[
    {
        "name": "src.chewingio.CheckAndResetRange#461",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.CheckAndResetRange( ChewingData *pgdata )",
        "snippet": "static void CheckAndResetRange( ChewingData *pgdata )\n{\n\tif ( pgdata->PointStart > -1 ) {\n\t\tpgdata->PointStart = -1;\n\t\tpgdata->PointEnd = 0;\n\t}\n}",
        "begin_line": 461,
        "end_line": 467,
        "is_bug": false
    },
    {
        "name": "src.chewingio.DoSelect#469",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.DoSelect( ChewingData *pgdata, int num )",
        "snippet": "static int DoSelect( ChewingData *pgdata, int num )\n{\n\tassert( pgdata->choiceInfo.pageNo >= 0 );\n\tif ( num >= 0 ) {\n\t\tnum += pgdata->choiceInfo.pageNo * pgdata->choiceInfo.nChoicePerPage;\n\t\t/* Note: if num is larger than the total, there will be big troubles. */\n\t\tif ( num < pgdata->choiceInfo.nTotalChoice ) {\n\t\t\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE ) {\n\t\t\t\tSymbolChoice( pgdata, num );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t/* change the select interval & selectStr & nSelect */\n\t\t\t\tAddSelect( pgdata, num );\n\t\t\t\t/* second, call choice module */\n\t\t\t\tChoiceSelect( pgdata, num );\n\t\t\t\t/* automatically shift the cursor to next phrase */\n\t\t\t\tif ( pgdata->config.bAutoShiftCur != 0 &&\n\t\t\t\t     /* if cursor at end of string, do not shift the cursor. */\n\t\t\t\t     pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {\n\t\t\t\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\t\t\t\t++pgdata->chiSymbolCursor;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpgdata->chiSymbolCursor +=\n\t\t\t\t\t\t\tpgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 469,
        "end_line": 500,
        "is_bug": false
    },
    {
        "name": "src.chewingio.NullLogger#118",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.NullLogger( void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)",
        "snippet": "static void NullLogger( void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)\n{\n}",
        "begin_line": 118,
        "end_line": 120,
        "is_bug": false
    },
    {
        "name": "src.chewingio.allocate_ChewingData#122",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.allocate_ChewingData()",
        "snippet": "static ChewingData * allocate_ChewingData()\n{\n\tstatic const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };\n\n\tChewingData *data = ALC( ChewingData, 1 );\n\tif ( data ) {\n\t\tdata->config.candPerPage = MAX_SELKEY;\n\t\tdata->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;\n\t\tdata->logger = NullLogger;\n\t\tmemcpy( data->config.selKey, DEFAULT_SELKEY, sizeof( data->config.selKey ) );\n\t}\n\n\treturn data;\n}",
        "begin_line": 122,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_Reset#216",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_Reset( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_Reset( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingStaticData static_data;\n\tChewingConfigData old_config;\n\tvoid (*logger)( void *data, int level, const char *fmt, ...);\n\n\t/* Backup old config and restore it after clearing pgdata structure. */\n\told_config = pgdata->config;\n\tstatic_data = pgdata->static_data;\n\tlogger = pgdata->logger;\n\tmemset( pgdata, 0, sizeof( ChewingData ) );\n\tpgdata->config = old_config;\n\tpgdata->static_data = static_data;\n\tpgdata->logger = logger;\n\n\t/* zuinData */\n\tmemset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );\n\n\t/* choiceInfo */\n\tmemset( &( pgdata->choiceInfo ), 0, sizeof( ChoiceInfo ) );\n\n\tpgdata->chiSymbolCursor = 0;\n\tpgdata->chiSymbolBufLen = 0;\n\tpgdata->nPhoneSeq = 0;\n\tmemset( pgdata->bUserArrCnnct, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tmemset( pgdata->bUserArrBrkpt, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tpgdata->bChiSym = CHINESE_MODE;\n\tpgdata->bFullShape = HALFSHAPE_MODE;\n\tpgdata->bSelect = 0;\n\tpgdata->nSelect = 0;\n\tpgdata->PointStart = -1;\n\tpgdata->PointEnd = 0;\n\tpgdata->phrOut.nNumCut = 0;\n\treturn 0;\n}",
        "begin_line": 216,
        "end_line": 251,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_delete#278",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_delete( ChewingContext *ctx )",
        "snippet": "CHEWING_API void chewing_delete( ChewingContext *ctx )\n{\n\tif ( ctx ) {\n\t\tif ( ctx->data ) {\n\t\t\tTerminatePinyin( ctx->data );\n\t\t\tTerminateEasySymbolTable( ctx->data );\n\t\t\tTerminateSymbolTable( ctx->data );\n\t\t\tTerminateHash( ctx->data );\n\t\t\tTerminateTree( ctx->data );\n\t\t\tTerminateDict( ctx->data );\n\t\t\tfree( ctx->data );\n\t\t}\n\n\t\tif ( ctx->output )\n\t\t\tfree( ctx->output);\n\t\tfree( ctx );\n\t}\n\treturn;\n}",
        "begin_line": 278,
        "end_line": 296,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_free#298",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_free( void *p )",
        "snippet": "CHEWING_API void chewing_free( void *p )\n{\n\tif ( p )\n\t\tfree( p );\n\treturn;\n}",
        "begin_line": 298,
        "end_line": 303,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_get_ChiEngMode#445",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_get_ChiEngMode( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_get_ChiEngMode( ChewingContext *ctx )\n{\n\treturn ctx->data->bChiSym;\n}",
        "begin_line": 445,
        "end_line": 448,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_get_phoneSeq#1399",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_get_phoneSeq( ChewingContext *ctx )",
        "snippet": "CHEWING_API unsigned short *chewing_get_phoneSeq( ChewingContext *ctx )\n{\n\tuint16_t *seq;\n\tseq = ALC( uint16_t, ctx->data->nPhoneSeq );\n\tif ( seq )\n\t\tmemcpy( seq, ctx->data->phoneSeq, sizeof(uint16_t)*ctx->data->nPhoneSeq );\n\treturn seq;\n}",
        "begin_line": 1399,
        "end_line": 1406,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_get_phoneSeqLen#1408",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_get_phoneSeqLen( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_get_phoneSeqLen( ChewingContext *ctx )\n{\n\treturn ctx->data->nPhoneSeq;\n}",
        "begin_line": 1408,
        "end_line": 1411,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Backspace#640",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Backspace( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Backspace( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tif ( ! pgdata->bSelect ) {\n\t\tif ( ZuinIsEntering( &( pgdata->zuinData ) ) ) {\n\t\t\tZuinRemoveLast( &( pgdata->zuinData ) );\n\t\t}\n\t\telse if ( pgdata->chiSymbolCursor > 0 ) {\n\t\t\tChewingKillChar(\n\t\t\t\tpgdata,\n\t\t\t\tpgdata->chiSymbolCursor - 1,\n\t\t\t\tDECREASE_CURSOR );\n\t\t}\n\t\tCallPhrasing( pgdata, 0 );\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\n\treturn 0;\n}",
        "begin_line": 640,
        "end_line": 667,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Capslock#914",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Capslock( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Capslock( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\n\tpgdata->bChiSym = 1 - pgdata->bChiSym;\n\tMakeOutputWithRtn( pgo, pgdata, KEYSTROKE_ABSORB );\n\treturn 0;\n}",
        "begin_line": 914,
        "end_line": 922,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Default#1026",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Default( ChewingContext *ctx, int key )",
        "snippet": "CHEWING_API int chewing_handle_Default( ChewingContext *ctx, int key )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint rtn, num;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint bQuickCommit = 0;\n\n\t/* Update lifetime */\n\tctx->data->static_data.chewing_lifetime++;\n\n\t/* Skip the special key */\n\tif ( key & 0xFF00 ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\tgoto End_KeyDefault;\n\t}\n\n\t/* We ignore non-printable input */\n\tif ( ! isprint( key ) )\n\t\tgoto End_KeyDefault;\n\n\tCheckAndResetRange( pgdata );\n\n\tDEBUG_CHECKPOINT();\n\tDEBUG_OUT( \"   key=%d\", key );\n\n\t/* Dvorak Hsu */\n\tif ( pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {\n\t\tkey = dvorak_convert( key );\n\t}\n\n\t/* selecting */\n\tif ( pgdata->bSelect ) {\n\t\tif ( key == ' ' )\n\t\t\treturn chewing_handle_Right( ctx );\n\t\t/* num starts from 0 */\n\t\tnum = CountSelKeyNum( key, pgdata );\n\t\tif ( num >= 0 ) {\n\t\t\tDoSelect( pgdata, num );\n\t\t\tgoto End_keyproc;\n\t\t}\n\n\t\t/* Otherwise, use 'j' and 'k' for paging in selection mode */\n\t\tDEBUG_OUT(\n\t\t\t\"\\t\\tchecking paging key, got '%c'\\n\",\n\t\t\tkey );\n\t\tswitch ( key ) {\n\t\t\tcase 'j':\n\t\t\tcase 'J':\n\t\t\t\tif ( pgdata->chiSymbolCursor > 0 ) {\n\t\t\t\t\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\t\t\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\t\t\t\t}\n\t\t\t\t\tCheckAndResetRange( pgdata );\n\t\t\t\t\tpgdata->chiSymbolCursor--;\n\t\t\t\t\tif ( ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) )\n\t\t\t\t\t\tChoiceFirstAvail( pgdata );\n\t\t\t\t\telse\n\t\t\t\t\t\tOpenSymbolChoice( pgdata );\n\n\t\t\t\t}\n\t\t\t\tgoto End_Paging;\n\t\t\tcase 'k':\n\t\t\tcase 'K':\n\t\t\t\tif ( pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {\n\t\t\t\t\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\t\t\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\t\t\t\t}\n\t\t\t\t\tCheckAndResetRange( pgdata );\n\t\t\t\t\tpgdata->chiSymbolCursor++;\n\t\t\t\t\tif ( ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) )\n\t\t\t\t\t\tChoiceFirstAvail( pgdata );\n\t\t\t\t\telse\n\t\t\t\t\t\tOpenSymbolChoice( pgdata );\n\t\t\t\t}\n\t\t\t\tgoto End_Paging;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t/* editing */\n\telse {\n\t\tif ( pgdata->bChiSym == CHINESE_MODE ) {\n\t\t\tif ( pgdata->config.bEasySymbolInput != 0 ) {\n\t\t\t\tEasySymbolInput( key, pgdata );\n\t\t\t\tgoto End_keyproc;\n\t\t\t}\n\n\t\t\t/* open symbol table */\n\t\t\tif ( key == '`' ) {\n\t\t\t\tpgdata->bSelect = 1;\n\t\t\t\tpgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t\t\t\tHaninSymbolInput( pgdata );\n\t\t\t\tgoto End_KeyDefault;\n\t\t\t}\n\n\t\t\trtn = ZuinPhoInput( pgdata, key );\n\t\t\tDEBUG_OUT(\n\t\t\t\t\"\\t\\tChinese mode key, \"\n\t\t\t\t\"ZuinPhoInput return value = %d\\n\",\n\t\t\t\trtn );\n\n\t\t\tif ( rtn == ZUIN_KEY_ERROR )\n\t\t\t\trtn = SpecialSymbolInput( key, pgdata );\n\t\t\tswitch ( rtn ) {\n\t\t\t\tcase ZUIN_ABSORB:\n\t\t\t\t\tkeystrokeRtn = KEYSTROKE_ABSORB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZUIN_COMMIT:\n\t\t\t\t\tAddChi( pgdata->zuinData.phone, pgdata->zuinData.phoneAlt, pgdata );\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZUIN_NO_WORD:\n\t\t\t\t\tkeystrokeRtn = KEYSTROKE_BELL | KEYSTROKE_ABSORB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ZUIN_KEY_ERROR:\n\t\t\t\tcase ZUIN_IGNORE:\n\t\t\t\t\tDEBUG_OUT(\n\t\t\t\t\t\t\"\\t\\tbefore isupper(key),key=%d\\n\",\n\t\t\t\t\t\tkey );\n\t\t\t\t\t/* change upper case into lower case */\n\t\t\t\t\tif ( isupper( key ) )\n\t\t\t\t\t\tkey = tolower( key );\n\n\t\t\t\t\tDEBUG_OUT(\n\t\t\t\t\t\t\"\\t\\tafter isupper(key),key=%d\\n\",\n\t\t\t\t\t\tkey );\n\n\t\t\t\t\t/* see if buffer contains nothing */\n\t\t\t\t\tif ( pgdata->chiSymbolBufLen == 0 ) {\n\t\t\t\t\t\tbQuickCommit = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( pgdata->config.bEasySymbolInput == 0 ) {\n\t\t\t\t\t\tif ( pgdata->bFullShape )\n\t\t\t\t\t\t\trtn = FullShapeSymbolInput( key, pgdata );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\trtn = SymbolInput( key, pgdata );\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( rtn == SYMBOL_KEY_ERROR ) {\n\t\t\t\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * If the key is not a printable symbol,\n\t\t\t\t\t\t * then it's wrong to commit it.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tbQuickCommit = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tkeystrokeRtn = KEYSTROKE_ABSORB;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\t\t/* English mode */\n\t\telse {\n\t\t\t/* see if buffer contains nothing */\n\t\t\tif ( pgdata->chiSymbolBufLen == 0 ) {\n\t\t\t\tbQuickCommit = 1;\n\t\t\t}\n\t\t\tif ( pgdata->bFullShape ) {\n\t\t\t\trtn = FullShapeSymbolInput( key, pgdata );\n\t\t\t}\n\t\t\telse {\n\t\t\t\trtn = SymbolInput( key, pgdata );\n\t\t\t}\n\n\t\t\tif ( rtn == SYMBOL_KEY_ERROR ) {\n\t\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t\t\t\tbQuickCommit = 0;\n\t\t\t}\n\t\t}\n\t}\n\nEnd_keyproc:\n\tif ( ! bQuickCommit ) {\n\t\tCallPhrasing( pgdata, 0 );\n\t\tif ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )\n\t\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t}\n\t/* Quick commit */\n\telse {\n\t\tDEBUG_OUT(\n\t\t\t\t\"\\t\\tQuick commit buf[0]=%c\\n\",\n\t\t\t\tpgdata->chiSymbolBuf[ 0 ].s[ 0 ] );\n\t\tpgo->commitStr[ 0 ] = pgdata->chiSymbolBuf[ 0 ];\n\t\tpgo->nCommitStr = 1;\n\t\tpgdata->chiSymbolBufLen = 0;\n\t\tpgdata->chiSymbolCursor = 0;\n\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t}\n\n\tif ( pgdata->phrOut.nNumCut > 0 ) {\n\t\tint i;\n\t\tfor ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {\n\t\t\tpgdata->bUserArrBrkpt[ pgdata->phrOut.dispInterval[ i ].from ] = 1;\n\t\t\tpgdata->bUserArrBrkpt[ pgdata->phrOut.dispInterval[ i ].to ] = 1;\n\t\t}\n\t\tpgdata->phrOut.nNumCut = 0;\n\t}\n\nEnd_KeyDefault:\n\tCallPhrasing( pgdata, 0 );\nEnd_Paging:\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1026,
        "end_line": 1233,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Del#613",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Del( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Del( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tif ( ! pgdata->bSelect ) {\n\t\tif (\n\t\t\t! ZuinIsEntering( &( pgdata->zuinData ) ) &&\n\t\t\tpgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {\n\t\t\tChewingKillChar(\n\t\t\t\tpgdata,\n\t\t\t\tpgdata->chiSymbolCursor,\n\t\t\t\tNONDECREASE_CURSOR );\n\t\t}\n\t\tCallPhrasing( pgdata, 0 );\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 613,
        "end_line": 638,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Down#700",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Down( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Down( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint toSelect = 0;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint key_buf_cursor;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tkey_buf_cursor = pgdata->chiSymbolCursor;\n\t// FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.\n\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )\n\t\tkey_buf_cursor--;\n\n\t/* see if to select */\n\tif ( ChewingIsChiAt( key_buf_cursor, pgdata ) )\n\t\t\ttoSelect = 1;\n\n\tchooseCandidate( ctx, toSelect, key_buf_cursor );\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 700,
        "end_line": 727,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_End#942",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_End( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_End( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( ! pgdata->bSelect ) {\n\t\tpgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 942,
        "end_line": 958,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Enter#562",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Enter( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Enter( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint nCommitStr = pgdata->chiSymbolBufLen;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( pgdata->bSelect ) {\n\t\tkeystrokeRtn = KEYSTROKE_ABSORB | KEYSTROKE_BELL;\n\t}\n\telse if ( pgdata->PointStart > -1 ) {\n\t\tint buf = pgdata->chiSymbolCursor;\n\t\tint key;\n\t\tif ( pgdata->PointEnd > 1 ) {\n\t\t\tif ( ! pgdata->config.bAddPhraseForward ) {\n\t\t\t\tpgdata->chiSymbolCursor = pgdata->PointStart;\n\t\t\t\tkey = '0' + pgdata->PointEnd;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpgdata->chiSymbolCursor = pgdata->PointStart + pgdata->PointEnd;\n\t\t\t\tkey = '0' + pgdata->PointEnd;\n\t\t\t}\n\n\t\t\tchewing_handle_CtrlNum( ctx, key );\n\t\t\tpgdata->chiSymbolCursor = buf;\n\t\t}\n\t\telse if ( pgdata->PointEnd < 1 ) {\n\t\t\tif ( pgdata->config.bAddPhraseForward )\n\t\t\t\tpgdata->chiSymbolCursor = buf - pgdata->PointEnd;\n\t\t\tkey = '0' - pgdata->PointEnd;\n\t\t\tchewing_handle_CtrlNum( ctx, key );\n\t\t\tpgdata->chiSymbolCursor = buf;\n\t\t}\n\t\tpgdata->PointStart = -1;\n\t\tpgdata->PointEnd = 0;\n\t}\n\telse {\n\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t\tWriteChiSymbolToBuf( pgo->commitStr, nCommitStr, pgdata );\n\t\tAutoLearnPhrase( pgdata );\n\t\tCleanAllBuf( pgdata );\n\t\tpgo->nCommitStr = nCommitStr;\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 562,
        "end_line": 611,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Esc#536",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Esc( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Esc( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( pgdata->bSelect ) {\n\t\tChoiceEndChoice( pgdata );\n\t}\n\telse if ( ZuinIsEntering( &( pgdata->zuinData ) ) ) {\n\t\tZuinRemoveAll( &( pgdata->zuinData ) );\n\t}\n\telse if ( pgdata->config.bEscCleanAllBuf ) {\n\t\tCleanAllBuf( pgdata );\n\t\tpgo->nCommitStr = pgdata->chiSymbolBufLen;\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 536,
        "end_line": 560,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Home#924",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Home( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Home( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( ! pgdata->bSelect ) {\n\t\tpgdata->chiSymbolCursor = 0;\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 924,
        "end_line": 940,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Left#761",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Left( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Left( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tif ( pgdata->bSelect ) {\n\t\tassert( pgdata->choiceInfo.nPage > 0 );\n\t\tif ( pgdata->choiceInfo.pageNo > 0 )\n\t\t\tpgdata->choiceInfo.pageNo--;\n\t\telse\n\t\t\tpgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;\n\t}\n\telse {\n\t\tif (\n\t\t\t! ZuinIsEntering( &( pgdata->zuinData ) ) &&\n\t\t\tpgdata->chiSymbolCursor > 0 ) {\n\t\t\tCheckAndResetRange( pgdata );\n\t\t\tpgdata->chiSymbolCursor--;\n\t\t}\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 761,
        "end_line": 788,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Numlock#1348",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Numlock( ChewingContext *ctx, int key )",
        "snippet": "CHEWING_API int chewing_handle_Numlock( ChewingContext *ctx, int key )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint rtn, QuickCommit = 0;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( ! pgdata->bSelect ) {\n\t\t/* If we're not selecting words, we should send out numeric\n\t\t * characters at once.\n\t\t */\n\t\tif ( pgdata->chiSymbolBufLen == 0 ) {\n\t\t\tQuickCommit = 1;\n\t\t}\n\t\trtn = SymbolInput( key, pgdata );\n\t\t/* copied from chewing_handle_Default */\n\t\tif ( rtn == SYMBOL_KEY_ERROR ) {\n\t\t\tkeystrokeRtn = KEYSTROKE_IGNORE ;\n\t\t}\n\t\telse if ( QuickCommit ) {\n\t\t\tpgo->commitStr[ 0 ] = pgdata->chiSymbolBuf[ 0 ];\n\t\t\tpgo->nCommitStr = 1;\n\t\t\tpgdata->chiSymbolBufLen = 0;\n\t\t\tpgdata->chiSymbolCursor = 0;\n\t\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t\t}\n\t\telse {\t/* Not quick commit */\n\t\t\tCallPhrasing( pgdata, 0 );\n\t\t\tif( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )\n\t\t\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\t\t}\n\t}\n\telse {\n\t\t/* Otherwise, if we are selecting words, we use numeric keys\n\t\t * as selkey\n\t\t * and submit the words.\n\t\t */\n\t\tint num = -1;\n\t\tif ( key > '0' && key < '9' )\n\t\t\tnum = key - '1';\n\t\telse if ( key == '0' )\n\t\t\tnum = 9;\n\t\tDoSelect( pgdata, num );\n\t}\n\tCallPhrasing( pgdata, 0 );\n\tif ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )\n\t\tkeystrokeRtn = KEYSTROKE_COMMIT;\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 1348,
        "end_line": 1397,
        "is_bug": true
    },
    {
        "name": "src.chewingio.chewing_handle_PageDown#978",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_PageDown( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_PageDown( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( ! pgdata->bSelect ) {\n\t\tpgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 978,
        "end_line": 994,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_PageUp#960",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_PageUp( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_PageUp( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\telse if ( ! pgdata->bSelect ) {\n\t\tpgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 960,
        "end_line": 976,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Right#823",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Right( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Right( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tif ( pgdata->bSelect ) {\n\t\tif ( pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1)\n\t\t\tpgdata->choiceInfo.pageNo++;\n\t\telse\n\t\t\tpgdata->choiceInfo.pageNo = 0;\n\t}\n\telse {\n\t\tif (\n\t\t\t! ZuinIsEntering( &( pgdata->zuinData ) ) &&\n\t\t\tpgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {\n\t\t\tCheckAndResetRange( pgdata );\n\t\t\tpgdata->chiSymbolCursor++;\n\t\t}\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 823,
        "end_line": 850,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Space#502",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Space( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Space( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\n\t/*\n\t * Use chewing_handle_Default( ctx, ' ' ) to handle space when:\n\t * - \"space as selection\" mode is disable\n\t * - mode is not CHINESE_MODE\n\t * - has incompleted bopomofo (space is needed to complete it)\n\t */\n\tif ( !pgdata->config.bSpaceAsSelection\n\t     || pgdata->bChiSym != CHINESE_MODE\n\t     || ZuinIsEntering( &ctx->data->zuinData ) ) {\n\t\treturn chewing_handle_Default( ctx, ' ' );\n\t}\n\n\tCheckAndResetRange( pgdata );\n\n\t/*\n\t * space = right when the follogin conditions are true\n\t * 1. In select mode\n\t * 2. The candidate page is not last page\n\t *\n\t * Otherwise, space = down\n\t */\n\tif ( pgdata->bSelect &&\n\t     ctx->output->pci->pageNo < ctx->output->pci->nPage - 1 ) {\n\t\treturn chewing_handle_Right( ctx );\n\t} else {\n\t\treturn chewing_handle_Down( ctx );\n\t}\n\treturn 0;\n}",
        "begin_line": 502,
        "end_line": 534,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Tab#852",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Tab( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Tab( ChewingContext *ctx )\n{\n\tint cursor;\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint all_phrasing = 0;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\n\tif ( ! pgdata->bSelect ) {\n\t\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen ) {\n\t\t\tpgdata->phrOut.nNumCut++;\n\t\t\tall_phrasing = 1;\n\t\t}\n\t\telse if ( ChewingIsChiAt( pgdata->chiSymbolCursor - 1, pgdata ) ) {\n\t\t\tcursor = PhoneSeqCursor( pgdata );\n\t\t\tif ( IsPreferIntervalConnted( cursor, pgdata) ) {\n\t\t\t\tpgdata->bUserArrBrkpt[ cursor ] = 1;\n\t\t\t\tpgdata->bUserArrCnnct[ cursor ] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpgdata->bUserArrBrkpt[ cursor ] = 0;\n\t\t\t\tpgdata->bUserArrCnnct[ cursor ] = 1;\n\t\t\t}\n\t\t}\n\t\tCallPhrasing( pgdata, all_phrasing );\n\t}\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 852,
        "end_line": 887,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_handle_Up#669",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_handle_Up( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_handle_Up( ChewingContext *ctx )\n{\n\tChewingData *pgdata = ctx->data;\n\tChewingOutput *pgo = ctx->output;\n\tint keystrokeRtn = KEYSTROKE_ABSORB;\n\tint key_buf_cursor;\n\n\tCheckAndResetRange( pgdata );\n\n\tif ( ! ChewingIsEntering( pgdata ) ) {\n\t\tkeystrokeRtn = KEYSTROKE_IGNORE;\n\t}\n\n\tkey_buf_cursor = pgdata->chiSymbolCursor;\n\t// FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.\n\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )\n\t\tkey_buf_cursor--;\n\n\t// XXX: Why close symbol choice list, but not word choice list.\n\tif ( ! pgdata->symbolKeyBuf[ key_buf_cursor ] ) {\n\t\t/* Close Symbol Choice List */\n\t\tif ( pgdata->bSelect ) {\n\t\t\t// FIXME: why we need to close the candidate list here?\n\t\t\tChoiceEndChoice( pgdata );\n\t\t}\n\t}\n\n\tMakeOutputWithRtn( pgo, pgdata, keystrokeRtn );\n\treturn 0;\n}",
        "begin_line": 669,
        "end_line": 698,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_set_autoShiftCur#406",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_set_autoShiftCur( ChewingContext *ctx, int mode )",
        "snippet": "CHEWING_API void chewing_set_autoShiftCur( ChewingContext *ctx, int mode )\n{\n\tif ( mode == 0 || mode == 1 )\n\t\tctx->data->config.bAutoShiftCur = mode;\n}",
        "begin_line": 406,
        "end_line": 410,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_set_maxChiSymbolLen#331",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_set_maxChiSymbolLen( ChewingContext *ctx, int n )",
        "snippet": "CHEWING_API void chewing_set_maxChiSymbolLen( ChewingContext *ctx, int n )\n{\n\tif ( MIN_CHI_SYMBOL_LEN <= n && n <= MAX_CHI_SYMBOL_LEN )\n\t\tctx->data->config.maxChiSymbolLen = n;\n}",
        "begin_line": 331,
        "end_line": 335,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_set_phraseChoiceRearward#428",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_set_phraseChoiceRearward( ChewingContext *ctx, int mode )",
        "snippet": "CHEWING_API void chewing_set_phraseChoiceRearward( ChewingContext *ctx, int mode )\n{\n\tif ( mode == 0 || mode == 1 )\n\t\tctx->data->config.bPhraseChoiceRearward = mode;\n}",
        "begin_line": 428,
        "end_line": 432,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chewing_set_spaceAsSelection#372",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chewing_set_spaceAsSelection( ChewingContext *ctx, int mode )",
        "snippet": "CHEWING_API void chewing_set_spaceAsSelection( ChewingContext *ctx, int mode )\n{\n\tif ( mode == 0 || mode == 1 )\n\t\tctx->data->config.bSpaceAsSelection = mode;\n}",
        "begin_line": 372,
        "end_line": 376,
        "is_bug": false
    },
    {
        "name": "src.chewingio.chooseCandidate#91",
        "src_path": "src/chewingio.c",
        "class_name": "src.chewingio",
        "signature": "src.chewingio.chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )",
        "snippet": "static void chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )\n{\n\tChewingData *pgdata = ctx->data;\n\tif ( toSelect ) {\n\t\tif ( ! pgdata->bSelect ) {\n\t\t\tChoiceFirstAvail( pgdata );\n\t\t} else {\n\t\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\t\tint avail_willbe = (pgdata->availInfo.currentAvail > 0) ?\n\t\t\t\t\tpgdata->availInfo.currentAvail - 1 :\n\t\t\t\t\tpgdata->availInfo.nAvail - 1;\n\t\t\t\tpgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor -\n\t\t\t\t\tpgdata->availInfo.avail[ avail_willbe ].len;\n\t\t\t\tif ( chewing_buffer_Len( ctx ) >\n\t\t\t\t\t\tpgdata->choiceInfo.oldChiSymbolCursor ) {\n\t\t\t\t\tpgdata->chiSymbolCursor++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tChoiceNextAvail( pgdata );\n\t\t}\n\t} else if ( pgdata->symbolKeyBuf[ key_buf_cursor ] ) {\n\t\t/* Open Symbol Choice List */\n\t\tif ( pgdata->choiceInfo.isSymbol == WORD_CHOICE )\n\t\t\tOpenSymbolChoice( pgdata );\n\t}\n}",
        "begin_line": 91,
        "end_line": 116,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AddChi#647",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )",
        "snippet": "int AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )\n{\n\tint i;\n\tint cursor = PhoneSeqCursor( pgdata );\n\n\t/* shift the selectInterval */\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from >= cursor ) {\n\t\t\tpgdata->selectInterval[ i ].from++;\n\t\t\tpgdata->selectInterval[ i ].to++;\n\t\t}\n\t}\n\n\t/* shift the Brkpt */\n\tassert( pgdata->nPhoneSeq >= cursor );\n\tmemmove(\n\t\t&( pgdata->bUserArrBrkpt[ cursor + 2 ] ),\n\t\t&( pgdata->bUserArrBrkpt[ cursor + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );\n\tmemmove(\n\t\t&( pgdata->bUserArrCnnct[ cursor + 2 ] ),\n\t\t&( pgdata->bUserArrCnnct[ cursor + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );\n\n\t/* add to phoneSeq */\n\tmemmove(\n\t\t&( pgdata->phoneSeq[ cursor + 1 ] ),\n\t\t&( pgdata->phoneSeq[ cursor ] ) ,\n\t\tsizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );\n\tpgdata->phoneSeq[ cursor ] = phone;\n\tmemmove(\n\t\t&( pgdata->phoneSeqAlt[ cursor + 1 ] ),\n\t\t&( pgdata->phoneSeqAlt[ cursor ] ) ,\n\t\tsizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );\n\tpgdata->phoneSeqAlt[ cursor ] = phoneAlt;\n\tpgdata->nPhoneSeq ++;\n\n\t/* add to chiSymbolBuf */\n\tassert( pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor );\n\tmemmove(\n\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ) ,\n\t\tsizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t/* \"0\" means Chinese word */\n\tpgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;\n\tpgdata->chiSymbolBufLen++;\n\tpgdata->chiSymbolCursor++;\n\n\treturn 0;\n}",
        "begin_line": 647,
        "end_line": 696,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AddSelect#963",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AddSelect( ChewingData *pgdata, int sel_i )",
        "snippet": "int AddSelect( ChewingData *pgdata, int sel_i )\n{\n\tint length, nSelect, cursor;\n\n\t/* save the typing time */\n\tlength = pgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;\n\tnSelect = pgdata->nSelect;\n\n\t/* change \"selectStr\" , \"selectInterval\" , and \"nSelect\" of ChewingData */\n\tueStrNCpy( pgdata->selectStr[ nSelect ],\n\t\t\tpgdata->choiceInfo.totalChoiceStr[ sel_i ],\n\t\t\tlength, 1 );\n\tcursor = PhoneSeqCursor( pgdata );\n\tpgdata->selectInterval[ nSelect ].from = cursor;\n\tpgdata->selectInterval[ nSelect ].to = cursor + length;\n\tpgdata->nSelect++;\n\treturn 0;\n}",
        "begin_line": 963,
        "end_line": 980,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.AutoLearnPhrase#606",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.AutoLearnPhrase( ChewingData *pgdata )",
        "snippet": "void AutoLearnPhrase( ChewingData *pgdata )\n{\n\tuint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];\n\tchar bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];\n\tint i, from, len;\n\tint prev_pos = 0;\n\tint pending = 0;\n\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tfrom = pgdata->preferInterval[ i ].from;\n\t\tlen = pgdata->preferInterval[i].to - from;\n\t\tif ( len == 1 && ! ChewingIsBreakPoint( from, pgdata ) ) {\n\t\t\tmemcpy( bufPhoneSeq + prev_pos, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );\n\t\t\tbufPhoneSeq[ prev_pos + len ] = (uint16_t) 0;\n\t\t\tueStrNCpy( ueStrSeek( bufWordSeq, prev_pos ),\n\t\t\t\t\tueStrSeek( (char *) &pgdata->phrOut.chiBuf, from ),\n\t\t\t\t\tlen, 1);\n\t\t\tprev_pos += len;\n\t\t\tpending = 1;\n\t\t}\n\t\telse {\n\t\t\tif ( pending ) {\n\t\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t\t\tprev_pos = 0;\n\t\t\t\tpending = 0;\n\t\t\t}\n\t\t\tmemcpy( bufPhoneSeq, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );\n\t\t\tbufPhoneSeq[ len ] = (uint16_t) 0;\n\t\t\tueStrNCpy( bufWordSeq,\n\t\t\t\t\tueStrSeek( (char *) &pgdata->phrOut.chiBuf, from ),\n\t\t\t\t\tlen, 1);\n\t\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\t}\n\t}\n\tif ( pending ) {\n\t\tUserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );\n\t\tprev_pos = 0;\n\t\tpending = 0;\n\t}\n}",
        "begin_line": 606,
        "end_line": 645,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CallPhrasing#743",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CallPhrasing( ChewingData *pgdata, int all_phrasing )",
        "snippet": "int CallPhrasing( ChewingData *pgdata, int all_phrasing )\n{\n\t/* set \"bSymbolArrBrkpt\" && \"bArrBrkpt\" */\n\tint i, ch_count = 0;\n\n\tmemcpy(\n\t\tpgdata->bArrBrkpt,\n\t\tpgdata->bUserArrBrkpt,\n\t\t(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );\n\tmemset(\n\t\tpgdata->bSymbolArrBrkpt, 0,\n\t\t(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );\n\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\tch_count++;\n\t\telse {\n\t\t\tpgdata->bArrBrkpt[ ch_count ] = 1;\n\t\t\tpgdata->bSymbolArrBrkpt[ ch_count ] = 1;\n\t\t}\n\t}\n\n\t/* kill select interval */\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ ) {\n\t\tif ( pgdata->bArrBrkpt[ i ] ) {\n\t\t\tChewingKillSelectIntervalAcross( i, pgdata );\n\t\t}\n\t}\n\n\tShowChewingData(pgdata);\n\n\t/* then phrasing */\n\tPhrasing( pgdata, all_phrasing );\n\n\t/* and then make prefer interval */\n\tMakePreferInterval( pgdata );\n\n\treturn 0;\n}",
        "begin_line": 743,
        "end_line": 781,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingIsBreakPoint#561",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsBreakPoint( int cursor, ChewingData *pgdata )",
        "snippet": "static int ChewingIsBreakPoint( int cursor, ChewingData *pgdata )\n{\n\tstatic const char * const break_word[] = {\n\t\t\"\\xE6\\x98\\xAF\", \"\\xE7\\x9A\\x84\", \"\\xE4\\xBA\\x86\", \"\\xE4\\xB8\\x8D\",\n\t\t/* \u662f              \u7684              \u4e86              \u4e0d */\n\t\t\"\\xE4\\xB9\\x9F\", \"\\xE8\\x80\\x8C\", \"\\xE4\\xBD\\xA0\", \"\\xE6\\x88\\x91\",\n\t\t/* \u4e5f              \u800c              \u4f60              \u6211 */\n\t\t\"\\xE4\\xBB\\x96\", \"\\xE8\\x88\\x87\", \"\\xE5\\xAE\\x83\", \"\\xE5\\xA5\\xB9\",\n\t\t/* \u4ed6              \u8207              \u5b83              \u5979 */\n\t\t\"\\xE5\\x85\\xB6\", \"\\xE5\\xB0\\xB1\", \"\\xE5\\x92\\x8C\", \"\\xE6\\x88\\x96\",\n\t\t/* \u5176              \u5c31              \u548c              \u6216 */\n\t\t\"\\xE5\\x80\\x91\", \"\\xE6\\x80\\xA7\", \"\\xE5\\x93\\xA1\", \"\\xE5\\xAD\\x90\",\n\t\t/* \u5011              \u6027              \u54e1              \u5b50 */\n\t\t\"\\xE4\\xB8\\x8A\", \"\\xE4\\xB8\\x8B\", \"\\xE4\\xB8\\xAD\", \"\\xE5\\x85\\xA7\",\n\t\t/* \u4e0a              \u4e0b              \u4e2d              \u5167 */\n\t\t\"\\xE5\\xA4\\x96\", \"\\xE5\\x8C\\x96\", \"\\xE8\\x80\\x85\", \"\\xE5\\xAE\\xB6\",\n\t\t/* \u5916              \u5316              \u8005              \u5bb6 */\n\t\t\"\\xE5\\x85\\x92\", \"\\xE5\\xB9\\xB4\", \"\\xE6\\x9C\\x88\", \"\\xE6\\x97\\xA5\",\n\t\t/* \u5152              \u5e74              \u6708              \u65e5 */\n\t\t\"\\xE6\\x99\\x82\", \"\\xE5\\x88\\x86\", \"\\xE7\\xA7\\x92\", \"\\xE8\\xA1\\x97\",\n\t\t/* \u6642              \u5206              \u79d2              \u8857 */\n\t\t\"\\xE8\\xB7\\xAF\", \"\\xE6\\x9D\\x91\",\n\t\t/* \u8def              \u6751 */\n\t\t\"\\xE5\\x9C\\xA8\",\n\t\t/* \u5728 */\n\t};\n\tchar buf[ MAX_UTF8_SIZE + 1 ];\n\tint i = 0, symbols = 0;\n\tfor ( i = 0; i < cursor; i++ )\n\t\tif ( ! ChewingIsChiAt ( i + symbols, pgdata ) )\n\t\t\tsymbols++;\n\tif ( ! ChewingIsChiAt( i + symbols, pgdata ) )\n\t\treturn 1;\n\telse {\n\t\tueStrNCpy( buf,\n\t\t\t\tueStrSeek( (char *) &pgdata->phrOut.chiBuf, cursor ),\n\t\t\t\t1, 1 );\n\t\tfor ( i = 0; (size_t) i < ARRAY_SIZE( break_word ); i++ ) {\n\t\t\tif ( ! strcmp ( buf, break_word[ i ] ) )\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid AutoLearnPhrase( ChewingData *pgdata )\n{\n\tuint16_t bufPhoneSeq[ MAX_PHO",
        "begin_line": 561,
        "end_line": 604,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingIsChiAt#1010",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )",
        "snippet": "int ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )\n{\n\t/* wch == 0 means Chinese */\n\treturn (\n\t\t( chiSymbolCursor < pgdata->chiSymbolBufLen ) &&\n\t\t( 0 <= chiSymbolCursor ) &&\n\t\t(pgdata->chiSymbolBuf[ chiSymbolCursor ].wch == 0 ) );\n}",
        "begin_line": 1010,
        "end_line": 1017,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingIsEntering#124",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingIsEntering( ChewingData *pgdata )",
        "snippet": "int ChewingIsEntering( ChewingData *pgdata )\n{\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE )\n\t\treturn 1;\n\treturn (\n\t\tpgdata->chiSymbolBufLen != 0 ||\n\t\tZuinIsEntering( &( pgdata->zuinData ) ) );\n}",
        "begin_line": 124,
        "end_line": 131,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingKillChar#1068",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingKillChar( \t\tChewingData *pgdata, int chiSymbolCursorToKill, int minus )",
        "snippet": "int ChewingKillChar(\n\t\tChewingData *pgdata,\n\t\tint chiSymbolCursorToKill,\n\t\tint minus )\n{\n\tint tmp, cursorToKill;\n\ttmp = pgdata->chiSymbolCursor;\n\tpgdata->chiSymbolCursor = chiSymbolCursorToKill;\n\tcursorToKill = PhoneSeqCursor( pgdata );\n\tpgdata->chiSymbolCursor = tmp;\n\tif ( ChewingIsChiAt( chiSymbolCursorToKill, pgdata ) ) {\n\t\tKillCharInSelectIntervalAndBrkpt(pgdata, cursorToKill);\n\t\tassert( pgdata->nPhoneSeq - cursorToKill - 1 >= 0 );\n\t\tmemmove(\n\t\t\t&( pgdata->phoneSeq[ cursorToKill ] ),\n\t\t\t&(pgdata->phoneSeq[ cursorToKill + 1 ] ),\n\t\t\t(pgdata->nPhoneSeq - cursorToKill - 1) * sizeof( uint16_t ) );\n\t\tpgdata->nPhoneSeq--;\n\t}\n\tpgdata->symbolKeyBuf[ chiSymbolCursorToKill ] = 0;\n\tassert( pgdata->chiSymbolBufLen - chiSymbolCursorToKill );\n\tmemmove(\n\t\t& pgdata->chiSymbolBuf[ chiSymbolCursorToKill ],\n\t\t& pgdata->chiSymbolBuf[ chiSymbolCursorToKill + 1 ],\n\t\t(pgdata->chiSymbolBufLen - chiSymbolCursorToKill) * sizeof( wch_t ) );\n\tpgdata->chiSymbolBufLen--;\n\tpgdata->chiSymbolCursor -= minus;\n\tif (pgdata->chiSymbolCursor < 0)\n\t\tpgdata->chiSymbolCursor = 0;\n\treturn 0;\n}",
        "begin_line": 1068,
        "end_line": 1098,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ChewingKillSelectIntervalAcross#1027",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ChewingKillSelectIntervalAcross( int cursor, ChewingData *pgdata )",
        "snippet": "static int ChewingKillSelectIntervalAcross( int cursor, ChewingData *pgdata )\n{\n\tint i;\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from < cursor &&\n\t\t\tpgdata->selectInterval[ i ].to > cursor ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 1027,
        "end_line": 1038,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CleanAllBuf#513",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CleanAllBuf( ChewingData *pgdata )",
        "snippet": "void CleanAllBuf( ChewingData *pgdata )\n{\n\t/* 1 */\n\tpgdata->nPhoneSeq = 0 ;\n\tmemset( pgdata->phoneSeq, 0, sizeof( pgdata->phoneSeq ) );\n\t/* 2 */\n\tpgdata->chiSymbolBufLen = 0;\n\tmemset( pgdata->chiSymbolBuf, 0, sizeof( pgdata->chiSymbolBuf ) );\n\t/* 3 */\n\tmemset( pgdata->bUserArrBrkpt, 0, sizeof( pgdata->bUserArrBrkpt ) );\n\t/* 4 */\n\tpgdata->nSelect = 0;\n\t/* 5 */\n\tpgdata->chiSymbolCursor = 0;\n\t/* 6 */\n\tmemset( pgdata->bUserArrCnnct, 0, sizeof( pgdata->bUserArrCnnct ) );\n\n\tpgdata->phrOut.nNumCut = 0;\n\n\tmemset( pgdata->symbolKeyBuf, 0, sizeof( pgdata->symbolKeyBuf ) );\n\n\tpgdata->nPrefer = 0;\n}",
        "begin_line": 513,
        "end_line": 535,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountReleaseNum#474",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountReleaseNum( ChewingData *pgdata )",
        "snippet": "static int CountReleaseNum( ChewingData *pgdata )\n{\n\tint remain, i;\n\n\tremain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;\n\tif ( remain >= 0 )\n\t\treturn 0;\n\n\tqsort(\n\t\tpgdata->preferInterval,\n\t\tpgdata->nPrefer,\n\t\tsizeof( IntervalType ),\n\t\t(CompFuncType) CompInterval );\n\n\tif ( ! ChewingIsChiAt( 0, pgdata ) ) {\n\t\tfor ( i = 0; i < pgdata->chiSymbolCursor; ++i ) {\n\t\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n\n\ti = FindIntervalFrom( 0, pgdata->preferInterval, pgdata->nPrefer );\n\tif ( i >= 0 ) {\n\t\treturn ( pgdata->preferInterval[ i ].to - pgdata->preferInterval[ i ].from );\n\t}\n\n\treturn 1;\n}",
        "begin_line": 474,
        "end_line": 503,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountSelKeyNum#982",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountSelKeyNum( int key, ChewingData *pgdata ) \t/* return value starts from 0.  If less than zero : error key */",
        "snippet": "int CountSelKeyNum( int key, ChewingData *pgdata )\n\t/* return value starts from 0.  If less than zero : error key */\n{\n\tint i;\n\n\tfor ( i = 0; i < MAX_SELKEY; i++ )\n\t\tif ( pgdata->config.selKey[ i ] == key )\n\t\t\treturn i;\n\treturn -1;\n}",
        "begin_line": 982,
        "end_line": 991,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.CountSymbols#993",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.CountSymbols( ChewingData *pgdata, int to )",
        "snippet": "int CountSymbols( ChewingData *pgdata, int to )\n{\n\tint chi;\n\tint i;\n\tfor ( chi = i = 0; i < to; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) )\n\t\t\tchi++;\n\t}\n\treturn to - chi;\n}",
        "begin_line": 993,
        "end_line": 1002,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.FindEasySymbolIndex#64",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.FindEasySymbolIndex( char ch )",
        "snippet": "static int FindEasySymbolIndex( char ch )\n{\n\t/**\n\t * '0' => 0, ..., '9' => 9\n\t * 'A' => 10, 'B' => 11, ... 'Z' => 35\n\t */\n\tif ( isdigit( ch ) ) {\n\t\treturn ch - '0';\n\t}\n\telse if ( isupper( ch ) ) {\n\t\treturn ch - 'A' + 10;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n}",
        "begin_line": 64,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.FindSymbolKey#1265",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.FindSymbolKey( const char *symbol )",
        "snippet": "static int FindSymbolKey( const char *symbol )\n{\n\tunsigned int i;\n\tconst char * const *buf;\n\tfor ( i = 0; i < ARRAY_SIZE( symbol_buf ); ++i ) {\n\t\tfor ( buf = symbol_buf[ i ]; *buf; ++buf )\t{\n\t\t\tif (  0 == strcmp( *buf, symbol ) )\n\t\t\t\treturn *symbol_buf[ i ][ 0 ];\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 1265,
        "end_line": 1276,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.HaninSymbolInput#133",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.HaninSymbolInput( ChewingData *pgdata )",
        "snippet": "int HaninSymbolInput( ChewingData *pgdata )\n{\n\tunsigned int i;\n\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\n\t/* No available symbol table */\n\tif ( ! pgdata->static_data.symbol_table )\n\t\treturn ZUIN_ABSORB;\n\n\tpci->nTotalChoice = 0;\n\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; i++ ) {\n\t\tstrcpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\tpgdata->static_data.symbol_table[ i ]->category );\n\t\tpci->nTotalChoice++;\n\t}\n\tpai->avail[ 0 ].len = 1;\n\tpai->avail[ 0 ].id = NULL;\n\tpai->nAvail = 1;\n\tpai->currentAvail = 0;\n\tpci->nChoicePerPage = pgdata->config.candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = SYMBOL_CATEGORY_CHOICE;\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 133,
        "end_line": 160,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.InitEasySymbolInput#1446",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.InitEasySymbolInput( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitEasySymbolInput( ChewingData *pgdata, const char *prefix )\n{\n\tstatic const size_t LINE_LEN = 512; // shall be long enough?\n\n\tFILE *file = NULL;\n\tchar *filename = NULL;\n\tchar *line = NULL;\n\tint len;\n\tint _index;\n\tchar *symbol;\n\tint ret = -1;\n\n\tret = asprintf( &filename, \"%s\" PLAT_SEPARATOR \"%s\",\n\t\t\tprefix, SOFTKBD_TABLE_FILE );\n\tif ( ret == -1 )\n\t\tgoto end;\n\n\tfile = fopen( filename, \"r\" );\n\tif ( !file )\n\t\tgoto end;\n\n\tline = ALC( char, LINE_LEN );\n\tif ( !line )\n\t\tgoto end;\n\n\twhile ( fgets( line, LINE_LEN, file ) ) {\n\t\tif ( ' ' != line[ 1 ] )\n\t\t\tcontinue;\n\n\t\t// Remove tailing \\n\n\t\tlen = strcspn( line, \"\\r\\n\" );\n\n\t\tline[ len ] = '\\0';\n\n\t\t_index = FindEasySymbolIndex( line[ 0 ] );\n\t\tif ( -1 == _index )\n\t\t\tcontinue;\n\n\t\tlen = ueStrLen( &line[ 2 ] );\n\t\tif ( 0 == len || len > MAX_PHRASE_LEN )\n\t\t\tcontinue;\n\n\t\tsymbol = ALC( char, strlen( &line[2] ) + 1 );\n\t\tif ( !symbol )\n\t\t\tgoto end;\n\n\t\tueStrNCpy( symbol, &line[ 2 ], len, 1 );\n\n\t\tfree( pgdata->static_data.g_easy_symbol_value[ _index ] );\n\t\tpgdata->static_data.g_easy_symbol_value[ _index ] = symbol;\n\t\tpgdata->static_data.g_easy_symbol_num[ _index ] = len;\n\t}\n\tret = 0;\nend:\n\tfree( line );\n\tfclose( file );\n\tfree ( filename );\n\treturn ret;\n}",
        "begin_line": 1446,
        "end_line": 1504,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.InitSymbolTable#1325",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.InitSymbolTable( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitSymbolTable( ChewingData *pgdata, const char *prefix )\n{\n\tstatic const unsigned int MAX_SYMBOL_ENTRY = 100;\n\tstatic const size_t LINE_LEN = 512; // shall be long enough?\n\n\tchar *filename = NULL;\n\tFILE *file = NULL;\n\tchar *line = NULL;\n\tSymbolEntry **entry = NULL;\n\tchar *category_end;\n\tconst char *symbols;\n\tconst char *symbols_end;\n\tconst char *symbol;\n\tsize_t i;\n\tsize_t len;\n\tsize_t size;\n\tint ret = -1;\n\n\tpgdata->static_data.n_symbol_entry = 0;\n\tpgdata->static_data.symbol_table = NULL;\n\n\tret = asprintf( &filename, \"%s\" PLAT_SEPARATOR \"%s\",\n\t\tprefix, SYMBOL_TABLE_FILE );\n\tif ( ret == -1 )\n\t\tgoto error;\n\n\tfile = fopen( filename, \"r\" );\n\tif ( !file )\n\t\tgoto error;\n\n\tline = ALC( char, LINE_LEN );\n\tif ( !line )\n\t\tgoto error;\n\n\tentry = ALC( SymbolEntry* , MAX_SYMBOL_ENTRY );\n\tif ( !entry )\n\t\tgoto error;\n\n\twhile ( fgets( line, LINE_LEN, file ) &&\n\t\tpgdata->static_data.n_symbol_entry < MAX_SYMBOL_ENTRY ) {\n\n\t\tcategory_end = strpbrk( line, \"=\\r\\n\" );\n\t\tif ( !category_end )\n\t\t\tgoto error;\n\n\t\tsymbols = category_end + 1;\n\t\tsymbols_end = strpbrk( symbols, \"\\r\\n\" );\n\t\tif ( symbols_end ) {\n\t\t\tlen = ueStrLen( symbols );\n\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ] =\n\t\t\t\t( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) +\n\t\t\t\t\tsizeof( entry[0][0].symbols[0] ) * len);\n\t\t\tif ( !entry[ pgdata->static_data.n_symbol_entry ] )\n\t\t\t\tgoto error;\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ]\n\t\t\t\t->nSymbols = len;\n\n\t\t\tsymbol = symbols;\n\n\t\t\tfor ( i = 0; i < len; ++i ) {\n\t\t\t\tueStrNCpy(\n\t\t\t\t\tentry[ pgdata->static_data.n_symbol_entry ]->symbols[ i ],\n\t\t\t\t\tsymbol, 1, 1 );\n\t\t\t\t// FIXME: What if symbol is combining sequences.\n\t\t\t\tsymbol += ueBytesFromChar( symbol[0] );\n\t\t\t}\n\n\n\t\t} else {\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ] =\n\t\t\t\t( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) );\n\t\t\tif ( !entry[ pgdata->static_data.n_symbol_entry ] )\n\t\t\t\tgoto error;\n\n\t\t\tentry[ pgdata->static_data.n_symbol_entry ]\n\t\t\t\t->nSymbols = 0;\n\t\t}\n\n\t\t*category_end = 0;\n\t\tueStrNCpy(\n\t\t\tentry[pgdata->static_data.n_symbol_entry]->category,\n\t\t\tline, MAX_PHRASE_LEN, 1);\n\n\t\t++pgdata->static_data.n_symbol_entry;\n\t}\n\n\tsize = sizeof( *pgdata->static_data.symbol_table ) *\n\t\tpgdata->static_data.n_symbol_entry;\n\tpgdata->static_data.symbol_table = ( SymbolEntry ** ) malloc( size );\n\tif ( !pgdata->static_data.symbol_table )\n\t\tgoto error;\n\tmemcpy( pgdata->static_data.symbol_table, entry, size );\n\n\tret = 0;\nend:\n\tfree( entry );\n\tfree( line );\n\tfclose( file );\n\tfree ( filename );\n\treturn ret;\n\nerror:\n\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i ) {\n\t\tfree( entry[ i ] );\n\t}\n\tgoto end;\n}",
        "begin_line": 1325,
        "end_line": 1432,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.IsPreferIntervalConnted#1100",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.IsPreferIntervalConnted( int cursor, ChewingData *pgdata )",
        "snippet": "int IsPreferIntervalConnted( int cursor, ChewingData *pgdata )\n{\n\tint i;\n\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tif (\n\t\t\tpgdata->preferInterval[ i ].from < cursor &&\n\t\t\tpgdata->preferInterval[ i ].to > cursor )\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 1100,
        "end_line": 1111,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.KillCharInSelectIntervalAndBrkpt#1040",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.KillCharInSelectIntervalAndBrkpt( ChewingData *pgdata, int cursorToKill )",
        "snippet": "static int KillCharInSelectIntervalAndBrkpt( ChewingData *pgdata, int cursorToKill )\n{\n\tint i;\n\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( pgdata->selectInterval[ i ].from <= cursorToKill &&\n\t\t\tpgdata->selectInterval[ i ].to > cursorToKill ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;      /* the last one was swap to i, we need to recheck i */\n\t\t}\n\t\telse if( pgdata->selectInterval[ i ].from > cursorToKill ) {\n\t\t\tpgdata->selectInterval[ i ].from--;\n\t\t\tpgdata->selectInterval[ i ].to--;\n\t\t}\n\t}\n\tassert ( pgdata->nPhoneSeq >= cursorToKill );\n\tmemmove(\n\t\t&( pgdata->bUserArrBrkpt[ cursorToKill ] ),\n\t\t&( pgdata->bUserArrBrkpt[ cursorToKill + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursorToKill ) );\n\tmemmove(\n\t\t&( pgdata->bUserArrCnnct[ cursorToKill ] ),\n\t\t&( pgdata->bUserArrCnnct[ cursorToKill + 1 ] ),\n\t\tsizeof( int ) * ( pgdata->nPhoneSeq - cursorToKill ) );\n\n\treturn 0;\n}",
        "begin_line": 1040,
        "end_line": 1066,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakeOutput#868",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )",
        "snippet": "static int MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )\n{\n\tint chi_i, chiSymbol_i, i ;\n\n\t/* fill zero to chiSymbolBuf first */\n\tmemset( pgo->chiSymbolBuf, 0, sizeof( wch_t ) * MAX_PHONE_SEQ_LEN );\n\n\t/* fill chiSymbolBuf */\n\tfor (\n\t\tchi_i = chiSymbol_i = 0;\n\t\tchiSymbol_i < pgdata->chiSymbolBufLen;\n\t\tchiSymbol_i ++ ) {\n\t\tif ( pgdata->chiSymbolBuf[ chiSymbol_i ].wch == 0 ) {\n\t\t\t/* is Chinese, then copy from the PhrasingOutput \"phrOut\" */\n\t\t\tpgo->chiSymbolBuf[ chiSymbol_i ].wch = 0;\n\t\t\tueStrNCpy( (char *) pgo->chiSymbolBuf[ chiSymbol_i ].s,\n\t\t\t           &( pgdata->phrOut.chiBuf[ chi_i ] ),\n\t\t\t           1, 1 );\n\t\t\tchi_i += ueBytesFromChar( pgo->chiSymbolBuf[ chiSymbol_i ].s[0] );\n\t\t}\n\t\telse {\n\t\t\t/* is Symbol */\n\t\t\tpgo->chiSymbolBuf[ chiSymbol_i ] = pgdata->chiSymbolBuf[ chiSymbol_i ];\n\t\t}\n\t}\n\n\t/* fill point */\n\tpgo->PointStart = pgdata->PointStart;\n\tpgo->PointEnd = pgdata->PointEnd;\n\n\t/* fill other fields */\n\tpgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;\n\tpgo->chiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* fill zuinBuf */\n\tif ( pgdata->zuinData.kbtype >= KB_HANYU_PINYIN ) {\n\t\tconst char *p = pgdata->zuinData.pinYinData.keySeq;\n\t\t/*\n\t\t * Copy from old content in zuinBuf\n\t\t * NOTE: No Unicode transformation here.\n\t\t */\n\t\tfor ( i = 0; i< ZUIN_SIZE; i++) {\n\t\t\tint j;\n\t\t\tfor ( j = 0; j < 2; j++ ) {\n\t\t\t\tif ( p[ 0 ] ) {\n\t\t\t\t\tpgo->zuinBuf[ i ].s[ j ] = p[ 0 ];\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpgo->zuinBuf[ i ].s[ j ] = '\\0';\n\t\t\t\t}\n\t\t\t}\n\t\t\tpgo->zuinBuf[ i ].s[ 2 ] = '\\0';\n\t\t}\n\t} else {\n\t\tfor ( i = 0; i < ZUIN_SIZE; i++ ) {\n\t\t\tif ( pgdata->zuinData.pho_inx[ i ] != 0 ) {\n\t\t\t\t/* Here we should use (zhuin_tab[i] + 2) to\n\t\t\t\t * skip the 2 space characters at\n\t\t\t\t * zhuin_tab[0] and zhuin_tab[1]. */\n\t\t\t\tueStrNCpy( (char *) pgo->zuinBuf[ i ].s,\n\t\t\t\t           ueConstStrSeek( (zhuin_tab[ i ] + 2),\n\t\t\t\t\t\t      pgdata->zuinData.pho_inx[ i ] - 1 ),\n\t\t\t\t           1, 1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tpgo->zuinBuf[ i ].wch = 0;\n\t\t}\n\t}\n\n\tShiftInterval( pgo, pgdata );\n\tmemcpy(\n\t\tpgo->dispBrkpt, pgdata->bUserArrBrkpt,\n\t\tsizeof( pgo->dispBrkpt[ 0 ] ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tpgo->pci = &( pgdata->choiceInfo );\n\tpgo->bChiSym = pgdata->bChiSym;\n\tmemcpy( pgo->selKey, pgdata->config.selKey, sizeof( pgdata->config.selKey ) );\n\tpgo->bShowMsg = 0;\n\treturn 0;\n}",
        "begin_line": 868,
        "end_line": 947,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakeOutputWithRtn#949",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )",
        "snippet": "int MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )\n{\n\tpgo->keystrokeRtn = keystrokeRtn;\n\treturn MakeOutput( pgo, pgdata );\n}",
        "begin_line": 949,
        "end_line": 953,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.MakePreferInterval#802",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.MakePreferInterval( ChewingData *pgdata )",
        "snippet": "static void MakePreferInterval( ChewingData *pgdata )\n{\n\tint i, j, set_no;\n\tint belong_set[ MAX_PHONE_SEQ_LEN + 1 ];\n\tint parent[ MAX_PHONE_SEQ_LEN + 1 ];\n\n\tmemset( belong_set, 0 , sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\tmemset( parent, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );\n\n\t/* for each interval */\n\tfor ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {\n\t\tfor (\n\t\t\tj = pgdata->phrOut.dispInterval[ i ].from;\n\t\t\tj < pgdata->phrOut.dispInterval[ i ].to;\n\t\t\tj++ ) {\n\t\t\tbelong_set[ j ] = i + 1;\n\t\t}\n\t}\n\tset_no = i + 1;\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ )\n\t\tif ( belong_set[i] == 0 )\n\t\t\tbelong_set[ i ] = set_no++;\n\n\t/* for each connect point */\n\tfor ( i = 1; i < pgdata->nPhoneSeq; i++ ) {\n\t\tif ( pgdata->bUserArrCnnct[ i ] ) {\n\t\t\tUnion( belong_set[ i - 1 ], belong_set[ i ], parent );\n\t\t}\n\t}\n\n\t/* generate new intervals */\n\tpgdata->nPrefer = 0;\n\ti = 0;\n\twhile ( i < pgdata->nPhoneSeq ) {\n\t\tfor ( j = i + 1; j < pgdata->nPhoneSeq; j++ )\n\t\t\tif ( ! SameSet( belong_set[ i ], belong_set[ j ], parent ) )\n\t\t\t\tbreak;\n\n\t\tpgdata->preferInterval[ pgdata->nPrefer ].from = i;\n\t\tpgdata->preferInterval[ pgdata->nPrefer ].to = j;\n\t\tpgdata->nPrefer++;\n\t\ti = j;\n\t}\n}",
        "begin_line": 802,
        "end_line": 845,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.OpenSymbolChoice#1278",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.OpenSymbolChoice( ChewingData *pgdata )",
        "snippet": "int OpenSymbolChoice( ChewingData *pgdata )\n{\n\tint i, symbol_buf_len = ARRAY_SIZE( symbol_buf );\n\tconst char * const *pBuf;\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tpci->oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* see if there is some word in the cursor position */\n\tif ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )\n\t\tpgdata->chiSymbolCursor--;\n\tif ( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] == '1' ) {\n\t\tpgdata->bSelect = 1;\n\t\tHaninSymbolInput( pgdata );\n\t\treturn 0;\n\t}\n\tfor ( i = 0; i < symbol_buf_len; i++ ) {\n\t\tif ( symbol_buf[ i ][ 0 ][ 0 ] ==\n\t\t\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ) {\n\t\t\tpBuf = symbol_buf[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif ( i == symbol_buf_len ) {\n\t\tChoiceEndChoice( pgdata );\n\t\treturn 0;\n\t}\n\tpci->nTotalChoice = 0;\n\tfor ( i = 1; pBuf[ i ]; i++ ) {\n\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\tpBuf[ i ], ueStrLen( pBuf[i] ), 1 );\n\t\tpci->nTotalChoice++;\n\t}\n\n\tpci->nChoicePerPage = pgdata->config.candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = SYMBOL_CHOICE_UPDATE;\n\n\tpgdata->bSelect = 1;\n\tpgdata->availInfo.nAvail = 1;\n\tpgdata->availInfo.currentAvail = 0;\n\tpgdata->availInfo.avail[ 0 ].id = NULL;\n\tpgdata->availInfo.avail[ 0 ].len = 1;\n\treturn 0;\n}",
        "begin_line": 1278,
        "end_line": 1323,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.PhoneSeqCursor#1004",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.PhoneSeqCursor( ChewingData *pgdata )",
        "snippet": "int PhoneSeqCursor( ChewingData *pgdata )\n{\n\tint cursor = pgdata->chiSymbolCursor - CountSymbols( pgdata, pgdata->chiSymbolCursor );\n\treturn cursor > 0 ? cursor : 0;\n}",
        "begin_line": 1004,
        "end_line": 1008,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ReleaseChiSymbolBuf#537",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )",
        "snippet": "int ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )\n{\n\tint throwEnd;\n\n\tthrowEnd = CountReleaseNum( pgdata );\n\n\tpgo->nCommitStr += throwEnd;\n\tif ( throwEnd ) {\n\t\t/*\n\t\t * count how many chinese words in \"chiSymbolBuf[ 0 .. (throwEnd - 1)]\"\n\t\t * And release from \"chiSymbolBuf\" && \"phoneSeq\"\n\t\t */\n\t\tWriteChiSymbolToBuf( pgo->commitStr, throwEnd, pgdata );\n\n\t\t/*\n\t\t * FIXME: analyze auto commit string and update userphrase\n\t\t * according to it.\n\t\t */\n\n\t\tKillFromLeft( pgdata, throwEnd );\n\t}\n\treturn throwEnd;\n}",
        "begin_line": 537,
        "end_line": 559,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.RemoveSelectElement#1019",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.RemoveSelectElement( int i, ChewingData *pgdata )",
        "snippet": "void RemoveSelectElement( int i, ChewingData *pgdata )\n{\n\tif ( --pgdata->nSelect == i )\n\t\treturn;\n\tpgdata->selectInterval[ i ] = pgdata->selectInterval[ pgdata->nSelect ];\n\tstrcpy( pgdata->selectStr[ i ], pgdata->selectStr[ pgdata->nSelect ] );\n}",
        "begin_line": 1019,
        "end_line": 1025,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SameSet#790",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SameSet( int set1, int set2, int parent[] )",
        "snippet": "static int SameSet( int set1,int set2, int parent[] )\n{\n\twhile ( parent[ set1 ] != 0 ) {\n\t\tset1 = parent[ set1 ];\n\t}\n\twhile ( parent[ set2 ] != 0 ) {\n\t\tset2 = parent[ set2 ];\n\t}\n\treturn ( set1 == set2 );\n}",
        "begin_line": 790,
        "end_line": 799,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ShiftInterval#848",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )",
        "snippet": "static void ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )\n{\n\tint i, arrPos[ MAX_PHONE_SEQ_LEN ], k = 0, from, len;\n\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\tarrPos[ k++ ] = i;\n\t\t}\n\t}\n\tarrPos[ k ] = i;\n\n\tpgo->nDispInterval = pgdata->nPrefer;\n\tfor ( i = 0; i < pgdata->nPrefer; i++ ) {\n\t\tfrom = pgdata->preferInterval[ i ].from;\n\t\tlen = pgdata->preferInterval[ i ].to - from;\n\t\tpgo->dispInterval[ i ].from = arrPos[ from ];\n\t\tpgo->dispInterval[ i ].to = arrPos[ from ] + len;\n\t}\n}",
        "begin_line": 848,
        "end_line": 866,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.ShowChewingData#698",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.ShowChewingData( ChewingData *pgdata )",
        "snippet": "static void ShowChewingData( ChewingData *pgdata )\n{\n\tint i ;\n\n\tDEBUG_OUT(\n\t\t\"nPhoneSeq : %d\\n\"\n\t\t\"phoneSeq  : \",\n\t\tpgdata->nPhoneSeq );\n\tfor ( i = 0; i < pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%hu \", pgdata->phoneSeq[ i ] );\n\tDEBUG_OUT(\n\t\t\"[cursor : %d]\\n\"\n\t\t\"nSelect : %d\\n\"\n\t\t\"selectStr       selectInterval\\n\",\n\t\tPhoneSeqCursor( pgdata ),\n\t\tpgdata->nSelect );\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tDEBUG_OUT(\n\t\t\t\"  %14s%4d%4d\\n\",\n\t\t\tpgdata->selectStr[ i ],\n\t\t\tpgdata->selectInterval[ i ].from,\n\t\t\tpgdata->selectInterval[ i ].to );\n\t}\n\n\tDEBUG_OUT( \"bUserArrCnnct : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bUserArrCnnct[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT( \"bUserArrBrkpt : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bUserArrBrkpt[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT( \"bArrBrkpt     : \" );\n\tfor ( i = 0; i <= pgdata->nPhoneSeq; i++ )\n\t\tDEBUG_OUT( \"%d \", pgdata->bArrBrkpt[ i ] );\n\tDEBUG_OUT( \"\\n\" );\n\n\tDEBUG_OUT(\n\t\t\"bChiSym : %d , bSelect : %d\\n\",\n\t\tpgdata->bChiSym,\n\t\tpgdata->bSelect );\n}",
        "begin_line": 698,
        "end_line": 741,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SymbolChoice#334",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SymbolChoice( ChewingData *pgdata, int sel_i )",
        "snippet": "int SymbolChoice( ChewingData *pgdata, int sel_i )\n{\n\tint kbtype;\n\tint i;\n\tint symbol_type;\n\tint key;\n\n\tif ( ! pgdata->static_data.symbol_table && pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_UPDATE )\n\t\treturn ZUIN_ABSORB;\n\n\tif ( pgdata->choiceInfo.isSymbol == SYMBOL_CATEGORY_CHOICE &&\n\t\t\t0 == pgdata->static_data.symbol_table[sel_i]->nSymbols )\n\t\tsymbol_type = SYMBOL_CHOICE_INSERT;\n\telse\n\t\tsymbol_type = pgdata->choiceInfo.isSymbol;\n\n\t/* level one, symbol category */\n\tif ( symbol_type == SYMBOL_CATEGORY_CHOICE ) {\n\t\tChoiceInfo* pci = &pgdata->choiceInfo;\n\t\tAvailInfo* pai = &pgdata->availInfo;\n\n\t\t/* Display all symbols in this category */\n\t\tpci->nTotalChoice = 0;\n\t\tfor ( i = 0; i < pgdata->static_data.symbol_table[ sel_i ]->nSymbols; i++ ) {\n\t\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\tpgdata->static_data.symbol_table[ sel_i ]->symbols[ i ], 1, 1 );\n\t\t\tpci->nTotalChoice++;\n\t\t}\n\t\tpai->avail[ 0 ].len = 1;\n\t\tpai->avail[ 0 ].id = NULL;\n\t\tpai->nAvail = 1;\n\t\tpai->currentAvail = 0;\n\t\tpci->nChoicePerPage = pgdata->config.candPerPage;\n\t\tassert( pci->nTotalChoice > 0 );\n\t\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\t\tpci->pageNo = 0;\n\t\tpci->isSymbol = SYMBOL_CHOICE_INSERT;\n\t}\n\telse { /* level 2 symbol or OpenSymbolChoice */\n\t\t/* TODO: FIXME, this part is buggy! */\n\t\tif ( symbol_type == SYMBOL_CHOICE_INSERT ) {\n\t\t\tassert( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\t\t\tmemmove(\n\t\t\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ),\n\t\t\t\tsizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t\t}\n\t\tpgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;\n\t\tueStrNCpy( (char *) pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].s,\n\t\t\t\tpgdata->choiceInfo.totalChoiceStr[ sel_i ], 1, 1);\n\n\t\t/* This is very strange */\n\t\tkey = FindSymbolKey( pgdata->choiceInfo.totalChoiceStr[ sel_i ] );\n\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = key ? key : '0';\n\n\t\tpgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;\n\t\tChoiceEndChoice(pgdata);\n\t\t/* Don't forget the kbtype */\n\t\tkbtype = pgdata->zuinData.kbtype;\n\t\tmemset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );\n\t\tpgdata->zuinData.kbtype = kbtype;\n\n\t\tif ( symbol_type == SYMBOL_CHOICE_INSERT ) {\n\t\t\tpgdata->chiSymbolBufLen++;\n\t\t\tpgdata->chiSymbolCursor ++ ;\n\t\t}\n\n\t\tpgdata->choiceInfo.isSymbol = WORD_CHOICE;\n\t}\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 334,
        "end_line": 404,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.SymbolInput#406",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.SymbolInput( int key, ChewingData *pgdata )",
        "snippet": "int SymbolInput( int key, ChewingData *pgdata )\n{\n\tif ( isprint( (char) key ) && /* other character was ignored */\n\t     (pgdata->chiSymbolBufLen < MAX_PHONE_SEQ_LEN) ) { /* protect the buffer */\n\t\tassert( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\t\tmemmove(\n\t\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t\t&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ),\n\t\t\tsizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\n\t\tpgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;\n\t\tpgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].s[ 0 ] = (char) key;\n\n\t\t/* Save Symbol Key */\n\t\tmemmove( &( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor + 1 ] ),\n\t\t\t&( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ),\n\t\t\tsizeof( pgdata->symbolKeyBuf[ 0 ] ) *\n\t\t\t( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );\n\t\t\tpgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = toupper( key );\n\n\t\tpgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;\n\t\tpgdata->chiSymbolCursor++;\n\t\tpgdata->chiSymbolBufLen++;\n\t\treturn SYMBOL_KEY_OK;\n\t}\n\treturn SYMBOL_KEY_ERROR;\n}",
        "begin_line": 406,
        "end_line": 432,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.TerminateEasySymbolTable#1506",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.TerminateEasySymbolTable( ChewingData *pgdata )",
        "snippet": "void TerminateEasySymbolTable( ChewingData *pgdata )\n{\n\tunsigned int i;\n\tfor ( i = 0; i < EASY_SYMBOL_KEY_TAB_LEN ; ++i ) {\n\t\tif ( NULL != pgdata->static_data.g_easy_symbol_value[ i ] ) {\n\t\t\tfree( pgdata->static_data.g_easy_symbol_value[ i ] );\n\t\t\tpgdata->static_data.g_easy_symbol_value[ i ] = NULL;\n\t\t}\n\t\tpgdata->static_data.g_easy_symbol_num[ i ] = 0;\n\t}\n}",
        "begin_line": 1506,
        "end_line": 1516,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.TerminateSymbolTable#1434",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.TerminateSymbolTable( ChewingData *pgdata )",
        "snippet": "void TerminateSymbolTable( ChewingData *pgdata )\n{\n\tunsigned int i;\n\tif ( pgdata->static_data.symbol_table ) {\n\t\tfor ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i )\n\t\t\tfree( pgdata->static_data.symbol_table[ i ] );\n\t\tfree( pgdata->static_data.symbol_table );\n\t\tpgdata->static_data.n_symbol_entry = 0;\n\t\tpgdata->static_data.symbol_table = NULL;\n\t}\n}",
        "begin_line": 1434,
        "end_line": 1444,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.Union#784",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.Union( int set1, int set2, int parent[] )",
        "snippet": "static void Union( int set1,int set2, int parent[] )\n{\n\tif ( set1 != set2 )\n\t\tparent[ max( set1, set2 ) ] = min( set1, set2 );\n}",
        "begin_line": 784,
        "end_line": 788,
        "is_bug": false
    },
    {
        "name": "src.chewingutil.WriteChiSymbolToBuf#452",
        "src_path": "src/chewingutil.c",
        "class_name": "src.chewingutil",
        "signature": "src.chewingutil.WriteChiSymbolToBuf( wch_t csBuf[], int csBufLen, ChewingData *pgdata )",
        "snippet": "int WriteChiSymbolToBuf( wch_t csBuf[], int csBufLen, ChewingData *pgdata )\n{\n\tint i, phoneseq_i = 0;\n\n\tfor ( i = 0 ; i < csBufLen; i++ ) {\n\t\tif ( ChewingIsChiAt( i, pgdata ) ) {\n\t\t\t/*\n\t\t\t * Workaround to avoid different initialization behavior\n\t\t\t * among Win32 and Unix-like OSs.\n\t\t\t */\n\t\t\tmemset( &( csBuf[ i ].s ), 0, MAX_UTF8_SIZE + 1 );\n\t\t\tueStrNCpy( (char *) csBuf[ i ].s,\n\t\t\t           &( pgdata->phrOut.chiBuf[ phoneseq_i ] ),\n\t\t\t\t   1, 1);\n\t\t\tphoneseq_i += ueBytesFromChar( pgdata->phrOut.chiBuf[ phoneseq_i ] );\n\t\t}\n\t\telse\n\t\t\tcsBuf[ i ] = pgdata->chiSymbolBuf[ i ];\n\t}\n\treturn 0;\n}",
        "begin_line": 452,
        "end_line": 472,
        "is_bug": false
    },
    {
        "name": "src.choice.ChangeSelectIntervalAndBreakpoint#33",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChangeSelectIntervalAndBreakpoint( \t\tChewingData *pgdata, int from, int to, const char *str )",
        "snippet": "static void ChangeSelectIntervalAndBreakpoint(\n\t\tChewingData *pgdata,\n\t\tint from,\n\t\tint to,\n\t\tconst char *str )\n{\n\tint i;\n\tint user_alloc;\n\n\tIntervalType inte;\n\n\tinte.from = from;\n\tinte.to = to;\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tif ( IsIntersect( inte, pgdata->selectInterval[ i ] ) ) {\n\t\t\tRemoveSelectElement( i, pgdata );\n\t\t\ti--;\n\t\t}\n\t}\n\n\tpgdata->selectInterval[ pgdata->nSelect ].from = from;\n\tpgdata->selectInterval[ pgdata->nSelect ].to = to;\n\n\t/* No available selection */\n\tif ( ( user_alloc = ( to - from ) ) == 0 )\n\t\treturn;\n\n\tueStrNCpy( pgdata->selectStr[ pgdata->nSelect ],\n\t\t\tstr,\n\t\t\tuser_alloc, 1);\n\tpgdata->nSelect++;\n\n\tif ( user_alloc > 1 ) {\n\t\tmemset( &pgdata->bUserArrBrkpt[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );\n\t\tmemset( &pgdata->bUserArrCnnct[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );\n\t}\n}",
        "begin_line": 33,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "src.choice.ChangeUserData#436",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChangeUserData( ChewingData *pgdata, int selectNo )",
        "snippet": "static void ChangeUserData( ChewingData *pgdata, int selectNo )\n{\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\tint len;\n\n\tlen = ueStrLen( pgdata->choiceInfo.totalChoiceStr[ selectNo ] );\n\tmemcpy(\n\t\tuserPhoneSeq,\n\t\t&( pgdata->phoneSeq[ PhoneSeqCursor( pgdata ) ] ),\n\t\tlen * sizeof( uint16_t ) );\n\tuserPhoneSeq[ len ] = 0;\n\tUserUpdatePhrase( pgdata, userPhoneSeq, pgdata->choiceInfo.totalChoiceStr[ selectNo ] );\n}",
        "begin_line": 436,
        "end_line": 448,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceEndChoice#421",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceEndChoice( ChewingData *pgdata )",
        "snippet": "int ChoiceEndChoice( ChewingData *pgdata )\n{\n\tpgdata->bSelect = 0;\n\tpgdata->choiceInfo.nTotalChoice = 0;\n\tpgdata->choiceInfo.nPage = 0;\n\n\tif ( pgdata->choiceInfo.isSymbol != WORD_CHOICE || pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_INSERT ) {\n\t\t/* return to the old chiSymbolCursor position */\n\t\tpgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;\n\t\tassert ( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );\n\t}\n\tpgdata->choiceInfo.isSymbol = WORD_CHOICE;\n\treturn 0;\n}",
        "begin_line": 421,
        "end_line": 434,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceFirstAvail#369",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceFirstAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceFirstAvail( ChewingData *pgdata )\n{\n\tint end, begin;\n\n\t/* save old cursor position */\n\tpgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;\n\n\t/* see if there is some word in the cursor position */\n\tif ( pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor ) {\n\t\tpgdata->chiSymbolCursor--;\n\t}\n\n\tend = PhoneSeqCursor( pgdata );\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\tpgdata->chiSymbolCursor = SeekPhraseHead( pgdata ) +\n\t\t\tCountSymbols( pgdata, pgdata->chiSymbolCursor );\n\t}\n\tbegin = PhoneSeqCursor( pgdata );\n\n\tpgdata->bSelect = 1;\n\n\tSetAvailInfo( pgdata, begin, end );\n\n\tif ( ! pgdata->availInfo.nAvail )\n\t\treturn ChoiceEndChoice( pgdata );\n\n\tpgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n\tSetChoiceInfo( pgdata );\n\treturn 0;\n}",
        "begin_line": 369,
        "end_line": 399,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceInfoAppendChi#179",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceInfoAppendChi( ChewingData *pgdata, ChoiceInfo *pci, uint16_t phone )",
        "snippet": "static void ChoiceInfoAppendChi( ChewingData *pgdata,  ChoiceInfo *pci, uint16_t phone )\n{\n\tPhrase tempWord;\n\tint len;\n\tif ( GetCharFirst( pgdata, &tempWord, phone ) ) {\n\t\tdo {\n\t\t\tlen = ueBytesFromChar( tempWord.phrase[ 0 ] );\n\t\t\tif ( ChoiceTheSame( pci, tempWord.phrase,\n\t\t\t\t\t    len) )\n\t\t\t\tcontinue;\n\t\t\tassert( pci->nTotalChoice < MAX_CHOICE );\n\t\t\tmemcpy(\n\t\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\ttempWord.phrase, len );\n\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ]\n\t\t\t\t\t   [ len ] = '\\0';\n\t\t\tpci->nTotalChoice++;\n\t\t} while ( GetVocabNext( pgdata, &tempWord ) );\n\t}\n}",
        "begin_line": 179,
        "end_line": 198,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceNextAvail#412",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceNextAvail( ChewingData *pgdata )",
        "snippet": "int ChoiceNextAvail( ChewingData *pgdata )\n{\n\tif (pgdata->choiceInfo.isSymbol) return 0;\n\tif ( --( pgdata->availInfo.currentAvail ) < 0 )\n\t\tpgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;\n\tSetChoiceInfo( pgdata );\n\treturn 0;\n}",
        "begin_line": 412,
        "end_line": 419,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceSelect#451",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceSelect( ChewingData *pgdata, int selectNo )",
        "snippet": "int ChoiceSelect( ChewingData *pgdata, int selectNo )\n{\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\n\tChangeUserData( pgdata, selectNo );\n\tChangeSelectIntervalAndBreakpoint(\n\t\t\tpgdata,\n\t\t\tPhoneSeqCursor( pgdata ),\n\t\t\tPhoneSeqCursor( pgdata ) + pai->avail[ pai->currentAvail ].len,\n\t\t\tpci->totalChoiceStr[ selectNo ] );\n\tChoiceEndChoice( pgdata );\n\treturn 0;\n}",
        "begin_line": 451,
        "end_line": 464,
        "is_bug": false
    },
    {
        "name": "src.choice.ChoiceTheSame#169",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )",
        "snippet": "static int ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )\n{\n\tint i;\n\n\tfor ( i = 0; i < pci->nTotalChoice; i++ )\n\t\tif ( ! memcmp( pci->totalChoiceStr[ i ], str, len ) )\n\t\t\treturn 1;\n\treturn 0;\n}",
        "begin_line": 169,
        "end_line": 177,
        "is_bug": false
    },
    {
        "name": "src.choice.SeekPhraseHead#355",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SeekPhraseHead( ChewingData *pgdata )",
        "snippet": "static int SeekPhraseHead( ChewingData *pgdata )\n{\n\tint i;\n\tint phoneSeq = PhoneSeqCursor( pgdata );\n\tfor ( i = pgdata->nPrefer - 1; i >= 0; i-- ) {\n\t\tif ( pgdata->preferInterval[ i ].from > phoneSeq\n\t\t\t\t|| pgdata->preferInterval[ i ].to < phoneSeq )\n\t\t\tcontinue;\n\t\treturn pgdata->preferInterval[ i ].from;\n\t}\n\treturn 0;\n}",
        "begin_line": 355,
        "end_line": 366,
        "is_bug": false
    },
    {
        "name": "src.choice.SetAvailInfo#72",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SetAvailInfo( ChewingData *pgdata, int begin, int end)",
        "snippet": "static void SetAvailInfo( ChewingData *pgdata, int begin, int end)\n{\n\tAvailInfo *pai = &( pgdata->availInfo );\n\tconst uint16_t *phoneSeq = pgdata->phoneSeq;\n\tint nPhoneSeq = pgdata->nPhoneSeq;\n\tconst int *bSymbolArrBrkpt = pgdata->bSymbolArrBrkpt;\n\tint symbolArrBrkpt[ ARRAY_SIZE(pgdata->bSymbolArrBrkpt) ] = { 0 };\n\n\tconst TreeType *tree_pos;\n\tint diff;\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tint i, head, head_tmp;\n\tint tail, tail_tmp;\n\tint pos;\n\n\thead = tail = 0;\n\n\tpai->nAvail = 0;\n\n\t/*\n\t * XXX: The phoneSeq, nPhoneSeq skip any symbol in preedit buffer,\n\t * while bSymbolArrBrkpt, does not skip any symbol in preedit\n\t * buffer. So we need to do some translate here.\n\t */\n\tfor ( i = 0; i < pgdata->chiSymbolBufLen; ++i ) {\n\t\tif ( bSymbolArrBrkpt[i] ) {\n\t\t\t/*\n\t\t\t * XXX: If preedit buffer starts with symbol, the pos\n\t\t\t * will become negative. In this case, we just ignore\n\t\t\t * this symbol because it does not create any break\n\t\t\t * point.\n\t\t\t */\n\t\t\tpos = i - CountSymbols( pgdata, i + 1 );\n\t\t\tif (pos >= 0)\n\t\t\t\tsymbolArrBrkpt[ pos ] = 1;\n\t\t}\n\t}\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\tfor ( i = end; i >= begin; i--){\n\t\t\tif ( symbolArrBrkpt[ i ] )\n\t\t\t\tbreak;\n\t\t\thead = i;\n\t\t}\n\t\thead_tmp = end;\n\t} else {\n\t\thead_tmp = head = begin;\n\t}\n\n\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\ttail_tmp = tail = end;\n\t} else {\n\t\tfor ( i = begin; i < nPhoneSeq; i++ ) {\n\t\t\ttail = i;\n\t\t\tif ( symbolArrBrkpt[ i ] )\n\t\t\t\tbreak;\n\t\t}\n\t\ttail_tmp = begin;\n\t}\n\n\twhile ( head <= head_tmp && tail_tmp <= tail ) {\n\t\tdiff = tail_tmp - head_tmp;\n\t\ttree_pos = TreeFindPhrase( pgdata, head_tmp, tail_tmp, phoneSeq );\n\n\t\tif ( tree_pos ) {\n\t\t\t/* save it! */\n\t\t\tpai->avail[ pai->nAvail ].len = diff + 1;\n\t\t\tpai->avail[ pai->nAvail ].id = tree_pos;\n\t\t\tpai->nAvail++;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(\n\t\t\t\tuserPhoneSeq,\n\t\t\t\t&phoneSeq[ head_tmp ],\n\t\t\t\tsizeof( uint16_t ) * ( diff + 1 ) ) ;\n\t\t\tuserPhoneSeq[ diff + 1 ] = 0;\n\t\t\tif ( UserGetPhraseFirst( pgdata, userPhoneSeq ) ) {\n\t\t\t\t/* save it! */\n\t\t\t\tpai->avail[ pai->nAvail ].len = diff + 1;\n\t\t\t\tpai->avail[ pai->nAvail ].id = NULL;\n\t\t\t\tpai->nAvail++;\n\t\t\t} else {\n\t\t\t\tpai->avail[ pai->nAvail ].len = 0;\n\t\t\t\tpai->avail[ pai->nAvail ].id = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif ( pgdata->config.bPhraseChoiceRearward ) {\n\t\t\thead_tmp--;\n\t\t} else {\n\t\t\ttail_tmp++;\n\t\t}\n\t}\n}",
        "begin_line": 72,
        "end_line": 166,
        "is_bug": false
    },
    {
        "name": "src.choice.SetChoiceInfo#206",
        "src_path": "src/choice.c",
        "class_name": "src.choice",
        "signature": "src.choice.SetChoiceInfo( ChewingData *pgdata )",
        "snippet": "static void SetChoiceInfo( ChewingData *pgdata )\n{\n\tPhrase tempPhrase;\n\tint len;\n\tUserPhraseData *pUserPhraseData;\n\tuint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tChoiceInfo *pci = &( pgdata->choiceInfo );\n\tAvailInfo *pai = &( pgdata->availInfo );\n\tuint16_t *phoneSeq = pgdata->phoneSeq;\n\tuint16_t *phoneSeqAlt = pgdata->phoneSeqAlt;\n\tint cursor = PhoneSeqCursor( pgdata );\n\tint candPerPage = pgdata->config.candPerPage;\n\n\t/* Clears previous candidates. */\n\tmemset( pci->totalChoiceStr, '\\0',\n\t\tMAX_CHOICE * MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1);\n\n\tpci->nTotalChoice = 0;\n\tlen = pai->avail[ pai->currentAvail ].len;\n\tassert(len);\n\n\t/* secondly, read tree phrase */\n\tif ( len == 1 ) { /* single character */\n\t\tChoiceInfoAppendChi( pgdata, pci, phoneSeq[ cursor ] );\n\n\t\tif ( phoneSeq[ cursor ] != phoneSeqAlt[ cursor ] ) {\n\t\t\tChoiceInfoAppendChi( pgdata, pci, phoneSeqAlt[ cursor ] );\n\t\t}\n\n\t\tif ( pgdata->zuinData.kbtype == KB_HSU ||\n\t\t     pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {\n\t\t\tswitch ( phoneSeq[ cursor ] ) {\n\t\t\t\tcase 0x2800:\t/* '\u3118' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x30 );\t\t/* '\u311f' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x80:\t/* '\u3127' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x20 );\t\t/* '\u311d' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2A00:\t/* '\u3119' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1 );\t\t/* '\u02d9' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0xA00:\t/* '\u3109' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x2 );\t\t/* '\u02ca' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x800:\t/* '\u3108' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x3 ); \t\t/* '\u02c7' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x18:\t/* '\u311c' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1200 );\t/* '\u310d' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x10:\t/* '\u311b' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1600 );\t/* '\u310f' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x1E00:\t/* '\u3113' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1800 );\t/* '\u3110' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x4 );\t\t/* '\u02cb' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x58:\t/* '\u3124' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1400 );\t/* '\u310e' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x68:\t/* '\u3126' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1000 );\t/* '\u310c' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x60 );\t\t/* '\u3125' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2200:\t/* '\u3115' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1C00 );\t/* '\u3112' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x2000:\t/* '\u3114' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x1A00 );\t/* '\u3111' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x50:\t/* '\u3123' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0xE00 );\t/* '\u310b' */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x48:\t/* '\u3122' */\n\t\t\t\t\tChoiceInfoAppendChi( pgdata, pci,\n\t\t\t\t\t\t0x600 );\t/* '\u3107' */\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* phrase */\n\telse {\n\t\tif ( pai->avail[ pai->currentAvail ].id ) {\n\t\t\tGetPhraseFirst( pgdata, &tempPhrase, pai->avail[ pai->currentAvail ].id );\n\t\t\tdo {\n\t\t\t\tif ( ChoiceTheSame(\n\t\t\t\t\tpci,\n\t\t\t\t\ttempPhrase.phrase,\n\t\t\t\t\tlen * ueBytesFromChar( tempPhrase.phrase[0] ) ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\t\ttempPhrase.phrase, len, 1);\n\t\t\t\tpci->nTotalChoice++;\n\t\t\t} while( GetVocabNext( pgdata, &tempPhrase ) );\n\t\t}\n\n\t\tmemcpy( userPhoneSeq, &phoneSeq[ cursor ], sizeof( uint16_t ) * len );\n\t\tuserPhoneSeq[ len ] = 0;\n\t\tpUserPhraseData = UserGetPhraseFirst( pgdata, userPhoneSeq );\n\t\tif ( pUserPhraseData ) {\n\t\t\tdo {\n\t\t\t\t/* check if the phrase is already in the choice list */\n\t\t\t\tif ( ChoiceTheSame(\n\t\t\t\t\tpci,\n\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\tlen * ueBytesFromChar( pUserPhraseData->wordSeq[0] ) ) )\n\t\t\t\t\tcontinue;\n\t\t\t\t/* otherwise store it */\n\t\t\t\tueStrNCpy(\n\t\t\t\t\t\tpci->totalChoiceStr[ pci->nTotalChoice ],\n\t\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\t\tlen, 1);\n\t\t\t\tpci->nTotalChoice++;\n\t\t\t} while ( ( pUserPhraseData =\n\t\t\t\t    UserGetPhraseNext( pgdata, userPhoneSeq ) ) != NULL );\n\t\t}\n\n\t}\n\n\t/* magic number */\n\tpci->nChoicePerPage = candPerPage;\n\tassert( pci->nTotalChoice > 0 );\n\tpci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );\n\tpci->pageNo = 0;\n\tpci->isSymbol = WORD_CHOICE;\n}\n\n/*\n * Seek the start of the phrase (English characters",
        "begin_line": 206,
        "end_line": 350,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueBytesFromChar#42",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueBytesFromChar( unsigned char b )",
        "snippet": "int ueBytesFromChar( unsigned char b )\n{\n\treturn utf8len_tab[ b ];\n}",
        "begin_line": 42,
        "end_line": 45,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueConstStrSeek#69",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueConstStrSeek( const char *src, size_t n )",
        "snippet": "const char *ueConstStrSeek( const char *src, size_t n )\n{\n\tsize_t i = 0;\n\tconst char *iter = src;\n\tfor ( i = 0; i < n; i++ ) {\n\t\titer += ueBytesFromChar( iter[0] );\n\t}\n\treturn iter;\n}",
        "begin_line": 69,
        "end_line": 77,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrLen#29",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrLen( const char *str )",
        "snippet": "int ueStrLen( const char *str )\n{\n\tint length = 0;\n\tconst char *strptr = str;\n\n\twhile ( strptr[ 0 ] != '\\0' ) {\n\t\tstrptr += ueBytesFromChar( strptr[0] );\n\t\t++length;\n\t}\n\treturn length;\n}",
        "begin_line": 29,
        "end_line": 39,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrNBytes#48",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrNBytes( const char *str, int n )",
        "snippet": "int ueStrNBytes( const char *str, int n )\n{\n\tint i = 0, len = 0;\n\tconst char *iter = str;\n\tfor ( i = 0; i < n; i++ ) {\n\t\tlen += ueBytesFromChar( iter[ len ] );\n\t}\n\treturn len;\n}",
        "begin_line": 48,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrNCpy#59",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrNCpy( char dest[], const char *src, size_t n, int end )",
        "snippet": "int ueStrNCpy( char dest[], const char *src, size_t n, int end )\n{\n\tint len = 0;\n\tlen = ueStrNBytes( src, n );\n\tmemcpy( dest, src, len );\n\tif ( end == STRNCPY_CLOSE )\n\t\tdest[ len ] = '\\0';\n\treturn len;\n}",
        "begin_line": 59,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "src.common.chewing-utf8-util.ueStrSeek#79",
        "src_path": "src/common/chewing-utf8-util.c",
        "class_name": "src.common.chewing-utf8-util",
        "signature": "src.common.chewing-utf8-util.ueStrSeek( char *src, size_t n )",
        "snippet": "char *ueStrSeek( char *src, size_t n )\n{\n\tsize_t i = 0;\n\tchar *iter = src;\n\tfor ( i = 0; i < n; i++ ) {\n\t\titer += ueBytesFromChar( iter[0] );\n\t}\n\treturn iter;\n}",
        "begin_line": 79,
        "end_line": 87,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.PhoneFromKey#126",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )",
        "snippet": "int PhoneFromKey( char *pho, const char *inputkey, int kbtype, int searchTimes )\n{\n\tint len = strlen( inputkey ), i, s;\n\tconst char *pTarget;\n\n\tpho[ 0 ] = '\\0';\n\tfor ( i = 0; i < len; i++ ) {\n\t\tchar *findptr = NULL;\n\t\tint _index;\n\n\t\tfor (\n\t\t\t\ts = 0, pTarget = key_str[ kbtype ];\n\t\t\t\ts < searchTimes;\n\t\t\t\ts++, pTarget = findptr + 1 ) {\n\t\t\tfindptr = strchr( pTarget, inputkey[ i ] );\n\t\t\tif ( ! findptr ) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t_index = findptr - key_str[ kbtype ];\n\t\tueStrNCpy( ueStrSeek( pho, i ),\n\t\t           ueConstStrSeek( ph_str, _index ),\n\t\t\t   1, 0);\n\t}\n\tpho = ueStrSeek( pho, len );\n\tpho[0] = '\\0';\n\treturn 1;\n}",
        "begin_line": 126,
        "end_line": 153,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.PhoneInxFromKey#177",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )",
        "snippet": "int PhoneInxFromKey( int key, int type, int kbtype, int searchTimes )\n{\n\tchar keyStr[ 2 ], rtStr[ 10 ], *p;\n\n\tkeyStr[ 0 ] = key;\n\tkeyStr[ 1 ] = '\\0';\n\tif ( ! PhoneFromKey( rtStr, keyStr, kbtype, searchTimes ) )\n\t\treturn 0;\n\tp = strstr( zhuin_tab[ type ], rtStr );\n\tif ( ! p )\n\t\treturn 0;\n\treturn zhuin_tab_num[type] - ueStrLen(p);\n}",
        "begin_line": 177,
        "end_line": 189,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.UintFromPhone#95",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.UintFromPhone( const char *zhuin )",
        "snippet": "uint16_t UintFromPhone( const char *zhuin )\n{\n\tconst char *iter;\n\tchar *pos;\n\tchar buf[ MAX_UTF8_SIZE + 1 ];\n\tint len, result = 0;\n\tint zhuin_index = 0;\n\n\titer = zhuin;\n\n\twhile ( *iter ) {\n\t\tlen = ueStrNCpy( buf, iter, 1, STRNCPY_CLOSE );\n\n\t\tfor (; zhuin_index < ZUIN_SIZE; ++zhuin_index ) {\n\t\t\tpos = strstr( zhuin_tab[ zhuin_index ], buf );\n\t\t\tif ( pos ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif ( zhuin_index >= ZUIN_SIZE ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tresult |= (zhuin_tab_num[ zhuin_index ] - ueStrLen( pos )) << shift[ zhuin_index ];\n\t\t++zhuin_index;\n\t\titer += len;\n\t}\n\treturn result;\n}",
        "begin_line": 95,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "src.common.key2pho.UintFromPhoneInx#191",
        "src_path": "src/common/key2pho.c",
        "class_name": "src.common.key2pho",
        "signature": "src.common.key2pho.UintFromPhoneInx( const int ph_inx[] )",
        "snippet": "uint16_t UintFromPhoneInx( const int ph_inx[] )\n{\n\tint i;\n\tuint16_t result = 0;\n\n\tfor ( i = 0; i < ZUIN_SIZE; i++ )\n\t\tresult |= ph_inx[ i ] << shift[ i ];\n\treturn result;\n}",
        "begin_line": 191,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "src.dict.GetCharFirst#72",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetCharFirst( ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key )",
        "snippet": "int GetCharFirst( ChewingData *pgdata, Phrase *wrd_ptr, uint16_t key )\n{\n\t/* &key serves as an array whose begin and end are both 0. */\n\tconst TreeType *pinx = TreeFindPhrase( pgdata, 0, 0, &key );\n\n\tif ( ! pinx )\n\t\treturn 0;\n\tTreeChildRange( pgdata, pinx );\n\tGetVocabFromDict( pgdata, wrd_ptr );\n\treturn 1;\n}",
        "begin_line": 72,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "src.dict.GetPhraseFirst#89",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent )",
        "snippet": "int GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, const TreeType *phrase_parent )\n{\n\tassert( phrase_parent );\n\n\tTreeChildRange( pgdata, phrase_parent );\n\tGetVocabFromDict( pgdata, phr_ptr );\n\treturn 1;\n}",
        "begin_line": 89,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "src.dict.GetVocabFromDict#65",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetVocabFromDict( ChewingData *pgdata, Phrase *phr_ptr )",
        "snippet": "static void GetVocabFromDict( ChewingData *pgdata, Phrase *phr_ptr )\n{\n\tstrcpy(phr_ptr->phrase, pgdata->static_data.dict + GetUint24(pgdata->static_data.tree_cur_pos->phrase.pos));\n\tphr_ptr->freq = GetUint24(pgdata->static_data.tree_cur_pos->phrase.freq);\n\tpgdata->static_data.tree_cur_pos++;\n}",
        "begin_line": 65,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "src.dict.GetVocabNext#98",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.GetVocabNext( ChewingData *pgdata, Phrase *phr_ptr )",
        "snippet": "int GetVocabNext( ChewingData *pgdata, Phrase *phr_ptr )\n{\n\tif ( pgdata->static_data.tree_cur_pos >= pgdata->static_data.tree_end_pos\n\t\t|| GetUint16(pgdata->static_data.tree_cur_pos->key) != 0)\n\t\treturn 0;\n\tGetVocabFromDict( pgdata, phr_ptr );\n\treturn 1;\n}",
        "begin_line": 98,
        "end_line": 105,
        "is_bug": false
    },
    {
        "name": "src.dict.InitDict#35",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.InitDict( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitDict( ChewingData *pgdata, const char *prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\tsize_t file_size;\n\tsize_t csize;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, DICT_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.dict_mmap );\n\tfile_size = plat_mmap_create( &pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( file_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tcsize = file_size;\n\tpgdata->static_data.dict = (const char*)plat_mmap_set_view( &pgdata->static_data.dict_mmap, &offset, &csize );\n\tif ( !pgdata->static_data.dict )\n\t\treturn -1;\n\n\treturn 0;\n}",
        "begin_line": 35,
        "end_line": 59,
        "is_bug": false
    },
    {
        "name": "src.dict.TerminateDict#30",
        "src_path": "src/dict.c",
        "class_name": "src.dict",
        "signature": "src.dict.TerminateDict( ChewingData *pgdata )",
        "snippet": "void TerminateDict( ChewingData *pgdata )\n{\n\tplat_mmap_close( &pgdata->static_data.dict_mmap );\n}",
        "begin_line": 30,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "src.hash.AlcUserPhraseSeq#28",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.AlcUserPhraseSeq( UserPhraseData *pData, int phonelen, int wordlen )",
        "snippet": "int AlcUserPhraseSeq( UserPhraseData *pData, int phonelen, int wordlen )\n{\n\tpData->phoneSeq = ALC( uint16_t, phonelen + 1 );\n\tif ( !pData->phoneSeq )\n\t\tgoto error;\n\tpData->wordSeq = ALC( char, wordlen + 1 );\n\tif ( !pData->wordSeq )\n\t\tgoto error;\n\n\treturn 1;\n\nerror:\n\tfree( pData->phoneSeq );\n\tfree( pData->wordSeq );\n\treturn 0;\n}",
        "begin_line": 28,
        "end_line": 43,
        "is_bug": false
    },
    {
        "name": "src.hash.FreeHashItem#446",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.FreeHashItem( HASH_ITEM *aItem )",
        "snippet": "static void FreeHashItem( HASH_ITEM *aItem )\n{\n\twhile ( aItem ) {\n\t\tHASH_ITEM *next = aItem->next;\n\t\tfree( aItem->data.phoneSeq );\n\t\tfree( aItem->data.wordSeq );\n\t\tfree( aItem );\n\t\taItem = next;\n\t}\n}",
        "begin_line": 446,
        "end_line": 455,
        "is_bug": false
    },
    {
        "name": "src.hash.HashFindEntry#81",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashFindEntry( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )",
        "snippet": "HASH_ITEM *HashFindEntry( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )\n{\n\tHASH_ITEM *pItem;\n\tint hashvalue;\n\n\thashvalue = HashFunc( phoneSeq );\n\n\tfor ( pItem = pgdata->static_data.hashtable[ hashvalue ]; pItem ; pItem = pItem->next ) {\n\t\tif (\n\t\t\t! strcmp( pItem->data.wordSeq, wordSeq ) &&\n\t\t\tPhoneSeqTheSame( pItem->data.phoneSeq, phoneSeq ) ) {\n\t\t\treturn pItem;\n\t\t}\n\t}\n\treturn NULL;\n}",
        "begin_line": 81,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "src.hash.HashFindPhonePhrase#69",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashFindPhonePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast )",
        "snippet": "HASH_ITEM *HashFindPhonePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast )\n{\n\tHASH_ITEM *pNow = pItemLast ?\n\t\t\tpItemLast->next :\n\t\t\tpgdata->static_data.hashtable[ HashFunc( phoneSeq ) ];\n\n\tfor ( ; pNow; pNow = pNow->next )\n\t\tif ( PhoneSeqTheSame( pNow->data.phoneSeq, phoneSeq ) )\n\t\t\treturn pNow;\n\treturn NULL;\n}",
        "begin_line": 69,
        "end_line": 79,
        "is_bug": false
    },
    {
        "name": "src.hash.HashFunc#60",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashFunc( const uint16_t phoneSeq[] )",
        "snippet": "static unsigned int HashFunc( const uint16_t phoneSeq[] )\n{\n\tint i, value = 0;\n\n\tfor ( i = 0; phoneSeq[ i ] != 0; i++ )\n\t\tvalue ^= phoneSeq[ i ];\n\treturn ( value & ( HASH_TABLE_SIZE - 1 ) );\n}",
        "begin_line": 60,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "src.hash.HashInsert#98",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashInsert( ChewingData *pgdata, UserPhraseData *pData )",
        "snippet": "HASH_ITEM *HashInsert( ChewingData *pgdata, UserPhraseData *pData )\n{\n\tint hashvalue;\n\tHASH_ITEM *pItem;\n\n\tpItem = HashFindEntry( pgdata, pData->phoneSeq, pData->wordSeq );\n\tif ( pItem != NULL )\n\t\treturn pItem;\n\n\tpItem = ALC( HASH_ITEM, 1 );\n\tif ( ! pItem )\n\t\treturn NULL;  /* Error occurs */\n\n\thashvalue = HashFunc( pData->phoneSeq );\n\t/* set the new element */\n\tpItem->next = pgdata->static_data.hashtable[ hashvalue ];\n\n\tmemcpy( &( pItem->data ), pData, sizeof( pItem->data ) );\n\tpItem->item_index = -1;\n\n\t/* set link to the new element */\n\tpgdata->static_data.hashtable[ hashvalue ] = pItem;\n\n\treturn pItem;\n}",
        "begin_line": 98,
        "end_line": 122,
        "is_bug": false
    },
    {
        "name": "src.hash.HashItem2Binary#145",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashItem2Binary( char *str, HASH_ITEM *pItem )",
        "snippet": "static void HashItem2Binary( char *str, HASH_ITEM *pItem )\n{\n\tint i, phraselen;\n\tchar *pc;\n\n\tmemset( str, 0, FIELD_SIZE );\n\tif ( sizeof(int) * 4 + ueStrLen( pItem->data.wordSeq ) * 2 +\n\t     strlen( pItem->data.wordSeq ) >= FIELD_SIZE ) {\n\t\t/* exceed buffer size */\n\t\treturn;\n\t}\n\n\t/* freq info */\n\tPutInt32PreservedEndian( pItem->data.userfreq, &str[ 0 ] );\n\tPutInt32PreservedEndian( pItem->data.recentTime, &str[ 4 ] );\n\tPutInt32PreservedEndian( pItem->data.maxfreq, &str[ 8 ] );\n\tPutInt32PreservedEndian( pItem->data.origfreq, &str[ 12 ] );\n\n\t/* phone seq*/\n\tphraselen = ueStrLen( pItem->data.wordSeq );\n\tstr[ 16 ] = phraselen;\n\tpc = &str[ 17 ];\n\tfor ( i = 0; i < phraselen; i++ ) {\n\t\tPutUint16PreservedEndian( pItem->data.phoneSeq[ i ], pc );\n\t\tpc += 2;\n\t}\n\n\t/* phrase */\n\t*pc = strlen( pItem->data.wordSeq );\n\tstrcpy( (pc + 1), pItem->data.wordSeq );\n\tpItem->data.wordSeq[ (unsigned char) *pc ] = '\\0';\n}",
        "begin_line": 145,
        "end_line": 176,
        "is_bug": false
    },
    {
        "name": "src.hash.HashItem2String#124",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashItem2String( char *str, HASH_ITEM *pItem )",
        "snippet": "static void HashItem2String( char *str, HASH_ITEM *pItem )\n{\n\tint i, len;\n\tchar buf[ FIELD_SIZE ];\n\n\tsprintf( str, \"%s \", pItem->data.wordSeq );\n\tlen = ueStrLen( pItem->data.wordSeq );\n\tfor ( i = 0; i < len; i++ ) {\n\t\tsprintf( buf, \"%hu \", pItem->data.phoneSeq[ i ] );\n\t\tstrcat( str, buf );\n\t}\n\tsprintf(\n\t\tbuf, \"%d %d %d %d\",\n\t\tpItem->data.userfreq, pItem->data.recentTime,\n\t\tpItem->data.maxfreq, pItem->data.origfreq );\n\tstrcat( str, buf );\n}",
        "begin_line": 124,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "src.hash.HashModify#178",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.HashModify( ChewingData *pgdata, HASH_ITEM *pItem )",
        "snippet": "void HashModify( ChewingData *pgdata, HASH_ITEM *pItem )\n{\n\tFILE *outfile;\n\tchar str[ FIELD_SIZE + 1 ];\n\n\toutfile = fopen( pgdata->static_data.hashfilename, \"r+b\" );\n\tif ( !outfile )\n\t\treturn;\n\n\t/* update \"lifetime\" */\n\tfseek( outfile, strlen( BIN_HASH_SIG ), SEEK_SET );\n\tfwrite( &pgdata->static_data.chewing_lifetime, 1, 4, outfile );\n\tsprintf( str, \"%d\", pgdata->static_data.chewing_lifetime );\n\tDEBUG_OUT( \"HashModify-1: '%-75s'\\n\", str );\n\n\t/* update record */\n\tif ( pItem->item_index < 0 ) {\n\t\tfseek( outfile, 0, SEEK_END );\n\t\tpItem->item_index =\n\t\t\t( ftell( outfile ) - 4 - strlen( BIN_HASH_SIG ) ) / FIELD_SIZE;\n\t}\n\telse {\n\t\tfseek( outfile,\n\t\t\tpItem->item_index * FIELD_SIZE + 4 + strlen( BIN_HASH_SIG ),\n\t\t\tSEEK_SET );\n\t}\n\n\tHashItem2String( str, pItem );\n\tDEBUG_OUT( \"HashModify-2: '%-75s'\\n\", str );\n\n\tHashItem2Binary( str, pItem );\n\tfwrite( str, 1, FIELD_SIZE, outfile );\n\tfflush( outfile );\n\tfclose( outfile );\n}",
        "begin_line": 178,
        "end_line": 212,
        "is_bug": false
    },
    {
        "name": "src.hash.InitHash#493",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.InitHash( ChewingData *pgdata )",
        "snippet": "int InitHash( ChewingData *pgdata )\n{\n\tHASH_ITEM item, *pItem, *pPool = NULL;\n\tint item_index, hashvalue, iret, fsize, hdrlen, oldest = INT_MAX;\n\tchar *dump, *seekdump;\n\n\tsetHashFileName( pgdata );\n\tmemset( pgdata->static_data.hashtable, 0, sizeof( pgdata->static_data.hashtable ) );\n\nopen_hash_file:\n\tdump = _load_hash_file( pgdata->static_data.hashfilename, &fsize );\n\thdrlen = strlen( BIN_HASH_SIG ) + sizeof(pgdata->static_data.chewing_lifetime);\n\titem_index = 0;\n\tif ( dump == NULL || fsize < hdrlen ) {\n\t\tFILE *outfile;\n\t\toutfile = fopen( pgdata->static_data.hashfilename, \"w+b\" );\n\t\tif ( ! outfile ) {\n\t\t\tif ( dump ) {\n\t\t\t\tfree( dump );\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tpgdata->static_data.chewing_lifetime = 0;\n\t\tfwrite( BIN_HASH_SIG, 1, strlen( BIN_HASH_SIG ), outfile );\n\t\tfwrite( &pgdata->static_data.chewing_lifetime, 1,\n\t\t                sizeof(pgdata->static_data.chewing_lifetime), outfile );\n\t\tfclose( outfile );\n\t}\n\telse {\n\t\tif ( memcmp(dump, BIN_HASH_SIG, strlen(BIN_HASH_SIG)) != 0 ) {\n\t\t\t/* perform migrate from text-based to binary form */\n\t\t\tfree( dump );\n\t\t\tif ( ! migrate_hash_to_bin( pgdata ) ) {\n\t\t\t\treturn  0;\n\t\t\t}\n\t\t\tgoto open_hash_file;\n\t\t}\n\n\t\tpgdata->static_data.chewing_lifetime = *(int *) (dump + strlen( BIN_HASH_SIG ));\n\t\tseekdump = dump + hdrlen;\n\t\tfsize -= hdrlen;\n\n\t\twhile ( fsize >= FIELD_SIZE ) {\n\t\t\tiret = ReadHashItem_bin( seekdump, &item, item_index++ );\n\t\t\t/* Ignore illegal data */\n\t\t\tif ( iret == -1 ) {\n\t\t\t\tseekdump += FIELD_SIZE;\n\t\t\t\tfsize -= FIELD_SIZE;\n\t\t\t\t--item_index;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if ( iret == 0 )\n\t\t\t\tbreak;\n\n\t\t\tpItem = ALC( HASH_ITEM, 1 );\n\t\t\tmemcpy( pItem, &item, sizeof( HASH_ITEM ) );\n\t\t\tpItem->next = pPool;\n\t\t\tpPool = pItem;\n\n\t\t\tif ( oldest > pItem->data.recentTime ) {\n\t\t\t\toldest = pItem->data.recentTime;\n\t\t\t}\n\n\t\t\tseekdump += FIELD_SIZE;\n\t\t\tfsize -= FIELD_SIZE;\n\t\t}\n\t\tfree( dump );\n\n\t\twhile ( pPool ) {\n\t\t\tpItem = pPool;\n\t\t\tpPool = pItem->next;\n\n\t\t\thashvalue = HashFunc( pItem->data.phoneSeq );\n\t\t\tpItem->next = pgdata->static_data.hashtable[ hashvalue ];\n\t\t\tpgdata->static_data.hashtable[ hashvalue ] = pItem;\n\t\t\tpItem->data.recentTime -= oldest;\n\t\t}\n\t\tpgdata->static_data.chewing_lifetime -= oldest;\n\t}\n\treturn 1;\n}",
        "begin_line": 493,
        "end_line": 573,
        "is_bug": false
    },
    {
        "name": "src.hash.PhoneSeqTheSame#45",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.PhoneSeqTheSame( const uint16_t p1[], const uint16_t p2[] )",
        "snippet": "static int PhoneSeqTheSame( const uint16_t p1[], const uint16_t p2[] )\n{\n\tint i;\n\tif ( ! p1 || ! p2 )\t/* FIXME: should not happend. */\n\t\treturn 0;\n\n\tfor ( i = 0; ( p1[ i ] != 0 && p2[ i ] != 0 ); i++ ) {\n\t\tif ( p1[ i ] != p2[ i ] )\n\t\t\treturn 0;\n\t}\n\tif ( p1[ i ] != p2[ i ] )\n\t\treturn 0;\n\treturn 1;\n}",
        "begin_line": 45,
        "end_line": 58,
        "is_bug": false
    },
    {
        "name": "src.hash.ReadHashItem_bin#235",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.ReadHashItem_bin( const char *srcbuf, HASH_ITEM *pItem, int item_index )",
        "snippet": "static int ReadHashItem_bin( const char *srcbuf, HASH_ITEM *pItem, int item_index )\n{\n\tint len, i;\n\tconst char *pc;\n\n\tmemset( pItem, 0, sizeof(HASH_ITEM) );\n\n\t/* freq info */\n\tpItem->data.userfreq\t= GetInt32PreservedEndian(&srcbuf[ 0 ]);\n\tpItem->data.recentTime\t= GetInt32PreservedEndian(&srcbuf[ 4 ]);\n\tpItem->data.maxfreq\t= GetInt32PreservedEndian(&srcbuf[ 8 ]);\n\tpItem->data.origfreq\t= GetInt32PreservedEndian(&srcbuf[ 12 ]);\n\n\t/* phone seq, length in num of chi words */\n\tlen = (int) srcbuf[ 16 ];\n\tpItem->data.phoneSeq = ALC( uint16_t, len + 1 );\n\tpc = &srcbuf[ 17 ];\n\tfor ( i = 0; i < len; i++ ) {\n\t\tpItem->data.phoneSeq[ i ] = GetUint16PreservedEndian( pc );\n\t\tpc += 2;\n\t}\n\tpItem->data.phoneSeq[ i ] = 0;\n\n\t/* phrase, length in num of bytes */\n\tpItem->data.wordSeq = ALC( char, (*pc) + 1 );\n\tstrcpy( pItem->data.wordSeq, (char *) (pc + 1) );\n\tpItem->data.wordSeq[ (unsigned int) *pc ] = '\\0';\n\n\t/* Invalid UTF-8 Chinese characters found */\n\tif ( ! isValidChineseString( pItem->data.wordSeq ) ) {\n\t\tgoto ignore_corrupted_record;\n\t}\n\n\t/* set item_index */\n\tpItem->item_index = item_index;\n\n\treturn 1; /* continue */\n\nignore_corrupted_record:\n\tif ( pItem->data.phoneSeq != NULL ) {\n\t\tfree( pItem->data.phoneSeq );\n\t\tpItem->data.phoneSeq = NULL;\n\t}\n\tif ( pItem->data.wordSeq != NULL ) {\n\t\tfree( pItem->data.wordSeq );\n\t\tpItem->data.wordSeq = NULL;\n\t}\n\treturn -1; /* ignore */\n}",
        "begin_line": 235,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "src.hash.TerminateHash#457",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.TerminateHash( ChewingData *pgdata )",
        "snippet": "void TerminateHash( ChewingData *pgdata )\n{\n\tHASH_ITEM *pItem;\n\tint i;\n\tfor ( i = 0; i < HASH_TABLE_SIZE; ++i ) {\n\t\tpItem = pgdata->static_data.hashtable[ i ];\n\t\tDEBUG_CHECKPOINT();\n\t\tFreeHashItem( pItem );\n\t}\n}",
        "begin_line": 457,
        "end_line": 466,
        "is_bug": false
    },
    {
        "name": "src.hash._load_hash_file#346",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash._load_hash_file( const char *filename, int *size )",
        "snippet": "static char *_load_hash_file( const char *filename, int *size )\n{\n\tint flen;\n\tchar *pd = NULL;\n\tFILE *tf;\n\n\ttf = open_file_get_length( filename, \"rb\", &flen );\n\tif ( tf == NULL ) {\n\t\tgoto err_load_file;\n\t}\n\tpd = ALC( char, flen );\n\tif ( pd == NULL ) {\n\t\tgoto err_load_file;\n\t}\n\tif ( fread( pd, flen, 1, tf ) != 1 ) {\n\t\tgoto err_load_file;\n\t}\n\tfclose( tf );\n\tif ( size != NULL )\n\t\t*size = flen;\n\treturn pd;\n\nerr_load_file:\n\tif ( pd != NULL )\n\t\tfree( pd );\n\tif ( tf != NULL )\n\t\tfclose( tf );\n\treturn NULL;\n}",
        "begin_line": 346,
        "end_line": 374,
        "is_bug": false
    },
    {
        "name": "src.hash.isValidChineseString#214",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.isValidChineseString( char *str )",
        "snippet": "static int isValidChineseString( char *str )\n{\n\tif ( str == NULL || *str == '\\0' ) {\n\t\treturn 0;\n\t}\n\twhile ( *str != '\\0' )  {\n\t\tint len = ueBytesFromChar( (unsigned char) *str );\n\t\tif ( len <= 1 ) {\n\t\t\treturn 0;\n\t\t}\n\t\tstr += len;\n\t};\n\treturn 1;\n}",
        "begin_line": 214,
        "end_line": 227,
        "is_bug": false
    },
    {
        "name": "src.hash.open_file_get_length#330",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.open_file_get_length( \t\tconst char *filename, const char *otype, int *size)",
        "snippet": "static FILE *open_file_get_length(\n\t\tconst char *filename,\n\t\tconst char *otype, int *size)\n{\n\tFILE *tf = fopen( filename, otype );\n\tif ( tf == NULL ) {\n\t\treturn NULL;\n\t}\n\tif ( size != NULL ) {\n\t\tfseek( tf, 0, SEEK_END );\n\t\t*size = ftell( tf );\n\t\tfseek( tf, 0, SEEK_SET );\n\t}\n\treturn tf;\n}",
        "begin_line": 330,
        "end_line": 344,
        "is_bug": false
    },
    {
        "name": "src.hash.setHashFileName#468",
        "src_path": "src/hash.c",
        "class_name": "src.hash",
        "signature": "src.hash.setHashFileName( ChewingData *pgdata )",
        "snippet": "void setHashFileName( ChewingData *pgdata )\n{\n\tchar *path;\n\n\tpath = getenv( \"CHEWING_USER_PATH\" );\n\n\t/* make sure of write permission */\n\tif ( path && access( path, W_OK ) == 0 ) {\n\t\tsnprintf( pgdata->static_data.hashfilename, sizeof( pgdata->static_data.hashfilename ),\n\t\t\t\"%s\" PLAT_SEPARATOR \"%s\", path, HASH_FILE );\n\t\treturn;\n\t}\n\n\tpath = getenv( \"HOME\" );\n\tif ( !path ) {\n\t\tpath = PLAT_TMPDIR;\n\t}\n\n\tsnprintf( pgdata->static_data.hashfilename, sizeof( pgdata->static_data.hashfilename ),\n\t\t\"%s%s\", path, CHEWING_HASH_PATH);\n\tPLAT_MKDIR( pgdata->static_data.hashfilename );\n\tstrcat( pgdata->static_data.hashfilename, PLAT_SEPARATOR );\n\tstrcat( pgdata->static_data.hashfilename, HASH_FILE );\n}",
        "begin_line": 468,
        "end_line": 491,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_Check#53",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_buffer_Check( ChewingContext *ctx )\n{\n\treturn (ctx->output->chiSymbolBufLen != 0);\n}",
        "begin_line": 53,
        "end_line": 56,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_Len#58",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_Len( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_buffer_Len( ChewingContext *ctx )\n{\n\treturn ctx->output->chiSymbolBufLen;\n}",
        "begin_line": 58,
        "end_line": 61,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_buffer_String#63",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_buffer_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_buffer_String( ChewingContext *ctx )\n{\n\tint i;\n\tchar *s = (char *) calloc(\n\t\t1 + ctx->output->chiSymbolBufLen,\n\t\tMAX_UTF8_SIZE );\n\tif ( s ) {\n\t\tfor ( i = 0; i < ctx->output->chiSymbolBufLen; i++ ) {\n\t\t\tstrcat( s, (char *) (ctx->output->chiSymbolBuf[ i ].s) );\n\t\t}\n\t}\n\treturn s;\n}",
        "begin_line": 63,
        "end_line": 75,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_Enumerate#146",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_Enumerate( ChewingContext *ctx )",
        "snippet": "CHEWING_API void chewing_cand_Enumerate( ChewingContext *ctx )\n{\n\tctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;\n}",
        "begin_line": 146,
        "end_line": 149,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_String#156",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_cand_String( ChewingContext *ctx )\n{\n\tchar *s;\n\tif ( chewing_cand_hasNext( ctx ) ) {\n\t\ts = strdup( ctx->output->pci->totalChoiceStr[ ctx->cand_no ] );\n\t\tctx->cand_no++;\n\t} else {\n\t\ts = strdup( \"\" );\n\t}\n\treturn s;\n}",
        "begin_line": 156,
        "end_line": 166,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_String_by_index#168",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_String_by_index( ChewingContext *ctx, int index )",
        "snippet": "CHEWING_API char *chewing_cand_String_by_index( ChewingContext *ctx, int index )\n{\n\tchar *s;\n\n\tif ( 0 <= index && index < ctx->output->pci->nTotalChoice ) {\n\t\ts = strdup( ctx->output->pci->totalChoiceStr[ index ] );\n\t} else {\n\t\ts = strdup( \"\" );\n\t}\n\treturn s;\n}",
        "begin_line": 168,
        "end_line": 178,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_TotalChoice#136",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_TotalChoice( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cand_TotalChoice( ChewingContext *ctx )\n{\n\treturn (ctx->output->pci ? ctx->output->pci->nTotalChoice : 0);\n}",
        "begin_line": 136,
        "end_line": 139,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cand_hasNext#151",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cand_hasNext( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cand_hasNext( ChewingContext *ctx )\n{\n\treturn (ctx->cand_no < ctx->output->pci->nTotalChoice);\n}",
        "begin_line": 151,
        "end_line": 154,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_commit_Check#28",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_commit_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_commit_Check( ChewingContext *ctx )\n{\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);\n}",
        "begin_line": 28,
        "end_line": 31,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_commit_String#39",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_commit_String( ChewingContext *ctx )",
        "snippet": "CHEWING_API char *chewing_commit_String( ChewingContext *ctx )\n{\n\tint i;\n\tchar *s = (char *) calloc(\n\t\t1 + ctx->output->nCommitStr,\n\t\tMAX_UTF8_SIZE );\n\tif ( s ) {\n\t\tfor ( i = 0; i < ctx->output->nCommitStr; i++ ) {\n\t\t\tstrcat( s, (char *) (ctx->output->commitStr[ i ].s) );\n\t\t}\n\t}\n\treturn s;\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_cursor_Current#116",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_cursor_Current( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_cursor_Current( ChewingContext *ctx )\n{\n\treturn (ctx->output->chiSymbolCursor);\n}",
        "begin_line": 116,
        "end_line": 119,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_Enumerate#180",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_Enumerate( ChewingContext *ctx )",
        "snippet": "CHEWING_API void chewing_interval_Enumerate( ChewingContext *ctx )\n{\n\tctx->it_no = 0;\n}",
        "begin_line": 180,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_Get#190",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_Get( ChewingContext *ctx, IntervalType *it )",
        "snippet": "CHEWING_API void chewing_interval_Get( ChewingContext *ctx, IntervalType *it )\n{\n\tif ( chewing_interval_hasNext( ctx ) ) {\n\t\tif ( it ) {\n\t\t\tit->from = ctx->output->dispInterval[ ctx->it_no ].from;\n\t\t\tit->to = ctx->output->dispInterval[ ctx->it_no ].to;\n\t\t}\n\t\tctx->it_no++;\n\t}\n}",
        "begin_line": 190,
        "end_line": 199,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_interval_hasNext#185",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_interval_hasNext( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_interval_hasNext( ChewingContext *ctx )\n{\n\treturn (ctx->it_no < ctx->output->nDispInterval);\n}",
        "begin_line": 185,
        "end_line": 188,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_keystroke_CheckAbsorb#230",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_keystroke_CheckAbsorb( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_keystroke_CheckAbsorb( ChewingContext *ctx )\n{\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);\n}",
        "begin_line": 230,
        "end_line": 233,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_keystroke_CheckIgnore#225",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_keystroke_CheckIgnore( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_keystroke_CheckIgnore( ChewingContext *ctx )\n{\n\treturn !!(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);\n}",
        "begin_line": 225,
        "end_line": 228,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_zuin_Check#104",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_zuin_Check( ChewingContext *ctx )",
        "snippet": "CHEWING_API int chewing_zuin_Check( ChewingContext *ctx )\n{\n\tint i;\n\n\tfor ( i = 0; i < ZUIN_SIZE; ++i ) {\n\t\tif ( ctx->output->zuinBuf[ i ].s[ 0 ] != '\\0' ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
        "begin_line": 104,
        "end_line": 114,
        "is_bug": false
    },
    {
        "name": "src.mod_aux.chewing_zuin_String#83",
        "src_path": "src/mod_aux.c",
        "class_name": "src.mod_aux",
        "signature": "src.mod_aux.chewing_zuin_String( ChewingContext *ctx, int *zuin_count )",
        "snippet": "CHEWING_API char *chewing_zuin_String( ChewingContext *ctx, int *zuin_count )\n{\n\tchar *s;\n\tint i;\n\tif ( zuin_count )\n\t\t*zuin_count = 0;\n\ts = (char*) calloc(\n\t\t1 + ZUIN_SIZE,\n\t\tsizeof(ctx->output->zuinBuf[ 0 ].s) );\n\tif ( s ) {\n\t\tfor ( i = 0; i < ZUIN_SIZE; i++ ) {\n\t\t\tif ( ctx->output->zuinBuf[ i ].s[ 0 ] != '\\0' ) {\n\t\t\t\tstrcat( s, (char *) (ctx->output->zuinBuf[ i ].s) );\n\t\t\t\tif ( zuin_count )\n\t\t\t\t\t(*zuin_count)++;\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}",
        "begin_line": 83,
        "end_line": 102,
        "is_bug": false
    },
    {
        "name": "src.pinyin.InitPinyin#29",
        "src_path": "src/pinyin.c",
        "class_name": "src.pinyin",
        "signature": "src.pinyin.InitPinyin( ChewingData *pgdata, const char *prefix )",
        "snippet": "int InitPinyin( ChewingData *pgdata, const char *prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tint i;\n\tFILE *fd;\n\tint ret;\n\n\tsprintf( filename,\n\t\t\"%s\" PLAT_SEPARATOR \"%s\",\n\t\tprefix, PINYIN_TAB_NAME );\n\n\tfd = fopen(filename, \"r\");\n\n\tif ( ! fd )\n\t\treturn 0;\n\n\tret = fscanf( fd, \"%d\", &pgdata->static_data.HANYU_INITIALS );\n\tif ( ret != 1 ) {\n\t\treturn 0;\n\t}\n\t++pgdata->static_data.HANYU_INITIALS;\n\tpgdata->static_data.hanyuInitialsMap = ALC( keymap, pgdata->static_data.HANYU_INITIALS );\n\tfor ( i = 0; i < pgdata->static_data.HANYU_INITIALS - 1; i++ ) {\n\t\tret = fscanf( fd, \"%s %s\",\n\t\t\tpgdata->static_data.hanyuInitialsMap[ i ].pinyin,\n\t\t\tpgdata->static_data.hanyuInitialsMap[ i ].zuin );\n\t\tif ( ret != 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = fscanf( fd, \"%d\", &pgdata->static_data.HANYU_FINALS );\n\tif ( ret != 1 ) {\n\t\treturn 0;\n\t}\n\t++pgdata->static_data.HANYU_FINALS;\n\tpgdata->static_data.hanyuFinalsMap = ALC( keymap, pgdata->static_data.HANYU_FINALS );\n\tfor ( i = 0; i < pgdata->static_data.HANYU_FINALS - 1; i++ ) {\n\t\tret = fscanf( fd, \"%s %s\",\n\t\t\tpgdata->static_data.hanyuFinalsMap[ i ].pinyin,\n\t\t\tpgdata->static_data.hanyuFinalsMap[ i ].zuin );\n\t\tif ( ret != 2 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tfclose( fd );\n\n\treturn 1;\n}",
        "begin_line": 29,
        "end_line": 78,
        "is_bug": false
    },
    {
        "name": "src.pinyin.TerminatePinyin#23",
        "src_path": "src/pinyin.c",
        "class_name": "src.pinyin",
        "signature": "src.pinyin.TerminatePinyin( ChewingData *pgdata )",
        "snippet": "void TerminatePinyin( ChewingData *pgdata )\n{\n\tfree( pgdata->static_data.hanyuInitialsMap );\n\tfree( pgdata->static_data.hanyuFinalsMap );\n}",
        "begin_line": 23,
        "end_line": 27,
        "is_bug": false
    },
    {
        "name": "src.porting_layer.src.plat_path.are_all_files_readable#130",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "src.porting_layer.src.plat_path",
        "signature": "src.porting_layer.src.plat_path.are_all_files_readable( \tconst char *path, const char * const *files, char *output, size_t output_len )",
        "snippet": "static int are_all_files_readable(\n\tconst char *path,\n\tconst char * const *files,\n\tchar *output,\n\tsize_t output_len )\n{\n\tint i;\n\n\tassert( path );\n\tassert( files );\n\n\tfor ( i = 0; files[i] != NULL; ++i ) {\n\t\tsnprintf( output, output_len, \"%s\" PLAT_SEPARATOR \"%s\", path,\n\t\t\t\tfiles[i] );\n\t\tif ( access( output, R_OK ) != 0 ) {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
        "begin_line": 130,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "src.porting_layer.src.plat_path.find_path_by_files#152",
        "src_path": "src/porting_layer/src/plat_path.c",
        "class_name": "src.porting_layer.src.plat_path",
        "signature": "src.porting_layer.src.plat_path.find_path_by_files( \tconst char *search_path, const char * const *files, char *output, size_t output_len )",
        "snippet": "int find_path_by_files(\n\tconst char *search_path,\n\tconst char * const *files,\n\tchar *output,\n\tsize_t output_len )\n{\n\tchar buffer[PATH_MAX];\n\tchar *path;\n\tchar *saveptr;\n\tint ret;\n\n\tassert( search_path );\n\tassert( files );\n\tassert( output );\n\tassert( output_len );\n\n\t// strtok_r will modify its first parameter.\n\tstrncpy( buffer, search_path, sizeof( buffer ) );\n\n\tfor ( path = strtok_r( buffer, SEARCH_PATH_SEP, &saveptr );\n\t\tpath; path = strtok_r( NULL, SEARCH_PATH_SEP, &saveptr ) ) {\n\n\t\tret = are_all_files_readable( path, files, output, output_len );\n\t\tif ( ret ) {\n\t\t\tsnprintf( output, output_len, \"%s\", path );\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
        "begin_line": 152,
        "end_line": 181,
        "is_bug": false
    },
    {
        "name": "src.tree.AddInterval#285",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.AddInterval( \t\tTreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user )",
        "snippet": "static void AddInterval(\n\t\tTreeDataType *ptd, int begin , int end,\n\t\tPhrase *p_phrase, int dict_or_user )\n{\n\tptd->interval[ ptd->nInterval ].from = begin;\n\tptd->interval[ ptd->nInterval ].to = end + 1;\n\tptd->interval[ ptd->nInterval ].p_phr = p_phrase;\n\tptd->interval[ ptd->nInterval ].source = dict_or_user;\n\tptd->nInterval++;\n}",
        "begin_line": 285,
        "end_line": 294,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckBreakpoint#108",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckBreakpoint( int from, int to, int bArrBrkpt[] )",
        "snippet": "static int CheckBreakpoint( int from, int to, int bArrBrkpt[] )\n{\n\tint i;\n\tfor ( i = from + 1; i < to; i++ )\n\t\tif ( bArrBrkpt[ i ] )\n\t\t\treturn 0;\n\treturn 1;\n}",
        "begin_line": 108,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckChoose#195",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckChoose( \t\tChewingData *pgdata, const TreeType *phrase_parent, int from, int to, Phrase **pp_phr, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect )",
        "snippet": "static int CheckChoose(\n\t\tChewingData *pgdata,\n\t\tconst TreeType *phrase_parent, int from, int to, Phrase **pp_phr,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[], int nSelect )\n{\n\tIntervalType inte, c;\n\tint chno, len;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\n\tassert( phrase );\n\tinte.from = from;\n\tinte.to = to;\n\t*pp_phr = NULL;\n\n\t/* if there exist one phrase satisfied all selectStr then return 1, else return 0. */\n\tGetPhraseFirst( pgdata, phrase, phrase_parent );\n\tdo {\n\t\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\t\tc = selectInterval[ chno ];\n\n\t\t\tif ( IsContain( inte, c ) ) {\n\t\t\t\t/* find a phrase under phrase_parent where the text contains\n\t\t\t\t * 'selectStr[chno]' test if not ok then return 0, if ok\n\t\t\t\t * then continue to test\n\t\t\t\t */\n\t\t\t\tlen = c.to - c.from;\n\t\t\t\tif ( memcmp(\n\t\t\t\t\tueStrSeek( phrase->phrase, c.from - from ),\n\t\t\t\t\tselectStr[ chno ],\n\t\t\t\t\tueStrNBytes( selectStr[ chno ], len ) ) )\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if ( IsIntersect( inte, selectInterval[ chno ] ) ) {\n\t\t\t\tfree( phrase );\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif ( chno == nSelect ) {\n\t\t\t*pp_phr = phrase;\n\t\t\treturn 1;\n\t\t}\n\t} while ( GetVocabNext( pgdata, phrase ) );\n\tfree( phrase );\n\treturn 0;\n}",
        "begin_line": 195,
        "end_line": 240,
        "is_bug": false
    },
    {
        "name": "src.tree.CheckUserChoose#117",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CheckUserChoose( \t\tChewingData *pgdata, uint16_t *new_phoneSeq, int from, int to, Phrase **pp_phr, char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ], IntervalType selectInterval[], int nSelect )",
        "snippet": "static int CheckUserChoose(\n\t\tChewingData *pgdata,\n\t\tuint16_t *new_phoneSeq, int from , int to,\n\t\tPhrase **pp_phr,\n\t\tchar selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],\n\t\tIntervalType selectInterval[], int nSelect )\n{\n\tIntervalType inte, c;\n\tint chno, len;\n\tint user_alloc;\n\tUserPhraseData *pUserPhraseData;\n\tPhrase *p_phr = ALC( Phrase, 1 );\n\n\tassert( p_phr );\n\tinte.from = from;\n\tinte.to = to;\n\t*pp_phr = NULL;\n\n\t/* pass 1\n\t * if these exist one selected interval which is not contained by inte\n\t * but has intersection with inte, then inte is an unacceptable interval\n\t */\n\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\tc = selectInterval[ chno ];\n\t\tif ( IsIntersect( inte, c ) && ! IsContain( inte, c ) ) {\n\t\t\tfree( p_phr );\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* pass 2\n\t * if there exist one phrase satisfied all selectStr then return 1, else return 0.\n\t * also store the phrase with highest freq\n\t */\n\tpUserPhraseData = UserGetPhraseFirst( pgdata, new_phoneSeq );\n\tp_phr->freq = -1;\n\tdo {\n\t\tfor ( chno = 0; chno < nSelect; chno++ ) {\n\t\t\tc = selectInterval[ chno ];\n\n\t\t\tif ( IsContain( inte, c ) ) {\n\t\t\t\t/*\n\t\t\t\t * find a phrase of ph_id where the text contains\n\t\t\t\t * 'selectStr[chno]' test if not ok then return 0,\n\t\t\t\t * if ok then continue to test. */\n\t\t\t\tlen = c.to - c.from;\n\t\t\t\tif ( memcmp(\n\t\t\t\t\tueStrSeek( pUserPhraseData->wordSeq, c.from - from ),\n\t\t\t\t\tselectStr[ chno ],\n\t\t\t\t\tueStrNBytes( selectStr[ chno ], len ) ) )\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tif ( chno == nSelect ) {\n\t\t\t/* save phrase data to \"pp_phr\" */\n\t\t\tif ( pUserPhraseData->userfreq > p_phr->freq ) {\n\t\t\t\tif ( ( user_alloc = ( to - from ) ) > 0 ) {\n\t\t\t\t\tueStrNCpy( p_phr->phrase,\n\t\t\t\t\t\t\tpUserPhraseData->wordSeq,\n\t\t\t\t\t\t\tuser_alloc, 1);\n\t\t\t\t}\n\t\t\t\tp_phr->freq = pUserPhraseData->userfreq;\n\t\t\t\t*pp_phr = p_phr;\n\t\t\t}\n\t\t}\n\t} while ( ( pUserPhraseData = UserGetPhraseNext( pgdata, new_phoneSeq ) ) != NULL );\n\n\tif ( p_phr->freq != -1 )\n\t\treturn 1;\n\n\tfree( p_phr );\n\treturn 0;\n}",
        "begin_line": 117,
        "end_line": 190,
        "is_bug": false
    },
    {
        "name": "src.tree.CleanUpMem#807",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CleanUpMem( TreeDataType *ptd )",
        "snippet": "static void CleanUpMem( TreeDataType *ptd )\n{\n\tint i;\n\tRecordNode *pNode;\n\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tif ( ptd->interval[ i ].p_phr ) {\n\t\t\tfree( ptd->interval[ i ].p_phr );\n\t\t\tptd->interval[ i ].p_phr = NULL;\n\t\t}\n\t}\n\twhile ( ptd->phList != NULL ) {\n\t\tpNode = ptd->phList;\n\t\tptd->phList = pNode->next;\n\t\tfree( pNode->arrIndex );\n\t\tfree( pNode );\n\t}\n}",
        "begin_line": 807,
        "end_line": 824,
        "is_bug": false
    },
    {
        "name": "src.tree.CompRecord#436",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CompRecord( const RecordNode **pa, const RecordNode **pb )",
        "snippet": "static int CompRecord( const RecordNode **pa, const RecordNode **pb )\n{\n\tint diff = (*pb)->nMatchCnnct - (*pa)->nMatchCnnct;\n\n\tif ( diff )\n\t\treturn diff;\n\treturn ( (*pb)->score - (*pa)->score );\n}",
        "begin_line": 436,
        "end_line": 443,
        "is_bug": false
    },
    {
        "name": "src.tree.CompTreeType#242",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CompTreeType( const void *a, const void *b )",
        "snippet": "static int CompTreeType( const void *a, const void *b )\n{\n\treturn GetUint16(((TreeType*)a)->key) - GetUint16(((TreeType*)b)->key);\n}",
        "begin_line": 242,
        "end_line": 245,
        "is_bug": false
    },
    {
        "name": "src.tree.CountMatchCnnct#826",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CountMatchCnnct( TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq )",
        "snippet": "static void CountMatchCnnct( TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq )\n{\n\tRecordNode *p;\n\tint i, k, sum;\n\n\tfor ( p = ptd->phList; p; p = p->next ) {\n\t\t/* for each record, count its 'nMatchCnnct' */\n\t\tfor ( sum = 0, i = 1; i < nPhoneSeq; i++ ) {\n\t\t\tif ( !bUserArrCnnct[ i ] )\n\t\t\t\tcontinue;\n\t\t\t/* check if matching 'cnnct' */\n\t\t\tfor ( k = 0; k < p->nInter; k++ ) {\n\t\t\t\tif (\n\t\t\t\t\tptd->interval[ p->arrIndex[ k ] ].from < i &&\n\t\t\t\t\tptd->interval[ p->arrIndex[ k ] ].to > i ) {\n\t\t\t\t\tsum++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp->nMatchCnnct = sum;\n\t}\n}",
        "begin_line": 826,
        "end_line": 848,
        "is_bug": false
    },
    {
        "name": "src.tree.CreateNullIntervalRecord#971",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CreateNullIntervalRecord()",
        "snippet": "static RecordNode * CreateNullIntervalRecord()\n{\n\tRecordNode *ret = NULL;\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\n\tret->nInter = 0;\n\tret->score = 0;\n\n\treturn ret;\n}",
        "begin_line": 971,
        "end_line": 988,
        "is_bug": false
    },
    {
        "name": "src.tree.CreateSingleIntervalRecord#947",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.CreateSingleIntervalRecord( TreeDataType *pdt, const int interval_id )",
        "snippet": "static RecordNode * CreateSingleIntervalRecord( TreeDataType *pdt, const int interval_id )\n{\n\tRecordNode *ret = NULL;\n\n\tassert( pdt );\n\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\n\tret->nInter = 1;\n\tret->arrIndex[0] = interval_id;\n\n\tret->score = LoadPhraseAndCountScore( ret->arrIndex, ret->nInter, pdt );\n\n\treturn ret;\n}",
        "begin_line": 947,
        "end_line": 969,
        "is_bug": false
    },
    {
        "name": "src.tree.Discard1#452",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Discard1( TreeDataType *ptd )",
        "snippet": "static void Discard1( TreeDataType *ptd )\n{\n\tint a, b;\n\tchar failflag[ INTERVAL_SIZE ];\n\tint nInterval2;\n\n\tmemset( failflag, 0, sizeof( failflag ) );\n\tfor ( a = 0; a < ptd->nInterval; a++ ) {\n\t\tif ( failflag[ a ] )\n\t\t\tcontinue;\n\t\tfor ( b = 0; b < ptd->nInterval; b++ ) {\n\t\t\tif ( a == b || failflag[ b ] )\n\t\t\t\tcontinue ;\n\n\t\t\t/* interval b is in interval a */\n\t\t\tif ( PhraseIntervalContain( ptd->interval[ a ], ptd->interval[ b ] ) )\n\t\t\t\tcontinue;\n\n\t\t\t/* interval b is in front of interval a */\n\t\t\tif ( ptd->interval[ b ].to <= ptd->interval[ a ].from )\n\t\t\t\tcontinue;\n\n\t\t\t/* interval b is in back of interval a */\n\t\t\tif ( ptd->interval[ a ].to <= ptd->interval[ b ].from )\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\t\t/* if any other interval b is inside or leftside or rightside the\n\t\t * interval a */\n\t\tif ( b >= ptd->nInterval ) {\n\t\t\t/* then kill all the intervals inside the interval a */\n\t\t\tint i;\n\t\t\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\t\t\tif (! failflag[ i ] && i != a &&\n\t\t\t\t\tPhraseIntervalContain( ptd->interval[ a ], ptd->interval[ i ] ) ) {\n\t\t\t\t\tfailflag[ i ] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/* discard all the intervals whose failflag[a] = 1 */\n\tnInterval2 = 0;\n\tfor ( a = 0; a < ptd->nInterval; a++ ) {\n\t\tif ( ! failflag[ a ] ) {\n\t\t\tptd->interval[ nInterval2++ ] = ptd->interval[ a ];\n\t\t}\n\t\telse {\n\t\t\tif ( ptd->interval[ a ].p_phr != NULL ) {\n\t\t\t\tfree( ptd->interval[ a ].p_phr );\n\t\t\t}\n\t\t}\n\t}\n\tptd->nInterval = nInterval2;\n}",
        "begin_line": 452,
        "end_line": 506,
        "is_bug": false
    },
    {
        "name": "src.tree.Discard2#519",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Discard2( TreeDataType *ptd )",
        "snippet": "static void Discard2( TreeDataType *ptd )\n{\n\tint i, j;\n\tchar overwrite[ MAX_PHONE_SEQ_LEN ];\n\tchar failflag[ INTERVAL_SIZE ];\n\tint nInterval2;\n\n\tmemset( failflag, 0, sizeof( failflag ) );\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tif ( ptd->leftmost[ ptd->interval[ i ].from ] == 0 )\n\t\t\tcontinue;\n\t\t/* test if interval i is overwrited by other intervals */\n\t\tmemset( overwrite, 0, sizeof( overwrite ) );\n\t\tfor ( j = 0; j < ptd->nInterval; j++ ) {\n\t\t\tif ( j == i )\n\t\t\t\tcontinue;\n\t\t\tmemset(\n\t\t\t\t&overwrite[ ptd->interval[ j ].from ],\n\t\t\t\t1,\n\t\t\t\tptd->interval[ j ].to - ptd->interval[ j ].from );\n\t\t}\n\t\tif ( memchr(\n\t\t\t&overwrite[ ptd->interval[ i ].from ],\n\t\t\t1,\n\t\t\tptd->interval[ i ].to - ptd->interval[ i ].from ) )\n\t\t\tfailflag[ i ] = 1;\n\t}\n\t/* discard all the intervals whose failflag[a] = 1 */\n\tnInterval2 = 0;\n\tfor ( i = 0; i < ptd->nInterval; i++ )\n\t\tif ( ! failflag[ i ] )\n\t\t\tptd->interval[ nInterval2++ ] = ptd->interval[ i ];\n\tptd->nInterval = nInterval2;\n}",
        "begin_line": 519,
        "end_line": 552,
        "is_bug": false
    },
    {
        "name": "src.tree.DoDpPhrasing#998",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.DoDpPhrasing( ChewingData *pgdata, TreeDataType *pdt )",
        "snippet": "static void DoDpPhrasing( ChewingData *pgdata, TreeDataType *pdt )\n{\n\tRecordNode *highest_score[ MAX_PHONE_SEQ_LEN ] = { 0 };\n\tRecordNode *tmp;\n\tint prev_end;\n\tint end;\n\tint interval_id;\n\n\tassert( pgdata );\n\tassert( pdt );\n\n\t/*\n\t * Assume P(x,y) is the highest score phrasing result from x to y. The\n\t * following is formula for P(x,y):\n\t *\n\t * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )\n\t *\n\t * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is\n\t * interval end at y. In this formula, x is always 0.\n\t *\n\t * The format of highest_score array is described as following:\n\t *\n\t * highest_score[0] = P(0,0)\n\t * highest_score[1] = P(0,1)\n\t * ...\n\t * highest_score[y-1] = P(0,y-1)\n\t */\n\n\t/* The interval shall be sorted by the increase order of end. */\n\tqsort( pdt->interval, pdt->nInterval, sizeof( pdt->interval[0] ), SortByIncreaseEnd );\n\n\tfor ( interval_id = 0; interval_id < pdt->nInterval; ++interval_id ) {\n\t\t/*\n\t\t * XXX: pdt->interval.to is excluding, while end is\n\t\t * including, so we need to minus one here.\n\t\t */\n\t\tend = pdt->interval[interval_id].to - 1;\n\n\t\tprev_end = pdt->interval[interval_id].from - 1;\n\n\t\tif ( prev_end >= 0 )\n\t\t\ttmp = DuplicateRecordAndInsertInterval(\n\t\t\t\thighest_score[ prev_end ],\n\t\t\t\tpdt,\n\t\t\t\tinterval_id );\n\t\telse\n\t\t\ttmp = CreateSingleIntervalRecord( pdt, interval_id );\n\n\t\t/* FIXME: shall exit immediately? */\n\t\tif (!tmp)\n\t\t\tcontinue;\n\n\t\tif ( highest_score[end] == NULL || highest_score[end]->score < tmp->score ) {\n\t\t\tFreeRecord( highest_score[end] );\n\t\t\thighest_score[end] = tmp;\n\t\t} else\n\t\t\tFreeRecord( tmp );\n\t}\n\n\tif ( pgdata->nPhoneSeq - 1 < 0 || highest_score[ pgdata->nPhoneSeq - 1 ] == NULL ) {\n\t\tpdt->phList = CreateNullIntervalRecord();\n\t} else {\n\t\tpdt->phList = highest_score[ pgdata->nPhoneSeq - 1 ];\n\t}\n\tpdt->nPhListLen = 1;\n\n\tfor ( end = 0; end < pgdata->nPhoneSeq - 1; ++end )\n\t\tFreeRecord( highest_score[end] );\n}",
        "begin_line": 998,
        "end_line": 1066,
        "is_bug": false
    },
    {
        "name": "src.tree.DuplicateRecordAndInsertInterval#918",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.DuplicateRecordAndInsertInterval( \tconst RecordNode *record, TreeDataType *pdt, const int interval_id )",
        "snippet": "static RecordNode * DuplicateRecordAndInsertInterval(\n\tconst RecordNode *record,\n\tTreeDataType *pdt,\n\tconst int interval_id )\n{\n\tRecordNode *ret = NULL;\n\n\tassert( record );\n\tassert( pdt );\n\n\tret = ALC( RecordNode, 1 );\n\tif ( !ret )\n\t\treturn NULL;\n\n\tret->arrIndex = ALC( int, record->nInter + 1 );\n\tif ( !ret->arrIndex ) {\n\t\tfree( ret );\n\t\treturn NULL;\n\t}\n\tret->nInter = record->nInter + 1;\n\tmemcpy( ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter );\n\n\tret->arrIndex[ ret->nInter - 1 ] = interval_id;\n\n\tret->score = LoadPhraseAndCountScore( ret->arrIndex, ret->nInter, pdt );\n\n\treturn ret;\n}",
        "begin_line": 918,
        "end_line": 945,
        "is_bug": false
    },
    {
        "name": "src.tree.FindInterval#324",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.FindInterval( ChewingData *pgdata, TreeDataType *ptd )",
        "snippet": "static void FindInterval( ChewingData *pgdata, TreeDataType *ptd )\n{\n\tint end, begin;\n\tconst TreeType *phrase_parent;\n\tPhrase *p_phrase, *puserphrase, *pdictphrase;\n\tUsedPhraseMode i_used_phrase;\n\tuint16_t new_phoneSeq[ MAX_PHONE_SEQ_LEN ];\n\n\tfor ( begin = 0; begin < pgdata->nPhoneSeq; begin++ ) {\n\t\tfor ( end = begin; end < min( pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN ); end++ ) {\n\t\t\tif ( ! CheckBreakpoint( begin, end + 1, pgdata->bArrBrkpt ) )\n\t\t\t\tbreak;\n\n\t\t\t/* set new_phoneSeq */\n\t\t\tmemcpy(\n\t\t\t\tnew_phoneSeq,\n\t\t\t\t&pgdata->phoneSeq[ begin ],\n\t\t\t\tsizeof( uint16_t ) * ( end - begin + 1 ) );\n\t\t\tnew_phoneSeq[ end - begin + 1 ] = 0;\n\t\t\tpuserphrase = pdictphrase = NULL;\n\t\t\ti_used_phrase = USED_PHRASE_NONE;\n\n\t\t\t/* check user phrase */\n\t\t\tif ( UserGetPhraseFirst( pgdata, new_phoneSeq ) &&\n\t\t\t\t\tCheckUserChoose( pgdata, new_phoneSeq, begin, end + 1,\n\t\t\t\t\t&p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect ) ) {\n\t\t\t\tpuserphrase = p_phrase;\n\t\t\t}\n\n\t\t\t/* check dict phrase */\n\t\t\tphrase_parent = TreeFindPhrase( pgdata, begin, end, pgdata->phoneSeq );\n\t\t\tif (\n\t\t\t\tphrase_parent &&\n\t\t\t\tCheckChoose(\n\t\t\t\t\tpgdata,\n\t\t\t\t\tphrase_parent, begin, end + 1,\n\t\t\t\t\t&p_phrase, pgdata->selectStr,\n\t\t\t\t\tpgdata->selectInterval, pgdata->nSelect ) ) {\n\t\t\t\tpdictphrase = p_phrase;\n\t\t\t}\n\n\t\t\t/* add only one interval, which has the largest freqency\n\t\t\t * but when the phrase is the same, the user phrase overrides\n\t\t\t * static dict\n\t\t\t */\n\t\t\tif ( puserphrase != NULL && pdictphrase == NULL ) {\n\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t}\n\t\t\telse if ( puserphrase == NULL && pdictphrase != NULL ) {\n\t\t\t\ti_used_phrase = USED_PHRASE_DICT;\n\t\t\t}\n\t\t\telse if ( puserphrase != NULL && pdictphrase != NULL ) {\n\t\t\t\t/* the same phrase, userphrase overrides */\n\t\t\t\tif ( ! strcmp(\n\t\t\t\t\tpuserphrase->phrase,\n\t\t\t\t\tpdictphrase->phrase ) ) {\n\t\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( puserphrase->freq > pdictphrase->freq ) {\n\t\t\t\t\t\ti_used_phrase = USED_PHRASE_USER;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\ti_used_phrase = USED_PHRASE_DICT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch ( i_used_phrase ) {\n\t\t\t\tcase USED_PHRASE_USER:\n\t\t\t\t\tAddInterval( ptd, begin, end, puserphrase, IS_USER_PHRASE );\n\t\t\t\t\tbreak;\n\t\t\t\tcase USED_PHRASE_DICT:\n\t\t\t\t\tAddInterval( ptd, begin, end, pdictphrase, IS_DICT_PHRASE );\n\t\t\t\t\tbreak;\n\t\t\t\tcase USED_PHRASE_NONE:\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinternal_release_Phrase(\n\t\t\t\ti_used_phrase,\n\t\t\t\tpuserphrase,\n\t\t\t\tpdictphrase );\n\t\t}\n\t}\n}",
        "begin_line": 324,
        "end_line": 408,
        "is_bug": false
    },
    {
        "name": "src.tree.FreeRecord#990",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.FreeRecord( RecordNode *node )",
        "snippet": "static void FreeRecord( RecordNode *node )\n{\n\tif ( node ) {\n\t\tfree( node->arrIndex );\n\t\tfree( node );\n\t}\n}",
        "begin_line": 990,
        "end_line": 996,
        "is_bug": false
    },
    {
        "name": "src.tree.InitPhrasing#789",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.InitPhrasing( TreeDataType *ptd )",
        "snippet": "static void InitPhrasing( TreeDataType *ptd )\n{\n\tmemset( ptd, 0, sizeof( TreeDataType ) );\n}",
        "begin_line": 789,
        "end_line": 792,
        "is_bug": false
    },
    {
        "name": "src.tree.InitTree#85",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.InitTree( ChewingData *pgdata, const char * prefix )",
        "snippet": "int InitTree( ChewingData *pgdata, const char * prefix )\n{\n\tchar filename[ PATH_MAX ];\n\tsize_t len;\n\tsize_t offset;\n\n\tlen = snprintf( filename, sizeof( filename ), \"%s\" PLAT_SEPARATOR \"%s\", prefix, PHONE_TREE_FILE );\n\tif ( len + 1 > sizeof( filename ) )\n\t\treturn -1;\n\n\tplat_mmap_set_invalid( &pgdata->static_data.tree_mmap );\n\tpgdata->static_data.tree_size = plat_mmap_create( &pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ );\n\tif ( pgdata->static_data.tree_size <= 0 )\n\t\treturn -1;\n\n\toffset = 0;\n\tpgdata->static_data.tree = (const TreeType *) plat_mmap_set_view( &pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size );\n\tif ( !pgdata->static_data.tree )\n\t\treturn -1;\n\n\treturn 0;\n}",
        "begin_line": 85,
        "end_line": 106,
        "is_bug": false
    },
    {
        "name": "src.tree.IsContain#58",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.IsContain( IntervalType in1, IntervalType in2 )",
        "snippet": "static int IsContain( IntervalType in1, IntervalType in2 )\n{\n\treturn ( in1.from <= in2.from && in1.to >= in2.to );\n}",
        "begin_line": 58,
        "end_line": 61,
        "is_bug": false
    },
    {
        "name": "src.tree.IsIntersect#63",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.IsIntersect( IntervalType in1, IntervalType in2 )",
        "snippet": "int IsIntersect( IntervalType in1, IntervalType in2 )\n{\n\treturn ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );\n}",
        "begin_line": 63,
        "end_line": 66,
        "is_bug": false
    },
    {
        "name": "src.tree.IsRecContain#656",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.IsRecContain( const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd )",
        "snippet": "static int IsRecContain( const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd )\n{\n\tint big, sml;\n\n\tfor ( big = 0, sml = 0; sml < nB; sml++ ) {\n\t\twhile (\n\t\t\t( big < nA ) &&\n\t\t\tptd->interval[ intA[ big ] ].from <\n\t\t\t\tptd->interval[ intB[ sml ] ].to ) {\n\t\t\tif ( PhraseIntervalContain(\n\t\t\t\tptd->interval[ intA[ big ] ],\n\t\t\t\tptd->interval[ intB[ sml ] ] ) )\n\t\t\t\tbreak;\n\t\t\tbig++;\n\t\t}\n\t\tif (\n\t\t\t( big >= nA ) ||\n\t\t\tptd->interval[ intA[ big ] ].from >=\n\t\t\t\tptd->interval[ intB[ sml ] ].to )\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
        "begin_line": 656,
        "end_line": 678,
        "is_bug": false
    },
    {
        "name": "src.tree.LoadChar#554",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.LoadChar( ChewingData *pgdata, char *buf, int buf_len, const uint16_t phoneSeq[], int nPhoneSeq )",
        "snippet": "static void LoadChar( ChewingData *pgdata, char *buf, int buf_len, const uint16_t phoneSeq[], int nPhoneSeq )\n{\n\tint i;\n\tPhrase word;\n\n\tmemset(buf, 0, buf_len);\n\tfor ( i = 0; i < nPhoneSeq; i++ ) {\n\t\tGetCharFirst( pgdata, &word, phoneSeq[ i ] );\n\t\tstrncat(buf, word.phrase, buf_len - strlen(buf) - 1);\n\t}\n\tbuf[ buf_len - 1 ] = '\\0';\n}",
        "begin_line": 554,
        "end_line": 565,
        "is_bug": false
    },
    {
        "name": "src.tree.LoadPhraseAndCountScore#643",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint total_score = 0;\n\t/* NOTE: the balance factor is tuneable */\n\tif (nRecord) {\n\t\ttotal_score += 1000*rule_largest_sum( record, nRecord, ptd );\n\t\ttotal_score += 1000*rule_largest_avgwordlen( record, nRecord, ptd );\n\t\ttotal_score += 100*rule_smallest_lenvariance( record, nRecord, ptd );\n\t\ttotal_score += rule_largest_freqsum( record, nRecord, ptd );\n\t}\n\treturn total_score;\n}",
        "begin_line": 643,
        "end_line": 654,
        "is_bug": false
    },
    {
        "name": "src.tree.NextCut#873",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.NextCut( TreeDataType *tdt, PhrasingOutput *ppo )",
        "snippet": "static RecordNode* NextCut( TreeDataType *tdt, PhrasingOutput *ppo )\n{\n\t/* pop nNumCut-th candidate to first */\n\tint i;\n\tRecordNode *former;\n\tRecordNode *want;\n\n\tif ( ppo->nNumCut >= tdt->nPhListLen )\n\t\tppo->nNumCut = 0;\n\tif (ppo->nNumCut == 0)\n\t\treturn tdt->phList;\n\n\t/* find the former of our candidate */\n\tformer = tdt->phList;\n\tfor ( i = 0; i < ppo->nNumCut - 1; i++ ) {\n\t\tformer = former->next;\n\t\tassert( former );\n\t}\n\n\t/* take the candidate out of the listed list */\n\twant = former->next;\n\tassert( want );\n\tformer->next = former->next->next;\n\n\t/* prepend to front of list */\n\twant->next = tdt->phList;\n\ttdt->phList = want;\n\n\treturn tdt->phList;\n}",
        "begin_line": 873,
        "end_line": 902,
        "is_bug": false
    },
    {
        "name": "src.tree.OutputRecordStr#568",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.OutputRecordStr( ChewingData *pgdata, const TreeDataType *ptd )",
        "snippet": "static void OutputRecordStr( ChewingData *pgdata, const TreeDataType *ptd )\n{\n\tPhraseIntervalType inter;\n\tint i;\n\n\tLoadChar( pgdata, pgdata->phrOut.chiBuf, ARRAY_SIZE( pgdata->phrOut.chiBuf ), pgdata->phoneSeq, pgdata->nPhoneSeq );\n\tfor ( i = 0; i < ptd->phList->nInter; i++ ) {\n\t\tinter = ptd->interval[ ptd->phList->arrIndex[ i ] ];\n\t\tueStrNCpy(\n\t\t\t\tueStrSeek( pgdata->phrOut.chiBuf, inter.from ),\n\t\t\t\t( inter.p_phr )->phrase,\n\t\t\t\t( inter.to - inter.from ), -1);\n\t}\n\tfor ( i = 0; i < pgdata->nSelect; i++ ) {\n\t\tinter.from = pgdata->selectInterval[ i ].from;\n\t\tinter.to = pgdata->selectInterval[ i ].to ;\n\t\tueStrNCpy(\n\t\t\t\tueStrSeek( pgdata->phrOut.chiBuf, inter.from ),\n\t\t\t\tpgdata->selectStr[ i ], ( inter.to - inter.from ), -1);\n\t}\n}",
        "begin_line": 568,
        "end_line": 588,
        "is_bug": false
    },
    {
        "name": "src.tree.PhraseIntervalContain#68",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n\treturn ( in1.from <= in2.from && in1.to >= in2.to );\n}",
        "begin_line": 68,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "src.tree.PhraseIntervalIntersect#73",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)",
        "snippet": "static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)\n{\n\treturn ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );\n}",
        "begin_line": 73,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "src.tree.Phrasing#1068",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.Phrasing( ChewingData *pgdata, int all_phrasing )",
        "snippet": "int Phrasing( ChewingData *pgdata, int all_phrasing )\n{\n\tTreeDataType treeData;\n\n\tInitPhrasing( &treeData );\n\n\tFindInterval( pgdata, &treeData );\n\tSetInfo( pgdata->nPhoneSeq, &treeData );\n\tDiscard1( &treeData );\n\tDiscard2( &treeData );\n\tif ( all_phrasing ) {\n\t\tSaveList( &treeData );\n\t\tCountMatchCnnct( &treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq );\n\t\tSortListByScore( &treeData );\n\t\tNextCut( &treeData, &pgdata->phrOut );\n\t} else {\n\t\tDoDpPhrasing( pgdata, &treeData );\n\t}\n\n\tShowList( pgdata, &treeData );\n\n\t/* set phrasing output */\n\tOutputRecordStr( pgdata, &treeData );\n\tSaveDispInterval( &pgdata->phrOut, &treeData );\n\n\t/* free \"phrase\" */\n\tCleanUpMem( &treeData );\n\treturn 0;\n}",
        "begin_line": 1068,
        "end_line": 1096,
        "is_bug": false
    },
    {
        "name": "src.tree.RecursiveSave#754",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.RecursiveSave( int depth, int to, int *record, TreeDataType *ptd )",
        "snippet": "static void RecursiveSave( int depth, int to, int *record, TreeDataType *ptd )\n{\n\tint first, i;\n\t/* to find first interval */\n\tfor (\n\t\tfirst = record[ depth - 1 ] + 1;\n\t\tptd->interval[ first ].from < to && first < ptd->nInterval;\n\t\tfirst++ )\n\t\t;\n\n\tif ( first == ptd->nInterval ) {\n\t\tSaveRecord( record + 1, depth - 1, ptd );\n\t\treturn;\n\t}\n\trecord[ depth ] = first;\n\tRecursiveSave( depth + 1, ptd->interval[ first ].to, record, ptd );\n\t/* for each interval which intersects first */\n\tfor (\n\t\ti= first + 1;\n\t\tPhraseIntervalIntersect(\n\t\t\tptd->interval[ first ],\n\t\t\tptd->interval[ i ] ) && i < ptd->nInterval;\n\t\t\ti++ ) {\n\t\trecord[ depth ] = i;\n\t\tRecursiveSave( depth + 1, ptd->interval[ i ].to,record, ptd );\n\t}\n}",
        "begin_line": 754,
        "end_line": 780,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveDispInterval#794",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )",
        "snippet": "static void SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )\n{\n\tint i;\n\n\tfor ( i = 0; i < ptd->phList->nInter; i++ ) {\n\t\tppo->dispInterval[ i ].from =\n\t\t\tptd->interval[ ptd->phList->arrIndex[ i ] ].from;\n\t\tppo->dispInterval[ i ].to =\n\t\t\tptd->interval[ ptd->phList->arrIndex[ i ] ].to;\n\t}\n\tppo->nDispInterval = ptd->phList->nInter;\n}",
        "begin_line": 794,
        "end_line": 805,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveList#782",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveList( TreeDataType *ptd )",
        "snippet": "static void SaveList( TreeDataType *ptd )\n{\n\tint record[ MAX_PHONE_SEQ_LEN + 1 ] = { -1 };\n\n\tRecursiveSave( 1, 0, record, ptd );\n}",
        "begin_line": 782,
        "end_line": 787,
        "is_bug": false
    },
    {
        "name": "src.tree.SaveRecord#718",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SaveRecord( const int *record, int nInter, TreeDataType *ptd )",
        "snippet": "static void SaveRecord( const int *record, int nInter, TreeDataType *ptd )\n{\n\tRecordNode *now, *p, *pre;\n\n\tpre = NULL;\n\tfor ( p = ptd->phList; p; ) {\n\t\t/* if  'p' contains 'record', then discard 'record'. */\n\t\tif ( IsRecContain( p->arrIndex, p->nInter, record, nInter, ptd ) )\n\t\t\treturn;\n\n\t\t/* if 'record' contains 'p', then discard 'p'\n\t\t * -- We must deal with the linked list. */\n\t\tif ( IsRecContain( record, nInter, p->arrIndex, p->nInter, ptd ) ) {\n\t\t\tRecordNode *tp = p;\n\n\t\t\tif ( pre )\n\t\t\t\tpre->next = p->next;\n\t\t\telse\n\t\t\t\tptd->phList = ptd->phList->next;\n\t\t\tp = p->next;\n\t\t\tfree( tp->arrIndex );\n\t\t\tfree( tp );\n\t\t}\n\t\telse\n\t\t\tpre = p, p = p->next;\n\t}\n\tnow = ALC( RecordNode, 1 );\n\tassert( now );\n\tnow->next = ptd->phList;\n\tnow->arrIndex = ALC( int, nInter );\n\tassert( now->arrIndex );\n\tnow->nInter = nInter;\n\tmemcpy( now->arrIndex, record, nInter * sizeof( int ) );\n\tptd->phList = now;\n}",
        "begin_line": 718,
        "end_line": 752,
        "is_bug": false
    },
    {
        "name": "src.tree.SetInfo#410",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SetInfo( int len, TreeDataType *ptd )",
        "snippet": "static void SetInfo( int len, TreeDataType *ptd )\n{\n\tint i, a;\n\n\tfor ( i = 0; i <= len; i++ )\n\t\tptd->leftmost[ i ] = i;\n\tfor ( i = 0; i < ptd->nInterval; i++ ) {\n\t\tptd->graph[ ptd->interval[ i ].from ][ ptd->interval[ i ].to ] = 1;\n\t\tptd->graph[ ptd->interval[ i ].to ][ ptd->interval[ i ].from ] = 1;\n\t}\n\n\t/* set leftmost */\n\tfor ( a = 0; a <= len; a++ ) {\n\t\tfor ( i = 0; i <= len; i++ ) {\n\t\t\tif ( ! ( ptd->graph[ a ][ i ] ) )\n\t\t\t\tcontinue;\n\t\t\tif ( ptd->leftmost[ i ] < ptd->leftmost[ a ] )\n\t\t\t\tptd->leftmost[ a ] = ptd->leftmost[ i ];\n\t\t}\n\t}\n}",
        "begin_line": 410,
        "end_line": 430,
        "is_bug": false
    },
    {
        "name": "src.tree.ShowList#850",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.ShowList( ChewingData *pgdata, const TreeDataType *ptd )",
        "snippet": "static void ShowList( ChewingData *pgdata, const TreeDataType *ptd )\n{\n\tconst RecordNode *p;\n\tint i;\n\n\tDEBUG_OUT( \"After SaveList :\\n\" );\n\tfor ( p = ptd->phList; p; p = p->next ) {\n\t\tDEBUG_OUT( \"  interval : \" );\n\t\tfor ( i = 0; i < p->nInter; i++ ) {\n\t\t\tDEBUG_OUT(\n\t\t\t\t\"[%d %d] \",\n\t\t\t\tptd->interval[ p->arrIndex[ i ] ].from,\n\t\t\t\tptd->interval[ p->arrIndex[ i ] ].to );\n\t\t}\n\t\tDEBUG_OUT(\n\t\t\t\"\\n\"\n\t\t\t   \"      score : %d , nMatchCnnct : %d\\n\",\n\t\t\tp->score,\n\t\t\tp->nMatchCnnct );\n\t}\n\tDEBUG_OUT( \"\\n\" );\n}",
        "begin_line": 850,
        "end_line": 871,
        "is_bug": false
    },
    {
        "name": "src.tree.SortByIncreaseEnd#904",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SortByIncreaseEnd( const void *x, const void *y)",
        "snippet": "static int SortByIncreaseEnd( const void *x, const void *y)\n{\n\tconst PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;\n\tconst PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;\n\n\tif ( interval_x->to < interval_y->to )\n\t\treturn -1;\n\n\tif ( interval_x->to > interval_y->to )\n\t\treturn 1;\n\n\treturn 0;\n}",
        "begin_line": 904,
        "end_line": 916,
        "is_bug": false
    },
    {
        "name": "src.tree.SortListByScore#680",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.SortListByScore( TreeDataType *ptd )",
        "snippet": "static void SortListByScore( TreeDataType *ptd )\n{\n\tint i, listLen;\n\tRecordNode *p, **arr;\n\n\tfor (\n\t\tlistLen = 0, p = ptd->phList;\n\t\tp;\n\t\tlistLen++, p = p->next )\n\t\t;\n\tptd->nPhListLen = listLen;\n\n\tarr = ALC( RecordNode *, listLen );\n\tassert( arr );\n\n\tfor (\n\t\ti = 0, p = ptd->phList;\n\t\ti < listLen;\n\t\tp = p->next, i++ ) {\n\t\tarr[ i ] = p;\n\t\tp->score = LoadPhraseAndCountScore(\n\t\t\tp->arrIndex,\n\t\t\tp->nInter,\n\t\t\tptd );\n\t}\n\n\tqsort( arr, listLen, sizeof( RecordNode * ), (CompFuncType) CompRecord );\n\n\tptd->phList = arr[ 0 ];\n\tfor ( i = 1; i < listLen; i++ ) {\n\t\tarr[ i - 1 ]->next = arr[ i ];\n\t}\n\tarr[ listLen - 1 ]->next = NULL;\n\n\tfree( arr );\n}",
        "begin_line": 680,
        "end_line": 715,
        "is_bug": false
    },
    {
        "name": "src.tree.TerminateTree#78",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.TerminateTree( ChewingData *pgdata )",
        "snippet": "void TerminateTree( ChewingData *pgdata )\n{\n\t\tpgdata->static_data.tree = NULL;\n\t\tplat_mmap_close( &pgdata->static_data.tree_mmap );\n}",
        "begin_line": 78,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "src.tree.TreeChildRange#279",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.TreeChildRange( ChewingData *pgdata, const TreeType *parent )",
        "snippet": "void TreeChildRange( ChewingData *pgdata, const TreeType *parent )\n{\n\tpgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);\n\tpgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);\n}",
        "begin_line": 279,
        "end_line": 283,
        "is_bug": false
    },
    {
        "name": "src.tree.TreeFindPhrase#251",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )",
        "snippet": "const TreeType *TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )\n{\n\tTreeType target;\n\tconst TreeType *tree_p = pgdata->static_data.tree;\n\tuint32_t range[2];\n\tint i;\n\n\tfor ( i = begin; i <= end; i++ ) {\n\t\tPutUint16(phoneSeq[i], target.key);\n\t\trange[0] = GetUint24(tree_p->child.begin);\n\t\trange[1] = GetUint24(tree_p->child.end);\n\t\ttree_p = (const TreeType*)bsearch(&target, pgdata->static_data.tree + range[0],\n\t\t\t\t\t\t  range[1] - range[0], sizeof(TreeType), CompTreeType);\n\n\t\t/* if not found any word then fail. */\n\t\tif( !tree_p )\n\t\t\treturn NULL;\n\t}\n\n\t/* If its child has no key value of 0, then it is only a \"half\" phrase. */\n\tif( GetUint16(pgdata->static_data.tree[ GetUint24(tree_p->child.begin) ].key) != 0)\n\t\treturn NULL;\n\treturn tree_p;\n}",
        "begin_line": 251,
        "end_line": 274,
        "is_bug": false
    },
    {
        "name": "src.tree.internal_release_Phrase#303",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )",
        "snippet": "static void internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )\n{\n\t/* we must free unused phrase entry to avoid memory leak. */\n\tswitch ( mode ) {\n\t\tcase USED_PHRASE_USER:\n\t\t\tif ( pDict != NULL )\n\t\t\t\tfree( pDict );\n\t\t\tbreak;\n\t\tcase USED_PHRASE_DICT:\n\t\t\tif ( pUser != NULL )\n\t\t\t\tfree( pUser );\n\t\t\tbreak;\n\t\tdefault: /* In fact, it is alwyas 0 */\n\t\t\tif ( pDict != NULL )\n\t\t\t\tfree( pDict );\n\t\t\tif ( pUser != NULL )\n\t\t\t\tfree( pUser );\n\t\t\tbreak;\n\t}\n}",
        "begin_line": 303,
        "end_line": 322,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_avgwordlen#603",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\t/* constant factor 6=1*2*3, to keep value as integer */\n\treturn 6 * rule_largest_sum( record, nRecord, ptd ) / nRecord;\n}",
        "begin_line": 603,
        "end_line": 607,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_freqsum#626",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, score = 0;\n\tPhraseIntervalType inter;\n\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tassert( inter.p_phr );\n\n\t\t/* We adjust the 'freq' of One-word Phrase */\n\t\tscore += ( inter.to - inter.from == 1 ) ?\n\t\t\t( inter.p_phr->freq / 512 ) :\n\t\t\tinter.p_phr->freq;\n\t}\n\treturn score;\n}",
        "begin_line": 626,
        "end_line": 641,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_largest_sum#590",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, score = 0;\n\tPhraseIntervalType inter;\n\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tinter = ptd->interval[ record[ i ] ];\n\t\tassert( inter.p_phr );\n\t\tscore += inter.to - inter.from;\n\t}\n\treturn score;\n}",
        "begin_line": 590,
        "end_line": 601,
        "is_bug": false
    },
    {
        "name": "src.tree.rule_smallest_lenvariance#609",
        "src_path": "src/tree.c",
        "class_name": "src.tree",
        "signature": "src.tree.rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )",
        "snippet": "static int rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )\n{\n\tint i, j, score = 0;\n\tPhraseIntervalType inter1, inter2;\n\n\t/* kcwu: heuristic? why variance no square function? */\n\tfor ( i = 0; i < nRecord; i++ ) {\n\t\tfor ( j = i + 1; j < nRecord; j++ ) {\n\t\t\tinter1 = ptd->interval[ record[ i ] ];\n\t\t\tinter2 = ptd->interval[ record[ j ] ];\n\t\t\tassert( inter1.p_phr && inter2.p_phr );\n\t\t\tscore += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));\n\t\t}\n\t}\n\treturn -score;\n}",
        "begin_line": 609,
        "end_line": 624,
        "is_bug": false
    },
    {
        "name": "src.userphrase.LoadMaxFreq#53",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.LoadMaxFreq( ChewingData *pgdata, const uint16_t phoneSeq[], int len )",
        "snippet": "static int LoadMaxFreq( ChewingData *pgdata, const uint16_t phoneSeq[], int len )\n{\n\tconst TreeType *tree_pos;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\tint maxFreq = FREQ_INIT_VALUE;\n\tUserPhraseData *uphrase;\n\n\ttree_pos = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );\n\tif ( tree_pos ) {\n\t\tGetPhraseFirst( pgdata, phrase, tree_pos );\n\t\tdo {\n\t\t\tif ( phrase->freq > maxFreq )\n\t\t\t\tmaxFreq = phrase->freq;\n\t\t} while( GetVocabNext( pgdata, phrase ) );\n\t}\n\tfree( phrase );\n\n\tuphrase = UserGetPhraseFirst( pgdata, phoneSeq );\n\twhile ( uphrase ) {\n\t\tif ( uphrase->userfreq > maxFreq )\n\t\t\tmaxFreq = uphrase->userfreq;\n\t\tuphrase = UserGetPhraseNext( pgdata, phoneSeq );\n\t}\n\n\treturn maxFreq;\n}",
        "begin_line": 53,
        "end_line": 78,
        "is_bug": false
    },
    {
        "name": "src.userphrase.LoadOriginalFreq#27",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )",
        "snippet": "static int LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )\n{\n\tconst TreeType *tree_pos;\n\tint retval;\n\tPhrase *phrase = ALC( Phrase, 1 );\n\n\ttree_pos = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );\n\tif ( tree_pos ) {\n\t\tGetPhraseFirst( pgdata, phrase, tree_pos );\n\t\tdo {\n\t\t\t/* find the same phrase */\n\t\t\tif ( ! strcmp(\n\t\t\t\tphrase->phrase,\n\t\t\t\twordSeq ) ) {\n\t\t\t\tretval = phrase->freq;\n\t\t\t\tfree( phrase );\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t} while ( GetVocabNext( pgdata, phrase ) );\n\t}\n\n\tfree( phrase );\n\treturn FREQ_INIT_VALUE;\n}",
        "begin_line": 27,
        "end_line": 50,
        "is_bug": false
    },
    {
        "name": "src.userphrase.LogUserPhrase#114",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.LogUserPhrase( \tChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int orig_freq, int max_freq, int user_freq, int recent_time)",
        "snippet": "static void LogUserPhrase(\n\tChewingData *pgdata,\n\tconst uint16_t phoneSeq[],\n\tconst char wordSeq[],\n\tint orig_freq,\n\tint max_freq,\n\tint user_freq,\n\tint recent_time)\n{\n\t/* Size of each phone is len(\"0x1234 \") = 7 */\n\tchar buf[7 * MAX_PHRASE_LEN + 1] = { 0 };\n\tint i;\n\n\tfor ( i = 0; i < MAX_PHRASE_LEN; ++i ) {\n\t\tif ( phoneSeq[i] == 0 )\n\t\t\tbreak;\n\t\tsnprintf( buf + 7 * i, 7 + 1, \"%#06x \", phoneSeq[i] );\n\t}\n\n\tLOG_INFO( \"userphrase %s, phone = %s, orig_freq = %d, max_freq = %d, user_freq = %d, recent_time = %d\\n\",\n\t\twordSeq, buf, orig_freq, max_freq, user_freq, recent_time );\n}",
        "begin_line": 114,
        "end_line": 135,
        "is_bug": false
    },
    {
        "name": "src.userphrase.UpdateFreq#81",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.UpdateFreq( int freq, int maxfreq, int origfreq, int deltatime )",
        "snippet": "static int UpdateFreq( int freq, int maxfreq, int origfreq, int deltatime )\n{\n\tint delta;\n\n\t/* Short interval */\n\tif ( deltatime < 4000 ) {\n\t\tdelta = ( freq >= maxfreq ) ?\n\t\t\tmin(\n\t\t\t\t( maxfreq - origfreq ) / 5 + 1,\n\t\t\t\tSHORT_INCREASE_FREQ ) :\n\t\t\tmax(\n\t\t\t\t( maxfreq - origfreq ) / 5 + 1,\n\t\t\t\tSHORT_INCREASE_FREQ );\n\t\treturn min( freq + delta, MAX_ALLOW_FREQ );\n\t}\n\t/* Medium interval */\n\telse if ( deltatime < 50000 ) {\n\t\tdelta = ( freq >= maxfreq ) ?\n\t\t\tmin(\n\t\t\t\t( maxfreq - origfreq ) / 10 + 1,\n\t\t\t\tMEDIUM_INCREASE_FREQ ) :\n\t\t\tmax(\n\t\t\t\t( maxfreq - origfreq ) / 10 + 1,\n\t\t\t\tMEDIUM_INCREASE_FREQ );\n\t\treturn min( freq + delta, MAX_ALLOW_FREQ );\n\t}\n\t/* long interval */\n\telse {\n\t\tdelta = max( ( freq - origfreq ) / 5, LONG_DECREASE_FREQ );\n\t\treturn max( freq - delta, origfreq );\n\t}\n}",
        "begin_line": 81,
        "end_line": 112,
        "is_bug": false
    },
    {
        "name": "src.userphrase.UserGetPhraseFirst#179",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.UserGetPhraseFirst( ChewingData *pgdata, const uint16_t phoneSeq[] )",
        "snippet": "UserPhraseData *UserGetPhraseFirst( ChewingData *pgdata, const uint16_t phoneSeq[] )\n{\n\tpgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, NULL );\n\tif ( ! pgdata->prev_userphrase )\n\t\treturn NULL;\n\treturn &( pgdata->prev_userphrase->data );\n}",
        "begin_line": 179,
        "end_line": 185,
        "is_bug": false
    },
    {
        "name": "src.userphrase.UserGetPhraseNext#187",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.UserGetPhraseNext( ChewingData *pgdata, const uint16_t phoneSeq[] )",
        "snippet": "UserPhraseData *UserGetPhraseNext( ChewingData *pgdata, const uint16_t phoneSeq[] )\n{\n\tpgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, pgdata->prev_userphrase );\n\tif ( ! pgdata->prev_userphrase )\n\t\treturn NULL;\n\treturn &( pgdata->prev_userphrase->data );\n}",
        "begin_line": 187,
        "end_line": 193,
        "is_bug": false
    },
    {
        "name": "src.userphrase.UserUpdatePhrase#137",
        "src_path": "src/userphrase.c",
        "class_name": "src.userphrase",
        "signature": "src.userphrase.UserUpdatePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )",
        "snippet": "int UserUpdatePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )\n{\n\tHASH_ITEM *pItem;\n\tUserPhraseData data;\n\tint len;\n\n\tlen = ueStrLen( wordSeq );\n\tpItem = HashFindEntry( pgdata, phoneSeq, wordSeq );\n\tif ( ! pItem ) {\n\t\tif ( ! AlcUserPhraseSeq( &data, len, strlen( wordSeq ) ) ) {\n\t\t\treturn USER_UPDATE_FAIL;\n\t\t}\n\n\t\tmemcpy( data.phoneSeq, phoneSeq, len * sizeof( phoneSeq[ 0 ] ) );\n\t\tdata.phoneSeq[ len ] = 0;\n\t\tstrcpy( data.wordSeq, wordSeq );\n\n\t\t/* load initial freq */\n\t\tdata.origfreq = LoadOriginalFreq( pgdata, phoneSeq, wordSeq, len );\n\t\tdata.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );\n\n\t\tdata.userfreq = data.origfreq;\n\t\tdata.recentTime = pgdata->static_data.chewing_lifetime;\n\t\tpItem = HashInsert( pgdata, &data );\n\t\tLogUserPhrase( pgdata, phoneSeq, wordSeq, pItem->data.origfreq, pItem->data.maxfreq, pItem->data.userfreq, pItem->data.recentTime );\n\t\tHashModify( pgdata, pItem );\n\t\treturn USER_UPDATE_INSERT;\n\t}\n\telse {\n\t\tpItem->data.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );\n\t\tpItem->data.userfreq = UpdateFreq(\n\t\t\tpItem->data.userfreq,\n\t\t\tpItem->data.maxfreq,\n\t\t\tpItem->data.origfreq,\n\t\t\tpgdata->static_data.chewing_lifetime - pItem->data.recentTime );\n\t\tpItem->data.recentTime = pgdata->static_data.chewing_lifetime;\n\t\tLogUserPhrase( pgdata, phoneSeq, wordSeq, pItem->data.origfreq, pItem->data.maxfreq, pItem->data.userfreq, pItem->data.recentTime );\n\t\tHashModify( pgdata, pItem );\n\t\treturn USER_UPDATE_MODIFY;\n\t}\n}",
        "begin_line": 137,
        "end_line": 177,
        "is_bug": false
    },
    {
        "name": "src.zuin.DefPhoInput#149",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.DefPhoInput( ChewingData *pgdata, int key )",
        "snippet": "static int DefPhoInput( ChewingData *pgdata, int key )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tint type = 0, inx = 0;\n\tint i;\n\n\tif ( IsDefPhoEndKey( key, pZuin->kbtype ) ) {\n\t\tfor ( i = 0; i < ZUIN_SIZE; ++i )\n\t\t\tif ( pZuin->pho_inx[ i ] != 0 )\n\t\t\t\tbreak;\n\t\tif ( i < ZUIN_SIZE )\n\t\t\treturn EndKeyProcess( pgdata, key, 1 );\n\t}\n\telse {\n\t\tpZuin->pho_inx[ 3 ] = 0;\n\t}\n\n\t/* decide if the key is a phone */\n\tfor ( type = 0; type <= 3; type++ ) {\n\t\tinx = PhoneInxFromKey( key, type, pZuin->kbtype, 1 );\n\t\tif ( inx )\n\t\t\tbreak;\n\t}\n\n\t/* the key is NOT a phone */\n\tif ( type > 3 ) {\n\t\treturn ZUIN_KEY_ERROR;\n\t}\n\n\t/* fill the key into the phone buffer */\n\tpZuin->pho_inx[ type ] = inx;\n\treturn ZUIN_ABSORB;\n}",
        "begin_line": 149,
        "end_line": 181,
        "is_bug": false
    },
    {
        "name": "src.zuin.EndKeyProcess#93",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.EndKeyProcess( ChewingData *pgdata, int key, int searchTimes )",
        "snippet": "static int EndKeyProcess( ChewingData *pgdata, int key, int searchTimes )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tuint16_t u16Pho, u16PhoAlt;\n\tPhrase tempword;\n\tint pho_inx;\n\n\tif (\n\t\tpZuin->pho_inx[ 0 ] == 0 &&\n\t\tpZuin->pho_inx[ 1 ] == 0 &&\n\t\tpZuin->pho_inx[ 2 ] == 0 &&\n\t\tpZuin->pho_inx[ 3 ] == 0 ) {\n\t\t/*\n\t\t * Special handle for space key (Indeed very special one).\n\t\t * Un-break the situation that OnKeySpace() is not called,\n\t\t * hence the Candidate window doesn't show up, because\n\t\t * ZUIN_NO_WORD is returned.\n\t\t */\n\t\treturn (key == ' ') ? ZUIN_KEY_ERROR : ZUIN_NO_WORD;\n\t}\n\n\tpho_inx = PhoneInxFromKey( key, 3, pZuin->kbtype, searchTimes );\n\tif ( pZuin->pho_inx[ 3 ] == 0 ) {\n\t\tpZuin->pho_inx[ 3 ] = pho_inx;\n\t\tpZuin->pho_inx_alt[ 3 ] = pho_inx;\n\t}\n\telse if ( key != ' ' ) {\n\t\tpZuin->pho_inx[ 3 ] = pho_inx;\n\t\tpZuin->pho_inx_alt[ 3 ] = pho_inx;\n\t\treturn ZUIN_NO_WORD;\n\t}\n\n\tu16Pho = UintFromPhoneInx( pZuin->pho_inx );\n\tif ( GetCharFirst( pgdata, &tempword, u16Pho ) == 0 ) {\n\t\tZuinRemoveAll( pZuin );\n\t\treturn ZUIN_NO_WORD;\n\t}\n\n\tpZuin->phone = u16Pho;\n\n\tif ( pZuin->pho_inx_alt[ 0 ] == 0 &&\n\t     pZuin->pho_inx_alt[ 1 ] == 0 &&\n\t     pZuin->pho_inx_alt[ 2 ] == 0 ) {\n\t\t/* no alternative phone, copy from default as alt */\n\t\tpZuin->phoneAlt = u16Pho;\n\t}\n\telse {\n\t\tu16PhoAlt = UintFromPhoneInx( pZuin->pho_inx_alt );\n\t\tpZuin->phoneAlt = u16PhoAlt;\n\t}\n\n\tmemset( pZuin->pho_inx, 0, sizeof( pZuin->pho_inx ) );\n\tmemset( pZuin->pho_inx_alt, 0, sizeof( pZuin->pho_inx_alt ) );\n\treturn ZUIN_COMMIT;\n}",
        "begin_line": 93,
        "end_line": 147,
        "is_bug": false
    },
    {
        "name": "src.zuin.IsDefPhoEndKey#83",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.IsDefPhoEndKey( int key, int kbtype )",
        "snippet": "static int IsDefPhoEndKey( int key, int kbtype )\n{\n\tif ( PhoneInxFromKey( key, 3, kbtype, 1 )  )\n\t\treturn 1;\n\n\tif ( key == ' ' )\n\t\treturn 1;\n\treturn 0;\n}",
        "begin_line": 83,
        "end_line": 91,
        "is_bug": false
    },
    {
        "name": "src.zuin.ZuinIsEntering#693",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.ZuinIsEntering( ZuinData *pZuin )",
        "snippet": "int ZuinIsEntering( ZuinData *pZuin )\n{\n\tint i;\n        if ( pZuin->kbtype >= KB_HANYU_PINYIN ) {\n\t    if ( pZuin->pinYinData.keySeq[0] )\n\t\treturn 1;\n\t} else {\n\t    for ( i = 0; i < ZUIN_SIZE; i++ )\n\t\tif ( pZuin->pho_inx[ i ] )\n\t\t    return 1;\n\t}\n\treturn 0;\n}",
        "begin_line": 693,
        "end_line": 705,
        "is_bug": false
    },
    {
        "name": "src.zuin.ZuinPhoInput#642",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.ZuinPhoInput( ChewingData *pgdata, int key )",
        "snippet": "int ZuinPhoInput( ChewingData *pgdata, int key )\n{\n\tZuinData *pZuin = &(pgdata->zuinData);\n\tswitch ( pZuin->kbtype ) {\n\t\tcase KB_HSU:\n\t\tcase KB_DVORAK_HSU:\n\t\t\treturn HsuPhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_ET26:\n\t\t\treturn ET26PhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_DACHEN_CP26:\n\t\t\treturn DACHENCP26PhoInput( pgdata, key );\n\t\t\tbreak;\n\t\tcase KB_HANYU_PINYIN:\n\t\tcase KB_THL_PINYIN:\n\t\tcase KB_MPS2_PINYIN:\n\t\t\treturn PinYinInput( pgdata, key );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn DefPhoInput( pgdata, key );\n\t}\n\treturn ZUIN_ERROR;\n}",
        "begin_line": 642,
        "end_line": 665,
        "is_bug": false
    },
    {
        "name": "src.zuin.ZuinRemoveAll#686",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.ZuinRemoveAll( ZuinData *pZuin )",
        "snippet": "int ZuinRemoveAll( ZuinData *pZuin )\n{\n\tmemset( pZuin->pho_inx, 0, sizeof( pZuin->pho_inx ) );\n\tmemset( pZuin->pinYinData.keySeq, 0, sizeof( pZuin->pinYinData.keySeq ) );\n\treturn 0;\n}",
        "begin_line": 686,
        "end_line": 691,
        "is_bug": false
    },
    {
        "name": "src.zuin.ZuinRemoveLast#668",
        "src_path": "src/zuin.c",
        "class_name": "src.zuin",
        "signature": "src.zuin.ZuinRemoveLast( ZuinData *pZuin )",
        "snippet": "int ZuinRemoveLast( ZuinData *pZuin )\n{\n\tint i;\n\tif ( pZuin->kbtype >= KB_HANYU_PINYIN ) {\n\t\ti = strlen( pZuin->pinYinData.keySeq );\n\t\tpZuin->pinYinData.keySeq[ i - 1 ] = '\\0';\n\t} else {\n\t\tfor ( i = 3; i >= 0; i-- ) {\n\t\t\tif ( pZuin->pho_inx[ i ] ) {\n\t\t\t\tpZuin->pho_inx[ i ] = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 668,
        "end_line": 683,
        "is_bug": false
    }
]