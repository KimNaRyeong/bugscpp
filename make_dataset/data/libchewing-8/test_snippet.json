[
    {
        "name": "test.genkeystroke.drawline#69",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.drawline( int x, int y )",
        "snippet": "void drawline( int x, int y )\n{\n\tmove( x, y );\n\taddstr( FILL_LINE );\n}",
        "begin_line": 69,
        "end_line": 73,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.main#266",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.main( int argc, char *argv[] )",
        "snippet": "int main( int argc, char *argv[] )\n{\n\tChewingContext *ctx;\n\tFILE *fout;\n\tint ch;\n\tint add_phrase_length;\n\n\tif ( argc < 2 ) {\n\t\tfprintf( stderr, \"usage: genkeystroke filename\\n\" );\n\t\texit( 1 );\n\t}\n\telse {\n\t\tfout = fopen( argv[ 1 ], \"w\" );\n\t\tif ( ! fout ) {\n\t\t\tfprintf( stderr, \"Error: failed to open %s\\n\", argv[ 1 ] );\n\t\t\texit( 1 );\n\t\t}\n\t}\n\n\t/* Initialize curses library */\n\tsetlocale(LC_CTYPE, \"\");\n\tinitscr();\n\tif ( has_colors() == TRUE ) {\n\t\tstart_color();\n\t\tinit_pair( 1, COLOR_WHITE, COLOR_BLUE );\n\t\tinit_pair( 2, COLOR_RED, COLOR_YELLOW );\n\t\tinit_pair( 3, COLOR_WHITE, COLOR_RED );\n\t\thasColor = 1;\n\t}\n\tcbreak();\n\tnoecho();\n\tkeypad( stdscr, 1 );\n\tstart_color();\n\tclear();\n\trefresh();\n\n\t/* Initialize libchewing */\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\t/* for the sake of testing, we should not change existing hash data */\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\t/* Request handle to ChewingContext */\n\tctx = chewing_new();\n\n\t/* Set keyboard type */\n\tchewing_set_KBType( ctx, chewing_KBStr2Num( \"KB_DEFAULT\" ) );\n\n\t/* Fill configuration values */\n\tchewing_set_candPerPage( ctx, 9 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\tchewing_set_selKey( ctx, selKey_define, 10 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\tclear();\n\tmvaddstr( 0, 0, \"Any key to start testing...\" );\n\n\twhile ( TRUE ) {\n\t\tch = getch();\n\t\tswitch ( ch ) {\n\t\t\tcase KEY_LEFT:\n\t\t\t\tchewing_handle_Left( ctx );\n\t\t\t\tfprintf( fout, \"<L>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_SLEFT:\n\t\t\t\tchewing_handle_ShiftLeft( ctx );\n\t\t\t\tfprintf( fout, \"<SL>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_RIGHT:\n\t\t\t\tchewing_handle_Right( ctx );\n\t\t\t\tfprintf( fout, \"<R>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_SRIGHT:\n\t\t\t\tchewing_handle_ShiftRight( ctx );\n\t\t\t\tfprintf( fout, \"<SR>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_UP:\n\t\t\t\tchewing_handle_Up( ctx );\n\t\t\t\tfprintf( fout, \"<U>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_DOWN:\n\t\t\t\tchewing_handle_Down( ctx );\n\t\t\t\tfprintf( fout, \"<D>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_SPACE:\n\t\t\t\tchewing_handle_Space( ctx );\n\t\t\t\tfprintf( fout, \" \" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_ENTER:\n\t\t\t\tchewing_handle_Enter( ctx );\n\t\t\t\tfprintf( fout, \"<E>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_BACKSPACE:\n\t\t\t\tchewing_handle_Backspace( ctx );\n\t\t\t\tfprintf( fout, \"<B>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_ESC:\n\t\t\t\tchewing_handle_Esc( ctx );\n\t\t\t\tfprintf( fout, \"<EE>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_DC:\n\t\t\t\tchewing_handle_Del( ctx );\n\t\t\t\tfprintf( fout, \"<DC>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_HOME:\n\t\t\t\tchewing_handle_Home( ctx );\n\t\t\t\tfprintf( fout, \"<H>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_END:\n\t\t\t\tchewing_handle_End( ctx );\n\t\t\t\tfprintf( fout, \"<EN>\" );\n\t\t\t\tbreak;\n\t\t\tcase KEY_TAB:\n\t\t\t\tchewing_handle_Tab( ctx );\n\t\t\t\tfprintf( fout, \"<T>\" );\n\t\t\t\tbreak;\n\t\t\tcase CTRL_0:\n\t\t\tcase CTRL_1:\n\t\t\tcase CTRL_2:\n\t\t\tcase CTRL_3:\n\t\t\tcase CTRL_4:\n\t\t\tcase CTRL_5:\n\t\t\tcase CTRL_6:\n\t\t\tcase CTRL_7:\n\t\t\tcase CTRL_8:\n\t\t\tcase CTRL_9:\n\t\t\t\tadd_phrase_length = ( ch - CTRL_0 + '0' );\n\t\t\t\tchewing_handle_CtrlNum( ctx, add_phrase_length );\n\t\t\t\tfprintf( fout, \"<C%c>\", add_phrase_length );\n\t\t\t\tbreak;\n\t\t\tcase KEY_CTRL_('B'): /* emulate CapsLock */\n\t\t\t\tchewing_handle_Capslock( ctx );\n\t\t\t\tfprintf( fout, \"<CB>\");\n\t\t\t\tbreak;\n\t\t\tcase KEY_CTRL_('D'):\n\t\t\t\tgoto end;\n\t\t\tcase KEY_CTRL_('H'): /* emulate Shift */\n\t\t\t\tif ( chewing_get_ShapeMode( ctx ) == FULLSHAPE_MODE )\n\t\t\t\t\tchewing_set_ShapeMode( ctx, HALFSHAPE_MODE );\n\t\t\t\telse\n\t\t\t\t\tchewing_set_ShapeMode( ctx, FULLSHAPE_MODE );\n\t\t\t\tbreak;\n\t\t\tcase KEY_NPAGE:\n\t\t\t\tchewing_handle_PageDown( ctx );\n\t\t\t\tfprintf( fout, \"<PD>\");\n\t\t\t\tbreak;\n\t\t\tcase KEY_PPAGE:\n\t\t\t\tchewing_handle_PageUp( ctx );\n\t\t\t\tfprintf( fout, \"<PU>\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tchewing_handle_Default( ctx, (char) ch );\n\t\t\t\tif ( ch != '<' && ch != '>' )\n\t\t\t\t\tfprintf( fout, \"%c\", (char) ch );\n\t\t\t\telse\n\t\t\t\t\tfprintf( fout, \"<%c>\", (char) ch );\n\t\t\t\tbreak;\n\t\t}\n\t\tdrawline( 0, 0 );\n\t\tdrawline( 2, 0 );\n\t\tshow_interval_buffer( 3, 0, ctx );\n\t\tdrawline( 4, 0 );\n\t\tshow_choose_buffer( 5, 0, ctx );\n\t\tdrawline( 6, 0 );\n\t\tshow_zuin_buffer( 7, 0, ctx );\n\t\tshow_full_shape( 7, 5, ctx );\n\t\tdrawline( 8, 0 );\n\t\tmvaddstr( 9, 0, \"Ctrl + d : leave\" );\n\t\tmvaddstr( 9, 20, \"Ctrl + b : toggle Eng/Chi mode\" );\n\t\tmvaddstr( 10, 0, \"F1, F2, F3, ..., F9 : Add user defined phrase\");\n\t\tmvaddstr( 11, 0, \"Ctrl + h : toggle Full/Half shape mode\" );\n\t\tshow_commit_string( 12, 0, ctx );\n\t\tshow_userphrase( 7, 12, ctx );\n\t\tshow_edit_buffer( 1, 0, ctx );\n\t}\nend:\n\tendwin();\n\n\t/* Release Chewing context */\n\tchewing_delete( ctx );\n\n\t/* Termate Chewing services */\n\n\tfprintf( fout, \"\\n\" );\n\tfclose( fout );\n\treturn 0;\n}",
        "begin_line": 266,
        "end_line": 454,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.showZuin#145",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.showZuin( ChewingContext *ctx )",
        "snippet": "void showZuin( ChewingContext *ctx )\n{\n\tint zuin_count;\n\tchar *zuin_string;\n\tif ( chewing_get_ChiEngMode( ctx ) )\n\t\taddstr( \"[\u4e2d]\" );\n\telse\n\t\taddstr( \"[\u82f1]\" );\n\taddstr( \"        \" );\n\tzuin_string = chewing_zuin_String( ctx, &zuin_count );\n\taddstr( zuin_string );\n\tfree( zuin_string );\n}\n\nvo",
        "begin_line": 145,
        "end_line": 157,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_choose_buffer#204",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_choose_buffer( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_choose_buffer( int x, int y, ChewingContext *ctx )\n{\n\tint i = 1;\n\tint currentPageNo;\n\tchar str[ 20 ];\n\tchar *cand_string;\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tmove( x, y );\n\n\tif ( chewing_cand_TotalPage( ctx ) == 0 )\n\t\treturn;\n\n\tchewing_cand_Enumerate( ctx );\n\twhile ( chewing_cand_hasNext( ctx ) ) {\n\t\tif ( i > chewing_cand_ChoicePerPage( ctx ) )\n\t\t\tbreak;\n\t\tsprintf( str, \"%d.\", i );\n\t\tif ( hasColor )\n\t\t\tattron( COLOR_PAIR( 3 ) );\n\t\taddstr( str );\n\t\tif ( hasColor )\n\t\t\tattroff( COLOR_PAIR( 3 ) );\n\t\tcand_string = chewing_cand_String( ctx );\n\t\tsprintf( str, \" %s \", cand_string );\n\t\taddstr( str );\n\t\tfree( cand_string );\n\t\ti++;\n\t}\n\tcurrentPageNo = chewing_cand_CurrentPage( ctx );\n\tif ( chewing_cand_TotalPage( ctx ) != 1 ) {\n\t\tif ( currentPageNo == 0 )\n\t\t\taddstr( \"  >\" );\n\t\telse if ( currentPageNo == ( chewing_cand_TotalPage( ctx ) - 1 ) )\n\t\t\taddstr( \"<  \" );\n\t\telse\n\t\t\taddstr( \"< >\" );\n\t}\n}",
        "begin_line": 204,
        "end_line": 242,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_commit_string#244",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_commit_string( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_commit_string( int x, int y, ChewingContext *ctx )\n{\n\tchar *commit_string;\n#if 0\n\tif ( pgo->keystrokeRtn & KEYSTROKE_COMMIT ) {\n\t\tfor ( i = 0; i < pgo->nCommitStr; i++ ) {\n\t\t\tmvaddstr( x, y, (const char *) pgo->commitStr[ i ].s );\n\t\t\ty = ( y >= 54 ) ?\n\t\t\t\t0 :\n\t\t\t\t( y + strlen( (const char *) pgo->commitStr[ i ].s ) - 3 < 0 ? y + 1 : y + 2 );\n\t\t\tx = ( y == 0 ) ? ( x + 1 ) : x;\n\t\t}\n\t}\n#endif\n\tif ( chewing_commit_Check( ctx ) ) {\n\t\tcommit_string = chewing_commit_String( ctx );\n\t\tmvaddstr( x, y, FILL_BLANK);\n\t\tmvaddstr( x, y, commit_string );\n\t\tfree( commit_string );\n\t}\n}",
        "begin_line": 244,
        "end_line": 264,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_edit_buffer#75",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_edit_buffer( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_edit_buffer( int x, int y, ChewingContext *ctx )\n{\n\tint i, cursor, count;\n\tchar *buffer_string;\n\tchar *p;\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tif ( ! chewing_buffer_Check( ctx ) ) {\n\t\tmove( x, y );\n\t\treturn;\n\t}\n\tbuffer_string = chewing_buffer_String( ctx );\n\tmvaddstr( x, y, buffer_string );\n\tcursor = chewing_cursor_Current( ctx );\n\tp = buffer_string;\n\tcount = 0;\n\tfor ( i = 0 ;i < cursor; i++ ) {\n\t\tcount += ueBytesFromChar(*p) <= 1 ? 1 : 2;\n\t\tp += ueBytesFromChar(*p);\n\t}\n\tmove( x, count );\n\tfree( buffer_string );\n}",
        "begin_line": 75,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_full_shape#171",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_full_shape( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_full_shape( int x, int y, ChewingContext *ctx )\n{\n\tmove( x, y );\n\taddstr( \"[\" );\n\tif ( hasColor )\n\t\tattron( COLOR_PAIR( 2 ) );\n\tif ( chewing_get_ShapeMode( ctx ) == FULLSHAPE_MODE )\n\t\taddstr( \"\u5168\u5f62\" );\n\telse\n\t\taddstr( \"\u534a\u5f62\" );\n\tif ( hasColor )\n\t\tattroff( COLOR_PAIR( 2 ) );\n\taddstr( \"]\" );\n}\n\nvoid s",
        "begin_line": 171,
        "end_line": 184,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_interval_buffer#99",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_interval_buffer( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_interval_buffer( int x, int y, ChewingContext *ctx )\n{\n\tchar *buf;\n\tchar *p;\n\tint buf_len;\n\tchar out_buf[ 100 ];\n\tint i, count;\n\tint arrPos[ 50 ];\n\tIntervalType it;\n\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tmove( x, y );\n\n\t/* Check if buffer is available. */\n\tif ( ! chewing_buffer_Check( ctx ) ) {\n\t\treturn;\n\t}\n\n\tbuf = chewing_buffer_String( ctx );\n\tbuf_len = chewing_buffer_Len( ctx );\n\n\tp = buf;\n\tcount = 0;\n\tfor ( i = 0 ;i < buf_len; i++ ) {\n\t\tarrPos[ i ] = count;\n\t\tcount += ueBytesFromChar(*p) <= 1 ? 1 : 2;\n\t\tp += ueBytesFromChar(*p);\n\t}\n\tarrPos[ i ] = count;\n\n\tmemset( out_buf, ' ', count * ( sizeof( char ) ) );\n\tout_buf[ count ] = '\\0';\n\n\tchewing_interval_Enumerate( ctx );\n\twhile ( chewing_interval_hasNext( ctx ) ) {\n\t\tchewing_interval_Get( ctx, &it );\n\t\tout_buf[ arrPos[ it.from ] ] = '[';\n\t\tout_buf[ arrPos[ it.to ] - 1 ] =  ']';\n\t\tmemset(\n\t\t\t&out_buf[ arrPos[ it.from ] + 1 ], '-',\n\t\t\tarrPos[ it.to ] - arrPos[ it.from ] - 2 );\n\t}\n\taddstr( out_buf );\n}",
        "begin_line": 99,
        "end_line": 143,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_userphrase#186",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_userphrase( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_userphrase( int x, int y, ChewingContext *ctx )\n{\n\tchar *aux_string;\n\tif ( chewing_aux_Length( ctx ) == 0 )\n\t\treturn;\n\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tmove( x, y );\n\tif ( hasColor )\n\t\tattron( COLOR_PAIR( 2 ) );\n\taux_string = chewing_aux_String( ctx );\n\taddstr( aux_string );\n\tfree( aux_string );\n\tif ( hasColor )\n\t\tattroff( COLOR_PAIR( 2 ) );\n}",
        "begin_line": 186,
        "end_line": 202,
        "is_bug": false
    },
    {
        "name": "test.genkeystroke.show_zuin_buffer#159",
        "src_path": "test/genkeystroke.c",
        "class_name": "test.genkeystroke",
        "signature": "test.genkeystroke.show_zuin_buffer( int x, int y, ChewingContext *ctx )",
        "snippet": "void show_zuin_buffer( int x, int y, ChewingContext *ctx )\n{\n\tmove( x, y );\n\taddstr( FILL_BLANK );\n\tmove( x, y );\n\tif ( hasColor )\n\t\tattron( COLOR_PAIR( 1 ) );\n\tshowZuin( ctx );\n\tif ( hasColor )\n\t\tattroff( COLOR_PAIR( 1 ) );\n}",
        "begin_line": 159,
        "end_line": 169,
        "is_bug": false
    },
    {
        "name": "test.performance.main#15",
        "src_path": "test/performance.c",
        "class_name": "test.performance",
        "signature": "test.performance.main()",
        "snippet": "int main()\n{\n\tChewingContext *ctx;\n\tint ch;\n\n\t/* Initialize libchewing */\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\t/* for the sake of testing, we should not change existing hash data */\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tctx = chewing_new();\n\n\twhile ( ( ch = getchar() ) != EOF ) {\n\t\tchewing_handle_Default( ctx, ch );\n\t}\n\n\tchewing_delete( ctx );\n\treturn 0;\n}",
        "begin_line": 15,
        "end_line": 33,
        "is_bug": false
    },
    {
        "name": "test.randkeystroke.main#51",
        "src_path": "test/randkeystroke.c",
        "class_name": "test.randkeystroke",
        "signature": "test.randkeystroke.main( int argc, char *argv[] )",
        "snippet": "int main( int argc, char *argv[] )\n{\n\tint nk = 100;\n\tint total_random = 0;\n\tint i, n;\n\tint n_tab1 = strlen(zhuin_tab[0]);\n\tint n_tab2 = strlen(zhuin_tab[1]);\n\tint n_tab3 = strlen(zhuin_tab[2]);\n\tint n_tab4 = strlen(zhuin_tab[3]);\n\n\tsrand( time( NULL ) );\n\n\tfor ( i = 1; i < argc; i++ ) {\n\t\tif ( ! strcmp( argv[i], \"-n\" ) ) {\n\t\t\tif ( ++i < argc )\n\t\t\t\tnk = atoi( argv[i] );\n\t\t} else if ( ! strcmp( argv[i], \"-r\" ) ) {\n\t\t\ttotal_random = 1;\n\t\t} else if ( ! strcmp( argv[i], \"-s\" ) ) {\n\t\t    \tif ( ++i < argc )\n\t\t\t    \tsrand( atoi( argv[i] ) );\n\t\t} else if ( ! strcmp( argv[i], \"-h\" ) ) {\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (total_random) {\n\t\tfor ( i = 0; i < nk; i++ ) {\n\t\t\tn = rand() % (n_nkeys + n_okeys);\n\t\t\tif ( n >= n_nkeys )\n\t\t\t\tprintf( \"%s\", other_keys[n - n_nkeys] );\n\t\t\telse\n\t\t\t\tprintf( \"%c\", normal_keys[n] );\n\t\t}\n\t} else {\n\t\tfor ( i = 0; i < nk; i++ ) {\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"%c\", zhuin_tab[0][ rand() % n_tab1 ] );\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"%c\", zhuin_tab[1][ rand() % n_tab2 ] );\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"%c\", zhuin_tab[2][ rand() % n_tab3 ] );\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"%c\", zhuin_tab[3][ rand() % n_tab4 ] );\n\t\t\telse\n\t\t\t\tprintf( \" \" );\n\t\t\tif ( rand() % 2 )\n\t\t\t\tprintf( \"<E>\" );\n\t\t}\n\t}\n\tprintf( \"\\n\" );\n\n\treturn 0;\n}",
        "begin_line": 51,
        "end_line": 104,
        "is_bug": false
    },
    {
        "name": "test.randkeystroke.usage#42",
        "src_path": "test/randkeystroke.c",
        "class_name": "test.randkeystroke",
        "signature": "test.randkeystroke.usage()",
        "snippet": "void usage()\n{\n\tprintf( \"usage: randkeystroke [-r] [-n num] [-h]\\n\" \\\n\t\t\"\\t -r     - total random\\n\" \\\n\t\t\"\\t -n num - generate num keystrokes\\n\"\n\t\t\"\\t -s seed - random seed\\n\"\n\t\t\"\\t -h     - help\\n\" );\n}",
        "begin_line": 42,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "test.simulate.chewing_test_Main#83",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.chewing_test_Main() #else int main() #endif",
        "snippet": "int chewing_test_Main()\n#else\nint main()\n#endif\n{\n\tChewingContext *ctx;\n\tint i;\n\n\t/* Initialize libchewing */\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\t/* for the sake of testing, we should not change existing hash data */\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\t/* Request handle to ChewingContext */\n\tctx = chewing_new();\n\n\t/* Set keyboard type */\n\tchewing_set_KBType( ctx, chewing_KBStr2Num( \"KB_DEFAULT\" ) );\n\n\tchewing_set_candPerPage( ctx, 9 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\tchewing_set_selKey( ctx, selKey_define, 10 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\n\twhile ( 1 ) {\n\t\ti = get_keystroke( get_char, NULL );\n\t\tif ( i == END )\n\t\t\tgoto end;\n                type_single_keystroke( ctx, i );\n\t\tcommit_string( ctx );\n#ifdef USED_IN_SIMULATION\n\t\tif ( i == KEY_ENTER )\n\t\t\tcompare_per_run();\n#endif\n\t}\nend:\n\t/* Free Chewing IM handle */\n\tchewing_delete( ctx );\n\n\t/* Termate Chewing services */\n#ifndef USED_IN_SIMULATION\n\tprintf( \"\\n\" );\n#endif\n\treturn 0;\n}",
        "begin_line": 83,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "test.simulate.commit_string#39",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.commit_string( ChewingContext *ctx )",
        "snippet": "void commit_string( ChewingContext *ctx )\n{\n\tchar *s;\n\tif ( chewing_commit_Check( ctx ) ) {\n\t\ts = chewing_commit_String( ctx );\n#ifdef USED_IN_SIMULATION\n\t\tstrcat( commit_string_buf, s );\n#else\n\t\tprintf( \"%s\", s );\n#endif\n\t\tfree( s );\n\t}\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "test.simulate.compare_per_run#54",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.compare_per_run()",
        "snippet": "void compare_per_run()\n{\n\tint i, len;\n\tchar utf8buf_expect[16];\n\tchar utf8buf_commit[16];\n\tprintf( \"Expected:  %s\", expect_string_buf );\n\tprintf( \"Committed: \");\n\n\ttested_word_count += (len = ueStrLen( expect_string_buf ) - 1);\n\t\t/* omit the suffix character */\n\tfor ( i = 0; i < len; i++ ) {\n\t\tueStrNCpy( utf8buf_expect,\n\t\t           ueStrSeek( expect_string_buf, i ),\n\t\t\t   1, STRNCPY_CLOSE );\n\t\tueStrNCpy( utf8buf_commit,\n\t\t           ueStrSeek( commit_string_buf, i ),\n\t\t\t   1, STRNCPY_CLOSE );\n\t\tif ( ! strcmp( utf8buf_expect, utf8buf_commit ) )\n\t\t\tprintf( \"%s\", utf8buf_commit );\n\t\telse {\n\t\t\tprintf( \"\\033[44;37m%s\\033[m\", utf8buf_commit );\n\t\t\tfailed_word_count++;\n\t\t}\n\t}\n\tmemset( commit_string_buf, 0, MAXLEN );\n\tprintf( \"\\n\\n\" );\n}",
        "begin_line": 54,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "test.simulate.fake_getchar#41",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.fake_getchar()",
        "snippet": "int fake_getchar()\n{\n\tstatic int remainder = 0;\n\tstatic int idx = 0;\n\tchar *pos;\n\n\tif ( feof( fp ) )\n\t\treturn EOF;\n\n\tif ( remainder == 0 ) {\nstart:\n\t\tif ( fgets( linebuf, MAXLEN, fp ) == NULL )\n\t\t\treturn EOF;\n\t\tif ( linebuf[ 0 ] == '#' || linebuf[ 0 ] == ' ' )\n\t\t\tgoto start;\n\n\t\tpos = strstr( linebuf, \"<E>\" );\n\t\tif ( ! pos )\n\t\t\treturn EOF;\n\t\t*(pos + 3) = '\\0';\n\t\tremainder = pos - linebuf + 3;\n\t\tidx = 0;\n\n\t\tpos += 4;\n\t\twhile ( *pos == '\\t' || *pos == ' ' )\n\t\t\tpos++;\n\t\tstrcpy( expect_string_buf, pos );\n\t}\n\tremainder--;\n\treturn linebuf[ idx++ ];\n}",
        "begin_line": 41,
        "end_line": 71,
        "is_bug": false
    },
    {
        "name": "test.simulate.fini_sim#32",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.fini_sim()",
        "snippet": "int fini_sim()\n{\n\tif ( fp )\n\t\tfclose( fp );\n\tfflush( stdout );\n\treturn 0;\n}",
        "begin_line": 32,
        "end_line": 38,
        "is_bug": false
    },
    {
        "name": "test.simulate.get_char#31",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.get_char( void *param UNUSED )",
        "snippet": "static int get_char( void *param UNUSED )\n{\n\tint ch = getchar();\n\tif ( ch == EOF )\n\t\treturn END;\n\treturn ch;\n}",
        "begin_line": 31,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "test.simulate.init_sim#23",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.init_sim()",
        "snippet": "int init_sim()\n{\n\tif ( 0 == access( FN_MATERIALS \"-random\", R_OK ))\n\t\tfp = fopen( FN_MATERIALS \"-random\", \"r\" );\n\telse\n\t\tfp = fopen( FN_MATERIALS, \"r\" );\n\treturn (fp != NULL);\n}",
        "begin_line": 23,
        "end_line": 30,
        "is_bug": false
    },
    {
        "name": "test.simulate.main#73",
        "src_path": "test/simulate.c",
        "class_name": "test.simulate",
        "signature": "test.simulate.main()",
        "snippet": "int main()\n{\n\tif ( ! init_sim() )\n\t\treturn 1;\n\n\tchewing_test_Main();\n\n\t{\n\t\tprintf(\n\"_________________________________________________________________________\\n\"\n\t\t        \"[ Report ]\\n\");\n\t\tprintf( \"Checks: %d words,  Failures: %d words\\n\",\n\t\t        tested_word_count, failed_word_count );\n\t\tprintf( \"Ratio: %.2f%%\\n\",\n\t\t        (float) (tested_word_count - failed_word_count ) /\n\t\t\t        tested_word_count * 100 );\n\t}\n\n\tfini_sim();\n\treturn 0;\n}",
        "begin_line": 73,
        "end_line": 93,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.main#980",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_select_candidate();\n\ttest_Esc();\n\ttest_Del();\n\ttest_Backspace();\n\ttest_Up();\n\ttest_Down();\n\ttest_Tab();\n\ttest_DblTab();\n\ttest_Capslock();\n\ttest_Home();\n\ttest_End();\n\ttest_PageUp();\n\ttest_PageDown();\n\ttest_ShiftSpace();\n\ttest_Numlock();\n\ttest_Space();\n\n\ttest_get_phoneSeq();\n\ttest_zuin_buffer();\n\n\ttest_longest_phrase();\n\n\treturn exit_status();\n}",
        "begin_line": 980,
        "end_line": 1008,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace#519",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace()",
        "snippet": "void test_Backspace()\n{\n\ttest_Backspace_not_entering_chewing();\n\ttest_Backspace_in_select();\n\ttest_Backspace_remove_bopomofo();\n\ttest_Backspace_word();\n}",
        "begin_line": 519,
        "end_line": 525,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_in_select#478",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_in_select()",
        "snippet": "void test_Backspace_in_select()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"`<B>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_ABSORB ); /* XXX: shall be ignore? */\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 478,
        "end_line": 489,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_not_entering_chewing#465",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_not_entering_chewing()",
        "snippet": "void test_Backspace_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"<B>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 465,
        "end_line": 476,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_remove_bopomofo#491",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_remove_bopomofo()",
        "snippet": "void test_Backspace_remove_bopomofo()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"hk<B>\" );\n\tok_zuin_buffer( ctx, \"\\xE3\\x84\\x98\" /* \u3118 */ );\n\n\tchewing_delete( ctx );\n}\n\n",
        "begin_line": 491,
        "end_line": 502,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Backspace_word#504",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Backspace_word()",
        "snippet": "void test_Backspace_word()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4u g4<L><B><E>\" );\n\tok_commit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 504,
        "end_line": 517,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Capslock#674",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Capslock()",
        "snippet": "void test_Capslock()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\ttype_keystroke_by_string( ctx, \"<CB>\" );\n\tok( chewing_get_ChiEngMode( ctx ) == SYMBOL_MODE,\n\t\t\"mode shall change to SYMBOL_MODE\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 674,
        "end_line": 687,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_DblTab#669",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_DblTab()",
        "snippet": "void test_DblTab()\n{\n\t/* FIXME: Implement this. */\n}",
        "begin_line": 669,
        "end_line": 672,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del#458",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del()",
        "snippet": "void test_Del()\n{\n\ttest_Del_not_entering_chewing();\n\ttest_Del_in_select();\n\ttest_Del_word();\n}",
        "begin_line": 458,
        "end_line": 463,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_in_select#430",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_in_select()",
        "snippet": "void test_Del_in_select()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"`<DC>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_ABSORB ); /* XXX: shall be ignore? */\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 430,
        "end_line": 441,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_not_entering_chewing#417",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_not_entering_chewing()",
        "snippet": "void test_Del_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"<DC>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 417,
        "end_line": 428,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Del_word#443",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Del_word()",
        "snippet": "void test_Del_word()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4u g4<L><L><DC><E>\" );\n\tok_commit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 443,
        "end_line": 456,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down#559",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down()",
        "snippet": "void test_Down()\n{\n\ttest_Down_not_entering_chewing();\n}",
        "begin_line": 559,
        "end_line": 562,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Down_not_entering_chewing#546",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Down_not_entering_chewing()",
        "snippet": "void test_Down_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"<D>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 546,
        "end_line": 557,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_End#710",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_End()",
        "snippet": "void test_End()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L><L>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor `%d' shall be 0\", cursor );\n\n\ttype_keystroke_by_string( ctx, \"<EN>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor `%d' shall be 2\", cursor );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 710,
        "end_line": 729,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc#409",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc()",
        "snippet": "void test_Esc()\n{\n\ttest_Esc_not_entering_chewing();\n\ttest_Esc_in_select();\n\ttest_Esc_entering_zuin();\n\t/* XXX: Test escCleanAllBuf here */\n}",
        "begin_line": 409,
        "end_line": 415,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_entering_zuin#396",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_entering_zuin()",
        "snippet": "void test_Esc_entering_zuin()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"hk<EE>\" );\n\tok_zuin_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 396,
        "end_line": 407,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_in_select#383",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_in_select()",
        "snippet": "void test_Esc_in_select()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"`<EE>\" );\n\tok_candidate( ctx, NULL, 0 );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 383,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Esc_not_entering_chewing#370",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Esc_not_entering_chewing()",
        "snippet": "void test_Esc_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"<EE>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 370,
        "end_line": 381,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Home#689",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Home()",
        "snippet": "void test_Home()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor `%d' shall be 2\", cursor );\n\n\ttype_keystroke_by_string( ctx, \"<H>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor `%d' shall be 0\", cursor );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 689,
        "end_line": 708,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock#843",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock()",
        "snippet": "void test_Numlock()\n{\n\ttest_Numlock_numeric_input();\n\ttest_Numlock_select_candidate();\n}",
        "begin_line": 843,
        "end_line": 847,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock_numeric_input#778",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock_numeric_input()",
        "snippet": "void test_Numlock_numeric_input()\n{\n\tconst TestData NUMLOCK_INPUT[] = {\n\t\t{ \"<N0>\", \"0\" },\n\t\t{ \"<N1>\", \"1\" },\n\t\t{ \"<N2>\", \"2\" },\n\t\t{ \"<N3>\", \"3\" },\n\t\t{ \"<N4>\", \"4\" },\n\t\t{ \"<N5>\", \"5\" },\n\t\t{ \"<N6>\", \"6\" },\n\t\t{ \"<N7>\", \"7\" },\n\t\t{ \"<N8>\", \"8\" },\n\t\t{ \"<N9>\", \"9\" },\n\t\t{ \"<N+>\", \"+\" },\n\t\t{ \"<N->\", \"-\" },\n\t\t{ \"<N*>\", \"*\" },\n\t\t{ \"<N/>\", \"/\" },\n\t\t{ \"<N.>\", \".\" },\n\t};\n\tsize_t i;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( NUMLOCK_INPUT ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, NUMLOCK_INPUT[i].token );\n\t\tok_commit_buffer( ctx, NUMLOCK_INPUT[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 778,
        "end_line": 811,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Numlock_select_candidate#813",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Numlock_select_candidate()",
        "snippet": "void test_Numlock_select_candidate()\n{\n\tconst TestData NUMLOCK_SELECT[] = {\n\t\t{ \"hk4<D><N1><E>\", \"\\xE5\\x86\\x8A\" /* \u518a */ },\n\t\t{ \"hk4<D><N2><E>\", \"\\xE7\\xAD\\x96\" /* \u7b56 */ },\n\t\t{ \"hk4<D><N3><E>\", \"\\xE6\\xB8\\xAC\" /* \u6e2c */ },\n\t\t{ \"hk4<D><N4><E>\", \"\\xE5\\x81\\xB4\" /* \u5074 */ },\n\t\t{ \"hk4<D><N5><E>\", \"\\xE5\\xBB\\x81\" /* \u5ec1 */ },\n\t\t{ \"hk4<D><N6><E>\", \"\\xE6\\x83\\xBB\" /* \u60fb */ },\n\t\t{ \"hk4<D><N7><E>\", \"\\xE7\\xAD\\xB4\" /* \u7b74 */ },\n\t\t{ \"hk4<D><N8><E>\", \"\\xE7\\x95\\x9F\" /* \u755f */ },\n\t\t{ \"hk4<D><N9><E>\", \"\\xE8\\x8C\\xA6\" /* \u8326 */ },\n\t\t{ \"hk4<D><N0><E>\", \"\\xE7\\xB2\\xA3\" /* \u7ca3 */ },\n\t};\n\tsize_t i;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( NUMLOCK_SELECT ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, NUMLOCK_SELECT[ i ].token );\n\t\tok_commit_buffer( ctx, NUMLOCK_SELECT[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}\n\nvoid test_Numlock(",
        "begin_line": 813,
        "end_line": 841,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageDown#752",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageDown()",
        "snippet": "void test_PageDown()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L><L>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor `%d' shall be 0\", cursor );\n\n\ttype_keystroke_by_string( ctx, \"<PD>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor `%d' shall be 2\", cursor );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 752,
        "end_line": 771,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_PageUp#731",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_PageUp()",
        "snippet": "void test_PageUp()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L><L>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor `%d' shall be 0\", cursor );\n\n\ttype_keystroke_by_string( ctx, \"<PU>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor `%d' shall be 2\", cursor );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 731,
        "end_line": 750,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_ShiftSpace#773",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_ShiftSpace()",
        "snippet": "void test_ShiftSpace()\n{\n\t/* FIXME: Implement this. */\n}",
        "begin_line": 773,
        "end_line": 776,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Space#883",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Space()",
        "snippet": "void test_Space()\n{\n\ttest_Space_selection();\n}",
        "begin_line": 883,
        "end_line": 886,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Space_selection#849",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Space_selection()",
        "snippet": "void test_Space_selection()\n{\n\tChewingContext *ctx;\n\tchar *buf;\n\tint len;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<H>\" /* \u6e2c\u8a66 */ );\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen(buf);\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d'\", buf, len, 2 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen(buf);\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d'\", buf, len, 1 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 849,
        "end_line": 881,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab#662",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab()",
        "snippet": "void test_Tab()\n{\n\ttest_Tab_insert_breakpoint_between_word();\n\ttest_Tab_connect_word();\n\ttest_Tab_at_the_end();\n}",
        "begin_line": 662,
        "end_line": 667,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_at_the_end#642",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_at_the_end()",
        "snippet": "void test_Tab_at_the_end()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\ttype_keystroke_by_string( ctx, \"hk4g4u6vu84\" );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE4\\xB8\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u4e00\u4e0b */ );\n\n\ttype_keystroke_by_string( ctx, \"<T>\" );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE5\\x84\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u5100\u4e0b */ );\n\n\ttype_keystroke_by_string( ctx, \"<T>\" );\n\tok_preedit_buffer( ctx, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE4\\xB8\\x80\\xE4\\xB8\\x8B\" /* \u6e2c\u8a66\u4e00\u4e0b */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_Tab()\n{\n\ttes",
        "begin_line": 642,
        "end_line": 660,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_connect_word#603",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_connect_word()",
        "snippet": "void test_Tab_connect_word()\n{\n\tChewingContext *ctx;\n\tIntervalType it;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"u -4<L>\" );\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 1, \"interval (%d, %d) shall be (0, 1)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 1 && it.to == 2, \"interval (%d, %d) shall be (1, 2)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 0, \"shall not have next interval\" );\n\n\t/* connect \u4e00 and \u4e8c */\n\ttype_keystroke_by_string( ctx, \"<T>\" );\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 2, \"interval (%d, %d) shall be (0, 2)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 0, \"shall not have next interval\" );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 603,
        "end_line": 640,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Tab_insert_breakpoint_between_word#564",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Tab_insert_breakpoint_between_word()",
        "snippet": "void test_Tab_insert_breakpoint_between_word()\n{\n\tChewingContext *ctx;\n\tIntervalType it;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L>\" );\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 2, \"interval (%d, %d) shall be (0, 2)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 0, \"shall not have next interval\" );\n\n\t/* inserts a breakpoint between \u6e2c and \u8a66 */\n\ttype_keystroke_by_string( ctx, \"<T>\" );\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 1, \"interval (%d, %d) shall be (0, 1)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 1 && it.to == 2, \"interval (%d, %d) shall be (1, 2)\",\n\t\tit.from, it.to );\n\n\tok( chewing_interval_hasNext( ctx ) == 0, \"shall not have next interval\" );\n\n\tchewing_delete( ctx );\n}\n\nvo",
        "begin_line": 564,
        "end_line": 601,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up#540",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up()",
        "snippet": "void test_Up()\n{\n\ttest_Up_not_entering_chewing();\n\t/* XXX: What is spec of Up? */\n}",
        "begin_line": 540,
        "end_line": 544,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_Up_not_entering_chewing#527",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_Up_not_entering_chewing()",
        "snippet": "void test_Up_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"<U>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 527,
        "end_line": 538,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_get_phoneSeq#888",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_get_phoneSeq()",
        "snippet": "void test_get_phoneSeq()\n{\n\tstatic const struct {\n\t\tchar *token;\n\t\tunsigned short phone[5];\n\t} DATA[] = {\n\t\t{ \"hk4g4\", { 10268, 8708, 0 } },\n\t\t{ \"hk4g4`31hk4g4\", { 10268, 8708, 10268, 8708, 0 } },\n\t\t{ \"`31`31\", { 0 } },\n\t};\n\tChewingContext *ctx;\n\tsize_t i;\n\tint expected_len;\n\tint len;\n\tunsigned short *phone;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( DATA ); ++i ) {\n\t\tchewing_Reset( ctx );\n\t\ttype_keystroke_by_string( ctx, DATA[i].token );\n\n\t\texpected_len = 0;\n\t\twhile ( DATA[i].phone[expected_len] != 0 )\n\t\t\t++expected_len;\n\t\tlen = chewing_get_phoneSeqLen( ctx );\n\t\tok( len == expected_len, \"phoneSeqLen `%d' shall be `%d'\", len, expected_len );\n\n\t\tphone = chewing_get_phoneSeq( ctx );\n\t\tok ( memcmp( phone, DATA[i].phone, sizeof( phone[0] ) * expected_len ) == 0, \"phoneSeq shall be expected value\" );\n\t\tchewing_free( phone );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 888,
        "end_line": 925,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_longest_phrase#956",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_longest_phrase()",
        "snippet": "void test_longest_phrase()\n{\n\tChewingContext *ctx;\n\tIntervalType it;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\ttype_keystroke_by_string( ctx, \"rup ji up6ji 1j4bj6y4ru32k7e.3ji \"\n\t\t/* \u3110\u3127\u3123 \u3128\u311b \u3127\u3123\u02ca \u3128\u311b \u3105\u3128\u02cb \u3116\u3128\u02ca \u3117\u02cb \u3110\u3127\u02c7 \u3109\u311c\u02d9 \u310d\u3121\u02c7 \u3128\u311b */ );\n\tok_preedit_buffer( ctx, \"\\xE9\\x87\\x91\\xE7\\xAA\\xA9\\xE9\\x8A\\x80\\xE7\\xAA\\xA9\\xE4\\xB8\\x8D\\xE5\\xA6\\x82\\xE8\\x87\\xAA\\xE5\\xB7\\xB1\\xE7\\x9A\\x84\\xE7\\x8B\\x97\\xE7\\xAA\\xA9\"\n\t\t/* \u91d1\u7aa9\u9280\u7aa9\u4e0d\u5982\u81ea\u5df1\u7684\u72d7\u7aa9 */ );\n\n\tchewing_interval_Enumerate( ctx );\n\n\tok( chewing_interval_hasNext( ctx ) == 1, \"shall have next interval\" );\n\tchewing_interval_Get( ctx, &it );\n\tok( it.from == 0 && it.to == 11, \"interval (%d, %d) shall be (0, 11)\",\n\t\tit.from, it.to );\n\n\tchewing_delete( ctx );\n}\n\nint main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"",
        "begin_line": 956,
        "end_line": 978,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate#359",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate()",
        "snippet": "void test_select_candidate() {\n\ttest_select_candidate_no_rearward();\n\ttest_select_candidate_rearward();\n\ttest_select_candidate_no_rearward_with_symbol();\n\ttest_select_candidate_rearward_with_symbol();\n\ttest_select_candidate_no_rearward_start_with_symbol();\n\ttest_select_candidate_rearward_start_with_symbol();\n\ttest_select_candidate_4_bytes_utf8();\n\n}",
        "begin_line": 359,
        "end_line": 368,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_4_bytes_utf8#330",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_4_bytes_utf8()",
        "snippet": "void test_select_candidate_4_bytes_utf8()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"2k62k6\" ); /* \u3109\u311c\u02ca \u3109\u311c\u02ca */\n\tok_preedit_buffer( ctx, \"\\xE5\\xBE\\x97\\xE5\\xBE\\x97\" /* \u5f97\u5f97 */ );\n\n\ttype_keystroke_by_string( ctx, \"<H>\" );\n\n\ttype_keystroke_by_string( ctx, \"<D>8\" );\n\tok_preedit_buffer( ctx, \"\\xF0\\xA2\\x94\\xA8\\xE5\\xBE\\x97\" /* \ud849\udd28\u5f97 */ );\n\n\ttype_keystroke_by_string( ctx, \"<D>8\" );\n\n\tok_preedit_buffer( ctx, \"\\xF0\\xA2\\x94\\xA8\\xF0\\xA2\\x94\\xA8\" /* \ud849\udd28\ud849\udd28 */ );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_select_candid",
        "begin_line": 330,
        "end_line": 357,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward#24",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward()",
        "snippet": "void test_select_candidate_no_rearward()\n{\n\t/*\n\t * The following phrases are in dict\n\t * \u4e00\u4e0a\u4f86\n\t * \u4e0a\u4f86\n\t * \u79fb\u4e0a\u4f86\n\t * \u79fb\u4e0a\n\t */\n\n\tstatic const char *CAND_1[] = {\n\t\t\"\\xE4\\xB8\\x80\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e00\u4e0a\u4f86 */,\n\t\t\"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u79fb\u4e0a\u4f86 */,\n\t};\n\n\tstatic const char *CAND_2[] = {\n\t\t\"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\" /* \u79fb\u4e0a */,\n\t};\n\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, \"u6g;4x96<L><L><L>\" ); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\n\ttype_keystroke_by_string( ctx, \"<D>\" ); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_candidate( ctx, CAND_1, ARRAY_SIZE( CAND_1 ) );\n\n\ttype_keystroke_by_string( ctx, \"<D>\" ); /* \u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_candidate( ctx, CAND_2, ARRAY_SIZE( CAND_2 ) );\n\n\ttype_keystroke_by_string( ctx, \"<D><D>2<E>\" ); /* select \u79fb\u4e0a\u4f86 */\n\tok_commit_buffer( ctx, CAND_1[1] );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_select_candidate_rearward()\n{\n\t/*\n\t * The following phrases are in",
        "begin_line": 24,
        "end_line": 65,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward_start_with_symbol#238",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward_start_with_symbol()",
        "snippet": "void test_select_candidate_no_rearward_start_with_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tchar *buf;\n\tint len;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\n\ttype_keystroke_by_string( ctx, \"`31hk4g4\" /* \uff0c\u6e2c\u8a66 */);\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 1 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvoid",
        "begin_line": 238,
        "end_line": 281,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_no_rearward_with_symbol#111",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_no_rearward_with_symbol()",
        "snippet": "void test_select_candidate_no_rearward_with_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tchar *buf;\n\tint len;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\n\ttype_keystroke_by_string( ctx, \"hk4g4`31u6vu84\" /* \u6e2c\u8a66\uff0c\u4e00\u4e0b */);\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 0 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 1 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 3 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 3 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 4 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 4 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvoid tes",
        "begin_line": 111,
        "end_line": 172,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward#67",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward()",
        "snippet": "void test_select_candidate_rearward()\n{\n\t/*\n\t * The following phrases are in dict\n\t * \u4e00\u4e0a\u4f86\n\t * \u4e0a\u4f86\n\t * \u79fb\u4e0a\u4f86\n\t * \u79fb\u4e0a\n\t */\n\n\tstatic const char *CAND_1[] = {\n\t\t\"\\xE4\\xB8\\x80\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e00\u4e0a\u4f86 */,\n\t\t\"\\xE7\\xA7\\xBB\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u79fb\u4e0a\u4f86 */,\n\t};\n\n\tstatic const char *CAND_2[] = {\n\t\t\"\\xE4\\xB8\\x8A\\xE4\\xBE\\x86\" /* \u4e0a\u4f86 */,\n\t};\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"u6g;4x96\" ); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_preedit_buffer( ctx, CAND_1[0] );\n\n\ttype_keystroke_by_string( ctx, \"<D>\" ); /* \u3127\u02ca\u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_candidate( ctx, CAND_1, ARRAY_SIZE( CAND_1 ) );\n\n\ttype_keystroke_by_string( ctx, \"<D>\" ); /* \u3115\u3124\u02cb\u310c\u311e\u02ca */\n\tok_candidate( ctx, CAND_2, ARRAY_SIZE( CAND_2 ) );\n\n\ttype_keystroke_by_string( ctx, \"<D><D>2<E>\" ); /* select \u79fb\u4e0a\u4f86 */\n\tok_commit_buffer( ctx, CAND_1[1] );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_select_candidate_no_rearward_with_symbol()\n{\n\tChewingContext *ctx;",
        "begin_line": 67,
        "end_line": 109,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward_start_with_symbol#283",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward_start_with_symbol()",
        "snippet": "void test_select_candidate_rearward_start_with_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tchar *buf;\n\tint len;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"`31hk4g4\" /* \uff0c\u6e2c\u8a66 */);\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 1 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 2 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\n\nvoi",
        "begin_line": 283,
        "end_line": 327,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_select_candidate_rearward_with_symbol#174",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_select_candidate_rearward_with_symbol()",
        "snippet": "void test_select_candidate_rearward_with_symbol()\n{\n\tChewingContext *ctx;\n\tint ret;\n\tchar *buf;\n\tint len;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4`31u6vu84\" /* \u6e2c\u8a66\uff0c\u4e00\u4e0b */);\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 0 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 0 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 1 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 1 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 2 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 2 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 3 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 1, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 1, 3 );\n\tchewing_free( buf );\n\n\ttype_keystroke_by_string( ctx, \"<EE><H><R><R><R><R><D>\" );\n\tret = chewing_cand_TotalChoice( ctx );\n\tok( ret > 0, \"chewing_cand_TotalChoice() returns `%d' shall greater than 0 at pos `%d'\", ret, 4 );\n\tchewing_cand_Enumerate( ctx );\n\tbuf = chewing_cand_String( ctx );\n\tlen = ueStrLen( buf );\n\tok( len == 2, \"candidate `%s' length `%d' shall be `%d' at pos `%d'\", buf, len, 2, 4 );\n\tchewing_free( buf );\n\n\tchewing_delete( ctx );\n}\n\nvoid tes",
        "begin_line": 174,
        "end_line": 236,
        "is_bug": false
    },
    {
        "name": "test.test-bopomofo.test_zuin_buffer#927",
        "src_path": "test/test-bopomofo.c",
        "class_name": "test.test-bopomofo",
        "signature": "test.test-bopomofo.test_zuin_buffer()",
        "snippet": "void test_zuin_buffer()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\ttype_keystroke_by_string( ctx, \"1ul\" );\n\tok_zuin_buffer( ctx, \"\\xE3\\x84\\x85\\xE3\\x84\\xA7\\xE3\\x84\\xA0\" /* \u3105\u3127\u3120 */ );\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\tok_zuin_buffer( ctx, \"\" );\n\n\ttype_keystroke_by_string( ctx, \"ul\" );\n\tok_zuin_buffer( ctx, \"\\xE3\\x84\\xA7\\xE3\\x84\\xA0\" /* \u3127\u3120 */ );\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\tok_zuin_buffer( ctx, \"\" );\n\n\ttype_keystroke_by_string( ctx, \"3\");\n\tok_zuin_buffer( ctx, \"\\xCB\\x87\" /* \u02c7 */);\n\n\ttype_keystroke_by_string( ctx, \" \" );\n\tok_zuin_buffer( ctx, \"\" );\n\n\tchewing_delete( ctx );\n}\n\nvoid test",
        "begin_line": 927,
        "end_line": 954,
        "is_bug": false
    },
    {
        "name": "test.test-config.main#488",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_default_value();\n\n\ttest_set_candPerPage();\n\ttest_set_maxChiSymbolLen();\n\ttest_maxChiSymbolLen();\n\ttest_set_selKey();\n\ttest_set_addPhraseDirection();\n\ttest_set_spaceAsSelection();\n\ttest_set_escCleanAllBuf();\n\ttest_set_autoShiftCur();\n\ttest_set_easySymbolInput();\n\ttest_set_phraseChoiceRearward();\n\ttest_set_ChiEngMode();\n\ttest_set_ShapeMode();\n\n\ttest_deprecated();\n\n\treturn exit_status();\n}",
        "begin_line": 488,
        "end_line": 511,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_default_value#35",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_default_value()",
        "snippet": "void test_default_value()\n{\n\tint *select_key;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tselect_key = chewing_get_selKey( ctx );\n\tok( select_key, \"chewing_get_selKey shall not return NULL\" );\n\tok( !memcmp( select_key, DEFAULT_SELECT_KEY,\n\t\tsizeof( DEFAULT_SELECT_KEY )),\n\t\t\"default select key shall be default value\" );\n\tchewing_free( select_key );\n\n\tok( chewing_get_candPerPage( ctx ) == DEFAULT_CAND_PER_PAGE,\n\t\t\"default candPerPage shall be %d\", DEFAULT_CAND_PER_PAGE );\n\n\tok( chewing_get_maxChiSymbolLen( ctx ) == MAX_CHI_SYMBOL_LEN,\n\t\t\"default maxChiSymbolLen shall be %d\", MAX_CHI_SYMBOL_LEN );\n\n\tok( chewing_get_addPhraseDirection( ctx ) == 0,\n\t\t\"default addPhraseDirection shall be 0\" );\n\n\tok( chewing_get_spaceAsSelection( ctx ) == 0,\n\t\t\"default spaceAsSelection shall be 0\" );\n\n\tok( chewing_get_escCleanAllBuf( ctx ) == 0,\n\t\t\"default escCleanAllBuf shall be 0\" );\n\n\tok( chewing_get_hsuSelKeyType( ctx ) == 0,\n\t\t\"default hsuSelKeyType shall be 0\" );\n\n\tok( chewing_get_autoShiftCur( ctx ) == 0,\n\t\t\"default autoShiftCur shall be 0\" );\n\n\tok( chewing_get_easySymbolInput( ctx ) == 0,\n\t\t\"default easySymbolInput shall be 0\" );\n\n\tok( chewing_get_phraseChoiceRearward( ctx ) == 0,\n\t\t\"default phraseChoiceRearward shall be 0\" );\n\n\tok( chewing_get_ChiEngMode( ctx ) == CHINESE_MODE,\n\t\t\"default ChiEngMode shall be CHINESE_MODE\" );\n\n\tok( chewing_get_ShapeMode( ctx ) == HALFSHAPE_MODE,\n\t\t\"default ShapeMode shall be HALFSHAPE_MODE\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 35,
        "end_line": 85,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_deprecated#468",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_deprecated()",
        "snippet": "void test_deprecated()\n{\n\tChewingContext *ctx;\n\tint type;\n\tChewingConfigData configure;\n\tmemset( &configure, 0, sizeof( ChewingConfigData ) );\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_hsuSelKeyType( ctx, HSU_SELKEY_TYPE1 );\n\ttype = chewing_get_hsuSelKeyType( ctx );\n\tok( type == HSU_SELKEY_TYPE1, \"`%d' shall be `%d'\", type, HSU_SELKEY_TYPE1 );\n\n\tchewing_Configure( ctx, &configure );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 468,
        "end_line": 486,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_maxChiSymbolLen#166",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_maxChiSymbolLen()",
        "snippet": "void test_maxChiSymbolLen()\n{\n\tChewingContext *ctx;\n\tint i;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, MAX_CHI_SYMBOL_LEN );\n\n\tfor ( i = 0; i < MAX_CHI_SYMBOL_LEN; ++i ) {\n\t\ttype_keystroke_by_string( ctx, \"hk4\" );\n\t}\n\n\t// Use easy symbol 'Orz' as last input for worst case scenario.\n\tchewing_set_easySymbolInput( ctx, 1 );\n\ttype_keystroke_by_string( ctx, \"L\" );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 166,
        "end_line": 186,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_ChiEngMode#396",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_ChiEngMode()",
        "snippet": "void test_set_ChiEngMode()\n{\n\tconst int VALUE[] = {\n\t\tCHINESE_MODE,\n\t\tSYMBOL_MODE,\n\t};\n\n\tconst int INVALID_VALUE[] = {\n\t\t-1,\n\t\t2,\n\t};\n\n\tChewingContext *ctx;\n\tsize_t i;\n\tsize_t j;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( i = 0; i < ARRAY_SIZE( VALUE ); ++i ) {\n\t\tchewing_set_ChiEngMode( ctx, VALUE[i] );\n\t\tok( chewing_get_ChiEngMode( ctx ) == VALUE[i],\n\t\t\t\"ChiEngMode shall be `%d'\", VALUE[i] );\n\n\t\tfor ( j = 0; j < ARRAY_SIZE( INVALID_VALUE ); ++j ) {\n\t\t\t// mode shall not change when set mode has invalid value.\n\t\t\tchewing_set_ChiEngMode( ctx, INVALID_VALUE[j] );\n\t\t\tok( chewing_get_ChiEngMode( ctx ) == VALUE[i],\n\t\t\t\t\"ChiEngMode shall be `%d'\", VALUE[i] );\n\t\t}\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 396,
        "end_line": 430,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_ShapeMode#432",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_ShapeMode()",
        "snippet": "void test_set_ShapeMode()\n{\n\tconst int VALUE[] = {\n\t\tHALFSHAPE_MODE,\n\t\tFULLSHAPE_MODE,\n\t};\n\n\tconst int INVALID_VALUE[] = {\n\t\t-1,\n\t\t2,\n\t};\n\n\tChewingContext *ctx;\n\tsize_t i;\n\tsize_t j;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( i = 0; i < ARRAY_SIZE( VALUE ); ++i ) {\n\t\tchewing_set_ShapeMode( ctx, VALUE[i] );\n\t\tok( chewing_get_ShapeMode( ctx ) == VALUE[i],\n\t\t\t\"ShapeMode shall be `%d'\", VALUE[i] );\n\n\t\tfor ( j = 0; j < ARRAY_SIZE( INVALID_VALUE ); ++j ) {\n\t\t\t// mode shall not change when set mode has invalid value.\n\t\t\tchewing_set_ShapeMode( ctx, INVALID_VALUE[j] );\n\t\t\tok( chewing_get_ShapeMode( ctx ) == VALUE[i],\n\t\t\t\t\"ShapeMode shall be `%d'\", VALUE[i] );\n\t\t}\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 432,
        "end_line": 466,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_addPhraseDirection#216",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_addPhraseDirection()",
        "snippet": "void test_set_addPhraseDirection()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_addPhraseDirection( ctx, value );\n\t\tmode = chewing_get_addPhraseDirection( ctx );\n\t\tok( mode == value,\n\t\t\t\"addPhraseDirection `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_addPhraseDirection( ctx, -1 );\n\t\tmode = chewing_get_addPhraseDirection( ctx );\n\t\tok( mode == value,\n\t\t\t\"addPhraseDirection `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_addPhraseDirection( ctx, 2 );\n\t\tmode = chewing_get_addPhraseDirection( ctx );\n\t\tok( mode == value,\n\t\t\t\"addPhraseDirection `%d' shall be `%d'\", mode, value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 216,
        "end_line": 244,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_autoShiftCur#306",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_autoShiftCur()",
        "snippet": "void test_set_autoShiftCur()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_autoShiftCur( ctx, value );\n\t\tmode = chewing_get_autoShiftCur( ctx );\n\t\tok( mode = chewing_get_autoShiftCur( ctx ) == value,\n\t\t\t\"autoShiftCur shall be `%d'\", value );\n\n\t\tchewing_set_autoShiftCur( ctx, -1 );\n\t\tmode = chewing_get_autoShiftCur( ctx );\n\t\tok( mode = chewing_get_autoShiftCur( ctx ) == value,\n\t\t\t\"autoShiftCur shall be `%d'\", value );\n\n\t\tchewing_set_autoShiftCur( ctx, 2 );\n\t\tmode = chewing_get_autoShiftCur( ctx );\n\t\tok( mode = chewing_get_autoShiftCur( ctx ) == value,\n\t\t\t\"autoShiftCur shall be `%d'\", value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 306,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_candPerPage#87",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_candPerPage()",
        "snippet": "void test_set_candPerPage()\n{\n\tconst int VALUE[] = {\n\t\tMIN_CAND_PER_PAGE,\n\t\tMAX_CAND_PER_PAGE,\n\t};\n\n\tconst int INVALID_VALUE[] = {\n\t\tMIN_CAND_PER_PAGE - 1,\n\t\tMAX_CAND_PER_PAGE + 1,\n\t};\n\n\tChewingContext *ctx;\n\tsize_t i;\n\tsize_t j;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( i = 0; i < ARRAY_SIZE( VALUE ); ++i ) {\n\t\tchewing_set_candPerPage( ctx, VALUE[i] );\n\t\tok( chewing_get_candPerPage( ctx ) == VALUE[i],\n\t\t\t\"candPerPage shall be `%d'\", VALUE[i] );\n\n\t\tfor ( j = 0; j < ARRAY_SIZE( INVALID_VALUE ); ++j ) {\n\t\t\t// mode shall not change when set mode has invalid value.\n\t\t\tchewing_set_candPerPage( ctx, INVALID_VALUE[j] );\n\t\t\tok( chewing_get_candPerPage( ctx ) == VALUE[i],\n\t\t\t\t\"candPerPage shall be `%d'\", VALUE[i] );\n\t\t}\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 87,
        "end_line": 121,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_easySymbolInput#336",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_easySymbolInput()",
        "snippet": "void test_set_easySymbolInput()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_easySymbolInput( ctx, value );\n\t\tmode = chewing_get_easySymbolInput( ctx );\n\t\tok( mode == value,\n\t\t\t\"easySymbolInput `%d', shall be `%d'\", mode, value );\n\n\t\tchewing_set_easySymbolInput( ctx, -1 );\n\t\tmode = chewing_get_easySymbolInput( ctx );\n\t\tok( mode == value,\n\t\t\t\"easySymbolInput `%d', shall be `%d'\", mode, value );\n\n\t\tchewing_set_easySymbolInput( ctx, 2 );\n\t\tmode = chewing_get_easySymbolInput( ctx );\n\t\tok( mode == value,\n\t\t\t\"easySymbolInput `%d', shall be `%d'\", mode, value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 336,
        "end_line": 364,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_escCleanAllBuf#276",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_escCleanAllBuf()",
        "snippet": "void test_set_escCleanAllBuf()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_escCleanAllBuf( ctx, value );\n\t\tmode = chewing_get_escCleanAllBuf( ctx );\n\t\tok( mode == value,\n\t\t\t\"escCleanAllBuf shall be `%d'\", value );\n\n\t\tchewing_set_escCleanAllBuf( ctx, -1 );\n\t\tmode = chewing_get_escCleanAllBuf( ctx );\n\t\tok( mode == value,\n\t\t\t\"escCleanAllBuf shall be `%d'\", value );\n\n\t\tchewing_set_escCleanAllBuf( ctx, 2 );\n\t\tmode = chewing_get_escCleanAllBuf( ctx );\n\t\tok( mode == value,\n\t\t\t\"escCleanAllBuf shall be `%d'\", value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 276,
        "end_line": 304,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_maxChiSymbolLen#123",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_maxChiSymbolLen()",
        "snippet": "void test_set_maxChiSymbolLen()\n{\n\tChewingContext *ctx;\n\tint i;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tok( chewing_get_maxChiSymbolLen( ctx ) == 16,\n\t\t\"maxChiSymbolLen shall be 16\" );\n\n\tchewing_set_maxChiSymbolLen( ctx, MIN_CHI_SYMBOL_LEN - 1 );\n\tok( chewing_get_maxChiSymbolLen( ctx ) == 16,\n\t\t\"maxChiSymbolLen shall not change when set to %d\",\n\t\tMIN_CHI_SYMBOL_LEN - 1 );\n\n\tchewing_set_maxChiSymbolLen( ctx, MAX_CHI_SYMBOL_LEN + 1 );\n\tok( chewing_get_maxChiSymbolLen( ctx ) == 16,\n\t\t\"maxChiSymbolLen shall not change when set to %d\",\n\t\tMAX_CHI_SYMBOL_LEN + 1 );\n\n\n\t// Test auto commit\n\tchewing_set_maxChiSymbolLen( ctx, MAX_CHI_SYMBOL_LEN );\n\n\t// In boundary\n\tfor ( i = 0; i < MAX_CHI_SYMBOL_LEN; ++i )\n\t\ttype_keystroke_by_string( ctx, \"hk4\" );\n\tok( chewing_commit_Check( ctx ) == 0,\n\t\t\"auto commit shall not be triggered when entering %d symbols\",\n\t\tMAX_CHI_SYMBOL_LEN );\n\n\t// Out of boundary\n\ttype_keystroke_by_string( ctx, \"hk4\" );\n\tok( chewing_commit_Check( ctx ) == 1,\n\t\t\"auto commit shall be triggered when entering %d symbols\",\n\t\tMAX_CHI_SYMBOL_LEN + 1);\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 123,
        "end_line": 164,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_phraseChoiceRearward#366",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_phraseChoiceRearward()",
        "snippet": "void test_set_phraseChoiceRearward()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_phraseChoiceRearward( ctx, value );\n\t\tmode = chewing_get_phraseChoiceRearward( ctx );\n\t\tok(  mode == value,\n\t\t\t\"phraseChoiceRearward `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_phraseChoiceRearward( ctx, -1 );\n\t\tmode = chewing_get_phraseChoiceRearward( ctx );\n\t\tok(  mode == value,\n\t\t\t\"phraseChoiceRearward `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_phraseChoiceRearward( ctx, 2 );\n\t\tmode = chewing_get_phraseChoiceRearward( ctx );\n\t\tok(  mode == value,\n\t\t\t\"phraseChoiceRearward `%d' shall be `%d'\", mode, value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 366,
        "end_line": 394,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_selKey#188",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_selKey()",
        "snippet": "void test_set_selKey()\n{\n\tChewingContext *ctx;\n\tint *select_key;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\t// XXX: chewing_set_selKey shall accept const char *.\n\tchewing_set_selKey( ctx,\n\t\tALTERNATE_SELECT_KEY, ARRAY_SIZE( ALTERNATE_SELECT_KEY ));\n\tselect_key = chewing_get_selKey( ctx );\n\tok( select_key, \"chewing_get_selKey shall not return NULL\" );\n\tok( !memcmp( select_key, ALTERNATE_SELECT_KEY,\n\t\tsizeof( ALTERNATE_SELECT_KEY )),\n\t\t\"select key shall be ALTERNATE_SELECT_KEY\");\n\n\ttype_keystroke_by_string( ctx, DATA.token );\n\tok_preedit_buffer( ctx, DATA.expected );\n\n\tchewing_free( select_key );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 188,
        "end_line": 214,
        "is_bug": false
    },
    {
        "name": "test.test-config.test_set_spaceAsSelection#246",
        "src_path": "test/test-config.c",
        "class_name": "test.test-config",
        "signature": "test.test-config.test_set_spaceAsSelection()",
        "snippet": "void test_set_spaceAsSelection()\n{\n\tChewingContext *ctx;\n\tint value;\n\tint mode;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tfor ( value = 0; value < 2; ++value ) {\n\t\tchewing_set_spaceAsSelection( ctx, value );\n\t\tmode = chewing_get_spaceAsSelection( ctx );\n\t\tok( mode == value,\n\t\t\t\"spaceAsSelection `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_spaceAsSelection( ctx, -1 );\n\t\tmode = chewing_get_spaceAsSelection( ctx );\n\t\tok( mode == value,\n\t\t\t\"spaceAsSelection `%d' shall be `%d'\", mode, value );\n\n\t\tchewing_set_spaceAsSelection( ctx, 2 );\n\t\tmode = chewing_get_spaceAsSelection( ctx );\n\t\tok( mode == value,\n\t\t\t\"spaceAsSelection `%d' shall be `%d'\", mode, value );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 246,
        "end_line": 274,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.main#99",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_type_easy_symbol();\n\ttest_mode_change();\n\treturn exit_status();\n}",
        "begin_line": 99,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.test_mode_change#74",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.test_mode_change()",
        "snippet": "void test_mode_change()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\ttype_keystroke_by_string( ctx, CHINESE.token );\n\tok_commit_buffer( ctx, CHINESE.expected );\n\n\tchewing_set_easySymbolInput( ctx, 1 );\n\ttype_keystroke_by_string( ctx, EASY_SYMBOL[0].token );\n\ttype_keystroke_by_string( ctx, \"<E>\" );\n\tok_commit_buffer( ctx, EASY_SYMBOL[0].expected );\n\n\tchewing_set_easySymbolInput( ctx, 0 );\n\ttype_keystroke_by_string( ctx, CHINESE.token );\n\tok_commit_buffer( ctx, CHINESE.expected );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 74,
        "end_line": 97,
        "is_bug": false
    },
    {
        "name": "test.test-easy-symbol.test_type_easy_symbol#52",
        "src_path": "test/test-easy-symbol.c",
        "class_name": "test.test-easy-symbol",
        "signature": "test.test-easy-symbol.test_type_easy_symbol()",
        "snippet": "void test_type_easy_symbol()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_easySymbolInput( ctx, 1 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( EASY_SYMBOL ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, EASY_SYMBOL[i].token );\n\t\tok_preedit_buffer( ctx, EASY_SYMBOL[i].expected );\n\t\ttype_keystroke_by_string( ctx, \"<E>\" );\n\t\tok_commit_buffer( ctx, EASY_SYMBOL[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 52,
        "end_line": 72,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.main#152",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_set_fullshape();\n\ttest_fullshape_input();\n\n\treturn exit_status();\n}",
        "begin_line": 152,
        "end_line": 161,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.test_fullshape_input#98",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.test_fullshape_input()",
        "snippet": "void test_fullshape_input()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_ChiEngMode( ctx, SYMBOL_MODE );\n\tchewing_set_ShapeMode( ctx, FULLSHAPE_MODE );\n\n\tfor ( i = 0; i < ARRAY_SIZE( FULLSHAPE_DATA ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, FULLSHAPE_DATA[i].token );\n\t\t// fullshape symbol does not present in preedit buffer.\n\t\tok_preedit_buffer( ctx, \"\" );\n\t\tok_commit_buffer( ctx, FULLSHAPE_DATA[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 98,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "test.test-fullshape.test_set_fullshape#120",
        "src_path": "test/test-fullshape.c",
        "class_name": "test.test-fullshape",
        "signature": "test.test-fullshape.test_set_fullshape()",
        "snippet": "void test_set_fullshape()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tok( chewing_get_ShapeMode( ctx ) == HALFSHAPE_MODE,\n\t\t\"default is HALFSHAPE_MODE\" );\n\n\tchewing_set_ShapeMode( ctx, FULLSHAPE_MODE );\n\tok( chewing_get_ShapeMode( ctx ) == FULLSHAPE_MODE,\n\t\t\"mode shall change to FULLSHAPE_MODE\" );\n\n\t// XXX: What is the correct behavior when input parameter is wrong?\n//\tchewing_set_ShapeMode( ctx, -1 );\n//\tok( chewing_get_ShapeMode( ctx ) == FULLSHAPE_MODE,\n//\t\t\"mode shall not change when parameter is invalid\" );\n\n\tchewing_set_ShapeMode( ctx, HALFSHAPE_MODE );\n\tok( chewing_get_ShapeMode( ctx ) == HALFSHAPE_MODE,\n\t\t\"mode shall change to HALFSHAPE_MODE\" );\n\n\tchewing_set_ShapeMode( ctx, -1 );\n\tok( chewing_get_ShapeMode( ctx ) == HALFSHAPE_MODE,\n\t\t\"mode shall not change when parameter is invalid\" );\n\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 120,
        "end_line": 150,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.main#117",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.main ()",
        "snippet": "int main ()\n{\n\ttest_uint_and_phone();\n\ttest_uint_and_phone_error();\n\ttest_key_and_phone();\n\n\treturn exit_status();\n}",
        "begin_line": 117,
        "end_line": 124,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_key_and_phone#95",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_key_and_phone()",
        "snippet": "void test_key_and_phone()\n{\n\tchar rt[ MAX_UTF8_SIZE * ZUIN_SIZE + 1 ];\n\n\tprint_function_name();\n\n\tPhoneFromKey( rt, \"dj\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\" /* \u310e\u3128 */ ), \"dj\");\n\n\tPhoneFromKey( rt, \"dj6\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x8A\" /* \u310e\u3128\u02ca */ ), \"dj6\");\n\n\tPhoneFromKey( rt, \"dj3\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x87\" /* \u310e\u3128\u02c7 */ ), \"dj3\");\n\n\tPhoneFromKey( rt, \"dj4\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x8B\" /* \u310e\u3128\u02cb */ ), \"dj4\");\n\n\tPhoneFromKey( rt, \"dj7\", 0, 1 );\n\tok (!strcmp(rt, \"\\xE3\\x84\\x8E\\xE3\\x84\\xA8\\xCB\\x99\" /* \u310e\u3128\u02d9 */ ), \"dj7\");\n}\n\nint main ()\n{\n\ttest_ui",
        "begin_line": 95,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_uint_and_phone#20",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_uint_and_phone()",
        "snippet": "void test_uint_and_phone()\n{\n\tchar *u8phone;\n\tchar rt[ MAX_UTF8_SIZE * ZUIN_SIZE + 1 ];\n\tuint16_t phone;\n\tuint16_t expect;\n\n\tprint_function_name();\n\n\tu8phone = \"\\xE3\\x84\\x86\\xE3\\x84\\xA3\" /* \u3106\u3123 */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 1104;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tPhoneFromUint( rt, sizeof( rt ), expect );\n\tok (strcmp( rt, u8phone ) == 0, \"PhoneFromUint d%d' shall be `%s', got `%s'\",\n\t\texpect, u8phone, rt);\n\n\n\tu8phone = \"\\xE3\\x84\\x8A\\xE3\\x84\\xA7\\xE3\\x84\\xA2\" /* \u310a\u3127\u3122 */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 3272;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tPhoneFromUint( rt, sizeof( rt ), expect );\n\tok (strcmp( rt, u8phone ) == 0, \"PhoneFromUint d%d' shall be `%s', got `%s'\",\n\t\texpect, u8phone, rt);\n\n\n\tu8phone = \"\\xE3\\x84\\x92\\xE3\\x84\\xA7\\xE3\\x84\\x9A\\xCB\\x8B\" /* \u3112\u3127\u311a\u02cb */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 7308;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tPhoneFromUint( rt, sizeof( rt ), expect );\n\tok (strcmp( rt, u8phone ) == 0, \"PhoneFromUint `%d' shall be `%s', got `%s'\",\n\t\texpect, u8phone, rt);\n}\n\nvoid test_uint_",
        "begin_line": 20,
        "end_line": 60,
        "is_bug": false
    },
    {
        "name": "test.test-key2pho.test_uint_and_phone_error#62",
        "src_path": "test/test-key2pho.c",
        "class_name": "test.test-key2pho",
        "signature": "test.test-key2pho.test_uint_and_phone_error()",
        "snippet": "void test_uint_and_phone_error()\n{\n\tchar *u8phone;\n\tchar rt[ MAX_UTF8_SIZE * ZUIN_SIZE + 1 ];\n\tuint16_t phone;\n\tuint16_t expect;\n\n\tprint_function_name();\n\n\tu8phone = \"\\xE3\\x84\\x8A\\xE3\\x84\\xA7\\xE6\\xB8\\xAC\" /* \u310a\u3127\u6e2c */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 0;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tu8phone = \"\\xE3\\x84\\x8E\\xE3\\x84\\x8E\" /* \u310e\u310e */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 0;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tu8phone = \"\\xE3\\x84\\xA8\\xE3\\x84\\x8E\" /* \u3128\u310e */;\n\tphone = UintFromPhone(u8phone);\n\texpect = 0;\n\tok (phone == expect, \"UintFromPhone `%s' shall be `%d', got `%d'\",\n\t\tu8phone, expect, phone);\n\n\tPhoneFromUint( rt, sizeof( rt ), 0 );\n\tok (strcmp( rt, \"\" ) == 0, \"PhoneFromUint `%d' shall be `%s', got `%s'\",\n\t\t0, \"\", rt);\n\n}\n\nvoid test_ke",
        "begin_line": 62,
        "end_line": 93,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.main#130",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_set_keyboard_type();\n\ttest_KBStr2Num();\n\ttest_enumerate_keyboard_type();\n\n\treturn exit_status();\n}",
        "begin_line": 130,
        "end_line": 140,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_KBStr2Num#84",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_KBStr2Num()",
        "snippet": "void test_KBStr2Num()\n{\n\tint i;\n\tint ret;\n\n\tprint_function_name();\n\n\tfor ( i = 0; i < (int)ARRAY_SIZE( KEYBOARD_STRING ); ++i ) {\n\t\t// XXX: chewing_KBStr2Num shall accept const char *.\n\t\tret = chewing_KBStr2Num( KEYBOARD_STRING[i] );\n\t\tok( ret == i, \"%d shall be %d\", ret, i );\n\t}\n}",
        "begin_line": 84,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_enumerate_keyboard_type#98",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_enumerate_keyboard_type()",
        "snippet": "void test_enumerate_keyboard_type()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\tchar *keyboard_string;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tok( chewing_kbtype_Total( ctx ) == ARRAY_SIZE( KEYBOARD_STRING ),\n\t\t\"total keyboard_string type shall be %d\", ARRAY_SIZE( KEYBOARD_STRING ) );\n\n\tchewing_kbtype_Enumerate( ctx );\n\tfor ( i = 0; i < ARRAY_SIZE( KEYBOARD_STRING ); ++i ) {\n\t\tok( chewing_kbtype_hasNext( ctx ) == 1 ,\n\t\t\t\"shall have next keyboard_string type\" );\n\t\tkeyboard_string = chewing_kbtype_String( ctx );\n\t\tok( strcmp( keyboard_string, KEYBOARD_STRING[i] ) == 0,\n\t\t\t\"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[i] );\n\t\tchewing_free( keyboard_string );\n\t}\n\tok( chewing_kbtype_hasNext( ctx ) == 0 ,\n\t\t\"shall not have next keyboard_string type\" );\n\tkeyboard_string = chewing_kbtype_String( ctx );\n\tok( strcmp( keyboard_string, \"\" ) == 0,\n\t\t\"`%s' shall be `%s'\", keyboard_string, \"\" );\n\tchewing_free( keyboard_string );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 98,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "test.test-keyboard.test_set_keyboard_type#38",
        "src_path": "test/test-keyboard.c",
        "class_name": "test.test-keyboard",
        "signature": "test.test-keyboard.test_set_keyboard_type()",
        "snippet": "void test_set_keyboard_type()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\tchar *keyboard_string;\n\tint keyboard_type;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tkeyboard_string = chewing_get_KBString( ctx );\n\tok( strcmp( keyboard_string, KEYBOARD_STRING[KEYBOARD_DEFAULT_TYPE] ) == 0,\n\t\t\"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[KEYBOARD_DEFAULT_TYPE] );\n\tchewing_free( keyboard_string );\n\tkeyboard_type = chewing_get_KBType( ctx );\n\tok( keyboard_type == KEYBOARD_DEFAULT_TYPE ,\n\t\t\"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE );\n\n\tfor ( i = 0; i < ARRAY_SIZE( KEYBOARD_STRING ); ++i ) {\n\t\tok ( chewing_set_KBType( ctx, i ) == 0, \"return shall be 0\" );\n\n\t\tkeyboard_string = chewing_get_KBString( ctx );\n\t\tok( strcmp( keyboard_string, KEYBOARD_STRING[i] ) == 0,\n\t\t\t\"`%s' shall be `%s'\", keyboard_string, KEYBOARD_STRING[i] );\n\t\tchewing_free( keyboard_string );\n\t\tkeyboard_type = chewing_get_KBType( ctx );\n\t\tok( keyboard_type == (int)i ,\n\t\t\t\"`%d' shall be `%d'\", keyboard_type, (int)i );\n\t}\n\n\t// The invalid KBType will reset KBType to default value.\n\tok( chewing_set_KBType( ctx, -1 ) == -1, \"return shall be -1\" );\n\tkeyboard_type = chewing_get_KBType( ctx );\n\tok( keyboard_type == KEYBOARD_DEFAULT_TYPE ,\n\t\t\"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE );\n\n\tok( chewing_set_KBType( ctx, ARRAY_SIZE( KEYBOARD_STRING ) + 1 ),\n\t\t\"return shall be -1\" );\n\tkeyboard_type = chewing_get_KBType( ctx );\n\tok( keyboard_type == KEYBOARD_DEFAULT_TYPE ,\n\t\t\"`%d' shall be `%d'\", keyboard_type, KEYBOARD_DEFAULT_TYPE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 38,
        "end_line": 82,
        "is_bug": false
    },
    {
        "name": "test.test-logger.logger#24",
        "src_path": "test/test-logger.c",
        "class_name": "test.test-logger",
        "signature": "test.test-logger.logger( void *data UNUSED, int level UNUSED, const char *fmt, ... )",
        "snippet": "void logger( void *data UNUSED, int level UNUSED, const char *fmt, ... )\n{\n\tva_list ap;\n\tFILE *fd = (FILE *) data;\n\n\tva_start( ap, fmt );\n\tvfprintf( fd, fmt, ap );\n\tva_end( ap );\n}",
        "begin_line": 24,
        "end_line": 32,
        "is_bug": false
    },
    {
        "name": "test.test-logger.main#54",
        "src_path": "test/test-logger.c",
        "class_name": "test.test-logger",
        "signature": "test.test-logger.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_set_logger();\n\n\treturn exit_status();\n}",
        "begin_line": 54,
        "end_line": 62,
        "is_bug": false
    },
    {
        "name": "test.test-logger.test_set_logger#34",
        "src_path": "test/test-logger.c",
        "class_name": "test.test-logger",
        "signature": "test.test-logger.test_set_logger()",
        "snippet": "void test_set_logger()\n{\n\tChewingContext *ctx;\n\tFILE *fd;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tfd = fopen( LOG_PATH,  \"w\" );\n\n\tchewing_set_logger( ctx, logger, fd );\n\ttype_keystroke_by_string( ctx, \"hk4g4\" );\n\n\tchewing_set_logger( ctx, NULL, 0 );\n\ttype_keystroke_by_string( ctx, \"hk4g4\" );\n\n\tfclose( fd );\n\tchewing_delete( ctx );\n}",
        "begin_line": 34,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "test.test-mmap.main#47",
        "src_path": "test/test-mmap.c",
        "class_name": "test.test-mmap",
        "signature": "test.test-mmap.main ()",
        "snippet": "int main ()\n{\n\ttest_UnitFromPlatMmap();\n\treturn exit_status();\n}",
        "begin_line": 47,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "test.test-mmap.test_UnitFromPlatMmap#21",
        "src_path": "test/test-mmap.c",
        "class_name": "test.test-mmap",
        "signature": "test.test-mmap.test_UnitFromPlatMmap()",
        "snippet": "void test_UnitFromPlatMmap()\n{\n\tunsigned int idx;\n\tplat_mmap m_mmap;\n\tsize_t offset = 0;\n\tsize_t csize;\n\tchar *data_buf;\n\tchar hard_copy[] = \"ji3cp3vu3cj0 vup dj4up <E>\";\n\tint i;\n\n\tprint_function_name();\n\n\tidx = plat_mmap_create(&m_mmap, TESTDATA, FLAG_ATTRIBUTE_READ);\n\tok (idx == 28, \"plat_mmap_create\");\n\tif (idx > 0) {\n\t\tcsize = idx;\n\t\tdata_buf = (char *) plat_mmap_set_view(&m_mmap, &offset, &csize);\n\t\tfor (i = 0; i < 26; i++) {\n\t\t\tif (data_buf[i] != hard_copy[i])\n\t\t\t\tbreak;\n\t\t}\n\t\tok (i == 26, \"plat_mmap_set_view\");\n\t}\n\tplat_mmap_close( &m_mmap );\n}",
        "begin_line": 21,
        "end_line": 45,
        "is_bug": false
    },
    {
        "name": "test.test-path.main#86",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.main()",
        "snippet": "int main()\n{\n\ttest_plat_get_search_path();\n\ttest_plat_path_found();\n\ttest_plat_path_cannot_find();\n\treturn exit_status();\n}",
        "begin_line": 86,
        "end_line": 92,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_get_search_path#40",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_get_search_path()",
        "snippet": "void test_plat_get_search_path()\n{\n\tint ret;\n\tchar output[PATH_MAX];\n\n\tprint_function_name();\n\n\tputenv(\"CHEWING_PATH=\" CHEWING_DATA_PREFIX);\n\tret = get_search_path( output, sizeof(output) );\n\tok (ret == 0, \"get_search_path return 0\");\n\tok (!strcmp(output, CHEWING_DATA_PREFIX), \"get_search_path succes\");\n\t// TODO plat specific test\n}",
        "begin_line": 40,
        "end_line": 52,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_path_cannot_find#71",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_path_cannot_find()",
        "snippet": "void test_plat_path_cannot_find()\n{\n\tint ret;\n\tchar output[ PATH_MAX ];\n\n\tprint_function_name();\n\n\tret = find_path_by_files(\n\t\t\tCHEWING_DATA_PREFIX \"_no_such_path_1\" SEARCH_PATH_SEP\n\t\t\tCHEWING_DATA_PREFIX \"_no_such_path_2\",\n\t\t\tFILES, output, sizeof( output ) );\n\n\tok( ret != 0, \"find_path_by_files shall not return 0\" );\n}",
        "begin_line": 71,
        "end_line": 84,
        "is_bug": false
    },
    {
        "name": "test.test-path.test_plat_path_found#54",
        "src_path": "test/test-path.c",
        "class_name": "test.test-path",
        "signature": "test.test-path.test_plat_path_found()",
        "snippet": "void test_plat_path_found()\n{\n\tint ret;\n\tchar output[ PATH_MAX ];\n\n\tprint_function_name();\n\n\tret = find_path_by_files(\n\t\tCHEWING_DATA_PREFIX \"_no_such_path\" SEARCH_PATH_SEP\n\t\tCHEWING_DATA_PREFIX,\n\t\tFILES, output, sizeof( output ) );\n\n\tok( ret == 0, \"find_path_by_files shall return 0\" );\n\tok( strcmp( output, CHEWING_DATA_PREFIX ) == 0,\n\t\t\"output shall be \" CHEWING_DATA_PREFIX );\n}",
        "begin_line": 54,
        "end_line": 69,
        "is_bug": false
    },
    {
        "name": "test.test-regression.main#117",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_libchewing_data_issue_1();\n\ttest_libchewing_issue_30();\n\ttest_libchewing_googlecode_issue_472();\n\ttest_libchewing_googlecode_issue_473();\n\n\treturn exit_status();\n}",
        "begin_line": 117,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_data_issue_1#100",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_data_issue_1()",
        "snippet": "void test_libchewing_data_issue_1()\n{\n\tconst TestData DATA = { \"e03y.3\", \"\\xE8\\xB6\\x95\\xE8\\xB5\\xB0\" /* \u8d95\u8d70*/ };\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\ttype_keystroke_by_string( ctx, DATA.token );\n\tok_preedit_buffer( ctx, DATA.expected );\n\n\tchewing_delete( ctx );\n}\n\nin",
        "begin_line": 100,
        "end_line": 115,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_googlecode_issue_472#23",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_googlecode_issue_472()",
        "snippet": "void test_libchewing_googlecode_issue_472()\n{\n\t/* FIXME: Add const cause gcc warning */\n\tstatic char *INPUT[] = {\n\t\t\"<T>|&Wt<H>mrJY)G<C2>OqJ<H><H>Yl<R>p0<EE>QE[^<C1>k\",\n\t\t\"+F<C9>hQ$UIICMr!X8/9<C3>(N<T>yU2!-LUI<D>`CS<D>jShm9SF}<EN>[`QYu<C8>k\",\n\t\t\"hk4`2<D>jk\",\n\t\t\"hk4`j 0\",\n\t\t\"hk4<C0>j 0\",\n\t};\n\tsize_t i;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\n\tfor (i = 0; i < ARRAY_SIZE(INPUT); ++i) {\n\t\tchewing_Reset( ctx );\n\t\ttype_keystroke_by_string( ctx, INPUT[i] );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 23,
        "end_line": 48,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_googlecode_issue_473#50",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_googlecode_issue_473()",
        "snippet": "void test_libchewing_googlecode_issue_473()\n{\n\t/* FIXME: Add const cause gcc warning */\n\tstatic char *INPUT[] = {\n\t\t\"t<N->_ M1<N+>H[Ls3<L><N1>PL+Z]4<C1>&(^H*H<TT>Sc<N->P]!|<CB>-<C6>S<H><N1><C0>U<B>d}P!f<EN><N.><C7>V!U!w|4-=S<C1>b<N2>Q\",\n\t\t\"wv<C0><C5><N9>$FIF<D><N4>B *<C2>E4*<C2>q)Kf)<SS><TT>4=<N5>%<R>mN4<EN>H<N9><N.>8s{XTD<N6>jZV(y3G`9<C6>JTy<B>J<C1>SNc<E>hC<SL><N/><R><C6>@an<C3><N7>wzF<C3>P*<N*><B>l<C3><N6>W<N*> $<SR><N.><N1><E><E><N0><N6>Y\",\n\n\t};\n\tsize_t i;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\tchewing_set_candPerPage( ctx, 9 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\n\tfor (i = 0; i < ARRAY_SIZE(INPUT); ++i) {\n\t\tchewing_Reset( ctx );\n\t\ttype_keystroke_by_string( ctx, INPUT[i] );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 50,
        "end_line": 76,
        "is_bug": false
    },
    {
        "name": "test.test-regression.test_libchewing_issue_30#78",
        "src_path": "test/test-regression.c",
        "class_name": "test.test-regression",
        "signature": "test.test-regression.test_libchewing_issue_30()",
        "snippet": "void test_libchewing_issue_30()\n{\n\tChewingContext *ctx;\n\tint cursor;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_autoShiftCur( ctx, 1 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\tchewing_set_phraseChoiceRearward( ctx, 1 );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<H> 3 1\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor position `%d' shall be `2'\", cursor);\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 78,
        "end_line": 98,
        "is_bug": false
    },
    {
        "name": "test.test-reset.main#45",
        "src_path": "test/test-reset.c",
        "class_name": "test.test-reset",
        "signature": "test.test-reset.main ()",
        "snippet": "int main ()\n{\n\ttest_reset_shall_not_clean_static_data();\n\treturn exit_status();\n}",
        "begin_line": 45,
        "end_line": 49,
        "is_bug": false
    },
    {
        "name": "test.test-reset.test_reset_shall_not_clean_static_data#21",
        "src_path": "test/test-reset.c",
        "class_name": "test.test-reset",
        "signature": "test.test-reset.test_reset_shall_not_clean_static_data()",
        "snippet": "void test_reset_shall_not_clean_static_data()\n{\n\tconst TestData DATA = { \"hk4g4<E>\", \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */ };\n\tChewingContext *ctx;\n\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_KBType( ctx, chewing_KBStr2Num( \"KB_DEFAULT\" ) );\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tchewing_Reset( ctx );\n\n\ttype_keystroke_by_string( ctx, DATA.token );\n\tok_commit_buffer( ctx, DATA.expected );\n\n\tchewing_delete( ctx );\n}\n\nin",
        "begin_line": 21,
        "end_line": 43,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.is_bopomofo_collision_key#53",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.is_bopomofo_collision_key( const char *key )",
        "snippet": "int is_bopomofo_collision_key( const char *key )\n{\n\tstatic const char *COLLISION_KEY[] = {\n\t\t\"<<>\",\n\t\t\">\",\n\t\t\";\",\n\t\t\",\",\n\t\t\".\",\n\t};\n\tsize_t i;\n\n\tfor ( i = 0; i < ARRAY_SIZE( COLLISION_KEY ); ++i ) {\n\t\tif ( strcmp( key, COLLISION_KEY[i] ) == 0 ) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 53,
        "end_line": 70,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.is_fullshape_collision_key#120",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.is_fullshape_collision_key( const char *key )",
        "snippet": "int is_fullshape_collision_key( const char *key )\n{\n\tstatic const char *COLLISION_KEY[] = {\n\t\t\"\\\"\",\n\t\t\"'\",\n\t\t\"/\",\n\t\t\"<<>\",\n\t\t\">\",\n\t\t\"`\",\n\t\t\"[\",\n\t\t\"]\",\n\t\t\"{\",\n\t\t\"}\",\n\t\t\"+\",\n\t\t\"-\",\n\t};\n\tsize_t i;\n\n\tfor ( i = 0; i < ARRAY_SIZE( COLLISION_KEY ); ++i ) {\n\t\tif ( strcmp( key, COLLISION_KEY[i] ) == 0 ) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
        "begin_line": 120,
        "end_line": 144,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.main#173",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_in_chinese_mode();\n\ttest_in_easy_symbol_mode();\n\ttest_in_fullshape_mode();\n\n\treturn exit_status();\n}",
        "begin_line": 173,
        "end_line": 183,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_chinese_mode#72",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_chinese_mode()",
        "snippet": "void test_in_chinese_mode()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( SPECIAL_SYMBOL_TABLE ); ++i ) {\n\t\t// If bopomofo symbol is collided with special symbol, use\n\t\t// bopomofo symbol\n\t\tif ( is_bopomofo_collision_key( SPECIAL_SYMBOL_TABLE[i].token ) )\n\t\t\tcontinue;\n\n\t\ttype_keystroke_by_string( ctx, SPECIAL_SYMBOL_TABLE[i].token );\n\t\tok_preedit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t\ttype_keystroke_by_string( ctx, \"<E>\" );\n\t\tok_commit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 72,
        "end_line": 96,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_easy_symbol_mode#98",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_easy_symbol_mode()",
        "snippet": "void test_in_easy_symbol_mode()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_easySymbolInput( ctx, 1 );\n\n\tfor ( i = 0; i < ARRAY_SIZE( SPECIAL_SYMBOL_TABLE ); ++i ) {\n\t\ttype_keystroke_by_string( ctx, SPECIAL_SYMBOL_TABLE[i].token );\n\t\tok_preedit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t\ttype_keystroke_by_string( ctx, \"<E>\" );\n\t\tok_commit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 98,
        "end_line": 118,
        "is_bug": false
    },
    {
        "name": "test.test-special-symbol.test_in_fullshape_mode#146",
        "src_path": "test/test-special-symbol.c",
        "class_name": "test.test-special-symbol",
        "signature": "test.test-special-symbol.test_in_fullshape_mode()",
        "snippet": "void test_in_fullshape_mode()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_ChiEngMode( ctx, SYMBOL_MODE );\n\tchewing_set_ShapeMode( ctx, FULLSHAPE_MODE );\n\n\tfor ( i = 0; i < ARRAY_SIZE( SPECIAL_SYMBOL_TABLE ); ++i ) {\n\t\t// If fullshape symbol is collided with special symbol, use\n\t\t// fullshape symbol\n\t\tif ( is_fullshape_collision_key( SPECIAL_SYMBOL_TABLE[i].token ) )\n\t\t\tcontinue;\n\n\t\ttype_keystroke_by_string( ctx, SPECIAL_SYMBOL_TABLE[i].token );\n\t\tok_preedit_buffer( ctx, \"\" );\n\t\tok_commit_buffer( ctx, SPECIAL_SYMBOL_TABLE[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 146,
        "end_line": 171,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.main#376",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.main ()",
        "snippet": "int main ()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_type_symbol();\n\ttest_symbol_cand_page();\n\n\treturn exit_status();\n}",
        "begin_line": 376,
        "end_line": 385,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_symbol_cand_page#356",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_symbol_cand_page()",
        "snippet": "void test_symbol_cand_page()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_candPerPage( ctx, 10 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tchewing_handle_Default( ctx, '`' );\n\tok( chewing_cand_CurrentPage( ctx ) == 0, \"current page shall be 0\" );\n\tok( chewing_cand_TotalPage( ctx ) == 2, \"total page shall be 2\" );\n\n\tok_candidate( ctx, CAND, ARRAY_SIZE( CAND ) );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 356,
        "end_line": 374,
        "is_bug": false
    },
    {
        "name": "test.test-symbol.test_type_symbol#335",
        "src_path": "test/test-symbol.c",
        "class_name": "test.test-symbol",
        "signature": "test.test-symbol.test_type_symbol()",
        "snippet": "void test_type_symbol()\n{\n\tChewingContext *ctx;\n\tsize_t i;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\n\tchewing_set_candPerPage( ctx, 10 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tfor (i = 0; i < ARRAY_SIZE(SYMBOL); ++i ) {\n\t\ttype_keystroke_by_string( ctx, SYMBOL[i].token );\n\t\tok_preedit_buffer( ctx, \"\" );\n\t\tok_commit_buffer( ctx, SYMBOL[i].expected );\n\t}\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 335,
        "end_line": 354,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.main#287",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.main()",
        "snippet": "int main()\n{\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\ttest_ShiftLeft();\n\ttest_ShiftRight();\n\ttest_CtrlNum();\n\ttest_userphrase();\n\n\treturn exit_status();\n}",
        "begin_line": 287,
        "end_line": 298,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum#225",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum()",
        "snippet": "void test_CtrlNum()\n{\n\ttest_CtrlNum_add_phrase_right();\n\ttest_CtrlNum_add_phrase_left();\n\ttest_CtrlNum_add_phrase_right_symbol_in_between();\n\ttest_CtrlNum_add_phrase_left_symbol_in_between();\n}",
        "begin_line": 225,
        "end_line": 231,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_left#143",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_left()",
        "snippet": "void test_CtrlNum_add_phrase_left()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<C2>\" );\n\tok_preedit_buffer( ctx, phrase );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor position `%d' shall be 2\", cursor );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 1,\n\t\t\"`%s' shall be in userphrase\", phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 143,
        "end_line": 169,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_left_symbol_in_between#198",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_left_symbol_in_between()",
        "snippet": "void test_CtrlNum_add_phrase_left_symbol_in_between()\n{\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\ttype_keystroke_by_string( ctx, \"hk4`1g4<C2>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 3, \"cursor position `%d' shall be 3\", cursor );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 198,
        "end_line": 223,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_right#115",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_right()",
        "snippet": "void test_CtrlNum_add_phrase_right()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 0 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<H><C2>\" );\n\tok_preedit_buffer( ctx, phrase );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor position `%d' shall be 0\", cursor );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 1,\n\t\t\"`%s' shall be in userphrase\", phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 115,
        "end_line": 141,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_CtrlNum_add_phrase_right_symbol_in_between#171",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_CtrlNum_add_phrase_right_symbol_in_between()",
        "snippet": "void test_CtrlNum_add_phrase_right_symbol_in_between()\n{\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 0 );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\ttype_keystroke_by_string( ctx, \"hk4`1g4<H><C2>\" );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor position `%d' shall be 0\", cursor );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 171,
        "end_line": 196,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft#63",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft()",
        "snippet": "void test_ShiftLeft()\n{\n\ttest_ShiftLeft_not_entering_chewing();\n\ttest_ShiftLeft_add_userphrase();\n}",
        "begin_line": 63,
        "end_line": 67,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft_add_userphrase#36",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft_add_userphrase()",
        "snippet": "void test_ShiftLeft_add_userphrase()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<SL><SL><E>\" );\n\tok_preedit_buffer( ctx, phrase );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 0, \"cursor position `%d' shall be 0\", cursor );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 1,\n\t\t\"`%s' shall be in userphrase\", phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 36,
        "end_line": 61,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftLeft_not_entering_chewing#23",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftLeft_not_entering_chewing()",
        "snippet": "void test_ShiftLeft_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"<SL>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 23,
        "end_line": 34,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight#109",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight()",
        "snippet": "void test_ShiftRight()\n{\n\ttest_ShiftRight_not_entering_chewing();\n\ttest_ShiftRight_add_userphrase();\n}",
        "begin_line": 109,
        "end_line": 113,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight_add_userphrase#82",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight_add_userphrase()",
        "snippet": "void test_ShiftRight_add_userphrase()\n{\n\tstatic const char phrase[] = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\" /* \u6e2c\u8a66 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x98\\xE3\\x84\\x9C\\xCB\\x8B \\xE3\\x84\\x95\\xCB\\x8B\" /* \u3118\u311c\u02cb \u3115\u02cb */;\n\tint cursor;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"hk4g4<L><L><SR><SR><E>\" );\n\tok_preedit_buffer( ctx, phrase );\n\tcursor = chewing_cursor_Current( ctx );\n\tok( cursor == 2, \"cursor position `%d' shall be 2\", cursor );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 1,\n\t\t\"`%s' shall be in userphrase\", phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_",
        "begin_line": 82,
        "end_line": 107,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_ShiftRight_not_entering_chewing#69",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_ShiftRight_not_entering_chewing()",
        "snippet": "void test_ShiftRight_not_entering_chewing()\n{\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tctx = chewing_new();\n\ttype_keystroke_by_string( ctx, \"<SR>\" );\n\tok_keystroke_rtn( ctx, KEYSTROKE_IGNORE );\n\n\tchewing_delete( ctx );\n}",
        "begin_line": 69,
        "end_line": 80,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase#281",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase()",
        "snippet": "void test_userphrase()\n{\n\ttest_userphrase_auto_learn();\n\ttest_userphrase_auto_learn_hardcode_break();\n}",
        "begin_line": 281,
        "end_line": 285,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_auto_learn#233",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_auto_learn()",
        "snippet": "void test_userphrase_auto_learn()\n{\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x8E\\xE3\\x84\\x9C \\xE3\\x84\\x8E\\xE3\\x84\\x9C\" /* \u310e\u311c \u310e\u311c */;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 0,\n\t\t\"`%s' shall not be in userphrase\", bopomofo );\n\n\ttype_keystroke_by_string( ctx, \"dk dk <E>\" );\n\tok( has_userphrase( ctx, bopomofo, NULL ) == 1,\n\t\t\"`%s' shall be in userphrase\", bopomofo );\n\n\tchewing_delete( ctx );\n}\n\nvoid t",
        "begin_line": 233,
        "end_line": 254,
        "is_bug": false
    },
    {
        "name": "test.test-userphrase.test_userphrase_auto_learn_hardcode_break#256",
        "src_path": "test/test-userphrase.c",
        "class_name": "test.test-userphrase",
        "signature": "test.test-userphrase.test_userphrase_auto_learn_hardcode_break()",
        "snippet": "void test_userphrase_auto_learn_hardcode_break()\n{\n\t/* \u7684 is a hardcode break point, see ChewingIsBreakPoint */\n\tstatic const char phrase[] = \"\\xE7\\x9A\\x84\\xE7\\x9A\\x84\" /* \u7684\u7684 */;\n\tstatic const char bopomofo[] = \"\\xE3\\x84\\x89\\xE3\\x84\\x9C\\xCB\\x99 \\xE3\\x84\\x89\\xE3\\x84\\x9C\\xCB\\x99\" /* \u3109\u311c\u02d9 \u3109\u311c\u02d9 */;\n\tChewingContext *ctx;\n\n\tprint_function_name();\n\n\tclean_userphrase();\n\n\tctx = chewing_new();\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\ttype_keystroke_by_string( ctx, \"2k72k7<E>\" );\n\tok( has_userphrase( ctx, bopomofo, phrase ) == 0,\n\t\t\"`%s' shall not be in userphrase\", phrase );\n\n\tchewing_delete( ctx );\n}\n\nvoid test_user",
        "begin_line": 256,
        "end_line": 279,
        "is_bug": false
    },
    {
        "name": "test.test-utf8.main#49",
        "src_path": "test/test-utf8.c",
        "class_name": "test.test-utf8",
        "signature": "test.test-utf8.main ()",
        "snippet": "int main ()\n{\ntest_utf8();\n\treturn exit_status();\n}",
        "begin_line": 49,
        "end_line": 53,
        "is_bug": false
    },
    {
        "name": "test.test-utf8.test_utf8#17",
        "src_path": "test/test-utf8.c",
        "class_name": "test.test-utf8",
        "signature": "test.test-utf8.test_utf8()",
        "snippet": "void test_utf8()\n{\n\tchar *u8string;\n\tint u8len;\n\tint len;\n\tchar u8string2[16];\n\n\tprint_function_name();\n\n\tu8string = \"HelloWorld\";\n\tu8len = ueStrLen(u8string);\n\tlen = strlen(u8string);\n\tok (u8len == len, \"ueStrLen\");\n\n\tu8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\"; /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n\tu8len = ueStrLen(u8string);\n\tok (u8len == 6, \"ueStrLen\");\n\n\tu8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\"; /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n\tueStrNCpy(u8string2, u8string, 3, STRNCPY_CLOSE);\n\tok (!strcmp(u8string2, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\" /* \u6e2c\u8a66\u8a08 */ ), \"ueStrNCpy\");\n\n\tu8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\"; /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n\tu8string = ueStrSeek(u8string, 3);\n\tok (!strcmp(u8string, \"\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\" /* \u7b97\u9577\u5ea6 */ ), \"ueStrSeek\");\n\n\tu8string = \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\"; /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */\n\tu8string = ueStrSeek(u8string, 0);\n\tok (!strcmp(u8string, \"\\xE6\\xB8\\xAC\\xE8\\xA9\\xA6\\xE8\\xA8\\x88\\xE7\\xAE\\x97\\xE9\\x95\\xB7\\xE5\\xBA\\xA6\" /* \u6e2c\u8a66\u8a08\u7b97\u9577\u5ea6 */ ), \"ueStrSeek\");\n\n}\n\nint main ()\n{\ntest_utf8();\n\treturn exit_status();\n}\n",
        "begin_line": 17,
        "end_line": 47,
        "is_bug": false
    },
    {
        "name": "test.testchewing.commit_string#39",
        "src_path": "test/testchewing.c",
        "class_name": "test.testchewing",
        "signature": "test.testchewing.commit_string( ChewingContext *ctx )",
        "snippet": "void commit_string( ChewingContext *ctx )\n{\n\tchar *s;\n\tif ( chewing_commit_Check( ctx ) ) {\n\t\ts = chewing_commit_String( ctx );\n#ifdef USED_IN_SIMULATION\n\t\tstrcat( commit_string_buf, s );\n#else\n\t\tprintf( \"%s\", s );\n#endif\n\t\tfree( s );\n\t}\n}",
        "begin_line": 39,
        "end_line": 51,
        "is_bug": false
    },
    {
        "name": "test.testchewing.get_char#31",
        "src_path": "test/testchewing.c",
        "class_name": "test.testchewing",
        "signature": "test.testchewing.get_char( void *param UNUSED )",
        "snippet": "static int get_char( void *param UNUSED )\n{\n\tint ch = getchar();\n\tif ( ch == EOF )\n\t\treturn END;\n\treturn ch;\n}",
        "begin_line": 31,
        "end_line": 37,
        "is_bug": false
    },
    {
        "name": "test.testchewing.main#85",
        "src_path": "test/testchewing.c",
        "class_name": "test.testchewing",
        "signature": "test.testchewing.main() #endif",
        "snippet": "int main()\n#endif\n{\n\tChewingContext *ctx;\n\tint i;\n\n\t/* Initialize libchewing */\n\tputenv( \"CHEWING_PATH=\" CHEWING_DATA_PREFIX );\n\t/* for the sake of testing, we should not change existing hash data */\n\tputenv( \"CHEWING_USER_PATH=\" TEST_HASH_DIR );\n\n\t/* Request handle to ChewingContext */\n\tctx = chewing_new();\n\n\t/* Set keyboard type */\n\tchewing_set_KBType( ctx, chewing_KBStr2Num( \"KB_DEFAULT\" ) );\n\n\tchewing_set_candPerPage( ctx, 9 );\n\tchewing_set_maxChiSymbolLen( ctx, 16 );\n\tchewing_set_addPhraseDirection( ctx, 1 );\n\tchewing_set_selKey( ctx, selKey_define, 10 );\n\tchewing_set_spaceAsSelection( ctx, 1 );\n\n\twhile ( 1 ) {\n\t\ti = get_keystroke( get_char, NULL );\n\t\tif ( i == END )\n\t\t\tgoto end;\n                type_single_keystroke( ctx, i );\n\t\tcommit_string( ctx );\n#ifdef USED_IN_SIMULATION\n\t\tif ( i == KEY_ENTER )\n\t\t\tcompare_per_run();\n#endif\n\t}\nend:\n\t/* Free Chewing IM handle */\n\tchewing_delete( ctx );\n\n\t/* Termate Chewing services */\n#ifndef USED_IN_SIMULATION\n\tprintf( \"\\n\" );\n#endif\n\treturn 0;\n}",
        "begin_line": 85,
        "end_line": 128,
        "is_bug": false
    },
    {
        "name": "test.testhelper.clean_userphrase#445",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.clean_userphrase()",
        "snippet": "void clean_userphrase()\n{\n\tremove( TEST_HASH_DIR PLAT_SEPARATOR HASH_FILE );\n}",
        "begin_line": 445,
        "end_line": 448,
        "is_bug": false
    },
    {
        "name": "test.testhelper.exit_status#440",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.exit_status()",
        "snippet": "int exit_status()\n{\n\treturn test_run == test_ok ? 0 : -1;\n}",
        "begin_line": 440,
        "end_line": 443,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_char_by_string#232",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_char_by_string( void * param )",
        "snippet": "static int get_char_by_string( void * param )\n{\n\tchar **ptr = param;\n\tchar ch;\n\n\tassert( param );\n\n\tif ( **ptr == 0 ) {\n\t\treturn END;\n\t}\n\n\tch = **ptr;\n\t++*ptr;\n\treturn ch;\n}",
        "begin_line": 232,
        "end_line": 246,
        "is_bug": false
    },
    {
        "name": "test.testhelper.get_keystroke#60",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.get_keystroke( get_char_func get_char, void * param )",
        "snippet": "int get_keystroke( get_char_func get_char, void * param )\n{\n\tint ch;\n\tint result = END;\n\tint flag = 0;\n\n\tassert( get_char );\n\n\twhile ( ( ch = get_char( param ) ) != END ) {\n\t\tif ( ( ch != '<' ) && ( flag != 1 ) )\n\t\t\treturn (int) ch;\n\t\telse if ( ch == '>' ) {\n\t\t\tflag = 0;\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\tflag = 1;\n\t\t\tch = get_char( param );\n\t\t\tswitch ( ch ) {\n\t\t\t\tcase '<':\n\t\t\t\tcase '>':\n\t\t\t\t\tif ( get_char( param ) == '>' )\n\t\t\t\t\t\treturn result = ch;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'L':\n\t\t\t\t\tresult = KEY_LEFT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'R':\n\t\t\t\t\tresult = KEY_RIGHT;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'U':\n\t\t\t\t\tresult = KEY_UP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'D':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == '>' )\n\t\t\t\t\t\treturn result = KEY_DOWN;\n\t\t\t\t\telse {\n\t\t\t\t\t\tget_char( param );\n\t\t\t\t\t\treturn result = KEY_DELETE;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'E':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == '>' )\n\t\t\t\t\t\treturn result = KEY_ENTER;\n\t\t\t\t\telse if ( ch == 'E' )\n\t\t\t\t\t\tresult = KEY_ESC;\n\t\t\t\t\telse\n\t\t\t\t\t\tresult = KEY_END;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'C':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) != '>' ) {\n\t\t\t\t\t\tif ( ch == 'B' )\n\t\t\t\t\t\t\tresult = ( KEY_CAPSLOCK );\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresult = ( KEY_CTRL_BASE + ch );\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tresult = KEY_BACKSPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'H':\n\t\t\t\t\tresult = KEY_HOME;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == 'L' )\n\t\t\t\t\t\tresult = KEY_SLEFT;\n\t\t\t\t\telse if ( ch == 'R' )\n\t\t\t\t\t\tresult = KEY_SRIGHT;\n\t\t\t\t\telse\n\t\t\t\t\t\tresult = KEY_SSPACE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == '>' )\n\t\t\t\t\t\treturn result = KEY_TAB;\n\t\t\t\t\telse\n\t\t\t\t\t\tresult = KEY_DBLTAB;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'P':\n\t\t\t\t\tif ( ( ch = get_char( param ) ) == 'D' )\n\t\t\t\t\t\tresult = KEY_NPAGE;\n\t\t\t\t\telse\n\t\t\t\t\t\tresult = KEY_PPAGE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tch = get_char( param );\n\t\t\t\t\tresult = KEY_NUMPAD_BASE + ch;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result = END;\n}",
        "begin_line": 60,
        "end_line": 151,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_has_userphrase#397",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_has_userphrase( const char *file UNUSED, int line UNUSED, ChewingContext *ctx, const char *bopomofo, const char *phrase )",
        "snippet": "int internal_has_userphrase( const char *file UNUSED, int line UNUSED,\n\tChewingContext *ctx, const char *bopomofo, const char *phrase )\n{\n\tuint16_t *phone = NULL;\n\tchar *bopomofo_buf = NULL;\n\tint i;\n\tchar *p;\n\tchar *save_ptr = NULL;\n\tHASH_ITEM *item = NULL;\n\tint ret = 0;\n\n\tphone = calloc( MAX_PHONE_SEQ_LEN, sizeof (*phone) );\n\tif ( !phone ) {\n\t\tfprintf( stderr, \"calloc fails at %s:%d\", __FILE__, __LINE__ );\n\t\tgoto end;\n\t}\n\n\tbopomofo_buf = strdup( bopomofo );\n\tif ( !bopomofo_buf ) {\n\t\tfprintf( stderr, \"strdup fails at %s:%d\", __FILE__, __LINE__ );\n\t\tgoto end;\n\t}\n\n\tfor ( i = 0, p = strtok_r( bopomofo_buf, \" \", &save_ptr );\n\t\ti < MAX_PHONE_SEQ_LEN && p;\n\t\t++i, p = strtok_r( NULL, \" \", &save_ptr) ) {\n\t\tphone[i] = UintFromPhone( p );\n\t}\n\n\twhile ( ( item = HashFindPhonePhrase( ctx->data, phone, item ) ) != NULL ) {\n\t\tif ( phrase == NULL || strcmp( item->data.wordSeq, phrase ) == 0 ) {\n\t\t\tret = 1;\n\t\t\tgoto end;\n\t\t}\n\t}\n\nend:\n\tfree( bopomofo_buf );\n\tfree( phone );\n\n\treturn ret;\n}",
        "begin_line": 397,
        "end_line": 438,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok#248",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok( const char *file, int line, int test, const char * test_txt, const char *fmt, ...)",
        "snippet": "void internal_ok( const char *file, int line, int test, const char * test_txt,\n\tconst char *fmt, ...)\n{\n\tva_list ap;\n\n\t++test_run;\n\tif ( test ) {\n\t\t++test_ok;\n\t\tprintf( \"ok %d \", test_run);\n\n\t\tva_start( ap, fmt );\n\t\tvprintf( fmt, ap );\n\t\tva_end( ap );\n\n\t\tprintf(\"\\n\");\n\t} else {\n\t\tprintf( \"not ok %d \", test_run);\n\n\t\tva_start( ap, fmt );\n\t\tvprintf( fmt, ap );\n\t\tva_end( ap );\n\n\t\tprintf( \"\\n# %s failed in %s:%d\\n\", test_txt, file, line );\n\t}\n}",
        "begin_line": 248,
        "end_line": 272,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_buffer#279",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_buffer( const char *file, int line, ChewingContext *ctx, const char *expected, const BufferType *buffer )",
        "snippet": "void internal_ok_buffer( const char *file, int line, ChewingContext *ctx,\n\tconst char *expected, const BufferType *buffer )\n{\n\tchar *buf;\n\tint actual_ret;\n\tint expected_ret;\n\tint expected_len;\n\n\tassert( ctx );\n\tassert( expected );\n\tassert( buffer );\n\n\texpected_len = ueStrLen( expected );\n\n\tif ( buffer->check ) {\n\t\tactual_ret = buffer->check( ctx );\n\t\texpected_ret = !!expected_len;\n\t\tinternal_ok( file, line, actual_ret == expected_ret,\n\t\t\t\"actual_ret == expected_ret\",\n\t\t\t\"check function returned `%d' shall be `%d'\", actual_ret, expected_ret );\n\t}\n\n\tif ( buffer->check_alt ) {\n\t\tactual_ret = buffer->check_alt( ctx );\n\t\texpected_ret = !expected_len;\n\t\tinternal_ok( file, line, actual_ret == expected_ret,\n\t\t\t\"actual_ret == expected_ret\",\n\t\t\t\"check function returned `%d' shall be `%d'\", actual_ret, expected_ret );\n\t}\n\n\tif ( buffer->get_length ) {\n\t\tactual_ret = buffer->get_length( ctx );\n\t\texpected_ret = expected_len;\n\t\tinternal_ok( file, line, actual_ret == expected_ret,\n\t\t\t\"actual_ret == expected_ret\",\n\t\t\t\"get length function returned `%d' shall be `%d'\", actual_ret, expected_ret );\n\t}\n\n\tif ( buffer->get_string ) {\n\t\tbuf = buffer->get_string( ctx );\n\t\tinternal_ok( file, line, !strcmp( buf, expected ), \"!strcmp( buf, expected )\",\n\t\t\t\"string function returned `%s' shall be `%s'\", buf, expected );\n\t\tchewing_free( buf );\n\t}\n\n\tif ( buffer->get_string_alt ) {\n\t\tbuf = buffer->get_string_alt( ctx, &actual_ret );\n\t\texpected_ret = expected_len;\n\t\tinternal_ok( file, line, actual_ret == expected_ret,\n\t\t\t\"actual_ret == expected_ret\",\n\t\t\t\"string function returned parameter `%d' shall be `%d'\", actual_ret, expected_ret );\n\t\tinternal_ok( file, line, !strcmp( buf, expected ), \"!strcmp( buf, expected )\",\n\t\t\t\"string function returned `%s' shall be `%s'\", buf, expected );\n\t\tchewing_free( buf );\n\t}\n}",
        "begin_line": 279,
        "end_line": 334,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_candidate#336",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_candidate( const char *file, int line, ChewingContext *ctx, const char *cand[], size_t cand_len )",
        "snippet": "void internal_ok_candidate( const char *file, int line,\n\tChewingContext *ctx, const char *cand[], size_t cand_len )\n{\n\tsize_t i;\n\tchar *buf;\n\n\tassert( ctx );\n\n\tchewing_cand_Enumerate( ctx );\n\tfor ( i = 0; i < cand_len; ++i ) {\n\t\tinternal_ok( file, line, chewing_cand_hasNext( ctx ), __func__,\n\t\t\t\"shall has next candidate\" );\n\n\t\tbuf = chewing_cand_String( ctx );\n\t\tinternal_ok( file, line, strcmp( buf, cand[i] ) == 0, __func__,\n\t\t\t\"candidate `%s' shall be `%s'\", buf, cand[i] );\n\t\tchewing_free( buf );\n\n\t\tbuf = chewing_cand_String_by_index( ctx, i );\n\t\tinternal_ok( file, line, strcmp( buf, cand[i] ) == 0, __func__,\n\t\t\t\"candndate `%s' shall be `%s'\", buf, cand[i] );\n\t\tchewing_free( buf );\n\t}\n\n\tinternal_ok( file, line , !chewing_cand_hasNext( ctx ), __func__,\n\t\t\t\"shall not have next candidate\" );\n\tbuf = chewing_cand_String( ctx );\n\n\tinternal_ok( file, line, strcmp( buf, \"\" ) == 0, __func__,\n\t\t\"candndate `%s' shall be `%s'\", buf, \"\" );\n\n\tchewing_free( buf );\n}",
        "begin_line": 336,
        "end_line": 368,
        "is_bug": false
    },
    {
        "name": "test.testhelper.internal_ok_keystroke_rtn#370",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.internal_ok_keystroke_rtn( const char *file, int line, ChewingContext *ctx, int rtn )",
        "snippet": "void internal_ok_keystroke_rtn( const char *file, int line,\n\tChewingContext *ctx, int rtn )\n{\n\tconst struct {\n\t\tint rtn;\n\t\tint (*func)(ChewingContext* ctx);\n\t} TABLE[] = {\n\t\t{ KEYSTROKE_IGNORE, chewing_keystroke_CheckIgnore },\n\t\t{ KEYSTROKE_COMMIT, chewing_commit_Check },\n\t\t// No function to check KEYSTROKE_BELL\n\t\t{ KEYSTROKE_ABSORB, chewing_keystroke_CheckAbsorb },\n\t};\n\tsize_t i;\n\tint actual;\n\tint expected;\n\n\tassert( ctx );\n\n\tfor ( i = 0; i < ARRAY_SIZE( TABLE ); ++i ) {\n\t\tactual = TABLE[i].func( ctx );\n\t\texpected = !!( rtn & TABLE[i].rtn );\n\n\t\tinternal_ok( file, line, actual == expected,\n\t\t\t__func__, \"keystroke rtn `%d' shall be `%d'\", actual, expected );\n\t}\n}",
        "begin_line": 370,
        "end_line": 395,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_keystroke#224",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_keystroke( ChewingContext *ctx, get_char_func get_char, void *param )",
        "snippet": "static void type_keystroke( ChewingContext *ctx, get_char_func get_char, void *param )\n{\n\tint ch;\n\n\twhile ( ( ch = get_keystroke( get_char, param ) ) != END )\n\t\ttype_single_keystroke( ctx, ch );\n}",
        "begin_line": 224,
        "end_line": 230,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_keystroke_by_string#274",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_keystroke_by_string( ChewingContext *ctx, char* keystroke )",
        "snippet": "void type_keystroke_by_string( ChewingContext *ctx, char* keystroke )\n{\n\ttype_keystroke( ctx, get_char_by_string, &keystroke );\n}",
        "begin_line": 274,
        "end_line": 277,
        "is_bug": false
    },
    {
        "name": "test.testhelper.type_single_keystroke#153",
        "src_path": "test/testhelper.c",
        "class_name": "test.testhelper",
        "signature": "test.testhelper.type_single_keystroke( ChewingContext *ctx, int ch )",
        "snippet": "void type_single_keystroke( ChewingContext *ctx, int ch )\n{\n\tswitch ( ch ) {\n\t\tcase KEY_LEFT:\n\t\t\tchewing_handle_Left( ctx );\n\t\t\tbreak;\n\t\tcase KEY_SLEFT:\n\t\t\tchewing_handle_ShiftLeft( ctx );\n\t\t\tbreak;\n\t\tcase KEY_RIGHT:\n\t\t\tchewing_handle_Right( ctx );\n\t\t\tbreak;\n\t\tcase KEY_SRIGHT:\n\t\t\tchewing_handle_ShiftRight( ctx );\n\t\t\tbreak;\n\t\tcase KEY_UP:\n\t\t\tchewing_handle_Up( ctx );\n\t\t\tbreak;\n\t\tcase KEY_DOWN:\n\t\t\tchewing_handle_Down( ctx );\n\t\t\tbreak;\n\t\tcase KEY_SPACE:\n\t\t\tchewing_handle_Space( ctx );\n\t\t\tbreak;\n\t\tcase KEY_ENTER:\n\t\t\tchewing_handle_Enter( ctx );\n\t\t\tbreak;\n\t\tcase KEY_BACKSPACE:\n\t\t\tchewing_handle_Backspace( ctx );\n\t\t\tbreak;\n\t\tcase KEY_ESC:\n\t\t\tchewing_handle_Esc( ctx );\n\t\t\tbreak;\n\t\tcase KEY_DELETE:\n\t\t\tchewing_handle_Del( ctx );\n\t\t\tbreak;\n\t\tcase KEY_HOME:\n\t\t\tchewing_handle_Home( ctx );\n\t\t\tbreak;\n\t\tcase KEY_END:\n\t\t\tchewing_handle_End( ctx );\n\t\t\tbreak;\n\t\tcase KEY_TAB:\n\t\t\tchewing_handle_Tab( ctx );\n\t\t\tbreak;\n\t\tcase KEY_CAPSLOCK:\n\t\t\tchewing_handle_Capslock( ctx );\n\t\t\tbreak;\n\t\tcase KEY_NPAGE:\n\t\t\tchewing_handle_PageDown( ctx );\n\t\t\tbreak;\n\t\tcase KEY_PPAGE:\n\t\t\tchewing_handle_PageUp( ctx );\n\t\t\tbreak;\n\t\tcase KEY_SSPACE:\n\t\t\tchewing_handle_ShiftSpace( ctx );\n\t\t\tbreak;\n\t\tcase KEY_DBLTAB:\n\t\t\tchewing_handle_DblTab( ctx );\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif ( KEY_CTRL_BASE <= ch && ch < KEY_NUMPAD_BASE)\n\t\t\t\tchewing_handle_CtrlNum( ctx, ch - KEY_CTRL_BASE );\n\t\t\telse if ( KEY_NUMPAD_BASE <= ch )\n\t\t\t\tchewing_handle_Numlock( ctx, ch - KEY_NUMPAD_BASE );\n\t\t\telse\n\t\t\t\tchewing_handle_Default( ctx, (char) ch );\n\t\t\tbreak;\n\t}\n}",
        "begin_line": 153,
        "end_line": 222,
        "is_bug": false
    }
]