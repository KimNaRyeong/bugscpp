        -:    0:Source:/home/workspace/src/tree.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/tree.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/tree.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * tree.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2005, 2006, 2008, 2011
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: *	@file tree.c
        -:   17: *	@brief API for accessing the phrase tree.
        -:   18: */
        -:   19:#include <assert.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:#include "chewing-private.h"
        -:   25:#include "chewing-utf8-util.h"
        -:   26:#include "userphrase-private.h"
        -:   27:#include "global.h"
        -:   28:#include "global-private.h"
        -:   29:#include "dict-private.h"
        -:   30:#include "memory-private.h"
        -:   31:#include "tree-private.h"
        -:   32:#include "private.h"
        -:   33:#include "plat_mmap.h"
        -:   34:
        -:   35:#define INTERVAL_SIZE ( ( MAX_PHONE_SEQ_LEN + 1 ) * MAX_PHONE_SEQ_LEN / 2 )
        -:   36:
        -:   37:typedef struct {
        -:   38:	int from, to, source;
        -:   39:	Phrase *p_phr;
        -:   40:} PhraseIntervalType;
        -:   41:
        -:   42:typedef struct tagRecordNode {
        -:   43:	int *arrIndex;		/* the index array of the things in "interval" */
        -:   44:	int nInter, score;
        -:   45:	struct tagRecordNode *next;
        -:   46:	int nMatchCnnct;	/* match how many Cnnct. */
        -:   47:} RecordNode;
        -:   48:
        -:   49:typedef struct {
        -:   50:	int leftmost[ MAX_PHONE_SEQ_LEN + 1 ] ;
        -:   51:	char graph[ MAX_PHONE_SEQ_LEN + 1 ][ MAX_PHONE_SEQ_LEN + 1 ];
        -:   52:	PhraseIntervalType interval[ MAX_INTERVAL ];
        -:   53:	int nInterval;
        -:   54:	RecordNode *phList;
        -:   55:	int nPhListLen;
        -:   56:} TreeDataType;
        -:   57:
      226:   58:static int IsContain( IntervalType in1, IntervalType in2 )
        -:   59:{
      226:   60:	return ( in1.from <= in2.from && in1.to >= in2.to );
        -:   61:}
        -:   62:
       79:   63:int IsIntersect( IntervalType in1, IntervalType in2 )
        -:   64:{
       79:   65:	return ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );
        -:   66:}
        -:   67:
     5009:   68:static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)
        -:   69:{
     5009:   70:	return ( in1.from <= in2.from && in1.to >= in2.to );
        -:   71:}
        -:   72:
       26:   73:static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)
        -:   74:{
       26:   75:	return ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );
        -:   76:}
        -:   77:
       33:   78:void TerminateTree( ChewingData *pgdata )
        -:   79:{
       33:   80:		pgdata->static_data.tree = NULL;
       33:   81:		plat_mmap_close( &pgdata->static_data.tree_mmap );
       33:   82:}
        -:   83:
        -:   84:
       33:   85:int InitTree( ChewingData *pgdata, const char * prefix )
        -:   86:{
        -:   87:	char filename[ PATH_MAX ];
        -:   88:	size_t len;
        -:   89:	size_t offset;
        -:   90:
       33:   91:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, PHONE_TREE_FILE );
       33:   92:	if ( len + 1 > sizeof( filename ) )
    #####:   93:		return -1;
        -:   94:
       33:   95:	plat_mmap_set_invalid( &pgdata->static_data.tree_mmap );
       33:   96:	pgdata->static_data.tree_size = plat_mmap_create( &pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ );
       33:   97:	if ( pgdata->static_data.tree_size <= 0 )
    #####:   98:		return -1;
        -:   99:
       33:  100:	offset = 0;
       33:  101:	pgdata->static_data.tree = (const TreeType *) plat_mmap_set_view( &pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size );
       33:  102:	if ( !pgdata->static_data.tree )
    #####:  103:		return -1;
        -:  104:
       33:  105:	return 0;
        -:  106:}
        -:  107:
     2131:  108:static int CheckBreakpoint( int from, int to, int bArrBrkpt[] )
        -:  109:{
        -:  110:	int i;
     5743:  111:	for ( i = from + 1; i < to; i++ )
     3665:  112:		if ( bArrBrkpt[ i ] )
       53:  113:			return 0;
     2078:  114:	return 1;
        -:  115:}
        -:  116:
       69:  117:static int CheckUserChoose(
        -:  118:		ChewingData *pgdata,
        -:  119:		uint16_t *new_phoneSeq, int from , int to,
        -:  120:		Phrase **pp_phr,
        -:  121:		char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],
        -:  122:		IntervalType selectInterval[], int nSelect )
        -:  123:{
        -:  124:	IntervalType inte, c;
        -:  125:	int chno, len;
        -:  126:	int user_alloc;
        -:  127:	UserPhraseData *pUserPhraseData;
       69:  128:	Phrase *p_phr = ALC( Phrase, 1 );
        -:  129:
      69*:  130:	assert( p_phr );
       69:  131:	inte.from = from;
       69:  132:	inte.to = to;
       69:  133:	*pp_phr = NULL;
        -:  134:
        -:  135:	/* pass 1
        -:  136:	 * if these exist one selected interval which is not contained by inte
        -:  137:	 * but has intersection with inte, then inte is an unacceptable interval
        -:  138:	 */
       94:  139:	for ( chno = 0; chno < nSelect; chno++ ) {
       25:  140:		c = selectInterval[ chno ];
       25:  141:		if ( IsIntersect( inte, c ) && ! IsContain( inte, c ) ) {
    #####:  142:			free( p_phr );
    #####:  143:			return 0;
        -:  144:		}
        -:  145:	}
        -:  146:
        -:  147:	/* pass 2
        -:  148:	 * if there exist one phrase satisfied all selectStr then return 1, else return 0.
        -:  149:	 * also store the phrase with highest freq
        -:  150:	 */
       69:  151:	pUserPhraseData = UserGetPhraseFirst( pgdata, new_phoneSeq );
       69:  152:	p_phr->freq = -1;
        -:  153:	do {
      221:  154:		for ( chno = 0; chno < nSelect; chno++ ) {
       61:  155:			c = selectInterval[ chno ];
        -:  156:
       61:  157:			if ( IsContain( inte, c ) ) {
        -:  158:				/*
        -:  159:				 * find a phrase of ph_id where the text contains
        -:  160:				 * 'selectStr[chno]' test if not ok then return 0,
        -:  161:				 * if ok then continue to test. */
       55:  162:				len = c.to - c.from;
       55:  163:				if ( memcmp(
       55:  164:					ueStrSeek( pUserPhraseData->wordSeq, c.from - from ),
       55:  165:					selectStr[ chno ],
       55:  166:					ueStrNBytes( selectStr[ chno ], len ) ) )
       36:  167:					break;
        -:  168:			}
        -:  169:
        -:  170:		}
      196:  171:		if ( chno == nSelect ) {
        -:  172:			/* save phrase data to "pp_phr" */
      160:  173:			if ( pUserPhraseData->userfreq > p_phr->freq ) {
       69:  174:				if ( ( user_alloc = ( to - from ) ) > 0 ) {
       69:  175:					ueStrNCpy( p_phr->phrase,
       69:  176:							pUserPhraseData->wordSeq,
        -:  177:							user_alloc, 1);
        -:  178:				}
       69:  179:				p_phr->freq = pUserPhraseData->userfreq;
       69:  180:				*pp_phr = p_phr;
        -:  181:			}
        -:  182:		}
      196:  183:	} while ( ( pUserPhraseData = UserGetPhraseNext( pgdata, new_phoneSeq ) ) != NULL );
        -:  184:
       69:  185:	if ( p_phr->freq != -1 )
       69:  186:		return 1;
        -:  187:
    #####:  188:	free( p_phr );
    #####:  189:	return 0;
        -:  190:}
        -:  191:
        -:  192:/*
        -:  193: * phrase is said to satisfy a choose interval if
        -:  194: * their intersections are the same */
     1025:  195:static int CheckChoose(
        -:  196:		ChewingData *pgdata,
        -:  197:		const TreeType *phrase_parent, int from, int to, Phrase **pp_phr,
        -:  198:		char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],
        -:  199:		IntervalType selectInterval[], int nSelect )
        -:  200:{
        -:  201:	IntervalType inte, c;
        -:  202:	int chno, len;
     1025:  203:	Phrase *phrase = ALC( Phrase, 1 );
        -:  204:
    1025*:  205:	assert( phrase );
     1025:  206:	inte.from = from;
     1025:  207:	inte.to = to;
     1025:  208:	*pp_phr = NULL;
        -:  209:
        -:  210:	/* if there exist one phrase satisfied all selectStr then return 1, else return 0. */
     1025:  211:	GetPhraseFirst( pgdata, phrase, phrase_parent );
        -:  212:	do {
     1147:  213:		for ( chno = 0; chno < nSelect; chno++ ) {
      146:  214:			c = selectInterval[ chno ];
        -:  215:
      146:  216:			if ( IsContain( inte, c ) ) {
        -:  217:				/* find a phrase under phrase_parent where the text contains
        -:  218:				 * 'selectStr[chno]' test if not ok then return 0, if ok
        -:  219:				 * then continue to test
        -:  220:				 */
      106:  221:				len = c.to - c.from;
      106:  222:				if ( memcmp(
      106:  223:					ueStrSeek( phrase->phrase, c.from - from ),
      106:  224:					selectStr[ chno ],
      106:  225:					ueStrNBytes( selectStr[ chno ], len ) ) )
       87:  226:					break;
        -:  227:			}
       40:  228:			else if ( IsIntersect( inte, selectInterval[ chno ] ) ) {
       20:  229:				free( phrase );
       20:  230:				return 0;
        -:  231:			}
        -:  232:		}
     1088:  233:		if ( chno == nSelect ) {
     1001:  234:			*pp_phr = phrase;
     1001:  235:			return 1;
        -:  236:		}
       87:  237:	} while ( GetVocabNext( pgdata, phrase ) );
        4:  238:	free( phrase );
        4:  239:	return 0;
        -:  240:}
        -:  241:
    38127:  242:static int CompTreeType( const void *a, const void *b )
        -:  243:{
    38127:  244:	return GetUint16(((TreeType*)a)->key) - GetUint16(((TreeType*)b)->key);
        -:  245:}
        -:  246:
        -:  247:/** @brief search for the phrases have the same pronunciation.*/
        -:  248:/* if phoneSeq[begin] ~ phoneSeq[end] is a phrase, then add an interval
        -:  249: * from (begin) to (end+1)
        -:  250: */
     3049:  251:const TreeType *TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )
        -:  252:{
        -:  253:	TreeType target;
     3049:  254:	const TreeType *tree_p = pgdata->static_data.tree;
        -:  255:	uint32_t range[2];
        -:  256:	int i;
        -:  257:
     7548:  258:	for ( i = begin; i <= end; i++ ) {
     5271:  259:		PutUint16(phoneSeq[i], target.key);
     5271:  260:		range[0] = GetUint24(tree_p->child.begin);
     5271:  261:		range[1] = GetUint24(tree_p->child.end);
     5271:  262:		tree_p = (const TreeType*)bsearch(&target, pgdata->static_data.tree + range[0],
     5271:  263:						  range[1] - range[0], sizeof(TreeType), CompTreeType);
        -:  264:
        -:  265:		/* if not found any word then fail. */
     5271:  266:		if( !tree_p )
      772:  267:			return NULL;
        -:  268:	}
        -:  269:
        -:  270:	/* If its child has no key value of 0, then it is only a "half" phrase. */
     2277:  271:	if( GetUint16(pgdata->static_data.tree[ GetUint24(tree_p->child.begin) ].key) != 0)
      281:  272:		return NULL;
     1996:  273:	return tree_p;
        -:  274:}
        -:  275:
        -:  276:/**
        -:  277: * @brief get child range of a given parent node.
        -:  278: */
     1971:  279:void TreeChildRange( ChewingData *pgdata, const TreeType *parent )
        -:  280:{
     1971:  281:	pgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);
     1971:  282:	pgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);
     1971:  283:}
        -:  284:
     1001:  285:static void AddInterval(
        -:  286:		TreeDataType *ptd, int begin , int end,
        -:  287:		Phrase *p_phrase, int dict_or_user )
        -:  288:{
     1001:  289:	ptd->interval[ ptd->nInterval ].from = begin;
     1001:  290:	ptd->interval[ ptd->nInterval ].to = end + 1;
     1001:  291:	ptd->interval[ ptd->nInterval ].p_phr = p_phrase;
     1001:  292:	ptd->interval[ ptd->nInterval ].source = dict_or_user;
     1001:  293:	ptd->nInterval++;
     1001:  294:}
        -:  295:
        -:  296:/* Item which inserts to interval array */
        -:  297:typedef enum {
        -:  298:	USED_PHRASE_NONE,	/**< none of items used */
        -:  299:	USED_PHRASE_USER,	/**< User phrase */
        -:  300:	USED_PHRASE_DICT	/**< Dict phrase */
        -:  301:} UsedPhraseMode;
        -:  302:
     2078:  303:static void internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )
        -:  304:{
        -:  305:	/* we must free unused phrase entry to avoid memory leak. */
     2078:  306:	switch ( mode ) {
       67:  307:		case USED_PHRASE_USER:
       67:  308:			if ( pDict != NULL )
       67:  309:				free( pDict );
       67:  310:			break;
      934:  311:		case USED_PHRASE_DICT:
      934:  312:			if ( pUser != NULL )
        2:  313:				free( pUser );
      934:  314:			break;
     1077:  315:		default: /* In fact, it is alwyas 0 */
     1077:  316:			if ( pDict != NULL )
    #####:  317:				free( pDict );
     1077:  318:			if ( pUser != NULL )
    #####:  319:				free( pUser );
     1077:  320:			break;
        -:  321:	}
     2078:  322:}
        -:  323:
      486:  324:static void FindInterval( ChewingData *pgdata, TreeDataType *ptd )
        -:  325:{
        -:  326:	int end, begin;
        -:  327:	const TreeType *phrase_parent;
        -:  328:	Phrase *p_phrase, *puserphrase, *pdictphrase;
        -:  329:	UsedPhraseMode i_used_phrase;
        -:  330:	uint16_t new_phoneSeq[ MAX_PHONE_SEQ_LEN ];
        -:  331:
     1286:  332:	for ( begin = 0; begin < pgdata->nPhoneSeq; begin++ ) {
     2878:  333:		for ( end = begin; end < min( pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN ); end++ ) {
     2131:  334:			if ( ! CheckBreakpoint( begin, end + 1, pgdata->bArrBrkpt ) )
       53:  335:				break;
        -:  336:
        -:  337:			/* set new_phoneSeq */
     2078:  338:			memcpy(
        -:  339:				new_phoneSeq,
     2078:  340:				&pgdata->phoneSeq[ begin ],
     2078:  341:				sizeof( uint16_t ) * ( end - begin + 1 ) );
     2078:  342:			new_phoneSeq[ end - begin + 1 ] = 0;
     2078:  343:			puserphrase = pdictphrase = NULL;
     2078:  344:			i_used_phrase = USED_PHRASE_NONE;
        -:  345:
        -:  346:			/* check user phrase */
     2147:  347:			if ( UserGetPhraseFirst( pgdata, new_phoneSeq ) &&
       69:  348:					CheckUserChoose( pgdata, new_phoneSeq, begin, end + 1,
       69:  349:					&p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect ) ) {
       69:  350:				puserphrase = p_phrase;
        -:  351:			}
        -:  352:
        -:  353:			/* check dict phrase */
     2078:  354:			phrase_parent = TreeFindPhrase( pgdata, begin, end, pgdata->phoneSeq );
     2078:  355:			if (
     1025:  356:				phrase_parent &&
     1025:  357:				CheckChoose(
        -:  358:					pgdata,
        -:  359:					phrase_parent, begin, end + 1,
     1025:  360:					&p_phrase, pgdata->selectStr,
     1025:  361:					pgdata->selectInterval, pgdata->nSelect ) ) {
     1001:  362:				pdictphrase = p_phrase;
        -:  363:			}
        -:  364:
        -:  365:			/* add only one interval, which has the largest freqency
        -:  366:			 * but when the phrase is the same, the user phrase overrides
        -:  367:			 * static dict
        -:  368:			 */
     2078:  369:			if ( puserphrase != NULL && pdictphrase == NULL ) {
    #####:  370:				i_used_phrase = USED_PHRASE_USER;
        -:  371:			}
     2078:  372:			else if ( puserphrase == NULL && pdictphrase != NULL ) {
      932:  373:				i_used_phrase = USED_PHRASE_DICT;
        -:  374:			}
     1146:  375:			else if ( puserphrase != NULL && pdictphrase != NULL ) {
        -:  376:				/* the same phrase, userphrase overrides */
       69:  377:				if ( ! strcmp(
       69:  378:					puserphrase->phrase,
       69:  379:					pdictphrase->phrase ) ) {
       48:  380:					i_used_phrase = USED_PHRASE_USER;
        -:  381:				}
        -:  382:				else {
       21:  383:					if ( puserphrase->freq > pdictphrase->freq ) {
       19:  384:						i_used_phrase = USED_PHRASE_USER;
        -:  385:					}
        -:  386:					else {
        2:  387:						i_used_phrase = USED_PHRASE_DICT;
        -:  388:					}
        -:  389:				}
        -:  390:			}
     2078:  391:			switch ( i_used_phrase ) {
       67:  392:				case USED_PHRASE_USER:
       67:  393:					AddInterval( ptd, begin, end, puserphrase, IS_USER_PHRASE );
       67:  394:					break;
      934:  395:				case USED_PHRASE_DICT:
      934:  396:					AddInterval( ptd, begin, end, pdictphrase, IS_DICT_PHRASE );
      934:  397:					break;
     1077:  398:				case USED_PHRASE_NONE:
        -:  399:				default:
     1077:  400:					break;
        -:  401:			}
     2078:  402:			internal_release_Phrase(
        -:  403:				i_used_phrase,
        -:  404:				puserphrase,
        -:  405:				pdictphrase );
        -:  406:		}
        -:  407:	}
      486:  408:}
        -:  409:
      486:  410:static void SetInfo( int len, TreeDataType *ptd )
        -:  411:{
        -:  412:	int i, a;
        -:  413:
     1772:  414:	for ( i = 0; i <= len; i++ )
     1286:  415:		ptd->leftmost[ i ] = i;
     1487:  416:	for ( i = 0; i < ptd->nInterval; i++ ) {
     1001:  417:		ptd->graph[ ptd->interval[ i ].from ][ ptd->interval[ i ].to ] = 1;
     1001:  418:		ptd->graph[ ptd->interval[ i ].to ][ ptd->interval[ i ].from ] = 1;
        -:  419:	}
        -:  420:
        -:  421:	/* set leftmost */
     1772:  422:	for ( a = 0; a <= len; a++ ) {
     6858:  423:		for ( i = 0; i <= len; i++ ) {
     5572:  424:			if ( ! ( ptd->graph[ a ][ i ] ) )
     3570:  425:				continue;
     2002:  426:			if ( ptd->leftmost[ i ] < ptd->leftmost[ a ] )
      792:  427:				ptd->leftmost[ a ] = ptd->leftmost[ i ];
        -:  428:		}
        -:  429:	}
      486:  430:}
        -:  431:
        -:  432:/*
        -:  433: * First we compare the 'nMatchCnnct'.
        -:  434: * If the values are the same, we will compare the 'score'
        -:  435: */
        2:  436:static int CompRecord( const RecordNode **pa, const RecordNode **pb )
        -:  437:{
        2:  438:	int diff = (*pb)->nMatchCnnct - (*pa)->nMatchCnnct;
        -:  439:
        2:  440:	if ( diff )
    #####:  441:		return diff;
        2:  442:	return ( (*pb)->score - (*pa)->score );
        -:  443:}
        -:  444:
        -:  445:/*
        -:  446: * Remove the interval containing in another interval.
        -:  447: *
        -:  448: * Example:
        -:  449: * 國民大會 has three interval: 國民, 大會, 國民大會. This function removes
        -:  450: * 國名, 大會 becasue 國民大會 contains 國民 and 大會.
        -:  451: */
      486:  452:static void Discard1( TreeDataType *ptd )
        -:  453:{
        -:  454:	int a, b;
        -:  455:	char failflag[ INTERVAL_SIZE ];
        -:  456:	int nInterval2;
        -:  457:
      486:  458:	memset( failflag, 0, sizeof( failflag ) );
     1487:  459:	for ( a = 0; a < ptd->nInterval; a++ ) {
     1001:  460:		if ( failflag[ a ] )
      211:  461:			continue;
     4266:  462:		for ( b = 0; b < ptd->nInterval; b++ ) {
     3683:  463:			if ( a == b || failflag[ b ] )
      990:  464:				continue ;
        -:  465:
        -:  466:			/* interval b is in interval a */
     2693:  467:			if ( PhraseIntervalContain( ptd->interval[ a ], ptd->interval[ b ] ) )
      422:  468:				continue;
        -:  469:
        -:  470:			/* interval b is in front of interval a */
     2271:  471:			if ( ptd->interval[ b ].to <= ptd->interval[ a ].from )
      950:  472:				continue;
        -:  473:
        -:  474:			/* interval b is in back of interval a */
     1321:  475:			if ( ptd->interval[ a ].to <= ptd->interval[ b ].from )
     1114:  476:				continue;
        -:  477:
      207:  478:			break;
        -:  479:		}
        -:  480:		/* if any other interval b is inside or leftside or rightside the
        -:  481:		 * interval a */
      790:  482:		if ( b >= ptd->nInterval ) {
        -:  483:			/* then kill all the intervals inside the interval a */
        -:  484:			int i;
     3528:  485:			for ( i = 0; i < ptd->nInterval; i++ ) {
     5135:  486:				if (! failflag[ i ] && i != a &&
     2190:  487:					PhraseIntervalContain( ptd->interval[ a ], ptd->interval[ i ] ) ) {
      386:  488:					failflag[ i ] = 1;
        -:  489:				}
        -:  490:			}
        -:  491:		}
        -:  492:	}
        -:  493:	/* discard all the intervals whose failflag[a] = 1 */
      486:  494:	nInterval2 = 0;
     1487:  495:	for ( a = 0; a < ptd->nInterval; a++ ) {
     1001:  496:		if ( ! failflag[ a ] ) {
      615:  497:			ptd->interval[ nInterval2++ ] = ptd->interval[ a ];
        -:  498:		}
        -:  499:		else {
      386:  500:			if ( ptd->interval[ a ].p_phr != NULL ) {
      386:  501:				free( ptd->interval[ a ].p_phr );
        -:  502:			}
        -:  503:		}
        -:  504:	}
      486:  505:	ptd->nInterval = nInterval2;
      486:  506:}
        -:  507:
        -:  508:/*
        -:  509: * Remove the interval that cannot connect to head or tail by other intervals.
        -:  510: *
        -:  511: * Example:
        -:  512: * The input string length is 5
        -:  513: * The available intervals are [1,1], [1,2], [2,3], [2,4], [5,5], [3,5].
        -:  514: *
        -:  515: * The possible connection from head to tail are [1,2][3,5], and
        -:  516: * [1,1][2,4][5,5]. Since [2,3] cannot connect to head or tail, it is removed
        -:  517: * by this function.
        -:  518: */
      486:  519:static void Discard2( TreeDataType *ptd )
        -:  520:{
        -:  521:	int i, j;
        -:  522:	char overwrite[ MAX_PHONE_SEQ_LEN ];
        -:  523:	char failflag[ INTERVAL_SIZE ];
        -:  524:	int nInterval2;
        -:  525:
      486:  526:	memset( failflag, 0, sizeof( failflag ) );
     1101:  527:	for ( i = 0; i < ptd->nInterval; i++ ) {
      615:  528:		if ( ptd->leftmost[ ptd->interval[ i ].from ] == 0 )
      615:  529:			continue;
        -:  530:		/* test if interval i is overwrited by other intervals */
    #####:  531:		memset( overwrite, 0, sizeof( overwrite ) );
    #####:  532:		for ( j = 0; j < ptd->nInterval; j++ ) {
    #####:  533:			if ( j == i )
    #####:  534:				continue;
    #####:  535:			memset(
    #####:  536:				&overwrite[ ptd->interval[ j ].from ],
        -:  537:				1,
    #####:  538:				ptd->interval[ j ].to - ptd->interval[ j ].from );
        -:  539:		}
    #####:  540:		if ( memchr(
    #####:  541:			&overwrite[ ptd->interval[ i ].from ],
        -:  542:			1,
    #####:  543:			ptd->interval[ i ].to - ptd->interval[ i ].from ) )
    #####:  544:			failflag[ i ] = 1;
        -:  545:	}
        -:  546:	/* discard all the intervals whose failflag[a] = 1 */
      486:  547:	nInterval2 = 0;
     1101:  548:	for ( i = 0; i < ptd->nInterval; i++ )
      615:  549:		if ( ! failflag[ i ] )
      615:  550:			ptd->interval[ nInterval2++ ] = ptd->interval[ i ];
      486:  551:	ptd->nInterval = nInterval2;
      486:  552:}
        -:  553:
      486:  554:static void LoadChar( ChewingData *pgdata, char *buf, int buf_len, const uint16_t phoneSeq[], int nPhoneSeq )
        -:  555:{
        -:  556:	int i;
        -:  557:	Phrase word;
        -:  558:
      486:  559:	memset(buf, 0, buf_len);
     1286:  560:	for ( i = 0; i < nPhoneSeq; i++ ) {
      800:  561:		GetCharFirst( pgdata, &word, phoneSeq[ i ] );
      800:  562:		strncat(buf, word.phrase, buf_len - strlen(buf) - 1);
        -:  563:	}
      486:  564:	buf[ buf_len - 1 ] = '\0';
      486:  565:}
        -:  566:
        -:  567:/* kpchen said, record is the index array of interval */
      486:  568:static void OutputRecordStr( ChewingData *pgdata, const TreeDataType *ptd )
        -:  569:{
        -:  570:	PhraseIntervalType inter;
        -:  571:	int i;
        -:  572:
      486:  573:	LoadChar( pgdata, pgdata->phrOut.chiBuf, ARRAY_SIZE( pgdata->phrOut.chiBuf ), pgdata->phoneSeq, pgdata->nPhoneSeq );
     1077:  574:	for ( i = 0; i < ptd->phList->nInter; i++ ) {
      591:  575:		inter = ptd->interval[ ptd->phList->arrIndex[ i ] ];
      591:  576:		ueStrNCpy(
      591:  577:				ueStrSeek( pgdata->phrOut.chiBuf, inter.from ),
      591:  578:				( inter.p_phr )->phrase,
      591:  579:				( inter.to - inter.from ), -1);
        -:  580:	}
      505:  581:	for ( i = 0; i < pgdata->nSelect; i++ ) {
       19:  582:		inter.from = pgdata->selectInterval[ i ].from;
       19:  583:		inter.to = pgdata->selectInterval[ i ].to ;
       19:  584:		ueStrNCpy(
       19:  585:				ueStrSeek( pgdata->phrOut.chiBuf, inter.from ),
       19:  586:				pgdata->selectStr[ i ], ( inter.to - inter.from ), -1);
        -:  587:	}
      486:  588:}
        -:  589:
     1206:  590:static int rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )
        -:  591:{
     1206:  592:	int i, score = 0;
        -:  593:	PhraseIntervalType inter;
        -:  594:
     3824:  595:	for ( i = 0; i < nRecord; i++ ) {
     2618:  596:		inter = ptd->interval[ record[ i ] ];
    2618*:  597:		assert( inter.p_phr );
     2618:  598:		score += inter.to - inter.from;
        -:  599:	}
     1206:  600:	return score;
        -:  601:}
        -:  602:
      603:  603:static int rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )
        -:  604:{
        -:  605:	/* constant factor 6=1*2*3, to keep value as integer */
      603:  606:	return 6 * rule_largest_sum( record, nRecord, ptd ) / nRecord;
        -:  607:}
        -:  608:
      603:  609:static int rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )
        -:  610:{
      603:  611:	int i, j, score = 0;
        -:  612:	PhraseIntervalType inter1, inter2;
        -:  613:
        -:  614:	/* kcwu: heuristic? why variance no square function? */
     1912:  615:	for ( i = 0; i < nRecord; i++ ) {
     2935:  616:		for ( j = i + 1; j < nRecord; j++ ) {
     1626:  617:			inter1 = ptd->interval[ record[ i ] ];
     1626:  618:			inter2 = ptd->interval[ record[ j ] ];
    1626*:  619:			assert( inter1.p_phr && inter2.p_phr );
     1626:  620:			score += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));
        -:  621:		}
        -:  622:	}
      603:  623:	return -score;
        -:  624:}
        -:  625:
      603:  626:static int rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )
        -:  627:{
      603:  628:	int i, score = 0;
        -:  629:	PhraseIntervalType inter;
        -:  630:
     1912:  631:	for ( i = 0; i < nRecord; i++ ) {
     1309:  632:		inter = ptd->interval[ record[ i ] ];
    1309*:  633:		assert( inter.p_phr );
        -:  634:
        -:  635:		/* We adjust the 'freq' of One-word Phrase */
     1309:  636:		score += ( inter.to - inter.from == 1 ) ?
     1309:  637:			( inter.p_phr->freq / 512 ) :
      273:  638:			inter.p_phr->freq;
        -:  639:	}
      603:  640:	return score;
        -:  641:}
        -:  642:
      603:  643:static int LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )
        -:  644:{
      603:  645:	int total_score = 0;
        -:  646:	/* NOTE: the balance factor is tuneable */
      603:  647:	if (nRecord) {
      603:  648:		total_score += 1000*rule_largest_sum( record, nRecord, ptd );
      603:  649:		total_score += 1000*rule_largest_avgwordlen( record, nRecord, ptd );
      603:  650:		total_score += 100*rule_smallest_lenvariance( record, nRecord, ptd );
      603:  651:		total_score += rule_largest_freqsum( record, nRecord, ptd );
        -:  652:	}
      603:  653:	return total_score;
        -:  654:}
        -:  655:
       36:  656:static int IsRecContain( const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd )
        -:  657:{
        -:  658:	int big, sml;
        -:  659:
       84:  660:	for ( big = 0, sml = 0; sml < nB; sml++ ) {
      154:  661:		while (
      138:  662:			( big < nA ) &&
      138:  663:			ptd->interval[ intA[ big ] ].from <
      138:  664:				ptd->interval[ intB[ sml ] ].to ) {
      126:  665:			if ( PhraseIntervalContain(
      126:  666:				ptd->interval[ intA[ big ] ],
      126:  667:				ptd->interval[ intB[ sml ] ] ) )
       48:  668:				break;
       78:  669:			big++;
        -:  670:		}
       76:  671:		if (
       60:  672:			( big >= nA ) ||
       60:  673:			ptd->interval[ intA[ big ] ].from >=
       60:  674:				ptd->interval[ intB[ sml ] ].to )
       28:  675:			return 0;
        -:  676:	}
        8:  677:	return 1;
        -:  678:}
        -:  679:
        2:  680:static void SortListByScore( TreeDataType *ptd )
        -:  681:{
        -:  682:	int i, listLen;
        -:  683:	RecordNode *p, **arr;
        -:  684:
        6:  685:	for (
        2:  686:		listLen = 0, p = ptd->phList;
        -:  687:		p;
        4:  688:		listLen++, p = p->next )
        -:  689:		;
        2:  690:	ptd->nPhListLen = listLen;
        -:  691:
        2:  692:	arr = ALC( RecordNode *, listLen );
       2*:  693:	assert( arr );
        -:  694:
        6:  695:	for (
        2:  696:		i = 0, p = ptd->phList;
        -:  697:		i < listLen;
        4:  698:		p = p->next, i++ ) {
        4:  699:		arr[ i ] = p;
        4:  700:		p->score = LoadPhraseAndCountScore(
        4:  701:			p->arrIndex,
        -:  702:			p->nInter,
        -:  703:			ptd );
        -:  704:	}
        -:  705:
        2:  706:	qsort( arr, listLen, sizeof( RecordNode * ), (CompFuncType) CompRecord );
        -:  707:
        2:  708:	ptd->phList = arr[ 0 ];
        4:  709:	for ( i = 1; i < listLen; i++ ) {
        2:  710:		arr[ i - 1 ]->next = arr[ i ];
        -:  711:	}
        2:  712:	arr[ listLen - 1 ]->next = NULL;
        -:  713:
        2:  714:	free( arr );
        2:  715:}
        -:  716:
        -:  717:/* when record==NULL then output the "link list" */
       12:  718:static void SaveRecord( const int *record, int nInter, TreeDataType *ptd )
        -:  719:{
        -:  720:	RecordNode *now, *p, *pre;
        -:  721:
       12:  722:	pre = NULL;
       30:  723:	for ( p = ptd->phList; p; ) {
        -:  724:		/* if  'p' contains 'record', then discard 'record'. */
       18:  725:		if ( IsRecContain( p->arrIndex, p->nInter, record, nInter, ptd ) )
    #####:  726:			return;
        -:  727:
        -:  728:		/* if 'record' contains 'p', then discard 'p'
        -:  729:		 * -- We must deal with the linked list. */
       18:  730:		if ( IsRecContain( record, nInter, p->arrIndex, p->nInter, ptd ) ) {
        8:  731:			RecordNode *tp = p;
        -:  732:
        8:  733:			if ( pre )
        4:  734:				pre->next = p->next;
        -:  735:			else
        4:  736:				ptd->phList = ptd->phList->next;
        8:  737:			p = p->next;
        8:  738:			free( tp->arrIndex );
        8:  739:			free( tp );
        -:  740:		}
        -:  741:		else
       10:  742:			pre = p, p = p->next;
        -:  743:	}
       12:  744:	now = ALC( RecordNode, 1 );
      12*:  745:	assert( now );
       12:  746:	now->next = ptd->phList;
       12:  747:	now->arrIndex = ALC( int, nInter );
      12*:  748:	assert( now->arrIndex );
       12:  749:	now->nInter = nInter;
       12:  750:	memcpy( now->arrIndex, record, nInter * sizeof( int ) );
       12:  751:	ptd->phList = now;
        -:  752:}
        -:  753:
       28:  754:static void RecursiveSave( int depth, int to, int *record, TreeDataType *ptd )
        -:  755:{
        -:  756:	int first, i;
        -:  757:	/* to find first interval */
       88:  758:	for (
       28:  759:		first = record[ depth - 1 ] + 1;
       60:  760:		ptd->interval[ first ].from < to && first < ptd->nInterval;
       32:  761:		first++ )
        -:  762:		;
        -:  763:
       28:  764:	if ( first == ptd->nInterval ) {
       12:  765:		SaveRecord( record + 1, depth - 1, ptd );
       12:  766:		return;
        -:  767:	}
       16:  768:	record[ depth ] = first;
       16:  769:	RecursiveSave( depth + 1, ptd->interval[ first ].to, record, ptd );
        -:  770:	/* for each interval which intersects first */
       26:  771:	for (
       16:  772:		i= first + 1;
       26:  773:		PhraseIntervalIntersect(
        -:  774:			ptd->interval[ first ],
       10:  775:			ptd->interval[ i ] ) && i < ptd->nInterval;
       10:  776:			i++ ) {
       10:  777:		record[ depth ] = i;
       10:  778:		RecursiveSave( depth + 1, ptd->interval[ i ].to,record, ptd );
        -:  779:	}
        -:  780:}
        -:  781:
        2:  782:static void SaveList( TreeDataType *ptd )
        -:  783:{
        2:  784:	int record[ MAX_PHONE_SEQ_LEN + 1 ] = { -1 };
        -:  785:
        2:  786:	RecursiveSave( 1, 0, record, ptd );
        2:  787:}
        -:  788:
      486:  789:static void InitPhrasing( TreeDataType *ptd )
        -:  790:{
      486:  791:	memset( ptd, 0, sizeof( TreeDataType ) );
      486:  792:}
        -:  793:
      486:  794:static void SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )
        -:  795:{
        -:  796:	int i;
        -:  797:
     1077:  798:	for ( i = 0; i < ptd->phList->nInter; i++ ) {
      591:  799:		ppo->dispInterval[ i ].from =
      591:  800:			ptd->interval[ ptd->phList->arrIndex[ i ] ].from;
      591:  801:		ppo->dispInterval[ i ].to =
      591:  802:			ptd->interval[ ptd->phList->arrIndex[ i ] ].to;
        -:  803:	}
      486:  804:	ppo->nDispInterval = ptd->phList->nInter;
      486:  805:}
        -:  806:
      486:  807:static void CleanUpMem( TreeDataType *ptd )
        -:  808:{
        -:  809:	int i;
        -:  810:	RecordNode *pNode;
        -:  811:
     1101:  812:	for ( i = 0; i < ptd->nInterval; i++ ) {
      615:  813:		if ( ptd->interval[ i ].p_phr ) {
      615:  814:			free( ptd->interval[ i ].p_phr );
      615:  815:			ptd->interval[ i ].p_phr = NULL;
        -:  816:		}
        -:  817:	}
      974:  818:	while ( ptd->phList != NULL ) {
      488:  819:		pNode = ptd->phList;
      488:  820:		ptd->phList = pNode->next;
      488:  821:		free( pNode->arrIndex );
      488:  822:		free( pNode );
        -:  823:	}
      486:  824:}
        -:  825:
        2:  826:static void CountMatchCnnct( TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq )
        -:  827:{
        -:  828:	RecordNode *p;
        -:  829:	int i, k, sum;
        -:  830:
        6:  831:	for ( p = ptd->phList; p; p = p->next ) {
        -:  832:		/* for each record, count its 'nMatchCnnct' */
       16:  833:		for ( sum = 0, i = 1; i < nPhoneSeq; i++ ) {
       12:  834:			if ( !bUserArrCnnct[ i ] )
       12:  835:				continue;
        -:  836:			/* check if matching 'cnnct' */
    #####:  837:			for ( k = 0; k < p->nInter; k++ ) {
    #####:  838:				if (
    #####:  839:					ptd->interval[ p->arrIndex[ k ] ].from < i &&
    #####:  840:					ptd->interval[ p->arrIndex[ k ] ].to > i ) {
    #####:  841:					sum++;
    #####:  842:					break;
        -:  843:				}
        -:  844:			}
        -:  845:		}
        4:  846:		p->nMatchCnnct = sum;
        -:  847:	}
        2:  848:}
        -:  849:
      486:  850:static void ShowList( ChewingData *pgdata, const TreeDataType *ptd )
        -:  851:{
        -:  852:	const RecordNode *p;
        -:  853:	int i;
        -:  854:
      486:  855:	DEBUG_OUT( "After SaveList :\n" );
      974:  856:	for ( p = ptd->phList; p; p = p->next ) {
      488:  857:		DEBUG_OUT( "  interval : " );
     1083:  858:		for ( i = 0; i < p->nInter; i++ ) {
      595:  859:			DEBUG_OUT(
        -:  860:				"[%d %d] ",
        -:  861:				ptd->interval[ p->arrIndex[ i ] ].from,
        -:  862:				ptd->interval[ p->arrIndex[ i ] ].to );
        -:  863:		}
      488:  864:		DEBUG_OUT(
        -:  865:			"\n"
        -:  866:			   "      score : %d , nMatchCnnct : %d\n",
        -:  867:			p->score,
        -:  868:			p->nMatchCnnct );
        -:  869:	}
      486:  870:	DEBUG_OUT( "\n" );
      486:  871:}
        -:  872:
        2:  873:static RecordNode* NextCut( TreeDataType *tdt, PhrasingOutput *ppo )
        -:  874:{
        -:  875:	/* pop nNumCut-th candidate to first */
        -:  876:	int i;
        -:  877:	RecordNode *former;
        -:  878:	RecordNode *want;
        -:  879:
        2:  880:	if ( ppo->nNumCut >= tdt->nPhListLen )
        1:  881:		ppo->nNumCut = 0;
        2:  882:	if (ppo->nNumCut == 0)
        1:  883:		return tdt->phList;
        -:  884:
        -:  885:	/* find the former of our candidate */
        1:  886:	former = tdt->phList;
       1*:  887:	for ( i = 0; i < ppo->nNumCut - 1; i++ ) {
    #####:  888:		former = former->next;
    #####:  889:		assert( former );
        -:  890:	}
        -:  891:
        -:  892:	/* take the candidate out of the listed list */
        1:  893:	want = former->next;
       1*:  894:	assert( want );
        1:  895:	former->next = former->next->next;
        -:  896:
        -:  897:	/* prepend to front of list */
        1:  898:	want->next = tdt->phList;
        1:  899:	tdt->phList = want;
        -:  900:
        1:  901:	return tdt->phList;
        -:  902:}
        -:  903:
      380:  904:static int SortByIncreaseEnd( const void *x, const void *y)
        -:  905:{
      380:  906:	const PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;
      380:  907:	const PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;
        -:  908:
      380:  909:	if ( interval_x->to < interval_y->to )
      370:  910:		return -1;
        -:  911:
       10:  912:	if ( interval_x->to > interval_y->to )
        2:  913:		return 1;
        -:  914:
        8:  915:	return 0;
        -:  916:}
        -:  917:
      278:  918:static RecordNode * DuplicateRecordAndInsertInterval(
        -:  919:	const RecordNode *record,
        -:  920:	TreeDataType *pdt,
        -:  921:	const int interval_id )
        -:  922:{
      278:  923:	RecordNode *ret = NULL;
        -:  924:
     278*:  925:	assert( record );
     278*:  926:	assert( pdt );
        -:  927:
      278:  928:	ret = ALC( RecordNode, 1 );
      278:  929:	if ( !ret )
    #####:  930:		return NULL;
        -:  931:
      278:  932:	ret->arrIndex = ALC( int, record->nInter + 1 );
      278:  933:	if ( !ret->arrIndex ) {
    #####:  934:		free( ret );
    #####:  935:		return NULL;
        -:  936:	}
      278:  937:	ret->nInter = record->nInter + 1;
      278:  938:	memcpy( ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter );
        -:  939:
      278:  940:	ret->arrIndex[ ret->nInter - 1 ] = interval_id;
        -:  941:
      278:  942:	ret->score = LoadPhraseAndCountScore( ret->arrIndex, ret->nInter, pdt );
        -:  943:
      278:  944:	return ret;
        -:  945:}
        -:  946:
      321:  947:static RecordNode * CreateSingleIntervalRecord( TreeDataType *pdt, const int interval_id )
        -:  948:{
      321:  949:	RecordNode *ret = NULL;
        -:  950:
     321*:  951:	assert( pdt );
        -:  952:
      321:  953:	ret = ALC( RecordNode, 1 );
      321:  954:	if ( !ret )
    #####:  955:		return NULL;
        -:  956:
      321:  957:	ret->arrIndex = ALC( int, 1 );
      321:  958:	if ( !ret->arrIndex ) {
    #####:  959:		free( ret );
    #####:  960:		return NULL;
        -:  961:	}
        -:  962:
      321:  963:	ret->nInter = 1;
      321:  964:	ret->arrIndex[0] = interval_id;
        -:  965:
      321:  966:	ret->score = LoadPhraseAndCountScore( ret->arrIndex, ret->nInter, pdt );
        -:  967:
      321:  968:	return ret;
        -:  969:}
        -:  970:
      167:  971:static RecordNode * CreateNullIntervalRecord()
        -:  972:{
      167:  973:	RecordNode *ret = NULL;
      167:  974:	ret = ALC( RecordNode, 1 );
      167:  975:	if ( !ret )
    #####:  976:		return NULL;
        -:  977:
      167:  978:	ret->arrIndex = ALC( int, 1 );
      167:  979:	if ( !ret->arrIndex ) {
    #####:  980:		free( ret );
    #####:  981:		return NULL;
        -:  982:	}
        -:  983:
      167:  984:	ret->nInter = 0;
      167:  985:	ret->score = 0;
        -:  986:
      167:  987:	return ret;
        -:  988:}
        -:  989:
     1074:  990:static void FreeRecord( RecordNode *node )
        -:  991:{
     1074:  992:	if ( node ) {
      282:  993:		free( node->arrIndex );
      282:  994:		free( node );
        -:  995:	}
     1074:  996:}
        -:  997:
      484:  998:static void DoDpPhrasing( ChewingData *pgdata, TreeDataType *pdt )
        -:  999:{
      484: 1000:	RecordNode *highest_score[ MAX_PHONE_SEQ_LEN ] = { 0 };
        -: 1001:	RecordNode *tmp;
        -: 1002:	int prev_end;
        -: 1003:	int end;
        -: 1004:	int interval_id;
        -: 1005:
     484*: 1006:	assert( pgdata );
     484*: 1007:	assert( pdt );
        -: 1008:
        -: 1009:	/*
        -: 1010:	 * Assume P(x,y) is the highest score phrasing result from x to y. The
        -: 1011:	 * following is formula for P(x,y):
        -: 1012:	 *
        -: 1013:	 * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )
        -: 1014:	 *
        -: 1015:	 * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is
        -: 1016:	 * interval end at y. In this formula, x is always 0.
        -: 1017:	 *
        -: 1018:	 * The format of highest_score array is described as following:
        -: 1019:	 *
        -: 1020:	 * highest_score[0] = P(0,0)
        -: 1021:	 * highest_score[1] = P(0,1)
        -: 1022:	 * ...
        -: 1023:	 * highest_score[y-1] = P(0,y-1)
        -: 1024:	 */
        -: 1025:
        -: 1026:	/* The interval shall be sorted by the increase order of end. */
      484: 1027:	qsort( pdt->interval, pdt->nInterval, sizeof( pdt->interval[0] ), SortByIncreaseEnd );
        -: 1028:
     1083: 1029:	for ( interval_id = 0; interval_id < pdt->nInterval; ++interval_id ) {
        -: 1030:		/*
        -: 1031:		 * XXX: pdt->interval.to is excluding, while end is
        -: 1032:		 * including, so we need to minus one here.
        -: 1033:		 */
      599: 1034:		end = pdt->interval[interval_id].to - 1;
        -: 1035:
      599: 1036:		prev_end = pdt->interval[interval_id].from - 1;
        -: 1037:
      599: 1038:		if ( prev_end >= 0 )
      278: 1039:			tmp = DuplicateRecordAndInsertInterval(
      278: 1040:				highest_score[ prev_end ],
        -: 1041:				pdt,
        -: 1042:				interval_id );
        -: 1043:		else
      321: 1044:			tmp = CreateSingleIntervalRecord( pdt, interval_id );
        -: 1045:
        -: 1046:		/* FIXME: shall exit immediately? */
      599: 1047:		if (!tmp)
    #####: 1048:			continue;
        -: 1049:
      599: 1050:		if ( highest_score[end] == NULL || highest_score[end]->score < tmp->score ) {
      593: 1051:			FreeRecord( highest_score[end] );
      593: 1052:			highest_score[end] = tmp;
        -: 1053:		} else
        6: 1054:			FreeRecord( tmp );
        -: 1055:	}
        -: 1056:
      484: 1057:	if ( pgdata->nPhoneSeq - 1 < 0 || highest_score[ pgdata->nPhoneSeq - 1 ] == NULL ) {
      167: 1058:		pdt->phList = CreateNullIntervalRecord();
        -: 1059:	} else {
      317: 1060:		pdt->phList = highest_score[ pgdata->nPhoneSeq - 1 ];
        -: 1061:	}
      484: 1062:	pdt->nPhListLen = 1;
        -: 1063:
      959: 1064:	for ( end = 0; end < pgdata->nPhoneSeq - 1; ++end )
      475: 1065:		FreeRecord( highest_score[end] );
      484: 1066:}
        -: 1067:
      486: 1068:int Phrasing( ChewingData *pgdata, int all_phrasing )
        -: 1069:{
        -: 1070:	TreeDataType treeData;
        -: 1071:
      486: 1072:	InitPhrasing( &treeData );
        -: 1073:
      486: 1074:	FindInterval( pgdata, &treeData );
      486: 1075:	SetInfo( pgdata->nPhoneSeq, &treeData );
      486: 1076:	Discard1( &treeData );
      486: 1077:	Discard2( &treeData );
      486: 1078:	if ( all_phrasing ) {
        2: 1079:		SaveList( &treeData );
        2: 1080:		CountMatchCnnct( &treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq );
        2: 1081:		SortListByScore( &treeData );
        2: 1082:		NextCut( &treeData, &pgdata->phrOut );
        -: 1083:	} else {
      484: 1084:		DoDpPhrasing( pgdata, &treeData );
        -: 1085:	}
        -: 1086:
      486: 1087:	ShowList( pgdata, &treeData );
        -: 1088:
        -: 1089:	/* set phrasing output */
      486: 1090:	OutputRecordStr( pgdata, &treeData );
      486: 1091:	SaveDispInterval( &pgdata->phrOut, &treeData );
        -: 1092:
        -: 1093:	/* free "phrase" */
      486: 1094:	CleanUpMem( &treeData );
      486: 1095:	return 0;
        -: 1096:}
