        -:    0:Source:/home/workspace/src/chewingio.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/chewingio.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/chewingio.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * chewingio.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004-2008, 2010, 2011, 2012
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: * @file chewingio.c
        -:   17: * @brief Implement basic I/O routines for Chewing manipulation.
        -:   18: */
        -:   19:
        -:   20:#include <assert.h>
        -:   21:#include <string.h>
        -:   22:#include <ctype.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <stdio.h>
        -:   25:
        -:   26:#include "chewing-utf8-util.h"
        -:   27:#include "global.h"
        -:   28:#include "zuin-private.h"
        -:   29:#include "chewingutil.h"
        -:   30:#include "userphrase-private.h"
        -:   31:#include "choice-private.h"
        -:   32:#include "dict-private.h"
        -:   33:#include "hash-private.h"
        -:   34:#include "tree-private.h"
        -:   35:#include "pinyin-private.h"
        -:   36:#include "private.h"
        -:   37:#include "chewingio.h"
        -:   38:#include "mod_aux.h"
        -:   39:#include "global-private.h"
        -:   40:#include "plat_path.h"
        -:   41:#include "chewing-private.h"
        -:   42:
        -:   43:const char * const kb_type_str[] = {
        -:   44:	"KB_DEFAULT",
        -:   45:	"KB_HSU",
        -:   46:	"KB_IBM",
        -:   47:	"KB_GIN_YIEH",
        -:   48:	"KB_ET",
        -:   49:	"KB_ET26",
        -:   50:	"KB_DVORAK",
        -:   51:	"KB_DVORAK_HSU",
        -:   52:	"KB_DACHEN_CP26",
        -:   53:	"KB_HANYU_PINYIN",
        -:   54:	"KB_THL_PINYIN",
        -:   55:	"KB_MPS2_PINYIN"
        -:   56:};
        -:   57:
        -:   58:const char * const DICT_FILES[] = {
        -:   59:	DICT_FILE,
        -:   60:	PHONE_TREE_FILE,
        -:   61:	NULL,
        -:   62:};
        -:   63:
        -:   64:const char * const SYMBOL_TABLE_FILES[] = {
        -:   65:	SYMBOL_TABLE_FILE,
        -:   66:	NULL,
        -:   67:};
        -:   68:
        -:   69:const char * const EASY_SYMBOL_FILES[] = {
        -:   70:	SOFTKBD_TABLE_FILE,
        -:   71:	NULL,
        -:   72:};
        -:   73:
        -:   74:const char * const PINYIN_FILES[] = {
        -:   75:	PINYIN_TAB_NAME,
        -:   76:	NULL,
        -:   77:};
        -:   78:
    #####:   79:CHEWING_API int chewing_KBStr2Num( char str[] )
        -:   80:{
        -:   81:	int i;
        -:   82:
        -:   83:	STATIC_ASSERT( KB_TYPE_NUM == ARRAY_SIZE( kb_type_str ), kb_type_str_needs_update);
    #####:   84:	for ( i = 0; i < KB_TYPE_NUM; i++) {
    #####:   85:		if ( ! strcmp( str, kb_type_str[ i ] ) )
    #####:   86:			return i;
        -:   87:	}
    #####:   88:	return KB_DEFAULT;
        -:   89:}
        -:   90:
       39:   91:static void chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )
        -:   92:{
       39:   93:	ChewingData *pgdata = ctx->data;
       39:   94:	if ( toSelect ) {
       34:   95:		if ( ! pgdata->bSelect ) {
       27:   96:			ChoiceFirstAvail( pgdata );
        -:   97:		} else {
        7:   98:			if ( pgdata->config.bPhraseChoiceRearward ) {
        6:   99:				int avail_willbe = (pgdata->availInfo.currentAvail > 0) ?
        3:  100:					pgdata->availInfo.currentAvail - 1 :
        1:  101:					pgdata->availInfo.nAvail - 1;
        3:  102:				pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor -
        3:  103:					pgdata->availInfo.avail[ avail_willbe ].len;
        3:  104:				if ( chewing_buffer_Len( ctx ) >
        3:  105:						pgdata->choiceInfo.oldChiSymbolCursor ) {
    #####:  106:					pgdata->chiSymbolCursor++;
        -:  107:				}
        -:  108:			}
        7:  109:			ChoiceNextAvail( pgdata );
        -:  110:		}
        5:  111:	} else if ( pgdata->symbolKeyBuf[ key_buf_cursor ] ) {
        -:  112:		/* Open Symbol Choice List */
        4:  113:		if ( pgdata->choiceInfo.isSymbol == WORD_CHOICE )
        4:  114:			OpenSymbolChoice( pgdata );
        -:  115:	}
       39:  116:}
        -:  117:
   553012:  118:static void NullLogger( void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)
        -:  119:{
   553012:  120:}
        -:  121:
       33:  122:static ChewingData * allocate_ChewingData()
        -:  123:{
        -:  124:	static const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };
        -:  125:
       33:  126:	ChewingData *data = ALC( ChewingData, 1 );
       33:  127:	if ( data ) {
       33:  128:		data->config.candPerPage = MAX_SELKEY;
       33:  129:		data->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;
       33:  130:		data->logger = NullLogger;
       33:  131:		memcpy( data->config.selKey, DEFAULT_SELKEY, sizeof( data->config.selKey ) );
        -:  132:	}
        -:  133:
       33:  134:	return data;
        -:  135:}
        -:  136:
       33:  137:CHEWING_API ChewingContext *chewing_new()
        -:  138:{
        -:  139:	ChewingContext *ctx;
        -:  140:	int ret;
        -:  141:	char search_path[PATH_MAX];
        -:  142:	char path[PATH_MAX];
        -:  143:
       33:  144:	ctx = ALC( ChewingContext, 1 );
       33:  145:	if ( !ctx )
    #####:  146:		goto error;
        -:  147:
       33:  148:	ctx->output = ALC ( ChewingOutput, 1 );
       33:  149:	if ( !ctx->output )
    #####:  150:		goto error;
        -:  151:
       33:  152:	ctx->data = allocate_ChewingData();
       33:  153:	if ( !ctx->data )
    #####:  154:		goto error;
        -:  155:
       33:  156:	chewing_Reset( ctx );
        -:  157:
       33:  158:	ret = get_search_path( search_path, sizeof( search_path ) );
       33:  159:	if ( ret )
    #####:  160:		goto error;
        -:  161:
       33:  162:	ret = find_path_by_files(
        -:  163:		search_path, DICT_FILES, path, sizeof( path ) );
       33:  164:	if ( ret )
    #####:  165:		goto error;
       33:  166:	ret = InitDict( ctx->data, path );
       33:  167:	if ( ret )
    #####:  168:		goto error;
       33:  169:	ret = InitTree( ctx->data, path );
       33:  170:	if ( ret )
    #####:  171:		goto error;
        -:  172:
       33:  173:	ret = InitHash( ctx->data );
       33:  174:	if ( !ret )
    #####:  175:		goto error;
        -:  176:
       33:  177:	ctx->cand_no = 0;
        -:  178:
       33:  179:	ret = find_path_by_files(
        -:  180:		search_path, SYMBOL_TABLE_FILES, path, sizeof( path ) );
       33:  181:	if ( ret )
    #####:  182:		goto error;
       33:  183:	ret = InitSymbolTable( ctx->data, path );
       33:  184:	if ( ret )
    #####:  185:		goto error;
        -:  186:
       33:  187:	ret = find_path_by_files(
        -:  188:		search_path, EASY_SYMBOL_FILES, path, sizeof( path ) );
       33:  189:	if ( ret )
    #####:  190:		goto error;
       33:  191:	ret = InitEasySymbolInput( ctx->data, path );
       33:  192:	if ( ret )
    #####:  193:		goto error;
        -:  194:
       33:  195:	ret = find_path_by_files(
        -:  196:		search_path, PINYIN_FILES, path, sizeof( path ) );
       33:  197:	if ( ret )
    #####:  198:		goto error;
       33:  199:	ret = InitPinyin( ctx->data, path );
       33:  200:	if ( !ret )
    #####:  201:		goto error;
        -:  202:
       33:  203:	return ctx;
    #####:  204:error:
    #####:  205:	chewing_delete( ctx );
    #####:  206:	return NULL;
        -:  207:}
        -:  208:
    #####:  209:CHEWING_API int chewing_Init(
        -:  210:		const char *dataPath UNUSED,
        -:  211:		const char *hashPath UNUSED)
        -:  212:{
    #####:  213:	return 0;
        -:  214:}
        -:  215:
       36:  216:CHEWING_API int chewing_Reset( ChewingContext *ctx )
        -:  217:{
       36:  218:	ChewingData *pgdata = ctx->data;
        -:  219:	ChewingStaticData static_data;
        -:  220:	ChewingConfigData old_config;
        -:  221:	void (*logger)( void *data, int level, const char *fmt, ...);
        -:  222:
        -:  223:	/* Backup old config and restore it after clearing pgdata structure. */
       36:  224:	old_config = pgdata->config;
       36:  225:	static_data = pgdata->static_data;
       36:  226:	logger = pgdata->logger;
       36:  227:	memset( pgdata, 0, sizeof( ChewingData ) );
       36:  228:	pgdata->config = old_config;
       36:  229:	pgdata->static_data = static_data;
       36:  230:	pgdata->logger = logger;
        -:  231:
        -:  232:	/* zuinData */
       36:  233:	memset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );
        -:  234:
        -:  235:	/* choiceInfo */
       36:  236:	memset( &( pgdata->choiceInfo ), 0, sizeof( ChoiceInfo ) );
        -:  237:
       36:  238:	pgdata->chiSymbolCursor = 0;
       36:  239:	pgdata->chiSymbolBufLen = 0;
       36:  240:	pgdata->nPhoneSeq = 0;
       36:  241:	memset( pgdata->bUserArrCnnct, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );
       36:  242:	memset( pgdata->bUserArrBrkpt, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );
       36:  243:	pgdata->bChiSym = CHINESE_MODE;
       36:  244:	pgdata->bFullShape = HALFSHAPE_MODE;
       36:  245:	pgdata->bSelect = 0;
       36:  246:	pgdata->nSelect = 0;
       36:  247:	pgdata->PointStart = -1;
       36:  248:	pgdata->PointEnd = 0;
       36:  249:	pgdata->phrOut.nNumCut = 0;
       36:  250:	return 0;
        -:  251:}
        -:  252:
    #####:  253:CHEWING_API int chewing_set_KBType( ChewingContext *ctx, int kbtype )
        -:  254:{
    #####:  255:	if ( kbtype < KB_TYPE_NUM && kbtype >= 0  ) {
    #####:  256:		ctx->data->zuinData.kbtype = kbtype;
    #####:  257:		return 0;
        -:  258:	} else {
    #####:  259:		ctx->data->zuinData.kbtype = KB_DEFAULT;
    #####:  260:		return -1;
        -:  261:	}
        -:  262:}
        -:  263:
    #####:  264:CHEWING_API int chewing_get_KBType( ChewingContext *ctx )
        -:  265:{
    #####:  266:	return ctx->data->zuinData.kbtype;
        -:  267:}
        -:  268:
    #####:  269:CHEWING_API char* chewing_get_KBString( ChewingContext *ctx )
        -:  270:{
    #####:  271:	return strdup( kb_type_str[ ctx->data->zuinData.kbtype ] );
        -:  272:}
        -:  273:
    #####:  274:CHEWING_API void chewing_Terminate()
        -:  275:{
    #####:  276:}
        -:  277:
       33:  278:CHEWING_API void chewing_delete( ChewingContext *ctx )
        -:  279:{
       33:  280:	if ( ctx ) {
       33:  281:		if ( ctx->data ) {
       33:  282:			TerminatePinyin( ctx->data );
       33:  283:			TerminateEasySymbolTable( ctx->data );
       33:  284:			TerminateSymbolTable( ctx->data );
       33:  285:			TerminateHash( ctx->data );
       33:  286:			TerminateTree( ctx->data );
       33:  287:			TerminateDict( ctx->data );
       33:  288:			free( ctx->data );
        -:  289:		}
        -:  290:
       33:  291:		if ( ctx->output )
       33:  292:			free( ctx->output);
       33:  293:		free( ctx );
        -:  294:	}
       33:  295:	return;
        -:  296:}
        -:  297:
       83:  298:CHEWING_API void chewing_free( void *p )
        -:  299:{
       83:  300:	if ( p )
       83:  301:		free( p );
       83:  302:	return;
        -:  303:}
        -:  304:
    #####:  305:CHEWING_API int chewing_Configure( ChewingContext *ctx, ChewingConfigData *pcd )
        -:  306:{
    #####:  307:	chewing_set_candPerPage( ctx, pcd->candPerPage );
    #####:  308:	chewing_set_maxChiSymbolLen( ctx, pcd->maxChiSymbolLen );
    #####:  309:	chewing_set_selKey( ctx, pcd->selKey, MAX_SELKEY );
    #####:  310:	chewing_set_addPhraseDirection( ctx, pcd->bAddPhraseForward );
    #####:  311:	chewing_set_spaceAsSelection( ctx, pcd->bSpaceAsSelection );
    #####:  312:	chewing_set_escCleanAllBuf( ctx, pcd->bEscCleanAllBuf );
    #####:  313:	chewing_set_autoShiftCur( ctx, pcd->bAutoShiftCur );
    #####:  314:	chewing_set_easySymbolInput( ctx, pcd->bEasySymbolInput );
    #####:  315:	chewing_set_phraseChoiceRearward( ctx, pcd->bPhraseChoiceRearward );
        -:  316:
    #####:  317:	return 0;
        -:  318:}
        -:  319:
    #####:  320:CHEWING_API void chewing_set_candPerPage( ChewingContext *ctx, int n )
        -:  321:{
    #####:  322:	if ( MIN_SELKEY <= n && n <= MAX_SELKEY )
    #####:  323:		ctx->data->config.candPerPage = n;
    #####:  324:}
        -:  325:
    #####:  326:CHEWING_API int chewing_get_candPerPage( ChewingContext *ctx )
        -:  327:{
    #####:  328:	return ctx->data->config.candPerPage;
        -:  329:}
        -:  330:
       14:  331:CHEWING_API void chewing_set_maxChiSymbolLen( ChewingContext *ctx, int n )
        -:  332:{
       14:  333:	if ( MIN_CHI_SYMBOL_LEN <= n && n <= MAX_CHI_SYMBOL_LEN )
       14:  334:		ctx->data->config.maxChiSymbolLen = n;
       14:  335:}
        -:  336:
    #####:  337:CHEWING_API int chewing_get_maxChiSymbolLen( ChewingContext *ctx )
        -:  338:{
    #####:  339:	return ctx->data->config.maxChiSymbolLen;
        -:  340:}
        -:  341:
    #####:  342:CHEWING_API void chewing_set_selKey( ChewingContext *ctx, int *selkeys,
        -:  343:                                     int len UNUSED)
        -:  344:{
    #####:  345:	memcpy(
    #####:  346:		ctx->data->config.selKey,
        -:  347:		selkeys,
        -:  348:		sizeof( selkeys[ 0 ] ) * MAX_SELKEY );
    #####:  349:}
        -:  350:
    #####:  351:CHEWING_API int* chewing_get_selKey( ChewingContext *ctx )
        -:  352:{
    #####:  353:	int *selkeys = ALC( int , MAX_SELKEY );
    #####:  354:	if ( selkeys ) {
    #####:  355:		memcpy( selkeys, ctx->data->config.selKey,
        -:  356:			sizeof( *selkeys ) * MAX_SELKEY );
        -:  357:	}
    #####:  358:	return selkeys;
        -:  359:}
        -:  360:
    #####:  361:CHEWING_API void chewing_set_addPhraseDirection( ChewingContext *ctx, int direction )
        -:  362:{
    #####:  363:	if ( direction == 0 || direction == 1 )
    #####:  364:		ctx->data->config.bAddPhraseForward = direction;
    #####:  365:}
        -:  366:
    #####:  367:CHEWING_API int chewing_get_addPhraseDirection( ChewingContext *ctx )
        -:  368:{
    #####:  369:	return ctx->data->config.bAddPhraseForward;
        -:  370:}
        -:  371:
        1:  372:CHEWING_API void chewing_set_spaceAsSelection( ChewingContext *ctx, int mode )
        -:  373:{
        1:  374:	if ( mode == 0 || mode == 1 )
        1:  375:		ctx->data->config.bSpaceAsSelection = mode;
        1:  376:}
        -:  377:
    #####:  378:CHEWING_API int chewing_get_spaceAsSelection( ChewingContext *ctx )
        -:  379:{
    #####:  380:	return ctx->data->config.bSpaceAsSelection;
        -:  381:}
        -:  382:
    #####:  383:CHEWING_API void chewing_set_escCleanAllBuf( ChewingContext *ctx, int mode )
        -:  384:{
    #####:  385:	if ( mode == 0 || mode == 1 )
    #####:  386:		ctx->data->config.bEscCleanAllBuf = mode;
    #####:  387:}
        -:  388:
    #####:  389:CHEWING_API int chewing_get_escCleanAllBuf( ChewingContext *ctx )
        -:  390:{
    #####:  391:	return ctx->data->config.bEscCleanAllBuf;
        -:  392:}
        -:  393:
    #####:  394:CHEWING_API void chewing_set_hsuSelKeyType( ChewingContext *ctx, int mode )
        -:  395:{
        -:  396:	// XXX: This function is deprecated. No one read hsuSelKeyType.
    #####:  397:	ctx->data->config.hsuSelKeyType = mode;
    #####:  398:}
        -:  399:
    #####:  400:CHEWING_API int chewing_get_hsuSelKeyType( ChewingContext *ctx )
        -:  401:{
        -:  402:	// XXX: This function is deprecated. No one read hsuSelKeyType.
    #####:  403:	return ctx->data->config.hsuSelKeyType;
        -:  404:}
        -:  405:
        1:  406:CHEWING_API void chewing_set_autoShiftCur( ChewingContext *ctx, int mode )
        -:  407:{
        1:  408:	if ( mode == 0 || mode == 1 )
        1:  409:		ctx->data->config.bAutoShiftCur = mode;
        1:  410:}
        -:  411:
    #####:  412:CHEWING_API int chewing_get_autoShiftCur( ChewingContext *ctx )
        -:  413:{
    #####:  414:	return ctx->data->config.bAutoShiftCur;
        -:  415:}
        -:  416:
    #####:  417:CHEWING_API void chewing_set_easySymbolInput( ChewingContext *ctx, int mode )
        -:  418:{
    #####:  419:	if ( mode == 0 || mode == 1 )
    #####:  420:		ctx->data->config.bEasySymbolInput = mode;
    #####:  421:}
        -:  422:
    #####:  423:CHEWING_API int chewing_get_easySymbolInput( ChewingContext *ctx )
        -:  424:{
    #####:  425:	return ctx->data->config.bEasySymbolInput;
        -:  426:}
        -:  427:
        4:  428:CHEWING_API void chewing_set_phraseChoiceRearward( ChewingContext *ctx, int mode )
        -:  429:{
        4:  430:	if ( mode == 0 || mode == 1 )
        4:  431:		ctx->data->config.bPhraseChoiceRearward = mode;
        4:  432:}
        -:  433:
    #####:  434:CHEWING_API int chewing_get_phraseChoiceRearward( ChewingContext *ctx )
        -:  435:{
    #####:  436:	return ctx->data->config.bPhraseChoiceRearward;
        -:  437:}
        -:  438:
    #####:  439:CHEWING_API void chewing_set_ChiEngMode( ChewingContext *ctx, int mode )
        -:  440:{
    #####:  441:	if ( mode == CHINESE_MODE || mode == SYMBOL_MODE )
    #####:  442:		ctx->data->bChiSym = mode;
    #####:  443:}
        -:  444:
        1:  445:CHEWING_API int chewing_get_ChiEngMode( ChewingContext *ctx )
        -:  446:{
        1:  447:	return ctx->data->bChiSym;
        -:  448:}
        -:  449:
    #####:  450:CHEWING_API void chewing_set_ShapeMode( ChewingContext *ctx, int mode )
        -:  451:{
    #####:  452:	if ( mode == HALFSHAPE_MODE || mode == FULLSHAPE_MODE )
    #####:  453:		ctx->data->bFullShape = mode;
    #####:  454:}
        -:  455:
    #####:  456:CHEWING_API int chewing_get_ShapeMode( ChewingContext *ctx )
        -:  457:{
    #####:  458:	return ctx->data->bFullShape;
        -:  459:}
        -:  460:
      367:  461:static void CheckAndResetRange( ChewingData *pgdata )
        -:  462:{
      367:  463:	if ( pgdata->PointStart > -1 ) {
    #####:  464:		pgdata->PointStart = -1;
    #####:  465:		pgdata->PointEnd = 0;
        -:  466:	}
      367:  467:}
        -:  468:
       28:  469:static int DoSelect( ChewingData *pgdata, int num )
        -:  470:{
      28*:  471:	assert( pgdata->choiceInfo.pageNo >= 0 );
       28:  472:	if ( num >= 0 ) {
       27:  473:		num += pgdata->choiceInfo.pageNo * pgdata->choiceInfo.nChoicePerPage;
        -:  474:		/* Note: if num is larger than the total, there will be big troubles. */
       27:  475:		if ( num < pgdata->choiceInfo.nTotalChoice ) {
       27:  476:			if ( pgdata->choiceInfo.isSymbol != WORD_CHOICE ) {
       14:  477:				SymbolChoice( pgdata, num );
        -:  478:			}
        -:  479:			else {
        -:  480:				/* change the select interval & selectStr & nSelect */
       13:  481:				AddSelect( pgdata, num );
        -:  482:				/* second, call choice module */
       13:  483:				ChoiceSelect( pgdata, num );
        -:  484:				/* automatically shift the cursor to next phrase */
       13:  485:				if ( pgdata->config.bAutoShiftCur != 0 &&
        -:  486:				     /* if cursor at end of string, do not shift the cursor. */
        2:  487:				     pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {
        2:  488:					if ( pgdata->config.bPhraseChoiceRearward ) {
        2:  489:						++pgdata->chiSymbolCursor;
        -:  490:					} else {
    #####:  491:						pgdata->chiSymbolCursor +=
    #####:  492:							pgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;
        -:  493:					}
        -:  494:				}
        -:  495:			}
       27:  496:			return 1;
        -:  497:		}
        -:  498:	}
        1:  499:	return 0;
        -:  500:}
        -:  501:
       12:  502:CHEWING_API int chewing_handle_Space( ChewingContext *ctx )
        -:  503:{
       12:  504:	ChewingData *pgdata = ctx->data;
        -:  505:
        -:  506:	/*
        -:  507:	 * Use chewing_handle_Default( ctx, ' ' ) to handle space when:
        -:  508:	 * - "space as selection" mode is disable
        -:  509:	 * - mode is not CHINESE_MODE
        -:  510:	 * - has incompleted bopomofo (space is needed to complete it)
        -:  511:	 */
       12:  512:	if ( !pgdata->config.bSpaceAsSelection
        2:  513:	     || pgdata->bChiSym != CHINESE_MODE
        2:  514:	     || ZuinIsEntering( &ctx->data->zuinData ) ) {
       10:  515:		return chewing_handle_Default( ctx, ' ' );
        -:  516:	}
        -:  517:
        2:  518:	CheckAndResetRange( pgdata );
        -:  519:
        -:  520:	/*
        -:  521:	 * space = right when the follogin conditions are true
        -:  522:	 * 1. In select mode
        -:  523:	 * 2. The candidate page is not last page
        -:  524:	 *
        -:  525:	 * Otherwise, space = down
        -:  526:	 */
        2:  527:	if ( pgdata->bSelect &&
        1:  528:	     ctx->output->pci->pageNo < ctx->output->pci->nPage - 1 ) {
    #####:  529:		return chewing_handle_Right( ctx );
        -:  530:	} else {
        2:  531:		return chewing_handle_Down( ctx );
        -:  532:	}
        -:  533:	return 0;
        -:  534:}
        -:  535:
       19:  536:CHEWING_API int chewing_handle_Esc( ChewingContext *ctx )
        -:  537:{
       19:  538:	ChewingData *pgdata = ctx->data;
       19:  539:	ChewingOutput *pgo = ctx->output;
       19:  540:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  541:
       19:  542:	CheckAndResetRange( pgdata );
        -:  543:
       19:  544:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  545:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  546:	}
       18:  547:	else if ( pgdata->bSelect ) {
       13:  548:		ChoiceEndChoice( pgdata );
        -:  549:	}
        5:  550:	else if ( ZuinIsEntering( &( pgdata->zuinData ) ) ) {
        1:  551:		ZuinRemoveAll( &( pgdata->zuinData ) );
        -:  552:	}
        4:  553:	else if ( pgdata->config.bEscCleanAllBuf ) {
    #####:  554:		CleanAllBuf( pgdata );
    #####:  555:		pgo->nCommitStr = pgdata->chiSymbolBufLen;
        -:  556:	}
        -:  557:
       19:  558:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       19:  559:	return 0;
        -:  560:}
        -:  561:
       14:  562:CHEWING_API int chewing_handle_Enter( ChewingContext *ctx )
        -:  563:{
       14:  564:	ChewingData *pgdata = ctx->data;
       14:  565:	ChewingOutput *pgo = ctx->output;
       14:  566:	int nCommitStr = pgdata->chiSymbolBufLen;
       14:  567:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  568:
       14:  569:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  570:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  571:	}
       14:  572:	else if ( pgdata->bSelect ) {
        1:  573:		keystrokeRtn = KEYSTROKE_ABSORB | KEYSTROKE_BELL;
        -:  574:	}
       13:  575:	else if ( pgdata->PointStart > -1 ) {
    #####:  576:		int buf = pgdata->chiSymbolCursor;
        -:  577:		int key;
    #####:  578:		if ( pgdata->PointEnd > 1 ) {
    #####:  579:			if ( ! pgdata->config.bAddPhraseForward ) {
    #####:  580:				pgdata->chiSymbolCursor = pgdata->PointStart;
    #####:  581:				key = '0' + pgdata->PointEnd;
        -:  582:			}
        -:  583:			else {
    #####:  584:				pgdata->chiSymbolCursor = pgdata->PointStart + pgdata->PointEnd;
    #####:  585:				key = '0' + pgdata->PointEnd;
        -:  586:			}
        -:  587:
    #####:  588:			chewing_handle_CtrlNum( ctx, key );
    #####:  589:			pgdata->chiSymbolCursor = buf;
        -:  590:		}
    #####:  591:		else if ( pgdata->PointEnd < 1 ) {
    #####:  592:			if ( pgdata->config.bAddPhraseForward )
    #####:  593:				pgdata->chiSymbolCursor = buf - pgdata->PointEnd;
    #####:  594:			key = '0' - pgdata->PointEnd;
    #####:  595:			chewing_handle_CtrlNum( ctx, key );
    #####:  596:			pgdata->chiSymbolCursor = buf;
        -:  597:		}
    #####:  598:		pgdata->PointStart = -1;
    #####:  599:		pgdata->PointEnd = 0;
        -:  600:	}
        -:  601:	else {
       13:  602:		keystrokeRtn = KEYSTROKE_COMMIT;
       13:  603:		WriteChiSymbolToBuf( pgo->commitStr, nCommitStr, pgdata );
       13:  604:		AutoLearnPhrase( pgdata );
       13:  605:		CleanAllBuf( pgdata );
       13:  606:		pgo->nCommitStr = nCommitStr;
        -:  607:	}
        -:  608:
       14:  609:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       14:  610:	return 0;
        -:  611:}
        -:  612:
        3:  613:CHEWING_API int chewing_handle_Del( ChewingContext *ctx )
        -:  614:{
        3:  615:	ChewingData *pgdata = ctx->data;
        3:  616:	ChewingOutput *pgo = ctx->output;
        3:  617:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  618:
        3:  619:	CheckAndResetRange( pgdata );
        -:  620:
        3:  621:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  622:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  623:	}
        -:  624:
        3:  625:	if ( ! pgdata->bSelect ) {
        2:  626:		if (
        2:  627:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
        2:  628:			pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {
        1:  629:			ChewingKillChar(
        -:  630:				pgdata,
        -:  631:				pgdata->chiSymbolCursor,
        -:  632:				NONDECREASE_CURSOR );
        -:  633:		}
        2:  634:		CallPhrasing( pgdata, 0 );
        -:  635:	}
        3:  636:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        3:  637:	return 0;
        -:  638:}
        -:  639:
        4:  640:CHEWING_API int chewing_handle_Backspace( ChewingContext *ctx )
        -:  641:{
        4:  642:	ChewingData *pgdata = ctx->data;
        4:  643:	ChewingOutput *pgo = ctx->output;
        4:  644:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  645:
        4:  646:	CheckAndResetRange( pgdata );
        -:  647:
        4:  648:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  649:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  650:	}
        -:  651:
        4:  652:	if ( ! pgdata->bSelect ) {
        3:  653:		if ( ZuinIsEntering( &( pgdata->zuinData ) ) ) {
        1:  654:			ZuinRemoveLast( &( pgdata->zuinData ) );
        -:  655:		}
        2:  656:		else if ( pgdata->chiSymbolCursor > 0 ) {
        1:  657:			ChewingKillChar(
        -:  658:				pgdata,
        1:  659:				pgdata->chiSymbolCursor - 1,
        -:  660:				DECREASE_CURSOR );
        -:  661:		}
        3:  662:		CallPhrasing( pgdata, 0 );
        -:  663:	}
        4:  664:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        -:  665:
        4:  666:	return 0;
        -:  667:}
        -:  668:
        1:  669:CHEWING_API int chewing_handle_Up( ChewingContext *ctx )
        -:  670:{
        1:  671:	ChewingData *pgdata = ctx->data;
        1:  672:	ChewingOutput *pgo = ctx->output;
        1:  673:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  674:	int key_buf_cursor;
        -:  675:
        1:  676:	CheckAndResetRange( pgdata );
        -:  677:
        1:  678:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  679:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  680:	}
        -:  681:
        1:  682:	key_buf_cursor = pgdata->chiSymbolCursor;
        -:  683:	// FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.
        1:  684:	if ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )
        1:  685:		key_buf_cursor--;
        -:  686:
        -:  687:	// XXX: Why close symbol choice list, but not word choice list.
        1:  688:	if ( ! pgdata->symbolKeyBuf[ key_buf_cursor ] ) {
        -:  689:		/* Close Symbol Choice List */
        1:  690:		if ( pgdata->bSelect ) {
        -:  691:			// FIXME: why we need to close the candidate list here?
    #####:  692:			ChoiceEndChoice( pgdata );
        -:  693:		}
        -:  694:	}
        -:  695:
        1:  696:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        1:  697:	return 0;
        -:  698:}
        -:  699:
       39:  700:CHEWING_API int chewing_handle_Down( ChewingContext *ctx )
        -:  701:{
       39:  702:	ChewingData *pgdata = ctx->data;
       39:  703:	ChewingOutput *pgo = ctx->output;
       39:  704:	int toSelect = 0;
       39:  705:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  706:	int key_buf_cursor;
        -:  707:
       39:  708:	CheckAndResetRange( pgdata );
        -:  709:
       39:  710:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  711:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  712:	}
        -:  713:
       39:  714:	key_buf_cursor = pgdata->chiSymbolCursor;
        -:  715:	// FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.
       39:  716:	if ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )
       12:  717:		key_buf_cursor--;
        -:  718:
        -:  719:	/* see if to select */
       39:  720:	if ( ChewingIsChiAt( key_buf_cursor, pgdata ) )
       34:  721:			toSelect = 1;
        -:  722:
       39:  723:	chooseCandidate( ctx, toSelect, key_buf_cursor );
        -:  724:
       39:  725:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       39:  726:	return 0;
        -:  727:}
        -:  728:
        -:  729:/* Add phrase in Hanin Style */
    #####:  730:CHEWING_API int chewing_handle_ShiftLeft( ChewingContext *ctx )
        -:  731:{
    #####:  732:	ChewingData *pgdata = ctx->data;
    #####:  733:	ChewingOutput *pgo = ctx->output;
    #####:  734:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  735:
    #####:  736:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  737:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  738:	}
    #####:  739:	if ( ! pgdata->bSelect ) {
        -:  740:		/*  PointEnd locates (-9, +9) */
    #####:  741:		if (
    #####:  742:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
    #####:  743:			pgdata->chiSymbolCursor > 0 &&
    #####:  744:			pgdata->PointEnd > -9 ) {
    #####:  745:			if ( pgdata->PointStart == -1 )
    #####:  746:				pgdata->PointStart = pgdata->chiSymbolCursor;
    #####:  747:			pgdata->chiSymbolCursor--;
    #####:  748:			if (
    #####:  749:				ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) ) {
    #####:  750:				pgdata->PointEnd--;
        -:  751:			}
    #####:  752:			if ( pgdata->PointEnd == 0 )
    #####:  753:				pgdata->PointStart = -1;
        -:  754:		}
        -:  755:	}
        -:  756:
    #####:  757:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####:  758:	return 0;
        -:  759:}
        -:  760:
       14:  761:CHEWING_API int chewing_handle_Left( ChewingContext *ctx )
        -:  762:{
       14:  763:	ChewingData *pgdata = ctx->data;
       14:  764:	ChewingOutput *pgo = ctx->output;
       14:  765:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  766:
       14:  767:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  768:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  769:	}
        -:  770:
       14:  771:	if ( pgdata->bSelect ) {
    #####:  772:		assert( pgdata->choiceInfo.nPage > 0 );
    #####:  773:		if ( pgdata->choiceInfo.pageNo > 0 )
    #####:  774:			pgdata->choiceInfo.pageNo--;
        -:  775:		else
    #####:  776:			pgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;
        -:  777:	}
        -:  778:	else {
       14:  779:		if (
       14:  780:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
       14:  781:			pgdata->chiSymbolCursor > 0 ) {
       14:  782:			CheckAndResetRange( pgdata );
       14:  783:			pgdata->chiSymbolCursor--;
        -:  784:		}
        -:  785:	}
       14:  786:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       14:  787:	return 0;
        -:  788:}
        -:  789:
        -:  790:/* Add phrase in Hanin Style */
    #####:  791:CHEWING_API int chewing_handle_ShiftRight( ChewingContext *ctx )
        -:  792:{
    #####:  793:	ChewingData *pgdata = ctx->data;
    #####:  794:	ChewingOutput *pgo = ctx->output;
    #####:  795:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  796:
    #####:  797:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  798:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  799:	}
        -:  800:
    #####:  801:	if ( ! pgdata->bSelect ) {
        -:  802:		/* PointEnd locates (-9, +9) */
    #####:  803:		if (
    #####:  804:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
    #####:  805:			pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen &&
    #####:  806:			pgdata->PointEnd < 9 ) {
    #####:  807:			if ( pgdata->PointStart == -1 )
    #####:  808:				pgdata->PointStart = pgdata->chiSymbolCursor;
    #####:  809:			if (
    #####:  810:				ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) ) {
    #####:  811:				pgdata->PointEnd++;
        -:  812:			}
    #####:  813:			pgdata->chiSymbolCursor++;
    #####:  814:			if ( pgdata->PointEnd == 0 )
    #####:  815:				pgdata->PointStart = -1;
        -:  816:		}
        -:  817:	}
        -:  818:
    #####:  819:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####:  820:	return 0;
        -:  821:}
        -:  822:
       26:  823:CHEWING_API int chewing_handle_Right( ChewingContext *ctx )
        -:  824:{
       26:  825:	ChewingData *pgdata = ctx->data;
       26:  826:	ChewingOutput *pgo = ctx->output;
       26:  827:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  828:
       26:  829:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  830:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  831:	}
        -:  832:
       26:  833:	if ( pgdata->bSelect ) {
    #####:  834:		if ( pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1)
    #####:  835:			pgdata->choiceInfo.pageNo++;
        -:  836:		else
    #####:  837:			pgdata->choiceInfo.pageNo = 0;
        -:  838:	}
        -:  839:	else {
       26:  840:		if (
       26:  841:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
       26:  842:			pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {
       26:  843:			CheckAndResetRange( pgdata );
       26:  844:			pgdata->chiSymbolCursor++;
        -:  845:		}
        -:  846:	}
        -:  847:
       26:  848:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       26:  849:	return 0;
        -:  850:}
        -:  851:
        4:  852:CHEWING_API int chewing_handle_Tab( ChewingContext *ctx )
        -:  853:{
        -:  854:	int cursor;
        4:  855:	ChewingData *pgdata = ctx->data;
        4:  856:	ChewingOutput *pgo = ctx->output;
        4:  857:	int keystrokeRtn = KEYSTROKE_ABSORB;
        4:  858:	int all_phrasing = 0;
        -:  859:
        4:  860:	CheckAndResetRange( pgdata );
        -:  861:
        4:  862:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  863:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  864:	}
        -:  865:
        -:  866:
        4:  867:	if ( ! pgdata->bSelect ) {
        4:  868:		if ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen ) {
        2:  869:			pgdata->phrOut.nNumCut++;
        2:  870:			all_phrasing = 1;
        -:  871:		}
        2:  872:		else if ( ChewingIsChiAt( pgdata->chiSymbolCursor - 1, pgdata ) ) {
        2:  873:			cursor = PhoneSeqCursor( pgdata );
        2:  874:			if ( IsPreferIntervalConnted( cursor, pgdata) ) {
        1:  875:				pgdata->bUserArrBrkpt[ cursor ] = 1;
        1:  876:				pgdata->bUserArrCnnct[ cursor ] = 0;
        -:  877:			}
        -:  878:			else {
        1:  879:				pgdata->bUserArrBrkpt[ cursor ] = 0;
        1:  880:				pgdata->bUserArrCnnct[ cursor ] = 1;
        -:  881:			}
        -:  882:		}
        4:  883:		CallPhrasing( pgdata, all_phrasing );
        -:  884:	}
        4:  885:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        4:  886:	return 0;
        -:  887:}
        -:  888:
    #####:  889:CHEWING_API int chewing_handle_DblTab( ChewingContext *ctx )
        -:  890:{
        -:  891:	int cursor;
    #####:  892:	ChewingData *pgdata = ctx->data;
    #####:  893:	ChewingOutput *pgo = ctx->output;
    #####:  894:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  895:
    #####:  896:	CheckAndResetRange( pgdata );
        -:  897:
    #####:  898:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  899:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  900:	}
        -:  901:
    #####:  902:	if ( ! pgdata->bSelect ) {
    #####:  903:		cursor = PhoneSeqCursor( pgdata );
    #####:  904:		pgdata->bUserArrBrkpt[ cursor ] = 0;
    #####:  905:		pgdata->bUserArrCnnct[ cursor ] = 0;
        -:  906:	}
    #####:  907:	CallPhrasing( pgdata, 0 );
        -:  908:
    #####:  909:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####:  910:	return 0;
        -:  911:}
        -:  912:
        -:  913:
        1:  914:CHEWING_API int chewing_handle_Capslock( ChewingContext *ctx )
        -:  915:{
        1:  916:	ChewingData *pgdata = ctx->data;
        1:  917:	ChewingOutput *pgo = ctx->output;
        -:  918:
        1:  919:	pgdata->bChiSym = 1 - pgdata->bChiSym;
        1:  920:	MakeOutputWithRtn( pgo, pgdata, KEYSTROKE_ABSORB );
        1:  921:	return 0;
        -:  922:}
        -:  923:
       19:  924:CHEWING_API int chewing_handle_Home( ChewingContext *ctx )
        -:  925:{
       19:  926:	ChewingData *pgdata = ctx->data;
       19:  927:	ChewingOutput *pgo = ctx->output;
       19:  928:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  929:
       19:  930:	CheckAndResetRange( pgdata );
        -:  931:
       19:  932:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  933:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  934:	}
       19:  935:	else if ( ! pgdata->bSelect ) {
       19:  936:		pgdata->chiSymbolCursor = 0;
        -:  937:	}
       19:  938:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       19:  939:	return 0;
        -:  940:}
        -:  941:
        1:  942:CHEWING_API int chewing_handle_End( ChewingContext *ctx )
        -:  943:{
        1:  944:	ChewingData *pgdata = ctx->data;
        1:  945:	ChewingOutput *pgo = ctx->output;
        1:  946:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  947:
        1:  948:	CheckAndResetRange( pgdata );
        -:  949:
        1:  950:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  951:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  952:	}
        1:  953:	else if ( ! pgdata->bSelect ) {
        1:  954:		pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
        -:  955:	}
        1:  956:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        1:  957:	return 0;
        -:  958:}
        -:  959:
        1:  960:CHEWING_API int chewing_handle_PageUp( ChewingContext *ctx )
        -:  961:{
        1:  962:	ChewingData *pgdata = ctx->data;
        1:  963:	ChewingOutput *pgo = ctx->output;
        1:  964:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  965:
        1:  966:	CheckAndResetRange( pgdata );
        -:  967:
        1:  968:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  969:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  970:	}
        1:  971:	else if ( ! pgdata->bSelect ) {
        1:  972:		pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
        -:  973:	}
        1:  974:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        1:  975:	return 0;
        -:  976:}
        -:  977:
        1:  978:CHEWING_API int chewing_handle_PageDown( ChewingContext *ctx )
        -:  979:{
        1:  980:	ChewingData *pgdata = ctx->data;
        1:  981:	ChewingOutput *pgo = ctx->output;
        1:  982:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  983:
        1:  984:	CheckAndResetRange( pgdata );
        -:  985:
        1:  986:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  987:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  988:	}
        1:  989:	else if ( ! pgdata->bSelect ) {
        1:  990:		pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
        -:  991:	}
        1:  992:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        1:  993:	return 0;
        -:  994:}
        -:  995:
        -:  996:/* Dvorak <-> Qwerty keyboard layout converter */
    #####:  997:static int dvorak_convert( int key )
        -:  998:{
    #####:  999:	const char dkey[] = {
        -: 1000:		'\'','\"',',','<','.','>','p','P','y','Y','f','F','g','G',
        -: 1001:		'c','C','r','R','l','L','/','?','=','+','\\','|',
        -: 1002:		'a','A','o','O','e','E','u','U','i','I','d','D','h','H',
        -: 1003:		't','T','n','N','s','S','-','_',
        -: 1004:		';',':','q','Q','j','J','k','K','x','X','b','B','m','M',
        -: 1005:		'w','W','v','V','z','Z'};
    #####: 1006:	const char qkey[] = {
        -: 1007:		'q','Q','w','W','e','E','r','R','t','T','y','Y','u','U',
        -: 1008:		'i','I','o','O','p','P','[','{',']','}','\\','|',
        -: 1009:		'a','A','s','S','d','D','f','F','g','G','h','H','j','J',
        -: 1010:		'k','K','l','L',';',':','\'','\"',
        -: 1011:		'z','Z','x','X','c','C','v','V','b','B','n','N','m','M',
        -: 1012:		',','<','.','>','/','?'};
        -: 1013:	size_t i;
        -: 1014:
        -: 1015:	STATIC_ASSERT( ARRAY_SIZE( dkey ) == ARRAY_SIZE( qkey ), update_dkey_and_qkey );
        -: 1016:
    #####: 1017:	for ( i = 0; i < ARRAY_SIZE( dkey ); i++ ) {
    #####: 1018:		if ( key == qkey[ i ] ) {
    #####: 1019:			key = dkey[ i ];
    #####: 1020:			return key;
        -: 1021:		}
        -: 1022:	}
    #####: 1023:	return key;
        -: 1024:}
        -: 1025:
      232: 1026:CHEWING_API int chewing_handle_Default( ChewingContext *ctx, int key )
        -: 1027:{
      232: 1028:	ChewingData *pgdata = ctx->data;
      232: 1029:	ChewingOutput *pgo = ctx->output;
        -: 1030:	int rtn, num;
      232: 1031:	int keystrokeRtn = KEYSTROKE_ABSORB;
      232: 1032:	int bQuickCommit = 0;
        -: 1033:
        -: 1034:	/* Update lifetime */
      232: 1035:	ctx->data->static_data.chewing_lifetime++;
        -: 1036:
        -: 1037:	/* Skip the special key */
      232: 1038:	if ( key & 0xFF00 ) {
    #####: 1039:		keystrokeRtn = KEYSTROKE_IGNORE;
    #####: 1040:		goto End_KeyDefault;
        -: 1041:	}
        -: 1042:
        -: 1043:	/* We ignore non-printable input */
      232: 1044:	if ( ! isprint( key ) )
    #####: 1045:		goto End_KeyDefault;
        -: 1046:
      232: 1047:	CheckAndResetRange( pgdata );
        -: 1048:
      232: 1049:	DEBUG_CHECKPOINT();
      232: 1050:	DEBUG_OUT( "   key=%d", key );
        -: 1051:
        -: 1052:	/* Dvorak Hsu */
      232: 1053:	if ( pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {
    #####: 1054:		key = dvorak_convert( key );
        -: 1055:	}
        -: 1056:
        -: 1057:	/* selecting */
      232: 1058:	if ( pgdata->bSelect ) {
       20: 1059:		if ( key == ' ' )
    #####: 1060:			return chewing_handle_Right( ctx );
        -: 1061:		/* num starts from 0 */
       20: 1062:		num = CountSelKeyNum( key, pgdata );
       20: 1063:		if ( num >= 0 ) {
       18: 1064:			DoSelect( pgdata, num );
       18: 1065:			goto End_keyproc;
        -: 1066:		}
        -: 1067:
        -: 1068:		/* Otherwise, use 'j' and 'k' for paging in selection mode */
        2: 1069:		DEBUG_OUT(
        -: 1070:			"\t\tchecking paging key, got '%c'\n",
        -: 1071:			key );
        2: 1072:		switch ( key ) {
    #####: 1073:			case 'j':
        -: 1074:			case 'J':
    #####: 1075:				if ( pgdata->chiSymbolCursor > 0 ) {
    #####: 1076:					if ( ! ChewingIsEntering( pgdata ) ) {
    #####: 1077:						keystrokeRtn = KEYSTROKE_IGNORE;
        -: 1078:					}
    #####: 1079:					CheckAndResetRange( pgdata );
    #####: 1080:					pgdata->chiSymbolCursor--;
    #####: 1081:					if ( ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) )
    #####: 1082:						ChoiceFirstAvail( pgdata );
        -: 1083:					else
    #####: 1084:						OpenSymbolChoice( pgdata );
        -: 1085:
        -: 1086:				}
    #####: 1087:				goto End_Paging;
        1: 1088:			case 'k':
        -: 1089:			case 'K':
        1: 1090:				if ( pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {
        1: 1091:					if ( ! ChewingIsEntering( pgdata ) ) {
    #####: 1092:						keystrokeRtn = KEYSTROKE_IGNORE;
        -: 1093:					}
        1: 1094:					CheckAndResetRange( pgdata );
        1: 1095:					pgdata->chiSymbolCursor++;
        1: 1096:					if ( ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) )
    #####: 1097:						ChoiceFirstAvail( pgdata );
        -: 1098:					else
        1: 1099:						OpenSymbolChoice( pgdata );
        -: 1100:				}
        1: 1101:				goto End_Paging;
        1: 1102:			default:
        1: 1103:				break;
        -: 1104:		}
        -: 1105:	}
        -: 1106:	/* editing */
        -: 1107:	else {
      212: 1108:		if ( pgdata->bChiSym == CHINESE_MODE ) {
      212: 1109:			if ( pgdata->config.bEasySymbolInput != 0 ) {
    #####: 1110:				EasySymbolInput( key, pgdata );
    #####: 1111:				goto End_keyproc;
        -: 1112:			}
        -: 1113:
        -: 1114:			/* open symbol table */
      212: 1115:			if ( key == '`' ) {
       10: 1116:				pgdata->bSelect = 1;
       10: 1117:				pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
        -: 1118:
       10: 1119:				HaninSymbolInput( pgdata );
       10: 1120:				goto End_KeyDefault;
        -: 1121:			}
        -: 1122:
      202: 1123:			rtn = ZuinPhoInput( pgdata, key );
      202: 1124:			DEBUG_OUT(
        -: 1125:				"\t\tChinese mode key, "
        -: 1126:				"ZuinPhoInput return value = %d\n",
        -: 1127:				rtn );
        -: 1128:
      202: 1129:			if ( rtn == ZUIN_KEY_ERROR )
    #####: 1130:				rtn = SpecialSymbolInput( key, pgdata );
      202: 1131:			switch ( rtn ) {
      129: 1132:				case ZUIN_ABSORB:
      129: 1133:					keystrokeRtn = KEYSTROKE_ABSORB;
      129: 1134:					break;
       73: 1135:				case ZUIN_COMMIT:
       73: 1136:					AddChi( pgdata->zuinData.phone, pgdata->zuinData.phoneAlt, pgdata );
       73: 1137:					break;
    #####: 1138:				case ZUIN_NO_WORD:
    #####: 1139:					keystrokeRtn = KEYSTROKE_BELL | KEYSTROKE_ABSORB;
    #####: 1140:					break;
    #####: 1141:				case ZUIN_KEY_ERROR:
        -: 1142:				case ZUIN_IGNORE:
    #####: 1143:					DEBUG_OUT(
        -: 1144:						"\t\tbefore isupper(key),key=%d\n",
        -: 1145:						key );
        -: 1146:					/* change upper case into lower case */
    #####: 1147:					if ( isupper( key ) )
    #####: 1148:						key = tolower( key );
        -: 1149:
    #####: 1150:					DEBUG_OUT(
        -: 1151:						"\t\tafter isupper(key),key=%d\n",
        -: 1152:						key );
        -: 1153:
        -: 1154:					/* see if buffer contains nothing */
    #####: 1155:					if ( pgdata->chiSymbolBufLen == 0 ) {
    #####: 1156:						bQuickCommit = 1;
        -: 1157:					}
        -: 1158:
    #####: 1159:					if ( pgdata->config.bEasySymbolInput == 0 ) {
    #####: 1160:						if ( pgdata->bFullShape )
    #####: 1161:							rtn = FullShapeSymbolInput( key, pgdata );
        -: 1162:						else
    #####: 1163:							rtn = SymbolInput( key, pgdata );
        -: 1164:					}
        -: 1165:
    #####: 1166:					if ( rtn == SYMBOL_KEY_ERROR ) {
    #####: 1167:						keystrokeRtn = KEYSTROKE_IGNORE;
        -: 1168:						/*
        -: 1169:						 * If the key is not a printable symbol,
        -: 1170:						 * then it's wrong to commit it.
        -: 1171:						 */
    #####: 1172:						bQuickCommit = 0;
        -: 1173:					}
        -: 1174:					else
    #####: 1175:						keystrokeRtn = KEYSTROKE_ABSORB;
        -: 1176:
    #####: 1177:					break;
        -: 1178:
        -: 1179:			}
      202: 1180:		}
        -: 1181:		/* English mode */
        -: 1182:		else {
        -: 1183:			/* see if buffer contains nothing */
    #####: 1184:			if ( pgdata->chiSymbolBufLen == 0 ) {
    #####: 1185:				bQuickCommit = 1;
        -: 1186:			}
    #####: 1187:			if ( pgdata->bFullShape ) {
    #####: 1188:				rtn = FullShapeSymbolInput( key, pgdata );
        -: 1189:			}
        -: 1190:			else {
    #####: 1191:				rtn = SymbolInput( key, pgdata );
        -: 1192:			}
        -: 1193:
    #####: 1194:			if ( rtn == SYMBOL_KEY_ERROR ) {
    #####: 1195:				keystrokeRtn = KEYSTROKE_IGNORE;
    #####: 1196:				bQuickCommit = 0;
        -: 1197:			}
        -: 1198:		}
        -: 1199:	}
        -: 1200:
    #####: 1201:End_keyproc:
      221: 1202:	if ( ! bQuickCommit ) {
      221: 1203:		CallPhrasing( pgdata, 0 );
      221: 1204:		if ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )
    #####: 1205:			keystrokeRtn = KEYSTROKE_COMMIT;
        -: 1206:	}
        -: 1207:	/* Quick commit */
        -: 1208:	else {
    #####: 1209:		DEBUG_OUT(
        -: 1210:				"\t\tQuick commit buf[0]=%c\n",
        -: 1211:				pgdata->chiSymbolBuf[ 0 ].s[ 0 ] );
    #####: 1212:		pgo->commitStr[ 0 ] = pgdata->chiSymbolBuf[ 0 ];
    #####: 1213:		pgo->nCommitStr = 1;
    #####: 1214:		pgdata->chiSymbolBufLen = 0;
    #####: 1215:		pgdata->chiSymbolCursor = 0;
    #####: 1216:		keystrokeRtn = KEYSTROKE_COMMIT;
        -: 1217:	}
        -: 1218:
      221: 1219:	if ( pgdata->phrOut.nNumCut > 0 ) {
        -: 1220:		int i;
    #####: 1221:		for ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {
    #####: 1222:			pgdata->bUserArrBrkpt[ pgdata->phrOut.dispInterval[ i ].from ] = 1;
    #####: 1223:			pgdata->bUserArrBrkpt[ pgdata->phrOut.dispInterval[ i ].to ] = 1;
        -: 1224:		}
    #####: 1225:		pgdata->phrOut.nNumCut = 0;
        -: 1226:	}
        -: 1227:
      221: 1228:End_KeyDefault:
      231: 1229:	CallPhrasing( pgdata, 0 );
      232: 1230:End_Paging:
      232: 1231:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
      232: 1232:	return 0;
        -: 1233:}
        -: 1234:
    #####: 1235:CHEWING_API int chewing_handle_CtrlNum( ChewingContext *ctx, int key )
        -: 1236:{
    #####: 1237:	ChewingData *pgdata = ctx->data;
    #####: 1238:	ChewingOutput *pgo = ctx->output;
    #####: 1239:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -: 1240:	int newPhraseLen;
        -: 1241:	int i;
        -: 1242:	uint16_t addPhoneSeq[ MAX_PHONE_SEQ_LEN ];
        -: 1243:	char addWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];
        -: 1244:	int phraseState;
        -: 1245:	int cursor;
        -: 1246:
    #####: 1247:	CheckAndResetRange( pgdata );
        -: 1248:
    #####: 1249:	if ( pgdata->bSelect )
    #####: 1250:		return 0;
        -: 1251:
    #####: 1252:	CallPhrasing( pgdata, 0 );
    #####: 1253:	newPhraseLen = key - '0';
        -: 1254:
    #####: 1255:	if ( key == '0' || key == '1' ) {
    #####: 1256:		pgdata->bSelect = 1;
    #####: 1257:		pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
        -: 1258:
    #####: 1259:		HaninSymbolInput( pgdata );
    #####: 1260:		CallPhrasing( pgdata, 0 );
    #####: 1261:		MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####: 1262:		return 0;
        -: 1263:	}
        -: 1264:
    #####: 1265:	cursor = PhoneSeqCursor( pgdata );
    #####: 1266:	if ( ! pgdata->config.bAddPhraseForward ) {
    #####: 1267:		if (
    #####: 1268:			newPhraseLen >= 1 &&
    #####: 1269:			cursor + newPhraseLen - 1 <= pgdata->nPhoneSeq ) {
    #####: 1270:			if ( NoSymbolBetween(
        -: 1271:				pgdata,
        -: 1272:				cursor,
        -: 1273:				cursor + newPhraseLen ) ) {
        -: 1274:				/* Manually add phrase to the user phrase database. */
    #####: 1275:				memcpy( addPhoneSeq,
    #####: 1276:				        &pgdata->phoneSeq[ cursor ],
        -: 1277:				        sizeof( uint16_t ) * newPhraseLen );
    #####: 1278:				addPhoneSeq[ newPhraseLen ] = 0;
    #####: 1279:				ueStrNCpy( addWordSeq,
    #####: 1280:				           ueStrSeek( (char *) &pgdata->phrOut.chiBuf,
        -: 1281:				                      cursor ),
        -: 1282:				           newPhraseLen, 1);
        -: 1283:
        -: 1284:
    #####: 1285:				phraseState = UserUpdatePhrase( pgdata, addPhoneSeq, addWordSeq );
    #####: 1286:				SetUpdatePhraseMsg(
        -: 1287:					pgdata,
        -: 1288:					addWordSeq,
        -: 1289:					newPhraseLen,
        -: 1290:					phraseState );
        -: 1291:
        -: 1292:				/* Clear the breakpoint between the New Phrase */
    #####: 1293:				for ( i = 1; i < newPhraseLen; i++ )
    #####: 1294:					pgdata->bUserArrBrkpt[ cursor + i ] = 0;
        -: 1295:			}
        -: 1296:		}
        -: 1297:	}
        -: 1298:	else {
    #####: 1299:		if (
    #####: 1300:			newPhraseLen >= 1 &&
    #####: 1301:			cursor - newPhraseLen >= 0 ) {
    #####: 1302:			if ( NoSymbolBetween( pgdata,
        -: 1303:				cursor - newPhraseLen,
        -: 1304:				cursor ) ) {
        -: 1305:				/* Manually add phrase to the user phrase database. */
    #####: 1306:				memcpy( addPhoneSeq,
    #####: 1307:				        &pgdata->phoneSeq[ cursor - newPhraseLen ],
        -: 1308:				        sizeof( uint16_t ) * newPhraseLen );
    #####: 1309:				addPhoneSeq[ newPhraseLen ] = 0;
    #####: 1310:				ueStrNCpy( addWordSeq,
    #####: 1311:				           ueStrSeek( (char *) &pgdata->phrOut.chiBuf,
    #####: 1312:				           cursor - newPhraseLen ),
        -: 1313:				           newPhraseLen, 1);
        -: 1314:
    #####: 1315:				phraseState = UserUpdatePhrase( pgdata, addPhoneSeq, addWordSeq );
    #####: 1316:				SetUpdatePhraseMsg(
        -: 1317:					pgdata,
        -: 1318:					addWordSeq,
        -: 1319:					newPhraseLen,
        -: 1320:					phraseState );
        -: 1321:
        -: 1322:				/* Clear the breakpoint between the New Phrase */
    #####: 1323:				for ( i = 1; i < newPhraseLen; i++ )
    #####: 1324:					pgdata->bUserArrBrkpt[ cursor - newPhraseLen + i ] = 0;
        -: 1325:			}
        -: 1326:		}
        -: 1327:	}
    #####: 1328:	CallPhrasing( pgdata, 0 );
    #####: 1329:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####: 1330:	MakeOutputAddMsgAndCleanInterval( pgo, pgdata );
    #####: 1331:	return 0;
        -: 1332:}
        -: 1333:
    #####: 1334:CHEWING_API int chewing_handle_ShiftSpace( ChewingContext *ctx )
        -: 1335:{
    #####: 1336:	ChewingData *pgdata = ctx->data;
    #####: 1337:	ChewingOutput *pgo = ctx->output;
    #####: 1338:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -: 1339:
    #####: 1340:	if ( ! pgdata->bSelect ) {
    #####: 1341:		CheckAndResetRange( pgdata );
        -: 1342:	}
    #####: 1343:	CallPhrasing( pgdata, 0 );
    #####: 1344:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####: 1345:	return 0;
        -: 1346:}
        -: 1347:
       25: 1348:CHEWING_API int chewing_handle_Numlock( ChewingContext *ctx, int key )
        -: 1349:{
       25: 1350:	ChewingData *pgdata = ctx->data;
       25: 1351:	ChewingOutput *pgo = ctx->output;
       25: 1352:	int rtn, QuickCommit = 0;
       25: 1353:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -: 1354:
       25: 1355:	if ( ! pgdata->bSelect ) {
        -: 1356:		/* If we're not selecting words, we should send out numeric
        -: 1357:		 * characters at once.
        -: 1358:		 */
       15: 1359:		if ( pgdata->chiSymbolBufLen == 0 ) {
       15: 1360:			QuickCommit = 1;
        -: 1361:		}
       15: 1362:		rtn = SymbolInput( key, pgdata );
        -: 1363:		/* copied from chewing_handle_Default */
       15: 1364:		if ( rtn == SYMBOL_KEY_ERROR ) {
    #####: 1365:			keystrokeRtn = KEYSTROKE_IGNORE ;
        -: 1366:		}
       15: 1367:		else if ( QuickCommit ) {
       15: 1368:			pgo->commitStr[ 0 ] = pgdata->chiSymbolBuf[ 0 ];
       15: 1369:			pgo->nCommitStr = 1;
       15: 1370:			pgdata->chiSymbolBufLen = 0;
       15: 1371:			pgdata->chiSymbolCursor = 0;
       15: 1372:			keystrokeRtn = KEYSTROKE_COMMIT;
        -: 1373:		}
        -: 1374:		else {	/* Not quick commit */
    #####: 1375:			CallPhrasing( pgdata, 0 );
    #####: 1376:			if( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )
    #####: 1377:				keystrokeRtn = KEYSTROKE_COMMIT;
        -: 1378:		}
        -: 1379:	}
        -: 1380:	else {
        -: 1381:		/* Otherwise, if we are selecting words, we use numeric keys
        -: 1382:		 * as selkey
        -: 1383:		 * and submit the words.
        -: 1384:		 */
       10: 1385:		int num = -1;
       10: 1386:		if ( key > '0' && key < '9' )
        8: 1387:			num = key - '1';
        2: 1388:		else if ( key == '0' )
        1: 1389:			num = 9;
       10: 1390:		DoSelect( pgdata, num );
        -: 1391:	}
       25: 1392:	CallPhrasing( pgdata, 0 );
       25: 1393:	if ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )
    #####: 1394:		keystrokeRtn = KEYSTROKE_COMMIT;
       25: 1395:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       25: 1396:	return 0;
        -: 1397:}
        -: 1398:
        3: 1399:CHEWING_API unsigned short *chewing_get_phoneSeq( ChewingContext *ctx )
        -: 1400:{
        -: 1401:	uint16_t *seq;
        3: 1402:	seq = ALC( uint16_t, ctx->data->nPhoneSeq );
        3: 1403:	if ( seq )
        3: 1404:		memcpy( seq, ctx->data->phoneSeq, sizeof(uint16_t)*ctx->data->nPhoneSeq );
        3: 1405:	return seq;
        -: 1406:}
        -: 1407:
        3: 1408:CHEWING_API int chewing_get_phoneSeqLen( ChewingContext *ctx )
        -: 1409:{
        3: 1410:	return ctx->data->nPhoneSeq;
        -: 1411:}
        -: 1412:
    #####: 1413:CHEWING_API void chewing_set_logger( ChewingContext *ctx,
        -: 1414:	void (*logger)( void *data, int level, const char *fmt, ... ),
        -: 1415:	void *data )
        -: 1416:{
    #####: 1417:	if ( !logger ) {
    #####: 1418:		logger = NullLogger;
    #####: 1419:		data = 0;
        -: 1420:	}
    #####: 1421:	ctx->data->logger = logger;
    #####: 1422:	ctx->data->loggerData = data;
    #####: 1423:}
