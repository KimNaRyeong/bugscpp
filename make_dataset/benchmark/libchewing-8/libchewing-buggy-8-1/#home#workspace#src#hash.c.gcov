        -:    0:Source:/home/workspace/src/hash.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/hash.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/hash.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * hash.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2005, 2006, 2007, 2008, 2011, 2012, 2013
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:#include <string.h>
        -:   16:#include <sys/stat.h>
        -:   17:/* ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types */
        -:   18:#include <limits.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <stdio.h>
        -:   21:
        -:   22:#include "chewing-private.h"
        -:   23:#include "chewing-utf8-util.h"
        -:   24:#include "hash-private.h"
        -:   25:#include "private.h"
        -:   26:#include "memory-private.h"
        -:   27:
       13:   28:int AlcUserPhraseSeq( UserPhraseData *pData, int phonelen, int wordlen )
        -:   29:{
       13:   30:	pData->phoneSeq = ALC( uint16_t, phonelen + 1 );
       13:   31:	if ( !pData->phoneSeq )
    #####:   32:		goto error;
       13:   33:	pData->wordSeq = ALC( char, wordlen + 1 );
       13:   34:	if ( !pData->wordSeq )
    #####:   35:		goto error;
        -:   36:
       13:   37:	return 1;
        -:   38:
    #####:   39:error:
    #####:   40:	free( pData->phoneSeq );
    #####:   41:	free( pData->wordSeq );
    #####:   42:	return 0;
        -:   43:}
        -:   44:
      363:   45:static int PhoneSeqTheSame( const uint16_t p1[], const uint16_t p2[] )
        -:   46:{
        -:   47:	int i;
      363:   48:	if ( ! p1 || ! p2 )	/* FIXME: should not happend. */
    #####:   49:		return 0;
        -:   50:
      806:   51:	for ( i = 0; ( p1[ i ] != 0 && p2[ i ] != 0 ); i++ ) {
      443:   52:		if ( p1[ i ] != p2[ i ] )
    #####:   53:			return 0;
        -:   54:	}
      363:   55:	if ( p1[ i ] != p2[ i ] )
    #####:   56:		return 0;
      363:   57:	return 1;
        -:   58:}
        -:   59:
     2276:   60:static unsigned int HashFunc( const uint16_t phoneSeq[] )
        -:   61:{
     2276:   62:	int i, value = 0;
        -:   63:
     8236:   64:	for ( i = 0; phoneSeq[ i ] != 0; i++ )
     5960:   65:		value ^= phoneSeq[ i ];
     2276:   66:	return ( value & ( HASH_TABLE_SIZE - 1 ) );
        -:   67:}
        -:   68:
     2467:   69:HASH_ITEM *HashFindPhonePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast )
        -:   70:{
     4653:   71:	HASH_ITEM *pNow = pItemLast ?
        -:   72:			pItemLast->next :
     2186:   73:			pgdata->static_data.hashtable[ HashFunc( phoneSeq ) ];
        -:   74:
    2467*:   75:	for ( ; pNow; pNow = pNow->next )
      350:   76:		if ( PhoneSeqTheSame( pNow->data.phoneSeq, phoneSeq ) )
      350:   77:			return pNow;
     2117:   78:	return NULL;
        -:   79:}
        -:   80:
       39:   81:HASH_ITEM *HashFindEntry( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )
        -:   82:{
        -:   83:	HASH_ITEM *pItem;
        -:   84:	int hashvalue;
        -:   85:
       39:   86:	hashvalue = HashFunc( phoneSeq );
        -:   87:
      111:   88:	for ( pItem = pgdata->static_data.hashtable[ hashvalue ]; pItem ; pItem = pItem->next ) {
       85:   89:		if (
       98:   90:			! strcmp( pItem->data.wordSeq, wordSeq ) &&
       13:   91:			PhoneSeqTheSame( pItem->data.phoneSeq, phoneSeq ) ) {
       13:   92:			return pItem;
        -:   93:		}
        -:   94:	}
       26:   95:	return NULL;
        -:   96:}
        -:   97:
       13:   98:HASH_ITEM *HashInsert( ChewingData *pgdata, UserPhraseData *pData )
        -:   99:{
        -:  100:	int hashvalue;
        -:  101:	HASH_ITEM *pItem;
        -:  102:
       13:  103:	pItem = HashFindEntry( pgdata, pData->phoneSeq, pData->wordSeq );
       13:  104:	if ( pItem != NULL )
    #####:  105:		return pItem;
        -:  106:
       13:  107:	pItem = ALC( HASH_ITEM, 1 );
       13:  108:	if ( ! pItem )
    #####:  109:		return NULL;  /* Error occurs */
        -:  110:
       13:  111:	hashvalue = HashFunc( pData->phoneSeq );
        -:  112:	/* set the new element */
       13:  113:	pItem->next = pgdata->static_data.hashtable[ hashvalue ];
        -:  114:
       13:  115:	memcpy( &( pItem->data ), pData, sizeof( pItem->data ) );
       13:  116:	pItem->item_index = -1;
        -:  117:
        -:  118:	/* set link to the new element */
       13:  119:	pgdata->static_data.hashtable[ hashvalue ] = pItem;
        -:  120:
       13:  121:	return pItem;
        -:  122:}
        -:  123:
       26:  124:static void HashItem2String( char *str, HASH_ITEM *pItem )
        -:  125:{
        -:  126:	int i, len;
        -:  127:	char buf[ FIELD_SIZE ];
        -:  128:
       26:  129:	sprintf( str, "%s ", pItem->data.wordSeq );
       26:  130:	len = ueStrLen( pItem->data.wordSeq );
       62:  131:	for ( i = 0; i < len; i++ ) {
       36:  132:		sprintf( buf, "%hu ", pItem->data.phoneSeq[ i ] );
       36:  133:		strcat( str, buf );
        -:  134:	}
       26:  135:	sprintf(
        -:  136:		buf, "%d %d %d %d",
        -:  137:		pItem->data.userfreq, pItem->data.recentTime,
        -:  138:		pItem->data.maxfreq, pItem->data.origfreq );
       26:  139:	strcat( str, buf );
       26:  140:}
        -:  141:
        -:  142:/*
        -:  143: * capacity of 'str' MUST bigger then FIELD_SIZE !
        -:  144: */
       26:  145:static void HashItem2Binary( char *str, HASH_ITEM *pItem )
        -:  146:{
        -:  147:	int i, phraselen;
        -:  148:	char *pc;
        -:  149:
       26:  150:	memset( str, 0, FIELD_SIZE );
       26:  151:	if ( sizeof(int) * 4 + ueStrLen( pItem->data.wordSeq ) * 2 +
       26:  152:	     strlen( pItem->data.wordSeq ) >= FIELD_SIZE ) {
        -:  153:		/* exceed buffer size */
    #####:  154:		return;
        -:  155:	}
        -:  156:
        -:  157:	/* freq info */
       26:  158:	PutInt32PreservedEndian( pItem->data.userfreq, &str[ 0 ] );
       26:  159:	PutInt32PreservedEndian( pItem->data.recentTime, &str[ 4 ] );
       26:  160:	PutInt32PreservedEndian( pItem->data.maxfreq, &str[ 8 ] );
       26:  161:	PutInt32PreservedEndian( pItem->data.origfreq, &str[ 12 ] );
        -:  162:
        -:  163:	/* phone seq*/
       26:  164:	phraselen = ueStrLen( pItem->data.wordSeq );
       26:  165:	str[ 16 ] = phraselen;
       26:  166:	pc = &str[ 17 ];
       62:  167:	for ( i = 0; i < phraselen; i++ ) {
       36:  168:		PutUint16PreservedEndian( pItem->data.phoneSeq[ i ], pc );
       36:  169:		pc += 2;
        -:  170:	}
        -:  171:
        -:  172:	/* phrase */
       26:  173:	*pc = strlen( pItem->data.wordSeq );
       26:  174:	strcpy( (pc + 1), pItem->data.wordSeq );
       26:  175:	pItem->data.wordSeq[ (unsigned char) *pc ] = '\0';
        -:  176:}
        -:  177:
       26:  178:void HashModify( ChewingData *pgdata, HASH_ITEM *pItem )
        -:  179:{
        -:  180:	FILE *outfile;
        -:  181:	char str[ FIELD_SIZE + 1 ];
        -:  182:
       26:  183:	outfile = fopen( pgdata->static_data.hashfilename, "r+b" );
       26:  184:	if ( !outfile )
    #####:  185:		return;
        -:  186:
        -:  187:	/* update "lifetime" */
       26:  188:	fseek( outfile, strlen( BIN_HASH_SIG ), SEEK_SET );
       26:  189:	fwrite( &pgdata->static_data.chewing_lifetime, 1, 4, outfile );
       26:  190:	sprintf( str, "%d", pgdata->static_data.chewing_lifetime );
       26:  191:	DEBUG_OUT( "HashModify-1: '%-75s'\n", str );
        -:  192:
        -:  193:	/* update record */
       26:  194:	if ( pItem->item_index < 0 ) {
       13:  195:		fseek( outfile, 0, SEEK_END );
       13:  196:		pItem->item_index =
       13:  197:			( ftell( outfile ) - 4 - strlen( BIN_HASH_SIG ) ) / FIELD_SIZE;
        -:  198:	}
        -:  199:	else {
       13:  200:		fseek( outfile,
       13:  201:			pItem->item_index * FIELD_SIZE + 4 + strlen( BIN_HASH_SIG ),
        -:  202:			SEEK_SET );
        -:  203:	}
        -:  204:
       26:  205:	HashItem2String( str, pItem );
       26:  206:	DEBUG_OUT( "HashModify-2: '%-75s'\n", str );
        -:  207:
       26:  208:	HashItem2Binary( str, pItem );
       26:  209:	fwrite( str, 1, FIELD_SIZE, outfile );
       26:  210:	fflush( outfile );
       26:  211:	fclose( outfile );
        -:  212:}
        -:  213:
       38:  214:static int isValidChineseString( char *str )
        -:  215:{
       38:  216:	if ( str == NULL || *str == '\0' ) {
    #####:  217:		return 0;
        -:  218:	}
       92:  219:	while ( *str != '\0' )  {
       54:  220:		int len = ueBytesFromChar( (unsigned char) *str );
       54:  221:		if ( len <= 1 ) {
    #####:  222:			return 0;
        -:  223:		}
       54:  224:		str += len;
        -:  225:	};
       38:  226:	return 1;
        -:  227:}
        -:  228:
        -:  229:/**
        -:  230: * @return 1, 0 or -1
        -:  231: * retval 0	end of file
        -:  232: * retval 1	continue
        -:  233: * retval -1	ignore this record
        -:  234: */
       38:  235:static int ReadHashItem_bin( const char *srcbuf, HASH_ITEM *pItem, int item_index )
        -:  236:{
        -:  237:	int len, i;
        -:  238:	const char *pc;
        -:  239:
       38:  240:	memset( pItem, 0, sizeof(HASH_ITEM) );
        -:  241:
        -:  242:	/* freq info */
       38:  243:	pItem->data.userfreq	= GetInt32PreservedEndian(&srcbuf[ 0 ]);
       38:  244:	pItem->data.recentTime	= GetInt32PreservedEndian(&srcbuf[ 4 ]);
       38:  245:	pItem->data.maxfreq	= GetInt32PreservedEndian(&srcbuf[ 8 ]);
       38:  246:	pItem->data.origfreq	= GetInt32PreservedEndian(&srcbuf[ 12 ]);
        -:  247:
        -:  248:	/* phone seq, length in num of chi words */
       38:  249:	len = (int) srcbuf[ 16 ];
       38:  250:	pItem->data.phoneSeq = ALC( uint16_t, len + 1 );
       38:  251:	pc = &srcbuf[ 17 ];
       92:  252:	for ( i = 0; i < len; i++ ) {
       54:  253:		pItem->data.phoneSeq[ i ] = GetUint16PreservedEndian( pc );
       54:  254:		pc += 2;
        -:  255:	}
       38:  256:	pItem->data.phoneSeq[ i ] = 0;
        -:  257:
        -:  258:	/* phrase, length in num of bytes */
       38:  259:	pItem->data.wordSeq = ALC( char, (*pc) + 1 );
       38:  260:	strcpy( pItem->data.wordSeq, (char *) (pc + 1) );
       38:  261:	pItem->data.wordSeq[ (unsigned int) *pc ] = '\0';
        -:  262:
        -:  263:	/* Invalid UTF-8 Chinese characters found */
       38:  264:	if ( ! isValidChineseString( pItem->data.wordSeq ) ) {
    #####:  265:		goto ignore_corrupted_record;
        -:  266:	}
        -:  267:
        -:  268:	/* set item_index */
       38:  269:	pItem->item_index = item_index;
        -:  270:
       38:  271:	return 1; /* continue */
        -:  272:
    #####:  273:ignore_corrupted_record:
    #####:  274:	if ( pItem->data.phoneSeq != NULL ) {
    #####:  275:		free( pItem->data.phoneSeq );
    #####:  276:		pItem->data.phoneSeq = NULL;
        -:  277:	}
    #####:  278:	if ( pItem->data.wordSeq != NULL ) {
    #####:  279:		free( pItem->data.wordSeq );
    #####:  280:		pItem->data.wordSeq = NULL;
        -:  281:	}
    #####:  282:	return -1; /* ignore */
        -:  283:}
        -:  284:
        -:  285:/**
        -:  286: * @return 1, 0 or -1
        -:  287: * retval -1 Ignore bad data item
        -:  288: */
    #####:  289:static int ReadHashItem_txt( FILE *infile, HASH_ITEM *pItem, int item_index )
        -:  290:{
        -:  291:	int len, i, word_len;
        -:  292:	char wordbuf[ 64 ];
        -:  293:
        -:  294:	/* read wordSeq */
    #####:  295:	if ( fscanf( infile, "%s", wordbuf ) != 1 )
    #####:  296:		return 0;
        -:  297:
        -:  298:	/* Invalid UTF-8 Chinese characters found */
    #####:  299:	if ( ! isValidChineseString( wordbuf ) ) {
    #####:  300:		fseek( infile, FIELD_SIZE - strlen( wordbuf ) - 1, SEEK_CUR );
    #####:  301:		return -1;
        -:  302:	}
        -:  303:
    #####:  304:	word_len = strlen( wordbuf );
    #####:  305:	pItem->data.wordSeq = ALC( char, word_len + 1 );
    #####:  306:	strcpy( pItem->data.wordSeq, wordbuf );
        -:  307:
        -:  308:	/* read phoneSeq */
    #####:  309:	len = ueStrLen( pItem->data.wordSeq );
    #####:  310:	pItem->data.phoneSeq = ALC( uint16_t, len + 1 );
    #####:  311:	for ( i = 0; i < len; i++ )
    #####:  312:		if ( fscanf( infile, "%hu", &( pItem->data.phoneSeq[ i ] ) ) != 1 )
    #####:  313:			return 0;
    #####:  314:	pItem->data.phoneSeq[ len ] = 0;
        -:  315:
        -:  316:	/* read userfreq & recentTime */
    #####:  317:	if ( fscanf( infile, "%d %d %d %d",
        -:  318:	             &(pItem->data.userfreq),
        -:  319:	             &(pItem->data.recentTime),
        -:  320:	             &(pItem->data.maxfreq),
        -:  321:	             &(pItem->data.origfreq) ) != 4 )
    #####:  322:		return 0;
        -:  323:
        -:  324:	/* set item_index */
    #####:  325:	pItem->item_index = item_index;
        -:  326:
    #####:  327:	return 1;
        -:  328:}
        -:  329:
       33:  330:static FILE *open_file_get_length(
        -:  331:		const char *filename,
        -:  332:		const char *otype, int *size)
        -:  333:{
       33:  334:	FILE *tf = fopen( filename, otype );
       33:  335:	if ( tf == NULL ) {
        8:  336:		return NULL;
        -:  337:	}
       25:  338:	if ( size != NULL ) {
       25:  339:		fseek( tf, 0, SEEK_END );
       25:  340:		*size = ftell( tf );
       25:  341:		fseek( tf, 0, SEEK_SET );
        -:  342:	}
       25:  343:	return tf;
        -:  344:}
        -:  345:
       33:  346:static char *_load_hash_file( const char *filename, int *size )
        -:  347:{
        -:  348:	int flen;
       33:  349:	char *pd = NULL;
        -:  350:	FILE *tf;
        -:  351:
       33:  352:	tf = open_file_get_length( filename, "rb", &flen );
       33:  353:	if ( tf == NULL ) {
        8:  354:		goto err_load_file;
        -:  355:	}
       25:  356:	pd = ALC( char, flen );
       25:  357:	if ( pd == NULL ) {
    #####:  358:		goto err_load_file;
        -:  359:	}
       25:  360:	if ( fread( pd, flen, 1, tf ) != 1 ) {
    #####:  361:		goto err_load_file;
        -:  362:	}
       25:  363:	fclose( tf );
       25:  364:	if ( size != NULL )
       25:  365:		*size = flen;
       25:  366:	return pd;
        -:  367:
        8:  368:err_load_file:
        8:  369:	if ( pd != NULL )
    #####:  370:		free( pd );
        8:  371:	if ( tf != NULL )
    #####:  372:		fclose( tf );
        8:  373:	return NULL;
        -:  374:}
        -:  375:
        -:  376:/* migrate from text-based hash to binary form */
    #####:  377:static int migrate_hash_to_bin( ChewingData *pgdata )
        -:  378:{
        -:  379:	FILE *txtfile;
        -:  380:	char oldname[ 256 ], *dump, *seekdump;
        -:  381:	HASH_ITEM item;
        -:  382:	int item_index, iret, tflen;
        -:  383:	int ret;
    #####:  384:	const char *ofilename = pgdata->static_data.hashfilename;
        -:  385:
        -:  386:	/* allocate dump buffer */
    #####:  387:	txtfile = open_file_get_length( ofilename, "r", &tflen );
    #####:  388:	if ( txtfile == NULL ) {
    #####:  389:		return 0;
        -:  390:	}
    #####:  391:	dump = ALC( char, tflen * 2 );
    #####:  392:	if ( dump == NULL ) {
    #####:  393:		fclose( txtfile );
    #####:  394:		return 0;
        -:  395:	}
    #####:  396:	ret = fscanf( txtfile, "%d", &pgdata->static_data.chewing_lifetime );
    #####:  397:	if ( ret != 1 ) {
    #####:  398:		return 0;
        -:  399:	}
        -:  400:
        -:  401:	/* prepare the bin file */
    #####:  402:	seekdump = dump;
    #####:  403:	memcpy( seekdump, BIN_HASH_SIG, strlen( BIN_HASH_SIG ) );
    #####:  404:	memcpy( seekdump + strlen( BIN_HASH_SIG ),
    #####:  405:	        &pgdata->static_data.chewing_lifetime,
        -:  406:		sizeof(pgdata->static_data.chewing_lifetime) );
    #####:  407:	seekdump += strlen( BIN_HASH_SIG ) + sizeof(pgdata->static_data.chewing_lifetime);
        -:  408:
        -:  409:	/* migrate */
    #####:  410:	item_index = 0;
        -:  411:	while ( 1 ) {
    #####:  412:		iret = ReadHashItem_txt( txtfile, &item, ++item_index );
        -:  413:
    #####:  414:		if ( iret == -1 ) {
    #####:  415:			--item_index;
    #####:  416:			continue;
        -:  417:		}
    #####:  418:		else if ( iret == 0 )
    #####:  419:			break;
        -:  420:
    #####:  421:		HashItem2Binary( seekdump, &item );
    #####:  422:		seekdump += FIELD_SIZE;
    #####:  423:		free( item.data.phoneSeq );
    #####:  424:		free( item.data.wordSeq );
        -:  425:	};
    #####:  426:	fclose( txtfile );
        -:  427:
        -:  428:	/* backup as *.old */
    #####:  429:	strncpy( oldname, ofilename, sizeof(oldname) );
    #####:  430:	strncat( oldname, ".old", sizeof(oldname) - strlen(oldname) - 1 );
    #####:  431:	oldname[ sizeof(oldname) - 1 ] = '\0';
    #####:  432:	PLAT_UNLINK( oldname );
    #####:  433:	PLAT_RENAME( ofilename, oldname );
        -:  434:
        -:  435:	/* dump new file */
    #####:  436:	PLAT_UNLINK( ofilename );
    #####:  437:	txtfile = fopen( ofilename, "w+b" );
    #####:  438:	fwrite( dump, seekdump - dump, 1, txtfile );
    #####:  439:	fflush( txtfile );
    #####:  440:	fclose( txtfile );
    #####:  441:	free( dump );
        -:  442:
    #####:  443:	return 1;
        -:  444:}
        -:  445:
   540672:  446:static void FreeHashItem( HASH_ITEM *aItem )
        -:  447:{
   540723:  448:	while ( aItem ) {
       51:  449:		HASH_ITEM *next = aItem->next;
       51:  450:		free( aItem->data.phoneSeq );
       51:  451:		free( aItem->data.wordSeq );
       51:  452:		free( aItem );
       51:  453:		aItem = next;
        -:  454:	}
   540672:  455:}
        -:  456:
       33:  457:void TerminateHash( ChewingData *pgdata )
        -:  458:{
        -:  459:	HASH_ITEM *pItem;
        -:  460:	int i;
   540705:  461:	for ( i = 0; i < HASH_TABLE_SIZE; ++i ) {
   540672:  462:		pItem = pgdata->static_data.hashtable[ i ];
   540672:  463:		DEBUG_CHECKPOINT();
   540672:  464:		FreeHashItem( pItem );
        -:  465:	}
       33:  466:}
        -:  467:
       33:  468:void setHashFileName( ChewingData *pgdata )
        -:  469:{
        -:  470:	char *path;
        -:  471:
       33:  472:	path = getenv( "CHEWING_USER_PATH" );
        -:  473:
        -:  474:	/* make sure of write permission */
       33:  475:	if ( path && access( path, W_OK ) == 0 ) {
       33:  476:		snprintf( pgdata->static_data.hashfilename, sizeof( pgdata->static_data.hashfilename ),
        -:  477:			"%s" PLAT_SEPARATOR "%s", path, HASH_FILE );
       33:  478:		return;
        -:  479:	}
        -:  480:
    #####:  481:	path = getenv( "HOME" );
    #####:  482:	if ( !path ) {
    #####:  483:		path = PLAT_TMPDIR;
        -:  484:	}
        -:  485:
    #####:  486:	snprintf( pgdata->static_data.hashfilename, sizeof( pgdata->static_data.hashfilename ),
        -:  487:		"%s%s", path, CHEWING_HASH_PATH);
    #####:  488:	PLAT_MKDIR( pgdata->static_data.hashfilename );
    #####:  489:	strcat( pgdata->static_data.hashfilename, PLAT_SEPARATOR );
    #####:  490:	strcat( pgdata->static_data.hashfilename, HASH_FILE );
        -:  491:}
        -:  492:
       33:  493:int InitHash( ChewingData *pgdata )
        -:  494:{
       33:  495:	HASH_ITEM item, *pItem, *pPool = NULL;
       33:  496:	int item_index, hashvalue, iret, fsize, hdrlen, oldest = INT_MAX;
        -:  497:	char *dump, *seekdump;
        -:  498:
       33:  499:	setHashFileName( pgdata );
       33:  500:	memset( pgdata->static_data.hashtable, 0, sizeof( pgdata->static_data.hashtable ) );
        -:  501:
       33:  502:open_hash_file:
       33:  503:	dump = _load_hash_file( pgdata->static_data.hashfilename, &fsize );
       33:  504:	hdrlen = strlen( BIN_HASH_SIG ) + sizeof(pgdata->static_data.chewing_lifetime);
       33:  505:	item_index = 0;
       41:  506:	if ( dump == NULL || fsize < hdrlen ) {
        -:  507:		FILE *outfile;
        8:  508:		outfile = fopen( pgdata->static_data.hashfilename, "w+b" );
        8:  509:		if ( ! outfile ) {
    #####:  510:			if ( dump ) {
    #####:  511:				free( dump );
        -:  512:			}
    #####:  513:			return 0;
        -:  514:		}
        8:  515:		pgdata->static_data.chewing_lifetime = 0;
        8:  516:		fwrite( BIN_HASH_SIG, 1, strlen( BIN_HASH_SIG ), outfile );
        8:  517:		fwrite( &pgdata->static_data.chewing_lifetime, 1,
        -:  518:		                sizeof(pgdata->static_data.chewing_lifetime), outfile );
        8:  519:		fclose( outfile );
        -:  520:	}
        -:  521:	else {
       25:  522:		if ( memcmp(dump, BIN_HASH_SIG, strlen(BIN_HASH_SIG)) != 0 ) {
        -:  523:			/* perform migrate from text-based to binary form */
    #####:  524:			free( dump );
    #####:  525:			if ( ! migrate_hash_to_bin( pgdata ) ) {
    #####:  526:				return  0;
        -:  527:			}
    #####:  528:			goto open_hash_file;
        -:  529:		}
        -:  530:
       25:  531:		pgdata->static_data.chewing_lifetime = *(int *) (dump + strlen( BIN_HASH_SIG ));
       25:  532:		seekdump = dump + hdrlen;
       25:  533:		fsize -= hdrlen;
        -:  534:
       63:  535:		while ( fsize >= FIELD_SIZE ) {
       38:  536:			iret = ReadHashItem_bin( seekdump, &item, item_index++ );
        -:  537:			/* Ignore illegal data */
       38:  538:			if ( iret == -1 ) {
    #####:  539:				seekdump += FIELD_SIZE;
    #####:  540:				fsize -= FIELD_SIZE;
    #####:  541:				--item_index;
    #####:  542:				continue;
        -:  543:			}
       38:  544:			else if ( iret == 0 )
    #####:  545:				break;
        -:  546:
       38:  547:			pItem = ALC( HASH_ITEM, 1 );
       38:  548:			memcpy( pItem, &item, sizeof( HASH_ITEM ) );
       38:  549:			pItem->next = pPool;
       38:  550:			pPool = pItem;
        -:  551:
       38:  552:			if ( oldest > pItem->data.recentTime ) {
       38:  553:				oldest = pItem->data.recentTime;
        -:  554:			}
        -:  555:
       38:  556:			seekdump += FIELD_SIZE;
       38:  557:			fsize -= FIELD_SIZE;
        -:  558:		}
       25:  559:		free( dump );
        -:  560:
       63:  561:		while ( pPool ) {
       38:  562:			pItem = pPool;
       38:  563:			pPool = pItem->next;
        -:  564:
       38:  565:			hashvalue = HashFunc( pItem->data.phoneSeq );
       38:  566:			pItem->next = pgdata->static_data.hashtable[ hashvalue ];
       38:  567:			pgdata->static_data.hashtable[ hashvalue ] = pItem;
       38:  568:			pItem->data.recentTime -= oldest;
        -:  569:		}
       25:  570:		pgdata->static_data.chewing_lifetime -= oldest;
        -:  571:	}
       33:  572:	return 1;
        -:  573:}
        -:  574:
