        -:    0:Source:/home/workspace/src/mod_aux.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/mod_aux.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/mod_aux.gcda
        -:    0:Runs:1
        -:    1:/*
        -:    2: * mod_aux.c
        -:    3: *
        -:    4: * Copyright (c) 2005, 2006, 2008
        -:    5: *	libchewing Core Team. See ChangeLog for details.
        -:    6: *
        -:    7: * See the file "COPYING" for information on usage and redistribution
        -:    8: * of this file.
        -:    9: */
        -:   10:
        -:   11:/**
        -:   12: * @file mod_aux.c
        -:   13: * @brief Auxiliary module
        -:   14: */
        -:   15:
        -:   16:#include <string.h>
        -:   17:#include <stdlib.h>
        -:   18:
        -:   19:#include "global.h"
        -:   20:#include "chewing-private.h"
        -:   21:#include "zuin-private.h"
        -:   22:#include "chewingio.h"
        -:   23:
        -:   24:/**
        -:   25: * @param ctx handle to Chewing IM context
        -:   26: * @retval TRUE if it currnet input state is at the "end-of-a-char"
        -:   27: */
       36:   28:CHEWING_API int chewing_commit_Check( ChewingContext *ctx )
        -:   29:{
       36:   30:	return !!(ctx->output->keystrokeRtn & KEYSTROKE_COMMIT);
        -:   31:}
        -:   32:
        -:   33:/**
        -:   34: * @param ctx handle to Chewing IM context
        -:   35: *
        -:   36: * retrun current commit string, regardless current input state.
        -:   37: * Alwasy returns a char pointer, caller must free it.
        -:   38: */
       29:   39:CHEWING_API char *chewing_commit_String( ChewingContext *ctx )
        -:   40:{
        -:   41:	int i;
       29:   42:	char *s = (char *) calloc(
       29:   43:		1 + ctx->output->nCommitStr,
        -:   44:		MAX_UTF8_SIZE );
       29:   45:	if ( s ) {
       64:   46:		for ( i = 0; i < ctx->output->nCommitStr; i++ ) {
       35:   47:			strcat( s, (char *) (ctx->output->commitStr[ i ].s) );
        -:   48:		}
        -:   49:	}
       29:   50:	return s;
        -:   51:}
        -:   52:
        8:   53:CHEWING_API int chewing_buffer_Check( ChewingContext *ctx )
        -:   54:{
        8:   55:	return (ctx->output->chiSymbolBufLen != 0);
        -:   56:}
        -:   57:
       11:   58:CHEWING_API int chewing_buffer_Len( ChewingContext *ctx )
        -:   59:{
       11:   60:	return ctx->output->chiSymbolBufLen;
        -:   61:}
        -:   62:
        8:   63:CHEWING_API char *chewing_buffer_String( ChewingContext *ctx )
        -:   64:{
        -:   65:	int i;
        8:   66:	char *s = (char *) calloc(
        8:   67:		1 + ctx->output->chiSymbolBufLen,
        -:   68:		MAX_UTF8_SIZE );
        8:   69:	if ( s ) {
       40:   70:		for ( i = 0; i < ctx->output->chiSymbolBufLen; i++ ) {
       32:   71:			strcat( s, (char *) (ctx->output->chiSymbolBuf[ i ].s) );
        -:   72:		}
        -:   73:	}
        8:   74:	return s;
        -:   75:}
        -:   76:
        -:   77:/**
        -:   78: * @param ctx handle to Chewing IM context
        -:   79: * @param zuin_count pointer to the integer of available Zuin preedit string
        -:   80: *
        -:   81: * Always returns a char pointer, caller must free it.
        -:   82: */
        8:   83:CHEWING_API char *chewing_zuin_String( ChewingContext *ctx, int *zuin_count )
        -:   84:{
        -:   85:	char *s;
        -:   86:	int i;
        8:   87:	if ( zuin_count )
        8:   88:		*zuin_count = 0;
        8:   89:	s = (char*) calloc(
        -:   90:		1 + ZUIN_SIZE,
        -:   91:		sizeof(ctx->output->zuinBuf[ 0 ].s) );
        8:   92:	if ( s ) {
       40:   93:		for ( i = 0; i < ZUIN_SIZE; i++ ) {
       32:   94:			if ( ctx->output->zuinBuf[ i ].s[ 0 ] != '\0' ) {
        7:   95:				strcat( s, (char *) (ctx->output->zuinBuf[ i ].s) );
        7:   96:				if ( zuin_count )
        7:   97:					(*zuin_count)++;
        -:   98:			}
        -:   99:		}
        -:  100:	}
        8:  101:	return s;
        -:  102:}
        -:  103:
        8:  104:CHEWING_API int chewing_zuin_Check( ChewingContext *ctx )
        -:  105:{
        -:  106:	int i;
        -:  107:
       28:  108:	for ( i = 0; i < ZUIN_SIZE; ++i ) {
       24:  109:		if ( ctx->output->zuinBuf[ i ].s[ 0 ] != '\0' ) {
        4:  110:			return 0;
        -:  111:		}
        -:  112:	}
        4:  113:	return 1;
        -:  114:}
        -:  115:
        8:  116:CHEWING_API int chewing_cursor_Current( ChewingContext *ctx )
        -:  117:{
        8:  118:	return (ctx->output->chiSymbolCursor);
        -:  119:}
        -:  120:
    #####:  121:CHEWING_API int chewing_cand_CheckDone( ChewingContext *ctx )
        -:  122:{
    #####:  123:	return (! ctx->output->pci);
        -:  124:}
        -:  125:
    #####:  126:CHEWING_API int chewing_cand_TotalPage( ChewingContext *ctx )
        -:  127:{
    #####:  128:	return (ctx->output->pci ? ctx->output->pci->nPage : 0);
        -:  129:}
        -:  130:
    #####:  131:CHEWING_API int chewing_cand_ChoicePerPage( ChewingContext *ctx )
        -:  132:{
    #####:  133:	return (ctx->output->pci ? ctx->output->pci->nChoicePerPage : 0);
        -:  134:}
        -:  135:
       16:  136:CHEWING_API int chewing_cand_TotalChoice( ChewingContext *ctx )
        -:  137:{
      16*:  138:	return (ctx->output->pci ? ctx->output->pci->nTotalChoice : 0);
        -:  139:}
        -:  140:
    #####:  141:CHEWING_API int chewing_cand_CurrentPage( ChewingContext *ctx )
        -:  142:{
    #####:  143:	return (ctx->output->pci ? ctx->output->pci->pageNo : -1);
        -:  144:}
        -:  145:
       23:  146:CHEWING_API void chewing_cand_Enumerate( ChewingContext *ctx )
        -:  147:{
       23:  148:	ctx->cand_no = ctx->output->pci->pageNo * ctx->output->pci->nChoicePerPage;
       23:  149:}
        -:  150:
       40:  151:CHEWING_API int chewing_cand_hasNext( ChewingContext *ctx )
        -:  152:{
       40:  153:	return (ctx->cand_no < ctx->output->pci->nTotalChoice);
        -:  154:}
        -:  155:
       29:  156:CHEWING_API char *chewing_cand_String( ChewingContext *ctx )
        -:  157:{
        -:  158:	char *s;
       29:  159:	if ( chewing_cand_hasNext( ctx ) ) {
       24:  160:		s = strdup( ctx->output->pci->totalChoiceStr[ ctx->cand_no ] );
       24:  161:		ctx->cand_no++;
        -:  162:	} else {
        5:  163:		s = strdup( "" );
        -:  164:	}
       29:  165:	return s;
        -:  166:}
        -:  167:
        6:  168:CHEWING_API char *chewing_cand_String_by_index( ChewingContext *ctx, int index )
        -:  169:{
        -:  170:	char *s;
        -:  171:
        6:  172:	if ( 0 <= index && index < ctx->output->pci->nTotalChoice ) {
        6:  173:		s = strdup( ctx->output->pci->totalChoiceStr[ index ] );
        -:  174:	} else {
    #####:  175:		s = strdup( "" );
        -:  176:	}
        6:  177:	return s;
        -:  178:}
        -:  179:
        5:  180:CHEWING_API void chewing_interval_Enumerate( ChewingContext *ctx )
        -:  181:{
        5:  182:	ctx->it_no = 0;
        5:  183:}
        -:  184:
       18:  185:CHEWING_API int chewing_interval_hasNext( ChewingContext *ctx )
        -:  186:{
       18:  187:	return (ctx->it_no < ctx->output->nDispInterval);
        -:  188:}
        -:  189:
        7:  190:CHEWING_API void chewing_interval_Get( ChewingContext *ctx, IntervalType *it )
        -:  191:{
        7:  192:	if ( chewing_interval_hasNext( ctx ) ) {
        7:  193:		if ( it ) {
        7:  194:			it->from = ctx->output->dispInterval[ ctx->it_no ].from;
        7:  195:			it->to = ctx->output->dispInterval[ ctx->it_no ].to;
        -:  196:		}
        7:  197:		ctx->it_no++;
        -:  198:	}
        7:  199:}
        -:  200:
    #####:  201:CHEWING_API int chewing_aux_Check( ChewingContext *ctx )
        -:  202:{
    #####:  203:	return (ctx->output->bShowMsg);
        -:  204:}
        -:  205:
    #####:  206:CHEWING_API int chewing_aux_Length( ChewingContext *ctx )
        -:  207:{
    #####:  208:	return (ctx->output->bShowMsg ? ctx->output->showMsgLen : 0);
        -:  209:}
        -:  210:
    #####:  211:CHEWING_API char *chewing_aux_String( ChewingContext *ctx )
        -:  212:{
        -:  213:	int i;
    #####:  214:	char *msg = (char *) calloc(
    #####:  215:		1 + ctx->output->showMsgLen,
        -:  216:		MAX_UTF8_SIZE );
    #####:  217:	if ( msg ) {
    #####:  218:		for ( i = 0; i < ctx->output->showMsgLen; ++i )
    #####:  219:			strcat( msg, (char *)(ctx->output->showMsg[ i ].s) );
        -:  220:	}
    #####:  221:	return msg;
        -:  222:
        -:  223:}
        -:  224:
        7:  225:CHEWING_API int chewing_keystroke_CheckIgnore( ChewingContext *ctx )
        -:  226:{
        7:  227:	return !!(ctx->output->keystrokeRtn & KEYSTROKE_IGNORE);
        -:  228:}
        -:  229:
        7:  230:CHEWING_API int chewing_keystroke_CheckAbsorb( ChewingContext *ctx )
        -:  231:{
        7:  232:	return !!(ctx->output->keystrokeRtn & KEYSTROKE_ABSORB);
        -:  233:}
        -:  234:
    #####:  235:CHEWING_API int chewing_kbtype_Total( ChewingContext *ctx UNUSED )
        -:  236:{
    #####:  237:	return KB_TYPE_NUM;
        -:  238:}
        -:  239:
    #####:  240:CHEWING_API void chewing_kbtype_Enumerate( ChewingContext *ctx )
        -:  241:{
    #####:  242:	ctx->kb_no = 0;
    #####:  243:}
        -:  244:
    #####:  245:CHEWING_API int chewing_kbtype_hasNext( ChewingContext *ctx )
        -:  246:{
    #####:  247:	return ctx->kb_no < KB_TYPE_NUM;
        -:  248:}
        -:  249:
        -:  250:extern const char * const kb_type_str[];
        -:  251:
    #####:  252:CHEWING_API char *chewing_kbtype_String( ChewingContext *ctx )
        -:  253:{
        -:  254:	char *s;
    #####:  255:	if ( chewing_kbtype_hasNext( ctx ) ) {
    #####:  256:		s = strdup( kb_type_str[ ctx->kb_no ] );
    #####:  257:		ctx->kb_no++;
        -:  258:	}
        -:  259:	else {
    #####:  260:		s = strdup( "" );
        -:  261:	}
    #####:  262:	return s;
        -:  263:}
