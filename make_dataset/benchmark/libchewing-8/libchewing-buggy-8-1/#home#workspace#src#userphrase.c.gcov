        -:    0:Source:/home/workspace/src/userphrase.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/userphrase.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/userphrase.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * userphrase.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2006
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:#include <stdlib.h>
        -:   16:#include <string.h>
        -:   17:#include <stdio.h>
        -:   18:
        -:   19:#include "chewing-utf8-util.h"
        -:   20:#include "hash-private.h"
        -:   21:#include "dict-private.h"
        -:   22:#include "tree-private.h"
        -:   23:#include "userphrase-private.h"
        -:   24:#include "private.h"
        -:   25:
        -:   26:/* load the orginal frequency from the static dict */
       13:   27:static int LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )
        -:   28:{
        -:   29:	const TreeType *tree_pos;
        -:   30:	int retval;
       13:   31:	Phrase *phrase = ALC( Phrase, 1 );
        -:   32:
       13:   33:	tree_pos = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );
       13:   34:	if ( tree_pos ) {
       13:   35:		GetPhraseFirst( pgdata, phrase, tree_pos );
        -:   36:		do {
        -:   37:			/* find the same phrase */
       59:   38:			if ( ! strcmp(
       59:   39:				phrase->phrase,
        -:   40:				wordSeq ) ) {
       13:   41:				retval = phrase->freq;
       13:   42:				free( phrase );
       13:   43:				return retval;
        -:   44:			}
       46:   45:		} while ( GetVocabNext( pgdata, phrase ) );
        -:   46:	}
        -:   47:
    #####:   48:	free( phrase );
    #####:   49:	return FREQ_INIT_VALUE;
        -:   50:}
        -:   51:
        -:   52:/* find the maximum frequency of the same phrase */
       26:   53:static int LoadMaxFreq( ChewingData *pgdata, const uint16_t phoneSeq[], int len )
        -:   54:{
        -:   55:	const TreeType *tree_pos;
       26:   56:	Phrase *phrase = ALC( Phrase, 1 );
       26:   57:	int maxFreq = FREQ_INIT_VALUE;
        -:   58:	UserPhraseData *uphrase;
        -:   59:
       26:   60:	tree_pos = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );
       26:   61:	if ( tree_pos ) {
       26:   62:		GetPhraseFirst( pgdata, phrase, tree_pos );
        -:   63:		do {
      504:   64:			if ( phrase->freq > maxFreq )
        6:   65:				maxFreq = phrase->freq;
      504:   66:		} while( GetVocabNext( pgdata, phrase ) );
        -:   67:	}
       26:   68:	free( phrase );
        -:   69:
       26:   70:	uphrase = UserGetPhraseFirst( pgdata, phoneSeq );
      111:   71:	while ( uphrase ) {
       85:   72:		if ( uphrase->userfreq > maxFreq )
       16:   73:			maxFreq = uphrase->userfreq;
       85:   74:		uphrase = UserGetPhraseNext( pgdata, phoneSeq );
        -:   75:	}
        -:   76:
       26:   77:	return maxFreq;
        -:   78:}
        -:   79:
        -:   80:/* compute the new updated freqency */
       13:   81:static int UpdateFreq( int freq, int maxfreq, int origfreq, int deltatime )
        -:   82:{
        -:   83:	int delta;
        -:   84:
        -:   85:	/* Short interval */
       13:   86:	if ( deltatime < 4000 ) {
       13:   87:		delta = ( freq >= maxfreq ) ?
        1:   88:			min(
        1:   89:				( maxfreq - origfreq ) / 5 + 1,
       13:   90:				SHORT_INCREASE_FREQ ) :
       12:   91:			max(
       12:   92:				( maxfreq - origfreq ) / 5 + 1,
        -:   93:				SHORT_INCREASE_FREQ );
       13:   94:		return min( freq + delta, MAX_ALLOW_FREQ );
        -:   95:	}
        -:   96:	/* Medium interval */
    #####:   97:	else if ( deltatime < 50000 ) {
    #####:   98:		delta = ( freq >= maxfreq ) ?
    #####:   99:			min(
    #####:  100:				( maxfreq - origfreq ) / 10 + 1,
    #####:  101:				MEDIUM_INCREASE_FREQ ) :
    #####:  102:			max(
    #####:  103:				( maxfreq - origfreq ) / 10 + 1,
        -:  104:				MEDIUM_INCREASE_FREQ );
    #####:  105:		return min( freq + delta, MAX_ALLOW_FREQ );
        -:  106:	}
        -:  107:	/* long interval */
        -:  108:	else {
    #####:  109:		delta = max( ( freq - origfreq ) / 5, LONG_DECREASE_FREQ );
    #####:  110:		return max( freq - delta, origfreq );
        -:  111:	}
        -:  112:}
        -:  113:
       26:  114:static void LogUserPhrase(
        -:  115:	ChewingData *pgdata,
        -:  116:	const uint16_t phoneSeq[],
        -:  117:	const char wordSeq[],
        -:  118:	int orig_freq,
        -:  119:	int max_freq,
        -:  120:	int user_freq,
        -:  121:	int recent_time)
        -:  122:{
        -:  123:	/* Size of each phone is len("0x1234 ") = 7 */
       26:  124:	char buf[7 * MAX_PHRASE_LEN + 1] = { 0 };
        -:  125:	int i;
        -:  126:
       62:  127:	for ( i = 0; i < MAX_PHRASE_LEN; ++i ) {
       62:  128:		if ( phoneSeq[i] == 0 )
       26:  129:			break;
       36:  130:		snprintf( buf + 7 * i, 7 + 1, "%#06x ", phoneSeq[i] );
        -:  131:	}
        -:  132:
       26:  133:	LOG_INFO( "userphrase %s, phone = %s, orig_freq = %d, max_freq = %d, user_freq = %d, recent_time = %d\n",
        -:  134:		wordSeq, buf, orig_freq, max_freq, user_freq, recent_time );
       26:  135:}
        -:  136:
       26:  137:int UserUpdatePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )
        -:  138:{
        -:  139:	HASH_ITEM *pItem;
        -:  140:	UserPhraseData data;
        -:  141:	int len;
        -:  142:
       26:  143:	len = ueStrLen( wordSeq );
       26:  144:	pItem = HashFindEntry( pgdata, phoneSeq, wordSeq );
       26:  145:	if ( ! pItem ) {
       13:  146:		if ( ! AlcUserPhraseSeq( &data, len, strlen( wordSeq ) ) ) {
    #####:  147:			return USER_UPDATE_FAIL;
        -:  148:		}
        -:  149:
       13:  150:		memcpy( data.phoneSeq, phoneSeq, len * sizeof( phoneSeq[ 0 ] ) );
       13:  151:		data.phoneSeq[ len ] = 0;
       13:  152:		strcpy( data.wordSeq, wordSeq );
        -:  153:
        -:  154:		/* load initial freq */
       13:  155:		data.origfreq = LoadOriginalFreq( pgdata, phoneSeq, wordSeq, len );
       13:  156:		data.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );
        -:  157:
       13:  158:		data.userfreq = data.origfreq;
       13:  159:		data.recentTime = pgdata->static_data.chewing_lifetime;
       13:  160:		pItem = HashInsert( pgdata, &data );
       13:  161:		LogUserPhrase( pgdata, phoneSeq, wordSeq, pItem->data.origfreq, pItem->data.maxfreq, pItem->data.userfreq, pItem->data.recentTime );
       13:  162:		HashModify( pgdata, pItem );
       13:  163:		return USER_UPDATE_INSERT;
        -:  164:	}
        -:  165:	else {
       13:  166:		pItem->data.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );
       26:  167:		pItem->data.userfreq = UpdateFreq(
        -:  168:			pItem->data.userfreq,
        -:  169:			pItem->data.maxfreq,
        -:  170:			pItem->data.origfreq,
       13:  171:			pgdata->static_data.chewing_lifetime - pItem->data.recentTime );
       13:  172:		pItem->data.recentTime = pgdata->static_data.chewing_lifetime;
       13:  173:		LogUserPhrase( pgdata, phoneSeq, wordSeq, pItem->data.origfreq, pItem->data.maxfreq, pItem->data.userfreq, pItem->data.recentTime );
       13:  174:		HashModify( pgdata, pItem );
       13:  175:		return USER_UPDATE_MODIFY;
        -:  176:	}
        -:  177:}
        -:  178:
     2186:  179:UserPhraseData *UserGetPhraseFirst( ChewingData *pgdata, const uint16_t phoneSeq[] )
        -:  180:{
     2186:  181:	pgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, NULL );
     2186:  182:	if ( ! pgdata->prev_userphrase )
     2027:  183:		return NULL;
      159:  184:	return &( pgdata->prev_userphrase->data );
        -:  185:}
        -:  186:
      281:  187:UserPhraseData *UserGetPhraseNext( ChewingData *pgdata, const uint16_t phoneSeq[] )
        -:  188:{
      281:  189:	pgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, pgdata->prev_userphrase );
      281:  190:	if ( ! pgdata->prev_userphrase )
       90:  191:		return NULL;
      191:  192:	return &( pgdata->prev_userphrase->data );
        -:  193:}
        -:  194:
