        -:    0:Source:/home/workspace/md4c/md4c.c
        -:    0:Programs:5
        -:    1:/*
        -:    2: * MD4C: Markdown parser for C
        -:    3: * (http://github.com/mity/md4c)
        -:    4: *
        -:    5: * Copyright (c) 2016-2019 Martin Mitas
        -:    6: *
        -:    7: * Permission is hereby granted, free of charge, to any person obtaining a
        -:    8: * copy of this software and associated documentation files (the "Software"),
        -:    9: * to deal in the Software without restriction, including without limitation
        -:   10: * the rights to use, copy, modify, merge, publish, distribute, sublicense,
        -:   11: * and/or sell copies of the Software, and to permit persons to whom the
        -:   12: * Software is furnished to do so, subject to the following conditions:
        -:   13: *
        -:   14: * The above copyright notice and this permission notice shall be included in
        -:   15: * all copies or substantial portions of the Software.
        -:   16: *
        -:   17: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        -:   18: * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   19: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   20: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   21: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        -:   22: * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
        -:   23: * IN THE SOFTWARE.
        -:   24: */
        -:   25:
        -:   26:#include "md4c.h"
        -:   27:
        -:   28:#include <limits.h>
        -:   29:#include <stdio.h>
        -:   30:#include <stdlib.h>
        -:   31:#include <string.h>
        -:   32:
        -:   33:
        -:   34:/*****************************
        -:   35: ***  Miscellaneous Stuff  ***
        -:   36: *****************************/
        -:   37:
        -:   38:#ifdef _MSC_VER
        -:   39:    /* MSVC does not understand "inline" when building as pure C (not C++).
        -:   40:     * However it understands "__inline" */
        -:   41:    #ifndef __cplusplus
        -:   42:        #define inline __inline
        -:   43:    #endif
        -:   44:#endif
        -:   45:
        -:   46:#ifdef _T
        -:   47:    #undef _T
        -:   48:#endif
        -:   49:#if defined MD4C_USE_UTF16
        -:   50:    #define _T(x)           L##x
        -:   51:#else
        -:   52:    #define _T(x)           x
        -:   53:#endif
        -:   54:
        -:   55:/* Misc. macros. */
        -:   56:#define SIZEOF_ARRAY(a)     (sizeof(a) / sizeof(a[0]))
        -:   57:
        -:   58:#define STRINGIZE_(x)       #x
        -:   59:#define STRINGIZE(x)        STRINGIZE_(x)
        -:   60:
        -:   61:#ifndef TRUE
        -:   62:    #define TRUE            1
        -:   63:    #define FALSE           0
        -:   64:#endif
        -:   65:
        -:   66:
        -:   67:/************************
        -:   68: ***  Internal Types  ***
        -:   69: ************************/
        -:   70:
        -:   71:/* These are omnipresent so lets save some typing. */
        -:   72:#define CHAR    MD_CHAR
        -:   73:#define SZ      MD_SIZE
        -:   74:#define OFF     MD_OFFSET
        -:   75:
        -:   76:typedef struct MD_MARK_tag MD_MARK;
        -:   77:typedef struct MD_BLOCK_tag MD_BLOCK;
        -:   78:typedef struct MD_CONTAINER_tag MD_CONTAINER;
        -:   79:typedef struct MD_REF_DEF_tag MD_REF_DEF;
        -:   80:
        -:   81:
        -:   82:/* During analyzes of inline marks, we need to manage some "mark chains",
        -:   83: * of (yet unresolved) openers. This structure holds start/end of the chain.
        -:   84: * The chain internals are then realized through MD_MARK::prev and ::next.
        -:   85: */
        -:   86:typedef struct MD_MARKCHAIN_tag MD_MARKCHAIN;
        -:   87:struct MD_MARKCHAIN_tag {
        -:   88:    int head;   /* Index of first mark in the chain, or -1 if empty. */
        -:   89:    int tail;   /* Index of last mark in the chain, or -1 if empty. */
        -:   90:};
        -:   91:
        -:   92:/* Context propagated through all the parsing. */
        -:   93:typedef struct MD_CTX_tag MD_CTX;
        -:   94:struct MD_CTX_tag {
        -:   95:    /* Immutable stuff (parameters of md_parse()). */
        -:   96:    const CHAR* text;
        -:   97:    SZ size;
        -:   98:    MD_PARSER parser;
        -:   99:    void* userdata;
        -:  100:
        -:  101:    /* Helper temporary growing buffer. */
        -:  102:    CHAR* buffer;
        -:  103:    unsigned alloc_buffer;
        -:  104:
        -:  105:    /* Reference definitions. */
        -:  106:    MD_REF_DEF* ref_defs;
        -:  107:    int n_ref_defs;
        -:  108:    int alloc_ref_defs;
        -:  109:    void** ref_def_hashtable;
        -:  110:    int ref_def_hashtable_size;
        -:  111:
        -:  112:    /* Stack of inline/span markers.
        -:  113:     * This is only used for parsing a single block contents but by storing it
        -:  114:     * here we may reuse the stack for subsequent blocks; i.e. we have fewer
        -:  115:     * (re)allocations. */
        -:  116:    MD_MARK* marks;
        -:  117:    int n_marks;
        -:  118:    int alloc_marks;
        -:  119:
        -:  120:#if defined MD4C_USE_UTF16
        -:  121:    char mark_char_map[128];
        -:  122:#else
        -:  123:    char mark_char_map[256];
        -:  124:#endif
        -:  125:
        -:  126:    /* For resolving of inline spans. */
        -:  127:    MD_MARKCHAIN mark_chains[11];
        -:  128:#define PTR_CHAIN                               ctx->mark_chains[0]
        -:  129:#define TABLECELLBOUNDARIES                     ctx->mark_chains[1]
        -:  130:#define ASTERISK_OPENERS_extraword_mod3_0       ctx->mark_chains[2]
        -:  131:#define ASTERISK_OPENERS_extraword_mod3_1       ctx->mark_chains[3]
        -:  132:#define ASTERISK_OPENERS_extraword_mod3_2       ctx->mark_chains[4]
        -:  133:#define ASTERISK_OPENERS_intraword_mod3_0       ctx->mark_chains[5]
        -:  134:#define ASTERISK_OPENERS_intraword_mod3_1       ctx->mark_chains[6]
        -:  135:#define ASTERISK_OPENERS_intraword_mod3_2       ctx->mark_chains[7]
        -:  136:#define UNDERSCORE_OPENERS                      ctx->mark_chains[8]
        -:  137:#define TILDE_OPENERS                           ctx->mark_chains[9]
        -:  138:#define BRACKET_OPENERS                         ctx->mark_chains[10]
        -:  139:#define OPENERS_CHAIN_FIRST                     2
        -:  140:#define OPENERS_CHAIN_LAST                      10
        -:  141:
        -:  142:    int n_table_cell_boundaries;
        -:  143:
        -:  144:    /* For resolving links. */
        -:  145:    int unresolved_link_head;
        -:  146:    int unresolved_link_tail;
        -:  147:
        -:  148:    /* For resolving raw HTML. */
        -:  149:    OFF html_comment_horizon;
        -:  150:    OFF html_proc_instr_horizon;
        -:  151:    OFF html_decl_horizon;
        -:  152:    OFF html_cdata_horizon;
        -:  153:
        -:  154:    /* For block analysis.
        -:  155:     * Notes:
        -:  156:     *   -- It holds MD_BLOCK as well as MD_LINE structures. After each
        -:  157:     *      MD_BLOCK, its (multiple) MD_LINE(s) follow.
        -:  158:     *   -- For MD_BLOCK_HTML and MD_BLOCK_CODE, MD_VERBATIMLINE(s) are used
        -:  159:     *      instead of MD_LINE(s).
        -:  160:     */
        -:  161:    void* block_bytes;
        -:  162:    MD_BLOCK* current_block;
        -:  163:    int n_block_bytes;
        -:  164:    int alloc_block_bytes;
        -:  165:
        -:  166:    /* For container block analysis. */
        -:  167:    MD_CONTAINER* containers;
        -:  168:    int n_containers;
        -:  169:    int alloc_containers;
        -:  170:
        -:  171:    /* Minimal indentation to call the block "indented code block". */
        -:  172:    unsigned code_indent_offset;
        -:  173:
        -:  174:    /* Contextual info for line analysis. */
        -:  175:    SZ code_fence_length;   /* For checking closing fence length. */
        -:  176:    int html_block_type;    /* For checking closing raw HTML condition. */
        -:  177:    int last_line_has_list_loosening_effect;
        -:  178:    int last_list_item_starts_with_two_blank_lines;
        -:  179:};
        -:  180:
        -:  181:typedef enum MD_LINETYPE_tag MD_LINETYPE;
        -:  182:enum MD_LINETYPE_tag {
        -:  183:    MD_LINE_BLANK,
        -:  184:    MD_LINE_HR,
        -:  185:    MD_LINE_ATXHEADER,
        -:  186:    MD_LINE_SETEXTHEADER,
        -:  187:    MD_LINE_SETEXTUNDERLINE,
        -:  188:    MD_LINE_INDENTEDCODE,
        -:  189:    MD_LINE_FENCEDCODE,
        -:  190:    MD_LINE_HTML,
        -:  191:    MD_LINE_TEXT,
        -:  192:    MD_LINE_TABLE,
        -:  193:    MD_LINE_TABLEUNDERLINE
        -:  194:};
        -:  195:
        -:  196:typedef struct MD_LINE_ANALYSIS_tag MD_LINE_ANALYSIS;
        -:  197:struct MD_LINE_ANALYSIS_tag {
        -:  198:    MD_LINETYPE type    : 16;
        -:  199:    unsigned data       : 16;
        -:  200:    OFF beg;
        -:  201:    OFF end;
        -:  202:    unsigned indent;        /* Indentation level. */
        -:  203:};
        -:  204:
        -:  205:typedef struct MD_LINE_tag MD_LINE;
        -:  206:struct MD_LINE_tag {
        -:  207:    OFF beg;
        -:  208:    OFF end;
        -:  209:};
        -:  210:
        -:  211:typedef struct MD_VERBATIMLINE_tag MD_VERBATIMLINE;
        -:  212:struct MD_VERBATIMLINE_tag {
        -:  213:    OFF beg;
        -:  214:    OFF end;
        -:  215:    OFF indent;
        -:  216:};
        -:  217:
        -:  218:
        -:  219:/*******************
        -:  220: ***  Debugging  ***
        -:  221: *******************/
        -:  222:
        -:  223:#define MD_LOG(msg)                                                     \
        -:  224:    do {                                                                \
        -:  225:        if(ctx->parser.debug_log != NULL)                               \
        -:  226:            ctx->parser.debug_log((msg), ctx->userdata);                \
        -:  227:    } while(0)
        -:  228:
        -:  229:#ifdef DEBUG
        -:  230:    #define MD_ASSERT(cond)                                             \
        -:  231:            do {                                                        \
        -:  232:                if(!(cond)) {                                           \
        -:  233:                    MD_LOG(__FILE__ ":" STRINGIZE(__LINE__) ": "        \
        -:  234:                           "Assertion '" STRINGIZE(cond) "' failed.");  \
        -:  235:                    exit(1);                                            \
        -:  236:                }                                                       \
        -:  237:            } while(0)
        -:  238:
        -:  239:    #define MD_UNREACHABLE()        MD_ASSERT(1 == 0)
        -:  240:#else
        -:  241:    #ifdef __GNUC__
        -:  242:        #define MD_ASSERT(cond)     do { if(!(cond)) __builtin_unreachable(); } while(0)
        -:  243:        #define MD_UNREACHABLE()    do { __builtin_unreachable(); } while(0)
        -:  244:    #elif defined _MSC_VER  &&  _MSC_VER > 120
        -:  245:        #define MD_ASSERT(cond)     do { __assume(cond); } while(0)
        -:  246:        #define MD_UNREACHABLE()    do { __assume(0); } while(0)
        -:  247:    #else
        -:  248:        #define MD_ASSERT(cond)     do {} while(0)
        -:  249:        #define MD_UNREACHABLE()    do {} while(0)
        -:  250:    #endif
        -:  251:#endif
        -:  252:
        -:  253:
        -:  254:/*****************
        -:  255: ***  Helpers  ***
        -:  256: *****************/
        -:  257:
        -:  258:/* Character accessors. */
        -:  259:#define CH(off)                 (ctx->text[(off)])
        -:  260:#define STR(off)                (ctx->text + (off))
        -:  261:
        -:  262:/* Character classification.
        -:  263: * Note we assume ASCII compatibility of code points < 128 here. */
        -:  264:#define ISIN_(ch, ch_min, ch_max)       ((ch_min) <= (unsigned)(ch) && (unsigned)(ch) <= (ch_max))
        -:  265:#define ISANYOF_(ch, palette)           (md_strchr((palette), (ch)) != NULL)
        -:  266:#define ISANYOF2_(ch, ch1, ch2)         ((ch) == (ch1) || (ch) == (ch2))
        -:  267:#define ISANYOF3_(ch, ch1, ch2, ch3)    ((ch) == (ch1) || (ch) == (ch2) || (ch) == (ch3))
        -:  268:#define ISASCII_(ch)                    ((unsigned)(ch) <= 127)
        -:  269:#define ISBLANK_(ch)                    (ISANYOF2_((ch), _T(' '), _T('\t')))
        -:  270:#define ISNEWLINE_(ch)                  (ISANYOF2_((ch), _T('\r'), _T('\n')))
        -:  271:#define ISWHITESPACE_(ch)               (ISBLANK_(ch) || ISANYOF2_((ch), _T('\v'), _T('\f')))
        -:  272:#define ISCNTRL_(ch)                    ((unsigned)(ch) <= 31 || (unsigned)(ch) == 127)
        -:  273:#define ISPUNCT_(ch)                    (ISIN_(ch, 33, 47) || ISIN_(ch, 58, 64) || ISIN_(ch, 91, 96) || ISIN_(ch, 123, 126))
        -:  274:#define ISUPPER_(ch)                    (ISIN_(ch, _T('A'), _T('Z')))
        -:  275:#define ISLOWER_(ch)                    (ISIN_(ch, _T('a'), _T('z')))
        -:  276:#define ISALPHA_(ch)                    (ISUPPER_(ch) || ISLOWER_(ch))
        -:  277:#define ISDIGIT_(ch)                    (ISIN_(ch, _T('0'), _T('9')))
        -:  278:#define ISXDIGIT_(ch)                   (ISDIGIT_(ch) || ISIN_(ch, _T('A'), _T('F')) || ISIN_(ch, _T('a'), _T('f')))
        -:  279:#define ISALNUM_(ch)                    (ISALPHA_(ch) || ISDIGIT_(ch))
        -:  280:
        -:  281:#define ISANYOF(off, palette)           ISANYOF_(CH(off), (palette))
        -:  282:#define ISANYOF2(off, ch1, ch2)         ISANYOF2_(CH(off), (ch1), (ch2))
        -:  283:#define ISANYOF3(off, ch1, ch2, ch3)    ISANYOF3_(CH(off), (ch1), (ch2), (ch3))
        -:  284:#define ISASCII(off)                    ISASCII_(CH(off))
        -:  285:#define ISBLANK(off)                    ISBLANK_(CH(off))
        -:  286:#define ISNEWLINE(off)                  ISNEWLINE_(CH(off))
        -:  287:#define ISWHITESPACE(off)               ISWHITESPACE_(CH(off))
        -:  288:#define ISCNTRL(off)                    ISCNTRL_(CH(off))
        -:  289:#define ISPUNCT(off)                    ISPUNCT_(CH(off))
        -:  290:#define ISUPPER(off)                    ISUPPER_(CH(off))
        -:  291:#define ISLOWER(off)                    ISLOWER_(CH(off))
        -:  292:#define ISALPHA(off)                    ISALPHA_(CH(off))
        -:  293:#define ISDIGIT(off)                    ISDIGIT_(CH(off))
        -:  294:#define ISXDIGIT(off)                   ISXDIGIT_(CH(off))
        -:  295:#define ISALNUM(off)                    ISALNUM_(CH(off))
        -:  296:static inline const CHAR*
        -:  297:md_strchr(const CHAR* str, CHAR ch)
        -:  298:{
        -:  299:    OFF i;
        8:  300:    for(i = 0; str[i] != _T('\0'); i++) {
        6:  301:        if(ch == str[i])
        -:  302:            return (str + i);
        -:  303:    }
        -:  304:    return NULL;
        -:  305:}
        -:  306:
        -:  307:/* Case insensitive check of string equality. */
        -:  308:static inline int
        -:  309:md_ascii_case_eq(const CHAR* s1, const CHAR* s2, SZ n)
        -:  310:{
        -:  311:    OFF i;
    #####:  312:    for(i = 0; i < n; i++) {
    #####:  313:        CHAR ch1 = s1[i];
    #####:  314:        CHAR ch2 = s2[i];
        -:  315:
    #####:  316:        if(ISLOWER_(ch1))
    #####:  317:            ch1 += ('A'-'a');
    #####:  318:        if(ISLOWER_(ch2))
    #####:  319:            ch2 += ('A'-'a');
    #####:  320:        if(ch1 != ch2)
        -:  321:            return FALSE;
        -:  322:    }
        -:  323:    return TRUE;
        -:  324:}
        -:  325:
        -:  326:static inline int
        -:  327:md_ascii_eq(const CHAR* s1, const CHAR* s2, SZ n)
        -:  328:{
    #####:  329:    return memcmp(s1, s2, n * sizeof(CHAR)) == 0;
        -:  330:}
        -:  331:
        -:  332:static int
    #####:  333:md_text_with_null_replacement(MD_CTX* ctx, MD_TEXTTYPE type, const CHAR* str, SZ size)
        -:  334:{
    #####:  335:    OFF off = 0;
    #####:  336:    int ret = 0;
        -:  337:
        -:  338:    while(1) {
    #####:  339:        while(off < size  &&  str[off] != _T('\0'))
    #####:  340:            off++;
        -:  341:
    #####:  342:        if(off > 0) {
    #####:  343:            ret = ctx->parser.text(type, str, off, ctx->userdata);
    #####:  344:            if(ret != 0)
        -:  345:                return ret;
        -:  346:
    #####:  347:            str += off;
    #####:  348:            size -= off;
    #####:  349:            off = 0;
        -:  350:        }
        -:  351:
    #####:  352:        if(off >= size)
        -:  353:            return 0;
        -:  354:
    #####:  355:        ret = ctx->parser.text(MD_TEXT_NULLCHAR, _T(""), 1, ctx->userdata);
    #####:  356:        if(ret != 0)
        -:  357:            return ret;
    #####:  358:        off++;
        -:  359:    }
        -:  360:}
        -:  361:
        -:  362:
        -:  363:#define MD_CHECK(func)                                                  \
        -:  364:    do {                                                                \
        -:  365:        ret = (func);                                                   \
        -:  366:        if(ret < 0)                                                     \
        -:  367:            goto abort;                                                 \
        -:  368:    } while(0)
        -:  369:
        -:  370:
        -:  371:#define MD_TEMP_BUFFER(sz)                                              \
        -:  372:    do {                                                                \
        -:  373:        if(sz > ctx->alloc_buffer) {                                    \
        -:  374:            CHAR* new_buffer;                                           \
        -:  375:            SZ new_size = ((sz) + (sz) / 2 + 128) & ~127;               \
        -:  376:                                                                        \
        -:  377:            new_buffer = realloc(ctx->buffer, new_size);                \
        -:  378:            if(new_buffer == NULL) {                                    \
        -:  379:                MD_LOG("realloc() failed.");                            \
        -:  380:                ret = -1;                                               \
        -:  381:                goto abort;                                             \
        -:  382:            }                                                           \
        -:  383:                                                                        \
        -:  384:            ctx->buffer = new_buffer;                                   \
        -:  385:            ctx->alloc_buffer = new_size;                               \
        -:  386:        }                                                               \
        -:  387:    } while(0)
        -:  388:
        -:  389:
        -:  390:#define MD_ENTER_BLOCK(type, arg)                                       \
        -:  391:    do {                                                                \
        -:  392:        ret = ctx->parser.enter_block((type), (arg), ctx->userdata);         \
        -:  393:        if(ret != 0) {                                                  \
        -:  394:            MD_LOG("Aborted from enter_block() callback.");             \
        -:  395:            goto abort;                                                 \
        -:  396:        }                                                               \
        -:  397:    } while(0)
        -:  398:
        -:  399:#define MD_LEAVE_BLOCK(type, arg)                                       \
        -:  400:    do {                                                                \
        -:  401:        ret = ctx->parser.leave_block((type), (arg), ctx->userdata);         \
        -:  402:        if(ret != 0) {                                                  \
        -:  403:            MD_LOG("Aborted from leave_block() callback.");             \
        -:  404:            goto abort;                                                 \
        -:  405:        }                                                               \
        -:  406:    } while(0)
        -:  407:
        -:  408:#define MD_ENTER_SPAN(type, arg)                                        \
        -:  409:    do {                                                                \
        -:  410:        ret = ctx->parser.enter_span((type), (arg), ctx->userdata);          \
        -:  411:        if(ret != 0) {                                                  \
        -:  412:            MD_LOG("Aborted from enter_span() callback.");              \
        -:  413:            goto abort;                                                 \
        -:  414:        }                                                               \
        -:  415:    } while(0)
        -:  416:
        -:  417:#define MD_LEAVE_SPAN(type, arg)                                        \
        -:  418:    do {                                                                \
        -:  419:        ret = ctx->parser.leave_span((type), (arg), ctx->userdata);          \
        -:  420:        if(ret != 0) {                                                  \
        -:  421:            MD_LOG("Aborted from leave_span() callback.");              \
        -:  422:            goto abort;                                                 \
        -:  423:        }                                                               \
        -:  424:    } while(0)
        -:  425:
        -:  426:#define MD_TEXT(type, str, size)                                        \
        -:  427:    do {                                                                \
        -:  428:        if(size > 0) {                                                  \
        -:  429:            ret = ctx->parser.text((type), (str), (size), ctx->userdata);    \
        -:  430:            if(ret != 0) {                                              \
        -:  431:                MD_LOG("Aborted from text() callback.");                \
        -:  432:                goto abort;                                             \
        -:  433:            }                                                           \
        -:  434:        }                                                               \
        -:  435:    } while(0)
        -:  436:
        -:  437:#define MD_TEXT_INSECURE(type, str, size)                               \
        -:  438:    do {                                                                \
        -:  439:        if(size > 0) {                                                  \
        -:  440:            ret = md_text_with_null_replacement(ctx, type, str, size);  \
        -:  441:            if(ret != 0) {                                              \
        -:  442:                MD_LOG("Aborted from text() callback.");                \
        -:  443:                goto abort;                                             \
        -:  444:            }                                                           \
        -:  445:        }                                                               \
        -:  446:    } while(0)
        -:  447:
        -:  448:
        -:  449:
        -:  450:/*************************
        -:  451: ***  Unicode Support  ***
        -:  452: *************************/
        -:  453:
        -:  454:typedef struct MD_UNICODE_FOLD_INFO_tag MD_UNICODE_FOLD_INFO;
        -:  455:struct MD_UNICODE_FOLD_INFO_tag {
        -:  456:    int codepoints[3];
        -:  457:    int n_codepoints;
        -:  458:};
        -:  459:
        -:  460:
        -:  461:#if defined MD4C_USE_UTF16 || defined MD4C_USE_UTF8
        -:  462:    static int
        1:  463:    md_is_unicode_whitespace__(int codepoint)
        -:  464:    {
        -:  465:        /* The ASCII ones are the most frequently used ones, so lets check them first. */
        1:  466:        if(codepoint <= 0x7f)
        1:  467:            return ISWHITESPACE_(codepoint);
        -:  468:
        -:  469:        /* Check for Unicode codepoints in Zs class above 127. */
    #####:  470:        if(codepoint == 0x00a0 || codepoint == 0x1680)
        -:  471:            return TRUE;
    #####:  472:        if(0x2000 <= codepoint && codepoint <= 0x200a)
        -:  473:            return TRUE;
    #####:  474:        if(codepoint == 0x202f || codepoint == 0x205f || codepoint == 0x3000)
        -:  475:            return TRUE;
        -:  476:
    #####:  477:        return FALSE;
        -:  478:    }
        -:  479:
        -:  480:    static int
        -:  481:    md_unicode_cmp__(const void* p_codepoint_a, const void* p_codepoint_b)
        -:  482:    {
    #####:  483:        return (*(const int*)p_codepoint_a - *(const int*)p_codepoint_b);
        -:  484:    }
        -:  485:
        -:  486:    static int
    #####:  487:    md_is_unicode_punct__(int codepoint)
        -:  488:    {
        -:  489:        /* non-ASCII (above 127) Unicode punctuation codepoints (classes
        -:  490:         * Pc, Pd, Pe, Pf, Pi, Po, Ps).
        -:  491:         *
        -:  492:         * Warning: Keep the array sorted.
        -:  493:         */
        -:  494:        static const int punct_list[] = {
        -:  495:            0x00a1, 0x00a7, 0x00ab, 0x00b6, 0x00b7, 0x00bb, 0x00bf, 0x037e, 0x0387, 0x055a, 0x055b, 0x055c, 0x055d, 0x055e, 0x055f, 0x0589,
        -:  496:            0x058a, 0x05be, 0x05c0, 0x05c3, 0x05c6, 0x05f3, 0x05f4, 0x0609, 0x060a, 0x060c, 0x060d, 0x061b, 0x061e, 0x061f, 0x066a, 0x066b,
        -:  497:            0x066c, 0x066d, 0x06d4, 0x0700, 0x0701, 0x0702, 0x0703, 0x0704, 0x0705, 0x0706, 0x0707, 0x0708, 0x0709, 0x070a, 0x070b, 0x070c,
        -:  498:            0x070d, 0x07f7, 0x07f8, 0x07f9, 0x0830, 0x0831, 0x0832, 0x0833, 0x0834, 0x0835, 0x0836, 0x0837, 0x0838, 0x0839, 0x083a, 0x083b,
        -:  499:            0x083c, 0x083d, 0x083e, 0x085e, 0x0964, 0x0965, 0x0970, 0x0af0, 0x0df4, 0x0e4f, 0x0e5a, 0x0e5b, 0x0f04, 0x0f05, 0x0f06, 0x0f07,
        -:  500:            0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e, 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f14, 0x0f3a, 0x0f3b, 0x0f3c, 0x0f3d,
        -:  501:            0x0f85, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4, 0x0fd9, 0x0fda, 0x104a, 0x104b, 0x104c, 0x104d, 0x104e, 0x104f, 0x10fb, 0x1360,
        -:  502:            0x1361, 0x1362, 0x1363, 0x1364, 0x1365, 0x1366, 0x1367, 0x1368, 0x1400, 0x166d, 0x166e, 0x169b, 0x169c, 0x16eb, 0x16ec, 0x16ed,
        -:  503:            0x1735, 0x1736, 0x17d4, 0x17d5, 0x17d6, 0x17d8, 0x17d9, 0x17da, 0x1800, 0x1801, 0x1802, 0x1803, 0x1804, 0x1805, 0x1806, 0x1807,
        -:  504:            0x1808, 0x1809, 0x180a, 0x1944, 0x1945, 0x1a1e, 0x1a1f, 0x1aa0, 0x1aa1, 0x1aa2, 0x1aa3, 0x1aa4, 0x1aa5, 0x1aa6, 0x1aa8, 0x1aa9,
        -:  505:            0x1aaa, 0x1aab, 0x1aac, 0x1aad, 0x1b5a, 0x1b5b, 0x1b5c, 0x1b5d, 0x1b5e, 0x1b5f, 0x1b60, 0x1bfc, 0x1bfd, 0x1bfe, 0x1bff, 0x1c3b,
        -:  506:            0x1c3c, 0x1c3d, 0x1c3e, 0x1c3f, 0x1c7e, 0x1c7f, 0x1cc0, 0x1cc1, 0x1cc2, 0x1cc3, 0x1cc4, 0x1cc5, 0x1cc6, 0x1cc7, 0x1cd3, 0x2010,
        -:  507:            0x2011, 0x2012, 0x2013, 0x2014, 0x2015, 0x2016, 0x2017, 0x2018, 0x2019, 0x201a, 0x201b, 0x201c, 0x201d, 0x201e, 0x201f, 0x2020,
        -:  508:            0x2021, 0x2022, 0x2023, 0x2024, 0x2025, 0x2026, 0x2027, 0x2030, 0x2031, 0x2032, 0x2033, 0x2034, 0x2035, 0x2036, 0x2037, 0x2038,
        -:  509:            0x2039, 0x203a, 0x203b, 0x203c, 0x203d, 0x203e, 0x203f, 0x2040, 0x2041, 0x2042, 0x2043, 0x2045, 0x2046, 0x2047, 0x2048, 0x2049,
        -:  510:            0x204a, 0x204b, 0x204c, 0x204d, 0x204e, 0x204f, 0x2050, 0x2051, 0x2053, 0x2054, 0x2055, 0x2056, 0x2057, 0x2058, 0x2059, 0x205a,
        -:  511:            0x205b, 0x205c, 0x205d, 0x205e, 0x207d, 0x207e, 0x208d, 0x208e, 0x2308, 0x2309, 0x230a, 0x230b, 0x2329, 0x232a, 0x2768, 0x2769,
        -:  512:            0x276a, 0x276b, 0x276c, 0x276d, 0x276e, 0x276f, 0x2770, 0x2771, 0x2772, 0x2773, 0x2774, 0x2775, 0x27c5, 0x27c6, 0x27e6, 0x27e7,
        -:  513:            0x27e8, 0x27e9, 0x27ea, 0x27eb, 0x27ec, 0x27ed, 0x27ee, 0x27ef, 0x2983, 0x2984, 0x2985, 0x2986, 0x2987, 0x2988, 0x2989, 0x298a,
        -:  514:            0x298b, 0x298c, 0x298d, 0x298e, 0x298f, 0x2990, 0x2991, 0x2992, 0x2993, 0x2994, 0x2995, 0x2996, 0x2997, 0x2998, 0x29d8, 0x29d9,
        -:  515:            0x29da, 0x29db, 0x29fc, 0x29fd, 0x2cf9, 0x2cfa, 0x2cfb, 0x2cfc, 0x2cfe, 0x2cff, 0x2d70, 0x2e00, 0x2e01, 0x2e02, 0x2e03, 0x2e04,
        -:  516:            0x2e05, 0x2e06, 0x2e07, 0x2e08, 0x2e09, 0x2e0a, 0x2e0b, 0x2e0c, 0x2e0d, 0x2e0e, 0x2e0f, 0x2e10, 0x2e11, 0x2e12, 0x2e13, 0x2e14,
        -:  517:            0x2e15, 0x2e16, 0x2e17, 0x2e18, 0x2e19, 0x2e1a, 0x2e1b, 0x2e1c, 0x2e1d, 0x2e1e, 0x2e1f, 0x2e20, 0x2e21, 0x2e22, 0x2e23, 0x2e24,
        -:  518:            0x2e25, 0x2e26, 0x2e27, 0x2e28, 0x2e29, 0x2e2a, 0x2e2b, 0x2e2c, 0x2e2d, 0x2e2e, 0x2e30, 0x2e31, 0x2e32, 0x2e33, 0x2e34, 0x2e35,
        -:  519:            0x2e36, 0x2e37, 0x2e38, 0x2e39, 0x2e3a, 0x2e3b, 0x2e3c, 0x2e3d, 0x2e3e, 0x2e3f, 0x2e40, 0x2e41, 0x2e42, 0x2e43, 0x2e44, 0x3001,
        -:  520:            0x3002, 0x3003, 0x3008, 0x3009, 0x300a, 0x300b, 0x300c, 0x300d, 0x300e, 0x300f, 0x3010, 0x3011, 0x3014, 0x3015, 0x3016, 0x3017,
        -:  521:            0x3018, 0x3019, 0x301a, 0x301b, 0x301c, 0x301d, 0x301e, 0x301f, 0x3030, 0x303d, 0x30a0, 0x30fb, 0xa4fe, 0xa4ff, 0xa60d, 0xa60e,
        -:  522:            0xa60f, 0xa673, 0xa67e, 0xa6f2, 0xa6f3, 0xa6f4, 0xa6f5, 0xa6f6, 0xa6f7, 0xa874, 0xa875, 0xa876, 0xa877, 0xa8ce, 0xa8cf, 0xa8f8,
        -:  523:            0xa8f9, 0xa8fa, 0xa8fc, 0xa92e, 0xa92f, 0xa95f, 0xa9c1, 0xa9c2, 0xa9c3, 0xa9c4, 0xa9c5, 0xa9c6, 0xa9c7, 0xa9c8, 0xa9c9, 0xa9ca,
        -:  524:            0xa9cb, 0xa9cc, 0xa9cd, 0xa9de, 0xa9df, 0xaa5c, 0xaa5d, 0xaa5e, 0xaa5f, 0xaade, 0xaadf, 0xaaf0, 0xaaf1, 0xabeb, 0xfd3e, 0xfd3f,
        -:  525:            0xfe10, 0xfe11, 0xfe12, 0xfe13, 0xfe14, 0xfe15, 0xfe16, 0xfe17, 0xfe18, 0xfe19, 0xfe30, 0xfe31, 0xfe32, 0xfe33, 0xfe34, 0xfe35,
        -:  526:            0xfe36, 0xfe37, 0xfe38, 0xfe39, 0xfe3a, 0xfe3b, 0xfe3c, 0xfe3d, 0xfe3e, 0xfe3f, 0xfe40, 0xfe41, 0xfe42, 0xfe43, 0xfe44, 0xfe45,
        -:  527:            0xfe46, 0xfe47, 0xfe48, 0xfe49, 0xfe4a, 0xfe4b, 0xfe4c, 0xfe4d, 0xfe4e, 0xfe4f, 0xfe50, 0xfe51, 0xfe52, 0xfe54, 0xfe55, 0xfe56,
        -:  528:            0xfe57, 0xfe58, 0xfe59, 0xfe5a, 0xfe5b, 0xfe5c, 0xfe5d, 0xfe5e, 0xfe5f, 0xfe60, 0xfe61, 0xfe63, 0xfe68, 0xfe6a, 0xfe6b, 0xff01,
        -:  529:            0xff02, 0xff03, 0xff05, 0xff06, 0xff07, 0xff08, 0xff09, 0xff0a, 0xff0c, 0xff0d, 0xff0e, 0xff0f, 0xff1a, 0xff1b, 0xff1f, 0xff20,
        -:  530:            0xff3b, 0xff3c, 0xff3d, 0xff3f, 0xff5b, 0xff5d, 0xff5f, 0xff60, 0xff61, 0xff62, 0xff63, 0xff64, 0xff65, 0x10100, 0x10101, 0x10102,
        -:  531:            0x1039f, 0x103d0, 0x1056f, 0x10857, 0x1091f, 0x1093f, 0x10a50, 0x10a51, 0x10a52, 0x10a53, 0x10a54, 0x10a55, 0x10a56, 0x10a57, 0x10a58, 0x10a7f,
        -:  532:            0x10af0, 0x10af1, 0x10af2, 0x10af3, 0x10af4, 0x10af5, 0x10af6, 0x10b39, 0x10b3a, 0x10b3b, 0x10b3c, 0x10b3d, 0x10b3e, 0x10b3f, 0x10b99, 0x10b9a,
        -:  533:            0x10b9b, 0x10b9c, 0x11047, 0x11048, 0x11049, 0x1104a, 0x1104b, 0x1104c, 0x1104d, 0x110bb, 0x110bc, 0x110be, 0x110bf, 0x110c0, 0x110c1, 0x11140,
        -:  534:            0x11141, 0x11142, 0x11143, 0x11174, 0x11175, 0x111c5, 0x111c6, 0x111c7, 0x111c8, 0x111c9, 0x111cd, 0x111db, 0x111dd, 0x111de, 0x111df, 0x11238,
        -:  535:            0x11239, 0x1123a, 0x1123b, 0x1123c, 0x1123d, 0x112a9, 0x1144b, 0x1144c, 0x1144d, 0x1144e, 0x1144f, 0x1145b, 0x1145d, 0x114c6, 0x115c1, 0x115c2,
        -:  536:            0x115c3, 0x115c4, 0x115c5, 0x115c6, 0x115c7, 0x115c8, 0x115c9, 0x115ca, 0x115cb, 0x115cc, 0x115cd, 0x115ce, 0x115cf, 0x115d0, 0x115d1, 0x115d2,
        -:  537:            0x115d3, 0x115d4, 0x115d5, 0x115d6, 0x115d7, 0x11641, 0x11642, 0x11643, 0x11660, 0x11661, 0x11662, 0x11663, 0x11664, 0x11665, 0x11666, 0x11667,
        -:  538:            0x11668, 0x11669, 0x1166a, 0x1166b, 0x1166c, 0x1173c, 0x1173d, 0x1173e, 0x11c41, 0x11c42, 0x11c43, 0x11c44, 0x11c45, 0x11c70, 0x11c71, 0x12470,
        -:  539:            0x12471, 0x12472, 0x12473, 0x12474, 0x16a6e, 0x16a6f, 0x16af5, 0x16b37, 0x16b38, 0x16b39, 0x16b3a, 0x16b3b, 0x16b44, 0x1bc9f, 0x1da87, 0x1da88,
        -:  540:            0x1da89, 0x1da8a, 0x1da8b, 0x1e95e, 0x1e95f
        -:  541:        };
        -:  542:
        -:  543:        /* The ASCII ones are the most frequently used ones, so lets check them first. */
    #####:  544:        if(codepoint <= 0x7f)
    #####:  545:            return ISPUNCT_(codepoint);
        -:  546:
    #####:  547:        return (bsearch(&codepoint, punct_list, SIZEOF_ARRAY(punct_list), sizeof(int), md_unicode_cmp__) != NULL);
        -:  548:    }
        -:  549:
        -:  550:    static void
    #####:  551:    md_get_unicode_fold_info(int codepoint, MD_UNICODE_FOLD_INFO* info)
        -:  552:    {
        -:  553:        /* This maps single codepoint within a range to a single codepoint
        -:  554:         * within an offseted range. */
        -:  555:        static const struct {
        -:  556:            int min_codepoint;
        -:  557:            int max_codepoint;
        -:  558:            int offset;
        -:  559:        } range_map[] = {
        -:  560:            { 0x00c0, 0x00d6, 32 }, { 0x00d8, 0x00de, 32 }, { 0x0388, 0x038a, 37 }, { 0x0391, 0x03a1, 32 }, { 0x03a3, 0x03ab, 32 }, { 0x0400, 0x040f, 80 },
        -:  561:            { 0x0410, 0x042f, 32 }, { 0x0531, 0x0556, 48 }, { 0x1f08, 0x1f0f, -8 }, { 0x1f18, 0x1f1d, -8 }, { 0x1f28, 0x1f2f, -8 }, { 0x1f38, 0x1f3f, -8 },
        -:  562:            { 0x1f48, 0x1f4d, -8 }, { 0x1f68, 0x1f6f, -8 }, { 0x1fc8, 0x1fcb, -86 }, { 0x2160, 0x216f, 16 }, { 0x24b6, 0x24cf, 26 }, { 0xff21, 0xff3a, 32 },
        -:  563:            { 0x10400, 0x10425, 40 }
        -:  564:        };
        -:  565:
        -:  566:        /* This maps single codepoint to another single codepoint. */
        -:  567:        static const struct {
        -:  568:            int src_codepoint;
        -:  569:            int dest_codepoint;
        -:  570:        } single_map[] = {
        -:  571:            { 0x00b5, 0x03bc }, { 0x0100, 0x0101 }, { 0x0102, 0x0103 }, { 0x0104, 0x0105 }, { 0x0106, 0x0107 }, { 0x0108, 0x0109 }, { 0x010a, 0x010b }, { 0x010c, 0x010d },
        -:  572:            { 0x010e, 0x010f }, { 0x0110, 0x0111 }, { 0x0112, 0x0113 }, { 0x0114, 0x0115 }, { 0x0116, 0x0117 }, { 0x0118, 0x0119 }, { 0x011a, 0x011b }, { 0x011c, 0x011d },
        -:  573:            { 0x011e, 0x011f }, { 0x0120, 0x0121 }, { 0x0122, 0x0123 }, { 0x0124, 0x0125 }, { 0x0126, 0x0127 }, { 0x0128, 0x0129 }, { 0x012a, 0x012b }, { 0x012c, 0x012d },
        -:  574:            { 0x012e, 0x012f }, { 0x0132, 0x0133 }, { 0x0134, 0x0135 }, { 0x0136, 0x0137 }, { 0x0139, 0x013a }, { 0x013b, 0x013c }, { 0x013d, 0x013e }, { 0x013f, 0x0140 },
        -:  575:            { 0x0141, 0x0142 }, { 0x0143, 0x0144 }, { 0x0145, 0x0146 }, { 0x0147, 0x0148 }, { 0x014a, 0x014b }, { 0x014c, 0x014d }, { 0x014e, 0x014f }, { 0x0150, 0x0151 },
        -:  576:            { 0x0152, 0x0153 }, { 0x0154, 0x0155 }, { 0x0156, 0x0157 }, { 0x0158, 0x0159 }, { 0x015a, 0x015b }, { 0x015c, 0x015d }, { 0x015e, 0x015f }, { 0x0160, 0x0161 },
        -:  577:            { 0x0162, 0x0163 }, { 0x0164, 0x0165 }, { 0x0166, 0x0167 }, { 0x0168, 0x0169 }, { 0x016a, 0x016b }, { 0x016c, 0x016d }, { 0x016e, 0x016f }, { 0x0170, 0x0171 },
        -:  578:            { 0x0172, 0x0173 }, { 0x0174, 0x0175 }, { 0x0176, 0x0177 }, { 0x0178, 0x00ff }, { 0x0179, 0x017a }, { 0x017b, 0x017c }, { 0x017d, 0x017e }, { 0x017f, 0x0073 },
        -:  579:            { 0x0181, 0x0253 }, { 0x0182, 0x0183 }, { 0x0184, 0x0185 }, { 0x0186, 0x0254 }, { 0x0187, 0x0188 }, { 0x0189, 0x0256 }, { 0x018a, 0x0257 }, { 0x018b, 0x018c },
        -:  580:            { 0x018e, 0x01dd }, { 0x018f, 0x0259 }, { 0x0190, 0x025b }, { 0x0191, 0x0192 }, { 0x0193, 0x0260 }, { 0x0194, 0x0263 }, { 0x0196, 0x0269 }, { 0x0197, 0x0268 },
        -:  581:            { 0x0198, 0x0199 }, { 0x019c, 0x026f }, { 0x019d, 0x0272 }, { 0x019f, 0x0275 }, { 0x01a0, 0x01a1 }, { 0x01a2, 0x01a3 }, { 0x01a4, 0x01a5 }, { 0x01a6, 0x0280 },
        -:  582:            { 0x01a7, 0x01a8 }, { 0x01a9, 0x0283 }, { 0x01ac, 0x01ad }, { 0x01ae, 0x0288 }, { 0x01af, 0x01b0 }, { 0x01b1, 0x028a }, { 0x01b2, 0x028b }, { 0x01b3, 0x01b4 },
        -:  583:            { 0x01b5, 0x01b6 }, { 0x01b7, 0x0292 }, { 0x01b8, 0x01b9 }, { 0x01bc, 0x01bd }, { 0x01c4, 0x01c6 }, { 0x01c5, 0x01c6 }, { 0x01c7, 0x01c9 }, { 0x01c8, 0x01c9 },
        -:  584:            { 0x01ca, 0x01cc }, { 0x01cb, 0x01cc }, { 0x01cd, 0x01ce }, { 0x01cf, 0x01d0 }, { 0x01d1, 0x01d2 }, { 0x01d3, 0x01d4 }, { 0x01d5, 0x01d6 }, { 0x01d7, 0x01d8 },
        -:  585:            { 0x01d9, 0x01da }, { 0x01db, 0x01dc }, { 0x01de, 0x01df }, { 0x01e0, 0x01e1 }, { 0x01e2, 0x01e3 }, { 0x01e4, 0x01e5 }, { 0x01e6, 0x01e7 }, { 0x01e8, 0x01e9 },
        -:  586:            { 0x01ea, 0x01eb }, { 0x01ec, 0x01ed }, { 0x01ee, 0x01ef }, { 0x01f1, 0x01f3 }, { 0x01f2, 0x01f3 }, { 0x01f4, 0x01f5 }, { 0x01f6, 0x0195 }, { 0x01f7, 0x01bf },
        -:  587:            { 0x01f8, 0x01f9 }, { 0x01fa, 0x01fb }, { 0x01fc, 0x01fd }, { 0x01fe, 0x01ff }, { 0x0200, 0x0201 }, { 0x0202, 0x0203 }, { 0x0204, 0x0205 }, { 0x0206, 0x0207 },
        -:  588:            { 0x0208, 0x0209 }, { 0x020a, 0x020b }, { 0x020c, 0x020d }, { 0x020e, 0x020f }, { 0x0210, 0x0211 }, { 0x0212, 0x0213 }, { 0x0214, 0x0215 }, { 0x0216, 0x0217 },
        -:  589:            { 0x0218, 0x0219 }, { 0x021a, 0x021b }, { 0x021c, 0x021d }, { 0x021e, 0x021f }, { 0x0220, 0x019e }, { 0x0222, 0x0223 }, { 0x0224, 0x0225 }, { 0x0226, 0x0227 },
        -:  590:            { 0x0228, 0x0229 }, { 0x022a, 0x022b }, { 0x022c, 0x022d }, { 0x022e, 0x022f }, { 0x0230, 0x0231 }, { 0x0232, 0x0233 }, { 0x0345, 0x03b9 }, { 0x0386, 0x03ac },
        -:  591:            { 0x038c, 0x03cc }, { 0x038e, 0x03cd }, { 0x038f, 0x03ce }, { 0x03c2, 0x03c3 }, { 0x03d0, 0x03b2 }, { 0x03d1, 0x03b8 }, { 0x03d5, 0x03c6 }, { 0x03d6, 0x03c0 },
        -:  592:            { 0x03d8, 0x03d9 }, { 0x03da, 0x03db }, { 0x03dc, 0x03dd }, { 0x03de, 0x03df }, { 0x03e0, 0x03e1 }, { 0x03e2, 0x03e3 }, { 0x03e4, 0x03e5 }, { 0x03e6, 0x03e7 },
        -:  593:            { 0x03e8, 0x03e9 }, { 0x03ea, 0x03eb }, { 0x03ec, 0x03ed }, { 0x03ee, 0x03ef }, { 0x03f0, 0x03ba }, { 0x03f1, 0x03c1 }, { 0x03f2, 0x03c3 }, { 0x03f4, 0x03b8 },
        -:  594:            { 0x03f5, 0x03b5 }, { 0x0460, 0x0461 }, { 0x0462, 0x0463 }, { 0x0464, 0x0465 }, { 0x0466, 0x0467 }, { 0x0468, 0x0469 }, { 0x046a, 0x046b }, { 0x046c, 0x046d },
        -:  595:            { 0x046e, 0x046f }, { 0x0470, 0x0471 }, { 0x0472, 0x0473 }, { 0x0474, 0x0475 }, { 0x0476, 0x0477 }, { 0x0478, 0x0479 }, { 0x047a, 0x047b }, { 0x047c, 0x047d },
        -:  596:            { 0x047e, 0x047f }, { 0x0480, 0x0481 }, { 0x048a, 0x048b }, { 0x048c, 0x048d }, { 0x048e, 0x048f }, { 0x0490, 0x0491 }, { 0x0492, 0x0493 }, { 0x0494, 0x0495 },
        -:  597:            { 0x0496, 0x0497 }, { 0x0498, 0x0499 }, { 0x049a, 0x049b }, { 0x049c, 0x049d }, { 0x049e, 0x049f }, { 0x04a0, 0x04a1 }, { 0x04a2, 0x04a3 }, { 0x04a4, 0x04a5 },
        -:  598:            { 0x04a6, 0x04a7 }, { 0x04a8, 0x04a9 }, { 0x04aa, 0x04ab }, { 0x04ac, 0x04ad }, { 0x04ae, 0x04af }, { 0x04b0, 0x04b1 }, { 0x04b2, 0x04b3 }, { 0x04b4, 0x04b5 },
        -:  599:            { 0x04b6, 0x04b7 }, { 0x04b8, 0x04b9 }, { 0x04ba, 0x04bb }, { 0x04bc, 0x04bd }, { 0x04be, 0x04bf }, { 0x04c1, 0x04c2 }, { 0x04c3, 0x04c4 }, { 0x04c5, 0x04c6 },
        -:  600:            { 0x04c7, 0x04c8 }, { 0x04c9, 0x04ca }, { 0x04cb, 0x04cc }, { 0x04cd, 0x04ce }, { 0x04d0, 0x04d1 }, { 0x04d2, 0x04d3 }, { 0x04d4, 0x04d5 }, { 0x04d6, 0x04d7 },
        -:  601:            { 0x04d8, 0x04d9 }, { 0x04da, 0x04db }, { 0x04dc, 0x04dd }, { 0x04de, 0x04df }, { 0x04e0, 0x04e1 }, { 0x04e2, 0x04e3 }, { 0x04e4, 0x04e5 }, { 0x04e6, 0x04e7 },
        -:  602:            { 0x04e8, 0x04e9 }, { 0x04ea, 0x04eb }, { 0x04ec, 0x04ed }, { 0x04ee, 0x04ef }, { 0x04f0, 0x04f1 }, { 0x04f2, 0x04f3 }, { 0x04f4, 0x04f5 }, { 0x04f8, 0x04f9 },
        -:  603:            { 0x0500, 0x0501 }, { 0x0502, 0x0503 }, { 0x0504, 0x0505 }, { 0x0506, 0x0507 }, { 0x0508, 0x0509 }, { 0x050a, 0x050b }, { 0x050c, 0x050d }, { 0x050e, 0x050f },
        -:  604:            { 0x1e00, 0x1e01 }, { 0x1e02, 0x1e03 }, { 0x1e04, 0x1e05 }, { 0x1e06, 0x1e07 }, { 0x1e08, 0x1e09 }, { 0x1e0a, 0x1e0b }, { 0x1e0c, 0x1e0d }, { 0x1e0e, 0x1e0f },
        -:  605:            { 0x1e10, 0x1e11 }, { 0x1e12, 0x1e13 }, { 0x1e14, 0x1e15 }, { 0x1e16, 0x1e17 }, { 0x1e18, 0x1e19 }, { 0x1e1a, 0x1e1b }, { 0x1e1c, 0x1e1d }, { 0x1e1e, 0x1e1f },
        -:  606:            { 0x1e20, 0x1e21 }, { 0x1e22, 0x1e23 }, { 0x1e24, 0x1e25 }, { 0x1e26, 0x1e27 }, { 0x1e28, 0x1e29 }, { 0x1e2a, 0x1e2b }, { 0x1e2c, 0x1e2d }, { 0x1e2e, 0x1e2f },
        -:  607:            { 0x1e30, 0x1e31 }, { 0x1e32, 0x1e33 }, { 0x1e34, 0x1e35 }, { 0x1e36, 0x1e37 }, { 0x1e38, 0x1e39 }, { 0x1e3a, 0x1e3b }, { 0x1e3c, 0x1e3d }, { 0x1e3e, 0x1e3f },
        -:  608:            { 0x1e40, 0x1e41 }, { 0x1e42, 0x1e43 }, { 0x1e44, 0x1e45 }, { 0x1e46, 0x1e47 }, { 0x1e48, 0x1e49 }, { 0x1e4a, 0x1e4b }, { 0x1e4c, 0x1e4d }, { 0x1e4e, 0x1e4f },
        -:  609:            { 0x1e50, 0x1e51 }, { 0x1e52, 0x1e53 }, { 0x1e54, 0x1e55 }, { 0x1e56, 0x1e57 }, { 0x1e58, 0x1e59 }, { 0x1e5a, 0x1e5b }, { 0x1e5c, 0x1e5d }, { 0x1e5e, 0x1e5f },
        -:  610:            { 0x1e60, 0x1e61 }, { 0x1e62, 0x1e63 }, { 0x1e64, 0x1e65 }, { 0x1e66, 0x1e67 }, { 0x1e68, 0x1e69 }, { 0x1e6a, 0x1e6b }, { 0x1e6c, 0x1e6d }, { 0x1e6e, 0x1e6f },
        -:  611:            { 0x1e70, 0x1e71 }, { 0x1e72, 0x1e73 }, { 0x1e74, 0x1e75 }, { 0x1e76, 0x1e77 }, { 0x1e78, 0x1e79 }, { 0x1e7a, 0x1e7b }, { 0x1e7c, 0x1e7d }, { 0x1e7e, 0x1e7f },
        -:  612:            { 0x1e80, 0x1e81 }, { 0x1e82, 0x1e83 }, { 0x1e84, 0x1e85 }, { 0x1e86, 0x1e87 }, { 0x1e88, 0x1e89 }, { 0x1e8a, 0x1e8b }, { 0x1e8c, 0x1e8d }, { 0x1e8e, 0x1e8f },
        -:  613:            { 0x1e90, 0x1e91 }, { 0x1e92, 0x1e93 }, { 0x1e94, 0x1e95 }, { 0x1e9b, 0x1e61 }, { 0x1ea0, 0x1ea1 }, { 0x1ea2, 0x1ea3 }, { 0x1ea4, 0x1ea5 }, { 0x1ea6, 0x1ea7 },
        -:  614:            { 0x1ea8, 0x1ea9 }, { 0x1eaa, 0x1eab }, { 0x1eac, 0x1ead }, { 0x1eae, 0x1eaf }, { 0x1eb0, 0x1eb1 }, { 0x1eb2, 0x1eb3 }, { 0x1eb4, 0x1eb5 }, { 0x1eb6, 0x1eb7 },
        -:  615:            { 0x1eb8, 0x1eb9 }, { 0x1eba, 0x1ebb }, { 0x1ebc, 0x1ebd }, { 0x1ebe, 0x1ebf }, { 0x1ec0, 0x1ec1 }, { 0x1ec2, 0x1ec3 }, { 0x1ec4, 0x1ec5 }, { 0x1ec6, 0x1ec7 },
        -:  616:            { 0x1ec8, 0x1ec9 }, { 0x1eca, 0x1ecb }, { 0x1ecc, 0x1ecd }, { 0x1ece, 0x1ecf }, { 0x1ed0, 0x1ed1 }, { 0x1ed2, 0x1ed3 }, { 0x1ed4, 0x1ed5 }, { 0x1ed6, 0x1ed7 },
        -:  617:            { 0x1ed8, 0x1ed9 }, { 0x1eda, 0x1edb }, { 0x1edc, 0x1edd }, { 0x1ede, 0x1edf }, { 0x1ee0, 0x1ee1 }, { 0x1ee2, 0x1ee3 }, { 0x1ee4, 0x1ee5 }, { 0x1ee6, 0x1ee7 },
        -:  618:            { 0x1ee8, 0x1ee9 }, { 0x1eea, 0x1eeb }, { 0x1eec, 0x1eed }, { 0x1eee, 0x1eef }, { 0x1ef0, 0x1ef1 }, { 0x1ef2, 0x1ef3 }, { 0x1ef4, 0x1ef5 }, { 0x1ef6, 0x1ef7 },
        -:  619:            { 0x1ef8, 0x1ef9 }, { 0x1f59, 0x1f51 }, { 0x1f5b, 0x1f53 }, { 0x1f5d, 0x1f55 }, { 0x1f5f, 0x1f57 }, { 0x1fb8, 0x1fb0 }, { 0x1fb9, 0x1fb1 }, { 0x1fba, 0x1f70 },
        -:  620:            { 0x1fbb, 0x1f71 }, { 0x1fbe, 0x03b9 }, { 0x1fd8, 0x1fd0 }, { 0x1fd9, 0x1fd1 }, { 0x1fda, 0x1f76 }, { 0x1fdb, 0x1f77 }, { 0x1fe8, 0x1fe0 }, { 0x1fe9, 0x1fe1 },
        -:  621:            { 0x1fea, 0x1f7a }, { 0x1feb, 0x1f7b }, { 0x1fec, 0x1fe5 }, { 0x1ff8, 0x1f78 }, { 0x1ff9, 0x1f79 }, { 0x1ffa, 0x1f7c }, { 0x1ffb, 0x1f7d }, { 0x2126, 0x03c9 },
        -:  622:            { 0x212a, 0x006b }, { 0x212b, 0x00e5 },
        -:  623:        };
        -:  624:
        -:  625:        /* This maps single codepoint to two codepoints. */
        -:  626:        static const struct {
        -:  627:            int src_codepoint;
        -:  628:            int dest_codepoint0;
        -:  629:            int dest_codepoint1;
        -:  630:        } double_map[] = {
        -:  631:            { 0x00df, 0x0073, 0x0073 }, { 0x0130, 0x0069, 0x0307 }, { 0x0149, 0x02bc, 0x006e }, { 0x01f0, 0x006a, 0x030c }, { 0x0587, 0x0565, 0x0582 }, { 0x1e96, 0x0068, 0x0331 },
        -:  632:            { 0x1e97, 0x0074, 0x0308 }, { 0x1e98, 0x0077, 0x030a }, { 0x1e99, 0x0079, 0x030a }, { 0x1e9a, 0x0061, 0x02be }, { 0x1f50, 0x03c5, 0x0313 }, { 0x1f80, 0x1f00, 0x03b9 },
        -:  633:            { 0x1f81, 0x1f01, 0x03b9 }, { 0x1f82, 0x1f02, 0x03b9 }, { 0x1f83, 0x1f03, 0x03b9 }, { 0x1f84, 0x1f04, 0x03b9 }, { 0x1f85, 0x1f05, 0x03b9 }, { 0x1f86, 0x1f06, 0x03b9 },
        -:  634:            { 0x1f87, 0x1f07, 0x03b9 }, { 0x1f88, 0x1f00, 0x03b9 }, { 0x1f89, 0x1f01, 0x03b9 }, { 0x1f8a, 0x1f02, 0x03b9 }, { 0x1f8b, 0x1f03, 0x03b9 }, { 0x1f8c, 0x1f04, 0x03b9 },
        -:  635:            { 0x1f8d, 0x1f05, 0x03b9 }, { 0x1f8e, 0x1f06, 0x03b9 }, { 0x1f8f, 0x1f07, 0x03b9 }, { 0x1f90, 0x1f20, 0x03b9 }, { 0x1f91, 0x1f21, 0x03b9 }, { 0x1f92, 0x1f22, 0x03b9 },
        -:  636:            { 0x1f93, 0x1f23, 0x03b9 }, { 0x1f94, 0x1f24, 0x03b9 }, { 0x1f95, 0x1f25, 0x03b9 }, { 0x1f96, 0x1f26, 0x03b9 }, { 0x1f97, 0x1f27, 0x03b9 }, { 0x1f98, 0x1f20, 0x03b9 },
        -:  637:            { 0x1f99, 0x1f21, 0x03b9 }, { 0x1f9a, 0x1f22, 0x03b9 }, { 0x1f9b, 0x1f23, 0x03b9 }, { 0x1f9c, 0x1f24, 0x03b9 }, { 0x1f9d, 0x1f25, 0x03b9 }, { 0x1f9e, 0x1f26, 0x03b9 },
        -:  638:            { 0x1f9f, 0x1f27, 0x03b9 }, { 0x1fa0, 0x1f60, 0x03b9 }, { 0x1fa1, 0x1f61, 0x03b9 }, { 0x1fa2, 0x1f62, 0x03b9 }, { 0x1fa3, 0x1f63, 0x03b9 }, { 0x1fa4, 0x1f64, 0x03b9 },
        -:  639:            { 0x1fa5, 0x1f65, 0x03b9 }, { 0x1fa6, 0x1f66, 0x03b9 }, { 0x1fa7, 0x1f67, 0x03b9 }, { 0x1fa8, 0x1f60, 0x03b9 }, { 0x1fa9, 0x1f61, 0x03b9 }, { 0x1faa, 0x1f62, 0x03b9 },
        -:  640:            { 0x1fab, 0x1f63, 0x03b9 }, { 0x1fac, 0x1f64, 0x03b9 }, { 0x1fad, 0x1f65, 0x03b9 }, { 0x1fae, 0x1f66, 0x03b9 }, { 0x1faf, 0x1f67, 0x03b9 }, { 0x1fb2, 0x1f70, 0x03b9 },
        -:  641:            { 0x1fb3, 0x03b1, 0x03b9 }, { 0x1fb4, 0x03ac, 0x03b9 }, { 0x1fb6, 0x03b1, 0x0342 }, { 0x1fbc, 0x03b1, 0x03b9 }, { 0x1fc2, 0x1f74, 0x03b9 }, { 0x1fc3, 0x03b7, 0x03b9 },
        -:  642:            { 0x1fc4, 0x03ae, 0x03b9 }, { 0x1fc6, 0x03b7, 0x0342 }, { 0x1fcc, 0x03b7, 0x03b9 }, { 0x1fd6, 0x03b9, 0x0342 }, { 0x1fe4, 0x03c1, 0x0313 }, { 0x1fe6, 0x03c5, 0x0342 },
        -:  643:            { 0x1ff2, 0x1f7c, 0x03b9 }, { 0x1ff3, 0x03c9, 0x03b9 }, { 0x1ff4, 0x03ce, 0x03b9 }, { 0x1ff6, 0x03c9, 0x0342 }, { 0x1ffc, 0x03c9, 0x03b9 }, { 0xfb00, 0x0066, 0x0066 },
        -:  644:            { 0xfb01, 0x0066, 0x0069 }, { 0xfb02, 0x0066, 0x006c }, { 0xfb05, 0x0073, 0x0074 }, { 0xfb06, 0x0073, 0x0074 }, { 0xfb13, 0x0574, 0x0576 }, { 0xfb14, 0x0574, 0x0565 },
        -:  645:            { 0xfb15, 0x0574, 0x056b }, { 0xfb16, 0x057e, 0x0576 }, { 0xfb17, 0x0574, 0x056d }
        -:  646:        };
        -:  647:
        -:  648:        /* This maps single codepoint to three codepoints. */
        -:  649:        static const struct {
        -:  650:            int src_codepoint;
        -:  651:            int dest_codepoint0;
        -:  652:            int dest_codepoint1;
        -:  653:            int dest_codepoint2;
        -:  654:        } triple_map[] = {
        -:  655:            { 0x0390, 0x03b9, 0x0308, 0x0301 }, { 0x03b0, 0x03c5, 0x0308, 0x0301 }, { 0x1f52, 0x03c5, 0x0313, 0x0300 }, { 0x1f54, 0x03c5, 0x0313, 0x0301 },
        -:  656:            { 0x1f56, 0x03c5, 0x0313, 0x0342 }, { 0x1fb7, 0x03b1, 0x0342, 0x03b9 }, { 0x1fc7, 0x03b7, 0x0342, 0x03b9 }, { 0x1fd2, 0x03b9, 0x0308, 0x0300 },
        -:  657:            { 0x1fd3, 0x03b9, 0x0308, 0x0301 }, { 0x1fd7, 0x03b9, 0x0308, 0x0342 }, { 0x1fe2, 0x03c5, 0x0308, 0x0300 }, { 0x1fe3, 0x03c5, 0x0308, 0x0301 },
        -:  658:            { 0x1fe7, 0x03c5, 0x0308, 0x0342 }, { 0x1ff7, 0x03c9, 0x0342, 0x03b9 }, { 0xfb03, 0x0066, 0x0066, 0x0069 }, { 0xfb04, 0x0066, 0x0066, 0x006c }
        -:  659:        };
        -:  660:
        -:  661:        int i;
        -:  662:
        -:  663:        /* Fast path for ASCII characters. */
    #####:  664:        if(codepoint <= 0x7f) {
    #####:  665:            info->codepoints[0] = codepoint;
    #####:  666:            if(ISUPPER_(codepoint))
    #####:  667:                info->codepoints[0] += 'a' - 'A';
    #####:  668:            info->n_codepoints = 1;
    #####:  669:            return;
        -:  670:        }
        -:  671:
    #####:  672:        for(i = 0; i < SIZEOF_ARRAY(range_map); i++) {
    #####:  673:            if(range_map[i].min_codepoint <= codepoint && codepoint <= range_map[i].max_codepoint) {
    #####:  674:                info->codepoints[0] = codepoint + range_map[i].offset;
    #####:  675:                info->n_codepoints = 1;
    #####:  676:                return;
        -:  677:            }
        -:  678:        }
        -:  679:
    #####:  680:        for(i = 0; i < SIZEOF_ARRAY(single_map); i++) {
    #####:  681:            if(codepoint == single_map[i].src_codepoint) {
    #####:  682:                info->codepoints[0] = single_map[i].dest_codepoint;
    #####:  683:                info->n_codepoints = 1;
    #####:  684:                return;
        -:  685:            }
        -:  686:        }
        -:  687:
    #####:  688:        for(i = 0; i < SIZEOF_ARRAY(double_map); i++) {
    #####:  689:            if(codepoint == double_map[i].src_codepoint) {
    #####:  690:                info->codepoints[0] = double_map[i].dest_codepoint0;
    #####:  691:                info->codepoints[1] = double_map[i].dest_codepoint1;
    #####:  692:                info->n_codepoints = 2;
    #####:  693:                return;
        -:  694:            }
        -:  695:        }
        -:  696:
    #####:  697:        for(i = 0; i < SIZEOF_ARRAY(triple_map); i++) {
    #####:  698:            if(codepoint == triple_map[i].src_codepoint) {
    #####:  699:                info->codepoints[0] = triple_map[i].dest_codepoint0;
    #####:  700:                info->codepoints[1] = triple_map[i].dest_codepoint1;
    #####:  701:                info->codepoints[2] = triple_map[i].dest_codepoint2;
    #####:  702:                info->n_codepoints = 3;
    #####:  703:                return;
        -:  704:            }
        -:  705:        }
        -:  706:
    #####:  707:        info->codepoints[0] = codepoint;
    #####:  708:        info->n_codepoints = 1;
        -:  709:    }
        -:  710:#endif
        -:  711:
        -:  712:
        -:  713:#if defined MD4C_USE_UTF16
        -:  714:    #define IS_UTF16_SURROGATE_HI(word)     (((WORD)(word) & 0xfc00) == 0xd800)
        -:  715:    #define IS_UTF16_SURROGATE_LO(word)     (((WORD)(word) & 0xfc00) == 0xdc00)
        -:  716:    #define UTF16_DECODE_SURROGATE(hi, lo)  (0x10000 + ((((unsigned)(hi) & 0x3ff) << 10) | (((unsigned)(lo) & 0x3ff) << 0)))
        -:  717:
        -:  718:    static int
        -:  719:    md_decode_utf16le__(const CHAR* str, SZ str_size, SZ* p_size)
        -:  720:    {
        -:  721:        if(IS_UTF16_SURROGATE_HI(str[0])) {
        -:  722:            if(1 < str_size && IS_UTF16_SURROGATE_LO(str[1])) {
        -:  723:                if(p_size != NULL)
        -:  724:                    *p_size = 2;
        -:  725:                return UTF16_DECODE_SURROGATE(str[0], str[1]);
        -:  726:            }
        -:  727:        }
        -:  728:
        -:  729:        if(p_size != NULL)
        -:  730:            *p_size = 1;
        -:  731:        return str[0];
        -:  732:    }
        -:  733:
        -:  734:    static int
        -:  735:    md_decode_utf16le_before__(MD_CTX* ctx, OFF off)
        -:  736:    {
        -:  737:        if(off > 2 && IS_UTF16_SURROGATE_HI(CH(off-2)) && IS_UTF16_SURROGATE_LO(CH(off-1)))
        -:  738:            return UTF16_DECODE_SURROGATE(CH(off-2), CH(off-1));
        -:  739:
        -:  740:        return CH(off);
        -:  741:    }
        -:  742:
        -:  743:    /* No whitespace uses surrogates, so no decoding needed here. */
        -:  744:    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)
        -:  745:    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(CH(off))
        -:  746:    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(CH((off)-1))
        -:  747:
        -:  748:    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf16le__(STR(off), ctx->size - (off), NULL))
        -:  749:    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf16le_before__(ctx, off))
        -:  750:
        -:  751:    static inline int
        -:  752:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)
        -:  753:    {
        -:  754:        return md_decode_utf16le__(str+off, str_size-off, p_char_size);
        -:  755:    }
        -:  756:#elif defined MD4C_USE_UTF8
        -:  757:    #define IS_UTF8_LEAD1(byte)     ((unsigned char)(byte) <= 0x7f)
        -:  758:    #define IS_UTF8_LEAD2(byte)     (((unsigned char)(byte) & 0xe0) == 0xc0)
        -:  759:    #define IS_UTF8_LEAD3(byte)     (((unsigned char)(byte) & 0xf0) == 0xe0)
        -:  760:    #define IS_UTF8_LEAD4(byte)     (((unsigned char)(byte) & 0xf8) == 0xf0)
        -:  761:    #define IS_UTF8_TAIL(byte)      (((unsigned char)(byte) & 0xc0) == 0x80)
        -:  762:
        -:  763:    static int
        1:  764:    md_decode_utf8__(const CHAR* str, SZ str_size, SZ* p_size)
        -:  765:    {
        1:  766:        if(!IS_UTF8_LEAD1(str[0])) {
    #####:  767:            if(IS_UTF8_LEAD2(str[0])) {
    #####:  768:                if(1 < str_size && IS_UTF8_TAIL(str[1])) {
    #####:  769:                    if(p_size != NULL)
    #####:  770:                        *p_size = 2;
        -:  771:
    #####:  772:                    return (((unsigned int)str[0] & 0x1f) << 6) |
    #####:  773:                           (((unsigned int)str[1] & 0x3f) << 0);
        -:  774:                }
    #####:  775:            } else if(IS_UTF8_LEAD3(str[0])) {
    #####:  776:                if(2 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2])) {
    #####:  777:                    if(p_size != NULL)
    #####:  778:                        *p_size = 3;
        -:  779:
    #####:  780:                    return (((unsigned int)str[0] & 0x0f) << 12) |
    #####:  781:                           (((unsigned int)str[1] & 0x3f) << 6) |
    #####:  782:                           (((unsigned int)str[2] & 0x3f) << 0);
        -:  783:                }
    #####:  784:            } else if(IS_UTF8_LEAD4(str[0])) {
    #####:  785:                if(3 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2]) && IS_UTF8_TAIL(str[3])) {
    #####:  786:                    if(p_size != NULL)
    #####:  787:                        *p_size = 4;
        -:  788:
    #####:  789:                    return (((unsigned int)str[0] & 0x07) << 18) |
    #####:  790:                           (((unsigned int)str[1] & 0x3f) << 12) |
    #####:  791:                           (((unsigned int)str[2] & 0x3f) << 6) |
    #####:  792:                           (((unsigned int)str[3] & 0x3f) << 0);
        -:  793:                }
        -:  794:            }
        -:  795:        }
        -:  796:
        1:  797:        if(p_size != NULL)
        1:  798:            *p_size = 1;
        1:  799:        return str[0];
        -:  800:    }
        -:  801:
        -:  802:    static int
    #####:  803:    md_decode_utf8_before__(MD_CTX* ctx, OFF off)
        -:  804:    {
    #####:  805:        if(!IS_UTF8_LEAD1(CH(off-1))) {
    #####:  806:            if(off > 1 && IS_UTF8_LEAD2(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  807:                return (((unsigned int)CH(off-2) & 0x1f) << 6) |
    #####:  808:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  809:
    #####:  810:            if(off > 2 && IS_UTF8_LEAD3(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  811:                return (((unsigned int)CH(off-3) & 0x0f) << 12) |
    #####:  812:                       (((unsigned int)CH(off-2) & 0x3f) << 6) |
    #####:  813:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  814:
    #####:  815:            if(off > 3 && IS_UTF8_LEAD4(CH(off-4)) && IS_UTF8_TAIL(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  816:                return (((unsigned int)CH(off-4) & 0x07) << 18) |
    #####:  817:                       (((unsigned int)CH(off-3) & 0x3f) << 12) |
    #####:  818:                       (((unsigned int)CH(off-2) & 0x3f) << 6) |
    #####:  819:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  820:        }
        -:  821:
    #####:  822:        return CH(off-1);
        -:  823:    }
        -:  824:
        -:  825:    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)
        -:  826:    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))
        -:  827:    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(md_decode_utf8_before__(ctx, off))
        -:  828:
        -:  829:    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))
        -:  830:    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf8_before__(ctx, off))
        -:  831:
        -:  832:    static inline int
        -:  833:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)
        -:  834:    {
        1:  835:        return md_decode_utf8__(str+off, str_size-off, p_char_size);
        -:  836:    }
        -:  837:#else
        -:  838:    #define ISUNICODEWHITESPACE_(codepoint) ISWHITESPACE_(codepoint)
        -:  839:    #define ISUNICODEWHITESPACE(off)        ISWHITESPACE(off)
        -:  840:    #define ISUNICODEWHITESPACEBEFORE(off)  ISWHITESPACE((off)-1)
        -:  841:
        -:  842:    #define ISUNICODEPUNCT(off)             ISPUNCT(off)
        -:  843:    #define ISUNICODEPUNCTBEFORE(off)       ISPUNCT((off)-1)
        -:  844:
        -:  845:    static inline void
        -:  846:    md_get_unicode_fold_info(int codepoint, MD_UNICODE_FOLD_INFO* info)
        -:  847:    {
        -:  848:        info->codepoints[0] = codepoint;
        -:  849:        if(ISUPPER_(codepoint))
        -:  850:            info->codepoints[0] += 'a' - 'A';
        -:  851:        info->n_codepoints = 1;
        -:  852:    }
        -:  853:
        -:  854:    static inline int
        -:  855:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_size)
        -:  856:    {
        -:  857:        *p_size = 1;
        -:  858:        return str[off];
        -:  859:    }
        -:  860:#endif
        -:  861:
        -:  862:
        -:  863:/*************************************
        -:  864: ***  Helper string manipulations  ***
        -:  865: *************************************/
        -:  866:
        -:  867:/* Fill buffer with copy of the string between 'beg' and 'end' but replace any
        -:  868: * line breaks with given replacement character.
        -:  869: *
        -:  870: * NOTE: Caller is responsible to make sure the buffer is large enough.
        -:  871: * (Given the output is always shorter then input, (end - beg) is good idea
        -:  872: * what the caller should allocate.)
        -:  873: */
        -:  874:static void
        -:  875:md_merge_lines(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,
        -:  876:               CHAR line_break_replacement_char, CHAR* buffer, SZ* p_size)
        -:  877:{
        -:  878:    CHAR* ptr = buffer;
        -:  879:    int line_index = 0;
        -:  880:    OFF off = beg;
        -:  881:
        -:  882:    while(1) {
    #####:  883:        const MD_LINE* line = &lines[line_index];
    #####:  884:        OFF line_end = line->end;
    #####:  885:        if(end < line_end)
    #####:  886:            line_end = end;
        -:  887:
    #####:  888:        while(off < line_end) {
    #####:  889:            *ptr = CH(off);
    #####:  890:            ptr++;
    #####:  891:            off++;
        -:  892:        }
        -:  893:
    #####:  894:        if(off >= end) {
    #####:  895:            *p_size = ptr - buffer;
        -:  896:            return;
        -:  897:        }
        -:  898:
    #####:  899:        *ptr = line_break_replacement_char;
    #####:  900:        ptr++;
        -:  901:
    #####:  902:        line_index++;
    #####:  903:        off = lines[line_index].beg;
        -:  904:    }
        -:  905:}
        -:  906:
        -:  907:/* Wrapper of md_merge_lines() which allocates new buffer for the output string.
        -:  908: */
        -:  909:static int
    #####:  910:md_merge_lines_alloc(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,
        -:  911:                    CHAR line_break_replacement_char, CHAR** p_str, SZ* p_size)
        -:  912:{
        -:  913:    CHAR* buffer;
        -:  914:
    #####:  915:    buffer = (CHAR*) malloc(sizeof(CHAR) * (end - beg));
    #####:  916:    if(buffer == NULL) {
    #####:  917:        MD_LOG("malloc() failed.");
        -:  918:        return -1;
        -:  919:    }
        -:  920:
    #####:  921:    md_merge_lines(ctx, beg, end, lines, n_lines,
        -:  922:                line_break_replacement_char, buffer, p_size);
        -:  923:
    #####:  924:    *p_str = buffer;
    #####:  925:    return 0;
        -:  926:}
        -:  927:
        -:  928:static OFF
    #####:  929:md_skip_unicode_whitespace(const CHAR* label, OFF off, SZ size)
        -:  930:{
    #####:  931:    SZ char_size;
        -:  932:    int codepoint;
        -:  933:
    #####:  934:    while(off < size) {
    #####:  935:        codepoint = md_decode_unicode(label, off, size, &char_size);
    #####:  936:        if(!ISUNICODEWHITESPACE_(codepoint)  &&  !ISNEWLINE_(label[off]))
        -:  937:            break;
    #####:  938:        off += char_size;
        -:  939:    }
        -:  940:
    #####:  941:    return off;
        -:  942:}
        -:  943:
        -:  944:
        -:  945:/******************************
        -:  946: ***  Recognizing raw HTML  ***
        -:  947: ******************************/
        -:  948:
        -:  949:/* md_is_html_tag() may be called when processing inlines (inline raw HTML)
        -:  950: * or when breaking document to blocks (checking for start of HTML block type 7).
        -:  951: *
        -:  952: * When breaking document to blocks, we do not yet know line boundaries, but
        -:  953: * in that case the whole tag has to live on a single line. We distinguish this
        -:  954: * by n_lines == 0.
        -:  955: */
        -:  956:static int
    #####:  957:md_is_html_tag(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -:  958:{
        -:  959:    int attr_state;
    #####:  960:    OFF off = beg;
    #####:  961:    OFF line_end = (n_lines > 0) ? lines[0].end : ctx->size;
    #####:  962:    int i = 0;
        -:  963:
    #####:  964:    MD_ASSERT(CH(beg) == _T('<'));
        -:  965:
    #####:  966:    if(off + 1 >= line_end)
        -:  967:        return FALSE;
    #####:  968:    off++;
        -:  969:
        -:  970:    /* For parsing attributes, we need a little state automaton below.
        -:  971:     * State -1: no attributes are allowed.
        -:  972:     * State 0: attribute could follow after some whitespace.
        -:  973:     * State 1: after a whitespace (attribute name may follow).
        -:  974:     * State 2: after attribute name ('=' MAY follow).
        -:  975:     * State 3: after '=' (value specification MUST follow).
        -:  976:     * State 41: in middle of unquoted attribute value.
        -:  977:     * State 42: in middle of single-quoted attribute value.
        -:  978:     * State 43: in middle of double-quoted attribute value.
        -:  979:     */
    #####:  980:    attr_state = 0;
        -:  981:
    #####:  982:    if(CH(off) == _T('/')) {
        -:  983:        /* Closer tag "</ ... >". No attributes may be present. */
    #####:  984:        attr_state = -1;
    #####:  985:        off++;
        -:  986:    }
        -:  987:
        -:  988:    /* Tag name */
    #####:  989:    if(off >= line_end  ||  !ISALPHA(off))
        -:  990:        return FALSE;
    #####:  991:    off++;
    #####:  992:    while(off < line_end  &&  (ISALNUM(off)  ||  CH(off) == _T('-')))
    #####:  993:        off++;
        -:  994:
        -:  995:    /* (Optional) attributes (if not closer), (optional) '/' (if not closer)
        -:  996:     * and final '>'. */
        -:  997:    while(1) {
    #####:  998:        while(off < line_end  &&  !ISNEWLINE(off)) {
    #####:  999:            if(attr_state > 40) {
    #####: 1000:                if(attr_state == 41 && (ISBLANK(off) || ISANYOF(off, _T("\"'=<>`")))) {
    #####: 1001:                    attr_state = 0;
    #####: 1002:                    off--;  /* Put the char back for re-inspection in the new state. */
    #####: 1003:                } else if(attr_state == 42 && CH(off) == _T('\'')) {
        -: 1004:                    attr_state = 0;
    #####: 1005:                } else if(attr_state == 43 && CH(off) == _T('"')) {
    #####: 1006:                    attr_state = 0;
        -: 1007:                }
    #####: 1008:                off++;
    #####: 1009:            } else if(ISWHITESPACE(off)) {
    #####: 1010:                if(attr_state == 0)
    #####: 1011:                    attr_state = 1;
    #####: 1012:                off++;
    #####: 1013:            } else if(attr_state <= 2 && CH(off) == _T('>')) {
        -: 1014:                /* End. */
        -: 1015:                goto done;
    #####: 1016:            } else if(attr_state <= 2 && CH(off) == _T('/') && off+1 < line_end && CH(off+1) == _T('>')) {
        -: 1017:                /* End with digraph '/>' */
        -: 1018:                off++;
        -: 1019:                goto done;
    #####: 1020:            } else if((attr_state == 1 || attr_state == 2) && (ISALPHA(off) || CH(off) == _T('_') || CH(off) == _T(':'))) {
    #####: 1021:                off++;
        -: 1022:                /* Attribute name */
    #####: 1023:                while(off < line_end && (ISALNUM(off) || ISANYOF(off, _T("_.:-"))))
    #####: 1024:                    off++;
        -: 1025:                attr_state = 2;
    #####: 1026:            } else if(attr_state == 2 && CH(off) == _T('=')) {
        -: 1027:                /* Attribute assignment sign */
    #####: 1028:                off++;
    #####: 1029:                attr_state = 3;
    #####: 1030:            } else if(attr_state == 3) {
        -: 1031:                /* Expecting start of attribute value. */
    #####: 1032:                if(CH(off) == _T('"'))
        -: 1033:                    attr_state = 43;
    #####: 1034:                else if(CH(off) == _T('\''))
        -: 1035:                    attr_state = 42;
    #####: 1036:                else if(!ISANYOF(off, _T("\"'=<>`"))  &&  !ISNEWLINE(off))
        -: 1037:                    attr_state = 41;
        -: 1038:                else
        -: 1039:                    return FALSE;
    #####: 1040:                off++;
        -: 1041:            } else {
        -: 1042:                /* Anything unexpected. */
        -: 1043:                return FALSE;
        -: 1044:            }
        -: 1045:        }
        -: 1046:
        -: 1047:        /* We have to be on a single line. See definition of start condition
        -: 1048:         * of HTML block, type 7. */
    #####: 1049:        if(n_lines == 0)
        -: 1050:            return FALSE;
        -: 1051:
    #####: 1052:        i++;
    #####: 1053:        if(i >= n_lines)
        -: 1054:            return FALSE;
        -: 1055:
    #####: 1056:        off = lines[i].beg;
    #####: 1057:        line_end = lines[i].end;
        -: 1058:
    #####: 1059:        if(attr_state == 0  ||  attr_state == 41)
    #####: 1060:            attr_state = 1;
        -: 1061:
    #####: 1062:        if(off >= max_end)
        -: 1063:            return FALSE;
        -: 1064:    }
        -: 1065:
    #####: 1066:done:
    #####: 1067:    if(off >= max_end)
        -: 1068:        return FALSE;
        -: 1069:
    #####: 1070:    *p_end = off+1;
        -: 1071:    return TRUE;
        -: 1072:}
        -: 1073:
        -: 1074:static int
    #####: 1075:md_scan_for_html_closer(MD_CTX* ctx, const MD_CHAR* str, MD_SIZE len,
        -: 1076:                        const MD_LINE* lines, int n_lines,
        -: 1077:                        OFF beg, OFF max_end, OFF* p_end,
        -: 1078:                        OFF* p_scan_horizon)
        -: 1079:{
    #####: 1080:    OFF off = beg;
    #####: 1081:    int i = 0;
        -: 1082:
    #####: 1083:    if(off < *p_scan_horizon  &&  *p_scan_horizon >= max_end - len) {
        -: 1084:        /* We have already scanned the range up to the max_end and we now
        -: 1085:         * there is nothing to see. */
        -: 1086:        return FALSE;
        -: 1087:    }
        -: 1088:
        -: 1089:    while(TRUE) {
    #####: 1090:        while(off + len <= lines[i].end  &&  off + len <= max_end) {
    #####: 1091:            if(md_ascii_eq(STR(off), str, len)) {
        -: 1092:                /* Success. */
    #####: 1093:                *p_end = off + len;
        -: 1094:                return TRUE;
        -: 1095:            }
    #####: 1096:            off++;
        -: 1097:        }
        -: 1098:
    #####: 1099:        i++;
    #####: 1100:        if(off >= max_end  ||  i >= n_lines) {
        -: 1101:            /* Failure. */
    #####: 1102:            *p_scan_horizon = off;
        -: 1103:            return FALSE;
        -: 1104:        }
        -: 1105:
    #####: 1106:        off = lines[i].beg;
        -: 1107:    }
        -: 1108:}
        -: 1109:
        -: 1110:static int
    #####: 1111:md_is_html_comment(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1112:{
    #####: 1113:    OFF off = beg;
        -: 1114:
    #####: 1115:    MD_ASSERT(CH(beg) == _T('<'));
        -: 1116:
    #####: 1117:    if(off + 4 >= lines[0].end)
        -: 1118:        return FALSE;
    #####: 1119:    if(CH(off+1) != _T('!')  ||  CH(off+2) != _T('-')  ||  CH(off+3) != _T('-'))
        -: 1120:        return FALSE;
    #####: 1121:    off += 4;
        -: 1122:
        -: 1123:    /* ">" and "->" must not follow the opening. */
    #####: 1124:    if(off < lines[0].end  &&  CH(off) == _T('>'))
        -: 1125:        return FALSE;
    #####: 1126:    if(off+1 < lines[0].end  &&  CH(off) == _T('-')  &&  CH(off+1) == _T('>'))
        -: 1127:        return FALSE;
        -: 1128:
        -: 1129:    /* HTML comment must not contyain "--", so we scan just for "--" instead
        -: 1130:     * of "-->" and verify manually that '>' follows. */
    #####: 1131:    if(md_scan_for_html_closer(ctx, _T("--"), 2,
        -: 1132:                lines, n_lines, off, max_end, p_end, &ctx->html_comment_horizon))
        -: 1133:    {
    #####: 1134:        if(*p_end < max_end  &&  CH(*p_end) == _T('>')) {
    #####: 1135:            *p_end = *p_end + 1;
    #####: 1136:            return TRUE;
        -: 1137:        }
        -: 1138:    }
        -: 1139:
        -: 1140:    return FALSE;
        -: 1141:}
        -: 1142:
        -: 1143:static int
    #####: 1144:md_is_html_processing_instruction(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1145:{
    #####: 1146:    OFF off = beg;
        -: 1147:
    #####: 1148:    if(off + 2 >= lines[0].end)
        -: 1149:        return FALSE;
    #####: 1150:    if(CH(off+1) != _T('?'))
        -: 1151:        return FALSE;
    #####: 1152:    off += 2;
        -: 1153:
    #####: 1154:    return md_scan_for_html_closer(ctx, _T("?>"), 2,
        -: 1155:                lines, n_lines, off, max_end, p_end, &ctx->html_proc_instr_horizon);
        -: 1156:}
        -: 1157:
        -: 1158:static int
    #####: 1159:md_is_html_declaration(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1160:{
    #####: 1161:    OFF off = beg;
        -: 1162:
    #####: 1163:    if(off + 2 >= lines[0].end)
        -: 1164:        return FALSE;
    #####: 1165:    if(CH(off+1) != _T('!'))
        -: 1166:        return FALSE;
    #####: 1167:    off += 2;
        -: 1168:
        -: 1169:    /* Declaration name. */
    #####: 1170:    if(off >= lines[0].end  ||  !ISALPHA(off))
        -: 1171:        return FALSE;
    #####: 1172:    off++;
    #####: 1173:    while(off < lines[0].end  &&  ISALPHA(off))
    #####: 1174:        off++;
    #####: 1175:    if(off < lines[0].end  &&  !ISWHITESPACE(off))
        -: 1176:        return FALSE;
        -: 1177:
    #####: 1178:    return md_scan_for_html_closer(ctx, _T(">"), 1,
        -: 1179:                lines, n_lines, off, max_end, p_end, &ctx->html_decl_horizon);
        -: 1180:}
        -: 1181:
        -: 1182:static int
    #####: 1183:md_is_html_cdata(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1184:{
        -: 1185:    static const CHAR open_str[] = _T("<![CDATA[");
        -: 1186:    static const SZ open_size = SIZEOF_ARRAY(open_str) - 1;
        -: 1187:
    #####: 1188:    OFF off = beg;
        -: 1189:
    #####: 1190:    if(off + open_size >= lines[0].end)
        -: 1191:        return FALSE;
    #####: 1192:    if(memcmp(STR(off), open_str, open_size) != 0)
        -: 1193:        return FALSE;
    #####: 1194:    off += open_size;
        -: 1195:
    #####: 1196:    if(lines[n_lines-1].end < max_end)
    #####: 1197:        max_end = lines[n_lines-1].end - 2;
        -: 1198:
    #####: 1199:    return md_scan_for_html_closer(ctx, _T("]]>"), 3,
        -: 1200:                lines, n_lines, off, max_end, p_end, &ctx->html_cdata_horizon);
        -: 1201:}
        -: 1202:
        -: 1203:static int
    #####: 1204:md_is_html_any(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1205:{
    #####: 1206:    MD_ASSERT(CH(beg) == _T('<'));
    #####: 1207:    return (md_is_html_tag(ctx, lines, n_lines, beg, max_end, p_end)  ||
    #####: 1208:            md_is_html_comment(ctx, lines, n_lines, beg, max_end, p_end)  ||
    #####: 1209:            md_is_html_processing_instruction(ctx, lines, n_lines, beg, max_end, p_end)  ||
    #####: 1210:            md_is_html_declaration(ctx, lines, n_lines, beg, max_end, p_end)  ||
    #####: 1211:            md_is_html_cdata(ctx, lines, n_lines, beg, max_end, p_end));
        -: 1212:}
        -: 1213:
        -: 1214:
        -: 1215:/****************************
        -: 1216: ***  Recognizing Entity  ***
        -: 1217: ****************************/
        -: 1218:
        -: 1219:static int
    #####: 1220:md_is_hex_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1221:{
    #####: 1222:    OFF off = beg;
        -: 1223:
    #####: 1224:    while(off < max_end  &&  ISXDIGIT_(text[off])  &&  off - beg <= 8)
    #####: 1225:        off++;
        -: 1226:
    #####: 1227:    if(1 <= off - beg  &&  off - beg <= 8) {
    #####: 1228:        *p_end = off;
        -: 1229:        return TRUE;
        -: 1230:    } else {
        -: 1231:        return FALSE;
        -: 1232:    }
        -: 1233:}
        -: 1234:
        -: 1235:static int
        -: 1236:md_is_dec_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1237:{
        -: 1238:    OFF off = beg;
        -: 1239:
    #####: 1240:    while(off < max_end  &&  ISDIGIT_(text[off])  &&  off - beg <= 8)
    #####: 1241:        off++;
        -: 1242:
    #####: 1243:    if(1 <= off - beg  &&  off - beg <= 8) {
    #####: 1244:        *p_end = off;
        -: 1245:        return TRUE;
        -: 1246:    } else {
        -: 1247:        return FALSE;
        -: 1248:    }
        -: 1249:}
        -: 1250:
        -: 1251:static int
    #####: 1252:md_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1253:{
    #####: 1254:    OFF off = beg;
        -: 1255:
    #####: 1256:    if(off < max_end  &&  ISALPHA_(text[off]))
    #####: 1257:        off++;
        -: 1258:    else
        -: 1259:        return FALSE;
        -: 1260:
    #####: 1261:    while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48)
    #####: 1262:        off++;
        -: 1263:
    #####: 1264:    if(2 <= off - beg  &&  off - beg <= 48) {
    #####: 1265:        *p_end = off;
        -: 1266:        return TRUE;
        -: 1267:    } else {
        -: 1268:        return FALSE;
        -: 1269:    }
        -: 1270:}
        -: 1271:
        -: 1272:static int
    #####: 1273:md_is_entity_str(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1274:{
        -: 1275:    int is_contents;
    #####: 1276:    OFF off = beg;
        -: 1277:
    #####: 1278:    MD_ASSERT(text[off] == _T('&'));
    #####: 1279:    off++;
        -: 1280:
    #####: 1281:    if(off+2 < max_end  &&  text[off] == _T('#')  &&  (text[off+1] == _T('x') || text[off+1] == _T('X')))
    #####: 1282:        is_contents = md_is_hex_entity_contents(ctx, text, off+2, max_end, &off);
    #####: 1283:    else if(off+1 < max_end  &&  text[off] == _T('#'))
    #####: 1284:        is_contents = md_is_dec_entity_contents(ctx, text, off+1, max_end, &off);
        -: 1285:    else
    #####: 1286:        is_contents = md_is_named_entity_contents(ctx, text, off, max_end, &off);
        -: 1287:
    #####: 1288:    if(is_contents  &&  off < max_end  &&  text[off] == _T(';')) {
    #####: 1289:        *p_end = off+1;
        -: 1290:        return TRUE;
        -: 1291:    } else {
        -: 1292:        return FALSE;
        -: 1293:    }
        -: 1294:}
        -: 1295:
        -: 1296:static inline int
        -: 1297:md_is_entity(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)
        -: 1298:{
    #####: 1299:    return md_is_entity_str(ctx, ctx->text, beg, max_end, p_end);
        -: 1300:}
        -: 1301:
        -: 1302:
        -: 1303:/******************************
        -: 1304: ***  Attribute Management  ***
        -: 1305: ******************************/
        -: 1306:
        -: 1307:typedef struct MD_ATTRIBUTE_BUILD_tag MD_ATTRIBUTE_BUILD;
        -: 1308:struct MD_ATTRIBUTE_BUILD_tag {
        -: 1309:    CHAR* text;
        -: 1310:    MD_TEXTTYPE* substr_types;
        -: 1311:    OFF* substr_offsets;
        -: 1312:    int substr_count;
        -: 1313:    int substr_alloc;
        -: 1314:    MD_TEXTTYPE trivial_types[1];
        -: 1315:    OFF trivial_offsets[2];
        -: 1316:};
        -: 1317:
        -: 1318:
        -: 1319:#define MD_BUILD_ATTR_NO_ESCAPES    0x0001
        -: 1320:
        -: 1321:static int
    #####: 1322:md_build_attr_append_substr(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build,
        -: 1323:                            MD_TEXTTYPE type, OFF off)
        -: 1324:{
    #####: 1325:    if(build->substr_count >= build->substr_alloc) {
        -: 1326:        MD_TEXTTYPE* new_substr_types;
        -: 1327:        OFF* new_substr_offsets;
        -: 1328:
    #####: 1329:        build->substr_alloc = (build->substr_alloc == 0 ? 8 : build->substr_alloc * 2);
        -: 1330:
    #####: 1331:        new_substr_types = (MD_TEXTTYPE*) realloc(build->substr_types,
    #####: 1332:                                    build->substr_alloc * sizeof(MD_TEXTTYPE));
    #####: 1333:        if(new_substr_types == NULL) {
    #####: 1334:            MD_LOG("realloc() failed.");
        -: 1335:            return -1;
        -: 1336:        }
        -: 1337:        /* Note +1 to reserve space for final offset (== raw_size). */
    #####: 1338:        new_substr_offsets = (OFF*) realloc(build->substr_offsets,
    #####: 1339:                                    (build->substr_alloc+1) * sizeof(OFF));
    #####: 1340:        if(new_substr_offsets == NULL) {
    #####: 1341:            MD_LOG("realloc() failed.");
    #####: 1342:            free(new_substr_types);
        -: 1343:            return -1;
        -: 1344:        }
        -: 1345:
    #####: 1346:        build->substr_types = new_substr_types;
    #####: 1347:        build->substr_offsets = new_substr_offsets;
        -: 1348:    }
        -: 1349:
    #####: 1350:    build->substr_types[build->substr_count] = type;
    #####: 1351:    build->substr_offsets[build->substr_count] = off;
    #####: 1352:    build->substr_count++;
        -: 1353:    return 0;
        -: 1354:}
        -: 1355:
        -: 1356:static void
    #####: 1357:md_free_attribute(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build)
        -: 1358:{
    #####: 1359:    if(build->substr_alloc > 0) {
    #####: 1360:        free(build->text);
    #####: 1361:        free(build->substr_types);
    #####: 1362:        free(build->substr_offsets);
        -: 1363:    }
    #####: 1364:}
        -: 1365:
        -: 1366:static int
    #####: 1367:md_build_attribute(MD_CTX* ctx, const CHAR* raw_text, SZ raw_size,
        -: 1368:                   unsigned flags, MD_ATTRIBUTE* attr, MD_ATTRIBUTE_BUILD* build)
        -: 1369:{
        -: 1370:    OFF raw_off, off;
        -: 1371:    int is_trivial;
    #####: 1372:    int ret = 0;
        -: 1373:
    #####: 1374:    memset(build, 0, sizeof(MD_ATTRIBUTE_BUILD));
        -: 1375:
        -: 1376:    /* If there is no backslash and no ampersand, build trivial attribute
        -: 1377:     * without any malloc(). */
    #####: 1378:    is_trivial = TRUE;
    #####: 1379:    for(raw_off = 0; raw_off < raw_size; raw_off++) {
    #####: 1380:        if(ISANYOF3_(raw_text[raw_off], _T('\\'), _T('&'), _T('\0'))) {
        -: 1381:            is_trivial = FALSE;
        -: 1382:            break;
        -: 1383:        }
        -: 1384:    }
        -: 1385:
    #####: 1386:    if(is_trivial) {
    #####: 1387:        build->text = (CHAR*) (raw_size ? raw_text : NULL);
    #####: 1388:        build->substr_types = build->trivial_types;
    #####: 1389:        build->substr_offsets = build->trivial_offsets;
    #####: 1390:        build->substr_count = 1;
    #####: 1391:        build->substr_alloc = 0;
    #####: 1392:        build->trivial_types[0] = MD_TEXT_NORMAL;
    #####: 1393:        build->trivial_offsets[0] = 0;
    #####: 1394:        build->trivial_offsets[1] = raw_size;
    #####: 1395:        off = raw_size;
        -: 1396:    } else {
    #####: 1397:        build->text = (CHAR*) malloc(raw_size * sizeof(CHAR));
    #####: 1398:        if(build->text == NULL) {
    #####: 1399:            MD_LOG("malloc() failed.");
        -: 1400:            goto abort;
        -: 1401:        }
        -: 1402:
        -: 1403:        raw_off = 0;
        -: 1404:        off = 0;
        -: 1405:
    #####: 1406:        while(raw_off < raw_size) {
    #####: 1407:            if(raw_text[raw_off] == _T('\0')) {
    #####: 1408:                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NULLCHAR, off));
    #####: 1409:                memcpy(build->text + off, raw_text + raw_off, 1);
    #####: 1410:                off++;
    #####: 1411:                raw_off++;
    #####: 1412:                continue;
        -: 1413:            }
        -: 1414:
    #####: 1415:            if(raw_text[raw_off] == _T('&')) {
    #####: 1416:                OFF ent_end;
        -: 1417:
    #####: 1418:                if(md_is_entity_str(ctx, raw_text, raw_off, raw_size, &ent_end)) {
    #####: 1419:                    MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_ENTITY, off));
    #####: 1420:                    memcpy(build->text + off, raw_text + raw_off, ent_end - raw_off);
    #####: 1421:                    off += ent_end - raw_off;
    #####: 1422:                    raw_off = ent_end;
    #####: 1423:                    continue;
        -: 1424:                }
        -: 1425:            }
        -: 1426:
    #####: 1427:            if(build->substr_count == 0  ||  build->substr_types[build->substr_count-1] != MD_TEXT_NORMAL)
    #####: 1428:                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NORMAL, off));
        -: 1429:
    #####: 1430:            if(!(flags & MD_BUILD_ATTR_NO_ESCAPES)  &&
    #####: 1431:               raw_text[raw_off] == _T('\\')  &&  raw_off+1 < raw_size  &&
    #####: 1432:               (ISPUNCT_(raw_text[raw_off+1]) || ISNEWLINE_(raw_text[raw_off+1])))
    #####: 1433:                raw_off++;
        -: 1434:
    #####: 1435:            build->text[off++] = raw_text[raw_off++];
        -: 1436:        }
    #####: 1437:        build->substr_offsets[build->substr_count] = off;
        -: 1438:    }
        -: 1439:
    #####: 1440:    attr->text = build->text;
    #####: 1441:    attr->size = off;
    #####: 1442:    attr->substr_offsets = build->substr_offsets;
    #####: 1443:    attr->substr_types = build->substr_types;
    #####: 1444:    return 0;
        -: 1445:
    #####: 1446:abort:
    #####: 1447:    md_free_attribute(ctx, build);
    #####: 1448:    return -1;
        -: 1449:}
        -: 1450:
        -: 1451:
        -: 1452:/*********************************************
        -: 1453: ***  Dictionary of Reference Definitions  ***
        -: 1454: *********************************************/
        -: 1455:
        -: 1456:#define MD_FNV1A_BASE       2166136261
        -: 1457:#define MD_FNV1A_PRIME      16777619
        -: 1458:
        -: 1459:static inline unsigned
        -: 1460:md_fnv1a(unsigned base, const void* data, size_t n)
        -: 1461:{
    #####: 1462:    const unsigned char* buf = (const unsigned char*) data;
    #####: 1463:    unsigned hash = base;
        -: 1464:    size_t i;
        -: 1465:
    #####: 1466:    for(i = 0; i < n; i++) {
    #####: 1467:        hash ^= buf[i];
    #####: 1468:        hash *= MD_FNV1A_PRIME;
        -: 1469:    }
        -: 1470:
        -: 1471:    return hash;
        -: 1472:}
        -: 1473:
        -: 1474:
        -: 1475:struct MD_REF_DEF_tag {
        -: 1476:    CHAR* label;
        -: 1477:    CHAR* title;
        -: 1478:    unsigned hash;
        -: 1479:    SZ label_size                   : 24;
        -: 1480:    unsigned label_needs_free       :  1;
        -: 1481:    unsigned title_needs_free       :  1;
        -: 1482:    SZ title_size;
        -: 1483:    OFF dest_beg;
        -: 1484:    OFF dest_end;
        -: 1485:};
        -: 1486:
        -: 1487:/* Label equivalence is quite complicated with regards to whitespace and case
        -: 1488: * folding. This complicates computing a hash of it as well as direct comparison
        -: 1489: * of two labels. */
        -: 1490:
        -: 1491:static unsigned
    #####: 1492:md_link_label_hash(const CHAR* label, SZ size)
        -: 1493:{
    #####: 1494:    unsigned hash = MD_FNV1A_BASE;
        -: 1495:    OFF off;
    #####: 1496:    int codepoint;
    #####: 1497:    int is_whitespace = FALSE;
        -: 1498:
    #####: 1499:    off = md_skip_unicode_whitespace(label, 0, size);
    #####: 1500:    while(off < size) {
    #####: 1501:        SZ char_size;
        -: 1502:
    #####: 1503:        codepoint = md_decode_unicode(label, off, size, &char_size);
    #####: 1504:        is_whitespace = ISUNICODEWHITESPACE_(codepoint) || ISNEWLINE_(label[off]);
        -: 1505:
        -: 1506:        if(is_whitespace) {
    #####: 1507:            codepoint = ' ';
    #####: 1508:            hash = md_fnv1a(hash, &codepoint, 1 * sizeof(int));
        -: 1509:
    #####: 1510:            off = md_skip_unicode_whitespace(label, off, size);
        -: 1511:        } else {
    #####: 1512:            MD_UNICODE_FOLD_INFO fold_info;
        -: 1513:
    #####: 1514:            md_get_unicode_fold_info(codepoint, &fold_info);
    #####: 1515:            hash = md_fnv1a(hash, fold_info.codepoints, fold_info.n_codepoints * sizeof(int));
        -: 1516:
    #####: 1517:            off += char_size;
        -: 1518:        }
        -: 1519:    }
        -: 1520:
    #####: 1521:    if(!is_whitespace) {
    #####: 1522:        codepoint = ' ';
        -: 1523:        hash = md_fnv1a(hash, &codepoint, 1 * sizeof(int));
        -: 1524:    }
        -: 1525:
    #####: 1526:    return hash;
        -: 1527:}
        -: 1528:
        -: 1529:static int
    #####: 1530:md_link_label_cmp(const CHAR* a_label, SZ a_size, const CHAR* b_label, SZ b_size)
        -: 1531:{
        -: 1532:    OFF a_off;
        -: 1533:    OFF b_off;
        -: 1534:
        -: 1535:    /* The slow path, with Unicode case folding and Unicode whitespace collapsing. */
    #####: 1536:    a_off = md_skip_unicode_whitespace(a_label, 0, a_size);
    #####: 1537:    b_off = md_skip_unicode_whitespace(b_label, 0, b_size);
    #####: 1538:    while(a_off < a_size  ||  b_off < b_size) {
        -: 1539:        int a_codepoint, b_codepoint;
    #####: 1540:        SZ a_char_size, b_char_size;
        -: 1541:        int a_is_whitespace, b_is_whitespace;
        -: 1542:
    #####: 1543:        if(a_off < a_size) {
    #####: 1544:            a_codepoint = md_decode_unicode(a_label, a_off, a_size, &a_char_size);
    #####: 1545:            a_is_whitespace = ISUNICODEWHITESPACE_(a_codepoint) || ISNEWLINE_(a_label[a_off]);
        -: 1546:        } else {
        -: 1547:            /* Treat end of label as a whitespace. */
        -: 1548:            a_codepoint = -1;
        -: 1549:            a_is_whitespace = TRUE;
        -: 1550:        }
        -: 1551:
    #####: 1552:        if(b_off < b_size) {
    #####: 1553:            b_codepoint = md_decode_unicode(b_label, b_off, b_size, &b_char_size);
    #####: 1554:            b_is_whitespace = ISUNICODEWHITESPACE_(b_codepoint) || ISNEWLINE_(b_label[b_off]);
        -: 1555:        } else {
        -: 1556:            /* Treat end of label as a whitespace. */
        -: 1557:            b_codepoint = -1;
        -: 1558:            b_is_whitespace = TRUE;
        -: 1559:        }
        -: 1560:
    #####: 1561:        if(a_is_whitespace || b_is_whitespace) {
    #####: 1562:            if(!a_is_whitespace || !b_is_whitespace)
    #####: 1563:                return (a_is_whitespace ? -1 : +1);
        -: 1564:
    #####: 1565:            a_off = md_skip_unicode_whitespace(a_label, a_off, a_size);
    #####: 1566:            b_off = md_skip_unicode_whitespace(b_label, b_off, b_size);
        -: 1567:        } else {
    #####: 1568:            MD_UNICODE_FOLD_INFO a_fold_info, b_fold_info;
        -: 1569:            int cmp;
        -: 1570:
    #####: 1571:            md_get_unicode_fold_info(a_codepoint, &a_fold_info);
    #####: 1572:            md_get_unicode_fold_info(b_codepoint, &b_fold_info);
        -: 1573:
    #####: 1574:            if(a_fold_info.n_codepoints != b_fold_info.n_codepoints)
    #####: 1575:                return (a_fold_info.n_codepoints - b_fold_info.n_codepoints);
    #####: 1576:            cmp = memcmp(a_fold_info.codepoints, b_fold_info.codepoints, a_fold_info.n_codepoints * sizeof(int));
    #####: 1577:            if(cmp != 0)
        -: 1578:                return cmp;
        -: 1579:
    #####: 1580:            a_off += a_char_size;
    #####: 1581:            b_off += b_char_size;
        -: 1582:        }
        -: 1583:    }
        -: 1584:
        -: 1585:    return 0;
        -: 1586:}
        -: 1587:
        -: 1588:typedef struct MD_REF_DEF_LIST_tag MD_REF_DEF_LIST;
        -: 1589:struct MD_REF_DEF_LIST_tag {
        -: 1590:    int n_ref_defs;
        -: 1591:    int alloc_ref_defs;
        -: 1592:    MD_REF_DEF* ref_defs[];  /* Valid items always  point into ctx->ref_defs[] */
        -: 1593:};
        -: 1594:
        -: 1595:static int
    #####: 1596:md_ref_def_cmp(const void* a, const void* b)
        -: 1597:{
    #####: 1598:    const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;
    #####: 1599:    const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;
        -: 1600:
    #####: 1601:    if(a_ref->hash < b_ref->hash)
        -: 1602:        return -1;
    #####: 1603:    else if(a_ref->hash > b_ref->hash)
        -: 1604:        return +1;
        -: 1605:    else
    #####: 1606:        return md_link_label_cmp(a_ref->label, a_ref->label_size, b_ref->label, b_ref->label_size);
        -: 1607:}
        -: 1608:
        -: 1609:static int
    #####: 1610:md_ref_def_cmp_stable(const void* a, const void* b)
        -: 1611:{
        -: 1612:    int cmp;
        -: 1613:
    #####: 1614:    cmp = md_ref_def_cmp(a, b);
        -: 1615:
        -: 1616:    /* Ensure stability of the sorting. */
    #####: 1617:    if(cmp == 0) {
    #####: 1618:        const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;
    #####: 1619:        const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;
        -: 1620:
    #####: 1621:        if(a_ref < b_ref)
        -: 1622:            cmp = -1;
    #####: 1623:        else if(a_ref > b_ref)
        -: 1624:            cmp = +1;
        -: 1625:        else
    #####: 1626:            cmp = 0;
        -: 1627:    }
        -: 1628:
    #####: 1629:    return cmp;
        -: 1630:}
        -: 1631:
        -: 1632:static int
    #####: 1633:md_build_ref_def_hashtable(MD_CTX* ctx)
        -: 1634:{
        -: 1635:    int i, j;
        -: 1636:
    #####: 1637:    if(ctx->n_ref_defs == 0)
        -: 1638:        return 0;
        -: 1639:
    #####: 1640:    ctx->ref_def_hashtable_size = (ctx->n_ref_defs * 5) / 4;
    #####: 1641:    ctx->ref_def_hashtable = malloc(ctx->ref_def_hashtable_size * sizeof(void*));
    #####: 1642:    if(ctx->ref_def_hashtable == NULL) {
    #####: 1643:        MD_LOG("malloc() failed.");
        -: 1644:        goto abort;
        -: 1645:    }
    #####: 1646:    memset(ctx->ref_def_hashtable, 0, ctx->ref_def_hashtable_size * sizeof(void*));
        -: 1647:
        -: 1648:    /* Each member of ctx->ref_def_hashtable[] can be:
        -: 1649:     *  -- NULL,
        -: 1650:     *  -- pointer to the MD_REF_DEF in ctx->ref_defs[], or
        -: 1651:     *  -- pointer to a MD_REF_DEF_LIST, which holds multiple pointers to
        -: 1652:     *     such MD_REF_DEFs.
        -: 1653:     */
    #####: 1654:    for(i = 0; i < ctx->n_ref_defs; i++) {
    #####: 1655:        MD_REF_DEF* def = &ctx->ref_defs[i];
        -: 1656:        void* bucket;
        -: 1657:        MD_REF_DEF_LIST* list;
        -: 1658:
    #####: 1659:        def->hash = md_link_label_hash(def->label, def->label_size);
    #####: 1660:        bucket = ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size];
        -: 1661:
    #####: 1662:        if(bucket == NULL) {
    #####: 1663:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = def;
    #####: 1664:            continue;
        -: 1665:        }
        -: 1666:
    #####: 1667:        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {
        -: 1668:            /* The bucket already contains one ref. def. Lets see whether it
        -: 1669:             * is the same label (ref. def. duplicate) or different one
        -: 1670:             * (hash conflict). */
    #####: 1671:            MD_REF_DEF* old_def = (MD_REF_DEF*) bucket;
        -: 1672:
    #####: 1673:            if(md_link_label_cmp(def->label, def->label_size, old_def->label, old_def->label_size) == 0) {
        -: 1674:                /* Ignore this ref. def. */
    #####: 1675:                continue;
        -: 1676:            }
        -: 1677:
        -: 1678:            /* Make the bucket capable of holding more ref. defs. */
    #####: 1679:            list = (MD_REF_DEF_LIST*) malloc(sizeof(MD_REF_DEF_LIST) + 4 * sizeof(MD_REF_DEF));
    #####: 1680:            if(list == NULL) {
    #####: 1681:                MD_LOG("malloc() failed.");
        -: 1682:                goto abort;
        -: 1683:            }
    #####: 1684:            list->ref_defs[0] = old_def;
    #####: 1685:            list->ref_defs[1] = def;
    #####: 1686:            list->n_ref_defs = 2;
    #####: 1687:            list->alloc_ref_defs = 4;
    #####: 1688:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;
    #####: 1689:            continue;
        -: 1690:        }
        -: 1691:
        -: 1692:        /* Append the def to the bucket list. */
    #####: 1693:        list = (MD_REF_DEF_LIST*) bucket;
    #####: 1694:        if(list->n_ref_defs >= list->alloc_ref_defs) {
    #####: 1695:            MD_REF_DEF_LIST* list_tmp = (MD_REF_DEF_LIST*) realloc(list,
    #####: 1696:                        sizeof(MD_REF_DEF_LIST) + 2 * list->alloc_ref_defs * sizeof(MD_REF_DEF));
    #####: 1697:            if(list_tmp == NULL) {
    #####: 1698:                MD_LOG("realloc() failed.");
        -: 1699:                goto abort;
        -: 1700:            }
    #####: 1701:            list = list_tmp;
    #####: 1702:            list->alloc_ref_defs *= 2;
    #####: 1703:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;
        -: 1704:        }
        -: 1705:
    #####: 1706:        list->ref_defs[list->n_ref_defs] = def;
    #####: 1707:        list->n_ref_defs++;
        -: 1708:    }
        -: 1709:
        -: 1710:    /* Sort the complex buckets so we can use bsearch() with them. */
    #####: 1711:    for(i = 0; i < ctx->ref_def_hashtable_size; i++) {
    #####: 1712:        void* bucket = ctx->ref_def_hashtable[i];
        -: 1713:        MD_REF_DEF_LIST* list;
        -: 1714:
    #####: 1715:        if(bucket == NULL)
    #####: 1716:            continue;
    #####: 1717:        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)
    #####: 1718:            continue;
        -: 1719:
    #####: 1720:        list = (MD_REF_DEF_LIST*) bucket;
    #####: 1721:        qsort(list->ref_defs, list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp_stable);
        -: 1722:
        -: 1723:        /* Disable duplicates. */
    #####: 1724:        for(j = 1; j < list->n_ref_defs; j++) {
    #####: 1725:            if(md_ref_def_cmp(&list->ref_defs[j-1], &list->ref_defs[j]) == 0)
    #####: 1726:                list->ref_defs[j] = list->ref_defs[j-1];
        -: 1727:        }
        -: 1728:    }
        -: 1729:
        -: 1730:    return 0;
        -: 1731:
        -: 1732:abort:
        -: 1733:    return -1;
        -: 1734:}
        -: 1735:
        -: 1736:static void
    #####: 1737:md_free_ref_def_hashtable(MD_CTX* ctx)
        -: 1738:{
    #####: 1739:    if(ctx->ref_def_hashtable != NULL) {
        -: 1740:        int i;
        -: 1741:
    #####: 1742:        for(i = 0; i < ctx->ref_def_hashtable_size; i++) {
    #####: 1743:            void* bucket = ctx->ref_def_hashtable[i];
    #####: 1744:            if(bucket == NULL)
    #####: 1745:                continue;
    #####: 1746:            if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)
    #####: 1747:                continue;
    #####: 1748:            free(bucket);
        -: 1749:        }
        -: 1750:
    #####: 1751:        free(ctx->ref_def_hashtable);
        -: 1752:    }
    #####: 1753:}
        -: 1754:
        -: 1755:static const MD_REF_DEF*
    #####: 1756:md_lookup_ref_def(MD_CTX* ctx, const CHAR* label, SZ label_size)
        -: 1757:{
        -: 1758:    unsigned hash;
        -: 1759:    void* bucket;
        -: 1760:
    #####: 1761:    if(ctx->ref_def_hashtable_size == 0)
        -: 1762:        return NULL;
        -: 1763:
    #####: 1764:    hash = md_link_label_hash(label, label_size);
    #####: 1765:    bucket = ctx->ref_def_hashtable[hash % ctx->ref_def_hashtable_size];
        -: 1766:
    #####: 1767:    if(bucket == NULL) {
        -: 1768:        return NULL;
    #####: 1769:    } else if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {
    #####: 1770:        const MD_REF_DEF* def = (MD_REF_DEF*) bucket;
        -: 1771:
    #####: 1772:        if(md_link_label_cmp(def->label, def->label_size, label, label_size) == 0)
        -: 1773:            return def;
        -: 1774:        else
    #####: 1775:            return NULL;
        -: 1776:    } else {
    #####: 1777:        MD_REF_DEF_LIST* list = (MD_REF_DEF_LIST*) bucket;
    #####: 1778:        MD_REF_DEF key_buf;
    #####: 1779:        const MD_REF_DEF* key = &key_buf;
        -: 1780:        const MD_REF_DEF** ret;
        -: 1781:
    #####: 1782:        key_buf.label = (CHAR*) label;
    #####: 1783:        key_buf.label_size = label_size;
    #####: 1784:        key_buf.hash = md_link_label_hash(key_buf.label, key_buf.label_size);
        -: 1785:
    #####: 1786:        ret = (const MD_REF_DEF**) bsearch(&key, list->ref_defs,
    #####: 1787:                    list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp);
    #####: 1788:        if(ret != NULL)
    #####: 1789:            return *ret;
        -: 1790:        else
        -: 1791:            return NULL;
        -: 1792:    }
        -: 1793:}
        -: 1794:
        -: 1795:
        -: 1796:/***************************
        -: 1797: ***  Recognizing Links  ***
        -: 1798: ***************************/
        -: 1799:
        -: 1800:/* Note this code is partially shared between processing inlines and blocks
        -: 1801: * as reference definitions and links share some helper parser functions.
        -: 1802: */
        -: 1803:
        -: 1804:typedef struct MD_LINK_ATTR_tag MD_LINK_ATTR;
        -: 1805:struct MD_LINK_ATTR_tag {
        -: 1806:    OFF dest_beg;
        -: 1807:    OFF dest_end;
        -: 1808:
        -: 1809:    CHAR* title;
        -: 1810:    SZ title_size;
        -: 1811:    int title_needs_free;
        -: 1812:};
        -: 1813:
        -: 1814:
        -: 1815:static int
        1: 1816:md_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,
        -: 1817:                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,
        -: 1818:                 OFF* p_contents_beg, OFF* p_contents_end)
        -: 1819:{
        1: 1820:    OFF off = beg;
        1: 1821:    OFF contents_beg = 0;
        1: 1822:    OFF contents_end = 0;
        1: 1823:    int line_index = 0;
        1: 1824:    int len = 0;
        -: 1825:
        1: 1826:    if(CH(off) != _T('['))
        -: 1827:        return FALSE;
        1: 1828:    off++;
        -: 1829:
        -: 1830:    while(1) {
        1: 1831:        OFF line_end = lines[line_index].end;
        -: 1832:
        2: 1833:        while(off < line_end) {
        2: 1834:            if(CH(off) == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
    #####: 1835:                if(contents_end == 0) {
    #####: 1836:                    contents_beg = off;
    #####: 1837:                    *p_beg_line_index = line_index;
        -: 1838:                }
    #####: 1839:                contents_end = off + 2;
    #####: 1840:                off += 2;
        2: 1841:            } else if(CH(off) == _T('[')) {
        -: 1842:                return FALSE;
        2: 1843:            } else if(CH(off) == _T(']')) {
        1: 1844:                if(contents_beg < contents_end) {
        -: 1845:                    /* Success. */
        1: 1846:                    *p_contents_beg = contents_beg;
        1: 1847:                    *p_contents_end = contents_end;
        1: 1848:                    *p_end = off+1;
        1: 1849:                    *p_end_line_index = line_index;
        -: 1850:                    return TRUE;
        -: 1851:                } else {
        -: 1852:                    /* Link label must have some non-whitespace contents. */
        -: 1853:                    return FALSE;
        -: 1854:                }
        -: 1855:            } else {
        -: 1856:                int codepoint;
        1: 1857:                SZ char_size;
        -: 1858:
        2: 1859:                codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size);
        1: 1860:                if(!ISUNICODEWHITESPACE_(codepoint)) {
        1: 1861:                    if(contents_end == 0) {
        1: 1862:                        contents_beg = off;
        1: 1863:                        *p_beg_line_index = line_index;
        -: 1864:                    }
        1: 1865:                    contents_end = off + char_size;
        -: 1866:                }
        -: 1867:
        1: 1868:                off += char_size;
        -: 1869:            }
        -: 1870:
        1: 1871:            len++;
        1: 1872:            if(len > 999)
        -: 1873:                return FALSE;
        -: 1874:        }
        -: 1875:
    #####: 1876:        line_index++;
    #####: 1877:        len++;
    #####: 1878:        if(line_index < n_lines)
    #####: 1879:            off = lines[line_index].beg;
        -: 1880:        else
        -: 1881:            break;
        -: 1882:    }
        -: 1883:
        -: 1884:    return FALSE;
        -: 1885:}
        -: 1886:
        -: 1887:static int
    #####: 1888:md_is_link_destination_A(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,
        -: 1889:                         OFF* p_contents_beg, OFF* p_contents_end)
        -: 1890:{
    #####: 1891:    OFF off = beg;
        -: 1892:
    #####: 1893:    if(off >= max_end  ||  CH(off) != _T('<'))
        -: 1894:        return FALSE;
    #####: 1895:    off++;
        -: 1896:
    #####: 1897:    while(off < max_end) {
    #####: 1898:        if(CH(off) == _T('\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {
    #####: 1899:            off += 2;
    #####: 1900:            continue;
        -: 1901:        }
        -: 1902:
    #####: 1903:        if(ISNEWLINE(off)  ||  CH(off) == _T('<'))
        -: 1904:            return FALSE;
        -: 1905:
    #####: 1906:        if(CH(off) == _T('>')) {
        -: 1907:            /* Success. */
    #####: 1908:            *p_contents_beg = beg+1;
    #####: 1909:            *p_contents_end = off;
    #####: 1910:            *p_end = off+1;
        -: 1911:            return TRUE;
        -: 1912:        }
        -: 1913:
    #####: 1914:        off++;
        -: 1915:    }
        -: 1916:
        -: 1917:    return FALSE;
        -: 1918:}
        -: 1919:
        -: 1920:static int
        1: 1921:md_is_link_destination_B(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,
        -: 1922:                         OFF* p_contents_beg, OFF* p_contents_end)
        -: 1923:{
        1: 1924:    OFF off = beg;
        1: 1925:    int parenthesis_level = 0;
        -: 1926:
        2: 1927:    while(off < max_end) {
        1: 1928:        if(CH(off) == _T('\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {
    #####: 1929:            off += 2;
    #####: 1930:            continue;
        -: 1931:        }
        -: 1932:
        1: 1933:        if(ISWHITESPACE(off) || ISCNTRL(off))
        -: 1934:            break;
        -: 1935:
        -: 1936:        /* Link destination may include balanced pairs of unescaped '(' ')'.
        -: 1937:         * Note we limit the maximal nesting level by 32 to protect us from
        -: 1938:         * https://github.com/jgm/cmark/issues/214 */
        1: 1939:        if(CH(off) == _T('(')) {
    #####: 1940:            parenthesis_level++;
    #####: 1941:            if(parenthesis_level > 32)
        -: 1942:                return FALSE;
        1: 1943:        } else if(CH(off) == _T(')')) {
    #####: 1944:            if(parenthesis_level == 0)
        -: 1945:                break;
    #####: 1946:            parenthesis_level--;
        -: 1947:        }
        -: 1948:
        1: 1949:        off++;
        -: 1950:    }
        -: 1951:
        1: 1952:    if(parenthesis_level != 0  ||  off == beg)
        -: 1953:        return FALSE;
        -: 1954:
        -: 1955:    /* Success. */
        1: 1956:    *p_contents_beg = beg;
        1: 1957:    *p_contents_end = off;
        1: 1958:    *p_end = off;
        -: 1959:    return TRUE;
        -: 1960:}
        -: 1961:
        -: 1962:static inline int
        1: 1963:md_is_link_destination(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,
        -: 1964:                       OFF* p_contents_beg, OFF* p_contents_end)
        -: 1965:{
        1: 1966:    if(CH(beg) == _T('<'))
    #####: 1967:        return md_is_link_destination_A(ctx, beg, max_end, p_end, p_contents_beg, p_contents_end);
        -: 1968:    else
        1: 1969:        return md_is_link_destination_B(ctx, beg, max_end, p_end, p_contents_beg, p_contents_end);
        -: 1970:}
        -: 1971:
        -: 1972:static int
        1: 1973:md_is_link_title(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,
        -: 1974:                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,
        -: 1975:                 OFF* p_contents_beg, OFF* p_contents_end)
        -: 1976:{
        1: 1977:    OFF off = beg;
        -: 1978:    CHAR closer_char;
        1: 1979:    int line_index = 0;
        -: 1980:
        -: 1981:    /* White space with up to one line break. */
        1: 1982:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 1983:        off++;
        1: 1984:    if(off >= lines[line_index].end) {
        1: 1985:        line_index++;
        1: 1986:        if(line_index >= n_lines)
        -: 1987:            return FALSE;
    #####: 1988:        off = lines[line_index].beg;
        -: 1989:    }
    #####: 1990:    if(off == beg)
        -: 1991:        return FALSE;
        -: 1992:
    #####: 1993:    *p_beg_line_index = line_index;
        -: 1994:
        -: 1995:    /* First char determines how to detect end of it. */
    #####: 1996:    switch(CH(off)) {
        -: 1997:        case _T('"'):   closer_char = _T('"'); break;
    #####: 1998:        case _T('\''):  closer_char = _T('\''); break;
    #####: 1999:        case _T('('):   closer_char = _T(')'); break;
        -: 2000:        default:        return FALSE;
        -: 2001:    }
    #####: 2002:    off++;
        -: 2003:
    #####: 2004:    *p_contents_beg = off;
        -: 2005:
    #####: 2006:    while(line_index < n_lines) {
    #####: 2007:        OFF line_end = lines[line_index].end;
        -: 2008:
    #####: 2009:        while(off < line_end) {
    #####: 2010:            if(CH(off) == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
        -: 2011:                off++;
    #####: 2012:            } else if(CH(off) == closer_char) {
        -: 2013:                /* Success. */
    #####: 2014:                *p_contents_end = off;
    #####: 2015:                *p_end = off+1;
    #####: 2016:                *p_end_line_index = line_index;
        -: 2017:                return TRUE;
    #####: 2018:            } else if(closer_char == _T(')')  &&  CH(off) == _T('(')) {
        -: 2019:                /* ()-style title cannot contain (unescaped '(')) */
        -: 2020:                return FALSE;
        -: 2021:            }
        -: 2022:
    #####: 2023:            off++;
        -: 2024:        }
        -: 2025:
    #####: 2026:        line_index++;
        -: 2027:    }
        -: 2028:
        -: 2029:    return FALSE;
        -: 2030:}
        -: 2031:
        -: 2032:/* Returns 0 if it is not a reference definition.
        -: 2033: *
        -: 2034: * Returns N > 0 if it is a reference definition. N then corresponds to the
        -: 2035: * number of lines forming it). In this case the definition is stored for
        -: 2036: * resolving any links referring to it.
        -: 2037: *
        -: 2038: * Returns -1 in case of an error (out of memory).
        -: 2039: */
        -: 2040:static int
        1: 2041:md_is_link_reference_definition(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 2042:{
        1: 2043:    OFF label_contents_beg;
        1: 2044:    OFF label_contents_end;
        1: 2045:    int label_contents_line_index = -1;
        -: 2046:    int label_is_multiline;
        1: 2047:    CHAR* label;
        1: 2048:    SZ label_size;
        1: 2049:    int label_needs_free = FALSE;
        1: 2050:    OFF dest_contents_beg;
        1: 2051:    OFF dest_contents_end;
        1: 2052:    OFF title_contents_beg;
        1: 2053:    OFF title_contents_end;
        1: 2054:    int title_contents_line_index;
        -: 2055:    int title_is_multiline;
        1: 2056:    OFF off;
        1: 2057:    int line_index = 0;
        1: 2058:    int tmp_line_index;
        -: 2059:    MD_REF_DEF* def;
        -: 2060:    int ret;
        -: 2061:
        -: 2062:    /* Link label. */
        1: 2063:    if(!md_is_link_label(ctx, lines, n_lines, lines[0].beg,
        -: 2064:                &off, &label_contents_line_index, &line_index,
        -: 2065:                &label_contents_beg, &label_contents_end))
        -: 2066:        return FALSE;
        1: 2067:    label_is_multiline = (label_contents_line_index != line_index);
        -: 2068:
        -: 2069:    /* Colon. */
        1: 2070:    if(off >= lines[line_index].end  ||  CH(off) != _T(':'))
        -: 2071:        return FALSE;
        1: 2072:    off++;
        -: 2073:
        -: 2074:    /* Optional white space with up to one line break. */
        2: 2075:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2076:        off++;
        1: 2077:    if(off >= lines[line_index].end) {
        1: 2078:        line_index++;
        1: 2079:        if(line_index >= n_lines)
        -: 2080:            return FALSE;
        1: 2081:        off = lines[line_index].beg;
        -: 2082:    }
        -: 2083:
        -: 2084:    /* Link destination. */
        1: 2085:    if(!md_is_link_destination(ctx, off, lines[line_index].end,
        -: 2086:                &off, &dest_contents_beg, &dest_contents_end))
        -: 2087:        return FALSE;
        -: 2088:
        -: 2089:    /* (Optional) title. Note we interpret it as an title only if nothing
        -: 2090:     * more follows on its last line. */
        1: 2091:    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,
        -: 2092:                &off, &title_contents_line_index, &tmp_line_index,
        -: 2093:                &title_contents_beg, &title_contents_end)
    #####: 2094:        &&  off >= lines[line_index + tmp_line_index].end)
        -: 2095:    {
    #####: 2096:        title_is_multiline = (tmp_line_index != title_contents_line_index);
    #####: 2097:        title_contents_line_index += line_index;
    #####: 2098:        line_index += tmp_line_index;
        -: 2099:    } else {
        -: 2100:        /* Not a title. */
        1: 2101:        title_is_multiline = FALSE;
        1: 2102:        title_contents_beg = off;
        1: 2103:        title_contents_end = off;
        1: 2104:        title_contents_line_index = 0;
        -: 2105:    }
        -: 2106:
        -: 2107:    /* Nothing more can follow on the last line. */
        1: 2108:    if(off < lines[line_index].end)
        -: 2109:        return FALSE;
        -: 2110:
        -: 2111:    /* Construct label. */
        1: 2112:    if(!label_is_multiline) {
        1: 2113:        label = (CHAR*) STR(label_contents_beg);
        1: 2114:        label_size = label_contents_end - label_contents_beg;
        1: 2115:        label_needs_free = FALSE;
        -: 2116:    } else {
    #####: 2117:        MD_CHECK(md_merge_lines_alloc(ctx, label_contents_beg, label_contents_end,
        -: 2118:                    lines + label_contents_line_index, n_lines - label_contents_line_index,
        -: 2119:                    _T(' '), &label, &label_size));
        -: 2120:        label_needs_free = TRUE;
        -: 2121:    }
        -: 2122:
        -: 2123:    /* Store the reference definition. */
        1: 2124:    if(ctx->n_ref_defs >= ctx->alloc_ref_defs) {
        -: 2125:        MD_REF_DEF* new_defs;
        -: 2126:
        1: 2127:        ctx->alloc_ref_defs = (ctx->alloc_ref_defs > 0 ? ctx->alloc_ref_defs * 2 : 16);
        1: 2128:        new_defs = (MD_REF_DEF*) realloc(ctx->ref_defs, ctx->alloc_ref_defs * sizeof(MD_REF_DEF));
        1: 2129:        if(new_defs == NULL) {
    #####: 2130:            MD_LOG("realloc() failed.");
        -: 2131:            ret = -1;
        -: 2132:            goto abort;
        -: 2133:        }
        -: 2134:
        1: 2135:        ctx->ref_defs = new_defs;
        -: 2136:    }
        -: 2137:
        1: 2138:    def = &ctx->ref_defs[ctx->n_ref_defs];
        1: 2139:    memset(def, 0, sizeof(MD_REF_DEF));
        -: 2140:
        1: 2141:    def->label = label;
        1: 2142:    def->label_size = label_size;
        1: 2143:    def->label_needs_free = label_needs_free;
        -: 2144:
        1: 2145:    def->dest_beg = dest_contents_beg;
        1: 2146:    def->dest_end = dest_contents_end;
        -: 2147:
        1: 2148:    if(title_contents_beg >= title_contents_end) {
        1: 2149:        def->title = NULL;
        1: 2150:        def->title_size = 0;
    #####: 2151:    } else if(!title_is_multiline) {
    #####: 2152:        def->title = (CHAR*) STR(title_contents_beg);
    #####: 2153:        def->title_size = title_contents_end - title_contents_beg;
        -: 2154:    } else {
    #####: 2155:        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,
        -: 2156:                    lines + title_contents_line_index, n_lines - title_contents_line_index,
        -: 2157:                    _T('\n'), &def->title, &def->title_size));
    #####: 2158:        def->title_needs_free = TRUE;
        -: 2159:    }
        -: 2160:
        -: 2161:    /* Success. */
        1: 2162:    ctx->n_ref_defs++;
        1: 2163:    return line_index + 1;
        -: 2164:
    #####: 2165:abort:
        -: 2166:    /* Failure. */
    #####: 2167:    if(label_needs_free)
    #####: 2168:        free(label);
        -: 2169:    return -1;
        -: 2170:}
        -: 2171:
        -: 2172:static int
    #####: 2173:md_is_link_reference(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2174:                     OFF beg, OFF end, MD_LINK_ATTR* attr)
        -: 2175:{
        -: 2176:    const MD_REF_DEF* def;
        -: 2177:    const MD_LINE* beg_line;
        -: 2178:    const MD_LINE* end_line;
    #####: 2179:    CHAR* label;
    #####: 2180:    SZ label_size;
        -: 2181:    int ret;
        -: 2182:
    #####: 2183:    MD_ASSERT(CH(beg) == _T('[') || CH(beg) == _T('!'));
    #####: 2184:    MD_ASSERT(CH(end-1) == _T(']'));
        -: 2185:
    #####: 2186:    beg += (CH(beg) == _T('!') ? 2 : 1);
    #####: 2187:    end--;
        -: 2188:
        -: 2189:    /* Find lines corresponding to the beg and end positions. */
    #####: 2190:    MD_ASSERT(lines[0].beg <= beg);
        -: 2191:    beg_line = lines;
    #####: 2192:    while(beg >= beg_line->end)
    #####: 2193:        beg_line++;
        -: 2194:
    #####: 2195:    MD_ASSERT(end <= lines[n_lines-1].end);
        -: 2196:    end_line = beg_line;
    #####: 2197:    while(end >= end_line->end)
    #####: 2198:        end_line++;
        -: 2199:
    #####: 2200:    if(beg_line != end_line) {
    #####: 2201:        MD_CHECK(md_merge_lines_alloc(ctx, beg, end, beg_line,
        -: 2202:                 n_lines - (beg_line - lines), _T(' '), &label, &label_size));
        -: 2203:    } else {
    #####: 2204:        label = (CHAR*) STR(beg);
    #####: 2205:        label_size = end - beg;
        -: 2206:    }
        -: 2207:
    #####: 2208:    def = md_lookup_ref_def(ctx, label, label_size);
    #####: 2209:    if(def != NULL) {
    #####: 2210:        attr->dest_beg = def->dest_beg;
    #####: 2211:        attr->dest_end = def->dest_end;
    #####: 2212:        attr->title = def->title;
    #####: 2213:        attr->title_size = def->title_size;
    #####: 2214:        attr->title_needs_free = FALSE;
        -: 2215:    }
        -: 2216:
    #####: 2217:    if(beg_line != end_line)
    #####: 2218:        free(label);
        -: 2219:
    #####: 2220:    ret = (def != NULL);
        -: 2221:
    #####: 2222:abort:
    #####: 2223:    return ret;
        -: 2224:}
        -: 2225:
        -: 2226:static int
    #####: 2227:md_is_inline_link_spec(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2228:                       OFF beg, OFF* p_end, MD_LINK_ATTR* attr)
        -: 2229:{
    #####: 2230:    int line_index = 0;
    #####: 2231:    int tmp_line_index;
    #####: 2232:    OFF title_contents_beg;
    #####: 2233:    OFF title_contents_end;
    #####: 2234:    int title_contents_line_index;
        -: 2235:    int title_is_multiline;
    #####: 2236:    OFF off = beg;
    #####: 2237:    int ret = FALSE;
        -: 2238:
    #####: 2239:    while(off >= lines[line_index].end)
    #####: 2240:        line_index++;
        -: 2241:
    #####: 2242:    MD_ASSERT(CH(off) == _T('('));
    #####: 2243:    off++;
        -: 2244:
        -: 2245:    /* Optional white space with up to one line break. */
    #####: 2246:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2247:        off++;
    #####: 2248:    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {
    #####: 2249:        line_index++;
    #####: 2250:        if(line_index >= n_lines)
        -: 2251:            return FALSE;
    #####: 2252:        off = lines[line_index].beg;
        -: 2253:    }
        -: 2254:
        -: 2255:    /* Link destination may be omitted, but only when not also having a title. */
    #####: 2256:    if(off < ctx->size  &&  CH(off) == _T(')')) {
    #####: 2257:        attr->dest_beg = off;
    #####: 2258:        attr->dest_end = off;
    #####: 2259:        attr->title = NULL;
    #####: 2260:        attr->title_size = 0;
    #####: 2261:        attr->title_needs_free = FALSE;
    #####: 2262:        off++;
    #####: 2263:        *p_end = off;
    #####: 2264:        return TRUE;
        -: 2265:    }
        -: 2266:
        -: 2267:    /* Link destination. */
    #####: 2268:    if(!md_is_link_destination(ctx, off, lines[line_index].end,
        -: 2269:                        &off, &attr->dest_beg, &attr->dest_end))
        -: 2270:        return FALSE;
        -: 2271:
        -: 2272:    /* (Optional) title. */
    #####: 2273:    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,
        -: 2274:                &off, &title_contents_line_index, &tmp_line_index,
        -: 2275:                &title_contents_beg, &title_contents_end))
        -: 2276:    {
    #####: 2277:        title_is_multiline = (tmp_line_index != title_contents_line_index);
    #####: 2278:        title_contents_line_index += line_index;
    #####: 2279:        line_index += tmp_line_index;
        -: 2280:    } else {
        -: 2281:        /* Not a title. */
    #####: 2282:        title_is_multiline = FALSE;
    #####: 2283:        title_contents_beg = off;
    #####: 2284:        title_contents_end = off;
    #####: 2285:        title_contents_line_index = 0;
        -: 2286:    }
        -: 2287:
        -: 2288:    /* Optional whitespace followed with final ')'. */
    #####: 2289:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2290:        off++;
    #####: 2291:    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {
    #####: 2292:        line_index++;
    #####: 2293:        if(line_index >= n_lines)
        -: 2294:            return FALSE;
    #####: 2295:        off = lines[line_index].beg;
        -: 2296:    }
    #####: 2297:    if(CH(off) != _T(')'))
        -: 2298:        goto abort;
    #####: 2299:    off++;
        -: 2300:
    #####: 2301:    if(title_contents_beg >= title_contents_end) {
    #####: 2302:        attr->title = NULL;
    #####: 2303:        attr->title_size = 0;
    #####: 2304:        attr->title_needs_free = FALSE;
    #####: 2305:    } else if(!title_is_multiline) {
    #####: 2306:        attr->title = (CHAR*) STR(title_contents_beg);
    #####: 2307:        attr->title_size = title_contents_end - title_contents_beg;
    #####: 2308:        attr->title_needs_free = FALSE;
        -: 2309:    } else {
    #####: 2310:        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,
        -: 2311:                    lines + title_contents_line_index, n_lines - title_contents_line_index,
        -: 2312:                    _T('\n'), &attr->title, &attr->title_size));
    #####: 2313:        attr->title_needs_free = TRUE;
        -: 2314:    }
        -: 2315:
    #####: 2316:    *p_end = off;
    #####: 2317:    ret = TRUE;
        -: 2318:
    #####: 2319:abort:
    #####: 2320:    return ret;
        -: 2321:}
        -: 2322:
        -: 2323:static void
    #####: 2324:md_free_ref_defs(MD_CTX* ctx)
        -: 2325:{
        -: 2326:    int i;
        -: 2327:
    #####: 2328:    for(i = 0; i < ctx->n_ref_defs; i++) {
    #####: 2329:        MD_REF_DEF* def = &ctx->ref_defs[i];
        -: 2330:
    #####: 2331:        if(def->label_needs_free)
    #####: 2332:            free(def->label);
    #####: 2333:        if(def->title_needs_free)
    #####: 2334:            free(def->title);
        -: 2335:    }
        -: 2336:
    #####: 2337:    free(ctx->ref_defs);
    #####: 2338:}
        -: 2339:
        -: 2340:
        -: 2341:/******************************************
        -: 2342: ***  Processing Inlines (a.k.a Spans)  ***
        -: 2343: ******************************************/
        -: 2344:
        -: 2345:/* We process inlines in few phases:
        -: 2346: *
        -: 2347: * (1) We go through the block text and collect all significant characters
        -: 2348: *     which may start/end a span or some other significant position into
        -: 2349: *     ctx->marks[]. Core of this is what md_collect_marks() does.
        -: 2350: *
        -: 2351: *     We also do some very brief preliminary context-less analysis, whether
        -: 2352: *     it might be opener or closer (e.g. of an emphasis span).
        -: 2353: *
        -: 2354: *     This speeds the other steps as we do not need to re-iterate over all
        -: 2355: *     characters anymore.
        -: 2356: *
        -: 2357: * (2) We analyze each potential mark types, in order by their precedence.
        -: 2358: *
        -: 2359: *     In each md_analyze_XXX() function, we re-iterate list of the marks,
        -: 2360: *     skipping already resolved regions (in preceding precedences) and try to
        -: 2361: *     resolve them.
        -: 2362: *
        -: 2363: * (2.1) For trivial marks, which are single (e.g. HTML entity), we just mark
        -: 2364: *       them as resolved.
        -: 2365: *
        -: 2366: * (2.2) For range-type marks, we analyze whether the mark could be closer
        -: 2367: *       and, if yes, whether there is some preceding opener it could satisfy.
        -: 2368: *
        -: 2369: *       If not we check whether it could be really an opener and if yes, we
        -: 2370: *       remember it so subsequent closers may resolve it.
        -: 2371: *
        -: 2372: * (3) Finally, when all marks were analyzed, we render the block contents
        -: 2373: *     by calling MD_RENDERER::text() callback, interrupting by ::enter_span()
        -: 2374: *     or ::close_span() whenever we reach a resolved mark.
        -: 2375: */
        -: 2376:
        -: 2377:
        -: 2378:/* The mark structure.
        -: 2379: *
        -: 2380: * '\\': Maybe escape sequence.
        -: 2381: * '\0': NULL char.
        -: 2382: *  '*': Maybe (strong) emphasis start/end.
        -: 2383: *  '_': Maybe (strong) emphasis start/end.
        -: 2384: *  '~': Maybe strikethrough start/end (needs MD_FLAG_STRIKETHROUGH).
        -: 2385: *  '`': Maybe code span start/end.
        -: 2386: *  '&': Maybe start of entity.
        -: 2387: *  ';': Maybe end of entity.
        -: 2388: *  '<': Maybe start of raw HTML or autolink.
        -: 2389: *  '>': Maybe end of raw HTML or autolink.
        -: 2390: *  '[': Maybe start of link label or link text.
        -: 2391: *  '!': Equivalent of '[' for image.
        -: 2392: *  ']': Maybe end of link label or link text.
        -: 2393: *  '@': Maybe permissive e-mail auto-link (needs MD_FLAG_PERMISSIVEEMAILAUTOLINKS).
        -: 2394: *  ':': Maybe permissive URL auto-link (needs MD_FLAG_PERMISSIVEURLAUTOLINKS).
        -: 2395: *  '.': Maybe permissive WWW auto-link (needs MD_FLAG_PERMISSIVEWWWAUTOLINKS).
        -: 2396: *  'D': Dummy mark, it reserves a space for splitting a previous mark
        -: 2397: *       (e.g. emphasis) or to make more space for storing some special data
        -: 2398: *       related to the preceding mark (e.g. link).
        -: 2399: *
        -: 2400: * Note that not all instances of these chars in the text imply creation of the
        -: 2401: * structure. Only those which have (or may have, after we see more context)
        -: 2402: * the special meaning.
        -: 2403: *
        -: 2404: * (Keep this struct as small as possible to fit as much of them into CPU
        -: 2405: * cache line.)
        -: 2406: */
        -: 2407:struct MD_MARK_tag {
        -: 2408:    OFF beg;
        -: 2409:    OFF end;
        -: 2410:
        -: 2411:    /* For unresolved openers, 'prev' and 'next' form the chain of open openers
        -: 2412:     * of given type 'ch'.
        -: 2413:     *
        -: 2414:     * During resolving, we disconnect from the chain and point to the
        -: 2415:     * corresponding counterpart so opener points to its closer and vice versa.
        -: 2416:     */
        -: 2417:    int prev;
        -: 2418:    int next;
        -: 2419:    CHAR ch;
        -: 2420:    unsigned char flags;
        -: 2421:};
        -: 2422:
        -: 2423:/* Mark flags (these apply to ALL mark types). */
        -: 2424:#define MD_MARK_POTENTIAL_OPENER            0x01  /* Maybe opener. */
        -: 2425:#define MD_MARK_POTENTIAL_CLOSER            0x02  /* Maybe closer. */
        -: 2426:#define MD_MARK_OPENER                      0x04  /* Definitely opener. */
        -: 2427:#define MD_MARK_CLOSER                      0x08  /* Definitely closer. */
        -: 2428:#define MD_MARK_RESOLVED                    0x10  /* Resolved in any definite way. */
        -: 2429:
        -: 2430:/* Mark flags specific for various mark types (so they can share bits). */
        -: 2431:#define MD_MARK_EMPH_INTRAWORD              0x20  /* Helper for the "rule of 3". */
        -: 2432:#define MD_MARK_EMPH_MOD3_0                 0x40
        -: 2433:#define MD_MARK_EMPH_MOD3_1                 0x80
        -: 2434:#define MD_MARK_EMPH_MOD3_2                 (0x40 | 0x80)
        -: 2435:#define MD_MARK_EMPH_MOD3_MASK              (0x40 | 0x80)
        -: 2436:#define MD_MARK_AUTOLINK                    0x20  /* Distinguisher for '<', '>'. */
        -: 2437:#define MD_MARK_VALIDPERMISSIVEAUTOLINK     0x20  /* For permissive autolinks. */
        -: 2438:
        -: 2439:static MD_MARKCHAIN*
        -: 2440:md_asterisk_chain(MD_CTX* ctx, unsigned flags)
        -: 2441:{
    #####: 2442:    switch(flags & (MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_MASK)) {
    #####: 2443:        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_0:  return &ASTERISK_OPENERS_intraword_mod3_0;
    #####: 2444:        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_1:  return &ASTERISK_OPENERS_intraword_mod3_1;
    #####: 2445:        case MD_MARK_EMPH_INTRAWORD | MD_MARK_EMPH_MOD3_2:  return &ASTERISK_OPENERS_intraword_mod3_2;
    #####: 2446:        case MD_MARK_EMPH_MOD3_0:                           return &ASTERISK_OPENERS_extraword_mod3_0;
    #####: 2447:        case MD_MARK_EMPH_MOD3_1:                           return &ASTERISK_OPENERS_extraword_mod3_1;
    #####: 2448:        case MD_MARK_EMPH_MOD3_2:                           return &ASTERISK_OPENERS_extraword_mod3_2;
    #####: 2449:        default:                                            MD_UNREACHABLE();
        -: 2450:    }
        -: 2451:    return NULL;
        -: 2452:}
        -: 2453:
        -: 2454:static MD_MARKCHAIN*
    #####: 2455:md_mark_chain(MD_CTX* ctx, int mark_index)
        -: 2456:{
    #####: 2457:    MD_MARK* mark = &ctx->marks[mark_index];
        -: 2458:
    #####: 2459:    switch(mark->ch) {
    #####: 2460:        case _T('*'):   return md_asterisk_chain(ctx, mark->flags);
    #####: 2461:        case _T('_'):   return &UNDERSCORE_OPENERS;
    #####: 2462:        case _T('~'):   return &TILDE_OPENERS;
    #####: 2463:        case _T('['):   return &BRACKET_OPENERS;
    #####: 2464:        case _T('|'):   return &TABLECELLBOUNDARIES;
        -: 2465:        default:        return NULL;
        -: 2466:    }
        -: 2467:}
        -: 2468:
        -: 2469:static MD_MARK*
    #####: 2470:md_push_mark(MD_CTX* ctx)
        -: 2471:{
    #####: 2472:    if(ctx->n_marks >= ctx->alloc_marks) {
        -: 2473:        MD_MARK* new_marks;
        -: 2474:
    #####: 2475:        ctx->alloc_marks = (ctx->alloc_marks > 0 ? ctx->alloc_marks * 2 : 64);
    #####: 2476:        new_marks = realloc(ctx->marks, ctx->alloc_marks * sizeof(MD_MARK));
    #####: 2477:        if(new_marks == NULL) {
    #####: 2478:            MD_LOG("realloc() failed.");
        -: 2479:            return NULL;
        -: 2480:        }
        -: 2481:
    #####: 2482:        ctx->marks = new_marks;
        -: 2483:    }
        -: 2484:
    #####: 2485:    return &ctx->marks[ctx->n_marks++];
        -: 2486:}
        -: 2487:
        -: 2488:#define PUSH_MARK_()                                                    \
        -: 2489:        do {                                                            \
        -: 2490:            mark = md_push_mark(ctx);                                   \
        -: 2491:            if(mark == NULL) {                                          \
        -: 2492:                ret = -1;                                               \
        -: 2493:                goto abort;                                             \
        -: 2494:            }                                                           \
        -: 2495:        } while(0)
        -: 2496:
        -: 2497:#define PUSH_MARK(ch_, beg_, end_, flags_)                              \
        -: 2498:        do {                                                            \
        -: 2499:            PUSH_MARK_();                                               \
        -: 2500:            mark->beg = (beg_);                                         \
        -: 2501:            mark->end = (end_);                                         \
        -: 2502:            mark->prev = -1;                                            \
        -: 2503:            mark->next = -1;                                            \
        -: 2504:            mark->ch = (char)(ch_);                                     \
        -: 2505:            mark->flags = (flags_);                                     \
        -: 2506:        } while(0)
        -: 2507:
        -: 2508:
        -: 2509:static void
        -: 2510:md_mark_chain_append(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index)
        -: 2511:{
    #####: 2512:    if(chain->tail >= 0)
    #####: 2513:        ctx->marks[chain->tail].next = mark_index;
        -: 2514:    else
    #####: 2515:        chain->head = mark_index;
        -: 2516:
    #####: 2517:    ctx->marks[mark_index].prev = chain->tail;
    #####: 2518:    chain->tail = mark_index;
        -: 2519:}
        -: 2520:
        -: 2521:/* Sometimes, we need to store a pointer into the mark. It is quite rare
        -: 2522: * so we do not bother to make MD_MARK use union, and it can only happen
        -: 2523: * for dummy marks. */
        -: 2524:static inline void
        -: 2525:md_mark_store_ptr(MD_CTX* ctx, int mark_index, void* ptr)
        -: 2526:{
    #####: 2527:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2528:    MD_ASSERT(mark->ch == 'D');
        -: 2529:
        -: 2530:    /* Check only members beg and end are misused for this. */
        -: 2531:    MD_ASSERT(sizeof(void*) <= 2 * sizeof(OFF));
    #####: 2532:    memcpy(mark, &ptr, sizeof(void*));
        -: 2533:}
        -: 2534:
        -: 2535:static inline void*
        -: 2536:md_mark_get_ptr(MD_CTX* ctx, int mark_index)
        -: 2537:{
    #####: 2538:    void* ptr;
    #####: 2539:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2540:    MD_ASSERT(mark->ch == 'D');
    #####: 2541:    memcpy(&ptr, mark, sizeof(void*));
        -: 2542:    return ptr;
        -: 2543:}
        -: 2544:
        -: 2545:static void
    #####: 2546:md_resolve_range(MD_CTX* ctx, MD_MARKCHAIN* chain, int opener_index, int closer_index)
        -: 2547:{
    #####: 2548:    MD_MARK* opener = &ctx->marks[opener_index];
    #####: 2549:    MD_MARK* closer = &ctx->marks[closer_index];
        -: 2550:
        -: 2551:    /* Remove opener from the list of openers. */
    #####: 2552:    if(chain != NULL) {
    #####: 2553:        if(opener->prev >= 0)
    #####: 2554:            ctx->marks[opener->prev].next = opener->next;
        -: 2555:        else
    #####: 2556:            chain->head = opener->next;
        -: 2557:
    #####: 2558:        if(opener->next >= 0)
    #####: 2559:            ctx->marks[opener->next].prev = opener->prev;
        -: 2560:        else
    #####: 2561:            chain->tail = opener->prev;
        -: 2562:    }
        -: 2563:
        -: 2564:    /* Interconnect opener and closer and mark both as resolved. */
    #####: 2565:    opener->next = closer_index;
    #####: 2566:    opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;
    #####: 2567:    closer->prev = opener_index;
    #####: 2568:    closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;
    #####: 2569:}
        -: 2570:
        -: 2571:
        -: 2572:#define MD_ROLLBACK_ALL         0
        -: 2573:#define MD_ROLLBACK_CROSSING    1
        -: 2574:
        -: 2575:/* In the range ctx->marks[opener_index] ... [closer_index], undo some or all
        -: 2576: * resolvings accordingly to these rules:
        -: 2577: *
        -: 2578: * (1) All openers BEFORE the range corresponding to any closer inside the
        -: 2579: *     range are un-resolved and they are re-added to their respective chains
        -: 2580: *     of unresolved openers. This ensures we can reuse the opener for closers
        -: 2581: *     AFTER the range.
        -: 2582: *
        -: 2583: * (2) If 'how' is MD_ROLLBACK_ALL, then ALL resolved marks inside the range
        -: 2584: *     are discarded.
        -: 2585: *
        -: 2586: * (3) If 'how' is MD_ROLLBACK_CROSSING, only closers with openers handled
        -: 2587: *     in (1) are discarded. I.e. pairs of openers and closers which are both
        -: 2588: *     inside the range are retained as well as any unpaired marks.
        -: 2589: */
        -: 2590:static void
    #####: 2591:md_rollback(MD_CTX* ctx, int opener_index, int closer_index, int how)
        -: 2592:{
        -: 2593:    int i;
        -: 2594:    int mark_index;
        -: 2595:
        -: 2596:    /* Cut all unresolved openers at the mark index. */
    #####: 2597:    for(i = OPENERS_CHAIN_FIRST; i < OPENERS_CHAIN_LAST+1; i++) {
        -: 2598:        MD_MARKCHAIN* chain = &ctx->mark_chains[i];
        -: 2599:
    #####: 2600:        while(chain->tail >= opener_index)
    #####: 2601:            chain->tail = ctx->marks[chain->tail].prev;
        -: 2602:
    #####: 2603:        if(chain->tail >= 0)
    #####: 2604:            ctx->marks[chain->tail].next = -1;
        -: 2605:        else
    #####: 2606:            chain->head = -1;
        -: 2607:    }
        -: 2608:
        -: 2609:    /* Go backwards so that un-resolved openers are re-added into their
        -: 2610:     * respective chains, in the right order. */
    #####: 2611:    mark_index = closer_index - 1;
    #####: 2612:    while(mark_index > opener_index) {
    #####: 2613:        MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2614:        int mark_flags = mark->flags;
    #####: 2615:        int discard_flag = (how == MD_ROLLBACK_ALL);
        -: 2616:
    #####: 2617:        if(mark->flags & MD_MARK_CLOSER) {
    #####: 2618:            int mark_opener_index = mark->prev;
        -: 2619:
        -: 2620:            /* Undo opener BEFORE the range. */
    #####: 2621:            if(mark_opener_index < opener_index) {
    #####: 2622:                MD_MARK* mark_opener = &ctx->marks[mark_opener_index];
        -: 2623:                MD_MARKCHAIN* chain;
        -: 2624:
    #####: 2625:                mark_opener->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);
    #####: 2626:                chain = md_mark_chain(ctx, opener_index);
    #####: 2627:                if(chain != NULL) {
    #####: 2628:                    md_mark_chain_append(ctx, chain, mark_opener_index);
    #####: 2629:                    discard_flag = 1;
        -: 2630:                }
        -: 2631:            }
        -: 2632:        }
        -: 2633:
        -: 2634:        /* And reset our flags. */
    #####: 2635:        if(discard_flag)
    #####: 2636:            mark->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);
        -: 2637:
        -: 2638:        /* Jump as far as we can over unresolved or non-interesting marks. */
    #####: 2639:        switch(how) {
    #####: 2640:            case MD_ROLLBACK_CROSSING:
    #####: 2641:                if((mark_flags & MD_MARK_CLOSER)  &&  mark->prev > opener_index) {
        -: 2642:                    /* If we are closer with opener INSIDE the range, there may
        -: 2643:                     * not be any other crosser inside the subrange. */
        -: 2644:                    mark_index = mark->prev;
        -: 2645:                    break;
        -: 2646:                }
        -: 2647:                /* Pass through. */
        -: 2648:            default:
    #####: 2649:                mark_index--;
    #####: 2650:                break;
        -: 2651:        }
        -: 2652:    }
    #####: 2653:}
        -: 2654:
        -: 2655:static void
        1: 2656:md_build_mark_char_map(MD_CTX* ctx)
        -: 2657:{
        2: 2658:    memset(ctx->mark_char_map, 0, sizeof(ctx->mark_char_map));
        -: 2659:
        1: 2660:    ctx->mark_char_map['\\'] = 1;
        1: 2661:    ctx->mark_char_map['*'] = 1;
        1: 2662:    ctx->mark_char_map['_'] = 1;
        1: 2663:    ctx->mark_char_map['`'] = 1;
        1: 2664:    ctx->mark_char_map['&'] = 1;
        1: 2665:    ctx->mark_char_map[';'] = 1;
        1: 2666:    ctx->mark_char_map['<'] = 1;
        1: 2667:    ctx->mark_char_map['>'] = 1;
        1: 2668:    ctx->mark_char_map['['] = 1;
        1: 2669:    ctx->mark_char_map['!'] = 1;
        1: 2670:    ctx->mark_char_map[']'] = 1;
        1: 2671:    ctx->mark_char_map['\0'] = 1;
        -: 2672:
        1: 2673:    if(ctx->parser.flags & MD_FLAG_STRIKETHROUGH)
    #####: 2674:        ctx->mark_char_map['~'] = 1;
        -: 2675:
        1: 2676:    if(ctx->parser.flags & MD_FLAG_PERMISSIVEEMAILAUTOLINKS)
    #####: 2677:        ctx->mark_char_map['@'] = 1;
        -: 2678:
        1: 2679:    if(ctx->parser.flags & MD_FLAG_PERMISSIVEURLAUTOLINKS)
    #####: 2680:        ctx->mark_char_map[':'] = 1;
        -: 2681:
        1: 2682:    if(ctx->parser.flags & MD_FLAG_PERMISSIVEWWWAUTOLINKS)
    #####: 2683:        ctx->mark_char_map['.'] = 1;
        -: 2684:
        1: 2685:    if(ctx->parser.flags & MD_FLAG_TABLES)
    #####: 2686:        ctx->mark_char_map['|'] = 1;
        -: 2687:
        1: 2688:    if(ctx->parser.flags & MD_FLAG_COLLAPSEWHITESPACE) {
        -: 2689:        int i;
        -: 2690:
    #####: 2691:        for(i = 0; i < sizeof(ctx->mark_char_map); i++) {
    #####: 2692:            if(ISWHITESPACE_(i))
    #####: 2693:                ctx->mark_char_map[i] = 1;
        -: 2694:        }
        -: 2695:    }
        1: 2696:}
        -: 2697:
        -: 2698:/* We limit code span marks to lower then 32 backticks. This solves the
        -: 2699: * pathologic case of too many openers, each of different length: Their
        -: 2700: * resolving would be then O(n^2). */
        -: 2701:#define CODESPAN_MARK_MAXLEN    32
        -: 2702:
        -: 2703:static int
    #####: 2704:md_is_code_span(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,
        -: 2705:                OFF* p_opener_beg, OFF* p_opener_end,
        -: 2706:                OFF* p_closer_beg, OFF* p_closer_end,
        -: 2707:                OFF last_potential_closers[CODESPAN_MARK_MAXLEN],
        -: 2708:                int* p_reached_paragraph_end)
        -: 2709:{
    #####: 2710:    OFF opener_beg = beg;
        -: 2711:    OFF opener_end;
        -: 2712:    OFF closer_beg;
        -: 2713:    OFF closer_end;
        -: 2714:    SZ mark_len;
        -: 2715:    OFF line_end;
    #####: 2716:    int has_space_after_opener = FALSE;
    #####: 2717:    int has_eol_after_opener = FALSE;
    #####: 2718:    int has_space_before_closer = FALSE;
    #####: 2719:    int has_eol_before_closer = FALSE;
    #####: 2720:    int has_only_space = TRUE;
    #####: 2721:    int line_index = 0;
        -: 2722:
    #####: 2723:    line_end = lines[0].end;
    #####: 2724:    opener_end = opener_beg;
    #####: 2725:    while(opener_end < line_end  &&  CH(opener_end) == _T('`'))
    #####: 2726:        opener_end++;
    #####: 2727:    has_space_after_opener = (opener_end < line_end && CH(opener_end) == _T(' '));
    #####: 2728:    has_eol_after_opener = (opener_end == line_end);
        -: 2729:
        -: 2730:    /* The caller needs to know end of the opening mark even if we fail. */
    #####: 2731:    *p_opener_end = opener_end;
        -: 2732:
    #####: 2733:    mark_len = opener_end - opener_beg;
    #####: 2734:    if(mark_len > CODESPAN_MARK_MAXLEN)
        -: 2735:        return FALSE;
        -: 2736:
        -: 2737:    /* Check whether we already know there is no closer of this length.
        -: 2738:     * If so, re-scan does no sense. This fixes issue #59. */
    #####: 2739:    if(last_potential_closers[mark_len-1] >= lines[n_lines-1].end  ||
    #####: 2740:       (*p_reached_paragraph_end  &&  last_potential_closers[mark_len-1] < opener_end))
        -: 2741:        return FALSE;
        -: 2742:
        -: 2743:    closer_beg = opener_end;
        -: 2744:    closer_end = opener_end;
        -: 2745:
        -: 2746:    /* Find closer mark. */
        -: 2747:    while(TRUE) {
    #####: 2748:        while(closer_beg < line_end  &&  CH(closer_beg) != _T('`')) {
    #####: 2749:            if(CH(closer_beg) != _T(' '))
    #####: 2750:                has_only_space = FALSE;
    #####: 2751:            closer_beg++;
        -: 2752:        }
        -: 2753:        closer_end = closer_beg;
    #####: 2754:        while(closer_end < line_end  &&  CH(closer_end) == _T('`'))
    #####: 2755:            closer_end++;
        -: 2756:
    #####: 2757:        if(closer_end - closer_beg == mark_len) {
        -: 2758:            /* Success. */
    #####: 2759:            has_space_before_closer = (closer_beg > lines[line_index].beg && CH(closer_beg-1) == _T(' '));
    #####: 2760:            has_eol_before_closer = (closer_beg == lines[line_index].beg);
        -: 2761:            break;
        -: 2762:        }
        -: 2763:
    #####: 2764:        if(closer_end - closer_beg > 0) {
        -: 2765:            /* We have found a back-tick which is not part of the closer. */
    #####: 2766:            has_only_space = FALSE;
        -: 2767:
        -: 2768:            /* But if we eventually fail, remember it as a potential closer
        -: 2769:             * of its own length for future attempts. This mitigates needs for
        -: 2770:             * rescans. */
    #####: 2771:            if(closer_end - closer_beg < CODESPAN_MARK_MAXLEN) {
    #####: 2772:                if(closer_beg > last_potential_closers[closer_end - closer_beg - 1])
    #####: 2773:                    last_potential_closers[closer_end - closer_beg - 1] = closer_beg;
        -: 2774:            }
        -: 2775:        }
        -: 2776:
    #####: 2777:        if(closer_end >= line_end) {
    #####: 2778:            line_index++;
    #####: 2779:            if(line_index >= n_lines) {
        -: 2780:                /* Reached end of the paragraph and still nothing. */
    #####: 2781:                *p_reached_paragraph_end = TRUE;
        -: 2782:                return FALSE;
        -: 2783:            }
        -: 2784:            /* Try on the next line. */
    #####: 2785:            line_end = lines[line_index].end;
    #####: 2786:            closer_beg = lines[line_index].beg;
        -: 2787:        } else {
        -: 2788:            closer_beg = closer_end;
        -: 2789:        }
        -: 2790:    }
        -: 2791:
        -: 2792:    /* If there is a space or a new line both after and before the opener
        -: 2793:     * (and if the code span is not made of spaces only), consume one initial
        -: 2794:     * and one trailing space as part of the marks. */
    #####: 2795:    if(!has_only_space  &&
    #####: 2796:       (has_space_after_opener || has_eol_after_opener)  &&
    #####: 2797:       (has_space_before_closer || has_eol_before_closer))
        -: 2798:    {
    #####: 2799:        if(has_space_after_opener)
    #####: 2800:            opener_end++;
        -: 2801:        else
    #####: 2802:            opener_end = lines[1].beg;
        -: 2803:
    #####: 2804:        if(has_space_before_closer)
    #####: 2805:            closer_beg--;
        -: 2806:        else {
    #####: 2807:            closer_beg = lines[line_index-1].end;
        -: 2808:            /* We need to eat the preceding "\r\n" but not any line trailing
        -: 2809:             * spaces. */
    #####: 2810:            while(closer_beg < ctx->size  &&  ISBLANK(closer_beg))
    #####: 2811:                closer_beg++;
        -: 2812:        }
        -: 2813:    }
        -: 2814:
    #####: 2815:    *p_opener_beg = opener_beg;
    #####: 2816:    *p_opener_end = opener_end;
    #####: 2817:    *p_closer_beg = closer_beg;
    #####: 2818:    *p_closer_end = closer_end;
        -: 2819:    return TRUE;
        -: 2820:}
        -: 2821:
        -: 2822:static int
    #####: 2823:md_is_autolink_uri(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)
        -: 2824:{
    #####: 2825:    OFF off = beg+1;
        -: 2826:
    #####: 2827:    MD_ASSERT(CH(beg) == _T('<'));
        -: 2828:
        -: 2829:    /* Check for scheme. */
    #####: 2830:    if(off >= max_end  ||  !ISASCII(off))
        -: 2831:        return FALSE;
    #####: 2832:    off++;
        -: 2833:    while(1) {
    #####: 2834:        if(off >= max_end)
        -: 2835:            return FALSE;
    #####: 2836:        if(off - beg > 32)
        -: 2837:            return FALSE;
    #####: 2838:        if(CH(off) == _T(':')  &&  off - beg >= 3)
        -: 2839:            break;
    #####: 2840:        if(!ISALNUM(off) && CH(off) != _T('+') && CH(off) != _T('-') && CH(off) != _T('.'))
        -: 2841:            return FALSE;
    #####: 2842:        off++;
        -: 2843:    }
        -: 2844:
        -: 2845:    /* Check the path after the scheme. */
    #####: 2846:    while(off < max_end  &&  CH(off) != _T('>')) {
    #####: 2847:        if(ISWHITESPACE(off) || ISCNTRL(off) || CH(off) == _T('<'))
        -: 2848:            return FALSE;
    #####: 2849:        off++;
        -: 2850:    }
        -: 2851:
    #####: 2852:    if(off >= max_end)
        -: 2853:        return FALSE;
        -: 2854:
    #####: 2855:    MD_ASSERT(CH(off) == _T('>'));
    #####: 2856:    *p_end = off+1;
        -: 2857:    return TRUE;
        -: 2858:}
        -: 2859:
        -: 2860:static int
    #####: 2861:md_is_autolink_email(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)
        -: 2862:{
    #####: 2863:    OFF off = beg + 1;
        -: 2864:    int label_len;
        -: 2865:
    #####: 2866:    MD_ASSERT(CH(beg) == _T('<'));
        -: 2867:
        -: 2868:    /* The code should correspond to this regexp:
        -: 2869:            /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+
        -: 2870:            @[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?
        -: 2871:            (?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
        -: 2872:     */
        -: 2873:
        -: 2874:    /* Username (before '@'). */
    #####: 2875:    while(off < max_end  &&  (ISALNUM(off) || ISANYOF(off, _T(".!#$%&'*+/=?^_`{|}~-"))))
    #####: 2876:        off++;
    #####: 2877:    if(off <= beg+1)
        -: 2878:        return FALSE;
        -: 2879:
        -: 2880:    /* '@' */
    #####: 2881:    if(off >= max_end  ||  CH(off) != _T('@'))
        -: 2882:        return FALSE;
    #####: 2883:    off++;
        -: 2884:
        -: 2885:    /* Labels delimited with '.'; each label is sequence of 1 - 62 alnum
        -: 2886:     * characters or '-', but '-' is not allowed as first or last char. */
    #####: 2887:    label_len = 0;
    #####: 2888:    while(off < max_end) {
    #####: 2889:        if(ISALNUM(off))
    #####: 2890:            label_len++;
    #####: 2891:        else if(CH(off) == _T('-')  &&  label_len > 0)
    #####: 2892:            label_len++;
    #####: 2893:        else if(CH(off) == _T('.')  &&  label_len > 0  &&  CH(off-1) != _T('-'))
        -: 2894:            label_len = 0;
        -: 2895:        else
        -: 2896:            break;
        -: 2897:
    #####: 2898:        if(label_len > 62)
        -: 2899:            return FALSE;
        -: 2900:
    #####: 2901:        off++;
        -: 2902:    }
        -: 2903:
    #####: 2904:    if(label_len <= 0  || off >= max_end  ||  CH(off) != _T('>') ||  CH(off-1) == _T('-'))
        -: 2905:        return FALSE;
        -: 2906:
    #####: 2907:    *p_end = off+1;
        -: 2908:    return TRUE;
        -: 2909:}
        -: 2910:
        -: 2911:static int
    #####: 2912:md_is_autolink(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end, int* p_missing_mailto)
        -: 2913:{
    #####: 2914:    if(md_is_autolink_uri(ctx, beg, max_end, p_end)) {
    #####: 2915:        *p_missing_mailto = FALSE;
    #####: 2916:        return TRUE;
        -: 2917:    }
        -: 2918:
    #####: 2919:    if(md_is_autolink_email(ctx, beg, max_end, p_end)) {
    #####: 2920:        *p_missing_mailto = TRUE;
    #####: 2921:        return TRUE;
        -: 2922:    }
        -: 2923:
        -: 2924:    return FALSE;
        -: 2925:}
        -: 2926:
        -: 2927:static int
    #####: 2928:md_collect_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)
        -: 2929:{
        -: 2930:    int i;
    #####: 2931:    int ret = 0;
        -: 2932:    MD_MARK* mark;
    #####: 2933:    OFF codespan_last_potential_closers[CODESPAN_MARK_MAXLEN] = { 0 };
    #####: 2934:    int codespan_scanned_till_paragraph_end = FALSE;
        -: 2935:
    #####: 2936:    for(i = 0; i < n_lines; i++) {
    #####: 2937:        const MD_LINE* line = &lines[i];
    #####: 2938:        OFF off = line->beg;
    #####: 2939:        OFF line_end = line->end;
        -: 2940:
        -: 2941:        while(TRUE) {
        -: 2942:            CHAR ch;
        -: 2943:
        -: 2944:#ifdef MD4C_USE_UTF16
        -: 2945:    /* For UTF-16, mark_char_map[] covers only ASCII. */
        -: 2946:    #define IS_MARK_CHAR(off)   ((CH(off) < SIZEOF_ARRAY(ctx->mark_char_map))  &&  \
        -: 2947:                                (ctx->mark_char_map[(unsigned char) CH(off)]))
        -: 2948:#else
        -: 2949:    /* For 8-bit encodings, mark_char_map[] covers all 256 elements. */
        -: 2950:    #define IS_MARK_CHAR(off)   (ctx->mark_char_map[(unsigned char) CH(off)])
        -: 2951:#endif
        -: 2952:
        -: 2953:            /* Optimization: Fast path (with some loop unrolling). */
    #####: 2954:            while(off + 4 < line_end  &&  !IS_MARK_CHAR(off+0)  &&  !IS_MARK_CHAR(off+1)
    #####: 2955:                                      &&  !IS_MARK_CHAR(off+2)  &&  !IS_MARK_CHAR(off+3))
        -: 2956:                off += 4;
    #####: 2957:            while(off < line_end  &&  !IS_MARK_CHAR(off+0))
    #####: 2958:                off++;
        -: 2959:
    #####: 2960:            if(off >= line_end)
        -: 2961:                break;
        -: 2962:
    #####: 2963:            ch = CH(off);
        -: 2964:
        -: 2965:            /* A backslash escape.
        -: 2966:             * It can go beyond line->end as it may involve escaped new
        -: 2967:             * line to form a hard break. */
    #####: 2968:            if(ch == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
        -: 2969:                /* Hard-break cannot be on the last line of the block. */
    #####: 2970:                if(!ISNEWLINE(off+1)  ||  i+1 < n_lines)
    #####: 2971:                    PUSH_MARK(ch, off, off+2, MD_MARK_RESOLVED);
    #####: 2972:                off += 2;
    #####: 2973:                continue;
        -: 2974:            }
        -: 2975:
        -: 2976:            /* A potential (string) emphasis start/end. */
    #####: 2977:            if(ch == _T('*')  ||  ch == _T('_')) {
    #####: 2978:                OFF tmp = off+1;
        -: 2979:                int left_level;     /* What precedes: 0 = whitespace; 1 = punctuation; 2 = other char. */
        -: 2980:                int right_level;    /* What follows: 0 = whitespace; 1 = punctuation; 2 = other char. */
        -: 2981:
    #####: 2982:                while(tmp < line_end  &&  CH(tmp) == ch)
    #####: 2983:                    tmp++;
        -: 2984:
    #####: 2985:                if(off == line->beg  ||  ISUNICODEWHITESPACEBEFORE(off))
        -: 2986:                    left_level = 0;
    #####: 2987:                else if(ISUNICODEPUNCTBEFORE(off))
        -: 2988:                    left_level = 1;
        -: 2989:                else
    #####: 2990:                    left_level = 2;
        -: 2991:
    #####: 2992:                if(tmp == line_end  ||  ISUNICODEWHITESPACE(tmp))
        -: 2993:                    right_level = 0;
    #####: 2994:                else if(ISUNICODEPUNCT(tmp))
        -: 2995:                    right_level = 1;
        -: 2996:                else
    #####: 2997:                    right_level = 2;
        -: 2998:
        -: 2999:                /* Intra-word underscore doesn't have special meaning. */
    #####: 3000:                if(ch == _T('_')  &&  left_level == 2  &&  right_level == 2) {
    #####: 3001:                    left_level = 0;
    #####: 3002:                    right_level = 0;
        -: 3003:                }
        -: 3004:
    #####: 3005:                if(left_level != 0  ||  right_level != 0) {
    #####: 3006:                    unsigned flags = 0;
        -: 3007:
    #####: 3008:                    if(left_level > 0  &&  left_level >= right_level)
    #####: 3009:                        flags |= MD_MARK_POTENTIAL_CLOSER;
    #####: 3010:                    if(right_level > 0  &&  right_level >= left_level)
    #####: 3011:                        flags |= MD_MARK_POTENTIAL_OPENER;
    #####: 3012:                    if(left_level == 2  &&  right_level == 2)
    #####: 3013:                        flags |= MD_MARK_EMPH_INTRAWORD;
        -: 3014:
        -: 3015:                    /* For "the rule of three" we need to remember the original
        -: 3016:                     * size of the mark (modulo three), before we potentially
        -: 3017:                     * split the mark when being later resolved partially by some
        -: 3018:                     * shorter closer. */
    #####: 3019:                    switch((tmp - off) % 3) {
    #####: 3020:                        case 0: flags |= MD_MARK_EMPH_MOD3_0; break;
    #####: 3021:                        case 1: flags |= MD_MARK_EMPH_MOD3_1; break;
    #####: 3022:                        case 2: flags |= MD_MARK_EMPH_MOD3_2; break;
        -: 3023:                    }
        -: 3024:
    #####: 3025:                    PUSH_MARK(ch, off, tmp, flags);
        -: 3026:
        -: 3027:                    /* During resolving, multiple asterisks may have to be
        -: 3028:                     * split into independent span start/ends. Consider e.g.
        -: 3029:                     * "**foo* bar*". Therefore we push also some empty dummy
        -: 3030:                     * marks to have enough space for that. */
    #####: 3031:                    off++;
    #####: 3032:                    while(off < tmp) {
    #####: 3033:                        PUSH_MARK('D', off, off, 0);
    #####: 3034:                        off++;
        -: 3035:                    }
    #####: 3036:                    continue;
        -: 3037:                }
        -: 3038:
    #####: 3039:                off = tmp;
    #####: 3040:                continue;
        -: 3041:            }
        -: 3042:
        -: 3043:            /* A potential code span start/end. */
    #####: 3044:            if(ch == _T('`')) {
    #####: 3045:                OFF opener_beg, opener_end;
    #####: 3046:                OFF closer_beg, closer_end;
        -: 3047:                int is_code_span;
        -: 3048:
    #####: 3049:                is_code_span = md_is_code_span(ctx, lines + i, n_lines - i, off,
        -: 3050:                                    &opener_beg, &opener_end, &closer_beg, &closer_end,
        -: 3051:                                    codespan_last_potential_closers,
        -: 3052:                                    &codespan_scanned_till_paragraph_end);
    #####: 3053:                if(is_code_span) {
    #####: 3054:                    PUSH_MARK(_T('`'), opener_beg, opener_end, MD_MARK_OPENER | MD_MARK_RESOLVED);
    #####: 3055:                    PUSH_MARK(_T('`'), closer_beg, closer_end, MD_MARK_CLOSER | MD_MARK_RESOLVED);
    #####: 3056:                    ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;
    #####: 3057:                    ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;
        -: 3058:
    #####: 3059:                    off = closer_end;
        -: 3060:
        -: 3061:                    /* Advance the current line accordingly. */
    #####: 3062:                    while(off > line_end) {
    #####: 3063:                        i++;
    #####: 3064:                        line++;
    #####: 3065:                        line_end = line->end;
        -: 3066:                    }
    #####: 3067:                    continue;
        -: 3068:                }
        -: 3069:
    #####: 3070:                off = opener_end;
    #####: 3071:                continue;
        -: 3072:            }
        -: 3073:
        -: 3074:            /* A potential entity start. */
    #####: 3075:            if(ch == _T('&')) {
    #####: 3076:                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);
    #####: 3077:                off++;
    #####: 3078:                continue;
        -: 3079:            }
        -: 3080:
        -: 3081:            /* A potential entity end. */
    #####: 3082:            if(ch == _T(';')) {
        -: 3083:                /* We surely cannot be entity unless the previous mark is '&'. */
    #####: 3084:                if(ctx->n_marks > 0  &&  ctx->marks[ctx->n_marks-1].ch == _T('&'))
    #####: 3085:                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);
        -: 3086:
    #####: 3087:                off++;
    #####: 3088:                continue;
        -: 3089:            }
        -: 3090:
        -: 3091:            /* A potential autolink or raw HTML start/end. */
    #####: 3092:            if(ch == _T('<')) {
        -: 3093:                int is_autolink;
    #####: 3094:                OFF autolink_end;
    #####: 3095:                int missing_mailto;
        -: 3096:
    #####: 3097:                if(!(ctx->parser.flags & MD_FLAG_NOHTMLSPANS)) {
        -: 3098:                    int is_html;
    #####: 3099:                    OFF html_end;
        -: 3100:
        -: 3101:                    /* Given the nature of the raw HTML, we have to recognize
        -: 3102:                     * it here. Doing so later in md_analyze_lt_gt() could
        -: 3103:                     * open can of worms of quadratic complexity. */
    #####: 3104:                    is_html = md_is_html_any(ctx, lines + i, n_lines - i, off,
    #####: 3105:                                    lines[n_lines-1].end, &html_end);
    #####: 3106:                    if(is_html) {
    #####: 3107:                        PUSH_MARK(_T('<'), off, off, MD_MARK_OPENER | MD_MARK_RESOLVED);
    #####: 3108:                        PUSH_MARK(_T('>'), html_end, html_end, MD_MARK_CLOSER | MD_MARK_RESOLVED);
    #####: 3109:                        ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;
    #####: 3110:                        ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;
    #####: 3111:                        off = html_end;
        -: 3112:
        -: 3113:                        /* Advance the current line accordingly. */
    #####: 3114:                        while(off > line_end) {
    #####: 3115:                            i++;
    #####: 3116:                            line++;
    #####: 3117:                            line_end = line->end;
        -: 3118:                        }
    #####: 3119:                        continue;
        -: 3120:                    }
        -: 3121:                }
        -: 3122:
    #####: 3123:                is_autolink = md_is_autolink(ctx, off, lines[n_lines-1].end,
        -: 3124:                                    &autolink_end, &missing_mailto);
    #####: 3125:                if(is_autolink) {
    #####: 3126:                    PUSH_MARK((missing_mailto ? _T('@') : _T('<')), off, off+1,
        -: 3127:                                MD_MARK_OPENER | MD_MARK_RESOLVED | MD_MARK_AUTOLINK);
    #####: 3128:                    PUSH_MARK(_T('>'), autolink_end-1, autolink_end,
        -: 3129:                                MD_MARK_CLOSER | MD_MARK_RESOLVED | MD_MARK_AUTOLINK);
    #####: 3130:                    ctx->marks[ctx->n_marks-2].next = ctx->n_marks-1;
    #####: 3131:                    ctx->marks[ctx->n_marks-1].prev = ctx->n_marks-2;
    #####: 3132:                    off = autolink_end;
    #####: 3133:                    continue;
        -: 3134:                }
        -: 3135:
    #####: 3136:                off++;
    #####: 3137:                continue;
        -: 3138:            }
        -: 3139:
        -: 3140:            /* A potential link or its part. */
    #####: 3141:            if(ch == _T('[')  ||  (ch == _T('!') && off+1 < line_end && CH(off+1) == _T('['))) {
    #####: 3142:                OFF tmp = (ch == _T('[') ? off+1 : off+2);
    #####: 3143:                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER);
    #####: 3144:                off = tmp;
        -: 3145:                /* Two dummies to make enough place for data we need if it is
        -: 3146:                 * a link. */
    #####: 3147:                PUSH_MARK('D', off, off, 0);
    #####: 3148:                PUSH_MARK('D', off, off, 0);
    #####: 3149:                continue;
        -: 3150:            }
    #####: 3151:            if(ch == _T(']')) {
    #####: 3152:                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);
    #####: 3153:                off++;
    #####: 3154:                continue;
        -: 3155:            }
        -: 3156:
        -: 3157:            /* A potential permissive e-mail autolink. */
    #####: 3158:            if(ch == _T('@')) {
    #####: 3159:                if(line->beg + 1 <= off  &&  ISALNUM(off-1)  &&
    #####: 3160:                    off + 3 < line->end  &&  ISALNUM(off+1))
        -: 3161:                {
    #####: 3162:                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);
        -: 3163:                    /* Push a dummy as a reserve for a closer. */
    #####: 3164:                    PUSH_MARK('D', off, off, 0);
        -: 3165:                }
        -: 3166:
    #####: 3167:                off++;
    #####: 3168:                continue;
        -: 3169:            }
        -: 3170:
        -: 3171:            /* A potential permissive URL autolink. */
    #####: 3172:            if(ch == _T(':')) {
        -: 3173:                static struct {
        -: 3174:                    const CHAR* scheme;
        -: 3175:                    SZ scheme_size;
        -: 3176:                    const CHAR* suffix;
        -: 3177:                    SZ suffix_size;
        -: 3178:                } scheme_map[] = {
        -: 3179:                    /* In the order from the most frequently used, arguably. */
        -: 3180:                    { _T("http"), 4,    _T("//"), 2 },
        -: 3181:                    { _T("https"), 5,   _T("//"), 2 },
        -: 3182:                    { _T("ftp"), 3,     _T("//"), 2 }
        -: 3183:                };
        -: 3184:                int scheme_index;
        -: 3185:
    #####: 3186:                for(scheme_index = 0; scheme_index < SIZEOF_ARRAY(scheme_map); scheme_index++) {
    #####: 3187:                    const CHAR* scheme = scheme_map[scheme_index].scheme;
    #####: 3188:                    const SZ scheme_size = scheme_map[scheme_index].scheme_size;
    #####: 3189:                    const CHAR* suffix = scheme_map[scheme_index].suffix;
    #####: 3190:                    const SZ suffix_size = scheme_map[scheme_index].suffix_size;
        -: 3191:
    #####: 3192:                    if(line->beg + scheme_size <= off  &&  md_ascii_eq(STR(off-scheme_size), scheme, scheme_size)  &&
    #####: 3193:                        (line->beg + scheme_size == off || ISWHITESPACE(off-scheme_size-1) || ISANYOF(off-scheme_size-1, _T("*_~([")))  &&
    #####: 3194:                        off + 1 + suffix_size < line->end  &&  md_ascii_eq(STR(off+1), suffix, suffix_size))
        -: 3195:                    {
    #####: 3196:                        PUSH_MARK(ch, off-scheme_size, off+1+suffix_size, MD_MARK_POTENTIAL_OPENER);
        -: 3197:                        /* Push a dummy as a reserve for a closer. */
    #####: 3198:                        PUSH_MARK('D', off, off, 0);
    #####: 3199:                        off += 1 + suffix_size;
    #####: 3200:                        continue;
        -: 3201:                    }
        -: 3202:                }
        -: 3203:
    #####: 3204:                off++;
    #####: 3205:                continue;
        -: 3206:            }
        -: 3207:
        -: 3208:            /* A potential permissive WWW autolink. */
    #####: 3209:            if(ch == _T('.')) {
    #####: 3210:                if(line->beg + 3 <= off  &&  md_ascii_eq(STR(off-3), _T("www"), 3)  &&
    #####: 3211:                    (line->beg + 3 == off || ISWHITESPACE(off-4) || ISANYOF(off-4, _T("*_~([")))  &&
    #####: 3212:                    off + 1 < line_end)
        -: 3213:                {
    #####: 3214:                    PUSH_MARK(ch, off-3, off+1, MD_MARK_POTENTIAL_OPENER);
        -: 3215:                    /* Push a dummy as a reserve for a closer. */
    #####: 3216:                    PUSH_MARK('D', off, off, 0);
    #####: 3217:                    off++;
    #####: 3218:                    continue;
        -: 3219:                }
        -: 3220:
    #####: 3221:                off++;
    #####: 3222:                continue;
        -: 3223:            }
        -: 3224:
        -: 3225:            /* A potential table cell boundary. */
    #####: 3226:            if(table_mode  &&  ch == _T('|')) {
    #####: 3227:                PUSH_MARK(ch, off, off+1, 0);
    #####: 3228:                off++;
    #####: 3229:                continue;
        -: 3230:            }
        -: 3231:
        -: 3232:            /* A potential strikethrough start/end. */
    #####: 3233:            if(ch == _T('~')) {
    #####: 3234:                OFF tmp = off+1;
        -: 3235:
    #####: 3236:                while(tmp < line_end  &&  CH(tmp) == _T('~'))
    #####: 3237:                    tmp++;
        -: 3238:
    #####: 3239:                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);
    #####: 3240:                off = tmp;
    #####: 3241:                continue;
        -: 3242:            }
        -: 3243:
        -: 3244:            /* Turn non-trivial whitespace into single space. */
    #####: 3245:            if(ISWHITESPACE_(ch)) {
    #####: 3246:                OFF tmp = off+1;
        -: 3247:
    #####: 3248:                while(tmp < line_end  &&  ISWHITESPACE(tmp))
    #####: 3249:                    tmp++;
        -: 3250:
    #####: 3251:                if(tmp - off > 1  ||  ch != _T(' '))
    #####: 3252:                    PUSH_MARK(ch, off, tmp, MD_MARK_RESOLVED);
        -: 3253:
    #####: 3254:                off = tmp;
    #####: 3255:                continue;
        -: 3256:            }
        -: 3257:
        -: 3258:            /* NULL character. */
    #####: 3259:            if(ch == _T('\0')) {
    #####: 3260:                PUSH_MARK(ch, off, off+1, MD_MARK_RESOLVED);
    #####: 3261:                off++;
    #####: 3262:                continue;
        -: 3263:            }
        -: 3264:
    #####: 3265:            off++;
        -: 3266:        }
        -: 3267:    }
        -: 3268:
        -: 3269:    /* Add a dummy mark at the end of the mark vector to simplify
        -: 3270:     * process_inlines(). */
    #####: 3271:    PUSH_MARK(127, ctx->size, ctx->size, MD_MARK_RESOLVED);
        -: 3272:
    #####: 3273:abort:
    #####: 3274:    return ret;
        -: 3275:}
        -: 3276:
        -: 3277:static void
    #####: 3278:md_analyze_bracket(MD_CTX* ctx, int mark_index)
        -: 3279:{
        -: 3280:    /* We cannot really resolve links here as for that we would need
        -: 3281:     * more context. E.g. a following pair of brackets (reference link),
        -: 3282:     * or enclosing pair of brackets (if the inner is the link, the outer
        -: 3283:     * one cannot be.)
        -: 3284:     *
        -: 3285:     * Therefore we here only construct a list of resolved '[' ']' pairs
        -: 3286:     * ordered by position of the closer. This allows ur to analyze what is
        -: 3287:     * or is not link in the right order, from inside to outside in case
        -: 3288:     * of nested brackets.
        -: 3289:     *
        -: 3290:     * The resolving itself is deferred into md_resolve_links().
        -: 3291:     */
        -: 3292:
    #####: 3293:    MD_MARK* mark = &ctx->marks[mark_index];
        -: 3294:
    #####: 3295:    if(mark->flags & MD_MARK_POTENTIAL_OPENER) {
    #####: 3296:        md_mark_chain_append(ctx, &BRACKET_OPENERS, mark_index);
        -: 3297:        return;
        -: 3298:    }
        -: 3299:
    #####: 3300:    if(BRACKET_OPENERS.tail >= 0) {
        -: 3301:        /* Pop the opener from the chain. */
    #####: 3302:        int opener_index = BRACKET_OPENERS.tail;
    #####: 3303:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3304:        if(opener->prev >= 0)
    #####: 3305:            ctx->marks[opener->prev].next = -1;
        -: 3306:        else
    #####: 3307:            BRACKET_OPENERS.head = -1;
    #####: 3308:        BRACKET_OPENERS.tail = opener->prev;
        -: 3309:
        -: 3310:        /* Interconnect the opener and closer. */
    #####: 3311:        opener->next = mark_index;
    #####: 3312:        mark->prev = opener_index;
        -: 3313:
        -: 3314:        /* Add the pair into chain of potential links for md_resolve_links().
        -: 3315:         * Note we misuse opener->prev for this as opener->next points to its
        -: 3316:         * closer. */
    #####: 3317:        if(ctx->unresolved_link_tail >= 0)
    #####: 3318:            ctx->marks[ctx->unresolved_link_tail].prev = opener_index;
        -: 3319:        else
    #####: 3320:            ctx->unresolved_link_head = opener_index;
    #####: 3321:        ctx->unresolved_link_tail = opener_index;
    #####: 3322:        opener->prev = -1;
        -: 3323:    }
        -: 3324:}
        -: 3325:
        -: 3326:/* Forward declaration. */
        -: 3327:static void md_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3328:                                     int mark_beg, int mark_end);
        -: 3329:
        -: 3330:static int
    #####: 3331:md_resolve_links(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 3332:{
    #####: 3333:    int opener_index = ctx->unresolved_link_head;
    #####: 3334:    OFF last_link_beg = 0;
    #####: 3335:    OFF last_link_end = 0;
    #####: 3336:    OFF last_img_beg = 0;
    #####: 3337:    OFF last_img_end = 0;
        -: 3338:
    #####: 3339:    while(opener_index >= 0) {
    #####: 3340:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3341:        int closer_index = opener->next;
    #####: 3342:        MD_MARK* closer = &ctx->marks[closer_index];
    #####: 3343:        int next_index = opener->prev;
        -: 3344:        MD_MARK* next_opener;
        -: 3345:        MD_MARK* next_closer;
    #####: 3346:        MD_LINK_ATTR attr;
    #####: 3347:        int is_link = FALSE;
        -: 3348:
    #####: 3349:        if(next_index >= 0) {
    #####: 3350:            next_opener = &ctx->marks[next_index];
    #####: 3351:            next_closer = &ctx->marks[next_opener->next];
        -: 3352:        } else {
        -: 3353:            next_opener = NULL;
        -: 3354:            next_closer = NULL;
        -: 3355:        }
        -: 3356:
        -: 3357:        /* If nested ("[ [ ] ]"), we need to make sure that:
        -: 3358:         *   - The outer does not end inside of (...) belonging to the inner.
        -: 3359:         *   - The outer cannot be link if the inner is link (i.e. not image).
        -: 3360:         *
        -: 3361:         * (Note we here analyze from inner to outer as the marks are ordered
        -: 3362:         * by closer->beg.)
        -: 3363:         */
    #####: 3364:        if((opener->beg < last_link_beg  &&  closer->end < last_link_end)  ||
    #####: 3365:           (opener->beg < last_img_beg  &&  closer->end < last_img_end)  ||
    #####: 3366:           (opener->beg < last_link_end  &&  opener->ch == '['))
        -: 3367:        {
    #####: 3368:            opener_index = next_index;
    #####: 3369:            continue;
        -: 3370:        }
        -: 3371:
    #####: 3372:        if(next_opener != NULL  &&  next_opener->beg == closer->end) {
    #####: 3373:            if(next_closer->beg > closer->end + 1) {
        -: 3374:                /* Might be full reference link. */
    #####: 3375:                is_link = md_is_link_reference(ctx, lines, n_lines, next_opener->beg, next_closer->end, &attr);
        -: 3376:            } else {
        -: 3377:                /* Might be shortcut reference link. */
    #####: 3378:                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);
        -: 3379:            }
        -: 3380:
    #####: 3381:            if(is_link < 0)
    #####: 3382:                return -1;
        -: 3383:
    #####: 3384:            if(is_link) {
        -: 3385:                /* Eat the 2nd "[...]". */
    #####: 3386:                closer->end = next_closer->end;
        -: 3387:            }
        -: 3388:        } else {
    #####: 3389:            if(closer->end < ctx->size  &&  CH(closer->end) == _T('(')) {
        -: 3390:                /* Might be inline link. */
    #####: 3391:                OFF inline_link_end = UINT_MAX;
        -: 3392:
    #####: 3393:                is_link = md_is_inline_link_spec(ctx, lines, n_lines, closer->end, &inline_link_end, &attr);
    #####: 3394:                if(is_link < 0)
    #####: 3395:                    return -1;
        -: 3396:
        -: 3397:                /* Check the closing ')' is not inside an already resolved range
        -: 3398:                 * (i.e. a range with a higher priority), e.g. a code span. */
    #####: 3399:                if(is_link) {
    #####: 3400:                    int i = closer_index + 1;
        -: 3401:
    #####: 3402:                    while(i < ctx->n_marks) {
    #####: 3403:                        MD_MARK* mark = &ctx->marks[i];
        -: 3404:
    #####: 3405:                        if(mark->beg >= inline_link_end)
        -: 3406:                            break;
    #####: 3407:                        if((mark->flags & (MD_MARK_OPENER | MD_MARK_RESOLVED)) == (MD_MARK_OPENER | MD_MARK_RESOLVED)) {
    #####: 3408:                            if(ctx->marks[mark->next].beg >= inline_link_end) {
        -: 3409:                                /* Cancel the link status. */
    #####: 3410:                                if(attr.title_needs_free)
    #####: 3411:                                    free(attr.title);
        -: 3412:                                is_link = FALSE;
        -: 3413:                                break;
        -: 3414:                            }
        -: 3415:
    #####: 3416:                            i = mark->next + 1;
        -: 3417:                        } else {
    #####: 3418:                            i++;
        -: 3419:                        }
        -: 3420:                    }
        -: 3421:                }
        -: 3422:
    #####: 3423:                if(is_link) {
        -: 3424:                    /* Eat the "(...)" */
    #####: 3425:                    closer->end = inline_link_end;
        -: 3426:                }
        -: 3427:            }
        -: 3428:
    #####: 3429:            if(!is_link) {
        -: 3430:                /* Might be collapsed reference link. */
    #####: 3431:                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);
    #####: 3432:                if(is_link < 0)
        -: 3433:                    return -1;
        -: 3434:            }
        -: 3435:        }
        -: 3436:
    #####: 3437:        if(is_link) {
        -: 3438:            /* Resolve the brackets as a link. */
    #####: 3439:            opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;
    #####: 3440:            closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;
        -: 3441:
        -: 3442:            /* If it is a link, we store the destination and title in the two
        -: 3443:             * dummy marks after the opener. */
    #####: 3444:            MD_ASSERT(ctx->marks[opener_index+1].ch == 'D');
    #####: 3445:            ctx->marks[opener_index+1].beg = attr.dest_beg;
    #####: 3446:            ctx->marks[opener_index+1].end = attr.dest_end;
        -: 3447:
    #####: 3448:            MD_ASSERT(ctx->marks[opener_index+2].ch == 'D');
    #####: 3449:            md_mark_store_ptr(ctx, opener_index+2, attr.title);
    #####: 3450:            if(attr.title_needs_free)
    #####: 3451:                md_mark_chain_append(ctx, &PTR_CHAIN, opener_index+2);
    #####: 3452:            ctx->marks[opener_index+2].prev = attr.title_size;
        -: 3453:
    #####: 3454:            if(opener->ch == '[') {
    #####: 3455:                last_link_beg = opener->beg;
    #####: 3456:                last_link_end = closer->end;
        -: 3457:            } else {
    #####: 3458:                last_img_beg = opener->beg;
    #####: 3459:                last_img_end = closer->end;
        -: 3460:            }
        -: 3461:
    #####: 3462:            md_analyze_link_contents(ctx, lines, n_lines, opener_index+1, closer_index);
        -: 3463:        }
        -: 3464:
    #####: 3465:        opener_index = next_index;
        -: 3466:    }
        -: 3467:
        -: 3468:    return 0;
        -: 3469:}
        -: 3470:
        -: 3471:/* Analyze whether the mark '&' starts a HTML entity.
        -: 3472: * If so, update its flags as well as flags of corresponding closer ';'. */
        -: 3473:static void
    #####: 3474:md_analyze_entity(MD_CTX* ctx, int mark_index)
        -: 3475:{
    #####: 3476:    MD_MARK* opener = &ctx->marks[mark_index];
        -: 3477:    MD_MARK* closer;
    #####: 3478:    OFF off;
        -: 3479:
        -: 3480:    /* Cannot be entity if there is no closer as the next mark.
        -: 3481:     * (Any other mark between would mean strange character which cannot be
        -: 3482:     * part of the entity.
        -: 3483:     *
        -: 3484:     * So we can do all the work on '&' and do not call this later for the
        -: 3485:     * closing mark ';'.
        -: 3486:     */
    #####: 3487:    if(mark_index + 1 >= ctx->n_marks)
    #####: 3488:        return;
    #####: 3489:    closer = &ctx->marks[mark_index+1];
    #####: 3490:    if(closer->ch != ';')
        -: 3491:        return;
        -: 3492:
    #####: 3493:    if(md_is_entity(ctx, opener->beg, closer->end, &off)) {
    #####: 3494:        MD_ASSERT(off == closer->end);
        -: 3495:
    #####: 3496:        md_resolve_range(ctx, NULL, mark_index, mark_index+1);
    #####: 3497:        opener->end = closer->end;
        -: 3498:    }
        -: 3499:}
        -: 3500:
        -: 3501:static void
        -: 3502:md_analyze_table_cell_boundary(MD_CTX* ctx, int mark_index)
        -: 3503:{
    #####: 3504:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 3505:    mark->flags |= MD_MARK_RESOLVED;
        -: 3506:
    #####: 3507:    md_mark_chain_append(ctx, &TABLECELLBOUNDARIES, mark_index);
    #####: 3508:    ctx->n_table_cell_boundaries++;
        -: 3509:}
        -: 3510:
        -: 3511:/* Split a longer mark into two. The new mark takes the given count of
        -: 3512: * characters. May only be called if an adequate number of dummy 'D' marks
        -: 3513: * follows.
        -: 3514: */
        -: 3515:static int
    #####: 3516:md_split_emph_mark(MD_CTX* ctx, int mark_index, SZ n)
        -: 3517:{
    #####: 3518:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 3519:    int new_mark_index = mark_index + (mark->end - mark->beg - n);
    #####: 3520:    MD_MARK* dummy = &ctx->marks[new_mark_index];
        -: 3521:
    #####: 3522:    MD_ASSERT(mark->end - mark->beg > n);
    #####: 3523:    MD_ASSERT(dummy->ch == 'D');
        -: 3524:
    #####: 3525:    memcpy(dummy, mark, sizeof(MD_MARK));
    #####: 3526:    mark->end -= n;
    #####: 3527:    dummy->beg = mark->end;
        -: 3528:
    #####: 3529:    return new_mark_index;
        -: 3530:}
        -: 3531:
        -: 3532:static void
    #####: 3533:md_analyze_emph(MD_CTX* ctx, int mark_index)
        -: 3534:{
    #####: 3535:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 3536:    MD_MARKCHAIN* chain = md_mark_chain(ctx, mark_index);
        -: 3537:
        -: 3538:    /* If we can be a closer, try to resolve with the preceding opener. */
    #####: 3539:    if(mark->flags & MD_MARK_POTENTIAL_CLOSER) {
    #####: 3540:        MD_MARK* opener = NULL;
        -: 3541:        int opener_index;
        -: 3542:
    #####: 3543:        if(mark->ch == _T('*')) {
    #####: 3544:            MD_MARKCHAIN* opener_chains[6];
        -: 3545:            int i, n_opener_chains;
    #####: 3546:            unsigned flags = mark->flags;
        -: 3547:
        -: 3548:            /* Apply "rule of three". (This is why we break asterisk opener
        -: 3549:             * marks into multiple chains.) */
    #####: 3550:            n_opener_chains = 0;
    #####: 3551:            opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_0;
    #####: 3552:            if((flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_2)
    #####: 3553:                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_1;
    #####: 3554:            if((flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_1)
    #####: 3555:                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_intraword_mod3_2;
    #####: 3556:            opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_0;
    #####: 3557:            if(!(flags & MD_MARK_EMPH_INTRAWORD)  ||  (flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_2)
    #####: 3558:                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_1;
    #####: 3559:            if(!(flags & MD_MARK_EMPH_INTRAWORD)  ||  (flags & MD_MARK_EMPH_MOD3_MASK) != MD_MARK_EMPH_MOD3_1)
    #####: 3560:                opener_chains[n_opener_chains++] = &ASTERISK_OPENERS_extraword_mod3_2;
        -: 3561:
        -: 3562:            /* Opener is the most recent mark from the allowed chains. */
    #####: 3563:            for(i = 0; i < n_opener_chains; i++) {
    #####: 3564:                if(opener_chains[i]->tail >= 0) {
    #####: 3565:                    int tmp_index = opener_chains[i]->tail;
    #####: 3566:                    MD_MARK* tmp_mark = &ctx->marks[tmp_index];
    #####: 3567:                    if(opener == NULL  ||  tmp_mark->end > opener->end) {
    #####: 3568:                        opener_index = tmp_index;
    #####: 3569:                        opener = tmp_mark;
        -: 3570:                    }
        -: 3571:                }
        -: 3572:            }
        -: 3573:        } else {
        -: 3574:            /* Simple emph. mark */
    #####: 3575:            if(chain->tail >= 0) {
    #####: 3576:                opener_index = chain->tail;
    #####: 3577:                opener = &ctx->marks[opener_index];
        -: 3578:            }
        -: 3579:        }
        -: 3580:
        -: 3581:        /* Resolve, if we have found matching opener. */
    #####: 3582:        if(opener != NULL) {
    #####: 3583:            SZ opener_size = opener->end - opener->beg;
    #####: 3584:            SZ closer_size = mark->end - mark->beg;
        -: 3585:
    #####: 3586:            if(opener_size > closer_size) {
    #####: 3587:                opener_index = md_split_emph_mark(ctx, opener_index, closer_size);
    #####: 3588:                md_mark_chain_append(ctx, md_mark_chain(ctx, opener_index), opener_index);
    #####: 3589:            } else if(opener_size < closer_size) {
    #####: 3590:                md_split_emph_mark(ctx, mark_index, closer_size - opener_size);
        -: 3591:            }
        -: 3592:
    #####: 3593:            md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);
    #####: 3594:            md_resolve_range(ctx, chain, opener_index, mark_index);
    #####: 3595:            return;
        -: 3596:        }
        -: 3597:    }
        -: 3598:
        -: 3599:    /* If we could not resolve as closer, we may be yet be an opener. */
    #####: 3600:    if(mark->flags & MD_MARK_POTENTIAL_OPENER)
    #####: 3601:        md_mark_chain_append(ctx, chain, mark_index);
        -: 3602:}
        -: 3603:
        -: 3604:static void
    #####: 3605:md_analyze_tilde(MD_CTX* ctx, int mark_index)
        -: 3606:{
        -: 3607:    /* We attempt to be Github Flavored Markdown compatible here. GFM says
        -: 3608:     * that length of the tilde sequence is not important at all. Note that
        -: 3609:     * implies the TILDE_OPENERS chain can have at most one item. */
        -: 3610:
    #####: 3611:    if(TILDE_OPENERS.head >= 0) {
        -: 3612:        /* The chain already contains an opener, so we may resolve the span. */
    #####: 3613:        int opener_index = TILDE_OPENERS.head;
        -: 3614:
    #####: 3615:        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);
    #####: 3616:        md_resolve_range(ctx, &TILDE_OPENERS, opener_index, mark_index);
        -: 3617:    } else {
        -: 3618:        /* We can only be opener. */
    #####: 3619:        md_mark_chain_append(ctx, &TILDE_OPENERS, mark_index);
        -: 3620:    }
    #####: 3621:}
        -: 3622:
        -: 3623:static void
    #####: 3624:md_analyze_permissive_url_autolink(MD_CTX* ctx, int mark_index)
        -: 3625:{
    #####: 3626:    MD_MARK* opener = &ctx->marks[mark_index];
    #####: 3627:    int closer_index = mark_index + 1;
    #####: 3628:    MD_MARK* closer = &ctx->marks[closer_index];
        -: 3629:    MD_MARK* next_resolved_mark;
    #####: 3630:    OFF off = opener->end;
    #####: 3631:    int seen_dot = FALSE;
    #####: 3632:    int seen_underscore_or_hyphen[2] = { FALSE, FALSE };
        -: 3633:
        -: 3634:    /* Check for domain. */
    #####: 3635:    while(off < ctx->size) {
    #####: 3636:        if(ISALNUM(off)) {
    #####: 3637:            off++;
    #####: 3638:        } else if(CH(off) == _T('.')) {
    #####: 3639:            seen_dot = TRUE;
    #####: 3640:            seen_underscore_or_hyphen[0] = seen_underscore_or_hyphen[1];
    #####: 3641:            seen_underscore_or_hyphen[1] = FALSE;
    #####: 3642:            off++;
    #####: 3643:        } else if(ISANYOF2(off, _T('-'), _T('_'))) {
    #####: 3644:            seen_underscore_or_hyphen[1] = TRUE;
    #####: 3645:            off++;
        -: 3646:        } else {
        -: 3647:            break;
        -: 3648:        }
        -: 3649:    }
        -: 3650:
    #####: 3651:    if(off <= opener->end || !seen_dot || seen_underscore_or_hyphen[0] || seen_underscore_or_hyphen[1])
        -: 3652:        return;
        -: 3653:
        -: 3654:    /* Check for path. */
    #####: 3655:    next_resolved_mark = closer + 1;
    #####: 3656:    while(next_resolved_mark->ch == 'D' || !(next_resolved_mark->flags & MD_MARK_RESOLVED))
    #####: 3657:        next_resolved_mark++;
    #####: 3658:    while(off < next_resolved_mark->beg  &&  CH(off) != _T('<')  &&  !ISWHITESPACE(off)  &&  !ISNEWLINE(off))
    #####: 3659:        off++;
        -: 3660:
        -: 3661:    /* Path validation. */
    #####: 3662:    if(ISANYOF(off-1, _T("?!.,:*_~)"))) {
    #####: 3663:        if(CH(off-1) != _T(')')) {
        -: 3664:            off--;
        -: 3665:        } else {
        -: 3666:            int parenthesis_balance = 0;
        -: 3667:            OFF tmp;
        -: 3668:
    #####: 3669:            for(tmp = opener->end; tmp < off; tmp++) {
    #####: 3670:                if(CH(tmp) == _T('('))
    #####: 3671:                    parenthesis_balance++;
    #####: 3672:                else if(CH(tmp) == _T(')'))
    #####: 3673:                    parenthesis_balance--;
        -: 3674:            }
        -: 3675:
    #####: 3676:            if(parenthesis_balance < 0)
    #####: 3677:                off--;
        -: 3678:        }
        -: 3679:    }
        -: 3680:
        -: 3681:    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero
        -: 3682:     * length so all the contents becomes the link text. */
    #####: 3683:    MD_ASSERT(closer->ch == 'D');
    #####: 3684:    opener->end = opener->beg;
    #####: 3685:    closer->ch = opener->ch;
    #####: 3686:    closer->beg = off;
    #####: 3687:    closer->end = off;
    #####: 3688:    md_resolve_range(ctx, NULL, mark_index, closer_index);
        -: 3689:}
        -: 3690:
        -: 3691:/* The permissive autolinks do not have to be enclosed in '<' '>' but we
        -: 3692: * instead impose stricter rules what is understood as an e-mail address
        -: 3693: * here. Actually any non-alphanumeric characters with exception of '.'
        -: 3694: * are prohibited both in username and after '@'. */
        -: 3695:static void
    #####: 3696:md_analyze_permissive_email_autolink(MD_CTX* ctx, int mark_index)
        -: 3697:{
    #####: 3698:    MD_MARK* opener = &ctx->marks[mark_index];
        -: 3699:    int closer_index;
        -: 3700:    MD_MARK* closer;
    #####: 3701:    OFF beg = opener->beg;
    #####: 3702:    OFF end = opener->end;
    #####: 3703:    int dot_count = 0;
        -: 3704:
    #####: 3705:    MD_ASSERT(CH(beg) == _T('@'));
        -: 3706:
        -: 3707:    /* Scan for name before '@'. */
    #####: 3708:    while(beg > 0  &&  (ISALNUM(beg-1) || ISANYOF(beg-1, _T(".-_+"))))
        -: 3709:        beg--;
        -: 3710:
        -: 3711:    /* Scan for domain after '@'. */
    #####: 3712:    while(end < ctx->size  &&  (ISALNUM(end) || ISANYOF(end, _T(".-_")))) {
    #####: 3713:        if(CH(end) == _T('.'))
    #####: 3714:            dot_count++;
    #####: 3715:        end++;
        -: 3716:    }
    #####: 3717:    if(CH(end-1) == _T('.')) {  /* Final '.' not part of it. */
    #####: 3718:        dot_count--;
    #####: 3719:        end--;
        -: 3720:    }
    #####: 3721:    else if(ISANYOF2(end-1, _T('-'), _T('_'))) /* These are forbidden at the end. */
        -: 3722:        return;
    #####: 3723:    if(CH(end-1) == _T('@')  ||  dot_count == 0)
        -: 3724:        return;
        -: 3725:
        -: 3726:    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero
        -: 3727:     * length so all the contents becomes the link text. */
    #####: 3728:    closer_index = mark_index + 1;
    #####: 3729:    closer = &ctx->marks[closer_index];
    #####: 3730:    MD_ASSERT(closer->ch == 'D');
        -: 3731:
    #####: 3732:    opener->beg = beg;
    #####: 3733:    opener->end = beg;
    #####: 3734:    closer->ch = opener->ch;
    #####: 3735:    closer->beg = end;
    #####: 3736:    closer->end = end;
    #####: 3737:    md_resolve_range(ctx, NULL, mark_index, closer_index);
        -: 3738:}
        -: 3739:
        -: 3740:static inline void
    #####: 3741:md_analyze_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3742:                 int mark_beg, int mark_end, const CHAR* mark_chars)
        -: 3743:{
        -: 3744:    int i = mark_beg;
        -: 3745:
    #####: 3746:    while(i < mark_end) {
    #####: 3747:        MD_MARK* mark = &ctx->marks[i];
        -: 3748:
        -: 3749:        /* Skip resolved spans. */
    #####: 3750:        if(mark->flags & MD_MARK_RESOLVED) {
    #####: 3751:            if(mark->flags & MD_MARK_OPENER) {
    #####: 3752:                MD_ASSERT(i < mark->next);
    #####: 3753:                i = mark->next + 1;
        -: 3754:            } else {
    #####: 3755:                i++;
        -: 3756:            }
    #####: 3757:            continue;
        -: 3758:        }
        -: 3759:
        -: 3760:        /* Skip marks we do not want to deal with. */
    #####: 3761:        if(!ISANYOF_(mark->ch, mark_chars)) {
    #####: 3762:            i++;
    #####: 3763:            continue;
        -: 3764:        }
        -: 3765:
        -: 3766:        /* Analyze the mark. */
    #####: 3767:        switch(mark->ch) {
    #####: 3768:            case '[':   /* Pass through. */
        -: 3769:            case '!':   /* Pass through. */
    #####: 3770:            case ']':   md_analyze_bracket(ctx, i); break;
    #####: 3771:            case '&':   md_analyze_entity(ctx, i); break;
    #####: 3772:            case '|':   md_analyze_table_cell_boundary(ctx, i); break;
    #####: 3773:            case '_':   /* Pass through. */
    #####: 3774:            case '*':   md_analyze_emph(ctx, i); break;
    #####: 3775:            case '~':   md_analyze_tilde(ctx, i); break;
    #####: 3776:            case '.':   /* Pass through. */
    #####: 3777:            case ':':   md_analyze_permissive_url_autolink(ctx, i); break;
    #####: 3778:            case '@':   md_analyze_permissive_email_autolink(ctx, i); break;
        -: 3779:        }
        -: 3780:
    #####: 3781:        i++;
        -: 3782:    }
    #####: 3783:}
        -: 3784:
        -: 3785:/* Analyze marks (build ctx->marks). */
        -: 3786:static int
    #####: 3787:md_analyze_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)
        -: 3788:{
        -: 3789:    int ret;
        -: 3790:
        -: 3791:    /* Reset the previously collected stack of marks. */
    #####: 3792:    ctx->n_marks = 0;
        -: 3793:
        -: 3794:    /* Collect all marks. */
    #####: 3795:    MD_CHECK(md_collect_marks(ctx, lines, n_lines, table_mode));
        -: 3796:
        -: 3797:    /* We analyze marks in few groups to handle their precedence. */
        -: 3798:    /* (1) Entities; code spans; autolinks; raw HTML. */
    #####: 3799:    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("&"));
        -: 3800:
    #####: 3801:    if(table_mode) {
        -: 3802:        /* (2) Analyze table cell boundaries.
        -: 3803:         * Note we reset TABLECELLBOUNDARIES chain prior to the call md_analyze_marks(),
        -: 3804:         * not after, because caller may need it. */
    #####: 3805:        MD_ASSERT(n_lines == 1);
    #####: 3806:        TABLECELLBOUNDARIES.head = -1;
    #####: 3807:        TABLECELLBOUNDARIES.tail = -1;
    #####: 3808:        ctx->n_table_cell_boundaries = 0;
    #####: 3809:        md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("|"));
    #####: 3810:        return ret;
        -: 3811:    }
        -: 3812:
        -: 3813:    /* (3) Links. */
    #####: 3814:    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("[]!"));
    #####: 3815:    MD_CHECK(md_resolve_links(ctx, lines, n_lines));
    #####: 3816:    BRACKET_OPENERS.head = -1;
    #####: 3817:    BRACKET_OPENERS.tail = -1;
    #####: 3818:    ctx->unresolved_link_head = -1;
    #####: 3819:    ctx->unresolved_link_tail = -1;
        -: 3820:
        -: 3821:    /* (4) Emphasis and strong emphasis; permissive autolinks. */
    #####: 3822:    md_analyze_link_contents(ctx, lines, n_lines, 0, ctx->n_marks);
        -: 3823:
    #####: 3824:abort:
        -: 3825:    return ret;
        -: 3826:}
        -: 3827:
        -: 3828:static void
    #####: 3829:md_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3830:                         int mark_beg, int mark_end)
        -: 3831:{
    #####: 3832:    md_analyze_marks(ctx, lines, n_lines, mark_beg, mark_end, _T("*_~@:."));
    #####: 3833:    ASTERISK_OPENERS_extraword_mod3_0.head = -1;
    #####: 3834:    ASTERISK_OPENERS_extraword_mod3_0.tail = -1;
    #####: 3835:    ASTERISK_OPENERS_extraword_mod3_1.head = -1;
    #####: 3836:    ASTERISK_OPENERS_extraword_mod3_1.tail = -1;
    #####: 3837:    ASTERISK_OPENERS_extraword_mod3_2.head = -1;
    #####: 3838:    ASTERISK_OPENERS_extraword_mod3_2.tail = -1;
    #####: 3839:    ASTERISK_OPENERS_intraword_mod3_0.head = -1;
    #####: 3840:    ASTERISK_OPENERS_intraword_mod3_0.tail = -1;
    #####: 3841:    ASTERISK_OPENERS_intraword_mod3_1.head = -1;
    #####: 3842:    ASTERISK_OPENERS_intraword_mod3_1.tail = -1;
    #####: 3843:    ASTERISK_OPENERS_intraword_mod3_2.head = -1;
    #####: 3844:    ASTERISK_OPENERS_intraword_mod3_2.tail = -1;
    #####: 3845:    UNDERSCORE_OPENERS.head = -1;
    #####: 3846:    UNDERSCORE_OPENERS.tail = -1;
    #####: 3847:    TILDE_OPENERS.head = -1;
    #####: 3848:    TILDE_OPENERS.tail = -1;
    #####: 3849:}
        -: 3850:
        -: 3851:static int
    #####: 3852:md_enter_leave_span_a(MD_CTX* ctx, int enter, MD_SPANTYPE type,
        -: 3853:                      const CHAR* dest, SZ dest_size, int prohibit_escapes_in_dest,
        -: 3854:                      const CHAR* title, SZ title_size)
        -: 3855:{
    #####: 3856:    MD_ATTRIBUTE_BUILD href_build = { 0 };
    #####: 3857:    MD_ATTRIBUTE_BUILD title_build = { 0 };
    #####: 3858:    MD_SPAN_A_DETAIL det;
    #####: 3859:    int ret = 0;
        -: 3860:
        -: 3861:    /* Note we here rely on fact that MD_SPAN_A_DETAIL and
        -: 3862:     * MD_SPAN_IMG_DETAIL are binary-compatible. */
    #####: 3863:    memset(&det, 0, sizeof(MD_SPAN_A_DETAIL));
    #####: 3864:    MD_CHECK(md_build_attribute(ctx, dest, dest_size,
        -: 3865:                    (prohibit_escapes_in_dest ? MD_BUILD_ATTR_NO_ESCAPES : 0),
        -: 3866:                    &det.href, &href_build));
    #####: 3867:    MD_CHECK(md_build_attribute(ctx, title, title_size, 0, &det.title, &title_build));
        -: 3868:
    #####: 3869:    if(enter)
    #####: 3870:        MD_ENTER_SPAN(type, &det);
        -: 3871:    else
    #####: 3872:        MD_LEAVE_SPAN(type, &det);
        -: 3873:
    #####: 3874:abort:
    #####: 3875:    md_free_attribute(ctx, &href_build);
    #####: 3876:    md_free_attribute(ctx, &title_build);
    #####: 3877:    return ret;
        -: 3878:}
        -: 3879:
        -: 3880:/* Render the output, accordingly to the analyzed ctx->marks. */
        -: 3881:static int
    #####: 3882:md_process_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 3883:{
        -: 3884:    MD_TEXTTYPE text_type;
    #####: 3885:    const MD_LINE* line = lines;
    #####: 3886:    MD_MARK* prev_mark = NULL;
        -: 3887:    MD_MARK* mark;
    #####: 3888:    OFF off = lines[0].beg;
    #####: 3889:    OFF end = lines[n_lines-1].end;
    #####: 3890:    int enforce_hardbreak = 0;
    #####: 3891:    int ret = 0;
        -: 3892:
        -: 3893:    /* Find first resolved mark. Note there is always at least one resolved
        -: 3894:     * mark,  the dummy last one after the end of the latest line we actually
        -: 3895:     * never really reach. This saves us of a lot of special checks and cases
        -: 3896:     * in this function. */
    #####: 3897:    mark = ctx->marks;
    #####: 3898:    while(!(mark->flags & MD_MARK_RESOLVED))
    #####: 3899:        mark++;
        -: 3900:
        -: 3901:    text_type = MD_TEXT_NORMAL;
        -: 3902:
        -: 3903:    while(1) {
        -: 3904:        /* Process the text up to the next mark or end-of-line. */
    #####: 3905:        OFF tmp = (line->end < mark->beg ? line->end : mark->beg);
    #####: 3906:        if(tmp > off) {
    #####: 3907:            MD_TEXT(text_type, STR(off), tmp - off);
        -: 3908:            off = tmp;
        -: 3909:        }
        -: 3910:
        -: 3911:        /* If reached the mark, process it and move to next one. */
    #####: 3912:        if(off >= mark->beg) {
    #####: 3913:            switch(mark->ch) {
    #####: 3914:                case '\\':      /* Backslash escape. */
    #####: 3915:                    if(ISNEWLINE(mark->beg+1))
        -: 3916:                        enforce_hardbreak = 1;
        -: 3917:                    else
    #####: 3918:                        MD_TEXT(text_type, STR(mark->beg+1), 1);
        -: 3919:                    break;
        -: 3920:
        -: 3921:                case ' ':       /* Non-trivial space. */
    #####: 3922:                    MD_TEXT(text_type, _T(" "), 1);
        -: 3923:                    break;
        -: 3924:
    #####: 3925:                case '`':       /* Code span. */
    #####: 3926:                    if(mark->flags & MD_MARK_OPENER) {
    #####: 3927:                        MD_ENTER_SPAN(MD_SPAN_CODE, NULL);
        -: 3928:                        text_type = MD_TEXT_CODE;
        -: 3929:                    } else {
    #####: 3930:                        MD_LEAVE_SPAN(MD_SPAN_CODE, NULL);
        -: 3931:                        text_type = MD_TEXT_NORMAL;
        -: 3932:                    }
        -: 3933:                    break;
        -: 3934:
    #####: 3935:                case '_':
        -: 3936:                case '*':       /* Emphasis, strong emphasis. */
    #####: 3937:                    if(mark->flags & MD_MARK_OPENER) {
    #####: 3938:                        if((mark->end - off) % 2) {
    #####: 3939:                            MD_ENTER_SPAN(MD_SPAN_EM, NULL);
    #####: 3940:                            off++;
        -: 3941:                        }
    #####: 3942:                        while(off + 1 < mark->end) {
    #####: 3943:                            MD_ENTER_SPAN(MD_SPAN_STRONG, NULL);
    #####: 3944:                            off += 2;
        -: 3945:                        }
        -: 3946:                    } else {
    #####: 3947:                        while(off + 1 < mark->end) {
    #####: 3948:                            MD_LEAVE_SPAN(MD_SPAN_STRONG, NULL);
    #####: 3949:                            off += 2;
        -: 3950:                        }
    #####: 3951:                        if((mark->end - off) % 2) {
    #####: 3952:                            MD_LEAVE_SPAN(MD_SPAN_EM, NULL);
        -: 3953:                            off++;
        -: 3954:                        }
        -: 3955:                    }
        -: 3956:                    break;
        -: 3957:
    #####: 3958:                case '~':
    #####: 3959:                    if(mark->flags & MD_MARK_OPENER)
    #####: 3960:                        MD_ENTER_SPAN(MD_SPAN_DEL, NULL);
        -: 3961:                    else
    #####: 3962:                        MD_LEAVE_SPAN(MD_SPAN_DEL, NULL);
        -: 3963:                    break;
        -: 3964:
    #####: 3965:                case '[':       /* Link, image. */
        -: 3966:                case '!':
        -: 3967:                case ']':
        -: 3968:                {
    #####: 3969:                    const MD_MARK* opener = (mark->ch != ']' ? mark : &ctx->marks[mark->prev]);
    #####: 3970:                    const MD_MARK* dest_mark = opener+1;
    #####: 3971:                    const MD_MARK* title_mark = opener+2;
        -: 3972:
    #####: 3973:                    MD_ASSERT(dest_mark->ch == 'D');
    #####: 3974:                    MD_ASSERT(title_mark->ch == 'D');
        -: 3975:
    #####: 3976:                    MD_CHECK(md_enter_leave_span_a(ctx, (mark->ch != ']'),
        -: 3977:                                (opener->ch == '!' ? MD_SPAN_IMG : MD_SPAN_A),
        -: 3978:                                STR(dest_mark->beg), dest_mark->end - dest_mark->beg, FALSE,
        -: 3979:                                md_mark_get_ptr(ctx, title_mark - ctx->marks), title_mark->prev));
        -: 3980:
        -: 3981:                    /* link/image closer may span multiple lines. */
    #####: 3982:                    if(mark->ch == ']') {
    #####: 3983:                        while(mark->end > line->end)
    #####: 3984:                            line++;
        -: 3985:                    }
        -: 3986:
        -: 3987:                    break;
        -: 3988:                }
        -: 3989:
    #####: 3990:                case '<':
        -: 3991:                case '>':       /* Autolink or raw HTML. */
    #####: 3992:                    if(!(mark->flags & MD_MARK_AUTOLINK)) {
        -: 3993:                        /* Raw HTML. */
    #####: 3994:                        if(mark->flags & MD_MARK_OPENER)
        -: 3995:                            text_type = MD_TEXT_HTML;
        -: 3996:                        else
    #####: 3997:                            text_type = MD_TEXT_NORMAL;
        -: 3998:                        break;
        -: 3999:                    }
        -: 4000:                    /* Pass through, if auto-link. */
        -: 4001:
        -: 4002:                case '@':       /* Permissive e-mail autolink. */
        -: 4003:                case ':':       /* Permissive URL autolink. */
        -: 4004:                case '.':       /* Permissive WWW autolink. */
        -: 4005:                {
    #####: 4006:                    MD_MARK* opener = ((mark->flags & MD_MARK_OPENER) ? mark : &ctx->marks[mark->prev]);
    #####: 4007:                    MD_MARK* closer = &ctx->marks[opener->next];
    #####: 4008:                    const CHAR* dest = STR(opener->end);
    #####: 4009:                    SZ dest_size = closer->beg - opener->end;
        -: 4010:
        -: 4011:                    /* For permissive auto-links we do not know closer mark
        -: 4012:                     * position at the time of md_collect_marks(), therefore
        -: 4013:                     * it can be out-of-order in ctx->marks[].
        -: 4014:                     *
        -: 4015:                     * With this flag, we make sure that we output the closer
        -: 4016:                     * only if we processed the opener. */
    #####: 4017:                    if(mark->flags & MD_MARK_OPENER)
    #####: 4018:                        closer->flags |= MD_MARK_VALIDPERMISSIVEAUTOLINK;
        -: 4019:
    #####: 4020:                    if(opener->ch == '@' || opener->ch == '.') {
    #####: 4021:                        dest_size += 7;
    #####: 4022:                        MD_TEMP_BUFFER(dest_size * sizeof(CHAR));
    #####: 4023:                        memcpy(ctx->buffer,
    #####: 4024:                                (opener->ch == '@' ? _T("mailto:") : _T("http://")),
        -: 4025:                                7 * sizeof(CHAR));
    #####: 4026:                        memcpy(ctx->buffer + 7, dest, (dest_size-7) * sizeof(CHAR));
    #####: 4027:                        dest = ctx->buffer;
        -: 4028:                    }
        -: 4029:
    #####: 4030:                    if(closer->flags & MD_MARK_VALIDPERMISSIVEAUTOLINK)
    #####: 4031:                        MD_CHECK(md_enter_leave_span_a(ctx, (mark->flags & MD_MARK_OPENER),
        -: 4032:                                    MD_SPAN_A, dest, dest_size, TRUE, NULL, 0));
        -: 4033:                    break;
        -: 4034:                }
        -: 4035:
    #####: 4036:                case '&':       /* Entity. */
    #####: 4037:                    MD_TEXT(MD_TEXT_ENTITY, STR(mark->beg), mark->end - mark->beg);
        -: 4038:                    break;
        -: 4039:
        -: 4040:                case '\0':
    #####: 4041:                    MD_TEXT(MD_TEXT_NULLCHAR, _T(""), 1);
        -: 4042:                    break;
        -: 4043:
        -: 4044:                case 127:
        -: 4045:                    goto abort;
        -: 4046:            }
        -: 4047:
    #####: 4048:            off = mark->end;
        -: 4049:
        -: 4050:            /* Move to next resolved mark. */
    #####: 4051:            prev_mark = mark;
    #####: 4052:            mark++;
    #####: 4053:            while(!(mark->flags & MD_MARK_RESOLVED)  ||  mark->beg < off)
    #####: 4054:                mark++;
        -: 4055:        }
        -: 4056:
        -: 4057:        /* If reached end of line, move to next one. */
    #####: 4058:        if(off >= line->end) {
        -: 4059:            /* If it is the last line, we are done. */
    #####: 4060:            if(off >= end)
        -: 4061:                break;
        -: 4062:
    #####: 4063:            if(text_type == MD_TEXT_CODE) {
        -: 4064:                OFF tmp;
        -: 4065:
    #####: 4066:                MD_ASSERT(prev_mark != NULL);
    #####: 4067:                MD_ASSERT(prev_mark->ch == '`'  &&  (prev_mark->flags & MD_MARK_OPENER));
    #####: 4068:                MD_ASSERT(mark->ch == '`'  &&  (mark->flags & MD_MARK_CLOSER));
        -: 4069:
        -: 4070:                /* Inside a code span, trailing line whitespace has to be
        -: 4071:                 * outputted. */
        -: 4072:                tmp = off;
    #####: 4073:                while(off < ctx->size  &&  ISBLANK(off))
    #####: 4074:                    off++;
    #####: 4075:                if(off > tmp)
    #####: 4076:                    MD_TEXT(MD_TEXT_CODE, STR(tmp), off-tmp);
        -: 4077:
        -: 4078:                /* and new lines are transformed into single spaces. */
    #####: 4079:                if(prev_mark->end < off  &&  off < mark->beg)
    #####: 4080:                    MD_TEXT(MD_TEXT_CODE, _T(" "), 1);
        -: 4081:
    #####: 4082:            } else if(text_type == MD_TEXT_HTML) {
        -: 4083:                /* Inside raw HTML, we output the new line verbatim, including
        -: 4084:                 * any trailing spaces. */
        -: 4085:                OFF tmp = off;
        -: 4086:
    #####: 4087:                while(tmp < end  &&  ISBLANK(tmp))
    #####: 4088:                    tmp++;
    #####: 4089:                if(tmp > off)
    #####: 4090:                    MD_TEXT(MD_TEXT_HTML, STR(off), tmp - off);
    #####: 4091:                MD_TEXT(MD_TEXT_HTML, _T("\n"), 1);
        -: 4092:            } else {
        -: 4093:                /* Output soft or hard line break. */
    #####: 4094:                MD_TEXTTYPE break_type = MD_TEXT_SOFTBR;
        -: 4095:
    #####: 4096:                if(text_type == MD_TEXT_NORMAL) {
    #####: 4097:                    if(enforce_hardbreak)
        -: 4098:                        break_type = MD_TEXT_BR;
    #####: 4099:                    else if((CH(line->end) == _T(' ') && CH(line->end+1) == _T(' ')))
    #####: 4100:                        break_type = MD_TEXT_BR;
        -: 4101:                }
        -: 4102:
    #####: 4103:                MD_TEXT(break_type, _T("\n"), 1);
        -: 4104:            }
        -: 4105:
        -: 4106:            /* Move to the next line. */
    #####: 4107:            line++;
    #####: 4108:            off = line->beg;
        -: 4109:
    #####: 4110:            enforce_hardbreak = 0;
        -: 4111:        }
        -: 4112:    }
        -: 4113:
    #####: 4114:abort:
    #####: 4115:    return ret;
        -: 4116:}
        -: 4117:
        -: 4118:
        -: 4119:/***************************
        -: 4120: ***  Processing Tables  ***
        -: 4121: ***************************/
        -: 4122:
        -: 4123:static void
    #####: 4124:md_analyze_table_alignment(MD_CTX* ctx, OFF beg, OFF end, MD_ALIGN* align, int n_align)
        -: 4125:{
        -: 4126:    static const MD_ALIGN align_map[] = { MD_ALIGN_DEFAULT, MD_ALIGN_LEFT, MD_ALIGN_RIGHT, MD_ALIGN_CENTER };
    #####: 4127:    OFF off = beg;
        -: 4128:
    #####: 4129:    while(n_align > 0) {
        -: 4130:        int index = 0;  /* index into align_map[] */
        -: 4131:
    #####: 4132:        while(CH(off) != _T('-'))
    #####: 4133:            off++;
    #####: 4134:        if(off > beg  &&  CH(off-1) == _T(':'))
    #####: 4135:            index |= 1;
    #####: 4136:        while(off < end  &&  CH(off) == _T('-'))
    #####: 4137:            off++;
    #####: 4138:        if(off < end  &&  CH(off) == _T(':'))
    #####: 4139:            index |= 2;
        -: 4140:
    #####: 4141:        *align = align_map[index];
    #####: 4142:        align++;
    #####: 4143:        n_align--;
        -: 4144:    }
        -: 4145:
    #####: 4146:}
        -: 4147:
        -: 4148:/* Forward declaration. */
        -: 4149:static int md_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines);
        -: 4150:
        -: 4151:static int
    #####: 4152:md_process_table_cell(MD_CTX* ctx, MD_BLOCKTYPE cell_type, MD_ALIGN align, OFF beg, OFF end)
        -: 4153:{
    #####: 4154:    MD_LINE line;
    #####: 4155:    MD_BLOCK_TD_DETAIL det;
    #####: 4156:    int ret = 0;
        -: 4157:
    #####: 4158:    while(beg < end  &&  ISWHITESPACE(beg))
    #####: 4159:        beg++;
    #####: 4160:    while(end > beg  &&  ISWHITESPACE(end-1))
        -: 4161:        end--;
        -: 4162:
    #####: 4163:    det.align = align;
    #####: 4164:    line.beg = beg;
    #####: 4165:    line.end = end;
        -: 4166:
    #####: 4167:    MD_ENTER_BLOCK(cell_type, &det);
    #####: 4168:    MD_CHECK(md_process_normal_block_contents(ctx, &line, 1));
    #####: 4169:    MD_LEAVE_BLOCK(cell_type, &det);
        -: 4170:
    #####: 4171:abort:
    #####: 4172:    return ret;
        -: 4173:}
        -: 4174:
        -: 4175:static int
    #####: 4176:md_process_table_row(MD_CTX* ctx, MD_BLOCKTYPE cell_type, OFF beg, OFF end,
        -: 4177:                     const MD_ALIGN* align, int col_count)
        -: 4178:{
    #####: 4179:    MD_LINE line;
    #####: 4180:    OFF* pipe_offs = NULL;
        -: 4181:    int i, j, n;
    #####: 4182:    int ret = 0;
        -: 4183:
    #####: 4184:    line.beg = beg;
    #####: 4185:    line.end = end;
        -: 4186:
        -: 4187:    /* Break the line into table cells by identifying pipe characters who
        -: 4188:     * form the cell boundary. */
    #####: 4189:    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));
        -: 4190:
        -: 4191:    /* We have to remember the cell boundaries in local buffer because
        -: 4192:     * ctx->marks[] shall be reused during cell contents processing. */
    #####: 4193:    n = ctx->n_table_cell_boundaries;
    #####: 4194:    pipe_offs = (OFF*) malloc(n * sizeof(OFF));
    #####: 4195:    if(pipe_offs == NULL) {
    #####: 4196:        MD_LOG("malloc() failed.");
        -: 4197:        ret = -1;
        -: 4198:        goto abort;
        -: 4199:    }
    #####: 4200:    for(i = TABLECELLBOUNDARIES.head, j = 0; i >= 0; i = ctx->marks[i].next) {
    #####: 4201:        MD_MARK* mark = &ctx->marks[i];
    #####: 4202:        pipe_offs[j++] = mark->beg;
        -: 4203:    }
        -: 4204:
        -: 4205:    /* Process cells. */
    #####: 4206:    MD_ENTER_BLOCK(MD_BLOCK_TR, NULL);
    #####: 4207:    j = 0;
    #####: 4208:    if(beg < pipe_offs[0]  &&  j < col_count)
    #####: 4209:        MD_CHECK(md_process_table_cell(ctx, cell_type, align[j++], beg, pipe_offs[0]));
    #####: 4210:    for(i = 0; i < n-1  &&  j < col_count; i++)
    #####: 4211:        MD_CHECK(md_process_table_cell(ctx, cell_type, align[j++], pipe_offs[i]+1, pipe_offs[i+1]));
    #####: 4212:    if(pipe_offs[n-1] < end-1  &&  j < col_count)
    #####: 4213:        MD_CHECK(md_process_table_cell(ctx, cell_type, align[j++], pipe_offs[n-1]+1, end));
        -: 4214:    /* Make sure we call enough table cells even if the current table contains
        -: 4215:     * too few of them. */
    #####: 4216:    while(j < col_count)
    #####: 4217:        MD_CHECK(md_process_table_cell(ctx, cell_type, align[j++], 0, 0));
        -: 4218:
    #####: 4219:    MD_LEAVE_BLOCK(MD_BLOCK_TR, NULL);
        -: 4220:
    #####: 4221:abort:
    #####: 4222:    free(pipe_offs);
        -: 4223:
        -: 4224:    /* Free any temporary memory blocks stored within some dummy marks. */
    #####: 4225:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4226:        free(md_mark_get_ptr(ctx, i));
    #####: 4227:    PTR_CHAIN.head = -1;
    #####: 4228:    PTR_CHAIN.tail = -1;
        -: 4229:
    #####: 4230:    return ret;
        -: 4231:}
        -: 4232:
        -: 4233:static int
    #####: 4234:md_process_table_block_contents(MD_CTX* ctx, int col_count, const MD_LINE* lines, int n_lines)
        -: 4235:{
        -: 4236:    MD_ALIGN* align;
        -: 4237:    int i;
    #####: 4238:    int ret = 0;
        -: 4239:
        -: 4240:    /* At least two lines have to be present: The column headers and the line
        -: 4241:     * with the underlines. */
    #####: 4242:    MD_ASSERT(n_lines >= 2);
        -: 4243:
    #####: 4244:    align = malloc(col_count * sizeof(MD_ALIGN));
    #####: 4245:    if(align == NULL) {
    #####: 4246:        MD_LOG("malloc() failed.");
        -: 4247:        ret = -1;
        -: 4248:        goto abort;
        -: 4249:    }
        -: 4250:
    #####: 4251:    md_analyze_table_alignment(ctx, lines[1].beg, lines[1].end, align, col_count);
        -: 4252:
    #####: 4253:    MD_ENTER_BLOCK(MD_BLOCK_THEAD, NULL);
    #####: 4254:    MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TH,
        -: 4255:                        lines[0].beg, lines[0].end, align, col_count));
    #####: 4256:    MD_LEAVE_BLOCK(MD_BLOCK_THEAD, NULL);
        -: 4257:
    #####: 4258:    MD_ENTER_BLOCK(MD_BLOCK_TBODY, NULL);
    #####: 4259:    for(i = 2; i < n_lines; i++) {
    #####: 4260:        MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TD,
        -: 4261:                        lines[i].beg, lines[i].end, align, col_count));
        -: 4262:    }
    #####: 4263:    MD_LEAVE_BLOCK(MD_BLOCK_TBODY, NULL);
        -: 4264:
    #####: 4265:abort:
    #####: 4266:    free(align);
    #####: 4267:    return ret;
        -: 4268:}
        -: 4269:
        -: 4270:static int
    #####: 4271:md_is_table_row(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 4272:{
    #####: 4273:    MD_LINE line;
        -: 4274:    int i;
    #####: 4275:    int ret = FALSE;
        -: 4276:
    #####: 4277:    line.beg = beg;
    #####: 4278:    line.end = beg;
        -: 4279:
        -: 4280:    /* Find end of line. */
    #####: 4281:    while(line.end < ctx->size  &&  !ISNEWLINE(line.end))
    #####: 4282:        line.end++;
        -: 4283:
    #####: 4284:    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));
        -: 4285:
    #####: 4286:    if(TABLECELLBOUNDARIES.head >= 0) {
    #####: 4287:        if(p_end != NULL)
    #####: 4288:            *p_end = line.end;
        -: 4289:        ret = TRUE;
        -: 4290:    }
        -: 4291:
    #####: 4292:abort:
        -: 4293:    /* Free any temporary memory blocks stored within some dummy marks. */
    #####: 4294:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4295:        free(md_mark_get_ptr(ctx, i));
    #####: 4296:    PTR_CHAIN.head = -1;
    #####: 4297:    PTR_CHAIN.tail = -1;
        -: 4298:
    #####: 4299:    return ret;
        -: 4300:}
        -: 4301:
        -: 4302:
        -: 4303:/**************************
        -: 4304: ***  Processing Block  ***
        -: 4305: **************************/
        -: 4306:
        -: 4307:#define MD_BLOCK_CONTAINER_OPENER   0x01
        -: 4308:#define MD_BLOCK_CONTAINER_CLOSER   0x02
        -: 4309:#define MD_BLOCK_CONTAINER          (MD_BLOCK_CONTAINER_OPENER | MD_BLOCK_CONTAINER_CLOSER)
        -: 4310:#define MD_BLOCK_LOOSE_LIST         0x04
        -: 4311:#define MD_BLOCK_SETEXT_HEADER      0x08
        -: 4312:
        -: 4313:struct MD_BLOCK_tag {
        -: 4314:    MD_BLOCKTYPE type  :  8;
        -: 4315:    unsigned flags     :  8;
        -: 4316:
        -: 4317:    /* MD_BLOCK_H:      Header level (1 - 6)
        -: 4318:     * MD_BLOCK_CODE:   Non-zero if fenced, zero if indented.
        -: 4319:     * MD_BLOCK_LI:     Task mark character (0 if not task list item, 'x', 'X' or ' ').
        -: 4320:     * MD_BLOCK_TABLE:  Column count (as determined by the table underline).
        -: 4321:     */
        -: 4322:    unsigned data      : 16;
        -: 4323:
        -: 4324:    /* Leaf blocks:     Count of lines (MD_LINE or MD_VERBATIMLINE) on the block.
        -: 4325:     * MD_BLOCK_LI:     Task mark offset in the input doc.
        -: 4326:     * MD_BLOCK_OL:     Start item number.
        -: 4327:     */
        -: 4328:    unsigned n_lines;
        -: 4329:};
        -: 4330:
        -: 4331:struct MD_CONTAINER_tag {
        -: 4332:    CHAR ch;
        -: 4333:    unsigned is_loose    : 8;
        -: 4334:    unsigned is_task     : 8;
        -: 4335:    unsigned start;
        -: 4336:    unsigned mark_indent;
        -: 4337:    unsigned contents_indent;
        -: 4338:    OFF block_byte_off;
        -: 4339:    OFF task_mark_off;
        -: 4340:};
        -: 4341:
        -: 4342:
        -: 4343:static int
    #####: 4344:md_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 4345:{
        -: 4346:    int i;
        -: 4347:    int ret;
        -: 4348:
    #####: 4349:    MD_CHECK(md_analyze_inlines(ctx, lines, n_lines, FALSE));
    #####: 4350:    MD_CHECK(md_process_inlines(ctx, lines, n_lines));
        -: 4351:
    #####: 4352:abort:
        -: 4353:    /* Free any temporary memory blocks stored within some dummy marks. */
    #####: 4354:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4355:        free(md_mark_get_ptr(ctx, i));
    #####: 4356:    PTR_CHAIN.head = -1;
    #####: 4357:    PTR_CHAIN.tail = -1;
        -: 4358:
    #####: 4359:    return ret;
        -: 4360:}
        -: 4361:
        -: 4362:static int
    #####: 4363:md_process_verbatim_block_contents(MD_CTX* ctx, MD_TEXTTYPE text_type, const MD_VERBATIMLINE* lines, int n_lines)
        -: 4364:{
        -: 4365:    static const CHAR indent_chunk_str[] = _T("                ");
        -: 4366:    static const SZ indent_chunk_size = SIZEOF_ARRAY(indent_chunk_str) - 1;
        -: 4367:
        -: 4368:    int i;
    #####: 4369:    int ret = 0;
        -: 4370:
    #####: 4371:    for(i = 0; i < n_lines; i++) {
    #####: 4372:        const MD_VERBATIMLINE* line = &lines[i];
    #####: 4373:        int indent = line->indent;
        -: 4374:
    #####: 4375:        MD_ASSERT(indent >= 0);
        -: 4376:
        -: 4377:        /* Output code indentation. */
    #####: 4378:        while(indent > SIZEOF_ARRAY(indent_chunk_str)) {
    #####: 4379:            MD_TEXT(text_type, indent_chunk_str, indent_chunk_size);
    #####: 4380:            indent -= SIZEOF_ARRAY(indent_chunk_str);
        -: 4381:        }
    #####: 4382:        if(indent > 0)
    #####: 4383:            MD_TEXT(text_type, indent_chunk_str, indent);
        -: 4384:
        -: 4385:        /* Output the code line itself. */
    #####: 4386:        MD_TEXT_INSECURE(text_type, STR(line->beg), line->end - line->beg);
        -: 4387:
        -: 4388:        /* Enforce end-of-line. */
    #####: 4389:        MD_TEXT(text_type, _T("\n"), 1);
        -: 4390:    }
        -: 4391:
    #####: 4392:abort:
    #####: 4393:    return ret;
        -: 4394:}
        -: 4395:
        -: 4396:static int
    #####: 4397:md_process_code_block_contents(MD_CTX* ctx, int is_fenced, const MD_VERBATIMLINE* lines, int n_lines)
        -: 4398:{
    #####: 4399:    if(is_fenced) {
        -: 4400:        /* Skip the first line in case of fenced code: It is the fence.
        -: 4401:         * (Only the starting fence is present due to logic in md_analyze_line().) */
    #####: 4402:        lines++;
    #####: 4403:        n_lines--;
        -: 4404:    } else {
        -: 4405:        /* Ignore blank lines at start/end of indented code block. */
    #####: 4406:        while(n_lines > 0  &&  lines[0].beg == lines[0].end) {
    #####: 4407:            lines++;
    #####: 4408:            n_lines--;
        -: 4409:        }
    #####: 4410:        while(n_lines > 0  &&  lines[n_lines-1].beg == lines[n_lines-1].end) {
    #####: 4411:            n_lines--;
        -: 4412:        }
        -: 4413:    }
        -: 4414:
    #####: 4415:    if(n_lines == 0)
        -: 4416:        return 0;
        -: 4417:
    #####: 4418:    return md_process_verbatim_block_contents(ctx, MD_TEXT_CODE, lines, n_lines);
        -: 4419:}
        -: 4420:
        -: 4421:static int
    #####: 4422:md_setup_fenced_code_detail(MD_CTX* ctx, const MD_BLOCK* block, MD_BLOCK_CODE_DETAIL* det,
        -: 4423:                            MD_ATTRIBUTE_BUILD* info_build, MD_ATTRIBUTE_BUILD* lang_build)
        -: 4424:{
    #####: 4425:    const MD_VERBATIMLINE* fence_line = (const MD_VERBATIMLINE*)(block + 1);
    #####: 4426:    OFF beg = fence_line->beg;
    #####: 4427:    OFF end = fence_line->end;
        -: 4428:    OFF lang_end;
    #####: 4429:    CHAR fence_ch = CH(fence_line->beg);
    #####: 4430:    int ret = 0;
        -: 4431:
        -: 4432:    /* Skip the fence itself. */
    #####: 4433:    while(beg < ctx->size  &&  CH(beg) == fence_ch)
    #####: 4434:        beg++;
        -: 4435:    /* Trim initial spaces. */
    #####: 4436:    while(beg < ctx->size  &&  CH(beg) == _T(' '))
    #####: 4437:        beg++;
        -: 4438:
        -: 4439:    /* Trim trailing spaces. */
    #####: 4440:    while(end > beg  &&  CH(end-1) == _T(' '))
        -: 4441:        end--;
        -: 4442:
        -: 4443:    /* Build info string attribute. */
    #####: 4444:    MD_CHECK(md_build_attribute(ctx, STR(beg), end - beg, 0, &det->info, info_build));
        -: 4445:
        -: 4446:    /* Build info string attribute. */
        -: 4447:    lang_end = beg;
    #####: 4448:    while(lang_end < end  &&  !ISWHITESPACE(lang_end))
    #####: 4449:        lang_end++;
    #####: 4450:    MD_CHECK(md_build_attribute(ctx, STR(beg), lang_end - beg, 0, &det->lang, lang_build));
        -: 4451:
    #####: 4452:abort:
    #####: 4453:    return ret;
        -: 4454:}
        -: 4455:
        -: 4456:static int
    #####: 4457:md_process_leaf_block(MD_CTX* ctx, const MD_BLOCK* block)
        -: 4458:{
        -: 4459:    union {
        -: 4460:        MD_BLOCK_H_DETAIL header;
        -: 4461:        MD_BLOCK_CODE_DETAIL code;
    #####: 4462:    } det;
    #####: 4463:    MD_ATTRIBUTE_BUILD info_build;
    #####: 4464:    MD_ATTRIBUTE_BUILD lang_build;
        -: 4465:    int is_in_tight_list;
    #####: 4466:    int clean_fence_code_detail = FALSE;
    #####: 4467:    int ret = 0;
        -: 4468:
    #####: 4469:    memset(&det, 0, sizeof(det));
        -: 4470:
    #####: 4471:    if(ctx->n_containers == 0)
        -: 4472:        is_in_tight_list = FALSE;
        -: 4473:    else
    #####: 4474:        is_in_tight_list = !ctx->containers[ctx->n_containers-1].is_loose;
        -: 4475:
    #####: 4476:    switch(block->type) {
    #####: 4477:        case MD_BLOCK_H:
    #####: 4478:            det.header.level = block->data;
    #####: 4479:            break;
        -: 4480:
    #####: 4481:        case MD_BLOCK_CODE:
        -: 4482:            /* For fenced code block, we may need to set the info string. */
    #####: 4483:            if(block->data != 0) {
    #####: 4484:                memset(&det.code, 0, sizeof(MD_BLOCK_CODE_DETAIL));
    #####: 4485:                clean_fence_code_detail = TRUE;
    #####: 4486:                MD_CHECK(md_setup_fenced_code_detail(ctx, block, &det.code, &info_build, &lang_build));
        -: 4487:            }
        -: 4488:            break;
        -: 4489:
        -: 4490:        default:
        -: 4491:            /* Noop. */
        -: 4492:            break;
        -: 4493:    }
        -: 4494:
    #####: 4495:    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)
    #####: 4496:        MD_ENTER_BLOCK(block->type, (void*) &det);
        -: 4497:
        -: 4498:    /* Process the block contents accordingly to is type. */
    #####: 4499:    switch(block->type) {
        -: 4500:        case MD_BLOCK_HR:
        -: 4501:            /* noop */
        -: 4502:            break;
        -: 4503:
    #####: 4504:        case MD_BLOCK_CODE:
    #####: 4505:            MD_CHECK(md_process_code_block_contents(ctx, (block->data != 0),
        -: 4506:                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));
        -: 4507:            break;
        -: 4508:
    #####: 4509:        case MD_BLOCK_HTML:
    #####: 4510:            MD_CHECK(md_process_verbatim_block_contents(ctx, MD_TEXT_HTML,
        -: 4511:                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));
        -: 4512:            break;
        -: 4513:
    #####: 4514:        case MD_BLOCK_TABLE:
    #####: 4515:            MD_CHECK(md_process_table_block_contents(ctx, block->data,
        -: 4516:                            (const MD_LINE*)(block + 1), block->n_lines));
        -: 4517:            break;
        -: 4518:
    #####: 4519:        default:
    #####: 4520:            MD_CHECK(md_process_normal_block_contents(ctx,
        -: 4521:                            (const MD_LINE*)(block + 1), block->n_lines));
        -: 4522:            break;
        -: 4523:    }
        -: 4524:
    #####: 4525:    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)
    #####: 4526:        MD_LEAVE_BLOCK(block->type, (void*) &det);
        -: 4527:
    #####: 4528:abort:
    #####: 4529:    if(clean_fence_code_detail) {
    #####: 4530:        md_free_attribute(ctx, &info_build);
    #####: 4531:        md_free_attribute(ctx, &lang_build);
        -: 4532:    }
    #####: 4533:    return ret;
        -: 4534:}
        -: 4535:
        -: 4536:static int
    #####: 4537:md_process_all_blocks(MD_CTX* ctx)
        -: 4538:{
    #####: 4539:    int byte_off = 0;
    #####: 4540:    int ret = 0;
        -: 4541:
        -: 4542:    /* ctx->containers now is not needed for detection of lists and list items
        -: 4543:     * so we reuse it for tracking what lists are loose or tight. We rely
        -: 4544:     * on the fact the vector is large enough to hold the deepest nesting
        -: 4545:     * level of lists. */
    #####: 4546:    ctx->n_containers = 0;
        -: 4547:
    #####: 4548:    while(byte_off < ctx->n_block_bytes) {
    #####: 4549:        MD_BLOCK* block = (MD_BLOCK*)((char*)ctx->block_bytes + byte_off);
        -: 4550:        union {
        -: 4551:            MD_BLOCK_UL_DETAIL ul;
        -: 4552:            MD_BLOCK_OL_DETAIL ol;
        -: 4553:            MD_BLOCK_LI_DETAIL li;
    #####: 4554:        } det;
        -: 4555:
    #####: 4556:        switch(block->type) {
    #####: 4557:            case MD_BLOCK_UL:
    #####: 4558:                det.ul.is_tight = (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;
    #####: 4559:                det.ul.mark = (CHAR) block->data;
    #####: 4560:                break;
        -: 4561:
    #####: 4562:            case MD_BLOCK_OL:
    #####: 4563:                det.ol.start = block->n_lines;
    #####: 4564:                det.ol.is_tight =  (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;
    #####: 4565:                det.ol.mark_delimiter = (CHAR) block->data;
    #####: 4566:                break;
        -: 4567:
    #####: 4568:            case MD_BLOCK_LI:
    #####: 4569:                det.li.is_task = (block->data != 0);
    #####: 4570:                det.li.task_mark = (CHAR) block->data;
    #####: 4571:                det.li.task_mark_offset = (OFF) block->n_lines;
    #####: 4572:                break;
        -: 4573:
        -: 4574:            default:
        -: 4575:                /* noop */
        -: 4576:                break;
        -: 4577:        }
        -: 4578:
    #####: 4579:        if(block->flags & MD_BLOCK_CONTAINER) {
    #####: 4580:            if(block->flags & MD_BLOCK_CONTAINER_CLOSER) {
    #####: 4581:                MD_LEAVE_BLOCK(block->type, &det);
        -: 4582:
    #####: 4583:                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL || block->type == MD_BLOCK_QUOTE)
    #####: 4584:                    ctx->n_containers--;
        -: 4585:            }
        -: 4586:
    #####: 4587:            if(block->flags & MD_BLOCK_CONTAINER_OPENER) {
    #####: 4588:                MD_ENTER_BLOCK(block->type, &det);
        -: 4589:
    #####: 4590:                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL) {
    #####: 4591:                    ctx->containers[ctx->n_containers].is_loose = (block->flags & MD_BLOCK_LOOSE_LIST);
    #####: 4592:                    ctx->n_containers++;
    #####: 4593:                } else if(block->type == MD_BLOCK_QUOTE) {
        -: 4594:                    /* This causes that any text in a block quote, even if
        -: 4595:                     * nested inside a tight list item, is wrapped with
        -: 4596:                     * <p>...</p>. */
    #####: 4597:                    ctx->containers[ctx->n_containers].is_loose = TRUE;
    #####: 4598:                    ctx->n_containers++;
        -: 4599:                }
        -: 4600:            }
        -: 4601:        } else {
    #####: 4602:            MD_CHECK(md_process_leaf_block(ctx, block));
        -: 4603:
    #####: 4604:            if(block->type == MD_BLOCK_CODE || block->type == MD_BLOCK_HTML)
    #####: 4605:                byte_off += block->n_lines * sizeof(MD_VERBATIMLINE);
        -: 4606:            else
    #####: 4607:                byte_off += block->n_lines * sizeof(MD_LINE);
        -: 4608:        }
        -: 4609:
    #####: 4610:        byte_off += sizeof(MD_BLOCK);
        -: 4611:    }
        -: 4612:
    #####: 4613:    ctx->n_block_bytes = 0;
        -: 4614:
    #####: 4615:abort:
    #####: 4616:    return ret;
        -: 4617:}
        -: 4618:
        -: 4619:
        -: 4620:/************************************
        -: 4621: ***  Grouping Lines into Blocks  ***
        -: 4622: ************************************/
        -: 4623:
        -: 4624:static void*
        4: 4625:md_push_block_bytes(MD_CTX* ctx, int n_bytes)
        -: 4626:{
        -: 4627:    void* ptr;
        -: 4628:
        4: 4629:    if(ctx->n_block_bytes + n_bytes > ctx->alloc_block_bytes) {
        -: 4630:        void* new_block_bytes;
        -: 4631:
        1: 4632:        ctx->alloc_block_bytes = (ctx->alloc_block_bytes > 0 ? ctx->alloc_block_bytes * 2 : 512);
        1: 4633:        new_block_bytes = realloc(ctx->block_bytes, ctx->alloc_block_bytes);
        1: 4634:        if(new_block_bytes == NULL) {
    #####: 4635:            MD_LOG("realloc() failed.");
        -: 4636:            return NULL;
        -: 4637:        }
        -: 4638:
        -: 4639:        /* Fix the ->current_block after the reallocation. */
        1: 4640:        if(ctx->current_block != NULL) {
    #####: 4641:            OFF off_current_block = (char*) ctx->current_block - (char*) ctx->block_bytes;
    #####: 4642:            ctx->current_block = (MD_BLOCK*) ((char*) new_block_bytes + off_current_block);
        -: 4643:        }
        -: 4644:
        1: 4645:        ctx->block_bytes = new_block_bytes;
        -: 4646:    }
        -: 4647:
        4: 4648:    ptr = (char*)ctx->block_bytes + ctx->n_block_bytes;
        4: 4649:    ctx->n_block_bytes += n_bytes;
        4: 4650:    return ptr;
        -: 4651:}
        -: 4652:
        -: 4653:static int
        2: 4654:md_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)
        -: 4655:{
        -: 4656:    MD_BLOCK* block;
        -: 4657:
        2: 4658:    MD_ASSERT(ctx->current_block == NULL);
        -: 4659:
        2: 4660:    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));
        2: 4661:    if(block == NULL)
        -: 4662:        return -1;
        -: 4663:
        1: 4664:    switch(line->type) {
    #####: 4665:        case MD_LINE_HR:
    #####: 4666:            block->type = MD_BLOCK_HR;
    #####: 4667:            break;
        -: 4668:
    #####: 4669:        case MD_LINE_ATXHEADER:
        -: 4670:        case MD_LINE_SETEXTHEADER:
    #####: 4671:            block->type = MD_BLOCK_H;
    #####: 4672:            break;
        -: 4673:
    #####: 4674:        case MD_LINE_FENCEDCODE:
        -: 4675:        case MD_LINE_INDENTEDCODE:
    #####: 4676:            block->type = MD_BLOCK_CODE;
    #####: 4677:            break;
        -: 4678:
        1: 4679:        case MD_LINE_TEXT:
        1: 4680:            block->type = MD_BLOCK_P;
        1: 4681:            break;
        -: 4682:
    #####: 4683:        case MD_LINE_HTML:
    #####: 4684:            block->type = MD_BLOCK_HTML;
    #####: 4685:            break;
        -: 4686:
    #####: 4687:        case MD_LINE_BLANK:
        -: 4688:        case MD_LINE_SETEXTUNDERLINE:
        -: 4689:        case MD_LINE_TABLEUNDERLINE:
        -: 4690:        default:
    #####: 4691:            MD_UNREACHABLE();
        -: 4692:            break;
        -: 4693:    }
        -: 4694:
        1: 4695:    block->flags = 0;
        1: 4696:    block->data = line->data;
        1: 4697:    block->n_lines = 0;
        -: 4698:
        1: 4699:    ctx->current_block = block;
        1: 4700:    return 0;
        -: 4701:}
        -: 4702:
        -: 4703:/* Eat from start of current (textual) block any reference definitions and
        -: 4704: * remember them so we can resolve any links referring to them.
        -: 4705: *
        -: 4706: * (Reference definitions can only be at start of it as they cannot break
        -: 4707: * a paragraph.)
        -: 4708: */
        -: 4709:static int
        1: 4710:md_consume_link_reference_definitions(MD_CTX* ctx)
        -: 4711:{
        1: 4712:    MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);
        1: 4713:    int n_lines = ctx->current_block->n_lines;
        1: 4714:    int n = 0;
        -: 4715:
        -: 4716:    /* Compute how many lines at the start of the block form one or more
        -: 4717:     * reference definitions. */
        3: 4718:    while(n < n_lines) {
        -: 4719:        int n_link_ref_lines;
        -: 4720:
        2: 4721:        n_link_ref_lines = md_is_link_reference_definition(ctx,
        1: 4722:                                    lines + n, n_lines - n);
        -: 4723:        /* Not a reference definition? */
        1: 4724:        if(n_link_ref_lines == 0)
        -: 4725:            break;
        -: 4726:
        -: 4727:        /* We fail if it is the ref. def. but it could not be stored due
        -: 4728:         * a memory allocation error. */
        1: 4729:        if(n_link_ref_lines < 0)
        -: 4730:            return -1;
        -: 4731:
        1: 4732:        n += n_link_ref_lines;
        -: 4733:    }
        -: 4734:
        -: 4735:    /* If there was at least one reference definition, we need to remove
        -: 4736:     * its lines from the block, or perhaps even the whole block. */
        1: 4737:    if(n > 0) {
        1: 4738:        if(n == n_lines) {
        -: 4739:            /* Remove complete block. */
        1: 4740:            ctx->n_block_bytes -= n * sizeof(MD_LINE);
        1: 4741:            ctx->n_block_bytes -= sizeof(MD_BLOCK);
        -: 4742:        } else {
        -: 4743:            /* Remove just some initial lines from the block. */
    #####: 4744:            memmove(lines, lines + n, (n_lines - n) * sizeof(MD_LINE));
    #####: 4745:            ctx->current_block->n_lines -= n;
    #####: 4746:            ctx->n_block_bytes -= n * sizeof(MD_LINE);
        -: 4747:        }
        -: 4748:    }
        -: 4749:
        -: 4750:    return 0;
        -: 4751:}
        -: 4752:
        -: 4753:static int
        3: 4754:md_end_current_block(MD_CTX* ctx)
        -: 4755:{
        3: 4756:    int ret = 0;
        -: 4757:
        3: 4758:    if(ctx->current_block == NULL)
        -: 4759:        return ret;
        -: 4760:
        -: 4761:    /* Check whether there is a reference definition. (We do this here instead
        -: 4762:     * of in md_analyze_line() because reference definition can take multiple
        -: 4763:     * lines.) */
        1: 4764:    if(ctx->current_block->type == MD_BLOCK_P  ||
        1: 4765:       (ctx->current_block->type == MD_BLOCK_H  &&  (ctx->current_block->flags & MD_BLOCK_SETEXT_HEADER)))
        -: 4766:    {
        1: 4767:        MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);
        1: 4768:        if(CH(lines[0].beg) == _T('[')) {
        1: 4769:            MD_CHECK(md_consume_link_reference_definitions(ctx));
        1: 4770:            if(ctx->current_block == NULL)
        -: 4771:                return ret;
        -: 4772:        }
        -: 4773:    }
        -: 4774:
        1: 4775:    if(ctx->current_block->type == MD_BLOCK_H  &&  (ctx->current_block->flags & MD_BLOCK_SETEXT_HEADER)) {
        1: 4776:        int n_lines = ctx->current_block->n_lines;
        -: 4777:
        1: 4778:        if(n_lines > 1) {
        -: 4779:            /* Get rid of the underline. */
        1: 4780:            ctx->current_block->n_lines--;
        1: 4781:            ctx->n_block_bytes -= sizeof(MD_LINE);
        -: 4782:        } else {
        -: 4783:            /* Only the underline has left after eating the ref. defs.
        -: 4784:             * Keep the line as beginning of a new ordinary paragraph. */
    #####: 4785:            ctx->current_block->type = MD_BLOCK_P;
    #####: 4786:            return 0;
        -: 4787:        }
        -: 4788:    }
        -: 4789:
        -: 4790:    /* Mark we are not building any block anymore. */
        1: 4791:    ctx->current_block = NULL;
        -: 4792:
    #####: 4793:abort:
        -: 4794:    return ret;
        -: 4795:}
        -: 4796:
        -: 4797:static int
        2: 4798:md_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)
        -: 4799:{
        2: 4800:    MD_ASSERT(ctx->current_block != NULL);
        -: 4801:
        2: 4802:    if(ctx->current_block->type == MD_BLOCK_CODE || ctx->current_block->type == MD_BLOCK_HTML) {
        -: 4803:        MD_VERBATIMLINE* line;
        -: 4804:
    #####: 4805:        line = (MD_VERBATIMLINE*) md_push_block_bytes(ctx, sizeof(MD_VERBATIMLINE));
    #####: 4806:        if(line == NULL)
        -: 4807:            return -1;
        -: 4808:
    #####: 4809:        line->indent = analysis->indent;
    #####: 4810:        line->beg = analysis->beg;
    #####: 4811:        line->end = analysis->end;
        -: 4812:    } else {
        -: 4813:        MD_LINE* line;
        -: 4814:
        2: 4815:        line = (MD_LINE*) md_push_block_bytes(ctx, sizeof(MD_LINE));
        2: 4816:        if(line == NULL)
        -: 4817:            return -1;
        -: 4818:
        2: 4819:        line->beg = analysis->beg;
        2: 4820:        line->end = analysis->end;
        -: 4821:    }
        2: 4822:    ctx->current_block->n_lines++;
        -: 4823:
        2: 4824:    return 0;
        -: 4825:}
        -: 4826:
        -: 4827:static int
    #####: 4828:md_push_container_bytes(MD_CTX* ctx, MD_BLOCKTYPE type, unsigned start,
        -: 4829:                        unsigned data, unsigned flags)
        -: 4830:{
        -: 4831:    MD_BLOCK* block;
    #####: 4832:    int ret = 0;
        -: 4833:
    #####: 4834:    MD_CHECK(md_end_current_block(ctx));
        -: 4835:
    #####: 4836:    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));
    #####: 4837:    if(block == NULL)
        -: 4838:        return -1;
        -: 4839:
    #####: 4840:    block->type = type;
    #####: 4841:    block->flags = flags;
    #####: 4842:    block->data = data;
    #####: 4843:    block->n_lines = start;
        -: 4844:
    #####: 4845:abort:
        -: 4846:    return ret;
        -: 4847:}
        -: 4848:
        -: 4849:
        -: 4850:
        -: 4851:/***********************
        -: 4852: ***  Line Analysis  ***
        -: 4853: ***********************/
        -: 4854:
        -: 4855:static int
    #####: 4856:md_is_hr_line(MD_CTX* ctx, OFF beg, OFF* p_end, OFF* p_killer)
        -: 4857:{
    #####: 4858:    OFF off = beg + 1;
    #####: 4859:    int n = 1;
        -: 4860:
    #####: 4861:    while(off < ctx->size  &&  (CH(off) == CH(beg) || CH(off) == _T(' ') || CH(off) == _T('\t'))) {
    #####: 4862:        if(CH(off) == CH(beg))
    #####: 4863:            n++;
    #####: 4864:        off++;
        -: 4865:    }
        -: 4866:
    #####: 4867:    if(n < 3) {
    #####: 4868:        *p_killer = off;
        -: 4869:        return FALSE;
        -: 4870:    }
        -: 4871:
        -: 4872:    /* Nothing else can be present on the line. */
    #####: 4873:    if(off < ctx->size  &&  !ISNEWLINE(off)) {
    #####: 4874:        *p_killer = off;
        -: 4875:        return FALSE;
        -: 4876:    }
        -: 4877:
    #####: 4878:    *p_end = off;
        -: 4879:    return TRUE;
        -: 4880:}
        -: 4881:
        -: 4882:static int
    #####: 4883:md_is_atxheader_line(MD_CTX* ctx, OFF beg, OFF* p_beg, OFF* p_end, unsigned* p_level)
        -: 4884:{
        -: 4885:    int n;
    #####: 4886:    OFF off = beg + 1;
        -: 4887:
    #####: 4888:    while(off < ctx->size  &&  CH(off) == _T('#')  &&  off - beg < 7)
    #####: 4889:        off++;
    #####: 4890:    n = off - beg;
        -: 4891:
    #####: 4892:    if(n > 6)
        -: 4893:        return FALSE;
    #####: 4894:    *p_level = n;
        -: 4895:
    #####: 4896:    if(!(ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS)  &&  off < ctx->size  &&
    #####: 4897:       CH(off) != _T(' ')  &&  CH(off) != _T('\t')  &&  !ISNEWLINE(off))
        -: 4898:        return FALSE;
        -: 4899:
    #####: 4900:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4901:        off++;
    #####: 4902:    *p_beg = off;
    #####: 4903:    *p_end = off;
    #####: 4904:    return TRUE;
        -: 4905:}
        -: 4906:
        -: 4907:static int
        1: 4908:md_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)
        -: 4909:{
        1: 4910:    OFF off = beg + 1;
        -: 4911:
        1: 4912:    while(off < ctx->size  &&  CH(off) == CH(beg))
    #####: 4913:        off++;
        -: 4914:
        -: 4915:    /* Optionally, space(s) can follow. */
        1: 4916:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4917:        off++;
        -: 4918:
        -: 4919:    /* But nothing more is allowed on the line. */
        1: 4920:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4921:        return FALSE;
        -: 4922:
        1: 4923:    *p_level = (CH(beg) == _T('=') ? 1 : 2);
        1: 4924:    *p_end = off;
        -: 4925:    return TRUE;
        -: 4926:}
        -: 4927:
        -: 4928:static int
    #####: 4929:md_is_table_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_col_count)
        -: 4930:{
    #####: 4931:    OFF off = beg;
    #####: 4932:    int found_pipe = FALSE;
    #####: 4933:    unsigned col_count = 0;
        -: 4934:
    #####: 4935:    if(off < ctx->size  &&  CH(off) == _T('|')) {
    #####: 4936:        found_pipe = TRUE;
    #####: 4937:        off++;
    #####: 4938:        while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4939:            off++;
        -: 4940:    }
        -: 4941:
        -: 4942:    while(1) {
        -: 4943:        OFF cell_beg;
    #####: 4944:        int delimited = FALSE;
        -: 4945:
        -: 4946:        /* Cell underline ("-----", ":----", "----:" or ":----:") */
    #####: 4947:        cell_beg = off;
    #####: 4948:        if(off < ctx->size  &&  CH(off) == _T(':'))
    #####: 4949:            off++;
    #####: 4950:        while(off < ctx->size  &&  CH(off) == _T('-'))
    #####: 4951:            off++;
    #####: 4952:        if(off < ctx->size  &&  CH(off) == _T(':'))
    #####: 4953:            off++;
    #####: 4954:        if(off - cell_beg < 3)
        -: 4955:            return FALSE;
        -: 4956:
    #####: 4957:        col_count++;
        -: 4958:
        -: 4959:        /* Pipe delimiter (optional at the end of line). */
    #####: 4960:        while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4961:            off++;
    #####: 4962:        if(off < ctx->size  &&  CH(off) == _T('|')) {
    #####: 4963:            delimited = TRUE;
    #####: 4964:            found_pipe =  TRUE;
    #####: 4965:            off++;
    #####: 4966:            while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4967:                off++;
        -: 4968:        }
        -: 4969:
        -: 4970:        /* Success, if we reach end of line. */
    #####: 4971:        if(off >= ctx->size  ||  ISNEWLINE(off))
        -: 4972:            break;
        -: 4973:
    #####: 4974:        if(!delimited)
        -: 4975:            return FALSE;
        -: 4976:    }
        -: 4977:
    #####: 4978:    if(!found_pipe)
        -: 4979:        return FALSE;
        -: 4980:
    #####: 4981:    *p_end = off;
    #####: 4982:    *p_col_count = col_count;
        -: 4983:    return TRUE;
        -: 4984:}
        -: 4985:
        -: 4986:static int
    #####: 4987:md_is_opening_code_fence(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 4988:{
    #####: 4989:    OFF off = beg;
        -: 4990:
    #####: 4991:    while(off < ctx->size && CH(off) == CH(beg))
    #####: 4992:        off++;
        -: 4993:
        -: 4994:    /* Fence must have at least three characters. */
    #####: 4995:    if(off - beg < 3)
        -: 4996:        return FALSE;
        -: 4997:
    #####: 4998:    ctx->code_fence_length = off - beg;
        -: 4999:
        -: 5000:    /* Optionally, space(s) can follow. */
    #####: 5001:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 5002:        off++;
        -: 5003:
        -: 5004:    /* Optionally, an info string can follow. */
    #####: 5005:    while(off < ctx->size  &&  !ISNEWLINE(off)) {
        -: 5006:        /* Backtick-based fence must not contain '`' in the info string. */
    #####: 5007:        if(CH(beg) == _T('`')  &&  CH(off) == _T('`'))
        -: 5008:            return FALSE;
    #####: 5009:        off++;
        -: 5010:    }
        -: 5011:
    #####: 5012:    *p_end = off;
    #####: 5013:    return TRUE;
        -: 5014:}
        -: 5015:
        -: 5016:static int
    #####: 5017:md_is_closing_code_fence(MD_CTX* ctx, CHAR ch, OFF beg, OFF* p_end)
        -: 5018:{
    #####: 5019:    OFF off = beg;
    #####: 5020:    int ret = FALSE;
        -: 5021:
        -: 5022:    /* Closing fence must have at least the same length and use same char as
        -: 5023:     * opening one. */
    #####: 5024:    while(off < ctx->size  &&  CH(off) == ch)
    #####: 5025:        off++;
    #####: 5026:    if(off - beg < ctx->code_fence_length)
        -: 5027:        goto out;
        -: 5028:
        -: 5029:    /* Optionally, space(s) can follow */
    #####: 5030:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 5031:        off++;
        -: 5032:
        -: 5033:    /* But nothing more is allowed on the line. */
    #####: 5034:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 5035:        goto out;
        -: 5036:
    #####: 5037:    ret = TRUE;
        -: 5038:
    #####: 5039:out:
        -: 5040:    /* Note we set *p_end even on failure: If we are not closing fence, caller
        -: 5041:     * would eat the line anyway without any parsing. */
    #####: 5042:    *p_end = off;
    #####: 5043:    return ret;
        -: 5044:}
        -: 5045:
        -: 5046:/* Returns type of the raw HTML block, or FALSE if it is not HTML block.
        -: 5047: * (Refer to CommonMark specification for details about the types.)
        -: 5048: */
        -: 5049:static int
    #####: 5050:md_is_html_block_start_condition(MD_CTX* ctx, OFF beg)
        -: 5051:{
        -: 5052:    typedef struct TAG_tag TAG;
        -: 5053:    struct TAG_tag {
        -: 5054:        const CHAR* name;
        -: 5055:        unsigned len    : 8;
        -: 5056:    };
        -: 5057:
        -: 5058:    /* Type 6 is started by a long list of allowed tags. We use two-level
        -: 5059:     * tree to speed-up the search. */
        -: 5060:#ifdef X
        -: 5061:    #undef X
        -: 5062:#endif
        -: 5063:#define X(name)     { _T(name), sizeof(name)-1 }
        -: 5064:#define Xend        { NULL, 0 }
        -: 5065:    static const TAG t1[] = { X("script"), X("pre"), X("style"), Xend };
        -: 5066:
        -: 5067:    static const TAG a6[] = { X("address"), X("article"), X("aside"), Xend };
        -: 5068:    static const TAG b6[] = { X("base"), X("basefont"), X("blockquote"), X("body"), Xend };
        -: 5069:    static const TAG c6[] = { X("caption"), X("center"), X("col"), X("colgroup"), Xend };
        -: 5070:    static const TAG d6[] = { X("dd"), X("details"), X("dialog"), X("dir"),
        -: 5071:                              X("div"), X("dl"), X("dt"), Xend };
        -: 5072:    static const TAG f6[] = { X("fieldset"), X("figcaption"), X("figure"), X("footer"),
        -: 5073:                              X("form"), X("frame"), X("frameset"), Xend };
        -: 5074:    static const TAG h6[] = { X("h1"), X("head"), X("header"), X("hr"), X("html"), Xend };
        -: 5075:    static const TAG i6[] = { X("iframe"), Xend };
        -: 5076:    static const TAG l6[] = { X("legend"), X("li"), X("link"), Xend };
        -: 5077:    static const TAG m6[] = { X("main"), X("menu"), X("menuitem"), Xend };
        -: 5078:    static const TAG n6[] = { X("nav"), X("noframes"), Xend };
        -: 5079:    static const TAG o6[] = { X("ol"), X("optgroup"), X("option"), Xend };
        -: 5080:    static const TAG p6[] = { X("p"), X("param"), Xend };
        -: 5081:    static const TAG s6[] = { X("section"), X("source"), X("summary"), Xend };
        -: 5082:    static const TAG t6[] = { X("table"), X("tbody"), X("td"), X("tfoot"), X("th"),
        -: 5083:                              X("thead"), X("title"), X("tr"), X("track"), Xend };
        -: 5084:    static const TAG u6[] = { X("ul"), Xend };
        -: 5085:    static const TAG xx[] = { Xend };
        -: 5086:#undef X
        -: 5087:
        -: 5088:    static const TAG* map6[26] = {
        -: 5089:        a6, b6, c6, d6, xx, f6, xx, h6, i6, xx, xx, l6, m6,
        -: 5090:        n6, o6, p6, xx, xx, s6, t6, u6, xx, xx, xx, xx, xx
        -: 5091:    };
    #####: 5092:    OFF off = beg + 1;
        -: 5093:    int i;
        -: 5094:
        -: 5095:    /* Check for type 1: <script, <pre, or <style */
    #####: 5096:    for(i = 0; t1[i].name != NULL; i++) {
    #####: 5097:        if(off + t1[i].len <= ctx->size) {
    #####: 5098:            if(md_ascii_case_eq(STR(off), t1[i].name, t1[i].len))
        -: 5099:                return 1;
        -: 5100:        }
        -: 5101:    }
        -: 5102:
        -: 5103:    /* Check for type 2: <!-- */
    #####: 5104:    if(off + 3 < ctx->size  &&  CH(off) == _T('!')  &&  CH(off+1) == _T('-')  &&  CH(off+2) == _T('-'))
        -: 5105:        return 2;
        -: 5106:
        -: 5107:    /* Check for type 3: <? */
    #####: 5108:    if(off < ctx->size  &&  CH(off) == _T('?'))
        -: 5109:        return 3;
        -: 5110:
        -: 5111:    /* Check for type 4 or 5: <! */
    #####: 5112:    if(off < ctx->size  &&  CH(off) == _T('!')) {
        -: 5113:        /* Check for type 4: <! followed by uppercase letter. */
    #####: 5114:        if(off + 1 < ctx->size  &&  ISUPPER(off+1))
        -: 5115:            return 4;
        -: 5116:
        -: 5117:        /* Check for type 5: <![CDATA[ */
    #####: 5118:        if(off + 8 < ctx->size) {
    #####: 5119:            if(md_ascii_eq(STR(off), _T("![CDATA["), 8 * sizeof(CHAR)))
        -: 5120:                return 5;
        -: 5121:        }
        -: 5122:    }
        -: 5123:
        -: 5124:    /* Check for type 6: Many possible starting tags listed above. */
    #####: 5125:    if(off + 1 < ctx->size  &&  (ISALPHA(off) || (CH(off) == _T('/') && ISALPHA(off+1)))) {
        -: 5126:        int slot;
        -: 5127:        const TAG* tags;
        -: 5128:
    #####: 5129:        if(CH(off) == _T('/'))
    #####: 5130:            off++;
        -: 5131:
    #####: 5132:        slot = (ISUPPER(off) ? CH(off) - 'A' : CH(off) - 'a');
    #####: 5133:        tags = map6[slot];
        -: 5134:
    #####: 5135:        for(i = 0; tags[i].name != NULL; i++) {
    #####: 5136:            if(off + tags[i].len <= ctx->size) {
    #####: 5137:                if(md_ascii_case_eq(STR(off), tags[i].name, tags[i].len)) {
    #####: 5138:                    OFF tmp = off + tags[i].len;
    #####: 5139:                    if(tmp >= ctx->size)
        -: 5140:                        return 6;
    #####: 5141:                    if(ISBLANK(tmp) || ISNEWLINE(tmp) || CH(tmp) == _T('>'))
        -: 5142:                        return 6;
    #####: 5143:                    if(tmp+1 < ctx->size && CH(tmp) == _T('/') && CH(tmp+1) == _T('>'))
        -: 5144:                        return 6;
        -: 5145:                    break;
        -: 5146:                }
        -: 5147:            }
        -: 5148:        }
        -: 5149:    }
        -: 5150:
        -: 5151:    /* Check for type 7: any COMPLETE other opening or closing tag. */
    #####: 5152:    if(off + 1 < ctx->size) {
    #####: 5153:        OFF end;
        -: 5154:
    #####: 5155:        if(md_is_html_tag(ctx, NULL, 0, beg, ctx->size, &end)) {
        -: 5156:            /* Only optional whitespace and new line may follow. */
    #####: 5157:            while(end < ctx->size  &&  ISWHITESPACE(end))
    #####: 5158:                end++;
    #####: 5159:            if(end >= ctx->size  ||  ISNEWLINE(end))
    #####: 5160:                return 7;
        -: 5161:        }
        -: 5162:    }
        -: 5163:
        -: 5164:    return FALSE;
        -: 5165:}
        -: 5166:
        -: 5167:/* Case sensitive check whether there is a substring 'what' between 'beg'
        -: 5168: * and end of line. */
        -: 5169:static int
    #####: 5170:md_line_contains(MD_CTX* ctx, OFF beg, const CHAR* what, SZ what_len, OFF* p_end)
        -: 5171:{
        -: 5172:    OFF i;
    #####: 5173:    for(i = beg; i + what_len < ctx->size; i++) {
    #####: 5174:        if(ISNEWLINE(i))
        -: 5175:            break;
    #####: 5176:        if(memcmp(STR(i), what, what_len * sizeof(CHAR)) == 0) {
    #####: 5177:            *p_end = i + what_len;
        -: 5178:            return TRUE;
        -: 5179:        }
        -: 5180:    }
        -: 5181:
    #####: 5182:    *p_end = i;
        -: 5183:    return FALSE;
        -: 5184:}
        -: 5185:
        -: 5186:/* Returns type of HTML block end condition or FALSE if not an end condition.
        -: 5187: *
        -: 5188: * Note it fills p_end even when it is not end condition as the caller
        -: 5189: * does not need to analyze contents of a raw HTML block.
        -: 5190: */
        -: 5191:static int
    #####: 5192:md_is_html_block_end_condition(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 5193:{
    #####: 5194:    switch(ctx->html_block_type) {
        -: 5195:        case 1:
        -: 5196:        {
        -: 5197:            OFF off = beg;
        -: 5198:
    #####: 5199:            while(off < ctx->size  &&  !ISNEWLINE(off)) {
    #####: 5200:                if(CH(off) == _T('<')) {
    #####: 5201:                    if(md_ascii_case_eq(STR(off), _T("</script>"), 9)) {
    #####: 5202:                        *p_end = off + 9;
    #####: 5203:                        return TRUE;
        -: 5204:                    }
        -: 5205:
    #####: 5206:                    if(md_ascii_case_eq(STR(off), _T("</style>"), 8)) {
    #####: 5207:                        *p_end = off + 8;
    #####: 5208:                        return TRUE;
        -: 5209:                    }
        -: 5210:
    #####: 5211:                    if(md_ascii_case_eq(STR(off), _T("</pre>"), 6)) {
    #####: 5212:                        *p_end = off + 6;
    #####: 5213:                        return TRUE;
        -: 5214:                    }
        -: 5215:                }
        -: 5216:
    #####: 5217:                off++;
        -: 5218:            }
    #####: 5219:            *p_end = off;
    #####: 5220:            return FALSE;
        -: 5221:        }
        -: 5222:
    #####: 5223:        case 2:
    #####: 5224:            return (md_line_contains(ctx, beg, _T("-->"), 3, p_end) ? 2 : FALSE);
        -: 5225:
    #####: 5226:        case 3:
    #####: 5227:            return (md_line_contains(ctx, beg, _T("?>"), 2, p_end) ? 3 : FALSE);
        -: 5228:
    #####: 5229:        case 4:
    #####: 5230:            return (md_line_contains(ctx, beg, _T(">"), 1, p_end) ? 4 : FALSE);
        -: 5231:
    #####: 5232:        case 5:
    #####: 5233:            return (md_line_contains(ctx, beg, _T("]]>"), 3, p_end) ? 5 : FALSE);
        -: 5234:
    #####: 5235:        case 6:     /* Pass through */
        -: 5236:        case 7:
    #####: 5237:            *p_end = beg;
    #####: 5238:            return (ISNEWLINE(beg) ? ctx->html_block_type : FALSE);
        -: 5239:
    #####: 5240:        default:
    #####: 5241:            MD_UNREACHABLE();
        -: 5242:    }
        -: 5243:    return FALSE;
        -: 5244:}
        -: 5245:
        -: 5246:
        -: 5247:static int
        -: 5248:md_is_container_compatible(const MD_CONTAINER* pivot, const MD_CONTAINER* container)
        -: 5249:{
        -: 5250:    /* Block quote has no "items" like lists. */
    #####: 5251:    if(container->ch == _T('>'))
        -: 5252:        return FALSE;
        -: 5253:
    #####: 5254:    if(container->ch != pivot->ch)
        -: 5255:        return FALSE;
    #####: 5256:    if(container->mark_indent > pivot->contents_indent)
        -: 5257:        return FALSE;
        -: 5258:
        -: 5259:    return TRUE;
        -: 5260:}
        -: 5261:
        -: 5262:static int
    #####: 5263:md_push_container(MD_CTX* ctx, const MD_CONTAINER* container)
        -: 5264:{
    #####: 5265:    if(ctx->n_containers >= ctx->alloc_containers) {
        -: 5266:        MD_CONTAINER* new_containers;
        -: 5267:
    #####: 5268:        ctx->alloc_containers = (ctx->alloc_containers > 0 ? ctx->alloc_containers * 2 : 16);
    #####: 5269:        new_containers = realloc(ctx->containers, ctx->alloc_containers * sizeof(MD_CONTAINER));
    #####: 5270:        if(new_containers == NULL) {
    #####: 5271:            MD_LOG("realloc() failed.");
        -: 5272:            return -1;
        -: 5273:        }
        -: 5274:
    #####: 5275:        ctx->containers = new_containers;
        -: 5276:    }
        -: 5277:
    #####: 5278:    memcpy(&ctx->containers[ctx->n_containers++], container, sizeof(MD_CONTAINER));
    #####: 5279:    return 0;
        -: 5280:}
        -: 5281:
        -: 5282:static int
    #####: 5283:md_enter_child_containers(MD_CTX* ctx, int n_children, unsigned data)
        -: 5284:{
        -: 5285:    int i;
    #####: 5286:    int ret = 0;
        -: 5287:
    #####: 5288:    for(i = ctx->n_containers - n_children; i < ctx->n_containers; i++) {
    #####: 5289:        MD_CONTAINER* c = &ctx->containers[i];
    #####: 5290:        int is_ordered_list = FALSE;
        -: 5291:
    #####: 5292:        switch(c->ch) {
        -: 5293:            case _T(')'):
        -: 5294:            case _T('.'):
        -: 5295:                is_ordered_list = TRUE;
        -: 5296:                /* Pass through */
        -: 5297:
    #####: 5298:            case _T('-'):
        -: 5299:            case _T('+'):
        -: 5300:            case _T('*'):
        -: 5301:                /* Remember offset in ctx->block_bytes so we can revisit the
        -: 5302:                 * block if we detect it is a loose list. */
    #####: 5303:                md_end_current_block(ctx);
    #####: 5304:                c->block_byte_off = ctx->n_block_bytes;
        -: 5305:
    #####: 5306:                MD_CHECK(md_push_container_bytes(ctx,
        -: 5307:                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL),
        -: 5308:                                c->start, data, MD_BLOCK_CONTAINER_OPENER));
    #####: 5309:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,
        -: 5310:                                c->task_mark_off,
        -: 5311:                                (c->is_task ? CH(c->task_mark_off) : 0),
        -: 5312:                                MD_BLOCK_CONTAINER_OPENER));
        -: 5313:                break;
        -: 5314:
    #####: 5315:            case _T('>'):
    #####: 5316:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0, 0, MD_BLOCK_CONTAINER_OPENER));
        -: 5317:                break;
        -: 5318:
    #####: 5319:            default:
    #####: 5320:                MD_UNREACHABLE();
        -: 5321:                break;
        -: 5322:        }
        -: 5323:    }
        -: 5324:
    #####: 5325:abort:
    #####: 5326:    return ret;
        -: 5327:}
        -: 5328:
        -: 5329:static int
    #####: 5330:md_leave_child_containers(MD_CTX* ctx, int n_keep)
        -: 5331:{
    #####: 5332:    int ret = 0;
        -: 5333:
    #####: 5334:    while(ctx->n_containers > n_keep) {
    #####: 5335:        MD_CONTAINER* c = &ctx->containers[ctx->n_containers-1];
    #####: 5336:        int is_ordered_list = FALSE;
        -: 5337:
    #####: 5338:        switch(c->ch) {
        -: 5339:            case _T(')'):
        -: 5340:            case _T('.'):
        -: 5341:                is_ordered_list = TRUE;
        -: 5342:                /* Pass through */
        -: 5343:
    #####: 5344:            case _T('-'):
        -: 5345:            case _T('+'):
        -: 5346:            case _T('*'):
    #####: 5347:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,
        -: 5348:                                c->task_mark_off, (c->is_task ? CH(c->task_mark_off) : 0),
        -: 5349:                                MD_BLOCK_CONTAINER_CLOSER));
    #####: 5350:                MD_CHECK(md_push_container_bytes(ctx,
        -: 5351:                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL), 0,
        -: 5352:                                c->ch, MD_BLOCK_CONTAINER_CLOSER));
        -: 5353:                break;
        -: 5354:
    #####: 5355:            case _T('>'):
    #####: 5356:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0,
        -: 5357:                                0, MD_BLOCK_CONTAINER_CLOSER));
        -: 5358:                break;
        -: 5359:
    #####: 5360:            default:
    #####: 5361:                MD_UNREACHABLE();
        -: 5362:                break;
        -: 5363:        }
        -: 5364:
    #####: 5365:        ctx->n_containers--;
        -: 5366:    }
        -: 5367:
    #####: 5368:abort:
    #####: 5369:    return ret;
        -: 5370:}
        -: 5371:
        -: 5372:static int
        1: 5373:md_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)
        -: 5374:{
        1: 5375:    OFF off = beg;
        -: 5376:    OFF max_end;
        -: 5377:
        1: 5378:    if(indent >= ctx->code_indent_offset)
        -: 5379:        return FALSE;
        -: 5380:
        -: 5381:    /* Check for block quote mark. */
        1: 5382:    if(off < ctx->size  &&  CH(off) == _T('>')) {
    #####: 5383:        off++;
    #####: 5384:        p_container->ch = _T('>');
    #####: 5385:        p_container->is_loose = FALSE;
    #####: 5386:        p_container->is_task = FALSE;
    #####: 5387:        p_container->mark_indent = indent;
    #####: 5388:        p_container->contents_indent = indent + 1;
    #####: 5389:        *p_end = off;
        -: 5390:        return TRUE;
        -: 5391:    }
        -: 5392:
        -: 5393:    /* Check for list item bullet mark. */
        2: 5394:    if(off+1 < ctx->size  &&  ISANYOF(off, _T("-+*"))  &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {
    #####: 5395:        p_container->ch = CH(off);
    #####: 5396:        p_container->is_loose = FALSE;
    #####: 5397:        p_container->is_task = FALSE;
    #####: 5398:        p_container->mark_indent = indent;
    #####: 5399:        p_container->contents_indent = indent + 1;
    #####: 5400:        *p_end = off + 1;
        -: 5401:        return TRUE;
        -: 5402:    }
        -: 5403:
        -: 5404:    /* Check for ordered list item marks. */
        1: 5405:    max_end = off + 9;
        1: 5406:    if(max_end > ctx->size)
    #####: 5407:        max_end = ctx->size;
        1: 5408:    p_container->start = 0;
        1: 5409:    while(off < max_end  &&  ISDIGIT(off)) {
    #####: 5410:        p_container->start = p_container->start * 10 + CH(off) - _T('0');
    #####: 5411:        off++;
        -: 5412:    }
        1: 5413:    if(off+1 < ctx->size  &&  (CH(off) == _T('.') || CH(off) == _T(')'))   &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {
    #####: 5414:        p_container->ch = CH(off);
    #####: 5415:        p_container->is_loose = FALSE;
    #####: 5416:        p_container->is_task = FALSE;
    #####: 5417:        p_container->mark_indent = indent;
    #####: 5418:        p_container->contents_indent = indent + off - beg + 1;
    #####: 5419:        *p_end = off + 1;
        -: 5420:        return TRUE;
        -: 5421:    }
        -: 5422:
        -: 5423:    return FALSE;
        -: 5424:}
        -: 5425:
        -: 5426:static unsigned
        -: 5427:md_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)
        -: 5428:{
        -: 5429:    OFF off = beg;
        -: 5430:    unsigned indent = total_indent;
        -: 5431:
        7: 5432:    while(off < ctx->size  &&  ISBLANK(off)) {
        4: 5433:        if(CH(off) == _T('\t'))
    #####: 5434:            indent = (indent + 4) & ~3;
        -: 5435:        else
        4: 5436:            indent++;
        4: 5437:        off++;
        -: 5438:    }
        -: 5439:
        3: 5440:    *p_end = off;
    #####: 5441:    return indent - total_indent;
        -: 5442:}
        -: 5443:
        -: 5444:static const MD_LINE_ANALYSIS md_dummy_blank_line = { MD_LINE_BLANK, 0 };
        -: 5445:
        -: 5446:/* Analyze type of the line and find some its properties. This serves as a
        -: 5447: * main input for determining type and boundaries of a block. */
        -: 5448:static int
        3: 5449:md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,
        -: 5450:                const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)
        -: 5451:{
        3: 5452:    unsigned total_indent = 0;
        3: 5453:    int n_parents = 0;
        3: 5454:    int n_brothers = 0;
        3: 5455:    int n_children = 0;
        3: 5456:    MD_CONTAINER container = { 0 };
        3: 5457:    int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;
        3: 5458:    OFF off = beg;
        3: 5459:    OFF hr_killer = 0;
        3: 5460:    int ret = 0;
        -: 5461:
        6: 5462:    line->indent = md_line_indentation(ctx, total_indent, off, &off);
        3: 5463:    total_indent += line->indent;
        3: 5464:    line->beg = off;
        -: 5465:
        -: 5466:    /* Given the indentation and block quote marks '>', determine how many of
        -: 5467:     * the current containers are our parents. */
        6: 5468:    while(n_parents < ctx->n_containers) {
    #####: 5469:        MD_CONTAINER* c = &ctx->containers[n_parents];
        -: 5470:
    #####: 5471:        if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&
    #####: 5472:            off < ctx->size  &&  CH(off) == _T('>'))
        -: 5473:        {
        -: 5474:            /* Block quote mark. */
    #####: 5475:            off++;
    #####: 5476:            total_indent++;
    #####: 5477:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
    #####: 5478:            total_indent += line->indent;
        -: 5479:
        -: 5480:            /* The optional 1st space after '>' is part of the block quote mark. */
    #####: 5481:            if(line->indent > 0)
    #####: 5482:                line->indent--;
        -: 5483:
    #####: 5484:            line->beg = off;
    #####: 5485:        } else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {
        -: 5486:            /* List. */
    #####: 5487:            line->indent -= c->contents_indent;
        -: 5488:        } else {
        -: 5489:            break;
        -: 5490:        }
        -: 5491:
    #####: 5492:        n_parents++;
        -: 5493:    }
        -: 5494:
        3: 5495:redo:
        -: 5496:    /* Check whether we are fenced code continuation. */
        3: 5497:    if(pivot_line->type == MD_LINE_FENCEDCODE) {
    #####: 5498:        line->beg = off;
        -: 5499:
        -: 5500:        /* We are another MD_LINE_FENCEDCODE unless we are closing fence
        -: 5501:         * which we transform into MD_LINE_BLANK. */
    #####: 5502:        if(line->indent < ctx->code_indent_offset) {
    #####: 5503:            if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {
    #####: 5504:                line->type = MD_LINE_BLANK;
    #####: 5505:                ctx->last_line_has_list_loosening_effect = FALSE;
    #####: 5506:                goto done;
        -: 5507:            }
        -: 5508:        }
        -: 5509:
    #####: 5510:        if(off >= ctx->size  ||  ISNEWLINE(off)) {
        -: 5511:            /* Blank line does not need any real indentation to be nested inside
        -: 5512:             * a list. */
    #####: 5513:            if(n_brothers + n_children == 0) {
    #####: 5514:                while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))
    #####: 5515:                    n_parents++;
        -: 5516:            }
        -: 5517:        }
        -: 5518:
        -: 5519:        /* Change indentation accordingly to the initial code fence. */
    #####: 5520:        if(n_parents == ctx->n_containers) {
    #####: 5521:            if(line->indent > pivot_line->indent)
    #####: 5522:                line->indent -= pivot_line->indent;
        -: 5523:            else
    #####: 5524:                line->indent = 0;
        -: 5525:
    #####: 5526:            line->type = MD_LINE_FENCEDCODE;
    #####: 5527:            goto done;
        -: 5528:        }
        -: 5529:    }
        -: 5530:
        -: 5531:    /* Check whether we are HTML block continuation. */
        3: 5532:    if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {
        -: 5533:        int html_block_type;
        -: 5534:
    #####: 5535:        html_block_type = md_is_html_block_end_condition(ctx, off, &off);
    #####: 5536:        if(html_block_type > 0) {
    #####: 5537:            MD_ASSERT(html_block_type == ctx->html_block_type);
        -: 5538:
        -: 5539:            /* Make sure this is the last line of the block. */
    #####: 5540:            ctx->html_block_type = 0;
        -: 5541:
        -: 5542:            /* Some end conditions serve as blank lines at the same time. */
    #####: 5543:            if(html_block_type == 6 || html_block_type == 7) {
    #####: 5544:                line->type = MD_LINE_BLANK;
    #####: 5545:                line->indent = 0;
    #####: 5546:                goto done;
        -: 5547:            }
        -: 5548:        }
        -: 5549:
    #####: 5550:        if(n_parents == ctx->n_containers) {
    #####: 5551:            line->type = MD_LINE_HTML;
    #####: 5552:            goto done;
        -: 5553:        }
        -: 5554:    }
        -: 5555:
        -: 5556:    /* Check for blank line. */
        3: 5557:    if(off >= ctx->size  ||  ISNEWLINE(off)) {
        -: 5558:        /* Blank line does not need any real indentation to be nested inside
        -: 5559:         * a list. */
    #####: 5560:        if(n_brothers + n_children == 0) {
    #####: 5561:            while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))
    #####: 5562:                n_parents++;
        -: 5563:        }
        -: 5564:
    #####: 5565:        if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {
    #####: 5566:            line->type = MD_LINE_INDENTEDCODE;
    #####: 5567:            if(line->indent > ctx->code_indent_offset)
    #####: 5568:                line->indent -= ctx->code_indent_offset;
        -: 5569:            else
    #####: 5570:                line->indent = 0;
    #####: 5571:            ctx->last_line_has_list_loosening_effect = FALSE;
        -: 5572:        } else {
    #####: 5573:            line->type = MD_LINE_BLANK;
    #####: 5574:            ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&
    #####: 5575:                    n_brothers + n_children == 0  &&
    #####: 5576:                    ctx->containers[n_parents-1].ch != _T('>'));
        -: 5577:
        -: 5578:#if 1
        -: 5579:            /* See https://github.com/mity/md4c/issues/6
        -: 5580:             *
        -: 5581:             * This ugly checking tests we are in (yet empty) list item but not
        -: 5582:             * its very first line (with the list item mark).
        -: 5583:             *
        -: 5584:             * If we are such blank line, then any following non-blank line
        -: 5585:             * which would be part of this list item actually ends the list
        -: 5586:             * because "a list item can begin with at most one blank line."
        -: 5587:             */
    #####: 5588:            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
    #####: 5589:               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
    #####: 5590:               ctx->n_block_bytes > sizeof(MD_BLOCK))
        -: 5591:            {
    #####: 5592:                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
    #####: 5593:                if(top_block->type == MD_BLOCK_LI)
    #####: 5594:                    ctx->last_list_item_starts_with_two_blank_lines = TRUE;
        -: 5595:            }
        -: 5596:#endif
        -: 5597:        }
        -: 5598:        goto done_on_eol;
        -: 5599:    } else {
        -: 5600:#if 1
        -: 5601:        /* This is 2nd half of the hack. If the flag is set (that is there
        -: 5602:         * were 2nd blank line at the start of the list item) and we would also
        -: 5603:         * belonging to such list item, then interrupt the list. */
        3: 5604:        ctx->last_line_has_list_loosening_effect = FALSE;
        3: 5605:        if(ctx->last_list_item_starts_with_two_blank_lines) {
    #####: 5606:            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
    #####: 5607:               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
    #####: 5608:               ctx->n_block_bytes > sizeof(MD_BLOCK))
        -: 5609:            {
    #####: 5610:                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
    #####: 5611:                if(top_block->type == MD_BLOCK_LI)
    #####: 5612:                    n_parents--;
        -: 5613:            }
        -: 5614:
    #####: 5615:            ctx->last_list_item_starts_with_two_blank_lines = FALSE;
        -: 5616:        }
        -: 5617:#endif
        -: 5618:    }
        -: 5619:
        -: 5620:    /* Check whether we are Setext underline. */
        3: 5621:    if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT
        1: 5622:        &&  (CH(off) == _T('=') || CH(off) == _T('-'))
        1: 5623:        &&  (n_parents == ctx->n_containers))
        -: 5624:    {
        1: 5625:        unsigned level;
        -: 5626:
        1: 5627:        if(md_is_setext_underline(ctx, off, &off, &level)) {
        1: 5628:            line->type = MD_LINE_SETEXTUNDERLINE;
        1: 5629:            line->data = level;
        1: 5630:            goto done;
        -: 5631:        }
        -: 5632:    }
        -: 5633:
        -: 5634:    /* Check for thematic break line. */
        3: 5635:    if(line->indent < ctx->code_indent_offset  &&  ISANYOF(off, _T("-_*"))  &&  off >= hr_killer) {
    #####: 5636:        if(md_is_hr_line(ctx, off, &off, &hr_killer)) {
    #####: 5637:            line->type = MD_LINE_HR;
    #####: 5638:            goto done;
        -: 5639:        }
        -: 5640:    }
        -: 5641:
        -: 5642:    /* Check for "brother" container. I.e. whether we are another list item
        -: 5643:     * in already started list. */
        2: 5644:    if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {
    #####: 5645:        OFF tmp;
        -: 5646:
    #####: 5647:        if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&
    #####: 5648:           md_is_container_compatible(&ctx->containers[n_parents], &container))
        -: 5649:        {
    #####: 5650:            pivot_line = &md_dummy_blank_line;
        -: 5651:
    #####: 5652:            off = tmp;
        -: 5653:
    #####: 5654:            total_indent += container.contents_indent - container.mark_indent;
    #####: 5655:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
    #####: 5656:            total_indent += line->indent;
    #####: 5657:            line->beg = off;
        -: 5658:
        -: 5659:            /* Some of the following whitespace actually still belongs to the mark. */
    #####: 5660:            if(off >= ctx->size || ISNEWLINE(off)) {
    #####: 5661:                container.contents_indent++;
    #####: 5662:            } else if(line->indent <= ctx->code_indent_offset) {
    #####: 5663:                container.contents_indent += line->indent;
    #####: 5664:                line->indent = 0;
        -: 5665:            } else {
    #####: 5666:                container.contents_indent += 1;
    #####: 5667:                line->indent--;
        -: 5668:            }
        -: 5669:
    #####: 5670:            ctx->containers[n_parents].mark_indent = container.mark_indent;
    #####: 5671:            ctx->containers[n_parents].contents_indent = container.contents_indent;
        -: 5672:
    #####: 5673:            n_brothers++;
    #####: 5674:            goto redo;
        -: 5675:        }
        -: 5676:    }
        -: 5677:
        -: 5678:    /* Check for indented code.
        -: 5679:     * Note indented code block cannot interrupt a paragraph. */
        3: 5680:    if(line->indent >= ctx->code_indent_offset  &&
        1: 5681:        (pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))
        -: 5682:    {
        1: 5683:        line->type = MD_LINE_INDENTEDCODE;
        -: 5684:        MD_ASSERT(line->indent >= ctx->code_indent_offset);
        1: 5685:        line->indent -= ctx->code_indent_offset;
        1: 5686:        line->data = 0;
        1: 5687:        goto done;
        -: 5688:    }
        -: 5689:
        -: 5690:    /* Check for start of a new container block. */
        2: 5691:    if(line->indent < ctx->code_indent_offset  &&
        1: 5692:       md_is_container_mark(ctx, line->indent, off, &off, &container))
        -: 5693:    {
    #####: 5694:        if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
    #####: 5695:                    (off >= ctx->size || ISNEWLINE(off)))
        -: 5696:        {
        -: 5697:            /* Noop. List mark followed by a blank line cannot interrupt a paragraph. */
    #####: 5698:        } else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
    #####: 5699:                    (container.ch == _T('.') || container.ch == _T(')'))  &&  container.start != 1)
        -: 5700:        {
        -: 5701:            /* Noop. Ordered list cannot interrupt a paragraph unless the start index is 1. */
        -: 5702:        } else {
    #####: 5703:            total_indent += container.contents_indent - container.mark_indent;
    #####: 5704:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
    #####: 5705:            total_indent += line->indent;
        -: 5706:
    #####: 5707:            line->beg = off;
    #####: 5708:            line->data = container.ch;
        -: 5709:
        -: 5710:            /* Some of the following whitespace actually still belongs to the mark. */
    #####: 5711:            if(off >= ctx->size || ISNEWLINE(off)) {
    #####: 5712:                container.contents_indent++;
    #####: 5713:            } else if(line->indent <= ctx->code_indent_offset) {
    #####: 5714:                container.contents_indent += line->indent;
    #####: 5715:                line->indent = 0;
        -: 5716:            } else {
    #####: 5717:                container.contents_indent += 1;
    #####: 5718:                line->indent--;
        -: 5719:            }
        -: 5720:
    #####: 5721:            if(n_brothers + n_children == 0)
    #####: 5722:                pivot_line = &md_dummy_blank_line;
        -: 5723:
    #####: 5724:            if(n_children == 0)
    #####: 5725:                MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));
        -: 5726:
    #####: 5727:            n_children++;
    #####: 5728:            MD_CHECK(md_push_container(ctx, &container));
        -: 5729:            goto redo;
        -: 5730:        }
        -: 5731:    }
        -: 5732:
        -: 5733:    /* Check whether we are table continuation. */
        1: 5734:    if(pivot_line->type == MD_LINE_TABLE  &&  md_is_table_row(ctx, off, &off)  &&
    #####: 5735:       n_parents == ctx->n_containers)
        -: 5736:    {
    #####: 5737:        line->type = MD_LINE_TABLE;
    #####: 5738:        goto done;
        -: 5739:    }
        -: 5740:
        -: 5741:    /* Check for ATX header. */
        1: 5742:    if(line->indent < ctx->code_indent_offset  &&  CH(off) == _T('#')) {
    #####: 5743:        unsigned level;
        -: 5744:
    #####: 5745:        if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {
    #####: 5746:            line->type = MD_LINE_ATXHEADER;
    #####: 5747:            line->data = level;
    #####: 5748:            goto done;
        -: 5749:        }
        -: 5750:    }
        -: 5751:
        -: 5752:    /* Check whether we are starting code fence. */
        1: 5753:    if(CH(off) == _T('`') || CH(off) == _T('~')) {
    #####: 5754:        if(md_is_opening_code_fence(ctx, off, &off)) {
    #####: 5755:            line->type = MD_LINE_FENCEDCODE;
    #####: 5756:            line->data = 1;
    #####: 5757:            goto done;
        -: 5758:        }
        -: 5759:    }
        -: 5760:
        -: 5761:    /* Check for start of raw HTML block. */
        1: 5762:    if(CH(off) == _T('<')  &&  !(ctx->parser.flags & MD_FLAG_NOHTMLBLOCKS))
        -: 5763:    {
    #####: 5764:        ctx->html_block_type = md_is_html_block_start_condition(ctx, off);
        -: 5765:
        -: 5766:        /* HTML block type 7 cannot interrupt paragraph. */
    #####: 5767:        if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)
    #####: 5768:            ctx->html_block_type = 0;
        -: 5769:
    #####: 5770:        if(ctx->html_block_type > 0) {
        -: 5771:            /* The line itself also may immediately close the block. */
    #####: 5772:            if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {
        -: 5773:                /* Make sure this is the last line of the block. */
    #####: 5774:                ctx->html_block_type = 0;
        -: 5775:            }
        -: 5776:
    #####: 5777:            line->type = MD_LINE_HTML;
    #####: 5778:            goto done;
        -: 5779:        }
        -: 5780:    }
        -: 5781:
        -: 5782:    /* Check for table underline. */
        1: 5783:    if((ctx->parser.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT  &&
    #####: 5784:       (CH(off) == _T('|') || CH(off) == _T('-') || CH(off) == _T(':'))  &&
    #####: 5785:       n_parents == ctx->n_containers)
        -: 5786:    {
    #####: 5787:        unsigned col_count;
        -: 5788:
    #####: 5789:        if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&
    #####: 5790:            md_is_table_underline(ctx, off, &off, &col_count)  &&
    #####: 5791:            md_is_table_row(ctx, pivot_line->beg, NULL))
        -: 5792:        {
    #####: 5793:            line->data = col_count;
    #####: 5794:            line->type = MD_LINE_TABLEUNDERLINE;
    #####: 5795:            goto done;
        -: 5796:        }
        -: 5797:    }
        -: 5798:
        -: 5799:    /* By default, we are normal text line. */
        1: 5800:    line->type = MD_LINE_TEXT;
        1: 5801:    if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {
        -: 5802:        /* Lazy continuation. */
    #####: 5803:        n_parents = ctx->n_containers;
        -: 5804:    }
        -: 5805:
        -: 5806:    /* Check for task mark. */
        1: 5807:    if((ctx->parser.flags & MD_FLAG_TASKLISTS)  &&  n_brothers + n_children > 0  &&
    #####: 5808:       ISANYOF_(ctx->containers[ctx->n_containers-1].ch, _T("-+*.)")))
        -: 5809:    {
    #####: 5810:        OFF tmp = off;
        -: 5811:
    #####: 5812:        while(tmp < ctx->size  &&  tmp < off + 3  &&  ISBLANK(tmp))
    #####: 5813:            tmp++;
    #####: 5814:        if(tmp + 2 < ctx->size  &&  CH(tmp) == _T('[')  &&
    #####: 5815:           ISANYOF(tmp+1, _T("xX "))  &&  CH(tmp+2) == _T(']')  &&
    #####: 5816:           (tmp + 3 == ctx->size  ||  ISBLANK(tmp+3)  ||  ISNEWLINE(tmp+3)))
        -: 5817:        {
    #####: 5818:            MD_CONTAINER* task_container = (n_children > 0 ? &ctx->containers[ctx->n_containers-1] : &container);
    #####: 5819:            task_container->is_task = TRUE;
    #####: 5820:            task_container->task_mark_off = tmp + 1;
    #####: 5821:            off = tmp + 3;
    #####: 5822:            while(ISWHITESPACE(off))
    #####: 5823:                off++;
    #####: 5824:            line->beg = off;
        -: 5825:        }
        -: 5826:    }
        -: 5827:
        4: 5828:done:
        -: 5829:    /* Scan for end of the line.
        -: 5830:     *
        -: 5831:     * Note this is bottleneck of this function as we itereate over (almost)
        -: 5832:     * all line contents after some initial line indentation. To optimize, we
        -: 5833:     * try to eat multiple chars in every loop iteration.
        -: 5834:     *
        -: 5835:     * (Measured ~6% performance boost of md2html with this optimization for
        -: 5836:     * normal kind of input.)
        -: 5837:     */
        7: 5838:    while(off + 4 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)
        2: 5839:                               &&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))
        1: 5840:        off += 4;
       10: 5841:    while(off < ctx->size  &&  !ISNEWLINE(off))
        2: 5842:        off++;
        -: 5843:
        3: 5844:done_on_eol:
        -: 5845:    /* Set end of the line. */
        3: 5846:    line->end = off;
        -: 5847:
        -: 5848:    /* But for ATX header, we should exclude the optional trailing mark. */
        3: 5849:    if(line->type == MD_LINE_ATXHEADER) {
        -: 5850:        OFF tmp = line->end;
    #####: 5851:        while(tmp > line->beg && CH(tmp-1) == _T(' '))
        -: 5852:            tmp--;
    #####: 5853:        while(tmp > line->beg && CH(tmp-1) == _T('#'))
        -: 5854:            tmp--;
    #####: 5855:        if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->parser.flags & MD_FLAG_PERMISSIVEATXHEADERS))
    #####: 5856:            line->end = tmp;
        -: 5857:    }
        -: 5858:
        -: 5859:    /* Trim trailing spaces. */
        3: 5860:    if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {
        2: 5861:        while(line->end > line->beg && CH(line->end-1) == _T(' '))
    #####: 5862:            line->end--;
        -: 5863:    }
        -: 5864:
        -: 5865:    /* Eat also the new line. */
        3: 5866:    if(off < ctx->size && CH(off) == _T('\r'))
    #####: 5867:        off++;
        3: 5868:    if(off < ctx->size && CH(off) == _T('\n'))
        3: 5869:        off++;
        -: 5870:
        3: 5871:    *p_end = off;
        -: 5872:
        -: 5873:    /* If we belong to a list after seeing a blank line, the list is loose. */
        3: 5874:    if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {
    #####: 5875:        MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];
    #####: 5876:        if(c->ch != _T('>')) {
    #####: 5877:            MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);
    #####: 5878:            block->flags |= MD_BLOCK_LOOSE_LIST;
        -: 5879:        }
        -: 5880:    }
        -: 5881:
        -: 5882:    /* Leave any containers we are not part of anymore. */
        3: 5883:    if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)
    #####: 5884:        MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));
        -: 5885:
        -: 5886:    /* Enter any container we found a mark for. */
        3: 5887:    if(n_brothers > 0) {
    #####: 5888:        MD_ASSERT(n_brothers == 1);
    #####: 5889:        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,
        -: 5890:                    ctx->containers[n_parents].task_mark_off,
        -: 5891:                    (ctx->containers[n_parents].is_task ? CH(ctx->containers[n_parents].task_mark_off) : 0),
        -: 5892:                    MD_BLOCK_CONTAINER_CLOSER));
    #####: 5893:        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI,
        -: 5894:                    container.task_mark_off,
        -: 5895:                    (container.is_task ? CH(container.task_mark_off) : 0),
        -: 5896:                    MD_BLOCK_CONTAINER_OPENER));
    #####: 5897:        ctx->containers[n_parents].is_task = container.is_task;
    #####: 5898:        ctx->containers[n_parents].task_mark_off = container.task_mark_off;
        -: 5899:    }
        -: 5900:
        3: 5901:    if(n_children > 0)
    #####: 5902:        MD_CHECK(md_enter_child_containers(ctx, n_children, line->data));
        -: 5903:
        3: 5904:abort:
        3: 5905:    return ret;
        -: 5906:}
        -: 5907:
        -: 5908:static int
        3: 5909:md_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, MD_LINE_ANALYSIS* line)
        -: 5910:{
        3: 5911:    const MD_LINE_ANALYSIS* pivot_line = *p_pivot_line;
        3: 5912:    int ret = 0;
        -: 5913:
        -: 5914:    /* Blank line ends current leaf block. */
        3: 5915:    if(line->type == MD_LINE_BLANK) {
    #####: 5916:        MD_CHECK(md_end_current_block(ctx));
    #####: 5917:        *p_pivot_line = &md_dummy_blank_line;
    #####: 5918:        return 0;
        -: 5919:    }
        -: 5920:
        -: 5921:    /* Some line types form block on their own. */
        3: 5922:    if(line->type == MD_LINE_HR || line->type == MD_LINE_ATXHEADER) {
    #####: 5923:        MD_CHECK(md_end_current_block(ctx));
        -: 5924:
        -: 5925:        /* Add our single-line block. */
    #####: 5926:        MD_CHECK(md_start_new_block(ctx, line));
    #####: 5927:        MD_CHECK(md_add_line_into_current_block(ctx, line));
    #####: 5928:        MD_CHECK(md_end_current_block(ctx));
    #####: 5929:        *p_pivot_line = &md_dummy_blank_line;
    #####: 5930:        return 0;
        -: 5931:    }
        -: 5932:
        -: 5933:    /* MD_LINE_SETEXTUNDERLINE changes meaning of the current block and ends it. */
        3: 5934:    if(line->type == MD_LINE_SETEXTUNDERLINE) {
        1: 5935:        MD_ASSERT(ctx->current_block != NULL);
        1: 5936:        ctx->current_block->type = MD_BLOCK_H;
        1: 5937:        ctx->current_block->data = line->data;
        1: 5938:        ctx->current_block->flags |= MD_BLOCK_SETEXT_HEADER;
        1: 5939:        MD_CHECK(md_add_line_into_current_block(ctx, line));
        1: 5940:        MD_CHECK(md_end_current_block(ctx));
        1: 5941:        if(ctx->current_block == NULL) {
        1: 5942:            *p_pivot_line = &md_dummy_blank_line;
        -: 5943:        } else {
        -: 5944:            /* This happens if we have consumed all the body as link ref. defs.
        -: 5945:             * and downgraded the underline into start of a new paragraph block. */
    #####: 5946:            line->type = MD_LINE_TEXT;
    #####: 5947:            *p_pivot_line = line;
        -: 5948:        }
        -: 5949:        return 0;
        -: 5950:    }
        -: 5951:
        -: 5952:    /* MD_LINE_TABLEUNDERLINE changes meaning of the current block. */
        2: 5953:    if(line->type == MD_LINE_TABLEUNDERLINE) {
    #####: 5954:        MD_ASSERT(ctx->current_block != NULL);
    #####: 5955:        MD_ASSERT(ctx->current_block->n_lines == 1);
    #####: 5956:        ctx->current_block->type = MD_BLOCK_TABLE;
    #####: 5957:        ctx->current_block->data = line->data;
    #####: 5958:        MD_ASSERT(pivot_line != &md_dummy_blank_line);
    #####: 5959:        ((MD_LINE_ANALYSIS*)pivot_line)->type = MD_LINE_TABLE;
    #####: 5960:        MD_CHECK(md_add_line_into_current_block(ctx, line));
        -: 5961:        return 0;
        -: 5962:    }
        -: 5963:
        -: 5964:    /* The current block also ends if the line has different type. */
        2: 5965:    if(line->type != pivot_line->type)
        2: 5966:        MD_CHECK(md_end_current_block(ctx));
        -: 5967:
        -: 5968:    /* The current line may start a new block. */
        2: 5969:    if(ctx->current_block == NULL) {
        2: 5970:        MD_CHECK(md_start_new_block(ctx, line));
        1: 5971:        *p_pivot_line = line;
        -: 5972:    }
        -: 5973:
        -: 5974:    /* In all other cases the line is just a continuation of the current block. */
        1: 5975:    MD_CHECK(md_add_line_into_current_block(ctx, line));
        -: 5976:
        1: 5977:abort:
        -: 5978:    return ret;
        -: 5979:}
        -: 5980:
        -: 5981:static int
        1: 5982:md_process_doc(MD_CTX *ctx)
        -: 5983:{
        1: 5984:    const MD_LINE_ANALYSIS* pivot_line = &md_dummy_blank_line;
        1: 5985:    MD_LINE_ANALYSIS line_buf[2];
        1: 5986:    MD_LINE_ANALYSIS* line = &line_buf[0];
        1: 5987:    OFF off = 0;
        1: 5988:    int ret = 0;
        -: 5989:
        1: 5990:    MD_ENTER_BLOCK(MD_BLOCK_DOC, NULL);
        -: 5991:
        3: 5992:    while(off < ctx->size) {
        3: 5993:        if(line == pivot_line)
        1: 5994:            line = (line == &line_buf[0] ? &line_buf[1] : &line_buf[0]);
        -: 5995:
        3: 5996:        MD_CHECK(md_analyze_line(ctx, off, &off, pivot_line, line));
        3: 5997:        MD_CHECK(md_process_line(ctx, &pivot_line, line));
        -: 5998:    }
        -: 5999:
    #####: 6000:    md_end_current_block(ctx);
        -: 6001:
    #####: 6002:    MD_CHECK(md_build_ref_def_hashtable(ctx));
        -: 6003:
        -: 6004:    /* Process all blocks. */
    #####: 6005:    MD_CHECK(md_leave_child_containers(ctx, 0));
    #####: 6006:    MD_CHECK(md_process_all_blocks(ctx));
        -: 6007:
    #####: 6008:    MD_LEAVE_BLOCK(MD_BLOCK_DOC, NULL);
        -: 6009:
    #####: 6010:abort:
        -: 6011:
        -: 6012:#if 0
        -: 6013:    /* Output some memory consumption statistics. */
        -: 6014:    {
        -: 6015:        char buffer[256];
        -: 6016:        sprintf(buffer, "Alloced %u bytes for block buffer.",
        -: 6017:                    (unsigned)(ctx->alloc_block_bytes));
        -: 6018:        MD_LOG(buffer);
        -: 6019:
        -: 6020:        sprintf(buffer, "Alloced %u bytes for containers buffer.",
        -: 6021:                    (unsigned)(ctx->alloc_containers * sizeof(MD_CONTAINER)));
        -: 6022:        MD_LOG(buffer);
        -: 6023:
        -: 6024:        sprintf(buffer, "Alloced %u bytes for marks buffer.",
        -: 6025:                    (unsigned)(ctx->alloc_marks * sizeof(MD_MARK)));
        -: 6026:        MD_LOG(buffer);
        -: 6027:
        -: 6028:        sprintf(buffer, "Alloced %u bytes for aux. buffer.",
        -: 6029:                    (unsigned)(ctx->alloc_buffer * sizeof(MD_CHAR)));
        -: 6030:        MD_LOG(buffer);
        -: 6031:    }
        -: 6032:#endif
        -: 6033:
    #####: 6034:    return ret;
        -: 6035:}
        -: 6036:
        -: 6037:
        -: 6038:/********************
        -: 6039: ***  Public API  ***
        -: 6040: ********************/
        -: 6041:
        -: 6042:int
        1: 6043:md_parse(const MD_CHAR* text, MD_SIZE size, const MD_PARSER* parser, void* userdata)
        -: 6044:{
        1: 6045:    MD_CTX ctx;
        -: 6046:    int i;
        -: 6047:    int ret;
        -: 6048:
        1: 6049:    if(parser->abi_version != 0) {
    #####: 6050:        if(parser->debug_log != NULL)
    #####: 6051:            parser->debug_log("Unsupported abi_version.", userdata);
        -: 6052:        return -1;
        -: 6053:    }
        -: 6054:
        -: 6055:    /* Setup context structure. */
        1: 6056:    memset(&ctx, 0, sizeof(MD_CTX));
        1: 6057:    ctx.text = text;
        1: 6058:    ctx.size = size;
        1: 6059:    memcpy(&ctx.parser, parser, sizeof(MD_PARSER));
        1: 6060:    ctx.userdata = userdata;
        1: 6061:    ctx.code_indent_offset = (ctx.parser.flags & MD_FLAG_NOINDENTEDCODEBLOCKS) ? (OFF)(-1) : 4;
        1: 6062:    md_build_mark_char_map(&ctx);
        -: 6063:
        -: 6064:    /* Reset all unresolved opener mark chains. */
       12: 6065:    for(i = 0; i < SIZEOF_ARRAY(ctx.mark_chains); i++) {
       11: 6066:        ctx.mark_chains[i].head = -1;
       11: 6067:        ctx.mark_chains[i].tail = -1;
        -: 6068:    }
        1: 6069:    ctx.unresolved_link_head = -1;
        1: 6070:    ctx.unresolved_link_tail = -1;
        -: 6071:
        -: 6072:    /* All the work. */
        1: 6073:    ret = md_process_doc(&ctx);
        -: 6074:
        -: 6075:    /* Clean-up. */
    #####: 6076:    md_free_ref_defs(&ctx);
    #####: 6077:    md_free_ref_def_hashtable(&ctx);
    #####: 6078:    free(ctx.buffer);
    #####: 6079:    free(ctx.marks);
    #####: 6080:    free(ctx.block_bytes);
    #####: 6081:    free(ctx.containers);
        -: 6082:
    #####: 6083:    return ret;
        -: 6084:}
