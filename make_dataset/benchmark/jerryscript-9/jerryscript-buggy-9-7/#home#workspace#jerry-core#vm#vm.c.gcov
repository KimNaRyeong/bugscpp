        -:    0:Source:/home/workspace/jerry-core/vm/vm.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "vm.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-arguments-object.h"
        -:   20:#include "ecma-array-object.h"
        -:   21:#include "ecma-bigint.h"
        -:   22:#include "ecma-builtin-object.h"
        -:   23:#include "ecma-builtins.h"
        -:   24:#include "ecma-comparison.h"
        -:   25:#include "ecma-conversion.h"
        -:   26:#include "ecma-errors.h"
        -:   27:#include "ecma-exceptions.h"
        -:   28:#include "ecma-function-object.h"
        -:   29:#include "ecma-gc.h"
        -:   30:#include "ecma-helpers.h"
        -:   31:#include "ecma-iterator-object.h"
        -:   32:#include "ecma-lcache.h"
        -:   33:#include "ecma-lex-env.h"
        -:   34:#include "ecma-objects-general.h"
        -:   35:#include "ecma-objects.h"
        -:   36:#include "ecma-promise-object.h"
        -:   37:#include "ecma-regexp-object.h"
        -:   38:
        -:   39:#include "common.h"
        -:   40:#include "jcontext.h"
        -:   41:#include "opcodes.h"
        -:   42:#include "vm-stack.h"
        -:   43:
        -:   44:/** \addtogroup vm Virtual machine
        -:   45: * @{
        -:   46: *
        -:   47: * \addtogroup vm_executor Executor
        -:   48: * @{
        -:   49: */
        -:   50:
        -:   51:JERRY_STATIC_ASSERT ((sizeof (vm_frame_ctx_t) % sizeof (ecma_value_t)) == 0,
        -:   52:                     sizeof_vm_frame_ctx_must_be_sizeof_ecma_value_t_aligned);
        -:   53:
        -:   54:/**
        -:   55: * Get the value of object[property].
        -:   56: *
        -:   57: * @return ecma value
        -:   58: */
        -:   59:static ecma_value_t
    #####:   60:vm_op_get_value (ecma_value_t object, /**< base object */
        -:   61:                 ecma_value_t property) /**< property name */
        -:   62:{
    #####:   63:  if (ecma_is_value_object (object))
        -:   64:  {
    #####:   65:    ecma_object_t *object_p = ecma_get_object_from_value (object);
    #####:   66:    ecma_string_t *property_name_p = NULL;
        -:   67:
    #####:   68:    if (ecma_is_value_integer_number (property))
        -:   69:    {
    #####:   70:      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);
        -:   71:
    #####:   72:      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)
        -:   73:      {
    #####:   74:        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)
        -:   75:        {
    #####:   76:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   77:
    #####:   78:          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)
        -:   79:                            && (uint32_t) int_value < ext_object_p->u.array.length))
        -:   80:          {
    #####:   81:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:   82:
    #####:   83:            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))
        -:   84:            {
    #####:   85:              return ecma_fast_copy_value (values_p[int_value]);
        -:   86:            }
        -:   87:          }
        -:   88:        }
        -:   89:
    #####:   90:        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) int_value);
        -:   91:      }
        -:   92:    }
    #####:   93:    else if (ecma_is_value_string (property))
        -:   94:    {
    #####:   95:      property_name_p = ecma_get_string_from_value (property);
        -:   96:    }
        -:   97:
        -:   98:#if JERRY_ESNEXT
    #####:   99:    if (ecma_is_value_symbol (property))
        -:  100:    {
    #####:  101:      property_name_p = ecma_get_symbol_from_value (property);
        -:  102:    }
        -:  103:#endif /* JERRY_ESNEXT */
        -:  104:
    #####:  105:    if (property_name_p != NULL)
        -:  106:    {
        -:  107:#if JERRY_LCACHE
    #####:  108:      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);
        -:  109:
    #####:  110:      if (property_p != NULL && (*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  111:      {
    #####:  112:        JERRY_ASSERT (!ECMA_PROPERTY_IS_INTERNAL (*property_p));
    #####:  113:        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  114:      }
        -:  115:#endif /* JERRY_LCACHE */
        -:  116:
        -:  117:      /* There is no need to free the name. */
    #####:  118:      return ecma_op_object_get (object_p, property_name_p);
        -:  119:    }
        -:  120:  }
        -:  121:
    #####:  122:  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))
        -:  123:  {
        -:  124:#if JERRY_ERROR_MESSAGES
    #####:  125:    ecma_value_t error_value =
        -:  126:      ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE, "Cannot read property '%' of %", property, object);
        -:  127:#else /* !JERRY_ERROR_MESSAGES */
        -:  128:    ecma_value_t error_value = ecma_raise_type_error (ECMA_ERR_EMPTY);
        -:  129:#endif /* JERRY_ERROR_MESSAGES */
    #####:  130:    return error_value;
        -:  131:  }
        -:  132:
    #####:  133:  ecma_string_t *property_name_p = ecma_op_to_property_key (property);
        -:  134:
    #####:  135:  if (property_name_p == NULL)
        -:  136:  {
    #####:  137:    return ECMA_VALUE_ERROR;
        -:  138:  }
        -:  139:
    #####:  140:  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);
        -:  141:
    #####:  142:  ecma_deref_ecma_string (property_name_p);
    #####:  143:  return get_value_result;
        -:  144:} /* vm_op_get_value */
        -:  145:
        -:  146:/**
        -:  147: * Set the value of object[property].
        -:  148: *
        -:  149: * Note:
        -:  150: *  this function frees its object and property arguments
        -:  151: *
        -:  152: * @return an ecma value which contains an error
        -:  153: *         if the property setting is unsuccessful
        -:  154: */
        -:  155:static ecma_value_t
    #####:  156:vm_op_set_value (ecma_value_t base, /**< base object */
        -:  157:                 ecma_value_t property, /**< property name */
        -:  158:                 ecma_value_t value, /**< ecma value */
        -:  159:                 bool is_strict) /**< strict mode */
        -:  160:{
    #####:  161:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -:  162:  ecma_object_t *object_p;
        -:  163:  ecma_string_t *property_p;
        -:  164:
    #####:  165:  if (JERRY_UNLIKELY (!ecma_is_value_object (base)))
        -:  166:  {
    #####:  167:    if (JERRY_UNLIKELY (ecma_is_value_null (base) || ecma_is_value_undefined (base)))
        -:  168:    {
        -:  169:#if JERRY_ERROR_MESSAGES
    #####:  170:      result = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE, "Cannot set property '%' of %", property, base);
        -:  171:#else /* !JERRY_ERROR_MESSAGES */
        -:  172:      result = ecma_raise_type_error (ECMA_ERR_EMPTY);
        -:  173:#endif /* JERRY_ERROR_MESSAGES */
    #####:  174:      ecma_free_value (property);
    #####:  175:      return result;
        -:  176:    }
        -:  177:
    #####:  178:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  179:    {
    #####:  180:      property_p = ecma_op_to_string (property);
    #####:  181:      ecma_fast_free_value (property);
        -:  182:
    #####:  183:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  184:      {
    #####:  185:        ecma_free_value (base);
    #####:  186:        return ECMA_VALUE_ERROR;
        -:  187:      }
        -:  188:    }
        -:  189:    else
        -:  190:    {
    #####:  191:      property_p = ecma_get_prop_name_from_value (property);
        -:  192:    }
        -:  193:
    #####:  194:    ecma_value_t object = ecma_op_to_object (base);
    #####:  195:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (object));
        -:  196:
    #####:  197:    object_p = ecma_get_object_from_value (object);
    #####:  198:    ecma_op_ordinary_object_prevent_extensions (object_p);
        -:  199:
    #####:  200:    result = ecma_op_object_put_with_receiver (object_p, property_p, value, base, is_strict);
        -:  201:
    #####:  202:    ecma_free_value (base);
        -:  203:  }
        -:  204:  else
        -:  205:  {
    #####:  206:    object_p = ecma_get_object_from_value (base);
        -:  207:
    #####:  208:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  209:    {
    #####:  210:      property_p = ecma_op_to_string (property);
    #####:  211:      ecma_fast_free_value (property);
        -:  212:
    #####:  213:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  214:      {
    #####:  215:        ecma_deref_object (object_p);
    #####:  216:        return ECMA_VALUE_ERROR;
        -:  217:      }
        -:  218:    }
        -:  219:    else
        -:  220:    {
    #####:  221:      property_p = ecma_get_prop_name_from_value (property);
        -:  222:    }
        -:  223:
    #####:  224:    if (!ecma_is_lexical_environment (object_p))
        -:  225:    {
    #####:  226:      result = ecma_op_object_put_with_receiver (object_p, property_p, value, base, is_strict);
        -:  227:    }
        -:  228:    else
        -:  229:    {
    #####:  230:      result = ecma_op_set_mutable_binding (object_p, property_p, value, is_strict);
        -:  231:    }
        -:  232:  }
        -:  233:
    #####:  234:  ecma_deref_object (object_p);
    #####:  235:  ecma_deref_ecma_string (property_p);
    #####:  236:  return result;
        -:  237:} /* vm_op_set_value */
        -:  238:
        -:  239:/** Compact bytecode define */
        -:  240:#define CBC_OPCODE(arg1, arg2, arg3, arg4) arg4,
        -:  241:
        -:  242:/**
        -:  243: * Decode table for both opcodes and extended opcodes.
        -:  244: */
        -:  245:static const uint16_t vm_decode_table[] JERRY_ATTR_CONST_DATA = { CBC_OPCODE_LIST CBC_EXT_OPCODE_LIST };
        -:  246:
        -:  247:#undef CBC_OPCODE
        -:  248:
        -:  249:/**
        -:  250: * Run global code
        -:  251: *
        -:  252: * Note:
        -:  253: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  254: *
        -:  255: * @return ecma value
        -:  256: */
        -:  257:ecma_value_t
        1:  258:vm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */
        -:  259:               ecma_object_t *function_object_p) /**< function object if available */
        -:  260:{
        -:  261:#if JERRY_BUILTIN_REALMS
        1:  262:  ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_p);
        -:  263:#else /* !JERRY_BUILTIN_REALMS */
    #####:  264:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        -:  265:#endif /* JERRY_BUILTIN_REALMS */
        -:  266:
        -:  267:#if JERRY_ESNEXT
        1:  268:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)
        -:  269:  {
    #####:  270:    ecma_create_global_lexical_block (global_obj_p);
        -:  271:  }
        -:  272:#endif /* JERRY_ESNEXT */
        -:  273:
        1:  274:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -:  275:
        1:  276:  vm_frame_ctx_shared_t shared;
        1:  277:  shared.bytecode_header_p = bytecode_p;
        1:  278:  shared.function_object_p = function_object_p;
        1:  279:  shared.status_flags = 0;
        -:  280:
        -:  281:#if JERRY_BUILTIN_REALMS
        1:  282:  ecma_value_t this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
        -:  283:
        1:  284:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
        1:  285:  JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) global_obj_p;
        -:  286:#else /* !JERRY_BUILTIN_REALMS */
    #####:  287:  ecma_value_t this_binding = ecma_make_object_value (global_obj_p);
        -:  288:#endif /* JERRY_BUILTIN_REALMS */
        -:  289:
        1:  290:  ecma_value_t result = vm_run (&shared, this_binding, global_scope_p);
        -:  291:
        -:  292:#if JERRY_BUILTIN_REALMS
    #####:  293:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  294:#endif /* JERRY_BUILTIN_REALMS */
        -:  295:
    #####:  296:  return result;
        -:  297:} /* vm_run_global */
        -:  298:
        -:  299:/**
        -:  300: * Run specified eval-mode bytecode
        -:  301: *
        -:  302: * @return ecma value
        -:  303: */
        -:  304:ecma_value_t
    #####:  305:vm_run_eval (ecma_compiled_code_t *bytecode_data_p, /**< byte-code data */
        -:  306:             uint32_t parse_opts) /**< ecma_parse_opts_t option bits */
        -:  307:{
        -:  308:  ecma_value_t this_binding;
        -:  309:  ecma_object_t *lex_env_p;
        -:  310:
        -:  311:  /* ECMA-262 v5, 10.4.2 */
    #####:  312:  if (parse_opts & ECMA_PARSE_DIRECT_EVAL)
        -:  313:  {
    #####:  314:    this_binding = ecma_copy_value (JERRY_CONTEXT (vm_top_context_p)->this_binding);
    #####:  315:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  316:
        -:  317:#if JERRY_DEBUGGER
        -:  318:    uint32_t chain_index = JERRY_CONTEXT (debugger_eval_chain_index);
        -:  319:    JERRY_CONTEXT (debugger_eval_chain_index) = 0;
        -:  320:
        -:  321:    while (chain_index != 0)
        -:  322:    {
        -:  323:      if (JERRY_UNLIKELY (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL))
        -:  324:      {
        -:  325:        ecma_bytecode_deref (bytecode_data_p);
        -:  326:        ecma_free_value (this_binding);
        -:  327:        return ecma_raise_range_error (ECMA_ERR_INVALID_SCOPE_CHAIN_INDEX_FOR_EVAL);
        -:  328:      }
        -:  329:
        -:  330:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  331:
        -:  332:      if ((ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)
        -:  333:          || (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE))
        -:  334:      {
        -:  335:        chain_index--;
        -:  336:      }
        -:  337:    }
        -:  338:#endif /* JERRY_DEBUGGER */
        -:  339:  }
        -:  340:  else
        -:  341:  {
        -:  342:#if JERRY_BUILTIN_REALMS
    #####:  343:    ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p);
    #####:  344:    this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
    #####:  345:    ecma_ref_object (ecma_get_object_from_value (this_binding));
        -:  346:#else /* !JERRY_BUILTIN_REALMS */
    #####:  347:    ecma_object_t *global_obj_p = ecma_builtin_get_global ();
    #####:  348:    ecma_ref_object (global_obj_p);
    #####:  349:    this_binding = ecma_make_object_value (global_obj_p);
        -:  350:#endif /* JERRY_BUILTIN_REALMS */
    #####:  351:    lex_env_p = ecma_get_global_scope (global_obj_p);
        -:  352:  }
        -:  353:
    #####:  354:  ecma_ref_object (lex_env_p);
        -:  355:
    #####:  356:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0)
        -:  357:  {
    #####:  358:    ecma_object_t *strict_lex_env_p = ecma_create_decl_lex_env (lex_env_p);
        -:  359:
    #####:  360:    ecma_deref_object (lex_env_p);
    #####:  361:    lex_env_p = strict_lex_env_p;
        -:  362:  }
        -:  363:
    #####:  364:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED) != 0)
        -:  365:  {
    #####:  366:    ecma_object_t *lex_block_p = ecma_create_decl_lex_env (lex_env_p);
    #####:  367:    lex_block_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -:  368:
    #####:  369:    ecma_deref_object (lex_env_p);
    #####:  370:    lex_env_p = lex_block_p;
        -:  371:  }
        -:  372:
    #####:  373:  vm_frame_ctx_shared_t shared;
    #####:  374:  shared.bytecode_header_p = bytecode_data_p;
    #####:  375:  shared.function_object_p = NULL;
    #####:  376:  shared.status_flags = (parse_opts & ECMA_PARSE_DIRECT_EVAL) ? VM_FRAME_CTX_SHARED_DIRECT_EVAL : 0;
        -:  377:
    #####:  378:  ecma_value_t completion_value = vm_run (&shared, this_binding, lex_env_p);
        -:  379:
    #####:  380:  ecma_deref_object (lex_env_p);
    #####:  381:  ecma_free_value (this_binding);
        -:  382:
        -:  383:#if JERRY_SNAPSHOT_EXEC
    #####:  384:  if (!(bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -:  385:  {
    #####:  386:    ecma_bytecode_deref (bytecode_data_p);
        -:  387:  }
        -:  388:#else /* !JERRY_SNAPSHOT_EXEC */
    #####:  389:  ecma_bytecode_deref (bytecode_data_p);
        -:  390:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  391:
    #####:  392:  return completion_value;
        -:  393:} /* vm_run_eval */
        -:  394:
        -:  395:#if JERRY_MODULE_SYSTEM
        -:  396:
        -:  397:/**
        -:  398: * Run module code
        -:  399: *
        -:  400: * Note:
        -:  401: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  402: *
        -:  403: * @return ecma value
        -:  404: */
        -:  405:ecma_value_t
    #####:  406:vm_run_module (ecma_module_t *module_p) /**< module to be executed */
        -:  407:{
    #####:  408:  const ecma_value_t module_init_result = ecma_module_initialize (module_p);
        -:  409:
    #####:  410:  if (ECMA_IS_VALUE_ERROR (module_init_result))
        -:  411:  {
    #####:  412:    return module_init_result;
        -:  413:  }
        -:  414:
    #####:  415:  vm_frame_ctx_shared_t shared;
    #####:  416:  shared.bytecode_header_p = module_p->u.compiled_code_p;
    #####:  417:  shared.function_object_p = &module_p->header.object;
    #####:  418:  shared.status_flags = 0;
        -:  419:
    #####:  420:  return vm_run (&shared, ECMA_VALUE_UNDEFINED, module_p->scope_p);
        -:  421:} /* vm_run_module */
        -:  422:
        -:  423:#endif /* JERRY_MODULE_SYSTEM */
        -:  424:
        -:  425:/**
        -:  426: * Construct object
        -:  427: *
        -:  428: * @return object value
        -:  429: */
        -:  430:static ecma_value_t
        1:  431:vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  432:                             ecma_value_t lit_value) /**< literal */
        -:  433:{
        -:  434:  ecma_compiled_code_t *bytecode_p;
        -:  435:
        -:  436:#if JERRY_SNAPSHOT_EXEC
    #####:  437:  if (JERRY_LIKELY (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -:  438:  {
        -:  439:#endif /* JERRY_SNAPSHOT_EXEC */
        1:  440:    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, lit_value);
        -:  441:#if JERRY_SNAPSHOT_EXEC
        -:  442:  }
        -:  443:  else
        -:  444:  {
    #####:  445:    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->shared_p->bytecode_header_p) + lit_value;
    #####:  446:    bytecode_p = (ecma_compiled_code_t *) byte_p;
        -:  447:  }
        -:  448:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  449:
        -:  450:#if JERRY_BUILTIN_REGEXP
        1:  451:  if (JERRY_UNLIKELY (!CBC_IS_FUNCTION (bytecode_p->status_flags)))
        -:  452:  {
    #####:  453:    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  454:
    #####:  455:    if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  456:    {
    #####:  457:      return ECMA_VALUE_ERROR;
        -:  458:    }
        -:  459:
    #####:  460:    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);
        -:  461:  }
        -:  462:#else /* !JERRY_BUILTIN_REGEXP */
        -:  463:  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));
        -:  464:#endif /* JERRY_BUILTIN_REGEXP */
        -:  465:
        -:  466:  ecma_object_t *func_obj_p;
        -:  467:
        -:  468:#if JERRY_ESNEXT
        1:  469:  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (bytecode_p->status_flags)))
        -:  470:  {
    #####:  471:    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p, bytecode_p, frame_ctx_p->this_binding);
        -:  472:  }
        -:  473:  else
        -:  474:  {
        1:  475:    func_obj_p = ecma_op_create_any_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  476:  }
        -:  477:#else /* !JERRY_ESNEXT */
    #####:  478:  func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  479:#endif /* JERRY_ESNEXT */
        -:  480:
        1:  481:  return ecma_make_object_value (func_obj_p);
        -:  482:} /* vm_construct_literal_object */
        -:  483:
        -:  484:/**
        -:  485: * Get implicit this value
        -:  486: *
        -:  487: * @return true - if the implicit 'this' value is updated,
        -:  488: *         false - otherwise
        -:  489: */
        -:  490:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  491:vm_get_implicit_this_value (ecma_value_t *this_value_p) /**< [in,out] this value */
        -:  492:{
    #####:  493:  if (ecma_is_value_object (*this_value_p))
        -:  494:  {
    #####:  495:    ecma_object_t *this_obj_p = ecma_get_object_from_value (*this_value_p);
        -:  496:
    #####:  497:    if (ecma_is_lexical_environment (this_obj_p))
        -:  498:    {
    #####:  499:      ecma_value_t completion_value = ecma_op_implicit_this_value (this_obj_p);
        -:  500:
    #####:  501:      JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion_value));
        -:  502:
    #####:  503:      *this_value_p = completion_value;
    #####:  504:      return true;
        -:  505:    }
        -:  506:  }
    #####:  507:  return false;
        -:  508:} /* vm_get_implicit_this_value */
        -:  509:
        -:  510:/**
        -:  511: * Special bytecode sequence for error handling while the vm_loop
        -:  512: * is preserved for an execute operation
        -:  513: */
        -:  514:static const uint8_t vm_error_byte_code_p[] = { CBC_EXT_OPCODE, CBC_EXT_ERROR };
        -:  515:
        -:  516:#if JERRY_ESNEXT
        -:  517:
        -:  518:static ecma_object_t *
    #####:  519:vm_get_class_function (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  520:{
    #####:  521:  JERRY_ASSERT (frame_ctx_p != NULL);
        -:  522:
    #####:  523:  if (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC)
        -:  524:  {
    #####:  525:    return frame_ctx_p->shared_p->function_object_p;
        -:  526:  }
        -:  527:
    #####:  528:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  529:
    #####:  530:  JERRY_ASSERT (environment_record_p != NULL);
    #####:  531:  return ecma_get_object_from_value (environment_record_p->function_object);
        -:  532:} /* vm_get_class_function */
        -:  533:
        -:  534:/**
        -:  535: * 'super(...)' function call handler.
        -:  536: */
        -:  537:static void
    #####:  538:vm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  539:{
    #####:  540:  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);
    #####:  541:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  542:
    #####:  543:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;
    #####:  544:  uint8_t opcode = byte_code_p[-2];
        -:  545:  uint32_t arguments_list_len;
        -:  546:
    #####:  547:  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;
        -:  548:
    #####:  549:  ecma_collection_t *collection_p = NULL;
        -:  550:  ecma_value_t *arguments_p;
        -:  551:
    #####:  552:  if (spread_arguments)
        -:  553:  {
    #####:  554:    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
    #####:  555:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  556:    arguments_p = collection_p->buffer_p;
    #####:  557:    arguments_list_len = collection_p->item_count;
        -:  558:  }
        -:  559:  else
        -:  560:  {
    #####:  561:    arguments_list_len = byte_code_p[-1];
    #####:  562:    arguments_p = frame_ctx_p->stack_top_p;
        -:  563:  }
        -:  564:
    #####:  565:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
        -:  566:  ecma_value_t completion_value;
        -:  567:
    #####:  568:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
    #####:  569:  JERRY_ASSERT (environment_record_p);
        -:  570:
    #####:  571:  if (!ecma_is_constructor (func_value))
        -:  572:  {
    #####:  573:    completion_value = ecma_raise_type_error (ECMA_ERR_VALUE_FOR_CLASS_HERITAGE_IS_NOT_A_CONSTRUCTOR);
        -:  574:  }
        -:  575:  else
        -:  576:  {
    #####:  577:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
    #####:  578:    completion_value =
    #####:  579:      ecma_op_function_construct (func_obj_p, JERRY_CONTEXT (current_new_target_p), arguments_p, arguments_list_len);
        -:  580:
    #####:  581:    if (!ECMA_IS_VALUE_ERROR (completion_value) && ecma_op_this_binding_is_initialized (environment_record_p))
        -:  582:    {
    #####:  583:      ecma_free_value (completion_value);
    #####:  584:      completion_value = ecma_raise_reference_error (ECMA_ERR_SUPER_CONSTRUCTOR_MAY_ONLY_BE_CALLED_ONCE);
        -:  585:    }
        -:  586:  }
        -:  587:
        -:  588:  /* Free registers. */
    #####:  589:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  590:  {
    #####:  591:    ecma_fast_free_value (arguments_p[i]);
        -:  592:  }
        -:  593:
    #####:  594:  if (collection_p != NULL)
        -:  595:  {
    #####:  596:    ecma_collection_destroy (collection_p);
        -:  597:  }
        -:  598:
    #####:  599:  if (ecma_is_value_object (completion_value))
        -:  600:  {
    #####:  601:    ecma_op_bind_this_value (environment_record_p, completion_value);
    #####:  602:    frame_ctx_p->this_binding = completion_value;
        -:  603:
    #####:  604:    ecma_value_t fields_value = opfunc_init_class_fields (vm_get_class_function (frame_ctx_p), completion_value);
        -:  605:
    #####:  606:    if (ECMA_IS_VALUE_ERROR (fields_value))
        -:  607:    {
    #####:  608:      ecma_free_value (completion_value);
    #####:  609:      completion_value = ECMA_VALUE_ERROR;
        -:  610:    }
        -:  611:  }
        -:  612:
    #####:  613:  ecma_free_value (func_value);
        -:  614:
    #####:  615:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  616:  {
        -:  617:#if JERRY_DEBUGGER
        -:  618:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  619:#endif /* JERRY_DEBUGGER */
    #####:  620:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  621:  }
        -:  622:  else
        -:  623:  {
    #####:  624:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  625:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  626:
    #####:  627:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  628:    {
    #####:  629:      ecma_fast_free_value (completion_value);
        -:  630:    }
    #####:  631:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  632:    {
    #####:  633:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  634:    }
        -:  635:    else
        -:  636:    {
    #####:  637:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  638:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  639:    }
        -:  640:  }
    #####:  641:} /* vm_super_call */
        -:  642:
        -:  643:/**
        -:  644: * Perform one of the following call/construct operation with spreaded argument list
        -:  645: *   - f(...args)
        -:  646: *   - o.f(...args)
        -:  647: *   - new O(...args)
        -:  648: */
        -:  649:static void
    #####:  650:vm_spread_operation (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  651:{
    #####:  652:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  653:
    #####:  654:  uint8_t opcode = frame_ctx_p->byte_code_p[1];
        -:  655:  ecma_value_t completion_value;
    #####:  656:  ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
        -:  657:
    #####:  658:  ecma_collection_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  659:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
    #####:  660:  bool is_call_prop = opcode >= CBC_EXT_SPREAD_CALL_PROP;
        -:  661:
    #####:  662:  if (frame_ctx_p->byte_code_p[1] == CBC_EXT_SPREAD_NEW)
        -:  663:  {
    #####:  664:    ecma_error_msg_t constructor_message_id = ecma_check_constructor (func_value);
    #####:  665:    if (constructor_message_id != ECMA_IS_VALID_CONSTRUCTOR)
        -:  666:    {
    #####:  667:      completion_value = ecma_raise_type_error (constructor_message_id);
        -:  668:    }
        -:  669:    else
        -:  670:    {
    #####:  671:      ecma_object_t *constructor_obj_p = ecma_get_object_from_value (func_value);
        -:  672:
    #####:  673:      completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  674:                                                     constructor_obj_p,
    #####:  675:                                                     collection_p->buffer_p,
        -:  676:                                                     collection_p->item_count);
        -:  677:    }
        -:  678:  }
        -:  679:  else
        -:  680:  {
    #####:  681:    ecma_value_t this_value = is_call_prop ? frame_ctx_p->stack_top_p[-2] : ECMA_VALUE_UNDEFINED;
        -:  682:
    #####:  683:    if (!ecma_is_value_object (func_value) || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  684:    {
    #####:  685:      completion_value = ecma_raise_type_error (ECMA_ERR_EXPECTED_A_FUNCTION);
        -:  686:    }
        -:  687:    else
        -:  688:    {
    #####:  689:      ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  690:
    #####:  691:      completion_value =
    #####:  692:        ecma_op_function_call (func_obj_p, this_value, collection_p->buffer_p, collection_p->item_count);
        -:  693:    }
        -:  694:
    #####:  695:    if (is_call_prop)
        -:  696:    {
    #####:  697:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
    #####:  698:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
        -:  699:    }
        -:  700:  }
        -:  701:
    #####:  702:  ecma_collection_free (collection_p);
    #####:  703:  ecma_free_value (func_value);
        -:  704:
    #####:  705:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  706:  {
        -:  707:#if JERRY_DEBUGGER
        -:  708:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  709:#endif /* JERRY_DEBUGGER */
    #####:  710:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  711:  }
        -:  712:  else
        -:  713:  {
    #####:  714:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  715:
    #####:  716:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  717:    {
    #####:  718:      ecma_fast_free_value (completion_value);
        -:  719:    }
    #####:  720:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  721:    {
    #####:  722:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  723:    }
        -:  724:    else
        -:  725:    {
    #####:  726:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  727:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  728:    }
        -:  729:
        -:  730:    /* EXT_OPCODE, SPREAD_OPCODE, BYTE_ARG */
    #####:  731:    frame_ctx_p->byte_code_p += 3;
        -:  732:  }
    #####:  733:} /* vm_spread_operation */
        -:  734:#endif /* JERRY_ESNEXT */
        -:  735:
        -:  736:/**
        -:  737: * 'Function call' opcode handler.
        -:  738: *
        -:  739: * See also: ECMA-262 v5, 11.2.3
        -:  740: */
        -:  741:static void
        1:  742:opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  743:{
        1:  744:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
        1:  745:  uint8_t opcode = byte_code_p[-1];
        -:  746:  uint32_t arguments_list_len;
        -:  747:
        1:  748:  if (opcode >= CBC_CALL0)
        -:  749:  {
        1:  750:    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);
        -:  751:  }
        -:  752:  else
        -:  753:  {
    #####:  754:    arguments_list_len = *byte_code_p++;
        -:  755:  }
        -:  756:
        1:  757:  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;
        -:  758:
        1:  759:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
        1:  760:  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;
        1:  761:  ecma_value_t func_value = stack_top_p[-1];
        -:  762:
        1:  763:  ecma_value_t completion_value =
        -:  764:    ecma_op_function_validated_call (func_value, this_value, stack_top_p, arguments_list_len);
        -:  765:
    #####:  766:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        -:  767:
        -:  768:  /* Free registers. */
    #####:  769:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  770:  {
    #####:  771:    ecma_fast_free_value (stack_top_p[i]);
        -:  772:  }
        -:  773:
    #####:  774:  if (is_call_prop)
        -:  775:  {
    #####:  776:    ecma_free_value (*(--stack_top_p));
    #####:  777:    ecma_free_value (*(--stack_top_p));
        -:  778:  }
        -:  779:
    #####:  780:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  781:  {
        -:  782:#if JERRY_DEBUGGER
        -:  783:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  784:#endif /* JERRY_DEBUGGER */
    #####:  785:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  786:  }
        -:  787:  else
        -:  788:  {
    #####:  789:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  790:    ecma_free_value (*(--stack_top_p));
    #####:  791:    uint32_t opcode_data = vm_decode_table[opcode];
        -:  792:
    #####:  793:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  794:    {
    #####:  795:      ecma_fast_free_value (completion_value);
        -:  796:    }
    #####:  797:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  798:    {
    #####:  799:      *stack_top_p++ = completion_value;
        -:  800:    }
        -:  801:    else
        -:  802:    {
    #####:  803:      ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####:  804:      VM_GET_REGISTERS (frame_ctx_p)[0] = completion_value;
        -:  805:    }
        -:  806:  }
        -:  807:
    #####:  808:  frame_ctx_p->stack_top_p = stack_top_p;
    #####:  809:} /* opfunc_call */
        -:  810:
        -:  811:/**
        -:  812: * 'Constructor call' opcode handler.
        -:  813: *
        -:  814: * See also: ECMA-262 v5, 11.2.2
        -:  815: */
        -:  816:static void
    11909:  817:opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  818:{
    11909:  819:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
    11909:  820:  uint8_t opcode = byte_code_p[-1];
        -:  821:  unsigned int arguments_list_len;
        -:  822:
    11909:  823:  if (opcode >= CBC_NEW0)
        -:  824:  {
    11909:  825:    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);
        -:  826:  }
        -:  827:  else
        -:  828:  {
    #####:  829:    arguments_list_len = *byte_code_p++;
        -:  830:  }
        -:  831:
    11909:  832:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
    11909:  833:  ecma_value_t constructor_value = stack_top_p[-1];
        -:  834:  ecma_value_t completion_value;
        -:  835:
    11909:  836:  ecma_error_msg_t constructor_message_id = ecma_check_constructor (constructor_value);
    11909:  837:  if (constructor_message_id != ECMA_IS_VALID_CONSTRUCTOR)
        -:  838:  {
    #####:  839:    completion_value = ecma_raise_type_error (constructor_message_id);
        -:  840:  }
        -:  841:  else
        -:  842:  {
    11909:  843:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);
        -:  844:
    11909:  845:    completion_value =
        -:  846:      ecma_op_function_construct (constructor_obj_p, constructor_obj_p, stack_top_p, arguments_list_len);
        -:  847:  }
        -:  848:
        -:  849:  /* Free registers. */
    #####:  850:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  851:  {
    #####:  852:    ecma_fast_free_value (stack_top_p[i]);
        -:  853:  }
        -:  854:
    #####:  855:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  856:  {
        -:  857:#if JERRY_DEBUGGER
        -:  858:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  859:#endif /* JERRY_DEBUGGER */
    #####:  860:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  861:  }
        -:  862:  else
        -:  863:  {
    #####:  864:    ecma_free_value (stack_top_p[-1]);
    #####:  865:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  866:    stack_top_p[-1] = completion_value;
        -:  867:  }
        -:  868:
    #####:  869:  frame_ctx_p->stack_top_p = stack_top_p;
    #####:  870:} /* opfunc_construct */
        -:  871:
        -:  872:/**
        -:  873: * Read literal index from the byte code stream into destination.
        -:  874: *
        -:  875: * @param destination destination
        -:  876: */
        -:  877:#define READ_LITERAL_INDEX(destination)                                                      \
        -:  878:  do                                                                                         \
        -:  879:  {                                                                                          \
        -:  880:    (destination) = *byte_code_p++;                                                          \
        -:  881:    if ((destination) >= encoding_limit)                                                     \
        -:  882:    {                                                                                        \
        -:  883:      (destination) = (uint16_t) ((((destination) << 8) | *byte_code_p++) - encoding_delta); \
        -:  884:    }                                                                                        \
        -:  885:  } while (0)
        -:  886:
        -:  887:/**
        -:  888: * Get literal value by literal index.
        -:  889: *
        -:  890: * @param literal_index literal index
        -:  891: * @param target_value target value
        -:  892: *
        -:  893: * TODO: For performance reasons, we define this as a macro.
        -:  894: * When we are able to construct a function with similar speed,
        -:  895: * we can remove this macro.
        -:  896: */
        -:  897:#define READ_LITERAL(literal_index, target_value)                                                 \
        -:  898:  do                                                                                              \
        -:  899:  {                                                                                               \
        -:  900:    if ((literal_index) < ident_end)                                                              \
        -:  901:    {                                                                                             \
        -:  902:      if ((literal_index) < register_end)                                                         \
        -:  903:      {                                                                                           \
        -:  904:        /* Note: There should be no specialization for arguments. */                              \
        -:  905:        (target_value) = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));     \
        -:  906:      }                                                                                           \
        -:  907:      else                                                                                        \
        -:  908:      {                                                                                           \
        -:  909:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);      \
        -:  910:                                                                                                  \
        -:  911:        result = ecma_op_resolve_reference_value (frame_ctx_p->lex_env_p, name_p);                \
        -:  912:                                                                                                  \
        -:  913:        if (ECMA_IS_VALUE_ERROR (result))                                                         \
        -:  914:        {                                                                                         \
        -:  915:          goto error;                                                                             \
        -:  916:        }                                                                                         \
        -:  917:        (target_value) = result;                                                                  \
        -:  918:      }                                                                                           \
        -:  919:    }                                                                                             \
        -:  920:    else if (literal_index < const_literal_end)                                                   \
        -:  921:    {                                                                                             \
        -:  922:      (target_value) = ecma_fast_copy_value (literal_start_p[literal_index]);                     \
        -:  923:    }                                                                                             \
        -:  924:    else                                                                                          \
        -:  925:    {                                                                                             \
        -:  926:      /* Object construction. */                                                                  \
        -:  927:      (target_value) = vm_construct_literal_object (frame_ctx_p, literal_start_p[literal_index]); \
        -:  928:    }                                                                                             \
        -:  929:  } while (0)
        -:  930:
        -:  931:/**
        -:  932: * Store the original value for post increase/decrease operators
        -:  933: *
        -:  934: * @param value original value
        -:  935: */
        -:  936:#define POST_INCREASE_DECREASE_PUT_RESULT(value)                                                             \
        -:  937:  if (opcode_data & VM_OC_PUT_STACK)                                                                         \
        -:  938:  {                                                                                                          \
        -:  939:    if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG)                                                  \
        -:  940:    {                                                                                                        \
        -:  941:      JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT); \
        -:  942:      *stack_top_p++ = (value);                                                                              \
        -:  943:    }                                                                                                        \
        -:  944:    else                                                                                                     \
        -:  945:    {                                                                                                        \
        -:  946:      /* The parser ensures there is enough space for the                                                    \
        -:  947:       * extra value on the stack. See js-parser-expr.c. */                                                  \
        -:  948:      JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT || opcode == CBC_POST_DECR_PUSH_RESULT);             \
        -:  949:      stack_top_p++;                                                                                         \
        -:  950:      stack_top_p[-1] = stack_top_p[-2];                                                                     \
        -:  951:      stack_top_p[-2] = stack_top_p[-3];                                                                     \
        -:  952:      stack_top_p[-3] = (value);                                                                             \
        -:  953:    }                                                                                                        \
        -:  954:    opcode_data &= (uint32_t) ~VM_OC_PUT_STACK;                                                              \
        -:  955:  }                                                                                                          \
        -:  956:  else                                                                                                       \
        -:  957:  {                                                                                                          \
        -:  958:    JERRY_ASSERT (opcode_data &VM_OC_PUT_BLOCK);                                                             \
        -:  959:    ecma_free_value (VM_GET_REGISTER (frame_ctx_p, 0));                                                      \
        -:  960:    VM_GET_REGISTERS (frame_ctx_p)[0] = (value);                                                             \
        -:  961:    opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK;                                                              \
        -:  962:  }
        -:  963:
        -:  964:/**
        -:  965: * Get the end of the existing topmost context
        -:  966: */
        -:  967:#define VM_LAST_CONTEXT_END() (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth)
        -:  968:
        -:  969:/**
        -:  970: * Run generic byte code.
        -:  971: *
        -:  972: * @return ecma value
        -:  973: */
        -:  974:static ecma_value_t JERRY_ATTR_NOINLINE
    11910:  975:vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  976:{
    11910:  977:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
    11910:  978:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;
    11910:  979:  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;
        -:  980:
    11910:  981:  ecma_value_t *stack_top_p;
        -:  982:  uint16_t encoding_limit;
        -:  983:  uint16_t encoding_delta;
        -:  984:  uint16_t register_end;
        -:  985:  uint16_t ident_end;
        -:  986:  uint16_t const_literal_end;
    11910:  987:  int32_t branch_offset = 0;
    11910:  988:  uint8_t branch_offset_length = 0;
    11910:  989:  ecma_value_t left_value;
        -:  990:  ecma_value_t right_value;
    11910:  991:  ecma_value_t result = ECMA_VALUE_EMPTY;
    11910:  992:  bool is_strict = ((bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);
        -:  993:
        -:  994:  /* Prepare for byte code execution. */
    11910:  995:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -:  996:  {
    11910:  997:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
    11910:  998:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -:  999:  }
        -: 1000:  else
        -: 1001:  {
    #####: 1002:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1003:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1004:  }
        -: 1005:
    11910: 1006:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1007:  {
    #####: 1008:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);
    #####: 1009:    register_end = args_p->register_end;
    #####: 1010:    ident_end = args_p->ident_end;
    #####: 1011:    const_literal_end = args_p->const_literal_end;
        -: 1012:  }
        -: 1013:  else
        -: 1014:  {
    11910: 1015:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);
    11910: 1016:    register_end = args_p->register_end;
    11910: 1017:    ident_end = args_p->ident_end;
    11910: 1018:    const_literal_end = args_p->const_literal_end;
        -: 1019:  }
        -: 1020:
    11910: 1021:  stack_top_p = frame_ctx_p->stack_top_p;
        -: 1022:
        -: 1023:  /* Outer loop for exception handling. */
    #####: 1024:  while (true)
        -: 1025:  {
        -: 1026:    /* Internal loop for byte code execution. */
        -: 1027:    while (true)
    11913: 1028:    {
    23823: 1029:      const uint8_t *byte_code_start_p = byte_code_p;
    23823: 1030:      uint8_t opcode = *byte_code_p++;
    23823: 1031:      uint32_t opcode_data = opcode;
        -: 1032:
    23823: 1033:      if (opcode == CBC_EXT_OPCODE)
        -: 1034:      {
        1: 1035:        opcode = *byte_code_p++;
        1: 1036:        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);
        -: 1037:      }
        -: 1038:
    23823: 1039:      opcode_data = vm_decode_table[opcode_data];
        -: 1040:
    23823: 1041:      left_value = ECMA_VALUE_UNDEFINED;
    23823: 1042:      right_value = ECMA_VALUE_UNDEFINED;
        -: 1043:
    23823: 1044:      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);
        -: 1045:
    23823: 1046:      if (operands >= VM_OC_GET_LITERAL)
        -: 1047:      {
        -: 1048:        uint16_t literal_index;
    11910: 1049:        READ_LITERAL_INDEX (literal_index);
    11910: 1050:        READ_LITERAL (literal_index, left_value);
        -: 1051:
    11910: 1052:        if (operands != VM_OC_GET_LITERAL)
        -: 1053:        {
    #####: 1054:          switch (operands)
        -: 1055:          {
    #####: 1056:            case VM_OC_GET_LITERAL_LITERAL:
        -: 1057:            {
        -: 1058:              uint16_t second_literal_index;
    #####: 1059:              READ_LITERAL_INDEX (second_literal_index);
    #####: 1060:              READ_LITERAL (second_literal_index, right_value);
    #####: 1061:              break;
        -: 1062:            }
    #####: 1063:            case VM_OC_GET_STACK_LITERAL:
        -: 1064:            {
    #####: 1065:              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1066:              right_value = left_value;
    #####: 1067:              left_value = *(--stack_top_p);
    #####: 1068:              break;
        -: 1069:            }
    #####: 1070:            default:
        -: 1071:            {
    #####: 1072:              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);
        -: 1073:
    #####: 1074:              right_value = left_value;
    #####: 1075:              left_value = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1076:              break;
        -: 1077:            }
        -: 1078:          }
    11910: 1079:        }
        -: 1080:      }
    11913: 1081:      else if (operands >= VM_OC_GET_STACK)
        -: 1082:      {
    #####: 1083:        JERRY_ASSERT (operands == VM_OC_GET_STACK || operands == VM_OC_GET_STACK_STACK);
        -: 1084:
    #####: 1085:        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1086:        left_value = *(--stack_top_p);
        -: 1087:
    #####: 1088:        if (operands == VM_OC_GET_STACK_STACK)
        -: 1089:        {
    #####: 1090:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1091:          right_value = left_value;
    #####: 1092:          left_value = *(--stack_top_p);
        -: 1093:        }
        -: 1094:      }
    11913: 1095:      else if (operands == VM_OC_GET_BRANCH)
        -: 1096:      {
        1: 1097:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        1: 1098:        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 1099:
        1: 1100:        branch_offset = *(byte_code_p++);
        -: 1101:
        1: 1102:        if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 1103:        {
    #####: 1104:          branch_offset <<= 8;
    #####: 1105:          branch_offset |= *(byte_code_p++);
        -: 1106:
    #####: 1107:          if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 1108:          {
    #####: 1109:            branch_offset <<= 8;
    #####: 1110:            branch_offset |= *(byte_code_p++);
        -: 1111:          }
        -: 1112:        }
        -: 1113:
        1: 1114:        if (opcode_data & VM_OC_BACKWARD_BRANCH)
        -: 1115:        {
        -: 1116:#if JERRY_VM_HALT
    #####: 1117:          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)
        -: 1118:          {
    #####: 1119:            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));
        -: 1120:
    #####: 1121:            if (ecma_is_value_undefined (result))
        -: 1122:            {
    #####: 1123:              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);
        -: 1124:            }
        -: 1125:            else
        -: 1126:            {
    #####: 1127:              JERRY_CONTEXT (vm_exec_stop_counter) = 1;
        -: 1128:
    #####: 1129:              if (ecma_is_value_exception (result))
        -: 1130:              {
    #####: 1131:                ecma_throw_exception (result);
        -: 1132:              }
        -: 1133:              else
        -: 1134:              {
    #####: 1135:                jcontext_raise_exception (result);
        -: 1136:              }
        -: 1137:
        -: 1138:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 1139:              jcontext_set_abort_flag (true);
    #####: 1140:              result = ECMA_VALUE_ERROR;
    #####: 1141:              goto error;
        -: 1142:            }
        -: 1143:          }
        -: 1144:#endif /* JERRY_VM_HALT */
        -: 1145:
    #####: 1146:          branch_offset = -branch_offset;
        -: 1147:        }
        -: 1148:      }
        -: 1149:
    23823: 1150:      switch (VM_OC_GROUP_GET_INDEX (opcode_data))
        -: 1151:      {
    #####: 1152:        case VM_OC_POP:
        -: 1153:        {
    #####: 1154:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1155:          ecma_free_value (*(--stack_top_p));
    #####: 1156:          continue;
        -: 1157:        }
    #####: 1158:        case VM_OC_POP_BLOCK:
        -: 1159:        {
    #####: 1160:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 1161:          VM_GET_REGISTERS (frame_ctx_p)[0] = *(--stack_top_p);
    #####: 1162:          continue;
        -: 1163:        }
    11910: 1164:        case VM_OC_PUSH:
        -: 1165:        {
    11910: 1166:          *stack_top_p++ = left_value;
    11910: 1167:          continue;
        -: 1168:        }
    #####: 1169:        case VM_OC_PUSH_TWO:
        -: 1170:        {
    #####: 1171:          *stack_top_p++ = left_value;
    #####: 1172:          *stack_top_p++ = right_value;
    #####: 1173:          continue;
        -: 1174:        }
    #####: 1175:        case VM_OC_PUSH_THREE:
        -: 1176:        {
        -: 1177:          uint16_t literal_index;
        -: 1178:
    #####: 1179:          *stack_top_p++ = left_value;
    #####: 1180:          left_value = ECMA_VALUE_UNDEFINED;
        -: 1181:
    #####: 1182:          READ_LITERAL_INDEX (literal_index);
    #####: 1183:          READ_LITERAL (literal_index, left_value);
        -: 1184:
    #####: 1185:          *stack_top_p++ = right_value;
    #####: 1186:          *stack_top_p++ = left_value;
    #####: 1187:          continue;
        -: 1188:        }
    #####: 1189:        case VM_OC_PUSH_UNDEFINED:
        -: 1190:        {
    #####: 1191:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 1192:          continue;
        -: 1193:        }
    #####: 1194:        case VM_OC_PUSH_TRUE:
        -: 1195:        {
    #####: 1196:          *stack_top_p++ = ECMA_VALUE_TRUE;
    #####: 1197:          continue;
        -: 1198:        }
    #####: 1199:        case VM_OC_PUSH_FALSE:
        -: 1200:        {
    #####: 1201:          *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 1202:          continue;
        -: 1203:        }
    #####: 1204:        case VM_OC_PUSH_NULL:
        -: 1205:        {
    #####: 1206:          *stack_top_p++ = ECMA_VALUE_NULL;
    #####: 1207:          continue;
        -: 1208:        }
    #####: 1209:        case VM_OC_PUSH_THIS:
        -: 1210:        {
    #####: 1211:          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1212:          continue;
        -: 1213:        }
    #####: 1214:        case VM_OC_PUSH_0:
        -: 1215:        {
    #####: 1216:          *stack_top_p++ = ecma_make_integer_value (0);
    #####: 1217:          continue;
        -: 1218:        }
    #####: 1219:        case VM_OC_PUSH_POS_BYTE:
        -: 1220:        {
    #####: 1221:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1222:          *stack_top_p++ = ecma_make_integer_value (number + 1);
    #####: 1223:          continue;
        -: 1224:        }
    #####: 1225:        case VM_OC_PUSH_NEG_BYTE:
        -: 1226:        {
    #####: 1227:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1228:          *stack_top_p++ = ecma_make_integer_value (-(number + 1));
    #####: 1229:          continue;
        -: 1230:        }
    #####: 1231:        case VM_OC_PUSH_LIT_0:
        -: 1232:        {
    #####: 1233:          stack_top_p[0] = left_value;
    #####: 1234:          stack_top_p[1] = ecma_make_integer_value (0);
    #####: 1235:          stack_top_p += 2;
    #####: 1236:          continue;
        -: 1237:        }
    #####: 1238:        case VM_OC_PUSH_LIT_POS_BYTE:
        -: 1239:        {
    #####: 1240:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1241:          stack_top_p[0] = left_value;
    #####: 1242:          stack_top_p[1] = ecma_make_integer_value (number + 1);
    #####: 1243:          stack_top_p += 2;
    #####: 1244:          continue;
        -: 1245:        }
    #####: 1246:        case VM_OC_PUSH_LIT_NEG_BYTE:
        -: 1247:        {
    #####: 1248:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1249:          stack_top_p[0] = left_value;
    #####: 1250:          stack_top_p[1] = ecma_make_integer_value (-(number + 1));
    #####: 1251:          stack_top_p += 2;
    #####: 1252:          continue;
        -: 1253:        }
    #####: 1254:        case VM_OC_PUSH_OBJECT:
        -: 1255:        {
    #####: 1256:          ecma_object_t *obj_p =
    #####: 1257:            ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE), 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 1258:
    #####: 1259:          *stack_top_p++ = ecma_make_object_value (obj_p);
    #####: 1260:          continue;
        -: 1261:        }
    #####: 1262:        case VM_OC_PUSH_NAMED_FUNC_EXPR:
        -: 1263:        {
    #####: 1264:          ecma_object_t *func_p = ecma_get_object_from_value (left_value);
        -: 1265:
    #####: 1266:          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);
        -: 1267:
    #####: 1268:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
        -: 1269:
    #####: 1270:          JERRY_ASSERT (frame_ctx_p->lex_env_p
        -: 1271:                        == ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));
        -: 1272:
    #####: 1273:          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1274:
    #####: 1275:          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);
        -: 1276:
    #####: 1277:          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);
        -: 1278:
    #####: 1279:          ecma_free_value (right_value);
    #####: 1280:          ecma_deref_object (name_lex_env);
    #####: 1281:          *stack_top_p++ = left_value;
    #####: 1282:          continue;
        -: 1283:        }
    #####: 1284:        case VM_OC_CREATE_BINDING:
        -: 1285:        {
        -: 1286:#if !JERRY_ESNEXT
        -: 1287:          JERRY_ASSERT (opcode == CBC_CREATE_VAR);
        -: 1288:#endif /* !JERRY_ESNEXT */
        -: 1289:
        -: 1290:          uint32_t literal_index;
        -: 1291:
    #####: 1292:          READ_LITERAL_INDEX (literal_index);
        -: 1293:
    #####: 1294:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1295:
    #####: 1296:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1297:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1298:
    #####: 1299:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1300:
        -: 1301:#if JERRY_ESNEXT
    #####: 1302:          if (opcode == CBC_CREATE_LET)
        -: 1303:          {
    #####: 1304:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1305:          }
    #####: 1306:          else if (opcode == CBC_CREATE_CONST)
        -: 1307:          {
    #####: 1308:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1309:          }
        -: 1310:
        -: 1311:          ecma_property_value_t *property_value_p;
    #####: 1312:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1313:
    #####: 1314:          if (opcode != CBC_CREATE_VAR)
        -: 1315:          {
    #####: 1316:            property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 1317:          }
        -: 1318:#else /* !JERRY_ESNEXT */
    #####: 1319:          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1320:#endif /* JERRY_ESNEXT */
        -: 1321:
    #####: 1322:          continue;
        -: 1323:        }
        1: 1324:        case VM_OC_VAR_EVAL:
        -: 1325:        {
        -: 1326:          uint32_t literal_index;
        1: 1327:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1328:
        1: 1329:          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)
        -: 1330:          {
        -: 1331:            uint32_t value_index;
        1: 1332:            READ_LITERAL_INDEX (value_index);
        1: 1333:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1334:
        1: 1335:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
        -: 1336:          }
        -: 1337:
        1: 1338:          READ_LITERAL_INDEX (literal_index);
        1: 1339:          JERRY_ASSERT (literal_index >= register_end);
        -: 1340:
        1: 1341:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        1: 1342:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1343:
        2: 1344:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1345:          {
        -: 1346:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
    #####: 1347:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1348:            {
    #####: 1349:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1350:
    #####: 1351:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1352:            }
        -: 1353:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1354:
    #####: 1355:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1356:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1357:          }
        -: 1358:
        -: 1359:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
        1: 1360:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1361:          {
    #####: 1362:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1363:
    #####: 1364:            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1365:          }
        -: 1366:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1367:
        -: 1368:          /* 'Variable declaration' */
        1: 1369:          result = ecma_op_has_binding (lex_env_p, name_p);
        -: 1370:
        -: 1371:#if JERRY_BUILTIN_PROXY
        1: 1372:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1373:          {
    #####: 1374:            goto error;
        -: 1375:          }
        -: 1376:#endif /* JERRY_BUILTIN_PROXY */
        -: 1377:
        1: 1378:          ecma_property_t *prop_p = NULL;
        -: 1379:
        1: 1380:          if (ecma_is_value_false (result))
        -: 1381:          {
        1: 1382:            bool is_configurable = (frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL) != 0;
        1: 1383:            prop_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_configurable);
        -: 1384:
        1: 1385:            if (JERRY_UNLIKELY (prop_p == ECMA_PROPERTY_POINTER_ERROR))
        -: 1386:            {
    #####: 1387:              result = ECMA_VALUE_ERROR;
    #####: 1388:              goto error;
        -: 1389:            }
        -: 1390:          }
        -: 1391:
        1: 1392:          if (lit_value != ECMA_VALUE_UNDEFINED)
        -: 1393:          {
        1: 1394:            JERRY_ASSERT (ecma_is_value_object (lit_value));
        -: 1395:
        1: 1396:            if (prop_p != NULL)
        -: 1397:            {
    #####: 1398:              JERRY_ASSERT (ecma_is_value_undefined (ECMA_PROPERTY_VALUE_PTR (prop_p)->value));
    #####: 1399:              JERRY_ASSERT (ecma_is_property_writable (*prop_p));
    #####: 1400:              ECMA_PROPERTY_VALUE_PTR (prop_p)->value = lit_value;
    #####: 1401:              ecma_free_object (lit_value);
        -: 1402:            }
        -: 1403:            else
        -: 1404:            {
        1: 1405:              result = ecma_op_put_value_lex_env_base (lex_env_p, name_p, is_strict, lit_value);
        1: 1406:              ecma_free_object (lit_value);
        -: 1407:
        1: 1408:              if (ECMA_IS_VALUE_ERROR (result))
        -: 1409:              {
    #####: 1410:                goto error;
        -: 1411:              }
        -: 1412:            }
        -: 1413:          }
        1: 1414:          continue;
        -: 1415:        }
        -: 1416:#if JERRY_ESNEXT
    #####: 1417:        case VM_OC_EXT_VAR_EVAL:
        -: 1418:        {
        -: 1419:          uint32_t literal_index;
    #####: 1420:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1421:
    #####: 1422:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1423:
    #####: 1424:          if (opcode == CBC_EXT_CREATE_VAR_FUNC_EVAL)
        -: 1425:          {
        -: 1426:            uint32_t value_index;
    #####: 1427:            READ_LITERAL_INDEX (value_index);
    #####: 1428:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1429:
    #####: 1430:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
        -: 1431:          }
        -: 1432:
    #####: 1433:          READ_LITERAL_INDEX (literal_index);
    #####: 1434:          JERRY_ASSERT (literal_index >= register_end);
        -: 1435:
    #####: 1436:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1437:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1438:          ecma_object_t *prev_lex_env_p = NULL;
        -: 1439:
    #####: 1440:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1441:          {
        -: 1442:#if !(defined JERRY_NDEBUG)
    #####: 1443:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1444:            {
    #####: 1445:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1446:
    #####: 1447:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1448:            }
        -: 1449:#endif /* !JERRY_NDEBUG */
        -: 1450:
    #####: 1451:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1452:            prev_lex_env_p = lex_env_p;
    #####: 1453:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1454:          }
        -: 1455:
    #####: 1456:          JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1457:          JERRY_ASSERT (prev_lex_env_p != NULL
        -: 1458:                        && ecma_get_lex_env_type (prev_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1459:
    #####: 1460:          ecma_property_t *property_p = ecma_find_named_property (prev_lex_env_p, name_p);
        -: 1461:          ecma_property_value_t *property_value_p;
        -: 1462:
    #####: 1463:          if (property_p == NULL)
        -: 1464:          {
    #####: 1465:            property_value_p =
        -: 1466:              ecma_create_named_data_property (prev_lex_env_p, name_p, ECMA_PROPERTY_CONFIGURABLE_WRITABLE, NULL);
        -: 1467:
    #####: 1468:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1469:            {
    #####: 1470:              continue;
        -: 1471:            }
        -: 1472:          }
        -: 1473:          else
        -: 1474:          {
    #####: 1475:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1476:            {
    #####: 1477:              continue;
        -: 1478:            }
        -: 1479:
    #####: 1480:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1481:            ecma_free_value_if_not_object (property_value_p->value);
        -: 1482:          }
        -: 1483:
    #####: 1484:          property_value_p->value = lit_value;
    #####: 1485:          ecma_deref_object (ecma_get_object_from_value (lit_value));
    #####: 1486:          continue;
        -: 1487:        }
        -: 1488:#endif /* JERRY_ESNEXT */
    #####: 1489:        case VM_OC_CREATE_ARGUMENTS:
        -: 1490:        {
        -: 1491:          uint32_t literal_index;
    #####: 1492:          READ_LITERAL_INDEX (literal_index);
        -: 1493:
    #####: 1494:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 1495:
    #####: 1496:          result = ecma_op_create_arguments_object ((vm_frame_ctx_shared_args_t *) (frame_ctx_p->shared_p),
        -: 1497:                                                    frame_ctx_p->lex_env_p);
        -: 1498:
    #####: 1499:          if (literal_index < register_end)
        -: 1500:          {
    #####: 1501:            JERRY_ASSERT (VM_GET_REGISTER (frame_ctx_p, literal_index) == ECMA_VALUE_UNDEFINED);
    #####: 1502:            VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
    #####: 1503:            continue;
        -: 1504:          }
        -: 1505:
    #####: 1506:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1507:
    #####: 1508:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1509:
    #####: 1510:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1511:          ecma_property_value_t *property_value_p;
        -: 1512:
    #####: 1513:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
    #####: 1514:          property_value_p->value = result;
        -: 1515:
    #####: 1516:          ecma_deref_object (ecma_get_object_from_value (result));
    #####: 1517:          continue;
        -: 1518:        }
        -: 1519:#if JERRY_SNAPSHOT_EXEC
    #####: 1520:        case VM_OC_SET_BYTECODE_PTR:
        -: 1521:        {
    #####: 1522:          memcpy (&byte_code_p, byte_code_p++, sizeof (uintptr_t));
    #####: 1523:          frame_ctx_p->byte_code_start_p = byte_code_p;
    #####: 1524:          continue;
        -: 1525:        }
        -: 1526:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 1527:        case VM_OC_INIT_ARG_OR_FUNC:
        -: 1528:        {
        -: 1529:          uint32_t literal_index, value_index;
        -: 1530:          ecma_value_t lit_value;
    #####: 1531:          bool release = false;
        -: 1532:
    #####: 1533:          READ_LITERAL_INDEX (value_index);
        -: 1534:
    #####: 1535:          if (value_index < register_end)
        -: 1536:          {
        -: 1537:            /* Take (not copy) the reference. */
    #####: 1538:            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));
        -: 1539:          }
        -: 1540:          else
        -: 1541:          {
    #####: 1542:            lit_value = vm_construct_literal_object (frame_ctx_p, literal_start_p[value_index]);
    #####: 1543:            release = true;
        -: 1544:          }
        -: 1545:
    #####: 1546:          READ_LITERAL_INDEX (literal_index);
        -: 1547:
    #####: 1548:          JERRY_ASSERT (value_index != literal_index);
    #####: 1549:          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);
        -: 1550:
    #####: 1551:          if (literal_index < register_end)
        -: 1552:          {
    #####: 1553:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 1554:            JERRY_ASSERT (release);
    #####: 1555:            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;
    #####: 1556:            continue;
        -: 1557:          }
        -: 1558:
    #####: 1559:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1560:
    #####: 1561:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1562:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1563:
        -: 1564:          ecma_property_value_t *property_value_p;
    #####: 1565:          property_value_p =
    #####: 1566:            ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1567:
    #####: 1568:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 1569:          property_value_p->value = lit_value;
        -: 1570:
    #####: 1571:          if (release)
        -: 1572:          {
    #####: 1573:            ecma_deref_object (ecma_get_object_from_value (lit_value));
        -: 1574:          }
    #####: 1575:          continue;
        -: 1576:        }
        -: 1577:#if JERRY_ESNEXT
        1: 1578:        case VM_OC_CHECK_VAR:
        -: 1579:        {
        1: 1580:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1581:                        == CBC_FUNCTION_SCRIPT);
        -: 1582:
        -: 1583:          uint32_t literal_index;
        1: 1584:          READ_LITERAL_INDEX (literal_index);
        -: 1585:
        1: 1586:          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)
        -: 1587:          {
        1: 1588:            continue;
        -: 1589:          }
        -: 1590:
    #####: 1591:          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1592:          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);
        -: 1593:
    #####: 1594:          if (binding_p != NULL)
        -: 1595:          {
    #####: 1596:            result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
    #####: 1597:            goto error;
        -: 1598:          }
        -: 1599:
    #####: 1600:          continue;
        -: 1601:        }
    #####: 1602:        case VM_OC_CHECK_LET:
        -: 1603:        {
    #####: 1604:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1605:                        == CBC_FUNCTION_SCRIPT);
        -: 1606:
        -: 1607:          uint32_t literal_index;
    #####: 1608:          READ_LITERAL_INDEX (literal_index);
        -: 1609:
    #####: 1610:          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1611:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1612:
    #####: 1613:          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1614:          {
    #####: 1615:            result = opfunc_lexical_scope_has_restricted_binding (frame_ctx_p, literal_name_p);
        -: 1616:
    #####: 1617:            if (!ecma_is_value_false (result))
        -: 1618:            {
    #####: 1619:              if (ecma_is_value_true (result))
        -: 1620:              {
    #####: 1621:                result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
        -: 1622:              }
        -: 1623:
    #####: 1624:              JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####: 1625:              goto error;
        -: 1626:            }
        -: 1627:
    #####: 1628:            continue;
        -: 1629:          }
        -: 1630:
    #####: 1631:          result = ecma_op_has_binding (lex_env_p, literal_name_p);
        -: 1632:
        -: 1633:#if JERRY_BUILTIN_PROXY
    #####: 1634:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1635:          {
    #####: 1636:            goto error;
        -: 1637:          }
        -: 1638:#endif /* JERRY_BUILTIN_PROXY */
        -: 1639:
    #####: 1640:          if (ecma_is_value_true (result))
        -: 1641:          {
    #####: 1642:            result = ecma_raise_syntax_error (ECMA_ERR_LOCAL_VARIABLE_IS_REDECLARED);
    #####: 1643:            goto error;
        -: 1644:          }
        -: 1645:
    #####: 1646:          continue;
        -: 1647:        }
    #####: 1648:        case VM_OC_ASSIGN_LET_CONST:
        -: 1649:        {
        -: 1650:          uint32_t literal_index;
    #####: 1651:          READ_LITERAL_INDEX (literal_index);
        -: 1652:
    #####: 1653:          JERRY_ASSERT (literal_index >= register_end);
    #####: 1654:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE
        -: 1655:                        || (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
        -: 1656:                            && ECMA_LEX_ENV_CLASS_IS_MODULE (frame_ctx_p->lex_env_p)));
        -: 1657:
    #####: 1658:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1659:          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);
        -: 1660:
    #####: 1661:          JERRY_ASSERT (property_p != NULL && ECMA_PROPERTY_IS_RAW_DATA (*property_p)
        -: 1662:                        && (*property_p & ECMA_PROPERTY_FLAG_DATA));
    #####: 1663:          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);
        -: 1664:
    #####: 1665:          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;
        -: 1666:
    #####: 1667:          if (ecma_is_value_object (left_value))
        -: 1668:          {
    #####: 1669:            ecma_deref_object (ecma_get_object_from_value (left_value));
        -: 1670:          }
    #####: 1671:          continue;
        -: 1672:        }
    #####: 1673:        case VM_OC_INIT_BINDING:
        -: 1674:        {
        -: 1675:          uint32_t literal_index;
        -: 1676:
    #####: 1677:          READ_LITERAL_INDEX (literal_index);
        -: 1678:
    #####: 1679:          JERRY_ASSERT (literal_index >= register_end);
        -: 1680:
    #####: 1681:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1682:
    #####: 1683:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1684:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1685:
    #####: 1686:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1687:
    #####: 1688:          if (opcode == CBC_INIT_LET)
        -: 1689:          {
    #####: 1690:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1691:          }
    #####: 1692:          else if (opcode == CBC_INIT_CONST)
        -: 1693:          {
    #####: 1694:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1695:          }
        -: 1696:
        -: 1697:          ecma_property_value_t *property_value_p;
    #####: 1698:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1699:
    #####: 1700:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -: 1701:
    #####: 1702:          ecma_value_t value = *(--stack_top_p);
        -: 1703:
    #####: 1704:          property_value_p->value = value;
    #####: 1705:          ecma_deref_if_object (value);
    #####: 1706:          continue;
        -: 1707:        }
    #####: 1708:        case VM_OC_THROW_CONST_ERROR:
        -: 1709:        {
    #####: 1710:          result = ecma_raise_type_error (ECMA_ERR_CONSTANT_BINDINGS_CANNOT_BE_REASSIGNED);
    #####: 1711:          goto error;
        -: 1712:        }
    #####: 1713:        case VM_OC_COPY_TO_GLOBAL:
        -: 1714:        {
        -: 1715:          uint32_t literal_index;
    #####: 1716:          READ_LITERAL_INDEX (literal_index);
        -: 1717:
    #####: 1718:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1719:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1720:
    #####: 1721:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1722:          {
        -: 1723:#ifndef JERRY_NDEBUG
    #####: 1724:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1725:            {
    #####: 1726:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1727:
    #####: 1728:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1729:            }
        -: 1730:#endif /* !JERRY_NDEBUG */
        -: 1731:
    #####: 1732:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1733:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1734:          }
        -: 1735:
    #####: 1736:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1737:          {
    #####: 1738:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1739:            ecma_property_value_t *prop_value_p;
        -: 1740:
    #####: 1741:            if (property_p == NULL)
        -: 1742:            {
    #####: 1743:              prop_value_p = ecma_create_named_data_property (lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1744:            }
        -: 1745:            else
        -: 1746:            {
        -: 1747:#ifndef JERRY_NDEBUG
    #####: 1748:              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1749:#endif /* !JERRY_NDEBUG */
    #####: 1750:              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1751:            }
        -: 1752:
    #####: 1753:            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);
        -: 1754:          }
        -: 1755:          else
        -: 1756:          {
    #####: 1757:            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);
        -: 1758:
    #####: 1759:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1760:            {
    #####: 1761:              goto error;
        -: 1762:            }
        -: 1763:          }
        -: 1764:
    #####: 1765:          goto free_left_value;
        -: 1766:        }
    #####: 1767:        case VM_OC_COPY_FROM_ARG:
        -: 1768:        {
        -: 1769:          uint32_t literal_index;
    #####: 1770:          READ_LITERAL_INDEX (literal_index);
    #####: 1771:          JERRY_ASSERT (literal_index >= register_end);
        -: 1772:
    #####: 1773:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1774:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1775:          ecma_object_t *arg_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1776:
    #####: 1777:          JERRY_ASSERT ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1778:                        && ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1779:          JERRY_ASSERT (arg_lex_env_p != NULL && !(arg_lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1780:                        && ecma_get_lex_env_type (arg_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1781:
        -: 1782:          ecma_property_value_t *property_value_p;
    #####: 1783:          property_value_p = ecma_create_named_data_property (lex_env_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1784:
    #####: 1785:          ecma_property_t *property_p = ecma_find_named_property (arg_lex_env_p, name_p);
    #####: 1786:          JERRY_ASSERT (property_p != NULL);
        -: 1787:
    #####: 1788:          ecma_property_value_t *arg_prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1789:          property_value_p->value = ecma_copy_value_if_not_object (arg_prop_value_p->value);
    #####: 1790:          continue;
        -: 1791:        }
    #####: 1792:        case VM_OC_CLONE_CONTEXT:
        -: 1793:        {
    #####: 1794:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1795:
    #####: 1796:          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);
    #####: 1797:          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);
    #####: 1798:          continue;
        -: 1799:        }
    #####: 1800:        case VM_OC_SET__PROTO__:
        -: 1801:        {
    #####: 1802:          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);
    #####: 1803:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1804:          {
    #####: 1805:            goto error;
        -: 1806:          }
    #####: 1807:          goto free_left_value;
        -: 1808:        }
    #####: 1809:        case VM_OC_CLASS_CALL_STATIC_BLOCK:
        -: 1810:        {
    #####: 1811:          result = ecma_op_function_call (ecma_get_object_from_value (left_value), frame_ctx_p->this_binding, NULL, 0);
        -: 1812:
    #####: 1813:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1814:          {
    #####: 1815:            goto error;
        -: 1816:          }
    #####: 1817:          goto free_left_value;
        -: 1818:        }
    #####: 1819:        case VM_OC_PUSH_STATIC_FIELD_FUNC:
        -: 1820:        {
    #####: 1821:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1822:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_FIELD_FUNC
        -: 1823:                            || byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC));
        -: 1824:
    #####: 1825:          bool push_computed = (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC);
    #####: 1826:          ecma_value_t value = stack_top_p[-1];
        -: 1827:
    #####: 1828:          if (!push_computed)
        -: 1829:          {
    #####: 1830:            stack_top_p++;
        -: 1831:          }
        -: 1832:
    #####: 1833:          memmove (stack_top_p - 3, stack_top_p - 4, 3 * sizeof (ecma_value_t));
    #####: 1834:          stack_top_p[-4] = left_value;
        -: 1835:
    #####: 1836:          ecma_object_t *class_object_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 1837:          ecma_object_t *initializer_func_p = ecma_get_object_from_value (left_value);
    #####: 1838:          opfunc_bind_class_environment (frame_ctx_p->lex_env_p, class_object_p, class_object_p, initializer_func_p);
        -: 1839:
    #####: 1840:          if (!push_computed)
        -: 1841:          {
    #####: 1842:            continue;
        -: 1843:          }
        -: 1844:
    #####: 1845:          left_value = value;
        -: 1846:          /* FALLTHRU */
        -: 1847:        }
    #####: 1848:        case VM_OC_ADD_COMPUTED_FIELD:
        -: 1849:        {
    #####: 1850:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1851:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC
        -: 1852:                            || byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD
        -: 1853:                            || byte_code_start_p[1] == CBC_EXT_ADD_STATIC_COMPUTED_FIELD));
        -: 1854:
    #####: 1855:          int index = (byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD) ? -2 : -4;
    #####: 1856:          result = opfunc_add_computed_field (stack_top_p[index], left_value);
        -: 1857:
    #####: 1858:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1859:          {
    #####: 1860:            goto error;
        -: 1861:          }
    #####: 1862:          goto free_left_value;
        -: 1863:        }
    #####: 1864:        case VM_OC_COPY_DATA_PROPERTIES:
        -: 1865:        {
    #####: 1866:          left_value = *(--stack_top_p);
        -: 1867:
    #####: 1868:          if (ecma_is_value_undefined (left_value) || ecma_is_value_null (left_value))
        -: 1869:          {
    #####: 1870:            continue;
        -: 1871:          }
        -: 1872:
    #####: 1873:          result = opfunc_copy_data_properties (stack_top_p[-1], left_value, ECMA_VALUE_UNDEFINED);
        -: 1874:
    #####: 1875:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1876:          {
    #####: 1877:            goto error;
        -: 1878:          }
        -: 1879:
    #####: 1880:          goto free_left_value;
        -: 1881:        }
    #####: 1882:        case VM_OC_SET_COMPUTED_PROPERTY:
        -: 1883:        {
        -: 1884:          /* Swap values. */
    #####: 1885:          left_value ^= right_value;
    #####: 1886:          right_value ^= left_value;
    #####: 1887:          left_value ^= right_value;
        -: 1888:          /* FALLTHRU */
        -: 1889:        }
        -: 1890:#endif /* JERRY_ESNEXT */
    #####: 1891:        case VM_OC_SET_PROPERTY:
        -: 1892:        {
        -: 1893:          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,
        -: 1894:                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);
        -: 1895:
    #####: 1896:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1897:
    #####: 1898:          ecma_string_t *prop_name_p = ecma_op_to_property_key (right_value);
        -: 1899:
    #####: 1900:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1901:          {
    #####: 1902:            result = ECMA_VALUE_ERROR;
    #####: 1903:            goto error;
        -: 1904:          }
        -: 1905:
        -: 1906:#if JERRY_ESNEXT
    #####: 1907:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1908:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1909:          {
    #####: 1910:            result = ecma_raise_type_error (ECMA_ERR_CLASS_IS_NON_CONFIGURABLE);
    #####: 1911:            goto error;
        -: 1912:          }
        -: 1913:
    #####: 1914:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1915:#else /* !JERRY_ESNEXT */
    #####: 1916:          const int index = -1;
        -: 1917:#endif /* JERRY_ESNEXT */
        -: 1918:
    #####: 1919:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);
        -: 1920:
    #####: 1921:          opfunc_set_data_property (object_p, prop_name_p, left_value);
    #####: 1922:          ecma_deref_ecma_string (prop_name_p);
        -: 1923:
    #####: 1924:          goto free_both_values;
        -: 1925:        }
    #####: 1926:        case VM_OC_SET_GETTER:
        -: 1927:        case VM_OC_SET_SETTER:
        -: 1928:        {
    #####: 1929:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1930:
    #####: 1931:          ecma_string_t *prop_name_p = ecma_op_to_property_key (left_value);
        -: 1932:
    #####: 1933:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1934:          {
    #####: 1935:            result = ECMA_VALUE_ERROR;
    #####: 1936:            goto error;
        -: 1937:          }
        -: 1938:
        -: 1939:#if JERRY_ESNEXT
    #####: 1940:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1941:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1942:          {
    #####: 1943:            result = ecma_raise_type_error (ECMA_ERR_CLASS_IS_NON_CONFIGURABLE);
    #####: 1944:            goto error;
        -: 1945:          }
        -: 1946:
    #####: 1947:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1948:#else /* !JERRY_ESNEXT */
    #####: 1949:          const int index = -1;
        -: 1950:#endif /* JERRY_ESNEXT */
        -: 1951:
    #####: 1952:          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,
    #####: 1953:                               stack_top_p[index],
        -: 1954:                               prop_name_p,
        -: 1955:                               right_value);
        -: 1956:
    #####: 1957:          ecma_deref_ecma_string (prop_name_p);
        -: 1958:
    #####: 1959:          goto free_both_values;
        -: 1960:        }
    #####: 1961:        case VM_OC_PUSH_ARRAY:
        -: 1962:        {
        -: 1963:          /* Note: this operation cannot throw an exception */
    #####: 1964:          *stack_top_p++ = ecma_make_object_value (ecma_op_new_array_object (0));
    #####: 1965:          continue;
        -: 1966:        }
        -: 1967:#if JERRY_ESNEXT
    #####: 1968:        case VM_OC_LOCAL_EVAL:
        -: 1969:        {
    #####: 1970:          ECMA_CLEAR_LOCAL_PARSE_OPTS ();
    #####: 1971:          uint8_t parse_opts = *byte_code_p++;
    #####: 1972:          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);
    #####: 1973:          continue;
        -: 1974:        }
    #####: 1975:        case VM_OC_SUPER_CALL:
        -: 1976:        {
    #####: 1977:          uint8_t arguments_list_len = *byte_code_p++;
        -: 1978:
    #####: 1979:          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)
        -: 1980:          {
    #####: 1981:            stack_top_p -= arguments_list_len;
    #####: 1982:            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 1983:
    #####: 1984:            if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 1985:            {
    #####: 1986:              result = ECMA_VALUE_ERROR;
    #####: 1987:              goto error;
        -: 1988:            }
        -: 1989:
    #####: 1990:            stack_top_p++;
    #####: 1991:            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 1992:          }
        -: 1993:          else
        -: 1994:          {
    #####: 1995:            stack_top_p -= arguments_list_len;
        -: 1996:          }
        -: 1997:
    #####: 1998:          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;
    #####: 1999:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2000:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2001:          return ECMA_VALUE_UNDEFINED;
        -: 2002:        }
    #####: 2003:        case VM_OC_PUSH_CLASS_ENVIRONMENT:
        -: 2004:        {
        -: 2005:          uint16_t literal_index;
        -: 2006:
    #####: 2007:          READ_LITERAL_INDEX (literal_index);
    #####: 2008:          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, literal_start_p[literal_index]);
    #####: 2009:          continue;
        -: 2010:        }
    #####: 2011:        case VM_OC_PUSH_IMPLICIT_CTOR:
        -: 2012:        {
    #####: 2013:          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode, frame_ctx_p->shared_p->bytecode_header_p);
    #####: 2014:          continue;
        -: 2015:        }
    #####: 2016:        case VM_OC_DEFINE_FIELD:
        -: 2017:        {
    #####: 2018:          result = opfunc_define_field (frame_ctx_p->this_binding, right_value, left_value);
        -: 2019:
    #####: 2020:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2021:          {
    #####: 2022:            goto error;
        -: 2023:          }
        -: 2024:
    #####: 2025:          goto free_both_values;
        -: 2026:        }
    #####: 2027:        case VM_OC_ASSIGN_PRIVATE:
        -: 2028:        {
    #####: 2029:          result = opfunc_private_set (stack_top_p[-3], stack_top_p[-2], stack_top_p[-1]);
        -: 2030:
    #####: 2031:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2032:          {
    #####: 2033:            goto error;
        -: 2034:          }
        -: 2035:
    #####: 2036:          ecma_free_value (stack_top_p[-3]);
    #####: 2037:          ecma_free_value (stack_top_p[-2]);
    #####: 2038:          ecma_free_value (stack_top_p[-1]);
    #####: 2039:          stack_top_p -= 3;
        -: 2040:
    #####: 2041:          if (opcode_data & VM_OC_PUT_STACK)
        -: 2042:          {
    #####: 2043:            *stack_top_p++ = result;
        -: 2044:          }
    #####: 2045:          else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 2046:          {
    #####: 2047:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 2048:            VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 2049:          }
        -: 2050:          else
        -: 2051:          {
    #####: 2052:            ecma_free_value (result);
        -: 2053:          }
        -: 2054:
    #####: 2055:          goto free_both_values;
        -: 2056:        }
    #####: 2057:        case VM_OC_PRIVATE_FIELD_ADD:
        -: 2058:        {
    #####: 2059:          result = opfunc_private_field_add (frame_ctx_p->this_binding, right_value, left_value);
        -: 2060:
    #####: 2061:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2062:          {
    #####: 2063:            goto error;
        -: 2064:          }
        -: 2065:
    #####: 2066:          goto free_both_values;
        -: 2067:        }
    #####: 2068:        case VM_OC_PRIVATE_PROP_GET:
        -: 2069:        {
    #####: 2070:          result = opfunc_private_get (left_value, right_value);
        -: 2071:
    #####: 2072:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2073:          {
    #####: 2074:            goto error;
        -: 2075:          }
        -: 2076:
    #####: 2077:          *stack_top_p++ = result;
    #####: 2078:          goto free_both_values;
        -: 2079:        }
    #####: 2080:        case VM_OC_PRIVATE_PROP_REFERENCE:
        -: 2081:        {
    #####: 2082:          result = opfunc_private_get (stack_top_p[-1], left_value);
        -: 2083:
    #####: 2084:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2085:          {
    #####: 2086:            goto error;
        -: 2087:          }
        -: 2088:
    #####: 2089:          *stack_top_p++ = left_value;
    #####: 2090:          *stack_top_p++ = result;
    #####: 2091:          continue;
        -: 2092:        }
    #####: 2093:        case VM_OC_PRIVATE_IN:
        -: 2094:        {
    #####: 2095:          result = opfunc_private_in (left_value, right_value);
        -: 2096:
    #####: 2097:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2098:          {
    #####: 2099:            goto error;
        -: 2100:          }
        -: 2101:
    #####: 2102:          *stack_top_p++ = result;
    #####: 2103:          goto free_both_values;
        -: 2104:        }
    #####: 2105:        case VM_OC_COLLECT_PRIVATE_PROPERTY:
        -: 2106:        {
    #####: 2107:          opfunc_collect_private_properties (stack_top_p[-2], left_value, right_value, opcode);
    #####: 2108:          continue;
        -: 2109:        }
    #####: 2110:        case VM_OC_INIT_CLASS:
        -: 2111:        {
    #####: 2112:          result = opfunc_init_class (frame_ctx_p, stack_top_p);
        -: 2113:
    #####: 2114:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2115:          {
    #####: 2116:            goto error;
        -: 2117:          }
    #####: 2118:          continue;
        -: 2119:        }
    #####: 2120:        case VM_OC_FINALIZE_CLASS:
        -: 2121:        {
    #####: 2122:          JERRY_ASSERT (opcode == CBC_EXT_FINALIZE_NAMED_CLASS || opcode == CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 2123:
    #####: 2124:          if (opcode == CBC_EXT_FINALIZE_NAMED_CLASS)
        -: 2125:          {
        -: 2126:            uint16_t literal_index;
    #####: 2127:            READ_LITERAL_INDEX (literal_index);
    #####: 2128:            left_value = literal_start_p[literal_index];
        -: 2129:          }
        -: 2130:
    #####: 2131:          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);
    #####: 2132:          continue;
        -: 2133:        }
    #####: 2134:        case VM_OC_SET_FIELD_INIT:
        -: 2135:        {
    #####: 2136:          ecma_string_t *property_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####: 2137:          ecma_object_t *proto_object_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####: 2138:          ecma_object_t *class_object_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 2139:          ecma_object_t *initializer_func_p = ecma_get_object_from_value (left_value);
        -: 2140:
    #####: 2141:          opfunc_bind_class_environment (frame_ctx_p->lex_env_p, proto_object_p, class_object_p, initializer_func_p);
        -: 2142:
    #####: 2143:          ecma_property_value_t *property_value_p =
        -: 2144:            ecma_create_named_data_property (class_object_p, property_name_p, ECMA_PROPERTY_FIXED, NULL);
    #####: 2145:          property_value_p->value = left_value;
        -: 2146:
    #####: 2147:          property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 2148:          ecma_property_t *property_p = ecma_find_named_property (class_object_p, property_name_p);
        -: 2149:
    #####: 2150:          if (property_p != NULL)
        -: 2151:          {
    #####: 2152:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 2153:            ecma_value_t *compact_collection_p =
    #####: 2154:              ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, property_value_p->value);
    #####: 2155:            compact_collection_p = ecma_compact_collection_shrink (compact_collection_p);
    #####: 2156:            ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
        -: 2157:          }
        -: 2158:
    #####: 2159:          goto free_left_value;
        -: 2160:        }
    #####: 2161:        case VM_OC_RUN_FIELD_INIT:
        -: 2162:        {
    #####: 2163:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####: 2164:          result = opfunc_init_class_fields (frame_ctx_p->shared_p->function_object_p, frame_ctx_p->this_binding);
        -: 2165:
    #####: 2166:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2167:          {
    #####: 2168:            goto error;
        -: 2169:          }
    #####: 2170:          continue;
        -: 2171:        }
    #####: 2172:        case VM_OC_RUN_STATIC_FIELD_INIT:
        -: 2173:        {
    #####: 2174:          left_value = stack_top_p[-2];
    #####: 2175:          stack_top_p[-2] = stack_top_p[-1];
    #####: 2176:          stack_top_p--;
        -: 2177:
    #####: 2178:          result = opfunc_init_static_class_fields (left_value, stack_top_p[-1]);
        -: 2179:
    #####: 2180:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2181:          {
    #####: 2182:            goto error;
        -: 2183:          }
    #####: 2184:          goto free_left_value;
        -: 2185:        }
    #####: 2186:        case VM_OC_SET_NEXT_COMPUTED_FIELD:
        -: 2187:        {
    #####: 2188:          ecma_integer_value_t next_index = ecma_get_integer_from_value (stack_top_p[-2]) + 1;
    #####: 2189:          stack_top_p[-2] = ecma_make_integer_value (next_index);
        -: 2190:
    #####: 2191:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS);
        -: 2192:
    #####: 2193:          ecma_value_t *computed_class_fields_p = VM_GET_COMPUTED_CLASS_FIELDS (frame_ctx_p);
    #####: 2194:          JERRY_ASSERT ((ecma_value_t) next_index < ECMA_COMPACT_COLLECTION_GET_SIZE (computed_class_fields_p));
    #####: 2195:          ecma_value_t prop_name = computed_class_fields_p[next_index];
        -: 2196:
    #####: 2197:          if (opcode == CBC_EXT_SET_NEXT_COMPUTED_FIELD_ANONYMOUS_FUNC)
        -: 2198:          {
    #####: 2199:            ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2200:
    #####: 2201:            JERRY_ASSERT (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) == NULL);
        -: 2202:            ecma_property_value_t *value_p;
    #####: 2203:            value_p = ecma_create_named_data_property (func_obj_p,
        -: 2204:                                                       ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2205:                                                       ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2206:                                                       NULL);
        -: 2207:
    #####: 2208:            if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2209:            {
    #####: 2210:              ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2211:            }
        -: 2212:
    #####: 2213:            value_p->value = ecma_copy_value (prop_name);
        -: 2214:          }
        -: 2215:
    #####: 2216:          result = opfunc_define_field (frame_ctx_p->this_binding, prop_name, stack_top_p[-1]);
        -: 2217:
    #####: 2218:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2219:          {
    #####: 2220:            goto error;
        -: 2221:          }
        -: 2222:
    #####: 2223:          ecma_free_value (*(--stack_top_p));
    #####: 2224:          continue;
        -: 2225:        }
    #####: 2226:        case VM_OC_PUSH_SUPER_CONSTRUCTOR:
        -: 2227:        {
    #####: 2228:          result = ecma_op_function_get_super_constructor (vm_get_class_function (frame_ctx_p));
        -: 2229:
    #####: 2230:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2231:          {
    #####: 2232:            goto error;
        -: 2233:          }
        -: 2234:
    #####: 2235:          *stack_top_p++ = result;
    #####: 2236:          continue;
        -: 2237:        }
    #####: 2238:        case VM_OC_RESOLVE_LEXICAL_THIS:
        -: 2239:        {
    #####: 2240:          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);
        -: 2241:
    #####: 2242:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2243:          {
    #####: 2244:            goto error;
        -: 2245:          }
        -: 2246:
    #####: 2247:          *stack_top_p++ = result;
    #####: 2248:          continue;
        -: 2249:        }
    #####: 2250:        case VM_OC_OBJECT_LITERAL_HOME_ENV:
        -: 2251:        {
    #####: 2252:          if (opcode == CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT)
        -: 2253:          {
    #####: 2254:            ecma_value_t obj_value = stack_top_p[-1];
    #####: 2255:            ecma_object_t *obj_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);
        -: 2256:
    #####: 2257:            ECMA_SET_NON_NULL_POINTER (obj_env_p->u1.bound_object_cp, ecma_get_object_from_value (obj_value));
    #####: 2258:            stack_top_p[-1] = ecma_make_object_value (obj_env_p);
    #####: 2259:            *stack_top_p++ = obj_value;
        -: 2260:          }
        -: 2261:          else
        -: 2262:          {
    #####: 2263:            JERRY_ASSERT (opcode == CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
    #####: 2264:            ecma_deref_object (ecma_get_object_from_value (stack_top_p[-2]));
    #####: 2265:            stack_top_p[-2] = stack_top_p[-1];
    #####: 2266:            stack_top_p--;
        -: 2267:          }
    #####: 2268:          continue;
        -: 2269:        }
    #####: 2270:        case VM_OC_SET_HOME_OBJECT:
        -: 2271:        {
    #####: 2272:          int offset = opcode == CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED ? -1 : 0;
    #####: 2273:          opfunc_set_home_object (ecma_get_object_from_value (stack_top_p[-1]),
    #####: 2274:                                  ecma_get_object_from_value (stack_top_p[-3 + offset]));
    #####: 2275:          continue;
        -: 2276:        }
    #####: 2277:        case VM_OC_SUPER_REFERENCE:
        -: 2278:        {
    #####: 2279:          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);
        -: 2280:
    #####: 2281:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2282:          {
    #####: 2283:            goto error;
        -: 2284:          }
        -: 2285:
    #####: 2286:          goto free_left_value;
        -: 2287:        }
    #####: 2288:        case VM_OC_SET_FUNCTION_NAME:
        -: 2289:        {
    #####: 2290:          char *prefix_p = NULL;
    #####: 2291:          lit_utf8_size_t prefix_size = 0;
        -: 2292:
    #####: 2293:          if (opcode != CBC_EXT_SET_FUNCTION_NAME)
        -: 2294:          {
        -: 2295:            ecma_value_t prop_name_value;
        -: 2296:
    #####: 2297:            if (opcode == CBC_EXT_SET_CLASS_NAME)
        -: 2298:            {
        -: 2299:              uint16_t literal_index;
    #####: 2300:              READ_LITERAL_INDEX (literal_index);
    #####: 2301:              prop_name_value = literal_start_p[literal_index];
        -: 2302:            }
        -: 2303:            else
        -: 2304:            {
    #####: 2305:              prop_name_value = stack_top_p[-2];
        -: 2306:            }
        -: 2307:
    #####: 2308:            ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name_value);
        -: 2309:
    #####: 2310:            if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 2311:            {
    #####: 2312:              result = ECMA_VALUE_ERROR;
    #####: 2313:              goto error;
        -: 2314:            }
        -: 2315:
    #####: 2316:            left_value = ecma_make_prop_name_value (prop_name_p);
        -: 2317:
    #####: 2318:            if (opcode != CBC_EXT_SET_CLASS_NAME)
        -: 2319:            {
    #####: 2320:              ecma_ref_ecma_string (prop_name_p);
    #####: 2321:              ecma_free_value (stack_top_p[-2]);
    #####: 2322:              stack_top_p[-2] = left_value;
        -: 2323:            }
        -: 2324:
    #####: 2325:            if (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME || opcode == CBC_EXT_SET_COMPUTED_SETTER_NAME)
        -: 2326:            {
    #####: 2327:              prefix_p = (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME) ? "get " : "set ";
    #####: 2328:              prefix_size = 4;
        -: 2329:            }
        -: 2330:          }
        -: 2331:
    #####: 2332:          ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2333:
    #####: 2334:          if (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) != NULL)
        -: 2335:          {
    #####: 2336:            ecma_free_value (left_value);
    #####: 2337:            continue;
        -: 2338:          }
        -: 2339:
        -: 2340:          ecma_property_value_t *value_p;
    #####: 2341:          value_p = ecma_create_named_data_property (func_obj_p,
        -: 2342:                                                     ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2343:                                                     ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2344:                                                     NULL);
        -: 2345:
    #####: 2346:          if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2347:          {
    #####: 2348:            ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2349:          }
        -: 2350:
    #####: 2351:          value_p->value =
    #####: 2352:            ecma_op_function_form_name (ecma_get_prop_name_from_value (left_value), prefix_p, prefix_size);
    #####: 2353:          ecma_free_value (left_value);
    #####: 2354:          continue;
        -: 2355:        }
    #####: 2356:        case VM_OC_PUSH_SPREAD_ELEMENT:
        -: 2357:        {
    #####: 2358:          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;
    #####: 2359:          continue;
        -: 2360:        }
    #####: 2361:        case VM_OC_PUSH_REST_OBJECT:
        -: 2362:        {
    #####: 2363:          vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        -: 2364:
    #####: 2365:          JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 2366:
    #####: 2367:          const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 2368:          uint32_t arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 2369:          uint16_t argument_end;
        -: 2370:
    #####: 2371:          if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 2372:          {
    #####: 2373:            argument_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;
        -: 2374:          }
        -: 2375:          else
        -: 2376:          {
    #####: 2377:            argument_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;
        -: 2378:          }
        -: 2379:
    #####: 2380:          if (arg_list_len < argument_end)
        -: 2381:          {
    #####: 2382:            arg_list_len = argument_end;
        -: 2383:          }
        -: 2384:
    #####: 2385:          result = ecma_op_new_array_object_from_buffer (arg_list_p + argument_end, arg_list_len - argument_end);
        -: 2386:
    #####: 2387:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (result));
    #####: 2388:          *stack_top_p++ = result;
    #####: 2389:          continue;
        -: 2390:        }
    #####: 2391:        case VM_OC_ITERATOR_CONTEXT_CREATE:
        -: 2392:        {
    #####: 2393:          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_SYNC_ITERATOR, &left_value);
        -: 2394:
    #####: 2395:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2396:          {
    #####: 2397:            goto error;
        -: 2398:          }
        -: 2399:
    #####: 2400:          uint32_t context_size =
    #####: 2401:            (uint32_t) (stack_top_p + PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION - VM_LAST_CONTEXT_END ());
    #####: 2402:          stack_top_p += PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION;
    #####: 2403:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2404:
    #####: 2405:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_ITERATOR, context_size) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2406:          stack_top_p[-2] = result;
    #####: 2407:          stack_top_p[-3] = left_value;
        -: 2408:
    #####: 2409:          continue;
        -: 2410:        }
    #####: 2411:        case VM_OC_ITERATOR_STEP:
        -: 2412:        {
    #####: 2413:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
        -: 2414:
    #####: 2415:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2416:          ecma_value_t next_method = last_context_end_p[-3];
        -: 2417:
    #####: 2418:          result = ecma_op_iterator_step (iterator, next_method);
        -: 2419:
    #####: 2420:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2421:          {
    #####: 2422:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2423:            goto error;
        -: 2424:          }
        -: 2425:
    #####: 2426:          ecma_value_t value = ECMA_VALUE_UNDEFINED;
        -: 2427:
    #####: 2428:          if (!ecma_is_value_false (result))
        -: 2429:          {
    #####: 2430:            value = ecma_op_iterator_value (result);
    #####: 2431:            ecma_free_value (result);
        -: 2432:
    #####: 2433:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2434:            {
    #####: 2435:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2436:              result = value;
    #####: 2437:              goto error;
        -: 2438:            }
        -: 2439:          }
        -: 2440:          else
        -: 2441:          {
    #####: 2442:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
        -: 2443:          }
        -: 2444:
    #####: 2445:          *stack_top_p++ = value;
    #####: 2446:          continue;
        -: 2447:        }
    #####: 2448:        case VM_OC_ITERATOR_CONTEXT_END:
        -: 2449:        {
    #####: 2450:          JERRY_ASSERT (VM_LAST_CONTEXT_END () == stack_top_p);
        -: 2451:
    #####: 2452:          if (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR)
        -: 2453:          {
    #####: 2454:            stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2455:            result = ecma_op_iterator_close (stack_top_p[-2]);
        -: 2456:
    #####: 2457:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2458:            {
    #####: 2459:              goto error;
        -: 2460:            }
        -: 2461:          }
        -: 2462:
    #####: 2463:          stack_top_p =
    #####: 2464:            vm_stack_context_abort_variable_length (frame_ctx_p, stack_top_p, PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION);
    #####: 2465:          continue;
        -: 2466:        }
    #####: 2467:        case VM_OC_DEFAULT_INITIALIZER:
        -: 2468:        {
    #####: 2469:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 2470:
    #####: 2471:          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)
        -: 2472:          {
    #####: 2473:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 2474:            continue;
        -: 2475:          }
        -: 2476:
    #####: 2477:          stack_top_p--;
    #####: 2478:          continue;
        -: 2479:        }
    #####: 2480:        case VM_OC_REST_INITIALIZER:
        -: 2481:        {
    #####: 2482:          ecma_object_t *array_p = ecma_op_new_array_object (0);
    #####: 2483:          JERRY_ASSERT (ecma_op_object_is_fast_array (array_p));
        -: 2484:
    #####: 2485:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2486:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2487:          ecma_value_t next_method = last_context_end_p[-3];
    #####: 2488:          uint32_t index = 0;
        -: 2489:
        -: 2490:          while (true)
    #####: 2491:          {
    #####: 2492:            result = ecma_op_iterator_step (iterator, next_method);
        -: 2493:
    #####: 2494:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2495:            {
    #####: 2496:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2497:              ecma_deref_object (array_p);
    #####: 2498:              goto error;
        -: 2499:            }
        -: 2500:
    #####: 2501:            if (ecma_is_value_false (result))
        -: 2502:            {
    #####: 2503:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2504:              break;
        -: 2505:            }
        -: 2506:
    #####: 2507:            ecma_value_t value = ecma_op_iterator_value (result);
    #####: 2508:            ecma_free_value (result);
        -: 2509:
    #####: 2510:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2511:            {
    #####: 2512:              ecma_deref_object (array_p);
    #####: 2513:              result = value;
    #####: 2514:              goto error;
        -: 2515:            }
        -: 2516:
    #####: 2517:            bool set_result = ecma_fast_array_set_property (array_p, index++, value);
    #####: 2518:            JERRY_ASSERT (set_result);
    #####: 2519:            ecma_free_value (value);
        -: 2520:          }
        -: 2521:
    #####: 2522:          *stack_top_p++ = ecma_make_object_value (array_p);
    #####: 2523:          continue;
        -: 2524:        }
    #####: 2525:        case VM_OC_OBJ_INIT_CONTEXT_CREATE:
        -: 2526:        {
    #####: 2527:          left_value = stack_top_p[-1];
    #####: 2528:          vm_stack_context_type_t context_type = VM_CONTEXT_OBJ_INIT;
    #####: 2529:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2530:
    #####: 2531:          if (opcode == CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE)
        -: 2532:          {
    #####: 2533:            context_type = VM_CONTEXT_OBJ_INIT_REST;
    #####: 2534:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2535:          }
        -: 2536:
    #####: 2537:          uint32_t context_size = (uint32_t) (stack_top_p + context_stack_allocation - VM_LAST_CONTEXT_END ());
    #####: 2538:          stack_top_p += context_stack_allocation;
    #####: 2539:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2540:
    #####: 2541:          stack_top_p[-1] = VM_CREATE_CONTEXT (context_type, context_size);
    #####: 2542:          stack_top_p[-2] = left_value;
        -: 2543:
    #####: 2544:          if (context_type == VM_CONTEXT_OBJ_INIT_REST)
        -: 2545:          {
    #####: 2546:            stack_top_p[-3] = ecma_make_object_value (ecma_op_new_array_object (0));
        -: 2547:          }
    #####: 2548:          continue;
        -: 2549:        }
    #####: 2550:        case VM_OC_OBJ_INIT_CONTEXT_END:
        -: 2551:        {
    #####: 2552:          JERRY_ASSERT (stack_top_p == VM_LAST_CONTEXT_END ());
        -: 2553:
    #####: 2554:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2555:
    #####: 2556:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_OBJ_INIT_REST)
        -: 2557:          {
    #####: 2558:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2559:          }
        -: 2560:
    #####: 2561:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p, stack_top_p, context_stack_allocation);
    #####: 2562:          continue;
        -: 2563:        }
    #####: 2564:        case VM_OC_OBJ_INIT_PUSH_REST:
        -: 2565:        {
    #####: 2566:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2567:          if (!ecma_op_require_object_coercible (last_context_end_p[-2]))
        -: 2568:          {
    #####: 2569:            result = ECMA_VALUE_ERROR;
    #####: 2570:            goto error;
        -: 2571:          }
        -: 2572:
    #####: 2573:          ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
    #####: 2574:          ecma_object_t *result_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 2575:
    #####: 2576:          left_value = ecma_make_object_value (result_object_p);
    #####: 2577:          result = opfunc_copy_data_properties (left_value, last_context_end_p[-2], last_context_end_p[-3]);
        -: 2578:
    #####: 2579:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2580:          {
    #####: 2581:            goto error;
        -: 2582:          }
        -: 2583:
    #####: 2584:          ecma_free_value (last_context_end_p[-3]);
    #####: 2585:          last_context_end_p[-3] = last_context_end_p[-2];
    #####: 2586:          last_context_end_p[-2] = ECMA_VALUE_UNDEFINED;
        -: 2587:
    #####: 2588:          *stack_top_p++ = left_value;
    #####: 2589:          continue;
        -: 2590:        }
    #####: 2591:        case VM_OC_INITIALIZER_PUSH_NAME:
        -: 2592:        {
    #####: 2593:          if (JERRY_UNLIKELY (!ecma_is_value_prop_name (left_value)))
        -: 2594:          {
    #####: 2595:            ecma_string_t *property_key = ecma_op_to_property_key (left_value);
        -: 2596:
    #####: 2597:            if (property_key == NULL)
        -: 2598:            {
    #####: 2599:              result = ECMA_VALUE_ERROR;
    #####: 2600:              goto error;
        -: 2601:            }
        -: 2602:
    #####: 2603:            ecma_free_value (left_value);
    #####: 2604:            left_value = ecma_make_string_value (property_key);
        -: 2605:          }
        -: 2606:
    #####: 2607:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2608:          ecma_object_t *array_obj_p = ecma_get_object_from_value (last_context_end_p[-3]);
    #####: 2609:          JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -: 2610:
    #####: 2611:          ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####: 2612:          ecma_fast_array_set_property (array_obj_p, ext_array_obj_p->u.array.length, left_value);
        -: 2613:          /* FALLTHRU */
        -: 2614:        }
    #####: 2615:        case VM_OC_INITIALIZER_PUSH_PROP:
        -: 2616:        {
    #####: 2617:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2618:          ecma_value_t base = last_context_end_p[-2];
        -: 2619:
    #####: 2620:          if (opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 2621:          {
    #####: 2622:            left_value = *last_context_end_p++;
    #####: 2623:            while (last_context_end_p < stack_top_p)
        -: 2624:            {
    #####: 2625:              last_context_end_p[-1] = *last_context_end_p;
    #####: 2626:              last_context_end_p++;
        -: 2627:            }
    #####: 2628:            stack_top_p--;
        -: 2629:          }
        -: 2630:
    #####: 2631:          result = vm_op_get_value (base, left_value);
        -: 2632:
    #####: 2633:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2634:          {
    #####: 2635:            goto error;
        -: 2636:          }
        -: 2637:
    #####: 2638:          *stack_top_p++ = result;
    #####: 2639:          goto free_left_value;
        -: 2640:        }
    #####: 2641:        case VM_OC_SPREAD_ARGUMENTS:
        -: 2642:        {
    #####: 2643:          uint8_t arguments_list_len = *byte_code_p++;
    #####: 2644:          stack_top_p -= arguments_list_len;
        -: 2645:
    #####: 2646:          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2647:
    #####: 2648:          if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2649:          {
    #####: 2650:            result = ECMA_VALUE_ERROR;
    #####: 2651:            goto error;
        -: 2652:          }
        -: 2653:
    #####: 2654:          stack_top_p++;
    #####: 2655:          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2656:
    #####: 2657:          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;
    #####: 2658:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2659:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2660:          return ECMA_VALUE_UNDEFINED;
        -: 2661:        }
    #####: 2662:        case VM_OC_CREATE_GENERATOR:
        -: 2663:        {
    #####: 2664:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2665:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2666:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 2667:
        -: 2668:          vm_executable_object_t *executable_object_p;
    #####: 2669:          executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -: 2670:
    #####: 2671:          return ecma_make_object_value ((ecma_object_t *) executable_object_p);
        -: 2672:        }
    #####: 2673:        case VM_OC_YIELD:
        -: 2674:        {
    #####: 2675:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2676:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2677:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2678:          return *stack_top_p;
        -: 2679:        }
    #####: 2680:        case VM_OC_ASYNC_YIELD:
        -: 2681:        {
    #####: 2682:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2683:
    #####: 2684:          opfunc_async_generator_yield (async_generator_object_p, stack_top_p[-1]);
        -: 2685:
    #####: 2686:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2687:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2688:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2689:          return ECMA_VALUE_UNDEFINED;
        -: 2690:        }
    #####: 2691:        case VM_OC_ASYNC_YIELD_ITERATOR:
        -: 2692:        {
    #####: 2693:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2694:
    #####: 2695:          JERRY_ASSERT (
        -: 2696:            !(async_generator_object_p->u.cls.u2.executable_obj_flags & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD));
        -: 2697:
        -: 2698:          /* Byte code is executed at the first time. */
    #####: 2699:          left_value = stack_top_p[-1];
    #####: 2700:          result = ecma_op_get_iterator (left_value, ECMA_VALUE_ASYNC_ITERATOR, stack_top_p - 1);
        -: 2701:
    #####: 2702:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2703:          {
    #####: 2704:            goto error;
        -: 2705:          }
        -: 2706:
    #####: 2707:          ecma_free_value (left_value);
    #####: 2708:          left_value = result;
    #####: 2709:          result = ecma_op_iterator_next (left_value, stack_top_p[-1], ECMA_VALUE_UNDEFINED);
        -: 2710:
    #####: 2711:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2712:          {
    #####: 2713:            goto error;
        -: 2714:          }
        -: 2715:
    #####: 2716:          result = ecma_promise_async_await (async_generator_object_p, result);
        -: 2717:
    #####: 2718:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2719:          {
    #####: 2720:            goto error;
        -: 2721:          }
        -: 2722:
    #####: 2723:          async_generator_object_p->u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD;
    #####: 2724:          *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p) = left_value;
        -: 2725:
    #####: 2726:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2727:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2728:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2729:          return ECMA_VALUE_UNDEFINED;
        -: 2730:        }
    #####: 2731:        case VM_OC_AWAIT:
        -: 2732:        {
    #####: 2733:          if (JERRY_UNLIKELY (!(frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE)))
        -: 2734:          {
    #####: 2735:            frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2736:            frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2737:            frame_ctx_p->stack_top_p = --stack_top_p;
        -: 2738:
    #####: 2739:            result = opfunc_async_create_and_await (frame_ctx_p, *stack_top_p, 0);
        -: 2740:
    #####: 2741:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2742:            {
    #####: 2743:              goto error;
        -: 2744:            }
    #####: 2745:            return result;
        -: 2746:          }
        -: 2747:          /* FALLTHRU */
        -: 2748:        }
        -: 2749:        case VM_OC_GENERATOR_AWAIT:
        -: 2750:        {
    #####: 2751:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2752:
    #####: 2753:          result = ecma_promise_async_await (async_generator_object_p, *(--stack_top_p));
        -: 2754:
    #####: 2755:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2756:          {
    #####: 2757:            goto error;
        -: 2758:          }
        -: 2759:
    #####: 2760:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2761:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2762:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2763:          return ECMA_VALUE_UNDEFINED;
        -: 2764:        }
    #####: 2765:        case VM_OC_EXT_RETURN:
        -: 2766:        {
    #####: 2767:          result = left_value;
    #####: 2768:          left_value = ECMA_VALUE_UNDEFINED;
        -: 2769:
    #####: 2770:          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 2771:
    #####: 2772:          while (stack_top_p > stack_bottom_p)
        -: 2773:          {
    #####: 2774:            ecma_fast_free_value (*(--stack_top_p));
        -: 2775:          }
        -: 2776:
    #####: 2777:          goto error;
        -: 2778:        }
    #####: 2779:        case VM_OC_ASYNC_EXIT:
        -: 2780:        {
    #####: 2781:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 2782:
    #####: 2783:          if (!(frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE))
        -: 2784:          {
    #####: 2785:            result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2786:          }
        -: 2787:          else
        -: 2788:          {
    #####: 2789:            result = *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p);
    #####: 2790:            *VM_GET_EXECUTABLE_ITERATOR (frame_ctx_p) = ECMA_VALUE_UNDEFINED;
        -: 2791:          }
        -: 2792:
    #####: 2793:          vm_stack_context_type_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 2794:
    #####: 2795:          if (context_type == VM_CONTEXT_TRY)
        -: 2796:          {
    #####: 2797:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 2798:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2799:          }
        -: 2800:          else
        -: 2801:          {
    #####: 2802:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 2803:            left_value = stack_top_p[-2];
        -: 2804:          }
        -: 2805:
    #####: 2806:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 2807:          {
    #####: 2808:            ecma_reject_promise (result, left_value);
        -: 2809:          }
        -: 2810:          else
        -: 2811:          {
    #####: 2812:            JERRY_ASSERT (context_type == VM_CONTEXT_TRY || context_type == VM_CONTEXT_FINALLY_RETURN);
    #####: 2813:            ecma_fulfill_promise (result, left_value);
        -: 2814:          }
        -: 2815:
    #####: 2816:          ecma_free_value (left_value);
        -: 2817:
    #####: 2818:          frame_ctx_p->context_depth = 0;
    #####: 2819:          frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 2820:          return result;
        -: 2821:        }
    #####: 2822:        case VM_OC_STRING_CONCAT:
        -: 2823:        {
    #####: 2824:          ecma_string_t *left_str_p = ecma_op_to_string (left_value);
        -: 2825:
    #####: 2826:          if (JERRY_UNLIKELY (left_str_p == NULL))
        -: 2827:          {
    #####: 2828:            result = ECMA_VALUE_ERROR;
    #####: 2829:            goto error;
        -: 2830:          }
    #####: 2831:          ecma_string_t *right_str_p = ecma_op_to_string (right_value);
        -: 2832:
    #####: 2833:          if (JERRY_UNLIKELY (right_str_p == NULL))
        -: 2834:          {
    #####: 2835:            ecma_deref_ecma_string (left_str_p);
    #####: 2836:            result = ECMA_VALUE_ERROR;
    #####: 2837:            goto error;
        -: 2838:          }
        -: 2839:
    #####: 2840:          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);
    #####: 2841:          ecma_deref_ecma_string (right_str_p);
        -: 2842:
    #####: 2843:          *stack_top_p++ = ecma_make_string_value (result_str_p);
    #####: 2844:          goto free_both_values;
        -: 2845:        }
    #####: 2846:        case VM_OC_GET_TEMPLATE_OBJECT:
        -: 2847:        {
    #####: 2848:          uint8_t tagged_idx = *byte_code_p++;
    #####: 2849:          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);
    #####: 2850:          JERRY_ASSERT (tagged_idx < collection_p->item_count);
        -: 2851:
    #####: 2852:          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);
    #####: 2853:          continue;
        -: 2854:        }
    #####: 2855:        case VM_OC_PUSH_NEW_TARGET:
        -: 2856:        {
    #####: 2857:          ecma_object_t *new_target_object_p = JERRY_CONTEXT (current_new_target_p);
    #####: 2858:          if (new_target_object_p == NULL)
        -: 2859:          {
    #####: 2860:            *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2861:          }
        -: 2862:          else
        -: 2863:          {
    #####: 2864:            ecma_ref_object (new_target_object_p);
    #####: 2865:            *stack_top_p++ = ecma_make_object_value (new_target_object_p);
        -: 2866:          }
    #####: 2867:          continue;
        -: 2868:        }
    #####: 2869:        case VM_OC_REQUIRE_OBJECT_COERCIBLE:
        -: 2870:        {
    #####: 2871:          if (!ecma_op_require_object_coercible (stack_top_p[-1]))
        -: 2872:          {
    #####: 2873:            result = ECMA_VALUE_ERROR;
    #####: 2874:            goto error;
        -: 2875:          }
    #####: 2876:          continue;
        -: 2877:        }
    #####: 2878:        case VM_OC_ASSIGN_SUPER:
        -: 2879:        {
    #####: 2880:          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);
        -: 2881:
    #####: 2882:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2883:          {
    #####: 2884:            goto error;
        -: 2885:          }
    #####: 2886:          continue;
        -: 2887:        }
        -: 2888:#endif /* JERRY_ESNEXT */
    #####: 2889:        case VM_OC_PUSH_ELISON:
        -: 2890:        {
    #####: 2891:          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;
    #####: 2892:          continue;
        -: 2893:        }
    #####: 2894:        case VM_OC_APPEND_ARRAY:
        -: 2895:        {
    #####: 2896:          uint16_t values_length = *byte_code_p++;
    #####: 2897:          stack_top_p -= values_length;
        -: 2898:
        -: 2899:#if JERRY_ESNEXT
    #####: 2900:          if (*byte_code_start_p == CBC_EXT_OPCODE)
        -: 2901:          {
    #####: 2902:            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);
        -: 2903:          }
        -: 2904:#endif /* JERRY_ESNEXT */
    #####: 2905:          result = opfunc_append_array (stack_top_p, values_length);
        -: 2906:
        -: 2907:#if JERRY_ESNEXT
    #####: 2908:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2909:          {
    #####: 2910:            goto error;
        -: 2911:          }
        -: 2912:#else /* !JERRY_ESNEXT */
        -: 2913:          JERRY_ASSERT (ecma_is_value_empty (result));
        -: 2914:#endif /* JERRY_ESNEXT */
    #####: 2915:          continue;
        -: 2916:        }
    #####: 2917:        case VM_OC_IDENT_REFERENCE:
        -: 2918:        {
        -: 2919:          uint16_t literal_index;
        -: 2920:
    #####: 2921:          READ_LITERAL_INDEX (literal_index);
        -: 2922:
    #####: 2923:          JERRY_ASSERT (literal_index < ident_end);
        -: 2924:
    #####: 2925:          if (literal_index < register_end)
        -: 2926:          {
    #####: 2927:            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;
    #####: 2928:            *stack_top_p++ = ecma_make_integer_value (literal_index);
    #####: 2929:            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 2930:          }
        -: 2931:          else
        -: 2932:          {
    #####: 2933:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 2934:
    #####: 2935:            ecma_object_t *ref_base_lex_env_p;
        -: 2936:
    #####: 2937:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p, &ref_base_lex_env_p, name_p);
        -: 2938:
    #####: 2939:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2940:            {
    #####: 2941:              goto error;
        -: 2942:            }
        -: 2943:
    #####: 2944:            ecma_ref_object (ref_base_lex_env_p);
    #####: 2945:            ecma_ref_ecma_string (name_p);
    #####: 2946:            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);
    #####: 2947:            *stack_top_p++ = ecma_make_string_value (name_p);
    #####: 2948:            *stack_top_p++ = result;
        -: 2949:          }
    #####: 2950:          continue;
        -: 2951:        }
    #####: 2952:        case VM_OC_PROP_GET:
        -: 2953:        {
    #####: 2954:          result = vm_op_get_value (left_value, right_value);
        -: 2955:
    #####: 2956:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2957:          {
    #####: 2958:            goto error;
        -: 2959:          }
        -: 2960:
    #####: 2961:          *stack_top_p++ = result;
    #####: 2962:          goto free_both_values;
        -: 2963:        }
    #####: 2964:        case VM_OC_PROP_REFERENCE:
        -: 2965:        {
        -: 2966:          /* Forms with reference requires preserving the base and offset. */
        -: 2967:
    #####: 2968:          if (opcode == CBC_PUSH_PROP_REFERENCE)
        -: 2969:          {
    #####: 2970:            left_value = stack_top_p[-2];
    #####: 2971:            right_value = stack_top_p[-1];
        -: 2972:          }
    #####: 2973:          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)
        -: 2974:          {
    #####: 2975:            *stack_top_p++ = left_value;
    #####: 2976:            right_value = left_value;
    #####: 2977:            left_value = stack_top_p[-2];
        -: 2978:          }
        -: 2979:          else
        -: 2980:          {
    #####: 2981:            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE
        -: 2982:                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);
    #####: 2983:            *stack_top_p++ = left_value;
    #####: 2984:            *stack_top_p++ = right_value;
        -: 2985:          }
        -: 2986:          /* FALLTHRU */
        -: 2987:        }
        -: 2988:        case VM_OC_PROP_PRE_INCR:
        -: 2989:        case VM_OC_PROP_PRE_DECR:
        -: 2990:        case VM_OC_PROP_POST_INCR:
        -: 2991:        case VM_OC_PROP_POST_DECR:
        -: 2992:        {
    #####: 2993:          result = vm_op_get_value (left_value, right_value);
        -: 2994:
    #####: 2995:          if (opcode < CBC_PRE_INCR)
        -: 2996:          {
    #####: 2997:            left_value = ECMA_VALUE_UNDEFINED;
    #####: 2998:            right_value = ECMA_VALUE_UNDEFINED;
        -: 2999:          }
        -: 3000:
    #####: 3001:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3002:          {
    #####: 3003:            goto error;
        -: 3004:          }
        -: 3005:
    #####: 3006:          if (opcode < CBC_PRE_INCR)
        -: 3007:          {
    #####: 3008:            break;
        -: 3009:          }
        -: 3010:
    #####: 3011:          stack_top_p += 2;
    #####: 3012:          left_value = result;
    #####: 3013:          right_value = ECMA_VALUE_UNDEFINED;
        -: 3014:          /* FALLTHRU */
        -: 3015:        }
    #####: 3016:        case VM_OC_PRE_INCR:
        -: 3017:        case VM_OC_PRE_DECR:
        -: 3018:        case VM_OC_POST_INCR:
        -: 3019:        case VM_OC_POST_DECR:
        -: 3020:        {
    #####: 3021:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;
    #####: 3022:          ecma_number_t result_number;
        -: 3023:
    #####: 3024:          byte_code_p = byte_code_start_p + 1;
        -: 3025:
    #####: 3026:          if (ecma_is_value_integer_number (left_value))
        -: 3027:          {
    #####: 3028:            result = left_value;
    #####: 3029:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3030:
    #####: 3031:            ecma_integer_value_t int_value = (ecma_integer_value_t) result;
    #####: 3032:            ecma_integer_value_t int_increase = 0;
        -: 3033:
    #####: 3034:            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3035:            {
    #####: 3036:              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)
        -: 3037:              {
    #####: 3038:                int_increase = -(1 << ECMA_DIRECT_SHIFT);
        -: 3039:              }
        -: 3040:            }
    #####: 3041:            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)
        -: 3042:            {
    #####: 3043:              int_increase = 1 << ECMA_DIRECT_SHIFT;
        -: 3044:            }
        -: 3045:
    #####: 3046:            if (JERRY_LIKELY (int_increase != 0))
        -: 3047:            {
        -: 3048:              /* Postfix operators require the unmodifed number value. */
    #####: 3049:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3050:              {
    #####: 3051:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3052:              }
        -: 3053:
    #####: 3054:              result = (ecma_value_t) (int_value + int_increase);
    #####: 3055:              break;
        -: 3056:            }
    #####: 3057:            result_number = (ecma_number_t) ecma_get_integer_from_value (result);
        -: 3058:          }
    #####: 3059:          else if (ecma_is_value_float_number (left_value))
        -: 3060:          {
    #####: 3061:            result = left_value;
    #####: 3062:            left_value = ECMA_VALUE_UNDEFINED;
    #####: 3063:            result_number = ecma_get_number_from_value (result);
        -: 3064:          }
        -: 3065:          else
        -: 3066:          {
    #####: 3067:            result = ecma_op_to_numeric (left_value, &result_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -: 3068:
    #####: 3069:            if (ECMA_IS_VALUE_ERROR (result))
        -: 3070:            {
    #####: 3071:              goto error;
        -: 3072:            }
        -: 3073:
    #####: 3074:            ecma_free_value (left_value);
    #####: 3075:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3076:
        -: 3077:#if JERRY_BUILTIN_BIGINT
    #####: 3078:            if (JERRY_UNLIKELY (ecma_is_value_bigint (result)))
        -: 3079:            {
    #####: 3080:              ecma_bigint_unary_operation_type operation_type = ECMA_BIGINT_UNARY_INCREASE;
        -: 3081:
    #####: 3082:              if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3083:              {
    #####: 3084:                operation_type = ECMA_BIGINT_UNARY_DECREASE;
        -: 3085:              }
        -: 3086:
        -: 3087:              /* Postfix operators require the unmodifed number value. */
    #####: 3088:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3089:              {
    #####: 3090:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3091:
    #####: 3092:                result = ecma_bigint_unary (result, operation_type);
        -: 3093:              }
        -: 3094:              else
        -: 3095:              {
    #####: 3096:                ecma_value_t original_value = result;
    #####: 3097:                result = ecma_bigint_unary (original_value, operation_type);
    #####: 3098:                ecma_free_value (original_value);
        -: 3099:              }
        -: 3100:
    #####: 3101:              if (ECMA_IS_VALUE_ERROR (result))
        -: 3102:              {
    #####: 3103:                goto error;
        -: 3104:              }
    #####: 3105:              break;
        -: 3106:            }
        -: 3107:#endif /* JERRY_BUILTIN_BIGINT */
        -: 3108:
    #####: 3109:            result = ecma_make_number_value (result_number);
        -: 3110:          }
        -: 3111:
    #####: 3112:          ecma_number_t increase = ECMA_NUMBER_ONE;
        -: 3113:
    #####: 3114:          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3115:          {
        -: 3116:            /* For decrement operators */
    #####: 3117:            increase = ECMA_NUMBER_MINUS_ONE;
        -: 3118:          }
        -: 3119:
        -: 3120:          /* Postfix operators require the unmodifed number value. */
    #####: 3121:          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3122:          {
    #####: 3123:            POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3124:
    #####: 3125:            result = ecma_make_number_value (result_number + increase);
    #####: 3126:            break;
        -: 3127:          }
        -: 3128:
    #####: 3129:          if (ecma_is_value_integer_number (result))
        -: 3130:          {
    #####: 3131:            result = ecma_make_number_value (result_number + increase);
        -: 3132:          }
        -: 3133:          else
        -: 3134:          {
    #####: 3135:            result = ecma_update_float_number (result, result_number + increase);
        -: 3136:          }
    #####: 3137:          break;
        -: 3138:        }
    #####: 3139:        case VM_OC_ASSIGN:
        -: 3140:        {
    #####: 3141:          result = left_value;
    #####: 3142:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3143:          break;
        -: 3144:        }
    #####: 3145:        case VM_OC_MOV_IDENT:
        -: 3146:        {
        -: 3147:          uint32_t literal_index;
        -: 3148:
    #####: 3149:          READ_LITERAL_INDEX (literal_index);
        -: 3150:
    #####: 3151:          JERRY_ASSERT (literal_index < register_end);
    #####: 3152:          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));
        -: 3153:
    #####: 3154:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 3155:          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;
    #####: 3156:          continue;
        -: 3157:        }
    #####: 3158:        case VM_OC_ASSIGN_PROP:
        -: 3159:        {
    #####: 3160:          result = stack_top_p[-1];
    #####: 3161:          stack_top_p[-1] = left_value;
    #####: 3162:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3163:          break;
        -: 3164:        }
    #####: 3165:        case VM_OC_ASSIGN_PROP_THIS:
        -: 3166:        {
    #####: 3167:          result = stack_top_p[-1];
    #####: 3168:          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 3169:          *stack_top_p++ = left_value;
    #####: 3170:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3171:          break;
        -: 3172:        }
    #####: 3173:        case VM_OC_RETURN_FUNCTION_END:
        -: 3174:        {
    #####: 3175:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_SCRIPT)
        -: 3176:          {
    #####: 3177:            result = VM_GET_REGISTER (frame_ctx_p, 0);
    #####: 3178:            VM_GET_REGISTERS (frame_ctx_p)[0] = ECMA_VALUE_UNDEFINED;
        -: 3179:          }
        -: 3180:          else
        -: 3181:          {
    #####: 3182:            result = ECMA_VALUE_UNDEFINED;
        -: 3183:          }
        -: 3184:
    #####: 3185:          goto error;
        -: 3186:        }
    #####: 3187:        case VM_OC_RETURN:
        -: 3188:        {
    #####: 3189:          JERRY_ASSERT (opcode == CBC_RETURN || opcode == CBC_RETURN_WITH_LITERAL);
        -: 3190:
    #####: 3191:          result = left_value;
    #####: 3192:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3193:          goto error;
        -: 3194:        }
    #####: 3195:        case VM_OC_THROW:
        -: 3196:        {
    #####: 3197:          jcontext_raise_exception (left_value);
        -: 3198:
    #####: 3199:          result = ECMA_VALUE_ERROR;
    #####: 3200:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3201:          goto error;
        -: 3202:        }
    #####: 3203:        case VM_OC_THROW_REFERENCE_ERROR:
        -: 3204:        {
    #####: 3205:          result = ecma_raise_reference_error (ECMA_ERR_UNDEFINED_REFERENCE);
    #####: 3206:          goto error;
        -: 3207:        }
    #####: 3208:        case VM_OC_EVAL:
        -: 3209:        {
    #####: 3210:          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;
    #####: 3211:          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)
        -: 3212:                        || (*byte_code_p == CBC_EXT_OPCODE && byte_code_p[1] >= CBC_EXT_SPREAD_CALL
        -: 3213:                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));
    #####: 3214:          continue;
        -: 3215:        }
        1: 3216:        case VM_OC_CALL:
        -: 3217:        {
        1: 3218:          frame_ctx_p->call_operation = VM_EXEC_CALL;
        1: 3219:          frame_ctx_p->byte_code_p = byte_code_start_p;
        1: 3220:          frame_ctx_p->stack_top_p = stack_top_p;
        1: 3221:          return ECMA_VALUE_UNDEFINED;
        -: 3222:        }
    11909: 3223:        case VM_OC_NEW:
        -: 3224:        {
    11909: 3225:          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;
    11909: 3226:          frame_ctx_p->byte_code_p = byte_code_start_p;
    11909: 3227:          frame_ctx_p->stack_top_p = stack_top_p;
    11909: 3228:          return ECMA_VALUE_UNDEFINED;
        -: 3229:        }
    #####: 3230:        case VM_OC_ERROR:
        -: 3231:        {
    #####: 3232:          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);
        -: 3233:#if JERRY_DEBUGGER
        -: 3234:          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);
        -: 3235:#endif /* JERRY_DEBUGGER */
        -: 3236:
    #####: 3237:          result = ECMA_VALUE_ERROR;
    #####: 3238:          goto error;
        -: 3239:        }
    #####: 3240:        case VM_OC_RESOLVE_BASE_FOR_CALL:
        -: 3241:        {
    #####: 3242:          ecma_value_t this_value = stack_top_p[-3];
        -: 3243:
    #####: 3244:          if (this_value == ECMA_VALUE_REGISTER_REF)
        -: 3245:          {
        -: 3246:            /* Lexical environment cannot be 'this' value. */
    #####: 3247:            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 3248:            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;
        -: 3249:          }
    #####: 3250:          else if (vm_get_implicit_this_value (&this_value))
        -: 3251:          {
    #####: 3252:            ecma_free_value (stack_top_p[-3]);
    #####: 3253:            stack_top_p[-3] = this_value;
        -: 3254:          }
        -: 3255:
    #####: 3256:          continue;
        -: 3257:        }
    #####: 3258:        case VM_OC_PROP_DELETE:
        -: 3259:        {
    #####: 3260:          result = vm_op_delete_prop (left_value, right_value, is_strict);
        -: 3261:
    #####: 3262:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3263:          {
    #####: 3264:            goto error;
        -: 3265:          }
        -: 3266:
    #####: 3267:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3268:
    #####: 3269:          *stack_top_p++ = result;
    #####: 3270:          goto free_both_values;
        -: 3271:        }
    #####: 3272:        case VM_OC_DELETE:
        -: 3273:        {
        -: 3274:          uint16_t literal_index;
        -: 3275:
    #####: 3276:          READ_LITERAL_INDEX (literal_index);
        -: 3277:
    #####: 3278:          if (literal_index < register_end)
        -: 3279:          {
    #####: 3280:            *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 3281:            continue;
        -: 3282:          }
        -: 3283:
    #####: 3284:          result = vm_op_delete_var (literal_start_p[literal_index], frame_ctx_p->lex_env_p);
        -: 3285:
    #####: 3286:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3287:          {
    #####: 3288:            goto error;
        -: 3289:          }
        -: 3290:
    #####: 3291:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3292:
    #####: 3293:          *stack_top_p++ = result;
    #####: 3294:          continue;
        -: 3295:        }
    #####: 3296:        case VM_OC_JUMP:
        -: 3297:        {
    #####: 3298:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 3299:          continue;
        -: 3300:        }
    #####: 3301:        case VM_OC_BRANCH_IF_STRICT_EQUAL:
        -: 3302:        {
    #####: 3303:          ecma_value_t value = *(--stack_top_p);
        -: 3304:
    #####: 3305:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 3306:
    #####: 3307:          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))
        -: 3308:          {
    #####: 3309:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3310:            ecma_free_value (*--stack_top_p);
        -: 3311:          }
    #####: 3312:          ecma_free_value (value);
    #####: 3313:          continue;
        -: 3314:        }
    #####: 3315:        case VM_OC_BRANCH_IF_TRUE:
        -: 3316:        case VM_OC_BRANCH_IF_FALSE:
        -: 3317:        case VM_OC_BRANCH_IF_LOGICAL_TRUE:
        -: 3318:        case VM_OC_BRANCH_IF_LOGICAL_FALSE:
        -: 3319:        {
    #####: 3320:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;
    #####: 3321:          ecma_value_t value = *(--stack_top_p);
        -: 3322:
    #####: 3323:          bool boolean_value = ecma_op_to_boolean (value);
        -: 3324:
    #####: 3325:          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)
        -: 3326:          {
    #####: 3327:            boolean_value = !boolean_value;
        -: 3328:          }
        -: 3329:
    #####: 3330:          if (boolean_value)
        -: 3331:          {
    #####: 3332:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3333:            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)
        -: 3334:            {
        -: 3335:              /* "Push" the value back to the stack. */
    #####: 3336:              ++stack_top_p;
    #####: 3337:              continue;
        -: 3338:            }
        -: 3339:          }
        -: 3340:
    #####: 3341:          ecma_fast_free_value (value);
    #####: 3342:          continue;
        -: 3343:        }
        -: 3344:#if JERRY_ESNEXT
    #####: 3345:        case VM_OC_POP_REFERENCE:
        -: 3346:        {
    #####: 3347:          ecma_free_value (stack_top_p[-2]);
    #####: 3348:          ecma_free_value (stack_top_p[-3]);
    #####: 3349:          stack_top_p[-3] = stack_top_p[-1];
    #####: 3350:          stack_top_p -= 2;
    #####: 3351:          continue;
        -: 3352:        }
    #####: 3353:        case VM_OC_BRANCH_IF_NULLISH:
        -: 3354:        {
    #####: 3355:          left_value = stack_top_p[-1];
        -: 3356:
    #####: 3357:          if (!ecma_is_value_null (left_value) && !ecma_is_value_undefined (left_value))
        -: 3358:          {
    #####: 3359:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3360:            continue;
        -: 3361:          }
    #####: 3362:          --stack_top_p;
    #####: 3363:          continue;
        -: 3364:        }
        -: 3365:#endif /* JERRY_ESNEXT */
    #####: 3366:        case VM_OC_PLUS:
        -: 3367:        case VM_OC_MINUS:
        -: 3368:        {
    #####: 3369:          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);
        -: 3370:
    #####: 3371:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3372:          {
    #####: 3373:            goto error;
        -: 3374:          }
        -: 3375:
    #####: 3376:          *stack_top_p++ = result;
    #####: 3377:          goto free_left_value;
        -: 3378:        }
    #####: 3379:        case VM_OC_NOT:
        -: 3380:        {
    #####: 3381:          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));
    #####: 3382:          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));
    #####: 3383:          goto free_left_value;
        -: 3384:        }
    #####: 3385:        case VM_OC_BIT_NOT:
        -: 3386:        {
        -: 3387:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3388:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3389:
    #####: 3390:          if (ecma_is_value_integer_number (left_value))
        -: 3391:          {
    #####: 3392:            *stack_top_p++ = (~ECMA_DIRECT_TYPE_MASK) ^ left_value;
    #####: 3393:            goto free_left_value;
        -: 3394:          }
        -: 3395:
    #####: 3396:          result = do_number_bitwise_not (left_value);
        -: 3397:
    #####: 3398:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3399:          {
    #####: 3400:            goto error;
        -: 3401:          }
        -: 3402:
    #####: 3403:          *stack_top_p++ = result;
    #####: 3404:          goto free_left_value;
        -: 3405:        }
    #####: 3406:        case VM_OC_VOID:
        -: 3407:        {
    #####: 3408:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 3409:          goto free_left_value;
        -: 3410:        }
    #####: 3411:        case VM_OC_TYPEOF_IDENT:
        -: 3412:        {
        -: 3413:          uint16_t literal_index;
        -: 3414:
    #####: 3415:          READ_LITERAL_INDEX (literal_index);
        -: 3416:
    #####: 3417:          JERRY_ASSERT (literal_index < ident_end);
        -: 3418:
    #####: 3419:          if (literal_index < register_end)
        -: 3420:          {
    #####: 3421:            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 3422:          }
        -: 3423:          else
        -: 3424:          {
    #####: 3425:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 3426:
    #####: 3427:            ecma_object_t *ref_base_lex_env_p;
        -: 3428:
    #####: 3429:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p, &ref_base_lex_env_p, name_p);
        -: 3430:
    #####: 3431:            if (ref_base_lex_env_p == NULL)
        -: 3432:            {
    #####: 3433:              jcontext_release_exception ();
    #####: 3434:              result = ECMA_VALUE_UNDEFINED;
        -: 3435:            }
    #####: 3436:            else if (ECMA_IS_VALUE_ERROR (result))
        -: 3437:            {
    #####: 3438:              goto error;
        -: 3439:            }
        -: 3440:
    #####: 3441:            left_value = result;
        -: 3442:          }
        -: 3443:          /* FALLTHRU */
        -: 3444:        }
        -: 3445:        case VM_OC_TYPEOF:
        -: 3446:        {
    #####: 3447:          result = opfunc_typeof (left_value);
        -: 3448:
    #####: 3449:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3450:          {
    #####: 3451:            goto error;
        -: 3452:          }
        -: 3453:
    #####: 3454:          *stack_top_p++ = result;
    #####: 3455:          goto free_left_value;
        -: 3456:        }
    #####: 3457:        case VM_OC_ADD:
        -: 3458:        {
    #####: 3459:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3460:          {
    #####: 3461:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3462:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3463:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));
    #####: 3464:            continue;
        -: 3465:          }
        -: 3466:
    #####: 3467:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3468:          {
    #####: 3469:            ecma_number_t new_value =
    #####: 3470:              (ecma_get_float_from_value (left_value) + ecma_get_number_from_value (right_value));
        -: 3471:
    #####: 3472:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3473:            ecma_free_number (right_value);
    #####: 3474:            continue;
        -: 3475:          }
        -: 3476:
    #####: 3477:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3478:          {
    #####: 3479:            ecma_number_t new_value =
    #####: 3480:              ((ecma_number_t) ecma_get_integer_from_value (left_value) + ecma_get_float_from_value (right_value));
        -: 3481:
    #####: 3482:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3483:            continue;
        -: 3484:          }
        -: 3485:
    #####: 3486:          result = opfunc_addition (left_value, right_value);
        -: 3487:
    #####: 3488:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3489:          {
    #####: 3490:            goto error;
        -: 3491:          }
        -: 3492:
    #####: 3493:          *stack_top_p++ = result;
    #####: 3494:          goto free_both_values;
        -: 3495:        }
    #####: 3496:        case VM_OC_SUB:
        -: 3497:        {
        -: 3498:          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,
        -: 3499:                               doubled_ecma_numbers_must_fit_into_int32_range);
        -: 3500:
    #####: 3501:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3502:
    #####: 3503:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3504:          {
    #####: 3505:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3506:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3507:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));
    #####: 3508:            continue;
        -: 3509:          }
        -: 3510:
    #####: 3511:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3512:          {
    #####: 3513:            ecma_number_t new_value =
    #####: 3514:              (ecma_get_float_from_value (left_value) - ecma_get_number_from_value (right_value));
        -: 3515:
    #####: 3516:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3517:            ecma_free_number (right_value);
    #####: 3518:            continue;
        -: 3519:          }
        -: 3520:
    #####: 3521:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3522:          {
    #####: 3523:            ecma_number_t new_value =
    #####: 3524:              ((ecma_number_t) ecma_get_integer_from_value (left_value) - ecma_get_float_from_value (right_value));
        -: 3525:
    #####: 3526:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3527:            continue;
        -: 3528:          }
        -: 3529:
    #####: 3530:          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION, left_value, right_value);
        -: 3531:
    #####: 3532:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3533:          {
    #####: 3534:            goto error;
        -: 3535:          }
        -: 3536:
    #####: 3537:          *stack_top_p++ = result;
    #####: 3538:          goto free_both_values;
        -: 3539:        }
    #####: 3540:        case VM_OC_MUL:
        -: 3541:        {
    #####: 3542:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3543:
        -: 3544:          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX
        -: 3545:                                 && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,
        -: 3546:                               square_of_integer_multiply_max_must_fit_into_integer_value_range);
        -: 3547:
    #####: 3548:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3549:          {
    #####: 3550:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3551:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3552:
    #####: 3553:            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer && left_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3554:                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer && right_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3555:                && left_integer != 0 && right_integer != 0)
        -: 3556:            {
    #####: 3557:              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);
    #####: 3558:              continue;
        -: 3559:            }
        -: 3560:
    #####: 3561:            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;
    #####: 3562:            *stack_top_p++ = ecma_make_number_value (multiply);
    #####: 3563:            continue;
        -: 3564:          }
        -: 3565:
    #####: 3566:          if (ecma_is_value_float_number (left_value) && ecma_is_value_number (right_value))
        -: 3567:          {
    #####: 3568:            ecma_number_t new_value =
    #####: 3569:              (ecma_get_float_from_value (left_value) * ecma_get_number_from_value (right_value));
        -: 3570:
    #####: 3571:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3572:            ecma_free_number (right_value);
    #####: 3573:            continue;
        -: 3574:          }
        -: 3575:
    #####: 3576:          if (ecma_is_value_float_number (right_value) && ecma_is_value_integer_number (left_value))
        -: 3577:          {
    #####: 3578:            ecma_number_t new_value =
    #####: 3579:              ((ecma_number_t) ecma_get_integer_from_value (left_value) * ecma_get_float_from_value (right_value));
        -: 3580:
    #####: 3581:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3582:            continue;
        -: 3583:          }
        -: 3584:
    #####: 3585:          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION, left_value, right_value);
        -: 3586:
    #####: 3587:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3588:          {
    #####: 3589:            goto error;
        -: 3590:          }
        -: 3591:
    #####: 3592:          *stack_top_p++ = result;
    #####: 3593:          goto free_both_values;
        -: 3594:        }
    #####: 3595:        case VM_OC_DIV:
        -: 3596:        {
    #####: 3597:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3598:
    #####: 3599:          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION, left_value, right_value);
        -: 3600:
    #####: 3601:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3602:          {
    #####: 3603:            goto error;
        -: 3604:          }
        -: 3605:
    #####: 3606:          *stack_top_p++ = result;
    #####: 3607:          goto free_both_values;
        -: 3608:        }
    #####: 3609:        case VM_OC_MOD:
        -: 3610:        {
    #####: 3611:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value) && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3612:
    #####: 3613:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3614:          {
    #####: 3615:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3616:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3617:
    #####: 3618:            if (right_integer != 0)
        -: 3619:            {
    #####: 3620:              ecma_integer_value_t mod_result = left_integer % right_integer;
        -: 3621:
    #####: 3622:              if (mod_result != 0 || left_integer >= 0)
        -: 3623:              {
    #####: 3624:                *stack_top_p++ = ecma_make_integer_value (mod_result);
    #####: 3625:                continue;
        -: 3626:              }
        -: 3627:            }
        -: 3628:          }
        -: 3629:
    #####: 3630:          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER, left_value, right_value);
        -: 3631:
    #####: 3632:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3633:          {
    #####: 3634:            goto error;
        -: 3635:          }
        -: 3636:
    #####: 3637:          *stack_top_p++ = result;
    #####: 3638:          goto free_both_values;
        -: 3639:        }
        -: 3640:#if JERRY_ESNEXT
    #####: 3641:        case VM_OC_EXP:
        -: 3642:        {
    #####: 3643:          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION, left_value, right_value);
        -: 3644:
    #####: 3645:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3646:          {
    #####: 3647:            goto error;
        -: 3648:          }
        -: 3649:
    #####: 3650:          *stack_top_p++ = result;
    #####: 3651:          goto free_both_values;
        -: 3652:        }
        -: 3653:#endif /* JERRY_ESNEXT */
    #####: 3654:        case VM_OC_EQUAL:
        -: 3655:        {
    #####: 3656:          result = opfunc_equality (left_value, right_value);
        -: 3657:
    #####: 3658:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3659:          {
    #####: 3660:            goto error;
        -: 3661:          }
        -: 3662:
    #####: 3663:          *stack_top_p++ = result;
    #####: 3664:          goto free_both_values;
        -: 3665:        }
    #####: 3666:        case VM_OC_NOT_EQUAL:
        -: 3667:        {
    #####: 3668:          result = opfunc_equality (left_value, right_value);
        -: 3669:
    #####: 3670:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3671:          {
    #####: 3672:            goto error;
        -: 3673:          }
        -: 3674:
    #####: 3675:          *stack_top_p++ = ecma_invert_boolean_value (result);
    #####: 3676:          goto free_both_values;
        -: 3677:        }
    #####: 3678:        case VM_OC_STRICT_EQUAL:
        -: 3679:        {
    #####: 3680:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3681:
    #####: 3682:          result = ecma_make_boolean_value (is_equal);
        -: 3683:
    #####: 3684:          *stack_top_p++ = result;
    #####: 3685:          goto free_both_values;
        -: 3686:        }
    #####: 3687:        case VM_OC_STRICT_NOT_EQUAL:
        -: 3688:        {
    #####: 3689:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3690:
    #####: 3691:          result = ecma_make_boolean_value (!is_equal);
        -: 3692:
    #####: 3693:          *stack_top_p++ = result;
    #####: 3694:          goto free_both_values;
        -: 3695:        }
    #####: 3696:        case VM_OC_BIT_OR:
        -: 3697:        {
        -: 3698:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3699:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3700:
    #####: 3701:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3702:          {
    #####: 3703:            *stack_top_p++ = left_value | right_value;
    #####: 3704:            continue;
        -: 3705:          }
        -: 3706:
    #####: 3707:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR, left_value, right_value);
        -: 3708:
    #####: 3709:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3710:          {
    #####: 3711:            goto error;
        -: 3712:          }
        -: 3713:
    #####: 3714:          *stack_top_p++ = result;
    #####: 3715:          goto free_both_values;
        -: 3716:        }
    #####: 3717:        case VM_OC_BIT_XOR:
        -: 3718:        {
        -: 3719:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3720:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3721:
    #####: 3722:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3723:          {
    #####: 3724:            *stack_top_p++ = left_value ^ right_value;
    #####: 3725:            continue;
        -: 3726:          }
        -: 3727:
    #####: 3728:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR, left_value, right_value);
        -: 3729:
    #####: 3730:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3731:          {
    #####: 3732:            goto error;
        -: 3733:          }
        -: 3734:
    #####: 3735:          *stack_top_p++ = result;
    #####: 3736:          goto free_both_values;
        -: 3737:        }
    #####: 3738:        case VM_OC_BIT_AND:
        -: 3739:        {
        -: 3740:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3741:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3742:
    #####: 3743:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3744:          {
    #####: 3745:            *stack_top_p++ = left_value & right_value;
    #####: 3746:            continue;
        -: 3747:          }
        -: 3748:
    #####: 3749:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND, left_value, right_value);
        -: 3750:
    #####: 3751:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3752:          {
    #####: 3753:            goto error;
        -: 3754:          }
        -: 3755:
    #####: 3756:          *stack_top_p++ = result;
    #####: 3757:          goto free_both_values;
        -: 3758:        }
    #####: 3759:        case VM_OC_LEFT_SHIFT:
        -: 3760:        {
        -: 3761:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3762:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3763:
    #####: 3764:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3765:          {
    #####: 3766:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3767:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3768:
    #####: 3769:            *stack_top_p++ = ecma_make_int32_value ((int32_t) ((uint32_t) left_integer << (right_integer & 0x1f)));
    #####: 3770:            continue;
        -: 3771:          }
        -: 3772:
    #####: 3773:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT, left_value, right_value);
        -: 3774:
    #####: 3775:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3776:          {
    #####: 3777:            goto error;
        -: 3778:          }
        -: 3779:
    #####: 3780:          *stack_top_p++ = result;
    #####: 3781:          goto free_both_values;
        -: 3782:        }
    #####: 3783:        case VM_OC_RIGHT_SHIFT:
        -: 3784:        {
        -: 3785:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3786:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3787:
    #####: 3788:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3789:          {
    #####: 3790:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3791:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3792:            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));
    #####: 3793:            continue;
        -: 3794:          }
        -: 3795:
    #####: 3796:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT, left_value, right_value);
        -: 3797:
    #####: 3798:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3799:          {
    #####: 3800:            goto error;
        -: 3801:          }
        -: 3802:
    #####: 3803:          *stack_top_p++ = result;
    #####: 3804:          goto free_both_values;
        -: 3805:        }
    #####: 3806:        case VM_OC_UNS_RIGHT_SHIFT:
        -: 3807:        {
        -: 3808:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3809:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3810:
    #####: 3811:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3812:          {
    #####: 3813:            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);
    #####: 3814:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3815:            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));
    #####: 3816:            continue;
        -: 3817:          }
        -: 3818:
    #####: 3819:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT, left_value, right_value);
        -: 3820:
    #####: 3821:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3822:          {
    #####: 3823:            goto error;
        -: 3824:          }
        -: 3825:
    #####: 3826:          *stack_top_p++ = result;
    #####: 3827:          goto free_both_values;
        -: 3828:        }
    #####: 3829:        case VM_OC_LESS:
        -: 3830:        {
    #####: 3831:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3832:          {
    #####: 3833:            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;
        -: 3834:#if !JERRY_VM_HALT
        -: 3835:            /* This is a lookahead to the next opcode to improve performance.
        -: 3836:             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */
    #####: 3837:            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)
        -: 3838:            {
    #####: 3839:              byte_code_start_p = byte_code_p++;
    #####: 3840:              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);
    #####: 3841:              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 3842:
    #####: 3843:              if (is_less)
        -: 3844:              {
    #####: 3845:                branch_offset = *(byte_code_p++);
        -: 3846:
    #####: 3847:                if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 3848:                {
    #####: 3849:                  branch_offset <<= 8;
    #####: 3850:                  branch_offset |= *(byte_code_p++);
    #####: 3851:                  if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 3852:                  {
    #####: 3853:                    branch_offset <<= 8;
    #####: 3854:                    branch_offset |= *(byte_code_p++);
        -: 3855:                  }
        -: 3856:                }
        -: 3857:
        -: 3858:                /* Note: The opcode is a backward branch. */
    #####: 3859:                byte_code_p = byte_code_start_p - branch_offset;
        -: 3860:              }
        -: 3861:              else
        -: 3862:              {
    #####: 3863:                byte_code_p += branch_offset_length;
        -: 3864:              }
        -: 3865:
    #####: 3866:              continue;
        -: 3867:            }
        -: 3868:#endif /* !JERRY_VM_HALT */
    #####: 3869:            *stack_top_p++ = ecma_make_boolean_value (is_less);
    #####: 3870:            continue;
        -: 3871:          }
        -: 3872:
    #####: 3873:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3874:          {
    #####: 3875:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3876:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3877:
    #####: 3878:            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);
    #####: 3879:            goto free_both_values;
        -: 3880:          }
        -: 3881:
    #####: 3882:          result = opfunc_relation (left_value, right_value, true, false);
        -: 3883:
    #####: 3884:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3885:          {
    #####: 3886:            goto error;
        -: 3887:          }
        -: 3888:
    #####: 3889:          *stack_top_p++ = result;
    #####: 3890:          goto free_both_values;
        -: 3891:        }
    #####: 3892:        case VM_OC_GREATER:
        -: 3893:        {
    #####: 3894:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3895:          {
    #####: 3896:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3897:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3898:
    #####: 3899:            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);
    #####: 3900:            continue;
        -: 3901:          }
        -: 3902:
    #####: 3903:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3904:          {
    #####: 3905:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3906:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3907:
    #####: 3908:            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);
    #####: 3909:            goto free_both_values;
        -: 3910:          }
        -: 3911:
    #####: 3912:          result = opfunc_relation (left_value, right_value, false, false);
        -: 3913:
    #####: 3914:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3915:          {
    #####: 3916:            goto error;
        -: 3917:          }
        -: 3918:
    #####: 3919:          *stack_top_p++ = result;
    #####: 3920:          goto free_both_values;
        -: 3921:        }
    #####: 3922:        case VM_OC_LESS_EQUAL:
        -: 3923:        {
    #####: 3924:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3925:          {
    #####: 3926:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3927:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3928:
    #####: 3929:            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);
    #####: 3930:            continue;
        -: 3931:          }
        -: 3932:
    #####: 3933:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3934:          {
    #####: 3935:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3936:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3937:
    #####: 3938:            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);
    #####: 3939:            goto free_both_values;
        -: 3940:          }
        -: 3941:
    #####: 3942:          result = opfunc_relation (left_value, right_value, false, true);
        -: 3943:
    #####: 3944:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3945:          {
    #####: 3946:            goto error;
        -: 3947:          }
        -: 3948:
    #####: 3949:          *stack_top_p++ = result;
    #####: 3950:          goto free_both_values;
        -: 3951:        }
    #####: 3952:        case VM_OC_GREATER_EQUAL:
        -: 3953:        {
    #####: 3954:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3955:          {
    #####: 3956:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3957:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3958:
    #####: 3959:            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);
    #####: 3960:            continue;
        -: 3961:          }
        -: 3962:
    #####: 3963:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3964:          {
    #####: 3965:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3966:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3967:
    #####: 3968:            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);
    #####: 3969:            goto free_both_values;
        -: 3970:          }
        -: 3971:
    #####: 3972:          result = opfunc_relation (left_value, right_value, true, true);
        -: 3973:
    #####: 3974:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3975:          {
    #####: 3976:            goto error;
        -: 3977:          }
        -: 3978:
    #####: 3979:          *stack_top_p++ = result;
    #####: 3980:          goto free_both_values;
        -: 3981:        }
    #####: 3982:        case VM_OC_IN:
        -: 3983:        {
    #####: 3984:          result = opfunc_in (left_value, right_value);
        -: 3985:
    #####: 3986:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3987:          {
    #####: 3988:            goto error;
        -: 3989:          }
        -: 3990:
    #####: 3991:          *stack_top_p++ = result;
    #####: 3992:          goto free_both_values;
        -: 3993:        }
    #####: 3994:        case VM_OC_INSTANCEOF:
        -: 3995:        {
    #####: 3996:          result = opfunc_instanceof (left_value, right_value);
        -: 3997:
    #####: 3998:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3999:          {
    #####: 4000:            goto error;
        -: 4001:          }
        -: 4002:
    #####: 4003:          *stack_top_p++ = result;
    #####: 4004:          goto free_both_values;
        -: 4005:        }
    #####: 4006:        case VM_OC_BLOCK_CREATE_CONTEXT:
        -: 4007:        {
        -: 4008:#if JERRY_ESNEXT
        -: 4009:          ecma_value_t *stack_context_top_p;
    #####: 4010:          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4011:
    #####: 4012:          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);
        -: 4013:
    #####: 4014:          if (byte_code_start_p[0] != CBC_EXT_OPCODE)
        -: 4015:          {
    #####: 4016:            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4017:
    #####: 4018:            if (stack_context_top_p != stack_top_p)
        -: 4019:            {
        -: 4020:              /* Preserve the value of switch statement. */
    #####: 4021:              stack_context_top_p[1] = stack_context_top_p[0];
        -: 4022:            }
        -: 4023:
    #####: 4024:            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);
        -: 4025:
    #####: 4026:            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
    #####: 4027:            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;
        -: 4028:          }
        -: 4029:          else
        -: 4030:          {
    #####: 4031:            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);
        -: 4032:
    #####: 4033:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY
        -: 4034:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH
        -: 4035:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP
        -: 4036:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW
        -: 4037:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
        -: 4038:
    #####: 4039:            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4040:
    #####: 4041:            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4042:          }
        -: 4043:#else /* !JERRY_ESNEXT */
        -: 4044:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH
        -: 4045:                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4046:
    #####: 4047:          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4048:#endif /* JERRY_ESNEXT */
        -: 4049:
    #####: 4050:          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
    #####: 4051:          frame_ctx_p->lex_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -: 4052:
    #####: 4053:          continue;
        -: 4054:        }
    #####: 4055:        case VM_OC_WITH:
        -: 4056:        {
    #####: 4057:          ecma_value_t value = *(--stack_top_p);
        -: 4058:          ecma_object_t *object_p;
        -: 4059:          ecma_object_t *with_env_p;
        -: 4060:
    #####: 4061:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4062:
    #####: 4063:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4064:
    #####: 4065:          result = ecma_op_to_object (value);
    #####: 4066:          ecma_free_value (value);
        -: 4067:
    #####: 4068:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4069:          {
    #####: 4070:            goto error;
        -: 4071:          }
        -: 4072:
    #####: 4073:          object_p = ecma_get_object_from_value (result);
        -: 4074:
    #####: 4075:          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p, object_p);
    #####: 4076:          ecma_deref_object (object_p);
        -: 4077:
    #####: 4078:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
    #####: 4079:          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;
        -: 4080:
    #####: 4081:          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);
        -: 4082:
    #####: 4083:          with_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
    #####: 4084:          frame_ctx_p->lex_env_p = with_env_p;
    #####: 4085:          continue;
        -: 4086:        }
    #####: 4087:        case VM_OC_FOR_IN_INIT:
        -: 4088:        {
    #####: 4089:          ecma_value_t value = *(--stack_top_p);
        -: 4090:
    #####: 4091:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4092:
    #####: 4093:          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;
    #####: 4094:          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);
    #####: 4095:          ecma_free_value (value);
        -: 4096:
    #####: 4097:          if (prop_names_p == NULL)
        -: 4098:          {
        -: 4099:#if JERRY_ESNEXT
    #####: 4100:            if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (expr_obj_value)))
        -: 4101:            {
    #####: 4102:              result = expr_obj_value;
    #####: 4103:              goto error;
        -: 4104:            }
        -: 4105:#endif /* JERRY_ESNEXT */
        -: 4106:
        -: 4107:            /* The collection is already released */
    #####: 4108:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4109:            continue;
        -: 4110:          }
        -: 4111:
    #####: 4112:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4113:
    #####: 4114:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4115:          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
    #####: 4116:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);
    #####: 4117:          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);
    #####: 4118:          stack_top_p[-3] = 0;
    #####: 4119:          stack_top_p[-4] = expr_obj_value;
        -: 4120:
        -: 4121:#if JERRY_ESNEXT
    #####: 4122:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4123:          {
        -: 4124:            /* No need to duplicate the first context. */
    #####: 4125:            byte_code_p += 2;
        -: 4126:          }
        -: 4127:#endif /* JERRY_ESNEXT */
    #####: 4128:          continue;
        -: 4129:        }
    #####: 4130:        case VM_OC_FOR_IN_GET_NEXT:
        -: 4131:        {
    #####: 4132:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4133:
        -: 4134:          ecma_collection_t *collection_p;
    #####: 4135:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);
        -: 4136:
    #####: 4137:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4138:
    #####: 4139:          uint32_t index = context_top_p[-3];
    #####: 4140:          ecma_value_t *buffer_p = collection_p->buffer_p;
        -: 4141:
    #####: 4142:          *stack_top_p++ = buffer_p[index];
    #####: 4143:          context_top_p[-3]++;
    #####: 4144:          continue;
        -: 4145:        }
    #####: 4146:        case VM_OC_FOR_IN_HAS_NEXT:
        -: 4147:        {
    #####: 4148:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4149:
        -: 4150:          ecma_collection_t *collection_p;
    #####: 4151:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);
        -: 4152:
    #####: 4153:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4154:
    #####: 4155:          ecma_value_t *buffer_p = collection_p->buffer_p;
    #####: 4156:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);
    #####: 4157:          uint32_t index = stack_top_p[-3];
        -: 4158:
    #####: 4159:          while (index < collection_p->item_count)
        -: 4160:          {
    #####: 4161:            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);
        -: 4162:
    #####: 4163:            result = ecma_op_object_has_property (object_p, prop_name_p);
        -: 4164:
    #####: 4165:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4166:            {
    #####: 4167:              stack_top_p[-3] = index;
    #####: 4168:              goto error;
        -: 4169:            }
        -: 4170:
    #####: 4171:            if (JERRY_LIKELY (ecma_is_value_true (result)))
        -: 4172:            {
    #####: 4173:              byte_code_p = byte_code_start_p + branch_offset;
    #####: 4174:              break;
        -: 4175:            }
        -: 4176:
    #####: 4177:            ecma_deref_ecma_string (prop_name_p);
    #####: 4178:            index++;
        -: 4179:          }
        -: 4180:
    #####: 4181:          if (index == collection_p->item_count)
        -: 4182:          {
    #####: 4183:            ecma_deref_object (object_p);
    #####: 4184:            ecma_collection_destroy (collection_p);
    #####: 4185:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4186:            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 4187:          }
        -: 4188:          else
        -: 4189:          {
    #####: 4190:            stack_top_p[-3] = index;
        -: 4191:          }
    #####: 4192:          continue;
        -: 4193:        }
        -: 4194:#if JERRY_ESNEXT
    #####: 4195:        case VM_OC_FOR_OF_INIT:
        -: 4196:        {
    #####: 4197:          ecma_value_t value = *(--stack_top_p);
        -: 4198:
    #####: 4199:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4200:
    #####: 4201:          ecma_value_t next_method;
    #####: 4202:          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -: 4203:
    #####: 4204:          ecma_free_value (value);
        -: 4205:
    #####: 4206:          if (ECMA_IS_VALUE_ERROR (iterator))
        -: 4207:          {
    #####: 4208:            result = iterator;
    #####: 4209:            goto error;
        -: 4210:          }
        -: 4211:
    #####: 4212:          result = ecma_op_iterator_step (iterator, next_method);
        -: 4213:
    #####: 4214:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4215:          {
    #####: 4216:            ecma_free_value (iterator);
    #####: 4217:            ecma_free_value (next_method);
    #####: 4218:            goto error;
        -: 4219:          }
        -: 4220:
    #####: 4221:          if (ecma_is_value_false (result))
        -: 4222:          {
    #####: 4223:            ecma_free_value (iterator);
    #####: 4224:            ecma_free_value (next_method);
    #####: 4225:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4226:            continue;
        -: 4227:          }
        -: 4228:
    #####: 4229:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4230:          ecma_free_value (result);
        -: 4231:
    #####: 4232:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4233:          {
    #####: 4234:            result = next_value;
    #####: 4235:            ecma_free_value (iterator);
    #####: 4236:            ecma_free_value (next_method);
    #####: 4237:            goto error;
        -: 4238:          }
        -: 4239:
    #####: 4240:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4241:
    #####: 4242:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4243:          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4244:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4245:          stack_top_p[-2] = next_value;
    #####: 4246:          stack_top_p[-3] = iterator;
    #####: 4247:          stack_top_p[-4] = next_method;
        -: 4248:
    #####: 4249:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4250:          {
        -: 4251:            /* No need to duplicate the first context. */
    #####: 4252:            byte_code_p += 2;
        -: 4253:          }
    #####: 4254:          continue;
        -: 4255:        }
    #####: 4256:        case VM_OC_FOR_OF_GET_NEXT:
        -: 4257:        {
    #####: 4258:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
    #####: 4259:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF
        -: 4260:                        || VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4261:          JERRY_ASSERT (context_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4262:
    #####: 4263:          *stack_top_p++ = context_top_p[-2];
    #####: 4264:          context_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4265:          continue;
        -: 4266:        }
    #####: 4267:        case VM_OC_FOR_OF_HAS_NEXT:
        -: 4268:        {
    #####: 4269:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4270:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_OF);
    #####: 4271:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4272:
    #####: 4273:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4274:          result = ecma_op_iterator_step (stack_top_p[-3], stack_top_p[-4]);
        -: 4275:
    #####: 4276:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4277:          {
    #####: 4278:            goto error;
        -: 4279:          }
        -: 4280:
    #####: 4281:          if (ecma_is_value_false (result))
        -: 4282:          {
    #####: 4283:            ecma_free_value (stack_top_p[-2]);
    #####: 4284:            ecma_free_value (stack_top_p[-3]);
    #####: 4285:            ecma_free_value (stack_top_p[-4]);
    #####: 4286:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4287:            stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4288:            continue;
        -: 4289:          }
        -: 4290:
    #####: 4291:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4292:          ecma_free_value (result);
        -: 4293:
    #####: 4294:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4295:          {
    #####: 4296:            result = next_value;
    #####: 4297:            goto error;
        -: 4298:          }
        -: 4299:
    #####: 4300:          JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);
    #####: 4301:          stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4302:          stack_top_p[-2] = next_value;
    #####: 4303:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4304:          continue;
        -: 4305:        }
    #####: 4306:        case VM_OC_FOR_AWAIT_OF_INIT:
        -: 4307:        {
    #####: 4308:          ecma_value_t value = *(--stack_top_p);
        -: 4309:
    #####: 4310:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4311:
    #####: 4312:          ecma_value_t next_method;
    #####: 4313:          result = ecma_op_get_iterator (value, ECMA_VALUE_ASYNC_ITERATOR, &next_method);
        -: 4314:
    #####: 4315:          ecma_free_value (value);
        -: 4316:
    #####: 4317:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4318:          {
    #####: 4319:            goto error;
        -: 4320:          }
        -: 4321:
    #####: 4322:          ecma_value_t iterator = result;
    #####: 4323:          result = ecma_op_iterator_next (result, next_method, ECMA_VALUE_EMPTY);
        -: 4324:
    #####: 4325:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4326:          {
    #####: 4327:            ecma_free_value (iterator);
    #####: 4328:            ecma_free_value (next_method);
    #####: 4329:            goto error;
        -: 4330:          }
        -: 4331:
    #####: 4332:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4333:
    #####: 4334:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4335:          stack_top_p += PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4336:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_AWAIT_OF, branch_offset);
    #####: 4337:          stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4338:          stack_top_p[-3] = iterator;
    #####: 4339:          stack_top_p[-4] = next_method;
        -: 4340:
    #####: 4341:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4342:          {
        -: 4343:            /* No need to duplicate the first context. */
    #####: 4344:            byte_code_p += 2;
        -: 4345:          }
        -: 4346:
    #####: 4347:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4348:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 4349:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 4350:
    #####: 4351:          uint16_t extra_flags =
        -: 4352:            (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
        -: 4353:
    #####: 4354:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR
    #####: 4355:              || (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_EXECUTABLE))
        -: 4356:          {
    #####: 4357:            ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4358:            result = ecma_promise_async_await (executable_object_p, result);
        -: 4359:
    #####: 4360:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4361:            {
    #####: 4362:              goto error;
        -: 4363:            }
        -: 4364:
    #####: 4365:            executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
    #####: 4366:            return ECMA_VALUE_UNDEFINED;
        -: 4367:          }
        -: 4368:
    #####: 4369:          result = opfunc_async_create_and_await (frame_ctx_p, result, extra_flags);
        -: 4370:
    #####: 4371:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4372:          {
    #####: 4373:            goto error;
        -: 4374:          }
    #####: 4375:          return result;
        -: 4376:        }
    #####: 4377:        case VM_OC_FOR_AWAIT_OF_HAS_NEXT:
        -: 4378:        {
    #####: 4379:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4380:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4381:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4382:
    #####: 4383:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4384:          result = ecma_op_iterator_next (stack_top_p[-3], stack_top_p[-4], ECMA_VALUE_EMPTY);
        -: 4385:
    #####: 4386:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4387:          {
    #####: 4388:            goto error;
        -: 4389:          }
        -: 4390:
    #####: 4391:          ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4392:          result = ecma_promise_async_await (executable_object_p, result);
        -: 4393:
    #####: 4394:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4395:          {
    #####: 4396:            goto error;
        -: 4397:          }
        -: 4398:
    #####: 4399:          uint16_t extra_flags =
        -: 4400:            (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
    #####: 4401:          executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
        -: 4402:
    #####: 4403:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4404:          frame_ctx_p->byte_code_p = byte_code_start_p + branch_offset;
    #####: 4405:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 4406:          return ECMA_VALUE_UNDEFINED;
        -: 4407:        }
        -: 4408:#endif /* JERRY_ESNEXT */
        1: 4409:        case VM_OC_TRY:
        -: 4410:        {
        -: 4411:          /* Try opcode simply creates the try context. */
        1: 4412:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4413:
        1: 4414:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4415:
        1: 4416:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        1: 4417:          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 4418:
        1: 4419:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);
        1: 4420:          continue;
        -: 4421:        }
    #####: 4422:        case VM_OC_CATCH:
        -: 4423:        {
        -: 4424:          /* Catches are ignored and turned to jumps. */
    #####: 4425:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4426:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);
        -: 4427:
    #####: 4428:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4429:          continue;
        -: 4430:        }
    #####: 4431:        case VM_OC_FINALLY:
        -: 4432:        {
    #####: 4433:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4434:
    #####: 4435:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4436:
    #####: 4437:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY
        -: 4438:                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4439:
    #####: 4440:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4441:          {
    #####: 4442:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4443:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4444:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4445:            ecma_deref_object (lex_env_p);
        -: 4446:          }
        -: 4447:
    #####: 4448:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);
    #####: 4449:          stack_top_p += PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION;
        -: 4450:
    #####: 4451:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);
    #####: 4452:          stack_top_p[-2] = (ecma_value_t) branch_offset;
    #####: 4453:          continue;
        -: 4454:        }
    #####: 4455:        case VM_OC_CONTEXT_END:
        -: 4456:        {
    #####: 4457:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4458:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -: 4459:
    #####: 4460:          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 4461:
    #####: 4462:          if (!VM_CONTEXT_IS_FINALLY (context_type))
        -: 4463:          {
    #####: 4464:            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4465:
    #####: 4466:            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4467:            continue;
        -: 4468:          }
        -: 4469:
        -: 4470:#if JERRY_ESNEXT
    #####: 4471:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4472:          {
    #####: 4473:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4474:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4475:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4476:            ecma_deref_object (lex_env_p);
        -: 4477:          }
        -: 4478:#endif /* JERRY_ESNEXT */
        -: 4479:
    #####: 4480:          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 4481:          stack_top_p -= PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -: 4482:
    #####: 4483:          if (context_type == VM_CONTEXT_FINALLY_RETURN)
        -: 4484:          {
    #####: 4485:            result = *stack_top_p;
    #####: 4486:            goto error;
        -: 4487:          }
        -: 4488:
    #####: 4489:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 4490:          {
    #####: 4491:            jcontext_raise_exception (*stack_top_p);
        -: 4492:#if JERRY_VM_THROW
    #####: 4493:            JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4494:#endif /* JERRY_VM_THROW */
    #####: 4495:            result = ECMA_VALUE_ERROR;
        -: 4496:
        -: 4497:#if JERRY_DEBUGGER
        -: 4498:            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4499:#endif /* JERRY_DEBUGGER */
    #####: 4500:            goto error;
        -: 4501:          }
        -: 4502:
    #####: 4503:          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);
        -: 4504:
    #####: 4505:          uint32_t jump_target = *stack_top_p;
        -: 4506:
    #####: 4507:          vm_stack_found_type type =
    #####: 4508:            vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_JUMP, jump_target);
    #####: 4509:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4510:          switch (type)
        -: 4511:          {
    #####: 4512:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4513:            {
    #####: 4514:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4515:
    #####: 4516:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4517:              stack_top_p[-2] = jump_target;
    #####: 4518:              break;
        -: 4519:            }
        -: 4520:#if JERRY_ESNEXT
    #####: 4521:            case VM_CONTEXT_FOUND_ERROR:
        -: 4522:            {
    #####: 4523:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4524:              result = ECMA_VALUE_ERROR;
    #####: 4525:              goto error;
        -: 4526:            }
    #####: 4527:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4528:            {
    #####: 4529:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4530:              stack_top_p[-2] = jump_target;
    #####: 4531:              return ECMA_VALUE_UNDEFINED;
        -: 4532:            }
        -: 4533:#endif /* JERRY_ESNEXT */
    #####: 4534:            default:
        -: 4535:            {
    #####: 4536:              byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;
    #####: 4537:              break;
        -: 4538:            }
        -: 4539:          }
        -: 4540:
    #####: 4541:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4542:          continue;
        -: 4543:        }
    #####: 4544:        case VM_OC_JUMP_AND_EXIT_CONTEXT:
        -: 4545:        {
    #####: 4546:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4547:          JERRY_ASSERT (!jcontext_has_pending_exception ());
        -: 4548:
    #####: 4549:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4550:
    #####: 4551:          vm_stack_found_type type =
    #####: 4552:            vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_JUMP, (uint32_t) branch_offset);
    #####: 4553:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4554:          switch (type)
        -: 4555:          {
    #####: 4556:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4557:            {
    #####: 4558:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4559:
    #####: 4560:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4561:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4562:              break;
        -: 4563:            }
        -: 4564:#if JERRY_ESNEXT
    #####: 4565:            case VM_CONTEXT_FOUND_ERROR:
        -: 4566:            {
    #####: 4567:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4568:              result = ECMA_VALUE_ERROR;
    #####: 4569:              goto error;
        -: 4570:            }
    #####: 4571:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4572:            {
    #####: 4573:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4574:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4575:              return ECMA_VALUE_UNDEFINED;
        -: 4576:            }
        -: 4577:#endif /* JERRY_ESNEXT */
    #####: 4578:            default:
        -: 4579:            {
    #####: 4580:              byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;
    #####: 4581:              break;
        -: 4582:            }
        -: 4583:          }
        -: 4584:
    #####: 4585:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4586:          continue;
        -: 4587:        }
        -: 4588:#if JERRY_MODULE_SYSTEM
    #####: 4589:        case VM_OC_MODULE_IMPORT:
        -: 4590:        {
    #####: 4591:          left_value = *(--stack_top_p);
        -: 4592:
    #####: 4593:          ecma_value_t user_value = ECMA_VALUE_UNDEFINED;
    #####: 4594:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 4595:
        -: 4596:#if JERRY_SNAPSHOT_EXEC
    #####: 4597:          if (JERRY_UNLIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 4598:          {
        -: 4599:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 4600:            cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4601:
    #####: 4602:            if (script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 4603:            {
    #####: 4604:              user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);
        -: 4605:            }
        -: 4606:#if JERRY_SNAPSHOT_EXEC
        -: 4607:          }
        -: 4608:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 4609:
    #####: 4610:          result = ecma_module_import (left_value, user_value);
    #####: 4611:          ecma_free_value (left_value);
        -: 4612:
    #####: 4613:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4614:          {
    #####: 4615:            goto error;
        -: 4616:          }
        -: 4617:
    #####: 4618:          *stack_top_p++ = result;
    #####: 4619:          continue;
        -: 4620:        }
    #####: 4621:        case VM_OC_MODULE_IMPORT_META:
        -: 4622:        {
    #####: 4623:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
    #####: 4624:          cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4625:
    #####: 4626:          JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META);
        -: 4627:
    #####: 4628:          ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);
    #####: 4629:          ecma_object_t *import_meta_object_p = ecma_get_object_from_value (import_meta);
        -: 4630:
    #####: 4631:          if (ecma_get_object_type (import_meta_object_p) != ECMA_OBJECT_TYPE_GENERAL)
        -: 4632:          {
    #####: 4633:            JERRY_ASSERT (ecma_object_class_is (import_meta_object_p, ECMA_OBJECT_CLASS_MODULE));
        -: 4634:
    #####: 4635:            ecma_value_t module = import_meta;
    #####: 4636:            import_meta_object_p = ecma_create_object (NULL, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 4637:            import_meta = ecma_make_object_value (import_meta_object_p);
        -: 4638:
    #####: 4639:            if (JERRY_CONTEXT (module_import_meta_callback_p) != NULL)
        -: 4640:            {
    #####: 4641:              void *user_p = JERRY_CONTEXT (module_import_meta_callback_user_p);
    #####: 4642:              JERRY_CONTEXT (module_import_meta_callback_p) (module, import_meta, user_p);
        -: 4643:            }
        -: 4644:
    #####: 4645:            CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type) = import_meta;
        -: 4646:          }
        -: 4647:          else
        -: 4648:          {
    #####: 4649:            ecma_ref_object (import_meta_object_p);
        -: 4650:          }
        -: 4651:
    #####: 4652:          *stack_top_p++ = import_meta;
    #####: 4653:          continue;
        -: 4654:        }
        -: 4655:#endif /* JERRY_MODULE_SYSTEM */
        -: 4656:#if JERRY_DEBUGGER
        -: 4657:        case VM_OC_BREAKPOINT_ENABLED:
        -: 4658:        {
        -: 4659:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4660:          {
        -: 4661:            continue;
        -: 4662:          }
        -: 4663:
        -: 4664:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4665:
        -: 4666:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4667:
        -: 4668:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4669:
        -: 4670:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4671:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4672:          {
        -: 4673:            result = ECMA_VALUE_ERROR;
        -: 4674:            goto error;
        -: 4675:          }
        -: 4676:          continue;
        -: 4677:        }
        -: 4678:        case VM_OC_BREAKPOINT_DISABLED:
        -: 4679:        {
        -: 4680:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4681:          {
        -: 4682:            continue;
        -: 4683:          }
        -: 4684:
        -: 4685:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4686:
        -: 4687:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4688:
        -: 4689:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4690:
        -: 4691:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4692:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4693:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4694:          {
        -: 4695:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4696:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4697:            {
        -: 4698:              result = ECMA_VALUE_ERROR;
        -: 4699:              goto error;
        -: 4700:            }
        -: 4701:            continue;
        -: 4702:          }
        -: 4703:
        -: 4704:          if (JERRY_CONTEXT (debugger_message_delay) > 0)
        -: 4705:          {
        -: 4706:            JERRY_CONTEXT (debugger_message_delay)--;
        -: 4707:            continue;
        -: 4708:          }
        -: 4709:
        -: 4710:          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;
        -: 4711:
        -: 4712:          if (jerry_debugger_receive (NULL))
        -: 4713:          {
        -: 4714:            continue;
        -: 4715:          }
        -: 4716:
        -: 4717:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4718:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4719:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4720:          {
        -: 4721:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4722:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4723:            {
        -: 4724:              result = ECMA_VALUE_ERROR;
        -: 4725:              goto error;
        -: 4726:            }
        -: 4727:          }
        -: 4728:          continue;
        -: 4729:        }
        -: 4730:#endif /* JERRY_DEBUGGER */
    #####: 4731:        case VM_OC_NONE:
        -: 4732:        default:
        -: 4733:        {
    #####: 4734:          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);
        -: 4735:
    #####: 4736:          jerry_fatal (ERR_DISABLED_BYTE_CODE);
        -: 4737:        }
        -: 4738:      }
        -: 4739:
    #####: 4740:      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));
        -: 4741:
    #####: 4742:      if (opcode_data & VM_OC_PUT_IDENT)
        -: 4743:      {
        -: 4744:        uint16_t literal_index;
        -: 4745:
    #####: 4746:        READ_LITERAL_INDEX (literal_index);
        -: 4747:
    #####: 4748:        if (literal_index < register_end)
        -: 4749:        {
    #####: 4750:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 4751:          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
        -: 4752:
    #####: 4753:          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))
        -: 4754:          {
    #####: 4755:            result = ecma_fast_copy_value (result);
        -: 4756:          }
        -: 4757:        }
        -: 4758:        else
        -: 4759:        {
    #####: 4760:          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 4761:
    #####: 4762:          ecma_value_t put_value_result =
    #####: 4763:            ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p, var_name_str_p, is_strict, result);
        -: 4764:
    #####: 4765:          if (ECMA_IS_VALUE_ERROR (put_value_result))
        -: 4766:          {
    #####: 4767:            ecma_free_value (result);
    #####: 4768:            result = put_value_result;
    #####: 4769:            goto error;
        -: 4770:          }
        -: 4771:
    #####: 4772:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4773:          {
    #####: 4774:            ecma_fast_free_value (result);
        -: 4775:          }
        -: 4776:        }
        -: 4777:      }
    #####: 4778:      else if (opcode_data & VM_OC_PUT_REFERENCE)
        -: 4779:      {
    #####: 4780:        ecma_value_t property = *(--stack_top_p);
    #####: 4781:        ecma_value_t base = *(--stack_top_p);
        -: 4782:
    #####: 4783:        if (base == ECMA_VALUE_REGISTER_REF)
        -: 4784:        {
    #####: 4785:          property = (ecma_value_t) ecma_get_integer_from_value (property);
    #####: 4786:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));
    #####: 4787:          VM_GET_REGISTER (frame_ctx_p, property) = result;
        -: 4788:
    #####: 4789:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4790:          {
    #####: 4791:            goto free_both_values;
        -: 4792:          }
    #####: 4793:          result = ecma_fast_copy_value (result);
        -: 4794:        }
        -: 4795:        else
        -: 4796:        {
    #####: 4797:          ecma_value_t set_value_result = vm_op_set_value (base, property, result, is_strict);
        -: 4798:
    #####: 4799:          if (ECMA_IS_VALUE_ERROR (set_value_result))
        -: 4800:          {
    #####: 4801:            ecma_free_value (result);
    #####: 4802:            result = set_value_result;
    #####: 4803:            goto error;
        -: 4804:          }
        -: 4805:
    #####: 4806:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4807:          {
    #####: 4808:            ecma_fast_free_value (result);
    #####: 4809:            goto free_both_values;
        -: 4810:          }
        -: 4811:        }
        -: 4812:      }
        -: 4813:
    #####: 4814:      if (opcode_data & VM_OC_PUT_STACK)
        -: 4815:      {
    #####: 4816:        *stack_top_p++ = result;
        -: 4817:      }
    #####: 4818:      else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 4819:      {
    #####: 4820:        ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 4821:        VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 4822:      }
        -: 4823:
    #####: 4824:free_both_values:
    #####: 4825:      ecma_fast_free_value (right_value);
    #####: 4826:free_left_value:
    #####: 4827:      ecma_fast_free_value (left_value);
        -: 4828:    }
        -: 4829:
    #####: 4830:error:
    #####: 4831:    ecma_fast_free_value (left_value);
    #####: 4832:    ecma_fast_free_value (right_value);
        -: 4833:
    #####: 4834:    if (ECMA_IS_VALUE_ERROR (result))
        -: 4835:    {
    #####: 4836:      JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4837:      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4838:
    #####: 4839:      while (stack_top_p > stack_bottom_p)
        -: 4840:      {
    #####: 4841:        ecma_value_t stack_item = *(--stack_top_p);
        -: 4842:#if JERRY_ESNEXT
    #####: 4843:        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 4844:        {
    #####: 4845:          opfunc_pop_lexical_environment (frame_ctx_p);
    #####: 4846:          continue;
        -: 4847:        }
        -: 4848:#endif /* JERRY_ESNEXT */
    #####: 4849:        ecma_fast_free_value (stack_item);
        -: 4850:      }
        -: 4851:
        -: 4852:#if JERRY_VM_THROW
    #####: 4853:      if (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_ERROR_THROWN))
        -: 4854:      {
    #####: 4855:        JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4856:
    #####: 4857:        jerry_throw_cb_t vm_throw_callback_p = JERRY_CONTEXT (vm_throw_callback_p);
        -: 4858:
    #####: 4859:        if (vm_throw_callback_p != NULL)
        -: 4860:        {
    #####: 4861:          vm_throw_callback_p (JERRY_CONTEXT (error_value), JERRY_CONTEXT (vm_throw_callback_user_p));
        -: 4862:        }
        -: 4863:      }
        -: 4864:#endif /* JERRY_VM_THROW */
        -: 4865:
        -: 4866:#if JERRY_DEBUGGER
        -: 4867:      const uint32_t dont_stop =
        -: 4868:        (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION | JERRY_DEBUGGER_VM_IGNORE | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4869:
        -: 4870:      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 4871:          && !(frame_ctx_p->shared_p->bytecode_header_p->status_flags
        -: 4872:               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 4873:          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))
        -: 4874:      {
        -: 4875:        /* Save the error to a local value, because the engine enters breakpoint mode after,
        -: 4876:           therefore an evaluation error, or user-created error throw would overwrite it. */
        -: 4877:        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);
        -: 4878:
        -: 4879:        if (jerry_debugger_send_exception_string (current_error_value))
        -: 4880:        {
        -: 4881:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);
        -: 4882:
        -: 4883:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4884:          {
        -: 4885:            ecma_free_value (current_error_value);
        -: 4886:          }
        -: 4887:          else
        -: 4888:          {
        -: 4889:            JERRY_CONTEXT (error_value) = current_error_value;
        -: 4890:          }
        -: 4891:
        -: 4892:          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4893:        }
        -: 4894:      }
        -: 4895:#endif /* JERRY_DEBUGGER */
        -: 4896:    }
        -: 4897:
    #####: 4898:    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4899:
    #####: 4900:    if (frame_ctx_p->context_depth == 0)
        -: 4901:    {
        -: 4902:      /* In most cases there is no context. */
    #####: 4903:      frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 4904:      return result;
        -: 4905:    }
        -: 4906:
    #####: 4907:    if (!ECMA_IS_VALUE_ERROR (result))
        -: 4908:    {
    #####: 4909:      switch (vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_RETURN, 0))
        -: 4910:      {
    #####: 4911:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4912:        {
    #####: 4913:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4914:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4915:
    #####: 4916:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4917:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4918:          stack_top_p[-2] = result;
    #####: 4919:          continue;
        -: 4920:        }
        -: 4921:#if JERRY_ESNEXT
    #####: 4922:        case VM_CONTEXT_FOUND_ERROR:
        -: 4923:        {
    #####: 4924:          JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4925:
    #####: 4926:          ecma_free_value (result);
    #####: 4927:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4928:          result = ECMA_VALUE_ERROR;
    #####: 4929:          break;
        -: 4930:        }
    #####: 4931:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4932:        {
    #####: 4933:          stack_top_p = frame_ctx_p->stack_top_p;
        -: 4934:
    #####: 4935:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4936:          stack_top_p[-2] = result;
    #####: 4937:          return ECMA_VALUE_UNDEFINED;
        -: 4938:        }
        -: 4939:#endif /* JERRY_ESNEXT */
    #####: 4940:        default:
        -: 4941:        {
    #####: 4942:          goto finish;
        -: 4943:        }
        -: 4944:      }
    #####: 4945:    }
        -: 4946:
    #####: 4947:    JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4948:
    #####: 4949:    if (!jcontext_has_pending_abort ())
        -: 4950:    {
    #####: 4951:      switch (vm_stack_find_finally (frame_ctx_p, stack_top_p, VM_CONTEXT_FINALLY_THROW, 0))
        -: 4952:      {
    #####: 4953:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4954:        {
    #####: 4955:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4956:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4957:
    #####: 4958:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4959:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4960:
        -: 4961:#if JERRY_DEBUGGER
        -: 4962:          JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4963:#endif /* JERRY_DEBUGGER */
        -: 4964:
    #####: 4965:          result = jcontext_take_exception ();
        -: 4966:
    #####: 4967:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)
        -: 4968:          {
    #####: 4969:            stack_top_p[-2] = result;
    #####: 4970:            continue;
        -: 4971:          }
        -: 4972:
    #####: 4973:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4974:
    #####: 4975:          *stack_top_p++ = result;
    #####: 4976:          continue;
        -: 4977:        }
        -: 4978:#if JERRY_ESNEXT
    #####: 4979:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4980:        {
    #####: 4981:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (frame_ctx_p->stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW);
    #####: 4982:          return ECMA_VALUE_UNDEFINED;
        -: 4983:        }
        -: 4984:#endif /* JERRY_ESNEXT */
    #####: 4985:        default:
        -: 4986:        {
    #####: 4987:          break;
        -: 4988:        }
        -: 4989:      }
        -: 4990:    }
        -: 4991:    else
        -: 4992:    {
        -: 4993:      do
        -: 4994:      {
    #####: 4995:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4996:
    #####: 4997:        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
    #####: 4998:      } while (frame_ctx_p->context_depth > 0);
        -: 4999:    }
        -: 5000:
    #####: 5001:finish:
    #####: 5002:    frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 5003:    return result;
        -: 5004:  }
        -: 5005:} /* vm_loop */
        -: 5006:
        -: 5007:#if JERRY_MODULE_SYSTEM
        -: 5008:
        -: 5009:/**
        -: 5010: * Create and initialize module scope with all data properties
        -: 5011: *
        -: 5012: * @return ECMA_VALUE_EMPTY on success,
        -: 5013: *         ECMA_VALUE_ERROR on failure
        -: 5014: */
        -: 5015:ecma_value_t
    #####: 5016:vm_init_module_scope (ecma_module_t *module_p) /**< module without scope */
        -: 5017:{
        -: 5018:  ecma_object_t *global_object_p;
        -: 5019:#if JERRY_BUILTIN_REALMS
    #####: 5020:  global_object_p = (ecma_object_t *) ecma_op_function_get_realm (module_p->u.compiled_code_p);
        -: 5021:#else /* !JERRY_BUILTIN_REALMS */
        -: 5022:  global_object_p = ecma_builtin_get_global ();
        -: 5023:#endif /* JERRY_BUILTIN_REALMS */
        -: 5024:
    #####: 5025:  ecma_object_t *scope_p = ecma_create_lex_env_class (ecma_get_global_environment (global_object_p),
        -: 5026:                                                      sizeof (ecma_lexical_environment_class_t));
    #####: 5027:  const ecma_compiled_code_t *compiled_code_p = module_p->u.compiled_code_p;
        -: 5028:  ecma_value_t *literal_start_p;
        -: 5029:  uint8_t *byte_code_p;
        -: 5030:  uint16_t encoding_limit;
        -: 5031:  uint16_t encoding_delta;
        -: 5032:
    #####: 5033:  ((ecma_lexical_environment_class_t *) scope_p)->object_p = (ecma_object_t *) module_p;
    #####: 5034:  ((ecma_lexical_environment_class_t *) scope_p)->type = ECMA_LEX_ENV_CLASS_TYPE_MODULE;
        -: 5035:
    #####: 5036:  module_p->scope_p = scope_p;
    #####: 5037:  ecma_deref_object (scope_p);
        -: 5038:
    #####: 5039:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5040:  {
    #####: 5041:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -: 5042:
    #####: 5043:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5044:    literal_start_p -= args_p->register_end;
    #####: 5045:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5046:  }
        -: 5047:  else
        -: 5048:  {
    #####: 5049:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 5050:
    #####: 5051:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5052:    literal_start_p -= args_p->register_end;
    #####: 5053:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5054:  }
        -: 5055:
        -: 5056:  /* Prepare for byte code execution. */
    #####: 5057:  if (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 5058:  {
    #####: 5059:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
    #####: 5060:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 5061:  }
        -: 5062:  else
        -: 5063:  {
    #####: 5064:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 5065:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 5066:  }
        -: 5067:
    #####: 5068:  JERRY_ASSERT (*byte_code_p >= CBC_JUMP_FORWARD && *byte_code_p <= CBC_JUMP_FORWARD_3);
        -: 5069:
    #####: 5070:  byte_code_p += 1 + CBC_BRANCH_OFFSET_LENGTH (*byte_code_p);
        -: 5071:
        -: 5072:  while (true)
    #####: 5073:  {
    #####: 5074:    uint8_t opcode = *byte_code_p++;
        -: 5075:
    #####: 5076:    switch (opcode)
        -: 5077:    {
    #####: 5078:      case CBC_CREATE_VAR:
        -: 5079:      case CBC_CREATE_LET:
        -: 5080:      case CBC_CREATE_CONST:
        -: 5081:      {
        -: 5082:        uint32_t literal_index;
        -: 5083:
    #####: 5084:        READ_LITERAL_INDEX (literal_index);
        -: 5085:
    #####: 5086:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5087:
    #####: 5088:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5089:
    #####: 5090:        uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 5091:
    #####: 5092:        if (opcode == CBC_CREATE_LET)
        -: 5093:        {
    #####: 5094:          prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 5095:        }
    #####: 5096:        else if (opcode == CBC_CREATE_CONST)
        -: 5097:        {
    #####: 5098:          prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 5099:        }
        -: 5100:
        -: 5101:        ecma_property_value_t *property_value_p;
    #####: 5102:        property_value_p = ecma_create_named_data_property (scope_p, name_p, prop_attributes, NULL);
        -: 5103:
    #####: 5104:        if (opcode != CBC_CREATE_VAR)
        -: 5105:        {
    #####: 5106:          property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 5107:        }
    #####: 5108:        break;
        -: 5109:      }
    #####: 5110:      case CBC_INIT_ARG_OR_FUNC:
        -: 5111:      {
        -: 5112:        uint32_t literal_index;
        -: 5113:
    #####: 5114:        READ_LITERAL_INDEX (literal_index);
        -: 5115:
        -: 5116:        ecma_compiled_code_t *function_bytecode_p;
        -: 5117:#if JERRY_SNAPSHOT_EXEC
    #####: 5118:        if (JERRY_LIKELY (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 5119:        {
        -: 5120:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 5121:          function_bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, literal_start_p[literal_index]);
        -: 5122:#if JERRY_SNAPSHOT_EXEC
        -: 5123:        }
        -: 5124:        else
        -: 5125:        {
    #####: 5126:          uint8_t *byte_p = ((uint8_t *) compiled_code_p) + literal_start_p[literal_index];
    #####: 5127:          function_bytecode_p = (ecma_compiled_code_t *) byte_p;
        -: 5128:        }
        -: 5129:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 5130:
    #####: 5131:        JERRY_ASSERT (CBC_IS_FUNCTION (function_bytecode_p->status_flags));
        -: 5132:
        -: 5133:        ecma_object_t *function_obj_p;
        -: 5134:
    #####: 5135:        if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (function_bytecode_p->status_flags)))
        -: 5136:        {
    #####: 5137:          function_obj_p = ecma_op_create_arrow_function_object (scope_p, function_bytecode_p, ECMA_VALUE_UNDEFINED);
        -: 5138:        }
        -: 5139:        else
        -: 5140:        {
    #####: 5141:          function_obj_p = ecma_op_create_any_function_object (scope_p, function_bytecode_p);
        -: 5142:        }
        -: 5143:
    #####: 5144:        READ_LITERAL_INDEX (literal_index);
    #####: 5145:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5146:
    #####: 5147:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5148:
        -: 5149:        ecma_property_value_t *property_value_p;
    #####: 5150:        property_value_p = ecma_create_named_data_property (scope_p, name_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 5151:
    #####: 5152:        JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 5153:        property_value_p->value = ecma_make_object_value (function_obj_p);
    #####: 5154:        ecma_deref_object (function_obj_p);
    #####: 5155:        break;
        -: 5156:      }
    #####: 5157:      default:
        -: 5158:      {
    #####: 5159:        JERRY_ASSERT (opcode == CBC_RETURN_FUNCTION_END);
    #####: 5160:        return ECMA_VALUE_EMPTY;
        -: 5161:      }
        -: 5162:    }
        -: 5163:  }
        -: 5164:} /* vm_init_module_scope */
        -: 5165:
        -: 5166:#endif /* JERRY_MODULE_SYSTEM */
        -: 5167:
        -: 5168:#undef READ_LITERAL
        -: 5169:#undef READ_LITERAL_INDEX
        -: 5170:
        -: 5171:JERRY_STATIC_ASSERT ((int) VM_FRAME_CTX_SHARED_DIRECT_EVAL == (int) VM_FRAME_CTX_DIRECT_EVAL,
        -: 5172:                     vm_frame_ctx_shared_direct_eval_must_be_equal_to_frame_ctx_direct_eval);
        -: 5173:
        -: 5174:JERRY_STATIC_ASSERT ((int) CBC_CODE_FLAGS_STRICT_MODE == (int) VM_FRAME_CTX_IS_STRICT,
        -: 5175:                     cbc_code_flags_strict_mode_must_be_equal_to_vm_frame_ctx_is_strict);
        -: 5176:
        -: 5177:/**
        -: 5178: * Initialize code block execution
        -: 5179: *
        -: 5180: * @return ECMA_VALUE_ERROR - if the initialization fails
        -: 5181: *         ECMA_VALUE_EMPTY - otherwise
        -: 5182: */
        -: 5183:static void JERRY_ATTR_NOINLINE
    11911: 5184:vm_init_exec (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5185:{
    11911: 5186:  vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
    11911: 5187:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5188:
    11911: 5189:  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);
    11911: 5190:  frame_ctx_p->context_depth = 0;
    23822: 5191:  frame_ctx_p->status_flags = (uint8_t) ((shared_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL)
    11911: 5192:                                         | (bytecode_header_p->status_flags & VM_FRAME_CTX_IS_STRICT));
        -: 5193:
        -: 5194:  uint16_t argument_end, register_end;
        -: 5195:  ecma_value_t *literal_p;
        -: 5196:
    11911: 5197:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5198:  {
    #####: 5199:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -: 5200:
    #####: 5201:    argument_end = args_p->argument_end;
    #####: 5202:    register_end = args_p->register_end;
        -: 5203:
    #####: 5204:    literal_p = (ecma_value_t *) (args_p + 1);
    #####: 5205:    literal_p -= register_end;
    #####: 5206:    frame_ctx_p->literal_start_p = literal_p;
    #####: 5207:    literal_p += args_p->literal_end;
        -: 5208:  }
        -: 5209:  else
        -: 5210:  {
    11911: 5211:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -: 5212:
    11911: 5213:    argument_end = args_p->argument_end;
    11911: 5214:    register_end = args_p->register_end;
        -: 5215:
    11911: 5216:    literal_p = (ecma_value_t *) (args_p + 1);
    11911: 5217:    literal_p -= register_end;
    11911: 5218:    frame_ctx_p->literal_start_p = literal_p;
    11911: 5219:    literal_p += args_p->literal_end;
        -: 5220:  }
        -: 5221:
    11911: 5222:  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;
    11911: 5223:  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;
    11911: 5224:  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;
        -: 5225:
    11911: 5226:  uint32_t arg_list_len = 0;
        -: 5227:
    11911: 5228:  if (argument_end > 0)
        -: 5229:  {
    #####: 5230:    JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 5231:
    #####: 5232:    const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 5233:    arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 5234:
    #####: 5235:    if (arg_list_len > argument_end)
        -: 5236:    {
    #####: 5237:      arg_list_len = argument_end;
        -: 5238:    }
        -: 5239:
    #####: 5240:    for (uint32_t i = 0; i < arg_list_len; i++)
        -: 5241:    {
    #####: 5242:      VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_list_p[i]);
        -: 5243:    }
        -: 5244:  }
        -: 5245:
        -: 5246:  /* The arg_list_len contains the end of the copied arguments.
        -: 5247:   * Fill everything else with undefined. */
    11911: 5248:  if (register_end > arg_list_len)
        -: 5249:  {
        1: 5250:    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;
        -: 5251:
        3: 5252:    for (uint32_t i = arg_list_len; i < register_end; i++)
        -: 5253:    {
        2: 5254:      *stack_p++ = ECMA_VALUE_UNDEFINED;
        -: 5255:    }
        -: 5256:  }
        -: 5257:
    11911: 5258:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
    11911: 5259:  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;
    11911: 5260:} /* vm_init_exec */
        -: 5261:
        -: 5262:/**
        -: 5263: * Resume execution of a code block.
        -: 5264: *
        -: 5265: * @return ecma value
        -: 5266: */
        -: 5267:ecma_value_t JERRY_ATTR_NOINLINE
    11911: 5268:vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5269:{
        -: 5270:  while (true)
    #####: 5271:  {
    11911: 5272:    ecma_value_t completion_value = vm_loop (frame_ctx_p);
        -: 5273:
    11910: 5274:    switch (frame_ctx_p->call_operation)
        -: 5275:    {
        1: 5276:      case VM_EXEC_CALL:
        -: 5277:      {
        1: 5278:        opfunc_call (frame_ctx_p);
    #####: 5279:        break;
        -: 5280:      }
        -: 5281:#if JERRY_ESNEXT
    #####: 5282:      case VM_EXEC_SUPER_CALL:
        -: 5283:      {
    #####: 5284:        vm_super_call (frame_ctx_p);
    #####: 5285:        break;
        -: 5286:      }
    #####: 5287:      case VM_EXEC_SPREAD_OP:
        -: 5288:      {
    #####: 5289:        vm_spread_operation (frame_ctx_p);
    #####: 5290:        break;
        -: 5291:      }
    #####: 5292:      case VM_EXEC_RETURN:
        -: 5293:      {
    #####: 5294:        return completion_value;
        -: 5295:      }
        -: 5296:#endif /* JERRY_ESNEXT */
    11909: 5297:      case VM_EXEC_CONSTRUCT:
        -: 5298:      {
    11909: 5299:        opfunc_construct (frame_ctx_p);
    #####: 5300:        break;
        -: 5301:      }
    #####: 5302:      default:
        -: 5303:      {
    #####: 5304:        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);
        -: 5305:
    #####: 5306:        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -: 5307:        uint32_t register_end;
        -: 5308:
    #####: 5309:        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5310:        {
    #####: 5311:          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;
        -: 5312:        }
        -: 5313:        else
        -: 5314:        {
    #####: 5315:          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;
        -: 5316:        }
        -: 5317:
        -: 5318:        /* Free arguments and registers */
    #####: 5319:        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);
    #####: 5320:        for (uint32_t i = 0; i < register_end; i++)
        -: 5321:        {
    #####: 5322:          ecma_fast_free_value (registers_p[i]);
        -: 5323:        }
        -: 5324:
        -: 5325:#if JERRY_DEBUGGER
        -: 5326:        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))
        -: 5327:        {
        -: 5328:          /* The engine will stop when the next breakpoint is reached. */
        -: 5329:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);
        -: 5330:          JERRY_CONTEXT (debugger_stop_context) = NULL;
        -: 5331:        }
        -: 5332:#endif /* JERRY_DEBUGGER */
        -: 5333:
    #####: 5334:        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;
    #####: 5335:        return completion_value;
        -: 5336:      }
        -: 5337:    }
        -: 5338:  }
        -: 5339:} /* vm_execute */
        -: 5340:
        -: 5341:/**
        -: 5342: * Run the code.
        -: 5343: *
        -: 5344: * @return ecma value
        -: 5345: */
        -: 5346:ecma_value_t
    11911: 5347:vm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */
        -: 5348:        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */
        -: 5349:        ecma_object_t *lex_env_p) /**< lexical environment to use */
    11911: 5350:{
    11911: 5351:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5352:  vm_frame_ctx_t *frame_ctx_p;
        -: 5353:  size_t frame_size;
        -: 5354:
    11911: 5355:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5356:  {
    #####: 5357:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####: 5358:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5359:  }
        -: 5360:  else
        -: 5361:  {
    11911: 5362:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    11911: 5363:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5364:  }
        -: 5365:
    11911: 5366:  JERRY_VLA (ecma_value_t, stack, frame_size + (sizeof (vm_frame_ctx_t) / sizeof (ecma_value_t)));
        -: 5367:
    11911: 5368:  frame_ctx_p = (vm_frame_ctx_t *) stack;
        -: 5369:
    11911: 5370:  frame_ctx_p->shared_p = shared_p;
    11911: 5371:  frame_ctx_p->lex_env_p = lex_env_p;
    11911: 5372:  frame_ctx_p->this_binding = this_binding_value;
        -: 5373:
    11911: 5374:  vm_init_exec (frame_ctx_p);
    11911: 5375:  return vm_execute (frame_ctx_p);
        -: 5376:} /* vm_run */
        -: 5377:
        -: 5378:/**
        -: 5379: * @}
        -: 5380: * @}
        -: 5381: */
