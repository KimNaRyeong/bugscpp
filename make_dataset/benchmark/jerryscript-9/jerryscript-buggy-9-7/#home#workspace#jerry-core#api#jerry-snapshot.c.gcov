        -:    0:Source:/home/workspace/jerry-core/api/jerry-snapshot.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerry-snapshot.h"
        -:   17:
        -:   18:#include "jerryscript.h"
        -:   19:
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-errors.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-helpers.h"
        -:   25:#include "ecma-lex-env.h"
        -:   26:#include "ecma-literal-storage.h"
        -:   27:
        -:   28:#include "jcontext.h"
        -:   29:#include "js-parser-internal.h"
        -:   30:#include "js-parser.h"
        -:   31:#include "lit-char-helpers.h"
        -:   32:#include "re-compiler.h"
        -:   33:
        -:   34:#if JERRY_SNAPSHOT_SAVE || JERRY_SNAPSHOT_EXEC
        -:   35:
        -:   36:/**
        -:   37: * Get snapshot configuration flags.
        -:   38: *
        -:   39: * @return configuration flags
        -:   40: */
        -:   41:static inline uint32_t JERRY_ATTR_ALWAYS_INLINE
        -:   42:snapshot_get_global_flags (bool has_regex, /**< regex literal is present */
        -:   43:                           bool has_class) /**< class literal is present */
        -:   44:{
        -:   45:  JERRY_UNUSED (has_regex);
        -:   46:  JERRY_UNUSED (has_class);
        -:   47:
    #####:   48:  uint32_t flags = 0;
        -:   49:
        -:   50:#if JERRY_BUILTIN_REGEXP
    #####:   51:  flags |= (has_regex ? JERRY_SNAPSHOT_HAS_REGEX_LITERAL : 0);
        -:   52:#endif /* JERRY_BUILTIN_REGEXP */
        -:   53:#if JERRY_ESNEXT
    #####:   54:  flags |= (has_class ? JERRY_SNAPSHOT_HAS_CLASS_LITERAL : 0);
        -:   55:#endif /* JERRY_ESNEXT */
        -:   56:
        -:   57:  return flags;
        -:   58:} /* snapshot_get_global_flags */
        -:   59:
        -:   60:/**
        -:   61: * Checks whether the global_flags argument matches to the current feature set.
        -:   62: *
        -:   63: * @return true if global_flags accepted, false otherwise
        -:   64: */
        -:   65:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:   66:snapshot_check_global_flags (uint32_t global_flags) /**< global flags */
        -:   67:{
        -:   68:#if JERRY_BUILTIN_REGEXP
    #####:   69:  global_flags &= (uint32_t) ~JERRY_SNAPSHOT_HAS_REGEX_LITERAL;
        -:   70:#endif /* JERRY_BUILTIN_REGEXP */
        -:   71:#if JERRY_ESNEXT
    #####:   72:  global_flags &= (uint32_t) ~JERRY_SNAPSHOT_HAS_CLASS_LITERAL;
        -:   73:#endif /* JERRY_ESNEXT */
        -:   74:
    #####:   75:  return global_flags == snapshot_get_global_flags (false, false);
        -:   76:} /* snapshot_check_global_flags */
        -:   77:
        -:   78:#endif /* JERRY_SNAPSHOT_SAVE || JERRY_SNAPSHOT_EXEC */
        -:   79:
        -:   80:#if JERRY_SNAPSHOT_SAVE
        -:   81:
        -:   82:/**
        -:   83: * Variables required to take a snapshot.
        -:   84: */
        -:   85:typedef struct
        -:   86:{
        -:   87:  size_t snapshot_buffer_write_offset;
        -:   88:  ecma_value_t snapshot_error;
        -:   89:  bool regex_found;
        -:   90:  bool class_found;
        -:   91:} snapshot_globals_t;
        -:   92:
        -:   93:/** \addtogroup jerrysnapshot Jerry snapshot operations
        -:   94: * @{
        -:   95: */
        -:   96:
        -:   97:/**
        -:   98: * Write data into the specified buffer.
        -:   99: *
        -:  100: * Note:
        -:  101: *      Offset is in-out and is incremented if the write operation completes successfully.
        -:  102: *
        -:  103: * @return true - if write was successful, i.e. offset + data_size doesn't exceed buffer size,
        -:  104: *         false - otherwise
        -:  105: */
        -:  106:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  107:snapshot_write_to_buffer_by_offset (uint8_t *buffer_p, /**< buffer */
        -:  108:                                    size_t buffer_size, /**< size of buffer */
        -:  109:                                    size_t *in_out_buffer_offset_p, /**< [in,out] offset to write to
        -:  110:                                                                     * incremented with data_size */
        -:  111:                                    const void *data_p, /**< data */
        -:  112:                                    size_t data_size) /**< size of the writable data */
        -:  113:{
    #####:  114:  if (*in_out_buffer_offset_p + data_size > buffer_size)
        -:  115:  {
        -:  116:    return false;
        -:  117:  }
        -:  118:
    #####:  119:  memcpy (buffer_p + *in_out_buffer_offset_p, data_p, data_size);
    #####:  120:  *in_out_buffer_offset_p += data_size;
        -:  121:
        -:  122:  return true;
        -:  123:} /* snapshot_write_to_buffer_by_offset */
        -:  124:
        -:  125:/**
        -:  126: * Maximum snapshot write buffer offset.
        -:  127: */
        -:  128:#if !JERRY_NUMBER_TYPE_FLOAT64
        -:  129:#define JERRY_SNAPSHOT_MAXIMUM_WRITE_OFFSET (0x7fffff >> 1)
        -:  130:#else /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  131:#define JERRY_SNAPSHOT_MAXIMUM_WRITE_OFFSET (UINT32_MAX >> 1)
        -:  132:#endif /* !JERRY_NUMBER_TYPE_FLOAT64 */
        -:  133:
        -:  134:/**
        -:  135: * Save snapshot helper.
        -:  136: *
        -:  137: * @return start offset
        -:  138: */
        -:  139:static uint32_t
    #####:  140:snapshot_add_compiled_code (const ecma_compiled_code_t *compiled_code_p, /**< compiled code */
        -:  141:                            uint8_t *snapshot_buffer_p, /**< snapshot buffer */
        -:  142:                            size_t snapshot_buffer_size, /**< snapshot buffer size */
        -:  143:                            snapshot_globals_t *globals_p) /**< snapshot globals */
        -:  144:{
    #####:  145:  const char *error_buffer_too_small_p = "Snapshot buffer too small";
        -:  146:
    #####:  147:  if (!ecma_is_value_empty (globals_p->snapshot_error))
        -:  148:  {
        -:  149:    return 0;
        -:  150:  }
        -:  151:
        -:  152:  JERRY_ASSERT ((globals_p->snapshot_buffer_write_offset & (JMEM_ALIGNMENT - 1)) == 0);
        -:  153:
    #####:  154:  if (globals_p->snapshot_buffer_write_offset > JERRY_SNAPSHOT_MAXIMUM_WRITE_OFFSET)
        -:  155:  {
    #####:  156:    globals_p->snapshot_error = jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_MAXIMUM_SNAPSHOT_SIZE));
    #####:  157:    return 0;
        -:  158:  }
        -:  159:
        -:  160:  /* The snapshot generator always parses a single file,
        -:  161:   * so the base always starts right after the snapshot header. */
    #####:  162:  uint32_t start_offset = (uint32_t) (globals_p->snapshot_buffer_write_offset - sizeof (jerry_snapshot_header_t));
        -:  163:
    #####:  164:  uint8_t *copied_code_start_p = snapshot_buffer_p + globals_p->snapshot_buffer_write_offset;
    #####:  165:  ecma_compiled_code_t *copied_code_p = (ecma_compiled_code_t *) copied_code_start_p;
        -:  166:
        -:  167:#if JERRY_ESNEXT
    #####:  168:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_HAS_TAGGED_LITERALS)
        -:  169:  {
    #####:  170:    globals_p->snapshot_error =
    #####:  171:      jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_TAGGED_TEMPLATE_LITERALS));
    #####:  172:    return 0;
        -:  173:  }
        -:  174:
    #####:  175:  if (CBC_FUNCTION_GET_TYPE (compiled_code_p->status_flags) == CBC_FUNCTION_CONSTRUCTOR)
        -:  176:  {
    #####:  177:    globals_p->class_found = true;
        -:  178:  }
        -:  179:#endif /* JERRY_ESNEXT */
        -:  180:
        -:  181:#if JERRY_BUILTIN_REGEXP
    #####:  182:  if (!CBC_IS_FUNCTION (compiled_code_p->status_flags))
        -:  183:  {
        -:  184:    /* Regular expression. */
    #####:  185:    if (globals_p->snapshot_buffer_write_offset + sizeof (ecma_compiled_code_t) > snapshot_buffer_size)
        -:  186:    {
    #####:  187:      globals_p->snapshot_error = jerry_throw_sz (JERRY_ERROR_RANGE, error_buffer_too_small_p);
    #####:  188:      return 0;
        -:  189:    }
        -:  190:
    #####:  191:    globals_p->snapshot_buffer_write_offset += sizeof (ecma_compiled_code_t);
        -:  192:
    #####:  193:    ecma_value_t pattern = ((re_compiled_code_t *) compiled_code_p)->source;
    #####:  194:    ecma_string_t *pattern_string_p = ecma_get_string_from_value (pattern);
        -:  195:
    #####:  196:    lit_utf8_size_t pattern_size = 0;
        -:  197:
    #####:  198:    ECMA_STRING_TO_UTF8_STRING (pattern_string_p, buffer_p, buffer_size);
        -:  199:
    #####:  200:    pattern_size = buffer_size;
        -:  201:
    #####:  202:    if (!snapshot_write_to_buffer_by_offset (snapshot_buffer_p,
        -:  203:                                             snapshot_buffer_size,
        -:  204:                                             &globals_p->snapshot_buffer_write_offset,
        -:  205:                                             buffer_p,
        -:  206:                                             buffer_size))
        -:  207:    {
    #####:  208:      globals_p->snapshot_error = jerry_throw_sz (JERRY_ERROR_RANGE, error_buffer_too_small_p);
        -:  209:      /* cannot return inside ECMA_FINALIZE_UTF8_STRING */
        -:  210:    }
        -:  211:
    #####:  212:    ECMA_FINALIZE_UTF8_STRING (buffer_p, buffer_size);
        -:  213:
    #####:  214:    if (!ecma_is_value_empty (globals_p->snapshot_error))
        -:  215:    {
        -:  216:      return 0;
        -:  217:    }
        -:  218:
    #####:  219:    globals_p->regex_found = true;
    #####:  220:    globals_p->snapshot_buffer_write_offset = JERRY_ALIGNUP (globals_p->snapshot_buffer_write_offset, JMEM_ALIGNMENT);
        -:  221:
        -:  222:    /* Regexp character size is stored in refs. */
    #####:  223:    copied_code_p->refs = (uint16_t) pattern_size;
        -:  224:
    #####:  225:    pattern_size += (lit_utf8_size_t) sizeof (ecma_compiled_code_t);
    #####:  226:    copied_code_p->size = (uint16_t) ((pattern_size + JMEM_ALIGNMENT - 1) >> JMEM_ALIGNMENT_LOG);
        -:  227:
    #####:  228:    copied_code_p->status_flags = compiled_code_p->status_flags;
        -:  229:
    #####:  230:    return start_offset;
        -:  231:  }
        -:  232:#endif /* JERRY_BUILTIN_REGEXP */
        -:  233:
        -:  234:  JERRY_ASSERT (CBC_IS_FUNCTION (compiled_code_p->status_flags));
        -:  235:
    #####:  236:  if (!snapshot_write_to_buffer_by_offset (snapshot_buffer_p,
        -:  237:                                           snapshot_buffer_size,
        -:  238:                                           &globals_p->snapshot_buffer_write_offset,
        -:  239:                                           compiled_code_p,
    #####:  240:                                           ((size_t) compiled_code_p->size) << JMEM_ALIGNMENT_LOG))
        -:  241:  {
    #####:  242:    globals_p->snapshot_error = jerry_throw_sz (JERRY_ERROR_RANGE, error_buffer_too_small_p);
    #####:  243:    return 0;
        -:  244:  }
        -:  245:
        -:  246:  /* Sub-functions and regular expressions are stored recursively. */
    #####:  247:  uint8_t *buffer_p = (uint8_t *) copied_code_p;
        -:  248:  ecma_value_t *literal_start_p;
        -:  249:  uint32_t const_literal_end;
        -:  250:  uint32_t literal_end;
        -:  251:
        -:  252:#if JERRY_LINE_INFO
        -:  253:  /* TODO: support snapshots. */
    #####:  254:  ((ecma_compiled_code_t *) buffer_p)->status_flags &= (uint16_t) ~CBC_CODE_FLAGS_HAS_LINE_INFO;
        -:  255:#endif /* JERRY_LINE_INFO */
        -:  256:
    #####:  257:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  258:  {
    #####:  259:    literal_start_p = (ecma_value_t *) (buffer_p + sizeof (cbc_uint16_arguments_t));
        -:  260:
    #####:  261:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) buffer_p;
    #####:  262:    literal_end = (uint32_t) (args_p->literal_end - args_p->register_end);
    #####:  263:    const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -:  264:  }
        -:  265:  else
        -:  266:  {
    #####:  267:    literal_start_p = (ecma_value_t *) (buffer_p + sizeof (cbc_uint8_arguments_t));
        -:  268:
    #####:  269:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) buffer_p;
    #####:  270:    literal_end = (uint32_t) (args_p->literal_end - args_p->register_end);
    #####:  271:    const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -:  272:  }
        -:  273:
    #####:  274:  for (uint32_t i = const_literal_end; i < literal_end; i++)
        -:  275:  {
    #####:  276:    ecma_compiled_code_t *bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, literal_start_p[i]);
        -:  277:
    #####:  278:    if (bytecode_p == compiled_code_p)
        -:  279:    {
    #####:  280:      literal_start_p[i] = 0;
        -:  281:    }
        -:  282:    else
        -:  283:    {
    #####:  284:      uint32_t offset = snapshot_add_compiled_code (bytecode_p, snapshot_buffer_p, snapshot_buffer_size, globals_p);
        -:  285:
        -:  286:      JERRY_ASSERT (!ecma_is_value_empty (globals_p->snapshot_error) || offset > start_offset);
        -:  287:
    #####:  288:      literal_start_p[i] = offset - start_offset;
        -:  289:    }
        -:  290:  }
        -:  291:
        -:  292:  return start_offset;
        -:  293:} /* snapshot_add_compiled_code */
        -:  294:
        -:  295:/**
        -:  296: * Create unsupported literal error.
        -:  297: */
        -:  298:static void
    #####:  299:static_snapshot_error_unsupported_literal (snapshot_globals_t *globals_p, /**< snapshot globals */
        -:  300:                                           ecma_value_t literal) /**< literal form the literal pool */
        -:  301:{
    #####:  302:  lit_utf8_byte_t *str_p = (lit_utf8_byte_t *) "Unsupported static snapshot literal: ";
    #####:  303:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_raw (str_p, 37);
        -:  304:
        -:  305:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (literal));
        -:  306:
    #####:  307:  ecma_string_t *literal_string_p = ecma_op_to_string (literal);
        -:  308:  JERRY_ASSERT (literal_string_p != NULL);
        -:  309:
    #####:  310:  ecma_stringbuilder_append (&builder, literal_string_p);
        -:  311:
    #####:  312:  ecma_deref_ecma_string (literal_string_p);
        -:  313:
    #####:  314:  ecma_object_t *error_object_p = ecma_new_standard_error (JERRY_ERROR_RANGE, ecma_stringbuilder_finalize (&builder));
        -:  315:
    #####:  316:  globals_p->snapshot_error = ecma_create_exception_from_object (error_object_p);
    #####:  317:} /* static_snapshot_error_unsupported_literal */
        -:  318:
        -:  319:/**
        -:  320: * Save static snapshot helper.
        -:  321: *
        -:  322: * @return start offset
        -:  323: */
        -:  324:static uint32_t
    #####:  325:static_snapshot_add_compiled_code (const ecma_compiled_code_t *compiled_code_p, /**< compiled code */
        -:  326:                                   uint8_t *snapshot_buffer_p, /**< snapshot buffer */
        -:  327:                                   size_t snapshot_buffer_size, /**< snapshot buffer size */
        -:  328:                                   snapshot_globals_t *globals_p) /**< snapshot globals */
        -:  329:{
    #####:  330:  if (!ecma_is_value_empty (globals_p->snapshot_error))
        -:  331:  {
        -:  332:    return 0;
        -:  333:  }
        -:  334:
        -:  335:  JERRY_ASSERT ((globals_p->snapshot_buffer_write_offset & (JMEM_ALIGNMENT - 1)) == 0);
        -:  336:
    #####:  337:  if (globals_p->snapshot_buffer_write_offset >= JERRY_SNAPSHOT_MAXIMUM_WRITE_OFFSET)
        -:  338:  {
    #####:  339:    globals_p->snapshot_error = jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_MAXIMUM_SNAPSHOT_SIZE));
    #####:  340:    return 0;
        -:  341:  }
        -:  342:
        -:  343:  /* The snapshot generator always parses a single file,
        -:  344:   * so the base always starts right after the snapshot header. */
    #####:  345:  uint32_t start_offset = (uint32_t) (globals_p->snapshot_buffer_write_offset - sizeof (jerry_snapshot_header_t));
        -:  346:
    #####:  347:  uint8_t *copied_code_start_p = snapshot_buffer_p + globals_p->snapshot_buffer_write_offset;
    #####:  348:  ecma_compiled_code_t *copied_code_p = (ecma_compiled_code_t *) copied_code_start_p;
        -:  349:
    #####:  350:  if (!CBC_IS_FUNCTION (compiled_code_p->status_flags))
        -:  351:  {
        -:  352:    /* Regular expression literals are not supported. */
    #####:  353:    globals_p->snapshot_error =
    #####:  354:      jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_REGULAR_EXPRESSION_NOT_SUPPORTED));
    #####:  355:    return 0;
        -:  356:  }
        -:  357:
    #####:  358:  if (!snapshot_write_to_buffer_by_offset (snapshot_buffer_p,
        -:  359:                                           snapshot_buffer_size,
        -:  360:                                           &globals_p->snapshot_buffer_write_offset,
        -:  361:                                           compiled_code_p,
    #####:  362:                                           ((size_t) compiled_code_p->size) << JMEM_ALIGNMENT_LOG))
        -:  363:  {
    #####:  364:    globals_p->snapshot_error = jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_SNAPSHOT_BUFFER_SMALL));
    #####:  365:    return 0;
        -:  366:  }
        -:  367:
        -:  368:  /* Sub-functions and regular expressions are stored recursively. */
    #####:  369:  uint8_t *buffer_p = (uint8_t *) copied_code_p;
        -:  370:  ecma_value_t *literal_start_p;
        -:  371:  uint32_t const_literal_end;
        -:  372:  uint32_t literal_end;
        -:  373:
    #####:  374:  ((ecma_compiled_code_t *) copied_code_p)->status_flags |= CBC_CODE_FLAGS_STATIC_FUNCTION;
        -:  375:
    #####:  376:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  377:  {
    #####:  378:    literal_start_p = (ecma_value_t *) (buffer_p + sizeof (cbc_uint16_arguments_t));
        -:  379:
    #####:  380:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) buffer_p;
    #####:  381:    literal_end = (uint32_t) (args_p->literal_end - args_p->register_end);
    #####:  382:    const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -:  383:
    #####:  384:    args_p->script_value = JMEM_CP_NULL;
        -:  385:  }
        -:  386:  else
        -:  387:  {
    #####:  388:    literal_start_p = (ecma_value_t *) (buffer_p + sizeof (cbc_uint8_arguments_t));
        -:  389:
    #####:  390:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) buffer_p;
    #####:  391:    literal_end = (uint32_t) (args_p->literal_end - args_p->register_end);
    #####:  392:    const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -:  393:
    #####:  394:    args_p->script_value = JMEM_CP_NULL;
        -:  395:  }
        -:  396:
    #####:  397:  for (uint32_t i = 0; i < const_literal_end; i++)
        -:  398:  {
    #####:  399:    if (!ecma_is_value_direct (literal_start_p[i]) && !ecma_is_value_direct_string (literal_start_p[i]))
        -:  400:    {
    #####:  401:      static_snapshot_error_unsupported_literal (globals_p, literal_start_p[i]);
    #####:  402:      return 0;
        -:  403:    }
        -:  404:  }
        -:  405:
    #####:  406:  for (uint32_t i = const_literal_end; i < literal_end; i++)
        -:  407:  {
    #####:  408:    ecma_compiled_code_t *bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, literal_start_p[i]);
        -:  409:
    #####:  410:    if (bytecode_p == compiled_code_p)
        -:  411:    {
    #####:  412:      literal_start_p[i] = 0;
        -:  413:    }
        -:  414:    else
        -:  415:    {
    #####:  416:      uint32_t offset =
        -:  417:        static_snapshot_add_compiled_code (bytecode_p, snapshot_buffer_p, snapshot_buffer_size, globals_p);
        -:  418:
        -:  419:      JERRY_ASSERT (!ecma_is_value_empty (globals_p->snapshot_error) || offset > start_offset);
        -:  420:
    #####:  421:      literal_start_p[i] = offset - start_offset;
        -:  422:    }
        -:  423:  }
        -:  424:
    #####:  425:  buffer_p += ((size_t) compiled_code_p->size) << JMEM_ALIGNMENT_LOG;
    #####:  426:  literal_start_p = ecma_snapshot_resolve_serializable_values (compiled_code_p, buffer_p);
        -:  427:
    #####:  428:  while (literal_start_p < (ecma_value_t *) buffer_p)
        -:  429:  {
    #####:  430:    if (!ecma_is_value_direct_string (*literal_start_p) && !ecma_is_value_empty (*literal_start_p))
        -:  431:    {
    #####:  432:      static_snapshot_error_unsupported_literal (globals_p, *literal_start_p);
    #####:  433:      return 0;
        -:  434:    }
        -:  435:
    #####:  436:    literal_start_p++;
        -:  437:  }
        -:  438:
        -:  439:  return start_offset;
        -:  440:} /* static_snapshot_add_compiled_code */
        -:  441:
        -:  442:/**
        -:  443: * Set the uint16_t offsets in the code area.
        -:  444: */
        -:  445:static void
    #####:  446:jerry_snapshot_set_offsets (uint32_t *buffer_p, /**< buffer */
        -:  447:                            uint32_t size, /**< buffer size */
        -:  448:                            lit_mem_to_snapshot_id_map_entry_t *lit_map_p) /**< literal map */
        -:  449:{
        -:  450:  JERRY_ASSERT (size > 0);
        -:  451:
        -:  452:  do
        -:  453:  {
    #####:  454:    ecma_compiled_code_t *bytecode_p = (ecma_compiled_code_t *) buffer_p;
    #####:  455:    uint32_t code_size = ((uint32_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG;
        -:  456:
    #####:  457:    if (CBC_IS_FUNCTION (bytecode_p->status_flags))
        -:  458:    {
        -:  459:      ecma_value_t *literal_start_p;
        -:  460:      uint32_t const_literal_end;
        -:  461:
    #####:  462:      if (bytecode_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  463:      {
    #####:  464:        literal_start_p = (ecma_value_t *) (((uint8_t *) buffer_p) + sizeof (cbc_uint16_arguments_t));
        -:  465:
    #####:  466:        cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) buffer_p;
    #####:  467:        const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -:  468:      }
        -:  469:      else
        -:  470:      {
    #####:  471:        literal_start_p = (ecma_value_t *) (((uint8_t *) buffer_p) + sizeof (cbc_uint8_arguments_t));
        -:  472:
    #####:  473:        cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) buffer_p;
    #####:  474:        const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -:  475:      }
        -:  476:
    #####:  477:      for (uint32_t i = 0; i < const_literal_end; i++)
        -:  478:      {
    #####:  479:        if (ecma_is_value_string (literal_start_p[i])
        -:  480:#if JERRY_BUILTIN_BIGINT
    #####:  481:            || ecma_is_value_bigint (literal_start_p[i])
        -:  482:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  483:            || ecma_is_value_float_number (literal_start_p[i]))
        -:  484:        {
        -:  485:          lit_mem_to_snapshot_id_map_entry_t *current_p = lit_map_p;
        -:  486:
    #####:  487:          while (current_p->literal_id != literal_start_p[i])
        -:  488:          {
    #####:  489:            current_p++;
        -:  490:          }
        -:  491:
    #####:  492:          literal_start_p[i] = current_p->literal_offset;
        -:  493:        }
        -:  494:      }
        -:  495:
    #####:  496:      uint8_t *byte_p = (uint8_t *) bytecode_p + (((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);
    #####:  497:      literal_start_p = ecma_snapshot_resolve_serializable_values (bytecode_p, byte_p);
        -:  498:
    #####:  499:      while (literal_start_p < (ecma_value_t *) byte_p)
        -:  500:      {
    #####:  501:        if (*literal_start_p != ECMA_VALUE_EMPTY)
        -:  502:        {
        -:  503:          JERRY_ASSERT (ecma_is_value_string (*literal_start_p));
        -:  504:
        -:  505:          lit_mem_to_snapshot_id_map_entry_t *current_p = lit_map_p;
        -:  506:
    #####:  507:          while (current_p->literal_id != *literal_start_p)
        -:  508:          {
    #####:  509:            current_p++;
        -:  510:          }
        -:  511:
    #####:  512:          *literal_start_p = current_p->literal_offset;
        -:  513:        }
        -:  514:
    #####:  515:        literal_start_p++;
        -:  516:      }
        -:  517:
        -:  518:      /* Set reference counter to 1. */
    #####:  519:      bytecode_p->refs = 1;
        -:  520:    }
        -:  521:
        -:  522:    JERRY_ASSERT ((code_size % sizeof (uint32_t)) == 0);
    #####:  523:    buffer_p += code_size / sizeof (uint32_t);
    #####:  524:    size -= code_size;
    #####:  525:  } while (size > 0);
    #####:  526:} /* jerry_snapshot_set_offsets */
        -:  527:
        -:  528:#endif /* JERRY_SNAPSHOT_SAVE */
        -:  529:
        -:  530:#if JERRY_SNAPSHOT_EXEC
        -:  531:
        -:  532:/**
        -:  533: * Byte code blocks shorter than this threshold are always copied into the memory.
        -:  534: * The memory / performance trade-of of byte code redirection does not worth
        -:  535: * in such cases.
        -:  536: */
        -:  537:#define BYTECODE_NO_COPY_THRESHOLD 8
        -:  538:
        -:  539:/**
        -:  540: * Load byte code from snapshot.
        -:  541: *
        -:  542: * @return byte code
        -:  543: */
        -:  544:static ecma_compiled_code_t *
    #####:  545:snapshot_load_compiled_code (const uint8_t *base_addr_p, /**< base address of the
        -:  546:                                                          *   current primary function */
        -:  547:                             const uint8_t *literal_base_p, /**< literal start */
        -:  548:                             cbc_script_t *script_p, /**< script */
        -:  549:                             bool copy_bytecode) /**< byte code should be copied to memory */
        -:  550:{
    #####:  551:  ecma_compiled_code_t *bytecode_p = (ecma_compiled_code_t *) base_addr_p;
    #####:  552:  uint32_t code_size = ((uint32_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG;
        -:  553:
        -:  554:#if JERRY_BUILTIN_REGEXP
    #####:  555:  if (!CBC_IS_FUNCTION (bytecode_p->status_flags))
        -:  556:  {
    #####:  557:    const uint8_t *regex_start_p = ((const uint8_t *) bytecode_p) + sizeof (ecma_compiled_code_t);
        -:  558:
        -:  559:    /* Real size is stored in refs. */
    #####:  560:    ecma_string_t *pattern_str_p = ecma_new_ecma_string_from_utf8 (regex_start_p, bytecode_p->refs);
        -:  561:
    #####:  562:    const re_compiled_code_t *re_bytecode_p = re_compile_bytecode (pattern_str_p, bytecode_p->status_flags);
    #####:  563:    ecma_deref_ecma_string (pattern_str_p);
        -:  564:
    #####:  565:    return (ecma_compiled_code_t *) re_bytecode_p;
        -:  566:  }
        -:  567:#else /* !JERRY_BUILTIN_REGEXP */
        -:  568:  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));
        -:  569:#endif /* JERRY_BUILTIN_REGEXP */
        -:  570:
        -:  571:  size_t header_size;
        -:  572:  uint32_t argument_end;
        -:  573:  uint32_t const_literal_end;
        -:  574:  uint32_t literal_end;
        -:  575:
    #####:  576:  if (JERRY_UNLIKELY (script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -:  577:  {
        -:  578:    /* This is probably never happens in practice. */
    #####:  579:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -:  580:  }
        -:  581:
    #####:  582:  script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
        -:  583:
    #####:  584:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  585:  {
    #####:  586:    uint8_t *byte_p = (uint8_t *) bytecode_p;
    #####:  587:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) byte_p;
        -:  588:
    #####:  589:    argument_end = args_p->argument_end;
    #####:  590:    const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
    #####:  591:    literal_end = (uint32_t) (args_p->literal_end - args_p->register_end);
    #####:  592:    header_size = sizeof (cbc_uint16_arguments_t);
        -:  593:
    #####:  594:    ECMA_SET_INTERNAL_VALUE_POINTER (args_p->script_value, script_p);
        -:  595:  }
        -:  596:  else
        -:  597:  {
    #####:  598:    uint8_t *byte_p = (uint8_t *) bytecode_p;
    #####:  599:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) byte_p;
        -:  600:
    #####:  601:    argument_end = args_p->argument_end;
    #####:  602:    const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
    #####:  603:    literal_end = (uint32_t) (args_p->literal_end - args_p->register_end);
    #####:  604:    header_size = sizeof (cbc_uint8_arguments_t);
        -:  605:
    #####:  606:    ECMA_SET_INTERNAL_VALUE_POINTER (args_p->script_value, script_p);
        -:  607:  }
        -:  608:
    #####:  609:  if (copy_bytecode || (header_size + (literal_end * sizeof (uint16_t)) + BYTECODE_NO_COPY_THRESHOLD > code_size))
        -:  610:  {
    #####:  611:    bytecode_p = (ecma_compiled_code_t *) jmem_heap_alloc_block (code_size);
        -:  612:
        -:  613:#if JERRY_MEM_STATS
    #####:  614:    jmem_stats_allocate_byte_code_bytes (code_size);
        -:  615:#endif /* JERRY_MEM_STATS */
        -:  616:
    #####:  617:    memcpy (bytecode_p, base_addr_p, code_size);
        -:  618:  }
        -:  619:  else
        -:  620:  {
    #####:  621:    uint32_t start_offset = (uint32_t) (header_size + literal_end * sizeof (ecma_value_t));
        -:  622:
    #####:  623:    uint8_t *real_bytecode_p = ((uint8_t *) bytecode_p) + start_offset;
    #####:  624:    uint32_t new_code_size = (uint32_t) (start_offset + 1 + sizeof (uint8_t *));
    #####:  625:    uint32_t extra_bytes = 0;
        -:  626:
    #####:  627:    if (bytecode_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)
        -:  628:    {
    #####:  629:      extra_bytes += (uint32_t) (argument_end * sizeof (ecma_value_t));
        -:  630:    }
        -:  631:
        -:  632:#if JERRY_ESNEXT
        -:  633:    /* function name */
    #####:  634:    if (CBC_FUNCTION_GET_TYPE (bytecode_p->status_flags) != CBC_FUNCTION_CONSTRUCTOR)
        -:  635:    {
    #####:  636:      extra_bytes += (uint32_t) sizeof (ecma_value_t);
        -:  637:    }
        -:  638:
        -:  639:    /* tagged template literals */
    #####:  640:    if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_TAGGED_LITERALS)
        -:  641:    {
    #####:  642:      extra_bytes += (uint32_t) sizeof (ecma_value_t);
        -:  643:    }
        -:  644:#endif /* JERRY_ESNEXT */
        -:  645:
        -:  646:#if JERRY_SOURCE_NAME
        -:  647:    /* source name */
    #####:  648:    extra_bytes += (uint32_t) sizeof (ecma_value_t);
        -:  649:#endif /* JERRY_SOURCE_NAME */
        -:  650:
    #####:  651:    new_code_size = JERRY_ALIGNUP (new_code_size + extra_bytes, JMEM_ALIGNMENT);
        -:  652:
    #####:  653:    bytecode_p = (ecma_compiled_code_t *) jmem_heap_alloc_block (new_code_size);
        -:  654:
        -:  655:#if JERRY_MEM_STATS
    #####:  656:    jmem_stats_allocate_byte_code_bytes (new_code_size);
        -:  657:#endif /* JERRY_MEM_STATS */
        -:  658:
    #####:  659:    memcpy (bytecode_p, base_addr_p, start_offset);
        -:  660:
    #####:  661:    bytecode_p->size = (uint16_t) (new_code_size >> JMEM_ALIGNMENT_LOG);
        -:  662:
    #####:  663:    uint8_t *byte_p = (uint8_t *) bytecode_p;
        -:  664:
    #####:  665:    uint8_t *new_base_p = byte_p + new_code_size - extra_bytes;
    #####:  666:    const uint8_t *base_p = base_addr_p + code_size - extra_bytes;
        -:  667:
        -:  668:    if (extra_bytes != 0)
        -:  669:    {
    #####:  670:      memcpy (new_base_p, base_p, extra_bytes);
        -:  671:    }
        -:  672:
    #####:  673:    byte_p[start_offset] = CBC_SET_BYTECODE_PTR;
    #####:  674:    memcpy (byte_p + start_offset + 1, &real_bytecode_p, sizeof (uintptr_t));
        -:  675:
    #####:  676:    code_size = new_code_size;
        -:  677:  }
        -:  678:
        -:  679:  JERRY_ASSERT (bytecode_p->refs == 1);
        -:  680:
        -:  681:#if JERRY_DEBUGGER
        -:  682:  bytecode_p->status_flags = (uint16_t) (bytecode_p->status_flags | CBC_CODE_FLAGS_DEBUGGER_IGNORE);
        -:  683:#endif /* JERRY_DEBUGGER */
        -:  684:
    #####:  685:  ecma_value_t *literal_start_p = (ecma_value_t *) (((uint8_t *) bytecode_p) + header_size);
        -:  686:
    #####:  687:  for (uint32_t i = 0; i < const_literal_end; i++)
        -:  688:  {
    #####:  689:    if ((literal_start_p[i] & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_SNAPSHOT_OFFSET)
        -:  690:    {
    #####:  691:      literal_start_p[i] = ecma_snapshot_get_literal (literal_base_p, literal_start_p[i]);
        -:  692:    }
        -:  693:  }
        -:  694:
    #####:  695:  for (uint32_t i = const_literal_end; i < literal_end; i++)
        -:  696:  {
    #####:  697:    size_t literal_offset = (size_t) literal_start_p[i];
        -:  698:
    #####:  699:    if (literal_offset == 0)
        -:  700:    {
        -:  701:      /* Self reference */
    #####:  702:      ECMA_SET_INTERNAL_VALUE_POINTER (literal_start_p[i], bytecode_p);
        -:  703:    }
        -:  704:    else
        -:  705:    {
        -:  706:      ecma_compiled_code_t *literal_bytecode_p;
    #####:  707:      literal_bytecode_p =
    #####:  708:        snapshot_load_compiled_code (base_addr_p + literal_offset, literal_base_p, script_p, copy_bytecode);
        -:  709:
    #####:  710:      ECMA_SET_INTERNAL_VALUE_POINTER (literal_start_p[i], literal_bytecode_p);
        -:  711:    }
        -:  712:  }
        -:  713:
    #####:  714:  uint8_t *byte_p = ((uint8_t *) bytecode_p) + code_size;
    #####:  715:  literal_start_p = ecma_snapshot_resolve_serializable_values (bytecode_p, byte_p);
        -:  716:
    #####:  717:  while (literal_start_p < (ecma_value_t *) byte_p)
        -:  718:  {
    #####:  719:    if ((*literal_start_p & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_SNAPSHOT_OFFSET)
        -:  720:    {
    #####:  721:      *literal_start_p = ecma_snapshot_get_literal (literal_base_p, *literal_start_p);
        -:  722:    }
        -:  723:
    #####:  724:    literal_start_p++;
        -:  725:  }
        -:  726:
        -:  727:  return bytecode_p;
        -:  728:} /* snapshot_load_compiled_code */
        -:  729:
        -:  730:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  731:
        -:  732:/**
        -:  733: * Generate snapshot from specified source and arguments
        -:  734: *
        -:  735: * @return size of snapshot (a number value), if it was generated succesfully
        -:  736: *          (i.e. there are no syntax errors in source code, buffer size is sufficient,
        -:  737: *           and snapshot support is enabled in current configuration through JERRY_SNAPSHOT_SAVE),
        -:  738: *         error object otherwise
        -:  739: */
        -:  740:jerry_value_t
    #####:  741:jerry_generate_snapshot (jerry_value_t compiled_code, /**< parsed script or function */
        -:  742:                         uint32_t generate_snapshot_opts, /**< jerry_generate_snapshot_opts_t option bits */
        -:  743:                         uint32_t *buffer_p, /**< buffer to save snapshot to */
        -:  744:                         size_t buffer_size) /**< the buffer's size */
        -:  745:{
        -:  746:#if JERRY_SNAPSHOT_SAVE
    #####:  747:  uint32_t allowed_options = JERRY_SNAPSHOT_SAVE_STATIC;
        -:  748:
    #####:  749:  if ((generate_snapshot_opts & ~allowed_options) != 0)
        -:  750:  {
    #####:  751:    return jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_SNAPSHOT_FLAG_NOT_SUPPORTED));
        -:  752:  }
        -:  753:
    #####:  754:  const ecma_compiled_code_t *bytecode_data_p = NULL;
        -:  755:
    #####:  756:  if (ecma_is_value_object (compiled_code))
        -:  757:  {
    #####:  758:    ecma_object_t *object_p = ecma_get_object_from_value (compiled_code);
        -:  759:
    #####:  760:    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_SCRIPT))
        -:  761:    {
    #####:  762:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  763:
    #####:  764:      bytecode_data_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
        -:  765:    }
    #####:  766:    else if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -:  767:    {
    #####:  768:      ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
        -:  769:
    #####:  770:      bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);
        -:  771:
    #####:  772:      uint16_t type = CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags);
        -:  773:
    #####:  774:      if (type != CBC_FUNCTION_NORMAL)
        -:  775:      {
    #####:  776:        bytecode_data_p = NULL;
        -:  777:      }
        -:  778:    }
        -:  779:  }
        -:  780:
    #####:  781:  if (JERRY_UNLIKELY (bytecode_data_p == NULL))
        -:  782:  {
    #####:  783:    return jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_SNAPSHOT_UNSUPPORTED_COMPILED_CODE));
        -:  784:  }
        -:  785:
        -:  786:  snapshot_globals_t globals;
    #####:  787:  const uint32_t aligned_header_size = JERRY_ALIGNUP (sizeof (jerry_snapshot_header_t), JMEM_ALIGNMENT);
        -:  788:
    #####:  789:  globals.snapshot_buffer_write_offset = aligned_header_size;
    #####:  790:  globals.snapshot_error = ECMA_VALUE_EMPTY;
    #####:  791:  globals.regex_found = false;
    #####:  792:  globals.class_found = false;
        -:  793:
    #####:  794:  if (generate_snapshot_opts & JERRY_SNAPSHOT_SAVE_STATIC)
        -:  795:  {
    #####:  796:    static_snapshot_add_compiled_code (bytecode_data_p, (uint8_t *) buffer_p, buffer_size, &globals);
        -:  797:  }
        -:  798:  else
        -:  799:  {
    #####:  800:    snapshot_add_compiled_code (bytecode_data_p, (uint8_t *) buffer_p, buffer_size, &globals);
        -:  801:  }
        -:  802:
    #####:  803:  if (!ecma_is_value_empty (globals.snapshot_error))
        -:  804:  {
        -:  805:    return globals.snapshot_error;
        -:  806:  }
        -:  807:
        -:  808:  jerry_snapshot_header_t header;
    #####:  809:  header.magic = JERRY_SNAPSHOT_MAGIC;
    #####:  810:  header.version = JERRY_SNAPSHOT_VERSION;
    #####:  811:  header.global_flags = snapshot_get_global_flags (globals.regex_found, globals.class_found);
    #####:  812:  header.lit_table_offset = (uint32_t) globals.snapshot_buffer_write_offset;
    #####:  813:  header.number_of_funcs = 1;
    #####:  814:  header.func_offsets[0] = aligned_header_size;
        -:  815:
    #####:  816:  lit_mem_to_snapshot_id_map_entry_t *lit_map_p = NULL;
    #####:  817:  uint32_t literals_num = 0;
        -:  818:
    #####:  819:  if (!(generate_snapshot_opts & JERRY_SNAPSHOT_SAVE_STATIC))
        -:  820:  {
    #####:  821:    ecma_collection_t *lit_pool_p = ecma_new_collection ();
        -:  822:
    #####:  823:    ecma_save_literals_add_compiled_code (bytecode_data_p, lit_pool_p);
        -:  824:
    #####:  825:    if (!ecma_save_literals_for_snapshot (lit_pool_p,
        -:  826:                                          buffer_p,
        -:  827:                                          buffer_size,
        -:  828:                                          &globals.snapshot_buffer_write_offset,
        -:  829:                                          &lit_map_p,
        -:  830:                                          &literals_num))
        -:  831:    {
        -:  832:      JERRY_ASSERT (lit_map_p == NULL);
    #####:  833:      return jerry_throw_sz (JERRY_ERROR_COMMON, ecma_get_error_msg (ECMA_ERR_CANNOT_ALLOCATE_MEMORY_LITERALS));
        -:  834:    }
        -:  835:
    #####:  836:    jerry_snapshot_set_offsets (buffer_p + (aligned_header_size / sizeof (uint32_t)),
    #####:  837:                                (uint32_t) (header.lit_table_offset - aligned_header_size),
        -:  838:                                lit_map_p);
        -:  839:  }
        -:  840:
    #####:  841:  size_t header_offset = 0;
        -:  842:
    #####:  843:  snapshot_write_to_buffer_by_offset ((uint8_t *) buffer_p, buffer_size, &header_offset, &header, sizeof (header));
        -:  844:
    #####:  845:  if (lit_map_p != NULL)
        -:  846:  {
    #####:  847:    jmem_heap_free_block (lit_map_p, literals_num * sizeof (lit_mem_to_snapshot_id_map_entry_t));
        -:  848:  }
        -:  849:
    #####:  850:  return ecma_make_number_value ((ecma_number_t) globals.snapshot_buffer_write_offset);
        -:  851:#else /* !JERRY_SNAPSHOT_SAVE */
        -:  852:  JERRY_UNUSED (compiled_code);
        -:  853:  JERRY_UNUSED (generate_snapshot_opts);
        -:  854:  JERRY_UNUSED (buffer_p);
        -:  855:  JERRY_UNUSED (buffer_size);
        -:  856:
    #####:  857:  return jerry_throw_sz (JERRY_ERROR_COMMON, ecma_get_error_msg (ECMA_ERR_SNAPSHOT_SAVE_DISABLED));
        -:  858:#endif /* JERRY_SNAPSHOT_SAVE */
        -:  859:} /* jerry_generate_snapshot */
        -:  860:
        -:  861:/**
        -:  862: * Execute/load snapshot from specified buffer
        -:  863: *
        -:  864: * Note:
        -:  865: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  866: *
        -:  867: * @return result of bytecode - if run was successful
        -:  868: *         thrown error - otherwise
        -:  869: */
        -:  870:jerry_value_t
    #####:  871:jerry_exec_snapshot (const uint32_t *snapshot_p, /**< snapshot */
        -:  872:                     size_t snapshot_size, /**< size of snapshot */
        -:  873:                     size_t func_index, /**< index of primary function */
        -:  874:                     uint32_t exec_snapshot_opts, /**< jerry_exec_snapshot_opts_t option bits */
        -:  875:                     const jerry_exec_snapshot_option_values_t *option_values_p) /**< additional option values,
        -:  876:                                                                                  *   can be NULL if not used */
        -:  877:{
        -:  878:#if JERRY_SNAPSHOT_EXEC
        -:  879:  JERRY_ASSERT (snapshot_p != NULL);
        -:  880:
    #####:  881:  uint32_t allowed_opts =
        -:  882:    (JERRY_SNAPSHOT_EXEC_COPY_DATA | JERRY_SNAPSHOT_EXEC_ALLOW_STATIC | JERRY_SNAPSHOT_EXEC_LOAD_AS_FUNCTION
        -:  883:     | JERRY_SNAPSHOT_EXEC_HAS_SOURCE_NAME | JERRY_SNAPSHOT_EXEC_HAS_USER_VALUE);
        -:  884:
    #####:  885:  if ((exec_snapshot_opts & ~(allowed_opts)) != 0)
        -:  886:  {
    #####:  887:    return jerry_throw_sz (JERRY_ERROR_RANGE,
        -:  888:                           ecma_get_error_msg (ECMA_ERR_UNSUPPORTED_SNAPSHOT_EXEC_FLAGS_ARE_SPECIFIED));
        -:  889:  }
        -:  890:
    #####:  891:  const uint8_t *snapshot_data_p = (uint8_t *) snapshot_p;
        -:  892:
    #####:  893:  if (snapshot_size <= sizeof (jerry_snapshot_header_t))
        -:  894:  {
    #####:  895:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INVALID_SNAPSHOT_FORMAT));
        -:  896:  }
        -:  897:
    #####:  898:  const jerry_snapshot_header_t *header_p = (const jerry_snapshot_header_t *) snapshot_data_p;
        -:  899:
    #####:  900:  if (header_p->magic != JERRY_SNAPSHOT_MAGIC || header_p->version != JERRY_SNAPSHOT_VERSION
    #####:  901:      || !snapshot_check_global_flags (header_p->global_flags))
        -:  902:  {
    #####:  903:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INVALID_SNAPSHOT_VERSION_OR_FEATURES));
        -:  904:  }
        -:  905:
    #####:  906:  if (header_p->lit_table_offset > snapshot_size)
        -:  907:  {
    #####:  908:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INVALID_SNAPSHOT_VERSION_OR_FEATURES));
        -:  909:  }
        -:  910:
    #####:  911:  if (func_index >= header_p->number_of_funcs)
        -:  912:  {
    #####:  913:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_FUNCTION_INDEX_IS_HIGHER_THAN_MAXIMUM));
        -:  914:  }
        -:  915:
        -:  916:  JERRY_ASSERT ((header_p->lit_table_offset % sizeof (uint32_t)) == 0);
        -:  917:
    #####:  918:  uint32_t func_offset = header_p->func_offsets[func_index];
    #####:  919:  ecma_compiled_code_t *bytecode_p = (ecma_compiled_code_t *) (snapshot_data_p + func_offset);
        -:  920:
    #####:  921:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)
        -:  922:  {
    #####:  923:    if (!(exec_snapshot_opts & JERRY_SNAPSHOT_EXEC_ALLOW_STATIC))
        -:  924:    {
    #####:  925:      return jerry_throw_sz (JERRY_ERROR_COMMON, ecma_get_error_msg (ECMA_ERR_STATIC_SNAPSHOTS_ARE_NOT_ENABLED));
        -:  926:    }
        -:  927:
    #####:  928:    if (exec_snapshot_opts & JERRY_SNAPSHOT_EXEC_COPY_DATA)
        -:  929:    {
    #####:  930:      return jerry_throw_sz (JERRY_ERROR_COMMON,
        -:  931:                             ecma_get_error_msg (ECMA_ERR_STATIC_SNAPSHOTS_CANNOT_BE_COPIED_INTO_MEMORY));
        -:  932:    }
        -:  933:  }
        -:  934:  else
        -:  935:  {
    #####:  936:    ecma_value_t user_value = ECMA_VALUE_EMPTY;
        -:  937:
    #####:  938:    if ((exec_snapshot_opts & JERRY_SNAPSHOT_EXEC_HAS_USER_VALUE) && option_values_p != NULL)
        -:  939:    {
    #####:  940:      user_value = option_values_p->user_value;
        -:  941:    }
        -:  942:
    #####:  943:    size_t script_size = sizeof (cbc_script_t);
        -:  944:
    #####:  945:    if (user_value != ECMA_VALUE_EMPTY)
        -:  946:    {
    #####:  947:      script_size += sizeof (ecma_value_t);
        -:  948:    }
        -:  949:
    #####:  950:    cbc_script_t *script_p = jmem_heap_alloc_block (script_size);
        -:  951:
    #####:  952:    CBC_SCRIPT_SET_TYPE (script_p, user_value, CBC_SCRIPT_REF_ONE);
        -:  953:
        -:  954:#if JERRY_BUILTIN_REALMS
    #####:  955:    script_p->realm_p = (ecma_object_t *) JERRY_CONTEXT (global_object_p);
        -:  956:#endif /* JERRY_BUILTIN_REALMS */
        -:  957:
        -:  958:#if JERRY_SOURCE_NAME
    #####:  959:    ecma_value_t source_name = ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -:  960:
    #####:  961:    if ((exec_snapshot_opts & JERRY_SNAPSHOT_EXEC_HAS_SOURCE_NAME) && option_values_p != NULL
    #####:  962:        && ecma_is_value_string (option_values_p->source_name) > 0)
        -:  963:    {
    #####:  964:      ecma_ref_ecma_string (ecma_get_string_from_value (option_values_p->source_name));
    #####:  965:      source_name = option_values_p->source_name;
        -:  966:    }
        -:  967:
    #####:  968:    script_p->source_name = source_name;
        -:  969:#endif /* JERRY_SOURCE_NAME */
        -:  970:
        -:  971:#if JERRY_FUNCTION_TO_STRING
    #####:  972:    script_p->source_code = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  973:#endif /* JERRY_FUNCTION_TO_STRING */
        -:  974:
    #####:  975:    const uint8_t *literal_base_p = snapshot_data_p + header_p->lit_table_offset;
        -:  976:
    #####:  977:    bytecode_p = snapshot_load_compiled_code ((const uint8_t *) bytecode_p,
        -:  978:                                              literal_base_p,
        -:  979:                                              script_p,
    #####:  980:                                              (exec_snapshot_opts & JERRY_SNAPSHOT_EXEC_COPY_DATA) != 0);
        -:  981:
    #####:  982:    if (bytecode_p == NULL)
        -:  983:    {
        -:  984:      JERRY_ASSERT (script_p->refs_and_type >= CBC_SCRIPT_REF_ONE);
    #####:  985:      jmem_heap_free_block (script_p, script_size);
    #####:  986:      return ecma_raise_type_error (ECMA_ERR_INVALID_SNAPSHOT_FORMAT);
        -:  987:    }
        -:  988:
    #####:  989:    script_p->refs_and_type -= CBC_SCRIPT_REF_ONE;
        -:  990:
    #####:  991:    if (user_value != ECMA_VALUE_EMPTY)
        -:  992:    {
    #####:  993:      CBC_SCRIPT_GET_USER_VALUE (script_p) = ecma_copy_value_if_not_object (user_value);
        -:  994:    }
        -:  995:  }
        -:  996:
        -:  997:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  998:  if (JERRY_CONTEXT (jerry_init_flags) & JERRY_INIT_SHOW_OPCODES)
        -:  999:  {
        -: 1000:    util_print_cbc (bytecode_p);
        -: 1001:  }
        -: 1002:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1003:
        -: 1004:  ecma_value_t ret_val;
        -: 1005:
    #####: 1006:  if (exec_snapshot_opts & JERRY_SNAPSHOT_EXEC_LOAD_AS_FUNCTION)
        -: 1007:  {
    #####: 1008:    ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -: 1009:
        -: 1010:#if JERRY_BUILTIN_REALMS
        -: 1011:    JERRY_ASSERT (global_object_p == (ecma_object_t *) ecma_op_function_get_realm (bytecode_p));
        -: 1012:#endif /* JERRY_BUILTIN_REALMS */
        -: 1013:
        -: 1014:#if JERRY_ESNEXT
    #####: 1015:    if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)
        -: 1016:    {
    #####: 1017:      ecma_create_global_lexical_block (global_object_p);
        -: 1018:    }
        -: 1019:#endif /* JERRY_ESNEXT */
        -: 1020:
    #####: 1021:    ecma_object_t *lex_env_p = ecma_get_global_scope (global_object_p);
    #####: 1022:    ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_p);
        -: 1023:
    #####: 1024:    if (!(bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 1025:    {
    #####: 1026:      ecma_bytecode_deref (bytecode_p);
        -: 1027:    }
    #####: 1028:    ret_val = ecma_make_object_value (func_obj_p);
        -: 1029:  }
        -: 1030:  else
        -: 1031:  {
    #####: 1032:    ret_val = vm_run_global (bytecode_p, NULL);
    #####: 1033:    if (!(bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 1034:    {
    #####: 1035:      ecma_bytecode_deref (bytecode_p);
        -: 1036:    }
        -: 1037:  }
        -: 1038:
    #####: 1039:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -: 1040:  {
    #####: 1041:    return ecma_create_exception_from_context ();
        -: 1042:  }
        -: 1043:
        -: 1044:  return ret_val;
        -: 1045:#else /* !JERRY_SNAPSHOT_EXEC */
        -: 1046:  JERRY_UNUSED (snapshot_p);
        -: 1047:  JERRY_UNUSED (snapshot_size);
        -: 1048:  JERRY_UNUSED (func_index);
        -: 1049:  JERRY_UNUSED (exec_snapshot_opts);
        -: 1050:  JERRY_UNUSED (option_values_p);
        -: 1051:
    #####: 1052:  return jerry_throw_sz (JERRY_ERROR_COMMON, ecma_get_error_msg (ECMA_ERR_SNAPSHOT_EXEC_DISABLED));
        -: 1053:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1054:} /* jerry_exec_snapshot */
        -: 1055:
        -: 1056:/**
        -: 1057: * @}
        -: 1058: */
        -: 1059:
        -: 1060:#if JERRY_SNAPSHOT_SAVE
        -: 1061:
        -: 1062:/**
        -: 1063: * Collect all literals from a snapshot file.
        -: 1064: */
        -: 1065:static void
    #####: 1066:scan_snapshot_functions (const uint8_t *buffer_p, /**< snapshot buffer start */
        -: 1067:                         const uint8_t *buffer_end_p, /**< snapshot buffer end */
        -: 1068:                         ecma_collection_t *lit_pool_p, /**< list of known values */
        -: 1069:                         const uint8_t *literal_base_p) /**< start of literal data */
        -: 1070:{
        -: 1071:  JERRY_ASSERT (buffer_end_p > buffer_p);
        -: 1072:
        -: 1073:  do
        -: 1074:  {
    #####: 1075:    const ecma_compiled_code_t *bytecode_p = (ecma_compiled_code_t *) buffer_p;
    #####: 1076:    uint32_t code_size = ((uint32_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG;
        -: 1077:
    #####: 1078:    if (CBC_IS_FUNCTION (bytecode_p->status_flags) && !(bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 1079:    {
        -: 1080:      const ecma_value_t *literal_start_p;
        -: 1081:      uint32_t const_literal_end;
        -: 1082:
    #####: 1083:      if (bytecode_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1084:      {
    #####: 1085:        literal_start_p = (ecma_value_t *) (buffer_p + sizeof (cbc_uint16_arguments_t));
        -: 1086:
    #####: 1087:        cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) buffer_p;
    #####: 1088:        const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -: 1089:      }
        -: 1090:      else
        -: 1091:      {
    #####: 1092:        literal_start_p = (ecma_value_t *) (buffer_p + sizeof (cbc_uint8_arguments_t));
        -: 1093:
    #####: 1094:        cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) buffer_p;
    #####: 1095:        const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -: 1096:      }
        -: 1097:
    #####: 1098:      for (uint32_t i = 0; i < const_literal_end; i++)
        -: 1099:      {
    #####: 1100:        if ((literal_start_p[i] & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_SNAPSHOT_OFFSET)
        -: 1101:        {
    #####: 1102:          ecma_value_t lit_value = ecma_snapshot_get_literal (literal_base_p, literal_start_p[i]);
    #####: 1103:          ecma_save_literals_append_value (lit_value, lit_pool_p);
        -: 1104:        }
        -: 1105:      }
        -: 1106:
    #####: 1107:      uint8_t *byte_p = (uint8_t *) bytecode_p + (((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);
    #####: 1108:      literal_start_p = ecma_snapshot_resolve_serializable_values ((ecma_compiled_code_t *) bytecode_p, byte_p);
        -: 1109:
    #####: 1110:      while (literal_start_p < (ecma_value_t *) byte_p)
        -: 1111:      {
    #####: 1112:        if ((*literal_start_p & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_SNAPSHOT_OFFSET)
        -: 1113:        {
    #####: 1114:          ecma_value_t lit_value = ecma_snapshot_get_literal (literal_base_p, *literal_start_p);
    #####: 1115:          ecma_save_literals_append_value (lit_value, lit_pool_p);
        -: 1116:        }
        -: 1117:
    #####: 1118:        literal_start_p++;
        -: 1119:      }
        -: 1120:    }
        -: 1121:
    #####: 1122:    buffer_p += code_size;
    #####: 1123:  } while (buffer_p < buffer_end_p);
    #####: 1124:} /* scan_snapshot_functions */
        -: 1125:
        -: 1126:/**
        -: 1127: * Update all literal offsets in a snapshot data.
        -: 1128: */
        -: 1129:static void
    #####: 1130:update_literal_offsets (uint8_t *buffer_p, /**< [in,out] snapshot buffer start */
        -: 1131:                        const uint8_t *buffer_end_p, /**< snapshot buffer end */
        -: 1132:                        const lit_mem_to_snapshot_id_map_entry_t *lit_map_p, /**< literal map */
        -: 1133:                        const uint8_t *literal_base_p) /**< start of literal data */
        -: 1134:{
        -: 1135:  JERRY_ASSERT (buffer_end_p > buffer_p);
        -: 1136:
        -: 1137:  do
        -: 1138:  {
    #####: 1139:    const ecma_compiled_code_t *bytecode_p = (ecma_compiled_code_t *) buffer_p;
    #####: 1140:    uint32_t code_size = ((uint32_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG;
        -: 1141:
    #####: 1142:    if (CBC_IS_FUNCTION (bytecode_p->status_flags) && !(bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 1143:    {
        -: 1144:      ecma_value_t *literal_start_p;
        -: 1145:      uint32_t const_literal_end;
        -: 1146:
    #####: 1147:      if (bytecode_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1148:      {
    #####: 1149:        literal_start_p = (ecma_value_t *) (buffer_p + sizeof (cbc_uint16_arguments_t));
        -: 1150:
    #####: 1151:        cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) buffer_p;
    #####: 1152:        const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -: 1153:      }
        -: 1154:      else
        -: 1155:      {
    #####: 1156:        literal_start_p = (ecma_value_t *) (buffer_p + sizeof (cbc_uint8_arguments_t));
        -: 1157:
    #####: 1158:        cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) buffer_p;
    #####: 1159:        const_literal_end = (uint32_t) (args_p->const_literal_end - args_p->register_end);
        -: 1160:      }
        -: 1161:
    #####: 1162:      for (uint32_t i = 0; i < const_literal_end; i++)
        -: 1163:      {
    #####: 1164:        if ((literal_start_p[i] & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_SNAPSHOT_OFFSET)
        -: 1165:        {
    #####: 1166:          ecma_value_t lit_value = ecma_snapshot_get_literal (literal_base_p, literal_start_p[i]);
    #####: 1167:          const lit_mem_to_snapshot_id_map_entry_t *current_p = lit_map_p;
        -: 1168:
    #####: 1169:          while (current_p->literal_id != lit_value)
        -: 1170:          {
    #####: 1171:            current_p++;
        -: 1172:          }
        -: 1173:
    #####: 1174:          literal_start_p[i] = current_p->literal_offset;
        -: 1175:        }
        -: 1176:      }
        -: 1177:
    #####: 1178:      uint8_t *byte_p = (uint8_t *) bytecode_p + (((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);
    #####: 1179:      literal_start_p = ecma_snapshot_resolve_serializable_values ((ecma_compiled_code_t *) bytecode_p, byte_p);
        -: 1180:
    #####: 1181:      while (literal_start_p < (ecma_value_t *) byte_p)
        -: 1182:      {
    #####: 1183:        if ((*literal_start_p & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_SNAPSHOT_OFFSET)
        -: 1184:        {
    #####: 1185:          ecma_value_t lit_value = ecma_snapshot_get_literal (literal_base_p, *literal_start_p);
    #####: 1186:          const lit_mem_to_snapshot_id_map_entry_t *current_p = lit_map_p;
        -: 1187:
    #####: 1188:          while (current_p->literal_id != lit_value)
        -: 1189:          {
    #####: 1190:            current_p++;
        -: 1191:          }
        -: 1192:
    #####: 1193:          *literal_start_p = current_p->literal_offset;
        -: 1194:        }
        -: 1195:
    #####: 1196:        literal_start_p++;
        -: 1197:      }
        -: 1198:    }
        -: 1199:
    #####: 1200:    buffer_p += code_size;
    #####: 1201:  } while (buffer_p < buffer_end_p);
    #####: 1202:} /* update_literal_offsets */
        -: 1203:
        -: 1204:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1205:
        -: 1206:/**
        -: 1207: * Merge multiple snapshots into a single buffer
        -: 1208: *
        -: 1209: * @return length of merged snapshot file
        -: 1210: *         0 on error
        -: 1211: */
        -: 1212:size_t
    #####: 1213:jerry_merge_snapshots (const uint32_t **inp_buffers_p, /**< array of (pointers to start of) input buffers */
        -: 1214:                       size_t *inp_buffer_sizes_p, /**< array of input buffer sizes */
        -: 1215:                       size_t number_of_snapshots, /**< number of snapshots */
        -: 1216:                       uint32_t *out_buffer_p, /**< output buffer */
        -: 1217:                       size_t out_buffer_size, /**< output buffer size */
        -: 1218:                       const char **error_p) /**< error description */
        -: 1219:{
        -: 1220:#if JERRY_SNAPSHOT_SAVE
    #####: 1221:  uint32_t number_of_funcs = 0;
    #####: 1222:  uint32_t merged_global_flags = 0;
    #####: 1223:  size_t functions_size = sizeof (jerry_snapshot_header_t);
        -: 1224:
    #####: 1225:  if (number_of_snapshots < 2)
        -: 1226:  {
    #####: 1227:    *error_p = "at least two snapshots must be passed";
    #####: 1228:    return 0;
        -: 1229:  }
        -: 1230:
    #####: 1231:  ecma_collection_t *lit_pool_p = ecma_new_collection ();
        -: 1232:
    #####: 1233:  for (uint32_t i = 0; i < number_of_snapshots; i++)
        -: 1234:  {
    #####: 1235:    if (inp_buffer_sizes_p[i] < sizeof (jerry_snapshot_header_t))
        -: 1236:    {
    #####: 1237:      *error_p = "invalid snapshot file";
    #####: 1238:      ecma_collection_destroy (lit_pool_p);
    #####: 1239:      return 0;
        -: 1240:    }
        -: 1241:
    #####: 1242:    const jerry_snapshot_header_t *header_p = (const jerry_snapshot_header_t *) inp_buffers_p[i];
        -: 1243:
    #####: 1244:    if (header_p->magic != JERRY_SNAPSHOT_MAGIC || header_p->version != JERRY_SNAPSHOT_VERSION
    #####: 1245:        || !snapshot_check_global_flags (header_p->global_flags))
        -: 1246:    {
    #####: 1247:      *error_p = "invalid snapshot version or unsupported features present";
    #####: 1248:      ecma_collection_destroy (lit_pool_p);
    #####: 1249:      return 0;
        -: 1250:    }
        -: 1251:
    #####: 1252:    merged_global_flags |= header_p->global_flags;
        -: 1253:
    #####: 1254:    uint32_t start_offset = header_p->func_offsets[0];
    #####: 1255:    const uint8_t *data_p = (const uint8_t *) inp_buffers_p[i];
    #####: 1256:    const uint8_t *literal_base_p = data_p + header_p->lit_table_offset;
        -: 1257:
        -: 1258:    JERRY_ASSERT (header_p->number_of_funcs > 0);
        -: 1259:
    #####: 1260:    number_of_funcs += header_p->number_of_funcs;
    #####: 1261:    functions_size += header_p->lit_table_offset - start_offset;
        -: 1262:
    #####: 1263:    scan_snapshot_functions (data_p + start_offset, literal_base_p, lit_pool_p, literal_base_p);
        -: 1264:  }
        -: 1265:
        -: 1266:  JERRY_ASSERT (number_of_funcs > 0);
        -: 1267:
    #####: 1268:  functions_size += JERRY_ALIGNUP ((number_of_funcs - 1) * sizeof (uint32_t), JMEM_ALIGNMENT);
        -: 1269:
    #####: 1270:  if (functions_size >= out_buffer_size)
        -: 1271:  {
    #####: 1272:    *error_p = "output buffer is too small";
    #####: 1273:    ecma_collection_destroy (lit_pool_p);
    #####: 1274:    return 0;
        -: 1275:  }
        -: 1276:
    #####: 1277:  jerry_snapshot_header_t *header_p = (jerry_snapshot_header_t *) out_buffer_p;
        -: 1278:
    #####: 1279:  header_p->magic = JERRY_SNAPSHOT_MAGIC;
    #####: 1280:  header_p->version = JERRY_SNAPSHOT_VERSION;
    #####: 1281:  header_p->global_flags = merged_global_flags;
    #####: 1282:  header_p->lit_table_offset = (uint32_t) functions_size;
    #####: 1283:  header_p->number_of_funcs = number_of_funcs;
        -: 1284:
        -: 1285:  lit_mem_to_snapshot_id_map_entry_t *lit_map_p;
        -: 1286:  uint32_t literals_num;
        -: 1287:
    #####: 1288:  if (!ecma_save_literals_for_snapshot (lit_pool_p,
        -: 1289:                                        out_buffer_p,
        -: 1290:                                        out_buffer_size,
        -: 1291:                                        &functions_size,
        -: 1292:                                        &lit_map_p,
        -: 1293:                                        &literals_num))
        -: 1294:  {
    #####: 1295:    *error_p = "buffer is too small";
    #####: 1296:    return 0;
        -: 1297:  }
        -: 1298:
    #####: 1299:  uint32_t *func_offset_p = header_p->func_offsets;
    #####: 1300:  uint8_t *dst_p = ((uint8_t *) out_buffer_p) + sizeof (jerry_snapshot_header_t);
    #####: 1301:  dst_p += JERRY_ALIGNUP ((number_of_funcs - 1) * sizeof (uint32_t), JMEM_ALIGNMENT);
        -: 1302:
    #####: 1303:  for (uint32_t i = 0; i < number_of_snapshots; i++)
        -: 1304:  {
    #####: 1305:    const jerry_snapshot_header_t *current_header_p = (const jerry_snapshot_header_t *) inp_buffers_p[i];
        -: 1306:
    #####: 1307:    uint32_t start_offset = current_header_p->func_offsets[0];
        -: 1308:
    #####: 1309:    memcpy (dst_p,
        -: 1310:            ((const uint8_t *) inp_buffers_p[i]) + start_offset,
    #####: 1311:            current_header_p->lit_table_offset - start_offset);
        -: 1312:
    #####: 1313:    const uint8_t *literal_base_p = ((const uint8_t *) inp_buffers_p[i]) + current_header_p->lit_table_offset;
    #####: 1314:    update_literal_offsets (dst_p,
    #####: 1315:                            dst_p + current_header_p->lit_table_offset - start_offset,
        -: 1316:                            lit_map_p,
        -: 1317:                            literal_base_p);
        -: 1318:
    #####: 1319:    uint32_t current_offset = (uint32_t) (dst_p - (uint8_t *) out_buffer_p) - start_offset;
        -: 1320:
    #####: 1321:    for (uint32_t j = 0; j < current_header_p->number_of_funcs; j++)
        -: 1322:    {
        -: 1323:      /* Updating offset without changing any flags. */
    #####: 1324:      *func_offset_p++ = current_header_p->func_offsets[j] + current_offset;
        -: 1325:    }
        -: 1326:
    #####: 1327:    dst_p += current_header_p->lit_table_offset - start_offset;
        -: 1328:  }
        -: 1329:
        -: 1330:  JERRY_ASSERT ((uint32_t) (dst_p - (uint8_t *) out_buffer_p) == header_p->lit_table_offset);
        -: 1331:
    #####: 1332:  if (lit_map_p != NULL)
        -: 1333:  {
    #####: 1334:    jmem_heap_free_block (lit_map_p, literals_num * sizeof (lit_mem_to_snapshot_id_map_entry_t));
        -: 1335:  }
        -: 1336:
    #####: 1337:  *error_p = NULL;
    #####: 1338:  return functions_size;
        -: 1339:#else /* !JERRY_SNAPSHOT_SAVE */
        -: 1340:  JERRY_UNUSED (inp_buffers_p);
        -: 1341:  JERRY_UNUSED (inp_buffer_sizes_p);
        -: 1342:  JERRY_UNUSED (number_of_snapshots);
        -: 1343:  JERRY_UNUSED (out_buffer_p);
        -: 1344:  JERRY_UNUSED (out_buffer_size);
        -: 1345:  JERRY_UNUSED (error_p);
        -: 1346:
    #####: 1347:  *error_p = "snapshot merge not supported";
    #####: 1348:  return 0;
        -: 1349:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1350:} /* jerry_merge_snapshots */
        -: 1351:
        -: 1352:#if JERRY_SNAPSHOT_SAVE
        -: 1353:
        -: 1354:/**
        -: 1355: * ====================== Functions for literal saving ==========================
        -: 1356: */
        -: 1357:
        -: 1358:/**
        -: 1359: * Compare two ecma_strings by size, then lexicographically.
        -: 1360: *
        -: 1361: * @return true - if the first string is less than the second one,
        -: 1362: *         false - otherwise
        -: 1363: */
        -: 1364:static bool
    #####: 1365:jerry_save_literals_compare (ecma_string_t *literal1, /**< first literal */
        -: 1366:                             ecma_string_t *literal2) /**< second literal */
        -: 1367:{
    #####: 1368:  const lit_utf8_size_t lit1_size = ecma_string_get_size (literal1);
    #####: 1369:  const lit_utf8_size_t lit2_size = ecma_string_get_size (literal2);
        -: 1370:
    #####: 1371:  if (lit1_size == lit2_size)
        -: 1372:  {
    #####: 1373:    return ecma_compare_ecma_strings_relational (literal1, literal2);
        -: 1374:  }
        -: 1375:
    #####: 1376:  return (lit1_size < lit2_size);
        -: 1377:} /* jerry_save_literals_compare */
        -: 1378:
        -: 1379:/**
        -: 1380: * Helper function for the heapsort algorithm.
        -: 1381: *
        -: 1382: * @return index of the maximum value
        -: 1383: */
        -: 1384:static lit_utf8_size_t
    #####: 1385:jerry_save_literals_heap_max (ecma_string_t *literals[], /**< array of literals */
        -: 1386:                              lit_utf8_size_t num_of_nodes, /**< number of nodes */
        -: 1387:                              lit_utf8_size_t node_idx, /**< index of parent node */
        -: 1388:                              lit_utf8_size_t child_idx1, /**< index of the first child */
        -: 1389:                              lit_utf8_size_t child_idx2) /**< index of the second child */
        -: 1390:{
    #####: 1391:  lit_utf8_size_t max_idx = node_idx;
        -: 1392:
    #####: 1393:  if (child_idx1 < num_of_nodes && jerry_save_literals_compare (literals[max_idx], literals[child_idx1]))
        -: 1394:  {
    #####: 1395:    max_idx = child_idx1;
        -: 1396:  }
        -: 1397:
    #####: 1398:  if (child_idx2 < num_of_nodes && jerry_save_literals_compare (literals[max_idx], literals[child_idx2]))
        -: 1399:  {
    #####: 1400:    max_idx = child_idx2;
        -: 1401:  }
        -: 1402:
    #####: 1403:  return max_idx;
        -: 1404:} /* jerry_save_literals_heap_max */
        -: 1405:
        -: 1406:/**
        -: 1407: * Helper function for the heapsort algorithm.
        -: 1408: */
        -: 1409:static void
    #####: 1410:jerry_save_literals_down_heap (ecma_string_t *literals[], /**< array of literals */
        -: 1411:                               lit_utf8_size_t num_of_nodes, /**< number of nodes */
        -: 1412:                               lit_utf8_size_t node_idx) /**< index of parent node */
        -: 1413:{
        -: 1414:  while (true)
    #####: 1415:  {
    #####: 1416:    lit_utf8_size_t max_idx =
    #####: 1417:      jerry_save_literals_heap_max (literals, num_of_nodes, node_idx, 2 * node_idx + 1, 2 * node_idx + 2);
    #####: 1418:    if (max_idx == node_idx)
        -: 1419:    {
        -: 1420:      break;
        -: 1421:    }
        -: 1422:
    #####: 1423:    ecma_string_t *tmp_str_p = literals[node_idx];
    #####: 1424:    literals[node_idx] = literals[max_idx];
    #####: 1425:    literals[max_idx] = tmp_str_p;
        -: 1426:
    #####: 1427:    node_idx = max_idx;
        -: 1428:  }
    #####: 1429:} /* jerry_save_literals_down_heap */
        -: 1430:
        -: 1431:/**
        -: 1432: * Helper function for a heapsort algorithm.
        -: 1433: */
        -: 1434:static void
    #####: 1435:jerry_save_literals_sort (ecma_string_t *literals[], /**< array of literals */
        -: 1436:                          lit_utf8_size_t num_of_literals) /**< number of literals */
        -: 1437:{
    #####: 1438:  if (num_of_literals < 2)
        -: 1439:  {
        -: 1440:    return;
        -: 1441:  }
        -: 1442:
    #####: 1443:  lit_utf8_size_t lit_idx = (num_of_literals - 2) / 2;
        -: 1444:
    #####: 1445:  while (lit_idx <= (num_of_literals - 2) / 2)
        -: 1446:  {
    #####: 1447:    jerry_save_literals_down_heap (literals, num_of_literals, lit_idx--);
        -: 1448:  }
        -: 1449:
    #####: 1450:  for (lit_idx = 0; lit_idx < num_of_literals; lit_idx++)
        -: 1451:  {
    #####: 1452:    const lit_utf8_size_t last_idx = num_of_literals - lit_idx - 1;
        -: 1453:
    #####: 1454:    ecma_string_t *tmp_str_p = literals[last_idx];
    #####: 1455:    literals[last_idx] = literals[0];
    #####: 1456:    literals[0] = tmp_str_p;
        -: 1457:
    #####: 1458:    jerry_save_literals_down_heap (literals, last_idx, 0);
        -: 1459:  }
        -: 1460:} /* jerry_save_literals_sort */
        -: 1461:
        -: 1462:/**
        -: 1463: * Append characters to the specified buffer.
        -: 1464: *
        -: 1465: * @return the position of the buffer pointer after copy.
        -: 1466: */
        -: 1467:static uint8_t *
    #####: 1468:jerry_append_chars_to_buffer (uint8_t *buffer_p, /**< buffer */
        -: 1469:                              uint8_t *buffer_end_p, /**< the end of the buffer */
        -: 1470:                              const char *chars, /**< string */
        -: 1471:                              lit_utf8_size_t string_size) /**< string size */
        -: 1472:{
    #####: 1473:  if (buffer_p > buffer_end_p)
        -: 1474:  {
        -: 1475:    return buffer_p;
        -: 1476:  }
        -: 1477:
    #####: 1478:  if (string_size == 0)
        -: 1479:  {
    #####: 1480:    string_size = (lit_utf8_size_t) strlen (chars);
        -: 1481:  }
        -: 1482:
    #####: 1483:  if (buffer_p + string_size <= buffer_end_p)
        -: 1484:  {
    #####: 1485:    memcpy ((char *) buffer_p, chars, string_size);
        -: 1486:
    #####: 1487:    return buffer_p + string_size;
        -: 1488:  }
        -: 1489:
        -: 1490:  /* Move the pointer behind the buffer to prevent further writes. */
    #####: 1491:  return buffer_end_p + 1;
        -: 1492:} /* jerry_append_chars_to_buffer */
        -: 1493:
        -: 1494:/**
        -: 1495: * Append an ecma-string to the specified buffer.
        -: 1496: *
        -: 1497: * @return the position of the buffer pointer after copy.
        -: 1498: */
        -: 1499:static uint8_t *
    #####: 1500:jerry_append_ecma_string_to_buffer (uint8_t *buffer_p, /**< buffer */
        -: 1501:                                    uint8_t *buffer_end_p, /**< the end of the buffer */
        -: 1502:                                    ecma_string_t *string_p) /**< ecma-string */
        -: 1503:{
    #####: 1504:  ECMA_STRING_TO_UTF8_STRING (string_p, str_buffer_p, str_buffer_size);
        -: 1505:
        -: 1506:  /* Append the string to the buffer. */
    #####: 1507:  uint8_t *new_buffer_p =
    #####: 1508:    jerry_append_chars_to_buffer (buffer_p, buffer_end_p, (const char *) str_buffer_p, str_buffer_size);
        -: 1509:
    #####: 1510:  ECMA_FINALIZE_UTF8_STRING (str_buffer_p, str_buffer_size);
        -: 1511:
    #####: 1512:  return new_buffer_p;
        -: 1513:} /* jerry_append_ecma_string_to_buffer */
        -: 1514:
        -: 1515:/**
        -: 1516: * Append an unsigned number to the specified buffer.
        -: 1517: *
        -: 1518: * @return the position of the buffer pointer after copy.
        -: 1519: */
        -: 1520:static uint8_t *
    #####: 1521:jerry_append_number_to_buffer (uint8_t *buffer_p, /**< buffer */
        -: 1522:                               uint8_t *buffer_end_p, /**< the end of the buffer */
        -: 1523:                               lit_utf8_size_t number) /**< number */
        -: 1524:{
        -: 1525:  lit_utf8_byte_t uint32_to_str_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
    #####: 1526:  lit_utf8_size_t utf8_str_size =
        -: 1527:    ecma_uint32_to_utf8_string (number, uint32_to_str_buffer, ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
        -: 1528:
        -: 1529:  JERRY_ASSERT (utf8_str_size <= ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
        -: 1530:
    #####: 1531:  return jerry_append_chars_to_buffer (buffer_p, buffer_end_p, (const char *) uint32_to_str_buffer, utf8_str_size);
        -: 1532:} /* jerry_append_number_to_buffer */
        -: 1533:
        -: 1534:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1535:
        -: 1536:/**
        -: 1537: * Get the literals from a snapshot. Copies certain string literals into the given
        -: 1538: * buffer in a specified format.
        -: 1539: *
        -: 1540: * Note:
        -: 1541: *      Only valid identifiers are saved in C format.
        -: 1542: *
        -: 1543: * @return size of the literal-list in bytes, at most equal to the buffer size,
        -: 1544: *         if the list of the literals isn't empty,
        -: 1545: *         0 - otherwise.
        -: 1546: */
        -: 1547:size_t
    #####: 1548:jerry_get_literals_from_snapshot (const uint32_t *snapshot_p, /**< input snapshot buffer */
        -: 1549:                                  size_t snapshot_size, /**< size of the input snapshot buffer */
        -: 1550:                                  jerry_char_t *lit_buf_p, /**< [out] buffer to save literals to */
        -: 1551:                                  size_t lit_buf_size, /**< the buffer's size */
        -: 1552:                                  bool is_c_format) /**< format-flag */
        -: 1553:{
        -: 1554:#if JERRY_SNAPSHOT_SAVE
    #####: 1555:  const uint8_t *snapshot_data_p = (uint8_t *) snapshot_p;
    #####: 1556:  const jerry_snapshot_header_t *header_p = (const jerry_snapshot_header_t *) snapshot_data_p;
        -: 1557:
    #####: 1558:  if (snapshot_size <= sizeof (jerry_snapshot_header_t) || header_p->magic != JERRY_SNAPSHOT_MAGIC
    #####: 1559:      || header_p->version != JERRY_SNAPSHOT_VERSION || !snapshot_check_global_flags (header_p->global_flags))
        -: 1560:  {
        -: 1561:    /* Invalid snapshot format */
        -: 1562:    return 0;
        -: 1563:  }
        -: 1564:
        -: 1565:  JERRY_ASSERT ((header_p->lit_table_offset % sizeof (uint32_t)) == 0);
    #####: 1566:  const uint8_t *literal_base_p = snapshot_data_p + header_p->lit_table_offset;
        -: 1567:
    #####: 1568:  ecma_collection_t *lit_pool_p = ecma_new_collection ();
    #####: 1569:  scan_snapshot_functions (snapshot_data_p + header_p->func_offsets[0], literal_base_p, lit_pool_p, literal_base_p);
        -: 1570:
    #####: 1571:  lit_utf8_size_t literal_count = 0;
    #####: 1572:  ecma_value_t *buffer_p = lit_pool_p->buffer_p;
        -: 1573:
        -: 1574:  /* Count the valid and non-magic identifiers in the list. */
    #####: 1575:  for (uint32_t i = 0; i < lit_pool_p->item_count; i++)
        -: 1576:  {
    #####: 1577:    if (ecma_is_value_string (buffer_p[i]))
        -: 1578:    {
    #####: 1579:      ecma_string_t *literal_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1580:
    #####: 1581:      if (ecma_get_string_magic (literal_p) == LIT_MAGIC_STRING__COUNT)
        -: 1582:      {
    #####: 1583:        literal_count++;
        -: 1584:      }
        -: 1585:    }
        -: 1586:  }
        -: 1587:
    #####: 1588:  if (literal_count == 0)
        -: 1589:  {
    #####: 1590:    ecma_collection_destroy (lit_pool_p);
    #####: 1591:    return 0;
        -: 1592:  }
        -: 1593:
    #####: 1594:  jerry_char_t *const buffer_start_p = lit_buf_p;
    #####: 1595:  jerry_char_t *const buffer_end_p = lit_buf_p + lit_buf_size;
        -: 1596:
    #####: 1597:  JMEM_DEFINE_LOCAL_ARRAY (literal_array, literal_count, ecma_string_t *);
    #####: 1598:  lit_utf8_size_t literal_idx = 0;
        -: 1599:
    #####: 1600:  buffer_p = lit_pool_p->buffer_p;
        -: 1601:
        -: 1602:  /* Count the valid and non-magic identifiers in the list. */
    #####: 1603:  for (uint32_t i = 0; i < lit_pool_p->item_count; i++)
        -: 1604:  {
    #####: 1605:    if (ecma_is_value_string (buffer_p[i]))
        -: 1606:    {
    #####: 1607:      ecma_string_t *literal_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1608:
    #####: 1609:      if (ecma_get_string_magic (literal_p) == LIT_MAGIC_STRING__COUNT)
        -: 1610:      {
    #####: 1611:        literal_array[literal_idx++] = literal_p;
        -: 1612:      }
        -: 1613:    }
        -: 1614:  }
        -: 1615:
    #####: 1616:  ecma_collection_destroy (lit_pool_p);
        -: 1617:
        -: 1618:  /* Sort the strings by size at first, then lexicographically. */
    #####: 1619:  jerry_save_literals_sort (literal_array, literal_count);
        -: 1620:
    #####: 1621:  if (is_c_format)
        -: 1622:  {
        -: 1623:    /* Save literal count. */
    #####: 1624:    lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "jerry_length_t literal_count = ", 0);
        -: 1625:
    #####: 1626:    lit_buf_p = jerry_append_number_to_buffer (lit_buf_p, buffer_end_p, literal_count);
        -: 1627:
        -: 1628:    /* Save the array of literals. */
    #####: 1629:    lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, ";\n\njerry_char_t *literals[", 0);
        -: 1630:
    #####: 1631:    lit_buf_p = jerry_append_number_to_buffer (lit_buf_p, buffer_end_p, literal_count);
    #####: 1632:    lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "] =\n{\n", 0);
        -: 1633:
    #####: 1634:    for (lit_utf8_size_t i = 0; i < literal_count; i++)
        -: 1635:    {
    #####: 1636:      lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "  \"", 0);
    #####: 1637:      ECMA_STRING_TO_UTF8_STRING (literal_array[i], str_buffer_p, str_buffer_size);
    #####: 1638:      for (lit_utf8_size_t j = 0; j < str_buffer_size; j++)
        -: 1639:      {
    #####: 1640:        uint8_t byte = str_buffer_p[j];
    #####: 1641:        if (byte < 32 || byte > 127)
        -: 1642:        {
    #####: 1643:          lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "\\x", 0);
    #####: 1644:          ecma_char_t hex_digit = (ecma_char_t) (byte >> 4);
    #####: 1645:          *lit_buf_p++ = (lit_utf8_byte_t) ((hex_digit > 9) ? (hex_digit + ('A' - 10)) : (hex_digit + '0'));
    #####: 1646:          hex_digit = (lit_utf8_byte_t) (byte & 0xf);
    #####: 1647:          *lit_buf_p++ = (lit_utf8_byte_t) ((hex_digit > 9) ? (hex_digit + ('A' - 10)) : (hex_digit + '0'));
        -: 1648:        }
        -: 1649:        else
        -: 1650:        {
    #####: 1651:          if (byte == '\\' || byte == '"')
        -: 1652:          {
    #####: 1653:            *lit_buf_p++ = '\\';
        -: 1654:          }
    #####: 1655:          *lit_buf_p++ = byte;
        -: 1656:        }
        -: 1657:      }
        -: 1658:
    #####: 1659:      ECMA_FINALIZE_UTF8_STRING (str_buffer_p, str_buffer_size);
    #####: 1660:      lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "\"", 0);
        -: 1661:
    #####: 1662:      if (i < literal_count - 1)
        -: 1663:      {
    #####: 1664:        lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, ",", 0);
        -: 1665:      }
        -: 1666:
    #####: 1667:      lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "\n", 0);
        -: 1668:    }
        -: 1669:
    #####: 1670:    lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "};\n\njerry_length_t literal_sizes[", 0);
        -: 1671:
    #####: 1672:    lit_buf_p = jerry_append_number_to_buffer (lit_buf_p, buffer_end_p, literal_count);
    #####: 1673:    lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "] =\n{\n", 0);
        -: 1674:  }
        -: 1675:
        -: 1676:  /* Save the literal sizes respectively. */
    #####: 1677:  for (lit_utf8_size_t i = 0; i < literal_count; i++)
        -: 1678:  {
    #####: 1679:    lit_utf8_size_t str_size = ecma_string_get_size (literal_array[i]);
        -: 1680:
    #####: 1681:    if (is_c_format)
        -: 1682:    {
    #####: 1683:      lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "  ", 0);
        -: 1684:    }
        -: 1685:
    #####: 1686:    lit_buf_p = jerry_append_number_to_buffer (lit_buf_p, buffer_end_p, str_size);
    #####: 1687:    lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, " ", 0);
        -: 1688:
    #####: 1689:    if (is_c_format)
        -: 1690:    {
        -: 1691:      /* Show the given string as a comment. */
    #####: 1692:      lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "/* ", 0);
    #####: 1693:      lit_buf_p = jerry_append_ecma_string_to_buffer (lit_buf_p, buffer_end_p, literal_array[i]);
    #####: 1694:      lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, " */", 0);
        -: 1695:
    #####: 1696:      if (i < literal_count - 1)
        -: 1697:      {
    #####: 1698:        lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, ",", 0);
        -: 1699:      }
        -: 1700:    }
        -: 1701:    else
        -: 1702:    {
    #####: 1703:      lit_buf_p = jerry_append_ecma_string_to_buffer (lit_buf_p, buffer_end_p, literal_array[i]);
        -: 1704:    }
        -: 1705:
    #####: 1706:    lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "\n", 0);
        -: 1707:  }
        -: 1708:
    #####: 1709:  if (is_c_format)
        -: 1710:  {
    #####: 1711:    lit_buf_p = jerry_append_chars_to_buffer (lit_buf_p, buffer_end_p, "};\n", 0);
        -: 1712:  }
        -: 1713:
    #####: 1714:  JMEM_FINALIZE_LOCAL_ARRAY (literal_array);
        -: 1715:
    #####: 1716:  return lit_buf_p <= buffer_end_p ? (size_t) (lit_buf_p - buffer_start_p) : 0;
        -: 1717:#else /* !JERRY_SNAPSHOT_SAVE */
        -: 1718:  JERRY_UNUSED (snapshot_p);
        -: 1719:  JERRY_UNUSED (snapshot_size);
        -: 1720:  JERRY_UNUSED (lit_buf_p);
        -: 1721:  JERRY_UNUSED (lit_buf_size);
        -: 1722:  JERRY_UNUSED (is_c_format);
        -: 1723:
    #####: 1724:  return 0;
        -: 1725:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1726:} /* jerry_get_literals_from_snapshot */
