        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-async-generator-object.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-async-generator-object.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-errors.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-iterator-object.h"
        -:   27:#include "ecma-objects.h"
        -:   28:#include "ecma-promise-object.h"
        -:   29:
        -:   30:#include "jcontext.h"
        -:   31:#include "opcodes.h"
        -:   32:#include "vm-stack.h"
        -:   33:#include "vm.h"
        -:   34:
        -:   35:#if JERRY_ESNEXT
        -:   36:
        -:   37:/** \addtogroup ecma ECMA
        -:   38: * @{
        -:   39: *
        -:   40: * \addtogroup ecmaasyncgeneratorobject ECMA AsyncGenerator object related routines
        -:   41: * @{
        -:   42: */
        -:   43:
        -:   44:/**
        -:   45: * Enqueue a task into the command queue of an async generator
        -:   46: *
        -:   47: * @return ecma Promise value
        -:   48: *         Returned value must be freed with ecma_free_value.
        -:   49: */
        -:   50:ecma_value_t
    #####:   51:ecma_async_generator_enqueue (vm_executable_object_t *async_generator_object_p, /**< async generator */
        -:   52:                              ecma_async_generator_operation_type_t operation, /**< operation */
        -:   53:                              ecma_value_t value) /**< value argument of operation */
        -:   54:{
    #####:   55:  ecma_async_generator_task_t *task_p = jmem_heap_alloc_block (sizeof (ecma_async_generator_task_t));
        -:   56:
    #####:   57:  ECMA_SET_INTERNAL_VALUE_ANY_POINTER (task_p->next, NULL);
    #####:   58:  task_p->operation_value = ecma_copy_value_if_not_object (value);
    #####:   59:  task_p->operation_type = (uint8_t) operation;
        -:   60:
    #####:   61:  ecma_value_t result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
    #####:   62:  task_p->promise = result;
        -:   63:
    #####:   64:  ecma_value_t head = async_generator_object_p->extended_object.u.cls.u3.head;
        -:   65:
    #####:   66:  if (ECMA_IS_INTERNAL_VALUE_NULL (head))
        -:   67:  {
    #####:   68:    ECMA_SET_INTERNAL_VALUE_POINTER (async_generator_object_p->extended_object.u.cls.u3.head, task_p);
        -:   69:
    #####:   70:    if (async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags & ECMA_ASYNC_GENERATOR_CALLED)
        -:   71:    {
    #####:   72:      ecma_value_t executable_object = ecma_make_object_value ((ecma_object_t *) async_generator_object_p);
    #####:   73:      ecma_enqueue_promise_async_generator_job (executable_object);
    #####:   74:      return result;
        -:   75:    }
        -:   76:
    #####:   77:    async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_ASYNC_GENERATOR_CALLED;
    #####:   78:    ecma_async_generator_run (async_generator_object_p);
    #####:   79:    return result;
        -:   80:  }
        -:   81:
        -:   82:  /* Append the new task at the end. */
        -:   83:  ecma_async_generator_task_t *prev_task_p;
    #####:   84:  prev_task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, head);
        -:   85:
    #####:   86:  while (!ECMA_IS_INTERNAL_VALUE_NULL (prev_task_p->next))
        -:   87:  {
    #####:   88:    prev_task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, prev_task_p->next);
        -:   89:  }
        -:   90:
    #####:   91:  ECMA_SET_INTERNAL_VALUE_POINTER (prev_task_p->next, task_p);
    #####:   92:  return result;
        -:   93:} /* ecma_async_generator_enqueue */
        -:   94:
        -:   95:/**
        -:   96: * Call a function and await its return value
        -:   97: *
        -:   98: * @return ECMA_VALUE_UNDEFINED on success, error otherwise
        -:   99: */
        -:  100:static ecma_value_t
    #####:  101:ecma_async_yield_call (ecma_value_t function, /**< function (takes reference) */
        -:  102:                       vm_executable_object_t *async_generator_object_p, /**< async generator */
        -:  103:                       ecma_value_t argument) /**< argument passed to the function */
        -:  104:{
    #####:  105:  ecma_value_t iterator = async_generator_object_p->iterator;
        -:  106:  ecma_value_t result;
        -:  107:
    #####:  108:  if (argument == ECMA_VALUE_EMPTY)
        -:  109:  {
    #####:  110:    result = ecma_op_function_validated_call (function, iterator, NULL, 0);
        -:  111:  }
        -:  112:  else
        -:  113:  {
    #####:  114:    result = ecma_op_function_validated_call (function, iterator, &argument, 1);
        -:  115:  }
        -:  116:
    #####:  117:  ecma_free_value (function);
        -:  118:
    #####:  119:  if (ECMA_IS_VALUE_ERROR (result))
        -:  120:  {
    #####:  121:    return result;
        -:  122:  }
        -:  123:
    #####:  124:  return ecma_promise_async_await ((ecma_extended_object_t *) async_generator_object_p, result);
        -:  125:} /* ecma_async_yield_call */
        -:  126:
        -:  127:/**
        -:  128: * Perform an exception throw and call the approprite handler
        -:  129: */
        -:  130:static ecma_value_t
    #####:  131:ecma_async_yield_throw (vm_executable_object_t *async_generator_object_p, /**< async generator */
        -:  132:                        ecma_value_t value) /**< thrown value */
        -:  133:{
    #####:  134:  ecma_object_t *obj_p = ecma_get_object_from_value (async_generator_object_p->iterator);
    #####:  135:  ecma_value_t result = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_THROW);
        -:  136:
    #####:  137:  if (ECMA_IS_VALUE_ERROR (result))
        -:  138:  {
    #####:  139:    return result;
        -:  140:  }
        -:  141:
    #####:  142:  if (result == ECMA_VALUE_UNDEFINED)
        -:  143:  {
    #####:  144:    result = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_RETURN);
        -:  145:
    #####:  146:    if (result == ECMA_VALUE_UNDEFINED)
        -:  147:    {
    #####:  148:      return ecma_raise_type_error (ECMA_ERR_ITERATOR_THROW_IS_NOT_AVAILABLE);
        -:  149:    }
        -:  150:
    #####:  151:    result = ecma_async_yield_call (result, async_generator_object_p, ECMA_VALUE_EMPTY);
        -:  152:
    #####:  153:    if (ECMA_IS_VALUE_ERROR (result))
        -:  154:    {
    #####:  155:      return result;
        -:  156:    }
        -:  157:
    #####:  158:    ECMA_AWAIT_CHANGE_STATE (async_generator_object_p, YIELD_OPERATION, YIELD_CLOSE);
    #####:  159:    return ECMA_VALUE_UNDEFINED;
        -:  160:  }
        -:  161:
    #####:  162:  result = ecma_async_yield_call (result, async_generator_object_p, value);
        -:  163:
    #####:  164:  if (ECMA_IS_VALUE_ERROR (result))
        -:  165:  {
    #####:  166:    return result;
        -:  167:  }
        -:  168:
    #####:  169:  ECMA_AWAIT_CHANGE_STATE (async_generator_object_p, YIELD_OPERATION, YIELD_NEXT);
    #####:  170:  return ECMA_VALUE_UNDEFINED;
        -:  171:} /* ecma_async_yield_throw */
        -:  172:
        -:  173:/**
        -:  174: * Execute the next task in the command queue of the async generator
        -:  175: *
        -:  176: * @return ecma value
        -:  177: *         Returned value must be freed with ecma_free_value.
        -:  178: */
        -:  179:ecma_value_t
    #####:  180:ecma_async_generator_run (vm_executable_object_t *async_generator_object_p) /**< async generator */
        -:  181:{
    #####:  182:  JERRY_ASSERT (async_generator_object_p->extended_object.u.cls.type == ECMA_OBJECT_CLASS_ASYNC_GENERATOR);
    #####:  183:  JERRY_ASSERT (!ECMA_IS_INTERNAL_VALUE_NULL (async_generator_object_p->extended_object.u.cls.u3.head));
        -:  184:
    #####:  185:  ecma_value_t head = async_generator_object_p->extended_object.u.cls.u3.head;
    #####:  186:  ecma_async_generator_task_t *task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, head);
        -:  187:  ecma_value_t result;
        -:  188:
    #####:  189:  if (async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags
    #####:  190:      & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD)
        -:  191:  {
    #####:  192:    switch (task_p->operation_type)
        -:  193:    {
    #####:  194:      case ECMA_ASYNC_GENERATOR_DO_NEXT:
        -:  195:      {
    #####:  196:        result = ecma_op_iterator_next (async_generator_object_p->iterator,
    #####:  197:                                        async_generator_object_p->frame_ctx.stack_top_p[-1],
        -:  198:                                        task_p->operation_value);
        -:  199:
    #####:  200:        if (ECMA_IS_VALUE_ERROR (result))
        -:  201:        {
    #####:  202:          break;
        -:  203:        }
        -:  204:
    #####:  205:        result = ecma_promise_async_await ((ecma_extended_object_t *) async_generator_object_p, result);
        -:  206:
    #####:  207:        if (ECMA_IS_VALUE_ERROR (result))
        -:  208:        {
    #####:  209:          break;
        -:  210:        }
        -:  211:
    #####:  212:        ECMA_AWAIT_CHANGE_STATE (async_generator_object_p, YIELD_OPERATION, YIELD_NEXT);
    #####:  213:        break;
        -:  214:      }
    #####:  215:      case ECMA_ASYNC_GENERATOR_DO_THROW:
        -:  216:      {
    #####:  217:        result = ecma_async_yield_throw (async_generator_object_p, task_p->operation_value);
    #####:  218:        break;
        -:  219:      }
    #####:  220:      default:
        -:  221:      {
    #####:  222:        JERRY_ASSERT (task_p->operation_type == ECMA_ASYNC_GENERATOR_DO_RETURN);
        -:  223:
    #####:  224:        result = ecma_copy_value (task_p->operation_value);
    #####:  225:        result = ecma_promise_async_await ((ecma_extended_object_t *) async_generator_object_p, result);
        -:  226:
    #####:  227:        if (ECMA_IS_VALUE_ERROR (result))
        -:  228:        {
    #####:  229:          break;
        -:  230:        }
        -:  231:
    #####:  232:        ECMA_AWAIT_CHANGE_STATE (async_generator_object_p, YIELD_OPERATION, YIELD_RETURN);
    #####:  233:        break;
        -:  234:      }
        -:  235:    }
        -:  236:
    #####:  237:    ecma_free_value_if_not_object (task_p->operation_value);
    #####:  238:    task_p->operation_value = ECMA_VALUE_UNDEFINED;
        -:  239:
    #####:  240:    if (result == ECMA_VALUE_UNDEFINED)
        -:  241:    {
    #####:  242:      return ECMA_VALUE_UNDEFINED;
        -:  243:    }
        -:  244:
    #####:  245:    JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
        -:  246:
    #####:  247:    async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags &= ECMA_AWAIT_CLEAR_MASK;
    #####:  248:    async_generator_object_p->iterator = ECMA_VALUE_UNDEFINED;
    #####:  249:    async_generator_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_throw;
        -:  250:
    #####:  251:    JERRY_ASSERT (async_generator_object_p->frame_ctx.stack_top_p[-1] == ECMA_VALUE_UNDEFINED
        -:  252:                  || ecma_is_value_object (async_generator_object_p->frame_ctx.stack_top_p[-1]));
    #####:  253:    async_generator_object_p->frame_ctx.stack_top_p--;
        -:  254:
    #####:  255:    result = jcontext_take_exception ();
        -:  256:  }
        -:  257:  else
        -:  258:  {
    #####:  259:    if (task_p->operation_type == ECMA_ASYNC_GENERATOR_DO_RETURN)
        -:  260:    {
    #####:  261:      async_generator_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_return;
        -:  262:    }
    #####:  263:    else if (task_p->operation_type == ECMA_ASYNC_GENERATOR_DO_THROW)
        -:  264:    {
    #####:  265:      async_generator_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_throw;
        -:  266:    }
        -:  267:
    #####:  268:    result = task_p->operation_value;
    #####:  269:    ecma_ref_if_object (result);
    #####:  270:    task_p->operation_value = ECMA_VALUE_UNDEFINED;
        -:  271:  }
        -:  272:
    #####:  273:  result = opfunc_resume_executable_object (async_generator_object_p, result);
        -:  274:
    #####:  275:  if (async_generator_object_p->extended_object.u.cls.u2.executable_obj_flags & ECMA_EXECUTABLE_OBJECT_COMPLETED)
        -:  276:  {
    #####:  277:    JERRY_ASSERT (head == async_generator_object_p->extended_object.u.cls.u3.head);
    #####:  278:    ecma_async_generator_finalize (async_generator_object_p, result);
    #####:  279:    result = ECMA_VALUE_UNDEFINED;
        -:  280:  }
        -:  281:
    #####:  282:  return result;
        -:  283:} /* ecma_async_generator_run */
        -:  284:
        -:  285:/**
        -:  286: * Finalize the promises of an executable generator
        -:  287: */
        -:  288:void
    #####:  289:ecma_async_generator_finalize (vm_executable_object_t *async_generator_object_p, /**< async generator */
        -:  290:                               ecma_value_t value) /**< final value (takes reference) */
        -:  291:{
    #####:  292:  ecma_value_t next = async_generator_object_p->extended_object.u.cls.u3.head;
    #####:  293:  ecma_async_generator_task_t *task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, next);
        -:  294:
    #####:  295:  if (ECMA_IS_VALUE_ERROR (value))
        -:  296:  {
    #####:  297:    value = jcontext_take_exception ();
    #####:  298:    ecma_reject_promise (task_p->promise, value);
        -:  299:  }
        -:  300:  else
        -:  301:  {
    #####:  302:    ecma_value_t result = ecma_create_iter_result_object (value, ECMA_VALUE_TRUE);
    #####:  303:    ecma_fulfill_promise (task_p->promise, result);
    #####:  304:    ecma_free_value (result);
        -:  305:  }
        -:  306:
    #####:  307:  ecma_free_value (value);
        -:  308:
    #####:  309:  next = task_p->next;
    #####:  310:  async_generator_object_p->extended_object.u.cls.u3.head = next;
    #####:  311:  jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -:  312:
    #####:  313:  while (!ECMA_IS_INTERNAL_VALUE_NULL (next))
        -:  314:  {
    #####:  315:    task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, next);
        -:  316:
    #####:  317:    if (task_p->operation_type != ECMA_ASYNC_GENERATOR_DO_THROW)
        -:  318:    {
    #####:  319:      value = ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
    #####:  320:      ecma_fulfill_promise (task_p->promise, value);
    #####:  321:      ecma_free_value (value);
        -:  322:    }
        -:  323:    else
        -:  324:    {
    #####:  325:      ecma_reject_promise (task_p->promise, task_p->operation_value);
        -:  326:    }
        -:  327:
    #####:  328:    ecma_free_value_if_not_object (task_p->operation_value);
        -:  329:
    #####:  330:    next = task_p->next;
    #####:  331:    async_generator_object_p->extended_object.u.cls.u3.head = next;
    #####:  332:    jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -:  333:  }
    #####:  334:} /* ecma_async_generator_finalize */
        -:  335:
        -:  336:/**
        -:  337: * Continue after an await operation is completed.
        -:  338: *
        -:  339: * @return an updated value for the value argument
        -:  340: */
        -:  341:ecma_value_t
    #####:  342:ecma_await_continue (vm_executable_object_t *executable_object_p, /**< executable object */
        -:  343:                     ecma_value_t value) /**< job value (takes reference) */
        -:  344:{
    #####:  345:  ecma_await_states_t state = (ecma_await_states_t) ECMA_AWAIT_GET_STATE (executable_object_p);
        -:  346:
    #####:  347:  switch (state)
        -:  348:  {
    #####:  349:    case ECMA_AWAIT_YIELD_NEXT:
        -:  350:    case ECMA_AWAIT_YIELD_NEXT_RETURN:
        -:  351:    {
    #####:  352:      if (!ecma_is_value_object (value))
        -:  353:      {
    #####:  354:        ecma_free_value (value);
    #####:  355:        return ecma_raise_type_error (ECMA_ERR_VALUE_RECEIVED_BY_YIELD_IS_NOT_OBJECT);
        -:  356:      }
        -:  357:
    #####:  358:      ecma_object_t *result_obj_p = ecma_get_object_from_value (value);
    #####:  359:      ecma_value_t result = ecma_op_object_get_by_magic_id (result_obj_p, LIT_MAGIC_STRING_DONE);
        -:  360:
    #####:  361:      if (ECMA_IS_VALUE_ERROR (result))
        -:  362:      {
    #####:  363:        ecma_deref_object (result_obj_p);
    #####:  364:        return result;
        -:  365:      }
        -:  366:
    #####:  367:      bool done = ecma_op_to_boolean (result);
    #####:  368:      ecma_free_value (result);
    #####:  369:      result = ecma_op_object_get_by_magic_id (result_obj_p, LIT_MAGIC_STRING_VALUE);
    #####:  370:      ecma_deref_object (result_obj_p);
        -:  371:
    #####:  372:      if (ECMA_IS_VALUE_ERROR (result))
        -:  373:      {
    #####:  374:        return result;
        -:  375:      }
        -:  376:
    #####:  377:      if (!done)
        -:  378:      {
    #####:  379:        ECMA_AWAIT_SET_STATE (executable_object_p, YIELD_NEXT_VALUE);
    #####:  380:        return ecma_promise_async_await ((ecma_extended_object_t *) executable_object_p, result);
        -:  381:      }
        -:  382:
    #####:  383:      ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
        -:  384:
    #####:  385:      if (state == ECMA_AWAIT_YIELD_NEXT_RETURN)
        -:  386:      {
    #####:  387:        executable_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_return;
        -:  388:      }
    #####:  389:      return result;
        -:  390:    }
    #####:  391:    case ECMA_AWAIT_YIELD_RETURN:
        -:  392:    {
    #####:  393:      ecma_object_t *obj_p = ecma_get_object_from_value (executable_object_p->iterator);
    #####:  394:      ecma_value_t result = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_RETURN);
        -:  395:
    #####:  396:      if (ECMA_IS_VALUE_ERROR (result))
        -:  397:      {
    #####:  398:        ecma_free_value (value);
    #####:  399:        return result;
        -:  400:      }
        -:  401:
    #####:  402:      if (result == ECMA_VALUE_UNDEFINED)
        -:  403:      {
    #####:  404:        ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
    #####:  405:        executable_object_p->frame_ctx.byte_code_p = opfunc_resume_executable_object_with_return;
    #####:  406:        return value;
        -:  407:      }
        -:  408:
    #####:  409:      result = ecma_async_yield_call (result, executable_object_p, value);
    #####:  410:      ecma_free_value (value);
        -:  411:
    #####:  412:      if (ECMA_IS_VALUE_ERROR (result))
        -:  413:      {
    #####:  414:        return result;
        -:  415:      }
        -:  416:
    #####:  417:      JERRY_ASSERT (result == ECMA_VALUE_UNDEFINED);
    #####:  418:      ECMA_AWAIT_CHANGE_STATE (executable_object_p, YIELD_RETURN, YIELD_NEXT_RETURN);
    #####:  419:      return ECMA_VALUE_UNDEFINED;
        -:  420:    }
    #####:  421:    case ECMA_AWAIT_YIELD_NEXT_VALUE:
        -:  422:    {
    #####:  423:      ECMA_AWAIT_CHANGE_STATE (executable_object_p, YIELD_NEXT_VALUE, YIELD_OPERATION);
    #####:  424:      opfunc_async_generator_yield ((ecma_extended_object_t *) executable_object_p, value);
    #####:  425:      return ECMA_VALUE_UNDEFINED;
        -:  426:    }
    #####:  427:    case ECMA_AWAIT_YIELD_OPERATION:
        -:  428:    {
        -:  429:      /* Currently this is always a throw exception case. */
    #####:  430:      ecma_value_t result = ecma_async_yield_throw (executable_object_p, value);
    #####:  431:      ecma_free_value (value);
    #####:  432:      return result;
        -:  433:    }
    #####:  434:    case ECMA_AWAIT_YIELD_CLOSE:
        -:  435:    {
    #####:  436:      ecma_error_msg_t msg = (ecma_is_value_object (value) ? ECMA_ERR_ITERATOR_THROW_IS_NOT_AVAILABLE
    #####:  437:                                                           : ECMA_ERR_VALUE_RECEIVED_BY_YIELD_IS_NOT_OBJECT);
        -:  438:
    #####:  439:      ecma_free_value (value);
    #####:  440:      return ecma_raise_type_error (msg);
        -:  441:    }
    #####:  442:    case ECMA_AWAIT_FOR_CLOSE:
        -:  443:    {
    #####:  444:      bool is_value_object = ecma_is_value_object (value);
    #####:  445:      ecma_free_value (value);
    #####:  446:      ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
        -:  447:
    #####:  448:      if (!is_value_object
    #####:  449:          && VM_GET_CONTEXT_TYPE (executable_object_p->frame_ctx.stack_top_p[-1]) != VM_CONTEXT_FINALLY_THROW)
        -:  450:      {
    #####:  451:        return ecma_raise_type_error (ECMA_ERR_ITERATOR_RETURN_RESULT_IS_NOT_OBJECT);
        -:  452:      }
    #####:  453:      return ECMA_VALUE_EMPTY;
        -:  454:    }
    #####:  455:    default:
        -:  456:    {
    #####:  457:      JERRY_ASSERT (state == ECMA_AWAIT_FOR_NEXT);
    #####:  458:      JERRY_ASSERT (VM_GET_CONTEXT_TYPE (executable_object_p->frame_ctx.stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####:  459:      JERRY_ASSERT (!(executable_object_p->frame_ctx.stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -:  460:
    #####:  461:      if (!ecma_is_value_object (value))
        -:  462:      {
    #####:  463:        ecma_free_value (value);
    #####:  464:        return ecma_raise_type_error (ECMA_ERR_VALUE_RECEIVED_BY_FOR_ASYNC_OF_IS_NOT_OBJECT);
        -:  465:      }
        -:  466:
    #####:  467:      ecma_object_t *result_obj_p = ecma_get_object_from_value (value);
    #####:  468:      ecma_value_t result = ecma_op_object_get_by_magic_id (result_obj_p, LIT_MAGIC_STRING_DONE);
        -:  469:
    #####:  470:      if (ECMA_IS_VALUE_ERROR (result))
        -:  471:      {
    #####:  472:        ecma_deref_object (result_obj_p);
    #####:  473:        return result;
        -:  474:      }
        -:  475:
    #####:  476:      bool done = ecma_op_to_boolean (result);
    #####:  477:      ecma_free_value (result);
        -:  478:
    #####:  479:      ecma_value_t *stack_top_p = executable_object_p->frame_ctx.stack_top_p;
    #####:  480:      JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);
    #####:  481:      JERRY_ASSERT (ecma_is_value_object (stack_top_p[-3]));
    #####:  482:      JERRY_ASSERT (stack_top_p[-4] == ECMA_VALUE_UNDEFINED || ecma_is_value_object (stack_top_p[-4]));
        -:  483:
    #####:  484:      if (!done)
        -:  485:      {
    #####:  486:        result = ecma_op_object_get_by_magic_id (result_obj_p, LIT_MAGIC_STRING_VALUE);
    #####:  487:        ecma_deref_object (result_obj_p);
        -:  488:
    #####:  489:        if (ECMA_IS_VALUE_ERROR (result))
        -:  490:        {
    #####:  491:          return result;
        -:  492:        }
        -:  493:
        -:  494:        /* It seems browsers call Await(result) here, although the standard does not
        -:  495:         * requests to do so. The following code might follow browsers in the future. */
    #####:  496:        ecma_deref_if_object (result);
    #####:  497:        stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;
    #####:  498:        stack_top_p[-2] = result;
    #####:  499:        ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
    #####:  500:        return ECMA_VALUE_EMPTY;
        -:  501:      }
        -:  502:
    #####:  503:      ecma_deref_object (result_obj_p);
        -:  504:
        -:  505:      /* This code jumps to the end regardless of the byte code which triggered this await. */
    #####:  506:      uint32_t context_end = VM_GET_CONTEXT_END (stack_top_p[-1]);
    #####:  507:      executable_object_p->frame_ctx.byte_code_p = executable_object_p->frame_ctx.byte_code_start_p + context_end;
        -:  508:
    #####:  509:      VM_MINUS_EQUAL_U16 (executable_object_p->frame_ctx.context_depth, PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
    #####:  510:      stack_top_p -= PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;
    #####:  511:      executable_object_p->frame_ctx.stack_top_p = stack_top_p;
        -:  512:
    #####:  513:      ECMA_EXECUTABLE_OBJECT_RESUME_EXEC (executable_object_p);
    #####:  514:      return ECMA_VALUE_EMPTY;
        -:  515:    }
        -:  516:  }
        -:  517:} /* ecma_await_continue */
        -:  518:
        -:  519:#endif /* JERRY_ESNEXT */
        -:  520:
        -:  521:/**
        -:  522: * @}
        -:  523: * @}
        -:  524: */
