        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-dataview-object.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-dataview-object.h"
        -:   17:
        -:   18:#include "ecma-arraybuffer-object.h"
        -:   19:#include "ecma-bigint.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-helpers.h"
        -:   25:#include "ecma-objects.h"
        -:   26:#include "ecma-shared-arraybuffer-object.h"
        -:   27:#include "ecma-typedarray-object.h"
        -:   28:
        -:   29:#include "jcontext.h"
        -:   30:
        -:   31:#if JERRY_BUILTIN_DATAVIEW
        -:   32:
        -:   33:/** \addtogroup ecma ECMA
        -:   34: * @{
        -:   35: *
        -:   36: * \addtogroup ecmadataviewobject ECMA builtin DataView helper functions
        -:   37: * @{
        -:   38: */
        -:   39:
        -:   40:/**
        -:   41: * Handle calling [[Construct]] of built-in DataView like objects
        -:   42: *
        -:   43: * See also:
        -:   44: *          ECMA-262 v11, 24.3.2.1
        -:   45: *
        -:   46: * @return created DataView object as an ecma-value - if success
        -:   47: *         raised error - otherwise
        -:   48: */
        -:   49:ecma_value_t
    #####:   50:ecma_op_dataview_create (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:   51:                         uint32_t arguments_list_len) /**< number of arguments */
        -:   52:{
    #####:   53:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
    #####:   54:  JERRY_ASSERT (JERRY_CONTEXT (current_new_target_p));
        -:   55:
    #####:   56:  ecma_value_t buffer = arguments_list_len > 0 ? arguments_list_p[0] : ECMA_VALUE_UNDEFINED;
        -:   57:
        -:   58:  /* 2. */
    #####:   59:  if (!ecma_is_value_object (buffer))
        -:   60:  {
    #####:   61:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_BUFFER_NOT_OBJECT);
        -:   62:  }
        -:   63:
    #####:   64:  ecma_object_t *buffer_p = ecma_get_object_from_value (buffer);
        -:   65:
    #####:   66:  if (!(ecma_object_class_is (buffer_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
    #####:   67:        || ecma_object_is_shared_arraybuffer (buffer_p)))
        -:   68:  {
    #####:   69:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_BUFFER_NOT_ARRAY_OR_SHARED_BUFFER);
        -:   70:  }
        -:   71:
        -:   72:  /* 3. */
    #####:   73:  ecma_number_t offset = 0;
        -:   74:
    #####:   75:  if (arguments_list_len > 1)
        -:   76:  {
    #####:   77:    ecma_value_t offset_value = ecma_op_to_index (arguments_list_p[1], &offset);
    #####:   78:    if (ECMA_IS_VALUE_ERROR (offset_value))
        -:   79:    {
    #####:   80:      return offset_value;
        -:   81:    }
        -:   82:  }
        -:   83:
        -:   84:  /* 4. */
    #####:   85:  if (ecma_arraybuffer_is_detached (buffer_p))
        -:   86:  {
    #####:   87:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:   88:  }
        -:   89:
        -:   90:  /* 5. */
    #####:   91:  ecma_number_t buffer_byte_length = ecma_arraybuffer_get_length (buffer_p);
        -:   92:
        -:   93:  /* 6. */
    #####:   94:  if (offset > buffer_byte_length)
        -:   95:  {
    #####:   96:    return ecma_raise_range_error (ECMA_ERR_START_OFFSET_IS_OUTSIDE_THE_BOUNDS_OF_THE_BUFFER);
        -:   97:  }
        -:   98:
        -:   99:  /* 7. */
        -:  100:  uint32_t view_byte_length;
    #####:  101:  if (arguments_list_len > 2 && !ecma_is_value_undefined (arguments_list_p[2]))
    #####:  102:  {
        -:  103:    /* 8.a */
    #####:  104:    ecma_number_t byte_length_to_index;
    #####:  105:    ecma_value_t byte_length_value = ecma_op_to_index (arguments_list_p[2], &byte_length_to_index);
        -:  106:
    #####:  107:    if (ECMA_IS_VALUE_ERROR (byte_length_value))
        -:  108:    {
    #####:  109:      return byte_length_value;
        -:  110:    }
        -:  111:
        -:  112:    /* 8.b */
    #####:  113:    if (offset + byte_length_to_index > buffer_byte_length)
        -:  114:    {
    #####:  115:      return ecma_raise_range_error (ECMA_ERR_START_OFFSET_IS_OUTSIDE_THE_BOUNDS_OF_THE_BUFFER);
        -:  116:    }
        -:  117:
    #####:  118:    JERRY_ASSERT (byte_length_to_index <= UINT32_MAX);
    #####:  119:    view_byte_length = (uint32_t) byte_length_to_index;
        -:  120:  }
        -:  121:  else
        -:  122:  {
        -:  123:    /* 7.a */
    #####:  124:    view_byte_length = (uint32_t) (buffer_byte_length - offset);
        -:  125:  }
        -:  126:
        -:  127:  /* 9. */
    #####:  128:  ecma_object_t *prototype_obj_p =
    #####:  129:    ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p), ECMA_BUILTIN_ID_DATAVIEW_PROTOTYPE);
    #####:  130:  if (JERRY_UNLIKELY (prototype_obj_p == NULL))
        -:  131:  {
    #####:  132:    return ECMA_VALUE_ERROR;
        -:  133:  }
        -:  134:
        -:  135:  /* 10. */
    #####:  136:  if (ecma_arraybuffer_is_detached (buffer_p))
        -:  137:  {
    #####:  138:    ecma_deref_object (prototype_obj_p);
    #####:  139:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  140:  }
        -:  141:
        -:  142:  /* 9. */
        -:  143:  /* It must happen after 10., because uninitialized object can't be destroyed properly. */
    #####:  144:  ecma_object_t *object_p =
        -:  145:    ecma_create_object (prototype_obj_p, sizeof (ecma_dataview_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  146:
    #####:  147:  ecma_deref_object (prototype_obj_p);
        -:  148:
        -:  149:  /* 11 - 14. */
    #####:  150:  ecma_dataview_object_t *dataview_obj_p = (ecma_dataview_object_t *) object_p;
    #####:  151:  dataview_obj_p->header.u.cls.type = ECMA_OBJECT_CLASS_DATAVIEW;
    #####:  152:  dataview_obj_p->header.u.cls.u3.length = view_byte_length;
    #####:  153:  dataview_obj_p->buffer_p = buffer_p;
    #####:  154:  dataview_obj_p->byte_offset = (uint32_t) offset;
        -:  155:
    #####:  156:  return ecma_make_object_value (object_p);
        -:  157:} /* ecma_op_dataview_create */
        -:  158:
        -:  159:/**
        -:  160: * Get the DataView object pointer
        -:  161: *
        -:  162: * Note:
        -:  163: *   If the function returns with NULL, the error object has
        -:  164: *   already set, and the caller must return with ECMA_VALUE_ERROR
        -:  165: *
        -:  166: * @return pointer to the dataView if this_arg is a valid dataView object
        -:  167: *         NULL otherwise
        -:  168: */
        -:  169:ecma_dataview_object_t *
    #####:  170:ecma_op_dataview_get_object (ecma_value_t this_arg) /**< this argument */
        -:  171:{
    #####:  172:  if (ecma_is_value_object (this_arg))
        -:  173:  {
    #####:  174:    ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  175:
    #####:  176:    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_DATAVIEW))
        -:  177:    {
    #####:  178:      return (ecma_dataview_object_t *) object_p;
        -:  179:    }
        -:  180:  }
        -:  181:
    #####:  182:  ecma_raise_type_error (ECMA_ERR_EXPECTED_A_DATAVIEW_OBJECT);
    #####:  183:  return NULL;
        -:  184:} /* ecma_op_dataview_get_object */
        -:  185:
        -:  186:/**
        -:  187: * Helper union to specify the system's endiannes
        -:  188: */
        -:  189:typedef union
        -:  190:{
        -:  191:  uint32_t number; /**< for write numeric data */
        -:  192:  char data[sizeof (uint32_t)]; /**< for read numeric data */
        -:  193:} ecma_dataview_endiannes_check_t;
        -:  194:
        -:  195:/**
        -:  196: * Helper function to check the current system endiannes
        -:  197: *
        -:  198: * @return true - if the current system has little endian byteorder
        -:  199: *         false - otherwise
        -:  200: */
        -:  201:static bool
    #####:  202:ecma_dataview_check_little_endian (void)
        -:  203:{
        -:  204:  ecma_dataview_endiannes_check_t checker;
    #####:  205:  checker.number = 0x01;
        -:  206:
    #####:  207:  return checker.data[0] == 0x01;
        -:  208:} /* ecma_dataview_check_little_endian */
        -:  209:
        -:  210:/**
        -:  211: * Helper function for swap bytes if the system's endiannes
        -:  212: * does not match with the requested endiannes.
        -:  213: */
        -:  214:static void
    #####:  215:ecma_dataview_swap_order (bool system_is_little_endian, /**< true - if the system has little endian byteorder
        -:  216:                                                         *   false - otherwise */
        -:  217:                          bool is_little_endian, /**< true - if little endian byteorder is requested
        -:  218:                                                  *   false - otherwise */
        -:  219:                          uint32_t element_size, /**< element size byte according to the Table 49.*/
        -:  220:                          lit_utf8_byte_t *block_p) /**< data block */
        -:  221:{
    #####:  222:  if (system_is_little_endian ^ is_little_endian)
        -:  223:  {
    #####:  224:    for (uint32_t i = 0; i < element_size / 2; i++)
        -:  225:    {
    #####:  226:      lit_utf8_byte_t tmp = block_p[i];
    #####:  227:      block_p[i] = block_p[element_size - i - 1];
    #####:  228:      block_p[element_size - i - 1] = tmp;
        -:  229:    }
        -:  230:  }
    #####:  231:} /* ecma_dataview_swap_order */
        -:  232:
        -:  233:/**
        -:  234: * GetViewValue and SetViewValue abstact operation
        -:  235: *
        -:  236: * See also:
        -:  237: *          ECMA-262 v11, 24.3.1.1
        -:  238: *          ECMA-262 v11, 24.3.1.2
        -:  239: *
        -:  240: * @return ecma value
        -:  241: */
        -:  242:ecma_value_t
    #####:  243:ecma_op_dataview_get_set_view_value (ecma_value_t view, /**< the operation's 'view' argument */
        -:  244:                                     ecma_value_t request_index, /**< the operation's 'requestIndex' argument */
        -:  245:                                     ecma_value_t is_little_endian_value, /**< the operation's
        -:  246:                                                                           *   'isLittleEndian' argument */
        -:  247:                                     ecma_value_t value_to_set, /**< the operation's 'value' argument */
        -:  248:                                     ecma_typedarray_type_t id) /**< the operation's 'type' argument */
        -:  249:{
        -:  250:  /* 1 - 2. */
    #####:  251:  ecma_dataview_object_t *view_p = ecma_op_dataview_get_object (view);
        -:  252:
    #####:  253:  if (JERRY_UNLIKELY (view_p == NULL))
        -:  254:  {
    #####:  255:    return ECMA_VALUE_ERROR;
        -:  256:  }
        -:  257:
    #####:  258:  ecma_object_t *buffer_p = view_p->buffer_p;
    #####:  259:  JERRY_ASSERT (ecma_object_class_is (buffer_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
        -:  260:                || ecma_object_is_shared_arraybuffer (buffer_p));
        -:  261:
        -:  262:  /* 3. */
    #####:  263:  ecma_number_t get_index;
    #####:  264:  ecma_value_t number_index_value = ecma_op_to_index (request_index, &get_index);
        -:  265:
    #####:  266:  if (ECMA_IS_VALUE_ERROR (number_index_value))
        -:  267:  {
    #####:  268:    return number_index_value;
        -:  269:  }
        -:  270:
        -:  271:  /* SetViewValue 4 - 5. */
    #####:  272:  if (!ecma_is_value_empty (value_to_set))
        -:  273:  {
        -:  274:#if JERRY_BUILTIN_BIGINT
    #####:  275:    if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (id))
        -:  276:    {
    #####:  277:      value_to_set = ecma_bigint_to_bigint (value_to_set, true);
        -:  278:
    #####:  279:      if (ECMA_IS_VALUE_ERROR (value_to_set))
        -:  280:      {
    #####:  281:        return value_to_set;
        -:  282:      }
        -:  283:    }
        -:  284:    else
        -:  285:#endif /* JERRY_BUILTIN_BIGINT */
        -:  286:    {
    #####:  287:      ecma_number_t value_to_set_number;
    #####:  288:      ecma_value_t value = ecma_op_to_number (value_to_set, &value_to_set_number);
        -:  289:
    #####:  290:      if (ECMA_IS_VALUE_ERROR (value))
        -:  291:      {
    #####:  292:        return value;
        -:  293:      }
        -:  294:
    #####:  295:      value_to_set = ecma_make_number_value (value_to_set_number);
        -:  296:    }
        -:  297:  }
        -:  298:
        -:  299:  /* GetViewValue 4., SetViewValue 6. */
    #####:  300:  bool is_little_endian = ecma_op_to_boolean (is_little_endian_value);
        -:  301:
    #####:  302:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (buffer_p))
        -:  303:  {
    #####:  304:    ecma_free_value (value_to_set);
    #####:  305:    return ECMA_VALUE_ERROR;
        -:  306:  }
        -:  307:
    #####:  308:  if (ecma_arraybuffer_is_detached (buffer_p))
        -:  309:  {
    #####:  310:    ecma_free_value (value_to_set);
    #####:  311:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  312:  }
        -:  313:
        -:  314:  /* GetViewValue 7., SetViewValue 9. */
    #####:  315:  uint32_t view_offset = view_p->byte_offset;
        -:  316:
        -:  317:  /* GetViewValue 8., SetViewValue 10. */
    #####:  318:  uint32_t view_size = view_p->header.u.cls.u3.length;
        -:  319:
        -:  320:  /* GetViewValue 9., SetViewValue 11. */
    #####:  321:  uint8_t element_size = (uint8_t) (1 << (ecma_typedarray_helper_get_shift_size (id)));
        -:  322:
        -:  323:  /* GetViewValue 10., SetViewValue 12. */
    #####:  324:  if (get_index + element_size > (ecma_number_t) view_size)
        -:  325:  {
    #####:  326:    ecma_free_value (value_to_set);
    #####:  327:    return ecma_raise_range_error (ECMA_ERR_START_OFFSET_IS_OUTSIDE_THE_BOUNDS_OF_THE_BUFFER);
        -:  328:  }
        -:  329:
    #####:  330:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (buffer_p))
        -:  331:  {
    #####:  332:    ecma_free_value (value_to_set);
    #####:  333:    return ECMA_VALUE_ERROR;
        -:  334:  }
        -:  335:
    #####:  336:  if (ecma_arraybuffer_is_detached (buffer_p))
        -:  337:  {
    #####:  338:    ecma_free_value (value_to_set);
    #####:  339:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  340:  }
        -:  341:
        -:  342:  /* GetViewValue 11., SetViewValue 13. */
    #####:  343:  bool system_is_little_endian = ecma_dataview_check_little_endian ();
        -:  344:
        -:  345:  ecma_typedarray_info_t info;
    #####:  346:  info.id = id;
    #####:  347:  info.length = view_size;
    #####:  348:  info.shift = ecma_typedarray_helper_get_shift_size (id);
    #####:  349:  info.element_size = element_size;
    #####:  350:  info.offset = view_p->byte_offset;
    #####:  351:  info.array_buffer_p = buffer_p;
        -:  352:
        -:  353:  /* GetViewValue 12. */
    #####:  354:  uint8_t *block_p = ecma_arraybuffer_get_buffer (buffer_p) + (uint32_t) get_index + view_offset;
        -:  355:
    #####:  356:  if (ecma_is_value_empty (value_to_set))
    #####:  357:  {
    #####:  358:    JERRY_VLA (lit_utf8_byte_t, swap_block_p, element_size);
    #####:  359:    memcpy (swap_block_p, block_p, element_size * sizeof (lit_utf8_byte_t));
    #####:  360:    ecma_dataview_swap_order (system_is_little_endian, is_little_endian, element_size, swap_block_p);
        -:  361:
    #####:  362:    ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info.id);
    #####:  363:    return typedarray_getter_cb (swap_block_p);
        -:  364:  }
        -:  365:
    #####:  366:  if (!ecma_number_is_nan (get_index) && get_index <= 0)
        -:  367:  {
    #####:  368:    get_index = 0;
        -:  369:  }
        -:  370:
        -:  371:  /* SetViewValue 14. */
    #####:  372:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####:  373:  ecma_value_t set_element = typedarray_setter_cb (block_p, value_to_set);
        -:  374:
    #####:  375:  ecma_free_value (value_to_set);
        -:  376:
    #####:  377:  if (ECMA_IS_VALUE_ERROR (set_element))
        -:  378:  {
    #####:  379:    return set_element;
        -:  380:  }
        -:  381:
    #####:  382:  ecma_dataview_swap_order (system_is_little_endian, is_little_endian, element_size, block_p);
        -:  383:
    #####:  384:  return ECMA_VALUE_UNDEFINED;
        -:  385:} /* ecma_op_dataview_get_set_view_value */
        -:  386:
        -:  387:/**
        -:  388: * Check if the value is dataview
        -:  389: *
        -:  390: * @return true - if value is a DataView object
        -:  391: *         false - otherwise
        -:  392: */
        -:  393:bool
    #####:  394:ecma_is_dataview (ecma_value_t value) /**< the target need to be checked */
        -:  395:{
    #####:  396:  if (!ecma_is_value_object (value))
        -:  397:  {
    #####:  398:    return false;
        -:  399:  }
        -:  400:
    #####:  401:  return ecma_object_class_is (ecma_get_object_from_value (value), ECMA_OBJECT_CLASS_DATAVIEW);
        -:  402:} /* ecma_is_dataview */
        -:  403:
        -:  404:/**
        -:  405: * @}
        -:  406: * @}
        -:  407: */
        -:  408:
        -:  409:#endif /* JERRY_BUILTIN_DATAVIEW */
