        -:    0:Source:/home/workspace/jerry-core/lit/lit-magic-strings.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "lit-magic-strings.h"
        -:   17:
        -:   18:#include "jcontext.h"
        -:   19:#include "lit-strings.h"
        -:   20:
        -:   21:/**
        -:   22: * Maximum number of external magic strings that can be registered.
        -:   23: */
        -:   24:#define LIT_EXTERNAL_MAGIC_STRING_LIMIT (UINT32_MAX / 2)
        -:   25:
        -:   26:/**
        -:   27: * Get number of external magic strings
        -:   28: *
        -:   29: * @return number of the strings, if there were registered,
        -:   30: *         zero - otherwise.
        -:   31: */
        -:   32:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
       10:   33:lit_get_magic_string_ex_count (void)
        -:   34:{
       10:   35:  return JERRY_CONTEXT (lit_magic_string_ex_count);
        -:   36:} /* lit_get_magic_string_ex_count */
        -:   37:
        -:   38:/**
        -:   39: * Get specified magic string as zero-terminated string
        -:   40: *
        -:   41: * @return pointer to zero-terminated magic string
        -:   42: */
        -:   43:const lit_utf8_byte_t *
       47:   44:lit_get_magic_string_utf8 (uint32_t id) /**< magic string id */
        -:   45:{
        -:   46:  static const lit_utf8_byte_t *const lit_magic_strings[] JERRY_ATTR_CONST_DATA = {
        -:   47:/** @cond doxygen_suppress */
        -:   48:#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)
        -:   49:#define LIT_MAGIC_STRING_DEF(id, utf8_string) (const lit_utf8_byte_t *) utf8_string,
        -:   50:#include "lit-magic-strings.inc.h"
        -:   51:#undef LIT_MAGIC_STRING_DEF
        -:   52:#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE
        -:   53:    /** @endcond */
        -:   54:  };
        -:   55:
       47:   56:  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);
        -:   57:
       47:   58:  return lit_magic_strings[id];
        -:   59:} /* lit_get_magic_string_utf8 */
        -:   60:
        -:   61:/**
        -:   62: * Get size of specified magic string
        -:   63: *
        -:   64: * @return size in bytes
        -:   65: */
        -:   66:lit_utf8_size_t
       10:   67:lit_get_magic_string_size (uint32_t id) /**< magic string id */
        -:   68:{
        -:   69:  static const lit_magic_size_t lit_magic_string_sizes[] JERRY_ATTR_CONST_DATA = {
        -:   70:/** @cond doxygen_suppress */
        -:   71:#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id)
        -:   72:#define LIT_MAGIC_STRING_DEF(id, utf8_string) sizeof (utf8_string) - 1,
        -:   73:#include "lit-magic-strings.inc.h"
        -:   74:#undef LIT_MAGIC_STRING_DEF
        -:   75:#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE
        -:   76:    /** @endcond */
        -:   77:  };
        -:   78:
       10:   79:  JERRY_ASSERT (id < LIT_NON_INTERNAL_MAGIC_STRING__COUNT);
        -:   80:
       10:   81:  return lit_magic_string_sizes[id];
        -:   82:} /* lit_get_magic_string_size */
        -:   83:
        -:   84:/**
        -:   85: * Get the block start element with the given size from
        -:   86: * the list of ECMA and implementation-defined magic string constants
        -:   87: *
        -:   88: * @return magic string id
        -:   89: */
        -:   90:static lit_magic_string_id_t
       20:   91:lit_get_magic_string_size_block_start (lit_utf8_size_t size) /**< magic string size */
        -:   92:{
        -:   93:  static const lit_magic_string_id_t lit_magic_string_size_block_starts[] JERRY_ATTR_CONST_DATA = {
        -:   94:/** @cond doxygen_suppress */
        -:   95:#define LIT_MAGIC_STRING_DEF(id, utf8_string)
        -:   96:#define LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE(size, id) id,
        -:   97:#include "lit-magic-strings.inc.h"
        -:   98:    LIT_NON_INTERNAL_MAGIC_STRING__COUNT
        -:   99:#undef LIT_MAGIC_STRING_DEF
        -:  100:#undef LIT_MAGIC_STRING_FIRST_STRING_WITH_SIZE
        -:  101:    /** @endcond */
        -:  102:  };
        -:  103:
       20:  104:  JERRY_ASSERT (size <= (sizeof (lit_magic_string_size_block_starts) / sizeof (lit_magic_string_id_t)));
        -:  105:
       20:  106:  return lit_magic_string_size_block_starts[size];
        -:  107:} /* lit_get_magic_string_size_block_start */
        -:  108:
        -:  109:/**
        -:  110: * Get specified magic string as zero-terminated string from external table
        -:  111: *
        -:  112: * @return pointer to zero-terminated magic string
        -:  113: */
        -:  114:const lit_utf8_byte_t *
    #####:  115:lit_get_magic_string_ex_utf8 (uint32_t id) /**< extern magic string id */
        -:  116:{
    #####:  117:  JERRY_ASSERT (JERRY_CONTEXT (lit_magic_string_ex_array) && id < JERRY_CONTEXT (lit_magic_string_ex_count));
        -:  118:
    #####:  119:  return JERRY_CONTEXT (lit_magic_string_ex_array)[id];
        -:  120:} /* lit_get_magic_string_ex_utf8 */
        -:  121:
        -:  122:/**
        -:  123: * Get size of specified external magic string
        -:  124: *
        -:  125: * @return size in bytes
        -:  126: */
        -:  127:lit_utf8_size_t
    #####:  128:lit_get_magic_string_ex_size (uint32_t id) /**< external magic string id */
        -:  129:{
    #####:  130:  return JERRY_CONTEXT (lit_magic_string_ex_sizes)[id];
        -:  131:} /* lit_get_magic_string_ex_size */
        -:  132:
        -:  133:/**
        -:  134: * Register external magic strings
        -:  135: */
        -:  136:void
    #####:  137:lit_magic_strings_ex_set (const lit_utf8_byte_t *const *ex_str_items, /**< character arrays, representing
        -:  138:                                                                       *   external magic strings' contents */
        -:  139:                          uint32_t count, /**< number of the strings */
        -:  140:                          const lit_utf8_size_t *ex_str_sizes) /**< sizes of the strings */
        -:  141:{
    #####:  142:  JERRY_ASSERT (ex_str_items != NULL);
    #####:  143:  JERRY_ASSERT (count > 0);
    #####:  144:  JERRY_ASSERT (ex_str_sizes != NULL);
        -:  145:
    #####:  146:  JERRY_ASSERT (JERRY_CONTEXT (lit_magic_string_ex_array) == NULL);
    #####:  147:  JERRY_ASSERT (JERRY_CONTEXT (lit_magic_string_ex_count) == 0);
    #####:  148:  JERRY_ASSERT (JERRY_CONTEXT (lit_magic_string_ex_sizes) == NULL);
        -:  149:
        -:  150:  /* Limit the number of external magic strings */
    #####:  151:  if (count > LIT_EXTERNAL_MAGIC_STRING_LIMIT)
        -:  152:  {
    #####:  153:    count = LIT_EXTERNAL_MAGIC_STRING_LIMIT;
        -:  154:  }
        -:  155:
        -:  156:  /* Set external magic strings information */
    #####:  157:  JERRY_CONTEXT (lit_magic_string_ex_array) = ex_str_items;
    #####:  158:  JERRY_CONTEXT (lit_magic_string_ex_count) = count;
    #####:  159:  JERRY_CONTEXT (lit_magic_string_ex_sizes) = ex_str_sizes;
        -:  160:
        -:  161:#ifndef JERRY_NDEBUG
    #####:  162:  for (lit_magic_string_ex_id_t id = (lit_magic_string_ex_id_t) 0; id < JERRY_CONTEXT (lit_magic_string_ex_count);
    #####:  163:       id = (lit_magic_string_ex_id_t) (id + 1))
        -:  164:  {
    #####:  165:    lit_utf8_size_t string_size = JERRY_CONTEXT (lit_magic_string_ex_sizes)[id];
        -:  166:
        -:  167:    /**
        -:  168:     * Check whether the strings are sorted by size and lexicographically,
        -:  169:     * e.g., "Bb" < "aa" < "aaa" < "xyz0".
        -:  170:     */
    #####:  171:    if (id > 0)
        -:  172:    {
    #####:  173:      const lit_magic_string_ex_id_t prev_id = id - 1;
    #####:  174:      const lit_utf8_size_t prev_string_size = lit_get_magic_string_ex_size (prev_id);
    #####:  175:      JERRY_ASSERT (lit_is_valid_cesu8_string (lit_get_magic_string_ex_utf8 (id), string_size));
    #####:  176:      JERRY_ASSERT (prev_string_size <= string_size);
        -:  177:
    #####:  178:      if (prev_string_size == string_size)
        -:  179:      {
    #####:  180:        const lit_utf8_byte_t *prev_ex_string_p = lit_get_magic_string_ex_utf8 (prev_id);
    #####:  181:        const lit_utf8_byte_t *curr_ex_string_p = lit_get_magic_string_ex_utf8 (id);
    #####:  182:        JERRY_ASSERT (memcmp (prev_ex_string_p, curr_ex_string_p, string_size) < 0);
        -:  183:      }
        -:  184:    }
        -:  185:  }
        -:  186:#endif /* !JERRY_NDEBUG */
    #####:  187:} /* lit_magic_strings_ex_set */
        -:  188:
        -:  189:/**
        -:  190: * Returns the magic string id of the argument string if it is available.
        -:  191: *
        -:  192: * @return id - if magic string id is found,
        -:  193: *         LIT_MAGIC_STRING__COUNT - otherwise.
        -:  194: */
        -:  195:lit_magic_string_id_t
       10:  196:lit_is_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */
        -:  197:                          lit_utf8_size_t string_size) /**< string size in bytes */
        -:  198:{
       10:  199:  if (string_size > lit_get_magic_string_size (LIT_NON_INTERNAL_MAGIC_STRING__COUNT - 1))
        -:  200:  {
    #####:  201:    return LIT_MAGIC_STRING__COUNT;
        -:  202:  }
        -:  203:
        -:  204:  /**< The string must be in this id range. */
       10:  205:  lit_utf8_size_t first = lit_get_magic_string_size_block_start (string_size);
       10:  206:  lit_utf8_size_t last = lit_get_magic_string_size_block_start (string_size + 1);
        -:  207:
       67:  208:  while (first < last)
        -:  209:  {
       47:  210:    lit_utf8_size_t middle = ((first + last) / 2); /**< mid point of search */
       47:  211:    int compare = memcmp (lit_get_magic_string_utf8 ((lit_magic_string_id_t) middle), string_p, string_size);
        -:  212:
       47:  213:    if (compare == 0)
        -:  214:    {
    #####:  215:      return (lit_magic_string_id_t) middle;
        -:  216:    }
       47:  217:    else if (compare > 0)
        -:  218:    {
       25:  219:      last = middle;
        -:  220:    }
        -:  221:    else
        -:  222:    {
       22:  223:      first = middle + 1;
        -:  224:    }
        -:  225:  }
        -:  226:
       10:  227:  return LIT_MAGIC_STRING__COUNT;
        -:  228:} /* lit_is_utf8_string_magic */
        -:  229:
        -:  230:/**
        -:  231: * Returns the magic string id of the argument string pair if it is available.
        -:  232: *
        -:  233: * @return id - if magic string id is found,
        -:  234: *         LIT_MAGIC_STRING__COUNT - otherwise.
        -:  235: */
        -:  236:lit_magic_string_id_t
    #####:  237:lit_is_utf8_string_pair_magic (const lit_utf8_byte_t *string1_p, /**< first utf-8 string */
        -:  238:                               lit_utf8_size_t string1_size, /**< first string size in bytes */
        -:  239:                               const lit_utf8_byte_t *string2_p, /**< second utf-8 string */
        -:  240:                               lit_utf8_size_t string2_size) /**< second string size in bytes */
        -:  241:{
    #####:  242:  lit_utf8_size_t total_string_size = string1_size + string2_size;
        -:  243:
    #####:  244:  if (total_string_size > lit_get_magic_string_size (LIT_NON_INTERNAL_MAGIC_STRING__COUNT - 1))
        -:  245:  {
    #####:  246:    return LIT_MAGIC_STRING__COUNT;
        -:  247:  }
        -:  248:
        -:  249:  /**< The string must be in this id range. */
    #####:  250:  lit_utf8_size_t first = lit_get_magic_string_size_block_start (total_string_size);
    #####:  251:  lit_utf8_size_t last = lit_get_magic_string_size_block_start (total_string_size + 1);
        -:  252:
    #####:  253:  while (first < last)
        -:  254:  {
    #####:  255:    lit_utf8_size_t middle = ((first + last) / 2); /**< mid point of search */
    #####:  256:    const lit_utf8_byte_t *middle_string_p = lit_get_magic_string_utf8 ((lit_magic_string_id_t) middle);
        -:  257:
    #####:  258:    int compare = memcmp (middle_string_p, string1_p, string1_size);
        -:  259:
    #####:  260:    if (compare == 0)
        -:  261:    {
    #####:  262:      compare = memcmp (middle_string_p + string1_size, string2_p, string2_size);
        -:  263:    }
        -:  264:
    #####:  265:    if (compare == 0)
        -:  266:    {
    #####:  267:      return (lit_magic_string_id_t) middle;
        -:  268:    }
    #####:  269:    else if (compare > 0)
        -:  270:    {
    #####:  271:      last = middle;
        -:  272:    }
        -:  273:    else
        -:  274:    {
    #####:  275:      first = middle + 1;
        -:  276:    }
        -:  277:  }
        -:  278:
    #####:  279:  return LIT_MAGIC_STRING__COUNT;
        -:  280:} /* lit_is_utf8_string_pair_magic */
        -:  281:
        -:  282:/**
        -:  283: * Returns the ex magic string id of the argument string if it is available.
        -:  284: *
        -:  285: * @return id - if magic string id is found,
        -:  286: *         lit_get_magic_string_ex_count () - otherwise.
        -:  287: */
        -:  288:lit_magic_string_ex_id_t
    #####:  289:lit_is_ex_utf8_string_magic (const lit_utf8_byte_t *string_p, /**< utf-8 string */
        -:  290:                             lit_utf8_size_t string_size) /**< string size in bytes */
        -:  291:{
    #####:  292:  const uint32_t magic_string_ex_count = lit_get_magic_string_ex_count ();
        -:  293:
    #####:  294:  if (magic_string_ex_count == 0 || string_size > lit_get_magic_string_ex_size (magic_string_ex_count - 1))
        -:  295:  {
    #####:  296:    return (lit_magic_string_ex_id_t) magic_string_ex_count;
        -:  297:  }
        -:  298:
    #####:  299:  lit_magic_string_ex_id_t first = 0;
    #####:  300:  lit_magic_string_ex_id_t last = (lit_magic_string_ex_id_t) magic_string_ex_count;
        -:  301:
    #####:  302:  while (first < last)
        -:  303:  {
    #####:  304:    const lit_magic_string_ex_id_t middle = (first + last) / 2;
    #####:  305:    const lit_utf8_byte_t *ext_string_p = lit_get_magic_string_ex_utf8 (middle);
    #####:  306:    const lit_utf8_size_t ext_string_size = lit_get_magic_string_ex_size (middle);
        -:  307:
    #####:  308:    if (string_size == ext_string_size)
        -:  309:    {
    #####:  310:      const int string_compare = memcmp (ext_string_p, string_p, string_size);
        -:  311:
    #####:  312:      if (string_compare == 0)
        -:  313:      {
    #####:  314:        return middle;
        -:  315:      }
    #####:  316:      else if (string_compare < 0)
        -:  317:      {
    #####:  318:        first = middle + 1;
        -:  319:      }
        -:  320:      else
        -:  321:      {
    #####:  322:        last = middle;
        -:  323:      }
        -:  324:    }
    #####:  325:    else if (string_size > ext_string_size)
        -:  326:    {
    #####:  327:      first = middle + 1;
        -:  328:    }
        -:  329:    else
        -:  330:    {
    #####:  331:      last = middle;
        -:  332:    }
        -:  333:  }
        -:  334:
    #####:  335:  return (lit_magic_string_ex_id_t) magic_string_ex_count;
        -:  336:} /* lit_is_ex_utf8_string_magic */
        -:  337:
        -:  338:/**
        -:  339: * Returns the ex magic string id of the argument string pair if it is available.
        -:  340: *
        -:  341: * @return id - if magic string id is found,
        -:  342: *         lit_get_magic_string_ex_count () - otherwise.
        -:  343: */
        -:  344:lit_magic_string_ex_id_t
    #####:  345:lit_is_ex_utf8_string_pair_magic (const lit_utf8_byte_t *string1_p, /**< first utf-8 string */
        -:  346:                                  lit_utf8_size_t string1_size, /**< first string size in bytes */
        -:  347:                                  const lit_utf8_byte_t *string2_p, /**< second utf-8 string */
        -:  348:                                  lit_utf8_size_t string2_size) /**< second string size in bytes */
        -:  349:{
    #####:  350:  const uint32_t magic_string_ex_count = lit_get_magic_string_ex_count ();
    #####:  351:  const lit_utf8_size_t total_string_size = string1_size + string2_size;
        -:  352:
    #####:  353:  if (magic_string_ex_count == 0 || total_string_size > lit_get_magic_string_ex_size (magic_string_ex_count - 1))
        -:  354:  {
    #####:  355:    return (lit_magic_string_ex_id_t) magic_string_ex_count;
        -:  356:  }
        -:  357:
    #####:  358:  lit_magic_string_ex_id_t first = 0;
    #####:  359:  lit_magic_string_ex_id_t last = (lit_magic_string_ex_id_t) magic_string_ex_count;
        -:  360:
    #####:  361:  while (first < last)
        -:  362:  {
    #####:  363:    const lit_magic_string_ex_id_t middle = (first + last) / 2;
    #####:  364:    const lit_utf8_byte_t *ext_string_p = lit_get_magic_string_ex_utf8 (middle);
    #####:  365:    const lit_utf8_size_t ext_string_size = lit_get_magic_string_ex_size (middle);
        -:  366:
    #####:  367:    if (total_string_size == ext_string_size)
        -:  368:    {
    #####:  369:      int string_compare = memcmp (ext_string_p, string1_p, string1_size);
        -:  370:
    #####:  371:      if (string_compare == 0)
        -:  372:      {
    #####:  373:        string_compare = memcmp (ext_string_p + string1_size, string2_p, string2_size);
        -:  374:      }
        -:  375:
    #####:  376:      if (string_compare == 0)
        -:  377:      {
    #####:  378:        return middle;
        -:  379:      }
    #####:  380:      else if (string_compare < 0)
        -:  381:      {
    #####:  382:        first = middle + 1;
        -:  383:      }
        -:  384:      else
        -:  385:      {
    #####:  386:        last = middle;
        -:  387:      }
        -:  388:    }
    #####:  389:    else if (total_string_size > ext_string_size)
        -:  390:    {
    #####:  391:      first = middle + 1;
        -:  392:    }
        -:  393:    else
        -:  394:    {
    #####:  395:      last = middle;
        -:  396:    }
        -:  397:  }
        -:  398:
    #####:  399:  return (lit_magic_string_ex_id_t) magic_string_ex_count;
        -:  400:} /* lit_is_ex_utf8_string_pair_magic */
        -:  401:
        -:  402:/**
        -:  403: * Copy magic string to buffer
        -:  404: *
        -:  405: * Warning:
        -:  406: *         the routine requires that buffer size is enough
        -:  407: *
        -:  408: * @return pointer to the byte next to the last copied in the buffer
        -:  409: */
        -:  410:lit_utf8_byte_t *
    #####:  411:lit_copy_magic_string_to_buffer (lit_magic_string_id_t id, /**< magic string id */
        -:  412:                                 lit_utf8_byte_t *buffer_p, /**< destination buffer */
        -:  413:                                 lit_utf8_size_t buffer_size) /**< size of buffer */
        -:  414:{
    #####:  415:  const lit_utf8_byte_t *magic_string_bytes_p = lit_get_magic_string_utf8 (id);
    #####:  416:  lit_utf8_size_t magic_string_bytes_count = lit_get_magic_string_size (id);
        -:  417:
    #####:  418:  const lit_utf8_byte_t *str_iter_p = magic_string_bytes_p;
    #####:  419:  lit_utf8_byte_t *buf_iter_p = buffer_p;
    #####:  420:  lit_utf8_size_t bytes_copied = 0;
        -:  421:
    #####:  422:  while (magic_string_bytes_count--)
        -:  423:  {
    #####:  424:    bytes_copied++;
    #####:  425:    JERRY_ASSERT (bytes_copied <= buffer_size);
        -:  426:
    #####:  427:    *buf_iter_p++ = *str_iter_p++;
        -:  428:  }
        -:  429:
    #####:  430:  return buf_iter_p;
        -:  431:} /* lit_copy_magic_string_to_buffer */
