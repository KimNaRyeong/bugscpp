        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-value.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-exceptions.h"
        -:   18:#include "ecma-function-object.h"
        -:   19:#include "ecma-gc.h"
        -:   20:#include "ecma-globals.h"
        -:   21:#include "ecma-helpers-number.h"
        -:   22:#include "ecma-helpers.h"
        -:   23:
        -:   24:#include "jrt-bit-fields.h"
        -:   25:#include "jrt.h"
        -:   26:#include "vm-defines.h"
        -:   27:
        -:   28:JERRY_STATIC_ASSERT (ECMA_TYPE___MAX <= ECMA_VALUE_TYPE_MASK, ecma_types_must_be_less_than_mask);
        -:   29:
        -:   30:JERRY_STATIC_ASSERT ((ECMA_VALUE_TYPE_MASK + 1) == (1 << ECMA_VALUE_SHIFT), ecma_value_part_must_start_after_flags);
        -:   31:
        -:   32:JERRY_STATIC_ASSERT (ECMA_VALUE_SHIFT <= JMEM_ALIGNMENT_LOG,
        -:   33:                     ecma_value_shift_must_be_less_than_or_equal_than_mem_alignment_log);
        -:   34:
        -:   35:JERRY_STATIC_ASSERT (sizeof (jmem_cpointer_t) <= sizeof (ecma_value_t),
        -:   36:                     size_of_jmem_cpointer_t_must_be_less_or_equal_to_the_size_of_ecma_value_t);
        -:   37:
        -:   38:JERRY_STATIC_ASSERT (sizeof (jmem_cpointer_t) <= sizeof (jmem_cpointer_tag_t),
        -:   39:                     size_of_jmem_cpointer_t_must_be_less_or_equal_to_the_size_of_jmem_cpointer_tag_t);
        -:   40:
        -:   41:#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY
        -:   42:
        -:   43:/* cppcheck-suppress zerodiv */
        -:   44:JERRY_STATIC_ASSERT (sizeof (uintptr_t) <= sizeof (ecma_value_t), uintptr_t_must_fit_in_ecma_value_t);
        -:   45:
        -:   46:#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:   47:
        -:   48:JERRY_STATIC_ASSERT (sizeof (uintptr_t) > sizeof (ecma_value_t), uintptr_t_must_not_fit_in_ecma_value_t);
        -:   49:
        -:   50:#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:   51:
        -:   52:JERRY_STATIC_ASSERT ((ECMA_VALUE_FALSE | (1 << ECMA_DIRECT_SHIFT)) == ECMA_VALUE_TRUE
        -:   53:                       && ECMA_VALUE_FALSE != ECMA_VALUE_TRUE,
        -:   54:                     only_the_lowest_bit_must_be_different_for_simple_value_true_and_false);
        -:   55:
        -:   56:#if JERRY_BUILTIN_BIGINT
        -:   57:
        -:   58:JERRY_STATIC_ASSERT (ECMA_NULL_POINTER == (ECMA_BIGINT_ZERO & ~(ecma_value_t) ECMA_VALUE_TYPE_MASK),
        -:   59:                     ecma_bigint_zero_must_be_encoded_as_null_pointer);
        -:   60:
        -:   61:#endif /* JERRY_BUILTIN_BIGINT */
        -:   62:
        -:   63:/** \addtogroup ecma ECMA
        -:   64: * @{
        -:   65: *
        -:   66: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   67: * @{
        -:   68: */
        -:   69:
        -:   70:/**
        -:   71: * Get type field of ecma value
        -:   72: *
        -:   73: * @return type field
        -:   74: */
        -:   75:extern inline ecma_type_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:   76:ecma_get_value_type_field (ecma_value_t value) /**< ecma value */
        -:   77:{
   143256:   78:  return value & ECMA_VALUE_TYPE_MASK;
        -:   79:} /* ecma_get_value_type_field */
        -:   80:
        -:   81:/**
        -:   82: * Convert a pointer into an ecma value.
        -:   83: *
        -:   84: * @return ecma value
        -:   85: */
        -:   86:static inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        -:   87:ecma_pointer_to_ecma_value (const void *ptr) /**< pointer */
        -:   88:{
        -:   89:#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY
        -:   90:
    35736:   91:  JERRY_ASSERT (ptr != NULL);
    35736:   92:  uintptr_t uint_ptr = (uintptr_t) ptr;
    35736:   93:  JERRY_ASSERT ((uint_ptr & ECMA_VALUE_TYPE_MASK) == 0);
    35736:   94:  return (ecma_value_t) uint_ptr;
        -:   95:
        -:   96:#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:   97:
        -:   98:  jmem_cpointer_t ptr_cp;
    #####:   99:  ECMA_SET_NON_NULL_POINTER (ptr_cp, ptr);
    #####:  100:  return ((ecma_value_t) ptr_cp) << ECMA_VALUE_SHIFT;
        -:  101:
        -:  102:#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:  103:} /* ecma_pointer_to_ecma_value */
        -:  104:
        -:  105:/**
        -:  106: * Get a pointer from an ecma value
        -:  107: *
        -:  108: * @return pointer
        -:  109: */
        -:  110:static inline void *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        -:  111:ecma_get_pointer_from_ecma_value (ecma_value_t value) /**< value */
        -:  112:{
        -:  113:#ifdef ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY
    71621:  114:  void *ptr = (void *) (uintptr_t) ((value) & ~ECMA_VALUE_TYPE_MASK);
    71621:  115:  JERRY_ASSERT (ptr != NULL);
    71621:  116:  return ptr;
        -:  117:#else /* !ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
    #####:  118:  return ECMA_GET_NON_NULL_POINTER (void, value >> ECMA_VALUE_SHIFT);
        -:  119:#endif /* ECMA_VALUE_CAN_STORE_UINTPTR_VALUE_DIRECTLY */
        -:  120:} /* ecma_get_pointer_from_ecma_value */
        -:  121:
        -:  122:/**
        -:  123: * Check if the value is direct ecma-value.
        -:  124: *
        -:  125: * @return true - if the value is a direct value,
        -:  126: *         false - otherwise
        -:  127: */
        -:  128:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  129:ecma_is_value_direct (ecma_value_t value) /**< ecma value */
        -:  130:{
    #####:  131:  return (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT);
        -:  132:} /* ecma_is_value_direct */
        -:  133:
        -:  134:/**
        -:  135: * Check if the value is simple ecma-value.
        -:  136: *
        -:  137: * @return true - if the value is a simple value,
        -:  138: *         false - otherwise
        -:  139: */
        -:  140:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  141:ecma_is_value_simple (ecma_value_t value) /**< ecma value */
        -:  142:{
    #####:  143:  return (value & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_SIMPLE_VALUE;
        -:  144:} /* ecma_is_value_simple */
        -:  145:
        -:  146:/**
        -:  147: * Check whether the value is a given simple value.
        -:  148: *
        -:  149: * @return true - if the value is equal to the given simple value,
        -:  150: *         false - otherwise
        -:  151: */
        -:  152:static inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        -:  153:ecma_is_value_equal_to_simple_value (ecma_value_t value, /**< ecma value */
        -:  154:                                     ecma_value_t simple_value) /**< simple value */
        -:  155:{
    23817:  156:  return value == simple_value;
        -:  157:} /* ecma_is_value_equal_to_simple_value */
        -:  158:
        -:  159:/**
        -:  160: * Check if the value is empty.
        -:  161: *
        -:  162: * @return true - if the value contains implementation-defined empty simple value,
        -:  163: *         false - otherwise
        -:  164: */
        -:  165:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  166:ecma_is_value_empty (ecma_value_t value) /**< ecma value */
        -:  167:{
    #####:  168:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_EMPTY);
        -:  169:} /* ecma_is_value_empty */
        -:  170:
        -:  171:/**
        -:  172: * Check if the value is undefined.
        -:  173: *
        -:  174: * @return true - if the value contains ecma-undefined simple value,
        -:  175: *         false - otherwise
        -:  176: */
        -:  177:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    11907:  178:ecma_is_value_undefined (ecma_value_t value) /**< ecma value */
        -:  179:{
    11907:  180:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_UNDEFINED);
        -:  181:} /* ecma_is_value_undefined */
        -:  182:
        -:  183:/**
        -:  184: * Check if the value is null.
        -:  185: *
        -:  186: * @return true - if the value contains ecma-null simple value,
        -:  187: *         false - otherwise
        -:  188: */
        -:  189:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    11901:  190:ecma_is_value_null (ecma_value_t value) /**< ecma value */
        -:  191:{
    11901:  192:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_NULL);
        -:  193:} /* ecma_is_value_null */
        -:  194:
        -:  195:/**
        -:  196: * Check if the value is boolean.
        -:  197: *
        -:  198: * @return true - if the value contains ecma-true or ecma-false simple values,
        -:  199: *         false - otherwise
        -:  200: */
        -:  201:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        2:  202:ecma_is_value_boolean (ecma_value_t value) /**< ecma value */
        -:  203:{
        4:  204:  return ecma_is_value_true (value | (1 << ECMA_DIRECT_SHIFT));
        -:  205:} /* ecma_is_value_boolean */
        -:  206:
        -:  207:/**
        -:  208: * Check if the value is true.
        -:  209: *
        -:  210: * @return true - if the value contains ecma-true simple value,
        -:  211: *         false - otherwise
        -:  212: */
        -:  213:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        6:  214:ecma_is_value_true (ecma_value_t value) /**< ecma value */
        -:  215:{
        8:  216:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_TRUE);
        -:  217:} /* ecma_is_value_true */
        -:  218:
        -:  219:/**
        -:  220: * Check if the value is false.
        -:  221: *
        -:  222: * @return true - if the value contains ecma-false simple value,
        -:  223: *         false - otherwise
        -:  224: */
        -:  225:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        1:  226:ecma_is_value_false (ecma_value_t value) /**< ecma value */
        -:  227:{
        1:  228:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_FALSE);
        -:  229:} /* ecma_is_value_false */
        -:  230:
        -:  231:/**
        -:  232: * Check if the value is not found.
        -:  233: *
        -:  234: * @return true - if the value contains ecma-not-found simple value,
        -:  235: *         false - otherwise
        -:  236: */
        -:  237:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    11901:  238:ecma_is_value_found (ecma_value_t value) /**< ecma value */
        -:  239:{
    11901:  240:  return value != ECMA_VALUE_NOT_FOUND;
        -:  241:} /* ecma_is_value_found */
        -:  242:
        -:  243:/**
        -:  244: * Check if the value is array hole.
        -:  245: *
        -:  246: * @return true - if the value contains ecma-array-hole simple value,
        -:  247: *         false - otherwise
        -:  248: */
        -:  249:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  250:ecma_is_value_array_hole (ecma_value_t value) /**< ecma value */
        -:  251:{
    #####:  252:  return ecma_is_value_equal_to_simple_value (value, ECMA_VALUE_ARRAY_HOLE);
        -:  253:} /* ecma_is_value_array_hole */
        -:  254:
        -:  255:/**
        -:  256: * Check if the value is integer ecma-number.
        -:  257: *
        -:  258: * @return true - if the value contains an integer ecma-number value,
        -:  259: *         false - otherwise
        -:  260: */
        -:  261:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  262:ecma_is_value_integer_number (ecma_value_t value) /**< ecma value */
        -:  263:{
    #####:  264:  return (value & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_INTEGER_VALUE;
        -:  265:} /* ecma_is_value_integer_number */
        -:  266:
        -:  267:/**
        -:  268: * Check if both values are integer ecma-numbers.
        -:  269: *
        -:  270: * @return true - if both values contain integer ecma-number values,
        -:  271: *         false - otherwise
        -:  272: */
        -:  273:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  274:ecma_are_values_integer_numbers (ecma_value_t first_value, /**< first ecma value */
        -:  275:                                 ecma_value_t second_value) /**< second ecma value */
        -:  276:{
        -:  277:  JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_INTEGER_VALUE == 0, ecma_direct_type_integer_value_must_be_zero);
        -:  278:
    #####:  279:  return ((first_value | second_value) & ECMA_DIRECT_TYPE_MASK) == ECMA_DIRECT_TYPE_INTEGER_VALUE;
        -:  280:} /* ecma_are_values_integer_numbers */
        -:  281:
        -:  282:/**
        -:  283: * Check if the value is floating-point ecma-number.
        -:  284: *
        -:  285: * @return true - if the value contains a floating-point ecma-number value,
        -:  286: *         false - otherwise
        -:  287: */
        -:  288:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  289:ecma_is_value_float_number (ecma_value_t value) /**< ecma value */
        -:  290:{
        1:  291:  return (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);
        -:  292:} /* ecma_is_value_float_number */
        -:  293:
        -:  294:/**
        -:  295: * Check if the value is ecma-number.
        -:  296: *
        -:  297: * @return true - if the value contains ecma-number value,
        -:  298: *         false - otherwise
        -:  299: */
        -:  300:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  301:ecma_is_value_number (ecma_value_t value) /**< ecma value */
        -:  302:{
    #####:  303:  return (ecma_is_value_integer_number (value) || ecma_is_value_float_number (value));
        -:  304:} /* ecma_is_value_number */
        -:  305:
        -:  306:JERRY_STATIC_ASSERT ((ECMA_TYPE_STRING | 0x4) == ECMA_TYPE_DIRECT_STRING,
        -:  307:                     ecma_type_string_and_direct_string_must_have_one_bit_difference);
        -:  308:
        -:  309:/**
        -:  310: * Check if the value is ecma-string.
        -:  311: *
        -:  312: * @return true - if the value contains ecma-string value,
        -:  313: *         false - otherwise
        -:  314: */
        -:  315:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        2:  316:ecma_is_value_string (ecma_value_t value) /**< ecma value */
        -:  317:{
    11917:  318:  return ((value & (ECMA_VALUE_TYPE_MASK - 0x4)) == ECMA_TYPE_STRING);
        -:  319:} /* ecma_is_value_string */
        -:  320:
        -:  321:/**
        -:  322: * Check if the value is symbol.
        -:  323: *
        -:  324: * @return true - if the value contains symbol value,
        -:  325: *         false - otherwise
        -:  326: */
        -:  327:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  328:ecma_is_value_symbol (ecma_value_t value) /**< ecma value */
        -:  329:{
        -:  330:#if JERRY_ESNEXT
    #####:  331:  return (ecma_get_value_type_field (value) == ECMA_TYPE_SYMBOL);
        -:  332:#else /* JERRY_ESNEXT */
        -:  333:  JERRY_UNUSED (value);
    #####:  334:  return false;
        -:  335:#endif /* JERRY_ESNEXT */
        -:  336:} /* ecma_is_value_symbol */
        -:  337:
        -:  338:/**
        -:  339: * Check if the value is a specific magic string.
        -:  340: *
        -:  341: * @return true - if the value the magic string value,
        -:  342: *         false - otherwise
        -:  343: */
        -:  344:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        1:  345:ecma_is_value_magic_string (ecma_value_t value, /**< ecma value */
        -:  346:                            lit_magic_string_id_t id) /**< magic string id */
        -:  347:{
        1:  348:  return value == ecma_make_magic_string_value (id);
        -:  349:} /* ecma_is_value_magic_string */
        -:  350:
        -:  351:/**
        -:  352: * Check if the value is bigint.
        -:  353: *
        -:  354: * @return true - if the value contains bigint value,
        -:  355: *         false - otherwise
        -:  356: */
        -:  357:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  358:ecma_is_value_bigint (ecma_value_t value) /**< ecma value */
        -:  359:{
        -:  360:#if JERRY_BUILTIN_BIGINT
    #####:  361:  return (ecma_get_value_type_field (value) == ECMA_TYPE_BIGINT);
        -:  362:#else /* !JERRY_BUILTIN_BIGINT */
        -:  363:  JERRY_UNUSED (value);
    #####:  364:  return false;
        -:  365:#endif /* JERRY_BUILTIN_BIGINT */
        -:  366:} /* ecma_is_value_bigint */
        -:  367:
        -:  368:/**
        -:  369: * Check if the value can be property name.
        -:  370: *
        -:  371: * @return true - if the value can be property name value,
        -:  372: *         false - otherwise
        -:  373: */
        -:  374:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        5:  375:ecma_is_value_prop_name (ecma_value_t value) /**< ecma value */
        -:  376:{
        -:  377:#if JERRY_ESNEXT
       10:  378:  return ecma_is_value_string (value) || ecma_is_value_symbol (value);
        -:  379:#else /* !JERRY_ESNEXT */
    #####:  380:  return ecma_is_value_string (value);
        -:  381:#endif /* JERRY_ESNEXT */
        -:  382:} /* ecma_is_value_prop_name */
        -:  383:
        -:  384:/**
        -:  385: * Check if the value is direct ecma-string.
        -:  386: *
        -:  387: * @return true - if the value contains direct ecma-string value,
        -:  388: *         false - otherwise
        -:  389: */
        -:  390:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  391:ecma_is_value_direct_string (ecma_value_t value) /**< ecma value */
        -:  392:{
    #####:  393:  return (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);
        -:  394:} /* ecma_is_value_direct_string */
        -:  395:
        -:  396:/**
        -:  397: * Check if the value is non-direct ecma-string.
        -:  398: *
        -:  399: * @return true - if the value contains non-direct ecma-string value,
        -:  400: *         false - otherwise
        -:  401: */
        -:  402:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  403:ecma_is_value_non_direct_string (ecma_value_t value) /**< ecma value */
        -:  404:{
    #####:  405:  return (ecma_get_value_type_field (value) == ECMA_TYPE_STRING);
        -:  406:} /* ecma_is_value_non_direct_string */
        -:  407:
        -:  408:/**
        -:  409: * Check if the value is object.
        -:  410: *
        -:  411: * @return true - if the value contains object value,
        -:  412: *         false - otherwise
        -:  413: */
        -:  414:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    35873:  415:ecma_is_value_object (ecma_value_t value) /**< ecma value */
        -:  416:{
    95585:  417:  return (ecma_get_value_type_field (value) == ECMA_TYPE_OBJECT);
        -:  418:} /* ecma_is_value_object */
        -:  419:
        -:  420:/**
        -:  421: * Check if the value is error reference.
        -:  422: *
        -:  423: * @return true - if the value contains an error reference,
        -:  424: *         false - otherwise
        -:  425: */
        -:  426:extern inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
       32:  427:ecma_is_value_exception (ecma_value_t value) /**< ecma value */
        -:  428:{
       32:  429:  return (ecma_get_value_type_field (value) == ECMA_TYPE_ERROR);
        -:  430:} /* ecma_is_value_exception */
        -:  431:
        -:  432:/**
        -:  433: * Debug assertion that specified value's type is one of ECMA-defined
        -:  434: * script-visible types, i.e.: undefined, null, boolean, number, string, object.
        -:  435: */
        -:  436:void
    #####:  437:ecma_check_value_type_is_spec_defined (ecma_value_t value) /**< ecma value */
        -:  438:{
    #####:  439:  JERRY_ASSERT (ecma_is_value_undefined (value) || ecma_is_value_null (value) || ecma_is_value_boolean (value)
        -:  440:                || ecma_is_value_number (value) || ecma_is_value_string (value) || ecma_is_value_bigint (value)
        -:  441:                || ecma_is_value_symbol (value) || ecma_is_value_object (value));
    #####:  442:} /* ecma_check_value_type_is_spec_defined */
        -:  443:
        -:  444:/**
        -:  445: * Checks if the given argument is an array or not.
        -:  446: *
        -:  447: * @return ECMA_VALUE_ERROR- if the operation fails
        -:  448: *         ECMA_VALUE_{TRUE/FALSE} - depends on whether 'arg' is an array object
        -:  449: */
        -:  450:ecma_value_t
    #####:  451:ecma_is_value_array (ecma_value_t arg) /**< argument */
        -:  452:{
    #####:  453:  if (!ecma_is_value_object (arg))
        -:  454:  {
    #####:  455:    return ECMA_VALUE_FALSE;
        -:  456:  }
        -:  457:
    #####:  458:  ecma_object_t *arg_obj_p = ecma_get_object_from_value (arg);
        -:  459:
    #####:  460:  if (ecma_get_object_base_type (arg_obj_p) == ECMA_OBJECT_BASE_TYPE_ARRAY)
        -:  461:  {
    #####:  462:    return ECMA_VALUE_TRUE;
        -:  463:  }
        -:  464:
        -:  465:#if JERRY_BUILTIN_PROXY
    #####:  466:  if (ECMA_OBJECT_IS_PROXY (arg_obj_p))
        -:  467:  {
    #####:  468:    ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) arg_obj_p;
        -:  469:
    #####:  470:    if (proxy_obj_p->handler == ECMA_VALUE_NULL)
        -:  471:    {
    #####:  472:      return ecma_raise_type_error (ECMA_ERR_PROXY_HANDLER_IS_NULL_FOR_ISARRAY_OPERATION);
        -:  473:    }
        -:  474:
    #####:  475:    return ecma_is_value_array (proxy_obj_p->target);
        -:  476:  }
        -:  477:#endif /* JERRY_BUILTIN_PROXY */
        -:  478:
    #####:  479:  return ECMA_VALUE_FALSE;
        -:  480:} /* ecma_is_value_array */
        -:  481:
        -:  482:/**
        -:  483: * Creates an ecma value from the given raw boolean.
        -:  484: *
        -:  485: * @return boolean ecma_value
        -:  486: */
        -:  487:extern inline ecma_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        1:  488:ecma_make_boolean_value (bool boolean_value) /**< raw bool value from which the ecma value will be created */
        -:  489:{
        1:  490:  return boolean_value ? ECMA_VALUE_TRUE : ECMA_VALUE_FALSE;
        -:  491:} /* ecma_make_boolean_value */
        -:  492:
        -:  493:/**
        -:  494: * Encode an integer number into an ecma-value without allocating memory
        -:  495: *
        -:  496: * Note:
        -:  497: *   The value must fit into the range of allowed ecma integer values
        -:  498: *
        -:  499: * @return ecma-value
        -:  500: */
        -:  501:extern inline ecma_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  502:ecma_make_integer_value (ecma_integer_value_t integer_value) /**< integer number to be encoded */
        -:  503:{
    #####:  504:  JERRY_ASSERT (ECMA_IS_INTEGER_NUMBER (integer_value));
        -:  505:
    #####:  506:  return (((ecma_value_t) integer_value) << ECMA_DIRECT_SHIFT) | ECMA_DIRECT_TYPE_INTEGER_VALUE;
        -:  507:} /* ecma_make_integer_value */
        -:  508:
        -:  509:/**
        -:  510: * Allocate and initialize a new float number without checks.
        -:  511: *
        -:  512: * @return ecma-value
        -:  513: */
        -:  514:static ecma_value_t
    #####:  515:ecma_create_float_number (ecma_number_t ecma_number) /**< value of the float number */
        -:  516:{
    #####:  517:  ecma_number_t *ecma_num_p = ecma_alloc_number ();
        -:  518:
    #####:  519:  *ecma_num_p = ecma_number;
        -:  520:
    #####:  521:  return ecma_pointer_to_ecma_value (ecma_num_p) | ECMA_TYPE_FLOAT;
        -:  522:} /* ecma_create_float_number */
        -:  523:
        -:  524:/**
        -:  525: * Encode float number without checks.
        -:  526: *
        -:  527: * @return ecma-value
        -:  528: */
        -:  529:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  530:ecma_make_float_value (ecma_number_t *ecma_num_p) /**< pointer to the float number */
        -:  531:{
    #####:  532:  return ecma_pointer_to_ecma_value (ecma_num_p) | ECMA_TYPE_FLOAT;
        -:  533:} /* ecma_make_float_value */
        -:  534:
        -:  535:/**
        -:  536: * Create a new NaN value.
        -:  537: *
        -:  538: * @return ecma-value
        -:  539: */
        -:  540:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE JERRY_ATTR_CONST
    #####:  541:ecma_make_nan_value (void)
        -:  542:{
    #####:  543:  return ecma_create_float_number (ecma_number_make_nan ());
        -:  544:} /* ecma_make_nan_value */
        -:  545:
        -:  546:/**
        -:  547: * Checks whether the passed number is +0.0
        -:  548: *
        -:  549: * @return true, if it is +0.0, false otherwise
        -:  550: */
        -:  551:static inline bool JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
        -:  552:ecma_is_number_equal_to_positive_zero (ecma_number_t ecma_number) /**< number */
        -:  553:{
    #####:  554:  return ecma_number_to_binary (ecma_number) == ECMA_NUMBER_BINARY_ZERO;
        -:  555:} /* ecma_is_number_equal_to_positive_zero */
        -:  556:
        -:  557:/**
        -:  558: * Encode a property length number into an ecma-value
        -:  559: *
        -:  560: * @return ecma-value
        -:  561: */
        -:  562:ecma_value_t
    #####:  563:ecma_make_length_value (ecma_length_t number) /**< number to be encoded */
        -:  564:{
    #####:  565:  if (number <= ECMA_INTEGER_NUMBER_MAX)
        -:  566:  {
    #####:  567:    return ecma_make_integer_value ((ecma_integer_value_t) number);
        -:  568:  }
        -:  569:
    #####:  570:  return ecma_create_float_number ((ecma_number_t) number);
        -:  571:} /* ecma_make_length_value */
        -:  572:
        -:  573:/**
        -:  574: * Encode a number into an ecma-value
        -:  575: *
        -:  576: * @return ecma-value
        -:  577: */
        -:  578:ecma_value_t
    #####:  579:ecma_make_number_value (ecma_number_t ecma_number) /**< number to be encoded */
        -:  580:{
    #####:  581:  ecma_integer_value_t integer_value = (ecma_integer_value_t) ecma_number;
        -:  582:
    #####:  583:  if ((ecma_number_t) integer_value == ecma_number
    #####:  584:      && ((integer_value == 0) ? ecma_is_number_equal_to_positive_zero (ecma_number)
    #####:  585:                               : ECMA_IS_INTEGER_NUMBER (integer_value)))
        -:  586:  {
    #####:  587:    return ecma_make_integer_value (integer_value);
        -:  588:  }
        -:  589:
    #####:  590:  return ecma_create_float_number (ecma_number);
        -:  591:} /* ecma_make_number_value */
        -:  592:
        -:  593:/**
        -:  594: * Encode an int32 number into an ecma-value
        -:  595: *
        -:  596: * @return ecma-value
        -:  597: */
        -:  598:ecma_value_t
    #####:  599:ecma_make_int32_value (int32_t int32_number) /**< int32 number to be encoded */
        -:  600:{
    #####:  601:  if (ECMA_IS_INTEGER_NUMBER (int32_number))
        -:  602:  {
    #####:  603:    return ecma_make_integer_value ((ecma_integer_value_t) int32_number);
        -:  604:  }
        -:  605:
    #####:  606:  return ecma_create_float_number ((ecma_number_t) int32_number);
        -:  607:} /* ecma_make_int32_value */
        -:  608:
        -:  609:/**
        -:  610: * Encode an unsigned int32 number into an ecma-value
        -:  611: *
        -:  612: * @return ecma-value
        -:  613: */
        -:  614:ecma_value_t
    #####:  615:ecma_make_uint32_value (uint32_t uint32_number) /**< uint32 number to be encoded */
        -:  616:{
    #####:  617:  if (uint32_number <= ECMA_INTEGER_NUMBER_MAX)
        -:  618:  {
    #####:  619:    return ecma_make_integer_value ((ecma_integer_value_t) uint32_number);
        -:  620:  }
        -:  621:
    #####:  622:  return ecma_create_float_number ((ecma_number_t) uint32_number);
        -:  623:} /* ecma_make_uint32_value */
        -:  624:
        -:  625:/**
        -:  626: * String value constructor
        -:  627: *
        -:  628: * @return ecma-value representation of the string argument
        -:  629: */
        -:  630:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
       10:  631:ecma_make_string_value (const ecma_string_t *ecma_string_p) /**< string to reference in value */
        -:  632:{
       10:  633:  JERRY_ASSERT (ecma_string_p != NULL);
        -:  634:#if JERRY_ESNEXT
       10:  635:  JERRY_ASSERT (!ecma_prop_name_is_symbol ((ecma_string_t *) ecma_string_p));
        -:  636:#endif /* JERRY_ESNEXT */
        -:  637:
       10:  638:  if ((((uintptr_t) ecma_string_p) & ECMA_VALUE_TYPE_MASK) != 0)
        -:  639:  {
    #####:  640:    return (ecma_value_t) (uintptr_t) ecma_string_p;
        -:  641:  }
        -:  642:
       10:  643:  return ecma_pointer_to_ecma_value (ecma_string_p) | ECMA_TYPE_STRING;
        -:  644:} /* ecma_make_string_value */
        -:  645:
        -:  646:#if JERRY_ESNEXT
        -:  647:/**
        -:  648: * Symbol value constructor
        -:  649: *
        -:  650: * @return ecma-value representation of the string argument
        -:  651: */
        -:  652:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  653:ecma_make_symbol_value (const ecma_string_t *ecma_symbol_p) /**< symbol to reference in value */
        -:  654:{
    #####:  655:  JERRY_ASSERT (ecma_symbol_p != NULL);
    #####:  656:  JERRY_ASSERT (ecma_prop_name_is_symbol ((ecma_string_t *) ecma_symbol_p));
        -:  657:
    #####:  658:  return ecma_pointer_to_ecma_value (ecma_symbol_p) | ECMA_TYPE_SYMBOL;
        -:  659:} /* ecma_make_symbol_value */
        -:  660:#endif /* JERRY_ESNEXT */
        -:  661:
        -:  662:/**
        -:  663: * Property-name value constructor
        -:  664: *
        -:  665: * @return ecma-value representation of a property name argument
        -:  666: */
        -:  667:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  668:ecma_make_prop_name_value (const ecma_string_t *ecma_prop_name_p) /**< property name to reference in value */
        -:  669:{
    #####:  670:  JERRY_ASSERT (ecma_prop_name_p != NULL);
        -:  671:
        -:  672:#if JERRY_ESNEXT
    #####:  673:  if (ecma_prop_name_is_symbol ((ecma_string_t *) ecma_prop_name_p))
        -:  674:  {
    #####:  675:    return ecma_make_symbol_value (ecma_prop_name_p);
        -:  676:  }
        -:  677:#endif /* JERRY_ESNEXT */
        -:  678:
    #####:  679:  return ecma_make_string_value (ecma_prop_name_p);
        -:  680:} /* ecma_make_prop_name_value */
        -:  681:
        -:  682:/**
        -:  683: * String value constructor
        -:  684: *
        -:  685: * @return ecma-value representation of the string argument
        -:  686: */
        -:  687:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        2:  688:ecma_make_magic_string_value (lit_magic_string_id_t id) /**< magic string id */
        -:  689:{
        3:  690:  return (ecma_value_t) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);
        -:  691:} /* ecma_make_magic_string_value */
        -:  692:
        -:  693:/**
        -:  694: * Object value constructor
        -:  695: *
        -:  696: * @return ecma-value representation of the object argument
        -:  697: */
        -:  698:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    35726:  699:ecma_make_object_value (const ecma_object_t *object_p) /**< object to reference in value */
        -:  700:{
    35726:  701:  JERRY_ASSERT (object_p != NULL);
        -:  702:
    35726:  703:  return ecma_pointer_to_ecma_value (object_p) | ECMA_TYPE_OBJECT;
        -:  704:} /* ecma_make_object_value */
        -:  705:
        -:  706:/**
        -:  707: * Error reference constructor
        -:  708: *
        -:  709: * @return ecma-value representation of the Error reference
        -:  710: */
        -:  711:extern inline ecma_value_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  712:ecma_make_extended_primitive_value (const ecma_extended_primitive_t *primitve_p, /**< extended primitve value */
        -:  713:                                    uint32_t type) /**< ecma type of extended primitve value */
        -:  714:{
    #####:  715:  JERRY_ASSERT (primitve_p != NULL);
        -:  716:#if JERRY_BUILTIN_BIGINT
    #####:  717:  JERRY_ASSERT (primitve_p != ECMA_BIGINT_POINTER_TO_ZERO);
        -:  718:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  719:  JERRY_ASSERT (type == ECMA_TYPE_BIGINT || type == ECMA_TYPE_ERROR);
        -:  720:
    #####:  721:  return ecma_pointer_to_ecma_value (primitve_p) | type;
        -:  722:} /* ecma_make_extended_primitive_value */
        -:  723:
        -:  724:/**
        -:  725: * Get integer value from an integer ecma value
        -:  726: *
        -:  727: * @return integer value
        -:  728: */
        -:  729:extern inline ecma_integer_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  730:ecma_get_integer_from_value (ecma_value_t value) /**< ecma value */
        -:  731:{
    #####:  732:  JERRY_ASSERT (ecma_is_value_integer_number (value));
        -:  733:
    #####:  734:  return ((ecma_integer_value_t) value) >> ECMA_DIRECT_SHIFT;
        -:  735:} /* ecma_get_integer_from_value */
        -:  736:
        -:  737:/**
        -:  738: * Get floating point value from an ecma value
        -:  739: *
        -:  740: * @return floating point value
        -:  741: */
        -:  742:extern inline ecma_number_t JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  743:ecma_get_float_from_value (ecma_value_t value) /**< ecma value */
        -:  744:{
    #####:  745:  JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);
        -:  746:
    #####:  747:  return *(ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
        -:  748:} /* ecma_get_float_from_value */
        -:  749:
        -:  750:/**
        -:  751: * Get floating point value pointer from an ecma value
        -:  752: *
        -:  753: * @return floating point value
        -:  754: */
        -:  755:extern inline ecma_number_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  756:ecma_get_pointer_from_float_value (ecma_value_t value) /**< ecma value */
        -:  757:{
    #####:  758:  JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_FLOAT);
        -:  759:
    #####:  760:  return (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
        -:  761:} /* ecma_get_pointer_from_float_value */
        -:  762:
        -:  763:/**
        -:  764: * Get floating point value from an ecma value
        -:  765: *
        -:  766: * @return floating point value
        -:  767: */
        -:  768:ecma_number_t JERRY_ATTR_PURE
    #####:  769:ecma_get_number_from_value (ecma_value_t value) /**< ecma value */
        -:  770:{
    #####:  771:  if (ecma_is_value_integer_number (value))
        -:  772:  {
    #####:  773:    return (ecma_number_t) ecma_get_integer_from_value (value);
        -:  774:  }
        -:  775:
    #####:  776:  return ecma_get_float_from_value (value);
        -:  777:} /* ecma_get_number_from_value */
        -:  778:
        -:  779:/**
        -:  780: * Get pointer to ecma-string from ecma value
        -:  781: *
        -:  782: * @return the string pointer
        -:  783: */
        -:  784:extern inline ecma_string_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    11905:  785:ecma_get_string_from_value (ecma_value_t value) /**< ecma value */
        -:  786:{
    11905:  787:  JERRY_ASSERT (ecma_is_value_string (value));
        -:  788:
    11905:  789:  if ((value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_DIRECT_STRING)
        -:  790:  {
    #####:  791:    return (ecma_string_t *) (uintptr_t) value;
        -:  792:  }
        -:  793:
    11905:  794:  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
        -:  795:} /* ecma_get_string_from_value */
        -:  796:
        -:  797:#if JERRY_ESNEXT
        -:  798:/**
        -:  799: * Get pointer to ecma-string from ecma value
        -:  800: *
        -:  801: * @return the string pointer
        -:  802: */
        -:  803:extern inline ecma_string_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  804:ecma_get_symbol_from_value (ecma_value_t value) /**< ecma value */
        -:  805:{
    #####:  806:  JERRY_ASSERT (ecma_is_value_symbol (value));
        -:  807:
    #####:  808:  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
        -:  809:} /* ecma_get_symbol_from_value */
        -:  810:#endif /* JERRY_ESNEXT */
        -:  811:
        -:  812:/**
        -:  813: * Get pointer to a property name from ecma value
        -:  814: *
        -:  815: * @return the string pointer
        -:  816: */
        -:  817:extern inline ecma_string_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
        5:  818:ecma_get_prop_name_from_value (ecma_value_t value) /**< ecma value */
        -:  819:{
        5:  820:  JERRY_ASSERT (ecma_is_value_prop_name (value));
        -:  821:
        5:  822:  if ((value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_DIRECT_STRING)
        -:  823:  {
    #####:  824:    return (ecma_string_t *) (uintptr_t) value;
        -:  825:  }
        -:  826:
        5:  827:  return (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
        -:  828:} /* ecma_get_prop_name_from_value */
        -:  829:
        -:  830:/**
        -:  831: * Get pointer to ecma-object from ecma value
        -:  832: *
        -:  833: * @return the pointer
        -:  834: */
        -:  835:extern inline ecma_object_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    35891:  836:ecma_get_object_from_value (ecma_value_t value) /**< ecma value */
        -:  837:{
    59705:  838:  JERRY_ASSERT (ecma_is_value_object (value));
        -:  839:
    59705:  840:  return (ecma_object_t *) ecma_get_pointer_from_ecma_value (value);
        -:  841:} /* ecma_get_object_from_value */
        -:  842:
        -:  843:/**
        -:  844: * Get pointer to error reference from ecma value
        -:  845: *
        -:  846: * @return the pointer
        -:  847: */
        -:  848:extern inline ecma_extended_primitive_t *JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  849:ecma_get_extended_primitive_from_value (ecma_value_t value) /**< ecma value */
        -:  850:{
        -:  851:#if JERRY_BUILTIN_BIGINT
    #####:  852:  JERRY_ASSERT (value != ECMA_BIGINT_ZERO);
        -:  853:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  854:  JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_BIGINT
        -:  855:                || ecma_get_value_type_field (value) == ECMA_TYPE_ERROR);
        -:  856:
    #####:  857:  return (ecma_extended_primitive_t *) ecma_get_pointer_from_ecma_value (value);
        -:  858:} /* ecma_get_extended_primitive_from_value */
        -:  859:
        -:  860:/**
        -:  861: * Invert a boolean value
        -:  862: *
        -:  863: * @return ecma value
        -:  864: */
        -:  865:extern inline ecma_value_t JERRY_ATTR_CONST JERRY_ATTR_ALWAYS_INLINE
    #####:  866:ecma_invert_boolean_value (ecma_value_t value) /**< ecma value */
        -:  867:{
    #####:  868:  JERRY_ASSERT (ecma_is_value_boolean (value));
        -:  869:
    #####:  870:  return (value ^ (1 << ECMA_DIRECT_SHIFT));
        -:  871:} /* ecma_invert_boolean_value */
        -:  872:
        -:  873:/**
        -:  874: * Copy ecma value.
        -:  875: *
        -:  876: * @return copy of the given value
        -:  877: */
        -:  878:ecma_value_t
    23804:  879:ecma_copy_value (ecma_value_t value) /**< value description */
        -:  880:{
    23804:  881:  switch (ecma_get_value_type_field (value))
        -:  882:  {
    #####:  883:    case ECMA_TYPE_FLOAT:
        -:  884:    {
    #####:  885:      ecma_number_t *num_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
    #####:  886:      ecma_number_t *new_num_p = ecma_alloc_number ();
        -:  887:
    #####:  888:      *new_num_p = *num_p;
        -:  889:
    #####:  890:      return ecma_make_float_value (new_num_p);
        -:  891:    }
        -:  892:#if JERRY_ESNEXT
    #####:  893:    case ECMA_TYPE_SYMBOL:
        -:  894:#endif /* JERRY_ESNEXT */
    #####:  895:    case ECMA_TYPE_STRING:
        -:  896:    {
    #####:  897:      ecma_string_t *string_p = (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
    #####:  898:      ecma_ref_ecma_string_non_direct (string_p);
    #####:  899:      return value;
        -:  900:    }
        -:  901:#if JERRY_BUILTIN_BIGINT
    #####:  902:    case ECMA_TYPE_BIGINT:
        -:  903:    {
    #####:  904:      if (value != ECMA_BIGINT_ZERO)
        -:  905:      {
    #####:  906:        ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
        -:  907:      }
    #####:  908:      return value;
        -:  909:    }
        -:  910:#endif /* JERRY_BUILTIN_BIGINT */
    23803:  911:    case ECMA_TYPE_OBJECT:
        -:  912:    {
    23803:  913:      ecma_ref_object_inline (ecma_get_object_from_value (value));
    23803:  914:      return value;
        -:  915:    }
        1:  916:    default:
        -:  917:    {
        1:  918:      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT
        -:  919:                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);
        -:  920:
        1:  921:      return value;
        -:  922:    }
        -:  923:  }
        -:  924:} /* ecma_copy_value */
        -:  925:
        -:  926:/**
        -:  927: * Copy ecma value.
        -:  928: *
        -:  929: * Note:
        -:  930: *   this function is similar to ecma_copy_value, but it is
        -:  931: *   faster for direct values since no function call is performed.
        -:  932: *   It also increases the binary size so it is recommended for
        -:  933: *   critical code paths only.
        -:  934: *
        -:  935: * @return copy of the given value
        -:  936: */
        -:  937:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    23803:  938:ecma_fast_copy_value (ecma_value_t value) /**< value description */
        -:  939:{
    23803:  940:  return (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT) ? value : ecma_copy_value (value);
        -:  941:} /* ecma_fast_copy_value */
        -:  942:
        -:  943:/**
        -:  944: * Copy the ecma value if not an object
        -:  945: *
        -:  946: * @return copy of the given value
        -:  947: */
        -:  948:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
        6:  949:ecma_copy_value_if_not_object (ecma_value_t value) /**< value description */
        -:  950:{
        7:  951:  if (!ecma_is_value_object (value))
        -:  952:  {
        1:  953:    return ecma_copy_value (value);
        -:  954:  }
        -:  955:
        6:  956:  return value;
        -:  957:} /* ecma_copy_value_if_not_object */
        -:  958:
        -:  959:/**
        -:  960: * Increase reference counter of a value if it is an object.
        -:  961: */
        -:  962:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  963:ecma_ref_if_object (ecma_value_t value) /**< value description */
        -:  964:{
    #####:  965:  if (ecma_is_value_object (value))
        -:  966:  {
    #####:  967:    ecma_ref_object (ecma_get_object_from_value (value));
        -:  968:  }
    #####:  969:} /* ecma_ref_if_object */
        -:  970:
        -:  971:/**
        -:  972: * Decrease reference counter of a value if it is an object.
        -:  973: */
        -:  974:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  975:ecma_deref_if_object (ecma_value_t value) /**< value description */
        -:  976:{
    #####:  977:  if (ecma_is_value_object (value))
        -:  978:  {
    #####:  979:    ecma_deref_object (ecma_get_object_from_value (value));
        -:  980:  }
    #####:  981:} /* ecma_deref_if_object */
        -:  982:
        -:  983:/**
        -:  984: * Assign a new value to an ecma-value
        -:  985: *
        -:  986: * Note:
        -:  987: *      value previously stored in the property is freed
        -:  988: */
        -:  989:void
        1:  990:ecma_value_assign_value (ecma_value_t *value_p, /**< [in, out] ecma value */
        -:  991:                         ecma_value_t ecma_value) /**< value to assign */
        -:  992:{
        -:  993:  JERRY_STATIC_ASSERT (ECMA_TYPE_DIRECT == 0, ecma_type_direct_must_be_zero_for_the_next_check);
        -:  994:
        1:  995:  if (*value_p == ecma_value)
        -:  996:  {
    #####:  997:    return;
        -:  998:  }
        -:  999:
        2: 1000:  if (ecma_get_value_type_field (ecma_value || *value_p) == ECMA_TYPE_DIRECT)
        -: 1001:  {
    #####: 1002:    *value_p = ecma_value;
        -: 1003:  }
        1: 1004:  else if (ecma_is_value_float_number (ecma_value) && ecma_is_value_float_number (*value_p))
    #####: 1005:  {
    #####: 1006:    const ecma_number_t *num_src_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (ecma_value);
    #####: 1007:    ecma_number_t *num_dst_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (*value_p);
        -: 1008:
    #####: 1009:    *num_dst_p = *num_src_p;
        -: 1010:  }
        -: 1011:  else
        -: 1012:  {
        1: 1013:    ecma_free_value_if_not_object (*value_p);
        1: 1014:    *value_p = ecma_copy_value_if_not_object (ecma_value);
        -: 1015:  }
        -: 1016:} /* ecma_value_assign_value */
        -: 1017:
        -: 1018:/**
        -: 1019: * Update the value of a float number to a new value
        -: 1020: *
        -: 1021: * Note:
        -: 1022: *   The original value is destroyed.
        -: 1023: *
        -: 1024: * @return updated ecma value
        -: 1025: */
        -: 1026:ecma_value_t
    #####: 1027:ecma_update_float_number (ecma_value_t float_value, /**< original float value */
        -: 1028:                          ecma_number_t new_number) /**< updated number value */
        -: 1029:{
    #####: 1030:  JERRY_ASSERT (ecma_is_value_float_number (float_value));
        -: 1031:
    #####: 1032:  ecma_integer_value_t integer_number = (ecma_integer_value_t) new_number;
    #####: 1033:  ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (float_value);
        -: 1034:
    #####: 1035:  if ((ecma_number_t) integer_number == new_number
    #####: 1036:      && ((integer_number == 0) ? ecma_is_number_equal_to_positive_zero (new_number)
    #####: 1037:                                : ECMA_IS_INTEGER_NUMBER (integer_number)))
        -: 1038:  {
    #####: 1039:    ecma_dealloc_number (number_p);
    #####: 1040:    return ecma_make_integer_value (integer_number);
        -: 1041:  }
        -: 1042:
    #####: 1043:  *number_p = new_number;
    #####: 1044:  return float_value;
        -: 1045:} /* ecma_update_float_number */
        -: 1046:
        -: 1047:/**
        -: 1048: * Assign a float number to an ecma-value
        -: 1049: *
        -: 1050: * Note:
        -: 1051: *      value previously stored in the property is freed
        -: 1052: */
        -: 1053:static void
    #####: 1054:ecma_value_assign_float_number (ecma_value_t *value_p, /**< [in, out] ecma value */
        -: 1055:                                ecma_number_t ecma_number) /**< number to assign */
        -: 1056:{
    #####: 1057:  if (ecma_is_value_float_number (*value_p))
        -: 1058:  {
    #####: 1059:    ecma_number_t *num_dst_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (*value_p);
        -: 1060:
    #####: 1061:    *num_dst_p = ecma_number;
    #####: 1062:    return;
        -: 1063:  }
        -: 1064:
    #####: 1065:  if (ecma_get_value_type_field (*value_p) != ECMA_TYPE_DIRECT
    #####: 1066:      && ecma_get_value_type_field (*value_p) != ECMA_TYPE_OBJECT)
        -: 1067:  {
    #####: 1068:    ecma_free_value (*value_p);
        -: 1069:  }
        -: 1070:
    #####: 1071:  *value_p = ecma_create_float_number (ecma_number);
        -: 1072:} /* ecma_value_assign_float_number */
        -: 1073:
        -: 1074:/**
        -: 1075: * Assign a number to an ecma-value
        -: 1076: *
        -: 1077: * Note:
        -: 1078: *      value previously stored in the property is freed
        -: 1079: */
        -: 1080:void
    #####: 1081:ecma_value_assign_number (ecma_value_t *value_p, /**< [in, out] ecma value */
        -: 1082:                          ecma_number_t ecma_number) /**< number to assign */
        -: 1083:{
    #####: 1084:  ecma_integer_value_t integer_value = (ecma_integer_value_t) ecma_number;
        -: 1085:
    #####: 1086:  if ((ecma_number_t) integer_value == ecma_number
    #####: 1087:      && ((integer_value == 0) ? ecma_is_number_equal_to_positive_zero (ecma_number)
    #####: 1088:                               : ECMA_IS_INTEGER_NUMBER (integer_value)))
        -: 1089:  {
    #####: 1090:    if (ecma_get_value_type_field (*value_p) != ECMA_TYPE_DIRECT
    #####: 1091:        && ecma_get_value_type_field (*value_p) != ECMA_TYPE_OBJECT)
        -: 1092:    {
    #####: 1093:      ecma_free_value (*value_p);
        -: 1094:    }
    #####: 1095:    *value_p = ecma_make_integer_value (integer_value);
    #####: 1096:    return;
        -: 1097:  }
        -: 1098:
    #####: 1099:  ecma_value_assign_float_number (value_p, ecma_number);
        -: 1100:} /* ecma_value_assign_number */
        -: 1101:
        -: 1102:/**
        -: 1103: * Free the ecma value
        -: 1104: */
        -: 1105:void
       22: 1106:ecma_free_value (ecma_value_t value) /**< value description */
        -: 1107:{
       22: 1108:  switch (ecma_get_value_type_field (value))
        -: 1109:  {
    #####: 1110:    case ECMA_TYPE_FLOAT:
        -: 1111:    {
    #####: 1112:      ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
    #####: 1113:      ecma_dealloc_number (number_p);
    #####: 1114:      break;
        -: 1115:    }
        -: 1116:#if JERRY_ESNEXT
        6: 1117:    case ECMA_TYPE_SYMBOL:
        -: 1118:#endif /* JERRY_ESNEXT */
    #####: 1119:    case ECMA_TYPE_STRING:
        -: 1120:    {
        6: 1121:      ecma_string_t *string_p = (ecma_string_t *) ecma_get_pointer_from_ecma_value (value);
        6: 1122:      ecma_deref_ecma_string_non_direct (string_p);
        6: 1123:      break;
        -: 1124:    }
       10: 1125:    case ECMA_TYPE_OBJECT:
        -: 1126:    {
       10: 1127:      ecma_deref_object (ecma_get_object_from_value (value));
       10: 1128:      break;
        -: 1129:    }
        -: 1130:#if JERRY_BUILTIN_BIGINT
    #####: 1131:    case ECMA_TYPE_BIGINT:
        -: 1132:    {
    #####: 1133:      if (value != ECMA_BIGINT_ZERO)
        -: 1134:      {
    #####: 1135:        ecma_deref_bigint (ecma_get_extended_primitive_from_value (value));
        -: 1136:      }
        -: 1137:
    #####: 1138:      break;
        -: 1139:    }
        -: 1140:#endif /* JERRY_BUILTIN_BIGINT */
        6: 1141:    default:
        -: 1142:    {
        6: 1143:      JERRY_ASSERT (ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT
        -: 1144:                    || ecma_get_value_type_field (value) == ECMA_TYPE_DIRECT_STRING);
        -: 1145:
        -: 1146:      /* no memory is allocated */
        6: 1147:      break;
        -: 1148:    }
        -: 1149:  }
       22: 1150:} /* ecma_free_value */
        -: 1151:
        -: 1152:/**
        -: 1153: * Free the ecma value
        -: 1154: *
        -: 1155: * Note:
        -: 1156: *   this function is similar to ecma_free_value, but it is
        -: 1157: *   faster for direct values since no function call is performed.
        -: 1158: *   It also increases the binary size so it is recommended for
        -: 1159: *   critical code paths only.
        -: 1160: */
        -: 1161:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1162:ecma_fast_free_value (ecma_value_t value) /**< value description */
        -: 1163:{
    #####: 1164:  if (ecma_get_value_type_field (value) != ECMA_TYPE_DIRECT)
        -: 1165:  {
    #####: 1166:    ecma_free_value (value);
        -: 1167:  }
    #####: 1168:} /* ecma_fast_free_value */
        -: 1169:
        -: 1170:/**
        -: 1171: * Free the ecma value if not an object
        -: 1172: */
        -: 1173:void
        1: 1174:ecma_free_value_if_not_object (ecma_value_t value) /**< value description */
        -: 1175:{
        1: 1176:  if (ecma_get_value_type_field (value) != ECMA_TYPE_OBJECT)
        -: 1177:  {
        1: 1178:    ecma_free_value (value);
        -: 1179:  }
        1: 1180:} /* ecma_free_value_if_not_object */
        -: 1181:
        -: 1182:/**
        -: 1183: * Free an ecma-value object
        -: 1184: */
        -: 1185:extern inline void JERRY_ATTR_ALWAYS_INLINE
        1: 1186:ecma_free_object (ecma_value_t value) /**< value description */
        -: 1187:{
        1: 1188:  ecma_deref_object (ecma_get_object_from_value (value));
        1: 1189:} /* ecma_free_object */
        -: 1190:
        -: 1191:/**
        -: 1192: * Free an ecma-value number
        -: 1193: */
        -: 1194:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1195:ecma_free_number (ecma_value_t value) /**< value description */
        -: 1196:{
    #####: 1197:  JERRY_ASSERT (ecma_is_value_number (value));
        -: 1198:
    #####: 1199:  if (ecma_is_value_float_number (value))
        -: 1200:  {
    #####: 1201:    ecma_number_t *number_p = (ecma_number_t *) ecma_get_pointer_from_ecma_value (value);
    #####: 1202:    ecma_dealloc_number (number_p);
        -: 1203:  }
    #####: 1204:} /* ecma_free_number */
        -: 1205:
        -: 1206:/**
        -: 1207: * Get the literal id associated with the given ecma_value type.
        -: 1208: * This operation is equivalent to the JavaScript 'typeof' operator.
        -: 1209: *
        -: 1210: * @returns one of the following value:
        -: 1211: *          - LIT_MAGIC_STRING_UNDEFINED
        -: 1212: *          - LIT_MAGIC_STRING_OBJECT
        -: 1213: *          - LIT_MAGIC_STRING_BOOLEAN
        -: 1214: *          - LIT_MAGIC_STRING_NUMBER
        -: 1215: *          - LIT_MAGIC_STRING_STRING
        -: 1216: *          - LIT_MAGIC_STRING_FUNCTION
        -: 1217: */
        -: 1218:lit_magic_string_id_t
    #####: 1219:ecma_get_typeof_lit_id (ecma_value_t value) /**< input ecma value */
        -: 1220:{
    #####: 1221:  lit_magic_string_id_t ret_value = LIT_MAGIC_STRING__EMPTY;
        -: 1222:
    #####: 1223:  if (ecma_is_value_undefined (value))
        -: 1224:  {
    #####: 1225:    ret_value = LIT_MAGIC_STRING_UNDEFINED;
        -: 1226:  }
    #####: 1227:  else if (ecma_is_value_null (value))
        -: 1228:  {
    #####: 1229:    ret_value = LIT_MAGIC_STRING_OBJECT;
        -: 1230:  }
    #####: 1231:  else if (ecma_is_value_boolean (value))
        -: 1232:  {
    #####: 1233:    ret_value = LIT_MAGIC_STRING_BOOLEAN;
        -: 1234:  }
    #####: 1235:  else if (ecma_is_value_number (value))
        -: 1236:  {
    #####: 1237:    ret_value = LIT_MAGIC_STRING_NUMBER;
        -: 1238:  }
    #####: 1239:  else if (ecma_is_value_string (value))
        -: 1240:  {
    #####: 1241:    ret_value = LIT_MAGIC_STRING_STRING;
        -: 1242:  }
        -: 1243:#if JERRY_ESNEXT
    #####: 1244:  else if (ecma_is_value_symbol (value))
        -: 1245:  {
    #####: 1246:    ret_value = LIT_MAGIC_STRING_SYMBOL;
        -: 1247:  }
        -: 1248:#endif /* JERRY_ESNEXT */
        -: 1249:#if JERRY_BUILTIN_BIGINT
    #####: 1250:  else if (ecma_is_value_bigint (value))
        -: 1251:  {
    #####: 1252:    ret_value = LIT_MAGIC_STRING_BIGINT;
        -: 1253:  }
        -: 1254:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1255:  else
        -: 1256:  {
    #####: 1257:    JERRY_ASSERT (ecma_is_value_object (value));
        -: 1258:
    #####: 1259:    ret_value = ecma_op_is_callable (value) ? LIT_MAGIC_STRING_FUNCTION : LIT_MAGIC_STRING_OBJECT;
        -: 1260:  }
        -: 1261:
    #####: 1262:  JERRY_ASSERT (ret_value != LIT_MAGIC_STRING__EMPTY);
        -: 1263:
    #####: 1264:  return ret_value;
        -: 1265:} /* ecma_get_typeof_lit_id */
        -: 1266:
        -: 1267:/**
        -: 1268: * @}
        -: 1269: * @}
        -: 1270: */
