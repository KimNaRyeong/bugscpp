        -:    0:Source:/home/workspace/docs/03.API-EXAMPLE.md
        -:    0:Programs:297
        -:    1:JerryScript Engine can be embedded into any application, providing the way to run JavaScript in a large range of environments - from desktops to low-memory microcontrollers.
        -:    2:
        -:    3:This guide is intended to introduce you to JerryScript embedding API and to create a minimal JavaScript shell.
        -:    4:The examples are not using all API methods please also check out the API reference document which contains additional examples.
        -:    5:
        -:    6:
        -:    7:## Before trying out the examples: Get and build JerryScript library
        -:    8:
        -:    9:Before getting started using the JerryScript library it should be cloned and built for a target os/device.
        -:   10:
        -:   11:There are quite a few configuration options but for these examples the JerryScript is built
        -:   12:**with default configuration** and installed to a user directory on a Linux system.
        -:   13:This is done by the following commands:
        -:   14:
        -:   15:```sh
        -:   16:$ mkdir jerry
        -:   17:$ cd jerry
        -:   18:$ git clone https://github.com/jerryscript-project/jerryscript.git
        -:   19:$ jerryscript/tools/build.py --builddir=$(pwd)/example_build --cmake-param="-DCMAKE_INSTALL_PREFIX=$(pwd)/example_install/"
        -:   20:$ make -C $(pwd)/example_build install
        -:   21:```
        -:   22:
        -:   23:With this the JerryScript library is installed into the `$(pwd)/example_install/{include,lib}` directories.
        -:   24:
        -:   25:In this guide we will use `pkg-config` to ease the usage of headers and libraries.
        -:   26:In order to do so, the following export is required (executed from the jerry directory):
        -:   27:
        -:   28:```sh
        -:   29:$ export PKG_CONFIG_PATH=$(pwd)/example_install/lib/pkgconfig/
        -:   30:```
        -:   31:
        -:   32:Test if the `pkg-config` works for JerryScript:
        -:   33:
        -:   34:```sh
        -:   35:$ pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-ext libjerry-math
        -:   36:```
        -:   37:
        -:   38:## Example 2. Split engine initialization and script execution.
        -:   39:
        -:   40:In this example the engine is initialized directly with the `jerry_init` method
        -:   41:and cleaned up with the `jerry_cleanup` method. The example JavaScript code
        -:   42:is directly parsed and executed via the `jerry_eval` method. Each `jerry_value_t`
        -:   43:returned by the API methods is freed with the `jerry_value_free` method.
        -:   44:
        -:   45:To make sure that the code parsing and execution was ok, the `jerry_value_is_exception`
        -:   46:method is used to check for any errors.
        -:   47:
        -:   48:Use the following code for the `api-example-2.c` file:
        -:   49:
        -:   50:[doctest]: # ()
        -:   51:
        -:   52:```c
        -:   53:#include "jerryscript.h"
        -:   54:
        -:   55:int
    #####:   56:main (void)
        -:   57:{
    #####:   58:  const jerry_char_t script[] = "var str = 'Hello, World!';";
    #####:   59:  const jerry_length_t script_size = sizeof (script) - 1;
        -:   60:  /* Note: sizeof can be used here only because the compiler knows the static character arrays's size.
        -:   61:   * If this is not the case, strlen should be used instead.
        -:   62:   */
        -:   63:
        -:   64:  /* Initialize engine */
    #####:   65:  jerry_init (JERRY_INIT_EMPTY);
        -:   66:
        -:   67:  /* Run the demo script with 'eval' */
    #####:   68:  jerry_value_t eval_ret = jerry_eval (script,
        -:   69:                                       script_size,
        -:   70:                                       JERRY_PARSE_NO_OPTS);
        -:   71:
        -:   72:  /* Check if there was any error (syntax or runtime) */
    #####:   73:  bool run_ok = !jerry_value_is_exception (eval_ret);
        -:   74:
        -:   75:  /* Parsed source code must be freed */
    #####:   76:  jerry_value_free (eval_ret);
        -:   77:
        -:   78:  /* Cleanup engine */
    #####:   79:  jerry_cleanup ();
        -:   80:
        -:   81:  return (run_ok ? 0 : 1);
        -:   82:}
        -:   83:```
        -:   84:
        -:   85:To compile it one can use the following command:
        -:   86:
        -:   87:```sh
        -:   88:$ gcc api-example-2.c -o api-example-2 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:   89:```
        -:   90:
        -:   91:If everything is correct the application returns with a zero exit code:
        -:   92:
        -:   93:```
        -:   94:$ ./api-example-2
        -:   95:$ echo $?
        -:   96:```
        -:   97:
        -:   98:## Example 3. Split JavaScript parsing and script execution
        -:   99:
        -:  100:In this example the `jerry_eval` is replaced with a more common API calls:
        -:  101:
        -:  102:- script code setup - `jerry_parse`.
        -:  103:- script execution - `jerry_run`.
        -:  104:
        -:  105:The `api-example-3.c` file should contain the following code:
        -:  106:
        -:  107:[doctest]: # ()
        -:  108:
        -:  109:```c
        -:  110:#include "jerryscript.h"
        -:  111:
        -:  112:int
    #####:  113:main (void)
        -:  114:{
    #####:  115:  bool run_ok = false;
        -:  116:
    #####:  117:  const jerry_char_t script[] = "var str = 'Hello, World!';";
        -:  118:
        -:  119:  /* Initialize engine */
    #####:  120:  jerry_init (JERRY_INIT_EMPTY);
        -:  121:
        -:  122:  /* Setup Global scope code */
    #####:  123:  jerry_value_t parsed_code = jerry_parse (script, sizeof (script) - 1, NULL);
        -:  124:
        -:  125:  /* Check if there is any JS code parse error */
    #####:  126:  if (!jerry_value_is_exception (parsed_code))
        -:  127:  {
        -:  128:    /* Execute the parsed source code in the Global scope */
    #####:  129:    jerry_value_t ret_value = jerry_run (parsed_code);
        -:  130:
        -:  131:    /* Check the execution return value if there is any error */
    #####:  132:    run_ok = !jerry_value_is_exception (ret_value);
        -:  133:
        -:  134:    /* Returned value must be freed */
    #####:  135:    jerry_value_free (ret_value);
        -:  136:  }
        -:  137:
        -:  138:  /* Parsed source code must be freed */
    #####:  139:  jerry_value_free (parsed_code);
        -:  140:
        -:  141:  /* Cleanup engine */
    #####:  142:  jerry_cleanup ();
        -:  143:
    #####:  144:  return (run_ok ? 0 : 1);
        -:  145:}
        -:  146:```
        -:  147:
        -:  148:To compile it one can use the following command:
        -:  149:
        -:  150:```sh
        -:  151:$ gcc api-example-3.c -o api-example-3 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:  152:```
        -:  153:
        -:  154:If everything is correct the application returns with a zero exit code:
        -:  155:
        -:  156:```
        -:  157:$ ./api-example-3
        -:  158:$ echo $?
        -:  159:```
        -:  160:
        -:  161:## Example 4. Adding a C method for JavaScript
        -:  162:
        -:  163:The previous examples were not that eye catching as there were no visual output by the JavaScript code
        -:  164:and C program.
        -:  165:
        -:  166:In this example a very simple "print" method is added which prints out a static string.
        -:  167:This method will be implemented in C and will be called from the JavaScript code.
        -:  168:For this a few extra API methods are required:
        -:  169:
        -:  170:- `jerry_current_realm`
        -:  171:- `jerry_string_sz`
        -:  172:- `jerry_object_set`
        -:  173:- `jerry_function_external`
        -:  174:
        -:  175:The `api-example-4.c` file should contain the following code:
        -:  176:
        -:  177:[doctest]: # ()
        -:  178:
        -:  179:```c
        -:  180:#include <stdio.h>
        -:  181:#include "jerryscript.h"
        -:  182:
        -:  183:static jerry_value_t
    #####:  184:print_handler (const jerry_call_info_t *call_info_p,
        -:  185:               const jerry_value_t arguments[],
        -:  186:               const jerry_length_t argument_count)
        -:  187:{
        -:  188:  /* No arguments are used in this example */
        -:  189:  /* Print out a static string */
    #####:  190:  printf ("Print handler was called\n");
        -:  191:
        -:  192:  /* Return an "undefined" value to the JavaScript engine */
    #####:  193:  return jerry_undefined ();
        -:  194:}
        -:  195:
        -:  196:int
    #####:  197:main (void)
        -:  198:{
    #####:  199:  const jerry_char_t script[] = "print ();";
    #####:  200:  const jerry_length_t script_size = sizeof (script) - 1;
        -:  201:
        -:  202:  /* Initialize engine */
    #####:  203:  jerry_init (JERRY_INIT_EMPTY);
        -:  204:
        -:  205:  /* Add the "print" method for the JavaScript global object */
        -:  206:  {
        -:  207:    /* Get the "global" object */
    #####:  208:    jerry_value_t global_object = jerry_current_realm ();
        -:  209:    /* Create a "print" JS string */
    #####:  210:    jerry_value_t property_name_print = jerry_string_sz ("print");
        -:  211:    /* Create a function from a native C method (this function will be called from JS) */
    #####:  212:    jerry_value_t property_value_func = jerry_function_external (print_handler);
        -:  213:    /* Add the "print" property with the function value to the "global" object */
    #####:  214:    jerry_value_t set_result = jerry_object_set (global_object, property_name_print, property_value_func);
        -:  215:
        -:  216:    /* Check if there was no error when adding the property (in this case it should never happen) */
    #####:  217:    if (jerry_value_is_exception (set_result)) {
        -:  218:      printf ("Failed to add the 'print' property\n");
        -:  219:    }
        -:  220:
        -:  221:    /* Release all jerry_value_t-s */
    #####:  222:    jerry_value_free (set_result);
    #####:  223:    jerry_value_free (property_value_func);
    #####:  224:    jerry_value_free (property_name_print);
    #####:  225:    jerry_value_free (global_object);
        -:  226:  }
        -:  227:
        -:  228:  /* Setup Global scope code */
    #####:  229:  jerry_value_t parsed_code = jerry_parse (script, script_size, NULL);
        -:  230:
    #####:  231:  if (!jerry_value_is_exception (parsed_code))
        -:  232:  {
        -:  233:    /* Execute the parsed source code in the Global scope */
    #####:  234:    jerry_value_t ret_value = jerry_run (parsed_code);
        -:  235:
        -:  236:    /* Returned value must be freed */
    #####:  237:    jerry_value_free (ret_value);
        -:  238:  }
        -:  239:
        -:  240:  /* Parsed source code must be freed */
    #####:  241:  jerry_value_free (parsed_code);
        -:  242:
        -:  243:  /* Cleanup engine */
    #####:  244:  jerry_cleanup ();
        -:  245:
        -:  246:  return 0;
        -:  247:}
        -:  248:```
        -:  249:
        -:  250:
        -:  251:To compile it one can use the following command:
        -:  252:
        -:  253:```sh
        -:  254:$ gcc api-example-4.c -o api-example-4 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:  255:```
        -:  256:
        -:  257:If everything is correct the application should print out the message present in the `print_handler` method:
        -:  258:
        -:  259:```
        -:  260:$ ./api-example-4
        -:  261:```
        -:  262:
        -:  263:## Example 5. Passing and processing arguments for native C code
        -:  264:
        -:  265:In the previous example the `print_handler` simply wrote a static string to the standard output.
        -:  266:However in most cases this is not useful, ideally the method's argument(s) should be printed.
        -:  267:
        -:  268:In this example the `print_handler` is extended to convert the first
        -:  269:argument (which probably comes from a JavaScript source) to a JS string and prints it out to the standard output.
        -:  270:
        -:  271:New API methods used:
        -:  272:
        -:  273:- `jerry_value_to_string`
        -:  274:- `jerry_string_to_buffer`
        -:  275:
        -:  276:The `api-example-5.c` file should contain the following code:
        -:  277:
        -:  278:[doctest]: # ()
        -:  279:
        -:  280:```c
        -:  281:#include <stdio.h>
        -:  282:#include "jerryscript.h"
        -:  283:
        -:  284:static jerry_value_t
    #####:  285:print_handler (const jerry_call_info_t *call_info_p,
        -:  286:               const jerry_value_t arguments[],
        -:  287:               const jerry_length_t arguments_count)
        -:  288:{
        -:  289:  /* There should be at least one argument */
    #####:  290:  if (arguments_count > 0)
        -:  291:  {
        -:  292:    /* Convert the first argument to a string (JS "toString" operation) */
    #####:  293:    jerry_value_t string_value = jerry_value_to_string (arguments[0]);
        -:  294:
        -:  295:    /* A naive allocation of buffer for the string */
        -:  296:    jerry_char_t buffer[256];
        -:  297:
        -:  298:    /* Copy the whole string to the buffer, without a null termination character,
        -:  299:     * Please note that if the string does not fit into the buffer nothing will be copied.
        -:  300:     * More details on the API reference page
        -:  301:     */
    #####:  302:    jerry_size_t copied_bytes = jerry_string_to_buffer (string_value, JERRY_ENCODING_UTF8, buffer, sizeof (buffer) - 1);
    #####:  303:    buffer[copied_bytes] = '\0';
        -:  304:
        -:  305:    /* Release the "toString" result */
    #####:  306:    jerry_value_free (string_value);
        -:  307:
    #####:  308:    printf ("%s\n", (const char *)buffer);
        -:  309:  }
        -:  310:
        -:  311:  /* Return an "undefined" value to the JavaScript engine */
    #####:  312:  return jerry_undefined ();
        -:  313:}
        -:  314:
        -:  315:int
    #####:  316:main (void)
        -:  317:{
    #####:  318:  const jerry_char_t script[] = "print ('Hello from JS!');";
    #####:  319:  const jerry_length_t script_size = sizeof (script) - 1;
        -:  320:
        -:  321:  /* Initialize engine */
    #####:  322:  jerry_init (JERRY_INIT_EMPTY);
        -:  323:
        -:  324:  /* Add the "print" method for the JavaScript global object */
        -:  325:  {
        -:  326:    /* Get the "global" object */
    #####:  327:    jerry_value_t global_object = jerry_current_realm ();
        -:  328:    /* Create a "print" JS string */
    #####:  329:    jerry_value_t property_name_print = jerry_string_sz ("print");
        -:  330:    /* Create a function from a native C method (this function will be called from JS) */
    #####:  331:    jerry_value_t property_value_func = jerry_function_external (print_handler);
        -:  332:    /* Add the "print" property with the function value to the "global" object */
    #####:  333:    jerry_value_t set_result = jerry_object_set (global_object, property_name_print, property_value_func);
        -:  334:
        -:  335:    /* Check if there was no error when adding the property (in this case it should never happen) */
    #####:  336:    if (jerry_value_is_exception (set_result)) {
        -:  337:      printf ("Failed to add the 'print' property\n");
        -:  338:    }
        -:  339:
        -:  340:    /* Release all jerry_value_t-s */
    #####:  341:    jerry_value_free (set_result);
    #####:  342:    jerry_value_free (property_value_func);
    #####:  343:    jerry_value_free (property_name_print);
    #####:  344:    jerry_value_free (global_object);
        -:  345:  }
        -:  346:
        -:  347:  /* Setup Global scope code */
    #####:  348:  jerry_value_t parsed_code = jerry_parse (script, script_size, NULL);
        -:  349:
    #####:  350:  if (!jerry_value_is_exception (parsed_code))
        -:  351:  {
        -:  352:    /* Execute the parsed source code in the Global scope */
    #####:  353:    jerry_value_t ret_value = jerry_run (parsed_code);
        -:  354:
        -:  355:    /* Returned value must be freed */
    #####:  356:    jerry_value_free (ret_value);
        -:  357:  }
        -:  358:
        -:  359:  /* Parsed source code must be freed */
    #####:  360:  jerry_value_free (parsed_code);
        -:  361:
        -:  362:  /* Cleanup engine */
    #####:  363:  jerry_cleanup ();
        -:  364:
        -:  365:  return 0;
        -:  366:}
        -:  367:```
        -:  368:
        -:  369:
        -:  370:To compile it one can use the following command:
        -:  371:
        -:  372:```sh
        -:  373:$ gcc api-example-5.c -o api-example-5 $(pkg-config --cflags --libs libjerry-core libjerry-port-default libjerry-math)
        -:  374:```
        -:  375:
        -:  376:If everything is correct the application should print out the string passed for the `print` method in the JS code:
        -:  377:
        -:  378:```
        -:  379:$ ./api-example-5
        -:  380:```
        -:  381:
        -:  382:
        -:  383:## Example 6. Using JerryScript Extensions
        -:  384:
        -:  385:Some of the previous examples used a "print" method to write data out to the standard output.
        -:  386:For convenience JerryScript provides an extension to add a simple "print" handler which
        -:  387:can be used by other applications.
        -:  388:
        -:  389:In this example the following extension methods are used:
        -:  390:
        -:  391:- `jerryx_handler_register_global`
        -:  392:- `jerryx_handler_print`
        -:  393:
        -:  394:In further examples this "print" handler will be used.
        -:  395:
        -:  396:```c
        -:  397:#include "jerryscript.h"
        -:  398:#include "jerryscript-ext/handler.h"
        -:  399:
        -:  400:int
        -:  401:main (void)
        -:  402:{
        -:  403:  const jerry_char_t script[] = "print ('Hello from JS with ext!');";
        -:  404:  const jerry_length_t script_size = sizeof (script) - 1;
        -:  405:
        -:  406:  /* Initialize engine */
        -:  407:  jerry_init (JERRY_INIT_EMPTY);
        -:  408:
        -:  409:  /* Register 'print' function from the extensions to the global object */
        -:  410:  jerryx_handler_register_global ("print", jerryx_handler_print);
        -:  411:
        -:  412:  /* Setup Global scope code */
        -:  413:  jerry_value_t parsed_code = jerry_parse (script, script_size, NULL);
        -:  414:
        -:  415:  if (!jerry_value_is_exception (parsed_code))
        -:  416:  {
        -:  417:    /* Execute the parsed source code in the Global scope */
        -:  418:    jerry_value_t ret_value = jerry_run (parsed_code);
        -:  419:
        -:  420:    /* Returned value must be freed */
        -:  421:    jerry_value_free (ret_value);
        -:  422:  }
        -:  423:
        -:  424:  /* Parsed source code must be freed */
        -:  425:  jerry_value_free (parsed_code);
        -:  426:
        -:  427:  /* Cleanup engine */
        -:  428:  jerry_cleanup ();
        -:  429:
        -:  430:  return 0;
        -:  431:}
        -:  432:```
        -:  433:
        -:  434:
        -:  435:To compile it one can use the following command:
        -:  436:
        -:  437:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -:  438:
        -:  439:```sh
        -:  440:$ gcc api-example-6.c -o api-example-6 $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -:  441:```
        -:  442:
        -:  443:If everything is correct the application should print out the string passed for the `print` method in the JS code:
        -:  444:
        -:  445:```
        -:  446:$ ./api-example-6
        -:  447:```
        -:  448:
        -:  449:## Example 7. Interaction with JavaScript environment - adding a string property
        -:  450:
        -:  451:Previously a C method was registered for the global object, now this examples show how one can add a string
        -:  452:property.
        -:  453:
        -:  454:Use the following code as the `api-example-7.c` file:
        -:  455:
        -:  456:[doctest]: # ()
        -:  457:
        -:  458:```c
        -:  459:#include "jerryscript.h"
        -:  460:#include "jerryscript-ext/handler.h"
        -:  461:
        -:  462:int
    #####:  463:main (void)
        -:  464:{
    #####:  465:  const jerry_char_t script[] = "print (my_var);";
        -:  466:
        -:  467:  /* Initializing JavaScript environment */
    #####:  468:  jerry_init (JERRY_INIT_EMPTY);
        -:  469:
        -:  470:  /* Register 'print' function from the extensions */
    #####:  471:  jerryx_handler_register_global ("print", jerryx_handler_print);
        -:  472:
        -:  473:  /* Getting pointer to the Global object */
    #####:  474:  jerry_value_t global_object = jerry_current_realm ();
        -:  475:
        -:  476:  /* Constructing strings */
    #####:  477:  jerry_value_t prop_name = jerry_string_sz ("my_var");
    #####:  478:  jerry_value_t prop_value = jerry_string_sz ("Hello from C!");
        -:  479:
        -:  480:  /* Setting the string value as a property of the Global object */
    #####:  481:  jerry_value_t set_result = jerry_object_set (global_object, prop_name, prop_value);
        -:  482:  /* The 'set_result' should be checked if there was any error */
    #####:  483:  if (jerry_value_is_exception (set_result)) {
        -:  484:    printf ("Failed to add the 'my_var' property\n");
        -:  485:  }
    #####:  486:  jerry_value_free (set_result);
        -:  487:
        -:  488:  /* Releasing string values, as it is no longer necessary outside of engine */
    #####:  489:  jerry_value_free (prop_name);
    #####:  490:  jerry_value_free (prop_value);
        -:  491:
        -:  492:  /* Releasing the Global object */
    #####:  493:  jerry_value_free (global_object);
        -:  494:
        -:  495:  /* Now starting script that would output value of just initialized field */
    #####:  496:  jerry_value_t eval_ret = jerry_eval (script,
        -:  497:                                       sizeof (script) - 1,
        -:  498:                                       JERRY_PARSE_NO_OPTS);
        -:  499:
        -:  500:  /* Free JavaScript value, returned by eval */
    #####:  501:  jerry_value_free (eval_ret);
        -:  502:
        -:  503:  /* Freeing engine */
    #####:  504:  jerry_cleanup ();
        -:  505:
        -:  506:  return 0;
        -:  507:}
        -:  508:```
        -:  509:
        -:  510:To compile it one can use the following command:
        -:  511:
        -:  512:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -:  513:
        -:  514:```sh
        -:  515:$ gcc api-example-7.c -o api-example-7 $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -:  516:```
        -:  517:
        -:  518:The sample will output 'Hello from C!'. However, now it is not just a part of the source script, but the value, dynamically supplied to the engine:
        -:  519:
        -:  520:```
        -:  521:$ ./api-example-7
        -:  522:```
        -:  523:
        -:  524:## Example 8. Description of JerryScript value descriptors
        -:  525:
        -:  526:JerryScript value can be a boolean, number, null, object, string, undefined or some special type of objects (arraybuffer, symbols, etc).
        -:  527:
        -:  528:There is a special "error" value which wraps another value. This "error" can be created by throwing a JavaScript value from JS code
        -:  529:or via API method(s). It is advised to check for this error with the `jerry_value_is_exception` method as not all API methods
        -:  530:can process error values. To extract the value from the "error" the API method `jerry_exception_value` should be used.
        -:  531:If an error object is created via API method (for example with `jerry_error`) the "error" value is automatically created.
        -:  532:
        -:  533:Notice the difference between error value and error object:
        -:  534:- The error object is a object which was constructed via one of the `Error` objects (available from the global object or from API).
        -:  535:  For example in JS such object be created with the following code example:
        -:  536:
        -:  537:```js
        -:  538:var error_object = new Error ("error message");
        -:  539:```
        -:  540:
        -:  541:- The error value is not an object on its own. This is the exception raised/thrown either via API methods or from JS.
        -:  542:  For example, creating such error value in JS would look like this:
        -:  543:
        -:  544:```js
        -:  545:throw "message";
        -:  546:```
        -:  547:
        -:  548:To check what type a given `jerry_value_t` is the `jerry_value_is_*` methods or the `jerry_value_type` could be used.
        -:  549:For example the following code snippet could print out a few types (not all types are checked):
        -:  550:
        -:  551:[doctest]: # (test="compile")
        -:  552:
        -:  553:```c
        -:  554:#include <stdio.h>
        -:  555:#include <stdlib.h>
        -:  556:#include "jerryscript.h"
        -:  557:
        -:  558:static void
        -:  559:print_value (const jerry_value_t jsvalue)
        -:  560:{
        -:  561:  jerry_value_t value;
        -:  562:  /* If there is an error extract the object from it */
        -:  563:  if (jerry_value_is_exception (jsvalue))
        -:  564:  {
        -:  565:    printf ("Error value detected: ");
        -:  566:    value = jerry_exception_value (jsvalue, false);
        -:  567:  }
        -:  568:  else
        -:  569:  {
        -:  570:    value = jerry_value_copy (jsvalue);
        -:  571:  }
        -:  572:
        -:  573:  if (jerry_value_is_undefined (value))
        -:  574:  {
        -:  575:    printf ("undefined");
        -:  576:  }
        -:  577:  else if (jerry_value_is_null (value))
        -:  578:  {
        -:  579:    printf ("null");
        -:  580:  }
        -:  581:  else if (jerry_value_is_boolean (value))
        -:  582:  {
        -:  583:    if (jerry_value_is_true (value))
        -:  584:    {
        -:  585:      printf ("true");
        -:  586:    }
        -:  587:    else
        -:  588:    {
        -:  589:      printf ("false");
        -:  590:    }
        -:  591:  }
        -:  592:  /* Float value */
        -:  593:  else if (jerry_value_is_number (value))
        -:  594:  {
        -:  595:    printf ("number: %lf", jerry_value_as_number (value));
        -:  596:  }
        -:  597:  /* String value */
        -:  598:  else if (jerry_value_is_string (value))
        -:  599:  {
        -:  600:    jerry_char_t str_buf_p[256];
        -:  601:
        -:  602:    /* Determining required buffer size */
        -:  603:    jerry_size_t req_sz = jerry_string_size (value, JERRY_ENCODING_CESU8);
        -:  604:
        -:  605:    if (req_sz <= 255)
        -:  606:    {
        -:  607:      jerry_string_to_buffer (value, JERRY_ENCODING_CESU8, str_buf_p, req_sz);
        -:  608:      str_buf_p[req_sz] = '\0';
        -:  609:      printf ("%s", (const char *) str_buf_p);
        -:  610:    }
        -:  611:    else
        -:  612:    {
        -:  613:      printf ("error: buffer isn't big enough");
        -:  614:    }
        -:  615:  }
        -:  616:  /* Object reference */
        -:  617:  else if (jerry_value_is_object (value))
        -:  618:  {
        -:  619:    printf ("[JS object]");
        -:  620:  }
        -:  621:
        -:  622:  printf ("\n");
        -:  623:  jerry_value_free (value);
        -:  624:}
        -:  625:```
        -:  626:
        -:  627:## Example 8: Simple JavaScript shell
        -:  628:
        -:  629:Now all building blocks, necessary to construct JavaScript shell, are ready.
        -:  630:
        -:  631:Shell operation can be described with the following loop:
        -:  632:
        -:  633:- read command;
        -:  634:- if command is 'quit'
        -:  635:  - exit loop;
        -:  636:- else
        -:  637:  - eval (command);
        -:  638:  - print result of eval;
        -:  639:  - loop.
        -:  640:
        -:  641:See the following `api-example-8-shell.c` file:
        -:  642:
        -:  643:[doctest]: # (test="link")
        -:  644:
        -:  645:```c
        -:  646:#include <stdio.h>
        -:  647:#include <stdlib.h>
        -:  648:#include <string.h>
        -:  649:#include "jerryscript.h"
        -:  650:#include "jerryscript-ext/handler.h"
        -:  651:
        -:  652:static void
    #####:  653:print_value (const jerry_value_t jsvalue)
        -:  654:{
        -:  655:  jerry_value_t value;
        -:  656:  /* If there is an error extract the object from it */
    #####:  657:  if (jerry_value_is_exception (jsvalue))
        -:  658:  {
    #####:  659:    printf ("Error value detected: ");
    #####:  660:    value = jerry_exception_value (jsvalue, false);
        -:  661:  }
        -:  662:  else
        -:  663:  {
    #####:  664:    value = jerry_value_copy (jsvalue);
        -:  665:  }
        -:  666:
    #####:  667:  if (jerry_value_is_undefined (value))
        -:  668:  {
        -:  669:    printf ("undefined");
        -:  670:  }
    #####:  671:  else if (jerry_value_is_null (value))
        -:  672:  {
        -:  673:    printf ("null");
        -:  674:  }
    #####:  675:  else if (jerry_value_is_boolean (value))
        -:  676:  {
    #####:  677:    if (jerry_value_is_true (value))
        -:  678:    {
        -:  679:      printf ("true");
        -:  680:    }
        -:  681:    else
        -:  682:    {
        -:  683:      printf ("false");
        -:  684:    }
        -:  685:  }
        -:  686:  /* Float value */
    #####:  687:  else if (jerry_value_is_number (value))
        -:  688:  {
    #####:  689:    printf ("number: %lf", jerry_value_as_number (value));
        -:  690:  }
        -:  691:  /* String value */
    #####:  692:  else if (jerry_value_is_string (value))
        -:  693:  {
        -:  694:    jerry_char_t str_buf_p[256];
        -:  695:
        -:  696:    /* Determining required buffer size */
    #####:  697:    jerry_size_t req_sz = jerry_string_size (value, JERRY_ENCODING_CESU8);
        -:  698:
    #####:  699:    if (req_sz <= 255)
        -:  700:    {
    #####:  701:      jerry_string_to_buffer (value, JERRY_ENCODING_CESU8, str_buf_p, req_sz);
    #####:  702:      str_buf_p[req_sz] = '\0';
        -:  703:      printf ("%s", (const char *) str_buf_p);
        -:  704:    }
        -:  705:    else
        -:  706:    {
        -:  707:      printf ("error: buffer isn't big enough");
        -:  708:    }
        -:  709:  }
        -:  710:  /* Object reference */
    #####:  711:  else if (jerry_value_is_object (value))
        -:  712:  {
        -:  713:    printf ("[JS object]");
        -:  714:  }
        -:  715:
    #####:  716:  printf ("\n");
    #####:  717:  jerry_value_free (value);
    #####:  718:}
        -:  719:
        -:  720:int
    #####:  721:main (void)
        -:  722:{
    #####:  723:  bool is_done = false;
        -:  724:
        -:  725:  /* Initialize engine */
    #####:  726:  jerry_init (JERRY_INIT_EMPTY);
        -:  727:
        -:  728:  /* Register 'print' function from the extensions */
    #####:  729:  jerryx_handler_register_global ("print", jerryx_handler_print);
        -:  730:
    #####:  731:  while (!is_done)
        -:  732:  {
        -:  733:    char cmd[256];
    #####:  734:    char *cmd_tail = cmd;
    #####:  735:    size_t len = 0;
        -:  736:
        -:  737:    printf ("> ");
        -:  738:
        -:  739:    /* Read next command */
        -:  740:    while (true)
        -:  741:    {
    #####:  742:      if (fread (cmd_tail, 1, 1, stdin) != 1 && len == 0)
        -:  743:      {
        -:  744:        is_done = true;
        -:  745:        break;
        -:  746:      }
    #####:  747:      if (*cmd_tail == '\n')
        -:  748:      {
        -:  749:        break;
        -:  750:      }
        -:  751:
    #####:  752:      cmd_tail++;
    #####:  753:      len++;
        -:  754:    }
        -:  755:
        -:  756:    /* If the command is "quit", break the loop */
    #####:  757:    if (!strncmp (cmd, "quit\n", sizeof ("quit\n") - 1))
        -:  758:    {
        -:  759:      break;
        -:  760:    }
        -:  761:
        -:  762:    jerry_value_t ret_val;
        -:  763:
        -:  764:    /* Evaluate entered command */
    #####:  765:    ret_val = jerry_eval ((const jerry_char_t *) cmd,
        -:  766:                          len,
        -:  767:                          JERRY_PARSE_NO_OPTS);
        -:  768:
        -:  769:    /* Print out the value */
    #####:  770:    print_value (ret_val);
        -:  771:
    #####:  772:    jerry_value_free (ret_val);
        -:  773:  }
        -:  774:
        -:  775:  /* Cleanup engine */
    #####:  776:  jerry_cleanup ();
        -:  777:
        -:  778:  return 0;
        -:  779:}
        -:  780:```
        -:  781:
        -:  782:To compile it one can use the following command:
        -:  783:
        -:  784:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -:  785:
        -:  786:```sh
        -:  787:$ gcc api-example-8-shell.c -o api-example-8-shell $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -:  788:```
        -:  789:
        -:  790:The application reads lines from standard input and evaluates them, one after another. To try out run:
        -:  791:
        -:  792:```
        -:  793:$ ./api-example-8-shell
        -:  794:```
        -:  795:
        -:  796:
        -:  797:## Example 9. Creating JS object in global context
        -:  798:
        -:  799:In this example (`api-example-9.c`) an object with a native function is added to the global object.
        -:  800:
        -:  801:[doctest]: # ()
        -:  802:
        -:  803:```c
        -:  804:#include "jerryscript.h"
        -:  805:#include "jerryscript-ext/handler.h"
        -:  806:
        -:  807:struct my_struct
        -:  808:{
        -:  809:  const char *msg;
        -:  810:} my_struct;
        -:  811:
        -:  812:/**
        -:  813: * Get a string from a native object
        -:  814: */
        -:  815:static jerry_value_t
    #####:  816:get_msg_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  817:                 const jerry_value_t *args_p, /**< function arguments */
        -:  818:                 const jerry_length_t args_cnt) /**< number of function arguments */
        -:  819:{
    #####:  820:  return jerry_string_sz (my_struct.msg);
        -:  821:} /* get_msg_handler */
        -:  822:
        -:  823:int
    #####:  824:main (void)
        -:  825:{
        -:  826:  /* Initialize engine */
    #####:  827:  jerry_init (JERRY_INIT_EMPTY);
        -:  828:
        -:  829:  /* Register 'print' function from the extensions */
    #####:  830:  jerryx_handler_register_global ("print", jerryx_handler_print);
        -:  831:
        -:  832:  /* Do something with the native object */
    #####:  833:  my_struct.msg = "Hello, World!";
        -:  834:
        -:  835:  /* Create an empty JS object */
    #####:  836:  jerry_value_t object = jerry_object ();
        -:  837:
        -:  838:  /* Create a JS function object and wrap into a jerry value */
    #####:  839:  jerry_value_t func_obj = jerry_function_external (get_msg_handler);
        -:  840:
        -:  841:  /* Set the native function as a property of the empty JS object */
    #####:  842:  jerry_value_t prop_name = jerry_string_sz ("myFunc");
    #####:  843:  jerry_value_free (jerry_object_set (object, prop_name, func_obj));
    #####:  844:  jerry_value_free (prop_name);
    #####:  845:  jerry_value_free (func_obj);
        -:  846:
        -:  847:  /* Wrap the JS object (not empty anymore) into a jerry api value */
    #####:  848:  jerry_value_t global_object = jerry_current_realm ();
        -:  849:
        -:  850:  /* Add the JS object to the global context */
    #####:  851:  prop_name = jerry_string_sz ("MyObject");
    #####:  852:  jerry_value_free (jerry_object_set (global_object, prop_name, object));
    #####:  853:  jerry_value_free (prop_name);
    #####:  854:  jerry_value_free (object);
    #####:  855:  jerry_value_free (global_object);
        -:  856:
        -:  857:  /* Now we have a "builtin" object called MyObject with a function called myFunc()
        -:  858:   *
        -:  859:   * Equivalent JS code:
        -:  860:   *                    var MyObject = { myFunc : function () { return "some string value"; } }
        -:  861:   */
    #####:  862:  const jerry_char_t script[] = " \
        -:  863:    var str = MyObject.myFunc (); \
        -:  864:    print (str); \
        -:  865:  ";
        -:  866:
        -:  867:  /* Evaluate script */
    #####:  868:  jerry_value_t eval_ret = jerry_eval (script, sizeof (script) - 1, JERRY_PARSE_NO_OPTS);
        -:  869:
        -:  870:  /* Free JavaScript value, returned by eval */
    #####:  871:  jerry_value_free (eval_ret);
        -:  872:
        -:  873:  /* Cleanup engine */
    #####:  874:  jerry_cleanup ();
        -:  875:
        -:  876:  return 0;
        -:  877:}
        -:  878:```
        -:  879:
        -:  880:To compile it one can use the following command:
        -:  881:
        -:  882:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -:  883:
        -:  884:```sh
        -:  885:$ gcc api-example-9.c -o api-example-9 $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -:  886:```
        -:  887:
        -:  888:Execute the example with:
        -:  889:
        -:  890:```
        -:  891:$ ./api-example-9
        -:  892:```
        -:  893:
        -:  894:The application will generate the following output:
        -:  895:
        -:  896:```bash
        -:  897:Hello, World
        -:  898:```
        -:  899:
        -:  900:## Example 10. Extending JS Objects with native functions
        -:  901:
        -:  902:The example creates a JS Object with `jerry_eval`, then it is extended from C with a native function.
        -:  903:In addition this native function shows how to get a property value from the object and how to manipulate it.
        -:  904:
        -:  905:
        -:  906:Use the following code for `api-example-10.c`:
        -:  907:
        -:  908:[doctest]: # ()
        -:  909:
        -:  910:```c
        -:  911:#include "jerryscript.h"
        -:  912:#include "jerryscript-ext/handler.h"
        -:  913:
        -:  914:/**
        -:  915: * Add param to 'this.x'
        -:  916: */
        -:  917:static jerry_value_t
    #####:  918:add_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  919:             const jerry_value_t args_p[], /**< function arguments */
        -:  920:             const jerry_length_t args_cnt) /**< number of function arguments */
        -:  921:{
        -:  922:  /* The the 'this_val' is the 'MyObject' from the JS code below */
        -:  923:  /* Note: that the argument count check is ignored for the example's case */
        -:  924:
        -:  925:  /* Get 'this.x' */
    #####:  926:  jerry_value_t prop_name = jerry_string_sz ("x");
    #####:  927:  jerry_value_t x_val = jerry_object_get (call_info_p->this_value, prop_name);
        -:  928:
    #####:  929:  if (!jerry_value_is_exception (x_val))
        -:  930:  {
        -:  931:    /* Convert Jerry API values to double */
    #####:  932:    double x = jerry_value_as_number (x_val);
    #####:  933:    double d = jerry_value_as_number (args_p[0]);
        -:  934:
        -:  935:    /* Add the parameter to 'x' */
    #####:  936:    jerry_value_t res_val = jerry_number (x + d);
        -:  937:
        -:  938:    /* Set the new value of 'this.x' */
    #####:  939:    jerry_value_free (jerry_object_set (call_info_p->this_value, prop_name, res_val));
    #####:  940:    jerry_value_free (res_val);
        -:  941:  }
        -:  942:
    #####:  943:  jerry_value_free (x_val);
    #####:  944:  jerry_value_free (prop_name);
        -:  945:
    #####:  946:  return jerry_undefined ();
        -:  947:} /* add_handler */
        -:  948:
        -:  949:int
    #####:  950:main (void)
        -:  951:{
        -:  952:  /* Initialize engine */
    #####:  953:  jerry_init (JERRY_INIT_EMPTY);
        -:  954:
        -:  955:  /* Register 'print' function from the extensions */
    #####:  956:  jerryx_handler_register_global ("print", jerryx_handler_print);
        -:  957:
        -:  958:  /* Create a JS object */
    #####:  959:  const jerry_char_t my_js_object[] = " \
        -:  960:    MyObject = \
        -:  961:    { x : 12, \
        -:  962:      y : 'Value of x is ', \
        -:  963:      foo: function () \
        -:  964:      { \
        -:  965:        return this.y + this.x; \
        -:  966:      } \
        -:  967:    } \
        -:  968:  ";
        -:  969:
        -:  970:  jerry_value_t my_js_obj_val;
        -:  971:
        -:  972:  /* Evaluate script */
    #####:  973:  my_js_obj_val = jerry_eval (my_js_object,
        -:  974:                              sizeof (my_js_object) - 1,
        -:  975:                              JERRY_PARSE_NO_OPTS);
        -:  976:
        -:  977:  /* Create a JS function object and wrap into a jerry value */
    #####:  978:  jerry_value_t add_func_obj = jerry_function_external (add_handler);
        -:  979:
        -:  980:  /* Set the native function as a property of previously created MyObject */
    #####:  981:  jerry_value_t prop_name = jerry_string_sz ("add2x");
    #####:  982:  jerry_value_free (jerry_object_set (my_js_obj_val, prop_name, add_func_obj));
    #####:  983:  jerry_value_free (add_func_obj);
    #####:  984:  jerry_value_free (prop_name);
        -:  985:
        -:  986:  /* Free JavaScript value, returned by eval (my_js_object) */
    #####:  987:  jerry_value_free (my_js_obj_val);
        -:  988:
    #####:  989:  const jerry_char_t script[] = " \
        -:  990:    var str = MyObject.foo (); \
        -:  991:    print (str); \
        -:  992:    MyObject.add2x (5); \
        -:  993:    print (MyObject.foo ()); \
        -:  994:  ";
        -:  995:
        -:  996:  /* Evaluate script */
    #####:  997:  jerry_value_t eval_ret = jerry_eval (script, sizeof (script) - 1, JERRY_PARSE_NO_OPTS);
        -:  998:
        -:  999:  /* Free JavaScript value, returned by eval */
    #####: 1000:  jerry_value_free (eval_ret);
        -: 1001:
        -: 1002:  /* Cleanup engine */
    #####: 1003:  jerry_cleanup ();
        -: 1004:
        -: 1005:  return 0;
        -: 1006:}
        -: 1007:```
        -: 1008:
        -: 1009:To compile it one can use the following command:
        -: 1010:
        -: 1011:(**Note** that the `libjerry-ext` was added **before** the `libjerry-port-default` entry for the `pkg-config` call.
        -: 1012:
        -: 1013:```sh
        -: 1014:$ gcc api-example-10.c -o api-example-10 $(pkg-config --cflags --libs libjerry-core libjerry-ext libjerry-port-default libjerry-math)
        -: 1015:```
        -: 1016:
        -: 1017:Execute the example with:
        -: 1018:
        -: 1019:```
        -: 1020:$ ./api-example-10
        -: 1021:```
        -: 1022:
        -: 1023:```bash
        -: 1024:Value of x is 12
        -: 1025:Value of x is 17
        -: 1026:```
        -: 1027:
        -: 1028:## Example 11. Changing the seed of pseudorandom generated numbers
        -: 1029:
        -: 1030:If you want to change the seed of `Math.random()` generated numbers, you have to initialize the seed value with `srand`.
        -: 1031:A recommended method is using `jerry_port_get_current_time()` or something based on a constantly changing value, therefore every run produces truly random numbers.
        -: 1032:
        -: 1033:[doctest]: # ()
        -: 1034:
        -: 1035:```c
        -: 1036:#include <stdlib.h>
        -: 1037:#include "jerryscript.h"
        -: 1038:#include "jerryscript-port.h"
        -: 1039:#include "jerryscript-ext/handler.h"
        -: 1040:
        -: 1041:int
    #####: 1042:main (void)
        -: 1043:{
        -: 1044:  /* Initialize srand value */
    #####: 1045:  union { double d; unsigned u; } now = { .d = jerry_port_get_current_time () };
    #####: 1046:  srand (now.u);
        -: 1047:
        -: 1048:  /* Generate a random number, and print it */
    #####: 1049:  const jerry_char_t script[] = "var a = Math.random (); print(a)";
        -: 1050:
        -: 1051:  /* Initialize the engine */
    #####: 1052:  jerry_init (JERRY_INIT_EMPTY);
        -: 1053:
        -: 1054:  /* Register the print function */
    #####: 1055:  jerryx_handler_register_global ("print", jerryx_handler_print);
        -: 1056:
        -: 1057:  /* Evaluate the script */
    #####: 1058:  jerry_value_t eval_ret = jerry_eval (script, sizeof (script) - 1, JERRY_PARSE_NO_OPTS);
        -: 1059:
        -: 1060:  /* Free the JavaScript value returned by eval */
    #####: 1061:  jerry_value_free (eval_ret);
        -: 1062:
        -: 1063:  /* Cleanup the engine */
    #####: 1064:  jerry_cleanup ();
        -: 1065:
        -: 1066:  return 0;
        -: 1067:}
        -: 1068:```
        -: 1069:
        -: 1070:## Further steps
        -: 1071:
        -: 1072:For further API description, please visit [API Reference page](https://jerryscript-project.github.io/jerryscript/api-reference/) on [JerryScript home page](https://jerryscript-project.github.io/jerryscript/).
