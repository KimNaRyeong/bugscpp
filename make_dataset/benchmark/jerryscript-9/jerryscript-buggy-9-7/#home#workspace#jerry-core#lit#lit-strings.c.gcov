        -:    0:Source:/home/workspace/jerry-core/lit/lit-strings.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "lit-strings.h"
        -:   17:
        -:   18:#include "jrt-libc-includes.h"
        -:   19:
        -:   20:#define LIT_UTF8_SURROGATE_MARKER     0xed /**< utf8 surrogate marker */
        -:   21:#define LIT_UTF8_HIGH_SURROGATE_MIN   0xa0 /**< utf8 high surrogate minimum */
        -:   22:#define LIT_UTF8_HIGH_SURROGATE_MAX   0xaf /**< utf8 high surrogate maximum */
        -:   23:#define LIT_UTF8_LOW_SURROGATE_MIN    0xb0 /**< utf8 low surrogate minimum */
        -:   24:#define LIT_UTF8_LOW_SURROGATE_MAX    0xbf /**< utf8 low surrogate maximum */
        -:   25:#define LIT_UTF8_1_BYTE_MAX           0xf4 /**< utf8 one byte max */
        -:   26:#define LIT_UTF8_2_BYTE_MAX           0x8f /**< utf8 two byte max */
        -:   27:#define LIT_UTF8_VALID_TWO_BYTE_START 0xc2 /**< utf8 two byte start */
        -:   28:
        -:   29:/**
        -:   30: * Validate utf-8 string
        -:   31: *
        -:   32: * NOTE:
        -:   33: *   Isolated surrogates are allowed.
        -:   34: *
        -:   35: * @return true if utf-8 string is well-formed
        -:   36: *         false otherwise
        -:   37: */
        -:   38:bool
        2:   39:lit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:   40:                          lit_utf8_size_t buf_size, /**< string size */
        -:   41:                          bool is_strict) /**< true if surrogate pairs are not allowed */
        -:   42:{
        2:   43:  const unsigned char *end = buf_size + utf8_buf_p;
        -:   44:
        2:   45:  const unsigned char *idx = (const unsigned char *) utf8_buf_p;
        -:   46:
      104:   47:  while (idx < end)
        -:   48:  {
      100:   49:    const uint8_t first_byte = *idx++;
        -:   50:
      100:   51:    if (first_byte < LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   52:    {
      100:   53:      continue;
        -:   54:    }
        -:   55:
    #####:   56:    if (first_byte < LIT_UTF8_VALID_TWO_BYTE_START || idx >= end)
        -:   57:    {
    #####:   58:      return false;
        -:   59:    }
        -:   60:
    #####:   61:    const uint8_t second_byte = *idx++;
        -:   62:
    #####:   63:    if ((second_byte & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   64:    {
    #####:   65:      return false;
        -:   66:    }
        -:   67:
    #####:   68:    if (first_byte < LIT_UTF8_3_BYTE_MARKER)
        -:   69:    {
    #####:   70:      continue;
        -:   71:    }
        -:   72:
    #####:   73:    if (idx >= end || (*idx++ & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   74:    {
    #####:   75:      return false;
        -:   76:    }
        -:   77:
    #####:   78:    if (first_byte < LIT_UTF8_4_BYTE_MARKER)
        -:   79:    {
    #####:   80:      if (first_byte == LIT_UTF8_3_BYTE_MARKER && (second_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   81:      {
    #####:   82:        return false;
        -:   83:      }
        -:   84:
    #####:   85:      if (is_strict && first_byte == LIT_UTF8_SURROGATE_MARKER && second_byte >= LIT_UTF8_HIGH_SURROGATE_MIN
    #####:   86:          && second_byte <= LIT_UTF8_HIGH_SURROGATE_MAX && idx + 3 <= end && idx[0] == LIT_UTF8_SURROGATE_MARKER
    #####:   87:          && idx[1] >= LIT_UTF8_LOW_SURROGATE_MIN && idx[1] <= LIT_UTF8_LOW_SURROGATE_MAX)
        -:   88:      {
    #####:   89:        return false;
        -:   90:      }
    #####:   91:      continue;
        -:   92:    }
        -:   93:
    #####:   94:    if (idx >= end || first_byte > LIT_UTF8_1_BYTE_MAX
    #####:   95:        || (first_byte == LIT_UTF8_4_BYTE_MARKER && second_byte <= LIT_UTF8_EXTRA_BYTE_MARKER)
    #####:   96:        || (first_byte == LIT_UTF8_1_BYTE_MAX && second_byte > LIT_UTF8_2_BYTE_MAX)
    #####:   97:        || (*idx++ & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   98:    {
    #####:   99:      return false;
        -:  100:    }
        -:  101:  }
        -:  102:
        2:  103:  return true;
        -:  104:} /* lit_is_valid_utf8_string */
        -:  105:
        -:  106:/**
        -:  107: * Validate cesu-8 string
        -:  108: *
        -:  109: * @return true if cesu-8 string is well-formed
        -:  110: *         false otherwise
        -:  111: */
        -:  112:bool
       15:  113:lit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  114:                           lit_utf8_size_t buf_size) /**< string size */
        -:  115:{
       15:  116:  lit_utf8_size_t idx = 0;
        -:  117:
      136:  118:  while (idx < buf_size)
        -:  119:  {
      106:  120:    lit_utf8_byte_t c = cesu8_buf_p[idx++];
      106:  121:    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  122:    {
      106:  123:      continue;
        -:  124:    }
        -:  125:
    #####:  126:    lit_code_point_t code_point = 0;
    #####:  127:    lit_code_point_t min_code_point = 0;
        -:  128:    lit_utf8_size_t extra_bytes_count;
    #####:  129:    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  130:    {
    #####:  131:      extra_bytes_count = 1;
    #####:  132:      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;
    #####:  133:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  134:    }
    #####:  135:    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  136:    {
    #####:  137:      extra_bytes_count = 2;
    #####:  138:      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;
    #####:  139:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  140:    }
        -:  141:    else
        -:  142:    {
    #####:  143:      return false;
        -:  144:    }
        -:  145:
    #####:  146:    if (idx + extra_bytes_count > buf_size)
        -:  147:    {
        -:  148:      /* cesu-8 string breaks in the middle */
    #####:  149:      return false;
        -:  150:    }
        -:  151:
    #####:  152:    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)
        -:  153:    {
    #####:  154:      c = cesu8_buf_p[idx + offset];
    #####:  155:      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:  156:      {
        -:  157:        /* invalid continuation byte */
    #####:  158:        return false;
        -:  159:      }
    #####:  160:      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  161:      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);
        -:  162:    }
        -:  163:
    #####:  164:    if (code_point < min_code_point)
        -:  165:    {
        -:  166:      /* cesu-8 string doesn't encode valid unicode code point */
    #####:  167:      return false;
        -:  168:    }
        -:  169:
    #####:  170:    idx += extra_bytes_count;
        -:  171:  }
        -:  172:
       15:  173:  return true;
        -:  174:} /* lit_is_valid_cesu8_string */
        -:  175:
        -:  176:/**
        -:  177: * Check if the code point is UTF-16 low surrogate
        -:  178: *
        -:  179: * @return true / false
        -:  180: */
        -:  181:bool
    #####:  182:lit_is_code_point_utf16_low_surrogate (lit_code_point_t code_point) /**< code point */
        -:  183:{
    #####:  184:  return LIT_UTF16_LOW_SURROGATE_MIN <= code_point && code_point <= LIT_UTF16_LOW_SURROGATE_MAX;
        -:  185:} /* lit_is_code_point_utf16_low_surrogate */
        -:  186:
        -:  187:/**
        -:  188: * Check if the code point is UTF-16 high surrogate
        -:  189: *
        -:  190: * @return true / false
        -:  191: */
        -:  192:bool
    #####:  193:lit_is_code_point_utf16_high_surrogate (lit_code_point_t code_point) /**< code point */
        -:  194:{
    #####:  195:  return LIT_UTF16_HIGH_SURROGATE_MIN <= code_point && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX;
        -:  196:} /* lit_is_code_point_utf16_high_surrogate */
        -:  197:
        -:  198:/**
        -:  199: * Represents code point (>0xFFFF) as surrogate pair and returns its lower part
        -:  200: *
        -:  201: * @return lower code_unit of the surrogate pair
        -:  202: */
        -:  203:static ecma_char_t
    #####:  204:convert_code_point_to_low_surrogate (lit_code_point_t code_point) /**< code point, should be > 0xFFFF */
        -:  205:{
    #####:  206:  JERRY_ASSERT (code_point > LIT_UTF16_CODE_UNIT_MAX);
        -:  207:
        -:  208:  ecma_char_t code_unit_bits;
    #####:  209:  code_unit_bits = (ecma_char_t) (code_point & LIT_UTF16_LAST_10_BITS_MASK);
        -:  210:
    #####:  211:  return (ecma_char_t) (LIT_UTF16_LOW_SURROGATE_MARKER | code_unit_bits);
        -:  212:} /* convert_code_point_to_low_surrogate */
        -:  213:
        -:  214:/**
        -:  215: * Represents code point (>0xFFFF) as surrogate pair and returns its higher part
        -:  216: *
        -:  217: * @return higher code_unit of the surrogate pair
        -:  218: */
        -:  219:static ecma_char_t
    #####:  220:convert_code_point_to_high_surrogate (lit_code_point_t code_point) /**< code point, should be > 0xFFFF */
        -:  221:{
    #####:  222:  JERRY_ASSERT (code_point > LIT_UTF16_CODE_UNIT_MAX);
    #####:  223:  JERRY_ASSERT (code_point <= LIT_UNICODE_CODE_POINT_MAX);
        -:  224:
        -:  225:  ecma_char_t code_unit_bits;
    #####:  226:  code_unit_bits = (ecma_char_t) ((code_point - LIT_UTF16_FIRST_SURROGATE_CODE_POINT) >> LIT_UTF16_BITS_IN_SURROGATE);
        -:  227:
    #####:  228:  return (LIT_UTF16_HIGH_SURROGATE_MARKER | code_unit_bits);
        -:  229:} /* convert_code_point_to_high_surrogate */
        -:  230:
        -:  231:/**
        -:  232: * UTF16 Encoding method for a code point
        -:  233: *
        -:  234: * See also:
        -:  235: *          ECMA-262 v6, 10.1.1
        -:  236: *
        -:  237: * @return uint8_t, the number of returning code points
        -:  238: */
        -:  239:uint8_t
    #####:  240:lit_utf16_encode_code_point (lit_code_point_t cp, /**< the code point we encode */
        -:  241:                             ecma_char_t *cu_p) /**< result of the encoding */
        -:  242:{
    #####:  243:  if (cp <= LIT_UTF16_CODE_UNIT_MAX)
        -:  244:  {
    #####:  245:    cu_p[0] = (ecma_char_t) cp;
    #####:  246:    return 1;
        -:  247:  }
        -:  248:
    #####:  249:  cu_p[0] = convert_code_point_to_high_surrogate (cp);
    #####:  250:  cu_p[1] = convert_code_point_to_low_surrogate (cp);
    #####:  251:  return 2;
        -:  252:} /* lit_utf16_encode_code_point */
        -:  253:
        -:  254:/**
        -:  255: * Calculate size of a zero-terminated utf-8 string
        -:  256: *
        -:  257: * NOTE:
        -:  258: *   - string cannot be NULL
        -:  259: *   - string should not contain zero characters in the middle
        -:  260: *
        -:  261: * @return size of a string
        -:  262: */
        -:  263:lit_utf8_size_t
        5:  264:lit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */
        -:  265:{
        5:  266:  JERRY_ASSERT (utf8_str_p != NULL);
        5:  267:  return (lit_utf8_size_t) strlen ((const char *) utf8_str_p);
        -:  268:} /* lit_zt_utf8_string_size */
        -:  269:
        -:  270:/**
        -:  271: * Calculate length of a cesu-8 encoded string
        -:  272: *
        -:  273: * @return UTF-16 code units count
        -:  274: */
        -:  275:lit_utf8_size_t
       10:  276:lit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:  277:                        lit_utf8_size_t utf8_buf_size) /**< string size */
        -:  278:{
       10:  279:  lit_utf8_size_t length = 0;
       10:  280:  lit_utf8_size_t size = 0;
        -:  281:
       92:  282:  while (size < utf8_buf_size)
        -:  283:  {
      144:  284:    size += lit_get_unicode_char_size_by_utf8_first_byte (*(utf8_buf_p + size));
       72:  285:    length++;
        -:  286:  }
        -:  287:
       10:  288:  JERRY_ASSERT (size == utf8_buf_size);
        -:  289:
       10:  290:  return length;
        -:  291:} /* lit_utf8_string_length */
        -:  292:
        -:  293:/**
        -:  294: * Calculate the required size of an utf-8 encoded string from cesu-8 encoded string
        -:  295: *
        -:  296: * @return size of an utf-8 encoded string
        -:  297: */
        -:  298:lit_utf8_size_t
    #####:  299:lit_get_utf8_size_of_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  300:                                   lit_utf8_size_t cesu8_buf_size) /**< string size */
        -:  301:{
    #####:  302:  lit_utf8_size_t offset = 0;
    #####:  303:  lit_utf8_size_t utf8_buf_size = cesu8_buf_size;
    #####:  304:  ecma_char_t prev_ch = 0;
        -:  305:
    #####:  306:  while (offset < cesu8_buf_size)
        -:  307:  {
    #####:  308:    ecma_char_t ch;
    #####:  309:    offset += lit_read_code_unit_from_cesu8 (cesu8_buf_p + offset, &ch);
        -:  310:
    #####:  311:    if (lit_is_code_point_utf16_low_surrogate (ch) && lit_is_code_point_utf16_high_surrogate (prev_ch))
        -:  312:    {
    #####:  313:      utf8_buf_size -= 2;
        -:  314:    }
        -:  315:
    #####:  316:    prev_ch = ch;
        -:  317:  }
        -:  318:
    #####:  319:  JERRY_ASSERT (offset == cesu8_buf_size);
        -:  320:
    #####:  321:  return utf8_buf_size;
        -:  322:} /* lit_get_utf8_size_of_cesu8_string */
        -:  323:
        -:  324:/**
        -:  325: * Calculate length of an utf-8 encoded string from cesu-8 encoded string
        -:  326: *
        -:  327: * @return length of an utf-8 encoded string
        -:  328: */
        -:  329:lit_utf8_size_t
    #####:  330:lit_get_utf8_length_of_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  331:                                     lit_utf8_size_t cesu8_buf_size) /**< string size */
        -:  332:{
    #####:  333:  lit_utf8_size_t offset = 0;
    #####:  334:  lit_utf8_size_t utf8_length = 0;
    #####:  335:  ecma_char_t prev_ch = 0;
        -:  336:
    #####:  337:  while (offset < cesu8_buf_size)
        -:  338:  {
    #####:  339:    ecma_char_t ch;
    #####:  340:    offset += lit_read_code_unit_from_cesu8 (cesu8_buf_p + offset, &ch);
        -:  341:
    #####:  342:    if (!lit_is_code_point_utf16_low_surrogate (ch) || !lit_is_code_point_utf16_high_surrogate (prev_ch))
        -:  343:    {
    #####:  344:      utf8_length++;
        -:  345:    }
        -:  346:
    #####:  347:    prev_ch = ch;
        -:  348:  }
        -:  349:
    #####:  350:  JERRY_ASSERT (offset == cesu8_buf_size);
        -:  351:
    #####:  352:  return utf8_length;
        -:  353:} /* lit_get_utf8_length_of_cesu8_string */
        -:  354:
        -:  355:/**
        -:  356: * Decodes a unicode code point from non-empty utf-8-encoded buffer
        -:  357: *
        -:  358: * @return number of bytes occupied by code point in the string
        -:  359: */
        -:  360:lit_utf8_size_t
    #####:  361:lit_read_code_point_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  362:                               lit_utf8_size_t buf_size, /**< size of the buffer in bytes */
        -:  363:                               lit_code_point_t *code_point) /**< [out] code point */
        -:  364:{
    #####:  365:  JERRY_ASSERT (buf_p && buf_size);
        -:  366:
    #####:  367:  lit_utf8_byte_t c = buf_p[0];
    #####:  368:  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  369:  {
    #####:  370:    *code_point = (lit_code_point_t) (c & LIT_UTF8_LAST_7_BITS_MASK);
    #####:  371:    return 1;
        -:  372:  }
        -:  373:
    #####:  374:  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;
    #####:  375:  lit_utf8_size_t bytes_count = 0;
    #####:  376:  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  377:  {
    #####:  378:    bytes_count = 2;
    #####:  379:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  380:  }
    #####:  381:  else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  382:  {
    #####:  383:    bytes_count = 3;
    #####:  384:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  385:  }
        -:  386:  else
        -:  387:  {
    #####:  388:    JERRY_ASSERT ((c & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER);
    #####:  389:    bytes_count = 4;
    #####:  390:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_3_BITS_MASK));
        -:  391:  }
        -:  392:
    #####:  393:  JERRY_ASSERT (buf_size >= bytes_count);
        -:  394:
    #####:  395:  for (uint32_t i = 1; i < bytes_count; ++i)
        -:  396:  {
    #####:  397:    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  398:    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);
        -:  399:  }
        -:  400:
    #####:  401:  *code_point = ret;
    #####:  402:  return bytes_count;
        -:  403:} /* lit_read_code_point_from_utf8 */
        -:  404:
        -:  405:/**
        -:  406: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  407: *
        -:  408: * @return number of bytes occupied by code point in the string
        -:  409: */
        -:  410:lit_utf8_size_t
    #####:  411:lit_read_code_unit_from_cesu8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  412:                               ecma_char_t *code_unit) /**< [out] code unit */
        -:  413:{
    #####:  414:  JERRY_ASSERT (buf_p);
        -:  415:
    #####:  416:  lit_utf8_byte_t c = buf_p[0];
    #####:  417:  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  418:  {
    #####:  419:    *code_unit = (ecma_char_t) (c & LIT_UTF8_LAST_7_BITS_MASK);
    #####:  420:    return 1;
        -:  421:  }
        -:  422:
    #####:  423:  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;
        -:  424:  lit_utf8_size_t bytes_count;
        -:  425:
    #####:  426:  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  427:  {
    #####:  428:    bytes_count = 2;
    #####:  429:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  430:  }
        -:  431:  else
        -:  432:  {
    #####:  433:    JERRY_ASSERT ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);
    #####:  434:    bytes_count = 3;
    #####:  435:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  436:  }
        -:  437:
    #####:  438:  for (uint32_t i = 1; i < bytes_count; ++i)
        -:  439:  {
    #####:  440:    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  441:    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);
        -:  442:  }
        -:  443:
    #####:  444:  JERRY_ASSERT (ret <= LIT_UTF16_CODE_UNIT_MAX);
    #####:  445:  *code_unit = (ecma_char_t) ret;
    #####:  446:  return bytes_count;
        -:  447:} /* lit_read_code_unit_from_cesu8 */
        -:  448:
        -:  449:/**
        -:  450: * Decodes a unicode code point from non-empty cesu-8-encoded buffer
        -:  451: *
        -:  452: * @return number of bytes occupied by code point in the string
        -:  453: */
        -:  454:lit_utf8_size_t
    #####:  455:lit_read_code_point_from_cesu8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  456:                                const lit_utf8_byte_t *buf_end_p, /**< buffer end */
        -:  457:                                lit_code_point_t *code_point) /**< [out] code point */
        -:  458:{
    #####:  459:  ecma_char_t code_unit;
    #####:  460:  lit_utf8_size_t size = lit_read_code_unit_from_cesu8 (buf_p, &code_unit);
        -:  461:
    #####:  462:  JERRY_ASSERT (buf_p + size <= buf_end_p);
        -:  463:
    #####:  464:  if (lit_is_code_point_utf16_high_surrogate (code_unit))
        -:  465:  {
    #####:  466:    buf_p += size;
        -:  467:
    #####:  468:    if (buf_p < buf_end_p)
        -:  469:    {
    #####:  470:      ecma_char_t next_code_unit;
    #####:  471:      lit_utf8_size_t next_size = lit_read_code_unit_from_cesu8 (buf_p, &next_code_unit);
        -:  472:
    #####:  473:      if (lit_is_code_point_utf16_low_surrogate (next_code_unit))
        -:  474:      {
    #####:  475:        JERRY_ASSERT (buf_p + next_size <= buf_end_p);
        -:  476:
    #####:  477:        *code_point = lit_convert_surrogate_pair_to_code_point (code_unit, next_code_unit);
    #####:  478:        return size + next_size;
        -:  479:      }
        -:  480:    }
        -:  481:  }
        -:  482:
    #####:  483:  *code_point = code_unit;
    #####:  484:  return size;
        -:  485:} /* lit_read_code_point_from_cesu8 */
        -:  486:
        -:  487:/**
        -:  488: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  489: *
        -:  490: * @return number of bytes occupied by code point in the string
        -:  491: */
        -:  492:lit_utf8_size_t
    #####:  493:lit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  494:                                   ecma_char_t *code_point) /**< [out] code point */
        -:  495:{
    #####:  496:  JERRY_ASSERT (buf_p);
        -:  497:
    #####:  498:  lit_utf8_decr (&buf_p);
    #####:  499:  return lit_read_code_unit_from_cesu8 (buf_p, code_point);
        -:  500:} /* lit_read_prev_code_unit_from_utf8 */
        -:  501:
        -:  502:/**
        -:  503: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  504: *
        -:  505: * @return next code unit
        -:  506: */
        -:  507:ecma_char_t
    #####:  508:lit_cesu8_read_next (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  509:{
    #####:  510:  JERRY_ASSERT (*buf_p);
    #####:  511:  ecma_char_t ch;
        -:  512:
    #####:  513:  *buf_p += lit_read_code_unit_from_cesu8 (*buf_p, &ch);
        -:  514:
    #####:  515:  return ch;
        -:  516:} /* lit_cesu8_read_next */
        -:  517:
        -:  518:/**
        -:  519: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  520: *
        -:  521: * @return previous code unit
        -:  522: */
        -:  523:ecma_char_t
    #####:  524:lit_cesu8_read_prev (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  525:{
    #####:  526:  JERRY_ASSERT (*buf_p);
    #####:  527:  ecma_char_t ch;
        -:  528:
    #####:  529:  lit_utf8_decr (buf_p);
    #####:  530:  lit_read_code_unit_from_cesu8 (*buf_p, &ch);
        -:  531:
    #####:  532:  return ch;
        -:  533:} /* lit_cesu8_read_prev */
        -:  534:
        -:  535:/**
        -:  536: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  537: *
        -:  538: * @return next code unit
        -:  539: */
        -:  540:ecma_char_t JERRY_ATTR_NOINLINE
    #####:  541:lit_cesu8_peek_next (const lit_utf8_byte_t *buf_p) /**< [in,out] buffer with characters */
        -:  542:{
    #####:  543:  JERRY_ASSERT (buf_p != NULL);
    #####:  544:  ecma_char_t ch;
        -:  545:
    #####:  546:  lit_read_code_unit_from_cesu8 (buf_p, &ch);
        -:  547:
    #####:  548:  return ch;
        -:  549:} /* lit_cesu8_peek_next */
        -:  550:
        -:  551:/**
        -:  552: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  553: *
        -:  554: * @return previous code unit
        -:  555: */
        -:  556:ecma_char_t JERRY_ATTR_NOINLINE
    #####:  557:lit_cesu8_peek_prev (const lit_utf8_byte_t *buf_p) /**< [in,out] buffer with characters */
        -:  558:{
    #####:  559:  JERRY_ASSERT (buf_p != NULL);
    #####:  560:  ecma_char_t ch;
        -:  561:
    #####:  562:  lit_read_prev_code_unit_from_utf8 (buf_p, &ch);
        -:  563:
    #####:  564:  return ch;
        -:  565:} /* lit_cesu8_peek_prev */
        -:  566:
        -:  567:/**
        -:  568: * Increase cesu-8 encoded string pointer by one code unit.
        -:  569: */
        -:  570:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  571:lit_utf8_incr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  572:{
    #####:  573:  JERRY_ASSERT (*buf_p);
        -:  574:
    #####:  575:  *buf_p += lit_get_unicode_char_size_by_utf8_first_byte (**buf_p);
    #####:  576:} /* lit_utf8_incr */
        -:  577:
        -:  578:/**
        -:  579: * Decrease cesu-8 encoded string pointer by one code unit.
        -:  580: */
        -:  581:void
    #####:  582:lit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  583:{
    #####:  584:  JERRY_ASSERT (*buf_p);
    #####:  585:  const lit_utf8_byte_t *current_p = *buf_p;
        -:  586:
        -:  587:  do
        -:  588:  {
    #####:  589:    current_p--;
    #####:  590:  } while ((*current_p & LIT_UTF8_EXTRA_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER);
        -:  591:
    #####:  592:  *buf_p = current_p;
    #####:  593:} /* lit_utf8_decr */
        -:  594:
        -:  595:/**
        -:  596: * Calc hash using the specified hash_basis.
        -:  597: *
        -:  598: * NOTE:
        -:  599: *   This is implementation of FNV-1a hash function, which is released into public domain.
        -:  600: *   Constants used, are carefully picked primes by the authors.
        -:  601: *   More info: http://www.isthe.com/chongo/tech/comp/fnv/
        -:  602: *
        -:  603: * @return ecma-string's hash
        -:  604: */
        -:  605:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
    #####:  606:lit_utf8_string_hash_combine (lit_string_hash_t hash_basis, /**< hash to be combined with */
        -:  607:                              const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */
        -:  608:                              lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */
        -:  609:{
       10:  610:  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);
        -:  611:
       10:  612:  uint32_t hash = hash_basis;
        -:  613:
       82:  614:  for (uint32_t i = 0; i < utf8_buf_size; i++)
        -:  615:  {
        -:  616:    /* 16777619 is 32 bit FNV_prime = 2^24 + 2^8 + 0x93 = 16777619 */
       72:  617:    hash = (hash ^ utf8_buf_p[i]) * 16777619;
        -:  618:  }
        -:  619:
       10:  620:  return (lit_string_hash_t) hash;
        -:  621:} /* lit_utf8_string_hash_combine */
        -:  622:
        -:  623:/**
        -:  624: * Calculate hash from the buffer.
        -:  625: *
        -:  626: * @return ecma-string's hash
        -:  627: */
        -:  628:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
       10:  629:lit_utf8_string_calc_hash (const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */
        -:  630:                           lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */
        -:  631:{
       10:  632:  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);
        -:  633:
        -:  634:  /* 32 bit offset_basis for FNV = 2166136261 */
       10:  635:  return lit_utf8_string_hash_combine ((lit_string_hash_t) 2166136261, utf8_buf_p, utf8_buf_size);
        -:  636:} /* lit_utf8_string_calc_hash */
        -:  637:
        -:  638:/**
        -:  639: * Return code unit at the specified position in string
        -:  640: *
        -:  641: * NOTE:
        -:  642: *   code_unit_offset should be less then string's length
        -:  643: *
        -:  644: * @return code unit value
        -:  645: */
        -:  646:ecma_char_t
    #####:  647:lit_utf8_string_code_unit_at (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:  648:                              lit_utf8_size_t utf8_buf_size, /**< string size in bytes */
        -:  649:                              lit_utf8_size_t code_unit_offset) /**< ofset of a code_unit */
        -:  650:{
    #####:  651:  lit_utf8_byte_t *current_p = (lit_utf8_byte_t *) utf8_buf_p;
    #####:  652:  ecma_char_t code_unit;
        -:  653:
        -:  654:  do
        -:  655:  {
    #####:  656:    JERRY_ASSERT (current_p < utf8_buf_p + utf8_buf_size);
    #####:  657:    current_p += lit_read_code_unit_from_cesu8 (current_p, &code_unit);
    #####:  658:  } while (code_unit_offset--);
        -:  659:
    #####:  660:  return code_unit;
        -:  661:} /* lit_utf8_string_code_unit_at */
        -:  662:
        -:  663:/**
        -:  664: * Get CESU-8 encoded size of character
        -:  665: *
        -:  666: * @return number of bytes occupied in CESU-8
        -:  667: */
        -:  668:extern inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
    #####:  669:lit_get_unicode_char_size_by_utf8_first_byte (const lit_utf8_byte_t first_byte) /**< buffer with characters */
        -:  670:{
       72:  671:  if ((first_byte & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  672:  {
       72:  673:    return 1;
        -:  674:  }
    #####:  675:  else if ((first_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  676:  {
    #####:  677:    return 2;
        -:  678:  }
        -:  679:  else
        -:  680:  {
    #####:  681:    JERRY_ASSERT ((first_byte & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);
    #####:  682:    return 3;
        -:  683:  }
        -:  684:} /* lit_get_unicode_char_size_by_utf8_first_byte */
        -:  685:
        -:  686:/**
        -:  687: * Convert code unit to cesu-8 representation
        -:  688: *
        -:  689: * @return byte count required to represent the code unit
        -:  690: */
        -:  691:lit_utf8_size_t
    #####:  692:lit_code_unit_to_utf8 (ecma_char_t code_unit, /**< code unit */
        -:  693:                       lit_utf8_byte_t *buf_p) /**< buffer where to store the result and its size
        -:  694:                                                *   should be at least LIT_UTF8_MAX_BYTES_IN_CODE_UNIT */
        -:  695:{
    #####:  696:  if (code_unit <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  697:  {
    #####:  698:    buf_p[0] = (lit_utf8_byte_t) code_unit;
    #####:  699:    return 1;
        -:  700:  }
    #####:  701:  else if (code_unit <= LIT_UTF8_2_BYTE_CODE_POINT_MAX)
        -:  702:  {
    #####:  703:    uint32_t code_unit_bits = code_unit;
    #####:  704:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  705:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  706:
    #####:  707:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_5_BITS_MASK);
    #####:  708:    JERRY_ASSERT (first_byte_bits == code_unit_bits);
        -:  709:
    #####:  710:    buf_p[0] = LIT_UTF8_2_BYTE_MARKER | first_byte_bits;
    #####:  711:    buf_p[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  712:    return 2;
        -:  713:  }
        -:  714:  else
        -:  715:  {
    #####:  716:    uint32_t code_unit_bits = code_unit;
    #####:  717:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  718:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  719:
    #####:  720:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  721:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  722:
    #####:  723:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_4_BITS_MASK);
    #####:  724:    JERRY_ASSERT (first_byte_bits == code_unit_bits);
        -:  725:
    #####:  726:    buf_p[0] = LIT_UTF8_3_BYTE_MARKER | first_byte_bits;
    #####:  727:    buf_p[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  728:    buf_p[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  729:    return 3;
        -:  730:  }
        -:  731:} /* lit_code_unit_to_utf8 */
        -:  732:
        -:  733:/**
        -:  734: * Convert code point to cesu-8 representation
        -:  735: *
        -:  736: * @return byte count required to represent the code point
        -:  737: */
        -:  738:lit_utf8_size_t
    #####:  739:lit_code_point_to_cesu8 (lit_code_point_t code_point, /**< code point */
        -:  740:                         lit_utf8_byte_t *buf) /**< buffer where to store the result,
        -:  741:                                                *   its size should be at least 6 bytes */
        -:  742:{
    #####:  743:  if (code_point <= LIT_UTF16_CODE_UNIT_MAX)
        -:  744:  {
    #####:  745:    return lit_code_unit_to_utf8 ((ecma_char_t) code_point, buf);
        -:  746:  }
        -:  747:  else
        -:  748:  {
    #####:  749:    lit_utf8_size_t offset = lit_code_unit_to_utf8 (convert_code_point_to_high_surrogate (code_point), buf);
    #####:  750:    offset += lit_code_unit_to_utf8 (convert_code_point_to_low_surrogate (code_point), buf + offset);
    #####:  751:    return offset;
        -:  752:  }
        -:  753:} /* lit_code_point_to_cesu8 */
        -:  754:
        -:  755:/**
        -:  756: * Convert code point to utf-8 representation
        -:  757: *
        -:  758: * @return byte count required to represent the code point
        -:  759: */
        -:  760:lit_utf8_size_t
    #####:  761:lit_code_point_to_utf8 (lit_code_point_t code_point, /**< code point */
        -:  762:                        lit_utf8_byte_t *buf) /**< buffer where to store the result,
        -:  763:                                               *   its size should be at least 4 bytes */
        -:  764:{
    #####:  765:  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  766:  {
    #####:  767:    buf[0] = (lit_utf8_byte_t) code_point;
    #####:  768:    return 1;
        -:  769:  }
    #####:  770:  else if (code_point <= LIT_UTF8_2_BYTE_CODE_POINT_MAX)
        -:  771:  {
    #####:  772:    uint32_t code_point_bits = code_point;
    #####:  773:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  774:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  775:
    #####:  776:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_5_BITS_MASK);
    #####:  777:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  778:
    #####:  779:    buf[0] = LIT_UTF8_2_BYTE_MARKER | first_byte_bits;
    #####:  780:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  781:    return 2;
        -:  782:  }
    #####:  783:  else if (code_point <= LIT_UTF8_3_BYTE_CODE_POINT_MAX)
        -:  784:  {
    #####:  785:    uint32_t code_point_bits = code_point;
    #####:  786:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  787:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  788:
    #####:  789:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  790:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  791:
    #####:  792:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_4_BITS_MASK);
    #####:  793:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  794:
    #####:  795:    buf[0] = LIT_UTF8_3_BYTE_MARKER | first_byte_bits;
    #####:  796:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  797:    buf[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  798:    return 3;
        -:  799:  }
        -:  800:  else
        -:  801:  {
    #####:  802:    JERRY_ASSERT (code_point <= LIT_UTF8_4_BYTE_CODE_POINT_MAX);
        -:  803:
    #####:  804:    uint32_t code_point_bits = code_point;
    #####:  805:    lit_utf8_byte_t fourth_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  806:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  807:
    #####:  808:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  809:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  810:
    #####:  811:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  812:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  813:
    #####:  814:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_3_BITS_MASK);
    #####:  815:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  816:
    #####:  817:    buf[0] = LIT_UTF8_4_BYTE_MARKER | first_byte_bits;
    #####:  818:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  819:    buf[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  820:    buf[3] = LIT_UTF8_EXTRA_BYTE_MARKER | fourth_byte_bits;
    #####:  821:    return 4;
        -:  822:  }
        -:  823:} /* lit_code_point_to_utf8 */
        -:  824:
        -:  825:/**
        -:  826: * Convert cesu-8 string to an utf-8 string and put it into the buffer.
        -:  827: * String will be truncated to fit the buffer.
        -:  828: *
        -:  829: * @return number of bytes copied to the buffer.
        -:  830: */
        -:  831:lit_utf8_size_t
    #####:  832:lit_convert_cesu8_string_to_utf8_string (const lit_utf8_byte_t *cesu8_string_p, /**< cesu-8 string */
        -:  833:                                         lit_utf8_size_t cesu8_size, /**< size of cesu-8 string */
        -:  834:                                         lit_utf8_byte_t *utf8_string_p, /**< destination utf-8 buffer pointer
        -:  835:                                                                          * (can be NULL if buffer_size == 0) */
        -:  836:                                         lit_utf8_size_t utf8_size) /**< size of utf-8 buffer */
        -:  837:{
    #####:  838:  const lit_utf8_byte_t *cesu8_cursor_p = cesu8_string_p;
    #####:  839:  const lit_utf8_byte_t *cesu8_end_p = cesu8_string_p + cesu8_size;
        -:  840:
    #####:  841:  lit_utf8_byte_t *utf8_cursor_p = utf8_string_p;
    #####:  842:  lit_utf8_byte_t *utf8_end_p = utf8_string_p + utf8_size;
        -:  843:
    #####:  844:  while (cesu8_cursor_p < cesu8_end_p)
        -:  845:  {
    #####:  846:    lit_code_point_t cp;
    #####:  847:    lit_utf8_size_t read_size = lit_read_code_point_from_cesu8 (cesu8_cursor_p, cesu8_end_p, &cp);
    #####:  848:    lit_utf8_size_t encoded_size = (cp >= LIT_UTF16_FIRST_SURROGATE_CODE_POINT) ? 4 : read_size;
        -:  849:
    #####:  850:    if (utf8_cursor_p + encoded_size > utf8_end_p)
        -:  851:    {
    #####:  852:      break;
        -:  853:    }
        -:  854:
    #####:  855:    if (cp >= LIT_UTF16_FIRST_SURROGATE_CODE_POINT)
        -:  856:    {
    #####:  857:      lit_code_point_to_utf8 (cp, utf8_cursor_p);
        -:  858:    }
        -:  859:    else
        -:  860:    {
    #####:  861:      memcpy (utf8_cursor_p, cesu8_cursor_p, encoded_size);
        -:  862:    }
        -:  863:
    #####:  864:    utf8_cursor_p += encoded_size;
    #####:  865:    cesu8_cursor_p += read_size;
        -:  866:  }
        -:  867:
    #####:  868:  JERRY_ASSERT (cesu8_cursor_p == cesu8_end_p);
    #####:  869:  JERRY_ASSERT (utf8_cursor_p <= utf8_end_p);
        -:  870:
    #####:  871:  return (lit_utf8_byte_t) (utf8_cursor_p - utf8_string_p);
        -:  872:} /* lit_convert_cesu8_string_to_utf8_string */
        -:  873:
        -:  874:/**
        -:  875: * Convert surrogate pair to code point
        -:  876: *
        -:  877: * @return code point
        -:  878: */
        -:  879:lit_code_point_t
    #####:  880:lit_convert_surrogate_pair_to_code_point (ecma_char_t high_surrogate, /**< high surrogate code point */
        -:  881:                                          ecma_char_t low_surrogate) /**< low surrogate code point */
        -:  882:{
    #####:  883:  JERRY_ASSERT (lit_is_code_point_utf16_high_surrogate (high_surrogate));
    #####:  884:  JERRY_ASSERT (lit_is_code_point_utf16_low_surrogate (low_surrogate));
        -:  885:
        -:  886:  lit_code_point_t code_point;
    #####:  887:  code_point = (uint16_t) (high_surrogate - LIT_UTF16_HIGH_SURROGATE_MIN);
    #####:  888:  code_point <<= LIT_UTF16_BITS_IN_SURROGATE;
        -:  889:
    #####:  890:  code_point += LIT_UTF16_FIRST_SURROGATE_CODE_POINT;
        -:  891:
    #####:  892:  code_point |= (uint16_t) (low_surrogate - LIT_UTF16_LOW_SURROGATE_MIN);
    #####:  893:  return code_point;
        -:  894:} /* lit_convert_surrogate_pair_to_code_point */
        -:  895:
        -:  896:/**
        -:  897: * Relational compare of cesu-8 strings
        -:  898: *
        -:  899: * First string is less than second string if:
        -:  900: *  - strings are not equal;
        -:  901: *  - first string is prefix of second or is lexicographically less than second.
        -:  902: *
        -:  903: * @return true - if first string is less than second string,
        -:  904: *         false - otherwise
        -:  905: */
        -:  906:bool
    #####:  907:lit_compare_utf8_strings_relational (const lit_utf8_byte_t *string1_p, /**< utf-8 string */
        -:  908:                                     lit_utf8_size_t string1_size, /**< string size */
        -:  909:                                     const lit_utf8_byte_t *string2_p, /**< utf-8 string */
        -:  910:                                     lit_utf8_size_t string2_size) /**< string size */
        -:  911:{
    #####:  912:  lit_utf8_byte_t *string1_pos = (lit_utf8_byte_t *) string1_p;
    #####:  913:  lit_utf8_byte_t *string2_pos = (lit_utf8_byte_t *) string2_p;
    #####:  914:  const lit_utf8_byte_t *string1_end_p = string1_p + string1_size;
    #####:  915:  const lit_utf8_byte_t *string2_end_p = string2_p + string2_size;
        -:  916:
    #####:  917:  while (string1_pos < string1_end_p && string2_pos < string2_end_p)
        -:  918:  {
    #####:  919:    ecma_char_t ch1, ch2;
    #####:  920:    string1_pos += lit_read_code_unit_from_cesu8 (string1_pos, &ch1);
    #####:  921:    string2_pos += lit_read_code_unit_from_cesu8 (string2_pos, &ch2);
        -:  922:
    #####:  923:    if (ch1 < ch2)
        -:  924:    {
    #####:  925:      return true;
        -:  926:    }
    #####:  927:    else if (ch1 > ch2)
        -:  928:    {
    #####:  929:      return false;
        -:  930:    }
        -:  931:  }
        -:  932:
    #####:  933:  return (string1_pos >= string1_end_p && string2_pos < string2_end_p);
        -:  934:} /* lit_compare_utf8_strings_relational */
