        -:    0:Source:/home/workspace/jerry-core/parser/regexp/re-parser.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "re-parser.h"
        -:   17:
        -:   18:#include "ecma-exceptions.h"
        -:   19:#include "ecma-globals.h"
        -:   20:
        -:   21:#include "jcontext.h"
        -:   22:#include "jrt-libc-includes.h"
        -:   23:#include "lit-char-helpers.h"
        -:   24:#include "re-compiler.h"
        -:   25:
        -:   26:#if JERRY_BUILTIN_REGEXP
        -:   27:
        -:   28:/** \addtogroup parser Parser
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup regexparser Regular expression
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup regexparser_parser Parser
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:/**
        -:   39: * Get the start opcode for the current group.
        -:   40: *
        -:   41: * @return RegExp opcode
        -:   42: */
        -:   43:static re_opcode_t
    #####:   44:re_get_group_start_opcode (bool is_capturing) /**< is capturing group */
        -:   45:{
    #####:   46:  return (is_capturing) ? RE_OP_CAPTURING_GROUP_START : RE_OP_NON_CAPTURING_GROUP_START;
        -:   47:} /* re_get_group_start_opcode */
        -:   48:
        -:   49:/**
        -:   50: * Get the end opcode for the current group.
        -:   51: *
        -:   52: * @return RegExp opcode
        -:   53: */
        -:   54:static re_opcode_t
    #####:   55:re_get_group_end_opcode (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:   56:                         bool is_capturing) /**< is capturing group */
        -:   57:{
    #####:   58:  if (is_capturing)
        -:   59:  {
    #####:   60:    if (re_ctx_p->token.greedy)
        -:   61:    {
    #####:   62:      return RE_OP_GREEDY_CAPTURING_GROUP_END;
        -:   63:    }
        -:   64:
    #####:   65:    return RE_OP_LAZY_CAPTURING_GROUP_END;
        -:   66:  }
        -:   67:
    #####:   68:  if (re_ctx_p->token.greedy)
        -:   69:  {
    #####:   70:    return RE_OP_GREEDY_NON_CAPTURING_GROUP_END;
        -:   71:  }
        -:   72:
    #####:   73:  return RE_OP_LAZY_NON_CAPTURING_GROUP_END;
        -:   74:} /* re_get_group_end_opcode */
        -:   75:
        -:   76:/**
        -:   77: * Enclose the given bytecode to a group.
        -:   78: */
        -:   79:static void
    #####:   80:re_insert_into_group (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:   81:                      uint32_t group_start_offset, /**< offset of group start */
        -:   82:                      uint32_t idx, /**< index of group */
        -:   83:                      uint32_t capture_start, /**< index of first nested capture */
        -:   84:                      bool is_capturing) /**< is capturing group */
        -:   85:{
    #####:   86:  uint32_t qmin = re_ctx_p->token.qmin;
    #####:   87:  uint32_t qmax = re_ctx_p->token.qmax;
        -:   88:
    #####:   89:  if (JERRY_UNLIKELY (!is_capturing && re_bytecode_size (re_ctx_p) == group_start_offset))
        -:   90:  {
    #####:   91:    return;
        -:   92:  }
        -:   93:
    #####:   94:  if (qmin == 0)
        -:   95:  {
    #####:   96:    re_insert_value (re_ctx_p, group_start_offset, re_bytecode_size (re_ctx_p) - group_start_offset);
        -:   97:  }
        -:   98:
    #####:   99:  re_insert_value (re_ctx_p, group_start_offset, qmin);
    #####:  100:  re_insert_value (re_ctx_p, group_start_offset, re_ctx_p->captures_count - capture_start);
        -:  101:
    #####:  102:  if (!is_capturing)
        -:  103:  {
    #####:  104:    re_insert_value (re_ctx_p, group_start_offset, capture_start);
        -:  105:  }
        -:  106:  else
        -:  107:  {
    #####:  108:    JERRY_ASSERT (idx == capture_start);
        -:  109:  }
        -:  110:
    #####:  111:  re_insert_value (re_ctx_p, group_start_offset, idx);
    #####:  112:  re_insert_opcode (re_ctx_p, group_start_offset, re_get_group_start_opcode (is_capturing));
        -:  113:
    #####:  114:  re_append_opcode (re_ctx_p, re_get_group_end_opcode (re_ctx_p, is_capturing));
    #####:  115:  re_append_value (re_ctx_p, idx);
    #####:  116:  re_append_value (re_ctx_p, qmin);
    #####:  117:  re_append_value (re_ctx_p, qmax + RE_QMAX_OFFSET);
        -:  118:} /* re_insert_into_group */
        -:  119:
        -:  120:/**
        -:  121: * Insert simple atom iterator.
        -:  122: */
        -:  123:static void
    #####:  124:re_insert_atom_iterator (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  125:                         uint32_t start_offset) /**< atom start offset */
        -:  126:{
    #####:  127:  const uint32_t qmin = re_ctx_p->token.qmin;
    #####:  128:  const uint32_t qmax = re_ctx_p->token.qmax;
        -:  129:
    #####:  130:  if (qmin == 1 && qmax == 1)
        -:  131:  {
    #####:  132:    return;
        -:  133:  }
        -:  134:
    #####:  135:  re_append_opcode (re_ctx_p, RE_OP_ITERATOR_END);
    #####:  136:  re_insert_value (re_ctx_p, start_offset, re_bytecode_size (re_ctx_p) - start_offset);
    #####:  137:  re_insert_value (re_ctx_p, start_offset, qmax + RE_QMAX_OFFSET);
    #####:  138:  re_insert_value (re_ctx_p, start_offset, qmin);
    #####:  139:  re_insert_opcode (re_ctx_p, start_offset, re_ctx_p->token.greedy ? RE_OP_GREEDY_ITERATOR : RE_OP_LAZY_ITERATOR);
        -:  140:} /* re_insert_atom_iterator */
        -:  141:
        -:  142:/**
        -:  143: * Insert a lookahead assertion.
        -:  144: */
        -:  145:static void
    #####:  146:re_insert_assertion_lookahead (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  147:                               uint32_t start_offset, /**< atom start offset */
        -:  148:                               uint32_t capture_start, /**< index of first nested capture */
        -:  149:                               bool negative) /** lookahead type */
        -:  150:{
    #####:  151:  const uint32_t qmin = re_ctx_p->token.qmin;
        -:  152:
    #####:  153:  re_append_opcode (re_ctx_p, RE_OP_ASSERT_END);
    #####:  154:  re_insert_value (re_ctx_p, start_offset, re_bytecode_size (re_ctx_p) - start_offset);
        -:  155:
        -:  156:  /* We need to clear nested capturing group results when a negative assertion or the tail after a positive assertion
        -:  157:   * does not match, so we store the begin and end index of nested capturing groups. */
    #####:  158:  re_insert_value (re_ctx_p, start_offset, re_ctx_p->captures_count - capture_start);
    #####:  159:  re_insert_value (re_ctx_p, start_offset, capture_start);
        -:  160:
        -:  161:  /* Lookaheads always result in zero length matches, which means iterations will always stop on the first match.
        -:  162:   * This allows us to not have to deal with iterations beyond one. Either qmin == 0 which will implicitly match,
        -:  163:   * or qmin > 0, in which case the first iteration will decide whether the assertion matches depending on whether
        -:  164:   * the iteration matched or not. This also allows us to ignore qmax entirely. */
    #####:  165:  re_insert_byte (re_ctx_p, start_offset, (uint8_t) JERRY_MIN (qmin, 1));
        -:  166:
    #####:  167:  const re_opcode_t opcode = (negative) ? RE_OP_ASSERT_LOOKAHEAD_NEG : RE_OP_ASSERT_LOOKAHEAD_POS;
    #####:  168:  re_insert_opcode (re_ctx_p, start_offset, opcode);
    #####:  169:} /* re_insert_assertion_lookahead */
        -:  170:
        -:  171:/**
        -:  172: * Consume non greedy (question mark) character if present.
        -:  173: */
        -:  174:static void
    #####:  175:re_parse_lazy_char (re_compiler_ctx_t *re_ctx_p) /**< RegExp parser context */
        -:  176:{
    #####:  177:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && *re_ctx_p->input_curr_p == LIT_CHAR_QUESTION)
        -:  178:  {
    #####:  179:    re_ctx_p->input_curr_p++;
    #####:  180:    re_ctx_p->token.greedy = false;
    #####:  181:    return;
        -:  182:  }
        -:  183:
    #####:  184:  re_ctx_p->token.greedy = true;
        -:  185:} /* re_parse_lazy_char */
        -:  186:
        -:  187:/**
        -:  188: * Parse a max 3 digit long octal number from the input string, with a decimal value less than 256.
        -:  189: *
        -:  190: * @return value of the octal number
        -:  191: */
        -:  192:static uint32_t
    #####:  193:re_parse_octal (re_compiler_ctx_t *re_ctx_p) /**< RegExp parser context */
        -:  194:{
    #####:  195:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  196:  JERRY_ASSERT (lit_char_is_octal_digit (*re_ctx_p->input_curr_p));
        -:  197:
    #####:  198:  uint32_t value = (uint32_t) (*re_ctx_p->input_curr_p++) - LIT_CHAR_0;
        -:  199:
    #####:  200:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  201:  {
    #####:  202:    value = value * 8 + (*re_ctx_p->input_curr_p++) - LIT_CHAR_0;
        -:  203:  }
        -:  204:
    #####:  205:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  206:  {
    #####:  207:    const uint32_t new_value = value * 8 + (*re_ctx_p->input_curr_p) - LIT_CHAR_0;
        -:  208:
    #####:  209:    if (new_value <= RE_MAX_OCTAL_VALUE)
        -:  210:    {
    #####:  211:      value = new_value;
    #####:  212:      re_ctx_p->input_curr_p++;
        -:  213:    }
        -:  214:  }
        -:  215:
    #####:  216:  return value;
        -:  217:} /* re_parse_octal */
        -:  218:
        -:  219:/**
        -:  220: * Check that the currently parsed quantifier is valid.
        -:  221: *
        -:  222: * @return ECMA_VALUE_ERROR, if quantifier is invalid
        -:  223: *         ECMA_VALUE_EMPTY, otherwise
        -:  224: */
        -:  225:static ecma_value_t
    #####:  226:re_check_quantifier (re_compiler_ctx_t *re_ctx_p)
        -:  227:{
    #####:  228:  if (re_ctx_p->token.qmin > re_ctx_p->token.qmax)
        -:  229:  {
        -:  230:    /* ECMA-262 v5.1 15.10.2.5 */
    #####:  231:    return ecma_raise_syntax_error (ECMA_ERR_MIN_GREATER_THAN_MAX);
        -:  232:  }
        -:  233:
    #####:  234:  return ECMA_VALUE_EMPTY;
        -:  235:} /* re_check_quantifier */
        -:  236:
        -:  237:/**
        -:  238: * Parse RegExp quantifier.
        -:  239: *
        -:  240: * @return ECMA_VALUE_TRUE - if parsed successfully
        -:  241: *         ECMA_VALUE_FALSE - otherwise
        -:  242: */
        -:  243:static ecma_value_t
    #####:  244:re_parse_quantifier (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  245:{
    #####:  246:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p)
        -:  247:  {
    #####:  248:    switch (*re_ctx_p->input_curr_p)
        -:  249:    {
    #####:  250:      case LIT_CHAR_QUESTION:
        -:  251:      {
    #####:  252:        re_ctx_p->input_curr_p++;
    #####:  253:        re_ctx_p->token.qmin = 0;
    #####:  254:        re_ctx_p->token.qmax = 1;
        -:  255:
    #####:  256:        re_parse_lazy_char (re_ctx_p);
    #####:  257:        return ECMA_VALUE_TRUE;
        -:  258:      }
    #####:  259:      case LIT_CHAR_ASTERISK:
        -:  260:      {
    #####:  261:        re_ctx_p->input_curr_p++;
    #####:  262:        re_ctx_p->token.qmin = 0;
    #####:  263:        re_ctx_p->token.qmax = RE_INFINITY;
        -:  264:
    #####:  265:        re_parse_lazy_char (re_ctx_p);
    #####:  266:        return ECMA_VALUE_TRUE;
        -:  267:      }
    #####:  268:      case LIT_CHAR_PLUS:
        -:  269:      {
    #####:  270:        re_ctx_p->input_curr_p++;
    #####:  271:        re_ctx_p->token.qmin = 1;
    #####:  272:        re_ctx_p->token.qmax = RE_INFINITY;
        -:  273:
    #####:  274:        re_parse_lazy_char (re_ctx_p);
    #####:  275:        return ECMA_VALUE_TRUE;
        -:  276:      }
    #####:  277:      case LIT_CHAR_LEFT_BRACE:
        -:  278:      {
    #####:  279:        const lit_utf8_byte_t *current_p = re_ctx_p->input_curr_p + 1;
    #####:  280:        uint32_t qmin = 0;
    #####:  281:        uint32_t qmax = RE_INFINITY;
        -:  282:
    #####:  283:        if (current_p >= re_ctx_p->input_end_p)
        -:  284:        {
    #####:  285:          break;
        -:  286:        }
        -:  287:
    #####:  288:        if (!lit_char_is_decimal_digit (*current_p))
        -:  289:        {
    #####:  290:          break;
        -:  291:        }
        -:  292:
    #####:  293:        qmin = lit_parse_decimal (&current_p, re_ctx_p->input_end_p);
        -:  294:
    #####:  295:        if (current_p >= re_ctx_p->input_end_p)
        -:  296:        {
    #####:  297:          break;
        -:  298:        }
        -:  299:
    #####:  300:        lit_utf8_byte_t ch = *current_p++;
    #####:  301:        if (ch == LIT_CHAR_RIGHT_BRACE)
        -:  302:        {
    #####:  303:          qmax = qmin;
        -:  304:        }
    #####:  305:        else if (ch == LIT_CHAR_COMMA)
        -:  306:        {
    #####:  307:          if (current_p >= re_ctx_p->input_end_p)
        -:  308:          {
    #####:  309:            break;
        -:  310:          }
        -:  311:
    #####:  312:          if (lit_char_is_decimal_digit (*current_p))
        -:  313:          {
    #####:  314:            qmax = lit_parse_decimal (&current_p, re_ctx_p->input_end_p);
        -:  315:          }
        -:  316:
    #####:  317:          if (current_p >= re_ctx_p->input_end_p || *current_p++ != LIT_CHAR_RIGHT_BRACE)
        -:  318:          {
        -:  319:            break;
        -:  320:          }
        -:  321:        }
        -:  322:        else
        -:  323:        {
    #####:  324:          break;
        -:  325:        }
        -:  326:
    #####:  327:        re_ctx_p->token.qmin = qmin;
    #####:  328:        re_ctx_p->token.qmax = qmax;
    #####:  329:        re_ctx_p->input_curr_p = current_p;
    #####:  330:        re_parse_lazy_char (re_ctx_p);
    #####:  331:        return ECMA_VALUE_TRUE;
        -:  332:      }
    #####:  333:      default:
        -:  334:      {
    #####:  335:        break;
        -:  336:      }
        -:  337:    }
    #####:  338:  }
        -:  339:
    #####:  340:  re_ctx_p->token.qmin = 1;
    #####:  341:  re_ctx_p->token.qmax = 1;
    #####:  342:  re_ctx_p->token.greedy = true;
        -:  343:
    #####:  344:  return ECMA_VALUE_FALSE;
        -:  345:} /* re_parse_quantifier */
        -:  346:
        -:  347:/**
        -:  348: * Count the number of groups in the current pattern.
        -:  349: */
        -:  350:static void
    #####:  351:re_count_groups (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  352:{
    #####:  353:  bool is_char_class = 0;
    #####:  354:  re_ctx_p->groups_count = 0;
    #####:  355:  const lit_utf8_byte_t *curr_p = re_ctx_p->input_start_p;
        -:  356:
    #####:  357:  while (curr_p < re_ctx_p->input_end_p)
        -:  358:  {
    #####:  359:    switch (*curr_p++)
        -:  360:    {
    #####:  361:      case LIT_CHAR_BACKSLASH:
        -:  362:      {
    #####:  363:        if (curr_p < re_ctx_p->input_end_p)
        -:  364:        {
    #####:  365:          lit_utf8_incr (&curr_p);
        -:  366:        }
    #####:  367:        break;
        -:  368:      }
    #####:  369:      case LIT_CHAR_LEFT_SQUARE:
        -:  370:      {
    #####:  371:        is_char_class = true;
    #####:  372:        break;
        -:  373:      }
    #####:  374:      case LIT_CHAR_RIGHT_SQUARE:
        -:  375:      {
    #####:  376:        is_char_class = false;
    #####:  377:        break;
        -:  378:      }
    #####:  379:      case LIT_CHAR_LEFT_PAREN:
        -:  380:      {
    #####:  381:        if (curr_p < re_ctx_p->input_end_p && *curr_p != LIT_CHAR_QUESTION && !is_char_class)
        -:  382:        {
    #####:  383:          re_ctx_p->groups_count++;
        -:  384:        }
    #####:  385:        break;
        -:  386:      }
        -:  387:    }
        -:  388:  }
    #####:  389:} /* re_count_groups */
        -:  390:
        -:  391:#if JERRY_ESNEXT
        -:  392:/**
        -:  393: * Check if a code point is a Syntax character
        -:  394: *
        -:  395: * @return true, if syntax character
        -:  396: *         false, otherwise
        -:  397: */
        -:  398:static bool
    #####:  399:re_is_syntax_char (lit_code_point_t cp) /**< code point */
        -:  400:{
    #####:  401:  return (cp == LIT_CHAR_CIRCUMFLEX || cp == LIT_CHAR_DOLLAR_SIGN || cp == LIT_CHAR_BACKSLASH || cp == LIT_CHAR_DOT
    #####:  402:          || cp == LIT_CHAR_ASTERISK || cp == LIT_CHAR_PLUS || cp == LIT_CHAR_QUESTION || cp == LIT_CHAR_LEFT_PAREN
    #####:  403:          || cp == LIT_CHAR_RIGHT_PAREN || cp == LIT_CHAR_LEFT_SQUARE || cp == LIT_CHAR_RIGHT_SQUARE
    #####:  404:          || cp == LIT_CHAR_LEFT_BRACE || cp == LIT_CHAR_RIGHT_BRACE || cp == LIT_CHAR_VLINE);
        -:  405:} /* re_is_syntax_char */
        -:  406:#endif /* JERRY_ESNEXT */
        -:  407:
        -:  408:/**
        -:  409: * Parse a Character Escape or a Character Class Escape.
        -:  410: *
        -:  411: * @return ECMA_VALUE_EMPTY, if parsed successfully
        -:  412: *         ECMA_VALUE_ERROR, otherwise
        -:  413: */
        -:  414:static ecma_value_t
    #####:  415:re_parse_char_escape (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  416:{
    #####:  417:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  418:  re_ctx_p->token.type = RE_TOK_CHAR;
        -:  419:
    #####:  420:  if (lit_char_is_decimal_digit (*re_ctx_p->input_curr_p))
        -:  421:  {
        -:  422:    /* NULL code point escape, only valid if there are no following digits. */
    #####:  423:    if (*re_ctx_p->input_curr_p == LIT_CHAR_0
    #####:  424:        && (re_ctx_p->input_curr_p + 1 >= re_ctx_p->input_end_p
    #####:  425:            || !lit_char_is_decimal_digit (re_ctx_p->input_curr_p[1])))
        -:  426:    {
    #####:  427:      re_ctx_p->input_curr_p++;
    #####:  428:      re_ctx_p->token.value = LIT_UNICODE_CODE_POINT_NULL;
    #####:  429:      return ECMA_VALUE_EMPTY;
        -:  430:    }
        -:  431:
        -:  432:#if JERRY_ESNEXT
    #####:  433:    if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  434:    {
    #####:  435:      return ecma_raise_syntax_error (ECMA_ERR_INVALID_ESCAPE_SEQUENCE);
        -:  436:    }
        -:  437:#endif /* JERRY_ESNEXT */
        -:  438:
        -:  439:    /* Legacy octal escape sequence */
    #####:  440:    if (lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  441:    {
    #####:  442:      re_ctx_p->token.value = re_parse_octal (re_ctx_p);
    #####:  443:      return ECMA_VALUE_EMPTY;
        -:  444:    }
        -:  445:
        -:  446:    /* Identity escape */
    #####:  447:    re_ctx_p->token.value = *re_ctx_p->input_curr_p++;
    #####:  448:    return ECMA_VALUE_EMPTY;
        -:  449:  }
        -:  450:
    #####:  451:  lit_code_point_t ch = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
    #####:  452:  switch (ch)
        -:  453:  {
        -:  454:    /* Character Class escapes */
    #####:  455:    case LIT_CHAR_LOWERCASE_D:
        -:  456:    {
    #####:  457:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  458:      re_ctx_p->token.value = RE_ESCAPE_DIGIT;
    #####:  459:      break;
        -:  460:    }
    #####:  461:    case LIT_CHAR_UPPERCASE_D:
        -:  462:    {
    #####:  463:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  464:      re_ctx_p->token.value = RE_ESCAPE_NOT_DIGIT;
    #####:  465:      break;
        -:  466:    }
    #####:  467:    case LIT_CHAR_LOWERCASE_S:
        -:  468:    {
    #####:  469:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  470:      re_ctx_p->token.value = RE_ESCAPE_WHITESPACE;
    #####:  471:      break;
        -:  472:    }
    #####:  473:    case LIT_CHAR_UPPERCASE_S:
        -:  474:    {
    #####:  475:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  476:      re_ctx_p->token.value = RE_ESCAPE_NOT_WHITESPACE;
    #####:  477:      break;
        -:  478:    }
    #####:  479:    case LIT_CHAR_LOWERCASE_W:
        -:  480:    {
    #####:  481:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  482:      re_ctx_p->token.value = RE_ESCAPE_WORD_CHAR;
    #####:  483:      break;
        -:  484:    }
    #####:  485:    case LIT_CHAR_UPPERCASE_W:
        -:  486:    {
    #####:  487:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  488:      re_ctx_p->token.value = RE_ESCAPE_NOT_WORD_CHAR;
    #####:  489:      break;
        -:  490:    }
        -:  491:    /* Control escapes */
    #####:  492:    case LIT_CHAR_LOWERCASE_F:
        -:  493:    {
    #####:  494:      re_ctx_p->token.value = LIT_CHAR_FF;
    #####:  495:      break;
        -:  496:    }
    #####:  497:    case LIT_CHAR_LOWERCASE_N:
        -:  498:    {
    #####:  499:      re_ctx_p->token.value = LIT_CHAR_LF;
    #####:  500:      break;
        -:  501:    }
    #####:  502:    case LIT_CHAR_LOWERCASE_R:
        -:  503:    {
    #####:  504:      re_ctx_p->token.value = LIT_CHAR_CR;
    #####:  505:      break;
        -:  506:    }
    #####:  507:    case LIT_CHAR_LOWERCASE_T:
        -:  508:    {
    #####:  509:      re_ctx_p->token.value = LIT_CHAR_TAB;
    #####:  510:      break;
        -:  511:    }
    #####:  512:    case LIT_CHAR_LOWERCASE_V:
        -:  513:    {
    #####:  514:      re_ctx_p->token.value = LIT_CHAR_VTAB;
    #####:  515:      break;
        -:  516:    }
        -:  517:    /* Control letter */
    #####:  518:    case LIT_CHAR_LOWERCASE_C:
        -:  519:    {
    #####:  520:      if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p)
        -:  521:      {
    #####:  522:        ch = *re_ctx_p->input_curr_p;
        -:  523:
    #####:  524:        if ((ch >= LIT_CHAR_ASCII_UPPERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_UPPERCASE_LETTERS_END)
    #####:  525:            || (ch >= LIT_CHAR_ASCII_LOWERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_LOWERCASE_LETTERS_END))
        -:  526:        {
    #####:  527:          re_ctx_p->token.value = (ch % 32);
    #####:  528:          re_ctx_p->input_curr_p++;
        -:  529:
    #####:  530:          break;
        -:  531:        }
        -:  532:      }
        -:  533:
        -:  534:#if JERRY_ESNEXT
    #####:  535:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  536:      {
    #####:  537:        return ecma_raise_syntax_error (ECMA_ERR_INVALID_CONTROL_ESCAPE_SEQUENCE);
        -:  538:      }
        -:  539:#endif /* JERRY_ESNEXT */
        -:  540:
    #####:  541:      re_ctx_p->token.value = LIT_CHAR_BACKSLASH;
    #####:  542:      re_ctx_p->input_curr_p--;
        -:  543:
    #####:  544:      break;
        -:  545:    }
        -:  546:    /* Hex escape */
    #####:  547:    case LIT_CHAR_LOWERCASE_X:
        -:  548:    {
    #####:  549:      uint32_t hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p, re_ctx_p->input_end_p, 2);
    #####:  550:      if (hex_value != UINT32_MAX)
        -:  551:      {
    #####:  552:        re_ctx_p->token.value = hex_value;
    #####:  553:        re_ctx_p->input_curr_p += 2;
    #####:  554:        break;
        -:  555:      }
        -:  556:
        -:  557:#if JERRY_ESNEXT
    #####:  558:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  559:      {
    #####:  560:        return ecma_raise_syntax_error (ECMA_ERR_INVALID_HEX_ESCAPE_SEQUENCE);
        -:  561:      }
        -:  562:#endif /* JERRY_ESNEXT */
        -:  563:
    #####:  564:      re_ctx_p->token.value = LIT_CHAR_LOWERCASE_X;
    #####:  565:      break;
        -:  566:    }
        -:  567:    /* Unicode escape */
    #####:  568:    case LIT_CHAR_LOWERCASE_U:
        -:  569:    {
    #####:  570:      uint32_t hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p, re_ctx_p->input_end_p, 4);
    #####:  571:      if (hex_value != UINT32_MAX)
        -:  572:      {
    #####:  573:        re_ctx_p->token.value = hex_value;
    #####:  574:        re_ctx_p->input_curr_p += 4;
        -:  575:
        -:  576:#if JERRY_ESNEXT
    #####:  577:        if (re_ctx_p->flags & RE_FLAG_UNICODE && lit_is_code_point_utf16_high_surrogate (re_ctx_p->token.value)
    #####:  578:            && re_ctx_p->input_curr_p + 6 <= re_ctx_p->input_end_p && re_ctx_p->input_curr_p[0] == '\\'
    #####:  579:            && re_ctx_p->input_curr_p[1] == 'u')
        -:  580:        {
    #####:  581:          hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p + 2, re_ctx_p->input_end_p, 4);
    #####:  582:          if (lit_is_code_point_utf16_low_surrogate (hex_value))
        -:  583:          {
    #####:  584:            re_ctx_p->token.value =
    #####:  585:              lit_convert_surrogate_pair_to_code_point ((ecma_char_t) re_ctx_p->token.value, (ecma_char_t) hex_value);
    #####:  586:            re_ctx_p->input_curr_p += 6;
        -:  587:          }
        -:  588:        }
        -:  589:#endif /* JERRY_ESNEXT */
        -:  590:
    #####:  591:        break;
        -:  592:      }
        -:  593:
        -:  594:#if JERRY_ESNEXT
    #####:  595:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  596:      {
    #####:  597:        if (re_ctx_p->input_curr_p + 1 < re_ctx_p->input_end_p && re_ctx_p->input_curr_p[0] == LIT_CHAR_LEFT_BRACE
    #####:  598:            && lit_char_is_hex_digit (re_ctx_p->input_curr_p[1]))
        -:  599:        {
    #####:  600:          lit_code_point_t cp = lit_char_hex_to_int (re_ctx_p->input_curr_p[1]);
    #####:  601:          re_ctx_p->input_curr_p += 2;
        -:  602:
    #####:  603:          while (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && lit_char_is_hex_digit (*re_ctx_p->input_curr_p))
        -:  604:          {
    #####:  605:            cp = cp * 16 + lit_char_hex_to_int (*re_ctx_p->input_curr_p++);
        -:  606:
    #####:  607:            if (JERRY_UNLIKELY (cp > LIT_UNICODE_CODE_POINT_MAX))
        -:  608:            {
    #####:  609:              return ecma_raise_syntax_error (ECMA_ERR_INVALID_UNICODE_ESCAPE_SEQUENCE);
        -:  610:            }
        -:  611:          }
        -:  612:
    #####:  613:          if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && *re_ctx_p->input_curr_p == LIT_CHAR_RIGHT_BRACE)
        -:  614:          {
    #####:  615:            re_ctx_p->input_curr_p++;
    #####:  616:            re_ctx_p->token.value = cp;
    #####:  617:            break;
        -:  618:          }
        -:  619:        }
        -:  620:
    #####:  621:        return ecma_raise_syntax_error (ECMA_ERR_INVALID_UNICODE_ESCAPE_SEQUENCE);
        -:  622:      }
        -:  623:#endif /* JERRY_ESNEXT */
        -:  624:
    #####:  625:      re_ctx_p->token.value = LIT_CHAR_LOWERCASE_U;
    #####:  626:      break;
        -:  627:    }
        -:  628:    /* Identity escape */
    #####:  629:    default:
        -:  630:    {
        -:  631:#if JERRY_ESNEXT
        -:  632:      /* Must be '/', or one of SyntaxCharacter */
    #####:  633:      if (re_ctx_p->flags & RE_FLAG_UNICODE && ch != LIT_CHAR_SLASH && !re_is_syntax_char (ch))
        -:  634:      {
    #####:  635:        return ecma_raise_syntax_error (ECMA_ERR_INVALID_ESCAPE);
        -:  636:      }
        -:  637:#endif /* JERRY_ESNEXT */
    #####:  638:      re_ctx_p->token.value = ch;
        -:  639:    }
        -:  640:  }
        -:  641:
    #####:  642:  return ECMA_VALUE_EMPTY;
        -:  643:} /* re_parse_char_escape */
        -:  644:
        -:  645:/**
        -:  646: * Read the input pattern and parse the next token for the RegExp compiler
        -:  647: *
        -:  648: * @return empty ecma value - if parsed successfully
        -:  649: *         error ecma value - otherwise
        -:  650: *
        -:  651: *         Returned value must be freed with ecma_free_value
        -:  652: */
        -:  653:static ecma_value_t
    #####:  654:re_parse_next_token (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  655:{
    #####:  656:  if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  657:  {
    #####:  658:    re_ctx_p->token.type = RE_TOK_EOF;
    #####:  659:    return ECMA_VALUE_EMPTY;
        -:  660:  }
        -:  661:
    #####:  662:  ecma_char_t ch = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
        -:  663:
    #####:  664:  switch (ch)
        -:  665:  {
    #####:  666:    case LIT_CHAR_CIRCUMFLEX:
        -:  667:    {
    #####:  668:      re_ctx_p->token.type = RE_TOK_ASSERT_START;
    #####:  669:      return ECMA_VALUE_EMPTY;
        -:  670:    }
    #####:  671:    case LIT_CHAR_DOLLAR_SIGN:
        -:  672:    {
    #####:  673:      re_ctx_p->token.type = RE_TOK_ASSERT_END;
    #####:  674:      return ECMA_VALUE_EMPTY;
        -:  675:    }
    #####:  676:    case LIT_CHAR_VLINE:
        -:  677:    {
    #####:  678:      re_ctx_p->token.type = RE_TOK_ALTERNATIVE;
    #####:  679:      return ECMA_VALUE_EMPTY;
        -:  680:    }
    #####:  681:    case LIT_CHAR_DOT:
        -:  682:    {
    #####:  683:      re_ctx_p->token.type = RE_TOK_PERIOD;
        -:  684:      /* Check quantifier */
    #####:  685:      break;
        -:  686:    }
    #####:  687:    case LIT_CHAR_BACKSLASH:
        -:  688:    {
    #####:  689:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  690:      {
    #####:  691:        return ecma_raise_syntax_error (ECMA_ERR_INVALID_ESCAPE);
        -:  692:      }
        -:  693:
        -:  694:      /* DecimalEscape, Backreferences cannot start with a zero digit. */
    #####:  695:      if (*re_ctx_p->input_curr_p > LIT_CHAR_0 && *re_ctx_p->input_curr_p <= LIT_CHAR_9)
        -:  696:      {
    #####:  697:        const lit_utf8_byte_t *digits_p = re_ctx_p->input_curr_p;
    #####:  698:        const uint32_t value = lit_parse_decimal (&digits_p, re_ctx_p->input_end_p);
        -:  699:
    #####:  700:        if (re_ctx_p->groups_count < 0)
        -:  701:        {
    #####:  702:          re_count_groups (re_ctx_p);
        -:  703:        }
        -:  704:
    #####:  705:        if (value <= (uint32_t) re_ctx_p->groups_count)
        -:  706:        {
        -:  707:          /* Valid backreference */
    #####:  708:          re_ctx_p->input_curr_p = digits_p;
    #####:  709:          re_ctx_p->token.type = RE_TOK_BACKREFERENCE;
    #####:  710:          re_ctx_p->token.value = value;
        -:  711:
        -:  712:          /* Check quantifier */
    #####:  713:          break;
        -:  714:        }
        -:  715:      }
        -:  716:
    #####:  717:      if (*re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_B)
        -:  718:      {
    #####:  719:        re_ctx_p->input_curr_p++;
    #####:  720:        re_ctx_p->token.type = RE_TOK_ASSERT_WORD_BOUNDARY;
    #####:  721:        return ECMA_VALUE_EMPTY;
        -:  722:      }
    #####:  723:      else if (*re_ctx_p->input_curr_p == LIT_CHAR_UPPERCASE_B)
        -:  724:      {
    #####:  725:        re_ctx_p->input_curr_p++;
    #####:  726:        re_ctx_p->token.type = RE_TOK_ASSERT_NOT_WORD_BOUNDARY;
    #####:  727:        return ECMA_VALUE_EMPTY;
        -:  728:      }
        -:  729:
    #####:  730:      const ecma_value_t parse_result = re_parse_char_escape (re_ctx_p);
        -:  731:
    #####:  732:      if (ECMA_IS_VALUE_ERROR (parse_result))
        -:  733:      {
    #####:  734:        return parse_result;
        -:  735:      }
        -:  736:
        -:  737:      /* Check quantifier */
    #####:  738:      break;
        -:  739:    }
    #####:  740:    case LIT_CHAR_LEFT_PAREN:
        -:  741:    {
    #####:  742:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  743:      {
    #####:  744:        return ecma_raise_syntax_error (ECMA_ERR_UNTERMINATED_GROUP);
        -:  745:      }
        -:  746:
    #####:  747:      if (*re_ctx_p->input_curr_p == LIT_CHAR_QUESTION)
        -:  748:      {
    #####:  749:        re_ctx_p->input_curr_p++;
    #####:  750:        if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  751:        {
    #####:  752:          return ecma_raise_syntax_error (ECMA_ERR_INVALID_GROUP);
        -:  753:        }
        -:  754:
    #####:  755:        ch = *re_ctx_p->input_curr_p++;
        -:  756:
    #####:  757:        if (ch == LIT_CHAR_EQUALS)
        -:  758:        {
    #####:  759:          re_ctx_p->token.type = RE_TOK_ASSERT_LOOKAHEAD;
    #####:  760:          re_ctx_p->token.value = false;
        -:  761:        }
    #####:  762:        else if (ch == LIT_CHAR_EXCLAMATION)
        -:  763:        {
    #####:  764:          re_ctx_p->token.type = RE_TOK_ASSERT_LOOKAHEAD;
    #####:  765:          re_ctx_p->token.value = true;
        -:  766:        }
    #####:  767:        else if (ch == LIT_CHAR_COLON)
        -:  768:        {
    #####:  769:          re_ctx_p->token.type = RE_TOK_START_NON_CAPTURE_GROUP;
        -:  770:        }
        -:  771:        else
        -:  772:        {
    #####:  773:          return ecma_raise_syntax_error (ECMA_ERR_INVALID_GROUP);
        -:  774:        }
        -:  775:      }
        -:  776:      else
        -:  777:      {
    #####:  778:        re_ctx_p->token.type = RE_TOK_START_CAPTURE_GROUP;
        -:  779:      }
        -:  780:
    #####:  781:      return ECMA_VALUE_EMPTY;
        -:  782:    }
    #####:  783:    case LIT_CHAR_RIGHT_PAREN:
        -:  784:    {
    #####:  785:      re_ctx_p->token.type = RE_TOK_END_GROUP;
        -:  786:
    #####:  787:      return ECMA_VALUE_EMPTY;
        -:  788:    }
    #####:  789:    case LIT_CHAR_LEFT_SQUARE:
        -:  790:    {
    #####:  791:      re_ctx_p->token.type = RE_TOK_CHAR_CLASS;
        -:  792:
    #####:  793:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  794:      {
    #####:  795:        return ecma_raise_syntax_error (ECMA_ERR_UNTERMINATED_CHARACTER_CLASS);
        -:  796:      }
        -:  797:
    #####:  798:      return ECMA_VALUE_EMPTY;
        -:  799:    }
    #####:  800:    case LIT_CHAR_QUESTION:
        -:  801:    case LIT_CHAR_ASTERISK:
        -:  802:    case LIT_CHAR_PLUS:
        -:  803:    {
    #####:  804:      return ecma_raise_syntax_error (ECMA_ERR_INVALID_QUANTIFIER);
        -:  805:    }
    #####:  806:    case LIT_CHAR_LEFT_BRACE:
        -:  807:    {
    #####:  808:      re_ctx_p->input_curr_p--;
    #####:  809:      if (ecma_is_value_true (re_parse_quantifier (re_ctx_p)))
        -:  810:      {
    #####:  811:        return ecma_raise_syntax_error (ECMA_ERR_NOTHING_TO_REPEAT);
        -:  812:      }
        -:  813:
        -:  814:#if JERRY_ESNEXT
    #####:  815:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  816:      {
    #####:  817:        return ecma_raise_syntax_error (ECMA_ERR_LONE_QUANTIFIER_BRACKET);
        -:  818:      }
        -:  819:#endif /* JERRY_ESNEXT */
        -:  820:
    #####:  821:      re_ctx_p->input_curr_p++;
    #####:  822:      re_ctx_p->token.type = RE_TOK_CHAR;
    #####:  823:      re_ctx_p->token.value = ch;
        -:  824:
        -:  825:      /* Check quantifier */
    #####:  826:      break;
        -:  827:    }
        -:  828:#if JERRY_ESNEXT
    #####:  829:    case LIT_CHAR_RIGHT_SQUARE:
        -:  830:    case LIT_CHAR_RIGHT_BRACE:
        -:  831:    {
    #####:  832:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  833:      {
    #####:  834:        return ecma_raise_syntax_error (ECMA_ERR_LONE_QUANTIFIER_BRACKET);
        -:  835:      }
        -:  836:
        -:  837:      /* FALLTHRU */
        -:  838:    }
        -:  839:#endif /* JERRY_ESNEXT */
    #####:  840:    default:
        -:  841:    {
    #####:  842:      re_ctx_p->token.type = RE_TOK_CHAR;
    #####:  843:      re_ctx_p->token.value = ch;
        -:  844:
        -:  845:#if JERRY_ESNEXT
    #####:  846:      if (re_ctx_p->flags & RE_FLAG_UNICODE && lit_is_code_point_utf16_high_surrogate (ch)
    #####:  847:          && re_ctx_p->input_curr_p < re_ctx_p->input_end_p)
        -:  848:      {
    #####:  849:        const ecma_char_t next = lit_cesu8_peek_next (re_ctx_p->input_curr_p);
    #####:  850:        if (lit_is_code_point_utf16_low_surrogate (next))
        -:  851:        {
    #####:  852:          re_ctx_p->token.value = lit_convert_surrogate_pair_to_code_point (ch, next);
    #####:  853:          re_ctx_p->input_curr_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  854:        }
        -:  855:      }
        -:  856:#endif /* JERRY_ESNEXT */
        -:  857:
        -:  858:      /* Check quantifier */
    #####:  859:      break;
        -:  860:    }
        -:  861:  }
        -:  862:
    #####:  863:  re_parse_quantifier (re_ctx_p);
    #####:  864:  return re_check_quantifier (re_ctx_p);
        -:  865:} /* re_parse_next_token */
        -:  866:
        -:  867:/**
        -:  868: * Append a character class range to the bytecode.
        -:  869: */
        -:  870:static void
    #####:  871:re_class_add_range (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  872:                    lit_code_point_t start, /**< range begin */
        -:  873:                    lit_code_point_t end) /**< range end */
        -:  874:{
    #####:  875:  if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -:  876:  {
    #####:  877:    start = ecma_regexp_canonicalize_char (start, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####:  878:    end = ecma_regexp_canonicalize_char (end, re_ctx_p->flags & RE_FLAG_UNICODE);
        -:  879:  }
        -:  880:
    #####:  881:  re_append_char (re_ctx_p, start);
    #####:  882:  re_append_char (re_ctx_p, end);
    #####:  883:} /* re_class_add_range */
        -:  884:
        -:  885:/**
        -:  886: * Add a single character to the character class
        -:  887: */
        -:  888:static void
    #####:  889:re_class_add_char (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  890:                   uint32_t class_offset, /**< character class bytecode offset*/
        -:  891:                   lit_code_point_t cp) /**< code point */
        -:  892:{
    #####:  893:  if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -:  894:  {
    #####:  895:    cp = ecma_regexp_canonicalize_char (cp, re_ctx_p->flags & RE_FLAG_UNICODE);
        -:  896:  }
        -:  897:
    #####:  898:  re_insert_char (re_ctx_p, class_offset, cp);
    #####:  899:} /* re_class_add_char */
        -:  900:
        -:  901:/**
        -:  902: * Invalid character code point
        -:  903: */
        -:  904:#define RE_INVALID_CP 0xFFFFFFFF
        -:  905:
        -:  906:/**
        -:  907: * Read the input pattern and parse the range of character class
        -:  908: *
        -:  909: * @return empty ecma value - if parsed successfully
        -:  910: *         error ecma value - otherwise
        -:  911: *
        -:  912: *         Returned value must be freed with ecma_free_value
        -:  913: */
        -:  914:static ecma_value_t
    #####:  915:re_parse_char_class (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  916:{
        -:  917:  static const uint8_t escape_flags[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20 };
    #####:  918:  const uint32_t class_offset = re_bytecode_size (re_ctx_p);
        -:  919:
    #####:  920:  uint8_t found_escape_flags = 0;
    #####:  921:  uint8_t out_class_flags = 0;
        -:  922:
    #####:  923:  uint32_t range_count = 0;
    #####:  924:  uint32_t char_count = 0;
    #####:  925:  bool is_range = false;
        -:  926:
    #####:  927:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  928:  if (*re_ctx_p->input_curr_p == LIT_CHAR_CIRCUMFLEX)
        -:  929:  {
    #####:  930:    re_ctx_p->input_curr_p++;
    #####:  931:    out_class_flags |= RE_CLASS_INVERT;
        -:  932:  }
        -:  933:
    #####:  934:  lit_code_point_t start = RE_INVALID_CP;
        -:  935:
        -:  936:  while (true)
    #####:  937:  {
    #####:  938:    if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  939:    {
    #####:  940:      return ecma_raise_syntax_error (ECMA_ERR_UNTERMINATED_CHARACTER_CLASS);
        -:  941:    }
        -:  942:
    #####:  943:    if (*re_ctx_p->input_curr_p == LIT_CHAR_RIGHT_SQUARE)
        -:  944:    {
    #####:  945:      if (is_range)
        -:  946:      {
    #####:  947:        if (start != RE_INVALID_CP)
        -:  948:        {
    #####:  949:          re_class_add_char (re_ctx_p, class_offset, start);
    #####:  950:          char_count++;
        -:  951:        }
        -:  952:
    #####:  953:        re_class_add_char (re_ctx_p, class_offset, LIT_CHAR_MINUS);
    #####:  954:        char_count++;
        -:  955:      }
        -:  956:
    #####:  957:      re_ctx_p->input_curr_p++;
    #####:  958:      break;
        -:  959:    }
        -:  960:
    #####:  961:    JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
        -:  962:    lit_code_point_t current;
        -:  963:
    #####:  964:    if (*re_ctx_p->input_curr_p == LIT_CHAR_BACKSLASH)
        -:  965:    {
    #####:  966:      re_ctx_p->input_curr_p++;
    #####:  967:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  968:      {
    #####:  969:        return ecma_raise_syntax_error (ECMA_ERR_INVALID_ESCAPE);
        -:  970:      }
        -:  971:
    #####:  972:      if (*re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_B)
        -:  973:      {
    #####:  974:        re_ctx_p->input_curr_p++;
    #####:  975:        current = LIT_CHAR_BS;
        -:  976:      }
        -:  977:#if JERRY_ESNEXT
    #####:  978:      else if (*re_ctx_p->input_curr_p == LIT_CHAR_MINUS)
        -:  979:      {
    #####:  980:        re_ctx_p->input_curr_p++;
    #####:  981:        current = LIT_CHAR_MINUS;
        -:  982:      }
        -:  983:#endif /* JERRY_ESNEXT */
    #####:  984:      else if ((re_ctx_p->flags & RE_FLAG_UNICODE) == 0 && *re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_C
    #####:  985:               && re_ctx_p->input_curr_p + 1 < re_ctx_p->input_end_p
    #####:  986:               && (lit_char_is_decimal_digit (*(re_ctx_p->input_curr_p + 1))
    #####:  987:                   || *(re_ctx_p->input_curr_p + 1) == LIT_CHAR_UNDERSCORE))
        -:  988:      {
    #####:  989:        current = ((uint8_t) * (re_ctx_p->input_curr_p + 1) % 32);
    #####:  990:        re_ctx_p->input_curr_p += 2;
        -:  991:      }
        -:  992:      else
        -:  993:      {
    #####:  994:        if (ECMA_IS_VALUE_ERROR (re_parse_char_escape (re_ctx_p)))
        -:  995:        {
    #####:  996:          return ECMA_VALUE_ERROR;
        -:  997:        }
        -:  998:
    #####:  999:        if (re_ctx_p->token.type == RE_TOK_CLASS_ESCAPE)
        -: 1000:        {
    #####: 1001:          const uint8_t escape = (uint8_t) re_ctx_p->token.value;
    #####: 1002:          found_escape_flags |= escape_flags[escape];
    #####: 1003:          current = RE_INVALID_CP;
        -: 1004:        }
        -: 1005:        else
        -: 1006:        {
    #####: 1007:          JERRY_ASSERT (re_ctx_p->token.type == RE_TOK_CHAR);
    #####: 1008:          current = re_ctx_p->token.value;
        -: 1009:        }
        -: 1010:      }
        -: 1011:    }
        -: 1012:#if JERRY_ESNEXT
    #####: 1013:    else if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1014:    {
    #####: 1015:      current = ecma_regexp_unicode_advance (&re_ctx_p->input_curr_p, re_ctx_p->input_end_p);
        -: 1016:    }
        -: 1017:#endif /* JERRY_ESNEXT */
        -: 1018:    else
        -: 1019:    {
    #####: 1020:      current = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
        -: 1021:    }
        -: 1022:
    #####: 1023:    if (is_range)
        -: 1024:    {
    #####: 1025:      is_range = false;
        -: 1026:
    #####: 1027:      if (start != RE_INVALID_CP && current != RE_INVALID_CP)
        -: 1028:      {
    #####: 1029:        if (start > current)
        -: 1030:        {
    #####: 1031:          return ecma_raise_syntax_error (ECMA_ERR_RANGE_OUT_OF_ORDER_IN_CHARACTER_CLASS);
        -: 1032:        }
        -: 1033:
    #####: 1034:        re_class_add_range (re_ctx_p, start, current);
    #####: 1035:        range_count++;
    #####: 1036:        continue;
        -: 1037:      }
        -: 1038:
        -: 1039:#if JERRY_ESNEXT
    #####: 1040:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1041:      {
    #####: 1042:        return ecma_raise_syntax_error (ECMA_ERR_INVALID_CHARACTER_CLASS);
        -: 1043:      }
        -: 1044:#endif /* JERRY_ESNEXT */
        -: 1045:
    #####: 1046:      if (start != RE_INVALID_CP)
        -: 1047:      {
    #####: 1048:        re_class_add_char (re_ctx_p, class_offset, start);
    #####: 1049:        char_count++;
        -: 1050:      }
    #####: 1051:      else if (current != RE_INVALID_CP)
        -: 1052:      {
    #####: 1053:        re_class_add_char (re_ctx_p, class_offset, current);
    #####: 1054:        char_count++;
        -: 1055:      }
        -: 1056:
    #####: 1057:      re_class_add_char (re_ctx_p, class_offset, LIT_CHAR_MINUS);
    #####: 1058:      char_count++;
    #####: 1059:      continue;
        -: 1060:    }
        -: 1061:
    #####: 1062:    if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && *re_ctx_p->input_curr_p == LIT_CHAR_MINUS)
        -: 1063:    {
    #####: 1064:      re_ctx_p->input_curr_p++;
    #####: 1065:      start = current;
    #####: 1066:      is_range = true;
    #####: 1067:      continue;
        -: 1068:    }
        -: 1069:
    #####: 1070:    if (current != RE_INVALID_CP)
        -: 1071:    {
    #####: 1072:      re_class_add_char (re_ctx_p, class_offset, current);
    #####: 1073:      char_count++;
        -: 1074:    }
        -: 1075:  }
        -: 1076:
    #####: 1077:  uint8_t escape_count = 0;
    #####: 1078:  for (ecma_class_escape_t escape = RE_ESCAPE__START; escape < RE_ESCAPE__COUNT; ++escape)
        -: 1079:  {
    #####: 1080:    if (found_escape_flags & escape_flags[escape])
        -: 1081:    {
    #####: 1082:      re_insert_byte (re_ctx_p, class_offset, (uint8_t) escape);
    #####: 1083:      escape_count++;
        -: 1084:    }
        -: 1085:  }
        -: 1086:
    #####: 1087:  if (range_count > 0)
        -: 1088:  {
    #####: 1089:    re_insert_value (re_ctx_p, class_offset, range_count);
    #####: 1090:    out_class_flags |= RE_CLASS_HAS_RANGES;
        -: 1091:  }
        -: 1092:
    #####: 1093:  if (char_count > 0)
        -: 1094:  {
    #####: 1095:    re_insert_value (re_ctx_p, class_offset, char_count);
    #####: 1096:    out_class_flags |= RE_CLASS_HAS_CHARS;
        -: 1097:  }
        -: 1098:
    #####: 1099:  JERRY_ASSERT (escape_count <= RE_CLASS_ESCAPE_COUNT_MASK);
    #####: 1100:  out_class_flags |= escape_count;
        -: 1101:
    #####: 1102:  re_insert_byte (re_ctx_p, class_offset, out_class_flags);
    #####: 1103:  re_insert_opcode (re_ctx_p, class_offset, RE_OP_CHAR_CLASS);
        -: 1104:
    #####: 1105:  re_parse_quantifier (re_ctx_p);
    #####: 1106:  return re_check_quantifier (re_ctx_p);
        -: 1107:} /* re_parse_char_class */
        -: 1108:
        -: 1109:/**
        -: 1110: * Parse alternatives
        -: 1111: *
        -: 1112: * @return empty ecma value - if alternative was successfully parsed
        -: 1113: *         error ecma value - otherwise
        -: 1114: *
        -: 1115: *         Returned value must be freed with ecma_free_value
        -: 1116: */
        -: 1117:ecma_value_t
    #####: 1118:re_parse_alternative (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -: 1119:                      bool expect_eof) /**< expect end of file */
        -: 1120:{
    #####: 1121:  ECMA_CHECK_STACK_USAGE ();
    #####: 1122:  uint32_t alternative_offset = re_bytecode_size (re_ctx_p);
    #####: 1123:  bool first_alternative = true;
        -: 1124:
        -: 1125:  while (true)
    #####: 1126:  {
    #####: 1127:    ecma_value_t next_token_result = re_parse_next_token (re_ctx_p);
    #####: 1128:    if (ECMA_IS_VALUE_ERROR (next_token_result))
        -: 1129:    {
    #####: 1130:      return next_token_result;
        -: 1131:    }
        -: 1132:
    #####: 1133:    JERRY_ASSERT (ecma_is_value_empty (next_token_result));
        -: 1134:
    #####: 1135:    uint32_t atom_offset = re_bytecode_size (re_ctx_p);
        -: 1136:
    #####: 1137:    switch (re_ctx_p->token.type)
        -: 1138:    {
    #####: 1139:      case RE_TOK_START_CAPTURE_GROUP:
        -: 1140:      {
    #####: 1141:        const uint32_t idx = re_ctx_p->captures_count++;
    #####: 1142:        const uint32_t capture_start = idx;
        -: 1143:
    #####: 1144:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
    #####: 1145:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1146:        {
    #####: 1147:          return result;
        -: 1148:        }
        -: 1149:
    #####: 1150:        re_parse_quantifier (re_ctx_p);
        -: 1151:
    #####: 1152:        if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1153:        {
    #####: 1154:          return ECMA_VALUE_ERROR;
        -: 1155:        }
        -: 1156:
    #####: 1157:        re_insert_into_group (re_ctx_p, atom_offset, idx, capture_start, true);
    #####: 1158:        break;
        -: 1159:      }
    #####: 1160:      case RE_TOK_START_NON_CAPTURE_GROUP:
        -: 1161:      {
    #####: 1162:        const uint32_t idx = re_ctx_p->non_captures_count++;
    #####: 1163:        const uint32_t capture_start = re_ctx_p->captures_count;
        -: 1164:
    #####: 1165:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
    #####: 1166:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1167:        {
    #####: 1168:          return result;
        -: 1169:        }
        -: 1170:
    #####: 1171:        re_parse_quantifier (re_ctx_p);
        -: 1172:
    #####: 1173:        if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1174:        {
    #####: 1175:          return ECMA_VALUE_ERROR;
        -: 1176:        }
        -: 1177:
    #####: 1178:        re_insert_into_group (re_ctx_p, atom_offset, idx, capture_start, false);
    #####: 1179:        break;
        -: 1180:      }
    #####: 1181:      case RE_TOK_PERIOD:
        -: 1182:      {
        -: 1183:#if JERRY_ESNEXT
    #####: 1184:        re_append_opcode (re_ctx_p, (re_ctx_p->flags & RE_FLAG_UNICODE) ? RE_OP_UNICODE_PERIOD : RE_OP_PERIOD);
        -: 1185:#else /* !JERRY_ESNEXT */
    #####: 1186:        re_append_opcode (re_ctx_p, RE_OP_PERIOD);
        -: 1187:#endif /* !JERRY_ESNEXT */
        -: 1188:
    #####: 1189:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1190:        break;
        -: 1191:      }
    #####: 1192:      case RE_TOK_ALTERNATIVE:
        -: 1193:      {
    #####: 1194:        re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1195:        re_insert_opcode (re_ctx_p,
        -: 1196:                          alternative_offset,
        -: 1197:                          first_alternative ? RE_OP_ALTERNATIVE_START : RE_OP_ALTERNATIVE_NEXT);
        -: 1198:
    #####: 1199:        alternative_offset = re_bytecode_size (re_ctx_p);
    #####: 1200:        first_alternative = false;
    #####: 1201:        break;
        -: 1202:      }
    #####: 1203:      case RE_TOK_ASSERT_START:
        -: 1204:      {
    #####: 1205:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_LINE_START);
    #####: 1206:        break;
        -: 1207:      }
    #####: 1208:      case RE_TOK_ASSERT_END:
        -: 1209:      {
    #####: 1210:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_LINE_END);
    #####: 1211:        break;
        -: 1212:      }
    #####: 1213:      case RE_TOK_ASSERT_WORD_BOUNDARY:
        -: 1214:      {
    #####: 1215:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_WORD_BOUNDARY);
    #####: 1216:        break;
        -: 1217:      }
    #####: 1218:      case RE_TOK_ASSERT_NOT_WORD_BOUNDARY:
        -: 1219:      {
    #####: 1220:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_NOT_WORD_BOUNDARY);
    #####: 1221:        break;
        -: 1222:      }
    #####: 1223:      case RE_TOK_ASSERT_LOOKAHEAD:
        -: 1224:      {
    #####: 1225:        const uint32_t start_capture_count = re_ctx_p->captures_count;
    #####: 1226:        const bool is_negative = !!re_ctx_p->token.value;
        -: 1227:
    #####: 1228:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
        -: 1229:
    #####: 1230:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1231:        {
    #####: 1232:          return result;
        -: 1233:        }
        -: 1234:
        -: 1235:#if JERRY_ESNEXT
    #####: 1236:        if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1237:        {
    #####: 1238:          re_ctx_p->token.qmin = 1;
    #####: 1239:          re_ctx_p->token.qmax = 1;
    #####: 1240:          re_ctx_p->token.greedy = true;
        -: 1241:        }
        -: 1242:        else
        -: 1243:#endif /* JERRY_ESNEXT */
        -: 1244:        {
    #####: 1245:          re_parse_quantifier (re_ctx_p);
        -: 1246:
    #####: 1247:          if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1248:          {
    #####: 1249:            return ECMA_VALUE_ERROR;
        -: 1250:          }
        -: 1251:        }
        -: 1252:
    #####: 1253:        re_insert_assertion_lookahead (re_ctx_p, atom_offset, start_capture_count, is_negative);
    #####: 1254:        break;
        -: 1255:      }
    #####: 1256:      case RE_TOK_BACKREFERENCE:
        -: 1257:      {
    #####: 1258:        const uint32_t backref_idx = re_ctx_p->token.value;
    #####: 1259:        re_append_opcode (re_ctx_p, RE_OP_BACKREFERENCE);
    #####: 1260:        re_append_value (re_ctx_p, backref_idx);
        -: 1261:
    #####: 1262:        if (re_ctx_p->token.qmin != 1 || re_ctx_p->token.qmax != 1)
        -: 1263:        {
    #####: 1264:          const uint32_t group_idx = re_ctx_p->non_captures_count++;
    #####: 1265:          re_insert_into_group (re_ctx_p, atom_offset, group_idx, re_ctx_p->captures_count, false);
        -: 1266:        }
        -: 1267:
    #####: 1268:        break;
        -: 1269:      }
    #####: 1270:      case RE_TOK_CLASS_ESCAPE:
        -: 1271:      {
    #####: 1272:        const ecma_class_escape_t escape = (ecma_class_escape_t) re_ctx_p->token.value;
    #####: 1273:        re_append_opcode (re_ctx_p, RE_OP_CLASS_ESCAPE);
    #####: 1274:        re_append_byte (re_ctx_p, (uint8_t) escape);
        -: 1275:
    #####: 1276:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1277:        break;
        -: 1278:      }
    #####: 1279:      case RE_TOK_CHAR_CLASS:
        -: 1280:      {
    #####: 1281:        ecma_value_t result = re_parse_char_class (re_ctx_p);
        -: 1282:
    #####: 1283:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1284:        {
    #####: 1285:          return result;
        -: 1286:        }
        -: 1287:
    #####: 1288:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1289:        break;
        -: 1290:      }
    #####: 1291:      case RE_TOK_END_GROUP:
        -: 1292:      {
    #####: 1293:        if (expect_eof)
        -: 1294:        {
    #####: 1295:          return ecma_raise_syntax_error (ECMA_ERR_UNMATCHED_CLOSE_BRACKET);
        -: 1296:        }
        -: 1297:
    #####: 1298:        if (!first_alternative)
        -: 1299:        {
    #####: 1300:          re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1301:          re_insert_opcode (re_ctx_p, alternative_offset, RE_OP_ALTERNATIVE_NEXT);
        -: 1302:        }
        -: 1303:
    #####: 1304:        return ECMA_VALUE_EMPTY;
        -: 1305:      }
    #####: 1306:      case RE_TOK_EOF:
        -: 1307:      {
    #####: 1308:        if (!expect_eof)
        -: 1309:        {
    #####: 1310:          return ecma_raise_syntax_error (ECMA_ERR_UNEXPECTED_END_OF_PATTERN);
        -: 1311:        }
        -: 1312:
    #####: 1313:        if (!first_alternative)
        -: 1314:        {
    #####: 1315:          re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1316:          re_insert_opcode (re_ctx_p, alternative_offset, RE_OP_ALTERNATIVE_NEXT);
        -: 1317:        }
        -: 1318:
    #####: 1319:        re_append_opcode (re_ctx_p, RE_OP_EOF);
    #####: 1320:        return ECMA_VALUE_EMPTY;
        -: 1321:      }
    #####: 1322:      default:
        -: 1323:      {
    #####: 1324:        JERRY_ASSERT (re_ctx_p->token.type == RE_TOK_CHAR);
        -: 1325:
    #####: 1326:        lit_code_point_t ch = re_ctx_p->token.value;
        -: 1327:
    #####: 1328:        if (ch <= LIT_UTF8_1_BYTE_CODE_POINT_MAX && (re_ctx_p->flags & RE_FLAG_IGNORE_CASE) == 0)
        -: 1329:        {
    #####: 1330:          re_append_opcode (re_ctx_p, RE_OP_BYTE);
    #####: 1331:          re_append_byte (re_ctx_p, (uint8_t) ch);
        -: 1332:
    #####: 1333:          re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1334:          break;
        -: 1335:        }
        -: 1336:
    #####: 1337:        if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -: 1338:        {
    #####: 1339:          ch = ecma_regexp_canonicalize_char (ch, re_ctx_p->flags & RE_FLAG_UNICODE);
        -: 1340:        }
        -: 1341:
    #####: 1342:        re_append_opcode (re_ctx_p, RE_OP_CHAR);
    #####: 1343:        re_append_char (re_ctx_p, ch);
        -: 1344:
    #####: 1345:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1346:        break;
        -: 1347:      }
        -: 1348:    }
        -: 1349:  }
        -: 1350:
        -: 1351:  return ECMA_VALUE_EMPTY;
        -: 1352:} /* re_parse_alternative */
        -: 1353:
        -: 1354:/**
        -: 1355: * @}
        -: 1356: * @}
        -: 1357: * @}
        -: 1358: */
        -: 1359:
        -: 1360:#endif /* JERRY_BUILTIN_REGEXP */
