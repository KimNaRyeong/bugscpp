        -:    0:Source:/home/workspace/jerry-core/vm/opcodes-ecma-arithmetics.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-bigint.h"
        -:   18:#include "ecma-conversion.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:#include "ecma-objects.h"
        -:   22:
        -:   23:#include "jrt-libc-includes.h"
        -:   24:#include "opcodes.h"
        -:   25:
        -:   26:/** \addtogroup vm Virtual machine
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup vm_opcodes Opcodes
        -:   30: * @{
        -:   31: */
        -:   32:
        -:   33:/**
        -:   34: * Perform ECMA number arithmetic operation.
        -:   35: *
        -:   36: * The algorithm of the operation is following:
        -:   37: *   leftNum = ToNumber (leftValue);
        -:   38: *   rightNum = ToNumber (rightValue);
        -:   39: *   result = leftNum ArithmeticOp rightNum;
        -:   40: *
        -:   41: * @return ecma value
        -:   42: *         Returned value must be freed with ecma_free_value
        -:   43: */
        -:   44:ecma_value_t
    #####:   45:do_number_arithmetic (number_arithmetic_op op, /**< number arithmetic operation */
        -:   46:                      ecma_value_t left_value, /**< left value */
        -:   47:                      ecma_value_t right_value) /**< right value */
        -:   48:{
    #####:   49:  ecma_number_t left_number;
    #####:   50:  left_value = ecma_op_to_numeric (left_value, &left_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -:   51:
    #####:   52:  if (ECMA_IS_VALUE_ERROR (left_value))
        -:   53:  {
    #####:   54:    return left_value;
        -:   55:  }
        -:   56:
    #####:   57:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:   58:
        -:   59:#if JERRY_BUILTIN_BIGINT
    #####:   60:  if (JERRY_LIKELY (!ecma_is_value_bigint (left_value)))
        -:   61:  {
        -:   62:#endif /* JERRY_BUILTIN_BIGINT */
        -:   63:
    #####:   64:    ecma_number_t right_number;
    #####:   65:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (right_value, &right_number)))
        -:   66:    {
    #####:   67:      return ECMA_VALUE_ERROR;
        -:   68:    }
        -:   69:
    #####:   70:    ecma_number_t result = ECMA_NUMBER_ZERO;
        -:   71:
    #####:   72:    switch (op)
        -:   73:    {
    #####:   74:      case NUMBER_ARITHMETIC_SUBTRACTION:
        -:   75:      {
    #####:   76:        result = left_number - right_number;
    #####:   77:        break;
        -:   78:      }
    #####:   79:      case NUMBER_ARITHMETIC_MULTIPLICATION:
        -:   80:      {
    #####:   81:        result = left_number * right_number;
    #####:   82:        break;
        -:   83:      }
    #####:   84:      case NUMBER_ARITHMETIC_DIVISION:
        -:   85:      {
    #####:   86:        result = left_number / right_number;
    #####:   87:        break;
        -:   88:      }
    #####:   89:      case NUMBER_ARITHMETIC_REMAINDER:
        -:   90:      {
    #####:   91:        if (ecma_number_is_nan (left_number) || ecma_number_is_nan (right_number)
    #####:   92:            || ecma_number_is_infinity (left_number) || ecma_number_is_zero (right_number))
        -:   93:        {
    #####:   94:          result = ecma_number_make_nan ();
    #####:   95:          break;
        -:   96:        }
        -:   97:
    #####:   98:        if (ecma_number_is_infinity (right_number)
    #####:   99:            || (ecma_number_is_zero (left_number) && !ecma_number_is_zero (right_number)))
        -:  100:        {
    #####:  101:          result = left_number;
    #####:  102:          break;
        -:  103:        }
        -:  104:
    #####:  105:        result = ecma_number_remainder (left_number, right_number);
    #####:  106:        break;
        -:  107:      }
        -:  108:#if JERRY_ESNEXT
    #####:  109:      case NUMBER_ARITHMETIC_EXPONENTIATION:
        -:  110:      {
    #####:  111:        result = ecma_number_pow (left_number, right_number);
    #####:  112:        break;
        -:  113:      }
        -:  114:#endif /* JERRY_ESNEXT */
        -:  115:    }
        -:  116:
    #####:  117:    ret_value = ecma_make_number_value (result);
        -:  118:#if JERRY_BUILTIN_BIGINT
        -:  119:  }
        -:  120:  else
        -:  121:  {
    #####:  122:    bool free_right_value;
    #####:  123:    right_value = ecma_bigint_get_bigint (right_value, &free_right_value);
        -:  124:
    #####:  125:    if (ECMA_IS_VALUE_ERROR (right_value))
        -:  126:    {
    #####:  127:      ecma_free_value (left_value);
    #####:  128:      return right_value;
        -:  129:    }
        -:  130:
    #####:  131:    switch (op)
        -:  132:    {
    #####:  133:      case NUMBER_ARITHMETIC_SUBTRACTION:
        -:  134:      {
    #####:  135:        ret_value = ecma_bigint_add_sub (left_value, right_value, false);
    #####:  136:        break;
        -:  137:      }
    #####:  138:      case NUMBER_ARITHMETIC_MULTIPLICATION:
        -:  139:      {
    #####:  140:        ret_value = ecma_bigint_mul (left_value, right_value);
    #####:  141:        break;
        -:  142:      }
    #####:  143:      case NUMBER_ARITHMETIC_DIVISION:
        -:  144:      {
    #####:  145:        ret_value = ecma_bigint_div_mod (left_value, right_value, false);
    #####:  146:        break;
        -:  147:      }
    #####:  148:      case NUMBER_ARITHMETIC_REMAINDER:
        -:  149:      {
    #####:  150:        ret_value = ecma_bigint_div_mod (left_value, right_value, true);
    #####:  151:        break;
        -:  152:      }
        -:  153:#if JERRY_ESNEXT
    #####:  154:      case NUMBER_ARITHMETIC_EXPONENTIATION:
        -:  155:      {
    #####:  156:        ret_value = ecma_bigint_pow (left_value, right_value);
    #####:  157:        break;
        -:  158:      }
        -:  159:#endif /* JERRY_ESNEXT */
        -:  160:    }
        -:  161:
    #####:  162:    ecma_free_value (left_value);
    #####:  163:    if (free_right_value)
        -:  164:    {
    #####:  165:      ecma_free_value (right_value);
        -:  166:    }
        -:  167:  }
        -:  168:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  169:  return ret_value;
        -:  170:} /* do_number_arithmetic */
        -:  171:
        -:  172:/**
        -:  173: * 'Addition' opcode handler.
        -:  174: *
        -:  175: * See also: ECMA-262 v5, 11.6.1
        -:  176: *
        -:  177: * @return ecma value
        -:  178: *         Returned value must be freed with ecma_free_value
        -:  179: */
        -:  180:ecma_value_t
    #####:  181:opfunc_addition (ecma_value_t left_value, /**< left value */
        -:  182:                 ecma_value_t right_value) /**< right value */
        -:  183:{
    #####:  184:  bool free_left_value = false;
    #####:  185:  bool free_right_value = false;
        -:  186:
    #####:  187:  if (ecma_is_value_object (left_value))
        -:  188:  {
    #####:  189:    ecma_object_t *obj_p = ecma_get_object_from_value (left_value);
    #####:  190:    left_value = ecma_op_object_default_value (obj_p, ECMA_PREFERRED_TYPE_NO);
    #####:  191:    free_left_value = true;
        -:  192:
    #####:  193:    if (ECMA_IS_VALUE_ERROR (left_value))
        -:  194:    {
    #####:  195:      return left_value;
        -:  196:    }
        -:  197:  }
        -:  198:
    #####:  199:  if (ecma_is_value_object (right_value))
        -:  200:  {
    #####:  201:    ecma_object_t *obj_p = ecma_get_object_from_value (right_value);
    #####:  202:    right_value = ecma_op_object_default_value (obj_p, ECMA_PREFERRED_TYPE_NO);
    #####:  203:    free_right_value = true;
        -:  204:
    #####:  205:    if (ECMA_IS_VALUE_ERROR (right_value))
        -:  206:    {
    #####:  207:      if (free_left_value)
        -:  208:      {
    #####:  209:        ecma_free_value (left_value);
        -:  210:      }
    #####:  211:      return right_value;
        -:  212:    }
        -:  213:  }
        -:  214:
    #####:  215:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  216:
    #####:  217:  if (ecma_is_value_string (left_value) || ecma_is_value_string (right_value))
    #####:  218:  {
    #####:  219:    ecma_string_t *string1_p = ecma_op_to_string (left_value);
        -:  220:
    #####:  221:    if (JERRY_UNLIKELY (string1_p == NULL))
        -:  222:    {
    #####:  223:      if (free_left_value)
        -:  224:      {
    #####:  225:        ecma_free_value (left_value);
        -:  226:      }
    #####:  227:      if (free_right_value)
        -:  228:      {
    #####:  229:        ecma_free_value (right_value);
        -:  230:      }
    #####:  231:      return ECMA_VALUE_ERROR;
        -:  232:    }
        -:  233:
    #####:  234:    ecma_string_t *string2_p = ecma_op_to_string (right_value);
        -:  235:
    #####:  236:    if (JERRY_UNLIKELY (string2_p == NULL))
        -:  237:    {
    #####:  238:      if (free_right_value)
        -:  239:      {
    #####:  240:        ecma_free_value (right_value);
        -:  241:      }
    #####:  242:      if (free_left_value)
        -:  243:      {
    #####:  244:        ecma_free_value (left_value);
        -:  245:      }
    #####:  246:      ecma_deref_ecma_string (string1_p);
    #####:  247:      return ECMA_VALUE_ERROR;
        -:  248:    }
        -:  249:
    #####:  250:    string1_p = ecma_concat_ecma_strings (string1_p, string2_p);
    #####:  251:    ret_value = ecma_make_string_value (string1_p);
        -:  252:
    #####:  253:    ecma_deref_ecma_string (string2_p);
        -:  254:  }
        -:  255:#if JERRY_BUILTIN_BIGINT
    #####:  256:  else if (JERRY_UNLIKELY (ecma_is_value_bigint (left_value)) && JERRY_UNLIKELY (ecma_is_value_bigint (right_value)))
        -:  257:  {
    #####:  258:    ret_value = ecma_bigint_add_sub (left_value, right_value, true);
        -:  259:  }
        -:  260:#endif /* JERRY_BUILTIN_BIGINT */
        -:  261:  else
        -:  262:  {
    #####:  263:    ecma_number_t num_left;
    #####:  264:    ecma_number_t num_right;
    #####:  265:    if (!ECMA_IS_VALUE_ERROR (ecma_op_to_number (left_value, &num_left))
    #####:  266:        && !ECMA_IS_VALUE_ERROR (ecma_op_to_number (right_value, &num_right)))
        -:  267:    {
    #####:  268:      ret_value = ecma_make_number_value (num_left + num_right);
        -:  269:    }
        -:  270:    else
        -:  271:    {
    #####:  272:      ret_value = ECMA_VALUE_ERROR;
        -:  273:    }
        -:  274:  }
        -:  275:
    #####:  276:  if (free_left_value)
        -:  277:  {
    #####:  278:    ecma_free_value (left_value);
        -:  279:  }
        -:  280:
    #####:  281:  if (free_right_value)
        -:  282:  {
    #####:  283:    ecma_free_value (right_value);
        -:  284:  }
        -:  285:
    #####:  286:  return ret_value;
        -:  287:} /* opfunc_addition */
        -:  288:
        -:  289:/**
        -:  290: * Unary operation opcode handler.
        -:  291: *
        -:  292: * See also: ECMA-262 v5, 11.4, 11.4.6, 11.4.7
        -:  293: *
        -:  294: * @return ecma value
        -:  295: *         Returned value must be freed with ecma_free_value
        -:  296: */
        -:  297:ecma_value_t
    #####:  298:opfunc_unary_operation (ecma_value_t left_value, /**< left value */
        -:  299:                        bool is_plus) /**< unary plus flag */
        -:  300:{
    #####:  301:  ecma_number_t left_number;
    #####:  302:  left_value = ecma_op_to_numeric (left_value, &left_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -:  303:
    #####:  304:  if (ECMA_IS_VALUE_ERROR (left_value))
        -:  305:  {
    #####:  306:    return left_value;
        -:  307:  }
        -:  308:
        -:  309:#if JERRY_BUILTIN_BIGINT
    #####:  310:  if (JERRY_LIKELY (!ecma_is_value_bigint (left_value)))
        -:  311:  {
    #####:  312:    return ecma_make_number_value (is_plus ? left_number : -left_number);
        -:  313:  }
        -:  314:
        -:  315:  ecma_value_t ret_value;
        -:  316:
    #####:  317:  if (is_plus)
        -:  318:  {
    #####:  319:    ret_value = ecma_raise_type_error (ECMA_ERR_UNARY_PLUS_IS_NOT_ALLOWED_FOR_BIGINTS);
        -:  320:  }
        -:  321:  else
        -:  322:  {
    #####:  323:    ret_value = left_value;
        -:  324:
    #####:  325:    if (left_value != ECMA_BIGINT_ZERO)
        -:  326:    {
    #####:  327:      ret_value = ecma_bigint_negate (ecma_get_extended_primitive_from_value (left_value));
        -:  328:    }
        -:  329:  }
        -:  330:
    #####:  331:  ecma_free_value (left_value);
    #####:  332:  return ret_value;
        -:  333:#else /* !JERRY_BUILTIN_BIGINT */
    #####:  334:  return ecma_make_number_value (is_plus ? left_number : -left_number);
        -:  335:#endif /* JERRY_BUILTIN_BIGINT */
        -:  336:} /* opfunc_unary_operation */
        -:  337:
        -:  338:/**
        -:  339: * @}
        -:  340: * @}
        -:  341: */
