        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-exceptions.h"
        -:   17:#include "ecma-extended-info.h"
        -:   18:#include "ecma-helpers.h"
        -:   19:#include "ecma-literal-storage.h"
        -:   20:#include "ecma-module.h"
        -:   21:
        -:   22:#include "debugger.h"
        -:   23:#include "jcontext.h"
        -:   24:#include "js-parser-internal.h"
        -:   25:#include "lit-char-helpers.h"
        -:   26:
        -:   27:#if JERRY_PARSER
        -:   28:
        -:   29:JERRY_STATIC_ASSERT ((int) ECMA_PARSE_STRICT_MODE == (int) PARSER_IS_STRICT,
        -:   30:                     ecma_parse_strict_mode_must_be_equal_to_parser_is_strict);
        -:   31:
        -:   32:#if JERRY_ESNEXT
        -:   33:JERRY_STATIC_ASSERT (PARSER_SAVE_STATUS_FLAGS (PARSER_ALLOW_SUPER) == 0x1, incorrect_saving_of_ecma_parse_allow_super);
        -:   34:JERRY_STATIC_ASSERT (PARSER_RESTORE_STATUS_FLAGS (ECMA_PARSE_ALLOW_SUPER) == PARSER_ALLOW_SUPER,
        -:   35:                     incorrect_restoring_of_ecma_parse_allow_super);
        -:   36:
        -:   37:JERRY_STATIC_ASSERT (PARSER_RESTORE_STATUS_FLAGS (ECMA_PARSE_FUNCTION_CONTEXT) == 0,
        -:   38:                     ecma_parse_function_context_must_not_be_transformed);
        -:   39:#endif /* JERRY_ESNEXT */
        -:   40:
        -:   41:/** \addtogroup parser Parser
        -:   42: * @{
        -:   43: *
        -:   44: * \addtogroup jsparser JavaScript
        -:   45: * @{
        -:   46: *
        -:   47: * \addtogroup jsparser_parser Parser
        -:   48: * @{
        -:   49: */
        -:   50:
        -:   51:/**
        -:   52: * Compute real literal indicies.
        -:   53: *
        -:   54: * @return length of the prefix opcodes
        -:   55: */
        -:   56:static void
        2:   57:parser_compute_indicies (parser_context_t *context_p, /**< context */
        -:   58:                         uint16_t *ident_end, /**< end of the identifier group */
        -:   59:                         uint16_t *const_literal_end) /**< end of the const literal group */
        -:   60:{
        2:   61:  parser_list_iterator_t literal_iterator;
        -:   62:  lexer_literal_t *literal_p;
        -:   63:
        2:   64:  uint16_t ident_count = 0;
        2:   65:  uint16_t const_literal_count = 0;
        -:   66:
        -:   67:  uint16_t ident_index;
        -:   68:  uint16_t const_literal_index;
        -:   69:  uint16_t literal_index;
        -:   70:
        -:   71:  /* First phase: count the number of items in each group. */
        2:   72:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        9:   73:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:   74:  {
        5:   75:    switch (literal_p->type)
        -:   76:    {
        4:   77:      case LEXER_IDENT_LITERAL:
        -:   78:      {
        4:   79:        if (literal_p->status_flags & LEXER_FLAG_USED)
        -:   80:        {
        3:   81:          ident_count++;
        3:   82:          break;
        -:   83:        }
        1:   84:        else if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:   85:        {
    #####:   86:          jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);
        -:   87:          /* This literal should not be freed even if an error is encountered later. */
    #####:   88:          literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;
        -:   89:        }
        1:   90:        continue;
        -:   91:      }
    #####:   92:      case LEXER_STRING_LITERAL:
        -:   93:      {
    #####:   94:        const_literal_count++;
    #####:   95:        break;
        -:   96:      }
    #####:   97:      case LEXER_NUMBER_LITERAL:
        -:   98:      {
    #####:   99:        const_literal_count++;
    #####:  100:        continue;
        -:  101:      }
        1:  102:      case LEXER_FUNCTION_LITERAL:
        -:  103:      case LEXER_REGEXP_LITERAL:
        -:  104:      {
        1:  105:        continue;
        -:  106:      }
    #####:  107:      default:
        -:  108:      {
    #####:  109:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);
    #####:  110:        continue;
        -:  111:      }
        -:  112:    }
        -:  113:
        3:  114:    const uint8_t *char_p = literal_p->u.char_p;
        3:  115:    uint32_t status_flags = context_p->status_flags;
        -:  116:
        3:  117:    if ((literal_p->status_flags & LEXER_FLAG_SOURCE_PTR) && literal_p->prop.length < 0xfff)
        -:  118:    {
        3:  119:      size_t bytes_to_end = (size_t) (context_p->source_end_p - char_p);
        -:  120:
        3:  121:      if (bytes_to_end < 0xfffff)
        -:  122:      {
        3:  123:        literal_p->u.source_data = ((uint32_t) bytes_to_end) | (((uint32_t) literal_p->prop.length) << 20);
        3:  124:        literal_p->status_flags |= LEXER_FLAG_LATE_INIT;
        3:  125:        status_flags |= PARSER_HAS_LATE_LIT_INIT;
        3:  126:        context_p->status_flags = status_flags;
        3:  127:        char_p = NULL;
        -:  128:      }
        -:  129:    }
        -:  130:
        3:  131:    if (char_p != NULL)
        -:  132:    {
    #####:  133:      literal_p->u.value = ecma_find_or_create_literal_string (char_p,
    #####:  134:                                                               literal_p->prop.length,
    #####:  135:                                                               (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);
        -:  136:
    #####:  137:      if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:  138:      {
    #####:  139:        jmem_heap_free_block ((void *) char_p, literal_p->prop.length);
        -:  140:        /* This literal should not be freed even if an error is encountered later. */
    #####:  141:        literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;
        -:  142:      }
        -:  143:    }
        -:  144:  }
        -:  145:
        2:  146:  ident_index = context_p->register_count;
        2:  147:  const_literal_index = (uint16_t) (ident_index + ident_count);
        2:  148:  literal_index = (uint16_t) (const_literal_index + const_literal_count);
        -:  149:
        -:  150:  /* Second phase: Assign an index to each literal. */
        2:  151:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        -:  152:
        9:  153:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:  154:  {
        5:  155:    switch (literal_p->type)
        -:  156:    {
        4:  157:      case LEXER_IDENT_LITERAL:
        -:  158:      {
        4:  159:        if (literal_p->status_flags & LEXER_FLAG_USED)
        -:  160:        {
        3:  161:          literal_p->prop.index = ident_index;
        3:  162:          ident_index++;
        -:  163:        }
        4:  164:        break;
        -:  165:      }
    #####:  166:      case LEXER_STRING_LITERAL:
        -:  167:      case LEXER_NUMBER_LITERAL:
        -:  168:      {
    #####:  169:        JERRY_ASSERT ((literal_p->status_flags & ~(LEXER_FLAG_SOURCE_PTR | LEXER_FLAG_LATE_INIT)) == 0);
    #####:  170:        literal_p->prop.index = const_literal_index;
    #####:  171:        const_literal_index++;
    #####:  172:        break;
        -:  173:      }
        1:  174:      case LEXER_FUNCTION_LITERAL:
        -:  175:      case LEXER_REGEXP_LITERAL:
        -:  176:      {
        1:  177:        JERRY_ASSERT (literal_p->status_flags == 0);
        -:  178:
        1:  179:        literal_p->prop.index = literal_index;
        1:  180:        literal_index++;
        1:  181:        break;
        -:  182:      }
    #####:  183:      default:
        -:  184:      {
    #####:  185:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL
        -:  186:                      && literal_p->status_flags == LEXER_FLAG_FUNCTION_ARGUMENT);
    #####:  187:        break;
        -:  188:      }
        -:  189:    }
        -:  190:  }
        -:  191:
        2:  192:  JERRY_ASSERT (ident_index == context_p->register_count + ident_count);
        2:  193:  JERRY_ASSERT (const_literal_index == ident_index + const_literal_count);
        2:  194:  JERRY_ASSERT (literal_index <= context_p->register_count + context_p->literal_count);
        -:  195:
        2:  196:  context_p->literal_count = literal_index;
        -:  197:
        2:  198:  *ident_end = ident_index;
        2:  199:  *const_literal_end = const_literal_index;
        2:  200:} /* parser_compute_indicies */
        -:  201:
        -:  202:/**
        -:  203: * Initialize literal pool.
        -:  204: */
        -:  205:static void
        2:  206:parser_init_literal_pool (parser_context_t *context_p, /**< context */
        -:  207:                          ecma_value_t *literal_pool_p) /**< start of literal pool */
        -:  208:{
        2:  209:  parser_list_iterator_t literal_iterator;
        -:  210:  lexer_literal_t *literal_p;
        -:  211:
        2:  212:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        -:  213:
        9:  214:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:  215:  {
        5:  216:    switch (literal_p->type)
        -:  217:    {
        4:  218:      case LEXER_IDENT_LITERAL:
        -:  219:      {
        4:  220:        if (!(literal_p->status_flags & LEXER_FLAG_USED))
        -:  221:        {
        1:  222:          break;
        -:  223:        }
        -:  224:        /* FALLTHRU */
        -:  225:      }
        -:  226:      case LEXER_STRING_LITERAL:
        -:  227:      {
        3:  228:        ecma_value_t lit_value = literal_p->u.value;
        -:  229:
        3:  230:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        3:  231:        literal_pool_p[literal_p->prop.index] = lit_value;
        3:  232:        break;
        -:  233:      }
    #####:  234:      case LEXER_NUMBER_LITERAL:
        -:  235:      {
    #####:  236:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        -:  237:
    #####:  238:        literal_pool_p[literal_p->prop.index] = literal_p->u.value;
    #####:  239:        break;
        -:  240:      }
        1:  241:      case LEXER_FUNCTION_LITERAL:
        -:  242:      case LEXER_REGEXP_LITERAL:
        -:  243:      {
        1:  244:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        -:  245:
        1:  246:        ECMA_SET_INTERNAL_VALUE_POINTER (literal_pool_p[literal_p->prop.index], literal_p->u.bytecode_p);
        1:  247:        break;
        -:  248:      }
    #####:  249:      default:
        -:  250:      {
    #####:  251:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);
    #####:  252:        break;
        -:  253:      }
        -:  254:    }
    #####:  255:  }
        2:  256:} /* parser_init_literal_pool */
        -:  257:
        -:  258:/*
        -:  259: * During byte code post processing certain bytes are not
        -:  260: * copied into the final byte code buffer. For example, if
        -:  261: * one byte is enough for encoding a literal index, the
        -:  262: * second byte is not copied. However, when a byte is skipped,
        -:  263: * the offsets of those branches which crosses (jumps over)
        -:  264: * that byte code should also be decreased by one. Instead
        -:  265: * of finding these jumps every time when a byte is skipped,
        -:  266: * all branch offset updates are computed in one step.
        -:  267: *
        -:  268: * Branch offset mapping example:
        -:  269: *
        -:  270: * Let's assume that each parser_mem_page of the byte_code
        -:  271: * buffer is 8 bytes long and only 4 bytes are kept for a
        -:  272: * given page:
        -:  273: *
        -:  274: * +---+---+---+---+---+---+---+---+
        -:  275: * | X | 1 | 2 | 3 | X | 4 | X | X |
        -:  276: * +---+---+---+---+---+---+---+---+
        -:  277: *
        -:  278: * X marks those bytes which are removed. The resulting
        -:  279: * offset mapping is the following:
        -:  280: *
        -:  281: * +---+---+---+---+---+---+---+---+
        -:  282: * | 0 | 1 | 2 | 3 | 3 | 4 | 4 | 4 |
        -:  283: * +---+---+---+---+---+---+---+---+
        -:  284: *
        -:  285: * Each X is simply replaced by the index of the previous
        -:  286: * index starting from zero. This shows the number of
        -:  287: * copied bytes before a given byte including the byte
        -:  288: * itself. The last byte always shows the number of bytes
        -:  289: * copied from this page.
        -:  290: *
        -:  291: * This mapping allows recomputing all branch targets,
        -:  292: * since mapping[to] - mapping[from] is the new argument
        -:  293: * for forward branches. As for backward branches, the
        -:  294: * equation is reversed to mapping[from] - mapping[to].
        -:  295: *
        -:  296: * The mapping is relative to one page, so distance
        -:  297: * computation affecting multiple pages requires a loop.
        -:  298: * We should also note that only argument bytes can
        -:  299: * be skipped, so removed bytes cannot be targeted by
        -:  300: * branches. Valid branches always target instruction
        -:  301: * starts only.
        -:  302: */
        -:  303:
        -:  304:/**
        -:  305: * Recompute the argument of a forward branch.
        -:  306: *
        -:  307: * @return the new distance
        -:  308: */
        -:  309:static size_t
        2:  310:parser_update_forward_branch (parser_mem_page_t *page_p, /**< current page */
        -:  311:                              size_t full_distance, /**< full distance */
        -:  312:                              uint8_t bytes_copied_before_jump) /**< bytes copied before jump */
        -:  313:{
        2:  314:  size_t new_distance = 0;
        -:  315:
        4:  316:  while (full_distance > PARSER_CBC_STREAM_PAGE_SIZE)
        -:  317:  {
    #####:  318:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  319:    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  320:    page_p = page_p->next_p;
        -:  321:  }
        -:  322:
        2:  323:  new_distance += page_p->bytes[full_distance - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        2:  324:  return new_distance - bytes_copied_before_jump;
        -:  325:} /* parser_update_forward_branch */
        -:  326:
        -:  327:/**
        -:  328: * Recompute the argument of a backward branch.
        -:  329: *
        -:  330: * @return the new distance
        -:  331: */
        -:  332:static size_t
    #####:  333:parser_update_backward_branch (parser_mem_page_t *page_p, /**< current page */
        -:  334:                               size_t full_distance, /**< full distance */
        -:  335:                               uint8_t bytes_copied_before_jump) /**< bytes copied before jump */
        -:  336:{
    #####:  337:  size_t new_distance = bytes_copied_before_jump;
        -:  338:
    #####:  339:  while (full_distance >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  340:  {
    #####:  341:    JERRY_ASSERT (page_p != NULL);
    #####:  342:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  343:    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  344:    page_p = page_p->next_p;
        -:  345:  }
        -:  346:
    #####:  347:  if (full_distance > 0)
        -:  348:  {
    #####:  349:    size_t offset = PARSER_CBC_STREAM_PAGE_SIZE - full_distance;
        -:  350:
    #####:  351:    JERRY_ASSERT (page_p != NULL);
        -:  352:
    #####:  353:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  354:    new_distance -= page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        -:  355:  }
        -:  356:
    #####:  357:  return new_distance;
        -:  358:} /* parser_update_backward_branch */
        -:  359:
        -:  360:/**
        -:  361: * Update targets of all branches in one step.
        -:  362: */
        -:  363:static void
        2:  364:parse_update_branches (parser_context_t *context_p, /**< context */
        -:  365:                       uint8_t *byte_code_p) /**< byte code */
        -:  366:{
        2:  367:  parser_mem_page_t *page_p = context_p->byte_code.first_p;
        2:  368:  parser_mem_page_t *prev_page_p = NULL;
        2:  369:  parser_mem_page_t *last_page_p = context_p->byte_code.last_p;
        2:  370:  size_t last_position = context_p->byte_code.last_position;
        2:  371:  size_t offset = 0;
        2:  372:  size_t bytes_copied = 0;
        -:  373:
        2:  374:  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  375:  {
    #####:  376:    last_page_p = NULL;
    #####:  377:    last_position = 0;
        -:  378:  }
        -:  379:
       41:  380:  while (page_p != last_page_p || offset < last_position)
        -:  381:  {
        -:  382:    /* Branch instructions are marked to improve search speed. */
       37:  383:    if (page_p->bytes[offset] & CBC_HIGHEST_BIT_MASK)
        -:  384:    {
        2:  385:      uint8_t *bytes_p = byte_code_p + bytes_copied;
        -:  386:      uint8_t flags;
        2:  387:      uint8_t bytes_copied_before_jump = 0;
        -:  388:      size_t branch_argument_length;
        -:  389:      size_t target_distance;
        -:  390:      size_t length;
        -:  391:
        2:  392:      if (offset > 0)
        -:  393:      {
        2:  394:        bytes_copied_before_jump = page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        -:  395:      }
        2:  396:      bytes_p += bytes_copied_before_jump;
        -:  397:
        2:  398:      if (*bytes_p == CBC_EXT_OPCODE)
        -:  399:      {
        2:  400:        bytes_p++;
        2:  401:        flags = cbc_ext_flags[*bytes_p];
        -:  402:      }
        -:  403:      else
        -:  404:      {
    #####:  405:        flags = cbc_flags[*bytes_p];
        -:  406:      }
        -:  407:
        2:  408:      JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);
        2:  409:      branch_argument_length = CBC_BRANCH_OFFSET_LENGTH (*bytes_p);
        2:  410:      bytes_p++;
        -:  411:
        -:  412:      /* Decoding target. */
        2:  413:      length = branch_argument_length;
        2:  414:      target_distance = 0;
        -:  415:      do
        -:  416:      {
        2:  417:        target_distance = (target_distance << 8) | *bytes_p;
        2:  418:        bytes_p++;
        2:  419:      } while (--length > 0);
        -:  420:
        2:  421:      if (CBC_BRANCH_IS_FORWARD (flags))
        -:  422:      {
        -:  423:        /* Branch target was not set. */
        2:  424:        JERRY_ASSERT (target_distance > 0);
        -:  425:
        2:  426:        target_distance = parser_update_forward_branch (page_p, offset + target_distance, bytes_copied_before_jump);
        -:  427:      }
        -:  428:      else
        -:  429:      {
    #####:  430:        if (target_distance < offset)
        -:  431:        {
    #####:  432:          uint8_t bytes_copied_before_target = page_p->bytes[offset - target_distance - 1];
    #####:  433:          bytes_copied_before_target = bytes_copied_before_target & CBC_LOWER_SEVEN_BIT_MASK;
        -:  434:
    #####:  435:          target_distance = (size_t) (bytes_copied_before_jump - bytes_copied_before_target);
        -:  436:        }
    #####:  437:        else if (target_distance == offset)
        -:  438:        {
    #####:  439:          target_distance = bytes_copied_before_jump;
        -:  440:        }
        -:  441:        else
        -:  442:        {
    #####:  443:          target_distance =
    #####:  444:            parser_update_backward_branch (prev_page_p, target_distance - offset, bytes_copied_before_jump);
        -:  445:        }
        -:  446:      }
        -:  447:
        -:  448:      /* Encoding target again. */
        -:  449:      do
        -:  450:      {
        2:  451:        bytes_p--;
        2:  452:        *bytes_p = (uint8_t) (target_distance & 0xff);
        2:  453:        target_distance >>= 8;
        2:  454:      } while (--branch_argument_length > 0);
        -:  455:    }
        -:  456:
       37:  457:    offset++;
       37:  458:    if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  459:    {
    #####:  460:      parser_mem_page_t *next_p = page_p->next_p;
        -:  461:
        -:  462:      /* We reverse the pages before the current page. */
    #####:  463:      page_p->next_p = prev_page_p;
    #####:  464:      prev_page_p = page_p;
        -:  465:
    #####:  466:      bytes_copied += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  467:      page_p = next_p;
    #####:  468:      offset = 0;
        -:  469:    }
        -:  470:  }
        -:  471:
        -:  472:  /* After this point the pages of the byte code stream are
        -:  473:   * not used anymore. However, they needs to be freed during
        -:  474:   * cleanup, so the first and last pointers of the stream
        -:  475:   * descriptor are reversed as well. */
        2:  476:  if (last_page_p != NULL)
        -:  477:  {
        2:  478:    JERRY_ASSERT (last_page_p == context_p->byte_code.last_p);
        2:  479:    last_page_p->next_p = prev_page_p;
        -:  480:  }
        -:  481:  else
        -:  482:  {
    #####:  483:    last_page_p = context_p->byte_code.last_p;
        -:  484:  }
        -:  485:
        2:  486:  context_p->byte_code.last_p = context_p->byte_code.first_p;
        2:  487:  context_p->byte_code.first_p = last_page_p;
        2:  488:} /* parse_update_branches */
        -:  489:
        -:  490:#if JERRY_DEBUGGER
        -:  491:
        -:  492:/**
        -:  493: * Send current breakpoint list.
        -:  494: */
        -:  495:static void
        -:  496:parser_send_breakpoints (parser_context_t *context_p, /**< context */
        -:  497:                         jerry_debugger_header_type_t type) /**< message type */
        -:  498:{
        -:  499:  JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -:  500:  JERRY_ASSERT (context_p->breakpoint_info_count > 0);
        -:  501:
        -:  502:  jerry_debugger_send_data (type,
        -:  503:                            context_p->breakpoint_info,
        -:  504:                            context_p->breakpoint_info_count * sizeof (parser_breakpoint_info_t));
        -:  505:
        -:  506:  context_p->breakpoint_info_count = 0;
        -:  507:} /* parser_send_breakpoints */
        -:  508:
        -:  509:/**
        -:  510: * Append a breakpoint info.
        -:  511: */
        -:  512:void
        -:  513:parser_append_breakpoint_info (parser_context_t *context_p, /**< context */
        -:  514:                               jerry_debugger_header_type_t type, /**< message type */
        -:  515:                               uint32_t value) /**< line or offset of the breakpoint */
        -:  516:{
        -:  517:  JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -:  518:
        -:  519:  context_p->status_flags |= PARSER_DEBUGGER_BREAKPOINT_APPENDED;
        -:  520:
        -:  521:  if (context_p->breakpoint_info_count >= JERRY_DEBUGGER_SEND_MAX (parser_breakpoint_info_t))
        -:  522:  {
        -:  523:    parser_send_breakpoints (context_p, type);
        -:  524:  }
        -:  525:
        -:  526:  context_p->breakpoint_info[context_p->breakpoint_info_count].value = value;
        -:  527:  context_p->breakpoint_info_count = (uint16_t) (context_p->breakpoint_info_count + 1);
        -:  528:} /* parser_append_breakpoint_info */
        -:  529:
        -:  530:#endif /* JERRY_DEBUGGER */
        -:  531:
        -:  532:/**
        -:  533: * Forward iterator: move to the next byte code
        -:  534: *
        -:  535: * @param page_p page
        -:  536: * @param offset offset
        -:  537: */
        -:  538:#define PARSER_NEXT_BYTE(page_p, offset)           \
        -:  539:  do                                               \
        -:  540:  {                                                \
        -:  541:    if (++(offset) >= PARSER_CBC_STREAM_PAGE_SIZE) \
        -:  542:    {                                              \
        -:  543:      offset = 0;                                  \
        -:  544:      page_p = page_p->next_p;                     \
        -:  545:    }                                              \
        -:  546:  } while (0)
        -:  547:
        -:  548:/**
        -:  549: * Forward iterator: move to the next byte code. Also updates the offset of the previous byte code.
        -:  550: *
        -:  551: * @param page_p page
        -:  552: * @param offset offset
        -:  553: * @param real_offset real offset
        -:  554: */
        -:  555:#define PARSER_NEXT_BYTE_UPDATE(page_p, offset, real_offset) \
        -:  556:  do                                                         \
        -:  557:  {                                                          \
        -:  558:    page_p->bytes[offset] = real_offset;                     \
        -:  559:    if (++(offset) >= PARSER_CBC_STREAM_PAGE_SIZE)           \
        -:  560:    {                                                        \
        -:  561:      offset = 0;                                            \
        -:  562:      real_offset = 0;                                       \
        -:  563:      page_p = page_p->next_p;                               \
        -:  564:    }                                                        \
        -:  565:  } while (0)
        -:  566:
        -:  567:/**
        -:  568: * Post processing main function.
        -:  569: *
        -:  570: * @return compiled code
        -:  571: */
        -:  572:static ecma_compiled_code_t *
        2:  573:parser_post_processing (parser_context_t *context_p) /**< context */
        -:  574:{
        -:  575:  uint16_t literal_one_byte_limit;
        2:  576:  uint16_t ident_end;
        2:  577:  uint16_t const_literal_end;
        -:  578:  parser_mem_page_t *page_p;
        -:  579:  parser_mem_page_t *last_page_p;
        -:  580:  size_t last_position;
        -:  581:  size_t offset;
        -:  582:  size_t length;
        -:  583:  size_t literal_length;
        -:  584:  size_t total_size;
        -:  585:  uint8_t real_offset;
        -:  586:  uint8_t *byte_code_p;
        -:  587:  bool needs_uint16_arguments;
        2:  588:  cbc_opcode_t last_opcode = CBC_EXT_OPCODE;
        -:  589:  ecma_compiled_code_t *compiled_code_p;
        -:  590:  ecma_value_t *literal_pool_p;
        -:  591:  uint8_t *dst_p;
        -:  592:
        -:  593:#if JERRY_ESNEXT
        2:  594:  if ((context_p->status_flags & (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))
        -:  595:      == (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))
        -:  596:  {
    #####:  597:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  598:#ifndef JERRY_NDEBUG
    #####:  599:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  600:#endif /* !JERRY_NDEBUG */
        -:  601:
    #####:  602:    context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;
        -:  603:
    #####:  604:    parser_emit_cbc (context_p, CBC_CONTEXT_END);
        -:  605:
    #####:  606:    parser_branch_t branch;
    #####:  607:    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####:  608:    parser_set_branch_to_current_position (context_p, &branch);
        -:  609:
    #####:  610:    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));
        -:  611:  }
        -:  612:
        2:  613:  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -:  614:  {
    #####:  615:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -:  616:#ifndef JERRY_NDEBUG
    #####:  617:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -:  618:#endif /* !JERRY_NDEBUG */
        -:  619:
    #####:  620:    if (context_p->stack_limit < PARSER_FINALLY_CONTEXT_STACK_ALLOCATION)
        -:  621:    {
    #####:  622:      context_p->stack_limit = PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -:  623:    }
        -:  624:
    #####:  625:    parser_branch_t branch;
        -:  626:
    #####:  627:    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####:  628:    parser_set_branch_to_current_position (context_p, &branch);
        -:  629:
    #####:  630:    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));
        -:  631:  }
        -:  632:#endif /* JERRY_ESNEXT */
        -:  633:
        -:  634:#if JERRY_LINE_INFO
        -:  635:  JERRY_ASSERT (context_p->line_info_p != NULL);
        -:  636:#endif /* JERRY_LINE_INFO */
        -:  637:
        2:  638:  JERRY_ASSERT (context_p->stack_depth == 0);
        -:  639:#ifndef JERRY_NDEBUG
        2:  640:  JERRY_ASSERT (context_p->context_stack_depth == 0);
        -:  641:#endif /* !JERRY_NDEBUG */
        -:  642:
        2:  643:  if ((size_t) context_p->stack_limit + (size_t) context_p->register_count > PARSER_MAXIMUM_STACK_LIMIT)
        -:  644:  {
    #####:  645:    parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  646:  }
        -:  647:
        2:  648:  if (JERRY_UNLIKELY (context_p->script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -:  649:  {
        -:  650:    /* This is probably never happens in practice. */
    #####:  651:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -:  652:  }
        -:  653:
        2:  654:  context_p->script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
        -:  655:
        2:  656:  JERRY_ASSERT (context_p->literal_count <= PARSER_MAXIMUM_NUMBER_OF_LITERALS);
        -:  657:
        -:  658:#if JERRY_DEBUGGER
        -:  659:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  660:      && !(context_p->status_flags & PARSER_DEBUGGER_BREAKPOINT_APPENDED))
        -:  661:  {
        -:  662:    /* Always provide at least one breakpoint. */
        -:  663:    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -:  664:    parser_flush_cbc (context_p);
        -:  665:
        -:  666:    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);
        -:  667:
        -:  668:    context_p->last_breakpoint_line = context_p->token.line;
        -:  669:  }
        -:  670:
        -:  671:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -:  672:  {
        -:  673:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);
        -:  674:    JERRY_ASSERT (context_p->breakpoint_info_count == 0);
        -:  675:  }
        -:  676:#endif /* JERRY_DEBUGGER */
        -:  677:
        2:  678:  parser_compute_indicies (context_p, &ident_end, &const_literal_end);
        -:  679:
        2:  680:  if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)
        -:  681:  {
        2:  682:    literal_one_byte_limit = CBC_MAXIMUM_BYTE_VALUE - 1;
        -:  683:  }
        -:  684:  else
        -:  685:  {
    #####:  686:    literal_one_byte_limit = CBC_LOWER_SEVEN_BIT_MASK;
        -:  687:  }
        -:  688:
        2:  689:  last_page_p = context_p->byte_code.last_p;
        2:  690:  last_position = context_p->byte_code.last_position;
        -:  691:
        2:  692:  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  693:  {
    #####:  694:    last_page_p = NULL;
    #####:  695:    last_position = 0;
        -:  696:  }
        -:  697:
        2:  698:  page_p = context_p->byte_code.first_p;
        2:  699:  offset = 0;
        2:  700:  length = 0;
        -:  701:
       17:  702:  while (page_p != last_page_p || offset < last_position)
        -:  703:  {
        -:  704:    uint8_t *opcode_p;
        -:  705:    uint8_t flags;
        -:  706:    size_t branch_offset_length;
        -:  707:
       13:  708:    opcode_p = page_p->bytes + offset;
       13:  709:    last_opcode = (cbc_opcode_t) (*opcode_p);
       13:  710:    PARSER_NEXT_BYTE (page_p, offset);
       13:  711:    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (last_opcode);
       13:  712:    flags = cbc_flags[last_opcode];
       13:  713:    length++;
        -:  714:
       13:  715:    switch (last_opcode)
        -:  716:    {
        2:  717:      case CBC_EXT_OPCODE:
        -:  718:      {
        -:  719:        cbc_ext_opcode_t ext_opcode;
        -:  720:
        2:  721:        ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];
        2:  722:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);
        2:  723:        flags = cbc_ext_flags[ext_opcode];
        2:  724:        PARSER_NEXT_BYTE (page_p, offset);
        2:  725:        length++;
        2:  726:        break;
        -:  727:      }
    #####:  728:      case CBC_POST_DECR:
        -:  729:      {
    #####:  730:        *opcode_p = CBC_PRE_DECR;
    #####:  731:        break;
        -:  732:      }
    #####:  733:      case CBC_POST_INCR:
        -:  734:      {
    #####:  735:        *opcode_p = CBC_PRE_INCR;
    #####:  736:        break;
        -:  737:      }
    #####:  738:      case CBC_POST_DECR_IDENT:
        -:  739:      {
    #####:  740:        *opcode_p = CBC_PRE_DECR_IDENT;
    #####:  741:        break;
        -:  742:      }
    #####:  743:      case CBC_POST_INCR_IDENT:
        -:  744:      {
    #####:  745:        *opcode_p = CBC_PRE_INCR_IDENT;
    #####:  746:        break;
        -:  747:      }
       11:  748:      default:
        -:  749:      {
       11:  750:        break;
        -:  751:      }
        -:  752:    }
        -:  753:
       28:  754:    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  755:    {
        8:  756:      uint8_t *first_byte = page_p->bytes + offset;
        8:  757:      uint32_t literal_index = *first_byte;
        -:  758:
        8:  759:      PARSER_NEXT_BYTE (page_p, offset);
        8:  760:      length++;
        -:  761:
        8:  762:      literal_index |= ((uint32_t) page_p->bytes[offset]) << 8;
        -:  763:
        8:  764:      if (literal_index >= PARSER_REGISTER_START)
        -:  765:      {
        2:  766:        literal_index -= PARSER_REGISTER_START;
        -:  767:      }
        -:  768:      else
        -:  769:      {
        6:  770:        literal_index = (PARSER_GET_LITERAL (literal_index))->prop.index;
        -:  771:      }
        -:  772:
        8:  773:      if (literal_index <= literal_one_byte_limit)
        -:  774:      {
        8:  775:        *first_byte = (uint8_t) literal_index;
        -:  776:      }
        -:  777:      else
        -:  778:      {
    #####:  779:        if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)
        -:  780:        {
    #####:  781:          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_SMALL_VALUE);
    #####:  782:          *first_byte = CBC_MAXIMUM_BYTE_VALUE;
    #####:  783:          page_p->bytes[offset] = (uint8_t) (literal_index - CBC_MAXIMUM_BYTE_VALUE);
    #####:  784:          length++;
        -:  785:        }
        -:  786:        else
        -:  787:        {
    #####:  788:          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_FULL_VALUE);
    #####:  789:          *first_byte = (uint8_t) ((literal_index >> 8) | CBC_HIGHEST_BIT_MASK);
    #####:  790:          page_p->bytes[offset] = (uint8_t) (literal_index & 0xff);
    #####:  791:          length++;
        -:  792:        }
        -:  793:      }
        8:  794:      PARSER_NEXT_BYTE (page_p, offset);
        -:  795:
        8:  796:      if (flags & CBC_HAS_LITERAL_ARG2)
        -:  797:      {
        2:  798:        if (flags & CBC_HAS_LITERAL_ARG)
        -:  799:        {
        2:  800:          flags = CBC_HAS_LITERAL_ARG;
        -:  801:        }
        -:  802:        else
        -:  803:        {
    #####:  804:          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;
        -:  805:        }
        -:  806:      }
        -:  807:      else
        -:  808:      {
        6:  809:        break;
        -:  810:      }
        -:  811:    }
        -:  812:
       13:  813:    if (flags & CBC_HAS_BYTE_ARG)
        -:  814:    {
        -:  815:      /* This argument will be copied without modification. */
    #####:  816:      PARSER_NEXT_BYTE (page_p, offset);
    #####:  817:      length++;
        -:  818:    }
        -:  819:
       13:  820:    if (flags & CBC_HAS_BRANCH_ARG)
        -:  821:    {
        2:  822:      bool prefix_zero = true;
        -:  823:
        -:  824:      /* The leading zeroes are dropped from the stream.
        -:  825:       * Although dropping these zeroes for backward
        -:  826:       * branches are unnecessary, we use the same
        -:  827:       * code path for simplicity. */
        2:  828:      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);
        -:  829:
        8:  830:      while (--branch_offset_length > 0)
        -:  831:      {
        4:  832:        uint8_t byte = page_p->bytes[offset];
        4:  833:        if (byte > 0 || !prefix_zero)
        -:  834:        {
    #####:  835:          prefix_zero = false;
    #####:  836:          length++;
        -:  837:        }
        -:  838:        else
        -:  839:        {
        4:  840:          JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));
        -:  841:        }
        4:  842:        PARSER_NEXT_BYTE (page_p, offset);
        -:  843:      }
        -:  844:
        2:  845:      if (last_opcode == (cbc_opcode_t) (CBC_JUMP_FORWARD + PARSER_MAX_BRANCH_LENGTH - 1) && prefix_zero
    #####:  846:          && page_p->bytes[offset] == PARSER_MAX_BRANCH_LENGTH + 1)
        -:  847:      {
        -:  848:        /* Uncoditional jumps which jump right after the instruction
        -:  849:         * are effectively NOPs. These jumps are removed from the
        -:  850:         * stream. The 1 byte long CBC_JUMP_FORWARD form marks these
        -:  851:         * instructions, since this form is constructed during post
        -:  852:         * processing and cannot be emitted directly. */
    #####:  853:        *opcode_p = CBC_JUMP_FORWARD;
    #####:  854:        length--;
        -:  855:      }
        -:  856:      else
        -:  857:      {
        -:  858:        /* Other last bytes are always copied. */
        2:  859:        length++;
        -:  860:      }
        -:  861:
        2:  862:      PARSER_NEXT_BYTE (page_p, offset);
        -:  863:    }
        -:  864:  }
        -:  865:
        2:  866:  if (!(context_p->status_flags & PARSER_NO_END_LABEL) || !(PARSER_OPCODE_IS_RETURN (last_opcode)))
        -:  867:  {
        2:  868:    context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;
        -:  869:
        -:  870:#if JERRY_ESNEXT
        2:  871:    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -:  872:    {
    #####:  873:      length++;
        -:  874:    }
        -:  875:#endif /* JERRY_ESNEXT */
        -:  876:
        2:  877:    length++;
        -:  878:  }
        -:  879:
        2:  880:  needs_uint16_arguments = false;
        2:  881:  total_size = sizeof (cbc_uint8_arguments_t);
        -:  882:
        2:  883:  if (context_p->stack_limit > CBC_MAXIMUM_BYTE_VALUE || context_p->register_count > CBC_MAXIMUM_BYTE_VALUE
        2:  884:      || context_p->literal_count > CBC_MAXIMUM_BYTE_VALUE)
        -:  885:  {
    #####:  886:    needs_uint16_arguments = true;
    #####:  887:    total_size = sizeof (cbc_uint16_arguments_t);
        -:  888:  }
        -:  889:
        2:  890:  literal_length = (size_t) (context_p->literal_count - context_p->register_count) * sizeof (ecma_value_t);
        -:  891:
        2:  892:  total_size += literal_length + length;
        -:  893:
        2:  894:  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -:  895:  {
    #####:  896:    total_size += context_p->argument_count * sizeof (ecma_value_t);
        -:  897:  }
        -:  898:
        -:  899:#if JERRY_ESNEXT
        -:  900:  /* function.name */
        2:  901:  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))
        -:  902:  {
        2:  903:    total_size += sizeof (ecma_value_t);
        -:  904:  }
        -:  905:
        2:  906:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -:  907:  {
    #####:  908:    total_size += sizeof (ecma_value_t);
        -:  909:  }
        -:  910:#endif /* JERRY_ESNEXT */
        -:  911:
        -:  912:#if JERRY_LINE_INFO
    #####:  913:  total_size += sizeof (ecma_value_t);
        -:  914:#endif /* JERRY_LINE_INFO */
        -:  915:
        -:  916:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        2:  917:  uint8_t extended_info = 0;
        -:  918:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  919:
        -:  920:#if JERRY_ESNEXT
        2:  921:  if (context_p->argument_length != UINT16_MAX)
        -:  922:  {
    #####:  923:    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH;
    #####:  924:    total_size += ecma_extended_info_get_encoded_length (context_p->argument_length);
        -:  925:  }
        -:  926:#endif /* JERRY_ESNEXT */
        -:  927:
        -:  928:#if JERRY_FUNCTION_TO_STRING
    #####:  929:  if (context_p->last_context_p != NULL)
        -:  930:  {
    #####:  931:    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_SOURCE_CODE_RANGE;
        -:  932:
    #####:  933:    const uint8_t *start_p = context_p->source_start_p;
    #####:  934:    const uint8_t *function_start_p = context_p->last_context_p->function_start_p;
        -:  935:
    #####:  936:    if (function_start_p < start_p || function_start_p >= start_p + context_p->source_size)
        -:  937:    {
        -:  938:      JERRY_ASSERT (context_p->arguments_start_p != NULL && function_start_p >= context_p->arguments_start_p
        -:  939:                    && function_start_p < context_p->arguments_start_p + context_p->arguments_size);
        -:  940:
    #####:  941:      start_p = context_p->arguments_start_p;
    #####:  942:      extended_info |= CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS;
        -:  943:    }
        -:  944:
    #####:  945:    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (function_start_p - start_p));
    #####:  946:    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (context_p->function_end_p - function_start_p));
        -:  947:  }
        -:  948:#endif /* JERRY_FUNCTION_TO_STRING */
        -:  949:
        -:  950:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        2:  951:  if (extended_info != 0)
        -:  952:  {
    #####:  953:    total_size += sizeof (uint8_t);
        -:  954:  }
        -:  955:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  956:
        2:  957:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -:  958:
        2:  959:  compiled_code_p = (ecma_compiled_code_t *) parser_malloc (context_p, total_size);
        -:  960:
        -:  961:#if JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE
        -:  962:  // Avoid getting junk bytes
    #####:  963:  memset (compiled_code_p, 0, total_size);
        -:  964:#endif /* JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE */
        -:  965:
        -:  966:#if JERRY_MEM_STATS
    #####:  967:  jmem_stats_allocate_byte_code_bytes (total_size);
        -:  968:#endif /* JERRY_MEM_STATS */
        -:  969:
        2:  970:  byte_code_p = (uint8_t *) compiled_code_p;
        2:  971:  compiled_code_p->size = (uint16_t) (total_size >> JMEM_ALIGNMENT_LOG);
        2:  972:  compiled_code_p->refs = 1;
        2:  973:  compiled_code_p->status_flags = 0;
        -:  974:
        -:  975:#if JERRY_ESNEXT
        2:  976:  if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -:  977:  {
    #####:  978:    JERRY_ASSERT (context_p->argument_count > 0);
    #####:  979:    context_p->argument_count--;
        -:  980:  }
        -:  981:#endif /* JERRY_ESNEXT */
        -:  982:
        2:  983:  if (needs_uint16_arguments)
        -:  984:  {
    #####:  985:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -:  986:
    #####:  987:    args_p->stack_limit = context_p->stack_limit;
    #####:  988:    args_p->script_value = context_p->script_value;
    #####:  989:    args_p->argument_end = context_p->argument_count;
    #####:  990:    args_p->register_end = context_p->register_count;
    #####:  991:    args_p->ident_end = ident_end;
    #####:  992:    args_p->const_literal_end = const_literal_end;
    #####:  993:    args_p->literal_end = context_p->literal_count;
        -:  994:
    #####:  995:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_UINT16_ARGUMENTS;
    #####:  996:    byte_code_p += sizeof (cbc_uint16_arguments_t);
        -:  997:  }
        -:  998:  else
        -:  999:  {
        2: 1000:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 1001:
        2: 1002:    args_p->stack_limit = (uint8_t) context_p->stack_limit;
        2: 1003:    args_p->argument_end = (uint8_t) context_p->argument_count;
        2: 1004:    args_p->script_value = context_p->script_value;
        2: 1005:    args_p->register_end = (uint8_t) context_p->register_count;
        2: 1006:    args_p->ident_end = (uint8_t) ident_end;
        2: 1007:    args_p->const_literal_end = (uint8_t) const_literal_end;
        2: 1008:    args_p->literal_end = (uint8_t) context_p->literal_count;
        -: 1009:
        2: 1010:    byte_code_p += sizeof (cbc_uint8_arguments_t);
        -: 1011:  }
        -: 1012:
        -: 1013:  uint16_t encoding_limit;
        -: 1014:  uint16_t encoding_delta;
        -: 1015:
        2: 1016:  if (context_p->literal_count > CBC_MAXIMUM_SMALL_VALUE)
        -: 1017:  {
    #####: 1018:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_FULL_LITERAL_ENCODING;
    #####: 1019:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1020:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1021:  }
        -: 1022:  else
        -: 1023:  {
        2: 1024:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
        2: 1025:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 1026:  }
        -: 1027:
        2: 1028:  if (context_p->status_flags & PARSER_IS_STRICT)
        -: 1029:  {
    #####: 1030:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_STRICT_MODE;
        -: 1031:  }
        -: 1032:
        2: 1033:  if ((context_p->status_flags & PARSER_ARGUMENTS_NEEDED) && PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -: 1034:  {
    #####: 1035:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED;
        -: 1036:  }
        -: 1037:
        2: 1038:  if (!(context_p->status_flags & PARSER_LEXICAL_ENV_NEEDED))
        -: 1039:  {
        1: 1040:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED;
        -: 1041:  }
        -: 1042:
        2: 1043:  uint16_t function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_NORMAL);
        -: 1044:
        2: 1045:  if (context_p->status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))
        -: 1046:  {
    #####: 1047:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ACCESSOR);
        -: 1048:  }
        2: 1049:  else if (!(context_p->status_flags & PARSER_IS_FUNCTION))
        -: 1050:  {
        1: 1051:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_SCRIPT);
        -: 1052:  }
        -: 1053:#if JERRY_ESNEXT
        1: 1054:  else if (context_p->status_flags & PARSER_IS_ARROW_FUNCTION)
        -: 1055:  {
    #####: 1056:    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1057:    {
    #####: 1058:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_ARROW);
        -: 1059:    }
        -: 1060:    else
        -: 1061:    {
    #####: 1062:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ARROW);
        -: 1063:    }
        -: 1064:  }
        1: 1065:  else if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1066:  {
    #####: 1067:    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1068:    {
    #####: 1069:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1070:    }
        -: 1071:    else
        -: 1072:    {
    #####: 1073:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_GENERATOR);
        -: 1074:    }
        -: 1075:  }
        1: 1076:  else if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1077:  {
    #####: 1078:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC);
        -: 1079:  }
        1: 1080:  else if (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR)
        -: 1081:  {
    #####: 1082:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_CONSTRUCTOR);
        -: 1083:  }
        1: 1084:  else if (context_p->status_flags & PARSER_IS_METHOD)
        -: 1085:  {
    #####: 1086:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_METHOD);
        -: 1087:  }
        -: 1088:
        2: 1089:  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
        -: 1090:  {
    #####: 1091:    JERRY_ASSERT (!(context_p->status_flags & PARSER_IS_FUNCTION));
    #####: 1092:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED;
        -: 1093:  }
        -: 1094:#endif /* JERRY_ESNEXT */
        -: 1095:
        2: 1096:  compiled_code_p->status_flags |= function_type;
        -: 1097:
        -: 1098:#if JERRY_LINE_INFO
    #####: 1099:  compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_LINE_INFO;
        -: 1100:#endif /* JERRY_LINE_INFO */
        -: 1101:
        2: 1102:  literal_pool_p = ((ecma_value_t *) byte_code_p) - context_p->register_count;
        2: 1103:  byte_code_p += literal_length;
        2: 1104:  dst_p = byte_code_p;
        -: 1105:
        2: 1106:  parser_init_literal_pool (context_p, literal_pool_p);
        -: 1107:
        2: 1108:  page_p = context_p->byte_code.first_p;
        2: 1109:  offset = 0;
        2: 1110:  real_offset = 0;
        2: 1111:  uint8_t last_register_index =
        2: 1112:    (uint8_t) JERRY_MIN (context_p->register_count, (PARSER_MAXIMUM_NUMBER_OF_REGISTERS - 1));
        -: 1113:
       17: 1114:  while (page_p != last_page_p || offset < last_position)
        -: 1115:  {
        -: 1116:    uint8_t flags;
        -: 1117:    uint8_t *opcode_p;
        -: 1118:    uint8_t *branch_mark_p;
        -: 1119:    cbc_opcode_t opcode;
        -: 1120:    size_t branch_offset_length;
        -: 1121:
       13: 1122:    opcode_p = dst_p;
       13: 1123:    branch_mark_p = page_p->bytes + offset;
       13: 1124:    opcode = (cbc_opcode_t) (*branch_mark_p);
       13: 1125:    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        -: 1126:
       13: 1127:    if (opcode == CBC_JUMP_FORWARD)
        -: 1128:    {
        -: 1129:      /* These opcodes are deleted from the stream. */
    #####: 1130:      size_t counter = PARSER_MAX_BRANCH_LENGTH + 1;
        -: 1131:
        -: 1132:      do
        -: 1133:      {
    #####: 1134:        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
    #####: 1135:      } while (--counter > 0);
        -: 1136:
    #####: 1137:      continue;
        -: 1138:    }
        -: 1139:
        -: 1140:    /* Storing the opcode */
       13: 1141:    *dst_p++ = (uint8_t) opcode;
       13: 1142:    real_offset++;
       13: 1143:    PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
       13: 1144:    flags = cbc_flags[opcode];
        -: 1145:
        -: 1146:#if JERRY_DEBUGGER
        -: 1147:    if (opcode == CBC_BREAKPOINT_DISABLED)
        -: 1148:    {
        -: 1149:      uint32_t bp_offset = (uint32_t) (((uint8_t *) dst_p) - ((uint8_t *) compiled_code_p) - 1);
        -: 1150:      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST, bp_offset);
        -: 1151:    }
        -: 1152:#endif /* JERRY_DEBUGGER */
        -: 1153:
       13: 1154:    if (opcode == CBC_EXT_OPCODE)
        -: 1155:    {
        -: 1156:      cbc_ext_opcode_t ext_opcode;
        -: 1157:
        2: 1158:      ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];
        2: 1159:      flags = cbc_ext_flags[ext_opcode];
        2: 1160:      branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);
        -: 1161:
        -: 1162:      /* Storing the extended opcode */
        2: 1163:      *dst_p++ = (uint8_t) ext_opcode;
        2: 1164:      opcode_p++;
        2: 1165:      real_offset++;
        2: 1166:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1167:    }
        -: 1168:
        -: 1169:    /* Only literal and call arguments can be combined. */
       13: 1170:    JERRY_ASSERT (!(flags & CBC_HAS_BRANCH_ARG) || !(flags & (CBC_HAS_BYTE_ARG | CBC_HAS_LITERAL_ARG)));
        -: 1171:
       28: 1172:    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -: 1173:    {
        8: 1174:      uint16_t first_byte = page_p->bytes[offset];
        -: 1175:
        8: 1176:      uint8_t *opcode_pos_p = dst_p - 1;
        8: 1177:      *dst_p++ = (uint8_t) first_byte;
        8: 1178:      real_offset++;
        8: 1179:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1180:
        8: 1181:      if (first_byte > literal_one_byte_limit)
        -: 1182:      {
    #####: 1183:        *dst_p++ = page_p->bytes[offset];
        -: 1184:
    #####: 1185:        if (first_byte >= encoding_limit)
        -: 1186:        {
    #####: 1187:          first_byte = (uint16_t) (((first_byte << 8) | dst_p[-1]) - encoding_delta);
        -: 1188:        }
    #####: 1189:        real_offset++;
        -: 1190:      }
        8: 1191:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1192:
        8: 1193:      if (flags & CBC_HAS_LITERAL_ARG2)
        -: 1194:      {
        2: 1195:        if (flags & CBC_HAS_LITERAL_ARG)
        -: 1196:        {
        2: 1197:          flags = CBC_HAS_LITERAL_ARG;
        -: 1198:        }
        -: 1199:        else
        -: 1200:        {
    #####: 1201:          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;
        -: 1202:        }
        -: 1203:      }
        -: 1204:      else
        -: 1205:      {
        6: 1206:        if (opcode == CBC_ASSIGN_SET_IDENT && JERRY_LIKELY (first_byte < last_register_index))
        -: 1207:        {
        1: 1208:          *opcode_pos_p = CBC_MOV_IDENT;
        -: 1209:        }
        -: 1210:
        6: 1211:        break;
        -: 1212:      }
        -: 1213:    }
        -: 1214:
       13: 1215:    if (flags & CBC_HAS_BYTE_ARG)
        -: 1216:    {
        -: 1217:      /* This argument will be copied without modification. */
    #####: 1218:      *dst_p++ = page_p->bytes[offset];
    #####: 1219:      real_offset++;
    #####: 1220:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
    #####: 1221:      continue;
        -: 1222:    }
        -: 1223:
       13: 1224:    if (flags & CBC_HAS_BRANCH_ARG)
        -: 1225:    {
        2: 1226:      *branch_mark_p |= CBC_HIGHEST_BIT_MASK;
        2: 1227:      bool prefix_zero = true;
        -: 1228:
        -: 1229:      /* The leading zeroes are dropped from the stream. */
        2: 1230:      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);
        -: 1231:
        8: 1232:      while (--branch_offset_length > 0)
        -: 1233:      {
        4: 1234:        uint8_t byte = page_p->bytes[offset];
        4: 1235:        if (byte > 0 || !prefix_zero)
        -: 1236:        {
    #####: 1237:          prefix_zero = false;
    #####: 1238:          *dst_p++ = page_p->bytes[offset];
    #####: 1239:          real_offset++;
        -: 1240:        }
        -: 1241:        else
        -: 1242:        {
        -: 1243:          /* When a leading zero is dropped, the branch
        -: 1244:           * offset length must be decreased as well. */
        4: 1245:          (*opcode_p)--;
        -: 1246:        }
        4: 1247:        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1248:      }
        -: 1249:
        2: 1250:      *dst_p++ = page_p->bytes[offset];
        2: 1251:      real_offset++;
        2: 1252:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        2: 1253:      continue;
        -: 1254:    }
        -: 1255:  }
        -: 1256:
        -: 1257:#if JERRY_DEBUGGER
        -: 1258:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -: 1259:  {
        -: 1260:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST);
        -: 1261:    JERRY_ASSERT (context_p->breakpoint_info_count == 0);
        -: 1262:  }
        -: 1263:#endif /* JERRY_DEBUGGER */
        -: 1264:
        2: 1265:  if (!(context_p->status_flags & PARSER_NO_END_LABEL))
        -: 1266:  {
        2: 1267:    *dst_p++ = CBC_RETURN_FUNCTION_END;
        -: 1268:
        -: 1269:#if JERRY_ESNEXT
        2: 1270:    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -: 1271:    {
    #####: 1272:      dst_p[-1] = CBC_EXT_OPCODE;
    #####: 1273:      dst_p[0] = CBC_EXT_ASYNC_EXIT;
    #####: 1274:      dst_p++;
        -: 1275:    }
        -: 1276:#endif /* JERRY_ESNEXT */
        -: 1277:  }
        2: 1278:  JERRY_ASSERT (dst_p == byte_code_p + length);
        -: 1279:
        -: 1280:#if JERRY_LINE_INFO
    #####: 1281:  uint8_t *line_info_p = parser_line_info_generate (context_p);
        -: 1282:#endif /* JERRY_LINE_INFO */
        -: 1283:
        2: 1284:  parse_update_branches (context_p, byte_code_p);
        -: 1285:
        2: 1286:  parser_cbc_stream_free (&context_p->byte_code);
        -: 1287:
        2: 1288:  if (context_p->status_flags & PARSER_HAS_LATE_LIT_INIT)
        -: 1289:  {
        2: 1290:    parser_list_iterator_t literal_iterator;
        -: 1291:    lexer_literal_t *literal_p;
        2: 1292:    uint16_t register_count = context_p->register_count;
        -: 1293:
        2: 1294:    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        9: 1295:    while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -: 1296:    {
        5: 1297:      if ((literal_p->status_flags & LEXER_FLAG_LATE_INIT) && literal_p->prop.index >= register_count)
        -: 1298:      {
        3: 1299:        uint32_t source_data = literal_p->u.source_data;
        3: 1300:        const uint8_t *char_p = context_p->source_end_p - (source_data & 0xfffff);
        3: 1301:        ecma_value_t lit_value = ecma_find_or_create_literal_string (char_p,
        -: 1302:                                                                     source_data >> 20,
        3: 1303:                                                                     (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);
        3: 1304:        literal_pool_p[literal_p->prop.index] = lit_value;
        -: 1305:      }
        -: 1306:    }
        -: 1307:  }
        -: 1308:
        2: 1309:  ecma_value_t *base_p = (ecma_value_t *) (((uint8_t *) compiled_code_p) + total_size);
        -: 1310:
        2: 1311:  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -: 1312:  {
    #####: 1313:    parser_list_iterator_t literal_iterator;
    #####: 1314:    uint16_t argument_count = 0;
    #####: 1315:    uint16_t register_count = context_p->register_count;
    #####: 1316:    base_p -= context_p->argument_count;
        -: 1317:
    #####: 1318:    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
    #####: 1319:    while (argument_count < context_p->argument_count)
        -: 1320:    {
        -: 1321:      lexer_literal_t *literal_p;
    #####: 1322:      literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator);
        -: 1323:
    #####: 1324:      JERRY_ASSERT (literal_p != NULL);
        -: 1325:
    #####: 1326:      if (!(literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))
        -: 1327:      {
    #####: 1328:        continue;
        -: 1329:      }
        -: 1330:
        -: 1331:      /* All arguments must be moved to initialized registers. */
    #####: 1332:      if (literal_p->type == LEXER_UNUSED_LITERAL)
        -: 1333:      {
    #####: 1334:        base_p[argument_count] = ECMA_VALUE_EMPTY;
    #####: 1335:        argument_count++;
    #####: 1336:        continue;
        -: 1337:      }
        -: 1338:
    #####: 1339:      JERRY_ASSERT (literal_p->type == LEXER_IDENT_LITERAL);
        -: 1340:
    #####: 1341:      JERRY_ASSERT (literal_p->prop.index >= register_count);
        -: 1342:
    #####: 1343:      base_p[argument_count] = literal_pool_p[literal_p->prop.index];
    #####: 1344:      argument_count++;
        -: 1345:    }
        -: 1346:  }
        -: 1347:
        -: 1348:#if JERRY_ESNEXT
        2: 1349:  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))
        -: 1350:  {
        2: 1351:    *(--base_p) = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1352:  }
        -: 1353:
        2: 1354:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 1355:  {
    #####: 1356:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_TAGGED_LITERALS;
    #####: 1357:    *(--base_p) = (ecma_value_t) context_p->tagged_template_literal_cp;
        -: 1358:  }
        -: 1359:#endif /* JERRY_ESNEXT */
        -: 1360:
        -: 1361:#if JERRY_LINE_INFO
    #####: 1362:  ECMA_SET_INTERNAL_VALUE_POINTER (base_p[-1], line_info_p);
        -: 1363:#endif /* JERRY_LINE_INFO */
        -: 1364:
        -: 1365:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        2: 1366:  if (extended_info != 0)
        -: 1367:  {
        -: 1368:#if JERRY_LINE_INFO
    #####: 1369:    base_p--;
        -: 1370:#endif /* JERRY_LINE_INFO */
        -: 1371:
    #####: 1372:    uint8_t *extended_info_p = ((uint8_t *) base_p) - 1;
        -: 1373:
    #####: 1374:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_EXTENDED_INFO;
    #####: 1375:    *extended_info_p = extended_info;
        -: 1376:
        -: 1377:#if JERRY_ESNEXT
    #####: 1378:    if (context_p->argument_length != UINT16_MAX)
        -: 1379:    {
    #####: 1380:      ecma_extended_info_encode_vlq (&extended_info_p, context_p->argument_length);
        -: 1381:    }
        -: 1382:#endif /* JERRY_ESNEXT */
        -: 1383:
        -: 1384:#if JERRY_FUNCTION_TO_STRING
    #####: 1385:    if (context_p->last_context_p != NULL)
        -: 1386:    {
    #####: 1387:      const uint8_t *start_p = context_p->source_start_p;
        -: 1388:
    #####: 1389:      if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 1390:      {
    #####: 1391:        start_p = context_p->arguments_start_p;
        -: 1392:      }
        -: 1393:
    #####: 1394:      const uint8_t *function_start_p = context_p->last_context_p->function_start_p;
        -: 1395:
    #####: 1396:      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (function_start_p - start_p));
    #####: 1397:      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (context_p->function_end_p - function_start_p));
        -: 1398:    }
        -: 1399:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1400:  }
        -: 1401:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -: 1402:
        -: 1403:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1404:  if (context_p->is_show_opcodes)
        -: 1405:  {
        -: 1406:    util_print_cbc (compiled_code_p);
        -: 1407:    JERRY_DEBUG_MSG ("\nByte code size: %d bytes\n", (int) length);
        -: 1408:    context_p->total_byte_code_size += (uint32_t) length;
        -: 1409:  }
        -: 1410:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1411:
        -: 1412:#if JERRY_DEBUGGER
        -: 1413:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1414:  {
        -: 1415:    jerry_debugger_send_function_cp (JERRY_DEBUGGER_BYTE_CODE_CP, compiled_code_p);
        -: 1416:  }
        -: 1417:#endif /* JERRY_DEBUGGER */
        -: 1418:
        2: 1419:  return compiled_code_p;
        -: 1420:} /* parser_post_processing */
        -: 1421:
        -: 1422:#undef PARSER_NEXT_BYTE
        -: 1423:#undef PARSER_NEXT_BYTE_UPDATE
        -: 1424:
        -: 1425:#if JERRY_ESNEXT
        -: 1426:/**
        -: 1427: * Resolve private identifier in direct eval context
        -: 1428: */
        -: 1429:static bool
    #####: 1430:parser_resolve_private_identifier_eval (parser_context_t *context_p) /**< context */
        -: 1431:{
        -: 1432:  ecma_string_t *search_key_p;
    #####: 1433:  uint8_t *destination_p = (uint8_t *) parser_malloc (context_p, context_p->token.lit_location.length);
        -: 1434:
    #####: 1435:  lexer_convert_ident_to_cesu8 (destination_p,
        -: 1436:                                context_p->token.lit_location.char_p,
    #####: 1437:                                context_p->token.lit_location.length);
        -: 1438:
    #####: 1439:  search_key_p = ecma_new_ecma_string_from_utf8 (destination_p, context_p->token.lit_location.length);
        -: 1440:
    #####: 1441:  parser_free (destination_p, context_p->token.lit_location.length);
        -: 1442:
    #####: 1443:  ecma_object_t *lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -: 1444:
        -: 1445:  while (true)
        -: 1446:  {
    #####: 1447:    JERRY_ASSERT (lex_env_p != NULL);
        -: 1448:
    #####: 1449:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
    #####: 1450:        && (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) != 0
    #####: 1451:        && !ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))
        -: 1452:    {
    #####: 1453:      ecma_object_t *class_object_p = ((ecma_lexical_environment_class_t *) lex_env_p)->object_p;
        -: 1454:
    #####: 1455:      ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
    #####: 1456:      ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -: 1457:
    #####: 1458:      if (prop_p != NULL)
        -: 1459:      {
    #####: 1460:        ecma_value_t *collection_p =
    #####: 1461:          ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 1462:        ecma_value_t *current_p = collection_p + 1;
    #####: 1463:        ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1464:
    #####: 1465:        while (current_p < end_p)
        -: 1466:        {
    #####: 1467:          current_p++; /* skip kind */
    #####: 1468:          ecma_string_t *private_key_p = ecma_get_prop_name_from_value (*current_p++);
    #####: 1469:          current_p++; /* skip value */
        -: 1470:
    #####: 1471:          JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1472:
    #####: 1473:          ecma_string_t *private_key_desc_p =
    #####: 1474:            ecma_get_string_from_value (((ecma_extended_string_t *) private_key_p)->u.symbol_descriptor);
        -: 1475:
    #####: 1476:          if (ecma_compare_ecma_strings (private_key_desc_p, search_key_p))
        -: 1477:          {
    #####: 1478:            ecma_deref_ecma_string (search_key_p);
    #####: 1479:            lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####: 1480:            return true;
        -: 1481:          }
        -: 1482:        }
        -: 1483:      }
        -: 1484:    }
        -: 1485:
    #####: 1486:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -: 1487:    {
    #####: 1488:      break;
        -: 1489:    }
        -: 1490:
    #####: 1491:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1492:  }
        -: 1493:
    #####: 1494:  ecma_deref_ecma_string (search_key_p);
    #####: 1495:  return false;
        -: 1496:} /* parser_resolve_private_identifier_eval */
        -: 1497:
        -: 1498:/**
        -: 1499: * Resolve private identifier
        -: 1500: */
        -: 1501:void
    #####: 1502:parser_resolve_private_identifier (parser_context_t *context_p) /**< context */
        -: 1503:{
    #####: 1504:  if ((context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL) && parser_resolve_private_identifier_eval (context_p))
        -: 1505:  {
    #####: 1506:    return;
        -: 1507:  }
        -: 1508:
    #####: 1509:  parser_private_context_t *context_iter_p = context_p->private_context_p;
        -: 1510:
    #####: 1511:  while (context_iter_p)
        -: 1512:  {
    #####: 1513:    if (context_iter_p == NULL || !(context_iter_p->opts & SCANNER_PRIVATE_FIELD_ACTIVE))
        -: 1514:    {
    #####: 1515:      parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1516:    }
        -: 1517:
    #####: 1518:    if (!(context_iter_p->opts & SCANNER_SUCCESSFUL_CLASS_SCAN))
        -: 1519:    {
    #####: 1520:      return;
        -: 1521:    }
        -: 1522:
    #####: 1523:    parser_private_context_t *private_context_p = context_iter_p;
        -: 1524:
    #####: 1525:    if (private_context_p == NULL)
        -: 1526:    {
    #####: 1527:      parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1528:    }
        -: 1529:
    #####: 1530:    scanner_class_private_member_t *ident_iter = private_context_p->members_p;
        -: 1531:
    #####: 1532:    while (ident_iter)
        -: 1533:    {
    #####: 1534:      if (lexer_compare_identifiers (context_p, &context_p->token.lit_location, &ident_iter->loc))
        -: 1535:      {
    #####: 1536:        lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####: 1537:        return;
        -: 1538:      }
        -: 1539:
    #####: 1540:      ident_iter = ident_iter->prev_p;
        -: 1541:    }
        -: 1542:
    #####: 1543:    context_iter_p = context_iter_p->prev_p;
        -: 1544:  }
        -: 1545:
    #####: 1546:  parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1547:} /* parser_resolve_private_identifier */
        -: 1548:
        -: 1549:/**
        -: 1550: * Save private field context
        -: 1551: */
        -: 1552:void
    #####: 1553:parser_save_private_context (parser_context_t *context_p, /**< context */
        -: 1554:                             parser_private_context_t *private_ctx_p, /**< private context */
        -: 1555:                             scanner_class_info_t *class_info_p) /**< class scanner info */
        -: 1556:{
    #####: 1557:  private_ctx_p->prev_p = context_p->private_context_p;
    #####: 1558:  context_p->private_context_p = private_ctx_p;
        -: 1559:
    #####: 1560:  context_p->private_context_p->members_p = class_info_p->members;
    #####: 1561:  context_p->private_context_p->opts = class_info_p->info.u8_arg;
    #####: 1562:  class_info_p->members = NULL;
    #####: 1563:} /* parser_save_private_context */
        -: 1564:
        -: 1565:/**
        -: 1566: * Release contexts private fields
        -: 1567: */
        -: 1568:static void
    #####: 1569:parser_free_private_fields (parser_context_t *context_p) /**< context */
        -: 1570:{
    #####: 1571:  parser_private_context_t *iter = context_p->private_context_p;
        -: 1572:
    #####: 1573:  while (iter != NULL)
        -: 1574:  {
    #####: 1575:    parser_private_context_t *prev_p = iter->prev_p;
    #####: 1576:    scanner_release_private_fields (iter->members_p);
    #####: 1577:    iter = prev_p;
        -: 1578:  }
    #####: 1579:} /* parser_free_private_fields */
        -: 1580:
        -: 1581:/**
        -: 1582: * Restore contexts private fields
        -: 1583: */
        -: 1584:void
    #####: 1585:parser_restore_private_context (parser_context_t *context_p, /**< context */
        -: 1586:                                parser_private_context_t *private_ctx_p) /**< private context */
        -: 1587:{
    #####: 1588:  scanner_release_private_fields (context_p->private_context_p->members_p);
    #####: 1589:  context_p->private_context_p = private_ctx_p->prev_p;
    #####: 1590:} /* parser_restore_private_context */
        -: 1591:#endif /* JERRY_ESNEXT */
        -: 1592:
        -: 1593:/**
        -: 1594: * Free identifiers and literals.
        -: 1595: */
        -: 1596:static void
    #####: 1597:parser_free_literals (parser_list_t *literal_pool_p) /**< literals */
        -: 1598:{
    #####: 1599:  parser_list_iterator_t literal_iterator;
        -: 1600:  lexer_literal_t *literal_p;
        -: 1601:
    #####: 1602:  parser_list_iterator_init (literal_pool_p, &literal_iterator);
    #####: 1603:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1604:  {
    #####: 1605:    util_free_literal (literal_p);
        -: 1606:  }
        -: 1607:
    #####: 1608:  parser_list_free (literal_pool_p);
    #####: 1609:} /* parser_free_literals */
        -: 1610:
        -: 1611:/**
        -: 1612: * Parse function arguments
        -: 1613: */
        -: 1614:static void
        1: 1615:parser_parse_function_arguments (parser_context_t *context_p, /**< context */
        -: 1616:                                 lexer_token_type_t end_type) /**< expected end type */
        -: 1617:{
        1: 1618:  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 1619:
        -: 1620:#if JERRY_ESNEXT
        1: 1621:  JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);
        1: 1622:  JERRY_ASSERT (!(context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED));
        -: 1623:
        1: 1624:  bool has_duplicated_arg_names = false;
        -: 1625:
        1: 1626:  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -: 1627:  {
    #####: 1628:    parser_branch_t branch;
    #####: 1629:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_TRY_CREATE_CONTEXT, &branch);
    #####: 1630:    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 1631:
        -: 1632:#ifndef JERRY_NDEBUG
    #####: 1633:    context_p->context_stack_depth = PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 1634:#endif /* !JERRY_NDEBUG */
        -: 1635:  }
        -: 1636:#endif /* JERRY_ESNEXT */
        -: 1637:
        1: 1638:  if (context_p->token.type == end_type)
        -: 1639:  {
        -: 1640:#if JERRY_ESNEXT
        1: 1641:    context_p->status_flags &= (uint32_t) ~PARSER_DISALLOW_AWAIT_YIELD;
        -: 1642:
        1: 1643:    if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1644:    {
    #####: 1645:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);
    #####: 1646:      parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);
    #####: 1647:      parser_emit_cbc (context_p, CBC_POP);
    #####: 1648:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);
    #####: 1649:      return;
        -: 1650:    }
        -: 1651:#endif /* JERRY_ESNEXT */
        1: 1652:    scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        1: 1653:    return;
        -: 1654:  }
        -: 1655:
        -: 1656:#if JERRY_ESNEXT
    #####: 1657:  bool has_complex_argument = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT) != 0;
        -: 1658:#endif /* JERRY_ESNEXT */
    #####: 1659:  bool is_strict = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT) != 0;
        -: 1660:
    #####: 1661:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);
    #####: 1662:  scanner_set_active (context_p);
        -: 1663:
        -: 1664:#if JERRY_ESNEXT
    #####: 1665:  context_p->status_flags |= PARSER_FUNCTION_IS_PARSING_ARGS;
        -: 1666:#endif /* JERRY_ESNEXT */
        -: 1667:
        -: 1668:  while (true)
    #####: 1669:  {
        -: 1670:#if JERRY_ESNEXT
    #####: 1671:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 1672:    {
    #####: 1673:      if (context_p->status_flags & PARSER_IS_PROPERTY_SETTER)
        -: 1674:      {
    #####: 1675:        parser_raise_error (context_p, PARSER_ERR_SETTER_REST_PARAMETER);
        -: 1676:      }
    #####: 1677:      lexer_next_token (context_p);
        -: 1678:
    #####: 1679:      if (has_duplicated_arg_names)
        -: 1680:      {
    #####: 1681:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1682:      }
        -: 1683:
    #####: 1684:      context_p->status_flags |= PARSER_FUNCTION_HAS_REST_PARAM | PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1685:    }
        -: 1686:
    #####: 1687:    if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 1688:    {
    #####: 1689:      if (has_duplicated_arg_names)
        -: 1690:      {
    #####: 1691:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1692:      }
        -: 1693:
    #####: 1694:      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1695:
    #####: 1696:      if (!(context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM))
        -: 1697:      {
    #####: 1698:        parser_emit_cbc_literal (context_p,
        -: 1699:                                 CBC_PUSH_LITERAL,
    #####: 1700:                                 (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));
        -: 1701:      }
        -: 1702:      else
        -: 1703:      {
    #####: 1704:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);
        -: 1705:      }
        -: 1706:
    #####: 1707:      uint32_t flags =
        -: 1708:        (PARSER_PATTERN_BINDING | PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_LOCAL | PARSER_PATTERN_ARGUMENTS);
        -: 1709:
    #####: 1710:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1711:      {
    #####: 1712:        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 1713:        {
    #####: 1714:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1715:          {
    #####: 1716:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1717:          }
        -: 1718:
    #####: 1719:          if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1720:          {
    #####: 1721:            parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);
        -: 1722:          }
        -: 1723:
    #####: 1724:          if (context_p->argument_length == UINT16_MAX)
        -: 1725:          {
    #####: 1726:            context_p->argument_length = context_p->argument_count;
        -: 1727:          }
        -: 1728:
    #####: 1729:          flags |= PARSER_PATTERN_TARGET_DEFAULT;
        -: 1730:        }
    #####: 1731:        else if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS)
        -: 1732:        {
    #####: 1733:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1734:          {
    #####: 1735:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1736:          }
    #####: 1737:          scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1738:        }
        -: 1739:        else
        -: 1740:        {
    #####: 1741:          parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 1742:        }
        -: 1743:      }
        -: 1744:
    #####: 1745:      parser_parse_initializer (context_p, flags);
        -: 1746:
    #####: 1747:      context_p->argument_count++;
    #####: 1748:      if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1749:      {
    #####: 1750:        parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1751:      }
        -: 1752:
    #####: 1753:      if (context_p->token.type != LEXER_COMMA)
        -: 1754:      {
    #####: 1755:        if (context_p->token.type != end_type)
        -: 1756:        {
    #####: 1757:          parser_error_msg_t error =
    #####: 1758:            ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED : PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1759:
    #####: 1760:          parser_raise_error (context_p, error);
        -: 1761:        }
    #####: 1762:        break;
        -: 1763:      }
        -: 1764:
    #####: 1765:      lexer_next_token (context_p);
        -: 1766:
    #####: 1767:      if (context_p->token.type == end_type)
        -: 1768:      {
    #####: 1769:        break;
        -: 1770:      }
    #####: 1771:      continue;
        -: 1772:    }
        -: 1773:#endif /* JERRY_ESNEXT */
        -: 1774:
    #####: 1775:    if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1776:    {
    #####: 1777:      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1778:    }
        -: 1779:
    #####: 1780:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 1781:
    #####: 1782:    if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -: 1783:    {
    #####: 1784:      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1785:    }
        -: 1786:
    #####: 1787:    if (JERRY_UNLIKELY (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))
        -: 1788:    {
        -: 1789:#if JERRY_ESNEXT
    #####: 1790:      if ((context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT)
    #####: 1791:          || (context_p->status_flags & PARSER_IS_ARROW_FUNCTION))
        -: 1792:      {
    #####: 1793:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1794:      }
    #####: 1795:      has_duplicated_arg_names = true;
        -: 1796:#endif /* JERRY_ESNEXT */
        -: 1797:
    #####: 1798:      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1799:    }
        -: 1800:    else
        -: 1801:    {
    #####: 1802:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 1803:    }
        -: 1804:
    #####: 1805:    lexer_next_token (context_p);
        -: 1806:
        -: 1807:#if JERRY_ESNEXT
    #####: 1808:    uint16_t literal_index = context_p->lit_object.index;
        -: 1809:
    #####: 1810:    if (context_p->token.type == LEXER_ASSIGN)
        -: 1811:    {
    #####: 1812:      JERRY_ASSERT (has_complex_argument);
        -: 1813:
    #####: 1814:      if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1815:      {
    #####: 1816:        parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);
        -: 1817:      }
        -: 1818:
    #####: 1819:      if (context_p->argument_length == UINT16_MAX)
        -: 1820:      {
    #####: 1821:        context_p->argument_length = context_p->argument_count;
        -: 1822:      }
        -: 1823:
    #####: 1824:      parser_branch_t skip_init;
        -: 1825:
    #####: 1826:      if (has_duplicated_arg_names)
        -: 1827:      {
    #####: 1828:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1829:      }
        -: 1830:
    #####: 1831:      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1832:
        -: 1833:      /* LEXER_ASSIGN does not overwrite lit_object. */
    #####: 1834:      parser_emit_cbc_literal (context_p,
        -: 1835:                               CBC_PUSH_LITERAL,
    #####: 1836:                               (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));
    #####: 1837:      parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 1838:
    #####: 1839:      lexer_next_token (context_p);
    #####: 1840:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1841:
    #####: 1842:      parser_set_branch_to_current_position (context_p, &skip_init);
        -: 1843:
    #####: 1844:      uint16_t opcode = CBC_ASSIGN_LET_CONST;
        -: 1845:
    #####: 1846:      if (literal_index >= PARSER_REGISTER_START)
        -: 1847:      {
    #####: 1848:        opcode = CBC_MOV_IDENT;
        -: 1849:      }
    #####: 1850:      else if (!scanner_literal_is_created (context_p, literal_index))
        -: 1851:      {
    #####: 1852:        opcode = CBC_INIT_ARG_OR_CATCH;
        -: 1853:      }
        -: 1854:
    #####: 1855:      parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1856:    }
    #####: 1857:    else if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1858:    {
    #####: 1859:      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);
        -: 1860:
    #####: 1861:      uint16_t opcode = CBC_MOV_IDENT;
        -: 1862:
    #####: 1863:      if (literal_index < PARSER_REGISTER_START)
        -: 1864:      {
    #####: 1865:        opcode = CBC_INIT_ARG_OR_CATCH;
        -: 1866:
    #####: 1867:        if (scanner_literal_is_created (context_p, literal_index))
        -: 1868:        {
    #####: 1869:          opcode = CBC_ASSIGN_LET_CONST;
        -: 1870:        }
        -: 1871:      }
        -: 1872:
    #####: 1873:      parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1874:    }
    #####: 1875:    else if (has_complex_argument && literal_index < PARSER_REGISTER_START)
        -: 1876:    {
    #####: 1877:      uint16_t opcode = CBC_INIT_ARG_OR_FUNC;
        -: 1878:
    #####: 1879:      if (scanner_literal_is_created (context_p, literal_index))
        -: 1880:      {
    #####: 1881:        opcode = CBC_ASSIGN_LET_CONST_LITERAL;
        -: 1882:      }
        -: 1883:
    #####: 1884:      parser_emit_cbc_literal_value (context_p,
        -: 1885:                                     opcode,
    #####: 1886:                                     (uint16_t) (PARSER_REGISTER_START + context_p->argument_count),
        -: 1887:                                     literal_index);
        -: 1888:    }
        -: 1889:#endif /* JERRY_ESNEXT */
        -: 1890:
    #####: 1891:    context_p->argument_count++;
    #####: 1892:    if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1893:    {
    #####: 1894:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1895:    }
        -: 1896:
    #####: 1897:    if (context_p->token.type != LEXER_COMMA)
        -: 1898:    {
    #####: 1899:      if (context_p->token.type != end_type)
        -: 1900:      {
    #####: 1901:        parser_error_msg_t error =
    #####: 1902:          ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED : PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1903:
    #####: 1904:        parser_raise_error (context_p, error);
        -: 1905:      }
    #####: 1906:      break;
        -: 1907:    }
        -: 1908:
        -: 1909:#if JERRY_ESNEXT
    #####: 1910:    if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1911:    {
    #####: 1912:      parser_raise_error (context_p, PARSER_ERR_FORMAL_PARAM_AFTER_REST_PARAMETER);
        -: 1913:    }
        -: 1914:#endif /* JERRY_ESNEXT */
        -: 1915:
    #####: 1916:    lexer_next_token (context_p);
        -: 1917:
        -: 1918:#if JERRY_ESNEXT
    #####: 1919:    if (context_p->token.type == end_type)
        -: 1920:    {
    #####: 1921:      break;
        -: 1922:    }
        -: 1923:#endif /* JERRY_ESNEXT */
        -: 1924:  }
        -: 1925:
    #####: 1926:  scanner_revert_active (context_p);
        -: 1927:
        -: 1928:#if JERRY_ESNEXT
    #####: 1929:  JERRY_ASSERT (has_complex_argument || !(context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT));
        -: 1930:
    #####: 1931:  if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1932:  {
    #####: 1933:    parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);
    #####: 1934:    parser_emit_cbc (context_p, CBC_POP);
        -: 1935:  }
        -: 1936:
    #####: 1937:  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
        -: 1938:  {
    #####: 1939:    if ((context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_LEXICAL_ENV_NEEDED)
    #####: 1940:        || scanner_is_context_needed (context_p, PARSER_CHECK_FUNCTION_CONTEXT))
    #####: 1941:    {
    #####: 1942:      context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 1943:
    #####: 1944:      parser_branch_t branch;
    #####: 1945:      parser_emit_cbc_forward_branch (context_p, CBC_BLOCK_CREATE_CONTEXT, &branch);
    #####: 1946:      parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 1947:
        -: 1948:#ifndef JERRY_NDEBUG
    #####: 1949:      PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -: 1950:#endif /* !JERRY_NDEBUG */
        -: 1951:    }
        -: 1952:    else
        -: 1953:    {
    #####: 1954:      context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;
        -: 1955:    }
        -: 1956:  }
        -: 1957:
    #####: 1958:  context_p->status_flags &= (uint32_t) ~(PARSER_DISALLOW_AWAIT_YIELD | PARSER_FUNCTION_IS_PARSING_ARGS);
        -: 1959:#endif /* JERRY_ESNEXT */
        -: 1960:
    #####: 1961:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);
        -: 1962:
    #####: 1963:  if (is_strict)
        -: 1964:  {
    #####: 1965:    context_p->status_flags |= PARSER_IS_STRICT;
        -: 1966:  }
        -: 1967:} /* parser_parse_function_arguments */
        -: 1968:
        -: 1969:#ifndef JERRY_NDEBUG
        -: 1970:JERRY_STATIC_ASSERT (PARSER_SCANNING_SUCCESSFUL == PARSER_HAS_LATE_LIT_INIT,
        -: 1971:                     parser_scanning_successful_should_share_the_bit_position_with_parser_has_late_lit_init);
        -: 1972:#endif /* !JERRY_NDEBUG */
        -: 1973:
        -: 1974:/**
        -: 1975: * Parser script size
        -: 1976: */
        -: 1977:static size_t
        1: 1978:parser_script_size (parser_context_t *context_p) /**< context */
        -: 1979:{
        1: 1980:  size_t script_size = sizeof (cbc_script_t);
        -: 1981:
        1: 1982:  if (context_p->user_value != ECMA_VALUE_EMPTY)
        -: 1983:  {
    #####: 1984:    script_size += sizeof (ecma_value_t);
        -: 1985:  }
        -: 1986:
        -: 1987:#if JERRY_FUNCTION_TO_STRING
    #####: 1988:  if (context_p->argument_list != ECMA_VALUE_EMPTY)
        -: 1989:  {
    #####: 1990:    script_size += sizeof (ecma_value_t);
        -: 1991:  }
        -: 1992:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1993:
        -: 1994:#if JERRY_MODULE_SYSTEM
        1: 1995:  if (context_p->global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)
        -: 1996:  {
    #####: 1997:    script_size += sizeof (ecma_value_t);
        -: 1998:  }
        -: 1999:#endif /* JERRY_MODULE_SYSTEM */
        1: 2000:  return script_size;
        -: 2001:} /* parser_script_size */
        -: 2002:
        -: 2003:#if JERRY_SOURCE_NAME
        -: 2004:/**
        -: 2005: * Parser resource name
        -: 2006: */
        -: 2007:static ecma_value_t
        1: 2008:parser_source_name (parser_context_t *context_p) /**< context */
        -: 2009:{
        1: 2010:  if (context_p->options_p != NULL && (context_p->options_p->options & JERRY_PARSE_HAS_SOURCE_NAME))
        -: 2011:  {
        1: 2012:    JERRY_ASSERT (ecma_is_value_string (context_p->options_p->source_name));
        -: 2013:
        1: 2014:    ecma_ref_ecma_string (ecma_get_string_from_value (context_p->options_p->source_name));
        1: 2015:    return context_p->options_p->source_name;
        -: 2016:  }
        -: 2017:
    #####: 2018:  if (context_p->global_status_flags & ECMA_PARSE_EVAL)
        -: 2019:  {
    #####: 2020:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_EVAL);
        -: 2021:  }
        -: 2022:
    #####: 2023:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 2024:} /* parser_source_name */
        -: 2025:#endif /* JERRY_SOURCE_NAME */
        -: 2026:
        -: 2027:/**
        -: 2028: * Parse and compile EcmaScript source code
        -: 2029: *
        -: 2030: * Note: source must be a valid UTF-8 string
        -: 2031: *
        -: 2032: * @return compiled code
        -: 2033: */
        -: 2034:static ecma_compiled_code_t *
        1: 2035:parser_parse_source (void *source_p, /**< source code */
        -: 2036:                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */
        -: 2037:                     const jerry_parse_options_t *options_p) /**< additional configuration options */
        -: 2038:{
        1: 2039:  parser_context_t context;
        -: 2040:  ecma_compiled_code_t *compiled_code_p;
        -: 2041:
        1: 2042:  context.error = PARSER_ERR_NO_ERROR;
        1: 2043:  context.status_flags = parse_opts & PARSER_STRICT_MODE_MASK;
        1: 2044:  context.global_status_flags = parse_opts;
        -: 2045:
        -: 2046:#if JERRY_ESNEXT
        1: 2047:  context.status_flags |= PARSER_RESTORE_STATUS_FLAGS (parse_opts);
        1: 2048:  context.tagged_template_literal_cp = JMEM_CP_NULL;
        -: 2049:#endif /* JERRY_ESNEXT */
        -: 2050:
        1: 2051:  context.stack_depth = 0;
        1: 2052:  context.stack_limit = 0;
        1: 2053:  context.options_p = options_p;
        1: 2054:  context.script_p = NULL;
        1: 2055:  context.arguments_start_p = NULL;
        1: 2056:  context.arguments_size = 0;
        -: 2057:#if JERRY_MODULE_SYSTEM
        1: 2058:  if (context.global_status_flags & ECMA_PARSE_MODULE)
        -: 2059:  {
    #####: 2060:    context.status_flags |= PARSER_IS_STRICT;
        -: 2061:  }
        -: 2062:
        1: 2063:  context.module_names_p = NULL;
        -: 2064:#endif /* JERRY_MODULE_SYSTEM */
        -: 2065:
        1: 2066:  context.argument_list = ECMA_VALUE_EMPTY;
        -: 2067:
        1: 2068:  if (context.options_p != NULL && (context.options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST))
        -: 2069:  {
    #####: 2070:    context.argument_list = context.options_p->argument_list;
        -: 2071:  }
        1: 2072:  else if (context.global_status_flags & ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE)
        -: 2073:  {
    #####: 2074:    JERRY_ASSERT (context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE);
    #####: 2075:    context.argument_list = ((ecma_value_t *) source_p)[1];
        -: 2076:  }
        -: 2077:
        1: 2078:  if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2079:  {
    #####: 2080:    JERRY_ASSERT (ecma_is_value_string (context.argument_list));
        -: 2081:
    #####: 2082:    context.status_flags |= PARSER_IS_FUNCTION;
        -: 2083:#if JERRY_ESNEXT
    #####: 2084:    if (parse_opts & ECMA_PARSE_GENERATOR_FUNCTION)
        -: 2085:    {
    #####: 2086:      context.status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 2087:    }
    #####: 2088:    if (parse_opts & ECMA_PARSE_ASYNC_FUNCTION)
        -: 2089:    {
    #####: 2090:      context.status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -: 2091:    }
        -: 2092:#endif /* JERRY_ESNEXT */
        -: 2093:
    #####: 2094:    ecma_string_t *string_p = ecma_get_string_from_value (context.argument_list);
    #####: 2095:    uint8_t flags = ECMA_STRING_FLAG_EMPTY;
        -: 2096:
    #####: 2097:    context.arguments_start_p = ecma_string_get_chars (string_p, &context.arguments_size, NULL, NULL, &flags);
        -: 2098:
    #####: 2099:    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2100:    {
    #####: 2101:      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_ARG_LIST;
        -: 2102:    }
        -: 2103:  }
        -: 2104:
        1: 2105:  if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))
        -: 2106:  {
        1: 2107:    context.source_start_p = ((parser_source_char_t *) source_p)->source_p;
        1: 2108:    context.source_size = (lit_utf8_size_t) ((parser_source_char_t *) source_p)->source_size;
        -: 2109:  }
        -: 2110:  else
        -: 2111:  {
    #####: 2112:    ecma_value_t source = ((ecma_value_t *) source_p)[0];
        -: 2113:
    #####: 2114:    JERRY_ASSERT (ecma_is_value_string (source));
        -: 2115:
    #####: 2116:    ecma_string_t *string_p = ecma_get_string_from_value (source);
    #####: 2117:    uint8_t flags = ECMA_STRING_FLAG_EMPTY;
        -: 2118:
    #####: 2119:    context.source_start_p = ecma_string_get_chars (string_p, &context.source_size, NULL, NULL, &flags);
        -: 2120:
    #####: 2121:    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2122:    {
    #####: 2123:      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_SOURCE;
        -: 2124:    }
        -: 2125:  }
        -: 2126:
        -: 2127:#if JERRY_DEBUGGER
        -: 2128:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2129:  {
        -: 2130:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE,
        -: 2131:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -: 2132:                                context.source_start_p,
        -: 2133:                                context.source_size);
        -: 2134:  }
        -: 2135:#endif /* JERRY_DEBUGGER */
        -: 2136:
        1: 2137:  context.user_value = ECMA_VALUE_EMPTY;
        -: 2138:
        1: 2139:  if ((context.global_status_flags & ECMA_PARSE_EVAL) && JERRY_CONTEXT (vm_top_context_p) != NULL)
    #####: 2140:  {
    #####: 2141:    const ecma_compiled_code_t *bytecode_header_p = JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p;
        -: 2142:
        -: 2143:#if JERRY_SNAPSHOT_EXEC
    #####: 2144:    if (JERRY_LIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 2145:    {
        -: 2146:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 2147:      ecma_value_t parent_script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 2148:      ;
    #####: 2149:      cbc_script_t *parent_script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, parent_script_value);
        -: 2150:
    #####: 2151:      if (parent_script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 2152:      {
    #####: 2153:        context.user_value = CBC_SCRIPT_GET_USER_VALUE (parent_script_p);
        -: 2154:      }
        -: 2155:#if JERRY_SNAPSHOT_EXEC
        -: 2156:    }
        -: 2157:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 2158:  }
        1: 2159:  else if (context.options_p != NULL && (context.options_p->options & JERRY_PARSE_HAS_USER_VALUE))
        -: 2160:  {
    #####: 2161:    context.user_value = context.options_p->user_value;
        -: 2162:  }
        -: 2163:
        1: 2164:  context.last_context_p = NULL;
        1: 2165:  context.last_statement.current_p = NULL;
        1: 2166:  context.token.flags = 0;
        1: 2167:  lexer_init_line_info (&context);
        -: 2168:
        1: 2169:  scanner_info_t scanner_info_end;
        1: 2170:  scanner_info_end.next_p = NULL;
        1: 2171:  scanner_info_end.source_p = NULL;
        1: 2172:  scanner_info_end.type = SCANNER_TYPE_END;
        1: 2173:  context.next_scanner_info_p = &scanner_info_end;
        1: 2174:  context.active_scanner_info_p = NULL;
        1: 2175:  context.skipped_scanner_info_p = NULL;
        1: 2176:  context.skipped_scanner_info_end_p = NULL;
        -: 2177:
        1: 2178:  context.last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2179:
        1: 2180:  context.argument_count = 0;
        -: 2181:#if JERRY_ESNEXT
        1: 2182:  context.argument_length = UINT16_MAX;
        -: 2183:#endif /* JERRY_ESNEXT */
        1: 2184:  context.register_count = 0;
        1: 2185:  context.literal_count = 0;
        -: 2186:
        1: 2187:  parser_cbc_stream_init (&context.byte_code);
        1: 2188:  context.byte_code_size = 0;
        1: 2189:  parser_list_init (&context.literal_pool,
        -: 2190:                    sizeof (lexer_literal_t),
        -: 2191:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_literal_t)));
        1: 2192:  context.scope_stack_p = NULL;
        1: 2193:  context.scope_stack_size = 0;
        1: 2194:  context.scope_stack_top = 0;
        1: 2195:  context.scope_stack_reg_top = 0;
        -: 2196:#if JERRY_ESNEXT
        1: 2197:  context.scope_stack_global_end = 0;
        1: 2198:  context.tagged_template_literal_cp = JMEM_CP_NULL;
        1: 2199:  context.private_context_p = NULL;
        -: 2200:#endif /* JERRY_ESNEXT */
        -: 2201:
        -: 2202:#ifndef JERRY_NDEBUG
        1: 2203:  context.context_stack_depth = 0;
        -: 2204:#endif /* !JERRY_NDEBUG */
        -: 2205:
        -: 2206:#if JERRY_LINE_INFO
    #####: 2207:  context.line_info_p = NULL;
        -: 2208:#endif /* JERRY_LINE_INFO */
        -: 2209:
        -: 2210:#if JERRY_FUNCTION_TO_STRING
    #####: 2211:  context.function_start_p = NULL;
    #####: 2212:  context.function_end_p = NULL;
        -: 2213:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2214:
        -: 2215:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2216:  context.is_show_opcodes = (JERRY_CONTEXT (jerry_init_flags) & JERRY_INIT_SHOW_OPCODES);
        -: 2217:  context.total_byte_code_size = 0;
        -: 2218:
        -: 2219:  if (context.is_show_opcodes)
        -: 2220:  {
        -: 2221:    JERRY_DEBUG_MSG ("\n--- %s parsing start ---\n\n", (context.arguments_start_p == NULL) ? "Script" : "Function");
        -: 2222:  }
        -: 2223:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2224:
        1: 2225:  scanner_scan_all (&context);
        -: 2226:
        1: 2227:  if (JERRY_UNLIKELY (context.error != PARSER_ERR_NO_ERROR))
        -: 2228:  {
    #####: 2229:    JERRY_ASSERT (context.error == PARSER_ERR_OUT_OF_MEMORY);
        -: 2230:
        -: 2231:    /* It is unlikely that memory can be allocated in an out-of-memory
        -: 2232:     * situation. However, a simple value can still be thrown. */
    #####: 2233:    jcontext_raise_exception (ECMA_VALUE_NULL);
    #####: 2234:    return NULL;
        -: 2235:  }
        -: 2236:
        1: 2237:  if (context.arguments_start_p == NULL)
        -: 2238:  {
        1: 2239:    context.source_p = context.source_start_p;
        1: 2240:    context.source_end_p = context.source_start_p + context.source_size;
        -: 2241:  }
        -: 2242:  else
        -: 2243:  {
    #####: 2244:    context.source_p = context.arguments_start_p;
    #####: 2245:    context.source_end_p = context.arguments_start_p + context.arguments_size;
        -: 2246:  }
        -: 2247:
        1: 2248:  context.u.allocated_buffer_p = NULL;
        1: 2249:  context.token.flags = 0;
        1: 2250:  lexer_init_line_info (&context);
        -: 2251:
        1: 2252:  parser_stack_init (&context);
        -: 2253:
        -: 2254:#if JERRY_DEBUGGER
        -: 2255:  context.breakpoint_info_count = 0;
        -: 2256:#endif /* JERRY_DEBUGGER */
        -: 2257:
        1: 2258:  JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_p);
        1: 2259:  JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2260:
        1: 2261:  if (context.next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT)
        -: 2262:  {
    #####: 2263:    context.status_flags |= PARSER_IS_STRICT;
        -: 2264:  }
        -: 2265:
        1: 2266:  PARSER_TRY (context.try_buffer)
        -: 2267:  {
        1: 2268:    context.script_p = parser_malloc (&context, parser_script_size (&context));
        -: 2269:
        1: 2270:    CBC_SCRIPT_SET_TYPE (context.script_p, context.user_value, CBC_SCRIPT_REF_ONE);
        -: 2271:
        1: 2272:    if (context.global_status_flags & (ECMA_PARSE_EVAL | ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE))
        -: 2273:    {
    #####: 2274:      context.script_p->refs_and_type |= CBC_SCRIPT_IS_EVAL_CODE;
        -: 2275:    }
        -: 2276:
        -: 2277:#if JERRY_BUILTIN_REALMS
        1: 2278:    context.script_p->realm_p = (ecma_object_t *) JERRY_CONTEXT (global_object_p);
        -: 2279:#endif /* JERRY_BUILTIN_REALMS */
        -: 2280:
        -: 2281:#if JERRY_SOURCE_NAME
        1: 2282:    context.script_p->source_name = parser_source_name (&context);
        -: 2283:#endif /* JERRY_SOURCE_NAME */
        -: 2284:
        1: 2285:    ECMA_SET_INTERNAL_VALUE_POINTER (context.script_value, context.script_p);
        -: 2286:
        -: 2287:    /* Pushing a dummy value ensures the stack is never empty.
        -: 2288:     * This simplifies the stack management routines. */
        1: 2289:    parser_stack_push_uint8 (&context, CBC_MAXIMUM_BYTE_VALUE);
        -: 2290:    /* The next token must always be present to make decisions
        -: 2291:     * in the parser. Therefore when a token is consumed, the
        -: 2292:     * lexer_next_token() must be immediately called. */
        1: 2293:    lexer_next_token (&context);
        -: 2294:
        1: 2295:    if (context.arguments_start_p != NULL)
        -: 2296:    {
    #####: 2297:      parser_parse_function_arguments (&context, LEXER_EOS);
        -: 2298:
    #####: 2299:      JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);
    #####: 2300:      scanner_release_next (&context, sizeof (scanner_info_t));
        -: 2301:
    #####: 2302:      context.source_p = context.source_start_p;
    #####: 2303:      context.source_end_p = context.source_start_p + context.source_size;
    #####: 2304:      lexer_init_line_info (&context);
        -: 2305:
    #####: 2306:      lexer_next_token (&context);
        -: 2307:    }
        -: 2308:#if JERRY_MODULE_SYSTEM
        1: 2309:    else if (parse_opts & ECMA_PARSE_MODULE)
        -: 2310:    {
    #####: 2311:      parser_branch_t branch;
    #####: 2312:      parser_emit_cbc_forward_branch (&context, CBC_JUMP_FORWARD, &branch);
        -: 2313:
    #####: 2314:      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_MODULE);
    #####: 2315:      parser_emit_cbc (&context, CBC_RETURN_FUNCTION_END);
        -: 2316:
    #####: 2317:      parser_set_branch_to_current_position (&context, &branch);
        -: 2318:    }
        -: 2319:#endif /* JERRY_MODULE_SYSTEM */
        -: 2320:    else
        -: 2321:    {
        1: 2322:      JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_start_p
        -: 2323:                    && context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2324:
        -: 2325:#if JERRY_ESNEXT
        1: 2326:      if (scanner_is_context_needed (&context, PARSER_CHECK_GLOBAL_CONTEXT))
        -: 2327:      {
    #####: 2328:        context.status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2329:      }
        -: 2330:
        1: 2331:      if (!(parse_opts & ECMA_PARSE_EVAL))
        -: 2332:      {
        1: 2333:        scanner_check_variables (&context);
        -: 2334:      }
        -: 2335:#endif /* JERRY_ESNEXT */
        -: 2336:
        1: 2337:      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_SCRIPT);
        -: 2338:    }
        -: 2339:
        1: 2340:    parser_parse_statements (&context);
        -: 2341:
        1: 2342:    JERRY_ASSERT (context.last_statement.current_p == NULL);
        -: 2343:
        1: 2344:    JERRY_ASSERT (context.last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        1: 2345:    JERRY_ASSERT (context.u.allocated_buffer_p == NULL);
        -: 2346:
        -: 2347:#ifndef JERRY_NDEBUG
        1: 2348:    JERRY_ASSERT (context.status_flags & PARSER_SCANNING_SUCCESSFUL);
        1: 2349:    JERRY_ASSERT (!(context.global_status_flags & ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR));
        1: 2350:    context.status_flags &= (uint32_t) ~PARSER_SCANNING_SUCCESSFUL;
        -: 2351:#endif /* !JERRY_NDEBUG */
        -: 2352:
        1: 2353:    JERRY_ASSERT (!(context.status_flags & PARSER_HAS_LATE_LIT_INIT));
        -: 2354:
        1: 2355:    compiled_code_p = parser_post_processing (&context);
        1: 2356:    parser_list_free (&context.literal_pool);
        -: 2357:
        -: 2358:    /* When parsing is successful, only the dummy value can be remained on the stack. */
        1: 2359:    JERRY_ASSERT (context.stack_top_uint8 == CBC_MAXIMUM_BYTE_VALUE && context.stack.last_position == 1
        -: 2360:                  && context.stack.first_p != NULL && context.stack.first_p->next_p == NULL
        -: 2361:                  && context.stack.last_p == NULL);
        -: 2362:
        1: 2363:    JERRY_ASSERT (context.arguments_start_p != NULL || !(context.status_flags & PARSER_ARGUMENTS_NEEDED));
        -: 2364:
        1: 2365:    context.script_p->refs_and_type -= CBC_SCRIPT_REF_ONE;
        -: 2366:
        1: 2367:    if (context.user_value != ECMA_VALUE_EMPTY)
        -: 2368:    {
    #####: 2369:      CBC_SCRIPT_GET_USER_VALUE (context.script_p) = ecma_copy_value_if_not_object (context.user_value);
        -: 2370:    }
        -: 2371:
        -: 2372:#if JERRY_MODULE_SYSTEM
        1: 2373:    if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)
        -: 2374:    {
    #####: 2375:      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;
    #####: 2376:      ecma_value_t module = ecma_make_object_value ((ecma_object_t *) JERRY_CONTEXT (module_current_p));
        -: 2377:
    #####: 2378:      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = module;
    #####: 2379:      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_IMPORT_META;
        -: 2380:    }
        -: 2381:#endif /* JERRY_MODULE_SYSTEM */
        -: 2382:
        -: 2383:#if JERRY_FUNCTION_TO_STRING
    #####: 2384:    if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))
        -: 2385:    {
        -: 2386:      ecma_string_t *string_p;
        -: 2387:
    #####: 2388:      if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_4_BYTE_MARKER)
        -: 2389:      {
    #####: 2390:        string_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 (context.source_start_p, context.source_size);
        -: 2391:      }
        -: 2392:      else
        -: 2393:      {
    #####: 2394:        string_p = ecma_new_ecma_string_from_utf8 (context.source_start_p, context.source_size);
        -: 2395:      }
        -: 2396:
    #####: 2397:      context.script_p->source_code = ecma_make_string_value (string_p);
        -: 2398:    }
        -: 2399:    else
        -: 2400:    {
    #####: 2401:      ecma_value_t source = ((ecma_value_t *) source_p)[0];
        -: 2402:
    #####: 2403:      ecma_ref_ecma_string (ecma_get_string_from_value (source));
    #####: 2404:      context.script_p->source_code = source;
        -: 2405:    }
        -: 2406:
    #####: 2407:    if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2408:    {
    #####: 2409:      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;
        -: 2410:
    #####: 2411:      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = context.argument_list;
        -: 2412:
    #####: 2413:      ecma_ref_ecma_string (ecma_get_string_from_value (context.argument_list));
    #####: 2414:      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS;
        -: 2415:    }
        -: 2416:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2417:
        -: 2418:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2419:    if (context.is_show_opcodes)
        -: 2420:    {
        -: 2421:      JERRY_DEBUG_MSG ("\n%s parsing successfully completed. Total byte code size: %d bytes\n",
        -: 2422:                       (context.arguments_start_p == NULL) ? "Script" : "Function",
        -: 2423:                       (int) context.total_byte_code_size);
        -: 2424:    }
        -: 2425:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2426:  }
        -: 2427:  PARSER_CATCH
        -: 2428:  {
    #####: 2429:    if (context.last_statement.current_p != NULL)
        -: 2430:    {
    #####: 2431:      parser_free_jumps (context.last_statement);
        -: 2432:    }
        -: 2433:
    #####: 2434:    parser_free_allocated_buffer (&context);
        -: 2435:
    #####: 2436:    scanner_cleanup (&context);
        -: 2437:
        -: 2438:#if JERRY_MODULE_SYSTEM
    #####: 2439:    if (context.module_names_p != NULL)
        -: 2440:    {
    #####: 2441:      ecma_module_release_module_names (context.module_names_p);
        -: 2442:    }
        -: 2443:#endif /* JERRY_MODULE_SYSTEM */
        -: 2444:
    #####: 2445:    compiled_code_p = NULL;
    #####: 2446:    parser_free_literals (&context.literal_pool);
    #####: 2447:    parser_cbc_stream_free (&context.byte_code);
        -: 2448:
        -: 2449:#if JERRY_SOURCE_NAME
    #####: 2450:    ecma_deref_ecma_string (ecma_get_string_from_value (context.script_p->source_name));
        -: 2451:#endif /* JERRY_SOURCE_NAME */
        -: 2452:
    #####: 2453:    if (context.script_p != NULL)
        -: 2454:    {
    #####: 2455:      JERRY_ASSERT (context.script_p->refs_and_type >= CBC_SCRIPT_REF_ONE);
    #####: 2456:      jmem_heap_free_block (context.script_p, parser_script_size (&context));
        -: 2457:    }
        -: 2458:  }
        -: 2459:  PARSER_TRY_END
        -: 2460:
        1: 2461:  if (context.scope_stack_p != NULL)
        -: 2462:  {
        1: 2463:    parser_free (context.scope_stack_p, context.scope_stack_size * sizeof (parser_scope_stack_t));
        -: 2464:  }
        -: 2465:
        -: 2466:#if JERRY_LINE_INFO
    #####: 2467:  parser_line_info_free (context.line_info_p);
        -: 2468:#endif /* JERRY_LINE_INFO */
        -: 2469:
        -: 2470:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2471:  if (context.is_show_opcodes)
        -: 2472:  {
        -: 2473:    JERRY_DEBUG_MSG ("\n--- %s parsing end ---\n\n", (context.arguments_start_p == NULL) ? "Script" : "Function");
        -: 2474:  }
        -: 2475:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2476:
        1: 2477:  parser_stack_free (&context);
        -: 2478:
        1: 2479:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_SOURCE)
        -: 2480:  {
    #####: 2481:    jmem_heap_free_block ((void *) context.source_start_p, context.source_size);
        -: 2482:  }
        -: 2483:
        1: 2484:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_ARG_LIST)
        -: 2485:  {
    #####: 2486:    jmem_heap_free_block ((void *) context.arguments_start_p, context.arguments_size);
        -: 2487:  }
        -: 2488:
        1: 2489:  if (compiled_code_p != NULL)
        -: 2490:  {
        1: 2491:    return compiled_code_p;
        -: 2492:  }
        -: 2493:
        -: 2494:#if JERRY_DEBUGGER
        -: 2495:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2496:  {
        -: 2497:    jerry_debugger_send_type (JERRY_DEBUGGER_PARSE_ERROR);
        -: 2498:  }
        -: 2499:#endif /* JERRY_DEBUGGER */
        -: 2500:
    #####: 2501:  if (context.error == PARSER_ERR_OUT_OF_MEMORY)
        -: 2502:  {
        -: 2503:    /* It is unlikely that memory can be allocated in an out-of-memory
        -: 2504:     * situation. However, a simple value can still be thrown. */
    #####: 2505:    jcontext_raise_exception (ECMA_VALUE_NULL);
    #####: 2506:    return NULL;
        -: 2507:  }
        -: 2508:
        -: 2509:#if JERRY_ERROR_MESSAGES
        -: 2510:  ecma_string_t *err_str_p;
        -: 2511:
    #####: 2512:  if (context.error == PARSER_ERR_INVALID_REGEXP)
        -: 2513:  {
    #####: 2514:    ecma_value_t error = jcontext_take_exception ();
    #####: 2515:    ecma_property_t *prop_p =
    #####: 2516:      ecma_find_named_property (ecma_get_object_from_value (error), ecma_get_magic_string (LIT_MAGIC_STRING_MESSAGE));
    #####: 2517:    ecma_free_value (error);
    #####: 2518:    JERRY_ASSERT (prop_p);
    #####: 2519:    err_str_p = ecma_get_string_from_value (ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 2520:    ecma_ref_ecma_string (err_str_p);
        -: 2521:  }
        -: 2522:  else
        -: 2523:  {
    #####: 2524:    err_str_p = ecma_new_ecma_external_string_from_cesu8 (parser_get_error_utf8 (context.error),
    #####: 2525:                                                          parser_get_error_size (context.error),
        -: 2526:                                                          NULL);
        -: 2527:  }
    #####: 2528:  ecma_value_t err_str_val = ecma_make_string_value (err_str_p);
    #####: 2529:  ecma_value_t line_str_val = ecma_make_uint32_value (context.token.line);
    #####: 2530:  ecma_value_t col_str_val = ecma_make_uint32_value (context.token.column);
    #####: 2531:  ecma_value_t source_name = parser_source_name (&context);
        -: 2532:
    #####: 2533:  ecma_raise_standard_error_with_format (JERRY_ERROR_SYNTAX,
        -: 2534:                                         "% [%:%:%]",
        -: 2535:                                         err_str_val,
        -: 2536:                                         source_name,
        -: 2537:                                         line_str_val,
        -: 2538:                                         col_str_val);
        -: 2539:
    #####: 2540:  ecma_free_value (source_name);
    #####: 2541:  ecma_free_value (col_str_val);
    #####: 2542:  ecma_free_value (line_str_val);
    #####: 2543:  ecma_deref_ecma_string (err_str_p);
        -: 2544:#else /* !JERRY_ERROR_MESSAGES */
        -: 2545:  if (context.error == PARSER_ERR_INVALID_REGEXP)
        -: 2546:  {
        -: 2547:    jcontext_release_exception ();
        -: 2548:  }
        -: 2549:
        -: 2550:  ecma_raise_syntax_error (ECMA_ERR_EMPTY);
        -: 2551:#endif /* JERRY_ERROR_MESSAGES */
        -: 2552:
    #####: 2553:  return NULL;
        -: 2554:} /* parser_parse_source */
        -: 2555:
        -: 2556:/**
        -: 2557: * Save parser context before function parsing.
        -: 2558: */
        -: 2559:static void
        1: 2560:parser_save_context (parser_context_t *context_p, /**< context */
        -: 2561:                     parser_saved_context_t *saved_context_p) /**< target for saving the context */
        -: 2562:{
        1: 2563:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 2564:
        -: 2565:#if JERRY_DEBUGGER
        -: 2566:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -: 2567:  {
        -: 2568:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);
        -: 2569:    context_p->breakpoint_info_count = 0;
        -: 2570:  }
        -: 2571:#endif /* JERRY_DEBUGGER */
        -: 2572:
        -: 2573:#if JERRY_ESNEXT
        1: 2574:  if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)
        -: 2575:  {
    #####: 2576:    context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2577:  }
        -: 2578:#endif /* JERRY_ESNEXT */
        -: 2579:
        -: 2580:  /* Save private part of the context. */
        -: 2581:
        1: 2582:  saved_context_p->status_flags = context_p->status_flags;
        1: 2583:  saved_context_p->stack_depth = context_p->stack_depth;
        1: 2584:  saved_context_p->stack_limit = context_p->stack_limit;
        1: 2585:  saved_context_p->prev_context_p = context_p->last_context_p;
        1: 2586:  saved_context_p->last_statement = context_p->last_statement;
        -: 2587:
        1: 2588:  saved_context_p->argument_count = context_p->argument_count;
        -: 2589:#if JERRY_ESNEXT
        1: 2590:  saved_context_p->argument_length = context_p->argument_length;
        -: 2591:#endif /* JERRY_ESNEXT */
        1: 2592:  saved_context_p->register_count = context_p->register_count;
        1: 2593:  saved_context_p->literal_count = context_p->literal_count;
        -: 2594:
        1: 2595:  saved_context_p->byte_code = context_p->byte_code;
        1: 2596:  saved_context_p->byte_code_size = context_p->byte_code_size;
        1: 2597:  saved_context_p->literal_pool_data = context_p->literal_pool.data;
        1: 2598:  saved_context_p->scope_stack_p = context_p->scope_stack_p;
        1: 2599:  saved_context_p->scope_stack_size = context_p->scope_stack_size;
        1: 2600:  saved_context_p->scope_stack_top = context_p->scope_stack_top;
        1: 2601:  saved_context_p->scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2602:#if JERRY_ESNEXT
        1: 2603:  saved_context_p->scope_stack_global_end = context_p->scope_stack_global_end;
        1: 2604:  saved_context_p->tagged_template_literal_cp = context_p->tagged_template_literal_cp;
        -: 2605:#endif /* JERRY_ESNEXT */
        -: 2606:
        -: 2607:#ifndef JERRY_NDEBUG
        1: 2608:  saved_context_p->context_stack_depth = context_p->context_stack_depth;
        -: 2609:#endif /* !JERRY_NDEBUG */
        -: 2610:
        -: 2611:#if JERRY_LINE_INFO
    #####: 2612:  saved_context_p->line_info_p = context_p->line_info_p;
        -: 2613:#endif /* JERRY_LINE_INFO */
        -: 2614:
        -: 2615:#if JERRY_FUNCTION_TO_STRING
    #####: 2616:  saved_context_p->function_start_p = context_p->function_start_p;
        -: 2617:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2618:
        -: 2619:  /* Reset private part of the context. */
        -: 2620:
        1: 2621:  context_p->status_flags &= PARSER_IS_STRICT;
        1: 2622:  context_p->stack_depth = 0;
        1: 2623:  context_p->stack_limit = 0;
        1: 2624:  context_p->last_context_p = saved_context_p;
        1: 2625:  context_p->last_statement.current_p = NULL;
        -: 2626:
        1: 2627:  context_p->argument_count = 0;
        -: 2628:#if JERRY_ESNEXT
        1: 2629:  context_p->argument_length = UINT16_MAX;
        -: 2630:#endif /* JERRY_ESNEXT */
        1: 2631:  context_p->register_count = 0;
        1: 2632:  context_p->literal_count = 0;
        -: 2633:
        1: 2634:  parser_cbc_stream_init (&context_p->byte_code);
        1: 2635:  context_p->byte_code_size = 0;
        1: 2636:  parser_list_reset (&context_p->literal_pool);
        1: 2637:  context_p->scope_stack_p = NULL;
        1: 2638:  context_p->scope_stack_size = 0;
        1: 2639:  context_p->scope_stack_top = 0;
        1: 2640:  context_p->scope_stack_reg_top = 0;
        -: 2641:#if JERRY_ESNEXT
        1: 2642:  context_p->scope_stack_global_end = 0;
        1: 2643:  context_p->tagged_template_literal_cp = JMEM_CP_NULL;
        -: 2644:#endif /* JERRY_ESNEXT */
        -: 2645:
        -: 2646:#ifndef JERRY_NDEBUG
        1: 2647:  context_p->context_stack_depth = 0;
        -: 2648:#endif /* !JERRY_NDEBUG */
        -: 2649:
        -: 2650:#if JERRY_LINE_INFO
    #####: 2651:  context_p->line_info_p = NULL;
        -: 2652:#endif /* JERRY_LINE_INFO */
        1: 2653:} /* parser_save_context */
        -: 2654:
        -: 2655:/**
        -: 2656: * Restore parser context after function parsing.
        -: 2657: */
        -: 2658:static void
        1: 2659:parser_restore_context (parser_context_t *context_p, /**< context */
        -: 2660:                        parser_saved_context_t *saved_context_p) /**< target for saving the context */
        -: 2661:{
        1: 2662:  parser_list_free (&context_p->literal_pool);
        -: 2663:
        1: 2664:  if (context_p->scope_stack_p != NULL)
        -: 2665:  {
    #####: 2666:    parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));
        -: 2667:  }
        -: 2668:
        -: 2669:#if JERRY_LINE_INFO
    #####: 2670:  parser_line_info_free (context_p->line_info_p);
        -: 2671:#endif /* JERRY_LINE_INFO */
        -: 2672:
        -: 2673:  /* Restore private part of the context. */
        -: 2674:
        1: 2675:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 2676:
        1: 2677:  context_p->status_flags = saved_context_p->status_flags;
        1: 2678:  context_p->stack_depth = saved_context_p->stack_depth;
        1: 2679:  context_p->stack_limit = saved_context_p->stack_limit;
        1: 2680:  context_p->last_context_p = saved_context_p->prev_context_p;
        1: 2681:  context_p->last_statement = saved_context_p->last_statement;
        -: 2682:
        1: 2683:  context_p->argument_count = saved_context_p->argument_count;
        -: 2684:#if JERRY_ESNEXT
        1: 2685:  context_p->argument_length = saved_context_p->argument_length;
        -: 2686:#endif /* JERRY_ESNEXT */
        1: 2687:  context_p->register_count = saved_context_p->register_count;
        1: 2688:  context_p->literal_count = saved_context_p->literal_count;
        -: 2689:
        1: 2690:  context_p->byte_code = saved_context_p->byte_code;
        1: 2691:  context_p->byte_code_size = saved_context_p->byte_code_size;
        1: 2692:  context_p->literal_pool.data = saved_context_p->literal_pool_data;
        1: 2693:  context_p->scope_stack_p = saved_context_p->scope_stack_p;
        1: 2694:  context_p->scope_stack_size = saved_context_p->scope_stack_size;
        1: 2695:  context_p->scope_stack_top = saved_context_p->scope_stack_top;
        1: 2696:  context_p->scope_stack_reg_top = saved_context_p->scope_stack_reg_top;
        -: 2697:#if JERRY_ESNEXT
        1: 2698:  context_p->scope_stack_global_end = saved_context_p->scope_stack_global_end;
        1: 2699:  context_p->tagged_template_literal_cp = saved_context_p->tagged_template_literal_cp;
        -: 2700:#endif /* JERRY_ESNEXT */
        -: 2701:
        -: 2702:#ifndef JERRY_NDEBUG
        1: 2703:  context_p->context_stack_depth = saved_context_p->context_stack_depth;
        -: 2704:#endif /* !JERRY_NDEBUG */
        -: 2705:
        -: 2706:#if JERRY_LINE_INFO
    #####: 2707:  context_p->line_info_p = saved_context_p->line_info_p;
        -: 2708:#endif /* JERRY_LINE_INFO */
        1: 2709:} /* parser_restore_context */
        -: 2710:
        -: 2711:/**
        -: 2712: * Parse function code
        -: 2713: *
        -: 2714: * @return compiled code
        -: 2715: */
        -: 2716:ecma_compiled_code_t *
        1: 2717:parser_parse_function (parser_context_t *context_p, /**< context */
        -: 2718:                       uint32_t status_flags) /**< extra status flags */
        -: 2719:{
        1: 2720:  parser_saved_context_t saved_context;
        -: 2721:  ecma_compiled_code_t *compiled_code_p;
        -: 2722:
        1: 2723:  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);
        1: 2724:  parser_save_context (context_p, &saved_context);
        1: 2725:  context_p->status_flags |= status_flags;
        -: 2726:#if JERRY_ESNEXT
        1: 2727:  context_p->status_flags |= PARSER_ALLOW_NEW_TARGET;
        -: 2728:#endif /* JERRY_ESNEXT */
        -: 2729:
        -: 2730:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2731:  if (context_p->is_show_opcodes)
        -: 2732:  {
        -: 2733:#if JERRY_ESNEXT
        -: 2734:    JERRY_DEBUG_MSG ("\n--- %s parsing start ---\n\n",
        -: 2735:                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? "Class constructor" : "Function");
        -: 2736:#else /* !JERRY_ESNEXT */
        -: 2737:    JERRY_DEBUG_MSG ("\n--- Function parsing start ---\n\n");
        -: 2738:#endif /* JERRY_ESNEXT */
        -: 2739:  }
        -: 2740:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2741:
        -: 2742:#if JERRY_DEBUGGER
        -: 2743:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2744:  {
        -: 2745:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2746:  }
        -: 2747:#endif /* JERRY_DEBUGGER */
        -: 2748:
        1: 2749:  lexer_next_token (context_p);
        -: 2750:
        1: 2751:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2752:  {
    #####: 2753:    parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);
        -: 2754:  }
        -: 2755:
        1: 2756:  lexer_next_token (context_p);
        -: 2757:
        1: 2758:  parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);
        1: 2759:  lexer_next_token (context_p);
        -: 2760:
        1: 2761:  if ((context_p->status_flags & PARSER_IS_PROPERTY_GETTER) && context_p->argument_count != 0)
        -: 2762:  {
    #####: 2763:    parser_raise_error (context_p, PARSER_ERR_NO_ARGUMENTS_EXPECTED);
        -: 2764:  }
        -: 2765:
        1: 2766:  if ((context_p->status_flags & PARSER_IS_PROPERTY_SETTER) && context_p->argument_count != 1)
        -: 2767:  {
    #####: 2768:    parser_raise_error (context_p, PARSER_ERR_ONE_ARGUMENT_EXPECTED);
        -: 2769:  }
        -: 2770:
        -: 2771:#if JERRY_ESNEXT
        1: 2772:  if ((context_p->status_flags & (PARSER_CLASS_CONSTRUCTOR | PARSER_ALLOW_SUPER_CALL)) == PARSER_CLASS_CONSTRUCTOR)
        -: 2773:  {
    #####: 2774:    parser_emit_cbc_ext (context_p, CBC_EXT_RUN_FIELD_INIT);
    #####: 2775:    parser_flush_cbc (context_p);
        -: 2776:  }
        -: 2777:#endif /* JERRY_ESNEXT */
        -: 2778:
        -: 2779:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2780:  if (context_p->is_show_opcodes && (context_p->status_flags & PARSER_HAS_NON_STRICT_ARG))
        -: 2781:  {
        -: 2782:    JERRY_DEBUG_MSG ("  Note: legacy (non-strict) argument definition\n\n");
        -: 2783:  }
        -: 2784:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2785:
        1: 2786:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2787:  {
    #####: 2788:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 2789:  }
        -: 2790:
        1: 2791:  lexer_next_token (context_p);
        1: 2792:  parser_parse_statements (context_p);
        1: 2793:  compiled_code_p = parser_post_processing (context_p);
        -: 2794:
        -: 2795:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2796:  if (context_p->is_show_opcodes)
        -: 2797:  {
        -: 2798:#if JERRY_ESNEXT
        -: 2799:    JERRY_DEBUG_MSG ("\n--- %s parsing end ---\n\n",
        -: 2800:                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? "Class constructor" : "Function");
        -: 2801:#else /* !JERRY_ESNEXT */
        -: 2802:    JERRY_DEBUG_MSG ("\n--- Function parsing end ---\n\n");
        -: 2803:#endif /* JERRY_ESNEXT */
        -: 2804:  }
        -: 2805:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2806:
        1: 2807:  parser_restore_context (context_p, &saved_context);
        -: 2808:
        1: 2809:  return compiled_code_p;
        -: 2810:} /* parser_parse_function */
        -: 2811:
        -: 2812:#if JERRY_ESNEXT
        -: 2813:
        -: 2814:/**
        -: 2815: * Parse static class block code
        -: 2816: *
        -: 2817: * @return compiled code
        -: 2818: */
        -: 2819:ecma_compiled_code_t *
    #####: 2820:parser_parse_class_static_block (parser_context_t *context_p) /**< context */
        -: 2821:{
    #####: 2822:  parser_saved_context_t saved_context;
        -: 2823:  ecma_compiled_code_t *compiled_code_p;
        -: 2824:
    #####: 2825:  parser_save_context (context_p, &saved_context);
    #####: 2826:  context_p->status_flags |= (PARSER_IS_CLASS_STATIC_BLOCK | PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER
        -: 2827:                              | PARSER_INSIDE_CLASS_FIELD | PARSER_ALLOW_NEW_TARGET | PARSER_DISALLOW_AWAIT_YIELD);
        -: 2828:
        -: 2829:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2830:  if (context_p->is_show_opcodes)
        -: 2831:  {
        -: 2832:    JERRY_DEBUG_MSG ("\n--- Static class block parsing start ---\n\n");
        -: 2833:  }
        -: 2834:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2835:
    #####: 2836:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
    #####: 2837:  lexer_next_token (context_p);
        -: 2838:
    #####: 2839:  parser_parse_statements (context_p);
    #####: 2840:  compiled_code_p = parser_post_processing (context_p);
        -: 2841:
        -: 2842:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2843:  if (context_p->is_show_opcodes)
        -: 2844:  {
        -: 2845:    JERRY_DEBUG_MSG ("\n--- Static class block parsing end ---\n\n");
        -: 2846:  }
        -: 2847:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2848:
    #####: 2849:  parser_restore_context (context_p, &saved_context);
        -: 2850:
    #####: 2851:  return compiled_code_p;
        -: 2852:} /* parser_parse_class_static_block */
        -: 2853:
        -: 2854:/**
        -: 2855: * Parse arrow function code
        -: 2856: *
        -: 2857: * @return compiled code
        -: 2858: */
        -: 2859:ecma_compiled_code_t *
    #####: 2860:parser_parse_arrow_function (parser_context_t *context_p, /**< context */
        -: 2861:                             uint32_t status_flags) /**< extra status flags */
        -: 2862:{
    #####: 2863:  parser_saved_context_t saved_context;
        -: 2864:  ecma_compiled_code_t *compiled_code_p;
        -: 2865:
    #####: 2866:  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);
    #####: 2867:  JERRY_ASSERT (status_flags & PARSER_IS_ARROW_FUNCTION);
    #####: 2868:  parser_save_context (context_p, &saved_context);
    #####: 2869:  context_p->status_flags |= status_flags;
    #####: 2870:  context_p->status_flags |=
    #####: 2871:    saved_context.status_flags & (PARSER_ALLOW_NEW_TARGET | PARSER_ALLOW_SUPER | PARSER_ALLOW_SUPER_CALL);
        -: 2872:
        -: 2873:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2874:  if (context_p->is_show_opcodes)
        -: 2875:  {
        -: 2876:    JERRY_DEBUG_MSG ("\n--- Arrow function parsing start ---\n\n");
        -: 2877:  }
        -: 2878:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2879:
        -: 2880:#if JERRY_DEBUGGER
        -: 2881:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2882:  {
        -: 2883:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2884:  }
        -: 2885:#endif /* JERRY_DEBUGGER */
        -: 2886:
        -: 2887:  /* The `await` keyword is disallowed in the IdentifierReference position */
    #####: 2888:  if (status_flags & PARSER_IS_CLASS_STATIC_BLOCK)
        -: 2889:  {
    #####: 2890:    context_p->status_flags |= PARSER_DISALLOW_AWAIT_YIELD;
        -: 2891:  }
        -: 2892:
    #####: 2893:  if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2894:  {
    #####: 2895:    lexer_next_token (context_p);
    #####: 2896:    parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);
    #####: 2897:    lexer_next_token (context_p);
        -: 2898:  }
        -: 2899:  else
        -: 2900:  {
    #####: 2901:    parser_parse_function_arguments (context_p, LEXER_ARROW);
        -: 2902:  }
        -: 2903:
        -: 2904:  /* The `await` keyword is interpreted as an identifier within the body of arrow functions */
    #####: 2905:  if (status_flags & PARSER_IS_CLASS_STATIC_BLOCK)
        -: 2906:  {
    #####: 2907:    context_p->status_flags &= (uint32_t) ~(PARSER_DISALLOW_AWAIT_YIELD | PARSER_IS_CLASS_STATIC_BLOCK);
        -: 2908:  }
        -: 2909:
    #####: 2910:  JERRY_ASSERT (context_p->token.type == LEXER_ARROW);
        -: 2911:
    #####: 2912:  lexer_next_token (context_p);
        -: 2913:
    #####: 2914:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2915:  {
    #####: 2916:    lexer_next_token (context_p);
        -: 2917:
    #####: 2918:    context_p->status_flags |= PARSER_IS_CLOSURE;
    #####: 2919:    parser_parse_statements (context_p);
        -: 2920:
        -: 2921:    /* Unlike normal function, arrow functions consume their close brace. */
    #####: 2922:    JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE);
    #####: 2923:    lexer_next_token (context_p);
        -: 2924:  }
        -: 2925:  else
        -: 2926:  {
    #####: 2927:    if (context_p->status_flags & PARSER_IS_STRICT && context_p->status_flags & PARSER_HAS_NON_STRICT_ARG)
        -: 2928:    {
    #####: 2929:      parser_raise_error (context_p, PARSER_ERR_NON_STRICT_ARG_DEFINITION);
        -: 2930:    }
        -: 2931:
        -: 2932:#if JERRY_LINE_INFO
    #####: 2933:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2934:#endif /* JERRY_LINE_INFO */
        -: 2935:
    #####: 2936:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2937:
    #####: 2938:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2939:    {
    #####: 2940:      context_p->last_cbc_opcode = CBC_RETURN_WITH_LITERAL;
        -: 2941:    }
        -: 2942:    else
        -: 2943:    {
    #####: 2944:      parser_emit_cbc (context_p, CBC_RETURN);
        -: 2945:    }
    #####: 2946:    parser_flush_cbc (context_p);
        -: 2947:
    #####: 2948:    lexer_update_await_yield (context_p, saved_context.status_flags);
        -: 2949:  }
        -: 2950:
    #####: 2951:  compiled_code_p = parser_post_processing (context_p);
        -: 2952:
        -: 2953:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2954:  if (context_p->is_show_opcodes)
        -: 2955:  {
        -: 2956:    JERRY_DEBUG_MSG ("\n--- Arrow function parsing end ---\n\n");
        -: 2957:  }
        -: 2958:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2959:
    #####: 2960:  parser_restore_context (context_p, &saved_context);
        -: 2961:
    #####: 2962:  return compiled_code_p;
        -: 2963:} /* parser_parse_arrow_function */
        -: 2964:
        -: 2965:/**
        -: 2966: * Parse class fields
        -: 2967: *
        -: 2968: * @return compiled code
        -: 2969: */
        -: 2970:ecma_compiled_code_t *
    #####: 2971:parser_parse_class_fields (parser_context_t *context_p) /**< context */
        -: 2972:{
    #####: 2973:  parser_saved_context_t saved_context;
        -: 2974:  ecma_compiled_code_t *compiled_code_p;
        -: 2975:
    #####: 2976:  uint32_t extra_status_flags = context_p->status_flags & PARSER_INSIDE_WITH;
        -: 2977:
    #####: 2978:  parser_save_context (context_p, &saved_context);
    #####: 2979:  context_p->status_flags |= (PARSER_IS_FUNCTION | PARSER_ALLOW_SUPER | PARSER_INSIDE_CLASS_FIELD
        -: 2980:                              | PARSER_ALLOW_NEW_TARGET | extra_status_flags);
        -: 2981:
        -: 2982:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2983:  if (context_p->is_show_opcodes)
        -: 2984:  {
        -: 2985:    JERRY_DEBUG_MSG ("\n--- Class fields parsing start ---\n\n");
        -: 2986:  }
        -: 2987:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2988:
        -: 2989:#if JERRY_DEBUGGER
        -: 2990:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2991:  {
        -: 2992:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2993:  }
        -: 2994:#endif /* JERRY_DEBUGGER */
        -: 2995:
    #####: 2996:  const uint8_t *source_end_p = context_p->source_end_p;
    #####: 2997:  bool first_computed_class_field = true;
    #####: 2998:  scanner_location_t end_location;
    #####: 2999:  scanner_get_location (&end_location, context_p);
        -: 3000:
        -: 3001:  do
        -: 3002:  {
    #####: 3003:    uint8_t class_field_type = context_p->stack_top_uint8;
    #####: 3004:    parser_stack_pop_uint8 (context_p);
        -: 3005:
    #####: 3006:    scanner_range_t range = { 0 };
        -: 3007:
    #####: 3008:    if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 3009:    {
    #####: 3010:      parser_stack_pop (context_p, &range, sizeof (scanner_range_t));
        -: 3011:    }
    #####: 3012:    else if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 3013:    {
    #####: 3014:      parser_stack_pop (context_p, &range.start_location, sizeof (scanner_location_t));
        -: 3015:    }
        -: 3016:
    #####: 3017:    uint16_t literal_index = 0;
    #####: 3018:    bool is_private = false;
        -: 3019:
    #####: 3020:    if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 3021:    {
    #####: 3022:      scanner_set_location (context_p, &range.start_location);
        -: 3023:
    #####: 3024:      if (class_field_type & PARSER_CLASS_FIELD_STATIC_BLOCK)
        -: 3025:      {
    #####: 3026:        scanner_seek (context_p);
    #####: 3027:        JERRY_ASSERT (context_p->source_p[1] == LIT_CHAR_LEFT_BRACE);
    #####: 3028:        context_p->source_p += 2;
    #####: 3029:        context_p->source_end_p = source_end_p;
        -: 3030:
    #####: 3031:        uint16_t func_index = lexer_construct_class_static_block_function (context_p);
        -: 3032:
    #####: 3033:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_CLASS_CALL_STATIC_BLOCK, func_index);
    #####: 3034:        continue;
        -: 3035:      }
        -: 3036:
    #####: 3037:      uint32_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
    #####: 3038:      is_private = context_p->source_p[-1] == LIT_CHAR_HASHMARK;
        -: 3039:
    #####: 3040:      if (is_private)
        -: 3041:      {
    #####: 3042:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
        -: 3043:      }
        -: 3044:
    #####: 3045:      context_p->source_end_p = source_end_p;
    #####: 3046:      scanner_seek (context_p);
        -: 3047:
    #####: 3048:      lexer_expect_object_literal_id (context_p, ident_opts);
        -: 3049:
    #####: 3050:      literal_index = context_p->lit_object.index;
        -: 3051:
    #####: 3052:      if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 3053:      {
    #####: 3054:        lexer_next_token (context_p);
    #####: 3055:        JERRY_ASSERT (context_p->token.type == LEXER_ASSIGN);
        -: 3056:      }
        -: 3057:    }
    #####: 3058:    else if (first_computed_class_field)
        -: 3059:    {
    #####: 3060:      parser_emit_cbc (context_p, CBC_PUSH_NUMBER_0);
    #####: 3061:      first_computed_class_field = false;
        -: 3062:    }
        -: 3063:
    #####: 3064:    if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 3065:    {
    #####: 3066:      if (!(class_field_type & PARSER_CLASS_FIELD_NORMAL))
        -: 3067:      {
    #####: 3068:        scanner_set_location (context_p, &range.start_location);
    #####: 3069:        scanner_seek (context_p);
        -: 3070:      }
        -: 3071:
    #####: 3072:      context_p->source_end_p = range.source_end_p;
    #####: 3073:      lexer_next_token (context_p);
        -: 3074:
        -: 3075:#if JERRY_LINE_INFO
    #####: 3076:      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3077:#endif /* JERRY_LINE_INFO */
        -: 3078:
    #####: 3079:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 3080:
    #####: 3081:      if (context_p->token.type != LEXER_EOS)
        -: 3082:      {
    #####: 3083:        parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 3084:      }
        -: 3085:    }
        -: 3086:    else
        -: 3087:    {
    #####: 3088:      parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 3089:    }
        -: 3090:
    #####: 3091:    if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 3092:    {
    #####: 3093:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3094:
    #####: 3095:      if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3096:      {
    #####: 3097:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, literal_index);
        -: 3098:      }
    #####: 3099:      else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3100:      {
    #####: 3101:        uint32_t function_name_status_flags = is_private ? PARSER_PRIVATE_FUNCTION_NAME : 0;
    #####: 3102:        parser_set_function_name (context_p, function_literal_index, literal_index, function_name_status_flags);
        -: 3103:      }
        -: 3104:
    #####: 3105:      if (is_private)
        -: 3106:      {
    #####: 3107:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_PRIVATE_FIELD_ADD, literal_index);
        -: 3108:      }
        -: 3109:      else
        -: 3110:      {
    #####: 3111:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_DEFINE_FIELD, literal_index);
        -: 3112:      }
        -: 3113:
        -: 3114:      /* Prepare stack slot for assignment property reference base. Needed by vm.c */
    #####: 3115:      if (context_p->stack_limit == context_p->stack_depth)
        -: 3116:      {
    #####: 3117:        context_p->stack_limit++;
    #####: 3118:        JERRY_ASSERT (context_p->stack_limit <= PARSER_MAXIMUM_STACK_LIMIT);
        -: 3119:      }
        -: 3120:    }
        -: 3121:    else
        -: 3122:    {
    #####: 3123:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
    #####: 3124:      uint16_t opcode = CBC_EXT_SET_NEXT_COMPUTED_FIELD;
        -: 3125:
    #####: 3126:      if (function_literal_index < PARSER_NAMED_FUNCTION || function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3127:      {
    #####: 3128:        opcode = CBC_EXT_SET_NEXT_COMPUTED_FIELD_ANONYMOUS_FUNC;
        -: 3129:      }
        -: 3130:
    #####: 3131:      parser_flush_cbc (context_p);
        -: 3132:
        -: 3133:      /* The next opcode pushes two more temporary values onto the stack */
    #####: 3134:      if (context_p->stack_depth + 1 > context_p->stack_limit)
        -: 3135:      {
    #####: 3136:        context_p->stack_limit = (uint16_t) (context_p->stack_depth + 1);
    #####: 3137:        if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -: 3138:        {
    #####: 3139:          parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -: 3140:        }
        -: 3141:      }
        -: 3142:
    #####: 3143:      parser_emit_cbc_ext (context_p, opcode);
        -: 3144:    }
    #####: 3145:  } while (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_END));
        -: 3146:
    #####: 3147:  if (!first_computed_class_field)
        -: 3148:  {
    #####: 3149:    parser_emit_cbc (context_p, CBC_POP);
        -: 3150:  }
        -: 3151:
    #####: 3152:  parser_flush_cbc (context_p);
    #####: 3153:  context_p->source_end_p = source_end_p;
    #####: 3154:  scanner_set_location (context_p, &end_location);
        -: 3155:
        -: 3156:#if JERRY_LINE_INFO
    #####: 3157:  if (context_p->line_info_p == NULL)
        -: 3158:  {
    #####: 3159:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3160:  }
        -: 3161:#endif /* JERRY_LINE_INFO */
        -: 3162:
    #####: 3163:  compiled_code_p = parser_post_processing (context_p);
        -: 3164:
        -: 3165:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 3166:  if (context_p->is_show_opcodes)
        -: 3167:  {
        -: 3168:    JERRY_DEBUG_MSG ("\n--- Class fields parsing end ---\n\n");
        -: 3169:  }
        -: 3170:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 3171:
    #####: 3172:  parser_restore_context (context_p, &saved_context);
        -: 3173:
    #####: 3174:  return compiled_code_p;
        -: 3175:} /* parser_parse_class_fields */
        -: 3176:
        -: 3177:/**
        -: 3178: * Check whether the last emitted cbc opcode was an anonymous function declaration
        -: 3179: *
        -: 3180: * @return PARSER_NOT_FUNCTION_LITERAL - if the last opcode is not a function literal
        -: 3181: *         PARSER_NAMED_FUNCTION - if the last opcode is not a named function declataion
        -: 3182: *         PARSER_ANONYMOUS_CLASS - if the last opcode is an anonymous class declaration
        -: 3183: *         literal index of the anonymous function literal - otherwise
        -: 3184: */
        -: 3185:uint16_t
    #####: 3186:parser_check_anonymous_function_declaration (parser_context_t *context_p) /**< context */
        -: 3187:{
    #####: 3188:  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))
        -: 3189:  {
    #####: 3190:    return PARSER_ANONYMOUS_CLASS;
        -: 3191:  }
        -: 3192:
    #####: 3193:  if (context_p->last_cbc.literal_type != LEXER_FUNCTION_LITERAL)
        -: 3194:  {
    #####: 3195:    return PARSER_NOT_FUNCTION_LITERAL;
        -: 3196:  }
        -: 3197:
    #####: 3198:  uint16_t literal_index = PARSER_NOT_FUNCTION_LITERAL;
        -: 3199:
    #####: 3200:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3201:  {
    #####: 3202:    literal_index = context_p->last_cbc.literal_index;
        -: 3203:  }
    #####: 3204:  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 3205:  {
    #####: 3206:    literal_index = context_p->last_cbc.value;
        -: 3207:  }
    #####: 3208:  else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)
        -: 3209:  {
    #####: 3210:    literal_index = context_p->last_cbc.third_literal_index;
        -: 3211:  }
        -: 3212:  else
        -: 3213:  {
    #####: 3214:    return PARSER_NOT_FUNCTION_LITERAL;
        -: 3215:  }
        -: 3216:
        -: 3217:  const ecma_compiled_code_t *bytecode_p;
    #####: 3218:  bytecode_p = (const ecma_compiled_code_t *) (PARSER_GET_LITERAL (literal_index)->u.bytecode_p);
    #####: 3219:  bool is_anon =
    #####: 3220:    ecma_is_value_magic_string (*ecma_compiled_code_resolve_function_name (bytecode_p), LIT_MAGIC_STRING__EMPTY);
        -: 3221:
    #####: 3222:  return (is_anon ? literal_index : PARSER_NAMED_FUNCTION);
        -: 3223:} /* parser_check_anonymous_function_declaration */
        -: 3224:
        -: 3225:/**
        -: 3226: * Set the function name of the function literal corresponds to the given function literal index
        -: 3227: * to the given character buffer of literal corresponds to the given name index.
        -: 3228: */
        -: 3229:void
    #####: 3230:parser_set_function_name (parser_context_t *context_p, /**< context */
        -: 3231:                          uint16_t function_literal_index, /**< function literal index */
        -: 3232:                          uint16_t name_index, /**< function name literal index */
        -: 3233:                          uint32_t status_flags) /**< status flags */
        -: 3234:{
        -: 3235:  ecma_compiled_code_t *bytecode_p;
    #####: 3236:  bytecode_p = (ecma_compiled_code_t *) (PARSER_GET_LITERAL (function_literal_index)->u.bytecode_p);
        -: 3237:
    #####: 3238:  parser_compiled_code_set_function_name (context_p, bytecode_p, name_index, status_flags);
    #####: 3239:} /* parser_set_function_name */
        -: 3240:
        -: 3241:/**
        -: 3242: * Prepend the given prefix into the current function name literal
        -: 3243: *
        -: 3244: * @return pointer to the newly allocated buffer
        -: 3245: */
        -: 3246:static uint8_t *
    #####: 3247:parser_add_function_name_prefix (parser_context_t *context_p, /**< context */
        -: 3248:                                 const char *prefix_p, /**< prefix */
        -: 3249:                                 uint32_t prefix_size, /**< prefix's length */
        -: 3250:                                 uint32_t *name_length_p, /**< [out] function name's size */
        -: 3251:                                 lexer_literal_t *name_lit_p) /**< function name literal */
        -: 3252:{
    #####: 3253:  *name_length_p += prefix_size;
    #####: 3254:  uint8_t *name_buffer_p = (uint8_t *) parser_malloc (context_p, *name_length_p * sizeof (uint8_t));
    #####: 3255:  memcpy (name_buffer_p, prefix_p, prefix_size);
    #####: 3256:  memcpy (name_buffer_p + prefix_size, name_lit_p->u.char_p, name_lit_p->prop.length);
        -: 3257:
    #####: 3258:  return name_buffer_p;
        -: 3259:} /* parser_add_function_name_prefix */
        -: 3260:
        -: 3261:/**
        -: 3262: * Set the function name of the given compiled code
        -: 3263: * to the given character buffer of literal corresponds to the given name index.
        -: 3264: */
        -: 3265:void
        1: 3266:parser_compiled_code_set_function_name (parser_context_t *context_p, /**< context */
        -: 3267:                                        ecma_compiled_code_t *bytecode_p, /**< function literal index */
        -: 3268:                                        uint16_t name_index, /**< function name literal index */
        -: 3269:                                        uint32_t status_flags) /**< status flags */
        -: 3270:{
        -: 3271:  ecma_value_t *func_name_start_p;
        1: 3272:  func_name_start_p = ecma_compiled_code_resolve_function_name ((const ecma_compiled_code_t *) bytecode_p);
        -: 3273:
        1: 3274:  if (JERRY_UNLIKELY (!ecma_is_value_magic_string (*func_name_start_p, LIT_MAGIC_STRING__EMPTY)))
        -: 3275:  {
    #####: 3276:    return;
        -: 3277:  }
        -: 3278:
        1: 3279:  parser_scope_stack_t *scope_stack_start_p = context_p->scope_stack_p;
        1: 3280:  parser_scope_stack_t *scope_stack_p = scope_stack_start_p + context_p->scope_stack_top;
        -: 3281:
        3: 3282:  while (scope_stack_p > scope_stack_start_p)
        -: 3283:  {
        2: 3284:    scope_stack_p--;
        -: 3285:
        2: 3286:    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC && scanner_decode_map_to (scope_stack_p) == name_index)
        -: 3287:    {
        1: 3288:      name_index = scope_stack_p->map_from;
        1: 3289:      break;
        -: 3290:    }
        -: 3291:  }
        -: 3292:
        1: 3293:  lexer_literal_t *name_lit_p = (lexer_literal_t *) PARSER_GET_LITERAL (name_index);
        -: 3294:
        1: 3295:  if (name_lit_p->type != LEXER_IDENT_LITERAL && name_lit_p->type != LEXER_STRING_LITERAL)
        -: 3296:  {
    #####: 3297:    return;
        -: 3298:  }
        -: 3299:
        1: 3300:  uint8_t *name_buffer_p = (uint8_t *) name_lit_p->u.char_p;
        1: 3301:  uint32_t name_length = name_lit_p->prop.length;
        -: 3302:
        1: 3303:  if (status_flags & PARSER_PRIVATE_FUNCTION_NAME)
        -: 3304:  {
    #####: 3305:    name_buffer_p = parser_add_function_name_prefix (context_p, "#", 1, &name_length, name_lit_p);
        -: 3306:  }
        1: 3307:  else if (status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))
        -: 3308:  {
    #####: 3309:    name_buffer_p = parser_add_function_name_prefix (context_p,
    #####: 3310:                                                     (status_flags & PARSER_IS_PROPERTY_GETTER) ? "get " : "set ",
        -: 3311:                                                     4,
        -: 3312:                                                     &name_length,
        -: 3313:                                                     name_lit_p);
        -: 3314:  }
        -: 3315:
        1: 3316:  *func_name_start_p =
        1: 3317:    ecma_find_or_create_literal_string (name_buffer_p, name_length, (status_flags & LEXER_FLAG_ASCII) != 0);
        -: 3318:
        1: 3319:  if (name_buffer_p != name_lit_p->u.char_p)
        -: 3320:  {
    #####: 3321:    parser_free (name_buffer_p, name_length);
        -: 3322:  }
        -: 3323:} /* parser_compiled_code_set_function_name */
        -: 3324:
        -: 3325:#endif /* JERRY_ESNEXT */
        -: 3326:
        -: 3327:/**
        -: 3328: * Raise a parse error.
        -: 3329: */
        -: 3330:void
    #####: 3331:parser_raise_error (parser_context_t *context_p, /**< context */
        -: 3332:                    parser_error_msg_t error) /**< error code */
        -: 3333:{
        -: 3334:  /* Must be compatible with the scanner because
        -: 3335:   * the lexer might throws errors during prescanning. */
    #####: 3336:  parser_saved_context_t *saved_context_p = context_p->last_context_p;
        -: 3337:
    #####: 3338:  while (saved_context_p != NULL)
        -: 3339:  {
    #####: 3340:    parser_cbc_stream_free (&saved_context_p->byte_code);
        -: 3341:
        -: 3342:    /* First the current literal pool is freed, and then it is replaced
        -: 3343:     * by the literal pool coming from the saved context. Since literals
        -: 3344:     * are not used anymore, this is a valid replacement. The last pool
        -: 3345:     * is freed by parser_parse_source. */
        -: 3346:
    #####: 3347:    parser_free_literals (&context_p->literal_pool);
    #####: 3348:    context_p->literal_pool.data = saved_context_p->literal_pool_data;
        -: 3349:
    #####: 3350:    if (context_p->scope_stack_p != NULL)
        -: 3351:    {
    #####: 3352:      parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));
        -: 3353:    }
    #####: 3354:    context_p->scope_stack_p = saved_context_p->scope_stack_p;
    #####: 3355:    context_p->scope_stack_size = saved_context_p->scope_stack_size;
        -: 3356:
    #####: 3357:    if (saved_context_p->last_statement.current_p != NULL)
        -: 3358:    {
    #####: 3359:      parser_free_jumps (saved_context_p->last_statement);
        -: 3360:    }
        -: 3361:
        -: 3362:#if JERRY_ESNEXT
    #####: 3363:    if (saved_context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 3364:    {
    #####: 3365:      ecma_collection_t *collection =
    #####: 3366:        ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, saved_context_p->tagged_template_literal_cp);
    #####: 3367:      ecma_collection_free_template_literal (collection);
        -: 3368:    }
        -: 3369:#endif /* JERRY_ESNEXT  */
        -: 3370:
        -: 3371:#if JERRY_LINE_INFO
    #####: 3372:    parser_line_info_free (saved_context_p->line_info_p);
        -: 3373:#endif /* JERRY_LINE_INFO */
        -: 3374:
    #####: 3375:    saved_context_p = saved_context_p->prev_context_p;
        -: 3376:  }
        -: 3377:
        -: 3378:#if JERRY_ESNEXT
    #####: 3379:  parser_free_private_fields (context_p);
        -: 3380:
    #####: 3381:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 3382:  {
    #####: 3383:    ecma_collection_t *collection =
    #####: 3384:      ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_p->tagged_template_literal_cp);
    #####: 3385:    ecma_collection_free_template_literal (collection);
        -: 3386:  }
        -: 3387:#endif /* JERRY_ESNEXT  */
        -: 3388:
    #####: 3389:  context_p->error = error;
    #####: 3390:  PARSER_THROW (context_p->try_buffer);
        -: 3391:  /* Should never been reached. */
        -: 3392:  JERRY_ASSERT (0);
        -: 3393:} /* parser_raise_error */
        -: 3394:
        -: 3395:#endif /* JERRY_PARSER */
        -: 3396:
        -: 3397:/**
        -: 3398: * Parse EcmaScript source code
        -: 3399: *
        -: 3400: * Note:
        -: 3401: *      if arg_list_p is not NULL, a function body is parsed
        -: 3402: *      returned value must be freed with ecma_free_value
        -: 3403: *
        -: 3404: * @return pointer to compiled byte code - if success
        -: 3405: *         NULL - otherwise
        -: 3406: */
        -: 3407:ecma_compiled_code_t *
        1: 3408:parser_parse_script (void *source_p, /**< source code */
        -: 3409:                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */
        -: 3410:                     const jerry_parse_options_t *options_p) /**< additional configuration options */
        -: 3411:{
        -: 3412:#if JERRY_PARSER
        1: 3413:  ecma_compiled_code_t *bytecode_p = parser_parse_source (source_p, parse_opts, options_p);
        -: 3414:
        1: 3415:  if (JERRY_UNLIKELY (bytecode_p == NULL))
        -: 3416:  {
        -: 3417:    /* Exception has already thrown. */
    #####: 3418:    return NULL;
        -: 3419:  }
        -: 3420:
        -: 3421:#if JERRY_DEBUGGER
        -: 3422:  if ((JERRY_CONTEXT (debugger_flags) & (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))
        -: 3423:      == (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))
        -: 3424:  {
        -: 3425:    JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_PARSER_WAIT_MODE);
        -: 3426:    jerry_debugger_send_type (JERRY_DEBUGGER_WAITING_AFTER_PARSE);
        -: 3427:
        -: 3428:    while (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_PARSER_WAIT_MODE)
        -: 3429:    {
        -: 3430:      jerry_debugger_receive (NULL);
        -: 3431:
        -: 3432:      if (!(JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED))
        -: 3433:      {
        -: 3434:        break;
        -: 3435:      }
        -: 3436:
        -: 3437:      jerry_debugger_transport_sleep ();
        -: 3438:    }
        -: 3439:  }
        -: 3440:#endif /* JERRY_DEBUGGER */
        -: 3441:
        1: 3442:  return bytecode_p;
        -: 3443:#else /* !JERRY_PARSER */
        -: 3444:  JERRY_UNUSED (arg_list_p);
        -: 3445:  JERRY_UNUSED (arg_list_size);
        -: 3446:  JERRY_UNUSED (source_p);
        -: 3447:  JERRY_UNUSED (source_size);
        -: 3448:  JERRY_UNUSED (parse_opts);
        -: 3449:  JERRY_UNUSED (source_name);
        -: 3450:
        -: 3451:  ecma_raise_syntax_error (ECMA_ERR_PARSER_NOT_SUPPORTED);
        -: 3452:  return NULL;
        -: 3453:#endif /* JERRY_PARSER */
        -: 3454:} /* parser_parse_script */
        -: 3455:
        -: 3456:/**
        -: 3457: * @}
        -: 3458: * @}
        -: 3459: * @}
        -: 3460: */
