        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-string.c
        -:    0:Programs:297
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-conversion.h"
        -:   18:#include "ecma-exceptions.h"
        -:   19:#include "ecma-gc.h"
        -:   20:#include "ecma-globals.h"
        -:   21:#include "ecma-helpers-number.h"
        -:   22:#include "ecma-helpers.h"
        -:   23:
        -:   24:#include "jcontext.h"
        -:   25:#include "jrt-libc-includes.h"
        -:   26:#include "jrt.h"
        -:   27:#include "lit-char-helpers.h"
        -:   28:#include "lit-magic-strings.h"
        -:   29:
        -:   30:/** \addtogroup ecma ECMA
        -:   31: * @{
        -:   32: *
        -:   33: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   34: * @{
        -:   35: */
        -:   36:
        -:   37:JERRY_STATIC_ASSERT (ECMA_STRING_CONTAINER_MASK >= ECMA_STRING_CONTAINER__MAX,
        -:   38:                     ecma_string_container_types_must_be_lower_than_the_container_mask);
        -:   39:
        -:   40:JERRY_STATIC_ASSERT ((ECMA_STRING_MAX_REF | ECMA_STRING_CONTAINER_MASK | ECMA_STATIC_STRING_FLAG) == UINT32_MAX,
        -:   41:                     ecma_string_ref_and_container_fields_should_fill_the_32_bit_field);
        -:   42:
        -:   43:JERRY_STATIC_ASSERT (ECMA_STRING_NOT_ARRAY_INDEX == UINT32_MAX,
        -:   44:                     ecma_string_not_array_index_must_be_equal_to_uint32_max);
        -:   45:
        -:   46:JERRY_STATIC_ASSERT ((ECMA_TYPE_DIRECT_STRING & 0x1) != 0, ecma_type_direct_string_must_be_odd_number);
        -:   47:
        -:   48:JERRY_STATIC_ASSERT (LIT_MAGIC_STRING__COUNT <= ECMA_DIRECT_STRING_MAX_IMM,
        -:   49:                     all_magic_strings_must_be_encoded_as_direct_string);
        -:   50:
        -:   51:JERRY_STATIC_ASSERT ((int) ECMA_DIRECT_STRING_UINT == (int) ECMA_STRING_CONTAINER_UINT32_IN_DESC,
        -:   52:                     ecma_direct_and_container_types_must_match);
        -:   53:
        -:   54:JERRY_STATIC_ASSERT (ECMA_PROPERTY_NAME_TYPE_SHIFT > ECMA_VALUE_SHIFT,
        -:   55:                     ecma_property_name_type_shift_must_be_greater_than_ecma_value_shift);
        -:   56:
        -:   57:JERRY_STATIC_ASSERT (sizeof (ecma_stringbuilder_header_t) <= ECMA_ASCII_STRING_HEADER_SIZE,
        -:   58:                     ecma_stringbuilder_header_must_not_be_larger_than_ecma_ascii_string);
        -:   59:
        -:   60:/**
        -:   61: * Convert a string to an unsigned 32 bit value if possible
        -:   62: *
        -:   63: * @return true if the conversion is successful
        -:   64: *         false otherwise
        -:   65: */
        -:   66:static bool
    #####:   67:ecma_string_to_array_index (const lit_utf8_byte_t *string_p, /**< utf-8 string */
        -:   68:                            lit_utf8_size_t string_size, /**< string size */
        -:   69:                            uint32_t *result_p) /**< [out] converted value */
        -:   70:{
    #####:   71:  JERRY_ASSERT (string_size > 0 && *string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9);
        -:   72:
    #####:   73:  if (*string_p == LIT_CHAR_0)
        -:   74:  {
    #####:   75:    *result_p = 0;
    #####:   76:    return (string_size == 1);
        -:   77:  }
        -:   78:
    #####:   79:  if (string_size > ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)
        -:   80:  {
    #####:   81:    return false;
        -:   82:  }
        -:   83:
    #####:   84:  uint32_t index = 0;
    #####:   85:  const lit_utf8_byte_t *string_end_p = string_p + string_size;
        -:   86:
    #####:   87:  if (string_size == ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)
        -:   88:  {
    #####:   89:    string_end_p--;
        -:   90:  }
        -:   91:
        -:   92:  do
        -:   93:  {
    #####:   94:    if (*string_p > LIT_CHAR_9 || *string_p < LIT_CHAR_0)
        -:   95:    {
    #####:   96:      return false;
        -:   97:    }
        -:   98:
    #####:   99:    index = (index * 10) + (uint32_t) (*string_p++ - LIT_CHAR_0);
    #####:  100:  } while (string_p < string_end_p);
        -:  101:
    #####:  102:  if (string_size < ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)
        -:  103:  {
    #####:  104:    *result_p = index;
    #####:  105:    return true;
        -:  106:  }
        -:  107:
        -:  108:  /* Overflow must be checked as well when size is
        -:  109:   * equal to ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32. */
    #####:  110:  if (*string_p > LIT_CHAR_9 || *string_p < LIT_CHAR_0 || index > (UINT32_MAX / 10)
    #####:  111:      || (index == (UINT32_MAX / 10) && *string_p > LIT_CHAR_5))
        -:  112:  {
    #####:  113:    return false;
        -:  114:  }
        -:  115:
    #####:  116:  *result_p = (index * 10) + (uint32_t) (*string_p - LIT_CHAR_0);
    #####:  117:  return true;
        -:  118:} /* ecma_string_to_array_index */
        -:  119:
        -:  120:/**
        -:  121: * Returns the characters and size of a string.
        -:  122: *
        -:  123: * Note:
        -:  124: *   UINT type is not supported
        -:  125: *
        -:  126: * @return byte array start - if the byte array of a string is available
        -:  127: *         NULL - otherwise
        -:  128: */
        -:  129:static const lit_utf8_byte_t *
    #####:  130:ecma_string_get_chars_fast (const ecma_string_t *string_p, /**< ecma-string */
        -:  131:                            lit_utf8_size_t *size_p) /**< [out] size of the ecma string */
        -:  132:{
    #####:  133:  if (ECMA_IS_DIRECT_STRING (string_p))
        -:  134:  {
    #####:  135:    if (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC)
        -:  136:    {
    #####:  137:      uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -:  138:
    #####:  139:      if (id >= LIT_MAGIC_STRING__COUNT)
        -:  140:      {
    #####:  141:        id -= LIT_MAGIC_STRING__COUNT;
        -:  142:
    #####:  143:        *size_p = lit_get_magic_string_ex_size (id);
    #####:  144:        return lit_get_magic_string_ex_utf8 (id);
        -:  145:      }
        -:  146:
    #####:  147:      *size_p = lit_get_magic_string_size (id);
    #####:  148:      return lit_get_magic_string_utf8 (id);
        -:  149:    }
        -:  150:  }
        -:  151:
    #####:  152:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -:  153:
    #####:  154:  switch (ECMA_STRING_GET_CONTAINER (string_p))
        -:  155:  {
    #####:  156:    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -:  157:    {
    #####:  158:      *size_p = ((ecma_short_string_t *) string_p)->size;
    #####:  159:      return ECMA_SHORT_STRING_GET_BUFFER (string_p);
        -:  160:    }
    #####:  161:    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -:  162:    {
    #####:  163:      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
    #####:  164:      *size_p = long_string_p->size;
    #####:  165:      return long_string_p->string_p;
        -:  166:    }
    #####:  167:    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -:  168:    {
    #####:  169:      *size_p = ECMA_ASCII_STRING_GET_SIZE (string_p);
    #####:  170:      return ECMA_ASCII_STRING_GET_BUFFER (string_p);
        -:  171:    }
    #####:  172:    default:
        -:  173:    {
    #####:  174:      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -:  175:
    #####:  176:      lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
    #####:  177:      *size_p = lit_get_magic_string_ex_size (id);
    #####:  178:      return lit_get_magic_string_ex_utf8 (id);
        -:  179:    }
        -:  180:  }
        -:  181:} /* ecma_string_get_chars_fast */
        -:  182:
        -:  183:/**
        -:  184: * Allocate new ecma-string and fill it with reference to ECMA magic string
        -:  185: *
        -:  186: * @return pointer to ecma-string descriptor
        -:  187: */
        -:  188:static ecma_string_t *
    #####:  189:ecma_new_ecma_string_from_magic_string_ex_id (lit_magic_string_ex_id_t id) /**< identifier of externl magic string */
        -:  190:{
    #####:  191:  JERRY_ASSERT (id < lit_get_magic_string_ex_count ());
        -:  192:
    #####:  193:  uintptr_t string_id = (uintptr_t) (id + LIT_MAGIC_STRING__COUNT);
        -:  194:
    #####:  195:  if (JERRY_LIKELY (string_id <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  196:  {
    #####:  197:    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, string_id);
        -:  198:  }
        -:  199:
    #####:  200:  ecma_string_t *string_desc_p = ecma_alloc_string ();
        -:  201:
    #####:  202:  string_desc_p->refs_and_container = ECMA_STRING_CONTAINER_MAGIC_STRING_EX | ECMA_STRING_REF_ONE;
    #####:  203:  string_desc_p->u.magic_string_ex_id = id + LIT_MAGIC_STRING__COUNT;
        -:  204:
    #####:  205:  return string_desc_p;
        -:  206:} /* ecma_new_ecma_string_from_magic_string_ex_id */
        -:  207:
        -:  208:#if JERRY_ESNEXT
        -:  209:/**
        -:  210: * Allocate new ecma-string and fill it with reference to the symbol descriptor
        -:  211: *
        -:  212: * Note:
        -:  213: *     Takes the reference to the string_desc
        -:  214: *
        -:  215: * @return pointer to ecma-string descriptor
        -:  216: */
        -:  217:ecma_string_t *
    #####:  218:ecma_new_symbol_from_descriptor_string (ecma_value_t string_desc) /**< ecma-string */
        -:  219:{
    #####:  220:  JERRY_ASSERT (!ecma_is_value_symbol (string_desc));
        -:  221:
    #####:  222:  ecma_extended_string_t *symbol_p = ecma_alloc_extended_string ();
    #####:  223:  symbol_p->header.refs_and_container = ECMA_STRING_REF_ONE | ECMA_STRING_CONTAINER_SYMBOL;
    #####:  224:  symbol_p->u.symbol_descriptor = string_desc;
    #####:  225:  symbol_p->header.u.hash = (lit_string_hash_t) (((uintptr_t) symbol_p) & (uintptr_t) ~ECMA_SYMBOL_FLAGS_MASK);
        -:  226:
    #####:  227:  return (ecma_string_t *) symbol_p;
        -:  228:} /* ecma_new_symbol_from_descriptor_string */
        -:  229:
        -:  230:/**
        -:  231: * Check whether an ecma-string contains an ecma-symbol
        -:  232: *
        -:  233: * @return true - if the ecma-string contains an ecma-symbol
        -:  234: *         false - otherwise
        -:  235: */
        -:  236:bool
       28:  237:ecma_prop_name_is_symbol (ecma_string_t *string_p) /**< ecma-string */
        -:  238:{
       28:  239:  JERRY_ASSERT (string_p != NULL);
        -:  240:
       28:  241:  return (!ECMA_IS_DIRECT_STRING (string_p) && ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_SYMBOL);
        -:  242:} /* ecma_prop_name_is_symbol */
        -:  243:#endif /* JERRY_ESNEXT */
        -:  244:
        -:  245:/**
        -:  246: * Allocate new UTF8 ecma-string and fill it with characters from the given utf8 buffer
        -:  247: *
        -:  248: * @return pointer to ecma-string descriptor
        -:  249: */
        -:  250:static inline ecma_string_t *JERRY_ATTR_ALWAYS_INLINE
        -:  251:ecma_new_ecma_string_from_utf8_buffer (lit_utf8_size_t length, /**< length of the buffer */
        -:  252:                                       lit_utf8_size_t size, /**< size of the buffer */
        -:  253:                                       lit_utf8_byte_t **data_p) /**< [out] pointer to the start of the string buffer */
        -:  254:{
       10:  255:  if (JERRY_LIKELY (size <= UINT16_MAX))
        -:  256:  {
       10:  257:    if (JERRY_LIKELY (length == size) && size <= (UINT8_MAX + 1))
        -:  258:    {
        -:  259:      ecma_string_t *string_desc_p;
       10:  260:      string_desc_p = (ecma_string_t *) ecma_alloc_string_buffer (size + ECMA_ASCII_STRING_HEADER_SIZE);
       10:  261:      string_desc_p->refs_and_container = ECMA_STRING_CONTAINER_HEAP_ASCII_STRING | ECMA_STRING_REF_ONE;
       10:  262:      ECMA_ASCII_STRING_SET_SIZE (string_desc_p, size);
        -:  263:
       10:  264:      *data_p = ECMA_ASCII_STRING_GET_BUFFER (string_desc_p);
       10:  265:      return (ecma_string_t *) string_desc_p;
        -:  266:    }
        -:  267:
        -:  268:    ecma_short_string_t *string_desc_p;
    #####:  269:    string_desc_p = (ecma_short_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_short_string_t));
    #####:  270:    string_desc_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_UTF8_STRING | ECMA_STRING_REF_ONE;
    #####:  271:    string_desc_p->size = (uint16_t) size;
    #####:  272:    string_desc_p->length = (uint16_t) length;
        -:  273:
    #####:  274:    *data_p = ECMA_SHORT_STRING_GET_BUFFER (string_desc_p);
    #####:  275:    return (ecma_string_t *) string_desc_p;
        -:  276:  }
        -:  277:
        -:  278:  ecma_long_string_t *long_string_p;
    #####:  279:  long_string_p = (ecma_long_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_long_string_t));
    #####:  280:  long_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING | ECMA_STRING_REF_ONE;
    #####:  281:  long_string_p->string_p = ECMA_LONG_STRING_BUFFER_START (long_string_p);
    #####:  282:  long_string_p->size = size;
    #####:  283:  long_string_p->length = length;
        -:  284:
    #####:  285:  *data_p = ECMA_LONG_STRING_BUFFER_START (long_string_p);
    #####:  286:  return (ecma_string_t *) long_string_p;
        -:  287:} /* ecma_new_ecma_string_from_utf8_buffer */
        -:  288:
        -:  289:/**
        -:  290: * Checks whether a string has a special representation, that is, the string is either a magic string,
        -:  291: * an external magic string, or an uint32 number, and creates an ecma string using the special representation,
        -:  292: * if available.
        -:  293: *
        -:  294: * @return pointer to ecma string with the special representation
        -:  295: *         NULL, if there is no special representation for the string
        -:  296: */
        -:  297:static ecma_string_t *
       10:  298:ecma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */
        -:  299:                          lit_utf8_size_t string_size) /**< string size */
        -:  300:{
       10:  301:  JERRY_ASSERT (string_p != NULL || string_size == 0);
       10:  302:  lit_magic_string_id_t magic_string_id = lit_is_utf8_string_magic (string_p, string_size);
        -:  303:
       10:  304:  if (magic_string_id != LIT_MAGIC_STRING__COUNT)
        -:  305:  {
    #####:  306:    return ecma_get_magic_string (magic_string_id);
        -:  307:  }
        -:  308:
       10:  309:  JERRY_ASSERT (string_size > 0);
        -:  310:
       10:  311:  if (*string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9)
        -:  312:  {
    #####:  313:    uint32_t array_index;
        -:  314:
    #####:  315:    if (ecma_string_to_array_index (string_p, string_size, &array_index))
        -:  316:    {
    #####:  317:      return ecma_new_ecma_string_from_uint32 (array_index);
        -:  318:    }
        -:  319:  }
        -:  320:
       10:  321:  if (lit_get_magic_string_ex_count () > 0)
        -:  322:  {
    #####:  323:    lit_magic_string_ex_id_t magic_string_ex_id = lit_is_ex_utf8_string_magic (string_p, string_size);
        -:  324:
    #####:  325:    if (magic_string_ex_id < lit_get_magic_string_ex_count ())
        -:  326:    {
    #####:  327:      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);
        -:  328:    }
        -:  329:  }
        -:  330:
       10:  331:  return NULL;
        -:  332:} /* ecma_find_special_string */
        -:  333:
        -:  334:/**
        -:  335: * Allocate new ecma-string and fill it with characters from ascii characters
        -:  336: *
        -:  337: * @return pointer to ecma-string descriptor
        -:  338: */
        -:  339:ecma_string_t *
    #####:  340:ecma_new_ecma_string_from_ascii (const lit_utf8_byte_t *string_p, /**< ascii string */
        -:  341:                                 lit_utf8_size_t string_size) /**< string size */
        -:  342:{
    #####:  343:  JERRY_ASSERT (string_p != NULL || string_size == 0);
        -:  344:
    #####:  345:  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);
        -:  346:
    #####:  347:  if (string_desc_p != NULL)
        -:  348:  {
    #####:  349:    return string_desc_p;
        -:  350:  }
        -:  351:
    #####:  352:  lit_utf8_byte_t *data_p;
    #####:  353:  string_desc_p = ecma_new_ecma_string_from_utf8_buffer (string_size, string_size, &data_p);
        -:  354:
    #####:  355:  string_desc_p->u.hash = lit_utf8_string_calc_hash (string_p, string_size);
    #####:  356:  memcpy (data_p, string_p, string_size);
        -:  357:
    #####:  358:  return string_desc_p;
        -:  359:} /* ecma_new_ecma_string_from_ascii */
        -:  360:
        -:  361:/**
        -:  362: * Allocate new ecma-string and fill it with characters from the utf8 string
        -:  363: *
        -:  364: * @return pointer to ecma-string descriptor
        -:  365: */
        -:  366:ecma_string_t *
       10:  367:ecma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */
        -:  368:                                lit_utf8_size_t string_size) /**< string size */
        -:  369:{
       10:  370:  JERRY_ASSERT (string_p != NULL || string_size == 0);
       10:  371:  JERRY_ASSERT (lit_is_valid_cesu8_string (string_p, string_size));
        -:  372:
       10:  373:  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);
        -:  374:
       10:  375:  if (string_desc_p != NULL)
        -:  376:  {
    #####:  377:    return string_desc_p;
        -:  378:  }
        -:  379:
       10:  380:  lit_utf8_byte_t *data_p;
       10:  381:  string_desc_p =
       10:  382:    ecma_new_ecma_string_from_utf8_buffer (lit_utf8_string_length (string_p, string_size), string_size, &data_p);
        -:  383:
       10:  384:  string_desc_p->u.hash = lit_utf8_string_calc_hash (string_p, string_size);
       10:  385:  memcpy (data_p, string_p, string_size);
        -:  386:
       10:  387:  return string_desc_p;
        -:  388:} /* ecma_new_ecma_string_from_utf8 */
        -:  389:
        -:  390:/**
        -:  391: * Allocate a new ecma-string and initialize it from the utf8 string argument.
        -:  392: * All 4-bytes long unicode sequences are converted into two 3-bytes long sequences.
        -:  393: *
        -:  394: * @return pointer to ecma-string descriptor
        -:  395: */
        -:  396:ecma_string_t *
        1:  397:ecma_new_ecma_string_from_utf8_converted_to_cesu8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */
        -:  398:                                                   lit_utf8_size_t string_size) /**< utf-8 string size */
        -:  399:{
        1:  400:  JERRY_ASSERT (string_p != NULL || string_size == 0);
        -:  401:
        1:  402:  lit_utf8_size_t converted_string_length = 0;
        1:  403:  lit_utf8_size_t converted_string_size = 0;
        1:  404:  lit_utf8_size_t pos = 0;
        -:  405:
        -:  406:  /* Calculate the required length and size information of the converted cesu-8 encoded string */
       14:  407:  while (pos < string_size)
        -:  408:  {
       12:  409:    if ((string_p[pos] & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  410:    {
       12:  411:      pos++;
        -:  412:    }
    #####:  413:    else if ((string_p[pos] & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  414:    {
    #####:  415:      pos += 2;
        -:  416:    }
    #####:  417:    else if ((string_p[pos] & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  418:    {
    #####:  419:      pos += 3;
        -:  420:    }
        -:  421:    else
        -:  422:    {
    #####:  423:      JERRY_ASSERT ((string_p[pos] & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER);
    #####:  424:      pos += 4;
    #####:  425:      converted_string_size += 2;
    #####:  426:      converted_string_length++;
        -:  427:    }
        -:  428:
       12:  429:    converted_string_length++;
        -:  430:  }
        -:  431:
        1:  432:  JERRY_ASSERT (pos == string_size);
        -:  433:
        1:  434:  if (converted_string_size == 0)
        -:  435:  {
        1:  436:    return ecma_new_ecma_string_from_utf8 (string_p, string_size);
        -:  437:  }
        -:  438:
    #####:  439:  converted_string_size += string_size;
        -:  440:
    #####:  441:  JERRY_ASSERT (lit_is_valid_utf8_string (string_p, string_size, false));
        -:  442:
    #####:  443:  lit_utf8_byte_t *data_p;
    #####:  444:  ecma_string_t *string_desc_p =
        -:  445:    ecma_new_ecma_string_from_utf8_buffer (converted_string_length, converted_string_size, &data_p);
        -:  446:
    #####:  447:  const lit_utf8_byte_t *const begin_data_p = data_p;
    #####:  448:  pos = 0;
        -:  449:
    #####:  450:  while (pos < string_size)
        -:  451:  {
    #####:  452:    if ((string_p[pos] & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)
        -:  453:    {
        -:  454:      /* Processing 4 byte unicode sequence. Always converted to two 3 byte long sequence. */
    #####:  455:      lit_four_byte_utf8_char_to_cesu8 (data_p, string_p + pos);
    #####:  456:      data_p += 3 * 2;
    #####:  457:      pos += 4;
        -:  458:    }
        -:  459:    else
        -:  460:    {
    #####:  461:      *data_p++ = string_p[pos++];
        -:  462:    }
        -:  463:  }
        -:  464:
    #####:  465:  JERRY_ASSERT (pos == string_size);
        -:  466:
    #####:  467:  string_desc_p->u.hash = lit_utf8_string_calc_hash (begin_data_p, converted_string_size);
        -:  468:
    #####:  469:  return (ecma_string_t *) string_desc_p;
        -:  470:} /* ecma_new_ecma_string_from_utf8_converted_to_cesu8 */
        -:  471:
        -:  472:/**
        -:  473: * Allocate new ecma-external-string and fill it with characters from the cesu8 string
        -:  474: *
        -:  475: * @return pointer to ecma-string descriptor
        -:  476: */
        -:  477:ecma_string_t *
    #####:  478:ecma_new_ecma_external_string_from_cesu8 (const lit_utf8_byte_t *string_p, /**< cesu-8 string */
        -:  479:                                          lit_utf8_size_t string_size, /**< string size */
        -:  480:                                          void *user_p) /**< user pointer passed to the callback
        -:  481:                                                         *   when the string is freed */
        -:  482:{
    #####:  483:  JERRY_ASSERT (string_p != NULL || string_size == 0);
    #####:  484:  JERRY_ASSERT (lit_is_valid_cesu8_string (string_p, string_size));
        -:  485:
    #####:  486:  if (string_size < (sizeof (ecma_external_string_t) - sizeof (ecma_short_string_t)))
        -:  487:  {
        -:  488:    /* Normal strings are created for short strings. */
    #####:  489:    ecma_string_t *string_desc_p = ecma_new_ecma_string_from_utf8 (string_p, string_size);
        -:  490:
    #####:  491:    jerry_external_string_free_cb_t free_cb = JERRY_CONTEXT (external_string_free_callback_p);
        -:  492:
    #####:  493:    if (free_cb != NULL)
        -:  494:    {
    #####:  495:      free_cb ((lit_utf8_byte_t *) string_p, string_size, user_p);
        -:  496:    }
    #####:  497:    return string_desc_p;
        -:  498:  }
        -:  499:
    #####:  500:  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);
        -:  501:
    #####:  502:  if (string_desc_p != NULL)
        -:  503:  {
    #####:  504:    jerry_external_string_free_cb_t free_cb = JERRY_CONTEXT (external_string_free_callback_p);
        -:  505:
    #####:  506:    if (free_cb != NULL)
        -:  507:    {
    #####:  508:      free_cb ((lit_utf8_byte_t *) string_p, string_size, user_p);
        -:  509:    }
    #####:  510:    return string_desc_p;
        -:  511:  }
        -:  512:
    #####:  513:  ecma_external_string_t *external_string_p = ecma_alloc_external_string ();
    #####:  514:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) external_string_p;
        -:  515:
    #####:  516:  long_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING | ECMA_STRING_REF_ONE;
    #####:  517:  long_string_p->header.u.hash = lit_utf8_string_calc_hash (string_p, string_size);
    #####:  518:  long_string_p->string_p = string_p;
    #####:  519:  long_string_p->size = string_size;
    #####:  520:  long_string_p->length = lit_utf8_string_length (string_p, string_size);
    #####:  521:  external_string_p->user_p = user_p;
        -:  522:
    #####:  523:  return (ecma_string_t *) external_string_p;
        -:  524:} /* ecma_new_ecma_external_string_from_cesu8 */
        -:  525:
        -:  526:/**
        -:  527: * Allocate new ecma-string and fill it with cesu-8 character which represents specified code unit
        -:  528: *
        -:  529: * @return pointer to ecma-string descriptor
        -:  530: */
        -:  531:ecma_string_t *
    #####:  532:ecma_new_ecma_string_from_code_unit (ecma_char_t code_unit) /**< code unit */
        -:  533:{
    #####:  534:  lit_utf8_byte_t lit_utf8_bytes[LIT_UTF8_MAX_BYTES_IN_CODE_UNIT];
    #####:  535:  lit_utf8_size_t bytes_size = lit_code_unit_to_utf8 (code_unit, lit_utf8_bytes);
        -:  536:
    #####:  537:  return ecma_new_ecma_string_from_utf8 (lit_utf8_bytes, bytes_size);
        -:  538:} /* ecma_new_ecma_string_from_code_unit */
        -:  539:
        -:  540:#if JERRY_ESNEXT
        -:  541:
        -:  542:/**
        -:  543: * Allocate new ecma-string and fill it with cesu-8 character which represents specified code units
        -:  544: *
        -:  545: * @return pointer to ecma-string descriptor
        -:  546: */
        -:  547:ecma_string_t *
    #####:  548:ecma_new_ecma_string_from_code_units (ecma_char_t first_code_unit, /**< code unit */
        -:  549:                                      ecma_char_t second_code_unit) /**< code unit */
        -:  550:{
    #####:  551:  lit_utf8_byte_t lit_utf8_bytes[2 * LIT_UTF8_MAX_BYTES_IN_CODE_UNIT];
    #####:  552:  lit_utf8_size_t bytes_size = lit_code_unit_to_utf8 (first_code_unit, lit_utf8_bytes);
    #####:  553:  bytes_size += lit_code_unit_to_utf8 (second_code_unit, lit_utf8_bytes + bytes_size);
        -:  554:
    #####:  555:  return ecma_new_ecma_string_from_utf8 (lit_utf8_bytes, bytes_size);
        -:  556:} /* ecma_new_ecma_string_from_code_units */
        -:  557:
        -:  558:#endif /* JERRY_ESNEXT */
        -:  559:
        -:  560:/**
        -:  561: * Allocate new ecma-string and fill it with ecma-number
        -:  562: *
        -:  563: * Note: the number cannot be represented as direct string
        -:  564: *
        -:  565: * @return pointer to ecma-string descriptor
        -:  566: */
        -:  567:ecma_string_t *
    #####:  568:ecma_new_non_direct_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */
        -:  569:{
    #####:  570:  JERRY_ASSERT (uint32_number > ECMA_DIRECT_STRING_MAX_IMM);
        -:  571:
    #####:  572:  ecma_string_t *string_p = ecma_alloc_string ();
        -:  573:
    #####:  574:  string_p->refs_and_container = ECMA_STRING_CONTAINER_UINT32_IN_DESC | ECMA_STRING_REF_ONE;
    #####:  575:  string_p->u.uint32_number = uint32_number;
        -:  576:
    #####:  577:  return string_p;
        -:  578:} /* ecma_new_non_direct_string_from_uint32 */
        -:  579:
        -:  580:/**
        -:  581: * Allocate new ecma-string and fill it with property length number
        -:  582: *
        -:  583: * @return pointer to ecma-string descriptor
        -:  584: */
        -:  585:ecma_string_t *
    #####:  586:ecma_new_ecma_string_from_length (ecma_length_t number) /**< property length */
        -:  587:{
    #####:  588:  if (JERRY_LIKELY (number <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  589:  {
    #####:  590:    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) number);
        -:  591:  }
        -:  592:
        -:  593:#if JERRY_ESNEXT
    #####:  594:  JERRY_ASSERT ((ecma_number_t) number <= ECMA_NUMBER_MAX_SAFE_INTEGER);
        -:  595:
    #####:  596:  if (JERRY_UNLIKELY (number > UINT32_MAX))
        -:  597:  {
    #####:  598:    return ecma_new_ecma_string_from_number ((ecma_number_t) number);
        -:  599:  }
        -:  600:#endif /* JERRY_ESNEXT */
        -:  601:
    #####:  602:  return ecma_new_non_direct_string_from_uint32 ((uint32_t) number);
        -:  603:} /* ecma_new_ecma_string_from_length */
        -:  604:
        -:  605:/**
        -:  606: * Allocate new ecma-string and fill it with uint32 number
        -:  607: *
        -:  608: * @return pointer to ecma-string descriptor
        -:  609: */
        -:  610:ecma_string_t *
    #####:  611:ecma_new_ecma_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */
        -:  612:{
    #####:  613:  if (JERRY_LIKELY (uint32_number <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  614:  {
    #####:  615:    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) uint32_number);
        -:  616:  }
        -:  617:
    #####:  618:  return ecma_new_non_direct_string_from_uint32 (uint32_number);
        -:  619:} /* ecma_new_ecma_string_from_uint32 */
        -:  620:
        -:  621:/**
        -:  622: * Returns the constant assigned to the uint32 number.
        -:  623: *
        -:  624: * Note:
        -:  625: *   Calling ecma_deref_ecma_string on the returned pointer is optional.
        -:  626: *
        -:  627: * @return pointer to ecma-string descriptor
        -:  628: */
        -:  629:ecma_string_t *
    #####:  630:ecma_get_ecma_string_from_uint32 (uint32_t uint32_number) /**< input number */
        -:  631:{
    #####:  632:  JERRY_ASSERT (uint32_number <= ECMA_DIRECT_STRING_MAX_IMM);
        -:  633:
    #####:  634:  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) uint32_number);
        -:  635:} /* ecma_get_ecma_string_from_uint32 */
        -:  636:
        -:  637:/**
        -:  638: * Allocate new ecma-string and fill it with ecma-number
        -:  639: *
        -:  640: * @return pointer to ecma-string descriptor
        -:  641: */
        -:  642:ecma_string_t *
    #####:  643:ecma_new_ecma_string_from_number (ecma_number_t num) /**< ecma-number */
        -:  644:{
    #####:  645:  uint32_t uint32_num = ecma_number_to_uint32 (num);
    #####:  646:  if (num == ((ecma_number_t) uint32_num))
        -:  647:  {
    #####:  648:    return ecma_new_ecma_string_from_uint32 (uint32_num);
        -:  649:  }
        -:  650:
    #####:  651:  if (ecma_number_is_nan (num))
        -:  652:  {
    #####:  653:    return ecma_get_magic_string (LIT_MAGIC_STRING_NAN);
        -:  654:  }
        -:  655:
    #####:  656:  if (ecma_number_is_infinity (num))
        -:  657:  {
    #####:  658:    lit_magic_string_id_t id =
    #####:  659:      (ecma_number_is_negative (num) ? LIT_MAGIC_STRING_NEGATIVE_INFINITY_UL : LIT_MAGIC_STRING_INFINITY_UL);
    #####:  660:    return ecma_get_magic_string (id);
        -:  661:  }
        -:  662:
    #####:  663:  lit_utf8_byte_t str_buf[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
    #####:  664:  lit_utf8_size_t str_size = ecma_number_to_utf8_string (num, str_buf, sizeof (str_buf));
        -:  665:
    #####:  666:  JERRY_ASSERT (str_size > 0);
        -:  667:#ifndef JERRY_NDEBUG
    #####:  668:  JERRY_ASSERT (lit_is_utf8_string_magic (str_buf, str_size) == LIT_MAGIC_STRING__COUNT
        -:  669:                && lit_is_ex_utf8_string_magic (str_buf, str_size) == lit_get_magic_string_ex_count ());
        -:  670:#endif /* !JERRY_NDEBUG */
        -:  671:
    #####:  672:  lit_utf8_byte_t *data_p;
    #####:  673:  ecma_string_t *string_desc_p =
    #####:  674:    ecma_new_ecma_string_from_utf8_buffer (lit_utf8_string_length (str_buf, str_size), str_size, &data_p);
        -:  675:
    #####:  676:  string_desc_p->u.hash = lit_utf8_string_calc_hash (str_buf, str_size);
    #####:  677:  memcpy (data_p, str_buf, str_size);
        -:  678:
    #####:  679:  return string_desc_p;
        -:  680:} /* ecma_new_ecma_string_from_number */
        -:  681:
        -:  682:/**
        -:  683: * Returns the constant assigned to the magic string id.
        -:  684: *
        -:  685: * Note:
        -:  686: *   Calling ecma_deref_ecma_string on the returned pointer is optional.
        -:  687: *
        -:  688: * @return pointer to ecma-string descriptor
        -:  689: */
        -:  690:extern inline ecma_string_t *JERRY_ATTR_ALWAYS_INLINE
<<<<<<< HEAD
    11909:  691:ecma_get_magic_string (lit_magic_string_id_t id) /**< identifier of magic string */
        -:  692:{
    11912:  693:  JERRY_ASSERT (id < LIT_MAGIC_STRING__COUNT);
    11912:  694:  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);
=======
    11911:  691:ecma_get_magic_string (lit_magic_string_id_t id) /**< identifier of magic string */
        -:  692:{
    11914:  693:  JERRY_ASSERT (id < LIT_MAGIC_STRING__COUNT);
    11914:  694:  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);
>>>>>>> a21cade7a7dbd62c58f835b59aec4a2edcb34875
        -:  695:} /* ecma_get_magic_string */
        -:  696:
        -:  697:/**
        -:  698: * Returns the constant assigned to the internal magic string id.
        -:  699: *
        -:  700: * Note:
        -:  701: *   Calling ecma_deref_ecma_string on the returned pointer is optional.
        -:  702: *
        -:  703: * @return pointer to ecma-string descriptor
        -:  704: */
        -:  705:extern inline ecma_string_t *JERRY_ATTR_ALWAYS_INLINE
    #####:  706:ecma_get_internal_string (lit_magic_string_id_t id) /**< identifier of magic string */
        -:  707:{
    #####:  708:  JERRY_ASSERT (id >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT && id < LIT_MAGIC_STRING__COUNT);
    #####:  709:  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_SPECIAL, (uintptr_t) id);
        -:  710:} /* ecma_get_internal_string */
        -:  711:
        -:  712:/**
        -:  713: * Append a cesu8 string after an ecma-string
        -:  714: *
        -:  715: * Note:
        -:  716: *   The string1_p argument is freed. If it needs to be preserved,
        -:  717: *   call ecma_ref_ecma_string with string1_p before the call.
        -:  718: *
        -:  719: * @return concatenation of an ecma-string and a cesu8 string
        -:  720: */
        -:  721:ecma_string_t *
    #####:  722:ecma_append_chars_to_string (ecma_string_t *string1_p, /**< base ecma-string */
        -:  723:                             const lit_utf8_byte_t *cesu8_string2_p, /**< characters to be appended */
        -:  724:                             lit_utf8_size_t cesu8_string2_size, /**< byte size of cesu8_string2_p */
        -:  725:                             lit_utf8_size_t cesu8_string2_length) /**< character length of cesu8_string2_p */
        -:  726:{
    #####:  727:  JERRY_ASSERT (string1_p != NULL && cesu8_string2_size > 0 && cesu8_string2_length > 0);
        -:  728:
    #####:  729:  if (JERRY_UNLIKELY (ecma_string_is_empty (string1_p)))
        -:  730:  {
    #####:  731:    return ecma_new_ecma_string_from_utf8 (cesu8_string2_p, cesu8_string2_size);
        -:  732:  }
        -:  733:
    #####:  734:  lit_utf8_size_t cesu8_string1_size;
    #####:  735:  lit_utf8_size_t cesu8_string1_length;
    #####:  736:  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  737:  lit_utf8_byte_t uint32_to_string_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
        -:  738:
    #####:  739:  const lit_utf8_byte_t *cesu8_string1_p =
        -:  740:    ecma_string_get_chars (string1_p, &cesu8_string1_size, &cesu8_string1_length, uint32_to_string_buffer, &flags);
        -:  741:
    #####:  742:  JERRY_ASSERT (!(flags & ECMA_STRING_FLAG_MUST_BE_FREED));
    #####:  743:  JERRY_ASSERT (cesu8_string1_length > 0);
    #####:  744:  JERRY_ASSERT (cesu8_string1_length <= cesu8_string1_size);
        -:  745:
    #####:  746:  lit_utf8_size_t new_size = cesu8_string1_size + cesu8_string2_size;
        -:  747:
        -:  748:  /* Poor man's carry flag check: it is impossible to allocate this large string. */
    #####:  749:  if (new_size < (cesu8_string1_size | cesu8_string2_size))
        -:  750:  {
    #####:  751:    jerry_fatal (ERR_OUT_OF_MEMORY);
        -:  752:  }
        -:  753:
        -:  754:  lit_magic_string_id_t magic_string_id;
    #####:  755:  magic_string_id =
    #####:  756:    lit_is_utf8_string_pair_magic (cesu8_string1_p, cesu8_string1_size, cesu8_string2_p, cesu8_string2_size);
        -:  757:
    #####:  758:  if (magic_string_id != LIT_MAGIC_STRING__COUNT)
        -:  759:  {
    #####:  760:    ecma_deref_ecma_string (string1_p);
    #####:  761:    return ecma_get_magic_string (magic_string_id);
        -:  762:  }
        -:  763:
    #####:  764:  if ((flags & ECMA_STRING_FLAG_IS_UINT32) && new_size <= ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)
        -:  765:  {
    #####:  766:    memcpy (uint32_to_string_buffer + cesu8_string1_size, cesu8_string2_p, cesu8_string2_size);
        -:  767:
    #####:  768:    uint32_t array_index;
        -:  769:
    #####:  770:    if (ecma_string_to_array_index (uint32_to_string_buffer, new_size, &array_index))
        -:  771:    {
    #####:  772:      ecma_deref_ecma_string (string1_p);
    #####:  773:      return ecma_new_ecma_string_from_uint32 (array_index);
        -:  774:    }
        -:  775:  }
        -:  776:
    #####:  777:  if (lit_get_magic_string_ex_count () > 0)
        -:  778:  {
        -:  779:    lit_magic_string_ex_id_t magic_string_ex_id;
    #####:  780:    magic_string_ex_id =
    #####:  781:      lit_is_ex_utf8_string_pair_magic (cesu8_string1_p, cesu8_string1_size, cesu8_string2_p, cesu8_string2_size);
        -:  782:
    #####:  783:    if (magic_string_ex_id < lit_get_magic_string_ex_count ())
        -:  784:    {
    #####:  785:      ecma_deref_ecma_string (string1_p);
    #####:  786:      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);
        -:  787:    }
        -:  788:  }
        -:  789:
    #####:  790:  lit_utf8_byte_t *data_p;
    #####:  791:  ecma_string_t *string_desc_p =
    #####:  792:    ecma_new_ecma_string_from_utf8_buffer (cesu8_string1_length + cesu8_string2_length, new_size, &data_p);
        -:  793:
        -:  794:  lit_string_hash_t hash_start;
        -:  795:
    #####:  796:  if (JERRY_UNLIKELY (flags & ECMA_STRING_FLAG_REHASH_NEEDED))
        -:  797:  {
    #####:  798:    hash_start = lit_utf8_string_calc_hash (cesu8_string1_p, cesu8_string1_size);
        -:  799:  }
        -:  800:  else
        -:  801:  {
    #####:  802:    JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string1_p));
    #####:  803:    hash_start = string1_p->u.hash;
        -:  804:  }
        -:  805:
    #####:  806:  string_desc_p->u.hash = lit_utf8_string_hash_combine (hash_start, cesu8_string2_p, cesu8_string2_size);
        -:  807:
    #####:  808:  memcpy (data_p, cesu8_string1_p, cesu8_string1_size);
    #####:  809:  memcpy (data_p + cesu8_string1_size, cesu8_string2_p, cesu8_string2_size);
        -:  810:
    #####:  811:  ecma_deref_ecma_string (string1_p);
    #####:  812:  return (ecma_string_t *) string_desc_p;
        -:  813:} /* ecma_append_chars_to_string */
        -:  814:
        -:  815:/**
        -:  816: * Concatenate ecma-strings
        -:  817: *
        -:  818: * Note:
        -:  819: *   The string1_p argument is freed. If it needs to be preserved,
        -:  820: *   call ecma_ref_ecma_string with string1_p before the call.
        -:  821: *
        -:  822: * @return concatenation of two ecma-strings
        -:  823: */
        -:  824:ecma_string_t *
    #####:  825:ecma_concat_ecma_strings (ecma_string_t *string1_p, /**< first ecma-string */
        -:  826:                          ecma_string_t *string2_p) /**< second ecma-string */
        -:  827:{
    #####:  828:  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);
        -:  829:
    #####:  830:  if (JERRY_UNLIKELY (ecma_string_is_empty (string1_p)))
        -:  831:  {
    #####:  832:    ecma_ref_ecma_string (string2_p);
    #####:  833:    return string2_p;
        -:  834:  }
    #####:  835:  else if (JERRY_UNLIKELY (ecma_string_is_empty (string2_p)))
        -:  836:  {
    #####:  837:    return string1_p;
        -:  838:  }
        -:  839:
    #####:  840:  lit_utf8_size_t cesu8_string2_size;
    #####:  841:  lit_utf8_size_t cesu8_string2_length;
    #####:  842:  lit_utf8_byte_t uint32_to_string_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
    #####:  843:  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;
        -:  844:
    #####:  845:  const lit_utf8_byte_t *cesu8_string2_p =
        -:  846:    ecma_string_get_chars (string2_p, &cesu8_string2_size, &cesu8_string2_length, uint32_to_string_buffer, &flags);
        -:  847:
    #####:  848:  JERRY_ASSERT (cesu8_string2_p != NULL);
        -:  849:
    #####:  850:  ecma_string_t *result_p =
    #####:  851:    ecma_append_chars_to_string (string1_p, cesu8_string2_p, cesu8_string2_size, cesu8_string2_length);
        -:  852:
    #####:  853:  JERRY_ASSERT (!(flags & ECMA_STRING_FLAG_MUST_BE_FREED));
        -:  854:
    #####:  855:  return result_p;
        -:  856:} /* ecma_concat_ecma_strings */
        -:  857:
        -:  858:/**
        -:  859: * Increase reference counter of non-direct ecma-string.
        -:  860: */
        -:  861:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  862:ecma_ref_ecma_string_non_direct (ecma_string_t *string_p) /**< string descriptor */
        -:  863:{
        7:  864:  JERRY_ASSERT (string_p != NULL);
        7:  865:  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));
        -:  866:
        -:  867:#ifdef JERRY_NDEBUG
    #####:  868:  if (ECMA_STRING_IS_STATIC (string_p))
        -:  869:  {
        -:  870:    return;
        -:  871:  }
        -:  872:#endif /* JERRY_NDEBUG */
        -:  873:
        7:  874:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -:  875:
        7:  876:  if (JERRY_LIKELY (string_p->refs_and_container < ECMA_STRING_MAX_REF))
        -:  877:  {
        -:  878:    /* Increase reference counter. */
        7:  879:    string_p->refs_and_container += ECMA_STRING_REF_ONE;
        -:  880:  }
        -:  881:  else
        -:  882:  {
    #####:  883:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -:  884:  }
    #####:  885:} /* ecma_ref_ecma_string_non_direct */
        -:  886:
        -:  887:/**
        -:  888: * Increase reference counter of ecma-string.
        -:  889: */
        -:  890:void
        7:  891:ecma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */
        -:  892:{
        7:  893:  JERRY_ASSERT (string_p != NULL);
        -:  894:
        7:  895:  if (ECMA_IS_DIRECT_STRING (string_p))
        -:  896:  {
    #####:  897:    return;
        -:  898:  }
        -:  899:
        -:  900:  ecma_ref_ecma_string_non_direct (string_p);
        -:  901:} /* ecma_ref_ecma_string */
        -:  902:
        -:  903:/**
        -:  904: * Decrease reference counter and deallocate a non-direct ecma-string
        -:  905: * if the counter becomes zero.
        -:  906: */
        -:  907:extern inline void JERRY_ATTR_ALWAYS_INLINE
        6:  908:ecma_deref_ecma_string_non_direct (ecma_string_t *string_p) /**< ecma-string */
        -:  909:{
        8:  910:  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));
        -:  911:
        -:  912:#ifdef JERRY_NDEBUG
    #####:  913:  if (ECMA_STRING_IS_STATIC (string_p))
        -:  914:  {
        -:  915:    return;
        -:  916:  }
        -:  917:#endif /* JERRY_NDEBUG */
        -:  918:
        8:  919:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -:  920:
        -:  921:  /* Decrease reference counter. */
        8:  922:  string_p->refs_and_container -= ECMA_STRING_REF_ONE;
        -:  923:
        8:  924:  if (string_p->refs_and_container >= ECMA_STRING_REF_ONE)
        -:  925:  {
        6:  926:    return;
        -:  927:  }
        -:  928:
        2:  929:  ecma_destroy_ecma_string (string_p);
        -:  930:} /* ecma_deref_ecma_string_non_direct */
        -:  931:
        -:  932:/**
        -:  933: * Decrease reference counter and deallocate ecma-string
        -:  934: * if the counter becomes zero.
        -:  935: */
        -:  936:void
        2:  937:ecma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */
        -:  938:{
        2:  939:  JERRY_ASSERT (string_p != NULL);
        -:  940:
        2:  941:  if (ECMA_IS_DIRECT_STRING (string_p))
        -:  942:  {
    #####:  943:    return;
        -:  944:  }
        -:  945:
        -:  946:  ecma_deref_ecma_string_non_direct (string_p);
        -:  947:} /* ecma_deref_ecma_string */
        -:  948:
        -:  949:/**
        -:  950: * Deallocate an ecma-string
        -:  951: */
        -:  952:void
        2:  953:ecma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */
        -:  954:{
        2:  955:  JERRY_ASSERT (string_p != NULL);
        2:  956:  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));
        2:  957:  JERRY_ASSERT ((string_p->refs_and_container < ECMA_STRING_REF_ONE) || ECMA_STRING_IS_STATIC (string_p));
        -:  958:
        2:  959:  switch (ECMA_STRING_GET_CONTAINER (string_p))
        -:  960:  {
    #####:  961:    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -:  962:    {
    #####:  963:      ecma_dealloc_string_buffer (string_p, ((ecma_short_string_t *) string_p)->size + sizeof (ecma_short_string_t));
    #####:  964:      return;
        -:  965:    }
    #####:  966:    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -:  967:    {
    #####:  968:      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -:  969:
    #####:  970:      if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))
        -:  971:      {
    #####:  972:        ecma_dealloc_string_buffer (string_p, long_string_p->size + sizeof (ecma_long_string_t));
    #####:  973:        return;
        -:  974:      }
        -:  975:
    #####:  976:      ecma_external_string_t *external_string_p = (ecma_external_string_t *) string_p;
    #####:  977:      jerry_external_string_free_cb_t free_cb = JERRY_CONTEXT (external_string_free_callback_p);
        -:  978:
    #####:  979:      if (free_cb != NULL)
        -:  980:      {
    #####:  981:        free_cb ((lit_utf8_byte_t *) external_string_p->header.string_p,
        -:  982:                 external_string_p->header.size,
        -:  983:                 external_string_p->user_p);
        -:  984:      }
        -:  985:
    #####:  986:      ecma_dealloc_external_string (external_string_p);
    #####:  987:      return;
        -:  988:    }
        2:  989:    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -:  990:    {
        2:  991:      ecma_dealloc_string_buffer (string_p, ECMA_ASCII_STRING_GET_SIZE (string_p) + ECMA_ASCII_STRING_HEADER_SIZE);
        2:  992:      return;
        -:  993:    }
        -:  994:#if JERRY_ESNEXT
    #####:  995:    case ECMA_STRING_CONTAINER_SYMBOL:
        -:  996:    {
    #####:  997:      ecma_extended_string_t *symbol_p = (ecma_extended_string_t *) string_p;
    #####:  998:      ecma_free_value (symbol_p->u.symbol_descriptor);
    #####:  999:      ecma_dealloc_extended_string (symbol_p);
    #####: 1000:      return;
        -: 1001:    }
        -: 1002:#endif /* JERRY_ESNEXT */
    #####: 1003:    default:
        -: 1004:    {
    #####: 1005:      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC
        -: 1006:                    || ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 1007:
        -: 1008:      /* only the string descriptor itself should be freed */
    #####: 1009:      ecma_dealloc_string (string_p);
        -: 1010:    }
        -: 1011:  }
        -: 1012:} /* ecma_destroy_ecma_string */
        -: 1013:
        -: 1014:/**
        -: 1015: * Convert ecma-string to number
        -: 1016: *
        -: 1017: * @return converted ecma-number
        -: 1018: */
        -: 1019:ecma_number_t
    #####: 1020:ecma_string_to_number (const ecma_string_t *string_p) /**< ecma-string */
        -: 1021:{
    #####: 1022:  JERRY_ASSERT (string_p != NULL);
        -: 1023:
    #####: 1024:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1025:  {
    #####: 1026:    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_UINT))
        -: 1027:    {
    #####: 1028:      return (ecma_number_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 1029:    }
        -: 1030:  }
    #####: 1031:  else if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1032:  {
    #####: 1033:    return ((ecma_number_t) string_p->u.uint32_number);
        -: 1034:  }
        -: 1035:
    #####: 1036:  lit_utf8_size_t size;
    #####: 1037:  const lit_utf8_byte_t *chars_p = ecma_string_get_chars_fast (string_p, &size);
        -: 1038:
    #####: 1039:  JERRY_ASSERT (chars_p != NULL);
        -: 1040:
    #####: 1041:  if (size == 0)
        -: 1042:  {
    #####: 1043:    return ECMA_NUMBER_ZERO;
        -: 1044:  }
        -: 1045:
    #####: 1046:  return ecma_utf8_string_to_number (chars_p, size, 0);
        -: 1047:} /* ecma_string_to_number */
        -: 1048:
        -: 1049:/**
        -: 1050: * Check if string is array index.
        -: 1051: *
        -: 1052: * @return ECMA_STRING_NOT_ARRAY_INDEX if string is not array index
        -: 1053: *         the array index otherwise
        -: 1054: */
        -: 1055:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
        5: 1056:ecma_string_get_array_index (const ecma_string_t *str_p) /**< ecma-string */
        -: 1057:{
        5: 1058:  if (ECMA_IS_DIRECT_STRING (str_p))
        -: 1059:  {
    #####: 1060:    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (str_p, ECMA_DIRECT_STRING_UINT))
        -: 1061:    {
        -: 1062:      /* Value cannot be equal to the maximum value of a 32 bit unsigned number. */
    #####: 1063:      return (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (str_p);
        -: 1064:    }
        -: 1065:
    #####: 1066:    return ECMA_STRING_NOT_ARRAY_INDEX;
        -: 1067:  }
        -: 1068:
        5: 1069:  if (ECMA_STRING_GET_CONTAINER (str_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1070:  {
        -: 1071:    /* When the uint32_number is equal to the maximum value of 32 bit unsigned integer number,
        -: 1072:     * it is also an invalid array index. The comparison to ECMA_STRING_NOT_ARRAY_INDEX will
        -: 1073:     * be true in this case. */
    #####: 1074:    return str_p->u.uint32_number;
        -: 1075:  }
        -: 1076:
        5: 1077:  return ECMA_STRING_NOT_ARRAY_INDEX;
        -: 1078:} /* ecma_string_get_array_index */
        -: 1079:
        -: 1080:/**
        -: 1081: * Copy digits of uint32 number, truncating if buffer is not large enough.
        -: 1082: *
        -: 1083: * @return number of digits copied
        -: 1084: */
        -: 1085:static lit_utf8_size_t
    #####: 1086:ecma_uint32_to_buffer (uint32_t num, /**< number */
        -: 1087:                       lit_utf8_byte_t *buffer_p /**< destination buffer */,
        -: 1088:                       lit_utf8_size_t buffer_size /**< buffer size */)
        -: 1089:{
    #####: 1090:  lit_utf8_byte_t digits[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
    #####: 1091:  lit_utf8_size_t digit_count = ecma_uint32_to_utf8_string (num, digits, ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
        -: 1092:
    #####: 1093:  digit_count = JERRY_MIN (buffer_size, digit_count);
    #####: 1094:  memcpy (buffer_p, digits, digit_count);
    #####: 1095:  return digit_count;
        -: 1096:} /* ecma_uint32_to_buffer */
        -: 1097:
        -: 1098:/**
        -: 1099: * Convert ecma-string's contents to the specified encoding and copy it to the buffer.
        -: 1100: * String data will be truncated to fit the buffer.
        -: 1101: *
        -: 1102: * @return number of bytes copied to the buffer.
        -: 1103: */
        -: 1104:lit_utf8_size_t JERRY_ATTR_WARN_UNUSED_RESULT
    #####: 1105:ecma_string_copy_to_buffer (const ecma_string_t *string_p, /**< ecma-string descriptor */
        -: 1106:                            lit_utf8_byte_t *buffer_p, /**< destination buffer pointer
        -: 1107:                                                        * (can be NULL if buffer_size == 0) */
        -: 1108:                            lit_utf8_size_t buffer_size, /**< size of buffer */
        -: 1109:                            jerry_encoding_t encoding) /**< encoding */
        -: 1110:{
    #####: 1111:  JERRY_ASSERT (string_p != NULL);
    #####: 1112:  JERRY_ASSERT (buffer_p != NULL || buffer_size == 0);
        -: 1113:
    #####: 1114:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1115:  {
    #####: 1116:    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_UINT))
        -: 1117:    {
    #####: 1118:      return ecma_uint32_to_buffer ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p), buffer_p, buffer_size);
        -: 1119:    }
        -: 1120:  }
        -: 1121:  else
        -: 1122:  {
    #####: 1123:    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1124:
    #####: 1125:    if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1126:    {
    #####: 1127:      return ecma_uint32_to_buffer (string_p->u.uint32_number, buffer_p, buffer_size);
        -: 1128:    }
        -: 1129:  }
        -: 1130:
    #####: 1131:  lit_utf8_size_t string_size;
    #####: 1132:  const lit_utf8_byte_t *chars_p = ecma_string_get_chars_fast (string_p, &string_size);
    #####: 1133:  lit_utf8_size_t copy_size = 0;
        -: 1134:
    #####: 1135:  JERRY_ASSERT (chars_p != NULL);
        -: 1136:
    #####: 1137:  switch (encoding)
        -: 1138:  {
    #####: 1139:    case JERRY_ENCODING_CESU8:
        -: 1140:    {
    #####: 1141:      copy_size = JERRY_MIN (string_size, buffer_size);
        -: 1142:
    #####: 1143:      if (copy_size < string_size)
        -: 1144:      {
        -: 1145:        /* Do not copy partial characters */
    #####: 1146:        while ((chars_p[copy_size] & LIT_UTF8_EXTRA_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER)
        -: 1147:        {
    #####: 1148:          copy_size--;
        -: 1149:        }
        -: 1150:      }
        -: 1151:
    #####: 1152:      memcpy (buffer_p, chars_p, copy_size);
    #####: 1153:      break;
        -: 1154:    }
    #####: 1155:    case JERRY_ENCODING_UTF8:
        -: 1156:    {
    #####: 1157:      if (string_size == ecma_string_get_length (string_p))
        -: 1158:      {
    #####: 1159:        copy_size = JERRY_MIN (string_size, buffer_size);
        -: 1160:
    #####: 1161:        memcpy (buffer_p, chars_p, copy_size);
    #####: 1162:        break;
        -: 1163:      }
        -: 1164:
    #####: 1165:      copy_size = lit_convert_cesu8_string_to_utf8_string (chars_p, string_size, buffer_p, buffer_size);
    #####: 1166:      break;
        -: 1167:    }
    #####: 1168:    default:
        -: 1169:    {
    #####: 1170:      break;
        -: 1171:    }
        -: 1172:  }
        -: 1173:
    #####: 1174:  return copy_size;
        -: 1175:} /* ecma_string_copy_to_buffer */
        -: 1176:
        -: 1177:/**
        -: 1178: * Convert ecma-string's contents to a cesu-8 string and put it to the buffer.
        -: 1179: * It is the caller's responsibility to make sure that the string fits in the buffer.
        -: 1180: * Check if the size of the string is equal with the size of the buffer.
        -: 1181: */
        -: 1182:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1183:ecma_string_to_cesu8_bytes (const ecma_string_t *string_desc_p, /**< ecma-string descriptor */
        -: 1184:                            lit_utf8_byte_t *buffer_p, /**< destination buffer pointer
        -: 1185:                                                        * (can be NULL if buffer_size == 0) */
        -: 1186:                            lit_utf8_size_t buffer_size) /**< size of buffer */
        -: 1187:{
    #####: 1188:  const lit_utf8_size_t size = ecma_string_copy_to_buffer (string_desc_p, buffer_p, buffer_size, JERRY_ENCODING_CESU8);
    #####: 1189:  JERRY_ASSERT (size == buffer_size);
    #####: 1190:} /* ecma_string_to_cesu8_bytes */
        -: 1191:
        -: 1192:/**
        -: 1193: * Get size of the uint32 number stored locally in the string's descriptor
        -: 1194: *
        -: 1195: * Note: the represented number size and length are equal
        -: 1196: *
        -: 1197: * @return size in bytes
        -: 1198: */
        -: 1199:static inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
        -: 1200:ecma_string_get_uint32_size (const uint32_t uint32_number) /**< number in the string-descriptor */
        -: 1201:{
    #####: 1202:  uint32_t prev_number = 1;
    #####: 1203:  uint32_t next_number = 100;
    #####: 1204:  lit_utf8_size_t size = 1;
        -: 1205:
    #####: 1206:  const uint32_t max_size = 9;
        -: 1207:
    #####: 1208:  while (size < max_size && uint32_number >= next_number)
        -: 1209:  {
    #####: 1210:    prev_number = next_number;
    #####: 1211:    next_number *= 100;
    #####: 1212:    size += 2;
        -: 1213:  }
        -: 1214:
    #####: 1215:  if (uint32_number >= prev_number * 10)
        -: 1216:  {
    #####: 1217:    size++;
        -: 1218:  }
        -: 1219:
    #####: 1220:  return size;
        -: 1221:} /* ecma_string_get_uint32_size */
        -: 1222:
        -: 1223:/**
        -: 1224: * Checks whether the given string is a sequence of ascii characters.
        -: 1225: */
        -: 1226:#define ECMA_STRING_IS_ASCII(char_p, size) ((size) == lit_utf8_string_length ((char_p), (size)))
        -: 1227:
        -: 1228:/**
        -: 1229: * Returns with the cesu8 character array of a string.
        -: 1230: *
        -: 1231: * Note:
        -: 1232: *   - This function returns with a newly allocated buffer for uint32 strings,
        -: 1233: *     which must be freed if the optional uint32_buff_p parameter is NULL.
        -: 1234: *   - The ASCII check only happens if the flags parameter gets
        -: 1235: *     'ECMA_STRING_FLAG_IS_ASCII' as an input.
        -: 1236: *
        -: 1237: * @return start of cesu8 characters
        -: 1238: */
        -: 1239:const lit_utf8_byte_t *
    #####: 1240:ecma_string_get_chars (const ecma_string_t *string_p, /**< ecma-string */
        -: 1241:                       lit_utf8_size_t *size_p, /**< [out] size of the ecma string */
        -: 1242:                       lit_utf8_size_t *length_p, /**< [out] optional argument. If the pointer is not NULL the pointed
        -: 1243:                                                   *    memory area is filled with the length of the ecma string */
        -: 1244:                       lit_utf8_byte_t *uint32_buff_p, /**< [out] optional argument. If the pointer is not NULL the
        -: 1245:                                                        *    pointed memory area is filled with the string converted
        -: 1246:                                                        *    uint32 string descriptor */
        -: 1247:                       uint8_t *flags_p) /**< [in,out] any combination of ecma_string_flag_t bits */
        -: 1248:{
        -: 1249:  lit_utf8_size_t length;
        -: 1250:  lit_utf8_size_t size;
        -: 1251:  const lit_utf8_byte_t *result_p;
        -: 1252:
    #####: 1253:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1254:  {
    #####: 1255:    *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;
        -: 1256:
    #####: 1257:    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))
        -: 1258:    {
    #####: 1259:      case ECMA_DIRECT_STRING_MAGIC:
        -: 1260:      {
    #####: 1261:        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 1262:
    #####: 1263:        if (id >= LIT_MAGIC_STRING__COUNT)
        -: 1264:        {
    #####: 1265:          id -= LIT_MAGIC_STRING__COUNT;
    #####: 1266:          size = lit_get_magic_string_ex_size (id);
    #####: 1267:          result_p = lit_get_magic_string_ex_utf8 (id);
    #####: 1268:          length = 0;
        -: 1269:
    #####: 1270:          if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))
        -: 1271:          {
    #####: 1272:            length = lit_utf8_string_length (result_p, size);
        -: 1273:          }
        -: 1274:        }
        -: 1275:        else
        -: 1276:        {
    #####: 1277:          size = lit_get_magic_string_size (id);
    #####: 1278:          length = size;
        -: 1279:
    #####: 1280:          result_p = lit_get_magic_string_utf8 (id);
        -: 1281:
        -: 1282:          /* All magic strings must be ascii strings. */
    #####: 1283:          JERRY_ASSERT (ECMA_STRING_IS_ASCII (result_p, size));
        -: 1284:        }
    #####: 1285:        break;
        -: 1286:      }
    #####: 1287:      default:
        -: 1288:      {
    #####: 1289:        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);
    #####: 1290:        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
    #####: 1291:        size = (lit_utf8_size_t) ecma_string_get_uint32_size (uint32_number);
        -: 1292:
    #####: 1293:        if (uint32_buff_p != NULL)
        -: 1294:        {
    #####: 1295:          result_p = uint32_buff_p;
        -: 1296:        }
        -: 1297:        else
        -: 1298:        {
    #####: 1299:          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);
    #####: 1300:          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;
        -: 1301:        }
        -: 1302:
    #####: 1303:        length = ecma_uint32_to_utf8_string (uint32_number, (lit_utf8_byte_t *) result_p, size);
        -: 1304:
    #####: 1305:        JERRY_ASSERT (length == size);
    #####: 1306:        *flags_p |= ECMA_STRING_FLAG_IS_UINT32;
    #####: 1307:        break;
        -: 1308:      }
        -: 1309:    }
        -: 1310:  }
        -: 1311:  else
        -: 1312:  {
    #####: 1313:    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1314:
    #####: 1315:    switch (ECMA_STRING_GET_CONTAINER (string_p))
        -: 1316:    {
    #####: 1317:      case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -: 1318:      {
    #####: 1319:        ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 1320:        size = short_string_p->size;
    #####: 1321:        length = short_string_p->length;
    #####: 1322:        result_p = ECMA_SHORT_STRING_GET_BUFFER (short_string_p);
    #####: 1323:        break;
        -: 1324:      }
    #####: 1325:      case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -: 1326:      {
    #####: 1327:        ecma_long_string_t *long_string_desc_p = (ecma_long_string_t *) string_p;
    #####: 1328:        size = long_string_desc_p->size;
    #####: 1329:        length = long_string_desc_p->length;
    #####: 1330:        result_p = long_string_desc_p->string_p;
    #####: 1331:        break;
        -: 1332:      }
    #####: 1333:      case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -: 1334:      {
    #####: 1335:        size = ECMA_ASCII_STRING_GET_SIZE (string_p);
    #####: 1336:        length = size;
    #####: 1337:        result_p = ECMA_ASCII_STRING_GET_BUFFER (string_p);
    #####: 1338:        break;
        -: 1339:      }
    #####: 1340:      case ECMA_STRING_CONTAINER_UINT32_IN_DESC:
        -: 1341:      {
    #####: 1342:        size = (lit_utf8_size_t) ecma_string_get_uint32_size (string_p->u.uint32_number);
        -: 1343:
    #####: 1344:        if (uint32_buff_p != NULL)
        -: 1345:        {
    #####: 1346:          result_p = uint32_buff_p;
        -: 1347:        }
        -: 1348:        else
        -: 1349:        {
    #####: 1350:          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);
    #####: 1351:          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;
        -: 1352:        }
        -: 1353:
    #####: 1354:        length = ecma_uint32_to_utf8_string (string_p->u.uint32_number, (lit_utf8_byte_t *) result_p, size);
        -: 1355:
    #####: 1356:        JERRY_ASSERT (length == size);
    #####: 1357:        *flags_p |= ECMA_STRING_FLAG_IS_UINT32 | ECMA_STRING_FLAG_REHASH_NEEDED;
    #####: 1358:        break;
        -: 1359:      }
    #####: 1360:      default:
        -: 1361:      {
    #####: 1362:        JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 1363:
    #####: 1364:        lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
    #####: 1365:        size = lit_get_magic_string_ex_size (id);
    #####: 1366:        length = 0;
        -: 1367:
    #####: 1368:        if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))
        -: 1369:        {
    #####: 1370:          length = lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id), size);
        -: 1371:        }
        -: 1372:
    #####: 1373:        result_p = lit_get_magic_string_ex_utf8 (id);
    #####: 1374:        *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;
    #####: 1375:        break;
        -: 1376:      }
        -: 1377:    }
        -: 1378:  }
        -: 1379:
    #####: 1380:  *size_p = size;
    #####: 1381:  if (length_p != NULL)
        -: 1382:  {
    #####: 1383:    *length_p = length;
        -: 1384:  }
        -: 1385:
    #####: 1386:  if ((*flags_p & ECMA_STRING_FLAG_IS_ASCII) && length != size)
        -: 1387:  {
    #####: 1388:    *flags_p = (uint8_t) (*flags_p & (uint8_t) ~ECMA_STRING_FLAG_IS_ASCII);
        -: 1389:  }
        -: 1390:
    #####: 1391:  return result_p;
        -: 1392:} /* ecma_string_get_chars */
        -: 1393:
        -: 1394:/**
        -: 1395: * Checks whether the string equals to the magic string id.
        -: 1396: *
        -: 1397: * @return true - if the string equals to the magic string id
        -: 1398: *         false - otherwise
        -: 1399: */
        -: 1400:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        3: 1401:ecma_compare_ecma_string_to_magic_id (const ecma_string_t *string_p, /**< property name */
        -: 1402:                                      lit_magic_string_id_t id) /**< magic string id */
        -: 1403:{
        3: 1404:  return (string_p == ecma_get_magic_string (id));
        -: 1405:} /* ecma_compare_ecma_string_to_magic_id */
        -: 1406:
        -: 1407:/**
        -: 1408: * Checks whether ecma string is empty or not
        -: 1409: *
        -: 1410: * @return true - if the string is an empty string
        -: 1411: *         false - otherwise
        -: 1412: */
        -: 1413:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1414:ecma_string_is_empty (const ecma_string_t *string_p) /**< ecma-string */
        -: 1415:{
    #####: 1416:  return ecma_compare_ecma_string_to_magic_id (string_p, LIT_MAGIC_STRING__EMPTY);
        -: 1417:} /* ecma_string_is_empty */
        -: 1418:
        -: 1419:/**
        -: 1420: * Checks whether the string equals to "length".
        -: 1421: *
        -: 1422: * @return true - if the string equals to "length"
        -: 1423: *         false - otherwise
        -: 1424: */
        -: 1425:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1426:ecma_string_is_length (const ecma_string_t *string_p) /**< property name */
        -: 1427:{
    #####: 1428:  return ecma_compare_ecma_string_to_magic_id (string_p, LIT_MAGIC_STRING_LENGTH);
        -: 1429:} /* ecma_string_is_length */
        -: 1430:
        -: 1431:/**
        -: 1432: * Converts a property name into a string
        -: 1433: *
        -: 1434: * @return pointer to the converted ecma string
        -: 1435: */
        -: 1436:static inline ecma_string_t *JERRY_ATTR_ALWAYS_INLINE
        -: 1437:ecma_property_to_string (ecma_property_t property, /**< property name type */
        -: 1438:                         jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */
        -: 1439:{
    #####: 1440:  uintptr_t property_string = ((uintptr_t) (property)) & (0x3 << ECMA_PROPERTY_NAME_TYPE_SHIFT);
    #####: 1441:  property_string = (property_string >> ECMA_STRING_TYPE_CONVERSION_SHIFT) | ECMA_TYPE_DIRECT_STRING;
    #####: 1442:  return (ecma_string_t *) (property_string | (((uintptr_t) prop_name_cp) << ECMA_DIRECT_STRING_SHIFT));
        -: 1443:} /* ecma_property_to_string */
        -: 1444:
        -: 1445:/**
        -: 1446: * Converts a string into a property name
        -: 1447: *
        -: 1448: * @return the compressed pointer part of the name
        -: 1449: */
        -: 1450:extern inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE
        8: 1451:ecma_string_to_property_name (ecma_string_t *prop_name_p, /**< property name */
        -: 1452:                              ecma_property_t *name_type_p) /**< [out] property name type */
        -: 1453:{
        8: 1454:  if (ECMA_IS_DIRECT_STRING (prop_name_p))
        -: 1455:  {
        2: 1456:    *name_type_p = (ecma_property_t) ECMA_DIRECT_STRING_TYPE_TO_PROP_NAME_TYPE (prop_name_p);
        2: 1457:    return (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (prop_name_p);
        -: 1458:  }
        -: 1459:
        6: 1460:  *name_type_p = ECMA_DIRECT_STRING_PTR << ECMA_PROPERTY_NAME_TYPE_SHIFT;
        -: 1461:
        6: 1462:  ecma_ref_ecma_string (prop_name_p);
        -: 1463:
        -: 1464:  jmem_cpointer_t prop_name_cp;
        6: 1465:  ECMA_SET_NON_NULL_POINTER (prop_name_cp, prop_name_p);
        6: 1466:  return prop_name_cp;
        -: 1467:} /* ecma_string_to_property_name */
        -: 1468:
        -: 1469:/**
        -: 1470: * Converts a property name into a string
        -: 1471: *
        -: 1472: * @return the string pointer
        -: 1473: *         string must be released with ecma_deref_ecma_string
        -: 1474: */
        -: 1475:ecma_string_t *
    #####: 1476:ecma_string_from_property_name (ecma_property_t property, /**< property name type */
        -: 1477:                                jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */
        -: 1478:{
    #####: 1479:  if (ECMA_PROPERTY_GET_NAME_TYPE (property) != ECMA_DIRECT_STRING_PTR)
        -: 1480:  {
    #####: 1481:    return ecma_property_to_string (property, prop_name_cp);
        -: 1482:  }
        -: 1483:
    #####: 1484:  ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);
    #####: 1485:  ecma_ref_ecma_string (prop_name_p);
    #####: 1486:  return prop_name_p;
        -: 1487:} /* ecma_string_from_property_name */
        -: 1488:
        -: 1489:/**
        -: 1490: * Get hash code of property name
        -: 1491: *
        -: 1492: * @return hash code of property name
        -: 1493: */
        -: 1494:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
    #####: 1495:ecma_string_get_property_name_hash (ecma_property_t property, /**< property name type */
        -: 1496:                                    jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */
        -: 1497:{
    #####: 1498:  if (ECMA_PROPERTY_GET_NAME_TYPE (property) == ECMA_DIRECT_STRING_PTR)
        -: 1499:  {
    #####: 1500:    ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);
    #####: 1501:    return prop_name_p->u.hash;
        -: 1502:  }
        -: 1503:
    #####: 1504:  return (lit_string_hash_t) prop_name_cp;
        -: 1505:} /* ecma_string_get_property_name_hash */
        -: 1506:
        -: 1507:/**
        -: 1508: * Check if property name is array index.
        -: 1509: *
        -: 1510: * @return ECMA_STRING_NOT_ARRAY_INDEX if string is not array index
        -: 1511: *         the array index otherwise
        -: 1512: */
        -: 1513:uint32_t
    #####: 1514:ecma_string_get_property_index (ecma_property_t property, /**< property name type */
        -: 1515:                                jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */
        -: 1516:{
    #####: 1517:  switch (ECMA_PROPERTY_GET_NAME_TYPE (property))
        -: 1518:  {
    #####: 1519:    case ECMA_DIRECT_STRING_UINT:
        -: 1520:    {
    #####: 1521:      return (uint32_t) prop_name_cp;
        -: 1522:    }
    #####: 1523:    case ECMA_DIRECT_STRING_PTR:
        -: 1524:    {
    #####: 1525:      ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);
    #####: 1526:      return ecma_string_get_array_index (prop_name_p);
        -: 1527:    }
    #####: 1528:    default:
        -: 1529:    {
    #####: 1530:      return ECMA_STRING_NOT_ARRAY_INDEX;
        -: 1531:    }
        -: 1532:  }
        -: 1533:} /* ecma_string_get_property_index */
        -: 1534:
        -: 1535:/**
        -: 1536: * Compare a property name to a string
        -: 1537: *
        -: 1538: * @return true if they are equals
        -: 1539: *         false otherwise
        -: 1540: */
        -: 1541:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1542:ecma_string_compare_to_property_name (ecma_property_t property, /**< property name type */
        -: 1543:                                      jmem_cpointer_t prop_name_cp, /**< property name compressed pointer */
        -: 1544:                                      const ecma_string_t *string_p) /**< other string */
        -: 1545:{
    #####: 1546:  if (ECMA_PROPERTY_GET_NAME_TYPE (property) != ECMA_DIRECT_STRING_PTR)
        -: 1547:  {
    #####: 1548:    return ecma_property_to_string (property, prop_name_cp) == string_p;
        -: 1549:  }
        -: 1550:
    #####: 1551:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1552:  {
    #####: 1553:    return false;
        -: 1554:  }
        -: 1555:
    #####: 1556:  ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);
    #####: 1557:  return ecma_compare_ecma_non_direct_strings (prop_name_p, string_p);
        -: 1558:} /* ecma_string_compare_to_property_name */
        -: 1559:
        -: 1560:/**
        -: 1561: * Helper for ecma_compare_ecma_strings_longpath to get string data
        -: 1562: *
        -: 1563: * @return string characters
        -: 1564: */
        -: 1565:static const lit_utf8_byte_t *
        4: 1566:ecma_compare_get_string_chars (const ecma_string_t *string_p, /**< ecma-string */
        -: 1567:                               lit_utf8_size_t *size_and_length_p) /**< [out] size and length */
        -: 1568:{
        4: 1569:  switch (ECMA_STRING_GET_CONTAINER (string_p))
        -: 1570:  {
    #####: 1571:    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -: 1572:    {
    #####: 1573:      ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 1574:      size_and_length_p[0] = short_string_p->size;
    #####: 1575:      size_and_length_p[1] = short_string_p->length;
    #####: 1576:      return ECMA_SHORT_STRING_GET_BUFFER (string_p);
        -: 1577:    }
    #####: 1578:    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -: 1579:    {
    #####: 1580:      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
    #####: 1581:      size_and_length_p[0] = long_string_p->size;
    #####: 1582:      size_and_length_p[1] = long_string_p->length;
    #####: 1583:      return long_string_p->string_p;
        -: 1584:    }
        4: 1585:    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -: 1586:    {
        4: 1587:      size_and_length_p[0] = ECMA_ASCII_STRING_GET_SIZE (string_p);
        4: 1588:      size_and_length_p[1] = size_and_length_p[0];
        4: 1589:      return ECMA_ASCII_STRING_GET_BUFFER (string_p);
        -: 1590:    }
    #####: 1591:    default:
        -: 1592:    {
    #####: 1593:      return NULL;
        -: 1594:    }
        -: 1595:  }
        -: 1596:} /* ecma_compare_get_string_chars */
        -: 1597:
        -: 1598:/**
        -: 1599: * Long path part of ecma-string to ecma-string comparison routine
        -: 1600: *
        -: 1601: * See also:
        -: 1602: *          ecma_compare_ecma_strings
        -: 1603: *
        -: 1604: * @return true - if strings are equal;
        -: 1605: *         false - otherwise
        -: 1606: */
        -: 1607:static bool JERRY_ATTR_NOINLINE
        2: 1608:ecma_compare_ecma_strings_longpath (const ecma_string_t *string1_p, /**< ecma-string */
        -: 1609:                                    const ecma_string_t *string2_p) /**< ecma-string */
        -: 1610:{
        -: 1611:  const lit_utf8_byte_t *utf8_string1_p, *utf8_string2_p;
        2: 1612:  lit_utf8_size_t string1_size_and_length[2], string2_size_and_length[2];
        -: 1613:
        2: 1614:  utf8_string1_p = ecma_compare_get_string_chars (string1_p, string1_size_and_length);
        2: 1615:  utf8_string2_p = ecma_compare_get_string_chars (string2_p, string2_size_and_length);
        -: 1616:
        2: 1617:  if (utf8_string1_p == NULL || utf8_string2_p == NULL)
        -: 1618:  {
    #####: 1619:    return false;
        -: 1620:  }
        -: 1621:
        2: 1622:  if (string1_size_and_length[0] != string2_size_and_length[0]
        2: 1623:      || string1_size_and_length[1] != string2_size_and_length[1])
        -: 1624:  {
    #####: 1625:    return false;
        -: 1626:  }
        -: 1627:
        2: 1628:  return !memcmp ((char *) utf8_string1_p, (char *) utf8_string2_p, string1_size_and_length[0]);
        -: 1629:} /* ecma_compare_ecma_strings_longpath */
        -: 1630:
        -: 1631:/**
        -: 1632: * Compare two ecma-strings
        -: 1633: *
        -: 1634: * @return true - if strings are equal;
        -: 1635: *         false - otherwise
        -: 1636: */
        -: 1637:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        3: 1638:ecma_compare_ecma_strings (const ecma_string_t *string1_p, /**< ecma-string */
        -: 1639:                           const ecma_string_t *string2_p) /**< ecma-string */
        -: 1640:{
        3: 1641:  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);
        -: 1642:
        -: 1643:  /* Fast paths first. */
        3: 1644:  if (string1_p == string2_p)
        -: 1645:  {
    #####: 1646:    return true;
        -: 1647:  }
        -: 1648:
        -: 1649:  /* Either string is direct, return with false. */
        3: 1650:  if (ECMA_IS_DIRECT_STRING (((uintptr_t) string1_p) | ((uintptr_t) string2_p)))
        -: 1651:  {
    #####: 1652:    return false;
        -: 1653:  }
        -: 1654:
        -: 1655:  /* Also compares uint32 values in descriptor. */
        3: 1656:  if (string1_p->u.hash != string2_p->u.hash)
        -: 1657:  {
        1: 1658:    return false;
        -: 1659:  }
        -: 1660:
        2: 1661:  if (ECMA_STRING_GET_CONTAINER (string1_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1662:  {
    #####: 1663:    return ECMA_STRING_GET_CONTAINER (string2_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC;
        -: 1664:  }
        -: 1665:
        2: 1666:  return ecma_compare_ecma_strings_longpath (string1_p, string2_p);
        -: 1667:} /* ecma_compare_ecma_strings */
        -: 1668:
        -: 1669:/**
        -: 1670: * Compare two non-direct ecma-strings
        -: 1671: *
        -: 1672: * @return true - if strings are equal;
        -: 1673: *         false - otherwise
        -: 1674: */
        -: 1675:extern inline bool JERRY_ATTR_ALWAYS_INLINE
       46: 1676:ecma_compare_ecma_non_direct_strings (const ecma_string_t *string1_p, /**< ecma-string */
        -: 1677:                                      const ecma_string_t *string2_p) /**< ecma-string */
        -: 1678:{
       46: 1679:  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);
       46: 1680:  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string1_p) && !ECMA_IS_DIRECT_STRING (string2_p));
        -: 1681:
        -: 1682:  /* Fast paths first. */
       46: 1683:  if (string1_p == string2_p)
        -: 1684:  {
        1: 1685:    return true;
        -: 1686:  }
        -: 1687:
       45: 1688:  if (string1_p->u.hash != string2_p->u.hash)
        -: 1689:  {
       45: 1690:    return false;
        -: 1691:  }
        -: 1692:
    #####: 1693:  if (ECMA_STRING_GET_CONTAINER (string1_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1694:  {
    #####: 1695:    return ECMA_STRING_GET_CONTAINER (string2_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC;
        -: 1696:  }
        -: 1697:
    #####: 1698:  return ecma_compare_ecma_strings_longpath (string1_p, string2_p);
        -: 1699:} /* ecma_compare_ecma_non_direct_strings */
        -: 1700:
        -: 1701:/**
        -: 1702: * Relational compare of ecma-strings.
        -: 1703: *
        -: 1704: * First string is less than second string if:
        -: 1705: *  - strings are not equal;
        -: 1706: *  - first string is prefix of second or is lexicographically less than second.
        -: 1707: *
        -: 1708: * @return true - if first string is less than second string,
        -: 1709: *         false - otherwise
        -: 1710: */
        -: 1711:bool
    #####: 1712:ecma_compare_ecma_strings_relational (const ecma_string_t *string1_p, /**< ecma-string */
        -: 1713:                                      const ecma_string_t *string2_p) /**< ecma-string */
        -: 1714:{
    #####: 1715:  if (ecma_compare_ecma_strings (string1_p, string2_p))
        -: 1716:  {
    #####: 1717:    return false;
        -: 1718:  }
        -: 1719:
        -: 1720:  const lit_utf8_byte_t *utf8_string1_p, *utf8_string2_p;
    #####: 1721:  lit_utf8_size_t utf8_string1_size, utf8_string2_size;
        -: 1722:
    #####: 1723:  lit_utf8_byte_t uint32_to_string_buffer1[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
    #####: 1724:  lit_utf8_byte_t uint32_to_string_buffer2[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
        -: 1725:
    #####: 1726:  if (ECMA_IS_DIRECT_STRING (string1_p))
        -: 1727:  {
    #####: 1728:    if (ECMA_GET_DIRECT_STRING_TYPE (string1_p) != ECMA_DIRECT_STRING_UINT)
        -: 1729:    {
    #####: 1730:      utf8_string1_p = ecma_string_get_chars_fast (string1_p, &utf8_string1_size);
        -: 1731:    }
        -: 1732:    else
        -: 1733:    {
    #####: 1734:      utf8_string1_size = ecma_uint32_to_utf8_string ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string1_p),
        -: 1735:                                                      uint32_to_string_buffer1,
        -: 1736:                                                      ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
    #####: 1737:      utf8_string1_p = uint32_to_string_buffer1;
        -: 1738:    }
        -: 1739:  }
        -: 1740:  else
        -: 1741:  {
    #####: 1742:    JERRY_ASSERT (string1_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1743:
    #####: 1744:    if (ECMA_STRING_GET_CONTAINER (string1_p) != ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1745:    {
    #####: 1746:      utf8_string1_p = ecma_string_get_chars_fast (string1_p, &utf8_string1_size);
        -: 1747:    }
        -: 1748:    else
        -: 1749:    {
    #####: 1750:      utf8_string1_size = ecma_uint32_to_utf8_string (string1_p->u.uint32_number,
        -: 1751:                                                      uint32_to_string_buffer1,
        -: 1752:                                                      ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
    #####: 1753:      utf8_string1_p = uint32_to_string_buffer1;
        -: 1754:    }
        -: 1755:  }
        -: 1756:
    #####: 1757:  if (ECMA_IS_DIRECT_STRING (string2_p))
        -: 1758:  {
    #####: 1759:    if (ECMA_GET_DIRECT_STRING_TYPE (string2_p) != ECMA_DIRECT_STRING_UINT)
        -: 1760:    {
    #####: 1761:      utf8_string2_p = ecma_string_get_chars_fast (string2_p, &utf8_string2_size);
        -: 1762:    }
        -: 1763:    else
        -: 1764:    {
    #####: 1765:      utf8_string2_size = ecma_uint32_to_utf8_string ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string2_p),
        -: 1766:                                                      uint32_to_string_buffer2,
        -: 1767:                                                      ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
    #####: 1768:      utf8_string2_p = uint32_to_string_buffer2;
        -: 1769:    }
        -: 1770:  }
        -: 1771:  else
        -: 1772:  {
    #####: 1773:    JERRY_ASSERT (string2_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1774:
    #####: 1775:    if (ECMA_STRING_GET_CONTAINER (string2_p) != ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1776:    {
    #####: 1777:      utf8_string2_p = ecma_string_get_chars_fast (string2_p, &utf8_string2_size);
        -: 1778:    }
        -: 1779:    else
        -: 1780:    {
    #####: 1781:      utf8_string2_size = ecma_uint32_to_utf8_string (string2_p->u.uint32_number,
        -: 1782:                                                      uint32_to_string_buffer2,
        -: 1783:                                                      ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
    #####: 1784:      utf8_string2_p = uint32_to_string_buffer2;
        -: 1785:    }
        -: 1786:  }
        -: 1787:
    #####: 1788:  return lit_compare_utf8_strings_relational (utf8_string1_p, utf8_string1_size, utf8_string2_p, utf8_string2_size);
        -: 1789:} /* ecma_compare_ecma_strings_relational */
        -: 1790:
        -: 1791:/**
        -: 1792: * Special value to represent that no size is available.
        -: 1793: */
        -: 1794:#define ECMA_STRING_NO_ASCII_SIZE 0xffffffff
        -: 1795:
        -: 1796:/**
        -: 1797: * Return the size of uint32 and magic strings.
        -: 1798: * The length of these strings are equal to their size.
        -: 1799: *
        -: 1800: * @return number of characters in the string
        -: 1801: */
        -: 1802:static lit_utf8_size_t
    #####: 1803:ecma_string_get_ascii_size (const ecma_string_t *string_p) /**< ecma-string */
        -: 1804:{
    #####: 1805:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1806:  {
    #####: 1807:    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))
        -: 1808:    {
    #####: 1809:      case ECMA_DIRECT_STRING_MAGIC:
        -: 1810:      {
    #####: 1811:        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 1812:
    #####: 1813:        if (id >= LIT_MAGIC_STRING__COUNT)
        -: 1814:        {
    #####: 1815:          return ECMA_STRING_NO_ASCII_SIZE;
        -: 1816:        }
        -: 1817:
    #####: 1818:        JERRY_ASSERT (ECMA_STRING_IS_ASCII (lit_get_magic_string_utf8 (id), lit_get_magic_string_size (id)));
        -: 1819:
    #####: 1820:        return lit_get_magic_string_size (id);
        -: 1821:      }
    #####: 1822:      default:
        -: 1823:      {
    #####: 1824:        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);
    #####: 1825:        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
    #####: 1826:        return ecma_string_get_uint32_size (uint32_number);
        -: 1827:      }
        -: 1828:    }
        -: 1829:  }
        -: 1830:
    #####: 1831:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1832:
    #####: 1833:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1834:  {
    #####: 1835:    return ecma_string_get_uint32_size (string_p->u.uint32_number);
        -: 1836:  }
    #####: 1837:  else if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_ASCII_STRING)
        -: 1838:  {
    #####: 1839:    return ECMA_ASCII_STRING_GET_SIZE (string_p);
        -: 1840:  }
        -: 1841:
    #####: 1842:  return ECMA_STRING_NO_ASCII_SIZE;
        -: 1843:} /* ecma_string_get_ascii_size */
        -: 1844:
        -: 1845:/**
        -: 1846: * Get length of ecma-string
        -: 1847: *
        -: 1848: * @return number of characters in the string
        -: 1849: */
        -: 1850:lit_utf8_size_t
    #####: 1851:ecma_string_get_length (const ecma_string_t *string_p) /**< ecma-string */
        -: 1852:{
    #####: 1853:  lit_utf8_size_t length = ecma_string_get_ascii_size (string_p);
        -: 1854:
    #####: 1855:  if (length != ECMA_STRING_NO_ASCII_SIZE)
        -: 1856:  {
    #####: 1857:    return length;
        -: 1858:  }
        -: 1859:
    #####: 1860:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1861:  {
    #####: 1862:    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);
    #####: 1863:    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);
        -: 1864:
    #####: 1865:    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT;
    #####: 1866:    return lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id), lit_get_magic_string_ex_size (id));
        -: 1867:  }
        -: 1868:
    #####: 1869:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)
        -: 1870:  {
    #####: 1871:    return ((ecma_short_string_t *) string_p)->length;
        -: 1872:  }
        -: 1873:
    #####: 1874:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 1875:  {
    #####: 1876:    return ((ecma_long_string_t *) string_p)->length;
        -: 1877:  }
        -: 1878:
    #####: 1879:  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 1880:
    #####: 1881:  lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
    #####: 1882:  return lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id), lit_get_magic_string_ex_size (id));
        -: 1883:} /* ecma_string_get_length */
        -: 1884:
        -: 1885:/**
        -: 1886: * Get length of UTF-8 encoded string length from ecma-string
        -: 1887: *
        -: 1888: * @return number of characters in the UTF-8 encoded string
        -: 1889: */
        -: 1890:lit_utf8_size_t
    #####: 1891:ecma_string_get_utf8_length (const ecma_string_t *string_p) /**< ecma-string */
        -: 1892:{
    #####: 1893:  lit_utf8_size_t length = ecma_string_get_ascii_size (string_p);
        -: 1894:
    #####: 1895:  if (length != ECMA_STRING_NO_ASCII_SIZE)
        -: 1896:  {
    #####: 1897:    return length;
        -: 1898:  }
        -: 1899:
    #####: 1900:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1901:  {
    #####: 1902:    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);
    #####: 1903:    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);
        -: 1904:
    #####: 1905:    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT;
    #####: 1906:    return lit_get_utf8_length_of_cesu8_string (lit_get_magic_string_ex_utf8 (id), lit_get_magic_string_ex_size (id));
        -: 1907:  }
        -: 1908:
    #####: 1909:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)
        -: 1910:  {
    #####: 1911:    ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 1912:    lit_utf8_size_t size = short_string_p->size;
        -: 1913:
    #####: 1914:    if (size == short_string_p->length)
        -: 1915:    {
    #####: 1916:      return size;
        -: 1917:    }
        -: 1918:
    #####: 1919:    return lit_get_utf8_length_of_cesu8_string (ECMA_SHORT_STRING_GET_BUFFER (string_p), size);
        -: 1920:  }
        -: 1921:
    #####: 1922:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 1923:  {
    #####: 1924:    ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
    #####: 1925:    lit_utf8_size_t size = long_string_p->size;
        -: 1926:
    #####: 1927:    if (size == long_string_p->length)
        -: 1928:    {
    #####: 1929:      return size;
        -: 1930:    }
        -: 1931:
    #####: 1932:    return lit_get_utf8_length_of_cesu8_string (long_string_p->string_p, size);
        -: 1933:  }
        -: 1934:
    #####: 1935:  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 1936:
    #####: 1937:  lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
        -: 1938:
    #####: 1939:  return lit_get_utf8_length_of_cesu8_string (lit_get_magic_string_ex_utf8 (id), lit_get_magic_string_ex_size (id));
        -: 1940:} /* ecma_string_get_utf8_length */
        -: 1941:
        -: 1942:/**
        -: 1943: * Get size of ecma-string
        -: 1944: *
        -: 1945: * @return number of bytes in the buffer needed to represent the string
        -: 1946: */
        -: 1947:lit_utf8_size_t
    #####: 1948:ecma_string_get_size (const ecma_string_t *string_p) /**< ecma-string */
        -: 1949:{
    #####: 1950:  lit_utf8_size_t length = ecma_string_get_ascii_size (string_p);
        -: 1951:
    #####: 1952:  if (length != ECMA_STRING_NO_ASCII_SIZE)
        -: 1953:  {
    #####: 1954:    return length;
        -: 1955:  }
        -: 1956:
    #####: 1957:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1958:  {
    #####: 1959:    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);
    #####: 1960:    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);
        -: 1961:
    #####: 1962:    return lit_get_magic_string_ex_size ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT);
        -: 1963:  }
        -: 1964:
    #####: 1965:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)
        -: 1966:  {
    #####: 1967:    return ((ecma_short_string_t *) string_p)->size;
        -: 1968:  }
        -: 1969:
    #####: 1970:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 1971:  {
    #####: 1972:    return ((ecma_long_string_t *) string_p)->size;
        -: 1973:  }
        -: 1974:
    #####: 1975:  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 1976:
    #####: 1977:  return lit_get_magic_string_ex_size (LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id);
        -: 1978:} /* ecma_string_get_size */
        -: 1979:
        -: 1980:/**
        -: 1981: * Get the UTF-8 encoded string size from ecma-string
        -: 1982: *
        -: 1983: * @return number of bytes in the buffer needed to represent an UTF-8 encoded string
        -: 1984: */
        -: 1985:lit_utf8_size_t
    #####: 1986:ecma_string_get_utf8_size (const ecma_string_t *string_p) /**< ecma-string */
        -: 1987:{
    #####: 1988:  lit_utf8_size_t length = ecma_string_get_ascii_size (string_p);
        -: 1989:
    #####: 1990:  if (length != ECMA_STRING_NO_ASCII_SIZE)
        -: 1991:  {
    #####: 1992:    return length;
        -: 1993:  }
        -: 1994:
    #####: 1995:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1996:  {
    #####: 1997:    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);
    #####: 1998:    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);
        -: 1999:
    #####: 2000:    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT;
    #####: 2001:    return lit_get_utf8_size_of_cesu8_string (lit_get_magic_string_ex_utf8 (id), lit_get_magic_string_ex_size (id));
        -: 2002:  }
        -: 2003:
    #####: 2004:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)
        -: 2005:  {
    #####: 2006:    ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 2007:    lit_utf8_size_t size = short_string_p->size;
        -: 2008:
    #####: 2009:    if (size == short_string_p->length)
        -: 2010:    {
    #####: 2011:      return size;
        -: 2012:    }
        -: 2013:
    #####: 2014:    return lit_get_utf8_size_of_cesu8_string (ECMA_SHORT_STRING_GET_BUFFER (string_p), size);
        -: 2015:  }
        -: 2016:
    #####: 2017:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 2018:  {
    #####: 2019:    ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -: 2020:
    #####: 2021:    if (long_string_p->size == long_string_p->length)
        -: 2022:    {
    #####: 2023:      return long_string_p->size;
        -: 2024:    }
        -: 2025:
    #####: 2026:    return lit_get_utf8_size_of_cesu8_string (long_string_p->string_p, long_string_p->size);
        -: 2027:  }
        -: 2028:
    #####: 2029:  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 2030:
    #####: 2031:  lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
    #####: 2032:  return lit_get_utf8_size_of_cesu8_string (lit_get_magic_string_ex_utf8 (id), lit_get_magic_string_ex_size (id));
        -: 2033:} /* ecma_string_get_utf8_size */
        -: 2034:
        -: 2035:/**
        -: 2036: * Get character from specified position in an external ecma-string.
        -: 2037: *
        -: 2038: * @return character value
        -: 2039: */
        -: 2040:static ecma_char_t JERRY_ATTR_NOINLINE
    #####: 2041:ecma_external_string_get_char_at_pos (lit_utf8_size_t id, /**< id of the external magic string */
        -: 2042:                                      lit_utf8_size_t index) /**< index of character */
        -: 2043:{
    #####: 2044:  id -= LIT_MAGIC_STRING__COUNT;
    #####: 2045:  const lit_utf8_byte_t *data_p = lit_get_magic_string_ex_utf8 (id);
    #####: 2046:  lit_utf8_size_t size = lit_get_magic_string_ex_size (id);
    #####: 2047:  lit_utf8_size_t length = lit_utf8_string_length (data_p, size);
        -: 2048:
    #####: 2049:  if (JERRY_LIKELY (size == length))
        -: 2050:  {
    #####: 2051:    return (ecma_char_t) data_p[index];
        -: 2052:  }
        -: 2053:
    #####: 2054:  return lit_utf8_string_code_unit_at (data_p, size, index);
        -: 2055:} /* ecma_external_string_get_char_at_pos */
        -: 2056:
        -: 2057:/**
        -: 2058: * Get character from specified position in the ecma-string.
        -: 2059: *
        -: 2060: * @return character value
        -: 2061: */
        -: 2062:ecma_char_t
    #####: 2063:ecma_string_get_char_at_pos (const ecma_string_t *string_p, /**< ecma-string */
        -: 2064:                             lit_utf8_size_t index) /**< index of character */
        -: 2065:{
    #####: 2066:  JERRY_ASSERT (index < ecma_string_get_length (string_p));
        -: 2067:
    #####: 2068:  lit_utf8_byte_t uint32_to_string_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
        -: 2069:
    #####: 2070:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2071:  {
    #####: 2072:    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))
        -: 2073:    {
    #####: 2074:      case ECMA_DIRECT_STRING_MAGIC:
        -: 2075:      {
    #####: 2076:        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2077:
    #####: 2078:        if (JERRY_LIKELY (id < LIT_MAGIC_STRING__COUNT))
        -: 2079:        {
        -: 2080:          /* All magic strings must be ascii strings. */
    #####: 2081:          const lit_utf8_byte_t *data_p = lit_get_magic_string_utf8 (id);
        -: 2082:
    #####: 2083:          return (ecma_char_t) data_p[index];
        -: 2084:        }
        -: 2085:
    #####: 2086:        return ecma_external_string_get_char_at_pos (id, index);
        -: 2087:      }
    #####: 2088:      default:
        -: 2089:      {
    #####: 2090:        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);
    #####: 2091:        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2092:
    #####: 2093:        ecma_uint32_to_utf8_string (uint32_number, uint32_to_string_buffer, ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
        -: 2094:
    #####: 2095:        return (ecma_char_t) uint32_to_string_buffer[index];
        -: 2096:      }
        -: 2097:    }
        -: 2098:  }
        -: 2099:
    #####: 2100:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 2101:
    #####: 2102:  switch (ECMA_STRING_GET_CONTAINER (string_p))
        -: 2103:  {
    #####: 2104:    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -: 2105:    {
    #####: 2106:      ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 2107:      lit_utf8_size_t size = short_string_p->size;
    #####: 2108:      const lit_utf8_byte_t *data_p = ECMA_SHORT_STRING_GET_BUFFER (string_p);
        -: 2109:
    #####: 2110:      if (JERRY_LIKELY (size == short_string_p->length))
        -: 2111:      {
    #####: 2112:        return (ecma_char_t) data_p[index];
        -: 2113:      }
        -: 2114:
    #####: 2115:      return lit_utf8_string_code_unit_at (data_p, size, index);
        -: 2116:    }
    #####: 2117:    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -: 2118:    {
    #####: 2119:      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
    #####: 2120:      lit_utf8_size_t size = long_string_p->size;
    #####: 2121:      const lit_utf8_byte_t *data_p = long_string_p->string_p;
        -: 2122:
    #####: 2123:      if (JERRY_LIKELY (size == long_string_p->length))
        -: 2124:      {
    #####: 2125:        return (ecma_char_t) data_p[index];
        -: 2126:      }
        -: 2127:
    #####: 2128:      return lit_utf8_string_code_unit_at (data_p, size, index);
        -: 2129:    }
    #####: 2130:    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -: 2131:    {
    #####: 2132:      const lit_utf8_byte_t *data_p = ECMA_ASCII_STRING_GET_BUFFER (string_p);
    #####: 2133:      return (ecma_char_t) data_p[index];
        -: 2134:    }
    #####: 2135:    case ECMA_STRING_CONTAINER_UINT32_IN_DESC:
        -: 2136:    {
    #####: 2137:      ecma_uint32_to_utf8_string (string_p->u.uint32_number,
        -: 2138:                                  uint32_to_string_buffer,
        -: 2139:                                  ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
        -: 2140:
    #####: 2141:      return (ecma_char_t) uint32_to_string_buffer[index];
        -: 2142:    }
    #####: 2143:    default:
        -: 2144:    {
    #####: 2145:      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
    #####: 2146:      return ecma_external_string_get_char_at_pos (string_p->u.magic_string_ex_id, index);
        -: 2147:    }
        -: 2148:  }
        -: 2149:} /* ecma_string_get_char_at_pos */
        -: 2150:
        -: 2151:/**
        -: 2152: * Check if passed string equals to one of magic strings
        -: 2153: * and if equal magic string was found, return it's id in 'out_id_p' argument.
        -: 2154: *
        -: 2155: * @return id - if magic string equal to passed string was found,
        -: 2156: *         LIT_MAGIC_STRING__COUNT - otherwise.
        -: 2157: */
        -: 2158:lit_magic_string_id_t
       18: 2159:ecma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */
        -: 2160:{
       18: 2161:  if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_MAGIC))
        -: 2162:  {
    #####: 2163:    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2164:
    #####: 2165:    if (id < LIT_MAGIC_STRING__COUNT)
        -: 2166:    {
    #####: 2167:      return (lit_magic_string_id_t) id;
        -: 2168:    }
        -: 2169:  }
        -: 2170:
       18: 2171:  return LIT_MAGIC_STRING__COUNT;
        -: 2172:} /* ecma_get_string_magic */
        -: 2173:
        -: 2174:/**
        -: 2175: * Try to calculate hash of the ecma-string
        -: 2176: *
        -: 2177: * @return calculated hash
        -: 2178: */
        -: 2179:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
    #####: 2180:ecma_string_hash (const ecma_string_t *string_p) /**< ecma-string to calculate hash for */
        -: 2181:{
    #####: 2182:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2183:  {
    #####: 2184:    return (lit_string_hash_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2185:  }
        -: 2186:
    #####: 2187:  return (lit_string_hash_t) string_p->u.hash;
        -: 2188:} /* ecma_string_hash */
        -: 2189:
        -: 2190:/**
        -: 2191: * Create a substring from an ecma string
        -: 2192: *
        -: 2193: * @return a newly consturcted ecma string with its value initialized to a copy of a substring of the first argument
        -: 2194: */
        -: 2195:ecma_string_t *
    #####: 2196:ecma_string_substr (const ecma_string_t *string_p, /**< pointer to an ecma string */
        -: 2197:                    lit_utf8_size_t start_pos, /**< start position, should be less or equal than string length */
        -: 2198:                    lit_utf8_size_t end_pos) /**< end position, should be less or equal than string length */
        -: 2199:{
    #####: 2200:  const lit_utf8_size_t string_length = ecma_string_get_length (string_p);
    #####: 2201:  JERRY_ASSERT (start_pos <= string_length);
    #####: 2202:  JERRY_ASSERT (end_pos <= string_length);
        -: 2203:
    #####: 2204:  if (start_pos >= end_pos)
        -: 2205:  {
    #####: 2206:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 2207:  }
        -: 2208:
    #####: 2209:  ecma_string_t *ecma_string_p = NULL;
    #####: 2210:  end_pos -= start_pos;
        -: 2211:
    #####: 2212:  ECMA_STRING_TO_UTF8_STRING (string_p, start_p, buffer_size);
        -: 2213:
    #####: 2214:  if (string_length == buffer_size)
        -: 2215:  {
    #####: 2216:    ecma_string_p = ecma_new_ecma_string_from_utf8 (start_p + start_pos, (lit_utf8_size_t) end_pos);
        -: 2217:  }
        -: 2218:  else
        -: 2219:  {
    #####: 2220:    while (start_pos--)
        -: 2221:    {
    #####: 2222:      start_p += lit_get_unicode_char_size_by_utf8_first_byte (*start_p);
        -: 2223:    }
        -: 2224:
    #####: 2225:    const lit_utf8_byte_t *end_p = start_p;
    #####: 2226:    while (end_pos--)
        -: 2227:    {
    #####: 2228:      end_p += lit_get_unicode_char_size_by_utf8_first_byte (*end_p);
        -: 2229:    }
        -: 2230:
    #####: 2231:    ecma_string_p = ecma_new_ecma_string_from_utf8 (start_p, (lit_utf8_size_t) (end_p - start_p));
        -: 2232:  }
        -: 2233:
    #####: 2234:  ECMA_FINALIZE_UTF8_STRING (start_p, buffer_size);
        -: 2235:
    #####: 2236:  return ecma_string_p;
        -: 2237:} /* ecma_string_substr */
        -: 2238:
        -: 2239:/**
        -: 2240: * Helper function for trimming.
        -: 2241: *
        -: 2242: * Used by:
        -: 2243: *        - ecma_string_trim_helper
        -: 2244: *        - ecma_builtin_global_object_parse_int
        -: 2245: *        - ecma_builtin_global_object_parse_float
        -: 2246: *
        -: 2247: * @return position of the first non whitespace character.
        -: 2248: */
        -: 2249:const lit_utf8_byte_t *
    #####: 2250:ecma_string_trim_front (const lit_utf8_byte_t *start_p, /**< current string's start position */
        -: 2251:                        const lit_utf8_byte_t *end_p) /**< current string's end position */
        -: 2252:{
    #####: 2253:  ecma_char_t ch;
        -: 2254:
    #####: 2255:  while (start_p < end_p)
        -: 2256:  {
    #####: 2257:    lit_utf8_size_t read_size = lit_read_code_unit_from_cesu8 (start_p, &ch);
        -: 2258:
    #####: 2259:    if (!lit_char_is_white_space (ch))
        -: 2260:    {
    #####: 2261:      break;
        -: 2262:    }
        -: 2263:
    #####: 2264:    start_p += read_size;
        -: 2265:  }
        -: 2266:
    #####: 2267:  return start_p;
        -: 2268:} /* ecma_string_trim_front */
        -: 2269:
        -: 2270:/**
        -: 2271: * Helper function for trimming.
        -: 2272: *
        -: 2273: * Used by:
        -: 2274: *        - ecma_string_trim_helper
        -: 2275: *
        -: 2276: * @return position of the last non whitespace character.
        -: 2277: */
        -: 2278:const lit_utf8_byte_t *
    #####: 2279:ecma_string_trim_back (const lit_utf8_byte_t *start_p, /**< current string's start position */
        -: 2280:                       const lit_utf8_byte_t *end_p) /**< current string's end position */
        -: 2281:{
    #####: 2282:  ecma_char_t ch;
        -: 2283:
    #####: 2284:  while (end_p > start_p)
        -: 2285:  {
    #####: 2286:    lit_utf8_size_t read_size = lit_read_prev_code_unit_from_utf8 (end_p, &ch);
        -: 2287:
    #####: 2288:    if (!lit_char_is_white_space (ch))
        -: 2289:    {
    #####: 2290:      break;
        -: 2291:    }
        -: 2292:
    #####: 2293:    end_p -= read_size;
        -: 2294:  }
        -: 2295:
    #####: 2296:  return end_p;
        -: 2297:} /* ecma_string_trim_back */
        -: 2298:
        -: 2299:/**
        -: 2300: * Helper function for trimming.
        -: 2301: *
        -: 2302: * Used by:
        -: 2303: *        - ecma_string_trim
        -: 2304: *        - ecma_utf8_string_to_number
        -: 2305: */
        -: 2306:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 2307:ecma_string_trim_helper (const lit_utf8_byte_t **utf8_str_p, /**< [in, out] current string position */
        -: 2308:                         lit_utf8_size_t *utf8_str_size) /**< [in, out] size of the given string */
        -: 2309:{
    #####: 2310:  const lit_utf8_byte_t *end_p = *utf8_str_p + *utf8_str_size;
    #####: 2311:  const lit_utf8_byte_t *start_p = *utf8_str_p;
        -: 2312:
    #####: 2313:  const lit_utf8_byte_t *new_start_p = ecma_string_trim_front (start_p, end_p);
    #####: 2314:  const lit_utf8_byte_t *new_end_p = ecma_string_trim_back (new_start_p, end_p);
        -: 2315:
    #####: 2316:  *utf8_str_size = (lit_utf8_size_t) (new_end_p - new_start_p);
    #####: 2317:  *utf8_str_p = new_start_p;
    #####: 2318:} /* ecma_string_trim_helper */
        -: 2319:
        -: 2320:/**
        -: 2321: * Trim leading and trailing whitespace characters from string.
        -: 2322: *
        -: 2323: * @return trimmed ecma string
        -: 2324: */
        -: 2325:ecma_string_t *
    #####: 2326:ecma_string_trim (const ecma_string_t *string_p) /**< pointer to an ecma string */
        -: 2327:{
        -: 2328:  ecma_string_t *ret_string_p;
        -: 2329:
    #####: 2330:  lit_utf8_size_t utf8_str_size;
    #####: 2331:  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 2332:  const lit_utf8_byte_t *utf8_str_p = ecma_string_get_chars (string_p, &utf8_str_size, NULL, NULL, &flags);
        -: 2333:
    #####: 2334:  if (utf8_str_size > 0)
        -: 2335:  {
    #####: 2336:    ecma_string_trim_helper (&utf8_str_p, &utf8_str_size);
    #####: 2337:    ret_string_p = ecma_new_ecma_string_from_utf8 (utf8_str_p, utf8_str_size);
        -: 2338:  }
        -: 2339:  else
        -: 2340:  {
    #####: 2341:    ret_string_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 2342:  }
        -: 2343:
    #####: 2344:  if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2345:  {
    #####: 2346:    jmem_heap_free_block ((void *) utf8_str_p, utf8_str_size);
        -: 2347:  }
        -: 2348:
    #####: 2349:  return ret_string_p;
        -: 2350:} /* ecma_string_trim */
        -: 2351:
        -: 2352:#if JERRY_ESNEXT
        -: 2353:
        -: 2354:/**
        -: 2355: * Pad the beginning or the end of string with parameter given in fill_string to the length of max_length.
        -: 2356: *
        -: 2357: * @return new string from original, padded with given parameters
        -: 2358: */
        -: 2359:ecma_value_t
    #####: 2360:ecma_string_pad (ecma_value_t original_string_p, /**< Input ecma string */
        -: 2361:                 ecma_value_t max_length, /**< Length to pad to, including original length */
        -: 2362:                 ecma_value_t fill_string, /**< The string to pad with */
        -: 2363:                 bool pad_on_start) /**< true - if we are padding to the start, calling with padStart
        -: 2364:                                         false - if we are padding to the end, calling with padEnd */
        -: 2365:{
        -: 2366:  /* 3 */
    #####: 2367:  ecma_length_t int_max_length;
    #####: 2368:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_length (max_length, &int_max_length)))
        -: 2369:  {
    #####: 2370:    return ECMA_VALUE_ERROR;
        -: 2371:  }
        -: 2372:  /* 4 */
    #####: 2373:  ecma_string_t *original_str_val_p = ecma_get_string_from_value (original_string_p);
    #####: 2374:  const uint32_t string_length = ecma_string_get_length (original_str_val_p);
        -: 2375:  /* 5 */
    #####: 2376:  if (int_max_length <= string_length)
        -: 2377:  {
    #####: 2378:    ecma_ref_ecma_string (original_str_val_p);
    #####: 2379:    return original_string_p;
        -: 2380:  }
        -: 2381:
    #####: 2382:  ecma_string_t *filler_p = ecma_get_magic_string (LIT_MAGIC_STRING_SPACE_CHAR);
        -: 2383:  /* 6 - 7 */
    #####: 2384:  if (!ecma_is_value_undefined (fill_string))
        -: 2385:  {
    #####: 2386:    filler_p = ecma_op_to_string (fill_string);
    #####: 2387:    if (filler_p == NULL)
        -: 2388:    {
    #####: 2389:      return ECMA_VALUE_ERROR;
        -: 2390:    }
    #####: 2391:    if (ecma_string_is_empty (filler_p))
        -: 2392:    {
    #####: 2393:      ecma_ref_ecma_string (original_str_val_p);
    #####: 2394:      return original_string_p;
        -: 2395:    }
        -: 2396:  }
        -: 2397:
    #####: 2398:  if (int_max_length >= UINT32_MAX)
        -: 2399:  {
    #####: 2400:    ecma_deref_ecma_string (filler_p);
    #####: 2401:    return ecma_raise_range_error (ECMA_ERR_MAXIMUM_STRING_LENGTH_IS_REACHED);
        -: 2402:  }
        -: 2403:
        -: 2404:  /* 9 */
    #####: 2405:  uint32_t fill_len = (uint32_t) int_max_length - string_length;
        -: 2406:
        -: 2407:  /* 10 */
    #####: 2408:  uint32_t filler_length = ecma_string_get_length (filler_p);
    #####: 2409:  uint32_t prepend_count = fill_len / filler_length;
    #####: 2410:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -: 2411:
    #####: 2412:  if (!pad_on_start)
        -: 2413:  {
    #####: 2414:    ecma_stringbuilder_append (&builder, original_str_val_p);
        -: 2415:  }
        -: 2416:
    #####: 2417:  for (uint32_t i = 0; i < prepend_count; i++)
        -: 2418:  {
    #####: 2419:    ecma_stringbuilder_append (&builder, filler_p);
        -: 2420:  }
        -: 2421:
    #####: 2422:  uint32_t remaining = fill_len - (prepend_count * filler_length);
        -: 2423:
    #####: 2424:  ECMA_STRING_TO_UTF8_STRING (filler_p, start_p, utf8_str_size);
    #####: 2425:  const lit_utf8_byte_t *temp_start_p = start_p;
    #####: 2426:  while (remaining > 0)
        -: 2427:  {
    #####: 2428:    ecma_char_t ch;
    #####: 2429:    lit_utf8_size_t read_size = lit_read_code_unit_from_cesu8 (temp_start_p, &ch);
    #####: 2430:    ecma_stringbuilder_append_char (&builder, ch);
    #####: 2431:    temp_start_p += read_size;
    #####: 2432:    remaining--;
        -: 2433:  }
    #####: 2434:  ECMA_FINALIZE_UTF8_STRING (start_p, utf8_str_size);
    #####: 2435:  ecma_deref_ecma_string (filler_p);
        -: 2436:
        -: 2437:  /* 11 - 12 */
    #####: 2438:  if (pad_on_start)
        -: 2439:  {
    #####: 2440:    ecma_stringbuilder_append (&builder, original_str_val_p);
        -: 2441:  }
        -: 2442:
    #####: 2443:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 2444:} /* ecma_string_pad */
        -: 2445:#endif /* JERRY_ESNEXT */
        -: 2446:
        -: 2447:/**
        -: 2448: * Create an empty string builder
        -: 2449: *
        -: 2450: * @return new string builder
        -: 2451: */
        -: 2452:ecma_stringbuilder_t
    #####: 2453:ecma_stringbuilder_create (void)
        -: 2454:{
    #####: 2455:  const lit_utf8_size_t initial_size = ECMA_ASCII_STRING_HEADER_SIZE;
    #####: 2456:  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);
    #####: 2457:  header_p->current_size = initial_size;
        -: 2458:#if JERRY_MEM_STATS
    #####: 2459:  jmem_stats_allocate_string_bytes (initial_size);
        -: 2460:#endif /* JERRY_MEM_STATS */
        -: 2461:
    #####: 2462:  ecma_stringbuilder_t ret = { .header_p = header_p };
    #####: 2463:  return ret;
        -: 2464:} /* ecma_stringbuilder_create */
        -: 2465:
        -: 2466:/**
        -: 2467: * Create a string builder from an ecma string
        -: 2468: *
        -: 2469: * @return new string builder
        -: 2470: */
        -: 2471:ecma_stringbuilder_t
    #####: 2472:ecma_stringbuilder_create_from (ecma_string_t *string_p) /**< ecma string */
        -: 2473:{
    #####: 2474:  const lit_utf8_size_t string_size = ecma_string_get_size (string_p);
    #####: 2475:  const lit_utf8_size_t initial_size = string_size + ECMA_ASCII_STRING_HEADER_SIZE;
        -: 2476:
    #####: 2477:  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);
    #####: 2478:  header_p->current_size = initial_size;
        -: 2479:#if JERRY_MEM_STATS
    #####: 2480:  jmem_stats_allocate_string_bytes (initial_size);
        -: 2481:#endif /* JERRY_MEM_STATS */
        -: 2482:
    #####: 2483:  ecma_string_to_cesu8_bytes (string_p, ECMA_STRINGBUILDER_STRING_PTR (header_p), string_size);
        -: 2484:
    #####: 2485:  ecma_stringbuilder_t ret = { .header_p = header_p };
    #####: 2486:  return ret;
        -: 2487:} /* ecma_stringbuilder_create_from */
        -: 2488:
        -: 2489:/**
        -: 2490: * Create a string builder from a raw string
        -: 2491: *
        -: 2492: * @return new string builder
        -: 2493: */
        -: 2494:ecma_stringbuilder_t
    #####: 2495:ecma_stringbuilder_create_raw (const lit_utf8_byte_t *data_p, /**< pointer to data */
        -: 2496:                               const lit_utf8_size_t data_size) /**< size of the data */
        -: 2497:{
    #####: 2498:  const lit_utf8_size_t initial_size = data_size + ECMA_ASCII_STRING_HEADER_SIZE;
        -: 2499:
    #####: 2500:  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);
    #####: 2501:  header_p->current_size = initial_size;
        -: 2502:#if JERRY_MEM_STATS
    #####: 2503:  jmem_stats_allocate_string_bytes (initial_size);
        -: 2504:#endif /* JERRY_MEM_STATS */
        -: 2505:
    #####: 2506:  memcpy (ECMA_STRINGBUILDER_STRING_PTR (header_p), data_p, data_size);
        -: 2507:
    #####: 2508:  ecma_stringbuilder_t ret = { .header_p = header_p };
    #####: 2509:  return ret;
        -: 2510:} /* ecma_stringbuilder_create_raw */
        -: 2511:
        -: 2512:/**
        -: 2513: * Grow the underlying buffer of a string builder
        -: 2514: *
        -: 2515: * @return pointer to the end of the data in the underlying buffer
        -: 2516: */
        -: 2517:static lit_utf8_byte_t *
    #####: 2518:ecma_stringbuilder_grow (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2519:                         lit_utf8_size_t required_size) /**< required size */
        -: 2520:{
    #####: 2521:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2522:  JERRY_ASSERT (header_p != NULL);
        -: 2523:
    #####: 2524:  const lit_utf8_size_t new_size = header_p->current_size + required_size;
    #####: 2525:  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, new_size);
    #####: 2526:  header_p->current_size = new_size;
    #####: 2527:  builder_p->header_p = header_p;
        -: 2528:
        -: 2529:#if JERRY_MEM_STATS
    #####: 2530:  jmem_stats_allocate_string_bytes (required_size);
        -: 2531:#endif /* JERRY_MEM_STATS */
        -: 2532:
    #####: 2533:  return ((lit_utf8_byte_t *) header_p) + header_p->current_size - required_size;
        -: 2534:} /* ecma_stringbuilder_grow */
        -: 2535:
        -: 2536:/**
        -: 2537: * Get the current size of the string in a string builder
        -: 2538: *
        -: 2539: * @return the size of the string data
        -: 2540: */
        -: 2541:lit_utf8_size_t
    #####: 2542:ecma_stringbuilder_get_size (ecma_stringbuilder_t *builder_p) /**< string builder */
        -: 2543:{
    #####: 2544:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2545:  JERRY_ASSERT (header_p != NULL);
        -: 2546:
    #####: 2547:  return ECMA_STRINGBUILDER_STRING_SIZE (header_p);
        -: 2548:} /* ecma_stringbuilder_get_size */
        -: 2549:
        -: 2550:/**
        -: 2551: * Get pointer to the raw string data in a string builder
        -: 2552: *
        -: 2553: * @return pointer to the string data
        -: 2554: */
        -: 2555:lit_utf8_byte_t *
    #####: 2556:ecma_stringbuilder_get_data (ecma_stringbuilder_t *builder_p) /**< string builder */
        -: 2557:{
    #####: 2558:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2559:  JERRY_ASSERT (header_p != NULL);
        -: 2560:
    #####: 2561:  return ECMA_STRINGBUILDER_STRING_PTR (header_p);
        -: 2562:} /* ecma_stringbuilder_get_data */
        -: 2563:
        -: 2564:/**
        -: 2565: * Revert the string builder to a smaller size
        -: 2566: */
        -: 2567:void
    #####: 2568:ecma_stringbuilder_revert (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2569:                           const lit_utf8_size_t size) /**< new size */
        -: 2570:{
    #####: 2571:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2572:  JERRY_ASSERT (header_p != NULL);
        -: 2573:
    #####: 2574:  const lit_utf8_size_t new_size = size + ECMA_ASCII_STRING_HEADER_SIZE;
    #####: 2575:  JERRY_ASSERT (new_size <= header_p->current_size);
        -: 2576:
        -: 2577:#if JERRY_MEM_STATS
    #####: 2578:  jmem_stats_free_string_bytes (header_p->current_size - new_size);
        -: 2579:#endif /* JERRY_MEM_STATS */
        -: 2580:
    #####: 2581:  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, new_size);
    #####: 2582:  header_p->current_size = new_size;
    #####: 2583:  builder_p->header_p = header_p;
    #####: 2584:} /* ecma_stringbuilder_revert */
        -: 2585:
        -: 2586:/**
        -: 2587: * Append an ecma_string_t to a string builder
        -: 2588: */
        -: 2589:void
    #####: 2590:ecma_stringbuilder_append (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2591:                           const ecma_string_t *string_p) /**< ecma string */
        -: 2592:{
    #####: 2593:  const lit_utf8_size_t string_size = ecma_string_get_size (string_p);
    #####: 2594:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, string_size);
        -: 2595:
    #####: 2596:  ecma_string_to_cesu8_bytes (string_p, dest_p, string_size);
    #####: 2597:} /* ecma_stringbuilder_append */
        -: 2598:
        -: 2599:/**
        -: 2600: * Append a magic string to a string builder
        -: 2601: */
        -: 2602:void
    #####: 2603:ecma_stringbuilder_append_magic (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2604:                                 const lit_magic_string_id_t id) /**< magic string id */
        -: 2605:{
    #####: 2606:  const lit_utf8_size_t string_size = lit_get_magic_string_size (id);
    #####: 2607:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, string_size);
        -: 2608:
    #####: 2609:  const lit_utf8_byte_t *string_data_p = lit_get_magic_string_utf8 (id);
    #####: 2610:  memcpy (dest_p, string_data_p, string_size);
    #####: 2611:} /* ecma_stringbuilder_append_magic */
        -: 2612:
        -: 2613:/**
        -: 2614: * Append raw string data to a string builder
        -: 2615: */
        -: 2616:void
    #####: 2617:ecma_stringbuilder_append_raw (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2618:                               const lit_utf8_byte_t *data_p, /**< pointer to data */
        -: 2619:                               const lit_utf8_size_t data_size) /**< size of the data */
        -: 2620:{
    #####: 2621:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, data_size);
    #####: 2622:  memcpy (dest_p, data_p, data_size);
    #####: 2623:} /* ecma_stringbuilder_append_raw */
        -: 2624:
        -: 2625:/**
        -: 2626: * Append a codepoint to a string builder
        -: 2627: */
        -: 2628:void
    #####: 2629:ecma_stringbuilder_append_codepoint (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2630:                                     lit_code_point_t cp) /**< code point */
        -: 2631:{
    #####: 2632:  const lit_utf8_size_t size = (lit_utf8_size_t) lit_code_point_get_cesu8_length (cp);
    #####: 2633:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, size);
        -: 2634:
    #####: 2635:  lit_code_point_to_cesu8_bytes (dest_p, cp);
    #####: 2636:} /* ecma_stringbuilder_append_codepoint */
        -: 2637:
        -: 2638:/**
        -: 2639: * Append an ecma_char_t to a string builder
        -: 2640: */
        -: 2641:void
    #####: 2642:ecma_stringbuilder_append_char (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2643:                                const ecma_char_t c) /**< ecma char */
        -: 2644:{
    #####: 2645:  ecma_stringbuilder_append_codepoint (builder_p, c);
    #####: 2646:} /* ecma_stringbuilder_append_char */
        -: 2647:
        -: 2648:/**
        -: 2649: * Append a single byte to a string builder
        -: 2650: */
        -: 2651:void
    #####: 2652:ecma_stringbuilder_append_byte (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2653:                                const lit_utf8_byte_t byte) /**< byte */
        -: 2654:{
    #####: 2655:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, 1);
    #####: 2656:  *dest_p = byte;
    #####: 2657:} /* ecma_stringbuilder_append_byte */
        -: 2658:
        -: 2659:/**
        -: 2660: * Finalize a string builder, returning the created string, and releasing the underlying buffer.
        -: 2661: *
        -: 2662: * Note:
        -: 2663: *      The builder should no longer be used.
        -: 2664: *
        -: 2665: * @return the created string
        -: 2666: */
        -: 2667:ecma_string_t *
    #####: 2668:ecma_stringbuilder_finalize (ecma_stringbuilder_t *builder_p) /**< string builder */
        -: 2669:{
    #####: 2670:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2671:  JERRY_ASSERT (header_p != NULL);
        -: 2672:
    #####: 2673:  const lit_utf8_size_t string_size = ECMA_STRINGBUILDER_STRING_SIZE (header_p);
    #####: 2674:  lit_utf8_byte_t *string_begin_p = ECMA_STRINGBUILDER_STRING_PTR (header_p);
        -: 2675:
    #####: 2676:  ecma_string_t *string_p = ecma_find_special_string (string_begin_p, string_size);
        -: 2677:
    #####: 2678:  if (JERRY_UNLIKELY (string_p != NULL))
        -: 2679:  {
    #####: 2680:    ecma_stringbuilder_destroy (builder_p);
    #####: 2681:    return string_p;
        -: 2682:  }
        -: 2683:
        -: 2684:#ifndef JERRY_NDEBUG
    #####: 2685:  builder_p->header_p = NULL;
        -: 2686:#endif /* !defined (JERRY_NDEBUG) */
        -: 2687:
    #####: 2688:  size_t container_size = sizeof (ecma_short_string_t);
    #####: 2689:  const lit_string_hash_t hash = lit_utf8_string_calc_hash (string_begin_p, string_size);
    #####: 2690:  const lit_utf8_size_t length = lit_utf8_string_length (string_begin_p, string_size);
        -: 2691:
    #####: 2692:  if (JERRY_LIKELY (string_size <= UINT16_MAX))
        -: 2693:  {
    #####: 2694:    if (JERRY_LIKELY (length == string_size) && string_size <= (UINT8_MAX + 1))
        -: 2695:    {
    #####: 2696:      string_p = (ecma_string_t *) header_p;
    #####: 2697:      string_p->refs_and_container = ECMA_STRING_CONTAINER_HEAP_ASCII_STRING | ECMA_STRING_REF_ONE;
    #####: 2698:      string_p->u.hash = hash;
    #####: 2699:      ECMA_ASCII_STRING_SET_SIZE (string_p, string_size);
        -: 2700:
    #####: 2701:      return (ecma_string_t *) string_p;
        -: 2702:    }
        -: 2703:  }
        -: 2704:  else
        -: 2705:  {
    #####: 2706:    container_size = sizeof (ecma_long_string_t);
        -: 2707:  }
        -: 2708:
    #####: 2709:  const size_t utf8_string_size = string_size + container_size;
    #####: 2710:  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, utf8_string_size);
    #####: 2711:  memmove (((lit_utf8_byte_t *) header_p + container_size), ECMA_STRINGBUILDER_STRING_PTR (header_p), string_size);
        -: 2712:
        -: 2713:#if JERRY_MEM_STATS
    #####: 2714:  jmem_stats_allocate_string_bytes (container_size - ECMA_ASCII_STRING_HEADER_SIZE);
        -: 2715:#endif /* JERRY_MEM_STATS */
        -: 2716:
    #####: 2717:  if (JERRY_LIKELY (string_size <= UINT16_MAX))
        -: 2718:  {
    #####: 2719:    ecma_short_string_t *short_string_p = (ecma_short_string_t *) header_p;
        -: 2720:
    #####: 2721:    short_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_UTF8_STRING | ECMA_STRING_REF_ONE;
    #####: 2722:    short_string_p->header.u.hash = hash;
    #####: 2723:    short_string_p->size = (uint16_t) string_size;
    #####: 2724:    short_string_p->length = (uint16_t) length;
        -: 2725:
    #####: 2726:    return (ecma_string_t *) short_string_p;
        -: 2727:  }
        -: 2728:
    #####: 2729:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) header_p;
        -: 2730:
    #####: 2731:  long_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING | ECMA_STRING_REF_ONE;
    #####: 2732:  long_string_p->header.u.hash = hash;
    #####: 2733:  long_string_p->string_p = ECMA_LONG_STRING_BUFFER_START (long_string_p);
    #####: 2734:  long_string_p->size = string_size;
    #####: 2735:  long_string_p->length = length;
        -: 2736:
    #####: 2737:  return (ecma_string_t *) long_string_p;
        -: 2738:} /* ecma_stringbuilder_finalize */
        -: 2739:
        -: 2740:/**
        -: 2741: * Destroy a string builder that is no longer needed without creating a string from the contents.
        -: 2742: */
        -: 2743:void
    #####: 2744:ecma_stringbuilder_destroy (ecma_stringbuilder_t *builder_p) /**< string builder */
        -: 2745:{
    #####: 2746:  JERRY_ASSERT (builder_p->header_p != NULL);
    #####: 2747:  const lit_utf8_size_t size = builder_p->header_p->current_size;
    #####: 2748:  jmem_heap_free_block (builder_p->header_p, size);
        -: 2749:
        -: 2750:#ifndef JERRY_NDEBUG
    #####: 2751:  builder_p->header_p = NULL;
        -: 2752:#endif /* !defined (JERRY_NDEBUG) */
        -: 2753:
        -: 2754:#if JERRY_MEM_STATS
    #####: 2755:  jmem_stats_free_string_bytes (size);
        -: 2756:#endif /* JERRY_MEM_STATS */
    #####: 2757:} /* ecma_stringbuilder_destroy */
        -: 2758:
        -: 2759:#if JERRY_ESNEXT
        -: 2760:/**
        -: 2761: * AdvanceStringIndex operation
        -: 2762: *
        -: 2763: * See also:
        -: 2764: *          ECMA-262 v6.0, 21.2.5.2.3
        -: 2765: *
        -: 2766: * @return uint32_t - the proper character index based on the operation
        -: 2767: */
        -: 2768:ecma_length_t
    #####: 2769:ecma_op_advance_string_index (ecma_string_t *str_p, /**< input string */
        -: 2770:                              ecma_length_t index, /**< given character index */
        -: 2771:                              bool is_unicode) /**< true - if regexp object's "unicode" flag is set
        -: 2772:                                                    false - otherwise */
        -: 2773:{
    #####: 2774:  JERRY_ASSERT ((ecma_number_t) index <= ECMA_NUMBER_MAX_SAFE_INTEGER);
    #####: 2775:  ecma_length_t next_index = index + 1;
        -: 2776:
    #####: 2777:  if (!is_unicode)
        -: 2778:  {
    #####: 2779:    return next_index;
        -: 2780:  }
        -: 2781:
    #####: 2782:  lit_utf8_size_t str_len = ecma_string_get_length (str_p);
        -: 2783:
    #####: 2784:  if (next_index >= str_len)
        -: 2785:  {
    #####: 2786:    return next_index;
        -: 2787:  }
        -: 2788:
    #####: 2789:  JERRY_ASSERT (index < UINT32_MAX);
    #####: 2790:  ecma_char_t first = ecma_string_get_char_at_pos (str_p, (lit_utf8_size_t) index);
        -: 2791:
    #####: 2792:  if (!lit_is_code_point_utf16_high_surrogate (first))
        -: 2793:  {
    #####: 2794:    return next_index;
        -: 2795:  }
        -: 2796:
    #####: 2797:  ecma_char_t second = ecma_string_get_char_at_pos (str_p, (lit_utf8_size_t) next_index);
        -: 2798:
    #####: 2799:  if (!lit_is_code_point_utf16_low_surrogate (second))
        -: 2800:  {
    #####: 2801:    return next_index;
        -: 2802:  }
        -: 2803:
    #####: 2804:  return next_index + 1;
        -: 2805:} /* ecma_op_advance_string_index */
        -: 2806:#endif /* JERRY_ESNEXT */
        -: 2807:
        -: 2808:/**
        -: 2809: * @}
        -: 2810: * @}
        -: 2811: */
