        -:    0:Source:/home/workspace/src/userphrase.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/userphrase.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/userphrase.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * userphrase.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2006
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:#include <stdlib.h>
        -:   16:#include <string.h>
        -:   17:
        -:   18:#include "chewing-utf8-util.h"
        -:   19:#include "hash-private.h"
        -:   20:#include "dict-private.h"
        -:   21:#include "tree-private.h"
        -:   22:#include "userphrase-private.h"
        -:   23:#include "private.h"
        -:   24:
        -:   25:/* load the orginal frequency from the static dict */
        5:   26:static int LoadOriginalFreq( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[], int len )
        -:   27:{
        -:   28:	int pho_id;
        -:   29:	int retval;
        5:   30:	Phrase *phrase = ALC( Phrase, 1 );
        -:   31:
        5:   32:	pho_id = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );
        5:   33:	if ( pho_id != -1 ) {
        5:   34:		GetPhraseFirst( pgdata, phrase, pho_id );
        -:   35:		do {
        -:   36:			/* find the same phrase */
        9:   37:			if ( ! strcmp(
        9:   38:				phrase->phrase,
        -:   39:				wordSeq ) ) {
        5:   40:				retval = phrase->freq;
        5:   41:				free( phrase );
        5:   42:				return retval;
        -:   43:			}
        4:   44:		} while ( GetPhraseNext( pgdata, phrase ) );
        -:   45:	}
        -:   46:
    #####:   47:	free( phrase );
    #####:   48:	return FREQ_INIT_VALUE;
        -:   49:}
        -:   50:
        -:   51:/* find the maximum frequency of the same phrase */
       10:   52:static int LoadMaxFreq( ChewingData *pgdata, const uint16_t phoneSeq[], int len )
        -:   53:{
        -:   54:	int pho_id;
       10:   55:	Phrase *phrase = ALC( Phrase, 1 );
       10:   56:	int maxFreq = FREQ_INIT_VALUE;
        -:   57:	UserPhraseData *uphrase;
        -:   58:
       10:   59:	pho_id = TreeFindPhrase( pgdata, 0, len - 1, phoneSeq );
       10:   60:	if ( pho_id != -1 ) {
       10:   61:		GetPhraseFirst( pgdata, phrase, pho_id );
        -:   62:		do {
       88:   63:			if ( phrase->freq > maxFreq )
       10:   64:				maxFreq = phrase->freq;
       88:   65:		} while( GetPhraseNext( pgdata, phrase ) );
        -:   66:	}
       10:   67:	free( phrase );
        -:   68:
       10:   69:	uphrase = UserGetPhraseFirst( pgdata, phoneSeq );
       15:   70:	while ( uphrase ) {
        5:   71:		if ( uphrase->userfreq > maxFreq )
    #####:   72:			maxFreq = uphrase->userfreq;
        5:   73:		uphrase = UserGetPhraseNext( pgdata, phoneSeq );
        -:   74:	}
        -:   75:
       10:   76:	return maxFreq;
        -:   77:}
        -:   78:
        -:   79:/* compute the new updated freqency */
        5:   80:static int UpdateFreq( int freq, int maxfreq, int origfreq, int deltatime )
        -:   81:{
        -:   82:	int delta;
        -:   83:
        -:   84:	/* Short interval */
        5:   85:	if ( deltatime < 4000 ) {
        5:   86:		delta = ( freq >= maxfreq ) ?
        2:   87:			min(
        2:   88:				( maxfreq - origfreq ) / 5 + 1,
        5:   89:				SHORT_INCREASE_FREQ ) :
        3:   90:			max(
        3:   91:				( maxfreq - origfreq ) / 5 + 1,
        -:   92:				SHORT_INCREASE_FREQ );
        5:   93:		return min( freq + delta, MAX_ALLOW_FREQ );
        -:   94:	}
        -:   95:	/* Medium interval */
    #####:   96:	else if ( deltatime < 50000 ) {
    #####:   97:		delta = ( freq >= maxfreq ) ?
    #####:   98:			min(
    #####:   99:				( maxfreq - origfreq ) / 10 + 1,
    #####:  100:				MEDIUM_INCREASE_FREQ ) :
    #####:  101:			max(
    #####:  102:				( maxfreq - origfreq ) / 10 + 1,
        -:  103:				MEDIUM_INCREASE_FREQ );
    #####:  104:		return min( freq + delta, MAX_ALLOW_FREQ );
        -:  105:	}
        -:  106:	/* long interval */
        -:  107:	else {
    #####:  108:		delta = max( ( freq - origfreq ) / 5, LONG_DECREASE_FREQ );
    #####:  109:		return max( freq - delta, origfreq );
        -:  110:	}
        -:  111:}
        -:  112:
       10:  113:int UserUpdatePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )
        -:  114:{
        -:  115:	HASH_ITEM *pItem;
        -:  116:	UserPhraseData data;
        -:  117:	int len;
        -:  118:
       10:  119:	len = ueStrLen( wordSeq );
       10:  120:	pItem = HashFindEntry( pgdata, phoneSeq, wordSeq );
       10:  121:	if ( ! pItem ) {
        5:  122:		if ( ! AlcUserPhraseSeq( &data, len, strlen( wordSeq ) ) ) {
    #####:  123:			return USER_UPDATE_FAIL;
        -:  124:		}
        -:  125:
        5:  126:		memcpy( data.phoneSeq, phoneSeq, len * sizeof( phoneSeq[ 0 ] ) );
        5:  127:		data.phoneSeq[ len ] = 0;
        5:  128:		strcpy( data.wordSeq, wordSeq );
        -:  129:
        -:  130:		/* load initial freq */
        5:  131:		data.origfreq = LoadOriginalFreq( pgdata, phoneSeq, wordSeq, len );
        5:  132:		data.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );
        -:  133:
        5:  134:		data.userfreq = data.origfreq;
        5:  135:		data.recentTime = pgdata->static_data.chewing_lifetime;
        5:  136:		pItem = HashInsert( pgdata, &data );
        5:  137:		HashModify( pgdata, pItem );
        5:  138:		return USER_UPDATE_INSERT;
        -:  139:	}
        -:  140:	else {
        5:  141:		pItem->data.maxfreq = LoadMaxFreq( pgdata, phoneSeq, len );
       10:  142:		pItem->data.userfreq = UpdateFreq(
        -:  143:			pItem->data.userfreq,
        -:  144:			pItem->data.maxfreq,
        -:  145:			pItem->data.origfreq,
        5:  146:			pgdata->static_data.chewing_lifetime - pItem->data.recentTime );
        5:  147:		pItem->data.recentTime = pgdata->static_data.chewing_lifetime;
        5:  148:		HashModify( pgdata, pItem );
        5:  149:		return USER_UPDATE_MODIFY;
        -:  150:	}
        -:  151:}
        -:  152:
      462:  153:UserPhraseData *UserGetPhraseFirst( ChewingData *pgdata, const uint16_t phoneSeq[] )
        -:  154:{
      462:  155:	pgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, NULL );
      462:  156:	if ( ! pgdata->prev_userphrase )
      297:  157:		return NULL;
      165:  158:	return &( pgdata->prev_userphrase->data );
        -:  159:}
        -:  160:
       85:  161:UserPhraseData *UserGetPhraseNext( ChewingData *pgdata, const uint16_t phoneSeq[] )
        -:  162:{
       85:  163:	pgdata->prev_userphrase = HashFindPhonePhrase( pgdata, phoneSeq, pgdata->prev_userphrase );
       85:  164:	if ( ! pgdata->prev_userphrase )
       85:  165:		return NULL;
    #####:  166:	return &( pgdata->prev_userphrase->data );
        -:  167:}
        -:  168:
