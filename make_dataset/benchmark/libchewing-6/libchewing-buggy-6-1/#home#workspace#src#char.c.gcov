        -:    0:Source:/home/workspace/src/char.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/char.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/char.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * char.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2005, 2006, 2008
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: * @file char.c
        -:   17: * @brief word data file
        -:   18: */
        -:   19:#if ! defined(USE_BINARY_DATA)
        -:   20:#include <assert.h>
        -:   21:#endif
        -:   22:#include <stdio.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <string.h>
        -:   25:
        -:   26:#include "global-private.h"
        -:   27:#include "chewing-definition.h"
        -:   28:#include "char-private.h"
        -:   29:#include "private.h"
        -:   30:#include "plat_mmap.h"
        -:   31:
        -:   32:#if ! defined(USE_BINARY_DATA)
        -:   33:static char *fgettab( char *buf, int maxlen, FILE *fp )
        -:   34:{
        -:   35:	int i;
        -:   36:
        -:   37:	for ( i = 0; i < maxlen; i++ ) {
        -:   38:		buf[ i ] = (char) fgetc( fp );
        -:   39:		if ( feof( fp ) )
        -:   40:			break;
        -:   41:		if ( buf[ i ] == '\t' )
        -:   42:			break;
        -:   43:	}
        -:   44:	if ( feof( fp ) )
        -:   45:		return 0;
        -:   46:	buf[ i ] = '\0';
        -:   47:	return buf;
        -:   48:}
        -:   49:#endif
        -:   50:
     2745:   51:static int CompUint16( const uint16_t *pa, const uint16_t *pb )
        -:   52:{
     2745:   53:	return ( (*pa) - (*pb) );
        -:   54:}
        -:   55:
       27:   56:void TerminateChar( ChewingData *pgdata )
        -:   57:{
        -:   58:#ifdef USE_BINARY_DATA
       27:   59:	pgdata->static_data.arrPhone = NULL;
       27:   60:	plat_mmap_close( &pgdata->static_data.char_phone_mmap );
        -:   61:
       27:   62:	pgdata->static_data.char_begin = NULL;
       27:   63:	plat_mmap_close( &pgdata->static_data.char_begin_mmap );
        -:   64:
       27:   65:	pgdata->static_data.char_ = NULL;
       27:   66:	plat_mmap_close( &pgdata->static_data.char_mmap );
        -:   67:
       27:   68:	pgdata->static_data.phone_num = 0;
        -:   69:#else
        -:   70:	if ( pgdata->static_data.charfile )
        -:   71:		fclose( pgdata->static_data.charfile );
        -:   72:	free( pgdata->static_data.char_begin );
        -:   73:	free( pgdata->static_data.arrPhone );
        -:   74:	pgdata->static_data.phone_num = 0;
        -:   75:#endif
       27:   76:}
        -:   77:
       27:   78:int InitChar( ChewingData *pgdata , const char * prefix )
        -:   79:{
        -:   80:#ifdef USE_BINARY_DATA
        -:   81:	char filename[ PATH_MAX ];
        -:   82:	size_t len;
        -:   83:	size_t offset;
        -:   84:	size_t file_size;
        -:   85:	size_t csize;
        -:   86:
       27:   87:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, CHAR_FILE );
       27:   88:	if ( len + 1 > sizeof( filename ) )
    #####:   89:		return -1;
        -:   90:
       27:   91:	plat_mmap_set_invalid( &pgdata->static_data.char_mmap );
       27:   92:	file_size = plat_mmap_create( &pgdata->static_data.char_mmap, filename, FLAG_ATTRIBUTE_READ );
       27:   93:	if ( file_size <= 0 )
    #####:   94:		return -1;
        -:   95:
       27:   96:	csize = file_size;
       27:   97:	offset = 0;
       27:   98:	pgdata->static_data.char_ = plat_mmap_set_view( &pgdata->static_data.char_mmap, &offset, &csize );
       27:   99:	if ( !pgdata->static_data.char_ )
    #####:  100:		return -1;
        -:  101:
       27:  102:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, CHAR_INDEX_BEGIN_FILE );
       27:  103:	if ( len + 1 > sizeof( filename ) )
    #####:  104:		return -1;
        -:  105:
       27:  106:	plat_mmap_set_invalid( &pgdata->static_data.char_begin_mmap );
       27:  107:	file_size = plat_mmap_create( &pgdata->static_data.char_begin_mmap, filename, FLAG_ATTRIBUTE_READ );
       27:  108:	if ( file_size <= 0 )
    #####:  109:		return -1;
        -:  110:
       27:  111:	pgdata->static_data.phone_num = file_size / sizeof( int );
        -:  112:
       27:  113:	offset = 0;
       27:  114:	csize = file_size;
       27:  115:	pgdata->static_data.char_begin = plat_mmap_set_view( &pgdata->static_data.char_begin_mmap, &offset, &csize );
       27:  116:	if ( !pgdata->static_data.char_begin )
    #####:  117:		return -1;
        -:  118:
       27:  119:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, CHAR_INDEX_PHONE_FILE );
       27:  120:	if ( len + 1 > sizeof( filename ) )
    #####:  121:		return -1;
        -:  122:
       27:  123:	plat_mmap_set_invalid( &pgdata->static_data.char_phone_mmap );
       27:  124:	file_size = plat_mmap_create( &pgdata->static_data.char_phone_mmap, filename, FLAG_ATTRIBUTE_READ );
       27:  125:	if ( file_size <= 0 )
    #####:  126:		return -1;
        -:  127:
       27:  128:	if ( pgdata->static_data.phone_num != file_size / sizeof( uint16_t ))
    #####:  129:		return -1;
        -:  130:
       27:  131:	offset = 0;
       27:  132:	csize = file_size;
       27:  133:	pgdata->static_data.arrPhone = plat_mmap_set_view( &pgdata->static_data.char_phone_mmap, &offset, &csize );
       27:  134:	if ( !pgdata->static_data.arrPhone )
    #####:  135:		return -1;
        -:  136:
       27:  137:	return 0;
        -:  138:#else
        -:  139:	char filename[ PATH_MAX ];
        -:  140:	int len;
        -:  141:	int i;
        -:  142:	FILE *indexfile = NULL;
        -:  143:
        -:  144:	pgdata->static_data.phone_num = PHONE_NUM;
        -:  145:
        -:  146:	pgdata->static_data.arrPhone = ALC( uint16_t, pgdata->static_data.phone_num );
        -:  147:	if ( !pgdata->static_data.arrPhone )
        -:  148:	    return -1;
        -:  149:
        -:  150:	pgdata->static_data.char_begin = ALC( int, pgdata->static_data.phone_num );
        -:  151:	if ( !pgdata->static_data.char_begin )
        -:  152:	    return -1;
        -:  153:
        -:  154:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, CHAR_FILE );
        -:  155:	if ( len + 1 > sizeof( filename ) )
        -:  156:		return -1;
        -:  157:
        -:  158:	pgdata->static_data.charfile = fopen( filename, "r" );
        -:  159:	if ( !pgdata->static_data.charfile )
        -:  160:		return -1;
        -:  161:
        -:  162:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, CHAR_INDEX_FILE );
        -:  163:	if ( len + 1 > sizeof( filename ) )
        -:  164:		return -1;
        -:  165:
        -:  166:	indexfile = fopen( filename, "r" );
        -:  167:	if ( !indexfile )
        -:  168:		return -1;
        -:  169:
        -:  170:	for ( i = 0; i < pgdata->static_data.phone_num; ++i )
        -:  171:		fscanf( indexfile, "%hu %d", &pgdata->static_data.arrPhone[i], &pgdata->static_data.char_begin[i] );
        -:  172:
        -:  173:	fclose( indexfile );
        -:  174:	return 0;
        -:  175:#endif
        -:  176:}
        -:  177:
      468:  178:static void Str2Word( ChewingData *pgdata, Word *wrd_ptr )
        -:  179:{
        -:  180:#ifndef USE_BINARY_DATA
        -:  181:	char buf[ 1000 ];
        -:  182:	uint16_t sh;
        -:  183:
        -:  184:	fgettab( buf, 1000, pgdata->static_data.charfile );
        -:  185:	/* only read 6 bytes to wrd_ptr->word avoid buffer overflow */
        -:  186:	sscanf( buf, "%hu %6[^ ]", &sh, wrd_ptr->word );
        -:  187:	assert( wrd_ptr->word[0] != '\0' );
        -:  188:#else
        -:  189:	unsigned char size;
      468:  190:	size = *(unsigned char *) pgdata->static_data.char_cur_pos;
      468:  191:	pgdata->static_data.char_cur_pos = (unsigned char*) pgdata->static_data.char_cur_pos + sizeof(unsigned char);
      468:  192:	memcpy( wrd_ptr->word, pgdata->static_data.char_cur_pos, size );
      468:  193:	pgdata->static_data.char_cur_pos = (unsigned char*) pgdata->static_data.char_cur_pos + size;
      468:  194:	wrd_ptr->word[ size ] = '\0';
        -:  195:#endif
      468:  196:}
        -:  197:
      299:  198:int GetCharFirst( ChewingData *pgdata, Word *wrd_ptr, uint16_t phoneid )
        -:  199:{
        -:  200:	uint16_t *pinx;
        -:  201:
      299:  202:	pinx = (uint16_t *) bsearch(
      299:  203:		&phoneid, pgdata->static_data.arrPhone, pgdata->static_data.phone_num,
        -:  204:		sizeof( uint16_t ), (CompFuncType) CompUint16 );
      299:  205:	if ( ! pinx )
    #####:  206:		return 0;
        -:  207:
        -:  208:#ifndef USE_BINARY_DATA
        -:  209:	fseek( pgdata->static_data.charfile, pgdata->static_data.char_begin[ pinx - pgdata->static_data.arrPhone ], SEEK_SET );
        -:  210:#else
      299:  211:	pgdata->static_data.char_cur_pos = (unsigned char*)pgdata->static_data.char_ + pgdata->static_data.char_begin[ pinx - pgdata->static_data.arrPhone ];
        -:  212:#endif
      299:  213:	pgdata->static_data.char_end_pos = pgdata->static_data.char_begin[ pinx - pgdata->static_data.arrPhone + 1 ];
      299:  214:	Str2Word( pgdata, wrd_ptr );
      299:  215:	return 1;
        -:  216:}
        -:  217:
      174:  218:int GetCharNext( ChewingData *pgdata, Word *wrd_ptr )
        -:  219:{
        -:  220:#ifndef USE_BINARY_DATA
        -:  221:	if ( ftell( pgdata->static_data.charfile ) >= pgdata->static_data.char_end_pos )
        -:  222:		return 0;
        -:  223:#else
      174:  224:	if ( (unsigned char*)pgdata->static_data.char_cur_pos >= (unsigned char*)pgdata->static_data.char_ + pgdata->static_data.char_end_pos )
        5:  225:		return 0;
        -:  226:#endif
      169:  227:	Str2Word( pgdata, wrd_ptr );
      169:  228:	return 1;
        -:  229:}
