        -:    0:Source:/home/workspace/src/chewingutil.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/chewingutil.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/chewingutil.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * chewingutil.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2005, 2006, 2008, 2010, 2011, 2012
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/* This file is encoded in UTF-8 */
        -:   16:#ifdef HAVE_CONFIG_H
        -:   17:#include <config.h>
        -:   18:#endif
        -:   19:
        -:   20:#include <ctype.h>
        -:   21:#include <string.h>
        -:   22:#include <assert.h>
        -:   23:#include <stdlib.h>
        -:   24:
        -:   25:#include "chewing-utf8-util.h"
        -:   26:#include "global.h"
        -:   27:#include "global-private.h"
        -:   28:#include "chewingutil.h"
        -:   29:#include "zuin-private.h"
        -:   30:#include "choice-private.h"
        -:   31:#include "tree-private.h"
        -:   32:#include "userphrase-private.h"
        -:   33:#include "private.h"
        -:   34:
        -:   35:#ifdef HAVE_ASPRINTF
        -:   36:/* asprintf is provided by GNU extensions and *BSD */
        -:   37:#ifndef _GNU_SOURCE
        -:   38:#define _GNU_SOURCE
        -:   39:#endif
        -:   40:#include <stdio.h>
        -:   41:#else
        -:   42:#include "plat_path.h"
        -:   43:#endif
        -:   44:
        -:   45:extern const char * const zhuin_tab[];
        -:   46:static void MakePreferInterval( ChewingData *pgdata );
        -:   47:static void ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata );
        -:   48:static int ChewingKillSelectIntervalAcross( int cursor, ChewingData *pgdata );
        -:   49:
        -:   50:static int FindSymbolKey( const char *symbol );
        -:   51:
        -:   52:/* Note: Keep synchronize with `FindEasySymbolIndex`! */
        -:   53:static const char G_EASY_SYMBOL_KEY[EASY_SYMBOL_KEY_TAB_LEN] = {
        -:   54:	'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        -:   55:	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J',
        -:   56:	'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T',
        -:   57:	'U', 'V', 'W', 'X', 'Y', 'Z'
        -:   58:};
        -:   59:
        -:   60:/*
        -:   61: * FindEasySymbolIndex(ch) = char ch's index in G_EASY_SYMBOL_KEY
        -:   62: * Just return -1 if not found.
        -:   63: */
      702:   64:static int FindEasySymbolIndex( char ch )
        -:   65:{
        -:   66:	/**
        -:   67:	 * '0' => 0, ..., '9' => 9
        -:   68:	 * 'A' => 10, 'B' => 11, ... 'Z' => 35
        -:   69:	 */
      702:   70:	if ( isdigit( ch ) ) {
    #####:   71:		return ch - '0';
        -:   72:	}
      702:   73:	else if ( isupper( ch ) ) {
      702:   74:		return ch - 'A' + 10;
        -:   75:	}
        -:   76:	else {
    #####:   77:		return -1;
        -:   78:	}
        -:   79:}
        -:   80:
    #####:   81:void SetUpdatePhraseMsg(
        -:   82:		ChewingData *pgdata, const char *addWordSeq,
        -:   83:		int len, int state )
        -:   84:{
    #####:   85:	const char *insert = "\xE5\x8A\xA0\xE5\x85\xA5\xEF\xBC\x9A";
        -:   86:		/* 加入： */
    #####:   87:	const char *modify = "\xE5\xB7\xB2\xE6\x9C\x89\xEF\xBC\x9A";
        -:   88:		/* 已有： */
    #####:   89:	int begin = 3, i;
        -:   90:	const char *msg;
        -:   91:
    #####:   92:	pgdata->showMsgLen = begin + len;
    #####:   93:	if ( state == USER_UPDATE_INSERT ) {
    #####:   94:		msg = insert;
        -:   95:	}
        -:   96:	else {
    #####:   97:		msg = modify;
        -:   98:	}
    #####:   99:	ueStrNCpy( (char *) pgdata->showMsg[ 0 ].s, msg, 1, 1 );
    #####:  100:	ueStrNCpy( (char *) pgdata->showMsg[ 1 ].s,
        -:  101:	           ueConstStrSeek( msg, 1 ),
        -:  102:		   1, 1 );
    #####:  103:	ueStrNCpy( (char *) pgdata->showMsg[ 2 ].s,
        -:  104:	           ueConstStrSeek( msg, 2 ),
        -:  105:		   1, 1 );
    #####:  106:	for ( i = 0; i < len; i++ ) {
    #####:  107:		ueStrNCpy( (char *) pgdata->showMsg[ begin + i ].s,
        -:  108:		           ueConstStrSeek( addWordSeq, i ),
        -:  109:			   1, 1);
        -:  110:	}
    #####:  111:}
        -:  112:
    #####:  113:int NoSymbolBetween( ChewingData *pgdata, int begin, int end )
        -:  114:{
        -:  115:	int i;
    #####:  116:	end = min( end, pgdata->chiSymbolBufLen );
        -:  117:
    #####:  118:	for ( i = begin; i < end; ++i )
    #####:  119:		if ( pgdata->chiSymbolBuf[ i ].wch != 0 )
    #####:  120:			return 0;
    #####:  121:	return 1;
        -:  122:}
        -:  123:
       52:  124:int ChewingIsEntering( ChewingData *pgdata )
        -:  125:{
       52:  126:	if ( pgdata->choiceInfo.isSymbol != WORD_CHOICE )
        3:  127:		return 1;
        -:  128:	return (
       57:  129:		pgdata->chiSymbolBufLen != 0 ||
        8:  130:		ZuinIsEntering( &( pgdata->zuinData ) ) );
        -:  131:}
        -:  132:
        7:  133:int HaninSymbolInput( ChewingData *pgdata )
        -:  134:{
        -:  135:	unsigned int i;
        -:  136:
        7:  137:	ChoiceInfo *pci = &( pgdata->choiceInfo );
        7:  138:	AvailInfo *pai = &( pgdata->availInfo );
        -:  139:
        -:  140:	/* No available symbol table */
        7:  141:	if ( ! pgdata->static_data.symbol_table )
    #####:  142:		return ZUIN_ABSORB;
        -:  143:
        7:  144:	pci->nTotalChoice = 0;
       98:  145:	for ( i = 0; i < pgdata->static_data.n_symbol_entry; i++ ) {
       91:  146:		strcpy( pci->totalChoiceStr[ pci->nTotalChoice ],
       91:  147:			pgdata->static_data.symbol_table[ i ]->category );
       91:  148:		pci->nTotalChoice++;
        -:  149:	}
        7:  150:	pai->avail[ 0 ].len = 1;
        7:  151:	pai->avail[ 0 ].id = -1;
        7:  152:	pai->nAvail = 1;
        7:  153:	pai->currentAvail = 0;
        7:  154:	pci->nChoicePerPage = pgdata->config.candPerPage;
       7*:  155:	assert( pci->nTotalChoice > 0 );
        7:  156:	pci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );
        7:  157:	pci->pageNo = 0;
        7:  158:	pci->isSymbol = SYMBOL_CATEGORY_CHOICE;
        7:  159:	return ZUIN_ABSORB;
        -:  160:}
        -:  161:
    #####:  162:static int _Inner_InternalSpecialSymbol(
        -:  163:		int key, ChewingData *pgdata,
        -:  164:		char symkey, const char * const chibuf )
        -:  165:{
        -:  166:	int kbtype;
        -:  167:
    #####:  168:	if ( key == symkey && NULL != chibuf ) {
    #####:  169:		assert( pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor );
    #####:  170:		memmove(
    #####:  171:			&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),
    #####:  172:			&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ),
    #####:  173:			sizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );
        -:  174:
    #####:  175:		pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;
    #####:  176:		ueStrNCpy( (char *) pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].s,
        -:  177:				chibuf, 1, 1);
        -:  178:		/* Save Symbol Key */
    #####:  179:		memmove(
    #####:  180:			&( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor + 1 ] ),
    #####:  181:			&( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ),
        -:  182:			sizeof( pgdata->symbolKeyBuf[0] ) *
    #####:  183:			( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );
    #####:  184:		pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = key;
    #####:  185:		pgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;
    #####:  186:		pgdata->chiSymbolCursor++;
    #####:  187:		pgdata->chiSymbolBufLen++;
        -:  188:		/* reset Zuin data */
        -:  189:		/* Don't forget the kbtype */
    #####:  190:		kbtype = pgdata->zuinData.kbtype;
    #####:  191:		memset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );
    #####:  192:		pgdata->zuinData.kbtype = kbtype;
    #####:  193:		return 1;
        -:  194:	}
    #####:  195:	return 0;
        -:  196:}
        -:  197:
    #####:  198:static int InternalSpecialSymbol(
        -:  199:		int key, ChewingData *pgdata,
        -:  200:		int nSpecial, const char keybuf[], const char * const chibuf[] )
        -:  201:{
    #####:  202:	int i, rtn = ZUIN_IGNORE; /* very strange and difficult to understand */
        -:  203:
    #####:  204:	for ( i = 0; i < nSpecial; i++ ) {
    #####:  205:		if ( 1 == _Inner_InternalSpecialSymbol( key, pgdata, keybuf[ i ], chibuf[ i ]) ) {
    #####:  206:			rtn = ZUIN_ABSORB;
    #####:  207:			break;
        -:  208:		}
        -:  209:	}
    #####:  210:	return rtn;
        -:  211:}
        -:  212:
    #####:  213:int SpecialSymbolInput( int key, ChewingData *pgdata )
        -:  214:{
        -:  215:	static const char keybuf[] = {
        -:  216:		'[', ']', '{', '}', '\'','<', ':', '\"', '>',
        -:  217:		'~', '!', '@', '#', '$', '%', '^', '&', '*',
        -:  218:		'(', ')', '_', '+', '=','\\', '|', '?',
        -:  219:		',', '.', ';'
        -:  220:	};
        -:  221:
        -:  222:	static const char * const chibuf[] = {
        -:  223:		"\xE3\x80\x8C", "\xE3\x80\x8D", "\xE3\x80\x8E", "\xE3\x80\x8F",
        -:  224:			/* "「", "」", "『", "』" */
        -:  225:		"\xE3\x80\x81", "\xEF\xBC\x8C", "\xEF\xBC\x9A", "\xEF\xBC\x9B",
        -:  226:			/* "、", "，", "：", "；" */
        -:  227:		"\xE3\x80\x82", "\xEF\xBD\x9E", "\xEF\xBC\x81", "\xEF\xBC\xA0",
        -:  228:			/* "。", "～", "！", "＠" */
        -:  229:		"\xEF\xBC\x83", "\xEF\xBC\x84", "\xEF\xBC\x85", "\xEF\xB8\xBF",
        -:  230:			/* "＃", "＄", "％", "︿" */
        -:  231:		"\xEF\xBC\x86", "\xEF\xBC\x8A", "\xEF\xBC\x88", "\xEF\xBC\x89",
        -:  232:			/* "＆", "＊", "（", "）" */
        -:  233:		"\xEF\xB9\x8D", "\xEF\xBC\x8B", "\xEF\xBC\x9D", "\xEF\xBC\xBC",
        -:  234:			/* "﹍", "＋", "＝", "＼" */
        -:  235:		"\xEF\xBD\x9C", "\xEF\xBC\x9F", "\xEF\xBC\x8C", "\xE3\x80\x82",
        -:  236:			/* "｜", "？", "，", "。" */
        -:  237:		"\xEF\xBC\x9B"
        -:  238:			/* "；" */
        -:  239:	};
        -:  240:	STATIC_ASSERT( ARRAY_SIZE( keybuf ) == ARRAY_SIZE( chibuf ), update_keybuf_and_chibuf );
        -:  241:
    #####:  242:	return InternalSpecialSymbol( key, pgdata, ARRAY_SIZE( keybuf ), keybuf, chibuf );
        -:  243:}
        -:  244:
    #####:  245:int FullShapeSymbolInput( int key, ChewingData *pgdata )
        -:  246:{
        -:  247:	int rtn;
        -:  248:	static char keybuf[] = {
        -:  249:		'0', '1', '2', '3',  '4',  '5', '6', '7', '8', '9',
        -:  250:		'a', 'b', 'c', 'd',  'e',  'f', 'g', 'h', 'i', 'j',
        -:  251:		'k', 'l', 'm', 'n',  'o',  'p', 'q', 'r', 's', 't',
        -:  252:		'u', 'v', 'w', 'x',  'y',  'z', 'A', 'B', 'C', 'D',
        -:  253:		'E', 'F', 'G', 'H',  'I',  'J', 'K', 'L', 'M', 'N',
        -:  254:		'O', 'P', 'Q', 'R',  'S',  'T', 'U', 'V', 'W', 'X',
        -:  255:		'Y', 'Z', ' ', '\"', '\'', '/', '<', '>', '`', '[',
        -:  256:		']', '{', '}', '+',  '-'
        -:  257:	};
        -:  258:	static const char *chibuf[] = {
        -:  259:		"\xEF\xBC\x90","\xEF\xBC\x91","\xEF\xBC\x92","\xEF\xBC\x93",
        -:  260:			/* "０","１","２","３" */
        -:  261:		"\xEF\xBC\x94","\xEF\xBC\x95","\xEF\xBC\x96","\xEF\xBC\x97",
        -:  262:			/* "４","５","６","７" */
        -:  263:		"\xEF\xBC\x98","\xEF\xBC\x99","\xEF\xBD\x81","\xEF\xBD\x82",
        -:  264:			/* "８","９","ａ","ｂ" */
        -:  265:		"\xEF\xBD\x83","\xEF\xBD\x84","\xEF\xBD\x85","\xEF\xBD\x86",
        -:  266:			/* "ｃ","ｄ","ｅ","ｆ" */
        -:  267:		"\xEF\xBD\x87","\xEF\xBD\x88","\xEF\xBD\x89","\xEF\xBD\x8A",
        -:  268:			/* "ｇ","ｈ","ｉ","ｊ" */
        -:  269:		"\xEF\xBD\x8B","\xEF\xBD\x8C","\xEF\xBD\x8D","\xEF\xBD\x8E",
        -:  270:			/* "ｋ","ｌ","ｍ","ｎ" */
        -:  271:		"\xEF\xBD\x8F","\xEF\xBD\x90","\xEF\xBD\x91","\xEF\xBD\x92",
        -:  272:			/* "ｏ","ｐ","ｑ","ｒ" */
        -:  273:		"\xEF\xBD\x93","\xEF\xBD\x94","\xEF\xBD\x95","\xEF\xBD\x96",
        -:  274:			/* "ｓ","ｔ","ｕ","ｖ" */
        -:  275:		"\xEF\xBD\x97","\xEF\xBD\x98","\xEF\xBD\x99","\xEF\xBD\x9A",
        -:  276:			/* "ｗ","ｘ","ｙ","ｚ" */
        -:  277:		"\xEF\xBC\xA1","\xEF\xBC\xA2","\xEF\xBC\xA3","\xEF\xBC\xA4",
        -:  278:			/* "Ａ","Ｂ","Ｃ","Ｄ" */
        -:  279:		"\xEF\xBC\xA5","\xEF\xBC\xA6","\xEF\xBC\xA7","\xEF\xBC\xA8",
        -:  280:			/* "Ｅ","Ｆ","Ｇ","Ｈ" */
        -:  281:		"\xEF\xBC\xA9","\xEF\xBC\xAA","\xEF\xBC\xAB","\xEF\xBC\xAC",
        -:  282:			/* "Ｉ","Ｊ","Ｋ","Ｌ" */
        -:  283:		"\xEF\xBC\xAD","\xEF\xBC\xAE","\xEF\xBC\xAF","\xEF\xBC\xB0",
        -:  284:			/* "Ｍ","Ｎ","Ｏ","Ｐ" */
        -:  285:		"\xEF\xBC\xB1","\xEF\xBC\xB2","\xEF\xBC\xB3","\xEF\xBC\xB4",
        -:  286:			/* "Ｑ","Ｒ","Ｓ","Ｔ" */
        -:  287:		"\xEF\xBC\xB5","\xEF\xBC\xB6","\xEF\xBC\xB7","\xEF\xBC\xB8",
        -:  288:			/* "Ｕ","Ｖ","Ｗ","Ｘ" */
        -:  289:		"\xEF\xBC\xB9","\xEF\xBC\xBA","\xE3\x80\x80","\xE2\x80\x9D",
        -:  290:			/* "Ｙ","Ｚ","　","”" */
        -:  291:		"\xE2\x80\x99","\xEF\xBC\x8F","\xEF\xBC\x9C","\xEF\xBC\x9E",
        -:  292:			/* "’","／","＜","＞" */
        -:  293:		"\xE2\x80\xB5","\xE3\x80\x94","\xE3\x80\x95","\xEF\xBD\x9B",
        -:  294:			/* "‵","〔""〕","｛" */
        -:  295:		"\xEF\xBD\x9D","\xEF\xBC\x8B","\xEF\xBC\x8D"
        -:  296:			/* "｝","＋","－" */
        -:  297:	};
        -:  298:	STATIC_ASSERT( ARRAY_SIZE( keybuf ) == ARRAY_SIZE( chibuf ), update_keybuf_and_chibuf );
        -:  299:
    #####:  300:	rtn = InternalSpecialSymbol( key, pgdata, ARRAY_SIZE( keybuf ), keybuf, chibuf );
    #####:  301:	if ( rtn == ZUIN_IGNORE )
    #####:  302:		rtn = SpecialSymbolInput( key, pgdata );
    #####:  303:	return (rtn == ZUIN_IGNORE ? SYMBOL_KEY_ERROR : SYMBOL_KEY_OK);
        -:  304:}
        -:  305:
    #####:  306:int EasySymbolInput( int key, ChewingData *pgdata )
        -:  307:{
        -:  308:	int rtn, loop, _index;
        -:  309:	char wordbuf[ 8 ];
        -:  310:
    #####:  311:	int nSpecial = EASY_SYMBOL_KEY_TAB_LEN;
        -:  312:
    #####:  313:	_index = FindEasySymbolIndex( key );
    #####:  314:	if ( -1 != _index ) {
    #####:  315:		for ( loop = 0; loop < pgdata->static_data.g_easy_symbol_num[ _index ]; ++loop ) {
    #####:  316:			ueStrNCpy( wordbuf,
    #####:  317:				ueStrSeek( pgdata->static_data.g_easy_symbol_value[ _index ],
        -:  318:					loop),
        -:  319:				1, 1 );
    #####:  320:			rtn = _Inner_InternalSpecialSymbol(
        -:  321:					key, pgdata, key, wordbuf );
        -:  322:		}
    #####:  323:		return SYMBOL_KEY_OK;
        -:  324:	}
        -:  325:
    #####:  326:	rtn = InternalSpecialSymbol(
        -:  327:			key, pgdata, nSpecial,
    #####:  328:			G_EASY_SYMBOL_KEY, (const char **) pgdata->static_data.g_easy_symbol_value );
    #####:  329:	if ( rtn == ZUIN_IGNORE )
    #####:  330:		rtn = SpecialSymbolInput( key, pgdata );
    #####:  331:	return ( rtn == ZUIN_IGNORE ? SYMBOL_KEY_ERROR : SYMBOL_KEY_OK );
        -:  332:}
        -:  333:
        7:  334:int SymbolChoice( ChewingData *pgdata, int sel_i )
        -:  335:{
        -:  336:	int kbtype;
        -:  337:	int i;
        -:  338:	int symbol_type;
        -:  339:	int key;
        -:  340:
       7*:  341:	if ( ! pgdata->static_data.symbol_table && pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_UPDATE )
    #####:  342:		return ZUIN_ABSORB;
        -:  343:
        7:  344:	if ( pgdata->choiceInfo.isSymbol == SYMBOL_CATEGORY_CHOICE &&
        4:  345:			0 == pgdata->static_data.symbol_table[sel_i]->nSymbols )
        1:  346:		symbol_type = SYMBOL_CHOICE_INSERT;
        -:  347:	else
        6:  348:		symbol_type = pgdata->choiceInfo.isSymbol;
        -:  349:
        -:  350:	/* level one, symbol category */
        7:  351:	if ( symbol_type == SYMBOL_CATEGORY_CHOICE ) {
        3:  352:		ChoiceInfo* pci = &pgdata->choiceInfo;
        3:  353:		AvailInfo* pai = &pgdata->availInfo;
        -:  354:
        -:  355:		/* Display all symbols in this category */
        3:  356:		pci->nTotalChoice = 0;
       96:  357:		for ( i = 0; i < pgdata->static_data.symbol_table[ sel_i ]->nSymbols; i++ ) {
       93:  358:			ueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],
       93:  359:					pgdata->static_data.symbol_table[ sel_i ]->symbols[ i ], 1, 1 );
       93:  360:			pci->nTotalChoice++;
        -:  361:		}
        3:  362:		pai->avail[ 0 ].len = 1;
        3:  363:		pai->avail[ 0 ].id = -1;
        3:  364:		pai->nAvail = 1;
        3:  365:		pai->currentAvail = 0;
        3:  366:		pci->nChoicePerPage = pgdata->config.candPerPage;
       3*:  367:		assert( pci->nTotalChoice > 0 );
        3:  368:		pci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );
        3:  369:		pci->pageNo = 0;
        3:  370:		pci->isSymbol = SYMBOL_CHOICE_INSERT;
        -:  371:	}
        -:  372:	else { /* level 2 symbol or OpenSymbolChoice */
        -:  373:		/* TODO: FIXME, this part is buggy! */
        4:  374:		if ( symbol_type == SYMBOL_CHOICE_INSERT ) {
       4*:  375:			assert( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );
        4:  376:			memmove(
        4:  377:				&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),
        4:  378:				&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ),
        4:  379:				sizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );
        -:  380:		}
        4:  381:		pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;
        4:  382:		ueStrNCpy( (char *) pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].s,
        4:  383:				pgdata->choiceInfo.totalChoiceStr[ sel_i ], 1, 1);
        -:  384:
        -:  385:		/* This is very strange */
        4:  386:		key = FindSymbolKey( pgdata->choiceInfo.totalChoiceStr[ sel_i ] );
       4*:  387:		pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = key ? key : '0';
        -:  388:
        4:  389:		pgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;
        4:  390:		ChoiceEndChoice(pgdata);
        -:  391:		/* Don't forget the kbtype */
        4:  392:		kbtype = pgdata->zuinData.kbtype;
        4:  393:		memset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );
        4:  394:		pgdata->zuinData.kbtype = kbtype;
        -:  395:
        4:  396:		if ( symbol_type == SYMBOL_CHOICE_INSERT ) {
        4:  397:			pgdata->chiSymbolBufLen++;
        4:  398:			pgdata->chiSymbolCursor ++ ;
        -:  399:		}
        -:  400:
        4:  401:		pgdata->choiceInfo.isSymbol = WORD_CHOICE;
        -:  402:	}
        7:  403:	return ZUIN_ABSORB;
        -:  404:}
        -:  405:
       15:  406:int SymbolInput( int key, ChewingData *pgdata )
        -:  407:{
       15:  408:	if ( isprint( (char) key ) && /* other character was ignored */
       15:  409:	     (pgdata->chiSymbolBufLen < MAX_PHONE_SEQ_LEN) ) { /* protect the buffer */
      15*:  410:		assert( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );
       15:  411:		memmove(
       15:  412:			&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),
       15:  413:			&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ),
       15:  414:			sizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );
        -:  415:
       15:  416:		pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;
       15:  417:		pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].s[ 0 ] = (char) key;
        -:  418:
        -:  419:		/* Save Symbol Key */
       15:  420:		memmove( &( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor + 1 ] ),
       15:  421:			&( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ),
        -:  422:			sizeof( pgdata->symbolKeyBuf[ 0 ] ) *
       15:  423:			( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );
       15:  424:			pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] = toupper( key );
        -:  425:
       15:  426:		pgdata->bUserArrCnnct[ PhoneSeqCursor( pgdata ) ] = 0;
       15:  427:		pgdata->chiSymbolCursor++;
       15:  428:		pgdata->chiSymbolBufLen++;
       15:  429:		return SYMBOL_KEY_OK;
        -:  430:	}
    #####:  431:	return SYMBOL_KEY_ERROR;
        -:  432:}
        -:  433:
    #####:  434:static int CompInterval( const IntervalType *a, const IntervalType *b )
        -:  435:{
    #####:  436:	int cmp = a->from - b->from;
    #####:  437:	if ( cmp )
    #####:  438:		return cmp;
    #####:  439:	return ( a->to - b->to );
        -:  440:}
        -:  441:
    #####:  442:static int FindIntervalFrom( int from, IntervalType inte[], int nInte )
        -:  443:{
        -:  444:	int i;
        -:  445:
    #####:  446:	for ( i = 0; i < nInte; i++ )
    #####:  447:		if ( inte[ i ].from == from )
    #####:  448:			return i;
    #####:  449:	return -1;
        -:  450:}
        -:  451:
        6:  452:int WriteChiSymbolToBuf( wch_t csBuf[], int csBufLen, ChewingData *pgdata )
        -:  453:{
        6:  454:	int i, phoneseq_i = 0;
        -:  455:
       18:  456:	for ( i = 0 ; i < csBufLen; i++ ) {
       12:  457:		if ( ChewingIsChiAt( i, pgdata ) ) {
        -:  458:			/*
        -:  459:			 * Workaround to avoid different initialization behavior
        -:  460:			 * among Win32 and Unix-like OSs.
        -:  461:			 */
       11:  462:			memset( &( csBuf[ i ].s ), 0, MAX_UTF8_SIZE + 1 );
       11:  463:			ueStrNCpy( (char *) csBuf[ i ].s,
       11:  464:			           &( pgdata->phrOut.chiBuf[ phoneseq_i ] ),
        -:  465:				   1, 1);
       11:  466:			phoneseq_i += ueBytesFromChar( pgdata->phrOut.chiBuf[ phoneseq_i ] );
        -:  467:		}
        -:  468:		else
        1:  469:			csBuf[ i ] = pgdata->chiSymbolBuf[ i ];
        -:  470:	}
        6:  471:	return 0;
        -:  472:}
        -:  473:
      128:  474:static int CountReleaseNum( ChewingData *pgdata )
        -:  475:{
        -:  476:	int remain, i;
        -:  477:
      128:  478:	remain = pgdata->config.maxChiSymbolLen - pgdata->chiSymbolBufLen;
      128:  479:	if ( remain >= 0 )
      128:  480:		return 0;
        -:  481:
    #####:  482:	qsort(
    #####:  483:		pgdata->preferInterval,
    #####:  484:		pgdata->nPrefer,
        -:  485:		sizeof( IntervalType ),
        -:  486:		(CompFuncType) CompInterval );
        -:  487:
    #####:  488:	if ( ! ChewingIsChiAt( 0, pgdata ) ) {
    #####:  489:		for ( i = 0; i < pgdata->chiSymbolCursor; ++i ) {
    #####:  490:			if ( ChewingIsChiAt( i, pgdata ) ) {
    #####:  491:				break;
        -:  492:			}
        -:  493:		}
    #####:  494:		return i;
        -:  495:	}
        -:  496:
    #####:  497:	i = FindIntervalFrom( 0, pgdata->preferInterval, pgdata->nPrefer );
    #####:  498:	if ( i >= 0 ) {
    #####:  499:		return ( pgdata->preferInterval[ i ].to - pgdata->preferInterval[ i ].from );
        -:  500:	}
        -:  501:
    #####:  502:	return 1;
        -:  503:}
        -:  504:
    #####:  505:static void KillFromLeft( ChewingData *pgdata, int nKill )
        -:  506:{
        -:  507:	int i;
        -:  508:
    #####:  509:	for ( i = 0; i < nKill; i++ )
    #####:  510:		ChewingKillChar( pgdata, 0, DECREASE_CURSOR );
    #####:  511:}
        -:  512:
        6:  513:void CleanAllBuf( ChewingData *pgdata )
        -:  514:{
        -:  515:	/* 1 */
        6:  516:	pgdata->nPhoneSeq = 0 ;
        6:  517:	memset( pgdata->phoneSeq, 0, sizeof( pgdata->phoneSeq ) );
        -:  518:	/* 2 */
        6:  519:	pgdata->chiSymbolBufLen = 0;
        6:  520:	memset( pgdata->chiSymbolBuf, 0, sizeof( pgdata->chiSymbolBuf ) );
        -:  521:	/* 3 */
        6:  522:	memset( pgdata->bUserArrBrkpt, 0, sizeof( pgdata->bUserArrBrkpt ) );
        -:  523:	/* 4 */
        6:  524:	pgdata->nSelect = 0;
        -:  525:	/* 5 */
        6:  526:	pgdata->chiSymbolCursor = 0;
        -:  527:	/* 6 */
        6:  528:	memset( pgdata->bUserArrCnnct, 0, sizeof( pgdata->bUserArrCnnct ) );
        -:  529:
        6:  530:	pgdata->phrOut.nNumCut = 0;
        -:  531:
        6:  532:	memset( pgdata->symbolKeyBuf, 0, sizeof( pgdata->symbolKeyBuf ) );
        -:  533:
        6:  534:	pgdata->nPrefer = 0;
        6:  535:}
        -:  536:
      128:  537:int ReleaseChiSymbolBuf( ChewingData *pgdata, ChewingOutput *pgo )
        -:  538:{
        -:  539:	int throwEnd;
        -:  540:	uint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  541:	char bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];
        -:  542:
      128:  543:	throwEnd = CountReleaseNum( pgdata );
        -:  544:
      128:  545:	pgo->nCommitStr = throwEnd;
      128:  546:	if ( throwEnd ) {
        -:  547:		/*
        -:  548:		 * count how many chinese words in "chiSymbolBuf[ 0 .. (throwEnd - 1)]"
        -:  549:		 * And release from "chiSymbolBuf" && "phoneSeq"
        -:  550:		 */
    #####:  551:		WriteChiSymbolToBuf( pgo->commitStr, throwEnd, pgdata );
        -:  552:
        -:  553:		/* Add to userphrase */
    #####:  554:		memcpy( bufPhoneSeq, pgdata->phoneSeq, sizeof( uint16_t ) * throwEnd );
    #####:  555:		bufPhoneSeq[ throwEnd ] = (uint16_t) 0;
    #####:  556:		ueStrNCpy( bufWordSeq, pgdata->phrOut.chiBuf, throwEnd, 1 );
    #####:  557:		UserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );
        -:  558:
    #####:  559:		KillFromLeft( pgdata, throwEnd );
        -:  560:	}
      128:  561:	return throwEnd;
        -:  562:}
        -:  563:
        1:  564:static int ChewingIsBreakPoint( int cursor, ChewingData *pgdata )
        -:  565:{
        -:  566:	static const char * const break_word[] = {
        -:  567:		"\xE6\x98\xAF", "\xE7\x9A\x84", "\xE4\xBA\x86", "\xE4\xB8\x8D",
        -:  568:		/* 是              的              了              不 */
        -:  569:		"\xE4\xB9\x9F", "\xE8\x80\x8C", "\xE4\xBD\xA0", "\xE6\x88\x91",
        -:  570:		/* 也              而              你              我 */
        -:  571:		"\xE4\xBB\x96", "\xE8\x88\x87", "\xE5\xAE\x83", "\xE5\xA5\xB9",
        -:  572:		/* 他              與              它              她 */
        -:  573:		"\xE5\x85\xB6", "\xE5\xB0\xB1", "\xE5\x92\x8C", "\xE6\x88\x96",
        -:  574:		/* 其              就              和              或 */
        -:  575:		"\xE5\x80\x91", "\xE6\x80\xA7", "\xE5\x93\xA1", "\xE5\xAD\x90",
        -:  576:		/* 們              性              員              子 */
        -:  577:		"\xE4\xB8\x8A", "\xE4\xB8\x8B", "\xE4\xB8\xAD", "\xE5\x85\xA7",
        -:  578:		/* 上              下              中              內 */
        -:  579:		"\xE5\xA4\x96", "\xE5\x8C\x96", "\xE8\x80\x85", "\xE5\xAE\xB6",
        -:  580:		/* 外              化              者              家 */
        -:  581:		"\xE5\x85\x92", "\xE5\xB9\xB4", "\xE6\x9C\x88", "\xE6\x97\xA5",
        -:  582:		/* 兒              年              月              日 */
        -:  583:		"\xE6\x99\x82", "\xE5\x88\x86", "\xE7\xA7\x92", "\xE8\xA1\x97",
        -:  584:		/* 時              分              秒              街 */
        -:  585:		"\xE8\xB7\xAF", "\xE6\x9D\x91",
        -:  586:		/* 路              村 */
        -:  587:		"\xE5\x9C\xA8",
        -:  588:		/* 在 */
        -:  589:	};
        -:  590:	char buf[ MAX_UTF8_SIZE + 1 ];
        1:  591:	int i = 0, symbols = 0;
       1*:  592:	for ( i = 0; i < cursor; i++ )
    #####:  593:		if ( ! ChewingIsChiAt ( i + symbols, pgdata ) )
    #####:  594:			symbols++;
        1:  595:	if ( ! ChewingIsChiAt( i + symbols, pgdata ) )
    #####:  596:		return 1;
        -:  597:	else {
        1:  598:		ueStrNCpy( buf,
        1:  599:				ueStrSeek( (char *) &pgdata->phrOut.chiBuf, cursor ),
        -:  600:				1, 1 );
       40:  601:		for ( i = 0; (size_t) i < ARRAY_SIZE( break_word ); i++ ) {
       39:  602:			if ( ! strcmp ( buf, break_word[ i ] ) )
    #####:  603:				return 1;
        -:  604:		}
        -:  605:	}
        1:  606:	return 0;
        -:  607:}
        -:  608:
        6:  609:void AutoLearnPhrase( ChewingData *pgdata )
        -:  610:{
        -:  611:	uint16_t bufPhoneSeq[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  612:	char bufWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];
        -:  613:	int i, from, len;
        6:  614:	int prev_pos = 0;
        6:  615:	int pending = 0;
        -:  616:
       11:  617:	for ( i = 0; i < pgdata->nPrefer; i++ ) {
        5:  618:		from = pgdata->preferInterval[ i ].from;
        5:  619:		len = pgdata->preferInterval[i].to - from;
        5:  620:		if ( len == 1 && ! ChewingIsBreakPoint( from, pgdata ) ) {
        1:  621:			memcpy( bufPhoneSeq + prev_pos, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );
        1:  622:			bufPhoneSeq[ prev_pos + len ] = (uint16_t) 0;
        1:  623:			ueStrNCpy( ueStrSeek( bufWordSeq, prev_pos ),
        1:  624:					ueStrSeek( (char *) &pgdata->phrOut.chiBuf, from ),
        -:  625:					len, 1);
        1:  626:			prev_pos += len;
        1:  627:			pending = 1;
        -:  628:		}
        -:  629:		else {
        4:  630:			if ( pending ) {
    #####:  631:				UserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );
    #####:  632:				prev_pos = 0;
    #####:  633:				pending = 0;
        -:  634:			}
        4:  635:			memcpy( bufPhoneSeq, &pgdata->phoneSeq[ from ], sizeof( uint16_t ) * len );
        4:  636:			bufPhoneSeq[ len ] = (uint16_t) 0;
        4:  637:			ueStrNCpy( bufWordSeq,
        4:  638:					ueStrSeek( (char *) &pgdata->phrOut.chiBuf, from ),
        -:  639:					len, 1);
        4:  640:			UserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );
        -:  641:		}
        -:  642:	}
        6:  643:	if ( pending ) {
        1:  644:		UserUpdatePhrase( pgdata, bufPhoneSeq, bufWordSeq );
        1:  645:		prev_pos = 0;
        1:  646:		pending = 0;
        -:  647:	}
        6:  648:}
        -:  649:
       38:  650:int AddChi( uint16_t phone, uint16_t phoneAlt, ChewingData *pgdata )
        -:  651:{
        -:  652:	int i;
       38:  653:	int cursor = PhoneSeqCursor( pgdata );
        -:  654:
        -:  655:	/* shift the selectInterval */
      38*:  656:	for ( i = 0; i < pgdata->nSelect; i++ ) {
    #####:  657:		if ( pgdata->selectInterval[ i ].from >= cursor ) {
    #####:  658:			pgdata->selectInterval[ i ].from++;
    #####:  659:			pgdata->selectInterval[ i ].to++;
        -:  660:		}
        -:  661:	}
        -:  662:
        -:  663:	/* shift the Brkpt */
      38*:  664:	assert( pgdata->nPhoneSeq >= cursor );
       38:  665:	memmove(
       38:  666:		&( pgdata->bUserArrBrkpt[ cursor + 2 ] ),
       38:  667:		&( pgdata->bUserArrBrkpt[ cursor + 1 ] ),
       38:  668:		sizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );
       38:  669:	memmove(
       38:  670:		&( pgdata->bUserArrCnnct[ cursor + 2 ] ),
       38:  671:		&( pgdata->bUserArrCnnct[ cursor + 1 ] ),
       38:  672:		sizeof( int ) * ( pgdata->nPhoneSeq - cursor ) );
        -:  673:
        -:  674:	/* add to phoneSeq */
       38:  675:	memmove(
       38:  676:		&( pgdata->phoneSeq[ cursor + 1 ] ),
       38:  677:		&( pgdata->phoneSeq[ cursor ] ) ,
       38:  678:		sizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );
       38:  679:	pgdata->phoneSeq[ cursor ] = phone;
       38:  680:	memmove(
       38:  681:		&( pgdata->phoneSeqAlt[ cursor + 1 ] ),
       38:  682:		&( pgdata->phoneSeqAlt[ cursor ] ) ,
       38:  683:		sizeof( uint16_t ) * ( pgdata->nPhoneSeq - cursor ) );
       38:  684:	pgdata->phoneSeqAlt[ cursor ] = phoneAlt;
       38:  685:	pgdata->nPhoneSeq ++;
        -:  686:
        -:  687:	/* add to chiSymbolBuf */
      38*:  688:	assert( pgdata->chiSymbolBufLen >= pgdata->chiSymbolCursor );
       38:  689:	memmove(
       38:  690:		&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor + 1 ] ),
       38:  691:		&( pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ] ) ,
       38:  692:		sizeof( wch_t ) * ( pgdata->chiSymbolBufLen - pgdata->chiSymbolCursor ) );
        -:  693:	/* "0" means Chinese word */
       38:  694:	pgdata->chiSymbolBuf[ pgdata->chiSymbolCursor ].wch = 0;
       38:  695:	pgdata->chiSymbolBufLen++;
       38:  696:	pgdata->chiSymbolCursor++;
        -:  697:
       38:  698:	return 0;
        -:  699:}
        -:  700:
      254:  701:static void ShowChewingData( ChewingData *pgdata )
        -:  702:{
        -:  703:	int i ;
        -:  704:
      254:  705:	DEBUG_OUT(
        -:  706:		"nPhoneSeq : %d\n"
        -:  707:		"phoneSeq  : ",
        -:  708:		pgdata->nPhoneSeq );
      510:  709:	for ( i = 0; i < pgdata->nPhoneSeq; i++ )
      256:  710:		DEBUG_OUT( "%hu ", pgdata->phoneSeq[ i ] );
      254:  711:	DEBUG_OUT(
        -:  712:		"[cursor : %d]\n"
        -:  713:		"nSelect : %d\n"
        -:  714:		"selectStr       selectInterval\n",
        -:  715:		PhoneSeqCursor( pgdata ),
        -:  716:		pgdata->nSelect );
      265:  717:	for ( i = 0; i < pgdata->nSelect; i++ ) {
       11:  718:		DEBUG_OUT(
        -:  719:			"  %14s%4d%4d\n",
        -:  720:			pgdata->selectStr[ i ],
        -:  721:			pgdata->selectInterval[ i ].from,
        -:  722:			pgdata->selectInterval[ i ].to );
        -:  723:	}
        -:  724:
      254:  725:	DEBUG_OUT( "bUserArrCnnct : " );
      764:  726:	for ( i = 0; i <= pgdata->nPhoneSeq; i++ )
      510:  727:		DEBUG_OUT( "%d ", pgdata->bUserArrCnnct[ i ] );
      254:  728:	DEBUG_OUT( "\n" );
        -:  729:
      254:  730:	DEBUG_OUT( "bUserArrBrkpt : " );
      764:  731:	for ( i = 0; i <= pgdata->nPhoneSeq; i++ )
      510:  732:		DEBUG_OUT( "%d ", pgdata->bUserArrBrkpt[ i ] );
      254:  733:	DEBUG_OUT( "\n" );
        -:  734:
      254:  735:	DEBUG_OUT( "bArrBrkpt     : " );
      764:  736:	for ( i = 0; i <= pgdata->nPhoneSeq; i++ )
      510:  737:		DEBUG_OUT( "%d ", pgdata->bArrBrkpt[ i ] );
      254:  738:	DEBUG_OUT( "\n" );
        -:  739:
      254:  740:	DEBUG_OUT(
        -:  741:		"bChiSym : %d , bSelect : %d\n",
        -:  742:		pgdata->bChiSym,
        -:  743:		pgdata->bSelect );
      254:  744:}
        -:  745:
      254:  746:int CallPhrasing( ChewingData *pgdata )
        -:  747:{
        -:  748:	/* set "bSymbolArrBrkpt" && "bArrBrkpt" */
      254:  749:	int i, ch_count = 0;
        -:  750:
      254:  751:	memcpy(
      254:  752:		pgdata->bArrBrkpt,
      254:  753:		pgdata->bUserArrBrkpt,
        -:  754:		(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );
      254:  755:	memset(
      254:  756:		pgdata->bSymbolArrBrkpt, 0,
        -:  757:		(MAX_PHONE_SEQ_LEN + 1) * sizeof( int ) );
        -:  758:
      532:  759:	for ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {
      278:  760:		if ( ChewingIsChiAt( i, pgdata ) )
      256:  761:			ch_count++;
        -:  762:		else {
       22:  763:			pgdata->bArrBrkpt[ ch_count ] = 1;
       22:  764:			pgdata->bSymbolArrBrkpt[ ch_count ] = 1;
        -:  765:		}
        -:  766:	}
        -:  767:
        -:  768:	/* kill select interval */
      510:  769:	for ( i = 0; i < pgdata->nPhoneSeq; i++ ) {
      256:  770:		if ( pgdata->bArrBrkpt[ i ] ) {
        7:  771:			ChewingKillSelectIntervalAcross( i, pgdata );
        -:  772:		}
        -:  773:	}
        -:  774:
      254:  775:	ShowChewingData(pgdata);
        -:  776:
        -:  777:	/* then phrasing */
      254:  778:	Phrasing( pgdata );
        -:  779:
        -:  780:	/* and then make prefer interval */
      254:  781:	MakePreferInterval( pgdata );
        -:  782:
      254:  783:	return 0;
        -:  784:}
        -:  785:
        -:  786:
        1:  787:static void Union( int set1,int set2, int parent[] )
        -:  788:{
        1:  789:	if ( set1 != set2 )
        1:  790:		parent[ max( set1, set2 ) ] = min( set1, set2 );
        1:  791:}
        -:  792:
      103:  793:static int SameSet( int set1,int set2, int parent[] )
        -:  794:{
      103:  795:	while ( parent[ set1 ] != 0 ) {
    #####:  796:		set1 = parent[ set1 ];
        -:  797:	}
      104:  798:	while ( parent[ set2 ] != 0 ) {
        1:  799:		set2 = parent[ set2 ];
        -:  800:	}
      103:  801:	return ( set1 == set2 );
        -:  802:}
        -:  803:
        -:  804:/* make prefer interval from phrOut->dispInterval */
      254:  805:static void MakePreferInterval( ChewingData *pgdata )
        -:  806:{
        -:  807:	int i, j, set_no;
        -:  808:	int belong_set[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  809:	int parent[ MAX_PHONE_SEQ_LEN + 1 ];
        -:  810:
      254:  811:	memset( belong_set, 0 , sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );
      254:  812:	memset( parent, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );
        -:  813:
        -:  814:	/* for each interval */
      441:  815:	for ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {
      630:  816:		for (
      187:  817:			j = pgdata->phrOut.dispInterval[ i ].from;
      443:  818:			j < pgdata->phrOut.dispInterval[ i ].to;
      256:  819:			j++ ) {
      256:  820:			belong_set[ j ] = i + 1;
        -:  821:		}
        -:  822:	}
      254:  823:	set_no = i + 1;
      510:  824:	for ( i = 0; i < pgdata->nPhoneSeq; i++ )
      256:  825:		if ( belong_set[i] == 0 )
    #####:  826:			belong_set[ i ] = set_no++;
        -:  827:
        -:  828:	/* for each connect point */
      357:  829:	for ( i = 1; i < pgdata->nPhoneSeq; i++ ) {
      103:  830:		if ( pgdata->bUserArrCnnct[ i ] ) {
        1:  831:			Union( belong_set[ i - 1 ], belong_set[ i ], parent );
        -:  832:		}
        -:  833:	}
        -:  834:
        -:  835:	/* generate new intervals */
      254:  836:	pgdata->nPrefer = 0;
      254:  837:	i = 0;
      440:  838:	while ( i < pgdata->nPhoneSeq ) {
      256:  839:		for ( j = i + 1; j < pgdata->nPhoneSeq; j++ )
      103:  840:			if ( ! SameSet( belong_set[ i ], belong_set[ j ], parent ) )
       33:  841:				break;
        -:  842:
      186:  843:		pgdata->preferInterval[ pgdata->nPrefer ].from = i;
      186:  844:		pgdata->preferInterval[ pgdata->nPrefer ].to = j;
      186:  845:		pgdata->nPrefer++;
      186:  846:		i = j;
        -:  847:	}
      254:  848:}
        -:  849:
        -:  850:/* for MakeOutput */
      188:  851:static void ShiftInterval( ChewingOutput *pgo, ChewingData *pgdata )
        -:  852:{
      188:  853:	int i, arrPos[ MAX_PHONE_SEQ_LEN ], k = 0, from, len;
        -:  854:
      407:  855:	for ( i = 0; i < pgdata->chiSymbolBufLen; i++ ) {
      219:  856:		if ( ChewingIsChiAt( i, pgdata ) ) {
      207:  857:			arrPos[ k++ ] = i;
        -:  858:		}
        -:  859:	}
      188:  860:	arrPos[ k ] = i;
        -:  861:
      188:  862:	pgo->nDispInterval = pgdata->nPrefer;
      320:  863:	for ( i = 0; i < pgdata->nPrefer; i++ ) {
      132:  864:		from = pgdata->preferInterval[ i ].from;
      132:  865:		len = pgdata->preferInterval[ i ].to - from;
      132:  866:		pgo->dispInterval[ i ].from = arrPos[ from ];
      132:  867:		pgo->dispInterval[ i ].to = arrPos[ from ] + len;
        -:  868:	}
      188:  869:}
        -:  870:
      188:  871:static int MakeOutput( ChewingOutput *pgo, ChewingData *pgdata )
        -:  872:{
        -:  873:	int chi_i, chiSymbol_i, i ;
        -:  874:
        -:  875:	/* fill zero to chiSymbolBuf first */
      188:  876:	memset( pgo->chiSymbolBuf, 0, sizeof( wch_t ) * MAX_PHONE_SEQ_LEN );
        -:  877:
        -:  878:	/* fill chiSymbolBuf */
      595:  879:	for (
      188:  880:		chi_i = chiSymbol_i = 0;
      407:  881:		chiSymbol_i < pgdata->chiSymbolBufLen;
      219:  882:		chiSymbol_i ++ ) {
      219:  883:		if ( pgdata->chiSymbolBuf[ chiSymbol_i ].wch == 0 ) {
        -:  884:			/* is Chinese, then copy from the PhrasingOutput "phrOut" */
      207:  885:			pgo->chiSymbolBuf[ chiSymbol_i ].wch = 0;
      207:  886:			ueStrNCpy( (char *) pgo->chiSymbolBuf[ chiSymbol_i ].s,
      207:  887:			           &( pgdata->phrOut.chiBuf[ chi_i ] ),
        -:  888:			           1, 1 );
      207:  889:			chi_i += ueBytesFromChar( pgo->chiSymbolBuf[ chiSymbol_i ].s[0] );
        -:  890:		}
        -:  891:		else {
        -:  892:			/* is Symbol */
       12:  893:			pgo->chiSymbolBuf[ chiSymbol_i ] = pgdata->chiSymbolBuf[ chiSymbol_i ];
        -:  894:		}
        -:  895:	}
        -:  896:
        -:  897:	/* fill point */
      188:  898:	pgo->PointStart = pgdata->PointStart;
      188:  899:	pgo->PointEnd = pgdata->PointEnd;
        -:  900:
        -:  901:	/* fill other fields */
      188:  902:	pgo->chiSymbolBufLen = pgdata->chiSymbolBufLen;
      188:  903:	pgo->chiSymbolCursor = pgdata->chiSymbolCursor;
        -:  904:
        -:  905:	/* fill zuinBuf */
      188:  906:	if ( pgdata->zuinData.kbtype >= KB_HANYU_PINYIN ) {
    #####:  907:		const char *p = pgdata->zuinData.pinYinData.keySeq;
        -:  908:		/*
        -:  909:		 * Copy from old content in zuinBuf
        -:  910:		 * NOTE: No Unicode transformation here.
        -:  911:		 */
    #####:  912:		for ( i = 0; i< ZUIN_SIZE; i++) {
        -:  913:			int j;
    #####:  914:			for ( j = 0; j < 2; j++ ) {
    #####:  915:				if ( p[ 0 ] ) {
    #####:  916:					pgo->zuinBuf[ i ].s[ j ] = p[ 0 ];
    #####:  917:					p++;
        -:  918:				}
        -:  919:				else {
    #####:  920:					pgo->zuinBuf[ i ].s[ j ] = '\0';
        -:  921:				}
        -:  922:			}
    #####:  923:			pgo->zuinBuf[ i ].s[ 2 ] = '\0';
        -:  924:		}
        -:  925:	} else {
      940:  926:		for ( i = 0; i < ZUIN_SIZE; i++ ) {
      752:  927:			if ( pgdata->zuinData.pho_inx[ i ] != 0 ) {
        -:  928:				/* Here we should use (zhuin_tab[i] + 2) to
        -:  929:				 * skip the 2 space characters at
        -:  930:				 * zhuin_tab[0] and zhuin_tab[1]. */
       88:  931:				ueStrNCpy( (char *) pgo->zuinBuf[ i ].s,
       88:  932:				           ueConstStrSeek( (zhuin_tab[ i ] + 2),
       88:  933:						      pgdata->zuinData.pho_inx[ i ] - 1 ),
        -:  934:				           1, 1);
        -:  935:			}
        -:  936:			else
      664:  937:				pgo->zuinBuf[ i ].wch = 0;
        -:  938:		}
        -:  939:	}
        -:  940:
      188:  941:	ShiftInterval( pgo, pgdata );
      188:  942:	memcpy(
      188:  943:		pgo->dispBrkpt, pgdata->bUserArrBrkpt,
        -:  944:		sizeof( pgo->dispBrkpt[ 0 ] ) * ( MAX_PHONE_SEQ_LEN + 1 ) );
      188:  945:	pgo->pci = &( pgdata->choiceInfo );
      188:  946:	pgo->bChiSym = pgdata->bChiSym;
      188:  947:	memcpy( pgo->selKey, pgdata->config.selKey, sizeof( pgdata->config.selKey ) );
      188:  948:	pgo->bShowMsg = 0;
      188:  949:	return 0;
        -:  950:}
        -:  951:
      188:  952:int MakeOutputWithRtn( ChewingOutput *pgo, ChewingData *pgdata, int keystrokeRtn )
        -:  953:{
      188:  954:	pgo->keystrokeRtn = keystrokeRtn;
      188:  955:	return MakeOutput( pgo, pgdata );
        -:  956:}
        -:  957:
    #####:  958:void MakeOutputAddMsgAndCleanInterval( ChewingOutput *pgo, ChewingData *pgdata )
        -:  959:{
    #####:  960:	pgo->bShowMsg = 1;
    #####:  961:	memcpy( pgo->showMsg, pgdata->showMsg, sizeof( wch_t ) * ( pgdata->showMsgLen ) );
    #####:  962:	pgo->showMsgLen = pgdata->showMsgLen;
    #####:  963:	pgo->nDispInterval = 0;
    #####:  964:}
        -:  965:
        5:  966:int AddSelect( ChewingData *pgdata, int sel_i )
        -:  967:{
        -:  968:	int length, nSelect, cursor;
        -:  969:
        -:  970:	/* save the typing time */
        5:  971:	length = pgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;
        5:  972:	nSelect = pgdata->nSelect;
        -:  973:
        -:  974:	/* change "selectStr" , "selectInterval" , and "nSelect" of ChewingData */
        5:  975:	ueStrNCpy( pgdata->selectStr[ nSelect ],
        5:  976:			pgdata->choiceInfo.totalChoiceStr[ sel_i ],
        -:  977:			length, 1 );
        5:  978:	cursor = PhoneSeqCursor( pgdata );
        5:  979:	pgdata->selectInterval[ nSelect ].from = cursor;
        5:  980:	pgdata->selectInterval[ nSelect ].to = cursor + length;
        5:  981:	pgdata->nSelect++;
        5:  982:	return 0;
        -:  983:}
        -:  984:
       10:  985:int CountSelKeyNum( int key, ChewingData *pgdata )
        -:  986:	/* return value starts from 0.  If less than zero : error key */
        -:  987:{
        -:  988:	int i;
        -:  989:
       32:  990:	for ( i = 0; i < MAX_SELKEY; i++ )
       32:  991:		if ( pgdata->config.selKey[ i ] == key )
       10:  992:			return i;
    #####:  993:	return -1;
        -:  994:}
        -:  995:
      362:  996:int CountSymbols( ChewingData *pgdata, int to )
        -:  997:{
        -:  998:	int chi;
        -:  999:	int i;
      685: 1000:	for ( chi = i = 0; i < to; i++ ) {
      323: 1001:		if ( ChewingIsChiAt( i, pgdata ) )
      298: 1002:			chi++;
        -: 1003:	}
      362: 1004:	return to - chi;
        -: 1005:}
        -: 1006:
      359: 1007:int PhoneSeqCursor( ChewingData *pgdata )
        -: 1008:{
      359: 1009:	int cursor = pgdata->chiSymbolCursor - CountSymbols( pgdata, pgdata->chiSymbolCursor );
      359: 1010:	return cursor > 0 ? cursor : 0;
        -: 1011:}
        -: 1012:
      849: 1013:int ChewingIsChiAt( int chiSymbolCursor, ChewingData *pgdata )
        -: 1014:{
        -: 1015:	/* wch == 0 means Chinese */
        -: 1016:	return (
      849: 1017:		( chiSymbolCursor < pgdata->chiSymbolBufLen ) &&
     1698: 1018:		( 0 <= chiSymbolCursor ) &&
      848: 1019:		(pgdata->chiSymbolBuf[ chiSymbolCursor ].wch == 0 ) );
        -: 1020:}
        -: 1021:
        5: 1022:void RemoveSelectElement( int i, ChewingData *pgdata )
        -: 1023:{
        5: 1024:	if ( --pgdata->nSelect == i )
        5: 1025:		return;
    #####: 1026:	pgdata->selectInterval[ i ] = pgdata->selectInterval[ pgdata->nSelect ];
    #####: 1027:	strcpy( pgdata->selectStr[ i ], pgdata->selectStr[ pgdata->nSelect ] );
        -: 1028:}
        -: 1029:
        7: 1030:static int ChewingKillSelectIntervalAcross( int cursor, ChewingData *pgdata )
        -: 1031:{
        -: 1032:	int i;
       7*: 1033:	for ( i = 0; i < pgdata->nSelect; i++ ) {
    #####: 1034:		if ( pgdata->selectInterval[ i ].from < cursor &&
    #####: 1035:			pgdata->selectInterval[ i ].to > cursor ) {
    #####: 1036:			RemoveSelectElement( i, pgdata );
    #####: 1037:			i--;
        -: 1038:		}
        -: 1039:	}
        7: 1040:	return 0;
        -: 1041:}
        -: 1042:
        2: 1043:static int KillCharInSelectIntervalAndBrkpt( ChewingData *pgdata, int cursorToKill )
        -: 1044:{
        -: 1045:	int i;
        -: 1046:
       2*: 1047:	for ( i = 0; i < pgdata->nSelect; i++ ) {
    #####: 1048:		if ( pgdata->selectInterval[ i ].from <= cursorToKill &&
    #####: 1049:			pgdata->selectInterval[ i ].to > cursorToKill ) {
    #####: 1050:			RemoveSelectElement( i, pgdata );
    #####: 1051:			i--;      /* the last one was swap to i, we need to recheck i */
        -: 1052:		}
    #####: 1053:		else if( pgdata->selectInterval[ i ].from > cursorToKill ) {
    #####: 1054:			pgdata->selectInterval[ i ].from--;
    #####: 1055:			pgdata->selectInterval[ i ].to--;
        -: 1056:		}
        -: 1057:	}
       2*: 1058:	assert ( pgdata->nPhoneSeq >= cursorToKill );
        2: 1059:	memmove(
        2: 1060:		&( pgdata->bUserArrBrkpt[ cursorToKill ] ),
        2: 1061:		&( pgdata->bUserArrBrkpt[ cursorToKill + 1 ] ),
        2: 1062:		sizeof( int ) * ( pgdata->nPhoneSeq - cursorToKill ) );
        2: 1063:	memmove(
        2: 1064:		&( pgdata->bUserArrCnnct[ cursorToKill ] ),
        2: 1065:		&( pgdata->bUserArrCnnct[ cursorToKill + 1 ] ),
        2: 1066:		sizeof( int ) * ( pgdata->nPhoneSeq - cursorToKill ) );
        -: 1067:
        2: 1068:	return 0;
        -: 1069:}
        -: 1070:
        2: 1071:int ChewingKillChar(
        -: 1072:		ChewingData *pgdata,
        -: 1073:		int chiSymbolCursorToKill,
        -: 1074:		int minus )
        -: 1075:{
        -: 1076:	int tmp, cursorToKill;
        2: 1077:	tmp = pgdata->chiSymbolCursor;
        2: 1078:	pgdata->chiSymbolCursor = chiSymbolCursorToKill;
        2: 1079:	cursorToKill = PhoneSeqCursor( pgdata );
        2: 1080:	pgdata->chiSymbolCursor = tmp;
        2: 1081:	if ( ChewingIsChiAt( chiSymbolCursorToKill, pgdata ) ) {
        2: 1082:		KillCharInSelectIntervalAndBrkpt(pgdata, cursorToKill);
       2*: 1083:		assert( pgdata->nPhoneSeq - cursorToKill - 1 >= 0 );
        2: 1084:		memmove(
        2: 1085:			&( pgdata->phoneSeq[ cursorToKill ] ),
        2: 1086:			&(pgdata->phoneSeq[ cursorToKill + 1 ] ),
        2: 1087:			(pgdata->nPhoneSeq - cursorToKill - 1) * sizeof( uint16_t ) );
        2: 1088:		pgdata->nPhoneSeq--;
        -: 1089:	}
        2: 1090:	pgdata->symbolKeyBuf[ chiSymbolCursorToKill ] = 0;
       2*: 1091:	assert( pgdata->chiSymbolBufLen - chiSymbolCursorToKill );
        2: 1092:	memmove(
        2: 1093:		& pgdata->chiSymbolBuf[ chiSymbolCursorToKill ],
        2: 1094:		& pgdata->chiSymbolBuf[ chiSymbolCursorToKill + 1 ],
        2: 1095:		(pgdata->chiSymbolBufLen - chiSymbolCursorToKill) * sizeof( wch_t ) );
        2: 1096:	pgdata->chiSymbolBufLen--;
        2: 1097:	pgdata->chiSymbolCursor -= minus;
        2: 1098:	if (pgdata->chiSymbolCursor < 0)
    #####: 1099:		pgdata->chiSymbolCursor = 0;
        2: 1100:	return 0;
        -: 1101:}
        -: 1102:
        2: 1103:int IsPreferIntervalConnted( int cursor, ChewingData *pgdata )
        -: 1104:{
        -: 1105:	int i;
        -: 1106:
        4: 1107:	for ( i = 0; i < pgdata->nPrefer; i++ ) {
        3: 1108:		if (
        3: 1109:			pgdata->preferInterval[ i ].from < cursor &&
        2: 1110:			pgdata->preferInterval[ i ].to > cursor )
        1: 1111:			return 1;
        -: 1112:	}
        1: 1113:	return 0;
        -: 1114:}
        -: 1115:
        -: 1116:static const char * const symbol_buf[][ 50 ] = {
        -: 1117:	{ "0", "\xC3\xB8", 0 },
        -: 1118:		/* "ø" */
        -: 1119:	{ "[", "\xE3\x80\x8C", "\xE3\x80\x8E", "\xE3\x80\x8A", "\xE3\x80\x88",
        -: 1120:		  "\xE3\x80\x90", "\xE3\x80\x94", 0 },
        -: 1121:		/* "「", "『", "《", "〈", "【", "〔" */
        -: 1122:	{ "]", "\xE3\x80\x8D", "\xE3\x80\x8F", "\xE3\x80\x8B", "\xE3\x80\x89",
        -: 1123:		  "\xE3\x80\x91", "\xE3\x80\x95", 0 },
        -: 1124:		/* "」", "』", "》", "〉", "】", "〕" */
        -: 1125:	{ "{", "\xEF\xBD\x9B", 0 },
        -: 1126:		/* "｛" */
        -: 1127:	{ "}", "\xEF\xBD\x9D", 0 },
        -: 1128:		/* "｝" */
        -: 1129:	{ "<", "\xEF\xBC\x8C", "\xE2\x86\x90", 0 },
        -: 1130:		/* "，", "←" */
        -: 1131:	{ ">", "\xE3\x80\x82", "\xE2\x86\x92", "\xEF\xBC\x8E", 0 },
        -: 1132:		/* "。", "→", "．" */
        -: 1133:	{ "?", "\xEF\xBC\x9F", "\xC2\xBF", 0 },
        -: 1134:		/* "？", "¿" */
        -: 1135:	{ "!", "\xEF\xBC\x81", "\xE2\x85\xA0","\xC2\xA1", 0 },
        -: 1136:		/* "！", "Ⅰ","¡" */
        -: 1137:	{ "@", "\xEF\xBC\xA0", "\xE2\x85\xA1", "\xE2\x8A\x95", "\xE2\x8A\x99",
        -: 1138:		  "\xE3\x8A\xA3", "\xEF\xB9\xAB", 0 },
        -: 1139:		/* "＠", "Ⅱ", "⊕", "⊙", "㊣", "﹫" */
        -: 1140:	{ "#", "\xEF\xBC\x83", "\xE2\x85\xA2", "\xEF\xB9\x9F", 0 },
        -: 1141:		/* "＃", "Ⅲ", "﹟" */
        -: 1142:	{ "$", "\xEF\xBC\x84", "\xE2\x85\xA3", "\xE2\x82\xAC", "\xEF\xB9\xA9",
        -: 1143:		  "\xEF\xBF\xA0", "\xE2\x88\xAE","\xEF\xBF\xA1", "\xEF\xBF\xA5", 0 },
        -: 1144:		/* "＄", "Ⅳ", "€", "﹩", "￠", "∮","￡", "￥" */
        -: 1145:	{ "%", "\xEF\xBC\x85", "\xE2\x85\xA4", 0 },
        -: 1146:		/* "％", "Ⅴ" */
        -: 1147:	{ "^", "\xEF\xB8\xBF", "\xE2\x85\xA5", "\xEF\xB9\x80", "\xEF\xB8\xBD",
        -: 1148:		  "\xEF\xB8\xBE", 0 },
        -: 1149:		/* "︿", "Ⅵ", "﹀", "︽", "︾" */
        -: 1150:	{ "&", "\xEF\xBC\x86", "\xE2\x85\xA6", "\xEF\xB9\xA0", 0 },
        -: 1151:		/* "＆", "Ⅶ", "﹠" */
        -: 1152:	{ "*", "\xEF\xBC\x8A", "\xE2\x85\xA7", "\xC3\x97", "\xE2\x80\xBB",
        -: 1153:		  "\xE2\x95\xB3", "\xEF\xB9\xA1", "\xE2\x98\xAF", "\xE2\x98\x86",
        -: 1154:		  "\xE2\x98\x85", 0 },
        -: 1155:		/* "＊", "Ⅷ", "×", "※", "╳", "﹡", "☯", "☆", "★" */
        -: 1156:	{ "(", "\xEF\xBC\x88", "\xE2\x85\xA8", 0 },
        -: 1157:		/* "（", "Ⅸ" */
        -: 1158:	{ ")", "\xEF\xBC\x89", "\xE2\x85\xA9", 0 },
        -: 1159:		/* "）", "Ⅹ" */
        -: 1160:	{ "_", "\xEF\xBC\xBF", "\xE2\x80\xA6", "\xE2\x80\xA5", "\xE2\x86\x90",
        -: 1161:		  "\xE2\x86\x92", "\xEF\xB9\x8D", "\xEF\xB9\x89", "\xCB\x8D",
        -: 1162:		  "\xEF\xBF\xA3", "\xE2\x80\x93", "\xE2\x80\x94", "\xC2\xAF",
        -: 1163:		  "\xEF\xB9\x8A", "\xEF\xB9\x8E", "\xEF\xB9\x8F", "\xEF\xB9\xA3",
        -: 1164:		  "\xEF\xBC\x8D", 0 },
        -: 1165:		/* "＿", "…", "‥", "←", "→", "﹍", "﹉", "ˍ", "￣"
        -: 1166:		 * "–", "—", "¯", "﹊", "﹎", "﹏", "﹣", "－" */
        -: 1167:	{ "+", "\xEF\xBC\x8B", "\xC2\xB1", "\xEF\xB9\xA2", 0 },
        -: 1168:		/* "＋", "±", "﹢" */
        -: 1169:	{ "=", "\xEF\xBC\x9D", "\xE2\x89\x92", "\xE2\x89\xA0", "\xE2\x89\xA1",
        -: 1170:		  "\xE2\x89\xA6", "\xE2\x89\xA7", "\xEF\xB9\xA6", 0 },
        -: 1171:		/* "＝", "≒", "≠", "≡", "≦", "≧", "﹦" */
        -: 1172:	{ "`", "\xE3\x80\x8F", "\xE3\x80\x8E", "\xE2\x80\xB2", "\xE2\x80\xB5", 0 },
        -: 1173:		/* "』", "『", "′", "‵" */
        -: 1174:	{ "~", "\xEF\xBD\x9E", 0 },
        -: 1175:		/* "～" */
        -: 1176:	{ ":", "\xEF\xBC\x9A", "\xEF\xBC\x9B", "\xEF\xB8\xB0", "\xEF\xB9\x95", 0 },
        -: 1177:		/* "：", "；", "︰", "﹕" */
        -: 1178:	{ "\"", "\xEF\xBC\x9B", 0 },
        -: 1179:		/* "；" */
        -: 1180:	{ "\'", "\xE3\x80\x81", "\xE2\x80\xA6", "\xE2\x80\xA5", 0 },
        -: 1181:		/* "、", "…", "‥" */
        -: 1182:	{ "\\", "\xEF\xBC\xBC", "\xE2\x86\x96", "\xE2\x86\x98", "\xEF\xB9\xA8", 0 },
        -: 1183:		/* "＼", "↖", "↘", "﹨" */
        -: 1184:	{ "-", "\xEF\xBC\x8D", "\xEF\xBC\xBF", "\xEF\xBF\xA3", "\xC2\xAF",
        -: 1185:		  "\xCB\x8D", "\xE2\x80\x93", "\xE2\x80\x94", "\xE2\x80\xA5",
        -: 1186:		  "\xE2\x80\xA6", "\xE2\x86\x90", "\xE2\x86\x92", "\xE2\x95\xB4",
        -: 1187:		  "\xEF\xB9\x89", "\xEF\xB9\x8A", "\xEF\xB9\x8D", "\xEF\xB9\x8E",
        -: 1188:		  "\xEF\xB9\x8F", "\xEF\xB9\xA3", 0 },
        -: 1189:		/* "－", "＿", "￣", "¯", "ˍ", "–", "—", "‥", "…"
        -: 1190:		 * "←", "→", "╴", "﹉", "﹊", "﹍", "﹎", "﹏", "﹣" */
        -: 1191:	{ "/", "\xEF\xBC\x8F", "\xC3\xB7", "\xE2\x86\x97", "\xE2\x86\x99",
        -: 1192:		  "\xE2\x88\x95", 0 },
        -: 1193:		/* "／","÷","↗","↙","∕" */
        -: 1194:	{ "|", "\xE2\x86\x91", "\xE2\x86\x93", "\xE2\x88\xA3", "\xE2\x88\xA5",
        -: 1195:		  "\xEF\xB8\xB1", "\xEF\xB8\xB3", "\xEF\xB8\xB4" ,0 },
        -: 1196:		/* "↑", "↓", "∣", "∥", "︱", "︳", "︴" */
        -: 1197:	{ "A", "\xC3\x85","\xCE\x91", "\xCE\xB1", "\xE2\x94\x9C", "\xE2\x95\xA0",
        -: 1198:		  "\xE2\x95\x9F", "\xE2\x95\x9E", 0 },
        -: 1199:		/* "Å","Α", "α", "├", "╠", "╟", "╞" */
        -: 1200:	{ "B", "\xCE\x92", "\xCE\xB2","\xE2\x88\xB5", 0 },
        -: 1201:		/* "Β", "β","∵" */
        -: 1202:	{ "C", "\xCE\xA7", "\xCF\x87", "\xE2\x94\x98", "\xE2\x95\xAF",
        -: 1203:		  "\xE2\x95\x9D", "\xE2\x95\x9C", "\xE2\x95\x9B", "\xE3\x8F\x84",
        -: 1204:		  "\xE2\x84\x83", "\xE3\x8E\x9D", "\xE2\x99\xA3", "\xC2\xA9", 0 },
        -: 1205:		/* "Χ", "χ", "┘", "╯", "╝", "╜", "╛"
        -: 1206:		 * "㏄", "℃", "㎝", "♣", "©" */
        -: 1207:	{ "D", "\xCE\x94", "\xCE\xB4", "\xE2\x97\x87", "\xE2\x97\x86",
        -: 1208:		  "\xE2\x94\xA4", "\xE2\x95\xA3", "\xE2\x95\xA2", "\xE2\x95\xA1",
        -: 1209:		  "\xE2\x99\xA6", 0 },
        -: 1210:		/* "Δ", "δ", "◇", "◆", "┤", "╣", "╢", "╡","♦" */
        -: 1211:	{ "E", "\xCE\x95", "\xCE\xB5", "\xE2\x94\x90", "\xE2\x95\xAE",
        -: 1212:		  "\xE2\x95\x97", "\xE2\x95\x93", "\xE2\x95\x95", 0 },
        -: 1213:		/* "Ε", "ε", "┐", "╮", "╗", "╓", "╕" */
        -: 1214:	{ "F", "\xCE\xA6", "\xCF\x88", "\xE2\x94\x82", "\xE2\x95\x91",
        -: 1215:		  "\xE2\x99\x80", 0 },
        -: 1216:		/* "Φ", "ψ", "│", "║", "♀" */
        -: 1217:	{ "G", "\xCE\x93", "\xCE\xB3", 0 },
        -: 1218:		/* "Γ", "γ" */
        -: 1219:	{ "H", "\xCE\x97", "\xCE\xB7","\xE2\x99\xA5", 0 },
        -: 1220:		/* "Η", "η","♥" */
        -: 1221:	{ "I", "\xCE\x99", "\xCE\xB9", 0 },
        -: 1222:		/* "Ι", "ι" */
        -: 1223:	{ "J", "\xCF\x86", 0 },
        -: 1224:		/* "φ" */
        -: 1225:	{ "K", "\xCE\x9A", "\xCE\xBA","\xE3\x8E\x9E", "\xE3\x8F\x8E", 0 },
        -: 1226:		/* "Κ", "κ","㎞", "㏎" */
        -: 1227:	{ "L", "\xCE\x9B", "\xCE\xBB","\xE3\x8F\x92", "\xE3\x8F\x91", 0 },
        -: 1228:		/* "Λ", "λ","㏒", "㏑" */
        -: 1229:	{ "M", "\xCE\x9C", "\xCE\xBC", "\xE2\x99\x82", "\xE2\x84\x93",
        -: 1230:		  "\xE3\x8E\x8E", "\xE3\x8F\x95", "\xE3\x8E\x9C","\xE3\x8E\xA1", 0 },
        -: 1231:		/* "Μ", "μ", "♂", "ℓ", "㎎", "㏕", "㎜","㎡" */
        -: 1232:	{ "N", "\xCE\x9D", "\xCE\xBD","\xE2\x84\x96", 0 },
        -: 1233:		/* "Ν", "ν","№" */
        -: 1234:	{ "O", "\xCE\x9F", "\xCE\xBF", 0 },
        -: 1235:		/* "Ο", "ο" */
        -: 1236:	{ "P", "\xCE\xA0", "\xCF\x80", 0 },
        -: 1237:		/* "Π", "π" */
        -: 1238:	{ "Q", "\xCE\x98", "\xCE\xB8","\xD0\x94","\xE2\x94\x8C", "\xE2\x95\xAD",
        -: 1239:		  "\xE2\x95\x94", "\xE2\x95\x93", "\xE2\x95\x92", 0 },
        -: 1240:		/* "Θ", "θ","Д","┌", "╭", "╔", "╓", "╒" */
        -: 1241:	{ "R", "\xCE\xA1", "\xCF\x81", "\xE2\x94\x80", "\xE2\x95\x90" ,"\xC2\xAE" , 0 },
        -: 1242:		/* "Ρ", "ρ", "─", "═" ,"®" */
        -: 1243:	{ "S", "\xCE\xA3", "\xCF\x83", "\xE2\x88\xB4", "\xE2\x96\xA1",
        -: 1244:		  "\xE2\x96\xA0", "\xE2\x94\xBC", "\xE2\x95\xAC", "\xE2\x95\xAA",
        -: 1245:		  "\xE2\x95\xAB", "\xE2\x88\xAB", "\xC2\xA7", "\xE2\x99\xA0", 0 },
        -: 1246:		/* "Σ", "σ", "∴", "□", "■", "┼", "╬", "╪", "╫"
        -: 1247:		 * "∫", "§", "♠" */
        -: 1248:	{ "T", "\xCE\xA4", "\xCF\x84", "\xCE\xB8", "\xE2\x96\xB3", "\xE2\x96\xB2",
        -: 1249:		  "\xE2\x96\xBD", "\xE2\x96\xBC", "\xE2\x84\xA2", "\xE2\x8A\xBF",
        -: 1250:		  "\xE2\x84\xA2", 0 },
        -: 1251:		/* "Τ", "τ","θ","△","▲","▽","▼","™","⊿", "™" */
        -: 1252:	{ "U", "\xCE\xA5", "\xCF\x85","\xCE\xBC","\xE2\x88\xAA", "\xE2\x88\xA9", 0 },
        -: 1253:		/* "Υ", "υ","μ","∪", "∩" */
        -: 1254:	{ "V", "\xCE\xBD", 0 },
        -: 1255:	{ "W", "\xE2\x84\xA6", "\xCF\x89", "\xE2\x94\xAC", "\xE2\x95\xA6",
        -: 1256:		  "\xE2\x95\xA4", "\xE2\x95\xA5", 0 },
        -: 1257:		/* "Ω", "ω", "┬", "╦", "╤", "╥" */
        -: 1258:	{ "X", "\xCE\x9E", "\xCE\xBE", "\xE2\x94\xB4", "\xE2\x95\xA9",
        -: 1259:		  "\xE2\x95\xA7", "\xE2\x95\xA8", 0 },
        -: 1260:		/* "Ξ", "ξ", "┴", "╩", "╧", "╨" */
        -: 1261:	{ "Y", "\xCE\xA8", 0 },
        -: 1262:		/* "Ψ" */
        -: 1263:	{ "Z", "\xCE\x96", "\xCE\xB6", "\xE2\x94\x94", "\xE2\x95\xB0",
        -: 1264:		  "\xE2\x95\x9A", "\xE2\x95\x99", "\xE2\x95\x98", 0 },
        -: 1265:		/* "Ζ", "ζ", "└", "╰", "╚", "╙", "╘" */
        -: 1266:};
        -: 1267:
        4: 1268:static int FindSymbolKey( const char *symbol )
        -: 1269:{
        -: 1270:	unsigned int i;
        -: 1271:	const char * const *buf;
       37: 1272:	for ( i = 0; i < ARRAY_SIZE( symbol_buf ); ++i ) {
      185: 1273:		for ( buf = symbol_buf[ i ]; *buf; ++buf )	{
      152: 1274:			if (  0 == strcmp( *buf, symbol ) )
        4: 1275:				return *symbol_buf[ i ][ 0 ];
        -: 1276:		}
        -: 1277:	}
    #####: 1278:	return 0;
        -: 1279:}
        -: 1280:
    #####: 1281:int OpenSymbolChoice( ChewingData *pgdata )
        -: 1282:{
    #####: 1283:	int i, symbol_buf_len = ARRAY_SIZE( symbol_buf );
        -: 1284:	const char * const *pBuf;
    #####: 1285:	ChoiceInfo *pci = &( pgdata->choiceInfo );
    #####: 1286:	pci->oldChiSymbolCursor = pgdata->chiSymbolCursor;
        -: 1287:
        -: 1288:	/* see if there is some word in the cursor position */
    #####: 1289:	if ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )
    #####: 1290:		pgdata->chiSymbolCursor--;
    #####: 1291:	if ( pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] == '1' ) {
    #####: 1292:		pgdata->bSelect = 1;
    #####: 1293:		HaninSymbolInput( pgdata );
    #####: 1294:		return 0;
        -: 1295:	}
    #####: 1296:	for ( i = 0; i < symbol_buf_len; i++ ) {
    #####: 1297:		if ( symbol_buf[ i ][ 0 ][ 0 ] ==
    #####: 1298:				pgdata->symbolKeyBuf[ pgdata->chiSymbolCursor ] ) {
    #####: 1299:			pBuf = symbol_buf[i];
    #####: 1300:			break;
        -: 1301:		}
        -: 1302:	}
    #####: 1303:	if ( i == symbol_buf_len ) {
    #####: 1304:		ChoiceEndChoice( pgdata );
    #####: 1305:		return 0;
        -: 1306:	}
    #####: 1307:	pci->nTotalChoice = 0;
    #####: 1308:	for ( i = 1; pBuf[ i ]; i++ ) {
    #####: 1309:		ueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],
    #####: 1310:				pBuf[ i ], ueStrLen( pBuf[i] ), 1 );
    #####: 1311:		pci->nTotalChoice++;
        -: 1312:	}
        -: 1313:
    #####: 1314:	pci->nChoicePerPage = pgdata->config.candPerPage;
    #####: 1315:	assert( pci->nTotalChoice > 0 );
    #####: 1316:	pci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );
    #####: 1317:	pci->pageNo = 0;
    #####: 1318:	pci->isSymbol = SYMBOL_CHOICE_UPDATE;
        -: 1319:
    #####: 1320:	pgdata->bSelect = 1;
    #####: 1321:	pgdata->availInfo.nAvail = 1;
    #####: 1322:	pgdata->availInfo.currentAvail = 0;
    #####: 1323:	pgdata->availInfo.avail[ 0 ].id = -1;
    #####: 1324:	pgdata->availInfo.avail[ 0 ].len = 1;
    #####: 1325:	return 0;
        -: 1326:}
        -: 1327:
       27: 1328:int InitSymbolTable( ChewingData *pgdata, const char *prefix )
        -: 1329:{
        -: 1330:	static const unsigned int MAX_SYMBOL_ENTRY = 100;
        -: 1331:	static const size_t LINE_LEN = 512; // shall be long enough?
        -: 1332:
       27: 1333:	char *filename = NULL;
       27: 1334:	FILE *file = NULL;
       27: 1335:	char *line = NULL;
       27: 1336:	SymbolEntry **entry = NULL;
        -: 1337:	char *category_end;
        -: 1338:	const char *symbols;
        -: 1339:	const char *symbols_end;
        -: 1340:	const char *symbol;
        -: 1341:	size_t i;
        -: 1342:	size_t len;
        -: 1343:	size_t size;
       27: 1344:	int ret = -1;
        -: 1345:
       27: 1346:	pgdata->static_data.n_symbol_entry = 0;
       27: 1347:	pgdata->static_data.symbol_table = NULL;
        -: 1348:
       27: 1349:	ret = asprintf( &filename, "%s" PLAT_SEPARATOR "%s",
        -: 1350:		prefix, SYMBOL_TABLE_FILE );
       27: 1351:	if ( ret == -1 )
    #####: 1352:		goto error;
        -: 1353:
       27: 1354:	file = fopen( filename, "r" );
       27: 1355:	if ( !file )
    #####: 1356:		goto error;
        -: 1357:
       27: 1358:	line = ALC( char, LINE_LEN );
       27: 1359:	if ( !line )
    #####: 1360:		goto error;
        -: 1361:
       27: 1362:	entry = ALC( SymbolEntry* , MAX_SYMBOL_ENTRY );
       27: 1363:	if ( !entry )
    #####: 1364:		goto error;
        -: 1365:
      378: 1366:	while ( fgets( line, LINE_LEN, file ) &&
      351: 1367:		pgdata->static_data.n_symbol_entry < MAX_SYMBOL_ENTRY ) {
        -: 1368:
      351: 1369:		category_end = strpbrk( line, "=\r\n" );
      351: 1370:		if ( !category_end )
    #####: 1371:			goto error;
        -: 1372:
      351: 1373:		symbols = category_end + 1;
      351: 1374:		symbols_end = strpbrk( symbols, "\r\n" );
      351: 1375:		if ( symbols_end ) {
      297: 1376:			len = ueStrLen( symbols );
        -: 1377:
      297: 1378:			entry[ pgdata->static_data.n_symbol_entry ] =
      297: 1379:				( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) +
      297: 1380:					sizeof( entry[0][0].symbols[0] ) * len);
      297: 1381:			if ( !entry[ pgdata->static_data.n_symbol_entry ] )
    #####: 1382:				goto error;
      297: 1383:			entry[ pgdata->static_data.n_symbol_entry ]
      297: 1384:				->nSymbols = len;
        -: 1385:
      297: 1386:			symbol = symbols;
        -: 1387:
     8505: 1388:			for ( i = 0; i < len; ++i ) {
     8208: 1389:				ueStrNCpy(
     8208: 1390:					entry[ pgdata->static_data.n_symbol_entry ]->symbols[ i ],
        -: 1391:					symbol, 1, 1 );
        -: 1392:				// FIXME: What if symbol is combining sequences.
     8208: 1393:				symbol += ueBytesFromChar( symbol[0] );
        -: 1394:			}
        -: 1395:
        -: 1396:
        -: 1397:		} else {
       54: 1398:			entry[ pgdata->static_data.n_symbol_entry ] =
       54: 1399:				( SymbolEntry* ) malloc( sizeof ( entry[0][0] ) );
       54: 1400:			if ( !entry[ pgdata->static_data.n_symbol_entry ] )
    #####: 1401:				goto error;
        -: 1402:
       54: 1403:			entry[ pgdata->static_data.n_symbol_entry ]
       54: 1404:				->nSymbols = 0;
        -: 1405:		}
        -: 1406:
      351: 1407:		*category_end = 0;
      351: 1408:		ueStrNCpy(
      351: 1409:			entry[pgdata->static_data.n_symbol_entry]->category,
        -: 1410:			line, MAX_PHRASE_LEN, 1);
        -: 1411:
      351: 1412:		++pgdata->static_data.n_symbol_entry;
        -: 1413:	}
        -: 1414:
       27: 1415:	size = sizeof( *pgdata->static_data.symbol_table ) *
       27: 1416:		pgdata->static_data.n_symbol_entry;
       27: 1417:	pgdata->static_data.symbol_table = ( SymbolEntry ** ) malloc( size );
       27: 1418:	if ( !pgdata->static_data.symbol_table )
    #####: 1419:		goto error;
       27: 1420:	memcpy( pgdata->static_data.symbol_table, entry, size );
        -: 1421:
       27: 1422:	ret = 0;
       27: 1423:end:
       27: 1424:	free( entry );
       27: 1425:	free( line );
       27: 1426:	fclose( file );
       27: 1427:	free ( filename );
       27: 1428:	return ret;
        -: 1429:
    #####: 1430:error:
    #####: 1431:	for ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i ) {
    #####: 1432:		free( entry[ i ] );
        -: 1433:	}
    #####: 1434:	goto end;
        -: 1435:}
        -: 1436:
       27: 1437:void TerminateSymbolTable( ChewingData *pgdata )
        -: 1438:{
        -: 1439:	unsigned int i;
       27: 1440:	if ( pgdata->static_data.symbol_table ) {
      378: 1441:		for ( i = 0; i < pgdata->static_data.n_symbol_entry; ++i )
      351: 1442:			free( pgdata->static_data.symbol_table[ i ] );
       27: 1443:		free( pgdata->static_data.symbol_table );
       27: 1444:		pgdata->static_data.n_symbol_entry = 0;
       27: 1445:		pgdata->static_data.symbol_table = NULL;
        -: 1446:	}
       27: 1447:}
        -: 1448:
       27: 1449:int InitEasySymbolInput( ChewingData *pgdata, const char *prefix )
        -: 1450:{
        -: 1451:	static const size_t LINE_LEN = 512; // shall be long enough?
        -: 1452:
       27: 1453:	FILE *file = NULL;
       27: 1454:	char *filename = NULL;
       27: 1455:	char *line = NULL;
        -: 1456:	int len;
        -: 1457:	int _index;
        -: 1458:	char *symbol;
       27: 1459:	int ret = -1;
        -: 1460:
       27: 1461:	ret = asprintf( &filename, "%s" PLAT_SEPARATOR "%s",
        -: 1462:			prefix, SOFTKBD_TABLE_FILE );
       27: 1463:	if ( ret == -1 )
    #####: 1464:		goto end;
        -: 1465:
       27: 1466:	file = fopen( filename, "r" );
       27: 1467:	if ( !file )
    #####: 1468:		goto end;
        -: 1469:
       27: 1470:	line = ALC( char, LINE_LEN );
       27: 1471:	if ( !line )
    #####: 1472:		goto end;
        -: 1473:
      729: 1474:	while ( fgets( line, LINE_LEN, file ) ) {
      702: 1475:		if ( ' ' != line[ 1 ] )
    #####: 1476:			continue;
        -: 1477:
        -: 1478:		// Remove tailing \n
      702: 1479:		len = strcspn( line, "\r\n" );
        -: 1480:
      702: 1481:		line[ len ] = '\0';
        -: 1482:
      702: 1483:		_index = FindEasySymbolIndex( line[ 0 ] );
      702: 1484:		if ( -1 == _index )
    #####: 1485:			continue;
        -: 1486:
      702: 1487:		len = ueStrLen( &line[ 2 ] );
      702: 1488:		if ( 0 == len || len > MAX_PHRASE_LEN )
    #####: 1489:			continue;
        -: 1490:
      702: 1491:		symbol = ALC( char, strlen( &line[2] ) + 1 );
      702: 1492:		if ( !symbol )
    #####: 1493:			goto end;
        -: 1494:
      702: 1495:		ueStrNCpy( symbol, &line[ 2 ], len, 1 );
        -: 1496:
      702: 1497:		free( pgdata->static_data.g_easy_symbol_value[ _index ] );
      702: 1498:		pgdata->static_data.g_easy_symbol_value[ _index ] = symbol;
      702: 1499:		pgdata->static_data.g_easy_symbol_num[ _index ] = len;
        -: 1500:	}
       27: 1501:	ret = 0;
       27: 1502:end:
       27: 1503:	free( line );
       27: 1504:	fclose( file );
       27: 1505:	free ( filename );
       27: 1506:	return ret;
        -: 1507:}
        -: 1508:
       27: 1509:void TerminateEasySymbolTable( ChewingData *pgdata )
        -: 1510:{
        -: 1511:	unsigned int i;
      999: 1512:	for ( i = 0; i < EASY_SYMBOL_KEY_TAB_LEN ; ++i ) {
      972: 1513:		if ( NULL != pgdata->static_data.g_easy_symbol_value[ i ] ) {
      702: 1514:			free( pgdata->static_data.g_easy_symbol_value[ i ] );
      702: 1515:			pgdata->static_data.g_easy_symbol_value[ i ] = NULL;
        -: 1516:		}
      972: 1517:		pgdata->static_data.g_easy_symbol_num[ i ] = 0;
        -: 1518:	}
       27: 1519:}
        -: 1520:
