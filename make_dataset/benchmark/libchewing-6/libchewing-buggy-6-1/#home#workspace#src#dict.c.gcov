        -:    0:Source:/home/workspace/src/dict.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/dict.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/dict.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * dict.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2005, 2008
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:#ifdef HAVE_CONFIG_H
        -:   15:  #include <config.h>
        -:   16:#endif
        -:   17:
        -:   18:#if ! defined(USE_BINARY_DATA)
        -:   19:#include <stdlib.h>
        -:   20:#endif
        -:   21:
        -:   22:#include <stdio.h>
        -:   23:#include <assert.h>
        -:   24:#include <string.h>
        -:   25:
        -:   26:#include "global-private.h"
        -:   27:#include "plat_mmap.h"
        -:   28:#include "dict-private.h"
        -:   29:#include "memory-private.h"
        -:   30:
        -:   31:#if ! defined(USE_BINARY_DATA)
        -:   32:#include "private.h"
        -:   33:#endif
        -:   34:
        -:   35:#if ! defined(USE_BINARY_DATA)
        -:   36:static char *fgettab( char *buf, int maxlen, FILE *fp )
        -:   37:{
        -:   38:	int i;
        -:   39:
        -:   40:	for ( i = 0; i < maxlen; i++ ) {
        -:   41:		buf[ i ] = (char) fgetc( fp );
        -:   42:		if ( feof( fp ) )
        -:   43:			break;
        -:   44:		if ( buf[ i ] == '\t' )
        -:   45:			break;
        -:   46:	}
        -:   47:	if ( feof( fp ) )
        -:   48:		return 0;
        -:   49:	buf[ i ] = '\0';
        -:   50:	return buf;
        -:   51:}
        -:   52:#endif
        -:   53:
       27:   54:void TerminateDict( ChewingData *pgdata )
        -:   55:{
        -:   56:#ifdef USE_BINARY_DATA
       27:   57:	plat_mmap_close( &pgdata->static_data.index_mmap );
       27:   58:	plat_mmap_close( &pgdata->static_data.dict_mmap );
        -:   59:#else
        -:   60:	if ( pgdata->static_data.dictfile ) {
        -:   61:		fclose( pgdata->static_data.dictfile );
        -:   62:		pgdata->static_data.dictfile = NULL;
        -:   63:	}
        -:   64:	free( pgdata->static_data.dict_begin );
        -:   65:	pgdata->static_data.dict_begin = NULL;
        -:   66:#endif
       27:   67:}
        -:   68:
       27:   69:int InitDict( ChewingData *pgdata, const char *prefix )
        -:   70:{
        -:   71:#ifdef USE_BINARY_DATA
        -:   72:	char filename[ PATH_MAX ];
        -:   73:	size_t len;
        -:   74:	size_t offset;
        -:   75:	size_t file_size;
        -:   76:	size_t csize;
        -:   77:
       27:   78:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, DICT_FILE );
       27:   79:	if ( len + 1 > sizeof( filename ) )
    #####:   80:		return -1;
        -:   81:
       27:   82:	plat_mmap_set_invalid( &pgdata->static_data.dict_mmap );
       27:   83:	file_size = plat_mmap_create( &pgdata->static_data.dict_mmap, filename, FLAG_ATTRIBUTE_READ );
       27:   84:	if ( file_size <= 0 )
    #####:   85:		return -1;
        -:   86:
       27:   87:	offset = 0;
       27:   88:	csize = file_size;
       27:   89:	pgdata->static_data.dict = plat_mmap_set_view( &pgdata->static_data.dict_mmap, &offset, &csize );
       27:   90:	if ( !pgdata->static_data.dict )
    #####:   91:		return -1;
        -:   92:
       27:   93:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, PH_INDEX_FILE );
       27:   94:	if ( len + 1 > sizeof( filename ) )
    #####:   95:		return -1;
        -:   96:
       27:   97:	plat_mmap_set_invalid( &pgdata->static_data.index_mmap );
       27:   98:	file_size = plat_mmap_create( &pgdata->static_data.index_mmap, filename, FLAG_ATTRIBUTE_READ );
       27:   99:	if ( file_size <= 0 )
    #####:  100:		return -1;
        -:  101:
       27:  102:	offset = 0;
       27:  103:	csize = file_size;
       27:  104:	pgdata->static_data.dict_begin = plat_mmap_set_view( &pgdata->static_data.index_mmap, &offset, &csize );
       27:  105:	if ( !pgdata->static_data.dict_begin )
    #####:  106:		return -1;
        -:  107:
       27:  108:	return 0;
        -:  109:#else
        -:  110:	char filename[ PATH_MAX ];
        -:  111:	FILE *indexfile;
        -:  112:	int len;
        -:  113:	int i;
        -:  114:
        -:  115:	pgdata->static_data.dict_begin = ALC( int, PHONE_PHRASE_NUM + 1 );
        -:  116:	if ( !pgdata->static_data.dict_begin )
        -:  117:		return -1;
        -:  118:
        -:  119:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, DICT_FILE );
        -:  120:	if ( len + 1 > sizeof( filename ) )
        -:  121:		return -1;
        -:  122:
        -:  123:	pgdata->static_data.dictfile = fopen( filename, "r" );
        -:  124:	if ( !pgdata->static_data.dictfile )
        -:  125:		return -1;
        -:  126:
        -:  127:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, PH_INDEX_FILE );
        -:  128:	if ( len + 1 > sizeof( filename ) )
        -:  129:		return -1;
        -:  130:
        -:  131:	indexfile = fopen( filename, "r" );
        -:  132:	if ( !indexfile )
        -:  133:		return -1;
        -:  134:
        -:  135:	i = 0;
        -:  136:	/* FIXME: check if begin is big enough to store all data. */
        -:  137:	while ( !feof( indexfile ) )
        -:  138:		fscanf( indexfile, "%d", &pgdata->static_data.dict_begin[ i++ ] );
        -:  139:	fclose( indexfile );
        -:  140:
        -:  141:	return 0;
        -:  142:#endif
        -:  143:}
        -:  144:
      460:  145:static void Str2Phrase( ChewingData *pgdata, Phrase *phr_ptr )
        -:  146:{
        -:  147:#ifndef USE_BINARY_DATA
        -:  148:	char buf[ 1000 ];
        -:  149:
        -:  150:	fgettab( buf, 1000, pgdata->static_data.dictfile );
        -:  151:	sscanf( buf, "%[^ ] %d", phr_ptr->phrase, &( phr_ptr->freq ) );
        -:  152:#else
        -:  153:	unsigned char size;
      460:  154:	size = *(unsigned char *) pgdata->static_data.dict_cur_pos;
      460:  155:	pgdata->static_data.dict_cur_pos = (unsigned char *)pgdata->static_data.dict_cur_pos + sizeof(unsigned char);
      460:  156:	memcpy( phr_ptr->phrase, pgdata->static_data.dict_cur_pos, size );
      460:  157:	pgdata->static_data.dict_cur_pos = (unsigned char *)pgdata->static_data.dict_cur_pos + size;
      460:  158:	phr_ptr->freq = GetInt32(pgdata->static_data.dict_cur_pos);
      460:  159:	pgdata->static_data.dict_cur_pos = (unsigned char *)pgdata->static_data.dict_cur_pos + sizeof(int);
      460:  160:	phr_ptr->phrase[ size ] = '\0';
        -:  161:#endif
      460:  162:}
        -:  163:
      358:  164:int GetPhraseFirst( ChewingData *pgdata, Phrase *phr_ptr, int phone_phr_id )
        -:  165:{
     358*:  166:	assert( ( 0 <= phone_phr_id ) && ( phone_phr_id < PHONE_PHRASE_NUM ) );
        -:  167:
        -:  168:#ifndef USE_BINARY_DATA
        -:  169:	fseek( pgdata->static_data.dictfile, pgdata->static_data.dict_begin[ phone_phr_id ], SEEK_SET );
        -:  170:#else
      358:  171:	pgdata->static_data.dict_cur_pos = (unsigned char *)pgdata->static_data.dict + pgdata->static_data.dict_begin[ phone_phr_id ];
        -:  172:#endif
      358:  173:	pgdata->static_data.dict_end_pos = pgdata->static_data.dict_begin[ phone_phr_id + 1 ];
      358:  174:	Str2Phrase( pgdata, phr_ptr );
      358:  175:	return 1;
        -:  176:}
        -:  177:
      122:  178:int GetPhraseNext( ChewingData *pgdata, Phrase *phr_ptr )
        -:  179:{
        -:  180:#ifndef USE_BINARY_DATA
        -:  181:	if ( ftell( pgdata->static_data.dictfile ) >= pgdata->static_data.dict_end_pos )
        -:  182:		return 0;
        -:  183:#else
      122:  184:	if ( (unsigned char *)pgdata->static_data.dict_cur_pos >= (unsigned char *)pgdata->static_data.dict + pgdata->static_data.dict_end_pos )
       20:  185:		return 0;
        -:  186:#endif
      102:  187:	Str2Phrase( pgdata, phr_ptr );
      102:  188:	return 1;
        -:  189:}
