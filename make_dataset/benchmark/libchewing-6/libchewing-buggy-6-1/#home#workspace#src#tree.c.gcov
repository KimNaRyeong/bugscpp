        -:    0:Source:/home/workspace/src/tree.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/tree.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/tree.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * tree.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2005, 2006, 2008, 2011
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: *	@file tree.c
        -:   17: *	@brief API for accessing the phrase tree.
        -:   18: */
        -:   19:#include <assert.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:#include "chewing-private.h"
        -:   25:#include "chewing-utf8-util.h"
        -:   26:#include "chewing-definition.h"
        -:   27:#include "userphrase-private.h"
        -:   28:#include "global.h"
        -:   29:#include "global-private.h"
        -:   30:#include "dict-private.h"
        -:   31:#include "char-private.h"
        -:   32:#include "tree-private.h"
        -:   33:#include "private.h"
        -:   34:#include "plat_mmap.h"
        -:   35:
        -:   36:#define INTERVAL_SIZE ( ( MAX_PHONE_SEQ_LEN + 1 ) * MAX_PHONE_SEQ_LEN / 2 )
        -:   37:
        -:   38:typedef struct {
        -:   39:	int from, to, pho_id, source;
        -:   40:	Phrase *p_phr;
        -:   41:} PhraseIntervalType;
        -:   42:
        -:   43:typedef struct tagRecordNode {
        -:   44:	int *arrIndex;		/* the index array of the things in "interval" */
        -:   45:	int nInter, score;
        -:   46:	struct tagRecordNode *next;
        -:   47:	int nMatchCnnct;	/* match how many Cnnct. */
        -:   48:} RecordNode;
        -:   49:
        -:   50:typedef struct {
        -:   51:	int leftmost[ MAX_PHONE_SEQ_LEN + 1 ] ;
        -:   52:	char graph[ MAX_PHONE_SEQ_LEN + 1 ][ MAX_PHONE_SEQ_LEN + 1 ];
        -:   53:	PhraseIntervalType interval[ MAX_INTERVAL ];
        -:   54:	int nInterval;
        -:   55:	RecordNode *phList;
        -:   56:	int nPhListLen;
        -:   57:} TreeDataType;
        -:   58:
       89:   59:static int IsContain( IntervalType in1, IntervalType in2 )
        -:   60:{
       89:   61:	return ( in1.from <= in2.from && in1.to >= in2.to );
        -:   62:}
        -:   63:
       53:   64:int IsIntersect( IntervalType in1, IntervalType in2 )
        -:   65:{
       53:   66:	return ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );
        -:   67:}
        -:   68:
    #####:   69:static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)
        -:   70:{
    #####:   71:	return ( in1.from <= in2.from && in1.to >= in2.to );
        -:   72:}
        -:   73:
      187:   74:static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)
        -:   75:{
      187:   76:	return ( max( in1.from, in2.from ) < min( in1.to, in2.to ) );
        -:   77:}
        -:   78:
       27:   79:void TerminateTree( ChewingData *pgdata )
        -:   80:{
        -:   81:#ifdef USE_BINARY_DATA
       27:   82:		pgdata->static_data.tree = NULL;
       27:   83:		plat_mmap_close( &pgdata->static_data.tree_mmap );
        -:   84:#else
        -:   85:		free( pgdata->static_data.tree );
        -:   86:		pgdata->static_data.tree = NULL;
        -:   87:#endif
       27:   88:}
        -:   89:
        -:   90:
       27:   91:int InitTree( ChewingData *pgdata, const char * prefix )
        -:   92:{
        -:   93:#ifdef USE_BINARY_DATA
        -:   94:	char filename[ PATH_MAX ];
        -:   95:	size_t len;
        -:   96:	size_t offset;
        -:   97:
       27:   98:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, PHONE_TREE_FILE );
       27:   99:	if ( len + 1 > sizeof( filename ) )
    #####:  100:		return -1;
        -:  101:
       27:  102:	plat_mmap_set_invalid( &pgdata->static_data.tree_mmap );
       27:  103:	pgdata->static_data.tree_size = plat_mmap_create( &pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ );
       27:  104:	if ( pgdata->static_data.tree_size <= 0 )
    #####:  105:		return -1;
        -:  106:
       27:  107:	offset = 0;
       27:  108:	pgdata->static_data.tree = (TreeType *) plat_mmap_set_view( &pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size );
       27:  109:	if ( !pgdata->static_data.tree )
    #####:  110:		return -1;
        -:  111:
       27:  112:	return 0;
        -:  113:#else
        -:  114:	char filename[ PATH_MAX ];
        -:  115:	int len;
        -:  116:	FILE *infile = NULL;
        -:  117:	int i;
        -:  118:
        -:  119:	len = snprintf( filename, sizeof( filename ), "%s" PLAT_SEPARATOR "%s", prefix, PHONE_TREE_FILE );
        -:  120:	if ( len + 1 > sizeof( filename ) )
        -:  121:		return -1;
        -:  122:
        -:  123:	infile = fopen( filename, "r" );
        -:  124:	if ( !infile )
        -:  125:		return -1;
        -:  126:
        -:  127:	pgdata->static_data.tree = ALC( TreeType, TREE_SIZE );
        -:  128:	if ( !pgdata->static_data.tree ) {
        -:  129:		fclose( infile );
        -:  130:		return -1;
        -:  131:	}
        -:  132:
        -:  133:	/* XXX: What happen if infile contains more than TREE_SIZE data? */
        -:  134:	for ( i = 0; i < TREE_SIZE; i++ ) {
        -:  135:		if ( fscanf( infile, "%hu%d%d%d",
        -:  136:					&pgdata->static_data.tree[ i ].phone_id,
        -:  137:					&pgdata->static_data.tree[ i ].phrase_id,
        -:  138:					&pgdata->static_data.tree[ i ].child_begin,
        -:  139:					&pgdata->static_data.tree[ i ].child_end ) != 4 )
        -:  140:			break;
        -:  141:	}
        -:  142:
        -:  143:	fclose( infile );
        -:  144:	return 0;
        -:  145:#endif
        -:  146:}
        -:  147:
      383:  148:static int CheckBreakpoint( int from, int to, int bArrBrkpt[] )
        -:  149:{
        -:  150:	int i;
      515:  151:	for ( i = from + 1; i < to; i++ )
      149:  152:		if ( bArrBrkpt[ i ] )
       17:  153:			return 0;
      366:  154:	return 1;
        -:  155:}
        -:  156:
       80:  157:static int CheckUserChoose(
        -:  158:		ChewingData *pgdata,
        -:  159:		uint16_t *new_phoneSeq, int from , int to,
        -:  160:		Phrase **pp_phr,
        -:  161:		char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],
        -:  162:		IntervalType selectInterval[], int nSelect )
        -:  163:{
        -:  164:	IntervalType inte, c;
        -:  165:	int chno, len;
        -:  166:	int user_alloc;
        -:  167:	UserPhraseData *pUserPhraseData;
       80:  168:	Phrase *p_phr = ALC( Phrase, 1 );
        -:  169:
      80*:  170:	assert( p_phr );
       80:  171:	inte.from = from;
       80:  172:	inte.to = to;
       80:  173:	*pp_phr = NULL;
        -:  174:
        -:  175:	/* pass 1
        -:  176:	 * if these exist one selected interval which is not contained by inte
        -:  177:	 * but has intersection with inte, then inte is an unacceptable interval
        -:  178:	 */
       97:  179:	for ( chno = 0; chno < nSelect; chno++ ) {
       17:  180:		c = selectInterval[ chno ];
       17:  181:		if ( IsIntersect( inte, c ) && ! IsContain( inte, c ) ) {
    #####:  182:			free( p_phr );
    #####:  183:			return 0;
        -:  184:		}
        -:  185:	}
        -:  186:
        -:  187:	/* pass 2
        -:  188:	 * if there exist one phrase satisfied all selectStr then return 1, else return 0.
        -:  189:	 * also store the phrase with highest freq
        -:  190:	 */
       80:  191:	pUserPhraseData = UserGetPhraseFirst( pgdata, new_phoneSeq );
       80:  192:	p_phr->freq = -1;
        -:  193:	do {
       97:  194:		for ( chno = 0; chno < nSelect; chno++ ) {
       17:  195:			c = selectInterval[ chno ];
        -:  196:
       17:  197:			if ( IsContain( inte, c ) ) {
        -:  198:				/*
        -:  199:				 * find a phrase of ph_id where the text contains
        -:  200:				 * 'selectStr[chno]' test if not ok then return 0,
        -:  201:				 * if ok then continue to test. */
       11:  202:				len = c.to - c.from;
       11:  203:				if ( memcmp(
       11:  204:					ueStrSeek( pUserPhraseData->wordSeq, c.from - from ),
       11:  205:					selectStr[ chno ],
       11:  206:					ueStrNBytes( selectStr[ chno ], len ) ) )
    #####:  207:					break;
        -:  208:			}
        -:  209:
        -:  210:		}
       80:  211:		if ( chno == nSelect ) {
        -:  212:			/* save phrase data to "pp_phr" */
       80:  213:			if ( pUserPhraseData->userfreq > p_phr->freq ) {
       80:  214:				if ( ( user_alloc = ( to - from ) ) > 0 ) {
       80:  215:					ueStrNCpy( p_phr->phrase,
       80:  216:							pUserPhraseData->wordSeq,
        -:  217:							user_alloc, 1);
        -:  218:				}
       80:  219:				p_phr->freq = pUserPhraseData->userfreq;
       80:  220:				*pp_phr = p_phr;
        -:  221:			}
        -:  222:		}
       80:  223:	} while ( ( pUserPhraseData = UserGetPhraseNext( pgdata, new_phoneSeq ) ) != NULL );
        -:  224:
       80:  225:	if ( p_phr->freq != -1 )
       80:  226:		return 1;
        -:  227:
    #####:  228:	free( p_phr );
    #####:  229:	return 0;
        -:  230:}
        -:  231:
        -:  232:/*
        -:  233: * phrase is said to satisfy a choose interval if
        -:  234: * their intersections are the same */
      337:  235:static int CheckChoose(
        -:  236:		ChewingData *pgdata,
        -:  237:		int ph_id, int from, int to, Phrase **pp_phr,
        -:  238:		char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],
        -:  239:		IntervalType selectInterval[], int nSelect )
        -:  240:{
        -:  241:	IntervalType inte, c;
        -:  242:	int chno, len;
      337:  243:	Phrase *phrase = ALC( Phrase, 1 );
        -:  244:
     337*:  245:	assert( phrase );
      337:  246:	inte.from = from;
      337:  247:	inte.to = to;
      337:  248:	*pp_phr = NULL;
        -:  249:
        -:  250:	/* if there exist one phrase satisfied all selectStr then return 1, else return 0. */
      337:  251:	GetPhraseFirst( pgdata, phrase, ph_id );
        -:  252:	do {
      374:  253:		for ( chno = 0; chno < nSelect; chno++ ) {
       61:  254:			c = selectInterval[ chno ];
        -:  255:
       61:  256:			if ( IsContain( inte, c ) ) {
        -:  257:				/* find a phrase of ph_id where the text contains
        -:  258:				 * 'selectStr[chno]' test if not ok then return 0, if ok
        -:  259:				 * then continue to test
        -:  260:				 */
       31:  261:				len = c.to - c.from;
       31:  262:				if ( memcmp(
       31:  263:					ueStrSeek( phrase->phrase, c.from - from ),
       31:  264:					selectStr[ chno ],
       31:  265:					ueStrNBytes( selectStr[ chno ], len ) ) )
       20:  266:					break;
        -:  267:			}
       30:  268:			else if ( IsIntersect( inte, selectInterval[ chno ] ) ) {
       20:  269:				free( phrase );
       20:  270:				return 0;
        -:  271:			}
        -:  272:		}
      333:  273:		if ( chno == nSelect ) {
      313:  274:			*pp_phr = phrase;
      313:  275:			return 1;
        -:  276:		}
       20:  277:	} while ( GetPhraseNext( pgdata, phrase ) );
        4:  278:	free( phrase );
        4:  279:	return 0;
        -:  280:}
        -:  281:
        -:  282:/** @brief search for the phrases have the same pronunciation.*/
        -:  283:/* if phoneSeq[begin] ~ phoneSeq[end] is a phrase, then add an interval
        -:  284: * from (begin) to (end+1) */
      390:  285:int TreeFindPhrase( ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq )
        -:  286:{
        -:  287:	int child, tree_p, i;
        -:  288:
      390:  289:	tree_p = 0;
      893:  290:	for ( i = begin; i <= end; i++ ) {
   325204:  291:		for (
      529:  292:			child = pgdata->static_data.tree[ tree_p ].child_begin;
   325204:  293:			child != -1 && child <= pgdata->static_data.tree[ tree_p ].child_end;
   324675:  294:			child++ ) {
        -:  295:
        -:  296:#ifdef USE_BINARY_DATA
  325178*:  297:			assert(0 <= child && child * sizeof(TreeType) < pgdata->static_data.tree_size);
        -:  298:#endif
   325178:  299:			if ( pgdata->static_data.tree[ child ].phone_id == phoneSeq[ i ] )
      503:  300:				break;
        -:  301:		}
        -:  302:		/* if not found any word then fail. */
      529:  303:		if ( child == -1 || child > pgdata->static_data.tree[ tree_p ].child_end )
       26:  304:			return -1;
        -:  305:		else {
      503:  306:			tree_p = child;
        -:  307:		}
        -:  308:	}
      364:  309:	return pgdata->static_data.tree[ tree_p ].phrase_id;
        -:  310:}
        -:  311:
      313:  312:static void AddInterval(
        -:  313:		TreeDataType *ptd, int begin , int end,
        -:  314:		int p_id, Phrase *p_phrase, int dict_or_user )
        -:  315:{
      313:  316:	ptd->interval[ ptd->nInterval ].from = begin;
      313:  317:	ptd->interval[ ptd->nInterval ].to = end + 1;
      313:  318:	ptd->interval[ ptd->nInterval ].pho_id = p_id;
      313:  319:	ptd->interval[ ptd->nInterval ].p_phr = p_phrase;
      313:  320:	ptd->interval[ ptd->nInterval ].source = dict_or_user;
      313:  321:	ptd->nInterval++;
      313:  322:}
        -:  323:
        -:  324:/* Item which inserts to interval array */
        -:  325:typedef enum {
        -:  326:	USED_PHRASE_NONE,	/**< none of items used */
        -:  327:	USED_PHRASE_USER,	/**< User phrase */
        -:  328:	USED_PHRASE_DICT	/**< Dict phrase */
        -:  329:} UsedPhraseMode;
        -:  330:
      366:  331:static void internal_release_Phrase( UsedPhraseMode mode, Phrase *pUser, Phrase *pDict )
        -:  332:{
        -:  333:	/* we must free unused phrase entry to avoid memory leak. */
      366:  334:	switch ( mode ) {
       78:  335:		case USED_PHRASE_USER:
       78:  336:			if ( pDict != NULL )
       78:  337:				free( pDict );
       78:  338:			break;
      235:  339:		case USED_PHRASE_DICT:
      235:  340:			if ( pUser != NULL )
        2:  341:				free( pUser );
      235:  342:			break;
       53:  343:		default: /* In fact, it is alwyas 0 */
       53:  344:			if ( pDict != NULL )
    #####:  345:				free( pDict );
       53:  346:			if ( pUser != NULL )
    #####:  347:				free( pUser );
       53:  348:			break;
        -:  349:	}
      366:  350:}
        -:  351:
      254:  352:static void FindInterval( ChewingData *pgdata, TreeDataType *ptd )
        -:  353:{
        -:  354:	int end, begin, pho_id;
        -:  355:	Phrase *p_phrase, *puserphrase, *pdictphrase;
        -:  356:	UsedPhraseMode i_used_phrase;
        -:  357:	uint16_t new_phoneSeq[ MAX_PHONE_SEQ_LEN ];
        -:  358:
      510:  359:	for ( begin = 0; begin < pgdata->nPhoneSeq; begin++ ) {
      639:  360:		for ( end = begin; end < pgdata->nPhoneSeq; end++ ) {
      383:  361:			if ( ! CheckBreakpoint( begin, end + 1, pgdata->bArrBrkpt ) )
       17:  362:				continue;
        -:  363:
        -:  364:			/* set new_phoneSeq */
      366:  365:			memcpy(
        -:  366:				new_phoneSeq,
      366:  367:				&pgdata->phoneSeq[ begin ],
      366:  368:				sizeof( uint16_t ) * ( end - begin + 1 ) );
      366:  369:			new_phoneSeq[ end - begin + 1 ] = 0;
      366:  370:			puserphrase = pdictphrase = NULL;
      366:  371:			i_used_phrase = USED_PHRASE_NONE;
        -:  372:
        -:  373:			/* check user phrase */
      446:  374:			if ( UserGetPhraseFirst( pgdata, new_phoneSeq ) &&
       80:  375:					CheckUserChoose( pgdata, new_phoneSeq, begin, end + 1,
       80:  376:					&p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect ) ) {
       80:  377:				puserphrase = p_phrase;
        -:  378:			}
        -:  379:
        -:  380:			/* check dict phrase */
      366:  381:			pho_id = TreeFindPhrase( pgdata, begin, end, pgdata->phoneSeq );
      366:  382:			if (
      337:  383:				( pho_id != -1 ) &&
      337:  384:				CheckChoose(
        -:  385:					pgdata,
        -:  386:					pho_id, begin, end + 1,
      337:  387:					&p_phrase, pgdata->selectStr,
      337:  388:					pgdata->selectInterval, pgdata->nSelect ) ) {
      313:  389:				pdictphrase = p_phrase;
        -:  390:			}
        -:  391:
        -:  392:			/* add only one interval, which has the largest freqency
        -:  393:			 * but when the phrase is the same, the user phrase overrides
        -:  394:			 * static dict
        -:  395:			 */
      366:  396:			if ( puserphrase != NULL && pdictphrase == NULL ) {
    #####:  397:				i_used_phrase = USED_PHRASE_USER;
        -:  398:			}
      366:  399:			else if ( puserphrase == NULL && pdictphrase != NULL ) {
      233:  400:				i_used_phrase = USED_PHRASE_DICT;
        -:  401:			}
      133:  402:			else if ( puserphrase != NULL && pdictphrase != NULL ) {
        -:  403:				/* the same phrase, userphrase overrides */
       80:  404:				if ( ! strcmp(
       80:  405:					puserphrase->phrase,
       80:  406:					pdictphrase->phrase ) ) {
       78:  407:					i_used_phrase = USED_PHRASE_USER;
        -:  408:				}
        -:  409:				else {
        2:  410:					if ( puserphrase->freq > pdictphrase->freq ) {
    #####:  411:						i_used_phrase = USED_PHRASE_USER;
        -:  412:					}
        -:  413:					else {
        2:  414:						i_used_phrase = USED_PHRASE_DICT;
        -:  415:					}
        -:  416:				}
        -:  417:			}
      366:  418:			switch ( i_used_phrase ) {
       78:  419:				case USED_PHRASE_USER:
       78:  420:					AddInterval( ptd, begin, end, -1, puserphrase,
        -:  421:							IS_USER_PHRASE );
       78:  422:					break;
      235:  423:				case USED_PHRASE_DICT:
      235:  424:					AddInterval( ptd, begin, end, pho_id, pdictphrase,
        -:  425:							IS_DICT_PHRASE );
      235:  426:					break;
       53:  427:				case USED_PHRASE_NONE:
        -:  428:				default:
       53:  429:					break;
        -:  430:			}
      366:  431:			internal_release_Phrase(
        -:  432:				i_used_phrase,
        -:  433:				puserphrase,
        -:  434:				pdictphrase );
        -:  435:		}
        -:  436:	}
      254:  437:}
        -:  438:
      254:  439:static void SetInfo( int len, TreeDataType *ptd )
        -:  440:{
        -:  441:	int i, a;
        -:  442:
      764:  443:	for ( i = 0; i <= len; i++ )
      510:  444:		ptd->leftmost[ i ] = i;
      567:  445:	for ( i = 0; i < ptd->nInterval; i++ ) {
      313:  446:		ptd->graph[ ptd->interval[ i ].from ][ ptd->interval[ i ].to ] = 1;
      313:  447:		ptd->graph[ ptd->interval[ i ].to ][ ptd->interval[ i ].from ] = 1;
        -:  448:	}
        -:  449:
        -:  450:	/* set leftmost */
      764:  451:	for ( a = 0; a <= len; a++ ) {
     1786:  452:		for ( i = 0; i <= len; i++ ) {
     1276:  453:			if ( ! ( ptd->graph[ a ][ i ] ) )
      650:  454:				continue;
      626:  455:			if ( ptd->leftmost[ i ] < ptd->leftmost[ a ] )
      248:  456:				ptd->leftmost[ a ] = ptd->leftmost[ i ];
        -:  457:		}
        -:  458:	}
      254:  459:}
        -:  460:
        -:  461:/*
        -:  462: * First we compare the 'nMatchCnnct'.
        -:  463: * If the values are the same, we will compare the 'score'
        -:  464: */
    #####:  465:static int CompRecord( const RecordNode **pa, const RecordNode **pb )
        -:  466:{
    #####:  467:	int diff = (*pb)->nMatchCnnct - (*pa)->nMatchCnnct;
        -:  468:
    #####:  469:	if ( diff )
    #####:  470:		return diff;
    #####:  471:	return ( (*pb)->score - (*pa)->score );
        -:  472:}
        -:  473:
        -:  474:
        -:  475:/*
        -:  476: * Remove the interval containing in another interval.
        -:  477: *
        -:  478: * Example:
        -:  479: * 國民大會 has three interval: 國民, 大會, 國民大會. This function removes
        -:  480: * 國名, 大會 becasue 國民大會 contains 國民 and 大會.
        -:  481: */
      254:  482:static void Discard1( TreeDataType *ptd )
        -:  483:{
        -:  484:	int a, b;
        -:  485:	char failflag[ INTERVAL_SIZE ];
        -:  486:	int nInterval2;
        -:  487:
      254:  488:	memset( failflag, 0, sizeof( failflag ) );
      567:  489:	for ( a = 0; a < ptd->nInterval; a++ ) {
      313:  490:		if ( failflag[ a ] )
       65:  491:			continue;
      732:  492:		for ( b = 0; b < ptd->nInterval; b++ ) {
      545:  493:			if ( a == b || failflag[ b ] )
      264:  494:				continue ;
      281:  495:			if ( ptd->interval[ b ].from >= ptd->interval[ a ].from &&
      239:  496:				ptd->interval[ b ].to <= ptd->interval[ a ].to )
      130:  497:				continue;
      151:  498:			if ( ptd->interval[ b ].from <= ptd->interval[ a ].from &&
      103:  499:				ptd->interval[ b ].to <= ptd->interval[ a ].from )
       42:  500:				continue;
      109:  501:			if ( ptd->interval[ b ].from >= ptd->interval[ a ].to &&
       48:  502:				ptd->interval[ b ].to >= ptd->interval[ a ].to )
       48:  503:				continue;
       61:  504:			break;
        -:  505:		}
        -:  506:		/* if any other interval b is inside or leftside or rightside the
        -:  507:		 * interval a */
      248:  508:		if ( b >= ptd->nInterval ) {
        -:  509:			/* then kill all the intervals inside the interval a */
        -:  510:			int i;
      596:  511:			for ( i = 0; i < ptd->nInterval; i++ )  {
      409:  512:				if (
      409:  513:					! failflag[ i ] && i != a &&
      210:  514:					ptd->interval[ i ].from >=
      210:  515:						ptd->interval[ a ].from &&
      174:  516:					ptd->interval[ i ].to <= ptd->interval[ a ].to ) {
      126:  517:					failflag[ i ] = 1;
        -:  518:				}
        -:  519:			}
        -:  520:		}
        -:  521:	}
        -:  522:	/* discard all the intervals whose failflag[a] = 1 */
      254:  523:	nInterval2 = 0;
      567:  524:	for ( a = 0; a < ptd->nInterval; a++ ) {
      313:  525:		if ( ! failflag[ a ] ) {
      187:  526:			ptd->interval[ nInterval2++ ] = ptd->interval[ a ];
        -:  527:		}
        -:  528:		else {
      126:  529:			if ( ptd->interval[ a ].p_phr != NULL ) {
      126:  530:				free( ptd->interval[ a ].p_phr );
        -:  531:			}
        -:  532:		}
        -:  533:	}
      254:  534:	ptd->nInterval = nInterval2;
      254:  535:}
        -:  536:
        -:  537:/*
        -:  538: * Remove the interval that cannot connect to head or tail by other intervals.
        -:  539: *
        -:  540: * Example:
        -:  541: * The input string length is 5
        -:  542: * The available intervals are [1,1], [1,2], [2,3], [2,4], [5,5], [3,5].
        -:  543: *
        -:  544: * The possible connection from head to tail are [1,2][3,5], and
        -:  545: * [1,1][2,4][5,5]. Since [2,3] cannot connect to head or tail, it is removed
        -:  546: * by this function.
        -:  547: */
      254:  548:static void Discard2( TreeDataType *ptd )
        -:  549:{
        -:  550:	int i, j;
        -:  551:	char overwrite[ MAX_PHONE_SEQ_LEN ], failflag[ MAX_PHONE_SEQ_LEN ];
        -:  552:	int nInterval2;
        -:  553:
      254:  554:	memset( failflag, 0, sizeof( failflag ) );
      441:  555:	for ( i = 0; i < ptd->nInterval; i++ ) {
      187:  556:		if ( ptd->leftmost[ ptd->interval[ i ].from ] == 0 )
      187:  557:			continue;
        -:  558:		/* test if interval i is overwrited by other intervals */
    #####:  559:		memset( overwrite, 0, sizeof( overwrite ) );
    #####:  560:		for ( j = 0; j < ptd->nInterval; j++ ) {
    #####:  561:			if ( j == i )
    #####:  562:				continue;
    #####:  563:			memset(
    #####:  564:				&overwrite[ ptd->interval[ j ].from ],
        -:  565:				1,
    #####:  566:				ptd->interval[ j ].to - ptd->interval[ j ].from );
        -:  567:		}
    #####:  568:		if ( memchr(
    #####:  569:			&overwrite[ ptd->interval[ i ].from ],
        -:  570:			1,
    #####:  571:			ptd->interval[ i ].to - ptd->interval[ i ].from ) )
    #####:  572:			failflag[ i ] = 1;
        -:  573:	}
        -:  574:	/* discard all the intervals whose failflag[a] = 1 */
      254:  575:	nInterval2 = 0;
      441:  576:	for ( i = 0; i < ptd->nInterval; i++ )
      187:  577:		if ( ! failflag[ i ] )
      187:  578:			ptd->interval[ nInterval2++ ] = ptd->interval[ i ];
      254:  579:	ptd->nInterval = nInterval2;
      254:  580:}
        -:  581:
      254:  582:static void LoadChar( ChewingData *pgdata, char *buf, int buf_len, const uint16_t phoneSeq[], int nPhoneSeq )
        -:  583:{
        -:  584:	int i;
        -:  585:	Word word;
        -:  586:
      254:  587:	memset(buf, 0, buf_len);
      510:  588:	for ( i = 0; i < nPhoneSeq; i++ ) {
      256:  589:		GetCharFirst( pgdata, &word, phoneSeq[ i ] );
      256:  590:		strncat(buf, word.word, buf_len - strlen(buf) - 1);
        -:  591:	}
      254:  592:	buf[ buf_len - 1 ] = '\0';
      254:  593:}
        -:  594:
        -:  595:/* kpchen said, record is the index array of interval */
      254:  596:static void OutputRecordStr(
        -:  597:		ChewingData *pgdata,
        -:  598:		char *out_buf, int out_buf_len,
        -:  599:		const int *record, int nRecord,
        -:  600:		uint16_t phoneSeq[], int nPhoneSeq,
        -:  601:		char selectStr[][ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ],
        -:  602:		IntervalType selectInterval[],
        -:  603:		int nSelect, const TreeDataType *ptd )
        -:  604:{
        -:  605:	PhraseIntervalType inter;
        -:  606:	int i;
        -:  607:
      254:  608:	LoadChar( pgdata, out_buf, out_buf_len, phoneSeq, nPhoneSeq );
      441:  609:	for ( i = 0; i < nRecord; i++ ) {
      187:  610:		inter = ptd->interval[ record[ i ] ];
      187:  611:		ueStrNCpy(
      187:  612:				ueStrSeek( out_buf, inter.from ),
      187:  613:				( inter.p_phr )->phrase,
      187:  614:				( inter.to - inter.from ), -1);
        -:  615:	}
      265:  616:	for ( i = 0; i < nSelect; i++ ) {
       11:  617:		inter.from = selectInterval[ i ].from;
       11:  618:		inter.to = selectInterval[ i ].to ;
       11:  619:		ueStrNCpy(
       11:  620:				ueStrSeek( out_buf, inter.from ),
       11:  621:				selectStr[ i ], ( inter.to - inter.from ), -1);
        -:  622:	}
      254:  623:}
        -:  624:
      306:  625:static int rule_largest_sum( const int *record, int nRecord, const TreeDataType *ptd )
        -:  626:{
      306:  627:	int i, score = 0;
        -:  628:	PhraseIntervalType inter;
        -:  629:
      680:  630:	for ( i = 0; i < nRecord; i++ ) {
      374:  631:		inter = ptd->interval[ record[ i ] ];
     374*:  632:		assert( inter.p_phr );
      374:  633:		score += inter.to - inter.from;
        -:  634:	}
      306:  635:	return score;
        -:  636:}
        -:  637:
      153:  638:static int rule_largest_avgwordlen( const int *record, int nRecord, const TreeDataType *ptd )
        -:  639:{
        -:  640:	/* constant factor 6=1*2*3, to keep value as integer */
      153:  641:	return 6 * rule_largest_sum( record, nRecord, ptd ) / nRecord;
        -:  642:}
        -:  643:
      153:  644:static int rule_smallest_lenvariance( const int *record, int nRecord, const TreeDataType *ptd )
        -:  645:{
      153:  646:	int i, j, score = 0;
        -:  647:	PhraseIntervalType inter1, inter2;
        -:  648:
        -:  649:	/* kcwu: heuristic? why variance no square function? */
      340:  650:	for ( i = 0; i < nRecord; i++ ) {
      223:  651:		for ( j = i + 1; j < nRecord; j++ ) {
       36:  652:			inter1 = ptd->interval[ record[ i ] ];
       36:  653:			inter2 = ptd->interval[ record[ j ] ];
      36*:  654:			assert( inter1.p_phr && inter2.p_phr );
       36:  655:			score += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));
        -:  656:		}
        -:  657:	}
      153:  658:	return -score;
        -:  659:}
        -:  660:
      153:  661:static int rule_largest_freqsum( const int *record, int nRecord, const TreeDataType *ptd )
        -:  662:{
      153:  663:	int i, score = 0;
        -:  664:	PhraseIntervalType inter;
        -:  665:
      340:  666:	for ( i = 0; i < nRecord; i++ ) {
      187:  667:		inter = ptd->interval[ record[ i ] ];
     187*:  668:		assert( inter.p_phr );
        -:  669:
        -:  670:		/* We adjust the 'freq' of One-word Phrase */
      187:  671:		score += ( inter.to - inter.from == 1 ) ?
      187:  672:			( inter.p_phr->freq / 512 ) :
       61:  673:			inter.p_phr->freq;
        -:  674:	}
      153:  675:	return score;
        -:  676:}
        -:  677:
      254:  678:static int LoadPhraseAndCountScore( const int *record, int nRecord, const TreeDataType *ptd )
        -:  679:{
      254:  680:	int total_score = 0;
        -:  681:	/* NOTE: the balance factor is tuneable */
      254:  682:	if (nRecord) {
      153:  683:		total_score += 1000*rule_largest_sum( record, nRecord, ptd );
      153:  684:		total_score += 1000*rule_largest_avgwordlen( record, nRecord, ptd );
      153:  685:		total_score += 100*rule_smallest_lenvariance( record, nRecord, ptd );
      153:  686:		total_score += rule_largest_freqsum( record, nRecord, ptd );
        -:  687:	}
      254:  688:	return total_score;
        -:  689:}
        -:  690:
    #####:  691:static int IsRecContain( const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd )
        -:  692:{
        -:  693:	int big, sml;
        -:  694:
    #####:  695:	for ( big = 0, sml = 0; sml < nB; sml++ ) {
    #####:  696:		while (
    #####:  697:			( big < nA ) &&
    #####:  698:			ptd->interval[ intA[ big ] ].from <
    #####:  699:				ptd->interval[ intB[ sml ] ].to ) {
    #####:  700:			if ( PhraseIntervalContain(
    #####:  701:				ptd->interval[ intA[ big ] ],
    #####:  702:				ptd->interval[ intB[ sml ] ] ) )
    #####:  703:				break;
    #####:  704:			big++;
        -:  705:		}
    #####:  706:		if (
    #####:  707:			( big >= nA ) ||
    #####:  708:			ptd->interval[ intA[ big ] ].from >=
    #####:  709:				ptd->interval[ intB[ sml ] ].to )
    #####:  710:			return 0;
        -:  711:	}
    #####:  712:	return 1;
        -:  713:}
        -:  714:
      254:  715:static void SortListByScore( TreeDataType *ptd )
        -:  716:{
        -:  717:	int i, listLen;
        -:  718:	RecordNode *p, **arr;
        -:  719:
      508:  720:	for (
      254:  721:		listLen = 0, p = ptd->phList;
        -:  722:		p;
      254:  723:		listLen++, p = p->next )
        -:  724:		;
      254:  725:	ptd->nPhListLen = listLen;
        -:  726:
      254:  727:	arr = ALC( RecordNode *, listLen );
     254*:  728:	assert( arr );
        -:  729:
      508:  730:	for (
      254:  731:		i = 0, p = ptd->phList;
        -:  732:		i < listLen;
      254:  733:		p = p->next, i++ ) {
      254:  734:		arr[ i ] = p;
      254:  735:		p->score = LoadPhraseAndCountScore(
      254:  736:			p->arrIndex,
        -:  737:			p->nInter,
        -:  738:			ptd );
        -:  739:	}
        -:  740:
      254:  741:	qsort( arr, listLen, sizeof( RecordNode * ), (CompFuncType) CompRecord );
        -:  742:
      254:  743:	ptd->phList = arr[ 0 ];
     254*:  744:	for ( i = 1; i < listLen; i++ ) {
    #####:  745:		arr[ i - 1 ]->next = arr[ i ];
        -:  746:	}
      254:  747:	arr[ listLen - 1 ]->next = NULL;
        -:  748:
      254:  749:	free( arr );
      254:  750:}
        -:  751:
        -:  752:/* when record==NULL then output the "link list" */
      254:  753:static void SaveRecord( const int *record, int nInter, TreeDataType *ptd )
        -:  754:{
        -:  755:	RecordNode *now, *p, *pre;
        -:  756:
      254:  757:	pre = NULL;
      254:  758:	for ( p = ptd->phList; p; ) {
        -:  759:		/* if  'p' contains 'record', then discard 'record'. */
    #####:  760:		if ( IsRecContain( p->arrIndex, p->nInter, record, nInter, ptd ) )
    #####:  761:			return;
        -:  762:
        -:  763:		/* if 'record' contains 'p', then discard 'p'
        -:  764:		 * -- We must deal with the linked list. */
    #####:  765:		if ( IsRecContain( record, nInter, p->arrIndex, p->nInter, ptd ) ) {
    #####:  766:			RecordNode *tp = p;
        -:  767:
    #####:  768:			if ( pre )
    #####:  769:				pre->next = p->next;
        -:  770:			else
    #####:  771:				ptd->phList = ptd->phList->next;
    #####:  772:			p = p->next;
    #####:  773:			free( tp->arrIndex );
    #####:  774:			free( tp );
        -:  775:		}
        -:  776:		else
    #####:  777:			pre = p, p = p->next;
        -:  778:	}
      254:  779:	now = ALC( RecordNode, 1 );
     254*:  780:	assert( now );
      254:  781:	now->next = ptd->phList;
      254:  782:	now->arrIndex = ALC( int, nInter );
     254*:  783:	assert( now->arrIndex );
      254:  784:	now->nInter = nInter;
      254:  785:	memcpy( now->arrIndex, record, nInter * sizeof( int ) );
      254:  786:	ptd->phList = now;
        -:  787:}
        -:  788:
      441:  789:static void RecursiveSave( int depth, int to, int *record, TreeDataType *ptd )
        -:  790:{
        -:  791:	int first, i;
        -:  792:	/* to find first interval */
      882:  793:	for (
      441:  794:		first = record[ depth - 1 ] + 1;
      441:  795:		ptd->interval[ first ].from < to && first < ptd->nInterval;
    #####:  796:		first++ )
        -:  797:		;
        -:  798:
      441:  799:	if ( first == ptd->nInterval ) {
      254:  800:		SaveRecord( record + 1, depth - 1, ptd );
      254:  801:		return;
        -:  802:	}
      187:  803:	record[ depth ] = first;
      187:  804:	RecursiveSave( depth + 1, ptd->interval[ first ].to, record, ptd );
        -:  805:	/* for each interval which intersects first */
      187:  806:	for (
      187:  807:		i= first + 1;
      187:  808:		PhraseIntervalIntersect(
        -:  809:			ptd->interval[ first ],
       49:  810:			ptd->interval[ i ] ) && i < ptd->nInterval;
    #####:  811:			i++ ) {
    #####:  812:		record[ depth ] = i;
    #####:  813:		RecursiveSave( depth + 1, ptd->interval[ i ].to,record, ptd );
        -:  814:	}
        -:  815:}
        -:  816:
      254:  817:static void SaveList( TreeDataType *ptd )
        -:  818:{
      254:  819:	int record[ MAX_PHONE_SEQ_LEN + 1 ] = { -1 };
        -:  820:
      254:  821:	RecursiveSave( 1, 0, record, ptd );
      254:  822:}
        -:  823:
      254:  824:static void InitPhrasing( TreeDataType *ptd )
        -:  825:{
      254:  826:	memset( ptd, 0, sizeof( TreeDataType ) );
      254:  827:}
        -:  828:
      254:  829:static void SaveDispInterval( PhrasingOutput *ppo, TreeDataType *ptd )
        -:  830:{
        -:  831:	int i;
        -:  832:
      441:  833:	for ( i = 0; i < ptd->phList->nInter; i++ ) {
      187:  834:		ppo->dispInterval[ i ].from =
      187:  835:			ptd->interval[ ptd->phList->arrIndex[ i ] ].from;
      187:  836:		ppo->dispInterval[ i ].to =
      187:  837:			ptd->interval[ ptd->phList->arrIndex[ i ] ].to;
        -:  838:	}
      254:  839:	ppo->nDispInterval = ptd->phList->nInter;
      254:  840:}
        -:  841:
      254:  842:static void CleanUpMem( TreeDataType *ptd )
        -:  843:{
        -:  844:	int i;
        -:  845:	RecordNode *pNode;
        -:  846:
      441:  847:	for ( i = 0; i < ptd->nInterval; i++ ) {
      187:  848:		if ( ptd->interval[ i ].p_phr ) {
      187:  849:			free( ptd->interval[ i ].p_phr );
      187:  850:			ptd->interval[ i ].p_phr = NULL;
        -:  851:		}
        -:  852:	}
      508:  853:	while ( ptd->phList != NULL ) {
      254:  854:		pNode = ptd->phList;
      254:  855:		ptd->phList = pNode->next;
      254:  856:		free( pNode->arrIndex );
      254:  857:		free( pNode );
        -:  858:	}
      254:  859:}
        -:  860:
      254:  861:static void CountMatchCnnct( TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq )
        -:  862:{
        -:  863:	RecordNode *p;
        -:  864:	int i, k, sum;
        -:  865:
      508:  866:	for ( p = ptd->phList; p; p = p->next ) {
        -:  867:		/* for each record, count its 'nMatchCnnct' */
      357:  868:		for ( sum = 0, i = 1; i < nPhoneSeq; i++ ) {
      103:  869:			if ( !bUserArrCnnct[ i ] )
      102:  870:				continue;
        -:  871:			/* check if matching 'cnnct' */
        3:  872:			for ( k = 0; k < p->nInter; k++ ) {
        2:  873:				if (
        2:  874:					ptd->interval[ p->arrIndex[ k ] ].from < i &&
        1:  875:					ptd->interval[ p->arrIndex[ k ] ].to > i ) {
    #####:  876:					sum++;
    #####:  877:					break;
        -:  878:				}
        -:  879:			}
        -:  880:		}
      254:  881:		p->nMatchCnnct = sum;
        -:  882:	}
      254:  883:}
        -:  884:
      254:  885:static void ShowList( ChewingData *pgdata, const TreeDataType *ptd )
        -:  886:{
        -:  887:	const RecordNode *p;
        -:  888:	int i;
        -:  889:
      254:  890:	DEBUG_OUT( "After SaveList :\n" );
      508:  891:	for ( p = ptd->phList; p; p = p->next ) {
      254:  892:		DEBUG_OUT( "  interval : " );
      441:  893:		for ( i = 0; i < p->nInter; i++ ) {
      187:  894:			DEBUG_OUT(
        -:  895:				"[%d %d] ",
        -:  896:				ptd->interval[ p->arrIndex[ i ] ].from,
        -:  897:				ptd->interval[ p->arrIndex[ i ] ].to );
        -:  898:		}
      254:  899:		DEBUG_OUT(
        -:  900:			"\n"
        -:  901:			   "      score : %d , nMatchCnnct : %d\n",
        -:  902:			p->score,
        -:  903:			p->nMatchCnnct );
        -:  904:	}
      254:  905:	DEBUG_OUT( "\n" );
      254:  906:}
        -:  907:
      254:  908:static RecordNode* NextCut( TreeDataType *tdt, PhrasingOutput *ppo )
        -:  909:{
        -:  910:	/* pop nNumCut-th candidate to first */
        -:  911:	int i;
        -:  912:	RecordNode *former;
        -:  913:	RecordNode *want;
        -:  914:
      254:  915:	if ( ppo->nNumCut >= tdt->nPhListLen )
        1:  916:		ppo->nNumCut = 0;
      254:  917:	if (ppo->nNumCut == 0)
      254:  918:		return tdt->phList;
        -:  919:
        -:  920:	/* find the former of our candidate */
    #####:  921:	former = tdt->phList;
    #####:  922:	for ( i = 0; i < ppo->nNumCut - 1; i++ ) {
    #####:  923:		former = former->next;
    #####:  924:		assert( former );
        -:  925:	}
        -:  926:
        -:  927:	/* take the candidate out of the listed list */
    #####:  928:	want = former->next;
    #####:  929:	assert( want );
    #####:  930:	former->next = former->next->next;
        -:  931:
        -:  932:	/* prepend to front of list */
    #####:  933:	want->next = tdt->phList;
    #####:  934:	tdt->phList = want;
        -:  935:
    #####:  936:	return tdt->phList;
        -:  937:}
        -:  938:
      254:  939:int Phrasing( ChewingData *pgdata )
        -:  940:{
        -:  941:	TreeDataType treeData;
        -:  942:
      254:  943:	InitPhrasing( &treeData );
        -:  944:
      254:  945:	FindInterval( pgdata, &treeData );
      254:  946:	SetInfo( pgdata->nPhoneSeq, &treeData );
      254:  947:	Discard1( &treeData );
      254:  948:	Discard2( &treeData );
      254:  949:	SaveList( &treeData );
      254:  950:	CountMatchCnnct( &treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq );
      254:  951:	SortListByScore( &treeData );
      254:  952:	NextCut( &treeData, &pgdata->phrOut );
        -:  953:
      254:  954:	ShowList( pgdata, &treeData );
        -:  955:
        -:  956:	/* set phrasing output */
      254:  957:	OutputRecordStr(
        -:  958:		pgdata,
      254:  959:		pgdata->phrOut.chiBuf, sizeof(pgdata->phrOut.chiBuf),
      254:  960:		( treeData.phList )->arrIndex,
      254:  961:		( treeData.phList )->nInter,
      254:  962:		pgdata->phoneSeq,
        -:  963:		pgdata->nPhoneSeq,
      254:  964:		pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect, &treeData );
      254:  965:	SaveDispInterval( &pgdata->phrOut, &treeData );
        -:  966:
        -:  967:	/* free "phrase" */
      254:  968:	CleanUpMem( &treeData );
      254:  969:	return 0;
        -:  970:}
