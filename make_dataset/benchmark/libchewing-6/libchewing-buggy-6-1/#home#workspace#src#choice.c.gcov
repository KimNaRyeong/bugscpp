        -:    0:Source:/home/workspace/src/choice.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/choice.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/choice.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * chewingio.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004-2008, 2010, 2011, 2012
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: * @file choice.c
        -:   17: * @brief Choice module
        -:   18: */
        -:   19:
        -:   20:#include <string.h>
        -:   21:#include <assert.h>
        -:   22:
        -:   23:#include "chewing-definition.h"
        -:   24:#include "chewing-utf8-util.h"
        -:   25:#include "global.h"
        -:   26:#include "dict-private.h"
        -:   27:#include "char-private.h"
        -:   28:#include "chewingutil.h"
        -:   29:#include "tree-private.h"
        -:   30:#include "userphrase-private.h"
        -:   31:#include "choice-private.h"
        -:   32:#include "zuin-private.h"
        -:   33:#include "private.h"
        -:   34:
        5:   35:static void ChangeSelectIntervalAndBreakpoint(
        -:   36:		ChewingData *pgdata,
        -:   37:		int from,
        -:   38:		int to,
        -:   39:		const char *str )
        -:   40:{
        -:   41:	int i;
        -:   42:	int user_alloc;
        -:   43:
        -:   44:	IntervalType inte;
        -:   45:
        5:   46:	inte.from = from;
        5:   47:	inte.to = to;
       11:   48:	for ( i = 0; i < pgdata->nSelect; i++ ) {
        6:   49:		if ( IsIntersect( inte, pgdata->selectInterval[ i ] ) ) {
        5:   50:			RemoveSelectElement( i, pgdata );
        5:   51:			i--;
        -:   52:		}
        -:   53:	}
        -:   54:
        5:   55:	pgdata->selectInterval[ pgdata->nSelect ].from = from;
        5:   56:	pgdata->selectInterval[ pgdata->nSelect ].to = to;
        -:   57:
        -:   58:	/* No available selection */
        5:   59:	if ( ( user_alloc = ( to - from ) ) == 0 )
    #####:   60:		return;
        -:   61:
        5:   62:	ueStrNCpy( pgdata->selectStr[ pgdata->nSelect ],
        -:   63:			str,
        -:   64:			user_alloc, 1);
        5:   65:	pgdata->nSelect++;
        -:   66:
        5:   67:	if ( user_alloc > 1 ) {
        2:   68:		memset( &pgdata->bUserArrBrkpt[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );
        2:   69:		memset( &pgdata->bUserArrCnnct[ from + 1 ], 0, sizeof( int ) * ( user_alloc - 1 ) );
        -:   70:	}
        -:   71:}
        -:   72:
        -:   73:/** @brief Loading all possible phrases after the cursor from long to short into AvailInfo structure.*/
        5:   74:static void SetAvailInfo( ChewingData *pgdata, int begin, int end)
        -:   75:{
        5:   76:	AvailInfo *pai = &( pgdata->availInfo );
        5:   77:	const uint16_t *phoneSeq = pgdata->phoneSeq;
        5:   78:	int nPhoneSeq = pgdata->nPhoneSeq;
        5:   79:	const int *bSymbolArrBrkpt = pgdata->bSymbolArrBrkpt;
        -:   80:
        -:   81:	int pho_id;
        -:   82:	int diff;
        -:   83:	uint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];
        -:   84:
        -:   85:	int i, head, head_tmp;
        -:   86:	int tail, tail_tmp;
        -:   87:
        5:   88:	head = tail = 0;
        -:   89:
        5:   90:	pai->nAvail = 0;
        -:   91:
        5:   92:	if ( pgdata->config.bPhraseChoiceRearward ) {
        8:   93:		for ( i = end; i >= begin; i--){
        5:   94:			head = i;
        5:   95:			if ( bSymbolArrBrkpt[ i ] )
    #####:   96:				break;
        -:   97:		}
        3:   98:		head_tmp = end;
        -:   99:	} else {
        2:  100:		head_tmp = head = begin;
        -:  101:	}
        -:  102:
        5:  103:	if ( pgdata->config.bPhraseChoiceRearward ) {
        3:  104:		tail_tmp = tail = end;
        -:  105:	} else {
        6:  106:		for ( i = begin; i < nPhoneSeq; i++ ) {
        4:  107:			if ( bSymbolArrBrkpt[ i ] )
    #####:  108:				break;
        4:  109:			tail = i;
        -:  110:		}
        2:  111:		tail_tmp = begin;
        -:  112:	}
        -:  113:
       14:  114:	while ( head <= head_tmp && tail_tmp <= tail ) {
        9:  115:		diff = tail_tmp - head_tmp;
        9:  116:		pho_id = TreeFindPhrase( pgdata, head_tmp, tail_tmp, phoneSeq );
        -:  117:
        9:  118:		if ( pho_id != -1 ) {
        -:  119:			/* save it! */
        9:  120:			pai->avail[ pai->nAvail ].len = diff + 1;
        9:  121:			pai->avail[ pai->nAvail ].id = pho_id;
        9:  122:			pai->nAvail++;
        -:  123:		}
        -:  124:		else {
    #####:  125:			memcpy(
        -:  126:				userPhoneSeq,
    #####:  127:				&phoneSeq[ head_tmp ],
    #####:  128:				sizeof( uint16_t ) * ( diff + 1 ) ) ;
    #####:  129:			userPhoneSeq[ diff + 1 ] = 0;
    #####:  130:			if ( UserGetPhraseFirst( pgdata, userPhoneSeq ) ) {
        -:  131:				/* save it! */
    #####:  132:				pai->avail[ pai->nAvail ].len = diff + 1;
    #####:  133:				pai->avail[ pai->nAvail ].id = -1;
    #####:  134:				pai->nAvail++;
        -:  135:			} else {
    #####:  136:				pai->avail[ pai->nAvail ].len = 0;
    #####:  137:				pai->avail[ pai->nAvail ].id = -1;
        -:  138:			}
        -:  139:		}
        -:  140:
        9:  141:		if ( pgdata->config.bPhraseChoiceRearward ) {
        5:  142:			head_tmp--;
        -:  143:		} else {
        4:  144:			tail_tmp++;
        -:  145:		}
        -:  146:	}
        5:  147:}
        -:  148:
        -:  149:/* FIXME: Improper use of len parameter */
      184:  150:static int ChoiceTheSame( ChoiceInfo *pci, const char *str, int len )
        -:  151:{
        -:  152:	int i;
        -:  153:
     6594:  154:	for ( i = 0; i < pci->nTotalChoice; i++ )
     6410:  155:		if ( ! memcmp( pci->totalChoiceStr[ i ], str, len ) )
    #####:  156:			return 1;
      184:  157:	return 0;
        -:  158:}
        -:  159:
        5:  160:static void ChoiceInfoAppendChi( ChewingData *pgdata,  ChoiceInfo *pci, uint16_t phone )
        -:  161:{
        -:  162:	Word tempWord;
        -:  163:	int len;
        5:  164:	if ( GetCharFirst( pgdata, &tempWord, phone ) ) {
        -:  165:		do {
      174:  166:			len = ueBytesFromChar( tempWord.word[ 0 ] );
      174:  167:			if ( ChoiceTheSame( pci, tempWord.word,
        -:  168:					    len) )
    #####:  169:				continue;
     174*:  170:			assert( pci->nTotalChoice < MAX_CHOICE );
      174:  171:			memcpy(
      174:  172:				pci->totalChoiceStr[ pci->nTotalChoice ],
        -:  173:				tempWord.word, len );
      174:  174:			pci->totalChoiceStr[ pci->nTotalChoice ]
      174:  175:					   [ len ] = '\0';
      174:  176:			pci->nTotalChoice++;
      174:  177:		} while ( GetCharNext( pgdata, &tempWord ) );
        -:  178:	}
        5:  179:}
        -:  180:
        -:  181:/** @brief Loading all possible phrases of certain length.
        -:  182: *
        -:  183: * Loading all possible phrases of certain length into ChoiceInfo structure
        -:  184: * from static and dynamic dictionaries, including number of total pages and
        -:  185: * the number of current page.
        -:  186: */
       11:  187:static void SetChoiceInfo( ChewingData *pgdata )
        -:  188:{
        -:  189:	Phrase tempPhrase;
        -:  190:	int len;
        -:  191:	UserPhraseData *pUserPhraseData;
        -:  192:	uint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];
        -:  193:
       11:  194:	ChoiceInfo *pci = &( pgdata->choiceInfo );
       11:  195:	AvailInfo *pai = &( pgdata->availInfo );
       11:  196:	uint16_t *phoneSeq = pgdata->phoneSeq;
       11:  197:	uint16_t *phoneSeqAlt = pgdata->phoneSeqAlt;
       11:  198:	int cursor = PhoneSeqCursor( pgdata );
       11:  199:	int candPerPage = pgdata->config.candPerPage;
        -:  200:
        -:  201:	/* Clears previous candidates. */
       11:  202:	memset( pci->totalChoiceStr, '\0',
        -:  203:		MAX_CHOICE * MAX_PHRASE_LEN * MAX_UTF8_SIZE + 1);
        -:  204:
       11:  205:	pci->nTotalChoice = 0;
       11:  206:	len = pai->avail[ pai->currentAvail ].len;
      11*:  207:	assert(len);
        -:  208:
        -:  209:	/* secondly, read tree phrase */
       11:  210:	if ( len == 1 ) { /* single character */
        5:  211:		ChoiceInfoAppendChi( pgdata, pci, phoneSeq[ cursor ] );
        -:  212:
        5:  213:		if ( phoneSeq[ cursor ] != phoneSeqAlt[ cursor ] ) {
    #####:  214:			ChoiceInfoAppendChi( pgdata, pci, phoneSeqAlt[ cursor ] );
        -:  215:		}
        -:  216:
        5:  217:		if ( pgdata->zuinData.kbtype == KB_HSU ||
        5:  218:		     pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {
    #####:  219:			switch ( phoneSeq[ cursor ] ) {
    #####:  220:				case 0x2800:	/* 'ㄘ' */
    #####:  221:					ChoiceInfoAppendChi( pgdata, pci,
        -:  222:						0x30 );		/* 'ㄟ' */
    #####:  223:					break;
    #####:  224:				case 0x80:	/* 'ㄧ' */
    #####:  225:					ChoiceInfoAppendChi( pgdata, pci,
        -:  226:						0x20 );		/* 'ㄝ' */
    #####:  227:					break;
    #####:  228:				case 0x2A00:	/* 'ㄙ' */
    #####:  229:					ChoiceInfoAppendChi( pgdata, pci,
        -:  230:						0x1 );		/* '˙' */
    #####:  231:					break;
    #####:  232:				case 0xA00:	/* 'ㄉ' */
    #####:  233:					ChoiceInfoAppendChi( pgdata, pci,
        -:  234:						0x2 );		/* 'ˊ' */
    #####:  235:					break;
    #####:  236:				case 0x800:	/* 'ㄈ' */
    #####:  237:					ChoiceInfoAppendChi( pgdata, pci,
        -:  238:						0x3 ); 		/* 'ˇ' */
    #####:  239:					break;
    #####:  240:				case 0x18:	/* 'ㄜ' */
    #####:  241:					ChoiceInfoAppendChi( pgdata, pci,
        -:  242:						0x1200 );	/* 'ㄍ' */
    #####:  243:					break;
    #####:  244:				case 0x10:	/* 'ㄛ' */
    #####:  245:					ChoiceInfoAppendChi( pgdata, pci,
        -:  246:						0x1600 );	/* 'ㄏ' */
    #####:  247:					break;
    #####:  248:				case 0x1E00:	/* 'ㄓ' */
    #####:  249:					ChoiceInfoAppendChi( pgdata, pci,
        -:  250:						0x1800 );	/* 'ㄐ' */
    #####:  251:					ChoiceInfoAppendChi( pgdata, pci,
        -:  252:						0x4 );		/* 'ˋ' */
    #####:  253:					break;
    #####:  254:				case 0x58:	/* 'ㄤ' */
    #####:  255:					ChoiceInfoAppendChi( pgdata, pci,
        -:  256:						0x1400 );	/* 'ㄎ' */
    #####:  257:					break;
    #####:  258:				case 0x68:	/* 'ㄦ' */
    #####:  259:					ChoiceInfoAppendChi( pgdata, pci,
        -:  260:						0x1000 );	/* 'ㄌ' */
    #####:  261:					ChoiceInfoAppendChi( pgdata, pci,
        -:  262:						0x60 );		/* 'ㄥ' */
    #####:  263:					break;
    #####:  264:				case 0x2200:	/* 'ㄕ' */
    #####:  265:					ChoiceInfoAppendChi( pgdata, pci,
        -:  266:						0x1C00 );	/* 'ㄒ' */
    #####:  267:					break;
    #####:  268:				case 0x2000:	/* 'ㄔ' */
    #####:  269:					ChoiceInfoAppendChi( pgdata, pci,
        -:  270:						0x1A00 );	/* 'ㄑ' */
    #####:  271:					break;
    #####:  272:				case 0x50:	/* 'ㄣ' */
    #####:  273:					ChoiceInfoAppendChi( pgdata, pci,
        -:  274:						0xE00 );	/* 'ㄋ' */
    #####:  275:					break;
    #####:  276:				case 0x48:	/* 'ㄢ' */
    #####:  277:					ChoiceInfoAppendChi( pgdata, pci,
        -:  278:						0x600 );	/* 'ㄇ' */
    #####:  279:					break;
    #####:  280:				default:
    #####:  281:					break;
        -:  282:			}
        5:  283:		}
        -:  284:	}
        -:  285:	/* phrase */
        -:  286:	else {
        6:  287:		if ( pai->avail[ pai->currentAvail ].id != -1 ) {
        6:  288:			GetPhraseFirst( pgdata, &tempPhrase, pai->avail[ pai->currentAvail ].id );
        -:  289:			do {
       10:  290:				if ( ChoiceTheSame(
        -:  291:					pci,
        -:  292:					tempPhrase.phrase,
       10:  293:					len * ueBytesFromChar( tempPhrase.phrase[0] ) ) ) {
    #####:  294:					continue;
        -:  295:				}
       10:  296:				ueStrNCpy( pci->totalChoiceStr[ pci->nTotalChoice ],
        -:  297:						tempPhrase.phrase, len, 1);
       10:  298:				pci->nTotalChoice++;
       10:  299:			} while( GetPhraseNext( pgdata, &tempPhrase ) );
        -:  300:		}
        -:  301:
        6:  302:		memcpy( userPhoneSeq, &phoneSeq[ cursor ], sizeof( uint16_t ) * len );
        6:  303:		userPhoneSeq[ len ] = 0;
        6:  304:		pUserPhraseData = UserGetPhraseFirst( pgdata, userPhoneSeq );
        6:  305:		if ( pUserPhraseData ) {
        -:  306:			do {
        -:  307:				/* check if the phrase is already in the choice list */
    #####:  308:				if ( ChoiceTheSame(
        -:  309:					pci,
    #####:  310:					pUserPhraseData->wordSeq,
    #####:  311:					len * ueBytesFromChar( pUserPhraseData->wordSeq[0] ) ) )
    #####:  312:					continue;
        -:  313:				/* otherwise store it */
    #####:  314:				ueStrNCpy(
    #####:  315:						pci->totalChoiceStr[ pci->nTotalChoice ],
    #####:  316:						pUserPhraseData->wordSeq,
        -:  317:						len, 1);
    #####:  318:				pci->nTotalChoice++;
        -:  319:			} while ( ( pUserPhraseData =
    #####:  320:				    UserGetPhraseNext( pgdata, userPhoneSeq ) ) != NULL );
        -:  321:		}
        -:  322:
        -:  323:	}
        -:  324:
        -:  325:	/* magic number */
       11:  326:	pci->nChoicePerPage = candPerPage;
      11*:  327:	assert( pci->nTotalChoice > 0 );
       11:  328:	pci->nPage = CEIL_DIV( pci->nTotalChoice, pci->nChoicePerPage );
       11:  329:	pci->pageNo = 0;
       11:  330:	pci->isSymbol = WORD_CHOICE;
       11:  331:}
        -:  332:
        -:  333:/*
        -:  334: * Seek the start of the phrase (English characters are skipped.)
        -:  335: */
        3:  336:static int SeekPhraseHead( ChewingData *pgdata )
        -:  337:{
        -:  338:	int i;
        3:  339:	int phoneSeq = PhoneSeqCursor( pgdata );
       3*:  340:	for ( i = pgdata->nPrefer - 1; i >= 0; i-- ) {
        3:  341:		if ( pgdata->preferInterval[ i ].from > phoneSeq
        3:  342:				|| pgdata->preferInterval[ i ].to < phoneSeq )
    #####:  343:			continue;
        3:  344:		return pgdata->preferInterval[ i ].from;
        -:  345:	}
    #####:  346:	return 0;
        -:  347:}
        -:  348:
        -:  349:/** @brief Enter choice mode and relating initialisations. */
        5:  350:int ChoiceFirstAvail( ChewingData *pgdata )
        -:  351:{
        -:  352:	int end, begin;
        -:  353:
        -:  354:	/* save old cursor position */
        5:  355:	pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
        -:  356:
        -:  357:	/* see if there is some word in the cursor position */
        5:  358:	if ( pgdata->chiSymbolBufLen == pgdata->chiSymbolCursor ) {
        2:  359:		pgdata->chiSymbolCursor--;
        -:  360:	}
        -:  361:
        5:  362:	end = PhoneSeqCursor( pgdata );
        -:  363:
        5:  364:	if ( pgdata->config.bPhraseChoiceRearward ) {
        6:  365:		pgdata->chiSymbolCursor = SeekPhraseHead( pgdata ) +
        3:  366:			CountSymbols( pgdata, pgdata->chiSymbolCursor );
        -:  367:	}
        5:  368:	begin = PhoneSeqCursor( pgdata );
        -:  369:
        5:  370:	pgdata->bSelect = 1;
        -:  371:
        5:  372:	SetAvailInfo( pgdata, begin, end );
        -:  373:
        5:  374:	if ( ! pgdata->availInfo.nAvail )
    #####:  375:		return ChoiceEndChoice( pgdata );
        -:  376:
        5:  377:	pgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;
        5:  378:	SetChoiceInfo( pgdata );
        5:  379:	return 0;
        -:  380:}
        -:  381:
    #####:  382:int ChoicePrevAvail( ChewingContext *ctx )
        -:  383:{
    #####:  384:	ChewingData *pgdata = ctx->data;
    #####:  385:	if (pgdata->choiceInfo.isSymbol != WORD_CHOICE) return 0;
    #####:  386:	if ( ++( pgdata->availInfo.currentAvail ) >= pgdata->availInfo.nAvail )
    #####:  387:		pgdata->availInfo.currentAvail = 0;
    #####:  388:	SetChoiceInfo( pgdata );
    #####:  389:	return 0;
        -:  390:}
        -:  391:
        -:  392:/** @brief Return the next phrase not longer than the previous phrase. */
        6:  393:int ChoiceNextAvail( ChewingData *pgdata )
        -:  394:{
       6*:  395:	if (pgdata->choiceInfo.isSymbol) return 0;
        6:  396:	if ( --( pgdata->availInfo.currentAvail ) < 0 )
        2:  397:		pgdata->availInfo.currentAvail = pgdata->availInfo.nAvail - 1;
        6:  398:	SetChoiceInfo( pgdata );
        6:  399:	return 0;
        -:  400:}
        -:  401:
       10:  402:int ChoiceEndChoice( ChewingData *pgdata )
        -:  403:{
       10:  404:	pgdata->bSelect = 0;
       10:  405:	pgdata->choiceInfo.nTotalChoice = 0;
       10:  406:	pgdata->choiceInfo.nPage = 0;
        -:  407:
       10:  408:	if ( pgdata->choiceInfo.isSymbol != WORD_CHOICE || pgdata->choiceInfo.isSymbol != SYMBOL_CHOICE_INSERT ) {
        -:  409:		/* return to the old chiSymbolCursor position */
       10:  410:		pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor;
      10*:  411:		assert ( pgdata->chiSymbolCursor <= pgdata->chiSymbolBufLen );
        -:  412:	}
       10:  413:	pgdata->choiceInfo.isSymbol = WORD_CHOICE;
       10:  414:	return 0;
        -:  415:}
        -:  416:
        5:  417:static void ChangeUserData( ChewingData *pgdata, int selectNo )
        -:  418:{
        -:  419:	uint16_t userPhoneSeq[ MAX_PHONE_SEQ_LEN ];
        -:  420:	int len;
        -:  421:
        5:  422:	len = ueStrLen( pgdata->choiceInfo.totalChoiceStr[ selectNo ] );
       10:  423:	memcpy(
        -:  424:		userPhoneSeq,
        5:  425:		&( pgdata->phoneSeq[ PhoneSeqCursor( pgdata ) ] ),
        -:  426:		len * sizeof( uint16_t ) );
        5:  427:	userPhoneSeq[ len ] = 0;
        5:  428:	UserUpdatePhrase( pgdata, userPhoneSeq, pgdata->choiceInfo.totalChoiceStr[ selectNo ] );
        5:  429:}
        -:  430:
        -:  431:/** @brief commit the selected phrase. */
        5:  432:int ChoiceSelect( ChewingData *pgdata, int selectNo )
        -:  433:{
        5:  434:	ChoiceInfo *pci = &( pgdata->choiceInfo );
        5:  435:	AvailInfo *pai = &( pgdata->availInfo );
        -:  436:
        5:  437:	ChangeUserData( pgdata, selectNo );
        5:  438:	ChangeSelectIntervalAndBreakpoint(
        -:  439:			pgdata,
        -:  440:			PhoneSeqCursor( pgdata ),
        5:  441:			PhoneSeqCursor( pgdata ) + pai->avail[ pai->currentAvail ].len,
        5:  442:			pci->totalChoiceStr[ selectNo ] );
        5:  443:	ChoiceEndChoice( pgdata );
        5:  444:	return 0;
        -:  445:}
        -:  446:
