        -:    0:Source:/home/workspace/src/hash.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/hash.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/hash.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * hash.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004, 2005, 2006, 2007, 2008, 2011, 2012, 2013
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:#include <string.h>
        -:   16:#include <sys/stat.h>
        -:   17:/* ISO C99 Standard: 7.10/5.2.4.2.1 Sizes of integer types */
        -:   18:#include <limits.h>
        -:   19:#include <stdlib.h>
        -:   20:#include <stdio.h>
        -:   21:
        -:   22:#include "chewing-private.h"
        -:   23:#include "chewing-utf8-util.h"
        -:   24:#include "hash-private.h"
        -:   25:#include "private.h"
        -:   26:#include "memory-private.h"
        -:   27:
        5:   28:int AlcUserPhraseSeq( UserPhraseData *pData, int phonelen, int wordlen )
        -:   29:{
        5:   30:	pData->phoneSeq = ALC( uint16_t, phonelen + 1 );
        5:   31:	if ( !pData->phoneSeq )
    #####:   32:		goto error;
        5:   33:	pData->wordSeq = ALC( char, wordlen + 1 );
        5:   34:	if ( !pData->wordSeq )
    #####:   35:		goto error;
        -:   36:
        5:   37:	return 1;
        -:   38:
    #####:   39:error:
    #####:   40:	free( pData->phoneSeq );
    #####:   41:	free( pData->wordSeq );
    #####:   42:	return 0;
        -:   43:}
        -:   44:
      170:   45:static int PhoneSeqTheSame( const uint16_t p1[], const uint16_t p2[] )
        -:   46:{
        -:   47:	int i;
      170:   48:	if ( ! p1 || ! p2 )	/* FIXME: should not happend. */
    #####:   49:		return 0;
        -:   50:
      434:   51:	for ( i = 0; ( p1[ i ] != 0 && p2[ i ] != 0 ); i++ ) {
      264:   52:		if ( p1[ i ] != p2[ i ] )
    #####:   53:			return 0;
        -:   54:	}
      170:   55:	if ( p1[ i ] != p2[ i ] )
    #####:   56:		return 0;
      170:   57:	return 1;
        -:   58:}
        -:   59:
      526:   60:static unsigned int HashFunc( const uint16_t phoneSeq[] )
        -:   61:{
      526:   62:	int i, value = 0;
        -:   63:
     1276:   64:	for ( i = 0; phoneSeq[ i ] != 0; i++ )
      750:   65:		value ^= phoneSeq[ i ];
      526:   66:	return ( value & ( HASH_TABLE_SIZE - 1 ) );
        -:   67:}
        -:   68:
      547:   69:HASH_ITEM *HashFindPhonePhrase( ChewingData *pgdata, const uint16_t phoneSeq[], HASH_ITEM *pItemLast )
        -:   70:{
     1009:   71:	HASH_ITEM *pNow = pItemLast ?
        -:   72:			pItemLast->next :
      462:   73:			pgdata->static_data.hashtable[ HashFunc( phoneSeq ) ];
        -:   74:
     547*:   75:	for ( ; pNow; pNow = pNow->next )
      165:   76:		if ( PhoneSeqTheSame( pNow->data.phoneSeq, phoneSeq ) )
      165:   77:			return pNow;
      382:   78:	return NULL;
        -:   79:}
        -:   80:
       15:   81:HASH_ITEM *HashFindEntry( ChewingData *pgdata, const uint16_t phoneSeq[], const char wordSeq[] )
        -:   82:{
        -:   83:	HASH_ITEM *pItem;
        -:   84:	int hashvalue;
        -:   85:
       15:   86:	hashvalue = HashFunc( phoneSeq );
        -:   87:
      15*:   88:	for ( pItem = pgdata->static_data.hashtable[ hashvalue ]; pItem ; pItem = pItem->next ) {
        5:   89:		if (
       10:   90:			! strcmp( pItem->data.wordSeq, wordSeq ) &&
        5:   91:			PhoneSeqTheSame( pItem->data.phoneSeq, phoneSeq ) ) {
        5:   92:			return pItem;
        -:   93:		}
        -:   94:	}
       10:   95:	return NULL;
        -:   96:}
        -:   97:
        5:   98:HASH_ITEM *HashInsert( ChewingData *pgdata, UserPhraseData *pData )
        -:   99:{
        -:  100:	int hashvalue;
        -:  101:	HASH_ITEM *pItem;
        -:  102:
        5:  103:	pItem = HashFindEntry( pgdata, pData->phoneSeq, pData->wordSeq );
        5:  104:	if ( pItem != NULL )
    #####:  105:		return pItem;
        -:  106:
        5:  107:	pItem = ALC( HASH_ITEM, 1 );
        5:  108:	if ( ! pItem )
    #####:  109:		return NULL;  /* Error occurs */
        -:  110:
        5:  111:	hashvalue = HashFunc( pData->phoneSeq );
        -:  112:	/* set the new element */
        5:  113:	pItem->next = pgdata->static_data.hashtable[ hashvalue ];
        -:  114:
        5:  115:	memcpy( &( pItem->data ), pData, sizeof( pItem->data ) );
        5:  116:	pItem->item_index = -1;
        -:  117:
        -:  118:	/* set link to the new element */
        5:  119:	pgdata->static_data.hashtable[ hashvalue ] = pItem;
        -:  120:
        5:  121:	return pItem;
        -:  122:}
        -:  123:
       10:  124:static void HashItem2String( char *str, HASH_ITEM *pItem )
        -:  125:{
        -:  126:	int i, len;
        -:  127:	char buf[ FIELD_SIZE ];
        -:  128:
       10:  129:	sprintf( str, "%s ", pItem->data.wordSeq );
       10:  130:	len = ueStrLen( pItem->data.wordSeq );
       30:  131:	for ( i = 0; i < len; i++ ) {
       20:  132:		sprintf( buf, "%hu ", pItem->data.phoneSeq[ i ] );
       20:  133:		strcat( str, buf );
        -:  134:	}
       10:  135:	sprintf(
        -:  136:		buf, "%d %d %d %d",
        -:  137:		pItem->data.userfreq, pItem->data.recentTime,
        -:  138:		pItem->data.maxfreq, pItem->data.origfreq );
       10:  139:	strcat( str, buf );
       10:  140:}
        -:  141:
        -:  142:/*
        -:  143: * capacity of 'str' MUST bigger then FIELD_SIZE !
        -:  144: */
       10:  145:static void HashItem2Binary( char *str, HASH_ITEM *pItem )
        -:  146:{
        -:  147:	int i, phraselen;
        -:  148:	char *pc;
        -:  149:
       10:  150:	memset( str, 0, FIELD_SIZE );
       10:  151:	if ( sizeof(int) * 4 + ueStrLen( pItem->data.wordSeq ) * 2 +
       10:  152:	     strlen( pItem->data.wordSeq ) >= FIELD_SIZE ) {
        -:  153:		/* exceed buffer size */
    #####:  154:		return;
        -:  155:	}
        -:  156:
        -:  157:	/* freq info */
       10:  158:	PutInt32( pItem->data.userfreq, &str[ 0 ] );
       10:  159:	PutInt32( pItem->data.recentTime, &str[ 4 ] );
       10:  160:	PutInt32( pItem->data.maxfreq, &str[ 8 ] );
       10:  161:	PutInt32( pItem->data.origfreq, &str[ 12 ] );
        -:  162:
        -:  163:	/* phone seq*/
       10:  164:	phraselen = ueStrLen( pItem->data.wordSeq );
       10:  165:	str[ 16 ] = phraselen;
       10:  166:	pc = &str[ 17 ];
       30:  167:	for ( i = 0; i < phraselen; i++ ) {
       20:  168:		PutUint16( pItem->data.phoneSeq[ i ], pc );
       20:  169:		pc += 2;
        -:  170:	}
        -:  171:
        -:  172:	/* phrase */
       10:  173:	*pc = strlen( pItem->data.wordSeq );
       10:  174:	strcpy( (pc + 1), pItem->data.wordSeq );
       10:  175:	pItem->data.wordSeq[ (unsigned char) *pc ] = '\0';
        -:  176:}
        -:  177:
       10:  178:void HashModify( ChewingData *pgdata, HASH_ITEM *pItem )
        -:  179:{
        -:  180:	FILE *outfile;
        -:  181:	char str[ FIELD_SIZE + 1 ];
        -:  182:
       10:  183:	outfile = fopen( pgdata->static_data.hashfilename, "r+b" );
       10:  184:	if ( !outfile )
    #####:  185:		return;
        -:  186:
        -:  187:	/* update "lifetime" */
       10:  188:	fseek( outfile, strlen( BIN_HASH_SIG ), SEEK_SET );
       10:  189:	fwrite( &pgdata->static_data.chewing_lifetime, 1, 4, outfile );
       10:  190:	sprintf( str, "%d", pgdata->static_data.chewing_lifetime );
       10:  191:	DEBUG_OUT( "HashModify-1: '%-75s'\n", str );
        -:  192:
        -:  193:	/* update record */
       10:  194:	if ( pItem->item_index < 0 ) {
        5:  195:		fseek( outfile, 0, SEEK_END );
        5:  196:		pItem->item_index =
        5:  197:			( ftell( outfile ) - 4 - strlen( BIN_HASH_SIG ) ) / FIELD_SIZE;
        -:  198:	}
        -:  199:	else {
        5:  200:		fseek( outfile,
        5:  201:			pItem->item_index * FIELD_SIZE + 4 + strlen( BIN_HASH_SIG ),
        -:  202:			SEEK_SET );
        -:  203:	}
        -:  204:
       10:  205:	HashItem2String( str, pItem );
       10:  206:	DEBUG_OUT( "HashModify-2: '%-75s'\n", str );
        -:  207:
       10:  208:	HashItem2Binary( str, pItem );
       10:  209:	fwrite( str, 1, FIELD_SIZE, outfile );
       10:  210:	fflush( outfile );
       10:  211:	fclose( outfile );
        -:  212:}
        -:  213:
       44:  214:static int isValidChineseString( char *str )
        -:  215:{
       44:  216:	if ( str == NULL || *str == '\0' ) {
    #####:  217:		return 0;
        -:  218:	}
      106:  219:	while ( *str != '\0' )  {
       62:  220:		int len = ueBytesFromChar( (unsigned char) *str );
       62:  221:		if ( len <= 1 ) {
    #####:  222:			return 0;
        -:  223:		}
       62:  224:		str += len;
        -:  225:	};
       44:  226:	return 1;
        -:  227:}
        -:  228:
        -:  229:/**
        -:  230: * @return 1, 0 or -1
        -:  231: * retval 0	end of file
        -:  232: * retval 1	continue
        -:  233: * retval -1	ignore this record
        -:  234: */
       44:  235:static int ReadHashItem_bin( const char *srcbuf, HASH_ITEM *pItem, int item_index )
        -:  236:{
        -:  237:	int len, i;
        -:  238:	const char *pc;
        -:  239:
       44:  240:	memset( pItem, 0, sizeof(HASH_ITEM) );
        -:  241:
        -:  242:	/* freq info */
       44:  243:	pItem->data.userfreq	= GetInt32(&srcbuf[ 0 ]);
       44:  244:	pItem->data.recentTime	= GetInt32(&srcbuf[ 4 ]);
       44:  245:	pItem->data.maxfreq	= GetInt32(&srcbuf[ 8 ]);
       44:  246:	pItem->data.origfreq	= GetInt32(&srcbuf[ 12 ]);
        -:  247:
        -:  248:	/* phone seq, length in num of chi words */
       44:  249:	len = (int) srcbuf[ 16 ];
       44:  250:	pItem->data.phoneSeq = ALC( uint16_t, len + 1 );
       44:  251:	pc = &srcbuf[ 17 ];
      106:  252:	for ( i = 0; i < len; i++ ) {
       62:  253:		pItem->data.phoneSeq[ i ] = GetUint16( pc );
       62:  254:		pc += 2;
        -:  255:	}
       44:  256:	pItem->data.phoneSeq[ i ] = 0;
        -:  257:
        -:  258:	/* phrase, length in num of bytes */
       44:  259:	pItem->data.wordSeq = ALC( char, (*pc) + 1 );
       44:  260:	strcpy( pItem->data.wordSeq, (char *) (pc + 1) );
       44:  261:	pItem->data.wordSeq[ (unsigned int) *pc ] = '\0';
        -:  262:
        -:  263:	/* Invalid UTF-8 Chinese characters found */
       44:  264:	if ( ! isValidChineseString( pItem->data.wordSeq ) ) {
    #####:  265:		goto ignore_corrupted_record;
        -:  266:	}
        -:  267:
        -:  268:	/* set item_index */
       44:  269:	pItem->item_index = item_index;
        -:  270:
       44:  271:	return 1; /* continue */
        -:  272:
    #####:  273:ignore_corrupted_record:
    #####:  274:	if ( pItem->data.phoneSeq != NULL ) {
    #####:  275:		free( pItem->data.phoneSeq );
    #####:  276:		pItem->data.phoneSeq = NULL;
        -:  277:	}
    #####:  278:	if ( pItem->data.wordSeq != NULL ) {
    #####:  279:		free( pItem->data.wordSeq );
    #####:  280:		pItem->data.wordSeq = NULL;
        -:  281:	}
    #####:  282:	return -1; /* ignore */
        -:  283:}
        -:  284:
        -:  285:/**
        -:  286: * @return 1, 0 or -1
        -:  287: * retval -1 Ignore bad data item
        -:  288: */
    #####:  289:static int ReadHashItem_txt( FILE *infile, HASH_ITEM *pItem, int item_index )
        -:  290:{
        -:  291:	int len, i, word_len;
        -:  292:	char wordbuf[ 64 ];
        -:  293:
        -:  294:	/* read wordSeq */
    #####:  295:	if ( fscanf( infile, "%s", wordbuf ) != 1 )
    #####:  296:		return 0;
        -:  297:
        -:  298:	/* Invalid UTF-8 Chinese characters found */
    #####:  299:	if ( ! isValidChineseString( wordbuf ) ) {
    #####:  300:		fseek( infile, FIELD_SIZE - strlen( wordbuf ) - 1, SEEK_CUR );
    #####:  301:		return -1;
        -:  302:	}
        -:  303:
    #####:  304:	word_len = strlen( wordbuf );
    #####:  305:	pItem->data.wordSeq = ALC( char, word_len + 1 );
    #####:  306:	strcpy( pItem->data.wordSeq, wordbuf );
        -:  307:
        -:  308:	/* read phoneSeq */
    #####:  309:	len = ueStrLen( pItem->data.wordSeq );
    #####:  310:	pItem->data.phoneSeq = ALC( uint16_t, len + 1 );
    #####:  311:	for ( i = 0; i < len; i++ )
    #####:  312:		if ( fscanf( infile, "%hu", &( pItem->data.phoneSeq[ i ] ) ) != 1 )
    #####:  313:			return 0;
    #####:  314:	pItem->data.phoneSeq[ len ] = 0;
        -:  315:
        -:  316:	/* read userfreq & recentTime */
    #####:  317:	if ( fscanf( infile, "%d %d %d %d",
        -:  318:	             &(pItem->data.userfreq),
        -:  319:	             &(pItem->data.recentTime),
        -:  320:	             &(pItem->data.maxfreq),
        -:  321:	             &(pItem->data.origfreq) ) != 4 )
    #####:  322:		return 0;
        -:  323:
        -:  324:	/* set item_index */
    #####:  325:	pItem->item_index = item_index;
        -:  326:
    #####:  327:	return 1;
        -:  328:}
        -:  329:
       27:  330:static FILE *open_file_get_length(
        -:  331:		const char *filename,
        -:  332:		const char *otype, int *size)
        -:  333:{
       27:  334:	FILE *tf = fopen( filename, otype );
       27:  335:	if ( tf == NULL ) {
        3:  336:		return NULL;
        -:  337:	}
       24:  338:	if ( size != NULL ) {
       24:  339:		fseek( tf, 0, SEEK_END );
       24:  340:		*size = ftell( tf );
       24:  341:		fseek( tf, 0, SEEK_SET );
        -:  342:	}
       24:  343:	return tf;
        -:  344:}
        -:  345:
       27:  346:static char *_load_hash_file( const char *filename, int *size )
        -:  347:{
        -:  348:	int flen;
       27:  349:	char *pd = NULL;
        -:  350:	FILE *tf;
        -:  351:
       27:  352:	tf = open_file_get_length( filename, "rb", &flen );
       27:  353:	if ( tf == NULL ) {
        3:  354:		goto err_load_file;
        -:  355:	}
       24:  356:	pd = ALC( char, flen );
       24:  357:	if ( pd == NULL ) {
    #####:  358:		goto err_load_file;
        -:  359:	}
       24:  360:	if ( fread( pd, flen, 1, tf ) != 1 ) {
    #####:  361:		goto err_load_file;
        -:  362:	}
       24:  363:	fclose( tf );
       24:  364:	if ( size != NULL )
       24:  365:		*size = flen;
       24:  366:	return pd;
        -:  367:
        3:  368:err_load_file:
        3:  369:	if ( pd != NULL )
    #####:  370:		free( pd );
        3:  371:	if ( tf != NULL )
    #####:  372:		fclose( tf );
        3:  373:	return NULL;
        -:  374:}
        -:  375:
        -:  376:/* migrate from text-based hash to binary form */
    #####:  377:static int migrate_hash_to_bin( ChewingData *pgdata )
        -:  378:{
        -:  379:	FILE *txtfile;
        -:  380:	char oldname[ 256 ], *dump, *seekdump;
        -:  381:	HASH_ITEM item;
        -:  382:	int item_index, iret, tflen;
        -:  383:	int ret;
    #####:  384:	const char *ofilename = pgdata->static_data.hashfilename;
        -:  385:
        -:  386:	/* allocate dump buffer */
    #####:  387:	txtfile = open_file_get_length( ofilename, "r", &tflen );
    #####:  388:	if ( txtfile == NULL ) {
    #####:  389:		return 0;
        -:  390:	}
    #####:  391:	dump = ALC( char, tflen * 2 );
    #####:  392:	if ( dump == NULL ) {
    #####:  393:		fclose( txtfile );
    #####:  394:		return 0;
        -:  395:	}
    #####:  396:	ret = fscanf( txtfile, "%d", &pgdata->static_data.chewing_lifetime );
    #####:  397:	if ( ret != 1 ) {
    #####:  398:		return 0;
        -:  399:	}
        -:  400:
        -:  401:	/* prepare the bin file */
    #####:  402:	seekdump = dump;
    #####:  403:	memcpy( seekdump, BIN_HASH_SIG, strlen( BIN_HASH_SIG ) );
    #####:  404:	memcpy( seekdump + strlen( BIN_HASH_SIG ),
    #####:  405:	        &pgdata->static_data.chewing_lifetime,
        -:  406:		sizeof(pgdata->static_data.chewing_lifetime) );
    #####:  407:	seekdump += strlen( BIN_HASH_SIG ) + sizeof(pgdata->static_data.chewing_lifetime);
        -:  408:
        -:  409:	/* migrate */
    #####:  410:	item_index = 0;
        -:  411:	while ( 1 ) {
    #####:  412:		iret = ReadHashItem_txt( txtfile, &item, ++item_index );
        -:  413:
    #####:  414:		if ( iret == -1 ) {
    #####:  415:			--item_index;
    #####:  416:			continue;
        -:  417:		}
    #####:  418:		else if ( iret == 0 )
    #####:  419:			break;
        -:  420:
    #####:  421:		HashItem2Binary( seekdump, &item );
    #####:  422:		seekdump += FIELD_SIZE;
    #####:  423:		free( item.data.phoneSeq );
    #####:  424:		free( item.data.wordSeq );
        -:  425:	};
    #####:  426:	fclose( txtfile );
        -:  427:
        -:  428:	/* backup as *.old */
    #####:  429:	strncpy( oldname, ofilename, sizeof(oldname) );
    #####:  430:	strncat( oldname, ".old", sizeof(oldname) - strlen(oldname) - 1 );
    #####:  431:	oldname[ sizeof(oldname) - 1 ] = '\0';
    #####:  432:	PLAT_UNLINK( oldname );
    #####:  433:	PLAT_RENAME( ofilename, oldname );
        -:  434:
        -:  435:	/* dump new file */
    #####:  436:	PLAT_UNLINK( ofilename );
    #####:  437:	txtfile = fopen( ofilename, "w+b" );
    #####:  438:	fwrite( dump, seekdump - dump, 1, txtfile );
    #####:  439:	fflush( txtfile );
    #####:  440:	fclose( txtfile );
    #####:  441:	free( dump );
        -:  442:
    #####:  443:	return 1;
        -:  444:}
        -:  445:
   442368:  446:static void FreeHashItem( HASH_ITEM *aItem )
        -:  447:{
   442368:  448:	if ( aItem ) {
       49:  449:		HASH_ITEM *pItem = aItem->next;
       49:  450:		free( aItem->data.phoneSeq );
       49:  451:		free( aItem->data.wordSeq );
       49:  452:		free( aItem );
       49:  453:		if ( pItem ) {
    #####:  454:			FreeHashItem( pItem );
        -:  455:		}
        -:  456:	}
   442368:  457:}
        -:  458:
       27:  459:void TerminateHash( ChewingData *pgdata )
        -:  460:{
        -:  461:	HASH_ITEM *pItem;
        -:  462:	int i;
   442395:  463:	for ( i = 0; i < HASH_TABLE_SIZE; ++i ) {
   442368:  464:		pItem = pgdata->static_data.hashtable[ i ];
   442368:  465:		DEBUG_CHECKPOINT();
   442368:  466:		FreeHashItem( pItem );
        -:  467:	}
       27:  468:}
        -:  469:
       27:  470:int InitHash( ChewingData *pgdata )
        -:  471:{
       27:  472:	HASH_ITEM item, *pItem, *pPool = NULL;
       27:  473:	int item_index, hashvalue, iret, fsize, hdrlen, oldest = INT_MAX;
        -:  474:	char *dump, *seekdump;
        -:  475:
       27:  476:	const char *path = getenv( "CHEWING_USER_PATH" );
        -:  477:
        -:  478:	/* make sure of write permission */
       27:  479:	if ( path && access( path, W_OK ) == 0 ) {
       27:  480:		sprintf( pgdata->static_data.hashfilename, "%s" PLAT_SEPARATOR "%s", path, HASH_FILE );
        -:  481:	} else {
    #####:  482:		if ( getenv( "HOME" ) ) {
    #####:  483:			sprintf(
    #####:  484:				pgdata->static_data.hashfilename, "%s%s",
        -:  485:				getenv( "HOME" ), CHEWING_HASH_PATH );
        -:  486:		}
        -:  487:		else {
    #####:  488:			sprintf(
    #####:  489:				pgdata->static_data.hashfilename, "%s%s",
        -:  490:				PLAT_TMPDIR, CHEWING_HASH_PATH );
        -:  491:		}
    #####:  492:		PLAT_MKDIR( pgdata->static_data.hashfilename );
    #####:  493:		strcat( pgdata->static_data.hashfilename, PLAT_SEPARATOR );
    #####:  494:		strcat( pgdata->static_data.hashfilename, HASH_FILE );
        -:  495:	}
       27:  496:	memset( pgdata->static_data.hashtable, 0, sizeof( pgdata->static_data.hashtable ) );
        -:  497:
       27:  498:open_hash_file:
       27:  499:	dump = _load_hash_file( pgdata->static_data.hashfilename, &fsize );
       27:  500:	hdrlen = strlen( BIN_HASH_SIG ) + sizeof(pgdata->static_data.chewing_lifetime);
       27:  501:	item_index = 0;
       30:  502:	if ( dump == NULL || fsize < hdrlen ) {
        -:  503:		FILE *outfile;
        3:  504:		outfile = fopen( pgdata->static_data.hashfilename, "w+b" );
        3:  505:		if ( ! outfile ) {
    #####:  506:			if ( dump ) {
    #####:  507:				free( dump );
        -:  508:			}
    #####:  509:			return 0;
        -:  510:		}
        3:  511:		pgdata->static_data.chewing_lifetime = 0;
        3:  512:		fwrite( BIN_HASH_SIG, 1, strlen( BIN_HASH_SIG ), outfile );
        3:  513:		fwrite( &pgdata->static_data.chewing_lifetime, 1,
        -:  514:		                sizeof(pgdata->static_data.chewing_lifetime), outfile );
        3:  515:		fclose( outfile );
        -:  516:	}
        -:  517:	else {
       24:  518:		if ( memcmp(dump, BIN_HASH_SIG, strlen(BIN_HASH_SIG)) != 0 ) {
        -:  519:			/* perform migrate from text-based to binary form */
    #####:  520:			free( dump );
    #####:  521:			if ( ! migrate_hash_to_bin( pgdata ) ) {
    #####:  522:				return  0;
        -:  523:			}
    #####:  524:			goto open_hash_file;
        -:  525:		}
        -:  526:
       24:  527:		pgdata->static_data.chewing_lifetime = *(int *) (dump + strlen( BIN_HASH_SIG ));
       24:  528:		seekdump = dump + hdrlen;
       24:  529:		fsize -= hdrlen;
        -:  530:
       68:  531:		while ( fsize >= FIELD_SIZE ) {
       44:  532:			iret = ReadHashItem_bin( seekdump, &item, item_index++ );
        -:  533:			/* Ignore illegal data */
       44:  534:			if ( iret == -1 ) {
    #####:  535:				seekdump += FIELD_SIZE;
    #####:  536:				fsize -= FIELD_SIZE;
    #####:  537:				--item_index;
    #####:  538:				continue;
        -:  539:			}
       44:  540:			else if ( iret == 0 )
    #####:  541:				break;
        -:  542:
       44:  543:			pItem = ALC( HASH_ITEM, 1 );
       44:  544:			memcpy( pItem, &item, sizeof( HASH_ITEM ) );
       44:  545:			pItem->next = pPool;
       44:  546:			pPool = pItem;
        -:  547:
       44:  548:			if ( oldest > pItem->data.recentTime ) {
       44:  549:				oldest = pItem->data.recentTime;
        -:  550:			}
        -:  551:
       44:  552:			seekdump += FIELD_SIZE;
       44:  553:			fsize -= FIELD_SIZE;
        -:  554:		}
       24:  555:		free( dump );
        -:  556:
       68:  557:		while ( pPool ) {
       44:  558:			pItem = pPool;
       44:  559:			pPool = pItem->next;
        -:  560:
       44:  561:			hashvalue = HashFunc( pItem->data.phoneSeq );
       44:  562:			pItem->next = pgdata->static_data.hashtable[ hashvalue ];
       44:  563:			pgdata->static_data.hashtable[ hashvalue ] = pItem;
       44:  564:			pItem->data.recentTime -= oldest;
        -:  565:		}
       24:  566:		pgdata->static_data.chewing_lifetime -= oldest;
        -:  567:	}
       27:  568:	return 1;
        -:  569:}
        -:  570:
