        -:    0:Source:/home/workspace/src/chewingio.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/chewingio.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/chewingio.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * chewingio.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *	Lu-chuan Kung and Kang-pen Chen.
        -:    6: *	All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004-2008, 2010, 2011, 2012
        -:    9: *	libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: * @file chewingio.c
        -:   17: * @brief Implement basic I/O routines for Chewing manipulation.
        -:   18: */
        -:   19:
        -:   20:#include <assert.h>
        -:   21:#include <string.h>
        -:   22:#include <ctype.h>
        -:   23:#include <stdlib.h>
        -:   24:#include <stdio.h>
        -:   25:
        -:   26:#include "chewing-utf8-util.h"
        -:   27:#include "global.h"
        -:   28:#include "zuin-private.h"
        -:   29:#include "chewingutil.h"
        -:   30:#include "userphrase-private.h"
        -:   31:#include "choice-private.h"
        -:   32:#include "dict-private.h"
        -:   33:#include "char-private.h"
        -:   34:#include "hash-private.h"
        -:   35:#include "tree-private.h"
        -:   36:#include "pinyin-private.h"
        -:   37:#include "private.h"
        -:   38:#include "chewingio.h"
        -:   39:#include "mod_aux.h"
        -:   40:#include "global-private.h"
        -:   41:#include "plat_path.h"
        -:   42:#include "chewing-private.h"
        -:   43:
        -:   44:const char * const kb_type_str[] = {
        -:   45:	"KB_DEFAULT",
        -:   46:	"KB_HSU",
        -:   47:	"KB_IBM",
        -:   48:	"KB_GIN_YIEH",
        -:   49:	"KB_ET",
        -:   50:	"KB_ET26",
        -:   51:	"KB_DVORAK",
        -:   52:	"KB_DVORAK_HSU",
        -:   53:	"KB_DACHEN_CP26",
        -:   54:	"KB_HANYU_PINYIN",
        -:   55:	"KB_THL_PINYIN",
        -:   56:	"KB_MPS2_PINYIN"
        -:   57:};
        -:   58:
        -:   59:const char * const CHAR_FILES[] = {
        -:   60:	CHAR_FILE,
        -:   61:#ifdef USE_BINARY_DATA
        -:   62:	CHAR_INDEX_BEGIN_FILE,
        -:   63:	CHAR_INDEX_PHONE_FILE,
        -:   64:#else
        -:   65:	CHAR_INDEX_FILE,
        -:   66:#endif
        -:   67:	NULL,
        -:   68:};
        -:   69:
        -:   70:const char * const DICT_FILES[] = {
        -:   71:	DICT_FILE,
        -:   72:	PH_INDEX_FILE,
        -:   73:	PHONE_TREE_FILE,
        -:   74:	NULL,
        -:   75:};
        -:   76:
        -:   77:const char * const SYMBOL_TABLE_FILES[] = {
        -:   78:	SYMBOL_TABLE_FILE,
        -:   79:	NULL,
        -:   80:};
        -:   81:
        -:   82:const char * const EASY_SYMBOL_FILES[] = {
        -:   83:	SOFTKBD_TABLE_FILE,
        -:   84:	NULL,
        -:   85:};
        -:   86:
        -:   87:const char * const PINYIN_FILES[] = {
        -:   88:	PINYIN_TAB_NAME,
        -:   89:	NULL,
        -:   90:};
        -:   91:
    #####:   92:CHEWING_API int chewing_KBStr2Num( char str[] )
        -:   93:{
        -:   94:	int i;
        -:   95:
        -:   96:	STATIC_ASSERT( KB_TYPE_NUM == ARRAY_SIZE( kb_type_str ), kb_type_str_needs_update);
    #####:   97:	for ( i = 0; i < KB_TYPE_NUM; i++) {
    #####:   98:		if ( ! strcmp( str, kb_type_str[ i ] ) )
    #####:   99:			return i;
        -:  100:	}
    #####:  101:	return KB_DEFAULT;
        -:  102:}
        -:  103:
       12:  104:static void chooseCandidate( ChewingContext *ctx, int toSelect, int key_buf_cursor )
        -:  105:{
       12:  106:	ChewingData *pgdata = ctx->data;
       12:  107:	if ( toSelect ) {
       11:  108:		if ( ! pgdata->bSelect ) {
        5:  109:			ChoiceFirstAvail( pgdata );
        -:  110:		} else {
        6:  111:			if ( pgdata->config.bPhraseChoiceRearward ) {
        6:  112:				int avail_willbe = (pgdata->availInfo.currentAvail > 0) ?
        3:  113:					pgdata->availInfo.currentAvail - 1 :
        1:  114:					pgdata->availInfo.nAvail - 1;
        3:  115:				pgdata->chiSymbolCursor = pgdata->choiceInfo.oldChiSymbolCursor -
        3:  116:					pgdata->availInfo.avail[ avail_willbe ].len;
        3:  117:				if ( chewing_buffer_Len( ctx ) >
        3:  118:						pgdata->choiceInfo.oldChiSymbolCursor ) {
    #####:  119:					pgdata->chiSymbolCursor++;
        -:  120:				}
        -:  121:			}
        6:  122:			ChoiceNextAvail( pgdata );
        -:  123:		}
        1:  124:	} else if ( pgdata->symbolKeyBuf[ key_buf_cursor ] ) {
        -:  125:		/* Open Symbol Choice List */
    #####:  126:		if ( pgdata->choiceInfo.isSymbol == WORD_CHOICE )
    #####:  127:			OpenSymbolChoice( pgdata );
        -:  128:	}
       12:  129:}
        -:  130:
   448011:  131:static void NullLogger( void *data UNUSED, int level UNUSED, const char *fmt UNUSED, ...)
        -:  132:{
   448011:  133:}
        -:  134:
       27:  135:static ChewingData * allocate_ChewingData()
        -:  136:{
        -:  137:	static const int DEFAULT_SELKEY[] = { '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' };
        -:  138:
       27:  139:	ChewingData *data = ALC( ChewingData, 1 );
       27:  140:	if ( data ) {
       27:  141:		data->config.candPerPage = MAX_SELKEY;
       27:  142:		data->config.maxChiSymbolLen = MAX_CHI_SYMBOL_LEN;
       27:  143:		data->logger = NullLogger;
       27:  144:		memcpy( data->config.selKey, DEFAULT_SELKEY, sizeof( data->config.selKey ) );
        -:  145:	}
        -:  146:
       27:  147:	return data;
        -:  148:}
        -:  149:
       27:  150:CHEWING_API ChewingContext *chewing_new()
        -:  151:{
        -:  152:	ChewingContext *ctx;
        -:  153:	int ret;
        -:  154:	char search_path[PATH_MAX];
        -:  155:	char path[PATH_MAX];
        -:  156:
       27:  157:	ctx = ALC( ChewingContext, 1 );
       27:  158:	if ( !ctx )
    #####:  159:		goto error;
        -:  160:
       27:  161:	ctx->output = ALC ( ChewingOutput, 1 );
       27:  162:	if ( !ctx->output )
    #####:  163:		goto error;
        -:  164:
       27:  165:	ctx->data = allocate_ChewingData();
       27:  166:	if ( !ctx->data )
    #####:  167:		goto error;
        -:  168:
       27:  169:	chewing_Reset( ctx );
        -:  170:
       27:  171:	ret = get_search_path( search_path, sizeof( search_path ) );
       27:  172:	if ( ret )
    #####:  173:		goto error;
        -:  174:
       27:  175:	ret = find_path_by_files(
        -:  176:		search_path, CHAR_FILES, path, sizeof( path ) );
       27:  177:	if ( ret )
    #####:  178:		goto error;
       27:  179:	ret = InitChar( ctx->data, path );
       27:  180:	if ( ret )
    #####:  181:		goto error;
        -:  182:
       27:  183:	ret = find_path_by_files(
        -:  184:		search_path, DICT_FILES, path, sizeof( path ) );
       27:  185:	if ( ret )
    #####:  186:		goto error;
       27:  187:	ret = InitDict( ctx->data, path );
       27:  188:	if ( ret )
    #####:  189:		goto error;
       27:  190:	ret = InitTree( ctx->data, path );
       27:  191:	if ( ret )
    #####:  192:		goto error;
        -:  193:
       27:  194:	ret = InitHash( ctx->data );
       27:  195:	if ( !ret )
    #####:  196:		goto error;
        -:  197:
       27:  198:	ctx->cand_no = 0;
        -:  199:
       27:  200:	ret = find_path_by_files(
        -:  201:		search_path, SYMBOL_TABLE_FILES, path, sizeof( path ) );
       27:  202:	if ( ret )
    #####:  203:		goto error;
       27:  204:	ret = InitSymbolTable( ctx->data, path );
       27:  205:	if ( ret )
    #####:  206:		goto error;
        -:  207:
       27:  208:	ret = find_path_by_files(
        -:  209:		search_path, EASY_SYMBOL_FILES, path, sizeof( path ) );
       27:  210:	if ( ret )
    #####:  211:		goto error;
       27:  212:	ret = InitEasySymbolInput( ctx->data, path );
       27:  213:	if ( ret )
    #####:  214:		goto error;
        -:  215:
       27:  216:	ret = find_path_by_files(
        -:  217:		search_path, PINYIN_FILES, path, sizeof( path ) );
       27:  218:	if ( ret )
    #####:  219:		goto error;
       27:  220:	ret = InitPinyin( ctx->data, path );
       27:  221:	if ( !ret )
    #####:  222:		goto error;
        -:  223:
       27:  224:	return ctx;
    #####:  225:error:
    #####:  226:	chewing_delete( ctx );
    #####:  227:	return NULL;
        -:  228:}
        -:  229:
    #####:  230:CHEWING_API int chewing_Init(
        -:  231:		const char *dataPath UNUSED,
        -:  232:		const char *hashPath UNUSED)
        -:  233:{
    #####:  234:	return 0;
        -:  235:}
        -:  236:
       30:  237:CHEWING_API int chewing_Reset( ChewingContext *ctx )
        -:  238:{
       30:  239:	ChewingData *pgdata = ctx->data;
        -:  240:	ChewingStaticData static_data;
        -:  241:	ChewingConfigData old_config;
        -:  242:	void (*logger)( void *data, int level, const char *fmt, ...);
        -:  243:
        -:  244:	/* Backup old config and restore it after clearing pgdata structure. */
       30:  245:	old_config = pgdata->config;
       30:  246:	static_data = pgdata->static_data;
       30:  247:	logger = pgdata->logger;
       30:  248:	memset( pgdata, 0, sizeof( ChewingData ) );
       30:  249:	pgdata->config = old_config;
       30:  250:	pgdata->static_data = static_data;
       30:  251:	pgdata->logger = logger;
        -:  252:
        -:  253:	/* zuinData */
       30:  254:	memset( &( pgdata->zuinData ), 0, sizeof( ZuinData ) );
        -:  255:
        -:  256:	/* choiceInfo */
       30:  257:	memset( &( pgdata->choiceInfo ), 0, sizeof( ChoiceInfo ) );
        -:  258:
       30:  259:	pgdata->chiSymbolCursor = 0;
       30:  260:	pgdata->chiSymbolBufLen = 0;
       30:  261:	pgdata->nPhoneSeq = 0;
       30:  262:	memset( pgdata->bUserArrCnnct, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );
       30:  263:	memset( pgdata->bUserArrBrkpt, 0, sizeof( int ) * ( MAX_PHONE_SEQ_LEN + 1 ) );
       30:  264:	pgdata->bChiSym = CHINESE_MODE;
       30:  265:	pgdata->bFullShape = HALFSHAPE_MODE;
       30:  266:	pgdata->bSelect = 0;
       30:  267:	pgdata->nSelect = 0;
       30:  268:	pgdata->PointStart = -1;
       30:  269:	pgdata->PointEnd = 0;
       30:  270:	pgdata->phrOut.nNumCut = 0;
       30:  271:	return 0;
        -:  272:}
        -:  273:
    #####:  274:CHEWING_API int chewing_set_KBType( ChewingContext *ctx, int kbtype )
        -:  275:{
    #####:  276:	if ( kbtype < KB_TYPE_NUM && kbtype >= 0  ) {
    #####:  277:		ctx->data->zuinData.kbtype = kbtype;
    #####:  278:		return 0;
        -:  279:	} else {
    #####:  280:		ctx->data->zuinData.kbtype = KB_DEFAULT;
    #####:  281:		return -1;
        -:  282:	}
        -:  283:}
        -:  284:
    #####:  285:CHEWING_API int chewing_get_KBType( ChewingContext *ctx )
        -:  286:{
    #####:  287:	return ctx->data->zuinData.kbtype;
        -:  288:}
        -:  289:
    #####:  290:CHEWING_API char* chewing_get_KBString( ChewingContext *ctx )
        -:  291:{
    #####:  292:	return strdup( kb_type_str[ ctx->data->zuinData.kbtype ] );
        -:  293:}
        -:  294:
    #####:  295:CHEWING_API void chewing_Terminate()
        -:  296:{
    #####:  297:}
        -:  298:
       27:  299:CHEWING_API void chewing_delete( ChewingContext *ctx )
        -:  300:{
       27:  301:	if ( ctx ) {
       27:  302:		if ( ctx->data ) {
       27:  303:			TerminatePinyin( ctx->data );
       27:  304:			TerminateEasySymbolTable( ctx->data );
       27:  305:			TerminateSymbolTable( ctx->data );
       27:  306:			TerminateHash( ctx->data );
       27:  307:			TerminateTree( ctx->data );
       27:  308:			TerminateDict( ctx->data );
       27:  309:			TerminateChar( ctx->data );
       27:  310:			free( ctx->data );
        -:  311:		}
        -:  312:
       27:  313:		if ( ctx->output )
       27:  314:			free( ctx->output);
       27:  315:		free( ctx );
        -:  316:	}
       27:  317:	return;
        -:  318:}
        -:  319:
       47:  320:CHEWING_API void chewing_free( void *p )
        -:  321:{
       47:  322:	if ( p )
       47:  323:		free( p );
       47:  324:	return;
        -:  325:}
        -:  326:
    #####:  327:CHEWING_API int chewing_Configure( ChewingContext *ctx, ChewingConfigData *pcd )
        -:  328:{
    #####:  329:	chewing_set_candPerPage( ctx, pcd->candPerPage );
    #####:  330:	chewing_set_maxChiSymbolLen( ctx, pcd->maxChiSymbolLen );
    #####:  331:	chewing_set_selKey( ctx, pcd->selKey, MAX_SELKEY );
    #####:  332:	chewing_set_addPhraseDirection( ctx, pcd->bAddPhraseForward );
    #####:  333:	chewing_set_spaceAsSelection( ctx, pcd->bSpaceAsSelection );
    #####:  334:	chewing_set_escCleanAllBuf( ctx, pcd->bEscCleanAllBuf );
    #####:  335:	chewing_set_autoShiftCur( ctx, pcd->bAutoShiftCur );
    #####:  336:	chewing_set_easySymbolInput( ctx, pcd->bEasySymbolInput );
    #####:  337:	chewing_set_phraseChoiceRearward( ctx, pcd->bPhraseChoiceRearward );
        -:  338:
    #####:  339:	return 0;
        -:  340:}
        -:  341:
    #####:  342:CHEWING_API void chewing_set_candPerPage( ChewingContext *ctx, int n )
        -:  343:{
    #####:  344:	if ( MIN_SELKEY <= n && n <= MAX_SELKEY )
    #####:  345:		ctx->data->config.candPerPage = n;
    #####:  346:}
        -:  347:
    #####:  348:CHEWING_API int chewing_get_candPerPage( ChewingContext *ctx )
        -:  349:{
    #####:  350:	return ctx->data->config.candPerPage;
        -:  351:}
        -:  352:
       15:  353:CHEWING_API void chewing_set_maxChiSymbolLen( ChewingContext *ctx, int n )
        -:  354:{
       15:  355:	if ( MIN_CHI_SYMBOL_LEN <= n && n <= MAX_CHI_SYMBOL_LEN )
       15:  356:		ctx->data->config.maxChiSymbolLen = n;
       15:  357:}
        -:  358:
    #####:  359:CHEWING_API int chewing_get_maxChiSymbolLen( ChewingContext *ctx )
        -:  360:{
    #####:  361:	return ctx->data->config.maxChiSymbolLen;
        -:  362:}
        -:  363:
    #####:  364:CHEWING_API void chewing_set_selKey( ChewingContext *ctx, int *selkeys,
        -:  365:                                     int len UNUSED)
        -:  366:{
    #####:  367:	memcpy(
    #####:  368:		ctx->data->config.selKey,
        -:  369:		selkeys,
        -:  370:		sizeof( selkeys[ 0 ] ) * MAX_SELKEY );
    #####:  371:}
        -:  372:
    #####:  373:CHEWING_API int* chewing_get_selKey( ChewingContext *ctx )
        -:  374:{
    #####:  375:	int *selkeys = ALC( int , MAX_SELKEY );
    #####:  376:	if ( selkeys ) {
    #####:  377:		memcpy( selkeys, ctx->data->config.selKey,
        -:  378:			sizeof( *selkeys ) * MAX_SELKEY );
        -:  379:	}
    #####:  380:	return selkeys;
        -:  381:}
        -:  382:
    #####:  383:CHEWING_API void chewing_set_addPhraseDirection( ChewingContext *ctx, int direction )
        -:  384:{
    #####:  385:	if ( direction == 0 || direction == 1 )
    #####:  386:		ctx->data->config.bAddPhraseForward = direction;
    #####:  387:}
        -:  388:
    #####:  389:CHEWING_API int chewing_get_addPhraseDirection( ChewingContext *ctx )
        -:  390:{
    #####:  391:	return ctx->data->config.bAddPhraseForward;
        -:  392:}
        -:  393:
    #####:  394:CHEWING_API void chewing_set_spaceAsSelection( ChewingContext *ctx, int mode )
        -:  395:{
    #####:  396:	if ( mode == 0 || mode == 1 )
    #####:  397:		ctx->data->config.bSpaceAsSelection = mode;
    #####:  398:}
        -:  399:
    #####:  400:CHEWING_API int chewing_get_spaceAsSelection( ChewingContext *ctx )
        -:  401:{
    #####:  402:	return ctx->data->config.bSpaceAsSelection;
        -:  403:}
        -:  404:
    #####:  405:CHEWING_API void chewing_set_escCleanAllBuf( ChewingContext *ctx, int mode )
        -:  406:{
    #####:  407:	if ( mode == 0 || mode == 1 )
    #####:  408:		ctx->data->config.bEscCleanAllBuf = mode;
    #####:  409:}
        -:  410:
    #####:  411:CHEWING_API int chewing_get_escCleanAllBuf( ChewingContext *ctx )
        -:  412:{
    #####:  413:	return ctx->data->config.bEscCleanAllBuf;
        -:  414:}
        -:  415:
    #####:  416:CHEWING_API void chewing_set_hsuSelKeyType( ChewingContext *ctx, int mode )
        -:  417:{
        -:  418:	// XXX: This function is deprecated. No one read hsuSelKeyType.
    #####:  419:	ctx->data->config.hsuSelKeyType = mode;
    #####:  420:}
        -:  421:
    #####:  422:CHEWING_API int chewing_get_hsuSelKeyType( ChewingContext *ctx )
        -:  423:{
        -:  424:	// XXX: This function is deprecated. No one read hsuSelKeyType.
    #####:  425:	return ctx->data->config.hsuSelKeyType;
        -:  426:}
        -:  427:
        1:  428:CHEWING_API void chewing_set_autoShiftCur( ChewingContext *ctx, int mode )
        -:  429:{
        1:  430:	if ( mode == 0 || mode == 1 )
        1:  431:		ctx->data->config.bAutoShiftCur = mode;
        1:  432:}
        -:  433:
    #####:  434:CHEWING_API int chewing_get_autoShiftCur( ChewingContext *ctx )
        -:  435:{
    #####:  436:	return ctx->data->config.bAutoShiftCur;
        -:  437:}
        -:  438:
    #####:  439:CHEWING_API void chewing_set_easySymbolInput( ChewingContext *ctx, int mode )
        -:  440:{
    #####:  441:	if ( mode == 0 || mode == 1 )
    #####:  442:		ctx->data->config.bEasySymbolInput = mode;
    #####:  443:}
        -:  444:
    #####:  445:CHEWING_API int chewing_get_easySymbolInput( ChewingContext *ctx )
        -:  446:{
    #####:  447:	return ctx->data->config.bEasySymbolInput;
        -:  448:}
        -:  449:
        2:  450:CHEWING_API void chewing_set_phraseChoiceRearward( ChewingContext *ctx, int mode )
        -:  451:{
        2:  452:	if ( mode == 0 || mode == 1 )
        2:  453:		ctx->data->config.bPhraseChoiceRearward = mode;
        2:  454:}
        -:  455:
    #####:  456:CHEWING_API int chewing_get_phraseChoiceRearward( ChewingContext *ctx )
        -:  457:{
    #####:  458:	return ctx->data->config.bPhraseChoiceRearward;
        -:  459:}
        -:  460:
    #####:  461:CHEWING_API void chewing_set_ChiEngMode( ChewingContext *ctx, int mode )
        -:  462:{
    #####:  463:	if ( mode == CHINESE_MODE || mode == SYMBOL_MODE )
    #####:  464:		ctx->data->bChiSym = mode;
    #####:  465:}
        -:  466:
        1:  467:CHEWING_API int chewing_get_ChiEngMode( ChewingContext *ctx )
        -:  468:{
        1:  469:	return ctx->data->bChiSym;
        -:  470:}
        -:  471:
    #####:  472:CHEWING_API void chewing_set_ShapeMode( ChewingContext *ctx, int mode )
        -:  473:{
    #####:  474:	if ( mode == HALFSHAPE_MODE || mode == FULLSHAPE_MODE )
    #####:  475:		ctx->data->bFullShape = mode;
    #####:  476:}
        -:  477:
    #####:  478:CHEWING_API int chewing_get_ShapeMode( ChewingContext *ctx )
        -:  479:{
    #####:  480:	return ctx->data->bFullShape;
        -:  481:}
        -:  482:
      164:  483:static void CheckAndResetRange( ChewingData *pgdata )
        -:  484:{
      164:  485:	if ( pgdata->PointStart > -1 ) {
    #####:  486:		pgdata->PointStart = -1;
    #####:  487:		pgdata->PointEnd = 0;
        -:  488:	}
      164:  489:}
        -:  490:
       12:  491:static int DoSelect( ChewingData *pgdata, int num )
        -:  492:{
      12*:  493:	assert( pgdata->choiceInfo.pageNo >= 0 );
       12:  494:	if ( num >= 0 ) {
       12:  495:		num += pgdata->choiceInfo.pageNo * pgdata->choiceInfo.nChoicePerPage;
        -:  496:		/* Note: if num is larger than the total, there will be big troubles. */
       12:  497:		if ( num < pgdata->choiceInfo.nTotalChoice ) {
       12:  498:			if ( pgdata->choiceInfo.isSymbol != WORD_CHOICE ) {
        7:  499:				SymbolChoice( pgdata, num );
        -:  500:			}
        -:  501:			else {
        -:  502:				/* change the select interval & selectStr & nSelect */
        5:  503:				AddSelect( pgdata, num );
        -:  504:				/* second, call choice module */
        5:  505:				ChoiceSelect( pgdata, num );
        -:  506:				/* automatically shift the cursor to next phrase */
        5:  507:				if ( pgdata->config.bAutoShiftCur != 0 &&
        -:  508:				     /* if cursor at end of string, do not shift the cursor. */
        2:  509:				     pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {
        2:  510:					if ( pgdata->config.bPhraseChoiceRearward ) {
        2:  511:						++pgdata->chiSymbolCursor;
        -:  512:					} else {
    #####:  513:						pgdata->chiSymbolCursor +=
    #####:  514:							pgdata->availInfo.avail[ pgdata->availInfo.currentAvail ].len;
        -:  515:					}
        -:  516:				}
        -:  517:			}
       12:  518:			return 1;
        -:  519:		}
        -:  520:	}
    #####:  521:	return 0;
        -:  522:}
        -:  523:
        6:  524:CHEWING_API int chewing_handle_Space( ChewingContext *ctx )
        -:  525:{
        6:  526:	ChewingData *pgdata = ctx->data;
        -:  527:
        -:  528:	/*
        -:  529:	 * Use chewing_handle_Default( ctx, ' ' ) to handle space when:
        -:  530:	 * - "space as selection" mode is disable
        -:  531:	 * - mode is not CHINESE_MODE
        -:  532:	 * - has incompleted bopomofo (space is needed to complete it)
        -:  533:	 */
        6:  534:	if ( !pgdata->config.bSpaceAsSelection
    #####:  535:	     || pgdata->bChiSym != CHINESE_MODE
    #####:  536:	     || ZuinIsEntering( &ctx->data->zuinData ) ) {
        6:  537:		return chewing_handle_Default( ctx, ' ' );
        -:  538:	}
        -:  539:
    #####:  540:	CheckAndResetRange( pgdata );
        -:  541:
    #####:  542:	if ( pgdata->bSelect ) {
    #####:  543:		return chewing_handle_Right( ctx );
        -:  544:	} else {
    #####:  545:		return chewing_handle_Down( ctx );
        -:  546:	}
        -:  547:	return 0;
        -:  548:}
        -:  549:
        4:  550:CHEWING_API int chewing_handle_Esc( ChewingContext *ctx )
        -:  551:{
        4:  552:	ChewingData *pgdata = ctx->data;
        4:  553:	ChewingOutput *pgo = ctx->output;
        4:  554:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  555:
        4:  556:	CheckAndResetRange( pgdata );
        -:  557:
        4:  558:	if ( ! ChewingIsEntering( pgdata ) ) {
        2:  559:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  560:	}
        2:  561:	else if ( pgdata->bSelect ) {
        1:  562:		ChoiceEndChoice( pgdata );
        -:  563:	}
        1:  564:	else if ( ZuinIsEntering( &( pgdata->zuinData ) ) ) {
        1:  565:		ZuinRemoveAll( &( pgdata->zuinData ) );
        -:  566:	}
    #####:  567:	else if ( pgdata->config.bEscCleanAllBuf ) {
    #####:  568:		CleanAllBuf( pgdata );
    #####:  569:		pgo->nCommitStr = pgdata->chiSymbolBufLen;
        -:  570:	}
        -:  571:
        4:  572:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        4:  573:	return 0;
        -:  574:}
        -:  575:
        6:  576:CHEWING_API int chewing_handle_Enter( ChewingContext *ctx )
        -:  577:{
        6:  578:	ChewingData *pgdata = ctx->data;
        6:  579:	ChewingOutput *pgo = ctx->output;
        6:  580:	int nCommitStr = pgdata->chiSymbolBufLen;
        6:  581:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  582:
        6:  583:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  584:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  585:	}
        6:  586:	else if ( pgdata->bSelect ) {
    #####:  587:		keystrokeRtn = KEYSTROKE_ABSORB | KEYSTROKE_BELL;
        -:  588:	}
        6:  589:	else if ( pgdata->PointStart > -1 ) {
    #####:  590:		int buf = pgdata->chiSymbolCursor;
        -:  591:		int key;
    #####:  592:		if ( pgdata->PointEnd > 1 ) {
    #####:  593:			if ( ! pgdata->config.bAddPhraseForward ) {
    #####:  594:				pgdata->chiSymbolCursor = pgdata->PointStart;
    #####:  595:				key = '0' + pgdata->PointEnd;
        -:  596:			}
        -:  597:			else {
    #####:  598:				pgdata->chiSymbolCursor = pgdata->PointStart + pgdata->PointEnd;
    #####:  599:				key = '0' + pgdata->PointEnd;
        -:  600:			}
        -:  601:
    #####:  602:			chewing_handle_CtrlNum( ctx, key );
    #####:  603:			pgdata->chiSymbolCursor = buf;
        -:  604:		}
    #####:  605:		else if ( pgdata->PointEnd < 1 ) {
    #####:  606:			if ( pgdata->config.bAddPhraseForward )
    #####:  607:				pgdata->chiSymbolCursor = buf - pgdata->PointEnd;
    #####:  608:			key = '0' - pgdata->PointEnd;
    #####:  609:			chewing_handle_CtrlNum( ctx, key );
    #####:  610:			pgdata->chiSymbolCursor = buf;
        -:  611:		}
    #####:  612:		pgdata->PointStart = -1;
    #####:  613:		pgdata->PointEnd = 0;
        -:  614:	}
        -:  615:	else {
        6:  616:		keystrokeRtn = KEYSTROKE_COMMIT;
        6:  617:		WriteChiSymbolToBuf( pgo->commitStr, nCommitStr, pgdata );
        6:  618:		AutoLearnPhrase( pgdata );
        6:  619:		CleanAllBuf( pgdata );
        6:  620:		pgo->nCommitStr = nCommitStr;
        -:  621:	}
        -:  622:
        6:  623:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        6:  624:	return 0;
        -:  625:}
        -:  626:
        3:  627:CHEWING_API int chewing_handle_Del( ChewingContext *ctx )
        -:  628:{
        3:  629:	ChewingData *pgdata = ctx->data;
        3:  630:	ChewingOutput *pgo = ctx->output;
        3:  631:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  632:
        3:  633:	CheckAndResetRange( pgdata );
        -:  634:
        3:  635:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  636:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  637:	}
        -:  638:
        3:  639:	if ( ! pgdata->bSelect ) {
        2:  640:		if (
        2:  641:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
        2:  642:			pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {
        1:  643:			ChewingKillChar(
        -:  644:				pgdata,
        -:  645:				pgdata->chiSymbolCursor,
        -:  646:				NONDECREASE_CURSOR );
        -:  647:		}
        2:  648:		CallPhrasing( pgdata );
        -:  649:	}
        3:  650:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        3:  651:	return 0;
        -:  652:}
        -:  653:
        4:  654:CHEWING_API int chewing_handle_Backspace( ChewingContext *ctx )
        -:  655:{
        4:  656:	ChewingData *pgdata = ctx->data;
        4:  657:	ChewingOutput *pgo = ctx->output;
        4:  658:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  659:
        4:  660:	CheckAndResetRange( pgdata );
        -:  661:
        4:  662:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  663:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  664:	}
        -:  665:
        4:  666:	if ( ! pgdata->bSelect ) {
        3:  667:		if ( ZuinIsEntering( &( pgdata->zuinData ) ) ) {
        1:  668:			ZuinRemoveLast( &( pgdata->zuinData ) );
        -:  669:		}
        2:  670:		else if ( pgdata->chiSymbolCursor > 0 ) {
        1:  671:			ChewingKillChar(
        -:  672:				pgdata,
        1:  673:				pgdata->chiSymbolCursor - 1,
        -:  674:				DECREASE_CURSOR );
        -:  675:		}
        3:  676:		CallPhrasing( pgdata );
        -:  677:	}
        4:  678:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        -:  679:
        4:  680:	return 0;
        -:  681:}
        -:  682:
        1:  683:CHEWING_API int chewing_handle_Up( ChewingContext *ctx )
        -:  684:{
        1:  685:	ChewingData *pgdata = ctx->data;
        1:  686:	ChewingOutput *pgo = ctx->output;
        1:  687:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  688:	int key_buf_cursor;
        -:  689:
        1:  690:	CheckAndResetRange( pgdata );
        -:  691:
        1:  692:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  693:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  694:	}
        -:  695:
        1:  696:	key_buf_cursor = pgdata->chiSymbolCursor;
        -:  697:	// FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.
        1:  698:	if ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )
        1:  699:		key_buf_cursor--;
        -:  700:
        -:  701:	// XXX: Why close symbol choice list, but not word choice list.
        1:  702:	if ( ! pgdata->symbolKeyBuf[ key_buf_cursor ] ) {
        -:  703:		/* Close Symbol Choice List */
        1:  704:		chewing_handle_Esc(ctx);
        -:  705:	}
        -:  706:
        1:  707:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        1:  708:	return 0;
        -:  709:}
        -:  710:
       12:  711:CHEWING_API int chewing_handle_Down( ChewingContext *ctx )
        -:  712:{
       12:  713:	ChewingData *pgdata = ctx->data;
       12:  714:	ChewingOutput *pgo = ctx->output;
       12:  715:	int toSelect = 0;
       12:  716:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  717:	int key_buf_cursor;
        -:  718:
       12:  719:	CheckAndResetRange( pgdata );
        -:  720:
       12:  721:	if ( ! ChewingIsEntering( pgdata ) ) {
        1:  722:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  723:	}
        -:  724:
       12:  725:	key_buf_cursor = pgdata->chiSymbolCursor;
        -:  726:	// FIXME: when pgdata->chiSymbolBufLen == 0, key_buf_cursor will be -1.
       12:  727:	if ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen )
        3:  728:		key_buf_cursor--;
        -:  729:
        -:  730:	/* see if to select */
       12:  731:	if ( ChewingIsChiAt( key_buf_cursor, pgdata ) )
       11:  732:			toSelect = 1;
        -:  733:
       12:  734:	chooseCandidate( ctx, toSelect, key_buf_cursor );
        -:  735:
       12:  736:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       12:  737:	return 0;
        -:  738:}
        -:  739:
        -:  740:/* Add phrase in Hanin Style */
    #####:  741:CHEWING_API int chewing_handle_ShiftLeft( ChewingContext *ctx )
        -:  742:{
    #####:  743:	ChewingData *pgdata = ctx->data;
    #####:  744:	ChewingOutput *pgo = ctx->output;
    #####:  745:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  746:
    #####:  747:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  748:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  749:	}
    #####:  750:	if ( ! pgdata->bSelect ) {
        -:  751:		/*  PointEnd locates (-9, +9) */
    #####:  752:		if (
    #####:  753:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
    #####:  754:			pgdata->chiSymbolCursor > 0 &&
    #####:  755:			pgdata->PointEnd > -9 ) {
    #####:  756:			if ( pgdata->PointStart == -1 )
    #####:  757:				pgdata->PointStart = pgdata->chiSymbolCursor;
    #####:  758:			pgdata->chiSymbolCursor--;
    #####:  759:			if (
    #####:  760:				ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) ) {
    #####:  761:				pgdata->PointEnd--;
        -:  762:			}
    #####:  763:			if ( pgdata->PointEnd == 0 )
    #####:  764:				pgdata->PointStart = -1;
        -:  765:		}
        -:  766:	}
        -:  767:
    #####:  768:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####:  769:	return 0;
        -:  770:}
        -:  771:
       14:  772:CHEWING_API int chewing_handle_Left( ChewingContext *ctx )
        -:  773:{
       14:  774:	ChewingData *pgdata = ctx->data;
       14:  775:	ChewingOutput *pgo = ctx->output;
       14:  776:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  777:
       14:  778:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  779:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  780:	}
        -:  781:
       14:  782:	if ( pgdata->bSelect ) {
    #####:  783:		assert( pgdata->choiceInfo.nPage > 0 );
    #####:  784:		if ( pgdata->choiceInfo.pageNo > 0 )
    #####:  785:			pgdata->choiceInfo.pageNo--;
        -:  786:		else
    #####:  787:			pgdata->choiceInfo.pageNo = pgdata->choiceInfo.nPage - 1;
        -:  788:	}
        -:  789:	else {
       14:  790:		if (
       14:  791:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
       14:  792:			pgdata->chiSymbolCursor > 0 ) {
       14:  793:			CheckAndResetRange( pgdata );
       14:  794:			pgdata->chiSymbolCursor--;
        -:  795:		}
        -:  796:	}
       14:  797:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       14:  798:	return 0;
        -:  799:}
        -:  800:
        -:  801:/* Add phrase in Hanin Style */
    #####:  802:CHEWING_API int chewing_handle_ShiftRight( ChewingContext *ctx )
        -:  803:{
    #####:  804:	ChewingData *pgdata = ctx->data;
    #####:  805:	ChewingOutput *pgo = ctx->output;
    #####:  806:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  807:
    #####:  808:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  809:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  810:	}
        -:  811:
    #####:  812:	if ( ! pgdata->bSelect ) {
        -:  813:		/* PointEnd locates (-9, +9) */
    #####:  814:		if (
    #####:  815:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
    #####:  816:			pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen &&
    #####:  817:			pgdata->PointEnd < 9 ) {
    #####:  818:			if ( pgdata->PointStart == -1 )
    #####:  819:				pgdata->PointStart = pgdata->chiSymbolCursor;
    #####:  820:			if (
    #####:  821:				ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) ) {
    #####:  822:				pgdata->PointEnd++;
        -:  823:			}
    #####:  824:			pgdata->chiSymbolCursor++;
    #####:  825:			if ( pgdata->PointEnd == 0 )
    #####:  826:				pgdata->PointStart = -1;
        -:  827:		}
        -:  828:	}
        -:  829:
    #####:  830:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####:  831:	return 0;
        -:  832:}
        -:  833:
    #####:  834:CHEWING_API int chewing_handle_Right( ChewingContext *ctx )
        -:  835:{
    #####:  836:	ChewingData *pgdata = ctx->data;
    #####:  837:	ChewingOutput *pgo = ctx->output;
    #####:  838:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  839:
    #####:  840:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  841:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  842:	}
        -:  843:
    #####:  844:	if ( pgdata->bSelect ) {
    #####:  845:		if ( pgdata->choiceInfo.pageNo < pgdata->choiceInfo.nPage - 1)
    #####:  846:			pgdata->choiceInfo.pageNo++;
        -:  847:		else
    #####:  848:			pgdata->choiceInfo.pageNo = 0;
        -:  849:	}
        -:  850:	else {
    #####:  851:		if (
    #####:  852:			! ZuinIsEntering( &( pgdata->zuinData ) ) &&
    #####:  853:			pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {
    #####:  854:			CheckAndResetRange( pgdata );
    #####:  855:			pgdata->chiSymbolCursor++;
        -:  856:		}
        -:  857:	}
        -:  858:
    #####:  859:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####:  860:	return 0;
        -:  861:}
        -:  862:
        3:  863:CHEWING_API int chewing_handle_Tab( ChewingContext *ctx )
        -:  864:{
        -:  865:	int cursor;
        3:  866:	ChewingData *pgdata = ctx->data;
        3:  867:	ChewingOutput *pgo = ctx->output;
        3:  868:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  869:
        3:  870:	CheckAndResetRange( pgdata );
        -:  871:
        3:  872:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  873:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  874:	}
        -:  875:
        -:  876:
        3:  877:	if ( ! pgdata->bSelect ) {
        3:  878:		if ( pgdata->chiSymbolCursor == pgdata->chiSymbolBufLen ) {
        1:  879:			pgdata->phrOut.nNumCut++;
        -:  880:		}
        2:  881:		else if ( ChewingIsChiAt( pgdata->chiSymbolCursor - 1, pgdata ) ) {
        2:  882:			cursor = PhoneSeqCursor( pgdata );
        2:  883:			if ( IsPreferIntervalConnted( cursor, pgdata) ) {
        1:  884:				pgdata->bUserArrBrkpt[ cursor ] = 1;
        1:  885:				pgdata->bUserArrCnnct[ cursor ] = 0;
        -:  886:			}
        -:  887:			else {
        1:  888:				pgdata->bUserArrBrkpt[ cursor ] = 0;
        1:  889:				pgdata->bUserArrCnnct[ cursor ] = 1;
        -:  890:			}
        -:  891:		}
        3:  892:		CallPhrasing( pgdata );
        -:  893:	}
        3:  894:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        3:  895:	return 0;
        -:  896:}
        -:  897:
    #####:  898:CHEWING_API int chewing_handle_DblTab( ChewingContext *ctx )
        -:  899:{
        -:  900:	int cursor;
    #####:  901:	ChewingData *pgdata = ctx->data;
    #####:  902:	ChewingOutput *pgo = ctx->output;
    #####:  903:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  904:
    #####:  905:	CheckAndResetRange( pgdata );
        -:  906:
    #####:  907:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  908:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  909:	}
        -:  910:
    #####:  911:	if ( ! pgdata->bSelect ) {
    #####:  912:		cursor = PhoneSeqCursor( pgdata );
    #####:  913:		pgdata->bUserArrBrkpt[ cursor ] = 0;
    #####:  914:		pgdata->bUserArrCnnct[ cursor ] = 0;
        -:  915:	}
    #####:  916:	CallPhrasing( pgdata );
        -:  917:
    #####:  918:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####:  919:	return 0;
        -:  920:}
        -:  921:
        -:  922:
        1:  923:CHEWING_API int chewing_handle_Capslock( ChewingContext *ctx )
        -:  924:{
        1:  925:	ChewingData *pgdata = ctx->data;
        1:  926:	ChewingOutput *pgo = ctx->output;
        -:  927:
        1:  928:	pgdata->bChiSym = 1 - pgdata->bChiSym;
        1:  929:	MakeOutputWithRtn( pgo, pgdata, KEYSTROKE_ABSORB );
        1:  930:	return 0;
        -:  931:}
        -:  932:
        2:  933:CHEWING_API int chewing_handle_Home( ChewingContext *ctx )
        -:  934:{
        2:  935:	ChewingData *pgdata = ctx->data;
        2:  936:	ChewingOutput *pgo = ctx->output;
        2:  937:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  938:
        2:  939:	CheckAndResetRange( pgdata );
        -:  940:
        2:  941:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  942:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  943:	}
        2:  944:	else if ( ! pgdata->bSelect ) {
        2:  945:		pgdata->chiSymbolCursor = 0;
        -:  946:	}
        2:  947:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        2:  948:	return 0;
        -:  949:}
        -:  950:
        1:  951:CHEWING_API int chewing_handle_End( ChewingContext *ctx )
        -:  952:{
        1:  953:	ChewingData *pgdata = ctx->data;
        1:  954:	ChewingOutput *pgo = ctx->output;
        1:  955:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  956:
        1:  957:	CheckAndResetRange( pgdata );
        -:  958:
        1:  959:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  960:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  961:	}
        1:  962:	else if ( ! pgdata->bSelect ) {
        1:  963:		pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
        -:  964:	}
        1:  965:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        1:  966:	return 0;
        -:  967:}
        -:  968:
        1:  969:CHEWING_API int chewing_handle_PageUp( ChewingContext *ctx )
        -:  970:{
        1:  971:	ChewingData *pgdata = ctx->data;
        1:  972:	ChewingOutput *pgo = ctx->output;
        1:  973:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  974:
        1:  975:	CheckAndResetRange( pgdata );
        -:  976:
        1:  977:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  978:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  979:	}
        1:  980:	else if ( ! pgdata->bSelect ) {
        1:  981:		pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
        -:  982:	}
        1:  983:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        1:  984:	return 0;
        -:  985:}
        -:  986:
        1:  987:CHEWING_API int chewing_handle_PageDown( ChewingContext *ctx )
        -:  988:{
        1:  989:	ChewingData *pgdata = ctx->data;
        1:  990:	ChewingOutput *pgo = ctx->output;
        1:  991:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -:  992:
        1:  993:	CheckAndResetRange( pgdata );
        -:  994:
        1:  995:	if ( ! ChewingIsEntering( pgdata ) ) {
    #####:  996:		keystrokeRtn = KEYSTROKE_IGNORE;
        -:  997:	}
        1:  998:	else if ( ! pgdata->bSelect ) {
        1:  999:		pgdata->chiSymbolCursor = pgdata->chiSymbolBufLen;
        -: 1000:	}
        1: 1001:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
        1: 1002:	return 0;
        -: 1003:}
        -: 1004:
        -: 1005:/* Dvorak <-> Qwerty keyboard layout converter */
    #####: 1006:static int dvorak_convert( int key )
        -: 1007:{
    #####: 1008:	const char dkey[] = {
        -: 1009:		'\'','\"',',','<','.','>','p','P','y','Y','f','F','g','G',
        -: 1010:		'c','C','r','R','l','L','/','?','=','+','\\','|',
        -: 1011:		'a','A','o','O','e','E','u','U','i','I','d','D','h','H',
        -: 1012:		't','T','n','N','s','S','-','_',
        -: 1013:		';',':','q','Q','j','J','k','K','x','X','b','B','m','M',
        -: 1014:		'w','W','v','V','z','Z'};
    #####: 1015:	const char qkey[] = {
        -: 1016:		'q','Q','w','W','e','E','r','R','t','T','y','Y','u','U',
        -: 1017:		'i','I','o','O','p','P','[','{',']','}','\\','|',
        -: 1018:		'a','A','s','S','d','D','f','F','g','G','h','H','j','J',
        -: 1019:		'k','K','l','L',';',':','\'','\"',
        -: 1020:		'z','Z','x','X','c','C','v','V','b','B','n','N','m','M',
        -: 1021:		',','<','.','>','/','?'};
        -: 1022:	size_t i;
        -: 1023:
        -: 1024:	STATIC_ASSERT( ARRAY_SIZE( dkey ) == ARRAY_SIZE( qkey ), update_dkey_and_qkey );
        -: 1025:
    #####: 1026:	for ( i = 0; i < ARRAY_SIZE( dkey ); i++ ) {
    #####: 1027:		if ( key == qkey[ i ] ) {
    #####: 1028:			key = dkey[ i ];
    #####: 1029:			return key;
        -: 1030:		}
        -: 1031:	}
    #####: 1032:	return key;
        -: 1033:}
        -: 1034:
      118: 1035:CHEWING_API int chewing_handle_Default( ChewingContext *ctx, int key )
        -: 1036:{
      118: 1037:	ChewingData *pgdata = ctx->data;
      118: 1038:	ChewingOutput *pgo = ctx->output;
        -: 1039:	int rtn, num;
      118: 1040:	int keystrokeRtn = KEYSTROKE_ABSORB;
      118: 1041:	int bQuickCommit = 0;
        -: 1042:
        -: 1043:	/* Update lifetime */
      118: 1044:	ctx->data->static_data.chewing_lifetime++;
        -: 1045:
        -: 1046:	/* Skip the special key */
      118: 1047:	if ( key & 0xFF00 ) {
    #####: 1048:		keystrokeRtn = KEYSTROKE_IGNORE;
    #####: 1049:		goto End_KeyDefault;
        -: 1050:	}
        -: 1051:
        -: 1052:	/* We ignore non-printable input */
      118: 1053:	if ( ! isprint( key ) )
    #####: 1054:		goto End_KeyDefault;
        -: 1055:
      118: 1056:	CheckAndResetRange( pgdata );
        -: 1057:
      118: 1058:	DEBUG_CHECKPOINT();
      118: 1059:	DEBUG_OUT( "   key=%d", key );
        -: 1060:
        -: 1061:	/* Dvorak Hsu */
      118: 1062:	if ( pgdata->zuinData.kbtype == KB_DVORAK_HSU ) {
    #####: 1063:		key = dvorak_convert( key );
        -: 1064:	}
        -: 1065:
        -: 1066:	/* selecting */
      118: 1067:	if ( pgdata->bSelect ) {
       10: 1068:		if ( key == ' ' )
    #####: 1069:			return chewing_handle_Right( ctx );
        -: 1070:		/* num starts from 0 */
       10: 1071:		num = CountSelKeyNum( key, pgdata );
       10: 1072:		if ( num >= 0 ) {
       10: 1073:			DoSelect( pgdata, num );
       10: 1074:			goto End_keyproc;
        -: 1075:		}
        -: 1076:
        -: 1077:		/* Otherwise, use 'j' and 'k' for paging in selection mode */
    #####: 1078:		DEBUG_OUT(
        -: 1079:			"\t\tchecking paging key, got '%c'\n",
        -: 1080:			key );
    #####: 1081:		switch ( key ) {
    #####: 1082:			case 'j':
        -: 1083:			case 'J':
    #####: 1084:				if ( pgdata->chiSymbolCursor > 0 ) {
    #####: 1085:					if ( ! ChewingIsEntering( pgdata ) ) {
    #####: 1086:						keystrokeRtn = KEYSTROKE_IGNORE;
        -: 1087:					}
    #####: 1088:					CheckAndResetRange( pgdata );
    #####: 1089:					pgdata->chiSymbolCursor--;
    #####: 1090:					if ( ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) )
    #####: 1091:						ChoiceFirstAvail( pgdata );
        -: 1092:					else
    #####: 1093:						OpenSymbolChoice( pgdata );
        -: 1094:
        -: 1095:				}
    #####: 1096:				goto End_Paging;
    #####: 1097:			case 'k':
        -: 1098:			case 'K':
    #####: 1099:				if ( pgdata->chiSymbolCursor < pgdata->chiSymbolBufLen ) {
    #####: 1100:					if ( ! ChewingIsEntering( pgdata ) ) {
    #####: 1101:						keystrokeRtn = KEYSTROKE_IGNORE;
        -: 1102:					}
    #####: 1103:					CheckAndResetRange( pgdata );
    #####: 1104:					pgdata->chiSymbolCursor++;
    #####: 1105:					if ( ChewingIsChiAt( pgdata->chiSymbolCursor, pgdata ) )
    #####: 1106:						ChoiceFirstAvail( pgdata );
        -: 1107:					else
    #####: 1108:						OpenSymbolChoice( pgdata );
        -: 1109:				}
    #####: 1110:				goto End_Paging;
    #####: 1111:			default:
    #####: 1112:				break;
        -: 1113:		}
        -: 1114:	}
        -: 1115:	/* editing */
        -: 1116:	else {
      108: 1117:		if ( pgdata->bChiSym == CHINESE_MODE ) {
      108: 1118:			if ( pgdata->config.bEasySymbolInput != 0 ) {
    #####: 1119:				EasySymbolInput( key, pgdata );
    #####: 1120:				goto End_keyproc;
        -: 1121:			}
        -: 1122:
        -: 1123:			/* open symbol table */
      108: 1124:			if ( key == '`' ) {
        7: 1125:				pgdata->bSelect = 1;
        7: 1126:				pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
        -: 1127:
        7: 1128:				HaninSymbolInput( pgdata );
        7: 1129:				goto End_KeyDefault;
        -: 1130:			}
        -: 1131:
      101: 1132:			rtn = ZuinPhoInput( pgdata, key );
      101: 1133:			DEBUG_OUT(
        -: 1134:				"\t\tChinese mode key, "
        -: 1135:				"ZuinPhoInput return value = %d\n",
        -: 1136:				rtn );
        -: 1137:
      101: 1138:			if ( rtn == ZUIN_KEY_ERROR )
    #####: 1139:				rtn = SpecialSymbolInput( key, pgdata );
      101: 1140:			switch ( rtn ) {
       63: 1141:				case ZUIN_ABSORB:
       63: 1142:					keystrokeRtn = KEYSTROKE_ABSORB;
       63: 1143:					break;
       38: 1144:				case ZUIN_COMMIT:
       38: 1145:					AddChi( pgdata->zuinData.phone, pgdata->zuinData.phoneAlt, pgdata );
       38: 1146:					break;
    #####: 1147:				case ZUIN_NO_WORD:
    #####: 1148:					keystrokeRtn = KEYSTROKE_BELL | KEYSTROKE_ABSORB;
    #####: 1149:					break;
    #####: 1150:				case ZUIN_KEY_ERROR:
        -: 1151:				case ZUIN_IGNORE:
    #####: 1152:					DEBUG_OUT(
        -: 1153:						"\t\tbefore isupper(key),key=%d\n",
        -: 1154:						key );
        -: 1155:					/* change upper case into lower case */
    #####: 1156:					if ( isupper( key ) )
    #####: 1157:						key = tolower( key );
        -: 1158:
    #####: 1159:					DEBUG_OUT(
        -: 1160:						"\t\tafter isupper(key),key=%d\n",
        -: 1161:						key );
        -: 1162:
        -: 1163:					/* see if buffer contains nothing */
    #####: 1164:					if ( pgdata->chiSymbolBufLen == 0 ) {
    #####: 1165:						bQuickCommit = 1;
        -: 1166:					}
        -: 1167:
    #####: 1168:					if ( pgdata->config.bEasySymbolInput == 0 ) {
    #####: 1169:						if ( pgdata->bFullShape )
    #####: 1170:							rtn = FullShapeSymbolInput( key, pgdata );
        -: 1171:						else
    #####: 1172:							rtn = SymbolInput( key, pgdata );
        -: 1173:					}
        -: 1174:
    #####: 1175:					if ( rtn == SYMBOL_KEY_ERROR ) {
    #####: 1176:						keystrokeRtn = KEYSTROKE_IGNORE;
        -: 1177:						/*
        -: 1178:						 * If the key is not a printable symbol,
        -: 1179:						 * then it's wrong to commit it.
        -: 1180:						 */
    #####: 1181:						bQuickCommit = 0;
        -: 1182:					}
        -: 1183:					else
    #####: 1184:						keystrokeRtn = KEYSTROKE_ABSORB;
        -: 1185:
    #####: 1186:					break;
        -: 1187:
        -: 1188:			}
      101: 1189:		}
        -: 1190:		/* English mode */
        -: 1191:		else {
        -: 1192:			/* see if buffer contains nothing */
    #####: 1193:			if ( pgdata->chiSymbolBufLen == 0 ) {
    #####: 1194:				bQuickCommit = 1;
        -: 1195:			}
    #####: 1196:			if ( pgdata->bFullShape ) {
    #####: 1197:				rtn = FullShapeSymbolInput( key, pgdata );
        -: 1198:			}
        -: 1199:			else {
    #####: 1200:				rtn = SymbolInput( key, pgdata );
        -: 1201:			}
        -: 1202:
    #####: 1203:			if ( rtn == SYMBOL_KEY_ERROR ) {
    #####: 1204:				keystrokeRtn = KEYSTROKE_IGNORE;
    #####: 1205:				bQuickCommit = 0;
        -: 1206:			}
        -: 1207:		}
        -: 1208:	}
        -: 1209:
    #####: 1210:End_keyproc:
      111: 1211:	if ( ! bQuickCommit ) {
      111: 1212:		CallPhrasing( pgdata );
      111: 1213:		if ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )
    #####: 1214:			keystrokeRtn = KEYSTROKE_COMMIT;
        -: 1215:	}
        -: 1216:	/* Quick commit */
        -: 1217:	else {
    #####: 1218:		DEBUG_OUT(
        -: 1219:				"\t\tQuick commit buf[0]=%c\n",
        -: 1220:				pgdata->chiSymbolBuf[ 0 ].s[ 0 ] );
    #####: 1221:		pgo->commitStr[ 0 ] = pgdata->chiSymbolBuf[ 0 ];
    #####: 1222:		pgo->nCommitStr = 1;
    #####: 1223:		pgdata->chiSymbolBufLen = 0;
    #####: 1224:		pgdata->chiSymbolCursor = 0;
    #####: 1225:		keystrokeRtn = KEYSTROKE_COMMIT;
        -: 1226:	}
        -: 1227:
      111: 1228:	if ( pgdata->phrOut.nNumCut > 0 ) {
        -: 1229:		int i;
    #####: 1230:		for ( i = 0; i < pgdata->phrOut.nDispInterval; i++ ) {
    #####: 1231:			pgdata->bUserArrBrkpt[ pgdata->phrOut.dispInterval[ i ].from ] = 1;
    #####: 1232:			pgdata->bUserArrBrkpt[ pgdata->phrOut.dispInterval[ i ].to ] = 1;
        -: 1233:		}
    #####: 1234:		pgdata->phrOut.nNumCut = 0;
        -: 1235:	}
        -: 1236:
      111: 1237:End_KeyDefault:
      118: 1238:	CallPhrasing( pgdata );
      118: 1239:End_Paging:
      118: 1240:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
      118: 1241:	return 0;
        -: 1242:}
        -: 1243:
    #####: 1244:CHEWING_API int chewing_handle_CtrlNum( ChewingContext *ctx, int key )
        -: 1245:{
    #####: 1246:	ChewingData *pgdata = ctx->data;
    #####: 1247:	ChewingOutput *pgo = ctx->output;
    #####: 1248:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -: 1249:	int newPhraseLen;
        -: 1250:	int i;
        -: 1251:	uint16_t addPhoneSeq[ MAX_PHONE_SEQ_LEN ];
        -: 1252:	char addWordSeq[ MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1 ];
        -: 1253:	int phraseState;
        -: 1254:	int cursor;
        -: 1255:
    #####: 1256:	CheckAndResetRange( pgdata );
        -: 1257:
    #####: 1258:	if ( pgdata->bSelect )
    #####: 1259:		return 0;
        -: 1260:
    #####: 1261:	CallPhrasing( pgdata );
    #####: 1262:	newPhraseLen = key - '0';
        -: 1263:
    #####: 1264:	if ( key == '0' || key == '1' ) {
    #####: 1265:		pgdata->bSelect = 1;
    #####: 1266:		pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
        -: 1267:
    #####: 1268:		HaninSymbolInput( pgdata );
    #####: 1269:		CallPhrasing( pgdata );
    #####: 1270:		MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####: 1271:		return 0;
        -: 1272:	}
        -: 1273:
    #####: 1274:	cursor = PhoneSeqCursor( pgdata );
    #####: 1275:	if ( ! pgdata->config.bAddPhraseForward ) {
    #####: 1276:		if (
    #####: 1277:			newPhraseLen >= 1 &&
    #####: 1278:			cursor + newPhraseLen - 1 <= pgdata->nPhoneSeq ) {
    #####: 1279:			if ( NoSymbolBetween(
        -: 1280:				pgdata,
        -: 1281:				cursor,
        -: 1282:				cursor + newPhraseLen ) ) {
        -: 1283:				/* Manually add phrase to the user phrase database. */
    #####: 1284:				memcpy( addPhoneSeq,
    #####: 1285:				        &pgdata->phoneSeq[ cursor ],
        -: 1286:				        sizeof( uint16_t ) * newPhraseLen );
    #####: 1287:				addPhoneSeq[ newPhraseLen ] = 0;
    #####: 1288:				ueStrNCpy( addWordSeq,
    #####: 1289:				           ueStrSeek( (char *) &pgdata->phrOut.chiBuf,
        -: 1290:				                      cursor ),
        -: 1291:				           newPhraseLen, 1);
        -: 1292:
        -: 1293:
    #####: 1294:				phraseState = UserUpdatePhrase( pgdata, addPhoneSeq, addWordSeq );
    #####: 1295:				SetUpdatePhraseMsg(
        -: 1296:					pgdata,
        -: 1297:					addWordSeq,
        -: 1298:					newPhraseLen,
        -: 1299:					phraseState );
        -: 1300:
        -: 1301:				/* Clear the breakpoint between the New Phrase */
    #####: 1302:				for ( i = 1; i < newPhraseLen; i++ )
    #####: 1303:					pgdata->bUserArrBrkpt[ cursor + i ] = 0;
        -: 1304:			}
        -: 1305:		}
        -: 1306:	}
        -: 1307:	else {
    #####: 1308:		if (
    #####: 1309:			newPhraseLen >= 1 &&
    #####: 1310:			cursor - newPhraseLen >= 0 ) {
    #####: 1311:			if ( NoSymbolBetween( pgdata,
        -: 1312:				cursor - newPhraseLen,
        -: 1313:				cursor ) ) {
        -: 1314:				/* Manually add phrase to the user phrase database. */
    #####: 1315:				memcpy( addPhoneSeq,
    #####: 1316:				        &pgdata->phoneSeq[ cursor - newPhraseLen ],
        -: 1317:				        sizeof( uint16_t ) * newPhraseLen );
    #####: 1318:				addPhoneSeq[ newPhraseLen ] = 0;
    #####: 1319:				ueStrNCpy( addWordSeq,
    #####: 1320:				           ueStrSeek( (char *) &pgdata->phrOut.chiBuf,
    #####: 1321:				           cursor - newPhraseLen ),
        -: 1322:				           newPhraseLen, 1);
        -: 1323:
    #####: 1324:				phraseState = UserUpdatePhrase( pgdata, addPhoneSeq, addWordSeq );
    #####: 1325:				SetUpdatePhraseMsg(
        -: 1326:					pgdata,
        -: 1327:					addWordSeq,
        -: 1328:					newPhraseLen,
        -: 1329:					phraseState );
        -: 1330:
        -: 1331:				/* Clear the breakpoint between the New Phrase */
    #####: 1332:				for ( i = 1; i < newPhraseLen; i++ )
    #####: 1333:					pgdata->bUserArrBrkpt[ cursor - newPhraseLen + i ] = 0;
        -: 1334:			}
        -: 1335:		}
        -: 1336:	}
    #####: 1337:	CallPhrasing( pgdata );
    #####: 1338:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####: 1339:	MakeOutputAddMsgAndCleanInterval( pgo, pgdata );
    #####: 1340:	return 0;
        -: 1341:}
        -: 1342:
    #####: 1343:CHEWING_API int chewing_handle_ShiftSpace( ChewingContext *ctx )
        -: 1344:{
    #####: 1345:	ChewingData *pgdata = ctx->data;
    #####: 1346:	ChewingOutput *pgo = ctx->output;
    #####: 1347:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -: 1348:
    #####: 1349:	if ( ! pgdata->bSelect ) {
    #####: 1350:		CheckAndResetRange( pgdata );
        -: 1351:	}
    #####: 1352:	CallPhrasing( pgdata );
    #####: 1353:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
    #####: 1354:	return 0;
        -: 1355:}
        -: 1356:
       17: 1357:CHEWING_API int chewing_handle_Numlock( ChewingContext *ctx, int key )
        -: 1358:{
       17: 1359:	ChewingData *pgdata = ctx->data;
       17: 1360:	ChewingOutput *pgo = ctx->output;
       17: 1361:	int rtn, QuickCommit = 0;
       17: 1362:	int keystrokeRtn = KEYSTROKE_ABSORB;
        -: 1363:
       17: 1364:	if ( ! pgdata->bSelect ) {
        -: 1365:		/* If we're not selecting words, we should send out numeric
        -: 1366:		 * characters at once.
        -: 1367:		 */
       15: 1368:		if ( pgdata->chiSymbolBufLen == 0 ) {
       15: 1369:			QuickCommit = 1;
        -: 1370:		}
       15: 1371:		rtn = SymbolInput( key, pgdata );
        -: 1372:		/* copied from chewing_handle_Default */
       15: 1373:		if ( rtn == SYMBOL_KEY_ERROR ) {
    #####: 1374:			keystrokeRtn = KEYSTROKE_IGNORE ;
        -: 1375:		}
       15: 1376:		else if ( QuickCommit ) {
       15: 1377:			pgo->commitStr[ 0 ] = pgdata->chiSymbolBuf[ 0 ];
       15: 1378:			pgo->nCommitStr = 1;
       15: 1379:			pgdata->chiSymbolBufLen = 0;
       15: 1380:			pgdata->chiSymbolCursor = 0;
       15: 1381:			keystrokeRtn = KEYSTROKE_COMMIT;
        -: 1382:		}
        -: 1383:		else {	/* Not quick commit */
    #####: 1384:			CallPhrasing( pgdata );
    #####: 1385:			if( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )
    #####: 1386:				keystrokeRtn = KEYSTROKE_COMMIT;
        -: 1387:		}
        -: 1388:	}
        -: 1389:	else {
        -: 1390:		/* Otherwise, if we are selecting words, we use numeric keys
        -: 1391:		 * as selkey
        -: 1392:		 * and submit the words.
        -: 1393:		 */
        2: 1394:		int num = -1;
        2: 1395:		if ( key > '0' && key < '9' )
        2: 1396:			num = key - '1';
    #####: 1397:		else if ( key == '0' )
    #####: 1398:			num = 9;
        2: 1399:		DoSelect( pgdata, num );
        -: 1400:	}
       17: 1401:	CallPhrasing( pgdata );
       17: 1402:	if ( ReleaseChiSymbolBuf( pgdata, pgo ) != 0 )
    #####: 1403:		keystrokeRtn = KEYSTROKE_COMMIT;
       17: 1404:	MakeOutputWithRtn( pgo, pgdata, keystrokeRtn );
       17: 1405:	return 0;
        -: 1406:}
        -: 1407:
        3: 1408:CHEWING_API unsigned short *chewing_get_phoneSeq( ChewingContext *ctx )
        -: 1409:{
        -: 1410:	uint16_t *seq;
        3: 1411:	seq = ALC( uint16_t, ctx->data->nPhoneSeq );
        3: 1412:	if ( seq )
        3: 1413:		memcpy( seq, ctx->data->phoneSeq, sizeof(uint16_t)*ctx->data->nPhoneSeq );
        3: 1414:	return seq;
        -: 1415:}
        -: 1416:
        3: 1417:CHEWING_API int chewing_get_phoneSeqLen( ChewingContext *ctx )
        -: 1418:{
        3: 1419:	return ctx->data->nPhoneSeq;
        -: 1420:}
        -: 1421:
    #####: 1422:CHEWING_API void chewing_set_logger( ChewingContext *ctx,
        -: 1423:	void (*logger)( void *data, int level, const char *fmt, ... ),
        -: 1424:	void *data )
        -: 1425:{
    #####: 1426:	if ( !logger ) {
    #####: 1427:		logger = NullLogger;
    #####: 1428:		data = 0;
        -: 1429:	}
    #####: 1430:	ctx->data->logger = logger;
    #####: 1431:	ctx->data->loggerData = data;
    #####: 1432:}
