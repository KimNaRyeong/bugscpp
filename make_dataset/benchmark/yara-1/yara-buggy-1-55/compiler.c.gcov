        -:    0:Source:compiler.c
        -:    0:Graph:/home/workspace/libyara/compiler.gcno
        -:    0:Data:/home/workspace/libyara/compiler.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013-2018. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <assert.h>
        -:   31:#include <fcntl.h>
        -:   32:#include <stdbool.h>
        -:   33:#include <stddef.h>
        -:   34:#include <stdio.h>
        -:   35:#include <string.h>
        -:   36:#include <sys/stat.h>
        -:   37:
        -:   38:#ifdef _MSC_VER
        -:   39:#include <io.h>
        -:   40:#include <share.h>
        -:   41:#else
        -:   42:#include <unistd.h>
        -:   43:#endif
        -:   44:
        -:   45:#include <yara/libyara.h>
        -:   46:#include <yara/utils.h>
        -:   47:#include <yara/compiler.h>
        -:   48:#include <yara/exec.h>
        -:   49:#include <yara/error.h>
        -:   50:#include <yara/mem.h>
        -:   51:#include <yara/object.h>
        -:   52:#include <yara/lexer.h>
        -:   53:#include <yara/strutils.h>
        -:   54:
        -:   55:
    #####:   56:static void _yr_compiler_default_include_free(
        -:   57:    const char* callback_result_ptr,
        -:   58:    void* user_data)
        -:   59:{
    #####:   60:  if (callback_result_ptr != NULL)
        -:   61:  {
    #####:   62:    yr_free((void*)callback_result_ptr);
        -:   63:  }
    #####:   64:}
        -:   65:
        -:   66:
    #####:   67:const char* _yr_compiler_default_include_callback(
        -:   68:    const char* include_name,
        -:   69:    const char* calling_rule_filename,
        -:   70:    const char* calling_rule_namespace,
        -:   71:    void* user_data)
        -:   72:{
        -:   73:  #ifndef _MSC_VER
        -:   74:  struct stat stbuf;
        -:   75:  #endif
        -:   76:
        -:   77:  char* file_buffer;
        -:   78:
        -:   79:  #ifdef _MSC_VER
        -:   80:  long file_size;
        -:   81:  #else
        -:   82:  off_t file_size;
        -:   83:  #endif
        -:   84:
    #####:   85:  int fd = -1;
        -:   86:
        -:   87:  #if defined(_MSC_VER)
        -:   88:  _sopen_s(&fd, include_name, _O_RDONLY | _O_BINARY, _SH_DENYRW, _S_IREAD);
        -:   89:  #elif defined(_WIN32) || defined(__CYGWIN__)
        -:   90:  fd = open(include_name, O_RDONLY | O_BINARY);
        -:   91:  #else
    #####:   92:  fd = open(include_name, O_RDONLY);
        -:   93:  #endif
        -:   94:
    #####:   95:  if (fd == -1)
    #####:   96:    return NULL;
        -:   97:
        -:   98:  #ifdef _MSC_VER
        -:   99:  file_size = _filelength(fd);
        -:  100:  if (file_size == -1)
        -:  101:  {
        -:  102:    _close(fd);
        -:  103:    return NULL;
        -:  104:  }
        -:  105:  #else
    #####:  106:  if ((fstat(fd, &stbuf) != 0) || (!S_ISREG(stbuf.st_mode)))
        -:  107:  {
    #####:  108:    close(fd);
    #####:  109:    return NULL;
        -:  110:  }
    #####:  111:  file_size = stbuf.st_size;
        -:  112:  #endif
        -:  113:
    #####:  114:  file_buffer = (char*) yr_malloc((size_t) file_size + 1);
        -:  115:
    #####:  116:  if (file_buffer == NULL)
        -:  117:  {
        -:  118:    #ifdef _MSC_VER
        -:  119:    _close(fd);
        -:  120:    #else
    #####:  121:    close(fd);
        -:  122:    #endif
        -:  123:
    #####:  124:    return NULL;
        -:  125:  }
        -:  126:
    #####:  127:  if (file_size != read(fd, file_buffer, (size_t) file_size))
        -:  128:  {
    #####:  129:    yr_free(file_buffer);
        -:  130:
        -:  131:    #ifdef _MSC_VER
        -:  132:    _close(fd);
        -:  133:    #else
    #####:  134:    close(fd);
        -:  135:    #endif
        -:  136:
    #####:  137:    return NULL;
        -:  138:  }
        -:  139:  else
        -:  140:  {
    #####:  141:    file_buffer[file_size] = '\0';
        -:  142:  }
        -:  143:
        -:  144:  #ifdef _MSC_VER
        -:  145:  _close(fd);
        -:  146:  #else
    #####:  147:  close(fd);
        -:  148:  #endif
        -:  149:
    #####:  150:  return file_buffer;
        -:  151:}
        -:  152:
        -:  153:
        1:  154:YR_API int yr_compiler_create(
        -:  155:    YR_COMPILER** compiler)
        -:  156:{
        -:  157:  int result;
        -:  158:  YR_COMPILER* new_compiler;
        -:  159:
        1:  160:  new_compiler = (YR_COMPILER*) yr_calloc(1, sizeof(YR_COMPILER));
        -:  161:
        1:  162:  if (new_compiler == NULL)
    #####:  163:    return ERROR_INSUFFICIENT_MEMORY;
        -:  164:
        1:  165:  new_compiler->errors = 0;
        1:  166:  new_compiler->callback = NULL;
        1:  167:  new_compiler->include_callback = _yr_compiler_default_include_callback;
        1:  168:  new_compiler->incl_clbk_user_data = NULL;
        1:  169:  new_compiler->include_free = _yr_compiler_default_include_free;
        1:  170:  new_compiler->re_ast_callback = NULL;
        1:  171:  new_compiler->re_ast_clbk_user_data = NULL;
        1:  172:  new_compiler->last_error = ERROR_SUCCESS;
        1:  173:  new_compiler->last_error_line = 0;
        1:  174:  new_compiler->current_line = 0;
        1:  175:  new_compiler->file_name_stack_ptr = 0;
        1:  176:  new_compiler->fixup_stack_head = NULL;
        1:  177:  new_compiler->loop_depth = 0;
        1:  178:  new_compiler->loop_for_of_mem_offset = -1;
        1:  179:  new_compiler->compiled_rules_arena = NULL;
        1:  180:  new_compiler->namespaces_count = 0;
        1:  181:  new_compiler->current_rule = NULL;
        1:  182:  new_compiler->atoms_config.get_atom_quality = yr_atoms_heuristic_quality;
        1:  183:  new_compiler->atoms_config.quality_warning_threshold = \
        -:  184:      YR_ATOM_QUALITY_WARNING_THRESHOLD;
        -:  185:
        1:  186:  result = yr_hash_table_create(10007, &new_compiler->rules_table);
        -:  187:
        1:  188:  if (result == ERROR_SUCCESS)
        1:  189:    result = yr_hash_table_create(10007, &new_compiler->objects_table);
        -:  190:
        1:  191:  if (result == ERROR_SUCCESS)
        1:  192:    result = yr_hash_table_create(101, &new_compiler->strings_table);
        -:  193:
        1:  194:  if (result == ERROR_SUCCESS)
        1:  195:    result = yr_arena_create(
        -:  196:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->sz_arena);
        -:  197:
        1:  198:  if (result == ERROR_SUCCESS)
        1:  199:    result = yr_arena_create(
        -:  200:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->rules_arena);
        -:  201:
        1:  202:  if (result == ERROR_SUCCESS)
        1:  203:    result = yr_arena_create(
        -:  204:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->strings_arena);
        -:  205:
        1:  206:  if (result == ERROR_SUCCESS)
        1:  207:      result = yr_arena_create(
        -:  208:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->code_arena);
        -:  209:
        1:  210:  if (result == ERROR_SUCCESS)
        1:  211:    result = yr_arena_create(
        -:  212:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->re_code_arena);
        -:  213:
        1:  214:  if (result == ERROR_SUCCESS)
        1:  215:    result = yr_arena_create(
        -:  216:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->externals_arena);
        -:  217:
        1:  218:  if (result == ERROR_SUCCESS)
        1:  219:    result = yr_arena_create(
        -:  220:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->namespaces_arena);
        -:  221:
        1:  222:  if (result == ERROR_SUCCESS)
        1:  223:    result = yr_arena_create(
        -:  224:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->metas_arena);
        -:  225:
        1:  226:  if (result == ERROR_SUCCESS)
        1:  227:    result = yr_arena_create(
        -:  228:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->automaton_arena);
        -:  229:
        1:  230:  if (result == ERROR_SUCCESS)
        1:  231:    result = yr_arena_create(
        -:  232:        65536, ARENA_FLAGS_RELOCATABLE, &new_compiler->matches_arena);
        -:  233:
        1:  234:  if (result == ERROR_SUCCESS)
        1:  235:    result = yr_ac_automaton_create(&new_compiler->automaton);
        -:  236:
        1:  237:  if (result == ERROR_SUCCESS)
        -:  238:  {
        1:  239:    *compiler = new_compiler;
        -:  240:  }
        -:  241:  else  // if error, do cleanup
        -:  242:  {
    #####:  243:    yr_compiler_destroy(new_compiler);
        -:  244:  }
        -:  245:
        1:  246:  return result;
        -:  247:}
        -:  248:
        -:  249:
        1:  250:YR_API void yr_compiler_destroy(
        -:  251:    YR_COMPILER* compiler)
        -:  252:{
        -:  253:  YR_FIXUP* fixup;
        -:  254:  int i;
        -:  255:
        1:  256:  yr_arena_destroy(compiler->compiled_rules_arena);
        1:  257:  yr_arena_destroy(compiler->sz_arena);
        1:  258:  yr_arena_destroy(compiler->rules_arena);
        1:  259:  yr_arena_destroy(compiler->strings_arena);
        1:  260:  yr_arena_destroy(compiler->code_arena);
        1:  261:  yr_arena_destroy(compiler->re_code_arena);
        1:  262:  yr_arena_destroy(compiler->externals_arena);
        1:  263:  yr_arena_destroy(compiler->namespaces_arena);
        1:  264:  yr_arena_destroy(compiler->metas_arena);
        1:  265:  yr_arena_destroy(compiler->automaton_arena);
        1:  266:  yr_arena_destroy(compiler->matches_arena);
        -:  267:
        1:  268:  yr_ac_automaton_destroy(compiler->automaton);
        -:  269:
        1:  270:  yr_hash_table_destroy(
        -:  271:      compiler->rules_table,
        -:  272:      NULL);
        -:  273:
        1:  274:  yr_hash_table_destroy(
        -:  275:      compiler->strings_table,
        -:  276:      NULL);
        -:  277:
        1:  278:  yr_hash_table_destroy(
        -:  279:      compiler->objects_table,
        -:  280:      (YR_HASH_TABLE_FREE_VALUE_FUNC) yr_object_destroy);
        -:  281:
        1:  282:  if (compiler->  atoms_config.free_quality_table)
    #####:  283:    yr_free(compiler->atoms_config.quality_table);
        -:  284:
       1*:  285:  for (i = 0; i < compiler->file_name_stack_ptr; i++)
    #####:  286:    yr_free(compiler->file_name_stack[i]);
        -:  287:
        1:  288:  fixup = compiler->fixup_stack_head;
        -:  289:
        1:  290:  while (fixup != NULL)
        -:  291:  {
    #####:  292:    YR_FIXUP* next_fixup = fixup->next;
    #####:  293:    yr_free(fixup);
    #####:  294:    fixup = next_fixup;
        -:  295:  }
        -:  296:
        1:  297:  yr_free(compiler);
        1:  298:}
        -:  299:
        -:  300:
    #####:  301:YR_API void yr_compiler_set_callback(
        -:  302:    YR_COMPILER* compiler,
        -:  303:    YR_COMPILER_CALLBACK_FUNC callback,
        -:  304:    void* user_data)
        -:  305:{
    #####:  306:  compiler->callback = callback;
    #####:  307:  compiler->user_data = user_data;
    #####:  308:}
        -:  309:
        -:  310:
    #####:  311:YR_API void yr_compiler_set_include_callback(
        -:  312:    YR_COMPILER* compiler,
        -:  313:    YR_COMPILER_INCLUDE_CALLBACK_FUNC include_callback,
        -:  314:    YR_COMPILER_INCLUDE_FREE_FUNC include_free,
        -:  315:    void* user_data)
        -:  316:{
    #####:  317:  compiler->include_callback = include_callback;
    #####:  318:  compiler->include_free = include_free;
    #####:  319:  compiler->incl_clbk_user_data = user_data;
    #####:  320:}
        -:  321:
        -:  322:
    #####:  323:YR_API void yr_compiler_set_re_ast_callback(
        -:  324:    YR_COMPILER* compiler,
        -:  325:    YR_COMPILER_RE_AST_CALLBACK_FUNC re_ast_callback,
        -:  326:    void* user_data)
        -:  327:{
    #####:  328:  compiler->re_ast_callback = re_ast_callback;
    #####:  329:  compiler->re_ast_clbk_user_data = user_data;
    #####:  330:}
        -:  331:
        -:  332:
        -:  333://
        -:  334:// yr_compiler_set_atom_quality_table
        -:  335://
        -:  336:// This function allows to specify an atom quality table to be used by the
        -:  337:// compiler for choosing the best atoms from regular expressions and strings.
        -:  338:// When a quality table is set, the compiler uses yr_atoms_table_quality
        -:  339:// instead of yr_atoms_heuristic_quality for computing atom quality. The table
        -:  340:// has an arbitary number of entries, each composed of YR_MAX_ATOM_LENGTH + 1
        -:  341:// bytes. The first YR_MAX_ATOM_LENGTH bytes from each entry are the atom's
        -:  342:// ones, and the remaining byte is a value in the range 0-255 determining the
        -:  343:// atom's quality. Entries must be lexicografically sorted by atom in ascending
        -:  344:// order.
        -:  345://
        -:  346://  [ atom (YR_MAX_ATOM_LENGTH bytes) ] [ quality (1 byte) ]
        -:  347://
        -:  348://  [ 00 00 .. 00 00 ] [ 00 ]
        -:  349://  [ 00 00 .. 00 01 ] [ 45 ]
        -:  350://  [ 00 00 .. 00 02 ] [ 13 ]
        -:  351://  ...
        -:  352://  [ FF FF .. FF FF ] [ 03 ]
        -:  353://
        -:  354:// The "table" argument must point to a buffer containing the quality in
        -:  355:// the format explained above, and "entries" must contain the number of entries
        -:  356:// in the table. The table can not be freed while the compiler is in use, the
        -:  357:// caller is responsible for freeing the table.
        -:  358://
        -:  359:// The "warning_threshold" argument must be a number between 0 and 255, if some
        -:  360:// atom choosen for a string have a quality below the specified threshold a
        -:  361:// warning like "<string> is slowing down scanning" is shown.
        -:  362:
    #####:  363:YR_API void yr_compiler_set_atom_quality_table(
        -:  364:    YR_COMPILER* compiler,
        -:  365:    const void* table,
        -:  366:    int entries,
        -:  367:    unsigned char warning_threshold)
        -:  368:{
    #####:  369:  compiler->atoms_config.free_quality_table = false;
    #####:  370:  compiler->atoms_config.quality_warning_threshold = warning_threshold;
    #####:  371:  compiler->atoms_config.get_atom_quality = yr_atoms_table_quality;
    #####:  372:  compiler->atoms_config.quality_table_entries = entries;
    #####:  373:  compiler->atoms_config.quality_table = \
        -:  374:      (YR_ATOM_QUALITY_TABLE_ENTRY*) table;
    #####:  375:}
        -:  376:
        -:  377://
        -:  378:// yr_compiler_set_atom_quality_table
        -:  379://
        -:  380:// Load an atom quality table from a file. The file's content must have the
        -:  381:// format explained in the decription for yr_compiler_set_atom_quality_table.
        -:  382://
        -:  383:
    #####:  384:YR_API int yr_compiler_load_atom_quality_table(
        -:  385:    YR_COMPILER* compiler,
        -:  386:    const char* filename,
        -:  387:    unsigned char warning_threshold)
        -:  388:{
    #####:  389:  FILE* fh = fopen(filename, "rb");
        -:  390:
    #####:  391:  if (fh == NULL)
    #####:  392:    return ERROR_COULD_NOT_OPEN_FILE;
        -:  393:
    #####:  394:  fseek(fh, 0L, SEEK_END);
    #####:  395:  long file_size = ftell(fh);
    #####:  396:  fseek(fh, 0L, SEEK_SET);
        -:  397:
    #####:  398:  void* table = yr_malloc(file_size);
        -:  399:
    #####:  400:  if (table == NULL)
        -:  401:  {
    #####:  402:    fclose(fh);
    #####:  403:    return ERROR_INSUFFICIENT_MEMORY;
        -:  404:  }
        -:  405:
    #####:  406:  int entries = file_size / sizeof(YR_ATOM_QUALITY_TABLE_ENTRY);
        -:  407:
    #####:  408:  if (fread(table, sizeof(YR_ATOM_QUALITY_TABLE_ENTRY), entries, fh) != entries)
        -:  409:  {
    #####:  410:    fclose(fh);
    #####:  411:    yr_free(table);
    #####:  412:    return ERROR_COULD_NOT_READ_FILE;
        -:  413:  }
        -:  414:
    #####:  415:  fclose(fh);
        -:  416:
    #####:  417:  yr_compiler_set_atom_quality_table(
        -:  418:      compiler, table, entries, warning_threshold);
        -:  419:
    #####:  420:  compiler->atoms_config.free_quality_table = true;
        -:  421:
    #####:  422:  return ERROR_SUCCESS;
        -:  423:}
        -:  424:
        -:  425:
    #####:  426:int _yr_compiler_push_file_name(
        -:  427:    YR_COMPILER* compiler,
        -:  428:    const char* file_name)
        -:  429:{
        -:  430:  char* str;
        -:  431:  int i;
        -:  432:
    #####:  433:  for (i = 0; i < compiler->file_name_stack_ptr; i++)
        -:  434:  {
    #####:  435:    if (strcmp(file_name, compiler->file_name_stack[i]) == 0)
    #####:  436:      return ERROR_INCLUDES_CIRCULAR_REFERENCE;
        -:  437:  }
        -:  438:
    #####:  439:  if (compiler->file_name_stack_ptr == YR_MAX_INCLUDE_DEPTH)
    #####:  440:    return ERROR_INCLUDE_DEPTH_EXCEEDED;
        -:  441:
    #####:  442:  str = yr_strdup(file_name);
        -:  443:
    #####:  444:  if (str == NULL)
    #####:  445:    return ERROR_INSUFFICIENT_MEMORY;
        -:  446:
    #####:  447:  compiler->file_name_stack[compiler->file_name_stack_ptr] = str;
    #####:  448:  compiler->file_name_stack_ptr++;
        -:  449:
    #####:  450:  return ERROR_SUCCESS;
        -:  451:}
        -:  452:
        -:  453:
        1:  454:void _yr_compiler_pop_file_name(
        -:  455:    YR_COMPILER* compiler)
        -:  456:{
        1:  457:  if (compiler->file_name_stack_ptr > 0)
        -:  458:  {
    #####:  459:    compiler->file_name_stack_ptr--;
    #####:  460:    yr_free(compiler->file_name_stack[compiler->file_name_stack_ptr]);
    #####:  461:    compiler->file_name_stack[compiler->file_name_stack_ptr] = NULL;
        -:  462:  }
        1:  463:}
        -:  464:
        -:  465:
    #####:  466:YR_API char* yr_compiler_get_current_file_name(
        -:  467:    YR_COMPILER* compiler)
        -:  468:{
    #####:  469:  if (compiler->file_name_stack_ptr > 0)
        -:  470:  {
    #####:  471:    return compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  472:  }
        -:  473:  else
        -:  474:  {
    #####:  475:    return NULL;
        -:  476:  }
        -:  477:}
        -:  478:
        -:  479:
        1:  480:static int _yr_compiler_set_namespace(
        -:  481:    YR_COMPILER* compiler,
        -:  482:    const char* namespace_)
        -:  483:{
        -:  484:  YR_NAMESPACE* ns;
        -:  485:
        -:  486:  char* ns_name;
        -:  487:  int result;
        -:  488:  int i;
        -:  489:  bool found;
        -:  490:
        1:  491:  ns = (YR_NAMESPACE*) yr_arena_base_address(compiler->namespaces_arena);
        1:  492:  found = false;
        -:  493:
       1*:  494:  for (i = 0; i < compiler->namespaces_count; i++)
        -:  495:  {
    #####:  496:    if (strcmp(ns->name, namespace_) == 0)
        -:  497:    {
    #####:  498:      found = true;
    #####:  499:      break;
        -:  500:    }
        -:  501:
    #####:  502:    ns = (YR_NAMESPACE*) yr_arena_next_address(
        -:  503:        compiler->namespaces_arena,
        -:  504:        ns,
        -:  505:        sizeof(YR_NAMESPACE));
        -:  506:  }
        -:  507:
        1:  508:  if (!found)
        -:  509:  {
        1:  510:    result = yr_arena_write_string(
        -:  511:        compiler->sz_arena,
        -:  512:        namespace_,
        -:  513:        &ns_name);
        -:  514:
        1:  515:    if (result == ERROR_SUCCESS)
        1:  516:      result = yr_arena_allocate_struct(
        -:  517:          compiler->namespaces_arena,
        -:  518:          sizeof(YR_NAMESPACE),
        -:  519:          (void**) &ns,
        -:  520:          offsetof(YR_NAMESPACE, name),
        -:  521:          EOL);
        -:  522:
        1:  523:    if (result != ERROR_SUCCESS)
    #####:  524:      return result;
        -:  525:
        1:  526:    ns->name = ns_name;
        -:  527:
       33:  528:    for (i = 0; i < YR_MAX_THREADS; i++)
       32:  529:      ns->t_flags[i] = 0;
        -:  530:
        1:  531:    compiler->namespaces_count++;
        -:  532:  }
        -:  533:
        1:  534:  compiler->current_namespace = ns;
        1:  535:  return ERROR_SUCCESS;
        -:  536:}
        -:  537:
        -:  538:
    #####:  539:YR_API int yr_compiler_add_file(
        -:  540:    YR_COMPILER* compiler,
        -:  541:    FILE* rules_file,
        -:  542:    const char* namespace_,
        -:  543:    const char* file_name)
        -:  544:{
        -:  545:  // Don't allow yr_compiler_add_file() after
        -:  546:  // yr_compiler_get_rules() has been called.
        -:  547:
    #####:  548:  assert(compiler->compiled_rules_arena == NULL);
        -:  549:
        -:  550:  // Don't allow calls to yr_compiler_add_file() if a previous call to
        -:  551:  // yr_compiler_add_XXXX failed.
        -:  552:
    #####:  553:  assert(compiler->errors == 0);
        -:  554:
    #####:  555:  if (file_name != NULL)
    #####:  556:    _yr_compiler_push_file_name(compiler, file_name);
        -:  557:
    #####:  558:  if (namespace_ != NULL)
    #####:  559:    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);
        -:  560:  else
    #####:  561:    compiler->last_error = _yr_compiler_set_namespace(compiler, "default");
        -:  562:
    #####:  563:  if (compiler->last_error != ERROR_SUCCESS)
        -:  564:  {
    #####:  565:    compiler->errors++;
    #####:  566:    return compiler->errors;
        -:  567:  }
        -:  568:
    #####:  569:  return yr_lex_parse_rules_file(rules_file, compiler);
        -:  570:}
        -:  571:
        -:  572:
    #####:  573:YR_API int yr_compiler_add_fd(
        -:  574:    YR_COMPILER* compiler,
        -:  575:    YR_FILE_DESCRIPTOR rules_fd,
        -:  576:    const char* namespace_,
        -:  577:    const char* file_name)
        -:  578:{
        -:  579:  // Don't allow yr_compiler_add_fd() after
        -:  580:  // yr_compiler_get_rules() has been called.
        -:  581:
    #####:  582:  assert(compiler->compiled_rules_arena == NULL);
        -:  583:
        -:  584:  // Don't allow calls to yr_compiler_add_fd() if a previous call to
        -:  585:  // yr_compiler_add_XXXX failed.
        -:  586:
    #####:  587:  assert(compiler->errors == 0);
        -:  588:
    #####:  589:  if (file_name != NULL)
    #####:  590:    _yr_compiler_push_file_name(compiler, file_name);
        -:  591:
    #####:  592:  if (namespace_ != NULL)
    #####:  593:    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);
        -:  594:  else
    #####:  595:    compiler->last_error = _yr_compiler_set_namespace(compiler, "default");
        -:  596:
    #####:  597:  if (compiler->last_error != ERROR_SUCCESS)
        -:  598:  {
    #####:  599:    compiler->errors++;
    #####:  600:    return compiler->errors;
        -:  601:  }
        -:  602:
    #####:  603:  return yr_lex_parse_rules_fd(rules_fd, compiler);
        -:  604:}
        -:  605:
        -:  606:
        1:  607:YR_API int yr_compiler_add_string(
        -:  608:    YR_COMPILER* compiler,
        -:  609:    const char* rules_string,
        -:  610:    const char* namespace_)
        -:  611:{
        -:  612:  // Don't allow calls to yr_compiler_add_string() after
        -:  613:  // yr_compiler_get_rules() has been called.
        -:  614:
       1*:  615:  assert(compiler->compiled_rules_arena == NULL);
        -:  616:
        -:  617:  // Don't allow calls to yr_compiler_add_string() if a previous call to
        -:  618:  // yr_compiler_add_XXXX failed.
        -:  619:
       1*:  620:  assert(compiler->errors == 0);
        -:  621:
        1:  622:  if (namespace_ != NULL)
    #####:  623:    compiler->last_error = _yr_compiler_set_namespace(compiler, namespace_);
        -:  624:  else
        1:  625:    compiler->last_error = _yr_compiler_set_namespace(compiler, "default");
        -:  626:
        1:  627:  if (compiler->last_error != ERROR_SUCCESS)
        -:  628:  {
    #####:  629:    compiler->errors++;
    #####:  630:    return compiler->errors;
        -:  631:  }
        -:  632:
        1:  633:  return yr_lex_parse_rules_string(rules_string, compiler);
        -:  634:}
        -:  635:
        -:  636:
    #####:  637:static int _yr_compiler_compile_rules(
        -:  638:    YR_COMPILER* compiler)
        -:  639:{
    #####:  640:  YARA_RULES_FILE_HEADER* rules_file_header = NULL;
    #####:  641:  YR_ARENA* arena = NULL;
        -:  642:  YR_RULE null_rule;
        -:  643:  YR_EXTERNAL_VARIABLE null_external;
        -:  644:  YR_AC_TABLES tables;
        -:  645:
    #####:  646:  uint8_t halt = OP_HALT;
        -:  647:  int result;
        -:  648:
        -:  649:  // Write halt instruction at the end of code.
    #####:  650:  yr_arena_write_data(
        -:  651:      compiler->code_arena,
        -:  652:      &halt,
        -:  653:      sizeof(uint8_t),
        -:  654:      NULL);
        -:  655:
        -:  656:  // Write a null rule indicating the end.
    #####:  657:  memset(&null_rule, 0xFA, sizeof(YR_RULE));
    #####:  658:  null_rule.g_flags = RULE_GFLAGS_NULL;
        -:  659:
    #####:  660:  yr_arena_write_data(
        -:  661:      compiler->rules_arena,
        -:  662:      &null_rule,
        -:  663:      sizeof(YR_RULE),
        -:  664:      NULL);
        -:  665:
        -:  666:  // Write a null external the end.
    #####:  667:  memset(&null_external, 0xFA, sizeof(YR_EXTERNAL_VARIABLE));
    #####:  668:  null_external.type = EXTERNAL_VARIABLE_TYPE_NULL;
        -:  669:
    #####:  670:  yr_arena_write_data(
        -:  671:      compiler->externals_arena,
        -:  672:      &null_external,
        -:  673:      sizeof(YR_EXTERNAL_VARIABLE),
        -:  674:      NULL);
        -:  675:
        -:  676:  // Write Aho-Corasick automaton to arena.
    #####:  677:  result = yr_ac_compile(
        -:  678:      compiler->automaton,
        -:  679:      compiler->automaton_arena,
        -:  680:      &tables);
        -:  681:
    #####:  682:  if (result == ERROR_SUCCESS)
    #####:  683:    result = yr_arena_create(1024, ARENA_FLAGS_RELOCATABLE, &arena);
        -:  684:
    #####:  685:  if (result == ERROR_SUCCESS)
    #####:  686:    result = yr_arena_allocate_struct(
        -:  687:        arena,
        -:  688:        sizeof(YARA_RULES_FILE_HEADER),
        -:  689:        (void**) &rules_file_header,
        -:  690:        offsetof(YARA_RULES_FILE_HEADER, rules_list_head),
        -:  691:        offsetof(YARA_RULES_FILE_HEADER, externals_list_head),
        -:  692:        offsetof(YARA_RULES_FILE_HEADER, code_start),
        -:  693:        offsetof(YARA_RULES_FILE_HEADER, ac_match_table),
        -:  694:        offsetof(YARA_RULES_FILE_HEADER, ac_transition_table),
        -:  695:        EOL);
        -:  696:
    #####:  697:  if (result == ERROR_SUCCESS)
        -:  698:  {
    #####:  699:    rules_file_header->rules_list_head = (YR_RULE*) yr_arena_base_address(
        -:  700:        compiler->rules_arena);
        -:  701:
    #####:  702:    rules_file_header->externals_list_head = (YR_EXTERNAL_VARIABLE*)
    #####:  703:		yr_arena_base_address(compiler->externals_arena);
        -:  704:
    #####:  705:    rules_file_header->code_start = (uint8_t*) yr_arena_base_address(
        -:  706:        compiler->code_arena);
        -:  707:
    #####:  708:    rules_file_header->ac_match_table = tables.matches;
    #####:  709:    rules_file_header->ac_transition_table = tables.transitions;
    #####:  710:    rules_file_header->ac_tables_size = compiler->automaton->tables_size;
        -:  711:  }
        -:  712:
    #####:  713:  if (result == ERROR_SUCCESS)
        -:  714:  {
    #####:  715:    result = yr_arena_append(
        -:  716:        arena,
        -:  717:        compiler->code_arena);
        -:  718:  }
        -:  719:
    #####:  720:  if (result == ERROR_SUCCESS)
        -:  721:  {
    #####:  722:    compiler->code_arena = NULL;
    #####:  723:    result = yr_arena_append(
        -:  724:        arena,
        -:  725:        compiler->re_code_arena);
        -:  726:  }
        -:  727:
    #####:  728:  if (result == ERROR_SUCCESS)
        -:  729:  {
    #####:  730:    compiler->re_code_arena = NULL;
    #####:  731:    result = yr_arena_append(
        -:  732:        arena,
        -:  733:        compiler->rules_arena);
        -:  734:  }
        -:  735:
    #####:  736:  if (result == ERROR_SUCCESS)
        -:  737:  {
    #####:  738:    compiler->rules_arena = NULL;
    #####:  739:    result = yr_arena_append(
        -:  740:        arena,
        -:  741:        compiler->strings_arena);
        -:  742:  }
        -:  743:
    #####:  744:  if (result == ERROR_SUCCESS)
        -:  745:  {
    #####:  746:    compiler->strings_arena = NULL;
    #####:  747:    result = yr_arena_append(
        -:  748:        arena,
        -:  749:        compiler->externals_arena);
        -:  750:  }
        -:  751:
    #####:  752:  if (result == ERROR_SUCCESS)
        -:  753:  {
    #####:  754:    compiler->externals_arena = NULL;
    #####:  755:    result = yr_arena_append(
        -:  756:        arena,
        -:  757:        compiler->namespaces_arena);
        -:  758:  }
        -:  759:
    #####:  760:  if (result == ERROR_SUCCESS)
        -:  761:  {
    #####:  762:    compiler->namespaces_arena = NULL;
    #####:  763:    result = yr_arena_append(
        -:  764:        arena,
        -:  765:        compiler->metas_arena);
        -:  766:  }
        -:  767:
    #####:  768:  if (result == ERROR_SUCCESS)
        -:  769:  {
    #####:  770:    compiler->metas_arena = NULL;
    #####:  771:    result = yr_arena_append(
        -:  772:        arena,
        -:  773:        compiler->sz_arena);
        -:  774:  }
        -:  775:
    #####:  776:  if (result == ERROR_SUCCESS)
        -:  777:  {
    #####:  778:    compiler->sz_arena = NULL;
    #####:  779:    result = yr_arena_append(
        -:  780:        arena,
        -:  781:        compiler->automaton_arena);
        -:  782:  }
        -:  783:
    #####:  784:  if (result == ERROR_SUCCESS)
        -:  785:  {
    #####:  786:    compiler->automaton_arena = NULL;
    #####:  787:    result = yr_arena_append(
        -:  788:        arena,
        -:  789:        compiler->matches_arena);
        -:  790:  }
        -:  791:
    #####:  792:  if (result == ERROR_SUCCESS)
        -:  793:  {
    #####:  794:    compiler->matches_arena = NULL;
    #####:  795:    compiler->compiled_rules_arena = arena;
    #####:  796:    result = yr_arena_coalesce(arena);
        -:  797:  }
        -:  798:  else
        -:  799:  {
    #####:  800:    yr_arena_destroy(arena);
        -:  801:  }
        -:  802:
    #####:  803:  return result;
        -:  804:}
        -:  805:
        -:  806:
    #####:  807:YR_API int yr_compiler_get_rules(
        -:  808:    YR_COMPILER* compiler,
        -:  809:    YR_RULES** rules)
        -:  810:{
        -:  811:  YR_RULES* yara_rules;
        -:  812:  YARA_RULES_FILE_HEADER* rules_file_header;
        -:  813:
        -:  814:  // Don't allow calls to yr_compiler_get_rules() if a previous call to
        -:  815:  // yr_compiler_add_XXXX failed.
        -:  816:
    #####:  817:  assert(compiler->errors == 0);
        -:  818:
    #####:  819:  *rules = NULL;
        -:  820:
    #####:  821:  if (compiler->compiled_rules_arena == NULL)
    #####:  822:     FAIL_ON_ERROR(_yr_compiler_compile_rules(compiler));
        -:  823:
    #####:  824:  yara_rules = (YR_RULES*) yr_malloc(sizeof(YR_RULES));
        -:  825:
    #####:  826:  if (yara_rules == NULL)
    #####:  827:    return ERROR_INSUFFICIENT_MEMORY;
        -:  828:
    #####:  829:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  830:      yr_arena_duplicate(compiler->compiled_rules_arena, &yara_rules->arena),
        -:  831:      yr_free(yara_rules));
        -:  832:
    #####:  833:  rules_file_header = (YARA_RULES_FILE_HEADER*) yr_arena_base_address(
        -:  834:      yara_rules->arena);
        -:  835:
    #####:  836:  yara_rules->externals_list_head = rules_file_header->externals_list_head;
    #####:  837:  yara_rules->rules_list_head = rules_file_header->rules_list_head;
    #####:  838:  yara_rules->ac_match_table = rules_file_header->ac_match_table;
    #####:  839:  yara_rules->ac_transition_table = rules_file_header->ac_transition_table;
    #####:  840:  yara_rules->ac_tables_size = rules_file_header->ac_tables_size;
    #####:  841:  yara_rules->code_start = rules_file_header->code_start;
    #####:  842:  yara_rules->time_cost = 0;
        -:  843:
    #####:  844:  memset(yara_rules->tidx_mask, 0, sizeof(yara_rules->tidx_mask));
        -:  845:
    #####:  846:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  847:      yr_mutex_create(&yara_rules->mutex),
        -:  848:      // cleanup
        -:  849:      yr_arena_destroy(yara_rules->arena);
        -:  850:      yr_free(yara_rules));
        -:  851:
    #####:  852:  *rules = yara_rules;
        -:  853:
    #####:  854:  return ERROR_SUCCESS;
        -:  855:}
        -:  856:
        1:  857:int _yr_compiler_define_variable(
        -:  858:    YR_COMPILER* compiler,
        -:  859:    YR_EXTERNAL_VARIABLE* external)
        -:  860:{
        -:  861:  YR_EXTERNAL_VARIABLE* ext;
        -:  862:  YR_OBJECT* object;
        -:  863:
        -:  864:  char* id;
        -:  865:
        1:  866:  object = (YR_OBJECT*) yr_hash_table_lookup(
        -:  867:      compiler->objects_table,
        -:  868:      external->identifier,
        -:  869:      NULL);
        -:  870:
        1:  871:  if (object != NULL)
    #####:  872:    return ERROR_DUPLICATED_EXTERNAL_VARIABLE;
        -:  873:
       1*:  874:  FAIL_ON_ERROR(yr_arena_write_string(
        -:  875:      compiler->sz_arena,
        -:  876:      external->identifier,
        -:  877:      &id));
        -:  878:
       1*:  879:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -:  880:      compiler->externals_arena,
        -:  881:      sizeof(YR_EXTERNAL_VARIABLE),
        -:  882:      (void**) &ext,
        -:  883:      offsetof(YR_EXTERNAL_VARIABLE, identifier),
        -:  884:      EOL));
        -:  885:
        1:  886:  ext->identifier = id;
        1:  887:  ext->type = external->type;
        1:  888:  ext->value = external->value;
        -:  889:
        1:  890:  if (external->type == EXTERNAL_VARIABLE_TYPE_STRING)
        -:  891:  {
        -:  892:    char* val;
        -:  893:
    #####:  894:    FAIL_ON_ERROR(yr_arena_write_string(
        -:  895:        compiler->sz_arena,
        -:  896:        external->value.s,
        -:  897:        &val));
        -:  898:
    #####:  899:    ext->value.s = val;
        -:  900:
    #####:  901:    FAIL_ON_ERROR(yr_arena_make_ptr_relocatable(
        -:  902:        compiler->externals_arena,
        -:  903:        ext,
        -:  904:        offsetof(YR_EXTERNAL_VARIABLE, value.s),
        -:  905:        EOL));
        -:  906:  }
        -:  907:
       1*:  908:  FAIL_ON_ERROR(yr_object_from_external_variable(
        -:  909:      external,
        -:  910:      &object));
        -:  911:
       1*:  912:  FAIL_ON_ERROR(yr_hash_table_add(
        -:  913:      compiler->objects_table,
        -:  914:      external->identifier,
        -:  915:      NULL,
        -:  916:      (void*) object));
        -:  917:
        1:  918:  return ERROR_SUCCESS;
        -:  919:}
        -:  920:
        -:  921:
    #####:  922:YR_API int yr_compiler_define_integer_variable(
        -:  923:    YR_COMPILER* compiler,
        -:  924:    const char* identifier,
        -:  925:    int64_t value)
        -:  926:{
        -:  927:  YR_EXTERNAL_VARIABLE external;
        -:  928:
    #####:  929:  external.type = EXTERNAL_VARIABLE_TYPE_INTEGER;
    #####:  930:  external.identifier = identifier;
    #####:  931:  external.value.i = value;
        -:  932:
    #####:  933:  FAIL_ON_ERROR(_yr_compiler_define_variable(
        -:  934:      compiler, &external));
        -:  935:
    #####:  936:  return ERROR_SUCCESS;
        -:  937:}
        -:  938:
        -:  939:
        1:  940:YR_API int yr_compiler_define_boolean_variable(
        -:  941:    YR_COMPILER* compiler,
        -:  942:    const char* identifier,
        -:  943:    int value)
        -:  944:{
        -:  945:  YR_EXTERNAL_VARIABLE external;
        -:  946:
        1:  947:  external.type = EXTERNAL_VARIABLE_TYPE_BOOLEAN;
        1:  948:  external.identifier = identifier;
        1:  949:  external.value.i = value;
        -:  950:
       1*:  951:  FAIL_ON_ERROR(_yr_compiler_define_variable(
        -:  952:      compiler, &external));
        -:  953:
        1:  954:  return ERROR_SUCCESS;
        -:  955:}
        -:  956:
        -:  957:
    #####:  958:YR_API int yr_compiler_define_float_variable(
        -:  959:    YR_COMPILER* compiler,
        -:  960:    const char* identifier,
        -:  961:    double value)
        -:  962:{
        -:  963:  YR_EXTERNAL_VARIABLE external;
        -:  964:
    #####:  965:  external.type = EXTERNAL_VARIABLE_TYPE_FLOAT;
    #####:  966:  external.identifier = identifier;
    #####:  967:  external.value.f = value;
        -:  968:
    #####:  969:  FAIL_ON_ERROR(_yr_compiler_define_variable(
        -:  970:      compiler, &external));
        -:  971:
    #####:  972:  return ERROR_SUCCESS;
        -:  973:}
        -:  974:
        -:  975:
    #####:  976:YR_API int yr_compiler_define_string_variable(
        -:  977:    YR_COMPILER* compiler,
        -:  978:    const char* identifier,
        -:  979:    const char* value)
        -:  980:{
        -:  981:  YR_EXTERNAL_VARIABLE external;
        -:  982:
    #####:  983:  external.type = EXTERNAL_VARIABLE_TYPE_STRING;
    #####:  984:  external.identifier = identifier;
    #####:  985:  external.value.s = (char*) value;
        -:  986:
    #####:  987:  FAIL_ON_ERROR(_yr_compiler_define_variable(
        -:  988:      compiler, &external));
        -:  989:
    #####:  990:  return ERROR_SUCCESS;
        -:  991:}
        -:  992:
        -:  993:
    #####:  994:YR_API char* yr_compiler_get_error_message(
        -:  995:    YR_COMPILER* compiler,
        -:  996:    char* buffer,
        -:  997:    int buffer_size)
        -:  998:{
        -:  999:  uint32_t max_strings_per_rule;
        -: 1000:
    #####: 1001:  switch(compiler->last_error)
        -: 1002:  {
    #####: 1003:    case ERROR_INSUFFICIENT_MEMORY:
    #####: 1004:      snprintf(buffer, buffer_size, "not enough memory");
    #####: 1005:      break;
    #####: 1006:    case ERROR_DUPLICATED_IDENTIFIER:
    #####: 1007:      snprintf(
        -: 1008:          buffer,
        -: 1009:          buffer_size,
        -: 1010:          "duplicated identifier \"%s\"",
    #####: 1011:          compiler->last_error_extra_info);
    #####: 1012:      break;
    #####: 1013:    case ERROR_DUPLICATED_STRING_IDENTIFIER:
    #####: 1014:      snprintf(
        -: 1015:          buffer,
        -: 1016:          buffer_size,
        -: 1017:          "duplicated string identifier \"%s\"",
    #####: 1018:          compiler->last_error_extra_info);
    #####: 1019:      break;
    #####: 1020:    case ERROR_DUPLICATED_TAG_IDENTIFIER:
    #####: 1021:      snprintf(
        -: 1022:          buffer,
        -: 1023:          buffer_size,
        -: 1024:          "duplicated tag identifier \"%s\"",
    #####: 1025:          compiler->last_error_extra_info);
    #####: 1026:      break;
    #####: 1027:    case ERROR_DUPLICATED_META_IDENTIFIER:
    #####: 1028:      snprintf(
        -: 1029:          buffer,
        -: 1030:          buffer_size,
        -: 1031:          "duplicated metadata identifier \"%s\"",
    #####: 1032:          compiler->last_error_extra_info);
    #####: 1033:      break;
    #####: 1034:    case ERROR_DUPLICATED_LOOP_IDENTIFIER:
    #####: 1035:      snprintf(
        -: 1036:          buffer,
        -: 1037:          buffer_size,
        -: 1038:          "duplicated loop identifier \"%s\"",
    #####: 1039:          compiler->last_error_extra_info);
    #####: 1040:      break;
    #####: 1041:    case ERROR_UNDEFINED_STRING:
    #####: 1042:      snprintf(
        -: 1043:          buffer,
        -: 1044:          buffer_size,
        -: 1045:          "undefined string \"%s\"",
    #####: 1046:          compiler->last_error_extra_info);
    #####: 1047:      break;
    #####: 1048:    case ERROR_UNDEFINED_IDENTIFIER:
    #####: 1049:      snprintf(
        -: 1050:          buffer,
        -: 1051:          buffer_size,
        -: 1052:          "undefined identifier \"%s\"",
    #####: 1053:          compiler->last_error_extra_info);
    #####: 1054:      break;
    #####: 1055:    case ERROR_UNREFERENCED_STRING:
    #####: 1056:      snprintf(
        -: 1057:          buffer,
        -: 1058:          buffer_size,
        -: 1059:          "unreferenced string \"%s\"",
    #####: 1060:          compiler->last_error_extra_info);
    #####: 1061:      break;
    #####: 1062:    case ERROR_EMPTY_STRING:
    #####: 1063:      snprintf(
        -: 1064:          buffer,
        -: 1065:          buffer_size,
        -: 1066:          "empty string \"%s\"",
    #####: 1067:          compiler->last_error_extra_info);
    #####: 1068:      break;
    #####: 1069:    case ERROR_NOT_A_STRUCTURE:
    #####: 1070:      snprintf(
        -: 1071:          buffer,
        -: 1072:          buffer_size,
        -: 1073:          "\"%s\" is not a structure",
    #####: 1074:          compiler->last_error_extra_info);
    #####: 1075:      break;
    #####: 1076:    case ERROR_NOT_INDEXABLE:
    #####: 1077:      snprintf(
        -: 1078:          buffer,
        -: 1079:          buffer_size,
        -: 1080:          "\"%s\" is not an array or dictionary",
    #####: 1081:          compiler->last_error_extra_info);
    #####: 1082:      break;
    #####: 1083:    case ERROR_NOT_A_FUNCTION:
    #####: 1084:      snprintf(
        -: 1085:          buffer,
        -: 1086:          buffer_size,
        -: 1087:          "\"%s\" is not a function",
    #####: 1088:          compiler->last_error_extra_info);
    #####: 1089:      break;
    #####: 1090:    case ERROR_INVALID_FIELD_NAME:
    #####: 1091:      snprintf(
        -: 1092:          buffer,
        -: 1093:          buffer_size,
        -: 1094:          "invalid field name \"%s\"",
    #####: 1095:          compiler->last_error_extra_info);
    #####: 1096:      break;
    #####: 1097:    case ERROR_MISPLACED_ANONYMOUS_STRING:
    #####: 1098:      snprintf(
        -: 1099:          buffer,
        -: 1100:          buffer_size,
        -: 1101:          "wrong use of anonymous string");
    #####: 1102:      break;
    #####: 1103:    case ERROR_INCLUDES_CIRCULAR_REFERENCE:
    #####: 1104:      snprintf(
        -: 1105:          buffer,
        -: 1106:          buffer_size,
        -: 1107:          "include circular reference");
    #####: 1108:      break;
    #####: 1109:    case ERROR_INCLUDE_DEPTH_EXCEEDED:
    #####: 1110:      snprintf(buffer,
        -: 1111:          buffer_size,
        -: 1112:          "too many levels of included rules");
    #####: 1113:      break;
    #####: 1114:    case ERROR_LOOP_NESTING_LIMIT_EXCEEDED:
    #####: 1115:      snprintf(buffer,
        -: 1116:          buffer_size,
        -: 1117:          "loop nesting limit exceeded");
    #####: 1118:      break;
    #####: 1119:    case ERROR_NESTED_FOR_OF_LOOP:
    #####: 1120:      snprintf(buffer,
        -: 1121:          buffer_size,
        -: 1122:          "'for <quantifier> of <string set>' loops can't be nested");
    #####: 1123:      break;
    #####: 1124:    case ERROR_UNKNOWN_MODULE:
    #####: 1125:      snprintf(
        -: 1126:          buffer,
        -: 1127:          buffer_size,
        -: 1128:          "unknown module \"%s\"",
    #####: 1129:          compiler->last_error_extra_info);
    #####: 1130:      break;
    #####: 1131:    case ERROR_INVALID_MODULE_NAME:
    #####: 1132:      snprintf(
        -: 1133:          buffer,
        -: 1134:          buffer_size,
        -: 1135:          "invalid module name \"%s\"",
    #####: 1136:          compiler->last_error_extra_info);
    #####: 1137:      break;
    #####: 1138:    case ERROR_DUPLICATED_STRUCTURE_MEMBER:
    #####: 1139:      snprintf(buffer,
        -: 1140:          buffer_size,
        -: 1141:          "duplicated structure member");
    #####: 1142:      break;
    #####: 1143:    case ERROR_WRONG_ARGUMENTS:
    #####: 1144:      snprintf(
        -: 1145:          buffer,
        -: 1146:          buffer_size,
        -: 1147:          "wrong arguments for function \"%s\"",
    #####: 1148:          compiler->last_error_extra_info);
    #####: 1149:      break;
    #####: 1150:    case ERROR_WRONG_RETURN_TYPE:
    #####: 1151:      snprintf(buffer,
        -: 1152:          buffer_size,
        -: 1153:          "wrong return type for overloaded function");
    #####: 1154:      break;
    #####: 1155:    case ERROR_INVALID_HEX_STRING:
        -: 1156:    case ERROR_INVALID_REGULAR_EXPRESSION:
        -: 1157:    case ERROR_SYNTAX_ERROR:
        -: 1158:    case ERROR_WRONG_TYPE:
    #####: 1159:      snprintf(
        -: 1160:          buffer,
        -: 1161:          buffer_size,
        -: 1162:          "%s",
    #####: 1163:          compiler->last_error_extra_info);
    #####: 1164:      break;
    #####: 1165:    case ERROR_INTERNAL_FATAL_ERROR:
    #####: 1166:      snprintf(
        -: 1167:          buffer,
        -: 1168:          buffer_size,
        -: 1169:          "internal fatal error");
    #####: 1170:      break;
    #####: 1171:    case ERROR_DIVISION_BY_ZERO:
    #####: 1172:      snprintf(
        -: 1173:          buffer,
        -: 1174:          buffer_size,
        -: 1175:          "division by zero");
    #####: 1176:      break;
    #####: 1177:    case ERROR_REGULAR_EXPRESSION_TOO_LARGE:
    #####: 1178:      snprintf(
        -: 1179:          buffer,
        -: 1180:          buffer_size,
        -: 1181:          "regular expression is too large");
    #####: 1182:      break;
    #####: 1183:    case ERROR_REGULAR_EXPRESSION_TOO_COMPLEX:
    #####: 1184:      snprintf(
        -: 1185:          buffer,
        -: 1186:          buffer_size,
        -: 1187:          "regular expression is too complex");
    #####: 1188:      break;
    #####: 1189:    case ERROR_TOO_MANY_STRINGS:
    #####: 1190:       yr_get_configuration(
        -: 1191:          YR_CONFIG_MAX_STRINGS_PER_RULE,
        -: 1192:          &max_strings_per_rule);
    #####: 1193:       snprintf(
        -: 1194:          buffer,
        -: 1195:          buffer_size,
        -: 1196:          "too many strings in rule \"%s\" (limit: %d)",
    #####: 1197:          compiler->last_error_extra_info,
        -: 1198:          max_strings_per_rule);
    #####: 1199:      break;
    #####: 1200:    case ERROR_INTEGER_OVERFLOW:
    #####: 1201:      snprintf(
        -: 1202:          buffer,
        -: 1203:          buffer_size,
        -: 1204:          "integer overflow in \"%s\"",
    #####: 1205:          compiler->last_error_extra_info);
    #####: 1206:      break;
    #####: 1207:    case ERROR_COULD_NOT_READ_FILE:
    #####: 1208:      snprintf(
        -: 1209:          buffer,
        -: 1210:          buffer_size,
        -: 1211:          "could not read file");
    #####: 1212:      break;
        -: 1213:  }
        -: 1214:
    #####: 1215:  return buffer;
        -: 1216:}
