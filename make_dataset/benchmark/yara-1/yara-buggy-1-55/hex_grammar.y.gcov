        -:    0:Source:hex_grammar.y
        -:    0:Graph:/home/workspace/libyara/hex_grammar.gcno
        -:    0:Data:/home/workspace/libyara/hex_grammar.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:%{
        -:   31:
        -:   32:#include <string.h>
        -:   33:#include <limits.h>
        -:   34:#include <stdbool.h>
        -:   35:
        -:   36:#include <yara/integers.h>
        -:   37:#include <yara/utils.h>
        -:   38:#include <yara/hex_lexer.h>
        -:   39:#include <yara/limits.h>
        -:   40:#include <yara/mem.h>
        -:   41:#include <yara/error.h>
        -:   42:
        -:   43:
        -:   44:#define STR_EXPAND(tok) #tok
        -:   45:#define STR(tok) STR_EXPAND(tok)
        -:   46:
        -:   47:#define YYERROR_VERBOSE
        -:   48:
        -:   49:#define YYMALLOC yr_malloc
        -:   50:#define YYFREE yr_free
        -:   51:
        -:   52:#define mark_as_not_fast_regexp() \
        -:   53:    ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP
        -:   54:
        -:   55:#define fail_if_too_many_ast_levels(cleanup_code) \
        -:   56:    if (((RE_AST*) yyget_extra(yyscanner))->levels++ > RE_MAX_AST_LEVELS) \
        -:   57:    { \
        -:   58:      { cleanup_code } \
        -:   59:      yyerror(yyscanner, lex_env, "string too long"); \
        -:   60:      YYABORT; \
        -:   61:    }
        -:   62:
        -:   63:#define fail_if(x, error) \
        -:   64:    if (x) \
        -:   65:    { \
        -:   66:      lex_env->last_error = error; \
        -:   67:      YYABORT; \
        -:   68:    } \
        -:   69:
        -:   70:#define destroy_node_if(x, node) \
        -:   71:    if (x) \
        -:   72:    { \
        -:   73:      yr_re_node_destroy(node); \
        -:   74:    } \
        -:   75:
        -:   76:%}
        -:   77:
        -:   78:%name-prefix "hex_yy"
        -:   79:%pure-parser
        -:   80:
        -:   81:%parse-param {void *yyscanner}
        -:   82:%parse-param {HEX_LEX_ENVIRONMENT *lex_env}
        -:   83:
        -:   84:%lex-param {yyscan_t yyscanner}
        -:   85:%lex-param {HEX_LEX_ENVIRONMENT *lex_env}
        -:   86:
        -:   87:%union {
        -:   88:  int64_t integer;
        -:   89:  RE_NODE *re_node;
        -:   90:}
        -:   91:
        -:   92:%token <integer> _BYTE_
        -:   93:%token <integer> _MASKED_BYTE_
        -:   94:%token <integer> _NUMBER_
        -:   95:
        -:   96:%type <re_node> tokens
        -:   97:%type <re_node> token_sequence
        -:   98:%type <re_node> token_or_range
        -:   99:%type <re_node> token byte
        -:  100:%type <re_node> alternatives
        -:  101:%type <re_node> range
        -:  102:
    #####:  103:%destructor { yr_re_node_destroy($$); $$ = NULL; } tokens
    #####:  104:%destructor { yr_re_node_destroy($$); $$ = NULL; } token_sequence
    #####:  105:%destructor { yr_re_node_destroy($$); $$ = NULL; } token_or_range
    #####:  106:%destructor { yr_re_node_destroy($$); $$ = NULL; } token
    #####:  107:%destructor { yr_re_node_destroy($$); $$ = NULL; } byte
    #####:  108:%destructor { yr_re_node_destroy($$); $$ = NULL; } alternatives
    #####:  109:%destructor { yr_re_node_destroy($$); $$ = NULL; } range
        -:  110:
        -:  111:%%
        -:  112:
        -:  113:hex_string
        -:  114:    : '{' tokens '}'
        -:  115:      {
    #####:  116:        RE_AST* re_ast = yyget_extra(yyscanner);
    #####:  117:        re_ast->root_node = $2;
        -:  118:      }
        -:  119:    ;
        -:  120:
        -:  121:
        -:  122:tokens
        -:  123:    : token
        -:  124:      {
    #####:  125:        $$ = $1;
        -:  126:      }
        -:  127:    | token token
        -:  128:      {
    #####:  129:        fail_if_too_many_ast_levels({
        -:  130:          yr_re_node_destroy($1);
        -:  131:          yr_re_node_destroy($2);
        -:  132:        });
        -:  133:
    #####:  134:        $$ = yr_re_node_create(RE_NODE_CONCAT, $1, $2);
        -:  135:
    #####:  136:        destroy_node_if($$ == NULL, $1);
    #####:  137:        destroy_node_if($$ == NULL, $2);
        -:  138:
    #####:  139:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  140:      }
        -:  141:    | token token_sequence token
        -:  142:      {
        -:  143:        RE_NODE* new_concat;
    #####:  144:        RE_NODE* leftmost_concat = NULL;
    #####:  145:        RE_NODE* leftmost_node = $2;
        -:  146:
    #####:  147:        fail_if_too_many_ast_levels({
        -:  148:          yr_re_node_destroy($1);
        -:  149:          yr_re_node_destroy($2);
        -:  150:          yr_re_node_destroy($3);
        -:  151:        });
        -:  152:
    #####:  153:        $$ = NULL;
        -:  154:
        -:  155:        /*
        -:  156:        Some portions of the code (i.e: yr_re_split_at_chaining_point)
        -:  157:        expect a left-unbalanced tree where the right child of a concat node
        -:  158:        can't be another concat node. A concat node must be always the left
        -:  159:        child of its parent if the parent is also a concat. For this reason
        -:  160:        the can't simply create two new concat nodes arranged like this:
        -:  161:
        -:  162:                concat
        -:  163:                 /   \
        -:  164:                /     \
        -:  165:            token's    \
        -:  166:            subtree  concat
        -:  167:                     /    \
        -:  168:                    /      \
        -:  169:                   /        \
        -:  170:           token_sequence's  token's
        -:  171:               subtree       subtree
        -:  172:
        -:  173:        Instead we must insert the subtree for the first token as the
        -:  174:        leftmost node of the token_sequence subtree.
        -:  175:        */
        -:  176:
    #####:  177:        while (leftmost_node->type == RE_NODE_CONCAT)
        -:  178:        {
    #####:  179:          leftmost_concat = leftmost_node;
    #####:  180:          leftmost_node = leftmost_node->left;
        -:  181:        }
        -:  182:
    #####:  183:        new_concat = yr_re_node_create(
    #####:  184:            RE_NODE_CONCAT, $1, leftmost_node);
        -:  185:
    #####:  186:        if (new_concat != NULL)
        -:  187:        {
    #####:  188:          if (leftmost_concat != NULL)
        -:  189:          {
    #####:  190:            leftmost_concat->left = new_concat;
    #####:  191:            $$ = yr_re_node_create(RE_NODE_CONCAT, $2, $3);
        -:  192:          }
        -:  193:          else
        -:  194:          {
    #####:  195:            $$ = yr_re_node_create(RE_NODE_CONCAT, new_concat, $3);
        -:  196:          }
        -:  197:        }
        -:  198:
    #####:  199:        destroy_node_if($$ == NULL, $1);
    #####:  200:        destroy_node_if($$ == NULL, $2);
    #####:  201:        destroy_node_if($$ == NULL, $3);
        -:  202:
    #####:  203:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  204:      }
        -:  205:    ;
        -:  206:
        -:  207:
        -:  208:token_sequence
        -:  209:    : token_or_range
        -:  210:      {
    #####:  211:        $$ = $1;
        -:  212:      }
        -:  213:    | token_sequence token_or_range
        -:  214:      {
    #####:  215:        fail_if_too_many_ast_levels({
        -:  216:          yr_re_node_destroy($1);
        -:  217:          yr_re_node_destroy($2);
        -:  218:        });
        -:  219:
    #####:  220:        $$ = yr_re_node_create(RE_NODE_CONCAT, $1, $2);
        -:  221:
    #####:  222:        destroy_node_if($$ == NULL, $1);
    #####:  223:        destroy_node_if($$ == NULL, $2);
        -:  224:
    #####:  225:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  226:      }
        -:  227:    ;
        -:  228:
        -:  229:
        -:  230:token_or_range
        -:  231:    : token
        -:  232:      {
    #####:  233:        $$ = $1;
        -:  234:      }
        -:  235:    |  range
        -:  236:      {
    #####:  237:        $$ = $1;
    #####:  238:        $$->greedy = false;
        -:  239:      }
        -:  240:    ;
        -:  241:
        -:  242:
        -:  243:token
        -:  244:    : byte
        -:  245:      {
    #####:  246:        $$ = $1;
        -:  247:      }
        -:  248:    | '('
        -:  249:      {
    #####:  250:        lex_env->inside_or++;
        -:  251:      }
        -:  252:      alternatives ')'
        -:  253:      {
    #####:  254:        $$ = $3;
    #####:  255:        lex_env->inside_or--;
        -:  256:      }
        -:  257:    ;
        -:  258:
        -:  259:
        -:  260:range
        -:  261:    : '[' _NUMBER_ ']'
        -:  262:      {
    #####:  263:        if ($2 <= 0)
        -:  264:        {
    #####:  265:          yyerror(yyscanner, lex_env, "invalid jump length");
    #####:  266:          YYABORT;
        -:  267:        }
        -:  268:
    #####:  269:        if (lex_env->inside_or && $2 > YR_STRING_CHAINING_THRESHOLD)
        -:  270:        {
    #####:  271:          yyerror(yyscanner, lex_env, "jumps over "
        -:  272:              STR(YR_STRING_CHAINING_THRESHOLD)
        -:  273:              " now allowed inside alternation (|)");
    #####:  274:          YYABORT;
        -:  275:        }
        -:  276:
    #####:  277:        $$ = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -:  278:
    #####:  279:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  280:
    #####:  281:        $$->start = (int) $2;
    #####:  282:        $$->end = (int) $2;
        -:  283:      }
        -:  284:    | '[' _NUMBER_ '-' _NUMBER_ ']'
        -:  285:      {
    #####:  286:        if (lex_env->inside_or &&
    #####:  287:            ($2 > YR_STRING_CHAINING_THRESHOLD ||
    #####:  288:             $4 > YR_STRING_CHAINING_THRESHOLD) )
        -:  289:        {
    #####:  290:          yyerror(yyscanner, lex_env, "jumps over "
        -:  291:              STR(YR_STRING_CHAINING_THRESHOLD)
        -:  292:              " now allowed inside alternation (|)");
        -:  293:
    #####:  294:          YYABORT;
        -:  295:        }
        -:  296:
    #####:  297:        if ($2 < 0 || $4 < 0)
        -:  298:        {
    #####:  299:          yyerror(yyscanner, lex_env, "invalid negative jump length");
    #####:  300:          YYABORT;
        -:  301:        }
        -:  302:
    #####:  303:        if ($2 > $4)
        -:  304:        {
    #####:  305:          yyerror(yyscanner, lex_env, "invalid jump range");
    #####:  306:          YYABORT;
        -:  307:        }
        -:  308:
    #####:  309:        $$ = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -:  310:
    #####:  311:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  312:
    #####:  313:        $$->start = (int) $2;
    #####:  314:        $$->end = (int) $4;
        -:  315:      }
        -:  316:    | '[' _NUMBER_ '-' ']'
        -:  317:      {
    #####:  318:        if (lex_env->inside_or)
        -:  319:        {
    #####:  320:          yyerror(yyscanner, lex_env,
        -:  321:              "unbounded jumps not allowed inside alternation (|)");
    #####:  322:          YYABORT;
        -:  323:        }
        -:  324:
    #####:  325:        if ($2 < 0)
        -:  326:        {
    #####:  327:          yyerror(yyscanner, lex_env, "invalid negative jump length");
    #####:  328:          YYABORT;
        -:  329:        }
        -:  330:
    #####:  331:        $$ = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -:  332:
    #####:  333:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  334:
    #####:  335:        $$->start = (int) $2;
    #####:  336:        $$->end = INT_MAX;
        -:  337:      }
        -:  338:    | '[' '-' ']'
        -:  339:      {
    #####:  340:        if (lex_env->inside_or)
        -:  341:        {
    #####:  342:          yyerror(yyscanner, lex_env,
        -:  343:              "unbounded jumps not allowed inside alternation (|)");
    #####:  344:          YYABORT;
        -:  345:        }
        -:  346:
    #####:  347:        $$ = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -:  348:
    #####:  349:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  350:
    #####:  351:        $$->start = 0;
    #####:  352:        $$->end = INT_MAX;
        -:  353:      }
        -:  354:    ;
        -:  355:
        -:  356:
        -:  357:alternatives
        -:  358:    : tokens
        -:  359:      {
    #####:  360:          $$ = $1;
        -:  361:      }
        -:  362:    | alternatives '|' tokens
        -:  363:      {
    #####:  364:        mark_as_not_fast_regexp();
        -:  365:
    #####:  366:        fail_if_too_many_ast_levels({
        -:  367:          yr_re_node_destroy($1);
        -:  368:          yr_re_node_destroy($3);
        -:  369:        });
        -:  370:
    #####:  371:        $$ = yr_re_node_create(RE_NODE_ALT, $1, $3);
        -:  372:
    #####:  373:        destroy_node_if($$ == NULL, $1);
    #####:  374:        destroy_node_if($$ == NULL, $3);
        -:  375:
    #####:  376:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  377:      }
        -:  378:    ;
        -:  379:
        -:  380:byte
        -:  381:    : _BYTE_
        -:  382:      {
    #####:  383:        $$ = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);
        -:  384:
    #####:  385:        fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  386:
    #####:  387:        $$->value = (int) $1;
        -:  388:      }
        -:  389:    | _MASKED_BYTE_
        -:  390:      {
    #####:  391:        uint8_t mask = (uint8_t) ($1 >> 8);
        -:  392:
    #####:  393:        if (mask == 0x00)
        -:  394:        {
    #####:  395:          $$ = yr_re_node_create(RE_NODE_ANY, NULL, NULL);
        -:  396:
    #####:  397:          fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  398:        }
        -:  399:        else
        -:  400:        {
    #####:  401:          $$ = yr_re_node_create(RE_NODE_MASKED_LITERAL, NULL, NULL);
        -:  402:
    #####:  403:          fail_if($$ == NULL, ERROR_INSUFFICIENT_MEMORY);
        -:  404:
    #####:  405:          $$->value = $1 & 0xFF;
    #####:  406:          $$->mask = mask;
        -:  407:        }
        -:  408:      }
        -:  409:    ;
        -:  410:
        -:  411:%%
