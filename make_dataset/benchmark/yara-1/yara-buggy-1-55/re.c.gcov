        -:    0:Source:re.c
        -:    0:Graph:/home/workspace/libyara/re.gcno
        -:    0:Data:/home/workspace/libyara/re.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:
        -:   31:/*
        -:   32:
        -:   33:This module implements a regular expressions engine based on Thompson's
        -:   34:algorithm as described by Russ Cox in http://swtch.com/~rsc/regexp/regexp2.html.
        -:   35:
        -:   36:What the article names a "thread" has been named a "fiber" in this code, in
        -:   37:order to avoid confusion with operating system threads.
        -:   38:
        -:   39:*/
        -:   40:
        -:   41:#include <assert.h>
        -:   42:#include <string.h>
        -:   43:
        -:   44:#include <yara/limits.h>
        -:   45:#include <yara/globals.h>
        -:   46:#include <yara/utils.h>
        -:   47:#include <yara/mem.h>
        -:   48:#include <yara/re.h>
        -:   49:#include <yara/error.h>
        -:   50:#include <yara/threading.h>
        -:   51:#include <yara/re_lexer.h>
        -:   52:#include <yara/hex_lexer.h>
        -:   53:
        -:   54:
        -:   55:#define EMIT_BACKWARDS                  0x01
        -:   56:#define EMIT_DONT_SET_FORWARDS_CODE     0x02
        -:   57:#define EMIT_DONT_SET_BACKWARDS_CODE    0x04
        -:   58:
        -:   59:#ifndef INT16_MAX
        -:   60:#define INT16_MAX              (32767)
        -:   61:#endif
        -:   62:
        -:   63:
        -:   64:typedef uint8_t RE_SPLIT_ID_TYPE;
        -:   65:
        -:   66:
        -:   67:typedef struct _RE_REPEAT_ARGS
        -:   68:{
        -:   69:  uint16_t  min;
        -:   70:  uint16_t  max;
        -:   71:  int32_t   offset;
        -:   72:
        -:   73:} RE_REPEAT_ARGS;
        -:   74:
        -:   75:
        -:   76:typedef struct _RE_REPEAT_ANY_ARGS
        -:   77:{
        -:   78:  uint16_t   min;
        -:   79:  uint16_t   max;
        -:   80:
        -:   81:} RE_REPEAT_ANY_ARGS;
        -:   82:
        -:   83:
        -:   84:typedef struct _RE_EMIT_CONTEXT {
        -:   85:
        -:   86:  YR_ARENA*         arena;
        -:   87:  RE_SPLIT_ID_TYPE  next_split_id;
        -:   88:
        -:   89:} RE_EMIT_CONTEXT;
        -:   90:
        -:   91:
        -:   92:#define CHAR_IN_CLASS(cls, chr)  \
        -:   93:  ((cls)[(chr) / 8] & 1 << ((chr) % 8))
        -:   94:
        -:   95:
    #####:   96:static bool _yr_re_is_char_in_class(
        -:   97:    RE_CLASS* re_class,
        -:   98:    uint8_t chr,
        -:   99:    int case_insensitive)
        -:  100:{
    #####:  101:  int result = CHAR_IN_CLASS(re_class->bitmap, chr);
        -:  102:
    #####:  103:  if (case_insensitive)
    #####:  104:    result |= CHAR_IN_CLASS(re_class->bitmap, yr_altercase[chr]);
        -:  105:
    #####:  106:  if (re_class->negated)
    #####:  107:    result = !result;
        -:  108:
    #####:  109:  return result;
        -:  110:}
        -:  111:
        -:  112:
    #####:  113:static bool _yr_re_is_word_char(
        -:  114:    const uint8_t* input,
        -:  115:    uint8_t character_size)
        -:  116:{
    #####:  117:  int result = ((isalnum(*input) || (*input) == '_'));
        -:  118:
    #####:  119:  if (character_size == 2)
    #####:  120:    result = result && (*(input + 1) == 0);
        -:  121:
    #####:  122:  return result;
        -:  123:}
        -:  124:
        -:  125:
    #####:  126:RE_NODE* yr_re_node_create(
        -:  127:    int type,
        -:  128:    RE_NODE* left,
        -:  129:    RE_NODE* right)
        -:  130:{
    #####:  131:  RE_NODE* result = (RE_NODE*) yr_malloc(sizeof(RE_NODE));
        -:  132:
    #####:  133:  if (result != NULL)
        -:  134:  {
    #####:  135:    result->type = type;
    #####:  136:    result->left = left;
    #####:  137:    result->right = right;
    #####:  138:    result->greedy = true;
    #####:  139:    result->forward_code = NULL;
    #####:  140:    result->backward_code = NULL;
        -:  141:  }
        -:  142:
    #####:  143:  return result;
        -:  144:}
        -:  145:
        -:  146:
    #####:  147:void yr_re_node_destroy(
        -:  148:    RE_NODE* node)
        -:  149:{
    #####:  150:  if (node->left != NULL)
    #####:  151:    yr_re_node_destroy(node->left);
        -:  152:
    #####:  153:  if (node->right != NULL)
    #####:  154:    yr_re_node_destroy(node->right);
        -:  155:
    #####:  156:  if (node->type == RE_NODE_CLASS)
    #####:  157:    yr_free(node->re_class);
        -:  158:
    #####:  159:  yr_free(node);
    #####:  160:}
        -:  161:
        -:  162:
    #####:  163:int yr_re_ast_create(
        -:  164:    RE_AST** re_ast)
        -:  165:{
    #####:  166:  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
        -:  167:
    #####:  168:  if (*re_ast == NULL)
    #####:  169:    return ERROR_INSUFFICIENT_MEMORY;
        -:  170:
    #####:  171:  (*re_ast)->flags = 0;
    #####:  172:  (*re_ast)->levels = 0;
    #####:  173:  (*re_ast)->root_node = NULL;
        -:  174:
    #####:  175:  return ERROR_SUCCESS;
        -:  176:}
        -:  177:
        -:  178:
    #####:  179:void yr_re_ast_destroy(
        -:  180:    RE_AST* re_ast)
        -:  181:{
    #####:  182:  if (re_ast->root_node != NULL)
    #####:  183:    yr_re_node_destroy(re_ast->root_node);
        -:  184:
    #####:  185:  yr_free(re_ast);
    #####:  186:}
        -:  187:
        -:  188:
        -:  189://
        -:  190:// yr_re_parse
        -:  191://
        -:  192:// Parses a regexp but don't emit its code. A further call to
        -:  193:// yr_re_emit_code is required to get the code.
        -:  194://
        -:  195:
    #####:  196:int yr_re_parse(
        -:  197:    const char* re_string,
        -:  198:    RE_AST** re_ast,
        -:  199:    RE_ERROR* error)
        -:  200:{
    #####:  201:  return yr_parse_re_string(re_string, re_ast, error);
        -:  202:}
        -:  203:
        -:  204:
        -:  205://
        -:  206:// yr_re_parse_hex
        -:  207://
        -:  208:// Parses a hex string but don't emit its code. A further call to
        -:  209:// yr_re_emit_code is required to get the code.
        -:  210://
        -:  211:
    #####:  212:int yr_re_parse_hex(
        -:  213:    const char* hex_string,
        -:  214:    RE_AST** re_ast,
        -:  215:    RE_ERROR* error)
        -:  216:{
    #####:  217:  return yr_parse_hex_string(hex_string, re_ast, error);
        -:  218:}
        -:  219:
        -:  220:
        -:  221://
        -:  222:// yr_re_compile
        -:  223://
        -:  224:// Parses the regexp and emit its code to the provided code_arena.
        -:  225://
        -:  226:
    #####:  227:int yr_re_compile(
        -:  228:    const char* re_string,
        -:  229:    int flags,
        -:  230:    YR_ARENA* code_arena,
        -:  231:    RE** re,
        -:  232:    RE_ERROR* error)
        -:  233:{
        -:  234:  RE_AST* re_ast;
        -:  235:  RE _re;
        -:  236:
    #####:  237:  FAIL_ON_ERROR(yr_arena_reserve_memory(
        -:  238:      code_arena, sizeof(int64_t) + RE_MAX_CODE_SIZE));
        -:  239:
    #####:  240:  FAIL_ON_ERROR(yr_re_parse(re_string, &re_ast, error));
        -:  241:
    #####:  242:  _re.flags = flags;
        -:  243:
    #####:  244:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  245:      yr_arena_write_data(
        -:  246:          code_arena,
        -:  247:          &_re,
        -:  248:          sizeof(_re),
        -:  249:          (void**) re),
        -:  250:      yr_re_ast_destroy(re_ast));
        -:  251:
    #####:  252:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  253:      yr_re_ast_emit_code(re_ast, code_arena, false),
        -:  254:      yr_re_ast_destroy(re_ast));
        -:  255:
    #####:  256:  yr_re_ast_destroy(re_ast);
        -:  257:
    #####:  258:  return ERROR_SUCCESS;
        -:  259:}
        -:  260:
        -:  261:
        -:  262://
        -:  263:// yr_re_match
        -:  264://
        -:  265:// Verifies if the target string matches the pattern
        -:  266://
        -:  267:// Args:
        -:  268://    YR_SCAN_CONTEXT* context  - Scan context
        -:  269://    RE* re                    -  A pointer to a compiled regexp
        -:  270://    char* target              -  Target string
        -:  271://
        -:  272:// Returns:
        -:  273://    See return codes for yr_re_exec
        -:  274:
        -:  275:
    #####:  276:int yr_re_match(
        -:  277:    YR_SCAN_CONTEXT* context,
        -:  278:    RE* re,
        -:  279:    const char* target)
        -:  280:{
        -:  281:  int result;
        -:  282:
    #####:  283:  yr_re_exec(
        -:  284:      context,
    #####:  285:      re->code,
        -:  286:      (uint8_t*) target,
        -:  287:      strlen(target),
        -:  288:      0,
    #####:  289:      re->flags | RE_FLAGS_SCAN,
        -:  290:      NULL,
        -:  291:      NULL,
        -:  292:      &result);
        -:  293:
    #####:  294:  return result;
        -:  295:}
        -:  296:
        -:  297:
        -:  298://
        -:  299:// yr_re_ast_extract_literal
        -:  300://
        -:  301:// Verifies if the provided regular expression is just a literal string
        -:  302:// like "abc", "12345", without any wildcard, operator, etc. In that case
        -:  303:// returns the string as a SIZED_STRING, or returns NULL if otherwise.
        -:  304://
        -:  305:// The caller is responsible for deallocating the returned SIZED_STRING by
        -:  306:// calling yr_free.
        -:  307://
        -:  308:
    #####:  309:SIZED_STRING* yr_re_ast_extract_literal(
        -:  310:    RE_AST* re_ast)
        -:  311:{
        -:  312:  SIZED_STRING* string;
    #####:  313:  RE_NODE* node = re_ast->root_node;
        -:  314:
    #####:  315:  int i, length = 0;
        -:  316:
    #####:  317:  while (node != NULL)
        -:  318:  {
    #####:  319:    length++;
        -:  320:
    #####:  321:    if (node->type == RE_NODE_LITERAL)
    #####:  322:      break;
        -:  323:
    #####:  324:    if (node->type != RE_NODE_CONCAT)
    #####:  325:      return NULL;
        -:  326:
    #####:  327:    if (node->right == NULL ||
    #####:  328:        node->right->type != RE_NODE_LITERAL)
    #####:  329:      return NULL;
        -:  330:
    #####:  331:    node = node->left;
        -:  332:  }
        -:  333:
    #####:  334:  string = (SIZED_STRING*) yr_malloc(sizeof(SIZED_STRING) + length);
        -:  335:
    #####:  336:  if (string == NULL)
    #####:  337:    return NULL;
        -:  338:
    #####:  339:  string->length = length;
    #####:  340:  node = re_ast->root_node;
        -:  341:
        -:  342:  // The root node is the end of the string. So let's fill it up backwards.
    #####:  343:  for (i = length - 1; i > 0; i--)
        -:  344:  {
    #####:  345:    string->c_string[i] = node->right->value;
    #####:  346:    node = node->left;
        -:  347:  }
        -:  348:
    #####:  349:  if (length > 0)
    #####:  350:    string->c_string[0] = node->value;
        -:  351:
    #####:  352:  assert(node == NULL || node->type == RE_NODE_LITERAL);
        -:  353:
    #####:  354:  return string;
        -:  355:}
        -:  356:
        -:  357:
    #####:  358:int _yr_re_node_contains_dot_star(
        -:  359:    RE_NODE* re_node)
        -:  360:{
    #####:  361:  if ((re_node->type == RE_NODE_STAR || re_node->type == RE_NODE_PLUS) &&
    #####:  362:      re_node->left->type == RE_NODE_ANY)
    #####:  363:    return true;
        -:  364:
    #####:  365:  if (re_node->left != NULL && _yr_re_node_contains_dot_star(re_node->left))
    #####:  366:    return true;
        -:  367:
    #####:  368:  if (re_node->right != NULL && _yr_re_node_contains_dot_star(re_node->right))
    #####:  369:    return true;
        -:  370:
    #####:  371:  return false;
        -:  372:}
        -:  373:
        -:  374:
    #####:  375:int yr_re_ast_contains_dot_star(
        -:  376:    RE_AST* re_ast)
        -:  377:{
    #####:  378:  return _yr_re_node_contains_dot_star(re_ast->root_node);
        -:  379:}
        -:  380:
        -:  381:
        -:  382://
        -:  383:// yr_re_ast_split_at_chaining_point
        -:  384://
        -:  385:// In some cases splitting a regular expression in two is more efficient that
        -:  386:// having a single regular expression. This happens when the regular expression
        -:  387:// contains a large repetition of any character, for example: /foo.{0,1000}bar/
        -:  388:// In this case the regexp is split in /foo/ and /bar/ where /bar/ is "chained"
        -:  389:// to /foo/. This means that /foo/ and /bar/ are handled as individual regexps
        -:  390:// and when both matches YARA verifies if the distance between the matches
        -:  391:// complies with the {0,1000} restriction.
        -:  392:
        -:  393:// This function traverses the regexp's tree looking for nodes where the regxp
        -:  394:// should be split. It expects a left-unbalanced tree where the right child of
        -:  395:// a RE_NODE_CONCAT can't be another RE_NODE_CONCAT. A RE_NODE_CONCAT must be
        -:  396:// always the left child of its parent if the parent is also a RE_NODE_CONCAT.
        -:  397://
        -:  398:
    #####:  399:int yr_re_ast_split_at_chaining_point(
        -:  400:    RE_AST* re_ast,
        -:  401:    RE_AST** result_re_ast,
        -:  402:    RE_AST** remainder_re_ast,
        -:  403:    int32_t* min_gap,
        -:  404:    int32_t* max_gap)
        -:  405:{
    #####:  406:  RE_NODE* node = re_ast->root_node;
    #####:  407:  RE_NODE* child = re_ast->root_node->left;
    #####:  408:  RE_NODE* parent = NULL;
        -:  409:
        -:  410:  int result;
        -:  411:
    #####:  412:  *result_re_ast = re_ast;
    #####:  413:  *remainder_re_ast = NULL;
    #####:  414:  *min_gap = 0;
    #####:  415:  *max_gap = 0;
        -:  416:
    #####:  417:  while (child != NULL && child->type == RE_NODE_CONCAT)
        -:  418:  {
    #####:  419:    if (child->right != NULL &&
    #####:  420:        child->right->type == RE_NODE_RANGE_ANY &&
    #####:  421:        child->right->greedy == false &&
    #####:  422:        (child->right->start > YR_STRING_CHAINING_THRESHOLD ||
    #####:  423:         child->right->end > YR_STRING_CHAINING_THRESHOLD))
        -:  424:    {
    #####:  425:      result = yr_re_ast_create(remainder_re_ast);
        -:  426:
    #####:  427:      if (result != ERROR_SUCCESS)
    #####:  428:        return result;
        -:  429:
    #####:  430:      (*remainder_re_ast)->root_node = child->left;
    #####:  431:      (*remainder_re_ast)->flags = re_ast->flags;
        -:  432:
    #####:  433:      child->left = NULL;
        -:  434:
    #####:  435:      if (parent != NULL)
    #####:  436:        parent->left = node->right;
        -:  437:      else
    #####:  438:        (*result_re_ast)->root_node = node->right;
        -:  439:
    #####:  440:      node->right = NULL;
        -:  441:
    #####:  442:      *min_gap = child->right->start;
    #####:  443:      *max_gap = child->right->end;
        -:  444:
    #####:  445:      yr_re_node_destroy(node);
        -:  446:
    #####:  447:      return ERROR_SUCCESS;
        -:  448:    }
        -:  449:
    #####:  450:    parent = node;
    #####:  451:    node = child;
    #####:  452:    child = child->left;
        -:  453:  }
        -:  454:
    #####:  455:  return ERROR_SUCCESS;
        -:  456:}
        -:  457:
        -:  458:
    #####:  459:int _yr_emit_inst(
        -:  460:    RE_EMIT_CONTEXT* emit_context,
        -:  461:    uint8_t opcode,
        -:  462:    uint8_t** instruction_addr,
        -:  463:    size_t* code_size)
        -:  464:{
    #####:  465:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  466:      emit_context->arena,
        -:  467:      &opcode,
        -:  468:      sizeof(uint8_t),
        -:  469:      (void**) instruction_addr));
        -:  470:
    #####:  471:  *code_size = sizeof(uint8_t);
        -:  472:
    #####:  473:  return ERROR_SUCCESS;
        -:  474:}
        -:  475:
        -:  476:
    #####:  477:int _yr_emit_inst_arg_uint8(
        -:  478:    RE_EMIT_CONTEXT* emit_context,
        -:  479:    uint8_t opcode,
        -:  480:    uint8_t argument,
        -:  481:    uint8_t** instruction_addr,
        -:  482:    uint8_t** argument_addr,
        -:  483:    size_t* code_size)
        -:  484:{
    #####:  485:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  486:      emit_context->arena,
        -:  487:      &opcode,
        -:  488:      sizeof(uint8_t),
        -:  489:      (void**) instruction_addr));
        -:  490:
    #####:  491:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  492:      emit_context->arena,
        -:  493:      &argument,
        -:  494:      sizeof(uint8_t),
        -:  495:      (void**) argument_addr));
        -:  496:
    #####:  497:  *code_size = 2 * sizeof(uint8_t);
        -:  498:
    #####:  499:  return ERROR_SUCCESS;
        -:  500:}
        -:  501:
        -:  502:
    #####:  503:int _yr_emit_inst_arg_uint16(
        -:  504:    RE_EMIT_CONTEXT* emit_context,
        -:  505:    uint8_t opcode,
        -:  506:    uint16_t argument,
        -:  507:    uint8_t** instruction_addr,
        -:  508:    uint16_t** argument_addr,
        -:  509:    size_t* code_size)
        -:  510:{
    #####:  511:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  512:      emit_context->arena,
        -:  513:      &opcode,
        -:  514:      sizeof(uint8_t),
        -:  515:      (void**) instruction_addr));
        -:  516:
    #####:  517:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  518:      emit_context->arena,
        -:  519:      &argument,
        -:  520:      sizeof(uint16_t),
        -:  521:      (void**) argument_addr));
        -:  522:
    #####:  523:  *code_size = sizeof(uint8_t) + sizeof(uint16_t);
        -:  524:
    #####:  525:  return ERROR_SUCCESS;
        -:  526:}
        -:  527:
        -:  528:
    #####:  529:int _yr_emit_inst_arg_uint32(
        -:  530:    RE_EMIT_CONTEXT* emit_context,
        -:  531:    uint8_t opcode,
        -:  532:    uint32_t argument,
        -:  533:    uint8_t** instruction_addr,
        -:  534:    uint32_t** argument_addr,
        -:  535:    size_t* code_size)
        -:  536:{
    #####:  537:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  538:      emit_context->arena,
        -:  539:      &opcode,
        -:  540:      sizeof(uint8_t),
        -:  541:      (void**) instruction_addr));
        -:  542:
    #####:  543:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  544:      emit_context->arena,
        -:  545:      &argument,
        -:  546:      sizeof(uint32_t),
        -:  547:      (void**) argument_addr));
        -:  548:
    #####:  549:  *code_size = sizeof(uint8_t) + sizeof(uint32_t);
        -:  550:
    #####:  551:  return ERROR_SUCCESS;
        -:  552:}
        -:  553:
        -:  554:
    #####:  555:int _yr_emit_inst_arg_int16(
        -:  556:    RE_EMIT_CONTEXT* emit_context,
        -:  557:    uint8_t opcode,
        -:  558:    int16_t argument,
        -:  559:    uint8_t** instruction_addr,
        -:  560:    int16_t** argument_addr,
        -:  561:    size_t* code_size)
        -:  562:{
    #####:  563:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  564:      emit_context->arena,
        -:  565:      &opcode,
        -:  566:      sizeof(uint8_t),
        -:  567:      (void**) instruction_addr));
        -:  568:
    #####:  569:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  570:      emit_context->arena,
        -:  571:      &argument,
        -:  572:      sizeof(int16_t),
        -:  573:      (void**) argument_addr));
        -:  574:
    #####:  575:  *code_size = sizeof(uint8_t) + sizeof(int16_t);
        -:  576:
    #####:  577:  return ERROR_SUCCESS;
        -:  578:}
        -:  579:
        -:  580:
    #####:  581:int _yr_emit_inst_arg_struct(
        -:  582:    RE_EMIT_CONTEXT* emit_context,
        -:  583:    uint8_t opcode,
        -:  584:    void* structure,
        -:  585:    size_t structure_size,
        -:  586:    uint8_t** instruction_addr,
        -:  587:    void** argument_addr,
        -:  588:    size_t* code_size)
        -:  589:{
    #####:  590:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  591:      emit_context->arena,
        -:  592:      &opcode,
        -:  593:      sizeof(uint8_t),
        -:  594:      (void**) instruction_addr));
        -:  595:
    #####:  596:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  597:      emit_context->arena,
        -:  598:      structure,
        -:  599:      structure_size,
        -:  600:      (void**) argument_addr));
        -:  601:
    #####:  602:  *code_size = sizeof(uint8_t) + structure_size;
        -:  603:
    #####:  604:  return ERROR_SUCCESS;
        -:  605:}
        -:  606:
        -:  607:
    #####:  608:int _yr_emit_split(
        -:  609:    RE_EMIT_CONTEXT* emit_context,
        -:  610:    uint8_t opcode,
        -:  611:    int16_t argument,
        -:  612:    uint8_t** instruction_addr,
        -:  613:    int16_t** argument_addr,
        -:  614:    size_t* code_size)
        -:  615:{
    #####:  616:  assert(opcode == RE_OPCODE_SPLIT_A || opcode == RE_OPCODE_SPLIT_B);
        -:  617:
    #####:  618:  if (emit_context->next_split_id == RE_MAX_SPLIT_ID)
    #####:  619:    return ERROR_REGULAR_EXPRESSION_TOO_COMPLEX;
        -:  620:
    #####:  621:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  622:      emit_context->arena,
        -:  623:      &opcode,
        -:  624:      sizeof(uint8_t),
        -:  625:      (void**) instruction_addr));
        -:  626:
    #####:  627:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  628:      emit_context->arena,
        -:  629:      &emit_context->next_split_id,
        -:  630:      sizeof(RE_SPLIT_ID_TYPE),
        -:  631:      NULL));
        -:  632:
    #####:  633:  emit_context->next_split_id++;
        -:  634:
    #####:  635:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  636:      emit_context->arena,
        -:  637:      &argument,
        -:  638:      sizeof(int16_t),
        -:  639:      (void**) argument_addr));
        -:  640:
    #####:  641:  *code_size = sizeof(uint8_t) + sizeof(RE_SPLIT_ID_TYPE) + sizeof(int16_t);
        -:  642:
    #####:  643:  return ERROR_SUCCESS;
        -:  644:}
        -:  645:
        -:  646:
    #####:  647:static int _yr_re_emit(
        -:  648:    RE_EMIT_CONTEXT* emit_context,
        -:  649:    RE_NODE* re_node,
        -:  650:    int flags,
        -:  651:    uint8_t** code_addr,
        -:  652:    size_t* code_size)
        -:  653:{
        -:  654:  size_t branch_size;
        -:  655:  size_t split_size;
        -:  656:  size_t inst_size;
        -:  657:  size_t jmp_size;
        -:  658:
        -:  659:  bool emit_split;
        -:  660:  bool emit_repeat;
        -:  661:  bool emit_prolog;
        -:  662:  bool emit_epilog;
        -:  663:
        -:  664:  RE_REPEAT_ARGS repeat_args;
        -:  665:  RE_REPEAT_ARGS* repeat_start_args_addr;
        -:  666:  RE_REPEAT_ANY_ARGS repeat_any_args;
        -:  667:
        -:  668:  RE_NODE* left;
        -:  669:  RE_NODE* right;
        -:  670:
    #####:  671:  int16_t* split_offset_addr = NULL;
    #####:  672:  int16_t* jmp_offset_addr = NULL;
    #####:  673:  uint8_t* instruction_addr = NULL;
        -:  674:
    #####:  675:  *code_size = 0;
        -:  676:
    #####:  677:  switch(re_node->type)
        -:  678:  {
    #####:  679:  case RE_NODE_LITERAL:
        -:  680:
    #####:  681:    FAIL_ON_ERROR(_yr_emit_inst_arg_uint8(
        -:  682:        emit_context,
        -:  683:        RE_OPCODE_LITERAL,
        -:  684:        re_node->value,
        -:  685:        &instruction_addr,
        -:  686:        NULL,
        -:  687:        code_size));
    #####:  688:    break;
        -:  689:
    #####:  690:  case RE_NODE_MASKED_LITERAL:
        -:  691:
    #####:  692:    FAIL_ON_ERROR(_yr_emit_inst_arg_uint16(
        -:  693:        emit_context,
        -:  694:        RE_OPCODE_MASKED_LITERAL,
        -:  695:        re_node->mask << 8 | re_node->value,
        -:  696:        &instruction_addr,
        -:  697:        NULL,
        -:  698:        code_size));
    #####:  699:    break;
        -:  700:
    #####:  701:  case RE_NODE_WORD_CHAR:
        -:  702:
    #####:  703:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  704:        emit_context,
        -:  705:        RE_OPCODE_WORD_CHAR,
        -:  706:        &instruction_addr,
        -:  707:        code_size));
    #####:  708:    break;
        -:  709:
    #####:  710:  case RE_NODE_NON_WORD_CHAR:
        -:  711:
    #####:  712:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  713:        emit_context,
        -:  714:        RE_OPCODE_NON_WORD_CHAR,
        -:  715:        &instruction_addr,
        -:  716:        code_size));
    #####:  717:    break;
        -:  718:
    #####:  719:  case RE_NODE_WORD_BOUNDARY:
        -:  720:
    #####:  721:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  722:        emit_context,
        -:  723:        RE_OPCODE_WORD_BOUNDARY,
        -:  724:        &instruction_addr,
        -:  725:        code_size));
    #####:  726:    break;
        -:  727:
    #####:  728:  case RE_NODE_NON_WORD_BOUNDARY:
        -:  729:
    #####:  730:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  731:        emit_context,
        -:  732:        RE_OPCODE_NON_WORD_BOUNDARY,
        -:  733:        &instruction_addr,
        -:  734:        code_size));
    #####:  735:    break;
        -:  736:
    #####:  737:  case RE_NODE_SPACE:
        -:  738:
    #####:  739:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  740:        emit_context,
        -:  741:        RE_OPCODE_SPACE,
        -:  742:        &instruction_addr,
        -:  743:        code_size));
    #####:  744:    break;
        -:  745:
    #####:  746:  case RE_NODE_NON_SPACE:
        -:  747:
    #####:  748:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  749:        emit_context,
        -:  750:        RE_OPCODE_NON_SPACE,
        -:  751:        &instruction_addr,
        -:  752:        code_size));
    #####:  753:    break;
        -:  754:
    #####:  755:  case RE_NODE_DIGIT:
        -:  756:
    #####:  757:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  758:        emit_context,
        -:  759:        RE_OPCODE_DIGIT,
        -:  760:        &instruction_addr,
        -:  761:        code_size));
    #####:  762:    break;
        -:  763:
    #####:  764:  case RE_NODE_NON_DIGIT:
        -:  765:
    #####:  766:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  767:        emit_context,
        -:  768:        RE_OPCODE_NON_DIGIT,
        -:  769:        &instruction_addr,
        -:  770:        code_size));
    #####:  771:    break;
        -:  772:
    #####:  773:  case RE_NODE_ANY:
        -:  774:
    #####:  775:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  776:        emit_context,
        -:  777:        RE_OPCODE_ANY,
        -:  778:        &instruction_addr,
        -:  779:        code_size));
    #####:  780:    break;
        -:  781:
    #####:  782:  case RE_NODE_CLASS:
        -:  783:
    #####:  784:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  785:        emit_context,
        -:  786:        RE_OPCODE_CLASS,
        -:  787:        &instruction_addr,
        -:  788:        code_size));
        -:  789:
    #####:  790:    FAIL_ON_ERROR(yr_arena_write_data(
        -:  791:        emit_context->arena,
        -:  792:        re_node->re_class,
        -:  793:        sizeof(*re_node->re_class),
        -:  794:        NULL));
        -:  795:
    #####:  796:    *code_size += sizeof(*re_node->re_class);
    #####:  797:    break;
        -:  798:
    #####:  799:  case RE_NODE_ANCHOR_START:
        -:  800:
    #####:  801:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  802:        emit_context,
        -:  803:        RE_OPCODE_MATCH_AT_START,
        -:  804:        &instruction_addr,
        -:  805:        code_size));
    #####:  806:    break;
        -:  807:
    #####:  808:  case RE_NODE_ANCHOR_END:
        -:  809:
    #####:  810:    FAIL_ON_ERROR(_yr_emit_inst(
        -:  811:        emit_context,
        -:  812:        RE_OPCODE_MATCH_AT_END,
        -:  813:        &instruction_addr,
        -:  814:        code_size));
    #####:  815:    break;
        -:  816:
    #####:  817:  case RE_NODE_CONCAT:
        -:  818:
    #####:  819:    if (flags & EMIT_BACKWARDS)
        -:  820:    {
    #####:  821:      left = re_node->right;
    #####:  822:      right = re_node->left;
        -:  823:    }
        -:  824:    else
        -:  825:    {
    #####:  826:      left = re_node->left;
    #####:  827:      right = re_node->right;
        -:  828:    }
        -:  829:
    #####:  830:    FAIL_ON_ERROR(_yr_re_emit(
        -:  831:        emit_context,
        -:  832:        left,
        -:  833:        flags,
        -:  834:        &instruction_addr,
        -:  835:        &branch_size));
        -:  836:
    #####:  837:    *code_size += branch_size;
        -:  838:
    #####:  839:    FAIL_ON_ERROR(_yr_re_emit(
        -:  840:        emit_context,
        -:  841:        right,
        -:  842:        flags,
        -:  843:        NULL,
        -:  844:        &branch_size));
        -:  845:
    #####:  846:    *code_size += branch_size;
        -:  847:
    #####:  848:    break;
        -:  849:
    #####:  850:  case RE_NODE_PLUS:
        -:  851:
        -:  852:    // Code for e+ looks like:
        -:  853:    //
        -:  854:    //          L1: code for e
        -:  855:    //              split L1, L2
        -:  856:    //          L2:
        -:  857:
    #####:  858:    FAIL_ON_ERROR(_yr_re_emit(
        -:  859:        emit_context,
        -:  860:        re_node->left,
        -:  861:        flags,
        -:  862:        &instruction_addr,
        -:  863:        &branch_size));
        -:  864:
    #####:  865:    *code_size += branch_size;
        -:  866:
    #####:  867:    FAIL_ON_ERROR(_yr_emit_split(
        -:  868:        emit_context,
        -:  869:        re_node->greedy ? RE_OPCODE_SPLIT_B : RE_OPCODE_SPLIT_A,
        -:  870:        -((int16_t) branch_size),
        -:  871:        NULL,
        -:  872:        &split_offset_addr,
        -:  873:        &split_size));
        -:  874:
    #####:  875:    *code_size += split_size;
    #####:  876:    break;
        -:  877:
    #####:  878:  case RE_NODE_STAR:
        -:  879:
        -:  880:    // Code for e* looks like:
        -:  881:    //
        -:  882:    //          L1: split L1, L2
        -:  883:    //              code for e
        -:  884:    //              jmp L1
        -:  885:    //          L2:
        -:  886:
    #####:  887:    FAIL_ON_ERROR(_yr_emit_split(
        -:  888:        emit_context,
        -:  889:        re_node->greedy ? RE_OPCODE_SPLIT_A : RE_OPCODE_SPLIT_B,
        -:  890:        0,
        -:  891:        &instruction_addr,
        -:  892:        &split_offset_addr,
        -:  893:        &split_size));
        -:  894:
    #####:  895:    *code_size += split_size;
        -:  896:
    #####:  897:    FAIL_ON_ERROR(_yr_re_emit(
        -:  898:        emit_context,
        -:  899:        re_node->left,
        -:  900:        flags,
        -:  901:        NULL,
        -:  902:        &branch_size));
        -:  903:
    #####:  904:    *code_size += branch_size;
        -:  905:
        -:  906:    // Emit jump with offset set to 0.
        -:  907:
    #####:  908:    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(
        -:  909:        emit_context,
        -:  910:        RE_OPCODE_JUMP,
        -:  911:        -((uint16_t)(branch_size + split_size)),
        -:  912:        NULL,
        -:  913:        &jmp_offset_addr,
        -:  914:        &jmp_size));
        -:  915:
    #####:  916:    *code_size += jmp_size;
        -:  917:
    #####:  918:    if (split_size + branch_size + jmp_size >= INT16_MAX)
    #####:  919:      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -:  920:
        -:  921:    // Update split offset.
    #####:  922:    *split_offset_addr = (int16_t) (split_size + branch_size + jmp_size);
    #####:  923:    break;
        -:  924:
    #####:  925:  case RE_NODE_ALT:
        -:  926:
        -:  927:    // Code for e1|e2 looks like:
        -:  928:    //
        -:  929:    //              split L1, L2
        -:  930:    //          L1: code for e1
        -:  931:    //              jmp L3
        -:  932:    //          L2: code for e2
        -:  933:    //          L3:
        -:  934:
        -:  935:    // Emit a split instruction with offset set to 0 temporarily. Offset
        -:  936:    // will be updated after we know the size of the code generated for
        -:  937:    // the left node (e1).
        -:  938:
    #####:  939:    FAIL_ON_ERROR(_yr_emit_split(
        -:  940:        emit_context,
        -:  941:        RE_OPCODE_SPLIT_A,
        -:  942:        0,
        -:  943:        &instruction_addr,
        -:  944:        &split_offset_addr,
        -:  945:        &split_size));
        -:  946:
    #####:  947:    *code_size += split_size;
        -:  948:
    #####:  949:    FAIL_ON_ERROR(_yr_re_emit(
        -:  950:        emit_context,
        -:  951:        re_node->left,
        -:  952:        flags,
        -:  953:        NULL,
        -:  954:        &branch_size));
        -:  955:
    #####:  956:    *code_size += branch_size;
        -:  957:
        -:  958:    // Emit jump with offset set to 0.
        -:  959:
    #####:  960:    FAIL_ON_ERROR(_yr_emit_inst_arg_int16(
        -:  961:        emit_context,
        -:  962:        RE_OPCODE_JUMP,
        -:  963:        0,
        -:  964:        NULL,
        -:  965:        &jmp_offset_addr,
        -:  966:        &jmp_size));
        -:  967:
    #####:  968:    *code_size += jmp_size;
        -:  969:
    #####:  970:    if (split_size + branch_size + jmp_size >= INT16_MAX)
    #####:  971:      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -:  972:
        -:  973:    // Update split offset.
    #####:  974:    *split_offset_addr = (int16_t) (split_size + branch_size + jmp_size);
        -:  975:
    #####:  976:    FAIL_ON_ERROR(_yr_re_emit(
        -:  977:        emit_context,
        -:  978:        re_node->right,
        -:  979:        flags,
        -:  980:        NULL,
        -:  981:        &branch_size));
        -:  982:
    #####:  983:    *code_size += branch_size;
        -:  984:
    #####:  985:    if (branch_size + jmp_size >= INT16_MAX)
    #####:  986:      return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -:  987:
        -:  988:    // Update offset for jmp instruction.
    #####:  989:    *jmp_offset_addr = (int16_t) (branch_size + jmp_size);
    #####:  990:    break;
        -:  991:
    #####:  992:  case RE_NODE_RANGE_ANY:
        -:  993:
    #####:  994:    repeat_any_args.min = re_node->start;
    #####:  995:    repeat_any_args.max = re_node->end;
        -:  996:
    #####:  997:    FAIL_ON_ERROR(_yr_emit_inst_arg_struct(
        -:  998:        emit_context,
        -:  999:        re_node->greedy ?
        -: 1000:            RE_OPCODE_REPEAT_ANY_GREEDY :
        -: 1001:            RE_OPCODE_REPEAT_ANY_UNGREEDY,
        -: 1002:        &repeat_any_args,
        -: 1003:        sizeof(repeat_any_args),
        -: 1004:        &instruction_addr,
        -: 1005:        NULL,
        -: 1006:        &inst_size));
        -: 1007:
    #####: 1008:    *code_size += inst_size;
    #####: 1009:    break;
        -: 1010:
    #####: 1011:  case RE_NODE_RANGE:
        -: 1012:
        -: 1013:    // Code for e{n,m} looks like:
        -: 1014:    //
        -: 1015:    //            code for e              ---   prolog
        -: 1016:    //            repeat_start n, m, L1   --+
        -: 1017:    //        L0: code for e                |   repeat
        -: 1018:    //            repeat_end n, m, L0     --+
        -: 1019:    //        L1: split L2, L3            ---   split
        -: 1020:    //        L2: code for e              ---   epilog
        -: 1021:    //        L3:
        -: 1022:    //
        -: 1023:    // Not all sections (prolog, repeat, split and epilog) are generated in all
        -: 1024:    // cases, it depends on the values of n and m. The following table shows
        -: 1025:    // which sections are generated for the first few values of n and m.
        -: 1026:    //
        -: 1027:    //        n,m   prolog  repeat      split  epilog
        -: 1028:    //                      (min,max)
        -: 1029:    //        ---------------------------------------
        -: 1030:    //        0,0     -       -           -      -
        -: 1031:    //        0,1     -       -           X      X
        -: 1032:    //        0,2     -       0,1         X      X
        -: 1033:    //        0,3     -       0,2         X      X
        -: 1034:    //        0,M     -       0,M-1       X      X
        -: 1035:    //
        -: 1036:    //        1,1     X       -           -      -
        -: 1037:    //        1,2     X       -           X      X
        -: 1038:    //        1,3     X       0,1         X      X
        -: 1039:    //        1,4     X       1,2         X      X
        -: 1040:    //        1,M     X       1,M-2       X      X
        -: 1041:    //
        -: 1042:    //        2,2     X       -           -      X
        -: 1043:    //        2,3     X       1,1         X      X
        -: 1044:    //        2,4     X       1,2         X      X
        -: 1045:    //        2,M     X       1,M-2       X      X
        -: 1046:    //
        -: 1047:    //        3,3     X       1,1         -      X
        -: 1048:    //        3,4     X       2,2         X      X
        -: 1049:    //        3,M     X       2,M-2       X      X
        -: 1050:    //
        -: 1051:    //        4,4     X       2,2         -      X
        -: 1052:    //        4,5     X       3,3         X      X
        -: 1053:    //        4,M     X       3,M-2       X      X
        -: 1054:    //
        -: 1055:    // The code can't consists simply in the repeat section, the prolog and
        -: 1056:    // epilog are required because we can't have atoms pointing to code inside
        -: 1057:    // the repeat loop. Atoms' forwards_code will point to code in the prolog
        -: 1058:    // and backwards_code will point to code in the epilog (or in prolog if
        -: 1059:    // epilog wasn't generated, like in n=1,m=1)
        -: 1060:
    #####: 1061:    emit_prolog = re_node->start > 0;
    #####: 1062:    emit_repeat = re_node->end > re_node->start + 1 || re_node->end > 2;
    #####: 1063:    emit_split = re_node->end > re_node->start;
    #####: 1064:    emit_epilog = re_node->end > re_node->start || re_node->end > 1;
        -: 1065:
    #####: 1066:    if (emit_prolog)
        -: 1067:    {
    #####: 1068:      FAIL_ON_ERROR(_yr_re_emit(
        -: 1069:          emit_context,
        -: 1070:          re_node->left,
        -: 1071:          flags,
        -: 1072:          &instruction_addr,
        -: 1073:          &branch_size));
        -: 1074:
    #####: 1075:       *code_size += branch_size;
        -: 1076:    }
        -: 1077:
    #####: 1078:    if (emit_repeat)
        -: 1079:    {
    #####: 1080:      repeat_args.min = re_node->start;
    #####: 1081:      repeat_args.max = re_node->end;
        -: 1082:
    #####: 1083:      if (emit_prolog)
        -: 1084:      {
    #####: 1085:        repeat_args.max--;
    #####: 1086:        repeat_args.min--;
        -: 1087:      }
        -: 1088:
    #####: 1089:      if (emit_split)
        -: 1090:      {
    #####: 1091:        repeat_args.max--;
        -: 1092:      }
        -: 1093:      else
        -: 1094:      {
    #####: 1095:        repeat_args.min--;
    #####: 1096:        repeat_args.max--;
        -: 1097:      }
        -: 1098:
    #####: 1099:      repeat_args.offset = 0;
        -: 1100:
    #####: 1101:      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(
        -: 1102:          emit_context,
        -: 1103:          re_node->greedy ?
        -: 1104:              RE_OPCODE_REPEAT_START_GREEDY :
        -: 1105:              RE_OPCODE_REPEAT_START_UNGREEDY,
        -: 1106:          &repeat_args,
        -: 1107:          sizeof(repeat_args),
        -: 1108:          emit_prolog ? NULL : &instruction_addr,
        -: 1109:          (void**) &repeat_start_args_addr,
        -: 1110:          &inst_size));
        -: 1111:
    #####: 1112:      *code_size += inst_size;
        -: 1113:
    #####: 1114:      FAIL_ON_ERROR(_yr_re_emit(
        -: 1115:          emit_context,
        -: 1116:          re_node->left,
        -: 1117:          flags | EMIT_DONT_SET_FORWARDS_CODE | EMIT_DONT_SET_BACKWARDS_CODE,
        -: 1118:          NULL,
        -: 1119:          &branch_size));
        -: 1120:
    #####: 1121:      *code_size += branch_size;
        -: 1122:
    #####: 1123:      repeat_start_args_addr->offset = (int32_t)(2 * inst_size + branch_size);
    #####: 1124:      repeat_args.offset = -((int32_t) branch_size);
        -: 1125:
    #####: 1126:      FAIL_ON_ERROR(_yr_emit_inst_arg_struct(
        -: 1127:          emit_context,
        -: 1128:          re_node->greedy ?
        -: 1129:              RE_OPCODE_REPEAT_END_GREEDY :
        -: 1130:              RE_OPCODE_REPEAT_END_UNGREEDY,
        -: 1131:          &repeat_args,
        -: 1132:          sizeof(repeat_args),
        -: 1133:          NULL,
        -: 1134:          NULL,
        -: 1135:          &inst_size));
        -: 1136:
    #####: 1137:      *code_size += inst_size;
        -: 1138:    }
        -: 1139:
    #####: 1140:    if (emit_split)
        -: 1141:    {
    #####: 1142:      FAIL_ON_ERROR(_yr_emit_split(
        -: 1143:          emit_context,
        -: 1144:          re_node->greedy ?
        -: 1145:              RE_OPCODE_SPLIT_A :
        -: 1146:              RE_OPCODE_SPLIT_B,
        -: 1147:          0,
        -: 1148:          NULL,
        -: 1149:          &split_offset_addr,
        -: 1150:          &split_size));
        -: 1151:
    #####: 1152:      *code_size += split_size;
        -: 1153:    }
        -: 1154:
    #####: 1155:    if (emit_epilog)
        -: 1156:    {
    #####: 1157:      FAIL_ON_ERROR(_yr_re_emit(
        -: 1158:          emit_context,
        -: 1159:          re_node->left,
        -: 1160:          emit_prolog ? flags | EMIT_DONT_SET_FORWARDS_CODE : flags,
        -: 1161:          emit_prolog || emit_repeat ? NULL : &instruction_addr,
        -: 1162:          &branch_size));
        -: 1163:
    #####: 1164:      *code_size += branch_size;
        -: 1165:    }
        -: 1166:
    #####: 1167:    if (emit_split)
        -: 1168:    {
    #####: 1169:      if (split_size + branch_size >= INT16_MAX)
    #####: 1170:        return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -: 1171:
    #####: 1172:      *split_offset_addr = (int16_t) (split_size + branch_size);
        -: 1173:    }
        -: 1174:
    #####: 1175:    break;
        -: 1176:  }
        -: 1177:
    #####: 1178:  if (flags & EMIT_BACKWARDS)
        -: 1179:  {
    #####: 1180:    if (!(flags & EMIT_DONT_SET_BACKWARDS_CODE))
    #####: 1181:      re_node->backward_code = instruction_addr + *code_size;
        -: 1182:  }
        -: 1183:  else
        -: 1184:  {
    #####: 1185:    if (!(flags & EMIT_DONT_SET_FORWARDS_CODE))
    #####: 1186:      re_node->forward_code = instruction_addr;
        -: 1187:  }
        -: 1188:
    #####: 1189:  if (code_addr != NULL)
    #####: 1190:    *code_addr = instruction_addr;
        -: 1191:
    #####: 1192:  return ERROR_SUCCESS;
        -: 1193:}
        -: 1194:
        -: 1195:
    #####: 1196:int yr_re_ast_emit_code(
        -: 1197:    RE_AST* re_ast,
        -: 1198:    YR_ARENA* arena,
        -: 1199:    int backwards_code)
        -: 1200:{
        -: 1201:  RE_EMIT_CONTEXT emit_context;
        -: 1202:
        -: 1203:  size_t code_size;
        -: 1204:  size_t total_size;
        -: 1205:
        -: 1206:  // Ensure that we have enough contiguous memory space in the arena to
        -: 1207:  // contain the regular expression code. The code can't span over multiple
        -: 1208:  // non-contiguous pages.
        -: 1209:
    #####: 1210:  FAIL_ON_ERROR(yr_arena_reserve_memory(arena, RE_MAX_CODE_SIZE));
        -: 1211:
        -: 1212:  // Emit code for matching the regular expressions forwards.
        -: 1213:
    #####: 1214:  total_size = 0;
    #####: 1215:  emit_context.arena = arena;
    #####: 1216:  emit_context.next_split_id = 0;
        -: 1217:
    #####: 1218:  FAIL_ON_ERROR(_yr_re_emit(
        -: 1219:      &emit_context,
        -: 1220:      re_ast->root_node,
        -: 1221:      backwards_code ? EMIT_BACKWARDS : 0,
        -: 1222:      NULL,
        -: 1223:      &code_size));
        -: 1224:
    #####: 1225:  total_size += code_size;
        -: 1226:
    #####: 1227:  FAIL_ON_ERROR(_yr_emit_inst(
        -: 1228:      &emit_context,
        -: 1229:      RE_OPCODE_MATCH,
        -: 1230:      NULL,
        -: 1231:      &code_size));
        -: 1232:
    #####: 1233:  total_size += code_size;
        -: 1234:
    #####: 1235:  if (total_size > RE_MAX_CODE_SIZE)
    #####: 1236:    return ERROR_REGULAR_EXPRESSION_TOO_LARGE;
        -: 1237:
    #####: 1238:  return ERROR_SUCCESS;
        -: 1239:}
        -: 1240:
        -: 1241:
    #####: 1242:static int _yr_re_fiber_create(
        -: 1243:    RE_FIBER_POOL* fiber_pool,
        -: 1244:    RE_FIBER** new_fiber)
        -: 1245:{
        -: 1246:  RE_FIBER* fiber;
        -: 1247:
    #####: 1248:  if (fiber_pool->fibers.head != NULL)
        -: 1249:  {
    #####: 1250:    fiber = fiber_pool->fibers.head;
    #####: 1251:    fiber_pool->fibers.head = fiber->next;
        -: 1252:
    #####: 1253:    if (fiber_pool->fibers.tail == fiber)
    #####: 1254:      fiber_pool->fibers.tail = NULL;
        -: 1255:  }
        -: 1256:  else
        -: 1257:  {
    #####: 1258:    if (fiber_pool->fiber_count == RE_MAX_FIBERS)
    #####: 1259:      return ERROR_TOO_MANY_RE_FIBERS;
        -: 1260:
    #####: 1261:    fiber = (RE_FIBER*) yr_malloc(sizeof(RE_FIBER));
        -: 1262:
    #####: 1263:    if (fiber == NULL)
    #####: 1264:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1265:
    #####: 1266:    fiber_pool->fiber_count++;
        -: 1267:  }
        -: 1268:
    #####: 1269:  fiber->ip = NULL;
    #####: 1270:  fiber->sp = -1;
    #####: 1271:  fiber->rc = -1;
    #####: 1272:  fiber->next = NULL;
    #####: 1273:  fiber->prev = NULL;
        -: 1274:
    #####: 1275:  *new_fiber = fiber;
        -: 1276:
    #####: 1277:  return ERROR_SUCCESS;
        -: 1278:}
        -: 1279:
        -: 1280:
        -: 1281://
        -: 1282:// _yr_re_fiber_append
        -: 1283://
        -: 1284:// Appends 'fiber' to 'fiber_list'
        -: 1285://
        -: 1286:
    #####: 1287:static void _yr_re_fiber_append(
        -: 1288:    RE_FIBER_LIST* fiber_list,
        -: 1289:    RE_FIBER* fiber)
        -: 1290:{
    #####: 1291:  assert(fiber->prev == NULL);
    #####: 1292:  assert(fiber->next == NULL);
        -: 1293:
    #####: 1294:  fiber->prev = fiber_list->tail;
        -: 1295:
    #####: 1296:  if (fiber_list->tail != NULL)
    #####: 1297:    fiber_list->tail->next = fiber;
        -: 1298:
    #####: 1299:  fiber_list->tail = fiber;
        -: 1300:
    #####: 1301:  if (fiber_list->head == NULL)
    #####: 1302:    fiber_list->head = fiber;
        -: 1303:
    #####: 1304:  assert(fiber_list->tail->next == NULL);
    #####: 1305:  assert(fiber_list->head->prev == NULL);
    #####: 1306:}
        -: 1307:
        -: 1308:
        -: 1309://
        -: 1310:// _yr_re_fiber_exists
        -: 1311://
        -: 1312:// Verifies if a fiber with the same properties (ip, rc, sp, and stack values)
        -: 1313:// than 'target_fiber' exists in 'fiber_list'. The list is iterated from
        -: 1314:// the start until 'last_fiber' (inclusive). Fibers past 'last_fiber' are not
        -: 1315:// taken into account.
        -: 1316://
        -: 1317:
    #####: 1318:static int _yr_re_fiber_exists(
        -: 1319:    RE_FIBER_LIST* fiber_list,
        -: 1320:    RE_FIBER* target_fiber,
        -: 1321:    RE_FIBER* last_fiber)
        -: 1322:{
    #####: 1323:  RE_FIBER* fiber = fiber_list->head;
        -: 1324:
        -: 1325:  int equal_stacks;
        -: 1326:  int i;
        -: 1327:
    #####: 1328:  if (last_fiber == NULL)
    #####: 1329:    return false;
        -: 1330:
    #####: 1331:  while (fiber != last_fiber->next)
        -: 1332:  {
    #####: 1333:    if (fiber->ip == target_fiber->ip &&
    #####: 1334:        fiber->sp == target_fiber->sp &&
    #####: 1335:        fiber->rc == target_fiber->rc)
        -: 1336:    {
    #####: 1337:      equal_stacks = true;
        -: 1338:
    #####: 1339:      for (i = 0; i <= fiber->sp; i++)
        -: 1340:      {
    #####: 1341:        if (fiber->stack[i] != target_fiber->stack[i])
        -: 1342:        {
    #####: 1343:          equal_stacks = false;
    #####: 1344:          break;
        -: 1345:        }
        -: 1346:      }
        -: 1347:
    #####: 1348:      if (equal_stacks)
    #####: 1349:        return true;
        -: 1350:    }
        -: 1351:
    #####: 1352:    fiber = fiber->next;
        -: 1353:  }
        -: 1354:
    #####: 1355:  return false;
        -: 1356:}
        -: 1357:
        -: 1358:
        -: 1359://
        -: 1360:// _yr_re_fiber_split
        -: 1361://
        -: 1362:// Clones a fiber in fiber_list and inserts the cloned fiber just after.
        -: 1363:// the original one. If fiber_list is:
        -: 1364://
        -: 1365://   f1 -> f2 -> f3 -> f4
        -: 1366://
        -: 1367:// Splitting f2 will result in:
        -: 1368://
        -: 1369://   f1 -> f2 -> cloned f2 -> f3 -> f4
        -: 1370://
        -: 1371:
    #####: 1372:static int _yr_re_fiber_split(
        -: 1373:    RE_FIBER_LIST* fiber_list,
        -: 1374:    RE_FIBER_POOL* fiber_pool,
        -: 1375:    RE_FIBER* fiber,
        -: 1376:    RE_FIBER** new_fiber)
        -: 1377:{
        -: 1378:  int32_t i;
        -: 1379:
    #####: 1380:  FAIL_ON_ERROR(_yr_re_fiber_create(fiber_pool, new_fiber));
        -: 1381:
    #####: 1382:  (*new_fiber)->sp = fiber->sp;
    #####: 1383:  (*new_fiber)->ip = fiber->ip;
    #####: 1384:  (*new_fiber)->rc = fiber->rc;
        -: 1385:
    #####: 1386:  for (i = 0; i <= fiber->sp; i++)
    #####: 1387:    (*new_fiber)->stack[i] = fiber->stack[i];
        -: 1388:
    #####: 1389:  (*new_fiber)->next = fiber->next;
    #####: 1390:  (*new_fiber)->prev = fiber;
        -: 1391:
    #####: 1392:  if (fiber->next != NULL)
    #####: 1393:    fiber->next->prev = *new_fiber;
        -: 1394:
    #####: 1395:  fiber->next = *new_fiber;
        -: 1396:
    #####: 1397:  if (fiber_list->tail == fiber)
    #####: 1398:    fiber_list->tail = *new_fiber;
        -: 1399:
    #####: 1400:  assert(fiber_list->tail->next == NULL);
    #####: 1401:  assert(fiber_list->head->prev == NULL);
        -: 1402:
    #####: 1403:  return ERROR_SUCCESS;
        -: 1404:}
        -: 1405:
        -: 1406:
        -: 1407://
        -: 1408:// _yr_re_fiber_kill
        -: 1409://
        -: 1410:// Kills a given fiber by removing it from the fiber list and putting it
        -: 1411:// in the fiber pool.
        -: 1412://
        -: 1413:
    #####: 1414:static RE_FIBER* _yr_re_fiber_kill(
        -: 1415:    RE_FIBER_LIST* fiber_list,
        -: 1416:    RE_FIBER_POOL* fiber_pool,
        -: 1417:    RE_FIBER* fiber)
        -: 1418:{
    #####: 1419:  RE_FIBER* next_fiber = fiber->next;
        -: 1420:
    #####: 1421:  if (fiber->prev != NULL)
    #####: 1422:    fiber->prev->next = next_fiber;
        -: 1423:
    #####: 1424:  if (next_fiber != NULL)
    #####: 1425:    next_fiber->prev = fiber->prev;
        -: 1426:
    #####: 1427:  if (fiber_pool->fibers.tail != NULL)
    #####: 1428:    fiber_pool->fibers.tail->next = fiber;
        -: 1429:
    #####: 1430:  if (fiber_list->tail == fiber)
    #####: 1431:    fiber_list->tail = fiber->prev;
        -: 1432:
    #####: 1433:  if (fiber_list->head == fiber)
    #####: 1434:    fiber_list->head = next_fiber;
        -: 1435:
    #####: 1436:  fiber->next = NULL;
    #####: 1437:  fiber->prev = fiber_pool->fibers.tail;
    #####: 1438:  fiber_pool->fibers.tail = fiber;
        -: 1439:
    #####: 1440:  if (fiber_pool->fibers.head == NULL)
    #####: 1441:    fiber_pool->fibers.head = fiber;
        -: 1442:
    #####: 1443:  return next_fiber;
        -: 1444:}
        -: 1445:
        -: 1446:
        -: 1447://
        -: 1448:// _yr_re_fiber_kill_tail
        -: 1449://
        -: 1450:// Kills all fibers from the given one up to the end of the fiber list.
        -: 1451://
        -: 1452:
    #####: 1453:static void _yr_re_fiber_kill_tail(
        -: 1454:  RE_FIBER_LIST* fiber_list,
        -: 1455:  RE_FIBER_POOL* fiber_pool,
        -: 1456:  RE_FIBER* fiber)
        -: 1457:{
    #####: 1458:  RE_FIBER* prev_fiber = fiber->prev;
        -: 1459:
    #####: 1460:  if (prev_fiber != NULL)
    #####: 1461:    prev_fiber->next = NULL;
        -: 1462:
    #####: 1463:  fiber->prev = fiber_pool->fibers.tail;
        -: 1464:
    #####: 1465:  if (fiber_pool->fibers.tail != NULL)
    #####: 1466:    fiber_pool->fibers.tail->next = fiber;
        -: 1467:
    #####: 1468:  fiber_pool->fibers.tail = fiber_list->tail;
    #####: 1469:  fiber_list->tail = prev_fiber;
        -: 1470:
    #####: 1471:  if (fiber_list->head == fiber)
    #####: 1472:    fiber_list->head = NULL;
        -: 1473:
    #####: 1474:  if (fiber_pool->fibers.head == NULL)
    #####: 1475:    fiber_pool->fibers.head = fiber;
    #####: 1476:}
        -: 1477:
        -: 1478:
        -: 1479://
        -: 1480:// _yr_re_fiber_kill_all
        -: 1481://
        -: 1482:// Kills all fibers in the fiber list.
        -: 1483://
        -: 1484:
    #####: 1485:static void _yr_re_fiber_kill_all(
        -: 1486:    RE_FIBER_LIST* fiber_list,
        -: 1487:    RE_FIBER_POOL* fiber_pool)
        -: 1488:{
    #####: 1489:  if (fiber_list->head != NULL)
    #####: 1490:    _yr_re_fiber_kill_tail(fiber_list, fiber_pool, fiber_list->head);
    #####: 1491:}
        -: 1492:
        -: 1493:
        -: 1494://
        -: 1495:// _yr_re_fiber_sync
        -: 1496://
        -: 1497:// Executes a fiber until reaching an "matching" instruction. A "matching"
        -: 1498:// instruction is one that actually reads a byte from the input and performs
        -: 1499:// some matching. If the fiber reaches a split instruction, the new fiber is
        -: 1500:// also synced.
        -: 1501://
        -: 1502:
    #####: 1503:static int _yr_re_fiber_sync(
        -: 1504:    RE_FIBER_LIST* fiber_list,
        -: 1505:    RE_FIBER_POOL* fiber_pool,
        -: 1506:    RE_FIBER* fiber_to_sync)
        -: 1507:{
        -: 1508:  // A array for keeping track of which split instructions has been already
        -: 1509:  // executed. Each split instruction within a regexp has an associated ID
        -: 1510:  // between 0 and RE_MAX_SPLIT_ID. Keeping track of executed splits is
        -: 1511:  // required to avoid infinite loops in regexps like (a*)* or (a|)*
        -: 1512:
        -: 1513:  RE_SPLIT_ID_TYPE splits_executed[RE_MAX_SPLIT_ID];
    #####: 1514:  RE_SPLIT_ID_TYPE splits_executed_count = 0;
        -: 1515:  RE_SPLIT_ID_TYPE split_id, splits_executed_idx;
        -: 1516:
        -: 1517:  int split_already_executed;
        -: 1518:
        -: 1519:  RE_REPEAT_ARGS* repeat_args;
        -: 1520:  RE_REPEAT_ANY_ARGS* repeat_any_args;
        -: 1521:
        -: 1522:  RE_FIBER* fiber;
        -: 1523:  RE_FIBER* last;
        -: 1524:  RE_FIBER* next;
        -: 1525:  RE_FIBER* branch_a;
        -: 1526:  RE_FIBER* branch_b;
        -: 1527:
    #####: 1528:  fiber = fiber_to_sync;
    #####: 1529:  last = fiber_to_sync->next;
        -: 1530:
    #####: 1531:  while (fiber != last)
        -: 1532:  {
    #####: 1533:    uint8_t opcode = *fiber->ip;
        -: 1534:
    #####: 1535:    switch (opcode)
        -: 1536:    {
    #####: 1537:      case RE_OPCODE_SPLIT_A:
        -: 1538:      case RE_OPCODE_SPLIT_B:
        -: 1539:
    #####: 1540:        split_id = *(RE_SPLIT_ID_TYPE*)(fiber->ip + 1);
    #####: 1541:        split_already_executed = false;
        -: 1542:
    #####: 1543:        for (splits_executed_idx = 0;
        -: 1544:             splits_executed_idx < splits_executed_count;
    #####: 1545:             splits_executed_idx++)
        -: 1546:        {
    #####: 1547:          if (split_id == splits_executed[splits_executed_idx])
        -: 1548:          {
    #####: 1549:            split_already_executed = true;
    #####: 1550:            break;
        -: 1551:          }
        -: 1552:        }
        -: 1553:
    #####: 1554:        if (split_already_executed)
        -: 1555:        {
    #####: 1556:          fiber = _yr_re_fiber_kill(fiber_list, fiber_pool, fiber);
        -: 1557:        }
        -: 1558:        else
        -: 1559:        {
    #####: 1560:          branch_a = fiber;
        -: 1561:
    #####: 1562:          FAIL_ON_ERROR(_yr_re_fiber_split(
        -: 1563:              fiber_list, fiber_pool, branch_a, &branch_b));
        -: 1564:
        -: 1565:          // With RE_OPCODE_SPLIT_A the current fiber continues at the next
        -: 1566:          // instruction in the stream (branch A), while the newly created
        -: 1567:          // fiber starts at the address indicated by the instruction (branch B)
        -: 1568:          // RE_OPCODE_SPLIT_B has the opposite behavior.
        -: 1569:
    #####: 1570:          if (opcode == RE_OPCODE_SPLIT_B)
    #####: 1571:            yr_swap(branch_a, branch_b, RE_FIBER*);
        -: 1572:
        -: 1573:          // Branch A continues at the next instruction
        -: 1574:
    #####: 1575:          branch_a->ip += (sizeof(RE_SPLIT_ID_TYPE) + 3);
        -: 1576:
        -: 1577:          // Branch B adds the offset encoded in the opcode to its instruction
        -: 1578:          // pointer.
        -: 1579:
    #####: 1580:          branch_b->ip += *(int16_t*)(
    #####: 1581:              branch_b->ip
        -: 1582:              + 1  // opcode size
    #####: 1583:              + sizeof(RE_SPLIT_ID_TYPE));
        -: 1584:
    #####: 1585:          splits_executed[splits_executed_count] = split_id;
    #####: 1586:          splits_executed_count++;
        -: 1587:        }
        -: 1588:
    #####: 1589:        break;
        -: 1590:
    #####: 1591:      case RE_OPCODE_REPEAT_START_GREEDY:
        -: 1592:      case RE_OPCODE_REPEAT_START_UNGREEDY:
        -: 1593:
    #####: 1594:        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);
    #####: 1595:        assert(repeat_args->max > 0);
    #####: 1596:        branch_a = fiber;
        -: 1597:
    #####: 1598:        if (repeat_args->min == 0)
        -: 1599:        {
    #####: 1600:          FAIL_ON_ERROR(_yr_re_fiber_split(
        -: 1601:              fiber_list, fiber_pool, branch_a, &branch_b));
        -: 1602:
    #####: 1603:          if (opcode == RE_OPCODE_REPEAT_START_UNGREEDY)
    #####: 1604:            yr_swap(branch_a, branch_b, RE_FIBER*);
        -: 1605:
    #####: 1606:          branch_b->ip += repeat_args->offset;
        -: 1607:        }
        -: 1608:
    #####: 1609:        branch_a->stack[++branch_a->sp] = 0;
    #####: 1610:        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));
    #####: 1611:        break;
        -: 1612:
    #####: 1613:      case RE_OPCODE_REPEAT_END_GREEDY:
        -: 1614:      case RE_OPCODE_REPEAT_END_UNGREEDY:
        -: 1615:
    #####: 1616:        repeat_args = (RE_REPEAT_ARGS*)(fiber->ip + 1);
    #####: 1617:        fiber->stack[fiber->sp]++;
        -: 1618:
    #####: 1619:        if (fiber->stack[fiber->sp] < repeat_args->min)
        -: 1620:        {
    #####: 1621:          fiber->ip += repeat_args->offset;
    #####: 1622:          break;
        -: 1623:        }
        -: 1624:
    #####: 1625:        branch_a = fiber;
        -: 1626:
    #####: 1627:        if (fiber->stack[fiber->sp] < repeat_args->max)
        -: 1628:        {
    #####: 1629:          FAIL_ON_ERROR(_yr_re_fiber_split(
        -: 1630:              fiber_list, fiber_pool, branch_a, &branch_b));
        -: 1631:
    #####: 1632:          if (opcode == RE_OPCODE_REPEAT_END_GREEDY)
    #####: 1633:            yr_swap(branch_a, branch_b, RE_FIBER*);
        -: 1634:
    #####: 1635:          branch_a->sp--;
    #####: 1636:          branch_b->ip += repeat_args->offset;
        -: 1637:        }
        -: 1638:
    #####: 1639:        branch_a->ip += (1 + sizeof(RE_REPEAT_ARGS));
    #####: 1640:        break;
        -: 1641:
    #####: 1642:      case RE_OPCODE_REPEAT_ANY_GREEDY:
        -: 1643:      case RE_OPCODE_REPEAT_ANY_UNGREEDY:
        -: 1644:
    #####: 1645:        repeat_any_args = (RE_REPEAT_ANY_ARGS*)(fiber->ip + 1);
        -: 1646:
        -: 1647:        // If repetition counter (rc) is -1 it means that we are reaching this
        -: 1648:        // instruction from the previous one in the instructions stream. In
        -: 1649:        // this case let's initialize the counter to 0 and start looping.
        -: 1650:
    #####: 1651:        if (fiber->rc == -1)
    #####: 1652:          fiber->rc = 0;
        -: 1653:
    #####: 1654:        if (fiber->rc < repeat_any_args->min)
        -: 1655:        {
        -: 1656:          // Increase repetition counter and continue with next fiber. The
        -: 1657:          // instruction pointer for this fiber is not incremented yet, this
        -: 1658:          // fiber spins in this same instruction until reaching the minimum
        -: 1659:          // number of repetitions.
        -: 1660:
    #####: 1661:          fiber->rc++;
    #####: 1662:          fiber = fiber->next;
        -: 1663:        }
    #####: 1664:        else if (fiber->rc < repeat_any_args->max)
        -: 1665:        {
        -: 1666:          // Once the minimum number of repetitions are matched one fiber
        -: 1667:          // remains spinning in this instruction until reaching the maximum
        -: 1668:          // number of repetitions while new fibers are created. New fibers
        -: 1669:          // start executing at the next instruction.
        -: 1670:
    #####: 1671:          next = fiber->next;
    #####: 1672:          branch_a = fiber;
        -: 1673:
    #####: 1674:          FAIL_ON_ERROR(_yr_re_fiber_split(
        -: 1675:              fiber_list, fiber_pool, branch_a, &branch_b));
        -: 1676:
    #####: 1677:          if (opcode == RE_OPCODE_REPEAT_ANY_UNGREEDY)
    #####: 1678:            yr_swap(branch_a, branch_b, RE_FIBER*);
        -: 1679:
    #####: 1680:          branch_a->rc++;
    #####: 1681:          branch_b->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));
    #####: 1682:          branch_b->rc = -1;
        -: 1683:
    #####: 1684:          FAIL_ON_ERROR(_yr_re_fiber_sync(
        -: 1685:              fiber_list, fiber_pool, branch_b));
        -: 1686:
    #####: 1687:          fiber = next;
        -: 1688:        }
        -: 1689:        else
        -: 1690:        {
        -: 1691:          // When the maximum number of repetitions is reached the fiber keeps
        -: 1692:          // executing at the next instruction. The repetition counter is set
        -: 1693:          // to -1 indicating that we are not spinning in a repeat instruction
        -: 1694:          // anymore.
        -: 1695:
    #####: 1696:          fiber->ip += (1 + sizeof(RE_REPEAT_ANY_ARGS));
    #####: 1697:          fiber->rc = -1;
        -: 1698:        }
        -: 1699:
    #####: 1700:        break;
        -: 1701:
    #####: 1702:      case RE_OPCODE_JUMP:
    #####: 1703:        fiber->ip += *(int16_t*)(fiber->ip + 1);
    #####: 1704:        break;
        -: 1705:
    #####: 1706:      default:
    #####: 1707:        fiber = fiber->next;
        -: 1708:    }
        -: 1709:  }
        -: 1710:
    #####: 1711:  return ERROR_SUCCESS;
        -: 1712:}
        -: 1713:
        -: 1714:
        -: 1715://
        -: 1716:// yr_re_exec
        -: 1717://
        -: 1718:// Executes a regular expression. The specified regular expression will try to
        -: 1719:// match the data starting at the address specified by "input". The "input"
        -: 1720:// pointer can point to any address inside a memory buffer. Arguments
        -: 1721:// "input_forwards_size" and "input_backwards_size" indicate how many bytes
        -: 1722:// can be accesible starting at "input" and going forwards and backwards
        -: 1723:// respectively.
        -: 1724://
        -: 1725://   <--- input_backwards_size -->|<----------- input_forwards_size -------->
        -: 1726://  |--------  memory buffer  -----------------------------------------------|
        -: 1727://                                ^
        -: 1728://                              input
        -: 1729://
        -: 1730:// Args:
        -: 1731://   YR_SCAN_CONTEXT *context         - Scan context.
        -: 1732://   const uint8_t* code              - Regexp code be executed
        -: 1733://   const uint8_t* input             - Pointer to input data
        -: 1734://   size_t input_forwards_size       - Number of accessible bytes starting at
        -: 1735://                                      "input" and going forwards.
        -: 1736://   size_t input_backwards_size      - Number of accessible bytes starting at
        -: 1737://                                      "input" and going backwards
        -: 1738://   int flags                        - Flags:
        -: 1739://      RE_FLAGS_SCAN
        -: 1740://      RE_FLAGS_BACKWARDS
        -: 1741://      RE_FLAGS_EXHAUSTIVE
        -: 1742://      RE_FLAGS_WIDE
        -: 1743://      RE_FLAGS_NO_CASE
        -: 1744://      RE_FLAGS_DOT_ALL
        -: 1745://   RE_MATCH_CALLBACK_FUNC callback  - Callback function
        -: 1746://   void* callback_args              - Callback argument
        -: 1747://   int*  matches                    - Pointer to an integer receiving the
        -: 1748://                                      number of matching bytes. Notice that
        -: 1749://                                      0 means a zero-length match, while no
        -: 1750://                                      matches is -1.
        -: 1751:// Returns:
        -: 1752://    ERROR_SUCCESS or any other error code.
        -: 1753:
    #####: 1754:int yr_re_exec(
        -: 1755:    YR_SCAN_CONTEXT* context,
        -: 1756:    const uint8_t* code,
        -: 1757:    const uint8_t* input_data,
        -: 1758:    size_t input_forwards_size,
        -: 1759:    size_t input_backwards_size,
        -: 1760:    int flags,
        -: 1761:    RE_MATCH_CALLBACK_FUNC callback,
        -: 1762:    void* callback_args,
        -: 1763:    int* matches)
        -: 1764:{
        -: 1765:  const uint8_t* input;
        -: 1766:  const uint8_t* ip;
        -: 1767:
        -: 1768:  uint8_t mask;
        -: 1769:  uint8_t value;
        -: 1770:  uint8_t character_size;
        -: 1771:
        -: 1772:  RE_FIBER_LIST fibers;
        -: 1773:  RE_FIBER* fiber;
        -: 1774:  RE_FIBER* next_fiber;
        -: 1775:
        -: 1776:  int bytes_matched;
        -: 1777:  int max_bytes_matched;
        -: 1778:  int match;
        -: 1779:  int input_incr;
        -: 1780:  int kill;
        -: 1781:  int action;
        -: 1782:
        -: 1783:  #define ACTION_NONE       0
        -: 1784:  #define ACTION_CONTINUE   1
        -: 1785:  #define ACTION_KILL       2
        -: 1786:  #define ACTION_KILL_TAIL  3
        -: 1787:
        -: 1788:  #define prolog { \
        -: 1789:      if ((bytes_matched >= max_bytes_matched) || \
        -: 1790:          (character_size == 2 && *(input + 1) != 0)) \
        -: 1791:      { \
        -: 1792:        action = ACTION_KILL; \
        -: 1793:        break; \
        -: 1794:      } \
        -: 1795:    }
        -: 1796:
    #####: 1797:  if (matches != NULL)
    #####: 1798:    *matches = -1;
        -: 1799:
    #####: 1800:  if (flags & RE_FLAGS_WIDE)
    #####: 1801:    character_size = 2;
        -: 1802:  else
    #####: 1803:    character_size = 1;
        -: 1804:
    #####: 1805:  input = input_data;
    #####: 1806:  input_incr = character_size;
        -: 1807:
    #####: 1808:  if (flags & RE_FLAGS_BACKWARDS)
        -: 1809:  {
    #####: 1810:    max_bytes_matched = (int) yr_min(input_backwards_size, RE_SCAN_LIMIT);
    #####: 1811:    input -= character_size;
    #####: 1812:    input_incr = -input_incr;
        -: 1813:  }
        -: 1814:  else
        -: 1815:  {
    #####: 1816:    max_bytes_matched = (int) yr_min(input_forwards_size, RE_SCAN_LIMIT);
        -: 1817:  }
        -: 1818:
        -: 1819:  // Round down max_bytes_matched to a multiple of character_size, this way if
        -: 1820:  // character_size is 2 and max_bytes_matched is odd we are ignoring the
        -: 1821:  // extra byte which can't match anyways.
        -: 1822:
    #####: 1823:  max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size;
    #####: 1824:  bytes_matched = 0;
        -: 1825:
    #####: 1826:  FAIL_ON_ERROR(_yr_re_fiber_create(&context->re_fiber_pool, &fiber));
        -: 1827:
    #####: 1828:  fiber->ip = code;
    #####: 1829:  fibers.head = fiber;
    #####: 1830:  fibers.tail = fiber;
        -: 1831:
    #####: 1832:  FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1833:      _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),
        -: 1834:      _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 1835:
    #####: 1836:  while (fibers.head != NULL)
        -: 1837:  {
    #####: 1838:    fiber = fibers.head;
        -: 1839:
    #####: 1840:    while (fiber != NULL)
        -: 1841:    {
    #####: 1842:      next_fiber = fiber->next;
        -: 1843:
    #####: 1844:      if (_yr_re_fiber_exists(&fibers, fiber, fiber->prev))
    #####: 1845:        _yr_re_fiber_kill(&fibers, &context->re_fiber_pool, fiber);
        -: 1846:
    #####: 1847:      fiber = next_fiber;
        -: 1848:    }
        -: 1849:
    #####: 1850:    fiber = fibers.head;
        -: 1851:
    #####: 1852:    while (fiber != NULL)
        -: 1853:    {
    #####: 1854:      ip = fiber->ip;
    #####: 1855:      action = ACTION_NONE;
        -: 1856:
    #####: 1857:      switch (*ip)
        -: 1858:      {
    #####: 1859:        case RE_OPCODE_ANY:
    #####: 1860:          prolog;
    #####: 1861:          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
    #####: 1862:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1863:          fiber->ip += 1;
    #####: 1864:          break;
        -: 1865:
    #####: 1866:        case RE_OPCODE_REPEAT_ANY_GREEDY:
        -: 1867:        case RE_OPCODE_REPEAT_ANY_UNGREEDY:
    #####: 1868:          prolog;
    #####: 1869:          match = (flags & RE_FLAGS_DOT_ALL) || (*input != 0x0A);
    #####: 1870:          action = match ? ACTION_NONE : ACTION_KILL;
        -: 1871:
        -: 1872:          // The instruction pointer is not incremented here. The current fiber
        -: 1873:          // spins in this instruction until reaching the required number of
        -: 1874:          // repetitions. The code controlling the number of repetitions is in
        -: 1875:          // _yr_re_fiber_sync.
        -: 1876:
    #####: 1877:          break;
        -: 1878:
    #####: 1879:        case RE_OPCODE_LITERAL:
    #####: 1880:          prolog;
    #####: 1881:          if (flags & RE_FLAGS_NO_CASE)
    #####: 1882:            match = yr_lowercase[*input] == yr_lowercase[*(ip + 1)];
        -: 1883:          else
    #####: 1884:            match = (*input == *(ip + 1));
    #####: 1885:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1886:          fiber->ip += 2;
    #####: 1887:          break;
        -: 1888:
    #####: 1889:        case RE_OPCODE_MASKED_LITERAL:
    #####: 1890:          prolog;
    #####: 1891:          value = *(int16_t*)(ip + 1) & 0xFF;
    #####: 1892:          mask = *(int16_t*)(ip + 1) >> 8;
        -: 1893:
        -: 1894:          // We don't need to take into account the case-insensitive
        -: 1895:          // case because this opcode is only used with hex strings,
        -: 1896:          // which can't be case-insensitive.
        -: 1897:
    #####: 1898:          match = ((*input & mask) == value);
    #####: 1899:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1900:          fiber->ip += 3;
    #####: 1901:          break;
        -: 1902:
    #####: 1903:        case RE_OPCODE_CLASS:
    #####: 1904:          prolog;
    #####: 1905:          match = _yr_re_is_char_in_class(
    #####: 1906:              (RE_CLASS*) (ip + 1), *input, flags & RE_FLAGS_NO_CASE);
    #####: 1907:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1908:          fiber->ip += (sizeof(RE_CLASS) + 1);
    #####: 1909:          break;
        -: 1910:
    #####: 1911:        case RE_OPCODE_WORD_CHAR:
    #####: 1912:          prolog;
    #####: 1913:          match = _yr_re_is_word_char(input, character_size);
    #####: 1914:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1915:          fiber->ip += 1;
    #####: 1916:          break;
        -: 1917:
    #####: 1918:        case RE_OPCODE_NON_WORD_CHAR:
    #####: 1919:          prolog;
    #####: 1920:          match = !_yr_re_is_word_char(input, character_size);
    #####: 1921:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1922:          fiber->ip += 1;
    #####: 1923:          break;
        -: 1924:
    #####: 1925:        case RE_OPCODE_SPACE:
        -: 1926:        case RE_OPCODE_NON_SPACE:
        -: 1927:
    #####: 1928:          prolog;
        -: 1929:
    #####: 1930:          switch (*input)
        -: 1931:          {
    #####: 1932:            case ' ':
        -: 1933:            case '\t':
        -: 1934:            case '\r':
        -: 1935:            case '\n':
        -: 1936:            case '\v':
        -: 1937:            case '\f':
    #####: 1938:              match = true;
    #####: 1939:              break;
    #####: 1940:            default:
    #####: 1941:              match = false;
        -: 1942:          }
        -: 1943:
    #####: 1944:          if (*ip == RE_OPCODE_NON_SPACE)
    #####: 1945:            match = !match;
        -: 1946:
    #####: 1947:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1948:          fiber->ip += 1;
    #####: 1949:          break;
        -: 1950:
    #####: 1951:        case RE_OPCODE_DIGIT:
    #####: 1952:          prolog;
    #####: 1953:          match = isdigit(*input);
    #####: 1954:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1955:          fiber->ip += 1;
    #####: 1956:          break;
        -: 1957:
    #####: 1958:        case RE_OPCODE_NON_DIGIT:
    #####: 1959:          prolog;
    #####: 1960:          match = !isdigit(*input);
    #####: 1961:          action = match ? ACTION_NONE : ACTION_KILL;
    #####: 1962:          fiber->ip += 1;
    #####: 1963:          break;
        -: 1964:
    #####: 1965:        case RE_OPCODE_WORD_BOUNDARY:
        -: 1966:        case RE_OPCODE_NON_WORD_BOUNDARY:
        -: 1967:
    #####: 1968:          if (bytes_matched == 0 && input_backwards_size < character_size)
        -: 1969:          {
    #####: 1970:            match = true;
        -: 1971:          }
    #####: 1972:          else if (bytes_matched >= max_bytes_matched)
        -: 1973:          {
    #####: 1974:            match = true;
        -: 1975:          }
        -: 1976:          else
        -: 1977:          {
    #####: 1978:            assert(input <  input_data + input_forwards_size);
    #####: 1979:            assert(input >= input_data - input_backwards_size);
        -: 1980:
    #####: 1981:            assert(input - input_incr <  input_data + input_forwards_size);
    #####: 1982:            assert(input - input_incr >= input_data - input_backwards_size);
        -: 1983:
    #####: 1984:            match = _yr_re_is_word_char(input, character_size) != \
    #####: 1985:                    _yr_re_is_word_char(input - input_incr, character_size);
        -: 1986:          }
        -: 1987:
    #####: 1988:          if (*ip == RE_OPCODE_NON_WORD_BOUNDARY)
    #####: 1989:            match = !match;
        -: 1990:
    #####: 1991:          action = match ? ACTION_CONTINUE : ACTION_KILL;
    #####: 1992:          fiber->ip += 1;
    #####: 1993:          break;
        -: 1994:
    #####: 1995:        case RE_OPCODE_MATCH_AT_START:
    #####: 1996:          if (flags & RE_FLAGS_BACKWARDS)
    #####: 1997:            kill = input_backwards_size > (size_t) bytes_matched;
        -: 1998:          else
    #####: 1999:            kill = input_backwards_size > 0 || (bytes_matched != 0);
    #####: 2000:          action = kill ? ACTION_KILL : ACTION_CONTINUE;
    #####: 2001:          fiber->ip += 1;
    #####: 2002:          break;
        -: 2003:
    #####: 2004:        case RE_OPCODE_MATCH_AT_END:
    #####: 2005:          kill = flags & RE_FLAGS_BACKWARDS ||
    #####: 2006:                 input_forwards_size > (size_t) bytes_matched;
    #####: 2007:          action = kill ? ACTION_KILL : ACTION_CONTINUE;
    #####: 2008:          fiber->ip += 1;
    #####: 2009:          break;
        -: 2010:
    #####: 2011:        case RE_OPCODE_MATCH:
        -: 2012:
    #####: 2013:          if (matches != NULL)
    #####: 2014:            *matches = bytes_matched;
        -: 2015:
    #####: 2016:          if (flags & RE_FLAGS_EXHAUSTIVE)
        -: 2017:          {
    #####: 2018:            if (callback != NULL)
        -: 2019:            {
    #####: 2020:              if (flags & RE_FLAGS_BACKWARDS)
        -: 2021:              {
    #####: 2022:                FAIL_ON_ERROR_WITH_CLEANUP(
        -: 2023:                    callback(
        -: 2024:                        input + character_size,
        -: 2025:                        bytes_matched,
        -: 2026:                        flags,
        -: 2027:                        callback_args),
        -: 2028:                    _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2029:              }
        -: 2030:              else
        -: 2031:              {
    #####: 2032:                FAIL_ON_ERROR_WITH_CLEANUP(
        -: 2033:                    callback(
        -: 2034:                        input_data,
        -: 2035:                        bytes_matched,
        -: 2036:                        flags,
        -: 2037:                        callback_args),
        -: 2038:                    _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2039:              }
        -: 2040:            }
        -: 2041:
    #####: 2042:            action = ACTION_KILL;
        -: 2043:          }
        -: 2044:          else
        -: 2045:          {
    #####: 2046:            action = ACTION_KILL_TAIL;
        -: 2047:          }
        -: 2048:
    #####: 2049:          break;
        -: 2050:
    #####: 2051:        default:
    #####: 2052:          assert(false);
        -: 2053:      }
        -: 2054:
    #####: 2055:      switch (action)
        -: 2056:      {
    #####: 2057:        case ACTION_KILL:
    #####: 2058:          fiber = _yr_re_fiber_kill(&fibers, &context->re_fiber_pool, fiber);
    #####: 2059:          break;
        -: 2060:
    #####: 2061:        case ACTION_KILL_TAIL:
    #####: 2062:          _yr_re_fiber_kill_tail(&fibers, &context->re_fiber_pool, fiber);
    #####: 2063:          fiber = NULL;
    #####: 2064:          break;
        -: 2065:
    #####: 2066:        case ACTION_CONTINUE:
    #####: 2067:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 2068:              _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),
        -: 2069:              _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
    #####: 2070:          break;
        -: 2071:
    #####: 2072:        default:
    #####: 2073:          next_fiber = fiber->next;
    #####: 2074:          FAIL_ON_ERROR_WITH_CLEANUP(
        -: 2075:              _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),
        -: 2076:              _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
    #####: 2077:          fiber = next_fiber;
        -: 2078:      }
        -: 2079:    }
        -: 2080:
    #####: 2081:    input += input_incr;
    #####: 2082:    bytes_matched += character_size;
        -: 2083:
    #####: 2084:    if (flags & RE_FLAGS_SCAN && bytes_matched < max_bytes_matched)
        -: 2085:    {
    #####: 2086:      FAIL_ON_ERROR_WITH_CLEANUP(
        -: 2087:          _yr_re_fiber_create(&context->re_fiber_pool, &fiber),
        -: 2088:          _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2089:
    #####: 2090:      fiber->ip = code;
    #####: 2091:      _yr_re_fiber_append(&fibers, fiber);
        -: 2092:
    #####: 2093:      FAIL_ON_ERROR_WITH_CLEANUP(
        -: 2094:          _yr_re_fiber_sync(&fibers, &context->re_fiber_pool, fiber),
        -: 2095:          _yr_re_fiber_kill_all(&fibers, &context->re_fiber_pool));
        -: 2096:    }
        -: 2097:  }
        -: 2098:
    #####: 2099:  return ERROR_SUCCESS;
        -: 2100:}
        -: 2101:
        -: 2102://
        -: 2103:// yr_re_fast_exec
        -: 2104://
        -: 2105:// This function replaces yr_re_exec for regular expressions marked with flag
        -: 2106:// RE_FLAGS_FAST_REGEXP. These are regular expression whose code contain only
        -: 2107:// the following operations: RE_OPCODE_LITERAL, RE_OPCODE_MASKED_LITERAL,
        -: 2108:// RE_OPCODE_ANY, RE_OPCODE_REPEAT_ANY_UNGREEDY and RE_OPCODE_MATCH. Some
        -: 2109:// examples of regular expressions that can be executed with this function are:
        -: 2110://
        -: 2111://  /foobar/
        -: 2112://  /foo.*?bar/
        -: 2113://
        -: 2114:
    #####: 2115:int yr_re_fast_exec(
        -: 2116:    YR_SCAN_CONTEXT* context,
        -: 2117:    const uint8_t* code,
        -: 2118:    const uint8_t* input_data,
        -: 2119:    size_t input_forwards_size,
        -: 2120:    size_t input_backwards_size,
        -: 2121:    int flags,
        -: 2122:    RE_MATCH_CALLBACK_FUNC callback,
        -: 2123:    void* callback_args,
        -: 2124:    int* matches)
        -: 2125:{
        -: 2126:  RE_REPEAT_ANY_ARGS* repeat_any_args;
        -: 2127:
        -: 2128:  const uint8_t* code_stack[YR_MAX_FAST_RE_STACK];
        -: 2129:  const uint8_t* input_stack[YR_MAX_FAST_RE_STACK];
        -: 2130:  int matches_stack[YR_MAX_FAST_RE_STACK];
        -: 2131:
    #####: 2132:  const uint8_t* input = input_data;
        -: 2133:  const uint8_t* next_input;
    #####: 2134:  const uint8_t* ip = code;
        -: 2135:  const uint8_t* next_opcode;
        -: 2136:
        -: 2137:  uint8_t mask;
        -: 2138:  uint8_t value;
        -: 2139:
        -: 2140:  int i;
        -: 2141:  int stop;
        -: 2142:  int input_incr;
    #####: 2143:  int sp = 0;
        -: 2144:  int bytes_matched;
        -: 2145:  int max_bytes_matched;
        -: 2146:
    #####: 2147:  max_bytes_matched = flags & RE_FLAGS_BACKWARDS ?
    #####: 2148:      (int) input_backwards_size :
        -: 2149:      (int) input_forwards_size;
        -: 2150:
    #####: 2151:  input_incr = flags & RE_FLAGS_BACKWARDS ? -1 : 1;
        -: 2152:
    #####: 2153:  if (flags & RE_FLAGS_BACKWARDS)
    #####: 2154:    input--;
        -: 2155:
    #####: 2156:  code_stack[sp] = code;
    #####: 2157:  input_stack[sp] = input;
    #####: 2158:  matches_stack[sp] = 0;
    #####: 2159:  sp++;
        -: 2160:
    #####: 2161:  while (sp > 0)
        -: 2162:  {
    #####: 2163:    sp--;
    #####: 2164:    ip = code_stack[sp];
    #####: 2165:    input = input_stack[sp];
    #####: 2166:    bytes_matched = matches_stack[sp];
    #####: 2167:    stop = false;
        -: 2168:
    #####: 2169:    while (!stop)
        -: 2170:    {
    #####: 2171:      if (*ip == RE_OPCODE_MATCH)
        -: 2172:      {
    #####: 2173:        if (flags & RE_FLAGS_EXHAUSTIVE)
        -: 2174:        {
    #####: 2175:          FAIL_ON_ERROR(callback(
        -: 2176:             flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data,
        -: 2177:             bytes_matched,
        -: 2178:             flags,
        -: 2179:             callback_args));
        -: 2180:
    #####: 2181:          break;
        -: 2182:        }
        -: 2183:        else
        -: 2184:        {
    #####: 2185:          if (matches != NULL)
    #####: 2186:            *matches = bytes_matched;
        -: 2187:
    #####: 2188:          return ERROR_SUCCESS;
        -: 2189:        }
        -: 2190:      }
        -: 2191:
    #####: 2192:      if (bytes_matched >= max_bytes_matched)
    #####: 2193:        break;
        -: 2194:
    #####: 2195:      switch (*ip)
        -: 2196:      {
    #####: 2197:        case RE_OPCODE_LITERAL:
        -: 2198:
    #####: 2199:          if (*input == *(ip + 1))
        -: 2200:          {
    #####: 2201:            bytes_matched++;
    #####: 2202:            input += input_incr;
    #####: 2203:            ip += 2;
        -: 2204:          }
        -: 2205:          else
        -: 2206:          {
    #####: 2207:            stop = true;
        -: 2208:          }
        -: 2209:
    #####: 2210:          break;
        -: 2211:
    #####: 2212:        case RE_OPCODE_MASKED_LITERAL:
        -: 2213:
    #####: 2214:          value = *(int16_t*)(ip + 1) & 0xFF;
    #####: 2215:          mask = *(int16_t*)(ip + 1) >> 8;
        -: 2216:
    #####: 2217:          if ((*input & mask) == value)
        -: 2218:          {
    #####: 2219:            bytes_matched++;
    #####: 2220:            input += input_incr;
    #####: 2221:            ip += 3;
        -: 2222:          }
        -: 2223:          else
        -: 2224:          {
    #####: 2225:            stop = true;
        -: 2226:          }
        -: 2227:
    #####: 2228:          break;
        -: 2229:
    #####: 2230:        case RE_OPCODE_ANY:
        -: 2231:
    #####: 2232:          bytes_matched++;
    #####: 2233:          input += input_incr;
    #####: 2234:          ip += 1;
        -: 2235:
    #####: 2236:          break;
        -: 2237:
    #####: 2238:        case RE_OPCODE_REPEAT_ANY_UNGREEDY:
        -: 2239:
    #####: 2240:          repeat_any_args = (RE_REPEAT_ANY_ARGS*)(ip + 1);
    #####: 2241:          next_opcode = ip + 1 + sizeof(RE_REPEAT_ANY_ARGS);
        -: 2242:
    #####: 2243:          for (i = repeat_any_args->min + 1; i <= repeat_any_args->max; i++)
        -: 2244:          {
    #####: 2245:            if (bytes_matched + i >= max_bytes_matched)
    #####: 2246:              break;
        -: 2247:
    #####: 2248:            next_input = input + i * input_incr;
        -: 2249:
    #####: 2250:            if ( *(next_opcode) != RE_OPCODE_LITERAL ||
    #####: 2251:                (*(next_opcode) == RE_OPCODE_LITERAL &&
    #####: 2252:                 *(next_opcode + 1) == *next_input))
        -: 2253:            {
    #####: 2254:              if (sp >= YR_MAX_FAST_RE_STACK)
    #####: 2255:                return ERROR_TOO_MANY_RE_FIBERS;
        -: 2256:
    #####: 2257:              code_stack[sp] = next_opcode;
    #####: 2258:              input_stack[sp] = next_input;
    #####: 2259:              matches_stack[sp] = bytes_matched + i;
    #####: 2260:              sp++;
        -: 2261:            }
        -: 2262:          }
        -: 2263:
    #####: 2264:          input += input_incr * repeat_any_args->min;
    #####: 2265:          bytes_matched += repeat_any_args->min;
    #####: 2266:          bytes_matched = yr_min(bytes_matched, max_bytes_matched);
    #####: 2267:          ip = next_opcode;
        -: 2268:
    #####: 2269:          break;
        -: 2270:
    #####: 2271:        default:
    #####: 2272:          assert(false);
        -: 2273:      }
        -: 2274:    }
        -: 2275:  }
        -: 2276:
    #####: 2277:  if (matches != NULL)
    #####: 2278:    *matches = -1;
        -: 2279:
    #####: 2280:  return ERROR_SUCCESS;
        -: 2281:}
        -: 2282:
        -: 2283:
    #####: 2284:static void _yr_re_print_node(
        -: 2285:    RE_NODE* re_node)
        -: 2286:{
        -: 2287:  int i;
        -: 2288:
    #####: 2289:  if (re_node == NULL)
    #####: 2290:    return;
        -: 2291:
    #####: 2292:  switch (re_node->type)
        -: 2293:  {
    #####: 2294:  case RE_NODE_ALT:
    #####: 2295:    printf("Alt(");
    #####: 2296:    _yr_re_print_node(re_node->left);
    #####: 2297:    printf(", ");
    #####: 2298:    _yr_re_print_node(re_node->right);
    #####: 2299:    printf(")");
    #####: 2300:    break;
        -: 2301:
    #####: 2302:  case RE_NODE_CONCAT:
    #####: 2303:    printf("Cat(");
    #####: 2304:    _yr_re_print_node(re_node->left);
    #####: 2305:    printf(", ");
    #####: 2306:    _yr_re_print_node(re_node->right);
    #####: 2307:    printf(")");
    #####: 2308:    break;
        -: 2309:
    #####: 2310:  case RE_NODE_STAR:
    #####: 2311:    printf("Star(");
    #####: 2312:    _yr_re_print_node(re_node->left);
    #####: 2313:    printf(")");
    #####: 2314:    break;
        -: 2315:
    #####: 2316:  case RE_NODE_PLUS:
    #####: 2317:    printf("Plus(");
    #####: 2318:    _yr_re_print_node(re_node->left);
    #####: 2319:    printf(")");
    #####: 2320:    break;
        -: 2321:
    #####: 2322:  case RE_NODE_LITERAL:
    #####: 2323:    printf("Lit(%02X)", re_node->value);
    #####: 2324:    break;
        -: 2325:
    #####: 2326:  case RE_NODE_MASKED_LITERAL:
    #####: 2327:    printf("MaskedLit(%02X,%02X)", re_node->value, re_node->mask);
    #####: 2328:    break;
        -: 2329:
    #####: 2330:  case RE_NODE_WORD_CHAR:
    #####: 2331:    printf("WordChar");
    #####: 2332:    break;
        -: 2333:
    #####: 2334:  case RE_NODE_NON_WORD_CHAR:
    #####: 2335:    printf("NonWordChar");
    #####: 2336:    break;
        -: 2337:
    #####: 2338:  case RE_NODE_SPACE:
    #####: 2339:    printf("Space");
    #####: 2340:    break;
        -: 2341:
    #####: 2342:  case RE_NODE_NON_SPACE:
    #####: 2343:    printf("NonSpace");
    #####: 2344:    break;
        -: 2345:
    #####: 2346:  case RE_NODE_DIGIT:
    #####: 2347:    printf("Digit");
    #####: 2348:    break;
        -: 2349:
    #####: 2350:  case RE_NODE_NON_DIGIT:
    #####: 2351:    printf("NonDigit");
    #####: 2352:    break;
        -: 2353:
    #####: 2354:  case RE_NODE_ANY:
    #####: 2355:    printf("Any");
    #####: 2356:    break;
        -: 2357:
    #####: 2358:  case RE_NODE_RANGE:
    #####: 2359:    printf("Range(%d-%d, ", re_node->start, re_node->end);
    #####: 2360:    _yr_re_print_node(re_node->left);
    #####: 2361:    printf(")");
    #####: 2362:    break;
        -: 2363:
    #####: 2364:  case RE_NODE_CLASS:
    #####: 2365:    printf("Class(");
    #####: 2366:    for (i = 0; i < 256; i++)
    #####: 2367:      if (_yr_re_is_char_in_class(re_node->re_class, i, false))
    #####: 2368:        printf("%02X,", i);
    #####: 2369:    printf(")");
    #####: 2370:    break;
        -: 2371:
    #####: 2372:  default:
    #####: 2373:    printf("???");
    #####: 2374:    break;
        -: 2375:  }
        -: 2376:}
        -: 2377:
    #####: 2378:void yr_re_print(
        -: 2379:    RE_AST* re_ast)
        -: 2380:{
    #####: 2381:  _yr_re_print_node(re_ast->root_node);
    #####: 2382:}
