        -:    0:Source:re_lexer.l
        -:    0:Graph:/home/workspace/libyara/re_lexer.gcno
        -:    0:Data:/home/workspace/libyara/re_lexer.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for regular expressions */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function re_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <assert.h>
        -:   48:#include <setjmp.h>
        -:   49:#include <stdbool.h>
        -:   50:
        -:   51:#include <yara/globals.h>
        -:   52:#include <yara/utils.h>
        -:   53:#include <yara/error.h>
        -:   54:#include <yara/limits.h>
        -:   55:#include <yara/mem.h>
        -:   56:#include <yara/re.h>
        -:   57:#include <yara/re_lexer.h>
        -:   58:#include <yara/threading.h>
        -:   59:#include <yara/strutils.h>
        -:   60:
        -:   61:
        -:   62:#ifdef _WIN32
        -:   63:#define snprintf _snprintf
        -:   64:#endif
        -:   65:
        -:   66:static uint8_t word_chars[] = {
        -:   67:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03,
        -:   68:    0xFE, 0xFF, 0xFF, 0x87, 0xFE, 0xFF, 0xFF, 0x07,
        -:   69:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        -:   70:    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
        -:   71:
        -:   72:
        -:   73:int escaped_char_value(
        -:   74:    char* text,
        -:   75:    uint8_t* value);
        -:   76:
        -:   77:int read_escaped_char(
        -:   78:    yyscan_t yyscanner,
        -:   79:    uint8_t* escaped_char);
        -:   80:
        -:   81:%}
        -:   82:
        -:   83:%option reentrant bison-bridge
        -:   84:%option noyywrap
        -:   85:%option nounistd
        -:   86:%option nounput
        -:   87:%option never-interactive
        -:   88:%option yylineno
        -:   89:%option prefix="re_yy"
        -:   90:
        -:   91:%option outfile="lex.yy.c"
        -:   92:
        -:   93:%option verbose
        -:   94:%option warn
        -:   95:
        -:   96:%x char_class
        -:   97:
        -:   98:digit         [0-9]
        -:   99:hex_digit     [0-9a-fA-F]
        -:  100:
        -:  101:%%
        -:  102:
        -:  103:\{{digit}*,{digit}*\} {
        -:  104:
        -:  105:  // Examples: {3,8} {0,5} {,5} {7,}
        -:  106:
        -:  107:  int hi_bound;
    #####:  108:  int lo_bound = atoi(yytext + 1);
        -:  109:
    #####:  110:  char* comma = strchr(yytext, ',');
        -:  111:
    #####:  112:  if (comma - yytext == strlen(yytext) - 2)
        -:  113:    // if comma is followed by the closing curly bracket
        -:  114:    // (example: {2,}) set high bound value to maximum.
    #####:  115:    hi_bound = INT16_MAX;
        -:  116:  else
    #####:  117:    hi_bound = atoi(comma + 1);
        -:  118:
    #####:  119:  if (hi_bound > INT16_MAX)
        -:  120:  {
    #####:  121:    yyerror(yyscanner, lex_env, "repeat interval too large");
    #####:  122:    yyterminate();
        -:  123:  }
        -:  124:
    #####:  125:  if (hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0)
        -:  126:  {
    #####:  127:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  128:    yyterminate();
        -:  129:  }
        -:  130:
    #####:  131:  if (hi_bound == 0 && lo_bound == 0)
        -:  132:  {
    #####:  133:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  134:    yyterminate();
        -:  135:  }
        -:  136:
    #####:  137:  yylval->range = (hi_bound << 16) | lo_bound;
        -:  138:
    #####:  139:  return _RANGE_;
        -:  140:}
        -:  141:
    #####:  142:
        -:  143:\{{digit}+\} {
        -:  144:
        -:  145:  // Example: {10}
        -:  146:
    #####:  147:  int value = atoi(yytext + 1);
        -:  148:
        -:  149:  // atoi can return a negative value if the input string represents a number
        -:  150:  // too large to fit in an integer.
        -:  151:
    #####:  152:  if (value > INT16_MAX || value < 0)
        -:  153:  {
    #####:  154:    yyerror(yyscanner, lex_env, "repeat interval too large");
    #####:  155:    yyterminate();
        -:  156:  }
        -:  157:
    #####:  158:  if (value == 0)
        -:  159:  {
    #####:  160:    yyerror(yyscanner, lex_env, "bad repeat interval");
    #####:  161:    yyterminate();
        -:  162:  }
        -:  163:
    #####:  164:  yylval->range = (value << 16) | value;
        -:  165:
    #####:  166:  return _RANGE_;
        -:  167:}
        -:  168:
    #####:  169:
        -:  170:\[\^ {
        -:  171:
        -:  172:  // Start of a negated character class. Example: [^abcd]
        -:  173:
    #####:  174:  BEGIN(char_class);
    #####:  175:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  176:  LEX_ENV->re_class.negated = true;
        -:  177:}
    #####:  178:
    #####:  179:\[\^\] {
        -:  180:
        -:  181:  // Start of character negated class containing a ].
        -:  182:  // Example: [^]abc] this must be interpreted as a class
        -:  183:  // not matching ], a, b, nor c
        -:  184:
    #####:  185:  BEGIN(char_class);
    #####:  186:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  187:  LEX_ENV->re_class.negated = true;
    #####:  188:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  189:}
    #####:  190:
    #####:  191:
        -:  192:\[\] {
        -:  193:
        -:  194:  // Start of character class containing a ].
        -:  195:  // Example: []abc] this must be interpreted as a class
        -:  196:  // matching ], a, b, or c.
        -:  197:
    #####:  198:  BEGIN(char_class);
    #####:  199:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  200:  LEX_ENV->re_class.negated = false;
    #####:  201:  LEX_ENV->re_class.bitmap[']' / 8] |= 1 << ']' % 8;
        -:  202:}
    #####:  203:
    #####:  204:
        -:  205:\[ {
        -:  206:
        -:  207:  // Start of character class. Example: [abcd]
        -:  208:
    #####:  209:  BEGIN(char_class);
    #####:  210:  memset(LEX_ENV->re_class.bitmap, 0, 32);
    #####:  211:  LEX_ENV->re_class.negated = false;
        -:  212:}
    #####:  213:
    #####:  214:
        -:  215:[^\\\[\(\)\|\$\.\^\+\*\?] {
        -:  216:
        -:  217:  // Any non-special character is passed as a CHAR token to the scanner.
        -:  218:
    #####:  219:  yylval->integer = yytext[0];
    #####:  220:  return _CHAR_;
        -:  221:}
        -:  222:
    #####:  223:
        -:  224:\\w {
    #####:  225:  return _WORD_CHAR_;
        -:  226:}
        -:  227:
    #####:  228:
        -:  229:\\W {
    #####:  230:  return _NON_WORD_CHAR_;
        -:  231:}
        -:  232:
    #####:  233:
        -:  234:\\s {
    #####:  235:  return _SPACE_;
        -:  236:}
        -:  237:
    #####:  238:
        -:  239:\\S {
    #####:  240:  return _NON_SPACE_;
        -:  241:}
        -:  242:
    #####:  243:
        -:  244:\\d {
    #####:  245:  return _DIGIT_;
        -:  246:}
        -:  247:
    #####:  248:
        -:  249:\\D {
    #####:  250:  return _NON_DIGIT_;
        -:  251:}
        -:  252:
    #####:  253:
        -:  254:\\b {
    #####:  255:  return _WORD_BOUNDARY_;
        -:  256:}
        -:  257:
    #####:  258:\\B {
    #####:  259:  return _NON_WORD_BOUNDARY_;
        -:  260:}
        -:  261:
    #####:  262:
        -:  263:\\{digit}+ {
        -:  264:
    #####:  265:  yyerror(yyscanner, lex_env, "backreferences are not allowed");
    #####:  266:  yyterminate();
        -:  267:}
        -:  268:
    #####:  269:
        -:  270:\\ {
        -:  271:
        -:  272:  uint8_t c;
        -:  273:
    #####:  274:  if (read_escaped_char(yyscanner, &c))
        -:  275:  {
    #####:  276:    yylval->integer = c;
    #####:  277:    return _CHAR_;
        -:  278:  }
        -:  279:  else
        -:  280:  {
    #####:  281:    yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  282:    yyterminate();
        -:  283:  }
        -:  284:}
        -:  285:
    #####:  286:
        -:  287:<char_class>\] {
        -:  288:
        -:  289:  // End of character class.
    #####:  290:  yylval->re_class = (RE_CLASS*) yr_malloc(sizeof(RE_CLASS));
    #####:  291:  memcpy(yylval->re_class->bitmap, LEX_ENV->re_class.bitmap, 32);
        -:  292:
    #####:  293:  yylval->re_class->negated = LEX_ENV->re_class.negated;
        -:  294:
    #####:  295:  BEGIN(INITIAL);
    #####:  296:  return _CLASS_;
        -:  297:}
        -:  298:
    #####:  299:
        -:  300:
        -:  301:<char_class>(\\x{hex_digit}{2}|\\.|[^\\])\-[^]] {
        -:  302:
        -:  303:  // A range inside a character class.
        -:  304:  //  [abc0-9]
        -:  305:  //      ^- matching here
        -:  306:
        -:  307:  uint16_t c;
    #####:  308:  uint8_t start = yytext[0];
    #####:  309:  uint8_t end = yytext[2];
        -:  310:
    #####:  311:  if (start == '\\')
        -:  312:  {
    #####:  313:    if (!escaped_char_value(yytext, &start))
        -:  314:    {
    #####:  315:      yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  316:      yyterminate();
        -:  317:    }
        -:  318:
    #####:  319:    if (yytext[1] == 'x')
    #####:  320:      end = yytext[5];
        -:  321:    else
    #####:  322:      end = yytext[3];
        -:  323:  }
        -:  324:
    #####:  325:  if (end == '\\')
        -:  326:  {
    #####:  327:    if (!read_escaped_char(yyscanner, &end))
        -:  328:    {
    #####:  329:      yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  330:      yyterminate();
        -:  331:    }
        -:  332:  }
        -:  333:
    #####:  334:  if (end < start)
        -:  335:  {
    #####:  336:    yyerror(yyscanner, lex_env, "bad character range");
    #####:  337:    yyterminate();
        -:  338:  }
        -:  339:
    #####:  340:  for (c = start; c <= end; c++)
        -:  341:  {
    #####:  342:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  343:  }
        -:  344:}
    #####:  345:
    #####:  346:
        -:  347:<char_class>\\w {
        -:  348:
        -:  349:  int i;
        -:  350:
    #####:  351:  for (i = 0; i < 32; i++)
    #####:  352:    LEX_ENV->re_class.bitmap[i] |= word_chars[i];
        -:  353:}
    #####:  354:
    #####:  355:
        -:  356:<char_class>\\W {
        -:  357:
        -:  358:  int i;
        -:  359:
    #####:  360:  for (i = 0; i < 32; i++)
    #####:  361:    LEX_ENV->re_class.bitmap[i] |= ~word_chars[i];
        -:  362:}
    #####:  363:
    #####:  364:
        -:  365:<char_class>\\s {
        -:  366:
    #####:  367:  LEX_ENV->re_class.bitmap[' ' / 8] |= 1 << ' ' % 8;
    #####:  368:  LEX_ENV->re_class.bitmap['\t' / 8] |= 1 << '\t' % 8;
        -:  369:}
    #####:  370:
    #####:  371:
        -:  372:<char_class>\\S {
        -:  373:
        -:  374:  int i;
        -:  375:
    #####:  376:  for (i = 0; i < 32; i++)
        -:  377:  {
    #####:  378:    if (i == ' ' / 8)
    #####:  379:      LEX_ENV->re_class.bitmap[i] |= ~(1 << ' ' % 8);
    #####:  380:    else if (i == '\t' / 8)
    #####:  381:      LEX_ENV->re_class.bitmap[i] |= ~(1 << '\t' % 8);
        -:  382:    else
    #####:  383:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -:  384:  }
        -:  385:}
    #####:  386:
    #####:  387:
        -:  388:<char_class>\\d {
        -:  389:
        -:  390:  char c;
        -:  391:
    #####:  392:  for (c = '0'; c <= '9'; c++)
    #####:  393:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  394:}
    #####:  395:
    #####:  396:
        -:  397:<char_class>\\D {
        -:  398:
        -:  399:  int i;
        -:  400:
    #####:  401:  for (i = 0; i < 32; i++)
        -:  402:  {
        -:  403:    // digits 0-7 are in the sixth byte of the vector, let that byte alone
    #####:  404:    if (i == 6)
    #####:  405:      continue;
        -:  406:
        -:  407:    // digits 8 and 9 are the lowest two bits in the seventh byte of the
        -:  408:    // vector, let those bits alone.
    #####:  409:    if (i == 7)
    #####:  410:      LEX_ENV->re_class.bitmap[i] |= 0xFC;
        -:  411:    else
    #####:  412:      LEX_ENV->re_class.bitmap[i] = 0xFF;
        -:  413:  }
        -:  414:}
    #####:  415:
    #####:  416:
        -:  417:<char_class>\\ {
        -:  418:
        -:  419:  uint8_t c;
        -:  420:
    #####:  421:  if (read_escaped_char(yyscanner, &c))
        -:  422:  {
    #####:  423:    LEX_ENV->re_class.bitmap[c / 8] |= 1 << c % 8;
        -:  424:  }
        -:  425:  else
        -:  426:  {
    #####:  427:    yyerror(yyscanner, lex_env, "illegal escape sequence");
    #####:  428:    yyterminate();
        -:  429:  }
        -:  430:}
    #####:  431:
    #####:  432:
        -:  433:<char_class>. {
        -:  434:
    #####:  435:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  436:  {
        -:  437:    // A character class (i.e: [0-9a-f]) is represented by a 256-bits vector,
        -:  438:    // here we set to 1 the vector's bit corresponding to the input character.
        -:  439:
    #####:  440:    LEX_ENV->re_class.bitmap[yytext[0] / 8] |= 1 << yytext[0] % 8;
        -:  441:  }
        -:  442:  else
        -:  443:  {
    #####:  444:    yyerror(yyscanner, lex_env, "non-ascii character");
    #####:  445:    yyterminate();
        -:  446:  }
        -:  447:}
    #####:  448:
    #####:  449:
        -:  450:<char_class><<EOF>> {
        -:  451:
        -:  452:  // End of regexp reached while scanning a character class.
        -:  453:
    #####:  454:  yyerror(yyscanner, lex_env, "missing terminating ] for character class");
    #####:  455:  yyterminate();
        -:  456:}
        -:  457:
    #####:  458:
        -:  459:. {
        -:  460:
    #####:  461:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  462:  {
    #####:  463:    return yytext[0];
        -:  464:  }
        -:  465:  else
        -:  466:  {
    #####:  467:    yyerror(yyscanner, lex_env, "non-ascii character");
    #####:  468:    yyterminate();
        -:  469:  }
        -:  470:}
        -:  471:
    #####:  472:
        -:  473:<<EOF>> {
        -:  474:
    #####:  475:  yyterminate();
        -:  476:}
        -:  477:
    #####:  478:%%
    #####:  479:
    #####:  480:int escaped_char_value(
        -:  481:    char* text,
        -:  482:    uint8_t* value)
        -:  483:{
        -:  484:  unsigned int hex_value;
        -:  485:  char hex[3];
        -:  486:
    #####:  487:  assert(text[0] == '\\');
        -:  488:
    #####:  489:  switch(text[1])
        -:  490:  {
    #####:  491:  case 'x':
    #####:  492:    if (!isxdigit(text[2]) || !isxdigit(text[3]))
    #####:  493:      return 0;
    #####:  494:    hex[0] = text[2];
    #####:  495:    hex[1] = text[3];
    #####:  496:    hex[2] = '\0';
    #####:  497:    sscanf(hex, "%x", &hex_value);
    #####:  498:    *value = (uint8_t) hex_value;
    #####:  499:    break;
        -:  500:
    #####:  501:  case 'n':
    #####:  502:    *value = '\n';
    #####:  503:    break;
        -:  504:
    #####:  505:  case 't':
    #####:  506:    *value = '\t';
    #####:  507:    break;
        -:  508:
    #####:  509:  case 'r':
    #####:  510:    *value = '\r';
    #####:  511:    break;
        -:  512:
    #####:  513:  case 'f':
    #####:  514:    *value = '\f';
    #####:  515:    break;
        -:  516:
    #####:  517:  case 'a':
    #####:  518:    *value = '\a';
    #####:  519:    break;
        -:  520:
    #####:  521:  default:
    #####:  522:    *value = text[1];
        -:  523:  }
        -:  524:
    #####:  525:  return 1;
        -:  526:}
        -:  527:
        -:  528:
        -:  529:#ifdef __cplusplus
        -:  530:#define RE_YY_INPUT yyinput
        -:  531:#else
        -:  532:#define RE_YY_INPUT input
        -:  533:#endif
        -:  534:
        -:  535:
    #####:  536:int read_escaped_char(
        -:  537:    yyscan_t yyscanner,
        -:  538:    uint8_t* escaped_char)
        -:  539:{
    #####:  540:  char text[4] = {0, 0, 0, 0};
        -:  541:
    #####:  542:  text[0] = '\\';
    #####:  543:  text[1] = RE_YY_INPUT(yyscanner);
        -:  544:
    #####:  545:  if (text[1] == EOF || text[1] == 0)
    #####:  546:    return 0;
        -:  547:
    #####:  548:  if (text[1] == 'x')
        -:  549:  {
    #####:  550:    text[2] = RE_YY_INPUT(yyscanner);
        -:  551:
    #####:  552:    if (text[2] == EOF || text[2] == 0)
    #####:  553:      return 0;
        -:  554:
    #####:  555:    text[3] = RE_YY_INPUT(yyscanner);
        -:  556:
    #####:  557:    if (text[3] == EOF || text[3] == 0)
    #####:  558:      return 0;
        -:  559:  }
        -:  560:
    #####:  561:  return escaped_char_value(text, escaped_char);
        -:  562:}
        -:  563:
        -:  564:
    #####:  565:void yyfatal(
        -:  566:    yyscan_t yyscanner,
        -:  567:    const char *error_message)
        -:  568:{
    #####:  569:  jmp_buf* recovery_state = (jmp_buf*) yr_thread_storage_get_value(
        -:  570:      &yr_recovery_state_key);
        -:  571:
    #####:  572:  longjmp(*recovery_state, 1);
        -:  573:}
        -:  574:
        -:  575:
    #####:  576:void yyerror(
        -:  577:    yyscan_t yyscanner,
        -:  578:    RE_LEX_ENVIRONMENT* lex_env,
        -:  579:    const char *error_message)
        -:  580:{
        -:  581:  // if lex_env->last_error was set to some error code before
        -:  582:  // don't overwrite it, we are interested in the first error, not in
        -:  583:  // subsequent errors like "syntax error, unexpected $end" caused by
        -:  584:  // early parser termination.
        -:  585:
    #####:  586:  if (lex_env->last_error == ERROR_SUCCESS)
        -:  587:  {
    #####:  588:    lex_env->last_error = ERROR_INVALID_REGULAR_EXPRESSION;
        -:  589:
    #####:  590:    strlcpy(
    #####:  591:        lex_env->last_error_message,
        -:  592:        error_message,
        -:  593:        sizeof(lex_env->last_error_message));
        -:  594:  }
    #####:  595:}
        -:  596:
        -:  597:
    #####:  598:int yr_parse_re_string(
        -:  599:  const char* re_string,
        -:  600:  RE_AST** re_ast,
        -:  601:  RE_ERROR* error)
        -:  602:{
        -:  603:  yyscan_t yyscanner;
        -:  604:  jmp_buf recovery_state;
        -:  605:  RE_LEX_ENVIRONMENT lex_env;
        -:  606:
    #####:  607:  lex_env.last_error = ERROR_SUCCESS;
    #####:  608:  lex_env.last_error_message[0] = '\0';
        -:  609:
    #####:  610:  yr_thread_storage_set_value(&yr_recovery_state_key, &recovery_state);
        -:  611:
    #####:  612:  if (setjmp(recovery_state) != 0)
    #####:  613:    return ERROR_INTERNAL_FATAL_ERROR;
        -:  614:
    #####:  615:  FAIL_ON_ERROR(yr_re_ast_create(re_ast));
        -:  616:
    #####:  617:  yylex_init(&yyscanner);
    #####:  618:  yyset_extra(*re_ast, yyscanner);
    #####:  619:  yy_scan_string(re_string, yyscanner);
    #####:  620:  yyparse(yyscanner, &lex_env);
    #####:  621:  yylex_destroy(yyscanner);
        -:  622:
    #####:  623:  if (lex_env.last_error != ERROR_SUCCESS)
        -:  624:  {
    #####:  625:    yr_re_ast_destroy(*re_ast);
    #####:  626:    *re_ast = NULL;
        -:  627:
    #####:  628:    strlcpy(
    #####:  629:        error->message,
        -:  630:        lex_env.last_error_message,
        -:  631:        sizeof(error->message));
        -:  632:
    #####:  633:    return lex_env.last_error;
        -:  634:  }
        -:  635:
    #####:  636:  return ERROR_SUCCESS;
        -:  637:}
