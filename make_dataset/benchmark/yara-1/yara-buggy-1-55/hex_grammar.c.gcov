        -:    0:Source:hex_grammar.c
        -:    0:Graph:/home/workspace/libyara/hex_grammar.gcno
        -:    0:Data:/home/workspace/libyara/hex_grammar.gcda
        -:    0:Runs:6
        -:    1:/* A Bison parser, made by GNU Bison 3.5.1.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
        -:    6:   Inc.
        -:    7:
        -:    8:   This program is free software: you can redistribute it and/or modify
        -:    9:   it under the terms of the GNU General Public License as published by
        -:   10:   the Free Software Foundation, either version 3 of the License, or
        -:   11:   (at your option) any later version.
        -:   12:
        -:   13:   This program is distributed in the hope that it will be useful,
        -:   14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:   GNU General Public License for more details.
        -:   17:
        -:   18:   You should have received a copy of the GNU General Public License
        -:   19:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   20:
        -:   21:/* As a special exception, you may create a larger work that contains
        -:   22:   part or all of the Bison parser skeleton and distribute that work
        -:   23:   under terms of your choice, so long as that work isn't itself a
        -:   24:   parser generator using the skeleton or a modified version thereof
        -:   25:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   26:   the parser skeleton itself, you may (at your option) remove this
        -:   27:   special exception, which will cause the skeleton and the resulting
        -:   28:   Bison output files to be licensed under the GNU General Public
        -:   29:   License without this special exception.
        -:   30:
        -:   31:   This special exception was added by the Free Software Foundation in
        -:   32:   version 2.2 of Bison.  */
        -:   33:
        -:   34:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   35:   simplifying the original so-called "semantic" parser.  */
        -:   36:
        -:   37:/* All symbols defined below should begin with yy or YY, to avoid
        -:   38:   infringing on user name space.  This should be done even for local
        -:   39:   variables, as they might otherwise be expanded by user macros.
        -:   40:   There are some unavoidable exceptions within include files to
        -:   41:   define necessary library symbols; they are noted "INFRINGES ON
        -:   42:   USER NAME SPACE" below.  */
        -:   43:
        -:   44:/* Undocumented macros, especially those whose name start with YY_,
        -:   45:   are private implementation details.  Do not rely on them.  */
        -:   46:
        -:   47:/* Identify Bison output.  */
        -:   48:#define YYBISON 1
        -:   49:
        -:   50:/* Bison version.  */
        -:   51:#define YYBISON_VERSION "3.5.1"
        -:   52:
        -:   53:/* Skeleton name.  */
        -:   54:#define YYSKELETON_NAME "yacc.c"
        -:   55:
        -:   56:/* Pure parsers.  */
        -:   57:#define YYPURE 1
        -:   58:
        -:   59:/* Push parsers.  */
        -:   60:#define YYPUSH 0
        -:   61:
        -:   62:/* Pull parsers.  */
        -:   63:#define YYPULL 1
        -:   64:
        -:   65:
        -:   66:/* Substitute the variable and function names.  */
        -:   67:#define yyparse         hex_yyparse
        -:   68:#define yylex           hex_yylex
        -:   69:#define yyerror         hex_yyerror
        -:   70:#define yydebug         hex_yydebug
        -:   71:#define yynerrs         hex_yynerrs
        -:   72:
        -:   73:/* First part of user prologue.  */
        -:   74:#line 30 "hex_grammar.y"
        -:   75:
        -:   76:
        -:   77:#include <string.h>
        -:   78:#include <limits.h>
        -:   79:#include <stdbool.h>
        -:   80:
        -:   81:#include <yara/integers.h>
        -:   82:#include <yara/utils.h>
        -:   83:#include <yara/hex_lexer.h>
        -:   84:#include <yara/limits.h>
        -:   85:#include <yara/mem.h>
        -:   86:#include <yara/error.h>
        -:   87:
        -:   88:
        -:   89:#define STR_EXPAND(tok) #tok
        -:   90:#define STR(tok) STR_EXPAND(tok)
        -:   91:
        -:   92:#define YYERROR_VERBOSE
        -:   93:
        -:   94:#define YYMALLOC yr_malloc
        -:   95:#define YYFREE yr_free
        -:   96:
        -:   97:#define mark_as_not_fast_regexp() \
        -:   98:    ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP
        -:   99:
        -:  100:#define fail_if_too_many_ast_levels(cleanup_code) \
        -:  101:    if (((RE_AST*) yyget_extra(yyscanner))->levels++ > RE_MAX_AST_LEVELS) \
        -:  102:    { \
        -:  103:      { cleanup_code } \
        -:  104:      yyerror(yyscanner, lex_env, "string too long"); \
        -:  105:      YYABORT; \
        -:  106:    }
        -:  107:
        -:  108:#define fail_if(x, error) \
        -:  109:    if (x) \
        -:  110:    { \
        -:  111:      lex_env->last_error = error; \
        -:  112:      YYABORT; \
        -:  113:    } \
        -:  114:
        -:  115:#define destroy_node_if(x, node) \
        -:  116:    if (x) \
        -:  117:    { \
        -:  118:      yr_re_node_destroy(node); \
        -:  119:    } \
        -:  120:
        -:  121:
        -:  122:#line 123 "hex_grammar.c"
        -:  123:
        -:  124:# ifndef YY_CAST
        -:  125:#  ifdef __cplusplus
        -:  126:#   define YY_CAST(Type, Val) static_cast<Type> (Val)
        -:  127:#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
        -:  128:#  else
        -:  129:#   define YY_CAST(Type, Val) ((Type) (Val))
        -:  130:#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
        -:  131:#  endif
        -:  132:# endif
        -:  133:# ifndef YY_NULLPTR
        -:  134:#  if defined __cplusplus
        -:  135:#   if 201103L <= __cplusplus
        -:  136:#    define YY_NULLPTR nullptr
        -:  137:#   else
        -:  138:#    define YY_NULLPTR 0
        -:  139:#   endif
        -:  140:#  else
        -:  141:#   define YY_NULLPTR ((void*)0)
        -:  142:#  endif
        -:  143:# endif
        -:  144:
        -:  145:/* Enabling verbose error messages.  */
        -:  146:#ifdef YYERROR_VERBOSE
        -:  147:# undef YYERROR_VERBOSE
        -:  148:# define YYERROR_VERBOSE 1
        -:  149:#else
        -:  150:# define YYERROR_VERBOSE 0
        -:  151:#endif
        -:  152:
        -:  153:/* Use api.header.include to #include this header
        -:  154:   instead of duplicating it here.  */
        -:  155:#ifndef YY_HEX_YY_HEX_GRAMMAR_H_INCLUDED
        -:  156:# define YY_HEX_YY_HEX_GRAMMAR_H_INCLUDED
        -:  157:/* Debug traces.  */
        -:  158:#ifndef YYDEBUG
        -:  159:# define YYDEBUG 0
        -:  160:#endif
        -:  161:#if YYDEBUG
        -:  162:extern int hex_yydebug;
        -:  163:#endif
        -:  164:
        -:  165:/* Token type.  */
        -:  166:#ifndef YYTOKENTYPE
        -:  167:# define YYTOKENTYPE
        -:  168:  enum yytokentype
        -:  169:  {
        -:  170:    _BYTE_ = 258,
        -:  171:    _MASKED_BYTE_ = 259,
        -:  172:    _NUMBER_ = 260
        -:  173:  };
        -:  174:#endif
        -:  175:/* Tokens.  */
        -:  176:#define _BYTE_ 258
        -:  177:#define _MASKED_BYTE_ 259
        -:  178:#define _NUMBER_ 260
        -:  179:
        -:  180:/* Value type.  */
        -:  181:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  182:union YYSTYPE
        -:  183:{
        -:  184:#line 87 "hex_grammar.y"
        -:  185:
        -:  186:  int64_t integer;
        -:  187:  RE_NODE *re_node;
        -:  188:
        -:  189:#line 190 "hex_grammar.c"
        -:  190:
        -:  191:};
        -:  192:typedef union YYSTYPE YYSTYPE;
        -:  193:# define YYSTYPE_IS_TRIVIAL 1
        -:  194:# define YYSTYPE_IS_DECLARED 1
        -:  195:#endif
        -:  196:
        -:  197:
        -:  198:
        -:  199:int hex_yyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env);
        -:  200:
        -:  201:#endif /* !YY_HEX_YY_HEX_GRAMMAR_H_INCLUDED  */
        -:  202:
        -:  203:
        -:  204:
        -:  205:#ifdef short
        -:  206:# undef short
        -:  207:#endif
        -:  208:
        -:  209:/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
        -:  210:   <limits.h> and (if available) <stdint.h> are included
        -:  211:   so that the code can choose integer types of a good width.  */
        -:  212:
        -:  213:#ifndef __PTRDIFF_MAX__
        -:  214:# include <limits.h> /* INFRINGES ON USER NAME SPACE */
        -:  215:# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  216:#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
        -:  217:#  define YY_STDINT_H
        -:  218:# endif
        -:  219:#endif
        -:  220:
        -:  221:/* Narrow types that promote to a signed type and that can represent a
        -:  222:   signed or unsigned integer of at least N bits.  In tables they can
        -:  223:   save space and decrease cache pressure.  Promoting to a signed type
        -:  224:   helps avoid bugs in integer arithmetic.  */
        -:  225:
        -:  226:#ifdef __INT_LEAST8_MAX__
        -:  227:typedef __INT_LEAST8_TYPE__ yytype_int8;
        -:  228:#elif defined YY_STDINT_H
        -:  229:typedef int_least8_t yytype_int8;
        -:  230:#else
        -:  231:typedef signed char yytype_int8;
        -:  232:#endif
        -:  233:
        -:  234:#ifdef __INT_LEAST16_MAX__
        -:  235:typedef __INT_LEAST16_TYPE__ yytype_int16;
        -:  236:#elif defined YY_STDINT_H
        -:  237:typedef int_least16_t yytype_int16;
        -:  238:#else
        -:  239:typedef short yytype_int16;
        -:  240:#endif
        -:  241:
        -:  242:#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
        -:  243:typedef __UINT_LEAST8_TYPE__ yytype_uint8;
        -:  244:#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
        -:  245:       && UINT_LEAST8_MAX <= INT_MAX)
        -:  246:typedef uint_least8_t yytype_uint8;
        -:  247:#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
        -:  248:typedef unsigned char yytype_uint8;
        -:  249:#else
        -:  250:typedef short yytype_uint8;
        -:  251:#endif
        -:  252:
        -:  253:#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
        -:  254:typedef __UINT_LEAST16_TYPE__ yytype_uint16;
        -:  255:#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
        -:  256:       && UINT_LEAST16_MAX <= INT_MAX)
        -:  257:typedef uint_least16_t yytype_uint16;
        -:  258:#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
        -:  259:typedef unsigned short yytype_uint16;
        -:  260:#else
        -:  261:typedef int yytype_uint16;
        -:  262:#endif
        -:  263:
        -:  264:#ifndef YYPTRDIFF_T
        -:  265:# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
        -:  266:#  define YYPTRDIFF_T __PTRDIFF_TYPE__
        -:  267:#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
        -:  268:# elif defined PTRDIFF_MAX
        -:  269:#  ifndef ptrdiff_t
        -:  270:#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  271:#  endif
        -:  272:#  define YYPTRDIFF_T ptrdiff_t
        -:  273:#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
        -:  274:# else
        -:  275:#  define YYPTRDIFF_T long
        -:  276:#  define YYPTRDIFF_MAXIMUM LONG_MAX
        -:  277:# endif
        -:  278:#endif
        -:  279:
        -:  280:#ifndef YYSIZE_T
        -:  281:# ifdef __SIZE_TYPE__
        -:  282:#  define YYSIZE_T __SIZE_TYPE__
        -:  283:# elif defined size_t
        -:  284:#  define YYSIZE_T size_t
        -:  285:# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  286:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  287:#  define YYSIZE_T size_t
        -:  288:# else
        -:  289:#  define YYSIZE_T unsigned
        -:  290:# endif
        -:  291:#endif
        -:  292:
        -:  293:#define YYSIZE_MAXIMUM                                  \
        -:  294:  YY_CAST (YYPTRDIFF_T,                                 \
        -:  295:           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
        -:  296:            ? YYPTRDIFF_MAXIMUM                         \
        -:  297:            : YY_CAST (YYSIZE_T, -1)))
        -:  298:
        -:  299:#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
        -:  300:
        -:  301:/* Stored state numbers (used for stacks). */
        -:  302:typedef yytype_int8 yy_state_t;
        -:  303:
        -:  304:/* State numbers in computations.  */
        -:  305:typedef int yy_state_fast_t;
        -:  306:
        -:  307:#ifndef YY_
        -:  308:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  309:#  if ENABLE_NLS
        -:  310:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  311:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  312:#  endif
        -:  313:# endif
        -:  314:# ifndef YY_
        -:  315:#  define YY_(Msgid) Msgid
        -:  316:# endif
        -:  317:#endif
        -:  318:
        -:  319:#ifndef YY_ATTRIBUTE_PURE
        -:  320:# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
        -:  321:#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
        -:  322:# else
        -:  323:#  define YY_ATTRIBUTE_PURE
        -:  324:# endif
        -:  325:#endif
        -:  326:
        -:  327:#ifndef YY_ATTRIBUTE_UNUSED
        -:  328:# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
        -:  329:#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  330:# else
        -:  331:#  define YY_ATTRIBUTE_UNUSED
        -:  332:# endif
        -:  333:#endif
        -:  334:
        -:  335:/* Suppress unused-variable warnings by "using" E.  */
        -:  336:#if ! defined lint || defined __GNUC__
        -:  337:# define YYUSE(E) ((void) (E))
        -:  338:#else
        -:  339:# define YYUSE(E) /* empty */
        -:  340:#endif
        -:  341:
        -:  342:#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  343:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  344:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
        -:  345:    _Pragma ("GCC diagnostic push")                                     \
        -:  346:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
        -:  347:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  348:# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
        -:  349:    _Pragma ("GCC diagnostic pop")
        -:  350:#else
        -:  351:# define YY_INITIAL_VALUE(Value) Value
        -:  352:#endif
        -:  353:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  354:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  355:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  356:#endif
        -:  357:#ifndef YY_INITIAL_VALUE
        -:  358:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  359:#endif
        -:  360:
        -:  361:#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
        -:  362:# define YY_IGNORE_USELESS_CAST_BEGIN                          \
        -:  363:    _Pragma ("GCC diagnostic push")                            \
        -:  364:    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
        -:  365:# define YY_IGNORE_USELESS_CAST_END            \
        -:  366:    _Pragma ("GCC diagnostic pop")
        -:  367:#endif
        -:  368:#ifndef YY_IGNORE_USELESS_CAST_BEGIN
        -:  369:# define YY_IGNORE_USELESS_CAST_BEGIN
        -:  370:# define YY_IGNORE_USELESS_CAST_END
        -:  371:#endif
        -:  372:
        -:  373:
        -:  374:#define YY_ASSERT(E) ((void) (0 && (E)))
        -:  375:
        -:  376:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  377:
        -:  378:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  379:
        -:  380:# ifdef YYSTACK_USE_ALLOCA
        -:  381:#  if YYSTACK_USE_ALLOCA
        -:  382:#   ifdef __GNUC__
        -:  383:#    define YYSTACK_ALLOC __builtin_alloca
        -:  384:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  385:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  386:#   elif defined _AIX
        -:  387:#    define YYSTACK_ALLOC __alloca
        -:  388:#   elif defined _MSC_VER
        -:  389:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  390:#    define alloca _alloca
        -:  391:#   else
        -:  392:#    define YYSTACK_ALLOC alloca
        -:  393:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  394:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  395:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  396:#     ifndef EXIT_SUCCESS
        -:  397:#      define EXIT_SUCCESS 0
        -:  398:#     endif
        -:  399:#    endif
        -:  400:#   endif
        -:  401:#  endif
        -:  402:# endif
        -:  403:
        -:  404:# ifdef YYSTACK_ALLOC
        -:  405:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  406:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  407:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  408:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  409:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  410:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  411:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  412:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  413:#  endif
        -:  414:# else
        -:  415:#  define YYSTACK_ALLOC YYMALLOC
        -:  416:#  define YYSTACK_FREE YYFREE
        -:  417:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  418:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  419:#  endif
        -:  420:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  421:       && ! ((defined YYMALLOC || defined malloc) \
        -:  422:             && (defined YYFREE || defined free)))
        -:  423:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  424:#   ifndef EXIT_SUCCESS
        -:  425:#    define EXIT_SUCCESS 0
        -:  426:#   endif
        -:  427:#  endif
        -:  428:#  ifndef YYMALLOC
        -:  429:#   define YYMALLOC malloc
        -:  430:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  431:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  432:#   endif
        -:  433:#  endif
        -:  434:#  ifndef YYFREE
        -:  435:#   define YYFREE free
        -:  436:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  437:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  438:#   endif
        -:  439:#  endif
        -:  440:# endif
        -:  441:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  442:
        -:  443:
        -:  444:#if (! defined yyoverflow \
        -:  445:     && (! defined __cplusplus \
        -:  446:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  447:
        -:  448:/* A type that is properly aligned for any stack member.  */
        -:  449:union yyalloc
        -:  450:{
        -:  451:  yy_state_t yyss_alloc;
        -:  452:  YYSTYPE yyvs_alloc;
        -:  453:};
        -:  454:
        -:  455:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  456:# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
        -:  457:
        -:  458:/* The size of an array large to enough to hold all stacks, each with
        -:  459:   N elements.  */
        -:  460:# define YYSTACK_BYTES(N) \
        -:  461:     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
        -:  462:      + YYSTACK_GAP_MAXIMUM)
        -:  463:
        -:  464:# define YYCOPY_NEEDED 1
        -:  465:
        -:  466:/* Relocate STACK from its old location to the new one.  The
        -:  467:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  468:   elements in the stack, and YYPTR gives the new location of the
        -:  469:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  470:   stack.  */
        -:  471:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  472:    do                                                                  \
        -:  473:      {                                                                 \
        -:  474:        YYPTRDIFF_T yynewbytes;                                         \
        -:  475:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  476:        Stack = &yyptr->Stack_alloc;                                    \
        -:  477:        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  478:        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
        -:  479:      }                                                                 \
        -:  480:    while (0)
        -:  481:
        -:  482:#endif
        -:  483:
        -:  484:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  485:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  486:   not overlap.  */
        -:  487:# ifndef YYCOPY
        -:  488:#  if defined __GNUC__ && 1 < __GNUC__
        -:  489:#   define YYCOPY(Dst, Src, Count) \
        -:  490:      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
        -:  491:#  else
        -:  492:#   define YYCOPY(Dst, Src, Count)              \
        -:  493:      do                                        \
        -:  494:        {                                       \
        -:  495:          YYPTRDIFF_T yyi;                      \
        -:  496:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  497:            (Dst)[yyi] = (Src)[yyi];            \
        -:  498:        }                                       \
        -:  499:      while (0)
        -:  500:#  endif
        -:  501:# endif
        -:  502:#endif /* !YYCOPY_NEEDED */
        -:  503:
        -:  504:/* YYFINAL -- State number of the termination state.  */
        -:  505:#define YYFINAL  9
        -:  506:/* YYLAST -- Last index in YYTABLE.  */
        -:  507:#define YYLAST   30
        -:  508:
        -:  509:/* YYNTOKENS -- Number of terminals.  */
        -:  510:#define YYNTOKENS  14
        -:  511:/* YYNNTS -- Number of nonterminals.  */
        -:  512:#define YYNNTS  10
        -:  513:/* YYNRULES -- Number of rules.  */
        -:  514:#define YYNRULES  20
        -:  515:/* YYNSTATES -- Number of states.  */
        -:  516:#define YYNSTATES  32
        -:  517:
        -:  518:#define YYUNDEFTOK  2
        -:  519:#define YYMAXUTOK   260
        -:  520:
        -:  521:
        -:  522:/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
        -:  523:   as returned by yylex, with out-of-bounds checking.  */
        -:  524:#define YYTRANSLATE(YYX)                                                \
        -:  525:  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  526:
        -:  527:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  528:   as returned by yylex.  */
        -:  529:static const yytype_int8 yytranslate[] =
        -:  530:{
        -:  531:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  532:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  533:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  534:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  535:       8,     9,     2,     2,     2,    12,     2,     2,     2,     2,
        -:  536:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  537:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  538:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  539:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  540:       2,    10,     2,    11,     2,     2,     2,     2,     2,     2,
        -:  541:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  542:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  543:       2,     2,     2,     6,    13,     7,     2,     2,     2,     2,
        -:  544:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  545:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  546:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  547:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  548:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  549:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  550:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  551:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  552:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  553:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  554:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  555:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  556:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  557:       5
        -:  558:};
        -:  559:
        -:  560:#if YYDEBUG
        -:  561:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  562:static const yytype_int16 yyrline[] =
        -:  563:{
        -:  564:       0,   114,   114,   123,   127,   141,   209,   213,   231,   235,
        -:  565:     244,   249,   248,   261,   284,   316,   338,   358,   362,   381,
        -:  566:     389
        -:  567:};
        -:  568:#endif
        -:  569:
        -:  570:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  571:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  572:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  573:static const char *const yytname[] =
        -:  574:{
        -:  575:  "$end", "error", "$undefined", "_BYTE_", "_MASKED_BYTE_", "_NUMBER_",
        -:  576:  "'{'", "'}'", "'('", "')'", "'['", "']'", "'-'", "'|'", "$accept",
        -:  577:  "hex_string", "tokens", "token_sequence", "token_or_range", "token",
        -:  578:  "$@1", "range", "alternatives", "byte", YY_NULLPTR
        -:  579:};
        -:  580:#endif
        -:  581:
        -:  582:# ifdef YYPRINT
        -:  583:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  584:   (internal) symbol number NUM (which must be that of a token).  */
        -:  585:static const yytype_int16 yytoknum[] =
        -:  586:{
        -:  587:       0,   256,   257,   258,   259,   260,   123,   125,    40,    41,
        -:  588:      91,    93,    45,   124
        -:  589:};
        -:  590:# endif
        -:  591:
        -:  592:#define YYPACT_NINF (-11)
        -:  593:
        -:  594:#define yypact_value_is_default(Yyn) \
        -:  595:  ((Yyn) == YYPACT_NINF)
        -:  596:
        -:  597:#define YYTABLE_NINF (-6)
        -:  598:
        -:  599:#define yytable_value_is_error(Yyn) \
        -:  600:  0
        -:  601:
        -:  602:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  603:     STATE-NUM.  */
        -:  604:static const yytype_int8 yypact[] =
        -:  605:{
        -:  606:      20,    14,    27,   -11,   -11,   -11,    21,    -2,   -11,   -11,
        -:  607:      14,   -11,    -1,    -2,   -11,    -4,   -11,   -11,    10,    13,
        -:  608:       9,   -11,     3,   -11,    14,   -11,     2,   -11,   -11,    18,
        -:  609:     -11,   -11
        -:  610:};
        -:  611:
        -:  612:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  613:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  614:     means the default is an error.  */
        -:  615:static const yytype_int8 yydefact[] =
        -:  616:{
        -:  617:       0,     0,     0,    19,    20,    11,     0,     3,    10,     1,
        -:  618:       0,     2,     0,     0,     6,     8,     9,    17,     0,     0,
        -:  619:       0,     7,     8,    12,     0,    13,     0,    16,    18,     0,
        -:  620:      15,    14
        -:  621:};
        -:  622:
        -:  623:  /* YYPGOTO[NTERM-NUM].  */
        -:  624:static const yytype_int8 yypgoto[] =
        -:  625:{
        -:  626:     -11,   -11,   -10,   -11,    17,     8,   -11,   -11,   -11,   -11
        -:  627:};
        -:  628:
        -:  629:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  630:static const yytype_int8 yydefgoto[] =
        -:  631:{
        -:  632:      -1,     2,     6,    13,    14,     7,    10,    16,    18,     8
        -:  633:};
        -:  634:
        -:  635:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  636:     positive, shift that token.  If negative, reduce the rule whose
        -:  637:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  638:static const yytype_int8 yytable[] =
        -:  639:{
        -:  640:      17,     3,     4,    -4,    19,    -4,     5,    29,    12,    -4,
        -:  641:      -5,    20,    -5,    30,    28,    15,    -5,     3,     4,    23,
        -:  642:      27,    22,     5,    24,    25,    26,     1,     9,    11,    31,
        -:  643:      21
        -:  644:};
        -:  645:
        -:  646:static const yytype_int8 yycheck[] =
        -:  647:{
        -:  648:      10,     3,     4,     7,     5,     9,     8,     5,    10,    13,
        -:  649:       7,    12,     9,    11,    24,     7,    13,     3,     4,     9,
        -:  650:      11,    13,     8,    13,    11,    12,     6,     0,     7,    11,
        -:  651:      13
        -:  652:};
        -:  653:
        -:  654:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  655:     symbol of state STATE-NUM.  */
        -:  656:static const yytype_int8 yystos[] =
        -:  657:{
        -:  658:       0,     6,    15,     3,     4,     8,    16,    19,    23,     0,
        -:  659:      20,     7,    10,    17,    18,    19,    21,    16,    22,     5,
        -:  660:      12,    18,    19,     9,    13,    11,    12,    11,    16,     5,
        -:  661:      11,    11
        -:  662:};
        -:  663:
        -:  664:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  665:static const yytype_int8 yyr1[] =
        -:  666:{
        -:  667:       0,    14,    15,    16,    16,    16,    17,    17,    18,    18,
        -:  668:      19,    20,    19,    21,    21,    21,    21,    22,    22,    23,
        -:  669:      23
        -:  670:};
        -:  671:
        -:  672:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  673:static const yytype_int8 yyr2[] =
        -:  674:{
        -:  675:       0,     2,     3,     1,     2,     3,     1,     2,     1,     1,
        -:  676:       1,     0,     4,     3,     5,     4,     3,     1,     3,     1,
        -:  677:       1
        -:  678:};
        -:  679:
        -:  680:
        -:  681:#define yyerrok         (yyerrstatus = 0)
        -:  682:#define yyclearin       (yychar = YYEMPTY)
        -:  683:#define YYEMPTY         (-2)
        -:  684:#define YYEOF           0
        -:  685:
        -:  686:#define YYACCEPT        goto yyacceptlab
        -:  687:#define YYABORT         goto yyabortlab
        -:  688:#define YYERROR         goto yyerrorlab
        -:  689:
        -:  690:
        -:  691:#define YYRECOVERING()  (!!yyerrstatus)
        -:  692:
        -:  693:#define YYBACKUP(Token, Value)                                    \
        -:  694:  do                                                              \
        -:  695:    if (yychar == YYEMPTY)                                        \
        -:  696:      {                                                           \
        -:  697:        yychar = (Token);                                         \
        -:  698:        yylval = (Value);                                         \
        -:  699:        YYPOPSTACK (yylen);                                       \
        -:  700:        yystate = *yyssp;                                         \
        -:  701:        goto yybackup;                                            \
        -:  702:      }                                                           \
        -:  703:    else                                                          \
        -:  704:      {                                                           \
        -:  705:        yyerror (yyscanner, lex_env, YY_("syntax error: cannot back up")); \
        -:  706:        YYERROR;                                                  \
        -:  707:      }                                                           \
        -:  708:  while (0)
        -:  709:
        -:  710:/* Error token number */
        -:  711:#define YYTERROR        1
        -:  712:#define YYERRCODE       256
        -:  713:
        -:  714:
        -:  715:
        -:  716:/* Enable debugging if requested.  */
        -:  717:#if YYDEBUG
        -:  718:
        -:  719:# ifndef YYFPRINTF
        -:  720:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -:  721:#  define YYFPRINTF fprintf
        -:  722:# endif
        -:  723:
        -:  724:# define YYDPRINTF(Args)                        \
        -:  725:do {                                            \
        -:  726:  if (yydebug)                                  \
        -:  727:    YYFPRINTF Args;                             \
        -:  728:} while (0)
        -:  729:
        -:  730:/* This macro is provided for backward compatibility. */
        -:  731:#ifndef YY_LOCATION_PRINT
        -:  732:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -:  733:#endif
        -:  734:
        -:  735:
        -:  736:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -:  737:do {                                                                      \
        -:  738:  if (yydebug)                                                            \
        -:  739:    {                                                                     \
        -:  740:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -:  741:      yy_symbol_print (stderr,                                            \
        -:  742:                  Type, Value, yyscanner, lex_env); \
        -:  743:      YYFPRINTF (stderr, "\n");                                           \
        -:  744:    }                                                                     \
        -:  745:} while (0)
        -:  746:
        -:  747:
        -:  748:/*-----------------------------------.
        -:  749:| Print this symbol's value on YYO.  |
        -:  750:`-----------------------------------*/
        -:  751:
        -:  752:static void
        -:  753:yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -:  754:{
        -:  755:  FILE *yyoutput = yyo;
        -:  756:  YYUSE (yyoutput);
        -:  757:  YYUSE (yyscanner);
        -:  758:  YYUSE (lex_env);
        -:  759:  if (!yyvaluep)
        -:  760:    return;
        -:  761:# ifdef YYPRINT
        -:  762:  if (yytype < YYNTOKENS)
        -:  763:    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
        -:  764:# endif
        -:  765:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  766:  YYUSE (yytype);
        -:  767:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  768:}
        -:  769:
        -:  770:
        -:  771:/*---------------------------.
        -:  772:| Print this symbol on YYO.  |
        -:  773:`---------------------------*/
        -:  774:
        -:  775:static void
        -:  776:yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -:  777:{
        -:  778:  YYFPRINTF (yyo, "%s %s (",
        -:  779:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -:  780:
        -:  781:  yy_symbol_value_print (yyo, yytype, yyvaluep, yyscanner, lex_env);
        -:  782:  YYFPRINTF (yyo, ")");
        -:  783:}
        -:  784:
        -:  785:/*------------------------------------------------------------------.
        -:  786:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -:  787:| TOP (included).                                                   |
        -:  788:`------------------------------------------------------------------*/
        -:  789:
        -:  790:static void
        -:  791:yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
        -:  792:{
        -:  793:  YYFPRINTF (stderr, "Stack now");
        -:  794:  for (; yybottom <= yytop; yybottom++)
        -:  795:    {
        -:  796:      int yybot = *yybottom;
        -:  797:      YYFPRINTF (stderr, " %d", yybot);
        -:  798:    }
        -:  799:  YYFPRINTF (stderr, "\n");
        -:  800:}
        -:  801:
        -:  802:# define YY_STACK_PRINT(Bottom, Top)                            \
        -:  803:do {                                                            \
        -:  804:  if (yydebug)                                                  \
        -:  805:    yy_stack_print ((Bottom), (Top));                           \
        -:  806:} while (0)
        -:  807:
        -:  808:
        -:  809:/*------------------------------------------------.
        -:  810:| Report that the YYRULE is going to be reduced.  |
        -:  811:`------------------------------------------------*/
        -:  812:
        -:  813:static void
        -:  814:yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -:  815:{
        -:  816:  int yylno = yyrline[yyrule];
        -:  817:  int yynrhs = yyr2[yyrule];
        -:  818:  int yyi;
        -:  819:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
        -:  820:             yyrule - 1, yylno);
        -:  821:  /* The symbols being reduced.  */
        -:  822:  for (yyi = 0; yyi < yynrhs; yyi++)
        -:  823:    {
        -:  824:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -:  825:      yy_symbol_print (stderr,
        -:  826:                       yystos[+yyssp[yyi + 1 - yynrhs]],
        -:  827:                       &yyvsp[(yyi + 1) - (yynrhs)]
        -:  828:                                              , yyscanner, lex_env);
        -:  829:      YYFPRINTF (stderr, "\n");
        -:  830:    }
        -:  831:}
        -:  832:
        -:  833:# define YY_REDUCE_PRINT(Rule)          \
        -:  834:do {                                    \
        -:  835:  if (yydebug)                          \
        -:  836:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, lex_env); \
        -:  837:} while (0)
        -:  838:
        -:  839:/* Nonzero means print parse trace.  It is left uninitialized so that
        -:  840:   multiple parsers can coexist.  */
        -:  841:int yydebug;
        -:  842:#else /* !YYDEBUG */
        -:  843:# define YYDPRINTF(Args)
        -:  844:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -:  845:# define YY_STACK_PRINT(Bottom, Top)
        -:  846:# define YY_REDUCE_PRINT(Rule)
        -:  847:#endif /* !YYDEBUG */
        -:  848:
        -:  849:
        -:  850:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -:  851:#ifndef YYINITDEPTH
        -:  852:# define YYINITDEPTH 200
        -:  853:#endif
        -:  854:
        -:  855:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -:  856:   if the built-in stack extension method is used).
        -:  857:
        -:  858:   Do not make this value too large; the results are undefined if
        -:  859:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -:  860:   evaluated with infinite-precision integer arithmetic.  */
        -:  861:
        -:  862:#ifndef YYMAXDEPTH
        -:  863:# define YYMAXDEPTH 10000
        -:  864:#endif
        -:  865:
        -:  866:
        -:  867:#if YYERROR_VERBOSE
        -:  868:
        -:  869:# ifndef yystrlen
        -:  870:#  if defined __GLIBC__ && defined _STRING_H
        -:  871:#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
        -:  872:#  else
        -:  873:/* Return the length of YYSTR.  */
        -:  874:static YYPTRDIFF_T
        -:  875:yystrlen (const char *yystr)
        -:  876:{
        -:  877:  YYPTRDIFF_T yylen;
        -:  878:  for (yylen = 0; yystr[yylen]; yylen++)
        -:  879:    continue;
        -:  880:  return yylen;
        -:  881:}
        -:  882:#  endif
        -:  883:# endif
        -:  884:
        -:  885:# ifndef yystpcpy
        -:  886:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -:  887:#   define yystpcpy stpcpy
        -:  888:#  else
        -:  889:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -:  890:   YYDEST.  */
        -:  891:static char *
    #####:  892:yystpcpy (char *yydest, const char *yysrc)
        -:  893:{
    #####:  894:  char *yyd = yydest;
    #####:  895:  const char *yys = yysrc;
        -:  896:
    #####:  897:  while ((*yyd++ = *yys++) != '\0')
    #####:  898:    continue;
        -:  899:
    #####:  900:  return yyd - 1;
        -:  901:}
        -:  902:#  endif
        -:  903:# endif
        -:  904:
        -:  905:# ifndef yytnamerr
        -:  906:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -:  907:   quotes and backslashes, so that it's suitable for yyerror.  The
        -:  908:   heuristic is that double-quoting is unnecessary unless the string
        -:  909:   contains an apostrophe, a comma, or backslash (other than
        -:  910:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -:  911:   null, do not copy; instead, return the length of what the result
        -:  912:   would have been.  */
        -:  913:static YYPTRDIFF_T
    #####:  914:yytnamerr (char *yyres, const char *yystr)
        -:  915:{
    #####:  916:  if (*yystr == '"')
        -:  917:    {
    #####:  918:      YYPTRDIFF_T yyn = 0;
    #####:  919:      char const *yyp = yystr;
        -:  920:
        -:  921:      for (;;)
    #####:  922:        switch (*++yyp)
        -:  923:          {
    #####:  924:          case '\'':
        -:  925:          case ',':
    #####:  926:            goto do_not_strip_quotes;
        -:  927:
    #####:  928:          case '\\':
    #####:  929:            if (*++yyp != '\\')
    #####:  930:              goto do_not_strip_quotes;
        -:  931:            else
    #####:  932:              goto append;
        -:  933:
    #####:  934:          append:
        -:  935:          default:
    #####:  936:            if (yyres)
    #####:  937:              yyres[yyn] = *yyp;
    #####:  938:            yyn++;
    #####:  939:            break;
        -:  940:
    #####:  941:          case '"':
    #####:  942:            if (yyres)
    #####:  943:              yyres[yyn] = '\0';
    #####:  944:            return yyn;
        -:  945:          }
    #####:  946:    do_not_strip_quotes: ;
        -:  947:    }
        -:  948:
    #####:  949:  if (yyres)
    #####:  950:    return yystpcpy (yyres, yystr) - yyres;
        -:  951:  else
    #####:  952:    return yystrlen (yystr);
        -:  953:}
        -:  954:# endif
        -:  955:
        -:  956:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -:  957:   about the unexpected token YYTOKEN for the state stack whose top is
        -:  958:   YYSSP.
        -:  959:
        -:  960:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -:  961:   not large enough to hold the message.  In that case, also set
        -:  962:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -:  963:   required number of bytes is too large to store.  */
        -:  964:static int
    #####:  965:yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
        -:  966:                yy_state_t *yyssp, int yytoken)
        -:  967:{
        -:  968:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -:  969:  /* Internationalized format string. */
    #####:  970:  const char *yyformat = YY_NULLPTR;
        -:  971:  /* Arguments of yyformat: reported tokens (one for the "unexpected",
        -:  972:     one per "expected"). */
        -:  973:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -:  974:  /* Actual size of YYARG. */
    #####:  975:  int yycount = 0;
        -:  976:  /* Cumulated lengths of YYARG.  */
    #####:  977:  YYPTRDIFF_T yysize = 0;
        -:  978:
        -:  979:  /* There are many possibilities here to consider:
        -:  980:     - If this state is a consistent state with a default action, then
        -:  981:       the only way this function was invoked is if the default action
        -:  982:       is an error action.  In that case, don't check for expected
        -:  983:       tokens because there are none.
        -:  984:     - The only way there can be no lookahead present (in yychar) is if
        -:  985:       this state is a consistent state with a default action.  Thus,
        -:  986:       detecting the absence of a lookahead is sufficient to determine
        -:  987:       that there is no unexpected or expected token to report.  In that
        -:  988:       case, just report a simple "syntax error".
        -:  989:     - Don't assume there isn't a lookahead just because this state is a
        -:  990:       consistent state with a default action.  There might have been a
        -:  991:       previous inconsistent state, consistent state with a non-default
        -:  992:       action, or user semantic action that manipulated yychar.
        -:  993:     - Of course, the expected token list depends on states to have
        -:  994:       correct lookahead information, and it depends on the parser not
        -:  995:       to perform extra reductions after fetching a lookahead from the
        -:  996:       scanner and before detecting a syntax error.  Thus, state merging
        -:  997:       (from LALR or IELR) and default reductions corrupt the expected
        -:  998:       token list.  However, the list is correct for canonical LR with
        -:  999:       one exception: it will still contain any token that will not be
        -: 1000:       accepted due to an error action in a later state.
        -: 1001:  */
    #####: 1002:  if (yytoken != YYEMPTY)
        -: 1003:    {
    #####: 1004:      int yyn = yypact[+*yyssp];
    #####: 1005:      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
    #####: 1006:      yysize = yysize0;
    #####: 1007:      yyarg[yycount++] = yytname[yytoken];
    #####: 1008:      if (!yypact_value_is_default (yyn))
        -: 1009:        {
        -: 1010:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1011:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1012:             this state because they are default actions.  */
    #####: 1013:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -: 1014:          /* Stay within bounds of both yycheck and yytname.  */
    #####: 1015:          int yychecklim = YYLAST - yyn + 1;
    #####: 1016:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1017:          int yyx;
        -: 1018:
    #####: 1019:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
    #####: 1020:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
    #####: 1021:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -: 1022:              {
    #####: 1023:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -: 1024:                  {
    #####: 1025:                    yycount = 1;
    #####: 1026:                    yysize = yysize0;
    #####: 1027:                    break;
        -: 1028:                  }
    #####: 1029:                yyarg[yycount++] = yytname[yyx];
        -: 1030:                {
    #####: 1031:                  YYPTRDIFF_T yysize1
    #####: 1032:                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
    #####: 1033:                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
    #####: 1034:                    yysize = yysize1;
        -: 1035:                  else
    #####: 1036:                    return 2;
        -: 1037:                }
        -: 1038:              }
        -: 1039:        }
        -: 1040:    }
        -: 1041:
    #####: 1042:  switch (yycount)
        -: 1043:    {
        -: 1044:# define YYCASE_(N, S)                      \
        -: 1045:      case N:                               \
        -: 1046:        yyformat = S;                       \
        -: 1047:      break
    #####: 1048:    default: /* Avoid compiler warnings. */
    #####: 1049:      YYCASE_(0, YY_("syntax error"));
    #####: 1050:      YYCASE_(1, YY_("syntax error, unexpected %s"));
    #####: 1051:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1052:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1053:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1054:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1055:# undef YYCASE_
        -: 1056:    }
        -: 1057:
        -: 1058:  {
        -: 1059:    /* Don't count the "%s"s in the final size, but reserve room for
        -: 1060:       the terminator.  */
    #####: 1061:    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
    #####: 1062:    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
    #####: 1063:      yysize = yysize1;
        -: 1064:    else
    #####: 1065:      return 2;
        -: 1066:  }
        -: 1067:
    #####: 1068:  if (*yymsg_alloc < yysize)
        -: 1069:    {
    #####: 1070:      *yymsg_alloc = 2 * yysize;
    #####: 1071:      if (! (yysize <= *yymsg_alloc
        -: 1072:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1073:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####: 1074:      return 1;
        -: 1075:    }
        -: 1076:
        -: 1077:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1078:     Don't have undefined behavior even if the translation
        -: 1079:     produced a string with the wrong number of "%s"s.  */
        -: 1080:  {
    #####: 1081:    char *yyp = *yymsg;
    #####: 1082:    int yyi = 0;
    #####: 1083:    while ((*yyp = *yyformat) != '\0')
    #####: 1084:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1085:        {
    #####: 1086:          yyp += yytnamerr (yyp, yyarg[yyi++]);
    #####: 1087:          yyformat += 2;
        -: 1088:        }
        -: 1089:      else
        -: 1090:        {
    #####: 1091:          ++yyp;
    #####: 1092:          ++yyformat;
        -: 1093:        }
        -: 1094:  }
    #####: 1095:  return 0;
        -: 1096:}
        -: 1097:#endif /* YYERROR_VERBOSE */
        -: 1098:
        -: 1099:/*-----------------------------------------------.
        -: 1100:| Release the memory associated to this symbol.  |
        -: 1101:`-----------------------------------------------*/
        -: 1102:
        -: 1103:static void
    #####: 1104:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -: 1105:{
        -: 1106:  YYUSE (yyvaluep);
        -: 1107:  YYUSE (yyscanner);
        -: 1108:  YYUSE (lex_env);
    #####: 1109:  if (!yymsg)
    #####: 1110:    yymsg = "Deleting";
        -: 1111:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1112:
        -: 1113:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1114:  switch (yytype)
        -: 1115:    {
    #####: 1116:    case 16: /* tokens  */
        -: 1117:#line 103 "hex_grammar.y"
        -: 1118:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1119:#line 1120 "hex_grammar.c"
    #####: 1120:        break;
        -: 1121:
    #####: 1122:    case 17: /* token_sequence  */
        -: 1123:#line 104 "hex_grammar.y"
        -: 1124:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1125:#line 1126 "hex_grammar.c"
    #####: 1126:        break;
        -: 1127:
    #####: 1128:    case 18: /* token_or_range  */
        -: 1129:#line 105 "hex_grammar.y"
        -: 1130:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1131:#line 1132 "hex_grammar.c"
    #####: 1132:        break;
        -: 1133:
    #####: 1134:    case 19: /* token  */
        -: 1135:#line 106 "hex_grammar.y"
        -: 1136:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1137:#line 1138 "hex_grammar.c"
    #####: 1138:        break;
        -: 1139:
    #####: 1140:    case 21: /* range  */
        -: 1141:#line 109 "hex_grammar.y"
        -: 1142:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1143:#line 1144 "hex_grammar.c"
    #####: 1144:        break;
        -: 1145:
    #####: 1146:    case 22: /* alternatives  */
        -: 1147:#line 108 "hex_grammar.y"
        -: 1148:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1149:#line 1150 "hex_grammar.c"
    #####: 1150:        break;
        -: 1151:
    #####: 1152:    case 23: /* byte  */
        -: 1153:#line 107 "hex_grammar.y"
        -: 1154:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1155:#line 1156 "hex_grammar.c"
    #####: 1156:        break;
        -: 1157:
    #####: 1158:      default:
    #####: 1159:        break;
        -: 1160:    }
        -: 1161:  YY_IGNORE_MAYBE_UNINITIALIZED_END
    #####: 1162:}
        -: 1163:
        -: 1164:
        -: 1165:
        -: 1166:
        -: 1167:/*----------.
        -: 1168:| yyparse.  |
        -: 1169:`----------*/
        -: 1170:
        -: 1171:int
    #####: 1172:yyparse (void *yyscanner, HEX_LEX_ENVIRONMENT *lex_env)
        -: 1173:{
        -: 1174:/* The lookahead symbol.  */
        -: 1175:int yychar;
        -: 1176:
        -: 1177:
        -: 1178:/* The semantic value of the lookahead symbol.  */
        -: 1179:/* Default value used for initialization, for pacifying older GCCs
        -: 1180:   or non-GCC compilers.  */
        -: 1181:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1182:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1183:
        -: 1184:    /* Number of syntax errors so far.  */
        -: 1185:    int yynerrs;
        -: 1186:
        -: 1187:    yy_state_fast_t yystate;
        -: 1188:    /* Number of tokens to shift before error messages enabled.  */
        -: 1189:    int yyerrstatus;
        -: 1190:
        -: 1191:    /* The stacks and their tools:
        -: 1192:       'yyss': related to states.
        -: 1193:       'yyvs': related to semantic values.
        -: 1194:
        -: 1195:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1196:       to reallocate them elsewhere.  */
        -: 1197:
        -: 1198:    /* The state stack.  */
        -: 1199:    yy_state_t yyssa[YYINITDEPTH];
        -: 1200:    yy_state_t *yyss;
        -: 1201:    yy_state_t *yyssp;
        -: 1202:
        -: 1203:    /* The semantic value stack.  */
        -: 1204:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1205:    YYSTYPE *yyvs;
        -: 1206:    YYSTYPE *yyvsp;
        -: 1207:
        -: 1208:    YYPTRDIFF_T yystacksize;
        -: 1209:
        -: 1210:  int yyn;
        -: 1211:  int yyresult;
        -: 1212:  /* Lookahead token as an internal (translated) token number.  */
    #####: 1213:  int yytoken = 0;
        -: 1214:  /* The variables used to return semantic value and location from the
        -: 1215:     action routines.  */
        -: 1216:  YYSTYPE yyval;
        -: 1217:
        -: 1218:#if YYERROR_VERBOSE
        -: 1219:  /* Buffer for error messages, and its allocated size.  */
        -: 1220:  char yymsgbuf[128];
    #####: 1221:  char *yymsg = yymsgbuf;
    #####: 1222:  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
        -: 1223:#endif
        -: 1224:
        -: 1225:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1226:
        -: 1227:  /* The number of symbols on the RHS of the reduced rule.
        -: 1228:     Keep to zero when no symbol should be popped.  */
    #####: 1229:  int yylen = 0;
        -: 1230:
    #####: 1231:  yyssp = yyss = yyssa;
    #####: 1232:  yyvsp = yyvs = yyvsa;
    #####: 1233:  yystacksize = YYINITDEPTH;
        -: 1234:
        -: 1235:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1236:
    #####: 1237:  yystate = 0;
    #####: 1238:  yyerrstatus = 0;
    #####: 1239:  yynerrs = 0;
    #####: 1240:  yychar = YYEMPTY; /* Cause a token to be read.  */
    #####: 1241:  goto yysetstate;
        -: 1242:
        -: 1243:
        -: 1244:/*------------------------------------------------------------.
        -: 1245:| yynewstate -- push a new state, which is found in yystate.  |
        -: 1246:`------------------------------------------------------------*/
    #####: 1247:yynewstate:
        -: 1248:  /* In all cases, when you get here, the value and location stacks
        -: 1249:     have just been pushed.  So pushing a state here evens the stacks.  */
    #####: 1250:  yyssp++;
        -: 1251:
        -: 1252:
        -: 1253:/*--------------------------------------------------------------------.
        -: 1254:| yysetstate -- set current state (the top of the stack) to yystate.  |
        -: 1255:`--------------------------------------------------------------------*/
    #####: 1256:yysetstate:
        -: 1257:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1258:  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
        -: 1259:  YY_IGNORE_USELESS_CAST_BEGIN
    #####: 1260:  *yyssp = YY_CAST (yy_state_t, yystate);
        -: 1261:  YY_IGNORE_USELESS_CAST_END
        -: 1262:
    #####: 1263:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1264:#if !defined yyoverflow && !defined YYSTACK_RELOCATE
        -: 1265:    goto yyexhaustedlab;
        -: 1266:#else
        -: 1267:    {
        -: 1268:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1269:      YYPTRDIFF_T yysize = yyssp - yyss + 1;
        -: 1270:
        -: 1271:# if defined yyoverflow
        -: 1272:      {
        -: 1273:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1274:           these so that the &'s don't force the real ones into
        -: 1275:           memory.  */
        -: 1276:        yy_state_t *yyss1 = yyss;
        -: 1277:        YYSTYPE *yyvs1 = yyvs;
        -: 1278:
        -: 1279:        /* Each stack pointer address is followed by the size of the
        -: 1280:           data in use in that stack, in bytes.  This used to be a
        -: 1281:           conditional around just the two extra args, but that might
        -: 1282:           be undefined if yyoverflow is a macro.  */
        -: 1283:        yyoverflow (YY_("memory exhausted"),
        -: 1284:                    &yyss1, yysize * YYSIZEOF (*yyssp),
        -: 1285:                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
        -: 1286:                    &yystacksize);
        -: 1287:        yyss = yyss1;
        -: 1288:        yyvs = yyvs1;
        -: 1289:      }
        -: 1290:# else /* defined YYSTACK_RELOCATE */
        -: 1291:      /* Extend the stack our own way.  */
    #####: 1292:      if (YYMAXDEPTH <= yystacksize)
    #####: 1293:        goto yyexhaustedlab;
    #####: 1294:      yystacksize *= 2;
    #####: 1295:      if (YYMAXDEPTH < yystacksize)
    #####: 1296:        yystacksize = YYMAXDEPTH;
        -: 1297:
        -: 1298:      {
    #####: 1299:        yy_state_t *yyss1 = yyss;
        -: 1300:        union yyalloc *yyptr =
    #####: 1301:          YY_CAST (union yyalloc *,
        -: 1302:                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
    #####: 1303:        if (! yyptr)
    #####: 1304:          goto yyexhaustedlab;
    #####: 1305:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1306:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1307:# undef YYSTACK_RELOCATE
    #####: 1308:        if (yyss1 != yyssa)
    #####: 1309:          YYSTACK_FREE (yyss1);
        -: 1310:      }
        -: 1311:# endif
        -: 1312:
    #####: 1313:      yyssp = yyss + yysize - 1;
    #####: 1314:      yyvsp = yyvs + yysize - 1;
        -: 1315:
        -: 1316:      YY_IGNORE_USELESS_CAST_BEGIN
        -: 1317:      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
        -: 1318:                  YY_CAST (long, yystacksize)));
        -: 1319:      YY_IGNORE_USELESS_CAST_END
        -: 1320:
    #####: 1321:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1322:        YYABORT;
        -: 1323:    }
        -: 1324:#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
        -: 1325:
    #####: 1326:  if (yystate == YYFINAL)
    #####: 1327:    YYACCEPT;
        -: 1328:
    #####: 1329:  goto yybackup;
        -: 1330:
        -: 1331:
        -: 1332:/*-----------.
        -: 1333:| yybackup.  |
        -: 1334:`-----------*/
    #####: 1335:yybackup:
        -: 1336:  /* Do appropriate processing given the current state.  Read a
        -: 1337:     lookahead token if we need one and don't already have one.  */
        -: 1338:
        -: 1339:  /* First try to decide what to do without reference to lookahead token.  */
    #####: 1340:  yyn = yypact[yystate];
    #####: 1341:  if (yypact_value_is_default (yyn))
    #####: 1342:    goto yydefault;
        -: 1343:
        -: 1344:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1345:
        -: 1346:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
    #####: 1347:  if (yychar == YYEMPTY)
        -: 1348:    {
        -: 1349:      YYDPRINTF ((stderr, "Reading a token: "));
    #####: 1350:      yychar = yylex (&yylval, yyscanner, lex_env);
        -: 1351:    }
        -: 1352:
    #####: 1353:  if (yychar <= YYEOF)
        -: 1354:    {
    #####: 1355:      yychar = yytoken = YYEOF;
        -: 1356:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1357:    }
        -: 1358:  else
        -: 1359:    {
    #####: 1360:      yytoken = YYTRANSLATE (yychar);
        -: 1361:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1362:    }
        -: 1363:
        -: 1364:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1365:     detect an error, take that action.  */
    #####: 1366:  yyn += yytoken;
    #####: 1367:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    #####: 1368:    goto yydefault;
    #####: 1369:  yyn = yytable[yyn];
    #####: 1370:  if (yyn <= 0)
        -: 1371:    {
        -: 1372:      if (yytable_value_is_error (yyn))
        -: 1373:        goto yyerrlab;
    #####: 1374:      yyn = -yyn;
    #####: 1375:      goto yyreduce;
        -: 1376:    }
        -: 1377:
        -: 1378:  /* Count tokens shifted since error; after three, turn off error
        -: 1379:     status.  */
    #####: 1380:  if (yyerrstatus)
    #####: 1381:    yyerrstatus--;
        -: 1382:
        -: 1383:  /* Shift the lookahead token.  */
        -: 1384:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
    #####: 1385:  yystate = yyn;
        -: 1386:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1387:  *++yyvsp = yylval;
        -: 1388:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1389:
        -: 1390:  /* Discard the shifted token.  */
    #####: 1391:  yychar = YYEMPTY;
    #####: 1392:  goto yynewstate;
        -: 1393:
        -: 1394:
        -: 1395:/*-----------------------------------------------------------.
        -: 1396:| yydefault -- do the default action for the current state.  |
        -: 1397:`-----------------------------------------------------------*/
    #####: 1398:yydefault:
    #####: 1399:  yyn = yydefact[yystate];
    #####: 1400:  if (yyn == 0)
    #####: 1401:    goto yyerrlab;
    #####: 1402:  goto yyreduce;
        -: 1403:
        -: 1404:
        -: 1405:/*-----------------------------.
        -: 1406:| yyreduce -- do a reduction.  |
        -: 1407:`-----------------------------*/
    #####: 1408:yyreduce:
        -: 1409:  /* yyn is the number of a rule to reduce with.  */
    #####: 1410:  yylen = yyr2[yyn];
        -: 1411:
        -: 1412:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1413:     '$$ = $1'.
        -: 1414:
        -: 1415:     Otherwise, the following line sets YYVAL to garbage.
        -: 1416:     This behavior is undocumented and Bison
        -: 1417:     users should not rely upon it.  Assigning to YYVAL
        -: 1418:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1419:     GCC warning that YYVAL may be used uninitialized.  */
    #####: 1420:  yyval = yyvsp[1-yylen];
        -: 1421:
        -: 1422:
        -: 1423:  YY_REDUCE_PRINT (yyn);
    #####: 1424:  switch (yyn)
        -: 1425:    {
    #####: 1426:  case 2:
        -: 1427:#line 115 "hex_grammar.y"
        -: 1428:      {
        -: 1429:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1430:        re_ast->root_node = (yyvsp[-1].re_node);
        -: 1431:      }
        -: 1432:#line 1433 "hex_grammar.c"
    #####: 1433:    break;
        -: 1434:
    #####: 1435:  case 3:
        -: 1436:#line 124 "hex_grammar.y"
        -: 1437:      {
        -: 1438:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1439:      }
        -: 1440:#line 1441 "hex_grammar.c"
    #####: 1441:    break;
        -: 1442:
    #####: 1443:  case 4:
        -: 1444:#line 128 "hex_grammar.y"
        -: 1445:      {
        -: 1446:        fail_if_too_many_ast_levels({
        -: 1447:          yr_re_node_destroy((yyvsp[-1].re_node));
        -: 1448:          yr_re_node_destroy((yyvsp[0].re_node));
        -: 1449:        });
        -: 1450:
        -: 1451:        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
        -: 1452:
        -: 1453:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1454:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1455:
        -: 1456:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1457:      }
        -: 1458:#line 1459 "hex_grammar.c"
    #####: 1459:    break;
        -: 1460:
    #####: 1461:  case 5:
        -: 1462:#line 142 "hex_grammar.y"
        -: 1463:      {
        -: 1464:        RE_NODE* new_concat;
        -: 1465:        RE_NODE* leftmost_concat = NULL;
        -: 1466:        RE_NODE* leftmost_node = (yyvsp[-1].re_node);
        -: 1467:
        -: 1468:        fail_if_too_many_ast_levels({
        -: 1469:          yr_re_node_destroy((yyvsp[-2].re_node));
        -: 1470:          yr_re_node_destroy((yyvsp[-1].re_node));
        -: 1471:          yr_re_node_destroy((yyvsp[0].re_node));
        -: 1472:        });
        -: 1473:
        -: 1474:        (yyval.re_node) = NULL;
        -: 1475:
        -: 1476:        /*
        -: 1477:        Some portions of the code (i.e: yr_re_split_at_chaining_point)
        -: 1478:        expect a left-unbalanced tree where the right child of a concat node
        -: 1479:        can't be another concat node. A concat node must be always the left
        -: 1480:        child of its parent if the parent is also a concat. For this reason
        -: 1481:        the can't simply create two new concat nodes arranged like this:
        -: 1482:
        -: 1483:                concat
        -: 1484:                 /   \
        -: 1485:                /     \
        -: 1486:            token's    \
        -: 1487:            subtree  concat
        -: 1488:                     /    \
        -: 1489:                    /      \
        -: 1490:                   /        \
        -: 1491:           token_sequence's  token's
        -: 1492:               subtree       subtree
        -: 1493:
        -: 1494:        Instead we must insert the subtree for the first token as the
        -: 1495:        leftmost node of the token_sequence subtree.
        -: 1496:        */
        -: 1497:
        -: 1498:        while (leftmost_node->type == RE_NODE_CONCAT)
        -: 1499:        {
        -: 1500:          leftmost_concat = leftmost_node;
        -: 1501:          leftmost_node = leftmost_node->left;
        -: 1502:        }
        -: 1503:
        -: 1504:        new_concat = yr_re_node_create(
        -: 1505:            RE_NODE_CONCAT, (yyvsp[-2].re_node), leftmost_node);
        -: 1506:
        -: 1507:        if (new_concat != NULL)
        -: 1508:        {
        -: 1509:          if (leftmost_concat != NULL)
        -: 1510:          {
        -: 1511:            leftmost_concat->left = new_concat;
        -: 1512:            (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
        -: 1513:          }
        -: 1514:          else
        -: 1515:          {
        -: 1516:            (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, new_concat, (yyvsp[0].re_node));
        -: 1517:          }
        -: 1518:        }
        -: 1519:
        -: 1520:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1521:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1522:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1523:
        -: 1524:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1525:      }
        -: 1526:#line 1527 "hex_grammar.c"
    #####: 1527:    break;
        -: 1528:
    #####: 1529:  case 6:
        -: 1530:#line 210 "hex_grammar.y"
        -: 1531:      {
        -: 1532:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1533:      }
        -: 1534:#line 1535 "hex_grammar.c"
    #####: 1535:    break;
        -: 1536:
    #####: 1537:  case 7:
        -: 1538:#line 214 "hex_grammar.y"
        -: 1539:      {
        -: 1540:        fail_if_too_many_ast_levels({
        -: 1541:          yr_re_node_destroy((yyvsp[-1].re_node));
        -: 1542:          yr_re_node_destroy((yyvsp[0].re_node));
        -: 1543:        });
        -: 1544:
        -: 1545:        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
        -: 1546:
        -: 1547:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1548:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1549:
        -: 1550:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1551:      }
        -: 1552:#line 1553 "hex_grammar.c"
    #####: 1553:    break;
        -: 1554:
    #####: 1555:  case 8:
        -: 1556:#line 232 "hex_grammar.y"
        -: 1557:      {
        -: 1558:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1559:      }
        -: 1560:#line 1561 "hex_grammar.c"
    #####: 1561:    break;
        -: 1562:
    #####: 1563:  case 9:
        -: 1564:#line 236 "hex_grammar.y"
        -: 1565:      {
        -: 1566:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1567:        (yyval.re_node)->greedy = false;
        -: 1568:      }
        -: 1569:#line 1570 "hex_grammar.c"
    #####: 1570:    break;
        -: 1571:
    #####: 1572:  case 10:
        -: 1573:#line 245 "hex_grammar.y"
        -: 1574:      {
        -: 1575:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1576:      }
        -: 1577:#line 1578 "hex_grammar.c"
    #####: 1578:    break;
        -: 1579:
    #####: 1580:  case 11:
        -: 1581:#line 249 "hex_grammar.y"
        -: 1582:      {
        -: 1583:        lex_env->inside_or++;
        -: 1584:      }
        -: 1585:#line 1586 "hex_grammar.c"
    #####: 1586:    break;
        -: 1587:
    #####: 1588:  case 12:
        -: 1589:#line 253 "hex_grammar.y"
        -: 1590:      {
        -: 1591:        (yyval.re_node) = (yyvsp[-1].re_node);
        -: 1592:        lex_env->inside_or--;
        -: 1593:      }
        -: 1594:#line 1595 "hex_grammar.c"
    #####: 1595:    break;
        -: 1596:
    #####: 1597:  case 13:
        -: 1598:#line 262 "hex_grammar.y"
        -: 1599:      {
        -: 1600:        if ((yyvsp[-1].integer) <= 0)
        -: 1601:        {
        -: 1602:          yyerror(yyscanner, lex_env, "invalid jump length");
        -: 1603:          YYABORT;
        -: 1604:        }
        -: 1605:
        -: 1606:        if (lex_env->inside_or && (yyvsp[-1].integer) > YR_STRING_CHAINING_THRESHOLD)
        -: 1607:        {
        -: 1608:          yyerror(yyscanner, lex_env, "jumps over "
        -: 1609:              STR(YR_STRING_CHAINING_THRESHOLD)
        -: 1610:              " now allowed inside alternation (|)");
        -: 1611:          YYABORT;
        -: 1612:        }
        -: 1613:
        -: 1614:        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -: 1615:
        -: 1616:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1617:
        -: 1618:        (yyval.re_node)->start = (int) (yyvsp[-1].integer);
        -: 1619:        (yyval.re_node)->end = (int) (yyvsp[-1].integer);
        -: 1620:      }
        -: 1621:#line 1622 "hex_grammar.c"
    #####: 1622:    break;
        -: 1623:
    #####: 1624:  case 14:
        -: 1625:#line 285 "hex_grammar.y"
        -: 1626:      {
        -: 1627:        if (lex_env->inside_or &&
        -: 1628:            ((yyvsp[-3].integer) > YR_STRING_CHAINING_THRESHOLD ||
        -: 1629:             (yyvsp[-1].integer) > YR_STRING_CHAINING_THRESHOLD) )
        -: 1630:        {
        -: 1631:          yyerror(yyscanner, lex_env, "jumps over "
        -: 1632:              STR(YR_STRING_CHAINING_THRESHOLD)
        -: 1633:              " now allowed inside alternation (|)");
        -: 1634:
        -: 1635:          YYABORT;
        -: 1636:        }
        -: 1637:
        -: 1638:        if ((yyvsp[-3].integer) < 0 || (yyvsp[-1].integer) < 0)
        -: 1639:        {
        -: 1640:          yyerror(yyscanner, lex_env, "invalid negative jump length");
        -: 1641:          YYABORT;
        -: 1642:        }
        -: 1643:
        -: 1644:        if ((yyvsp[-3].integer) > (yyvsp[-1].integer))
        -: 1645:        {
        -: 1646:          yyerror(yyscanner, lex_env, "invalid jump range");
        -: 1647:          YYABORT;
        -: 1648:        }
        -: 1649:
        -: 1650:        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -: 1651:
        -: 1652:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1653:
        -: 1654:        (yyval.re_node)->start = (int) (yyvsp[-3].integer);
        -: 1655:        (yyval.re_node)->end = (int) (yyvsp[-1].integer);
        -: 1656:      }
        -: 1657:#line 1658 "hex_grammar.c"
    #####: 1658:    break;
        -: 1659:
    #####: 1660:  case 15:
        -: 1661:#line 317 "hex_grammar.y"
        -: 1662:      {
        -: 1663:        if (lex_env->inside_or)
        -: 1664:        {
        -: 1665:          yyerror(yyscanner, lex_env,
        -: 1666:              "unbounded jumps not allowed inside alternation (|)");
        -: 1667:          YYABORT;
        -: 1668:        }
        -: 1669:
        -: 1670:        if ((yyvsp[-2].integer) < 0)
        -: 1671:        {
        -: 1672:          yyerror(yyscanner, lex_env, "invalid negative jump length");
        -: 1673:          YYABORT;
        -: 1674:        }
        -: 1675:
        -: 1676:        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -: 1677:
        -: 1678:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1679:
        -: 1680:        (yyval.re_node)->start = (int) (yyvsp[-2].integer);
        -: 1681:        (yyval.re_node)->end = INT_MAX;
        -: 1682:      }
        -: 1683:#line 1684 "hex_grammar.c"
    #####: 1684:    break;
        -: 1685:
    #####: 1686:  case 16:
        -: 1687:#line 339 "hex_grammar.y"
        -: 1688:      {
        -: 1689:        if (lex_env->inside_or)
        -: 1690:        {
        -: 1691:          yyerror(yyscanner, lex_env,
        -: 1692:              "unbounded jumps not allowed inside alternation (|)");
        -: 1693:          YYABORT;
        -: 1694:        }
        -: 1695:
        -: 1696:        (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -: 1697:
        -: 1698:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1699:
        -: 1700:        (yyval.re_node)->start = 0;
        -: 1701:        (yyval.re_node)->end = INT_MAX;
        -: 1702:      }
        -: 1703:#line 1704 "hex_grammar.c"
    #####: 1704:    break;
        -: 1705:
    #####: 1706:  case 17:
        -: 1707:#line 359 "hex_grammar.y"
        -: 1708:      {
        -: 1709:          (yyval.re_node) = (yyvsp[0].re_node);
        -: 1710:      }
        -: 1711:#line 1712 "hex_grammar.c"
    #####: 1712:    break;
        -: 1713:
    #####: 1714:  case 18:
        -: 1715:#line 363 "hex_grammar.y"
        -: 1716:      {
        -: 1717:        mark_as_not_fast_regexp();
        -: 1718:
        -: 1719:        fail_if_too_many_ast_levels({
        -: 1720:          yr_re_node_destroy((yyvsp[-2].re_node));
        -: 1721:          yr_re_node_destroy((yyvsp[0].re_node));
        -: 1722:        });
        -: 1723:
        -: 1724:        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));
        -: 1725:
        -: 1726:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1727:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1728:
        -: 1729:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1730:      }
        -: 1731:#line 1732 "hex_grammar.c"
    #####: 1732:    break;
        -: 1733:
    #####: 1734:  case 19:
        -: 1735:#line 382 "hex_grammar.y"
        -: 1736:      {
        -: 1737:        (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);
        -: 1738:
        -: 1739:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1740:
        -: 1741:        (yyval.re_node)->value = (int) (yyvsp[0].integer);
        -: 1742:      }
        -: 1743:#line 1744 "hex_grammar.c"
    #####: 1744:    break;
        -: 1745:
    #####: 1746:  case 20:
        -: 1747:#line 390 "hex_grammar.y"
        -: 1748:      {
        -: 1749:        uint8_t mask = (uint8_t) ((yyvsp[0].integer) >> 8);
        -: 1750:
        -: 1751:        if (mask == 0x00)
        -: 1752:        {
        -: 1753:          (yyval.re_node) = yr_re_node_create(RE_NODE_ANY, NULL, NULL);
        -: 1754:
        -: 1755:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1756:        }
        -: 1757:        else
        -: 1758:        {
        -: 1759:          (yyval.re_node) = yr_re_node_create(RE_NODE_MASKED_LITERAL, NULL, NULL);
        -: 1760:
        -: 1761:          fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1762:
        -: 1763:          (yyval.re_node)->value = (yyvsp[0].integer) & 0xFF;
        -: 1764:          (yyval.re_node)->mask = mask;
        -: 1765:        }
        -: 1766:      }
        -: 1767:#line 1768 "hex_grammar.c"
    #####: 1768:    break;
        -: 1769:
        -: 1770:
        -: 1771:#line 1772 "hex_grammar.c"
        -: 1772:
    #####: 1773:      default: break;
        -: 1774:    }
        -: 1775:  /* User semantic actions sometimes alter yychar, and that requires
        -: 1776:     that yytoken be updated with the new translation.  We take the
        -: 1777:     approach of translating immediately before every use of yytoken.
        -: 1778:     One alternative is translating here after every semantic action,
        -: 1779:     but that translation would be missed if the semantic action invokes
        -: 1780:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 1781:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 1782:     incorrect destructor might then be invoked immediately.  In the
        -: 1783:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 1784:     to an incorrect destructor call or verbose syntax error message
        -: 1785:     before the lookahead is translated.  */
        -: 1786:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 1787:
    #####: 1788:  YYPOPSTACK (yylen);
    #####: 1789:  yylen = 0;
        -: 1790:  YY_STACK_PRINT (yyss, yyssp);
        -: 1791:
    #####: 1792:  *++yyvsp = yyval;
        -: 1793:
        -: 1794:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 1795:     that goes to, based on the state we popped back to and the rule
        -: 1796:     number reduced by.  */
        -: 1797:  {
    #####: 1798:    const int yylhs = yyr1[yyn] - YYNTOKENS;
    #####: 1799:    const int yyi = yypgoto[yylhs] + *yyssp;
    #####: 1800:    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
    #####: 1801:               ? yytable[yyi]
    #####: 1802:               : yydefgoto[yylhs]);
        -: 1803:  }
        -: 1804:
    #####: 1805:  goto yynewstate;
        -: 1806:
        -: 1807:
        -: 1808:/*--------------------------------------.
        -: 1809:| yyerrlab -- here on detecting error.  |
        -: 1810:`--------------------------------------*/
    #####: 1811:yyerrlab:
        -: 1812:  /* Make sure we have latest lookahead translation.  See comments at
        -: 1813:     user semantic actions for why this is necessary.  */
    #####: 1814:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 1815:
        -: 1816:  /* If not already recovering from an error, report this error.  */
    #####: 1817:  if (!yyerrstatus)
        -: 1818:    {
    #####: 1819:      ++yynerrs;
        -: 1820:#if ! YYERROR_VERBOSE
        -: 1821:      yyerror (yyscanner, lex_env, YY_("syntax error"));
        -: 1822:#else
        -: 1823:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 1824:                                        yyssp, yytoken)
        -: 1825:      {
    #####: 1826:        char const *yymsgp = YY_("syntax error");
        -: 1827:        int yysyntax_error_status;
    #####: 1828:        yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 1829:        if (yysyntax_error_status == 0)
    #####: 1830:          yymsgp = yymsg;
    #####: 1831:        else if (yysyntax_error_status == 1)
        -: 1832:          {
    #####: 1833:            if (yymsg != yymsgbuf)
    #####: 1834:              YYSTACK_FREE (yymsg);
    #####: 1835:            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
    #####: 1836:            if (!yymsg)
        -: 1837:              {
    #####: 1838:                yymsg = yymsgbuf;
    #####: 1839:                yymsg_alloc = sizeof yymsgbuf;
    #####: 1840:                yysyntax_error_status = 2;
        -: 1841:              }
        -: 1842:            else
        -: 1843:              {
    #####: 1844:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 1845:                yymsgp = yymsg;
        -: 1846:              }
        -: 1847:          }
    #####: 1848:        yyerror (yyscanner, lex_env, yymsgp);
    #####: 1849:        if (yysyntax_error_status == 2)
    #####: 1850:          goto yyexhaustedlab;
        -: 1851:      }
        -: 1852:# undef YYSYNTAX_ERROR
        -: 1853:#endif
        -: 1854:    }
        -: 1855:
        -: 1856:
        -: 1857:
    #####: 1858:  if (yyerrstatus == 3)
        -: 1859:    {
        -: 1860:      /* If just tried and failed to reuse lookahead token after an
        -: 1861:         error, discard it.  */
        -: 1862:
    #####: 1863:      if (yychar <= YYEOF)
        -: 1864:        {
        -: 1865:          /* Return failure if at end of input.  */
    #####: 1866:          if (yychar == YYEOF)
    #####: 1867:            YYABORT;
        -: 1868:        }
        -: 1869:      else
        -: 1870:        {
    #####: 1871:          yydestruct ("Error: discarding",
        -: 1872:                      yytoken, &yylval, yyscanner, lex_env);
    #####: 1873:          yychar = YYEMPTY;
        -: 1874:        }
        -: 1875:    }
        -: 1876:
        -: 1877:  /* Else will try to reuse lookahead token after shifting the error
        -: 1878:     token.  */
    #####: 1879:  goto yyerrlab1;
        -: 1880:
        -: 1881:
        -: 1882:/*---------------------------------------------------.
        -: 1883:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 1884:`---------------------------------------------------*/
        -: 1885:yyerrorlab:
        -: 1886:  /* Pacify compilers when the user code never invokes YYERROR and the
        -: 1887:     label yyerrorlab therefore never appears in user code.  */
        -: 1888:  if (0)
        -: 1889:    YYERROR;
        -: 1890:
        -: 1891:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 1892:     this YYERROR.  */
        -: 1893:  YYPOPSTACK (yylen);
        -: 1894:  yylen = 0;
        -: 1895:  YY_STACK_PRINT (yyss, yyssp);
        -: 1896:  yystate = *yyssp;
        -: 1897:  goto yyerrlab1;
        -: 1898:
        -: 1899:
        -: 1900:/*-------------------------------------------------------------.
        -: 1901:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 1902:`-------------------------------------------------------------*/
    #####: 1903:yyerrlab1:
    #####: 1904:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 1905:
        -: 1906:  for (;;)
        -: 1907:    {
    #####: 1908:      yyn = yypact[yystate];
    #####: 1909:      if (!yypact_value_is_default (yyn))
        -: 1910:        {
    #####: 1911:          yyn += YYTERROR;
    #####: 1912:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 1913:            {
    #####: 1914:              yyn = yytable[yyn];
    #####: 1915:              if (0 < yyn)
    #####: 1916:                break;
        -: 1917:            }
        -: 1918:        }
        -: 1919:
        -: 1920:      /* Pop the current state because it cannot handle the error token.  */
    #####: 1921:      if (yyssp == yyss)
    #####: 1922:        YYABORT;
        -: 1923:
        -: 1924:
    #####: 1925:      yydestruct ("Error: popping",
    #####: 1926:                  yystos[yystate], yyvsp, yyscanner, lex_env);
    #####: 1927:      YYPOPSTACK (1);
    #####: 1928:      yystate = *yyssp;
        -: 1929:      YY_STACK_PRINT (yyss, yyssp);
        -: 1930:    }
        -: 1931:
        -: 1932:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1933:  *++yyvsp = yylval;
        -: 1934:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1935:
        -: 1936:
        -: 1937:  /* Shift the error token.  */
        -: 1938:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 1939:
    #####: 1940:  yystate = yyn;
    #####: 1941:  goto yynewstate;
        -: 1942:
        -: 1943:
        -: 1944:/*-------------------------------------.
        -: 1945:| yyacceptlab -- YYACCEPT comes here.  |
        -: 1946:`-------------------------------------*/
    #####: 1947:yyacceptlab:
    #####: 1948:  yyresult = 0;
    #####: 1949:  goto yyreturn;
        -: 1950:
        -: 1951:
        -: 1952:/*-----------------------------------.
        -: 1953:| yyabortlab -- YYABORT comes here.  |
        -: 1954:`-----------------------------------*/
    #####: 1955:yyabortlab:
    #####: 1956:  yyresult = 1;
    #####: 1957:  goto yyreturn;
        -: 1958:
        -: 1959:
        -: 1960:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 1961:/*-------------------------------------------------.
        -: 1962:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 1963:`-------------------------------------------------*/
    #####: 1964:yyexhaustedlab:
    #####: 1965:  yyerror (yyscanner, lex_env, YY_("memory exhausted"));
    #####: 1966:  yyresult = 2;
        -: 1967:  /* Fall through.  */
        -: 1968:#endif
        -: 1969:
        -: 1970:
        -: 1971:/*-----------------------------------------------------.
        -: 1972:| yyreturn -- parsing is finished, return the result.  |
        -: 1973:`-----------------------------------------------------*/
    #####: 1974:yyreturn:
    #####: 1975:  if (yychar != YYEMPTY)
        -: 1976:    {
        -: 1977:      /* Make sure we have latest lookahead translation.  See comments at
        -: 1978:         user semantic actions for why this is necessary.  */
    #####: 1979:      yytoken = YYTRANSLATE (yychar);
    #####: 1980:      yydestruct ("Cleanup: discarding lookahead",
        -: 1981:                  yytoken, &yylval, yyscanner, lex_env);
        -: 1982:    }
        -: 1983:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 1984:     this YYABORT or YYACCEPT.  */
    #####: 1985:  YYPOPSTACK (yylen);
        -: 1986:  YY_STACK_PRINT (yyss, yyssp);
    #####: 1987:  while (yyssp != yyss)
        -: 1988:    {
    #####: 1989:      yydestruct ("Cleanup: popping",
    #####: 1990:                  yystos[+*yyssp], yyvsp, yyscanner, lex_env);
    #####: 1991:      YYPOPSTACK (1);
        -: 1992:    }
        -: 1993:#ifndef yyoverflow
    #####: 1994:  if (yyss != yyssa)
    #####: 1995:    YYSTACK_FREE (yyss);
        -: 1996:#endif
        -: 1997:#if YYERROR_VERBOSE
    #####: 1998:  if (yymsg != yymsgbuf)
    #####: 1999:    YYSTACK_FREE (yymsg);
        -: 2000:#endif
    #####: 2001:  return yyresult;
        -: 2002:}
        -: 2003:#line 411 "hex_grammar.y"
