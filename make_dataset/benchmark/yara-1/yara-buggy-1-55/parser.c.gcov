        -:    0:Source:parser.c
        -:    0:Graph:/home/workspace/libyara/parser.gcno
        -:    0:Data:/home/workspace/libyara/parser.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <stdbool.h>
        -:   31:#include <stddef.h>
        -:   32:#include <string.h>
        -:   33:
        -:   34:#include <yara/ahocorasick.h>
        -:   35:#include <yara/arena.h>
        -:   36:#include <yara/re.h>
        -:   37:#include <yara/error.h>
        -:   38:#include <yara/exec.h>
        -:   39:#include <yara/object.h>
        -:   40:#include <yara/strutils.h>
        -:   41:#include <yara/utils.h>
        -:   42:#include <yara/modules.h>
        -:   43:#include <yara/parser.h>
        -:   44:#include <yara/mem.h>
        -:   45:
        -:   46:#define todigit(x)  ((x) >='A'&& (x) <='F')? \
        -:   47:                    ((uint8_t) (x - 'A' + 10)) : \
        -:   48:                    ((uint8_t) (x - '0'))
        -:   49:
        -:   50:
        2:   51:int yr_parser_emit(
        -:   52:    yyscan_t yyscanner,
        -:   53:    uint8_t instruction,
        -:   54:    uint8_t** instruction_address)
        -:   55:{
        2:   56:  return yr_arena_write_data(
        2:   57:      yyget_extra(yyscanner)->code_arena,
        -:   58:      &instruction,
        -:   59:      sizeof(int8_t),
        -:   60:      (void**) instruction_address);
        -:   61:}
        -:   62:
        -:   63:
    #####:   64:int yr_parser_emit_with_arg_double(
        -:   65:    yyscan_t yyscanner,
        -:   66:    uint8_t instruction,
        -:   67:    double argument,
        -:   68:    uint8_t** instruction_address,
        -:   69:    double** argument_address)
        -:   70:{
    #####:   71:  int result = yr_arena_write_data(
    #####:   72:      yyget_extra(yyscanner)->code_arena,
        -:   73:      &instruction,
        -:   74:      sizeof(uint8_t),
        -:   75:      (void**) instruction_address);
        -:   76:
    #####:   77:  if (result == ERROR_SUCCESS)
    #####:   78:    result = yr_arena_write_data(
    #####:   79:        yyget_extra(yyscanner)->code_arena,
        -:   80:        &argument,
        -:   81:        sizeof(double),
        -:   82:        (void**) argument_address);
        -:   83:
    #####:   84:  return result;
        -:   85:}
        -:   86:
        -:   87:
        1:   88:int yr_parser_emit_with_arg(
        -:   89:    yyscan_t yyscanner,
        -:   90:    uint8_t instruction,
        -:   91:    int64_t argument,
        -:   92:    uint8_t** instruction_address,
        -:   93:    int64_t** argument_address)
        -:   94:{
        1:   95:  int result = yr_arena_write_data(
        1:   96:      yyget_extra(yyscanner)->code_arena,
        -:   97:      &instruction,
        -:   98:      sizeof(uint8_t),
        -:   99:      (void**) instruction_address);
        -:  100:
        1:  101:  if (result == ERROR_SUCCESS)
        1:  102:    result = yr_arena_write_data(
        1:  103:        yyget_extra(yyscanner)->code_arena,
        -:  104:        &argument,
        -:  105:        sizeof(int64_t),
        -:  106:        (void**) argument_address);
        -:  107:
        1:  108:  return result;
        -:  109:}
        -:  110:
        -:  111:
        1:  112:int yr_parser_emit_with_arg_reloc(
        -:  113:    yyscan_t yyscanner,
        -:  114:    uint8_t instruction,
        -:  115:    void* argument,
        -:  116:    uint8_t** instruction_address,
        -:  117:    void** argument_address)
        -:  118:{
        1:  119:  int64_t* ptr = NULL;
        -:  120:  int result;
        -:  121:
        -:  122:  DECLARE_REFERENCE(void*, ptr) arg;
        -:  123:
        1:  124:  memset(&arg, 0, sizeof(arg));
        1:  125:  arg.ptr = argument;
        -:  126:
        1:  127:  result = yr_arena_write_data(
        1:  128:      yyget_extra(yyscanner)->code_arena,
        -:  129:      &instruction,
        -:  130:      sizeof(uint8_t),
        -:  131:      (void**) instruction_address);
        -:  132:
        1:  133:  if (result == ERROR_SUCCESS)
        1:  134:    result = yr_arena_write_data(
        1:  135:        yyget_extra(yyscanner)->code_arena,
        -:  136:        &arg,
        -:  137:        sizeof(arg),
        -:  138:        (void**) &ptr);
        -:  139:
        1:  140:  if (result == ERROR_SUCCESS)
        1:  141:    result = yr_arena_make_ptr_relocatable(
        1:  142:        yyget_extra(yyscanner)->code_arena,
        -:  143:        ptr,
        -:  144:        0,
        -:  145:        EOL);
        -:  146:
        1:  147:  if (argument_address != NULL)
    #####:  148:    *argument_address = (void*) ptr;
        -:  149:
        1:  150:  return result;
        -:  151:}
        -:  152:
        -:  153:
    #####:  154:int yr_parser_emit_pushes_for_strings(
        -:  155:    yyscan_t yyscanner,
        -:  156:    const char* identifier)
        -:  157:{
    #####:  158:  YR_COMPILER* compiler = yyget_extra(yyscanner);
    #####:  159:  YR_STRING* string = compiler->current_rule->strings;
        -:  160:
        -:  161:  const char* string_identifier;
        -:  162:  const char* target_identifier;
        -:  163:
    #####:  164:  int matching = 0;
        -:  165:
    #####:  166:  while(!STRING_IS_NULL(string))
        -:  167:  {
        -:  168:    // Don't generate pushes for strings chained to another one, we are
        -:  169:    // only interested in non-chained strings or the head of the chain.
        -:  170:
    #####:  171:    if (string->chained_to == NULL)
        -:  172:    {
    #####:  173:      string_identifier = string->identifier;
    #####:  174:      target_identifier = identifier;
        -:  175:
    #####:  176:      while (*target_identifier != '\0' &&
    #####:  177:             *string_identifier != '\0' &&
    #####:  178:             *target_identifier == *string_identifier)
        -:  179:      {
    #####:  180:        target_identifier++;
    #####:  181:        string_identifier++;
        -:  182:      }
        -:  183:
    #####:  184:      if ((*target_identifier == '\0' && *string_identifier == '\0') ||
    #####:  185:           *target_identifier == '*')
        -:  186:      {
    #####:  187:        yr_parser_emit_with_arg_reloc(
        -:  188:            yyscanner,
        -:  189:            OP_PUSH,
        -:  190:            string,
        -:  191:            NULL,
        -:  192:            NULL);
        -:  193:
    #####:  194:        string->g_flags |= STRING_GFLAGS_REFERENCED;
    #####:  195:        string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
    #####:  196:        matching++;
        -:  197:      }
        -:  198:    }
        -:  199:
    #####:  200:    string = (YR_STRING*) yr_arena_next_address(
        -:  201:        compiler->strings_arena,
        -:  202:        string,
        -:  203:        sizeof(YR_STRING));
        -:  204:  }
        -:  205:
    #####:  206:  if (matching == 0)
        -:  207:  {
    #####:  208:    yr_compiler_set_error_extra_info(compiler, identifier);
    #####:  209:    return ERROR_UNDEFINED_STRING;
        -:  210:  }
        -:  211:
    #####:  212:  return ERROR_SUCCESS;
        -:  213:}
        -:  214:
        -:  215:
    #####:  216:int yr_parser_check_types(
        -:  217:    YR_COMPILER* compiler,
        -:  218:    YR_OBJECT_FUNCTION* function,
        -:  219:    const char* actual_args_fmt)
        -:  220:{
        -:  221:  int i;
        -:  222:
    #####:  223:  for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  224:  {
    #####:  225:    if (function->prototypes[i].arguments_fmt == NULL)
    #####:  226:      break;
        -:  227:
    #####:  228:    if (strcmp(function->prototypes[i].arguments_fmt, actual_args_fmt) == 0)
    #####:  229:      return ERROR_SUCCESS;
        -:  230:  }
        -:  231:
    #####:  232:  yr_compiler_set_error_extra_info(compiler, function->identifier);
        -:  233:
    #####:  234:  return ERROR_WRONG_ARGUMENTS;
        -:  235:}
        -:  236:
        -:  237:
    #####:  238:int yr_parser_lookup_string(
        -:  239:    yyscan_t yyscanner,
        -:  240:    const char* identifier,
        -:  241:    YR_STRING** string)
        -:  242:{
    #####:  243:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  244:
    #####:  245:  *string = compiler->current_rule->strings;
        -:  246:
    #####:  247:  while(!STRING_IS_NULL(*string))
        -:  248:  {
        -:  249:    // If some string $a gets fragmented into multiple chained
        -:  250:    // strings, all those fragments have the same $a identifier
        -:  251:    // but we are interested in the heading fragment, which is
        -:  252:    // that with chained_to == NULL
        -:  253:
    #####:  254:    if (strcmp((*string)->identifier, identifier) == 0 &&
    #####:  255:        (*string)->chained_to == NULL)
        -:  256:    {
    #####:  257:      return ERROR_SUCCESS;
        -:  258:    }
        -:  259:
    #####:  260:    *string = (YR_STRING*) yr_arena_next_address(
        -:  261:        compiler->strings_arena,
        -:  262:        *string,
        -:  263:        sizeof(YR_STRING));
        -:  264:  }
        -:  265:
    #####:  266:  yr_compiler_set_error_extra_info(compiler, identifier);
        -:  267:
    #####:  268:  *string = NULL;
        -:  269:
    #####:  270:  return ERROR_UNDEFINED_STRING;
        -:  271:}
        -:  272:
        -:  273:
    #####:  274:int yr_parser_lookup_loop_variable(
        -:  275:    yyscan_t yyscanner,
        -:  276:    const char* identifier)
        -:  277:{
    #####:  278:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  279:  int i;
        -:  280:
    #####:  281:  for (i = 0; i < compiler->loop_depth; i++)
        -:  282:  {
    #####:  283:    if (compiler->loop_identifier[i] != NULL &&
    #####:  284:        strcmp(identifier, compiler->loop_identifier[i]) == 0)
    #####:  285:      return i;
        -:  286:  }
        -:  287:
    #####:  288:  return -1;
        -:  289:}
        -:  290:
        -:  291:
    #####:  292:static int _yr_parser_write_string(
        -:  293:    const char* identifier,
        -:  294:    int flags,
        -:  295:    YR_COMPILER* compiler,
        -:  296:    SIZED_STRING* str,
        -:  297:    RE_AST* re_ast,
        -:  298:    YR_STRING** string,
        -:  299:    int* min_atom_quality)
        -:  300:{
        -:  301:  SIZED_STRING* literal_string;
    #####:  302:  YR_ATOM_LIST_ITEM* atom_list = NULL;
        -:  303:
        -:  304:  int result;
        -:  305:  int max_string_len;
    #####:  306:  bool free_literal = false;
        -:  307:
    #####:  308:  *string = NULL;
        -:  309:
    #####:  310:  result = yr_arena_allocate_struct(
        -:  311:      compiler->strings_arena,
        -:  312:      sizeof(YR_STRING),
        -:  313:      (void**) string,
        -:  314:      offsetof(YR_STRING, identifier),
        -:  315:      offsetof(YR_STRING, string),
        -:  316:      offsetof(YR_STRING, chained_to),
        -:  317:      offsetof(YR_STRING, rule),
        -:  318:      EOL);
        -:  319:
    #####:  320:  if (result != ERROR_SUCCESS)
    #####:  321:    return result;
        -:  322:
    #####:  323:  result = yr_arena_write_string(
        -:  324:      compiler->sz_arena,
        -:  325:      identifier,
    #####:  326:      &(*string)->identifier);
        -:  327:
    #####:  328:  if (result != ERROR_SUCCESS)
    #####:  329:    return result;
        -:  330:
    #####:  331:  if (flags & STRING_GFLAGS_HEXADECIMAL ||
    #####:  332:      flags & STRING_GFLAGS_REGEXP)
        -:  333:  {
    #####:  334:    literal_string = yr_re_ast_extract_literal(re_ast);
        -:  335:
    #####:  336:    if (literal_string != NULL)
        -:  337:    {
    #####:  338:      flags |= STRING_GFLAGS_LITERAL;
    #####:  339:      free_literal = true;
        -:  340:    }
        -:  341:    else
        -:  342:    {
        -:  343:      // Non-literal strings can't be marked as fixed offset because once we
        -:  344:      // find a string atom in the scanned data we don't know the offset where
        -:  345:      // the string should start, as the non-literal strings can contain
        -:  346:      // variable-length portions.
        -:  347:
    #####:  348:      flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  349:    }
        -:  350:  }
        -:  351:  else
        -:  352:  {
    #####:  353:    literal_string = str;
    #####:  354:    flags |= STRING_GFLAGS_LITERAL;
        -:  355:  }
        -:  356:
    #####:  357:  (*string)->g_flags = flags;
    #####:  358:  (*string)->chained_to = NULL;
    #####:  359:  (*string)->fixed_offset = UNDEFINED;
    #####:  360:  (*string)->rule = compiler->current_rule;
        -:  361:
        -:  362:  #ifdef PROFILING_ENABLED
        -:  363:  (*string)->time_cost = 0;
        -:  364:  #endif
        -:  365:
    #####:  366:  memset((*string)->matches, 0,
        -:  367:         sizeof((*string)->matches));
        -:  368:
    #####:  369:  memset((*string)->unconfirmed_matches, 0,
        -:  370:         sizeof((*string)->unconfirmed_matches));
        -:  371:
    #####:  372:  if (flags & STRING_GFLAGS_LITERAL)
        -:  373:  {
    #####:  374:    (*string)->length = (uint32_t) literal_string->length;
        -:  375:
    #####:  376:    result = yr_arena_write_data(
        -:  377:        compiler->sz_arena,
    #####:  378:        literal_string->c_string,
    #####:  379:        literal_string->length + 1,   // +1 to include terminating NULL
    #####:  380:        (void**) &(*string)->string);
        -:  381:
    #####:  382:    if (result == ERROR_SUCCESS)
        -:  383:    {
    #####:  384:      result = yr_atoms_extract_from_string(
        -:  385:          &compiler->atoms_config,
    #####:  386:          (uint8_t*) literal_string->c_string,
    #####:  387:          (int32_t) literal_string->length,
        -:  388:          flags,
        -:  389:          &atom_list);
        -:  390:    }
        -:  391:  }
        -:  392:  else
        -:  393:  {
        -:  394:    // Emit forwards code
    #####:  395:    result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, false);
        -:  396:
        -:  397:    // Emit backwards code
    #####:  398:    if (result == ERROR_SUCCESS)
    #####:  399:      result = yr_re_ast_emit_code(re_ast, compiler->re_code_arena, true);
        -:  400:
    #####:  401:    if (result == ERROR_SUCCESS)
    #####:  402:      result = yr_atoms_extract_from_re(
        -:  403:          &compiler->atoms_config, re_ast, flags, &atom_list);
        -:  404:  }
        -:  405:
    #####:  406:  if (result == ERROR_SUCCESS)
        -:  407:  {
        -:  408:    // Add the string to Aho-Corasick automaton.
    #####:  409:    result = yr_ac_add_string(
        -:  410:        compiler->automaton,
        -:  411:        *string,
        -:  412:        atom_list,
        -:  413:        compiler->matches_arena);
        -:  414:  }
        -:  415:
    #####:  416:  *min_atom_quality = yr_atoms_min_quality(
        -:  417:      &compiler->atoms_config, atom_list);
        -:  418:
    #####:  419:  if (flags & STRING_GFLAGS_LITERAL)
        -:  420:  {
    #####:  421:    if (flags & STRING_GFLAGS_WIDE)
    #####:  422:      max_string_len = (*string)->length * 2;
        -:  423:    else
    #####:  424:      max_string_len = (*string)->length;
        -:  425:
    #####:  426:    if (max_string_len <= YR_MAX_ATOM_LENGTH)
    #####:  427:      (*string)->g_flags |= STRING_GFLAGS_FITS_IN_ATOM;
        -:  428:  }
        -:  429:
    #####:  430:  if (free_literal)
    #####:  431:    yr_free(literal_string);
        -:  432:
    #####:  433:  if (atom_list != NULL)
    #####:  434:    yr_atoms_list_destroy(atom_list);
        -:  435:
    #####:  436:  return result;
        -:  437:}
        -:  438:
        -:  439:#include <limits.h>
        -:  440:
        -:  441:#include <yara/integers.h>
        -:  442:
        -:  443:
    #####:  444:int yr_parser_reduce_string_declaration(
        -:  445:    yyscan_t yyscanner,
        -:  446:    int32_t string_flags,
        -:  447:    const char* identifier,
        -:  448:    SIZED_STRING* str,
        -:  449:    YR_STRING** string)
        -:  450:{
        -:  451:  int min_atom_quality;
        -:  452:  int min_atom_quality_aux;
        -:  453:
        -:  454:  int32_t min_gap;
        -:  455:  int32_t max_gap;
        -:  456:
        -:  457:  char message[512];
        -:  458:
    #####:  459:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  460:  YR_STRING* aux_string;
        -:  461:  YR_STRING* prev_string;
        -:  462:
    #####:  463:  RE_AST* re_ast = NULL;
    #####:  464:  RE_AST* remainder_re_ast = NULL;
        -:  465:
        -:  466:  RE_ERROR re_error;
        -:  467:
    #####:  468:  int result = ERROR_SUCCESS;
        -:  469:
        -:  470:  // Determine if a string with the same identifier was already defined
        -:  471:  // by searching for the identifier in string_table.
        -:  472:
    #####:  473:  *string = (YR_STRING*) yr_hash_table_lookup(
        -:  474:      compiler->strings_table,
        -:  475:      identifier,
        -:  476:      NULL);
        -:  477:
    #####:  478:  if (*string != NULL)
        -:  479:  {
    #####:  480:    result = ERROR_DUPLICATED_STRING_IDENTIFIER;
    #####:  481:    yr_compiler_set_error_extra_info(compiler, identifier);
    #####:  482:    goto _exit;
        -:  483:  }
        -:  484:
        -:  485:  // Empty strings are not allowed
        -:  486:
    #####:  487:  if (str->length == 0)
        -:  488:  {
    #####:  489:    result = ERROR_EMPTY_STRING;
    #####:  490:    yr_compiler_set_error_extra_info(compiler, identifier);
    #####:  491:    goto _exit;
        -:  492:  }
        -:  493:
    #####:  494:  if (str->flags & SIZED_STRING_FLAGS_NO_CASE)
    #####:  495:    string_flags |= STRING_GFLAGS_NO_CASE;
        -:  496:
    #####:  497:  if (str->flags & SIZED_STRING_FLAGS_DOT_ALL)
    #####:  498:    string_flags |= STRING_GFLAGS_DOT_ALL;
        -:  499:
    #####:  500:  if (strcmp(identifier,"$") == 0)
    #####:  501:    string_flags |= STRING_GFLAGS_ANONYMOUS;
        -:  502:
    #####:  503:  if (!(string_flags & STRING_GFLAGS_WIDE) &&
    #####:  504:      !(string_flags & STRING_GFLAGS_XOR))
    #####:  505:    string_flags |= STRING_GFLAGS_ASCII;
        -:  506:
        -:  507:  // Hex strings are always handled as DOT_ALL regexps.
        -:  508:
    #####:  509:  if (string_flags & STRING_GFLAGS_HEXADECIMAL)
    #####:  510:    string_flags |= STRING_GFLAGS_DOT_ALL;
        -:  511:
        -:  512:  // The STRING_GFLAGS_SINGLE_MATCH flag indicates that finding
        -:  513:  // a single match for the string is enough. This is true in
        -:  514:  // most cases, except when the string count (#) and string offset (@)
        -:  515:  // operators are used. All strings are marked STRING_FLAGS_SINGLE_MATCH
        -:  516:  // initially, and unmarked later if required.
        -:  517:
    #####:  518:  string_flags |= STRING_GFLAGS_SINGLE_MATCH;
        -:  519:
        -:  520:  // The STRING_GFLAGS_FIXED_OFFSET indicates that the string doesn't
        -:  521:  // need to be searched all over the file because the user is using the
        -:  522:  // "at" operator. The string must be searched at a fixed offset in the
        -:  523:  // file. All strings are marked STRING_GFLAGS_FIXED_OFFSET initially,
        -:  524:  // and unmarked later if required.
        -:  525:
    #####:  526:  string_flags |= STRING_GFLAGS_FIXED_OFFSET;
        -:  527:
    #####:  528:  if (string_flags & STRING_GFLAGS_HEXADECIMAL ||
    #####:  529:      string_flags & STRING_GFLAGS_REGEXP)
        -:  530:  {
    #####:  531:    if (string_flags & STRING_GFLAGS_HEXADECIMAL)
    #####:  532:      result = yr_re_parse_hex(str->c_string, &re_ast, &re_error);
        -:  533:    else
    #####:  534:      result = yr_re_parse(str->c_string, &re_ast, &re_error);
        -:  535:
    #####:  536:    if (result != ERROR_SUCCESS)
        -:  537:    {
    #####:  538:      snprintf(
        -:  539:          message,
        -:  540:          sizeof(message),
        -:  541:          "invalid %s \"%s\": %s",
    #####:  542:          (string_flags & STRING_GFLAGS_HEXADECIMAL) ?
        -:  543:              "hex string" : "regular expression",
        -:  544:          identifier,
        -:  545:          re_error.message);
        -:  546:
    #####:  547:      yr_compiler_set_error_extra_info(
        -:  548:          compiler, message);
        -:  549:
    #####:  550:      goto _exit;
        -:  551:    }
        -:  552:
    #####:  553:    if (re_ast->flags & RE_FLAGS_FAST_REGEXP)
    #####:  554:      string_flags |= STRING_GFLAGS_FAST_REGEXP;
        -:  555:
        -:  556:    // Regular expressions in the strings section can't mix greedy and ungreedy
        -:  557:    // quantifiers like .* and .*?. That's because these regular expressions can
        -:  558:    // be matched forwards and/or backwards depending on the atom found, and we
        -:  559:    // need the regexp to be all-greedy or all-ungreedy to be able to properly
        -:  560:    // calculate the length of the match.
        -:  561:
    #####:  562:    if ((re_ast->flags & RE_FLAGS_GREEDY) &&
    #####:  563:        (re_ast->flags & RE_FLAGS_UNGREEDY))
        -:  564:    {
    #####:  565:      result = ERROR_INVALID_REGULAR_EXPRESSION;
        -:  566:
    #####:  567:      yr_compiler_set_error_extra_info(compiler,
        -:  568:          "greedy and ungreedy quantifiers can't be mixed in a regular "
        -:  569:          "expression");
        -:  570:
    #####:  571:      goto _exit;
        -:  572:    }
        -:  573:
    #####:  574:    if (re_ast->flags & RE_FLAGS_GREEDY)
    #####:  575:      string_flags |= STRING_GFLAGS_GREEDY_REGEXP;
        -:  576:
    #####:  577:    if (yr_re_ast_contains_dot_star(re_ast))
        -:  578:    {
    #####:  579:      yywarning(
        -:  580:          yyscanner,
        -:  581:          "%s contains .* or .+, consider using .{N} or .{1,N} with a reasonable value for N",
        -:  582:          identifier);
        -:  583:    }
        -:  584:
    #####:  585:    if (compiler->re_ast_callback != NULL)
        -:  586:    {
    #####:  587:      compiler->re_ast_callback(
    #####:  588:          compiler->current_rule,
        -:  589:          identifier,
        -:  590:          re_ast,
        -:  591:          compiler->re_ast_clbk_user_data);
        -:  592:    }
        -:  593:
    #####:  594:    result = yr_re_ast_split_at_chaining_point(
        -:  595:        re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);
        -:  596:
    #####:  597:    if (result != ERROR_SUCCESS)
    #####:  598:      goto _exit;
        -:  599:
    #####:  600:    result = _yr_parser_write_string(
        -:  601:        identifier,
        -:  602:        string_flags,
        -:  603:        compiler,
        -:  604:        NULL,
        -:  605:        re_ast,
        -:  606:        string,
        -:  607:        &min_atom_quality);
        -:  608:
    #####:  609:    if (result != ERROR_SUCCESS)
    #####:  610:      goto _exit;
        -:  611:
    #####:  612:    if (remainder_re_ast != NULL)
        -:  613:    {
    #####:  614:      (*string)->g_flags |= STRING_GFLAGS_CHAIN_TAIL | STRING_GFLAGS_CHAIN_PART;
    #####:  615:      (*string)->chain_gap_min = min_gap;
    #####:  616:      (*string)->chain_gap_max = max_gap;
        -:  617:    }
        -:  618:
        -:  619:    // Use "aux_string" from now on, we want to keep the value of "string"
        -:  620:    // because it will returned.
        -:  621:
    #####:  622:    aux_string = *string;
        -:  623:
    #####:  624:    while (remainder_re_ast != NULL)
        -:  625:    {
        -:  626:      // Destroy regexp pointed by 're_ast' before yr_re_split_at_chaining_point
        -:  627:      // overwrites 're_ast' with another value.
        -:  628:
    #####:  629:      yr_re_ast_destroy(re_ast);
        -:  630:
    #####:  631:      result = yr_re_ast_split_at_chaining_point(
        -:  632:          remainder_re_ast, &re_ast, &remainder_re_ast, &min_gap, &max_gap);
        -:  633:
    #####:  634:      if (result != ERROR_SUCCESS)
    #####:  635:        goto _exit;
        -:  636:
    #####:  637:      prev_string = aux_string;
        -:  638:
    #####:  639:      result = _yr_parser_write_string(
        -:  640:          identifier,
        -:  641:          string_flags,
        -:  642:          compiler,
        -:  643:          NULL,
        -:  644:          re_ast,
        -:  645:          &aux_string,
        -:  646:          &min_atom_quality_aux);
        -:  647:
    #####:  648:      if (result != ERROR_SUCCESS)
    #####:  649:        goto _exit;
        -:  650:
    #####:  651:      if (min_atom_quality_aux < min_atom_quality)
    #####:  652:        min_atom_quality = min_atom_quality_aux;
        -:  653:
    #####:  654:      aux_string->g_flags |= STRING_GFLAGS_CHAIN_PART;
    #####:  655:      aux_string->chain_gap_min = min_gap;
    #####:  656:      aux_string->chain_gap_max = max_gap;
        -:  657:
    #####:  658:      prev_string->chained_to = aux_string;
        -:  659:
        -:  660:      // prev_string is now chained to aux_string, an string chained
        -:  661:      // to another one can't have a fixed offset, only the head of the
        -:  662:      // string chain can have a fixed offset.
        -:  663:
    #####:  664:      prev_string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  665:    }
        -:  666:  }
        -:  667:  else
        -:  668:  {
    #####:  669:    result = _yr_parser_write_string(
        -:  670:        identifier,
        -:  671:        string_flags,
        -:  672:        compiler,
        -:  673:        str,
        -:  674:        NULL,
        -:  675:        string,
        -:  676:        &min_atom_quality);
        -:  677:
    #####:  678:    if (result != ERROR_SUCCESS)
    #####:  679:      goto _exit;
        -:  680:  }
        -:  681:
    #####:  682:  if (!STRING_IS_ANONYMOUS(*string))
        -:  683:  {
    #####:  684:    result = yr_hash_table_add(
        -:  685:      compiler->strings_table,
        -:  686:      identifier,
        -:  687:      NULL,
        -:  688:      *string);
        -:  689:
    #####:  690:    if (result != ERROR_SUCCESS)
    #####:  691:      goto _exit;
        -:  692:  }
        -:  693:
    #####:  694:  if (min_atom_quality < compiler->atoms_config.quality_warning_threshold)
        -:  695:  {
    #####:  696:    yywarning(
        -:  697:        yyscanner,
        -:  698:        "%s is slowing down scanning",
    #####:  699:        (*string)->identifier);
        -:  700:  }
        -:  701:
    #####:  702:_exit:
        -:  703:
    #####:  704:  if (re_ast != NULL)
    #####:  705:    yr_re_ast_destroy(re_ast);
        -:  706:
    #####:  707:  if (remainder_re_ast != NULL)
    #####:  708:    yr_re_ast_destroy(remainder_re_ast);
        -:  709:
    #####:  710:  return result;
        -:  711:}
        -:  712:
        -:  713:
        1:  714:int yr_parser_reduce_rule_declaration_phase_1(
        -:  715:    yyscan_t yyscanner,
        -:  716:    int32_t flags,
        -:  717:    const char* identifier,
        -:  718:    YR_RULE** rule)
        -:  719:{
        -:  720:  YR_FIXUP *fixup;
        -:  721:  YR_INIT_RULE_ARGS *init_rule_args;
        1:  722:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  723:
        1:  724:  *rule = NULL;
        -:  725:
        1:  726:  if (yr_hash_table_lookup(
        -:  727:        compiler->rules_table,
        -:  728:        identifier,
        2:  729:        compiler->current_namespace->name) != NULL ||
        1:  730:      yr_hash_table_lookup(
        -:  731:        compiler->objects_table,
        -:  732:        identifier,
        1:  733:        compiler->current_namespace->name) != NULL)
        -:  734:  {
        -:  735:    // A rule or variable with the same identifier already exists, return the
        -:  736:    // appropriate error.
        -:  737:
    #####:  738:    yr_compiler_set_error_extra_info(compiler, identifier);
    #####:  739:    return ERROR_DUPLICATED_IDENTIFIER;
        -:  740:  }
        -:  741:
       1*:  742:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -:  743:      compiler->rules_arena,
        -:  744:      sizeof(YR_RULE),
        -:  745:      (void**) rule,
        -:  746:      offsetof(YR_RULE, identifier),
        -:  747:      offsetof(YR_RULE, tags),
        -:  748:      offsetof(YR_RULE, strings),
        -:  749:      offsetof(YR_RULE, metas),
        -:  750:      offsetof(YR_RULE, ns),
        -:  751:      EOL))
        -:  752:
        1:  753:  (*rule)->g_flags = flags;
        1:  754:  (*rule)->ns = compiler->current_namespace;
        -:  755:
        -:  756:  #ifdef PROFILING_ENABLED
        -:  757:  rule->time_cost = 0;
        -:  758:  #endif
        -:  759:
       1*:  760:  FAIL_ON_ERROR(yr_arena_write_string(
        -:  761:      compiler->sz_arena,
        -:  762:      identifier,
        -:  763:      (char**) &(*rule)->identifier));
        -:  764:
       1*:  765:  FAIL_ON_ERROR(yr_parser_emit(
        -:  766:      yyscanner,
        -:  767:      OP_INIT_RULE,
        -:  768:      NULL));
        -:  769:
       1*:  770:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -:  771:      compiler->code_arena,
        -:  772:      sizeof(YR_INIT_RULE_ARGS),
        -:  773:      (void**) &init_rule_args,
        -:  774:      offsetof(YR_INIT_RULE_ARGS, rule),
        -:  775:      offsetof(YR_INIT_RULE_ARGS, jmp_addr),
        -:  776:      EOL));
        -:  777:
        1:  778:  init_rule_args->rule = *rule;
        -:  779:
        -:  780:  // jmp_addr holds the address to jump to when we want to skip the code for
        -:  781:  // the rule. It is iniatialized as NULL at this point because we don't know
        -:  782:  // the address until emmiting the code for the rule's condition. The address
        -:  783:  // is set in yr_parser_reduce_rule_declaration_phase_2.
        1:  784:  init_rule_args->jmp_addr = NULL;
        -:  785:
        -:  786:  // Create a fixup entry for the jump and push it in the stack
        1:  787:  fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -:  788:
        1:  789:  if (fixup == NULL)
    #####:  790:    return ERROR_INSUFFICIENT_MEMORY;
        -:  791:
        1:  792:  fixup->address = (void*) &(init_rule_args->jmp_addr);
        1:  793:  fixup->next = compiler->fixup_stack_head;
        1:  794:  compiler->fixup_stack_head = fixup;
        -:  795:
        -:  796:  // Clean strings_table as we are starting to parse a new rule.
        1:  797:  yr_hash_table_clean(compiler->strings_table, NULL);
        -:  798:
       1*:  799:  FAIL_ON_ERROR(yr_hash_table_add(
        -:  800:      compiler->rules_table,
        -:  801:      identifier,
        -:  802:      compiler->current_namespace->name,
        -:  803:      (void*) *rule));
        -:  804:
        1:  805:  compiler->current_rule = *rule;
        -:  806:
        1:  807:  return ERROR_SUCCESS;
        -:  808:}
        -:  809:
        1:  810:int yr_parser_reduce_rule_declaration_phase_2(
        -:  811:    yyscan_t yyscanner,
        -:  812:    YR_RULE* rule)
        -:  813:{
        -:  814:  uint32_t max_strings_per_rule;
        1:  815:  uint32_t strings_in_rule = 0;
        1:  816:  uint8_t* nop_inst_addr = NULL;
        -:  817:
        -:  818:  int result;
        -:  819:
        -:  820:  YR_FIXUP *fixup;
        1:  821:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  822:
        -:  823:  // Check for unreferenced (unused) strings.
        -:  824:
        1:  825:  YR_STRING* string = rule->strings;
        -:  826:
        1:  827:  yr_get_configuration(
        -:  828:      YR_CONFIG_MAX_STRINGS_PER_RULE,
        -:  829:      (void*) &max_strings_per_rule);
        -:  830:
       1*:  831:  while (!STRING_IS_NULL(string))
        -:  832:  {
        -:  833:    // Only the heading fragment in a chain of strings (the one with
        -:  834:    // chained_to == NULL) must be referenced. All other fragments
        -:  835:    // are never marked as referenced.
        -:  836:
    #####:  837:    if (!STRING_IS_REFERENCED(string) &&
    #####:  838:        string->chained_to == NULL)
        -:  839:    {
    #####:  840:      yr_compiler_set_error_extra_info(compiler, string->identifier);
    #####:  841:      return ERROR_UNREFERENCED_STRING;
        -:  842:    }
        -:  843:
    #####:  844:    strings_in_rule++;
        -:  845:
    #####:  846:    if (strings_in_rule > max_strings_per_rule)
        -:  847:    {
    #####:  848:      yr_compiler_set_error_extra_info(compiler, rule->identifier);
    #####:  849:      return ERROR_TOO_MANY_STRINGS;
        -:  850:    }
        -:  851:
    #####:  852:    string = (YR_STRING*) yr_arena_next_address(
        -:  853:        compiler->strings_arena,
        -:  854:        string,
        -:  855:        sizeof(YR_STRING));
        -:  856:  }
        -:  857:
        1:  858:  result = yr_parser_emit_with_arg_reloc(
        -:  859:      yyscanner,
        -:  860:      OP_MATCH_RULE,
        -:  861:      rule,
        -:  862:      NULL,
        -:  863:      NULL);
        -:  864:
        -:  865:  // Generate a do-nothing instruction (NOP) in order to get its address
        -:  866:  // and use it as the destination for the OP_INIT_RULE skip jump. We can not
        -:  867:  // simply use the address of the OP_MATCH_RULE instruction +1 because we
        -:  868:  // can't be sure that the instruction following the OP_MATCH_RULE is going to
        -:  869:  // be in the same arena page. As we don't have a reliable way of getting the
        -:  870:  // address of the next instruction we generate the OP_NOP.
        -:  871:
        1:  872:  if (result == ERROR_SUCCESS)
        1:  873:    result = yr_parser_emit(yyscanner, OP_NOP, &nop_inst_addr);
        -:  874:
        1:  875:  fixup = compiler->fixup_stack_head;
        1:  876:  *(void**)(fixup->address) = (void*) nop_inst_addr;
        1:  877:  compiler->fixup_stack_head = fixup->next;
        1:  878:  yr_free(fixup);
        -:  879:
        1:  880:  return result;
        -:  881:}
        -:  882:
        -:  883:
    #####:  884:int yr_parser_reduce_string_identifier(
        -:  885:    yyscan_t yyscanner,
        -:  886:    const char* identifier,
        -:  887:    uint8_t instruction,
        -:  888:    uint64_t at_offset)
        -:  889:{
        -:  890:  YR_STRING* string;
    #####:  891:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  892:
    #####:  893:  if (strcmp(identifier, "$") == 0) // is an anonymous string ?
        -:  894:  {
    #####:  895:    if (compiler->loop_for_of_mem_offset >= 0) // inside a loop ?
        -:  896:    {
    #####:  897:      yr_parser_emit_with_arg(
        -:  898:          yyscanner,
        -:  899:          OP_PUSH_M,
    #####:  900:          compiler->loop_for_of_mem_offset,
        -:  901:          NULL,
        -:  902:          NULL);
        -:  903:
    #####:  904:      yr_parser_emit(yyscanner, instruction, NULL);
        -:  905:
    #####:  906:      string = compiler->current_rule->strings;
        -:  907:
    #####:  908:      while(!STRING_IS_NULL(string))
        -:  909:      {
    #####:  910:        if (instruction != OP_FOUND)
    #####:  911:          string->g_flags &= ~STRING_GFLAGS_SINGLE_MATCH;
        -:  912:
    #####:  913:        if (instruction == OP_FOUND_AT)
        -:  914:        {
        -:  915:          // Avoid overwriting any previous fixed offset
        -:  916:
    #####:  917:          if (string->fixed_offset == UNDEFINED)
    #####:  918:            string->fixed_offset = at_offset;
        -:  919:
        -:  920:          // If a previous fixed offset was different, disable
        -:  921:          // the STRING_GFLAGS_FIXED_OFFSET flag because we only
        -:  922:          // have room to store a single fixed offset value
        -:  923:
    #####:  924:          if (string->fixed_offset != at_offset)
    #####:  925:            string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  926:        }
        -:  927:        else
        -:  928:        {
    #####:  929:          string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  930:        }
        -:  931:
    #####:  932:        string = (YR_STRING*) yr_arena_next_address(
        -:  933:            compiler->strings_arena,
        -:  934:            string,
        -:  935:            sizeof(YR_STRING));
        -:  936:      }
        -:  937:    }
        -:  938:    else
        -:  939:    {
        -:  940:      // Anonymous strings not allowed outside of a loop
    #####:  941:      return ERROR_MISPLACED_ANONYMOUS_STRING;
        -:  942:    }
        -:  943:  }
        -:  944:  else
        -:  945:  {
    #####:  946:    FAIL_ON_ERROR(yr_parser_lookup_string(
        -:  947:        yyscanner, identifier, &string));
        -:  948:
    #####:  949:    FAIL_ON_ERROR(yr_parser_emit_with_arg_reloc(
        -:  950:        yyscanner,
        -:  951:        OP_PUSH,
        -:  952:        string,
        -:  953:        NULL,
        -:  954:        NULL));
        -:  955:
    #####:  956:    if (instruction != OP_FOUND)
    #####:  957:      string->g_flags &= ~STRING_GFLAGS_SINGLE_MATCH;
        -:  958:
    #####:  959:    if (instruction == OP_FOUND_AT)
        -:  960:    {
        -:  961:      // Avoid overwriting any previous fixed offset
        -:  962:
    #####:  963:      if (string->fixed_offset == UNDEFINED)
    #####:  964:        string->fixed_offset = at_offset;
        -:  965:
        -:  966:      // If a previous fixed offset was different, disable
        -:  967:      // the STRING_GFLAGS_FIXED_OFFSET flag because we only
        -:  968:      // have room to store a single fixed offset value
        -:  969:
    #####:  970:      if (string->fixed_offset == UNDEFINED ||
    #####:  971:          string->fixed_offset != at_offset)
        -:  972:      {
    #####:  973:        string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  974:      }
        -:  975:    }
        -:  976:    else
        -:  977:    {
    #####:  978:      string->g_flags &= ~STRING_GFLAGS_FIXED_OFFSET;
        -:  979:    }
        -:  980:
    #####:  981:    FAIL_ON_ERROR(yr_parser_emit(yyscanner, instruction, NULL));
        -:  982:
    #####:  983:    string->g_flags |= STRING_GFLAGS_REFERENCED;
        -:  984:  }
        -:  985:
    #####:  986:  return ERROR_SUCCESS;
        -:  987:}
        -:  988:
        -:  989:
    #####:  990:int yr_parser_reduce_meta_declaration(
        -:  991:    yyscan_t yyscanner,
        -:  992:    int32_t type,
        -:  993:    const char* identifier,
        -:  994:    const char* string,
        -:  995:    int64_t integer,
        -:  996:    YR_META** meta)
        -:  997:{
    #####:  998:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  999:
    #####: 1000:  FAIL_ON_ERROR(yr_arena_allocate_struct(
        -: 1001:      compiler->metas_arena,
        -: 1002:      sizeof(YR_META),
        -: 1003:      (void**) meta,
        -: 1004:      offsetof(YR_META, identifier),
        -: 1005:      offsetof(YR_META, string),
        -: 1006:      EOL));
        -: 1007:
    #####: 1008:  FAIL_ON_ERROR(yr_arena_write_string(
        -: 1009:      compiler->sz_arena,
        -: 1010:      identifier,
        -: 1011:      (char**) &(*meta)->identifier));
        -: 1012:
    #####: 1013:  if (string != NULL)
        -: 1014:  {
    #####: 1015:    FAIL_ON_ERROR(yr_arena_write_string(
        -: 1016:        compiler->sz_arena,
        -: 1017:        string,
        -: 1018:        &(*meta)->string));
        -: 1019:  }
        -: 1020:  else
        -: 1021:  {
    #####: 1022:    (*meta)->string = NULL;
        -: 1023:  }
        -: 1024:
    #####: 1025:  (*meta)->integer = integer;
    #####: 1026:  (*meta)->type = type;
        -: 1027:
    #####: 1028:  return ERROR_SUCCESS;
        -: 1029:}
        -: 1030:
        -: 1031:
    #####: 1032:static int _yr_parser_valid_module_name(
        -: 1033:    SIZED_STRING* module_name)
        -: 1034:{
    #####: 1035:  if (module_name->length == 0)
    #####: 1036:    return false;
        -: 1037:
    #####: 1038:  if (strlen(module_name->c_string) != module_name->length)
    #####: 1039:    return false;
        -: 1040:
    #####: 1041:  return true;
        -: 1042:}
        -: 1043:
        -: 1044:
    #####: 1045:int yr_parser_reduce_import(
        -: 1046:    yyscan_t yyscanner,
        -: 1047:    SIZED_STRING* module_name)
        -: 1048:{
    #####: 1049:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1050:  YR_OBJECT* module_structure;
        -: 1051:
        -: 1052:  char* name;
        -: 1053:
    #####: 1054:  if (!_yr_parser_valid_module_name(module_name))
        -: 1055:  {
    #####: 1056:    yr_compiler_set_error_extra_info(compiler, module_name->c_string);
    #####: 1057:    return ERROR_INVALID_MODULE_NAME;
        -: 1058:  }
        -: 1059:
    #####: 1060:  module_structure = (YR_OBJECT*) yr_hash_table_lookup(
        -: 1061:      compiler->objects_table,
    #####: 1062:      module_name->c_string,
    #####: 1063:      compiler->current_namespace->name);
        -: 1064:
        -: 1065:  // if module already imported, do nothing
        -: 1066:
    #####: 1067:  if (module_structure != NULL)
    #####: 1068:    return ERROR_SUCCESS;
        -: 1069:
    #####: 1070:  FAIL_ON_ERROR(yr_object_create(
        -: 1071:      OBJECT_TYPE_STRUCTURE,
        -: 1072:      module_name->c_string,
        -: 1073:      NULL,
        -: 1074:      &module_structure));
        -: 1075:
    #####: 1076:  FAIL_ON_ERROR(yr_hash_table_add(
        -: 1077:      compiler->objects_table,
        -: 1078:      module_name->c_string,
        -: 1079:      compiler->current_namespace->name,
        -: 1080:      module_structure));
        -: 1081:
    #####: 1082:  int result = yr_modules_do_declarations(
    #####: 1083:      module_name->c_string,
        -: 1084:      module_structure);
        -: 1085:
    #####: 1086:  if (result == ERROR_UNKNOWN_MODULE)
    #####: 1087:    yr_compiler_set_error_extra_info(compiler, module_name->c_string);
        -: 1088:
    #####: 1089:  if (result != ERROR_SUCCESS)
    #####: 1090:    return result;
        -: 1091:
    #####: 1092:  FAIL_ON_ERROR(yr_arena_write_string(
        -: 1093:      compiler->sz_arena,
        -: 1094:      module_name->c_string,
        -: 1095:      &name));
        -: 1096:
    #####: 1097:  FAIL_ON_ERROR(yr_parser_emit_with_arg_reloc(
        -: 1098:        yyscanner,
        -: 1099:        OP_IMPORT,
        -: 1100:        name,
        -: 1101:        NULL,
        -: 1102:        NULL));
        -: 1103:
    #####: 1104:  return ERROR_SUCCESS;
        -: 1105:}
        -: 1106:
        -: 1107:
    #####: 1108:static int _yr_parser_operator_to_opcode(
        -: 1109:    const char* op,
        -: 1110:    int expression_type)
        -: 1111:{
    #####: 1112:  int opcode = 0;
        -: 1113:
    #####: 1114:  switch(expression_type)
        -: 1115:  {
    #####: 1116:    case EXPRESSION_TYPE_INTEGER:
    #####: 1117:      opcode = OP_INT_BEGIN;
    #####: 1118:      break;
    #####: 1119:    case EXPRESSION_TYPE_FLOAT:
    #####: 1120:      opcode = OP_DBL_BEGIN;
    #####: 1121:      break;
    #####: 1122:    case EXPRESSION_TYPE_STRING:
    #####: 1123:      opcode = OP_STR_BEGIN;
    #####: 1124:      break;
    #####: 1125:    default:
    #####: 1126:      assert(false);
        -: 1127:  }
        -: 1128:
    #####: 1129:  if (op[0] == '<')
        -: 1130:  {
    #####: 1131:    if (op[1] == '=')
    #####: 1132:      opcode += _OP_LE;
        -: 1133:    else
    #####: 1134:      opcode += _OP_LT;
        -: 1135:  }
    #####: 1136:  else if (op[0] == '>')
        -: 1137:  {
    #####: 1138:    if (op[1] == '=')
    #####: 1139:      opcode += _OP_GE;
        -: 1140:    else
    #####: 1141:      opcode += _OP_GT;
        -: 1142:  }
    #####: 1143:  else if (op[1] == '=')
        -: 1144:  {
    #####: 1145:    if (op[0] == '=')
    #####: 1146:      opcode += _OP_EQ;
        -: 1147:    else
    #####: 1148:      opcode += _OP_NEQ;
        -: 1149:  }
    #####: 1150:  else if (op[0] == '+')
        -: 1151:  {
    #####: 1152:    opcode += _OP_ADD;
        -: 1153:  }
    #####: 1154:  else if (op[0] == '-')
        -: 1155:  {
    #####: 1156:    opcode += _OP_SUB;
        -: 1157:  }
    #####: 1158:  else if (op[0] == '*')
        -: 1159:  {
    #####: 1160:    opcode += _OP_MUL;
        -: 1161:  }
    #####: 1162:  else if (op[0] == '\\')
        -: 1163:  {
    #####: 1164:    opcode += _OP_DIV;
        -: 1165:  }
        -: 1166:
    #####: 1167:  if (IS_INT_OP(opcode) || IS_DBL_OP(opcode) || IS_STR_OP(opcode))
        -: 1168:  {
    #####: 1169:    return opcode;
        -: 1170:  }
        -: 1171:
    #####: 1172:  return OP_ERROR;
        -: 1173:}
        -: 1174:
        -: 1175:
    #####: 1176:int yr_parser_reduce_operation(
        -: 1177:    yyscan_t yyscanner,
        -: 1178:    const char* op,
        -: 1179:    EXPRESSION left_operand,
        -: 1180:    EXPRESSION right_operand)
        -: 1181:{
    #####: 1182:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -: 1183:
    #####: 1184:  if ((left_operand.type == EXPRESSION_TYPE_INTEGER ||
    #####: 1185:       left_operand.type == EXPRESSION_TYPE_FLOAT) &&
    #####: 1186:      (right_operand.type == EXPRESSION_TYPE_INTEGER ||
    #####: 1187:       right_operand.type == EXPRESSION_TYPE_FLOAT))
    #####: 1188:  {
    #####: 1189:    if (left_operand.type != right_operand.type)
        -: 1190:    {
        -: 1191:      // One operand is double and the other is integer,
        -: 1192:      // cast the integer to double
        -: 1193:
    #####: 1194:      FAIL_ON_ERROR(yr_parser_emit_with_arg(
        -: 1195:          yyscanner,
        -: 1196:          OP_INT_TO_DBL,
        -: 1197:          (left_operand.type == EXPRESSION_TYPE_INTEGER) ? 2 : 1,
        -: 1198:          NULL,
        -: 1199:          NULL));
        -: 1200:    }
        -: 1201:
    #####: 1202:    int expression_type = EXPRESSION_TYPE_FLOAT;
        -: 1203:
    #####: 1204:    if (left_operand.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1205:        right_operand.type == EXPRESSION_TYPE_INTEGER)
        -: 1206:    {
    #####: 1207:      expression_type = EXPRESSION_TYPE_INTEGER;
        -: 1208:    }
        -: 1209:
    #####: 1210:    FAIL_ON_ERROR(yr_parser_emit(
        -: 1211:        yyscanner,
        -: 1212:        _yr_parser_operator_to_opcode(op, expression_type),
        -: 1213:        NULL));
        -: 1214:  }
    #####: 1215:  else if (left_operand.type == EXPRESSION_TYPE_STRING &&
    #####: 1216:           right_operand.type == EXPRESSION_TYPE_STRING)
    #####: 1217:  {
    #####: 1218:    int opcode = _yr_parser_operator_to_opcode(op, EXPRESSION_TYPE_STRING);
        -: 1219:
    #####: 1220:    if (opcode != OP_ERROR)
        -: 1221:    {
    #####: 1222:      FAIL_ON_ERROR(yr_parser_emit(
        -: 1223:          yyscanner,
        -: 1224:          opcode,
        -: 1225:          NULL));
        -: 1226:    }
        -: 1227:    else
        -: 1228:    {
    #####: 1229:      yr_compiler_set_error_extra_info_fmt(
        -: 1230:          compiler, "strings don't support \"%s\" operation", op);
        -: 1231:
    #####: 1232:      return ERROR_WRONG_TYPE;
        -: 1233:    }
        -: 1234:  }
        -: 1235:  else
        -: 1236:  {
    #####: 1237:    yr_compiler_set_error_extra_info(compiler, "type mismatch");
        -: 1238:
    #####: 1239:    return ERROR_WRONG_TYPE;
        -: 1240:  }
        -: 1241:
    #####: 1242:  return ERROR_SUCCESS;
        -: 1243:}
