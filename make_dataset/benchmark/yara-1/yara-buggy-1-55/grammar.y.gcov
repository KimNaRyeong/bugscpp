        -:    0:Source:grammar.y
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:%{
        -:   31:
        -:   32:
        -:   33:#include <assert.h>
        -:   34:#include <stdio.h>
        -:   35:#include <string.h>
        -:   36:#include <limits.h>
        -:   37:#include <stdbool.h>
        -:   38:#include <stdlib.h>
        -:   39:#include <stddef.h>
        -:   40:
        -:   41:#include <yara/integers.h>
        -:   42:#include <yara/utils.h>
        -:   43:#include <yara/strutils.h>
        -:   44:#include <yara/compiler.h>
        -:   45:#include <yara/object.h>
        -:   46:#include <yara/sizedstr.h>
        -:   47:#include <yara/exec.h>
        -:   48:#include <yara/error.h>
        -:   49:#include <yara/mem.h>
        -:   50:#include <yara/lexer.h>
        -:   51:#include <yara/parser.h>
        -:   52:
        -:   53:#if defined(_MSC_VER)
        -:   54:#define llabs _abs64
        -:   55:#endif
        -:   56:
        -:   57:#define YYERROR_VERBOSE
        -:   58:
        -:   59:#define YYMALLOC yr_malloc
        -:   60:#define YYFREE yr_free
        -:   61:
        -:   62:#define INTEGER_SET_ENUMERATION   1
        -:   63:#define INTEGER_SET_RANGE         2
        -:   64:
        -:   65:#define fail_if_error(e) \
        -:   66:    if (e != ERROR_SUCCESS) \
        -:   67:    { \
        -:   68:      compiler->last_error = e; \
        -:   69:      yyerror(yyscanner, compiler, NULL); \
        -:   70:      YYERROR; \
        -:   71:    } \
        -:   72:
        -:   73:
        -:   74:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:   75:    if (((expression.type) & (expected_type)) == 0) \
        -:   76:    { \
        -:   77:      switch(expression.type) \
        -:   78:      { \
        -:   79:        case EXPRESSION_TYPE_INTEGER: \
        -:   80:          yr_compiler_set_error_extra_info( \
        -:   81:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:   82:          break; \
        -:   83:        case EXPRESSION_TYPE_FLOAT: \
        -:   84:          yr_compiler_set_error_extra_info( \
        -:   85:              compiler, "wrong type \"float\" for " op " operator"); \
        -:   86:          break; \
        -:   87:        case EXPRESSION_TYPE_STRING: \
        -:   88:          yr_compiler_set_error_extra_info( \
        -:   89:              compiler, "wrong type \"string\" for " op " operator"); \
        -:   90:          break; \
        -:   91:        case EXPRESSION_TYPE_BOOLEAN: \
        -:   92:          yr_compiler_set_error_extra_info( \
        -:   93:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:   94:          break; \
        -:   95:      } \
        -:   96:      cleanup; \
        -:   97:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:   98:      yyerror(yyscanner, compiler, NULL); \
        -:   99:      YYERROR; \
        -:  100:    }
        -:  101:
        -:  102:
        -:  103:#define check_type(expression, expected_type, op) \
        -:  104:    check_type_with_cleanup(expression, expected_type, op, )
        -:  105:
        -:  106:%}
        -:  107:
        -:  108:
        -:  109:%expect 1   // expect 1 shift/reduce conflicts
        -:  110:
        -:  111:// Uncomment this line to print parsing information that can be useful to
        -:  112:// debug YARA's grammar.
        -:  113:
        -:  114:// %debug
        -:  115:
        -:  116:%name-prefix "yara_yy"
        -:  117:%pure-parser
        -:  118:%parse-param {void *yyscanner}
        -:  119:%parse-param {YR_COMPILER* compiler}
        -:  120:%lex-param {yyscan_t yyscanner}
        -:  121:%lex-param {YR_COMPILER* compiler}
        -:  122:
        -:  123:%token _DOT_DOT_
        -:  124:%token _RULE_
        -:  125:%token _PRIVATE_
        -:  126:%token _GLOBAL_
        -:  127:%token _META_
        -:  128:%token <string> _STRINGS_
        -:  129:%token _CONDITION_
        -:  130:%token <c_string> _IDENTIFIER_
        -:  131:%token <c_string> _STRING_IDENTIFIER_
        -:  132:%token <c_string> _STRING_COUNT_
        -:  133:%token <c_string> _STRING_OFFSET_
        -:  134:%token <c_string> _STRING_LENGTH_
        -:  135:%token <c_string> _STRING_IDENTIFIER_WITH_WILDCARD_
        -:  136:%token <integer> _NUMBER_
        -:  137:%token <double_> _DOUBLE_
        -:  138:%token <integer> _INTEGER_FUNCTION_
        -:  139:%token <sized_string> _TEXT_STRING_
        -:  140:%token <sized_string> _HEX_STRING_
        -:  141:%token <sized_string> _REGEXP_
        -:  142:%token _ASCII_
        -:  143:%token _WIDE_
        -:  144:%token _XOR_
        -:  145:%token _NOCASE_
        -:  146:%token _FULLWORD_
        -:  147:%token _AT_
        -:  148:%token _FILESIZE_
        -:  149:%token _ENTRYPOINT_
        -:  150:%token _ALL_
        -:  151:%token _ANY_
        -:  152:%token _IN_
        -:  153:%token _OF_
        -:  154:%token _FOR_
        -:  155:%token _THEM_
        -:  156:%token _MATCHES_
        -:  157:%token _CONTAINS_
        -:  158:%token _IMPORT_
        -:  159:
        -:  160:%token _TRUE_
        -:  161:%token _FALSE_
        -:  162:
        -:  163:%left _OR_
        -:  164:%left _AND_
        -:  165:%left '|'
        -:  166:%left '^'
        -:  167:%left '&'
        -:  168:%left _EQ_ _NEQ_
        -:  169:%left _LT_ _LE_ _GT_ _GE_
        -:  170:%left _SHIFT_LEFT_ _SHIFT_RIGHT_
        -:  171:%left '+' '-'
        -:  172:%left '*' '\\' '%'
        -:  173:%right _NOT_ '~' UNARY_MINUS
        -:  174:
        -:  175:%type <rule>   rule
        -:  176:
        -:  177:%type <string> strings
        -:  178:%type <string> string_declaration
        -:  179:%type <string> string_declarations
        -:  180:
        -:  181:%type <meta> meta
        -:  182:%type <meta> meta_declaration
        -:  183:%type <meta> meta_declarations
        -:  184:
        -:  185:%type <c_string> tags
        -:  186:%type <c_string> tag_list
        -:  187:
        -:  188:%type <integer> string_modifier
        -:  189:%type <integer> string_modifiers
        -:  190:
        -:  191:%type <integer> integer_set
        -:  192:
        -:  193:%type <integer> rule_modifier
        -:  194:%type <integer> rule_modifiers
        -:  195:
        -:  196:%type <expression> primary_expression
        -:  197:%type <expression> boolean_expression
        -:  198:%type <expression> expression
        -:  199:%type <expression> identifier
        -:  200:%type <expression> regexp
        -:  201:
        -:  202:%type <c_string> arguments
        -:  203:%type <c_string> arguments_list
        -:  204:
    #####:  205:%destructor { yr_free($$); $$ = NULL; } _IDENTIFIER_
    #####:  206:%destructor { yr_free($$); $$ = NULL; } _STRING_COUNT_
    #####:  207:%destructor { yr_free($$); $$ = NULL; } _STRING_OFFSET_
    #####:  208:%destructor { yr_free($$); $$ = NULL; } _STRING_LENGTH_
    #####:  209:%destructor { yr_free($$); $$ = NULL; } _STRING_IDENTIFIER_
    #####:  210:%destructor { yr_free($$); $$ = NULL; } _STRING_IDENTIFIER_WITH_WILDCARD_
    #####:  211:%destructor { yr_free($$); $$ = NULL; } _TEXT_STRING_
    #####:  212:%destructor { yr_free($$); $$ = NULL; } _HEX_STRING_
    #####:  213:%destructor { yr_free($$); $$ = NULL; } _REGEXP_
        -:  214:
    #####:  215:%destructor { yr_free($$); $$ = NULL; } arguments
    #####:  216:%destructor { yr_free($$); $$ = NULL; } arguments_list
        -:  217:
        -:  218:%union {
        -:  219:  EXPRESSION      expression;
        -:  220:  SIZED_STRING*   sized_string;
        -:  221:  char*           c_string;
        -:  222:  int64_t         integer;
        -:  223:  double          double_;
        -:  224:  YR_STRING*      string;
        -:  225:  YR_META*        meta;
        -:  226:  YR_RULE*        rule;
        -:  227:}
        -:  228:
        -:  229:
        -:  230:%%
        -:  231:
        -:  232:rules
        -:  233:    : /* empty */
        -:  234:    | rules rule
        -:  235:    | rules import
        -:  236:    | rules error rule      /* on error skip until next rule..*/
        -:  237:    | rules error import    /* .. or import statement */
        -:  238:    | rules error "include" /* .. or include statement */
        -:  239:    ;
        -:  240:
        -:  241:
        -:  242:import
        -:  243:    : _IMPORT_ _TEXT_STRING_
        -:  244:      {
    #####:  245:        int result = yr_parser_reduce_import(yyscanner, $2);
        -:  246:
    #####:  247:        yr_free($2);
        -:  248:
    #####:  249:        fail_if_error(result);
        -:  250:      }
        -:  251:    ;
        -:  252:
        -:  253:
        -:  254:rule
        -:  255:    : rule_modifiers _RULE_ _IDENTIFIER_
        -:  256:      {
       1*:  257:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -:  258:            yyscanner, (int32_t) $1, $3, &$<rule>$));
        -:  259:      }
        -:  260:      tags '{' meta strings
        -:  261:      {
        1:  262:        YR_RULE* rule = $<rule>4; // rule created in phase 1
        -:  263:
        1:  264:        rule->tags = $5;
        1:  265:        rule->metas = $7;
        1:  266:        rule->strings = $8;
        -:  267:      }
        -:  268:      condition '}'
        -:  269:      {
        1:  270:        int result = yr_parser_reduce_rule_declaration_phase_2(
        1:  271:            yyscanner, $<rule>4); // rule created in phase 1
        -:  272:
        1:  273:        yr_free($3);
        -:  274:
       1*:  275:        fail_if_error(result);
        -:  276:      }
        -:  277:    ;
        -:  278:
        -:  279:
        -:  280:meta
        -:  281:    : /* empty */
        -:  282:      {
        1:  283:        $$ = NULL;
        -:  284:      }
        -:  285:    | _META_ ':' meta_declarations
        -:  286:      {
        -:  287:        // Each rule have a list of meta-data info, consisting in a
        -:  288:        // sequence of YR_META structures. The last YR_META structure does
        -:  289:        // not represent a real meta-data, it's just a end-of-list marker
        -:  290:        // identified by a specific type (META_TYPE_NULL). Here we
        -:  291:        // write the end-of-list marker.
        -:  292:
        -:  293:        YR_META null_meta;
        -:  294:
    #####:  295:        memset(&null_meta, 0xFF, sizeof(YR_META));
    #####:  296:        null_meta.type = META_TYPE_NULL;
        -:  297:
    #####:  298:        int result = yr_arena_write_data(
        -:  299:            compiler->metas_arena,
        -:  300:            &null_meta,
        -:  301:            sizeof(YR_META),
        -:  302:            NULL);
        -:  303:
    #####:  304:        $$ = $3;
        -:  305:
    #####:  306:        fail_if_error(result);
        -:  307:      }
        -:  308:    ;
        -:  309:
        -:  310:
        -:  311:strings
        -:  312:    : /* empty */
        -:  313:      {
        1:  314:        $$ = NULL;
        -:  315:      }
        -:  316:    | _STRINGS_ ':' string_declarations
        -:  317:      {
        -:  318:        // Each rule have a list of strings, consisting in a sequence
        -:  319:        // of YR_STRING structures. The last YR_STRING structure does not
        -:  320:        // represent a real string, it's just a end-of-list marker
        -:  321:        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        -:  322:        // write the end-of-list marker.
        -:  323:
        -:  324:        YR_STRING null_string;
        -:  325:
    #####:  326:        memset(&null_string, 0xFF, sizeof(YR_STRING));
    #####:  327:        null_string.g_flags = STRING_GFLAGS_NULL;
        -:  328:
    #####:  329:        fail_if_error(yr_arena_write_data(
        -:  330:            compiler->strings_arena,
        -:  331:            &null_string,
        -:  332:            sizeof(YR_STRING),
        -:  333:            NULL));
        -:  334:
    #####:  335:        $$ = $3;
        -:  336:      }
        -:  337:    ;
        -:  338:
        -:  339:
        -:  340:condition
        -:  341:    : _CONDITION_ ':' boolean_expression
        -:  342:    ;
        -:  343:
        -:  344:
        -:  345:rule_modifiers
        1:  346:    : /* empty */                      { $$ = 0;  }
    #####:  347:    | rule_modifiers rule_modifier     { $$ = $1 | $2; }
        -:  348:    ;
        -:  349:
        -:  350:
        -:  351:rule_modifier
    #####:  352:    : _PRIVATE_      { $$ = RULE_GFLAGS_PRIVATE; }
    #####:  353:    | _GLOBAL_       { $$ = RULE_GFLAGS_GLOBAL; }
        -:  354:    ;
        -:  355:
        -:  356:
        -:  357:tags
        -:  358:    : /* empty */
        -:  359:      {
        1:  360:        $$ = NULL;
        -:  361:      }
        -:  362:    | ':' tag_list
        -:  363:      {
        -:  364:        // Tags list is represented in the arena as a sequence
        -:  365:        // of null-terminated strings, the sequence ends with an
        -:  366:        // additional null character. Here we write the ending null
        -:  367:        //character. Example: tag1\0tag2\0tag3\0\0
        -:  368:
    #####:  369:        int result = yr_arena_write_string(
    #####:  370:            yyget_extra(yyscanner)->sz_arena, "", NULL);
        -:  371:
    #####:  372:        fail_if_error(result);
        -:  373:
    #####:  374:        $$ = $2;
        -:  375:      }
        -:  376:    ;
        -:  377:
        -:  378:
        -:  379:tag_list
        -:  380:    : _IDENTIFIER_
        -:  381:      {
    #####:  382:        int result = yr_arena_write_string(
    #####:  383:            yyget_extra(yyscanner)->sz_arena, $1, &$$);
        -:  384:
    #####:  385:        yr_free($1);
        -:  386:
    #####:  387:        fail_if_error(result);
        -:  388:      }
        -:  389:    | tag_list _IDENTIFIER_
        -:  390:      {
    #####:  391:        int result = ERROR_SUCCESS;
        -:  392:
    #####:  393:        char* tag_name = $1;
    #####:  394:        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -:  395:
    #####:  396:        while (tag_length > 0)
        -:  397:        {
    #####:  398:          if (strcmp(tag_name, $2) == 0)
        -:  399:          {
    #####:  400:            yr_compiler_set_error_extra_info(compiler, tag_name);
    #####:  401:            result = ERROR_DUPLICATED_TAG_IDENTIFIER;
    #####:  402:            break;
        -:  403:          }
        -:  404:
    #####:  405:          tag_name = (char*) yr_arena_next_address(
    #####:  406:              yyget_extra(yyscanner)->sz_arena,
        -:  407:              tag_name,
        -:  408:              tag_length + 1);
        -:  409:
    #####:  410:          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -:  411:        }
        -:  412:
    #####:  413:        if (result == ERROR_SUCCESS)
    #####:  414:          result = yr_arena_write_string(
    #####:  415:              yyget_extra(yyscanner)->sz_arena, $2, NULL);
        -:  416:
    #####:  417:        yr_free($2);
        -:  418:
    #####:  419:        fail_if_error(result);
        -:  420:
    #####:  421:        $$ = $1;
        -:  422:      }
        -:  423:    ;
        -:  424:
        -:  425:
        -:  426:
        -:  427:meta_declarations
    #####:  428:    : meta_declaration                    {  $$ = $1; }
    #####:  429:    | meta_declarations meta_declaration  {  $$ = $1; }
        -:  430:    ;
        -:  431:
        -:  432:
        -:  433:meta_declaration
        -:  434:    : _IDENTIFIER_ '=' _TEXT_STRING_
        -:  435:      {
    #####:  436:        SIZED_STRING* sized_string = $3;
        -:  437:
    #####:  438:        int result = yr_parser_reduce_meta_declaration(
        -:  439:            yyscanner,
        -:  440:            META_TYPE_STRING,
    #####:  441:            $1,
    #####:  442:            sized_string->c_string,
        -:  443:            0,
        -:  444:            &$$);
        -:  445:
    #####:  446:        yr_free($1);
    #####:  447:        yr_free($3);
        -:  448:
    #####:  449:        fail_if_error(result);
        -:  450:      }
        -:  451:    | _IDENTIFIER_ '=' _NUMBER_
        -:  452:      {
    #####:  453:        int result = yr_parser_reduce_meta_declaration(
        -:  454:            yyscanner,
        -:  455:            META_TYPE_INTEGER,
    #####:  456:            $1,
        -:  457:            NULL,
        -:  458:            $3,
        -:  459:            &$$);
        -:  460:
    #####:  461:        yr_free($1);
        -:  462:
    #####:  463:        fail_if_error(result);
        -:  464:      }
        -:  465:    | _IDENTIFIER_ '=' '-' _NUMBER_
        -:  466:      {
    #####:  467:        int result = yr_parser_reduce_meta_declaration(
        -:  468:            yyscanner,
        -:  469:            META_TYPE_INTEGER,
    #####:  470:            $1,
        -:  471:            NULL,
    #####:  472:            -$4,
        -:  473:            &$$);
        -:  474:
    #####:  475:        yr_free($1);
        -:  476:
    #####:  477:        fail_if_error(result);
        -:  478:      }
        -:  479:    | _IDENTIFIER_ '=' _TRUE_
        -:  480:      {
    #####:  481:        int result = yr_parser_reduce_meta_declaration(
        -:  482:            yyscanner,
        -:  483:            META_TYPE_BOOLEAN,
    #####:  484:            $1,
        -:  485:            NULL,
        -:  486:            true,
        -:  487:            &$$);
        -:  488:
    #####:  489:        yr_free($1);
        -:  490:
    #####:  491:        fail_if_error(result);
        -:  492:      }
        -:  493:    | _IDENTIFIER_ '=' _FALSE_
        -:  494:      {
    #####:  495:        int result = yr_parser_reduce_meta_declaration(
        -:  496:            yyscanner,
        -:  497:            META_TYPE_BOOLEAN,
    #####:  498:            $1,
        -:  499:            NULL,
        -:  500:            false,
        -:  501:            &$$);
        -:  502:
    #####:  503:        yr_free($1);
        -:  504:
    #####:  505:        fail_if_error(result);
        -:  506:      }
        -:  507:    ;
        -:  508:
        -:  509:
        -:  510:string_declarations
    #####:  511:    : string_declaration                      { $$ = $1; }
    #####:  512:    | string_declarations string_declaration  { $$ = $1; }
        -:  513:    ;
        -:  514:
        -:  515:
        -:  516:string_declaration
        -:  517:    : _STRING_IDENTIFIER_ '='
        -:  518:      {
    #####:  519:        compiler->current_line = yyget_lineno(yyscanner);
        -:  520:      }
        -:  521:      _TEXT_STRING_ string_modifiers
        -:  522:      {
    #####:  523:        int result = yr_parser_reduce_string_declaration(
    #####:  524:            yyscanner, (int32_t) $5, $1, $4, &$$);
        -:  525:
    #####:  526:        yr_free($1);
    #####:  527:        yr_free($4);
        -:  528:
    #####:  529:        fail_if_error(result);
    #####:  530:        compiler->current_line = 0;
        -:  531:      }
        -:  532:    | _STRING_IDENTIFIER_ '='
        -:  533:      {
    #####:  534:        compiler->current_line = yyget_lineno(yyscanner);
        -:  535:      }
        -:  536:      _REGEXP_ string_modifiers
        -:  537:      {
    #####:  538:        int result = yr_parser_reduce_string_declaration(
    #####:  539:            yyscanner, (int32_t) $5 | STRING_GFLAGS_REGEXP, $1, $4, &$$);
        -:  540:
    #####:  541:        yr_free($1);
    #####:  542:        yr_free($4);
        -:  543:
    #####:  544:        fail_if_error(result);
        -:  545:
    #####:  546:        compiler->current_line = 0;
        -:  547:      }
        -:  548:    | _STRING_IDENTIFIER_ '=' _HEX_STRING_
        -:  549:      {
    #####:  550:        int result = yr_parser_reduce_string_declaration(
    #####:  551:            yyscanner, STRING_GFLAGS_HEXADECIMAL, $1, $3, &$$);
        -:  552:
    #####:  553:        yr_free($1);
    #####:  554:        yr_free($3);
        -:  555:
    #####:  556:        fail_if_error(result);
        -:  557:      }
        -:  558:    ;
        -:  559:
        -:  560:
        -:  561:string_modifiers
    #####:  562:    : /* empty */                         { $$ = 0; }
    #####:  563:    | string_modifiers string_modifier    { $$ = $1 | $2; }
        -:  564:    ;
        -:  565:
        -:  566:
        -:  567:string_modifier
    #####:  568:    : _WIDE_        { $$ = STRING_GFLAGS_WIDE; }
    #####:  569:    | _ASCII_       { $$ = STRING_GFLAGS_ASCII; }
    #####:  570:    | _NOCASE_      { $$ = STRING_GFLAGS_NO_CASE; }
    #####:  571:    | _FULLWORD_    { $$ = STRING_GFLAGS_FULL_WORD; }
    #####:  572:    | _XOR_         { $$ = STRING_GFLAGS_XOR; }
        -:  573:    ;
        -:  574:
        -:  575:
        -:  576:identifier
        -:  577:    : _IDENTIFIER_
        -:  578:      {
    #####:  579:        int result = ERROR_SUCCESS;
    #####:  580:        int var_index = yr_parser_lookup_loop_variable(yyscanner, $1);
        -:  581:
    #####:  582:        if (var_index >= 0)
        -:  583:        {
    #####:  584:          result = yr_parser_emit_with_arg(
        -:  585:              yyscanner,
        -:  586:              OP_PUSH_M,
    #####:  587:              LOOP_LOCAL_VARS * var_index,
        -:  588:              NULL,
        -:  589:              NULL);
        -:  590:
    #####:  591:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####:  592:          $$.value.integer = UNDEFINED;
    #####:  593:          $$.identifier = compiler->loop_identifier[var_index];
        -:  594:        }
        -:  595:        else
        -:  596:        {
        -:  597:          // Search for identifier within the global namespace, where the
        -:  598:          // externals variables reside.
        -:  599:
    #####:  600:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
    #####:  601:              compiler->objects_table, $1, NULL);
        -:  602:
    #####:  603:          if (object == NULL)
        -:  604:          {
        -:  605:            // If not found, search within the current namespace.
    #####:  606:            char* ns = compiler->current_namespace->name;
        -:  607:
    #####:  608:            object = (YR_OBJECT*) yr_hash_table_lookup(
    #####:  609:                compiler->objects_table, $1, ns);
        -:  610:          }
        -:  611:
    #####:  612:          if (object != NULL)
        -:  613:          {
        -:  614:            char* id;
        -:  615:
    #####:  616:            result = yr_arena_write_string(
    #####:  617:                compiler->sz_arena, $1, &id);
        -:  618:
    #####:  619:            if (result == ERROR_SUCCESS)
    #####:  620:              result = yr_parser_emit_with_arg_reloc(
        -:  621:                  yyscanner,
        -:  622:                  OP_OBJ_LOAD,
        -:  623:                  id,
        -:  624:                  NULL,
        -:  625:                  NULL);
        -:  626:
    #####:  627:            $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  628:            $$.value.object = object;
    #####:  629:            $$.identifier = object->identifier;
        -:  630:          }
        -:  631:          else
        -:  632:          {
    #####:  633:            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
        -:  634:                compiler->rules_table,
    #####:  635:                $1,
    #####:  636:                compiler->current_namespace->name);
        -:  637:
    #####:  638:            if (rule != NULL)
        -:  639:            {
    #####:  640:              result = yr_parser_emit_with_arg_reloc(
        -:  641:                  yyscanner,
        -:  642:                  OP_PUSH_RULE,
        -:  643:                  rule,
        -:  644:                  NULL,
        -:  645:                  NULL);
        -:  646:
    #####:  647:              $$.type = EXPRESSION_TYPE_BOOLEAN;
    #####:  648:              $$.value.integer = UNDEFINED;
    #####:  649:              $$.identifier = rule->identifier;
        -:  650:            }
        -:  651:            else
        -:  652:            {
    #####:  653:              yr_compiler_set_error_extra_info(compiler, $1);
    #####:  654:              result = ERROR_UNDEFINED_IDENTIFIER;
        -:  655:            }
        -:  656:          }
        -:  657:        }
        -:  658:
    #####:  659:        yr_free($1);
        -:  660:
    #####:  661:        fail_if_error(result);
        -:  662:      }
        -:  663:    | identifier '.' _IDENTIFIER_
        -:  664:      {
    #####:  665:        int result = ERROR_SUCCESS;
    #####:  666:        YR_OBJECT* field = NULL;
        -:  667:
    #####:  668:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  669:            $1.value.object->type == OBJECT_TYPE_STRUCTURE)
        -:  670:        {
    #####:  671:          field = yr_object_lookup_field($1.value.object, $3);
        -:  672:
    #####:  673:          if (field != NULL)
        -:  674:          {
        -:  675:            char* ident;
        -:  676:
    #####:  677:            result = yr_arena_write_string(
    #####:  678:                compiler->sz_arena, $3, &ident);
        -:  679:
    #####:  680:            if (result == ERROR_SUCCESS)
    #####:  681:              result = yr_parser_emit_with_arg_reloc(
        -:  682:                  yyscanner,
        -:  683:                  OP_OBJ_FIELD,
        -:  684:                  ident,
        -:  685:                  NULL,
        -:  686:                  NULL);
        -:  687:
    #####:  688:            $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  689:            $$.value.object = field;
    #####:  690:            $$.identifier = field->identifier;
        -:  691:          }
        -:  692:          else
        -:  693:          {
    #####:  694:            yr_compiler_set_error_extra_info(compiler, $3);
    #####:  695:            result = ERROR_INVALID_FIELD_NAME;
        -:  696:          }
        -:  697:        }
        -:  698:        else
        -:  699:        {
    #####:  700:          yr_compiler_set_error_extra_info(
        -:  701:              compiler, $1.identifier);
        -:  702:
    #####:  703:          result = ERROR_NOT_A_STRUCTURE;
        -:  704:        }
        -:  705:
    #####:  706:        yr_free($3);
        -:  707:
    #####:  708:        fail_if_error(result);
        -:  709:      }
        -:  710:    | identifier '[' primary_expression ']'
        -:  711:      {
    #####:  712:        int result = ERROR_SUCCESS;
        -:  713:        YR_OBJECT_ARRAY* array;
        -:  714:        YR_OBJECT_DICTIONARY* dict;
        -:  715:
    #####:  716:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  717:            $1.value.object->type == OBJECT_TYPE_ARRAY)
        -:  718:        {
    #####:  719:          if ($3.type != EXPRESSION_TYPE_INTEGER)
        -:  720:          {
    #####:  721:            yr_compiler_set_error_extra_info(
        -:  722:                compiler, "array indexes must be of integer type");
    #####:  723:            result = ERROR_WRONG_TYPE;
        -:  724:          }
        -:  725:
    #####:  726:          fail_if_error(result);
        -:  727:
    #####:  728:          result = yr_parser_emit(
        -:  729:              yyscanner, OP_INDEX_ARRAY, NULL);
        -:  730:
    #####:  731:          array = object_as_array($1.value.object);
        -:  732:
    #####:  733:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  734:          $$.value.object = array->prototype_item;
    #####:  735:          $$.identifier = array->identifier;
        -:  736:        }
    #####:  737:        else if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  738:                 $1.value.object->type == OBJECT_TYPE_DICTIONARY)
        -:  739:        {
    #####:  740:          if ($3.type != EXPRESSION_TYPE_STRING)
        -:  741:          {
    #####:  742:            yr_compiler_set_error_extra_info(
        -:  743:                compiler, "dictionary keys must be of string type");
    #####:  744:            result = ERROR_WRONG_TYPE;
        -:  745:          }
        -:  746:
    #####:  747:          fail_if_error(result);
        -:  748:
    #####:  749:          result = yr_parser_emit(
        -:  750:              yyscanner, OP_LOOKUP_DICT, NULL);
        -:  751:
    #####:  752:          dict = object_as_dictionary($1.value.object);
        -:  753:
    #####:  754:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  755:          $$.value.object = dict->prototype_item;
    #####:  756:          $$.identifier = dict->identifier;
        -:  757:        }
        -:  758:        else
        -:  759:        {
    #####:  760:          yr_compiler_set_error_extra_info(
        -:  761:              compiler, $1.identifier);
        -:  762:
    #####:  763:          result = ERROR_NOT_INDEXABLE;
        -:  764:        }
        -:  765:
    #####:  766:        fail_if_error(result);
        -:  767:      }
        -:  768:
        -:  769:    | identifier '(' arguments ')'
        -:  770:      {
    #####:  771:        int result = ERROR_SUCCESS;
        -:  772:        YR_OBJECT_FUNCTION* function;
        -:  773:        char* args_fmt;
        -:  774:
    #####:  775:        if ($1.type == EXPRESSION_TYPE_OBJECT &&
    #####:  776:            $1.value.object->type == OBJECT_TYPE_FUNCTION)
        -:  777:        {
    #####:  778:          result = yr_parser_check_types(
    #####:  779:              compiler, object_as_function($1.value.object), $3);
        -:  780:
    #####:  781:          if (result == ERROR_SUCCESS)
    #####:  782:            result = yr_arena_write_string(
    #####:  783:                compiler->sz_arena, $3, &args_fmt);
        -:  784:
    #####:  785:          if (result == ERROR_SUCCESS)
    #####:  786:            result = yr_parser_emit_with_arg_reloc(
        -:  787:                yyscanner,
        -:  788:                OP_CALL,
        -:  789:                args_fmt,
        -:  790:                NULL,
        -:  791:                NULL);
        -:  792:
    #####:  793:          function = object_as_function($1.value.object);
        -:  794:
    #####:  795:          $$.type = EXPRESSION_TYPE_OBJECT;
    #####:  796:          $$.value.object = function->return_obj;
    #####:  797:          $$.identifier = function->identifier;
        -:  798:        }
        -:  799:        else
        -:  800:        {
    #####:  801:          yr_compiler_set_error_extra_info(
        -:  802:              compiler, $1.identifier);
        -:  803:
    #####:  804:          result = ERROR_NOT_A_FUNCTION;
        -:  805:        }
        -:  806:
    #####:  807:        yr_free($3);
        -:  808:
    #####:  809:        fail_if_error(result);
        -:  810:      }
        -:  811:    ;
        -:  812:
        -:  813:
        -:  814:arguments
    #####:  815:    : /* empty */     { $$ = yr_strdup(""); }
    #####:  816:    | arguments_list  { $$ = $1; }
        -:  817:
        -:  818:
        -:  819:arguments_list
        -:  820:    : expression
        -:  821:      {
    #####:  822:        $$ = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -:  823:
    #####:  824:        if ($$ == NULL)
    #####:  825:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -:  826:
    #####:  827:        switch($1.type)
        -:  828:        {
    #####:  829:          case EXPRESSION_TYPE_INTEGER:
    #####:  830:            strlcpy($$, "i", YR_MAX_FUNCTION_ARGS);
    #####:  831:            break;
    #####:  832:          case EXPRESSION_TYPE_FLOAT:
    #####:  833:            strlcpy($$, "f", YR_MAX_FUNCTION_ARGS);
    #####:  834:            break;
    #####:  835:          case EXPRESSION_TYPE_BOOLEAN:
    #####:  836:            strlcpy($$, "b", YR_MAX_FUNCTION_ARGS);
    #####:  837:            break;
    #####:  838:          case EXPRESSION_TYPE_STRING:
    #####:  839:            strlcpy($$, "s", YR_MAX_FUNCTION_ARGS);
    #####:  840:            break;
    #####:  841:          case EXPRESSION_TYPE_REGEXP:
    #####:  842:            strlcpy($$, "r", YR_MAX_FUNCTION_ARGS);
    #####:  843:            break;
    #####:  844:          default:
    #####:  845:            assert(false);
        -:  846:        }
        -:  847:      }
        -:  848:    | arguments_list ',' expression
        -:  849:      {
    #####:  850:        int result = ERROR_SUCCESS;
        -:  851:
    #####:  852:        if (strlen($1) == YR_MAX_FUNCTION_ARGS)
        -:  853:        {
    #####:  854:          result = ERROR_TOO_MANY_ARGUMENTS;
        -:  855:        }
        -:  856:        else
        -:  857:        {
    #####:  858:          switch($3.type)
        -:  859:          {
    #####:  860:            case EXPRESSION_TYPE_INTEGER:
    #####:  861:              strlcat($1, "i", YR_MAX_FUNCTION_ARGS);
    #####:  862:              break;
    #####:  863:            case EXPRESSION_TYPE_FLOAT:
    #####:  864:              strlcat($1, "f", YR_MAX_FUNCTION_ARGS);
    #####:  865:              break;
    #####:  866:            case EXPRESSION_TYPE_BOOLEAN:
    #####:  867:              strlcat($1, "b", YR_MAX_FUNCTION_ARGS);
    #####:  868:              break;
    #####:  869:            case EXPRESSION_TYPE_STRING:
    #####:  870:              strlcat($1, "s", YR_MAX_FUNCTION_ARGS);
    #####:  871:              break;
    #####:  872:            case EXPRESSION_TYPE_REGEXP:
    #####:  873:              strlcat($1, "r", YR_MAX_FUNCTION_ARGS);
    #####:  874:              break;
    #####:  875:            default:
    #####:  876:              assert(false);
        -:  877:          }
        -:  878:        }
        -:  879:
    #####:  880:        fail_if_error(result);
        -:  881:
    #####:  882:        $$ = $1;
        -:  883:      }
        -:  884:    ;
        -:  885:
        -:  886:
        -:  887:regexp
        -:  888:    : _REGEXP_
        -:  889:      {
    #####:  890:        SIZED_STRING* sized_string = $1;
        -:  891:        RE* re;
        -:  892:        RE_ERROR error;
        -:  893:
    #####:  894:        int result = ERROR_SUCCESS;
    #####:  895:        int re_flags = 0;
        -:  896:
    #####:  897:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
    #####:  898:          re_flags |= RE_FLAGS_NO_CASE;
        -:  899:
    #####:  900:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
    #####:  901:          re_flags |= RE_FLAGS_DOT_ALL;
        -:  902:
    #####:  903:        result = yr_re_compile(
    #####:  904:            sized_string->c_string,
        -:  905:            re_flags,
        -:  906:            compiler->re_code_arena,
        -:  907:            &re,
        -:  908:            &error);
        -:  909:
    #####:  910:        yr_free($1);
        -:  911:
    #####:  912:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
    #####:  913:          yr_compiler_set_error_extra_info(compiler, error.message);
        -:  914:
    #####:  915:        if (result == ERROR_SUCCESS)
    #####:  916:          result = yr_parser_emit_with_arg_reloc(
        -:  917:              yyscanner,
        -:  918:              OP_PUSH,
        -:  919:              re,
        -:  920:              NULL,
        -:  921:              NULL);
        -:  922:
    #####:  923:        fail_if_error(result);
        -:  924:
    #####:  925:        $$.type = EXPRESSION_TYPE_REGEXP;
        -:  926:      }
        -:  927:    ;
        -:  928:
        -:  929:
        -:  930:boolean_expression
        -:  931:    : expression
        -:  932:      {
        1:  933:        if ($1.type == EXPRESSION_TYPE_STRING)
        -:  934:        {
    #####:  935:          if ($1.value.sized_string != NULL)
        -:  936:          {
    #####:  937:            yywarning(yyscanner,
        -:  938:              "Using literal string \"%s\" in a boolean operation.",
    #####:  939:              $1.value.sized_string->c_string);
        -:  940:          }
        -:  941:
    #####:  942:          fail_if_error(yr_parser_emit(
        -:  943:              yyscanner, OP_STR_TO_BOOL, NULL));
        -:  944:        }
        -:  945:
        1:  946:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -:  947:      }
        -:  948:    ;
        -:  949:
        -:  950:expression
        -:  951:    : _TRUE_
        -:  952:      {
       1*:  953:        fail_if_error(yr_parser_emit_with_arg(
        -:  954:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -:  955:
        1:  956:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -:  957:      }
        -:  958:    | _FALSE_
        -:  959:      {
    #####:  960:        fail_if_error(yr_parser_emit_with_arg(
        -:  961:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -:  962:
    #####:  963:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -:  964:      }
        -:  965:    | primary_expression _MATCHES_ regexp
        -:  966:      {
    #####:  967:        check_type($1, EXPRESSION_TYPE_STRING, "matches");
    #####:  968:        check_type($3, EXPRESSION_TYPE_REGEXP, "matches");
        -:  969:
    #####:  970:        fail_if_error(yr_parser_emit(
        -:  971:            yyscanner,
        -:  972:            OP_MATCHES,
        -:  973:            NULL));
        -:  974:
    #####:  975:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -:  976:      }
        -:  977:    | primary_expression _CONTAINS_ primary_expression
        -:  978:      {
    #####:  979:        check_type($1, EXPRESSION_TYPE_STRING, "contains");
    #####:  980:        check_type($3, EXPRESSION_TYPE_STRING, "contains");
        -:  981:
    #####:  982:        fail_if_error(yr_parser_emit(
        -:  983:            yyscanner, OP_CONTAINS, NULL));
        -:  984:
    #####:  985:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -:  986:      }
        -:  987:    | _STRING_IDENTIFIER_
        -:  988:      {
    #####:  989:        int result = yr_parser_reduce_string_identifier(
        -:  990:            yyscanner,
    #####:  991:            $1,
        -:  992:            OP_FOUND,
        -:  993:            UNDEFINED);
        -:  994:
    #####:  995:        yr_free($1);
        -:  996:
    #####:  997:        fail_if_error(result);
        -:  998:
    #####:  999:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1000:      }
        -: 1001:    | _STRING_IDENTIFIER_ _AT_ primary_expression
        -: 1002:      {
    #####: 1003:        check_type_with_cleanup($3, EXPRESSION_TYPE_INTEGER, "at", yr_free($1));
        -: 1004:
    #####: 1005:        int result = yr_parser_reduce_string_identifier(
    #####: 1006:            yyscanner, $1, OP_FOUND_AT, $3.value.integer);
        -: 1007:
    #####: 1008:        yr_free($1);
        -: 1009:
    #####: 1010:        fail_if_error(result);
        -: 1011:
    #####: 1012:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1013:      }
        -: 1014:    | _STRING_IDENTIFIER_ _IN_ range
        -: 1015:      {
    #####: 1016:        int result = yr_parser_reduce_string_identifier(
    #####: 1017:            yyscanner, $1, OP_FOUND_IN, UNDEFINED);
        -: 1018:
    #####: 1019:        yr_free($1);
        -: 1020:
    #####: 1021:        fail_if_error(result);
        -: 1022:
    #####: 1023:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1024:      }
        -: 1025:    | _FOR_ for_expression error
        -: 1026:      {
    #####: 1027:        if (compiler->loop_depth > 0)
        -: 1028:        {
    #####: 1029:          compiler->loop_depth--;
    #####: 1030:          compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 1031:        }
        -: 1032:
    #####: 1033:        YYERROR;
        -: 1034:      }
        -: 1035:    | _FOR_ for_expression _IDENTIFIER_ _IN_
        -: 1036:      {
    #####: 1037:        int result = ERROR_SUCCESS;
        -: 1038:        int var_index;
        -: 1039:
    #####: 1040:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
    #####: 1041:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 1042:
    #####: 1043:        fail_if_error(result);
        -: 1044:
    #####: 1045:        var_index = yr_parser_lookup_loop_variable(
    #####: 1046:            yyscanner, $3);
        -: 1047:
    #####: 1048:        if (var_index >= 0)
        -: 1049:        {
    #####: 1050:          yr_compiler_set_error_extra_info(
        -: 1051:              compiler, $3);
        -: 1052:
    #####: 1053:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 1054:        }
        -: 1055:
    #####: 1056:        fail_if_error(result);
        -: 1057:
        -: 1058:        // Push end-of-list marker
    #####: 1059:        result = yr_parser_emit_with_arg(
        -: 1060:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 1061:
    #####: 1062:        fail_if_error(result);
        -: 1063:      }
        -: 1064:      integer_set ':'
        -: 1065:      {
    #####: 1066:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1067:        uint8_t* addr;
        -: 1068:
        -: 1069:        // Clear counter for number of expressions evaluating
        -: 1070:        // to true.
    #####: 1071:        yr_parser_emit_with_arg(
    #####: 1072:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 1073:
        -: 1074:        // Clear iterations counter
    #####: 1075:        yr_parser_emit_with_arg(
    #####: 1076:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 1077:
    #####: 1078:        if ($6 == INTEGER_SET_ENUMERATION)
        -: 1079:        {
        -: 1080:          // Pop the first integer
    #####: 1081:          yr_parser_emit_with_arg(
        -: 1082:              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 1083:        }
        -: 1084:        else // INTEGER_SET_RANGE
        -: 1085:        {
        -: 1086:          // Pop higher bound of set range
    #####: 1087:          yr_parser_emit_with_arg(
    #####: 1088:              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);
        -: 1089:
        -: 1090:          // Pop lower bound of set range
    #####: 1091:          yr_parser_emit_with_arg(
        -: 1092:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 1093:        }
        -: 1094:
    #####: 1095:        compiler->loop_address[compiler->loop_depth] = addr;
    #####: 1096:        compiler->loop_identifier[compiler->loop_depth] = $3;
    #####: 1097:        compiler->loop_depth++;
        -: 1098:      }
        -: 1099:      '(' boolean_expression ')'
        -: 1100:      {
        -: 1101:        int mem_offset;
        -: 1102:
    #####: 1103:        compiler->loop_depth--;
    #####: 1104:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1105:
        -: 1106:        // The value at the top of the stack is the result of
        -: 1107:        // evaluating the boolean expression, so it could be
        -: 1108:        // 0, 1 or UNDEFINED. Add this value to a counter
        -: 1109:        // keeping the number of expressions evaluating to true.
        -: 1110:        // If the value is UNDEFINED instruction OP_ADD_M
        -: 1111:        // does nothing.
        -: 1112:
    #####: 1113:        yr_parser_emit_with_arg(
    #####: 1114:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 1115:
        -: 1116:        // Increment iterations counter
    #####: 1117:        yr_parser_emit_with_arg(
    #####: 1118:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 1119:
    #####: 1120:        if ($6 == INTEGER_SET_ENUMERATION)
        -: 1121:        {
    #####: 1122:          yr_parser_emit_with_arg_reloc(
        -: 1123:              yyscanner,
        -: 1124:              OP_JNUNDEF,
    #####: 1125:              compiler->loop_address[compiler->loop_depth],
        -: 1126:              NULL,
        -: 1127:              NULL);
        -: 1128:        }
        -: 1129:        else // INTEGER_SET_RANGE
        -: 1130:        {
        -: 1131:          // Increment lower bound of integer set
    #####: 1132:          yr_parser_emit_with_arg(
        -: 1133:              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
        -: 1134:
        -: 1135:          // Push lower bound of integer set
    #####: 1136:          yr_parser_emit_with_arg(
        -: 1137:              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
        -: 1138:
        -: 1139:          // Push higher bound of integer set
    #####: 1140:          yr_parser_emit_with_arg(
    #####: 1141:              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
        -: 1142:
        -: 1143:          // Compare higher bound with lower bound, do loop again
        -: 1144:          // if lower bound is still lower or equal than higher bound
    #####: 1145:          yr_parser_emit_with_arg_reloc(
        -: 1146:              yyscanner,
        -: 1147:              OP_JLE,
    #####: 1148:              compiler->loop_address[compiler->loop_depth],
        -: 1149:              NULL,
        -: 1150:              NULL);
        -: 1151:
    #####: 1152:          yr_parser_emit(yyscanner, OP_POP, NULL);
    #####: 1153:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1154:        }
        -: 1155:
        -: 1156:        // Pop end-of-list marker.
    #####: 1157:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1158:
        -: 1159:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 1160:        // is at the top of the stack. Check if the quantifier
        -: 1161:        // is undefined (meaning "all") and replace it with the
        -: 1162:        // iterations counter in that case.
    #####: 1163:        yr_parser_emit_with_arg(
    #####: 1164:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 1165:
        -: 1166:        // Compare the loop quantifier with the number of
        -: 1167:        // expressions evaluating to true.
    #####: 1168:        yr_parser_emit_with_arg(
    #####: 1169:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 1170:
    #####: 1171:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 1172:
    #####: 1173:        compiler->loop_identifier[compiler->loop_depth] = NULL;
    #####: 1174:        yr_free($3);
        -: 1175:
    #####: 1176:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1177:      }
        -: 1178:    | _FOR_ for_expression _OF_ string_set ':'
        -: 1179:      {
    #####: 1180:        int result = ERROR_SUCCESS;
    #####: 1181:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1182:        uint8_t* addr;
        -: 1183:
    #####: 1184:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
    #####: 1185:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 1186:
    #####: 1187:        if (compiler->loop_for_of_mem_offset != -1)
    #####: 1188:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 1189:
    #####: 1190:        fail_if_error(result);
        -: 1191:
    #####: 1192:        yr_parser_emit_with_arg(
    #####: 1193:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 1194:
    #####: 1195:        yr_parser_emit_with_arg(
    #####: 1196:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 1197:
        -: 1198:        // Pop the first string.
    #####: 1199:        yr_parser_emit_with_arg(
        -: 1200:            yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 1201:
    #####: 1202:        compiler->loop_for_of_mem_offset = mem_offset;
    #####: 1203:        compiler->loop_address[compiler->loop_depth] = addr;
    #####: 1204:        compiler->loop_identifier[compiler->loop_depth] = NULL;
    #####: 1205:        compiler->loop_depth++;
        -: 1206:      }
        -: 1207:      '(' boolean_expression ')'
        -: 1208:      {
        -: 1209:        int mem_offset;
        -: 1210:
    #####: 1211:        compiler->loop_depth--;
    #####: 1212:        compiler->loop_for_of_mem_offset = -1;
        -: 1213:
    #####: 1214:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 1215:
        -: 1216:        // Increment counter by the value returned by the
        -: 1217:        // boolean expression (0 or 1). If the boolean expression
        -: 1218:        // returned UNDEFINED the OP_ADD_M won't do anything.
        -: 1219:
    #####: 1220:        yr_parser_emit_with_arg(
    #####: 1221:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 1222:
        -: 1223:        // Increment iterations counter.
    #####: 1224:        yr_parser_emit_with_arg(
    #####: 1225:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 1226:
        -: 1227:        // If next string is not undefined, go back to the
        -: 1228:        // beginning of the loop.
    #####: 1229:        yr_parser_emit_with_arg_reloc(
        -: 1230:            yyscanner,
        -: 1231:            OP_JNUNDEF,
    #####: 1232:            compiler->loop_address[compiler->loop_depth],
        -: 1233:            NULL,
        -: 1234:            NULL);
        -: 1235:
        -: 1236:        // Pop end-of-list marker.
    #####: 1237:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 1238:
        -: 1239:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 1240:        // is at top of the stack. Check if the quantifier is
        -: 1241:        // undefined (meaning "all") and replace it with the
        -: 1242:        // iterations counter in that case.
    #####: 1243:        yr_parser_emit_with_arg(
    #####: 1244:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 1245:
        -: 1246:        // Compare the loop quantifier with the number of
        -: 1247:        // expressions evaluating to true.
    #####: 1248:        yr_parser_emit_with_arg(
    #####: 1249:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 1250:
    #####: 1251:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 1252:
    #####: 1253:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1254:
        -: 1255:      }
        -: 1256:    | for_expression _OF_ string_set
        -: 1257:      {
    #####: 1258:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 1259:
    #####: 1260:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1261:      }
        -: 1262:    | _NOT_ boolean_expression
        -: 1263:      {
    #####: 1264:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 1265:
    #####: 1266:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1267:      }
        -: 1268:    | boolean_expression _AND_
        -: 1269:      {
        -: 1270:        YR_FIXUP* fixup;
        -: 1271:        void* jmp_destination_addr;
        -: 1272:
    #####: 1273:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 1274:            yyscanner,
        -: 1275:            OP_JFALSE,
        -: 1276:            0,          // still don't know the jump destination
        -: 1277:            NULL,
        -: 1278:            &jmp_destination_addr));
        -: 1279:
        -: 1280:        // create a fixup entry for the jump and push it in the stack
    #####: 1281:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1282:
    #####: 1283:        if (fixup == NULL)
    #####: 1284:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1285:
    #####: 1286:        fixup->address = jmp_destination_addr;
    #####: 1287:        fixup->next = compiler->fixup_stack_head;
    #####: 1288:        compiler->fixup_stack_head = fixup;
        -: 1289:      }
        -: 1290:      boolean_expression
        -: 1291:      {
        -: 1292:        YR_FIXUP* fixup;
        -: 1293:        uint8_t* nop_addr;
        -: 1294:
    #####: 1295:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 1296:
        -: 1297:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 1298:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 1299:        // use the address of the OP_AND instruction +1 because we can't be
        -: 1300:        // sure that the instruction following the OP_AND is going to be in
        -: 1301:        // the same arena page. As we don't have a reliable way of getting the
        -: 1302:        // address of the next instruction we generate the OP_NOP.
        -: 1303:
    #####: 1304:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 1305:
    #####: 1306:        fixup = compiler->fixup_stack_head;
    #####: 1307:        *(void**)(fixup->address) = (void*) nop_addr;
    #####: 1308:        compiler->fixup_stack_head = fixup->next;
    #####: 1309:        yr_free(fixup);
        -: 1310:
    #####: 1311:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1312:      }
        -: 1313:    | boolean_expression _OR_
        -: 1314:      {
        -: 1315:        YR_FIXUP* fixup;
        -: 1316:        void* jmp_destination_addr;
        -: 1317:
    #####: 1318:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 1319:            yyscanner,
        -: 1320:            OP_JTRUE,
        -: 1321:            0,         // still don't know the jump destination
        -: 1322:            NULL,
        -: 1323:            &jmp_destination_addr));
        -: 1324:
    #####: 1325:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 1326:
    #####: 1327:        if (fixup == NULL)
    #####: 1328:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 1329:
    #####: 1330:        fixup->address = jmp_destination_addr;
    #####: 1331:        fixup->next = compiler->fixup_stack_head;
    #####: 1332:        compiler->fixup_stack_head = fixup;
        -: 1333:      }
        -: 1334:      boolean_expression
        -: 1335:      {
        -: 1336:        YR_FIXUP* fixup;
        -: 1337:        uint8_t* nop_addr;
        -: 1338:
    #####: 1339:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 1340:
        -: 1341:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 1342:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 1343:        // use the address of the OP_OR instruction +1 because we can't be
        -: 1344:        // sure that the instruction following the OP_AND is going to be in
        -: 1345:        // the same arena page. As we don't have a reliable way of getting the
        -: 1346:        // address of the next instruction we generate the OP_NOP.
        -: 1347:
    #####: 1348:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 1349:
    #####: 1350:        fixup = compiler->fixup_stack_head;
    #####: 1351:        *(void**)(fixup->address) = (void*)(nop_addr);
    #####: 1352:        compiler->fixup_stack_head = fixup->next;
    #####: 1353:        yr_free(fixup);
        -: 1354:
    #####: 1355:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1356:      }
        -: 1357:    | primary_expression _LT_ primary_expression
        -: 1358:      {
    #####: 1359:        fail_if_error(yr_parser_reduce_operation(
        -: 1360:            yyscanner, "<", $1, $3));
        -: 1361:
    #####: 1362:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1363:      }
        -: 1364:    | primary_expression _GT_ primary_expression
        -: 1365:      {
    #####: 1366:        fail_if_error(yr_parser_reduce_operation(
        -: 1367:            yyscanner, ">", $1, $3));
        -: 1368:
    #####: 1369:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1370:      }
        -: 1371:    | primary_expression _LE_ primary_expression
        -: 1372:      {
    #####: 1373:        fail_if_error(yr_parser_reduce_operation(
        -: 1374:            yyscanner, "<=", $1, $3));
        -: 1375:
    #####: 1376:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1377:      }
        -: 1378:    | primary_expression _GE_ primary_expression
        -: 1379:      {
    #####: 1380:        fail_if_error(yr_parser_reduce_operation(
        -: 1381:            yyscanner, ">=", $1, $3));
        -: 1382:
    #####: 1383:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1384:      }
        -: 1385:    | primary_expression _EQ_ primary_expression
        -: 1386:      {
    #####: 1387:        fail_if_error(yr_parser_reduce_operation(
        -: 1388:            yyscanner, "==", $1, $3));
        -: 1389:
    #####: 1390:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1391:      }
        -: 1392:    | primary_expression _NEQ_ primary_expression
        -: 1393:      {
    #####: 1394:        fail_if_error(yr_parser_reduce_operation(
        -: 1395:            yyscanner, "!=", $1, $3));
        -: 1396:
    #####: 1397:        $$.type = EXPRESSION_TYPE_BOOLEAN;
        -: 1398:      }
        -: 1399:    | primary_expression
        -: 1400:      {
    #####: 1401:        $$ = $1;
        -: 1402:      }
        -: 1403:    |'(' expression ')'
        -: 1404:      {
    #####: 1405:        $$ = $2;
        -: 1406:      }
        -: 1407:    ;
        -: 1408:
        -: 1409:
        -: 1410:integer_set
    #####: 1411:    : '(' integer_enumeration ')'  { $$ = INTEGER_SET_ENUMERATION; }
    #####: 1412:    | range                        { $$ = INTEGER_SET_RANGE; }
        -: 1413:    ;
        -: 1414:
        -: 1415:
        -: 1416:range
        -: 1417:    : '(' primary_expression _DOT_DOT_  primary_expression ')'
        -: 1418:      {
    #####: 1419:        int result = ERROR_SUCCESS;
        -: 1420:
    #####: 1421:        if ($2.type != EXPRESSION_TYPE_INTEGER)
        -: 1422:        {
    #####: 1423:          yr_compiler_set_error_extra_info(
        -: 1424:              compiler, "wrong type for range's lower bound");
    #####: 1425:          result = ERROR_WRONG_TYPE;
        -: 1426:        }
        -: 1427:
    #####: 1428:        if ($4.type != EXPRESSION_TYPE_INTEGER)
        -: 1429:        {
    #####: 1430:          yr_compiler_set_error_extra_info(
        -: 1431:              compiler, "wrong type for range's upper bound");
    #####: 1432:          result = ERROR_WRONG_TYPE;
        -: 1433:        }
        -: 1434:
    #####: 1435:        fail_if_error(result);
        -: 1436:      }
        -: 1437:    ;
        -: 1438:
        -: 1439:
        -: 1440:integer_enumeration
        -: 1441:    : primary_expression
        -: 1442:      {
    #####: 1443:        int result = ERROR_SUCCESS;
        -: 1444:
    #####: 1445:        if ($1.type != EXPRESSION_TYPE_INTEGER)
        -: 1446:        {
    #####: 1447:          yr_compiler_set_error_extra_info(
        -: 1448:              compiler, "wrong type for enumeration item");
    #####: 1449:          result = ERROR_WRONG_TYPE;
        -: 1450:        }
        -: 1451:
    #####: 1452:        fail_if_error(result);
        -: 1453:      }
        -: 1454:    | integer_enumeration ',' primary_expression
        -: 1455:      {
    #####: 1456:        int result = ERROR_SUCCESS;
        -: 1457:
    #####: 1458:        if ($3.type != EXPRESSION_TYPE_INTEGER)
        -: 1459:        {
    #####: 1460:          yr_compiler_set_error_extra_info(
        -: 1461:              compiler, "wrong type for enumeration item");
    #####: 1462:          result = ERROR_WRONG_TYPE;
        -: 1463:        }
        -: 1464:
    #####: 1465:        fail_if_error(result);
        -: 1466:      }
        -: 1467:    ;
        -: 1468:
        -: 1469:
        -: 1470:string_set
        -: 1471:    : '('
        -: 1472:      {
        -: 1473:        // Push end-of-list marker
    #####: 1474:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 1475:      }
        -: 1476:      string_enumeration ')'
        -: 1477:    | _THEM_
        -: 1478:      {
    #####: 1479:        fail_if_error(yr_parser_emit_with_arg(
        -: 1480:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));
        -: 1481:
    #####: 1482:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 1483:            yyscanner, "$*"));
        -: 1484:      }
        -: 1485:    ;
        -: 1486:
        -: 1487:
        -: 1488:string_enumeration
        -: 1489:    : string_enumeration_item
        -: 1490:    | string_enumeration ',' string_enumeration_item
        -: 1491:    ;
        -: 1492:
        -: 1493:
        -: 1494:string_enumeration_item
        -: 1495:    : _STRING_IDENTIFIER_
        -: 1496:      {
    #####: 1497:        int result = yr_parser_emit_pushes_for_strings(yyscanner, $1);
    #####: 1498:        yr_free($1);
        -: 1499:
    #####: 1500:        fail_if_error(result);
        -: 1501:      }
        -: 1502:    | _STRING_IDENTIFIER_WITH_WILDCARD_
        -: 1503:      {
    #####: 1504:        int result = yr_parser_emit_pushes_for_strings(yyscanner, $1);
    #####: 1505:        yr_free($1);
        -: 1506:
    #####: 1507:        fail_if_error(result);
        -: 1508:      }
        -: 1509:    ;
        -: 1510:
        -: 1511:
        -: 1512:for_expression
        -: 1513:    : primary_expression
        -: 1514:    | _ALL_
        -: 1515:      {
    #####: 1516:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 1517:      }
        -: 1518:    | _ANY_
        -: 1519:      {
    #####: 1520:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 1521:      }
        -: 1522:    ;
        -: 1523:
        -: 1524:
        -: 1525:primary_expression
        -: 1526:    : '(' primary_expression ')'
        -: 1527:      {
    #####: 1528:        $$ = $2;
        -: 1529:      }
        -: 1530:    | _FILESIZE_
        -: 1531:      {
    #####: 1532:        fail_if_error(yr_parser_emit(
        -: 1533:            yyscanner, OP_FILESIZE, NULL));
        -: 1534:
    #####: 1535:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1536:        $$.value.integer = UNDEFINED;
        -: 1537:      }
        -: 1538:    | _ENTRYPOINT_
        -: 1539:      {
    #####: 1540:        yywarning(yyscanner,
        -: 1541:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 1542:            "function from PE module instead.");
        -: 1543:
    #####: 1544:        fail_if_error(yr_parser_emit(
        -: 1545:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 1546:
    #####: 1547:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1548:        $$.value.integer = UNDEFINED;
        -: 1549:      }
        -: 1550:    | _INTEGER_FUNCTION_ '(' primary_expression ')'
        -: 1551:      {
    #####: 1552:        check_type($3, EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 1553:
        -: 1554:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 1555:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 1556:        // in the proper OP_INTXX opcode.
        -: 1557:
    #####: 1558:        fail_if_error(yr_parser_emit(
        -: 1559:            yyscanner, (uint8_t) (OP_READ_INT + $1), NULL));
        -: 1560:
    #####: 1561:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1562:        $$.value.integer = UNDEFINED;
        -: 1563:      }
        -: 1564:    | _NUMBER_
        -: 1565:      {
    #####: 1566:        fail_if_error(yr_parser_emit_with_arg(
        -: 1567:            yyscanner, OP_PUSH, $1, NULL, NULL));
        -: 1568:
    #####: 1569:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1570:        $$.value.integer = $1;
        -: 1571:      }
        -: 1572:    | _DOUBLE_
        -: 1573:      {
    #####: 1574:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 1575:            yyscanner, OP_PUSH, $1, NULL, NULL));
        -: 1576:
    #####: 1577:        $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1578:      }
        -: 1579:    | _TEXT_STRING_
        -: 1580:      {
        -: 1581:        SIZED_STRING* sized_string;
        -: 1582:
    #####: 1583:        int result = yr_arena_write_data(
        -: 1584:            compiler->sz_arena,
    #####: 1585:            $1,
    #####: 1586:            $1->length + sizeof(SIZED_STRING),
        -: 1587:            (void**) &sized_string);
        -: 1588:
    #####: 1589:        yr_free($1);
        -: 1590:
    #####: 1591:        if (result == ERROR_SUCCESS)
    #####: 1592:          result = yr_parser_emit_with_arg_reloc(
        -: 1593:              yyscanner,
        -: 1594:              OP_PUSH,
        -: 1595:              sized_string,
        -: 1596:              NULL,
        -: 1597:              NULL);
        -: 1598:
    #####: 1599:        fail_if_error(result);
        -: 1600:
    #####: 1601:        $$.type = EXPRESSION_TYPE_STRING;
    #####: 1602:        $$.value.sized_string = sized_string;
        -: 1603:      }
        -: 1604:    | _STRING_COUNT_
        -: 1605:      {
    #####: 1606:        int result = yr_parser_reduce_string_identifier(
    #####: 1607:            yyscanner, $1, OP_COUNT, UNDEFINED);
        -: 1608:
    #####: 1609:        yr_free($1);
        -: 1610:
    #####: 1611:        fail_if_error(result);
        -: 1612:
    #####: 1613:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1614:        $$.value.integer = UNDEFINED;
        -: 1615:      }
        -: 1616:    | _STRING_OFFSET_ '[' primary_expression ']'
        -: 1617:      {
    #####: 1618:        int result = yr_parser_reduce_string_identifier(
    #####: 1619:            yyscanner, $1, OP_OFFSET, UNDEFINED);
        -: 1620:
    #####: 1621:        yr_free($1);
        -: 1622:
    #####: 1623:        fail_if_error(result);
        -: 1624:
    #####: 1625:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1626:        $$.value.integer = UNDEFINED;
        -: 1627:      }
        -: 1628:    | _STRING_OFFSET_
        -: 1629:      {
    #####: 1630:        int result = yr_parser_emit_with_arg(
        -: 1631:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 1632:
    #####: 1633:        if (result == ERROR_SUCCESS)
    #####: 1634:          result = yr_parser_reduce_string_identifier(
    #####: 1635:              yyscanner, $1, OP_OFFSET, UNDEFINED);
        -: 1636:
    #####: 1637:        yr_free($1);
        -: 1638:
    #####: 1639:        fail_if_error(result);
        -: 1640:
    #####: 1641:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1642:        $$.value.integer = UNDEFINED;
        -: 1643:      }
        -: 1644:    | _STRING_LENGTH_ '[' primary_expression ']'
        -: 1645:      {
    #####: 1646:        int result = yr_parser_reduce_string_identifier(
    #####: 1647:            yyscanner, $1, OP_LENGTH, UNDEFINED);
        -: 1648:
    #####: 1649:        yr_free($1);
        -: 1650:
    #####: 1651:        fail_if_error(result);
        -: 1652:
    #####: 1653:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1654:        $$.value.integer = UNDEFINED;
        -: 1655:      }
        -: 1656:    | _STRING_LENGTH_
        -: 1657:      {
    #####: 1658:        int result = yr_parser_emit_with_arg(
        -: 1659:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 1660:
    #####: 1661:        if (result == ERROR_SUCCESS)
    #####: 1662:          result = yr_parser_reduce_string_identifier(
    #####: 1663:              yyscanner, $1, OP_LENGTH, UNDEFINED);
        -: 1664:
    #####: 1665:        yr_free($1);
        -: 1666:
    #####: 1667:        fail_if_error(result);
        -: 1668:
    #####: 1669:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1670:        $$.value.integer = UNDEFINED;
        -: 1671:      }
        -: 1672:    | identifier
        -: 1673:      {
    #####: 1674:        int result = ERROR_SUCCESS;
        -: 1675:
    #####: 1676:        if ($1.type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        -: 1677:        {
    #####: 1678:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1679:          $$.value.integer = UNDEFINED;
        -: 1680:        }
    #####: 1681:        else if ($1.type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        -: 1682:        {
    #####: 1683:          $$.type = EXPRESSION_TYPE_BOOLEAN;
    #####: 1684:          $$.value.integer = UNDEFINED;
        -: 1685:        }
    #####: 1686:        else if ($1.type == EXPRESSION_TYPE_OBJECT)
        -: 1687:        {
    #####: 1688:          result = yr_parser_emit(
        -: 1689:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 1690:
    #####: 1691:          switch($1.value.object->type)
        -: 1692:          {
    #####: 1693:            case OBJECT_TYPE_INTEGER:
    #####: 1694:              $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1695:              $$.value.integer = UNDEFINED;
    #####: 1696:              break;
    #####: 1697:            case OBJECT_TYPE_FLOAT:
    #####: 1698:              $$.type = EXPRESSION_TYPE_FLOAT;
    #####: 1699:              break;
    #####: 1700:            case OBJECT_TYPE_STRING:
    #####: 1701:              $$.type = EXPRESSION_TYPE_STRING;
    #####: 1702:              $$.value.sized_string = NULL;
    #####: 1703:              break;
    #####: 1704:            default:
    #####: 1705:              yr_compiler_set_error_extra_info_fmt(
        -: 1706:                  compiler,
        -: 1707:                  "wrong usage of identifier \"%s\"",
        -: 1708:                  $1.identifier);
    #####: 1709:              result = ERROR_WRONG_TYPE;
        -: 1710:          }
        -: 1711:        }
        -: 1712:        else
        -: 1713:        {
    #####: 1714:          assert(false);
        -: 1715:        }
        -: 1716:
    #####: 1717:        fail_if_error(result);
        -: 1718:      }
        -: 1719:    | '-' primary_expression %prec UNARY_MINUS
        -: 1720:      {
    #####: 1721:        int result = ERROR_SUCCESS;
        -: 1722:
    #####: 1723:        check_type($2, EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 1724:
    #####: 1725:        if ($2.type == EXPRESSION_TYPE_INTEGER)
        -: 1726:        {
    #####: 1727:          $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1728:          $$.value.integer = ($2.value.integer == UNDEFINED) ?
    #####: 1729:              UNDEFINED : -($2.value.integer);
    #####: 1730:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 1731:        }
    #####: 1732:        else if ($2.type == EXPRESSION_TYPE_FLOAT)
        -: 1733:        {
    #####: 1734:          $$.type = EXPRESSION_TYPE_FLOAT;
    #####: 1735:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 1736:        }
        -: 1737:
    #####: 1738:        fail_if_error(result);
        -: 1739:      }
        -: 1740:    | primary_expression '+' primary_expression
        -: 1741:      {
    #####: 1742:        int result = yr_parser_reduce_operation(
    #####: 1743:            yyscanner, "+", $1, $3);
        -: 1744:
    #####: 1745:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1746:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 1747:        {
    #####: 1748:          int64_t i1 = $1.value.integer;
    #####: 1749:          int64_t i2 = $3.value.integer;
        -: 1750:
    #####: 1751:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 1752:              (
    #####: 1753:                (i2 > 0 && i1 > INT64_MAX - i2) ||
    #####: 1754:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 1755:              ))
        -: 1756:          {
    #####: 1757:            yr_compiler_set_error_extra_info_fmt(
        -: 1758:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 1759:
    #####: 1760:            result = ERROR_INTEGER_OVERFLOW;
        -: 1761:          }
        -: 1762:          else
        -: 1763:          {
    #####: 1764:            $$.value.integer = OPERATION(+, i1, i2);
    #####: 1765:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1766:          }
        -: 1767:        }
        -: 1768:        else
        -: 1769:        {
    #####: 1770:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1771:        }
        -: 1772:
    #####: 1773:        fail_if_error(result);
        -: 1774:      }
        -: 1775:    | primary_expression '-' primary_expression
        -: 1776:      {
    #####: 1777:        int result = yr_parser_reduce_operation(
    #####: 1778:            yyscanner, "-", $1, $3);
        -: 1779:
    #####: 1780:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1781:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 1782:        {
    #####: 1783:          int64_t i1 = $1.value.integer;
    #####: 1784:          int64_t i2 = $3.value.integer;
        -: 1785:
    #####: 1786:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 1787:              (
    #####: 1788:                (i2 < 0 && i1 > INT64_MAX + i2) ||
    #####: 1789:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 1790:              ))
        -: 1791:          {
    #####: 1792:            yr_compiler_set_error_extra_info_fmt(
        -: 1793:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 1794:
    #####: 1795:            result = ERROR_INTEGER_OVERFLOW;
        -: 1796:          }
        -: 1797:          else
        -: 1798:          {
    #####: 1799:            $$.value.integer = OPERATION(-, i1, i2);
    #####: 1800:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1801:          }
        -: 1802:        }
        -: 1803:        else
        -: 1804:        {
    #####: 1805:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1806:        }
        -: 1807:
    #####: 1808:        fail_if_error(result);
        -: 1809:      }
        -: 1810:    | primary_expression '*' primary_expression
        -: 1811:      {
    #####: 1812:        int result = yr_parser_reduce_operation(
    #####: 1813:            yyscanner, "*", $1, $3);
        -: 1814:
    #####: 1815:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1816:            $3.type == EXPRESSION_TYPE_INTEGER)
    #####: 1817:        {
    #####: 1818:          int64_t i1 = $1.value.integer;
    #####: 1819:          int64_t i2 = $3.value.integer;
        -: 1820:
    #####: 1821:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 1822:              (
    #####: 1823:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 1824:              ))
        -: 1825:          {
    #####: 1826:            yr_compiler_set_error_extra_info_fmt(
        -: 1827:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 1828:
    #####: 1829:            result = ERROR_INTEGER_OVERFLOW;
        -: 1830:          }
        -: 1831:          else
        -: 1832:          {
    #####: 1833:            $$.value.integer = OPERATION(*, i1, i2);
    #####: 1834:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1835:          }
        -: 1836:        }
        -: 1837:        else
        -: 1838:        {
    #####: 1839:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1840:        }
        -: 1841:
    #####: 1842:        fail_if_error(result);
        -: 1843:      }
        -: 1844:    | primary_expression '\\' primary_expression
        -: 1845:      {
    #####: 1846:        int result = yr_parser_reduce_operation(
    #####: 1847:            yyscanner, "\\", $1, $3);
        -: 1848:
    #####: 1849:        if ($1.type == EXPRESSION_TYPE_INTEGER &&
    #####: 1850:            $3.type == EXPRESSION_TYPE_INTEGER)
        -: 1851:        {
    #####: 1852:          if ($3.value.integer != 0)
        -: 1853:          {
    #####: 1854:            $$.value.integer = OPERATION(/, $1.value.integer, $3.value.integer);
    #####: 1855:            $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1856:          }
        -: 1857:          else
        -: 1858:          {
    #####: 1859:            result = ERROR_DIVISION_BY_ZERO;
        -: 1860:          }
        -: 1861:        }
        -: 1862:        else
        -: 1863:        {
    #####: 1864:          $$.type = EXPRESSION_TYPE_FLOAT;
        -: 1865:        }
        -: 1866:
    #####: 1867:        fail_if_error(result);
        -: 1868:      }
        -: 1869:    | primary_expression '%' primary_expression
        -: 1870:      {
    #####: 1871:        check_type($1, EXPRESSION_TYPE_INTEGER, "%");
    #####: 1872:        check_type($3, EXPRESSION_TYPE_INTEGER, "%");
        -: 1873:
    #####: 1874:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 1875:
    #####: 1876:        if ($3.value.integer != 0)
        -: 1877:        {
    #####: 1878:          $$.value.integer = OPERATION(%, $1.value.integer, $3.value.integer);
    #####: 1879:          $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1880:        }
        -: 1881:        else
        -: 1882:        {
    #####: 1883:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 1884:        }
        -: 1885:      }
        -: 1886:    | primary_expression '^' primary_expression
        -: 1887:      {
    #####: 1888:        check_type($1, EXPRESSION_TYPE_INTEGER, "^");
    #####: 1889:        check_type($3, EXPRESSION_TYPE_INTEGER, "^");
        -: 1890:
    #####: 1891:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 1892:
    #####: 1893:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1894:        $$.value.integer = OPERATION(^, $1.value.integer, $3.value.integer);
        -: 1895:      }
        -: 1896:    | primary_expression '&' primary_expression
        -: 1897:      {
    #####: 1898:        check_type($1, EXPRESSION_TYPE_INTEGER, "^");
    #####: 1899:        check_type($3, EXPRESSION_TYPE_INTEGER, "^");
        -: 1900:
    #####: 1901:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 1902:
    #####: 1903:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1904:        $$.value.integer = OPERATION(&, $1.value.integer, $3.value.integer);
        -: 1905:      }
        -: 1906:    | primary_expression '|' primary_expression
        -: 1907:      {
    #####: 1908:        check_type($1, EXPRESSION_TYPE_INTEGER, "|");
    #####: 1909:        check_type($3, EXPRESSION_TYPE_INTEGER, "|");
        -: 1910:
    #####: 1911:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 1912:
    #####: 1913:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1914:        $$.value.integer = OPERATION(|, $1.value.integer, $3.value.integer);
        -: 1915:      }
        -: 1916:    | '~' primary_expression
        -: 1917:      {
    #####: 1918:        check_type($2, EXPRESSION_TYPE_INTEGER, "~");
        -: 1919:
    #####: 1920:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 1921:
    #####: 1922:        $$.type = EXPRESSION_TYPE_INTEGER;
    #####: 1923:        $$.value.integer = ($2.value.integer == UNDEFINED) ?
    #####: 1924:            UNDEFINED : ~($2.value.integer);
        -: 1925:      }
        -: 1926:    | primary_expression _SHIFT_LEFT_ primary_expression
        -: 1927:      {
    #####: 1928:        check_type($1, EXPRESSION_TYPE_INTEGER, "<<");
    #####: 1929:        check_type($3, EXPRESSION_TYPE_INTEGER, "<<");
        -: 1930:
    #####: 1931:        int result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 1932:
    #####: 1933:        if (!IS_UNDEFINED($3.value.integer) && $3.value.integer < 0)
    #####: 1934:          result = ERROR_INVALID_OPERAND;
    #####: 1935:        else if (!IS_UNDEFINED($3.value.integer) && $3.value.integer >= 64)
    #####: 1936:          $$.value.integer = 0;
        -: 1937:        else
    #####: 1938:          $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);
        -: 1939:
    #####: 1940:        $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1941:
    #####: 1942:        fail_if_error(result);
        -: 1943:      }
        -: 1944:    | primary_expression _SHIFT_RIGHT_ primary_expression
        -: 1945:      {
    #####: 1946:        check_type($1, EXPRESSION_TYPE_INTEGER, ">>");
    #####: 1947:        check_type($3, EXPRESSION_TYPE_INTEGER, ">>");
        -: 1948:
    #####: 1949:        int result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 1950:
    #####: 1951:        if (!IS_UNDEFINED($3.value.integer) && $3.value.integer < 0)
    #####: 1952:          result = ERROR_INVALID_OPERAND;
    #####: 1953:        else if (!IS_UNDEFINED($3.value.integer) && $3.value.integer >= 64)
    #####: 1954:          $$.value.integer = 0;
        -: 1955:        else
    #####: 1956:          $$.value.integer = OPERATION(<<, $1.value.integer, $3.value.integer);
        -: 1957:
    #####: 1958:        $$.type = EXPRESSION_TYPE_INTEGER;
        -: 1959:
    #####: 1960:        fail_if_error(result);
        -: 1961:      }
        -: 1962:    | regexp
        -: 1963:      {
    #####: 1964:        $$ = $1;
        -: 1965:      }
        -: 1966:    ;
        -: 1967:
        -: 1968:%%
