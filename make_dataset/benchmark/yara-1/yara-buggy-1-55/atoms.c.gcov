        -:    0:Source:atoms.c
        -:    0:Graph:/home/workspace/libyara/atoms.gcno
        -:    0:Data:/home/workspace/libyara/atoms.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013-2018. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/*
        -:   31:
        -:   32:This module handles atom extraction from regexps and hex strings. Atoms are
        -:   33:undivided substrings found in a regexps and hex strings. Let's consider this
        -:   34:hex string:
        -:   35:
        -:   36:{ 01 02 03 04 05 ?? 06 07 08 [1-2] 09 0A }
        -:   37:
        -:   38:In the above string, byte sequences 0102030405, 060708 and 090A are atoms.
        -:   39:Similarly, in this regexp:
        -:   40:
        -:   41:/abc.*ed[0-9]+fgh/
        -:   42:
        -:   43:The strings "abc", "ed" and "fgh" are atoms.
        -:   44:
        -:   45:When searching for regexps/hex strings matching a file, YARA uses these
        -:   46:atoms to find locations inside the file where the regexp/hex string could
        -:   47:match. If the atom "abc" is found somewhere inside the file, there is a chance
        -:   48:for /abc.*ed[0-9]+fgh/ to match the file, if "abc" doesn't appear in the file
        -:   49:there's no chance for the regexp to match. When the atom is found in the file
        -:   50:YARA proceeds to fully evaluate the regexp/hex string to determine if it's
        -:   51:actually a match.
        -:   52:
        -:   53:For each regexp/hex string YARA extracts one or more atoms. Sometimes a
        -:   54:single atom is enough (like in the previous example "abc" is enough for finding
        -:   55:/abc.*ed[0-9]+fgh/), but sometimes a single atom isn't enough like in the
        -:   56:regexp /(abc|efg)/. In this case YARA must search for both "abc" AND "efg" and
        -:   57:fully evaluate the regexp whenever one of these atoms is found.
        -:   58:
        -:   59:In the regexp /Look(at|into)this/ YARA can search for "Look", or search for
        -:   60:"this", or search for both "at" and "into". This is what we call an atoms tree,
        -:   61:because it can be represented by the following tree structure:
        -:   62:
        -:   63:-OR
        -:   64:  |- "Look"
        -:   65:  |
        -:   66:  |- AND
        -:   67:  |   |
        -:   68:  |   |- "at"
        -:   69:  |    - "into"
        -:   70:  |
        -:   71:   - "this"
        -:   72:
        -:   73:From an atom tree YARA chooses the best combination, trying to minimize the
        -:   74:number of required atoms, but also using high quality atoms (long atoms with
        -:   75:not too many zeroes and a bit of byte diversity). In the previous example YARA
        -:   76:will end up using the "Look" atom alone, but in /a(bcd|efg)h/ atoms "bcd" and
        -:   77:"efg" will be used because "a" and "h" are too short.
        -:   78:
        -:   79:*/
        -:   80:
        -:   81:#include <assert.h>
        -:   82:#include <stdbool.h>
        -:   83:#include <string.h>
        -:   84:
        -:   85:#include <yara/utils.h>
        -:   86:#include <yara/atoms.h>
        -:   87:#include <yara/limits.h>
        -:   88:#include <yara/mem.h>
        -:   89:#include <yara/error.h>
        -:   90:#include <yara/types.h>
        -:   91:
        -:   92:
        -:   93:#define append_current_leaf_to_node(node) \
        -:   94:    if (atom_tree->current_leaf != NULL) \
        -:   95:    { \
        -:   96:      _yr_atoms_tree_node_append(node, atom_tree->current_leaf); \
        -:   97:      atom_tree->current_leaf = NULL; \
        -:   98:    } \
        -:   99:
        -:  100:
        -:  101://
        -:  102:// yr_atoms_heuristic_quality
        -:  103://
        -:  104:// Returns a numeric value indicating the quality of an atom. The quality
        -:  105:// depends on some characteristics of the atom, including its length, number
        -:  106:// of very common bytes like 00 and FF and number of unique distinct bytes.
        -:  107:// Atom 00 00 has a very low quality, because it's only two bytes long and
        -:  108:// both bytes are zeroes. Atom 01 01 01 01 is better but still not optimal,
        -:  109:// because the same byte is repeated. Atom 01 02 03 04 is an optimal one.
        -:  110://
        -:  111:// Args:
        -:  112://    YR_ATOMS_CONFIG* config   - Pointer to YR_ATOMS_CONFIG struct.
        -:  113://    uint8_t* atom             - Pointer to the atom's bytes.
        -:  114://    int atom_length           - Atom's length.
        -:  115://
        -:  116:// Returns:
        -:  117://    An integer indicating the atom's quality
        -:  118://
        -:  119:
    #####:  120:int yr_atoms_heuristic_quality(
        -:  121:    YR_ATOMS_CONFIG* config,
        -:  122:    uint8_t* atom,
        -:  123:    int atom_length)
        -:  124:{
    #####:  125:  int penalty = 0;
    #####:  126:  int unique_bytes = 0;
        -:  127:  int i, j;
        -:  128:  bool is_unique;
        -:  129:
    #####:  130:  for (i = 0; i < atom_length; i++)
        -:  131:  {
    #####:  132:    if (atom[i] == 0x00 || atom[i] == 0xFF || atom[i] == 0x20 ||
    #####:  133:        atom[i] == 0x0A || atom[i] == 0x0D)
        -:  134:    {
        -:  135:      // Penalize common bytes, specially if they are in the first two positions.
        -:  136:
    #####:  137:      switch(i)
        -:  138:      {
    #####:  139:        case 0:
    #####:  140:          penalty += 3;
    #####:  141:          break;
    #####:  142:        case 1:
    #####:  143:          penalty += 2;
    #####:  144:          break;
    #####:  145:        default:
    #####:  146:          penalty += 1;
    #####:  147:          break;
        -:  148:      }
    #####:  149:    }
        -:  150:
    #####:  151:    is_unique = true;
        -:  152:
    #####:  153:    for (j = i + 1; j < atom_length; j++)
    #####:  154:      if (atom[i] == atom[j])
        -:  155:      {
    #####:  156:        is_unique = false;
    #####:  157:        break;
        -:  158:      }
        -:  159:
    #####:  160:    if (is_unique)
    #####:  161:      unique_bytes += 1;
        -:  162:  }
        -:  163:
        -:  164:  // (atom_length + unique_bytes - penalty + 2) is within the range
        -:  165:  // [0 - 2 * YR_MAX_ATOM_LENGTH], which means that the function returns a value
        -:  166:  // in [YR_MAX_ATOM_QUALITY - 2 * YR_MAX_ATOM_LENGTH, YR_MAX_ATOM_QUALITY]
        -:  167:
    #####:  168:  return YR_MAX_ATOM_QUALITY - 2 * YR_MAX_ATOM_LENGTH +
    #####:  169:          (atom_length + unique_bytes - penalty + 2);
        -:  170:}
        -:  171:
        -:  172://
        -:  173:// yr_atoms_table_quality
        -:  174://
        -:  175:// Returns a numeric value indicating the quality of an atom. The quality is
        -:  176:// based in the atom quality table passed in "config". Very common atoms
        -:  177:// (i.e: those with greater quality) have lower quality than those that are
        -:  178:// uncommon. See the comment for yr_compiler_set_atom_quality_table for
        -:  179:// details about the quality table's format.
        -:  180://
        -:  181:// Args:
        -:  182://    YR_ATOMS_CONFIG* config   - Pointer to YR_ATOMS_CONFIG struct.
        -:  183://    uint8_t* atom             - Pointer to the atom's bytes.
        -:  184://    int atom_length           - Atom's length.
        -:  185://
        -:  186:// Returns:
        -:  187://    An integer indicating the atom's quality
        -:  188://
        -:  189:
    #####:  190:int yr_atoms_table_quality(
        -:  191:    YR_ATOMS_CONFIG* config,
        -:  192:    uint8_t* atom,
        -:  193:    int atom_length)
        -:  194:{
    #####:  195:  YR_ATOM_QUALITY_TABLE_ENTRY* table = config->quality_table;
        -:  196:
    #####:  197:  int begin = 0;
    #####:  198:  int end = config->quality_table_entries;
        -:  199:
    #####:  200:  while (end > begin)
        -:  201:  {
    #####:  202:    int middle = begin + (end - begin) / 2;
    #####:  203:    int c = memcmp(table[middle].atom, atom, atom_length);
        -:  204:
    #####:  205:    if (c < 0)
        -:  206:    {
    #####:  207:      begin = middle + 1;
        -:  208:    }
    #####:  209:    else if (c > 0)
        -:  210:    {
    #####:  211:      end = middle;
        -:  212:    }
        -:  213:    else
        -:  214:    {
    #####:  215:      if (atom_length == YR_MAX_ATOM_LENGTH)
    #####:  216:        return table[middle].quality;
        -:  217:
    #####:  218:      int i = middle + 1;
    #####:  219:      int quality = table[middle].quality;
    #####:  220:      int min_quality = quality;
        -:  221:
    #####:  222:      while (i < end && memcmp(table[i].atom, atom, atom_length) == 0)
        -:  223:      {
    #####:  224:        if (min_quality > table[i].quality)
    #####:  225:          min_quality = table[i].quality;
        -:  226:
    #####:  227:        i++;
        -:  228:      }
        -:  229:
    #####:  230:      i = middle - 1;
        -:  231:
    #####:  232:      while (i >= begin && memcmp(table[i].atom, atom, atom_length) == 0)
        -:  233:      {
    #####:  234:        if (min_quality > table[i].quality)
    #####:  235:          min_quality = table[i].quality;
        -:  236:
    #####:  237:        i--;
        -:  238:      }
        -:  239:
    #####:  240:      return min_quality >> (YR_MAX_ATOM_LENGTH - atom_length);
        -:  241:    }
        -:  242:  }
        -:  243:
    #####:  244:  return YR_MAX_ATOM_QUALITY;
        -:  245:}
        -:  246:
        -:  247:
        -:  248://
        -:  249:// yr_atoms_min_quality
        -:  250://
        -:  251:// Returns the quality for the worst quality atom in a list.
        -:  252://
        -:  253:
    #####:  254:int yr_atoms_min_quality(
        -:  255:    YR_ATOMS_CONFIG* config,
        -:  256:    YR_ATOM_LIST_ITEM* atom_list)
        -:  257:{
        -:  258:  YR_ATOM_LIST_ITEM* atom;
        -:  259:
        -:  260:  int quality;
    #####:  261:  int min_quality = YR_MAX_ATOM_QUALITY;
        -:  262:
    #####:  263:  if (atom_list == NULL)
    #####:  264:    return YR_MIN_ATOM_QUALITY;
        -:  265:
    #####:  266:  atom = atom_list;
        -:  267:
    #####:  268:  while (atom != NULL)
        -:  269:  {
    #####:  270:    quality = config->get_atom_quality(config, atom->atom, atom->atom_length);
        -:  271:
    #####:  272:    if (quality < min_quality)
    #####:  273:      min_quality = quality;
        -:  274:
    #####:  275:    atom = atom->next;
        -:  276:  }
        -:  277:
    #####:  278:  return min_quality;
        -:  279:}
        -:  280:
        -:  281:
        -:  282://
        -:  283:// _yr_atoms_tree_node_create
        -:  284://
        -:  285:// Creates a new node for an atoms tree.
        -:  286://
        -:  287:
    #####:  288:static ATOM_TREE_NODE* _yr_atoms_tree_node_create(
        -:  289:    uint8_t type)
        -:  290:{
        -:  291:  ATOM_TREE_NODE* new_node = (ATOM_TREE_NODE*) \
    #####:  292:      yr_malloc(sizeof(ATOM_TREE_NODE));
        -:  293:
    #####:  294:  if (new_node != NULL)
        -:  295:  {
    #####:  296:    new_node->type = type;
    #####:  297:    new_node->atom_length = 0;
    #####:  298:    new_node->next_sibling = NULL;
    #####:  299:    new_node->children_head = NULL;
    #####:  300:    new_node->children_tail = NULL;
    #####:  301:    new_node->forward_code = NULL;
    #####:  302:    new_node->backward_code = NULL;
        -:  303:  }
        -:  304:
    #####:  305:  return new_node;
        -:  306:}
        -:  307:
        -:  308:
        -:  309://
        -:  310:// _yr_atoms_tree_node_destroy
        -:  311://
        -:  312:// Destroys a node from an atoms tree.
        -:  313://
        -:  314:
    #####:  315:static void _yr_atoms_tree_node_destroy(
        -:  316:    ATOM_TREE_NODE* node)
        -:  317:{
        -:  318:  ATOM_TREE_NODE* child;
        -:  319:  ATOM_TREE_NODE* next_child;
        -:  320:
    #####:  321:  if (node == NULL)
    #####:  322:    return;
        -:  323:
    #####:  324:  if (node->type == ATOM_TREE_OR || node->type == ATOM_TREE_AND)
        -:  325:  {
    #####:  326:    child = node->children_head;
        -:  327:
    #####:  328:    while (child != NULL)
        -:  329:    {
    #####:  330:      next_child = child->next_sibling;
    #####:  331:      _yr_atoms_tree_node_destroy(child);
    #####:  332:      child = next_child;
        -:  333:    }
        -:  334:  }
        -:  335:
    #####:  336:  yr_free(node);
        -:  337:}
        -:  338:
        -:  339:
        -:  340://
        -:  341:// _yr_atoms_tree_node_append
        -:  342://
        -:  343:// Appends a new child node to another atoms tree node.
        -:  344://
        -:  345:
    #####:  346:static void _yr_atoms_tree_node_append(
        -:  347:    ATOM_TREE_NODE* dest,
        -:  348:    ATOM_TREE_NODE* node)
        -:  349:{
    #####:  350:  if (dest->children_head == NULL)
    #####:  351:    dest->children_head = node;
        -:  352:
    #####:  353:  if (dest->children_tail != NULL)
    #####:  354:    dest->children_tail->next_sibling = node;
        -:  355:
    #####:  356:  dest->children_tail = node;
    #####:  357:}
        -:  358:
        -:  359:
        -:  360://
        -:  361:// _yr_atoms_tree_destroy
        -:  362://
        -:  363:// Destroys an atoms tree.
        -:  364://
        -:  365:
    #####:  366:static void _yr_atoms_tree_destroy(
        -:  367:    ATOM_TREE* atom_tree)
        -:  368:{
    #####:  369:  _yr_atoms_tree_node_destroy(atom_tree->root_node);
    #####:  370:  yr_free(atom_tree);
    #####:  371:}
        -:  372:
        -:  373:
        -:  374://
        -:  375:// yr_atoms_list_destroy
        -:  376://
        -:  377:// Destroys an atoms list.
        -:  378://
        -:  379:
    #####:  380:void yr_atoms_list_destroy(
        -:  381:    YR_ATOM_LIST_ITEM* list_head)
        -:  382:{
    #####:  383:  YR_ATOM_LIST_ITEM* item = list_head;
        -:  384:  YR_ATOM_LIST_ITEM* next;
        -:  385:
    #####:  386:  while (item != NULL)
        -:  387:  {
    #####:  388:    next = item->next;
    #####:  389:    yr_free(item);
    #####:  390:    item = next;
        -:  391:  }
    #####:  392:}
        -:  393:
        -:  394:
        -:  395://
        -:  396:// yr_atoms_list_destroy
        -:  397://
        -:  398:// Concats two atoms lists.
        -:  399://
        -:  400:
    #####:  401:static YR_ATOM_LIST_ITEM* _yr_atoms_list_concat(
        -:  402:    YR_ATOM_LIST_ITEM* list1,
        -:  403:    YR_ATOM_LIST_ITEM* list2)
        -:  404:{
        -:  405:  YR_ATOM_LIST_ITEM* item;
        -:  406:
    #####:  407:  if (list1 == NULL)
    #####:  408:    return list2;
        -:  409:
    #####:  410:  item = list1;
        -:  411:
    #####:  412:  while (item->next != NULL)
        -:  413:  {
    #####:  414:    item = item->next;
        -:  415:  }
        -:  416:
    #####:  417:  item->next = list2;
    #####:  418:  return list1;
        -:  419:}
        -:  420:
        -:  421:
        -:  422://
        -:  423:// _yr_atoms_choose
        -:  424://
        -:  425:// Chooses which atoms from an atoms tree will be used to feed the
        -:  426:// Aho-Corasick automaton, and puts them in a list.
        -:  427://
        -:  428:
    #####:  429:static int _yr_atoms_choose(
        -:  430:    YR_ATOMS_CONFIG* config,
        -:  431:    ATOM_TREE_NODE* node,
        -:  432:    YR_ATOM_LIST_ITEM** chosen_atoms,
        -:  433:    int* atoms_quality)
        -:  434:{
        -:  435:  ATOM_TREE_NODE* child;
        -:  436:  YR_ATOM_LIST_ITEM* item;
        -:  437:  YR_ATOM_LIST_ITEM* tail;
        -:  438:
        -:  439:  int i, quality;
    #####:  440:  int max_quality = YR_MIN_ATOM_QUALITY;
    #####:  441:  int min_quality = YR_MAX_ATOM_QUALITY;
        -:  442:
    #####:  443:  *chosen_atoms = NULL;
        -:  444:
    #####:  445:  switch (node->type)
        -:  446:  {
    #####:  447:  case ATOM_TREE_LEAF:
        -:  448:
    #####:  449:    item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -:  450:
    #####:  451:    if (item == NULL)
    #####:  452:      return ERROR_INSUFFICIENT_MEMORY;
        -:  453:
    #####:  454:    for (i = 0; i < node->atom_length; i++)
    #####:  455:      item->atom[i] = node->atom[i];
        -:  456:
    #####:  457:    item->atom_length = node->atom_length;
    #####:  458:    item->forward_code = node->forward_code;
    #####:  459:    item->backward_code = node->backward_code;
    #####:  460:    item->backtrack = 0;
    #####:  461:    item->next = NULL;
        -:  462:
    #####:  463:    *chosen_atoms = item;
    #####:  464:    *atoms_quality = config->get_atom_quality(
    #####:  465:        config, node->atom, node->atom_length);
    #####:  466:    break;
        -:  467:
    #####:  468:  case ATOM_TREE_OR:
        -:  469:
    #####:  470:    child = node->children_head;
        -:  471:
    #####:  472:    while (child != NULL)
        -:  473:    {
    #####:  474:      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));
        -:  475:
    #####:  476:      if (quality > max_quality)
        -:  477:      {
    #####:  478:        max_quality = quality;
    #####:  479:        yr_atoms_list_destroy(*chosen_atoms);
    #####:  480:        *chosen_atoms = item;
        -:  481:      }
        -:  482:      else
        -:  483:      {
    #####:  484:        yr_atoms_list_destroy(item);
        -:  485:      }
        -:  486:
    #####:  487:      if (max_quality == YR_MAX_ATOM_QUALITY)
    #####:  488:        break;
        -:  489:
    #####:  490:      child = child->next_sibling;
        -:  491:    }
        -:  492:
    #####:  493:    *atoms_quality = max_quality;
    #####:  494:    break;
        -:  495:
    #####:  496:  case ATOM_TREE_AND:
        -:  497:
    #####:  498:    child = node->children_head;
        -:  499:
    #####:  500:    while (child != NULL)
        -:  501:    {
    #####:  502:      FAIL_ON_ERROR(_yr_atoms_choose(config, child, &item, &quality));
        -:  503:
    #####:  504:      if (quality < min_quality)
    #####:  505:        min_quality = quality;
        -:  506:
    #####:  507:      if (item != NULL)
        -:  508:      {
    #####:  509:        tail = item;
    #####:  510:        while (tail->next != NULL)
    #####:  511:          tail = tail->next;
        -:  512:
    #####:  513:        tail->next = *chosen_atoms;
    #####:  514:        *chosen_atoms = item;
        -:  515:      }
        -:  516:
    #####:  517:      child = child->next_sibling;
        -:  518:    }
        -:  519:
    #####:  520:    *atoms_quality = min_quality;
    #####:  521:    break;
        -:  522:  }
        -:  523:
    #####:  524:  return ERROR_SUCCESS;
        -:  525:}
        -:  526:
        -:  527:
        -:  528://
        -:  529:// _yr_atoms_case_combinations
        -:  530://
        -:  531:// Returns all combinations of lower and upper cases for a given atom. For
        -:  532:// atom "abc" the output would be "abc" "abC" "aBC" and so on. Resulting
        -:  533:// atoms are written into the output buffer in this format:
        -:  534://
        -:  535://  [size of atom 1] [atom 1]  ... [size of atom N] [atom N] [0]
        -:  536://
        -:  537:// Notice the zero at the end to indicate where the output ends.
        -:  538://
        -:  539:// The caller is responsible of providing a buffer large enough to hold the
        -:  540:// returned atoms.
        -:  541://
        -:  542:
    #####:  543:static uint8_t* _yr_atoms_case_combinations(
        -:  544:    uint8_t* atom,
        -:  545:    int atom_length,
        -:  546:    int atom_offset,
        -:  547:    uint8_t* output_buffer)
        -:  548:{
        -:  549:  uint8_t c;
        -:  550:  uint8_t* new_atom;
        -:  551:
    #####:  552:  if (atom_offset + 1 < atom_length)
    #####:  553:    output_buffer = _yr_atoms_case_combinations(
        -:  554:        atom,
        -:  555:        atom_length,
        -:  556:        atom_offset + 1,
        -:  557:        output_buffer);
        -:  558:
    #####:  559:  c = atom[atom_offset];
        -:  560:
    #####:  561:  if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
        -:  562:  {
        -:  563:    // Write atom length.
    #####:  564:    *output_buffer = atom_length;
    #####:  565:    output_buffer++;
        -:  566:
    #####:  567:    memcpy(output_buffer, atom, atom_length);
        -:  568:
    #####:  569:    new_atom = output_buffer;
    #####:  570:    output_buffer += atom_length;
        -:  571:
        -:  572:    // Swap character case.
    #####:  573:    if (c >= 'a' && c <= 'z')
    #####:  574:      new_atom[atom_offset] -= 32;
        -:  575:    else
    #####:  576:      new_atom[atom_offset] += 32;
        -:  577:
    #####:  578:    if (atom_offset + 1 < atom_length)
    #####:  579:      output_buffer = _yr_atoms_case_combinations(
        -:  580:          new_atom,
        -:  581:          atom_length,
        -:  582:          atom_offset + 1,
        -:  583:          output_buffer);
        -:  584:  }
        -:  585:
    #####:  586:  if (atom_offset == 0)
    #####:  587:    *output_buffer = 0;
        -:  588:
    #####:  589:  return output_buffer;
        -:  590:}
        -:  591:
        -:  592:// Size of buffer used in _yr_atoms_case_insensitive for storing the all
        -:  593:// the possible combinations for an atom. Each atom has up to YR_MAX_ATOM_LENGTH
        -:  594:// characters and each character has two possible values (upper and lower case).
        -:  595:// That means 2 ^ YR_MAX_ATOM_LENGTH combinations for an atom, where each atom
        -:  596:// occupies YR_MAX_ATOM_LENGTH + 1 bytes (the atom itself +1 byte for its length)
        -:  597:// One extra bytes is allocated for the zero value indicating the end.
        -:  598:
        -:  599:#define CASE_COMBINATIONS_BUFFER_SIZE \
        -:  600:    (1 << YR_MAX_ATOM_LENGTH) * (YR_MAX_ATOM_LENGTH + 1) + 1
        -:  601:
        -:  602://
        -:  603:// _yr_atoms_case_insensitive
        -:  604://
        -:  605:// For a given list of atoms returns another list of atoms
        -:  606:// with every case combination.
        -:  607://
        -:  608:
    #####:  609:static int _yr_atoms_case_insensitive(
        -:  610:    YR_ATOM_LIST_ITEM* atoms,
        -:  611:    YR_ATOM_LIST_ITEM** case_insensitive_atoms)
        -:  612:{
        -:  613:  YR_ATOM_LIST_ITEM* atom;
        -:  614:  YR_ATOM_LIST_ITEM* new_atom;
        -:  615:
        -:  616:  uint8_t buffer[CASE_COMBINATIONS_BUFFER_SIZE];
        -:  617:  uint8_t atom_length;
        -:  618:  uint8_t* atoms_cursor;
        -:  619:
        -:  620:  int i;
        -:  621:
    #####:  622:  *case_insensitive_atoms = NULL;
    #####:  623:  atom = atoms;
        -:  624:
    #####:  625:  while (atom != NULL)
        -:  626:  {
    #####:  627:    _yr_atoms_case_combinations(
    #####:  628:        atom->atom,
    #####:  629:        atom->atom_length,
        -:  630:        0,
        -:  631:        buffer);
        -:  632:
    #####:  633:    atoms_cursor = buffer;
    #####:  634:    atom_length = *atoms_cursor;
    #####:  635:    atoms_cursor++;
        -:  636:
    #####:  637:    while (atom_length != 0)
        -:  638:    {
    #####:  639:      new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -:  640:
    #####:  641:      if (new_atom == NULL)
    #####:  642:        return ERROR_INSUFFICIENT_MEMORY;
        -:  643:
    #####:  644:      for (i = 0; i < atom_length; i++)
    #####:  645:        new_atom->atom[i] = atoms_cursor[i];
        -:  646:
    #####:  647:      new_atom->atom_length = atom_length;
    #####:  648:      new_atom->forward_code = atom->forward_code;
    #####:  649:      new_atom->backward_code = atom->backward_code;
    #####:  650:      new_atom->backtrack = atom->backtrack;
    #####:  651:      new_atom->next = *case_insensitive_atoms;
        -:  652:
    #####:  653:      *case_insensitive_atoms = new_atom;
        -:  654:
    #####:  655:      atoms_cursor += atom_length;
    #####:  656:      atom_length = *atoms_cursor;
    #####:  657:      atoms_cursor++;
        -:  658:    }
        -:  659:
    #####:  660:    atom = atom->next;
        -:  661:  }
        -:  662:
    #####:  663:  return ERROR_SUCCESS;
        -:  664:}
        -:  665:
        -:  666:
        -:  667://
        -:  668:// _yr_atoms_xor
        -:  669://
        -:  670:// For a given list of atoms returns another list after a single byte xor
        -:  671:// has been applied to it.
        -:  672://
    #####:  673:static int _yr_atoms_xor(
        -:  674:    YR_ATOM_LIST_ITEM* atoms,
        -:  675:    YR_ATOM_LIST_ITEM** xor_atoms)
        -:  676:{
        -:  677:  YR_ATOM_LIST_ITEM* atom;
        -:  678:  YR_ATOM_LIST_ITEM* new_atom;
        -:  679:
        -:  680:  int i, j;
    #####:  681:  *xor_atoms = NULL;
    #####:  682:  atom = atoms;
        -:  683:
    #####:  684:  while (atom != NULL)
        -:  685:  {
    #####:  686:    for (j = 1; j <= 255; j++)
        -:  687:    {
    #####:  688:      new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -:  689:
    #####:  690:      if (new_atom == NULL)
    #####:  691:        return ERROR_INSUFFICIENT_MEMORY;
        -:  692:
    #####:  693:      for (i = 0; i < atom->atom_length; i++)
    #####:  694:        new_atom->atom[i] = atom->atom[i] ^ j;
        -:  695:
    #####:  696:      new_atom->atom_length = yr_min(atom->atom_length, YR_MAX_ATOM_LENGTH);
    #####:  697:      new_atom->forward_code = atom->forward_code;
    #####:  698:      new_atom->backward_code = atom->backward_code;
    #####:  699:      new_atom->backtrack = atom->backtrack;
    #####:  700:      new_atom->next = *xor_atoms;
        -:  701:
    #####:  702:      *xor_atoms = new_atom;
        -:  703:    }
        -:  704:
    #####:  705:    atom = atom->next;
        -:  706:  }
    #####:  707:  return ERROR_SUCCESS;
        -:  708:}
        -:  709://
        -:  710:// _yr_atoms_wide
        -:  711://
        -:  712:// For a given list of atoms returns another list with the corresponding
        -:  713:// wide atoms. Wide atoms are just the original atoms with interleaved zeroes,
        -:  714:// for example: 01 02 -> 01 00 02 00
        -:  715://
        -:  716:
    #####:  717:static int _yr_atoms_wide(
        -:  718:    YR_ATOM_LIST_ITEM* atoms,
        -:  719:    YR_ATOM_LIST_ITEM** wide_atoms)
        -:  720:{
        -:  721:  YR_ATOM_LIST_ITEM* atom;
        -:  722:  YR_ATOM_LIST_ITEM* new_atom;
        -:  723:
        -:  724:  int i;
        -:  725:
    #####:  726:  *wide_atoms = NULL;
    #####:  727:  atom = atoms;
        -:  728:
    #####:  729:  while (atom != NULL)
        -:  730:  {
    #####:  731:    new_atom = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -:  732:
    #####:  733:    if (new_atom == NULL)
    #####:  734:      return ERROR_INSUFFICIENT_MEMORY;
        -:  735:
    #####:  736:    for (i = 0; i < YR_MAX_ATOM_LENGTH; i++)
    #####:  737:      new_atom->atom[i] = 0;
        -:  738:
    #####:  739:    for (i = 0; i < atom->atom_length; i++)
        -:  740:    {
    #####:  741:      if (i * 2 < YR_MAX_ATOM_LENGTH)
    #####:  742:        new_atom->atom[i * 2] = atom->atom[i];
        -:  743:      else
    #####:  744:        break;
        -:  745:    }
        -:  746:
    #####:  747:    new_atom->atom_length = yr_min(atom->atom_length * 2, YR_MAX_ATOM_LENGTH);
    #####:  748:    new_atom->forward_code = atom->forward_code;
    #####:  749:    new_atom->backward_code = atom->backward_code;
    #####:  750:    new_atom->backtrack = atom->backtrack * 2;
    #####:  751:    new_atom->next = *wide_atoms;
        -:  752:
    #####:  753:    *wide_atoms = new_atom;
        -:  754:
    #####:  755:    atom = atom->next;
        -:  756:  }
        -:  757:
    #####:  758:  return ERROR_SUCCESS;
        -:  759:}
        -:  760:
        -:  761:
        -:  762://
        -:  763:// _yr_atoms_extract_from_re_node
        -:  764://
        -:  765:// Extract atoms from a regular expression node. See description for
        -:  766:// _yr_atoms_extract_from_re for more details.
        -:  767://
        -:  768:
    #####:  769:static ATOM_TREE_NODE* _yr_atoms_extract_from_re_node(
        -:  770:    YR_ATOMS_CONFIG* config,
        -:  771:    RE_NODE* re_node,
        -:  772:    ATOM_TREE* atom_tree,
        -:  773:    ATOM_TREE_NODE* current_node)
        -:  774:{
        -:  775:  ATOM_TREE_NODE* left_node;
        -:  776:  ATOM_TREE_NODE* right_node;
        -:  777:  ATOM_TREE_NODE* and_node;
        -:  778:  ATOM_TREE_NODE* current_leaf;
        -:  779:  ATOM_TREE_NODE* temp;
        -:  780:
        -:  781:  int quality;
        -:  782:  int new_quality;
        -:  783:  int i;
        -:  784:
        -:  785:  uint8_t new_atom[YR_MAX_ATOM_LENGTH];
        -:  786:
    #####:  787:  switch(re_node->type)
        -:  788:  {
    #####:  789:    case RE_NODE_LITERAL:
        -:  790:
    #####:  791:      if (atom_tree->current_leaf == NULL)
        -:  792:      {
    #####:  793:        atom_tree->current_leaf = _yr_atoms_tree_node_create(ATOM_TREE_LEAF);
        -:  794:
    #####:  795:        if (atom_tree->current_leaf == NULL)
    #####:  796:          return NULL;
        -:  797:
    #####:  798:        atom_tree->current_leaf->forward_code = re_node->forward_code;
    #####:  799:        atom_tree->current_leaf->backward_code = re_node->backward_code;
        -:  800:
    #####:  801:        assert(atom_tree->current_leaf->forward_code != NULL);
    #####:  802:        assert(atom_tree->current_leaf->backward_code != NULL);
        -:  803:      }
        -:  804:
    #####:  805:      current_leaf = atom_tree->current_leaf;
        -:  806:
    #####:  807:      if (current_leaf->atom_length < YR_MAX_ATOM_LENGTH)
        -:  808:      {
    #####:  809:        current_leaf->atom[current_leaf->atom_length] =
    #####:  810:            (uint8_t) re_node->value;
    #####:  811:        current_leaf->recent_nodes[current_leaf->atom_length] = re_node;
    #####:  812:        current_leaf->atom_length++;
        -:  813:      }
        -:  814:      else
        -:  815:      {
    #####:  816:        quality = config->get_atom_quality(
    #####:  817:            config, current_leaf->atom, YR_MAX_ATOM_LENGTH);
        -:  818:
    #####:  819:        if (quality < YR_MAX_ATOM_QUALITY)
        -:  820:        {
    #####:  821:          for (i = 1; i < YR_MAX_ATOM_LENGTH; i++)
    #####:  822:            current_leaf->recent_nodes[i - 1] = current_leaf->recent_nodes[i];
        -:  823:
    #####:  824:          current_leaf->recent_nodes[YR_MAX_ATOM_LENGTH - 1] = re_node;
        -:  825:
    #####:  826:          for (i = 0; i < YR_MAX_ATOM_LENGTH; i++)
    #####:  827:            new_atom[i] = (uint8_t) current_leaf->recent_nodes[i]->value;
        -:  828:
    #####:  829:          new_quality = config->get_atom_quality(
        -:  830:              config, new_atom, YR_MAX_ATOM_LENGTH);
        -:  831:
    #####:  832:          if (new_quality > quality)
        -:  833:          {
    #####:  834:            for (i = 0; i < YR_MAX_ATOM_LENGTH; i++)
    #####:  835:              current_leaf->atom[i] = new_atom[i];
        -:  836:
    #####:  837:            current_leaf->forward_code = \
    #####:  838:                current_leaf->recent_nodes[0]->forward_code;
        -:  839:
    #####:  840:            current_leaf->backward_code = \
    #####:  841:                current_leaf->recent_nodes[0]->backward_code;
        -:  842:
    #####:  843:            assert(current_leaf->forward_code != NULL);
    #####:  844:            assert(current_leaf->backward_code != NULL);
        -:  845:          }
        -:  846:        }
        -:  847:      }
        -:  848:
    #####:  849:      return current_node;
        -:  850:
    #####:  851:    case RE_NODE_CONCAT:
        -:  852:
    #####:  853:      current_node = _yr_atoms_extract_from_re_node(
        -:  854:          config, re_node->left, atom_tree, current_node);
        -:  855:
    #####:  856:      if (current_node == NULL)
    #####:  857:        return NULL;
        -:  858:
    #####:  859:      current_node = _yr_atoms_extract_from_re_node(
        -:  860:          config, re_node->right, atom_tree, current_node);
        -:  861:
    #####:  862:      return current_node;
        -:  863:
    #####:  864:    case RE_NODE_ALT:
        -:  865:
    #####:  866:      append_current_leaf_to_node(current_node);
        -:  867:
    #####:  868:      left_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
        -:  869:
    #####:  870:      if (left_node == NULL)
    #####:  871:        return NULL;
        -:  872:
    #####:  873:      left_node = _yr_atoms_extract_from_re_node(
        -:  874:          config, re_node->left, atom_tree, left_node);
        -:  875:
    #####:  876:      if (left_node == NULL)
    #####:  877:        return NULL;
        -:  878:
    #####:  879:      append_current_leaf_to_node(left_node);
        -:  880:
    #####:  881:      if (left_node->children_head == NULL)
        -:  882:      {
    #####:  883:        _yr_atoms_tree_node_destroy(left_node);
    #####:  884:        return current_node;
        -:  885:      }
        -:  886:
    #####:  887:      if (left_node->children_head == left_node->children_tail)
        -:  888:      {
    #####:  889:        temp = left_node;
    #####:  890:        left_node = left_node->children_head;
    #####:  891:        yr_free(temp);
        -:  892:      }
        -:  893:
    #####:  894:      right_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
        -:  895:
    #####:  896:      if (right_node == NULL)
    #####:  897:        return NULL;
        -:  898:
    #####:  899:      right_node = _yr_atoms_extract_from_re_node(
        -:  900:          config, re_node->right, atom_tree, right_node);
        -:  901:
    #####:  902:      if (right_node == NULL)
    #####:  903:        return NULL;
        -:  904:
    #####:  905:      append_current_leaf_to_node(right_node);
        -:  906:
    #####:  907:      if (right_node->children_head == NULL)
        -:  908:      {
    #####:  909:        _yr_atoms_tree_node_destroy(left_node);
    #####:  910:        _yr_atoms_tree_node_destroy(right_node);
    #####:  911:        return current_node;
        -:  912:      }
        -:  913:
    #####:  914:      if (right_node->children_head == right_node->children_tail)
        -:  915:      {
    #####:  916:        temp = right_node;
    #####:  917:        right_node = right_node->children_head;
    #####:  918:        yr_free(temp);
        -:  919:      }
        -:  920:
    #####:  921:      and_node = _yr_atoms_tree_node_create(ATOM_TREE_AND);
        -:  922:
    #####:  923:      if (and_node == NULL)
    #####:  924:        return NULL;
        -:  925:
    #####:  926:      and_node->children_head = left_node;
    #####:  927:      and_node->children_tail = right_node;
    #####:  928:      left_node->next_sibling = right_node;
        -:  929:
    #####:  930:      _yr_atoms_tree_node_append(current_node, and_node);
        -:  931:
    #####:  932:      return current_node;
        -:  933:
    #####:  934:    case RE_NODE_RANGE:
        -:  935:
    #####:  936:      if (re_node->start == 0)
    #####:  937:        append_current_leaf_to_node(current_node);
        -:  938:
        -:  939:      // In a regexp like /a{10,20}/ the optimal atom is 'aaaa' (assuming that
        -:  940:      // YR_MAX_ATOM_LENGTH = 4) because the 'a' character must appear at least
        -:  941:      // 10 times in the matching string. Each call in the loop will append
        -:  942:      // one 'a' to the atom, so YR_MAX_ATOM_LENGTH iterations are enough.
        -:  943:
    #####:  944:      for (i = 0; i < yr_min(re_node->start, YR_MAX_ATOM_LENGTH); i++)
        -:  945:      {
    #####:  946:        current_node = _yr_atoms_extract_from_re_node(
        -:  947:            config, re_node->left, atom_tree, current_node);
        -:  948:
    #####:  949:        if (current_node == NULL)
    #####:  950:          return NULL;
        -:  951:      }
        -:  952:
    #####:  953:      if (re_node->start != re_node->end)
    #####:  954:        append_current_leaf_to_node(current_node);
        -:  955:
    #####:  956:      return current_node;
        -:  957:
    #####:  958:    case RE_NODE_PLUS:
        -:  959:
    #####:  960:      current_node = _yr_atoms_extract_from_re_node(
        -:  961:          config, re_node->left, atom_tree, current_node);
        -:  962:
    #####:  963:      if (current_node == NULL)
    #####:  964:        return NULL;
        -:  965:
    #####:  966:      append_current_leaf_to_node(current_node);
    #####:  967:      return current_node;
        -:  968:
    #####:  969:    case RE_NODE_ANY:
        -:  970:    case RE_NODE_RANGE_ANY:
        -:  971:    case RE_NODE_STAR:
        -:  972:    case RE_NODE_CLASS:
        -:  973:    case RE_NODE_MASKED_LITERAL:
        -:  974:    case RE_NODE_WORD_CHAR:
        -:  975:    case RE_NODE_NON_WORD_CHAR:
        -:  976:    case RE_NODE_SPACE:
        -:  977:    case RE_NODE_NON_SPACE:
        -:  978:    case RE_NODE_DIGIT:
        -:  979:    case RE_NODE_NON_DIGIT:
        -:  980:    case RE_NODE_EMPTY:
        -:  981:    case RE_NODE_ANCHOR_START:
        -:  982:    case RE_NODE_ANCHOR_END:
        -:  983:    case RE_NODE_WORD_BOUNDARY:
        -:  984:    case RE_NODE_NON_WORD_BOUNDARY:
        -:  985:
    #####:  986:      append_current_leaf_to_node(current_node);
    #####:  987:      return current_node;
        -:  988:
    #####:  989:    default:
    #####:  990:      assert(false);
        -:  991:  }
        -:  992:
        -:  993:  return NULL;
        -:  994:}
        -:  995:
        -:  996://
        -:  997:// yr_atoms_extract_triplets
        -:  998://
        -:  999:// On certain cases YARA can not extract long enough atoms from a regexp, but
        -: 1000:// can infer them. For example, in the hex string { 01 ?? 02 } the only explicit
        -: 1001:// atoms are 01 and 02, and both of them are too short to be efficiently used.
        -: 1002:// However YARA can use simultaneously atoms 01 00 02, 01 01 02, 01 02 02,
        -: 1003:// 01 03 02, and so on up to 01 FF 02. Searching for 256 three-bytes atoms is
        -: 1004:// faster than searching for a single one-byte atom.
        -: 1005://
        -: 1006:// This function extracts these three-bytes atoms from a regexp node if
        -: 1007:// possible.
        -: 1008://
        -: 1009:
    #####: 1010:int yr_atoms_extract_triplets(
        -: 1011:    RE_NODE* re_node,
        -: 1012:    YR_ATOM_LIST_ITEM** atoms)
        -: 1013: {
        -: 1014:    RE_NODE* left_child;
        -: 1015:    RE_NODE* left_grand_child;
        -: 1016:
        -: 1017:    int i;
        -: 1018:    int shift;
        -: 1019:
    #####: 1020:    *atoms = NULL;
        -: 1021:
    #####: 1022:    if (re_node->type == RE_NODE_CONCAT)
    #####: 1023:      left_child = re_node->left;
        -: 1024:    else
    #####: 1025:      return ERROR_SUCCESS;
        -: 1026:
    #####: 1027:    if (left_child->type == RE_NODE_CONCAT)
    #####: 1028:      left_grand_child = left_child->left;
        -: 1029:    else
    #####: 1030:      return ERROR_SUCCESS;
        -: 1031:
    #####: 1032:    if (re_node->right->type != RE_NODE_LITERAL)
    #####: 1033:      return yr_atoms_extract_triplets(left_child, atoms);
        -: 1034:
    #####: 1035:    if (left_child->left->type == RE_NODE_LITERAL &&
    #####: 1036:        (left_child->right->type == RE_NODE_ANY))
        -: 1037:    {
    #####: 1038:      for (i = 0; i < 256; i++)
        -: 1039:      {
        -: 1040:        YR_ATOM_LIST_ITEM* atom = (YR_ATOM_LIST_ITEM*)
    #####: 1041:            yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1042:
    #####: 1043:        if (atom == NULL)
    #####: 1044:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1045:
    #####: 1046:        atom->atom[0] = (uint8_t) left_child->left->value;
    #####: 1047:        atom->atom[1] = (uint8_t) i;
    #####: 1048:        atom->atom[2] = (uint8_t) re_node->right->value;
        -: 1049:
    #####: 1050:        atom->atom_length = 3;
    #####: 1051:        atom->forward_code = left_child->left->forward_code;
    #####: 1052:        atom->backward_code = left_child->left->backward_code;
    #####: 1053:        atom->backtrack = 0;
    #####: 1054:        atom->next = *atoms;
        -: 1055:
    #####: 1056:        *atoms = atom;
        -: 1057:      }
        -: 1058:
    #####: 1059:      return ERROR_SUCCESS;
        -: 1060:    }
        -: 1061:
    #####: 1062:    if (left_child->left->type == RE_NODE_LITERAL &&
    #####: 1063:        (left_child->right->type == RE_NODE_MASKED_LITERAL))
        -: 1064:    {
    #####: 1065:      for (i = 0; i < 16; i++)
        -: 1066:      {
        -: 1067:        YR_ATOM_LIST_ITEM* atom = (YR_ATOM_LIST_ITEM*)
    #####: 1068:            yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1069:
    #####: 1070:        if (atom == NULL)
    #####: 1071:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1072:
    #####: 1073:        if (left_child->right->mask == 0xF0)
    #####: 1074:          shift = 0;
        -: 1075:        else
    #####: 1076:          shift = 4;
        -: 1077:
    #####: 1078:        atom->atom[0] = (uint8_t) left_child->left->value;
    #####: 1079:        atom->atom[1] = (uint8_t)(left_child->right->value | (i << shift));
    #####: 1080:        atom->atom[2] = (uint8_t) re_node->right->value;
        -: 1081:
    #####: 1082:        atom->atom_length = 3;
    #####: 1083:        atom->forward_code = left_child->left->forward_code;
    #####: 1084:        atom->backward_code = left_child->left->backward_code;
    #####: 1085:        atom->backtrack = 0;
    #####: 1086:        atom->next = *atoms;
        -: 1087:
    #####: 1088:        *atoms = atom;
        -: 1089:      }
        -: 1090:
    #####: 1091:      return ERROR_SUCCESS;
        -: 1092:    }
        -: 1093:
    #####: 1094:    if (left_grand_child->type == RE_NODE_CONCAT &&
    #####: 1095:        left_grand_child->right->type == RE_NODE_LITERAL &&
    #####: 1096:        (left_child->right->type == RE_NODE_ANY))
        -: 1097:    {
    #####: 1098:      for (i = 0; i < 256; i++)
        -: 1099:      {
        -: 1100:        YR_ATOM_LIST_ITEM* atom = (YR_ATOM_LIST_ITEM*)
    #####: 1101:            yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1102:
    #####: 1103:        if (atom == NULL)
    #####: 1104:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1105:
    #####: 1106:        atom->atom[0] = (uint8_t) left_grand_child->right->value;
    #####: 1107:        atom->atom[1] = (uint8_t) i;
    #####: 1108:        atom->atom[2] = (uint8_t) re_node->right->value;
        -: 1109:
    #####: 1110:        atom->atom_length = 3;
    #####: 1111:        atom->forward_code = left_grand_child->right->forward_code;
    #####: 1112:        atom->backward_code = left_grand_child->right->backward_code;
    #####: 1113:        atom->backtrack = 0;
    #####: 1114:        atom->next = *atoms;
        -: 1115:
    #####: 1116:        *atoms = atom;
        -: 1117:      }
        -: 1118:
    #####: 1119:      return ERROR_SUCCESS;
        -: 1120:    }
        -: 1121:
    #####: 1122:    if (left_grand_child->type == RE_NODE_CONCAT &&
    #####: 1123:        left_grand_child->right->type == RE_NODE_LITERAL &&
    #####: 1124:        (left_child->right->type == RE_NODE_MASKED_LITERAL))
        -: 1125:    {
    #####: 1126:      for (i = 0; i < 16; i++)
        -: 1127:      {
        -: 1128:        YR_ATOM_LIST_ITEM* atom = (YR_ATOM_LIST_ITEM*)
    #####: 1129:            yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1130:
    #####: 1131:        if (atom == NULL)
    #####: 1132:          return ERROR_INSUFFICIENT_MEMORY;
        -: 1133:
    #####: 1134:        if (left_child->right->mask == 0xF0)
    #####: 1135:          shift = 0;
        -: 1136:        else
    #####: 1137:          shift = 4;
        -: 1138:
    #####: 1139:        atom->atom[0] = (uint8_t) left_grand_child->right->value;
    #####: 1140:        atom->atom[1] = (uint8_t)(left_child->right->value | (i << shift));
    #####: 1141:        atom->atom[2] = (uint8_t) re_node->right->value;
        -: 1142:
    #####: 1143:        atom->atom_length = 3;
    #####: 1144:        atom->forward_code = left_grand_child->right->forward_code;
    #####: 1145:        atom->backward_code = left_grand_child->right->backward_code;
    #####: 1146:        atom->backtrack = 0;
    #####: 1147:        atom->next = *atoms;
        -: 1148:
    #####: 1149:        *atoms = atom;
        -: 1150:      }
        -: 1151:
    #####: 1152:      return ERROR_SUCCESS;
        -: 1153:    }
        -: 1154:
    #####: 1155:    return yr_atoms_extract_triplets(left_child, atoms);;
        -: 1156: }
        -: 1157:
        -: 1158://
        -: 1159:// _yr_atoms_extract_from_re
        -: 1160://
        -: 1161:// Extract atoms from a regular expression.
        -: 1162://
        -: 1163:
    #####: 1164:int yr_atoms_extract_from_re(
        -: 1165:    YR_ATOMS_CONFIG* config,
        -: 1166:    RE_AST* re_ast,
        -: 1167:    int flags,
        -: 1168:    YR_ATOM_LIST_ITEM** atoms)
        -: 1169:{
    #####: 1170:  ATOM_TREE* atom_tree = (ATOM_TREE*) yr_malloc(sizeof(ATOM_TREE));
        -: 1171:  ATOM_TREE_NODE* temp;
        -: 1172:  YR_ATOM_LIST_ITEM* wide_atoms;
        -: 1173:  YR_ATOM_LIST_ITEM* case_insensitive_atoms;
        -: 1174:  YR_ATOM_LIST_ITEM* triplet_atoms;
        -: 1175:
    #####: 1176:  int min_atom_quality = YR_MIN_ATOM_QUALITY;
        -: 1177:
    #####: 1178:  if (atom_tree == NULL)
    #####: 1179:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1180:
    #####: 1181:  atom_tree->root_node = _yr_atoms_tree_node_create(ATOM_TREE_OR);
        -: 1182:
    #####: 1183:  if (atom_tree->root_node == NULL)
        -: 1184:  {
    #####: 1185:    _yr_atoms_tree_destroy(atom_tree);
    #####: 1186:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1187:  }
        -: 1188:
    #####: 1189:  atom_tree->current_leaf = NULL;
        -: 1190:
    #####: 1191:  atom_tree->root_node = _yr_atoms_extract_from_re_node(
        -: 1192:      config, re_ast->root_node, atom_tree, atom_tree->root_node);
        -: 1193:
    #####: 1194:  if (atom_tree->root_node == NULL)
        -: 1195:  {
    #####: 1196:    _yr_atoms_tree_destroy(atom_tree);
    #####: 1197:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1198:  }
        -: 1199:
    #####: 1200:  if (atom_tree->current_leaf != NULL)
    #####: 1201:    _yr_atoms_tree_node_append(atom_tree->root_node, atom_tree->current_leaf);
        -: 1202:
    #####: 1203:  if (atom_tree->root_node->children_head ==
    #####: 1204:      atom_tree->root_node->children_tail)
        -: 1205:  {
        -: 1206:    // The root OR node has a single child, there's no need for the OR node so
        -: 1207:    // we proceed to destroy it and use its child as root.
        -: 1208:
    #####: 1209:    temp = atom_tree->root_node;
    #####: 1210:    atom_tree->root_node = atom_tree->root_node->children_head;
    #####: 1211:    yr_free(temp);
        -: 1212:  }
        -: 1213:
        -: 1214:  // Initialize atom list
    #####: 1215:  *atoms = NULL;
        -: 1216:
    #####: 1217:  if (atom_tree->root_node != NULL)
        -: 1218:  {
        -: 1219:    // Choose the atoms that will be used.
    #####: 1220:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1221:        _yr_atoms_choose(
        -: 1222:            config, atom_tree->root_node, atoms, &min_atom_quality),
        -: 1223:        _yr_atoms_tree_destroy(atom_tree));
        -: 1224:  }
        -: 1225:
    #####: 1226:  _yr_atoms_tree_destroy(atom_tree);
        -: 1227:
    #####: 1228:  FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1229:      yr_atoms_extract_triplets(re_ast->root_node, &triplet_atoms),
        -: 1230:      {
        -: 1231:        yr_atoms_list_destroy(*atoms);
        -: 1232:        yr_atoms_list_destroy(triplet_atoms);
        -: 1233:        *atoms = NULL;
        -: 1234:      });
        -: 1235:
    #####: 1236:  if (min_atom_quality < (yr_atoms_min_quality(config, triplet_atoms) >> 1))
        -: 1237:  {
    #####: 1238:    yr_atoms_list_destroy(*atoms);
    #####: 1239:    *atoms = triplet_atoms;
        -: 1240:  }
        -: 1241:  else
        -: 1242:  {
    #####: 1243:    yr_atoms_list_destroy(triplet_atoms);
        -: 1244:  }
        -: 1245:
    #####: 1246:  if (flags & STRING_GFLAGS_WIDE)
        -: 1247:  {
    #####: 1248:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1249:        _yr_atoms_wide(*atoms, &wide_atoms),
        -: 1250:        {
        -: 1251:          yr_atoms_list_destroy(*atoms);
        -: 1252:          yr_atoms_list_destroy(wide_atoms);
        -: 1253:          *atoms = NULL;
        -: 1254:        });
        -: 1255:
    #####: 1256:    if (flags & STRING_GFLAGS_ASCII)
        -: 1257:    {
    #####: 1258:      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);
        -: 1259:    }
        -: 1260:    else
        -: 1261:    {
    #####: 1262:      yr_atoms_list_destroy(*atoms);
    #####: 1263:      *atoms = wide_atoms;
        -: 1264:    }
        -: 1265:  }
        -: 1266:
    #####: 1267:  if (flags & STRING_GFLAGS_NO_CASE)
        -: 1268:  {
    #####: 1269:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1270:        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),
        -: 1271:        {
        -: 1272:          yr_atoms_list_destroy(*atoms);
        -: 1273:          yr_atoms_list_destroy(case_insensitive_atoms);
        -: 1274:          *atoms = NULL;
        -: 1275:        });
        -: 1276:
    #####: 1277:    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);
        -: 1278:  }
        -: 1279:
        -: 1280:  // No atoms has been extracted, let's add a zero-length atom.
        -: 1281:
    #####: 1282:  if (*atoms == NULL)
        -: 1283:  {
    #####: 1284:    *atoms = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1285:
    #####: 1286:    if (*atoms == NULL)
    #####: 1287:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1288:
    #####: 1289:    (*atoms)->atom_length = 0;
    #####: 1290:    (*atoms)->backtrack = 0;
    #####: 1291:    (*atoms)->forward_code = re_ast->root_node->forward_code;
    #####: 1292:    (*atoms)->backward_code = NULL;
    #####: 1293:    (*atoms)->next = NULL;
        -: 1294:  }
        -: 1295:
    #####: 1296:  return ERROR_SUCCESS;
        -: 1297:}
        -: 1298:
        -: 1299:
        -: 1300://
        -: 1301:// yr_atoms_extract_from_string
        -: 1302://
        -: 1303:// Extract atoms from a string.
        -: 1304://
        -: 1305:
    #####: 1306:int yr_atoms_extract_from_string(
        -: 1307:    YR_ATOMS_CONFIG* config,
        -: 1308:    uint8_t* string,
        -: 1309:    int32_t string_length,
        -: 1310:    int flags,
        -: 1311:    YR_ATOM_LIST_ITEM** atoms)
        -: 1312:{
        -: 1313:  YR_ATOM_LIST_ITEM* item;
        -: 1314:  YR_ATOM_LIST_ITEM* case_insensitive_atoms;
        -: 1315:  YR_ATOM_LIST_ITEM* xor_atoms;
        -: 1316:  YR_ATOM_LIST_ITEM* wide_atoms;
        -: 1317:
        -: 1318:  int max_quality;
        -: 1319:  int i, j, length;
        -: 1320:
    #####: 1321:  item = (YR_ATOM_LIST_ITEM*) yr_malloc(sizeof(YR_ATOM_LIST_ITEM));
        -: 1322:
    #####: 1323:  if (item == NULL)
    #####: 1324:    return ERROR_INSUFFICIENT_MEMORY;
        -: 1325:
    #####: 1326:  item->forward_code = NULL;
    #####: 1327:  item->backward_code = NULL;
    #####: 1328:  item->next = NULL;
    #####: 1329:  item->backtrack = 0;
        -: 1330:
    #####: 1331:  length = yr_min(string_length, YR_MAX_ATOM_LENGTH);
        -: 1332:
    #####: 1333:  for (i = 0; i < length; i++)
    #####: 1334:    item->atom[i] = string[i];
        -: 1335:
    #####: 1336:  item->atom_length = i;
        -: 1337:
    #####: 1338:  max_quality = config->get_atom_quality(config, string, length);
        -: 1339:
    #####: 1340:  for (i = YR_MAX_ATOM_LENGTH;
    #####: 1341:       i < string_length && max_quality < YR_MAX_ATOM_QUALITY;
    #####: 1342:       i++)
        -: 1343:  {
    #####: 1344:    int quality = config->get_atom_quality(
        -: 1345:        config,
    #####: 1346:        string + i - YR_MAX_ATOM_LENGTH + 1,
        -: 1347:        YR_MAX_ATOM_LENGTH);
        -: 1348:
    #####: 1349:    if (quality > max_quality)
        -: 1350:    {
    #####: 1351:      for (j = 0; j < YR_MAX_ATOM_LENGTH; j++)
    #####: 1352:        item->atom[j] = string[i + j - YR_MAX_ATOM_LENGTH + 1];
        -: 1353:
    #####: 1354:      item->backtrack = i - YR_MAX_ATOM_LENGTH + 1;
    #####: 1355:      max_quality = quality;
        -: 1356:    }
        -: 1357:  }
        -: 1358:
    #####: 1359:  *atoms = item;
        -: 1360:
    #####: 1361:  if (flags & STRING_GFLAGS_WIDE)
        -: 1362:  {
    #####: 1363:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1364:        _yr_atoms_wide(*atoms, &wide_atoms),
        -: 1365:        {
        -: 1366:          yr_atoms_list_destroy(*atoms);
        -: 1367:          yr_atoms_list_destroy(wide_atoms);
        -: 1368:          *atoms = NULL;
        -: 1369:        });
        -: 1370:
    #####: 1371:    if (flags & STRING_GFLAGS_ASCII)
        -: 1372:    {
    #####: 1373:      *atoms = _yr_atoms_list_concat(*atoms, wide_atoms);
        -: 1374:    }
        -: 1375:    else
        -: 1376:    {
    #####: 1377:      yr_atoms_list_destroy(*atoms);
    #####: 1378:      *atoms = wide_atoms;
        -: 1379:    }
        -: 1380:  }
        -: 1381:
    #####: 1382:  if (flags & STRING_GFLAGS_NO_CASE)
        -: 1383:  {
    #####: 1384:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1385:        _yr_atoms_case_insensitive(*atoms, &case_insensitive_atoms),
        -: 1386:        {
        -: 1387:          yr_atoms_list_destroy(*atoms);
        -: 1388:          yr_atoms_list_destroy(case_insensitive_atoms);
        -: 1389:          *atoms = NULL;
        -: 1390:        });
        -: 1391:
    #####: 1392:    *atoms = _yr_atoms_list_concat(*atoms, case_insensitive_atoms);
        -: 1393:  }
        -: 1394:
    #####: 1395:  if (flags & STRING_GFLAGS_XOR)
        -: 1396:  {
    #####: 1397:    FAIL_ON_ERROR_WITH_CLEANUP(
        -: 1398:      _yr_atoms_xor(*atoms, &xor_atoms),
        -: 1399:      {
        -: 1400:        yr_atoms_list_destroy(*atoms);
        -: 1401:        yr_atoms_list_destroy(xor_atoms);
        -: 1402:        *atoms = NULL;
        -: 1403:      });
        -: 1404:
    #####: 1405:    if (flags & STRING_GFLAGS_ASCII ||
    #####: 1406:        flags & STRING_GFLAGS_WIDE ||
    #####: 1407:        flags & STRING_GFLAGS_NO_CASE)
        -: 1408:    {
    #####: 1409:      *atoms = _yr_atoms_list_concat(*atoms, xor_atoms);
        -: 1410:    }
        -: 1411:    else
        -: 1412:    {
    #####: 1413:      yr_atoms_list_destroy(*atoms);
    #####: 1414:      *atoms = xor_atoms;
        -: 1415:    }
        -: 1416:
        -: 1417:  }
        -: 1418:
    #####: 1419:  return ERROR_SUCCESS;
        -: 1420:}
        -: 1421:
        -: 1422:
        -: 1423://
        -: 1424:// yr_atoms_tree_node_print
        -: 1425://
        -: 1426:// Prints an atom tree node. Used only for debugging purposes.
        -: 1427://
        -: 1428:
    #####: 1429:void yr_atoms_tree_node_print(
        -: 1430:    ATOM_TREE_NODE* node)
        -: 1431:{
        -: 1432:  ATOM_TREE_NODE* child;
        -: 1433:  int i;
        -: 1434:
    #####: 1435:  if (node == NULL)
        -: 1436:  {
    #####: 1437:    printf("Empty tree node\n");
    #####: 1438:    return;
        -: 1439:  }
        -: 1440:
    #####: 1441:  switch(node->type)
        -: 1442:  {
    #####: 1443:  case ATOM_TREE_LEAF:
    #####: 1444:    for (i = 0; i < node->atom_length; i++)
    #####: 1445:      printf("%02X", node->atom[i]);
    #####: 1446:    break;
        -: 1447:
    #####: 1448:  case ATOM_TREE_AND:
        -: 1449:  case ATOM_TREE_OR:
    #####: 1450:    if (node->type == ATOM_TREE_AND)
    #####: 1451:      printf("AND");
        -: 1452:    else
    #####: 1453:      printf("OR");
    #####: 1454:    printf("(");
    #####: 1455:    child = node->children_head;
    #####: 1456:    while (child != NULL)
        -: 1457:    {
    #####: 1458:      yr_atoms_tree_node_print(child);
    #####: 1459:      child = child->next_sibling;
    #####: 1460:      if (child != NULL)
    #####: 1461:        printf(",");
        -: 1462:    }
    #####: 1463:    printf(")");
    #####: 1464:    break;
        -: 1465:  }
        -: 1466:}
