        -:    0:Source:ahocorasick.c
        -:    0:Graph:/home/workspace/libyara/ahocorasick.gcno
        -:    0:Data:/home/workspace/libyara/ahocorasick.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <assert.h>
        -:   31:#include <stdbool.h>
        -:   32:#include <stddef.h>
        -:   33:#include <string.h>
        -:   34:
        -:   35:#include <yara/arena.h>
        -:   36:#include <yara/ahocorasick.h>
        -:   37:#include <yara/error.h>
        -:   38:#include <yara/utils.h>
        -:   39:#include <yara/mem.h>
        -:   40:
        -:   41:
        -:   42:
        -:   43:typedef struct _QUEUE_NODE
        -:   44:{
        -:   45:  YR_AC_STATE* value;
        -:   46:
        -:   47:  struct _QUEUE_NODE*  previous;
        -:   48:  struct _QUEUE_NODE*  next;
        -:   49:
        -:   50:} QUEUE_NODE;
        -:   51:
        -:   52:
        -:   53:typedef struct _QUEUE
        -:   54:{
        -:   55:  QUEUE_NODE* head;
        -:   56:  QUEUE_NODE* tail;
        -:   57:
        -:   58:} QUEUE;
        -:   59:
        -:   60:
        -:   61://
        -:   62:// _yr_ac_queue_push
        -:   63://
        -:   64:// Pushes a state in a queue.
        -:   65://
        -:   66:// Args:
        -:   67://    QUEUE* queue     - The queue
        -:   68://    YR_AC_STATE* state  - The state
        -:   69://
        -:   70:// Returns:
        -:   71://    ERROR_SUCCESS if succeed or the corresponding error code otherwise.
        -:   72://
        -:   73:
    #####:   74:static int _yr_ac_queue_push(
        -:   75:    QUEUE* queue,
        -:   76:    YR_AC_STATE* value)
        -:   77:{
        -:   78:  QUEUE_NODE* pushed_node;
        -:   79:
    #####:   80:  pushed_node = (QUEUE_NODE*) yr_malloc(sizeof(QUEUE_NODE));
        -:   81:
    #####:   82:  if (pushed_node == NULL)
    #####:   83:    return ERROR_INSUFFICIENT_MEMORY;
        -:   84:
    #####:   85:  pushed_node->previous = queue->tail;
    #####:   86:  pushed_node->next = NULL;
    #####:   87:  pushed_node->value = value;
        -:   88:
    #####:   89:  if (queue->tail != NULL)
    #####:   90:    queue->tail->next = pushed_node;
        -:   91:  else // queue is empty
    #####:   92:    queue->head = pushed_node;
        -:   93:
    #####:   94:  queue->tail = pushed_node;
        -:   95:
    #####:   96:  return ERROR_SUCCESS;
        -:   97:}
        -:   98:
        -:   99:
        -:  100://
        -:  101:// _yr_ac_queue_pop
        -:  102://
        -:  103:// Pops a state from a queue.
        -:  104://
        -:  105:// Args:
        -:  106://    QUEUE* queue     - The queue
        -:  107://
        -:  108:// Returns:
        -:  109://    Pointer to the poped state.
        -:  110://
        -:  111:
    #####:  112:static YR_AC_STATE* _yr_ac_queue_pop(
        -:  113:    QUEUE* queue)
        -:  114:{
        -:  115:  YR_AC_STATE* result;
        -:  116:  QUEUE_NODE* popped_node;
        -:  117:
    #####:  118:  if (queue->head == NULL)
    #####:  119:    return NULL;
        -:  120:
    #####:  121:  popped_node = queue->head;
    #####:  122:  queue->head = popped_node->next;
        -:  123:
    #####:  124:  if (queue->head)
    #####:  125:    queue->head->previous = NULL;
        -:  126:  else // queue is empty
    #####:  127:    queue->tail = NULL;
        -:  128:
    #####:  129:  result = popped_node->value;
        -:  130:
    #####:  131:  yr_free(popped_node);
    #####:  132:  return result;
        -:  133:}
        -:  134:
        -:  135:
        -:  136://
        -:  137:// _yr_ac_queue_is_empty
        -:  138://
        -:  139:// Checks if a queue is empty.
        -:  140://
        -:  141:// Args:
        -:  142://    QUEUE* queue     - The queue
        -:  143://
        -:  144:// Returns:
        -:  145://    true if queue is empty, false otherwise.
        -:  146://
        -:  147:
    #####:  148:static int _yr_ac_queue_is_empty(
        -:  149:    QUEUE* queue)
        -:  150:{
    #####:  151:  return queue->head == NULL;
        -:  152:}
        -:  153:
        -:  154:
        -:  155://
        -:  156:// _yr_ac_next_state
        -:  157://
        -:  158:// Given an automaton state and an input symbol, returns the new state
        -:  159:// after reading the input symbol.
        -:  160://
        -:  161:// Args:
        -:  162://    YR_AC_STATE* state     - Automaton state
        -:  163://    uint8_t input       - Input symbol
        -:  164://
        -:  165:// Returns:
        -:  166://   Pointer to the next automaton state.
        -:  167://
        -:  168:
    #####:  169:static YR_AC_STATE* _yr_ac_next_state(
        -:  170:    YR_AC_STATE* state,
        -:  171:    uint8_t input)
        -:  172:{
    #####:  173:  YR_AC_STATE* next_state = state->first_child;
        -:  174:
    #####:  175:  while (next_state != NULL)
        -:  176:  {
    #####:  177:    if (next_state->input == input)
    #####:  178:      return next_state;
        -:  179:
    #####:  180:    next_state = next_state->siblings;
        -:  181:  }
        -:  182:
    #####:  183:  return NULL;
        -:  184:}
        -:  185:
        -:  186:
        -:  187://
        -:  188:// _yr_ac_state_create
        -:  189://
        -:  190:// Creates a new automaton state, the automaton will transition from
        -:  191:// the given state to the new state after reading the input symbol.
        -:  192://
        -:  193:// Args:
        -:  194://   YR_AC_STATE* state  - Origin state
        -:  195://   uint8_t input       - Input symbol
        -:  196://
        -:  197:// Returns:
        -:  198://   YR_AC_STATE* pointer to the newly allocated state or NULL in case
        -:  199://   of error.
        -:  200:
    #####:  201:static YR_AC_STATE* _yr_ac_state_create(
        -:  202:    YR_AC_STATE* state,
        -:  203:    uint8_t input)
        -:  204:{
    #####:  205:  YR_AC_STATE* new_state = (YR_AC_STATE*) yr_malloc(sizeof(YR_AC_STATE));
        -:  206:
    #####:  207:  if (new_state == NULL)
    #####:  208:    return NULL;
        -:  209:
    #####:  210:  new_state->input = input;
    #####:  211:  new_state->depth = state->depth + 1;
    #####:  212:  new_state->matches = NULL;
    #####:  213:  new_state->failure = NULL;
    #####:  214:  new_state->t_table_slot = 0;
    #####:  215:  new_state->first_child = NULL;
    #####:  216:  new_state->siblings = state->first_child;
    #####:  217:  state->first_child = new_state;
        -:  218:
    #####:  219:  return new_state;
        -:  220:}
        -:  221:
        -:  222:
        -:  223://
        -:  224:// _yr_ac_state_destroy
        -:  225://
        -:  226:
        1:  227:static int _yr_ac_state_destroy(
        -:  228:    YR_AC_STATE* state)
        -:  229:{
        1:  230:  YR_AC_STATE* child_state = state->first_child;
        -:  231:
        1:  232:  while (child_state != NULL)
        -:  233:  {
    #####:  234:    YR_AC_STATE* next_child_state = child_state->siblings;
    #####:  235:    _yr_ac_state_destroy(child_state);
    #####:  236:    child_state = next_child_state;
        -:  237:  }
        -:  238:
        1:  239:  yr_free(state);
        -:  240:
        1:  241:  return ERROR_SUCCESS;
        -:  242:}
        -:  243:
        -:  244:
        -:  245://
        -:  246:// _yr_ac_create_failure_links
        -:  247://
        -:  248:// Create failure links for each automaton state. This function must
        -:  249:// be called after all the strings have been added to the automaton.
        -:  250://
        -:  251:
    #####:  252:static int _yr_ac_create_failure_links(
        -:  253:    YR_AC_AUTOMATON* automaton)
        -:  254:{
        -:  255:  YR_AC_STATE* current_state;
        -:  256:  YR_AC_STATE* failure_state;
        -:  257:  YR_AC_STATE* temp_state;
        -:  258:  YR_AC_STATE* state;
        -:  259:  YR_AC_STATE* transition_state;
        -:  260:  YR_AC_STATE* root_state;
        -:  261:  YR_AC_MATCH* match;
        -:  262:
        -:  263:  QUEUE queue;
        -:  264:
    #####:  265:  queue.head = NULL;
    #####:  266:  queue.tail = NULL;
        -:  267:
    #####:  268:  root_state = automaton->root;
        -:  269:
        -:  270:  // Set the failure link of root state to itself.
    #####:  271:  root_state->failure = root_state;
        -:  272:
        -:  273:  // Push root's children and set their failure link to root.
    #####:  274:  state = root_state->first_child;
        -:  275:
    #####:  276:  while (state != NULL)
        -:  277:  {
    #####:  278:    FAIL_ON_ERROR(_yr_ac_queue_push(&queue, state));
    #####:  279:    state->failure = root_state;
    #####:  280:    state = state->siblings;
        -:  281:  }
        -:  282:
        -:  283:  // Traverse the trie in BFS order calculating the failure link
        -:  284:  // for each state.
        -:  285:
    #####:  286:  while (!_yr_ac_queue_is_empty(&queue))
        -:  287:  {
    #####:  288:    current_state = _yr_ac_queue_pop(&queue);
        -:  289:
    #####:  290:    match = current_state->matches;
        -:  291:
    #####:  292:    if (match != NULL)
        -:  293:    {
    #####:  294:      while (match->next != NULL)
    #####:  295:        match = match->next;
        -:  296:
    #####:  297:      if (match->backtrack > 0)
    #####:  298:        match->next = root_state->matches;
        -:  299:    }
        -:  300:    else
        -:  301:    {
    #####:  302:      current_state->matches = root_state->matches;
        -:  303:    }
        -:  304:
    #####:  305:    transition_state = current_state->first_child;
        -:  306:
    #####:  307:    while (transition_state != NULL)
        -:  308:    {
    #####:  309:      FAIL_ON_ERROR(_yr_ac_queue_push(&queue, transition_state));
    #####:  310:      failure_state = current_state->failure;
        -:  311:
        -:  312:      while (1)
        -:  313:      {
    #####:  314:        temp_state = _yr_ac_next_state(
    #####:  315:            failure_state, transition_state->input);
        -:  316:
    #####:  317:        if (temp_state != NULL)
        -:  318:        {
    #####:  319:          transition_state->failure = temp_state;
        -:  320:
    #####:  321:          if (transition_state->matches == NULL)
        -:  322:          {
    #####:  323:            transition_state->matches = temp_state->matches;
        -:  324:          }
        -:  325:          else
        -:  326:          {
    #####:  327:            match = transition_state->matches;
        -:  328:
    #####:  329:            while (match != NULL && match->next != NULL)
    #####:  330:              match = match->next;
        -:  331:
    #####:  332:            match->next = temp_state->matches;
        -:  333:          }
        -:  334:
    #####:  335:          break;
        -:  336:        }
        -:  337:        else
        -:  338:        {
    #####:  339:          if (failure_state == root_state)
        -:  340:          {
    #####:  341:            transition_state->failure = root_state;
    #####:  342:            break;
        -:  343:          }
        -:  344:          else
        -:  345:          {
    #####:  346:            failure_state = failure_state->failure;
        -:  347:          }
        -:  348:        }
        -:  349:      } // while(1)
        -:  350:
    #####:  351:      transition_state = transition_state->siblings;
        -:  352:    }
        -:  353:
        -:  354:  } // while(!__yr_ac_queue_is_empty(&queue))
        -:  355:
    #####:  356:  return ERROR_SUCCESS;
        -:  357:}
        -:  358:
        -:  359:
        -:  360://
        -:  361:// _yr_ac_transitions_subset
        -:  362://
        -:  363:// Returns true if the transitions for state s2 are a subset of the transitions
        -:  364:// for state s1. In other words, if at state s2 input X is accepted, it must be
        -:  365:// accepted in s1 too.
        -:  366://
        -:  367:
    #####:  368:static bool _yr_ac_transitions_subset(
        -:  369:    YR_AC_STATE* s1,
        -:  370:    YR_AC_STATE* s2)
        -:  371:{
        -:  372:  uint8_t set[32];
        -:  373:
    #####:  374:  YR_AC_STATE* state = s1->first_child;
        -:  375:
    #####:  376:  memset(set, 0, 32);
        -:  377:
    #####:  378:  while (state != NULL)
        -:  379:  {
    #####:  380:    set[state->input / 8] |= 1 << state->input % 8;
    #####:  381:    state = state->siblings;
        -:  382:  }
        -:  383:
    #####:  384:  state = s2->first_child;
        -:  385:
    #####:  386:  while (state != NULL)
        -:  387:  {
    #####:  388:    if (!(set[state->input / 8] & 1 << state->input % 8))
    #####:  389:      return false;
        -:  390:
    #####:  391:    state = state->siblings;
        -:  392:  }
        -:  393:
    #####:  394:  return true;
        -:  395:}
        -:  396:
        -:  397:
        -:  398://
        -:  399:// _yr_ac_optimize_failure_links
        -:  400://
        -:  401:// Removes unnecessary failure links.
        -:  402://
        -:  403:
    #####:  404:static int _yr_ac_optimize_failure_links(
        -:  405:    YR_AC_AUTOMATON* automaton)
        -:  406:{
    #####:  407:  QUEUE queue = { NULL, NULL};
        -:  408:
        -:  409:  // Push root's children.
    #####:  410:  YR_AC_STATE* root_state = automaton->root;
    #####:  411:  YR_AC_STATE* state = root_state->first_child;
        -:  412:
    #####:  413:  while (state != NULL)
        -:  414:  {
    #####:  415:    FAIL_ON_ERROR(_yr_ac_queue_push(&queue, state));
    #####:  416:    state = state->siblings;
        -:  417:  }
        -:  418:
    #####:  419:  while (!_yr_ac_queue_is_empty(&queue))
        -:  420:  {
    #####:  421:    YR_AC_STATE* current_state = _yr_ac_queue_pop(&queue);
        -:  422:
    #####:  423:    if (current_state->failure != root_state)
        -:  424:    {
    #####:  425:      if (_yr_ac_transitions_subset(current_state, current_state->failure))
    #####:  426:        current_state->failure = current_state->failure->failure;
        -:  427:    }
        -:  428:
        -:  429:    // Push childrens of current_state
    #####:  430:    state = current_state->first_child;
        -:  431:
    #####:  432:    while (state != NULL)
        -:  433:    {
    #####:  434:      FAIL_ON_ERROR(_yr_ac_queue_push(&queue, state));
    #####:  435:      state = state->siblings;
        -:  436:    }
        -:  437:  }
        -:  438:
    #####:  439:  return ERROR_SUCCESS;
        -:  440:}
        -:  441:
        -:  442:
        -:  443://
        -:  444:// _yr_ac_find_suitable_transition_table_slot
        -:  445://
        -:  446:// Find a place within the automaton's transition table where the transitions
        -:  447:// for the given state can be put. The function first create a bitmask for the
        -:  448:// state's transition table, then searches for an offset within the automaton's
        -:  449:// bitmask where the state's bitmask can be put without bit collisions.
        -:  450://
        -:  451:
    #####:  452:static int _yr_ac_find_suitable_transition_table_slot(
        -:  453:    YR_AC_AUTOMATON* automaton,
        -:  454:    YR_AC_STATE* state,
        -:  455:    uint32_t* slot)
        -:  456:{
        -:  457:  // The state's transition table has 257 entries, 1 for the failure link and
        -:  458:  // 256 for each possible input byte, so the state's bitmask has 257 bits.
        -:  459:  YR_BITMASK state_bitmask[YR_BITMASK_SIZE(257)];
        -:  460:
    #####:  461:  YR_AC_STATE* child_state = state->first_child;
        -:  462:
        -:  463:  // Start with all bits set to zero.
    #####:  464:  yr_bitmask_clear_all(state_bitmask);
        -:  465:
        -:  466:  // The first slot in the transition table is for the state's failure link,
        -:  467:  // so the first bit in the bitmask must be set to one.
    #####:  468:  yr_bitmask_set(state_bitmask, 0);
        -:  469:
    #####:  470:  while (child_state != NULL)
        -:  471:  {
    #####:  472:    yr_bitmask_set(state_bitmask, child_state->input + 1);
    #####:  473:    child_state = child_state->siblings;
        -:  474:  }
        -:  475:
    #####:  476:  *slot = yr_bitmask_find_non_colliding_offset(
        -:  477:      automaton->bitmask,
        -:  478:      state_bitmask,
        -:  479:      automaton->tables_size,
        -:  480:      257,
        -:  481:      &automaton->t_table_unused_candidate);
        -:  482:
        -:  483:  // Make sure that we are not going beyond the maximum size of the transition
        -:  484:  // table, starting at the slot found there must be at least 257 other slots
        -:  485:  // for accommodating the state's transition table.
    #####:  486:  assert(*slot + 257 < YR_AC_MAX_TRANSITION_TABLE_SIZE);
        -:  487:
    #####:  488:  if (*slot > automaton->tables_size - 257)
        -:  489:  {
    #####:  490:      size_t t_bytes_size = automaton->tables_size *
        -:  491:          sizeof(YR_AC_TRANSITION);
        -:  492:
    #####:  493:      size_t m_bytes_size = automaton->tables_size *
        -:  494:          sizeof(YR_AC_MATCH_TABLE_ENTRY);
        -:  495:
    #####:  496:      size_t b_bytes_size = YR_BITMASK_SIZE(automaton->tables_size) *
        -:  497:           sizeof(YR_BITMASK);
        -:  498:
    #####:  499:      automaton->t_table = (YR_AC_TRANSITION_TABLE) yr_realloc(
    #####:  500:          automaton->t_table, t_bytes_size * 2);
        -:  501:
    #####:  502:      automaton->m_table = (YR_AC_MATCH_TABLE) yr_realloc(
    #####:  503:          automaton->m_table, m_bytes_size * 2);
        -:  504:
    #####:  505:      automaton->bitmask = (YR_BITMASK*) yr_realloc(
    #####:  506:          automaton->bitmask, b_bytes_size * 2);
        -:  507:      
    #####:  508:      if (automaton->t_table == NULL ||
    #####:  509:          automaton->m_table == NULL ||
    #####:  510:          automaton->bitmask == NULL)
        -:  511:      {
    #####:  512:        return ERROR_INSUFFICIENT_MEMORY;
        -:  513:      }
        -:  514:
    #####:  515:      memset((uint8_t*) automaton->t_table + t_bytes_size, 0, t_bytes_size);
    #####:  516:      memset((uint8_t*) automaton->m_table + m_bytes_size, 0, m_bytes_size);
    #####:  517:      memset((uint8_t*) automaton->bitmask + b_bytes_size, 0, b_bytes_size);
        -:  518:
    #####:  519:      automaton->tables_size *= 2;
        -:  520:  }
        -:  521:
    #####:  522:  return ERROR_SUCCESS;
        -:  523:}
        -:  524:
        -:  525://
        -:  526:// _yr_ac_build_transition_table
        -:  527://
        -:  528:// Builds the transition table for the automaton. The transition table (T) is a
        -:  529:// large array of 32-bits integers. Each state in the automaton is represented
        -:  530:// by an index S within the array. The integer stored in T[S] is the failure
        -:  531:// link for state S, it contains the index of the next state when no valid
        -:  532:// transition exists for the next input byte.
        -:  533://
        -:  534:// At position T[S+1+B] (where B is a byte) we can find the transition (if any)
        -:  535:// that must be followed from state S if the next input is B. The value in
        -:  536:// T[S+1+B] contains the index for next state or zero. A zero value means that
        -:  537:// no valid transition exists from state S when next input is B, and the failure
        -:  538:// link must be used instead.
        -:  539://
        -:  540:// The transition table for state S starts at T[S] and spans the next 257
        -:  541:// slots in the array (1 for the failure link and 256 for all the possible
        -:  542:// transitions). But many of those slots are for invalid transitions, so
        -:  543:// the transitions for multiple states can be interleaved as long as they don't
        -:  544:// collide. For example, instead of having this transition table with state S1
        -:  545:// and S2 separated by a large number of slots:
        -:  546://
        -:  547:// S1                                             S2
        -:  548:// +------+------+------+------+--   ~   --+------+------+------+--   ~   --+
        -:  549:// | FLS1 |   X  |   -  |   -  |     -     |  Y   | FLS2 |   Z  |     -     |
        -:  550:// +------+------+------+------+--   ~   --+------+------+------+--   ~   --+
        -:  551://
        -:  552:// We can interleave the transitions for states S1 and S2 and get this other
        -:  553:// transition table, which is more compact:
        -:  554://
        -:  555:// S1            S2
        -:  556:// +------+------+------+------+--   ~   --+------+
        -:  557:// | FLS1 |  X   | FLS2 |   Z  |     -     |  Y   |
        -:  558:// +------+------+------+------+--   ~   --+------+
        -:  559://
        -:  560:// And how do we know that transition Z belongs to state S2 and not S1? Or that
        -:  561:// transition Y belongs to S1 and not S2? Because each slot of the array not
        -:  562:// only contains the index for the state where the transition points to, it
        -:  563:// also contains the offset of the transition relative to its owner state. So,
        -:  564:// the value for the owner offset would be 1 for transitions X, because X
        -:  565:// belongs to state S1 and it's located 1 position away from S1. The same occurs
        -:  566:// for Z, it belongs to S2 and it's located one position away from S2 so its
        -:  567:// owner offset is 1. If we are in S1 and next byte is 2, we are going to read
        -:  568:// the transition at T[S1+1+2] which is Z. But we know that transition Z is not
        -:  569:// a valid transition for state S1 because the owner offset for Z is 1 not 3.
        -:  570://
        -:  571:// Each 32-bit slot in the transition table has 23 bits for storing the index
        -:  572:// of the target state and 9 bits for storing the offset of the slot relative
        -:  573:// to its own state. The offset can be any value from 0 to 256, both inclusive,
        -:  574:// hence 9 bits are required for it. The layout for the slot goes like:
        -:  575://
        -:  576:// 32                      23        0
        -:  577:// +-----------------------+---------+
        -:  578:// | Target state's index  |  Offset |
        -:  579:// +-----------------------+---------+
        -:  580://
        -:  581:// A more detailed description can be found in: http://goo.gl/lE6zG
        -:  582:
        -:  583:
    #####:  584:static int _yr_ac_build_transition_table(
        -:  585:    YR_AC_AUTOMATON* automaton)
        -:  586:{
        -:  587:  YR_AC_STATE* state;
        -:  588:  YR_AC_STATE* child_state;
    #####:  589:  YR_AC_STATE* root_state = automaton->root;
        -:  590:
        -:  591:  uint32_t slot;
        -:  592:
    #####:  593:  QUEUE queue = { NULL, NULL};
        -:  594:
    #####:  595:  automaton->tables_size = 1024;
        -:  596:
    #####:  597:  automaton->t_table = (YR_AC_TRANSITION_TABLE) yr_calloc(
    #####:  598:      automaton->tables_size, sizeof(YR_AC_TRANSITION));
        -:  599:
    #####:  600:  automaton->m_table = (YR_AC_MATCH_TABLE) yr_calloc(
    #####:  601:      automaton->tables_size, sizeof(YR_AC_MATCH_TABLE_ENTRY));
        -:  602:
    #####:  603:  automaton->bitmask = (YR_BITMASK*) yr_calloc(
    #####:  604:      YR_BITMASK_SIZE(automaton->tables_size), sizeof(YR_BITMASK));
        -:  605:
    #####:  606:  if (automaton->t_table == NULL || 
    #####:  607:      automaton->m_table == NULL ||
    #####:  608:      automaton->bitmask == NULL)
        -:  609:  {
    #####:  610:    yr_free(automaton->t_table);
    #####:  611:    yr_free(automaton->m_table);
    #####:  612:    yr_free(automaton->bitmask);
        -:  613:
    #####:  614:    return ERROR_INSUFFICIENT_MEMORY;
        -:  615:  }
        -:  616:
    #####:  617:  automaton->t_table[0] = YR_AC_MAKE_TRANSITION(0, 0);
    #####:  618:  automaton->m_table[0].match = root_state->matches;
        -:  619:
    #####:  620:  yr_bitmask_set(automaton->bitmask, 0);
        -:  621:
        -:  622:  // Index 0 is for root node. Unused indexes start at 1.
    #####:  623:  automaton->t_table_unused_candidate = 1;
        -:  624:
    #####:  625:  child_state = root_state->first_child;
        -:  626:
    #####:  627:  while (child_state != NULL)
        -:  628:  {
    #####:  629:    child_state->t_table_slot = child_state->input + 1;
    #####:  630:    automaton->t_table[child_state->input + 1] = YR_AC_MAKE_TRANSITION(
        -:  631:        0, child_state->input + 1);
        -:  632:
    #####:  633:    yr_bitmask_set(automaton->bitmask, child_state->input + 1);
        -:  634:
    #####:  635:    FAIL_ON_ERROR(_yr_ac_queue_push(&queue, child_state));
    #####:  636:    child_state = child_state->siblings;
        -:  637:  }
        -:  638:
    #####:  639:  while (!_yr_ac_queue_is_empty(&queue))
        -:  640:  {
    #####:  641:    state = _yr_ac_queue_pop(&queue);
        -:  642:
    #####:  643:    FAIL_ON_ERROR(_yr_ac_find_suitable_transition_table_slot(
        -:  644:        automaton, state, &slot));
        -:  645:
    #####:  646:    automaton->t_table[state->t_table_slot] |= (slot << YR_AC_SLOT_OFFSET_BITS);
        -:  647:
    #####:  648:    state->t_table_slot = slot;
        -:  649:
    #####:  650:    automaton->t_table[slot] = YR_AC_MAKE_TRANSITION(
        -:  651:        state->failure->t_table_slot, 0);
        -:  652:
    #####:  653:    yr_bitmask_set(automaton->bitmask, slot);
        -:  654:
    #####:  655:    automaton->m_table[slot].match = state->matches;
        -:  656:
        -:  657:    // Push childrens of current_state
        -:  658:
    #####:  659:    child_state = state->first_child;
        -:  660:
    #####:  661:    while (child_state != NULL)
        -:  662:    {
    #####:  663:      child_state->t_table_slot = slot + child_state->input + 1;
    #####:  664:      automaton->t_table[child_state->t_table_slot] = YR_AC_MAKE_TRANSITION(
        -:  665:          0, child_state->input + 1);
        -:  666:
    #####:  667:      yr_bitmask_set(automaton->bitmask, child_state->t_table_slot);
        -:  668:
    #####:  669:      FAIL_ON_ERROR(_yr_ac_queue_push(&queue, child_state));
        -:  670:
    #####:  671:      child_state = child_state->siblings;
        -:  672:    }
        -:  673:  }
        -:  674:
    #####:  675:  return ERROR_SUCCESS;
        -:  676:}
        -:  677:
        -:  678:
        -:  679://
        -:  680:// _yr_ac_print_automaton_state
        -:  681://
        -:  682:// Prints automaton state for debug purposes. This function is invoked by
        -:  683:// yr_ac_print_automaton, is not intended to be used stand-alone.
        -:  684://
        -:  685:
    #####:  686:static void _yr_ac_print_automaton_state(
        -:  687:    YR_AC_STATE* state)
        -:  688:{
        -:  689:  int i;
        -:  690:  int child_count;
        -:  691:
        -:  692:  YR_AC_MATCH* match;
        -:  693:  YR_AC_STATE* child_state;
        -:  694:
    #####:  695:  for (i = 0; i < state->depth; i++)
    #####:  696:    printf(" ");
        -:  697:
    #####:  698:  child_state = state->first_child;
    #####:  699:  child_count = 0;
        -:  700:
    #####:  701:  while(child_state != NULL)
        -:  702:  {
    #####:  703:    child_count++;
    #####:  704:    child_state = child_state->siblings;
        -:  705:  }
        -:  706:
    #####:  707:  printf("%p childs:%d depth:%d failure:%p",
    #####:  708:         state, child_count, state->depth, state->failure);
        -:  709:
    #####:  710:  match = state->matches;
        -:  711:
    #####:  712:  while (match != NULL)
        -:  713:  {
    #####:  714:    printf("\n");
        -:  715:
    #####:  716:    for (i = 0; i < state->depth + 1; i++)
    #####:  717:      printf(" ");
        -:  718:
    #####:  719:    printf("%s = ", match->string->identifier);
        -:  720:
    #####:  721:    if (STRING_IS_HEX(match->string))
        -:  722:    {
    #####:  723:      printf("{ ");
        -:  724:
    #####:  725:      for (i = 0; i < yr_min(match->string->length, 10); i++)
    #####:  726:        printf("%02x ", match->string->string[i]);
        -:  727:
    #####:  728:      printf("}");
        -:  729:    }
    #####:  730:    else if (STRING_IS_REGEXP(match->string))
        -:  731:    {
    #####:  732:      printf("/");
        -:  733:
    #####:  734:      for (i = 0; i < yr_min(match->string->length, 10); i++)
    #####:  735:        printf("%c", match->string->string[i]);
        -:  736:
    #####:  737:      printf("/");
        -:  738:    }
        -:  739:    else
        -:  740:    {
    #####:  741:      printf("\"");
        -:  742:
    #####:  743:      for (i = 0; i < yr_min(match->string->length, 10); i++)
    #####:  744:        printf("%c", match->string->string[i]);
        -:  745:
    #####:  746:      printf("\"");
        -:  747:    }
        -:  748:
    #####:  749:    match = match->next;
        -:  750:  }
        -:  751:
    #####:  752:  printf("\n");
        -:  753:
    #####:  754:  child_state = state->first_child;
        -:  755:
    #####:  756:  while(child_state != NULL)
        -:  757:  {
    #####:  758:    _yr_ac_print_automaton_state(child_state);
    #####:  759:    child_state = child_state->siblings;
        -:  760:  }
    #####:  761:}
        -:  762:
        -:  763:
        -:  764://
        -:  765:// yr_ac_automaton_create
        -:  766://
        -:  767:// Creates a new automaton
        -:  768://
        -:  769:
        1:  770:int yr_ac_automaton_create(
        -:  771:    YR_AC_AUTOMATON** automaton)
        -:  772:{
        -:  773:  YR_AC_AUTOMATON* new_automaton;
        -:  774:  YR_AC_STATE* root_state;
        -:  775:
        1:  776:  new_automaton = (YR_AC_AUTOMATON*) yr_malloc(sizeof(YR_AC_AUTOMATON));
        1:  777:  root_state = (YR_AC_STATE*) yr_malloc(sizeof(YR_AC_STATE));
        -:  778:
        1:  779:  if (new_automaton == NULL || root_state == NULL)
        -:  780:  {
    #####:  781:    yr_free(new_automaton);
    #####:  782:    yr_free(root_state);
        -:  783:
    #####:  784:    return ERROR_INSUFFICIENT_MEMORY;
        -:  785:  }
        -:  786:
        1:  787:  root_state->depth = 0;
        1:  788:  root_state->matches = NULL;
        1:  789:  root_state->failure = NULL;
        1:  790:  root_state->first_child = NULL;
        1:  791:  root_state->siblings = NULL;
        1:  792:  root_state->t_table_slot = 0;
        -:  793:
        1:  794:  new_automaton->root = root_state;
        1:  795:  new_automaton->m_table = NULL;
        1:  796:  new_automaton->t_table = NULL;
        1:  797:  new_automaton->bitmask = NULL;
        1:  798:  new_automaton->tables_size = 0;
        -:  799:
        1:  800:  *automaton = new_automaton;
        -:  801:
        1:  802:  return ERROR_SUCCESS;
        -:  803:}
        -:  804:
        -:  805:
        -:  806://
        -:  807:// yr_ac_automaton_destroy
        -:  808://
        -:  809:// Destroys automaton
        -:  810://
        -:  811:
        1:  812:int yr_ac_automaton_destroy(
        -:  813:    YR_AC_AUTOMATON* automaton)
        -:  814:{
        1:  815:  _yr_ac_state_destroy(automaton->root);
        -:  816:
        1:  817:  yr_free(automaton->t_table);
        1:  818:  yr_free(automaton->m_table);
        1:  819:  yr_free(automaton->bitmask);
        1:  820:  yr_free(automaton);
        -:  821:
        1:  822:  return ERROR_SUCCESS;
        -:  823:}
        -:  824:
        -:  825:
        -:  826://
        -:  827:// yr_ac_add_string
        -:  828://
        -:  829:// Adds a string to the automaton. This function is invoked once for each
        -:  830:// string defined in the rules.
        -:  831://
        -:  832:
    #####:  833:int yr_ac_add_string(
        -:  834:    YR_AC_AUTOMATON* automaton,
        -:  835:    YR_STRING* string,
        -:  836:    YR_ATOM_LIST_ITEM* atom,
        -:  837:    YR_ARENA* matches_arena)
        -:  838:{
    #####:  839:  int result = ERROR_SUCCESS;
        -:  840:  int i;
        -:  841:
        -:  842:  YR_AC_STATE* state;
        -:  843:  YR_AC_STATE* next_state;
        -:  844:  YR_AC_MATCH* new_match;
        -:  845:
        -:  846:  // For each atom create the states in the automaton.
        -:  847:
    #####:  848:  while (atom != NULL)
        -:  849:  {
    #####:  850:    state = automaton->root;
        -:  851:
    #####:  852:    for (i = 0; i < atom->atom_length; i++)
        -:  853:    {
    #####:  854:      next_state = _yr_ac_next_state(state, atom->atom[i]);
        -:  855:
    #####:  856:      if (next_state == NULL)
        -:  857:      {
    #####:  858:        next_state = _yr_ac_state_create(state, atom->atom[i]);
        -:  859:
    #####:  860:        if (next_state == NULL)
    #####:  861:          return ERROR_INSUFFICIENT_MEMORY;
        -:  862:      }
        -:  863:
    #####:  864:      state = next_state;
        -:  865:    }
        -:  866:
    #####:  867:    result = yr_arena_allocate_struct(
        -:  868:        matches_arena,
        -:  869:        sizeof(YR_AC_MATCH),
        -:  870:        (void**) &new_match,
        -:  871:        offsetof(YR_AC_MATCH, string),
        -:  872:        offsetof(YR_AC_MATCH, forward_code),
        -:  873:        offsetof(YR_AC_MATCH, backward_code),
        -:  874:        offsetof(YR_AC_MATCH, next),
        -:  875:        EOL);
        -:  876:
    #####:  877:    if (result == ERROR_SUCCESS)
        -:  878:    {
    #####:  879:      new_match->backtrack = state->depth + atom->backtrack;
    #####:  880:      new_match->string = string;
    #####:  881:      new_match->forward_code = atom->forward_code;
    #####:  882:      new_match->backward_code = atom->backward_code;
    #####:  883:      new_match->next = state->matches;
    #####:  884:      state->matches = new_match;
        -:  885:    }
        -:  886:    else
        -:  887:    {
    #####:  888:      break;
        -:  889:    }
        -:  890:
    #####:  891:    atom = atom->next;
        -:  892:  }
        -:  893:
    #####:  894:  return result;
        -:  895:}
        -:  896:
        -:  897:
        -:  898://
        -:  899:// yr_ac_compile
        -:  900://
        -:  901:
    #####:  902:int yr_ac_compile(
        -:  903:    YR_AC_AUTOMATON* automaton,
        -:  904:    YR_ARENA* arena,
        -:  905:    YR_AC_TABLES* tables)
        -:  906:{
        -:  907:  uint32_t i;
        -:  908:
    #####:  909:  FAIL_ON_ERROR(_yr_ac_create_failure_links(automaton));
    #####:  910:  FAIL_ON_ERROR(_yr_ac_optimize_failure_links(automaton));
    #####:  911:  FAIL_ON_ERROR(_yr_ac_build_transition_table(automaton));
        -:  912:
    #####:  913:  FAIL_ON_ERROR(yr_arena_reserve_memory(
        -:  914:      arena,
        -:  915:      automaton->tables_size * sizeof(tables->transitions[0]) +
        -:  916:      automaton->tables_size * sizeof(tables->matches[0])));
        -:  917:
    #####:  918:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  919:      arena,
        -:  920:      automaton->t_table,
        -:  921:      sizeof(YR_AC_TRANSITION),
        -:  922:      (void**) &tables->transitions));
        -:  923:
    #####:  924:  for (i = 1; i < automaton->tables_size; i++)
        -:  925:  {
    #####:  926:    FAIL_ON_ERROR(yr_arena_write_data(
        -:  927:        arena,
        -:  928:        automaton->t_table + i,
        -:  929:        sizeof(YR_AC_TRANSITION),
        -:  930:        NULL));
        -:  931:  }
        -:  932:
    #####:  933:  FAIL_ON_ERROR(yr_arena_write_data(
        -:  934:      arena,
        -:  935:      automaton->m_table,
        -:  936:      sizeof(YR_AC_MATCH_TABLE_ENTRY),
        -:  937:      (void**) &tables->matches));
        -:  938:
    #####:  939:  FAIL_ON_ERROR(yr_arena_make_ptr_relocatable(
        -:  940:      arena,
        -:  941:      tables->matches,
        -:  942:      offsetof(YR_AC_MATCH_TABLE_ENTRY, match),
        -:  943:      EOL));
        -:  944:
    #####:  945:  for (i = 1; i < automaton->tables_size; i++)
        -:  946:  {
        -:  947:    void* ptr;
        -:  948:
    #####:  949:    FAIL_ON_ERROR(yr_arena_write_data(
        -:  950:        arena,
        -:  951:        automaton->m_table + i,
        -:  952:        sizeof(YR_AC_MATCH_TABLE_ENTRY),
        -:  953:        (void**) &ptr));
        -:  954:
    #####:  955:    FAIL_ON_ERROR(yr_arena_make_ptr_relocatable(
        -:  956:        arena,
        -:  957:        ptr,
        -:  958:        offsetof(YR_AC_MATCH_TABLE_ENTRY, match),
        -:  959:        EOL));
        -:  960:  }
        -:  961:
    #####:  962:  return ERROR_SUCCESS;
        -:  963:}
        -:  964:
        -:  965:
        -:  966://
        -:  967:// yr_ac_print_automaton
        -:  968://
        -:  969:// Prints automaton for debug purposes.
        -:  970://
        -:  971:
    #####:  972:void yr_ac_print_automaton(YR_AC_AUTOMATON* automaton)
        -:  973:{
    #####:  974:  printf("-------------------------------------------------------\n");
    #####:  975:  _yr_ac_print_automaton_state(automaton->root);
    #####:  976:  printf("-------------------------------------------------------\n");
    #####:  977:}
