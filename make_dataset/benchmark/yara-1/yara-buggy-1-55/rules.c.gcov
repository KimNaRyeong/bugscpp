        -:    0:Source:rules.c
        -:    0:Graph:/home/workspace/libyara/rules.gcno
        -:    0:Data:/home/workspace/libyara/rules.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <assert.h>
        -:   31:#include <string.h>
        -:   32:#include <ctype.h>
        -:   33:
        -:   34:#include <yara/error.h>
        -:   35:#include <yara/filemap.h>
        -:   36:#include <yara/mem.h>
        -:   37:#include <yara/proc.h>
        -:   38:#include <yara/rules.h>
        -:   39:#include <yara/utils.h>
        -:   40:#include <yara/globals.h>
        -:   41:#include <yara/scan.h>
        -:   42:#include <yara/scanner.h>
        -:   43:
        -:   44:
    #####:   45:YR_API int yr_rules_define_integer_variable(
        -:   46:    YR_RULES* rules,
        -:   47:    const char* identifier,
        -:   48:    int64_t value)
        -:   49:{
        -:   50:  YR_EXTERNAL_VARIABLE* external;
        -:   51:
    #####:   52:  external = rules->externals_list_head;
        -:   53:
    #####:   54:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:   55:  {
    #####:   56:    if (strcmp(external->identifier, identifier) == 0)
        -:   57:    {
    #####:   58:      if (external->type != EXTERNAL_VARIABLE_TYPE_INTEGER)
    #####:   59:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:   60:
    #####:   61:      external->value.i = value;
    #####:   62:      return ERROR_SUCCESS;
        -:   63:    }
        -:   64:
    #####:   65:    external++;
        -:   66:  }
        -:   67:
    #####:   68:  return ERROR_INVALID_ARGUMENT;
        -:   69:}
        -:   70:
        -:   71:
    #####:   72:YR_API int yr_rules_define_boolean_variable(
        -:   73:    YR_RULES* rules,
        -:   74:    const char* identifier,
        -:   75:    int value)
        -:   76:{
        -:   77:  YR_EXTERNAL_VARIABLE* external;
        -:   78:
    #####:   79:  external = rules->externals_list_head;
        -:   80:
    #####:   81:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:   82:  {
    #####:   83:    if (strcmp(external->identifier, identifier) == 0)
        -:   84:    {
    #####:   85:      if (external->type != EXTERNAL_VARIABLE_TYPE_BOOLEAN)
    #####:   86:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:   87:
    #####:   88:      external->value.i = value;
    #####:   89:      return ERROR_SUCCESS;
        -:   90:    }
        -:   91:
    #####:   92:    external++;
        -:   93:  }
        -:   94:
    #####:   95:  return ERROR_INVALID_ARGUMENT;
        -:   96:}
        -:   97:
        -:   98:
    #####:   99:YR_API int yr_rules_define_float_variable(
        -:  100:    YR_RULES* rules,
        -:  101:    const char* identifier,
        -:  102:    double value)
        -:  103:{
        -:  104:  YR_EXTERNAL_VARIABLE* external;
        -:  105:
    #####:  106:  external = rules->externals_list_head;
        -:  107:
    #####:  108:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  109:  {
    #####:  110:    if (strcmp(external->identifier, identifier) == 0)
        -:  111:    {
    #####:  112:      if (external->type != EXTERNAL_VARIABLE_TYPE_FLOAT)
    #####:  113:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  114:
    #####:  115:      external->value.f = value;
    #####:  116:      return ERROR_SUCCESS;
        -:  117:    }
        -:  118:
    #####:  119:    external++;
        -:  120:  }
        -:  121:
    #####:  122:  return ERROR_INVALID_ARGUMENT;
        -:  123:}
        -:  124:
        -:  125:
    #####:  126:YR_API int yr_rules_define_string_variable(
        -:  127:    YR_RULES* rules,
        -:  128:    const char* identifier,
        -:  129:    const char* value)
        -:  130:{
        -:  131:  YR_EXTERNAL_VARIABLE* external;
        -:  132:
    #####:  133:  external = rules->externals_list_head;
        -:  134:
    #####:  135:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  136:  {
    #####:  137:    if (strcmp(external->identifier, identifier) == 0)
        -:  138:    {
    #####:  139:      if (external->type != EXTERNAL_VARIABLE_TYPE_STRING &&
    #####:  140:          external->type != EXTERNAL_VARIABLE_TYPE_MALLOC_STRING)
    #####:  141:        return ERROR_INVALID_EXTERNAL_VARIABLE_TYPE;
        -:  142:
    #####:  143:      if (external->type == EXTERNAL_VARIABLE_TYPE_MALLOC_STRING &&
    #####:  144:          external->value.s != NULL)
        -:  145:      {
    #####:  146:        yr_free(external->value.s);
        -:  147:      }
        -:  148:
    #####:  149:      external->type = EXTERNAL_VARIABLE_TYPE_MALLOC_STRING;
    #####:  150:      external->value.s = yr_strdup(value);
        -:  151:
    #####:  152:      if (external->value.s == NULL)
    #####:  153:        return ERROR_INSUFFICIENT_MEMORY;
        -:  154:      else
    #####:  155:        return ERROR_SUCCESS;
        -:  156:    }
        -:  157:
    #####:  158:    external++;
        -:  159:  }
        -:  160:
    #####:  161:  return ERROR_INVALID_ARGUMENT;
        -:  162:}
        -:  163:
        -:  164:
        -:  165:#ifdef PROFILING_ENABLED
        -:  166:void yr_rules_print_profiling_info(
        -:  167:    YR_RULES* rules)
        -:  168:{
        -:  169:  YR_RULE* rule;
        -:  170:
        -:  171:  printf("\n===== PROFILING INFORMATION =====\n\n");
        -:  172:
        -:  173:  yr_rules_foreach(rules, rule)
        -:  174:  {
        -:  175:    printf(
        -:  176:        "%s:%s: %" PRIu64 " (%0.3f%%)\n",
        -:  177:        rule->ns->name,
        -:  178:        rule->identifier,
        -:  179:        rule->time_cost,
        -:  180:        (float) rule->time_cost / rules->time_cost * 100);
        -:  181:  }
        -:  182:
        -:  183:  printf("\n=================================\n");
        -:  184:}
        -:  185:#endif
        -:  186:
        -:  187:
    #####:  188:YR_API int yr_rules_scan_mem_blocks(
        -:  189:    YR_RULES* rules,
        -:  190:    YR_MEMORY_BLOCK_ITERATOR* iterator,
        -:  191:    int flags,
        -:  192:    YR_CALLBACK_FUNC callback,
        -:  193:    void* user_data,
        -:  194:    int timeout)
        -:  195:{
        -:  196:  YR_SCANNER* scanner;
        -:  197:  int result;
        -:  198:
    #####:  199:  FAIL_ON_ERROR(yr_scanner_create(rules, &scanner));
        -:  200:
    #####:  201:  yr_scanner_set_callback(scanner, callback, user_data);
    #####:  202:  yr_scanner_set_timeout(scanner, timeout);
    #####:  203:  yr_scanner_set_flags(scanner, flags);
        -:  204:
    #####:  205:  result = yr_scanner_scan_mem_blocks(scanner, iterator);
        -:  206:
    #####:  207:  yr_scanner_destroy(scanner);
        -:  208:
    #####:  209:  return result;
        -:  210:}
        -:  211:
        -:  212:
    #####:  213:static YR_MEMORY_BLOCK* _yr_get_first_block(
        -:  214:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  215:{
    #####:  216:  return (YR_MEMORY_BLOCK*) iterator->context;
        -:  217:}
        -:  218:
        -:  219:
    #####:  220:static YR_MEMORY_BLOCK* _yr_get_next_block(
        -:  221:    YR_MEMORY_BLOCK_ITERATOR* iterator)
        -:  222:{
    #####:  223:  return NULL;
        -:  224:}
        -:  225:
        -:  226:
    #####:  227:static const uint8_t* _yr_fetch_block_data(
        -:  228:    YR_MEMORY_BLOCK* block)
        -:  229:{
    #####:  230:  return (const uint8_t*) block->context;
        -:  231:}
        -:  232:
        -:  233:
    #####:  234:YR_API int yr_rules_scan_mem(
        -:  235:    YR_RULES* rules,
        -:  236:    const uint8_t* buffer,
        -:  237:    size_t buffer_size,
        -:  238:    int flags,
        -:  239:    YR_CALLBACK_FUNC callback,
        -:  240:    void* user_data,
        -:  241:    int timeout)
        -:  242:{
        -:  243:  YR_MEMORY_BLOCK block;
        -:  244:  YR_MEMORY_BLOCK_ITERATOR iterator;
        -:  245:
    #####:  246:  block.size = buffer_size;
    #####:  247:  block.base = 0;
    #####:  248:  block.fetch_data = _yr_fetch_block_data;
    #####:  249:  block.context = (void*) buffer;
        -:  250:
    #####:  251:  iterator.context = &block;
    #####:  252:  iterator.first = _yr_get_first_block;
    #####:  253:  iterator.next = _yr_get_next_block;
        -:  254:
    #####:  255:  return yr_rules_scan_mem_blocks(
        -:  256:      rules,
        -:  257:      &iterator,
        -:  258:      flags,
        -:  259:      callback,
        -:  260:      user_data,
        -:  261:      timeout);
        -:  262:}
        -:  263:
        -:  264:
    #####:  265:YR_API int yr_rules_scan_file(
        -:  266:    YR_RULES* rules,
        -:  267:    const char* filename,
        -:  268:    int flags,
        -:  269:    YR_CALLBACK_FUNC callback,
        -:  270:    void* user_data,
        -:  271:    int timeout)
        -:  272:{
        -:  273:  YR_MAPPED_FILE mfile;
        -:  274:
    #####:  275:  int result = yr_filemap_map(filename, &mfile);
        -:  276:
    #####:  277:  if (result == ERROR_SUCCESS)
        -:  278:  {
    #####:  279:    result = yr_rules_scan_mem(
        -:  280:        rules,
        -:  281:        mfile.data,
        -:  282:        mfile.size,
        -:  283:        flags,
        -:  284:        callback,
        -:  285:        user_data,
        -:  286:        timeout);
        -:  287:
    #####:  288:    yr_filemap_unmap(&mfile);
        -:  289:  }
        -:  290:
    #####:  291:  return result;
        -:  292:}
        -:  293:
        -:  294:
    #####:  295:YR_API int yr_rules_scan_fd(
        -:  296:    YR_RULES* rules,
        -:  297:    YR_FILE_DESCRIPTOR fd,
        -:  298:    int flags,
        -:  299:    YR_CALLBACK_FUNC callback,
        -:  300:    void* user_data,
        -:  301:    int timeout)
        -:  302:{
        -:  303:  YR_MAPPED_FILE mfile;
        -:  304:
    #####:  305:  int result = yr_filemap_map_fd(fd, 0, 0, &mfile);
        -:  306:
    #####:  307:  if (result == ERROR_SUCCESS)
        -:  308:  {
    #####:  309:    result = yr_rules_scan_mem(
        -:  310:        rules,
        -:  311:        mfile.data,
        -:  312:        mfile.size,
        -:  313:        flags,
        -:  314:        callback,
        -:  315:        user_data,
        -:  316:        timeout);
        -:  317:
    #####:  318:    yr_filemap_unmap_fd(&mfile);
        -:  319:  }
        -:  320:
    #####:  321:  return result;
        -:  322:}
        -:  323:
        -:  324:
    #####:  325:YR_API int yr_rules_scan_proc(
        -:  326:    YR_RULES* rules,
        -:  327:    int pid,
        -:  328:    int flags,
        -:  329:    YR_CALLBACK_FUNC callback,
        -:  330:    void* user_data,
        -:  331:    int timeout)
        -:  332:{
        -:  333:  YR_MEMORY_BLOCK_ITERATOR iterator;
        -:  334:
    #####:  335:  int result = yr_process_open_iterator(
        -:  336:      pid,
        -:  337:      &iterator);
        -:  338:
    #####:  339:  if (result == ERROR_SUCCESS)
        -:  340:  {
    #####:  341:    result = yr_rules_scan_mem_blocks(
        -:  342:        rules,
        -:  343:        &iterator,
        -:  344:        flags | SCAN_FLAGS_PROCESS_MEMORY,
        -:  345:        callback,
        -:  346:        user_data,
        -:  347:        timeout);
        -:  348:
    #####:  349:    yr_process_close_iterator(&iterator);
        -:  350:  }
        -:  351:
    #####:  352:  return result;
        -:  353:}
        -:  354:
        -:  355:
    #####:  356:YR_API int yr_rules_load_stream(
        -:  357:    YR_STREAM* stream,
        -:  358:    YR_RULES** rules)
        -:  359:{
        -:  360:  YARA_RULES_FILE_HEADER* header;
    #####:  361:  YR_RULES* new_rules = (YR_RULES*) yr_malloc(sizeof(YR_RULES));
        -:  362:
    #####:  363:  if (new_rules == NULL)
    #####:  364:    return ERROR_INSUFFICIENT_MEMORY;
        -:  365:
    #####:  366:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  367:      yr_arena_load_stream(stream, &new_rules->arena),
        -:  368:      // cleanup
        -:  369:      yr_free(new_rules));
        -:  370:
        -:  371:  header = (YARA_RULES_FILE_HEADER*)
    #####:  372:      yr_arena_base_address(new_rules->arena);
        -:  373:
    #####:  374:  new_rules->code_start = header->code_start;
    #####:  375:  new_rules->externals_list_head = header->externals_list_head;
    #####:  376:  new_rules->rules_list_head = header->rules_list_head;
    #####:  377:  new_rules->ac_match_table = header->ac_match_table;
    #####:  378:  new_rules->ac_transition_table = header->ac_transition_table;
    #####:  379:  new_rules->ac_tables_size = header->ac_tables_size;
        -:  380:
    #####:  381:  memset(new_rules->tidx_mask, 0, sizeof(new_rules->tidx_mask));
        -:  382:
    #####:  383:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  384:      yr_mutex_create(&new_rules->mutex),
        -:  385:      // cleanup
        -:  386:      yr_free(new_rules));
        -:  387:
    #####:  388:  *rules = new_rules;
        -:  389:
    #####:  390:  return ERROR_SUCCESS;
        -:  391:}
        -:  392:
        -:  393:
    #####:  394:YR_API int yr_rules_load(
        -:  395:    const char* filename,
        -:  396:    YR_RULES** rules)
        -:  397:{
        -:  398:  int result;
        -:  399:
        -:  400:  YR_STREAM stream;
    #####:  401:  FILE* fh = fopen(filename, "rb");
        -:  402:
    #####:  403:  if (fh == NULL)
    #####:  404:    return ERROR_COULD_NOT_OPEN_FILE;
        -:  405:
    #####:  406:  stream.user_data = fh;
    #####:  407:  stream.read = (YR_STREAM_READ_FUNC) fread;
        -:  408:
    #####:  409:  result = yr_rules_load_stream(&stream, rules);
        -:  410:
    #####:  411:  fclose(fh);
    #####:  412:  return result;
        -:  413:}
        -:  414:
        -:  415:
    #####:  416:YR_API int yr_rules_save_stream(
        -:  417:    YR_RULES* rules,
        -:  418:    YR_STREAM* stream)
        -:  419:{
        -:  420:  int i;
        -:  421:
    #####:  422:  for (i = 0; i < YR_BITARRAY_NCHARS(YR_MAX_THREADS); ++i)
    #####:  423:    assert(rules->tidx_mask[i] == 0);
        -:  424:
    #####:  425:  return yr_arena_save_stream(rules->arena, stream);
        -:  426:}
        -:  427:
        -:  428:
    #####:  429:YR_API int yr_rules_save(
        -:  430:    YR_RULES* rules,
        -:  431:    const char* filename)
        -:  432:{
        -:  433:  int result;
        -:  434:
        -:  435:  YR_STREAM stream;
    #####:  436:  FILE* fh = fopen(filename, "wb");
        -:  437:
    #####:  438:  if (fh == NULL)
    #####:  439:    return ERROR_COULD_NOT_OPEN_FILE;
        -:  440:
    #####:  441:  stream.user_data = fh;
    #####:  442:  stream.write = (YR_STREAM_WRITE_FUNC) fwrite;
        -:  443:
    #####:  444:  result = yr_rules_save_stream(rules, &stream);
        -:  445:
    #####:  446:  fclose(fh);
    #####:  447:  return result;
        -:  448:}
        -:  449:
        -:  450:
    #####:  451:static int _uint32_cmp (
        -:  452:    const void * a,
        -:  453:    const void * b)
        -:  454:{
    #####:  455:   return (*(uint32_t*) a - *(uint32_t*) b);
        -:  456:}
        -:  457:
    #####:  458:YR_API int yr_rules_get_stats(
        -:  459:    YR_RULES* rules,
        -:  460:    YR_RULES_STATS *stats)
        -:  461:{
        -:  462:  YR_RULE* rule;
        -:  463:  YR_STRING* string;
        -:  464:
    #####:  465:  uint32_t* match_list_lengths = (uint32_t*) yr_malloc(
    #####:  466:      sizeof(uint32_t) * rules->ac_tables_size);
        -:  467:
    #####:  468:  float match_list_length_sum = 0;
    #####:  469:  int c = 0;
        -:  470:
    #####:  471:  if (match_list_lengths == NULL)
    #####:  472:    return ERROR_INSUFFICIENT_MEMORY;
        -:  473:
    #####:  474:  stats->ac_tables_size = rules->ac_tables_size;
    #####:  475:  stats->ac_matches = 0;
    #####:  476:  stats->rules = 0;
    #####:  477:  stats->strings = 0;
        -:  478:
    #####:  479:  for (int i = 0; i < rules->ac_tables_size; i++)
        -:  480:  {
    #####:  481:    YR_AC_MATCH* match = rules->ac_match_table[i].match;
        -:  482:
    #####:  483:    int match_list_length = 0;
        -:  484:
    #####:  485:    while (match != NULL)
        -:  486:    {
    #####:  487:      match_list_length++;
    #####:  488:      stats->ac_matches++;
    #####:  489:      match = match->next;
        -:  490:    }
        -:  491:
    #####:  492:    if (i == 0)
    #####:  493:      stats->ac_root_match_list_length = match_list_length;
        -:  494:
    #####:  495:    match_list_length_sum += match_list_length;
        -:  496:
    #####:  497:    if (match_list_length > 0)
        -:  498:    {
    #####:  499:      match_list_lengths[c] = match_list_length;
    #####:  500:      c++;
        -:  501:    }
        -:  502:  }
        -:  503:
        -:  504:  // sort match_list_lengths in increasing order for computing percentiles.
    #####:  505:  qsort(match_list_lengths, c, sizeof(match_list_lengths[0]), _uint32_cmp);
        -:  506:
    #####:  507:  for (int i = 0; i < 100; i++)
        -:  508:  {
    #####:  509:    if (i < c)
    #####:  510:      stats->top_ac_match_list_lengths[i] = match_list_lengths[c-i-1];
        -:  511:    else
    #####:  512:      stats->top_ac_match_list_lengths[i] = 0;
        -:  513:  }
        -:  514:
    #####:  515:  stats->ac_average_match_list_length = match_list_length_sum / c;
    #####:  516:  stats->ac_match_list_length_pctls[0] = match_list_lengths[0];
    #####:  517:  stats->ac_match_list_length_pctls[100] = match_list_lengths[c-1];
        -:  518:
    #####:  519:  for (int i = 1; i < 100; i++)
    #####:  520:    stats->ac_match_list_length_pctls[i] = match_list_lengths[(c * i) / 100];
        -:  521:
    #####:  522:  yr_free(match_list_lengths);
        -:  523:
    #####:  524:  yr_rules_foreach(rules, rule)
        -:  525:  {
    #####:  526:    stats->rules++;
    #####:  527:    yr_rule_strings_foreach(rule, string)
    #####:  528:      stats->strings++;
        -:  529:  }
        -:  530:
    #####:  531:  return ERROR_SUCCESS;
        -:  532:}
        -:  533:
        -:  534:
    #####:  535:YR_API int yr_rules_destroy(
        -:  536:    YR_RULES* rules)
        -:  537:{
    #####:  538:  YR_EXTERNAL_VARIABLE* external = rules->externals_list_head;
        -:  539:
    #####:  540:  while (!EXTERNAL_VARIABLE_IS_NULL(external))
        -:  541:  {
    #####:  542:    if (external->type == EXTERNAL_VARIABLE_TYPE_MALLOC_STRING)
    #####:  543:      yr_free(external->value.s);
        -:  544:
    #####:  545:    external++;
        -:  546:  }
        -:  547:
    #####:  548:  yr_mutex_destroy(&rules->mutex);
    #####:  549:  yr_arena_destroy(rules->arena);
    #####:  550:  yr_free(rules);
        -:  551:
    #####:  552:  return ERROR_SUCCESS;
        -:  553:}
        -:  554:
    #####:  555:YR_API void yr_rule_disable(
        -:  556:    YR_RULE* rule)
        -:  557:{
        -:  558:  YR_STRING* string;
        -:  559:
    #####:  560:  rule->g_flags |= RULE_GFLAGS_DISABLED;
        -:  561:
    #####:  562:  yr_rule_strings_foreach(rule, string)
        -:  563:  {
    #####:  564:    string->g_flags |= STRING_GFLAGS_DISABLED;
        -:  565:  }
    #####:  566:}
        -:  567:
        -:  568:
    #####:  569:YR_API void yr_rule_enable(
        -:  570:    YR_RULE* rule)
        -:  571:{
        -:  572:  YR_STRING* string;
        -:  573:
    #####:  574:  rule->g_flags &= ~RULE_GFLAGS_DISABLED;
        -:  575:
    #####:  576:  yr_rule_strings_foreach(rule, string)
        -:  577:  {
    #####:  578:    string->g_flags &= ~STRING_GFLAGS_DISABLED;
        -:  579:  }
    #####:  580:}
