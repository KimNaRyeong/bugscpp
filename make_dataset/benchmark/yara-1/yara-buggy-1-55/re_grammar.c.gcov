        -:    0:Source:re_grammar.c
        -:    0:Graph:/home/workspace/libyara/re_grammar.gcno
        -:    0:Data:/home/workspace/libyara/re_grammar.gcda
        -:    0:Runs:6
        -:    1:/* A Bison parser, made by GNU Bison 3.5.1.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
        -:    6:   Inc.
        -:    7:
        -:    8:   This program is free software: you can redistribute it and/or modify
        -:    9:   it under the terms of the GNU General Public License as published by
        -:   10:   the Free Software Foundation, either version 3 of the License, or
        -:   11:   (at your option) any later version.
        -:   12:
        -:   13:   This program is distributed in the hope that it will be useful,
        -:   14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:   GNU General Public License for more details.
        -:   17:
        -:   18:   You should have received a copy of the GNU General Public License
        -:   19:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   20:
        -:   21:/* As a special exception, you may create a larger work that contains
        -:   22:   part or all of the Bison parser skeleton and distribute that work
        -:   23:   under terms of your choice, so long as that work isn't itself a
        -:   24:   parser generator using the skeleton or a modified version thereof
        -:   25:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   26:   the parser skeleton itself, you may (at your option) remove this
        -:   27:   special exception, which will cause the skeleton and the resulting
        -:   28:   Bison output files to be licensed under the GNU General Public
        -:   29:   License without this special exception.
        -:   30:
        -:   31:   This special exception was added by the Free Software Foundation in
        -:   32:   version 2.2 of Bison.  */
        -:   33:
        -:   34:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   35:   simplifying the original so-called "semantic" parser.  */
        -:   36:
        -:   37:/* All symbols defined below should begin with yy or YY, to avoid
        -:   38:   infringing on user name space.  This should be done even for local
        -:   39:   variables, as they might otherwise be expanded by user macros.
        -:   40:   There are some unavoidable exceptions within include files to
        -:   41:   define necessary library symbols; they are noted "INFRINGES ON
        -:   42:   USER NAME SPACE" below.  */
        -:   43:
        -:   44:/* Undocumented macros, especially those whose name start with YY_,
        -:   45:   are private implementation details.  Do not rely on them.  */
        -:   46:
        -:   47:/* Identify Bison output.  */
        -:   48:#define YYBISON 1
        -:   49:
        -:   50:/* Bison version.  */
        -:   51:#define YYBISON_VERSION "3.5.1"
        -:   52:
        -:   53:/* Skeleton name.  */
        -:   54:#define YYSKELETON_NAME "yacc.c"
        -:   55:
        -:   56:/* Pure parsers.  */
        -:   57:#define YYPURE 1
        -:   58:
        -:   59:/* Push parsers.  */
        -:   60:#define YYPUSH 0
        -:   61:
        -:   62:/* Pull parsers.  */
        -:   63:#define YYPULL 1
        -:   64:
        -:   65:
        -:   66:/* Substitute the variable and function names.  */
        -:   67:#define yyparse         re_yyparse
        -:   68:#define yylex           re_yylex
        -:   69:#define yyerror         re_yyerror
        -:   70:#define yydebug         re_yydebug
        -:   71:#define yynerrs         re_yynerrs
        -:   72:
        -:   73:/* First part of user prologue.  */
        -:   74:#line 30 "re_grammar.y"
        -:   75:
        -:   76:
        -:   77:#include <stdbool.h>
        -:   78:
        -:   79:#include <yara/integers.h>
        -:   80:#include <yara/utils.h>
        -:   81:#include <yara/error.h>
        -:   82:#include <yara/limits.h>
        -:   83:#include <yara/mem.h>
        -:   84:#include <yara/re.h>
        -:   85:#include <yara/re_lexer.h>
        -:   86:
        -:   87:
        -:   88:#define YYERROR_VERBOSE
        -:   89:
        -:   90:#define YYMALLOC yr_malloc
        -:   91:#define YYFREE yr_free
        -:   92:
        -:   93:#define mark_as_not_fast_regexp() \
        -:   94:    ((RE_AST*) yyget_extra(yyscanner))->flags &= ~RE_FLAGS_FAST_REGEXP
        -:   95:
        -:   96:#define fail_if_too_many_ast_levels(cleanup_code) \
        -:   97:    if (((RE_AST*) yyget_extra(yyscanner))->levels++ > RE_MAX_AST_LEVELS) \
        -:   98:    { \
        -:   99:      { cleanup_code } \
        -:  100:      yyerror(yyscanner, lex_env, "regexp too long"); \
        -:  101:      YYABORT; \
        -:  102:    }
        -:  103:
        -:  104:#define fail_if(x, error) \
        -:  105:    if (x) \
        -:  106:    { \
        -:  107:      lex_env->last_error = error; \
        -:  108:      YYABORT; \
        -:  109:    } \
        -:  110:
        -:  111:#define destroy_node_if(x, node) \
        -:  112:    if (x) \
        -:  113:    { \
        -:  114:      yr_re_node_destroy(node); \
        -:  115:    } \
        -:  116:
        -:  117:
        -:  118:#line 119 "re_grammar.c"
        -:  119:
        -:  120:# ifndef YY_CAST
        -:  121:#  ifdef __cplusplus
        -:  122:#   define YY_CAST(Type, Val) static_cast<Type> (Val)
        -:  123:#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
        -:  124:#  else
        -:  125:#   define YY_CAST(Type, Val) ((Type) (Val))
        -:  126:#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
        -:  127:#  endif
        -:  128:# endif
        -:  129:# ifndef YY_NULLPTR
        -:  130:#  if defined __cplusplus
        -:  131:#   if 201103L <= __cplusplus
        -:  132:#    define YY_NULLPTR nullptr
        -:  133:#   else
        -:  134:#    define YY_NULLPTR 0
        -:  135:#   endif
        -:  136:#  else
        -:  137:#   define YY_NULLPTR ((void*)0)
        -:  138:#  endif
        -:  139:# endif
        -:  140:
        -:  141:/* Enabling verbose error messages.  */
        -:  142:#ifdef YYERROR_VERBOSE
        -:  143:# undef YYERROR_VERBOSE
        -:  144:# define YYERROR_VERBOSE 1
        -:  145:#else
        -:  146:# define YYERROR_VERBOSE 0
        -:  147:#endif
        -:  148:
        -:  149:/* Use api.header.include to #include this header
        -:  150:   instead of duplicating it here.  */
        -:  151:#ifndef YY_RE_YY_RE_GRAMMAR_H_INCLUDED
        -:  152:# define YY_RE_YY_RE_GRAMMAR_H_INCLUDED
        -:  153:/* Debug traces.  */
        -:  154:#ifndef YYDEBUG
        -:  155:# define YYDEBUG 0
        -:  156:#endif
        -:  157:#if YYDEBUG
        -:  158:extern int re_yydebug;
        -:  159:#endif
        -:  160:
        -:  161:/* Token type.  */
        -:  162:#ifndef YYTOKENTYPE
        -:  163:# define YYTOKENTYPE
        -:  164:  enum yytokentype
        -:  165:  {
        -:  166:    _CHAR_ = 258,
        -:  167:    _ANY_ = 259,
        -:  168:    _RANGE_ = 260,
        -:  169:    _CLASS_ = 261,
        -:  170:    _WORD_CHAR_ = 262,
        -:  171:    _NON_WORD_CHAR_ = 263,
        -:  172:    _SPACE_ = 264,
        -:  173:    _NON_SPACE_ = 265,
        -:  174:    _DIGIT_ = 266,
        -:  175:    _NON_DIGIT_ = 267,
        -:  176:    _WORD_BOUNDARY_ = 268,
        -:  177:    _NON_WORD_BOUNDARY_ = 269
        -:  178:  };
        -:  179:#endif
        -:  180:/* Tokens.  */
        -:  181:#define _CHAR_ 258
        -:  182:#define _ANY_ 259
        -:  183:#define _RANGE_ 260
        -:  184:#define _CLASS_ 261
        -:  185:#define _WORD_CHAR_ 262
        -:  186:#define _NON_WORD_CHAR_ 263
        -:  187:#define _SPACE_ 264
        -:  188:#define _NON_SPACE_ 265
        -:  189:#define _DIGIT_ 266
        -:  190:#define _NON_DIGIT_ 267
        -:  191:#define _WORD_BOUNDARY_ 268
        -:  192:#define _NON_WORD_BOUNDARY_ 269
        -:  193:
        -:  194:/* Value type.  */
        -:  195:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  196:union YYSTYPE
        -:  197:{
        -:  198:#line 83 "re_grammar.y"
        -:  199:
        -:  200:  int integer;
        -:  201:  uint32_t range;
        -:  202:  RE_NODE* re_node;
        -:  203:  RE_CLASS* re_class;
        -:  204:
        -:  205:#line 206 "re_grammar.c"
        -:  206:
        -:  207:};
        -:  208:typedef union YYSTYPE YYSTYPE;
        -:  209:# define YYSTYPE_IS_TRIVIAL 1
        -:  210:# define YYSTYPE_IS_DECLARED 1
        -:  211:#endif
        -:  212:
        -:  213:
        -:  214:
        -:  215:int re_yyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env);
        -:  216:
        -:  217:#endif /* !YY_RE_YY_RE_GRAMMAR_H_INCLUDED  */
        -:  218:
        -:  219:
        -:  220:
        -:  221:#ifdef short
        -:  222:# undef short
        -:  223:#endif
        -:  224:
        -:  225:/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
        -:  226:   <limits.h> and (if available) <stdint.h> are included
        -:  227:   so that the code can choose integer types of a good width.  */
        -:  228:
        -:  229:#ifndef __PTRDIFF_MAX__
        -:  230:# include <limits.h> /* INFRINGES ON USER NAME SPACE */
        -:  231:# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  232:#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
        -:  233:#  define YY_STDINT_H
        -:  234:# endif
        -:  235:#endif
        -:  236:
        -:  237:/* Narrow types that promote to a signed type and that can represent a
        -:  238:   signed or unsigned integer of at least N bits.  In tables they can
        -:  239:   save space and decrease cache pressure.  Promoting to a signed type
        -:  240:   helps avoid bugs in integer arithmetic.  */
        -:  241:
        -:  242:#ifdef __INT_LEAST8_MAX__
        -:  243:typedef __INT_LEAST8_TYPE__ yytype_int8;
        -:  244:#elif defined YY_STDINT_H
        -:  245:typedef int_least8_t yytype_int8;
        -:  246:#else
        -:  247:typedef signed char yytype_int8;
        -:  248:#endif
        -:  249:
        -:  250:#ifdef __INT_LEAST16_MAX__
        -:  251:typedef __INT_LEAST16_TYPE__ yytype_int16;
        -:  252:#elif defined YY_STDINT_H
        -:  253:typedef int_least16_t yytype_int16;
        -:  254:#else
        -:  255:typedef short yytype_int16;
        -:  256:#endif
        -:  257:
        -:  258:#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
        -:  259:typedef __UINT_LEAST8_TYPE__ yytype_uint8;
        -:  260:#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
        -:  261:       && UINT_LEAST8_MAX <= INT_MAX)
        -:  262:typedef uint_least8_t yytype_uint8;
        -:  263:#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
        -:  264:typedef unsigned char yytype_uint8;
        -:  265:#else
        -:  266:typedef short yytype_uint8;
        -:  267:#endif
        -:  268:
        -:  269:#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
        -:  270:typedef __UINT_LEAST16_TYPE__ yytype_uint16;
        -:  271:#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
        -:  272:       && UINT_LEAST16_MAX <= INT_MAX)
        -:  273:typedef uint_least16_t yytype_uint16;
        -:  274:#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
        -:  275:typedef unsigned short yytype_uint16;
        -:  276:#else
        -:  277:typedef int yytype_uint16;
        -:  278:#endif
        -:  279:
        -:  280:#ifndef YYPTRDIFF_T
        -:  281:# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
        -:  282:#  define YYPTRDIFF_T __PTRDIFF_TYPE__
        -:  283:#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
        -:  284:# elif defined PTRDIFF_MAX
        -:  285:#  ifndef ptrdiff_t
        -:  286:#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  287:#  endif
        -:  288:#  define YYPTRDIFF_T ptrdiff_t
        -:  289:#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
        -:  290:# else
        -:  291:#  define YYPTRDIFF_T long
        -:  292:#  define YYPTRDIFF_MAXIMUM LONG_MAX
        -:  293:# endif
        -:  294:#endif
        -:  295:
        -:  296:#ifndef YYSIZE_T
        -:  297:# ifdef __SIZE_TYPE__
        -:  298:#  define YYSIZE_T __SIZE_TYPE__
        -:  299:# elif defined size_t
        -:  300:#  define YYSIZE_T size_t
        -:  301:# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  302:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  303:#  define YYSIZE_T size_t
        -:  304:# else
        -:  305:#  define YYSIZE_T unsigned
        -:  306:# endif
        -:  307:#endif
        -:  308:
        -:  309:#define YYSIZE_MAXIMUM                                  \
        -:  310:  YY_CAST (YYPTRDIFF_T,                                 \
        -:  311:           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
        -:  312:            ? YYPTRDIFF_MAXIMUM                         \
        -:  313:            : YY_CAST (YYSIZE_T, -1)))
        -:  314:
        -:  315:#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
        -:  316:
        -:  317:/* Stored state numbers (used for stacks). */
        -:  318:typedef yytype_int8 yy_state_t;
        -:  319:
        -:  320:/* State numbers in computations.  */
        -:  321:typedef int yy_state_fast_t;
        -:  322:
        -:  323:#ifndef YY_
        -:  324:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  325:#  if ENABLE_NLS
        -:  326:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  327:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  328:#  endif
        -:  329:# endif
        -:  330:# ifndef YY_
        -:  331:#  define YY_(Msgid) Msgid
        -:  332:# endif
        -:  333:#endif
        -:  334:
        -:  335:#ifndef YY_ATTRIBUTE_PURE
        -:  336:# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
        -:  337:#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
        -:  338:# else
        -:  339:#  define YY_ATTRIBUTE_PURE
        -:  340:# endif
        -:  341:#endif
        -:  342:
        -:  343:#ifndef YY_ATTRIBUTE_UNUSED
        -:  344:# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
        -:  345:#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  346:# else
        -:  347:#  define YY_ATTRIBUTE_UNUSED
        -:  348:# endif
        -:  349:#endif
        -:  350:
        -:  351:/* Suppress unused-variable warnings by "using" E.  */
        -:  352:#if ! defined lint || defined __GNUC__
        -:  353:# define YYUSE(E) ((void) (E))
        -:  354:#else
        -:  355:# define YYUSE(E) /* empty */
        -:  356:#endif
        -:  357:
        -:  358:#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  359:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  360:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
        -:  361:    _Pragma ("GCC diagnostic push")                                     \
        -:  362:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
        -:  363:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  364:# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
        -:  365:    _Pragma ("GCC diagnostic pop")
        -:  366:#else
        -:  367:# define YY_INITIAL_VALUE(Value) Value
        -:  368:#endif
        -:  369:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  370:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  371:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  372:#endif
        -:  373:#ifndef YY_INITIAL_VALUE
        -:  374:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  375:#endif
        -:  376:
        -:  377:#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
        -:  378:# define YY_IGNORE_USELESS_CAST_BEGIN                          \
        -:  379:    _Pragma ("GCC diagnostic push")                            \
        -:  380:    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
        -:  381:# define YY_IGNORE_USELESS_CAST_END            \
        -:  382:    _Pragma ("GCC diagnostic pop")
        -:  383:#endif
        -:  384:#ifndef YY_IGNORE_USELESS_CAST_BEGIN
        -:  385:# define YY_IGNORE_USELESS_CAST_BEGIN
        -:  386:# define YY_IGNORE_USELESS_CAST_END
        -:  387:#endif
        -:  388:
        -:  389:
        -:  390:#define YY_ASSERT(E) ((void) (0 && (E)))
        -:  391:
        -:  392:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  393:
        -:  394:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  395:
        -:  396:# ifdef YYSTACK_USE_ALLOCA
        -:  397:#  if YYSTACK_USE_ALLOCA
        -:  398:#   ifdef __GNUC__
        -:  399:#    define YYSTACK_ALLOC __builtin_alloca
        -:  400:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  401:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  402:#   elif defined _AIX
        -:  403:#    define YYSTACK_ALLOC __alloca
        -:  404:#   elif defined _MSC_VER
        -:  405:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  406:#    define alloca _alloca
        -:  407:#   else
        -:  408:#    define YYSTACK_ALLOC alloca
        -:  409:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  410:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  411:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  412:#     ifndef EXIT_SUCCESS
        -:  413:#      define EXIT_SUCCESS 0
        -:  414:#     endif
        -:  415:#    endif
        -:  416:#   endif
        -:  417:#  endif
        -:  418:# endif
        -:  419:
        -:  420:# ifdef YYSTACK_ALLOC
        -:  421:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  422:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  423:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  424:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  425:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  426:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  427:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  428:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  429:#  endif
        -:  430:# else
        -:  431:#  define YYSTACK_ALLOC YYMALLOC
        -:  432:#  define YYSTACK_FREE YYFREE
        -:  433:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  434:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  435:#  endif
        -:  436:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  437:       && ! ((defined YYMALLOC || defined malloc) \
        -:  438:             && (defined YYFREE || defined free)))
        -:  439:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  440:#   ifndef EXIT_SUCCESS
        -:  441:#    define EXIT_SUCCESS 0
        -:  442:#   endif
        -:  443:#  endif
        -:  444:#  ifndef YYMALLOC
        -:  445:#   define YYMALLOC malloc
        -:  446:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  447:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  448:#   endif
        -:  449:#  endif
        -:  450:#  ifndef YYFREE
        -:  451:#   define YYFREE free
        -:  452:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  453:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  454:#   endif
        -:  455:#  endif
        -:  456:# endif
        -:  457:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  458:
        -:  459:
        -:  460:#if (! defined yyoverflow \
        -:  461:     && (! defined __cplusplus \
        -:  462:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  463:
        -:  464:/* A type that is properly aligned for any stack member.  */
        -:  465:union yyalloc
        -:  466:{
        -:  467:  yy_state_t yyss_alloc;
        -:  468:  YYSTYPE yyvs_alloc;
        -:  469:};
        -:  470:
        -:  471:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  472:# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
        -:  473:
        -:  474:/* The size of an array large to enough to hold all stacks, each with
        -:  475:   N elements.  */
        -:  476:# define YYSTACK_BYTES(N) \
        -:  477:     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
        -:  478:      + YYSTACK_GAP_MAXIMUM)
        -:  479:
        -:  480:# define YYCOPY_NEEDED 1
        -:  481:
        -:  482:/* Relocate STACK from its old location to the new one.  The
        -:  483:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  484:   elements in the stack, and YYPTR gives the new location of the
        -:  485:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  486:   stack.  */
        -:  487:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  488:    do                                                                  \
        -:  489:      {                                                                 \
        -:  490:        YYPTRDIFF_T yynewbytes;                                         \
        -:  491:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  492:        Stack = &yyptr->Stack_alloc;                                    \
        -:  493:        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  494:        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
        -:  495:      }                                                                 \
        -:  496:    while (0)
        -:  497:
        -:  498:#endif
        -:  499:
        -:  500:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  501:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  502:   not overlap.  */
        -:  503:# ifndef YYCOPY
        -:  504:#  if defined __GNUC__ && 1 < __GNUC__
        -:  505:#   define YYCOPY(Dst, Src, Count) \
        -:  506:      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
        -:  507:#  else
        -:  508:#   define YYCOPY(Dst, Src, Count)              \
        -:  509:      do                                        \
        -:  510:        {                                       \
        -:  511:          YYPTRDIFF_T yyi;                      \
        -:  512:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  513:            (Dst)[yyi] = (Src)[yyi];            \
        -:  514:        }                                       \
        -:  515:      while (0)
        -:  516:#  endif
        -:  517:# endif
        -:  518:#endif /* !YYCOPY_NEEDED */
        -:  519:
        -:  520:/* YYFINAL -- State number of the termination state.  */
        -:  521:#define YYFINAL  22
        -:  522:/* YYLAST -- Last index in YYTABLE.  */
        -:  523:#define YYLAST   45
        -:  524:
        -:  525:/* YYNTOKENS -- Number of terminals.  */
        -:  526:#define YYNTOKENS  24
        -:  527:/* YYNNTS -- Number of nonterminals.  */
        -:  528:#define YYNNTS  6
        -:  529:/* YYNRULES -- Number of rules.  */
        -:  530:#define YYNRULES  31
        -:  531:/* YYNSTATES -- Number of states.  */
        -:  532:#define YYNSTATES  35
        -:  533:
        -:  534:#define YYUNDEFTOK  2
        -:  535:#define YYMAXUTOK   269
        -:  536:
        -:  537:
        -:  538:/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
        -:  539:   as returned by yylex, with out-of-bounds checking.  */
        -:  540:#define YYTRANSLATE(YYX)                                                \
        -:  541:  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  542:
        -:  543:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  544:   as returned by yylex.  */
        -:  545:static const yytype_int8 yytranslate[] =
        -:  546:{
        -:  547:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  548:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  549:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  550:       2,     2,     2,     2,     2,     2,    20,     2,     2,     2,
        -:  551:      21,    22,    16,    18,     2,     2,    23,     2,     2,     2,
        -:  552:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  553:       2,     2,     2,    17,     2,     2,     2,     2,     2,     2,
        -:  554:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  555:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  556:       2,     2,     2,     2,    19,     2,     2,     2,     2,     2,
        -:  557:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  558:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  559:       2,     2,     2,     2,    15,     2,     2,     2,     2,     2,
        -:  560:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  561:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  562:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  563:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  564:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  565:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  566:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  567:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  568:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  569:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  570:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  571:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  572:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  573:       5,     6,     7,     8,     9,    10,    11,    12,    13,    14
        -:  574:};
        -:  575:
        -:  576:#if YYDEBUG
        -:  577:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  578:static const yytype_int16 yyrline[] =
        -:  579:{
        -:  580:       0,   114,   114,   119,   123,   127,   143,   165,   169,   186,
        -:  581:     200,   216,   230,   246,   268,   291,   313,   336,   340,   346,
        -:  582:     352,   358,   367,   375,   381,   389,   395,   401,   407,   413,
        -:  583:     419,   425
        -:  584:};
        -:  585:#endif
        -:  586:
        -:  587:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  588:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  589:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  590:static const char *const yytname[] =
        -:  591:{
        -:  592:  "$end", "error", "$undefined", "_CHAR_", "_ANY_", "_RANGE_", "_CLASS_",
        -:  593:  "_WORD_CHAR_", "_NON_WORD_CHAR_", "_SPACE_", "_NON_SPACE_", "_DIGIT_",
        -:  594:  "_NON_DIGIT_", "_WORD_BOUNDARY_", "_NON_WORD_BOUNDARY_", "'|'", "'*'",
        -:  595:  "'?'", "'+'", "'^'", "'$'", "'('", "')'", "'.'", "$accept", "re",
        -:  596:  "alternative", "concatenation", "repeat", "single", YY_NULLPTR
        -:  597:};
        -:  598:#endif
        -:  599:
        -:  600:# ifdef YYPRINT
        -:  601:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  602:   (internal) symbol number NUM (which must be that of a token).  */
        -:  603:static const yytype_int16 yytoknum[] =
        -:  604:{
        -:  605:       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
        -:  606:     265,   266,   267,   268,   269,   124,    42,    63,    43,    94,
        -:  607:      36,    40,    41,    46
        -:  608:};
        -:  609:# endif
        -:  610:
        -:  611:#define YYPACT_NINF (-12)
        -:  612:
        -:  613:#define yypact_value_is_default(Yyn) \
        -:  614:  ((Yyn) == YYPACT_NINF)
        -:  615:
        -:  616:#define YYTABLE_NINF (-1)
        -:  617:
        -:  618:#define yytable_value_is_error(Yyn) \
        -:  619:  0
        -:  620:
        -:  621:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  622:     STATE-NUM.  */
        -:  623:static const yytype_int8 yypact[] =
        -:  624:{
        -:  625:      -1,   -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,   -12,
        -:  626:     -12,   -12,   -12,   -12,    18,   -12,     1,   -11,    18,   -12,
        -:  627:      -2,    21,   -12,    18,   -12,     0,    16,    17,    23,   -12,
        -:  628:      18,   -12,   -12,   -12,   -12
        -:  629:};
        -:  630:
        -:  631:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  632:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  633:     means the default is an error.  */
        -:  634:static const yytype_int8 yydefact[] =
        -:  635:{
        -:  636:       0,     3,    24,    31,    25,    26,    27,    28,    29,    30,
        -:  637:      18,    19,    20,    21,     0,    23,     0,     2,     4,     7,
        -:  638:      17,     0,     1,     6,     8,    15,     9,    13,    11,    22,
        -:  639:       5,    16,    10,    14,    12
        -:  640:};
        -:  641:
        -:  642:  /* YYPGOTO[NTERM-NUM].  */
        -:  643:static const yytype_int8 yypgoto[] =
        -:  644:{
        -:  645:     -12,   -12,    28,    22,     5,   -12
        -:  646:};
        -:  647:
        -:  648:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  649:static const yytype_int8 yydefgoto[] =
        -:  650:{
        -:  651:      -1,    16,    17,    18,    19,    20
        -:  652:};
        -:  653:
        -:  654:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  655:     positive, shift that token.  If negative, reduce the rule whose
        -:  656:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  657:static const yytype_int8 yytable[] =
        -:  658:{
        -:  659:       1,    22,     2,    25,    23,     3,     4,     5,     6,     7,
        -:  660:       8,     9,    10,    11,    26,    27,    28,    31,    12,    13,
        -:  661:      14,     2,    15,    24,     3,     4,     5,     6,     7,     8,
        -:  662:       9,    10,    11,    32,    33,    24,    23,    12,    13,    14,
        -:  663:      34,    15,    21,    29,     0,    30
        -:  664:};
        -:  665:
        -:  666:static const yytype_int8 yycheck[] =
        -:  667:{
        -:  668:       1,     0,     3,     5,    15,     6,     7,     8,     9,    10,
        -:  669:      11,    12,    13,    14,    16,    17,    18,    17,    19,    20,
        -:  670:      21,     3,    23,    18,     6,     7,     8,     9,    10,    11,
        -:  671:      12,    13,    14,    17,    17,    30,    15,    19,    20,    21,
        -:  672:      17,    23,    14,    22,    -1,    23
        -:  673:};
        -:  674:
        -:  675:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  676:     symbol of state STATE-NUM.  */
        -:  677:static const yytype_int8 yystos[] =
        -:  678:{
        -:  679:       0,     1,     3,     6,     7,     8,     9,    10,    11,    12,
        -:  680:      13,    14,    19,    20,    21,    23,    25,    26,    27,    28,
        -:  681:      29,    26,     0,    15,    28,     5,    16,    17,    18,    22,
        -:  682:      27,    17,    17,    17,    17
        -:  683:};
        -:  684:
        -:  685:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  686:static const yytype_int8 yyr1[] =
        -:  687:{
        -:  688:       0,    24,    25,    25,    26,    26,    26,    27,    27,    28,
        -:  689:      28,    28,    28,    28,    28,    28,    28,    28,    28,    28,
        -:  690:      28,    28,    29,    29,    29,    29,    29,    29,    29,    29,
        -:  691:      29,    29
        -:  692:};
        -:  693:
        -:  694:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  695:static const yytype_int8 yyr2[] =
        -:  696:{
        -:  697:       0,     2,     1,     1,     1,     3,     2,     1,     2,     2,
        -:  698:       3,     2,     3,     2,     3,     2,     3,     1,     1,     1,
        -:  699:       1,     1,     3,     1,     1,     1,     1,     1,     1,     1,
        -:  700:       1,     1
        -:  701:};
        -:  702:
        -:  703:
        -:  704:#define yyerrok         (yyerrstatus = 0)
        -:  705:#define yyclearin       (yychar = YYEMPTY)
        -:  706:#define YYEMPTY         (-2)
        -:  707:#define YYEOF           0
        -:  708:
        -:  709:#define YYACCEPT        goto yyacceptlab
        -:  710:#define YYABORT         goto yyabortlab
        -:  711:#define YYERROR         goto yyerrorlab
        -:  712:
        -:  713:
        -:  714:#define YYRECOVERING()  (!!yyerrstatus)
        -:  715:
        -:  716:#define YYBACKUP(Token, Value)                                    \
        -:  717:  do                                                              \
        -:  718:    if (yychar == YYEMPTY)                                        \
        -:  719:      {                                                           \
        -:  720:        yychar = (Token);                                         \
        -:  721:        yylval = (Value);                                         \
        -:  722:        YYPOPSTACK (yylen);                                       \
        -:  723:        yystate = *yyssp;                                         \
        -:  724:        goto yybackup;                                            \
        -:  725:      }                                                           \
        -:  726:    else                                                          \
        -:  727:      {                                                           \
        -:  728:        yyerror (yyscanner, lex_env, YY_("syntax error: cannot back up")); \
        -:  729:        YYERROR;                                                  \
        -:  730:      }                                                           \
        -:  731:  while (0)
        -:  732:
        -:  733:/* Error token number */
        -:  734:#define YYTERROR        1
        -:  735:#define YYERRCODE       256
        -:  736:
        -:  737:
        -:  738:
        -:  739:/* Enable debugging if requested.  */
        -:  740:#if YYDEBUG
        -:  741:
        -:  742:# ifndef YYFPRINTF
        -:  743:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -:  744:#  define YYFPRINTF fprintf
        -:  745:# endif
        -:  746:
        -:  747:# define YYDPRINTF(Args)                        \
        -:  748:do {                                            \
        -:  749:  if (yydebug)                                  \
        -:  750:    YYFPRINTF Args;                             \
        -:  751:} while (0)
        -:  752:
        -:  753:/* This macro is provided for backward compatibility. */
        -:  754:#ifndef YY_LOCATION_PRINT
        -:  755:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -:  756:#endif
        -:  757:
        -:  758:
        -:  759:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -:  760:do {                                                                      \
        -:  761:  if (yydebug)                                                            \
        -:  762:    {                                                                     \
        -:  763:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -:  764:      yy_symbol_print (stderr,                                            \
        -:  765:                  Type, Value, yyscanner, lex_env); \
        -:  766:      YYFPRINTF (stderr, "\n");                                           \
        -:  767:    }                                                                     \
        -:  768:} while (0)
        -:  769:
        -:  770:
        -:  771:/*-----------------------------------.
        -:  772:| Print this symbol's value on YYO.  |
        -:  773:`-----------------------------------*/
        -:  774:
        -:  775:static void
        -:  776:yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -:  777:{
        -:  778:  FILE *yyoutput = yyo;
        -:  779:  YYUSE (yyoutput);
        -:  780:  YYUSE (yyscanner);
        -:  781:  YYUSE (lex_env);
        -:  782:  if (!yyvaluep)
        -:  783:    return;
        -:  784:# ifdef YYPRINT
        -:  785:  if (yytype < YYNTOKENS)
        -:  786:    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
        -:  787:# endif
        -:  788:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  789:  YYUSE (yytype);
        -:  790:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  791:}
        -:  792:
        -:  793:
        -:  794:/*---------------------------.
        -:  795:| Print this symbol on YYO.  |
        -:  796:`---------------------------*/
        -:  797:
        -:  798:static void
        -:  799:yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -:  800:{
        -:  801:  YYFPRINTF (yyo, "%s %s (",
        -:  802:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -:  803:
        -:  804:  yy_symbol_value_print (yyo, yytype, yyvaluep, yyscanner, lex_env);
        -:  805:  YYFPRINTF (yyo, ")");
        -:  806:}
        -:  807:
        -:  808:/*------------------------------------------------------------------.
        -:  809:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -:  810:| TOP (included).                                                   |
        -:  811:`------------------------------------------------------------------*/
        -:  812:
        -:  813:static void
        -:  814:yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
        -:  815:{
        -:  816:  YYFPRINTF (stderr, "Stack now");
        -:  817:  for (; yybottom <= yytop; yybottom++)
        -:  818:    {
        -:  819:      int yybot = *yybottom;
        -:  820:      YYFPRINTF (stderr, " %d", yybot);
        -:  821:    }
        -:  822:  YYFPRINTF (stderr, "\n");
        -:  823:}
        -:  824:
        -:  825:# define YY_STACK_PRINT(Bottom, Top)                            \
        -:  826:do {                                                            \
        -:  827:  if (yydebug)                                                  \
        -:  828:    yy_stack_print ((Bottom), (Top));                           \
        -:  829:} while (0)
        -:  830:
        -:  831:
        -:  832:/*------------------------------------------------.
        -:  833:| Report that the YYRULE is going to be reduced.  |
        -:  834:`------------------------------------------------*/
        -:  835:
        -:  836:static void
        -:  837:yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -:  838:{
        -:  839:  int yylno = yyrline[yyrule];
        -:  840:  int yynrhs = yyr2[yyrule];
        -:  841:  int yyi;
        -:  842:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
        -:  843:             yyrule - 1, yylno);
        -:  844:  /* The symbols being reduced.  */
        -:  845:  for (yyi = 0; yyi < yynrhs; yyi++)
        -:  846:    {
        -:  847:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -:  848:      yy_symbol_print (stderr,
        -:  849:                       yystos[+yyssp[yyi + 1 - yynrhs]],
        -:  850:                       &yyvsp[(yyi + 1) - (yynrhs)]
        -:  851:                                              , yyscanner, lex_env);
        -:  852:      YYFPRINTF (stderr, "\n");
        -:  853:    }
        -:  854:}
        -:  855:
        -:  856:# define YY_REDUCE_PRINT(Rule)          \
        -:  857:do {                                    \
        -:  858:  if (yydebug)                          \
        -:  859:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, lex_env); \
        -:  860:} while (0)
        -:  861:
        -:  862:/* Nonzero means print parse trace.  It is left uninitialized so that
        -:  863:   multiple parsers can coexist.  */
        -:  864:int yydebug;
        -:  865:#else /* !YYDEBUG */
        -:  866:# define YYDPRINTF(Args)
        -:  867:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -:  868:# define YY_STACK_PRINT(Bottom, Top)
        -:  869:# define YY_REDUCE_PRINT(Rule)
        -:  870:#endif /* !YYDEBUG */
        -:  871:
        -:  872:
        -:  873:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -:  874:#ifndef YYINITDEPTH
        -:  875:# define YYINITDEPTH 200
        -:  876:#endif
        -:  877:
        -:  878:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -:  879:   if the built-in stack extension method is used).
        -:  880:
        -:  881:   Do not make this value too large; the results are undefined if
        -:  882:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -:  883:   evaluated with infinite-precision integer arithmetic.  */
        -:  884:
        -:  885:#ifndef YYMAXDEPTH
        -:  886:# define YYMAXDEPTH 10000
        -:  887:#endif
        -:  888:
        -:  889:
        -:  890:#if YYERROR_VERBOSE
        -:  891:
        -:  892:# ifndef yystrlen
        -:  893:#  if defined __GLIBC__ && defined _STRING_H
        -:  894:#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
        -:  895:#  else
        -:  896:/* Return the length of YYSTR.  */
        -:  897:static YYPTRDIFF_T
        -:  898:yystrlen (const char *yystr)
        -:  899:{
        -:  900:  YYPTRDIFF_T yylen;
        -:  901:  for (yylen = 0; yystr[yylen]; yylen++)
        -:  902:    continue;
        -:  903:  return yylen;
        -:  904:}
        -:  905:#  endif
        -:  906:# endif
        -:  907:
        -:  908:# ifndef yystpcpy
        -:  909:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -:  910:#   define yystpcpy stpcpy
        -:  911:#  else
        -:  912:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -:  913:   YYDEST.  */
        -:  914:static char *
    #####:  915:yystpcpy (char *yydest, const char *yysrc)
        -:  916:{
    #####:  917:  char *yyd = yydest;
    #####:  918:  const char *yys = yysrc;
        -:  919:
    #####:  920:  while ((*yyd++ = *yys++) != '\0')
    #####:  921:    continue;
        -:  922:
    #####:  923:  return yyd - 1;
        -:  924:}
        -:  925:#  endif
        -:  926:# endif
        -:  927:
        -:  928:# ifndef yytnamerr
        -:  929:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -:  930:   quotes and backslashes, so that it's suitable for yyerror.  The
        -:  931:   heuristic is that double-quoting is unnecessary unless the string
        -:  932:   contains an apostrophe, a comma, or backslash (other than
        -:  933:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -:  934:   null, do not copy; instead, return the length of what the result
        -:  935:   would have been.  */
        -:  936:static YYPTRDIFF_T
    #####:  937:yytnamerr (char *yyres, const char *yystr)
        -:  938:{
    #####:  939:  if (*yystr == '"')
        -:  940:    {
    #####:  941:      YYPTRDIFF_T yyn = 0;
    #####:  942:      char const *yyp = yystr;
        -:  943:
        -:  944:      for (;;)
    #####:  945:        switch (*++yyp)
        -:  946:          {
    #####:  947:          case '\'':
        -:  948:          case ',':
    #####:  949:            goto do_not_strip_quotes;
        -:  950:
    #####:  951:          case '\\':
    #####:  952:            if (*++yyp != '\\')
    #####:  953:              goto do_not_strip_quotes;
        -:  954:            else
    #####:  955:              goto append;
        -:  956:
    #####:  957:          append:
        -:  958:          default:
    #####:  959:            if (yyres)
    #####:  960:              yyres[yyn] = *yyp;
    #####:  961:            yyn++;
    #####:  962:            break;
        -:  963:
    #####:  964:          case '"':
    #####:  965:            if (yyres)
    #####:  966:              yyres[yyn] = '\0';
    #####:  967:            return yyn;
        -:  968:          }
    #####:  969:    do_not_strip_quotes: ;
        -:  970:    }
        -:  971:
    #####:  972:  if (yyres)
    #####:  973:    return yystpcpy (yyres, yystr) - yyres;
        -:  974:  else
    #####:  975:    return yystrlen (yystr);
        -:  976:}
        -:  977:# endif
        -:  978:
        -:  979:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -:  980:   about the unexpected token YYTOKEN for the state stack whose top is
        -:  981:   YYSSP.
        -:  982:
        -:  983:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -:  984:   not large enough to hold the message.  In that case, also set
        -:  985:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -:  986:   required number of bytes is too large to store.  */
        -:  987:static int
    #####:  988:yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
        -:  989:                yy_state_t *yyssp, int yytoken)
        -:  990:{
        -:  991:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -:  992:  /* Internationalized format string. */
    #####:  993:  const char *yyformat = YY_NULLPTR;
        -:  994:  /* Arguments of yyformat: reported tokens (one for the "unexpected",
        -:  995:     one per "expected"). */
        -:  996:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -:  997:  /* Actual size of YYARG. */
    #####:  998:  int yycount = 0;
        -:  999:  /* Cumulated lengths of YYARG.  */
    #####: 1000:  YYPTRDIFF_T yysize = 0;
        -: 1001:
        -: 1002:  /* There are many possibilities here to consider:
        -: 1003:     - If this state is a consistent state with a default action, then
        -: 1004:       the only way this function was invoked is if the default action
        -: 1005:       is an error action.  In that case, don't check for expected
        -: 1006:       tokens because there are none.
        -: 1007:     - The only way there can be no lookahead present (in yychar) is if
        -: 1008:       this state is a consistent state with a default action.  Thus,
        -: 1009:       detecting the absence of a lookahead is sufficient to determine
        -: 1010:       that there is no unexpected or expected token to report.  In that
        -: 1011:       case, just report a simple "syntax error".
        -: 1012:     - Don't assume there isn't a lookahead just because this state is a
        -: 1013:       consistent state with a default action.  There might have been a
        -: 1014:       previous inconsistent state, consistent state with a non-default
        -: 1015:       action, or user semantic action that manipulated yychar.
        -: 1016:     - Of course, the expected token list depends on states to have
        -: 1017:       correct lookahead information, and it depends on the parser not
        -: 1018:       to perform extra reductions after fetching a lookahead from the
        -: 1019:       scanner and before detecting a syntax error.  Thus, state merging
        -: 1020:       (from LALR or IELR) and default reductions corrupt the expected
        -: 1021:       token list.  However, the list is correct for canonical LR with
        -: 1022:       one exception: it will still contain any token that will not be
        -: 1023:       accepted due to an error action in a later state.
        -: 1024:  */
    #####: 1025:  if (yytoken != YYEMPTY)
        -: 1026:    {
    #####: 1027:      int yyn = yypact[+*yyssp];
    #####: 1028:      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
    #####: 1029:      yysize = yysize0;
    #####: 1030:      yyarg[yycount++] = yytname[yytoken];
    #####: 1031:      if (!yypact_value_is_default (yyn))
        -: 1032:        {
        -: 1033:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1034:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1035:             this state because they are default actions.  */
    #####: 1036:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -: 1037:          /* Stay within bounds of both yycheck and yytname.  */
    #####: 1038:          int yychecklim = YYLAST - yyn + 1;
    #####: 1039:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1040:          int yyx;
        -: 1041:
    #####: 1042:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
    #####: 1043:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
    #####: 1044:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -: 1045:              {
    #####: 1046:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -: 1047:                  {
    #####: 1048:                    yycount = 1;
    #####: 1049:                    yysize = yysize0;
    #####: 1050:                    break;
        -: 1051:                  }
    #####: 1052:                yyarg[yycount++] = yytname[yyx];
        -: 1053:                {
    #####: 1054:                  YYPTRDIFF_T yysize1
    #####: 1055:                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
    #####: 1056:                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
    #####: 1057:                    yysize = yysize1;
        -: 1058:                  else
    #####: 1059:                    return 2;
        -: 1060:                }
        -: 1061:              }
        -: 1062:        }
        -: 1063:    }
        -: 1064:
    #####: 1065:  switch (yycount)
        -: 1066:    {
        -: 1067:# define YYCASE_(N, S)                      \
        -: 1068:      case N:                               \
        -: 1069:        yyformat = S;                       \
        -: 1070:      break
    #####: 1071:    default: /* Avoid compiler warnings. */
    #####: 1072:      YYCASE_(0, YY_("syntax error"));
    #####: 1073:      YYCASE_(1, YY_("syntax error, unexpected %s"));
    #####: 1074:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1075:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1076:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1077:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1078:# undef YYCASE_
        -: 1079:    }
        -: 1080:
        -: 1081:  {
        -: 1082:    /* Don't count the "%s"s in the final size, but reserve room for
        -: 1083:       the terminator.  */
    #####: 1084:    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
    #####: 1085:    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
    #####: 1086:      yysize = yysize1;
        -: 1087:    else
    #####: 1088:      return 2;
        -: 1089:  }
        -: 1090:
    #####: 1091:  if (*yymsg_alloc < yysize)
        -: 1092:    {
    #####: 1093:      *yymsg_alloc = 2 * yysize;
    #####: 1094:      if (! (yysize <= *yymsg_alloc
        -: 1095:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1096:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####: 1097:      return 1;
        -: 1098:    }
        -: 1099:
        -: 1100:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1101:     Don't have undefined behavior even if the translation
        -: 1102:     produced a string with the wrong number of "%s"s.  */
        -: 1103:  {
    #####: 1104:    char *yyp = *yymsg;
    #####: 1105:    int yyi = 0;
    #####: 1106:    while ((*yyp = *yyformat) != '\0')
    #####: 1107:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1108:        {
    #####: 1109:          yyp += yytnamerr (yyp, yyarg[yyi++]);
    #####: 1110:          yyformat += 2;
        -: 1111:        }
        -: 1112:      else
        -: 1113:        {
    #####: 1114:          ++yyp;
    #####: 1115:          ++yyformat;
        -: 1116:        }
        -: 1117:  }
    #####: 1118:  return 0;
        -: 1119:}
        -: 1120:#endif /* YYERROR_VERBOSE */
        -: 1121:
        -: 1122:/*-----------------------------------------------.
        -: 1123:| Release the memory associated to this symbol.  |
        -: 1124:`-----------------------------------------------*/
        -: 1125:
        -: 1126:static void
    #####: 1127:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -: 1128:{
        -: 1129:  YYUSE (yyvaluep);
        -: 1130:  YYUSE (yyscanner);
        -: 1131:  YYUSE (lex_env);
    #####: 1132:  if (!yymsg)
    #####: 1133:    yymsg = "Deleting";
        -: 1134:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1135:
        -: 1136:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1137:  switch (yytype)
        -: 1138:    {
    #####: 1139:    case 6: /* _CLASS_  */
        -: 1140:#line 106 "re_grammar.y"
        -: 1141:            { yr_free(((*yyvaluep).re_class)); ((*yyvaluep).re_class) = NULL; }
        -: 1142:#line 1143 "re_grammar.c"
    #####: 1143:        break;
        -: 1144:
    #####: 1145:    case 26: /* alternative  */
        -: 1146:#line 107 "re_grammar.y"
        -: 1147:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1148:#line 1149 "re_grammar.c"
    #####: 1149:        break;
        -: 1150:
    #####: 1151:    case 27: /* concatenation  */
        -: 1152:#line 108 "re_grammar.y"
        -: 1153:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1154:#line 1155 "re_grammar.c"
    #####: 1155:        break;
        -: 1156:
    #####: 1157:    case 28: /* repeat  */
        -: 1158:#line 109 "re_grammar.y"
        -: 1159:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1160:#line 1161 "re_grammar.c"
    #####: 1161:        break;
        -: 1162:
    #####: 1163:    case 29: /* single  */
        -: 1164:#line 110 "re_grammar.y"
        -: 1165:            { yr_re_node_destroy(((*yyvaluep).re_node)); ((*yyvaluep).re_node) = NULL; }
        -: 1166:#line 1167 "re_grammar.c"
    #####: 1167:        break;
        -: 1168:
    #####: 1169:      default:
    #####: 1170:        break;
        -: 1171:    }
        -: 1172:  YY_IGNORE_MAYBE_UNINITIALIZED_END
    #####: 1173:}
        -: 1174:
        -: 1175:
        -: 1176:
        -: 1177:
        -: 1178:/*----------.
        -: 1179:| yyparse.  |
        -: 1180:`----------*/
        -: 1181:
        -: 1182:int
    #####: 1183:yyparse (void *yyscanner, RE_LEX_ENVIRONMENT *lex_env)
        -: 1184:{
        -: 1185:/* The lookahead symbol.  */
        -: 1186:int yychar;
        -: 1187:
        -: 1188:
        -: 1189:/* The semantic value of the lookahead symbol.  */
        -: 1190:/* Default value used for initialization, for pacifying older GCCs
        -: 1191:   or non-GCC compilers.  */
        -: 1192:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1193:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1194:
        -: 1195:    /* Number of syntax errors so far.  */
        -: 1196:    int yynerrs;
        -: 1197:
        -: 1198:    yy_state_fast_t yystate;
        -: 1199:    /* Number of tokens to shift before error messages enabled.  */
        -: 1200:    int yyerrstatus;
        -: 1201:
        -: 1202:    /* The stacks and their tools:
        -: 1203:       'yyss': related to states.
        -: 1204:       'yyvs': related to semantic values.
        -: 1205:
        -: 1206:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1207:       to reallocate them elsewhere.  */
        -: 1208:
        -: 1209:    /* The state stack.  */
        -: 1210:    yy_state_t yyssa[YYINITDEPTH];
        -: 1211:    yy_state_t *yyss;
        -: 1212:    yy_state_t *yyssp;
        -: 1213:
        -: 1214:    /* The semantic value stack.  */
        -: 1215:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1216:    YYSTYPE *yyvs;
        -: 1217:    YYSTYPE *yyvsp;
        -: 1218:
        -: 1219:    YYPTRDIFF_T yystacksize;
        -: 1220:
        -: 1221:  int yyn;
        -: 1222:  int yyresult;
        -: 1223:  /* Lookahead token as an internal (translated) token number.  */
    #####: 1224:  int yytoken = 0;
        -: 1225:  /* The variables used to return semantic value and location from the
        -: 1226:     action routines.  */
        -: 1227:  YYSTYPE yyval;
        -: 1228:
        -: 1229:#if YYERROR_VERBOSE
        -: 1230:  /* Buffer for error messages, and its allocated size.  */
        -: 1231:  char yymsgbuf[128];
    #####: 1232:  char *yymsg = yymsgbuf;
    #####: 1233:  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
        -: 1234:#endif
        -: 1235:
        -: 1236:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1237:
        -: 1238:  /* The number of symbols on the RHS of the reduced rule.
        -: 1239:     Keep to zero when no symbol should be popped.  */
    #####: 1240:  int yylen = 0;
        -: 1241:
    #####: 1242:  yyssp = yyss = yyssa;
    #####: 1243:  yyvsp = yyvs = yyvsa;
    #####: 1244:  yystacksize = YYINITDEPTH;
        -: 1245:
        -: 1246:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1247:
    #####: 1248:  yystate = 0;
    #####: 1249:  yyerrstatus = 0;
    #####: 1250:  yynerrs = 0;
    #####: 1251:  yychar = YYEMPTY; /* Cause a token to be read.  */
    #####: 1252:  goto yysetstate;
        -: 1253:
        -: 1254:
        -: 1255:/*------------------------------------------------------------.
        -: 1256:| yynewstate -- push a new state, which is found in yystate.  |
        -: 1257:`------------------------------------------------------------*/
    #####: 1258:yynewstate:
        -: 1259:  /* In all cases, when you get here, the value and location stacks
        -: 1260:     have just been pushed.  So pushing a state here evens the stacks.  */
    #####: 1261:  yyssp++;
        -: 1262:
        -: 1263:
        -: 1264:/*--------------------------------------------------------------------.
        -: 1265:| yysetstate -- set current state (the top of the stack) to yystate.  |
        -: 1266:`--------------------------------------------------------------------*/
    #####: 1267:yysetstate:
        -: 1268:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1269:  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
        -: 1270:  YY_IGNORE_USELESS_CAST_BEGIN
    #####: 1271:  *yyssp = YY_CAST (yy_state_t, yystate);
        -: 1272:  YY_IGNORE_USELESS_CAST_END
        -: 1273:
    #####: 1274:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1275:#if !defined yyoverflow && !defined YYSTACK_RELOCATE
        -: 1276:    goto yyexhaustedlab;
        -: 1277:#else
        -: 1278:    {
        -: 1279:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1280:      YYPTRDIFF_T yysize = yyssp - yyss + 1;
        -: 1281:
        -: 1282:# if defined yyoverflow
        -: 1283:      {
        -: 1284:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1285:           these so that the &'s don't force the real ones into
        -: 1286:           memory.  */
        -: 1287:        yy_state_t *yyss1 = yyss;
        -: 1288:        YYSTYPE *yyvs1 = yyvs;
        -: 1289:
        -: 1290:        /* Each stack pointer address is followed by the size of the
        -: 1291:           data in use in that stack, in bytes.  This used to be a
        -: 1292:           conditional around just the two extra args, but that might
        -: 1293:           be undefined if yyoverflow is a macro.  */
        -: 1294:        yyoverflow (YY_("memory exhausted"),
        -: 1295:                    &yyss1, yysize * YYSIZEOF (*yyssp),
        -: 1296:                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
        -: 1297:                    &yystacksize);
        -: 1298:        yyss = yyss1;
        -: 1299:        yyvs = yyvs1;
        -: 1300:      }
        -: 1301:# else /* defined YYSTACK_RELOCATE */
        -: 1302:      /* Extend the stack our own way.  */
    #####: 1303:      if (YYMAXDEPTH <= yystacksize)
    #####: 1304:        goto yyexhaustedlab;
    #####: 1305:      yystacksize *= 2;
    #####: 1306:      if (YYMAXDEPTH < yystacksize)
    #####: 1307:        yystacksize = YYMAXDEPTH;
        -: 1308:
        -: 1309:      {
    #####: 1310:        yy_state_t *yyss1 = yyss;
        -: 1311:        union yyalloc *yyptr =
    #####: 1312:          YY_CAST (union yyalloc *,
        -: 1313:                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
    #####: 1314:        if (! yyptr)
    #####: 1315:          goto yyexhaustedlab;
    #####: 1316:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1317:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1318:# undef YYSTACK_RELOCATE
    #####: 1319:        if (yyss1 != yyssa)
    #####: 1320:          YYSTACK_FREE (yyss1);
        -: 1321:      }
        -: 1322:# endif
        -: 1323:
    #####: 1324:      yyssp = yyss + yysize - 1;
    #####: 1325:      yyvsp = yyvs + yysize - 1;
        -: 1326:
        -: 1327:      YY_IGNORE_USELESS_CAST_BEGIN
        -: 1328:      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
        -: 1329:                  YY_CAST (long, yystacksize)));
        -: 1330:      YY_IGNORE_USELESS_CAST_END
        -: 1331:
    #####: 1332:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1333:        YYABORT;
        -: 1334:    }
        -: 1335:#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
        -: 1336:
    #####: 1337:  if (yystate == YYFINAL)
    #####: 1338:    YYACCEPT;
        -: 1339:
    #####: 1340:  goto yybackup;
        -: 1341:
        -: 1342:
        -: 1343:/*-----------.
        -: 1344:| yybackup.  |
        -: 1345:`-----------*/
    #####: 1346:yybackup:
        -: 1347:  /* Do appropriate processing given the current state.  Read a
        -: 1348:     lookahead token if we need one and don't already have one.  */
        -: 1349:
        -: 1350:  /* First try to decide what to do without reference to lookahead token.  */
    #####: 1351:  yyn = yypact[yystate];
    #####: 1352:  if (yypact_value_is_default (yyn))
    #####: 1353:    goto yydefault;
        -: 1354:
        -: 1355:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1356:
        -: 1357:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
    #####: 1358:  if (yychar == YYEMPTY)
        -: 1359:    {
        -: 1360:      YYDPRINTF ((stderr, "Reading a token: "));
    #####: 1361:      yychar = yylex (&yylval, yyscanner, lex_env);
        -: 1362:    }
        -: 1363:
    #####: 1364:  if (yychar <= YYEOF)
        -: 1365:    {
    #####: 1366:      yychar = yytoken = YYEOF;
        -: 1367:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1368:    }
        -: 1369:  else
        -: 1370:    {
    #####: 1371:      yytoken = YYTRANSLATE (yychar);
        -: 1372:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1373:    }
        -: 1374:
        -: 1375:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1376:     detect an error, take that action.  */
    #####: 1377:  yyn += yytoken;
    #####: 1378:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
    #####: 1379:    goto yydefault;
    #####: 1380:  yyn = yytable[yyn];
    #####: 1381:  if (yyn <= 0)
        -: 1382:    {
        -: 1383:      if (yytable_value_is_error (yyn))
        -: 1384:        goto yyerrlab;
    #####: 1385:      yyn = -yyn;
    #####: 1386:      goto yyreduce;
        -: 1387:    }
        -: 1388:
        -: 1389:  /* Count tokens shifted since error; after three, turn off error
        -: 1390:     status.  */
    #####: 1391:  if (yyerrstatus)
    #####: 1392:    yyerrstatus--;
        -: 1393:
        -: 1394:  /* Shift the lookahead token.  */
        -: 1395:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
    #####: 1396:  yystate = yyn;
        -: 1397:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 1398:  *++yyvsp = yylval;
        -: 1399:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1400:
        -: 1401:  /* Discard the shifted token.  */
    #####: 1402:  yychar = YYEMPTY;
    #####: 1403:  goto yynewstate;
        -: 1404:
        -: 1405:
        -: 1406:/*-----------------------------------------------------------.
        -: 1407:| yydefault -- do the default action for the current state.  |
        -: 1408:`-----------------------------------------------------------*/
    #####: 1409:yydefault:
    #####: 1410:  yyn = yydefact[yystate];
    #####: 1411:  if (yyn == 0)
    #####: 1412:    goto yyerrlab;
    #####: 1413:  goto yyreduce;
        -: 1414:
        -: 1415:
        -: 1416:/*-----------------------------.
        -: 1417:| yyreduce -- do a reduction.  |
        -: 1418:`-----------------------------*/
    #####: 1419:yyreduce:
        -: 1420:  /* yyn is the number of a rule to reduce with.  */
    #####: 1421:  yylen = yyr2[yyn];
        -: 1422:
        -: 1423:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1424:     '$$ = $1'.
        -: 1425:
        -: 1426:     Otherwise, the following line sets YYVAL to garbage.
        -: 1427:     This behavior is undocumented and Bison
        -: 1428:     users should not rely upon it.  Assigning to YYVAL
        -: 1429:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1430:     GCC warning that YYVAL may be used uninitialized.  */
    #####: 1431:  yyval = yyvsp[1-yylen];
        -: 1432:
        -: 1433:
        -: 1434:  YY_REDUCE_PRINT (yyn);
    #####: 1435:  switch (yyn)
        -: 1436:    {
    #####: 1437:  case 2:
        -: 1438:#line 115 "re_grammar.y"
        -: 1439:      {
        -: 1440:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1441:        re_ast->root_node = (yyvsp[0].re_node);
        -: 1442:      }
        -: 1443:#line 1444 "re_grammar.c"
    #####: 1444:    break;
        -: 1445:
    #####: 1446:  case 4:
        -: 1447:#line 124 "re_grammar.y"
        -: 1448:      {
        -: 1449:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1450:      }
        -: 1451:#line 1452 "re_grammar.c"
    #####: 1452:    break;
        -: 1453:
    #####: 1454:  case 5:
        -: 1455:#line 128 "re_grammar.y"
        -: 1456:      {
        -: 1457:        mark_as_not_fast_regexp();
        -: 1458:
        -: 1459:        fail_if_too_many_ast_levels({
        -: 1460:          yr_re_node_destroy((yyvsp[-2].re_node));
        -: 1461:          yr_re_node_destroy((yyvsp[0].re_node));
        -: 1462:        });
        -: 1463:
        -: 1464:        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-2].re_node), (yyvsp[0].re_node));
        -: 1465:
        -: 1466:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1467:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1468:
        -: 1469:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1470:      }
        -: 1471:#line 1472 "re_grammar.c"
    #####: 1472:    break;
        -: 1473:
    #####: 1474:  case 6:
        -: 1475:#line 144 "re_grammar.y"
        -: 1476:      {
        -: 1477:        RE_NODE* node;
        -: 1478:
        -: 1479:        mark_as_not_fast_regexp();
        -: 1480:
        -: 1481:        fail_if_too_many_ast_levels({
        -: 1482:          yr_re_node_destroy((yyvsp[-1].re_node));
        -: 1483:        });
        -: 1484:
        -: 1485:        node = yr_re_node_create(RE_NODE_EMPTY, NULL, NULL);
        -: 1486:
        -: 1487:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1488:        fail_if(node == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1489:
        -: 1490:        (yyval.re_node) = yr_re_node_create(RE_NODE_ALT, (yyvsp[-1].re_node), node);
        -: 1491:
        -: 1492:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1493:      }
        -: 1494:#line 1495 "re_grammar.c"
    #####: 1495:    break;
        -: 1496:
    #####: 1497:  case 7:
        -: 1498:#line 166 "re_grammar.y"
        -: 1499:      {
        -: 1500:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1501:      }
        -: 1502:#line 1503 "re_grammar.c"
    #####: 1503:    break;
        -: 1504:
    #####: 1505:  case 8:
        -: 1506:#line 170 "re_grammar.y"
        -: 1507:      {
        -: 1508:        fail_if_too_many_ast_levels({
        -: 1509:          yr_re_node_destroy((yyvsp[-1].re_node));
        -: 1510:          yr_re_node_destroy((yyvsp[0].re_node));
        -: 1511:        });
        -: 1512:
        -: 1513:        (yyval.re_node) = yr_re_node_create(RE_NODE_CONCAT, (yyvsp[-1].re_node), (yyvsp[0].re_node));
        -: 1514:
        -: 1515:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1516:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[0].re_node));
        -: 1517:
        -: 1518:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1519:      }
        -: 1520:#line 1521 "re_grammar.c"
    #####: 1521:    break;
        -: 1522:
    #####: 1523:  case 9:
        -: 1524:#line 187 "re_grammar.y"
        -: 1525:      {
        -: 1526:        RE_AST* re_ast;
        -: 1527:
        -: 1528:        mark_as_not_fast_regexp();
        -: 1529:
        -: 1530:        re_ast = yyget_extra(yyscanner);
        -: 1531:        re_ast->flags |= RE_FLAGS_GREEDY;
        -: 1532:
        -: 1533:        (yyval.re_node) = yr_re_node_create(RE_NODE_STAR, (yyvsp[-1].re_node), NULL);
        -: 1534:
        -: 1535:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1536:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1537:      }
        -: 1538:#line 1539 "re_grammar.c"
    #####: 1539:    break;
        -: 1540:
    #####: 1541:  case 10:
        -: 1542:#line 201 "re_grammar.y"
        -: 1543:      {
        -: 1544:        RE_AST* re_ast;
        -: 1545:
        -: 1546:        mark_as_not_fast_regexp();
        -: 1547:
        -: 1548:        re_ast = yyget_extra(yyscanner);
        -: 1549:        re_ast->flags |= RE_FLAGS_UNGREEDY;
        -: 1550:
        -: 1551:        (yyval.re_node) = yr_re_node_create(RE_NODE_STAR, (yyvsp[-2].re_node), NULL);
        -: 1552:
        -: 1553:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1554:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1555:
        -: 1556:        (yyval.re_node)->greedy = false;
        -: 1557:      }
        -: 1558:#line 1559 "re_grammar.c"
    #####: 1559:    break;
        -: 1560:
    #####: 1561:  case 11:
        -: 1562:#line 217 "re_grammar.y"
        -: 1563:      {
        -: 1564:        RE_AST* re_ast;
        -: 1565:
        -: 1566:        mark_as_not_fast_regexp();
        -: 1567:
        -: 1568:        re_ast = yyget_extra(yyscanner);
        -: 1569:        re_ast->flags |= RE_FLAGS_GREEDY;
        -: 1570:
        -: 1571:        (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS, (yyvsp[-1].re_node), NULL);
        -: 1572:
        -: 1573:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1574:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1575:      }
        -: 1576:#line 1577 "re_grammar.c"
    #####: 1577:    break;
        -: 1578:
    #####: 1579:  case 12:
        -: 1580:#line 231 "re_grammar.y"
        -: 1581:      {
        -: 1582:        RE_AST* re_ast;
        -: 1583:
        -: 1584:        mark_as_not_fast_regexp();
        -: 1585:
        -: 1586:        re_ast = yyget_extra(yyscanner);
        -: 1587:        re_ast->flags |= RE_FLAGS_UNGREEDY;
        -: 1588:
        -: 1589:        (yyval.re_node) = yr_re_node_create(RE_NODE_PLUS, (yyvsp[-2].re_node), NULL);
        -: 1590:
        -: 1591:        destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1592:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1593:
        -: 1594:        (yyval.re_node)->greedy = false;
        -: 1595:      }
        -: 1596:#line 1597 "re_grammar.c"
    #####: 1597:    break;
        -: 1598:
    #####: 1599:  case 13:
        -: 1600:#line 247 "re_grammar.y"
        -: 1601:      {
        -: 1602:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1603:        re_ast->flags |= RE_FLAGS_GREEDY;
        -: 1604:
        -: 1605:        if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)
        -: 1606:        {
        -: 1607:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -: 1608:          destroy_node_if(true, (yyvsp[-1].re_node));
        -: 1609:        }
        -: 1610:        else
        -: 1611:        {
        -: 1612:          mark_as_not_fast_regexp();
        -: 1613:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-1].re_node), NULL);
        -: 1614:          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1615:        }
        -: 1616:
        -: 1617:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1618:
        -: 1619:        (yyval.re_node)->start = 0;
        -: 1620:        (yyval.re_node)->end = 1;
        -: 1621:      }
        -: 1622:#line 1623 "re_grammar.c"
    #####: 1623:    break;
        -: 1624:
    #####: 1625:  case 14:
        -: 1626:#line 269 "re_grammar.y"
        -: 1627:      {
        -: 1628:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1629:        re_ast->flags |= RE_FLAGS_UNGREEDY;
        -: 1630:
        -: 1631:        if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)
        -: 1632:        {
        -: 1633:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -: 1634:          destroy_node_if(true, (yyvsp[-2].re_node));
        -: 1635:        }
        -: 1636:        else
        -: 1637:        {
        -: 1638:          mark_as_not_fast_regexp();
        -: 1639:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-2].re_node), NULL);
        -: 1640:          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1641:        }
        -: 1642:
        -: 1643:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1644:
        -: 1645:        (yyval.re_node)->start = 0;
        -: 1646:        (yyval.re_node)->end = 1;
        -: 1647:        (yyval.re_node)->greedy = false;
        -: 1648:      }
        -: 1649:#line 1650 "re_grammar.c"
    #####: 1650:    break;
        -: 1651:
    #####: 1652:  case 15:
        -: 1653:#line 292 "re_grammar.y"
        -: 1654:      {
        -: 1655:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1656:        re_ast->flags |= RE_FLAGS_GREEDY;
        -: 1657:
        -: 1658:        if ((yyvsp[-1].re_node)->type == RE_NODE_ANY)
        -: 1659:        {
        -: 1660:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -: 1661:          destroy_node_if(true, (yyvsp[-1].re_node));
        -: 1662:        }
        -: 1663:        else
        -: 1664:        {
        -: 1665:          mark_as_not_fast_regexp();
        -: 1666:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-1].re_node), NULL);
        -: 1667:          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-1].re_node));
        -: 1668:        }
        -: 1669:
        -: 1670:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1671:
        -: 1672:        (yyval.re_node)->start = (yyvsp[0].range) & 0xFFFF;;
        -: 1673:        (yyval.re_node)->end = (yyvsp[0].range) >> 16;;
        -: 1674:      }
        -: 1675:#line 1676 "re_grammar.c"
    #####: 1676:    break;
        -: 1677:
    #####: 1678:  case 16:
        -: 1679:#line 314 "re_grammar.y"
        -: 1680:      {
        -: 1681:        RE_AST* re_ast = yyget_extra(yyscanner);
        -: 1682:        re_ast->flags |= RE_FLAGS_UNGREEDY;
        -: 1683:
        -: 1684:        if ((yyvsp[-2].re_node)->type == RE_NODE_ANY)
        -: 1685:        {
        -: 1686:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE_ANY, NULL, NULL);
        -: 1687:          destroy_node_if(true, (yyvsp[-2].re_node));
        -: 1688:        }
        -: 1689:        else
        -: 1690:        {
        -: 1691:          mark_as_not_fast_regexp();
        -: 1692:          (yyval.re_node) = yr_re_node_create(RE_NODE_RANGE, (yyvsp[-2].re_node), NULL);
        -: 1693:          destroy_node_if((yyval.re_node) == NULL, (yyvsp[-2].re_node));
        -: 1694:        }
        -: 1695:
        -: 1696:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1697:
        -: 1698:        (yyval.re_node)->start = (yyvsp[-1].range) & 0xFFFF;;
        -: 1699:        (yyval.re_node)->end = (yyvsp[-1].range) >> 16;;
        -: 1700:        (yyval.re_node)->greedy = false;
        -: 1701:      }
        -: 1702:#line 1703 "re_grammar.c"
    #####: 1703:    break;
        -: 1704:
    #####: 1705:  case 17:
        -: 1706:#line 337 "re_grammar.y"
        -: 1707:      {
        -: 1708:        (yyval.re_node) = (yyvsp[0].re_node);
        -: 1709:      }
        -: 1710:#line 1711 "re_grammar.c"
    #####: 1711:    break;
        -: 1712:
    #####: 1713:  case 18:
        -: 1714:#line 341 "re_grammar.y"
        -: 1715:      {
        -: 1716:        (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_BOUNDARY, NULL, NULL);
        -: 1717:
        -: 1718:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1719:      }
        -: 1720:#line 1721 "re_grammar.c"
    #####: 1721:    break;
        -: 1722:
    #####: 1723:  case 19:
        -: 1724:#line 347 "re_grammar.y"
        -: 1725:      {
        -: 1726:        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_BOUNDARY, NULL, NULL);
        -: 1727:
        -: 1728:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1729:      }
        -: 1730:#line 1731 "re_grammar.c"
    #####: 1731:    break;
        -: 1732:
    #####: 1733:  case 20:
        -: 1734:#line 353 "re_grammar.y"
        -: 1735:      {
        -: 1736:        (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_START, NULL, NULL);
        -: 1737:
        -: 1738:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1739:      }
        -: 1740:#line 1741 "re_grammar.c"
    #####: 1741:    break;
        -: 1742:
    #####: 1743:  case 21:
        -: 1744:#line 359 "re_grammar.y"
        -: 1745:      {
        -: 1746:        (yyval.re_node) = yr_re_node_create(RE_NODE_ANCHOR_END, NULL, NULL);
        -: 1747:
        -: 1748:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1749:      }
        -: 1750:#line 1751 "re_grammar.c"
    #####: 1751:    break;
        -: 1752:
    #####: 1753:  case 22:
        -: 1754:#line 368 "re_grammar.y"
        -: 1755:      {
        -: 1756:        fail_if_too_many_ast_levels({
        -: 1757:          yr_re_node_destroy((yyvsp[-1].re_node));
        -: 1758:        });
        -: 1759:
        -: 1760:        (yyval.re_node) = (yyvsp[-1].re_node);
        -: 1761:      }
        -: 1762:#line 1763 "re_grammar.c"
    #####: 1763:    break;
        -: 1764:
    #####: 1765:  case 23:
        -: 1766:#line 376 "re_grammar.y"
        -: 1767:      {
        -: 1768:        (yyval.re_node) = yr_re_node_create(RE_NODE_ANY, NULL, NULL);
        -: 1769:
        -: 1770:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1771:      }
        -: 1772:#line 1773 "re_grammar.c"
    #####: 1773:    break;
        -: 1774:
    #####: 1775:  case 24:
        -: 1776:#line 382 "re_grammar.y"
        -: 1777:      {
        -: 1778:        (yyval.re_node) = yr_re_node_create(RE_NODE_LITERAL, NULL, NULL);
        -: 1779:
        -: 1780:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1781:
        -: 1782:        (yyval.re_node)->value = (yyvsp[0].integer);
        -: 1783:      }
        -: 1784:#line 1785 "re_grammar.c"
    #####: 1785:    break;
        -: 1786:
    #####: 1787:  case 25:
        -: 1788:#line 390 "re_grammar.y"
        -: 1789:      {
        -: 1790:        (yyval.re_node) = yr_re_node_create(RE_NODE_WORD_CHAR, NULL, NULL);
        -: 1791:
        -: 1792:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1793:      }
        -: 1794:#line 1795 "re_grammar.c"
    #####: 1795:    break;
        -: 1796:
    #####: 1797:  case 26:
        -: 1798:#line 396 "re_grammar.y"
        -: 1799:      {
        -: 1800:        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_WORD_CHAR, NULL, NULL);
        -: 1801:
        -: 1802:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1803:      }
        -: 1804:#line 1805 "re_grammar.c"
    #####: 1805:    break;
        -: 1806:
    #####: 1807:  case 27:
        -: 1808:#line 402 "re_grammar.y"
        -: 1809:      {
        -: 1810:        (yyval.re_node) = yr_re_node_create(RE_NODE_SPACE, NULL, NULL);
        -: 1811:
        -: 1812:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1813:      }
        -: 1814:#line 1815 "re_grammar.c"
    #####: 1815:    break;
        -: 1816:
    #####: 1817:  case 28:
        -: 1818:#line 408 "re_grammar.y"
        -: 1819:      {
        -: 1820:         (yyval.re_node) = yr_re_node_create(RE_NODE_NON_SPACE, NULL, NULL);
        -: 1821:
        -: 1822:         fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1823:      }
        -: 1824:#line 1825 "re_grammar.c"
    #####: 1825:    break;
        -: 1826:
    #####: 1827:  case 29:
        -: 1828:#line 414 "re_grammar.y"
        -: 1829:      {
        -: 1830:        (yyval.re_node) = yr_re_node_create(RE_NODE_DIGIT, NULL, NULL);
        -: 1831:
        -: 1832:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1833:      }
        -: 1834:#line 1835 "re_grammar.c"
    #####: 1835:    break;
        -: 1836:
    #####: 1837:  case 30:
        -: 1838:#line 420 "re_grammar.y"
        -: 1839:      {
        -: 1840:        (yyval.re_node) = yr_re_node_create(RE_NODE_NON_DIGIT, NULL, NULL);
        -: 1841:
        -: 1842:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1843:      }
        -: 1844:#line 1845 "re_grammar.c"
    #####: 1845:    break;
        -: 1846:
    #####: 1847:  case 31:
        -: 1848:#line 426 "re_grammar.y"
        -: 1849:      {
        -: 1850:        (yyval.re_node) = yr_re_node_create(RE_NODE_CLASS, NULL, NULL);
        -: 1851:
        -: 1852:        fail_if((yyval.re_node) == NULL, ERROR_INSUFFICIENT_MEMORY);
        -: 1853:
        -: 1854:        (yyval.re_node)->re_class = (yyvsp[0].re_class);
        -: 1855:      }
        -: 1856:#line 1857 "re_grammar.c"
    #####: 1857:    break;
        -: 1858:
        -: 1859:
        -: 1860:#line 1861 "re_grammar.c"
        -: 1861:
    #####: 1862:      default: break;
        -: 1863:    }
        -: 1864:  /* User semantic actions sometimes alter yychar, and that requires
        -: 1865:     that yytoken be updated with the new translation.  We take the
        -: 1866:     approach of translating immediately before every use of yytoken.
        -: 1867:     One alternative is translating here after every semantic action,
        -: 1868:     but that translation would be missed if the semantic action invokes
        -: 1869:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 1870:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 1871:     incorrect destructor might then be invoked immediately.  In the
        -: 1872:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 1873:     to an incorrect destructor call or verbose syntax error message
        -: 1874:     before the lookahead is translated.  */
        -: 1875:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 1876:
    #####: 1877:  YYPOPSTACK (yylen);
    #####: 1878:  yylen = 0;
        -: 1879:  YY_STACK_PRINT (yyss, yyssp);
        -: 1880:
    #####: 1881:  *++yyvsp = yyval;
        -: 1882:
        -: 1883:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 1884:     that goes to, based on the state we popped back to and the rule
        -: 1885:     number reduced by.  */
        -: 1886:  {
    #####: 1887:    const int yylhs = yyr1[yyn] - YYNTOKENS;
    #####: 1888:    const int yyi = yypgoto[yylhs] + *yyssp;
    #####: 1889:    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
    #####: 1890:               ? yytable[yyi]
    #####: 1891:               : yydefgoto[yylhs]);
        -: 1892:  }
        -: 1893:
    #####: 1894:  goto yynewstate;
        -: 1895:
        -: 1896:
        -: 1897:/*--------------------------------------.
        -: 1898:| yyerrlab -- here on detecting error.  |
        -: 1899:`--------------------------------------*/
    #####: 1900:yyerrlab:
        -: 1901:  /* Make sure we have latest lookahead translation.  See comments at
        -: 1902:     user semantic actions for why this is necessary.  */
    #####: 1903:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 1904:
        -: 1905:  /* If not already recovering from an error, report this error.  */
    #####: 1906:  if (!yyerrstatus)
        -: 1907:    {
    #####: 1908:      ++yynerrs;
        -: 1909:#if ! YYERROR_VERBOSE
        -: 1910:      yyerror (yyscanner, lex_env, YY_("syntax error"));
        -: 1911:#else
        -: 1912:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 1913:                                        yyssp, yytoken)
        -: 1914:      {
    #####: 1915:        char const *yymsgp = YY_("syntax error");
        -: 1916:        int yysyntax_error_status;
    #####: 1917:        yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 1918:        if (yysyntax_error_status == 0)
    #####: 1919:          yymsgp = yymsg;
    #####: 1920:        else if (yysyntax_error_status == 1)
        -: 1921:          {
    #####: 1922:            if (yymsg != yymsgbuf)
    #####: 1923:              YYSTACK_FREE (yymsg);
    #####: 1924:            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
    #####: 1925:            if (!yymsg)
        -: 1926:              {
    #####: 1927:                yymsg = yymsgbuf;
    #####: 1928:                yymsg_alloc = sizeof yymsgbuf;
    #####: 1929:                yysyntax_error_status = 2;
        -: 1930:              }
        -: 1931:            else
        -: 1932:              {
    #####: 1933:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 1934:                yymsgp = yymsg;
        -: 1935:              }
        -: 1936:          }
    #####: 1937:        yyerror (yyscanner, lex_env, yymsgp);
    #####: 1938:        if (yysyntax_error_status == 2)
    #####: 1939:          goto yyexhaustedlab;
        -: 1940:      }
        -: 1941:# undef YYSYNTAX_ERROR
        -: 1942:#endif
        -: 1943:    }
        -: 1944:
        -: 1945:
        -: 1946:
    #####: 1947:  if (yyerrstatus == 3)
        -: 1948:    {
        -: 1949:      /* If just tried and failed to reuse lookahead token after an
        -: 1950:         error, discard it.  */
        -: 1951:
    #####: 1952:      if (yychar <= YYEOF)
        -: 1953:        {
        -: 1954:          /* Return failure if at end of input.  */
    #####: 1955:          if (yychar == YYEOF)
    #####: 1956:            YYABORT;
        -: 1957:        }
        -: 1958:      else
        -: 1959:        {
    #####: 1960:          yydestruct ("Error: discarding",
        -: 1961:                      yytoken, &yylval, yyscanner, lex_env);
    #####: 1962:          yychar = YYEMPTY;
        -: 1963:        }
        -: 1964:    }
        -: 1965:
        -: 1966:  /* Else will try to reuse lookahead token after shifting the error
        -: 1967:     token.  */
    #####: 1968:  goto yyerrlab1;
        -: 1969:
        -: 1970:
        -: 1971:/*---------------------------------------------------.
        -: 1972:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 1973:`---------------------------------------------------*/
        -: 1974:yyerrorlab:
        -: 1975:  /* Pacify compilers when the user code never invokes YYERROR and the
        -: 1976:     label yyerrorlab therefore never appears in user code.  */
        -: 1977:  if (0)
        -: 1978:    YYERROR;
        -: 1979:
        -: 1980:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 1981:     this YYERROR.  */
        -: 1982:  YYPOPSTACK (yylen);
        -: 1983:  yylen = 0;
        -: 1984:  YY_STACK_PRINT (yyss, yyssp);
        -: 1985:  yystate = *yyssp;
        -: 1986:  goto yyerrlab1;
        -: 1987:
        -: 1988:
        -: 1989:/*-------------------------------------------------------------.
        -: 1990:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 1991:`-------------------------------------------------------------*/
    #####: 1992:yyerrlab1:
    #####: 1993:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 1994:
        -: 1995:  for (;;)
        -: 1996:    {
    #####: 1997:      yyn = yypact[yystate];
    #####: 1998:      if (!yypact_value_is_default (yyn))
        -: 1999:        {
    #####: 2000:          yyn += YYTERROR;
    #####: 2001:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 2002:            {
    #####: 2003:              yyn = yytable[yyn];
    #####: 2004:              if (0 < yyn)
    #####: 2005:                break;
        -: 2006:            }
        -: 2007:        }
        -: 2008:
        -: 2009:      /* Pop the current state because it cannot handle the error token.  */
    #####: 2010:      if (yyssp == yyss)
    #####: 2011:        YYABORT;
        -: 2012:
        -: 2013:
    #####: 2014:      yydestruct ("Error: popping",
    #####: 2015:                  yystos[yystate], yyvsp, yyscanner, lex_env);
    #####: 2016:      YYPOPSTACK (1);
    #####: 2017:      yystate = *yyssp;
        -: 2018:      YY_STACK_PRINT (yyss, yyssp);
        -: 2019:    }
        -: 2020:
        -: 2021:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 2022:  *++yyvsp = yylval;
        -: 2023:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 2024:
        -: 2025:
        -: 2026:  /* Shift the error token.  */
        -: 2027:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 2028:
    #####: 2029:  yystate = yyn;
    #####: 2030:  goto yynewstate;
        -: 2031:
        -: 2032:
        -: 2033:/*-------------------------------------.
        -: 2034:| yyacceptlab -- YYACCEPT comes here.  |
        -: 2035:`-------------------------------------*/
    #####: 2036:yyacceptlab:
    #####: 2037:  yyresult = 0;
    #####: 2038:  goto yyreturn;
        -: 2039:
        -: 2040:
        -: 2041:/*-----------------------------------.
        -: 2042:| yyabortlab -- YYABORT comes here.  |
        -: 2043:`-----------------------------------*/
    #####: 2044:yyabortlab:
    #####: 2045:  yyresult = 1;
    #####: 2046:  goto yyreturn;
        -: 2047:
        -: 2048:
        -: 2049:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 2050:/*-------------------------------------------------.
        -: 2051:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 2052:`-------------------------------------------------*/
    #####: 2053:yyexhaustedlab:
    #####: 2054:  yyerror (yyscanner, lex_env, YY_("memory exhausted"));
    #####: 2055:  yyresult = 2;
        -: 2056:  /* Fall through.  */
        -: 2057:#endif
        -: 2058:
        -: 2059:
        -: 2060:/*-----------------------------------------------------.
        -: 2061:| yyreturn -- parsing is finished, return the result.  |
        -: 2062:`-----------------------------------------------------*/
    #####: 2063:yyreturn:
    #####: 2064:  if (yychar != YYEMPTY)
        -: 2065:    {
        -: 2066:      /* Make sure we have latest lookahead translation.  See comments at
        -: 2067:         user semantic actions for why this is necessary.  */
    #####: 2068:      yytoken = YYTRANSLATE (yychar);
    #####: 2069:      yydestruct ("Cleanup: discarding lookahead",
        -: 2070:                  yytoken, &yylval, yyscanner, lex_env);
        -: 2071:    }
        -: 2072:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 2073:     this YYABORT or YYACCEPT.  */
    #####: 2074:  YYPOPSTACK (yylen);
        -: 2075:  YY_STACK_PRINT (yyss, yyssp);
    #####: 2076:  while (yyssp != yyss)
        -: 2077:    {
    #####: 2078:      yydestruct ("Cleanup: popping",
    #####: 2079:                  yystos[+*yyssp], yyvsp, yyscanner, lex_env);
    #####: 2080:      YYPOPSTACK (1);
        -: 2081:    }
        -: 2082:#ifndef yyoverflow
    #####: 2083:  if (yyss != yyssa)
    #####: 2084:    YYSTACK_FREE (yyss);
        -: 2085:#endif
        -: 2086:#if YYERROR_VERBOSE
    #####: 2087:  if (yymsg != yymsgbuf)
    #####: 2088:    YYSTACK_FREE (yymsg);
        -: 2089:#endif
    #####: 2090:  return yyresult;
        -: 2091:}
        -: 2092:#line 434 "re_grammar.y"
        -: 2093:
