        -:    0:Source:grammar.c
        -:    0:Graph:/home/workspace/libyara/grammar.gcno
        -:    0:Data:/home/workspace/libyara/grammar.gcda
        -:    0:Runs:6
        -:    1:/* A Bison parser, made by GNU Bison 3.5.1.  */
        -:    2:
        -:    3:/* Bison implementation for Yacc-like parsers in C
        -:    4:
        -:    5:   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
        -:    6:   Inc.
        -:    7:
        -:    8:   This program is free software: you can redistribute it and/or modify
        -:    9:   it under the terms of the GNU General Public License as published by
        -:   10:   the Free Software Foundation, either version 3 of the License, or
        -:   11:   (at your option) any later version.
        -:   12:
        -:   13:   This program is distributed in the hope that it will be useful,
        -:   14:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   15:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   16:   GNU General Public License for more details.
        -:   17:
        -:   18:   You should have received a copy of the GNU General Public License
        -:   19:   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
        -:   20:
        -:   21:/* As a special exception, you may create a larger work that contains
        -:   22:   part or all of the Bison parser skeleton and distribute that work
        -:   23:   under terms of your choice, so long as that work isn't itself a
        -:   24:   parser generator using the skeleton or a modified version thereof
        -:   25:   as a parser skeleton.  Alternatively, if you modify or redistribute
        -:   26:   the parser skeleton itself, you may (at your option) remove this
        -:   27:   special exception, which will cause the skeleton and the resulting
        -:   28:   Bison output files to be licensed under the GNU General Public
        -:   29:   License without this special exception.
        -:   30:
        -:   31:   This special exception was added by the Free Software Foundation in
        -:   32:   version 2.2 of Bison.  */
        -:   33:
        -:   34:/* C LALR(1) parser skeleton written by Richard Stallman, by
        -:   35:   simplifying the original so-called "semantic" parser.  */
        -:   36:
        -:   37:/* All symbols defined below should begin with yy or YY, to avoid
        -:   38:   infringing on user name space.  This should be done even for local
        -:   39:   variables, as they might otherwise be expanded by user macros.
        -:   40:   There are some unavoidable exceptions within include files to
        -:   41:   define necessary library symbols; they are noted "INFRINGES ON
        -:   42:   USER NAME SPACE" below.  */
        -:   43:
        -:   44:/* Undocumented macros, especially those whose name start with YY_,
        -:   45:   are private implementation details.  Do not rely on them.  */
        -:   46:
        -:   47:/* Identify Bison output.  */
        -:   48:#define YYBISON 1
        -:   49:
        -:   50:/* Bison version.  */
        -:   51:#define YYBISON_VERSION "3.5.1"
        -:   52:
        -:   53:/* Skeleton name.  */
        -:   54:#define YYSKELETON_NAME "yacc.c"
        -:   55:
        -:   56:/* Pure parsers.  */
        -:   57:#define YYPURE 1
        -:   58:
        -:   59:/* Push parsers.  */
        -:   60:#define YYPUSH 0
        -:   61:
        -:   62:/* Pull parsers.  */
        -:   63:#define YYPULL 1
        -:   64:
        -:   65:
        -:   66:/* Substitute the variable and function names.  */
        -:   67:#define yyparse         yara_yyparse
        -:   68:#define yylex           yara_yylex
        -:   69:#define yyerror         yara_yyerror
        -:   70:#define yydebug         yara_yydebug
        -:   71:#define yynerrs         yara_yynerrs
        -:   72:
        -:   73:/* First part of user prologue.  */
        -:   74:#line 30 "grammar.y"
        -:   75:
        -:   76:
        -:   77:
        -:   78:#include <assert.h>
        -:   79:#include <stdio.h>
        -:   80:#include <string.h>
        -:   81:#include <limits.h>
        -:   82:#include <stdbool.h>
        -:   83:#include <stdlib.h>
        -:   84:#include <stddef.h>
        -:   85:
        -:   86:#include <yara/integers.h>
        -:   87:#include <yara/utils.h>
        -:   88:#include <yara/strutils.h>
        -:   89:#include <yara/compiler.h>
        -:   90:#include <yara/object.h>
        -:   91:#include <yara/sizedstr.h>
        -:   92:#include <yara/exec.h>
        -:   93:#include <yara/error.h>
        -:   94:#include <yara/mem.h>
        -:   95:#include <yara/lexer.h>
        -:   96:#include <yara/parser.h>
        -:   97:
        -:   98:#if defined(_MSC_VER)
        -:   99:#define llabs _abs64
        -:  100:#endif
        -:  101:
        -:  102:#define YYERROR_VERBOSE
        -:  103:
        -:  104:#define YYMALLOC yr_malloc
        -:  105:#define YYFREE yr_free
        -:  106:
        -:  107:#define INTEGER_SET_ENUMERATION   1
        -:  108:#define INTEGER_SET_RANGE         2
        -:  109:
        -:  110:#define fail_if_error(e) \
        -:  111:    if (e != ERROR_SUCCESS) \
        -:  112:    { \
        -:  113:      compiler->last_error = e; \
        -:  114:      yyerror(yyscanner, compiler, NULL); \
        -:  115:      YYERROR; \
        -:  116:    } \
        -:  117:
        -:  118:
        -:  119:#define check_type_with_cleanup(expression, expected_type, op, cleanup) \
        -:  120:    if (((expression.type) & (expected_type)) == 0) \
        -:  121:    { \
        -:  122:      switch(expression.type) \
        -:  123:      { \
        -:  124:        case EXPRESSION_TYPE_INTEGER: \
        -:  125:          yr_compiler_set_error_extra_info( \
        -:  126:              compiler, "wrong type \"integer\" for " op " operator"); \
        -:  127:          break; \
        -:  128:        case EXPRESSION_TYPE_FLOAT: \
        -:  129:          yr_compiler_set_error_extra_info( \
        -:  130:              compiler, "wrong type \"float\" for " op " operator"); \
        -:  131:          break; \
        -:  132:        case EXPRESSION_TYPE_STRING: \
        -:  133:          yr_compiler_set_error_extra_info( \
        -:  134:              compiler, "wrong type \"string\" for " op " operator"); \
        -:  135:          break; \
        -:  136:        case EXPRESSION_TYPE_BOOLEAN: \
        -:  137:          yr_compiler_set_error_extra_info( \
        -:  138:              compiler, "wrong type \"boolean\" for " op " operator"); \
        -:  139:          break; \
        -:  140:      } \
        -:  141:      cleanup; \
        -:  142:      compiler->last_error = ERROR_WRONG_TYPE; \
        -:  143:      yyerror(yyscanner, compiler, NULL); \
        -:  144:      YYERROR; \
        -:  145:    }
        -:  146:
        -:  147:
        -:  148:#define check_type(expression, expected_type, op) \
        -:  149:    check_type_with_cleanup(expression, expected_type, op, )
        -:  150:
        -:  151:
        -:  152:#line 153 "grammar.c"
        -:  153:
        -:  154:# ifndef YY_CAST
        -:  155:#  ifdef __cplusplus
        -:  156:#   define YY_CAST(Type, Val) static_cast<Type> (Val)
        -:  157:#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
        -:  158:#  else
        -:  159:#   define YY_CAST(Type, Val) ((Type) (Val))
        -:  160:#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
        -:  161:#  endif
        -:  162:# endif
        -:  163:# ifndef YY_NULLPTR
        -:  164:#  if defined __cplusplus
        -:  165:#   if 201103L <= __cplusplus
        -:  166:#    define YY_NULLPTR nullptr
        -:  167:#   else
        -:  168:#    define YY_NULLPTR 0
        -:  169:#   endif
        -:  170:#  else
        -:  171:#   define YY_NULLPTR ((void*)0)
        -:  172:#  endif
        -:  173:# endif
        -:  174:
        -:  175:/* Enabling verbose error messages.  */
        -:  176:#ifdef YYERROR_VERBOSE
        -:  177:# undef YYERROR_VERBOSE
        -:  178:# define YYERROR_VERBOSE 1
        -:  179:#else
        -:  180:# define YYERROR_VERBOSE 0
        -:  181:#endif
        -:  182:
        -:  183:/* Use api.header.include to #include this header
        -:  184:   instead of duplicating it here.  */
        -:  185:#ifndef YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  186:# define YY_YARA_YY_GRAMMAR_H_INCLUDED
        -:  187:/* Debug traces.  */
        -:  188:#ifndef YYDEBUG
        -:  189:# define YYDEBUG 0
        -:  190:#endif
        -:  191:#if YYDEBUG
        -:  192:extern int yara_yydebug;
        -:  193:#endif
        -:  194:
        -:  195:/* Token type.  */
        -:  196:#ifndef YYTOKENTYPE
        -:  197:# define YYTOKENTYPE
        -:  198:  enum yytokentype
        -:  199:  {
        -:  200:    _DOT_DOT_ = 258,
        -:  201:    _RULE_ = 259,
        -:  202:    _PRIVATE_ = 260,
        -:  203:    _GLOBAL_ = 261,
        -:  204:    _META_ = 262,
        -:  205:    _STRINGS_ = 263,
        -:  206:    _CONDITION_ = 264,
        -:  207:    _IDENTIFIER_ = 265,
        -:  208:    _STRING_IDENTIFIER_ = 266,
        -:  209:    _STRING_COUNT_ = 267,
        -:  210:    _STRING_OFFSET_ = 268,
        -:  211:    _STRING_LENGTH_ = 269,
        -:  212:    _STRING_IDENTIFIER_WITH_WILDCARD_ = 270,
        -:  213:    _NUMBER_ = 271,
        -:  214:    _DOUBLE_ = 272,
        -:  215:    _INTEGER_FUNCTION_ = 273,
        -:  216:    _TEXT_STRING_ = 274,
        -:  217:    _HEX_STRING_ = 275,
        -:  218:    _REGEXP_ = 276,
        -:  219:    _ASCII_ = 277,
        -:  220:    _WIDE_ = 278,
        -:  221:    _XOR_ = 279,
        -:  222:    _NOCASE_ = 280,
        -:  223:    _FULLWORD_ = 281,
        -:  224:    _AT_ = 282,
        -:  225:    _FILESIZE_ = 283,
        -:  226:    _ENTRYPOINT_ = 284,
        -:  227:    _ALL_ = 285,
        -:  228:    _ANY_ = 286,
        -:  229:    _IN_ = 287,
        -:  230:    _OF_ = 288,
        -:  231:    _FOR_ = 289,
        -:  232:    _THEM_ = 290,
        -:  233:    _MATCHES_ = 291,
        -:  234:    _CONTAINS_ = 292,
        -:  235:    _IMPORT_ = 293,
        -:  236:    _TRUE_ = 294,
        -:  237:    _FALSE_ = 295,
        -:  238:    _OR_ = 296,
        -:  239:    _AND_ = 297,
        -:  240:    _EQ_ = 298,
        -:  241:    _NEQ_ = 299,
        -:  242:    _LT_ = 300,
        -:  243:    _LE_ = 301,
        -:  244:    _GT_ = 302,
        -:  245:    _GE_ = 303,
        -:  246:    _SHIFT_LEFT_ = 304,
        -:  247:    _SHIFT_RIGHT_ = 305,
        -:  248:    _NOT_ = 306,
        -:  249:    UNARY_MINUS = 307
        -:  250:  };
        -:  251:#endif
        -:  252:/* Tokens.  */
        -:  253:#define _DOT_DOT_ 258
        -:  254:#define _RULE_ 259
        -:  255:#define _PRIVATE_ 260
        -:  256:#define _GLOBAL_ 261
        -:  257:#define _META_ 262
        -:  258:#define _STRINGS_ 263
        -:  259:#define _CONDITION_ 264
        -:  260:#define _IDENTIFIER_ 265
        -:  261:#define _STRING_IDENTIFIER_ 266
        -:  262:#define _STRING_COUNT_ 267
        -:  263:#define _STRING_OFFSET_ 268
        -:  264:#define _STRING_LENGTH_ 269
        -:  265:#define _STRING_IDENTIFIER_WITH_WILDCARD_ 270
        -:  266:#define _NUMBER_ 271
        -:  267:#define _DOUBLE_ 272
        -:  268:#define _INTEGER_FUNCTION_ 273
        -:  269:#define _TEXT_STRING_ 274
        -:  270:#define _HEX_STRING_ 275
        -:  271:#define _REGEXP_ 276
        -:  272:#define _ASCII_ 277
        -:  273:#define _WIDE_ 278
        -:  274:#define _XOR_ 279
        -:  275:#define _NOCASE_ 280
        -:  276:#define _FULLWORD_ 281
        -:  277:#define _AT_ 282
        -:  278:#define _FILESIZE_ 283
        -:  279:#define _ENTRYPOINT_ 284
        -:  280:#define _ALL_ 285
        -:  281:#define _ANY_ 286
        -:  282:#define _IN_ 287
        -:  283:#define _OF_ 288
        -:  284:#define _FOR_ 289
        -:  285:#define _THEM_ 290
        -:  286:#define _MATCHES_ 291
        -:  287:#define _CONTAINS_ 292
        -:  288:#define _IMPORT_ 293
        -:  289:#define _TRUE_ 294
        -:  290:#define _FALSE_ 295
        -:  291:#define _OR_ 296
        -:  292:#define _AND_ 297
        -:  293:#define _EQ_ 298
        -:  294:#define _NEQ_ 299
        -:  295:#define _LT_ 300
        -:  296:#define _LE_ 301
        -:  297:#define _GT_ 302
        -:  298:#define _GE_ 303
        -:  299:#define _SHIFT_LEFT_ 304
        -:  300:#define _SHIFT_RIGHT_ 305
        -:  301:#define _NOT_ 306
        -:  302:#define UNARY_MINUS 307
        -:  303:
        -:  304:/* Value type.  */
        -:  305:#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
        -:  306:union YYSTYPE
        -:  307:{
        -:  308:#line 218 "grammar.y"
        -:  309:
        -:  310:  EXPRESSION      expression;
        -:  311:  SIZED_STRING*   sized_string;
        -:  312:  char*           c_string;
        -:  313:  int64_t         integer;
        -:  314:  double          double_;
        -:  315:  YR_STRING*      string;
        -:  316:  YR_META*        meta;
        -:  317:  YR_RULE*        rule;
        -:  318:
        -:  319:#line 320 "grammar.c"
        -:  320:
        -:  321:};
        -:  322:typedef union YYSTYPE YYSTYPE;
        -:  323:# define YYSTYPE_IS_TRIVIAL 1
        -:  324:# define YYSTYPE_IS_DECLARED 1
        -:  325:#endif
        -:  326:
        -:  327:
        -:  328:
        -:  329:int yara_yyparse (void *yyscanner, YR_COMPILER* compiler);
        -:  330:
        -:  331:#endif /* !YY_YARA_YY_GRAMMAR_H_INCLUDED  */
        -:  332:
        -:  333:
        -:  334:
        -:  335:#ifdef short
        -:  336:# undef short
        -:  337:#endif
        -:  338:
        -:  339:/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
        -:  340:   <limits.h> and (if available) <stdint.h> are included
        -:  341:   so that the code can choose integer types of a good width.  */
        -:  342:
        -:  343:#ifndef __PTRDIFF_MAX__
        -:  344:# include <limits.h> /* INFRINGES ON USER NAME SPACE */
        -:  345:# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  346:#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
        -:  347:#  define YY_STDINT_H
        -:  348:# endif
        -:  349:#endif
        -:  350:
        -:  351:/* Narrow types that promote to a signed type and that can represent a
        -:  352:   signed or unsigned integer of at least N bits.  In tables they can
        -:  353:   save space and decrease cache pressure.  Promoting to a signed type
        -:  354:   helps avoid bugs in integer arithmetic.  */
        -:  355:
        -:  356:#ifdef __INT_LEAST8_MAX__
        -:  357:typedef __INT_LEAST8_TYPE__ yytype_int8;
        -:  358:#elif defined YY_STDINT_H
        -:  359:typedef int_least8_t yytype_int8;
        -:  360:#else
        -:  361:typedef signed char yytype_int8;
        -:  362:#endif
        -:  363:
        -:  364:#ifdef __INT_LEAST16_MAX__
        -:  365:typedef __INT_LEAST16_TYPE__ yytype_int16;
        -:  366:#elif defined YY_STDINT_H
        -:  367:typedef int_least16_t yytype_int16;
        -:  368:#else
        -:  369:typedef short yytype_int16;
        -:  370:#endif
        -:  371:
        -:  372:#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
        -:  373:typedef __UINT_LEAST8_TYPE__ yytype_uint8;
        -:  374:#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
        -:  375:       && UINT_LEAST8_MAX <= INT_MAX)
        -:  376:typedef uint_least8_t yytype_uint8;
        -:  377:#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
        -:  378:typedef unsigned char yytype_uint8;
        -:  379:#else
        -:  380:typedef short yytype_uint8;
        -:  381:#endif
        -:  382:
        -:  383:#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
        -:  384:typedef __UINT_LEAST16_TYPE__ yytype_uint16;
        -:  385:#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
        -:  386:       && UINT_LEAST16_MAX <= INT_MAX)
        -:  387:typedef uint_least16_t yytype_uint16;
        -:  388:#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
        -:  389:typedef unsigned short yytype_uint16;
        -:  390:#else
        -:  391:typedef int yytype_uint16;
        -:  392:#endif
        -:  393:
        -:  394:#ifndef YYPTRDIFF_T
        -:  395:# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
        -:  396:#  define YYPTRDIFF_T __PTRDIFF_TYPE__
        -:  397:#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
        -:  398:# elif defined PTRDIFF_MAX
        -:  399:#  ifndef ptrdiff_t
        -:  400:#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  401:#  endif
        -:  402:#  define YYPTRDIFF_T ptrdiff_t
        -:  403:#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
        -:  404:# else
        -:  405:#  define YYPTRDIFF_T long
        -:  406:#  define YYPTRDIFF_MAXIMUM LONG_MAX
        -:  407:# endif
        -:  408:#endif
        -:  409:
        -:  410:#ifndef YYSIZE_T
        -:  411:# ifdef __SIZE_TYPE__
        -:  412:#  define YYSIZE_T __SIZE_TYPE__
        -:  413:# elif defined size_t
        -:  414:#  define YYSIZE_T size_t
        -:  415:# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
        -:  416:#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
        -:  417:#  define YYSIZE_T size_t
        -:  418:# else
        -:  419:#  define YYSIZE_T unsigned
        -:  420:# endif
        -:  421:#endif
        -:  422:
        -:  423:#define YYSIZE_MAXIMUM                                  \
        -:  424:  YY_CAST (YYPTRDIFF_T,                                 \
        -:  425:           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
        -:  426:            ? YYPTRDIFF_MAXIMUM                         \
        -:  427:            : YY_CAST (YYSIZE_T, -1)))
        -:  428:
        -:  429:#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
        -:  430:
        -:  431:/* Stored state numbers (used for stacks). */
        -:  432:typedef yytype_uint8 yy_state_t;
        -:  433:
        -:  434:/* State numbers in computations.  */
        -:  435:typedef int yy_state_fast_t;
        -:  436:
        -:  437:#ifndef YY_
        -:  438:# if defined YYENABLE_NLS && YYENABLE_NLS
        -:  439:#  if ENABLE_NLS
        -:  440:#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
        -:  441:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
        -:  442:#  endif
        -:  443:# endif
        -:  444:# ifndef YY_
        -:  445:#  define YY_(Msgid) Msgid
        -:  446:# endif
        -:  447:#endif
        -:  448:
        -:  449:#ifndef YY_ATTRIBUTE_PURE
        -:  450:# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
        -:  451:#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
        -:  452:# else
        -:  453:#  define YY_ATTRIBUTE_PURE
        -:  454:# endif
        -:  455:#endif
        -:  456:
        -:  457:#ifndef YY_ATTRIBUTE_UNUSED
        -:  458:# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
        -:  459:#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
        -:  460:# else
        -:  461:#  define YY_ATTRIBUTE_UNUSED
        -:  462:# endif
        -:  463:#endif
        -:  464:
        -:  465:/* Suppress unused-variable warnings by "using" E.  */
        -:  466:#if ! defined lint || defined __GNUC__
        -:  467:# define YYUSE(E) ((void) (E))
        -:  468:#else
        -:  469:# define YYUSE(E) /* empty */
        -:  470:#endif
        -:  471:
        -:  472:#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
        -:  473:/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
        -:  474:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
        -:  475:    _Pragma ("GCC diagnostic push")                                     \
        -:  476:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
        -:  477:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
        -:  478:# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
        -:  479:    _Pragma ("GCC diagnostic pop")
        -:  480:#else
        -:  481:# define YY_INITIAL_VALUE(Value) Value
        -:  482:#endif
        -:  483:#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  484:# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -:  485:# define YY_IGNORE_MAYBE_UNINITIALIZED_END
        -:  486:#endif
        -:  487:#ifndef YY_INITIAL_VALUE
        -:  488:# define YY_INITIAL_VALUE(Value) /* Nothing. */
        -:  489:#endif
        -:  490:
        -:  491:#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
        -:  492:# define YY_IGNORE_USELESS_CAST_BEGIN                          \
        -:  493:    _Pragma ("GCC diagnostic push")                            \
        -:  494:    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
        -:  495:# define YY_IGNORE_USELESS_CAST_END            \
        -:  496:    _Pragma ("GCC diagnostic pop")
        -:  497:#endif
        -:  498:#ifndef YY_IGNORE_USELESS_CAST_BEGIN
        -:  499:# define YY_IGNORE_USELESS_CAST_BEGIN
        -:  500:# define YY_IGNORE_USELESS_CAST_END
        -:  501:#endif
        -:  502:
        -:  503:
        -:  504:#define YY_ASSERT(E) ((void) (0 && (E)))
        -:  505:
        -:  506:#if ! defined yyoverflow || YYERROR_VERBOSE
        -:  507:
        -:  508:/* The parser invokes alloca or malloc; define the necessary symbols.  */
        -:  509:
        -:  510:# ifdef YYSTACK_USE_ALLOCA
        -:  511:#  if YYSTACK_USE_ALLOCA
        -:  512:#   ifdef __GNUC__
        -:  513:#    define YYSTACK_ALLOC __builtin_alloca
        -:  514:#   elif defined __BUILTIN_VA_ARG_INCR
        -:  515:#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
        -:  516:#   elif defined _AIX
        -:  517:#    define YYSTACK_ALLOC __alloca
        -:  518:#   elif defined _MSC_VER
        -:  519:#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
        -:  520:#    define alloca _alloca
        -:  521:#   else
        -:  522:#    define YYSTACK_ALLOC alloca
        -:  523:#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
        -:  524:#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  525:      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
        -:  526:#     ifndef EXIT_SUCCESS
        -:  527:#      define EXIT_SUCCESS 0
        -:  528:#     endif
        -:  529:#    endif
        -:  530:#   endif
        -:  531:#  endif
        -:  532:# endif
        -:  533:
        -:  534:# ifdef YYSTACK_ALLOC
        -:  535:   /* Pacify GCC's 'empty if-body' warning.  */
        -:  536:#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
        -:  537:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  538:    /* The OS might guarantee only one guard page at the bottom of the stack,
        -:  539:       and a page size can be as small as 4096 bytes.  So we cannot safely
        -:  540:       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        -:  541:       to allow for a few compiler-allocated temporary stack slots.  */
        -:  542:#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
        -:  543:#  endif
        -:  544:# else
        -:  545:#  define YYSTACK_ALLOC YYMALLOC
        -:  546:#  define YYSTACK_FREE YYFREE
        -:  547:#  ifndef YYSTACK_ALLOC_MAXIMUM
        -:  548:#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
        -:  549:#  endif
        -:  550:#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
        -:  551:       && ! ((defined YYMALLOC || defined malloc) \
        -:  552:             && (defined YYFREE || defined free)))
        -:  553:#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
        -:  554:#   ifndef EXIT_SUCCESS
        -:  555:#    define EXIT_SUCCESS 0
        -:  556:#   endif
        -:  557:#  endif
        -:  558:#  ifndef YYMALLOC
        -:  559:#   define YYMALLOC malloc
        -:  560:#   if ! defined malloc && ! defined EXIT_SUCCESS
        -:  561:void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
        -:  562:#   endif
        -:  563:#  endif
        -:  564:#  ifndef YYFREE
        -:  565:#   define YYFREE free
        -:  566:#   if ! defined free && ! defined EXIT_SUCCESS
        -:  567:void free (void *); /* INFRINGES ON USER NAME SPACE */
        -:  568:#   endif
        -:  569:#  endif
        -:  570:# endif
        -:  571:#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
        -:  572:
        -:  573:
        -:  574:#if (! defined yyoverflow \
        -:  575:     && (! defined __cplusplus \
        -:  576:         || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
        -:  577:
        -:  578:/* A type that is properly aligned for any stack member.  */
        -:  579:union yyalloc
        -:  580:{
        -:  581:  yy_state_t yyss_alloc;
        -:  582:  YYSTYPE yyvs_alloc;
        -:  583:};
        -:  584:
        -:  585:/* The size of the maximum gap between one aligned stack and the next.  */
        -:  586:# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
        -:  587:
        -:  588:/* The size of an array large to enough to hold all stacks, each with
        -:  589:   N elements.  */
        -:  590:# define YYSTACK_BYTES(N) \
        -:  591:     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE)) \
        -:  592:      + YYSTACK_GAP_MAXIMUM)
        -:  593:
        -:  594:# define YYCOPY_NEEDED 1
        -:  595:
        -:  596:/* Relocate STACK from its old location to the new one.  The
        -:  597:   local variables YYSIZE and YYSTACKSIZE give the old and new number of
        -:  598:   elements in the stack, and YYPTR gives the new location of the
        -:  599:   stack.  Advance YYPTR to a properly aligned location for the next
        -:  600:   stack.  */
        -:  601:# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
        -:  602:    do                                                                  \
        -:  603:      {                                                                 \
        -:  604:        YYPTRDIFF_T yynewbytes;                                         \
        -:  605:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
        -:  606:        Stack = &yyptr->Stack_alloc;                                    \
        -:  607:        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
        -:  608:        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
        -:  609:      }                                                                 \
        -:  610:    while (0)
        -:  611:
        -:  612:#endif
        -:  613:
        -:  614:#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
        -:  615:/* Copy COUNT objects from SRC to DST.  The source and destination do
        -:  616:   not overlap.  */
        -:  617:# ifndef YYCOPY
        -:  618:#  if defined __GNUC__ && 1 < __GNUC__
        -:  619:#   define YYCOPY(Dst, Src, Count) \
        -:  620:      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
        -:  621:#  else
        -:  622:#   define YYCOPY(Dst, Src, Count)              \
        -:  623:      do                                        \
        -:  624:        {                                       \
        -:  625:          YYPTRDIFF_T yyi;                      \
        -:  626:          for (yyi = 0; yyi < (Count); yyi++)   \
        -:  627:            (Dst)[yyi] = (Src)[yyi];            \
        -:  628:        }                                       \
        -:  629:      while (0)
        -:  630:#  endif
        -:  631:# endif
        -:  632:#endif /* !YYCOPY_NEEDED */
        -:  633:
        -:  634:/* YYFINAL -- State number of the termination state.  */
        -:  635:#define YYFINAL  2
        -:  636:/* YYLAST -- Last index in YYTABLE.  */
        -:  637:#define YYLAST   396
        -:  638:
        -:  639:/* YYNTOKENS -- Number of terminals.  */
        -:  640:#define YYNTOKENS  73
        -:  641:/* YYNNTS -- Number of nonterminals.  */
        -:  642:#define YYNNTS  41
        -:  643:/* YYNRULES -- Number of rules.  */
        -:  644:#define YYNRULES  123
        -:  645:/* YYNSTATES -- Number of states.  */
        -:  646:#define YYNSTATES  211
        -:  647:
        -:  648:#define YYUNDEFTOK  2
        -:  649:#define YYMAXUTOK   308
        -:  650:
        -:  651:
        -:  652:/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
        -:  653:   as returned by yylex, with out-of-bounds checking.  */
        -:  654:#define YYTRANSLATE(YYX)                                                \
        -:  655:  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
        -:  656:
        -:  657:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
        -:  658:   as returned by yylex.  */
        -:  659:static const yytype_int8 yytranslate[] =
        -:  660:{
        -:  661:       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  662:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  663:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  664:       2,     2,     2,     2,     2,     2,     2,    58,    45,     2,
        -:  665:      70,    71,    56,    54,    72,    55,    67,     2,     2,     2,
        -:  666:       2,     2,     2,     2,     2,     2,     2,     2,    65,     2,
        -:  667:       2,    66,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  668:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  669:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  670:       2,    68,    57,    69,    44,     2,     2,     2,     2,     2,
        -:  671:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  672:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  673:       2,     2,     2,    63,    43,    64,    60,     2,     2,     2,
        -:  674:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  675:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  676:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  677:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  678:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  679:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  680:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  681:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  682:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  683:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  684:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  685:       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        -:  686:       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
        -:  687:       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
        -:  688:      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
        -:  689:      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
        -:  690:      35,    36,    37,    38,    39,    40,    41,    42,    46,    47,
        -:  691:      48,    49,    50,    51,    52,    53,    59,    61,    62
        -:  692:};
        -:  693:
        -:  694:#if YYDEBUG
        -:  695:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
        -:  696:static const yytype_int16 yyrline[] =
        -:  697:{
        -:  698:       0,   233,   233,   234,   235,   236,   237,   238,   243,   256,
        -:  699:     261,   255,   282,   285,   313,   316,   341,   346,   347,   352,
        -:  700:     353,   359,   362,   380,   389,   428,   429,   434,   451,   465,
        -:  701:     479,   493,   511,   512,   518,   517,   533,   532,   548,   562,
        -:  702:     563,   568,   569,   570,   571,   572,   577,   663,   710,   769,
        -:  703:     815,   816,   820,   848,   888,   931,   951,   958,   965,   977,
        -:  704:     987,  1001,  1014,  1025,  1036,  1065,  1035,  1179,  1178,  1256,
        -:  705:    1262,  1269,  1268,  1314,  1313,  1357,  1364,  1371,  1378,  1385,
        -:  706:    1392,  1399,  1403,  1411,  1412,  1417,  1441,  1454,  1472,  1471,
        -:  707:    1477,  1489,  1490,  1495,  1502,  1513,  1514,  1518,  1526,  1530,
        -:  708:    1538,  1550,  1564,  1572,  1579,  1604,  1616,  1628,  1644,  1656,
        -:  709:    1672,  1719,  1740,  1775,  1810,  1844,  1869,  1886,  1896,  1906,
        -:  710:    1916,  1926,  1944,  1962
        -:  711:};
        -:  712:#endif
        -:  713:
        -:  714:#if YYDEBUG || YYERROR_VERBOSE || 0
        -:  715:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
        -:  716:   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
        -:  717:static const char *const yytname[] =
        -:  718:{
        -:  719:  "$end", "error", "$undefined", "_DOT_DOT_", "_RULE_", "_PRIVATE_",
        -:  720:  "_GLOBAL_", "_META_", "_STRINGS_", "_CONDITION_", "_IDENTIFIER_",
        -:  721:  "_STRING_IDENTIFIER_", "_STRING_COUNT_", "_STRING_OFFSET_",
        -:  722:  "_STRING_LENGTH_", "_STRING_IDENTIFIER_WITH_WILDCARD_", "_NUMBER_",
        -:  723:  "_DOUBLE_", "_INTEGER_FUNCTION_", "_TEXT_STRING_", "_HEX_STRING_",
        -:  724:  "_REGEXP_", "_ASCII_", "_WIDE_", "_XOR_", "_NOCASE_", "_FULLWORD_",
        -:  725:  "_AT_", "_FILESIZE_", "_ENTRYPOINT_", "_ALL_", "_ANY_", "_IN_", "_OF_",
        -:  726:  "_FOR_", "_THEM_", "_MATCHES_", "_CONTAINS_", "_IMPORT_", "_TRUE_",
        -:  727:  "_FALSE_", "_OR_", "_AND_", "'|'", "'^'", "'&'", "_EQ_", "_NEQ_", "_LT_",
        -:  728:  "_LE_", "_GT_", "_GE_", "_SHIFT_LEFT_", "_SHIFT_RIGHT_", "'+'", "'-'",
        -:  729:  "'*'", "'\\\\'", "'%'", "_NOT_", "'~'", "UNARY_MINUS", "\"include\"",
        -:  730:  "'{'", "'}'", "':'", "'='", "'.'", "'['", "']'", "'('", "')'", "','",
        -:  731:  "$accept", "rules", "import", "rule", "@1", "$@2", "meta", "strings",
        -:  732:  "condition", "rule_modifiers", "rule_modifier", "tags", "tag_list",
        -:  733:  "meta_declarations", "meta_declaration", "string_declarations",
        -:  734:  "string_declaration", "$@3", "$@4", "string_modifiers",
        -:  735:  "string_modifier", "identifier", "arguments", "arguments_list", "regexp",
        -:  736:  "boolean_expression", "expression", "$@5", "$@6", "$@7", "$@8", "$@9",
        -:  737:  "integer_set", "range", "integer_enumeration", "string_set", "$@10",
        -:  738:  "string_enumeration", "string_enumeration_item", "for_expression",
        -:  739:  "primary_expression", YY_NULLPTR
        -:  740:};
        -:  741:#endif
        -:  742:
        -:  743:# ifdef YYPRINT
        -:  744:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
        -:  745:   (internal) symbol number NUM (which must be that of a token).  */
        -:  746:static const yytype_int16 yytoknum[] =
        -:  747:{
        -:  748:       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
        -:  749:     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
        -:  750:     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
        -:  751:     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
        -:  752:     295,   296,   297,   124,    94,    38,   298,   299,   300,   301,
        -:  753:     302,   303,   304,   305,    43,    45,    42,    92,    37,   306,
        -:  754:     126,   307,   308,   123,   125,    58,    61,    46,    91,    93,
        -:  755:      40,    41,    44
        -:  756:};
        -:  757:# endif
        -:  758:
        -:  759:#define YYPACT_NINF (-73)
        -:  760:
        -:  761:#define yypact_value_is_default(Yyn) \
        -:  762:  ((Yyn) == YYPACT_NINF)
        -:  763:
        -:  764:#define YYTABLE_NINF (-96)
        -:  765:
        -:  766:#define yytable_value_is_error(Yyn) \
        -:  767:  0
        -:  768:
        -:  769:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
        -:  770:     STATE-NUM.  */
        -:  771:static const yytype_int16 yypact[] =
        -:  772:{
        -:  773:     -73,    90,   -73,   -33,   -16,   -73,   -73,    69,   -73,   -73,
        -:  774:     -73,   -73,     5,   -73,   -73,   -73,   -73,   -42,    44,   -38,
        -:  775:     -73,    60,    61,   -73,    21,    72,    79,    41,   -73,    64,
        -:  776:      79,   -73,   129,   141,    16,   -73,    85,   129,   -73,    80,
        -:  777:      96,   -73,   -73,   -73,   -73,   145,    81,   -73,    48,   -73,
        -:  778:     -73,   -73,   143,   150,   -73,   -10,   -73,   104,   111,   -73,
        -:  779:     -73,   114,   -73,   -73,   -73,   -73,   -73,   -73,   103,   -73,
        -:  780:     -73,   125,    48,   125,    48,   -34,   -73,    68,   -73,   148,
        -:  781:     293,   -73,   -73,   125,   116,   125,   125,   125,   125,    71,
        -:  782:     309,   -73,   -73,   -73,    68,   133,   170,   172,   125,    48,
        -:  783:     -73,   -73,    -7,   184,   125,   125,   125,   125,   125,   125,
        -:  784:     125,   125,   125,   125,   125,   125,   125,   125,   125,   125,
        -:  785:     125,   152,   152,   309,   125,   -73,   230,   248,   112,   190,
        -:  786:     -73,   176,    -7,   -73,   -73,   -73,   266,   138,   139,    70,
        -:  787:      48,    48,   -73,   -73,   -73,   -73,   309,   324,   338,   -44,
        -:  788:     309,   309,   309,   309,   309,   309,   136,   136,    27,    27,
        -:  789:     -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   -73,   144,
        -:  790:     -73,   -73,   -73,   -73,   147,   -73,   -73,    48,   168,   -73,
        -:  791:      15,   125,   159,   -73,    70,   -73,   -73,    54,   -73,   210,
        -:  792:     125,   165,   -73,   161,   -73,    15,   -73,    77,   144,   -73,
        -:  793:      48,   -73,   -73,   125,   162,    56,   309,    48,   -73,    58,
        -:  794:     -73
        -:  795:};
        -:  796:
        -:  797:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
        -:  798:     Performed when YYTABLE does not specify something else to do.  Zero
        -:  799:     means the default is an error.  */
        -:  800:static const yytype_int8 yydefact[] =
        -:  801:{
        -:  802:       2,     0,     1,    17,     0,     4,     3,     0,     7,     6,
        -:  803:       5,     8,     0,    19,    20,    18,     9,    21,     0,     0,
        -:  804:      23,    22,    12,    24,     0,    14,     0,     0,    10,     0,
        -:  805:      13,    25,     0,     0,     0,    26,     0,    15,    32,     0,
        -:  806:       0,    28,    27,    30,    31,     0,    34,    33,     0,    11,
        -:  807:      29,    38,     0,     0,    46,    60,   105,   107,   109,   102,
        -:  808:     103,     0,   104,    54,    99,   100,    96,    97,     0,    56,
        -:  809:      57,     0,     0,     0,     0,   110,   123,    16,    55,     0,
        -:  810:      81,    39,    39,     0,     0,     0,     0,     0,     0,     0,
        -:  811:      95,   111,    70,   120,     0,    55,    81,     0,     0,    50,
        -:  812:      73,    71,     0,     0,     0,     0,     0,     0,     0,     0,
        -:  813:       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
        -:  814:       0,    35,    37,    61,     0,    62,     0,     0,     0,     0,
        -:  815:      63,     0,     0,    82,    98,    47,     0,     0,    51,    52,
        -:  816:       0,     0,    90,    88,    69,    58,    59,   119,   117,   118,
        -:  817:      79,    80,    75,    77,    76,    78,   121,   122,   112,   113,
        -:  818:     114,   115,   116,    42,    41,    45,    43,    44,    40,     0,
        -:  819:     106,   108,   101,    64,     0,    48,    49,     0,    74,    72,
        -:  820:       0,     0,     0,    67,    53,    93,    94,     0,    91,     0,
        -:  821:       0,     0,    84,     0,    89,     0,    85,     0,    86,    65,
        -:  822:       0,    92,    83,     0,     0,     0,    87,     0,    68,     0,
        -:  823:      66
        -:  824:};
        -:  825:
        -:  826:  /* YYPGOTO[NTERM-NUM].  */
        -:  827:static const yytype_int16 yypgoto[] =
        -:  828:{
        -:  829:     -73,   -73,   233,   234,   -73,   -73,   -73,   -73,   -73,   -73,
        -:  830:     -73,   -73,   -73,   -73,   208,   -73,   202,   -73,   -73,   158,
        -:  831:     -73,   -73,   -73,   -73,   146,   -48,   -72,   -73,   -73,   -73,
        -:  832:     -73,   -73,   -73,    74,   -73,   118,   -73,   -73,    57,   183,
        -:  833:     -67
        -:  834:};
        -:  835:
        -:  836:  /* YYDEFGOTO[NTERM-NUM].  */
        -:  837:static const yytype_int16 yydefgoto[] =
        -:  838:{
        -:  839:      -1,     1,     5,     6,    17,    33,    25,    28,    40,     7,
        -:  840:      15,    19,    21,    30,    31,    37,    38,    52,    53,   121,
        -:  841:     168,    75,   137,   138,    76,    94,    78,   182,   204,   193,
        -:  842:     141,   140,   191,   125,   197,   144,   180,   187,   188,    79,
        -:  843:      80
        -:  844:};
        -:  845:
        -:  846:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
        -:  847:     positive, shift that token.  If negative, reduce the rule whose
        -:  848:     number is the opposite.  If YYTABLE_NINF, syntax error.  */
        -:  849:static const yytype_int16 yytable[] =
        -:  850:{
        -:  851:      77,    90,    95,    11,    91,     4,    93,    96,   114,   115,
        -:  852:     116,   117,   118,   119,   120,    16,   123,    83,   126,   127,
        -:  853:     128,   129,    84,    18,    92,    22,   185,   139,   142,     8,
        -:  854:     186,   136,    41,    97,    98,    42,    99,   146,   147,   148,
        -:  855:     149,   150,   151,   152,   153,   154,   155,   156,   157,   158,
        -:  856:     159,   160,   161,   162,    20,    43,    44,   169,    54,    55,
        -:  857:      56,    57,    58,   143,    59,    60,    61,    62,    24,    63,
        -:  858:      23,    45,   130,    12,    13,    14,    64,    65,    66,    67,
        -:  859:      27,   131,    68,   118,   119,   120,    26,    69,    70,    29,
        -:  860:       2,     3,   178,   179,   -17,   -17,   -17,   100,   101,   100,
        -:  861:     101,    51,   -36,    71,   132,   184,    32,    72,    73,   100,
        -:  862:     101,   -55,   -55,    54,   189,    56,    57,    58,    74,    59,
        -:  863:      60,    61,    62,   198,    63,   194,   195,   208,     4,   210,
        -:  864:      34,    64,    65,    66,    67,    54,   206,    56,    57,    58,
        -:  865:      36,    59,    60,    61,    62,    48,    63,   181,   202,   203,
        -:  866:      39,    46,   205,    64,    65,   105,   106,   107,    71,   209,
        -:  867:      49,    50,    81,    73,   114,   115,   116,   117,   118,   119,
        -:  868:     120,    82,    85,    88,   163,   164,   165,   166,   167,    86,
        -:  869:      71,   102,   135,   172,    87,    73,   124,   105,   106,   107,
        -:  870:     116,   117,   118,   119,   120,    88,   114,   115,   116,   117,
        -:  871:     118,   119,   120,   -95,   133,    63,   103,   104,   173,   176,
        -:  872:     101,   177,   183,   105,   106,   107,   108,   109,   110,   111,
        -:  873:     112,   113,   114,   115,   116,   117,   118,   119,   120,   190,
        -:  874:     199,   200,   207,   105,   106,   107,     9,    10,    35,    47,
        -:  875:     122,   134,   114,   115,   116,   117,   118,   119,   120,   145,
        -:  876:     174,    89,   201,   105,   106,   107,   192,     0,     0,     0,
        -:  877:       0,   134,   114,   115,   116,   117,   118,   119,   120,     0,
        -:  878:       0,     0,     0,   105,   106,   107,     0,     0,     0,     0,
        -:  879:       0,   196,   114,   115,   116,   117,   118,   119,   120,     0,
        -:  880:       0,   105,   106,   107,     0,     0,     0,     0,     0,   170,
        -:  881:     114,   115,   116,   117,   118,   119,   120,     0,     0,   105,
        -:  882:     106,   107,     0,     0,     0,     0,     0,   171,   114,   115,
        -:  883:     116,   117,   118,   119,   120,     0,   -95,     0,     0,   103,
        -:  884:     104,     0,     0,     0,     0,   175,   105,   106,   107,   108,
        -:  885:     109,   110,   111,   112,   113,   114,   115,   116,   117,   118,
        -:  886:     119,   120,   105,   106,   107,     0,     0,     0,     0,     0,
        -:  887:       0,   114,   115,   116,   117,   118,   119,   120,   106,   107,
        -:  888:       0,     0,     0,     0,     0,     0,   114,   115,   116,   117,
        -:  889:     118,   119,   120,   107,     0,     0,     0,     0,     0,     0,
        -:  890:     114,   115,   116,   117,   118,   119,   120
        -:  891:};
        -:  892:
        -:  893:static const yytype_int16 yycheck[] =
        -:  894:{
        -:  895:      48,    68,    74,    19,    71,    38,    73,    74,    52,    53,
        -:  896:      54,    55,    56,    57,    58,    10,    83,    27,    85,    86,
        -:  897:      87,    88,    32,    65,    72,    63,    11,    99,    35,    62,
        -:  898:      15,    98,    16,    67,    68,    19,    70,   104,   105,   106,
        -:  899:     107,   108,   109,   110,   111,   112,   113,   114,   115,   116,
        -:  900:     117,   118,   119,   120,    10,    39,    40,   124,    10,    11,
        -:  901:      12,    13,    14,    70,    16,    17,    18,    19,     7,    21,
        -:  902:      10,    55,     1,     4,     5,     6,    28,    29,    30,    31,
        -:  903:       8,    10,    34,    56,    57,    58,    65,    39,    40,    10,
        -:  904:       0,     1,   140,   141,     4,     5,     6,    41,    42,    41,
        -:  905:      42,    20,    21,    55,    33,   177,    65,    59,    60,    41,
        -:  906:      42,    41,    42,    10,   181,    12,    13,    14,    70,    16,
        -:  907:      17,    18,    19,   190,    21,    71,    72,    71,    38,    71,
        -:  908:      66,    28,    29,    30,    31,    10,   203,    12,    13,    14,
        -:  909:      11,    16,    17,    18,    19,    65,    21,     3,    71,    72,
        -:  910:       9,    66,   200,    28,    29,    43,    44,    45,    55,   207,
        -:  911:      64,    16,    19,    60,    52,    53,    54,    55,    56,    57,
        -:  912:      58,    21,    68,    70,    22,    23,    24,    25,    26,    68,
        -:  913:      55,    33,    10,    71,    70,    60,    70,    43,    44,    45,
        -:  914:      54,    55,    56,    57,    58,    70,    52,    53,    54,    55,
        -:  915:      56,    57,    58,    33,    71,    21,    36,    37,    32,    71,
        -:  916:      42,    72,    65,    43,    44,    45,    46,    47,    48,    49,
        -:  917:      50,    51,    52,    53,    54,    55,    56,    57,    58,    70,
        -:  918:      65,    70,    70,    43,    44,    45,     3,     3,    30,    37,
        -:  919:      82,    71,    52,    53,    54,    55,    56,    57,    58,   103,
        -:  920:     132,    68,   195,    43,    44,    45,   182,    -1,    -1,    -1,
        -:  921:      -1,    71,    52,    53,    54,    55,    56,    57,    58,    -1,
        -:  922:      -1,    -1,    -1,    43,    44,    45,    -1,    -1,    -1,    -1,
        -:  923:      -1,    71,    52,    53,    54,    55,    56,    57,    58,    -1,
        -:  924:      -1,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,    69,
        -:  925:      52,    53,    54,    55,    56,    57,    58,    -1,    -1,    43,
        -:  926:      44,    45,    -1,    -1,    -1,    -1,    -1,    69,    52,    53,
        -:  927:      54,    55,    56,    57,    58,    -1,    33,    -1,    -1,    36,
        -:  928:      37,    -1,    -1,    -1,    -1,    69,    43,    44,    45,    46,
        -:  929:      47,    48,    49,    50,    51,    52,    53,    54,    55,    56,
        -:  930:      57,    58,    43,    44,    45,    -1,    -1,    -1,    -1,    -1,
        -:  931:      -1,    52,    53,    54,    55,    56,    57,    58,    44,    45,
        -:  932:      -1,    -1,    -1,    -1,    -1,    -1,    52,    53,    54,    55,
        -:  933:      56,    57,    58,    45,    -1,    -1,    -1,    -1,    -1,    -1,
        -:  934:      52,    53,    54,    55,    56,    57,    58
        -:  935:};
        -:  936:
        -:  937:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
        -:  938:     symbol of state STATE-NUM.  */
        -:  939:static const yytype_int8 yystos[] =
        -:  940:{
        -:  941:       0,    74,     0,     1,    38,    75,    76,    82,    62,    75,
        -:  942:      76,    19,     4,     5,     6,    83,    10,    77,    65,    84,
        -:  943:      10,    85,    63,    10,     7,    79,    65,     8,    80,    10,
        -:  944:      86,    87,    65,    78,    66,    87,    11,    88,    89,     9,
        -:  945:      81,    16,    19,    39,    40,    55,    66,    89,    65,    64,
        -:  946:      16,    20,    90,    91,    10,    11,    12,    13,    14,    16,
        -:  947:      17,    18,    19,    21,    28,    29,    30,    31,    34,    39,
        -:  948:      40,    55,    59,    60,    70,    94,    97,    98,    99,   112,
        -:  949:     113,    19,    21,    27,    32,    68,    68,    70,    70,   112,
        -:  950:     113,   113,    98,   113,    98,    99,   113,    67,    68,    70,
        -:  951:      41,    42,    33,    36,    37,    43,    44,    45,    46,    47,
        -:  952:      48,    49,    50,    51,    52,    53,    54,    55,    56,    57,
        -:  953:      58,    92,    92,   113,    70,   106,   113,   113,   113,   113,
        -:  954:       1,    10,    33,    71,    71,    10,   113,    95,    96,    99,
        -:  955:     104,   103,    35,    70,   108,    97,   113,   113,   113,   113,
        -:  956:     113,   113,   113,   113,   113,   113,   113,   113,   113,   113,
        -:  957:     113,   113,   113,    22,    23,    24,    25,    26,    93,   113,
        -:  958:      69,    69,    71,    32,   108,    69,    71,    72,    98,    98,
        -:  959:     109,     3,   100,    65,    99,    11,    15,   110,   111,   113,
        -:  960:      70,   105,   106,   102,    71,    72,    71,   107,   113,    65,
        -:  961:      70,   111,    71,    72,   101,    98,   113,    70,    71,    98,
        -:  962:      71
        -:  963:};
        -:  964:
        -:  965:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
        -:  966:static const yytype_int8 yyr1[] =
        -:  967:{
        -:  968:       0,    73,    74,    74,    74,    74,    74,    74,    75,    77,
        -:  969:      78,    76,    79,    79,    80,    80,    81,    82,    82,    83,
        -:  970:      83,    84,    84,    85,    85,    86,    86,    87,    87,    87,
        -:  971:      87,    87,    88,    88,    90,    89,    91,    89,    89,    92,
        -:  972:      92,    93,    93,    93,    93,    93,    94,    94,    94,    94,
        -:  973:      95,    95,    96,    96,    97,    98,    99,    99,    99,    99,
        -:  974:      99,    99,    99,    99,   100,   101,    99,   102,    99,    99,
        -:  975:      99,   103,    99,   104,    99,    99,    99,    99,    99,    99,
        -:  976:      99,    99,    99,   105,   105,   106,   107,   107,   109,   108,
        -:  977:     108,   110,   110,   111,   111,   112,   112,   112,   113,   113,
        -:  978:     113,   113,   113,   113,   113,   113,   113,   113,   113,   113,
        -:  979:     113,   113,   113,   113,   113,   113,   113,   113,   113,   113,
        -:  980:     113,   113,   113,   113
        -:  981:};
        -:  982:
        -:  983:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
        -:  984:static const yytype_int8 yyr2[] =
        -:  985:{
        -:  986:       0,     2,     0,     2,     2,     3,     3,     3,     2,     0,
        -:  987:       0,    11,     0,     3,     0,     3,     3,     0,     2,     1,
        -:  988:       1,     0,     2,     1,     2,     1,     2,     3,     3,     4,
        -:  989:       3,     3,     1,     2,     0,     5,     0,     5,     3,     0,
        -:  990:       2,     1,     1,     1,     1,     1,     1,     3,     4,     4,
        -:  991:       0,     1,     1,     3,     1,     1,     1,     1,     3,     3,
        -:  992:       1,     3,     3,     3,     0,     0,    11,     0,     9,     3,
        -:  993:       2,     0,     4,     0,     4,     3,     3,     3,     3,     3,
        -:  994:       3,     1,     3,     3,     1,     5,     1,     3,     0,     4,
        -:  995:       1,     1,     3,     1,     1,     1,     1,     1,     3,     1,
        -:  996:       1,     4,     1,     1,     1,     1,     4,     1,     4,     1,
        -:  997:       1,     2,     3,     3,     3,     3,     3,     3,     3,     3,
        -:  998:       2,     3,     3,     1
        -:  999:};
        -: 1000:
        -: 1001:
        -: 1002:#define yyerrok         (yyerrstatus = 0)
        -: 1003:#define yyclearin       (yychar = YYEMPTY)
        -: 1004:#define YYEMPTY         (-2)
        -: 1005:#define YYEOF           0
        -: 1006:
        -: 1007:#define YYACCEPT        goto yyacceptlab
        -: 1008:#define YYABORT         goto yyabortlab
        -: 1009:#define YYERROR         goto yyerrorlab
        -: 1010:
        -: 1011:
        -: 1012:#define YYRECOVERING()  (!!yyerrstatus)
        -: 1013:
        -: 1014:#define YYBACKUP(Token, Value)                                    \
        -: 1015:  do                                                              \
        -: 1016:    if (yychar == YYEMPTY)                                        \
        -: 1017:      {                                                           \
        -: 1018:        yychar = (Token);                                         \
        -: 1019:        yylval = (Value);                                         \
        -: 1020:        YYPOPSTACK (yylen);                                       \
        -: 1021:        yystate = *yyssp;                                         \
        -: 1022:        goto yybackup;                                            \
        -: 1023:      }                                                           \
        -: 1024:    else                                                          \
        -: 1025:      {                                                           \
        -: 1026:        yyerror (yyscanner, compiler, YY_("syntax error: cannot back up")); \
        -: 1027:        YYERROR;                                                  \
        -: 1028:      }                                                           \
        -: 1029:  while (0)
        -: 1030:
        -: 1031:/* Error token number */
        -: 1032:#define YYTERROR        1
        -: 1033:#define YYERRCODE       256
        -: 1034:
        -: 1035:
        -: 1036:
        -: 1037:/* Enable debugging if requested.  */
        -: 1038:#if YYDEBUG
        -: 1039:
        -: 1040:# ifndef YYFPRINTF
        -: 1041:#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
        -: 1042:#  define YYFPRINTF fprintf
        -: 1043:# endif
        -: 1044:
        -: 1045:# define YYDPRINTF(Args)                        \
        -: 1046:do {                                            \
        -: 1047:  if (yydebug)                                  \
        -: 1048:    YYFPRINTF Args;                             \
        -: 1049:} while (0)
        -: 1050:
        -: 1051:/* This macro is provided for backward compatibility. */
        -: 1052:#ifndef YY_LOCATION_PRINT
        -: 1053:# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
        -: 1054:#endif
        -: 1055:
        -: 1056:
        -: 1057:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
        -: 1058:do {                                                                      \
        -: 1059:  if (yydebug)                                                            \
        -: 1060:    {                                                                     \
        -: 1061:      YYFPRINTF (stderr, "%s ", Title);                                   \
        -: 1062:      yy_symbol_print (stderr,                                            \
        -: 1063:                  Type, Value, yyscanner, compiler); \
        -: 1064:      YYFPRINTF (stderr, "\n");                                           \
        -: 1065:    }                                                                     \
        -: 1066:} while (0)
        -: 1067:
        -: 1068:
        -: 1069:/*-----------------------------------.
        -: 1070:| Print this symbol's value on YYO.  |
        -: 1071:`-----------------------------------*/
        -: 1072:
        -: 1073:static void
        -: 1074:yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1075:{
        -: 1076:  FILE *yyoutput = yyo;
        -: 1077:  YYUSE (yyoutput);
        -: 1078:  YYUSE (yyscanner);
        -: 1079:  YYUSE (compiler);
        -: 1080:  if (!yyvaluep)
        -: 1081:    return;
        -: 1082:# ifdef YYPRINT
        -: 1083:  if (yytype < YYNTOKENS)
        -: 1084:    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
        -: 1085:# endif
        -: 1086:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        -: 1087:  YYUSE (yytype);
        -: 1088:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1089:}
        -: 1090:
        -: 1091:
        -: 1092:/*---------------------------.
        -: 1093:| Print this symbol on YYO.  |
        -: 1094:`---------------------------*/
        -: 1095:
        -: 1096:static void
        -: 1097:yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1098:{
        -: 1099:  YYFPRINTF (yyo, "%s %s (",
        -: 1100:             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
        -: 1101:
        -: 1102:  yy_symbol_value_print (yyo, yytype, yyvaluep, yyscanner, compiler);
        -: 1103:  YYFPRINTF (yyo, ")");
        -: 1104:}
        -: 1105:
        -: 1106:/*------------------------------------------------------------------.
        -: 1107:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
        -: 1108:| TOP (included).                                                   |
        -: 1109:`------------------------------------------------------------------*/
        -: 1110:
        -: 1111:static void
        -: 1112:yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
        -: 1113:{
        -: 1114:  YYFPRINTF (stderr, "Stack now");
        -: 1115:  for (; yybottom <= yytop; yybottom++)
        -: 1116:    {
        -: 1117:      int yybot = *yybottom;
        -: 1118:      YYFPRINTF (stderr, " %d", yybot);
        -: 1119:    }
        -: 1120:  YYFPRINTF (stderr, "\n");
        -: 1121:}
        -: 1122:
        -: 1123:# define YY_STACK_PRINT(Bottom, Top)                            \
        -: 1124:do {                                                            \
        -: 1125:  if (yydebug)                                                  \
        -: 1126:    yy_stack_print ((Bottom), (Top));                           \
        -: 1127:} while (0)
        -: 1128:
        -: 1129:
        -: 1130:/*------------------------------------------------.
        -: 1131:| Report that the YYRULE is going to be reduced.  |
        -: 1132:`------------------------------------------------*/
        -: 1133:
        -: 1134:static void
        -: 1135:yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *yyscanner, YR_COMPILER* compiler)
        -: 1136:{
        -: 1137:  int yylno = yyrline[yyrule];
        -: 1138:  int yynrhs = yyr2[yyrule];
        -: 1139:  int yyi;
        -: 1140:  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
        -: 1141:             yyrule - 1, yylno);
        -: 1142:  /* The symbols being reduced.  */
        -: 1143:  for (yyi = 0; yyi < yynrhs; yyi++)
        -: 1144:    {
        -: 1145:      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
        -: 1146:      yy_symbol_print (stderr,
        -: 1147:                       yystos[+yyssp[yyi + 1 - yynrhs]],
        -: 1148:                       &yyvsp[(yyi + 1) - (yynrhs)]
        -: 1149:                                              , yyscanner, compiler);
        -: 1150:      YYFPRINTF (stderr, "\n");
        -: 1151:    }
        -: 1152:}
        -: 1153:
        -: 1154:# define YY_REDUCE_PRINT(Rule)          \
        -: 1155:do {                                    \
        -: 1156:  if (yydebug)                          \
        -: 1157:    yy_reduce_print (yyssp, yyvsp, Rule, yyscanner, compiler); \
        -: 1158:} while (0)
        -: 1159:
        -: 1160:/* Nonzero means print parse trace.  It is left uninitialized so that
        -: 1161:   multiple parsers can coexist.  */
        -: 1162:int yydebug;
        -: 1163:#else /* !YYDEBUG */
        -: 1164:# define YYDPRINTF(Args)
        -: 1165:# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
        -: 1166:# define YY_STACK_PRINT(Bottom, Top)
        -: 1167:# define YY_REDUCE_PRINT(Rule)
        -: 1168:#endif /* !YYDEBUG */
        -: 1169:
        -: 1170:
        -: 1171:/* YYINITDEPTH -- initial size of the parser's stacks.  */
        -: 1172:#ifndef YYINITDEPTH
        -: 1173:# define YYINITDEPTH 200
        -: 1174:#endif
        -: 1175:
        -: 1176:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
        -: 1177:   if the built-in stack extension method is used).
        -: 1178:
        -: 1179:   Do not make this value too large; the results are undefined if
        -: 1180:   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
        -: 1181:   evaluated with infinite-precision integer arithmetic.  */
        -: 1182:
        -: 1183:#ifndef YYMAXDEPTH
        -: 1184:# define YYMAXDEPTH 10000
        -: 1185:#endif
        -: 1186:
        -: 1187:
        -: 1188:#if YYERROR_VERBOSE
        -: 1189:
        -: 1190:# ifndef yystrlen
        -: 1191:#  if defined __GLIBC__ && defined _STRING_H
        -: 1192:#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
        -: 1193:#  else
        -: 1194:/* Return the length of YYSTR.  */
        -: 1195:static YYPTRDIFF_T
        -: 1196:yystrlen (const char *yystr)
        -: 1197:{
        -: 1198:  YYPTRDIFF_T yylen;
        -: 1199:  for (yylen = 0; yystr[yylen]; yylen++)
        -: 1200:    continue;
        -: 1201:  return yylen;
        -: 1202:}
        -: 1203:#  endif
        -: 1204:# endif
        -: 1205:
        -: 1206:# ifndef yystpcpy
        -: 1207:#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
        -: 1208:#   define yystpcpy stpcpy
        -: 1209:#  else
        -: 1210:/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
        -: 1211:   YYDEST.  */
        -: 1212:static char *
    #####: 1213:yystpcpy (char *yydest, const char *yysrc)
        -: 1214:{
    #####: 1215:  char *yyd = yydest;
    #####: 1216:  const char *yys = yysrc;
        -: 1217:
    #####: 1218:  while ((*yyd++ = *yys++) != '\0')
    #####: 1219:    continue;
        -: 1220:
    #####: 1221:  return yyd - 1;
        -: 1222:}
        -: 1223:#  endif
        -: 1224:# endif
        -: 1225:
        -: 1226:# ifndef yytnamerr
        -: 1227:/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
        -: 1228:   quotes and backslashes, so that it's suitable for yyerror.  The
        -: 1229:   heuristic is that double-quoting is unnecessary unless the string
        -: 1230:   contains an apostrophe, a comma, or backslash (other than
        -: 1231:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
        -: 1232:   null, do not copy; instead, return the length of what the result
        -: 1233:   would have been.  */
        -: 1234:static YYPTRDIFF_T
    #####: 1235:yytnamerr (char *yyres, const char *yystr)
        -: 1236:{
    #####: 1237:  if (*yystr == '"')
        -: 1238:    {
    #####: 1239:      YYPTRDIFF_T yyn = 0;
    #####: 1240:      char const *yyp = yystr;
        -: 1241:
        -: 1242:      for (;;)
    #####: 1243:        switch (*++yyp)
        -: 1244:          {
    #####: 1245:          case '\'':
        -: 1246:          case ',':
    #####: 1247:            goto do_not_strip_quotes;
        -: 1248:
    #####: 1249:          case '\\':
    #####: 1250:            if (*++yyp != '\\')
    #####: 1251:              goto do_not_strip_quotes;
        -: 1252:            else
    #####: 1253:              goto append;
        -: 1254:
    #####: 1255:          append:
        -: 1256:          default:
    #####: 1257:            if (yyres)
    #####: 1258:              yyres[yyn] = *yyp;
    #####: 1259:            yyn++;
    #####: 1260:            break;
        -: 1261:
    #####: 1262:          case '"':
    #####: 1263:            if (yyres)
    #####: 1264:              yyres[yyn] = '\0';
    #####: 1265:            return yyn;
        -: 1266:          }
    #####: 1267:    do_not_strip_quotes: ;
        -: 1268:    }
        -: 1269:
    #####: 1270:  if (yyres)
    #####: 1271:    return yystpcpy (yyres, yystr) - yyres;
        -: 1272:  else
    #####: 1273:    return yystrlen (yystr);
        -: 1274:}
        -: 1275:# endif
        -: 1276:
        -: 1277:/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
        -: 1278:   about the unexpected token YYTOKEN for the state stack whose top is
        -: 1279:   YYSSP.
        -: 1280:
        -: 1281:   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
        -: 1282:   not large enough to hold the message.  In that case, also set
        -: 1283:   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
        -: 1284:   required number of bytes is too large to store.  */
        -: 1285:static int
    #####: 1286:yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
        -: 1287:                yy_state_t *yyssp, int yytoken)
        -: 1288:{
        -: 1289:  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
        -: 1290:  /* Internationalized format string. */
    #####: 1291:  const char *yyformat = YY_NULLPTR;
        -: 1292:  /* Arguments of yyformat: reported tokens (one for the "unexpected",
        -: 1293:     one per "expected"). */
        -: 1294:  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
        -: 1295:  /* Actual size of YYARG. */
    #####: 1296:  int yycount = 0;
        -: 1297:  /* Cumulated lengths of YYARG.  */
    #####: 1298:  YYPTRDIFF_T yysize = 0;
        -: 1299:
        -: 1300:  /* There are many possibilities here to consider:
        -: 1301:     - If this state is a consistent state with a default action, then
        -: 1302:       the only way this function was invoked is if the default action
        -: 1303:       is an error action.  In that case, don't check for expected
        -: 1304:       tokens because there are none.
        -: 1305:     - The only way there can be no lookahead present (in yychar) is if
        -: 1306:       this state is a consistent state with a default action.  Thus,
        -: 1307:       detecting the absence of a lookahead is sufficient to determine
        -: 1308:       that there is no unexpected or expected token to report.  In that
        -: 1309:       case, just report a simple "syntax error".
        -: 1310:     - Don't assume there isn't a lookahead just because this state is a
        -: 1311:       consistent state with a default action.  There might have been a
        -: 1312:       previous inconsistent state, consistent state with a non-default
        -: 1313:       action, or user semantic action that manipulated yychar.
        -: 1314:     - Of course, the expected token list depends on states to have
        -: 1315:       correct lookahead information, and it depends on the parser not
        -: 1316:       to perform extra reductions after fetching a lookahead from the
        -: 1317:       scanner and before detecting a syntax error.  Thus, state merging
        -: 1318:       (from LALR or IELR) and default reductions corrupt the expected
        -: 1319:       token list.  However, the list is correct for canonical LR with
        -: 1320:       one exception: it will still contain any token that will not be
        -: 1321:       accepted due to an error action in a later state.
        -: 1322:  */
    #####: 1323:  if (yytoken != YYEMPTY)
        -: 1324:    {
    #####: 1325:      int yyn = yypact[+*yyssp];
    #####: 1326:      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
    #####: 1327:      yysize = yysize0;
    #####: 1328:      yyarg[yycount++] = yytname[yytoken];
    #####: 1329:      if (!yypact_value_is_default (yyn))
        -: 1330:        {
        -: 1331:          /* Start YYX at -YYN if negative to avoid negative indexes in
        -: 1332:             YYCHECK.  In other words, skip the first -YYN actions for
        -: 1333:             this state because they are default actions.  */
    #####: 1334:          int yyxbegin = yyn < 0 ? -yyn : 0;
        -: 1335:          /* Stay within bounds of both yycheck and yytname.  */
    #####: 1336:          int yychecklim = YYLAST - yyn + 1;
    #####: 1337:          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
        -: 1338:          int yyx;
        -: 1339:
    #####: 1340:          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
    #####: 1341:            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
    #####: 1342:                && !yytable_value_is_error (yytable[yyx + yyn]))
        -: 1343:              {
    #####: 1344:                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
        -: 1345:                  {
    #####: 1346:                    yycount = 1;
    #####: 1347:                    yysize = yysize0;
    #####: 1348:                    break;
        -: 1349:                  }
    #####: 1350:                yyarg[yycount++] = yytname[yyx];
        -: 1351:                {
    #####: 1352:                  YYPTRDIFF_T yysize1
    #####: 1353:                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
    #####: 1354:                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
    #####: 1355:                    yysize = yysize1;
        -: 1356:                  else
    #####: 1357:                    return 2;
        -: 1358:                }
        -: 1359:              }
        -: 1360:        }
        -: 1361:    }
        -: 1362:
    #####: 1363:  switch (yycount)
        -: 1364:    {
        -: 1365:# define YYCASE_(N, S)                      \
        -: 1366:      case N:                               \
        -: 1367:        yyformat = S;                       \
        -: 1368:      break
    #####: 1369:    default: /* Avoid compiler warnings. */
    #####: 1370:      YYCASE_(0, YY_("syntax error"));
    #####: 1371:      YYCASE_(1, YY_("syntax error, unexpected %s"));
    #####: 1372:      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
    #####: 1373:      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
    #####: 1374:      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
    #####: 1375:      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
        -: 1376:# undef YYCASE_
        -: 1377:    }
        -: 1378:
        -: 1379:  {
        -: 1380:    /* Don't count the "%s"s in the final size, but reserve room for
        -: 1381:       the terminator.  */
    #####: 1382:    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
    #####: 1383:    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
    #####: 1384:      yysize = yysize1;
        -: 1385:    else
    #####: 1386:      return 2;
        -: 1387:  }
        -: 1388:
    #####: 1389:  if (*yymsg_alloc < yysize)
        -: 1390:    {
    #####: 1391:      *yymsg_alloc = 2 * yysize;
    #####: 1392:      if (! (yysize <= *yymsg_alloc
        -: 1393:             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
    #####: 1394:        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
    #####: 1395:      return 1;
        -: 1396:    }
        -: 1397:
        -: 1398:  /* Avoid sprintf, as that infringes on the user's name space.
        -: 1399:     Don't have undefined behavior even if the translation
        -: 1400:     produced a string with the wrong number of "%s"s.  */
        -: 1401:  {
    #####: 1402:    char *yyp = *yymsg;
    #####: 1403:    int yyi = 0;
    #####: 1404:    while ((*yyp = *yyformat) != '\0')
    #####: 1405:      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
        -: 1406:        {
    #####: 1407:          yyp += yytnamerr (yyp, yyarg[yyi++]);
    #####: 1408:          yyformat += 2;
        -: 1409:        }
        -: 1410:      else
        -: 1411:        {
    #####: 1412:          ++yyp;
    #####: 1413:          ++yyformat;
        -: 1414:        }
        -: 1415:  }
    #####: 1416:  return 0;
        -: 1417:}
        -: 1418:#endif /* YYERROR_VERBOSE */
        -: 1419:
        -: 1420:/*-----------------------------------------------.
        -: 1421:| Release the memory associated to this symbol.  |
        -: 1422:`-----------------------------------------------*/
        -: 1423:
        -: 1424:static void
        2: 1425:yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *yyscanner, YR_COMPILER* compiler)
        -: 1426:{
        -: 1427:  YYUSE (yyvaluep);
        -: 1428:  YYUSE (yyscanner);
        -: 1429:  YYUSE (compiler);
        2: 1430:  if (!yymsg)
    #####: 1431:    yymsg = "Deleting";
        -: 1432:  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
        -: 1433:
        -: 1434:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        2: 1435:  switch (yytype)
        -: 1436:    {
    #####: 1437:    case 10: /* _IDENTIFIER_  */
        -: 1438:#line 205 "grammar.y"
        -: 1439:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1440:#line 1441 "grammar.c"
    #####: 1441:        break;
        -: 1442:
    #####: 1443:    case 11: /* _STRING_IDENTIFIER_  */
        -: 1444:#line 209 "grammar.y"
        -: 1445:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1446:#line 1447 "grammar.c"
    #####: 1447:        break;
        -: 1448:
    #####: 1449:    case 12: /* _STRING_COUNT_  */
        -: 1450:#line 206 "grammar.y"
        -: 1451:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1452:#line 1453 "grammar.c"
    #####: 1453:        break;
        -: 1454:
    #####: 1455:    case 13: /* _STRING_OFFSET_  */
        -: 1456:#line 207 "grammar.y"
        -: 1457:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1458:#line 1459 "grammar.c"
    #####: 1459:        break;
        -: 1460:
    #####: 1461:    case 14: /* _STRING_LENGTH_  */
        -: 1462:#line 208 "grammar.y"
        -: 1463:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1464:#line 1465 "grammar.c"
    #####: 1465:        break;
        -: 1466:
    #####: 1467:    case 15: /* _STRING_IDENTIFIER_WITH_WILDCARD_  */
        -: 1468:#line 210 "grammar.y"
        -: 1469:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1470:#line 1471 "grammar.c"
    #####: 1471:        break;
        -: 1472:
    #####: 1473:    case 19: /* _TEXT_STRING_  */
        -: 1474:#line 211 "grammar.y"
        -: 1475:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1476:#line 1477 "grammar.c"
    #####: 1477:        break;
        -: 1478:
    #####: 1479:    case 20: /* _HEX_STRING_  */
        -: 1480:#line 212 "grammar.y"
        -: 1481:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1482:#line 1483 "grammar.c"
    #####: 1483:        break;
        -: 1484:
    #####: 1485:    case 21: /* _REGEXP_  */
        -: 1486:#line 213 "grammar.y"
        -: 1487:            { yr_free(((*yyvaluep).sized_string)); ((*yyvaluep).sized_string) = NULL; }
        -: 1488:#line 1489 "grammar.c"
    #####: 1489:        break;
        -: 1490:
    #####: 1491:    case 95: /* arguments  */
        -: 1492:#line 215 "grammar.y"
        -: 1493:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1494:#line 1495 "grammar.c"
    #####: 1495:        break;
        -: 1496:
    #####: 1497:    case 96: /* arguments_list  */
        -: 1498:#line 216 "grammar.y"
        -: 1499:            { yr_free(((*yyvaluep).c_string)); ((*yyvaluep).c_string) = NULL; }
        -: 1500:#line 1501 "grammar.c"
    #####: 1501:        break;
        -: 1502:
        2: 1503:      default:
        2: 1504:        break;
        -: 1505:    }
        -: 1506:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        2: 1507:}
        -: 1508:
        -: 1509:
        -: 1510:
        -: 1511:
        -: 1512:/*----------.
        -: 1513:| yyparse.  |
        -: 1514:`----------*/
        -: 1515:
        -: 1516:int
        1: 1517:yyparse (void *yyscanner, YR_COMPILER* compiler)
        -: 1518:{
        -: 1519:/* The lookahead symbol.  */
        -: 1520:int yychar;
        -: 1521:
        -: 1522:
        -: 1523:/* The semantic value of the lookahead symbol.  */
        -: 1524:/* Default value used for initialization, for pacifying older GCCs
        -: 1525:   or non-GCC compilers.  */
        -: 1526:YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
        -: 1527:YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
        -: 1528:
        -: 1529:    /* Number of syntax errors so far.  */
        -: 1530:    int yynerrs;
        -: 1531:
        -: 1532:    yy_state_fast_t yystate;
        -: 1533:    /* Number of tokens to shift before error messages enabled.  */
        -: 1534:    int yyerrstatus;
        -: 1535:
        -: 1536:    /* The stacks and their tools:
        -: 1537:       'yyss': related to states.
        -: 1538:       'yyvs': related to semantic values.
        -: 1539:
        -: 1540:       Refer to the stacks through separate pointers, to allow yyoverflow
        -: 1541:       to reallocate them elsewhere.  */
        -: 1542:
        -: 1543:    /* The state stack.  */
        -: 1544:    yy_state_t yyssa[YYINITDEPTH];
        -: 1545:    yy_state_t *yyss;
        -: 1546:    yy_state_t *yyssp;
        -: 1547:
        -: 1548:    /* The semantic value stack.  */
        -: 1549:    YYSTYPE yyvsa[YYINITDEPTH];
        -: 1550:    YYSTYPE *yyvs;
        -: 1551:    YYSTYPE *yyvsp;
        -: 1552:
        -: 1553:    YYPTRDIFF_T yystacksize;
        -: 1554:
        -: 1555:  int yyn;
        -: 1556:  int yyresult;
        -: 1557:  /* Lookahead token as an internal (translated) token number.  */
        1: 1558:  int yytoken = 0;
        -: 1559:  /* The variables used to return semantic value and location from the
        -: 1560:     action routines.  */
        -: 1561:  YYSTYPE yyval;
        -: 1562:
        -: 1563:#if YYERROR_VERBOSE
        -: 1564:  /* Buffer for error messages, and its allocated size.  */
        -: 1565:  char yymsgbuf[128];
        1: 1566:  char *yymsg = yymsgbuf;
        1: 1567:  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
        -: 1568:#endif
        -: 1569:
        -: 1570:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
        -: 1571:
        -: 1572:  /* The number of symbols on the RHS of the reduced rule.
        -: 1573:     Keep to zero when no symbol should be popped.  */
        1: 1574:  int yylen = 0;
        -: 1575:
        1: 1576:  yyssp = yyss = yyssa;
        1: 1577:  yyvsp = yyvs = yyvsa;
        1: 1578:  yystacksize = YYINITDEPTH;
        -: 1579:
        -: 1580:  YYDPRINTF ((stderr, "Starting parse\n"));
        -: 1581:
        1: 1582:  yystate = 0;
        1: 1583:  yyerrstatus = 0;
        1: 1584:  yynerrs = 0;
        1: 1585:  yychar = YYEMPTY; /* Cause a token to be read.  */
        1: 1586:  goto yysetstate;
        -: 1587:
        -: 1588:
        -: 1589:/*------------------------------------------------------------.
        -: 1590:| yynewstate -- push a new state, which is found in yystate.  |
        -: 1591:`------------------------------------------------------------*/
       20: 1592:yynewstate:
        -: 1593:  /* In all cases, when you get here, the value and location stacks
        -: 1594:     have just been pushed.  So pushing a state here evens the stacks.  */
       20: 1595:  yyssp++;
        -: 1596:
        -: 1597:
        -: 1598:/*--------------------------------------------------------------------.
        -: 1599:| yysetstate -- set current state (the top of the stack) to yystate.  |
        -: 1600:`--------------------------------------------------------------------*/
       21: 1601:yysetstate:
        -: 1602:  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
        -: 1603:  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
        -: 1604:  YY_IGNORE_USELESS_CAST_BEGIN
       21: 1605:  *yyssp = YY_CAST (yy_state_t, yystate);
        -: 1606:  YY_IGNORE_USELESS_CAST_END
        -: 1607:
       21: 1608:  if (yyss + yystacksize - 1 <= yyssp)
        -: 1609:#if !defined yyoverflow && !defined YYSTACK_RELOCATE
        -: 1610:    goto yyexhaustedlab;
        -: 1611:#else
        -: 1612:    {
        -: 1613:      /* Get the current used size of the three stacks, in elements.  */
    #####: 1614:      YYPTRDIFF_T yysize = yyssp - yyss + 1;
        -: 1615:
        -: 1616:# if defined yyoverflow
        -: 1617:      {
        -: 1618:        /* Give user a chance to reallocate the stack.  Use copies of
        -: 1619:           these so that the &'s don't force the real ones into
        -: 1620:           memory.  */
        -: 1621:        yy_state_t *yyss1 = yyss;
        -: 1622:        YYSTYPE *yyvs1 = yyvs;
        -: 1623:
        -: 1624:        /* Each stack pointer address is followed by the size of the
        -: 1625:           data in use in that stack, in bytes.  This used to be a
        -: 1626:           conditional around just the two extra args, but that might
        -: 1627:           be undefined if yyoverflow is a macro.  */
        -: 1628:        yyoverflow (YY_("memory exhausted"),
        -: 1629:                    &yyss1, yysize * YYSIZEOF (*yyssp),
        -: 1630:                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
        -: 1631:                    &yystacksize);
        -: 1632:        yyss = yyss1;
        -: 1633:        yyvs = yyvs1;
        -: 1634:      }
        -: 1635:# else /* defined YYSTACK_RELOCATE */
        -: 1636:      /* Extend the stack our own way.  */
    #####: 1637:      if (YYMAXDEPTH <= yystacksize)
    #####: 1638:        goto yyexhaustedlab;
    #####: 1639:      yystacksize *= 2;
    #####: 1640:      if (YYMAXDEPTH < yystacksize)
    #####: 1641:        yystacksize = YYMAXDEPTH;
        -: 1642:
        -: 1643:      {
    #####: 1644:        yy_state_t *yyss1 = yyss;
        -: 1645:        union yyalloc *yyptr =
    #####: 1646:          YY_CAST (union yyalloc *,
        -: 1647:                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
    #####: 1648:        if (! yyptr)
    #####: 1649:          goto yyexhaustedlab;
    #####: 1650:        YYSTACK_RELOCATE (yyss_alloc, yyss);
    #####: 1651:        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
        -: 1652:# undef YYSTACK_RELOCATE
    #####: 1653:        if (yyss1 != yyssa)
    #####: 1654:          YYSTACK_FREE (yyss1);
        -: 1655:      }
        -: 1656:# endif
        -: 1657:
    #####: 1658:      yyssp = yyss + yysize - 1;
    #####: 1659:      yyvsp = yyvs + yysize - 1;
        -: 1660:
        -: 1661:      YY_IGNORE_USELESS_CAST_BEGIN
        -: 1662:      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
        -: 1663:                  YY_CAST (long, yystacksize)));
        -: 1664:      YY_IGNORE_USELESS_CAST_END
        -: 1665:
    #####: 1666:      if (yyss + yystacksize - 1 <= yyssp)
    #####: 1667:        YYABORT;
        -: 1668:    }
        -: 1669:#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
        -: 1670:
       21: 1671:  if (yystate == YYFINAL)
        1: 1672:    YYACCEPT;
        -: 1673:
       20: 1674:  goto yybackup;
        -: 1675:
        -: 1676:
        -: 1677:/*-----------.
        -: 1678:| yybackup.  |
        -: 1679:`-----------*/
       20: 1680:yybackup:
        -: 1681:  /* Do appropriate processing given the current state.  Read a
        -: 1682:     lookahead token if we need one and don't already have one.  */
        -: 1683:
        -: 1684:  /* First try to decide what to do without reference to lookahead token.  */
       20: 1685:  yyn = yypact[yystate];
       20: 1686:  if (yypact_value_is_default (yyn))
        7: 1687:    goto yydefault;
        -: 1688:
        -: 1689:  /* Not known => get a lookahead token if don't already have one.  */
        -: 1690:
        -: 1691:  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
       13: 1692:  if (yychar == YYEMPTY)
        -: 1693:    {
        -: 1694:      YYDPRINTF ((stderr, "Reading a token: "));
        8: 1695:      yychar = yylex (&yylval, yyscanner, compiler);
        -: 1696:    }
        -: 1697:
       13: 1698:  if (yychar <= YYEOF)
        -: 1699:    {
        1: 1700:      yychar = yytoken = YYEOF;
        -: 1701:      YYDPRINTF ((stderr, "Now at end of input.\n"));
        -: 1702:    }
        -: 1703:  else
        -: 1704:    {
      12*: 1705:      yytoken = YYTRANSLATE (yychar);
        -: 1706:      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
        -: 1707:    }
        -: 1708:
        -: 1709:  /* If the proper action on seeing token YYTOKEN is to reduce or to
        -: 1710:     detect an error, take that action.  */
       13: 1711:  yyn += yytoken;
       13: 1712:  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
        4: 1713:    goto yydefault;
        9: 1714:  yyn = yytable[yyn];
        9: 1715:  if (yyn <= 0)
        -: 1716:    {
        -: 1717:      if (yytable_value_is_error (yyn))
        -: 1718:        goto yyerrlab;
        1: 1719:      yyn = -yyn;
        1: 1720:      goto yyreduce;
        -: 1721:    }
        -: 1722:
        -: 1723:  /* Count tokens shifted since error; after three, turn off error
        -: 1724:     status.  */
        8: 1725:  if (yyerrstatus)
    #####: 1726:    yyerrstatus--;
        -: 1727:
        -: 1728:  /* Shift the lookahead token.  */
        -: 1729:  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
        8: 1730:  yystate = yyn;
        -: 1731:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
        8: 1732:  *++yyvsp = yylval;
        -: 1733:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 1734:
        -: 1735:  /* Discard the shifted token.  */
        8: 1736:  yychar = YYEMPTY;
        8: 1737:  goto yynewstate;
        -: 1738:
        -: 1739:
        -: 1740:/*-----------------------------------------------------------.
        -: 1741:| yydefault -- do the default action for the current state.  |
        -: 1742:`-----------------------------------------------------------*/
       11: 1743:yydefault:
       11: 1744:  yyn = yydefact[yystate];
       11: 1745:  if (yyn == 0)
    #####: 1746:    goto yyerrlab;
       11: 1747:  goto yyreduce;
        -: 1748:
        -: 1749:
        -: 1750:/*-----------------------------.
        -: 1751:| yyreduce -- do a reduction.  |
        -: 1752:`-----------------------------*/
       12: 1753:yyreduce:
        -: 1754:  /* yyn is the number of a rule to reduce with.  */
       12: 1755:  yylen = yyr2[yyn];
        -: 1756:
        -: 1757:  /* If YYLEN is nonzero, implement the default value of the action:
        -: 1758:     '$$ = $1'.
        -: 1759:
        -: 1760:     Otherwise, the following line sets YYVAL to garbage.
        -: 1761:     This behavior is undocumented and Bison
        -: 1762:     users should not rely upon it.  Assigning to YYVAL
        -: 1763:     unconditionally makes the parser a bit smaller, and it avoids a
        -: 1764:     GCC warning that YYVAL may be used uninitialized.  */
       12: 1765:  yyval = yyvsp[1-yylen];
        -: 1766:
        -: 1767:
        -: 1768:  YY_REDUCE_PRINT (yyn);
       12: 1769:  switch (yyn)
        -: 1770:    {
    #####: 1771:  case 8:
        -: 1772:#line 244 "grammar.y"
        -: 1773:      {
        -: 1774:        int result = yr_parser_reduce_import(yyscanner, (yyvsp[0].sized_string));
        -: 1775:
        -: 1776:        yr_free((yyvsp[0].sized_string));
        -: 1777:
        -: 1778:        fail_if_error(result);
        -: 1779:      }
        -: 1780:#line 1781 "grammar.c"
    #####: 1781:    break;
        -: 1782:
        1: 1783:  case 9:
        -: 1784:#line 256 "grammar.y"
        -: 1785:      {
        -: 1786:        fail_if_error(yr_parser_reduce_rule_declaration_phase_1(
        -: 1787:            yyscanner, (int32_t) (yyvsp[-2].integer), (yyvsp[0].c_string), &(yyval.rule)));
        -: 1788:      }
        -: 1789:#line 1790 "grammar.c"
        1: 1790:    break;
        -: 1791:
        1: 1792:  case 10:
        -: 1793:#line 261 "grammar.y"
        -: 1794:      {
        -: 1795:        YR_RULE* rule = (yyvsp[-4].rule); // rule created in phase 1
        -: 1796:
        -: 1797:        rule->tags = (yyvsp[-3].c_string);
        -: 1798:        rule->metas = (yyvsp[-1].meta);
        -: 1799:        rule->strings = (yyvsp[0].string);
        -: 1800:      }
        -: 1801:#line 1802 "grammar.c"
        1: 1802:    break;
        -: 1803:
        1: 1804:  case 11:
        -: 1805:#line 269 "grammar.y"
        -: 1806:      {
        -: 1807:        int result = yr_parser_reduce_rule_declaration_phase_2(
        -: 1808:            yyscanner, (yyvsp[-7].rule)); // rule created in phase 1
        -: 1809:
        -: 1810:        yr_free((yyvsp[-8].c_string));
        -: 1811:
        -: 1812:        fail_if_error(result);
        -: 1813:      }
        -: 1814:#line 1815 "grammar.c"
        1: 1815:    break;
        -: 1816:
        1: 1817:  case 12:
        -: 1818:#line 282 "grammar.y"
        -: 1819:      {
        -: 1820:        (yyval.meta) = NULL;
        -: 1821:      }
        -: 1822:#line 1823 "grammar.c"
        1: 1823:    break;
        -: 1824:
    #####: 1825:  case 13:
        -: 1826:#line 286 "grammar.y"
        -: 1827:      {
        -: 1828:        // Each rule have a list of meta-data info, consisting in a
        -: 1829:        // sequence of YR_META structures. The last YR_META structure does
        -: 1830:        // not represent a real meta-data, it's just a end-of-list marker
        -: 1831:        // identified by a specific type (META_TYPE_NULL). Here we
        -: 1832:        // write the end-of-list marker.
        -: 1833:
        -: 1834:        YR_META null_meta;
        -: 1835:
        -: 1836:        memset(&null_meta, 0xFF, sizeof(YR_META));
        -: 1837:        null_meta.type = META_TYPE_NULL;
        -: 1838:
        -: 1839:        int result = yr_arena_write_data(
        -: 1840:            compiler->metas_arena,
        -: 1841:            &null_meta,
        -: 1842:            sizeof(YR_META),
        -: 1843:            NULL);
        -: 1844:
        -: 1845:        (yyval.meta) = (yyvsp[0].meta);
        -: 1846:
        -: 1847:        fail_if_error(result);
        -: 1848:      }
        -: 1849:#line 1850 "grammar.c"
    #####: 1850:    break;
        -: 1851:
        1: 1852:  case 14:
        -: 1853:#line 313 "grammar.y"
        -: 1854:      {
        -: 1855:        (yyval.string) = NULL;
        -: 1856:      }
        -: 1857:#line 1858 "grammar.c"
        1: 1858:    break;
        -: 1859:
    #####: 1860:  case 15:
        -: 1861:#line 317 "grammar.y"
        -: 1862:      {
        -: 1863:        // Each rule have a list of strings, consisting in a sequence
        -: 1864:        // of YR_STRING structures. The last YR_STRING structure does not
        -: 1865:        // represent a real string, it's just a end-of-list marker
        -: 1866:        // identified by a specific flag (STRING_FLAGS_NULL). Here we
        -: 1867:        // write the end-of-list marker.
        -: 1868:
        -: 1869:        YR_STRING null_string;
        -: 1870:
        -: 1871:        memset(&null_string, 0xFF, sizeof(YR_STRING));
        -: 1872:        null_string.g_flags = STRING_GFLAGS_NULL;
        -: 1873:
        -: 1874:        fail_if_error(yr_arena_write_data(
        -: 1875:            compiler->strings_arena,
        -: 1876:            &null_string,
        -: 1877:            sizeof(YR_STRING),
        -: 1878:            NULL));
        -: 1879:
        -: 1880:        (yyval.string) = (yyvsp[0].string);
        -: 1881:      }
        -: 1882:#line 1883 "grammar.c"
    #####: 1883:    break;
        -: 1884:
        1: 1885:  case 17:
        -: 1886:#line 346 "grammar.y"
        -: 1887:                                       { (yyval.integer) = 0;  }
        -: 1888:#line 1889 "grammar.c"
        1: 1889:    break;
        -: 1890:
    #####: 1891:  case 18:
        -: 1892:#line 347 "grammar.y"
        -: 1893:                                       { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 1894:#line 1895 "grammar.c"
    #####: 1895:    break;
        -: 1896:
    #####: 1897:  case 19:
        -: 1898:#line 352 "grammar.y"
        -: 1899:                     { (yyval.integer) = RULE_GFLAGS_PRIVATE; }
        -: 1900:#line 1901 "grammar.c"
    #####: 1901:    break;
        -: 1902:
    #####: 1903:  case 20:
        -: 1904:#line 353 "grammar.y"
        -: 1905:                     { (yyval.integer) = RULE_GFLAGS_GLOBAL; }
        -: 1906:#line 1907 "grammar.c"
    #####: 1907:    break;
        -: 1908:
        1: 1909:  case 21:
        -: 1910:#line 359 "grammar.y"
        -: 1911:      {
        -: 1912:        (yyval.c_string) = NULL;
        -: 1913:      }
        -: 1914:#line 1915 "grammar.c"
        1: 1915:    break;
        -: 1916:
    #####: 1917:  case 22:
        -: 1918:#line 363 "grammar.y"
        -: 1919:      {
        -: 1920:        // Tags list is represented in the arena as a sequence
        -: 1921:        // of null-terminated strings, the sequence ends with an
        -: 1922:        // additional null character. Here we write the ending null
        -: 1923:        //character. Example: tag1\0tag2\0tag3\0\0
        -: 1924:
        -: 1925:        int result = yr_arena_write_string(
        -: 1926:            yyget_extra(yyscanner)->sz_arena, "", NULL);
        -: 1927:
        -: 1928:        fail_if_error(result);
        -: 1929:
        -: 1930:        (yyval.c_string) = (yyvsp[0].c_string);
        -: 1931:      }
        -: 1932:#line 1933 "grammar.c"
    #####: 1933:    break;
        -: 1934:
    #####: 1935:  case 23:
        -: 1936:#line 381 "grammar.y"
        -: 1937:      {
        -: 1938:        int result = yr_arena_write_string(
        -: 1939:            yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), &(yyval.c_string));
        -: 1940:
        -: 1941:        yr_free((yyvsp[0].c_string));
        -: 1942:
        -: 1943:        fail_if_error(result);
        -: 1944:      }
        -: 1945:#line 1946 "grammar.c"
    #####: 1946:    break;
        -: 1947:
    #####: 1948:  case 24:
        -: 1949:#line 390 "grammar.y"
        -: 1950:      {
        -: 1951:        int result = ERROR_SUCCESS;
        -: 1952:
        -: 1953:        char* tag_name = (yyvsp[-1].c_string);
        -: 1954:        size_t tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1955:
        -: 1956:        while (tag_length > 0)
        -: 1957:        {
        -: 1958:          if (strcmp(tag_name, (yyvsp[0].c_string)) == 0)
        -: 1959:          {
        -: 1960:            yr_compiler_set_error_extra_info(compiler, tag_name);
        -: 1961:            result = ERROR_DUPLICATED_TAG_IDENTIFIER;
        -: 1962:            break;
        -: 1963:          }
        -: 1964:
        -: 1965:          tag_name = (char*) yr_arena_next_address(
        -: 1966:              yyget_extra(yyscanner)->sz_arena,
        -: 1967:              tag_name,
        -: 1968:              tag_length + 1);
        -: 1969:
        -: 1970:          tag_length = tag_name != NULL ? strlen(tag_name) : 0;
        -: 1971:        }
        -: 1972:
        -: 1973:        if (result == ERROR_SUCCESS)
        -: 1974:          result = yr_arena_write_string(
        -: 1975:              yyget_extra(yyscanner)->sz_arena, (yyvsp[0].c_string), NULL);
        -: 1976:
        -: 1977:        yr_free((yyvsp[0].c_string));
        -: 1978:
        -: 1979:        fail_if_error(result);
        -: 1980:
        -: 1981:        (yyval.c_string) = (yyvsp[-1].c_string);
        -: 1982:      }
        -: 1983:#line 1984 "grammar.c"
    #####: 1984:    break;
        -: 1985:
    #####: 1986:  case 25:
        -: 1987:#line 428 "grammar.y"
        -: 1988:                                          {  (yyval.meta) = (yyvsp[0].meta); }
        -: 1989:#line 1990 "grammar.c"
    #####: 1990:    break;
        -: 1991:
    #####: 1992:  case 26:
        -: 1993:#line 429 "grammar.y"
        -: 1994:                                          {  (yyval.meta) = (yyvsp[-1].meta); }
        -: 1995:#line 1996 "grammar.c"
    #####: 1996:    break;
        -: 1997:
    #####: 1998:  case 27:
        -: 1999:#line 435 "grammar.y"
        -: 2000:      {
        -: 2001:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2002:
        -: 2003:        int result = yr_parser_reduce_meta_declaration(
        -: 2004:            yyscanner,
        -: 2005:            META_TYPE_STRING,
        -: 2006:            (yyvsp[-2].c_string),
        -: 2007:            sized_string->c_string,
        -: 2008:            0,
        -: 2009:            &(yyval.meta));
        -: 2010:
        -: 2011:        yr_free((yyvsp[-2].c_string));
        -: 2012:        yr_free((yyvsp[0].sized_string));
        -: 2013:
        -: 2014:        fail_if_error(result);
        -: 2015:      }
        -: 2016:#line 2017 "grammar.c"
    #####: 2017:    break;
        -: 2018:
    #####: 2019:  case 28:
        -: 2020:#line 452 "grammar.y"
        -: 2021:      {
        -: 2022:        int result = yr_parser_reduce_meta_declaration(
        -: 2023:            yyscanner,
        -: 2024:            META_TYPE_INTEGER,
        -: 2025:            (yyvsp[-2].c_string),
        -: 2026:            NULL,
        -: 2027:            (yyvsp[0].integer),
        -: 2028:            &(yyval.meta));
        -: 2029:
        -: 2030:        yr_free((yyvsp[-2].c_string));
        -: 2031:
        -: 2032:        fail_if_error(result);
        -: 2033:      }
        -: 2034:#line 2035 "grammar.c"
    #####: 2035:    break;
        -: 2036:
    #####: 2037:  case 29:
        -: 2038:#line 466 "grammar.y"
        -: 2039:      {
        -: 2040:        int result = yr_parser_reduce_meta_declaration(
        -: 2041:            yyscanner,
        -: 2042:            META_TYPE_INTEGER,
        -: 2043:            (yyvsp[-3].c_string),
        -: 2044:            NULL,
        -: 2045:            -(yyvsp[0].integer),
        -: 2046:            &(yyval.meta));
        -: 2047:
        -: 2048:        yr_free((yyvsp[-3].c_string));
        -: 2049:
        -: 2050:        fail_if_error(result);
        -: 2051:      }
        -: 2052:#line 2053 "grammar.c"
    #####: 2053:    break;
        -: 2054:
    #####: 2055:  case 30:
        -: 2056:#line 480 "grammar.y"
        -: 2057:      {
        -: 2058:        int result = yr_parser_reduce_meta_declaration(
        -: 2059:            yyscanner,
        -: 2060:            META_TYPE_BOOLEAN,
        -: 2061:            (yyvsp[-2].c_string),
        -: 2062:            NULL,
        -: 2063:            true,
        -: 2064:            &(yyval.meta));
        -: 2065:
        -: 2066:        yr_free((yyvsp[-2].c_string));
        -: 2067:
        -: 2068:        fail_if_error(result);
        -: 2069:      }
        -: 2070:#line 2071 "grammar.c"
    #####: 2071:    break;
        -: 2072:
    #####: 2073:  case 31:
        -: 2074:#line 494 "grammar.y"
        -: 2075:      {
        -: 2076:        int result = yr_parser_reduce_meta_declaration(
        -: 2077:            yyscanner,
        -: 2078:            META_TYPE_BOOLEAN,
        -: 2079:            (yyvsp[-2].c_string),
        -: 2080:            NULL,
        -: 2081:            false,
        -: 2082:            &(yyval.meta));
        -: 2083:
        -: 2084:        yr_free((yyvsp[-2].c_string));
        -: 2085:
        -: 2086:        fail_if_error(result);
        -: 2087:      }
        -: 2088:#line 2089 "grammar.c"
    #####: 2089:    break;
        -: 2090:
    #####: 2091:  case 32:
        -: 2092:#line 511 "grammar.y"
        -: 2093:                                              { (yyval.string) = (yyvsp[0].string); }
        -: 2094:#line 2095 "grammar.c"
    #####: 2095:    break;
        -: 2096:
    #####: 2097:  case 33:
        -: 2098:#line 512 "grammar.y"
        -: 2099:                                              { (yyval.string) = (yyvsp[-1].string); }
        -: 2100:#line 2101 "grammar.c"
    #####: 2101:    break;
        -: 2102:
    #####: 2103:  case 34:
        -: 2104:#line 518 "grammar.y"
        -: 2105:      {
        -: 2106:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2107:      }
        -: 2108:#line 2109 "grammar.c"
    #####: 2109:    break;
        -: 2110:
    #####: 2111:  case 35:
        -: 2112:#line 522 "grammar.y"
        -: 2113:      {
        -: 2114:        int result = yr_parser_reduce_string_declaration(
        -: 2115:            yyscanner, (int32_t) (yyvsp[0].integer), (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2116:
        -: 2117:        yr_free((yyvsp[-4].c_string));
        -: 2118:        yr_free((yyvsp[-1].sized_string));
        -: 2119:
        -: 2120:        fail_if_error(result);
        -: 2121:        compiler->current_line = 0;
        -: 2122:      }
        -: 2123:#line 2124 "grammar.c"
    #####: 2124:    break;
        -: 2125:
    #####: 2126:  case 36:
        -: 2127:#line 533 "grammar.y"
        -: 2128:      {
        -: 2129:        compiler->current_line = yyget_lineno(yyscanner);
        -: 2130:      }
        -: 2131:#line 2132 "grammar.c"
    #####: 2132:    break;
        -: 2133:
    #####: 2134:  case 37:
        -: 2135:#line 537 "grammar.y"
        -: 2136:      {
        -: 2137:        int result = yr_parser_reduce_string_declaration(
        -: 2138:            yyscanner, (int32_t) (yyvsp[0].integer) | STRING_GFLAGS_REGEXP, (yyvsp[-4].c_string), (yyvsp[-1].sized_string), &(yyval.string));
        -: 2139:
        -: 2140:        yr_free((yyvsp[-4].c_string));
        -: 2141:        yr_free((yyvsp[-1].sized_string));
        -: 2142:
        -: 2143:        fail_if_error(result);
        -: 2144:
        -: 2145:        compiler->current_line = 0;
        -: 2146:      }
        -: 2147:#line 2148 "grammar.c"
    #####: 2148:    break;
        -: 2149:
    #####: 2150:  case 38:
        -: 2151:#line 549 "grammar.y"
        -: 2152:      {
        -: 2153:        int result = yr_parser_reduce_string_declaration(
        -: 2154:            yyscanner, STRING_GFLAGS_HEXADECIMAL, (yyvsp[-2].c_string), (yyvsp[0].sized_string), &(yyval.string));
        -: 2155:
        -: 2156:        yr_free((yyvsp[-2].c_string));
        -: 2157:        yr_free((yyvsp[0].sized_string));
        -: 2158:
        -: 2159:        fail_if_error(result);
        -: 2160:      }
        -: 2161:#line 2162 "grammar.c"
    #####: 2162:    break;
        -: 2163:
    #####: 2164:  case 39:
        -: 2165:#line 562 "grammar.y"
        -: 2166:                                          { (yyval.integer) = 0; }
        -: 2167:#line 2168 "grammar.c"
    #####: 2168:    break;
        -: 2169:
    #####: 2170:  case 40:
        -: 2171:#line 563 "grammar.y"
        -: 2172:                                          { (yyval.integer) = (yyvsp[-1].integer) | (yyvsp[0].integer); }
        -: 2173:#line 2174 "grammar.c"
    #####: 2174:    break;
        -: 2175:
    #####: 2176:  case 41:
        -: 2177:#line 568 "grammar.y"
        -: 2178:                    { (yyval.integer) = STRING_GFLAGS_WIDE; }
        -: 2179:#line 2180 "grammar.c"
    #####: 2180:    break;
        -: 2181:
    #####: 2182:  case 42:
        -: 2183:#line 569 "grammar.y"
        -: 2184:                    { (yyval.integer) = STRING_GFLAGS_ASCII; }
        -: 2185:#line 2186 "grammar.c"
    #####: 2186:    break;
        -: 2187:
    #####: 2188:  case 43:
        -: 2189:#line 570 "grammar.y"
        -: 2190:                    { (yyval.integer) = STRING_GFLAGS_NO_CASE; }
        -: 2191:#line 2192 "grammar.c"
    #####: 2192:    break;
        -: 2193:
    #####: 2194:  case 44:
        -: 2195:#line 571 "grammar.y"
        -: 2196:                    { (yyval.integer) = STRING_GFLAGS_FULL_WORD; }
        -: 2197:#line 2198 "grammar.c"
    #####: 2198:    break;
        -: 2199:
    #####: 2200:  case 45:
        -: 2201:#line 572 "grammar.y"
        -: 2202:                    { (yyval.integer) = STRING_GFLAGS_XOR; }
        -: 2203:#line 2204 "grammar.c"
    #####: 2204:    break;
        -: 2205:
    #####: 2206:  case 46:
        -: 2207:#line 578 "grammar.y"
        -: 2208:      {
        -: 2209:        int result = ERROR_SUCCESS;
        -: 2210:        int var_index = yr_parser_lookup_loop_variable(yyscanner, (yyvsp[0].c_string));
        -: 2211:
        -: 2212:        if (var_index >= 0)
        -: 2213:        {
        -: 2214:          result = yr_parser_emit_with_arg(
        -: 2215:              yyscanner,
        -: 2216:              OP_PUSH_M,
        -: 2217:              LOOP_LOCAL_VARS * var_index,
        -: 2218:              NULL,
        -: 2219:              NULL);
        -: 2220:
        -: 2221:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 2222:          (yyval.expression).value.integer = UNDEFINED;
        -: 2223:          (yyval.expression).identifier = compiler->loop_identifier[var_index];
        -: 2224:        }
        -: 2225:        else
        -: 2226:        {
        -: 2227:          // Search for identifier within the global namespace, where the
        -: 2228:          // externals variables reside.
        -: 2229:
        -: 2230:          YR_OBJECT* object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2231:              compiler->objects_table, (yyvsp[0].c_string), NULL);
        -: 2232:
        -: 2233:          if (object == NULL)
        -: 2234:          {
        -: 2235:            // If not found, search within the current namespace.
        -: 2236:            char* ns = compiler->current_namespace->name;
        -: 2237:
        -: 2238:            object = (YR_OBJECT*) yr_hash_table_lookup(
        -: 2239:                compiler->objects_table, (yyvsp[0].c_string), ns);
        -: 2240:          }
        -: 2241:
        -: 2242:          if (object != NULL)
        -: 2243:          {
        -: 2244:            char* id;
        -: 2245:
        -: 2246:            result = yr_arena_write_string(
        -: 2247:                compiler->sz_arena, (yyvsp[0].c_string), &id);
        -: 2248:
        -: 2249:            if (result == ERROR_SUCCESS)
        -: 2250:              result = yr_parser_emit_with_arg_reloc(
        -: 2251:                  yyscanner,
        -: 2252:                  OP_OBJ_LOAD,
        -: 2253:                  id,
        -: 2254:                  NULL,
        -: 2255:                  NULL);
        -: 2256:
        -: 2257:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2258:            (yyval.expression).value.object = object;
        -: 2259:            (yyval.expression).identifier = object->identifier;
        -: 2260:          }
        -: 2261:          else
        -: 2262:          {
        -: 2263:            YR_RULE* rule = (YR_RULE*) yr_hash_table_lookup(
        -: 2264:                compiler->rules_table,
        -: 2265:                (yyvsp[0].c_string),
        -: 2266:                compiler->current_namespace->name);
        -: 2267:
        -: 2268:            if (rule != NULL)
        -: 2269:            {
        -: 2270:              result = yr_parser_emit_with_arg_reloc(
        -: 2271:                  yyscanner,
        -: 2272:                  OP_PUSH_RULE,
        -: 2273:                  rule,
        -: 2274:                  NULL,
        -: 2275:                  NULL);
        -: 2276:
        -: 2277:              (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2278:              (yyval.expression).value.integer = UNDEFINED;
        -: 2279:              (yyval.expression).identifier = rule->identifier;
        -: 2280:            }
        -: 2281:            else
        -: 2282:            {
        -: 2283:              yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2284:              result = ERROR_UNDEFINED_IDENTIFIER;
        -: 2285:            }
        -: 2286:          }
        -: 2287:        }
        -: 2288:
        -: 2289:        yr_free((yyvsp[0].c_string));
        -: 2290:
        -: 2291:        fail_if_error(result);
        -: 2292:      }
        -: 2293:#line 2294 "grammar.c"
    #####: 2294:    break;
        -: 2295:
    #####: 2296:  case 47:
        -: 2297:#line 664 "grammar.y"
        -: 2298:      {
        -: 2299:        int result = ERROR_SUCCESS;
        -: 2300:        YR_OBJECT* field = NULL;
        -: 2301:
        -: 2302:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2303:            (yyvsp[-2].expression).value.object->type == OBJECT_TYPE_STRUCTURE)
        -: 2304:        {
        -: 2305:          field = yr_object_lookup_field((yyvsp[-2].expression).value.object, (yyvsp[0].c_string));
        -: 2306:
        -: 2307:          if (field != NULL)
        -: 2308:          {
        -: 2309:            char* ident;
        -: 2310:
        -: 2311:            result = yr_arena_write_string(
        -: 2312:                compiler->sz_arena, (yyvsp[0].c_string), &ident);
        -: 2313:
        -: 2314:            if (result == ERROR_SUCCESS)
        -: 2315:              result = yr_parser_emit_with_arg_reloc(
        -: 2316:                  yyscanner,
        -: 2317:                  OP_OBJ_FIELD,
        -: 2318:                  ident,
        -: 2319:                  NULL,
        -: 2320:                  NULL);
        -: 2321:
        -: 2322:            (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2323:            (yyval.expression).value.object = field;
        -: 2324:            (yyval.expression).identifier = field->identifier;
        -: 2325:          }
        -: 2326:          else
        -: 2327:          {
        -: 2328:            yr_compiler_set_error_extra_info(compiler, (yyvsp[0].c_string));
        -: 2329:            result = ERROR_INVALID_FIELD_NAME;
        -: 2330:          }
        -: 2331:        }
        -: 2332:        else
        -: 2333:        {
        -: 2334:          yr_compiler_set_error_extra_info(
        -: 2335:              compiler, (yyvsp[-2].expression).identifier);
        -: 2336:
        -: 2337:          result = ERROR_NOT_A_STRUCTURE;
        -: 2338:        }
        -: 2339:
        -: 2340:        yr_free((yyvsp[0].c_string));
        -: 2341:
        -: 2342:        fail_if_error(result);
        -: 2343:      }
        -: 2344:#line 2345 "grammar.c"
    #####: 2345:    break;
        -: 2346:
    #####: 2347:  case 48:
        -: 2348:#line 711 "grammar.y"
        -: 2349:      {
        -: 2350:        int result = ERROR_SUCCESS;
        -: 2351:        YR_OBJECT_ARRAY* array;
        -: 2352:        YR_OBJECT_DICTIONARY* dict;
        -: 2353:
        -: 2354:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2355:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_ARRAY)
        -: 2356:        {
        -: 2357:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 2358:          {
        -: 2359:            yr_compiler_set_error_extra_info(
        -: 2360:                compiler, "array indexes must be of integer type");
        -: 2361:            result = ERROR_WRONG_TYPE;
        -: 2362:          }
        -: 2363:
        -: 2364:          fail_if_error(result);
        -: 2365:
        -: 2366:          result = yr_parser_emit(
        -: 2367:              yyscanner, OP_INDEX_ARRAY, NULL);
        -: 2368:
        -: 2369:          array = object_as_array((yyvsp[-3].expression).value.object);
        -: 2370:
        -: 2371:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2372:          (yyval.expression).value.object = array->prototype_item;
        -: 2373:          (yyval.expression).identifier = array->identifier;
        -: 2374:        }
        -: 2375:        else if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2376:                 (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_DICTIONARY)
        -: 2377:        {
        -: 2378:          if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_STRING)
        -: 2379:          {
        -: 2380:            yr_compiler_set_error_extra_info(
        -: 2381:                compiler, "dictionary keys must be of string type");
        -: 2382:            result = ERROR_WRONG_TYPE;
        -: 2383:          }
        -: 2384:
        -: 2385:          fail_if_error(result);
        -: 2386:
        -: 2387:          result = yr_parser_emit(
        -: 2388:              yyscanner, OP_LOOKUP_DICT, NULL);
        -: 2389:
        -: 2390:          dict = object_as_dictionary((yyvsp[-3].expression).value.object);
        -: 2391:
        -: 2392:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2393:          (yyval.expression).value.object = dict->prototype_item;
        -: 2394:          (yyval.expression).identifier = dict->identifier;
        -: 2395:        }
        -: 2396:        else
        -: 2397:        {
        -: 2398:          yr_compiler_set_error_extra_info(
        -: 2399:              compiler, (yyvsp[-3].expression).identifier);
        -: 2400:
        -: 2401:          result = ERROR_NOT_INDEXABLE;
        -: 2402:        }
        -: 2403:
        -: 2404:        fail_if_error(result);
        -: 2405:      }
        -: 2406:#line 2407 "grammar.c"
    #####: 2407:    break;
        -: 2408:
    #####: 2409:  case 49:
        -: 2410:#line 770 "grammar.y"
        -: 2411:      {
        -: 2412:        int result = ERROR_SUCCESS;
        -: 2413:        YR_OBJECT_FUNCTION* function;
        -: 2414:        char* args_fmt;
        -: 2415:
        -: 2416:        if ((yyvsp[-3].expression).type == EXPRESSION_TYPE_OBJECT &&
        -: 2417:            (yyvsp[-3].expression).value.object->type == OBJECT_TYPE_FUNCTION)
        -: 2418:        {
        -: 2419:          result = yr_parser_check_types(
        -: 2420:              compiler, object_as_function((yyvsp[-3].expression).value.object), (yyvsp[-1].c_string));
        -: 2421:
        -: 2422:          if (result == ERROR_SUCCESS)
        -: 2423:            result = yr_arena_write_string(
        -: 2424:                compiler->sz_arena, (yyvsp[-1].c_string), &args_fmt);
        -: 2425:
        -: 2426:          if (result == ERROR_SUCCESS)
        -: 2427:            result = yr_parser_emit_with_arg_reloc(
        -: 2428:                yyscanner,
        -: 2429:                OP_CALL,
        -: 2430:                args_fmt,
        -: 2431:                NULL,
        -: 2432:                NULL);
        -: 2433:
        -: 2434:          function = object_as_function((yyvsp[-3].expression).value.object);
        -: 2435:
        -: 2436:          (yyval.expression).type = EXPRESSION_TYPE_OBJECT;
        -: 2437:          (yyval.expression).value.object = function->return_obj;
        -: 2438:          (yyval.expression).identifier = function->identifier;
        -: 2439:        }
        -: 2440:        else
        -: 2441:        {
        -: 2442:          yr_compiler_set_error_extra_info(
        -: 2443:              compiler, (yyvsp[-3].expression).identifier);
        -: 2444:
        -: 2445:          result = ERROR_NOT_A_FUNCTION;
        -: 2446:        }
        -: 2447:
        -: 2448:        yr_free((yyvsp[-1].c_string));
        -: 2449:
        -: 2450:        fail_if_error(result);
        -: 2451:      }
        -: 2452:#line 2453 "grammar.c"
    #####: 2453:    break;
        -: 2454:
    #####: 2455:  case 50:
        -: 2456:#line 815 "grammar.y"
        -: 2457:                      { (yyval.c_string) = yr_strdup(""); }
        -: 2458:#line 2459 "grammar.c"
    #####: 2459:    break;
        -: 2460:
    #####: 2461:  case 51:
        -: 2462:#line 816 "grammar.y"
        -: 2463:                      { (yyval.c_string) = (yyvsp[0].c_string); }
        -: 2464:#line 2465 "grammar.c"
    #####: 2465:    break;
        -: 2466:
    #####: 2467:  case 52:
        -: 2468:#line 821 "grammar.y"
        -: 2469:      {
        -: 2470:        (yyval.c_string) = (char*) yr_malloc(YR_MAX_FUNCTION_ARGS + 1);
        -: 2471:
        -: 2472:        if ((yyval.c_string) == NULL)
        -: 2473:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2474:
        -: 2475:        switch((yyvsp[0].expression).type)
        -: 2476:        {
        -: 2477:          case EXPRESSION_TYPE_INTEGER:
        -: 2478:            strlcpy((yyval.c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2479:            break;
        -: 2480:          case EXPRESSION_TYPE_FLOAT:
        -: 2481:            strlcpy((yyval.c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2482:            break;
        -: 2483:          case EXPRESSION_TYPE_BOOLEAN:
        -: 2484:            strlcpy((yyval.c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2485:            break;
        -: 2486:          case EXPRESSION_TYPE_STRING:
        -: 2487:            strlcpy((yyval.c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2488:            break;
        -: 2489:          case EXPRESSION_TYPE_REGEXP:
        -: 2490:            strlcpy((yyval.c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2491:            break;
        -: 2492:          default:
        -: 2493:            assert(false);
        -: 2494:        }
        -: 2495:      }
        -: 2496:#line 2497 "grammar.c"
    #####: 2497:    break;
        -: 2498:
    #####: 2499:  case 53:
        -: 2500:#line 849 "grammar.y"
        -: 2501:      {
        -: 2502:        int result = ERROR_SUCCESS;
        -: 2503:
        -: 2504:        if (strlen((yyvsp[-2].c_string)) == YR_MAX_FUNCTION_ARGS)
        -: 2505:        {
        -: 2506:          result = ERROR_TOO_MANY_ARGUMENTS;
        -: 2507:        }
        -: 2508:        else
        -: 2509:        {
        -: 2510:          switch((yyvsp[0].expression).type)
        -: 2511:          {
        -: 2512:            case EXPRESSION_TYPE_INTEGER:
        -: 2513:              strlcat((yyvsp[-2].c_string), "i", YR_MAX_FUNCTION_ARGS);
        -: 2514:              break;
        -: 2515:            case EXPRESSION_TYPE_FLOAT:
        -: 2516:              strlcat((yyvsp[-2].c_string), "f", YR_MAX_FUNCTION_ARGS);
        -: 2517:              break;
        -: 2518:            case EXPRESSION_TYPE_BOOLEAN:
        -: 2519:              strlcat((yyvsp[-2].c_string), "b", YR_MAX_FUNCTION_ARGS);
        -: 2520:              break;
        -: 2521:            case EXPRESSION_TYPE_STRING:
        -: 2522:              strlcat((yyvsp[-2].c_string), "s", YR_MAX_FUNCTION_ARGS);
        -: 2523:              break;
        -: 2524:            case EXPRESSION_TYPE_REGEXP:
        -: 2525:              strlcat((yyvsp[-2].c_string), "r", YR_MAX_FUNCTION_ARGS);
        -: 2526:              break;
        -: 2527:            default:
        -: 2528:              assert(false);
        -: 2529:          }
        -: 2530:        }
        -: 2531:
        -: 2532:        fail_if_error(result);
        -: 2533:
        -: 2534:        (yyval.c_string) = (yyvsp[-2].c_string);
        -: 2535:      }
        -: 2536:#line 2537 "grammar.c"
    #####: 2537:    break;
        -: 2538:
    #####: 2539:  case 54:
        -: 2540:#line 889 "grammar.y"
        -: 2541:      {
        -: 2542:        SIZED_STRING* sized_string = (yyvsp[0].sized_string);
        -: 2543:        RE* re;
        -: 2544:        RE_ERROR error;
        -: 2545:
        -: 2546:        int result = ERROR_SUCCESS;
        -: 2547:        int re_flags = 0;
        -: 2548:
        -: 2549:        if (sized_string->flags & SIZED_STRING_FLAGS_NO_CASE)
        -: 2550:          re_flags |= RE_FLAGS_NO_CASE;
        -: 2551:
        -: 2552:        if (sized_string->flags & SIZED_STRING_FLAGS_DOT_ALL)
        -: 2553:          re_flags |= RE_FLAGS_DOT_ALL;
        -: 2554:
        -: 2555:        result = yr_re_compile(
        -: 2556:            sized_string->c_string,
        -: 2557:            re_flags,
        -: 2558:            compiler->re_code_arena,
        -: 2559:            &re,
        -: 2560:            &error);
        -: 2561:
        -: 2562:        yr_free((yyvsp[0].sized_string));
        -: 2563:
        -: 2564:        if (result == ERROR_INVALID_REGULAR_EXPRESSION)
        -: 2565:          yr_compiler_set_error_extra_info(compiler, error.message);
        -: 2566:
        -: 2567:        if (result == ERROR_SUCCESS)
        -: 2568:          result = yr_parser_emit_with_arg_reloc(
        -: 2569:              yyscanner,
        -: 2570:              OP_PUSH,
        -: 2571:              re,
        -: 2572:              NULL,
        -: 2573:              NULL);
        -: 2574:
        -: 2575:        fail_if_error(result);
        -: 2576:
        -: 2577:        (yyval.expression).type = EXPRESSION_TYPE_REGEXP;
        -: 2578:      }
        -: 2579:#line 2580 "grammar.c"
    #####: 2580:    break;
        -: 2581:
        1: 2582:  case 55:
        -: 2583:#line 932 "grammar.y"
        -: 2584:      {
        -: 2585:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_STRING)
        -: 2586:        {
        -: 2587:          if ((yyvsp[0].expression).value.sized_string != NULL)
        -: 2588:          {
        -: 2589:            yywarning(yyscanner,
        -: 2590:              "Using literal string \"%s\" in a boolean operation.",
        -: 2591:              (yyvsp[0].expression).value.sized_string->c_string);
        -: 2592:          }
        -: 2593:
        -: 2594:          fail_if_error(yr_parser_emit(
        -: 2595:              yyscanner, OP_STR_TO_BOOL, NULL));
        -: 2596:        }
        -: 2597:
        -: 2598:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2599:      }
        -: 2600:#line 2601 "grammar.c"
        1: 2601:    break;
        -: 2602:
        1: 2603:  case 56:
        -: 2604:#line 952 "grammar.y"
        -: 2605:      {
        -: 2606:        fail_if_error(yr_parser_emit_with_arg(
        -: 2607:            yyscanner, OP_PUSH, 1, NULL, NULL));
        -: 2608:
        -: 2609:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2610:      }
        -: 2611:#line 2612 "grammar.c"
        1: 2612:    break;
        -: 2613:
    #####: 2614:  case 57:
        -: 2615:#line 959 "grammar.y"
        -: 2616:      {
        -: 2617:        fail_if_error(yr_parser_emit_with_arg(
        -: 2618:            yyscanner, OP_PUSH, 0, NULL, NULL));
        -: 2619:
        -: 2620:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2621:      }
        -: 2622:#line 2623 "grammar.c"
    #####: 2623:    break;
        -: 2624:
    #####: 2625:  case 58:
        -: 2626:#line 966 "grammar.y"
        -: 2627:      {
        -: 2628:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "matches");
        -: 2629:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_REGEXP, "matches");
        -: 2630:
        -: 2631:        fail_if_error(yr_parser_emit(
        -: 2632:            yyscanner,
        -: 2633:            OP_MATCHES,
        -: 2634:            NULL));
        -: 2635:
        -: 2636:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2637:      }
        -: 2638:#line 2639 "grammar.c"
    #####: 2639:    break;
        -: 2640:
    #####: 2641:  case 59:
        -: 2642:#line 978 "grammar.y"
        -: 2643:      {
        -: 2644:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2645:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_STRING, "contains");
        -: 2646:
        -: 2647:        fail_if_error(yr_parser_emit(
        -: 2648:            yyscanner, OP_CONTAINS, NULL));
        -: 2649:
        -: 2650:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2651:      }
        -: 2652:#line 2653 "grammar.c"
    #####: 2653:    break;
        -: 2654:
    #####: 2655:  case 60:
        -: 2656:#line 988 "grammar.y"
        -: 2657:      {
        -: 2658:        int result = yr_parser_reduce_string_identifier(
        -: 2659:            yyscanner,
        -: 2660:            (yyvsp[0].c_string),
        -: 2661:            OP_FOUND,
        -: 2662:            UNDEFINED);
        -: 2663:
        -: 2664:        yr_free((yyvsp[0].c_string));
        -: 2665:
        -: 2666:        fail_if_error(result);
        -: 2667:
        -: 2668:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2669:      }
        -: 2670:#line 2671 "grammar.c"
    #####: 2671:    break;
        -: 2672:
    #####: 2673:  case 61:
        -: 2674:#line 1002 "grammar.y"
        -: 2675:      {
        -: 2676:        check_type_with_cleanup((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "at", yr_free((yyvsp[-2].c_string)));
        -: 2677:
        -: 2678:        int result = yr_parser_reduce_string_identifier(
        -: 2679:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_AT, (yyvsp[0].expression).value.integer);
        -: 2680:
        -: 2681:        yr_free((yyvsp[-2].c_string));
        -: 2682:
        -: 2683:        fail_if_error(result);
        -: 2684:
        -: 2685:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2686:      }
        -: 2687:#line 2688 "grammar.c"
    #####: 2688:    break;
        -: 2689:
    #####: 2690:  case 62:
        -: 2691:#line 1015 "grammar.y"
        -: 2692:      {
        -: 2693:        int result = yr_parser_reduce_string_identifier(
        -: 2694:            yyscanner, (yyvsp[-2].c_string), OP_FOUND_IN, UNDEFINED);
        -: 2695:
        -: 2696:        yr_free((yyvsp[-2].c_string));
        -: 2697:
        -: 2698:        fail_if_error(result);
        -: 2699:
        -: 2700:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2701:      }
        -: 2702:#line 2703 "grammar.c"
    #####: 2703:    break;
        -: 2704:
    #####: 2705:  case 63:
        -: 2706:#line 1026 "grammar.y"
        -: 2707:      {
        -: 2708:        if (compiler->loop_depth > 0)
        -: 2709:        {
        -: 2710:          compiler->loop_depth--;
        -: 2711:          compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2712:        }
        -: 2713:
        -: 2714:        YYERROR;
        -: 2715:      }
        -: 2716:#line 2717 "grammar.c"
        -: 2717:    break;
        -: 2718:
    #####: 2719:  case 64:
        -: 2720:#line 1036 "grammar.y"
        -: 2721:      {
        -: 2722:        int result = ERROR_SUCCESS;
        -: 2723:        int var_index;
        -: 2724:
        -: 2725:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2726:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2727:
        -: 2728:        fail_if_error(result);
        -: 2729:
        -: 2730:        var_index = yr_parser_lookup_loop_variable(
        -: 2731:            yyscanner, (yyvsp[-1].c_string));
        -: 2732:
        -: 2733:        if (var_index >= 0)
        -: 2734:        {
        -: 2735:          yr_compiler_set_error_extra_info(
        -: 2736:              compiler, (yyvsp[-1].c_string));
        -: 2737:
        -: 2738:          result = ERROR_DUPLICATED_LOOP_IDENTIFIER;
        -: 2739:        }
        -: 2740:
        -: 2741:        fail_if_error(result);
        -: 2742:
        -: 2743:        // Push end-of-list marker
        -: 2744:        result = yr_parser_emit_with_arg(
        -: 2745:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 2746:
        -: 2747:        fail_if_error(result);
        -: 2748:      }
        -: 2749:#line 2750 "grammar.c"
    #####: 2750:    break;
        -: 2751:
    #####: 2752:  case 65:
        -: 2753:#line 1065 "grammar.y"
        -: 2754:      {
        -: 2755:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2756:        uint8_t* addr;
        -: 2757:
        -: 2758:        // Clear counter for number of expressions evaluating
        -: 2759:        // to true.
        -: 2760:        yr_parser_emit_with_arg(
        -: 2761:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2762:
        -: 2763:        // Clear iterations counter
        -: 2764:        yr_parser_emit_with_arg(
        -: 2765:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2766:
        -: 2767:        if ((yyvsp[-1].integer) == INTEGER_SET_ENUMERATION)
        -: 2768:        {
        -: 2769:          // Pop the first integer
        -: 2770:          yr_parser_emit_with_arg(
        -: 2771:              yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 2772:        }
        -: 2773:        else // INTEGER_SET_RANGE
        -: 2774:        {
        -: 2775:          // Pop higher bound of set range
        -: 2776:          yr_parser_emit_with_arg(
        -: 2777:              yyscanner, OP_POP_M, mem_offset + 3, &addr, NULL);
        -: 2778:
        -: 2779:          // Pop lower bound of set range
        -: 2780:          yr_parser_emit_with_arg(
        -: 2781:              yyscanner, OP_POP_M, mem_offset, NULL, NULL);
        -: 2782:        }
        -: 2783:
        -: 2784:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2785:        compiler->loop_identifier[compiler->loop_depth] = (yyvsp[-4].c_string);
        -: 2786:        compiler->loop_depth++;
        -: 2787:      }
        -: 2788:#line 2789 "grammar.c"
    #####: 2789:    break;
        -: 2790:
    #####: 2791:  case 66:
        -: 2792:#line 1100 "grammar.y"
        -: 2793:      {
        -: 2794:        int mem_offset;
        -: 2795:
        -: 2796:        compiler->loop_depth--;
        -: 2797:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2798:
        -: 2799:        // The value at the top of the stack is the result of
        -: 2800:        // evaluating the boolean expression, so it could be
        -: 2801:        // 0, 1 or UNDEFINED. Add this value to a counter
        -: 2802:        // keeping the number of expressions evaluating to true.
        -: 2803:        // If the value is UNDEFINED instruction OP_ADD_M
        -: 2804:        // does nothing.
        -: 2805:
        -: 2806:        yr_parser_emit_with_arg(
        -: 2807:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 2808:
        -: 2809:        // Increment iterations counter
        -: 2810:        yr_parser_emit_with_arg(
        -: 2811:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 2812:
        -: 2813:        if ((yyvsp[-5].integer) == INTEGER_SET_ENUMERATION)
        -: 2814:        {
        -: 2815:          yr_parser_emit_with_arg_reloc(
        -: 2816:              yyscanner,
        -: 2817:              OP_JNUNDEF,
        -: 2818:              compiler->loop_address[compiler->loop_depth],
        -: 2819:              NULL,
        -: 2820:              NULL);
        -: 2821:        }
        -: 2822:        else // INTEGER_SET_RANGE
        -: 2823:        {
        -: 2824:          // Increment lower bound of integer set
        -: 2825:          yr_parser_emit_with_arg(
        -: 2826:              yyscanner, OP_INCR_M, mem_offset, NULL, NULL);
        -: 2827:
        -: 2828:          // Push lower bound of integer set
        -: 2829:          yr_parser_emit_with_arg(
        -: 2830:              yyscanner, OP_PUSH_M, mem_offset, NULL, NULL);
        -: 2831:
        -: 2832:          // Push higher bound of integer set
        -: 2833:          yr_parser_emit_with_arg(
        -: 2834:              yyscanner, OP_PUSH_M, mem_offset + 3, NULL, NULL);
        -: 2835:
        -: 2836:          // Compare higher bound with lower bound, do loop again
        -: 2837:          // if lower bound is still lower or equal than higher bound
        -: 2838:          yr_parser_emit_with_arg_reloc(
        -: 2839:              yyscanner,
        -: 2840:              OP_JLE,
        -: 2841:              compiler->loop_address[compiler->loop_depth],
        -: 2842:              NULL,
        -: 2843:              NULL);
        -: 2844:
        -: 2845:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2846:          yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2847:        }
        -: 2848:
        -: 2849:        // Pop end-of-list marker.
        -: 2850:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2851:
        -: 2852:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 2853:        // is at the top of the stack. Check if the quantifier
        -: 2854:        // is undefined (meaning "all") and replace it with the
        -: 2855:        // iterations counter in that case.
        -: 2856:        yr_parser_emit_with_arg(
        -: 2857:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 2858:
        -: 2859:        // Compare the loop quantifier with the number of
        -: 2860:        // expressions evaluating to true.
        -: 2861:        yr_parser_emit_with_arg(
        -: 2862:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 2863:
        -: 2864:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 2865:
        -: 2866:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2867:        yr_free((yyvsp[-8].c_string));
        -: 2868:
        -: 2869:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2870:      }
        -: 2871:#line 2872 "grammar.c"
    #####: 2872:    break;
        -: 2873:
    #####: 2874:  case 67:
        -: 2875:#line 1179 "grammar.y"
        -: 2876:      {
        -: 2877:        int result = ERROR_SUCCESS;
        -: 2878:        int mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2879:        uint8_t* addr;
        -: 2880:
        -: 2881:        if (compiler->loop_depth == YR_MAX_LOOP_NESTING)
        -: 2882:          result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED;
        -: 2883:
        -: 2884:        if (compiler->loop_for_of_mem_offset != -1)
        -: 2885:          result = ERROR_NESTED_FOR_OF_LOOP;
        -: 2886:
        -: 2887:        fail_if_error(result);
        -: 2888:
        -: 2889:        yr_parser_emit_with_arg(
        -: 2890:            yyscanner, OP_CLEAR_M, mem_offset + 1, NULL, NULL);
        -: 2891:
        -: 2892:        yr_parser_emit_with_arg(
        -: 2893:            yyscanner, OP_CLEAR_M, mem_offset + 2, NULL, NULL);
        -: 2894:
        -: 2895:        // Pop the first string.
        -: 2896:        yr_parser_emit_with_arg(
        -: 2897:            yyscanner, OP_POP_M, mem_offset, &addr, NULL);
        -: 2898:
        -: 2899:        compiler->loop_for_of_mem_offset = mem_offset;
        -: 2900:        compiler->loop_address[compiler->loop_depth] = addr;
        -: 2901:        compiler->loop_identifier[compiler->loop_depth] = NULL;
        -: 2902:        compiler->loop_depth++;
        -: 2903:      }
        -: 2904:#line 2905 "grammar.c"
    #####: 2905:    break;
        -: 2906:
    #####: 2907:  case 68:
        -: 2908:#line 1208 "grammar.y"
        -: 2909:      {
        -: 2910:        int mem_offset;
        -: 2911:
        -: 2912:        compiler->loop_depth--;
        -: 2913:        compiler->loop_for_of_mem_offset = -1;
        -: 2914:
        -: 2915:        mem_offset = LOOP_LOCAL_VARS * compiler->loop_depth;
        -: 2916:
        -: 2917:        // Increment counter by the value returned by the
        -: 2918:        // boolean expression (0 or 1). If the boolean expression
        -: 2919:        // returned UNDEFINED the OP_ADD_M won't do anything.
        -: 2920:
        -: 2921:        yr_parser_emit_with_arg(
        -: 2922:            yyscanner, OP_ADD_M, mem_offset + 1, NULL, NULL);
        -: 2923:
        -: 2924:        // Increment iterations counter.
        -: 2925:        yr_parser_emit_with_arg(
        -: 2926:            yyscanner, OP_INCR_M, mem_offset + 2, NULL, NULL);
        -: 2927:
        -: 2928:        // If next string is not undefined, go back to the
        -: 2929:        // beginning of the loop.
        -: 2930:        yr_parser_emit_with_arg_reloc(
        -: 2931:            yyscanner,
        -: 2932:            OP_JNUNDEF,
        -: 2933:            compiler->loop_address[compiler->loop_depth],
        -: 2934:            NULL,
        -: 2935:            NULL);
        -: 2936:
        -: 2937:        // Pop end-of-list marker.
        -: 2938:        yr_parser_emit(yyscanner, OP_POP, NULL);
        -: 2939:
        -: 2940:        // At this point the loop quantifier (any, all, 1, 2,..)
        -: 2941:        // is at top of the stack. Check if the quantifier is
        -: 2942:        // undefined (meaning "all") and replace it with the
        -: 2943:        // iterations counter in that case.
        -: 2944:        yr_parser_emit_with_arg(
        -: 2945:            yyscanner, OP_SWAPUNDEF, mem_offset + 2, NULL, NULL);
        -: 2946:
        -: 2947:        // Compare the loop quantifier with the number of
        -: 2948:        // expressions evaluating to true.
        -: 2949:        yr_parser_emit_with_arg(
        -: 2950:            yyscanner, OP_PUSH_M, mem_offset + 1, NULL, NULL);
        -: 2951:
        -: 2952:        yr_parser_emit(yyscanner, OP_INT_LE, NULL);
        -: 2953:
        -: 2954:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2955:
        -: 2956:      }
        -: 2957:#line 2958 "grammar.c"
    #####: 2958:    break;
        -: 2959:
    #####: 2960:  case 69:
        -: 2961:#line 1257 "grammar.y"
        -: 2962:      {
        -: 2963:        yr_parser_emit(yyscanner, OP_OF, NULL);
        -: 2964:
        -: 2965:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2966:      }
        -: 2967:#line 2968 "grammar.c"
    #####: 2968:    break;
        -: 2969:
    #####: 2970:  case 70:
        -: 2971:#line 1263 "grammar.y"
        -: 2972:      {
        -: 2973:        yr_parser_emit(yyscanner, OP_NOT, NULL);
        -: 2974:
        -: 2975:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 2976:      }
        -: 2977:#line 2978 "grammar.c"
    #####: 2978:    break;
        -: 2979:
    #####: 2980:  case 71:
        -: 2981:#line 1269 "grammar.y"
        -: 2982:      {
        -: 2983:        YR_FIXUP* fixup;
        -: 2984:        void* jmp_destination_addr;
        -: 2985:
        -: 2986:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 2987:            yyscanner,
        -: 2988:            OP_JFALSE,
        -: 2989:            0,          // still don't know the jump destination
        -: 2990:            NULL,
        -: 2991:            &jmp_destination_addr));
        -: 2992:
        -: 2993:        // create a fixup entry for the jump and push it in the stack
        -: 2994:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 2995:
        -: 2996:        if (fixup == NULL)
        -: 2997:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 2998:
        -: 2999:        fixup->address = jmp_destination_addr;
        -: 3000:        fixup->next = compiler->fixup_stack_head;
        -: 3001:        compiler->fixup_stack_head = fixup;
        -: 3002:      }
        -: 3003:#line 3004 "grammar.c"
    #####: 3004:    break;
        -: 3005:
    #####: 3006:  case 72:
        -: 3007:#line 1291 "grammar.y"
        -: 3008:      {
        -: 3009:        YR_FIXUP* fixup;
        -: 3010:        uint8_t* nop_addr;
        -: 3011:
        -: 3012:        fail_if_error(yr_parser_emit(yyscanner, OP_AND, NULL));
        -: 3013:
        -: 3014:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 3015:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 3016:        // use the address of the OP_AND instruction +1 because we can't be
        -: 3017:        // sure that the instruction following the OP_AND is going to be in
        -: 3018:        // the same arena page. As we don't have a reliable way of getting the
        -: 3019:        // address of the next instruction we generate the OP_NOP.
        -: 3020:
        -: 3021:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 3022:
        -: 3023:        fixup = compiler->fixup_stack_head;
        -: 3024:        *(void**)(fixup->address) = (void*) nop_addr;
        -: 3025:        compiler->fixup_stack_head = fixup->next;
        -: 3026:        yr_free(fixup);
        -: 3027:
        -: 3028:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3029:      }
        -: 3030:#line 3031 "grammar.c"
    #####: 3031:    break;
        -: 3032:
    #####: 3033:  case 73:
        -: 3034:#line 1314 "grammar.y"
        -: 3035:      {
        -: 3036:        YR_FIXUP* fixup;
        -: 3037:        void* jmp_destination_addr;
        -: 3038:
        -: 3039:        fail_if_error(yr_parser_emit_with_arg_reloc(
        -: 3040:            yyscanner,
        -: 3041:            OP_JTRUE,
        -: 3042:            0,         // still don't know the jump destination
        -: 3043:            NULL,
        -: 3044:            &jmp_destination_addr));
        -: 3045:
        -: 3046:        fixup = (YR_FIXUP*) yr_malloc(sizeof(YR_FIXUP));
        -: 3047:
        -: 3048:        if (fixup == NULL)
        -: 3049:          fail_if_error(ERROR_INSUFFICIENT_MEMORY);
        -: 3050:
        -: 3051:        fixup->address = jmp_destination_addr;
        -: 3052:        fixup->next = compiler->fixup_stack_head;
        -: 3053:        compiler->fixup_stack_head = fixup;
        -: 3054:      }
        -: 3055:#line 3056 "grammar.c"
    #####: 3056:    break;
        -: 3057:
    #####: 3058:  case 74:
        -: 3059:#line 1335 "grammar.y"
        -: 3060:      {
        -: 3061:        YR_FIXUP* fixup;
        -: 3062:        uint8_t* nop_addr;
        -: 3063:
        -: 3064:        fail_if_error(yr_parser_emit(yyscanner, OP_OR, NULL));
        -: 3065:
        -: 3066:        // Generate a do-nothing instruction (NOP) in order to get its address
        -: 3067:        // and use it as the destination for the OP_JFALSE. We can not simply
        -: 3068:        // use the address of the OP_OR instruction +1 because we can't be
        -: 3069:        // sure that the instruction following the OP_AND is going to be in
        -: 3070:        // the same arena page. As we don't have a reliable way of getting the
        -: 3071:        // address of the next instruction we generate the OP_NOP.
        -: 3072:
        -: 3073:        fail_if_error(yr_parser_emit(yyscanner, OP_NOP, &nop_addr));
        -: 3074:
        -: 3075:        fixup = compiler->fixup_stack_head;
        -: 3076:        *(void**)(fixup->address) = (void*)(nop_addr);
        -: 3077:        compiler->fixup_stack_head = fixup->next;
        -: 3078:        yr_free(fixup);
        -: 3079:
        -: 3080:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3081:      }
        -: 3082:#line 3083 "grammar.c"
    #####: 3083:    break;
        -: 3084:
    #####: 3085:  case 75:
        -: 3086:#line 1358 "grammar.y"
        -: 3087:      {
        -: 3088:        fail_if_error(yr_parser_reduce_operation(
        -: 3089:            yyscanner, "<", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3090:
        -: 3091:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3092:      }
        -: 3093:#line 3094 "grammar.c"
    #####: 3094:    break;
        -: 3095:
    #####: 3096:  case 76:
        -: 3097:#line 1365 "grammar.y"
        -: 3098:      {
        -: 3099:        fail_if_error(yr_parser_reduce_operation(
        -: 3100:            yyscanner, ">", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3101:
        -: 3102:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3103:      }
        -: 3104:#line 3105 "grammar.c"
    #####: 3105:    break;
        -: 3106:
    #####: 3107:  case 77:
        -: 3108:#line 1372 "grammar.y"
        -: 3109:      {
        -: 3110:        fail_if_error(yr_parser_reduce_operation(
        -: 3111:            yyscanner, "<=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3112:
        -: 3113:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3114:      }
        -: 3115:#line 3116 "grammar.c"
    #####: 3116:    break;
        -: 3117:
    #####: 3118:  case 78:
        -: 3119:#line 1379 "grammar.y"
        -: 3120:      {
        -: 3121:        fail_if_error(yr_parser_reduce_operation(
        -: 3122:            yyscanner, ">=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3123:
        -: 3124:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3125:      }
        -: 3126:#line 3127 "grammar.c"
    #####: 3127:    break;
        -: 3128:
    #####: 3129:  case 79:
        -: 3130:#line 1386 "grammar.y"
        -: 3131:      {
        -: 3132:        fail_if_error(yr_parser_reduce_operation(
        -: 3133:            yyscanner, "==", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3134:
        -: 3135:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3136:      }
        -: 3137:#line 3138 "grammar.c"
    #####: 3138:    break;
        -: 3139:
    #####: 3140:  case 80:
        -: 3141:#line 1393 "grammar.y"
        -: 3142:      {
        -: 3143:        fail_if_error(yr_parser_reduce_operation(
        -: 3144:            yyscanner, "!=", (yyvsp[-2].expression), (yyvsp[0].expression)));
        -: 3145:
        -: 3146:        (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3147:      }
        -: 3148:#line 3149 "grammar.c"
    #####: 3149:    break;
        -: 3150:
    #####: 3151:  case 81:
        -: 3152:#line 1400 "grammar.y"
        -: 3153:      {
        -: 3154:        (yyval.expression) = (yyvsp[0].expression);
        -: 3155:      }
        -: 3156:#line 3157 "grammar.c"
    #####: 3157:    break;
        -: 3158:
    #####: 3159:  case 82:
        -: 3160:#line 1404 "grammar.y"
        -: 3161:      {
        -: 3162:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3163:      }
        -: 3164:#line 3165 "grammar.c"
    #####: 3165:    break;
        -: 3166:
    #####: 3167:  case 83:
        -: 3168:#line 1411 "grammar.y"
        -: 3169:                                   { (yyval.integer) = INTEGER_SET_ENUMERATION; }
        -: 3170:#line 3171 "grammar.c"
    #####: 3171:    break;
        -: 3172:
    #####: 3173:  case 84:
        -: 3174:#line 1412 "grammar.y"
        -: 3175:                                   { (yyval.integer) = INTEGER_SET_RANGE; }
        -: 3176:#line 3177 "grammar.c"
    #####: 3177:    break;
        -: 3178:
    #####: 3179:  case 85:
        -: 3180:#line 1418 "grammar.y"
        -: 3181:      {
        -: 3182:        int result = ERROR_SUCCESS;
        -: 3183:
        -: 3184:        if ((yyvsp[-3].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3185:        {
        -: 3186:          yr_compiler_set_error_extra_info(
        -: 3187:              compiler, "wrong type for range's lower bound");
        -: 3188:          result = ERROR_WRONG_TYPE;
        -: 3189:        }
        -: 3190:
        -: 3191:        if ((yyvsp[-1].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3192:        {
        -: 3193:          yr_compiler_set_error_extra_info(
        -: 3194:              compiler, "wrong type for range's upper bound");
        -: 3195:          result = ERROR_WRONG_TYPE;
        -: 3196:        }
        -: 3197:
        -: 3198:        fail_if_error(result);
        -: 3199:      }
        -: 3200:#line 3201 "grammar.c"
    #####: 3201:    break;
        -: 3202:
    #####: 3203:  case 86:
        -: 3204:#line 1442 "grammar.y"
        -: 3205:      {
        -: 3206:        int result = ERROR_SUCCESS;
        -: 3207:
        -: 3208:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3209:        {
        -: 3210:          yr_compiler_set_error_extra_info(
        -: 3211:              compiler, "wrong type for enumeration item");
        -: 3212:          result = ERROR_WRONG_TYPE;
        -: 3213:        }
        -: 3214:
        -: 3215:        fail_if_error(result);
        -: 3216:      }
        -: 3217:#line 3218 "grammar.c"
    #####: 3218:    break;
        -: 3219:
    #####: 3220:  case 87:
        -: 3221:#line 1455 "grammar.y"
        -: 3222:      {
        -: 3223:        int result = ERROR_SUCCESS;
        -: 3224:
        -: 3225:        if ((yyvsp[0].expression).type != EXPRESSION_TYPE_INTEGER)
        -: 3226:        {
        -: 3227:          yr_compiler_set_error_extra_info(
        -: 3228:              compiler, "wrong type for enumeration item");
        -: 3229:          result = ERROR_WRONG_TYPE;
        -: 3230:        }
        -: 3231:
        -: 3232:        fail_if_error(result);
        -: 3233:      }
        -: 3234:#line 3235 "grammar.c"
    #####: 3235:    break;
        -: 3236:
    #####: 3237:  case 88:
        -: 3238:#line 1472 "grammar.y"
        -: 3239:      {
        -: 3240:        // Push end-of-list marker
        -: 3241:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3242:      }
        -: 3243:#line 3244 "grammar.c"
    #####: 3244:    break;
        -: 3245:
    #####: 3246:  case 90:
        -: 3247:#line 1478 "grammar.y"
        -: 3248:      {
        -: 3249:        fail_if_error(yr_parser_emit_with_arg(
        -: 3250:            yyscanner, OP_PUSH, UNDEFINED, NULL, NULL));
        -: 3251:
        -: 3252:        fail_if_error(yr_parser_emit_pushes_for_strings(
        -: 3253:            yyscanner, "$*"));
        -: 3254:      }
        -: 3255:#line 3256 "grammar.c"
    #####: 3256:    break;
        -: 3257:
    #####: 3258:  case 93:
        -: 3259:#line 1496 "grammar.y"
        -: 3260:      {
        -: 3261:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3262:        yr_free((yyvsp[0].c_string));
        -: 3263:
        -: 3264:        fail_if_error(result);
        -: 3265:      }
        -: 3266:#line 3267 "grammar.c"
    #####: 3267:    break;
        -: 3268:
    #####: 3269:  case 94:
        -: 3270:#line 1503 "grammar.y"
        -: 3271:      {
        -: 3272:        int result = yr_parser_emit_pushes_for_strings(yyscanner, (yyvsp[0].c_string));
        -: 3273:        yr_free((yyvsp[0].c_string));
        -: 3274:
        -: 3275:        fail_if_error(result);
        -: 3276:      }
        -: 3277:#line 3278 "grammar.c"
    #####: 3278:    break;
        -: 3279:
    #####: 3280:  case 96:
        -: 3281:#line 1515 "grammar.y"
        -: 3282:      {
        -: 3283:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, UNDEFINED, NULL, NULL);
        -: 3284:      }
        -: 3285:#line 3286 "grammar.c"
    #####: 3286:    break;
        -: 3287:
    #####: 3288:  case 97:
        -: 3289:#line 1519 "grammar.y"
        -: 3290:      {
        -: 3291:        yr_parser_emit_with_arg(yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3292:      }
        -: 3293:#line 3294 "grammar.c"
    #####: 3294:    break;
        -: 3295:
    #####: 3296:  case 98:
        -: 3297:#line 1527 "grammar.y"
        -: 3298:      {
        -: 3299:        (yyval.expression) = (yyvsp[-1].expression);
        -: 3300:      }
        -: 3301:#line 3302 "grammar.c"
    #####: 3302:    break;
        -: 3303:
    #####: 3304:  case 99:
        -: 3305:#line 1531 "grammar.y"
        -: 3306:      {
        -: 3307:        fail_if_error(yr_parser_emit(
        -: 3308:            yyscanner, OP_FILESIZE, NULL));
        -: 3309:
        -: 3310:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3311:        (yyval.expression).value.integer = UNDEFINED;
        -: 3312:      }
        -: 3313:#line 3314 "grammar.c"
    #####: 3314:    break;
        -: 3315:
    #####: 3316:  case 100:
        -: 3317:#line 1539 "grammar.y"
        -: 3318:      {
        -: 3319:        yywarning(yyscanner,
        -: 3320:            "Using deprecated \"entrypoint\" keyword. Use the \"entry_point\" "
        -: 3321:            "function from PE module instead.");
        -: 3322:
        -: 3323:        fail_if_error(yr_parser_emit(
        -: 3324:            yyscanner, OP_ENTRYPOINT, NULL));
        -: 3325:
        -: 3326:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3327:        (yyval.expression).value.integer = UNDEFINED;
        -: 3328:      }
        -: 3329:#line 3330 "grammar.c"
    #####: 3330:    break;
        -: 3331:
    #####: 3332:  case 101:
        -: 3333:#line 1551 "grammar.y"
        -: 3334:      {
        -: 3335:        check_type((yyvsp[-1].expression), EXPRESSION_TYPE_INTEGER, "intXXXX or uintXXXX");
        -: 3336:
        -: 3337:        // _INTEGER_FUNCTION_ could be any of int8, int16, int32, uint8,
        -: 3338:        // uint32, etc. $1 contains an index that added to OP_READ_INT results
        -: 3339:        // in the proper OP_INTXX opcode.
        -: 3340:
        -: 3341:        fail_if_error(yr_parser_emit(
        -: 3342:            yyscanner, (uint8_t) (OP_READ_INT + (yyvsp[-3].integer)), NULL));
        -: 3343:
        -: 3344:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3345:        (yyval.expression).value.integer = UNDEFINED;
        -: 3346:      }
        -: 3347:#line 3348 "grammar.c"
    #####: 3348:    break;
        -: 3349:
    #####: 3350:  case 102:
        -: 3351:#line 1565 "grammar.y"
        -: 3352:      {
        -: 3353:        fail_if_error(yr_parser_emit_with_arg(
        -: 3354:            yyscanner, OP_PUSH, (yyvsp[0].integer), NULL, NULL));
        -: 3355:
        -: 3356:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3357:        (yyval.expression).value.integer = (yyvsp[0].integer);
        -: 3358:      }
        -: 3359:#line 3360 "grammar.c"
    #####: 3360:    break;
        -: 3361:
    #####: 3362:  case 103:
        -: 3363:#line 1573 "grammar.y"
        -: 3364:      {
        -: 3365:        fail_if_error(yr_parser_emit_with_arg_double(
        -: 3366:            yyscanner, OP_PUSH, (yyvsp[0].double_), NULL, NULL));
        -: 3367:
        -: 3368:        (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3369:      }
        -: 3370:#line 3371 "grammar.c"
    #####: 3371:    break;
        -: 3372:
    #####: 3373:  case 104:
        -: 3374:#line 1580 "grammar.y"
        -: 3375:      {
        -: 3376:        SIZED_STRING* sized_string;
        -: 3377:
        -: 3378:        int result = yr_arena_write_data(
        -: 3379:            compiler->sz_arena,
        -: 3380:            (yyvsp[0].sized_string),
        -: 3381:            (yyvsp[0].sized_string)->length + sizeof(SIZED_STRING),
        -: 3382:            (void**) &sized_string);
        -: 3383:
        -: 3384:        yr_free((yyvsp[0].sized_string));
        -: 3385:
        -: 3386:        if (result == ERROR_SUCCESS)
        -: 3387:          result = yr_parser_emit_with_arg_reloc(
        -: 3388:              yyscanner,
        -: 3389:              OP_PUSH,
        -: 3390:              sized_string,
        -: 3391:              NULL,
        -: 3392:              NULL);
        -: 3393:
        -: 3394:        fail_if_error(result);
        -: 3395:
        -: 3396:        (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3397:        (yyval.expression).value.sized_string = sized_string;
        -: 3398:      }
        -: 3399:#line 3400 "grammar.c"
    #####: 3400:    break;
        -: 3401:
    #####: 3402:  case 105:
        -: 3403:#line 1605 "grammar.y"
        -: 3404:      {
        -: 3405:        int result = yr_parser_reduce_string_identifier(
        -: 3406:            yyscanner, (yyvsp[0].c_string), OP_COUNT, UNDEFINED);
        -: 3407:
        -: 3408:        yr_free((yyvsp[0].c_string));
        -: 3409:
        -: 3410:        fail_if_error(result);
        -: 3411:
        -: 3412:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3413:        (yyval.expression).value.integer = UNDEFINED;
        -: 3414:      }
        -: 3415:#line 3416 "grammar.c"
    #####: 3416:    break;
        -: 3417:
    #####: 3418:  case 106:
        -: 3419:#line 1617 "grammar.y"
        -: 3420:      {
        -: 3421:        int result = yr_parser_reduce_string_identifier(
        -: 3422:            yyscanner, (yyvsp[-3].c_string), OP_OFFSET, UNDEFINED);
        -: 3423:
        -: 3424:        yr_free((yyvsp[-3].c_string));
        -: 3425:
        -: 3426:        fail_if_error(result);
        -: 3427:
        -: 3428:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3429:        (yyval.expression).value.integer = UNDEFINED;
        -: 3430:      }
        -: 3431:#line 3432 "grammar.c"
    #####: 3432:    break;
        -: 3433:
    #####: 3434:  case 107:
        -: 3435:#line 1629 "grammar.y"
        -: 3436:      {
        -: 3437:        int result = yr_parser_emit_with_arg(
        -: 3438:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3439:
        -: 3440:        if (result == ERROR_SUCCESS)
        -: 3441:          result = yr_parser_reduce_string_identifier(
        -: 3442:              yyscanner, (yyvsp[0].c_string), OP_OFFSET, UNDEFINED);
        -: 3443:
        -: 3444:        yr_free((yyvsp[0].c_string));
        -: 3445:
        -: 3446:        fail_if_error(result);
        -: 3447:
        -: 3448:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3449:        (yyval.expression).value.integer = UNDEFINED;
        -: 3450:      }
        -: 3451:#line 3452 "grammar.c"
    #####: 3452:    break;
        -: 3453:
    #####: 3454:  case 108:
        -: 3455:#line 1645 "grammar.y"
        -: 3456:      {
        -: 3457:        int result = yr_parser_reduce_string_identifier(
        -: 3458:            yyscanner, (yyvsp[-3].c_string), OP_LENGTH, UNDEFINED);
        -: 3459:
        -: 3460:        yr_free((yyvsp[-3].c_string));
        -: 3461:
        -: 3462:        fail_if_error(result);
        -: 3463:
        -: 3464:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3465:        (yyval.expression).value.integer = UNDEFINED;
        -: 3466:      }
        -: 3467:#line 3468 "grammar.c"
    #####: 3468:    break;
        -: 3469:
    #####: 3470:  case 109:
        -: 3471:#line 1657 "grammar.y"
        -: 3472:      {
        -: 3473:        int result = yr_parser_emit_with_arg(
        -: 3474:            yyscanner, OP_PUSH, 1, NULL, NULL);
        -: 3475:
        -: 3476:        if (result == ERROR_SUCCESS)
        -: 3477:          result = yr_parser_reduce_string_identifier(
        -: 3478:              yyscanner, (yyvsp[0].c_string), OP_LENGTH, UNDEFINED);
        -: 3479:
        -: 3480:        yr_free((yyvsp[0].c_string));
        -: 3481:
        -: 3482:        fail_if_error(result);
        -: 3483:
        -: 3484:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3485:        (yyval.expression).value.integer = UNDEFINED;
        -: 3486:      }
        -: 3487:#line 3488 "grammar.c"
    #####: 3488:    break;
        -: 3489:
    #####: 3490:  case 110:
        -: 3491:#line 1673 "grammar.y"
        -: 3492:      {
        -: 3493:        int result = ERROR_SUCCESS;
        -: 3494:
        -: 3495:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)  // loop identifier
        -: 3496:        {
        -: 3497:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3498:          (yyval.expression).value.integer = UNDEFINED;
        -: 3499:        }
        -: 3500:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_BOOLEAN)  // rule identifier
        -: 3501:        {
        -: 3502:          (yyval.expression).type = EXPRESSION_TYPE_BOOLEAN;
        -: 3503:          (yyval.expression).value.integer = UNDEFINED;
        -: 3504:        }
        -: 3505:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_OBJECT)
        -: 3506:        {
        -: 3507:          result = yr_parser_emit(
        -: 3508:              yyscanner, OP_OBJ_VALUE, NULL);
        -: 3509:
        -: 3510:          switch((yyvsp[0].expression).value.object->type)
        -: 3511:          {
        -: 3512:            case OBJECT_TYPE_INTEGER:
        -: 3513:              (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3514:              (yyval.expression).value.integer = UNDEFINED;
        -: 3515:              break;
        -: 3516:            case OBJECT_TYPE_FLOAT:
        -: 3517:              (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3518:              break;
        -: 3519:            case OBJECT_TYPE_STRING:
        -: 3520:              (yyval.expression).type = EXPRESSION_TYPE_STRING;
        -: 3521:              (yyval.expression).value.sized_string = NULL;
        -: 3522:              break;
        -: 3523:            default:
        -: 3524:              yr_compiler_set_error_extra_info_fmt(
        -: 3525:                  compiler,
        -: 3526:                  "wrong usage of identifier \"%s\"",
        -: 3527:                  (yyvsp[0].expression).identifier);
        -: 3528:              result = ERROR_WRONG_TYPE;
        -: 3529:          }
        -: 3530:        }
        -: 3531:        else
        -: 3532:        {
        -: 3533:          assert(false);
        -: 3534:        }
        -: 3535:
        -: 3536:        fail_if_error(result);
        -: 3537:      }
        -: 3538:#line 3539 "grammar.c"
    #####: 3539:    break;
        -: 3540:
    #####: 3541:  case 111:
        -: 3542:#line 1720 "grammar.y"
        -: 3543:      {
        -: 3544:        int result = ERROR_SUCCESS;
        -: 3545:
        -: 3546:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT, "-");
        -: 3547:
        -: 3548:        if ((yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3549:        {
        -: 3550:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3551:          (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3552:              UNDEFINED : -((yyvsp[0].expression).value.integer);
        -: 3553:          result = yr_parser_emit(yyscanner, OP_INT_MINUS, NULL);
        -: 3554:        }
        -: 3555:        else if ((yyvsp[0].expression).type == EXPRESSION_TYPE_FLOAT)
        -: 3556:        {
        -: 3557:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3558:          result = yr_parser_emit(yyscanner, OP_DBL_MINUS, NULL);
        -: 3559:        }
        -: 3560:
        -: 3561:        fail_if_error(result);
        -: 3562:      }
        -: 3563:#line 3564 "grammar.c"
    #####: 3564:    break;
        -: 3565:
    #####: 3566:  case 112:
        -: 3567:#line 1741 "grammar.y"
        -: 3568:      {
        -: 3569:        int result = yr_parser_reduce_operation(
        -: 3570:            yyscanner, "+", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3571:
        -: 3572:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3573:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3574:        {
        -: 3575:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3576:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3577:
        -: 3578:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3579:              (
        -: 3580:                (i2 > 0 && i1 > INT64_MAX - i2) ||
        -: 3581:                (i2 < 0 && i1 < INT64_MIN - i2)
        -: 3582:              ))
        -: 3583:          {
        -: 3584:            yr_compiler_set_error_extra_info_fmt(
        -: 3585:                compiler, "%" PRId64 " + %" PRId64, i1, i2);
        -: 3586:
        -: 3587:            result = ERROR_INTEGER_OVERFLOW;
        -: 3588:          }
        -: 3589:          else
        -: 3590:          {
        -: 3591:            (yyval.expression).value.integer = OPERATION(+, i1, i2);
        -: 3592:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3593:          }
        -: 3594:        }
        -: 3595:        else
        -: 3596:        {
        -: 3597:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3598:        }
        -: 3599:
        -: 3600:        fail_if_error(result);
        -: 3601:      }
        -: 3602:#line 3603 "grammar.c"
    #####: 3603:    break;
        -: 3604:
    #####: 3605:  case 113:
        -: 3606:#line 1776 "grammar.y"
        -: 3607:      {
        -: 3608:        int result = yr_parser_reduce_operation(
        -: 3609:            yyscanner, "-", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3610:
        -: 3611:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3612:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3613:        {
        -: 3614:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3615:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3616:
        -: 3617:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3618:              (
        -: 3619:                (i2 < 0 && i1 > INT64_MAX + i2) ||
        -: 3620:                (i2 > 0 && i1 < INT64_MIN + i2)
        -: 3621:              ))
        -: 3622:          {
        -: 3623:            yr_compiler_set_error_extra_info_fmt(
        -: 3624:                compiler, "%" PRId64 " - %" PRId64, i1, i2);
        -: 3625:
        -: 3626:            result = ERROR_INTEGER_OVERFLOW;
        -: 3627:          }
        -: 3628:          else
        -: 3629:          {
        -: 3630:            (yyval.expression).value.integer = OPERATION(-, i1, i2);
        -: 3631:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3632:          }
        -: 3633:        }
        -: 3634:        else
        -: 3635:        {
        -: 3636:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3637:        }
        -: 3638:
        -: 3639:        fail_if_error(result);
        -: 3640:      }
        -: 3641:#line 3642 "grammar.c"
    #####: 3642:    break;
        -: 3643:
    #####: 3644:  case 114:
        -: 3645:#line 1811 "grammar.y"
        -: 3646:      {
        -: 3647:        int result = yr_parser_reduce_operation(
        -: 3648:            yyscanner, "*", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3649:
        -: 3650:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3651:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3652:        {
        -: 3653:          int64_t i1 = (yyvsp[-2].expression).value.integer;
        -: 3654:          int64_t i2 = (yyvsp[0].expression).value.integer;
        -: 3655:
        -: 3656:          if (!IS_UNDEFINED(i1) && !IS_UNDEFINED(i2) &&
        -: 3657:              (
        -: 3658:                i2 != 0 && llabs(i1) > INT64_MAX / llabs(i2)
        -: 3659:              ))
        -: 3660:          {
        -: 3661:            yr_compiler_set_error_extra_info_fmt(
        -: 3662:                compiler, "%" PRId64 " * %" PRId64, i1, i2);
        -: 3663:
        -: 3664:            result = ERROR_INTEGER_OVERFLOW;
        -: 3665:          }
        -: 3666:          else
        -: 3667:          {
        -: 3668:            (yyval.expression).value.integer = OPERATION(*, i1, i2);
        -: 3669:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3670:          }
        -: 3671:        }
        -: 3672:        else
        -: 3673:        {
        -: 3674:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3675:        }
        -: 3676:
        -: 3677:        fail_if_error(result);
        -: 3678:      }
        -: 3679:#line 3680 "grammar.c"
    #####: 3680:    break;
        -: 3681:
    #####: 3682:  case 115:
        -: 3683:#line 1845 "grammar.y"
        -: 3684:      {
        -: 3685:        int result = yr_parser_reduce_operation(
        -: 3686:            yyscanner, "\\", (yyvsp[-2].expression), (yyvsp[0].expression));
        -: 3687:
        -: 3688:        if ((yyvsp[-2].expression).type == EXPRESSION_TYPE_INTEGER &&
        -: 3689:            (yyvsp[0].expression).type == EXPRESSION_TYPE_INTEGER)
        -: 3690:        {
        -: 3691:          if ((yyvsp[0].expression).value.integer != 0)
        -: 3692:          {
        -: 3693:            (yyval.expression).value.integer = OPERATION(/, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3694:            (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3695:          }
        -: 3696:          else
        -: 3697:          {
        -: 3698:            result = ERROR_DIVISION_BY_ZERO;
        -: 3699:          }
        -: 3700:        }
        -: 3701:        else
        -: 3702:        {
        -: 3703:          (yyval.expression).type = EXPRESSION_TYPE_FLOAT;
        -: 3704:        }
        -: 3705:
        -: 3706:        fail_if_error(result);
        -: 3707:      }
        -: 3708:#line 3709 "grammar.c"
    #####: 3709:    break;
        -: 3710:
    #####: 3711:  case 116:
        -: 3712:#line 1870 "grammar.y"
        -: 3713:      {
        -: 3714:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3715:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "%");
        -: 3716:
        -: 3717:        fail_if_error(yr_parser_emit(yyscanner, OP_MOD, NULL));
        -: 3718:
        -: 3719:        if ((yyvsp[0].expression).value.integer != 0)
        -: 3720:        {
        -: 3721:          (yyval.expression).value.integer = OPERATION(%, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3722:          (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3723:        }
        -: 3724:        else
        -: 3725:        {
        -: 3726:          fail_if_error(ERROR_DIVISION_BY_ZERO);
        -: 3727:        }
        -: 3728:      }
        -: 3729:#line 3730 "grammar.c"
    #####: 3730:    break;
        -: 3731:
    #####: 3732:  case 117:
        -: 3733:#line 1887 "grammar.y"
        -: 3734:      {
        -: 3735:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3736:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3737:
        -: 3738:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_XOR, NULL));
        -: 3739:
        -: 3740:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3741:        (yyval.expression).value.integer = OPERATION(^, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3742:      }
        -: 3743:#line 3744 "grammar.c"
    #####: 3744:    break;
        -: 3745:
    #####: 3746:  case 118:
        -: 3747:#line 1897 "grammar.y"
        -: 3748:      {
        -: 3749:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3750:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "^");
        -: 3751:
        -: 3752:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_AND, NULL));
        -: 3753:
        -: 3754:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3755:        (yyval.expression).value.integer = OPERATION(&, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3756:      }
        -: 3757:#line 3758 "grammar.c"
    #####: 3758:    break;
        -: 3759:
    #####: 3760:  case 119:
        -: 3761:#line 1907 "grammar.y"
        -: 3762:      {
        -: 3763:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 3764:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "|");
        -: 3765:
        -: 3766:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_OR, NULL));
        -: 3767:
        -: 3768:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3769:        (yyval.expression).value.integer = OPERATION(|, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3770:      }
        -: 3771:#line 3772 "grammar.c"
    #####: 3772:    break;
        -: 3773:
    #####: 3774:  case 120:
        -: 3775:#line 1917 "grammar.y"
        -: 3776:      {
        -: 3777:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "~");
        -: 3778:
        -: 3779:        fail_if_error(yr_parser_emit(yyscanner, OP_BITWISE_NOT, NULL));
        -: 3780:
        -: 3781:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3782:        (yyval.expression).value.integer = ((yyvsp[0].expression).value.integer == UNDEFINED) ?
        -: 3783:            UNDEFINED : ~((yyvsp[0].expression).value.integer);
        -: 3784:      }
        -: 3785:#line 3786 "grammar.c"
    #####: 3786:    break;
        -: 3787:
    #####: 3788:  case 121:
        -: 3789:#line 1927 "grammar.y"
        -: 3790:      {
        -: 3791:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 3792:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, "<<");
        -: 3793:
        -: 3794:        int result = yr_parser_emit(yyscanner, OP_SHL, NULL);
        -: 3795:
        -: 3796:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 3797:          result = ERROR_INVALID_OPERAND;
        -: 3798:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 3799:          (yyval.expression).value.integer = 0;
        -: 3800:        else
        -: 3801:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3802:
        -: 3803:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3804:
        -: 3805:        fail_if_error(result);
        -: 3806:      }
        -: 3807:#line 3808 "grammar.c"
    #####: 3808:    break;
        -: 3809:
    #####: 3810:  case 122:
        -: 3811:#line 1945 "grammar.y"
        -: 3812:      {
        -: 3813:        check_type((yyvsp[-2].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 3814:        check_type((yyvsp[0].expression), EXPRESSION_TYPE_INTEGER, ">>");
        -: 3815:
        -: 3816:        int result = yr_parser_emit(yyscanner, OP_SHR, NULL);
        -: 3817:
        -: 3818:        if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer < 0)
        -: 3819:          result = ERROR_INVALID_OPERAND;
        -: 3820:        else if (!IS_UNDEFINED((yyvsp[0].expression).value.integer) && (yyvsp[0].expression).value.integer >= 64)
        -: 3821:          (yyval.expression).value.integer = 0;
        -: 3822:        else
        -: 3823:          (yyval.expression).value.integer = OPERATION(<<, (yyvsp[-2].expression).value.integer, (yyvsp[0].expression).value.integer);
        -: 3824:
        -: 3825:        (yyval.expression).type = EXPRESSION_TYPE_INTEGER;
        -: 3826:
        -: 3827:        fail_if_error(result);
        -: 3828:      }
        -: 3829:#line 3830 "grammar.c"
    #####: 3830:    break;
        -: 3831:
    #####: 3832:  case 123:
        -: 3833:#line 1963 "grammar.y"
        -: 3834:      {
        -: 3835:        (yyval.expression) = (yyvsp[0].expression);
        -: 3836:      }
        -: 3837:#line 3838 "grammar.c"
    #####: 3838:    break;
        -: 3839:
        -: 3840:
        -: 3841:#line 3842 "grammar.c"
        -: 3842:
        3: 3843:      default: break;
        -: 3844:    }
        -: 3845:  /* User semantic actions sometimes alter yychar, and that requires
        -: 3846:     that yytoken be updated with the new translation.  We take the
        -: 3847:     approach of translating immediately before every use of yytoken.
        -: 3848:     One alternative is translating here after every semantic action,
        -: 3849:     but that translation would be missed if the semantic action invokes
        -: 3850:     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
        -: 3851:     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
        -: 3852:     incorrect destructor might then be invoked immediately.  In the
        -: 3853:     case of YYERROR or YYBACKUP, subsequent parser actions might lead
        -: 3854:     to an incorrect destructor call or verbose syntax error message
        -: 3855:     before the lookahead is translated.  */
        -: 3856:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
        -: 3857:
       12: 3858:  YYPOPSTACK (yylen);
       12: 3859:  yylen = 0;
        -: 3860:  YY_STACK_PRINT (yyss, yyssp);
        -: 3861:
       12: 3862:  *++yyvsp = yyval;
        -: 3863:
        -: 3864:  /* Now 'shift' the result of the reduction.  Determine what state
        -: 3865:     that goes to, based on the state we popped back to and the rule
        -: 3866:     number reduced by.  */
        -: 3867:  {
       12: 3868:    const int yylhs = yyr1[yyn] - YYNTOKENS;
       12: 3869:    const int yyi = yypgoto[yylhs] + *yyssp;
        2: 3870:    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
        1: 3871:               ? yytable[yyi]
       14: 3872:               : yydefgoto[yylhs]);
        -: 3873:  }
        -: 3874:
       12: 3875:  goto yynewstate;
        -: 3876:
        -: 3877:
        -: 3878:/*--------------------------------------.
        -: 3879:| yyerrlab -- here on detecting error.  |
        -: 3880:`--------------------------------------*/
    #####: 3881:yyerrlab:
        -: 3882:  /* Make sure we have latest lookahead translation.  See comments at
        -: 3883:     user semantic actions for why this is necessary.  */
    #####: 3884:  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
        -: 3885:
        -: 3886:  /* If not already recovering from an error, report this error.  */
    #####: 3887:  if (!yyerrstatus)
        -: 3888:    {
    #####: 3889:      ++yynerrs;
        -: 3890:#if ! YYERROR_VERBOSE
        -: 3891:      yyerror (yyscanner, compiler, YY_("syntax error"));
        -: 3892:#else
        -: 3893:# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
        -: 3894:                                        yyssp, yytoken)
        -: 3895:      {
    #####: 3896:        char const *yymsgp = YY_("syntax error");
        -: 3897:        int yysyntax_error_status;
    #####: 3898:        yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 3899:        if (yysyntax_error_status == 0)
    #####: 3900:          yymsgp = yymsg;
    #####: 3901:        else if (yysyntax_error_status == 1)
        -: 3902:          {
    #####: 3903:            if (yymsg != yymsgbuf)
    #####: 3904:              YYSTACK_FREE (yymsg);
    #####: 3905:            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
    #####: 3906:            if (!yymsg)
        -: 3907:              {
    #####: 3908:                yymsg = yymsgbuf;
    #####: 3909:                yymsg_alloc = sizeof yymsgbuf;
    #####: 3910:                yysyntax_error_status = 2;
        -: 3911:              }
        -: 3912:            else
        -: 3913:              {
    #####: 3914:                yysyntax_error_status = YYSYNTAX_ERROR;
    #####: 3915:                yymsgp = yymsg;
        -: 3916:              }
        -: 3917:          }
    #####: 3918:        yyerror (yyscanner, compiler, yymsgp);
    #####: 3919:        if (yysyntax_error_status == 2)
    #####: 3920:          goto yyexhaustedlab;
        -: 3921:      }
        -: 3922:# undef YYSYNTAX_ERROR
        -: 3923:#endif
        -: 3924:    }
        -: 3925:
        -: 3926:
        -: 3927:
    #####: 3928:  if (yyerrstatus == 3)
        -: 3929:    {
        -: 3930:      /* If just tried and failed to reuse lookahead token after an
        -: 3931:         error, discard it.  */
        -: 3932:
    #####: 3933:      if (yychar <= YYEOF)
        -: 3934:        {
        -: 3935:          /* Return failure if at end of input.  */
    #####: 3936:          if (yychar == YYEOF)
    #####: 3937:            YYABORT;
        -: 3938:        }
        -: 3939:      else
        -: 3940:        {
    #####: 3941:          yydestruct ("Error: discarding",
        -: 3942:                      yytoken, &yylval, yyscanner, compiler);
    #####: 3943:          yychar = YYEMPTY;
        -: 3944:        }
        -: 3945:    }
        -: 3946:
        -: 3947:  /* Else will try to reuse lookahead token after shifting the error
        -: 3948:     token.  */
    #####: 3949:  goto yyerrlab1;
        -: 3950:
        -: 3951:
        -: 3952:/*---------------------------------------------------.
        -: 3953:| yyerrorlab -- error raised explicitly by YYERROR.  |
        -: 3954:`---------------------------------------------------*/
    #####: 3955:yyerrorlab:
        -: 3956:  /* Pacify compilers when the user code never invokes YYERROR and the
        -: 3957:     label yyerrorlab therefore never appears in user code.  */
        -: 3958:  if (0)
        -: 3959:    YYERROR;
        -: 3960:
        -: 3961:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 3962:     this YYERROR.  */
    #####: 3963:  YYPOPSTACK (yylen);
    #####: 3964:  yylen = 0;
        -: 3965:  YY_STACK_PRINT (yyss, yyssp);
    #####: 3966:  yystate = *yyssp;
    #####: 3967:  goto yyerrlab1;
        -: 3968:
        -: 3969:
        -: 3970:/*-------------------------------------------------------------.
        -: 3971:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
        -: 3972:`-------------------------------------------------------------*/
    #####: 3973:yyerrlab1:
    #####: 3974:  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
        -: 3975:
        -: 3976:  for (;;)
        -: 3977:    {
    #####: 3978:      yyn = yypact[yystate];
    #####: 3979:      if (!yypact_value_is_default (yyn))
        -: 3980:        {
    #####: 3981:          yyn += YYTERROR;
    #####: 3982:          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
        -: 3983:            {
    #####: 3984:              yyn = yytable[yyn];
    #####: 3985:              if (0 < yyn)
    #####: 3986:                break;
        -: 3987:            }
        -: 3988:        }
        -: 3989:
        -: 3990:      /* Pop the current state because it cannot handle the error token.  */
    #####: 3991:      if (yyssp == yyss)
    #####: 3992:        YYABORT;
        -: 3993:
        -: 3994:
    #####: 3995:      yydestruct ("Error: popping",
    #####: 3996:                  yystos[yystate], yyvsp, yyscanner, compiler);
    #####: 3997:      YYPOPSTACK (1);
    #####: 3998:      yystate = *yyssp;
        -: 3999:      YY_STACK_PRINT (yyss, yyssp);
        -: 4000:    }
        -: 4001:
        -: 4002:  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
    #####: 4003:  *++yyvsp = yylval;
        -: 4004:  YY_IGNORE_MAYBE_UNINITIALIZED_END
        -: 4005:
        -: 4006:
        -: 4007:  /* Shift the error token.  */
        -: 4008:  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
        -: 4009:
    #####: 4010:  yystate = yyn;
    #####: 4011:  goto yynewstate;
        -: 4012:
        -: 4013:
        -: 4014:/*-------------------------------------.
        -: 4015:| yyacceptlab -- YYACCEPT comes here.  |
        -: 4016:`-------------------------------------*/
        1: 4017:yyacceptlab:
        1: 4018:  yyresult = 0;
        1: 4019:  goto yyreturn;
        -: 4020:
        -: 4021:
        -: 4022:/*-----------------------------------.
        -: 4023:| yyabortlab -- YYABORT comes here.  |
        -: 4024:`-----------------------------------*/
    #####: 4025:yyabortlab:
    #####: 4026:  yyresult = 1;
    #####: 4027:  goto yyreturn;
        -: 4028:
        -: 4029:
        -: 4030:#if !defined yyoverflow || YYERROR_VERBOSE
        -: 4031:/*-------------------------------------------------.
        -: 4032:| yyexhaustedlab -- memory exhaustion comes here.  |
        -: 4033:`-------------------------------------------------*/
    #####: 4034:yyexhaustedlab:
    #####: 4035:  yyerror (yyscanner, compiler, YY_("memory exhausted"));
    #####: 4036:  yyresult = 2;
        -: 4037:  /* Fall through.  */
        -: 4038:#endif
        -: 4039:
        -: 4040:
        -: 4041:/*-----------------------------------------------------.
        -: 4042:| yyreturn -- parsing is finished, return the result.  |
        -: 4043:`-----------------------------------------------------*/
        1: 4044:yyreturn:
        1: 4045:  if (yychar != YYEMPTY)
        -: 4046:    {
        -: 4047:      /* Make sure we have latest lookahead translation.  See comments at
        -: 4048:         user semantic actions for why this is necessary.  */
    #####: 4049:      yytoken = YYTRANSLATE (yychar);
    #####: 4050:      yydestruct ("Cleanup: discarding lookahead",
        -: 4051:                  yytoken, &yylval, yyscanner, compiler);
        -: 4052:    }
        -: 4053:  /* Do not reclaim the symbols of the rule whose action triggered
        -: 4054:     this YYABORT or YYACCEPT.  */
        1: 4055:  YYPOPSTACK (yylen);
        -: 4056:  YY_STACK_PRINT (yyss, yyssp);
        3: 4057:  while (yyssp != yyss)
        -: 4058:    {
        2: 4059:      yydestruct ("Cleanup: popping",
        2: 4060:                  yystos[+*yyssp], yyvsp, yyscanner, compiler);
        2: 4061:      YYPOPSTACK (1);
        -: 4062:    }
        -: 4063:#ifndef yyoverflow
        1: 4064:  if (yyss != yyssa)
    #####: 4065:    YYSTACK_FREE (yyss);
        -: 4066:#endif
        -: 4067:#if YYERROR_VERBOSE
        1: 4068:  if (yymsg != yymsgbuf)
    #####: 4069:    YYSTACK_FREE (yymsg);
        -: 4070:#endif
        1: 4071:  return yyresult;
        -: 4072:}
        -: 4073:#line 1968 "grammar.y"
        -: 4074:
