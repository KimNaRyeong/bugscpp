        -:    0:Source:exec.c
        -:    0:Graph:/home/workspace/libyara/exec.gcno
        -:    0:Data:/home/workspace/libyara/exec.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2013-2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#define _GNU_SOURCE
        -:   31:
        -:   32:#include <stdbool.h>
        -:   33:#include <string.h>
        -:   34:#include <assert.h>
        -:   35:#include <math.h>
        -:   36:
        -:   37:#include <yara/globals.h>
        -:   38:#include <yara/arena.h>
        -:   39:#include <yara/endian.h>
        -:   40:#include <yara/exec.h>
        -:   41:#include <yara/limits.h>
        -:   42:#include <yara/error.h>
        -:   43:#include <yara/object.h>
        -:   44:#include <yara/modules.h>
        -:   45:#include <yara/re.h>
        -:   46:#include <yara/strutils.h>
        -:   47:#include <yara/utils.h>
        -:   48:#include <yara/mem.h>
        -:   49:#include <yara/stopwatch.h>
        -:   50:
        -:   51:
        -:   52:#include <yara.h>
        -:   53:
        -:   54:
        -:   55:// Turn on paranoid mode by default if not defined otherwise. In paranoid
        -:   56:// mode additional checks are performed in order to mitigate the effects of
        -:   57:// malicious tampering with compiled rules. Such checks are not necessary
        -:   58:// when you can ensure that the compiled rules are executed exactly as they
        -:   59:// were generated by YARA, without any further modification. Check issue #891
        -:   60:// (https://github.com/VirusTotal/yara/issues/891) for more context.
        -:   61://
        -:   62:// Paranoid mode does not guarantee that it's safe to load compiled rules from
        -:   63:// third parties, it only prevents severe security issues. Maliciously crafted
        -:   64:// compiled rules can still crash YARA. Loading third-party compiled rules is
        -:   65:// *highly* undiscouraged. If you need to distribute YARA rules in compiled
        -:   66:// form you should encapsulate them in some digitally-signed package that
        -:   67:// ensure that they haven't been modified by someone else.
        -:   68:
        -:   69:#if !defined(PARANOID_EXEC)
        -:   70:#define PARANOID_EXEC   1
        -:   71:#endif
        -:   72:
        -:   73:
        -:   74:#define MEM_SIZE   YR_MAX_LOOP_NESTING * LOOP_LOCAL_VARS
        -:   75:
        -:   76:
        -:   77:#define push(x)  \
        -:   78:    if (sp < stack_size) \
        -:   79:    { \
        -:   80:      stack[sp++] = (x); \
        -:   81:    } \
        -:   82:    else \
        -:   83:    { \
        -:   84:      result = ERROR_EXEC_STACK_OVERFLOW; \
        -:   85:      stop = true; \
        -:   86:      break; \
        -:   87:    } \
        -:   88:
        -:   89:
        -:   90:#define pop(x) { assert(sp > 0); x = stack[--sp]; }
        -:   91:
        -:   92:#define is_undef(x) IS_UNDEFINED((x).i)
        -:   93:
        -:   94:#define ensure_defined(x) \
        -:   95:    if (is_undef(x)) \
        -:   96:    { \
        -:   97:      r1.i = UNDEFINED; \
        -:   98:      push(r1); \
        -:   99:      break; \
        -:  100:    }
        -:  101:
        -:  102:#define ensure_within_mem(x) \
        -:  103:    if (x < 0 || x >= MEM_SIZE) \
        -:  104:    { \
        -:  105:      stop = true; \
        -:  106:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  107:      break; \
        -:  108:    }
        -:  109:
        -:  110:#define check_object_canary(o) \
        -:  111:    if (o->canary != yr_canary) \
        -:  112:    { \
        -:  113:      stop = true; \
        -:  114:      result = ERROR_INTERNAL_FATAL_ERROR; \
        -:  115:      break; \
        -:  116:    }
        -:  117:
        -:  118:#define little_endian_uint8_t(x)     (x)
        -:  119:#define little_endian_int8_t(x)      (x)
        -:  120:#define little_endian_uint16_t(x)    yr_le16toh(x)
        -:  121:#define little_endian_int16_t(x)     yr_le16toh(x)
        -:  122:#define little_endian_uint32_t(x)    yr_le32toh(x)
        -:  123:#define little_endian_int32_t(x)     yr_le32toh(x)
        -:  124:
        -:  125:#define big_endian_uint8_t(x)        (x)
        -:  126:#define big_endian_int8_t(x)         (x)
        -:  127:#define big_endian_uint16_t(x)       yr_be16toh(x)
        -:  128:#define big_endian_int16_t(x)        yr_be16toh(x)
        -:  129:#define big_endian_uint32_t(x)       yr_be32toh(x)
        -:  130:#define big_endian_int32_t(x)        yr_be32toh(x)
        -:  131:
        -:  132:
        -:  133:#define function_read(type, endianess) \
        -:  134:    int64_t read_##type##_##endianess(YR_MEMORY_BLOCK_ITERATOR* iterator, size_t offset) \
        -:  135:    { \
        -:  136:      YR_MEMORY_BLOCK* block = iterator->first(iterator); \
        -:  137:      while (block != NULL) \
        -:  138:      { \
        -:  139:        if (offset >= block->base && \
        -:  140:            block->size >= sizeof(type) && \
        -:  141:            offset <= block->base + block->size - sizeof(type)) \
        -:  142:        { \
        -:  143:          type result; \
        -:  144:          const uint8_t* data = block->fetch_data(block); \
        -:  145:          if (data == NULL) \
        -:  146:            return UNDEFINED; \
        -:  147:          result = *(type *)(data + offset - block->base); \
        -:  148:          result = endianess##_##type(result); \
        -:  149:          return result; \
        -:  150:        } \
        -:  151:        block = iterator->next(iterator); \
        -:  152:      } \
        -:  153:      return UNDEFINED; \
        -:  154:    };
        -:  155:
        -:  156:
    #####:  157:function_read(uint8_t, little_endian)
    #####:  158:function_read(uint16_t, little_endian)
    #####:  159:function_read(uint32_t, little_endian)
    #####:  160:function_read(int8_t, little_endian)
    #####:  161:function_read(int16_t, little_endian)
    #####:  162:function_read(int32_t, little_endian)
    #####:  163:function_read(uint8_t, big_endian)
    #####:  164:function_read(uint16_t, big_endian)
    #####:  165:function_read(uint32_t, big_endian)
    #####:  166:function_read(int8_t, big_endian)
    #####:  167:function_read(int16_t, big_endian)
    #####:  168:function_read(int32_t, big_endian)
        -:  169:
        -:  170:
    #####:  171:static const uint8_t* jmp_if(
        -:  172:    int condition,
        -:  173:    const uint8_t* ip)
        -:  174:{
        -:  175:  const uint8_t* result;
        -:  176:
    #####:  177:  if (condition)
        -:  178:  {
    #####:  179:    result = *(const uint8_t**)(ip);
        -:  180:  }
        -:  181:  else
        -:  182:  {
    #####:  183:    result = ip + sizeof(uint64_t);
        -:  184:  }
        -:  185:
    #####:  186:  return result;
        -:  187:}
        -:  188:
        -:  189:
    #####:  190:int yr_execute_code(
        -:  191:    YR_SCAN_CONTEXT* context)
        -:  192:{
        -:  193:  int64_t mem[MEM_SIZE];
    #####:  194:  int32_t sp = 0;
        -:  195:
    #####:  196:  const uint8_t* ip = context->rules->code_start;
        -:  197:
        -:  198:  YR_VALUE args[YR_MAX_FUNCTION_ARGS];
        -:  199:  YR_VALUE *stack;
        -:  200:  YR_VALUE r1;
        -:  201:  YR_VALUE r2;
        -:  202:  YR_VALUE r3;
        -:  203:
        -:  204:  uint64_t elapsed_time;
        -:  205:
        -:  206:  #ifdef PROFILING_ENABLED
        -:  207:  uint64_t start_time;
        -:  208:  YR_RULE* current_rule = NULL;
        -:  209:  #endif
        -:  210:
        -:  211:  YR_INIT_RULE_ARGS init_rule_args;
        -:  212:
        -:  213:  YR_RULE* rule;
        -:  214:  YR_MATCH* match;
        -:  215:  YR_OBJECT_FUNCTION* function;
        -:  216:  YR_OBJECT** obj_ptr;
        -:  217:  YR_ARENA* obj_arena;
        -:  218:
        -:  219:  char* identifier;
        -:  220:  char* args_fmt;
        -:  221:
        -:  222:  int i;
        -:  223:  int found;
        -:  224:  int count;
    #####:  225:  int result = ERROR_SUCCESS;
    #####:  226:  int cycle = 0;
    #####:  227:  int tidx = context->tidx;
        -:  228:  int stack_size;
        -:  229:
    #####:  230:  bool stop = false;
        -:  231:
        -:  232:  uint8_t opcode;
        -:  233:
    #####:  234:  yr_get_configuration(YR_CONFIG_STACK_SIZE, (void*) &stack_size);
        -:  235:
    #####:  236:  stack = (YR_VALUE*) yr_malloc(stack_size * sizeof(YR_VALUE));
        -:  237:
    #####:  238:  if (stack == NULL)
    #####:  239:    return ERROR_INSUFFICIENT_MEMORY;
        -:  240:
    #####:  241:  FAIL_ON_ERROR_WITH_CLEANUP(
        -:  242:      yr_arena_create(1024, 0, &obj_arena),
        -:  243:      yr_free(stack));
        -:  244:
        -:  245:  #ifdef PROFILING_ENABLED
        -:  246:  start_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -:  247:  #endif
        -:  248:
    #####:  249:  while(!stop)
        -:  250:  {
    #####:  251:    opcode = *ip;
    #####:  252:    ip++;
        -:  253:
    #####:  254:    switch(opcode)
        -:  255:    {
    #####:  256:      case OP_NOP:
    #####:  257:        break;
        -:  258:
    #####:  259:      case OP_HALT:
    #####:  260:        assert(sp == 0); // When HALT is reached the stack should be empty.
    #####:  261:        stop = true;
    #####:  262:        break;
        -:  263:
    #####:  264:      case OP_PUSH:
    #####:  265:        r1.i = *(uint64_t*)(ip);
    #####:  266:        ip += sizeof(uint64_t);
    #####:  267:        push(r1);
    #####:  268:        break;
        -:  269:
    #####:  270:      case OP_POP:
    #####:  271:        pop(r1);
    #####:  272:        break;
        -:  273:
    #####:  274:      case OP_CLEAR_M:
    #####:  275:        r1.i = *(uint64_t*)(ip);
    #####:  276:        ip += sizeof(uint64_t);
        -:  277:        #if PARANOID_EXEC
    #####:  278:        ensure_within_mem(r1.i);
        -:  279:        #endif
    #####:  280:        mem[r1.i] = 0;
    #####:  281:        break;
        -:  282:
    #####:  283:      case OP_ADD_M:
    #####:  284:        r1.i = *(uint64_t*)(ip);
    #####:  285:        ip += sizeof(uint64_t);
        -:  286:        #if PARANOID_EXEC
    #####:  287:        ensure_within_mem(r1.i);
        -:  288:        #endif
    #####:  289:        pop(r2);
    #####:  290:        if (!is_undef(r2))
    #####:  291:          mem[r1.i] += r2.i;
    #####:  292:        break;
        -:  293:
    #####:  294:      case OP_INCR_M:
    #####:  295:        r1.i = *(uint64_t*)(ip);
    #####:  296:        ip += sizeof(uint64_t);
        -:  297:        #if PARANOID_EXEC
    #####:  298:        ensure_within_mem(r1.i);
        -:  299:        #endif
    #####:  300:        mem[r1.i]++;
    #####:  301:        break;
        -:  302:
    #####:  303:      case OP_PUSH_M:
    #####:  304:        r1.i = *(uint64_t*)(ip);
    #####:  305:        ip += sizeof(uint64_t);
        -:  306:        #if PARANOID_EXEC
    #####:  307:        ensure_within_mem(r1.i);
        -:  308:        #endif
    #####:  309:        r1.i = mem[r1.i];
    #####:  310:        push(r1);
    #####:  311:        break;
        -:  312:
    #####:  313:      case OP_POP_M:
    #####:  314:        r1.i = *(uint64_t*)(ip);
    #####:  315:        ip += sizeof(uint64_t);
        -:  316:        #if PARANOID_EXEC
    #####:  317:        ensure_within_mem(r1.i);
        -:  318:        #endif
    #####:  319:        pop(r2);
    #####:  320:        mem[r1.i] = r2.i;
    #####:  321:        break;
        -:  322:
    #####:  323:      case OP_SWAPUNDEF:
    #####:  324:        r1.i = *(uint64_t*)(ip);
    #####:  325:        ip += sizeof(uint64_t);
        -:  326:        #if PARANOID_EXEC
    #####:  327:        ensure_within_mem(r1.i);
        -:  328:        #endif
    #####:  329:        pop(r2);
        -:  330:
    #####:  331:        if (is_undef(r2))
        -:  332:        {
    #####:  333:          r1.i = mem[r1.i];
    #####:  334:          push(r1);
        -:  335:        }
        -:  336:        else
        -:  337:        {
    #####:  338:          push(r2);
        -:  339:        }
    #####:  340:        break;
        -:  341:
    #####:  342:      case OP_JNUNDEF:
    #####:  343:        pop(r1);
    #####:  344:        push(r1);
        -:  345:
    #####:  346:        ip = jmp_if(!is_undef(r1), ip);
    #####:  347:        break;
        -:  348:
    #####:  349:      case OP_JLE:
    #####:  350:        pop(r2);
    #####:  351:        pop(r1);
    #####:  352:        push(r1);
    #####:  353:        push(r2);
        -:  354:
    #####:  355:        ip = jmp_if(r1.i <= r2.i, ip);
    #####:  356:        break;
        -:  357:
    #####:  358:      case OP_JTRUE:
    #####:  359:        pop(r1);
    #####:  360:        push(r1);
        -:  361:
    #####:  362:        ip = jmp_if(!is_undef(r1) && r1.i, ip);
    #####:  363:        break;
        -:  364:
    #####:  365:      case OP_JFALSE:
    #####:  366:        pop(r1);
    #####:  367:        push(r1);
        -:  368:
    #####:  369:        ip = jmp_if(is_undef(r1) || !r1.i, ip);
    #####:  370:        break;
        -:  371:
    #####:  372:      case OP_AND:
    #####:  373:        pop(r2);
    #####:  374:        pop(r1);
        -:  375:
    #####:  376:        if (is_undef(r1) || is_undef(r2))
    #####:  377:          r1.i = 0;
        -:  378:        else
    #####:  379:          r1.i = r1.i && r2.i;
        -:  380:
    #####:  381:        push(r1);
    #####:  382:        break;
        -:  383:
    #####:  384:      case OP_OR:
    #####:  385:        pop(r2);
    #####:  386:        pop(r1);
        -:  387:
    #####:  388:        if (is_undef(r1))
        -:  389:        {
    #####:  390:          push(r2);
        -:  391:        }
    #####:  392:        else if (is_undef(r2))
        -:  393:        {
    #####:  394:          push(r1);
        -:  395:        }
        -:  396:        else
        -:  397:        {
    #####:  398:          r1.i = r1.i || r2.i;
    #####:  399:          push(r1);
        -:  400:        }
    #####:  401:        break;
        -:  402:
    #####:  403:      case OP_NOT:
    #####:  404:        pop(r1);
        -:  405:
    #####:  406:        if (is_undef(r1))
    #####:  407:          r1.i = UNDEFINED;
        -:  408:        else
    #####:  409:          r1.i= !r1.i;
        -:  410:
    #####:  411:        push(r1);
    #####:  412:        break;
        -:  413:
    #####:  414:      case OP_MOD:
    #####:  415:        pop(r2);
    #####:  416:        pop(r1);
    #####:  417:        ensure_defined(r2);
    #####:  418:        ensure_defined(r1);
    #####:  419:        if (r2.i != 0)
    #####:  420:          r1.i = r1.i % r2.i;
        -:  421:        else
    #####:  422:          r1.i = UNDEFINED;
    #####:  423:        push(r1);
    #####:  424:        break;
        -:  425:
    #####:  426:      case OP_SHR:
    #####:  427:        pop(r2);
    #####:  428:        pop(r1);
    #####:  429:        ensure_defined(r2);
    #####:  430:        ensure_defined(r1);
    #####:  431:        if (r2.i < 0)
    #####:  432:          r1.i = UNDEFINED;
    #####:  433:        else if (r2.i < 64)
    #####:  434:          r1.i = r1.i >> r2.i;
        -:  435:        else
    #####:  436:          r1.i = 0;
    #####:  437:        push(r1);
    #####:  438:        break;
        -:  439:
    #####:  440:      case OP_SHL:
    #####:  441:        pop(r2);
    #####:  442:        pop(r1);
    #####:  443:        ensure_defined(r2);
    #####:  444:        ensure_defined(r1);
    #####:  445:        if (r2.i < 0)
    #####:  446:          r1.i = UNDEFINED;
    #####:  447:        else if (r2.i < 64)
    #####:  448:          r1.i = r1.i << r2.i;
        -:  449:        else
    #####:  450:          r1.i = 0;
    #####:  451:        push(r1);
    #####:  452:        break;
        -:  453:
    #####:  454:      case OP_BITWISE_NOT:
    #####:  455:        pop(r1);
    #####:  456:        ensure_defined(r1);
    #####:  457:        r1.i = ~r1.i;
    #####:  458:        push(r1);
    #####:  459:        break;
        -:  460:
    #####:  461:      case OP_BITWISE_AND:
    #####:  462:        pop(r2);
    #####:  463:        pop(r1);
    #####:  464:        ensure_defined(r2);
    #####:  465:        ensure_defined(r1);
    #####:  466:        r1.i = r1.i & r2.i;
    #####:  467:        push(r1);
    #####:  468:        break;
        -:  469:
    #####:  470:      case OP_BITWISE_OR:
    #####:  471:        pop(r2);
    #####:  472:        pop(r1);
    #####:  473:        ensure_defined(r2);
    #####:  474:        ensure_defined(r1);
    #####:  475:        r1.i = r1.i | r2.i;
    #####:  476:        push(r1);
    #####:  477:        break;
        -:  478:
    #####:  479:      case OP_BITWISE_XOR:
    #####:  480:        pop(r2);
    #####:  481:        pop(r1);
    #####:  482:        ensure_defined(r2);
    #####:  483:        ensure_defined(r1);
    #####:  484:        r1.i = r1.i ^ r2.i;
    #####:  485:        push(r1);
    #####:  486:        break;
        -:  487:
    #####:  488:      case OP_PUSH_RULE:
    #####:  489:        rule = *(YR_RULE**)(ip);
    #####:  490:        ip += sizeof(uint64_t);
    #####:  491:        if (RULE_IS_DISABLED(rule))
    #####:  492:          r1.i = UNDEFINED;
        -:  493:        else
    #####:  494:          r1.i = rule->t_flags[tidx] & RULE_TFLAGS_MATCH ? 1 : 0;
    #####:  495:        push(r1);
    #####:  496:        break;
        -:  497:
    #####:  498:      case OP_INIT_RULE:
    #####:  499:        memcpy(&init_rule_args, ip, sizeof(init_rule_args));
        -:  500:        #ifdef PROFILING_ENABLED
        -:  501:        current_rule = init_rule_args.rule;
        -:  502:        #endif
    #####:  503:        if (RULE_IS_DISABLED(init_rule_args.rule))
    #####:  504:          ip = init_rule_args.jmp_addr;
        -:  505:        else
    #####:  506:          ip += sizeof(init_rule_args);
    #####:  507:        break;
        -:  508:
    #####:  509:      case OP_MATCH_RULE:
    #####:  510:        pop(r1);
    #####:  511:        rule = *(YR_RULE**)(ip);
    #####:  512:        ip += sizeof(uint64_t);
        -:  513:
    #####:  514:        if (!is_undef(r1) && r1.i)
    #####:  515:          rule->t_flags[tidx] |= RULE_TFLAGS_MATCH;
    #####:  516:        else if (RULE_IS_GLOBAL(rule))
    #####:  517:          rule->ns->t_flags[tidx] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL;
        -:  518:
        -:  519:        #ifdef PROFILING_ENABLED
        -:  520:        elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -:  521:        rule->time_cost += (elapsed_time - start_time);
        -:  522:        start_time = elapsed_time;
        -:  523:        #endif
        -:  524:
    #####:  525:        assert(sp == 0); // at this point the stack should be empty.
    #####:  526:        break;
        -:  527:
    #####:  528:      case OP_OBJ_LOAD:
    #####:  529:        identifier = *(char**)(ip);
    #####:  530:        ip += sizeof(uint64_t);
        -:  531:
    #####:  532:        r1.o = (YR_OBJECT*) yr_hash_table_lookup(
        -:  533:            context->objects_table,
        -:  534:            identifier,
        -:  535:            NULL);
        -:  536:
    #####:  537:        assert(r1.o != NULL);
    #####:  538:        push(r1);
    #####:  539:        break;
        -:  540:
    #####:  541:      case OP_OBJ_FIELD:
    #####:  542:        identifier = *(char**)(ip);
    #####:  543:        ip += sizeof(uint64_t);
        -:  544:
    #####:  545:        pop(r1);
    #####:  546:        ensure_defined(r1);
        -:  547:
    #####:  548:        r1.o = yr_object_lookup_field(r1.o, identifier);
        -:  549:
    #####:  550:        assert(r1.o != NULL);
    #####:  551:        push(r1);
    #####:  552:        break;
        -:  553:
    #####:  554:      case OP_OBJ_VALUE:
    #####:  555:        pop(r1);
    #####:  556:        ensure_defined(r1);
        -:  557:
        -:  558:        #if PARANOID_EXEC
    #####:  559:        check_object_canary(r1.o);
        -:  560:        #endif
        -:  561:
    #####:  562:        switch(r1.o->type)
        -:  563:        {
    #####:  564:          case OBJECT_TYPE_INTEGER:
    #####:  565:            r1.i = r1.o->value.i;
    #####:  566:            break;
        -:  567:
    #####:  568:          case OBJECT_TYPE_FLOAT:
    #####:  569:            if (isnan(r1.o->value.d))
    #####:  570:              r1.i = UNDEFINED;
        -:  571:            else
    #####:  572:              r1.d = r1.o->value.d;
    #####:  573:            break;
        -:  574:
    #####:  575:          case OBJECT_TYPE_STRING:
    #####:  576:            if (r1.o->value.ss == NULL)
    #####:  577:              r1.i = UNDEFINED;
        -:  578:            else
    #####:  579:              r1.ss = r1.o->value.ss;
    #####:  580:            break;
        -:  581:
    #####:  582:          default:
    #####:  583:            assert(false);
        -:  584:        }
        -:  585:
    #####:  586:        push(r1);
    #####:  587:        break;
        -:  588:
    #####:  589:      case OP_INDEX_ARRAY:
    #####:  590:        pop(r1);  // index
    #####:  591:        pop(r2);  // array
        -:  592:
    #####:  593:        ensure_defined(r1);
    #####:  594:        ensure_defined(r2);
        -:  595:
    #####:  596:        assert(r2.o->type == OBJECT_TYPE_ARRAY);
        -:  597:
        -:  598:        #if PARANOID_EXEC
    #####:  599:        check_object_canary(r2.o);
        -:  600:        #endif
        -:  601:
    #####:  602:        r1.o = yr_object_array_get_item(r2.o, 0, (int) r1.i);
        -:  603:
    #####:  604:        if (r1.o == NULL)
    #####:  605:          r1.i = UNDEFINED;
        -:  606:
    #####:  607:        push(r1);
    #####:  608:        break;
        -:  609:
    #####:  610:      case OP_LOOKUP_DICT:
    #####:  611:        pop(r1);  // key
    #####:  612:        pop(r2);  // dictionary
        -:  613:
    #####:  614:        ensure_defined(r1);
    #####:  615:        ensure_defined(r2);
        -:  616:
    #####:  617:        assert(r2.o->type == OBJECT_TYPE_DICTIONARY);
        -:  618:
        -:  619:        #if PARANOID_EXEC
    #####:  620:        check_object_canary(r2.o);
        -:  621:        #endif
        -:  622:
    #####:  623:        r1.o = yr_object_dict_get_item(
    #####:  624:            r2.o, 0, r1.ss->c_string);
        -:  625:
    #####:  626:        if (r1.o == NULL)
    #####:  627:          r1.i = UNDEFINED;
        -:  628:
    #####:  629:        push(r1);
    #####:  630:        break;
        -:  631:
    #####:  632:      case OP_CALL:
    #####:  633:        args_fmt = *(char**)(ip);
    #####:  634:        ip += sizeof(uint64_t);
        -:  635:
    #####:  636:        i = (int) strlen(args_fmt);
    #####:  637:        count = 0;
        -:  638:
        -:  639:        #if PARANOID_EXEC
    #####:  640:        if (i > YR_MAX_FUNCTION_ARGS)
        -:  641:        {
    #####:  642:          stop = true;
    #####:  643:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####:  644:          break;
        -:  645:        }
        -:  646:        #endif
        -:  647:
        -:  648:        // pop arguments from stack and copy them to args array
        -:  649:
    #####:  650:        while (i > 0)
        -:  651:        {
    #####:  652:          pop(r1);
        -:  653:
    #####:  654:          if (is_undef(r1))  // count the number of undefined args
    #####:  655:            count++;
        -:  656:
    #####:  657:          args[i - 1] = r1;
    #####:  658:          i--;
        -:  659:        }
        -:  660:
    #####:  661:        pop(r2);
    #####:  662:        ensure_defined(r2);
        -:  663:
        -:  664:        #if PARANOID_EXEC
    #####:  665:        check_object_canary(r2.o);
        -:  666:        #endif
        -:  667:
    #####:  668:        if (count > 0)
        -:  669:        {
        -:  670:          // if there are undefined args, result for function call
        -:  671:          // is undefined as well.
        -:  672:
    #####:  673:          r1.i = UNDEFINED;
    #####:  674:          push(r1);
    #####:  675:          break;
        -:  676:        }
        -:  677:
    #####:  678:        function = object_as_function(r2.o);
    #####:  679:        result = ERROR_INTERNAL_FATAL_ERROR;
        -:  680:
    #####:  681:        for (i = 0; i < YR_MAX_OVERLOADED_FUNCTIONS; i++)
        -:  682:        {
    #####:  683:          if (function->prototypes[i].arguments_fmt == NULL)
    #####:  684:            break;
        -:  685:
    #####:  686:          if (strcmp(function->prototypes[i].arguments_fmt, args_fmt) == 0)
        -:  687:          {
    #####:  688:            result = function->prototypes[i].code(args, context, function);
    #####:  689:            break;
        -:  690:          }
        -:  691:        }
        -:  692:
        -:  693:        // if i == YR_MAX_OVERLOADED_FUNCTIONS at this point no matching
        -:  694:        // prototype was found, but this shouldn't happen.
        -:  695:
    #####:  696:        assert(i < YR_MAX_OVERLOADED_FUNCTIONS);
        -:  697:
        -:  698:        // make a copy of the returned object and push the copy into the stack
        -:  699:        // function->return_obj can't be pushed because it can change in
        -:  700:        // subsequent calls to the same function.
        -:  701:
    #####:  702:        if (result == ERROR_SUCCESS)
    #####:  703:          result = yr_object_copy(function->return_obj, &r1.o);
        -:  704:
        -:  705:        // a pointer to the copied object is stored in a arena in order to
        -:  706:        // free the object before exiting yr_execute_code
        -:  707:
    #####:  708:        if (result == ERROR_SUCCESS)
    #####:  709:          result = yr_arena_write_data(obj_arena, &r1.o, sizeof(r1.o), NULL);
        -:  710:
    #####:  711:        stop = (result != ERROR_SUCCESS);
    #####:  712:        push(r1);
    #####:  713:        break;
        -:  714:
    #####:  715:      case OP_FOUND:
    #####:  716:        pop(r1);
    #####:  717:        r1.i = r1.s->matches[tidx].tail != NULL ? 1 : 0;
    #####:  718:        push(r1);
    #####:  719:        break;
        -:  720:
    #####:  721:      case OP_FOUND_AT:
    #####:  722:        pop(r2);
    #####:  723:        pop(r1);
        -:  724:
    #####:  725:        if (is_undef(r1))
        -:  726:        {
    #####:  727:          r1.i = 0;
    #####:  728:          push(r1);
    #####:  729:          break;
        -:  730:        }
        -:  731:
    #####:  732:        match = r2.s->matches[tidx].head;
    #####:  733:        r3.i = false;
        -:  734:
    #####:  735:        while (match != NULL)
        -:  736:        {
    #####:  737:          if (r1.i == match->base + match->offset)
        -:  738:          {
    #####:  739:            r3.i = true;
    #####:  740:            break;
        -:  741:          }
        -:  742:
    #####:  743:          if (r1.i < match->base + match->offset)
    #####:  744:            break;
        -:  745:
    #####:  746:          match = match->next;
        -:  747:        }
        -:  748:
    #####:  749:        push(r3);
    #####:  750:        break;
        -:  751:
    #####:  752:      case OP_FOUND_IN:
    #####:  753:        pop(r3);
    #####:  754:        pop(r2);
    #####:  755:        pop(r1);
        -:  756:
    #####:  757:        ensure_defined(r1);
    #####:  758:        ensure_defined(r2);
        -:  759:
    #####:  760:        match = r3.s->matches[tidx].head;
    #####:  761:        r3.i = false;
        -:  762:
    #####:  763:        while (match != NULL && !r3.i)
        -:  764:        {
    #####:  765:          if (match->base + match->offset >= r1.i &&
    #####:  766:              match->base + match->offset <= r2.i)
        -:  767:          {
    #####:  768:            r3.i = true;
        -:  769:          }
        -:  770:
    #####:  771:          if (match->base + match->offset > r2.i)
    #####:  772:            break;
        -:  773:
    #####:  774:          match = match->next;
        -:  775:        }
        -:  776:
    #####:  777:        push(r3);
    #####:  778:        break;
        -:  779:
    #####:  780:      case OP_COUNT:
    #####:  781:        pop(r1);
    #####:  782:        r1.i = r1.s->matches[tidx].count;
    #####:  783:        push(r1);
    #####:  784:        break;
        -:  785:
    #####:  786:      case OP_OFFSET:
    #####:  787:        pop(r2);
    #####:  788:        pop(r1);
        -:  789:
    #####:  790:        ensure_defined(r1);
        -:  791:
    #####:  792:        match = r2.s->matches[tidx].head;
    #####:  793:        i = 1;
    #####:  794:        r3.i = UNDEFINED;
        -:  795:
    #####:  796:        while (match != NULL && r3.i == UNDEFINED)
        -:  797:        {
    #####:  798:          if (r1.i == i)
    #####:  799:            r3.i = match->base + match->offset;
        -:  800:
    #####:  801:          i++;
    #####:  802:          match = match->next;
        -:  803:        }
        -:  804:
    #####:  805:        push(r3);
    #####:  806:        break;
        -:  807:
    #####:  808:      case OP_LENGTH:
    #####:  809:        pop(r2);
    #####:  810:        pop(r1);
        -:  811:
    #####:  812:        ensure_defined(r1);
        -:  813:
    #####:  814:        match = r2.s->matches[tidx].head;
    #####:  815:        i = 1;
    #####:  816:        r3.i = UNDEFINED;
        -:  817:
    #####:  818:        while (match != NULL && r3.i == UNDEFINED)
        -:  819:        {
    #####:  820:          if (r1.i == i)
    #####:  821:            r3.i = match->match_length;
        -:  822:
    #####:  823:          i++;
    #####:  824:          match = match->next;
        -:  825:        }
        -:  826:
    #####:  827:        push(r3);
    #####:  828:        break;
        -:  829:
    #####:  830:      case OP_OF:
    #####:  831:        found = 0;
    #####:  832:        count = 0;
    #####:  833:        pop(r1);
        -:  834:
    #####:  835:        while (!is_undef(r1))
        -:  836:        {
    #####:  837:          if (r1.s->matches[tidx].tail != NULL)
    #####:  838:            found++;
    #####:  839:          count++;
    #####:  840:          pop(r1);
        -:  841:        }
        -:  842:
    #####:  843:        pop(r2);
        -:  844:
    #####:  845:        if (is_undef(r2))
    #####:  846:          r1.i = found >= count ? 1 : 0;
        -:  847:        else
    #####:  848:          r1.i = found >= r2.i ? 1 : 0;
        -:  849:
    #####:  850:        push(r1);
    #####:  851:        break;
        -:  852:
    #####:  853:      case OP_FILESIZE:
    #####:  854:        r1.i = context->file_size;
    #####:  855:        push(r1);
    #####:  856:        break;
        -:  857:
    #####:  858:      case OP_ENTRYPOINT:
    #####:  859:        r1.i = context->entry_point;
    #####:  860:        push(r1);
    #####:  861:        break;
        -:  862:
    #####:  863:      case OP_INT8:
    #####:  864:        pop(r1);
    #####:  865:        r1.i = read_int8_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  866:        push(r1);
    #####:  867:        break;
        -:  868:
    #####:  869:      case OP_INT16:
    #####:  870:        pop(r1);
    #####:  871:        r1.i = read_int16_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  872:        push(r1);
    #####:  873:        break;
        -:  874:
    #####:  875:      case OP_INT32:
    #####:  876:        pop(r1);
    #####:  877:        r1.i = read_int32_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  878:        push(r1);
    #####:  879:        break;
        -:  880:
    #####:  881:      case OP_UINT8:
    #####:  882:        pop(r1);
    #####:  883:        r1.i = read_uint8_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  884:        push(r1);
    #####:  885:        break;
        -:  886:
    #####:  887:      case OP_UINT16:
    #####:  888:        pop(r1);
    #####:  889:        r1.i = read_uint16_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  890:        push(r1);
    #####:  891:        break;
        -:  892:
    #####:  893:      case OP_UINT32:
    #####:  894:        pop(r1);
    #####:  895:        r1.i = read_uint32_t_little_endian(context->iterator, (size_t) r1.i);
    #####:  896:        push(r1);
    #####:  897:        break;
        -:  898:
    #####:  899:      case OP_INT8BE:
    #####:  900:        pop(r1);
    #####:  901:        r1.i = read_int8_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  902:        push(r1);
    #####:  903:        break;
        -:  904:
    #####:  905:      case OP_INT16BE:
    #####:  906:        pop(r1);
    #####:  907:        r1.i = read_int16_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  908:        push(r1);
    #####:  909:        break;
        -:  910:
    #####:  911:      case OP_INT32BE:
    #####:  912:        pop(r1);
    #####:  913:        r1.i = read_int32_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  914:        push(r1);
    #####:  915:        break;
        -:  916:
    #####:  917:      case OP_UINT8BE:
    #####:  918:        pop(r1);
    #####:  919:        r1.i = read_uint8_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  920:        push(r1);
    #####:  921:        break;
        -:  922:
    #####:  923:      case OP_UINT16BE:
    #####:  924:        pop(r1);
    #####:  925:        r1.i = read_uint16_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  926:        push(r1);
    #####:  927:        break;
        -:  928:
    #####:  929:      case OP_UINT32BE:
    #####:  930:        pop(r1);
    #####:  931:        r1.i = read_uint32_t_big_endian(context->iterator, (size_t) r1.i);
    #####:  932:        push(r1);
    #####:  933:        break;
        -:  934:
    #####:  935:      case OP_CONTAINS:
    #####:  936:        pop(r2);
    #####:  937:        pop(r1);
        -:  938:
    #####:  939:        ensure_defined(r1);
    #####:  940:        ensure_defined(r2);
        -:  941:
    #####:  942:        r1.i = memmem(r1.ss->c_string, r1.ss->length,
    #####:  943:                      r2.ss->c_string, r2.ss->length) != NULL;
    #####:  944:        push(r1);
    #####:  945:        break;
        -:  946:
    #####:  947:      case OP_IMPORT:
    #####:  948:        r1.i = *(uint64_t*)(ip);
    #####:  949:        ip += sizeof(uint64_t);
        -:  950:
    #####:  951:        result = yr_modules_load((char*) r1.p, context);
        -:  952:
    #####:  953:        if (result != ERROR_SUCCESS)
    #####:  954:          stop = true;
        -:  955:
    #####:  956:        break;
        -:  957:
    #####:  958:      case OP_MATCHES:
        -:  959:
    #####:  960:        pop(r2);
    #####:  961:        pop(r1);
        -:  962:
    #####:  963:        ensure_defined(r2);
    #####:  964:        ensure_defined(r1);
        -:  965:
    #####:  966:        if (r1.ss->length == 0)
        -:  967:        {
    #####:  968:          r1.i = false;
    #####:  969:          push(r1);
    #####:  970:          break;
        -:  971:        }
        -:  972:
    #####:  973:        result = yr_re_exec(
        -:  974:          context,
    #####:  975:          (uint8_t*) r2.re->code,
    #####:  976:          (uint8_t*) r1.ss->c_string,
    #####:  977:          r1.ss->length,
        -:  978:          0,
    #####:  979:          r2.re->flags | RE_FLAGS_SCAN,
        -:  980:          NULL,
        -:  981:          NULL,
        -:  982:          &found);
        -:  983:
    #####:  984:        if (result != ERROR_SUCCESS)
    #####:  985:          stop = true;
        -:  986:
    #####:  987:        r1.i = found >= 0;
    #####:  988:        push(r1);
    #####:  989:        break;
        -:  990:
    #####:  991:      case OP_INT_TO_DBL:
        -:  992:
    #####:  993:        r1.i = *(uint64_t*)(ip);
    #####:  994:        ip += sizeof(uint64_t);
        -:  995:
        -:  996:        #if PARANOID_EXEC
    #####:  997:        if (r1.i > sp || sp - r1.i >= stack_size)
        -:  998:        {
    #####:  999:          stop = true;
    #####: 1000:          result = ERROR_INTERNAL_FATAL_ERROR;
    #####: 1001:          break;
        -: 1002:        }
        -: 1003:        #endif
        -: 1004:
    #####: 1005:        r2 = stack[sp - r1.i];
        -: 1006:
    #####: 1007:        if (is_undef(r2))
    #####: 1008:          stack[sp - r1.i].i = UNDEFINED;
        -: 1009:        else
    #####: 1010:          stack[sp - r1.i].d = (double) r2.i;
    #####: 1011:        break;
        -: 1012:
    #####: 1013:      case OP_STR_TO_BOOL:
    #####: 1014:        pop(r1);
    #####: 1015:        ensure_defined(r1);
    #####: 1016:        r1.i = r1.ss->length > 0;
    #####: 1017:        push(r1);
    #####: 1018:        break;
        -: 1019:
    #####: 1020:      case OP_INT_EQ:
    #####: 1021:        pop(r2);
    #####: 1022:        pop(r1);
    #####: 1023:        ensure_defined(r2);
    #####: 1024:        ensure_defined(r1);
    #####: 1025:        r1.i = r1.i == r2.i;
    #####: 1026:        push(r1);
    #####: 1027:        break;
        -: 1028:
    #####: 1029:      case OP_INT_NEQ:
    #####: 1030:        pop(r2);
    #####: 1031:        pop(r1);
    #####: 1032:        ensure_defined(r2);
    #####: 1033:        ensure_defined(r1);
    #####: 1034:        r1.i = r1.i != r2.i;
    #####: 1035:        push(r1);
    #####: 1036:        break;
        -: 1037:
    #####: 1038:      case OP_INT_LT:
    #####: 1039:        pop(r2);
    #####: 1040:        pop(r1);
    #####: 1041:        ensure_defined(r2);
    #####: 1042:        ensure_defined(r1);
    #####: 1043:        r1.i = r1.i < r2.i;
    #####: 1044:        push(r1);
    #####: 1045:        break;
        -: 1046:
    #####: 1047:      case OP_INT_GT:
    #####: 1048:        pop(r2);
    #####: 1049:        pop(r1);
    #####: 1050:        ensure_defined(r2);
    #####: 1051:        ensure_defined(r1);
    #####: 1052:        r1.i = r1.i > r2.i;
    #####: 1053:        push(r1);
    #####: 1054:        break;
        -: 1055:
    #####: 1056:      case OP_INT_LE:
    #####: 1057:        pop(r2);
    #####: 1058:        pop(r1);
    #####: 1059:        ensure_defined(r2);
    #####: 1060:        ensure_defined(r1);
    #####: 1061:        r1.i = r1.i <= r2.i;
    #####: 1062:        push(r1);
    #####: 1063:        break;
        -: 1064:
    #####: 1065:      case OP_INT_GE:
    #####: 1066:        pop(r2);
    #####: 1067:        pop(r1);
    #####: 1068:        ensure_defined(r2);
    #####: 1069:        ensure_defined(r1);
    #####: 1070:        r1.i = r1.i >= r2.i;
    #####: 1071:        push(r1);
    #####: 1072:        break;
        -: 1073:
    #####: 1074:      case OP_INT_ADD:
    #####: 1075:        pop(r2);
    #####: 1076:        pop(r1);
    #####: 1077:        ensure_defined(r2);
    #####: 1078:        ensure_defined(r1);
    #####: 1079:        r1.i = r1.i + r2.i;
    #####: 1080:        push(r1);
    #####: 1081:        break;
        -: 1082:
    #####: 1083:      case OP_INT_SUB:
    #####: 1084:        pop(r2);
    #####: 1085:        pop(r1);
    #####: 1086:        ensure_defined(r2);
    #####: 1087:        ensure_defined(r1);
    #####: 1088:        r1.i = r1.i - r2.i;
    #####: 1089:        push(r1);
    #####: 1090:        break;
        -: 1091:
    #####: 1092:      case OP_INT_MUL:
    #####: 1093:        pop(r2);
    #####: 1094:        pop(r1);
    #####: 1095:        ensure_defined(r2);
    #####: 1096:        ensure_defined(r1);
    #####: 1097:        r1.i = r1.i * r2.i;
    #####: 1098:        push(r1);
    #####: 1099:        break;
        -: 1100:
    #####: 1101:      case OP_INT_DIV:
    #####: 1102:        pop(r2);
    #####: 1103:        pop(r1);
    #####: 1104:        ensure_defined(r2);
    #####: 1105:        ensure_defined(r1);
    #####: 1106:        if (r2.i != 0)
    #####: 1107:          r1.i = r1.i / r2.i;
        -: 1108:        else
    #####: 1109:          r1.i = UNDEFINED;
    #####: 1110:        push(r1);
    #####: 1111:        break;
        -: 1112:
    #####: 1113:      case OP_INT_MINUS:
    #####: 1114:        pop(r1);
    #####: 1115:        ensure_defined(r1);
    #####: 1116:        r1.i = -r1.i;
    #####: 1117:        push(r1);
    #####: 1118:        break;
        -: 1119:
    #####: 1120:      case OP_DBL_LT:
    #####: 1121:        pop(r2);
    #####: 1122:        pop(r1);
    #####: 1123:        ensure_defined(r2);
    #####: 1124:        ensure_defined(r1);
    #####: 1125:        r1.i = r1.d < r2.d;
    #####: 1126:        push(r1);
    #####: 1127:        break;
        -: 1128:
    #####: 1129:      case OP_DBL_GT:
    #####: 1130:        pop(r2);
    #####: 1131:        pop(r1);
    #####: 1132:        ensure_defined(r2);
    #####: 1133:        ensure_defined(r1);
    #####: 1134:        r1.i = r1.d > r2.d;
    #####: 1135:        push(r1);
    #####: 1136:        break;
        -: 1137:
    #####: 1138:      case OP_DBL_LE:
    #####: 1139:        pop(r2);
    #####: 1140:        pop(r1);
    #####: 1141:        ensure_defined(r2);
    #####: 1142:        ensure_defined(r1);
    #####: 1143:        r1.i = r1.d <= r2.d;
    #####: 1144:        push(r1);
    #####: 1145:        break;
        -: 1146:
    #####: 1147:      case OP_DBL_GE:
    #####: 1148:        pop(r2);
    #####: 1149:        pop(r1);
    #####: 1150:        ensure_defined(r2);
    #####: 1151:        ensure_defined(r1);
    #####: 1152:        r1.i = r1.d >= r2.d;
    #####: 1153:        push(r1);
    #####: 1154:        break;
        -: 1155:
    #####: 1156:      case OP_DBL_EQ:
    #####: 1157:        pop(r2);
    #####: 1158:        pop(r1);
    #####: 1159:        ensure_defined(r2);
    #####: 1160:        ensure_defined(r1);
    #####: 1161:        r1.i = r1.d == r2.d;
    #####: 1162:        push(r1);
    #####: 1163:        break;
        -: 1164:
    #####: 1165:      case OP_DBL_NEQ:
    #####: 1166:        pop(r2);
    #####: 1167:        pop(r1);
    #####: 1168:        ensure_defined(r2);
    #####: 1169:        ensure_defined(r1);
    #####: 1170:        r1.i = r1.d != r2.d;
    #####: 1171:        push(r1);
    #####: 1172:        break;
        -: 1173:
    #####: 1174:      case OP_DBL_ADD:
    #####: 1175:        pop(r2);
    #####: 1176:        pop(r1);
    #####: 1177:        ensure_defined(r2);
    #####: 1178:        ensure_defined(r1);
    #####: 1179:        r1.d = r1.d + r2.d;
    #####: 1180:        push(r1);
    #####: 1181:        break;
        -: 1182:
    #####: 1183:      case OP_DBL_SUB:
    #####: 1184:        pop(r2);
    #####: 1185:        pop(r1);
    #####: 1186:        ensure_defined(r2);
    #####: 1187:        ensure_defined(r1);
    #####: 1188:        r1.d = r1.d - r2.d;
    #####: 1189:        push(r1);
    #####: 1190:        break;
        -: 1191:
    #####: 1192:      case OP_DBL_MUL:
    #####: 1193:        pop(r2);
    #####: 1194:        pop(r1);
    #####: 1195:        ensure_defined(r2);
    #####: 1196:        ensure_defined(r1);
    #####: 1197:        r1.d = r1.d * r2.d;
    #####: 1198:        push(r1);
    #####: 1199:        break;
        -: 1200:
    #####: 1201:      case OP_DBL_DIV:
    #####: 1202:        pop(r2);
    #####: 1203:        pop(r1);
    #####: 1204:        ensure_defined(r2);
    #####: 1205:        ensure_defined(r1);
    #####: 1206:        r1.d = r1.d / r2.d;
    #####: 1207:        push(r1);
    #####: 1208:        break;
        -: 1209:
    #####: 1210:      case OP_DBL_MINUS:
    #####: 1211:        pop(r1);
    #####: 1212:        ensure_defined(r1);
    #####: 1213:        r1.d = -r1.d;
    #####: 1214:        push(r1);
    #####: 1215:        break;
        -: 1216:
    #####: 1217:      case OP_STR_EQ:
        -: 1218:      case OP_STR_NEQ:
        -: 1219:      case OP_STR_LT:
        -: 1220:      case OP_STR_LE:
        -: 1221:      case OP_STR_GT:
        -: 1222:      case OP_STR_GE:
        -: 1223:
    #####: 1224:        pop(r2);
    #####: 1225:        pop(r1);
        -: 1226:
    #####: 1227:        ensure_defined(r1);
    #####: 1228:        ensure_defined(r2);
        -: 1229:
    #####: 1230:        switch(opcode)
        -: 1231:        {
    #####: 1232:          case OP_STR_EQ:
    #####: 1233:            r1.i = (sized_string_cmp(r1.ss, r2.ss) == 0);
    #####: 1234:            break;
    #####: 1235:          case OP_STR_NEQ:
    #####: 1236:            r1.i = (sized_string_cmp(r1.ss, r2.ss) != 0);
    #####: 1237:            break;
    #####: 1238:          case OP_STR_LT:
    #####: 1239:            r1.i = (sized_string_cmp(r1.ss, r2.ss) < 0);
    #####: 1240:            break;
    #####: 1241:          case OP_STR_LE:
    #####: 1242:            r1.i = (sized_string_cmp(r1.ss, r2.ss) <= 0);
    #####: 1243:            break;
    #####: 1244:          case OP_STR_GT:
    #####: 1245:            r1.i = (sized_string_cmp(r1.ss, r2.ss) > 0);
    #####: 1246:            break;
    #####: 1247:          case OP_STR_GE:
    #####: 1248:            r1.i = (sized_string_cmp(r1.ss, r2.ss) >= 0);
    #####: 1249:            break;
        -: 1250:        }
        -: 1251:
    #####: 1252:        push(r1);
    #####: 1253:        break;
        -: 1254:
    #####: 1255:      default:
        -: 1256:        // Unknown instruction, this shouldn't happen.
    #####: 1257:        assert(false);
        -: 1258:    }
        -: 1259:
        -: 1260:    // Check for timeout every 10 instruction cycles. If timeout == 0 it means
        -: 1261:    // no timeout at all.
        -: 1262:
    #####: 1263:    if (context->timeout > 0L && ++cycle == 10)
        -: 1264:    {
    #####: 1265:      elapsed_time = yr_stopwatch_elapsed_us(&context->stopwatch);
        -: 1266:
    #####: 1267:      if (elapsed_time > context->timeout)
        -: 1268:      {
        -: 1269:        #ifdef PROFILING_ENABLED
        -: 1270:        assert(current_rule != NULL);
        -: 1271:        current_rule->time_cost += elapsed_time - start_time;
        -: 1272:        #endif
    #####: 1273:        result = ERROR_SCAN_TIMEOUT;
    #####: 1274:        stop = true;
        -: 1275:      }
        -: 1276:
    #####: 1277:      cycle = 0;
        -: 1278:    }
        -: 1279:  }
        -: 1280:
    #####: 1281:  obj_ptr = (YR_OBJECT**) yr_arena_base_address(obj_arena);
        -: 1282:
    #####: 1283:  while (obj_ptr != NULL)
        -: 1284:  {
    #####: 1285:    yr_object_destroy(*obj_ptr);
        -: 1286:
    #####: 1287:    obj_ptr = (YR_OBJECT**) yr_arena_next_address(
        -: 1288:        obj_arena, obj_ptr, sizeof(YR_OBJECT*));
        -: 1289:  }
        -: 1290:
    #####: 1291:  yr_arena_destroy(obj_arena);
    #####: 1292:  yr_modules_unload_all(context);
    #####: 1293:  yr_free(stack);
        -: 1294:
    #####: 1295:  return result;
        -: 1296:}
