        -:    0:Source:bitmask.c
        -:    0:Graph:/home/workspace/libyara/bitmask.gcno
        -:    0:Data:/home/workspace/libyara/bitmask.gcda
        -:    0:Runs:7
        -:    1:/*
        -:    2:Copyright (c) 2018. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#include <assert.h>
        -:   31:#include <stdbool.h>
        -:   32:
        -:   33:#include <yara/utils.h>
        -:   34:#include <yara/bitmask.h>
        -:   35:
        -:   36://
        -:   37:// yr_bitmask_find_non_colliding_offset
        -:   38://
        -:   39:// Finds the smaller offset within bitmask A where bitmask B can be accommodated
        -:   40:// without bit collisions. A collision occurs when bots bitmasks have a bit set
        -:   41:// to 1 at the same offset. This function assumes that the first bit in B is 1
        -:   42:// and do optimizations that rely on that.
        -:   43://
        -:   44:// The function also receives a pointer to an uint64_t where the function stores
        -:   45:// a value that is used for speeding-up subsequent searches over the same
        -:   46:// bitmask A. When called for the first time with some bitmask A, the pointer
        -:   47:// must point to zero-initialized uint64_t. In the next call the function uses
        -:   48:// the previously stored value for skiping over a portion of the A bitmask and
        -:   49:// updates the value.
        -:   50://
        -:   51:// Args:
        -:   52://    YR_BITMASK* a      - Bitmask A
        -:   53://    YR_BITMASK* b      - Bitmask B
        -:   54://    uint64_t len_a     - Length of bitmask A in bits
        -:   55://    uint64_t len_b     - Length of bitmask B in bits
        -:   56://    uint64_t* hint     - Address of an uint64_t where the function writes a
        -:   57://                         value that can be used as a hint.
        -:   58:// Returns:
        -:   59://    The smaller offset within bitmask A where bitmask B can be put.
        -:   60://
        -:   61:
    #####:   62:uint32_t yr_bitmask_find_non_colliding_offset(
        -:   63:    YR_BITMASK* a,
        -:   64:    YR_BITMASK* b,
        -:   65:    uint32_t len_a,
        -:   66:    uint32_t len_b,
        -:   67:    uint32_t* off_a)
        -:   68:{
        -:   69:  uint32_t i, j, k;
        -:   70:
        -:   71:  // Ensure that the first bit of bitmask B is set, as this function does some
        -:   72:  // optimizations that rely on that.
    #####:   73:  assert(yr_bitmask_isset(b, 0));
        -:   74:
        -:   75:  // Skip all slots that are filled with 1s. It's safe to do that because the
        -:   76:  // first bit of B is 1, so we won't be able to accommodate B at any offset
        -:   77:  // within such slots.
    #####:   78:  for (i = *off_a / YR_BITMASK_SLOT_BITS;
    #####:   79:       i <= len_a / YR_BITMASK_SLOT_BITS && a[i] == 0xFFFFFFFFFFFFFFFFL;
    #####:   80:       i++);
        -:   81:
    #####:   82:  *off_a = i;
        -:   83:
    #####:   84:  for (; i <= len_a / YR_BITMASK_SLOT_BITS; i++)
        -:   85:  {
        -:   86:    // The slot is filled with 1s, we can safely skip it.
    #####:   87:    if (a[i] == 0xFFFFFFFFFFFFFFFFL)
    #####:   88:      continue;
        -:   89:
    #####:   90:    for (j = 0; j <= yr_min(len_a, YR_BITMASK_SLOT_BITS - 1); j++)
        -:   91:    {
    #####:   92:      bool found = true;
        -:   93:
    #####:   94:      for (k = 0; k <= len_b / YR_BITMASK_SLOT_BITS; k++)
        -:   95:      {
    #####:   96:        YR_BITMASK m = b[k] << j;
        -:   97:
    #####:   98:        if (j > 0 && k > 0)
    #####:   99:          m |= b[k - 1] >> (YR_BITMASK_SLOT_BITS - j);
        -:  100:
    #####:  101:        if ((i + k <= len_a / YR_BITMASK_SLOT_BITS) && (m & a[i + k]) != 0)
        -:  102:        {
    #####:  103:          found = false;
    #####:  104:          break ;
        -:  105:        }
        -:  106:      }
        -:  107:
    #####:  108:      if (found)
    #####:  109:        return i * YR_BITMASK_SLOT_BITS + j;
        -:  110:    }
        -:  111:  }
        -:  112:
    #####:  113:  return len_a;
        -:  114:}
