        -:    0:Source:lexer.l
        -:    0:Graph:/home/workspace/libyara/lexer.gcno
        -:    0:Data:/home/workspace/libyara/lexer.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:/* Lexical analyzer for YARA */
        -:   31:
        -:   32:%{
        -:   33:
        -:   34:/* Disable warnings for unused functions in this file.
        -:   35:
        -:   36:As we redefine YY_FATAL_ERROR macro to use our own function yara_yyfatal, the
        -:   37:yy_fatal_error function generated by Flex is not actually used, causing a
        -:   38:compiler warning. Flex doesn't offer any options to remove the yy_fatal_error
        -:   39:function. When they include something like %option noyy_fatal_error as they do
        -:   40:with noyywrap then we can remove this pragma.
        -:   41:*/
        -:   42:
        -:   43:#ifdef __GNUC__
        -:   44:#pragma GCC diagnostic ignored "-Wunused-function"
        -:   45:#endif
        -:   46:
        -:   47:#include <math.h>
        -:   48:#include <stdarg.h>
        -:   49:#include <stdbool.h>
        -:   50:#include <stdio.h>
        -:   51:#include <stdlib.h>
        -:   52:#include <string.h>
        -:   53:#include <setjmp.h>
        -:   54:
        -:   55:#if defined(_WIN32) || defined(__CYGWIN__)
        -:   56:#include <windows.h>
        -:   57:#else
        -:   58:#include <sys/stat.h>
        -:   59:#include <unistd.h>
        -:   60:#endif
        -:   61:
        -:   62:#if defined(_WIN32)
        -:   63:#define strtoll _strtoi64
        -:   64:#endif
        -:   65:
        -:   66:#include <yara/integers.h>
        -:   67:#include <yara/lexer.h>
        -:   68:#include <yara/sizedstr.h>
        -:   69:#include <yara/error.h>
        -:   70:#include <yara/mem.h>
        -:   71:#include <yara/strutils.h>
        -:   72:
        -:   73:#include "grammar.h"
        -:   74:
        -:   75:#define error(error_code) \
        -:   76:    { \
        -:   77:      compiler->last_error = error_code; \
        -:   78:      yyerror(yyscanner, compiler, NULL); \
        -:   79:      yyterminate(); \
        -:   80:    }
        -:   81:
        -:   82:#define syntax_error(error_msg) \
        -:   83:    { \
        -:   84:      yr_compiler_set_error_extra_info(compiler, error_msg); \
        -:   85:      error(ERROR_SYNTAX_ERROR); \
        -:   86:    }
        -:   87:
        -:   88:#define lex_check_space_ok(data, current_size, max_length) \
        -:   89:    if (strlen(data) + current_size >= max_length - 1) \
        -:   90:    { \
        -:   91:      yyerror(yyscanner, compiler, "out of space in lex_buf"); \
        -:   92:      yyterminate(); \
        -:   93:    }
        -:   94:
        -:   95:#define yytext_to_buffer \
        -:   96:    { \
        -:   97:      char *yptr = yytext; \
        -:   98:      lex_check_space_ok(yptr, yyextra->lex_buf_len, YR_LEX_BUF_SIZE); \
        -:   99:      while(*yptr) \
        -:  100:      { \
        -:  101:        *yyextra->lex_buf_ptr++ = *yptr++; \
        -:  102:        yyextra->lex_buf_len++; \
        -:  103:      } \
        -:  104:    }
        -:  105:
        -:  106:#define alloc_sized_string(str, str_len) \
        -:  107:  SIZED_STRING* str = (SIZED_STRING*) yr_malloc( \
        -:  108:      str_len + sizeof(SIZED_STRING)); \
        -:  109:  if (str == NULL) \
        -:  110:  { \
        -:  111:    yyerror(yyscanner, compiler, "not enough memory"); \
        -:  112:    yyterminate(); \
        -:  113:  } \
        -:  114:  else \
        -:  115:  { \
        -:  116:    str->length = (uint32_t) (str_len); \
        -:  117:    str->flags = 0; \
        -:  118:  } \
        -:  119:
        -:  120:#ifdef _WIN32
        -:  121:#define snprintf _snprintf
        -:  122:#endif
        -:  123:
    #####:  124:static bool is_absolute_path(
        -:  125:    char* path)
        -:  126:{
    #####:  127:  if (path == NULL)
    #####:  128:    return false;
        -:  129:
        -:  130:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  131:  return strlen(path) > 2 &&
        -:  132:      path[1] == ':' && (path[2] == '/' || path[2] == '\\');
        -:  133:  #else
    #####:  134:  return strlen(path) > 0 && path[0] == '/';
        -:  135:  #endif
        -:  136:}
        -:  137:
        -:  138:%}
        -:  139:
        -:  140:%option reentrant bison-bridge
        -:  141:%option noyywrap
        -:  142:%option nounistd
        -:  143:%option noinput
        -:  144:%option nounput
        -:  145:%option never-interactive
        -:  146:%option yylineno
        -:  147:%option prefix="yara_yy"
        -:  148:%option outfile="lex.yy.c"
        -:  149:
        -:  150:%option verbose
        -:  151:%option warn
        -:  152:
        -:  153:%x str
        -:  154:%x regexp
        -:  155:%x include
        -:  156:%x comment
        -:  157:
        -:  158:digit         [0-9]
        -:  159:letter        [a-zA-Z]
        -:  160:hexdigit      [a-fA-F0-9]
        -:  161:octdigit      [0-7]
        -:  162:
        -:  163:%%
        -:  164:
    #####:  165:".."                    { return _DOT_DOT_;     }
    #####:  166:"<"                     { return _LT_;          }
    #####:  167:">"                     { return _GT_;          }
    #####:  168:"<="                    { return _LE_;          }
    #####:  169:">="                    { return _GE_;          }
    #####:  170:"=="                    { return _EQ_;          }
    #####:  171:"!="                    { return _NEQ_;         }
    #####:  172:"<<"                    { return _SHIFT_LEFT_;  }
    #####:  173:">>"                    { return _SHIFT_RIGHT_; }
    #####:  174:"private"               { return _PRIVATE_;     }
    #####:  175:"global"                { return _GLOBAL_;      }
    #####:  176:"rule"                  { return _RULE_;        }
       1*:  177:"meta"                  { return _META_;        }
    #####:  178:"strings"               { return _STRINGS_;     }
    #####:  179:"ascii"                 { return _ASCII_;       }
    #####:  180:"wide"                  { return _WIDE_;        }
    #####:  181:"xor"                   { return _XOR_;         }
    #####:  182:"fullword"              { return _FULLWORD_;    }
    #####:  183:"nocase"                { return _NOCASE_;      }
    #####:  184:"condition"             { return _CONDITION_;   }
        1:  185:"true"                  { return _TRUE_;        }
       1*:  186:"false"                 { return _FALSE_;       }
    #####:  187:"not"                   { return _NOT_;         }
    #####:  188:"and"                   { return _AND_;         }
    #####:  189:"or"                    { return _OR_;          }
    #####:  190:"at"                    { return _AT_;          }
    #####:  191:"in"                    { return _IN_;          }
    #####:  192:"of"                    { return _OF_;          }
    #####:  193:"them"                  { return _THEM_;        }
    #####:  194:"for"                   { return _FOR_;         }
    #####:  195:"all"                   { return _ALL_;         }
    #####:  196:"any"                   { return _ANY_;         }
    #####:  197:"entrypoint"            { return _ENTRYPOINT_;  }
    #####:  198:"filesize"              { return _FILESIZE_;    }
    #####:  199:"matches"               { return _MATCHES_;     }
    #####:  200:"contains"              { return _CONTAINS_;    }
    #####:  201:"import"                { return _IMPORT_;      }
    #####:  202:
    #####:  203:
    #####:  204:"/*"                    { BEGIN(comment);       }
    #####:  205:<comment>"*/"           { BEGIN(INITIAL);       }
    #####:  206:<comment>(.|\n)         { /* skip comments */   }
    #####:  207:
    #####:  208:
        -:  209:"//"[^\n]*              { /* skip single-line comments */ }
    #####:  210:
    #####:  211:
        -:  212:include[ \t]+\"         {
    #####:  213:                          yyextra->lex_buf_ptr = yyextra->lex_buf;
    #####:  214:                          yyextra->lex_buf_len = 0;
    #####:  215:                          BEGIN(include);
        -:  216:                        }
    #####:  217:
    #####:  218:
    #####:  219:<include>[^\"]+         { yytext_to_buffer; }
    #####:  220:
    #####:  221:
        -:  222:<include>\"             {
        -:  223:
    #####:  224:  if (compiler->include_callback != NULL)
        -:  225:  {
        -:  226:    #ifdef _MSC_VER
        -:  227:    char* b = NULL;
        -:  228:    #endif
    #####:  229:    char* s = NULL;
        -:  230:    char* f;
        -:  231:
        -:  232:    char buffer[1024];
        -:  233:    const char* included_rules;
        -:  234:    char* current_file_name;
        -:  235:    char* include_path;
        -:  236:
    #####:  237:    *yyextra->lex_buf_ptr = '\0'; // null-terminate included file path
        -:  238:
    #####:  239:    current_file_name = yr_compiler_get_current_file_name(compiler);
        -:  240:
    #####:  241:    if (current_file_name == NULL ||
    #####:  242:        compiler->include_callback != _yr_compiler_default_include_callback ||
    #####:  243:        is_absolute_path(yyextra->lex_buf))
        -:  244:    {
    #####:  245:      include_path = yyextra->lex_buf;
        -:  246:    }
        -:  247:    else
        -:  248:    {
    #####:  249:      strlcpy(buffer, current_file_name, sizeof(buffer));
    #####:  250:      s = strrchr(buffer, '/');
        -:  251:
        -:  252:      #ifdef _MSC_VER
        -:  253:      b = strrchr(buffer, '\\'); // in Windows both path delimiters are accepted
        -:  254:      #endif
        -:  255:
        -:  256:      #ifdef _MSC_VER
        -:  257:      if (s != NULL || b != NULL)
        -:  258:      #else
    #####:  259:      if (s != NULL)
        -:  260:      #endif
        -:  261:      {
        -:  262:        #ifdef _MSC_VER
        -:  263:        f = (b > s) ? (b + 1) : (s + 1);
        -:  264:        #else
    #####:  265:        f = s + 1;
        -:  266:        #endif
        -:  267:
    #####:  268:        strlcpy(f, yyextra->lex_buf, sizeof(buffer) - (f - buffer));
    #####:  269:        include_path = buffer;
        -:  270:      }
        -:  271:      else
        -:  272:      {
    #####:  273:        include_path = yyextra->lex_buf;
        -:  274:      }
        -:  275:    }
        -:  276:
    #####:  277:    included_rules = compiler->include_callback(
        -:  278:        include_path,
        -:  279:        current_file_name,
    #####:  280:        compiler->current_namespace->name,
        -:  281:        compiler->incl_clbk_user_data);
        -:  282:
    #####:  283:    if (included_rules != NULL)
        -:  284:    {
    #####:  285:      int error_code = _yr_compiler_push_file_name(compiler, include_path);
        -:  286:
    #####:  287:      if (error_code != ERROR_SUCCESS)
        -:  288:      {
    #####:  289:        if (error_code == ERROR_INCLUDES_CIRCULAR_REFERENCE)
        -:  290:        {
    #####:  291:          yyerror(yyscanner, compiler, "includes circular reference");
        -:  292:        }
    #####:  293:        else if (error_code == ERROR_INCLUDE_DEPTH_EXCEEDED)
        -:  294:        {
    #####:  295:          yyerror(yyscanner, compiler, "includes depth exceeded");
        -:  296:        }
        -:  297:
    #####:  298:        if (compiler->include_free != NULL)
        -:  299:        {
    #####:  300:          compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -:  301:        }
        -:  302:
    #####:  303:        yyterminate();
        -:  304:      }
        -:  305:
        -:  306:      // Workaround for flex issue: https://github.com/westes/flex/issues/58
    #####:  307:      yypush_buffer_state(YY_CURRENT_BUFFER, yyscanner);
    #####:  308:      yy_scan_string(included_rules, yyscanner);
    #####:  309:      yyset_lineno(1, yyscanner);
        -:  310:
    #####:  311:      if (compiler->include_free != NULL)
        -:  312:      {
    #####:  313:        compiler->include_free(included_rules, compiler->incl_clbk_user_data);
        -:  314:      }
        -:  315:    }
        -:  316:    else
        -:  317:    {
        -:  318:      char* err_msg_fmt;
        -:  319:      char err_msg[512];
        -:  320:
    #####:  321:      if (compiler->include_callback == _yr_compiler_default_include_callback)
        -:  322:      {
    #####:  323:        err_msg_fmt = "can't open include file: %s";
        -:  324:      }
        -:  325:      else
        -:  326:      {
    #####:  327:        err_msg_fmt = "callback failed to provide include resource: %s";
        -:  328:      }
        -:  329:
    #####:  330:      snprintf(
        -:  331:          err_msg,
        -:  332:          sizeof(err_msg),
        -:  333:          err_msg_fmt,
    #####:  334:          yyextra->lex_buf);
        -:  335:
    #####:  336:      yyerror(yyscanner, compiler, err_msg);
        -:  337:    }
        -:  338:
        -:  339:  }
        -:  340:  else // not allowing includes
        -:  341:  {
    #####:  342:    yyerror(yyscanner, compiler, "includes are disabled");
        -:  343:  }
        -:  344:
    #####:  345:  BEGIN(INITIAL);
        -:  346:}
    #####:  347:
        1:  348:
        -:  349:<<EOF>> {
        -:  350:
        1:  351:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  352:
        1:  353:  _yr_compiler_pop_file_name(compiler);
        1:  354:  yypop_buffer_state(yyscanner);
        -:  355:
        1:  356:  if (!YY_CURRENT_BUFFER)
        -:  357:  {
        1:  358:    yyterminate();
        -:  359:  }
        -:  360:}
    #####:  361:
    #####:  362:
        -:  363:$({letter}|{digit}|_)*"*"  {
        -:  364:
    #####:  365:  yylval->c_string = yr_strdup(yytext);
        -:  366:
    #####:  367:  if (yylval->c_string == NULL)
    #####:  368:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  369:
    #####:  370:  return _STRING_IDENTIFIER_WITH_WILDCARD_;
        -:  371:}
        -:  372:
    #####:  373:
        -:  374:$({letter}|{digit}|_)*  {
        -:  375:
    #####:  376:  yylval->c_string = yr_strdup(yytext);
        -:  377:
    #####:  378:  if (yylval->c_string == NULL)
    #####:  379:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  380:
    #####:  381:  return _STRING_IDENTIFIER_;
        -:  382:}
        -:  383:
    #####:  384:
        -:  385:#({letter}|{digit}|_)*  {
        -:  386:
    #####:  387:  yylval->c_string = yr_strdup(yytext);
        -:  388:
    #####:  389:  if (yylval->c_string == NULL)
        -:  390:  {
    #####:  391:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  392:  }
        -:  393:  else
        -:  394:  {
    #####:  395:    yylval->c_string[0] = '$'; /* replace # by $*/
        -:  396:  }
        -:  397:
    #####:  398:  return _STRING_COUNT_;
        -:  399:}
        -:  400:
    #####:  401:
        -:  402:@({letter}|{digit}|_)*  {
        -:  403:
    #####:  404:  yylval->c_string = yr_strdup(yytext);
        -:  405:
    #####:  406:  if (yylval->c_string == NULL)
        -:  407:  {
    #####:  408:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  409:  }
        -:  410:  else
        -:  411:  {
    #####:  412:    yylval->c_string[0] = '$'; /* replace @ by $*/
        -:  413:  }
        -:  414:
    #####:  415:  return _STRING_OFFSET_;
        -:  416:}
        -:  417:
    #####:  418:
        -:  419:!({letter}|{digit}|_)*  {
        -:  420:
    #####:  421:  yylval->c_string = yr_strdup(yytext);
        -:  422:
    #####:  423:  if (yylval->c_string == NULL)
        -:  424:  {
    #####:  425:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  426:  }
        -:  427:  else
        -:  428:  {
    #####:  429:    yylval->c_string[0] = '$'; /* replace ! by $*/
        -:  430:  }
        -:  431:
    #####:  432:  return _STRING_LENGTH_;
        -:  433:}
        -:  434:
    #####:  435:
        -:  436:u?int(8|16|32)(be)? {
        -:  437:
    #####:  438:  char* text = yytext;
        -:  439:
    #####:  440:  if (*text == 'u')
        -:  441:  {
    #####:  442:    yylval->integer = 3;
    #####:  443:    text++;
        -:  444:  }
        -:  445:  else
        -:  446:  {
    #####:  447:    yylval->integer = 0;
        -:  448:  }
        -:  449:
    #####:  450:  if (strstr(text, "int8") == text)
        -:  451:  {
    #####:  452:    yylval->integer += 0;
    #####:  453:    text += 4;
        -:  454:  }
    #####:  455:  else if (strstr(text, "int16") == text)
        -:  456:  {
    #####:  457:    yylval->integer += 1;
    #####:  458:    text += 5;
        -:  459:  }
    #####:  460:  else if (strstr(text, "int32") == text)
        -:  461:  {
    #####:  462:    yylval->integer += 2;
    #####:  463:    text += 5;
        -:  464:  }
        -:  465:
    #####:  466:  if (strcmp(text, "be") == 0)
        -:  467:  {
    #####:  468:    yylval->integer += 6;
        -:  469:  }
        -:  470:
    #####:  471:  return _INTEGER_FUNCTION_;
        -:  472:}
        -:  473:
        1:  474:
        -:  475:({letter}|_)({letter}|{digit}|_)*  {
        -:  476:
        1:  477:  if (strlen(yytext) > 128)
    #####:  478:    syntax_error("identifier too long");
        -:  479:
        1:  480:  yylval->c_string = yr_strdup(yytext);
        -:  481:
        1:  482:  if (yylval->c_string == NULL)
    #####:  483:    error(ERROR_INSUFFICIENT_MEMORY);
        -:  484:
        1:  485:  return _IDENTIFIER_;
        -:  486:}
        -:  487:
    #####:  488:
        -:  489:{digit}+(MB|KB){0,1}  {
        -:  490:
        -:  491:  char *endptr;
        -:  492:
    #####:  493:  errno = 0;
    #####:  494:  yylval->integer = strtoll(yytext, &endptr, 10);
        -:  495:
    #####:  496:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  497:  {
    #####:  498:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  499:    error(ERROR_INTEGER_OVERFLOW);
        -:  500:  }
    #####:  501:  else if (strstr(yytext, "KB") != NULL)
        -:  502:  {
    #####:  503:    if (yylval->integer > LLONG_MAX / 1024)
        -:  504:    {
    #####:  505:      yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  506:      error(ERROR_INTEGER_OVERFLOW);
        -:  507:    }
        -:  508:    else
        -:  509:    {
    #####:  510:      yylval->integer *= 1024;
        -:  511:    }
        -:  512:  }
    #####:  513:  else if (strstr(yytext, "MB") != NULL)
        -:  514:  {
    #####:  515:    if (yylval->integer > LLONG_MAX / 1048576)
        -:  516:    {
    #####:  517:      yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  518:      error(ERROR_INTEGER_OVERFLOW);
        -:  519:    }
        -:  520:    else
        -:  521:    {
    #####:  522:      yylval->integer *= 1048576;
        -:  523:    }
        -:  524:  }
        -:  525:
    #####:  526:  return _NUMBER_;
        -:  527:}
        -:  528:
    #####:  529:{digit}+"."{digit}+  {
    #####:  530:  yylval->double_ = atof(yytext);
    #####:  531:  return _DOUBLE_;
        -:  532:}
        -:  533:
    #####:  534:0x{hexdigit}+  {
        -:  535:
        -:  536:  char *endptr;
        -:  537:
    #####:  538:  errno = 0;
    #####:  539:  yylval->integer = strtoll(yytext, &endptr, 16);
        -:  540:
    #####:  541:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  542:  {
    #####:  543:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  544:    error(ERROR_INTEGER_OVERFLOW);
        -:  545:  }
        -:  546:
    #####:  547:  return _NUMBER_;
        -:  548:}
        -:  549:
    #####:  550:0o{octdigit}+  {
        -:  551:
        -:  552:  char *endptr;
        -:  553:
    #####:  554:  errno = 0;
    #####:  555:  yylval->integer = strtoll(yytext + 2, &endptr, 8);
        -:  556:
    #####:  557:  if (yylval->integer == LLONG_MAX && errno == ERANGE)
        -:  558:  {
    #####:  559:    yr_compiler_set_error_extra_info(compiler, yytext);
    #####:  560:    error(ERROR_INTEGER_OVERFLOW);
        -:  561:  }
        -:  562:
    #####:  563:  return _NUMBER_;
        -:  564:}
        -:  565:
    #####:  566:
        -:  567:<str>\"   {     /* saw closing quote - all done */
        -:  568:
    #####:  569:  alloc_sized_string(s, yyextra->lex_buf_len);
        -:  570:
    #####:  571:  *yyextra->lex_buf_ptr = '\0';
    #####:  572:  memcpy(s->c_string, yyextra->lex_buf, yyextra->lex_buf_len + 1);
    #####:  573:  yylval->sized_string = s;
        -:  574:
    #####:  575:  BEGIN(INITIAL);
        -:  576:
    #####:  577:  return _TEXT_STRING_;
        -:  578:}
        -:  579:
    #####:  580:
        -:  581:<str>\\t   {
        -:  582:
    #####:  583:  lex_check_space_ok("\t", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  584:  *yyextra->lex_buf_ptr++ = '\t';
    #####:  585:  yyextra->lex_buf_len++;
        -:  586:}
    #####:  587:
    #####:  588:
        -:  589:<str>\\n   {
        -:  590:
    #####:  591:  lex_check_space_ok("\n", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  592:  *yyextra->lex_buf_ptr++ = '\n';
    #####:  593:  yyextra->lex_buf_len++;
        -:  594:}
    #####:  595:
    #####:  596:
        -:  597:<str>\\\"   {
        -:  598:
    #####:  599:  lex_check_space_ok("\"", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  600:  *yyextra->lex_buf_ptr++ = '\"';
    #####:  601:  yyextra->lex_buf_len++;
        -:  602:}
    #####:  603:
    #####:  604:
        -:  605:<str>\\\\   {
        -:  606:
    #####:  607:  lex_check_space_ok("\\", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  608:  *yyextra->lex_buf_ptr++ = '\\';
    #####:  609:  yyextra->lex_buf_len++;
        -:  610:}
    #####:  611:
    #####:  612:
        -:  613:<str>\\x{hexdigit}{2} {
        -:  614:
        -:  615:   int result;
        -:  616:
    #####:  617:   sscanf( yytext + 2, "%x", &result );
    #####:  618:   lex_check_space_ok("X", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  619:   *yyextra->lex_buf_ptr++ = result;
    #####:  620:   yyextra->lex_buf_len++;
        -:  621:}
    #####:  622:
    #####:  623:
    #####:  624:<str>[^\\\n\"]+   { yytext_to_buffer; }
    #####:  625:
    #####:  626:
        -:  627:<str>\n  {
    #####:  628:  syntax_error("unterminated string");
        -:  629:}
        -:  630:
    #####:  631:
        -:  632:<str>\\(.|\n) {
    #####:  633:  syntax_error("illegal escape sequence");
        -:  634:}
        -:  635:
    #####:  636:
        -:  637:<regexp>\/i?s?  {
        -:  638:
    #####:  639:  if (yyextra->lex_buf_len > 0)
        -:  640:  {
    #####:  641:    alloc_sized_string(s, yyextra->lex_buf_len);
        -:  642:
    #####:  643:    if (yytext[1] == 'i')
    #####:  644:      s->flags |= SIZED_STRING_FLAGS_NO_CASE;
        -:  645:
    #####:  646:    if (yytext[1] == 's' || yytext[2] == 's')
    #####:  647:      s->flags |= SIZED_STRING_FLAGS_DOT_ALL;
        -:  648:
    #####:  649:    *yyextra->lex_buf_ptr = '\0';
    #####:  650:    strlcpy(s->c_string, yyextra->lex_buf, s->length + 1);
    #####:  651:    yylval->sized_string = s;
        -:  652:  }
        -:  653:  else
        -:  654:  {
    #####:  655:    syntax_error("empty regular expression");
        -:  656:  }
        -:  657:
    #####:  658:  BEGIN(INITIAL);
    #####:  659:  return _REGEXP_;
        -:  660:}
        -:  661:
    #####:  662:
        -:  663:<regexp>\\\/  {
        -:  664:
    #####:  665:  lex_check_space_ok("/", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
    #####:  666:  *yyextra->lex_buf_ptr++ = '/';
    #####:  667:  yyextra->lex_buf_len++ ;
        -:  668:}
    #####:  669:
    #####:  670:
        -:  671:<regexp>\\. {
        -:  672:
    #####:  673:  lex_check_space_ok("\\.", yyextra->lex_buf_len, YR_LEX_BUF_SIZE);
        -:  674:
    #####:  675:  if (yytext[1] == 0)
    #####:  676:    syntax_error("malformed regular expression");
        -:  677:
    #####:  678:  *yyextra->lex_buf_ptr++ = yytext[0];
    #####:  679:  *yyextra->lex_buf_ptr++ = yytext[1];
    #####:  680:  yyextra->lex_buf_len += 2;
        -:  681:}
    #####:  682:
    #####:  683:
    #####:  684:<regexp>[^/\n\\]+ { yytext_to_buffer; }
    #####:  685:
    #####:  686:
        -:  687:<regexp>\n  {
    #####:  688:  syntax_error("unterminated regular expression");
        -:  689:}
        -:  690:
    #####:  691:
        -:  692:\"  {
        -:  693:
    #####:  694:  yylval->sized_string = NULL;
    #####:  695:  yyextra->lex_buf_ptr = yyextra->lex_buf;
    #####:  696:  yyextra->lex_buf_len = 0;
    #####:  697:  BEGIN(str);
        -:  698:}
    #####:  699:
    #####:  700:
        -:  701:"/"  {
        -:  702:
    #####:  703:  yylval->sized_string = NULL;
    #####:  704:  yyextra->lex_buf_ptr = yyextra->lex_buf;
    #####:  705:  yyextra->lex_buf_len = 0;
    #####:  706:  BEGIN(regexp);
        -:  707:}
    #####:  708:
    #####:  709:
        -:  710:\{(({hexdigit}|[ \-|\?\[\]\(\)\n\r\t]|\/\*[^*]*\*\/)+|\/\/.*)+\}  {
        -:  711:  // Match hex-digits with whitespace or comments. The latter are stripped
        -:  712:  // out by hex_lexer.l
        -:  713:
    #####:  714:  alloc_sized_string(s, strlen(yytext));
        -:  715:
    #####:  716:  strlcpy(s->c_string, yytext, s->length + 1);
    #####:  717:  yylval->sized_string = s;
        -:  718:
    #####:  719:  return _HEX_STRING_;
        -:  720:}
        -:  721:
       25:  722:
        -:  723:[ \t\r\n]   /* skip whitespace */
       25:  724:
        3:  725:.   {
        -:  726:
        3:  727:  if (yytext[0] >= 32 && yytext[0] < 127)
        -:  728:  {
        3:  729:    return yytext[0];
        -:  730:  }
        -:  731:  else
        -:  732:  {
    #####:  733:    syntax_error("non-ascii character");
        -:  734:  }
        -:  735:}
        -:  736:
    #####:  737:%%
    #####:  738:
        -:  739:
    #####:  740:void yywarning(
        -:  741:    yyscan_t yyscanner,
        -:  742:    const char *message_fmt,
        -:  743:    ...)
        -:  744:{
    #####:  745:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  746:
        -:  747:  char* file_name;
        -:  748:  char message[512];
        -:  749:  va_list message_args;
        -:  750:
    #####:  751:  if (compiler->callback == NULL)
    #####:  752:    return;
        -:  753:
    #####:  754:  va_start(message_args, message_fmt);
        -:  755:
    #####:  756:  if (compiler->file_name_stack_ptr > 0)
    #####:  757:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  758:  else
    #####:  759:    file_name = NULL;
        -:  760:
    #####:  761:  vsnprintf(message, sizeof(message), message_fmt, message_args);
        -:  762:
    #####:  763:  compiler->callback(
        -:  764:      YARA_ERROR_LEVEL_WARNING,
        -:  765:      file_name,
    #####:  766:      compiler->current_line ? compiler->current_line : yyget_lineno(yyscanner),
        -:  767:      message,
        -:  768:      compiler->user_data);
        -:  769:
    #####:  770:  va_end(message_args);
        -:  771:}
        -:  772:
        -:  773:
    #####:  774:void yyfatal(
        -:  775:    yyscan_t yyscanner,
        -:  776:    const char *error_message)
        -:  777:{
    #####:  778:  YR_COMPILER* compiler = yyget_extra(yyscanner);
        -:  779:
    #####:  780:  yyerror(yyscanner, compiler, error_message);
    #####:  781:  longjmp(compiler->error_recovery, 1);
        -:  782:}
        -:  783:
        -:  784:
    #####:  785:void yyerror(
        -:  786:    yyscan_t yyscanner,
        -:  787:    YR_COMPILER* compiler,
        -:  788:    const char *error_message)
        -:  789:{
    #####:  790:  char message[512] = {'\0'};
    #####:  791:  char* file_name = NULL;
        -:  792:
        -:  793:  /*
        -:  794:    if error_message != NULL the error comes from yyparse internal code
        -:  795:    else the error comes from my code and the error code is set in
        -:  796:    compiler->last_error
        -:  797:  */
        -:  798:
    #####:  799:  compiler->errors++;
        -:  800:
    #####:  801:  if (compiler->current_line != 0)
    #####:  802:    compiler->last_error_line = compiler->current_line;
        -:  803:  else
    #####:  804:    compiler->last_error_line = yyget_lineno(yyscanner);
        -:  805:
    #####:  806:  compiler->current_line = 0;
        -:  807:
    #####:  808:  if (compiler->file_name_stack_ptr > 0)
        -:  809:  {
    #####:  810:    file_name = compiler->file_name_stack[compiler->file_name_stack_ptr - 1];
        -:  811:  }
        -:  812:  else
        -:  813:  {
    #####:  814:    file_name = NULL;
        -:  815:  }
        -:  816:
    #####:  817:  if (error_message != NULL)
        -:  818:  {
    #####:  819:    yr_compiler_set_error_extra_info(compiler, error_message);
    #####:  820:    compiler->last_error = ERROR_SYNTAX_ERROR;
        -:  821:
    #####:  822:    if (compiler->callback != NULL)
        -:  823:    {
    #####:  824:      compiler->callback(
        -:  825:          YARA_ERROR_LEVEL_ERROR,
        -:  826:          file_name,
        -:  827:          compiler->last_error_line,
        -:  828:          error_message,
        -:  829:          compiler->user_data);
        -:  830:    }
        -:  831:  }
    #####:  832:  else if (compiler->callback != NULL)
        -:  833:  {
    #####:  834:    yr_compiler_get_error_message(compiler, message, sizeof(message));
        -:  835:
    #####:  836:    compiler->callback(
        -:  837:      YARA_ERROR_LEVEL_ERROR,
        -:  838:      file_name,
        -:  839:      compiler->last_error_line,
        -:  840:      message,
        -:  841:      compiler->user_data);
        -:  842:  }
    #####:  843:}
        -:  844:
        -:  845:
        1:  846:int yr_lex_parse_rules_string(
        -:  847:    const char* rules_string,
        -:  848:    YR_COMPILER* compiler)
        -:  849:{
        -:  850:  yyscan_t yyscanner;
        -:  851:
        1:  852:  compiler->errors = 0;
        -:  853:
        1:  854:  if (setjmp(compiler->error_recovery) != 0)
    #####:  855:    return compiler->errors;
        -:  856:
        1:  857:  yylex_init(&yyscanner);
        -:  858:
        -:  859:  #if YYDEBUG
        -:  860:  yydebug = 1;
        -:  861:  #endif
        -:  862:
        1:  863:  yyset_extra(compiler, yyscanner);
        1:  864:  yy_scan_string(rules_string, yyscanner);
        1:  865:  yyset_lineno(1, yyscanner);
        1:  866:  yyparse(yyscanner, compiler);
        1:  867:  yylex_destroy(yyscanner);
        -:  868:
        1:  869:  return compiler->errors;
        -:  870:}
        -:  871:
        -:  872:
    #####:  873:int yr_lex_parse_rules_file(
        -:  874:    FILE* rules_file,
        -:  875:    YR_COMPILER* compiler)
        -:  876:{
        -:  877:  yyscan_t yyscanner;
        -:  878:
    #####:  879:  compiler->errors = 0;
        -:  880:
    #####:  881:  if (setjmp(compiler->error_recovery) != 0)
    #####:  882:    return compiler->errors;
        -:  883:
    #####:  884:  yylex_init(&yyscanner);
        -:  885:
        -:  886:  #if YYDEBUG
        -:  887:  yydebug = 1;
        -:  888:  #endif
        -:  889:
    #####:  890:  yyset_in(rules_file, yyscanner);
    #####:  891:  yyset_extra(compiler, yyscanner);
    #####:  892:  yyparse(yyscanner, compiler);
    #####:  893:  yylex_destroy(yyscanner);
        -:  894:
    #####:  895:  return compiler->errors;
        -:  896:}
        -:  897:
        -:  898:
    #####:  899:int yr_lex_parse_rules_fd(
        -:  900:    YR_FILE_DESCRIPTOR rules_fd,
        -:  901:    YR_COMPILER* compiler)
        -:  902:{
        -:  903:  yyscan_t yyscanner;
        -:  904:  size_t file_size;
        -:  905:  void* buffer;
        -:  906:
    #####:  907:  compiler->errors = 0;
        -:  908:
    #####:  909:  if (setjmp(compiler->error_recovery) != 0)
    #####:  910:    return compiler->errors;
        -:  911:
        -:  912:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  913:  file_size = (size_t) GetFileSize(rules_fd, NULL);
        -:  914:  #else
        -:  915:  struct stat fs;
    #####:  916:  if (fstat(rules_fd, &fs) != 0)
        -:  917:  {
    #####:  918:    compiler->errors = 1;
    #####:  919:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
    #####:  920:    return compiler->errors;
        -:  921:  }
    #####:  922:  file_size = (size_t) fs.st_size;
        -:  923:  #endif
        -:  924:
    #####:  925:  buffer = yr_malloc(file_size);
        -:  926:
    #####:  927:  if (buffer == NULL)
        -:  928:  {
    #####:  929:    compiler->errors = 1;
    #####:  930:    compiler->last_error = ERROR_INSUFFICIENT_MEMORY;
    #####:  931:    return compiler->errors;
        -:  932:  }
        -:  933:
        -:  934:  #if defined(_WIN32) || defined(__CYGWIN__)
        -:  935:  if (!ReadFile(rules_fd, buffer, file_size, NULL, NULL))
        -:  936:  #else
    #####:  937:  if (read(rules_fd, buffer, file_size) != file_size)
        -:  938:  #endif
        -:  939:  {
    #####:  940:    yr_free(buffer);
    #####:  941:    compiler->errors = 1;
    #####:  942:    compiler->last_error = ERROR_COULD_NOT_READ_FILE;
    #####:  943:    return compiler->errors;
        -:  944:  }
        -:  945:
    #####:  946:  yylex_init(&yyscanner);
        -:  947:
        -:  948:  #if YYDEBUG
        -:  949:  yydebug = 1;
        -:  950:  #endif
        -:  951:
    #####:  952:  yyset_extra(compiler, yyscanner);
    #####:  953:  yy_scan_bytes((const char*) buffer, file_size, yyscanner);
    #####:  954:  yyparse(yyscanner, compiler);
    #####:  955:  yylex_destroy(yyscanner);
        -:  956:
    #####:  957:  yr_free(buffer);
        -:  958:
    #####:  959:  return compiler->errors;
        -:  960:}
