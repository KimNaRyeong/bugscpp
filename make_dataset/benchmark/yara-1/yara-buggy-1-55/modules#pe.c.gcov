        -:    0:Source:modules/pe.c
        -:    0:Graph:/home/workspace/libyara/modules/pe.gcno
        -:    0:Data:/home/workspace/libyara/modules/pe.gcda
        -:    0:Runs:6
        -:    1:/*
        -:    2:Copyright (c) 2014. The YARA Authors. All Rights Reserved.
        -:    3:
        -:    4:Redistribution and use in source and binary forms, with or without modification,
        -:    5:are permitted provided that the following conditions are met:
        -:    6:
        -:    7:1. Redistributions of source code must retain the above copyright notice, this
        -:    8:list of conditions and the following disclaimer.
        -:    9:
        -:   10:2. Redistributions in binary form must reproduce the above copyright notice,
        -:   11:this list of conditions and the following disclaimer in the documentation and/or
        -:   12:other materials provided with the distribution.
        -:   13:
        -:   14:3. Neither the name of the copyright holder nor the names of its contributors
        -:   15:may be used to endorse or promote products derived from this software without
        -:   16:specific prior written permission.
        -:   17:
        -:   18:THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   19:ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   20:WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
        -:   21:DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
        -:   22:ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
        -:   23:(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
        -:   24:LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
        -:   25:ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
        -:   26:(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
        -:   27:SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
        -:   28:*/
        -:   29:
        -:   30:#define _GNU_SOURCE
        -:   31:
        -:   32:#include <stdbool.h>
        -:   33:#include <stdio.h>
        -:   34:#include <ctype.h>
        -:   35:#include <time.h>
        -:   36:
        -:   37:#include "../crypto.h"
        -:   38:#if defined(HAVE_LIBCRYPTO)
        -:   39:#include <openssl/safestack.h>
        -:   40:#include <openssl/asn1.h>
        -:   41:#include <openssl/bio.h>
        -:   42:#include <openssl/pkcs7.h>
        -:   43:#include <openssl/x509.h>
        -:   44:#if OPENSSL_VERSION_NUMBER < 0x10100000L || defined(LIBRESSL_VERSION_NUMBER)
        -:   45:#define X509_get_signature_nid(o) OBJ_obj2nid((o)->sig_alg->algorithm)
        -:   46:#endif
        -:   47:#endif
        -:   48:
        -:   49:#include <yara/endian.h>
        -:   50:#include <yara/pe.h>
        -:   51:#include <yara/modules.h>
        -:   52:#include <yara/mem.h>
        -:   53:#include <yara/strutils.h>
        -:   54:
        -:   55:#include <yara/pe_utils.h>
        -:   56:
        -:   57:#define MODULE_NAME pe
        -:   58:
        -:   59:// http://msdn.microsoft.com/en-us/library/ms648009(v=vs.85).aspx
        -:   60:#define RESOURCE_TYPE_CURSOR       1
        -:   61:#define RESOURCE_TYPE_BITMAP       2
        -:   62:#define RESOURCE_TYPE_ICON         3
        -:   63:#define RESOURCE_TYPE_MENU         4
        -:   64:#define RESOURCE_TYPE_DIALOG       5
        -:   65:#define RESOURCE_TYPE_STRING       6
        -:   66:#define RESOURCE_TYPE_FONTDIR      7
        -:   67:#define RESOURCE_TYPE_FONT         8
        -:   68:#define RESOURCE_TYPE_ACCELERATOR  9
        -:   69:#define RESOURCE_TYPE_RCDATA       10
        -:   70:#define RESOURCE_TYPE_MESSAGETABLE 11
        -:   71:#define RESOURCE_TYPE_GROUP_CURSOR 12 // MAKEINTRESOURCE((ULONG_PTR)(RT_CURSOR) + 11)
        -:   72:#define RESOURCE_TYPE_GROUP_ICON   14 // MAKEINTRESOURCE((ULONG_PTR)(RT_ICON) + 11)
        -:   73:#define RESOURCE_TYPE_VERSION      16
        -:   74:#define RESOURCE_TYPE_DLGINCLUDE   17
        -:   75:#define RESOURCE_TYPE_PLUGPLAY     19
        -:   76:#define RESOURCE_TYPE_VXD          20
        -:   77:#define RESOURCE_TYPE_ANICURSOR    21
        -:   78:#define RESOURCE_TYPE_ANIICON      22
        -:   79:#define RESOURCE_TYPE_HTML         23
        -:   80:#define RESOURCE_TYPE_MANIFEST     24
        -:   81:
        -:   82:
        -:   83:#define RESOURCE_CALLBACK_CONTINUE   0
        -:   84:#define RESOURCE_CALLBACK_ABORT      1
        -:   85:
        -:   86:
        -:   87:#define RESOURCE_ITERATOR_FINISHED   0
        -:   88:#define RESOURCE_ITERATOR_ABORTED    1
        -:   89:
        -:   90:
        -:   91:#define MAX_PE_IMPORTS               16384
        -:   92:#define MAX_PE_EXPORTS               65535
        -:   93:
        -:   94:
        -:   95:#define IS_RESOURCE_SUBDIRECTORY(entry) \
        -:   96:    ((entry)->OffsetToData & 0x80000000)
        -:   97:
        -:   98:
        -:   99:#define RESOURCE_OFFSET(entry) \
        -:  100:    ((entry)->OffsetToData & 0x7FFFFFFF)
        -:  101:
        -:  102:
        -:  103:typedef int (*RESOURCE_CALLBACK_FUNC) ( \
        -:  104:     PIMAGE_RESOURCE_DATA_ENTRY rsrc_data, \
        -:  105:     int rsrc_type, \
        -:  106:     int rsrc_id, \
        -:  107:     int rsrc_language, \
        -:  108:     const uint8_t* type_string, \
        -:  109:     const uint8_t* name_string, \
        -:  110:     const uint8_t* lang_string, \
        -:  111:     void* cb_data);
        -:  112:
        -:  113:
    #####:  114:static size_t available_space(
        -:  115:    PE* pe,
        -:  116:    void* pointer)
        -:  117:{
    #####:  118:  if ((uint8_t*) pointer < pe->data)
    #####:  119:    return 0;
        -:  120:
    #####:  121:  if ((uint8_t*) pointer >= pe->data + pe->data_size)
    #####:  122:    return 0;
        -:  123:
    #####:  124:  return pe->data + pe->data_size - (uint8_t*) pointer;
        -:  125:}
        -:  126:
        -:  127:
    #####:  128:int wide_string_fits_in_pe(
        -:  129:    PE* pe,
        -:  130:    char* data)
        -:  131:{
    #####:  132:  size_t i = 0;
    #####:  133:  size_t space_left = available_space(pe, data);
        -:  134:
    #####:  135:  while (space_left >= 2)
        -:  136:  {
    #####:  137:    if (data[i] == 0 && data[i + 1] == 0)
    #####:  138:      return 1;
    #####:  139:    space_left -= 2;
    #####:  140:    i += 2;
        -:  141:  }
        -:  142:
    #####:  143:  return 0;
        -:  144:}
        -:  145:
        -:  146:
        -:  147:// Parse the rich signature.
        -:  148:// http://www.ntcore.com/files/richsign.htm
        -:  149:
    #####:  150:void pe_parse_rich_signature(
        -:  151:    PE* pe,
        -:  152:    uint64_t base_address)
        -:  153:{
        -:  154:  PIMAGE_DOS_HEADER mz_header;
        -:  155:  PIMAGE_NT_HEADERS32 pe_header;
        -:  156:  PRICH_SIGNATURE rich_signature;
        -:  157:  DWORD* rich_ptr;
        -:  158:
    #####:  159:  BYTE* raw_data = NULL;
    #####:  160:  BYTE* clear_data = NULL;
    #####:  161:  size_t headers_size = 0;
    #####:  162:  size_t rich_len = 0;
        -:  163:
    #####:  164:  if (pe->data_size < sizeof(IMAGE_DOS_HEADER))
    #####:  165:    return;
        -:  166:
    #####:  167:  mz_header = (PIMAGE_DOS_HEADER) pe->data;
        -:  168:
    #####:  169:  if (yr_le16toh(mz_header->e_magic) != IMAGE_DOS_SIGNATURE)
    #####:  170:    return;
        -:  171:
    #####:  172:  if (yr_le32toh(mz_header->e_lfanew) < 0)
    #####:  173:    return;
        -:  174:
    #####:  175:  headers_size = yr_le32toh(mz_header->e_lfanew) + \
        -:  176:                 sizeof(pe_header->Signature) + \
        -:  177:                 sizeof(IMAGE_FILE_HEADER);
        -:  178:
    #####:  179:  if (pe->data_size < headers_size)
    #####:  180:    return;
        -:  181:
        -:  182:  // From offset 0x80 until the start of the PE header should be the Rich
        -:  183:  // signature. The three key values must all be equal and the first dword
        -:  184:  // XORs to "DanS". Then walk the buffer looking for "Rich" which marks the
        -:  185:  // end. Technically the XOR key should be right after "Rich" but it's not
        -:  186:  // important.
        -:  187:
    #####:  188:  rich_signature = (PRICH_SIGNATURE) (pe->data + 0x80);
        -:  189:
    #####:  190:  if (yr_le32toh(rich_signature->key1) != yr_le32toh(rich_signature->key2) ||
    #####:  191:      yr_le32toh(rich_signature->key2) != yr_le32toh(rich_signature->key3) ||
    #####:  192:      (yr_le32toh(rich_signature->dans) ^ yr_le32toh(rich_signature->key1)) != RICH_DANS)
        -:  193:  {
    #####:  194:    return;
        -:  195:  }
        -:  196:
    #####:  197:  for (rich_ptr = (DWORD*) rich_signature;
    #####:  198:       rich_ptr <= (DWORD*) (pe->data + headers_size);
    #####:  199:       rich_ptr++)
        -:  200:  {
    #####:  201:    if (yr_le32toh(*rich_ptr) == RICH_RICH)
        -:  202:    {
        -:  203:      // Multiple by 4 because we are counting in DWORDs.
    #####:  204:      rich_len = (rich_ptr - (DWORD*) rich_signature) * 4;
    #####:  205:      raw_data = (BYTE*) yr_malloc(rich_len);
        -:  206:
    #####:  207:      if (!raw_data)
    #####:  208:        return;
        -:  209:
    #####:  210:      memcpy(raw_data, rich_signature, rich_len);
        -:  211:
    #####:  212:      set_integer(
        -:  213:          base_address + 0x80, pe->object, "rich_signature.offset");
        -:  214:
    #####:  215:      set_integer(
        -:  216:          rich_len, pe->object, "rich_signature.length");
        -:  217:
    #####:  218:      set_integer(
        -:  219:          rich_signature->key1, pe->object, "rich_signature.key");
        -:  220:
    #####:  221:      break;
        -:  222:    }
        -:  223:  }
        -:  224:
        -:  225:  // Walk the entire block and apply the XOR key.
    #####:  226:  if (raw_data)
        -:  227:  {
    #####:  228:    clear_data = (BYTE*) yr_malloc(rich_len);
        -:  229:
    #####:  230:    if (!clear_data)
        -:  231:    {
    #####:  232:      yr_free(raw_data);
    #####:  233:      return;
        -:  234:    }
        -:  235:
        -:  236:    // Copy the entire block here to be XORed.
    #####:  237:    memcpy(clear_data, raw_data, rich_len);
        -:  238:
    #####:  239:    for (rich_ptr = (DWORD*) clear_data;
    #####:  240:         rich_ptr < (DWORD*) (clear_data + rich_len);
    #####:  241:         rich_ptr++)
        -:  242:    {
    #####:  243:      *rich_ptr ^= rich_signature->key1;
        -:  244:    }
        -:  245:
    #####:  246:    set_sized_string(
        -:  247:        (char*) raw_data, rich_len, pe->object, "rich_signature.raw_data");
        -:  248:
    #####:  249:    set_sized_string(
        -:  250:        (char*) clear_data, rich_len, pe->object, "rich_signature.clear_data");
        -:  251:
    #####:  252:    yr_free(raw_data);
    #####:  253:    yr_free(clear_data);
    #####:  254:    return;
        -:  255:  }
        -:  256:
    #####:  257:  return;
        -:  258:}
        -:  259:
        -:  260:
        -:  261:// Return a pointer to the resource directory string or NULL.
        -:  262:// The callback function will parse this and call set_sized_string().
        -:  263:// The pointer is guaranteed to have enough space to contain the entire string.
        -:  264:
    #####:  265:const uint8_t* parse_resource_name(
        -:  266:    PE* pe,
        -:  267:    const uint8_t* rsrc_data,
        -:  268:    PIMAGE_RESOURCE_DIRECTORY_ENTRY entry)
        -:  269:{
        -:  270:
        -:  271:  // If high bit is set it is an offset relative to rsrc_data, which contains
        -:  272:  // a resource directory string.
        -:  273:
    #####:  274:  if (yr_le32toh(entry->Name) & 0x80000000)
        -:  275:  {
        -:  276:    DWORD length;
        -:  277:
    #####:  278:    const uint8_t* rsrc_str_ptr = rsrc_data + \
    #####:  279:        (yr_le32toh(entry->Name) & 0x7FFFFFFF);
        -:  280:
        -:  281:    // A resource directory string is 2 bytes for a string and then a variable
        -:  282:    // length Unicode string. Make sure we at least have two bytes.
        -:  283:
    #####:  284:    if (!fits_in_pe(pe, rsrc_str_ptr, 2))
    #####:  285:      return NULL;
        -:  286:
    #####:  287:    length = *rsrc_str_ptr;
        -:  288:
        -:  289:    // Move past the length and make sure we have enough bytes for the string.
    #####:  290:    if (!fits_in_pe(pe, rsrc_str_ptr + 2, length * 2))
    #####:  291:      return NULL;
        -:  292:
    #####:  293:    return rsrc_str_ptr;
        -:  294:  }
        -:  295:
    #####:  296:  return NULL;
        -:  297:}
        -:  298:
        -:  299:
    #####:  300:int _pe_iterate_resources(
        -:  301:    PE* pe,
        -:  302:    PIMAGE_RESOURCE_DIRECTORY resource_dir,
        -:  303:    const uint8_t* rsrc_data,
        -:  304:    int rsrc_tree_level,
        -:  305:    int* type,
        -:  306:    int* id,
        -:  307:    int* language,
        -:  308:    const uint8_t* type_string,
        -:  309:    const uint8_t* name_string,
        -:  310:    const uint8_t* lang_string,
        -:  311:    RESOURCE_CALLBACK_FUNC callback,
        -:  312:    void* callback_data)
        -:  313:{
    #####:  314:  int i, result = RESOURCE_ITERATOR_FINISHED;
        -:  315:  int total_entries;
        -:  316:
        -:  317:  PIMAGE_RESOURCE_DIRECTORY_ENTRY entry;
        -:  318:
        -:  319:  // A few sanity checks to avoid corrupt files
        -:  320:
    #####:  321:  if (yr_le32toh(resource_dir->Characteristics) != 0 ||
    #####:  322:      yr_le16toh(resource_dir->NumberOfNamedEntries) > 32768 ||
    #####:  323:      yr_le16toh(resource_dir->NumberOfIdEntries) > 32768)
        -:  324:  {
    #####:  325:    return result;
        -:  326:  }
        -:  327:
    #####:  328:  total_entries = yr_le16toh(resource_dir->NumberOfNamedEntries) +
    #####:  329:                  yr_le16toh(resource_dir->NumberOfIdEntries);
        -:  330:
        -:  331:  // The first directory entry is just after the resource directory,
        -:  332:  // by incrementing resource_dir we skip sizeof(resource_dir) bytes
        -:  333:  // and get a pointer to the end of the resource directory.
        -:  334:
    #####:  335:  entry = (PIMAGE_RESOURCE_DIRECTORY_ENTRY) (resource_dir + 1);
        -:  336:
    #####:  337:  for (i = 0; i < total_entries; i++)
        -:  338:  {
    #####:  339:    if (!struct_fits_in_pe(pe, entry, IMAGE_RESOURCE_DIRECTORY_ENTRY))
        -:  340:    {
    #####:  341:      result = RESOURCE_ITERATOR_ABORTED;
    #####:  342:      break;
        -:  343:    }
        -:  344:
    #####:  345:    switch(rsrc_tree_level)
        -:  346:    {
    #####:  347:      case 0:
    #####:  348:        *type = yr_le32toh(entry->Name);
    #####:  349:        type_string = parse_resource_name(pe, rsrc_data, entry);
    #####:  350:        break;
    #####:  351:      case 1:
    #####:  352:        *id = yr_le32toh(entry->Name);
    #####:  353:        name_string = parse_resource_name(pe, rsrc_data, entry);
    #####:  354:        break;
    #####:  355:      case 2:
    #####:  356:        *language = yr_le32toh(entry->Name);
    #####:  357:        lang_string = parse_resource_name(pe, rsrc_data, entry);
    #####:  358:        break;
        -:  359:    }
        -:  360:
    #####:  361:    if (IS_RESOURCE_SUBDIRECTORY(entry) && rsrc_tree_level < 2)
    #####:  362:    {
    #####:  363:      PIMAGE_RESOURCE_DIRECTORY directory = (PIMAGE_RESOURCE_DIRECTORY) \
    #####:  364:          (rsrc_data + RESOURCE_OFFSET(entry));
        -:  365:
    #####:  366:      if (struct_fits_in_pe(pe, directory, IMAGE_RESOURCE_DIRECTORY))
        -:  367:      {
    #####:  368:        result = _pe_iterate_resources(
        -:  369:            pe,
        -:  370:            directory,
        -:  371:            rsrc_data,
        -:  372:            rsrc_tree_level + 1,
        -:  373:            type,
        -:  374:            id,
        -:  375:            language,
        -:  376:            type_string,
        -:  377:            name_string,
        -:  378:            lang_string,
        -:  379:            callback,
        -:  380:            callback_data);
        -:  381:      }
        -:  382:      else
        -:  383:      {
    #####:  384:        result = RESOURCE_ITERATOR_ABORTED;
        -:  385:      }
        -:  386:    }
        -:  387:    else
        -:  388:    {
    #####:  389:      PIMAGE_RESOURCE_DATA_ENTRY data_entry = (PIMAGE_RESOURCE_DATA_ENTRY) \
    #####:  390:          (rsrc_data + RESOURCE_OFFSET(entry));
        -:  391:
    #####:  392:      if (struct_fits_in_pe(pe, data_entry, IMAGE_RESOURCE_DATA_ENTRY))
        -:  393:      {
    #####:  394:        if (callback(
        -:  395:            data_entry,
        -:  396:            *type,
        -:  397:            *id,
        -:  398:            *language,
        -:  399:            type_string,
        -:  400:            name_string,
        -:  401:            lang_string,
        -:  402:            callback_data) == RESOURCE_CALLBACK_ABORT)
        -:  403:        {
    #####:  404:          result = RESOURCE_ITERATOR_ABORTED;
        -:  405:        }
        -:  406:      }
        -:  407:      else
        -:  408:      {
    #####:  409:        result = RESOURCE_ITERATOR_ABORTED;
        -:  410:      }
        -:  411:    }
        -:  412:
    #####:  413:    if (result == RESOURCE_ITERATOR_ABORTED)
    #####:  414:      break;
        -:  415:
    #####:  416:    entry++;
        -:  417:  }
        -:  418:
    #####:  419:  return result;
        -:  420:}
        -:  421:
        -:  422:
    #####:  423:int pe_iterate_resources(
        -:  424:    PE* pe,
        -:  425:    RESOURCE_CALLBACK_FUNC callback,
        -:  426:    void* callback_data)
        -:  427:{
        -:  428:  int64_t offset;
        -:  429:
    #####:  430:  int type = -1;
    #####:  431:  int id = -1;
    #####:  432:  int language = -1;
        -:  433:
    #####:  434:  uint8_t* type_string = NULL;
    #####:  435:  uint8_t* name_string = NULL;
    #####:  436:  uint8_t* lang_string = NULL;
        -:  437:
    #####:  438:  PIMAGE_DATA_DIRECTORY directory = pe_get_directory_entry(
        -:  439:      pe, IMAGE_DIRECTORY_ENTRY_RESOURCE);
        -:  440:
    #####:  441:  if (directory == NULL)
    #####:  442:     return 0;
        -:  443:
    #####:  444:  if (yr_le32toh(directory->VirtualAddress) != 0)
        -:  445:  {
        -:  446:    PIMAGE_RESOURCE_DIRECTORY rsrc_dir;
        -:  447:
    #####:  448:    offset = pe_rva_to_offset(pe, yr_le32toh(directory->VirtualAddress));
        -:  449:
    #####:  450:    if (offset < 0)
    #####:  451:      return 0;
        -:  452:
    #####:  453:    rsrc_dir = (PIMAGE_RESOURCE_DIRECTORY) (pe->data + offset);
        -:  454:
    #####:  455:    if (struct_fits_in_pe(pe, rsrc_dir, IMAGE_RESOURCE_DIRECTORY))
        -:  456:    {
    #####:  457:      set_integer(yr_le32toh(rsrc_dir->TimeDateStamp),
        -:  458:          pe->object,
        -:  459:          "resource_timestamp");
        -:  460:
    #####:  461:      set_integer(yr_le16toh(rsrc_dir->MajorVersion),
        -:  462:                  pe->object,
        -:  463:                  "resource_version.major");
    #####:  464:      set_integer(yr_le16toh(rsrc_dir->MinorVersion),
        -:  465:                  pe->object,
        -:  466:                  "resource_version.minor");
        -:  467:
    #####:  468:      _pe_iterate_resources(
        -:  469:          pe,
        -:  470:          rsrc_dir,
    #####:  471:          pe->data + offset,
        -:  472:          0,
        -:  473:          &type,
        -:  474:          &id,
        -:  475:          &language,
        -:  476:          type_string,
        -:  477:          name_string,
        -:  478:          lang_string,
        -:  479:          callback,
        -:  480:          callback_data);
        -:  481:
    #####:  482:      return 1;
        -:  483:    }
        -:  484:  }
        -:  485:
    #####:  486:  return 0;
        -:  487:}
        -:  488:
        -:  489:
        -:  490:// Align offset to a 32-bit boundary and add it to a pointer
        -:  491:
        -:  492:#define ADD_OFFSET(ptr, offset) \
        -:  493:    (PVERSION_INFO) ((uint8_t*) (ptr) + ((offset + 3) & ~3))
        -:  494:
        -:  495:
    #####:  496:void pe_parse_version_info(
        -:  497:    PIMAGE_RESOURCE_DATA_ENTRY rsrc_data,
        -:  498:    PE* pe)
        -:  499:{
        -:  500:  PVERSION_INFO version_info;
        -:  501:
    #####:  502:  int64_t version_info_offset = pe_rva_to_offset(
    #####:  503:      pe, yr_le32toh(rsrc_data->OffsetToData));
        -:  504:
    #####:  505:  if (version_info_offset < 0)
    #####:  506:    return;
        -:  507:
    #####:  508:  version_info = (PVERSION_INFO) (pe->data + version_info_offset);
        -:  509:
    #####:  510:  if (!struct_fits_in_pe(pe, version_info, VERSION_INFO))
    #####:  511:    return;
        -:  512:
    #####:  513:  if (!fits_in_pe(pe, version_info->Key, sizeof("VS_VERSION_INFO") * 2))
    #####:  514:    return;
        -:  515:
    #####:  516:  if (strcmp_w(version_info->Key, "VS_VERSION_INFO") != 0)
    #####:  517:    return;
        -:  518:
    #####:  519:  version_info = ADD_OFFSET(
        -:  520:      version_info, sizeof(VERSION_INFO) + 86);
        -:  521:
    #####:  522:  while(fits_in_pe(pe, version_info->Key, sizeof("VarFileInfo") * 2) &&
    #####:  523:        strcmp_w(version_info->Key, "VarFileInfo") == 0 &&
    #####:  524:        yr_le16toh(version_info->Length) != 0)
        -:  525:  {
    #####:  526:    version_info = ADD_OFFSET(
        -:  527:        version_info,
        -:  528:        yr_le16toh(version_info->Length));
        -:  529:  }
        -:  530:
    #####:  531:  while(fits_in_pe(pe, version_info->Key, sizeof("StringFileInfo") * 2) &&
    #####:  532:        strcmp_w(version_info->Key, "StringFileInfo") == 0 &&
    #####:  533:        yr_le16toh(version_info->Length) != 0)
        -:  534:  {
    #####:  535:    PVERSION_INFO string_table = ADD_OFFSET(
        -:  536:        version_info,
        -:  537:        sizeof(VERSION_INFO) + 30);
        -:  538:
    #####:  539:    version_info = ADD_OFFSET(
        -:  540:        version_info,
        -:  541:        yr_le16toh(version_info->Length));
        -:  542:
    #####:  543:    while (struct_fits_in_pe(pe, string_table, VERSION_INFO) &&
    #####:  544:           wide_string_fits_in_pe(pe, string_table->Key) &&
    #####:  545:           yr_le16toh(string_table->Length) != 0 &&
        -:  546:           string_table < version_info)
        -:  547:    {
    #####:  548:      PVERSION_INFO string = ADD_OFFSET(
        -:  549:          string_table,
        -:  550:          sizeof(VERSION_INFO) + 2 * (strnlen_w(string_table->Key) + 1));
        -:  551:
    #####:  552:      string_table = ADD_OFFSET(
        -:  553:          string_table,
        -:  554:          yr_le16toh(string_table->Length));
        -:  555:
    #####:  556:      while (struct_fits_in_pe(pe, string, VERSION_INFO) &&
    #####:  557:             wide_string_fits_in_pe(pe, string->Key) &&
    #####:  558:             yr_le16toh(string->Length) != 0 &&
        -:  559:             string < string_table)
        -:  560:      {
    #####:  561:        if (yr_le16toh(string->ValueLength) > 0)
        -:  562:        {
    #####:  563:          char* string_value = (char*) ADD_OFFSET(string,
        -:  564:              sizeof(VERSION_INFO) + 2 * (strnlen_w(string->Key) + 1));
        -:  565:
    #####:  566:          if (wide_string_fits_in_pe(pe, string_value))
        -:  567:          {
        -:  568:            char key[64];
        -:  569:            char value[256];
        -:  570:
    #####:  571:            strlcpy_w(key, string->Key, sizeof(key));
    #####:  572:            strlcpy_w(value, string_value, sizeof(value));
        -:  573:
    #####:  574:            set_string(value, pe->object, "version_info[%s]", key);
        -:  575:          }
        -:  576:        }
        -:  577:
    #####:  578:        string = ADD_OFFSET(string, yr_le16toh(string->Length));
        -:  579:      }
        -:  580:    }
        -:  581:  }
        -:  582:}
        -:  583:
        -:  584:
    #####:  585:int pe_collect_resources(
        -:  586:    PIMAGE_RESOURCE_DATA_ENTRY rsrc_data,
        -:  587:    int rsrc_type,
        -:  588:    int rsrc_id,
        -:  589:    int rsrc_language,
        -:  590:    uint8_t* type_string,
        -:  591:    uint8_t* name_string,
        -:  592:    uint8_t* lang_string,
        -:  593:    PE* pe)
        -:  594:{
        -:  595:  DWORD length;
        -:  596:
    #####:  597:  int64_t offset = pe_rva_to_offset(pe, yr_le32toh(rsrc_data->OffsetToData));
        -:  598:
    #####:  599:  if (offset < 0)
    #####:  600:    return RESOURCE_CALLBACK_CONTINUE;
        -:  601:
    #####:  602:  if (!fits_in_pe(pe, pe->data + offset, yr_le32toh(rsrc_data->Size)))
    #####:  603:    return RESOURCE_CALLBACK_CONTINUE;
        -:  604:
    #####:  605:  set_integer(
        -:  606:        offset,
        -:  607:        pe->object,
        -:  608:        "resources[%i].offset",
        -:  609:        pe->resources);
        -:  610:
    #####:  611:  set_integer(
        -:  612:        yr_le32toh(rsrc_data->Size),
        -:  613:        pe->object,
        -:  614:        "resources[%i].length",
        -:  615:        pe->resources);
        -:  616:
    #####:  617:  if (type_string)
        -:  618:  {
        -:  619:    // Multiply by 2 because it is a Unicode string.
    #####:  620:    length = ((DWORD) *type_string) * 2;
    #####:  621:    type_string += 2;
        -:  622:
    #####:  623:    set_sized_string(
        -:  624:        (char*) type_string, length, pe->object,
        -:  625:        "resources[%i].type_string", pe->resources);
        -:  626:  }
        -:  627:  else
        -:  628:  {
    #####:  629:    set_integer(
        -:  630:          rsrc_type,
        -:  631:          pe->object,
        -:  632:          "resources[%i].type",
        -:  633:          pe->resources);
        -:  634:  }
        -:  635:
    #####:  636:  if (name_string)
        -:  637:  {
        -:  638:    // Multiply by 2 because it is a Unicode string.
    #####:  639:    length = ((DWORD) *name_string) * 2;
    #####:  640:    name_string += 2;
    #####:  641:    set_sized_string(
        -:  642:        (char*) name_string, length, pe->object,
        -:  643:        "resources[%i].name_string", pe->resources);
        -:  644:  }
        -:  645:  else
        -:  646:  {
    #####:  647:    set_integer(
        -:  648:        rsrc_id,
        -:  649:        pe->object,
        -:  650:        "resources[%i].id",
        -:  651:        pe->resources);
        -:  652:  }
        -:  653:
    #####:  654:  if (lang_string)
        -:  655:  {
        -:  656:    // Multiply by 2 because it is a Unicode string.
    #####:  657:    length = ((DWORD) *lang_string) * 2;
    #####:  658:    lang_string += 2;
    #####:  659:    set_sized_string(
        -:  660:        (char*) lang_string, length, pe->object,
        -:  661:        "resources[%i].language_string", pe->resources);
        -:  662:  }
        -:  663:  else
        -:  664:  {
    #####:  665:    set_integer(
        -:  666:        rsrc_language,
        -:  667:        pe->object,
        -:  668:        "resources[%i].language",
        -:  669:        pe->resources);
        -:  670:  }
        -:  671:
        -:  672:  // Resources we do extra parsing on
    #####:  673:  if (rsrc_type == RESOURCE_TYPE_VERSION)
    #####:  674:    pe_parse_version_info(rsrc_data, pe);
        -:  675:
    #####:  676:  pe->resources += 1;
    #####:  677:  return RESOURCE_CALLBACK_CONTINUE;
        -:  678:}
        -:  679:
        -:  680:
    #####:  681:IMPORT_FUNCTION* pe_parse_import_descriptor(
        -:  682:    PE* pe,
        -:  683:    PIMAGE_IMPORT_DESCRIPTOR import_descriptor,
        -:  684:    char* dll_name,
        -:  685:    int* num_function_imports)
        -:  686:{
    #####:  687:  IMPORT_FUNCTION* head = NULL;
    #####:  688:  IMPORT_FUNCTION* tail = NULL;
        -:  689:
    #####:  690:  int64_t offset = pe_rva_to_offset(
    #####:  691:      pe, yr_le32toh(import_descriptor->OriginalFirstThunk));
        -:  692:
        -:  693:  // I've seen binaries where OriginalFirstThunk is zero. In this case
        -:  694:  // use FirstThunk.
        -:  695:
    #####:  696:  if (offset <= 0)
    #####:  697:    offset = pe_rva_to_offset(pe, yr_le32toh(import_descriptor->FirstThunk));
        -:  698:
    #####:  699:  if (offset < 0)
    #####:  700:    return NULL;
        -:  701:
    #####:  702:  if (IS_64BITS_PE(pe))
        -:  703:  {
    #####:  704:    PIMAGE_THUNK_DATA64 thunks64 = (PIMAGE_THUNK_DATA64)(pe->data + offset);
        -:  705:
    #####:  706:    while (struct_fits_in_pe(pe, thunks64, IMAGE_THUNK_DATA64) &&
    #####:  707:           yr_le64toh(thunks64->u1.Ordinal) != 0 &&
    #####:  708:           *num_function_imports < MAX_PE_IMPORTS)
        -:  709:    {
    #####:  710:      char* name = NULL;
    #####:  711:      uint16_t ordinal = 0;
    #####:  712:      uint8_t has_ordinal = 0;
        -:  713:
    #####:  714:      if (!(yr_le64toh(thunks64->u1.Ordinal) & IMAGE_ORDINAL_FLAG64))
        -:  715:      {
        -:  716:        // If imported by name
    #####:  717:        offset = pe_rva_to_offset(pe, yr_le64toh(thunks64->u1.Function));
        -:  718:
    #####:  719:        if (offset >= 0)
        -:  720:        {
    #####:  721:          PIMAGE_IMPORT_BY_NAME import = (PIMAGE_IMPORT_BY_NAME) \
    #####:  722:              (pe->data + offset);
        -:  723:
    #####:  724:          if (struct_fits_in_pe(pe, import, IMAGE_IMPORT_BY_NAME))
        -:  725:          {
    #####:  726:            name = (char *) yr_strndup(
    #####:  727:                (char*) import->Name,
    #####:  728:                yr_min(available_space(pe, import->Name), 512));
        -:  729:          }
        -:  730:        }
        -:  731:      }
        -:  732:      else
        -:  733:      {
        -:  734:        // If imported by ordinal. Lookup the ordinal.
    #####:  735:        name = ord_lookup(dll_name, yr_le64toh(thunks64->u1.Ordinal) & 0xFFFF);
        -:  736:        // Also store the ordinal.
    #####:  737:        ordinal = yr_le64toh(thunks64->u1.Ordinal) & 0xFFFF;
    #####:  738:        has_ordinal = 1;
        -:  739:      }
        -:  740:
    #####:  741:      if (name != NULL || has_ordinal == 1)
        -:  742:      {
        -:  743:        IMPORT_FUNCTION* imported_func = (IMPORT_FUNCTION*)
    #####:  744:            yr_calloc(1, sizeof(IMPORT_FUNCTION));
        -:  745:
    #####:  746:        if (imported_func == NULL)
        -:  747:        {
    #####:  748:          yr_free(name);
    #####:  749:          continue;
        -:  750:        }
        -:  751:
    #####:  752:        imported_func->name = name;
    #####:  753:        imported_func->ordinal = ordinal;
    #####:  754:        imported_func->has_ordinal = has_ordinal;
    #####:  755:        imported_func->next = NULL;
        -:  756:
    #####:  757:        if (head == NULL)
    #####:  758:          head = imported_func;
        -:  759:
    #####:  760:        if (tail != NULL)
    #####:  761:          tail->next = imported_func;
        -:  762:
    #####:  763:        tail = imported_func;
        -:  764:      }
        -:  765:
    #####:  766:      (*num_function_imports)++;
    #####:  767:      thunks64++;
        -:  768:    }
        -:  769:  }
        -:  770:  else
        -:  771:  {
    #####:  772:    PIMAGE_THUNK_DATA32 thunks32 = (PIMAGE_THUNK_DATA32)(pe->data + offset);
        -:  773:
    #####:  774:    while (struct_fits_in_pe(pe, thunks32, IMAGE_THUNK_DATA32) &&
    #####:  775:           yr_le32toh(thunks32->u1.Ordinal) != 0 && *num_function_imports < MAX_PE_IMPORTS)
        -:  776:    {
    #####:  777:      char* name = NULL;
    #####:  778:      uint16_t ordinal = 0;
    #####:  779:      uint8_t has_ordinal = 0;
        -:  780:
    #####:  781:      if (!(yr_le32toh(thunks32->u1.Ordinal) & IMAGE_ORDINAL_FLAG32))
        -:  782:      {
        -:  783:        // If imported by name
    #####:  784:        offset = pe_rva_to_offset(pe, yr_le32toh(thunks32->u1.Function));
        -:  785:
    #####:  786:        if (offset >= 0)
        -:  787:        {
    #####:  788:          PIMAGE_IMPORT_BY_NAME import = (PIMAGE_IMPORT_BY_NAME) \
    #####:  789:              (pe->data + offset);
        -:  790:
    #####:  791:          if (struct_fits_in_pe(pe, import, IMAGE_IMPORT_BY_NAME))
        -:  792:          {
    #####:  793:            name = (char *) yr_strndup(
    #####:  794:                (char*) import->Name,
    #####:  795:                yr_min(available_space(pe, import->Name), 512));
        -:  796:          }
        -:  797:        }
        -:  798:      }
        -:  799:      else
        -:  800:      {
        -:  801:        // If imported by ordinal. Lookup the ordinal.
    #####:  802:        name = ord_lookup(dll_name, yr_le32toh(thunks32->u1.Ordinal) & 0xFFFF);
        -:  803:        // Also store the ordinal.
    #####:  804:        ordinal = yr_le32toh(thunks32->u1.Ordinal) & 0xFFFF;
    #####:  805:        has_ordinal = 1;
        -:  806:      }
        -:  807:
    #####:  808:      if (name != NULL || has_ordinal == 1)
        -:  809:      {
        -:  810:        IMPORT_FUNCTION* imported_func = (IMPORT_FUNCTION*)
    #####:  811:            yr_calloc(1, sizeof(IMPORT_FUNCTION));
        -:  812:
    #####:  813:        if (imported_func == NULL)
        -:  814:        {
    #####:  815:          yr_free(name);
    #####:  816:          continue;
        -:  817:        }
        -:  818:
    #####:  819:        imported_func->name = name;
    #####:  820:        imported_func->ordinal = ordinal;
    #####:  821:        imported_func->has_ordinal = has_ordinal;
    #####:  822:        imported_func->next = NULL;
        -:  823:
    #####:  824:        if (head == NULL)
    #####:  825:          head = imported_func;
        -:  826:
    #####:  827:        if (tail != NULL)
    #####:  828:          tail->next = imported_func;
        -:  829:
    #####:  830:        tail = imported_func;
        -:  831:      }
        -:  832:
    #####:  833:      (*num_function_imports)++;
    #####:  834:      thunks32++;
        -:  835:    }
        -:  836:  }
        -:  837:
    #####:  838:  return head;
        -:  839:}
        -:  840:
        -:  841:
    #####:  842:int pe_valid_dll_name(
        -:  843:    const char* dll_name, size_t n)
        -:  844:{
    #####:  845:  const char* c = dll_name;
    #####:  846:  size_t l = 0;
        -:  847:
    #####:  848:  while (l < n && *c != '\0')
        -:  849:  {
    #####:  850:    if ((*c >= 'a' && *c <= 'z') ||
    #####:  851:        (*c >= 'A' && *c <= 'Z') ||
    #####:  852:        (*c >= '0' && *c <= '9') ||
    #####:  853:        (*c == '_' || *c == '.' || *c == '-'))
        -:  854:    {
    #####:  855:      c++;
    #####:  856:      l++;
        -:  857:    }
        -:  858:    else
        -:  859:    {
    #####:  860:      return false;
        -:  861:    }
        -:  862:  }
        -:  863:
    #####:  864:  return (l > 0 && l < n);
        -:  865:}
        -:  866:
        -:  867:
        -:  868://
        -:  869:// Walk the imports and collect relevant information. It is used in the
        -:  870:// "imports" function for comparison and in the "imphash" function for
        -:  871:// calculation.
        -:  872://
        -:  873:
    #####:  874:IMPORTED_DLL* pe_parse_imports(
        -:  875:    PE* pe)
        -:  876:{
        -:  877:  int64_t offset;
    #####:  878:  int num_imports = 0;           // Number of imported DLLs
    #####:  879:  int num_function_imports = 0;  // Total number of functions imported
        -:  880:
    #####:  881:  IMPORTED_DLL* head = NULL;
    #####:  882:  IMPORTED_DLL* tail = NULL;
        -:  883:
        -:  884:  PIMAGE_IMPORT_DESCRIPTOR imports;
        -:  885:
    #####:  886:  PIMAGE_DATA_DIRECTORY directory = pe_get_directory_entry(
        -:  887:      pe, IMAGE_DIRECTORY_ENTRY_IMPORT);
        -:  888:
    #####:  889:  if (directory == NULL)
    #####:  890:    return NULL;
        -:  891:
    #####:  892:  if (yr_le32toh(directory->VirtualAddress) == 0)
    #####:  893:    return NULL;
        -:  894:
    #####:  895:  offset = pe_rva_to_offset(pe, yr_le32toh(directory->VirtualAddress));
        -:  896:
    #####:  897:  if (offset < 0)
    #####:  898:    return NULL;
        -:  899:
    #####:  900:  imports = (PIMAGE_IMPORT_DESCRIPTOR) \
    #####:  901:      (pe->data + offset);
        -:  902:
    #####:  903:  while (struct_fits_in_pe(pe, imports, IMAGE_IMPORT_DESCRIPTOR) &&
    #####:  904:         yr_le32toh(imports->Name) != 0 && num_imports < MAX_PE_IMPORTS)
        -:  905:  {
    #####:  906:    int64_t offset = pe_rva_to_offset(pe, yr_le32toh(imports->Name));
        -:  907:
    #####:  908:    if (offset >= 0)
        -:  909:    {
        -:  910:      IMPORTED_DLL* imported_dll;
        -:  911:
    #####:  912:      char* dll_name = (char *) (pe->data + offset);
        -:  913:
    #####:  914:      if (!pe_valid_dll_name(dll_name, pe->data_size - (size_t) offset))
        -:  915:      {
    #####:  916:          imports++;
    #####:  917:          continue;
        -:  918:      }
        -:  919:
    #####:  920:      imported_dll = (IMPORTED_DLL*) yr_calloc(1, sizeof(IMPORTED_DLL));
        -:  921:
    #####:  922:      if (imported_dll != NULL)
        -:  923:      {
    #####:  924:        IMPORT_FUNCTION* functions = pe_parse_import_descriptor(
        -:  925:            pe, imports, dll_name, &num_function_imports);
        -:  926:
    #####:  927:        if (functions != NULL)
        -:  928:        {
    #####:  929:          imported_dll->name = yr_strdup(dll_name);;
    #####:  930:          imported_dll->functions = functions;
    #####:  931:          imported_dll->next = NULL;
        -:  932:
    #####:  933:          if (head == NULL)
    #####:  934:            head = imported_dll;
        -:  935:
    #####:  936:          if (tail != NULL)
    #####:  937:            tail->next = imported_dll;
        -:  938:
    #####:  939:          tail = imported_dll;
        -:  940:        }
        -:  941:        else
        -:  942:        {
    #####:  943:          yr_free(imported_dll);
        -:  944:        }
        -:  945:      }
        -:  946:    }
        -:  947:
    #####:  948:    num_imports++;
    #####:  949:    imports++;
        -:  950:  }
        -:  951:
    #####:  952:  set_integer(num_imports, pe->object, "number_of_imports");
    #####:  953:  return head;
        -:  954:}
        -:  955:
        -:  956://
        -:  957:// Walk the exports and collect relevant information. It is used in the
        -:  958:// "exports" function for comparison.
        -:  959://
        -:  960:
    #####:  961:EXPORT_FUNCTIONS* pe_parse_exports(
        -:  962:    PE* pe)
        -:  963:{
        -:  964:  PIMAGE_DATA_DIRECTORY directory;
        -:  965:  PIMAGE_EXPORT_DIRECTORY exports;
        -:  966:  EXPORT_FUNCTIONS* exported_functions;
        -:  967:
        -:  968:  uint32_t i;
        -:  969:  uint16_t ordinal;
        -:  970:  int64_t offset;
        -:  971:  size_t remaining;
        -:  972:
    #####:  973:  DWORD* names = NULL;
    #####:  974:  WORD* ordinals = NULL;
        -:  975:
        -:  976:  // If not a PE file, return UNDEFINED
        -:  977:
    #####:  978:  if (pe == NULL)
    #####:  979:    return NULL;
        -:  980:
    #####:  981:  directory = pe_get_directory_entry(
        -:  982:      pe, IMAGE_DIRECTORY_ENTRY_EXPORT);
        -:  983:
    #####:  984:  if (directory == NULL)
    #####:  985:    return NULL;
        -:  986:
    #####:  987:  if (yr_le32toh(directory->VirtualAddress) == 0)
    #####:  988:    return NULL;
        -:  989:
    #####:  990:  offset = pe_rva_to_offset(pe, yr_le32toh(directory->VirtualAddress));
        -:  991:
    #####:  992:  if (offset < 0)
    #####:  993:    return NULL;
        -:  994:
    #####:  995:  exports = (PIMAGE_EXPORT_DIRECTORY) (pe->data + offset);
        -:  996:
    #####:  997:  if (!struct_fits_in_pe(pe, exports, IMAGE_EXPORT_DIRECTORY))
    #####:  998:    return NULL;
        -:  999:
    #####: 1000:  if (yr_le32toh(exports->NumberOfFunctions) > MAX_PE_EXPORTS ||
    #####: 1001:      yr_le32toh(exports->NumberOfFunctions) * sizeof(DWORD) > pe->data_size - offset)
    #####: 1002:    return NULL;
        -: 1003:
    #####: 1004:  if (yr_le32toh(exports->NumberOfNames) > 0)
        -: 1005:  {
    #####: 1006:    offset = pe_rva_to_offset(pe, yr_le32toh(exports->AddressOfNames));
        -: 1007:
    #####: 1008:    if (offset < 0)
    #####: 1009:      return NULL;
        -: 1010:
    #####: 1011:    if (yr_le32toh(exports->NumberOfNames) * sizeof(DWORD) > pe->data_size - offset)
    #####: 1012:      return NULL;
        -: 1013:
    #####: 1014:    names = (DWORD*)(pe->data + offset);
        -: 1015:
    #####: 1016:    offset = pe_rva_to_offset(pe, yr_le32toh(exports->AddressOfNameOrdinals));
        -: 1017:
    #####: 1018:    if (offset < 0)
    #####: 1019:      return NULL;
        -: 1020:
    #####: 1021:    ordinals = (WORD*)(pe->data + offset);
        -: 1022:  }
        -: 1023:
    #####: 1024:  exported_functions = (EXPORT_FUNCTIONS*) yr_malloc(sizeof(EXPORT_FUNCTIONS));
        -: 1025:
    #####: 1026:  if (exported_functions == NULL)
    #####: 1027:    return NULL;
        -: 1028:
    #####: 1029:  exported_functions->number_of_exports = yr_le32toh(
        -: 1030:      exports->NumberOfFunctions);
        -: 1031:
    #####: 1032:  exported_functions->functions = (EXPORT_FUNCTION*) yr_malloc(
    #####: 1033:      exported_functions->number_of_exports * sizeof(EXPORT_FUNCTION));
        -: 1034:
    #####: 1035:  if (exported_functions->functions == NULL)
        -: 1036:  {
    #####: 1037:    yr_free(exported_functions);
    #####: 1038:    return NULL;
        -: 1039:  }
        -: 1040:
        -: 1041:  // At first, iterate through Functions array and create representation for
        -: 1042:  // each exported function. Ordinal is just array index that starts from 1
    #####: 1043:  for (i = 0; i < exported_functions->number_of_exports; i++)
        -: 1044:  {
    #####: 1045:    exported_functions->functions[i].name = NULL;
    #####: 1046:    exported_functions->functions[i].ordinal = i + 1;
        -: 1047:  }
        -: 1048:
        -: 1049:  // Now, we can iterate through Names and NameOrdinals arrays to obtain
        -: 1050:  // function names. Not all functions have names.
    #####: 1051:  uint32_t number_of_names = yr_min(
        -: 1052:      yr_le32toh(exports->NumberOfNames),
        -: 1053:      exported_functions->number_of_exports);
        -: 1054:
    #####: 1055:  for (i = 0; i < number_of_names; i++)
        -: 1056:  {
    #####: 1057:    if (available_space(pe, names + i) < sizeof(DWORD) ||
    #####: 1058:        available_space(pe, ordinals + i) < sizeof(WORD))
        -: 1059:    {
        -: 1060:      break;
        -: 1061:    }
        -: 1062:
    #####: 1063:    offset = pe_rva_to_offset(pe, names[i]);
        -: 1064:
    #####: 1065:    if (offset < 0)
    #####: 1066:      continue;
        -: 1067:
        -: 1068:    // Even though it is called ordinal, it is just index to Functions array
        -: 1069:    // If it was ordinal it would start from 1 but it starts from 0
    #####: 1070:    ordinal = yr_le16toh(ordinals[i]);
        -: 1071:
    #####: 1072:    if (ordinal >= exported_functions->number_of_exports)
    #####: 1073:      continue;
        -: 1074:
    #####: 1075:    remaining = pe->data_size - (size_t) offset;
        -: 1076:
    #####: 1077:    if (exported_functions->functions[ordinal].name == NULL)
        -: 1078:    {
    #####: 1079:      exported_functions->functions[ordinal].name = yr_strndup(
    #####: 1080:          (char*) (pe->data + offset), remaining);
        -: 1081:    }
        -: 1082:  }
        -: 1083:
    #####: 1084:  set_integer(
        -: 1085:      exported_functions->number_of_exports,
        -: 1086:      pe->object, "number_of_exports");
        -: 1087:
    #####: 1088:  return exported_functions;
        -: 1089:}
        -: 1090:
        -: 1091:
        -: 1092:#if defined(HAVE_LIBCRYPTO)
        -: 1093:
    #####: 1094:void pe_parse_certificates(
        -: 1095:    PE* pe)
        -: 1096:{
    #####: 1097:  int i, counter = 0;
        -: 1098:
        -: 1099:  const uint8_t* eod;
        -: 1100:  uintptr_t end;
        -: 1101:
        -: 1102:  PWIN_CERTIFICATE win_cert;
        -: 1103:
    #####: 1104:  PIMAGE_DATA_DIRECTORY directory = pe_get_directory_entry(
        -: 1105:      pe, IMAGE_DIRECTORY_ENTRY_SECURITY);
        -: 1106:
    #####: 1107:  if (directory == NULL)
    #####: 1108:    return;
        -: 1109:
        -: 1110:  // Default to 0 signatures until we know otherwise.
    #####: 1111:  set_integer(0, pe->object, "number_of_signatures");
        -: 1112:
        -: 1113:  // directory->VirtualAddress is a file offset. Don't call pe_rva_to_offset().
    #####: 1114:  if (yr_le32toh(directory->VirtualAddress) == 0 ||
    #####: 1115:      yr_le32toh(directory->VirtualAddress) > pe->data_size ||
    #####: 1116:      yr_le32toh(directory->Size) > pe->data_size ||
    #####: 1117:      yr_le32toh(directory->VirtualAddress) + yr_le32toh(directory->Size) > pe->data_size)
        -: 1118:  {
    #####: 1119:    return;
        -: 1120:  }
        -: 1121:
        -: 1122:  // Store the end of directory, making comparisons easier.
    #####: 1123:  eod = pe->data + \
    #####: 1124:        yr_le32toh(directory->VirtualAddress) + \
    #####: 1125:        yr_le32toh(directory->Size);
        -: 1126:
    #####: 1127:  win_cert = (PWIN_CERTIFICATE) \
    #####: 1128:    (pe->data + yr_le32toh(directory->VirtualAddress));
        -: 1129:
        -: 1130:  //
        -: 1131:  // Walk the directory, pulling out certificates.
        -: 1132:  //
        -: 1133:  // Make sure WIN_CERTIFICATE fits within the directory.
        -: 1134:  // Make sure the Length specified fits within directory too.
        -: 1135:  //
        -: 1136:  // The docs say that the length is only for the Certificate, but the next
        -: 1137:  // paragraph contradicts that. All the binaries I've seen have the Length
        -: 1138:  // being the entire structure (Certificate included).
        -: 1139:  //
        -: 1140:
    #####: 1141:  while (struct_fits_in_pe(pe, win_cert, WIN_CERTIFICATE) &&
    #####: 1142:         yr_le32toh(win_cert->Length) > sizeof(WIN_CERTIFICATE) &&
    #####: 1143:         fits_in_pe(pe, win_cert, yr_le32toh(win_cert->Length)) &&
    #####: 1144:         (uint8_t*) win_cert + sizeof(WIN_CERTIFICATE) < eod &&
    #####: 1145:         (uint8_t*) win_cert + yr_le32toh(win_cert->Length) <= eod)
        -: 1146:  {
        -: 1147:    BIO* cert_bio;
        -: 1148:    PKCS7* pkcs7;
        -: 1149:    STACK_OF(X509)* certs;
        -: 1150:
        -: 1151:    // Some sanity checks
        -: 1152:
    #####: 1153:    if (yr_le32toh(win_cert->Length) == 0 ||
    #####: 1154:        (yr_le16toh(win_cert->Revision) != WIN_CERT_REVISION_1_0 &&
    #####: 1155:         yr_le16toh(win_cert->Revision) != WIN_CERT_REVISION_2_0))
        -: 1156:    {
        -: 1157:      break;
        -: 1158:    }
        -: 1159:
        -: 1160:    // Don't support legacy revision for now.
        -: 1161:    // Make sure type is PKCS#7 too.
        -: 1162:
    #####: 1163:    if (yr_le16toh(win_cert->Revision) != WIN_CERT_REVISION_2_0 ||
    #####: 1164:        yr_le16toh(win_cert->CertificateType) != WIN_CERT_TYPE_PKCS_SIGNED_DATA)
        -: 1165:    {
    #####: 1166:      uintptr_t end = (uintptr_t)
    #####: 1167:          ((uint8_t *) win_cert) + yr_le32toh(win_cert->Length);
        -: 1168:
    #####: 1169:      win_cert = (PWIN_CERTIFICATE) (end + (end % 8));
    #####: 1170:      continue;
        -: 1171:    }
        -: 1172:
    #####: 1173:    cert_bio = BIO_new_mem_buf(
    #####: 1174:        win_cert->Certificate, yr_le32toh(win_cert->Length) - WIN_CERTIFICATE_HEADER_SIZE);
        -: 1175:
    #####: 1176:    if (!cert_bio)
    #####: 1177:      break;
        -: 1178:
    #####: 1179:    pkcs7 = d2i_PKCS7_bio(cert_bio, NULL);
    #####: 1180:    certs = PKCS7_get0_signers(pkcs7, NULL, 0);
        -: 1181:
    #####: 1182:    if (!certs)
        -: 1183:    {
    #####: 1184:      BIO_free(cert_bio);
    #####: 1185:      PKCS7_free(pkcs7);
    #####: 1186:      break;
        -: 1187:    }
        -: 1188:
    #####: 1189:    for (i = 0; i < sk_X509_num(certs); i++)
        -: 1190:    {
        -: 1191:      time_t date_time;
        -: 1192:      const char* sig_alg;
        -: 1193:      char buffer[256];
        -: 1194:      int bytes;
        -: 1195:
        -: 1196:      ASN1_INTEGER* serial;
        -: 1197:
    #####: 1198:      X509* cert = sk_X509_value(certs, i);
        -: 1199:
    #####: 1200:      X509_NAME_oneline(
    #####: 1201:          X509_get_issuer_name(cert), buffer, sizeof(buffer));
        -: 1202:
    #####: 1203:      set_string(buffer, pe->object, "signatures[%i].issuer", counter);
        -: 1204:
    #####: 1205:      X509_NAME_oneline(
    #####: 1206:          X509_get_subject_name(cert), buffer, sizeof(buffer));
        -: 1207:
    #####: 1208:      set_string(buffer, pe->object, "signatures[%i].subject", counter);
        -: 1209:
    #####: 1210:      set_integer(
        -: 1211:          X509_get_version(cert) + 1, // Versions are zero based, so add one.
        -: 1212:          pe->object,
        -: 1213:          "signatures[%i].version", counter);
        -: 1214:
    #####: 1215:      sig_alg = OBJ_nid2ln(X509_get_signature_nid(cert));
        -: 1216:
    #####: 1217:      set_string(sig_alg, pe->object, "signatures[%i].algorithm", counter);
        -: 1218:
    #####: 1219:      serial = X509_get_serialNumber(cert);
        -: 1220:
    #####: 1221:      if (serial)
        -: 1222:      {
        -: 1223:        // ASN1_INTEGER can be negative (serial->type & V_ASN1_NEG_INTEGER),
        -: 1224:        // in which case the serial number will be stored in 2's complement.
        -: 1225:        //
        -: 1226:        // Handle negative serial numbers, which are technically not allowed
        -: 1227:        // by RFC5280, but do exist. An example binary which has a negative
        -: 1228:        // serial number is: 4bfe05f182aa273e113db6ed7dae4bb8.
        -: 1229:        //
        -: 1230:        // Negative serial numbers are handled by calling i2d_ASN1_INTEGER()
        -: 1231:        // with a NULL second parameter. This will return the size of the
        -: 1232:        // buffer necessary to store the proper serial number.
        -: 1233:        //
        -: 1234:        // Do this even for positive serial numbers because it makes the code
        -: 1235:        // cleaner and easier to read.
        -: 1236:
    #####: 1237:        bytes = i2d_ASN1_INTEGER(serial, NULL);
        -: 1238:
        -: 1239:        // According to X.509 specification the maximum length for the
        -: 1240:        // serial number is 20 octets. Add two bytes to account for
        -: 1241:        // DER type and length information.
        -: 1242:
    #####: 1243:        if (bytes > 2 && bytes <= 22)
        -: 1244:        {
        -: 1245:          // Now that we know the size of the serial number allocate enough
        -: 1246:          // space to hold it, and use i2d_ASN1_INTEGER() one last time to
        -: 1247:          // hold it in the allocated buffer.
        -: 1248:
    #####: 1249:          unsigned char* serial_der = (unsigned char*) yr_malloc(bytes);
        -: 1250:
    #####: 1251:          if (serial_der != NULL)
        -: 1252:          {
        -: 1253:            unsigned char* serial_bytes;
        -: 1254:            char *serial_ascii;
        -: 1255:
    #####: 1256:            bytes = i2d_ASN1_INTEGER(serial, &serial_der);
        -: 1257:
        -: 1258:            // i2d_ASN1_INTEGER() moves the pointer as it writes into
        -: 1259:            // serial_bytes. Move it back.
        -: 1260:
    #####: 1261:            serial_der -= bytes;
        -: 1262:
        -: 1263:            // Skip over DER type, length information
    #####: 1264:            serial_bytes = serial_der + 2;
    #####: 1265:            bytes -= 2;
        -: 1266:
        -: 1267:            // Also allocate space to hold the "common" string format:
        -: 1268:            // 00:01:02:03:04...
        -: 1269:            //
        -: 1270:            // For each byte in the serial to convert to hexlified format we
        -: 1271:            // need three bytes, two for the byte itself and one for colon.
        -: 1272:            // The last one doesn't have the colon, but the extra byte is used
        -: 1273:            // for the NULL terminator.
        -: 1274:
    #####: 1275:            serial_ascii = (char*) yr_malloc(bytes * 3);
        -: 1276:
    #####: 1277:            if (serial_ascii)
        -: 1278:            {
        -: 1279:              int j;
        -: 1280:
    #####: 1281:              for (j = 0; j < bytes; j++)
        -: 1282:              {
        -: 1283:                // Don't put the colon on the last one.
    #####: 1284:                if (j < bytes - 1)
    #####: 1285:                  snprintf(
    #####: 1286:                    serial_ascii + 3 * j, 4, "%02x:", serial_bytes[j]);
        -: 1287:                else
    #####: 1288:                  snprintf(
    #####: 1289:                    serial_ascii + 3 * j, 3, "%02x", serial_bytes[j]);
        -: 1290:              }
        -: 1291:
    #####: 1292:              set_string(
        -: 1293:                  serial_ascii,
        -: 1294:                  pe->object,
        -: 1295:                  "signatures[%i].serial",
        -: 1296:                  counter);
        -: 1297:
    #####: 1298:              yr_free(serial_ascii);
        -: 1299:            }
        -: 1300:
    #####: 1301:            yr_free(serial_der);
        -: 1302:          }
        -: 1303:        }
        -: 1304:      }
        -: 1305:
    #####: 1306:      date_time = ASN1_get_time_t(X509_get_notBefore(cert));
    #####: 1307:      set_integer(date_time, pe->object, "signatures[%i].not_before", counter);
        -: 1308:
    #####: 1309:      date_time = ASN1_get_time_t(X509_get_notAfter(cert));
    #####: 1310:      set_integer(date_time, pe->object, "signatures[%i].not_after", counter);
        -: 1311:
    #####: 1312:      counter++;
        -: 1313:    }
        -: 1314:
    #####: 1315:    end = (uintptr_t)((uint8_t *) win_cert) + yr_le32toh(win_cert->Length);
    #####: 1316:    win_cert = (PWIN_CERTIFICATE)(end + (end % 8));
        -: 1317:
    #####: 1318:    BIO_free(cert_bio);
    #####: 1319:    PKCS7_free(pkcs7);
    #####: 1320:    sk_X509_free(certs);
        -: 1321:  }
        -: 1322:
    #####: 1323:  set_integer(counter, pe->object, "number_of_signatures");
        -: 1324:}
        -: 1325:
        -: 1326:#endif  // defined(HAVE_LIBCRYPTO)
        -: 1327:
        -: 1328:
    #####: 1329:void pe_parse_header(
        -: 1330:    PE* pe,
        -: 1331:    uint64_t base_address,
        -: 1332:    int flags)
        -: 1333:{
        -: 1334:  PIMAGE_SECTION_HEADER section;
        -: 1335:
        -: 1336:  char section_name[IMAGE_SIZEOF_SHORT_NAME + 1];
        -: 1337:  int i, scount;
    #####: 1338:  uint64_t highest_sec_siz = 0;
    #####: 1339:  uint64_t highest_sec_ofs = 0;
        -: 1340:  uint64_t section_end;
        -: 1341:  uint64_t last_section_end;
        -: 1342:
    #####: 1343:  set_integer(
        -: 1344:      yr_le16toh(pe->header->FileHeader.Machine),
        -: 1345:      pe->object, "machine");
        -: 1346:
    #####: 1347:  set_integer(
        -: 1348:      yr_le16toh(pe->header->FileHeader.NumberOfSections),
        -: 1349:      pe->object, "number_of_sections");
        -: 1350:
    #####: 1351:  set_integer(
        -: 1352:      yr_le32toh(pe->header->FileHeader.TimeDateStamp),
        -: 1353:      pe->object, "timestamp");
        -: 1354:
    #####: 1355:  set_integer(
        -: 1356:      yr_le16toh(pe->header->FileHeader.Characteristics),
        -: 1357:      pe->object, "characteristics");
        -: 1358:
    #####: 1359:  set_integer(
        -: 1360:      flags & SCAN_FLAGS_PROCESS_MEMORY ?
        -: 1361:      base_address + yr_le32toh(OptionalHeader(pe, AddressOfEntryPoint)) :
        -: 1362:      pe_rva_to_offset(pe, yr_le32toh(OptionalHeader(pe, AddressOfEntryPoint))),
        -: 1363:      pe->object, "entry_point");
        -: 1364:
    #####: 1365:  set_integer(
        -: 1366:      IS_64BITS_PE(pe) ?
        -: 1367:      yr_le64toh(OptionalHeader(pe, ImageBase)) :
        -: 1368:      yr_le32toh(OptionalHeader(pe, ImageBase)),
        -: 1369:      pe->object, "image_base");
        -: 1370:
    #####: 1371:  set_integer(
        -: 1372:      yr_le32toh(OptionalHeader(pe, NumberOfRvaAndSizes)),
        -: 1373:      pe->object, "number_of_rva_and_sizes");
        -: 1374:
    #####: 1375:  set_integer(
        -: 1376:      OptionalHeader(pe, MajorLinkerVersion),
        -: 1377:      pe->object, "linker_version.major");
        -: 1378:
    #####: 1379:  set_integer(
        -: 1380:      OptionalHeader(pe, MinorLinkerVersion),
        -: 1381:      pe->object, "linker_version.minor");
        -: 1382:
    #####: 1383:  set_integer(
        -: 1384:      yr_le16toh(OptionalHeader(pe, MajorOperatingSystemVersion)),
        -: 1385:      pe->object, "os_version.major");
        -: 1386:
    #####: 1387:  set_integer(
        -: 1388:      yr_le16toh(OptionalHeader(pe, MinorOperatingSystemVersion)),
        -: 1389:      pe->object, "os_version.minor");
        -: 1390:
    #####: 1391:  set_integer(
        -: 1392:      yr_le16toh(OptionalHeader(pe, MajorImageVersion)),
        -: 1393:      pe->object, "image_version.major");
        -: 1394:
    #####: 1395:  set_integer(
        -: 1396:      yr_le16toh(OptionalHeader(pe, MinorImageVersion)),
        -: 1397:      pe->object, "image_version.minor");
        -: 1398:
    #####: 1399:  set_integer(
        -: 1400:      yr_le16toh(OptionalHeader(pe, MajorSubsystemVersion)),
        -: 1401:      pe->object, "subsystem_version.major");
        -: 1402:
    #####: 1403:  set_integer(
        -: 1404:      yr_le16toh(OptionalHeader(pe, MinorSubsystemVersion)),
        -: 1405:      pe->object, "subsystem_version.minor");
        -: 1406:
    #####: 1407:  set_integer(
        -: 1408:      yr_le32toh(OptionalHeader(pe, CheckSum)),
        -: 1409:      pe->object, "checksum");
        -: 1410:
    #####: 1411:  set_integer(
        -: 1412:      yr_le16toh(OptionalHeader(pe, Subsystem)),
        -: 1413:      pe->object, "subsystem");
        -: 1414:
    #####: 1415:  set_integer(
        -: 1416:      OptionalHeader(pe, DllCharacteristics),
        -: 1417:      pe->object, "dll_characteristics");
        -: 1418:
    #####: 1419:  pe_iterate_resources(
        -: 1420:      pe,
        -: 1421:      (RESOURCE_CALLBACK_FUNC) pe_collect_resources,
        -: 1422:      (void*) pe);
        -: 1423:
    #####: 1424:  set_integer(pe->resources, pe->object, "number_of_resources");
        -: 1425:
    #####: 1426:  section = IMAGE_FIRST_SECTION(pe->header);
        -: 1427:
    #####: 1428:  scount = yr_min(
        -: 1429:      yr_le16toh(pe->header->FileHeader.NumberOfSections), MAX_PE_SECTIONS);
        -: 1430:
    #####: 1431:  for (i = 0; i < scount; i++)
        -: 1432:  {
    #####: 1433:    if (!struct_fits_in_pe(pe, section, IMAGE_SECTION_HEADER))
        -: 1434:      break;
        -: 1435:
    #####: 1436:    strncpy(section_name, (char*) section->Name, IMAGE_SIZEOF_SHORT_NAME);
    #####: 1437:    section_name[IMAGE_SIZEOF_SHORT_NAME] = '\0';
        -: 1438:
    #####: 1439:    set_string(
        -: 1440:        section_name,
        -: 1441:        pe->object, "sections[%i].name", i);
        -: 1442:
    #####: 1443:    set_integer(
        -: 1444:        yr_le32toh(section->Characteristics),
        -: 1445:        pe->object, "sections[%i].characteristics", i);
        -: 1446:
    #####: 1447:    set_integer(
        -: 1448:        yr_le32toh(section->SizeOfRawData),
        -: 1449:        pe->object, "sections[%i].raw_data_size", i);
        -: 1450:
    #####: 1451:    set_integer(
        -: 1452:        yr_le32toh(section->PointerToRawData),
        -: 1453:        pe->object, "sections[%i].raw_data_offset", i);
        -: 1454:
    #####: 1455:    set_integer(
        -: 1456:        yr_le32toh(section->VirtualAddress),
        -: 1457:        pe->object, "sections[%i].virtual_address", i);
        -: 1458:
    #####: 1459:    set_integer(
        -: 1460:        yr_le32toh(section->Misc.VirtualSize),
        -: 1461:        pe->object, "sections[%i].virtual_size", i);
        -: 1462:
        -: 1463:    // This will catch the section with the highest raw offset to help checking
        -: 1464:    // if overlay data is present. If two sections have the same raw pointer
        -: 1465:    // but different raw sizes the largest one is used. An example of this case
        -: 1466:    // is file: cf62bf1815a93e68e6c5189f689286b66c4088b9507cf3ecf835e4ac3f9ededa
        -: 1467:
    #####: 1468:    section_end = yr_le32toh(section->PointerToRawData) +
    #####: 1469:                  yr_le32toh(section->SizeOfRawData);
        -: 1470:
    #####: 1471:    if (section_end > highest_sec_ofs + highest_sec_siz)
        -: 1472:    {
    #####: 1473:      highest_sec_ofs = yr_le32toh(section->PointerToRawData);
    #####: 1474:      highest_sec_siz = yr_le32toh(section->SizeOfRawData);
        -: 1475:    }
        -: 1476:
    #####: 1477:    section++;
        -: 1478:  }
        -: 1479:
        -: 1480:  // An overlay is data appended to a PE file. Its location is at
        -: 1481:  // RawData + RawOffset of the last section on the physical file
    #####: 1482:  last_section_end = highest_sec_siz + highest_sec_ofs;
        -: 1483:
        -: 1484:  // "overlay.offset" is set to UNDEFINED for files that do not have an overlay
    #####: 1485:  if (last_section_end && (pe->data_size > last_section_end))
    #####: 1486:    set_integer(last_section_end, pe->object, "overlay.offset");
        -: 1487:
        -: 1488:  // "overlay.size" is zero for well formed PE files that don not have an
        -: 1489:  // overlay and UNDEFINED for malformed PE files or non-PE files.
    #####: 1490:  if (last_section_end && (pe->data_size >= last_section_end))
    #####: 1491:    set_integer(pe->data_size - last_section_end, pe->object, "overlay.size");
    #####: 1492:}
        -: 1493:
        -: 1494://
        -: 1495:// Given a posix timestamp argument, make sure not_before <= arg <= not_after
        -: 1496://
        -: 1497:
    #####: 1498:define_function(valid_on)
        -: 1499:{
        -: 1500:  int64_t timestamp;
        -: 1501:  int64_t not_before;
        -: 1502:  int64_t not_after;
        -: 1503:
    #####: 1504:  if (is_undefined(parent(), "not_before") ||
    #####: 1505:      is_undefined(parent(), "not_after"))
        -: 1506:  {
    #####: 1507:    return_integer(UNDEFINED);
        -: 1508:  }
        -: 1509:
    #####: 1510:  timestamp = integer_argument(1);
        -: 1511:
    #####: 1512:  not_before = get_integer(parent(), "not_before");
    #####: 1513:  not_after = get_integer(parent(), "not_after");
        -: 1514:
    #####: 1515:  return_integer(timestamp >= not_before  && timestamp <= not_after);
        -: 1516:}
        -: 1517:
        -: 1518:
    #####: 1519:define_function(section_index_addr)
        -: 1520:{
    #####: 1521:  YR_OBJECT* module = module();
    #####: 1522:  YR_SCAN_CONTEXT* context = scan_context();
        -: 1523:
        -: 1524:  int64_t i;
        -: 1525:  int64_t offset;
        -: 1526:  int64_t size;
        -: 1527:
    #####: 1528:  int64_t addr = integer_argument(1);
    #####: 1529:  int64_t n = get_integer(module, "number_of_sections");
        -: 1530:
    #####: 1531:  if (is_undefined(module, "number_of_sections"))
    #####: 1532:    return_integer(UNDEFINED);
        -: 1533:
    #####: 1534:  for (i = 0; i < yr_min(n, MAX_PE_SECTIONS); i++)
        -: 1535:  {
    #####: 1536:    if (context->flags & SCAN_FLAGS_PROCESS_MEMORY)
        -: 1537:    {
    #####: 1538:      offset = get_integer(module, "sections[%i].virtual_address", i);
    #####: 1539:      size = get_integer(module, "sections[%i].virtual_size", i);
        -: 1540:    }
        -: 1541:    else
        -: 1542:    {
    #####: 1543:      offset = get_integer(module, "sections[%i].raw_data_offset", i);
    #####: 1544:      size = get_integer(module, "sections[%i].raw_data_size", i);
        -: 1545:    }
        -: 1546:
    #####: 1547:    if (addr >= offset && addr < offset + size)
    #####: 1548:      return_integer(i);
        -: 1549:  }
        -: 1550:
    #####: 1551:  return_integer(UNDEFINED);
        -: 1552:}
        -: 1553:
        -: 1554:
    #####: 1555:define_function(section_index_name)
        -: 1556:{
    #####: 1557:  YR_OBJECT* module = module();
        -: 1558:
    #####: 1559:  char* name = string_argument(1);
        -: 1560:
    #####: 1561:  int64_t n = get_integer(module, "number_of_sections");
        -: 1562:  int64_t i;
        -: 1563:
    #####: 1564:  if (is_undefined(module, "number_of_sections"))
    #####: 1565:    return_integer(UNDEFINED);
        -: 1566:
    #####: 1567:  for (i = 0; i < yr_min(n, MAX_PE_SECTIONS); i++)
        -: 1568:  {
    #####: 1569:    SIZED_STRING* sect = get_string(module, "sections[%i].name", i);
        -: 1570:
    #####: 1571:    if (sect != NULL && strcmp(name, sect->c_string) == 0)
    #####: 1572:      return_integer(i);
        -: 1573:  }
        -: 1574:
    #####: 1575:  return_integer(UNDEFINED);
        -: 1576:}
        -: 1577:
        -: 1578:
    #####: 1579:define_function(exports)
        -: 1580:{
    #####: 1581:  SIZED_STRING* function_name = sized_string_argument(1);
        -: 1582:
    #####: 1583:  YR_OBJECT* module = module();
    #####: 1584:  PE* pe = (PE*) module->data;
        -: 1585:
        -: 1586:  int i;
        -: 1587:
        -: 1588:  // If not a PE, return UNDEFINED.
    #####: 1589:  if (pe == NULL)
    #####: 1590:    return_integer(UNDEFINED);
        -: 1591:
        -: 1592:  // If PE, but not exported functions, return false.
    #####: 1593:  if (pe->exported_functions == NULL)
    #####: 1594:    return_integer(0);
        -: 1595:
    #####: 1596:  for (i = 0; i < pe->exported_functions->number_of_exports; i++)
        -: 1597:  {
    #####: 1598:    if (pe->exported_functions->functions[i].name &&
    #####: 1599:        strcasecmp(pe->exported_functions->functions[i].name, function_name->c_string) == 0)
        -: 1600:    {
    #####: 1601:      return_integer(1);
        -: 1602:    }
        -: 1603:  }
        -: 1604:
    #####: 1605:  return_integer(0);
        -: 1606:}
        -: 1607:
        -: 1608:
    #####: 1609:define_function(exports_regexp)
        -: 1610:{
    #####: 1611:  RE* regex = regexp_argument(1);
        -: 1612:
    #####: 1613:  YR_OBJECT* module = module();
    #####: 1614:  PE* pe = (PE*) module->data;
        -: 1615:
        -: 1616:  int i;
        -: 1617:
        -: 1618:  // If not a PE, return UNDEFINED.
    #####: 1619:  if (pe == NULL)
    #####: 1620:    return_integer(UNDEFINED);
        -: 1621:
        -: 1622:  // If PE, but not exported functions, return false.
    #####: 1623:  if (pe->exported_functions == NULL)
    #####: 1624:    return_integer(0);
        -: 1625:
    #####: 1626:  for (i = 0; i < pe->exported_functions->number_of_exports; i++)
        -: 1627:  {
    #####: 1628:    if (pe->exported_functions->functions[i].name &&
    #####: 1629:        yr_re_match(scan_context(), regex, pe->exported_functions->functions[i].name) != -1)
        -: 1630:    {
    #####: 1631:      return_integer(1);
        -: 1632:    }
        -: 1633:  }
        -: 1634:
    #####: 1635:  return_integer(0);
        -: 1636:}
        -: 1637:
        -: 1638:
    #####: 1639:define_function(exports_ordinal)
        -: 1640:{
    #####: 1641:  uint64_t ordinal = integer_argument(1);
        -: 1642:
    #####: 1643:  YR_OBJECT* module = module();
    #####: 1644:  PE* pe = (PE*) module->data;
        -: 1645:
        -: 1646:  // If not a PE, return UNDEFINED.
    #####: 1647:  if (pe == NULL)
    #####: 1648:    return_integer(UNDEFINED);
        -: 1649:
        -: 1650:  // If PE, but not exported functions, return false.
    #####: 1651:  if (pe->exported_functions == NULL)
    #####: 1652:    return_integer(0);
        -: 1653:
    #####: 1654:  if (ordinal == 0 || ordinal > pe->exported_functions->number_of_exports)
    #####: 1655:    return_integer(0);
        -: 1656:
        -: 1657:  // Just in case, this should always be true
    #####: 1658:  if (pe->exported_functions->functions[ordinal - 1].ordinal == ordinal)
    #####: 1659:    return_integer(1);
        -: 1660:
    #####: 1661:  return_integer(0);
        -: 1662:}
        -: 1663:
        -: 1664:#if defined(HAVE_LIBCRYPTO) || \
        -: 1665:    defined(HAVE_WINCRYPT_H) || \
        -: 1666:    defined(HAVE_COMMONCRYPTO_COMMONCRYPTO_H)
        -: 1667:
        -: 1668://
        -: 1669:// Generate an import hash:
        -: 1670:// https://www.mandiant.com/blog/tracking-malware-import-hashing/
        -: 1671:// It is important to make duplicates of the strings as we don't want
        -: 1672:// to alter the contents of the parsed import structures.
        -: 1673://
        -: 1674:
    #####: 1675:define_function(imphash)
        -: 1676:{
    #####: 1677:  YR_OBJECT* module = module();
        -: 1678:
        -: 1679:  IMPORTED_DLL* dll;
        -: 1680:  yr_md5_ctx ctx;
        -: 1681:
        -: 1682:  unsigned char digest[YR_MD5_LEN];
        -: 1683:  char digest_ascii[YR_MD5_LEN * 2 + 1];
        -: 1684:  size_t i;
    #####: 1685:  bool first = true;
        -: 1686:
    #####: 1687:  PE* pe = (PE*) module->data;
        -: 1688:
        -: 1689:  // If not a PE, return UNDEFINED.
        -: 1690:
    #####: 1691:  if (!pe)
    #####: 1692:    return_string(UNDEFINED);
        -: 1693:
    #####: 1694:  yr_md5_init(&ctx);
        -: 1695:
    #####: 1696:  dll = pe->imported_dlls;
        -: 1697:
    #####: 1698:  while (dll)
        -: 1699:  {
        -: 1700:    IMPORT_FUNCTION* func;
        -: 1701:
        -: 1702:    size_t dll_name_len;
        -: 1703:    char* dll_name;
        -: 1704:
        -: 1705:    // If extension is 'ocx', 'sys' or 'dll', chop it.
        -: 1706:
    #####: 1707:    char* ext = strstr(dll->name, ".");
        -: 1708:
    #####: 1709:    if (ext && (strncasecmp(ext, ".ocx", 4) == 0 ||
    #####: 1710:                strncasecmp(ext, ".sys", 4) == 0 ||
    #####: 1711:                strncasecmp(ext, ".dll", 4) == 0))
        -: 1712:    {
    #####: 1713:      dll_name_len = (ext - dll->name);
        -: 1714:    }
        -: 1715:    else
        -: 1716:    {
    #####: 1717:      dll_name_len = strlen(dll->name);
        -: 1718:    }
        -: 1719:
        -: 1720:    // Allocate a new string to hold the dll name.
        -: 1721:
    #####: 1722:    dll_name = (char *) yr_malloc(dll_name_len + 1);
        -: 1723:
    #####: 1724:    if (!dll_name)
    #####: 1725:      return ERROR_INSUFFICIENT_MEMORY;
        -: 1726:
    #####: 1727:    strlcpy(dll_name, dll->name, dll_name_len + 1);
        -: 1728:
    #####: 1729:    func = dll->functions;
        -: 1730:
    #####: 1731:    while (func)
        -: 1732:    {
        -: 1733:      char* final_name;
    #####: 1734:      size_t final_name_len = dll_name_len + strlen(func->name) + 1;
        -: 1735:
    #####: 1736:      if (!first)
    #####: 1737:        final_name_len++;   // Additional byte to accommodate the extra comma
        -: 1738:
    #####: 1739:      final_name = (char*) yr_malloc(final_name_len + 1);
        -: 1740:
    #####: 1741:      if (final_name == NULL)
    #####: 1742:        break;
        -: 1743:
    #####: 1744:      sprintf(final_name, first ? "%s.%s": ",%s.%s", dll_name, func->name);
        -: 1745:
        -: 1746:      // Lowercase the whole thing.
        -: 1747:
    #####: 1748:      for (i = 0; i < final_name_len; i++)
    #####: 1749:        final_name[i] = tolower(final_name[i]);
        -: 1750:
    #####: 1751:      yr_md5_update(&ctx, final_name, final_name_len);
        -: 1752:
    #####: 1753:      yr_free(final_name);
        -: 1754:
    #####: 1755:      func = func->next;
    #####: 1756:      first = false;
        -: 1757:    }
        -: 1758:
    #####: 1759:    yr_free(dll_name);
        -: 1760:
    #####: 1761:    dll = dll->next;
        -: 1762:  }
        -: 1763:
    #####: 1764:  yr_md5_final(digest, &ctx);
        -: 1765:
        -: 1766:  // Transform the binary digest to ascii
        -: 1767:
    #####: 1768:  for (i = 0; i < YR_MD5_LEN; i++)
        -: 1769:  {
    #####: 1770:    sprintf(digest_ascii + (i * 2), "%02x", digest[i]);
        -: 1771:  }
        -: 1772:
    #####: 1773:  digest_ascii[YR_MD5_LEN * 2] = '\0';
        -: 1774:
    #####: 1775:  return_string(digest_ascii);
        -: 1776:}
        -: 1777:
        -: 1778:#endif  // defined(HAVE_LIBCRYPTO) || defined(HAVE_WINCRYPT_H)
        -: 1779:
        -: 1780:
    #####: 1781:define_function(imports)
        -: 1782:{
    #####: 1783:  char* dll_name = string_argument(1);
    #####: 1784:  char* function_name = string_argument(2);
        -: 1785:
    #####: 1786:  YR_OBJECT* module = module();
    #####: 1787:  PE* pe = (PE*) module->data;
        -: 1788:
        -: 1789:  IMPORTED_DLL* imported_dll;
        -: 1790:
    #####: 1791:  if (!pe)
    #####: 1792:    return_integer(UNDEFINED);
        -: 1793:
    #####: 1794:  imported_dll = pe->imported_dlls;
        -: 1795:
    #####: 1796:  while (imported_dll != NULL)
        -: 1797:  {
    #####: 1798:    if (strcasecmp(imported_dll->name, dll_name) == 0)
        -: 1799:    {
    #####: 1800:      IMPORT_FUNCTION* imported_func = imported_dll->functions;
        -: 1801:
    #####: 1802:      while (imported_func != NULL)
        -: 1803:      {
    #####: 1804:        if (imported_func->name &&
    #####: 1805:            strcasecmp(imported_func->name, function_name) == 0)
    #####: 1806:          return_integer(1);
        -: 1807:
    #####: 1808:        imported_func = imported_func->next;
        -: 1809:      }
        -: 1810:    }
        -: 1811:
    #####: 1812:    imported_dll = imported_dll->next;
        -: 1813:  }
        -: 1814:
    #####: 1815:  return_integer(0);
        -: 1816:}
        -: 1817:
    #####: 1818:define_function(imports_ordinal)
        -: 1819:{
    #####: 1820:  char* dll_name = string_argument(1);
    #####: 1821:  uint64_t ordinal = integer_argument(2);
        -: 1822:
    #####: 1823:  YR_OBJECT* module = module();
    #####: 1824:  PE* pe = (PE*) module->data;
        -: 1825:
        -: 1826:  IMPORTED_DLL* imported_dll;
        -: 1827:
    #####: 1828:  if (!pe)
    #####: 1829:    return_integer(UNDEFINED);
        -: 1830:
    #####: 1831:  imported_dll = pe->imported_dlls;
        -: 1832:
    #####: 1833:  while (imported_dll != NULL)
        -: 1834:  {
    #####: 1835:    if (strcasecmp(imported_dll->name, dll_name) == 0)
        -: 1836:    {
    #####: 1837:      IMPORT_FUNCTION* imported_func = imported_dll->functions;
        -: 1838:
    #####: 1839:      while (imported_func != NULL)
        -: 1840:      {
    #####: 1841:        if (imported_func->has_ordinal && imported_func->ordinal == ordinal)
    #####: 1842:          return_integer(1);
        -: 1843:
    #####: 1844:        imported_func = imported_func->next;
        -: 1845:      }
        -: 1846:    }
        -: 1847:
    #####: 1848:    imported_dll = imported_dll->next;
        -: 1849:  }
        -: 1850:
    #####: 1851:  return_integer(0);
        -: 1852:}
        -: 1853:
    #####: 1854:define_function(imports_dll)
        -: 1855:{
    #####: 1856:  char* dll_name = string_argument(1);
        -: 1857:
    #####: 1858:  YR_OBJECT* module = module();
    #####: 1859:  PE* pe = (PE*) module->data;
        -: 1860:
        -: 1861:  IMPORTED_DLL* imported_dll;
        -: 1862:
    #####: 1863:  if (!pe)
    #####: 1864:    return_integer(UNDEFINED);
        -: 1865:
    #####: 1866:  imported_dll = pe->imported_dlls;
        -: 1867:
    #####: 1868:  while (imported_dll != NULL)
        -: 1869:  {
    #####: 1870:    if (strcasecmp(imported_dll->name, dll_name) == 0)
        -: 1871:    {
    #####: 1872:      return_integer(1);
        -: 1873:    }
        -: 1874:
    #####: 1875:    imported_dll = imported_dll->next;
        -: 1876:  }
        -: 1877:
    #####: 1878:  return_integer(0);
        -: 1879:}
        -: 1880:
    #####: 1881:define_function(locale)
        -: 1882:{
    #####: 1883:  YR_OBJECT* module = module();
    #####: 1884:  PE* pe = (PE*) module->data;
        -: 1885:
    #####: 1886:  uint64_t locale = integer_argument(1);
        -: 1887:  int64_t n, i;
        -: 1888:
    #####: 1889:  if (is_undefined(module, "number_of_resources"))
    #####: 1890:    return_integer(UNDEFINED);
        -: 1891:
        -: 1892:  // If not a PE file, return UNDEFINED
        -: 1893:
    #####: 1894:  if (pe == NULL)
    #####: 1895:    return_integer(UNDEFINED);
        -: 1896:
    #####: 1897:  n = get_integer(module, "number_of_resources");
        -: 1898:
    #####: 1899:  for (i = 0; i < n; i++)
        -: 1900:  {
    #####: 1901:    uint64_t rsrc_language = get_integer(module, "resources[%i].language", i);
        -: 1902:
    #####: 1903:    if ((rsrc_language & 0xFFFF) == locale)
    #####: 1904:      return_integer(1);
        -: 1905:  }
        -: 1906:
    #####: 1907:  return_integer(0);
        -: 1908:}
        -: 1909:
        -: 1910:
    #####: 1911:define_function(language)
        -: 1912:{
    #####: 1913:  YR_OBJECT* module = module();
    #####: 1914:  PE* pe = (PE*) module->data;
        -: 1915:
    #####: 1916:  uint64_t language = integer_argument(1);
        -: 1917:  int64_t n, i;
        -: 1918:
    #####: 1919:  if (is_undefined(module, "number_of_resources"))
    #####: 1920:    return_integer(UNDEFINED);
        -: 1921:
        -: 1922:  // If not a PE file, return UNDEFINED
        -: 1923:
    #####: 1924:  if (pe == NULL)
    #####: 1925:    return_integer(UNDEFINED);
        -: 1926:
    #####: 1927:  n = get_integer(module, "number_of_resources");
        -: 1928:
    #####: 1929:  for (i = 0; i < n; i++)
        -: 1930:  {
    #####: 1931:    uint64_t rsrc_language = get_integer(module, "resources[%i].language", i);
        -: 1932:
    #####: 1933:    if ((rsrc_language & 0xFF) == language)
    #####: 1934:      return_integer(1);
        -: 1935:  }
        -: 1936:
    #####: 1937:  return_integer(0);
        -: 1938:}
        -: 1939:
        -: 1940:
    #####: 1941:define_function(is_dll)
        -: 1942:{
        -: 1943:  int64_t characteristics;
    #####: 1944:  YR_OBJECT* module = module();
        -: 1945:
    #####: 1946:  if (is_undefined(module, "characteristics"))
    #####: 1947:    return_integer(UNDEFINED);
        -: 1948:
    #####: 1949:  characteristics = get_integer(module, "characteristics");
    #####: 1950:  return_integer(characteristics & IMAGE_FILE_DLL);
        -: 1951:}
        -: 1952:
        -: 1953:
    #####: 1954:define_function(is_32bit)
        -: 1955:{
    #####: 1956:  YR_OBJECT* module = module();
    #####: 1957:  PE* pe = (PE*) module->data;
        -: 1958:
    #####: 1959:  if (pe == NULL)
    #####: 1960:    return_integer(UNDEFINED);
        -: 1961:
    #####: 1962:  return_integer(IS_64BITS_PE(pe) ? 0 : 1);
        -: 1963:}
        -: 1964:
        -: 1965:
    #####: 1966:define_function(is_64bit)
        -: 1967:{
    #####: 1968:  YR_OBJECT* module = module();
    #####: 1969:  PE* pe = (PE*) module->data;
        -: 1970:
    #####: 1971:  if (pe == NULL)
    #####: 1972:    return_integer(UNDEFINED);
        -: 1973:
    #####: 1974:  return_integer(IS_64BITS_PE(pe) ? 1 : 0);
        -: 1975:}
        -: 1976:
        -: 1977:
    #####: 1978:static uint64_t rich_internal(
        -: 1979:    YR_OBJECT* module,
        -: 1980:    uint64_t version,
        -: 1981:    uint64_t toolid)
        -: 1982:{
        -: 1983:  int64_t rich_length;
        -: 1984:  int64_t rich_count;
        -: 1985:  int64_t i;
        -: 1986:
        -: 1987:  PRICH_SIGNATURE clear_rich_signature;
        -: 1988:  SIZED_STRING* rich_string;
        -: 1989:
        -: 1990:  // Check if the required fields are set
    #####: 1991:  if (is_undefined(module, "rich_signature.length"))
    #####: 1992:      return UNDEFINED;
        -: 1993:
    #####: 1994:  rich_length = get_integer(module, "rich_signature.length");
    #####: 1995:  rich_string = get_string(module, "rich_signature.clear_data");
        -: 1996:
        -: 1997:  // If the clear_data was not set, return UNDEFINED
    #####: 1998:  if (rich_string == NULL)
    #####: 1999:      return UNDEFINED;
        -: 2000:
    #####: 2001:  if (version == UNDEFINED && toolid == UNDEFINED)
    #####: 2002:      return false;
        -: 2003:
    #####: 2004:  clear_rich_signature = (PRICH_SIGNATURE) rich_string->c_string;
        -: 2005:
        -: 2006:  // Loop over the versions in the rich signature
        -: 2007:
    #####: 2008:  rich_count = \
    #####: 2009:      (rich_length - sizeof(RICH_SIGNATURE)) / sizeof(RICH_VERSION_INFO);
        -: 2010:
    #####: 2011:  for (i = 0; i < rich_count; i++)
        -: 2012:  {
    #####: 2013:    DWORD id_version = yr_le32toh(clear_rich_signature->versions[i].id_version);
        -: 2014:
    #####: 2015:    int match_version = (version == RICH_VERSION_VERSION(id_version));
    #####: 2016:    int match_toolid = (toolid == RICH_VERSION_ID(id_version));
        -: 2017:
    #####: 2018:    if (version != UNDEFINED && toolid != UNDEFINED)
        -: 2019:    {
        -: 2020:      // check version and toolid
    #####: 2021:      if (match_version && match_toolid)
    #####: 2022:        return true;
        -: 2023:    }
    #####: 2024:    else if (version != UNDEFINED)
        -: 2025:    {
        -: 2026:      // check only version
    #####: 2027:      if (match_version)
    #####: 2028:        return true;
        -: 2029:    }
    #####: 2030:    else if (toolid != UNDEFINED)
        -: 2031:    {
        -: 2032:      // check only toolid
    #####: 2033:      if (match_toolid)
    #####: 2034:        return true;
        -: 2035:    }
        -: 2036:  }
        -: 2037:
    #####: 2038:  return false;
        -: 2039:}
        -: 2040:
        -: 2041:
    #####: 2042:define_function(rich_version)
        -: 2043:{
    #####: 2044:  return_integer(
        -: 2045:      rich_internal(module(), integer_argument(1), UNDEFINED));
        -: 2046:}
        -: 2047:
        -: 2048:
    #####: 2049:define_function(rich_version_toolid)
        -: 2050:{
    #####: 2051:  return_integer(
        -: 2052:      rich_internal(module(), integer_argument(1), integer_argument(2)));
        -: 2053:}
        -: 2054:
        -: 2055:
    #####: 2056:define_function(rich_toolid)
        -: 2057:{
    #####: 2058:    return_integer(
        -: 2059:       rich_internal(module(), UNDEFINED, integer_argument(1)));
        -: 2060:}
        -: 2061:
        -: 2062:
    #####: 2063:define_function(rich_toolid_version)
        -: 2064:{
    #####: 2065:  return_integer(
        -: 2066:      rich_internal(module(), integer_argument(2), integer_argument(1)));
        -: 2067:}
        -: 2068:
        -: 2069:
    #####: 2070:define_function(calculate_checksum)
        -: 2071:{
    #####: 2072:  YR_OBJECT* module = module();
    #####: 2073:  PE* pe = (PE*) module->data;
        -: 2074:
    #####: 2075:  uint64_t csum = 0;
        -: 2076:  size_t csum_offset;
        -: 2077:  size_t i, j;
        -: 2078:
    #####: 2079:  if (pe == NULL)
    #####: 2080:    return_integer(UNDEFINED);
        -: 2081:
    #####: 2082:  csum_offset = ((uint8_t*) &(pe->header->OptionalHeader) +
    #####: 2083:      offsetof(IMAGE_OPTIONAL_HEADER32, CheckSum)) - pe->data;
        -: 2084:
    #####: 2085:  for (i = 0; i <= pe->data_size / 4; i++)
        -: 2086:  {
        -: 2087:    // Treat the CheckSum field as 0 -- the offset is the same for
        -: 2088:    // PE32 and PE64.
        -: 2089:
    #####: 2090:    if (4 * i == csum_offset)
    #####: 2091:      continue;
        -: 2092:
    #####: 2093:    if (4 * i + 4 <= pe->data_size)
        -: 2094:    {
    #####: 2095:      csum += ((uint64_t) pe->data[4 * i] +
    #####: 2096:          ((uint64_t) pe->data[4 * i + 1] << 8)  +
    #####: 2097:          ((uint64_t) pe->data[4 * i + 2] << 16) +
    #####: 2098:          ((uint64_t) pe->data[4 * i + 3] << 24));
        -: 2099:    }
        -: 2100:    else
        -: 2101:    {
    #####: 2102:      for (j = 0; j < pe->data_size % 4; j++)
    #####: 2103:        csum += (uint64_t) pe->data[4 * i + j] << (8 * j);
        -: 2104:    }
        -: 2105:
    #####: 2106:    if (csum > 0xffffffff)
    #####: 2107:      csum = (csum & 0xffffffff) + (csum >> 32);
        -: 2108:  }
        -: 2109:
    #####: 2110:  csum = (csum & 0xffff) + (csum >> 16);
    #####: 2111:  csum += (csum >> 16);
    #####: 2112:  csum &= 0xffff;
    #####: 2113:  csum += pe->data_size;
        -: 2114:
    #####: 2115:  return_integer(csum);
        -: 2116:}
        -: 2117:
        -: 2118:
    #####: 2119:define_function(rva_to_offset)
        -: 2120:{
    #####: 2121:  YR_OBJECT* module = module();
    #####: 2122:  PE* pe = (PE*) module->data;
        -: 2123:
        -: 2124:  uint64_t rva, offset;
        -: 2125:
    #####: 2126:  if (pe == NULL)
    #####: 2127:    return_integer(UNDEFINED);
        -: 2128:
    #####: 2129:  rva = integer_argument(1);
    #####: 2130:  offset = pe_rva_to_offset(pe, rva);
    #####: 2131:  if (offset == -1)
    #####: 2132:    return_integer(UNDEFINED);
        -: 2133:
    #####: 2134:  return_integer(offset);
        -: 2135:}
        -: 2136:
        -: 2137:
    #####: 2138:begin_declarations;
        -: 2139:
    #####: 2140:  declare_integer("MACHINE_UNKNOWN");
    #####: 2141:  declare_integer("MACHINE_AM33");
    #####: 2142:  declare_integer("MACHINE_AMD64");
    #####: 2143:  declare_integer("MACHINE_ARM");
    #####: 2144:  declare_integer("MACHINE_ARMNT");
    #####: 2145:  declare_integer("MACHINE_ARM64");
    #####: 2146:  declare_integer("MACHINE_EBC");
    #####: 2147:  declare_integer("MACHINE_I386");
    #####: 2148:  declare_integer("MACHINE_IA64");
    #####: 2149:  declare_integer("MACHINE_M32R");
    #####: 2150:  declare_integer("MACHINE_MIPS16");
    #####: 2151:  declare_integer("MACHINE_MIPSFPU");
    #####: 2152:  declare_integer("MACHINE_MIPSFPU16");
    #####: 2153:  declare_integer("MACHINE_POWERPC");
    #####: 2154:  declare_integer("MACHINE_POWERPCFP");
    #####: 2155:  declare_integer("MACHINE_R4000");
    #####: 2156:  declare_integer("MACHINE_SH3");
    #####: 2157:  declare_integer("MACHINE_SH3DSP");
    #####: 2158:  declare_integer("MACHINE_SH4");
    #####: 2159:  declare_integer("MACHINE_SH5");
    #####: 2160:  declare_integer("MACHINE_THUMB");
    #####: 2161:  declare_integer("MACHINE_WCEMIPSV2");
        -: 2162:
    #####: 2163:  declare_integer("SUBSYSTEM_UNKNOWN");
    #####: 2164:  declare_integer("SUBSYSTEM_NATIVE");
    #####: 2165:  declare_integer("SUBSYSTEM_WINDOWS_GUI");
    #####: 2166:  declare_integer("SUBSYSTEM_WINDOWS_CUI");
    #####: 2167:  declare_integer("SUBSYSTEM_OS2_CUI");
    #####: 2168:  declare_integer("SUBSYSTEM_POSIX_CUI");
    #####: 2169:  declare_integer("SUBSYSTEM_NATIVE_WINDOWS");
    #####: 2170:  declare_integer("SUBSYSTEM_WINDOWS_CE_GUI");
    #####: 2171:  declare_integer("SUBSYSTEM_EFI_APPLICATION");
    #####: 2172:  declare_integer("SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER");
    #####: 2173:  declare_integer("SUBSYSTEM_EFI_RUNTIME_DRIVER");
    #####: 2174:  declare_integer("SUBSYSTEM_XBOX");
    #####: 2175:  declare_integer("SUBSYSTEM_WINDOWS_BOOT_APPLICATION");
        -: 2176:
    #####: 2177:  declare_integer("DYNAMIC_BASE");
    #####: 2178:  declare_integer("FORCE_INTEGRITY");
    #####: 2179:  declare_integer("NX_COMPAT");
    #####: 2180:  declare_integer("NO_ISOLATION");
    #####: 2181:  declare_integer("NO_SEH");
    #####: 2182:  declare_integer("NO_BIND");
    #####: 2183:  declare_integer("WDM_DRIVER");
    #####: 2184:  declare_integer("TERMINAL_SERVER_AWARE");
        -: 2185:
    #####: 2186:  declare_integer("RELOCS_STRIPPED");
    #####: 2187:  declare_integer("EXECUTABLE_IMAGE");
    #####: 2188:  declare_integer("LINE_NUMS_STRIPPED");
    #####: 2189:  declare_integer("LOCAL_SYMS_STRIPPED");
    #####: 2190:  declare_integer("AGGRESIVE_WS_TRIM");
    #####: 2191:  declare_integer("LARGE_ADDRESS_AWARE");
    #####: 2192:  declare_integer("BYTES_REVERSED_LO");
    #####: 2193:  declare_integer("MACHINE_32BIT");
    #####: 2194:  declare_integer("DEBUG_STRIPPED");
    #####: 2195:  declare_integer("REMOVABLE_RUN_FROM_SWAP");
    #####: 2196:  declare_integer("NET_RUN_FROM_SWAP");
    #####: 2197:  declare_integer("SYSTEM");
    #####: 2198:  declare_integer("DLL");
    #####: 2199:  declare_integer("UP_SYSTEM_ONLY");
    #####: 2200:  declare_integer("BYTES_REVERSED_HI");
        -: 2201:
    #####: 2202:  declare_integer("SECTION_CNT_CODE");
    #####: 2203:  declare_integer("SECTION_CNT_INITIALIZED_DATA");
    #####: 2204:  declare_integer("SECTION_CNT_UNINITIALIZED_DATA");
    #####: 2205:  declare_integer("SECTION_GPREL");
    #####: 2206:  declare_integer("SECTION_MEM_16BIT");
    #####: 2207:  declare_integer("SECTION_LNK_NRELOC_OVFL");
    #####: 2208:  declare_integer("SECTION_MEM_DISCARDABLE");
    #####: 2209:  declare_integer("SECTION_MEM_NOT_CACHED");
    #####: 2210:  declare_integer("SECTION_MEM_NOT_PAGED");
    #####: 2211:  declare_integer("SECTION_MEM_SHARED");
    #####: 2212:  declare_integer("SECTION_MEM_EXECUTE");
    #####: 2213:  declare_integer("SECTION_MEM_READ");
    #####: 2214:  declare_integer("SECTION_MEM_WRITE");
        -: 2215:
    #####: 2216:  declare_integer("RESOURCE_TYPE_CURSOR");
    #####: 2217:  declare_integer("RESOURCE_TYPE_BITMAP");
    #####: 2218:  declare_integer("RESOURCE_TYPE_ICON");
    #####: 2219:  declare_integer("RESOURCE_TYPE_MENU");
    #####: 2220:  declare_integer("RESOURCE_TYPE_DIALOG");
    #####: 2221:  declare_integer("RESOURCE_TYPE_STRING");
    #####: 2222:  declare_integer("RESOURCE_TYPE_FONTDIR");
    #####: 2223:  declare_integer("RESOURCE_TYPE_FONT");
    #####: 2224:  declare_integer("RESOURCE_TYPE_ACCELERATOR");
    #####: 2225:  declare_integer("RESOURCE_TYPE_RCDATA");
    #####: 2226:  declare_integer("RESOURCE_TYPE_MESSAGETABLE");
    #####: 2227:  declare_integer("RESOURCE_TYPE_GROUP_CURSOR");
    #####: 2228:  declare_integer("RESOURCE_TYPE_GROUP_ICON");
    #####: 2229:  declare_integer("RESOURCE_TYPE_VERSION");
    #####: 2230:  declare_integer("RESOURCE_TYPE_DLGINCLUDE");
    #####: 2231:  declare_integer("RESOURCE_TYPE_PLUGPLAY");
    #####: 2232:  declare_integer("RESOURCE_TYPE_VXD");
    #####: 2233:  declare_integer("RESOURCE_TYPE_ANICURSOR");
    #####: 2234:  declare_integer("RESOURCE_TYPE_ANIICON");
    #####: 2235:  declare_integer("RESOURCE_TYPE_HTML");
    #####: 2236:  declare_integer("RESOURCE_TYPE_MANIFEST");
        -: 2237:
    #####: 2238:  declare_integer("machine");
    #####: 2239:  declare_integer("number_of_sections");
    #####: 2240:  declare_integer("timestamp");
    #####: 2241:  declare_integer("characteristics");
        -: 2242:
    #####: 2243:  declare_integer("entry_point");
    #####: 2244:  declare_integer("image_base");
    #####: 2245:  declare_integer("number_of_rva_and_sizes");
        -: 2246:
    #####: 2247:  declare_string_dictionary("version_info");
        -: 2248:
    #####: 2249:  begin_struct("linker_version");
    #####: 2250:    declare_integer("major");
    #####: 2251:    declare_integer("minor");
    #####: 2252:  end_struct("linker_version");
        -: 2253:
    #####: 2254:  begin_struct("os_version");
    #####: 2255:    declare_integer("major");
    #####: 2256:    declare_integer("minor");
    #####: 2257:  end_struct("os_version");
        -: 2258:
    #####: 2259:  begin_struct("image_version");
    #####: 2260:    declare_integer("major");
    #####: 2261:    declare_integer("minor");
    #####: 2262:  end_struct("image_version");
        -: 2263:
    #####: 2264:  begin_struct("subsystem_version");
    #####: 2265:    declare_integer("major");
    #####: 2266:    declare_integer("minor");
    #####: 2267:  end_struct("subsystem_version");
        -: 2268:
    #####: 2269:  declare_integer("checksum");
    #####: 2270:  declare_function("calculate_checksum", "", "i", calculate_checksum);
    #####: 2271:  declare_integer("subsystem");
        -: 2272:
    #####: 2273:  declare_integer("dll_characteristics");
        -: 2274:
    #####: 2275:  begin_struct_array("sections");
    #####: 2276:    declare_string("name");
    #####: 2277:    declare_integer("characteristics");
    #####: 2278:    declare_integer("virtual_address");
    #####: 2279:    declare_integer("virtual_size");
    #####: 2280:    declare_integer("raw_data_offset");
    #####: 2281:    declare_integer("raw_data_size");
    #####: 2282:  end_struct_array("sections");
        -: 2283:
    #####: 2284:  begin_struct("overlay");
    #####: 2285:    declare_integer("offset");
    #####: 2286:    declare_integer("size");
    #####: 2287:  end_struct("overlay");
        -: 2288:
    #####: 2289:  begin_struct("rich_signature");
    #####: 2290:    declare_integer("offset");
    #####: 2291:    declare_integer("length");
    #####: 2292:    declare_integer("key");
    #####: 2293:    declare_string("raw_data");
    #####: 2294:    declare_string("clear_data");
    #####: 2295:    declare_function("version", "i", "i", rich_version);
    #####: 2296:    declare_function("version", "ii", "i", rich_version_toolid);
    #####: 2297:    declare_function("toolid", "i", "i", rich_toolid);
    #####: 2298:    declare_function("toolid", "ii", "i", rich_toolid_version);
    #####: 2299:  end_struct("rich_signature");
        -: 2300:
        -: 2301:  #if defined(HAVE_LIBCRYPTO) || \
        -: 2302:      defined(HAVE_WINCRYPT_H) || \
        -: 2303:      defined(HAVE_COMMONCRYPTO_COMMONCRYPTO_H)
    #####: 2304:  declare_function("imphash", "", "s", imphash);
        -: 2305:  #endif
        -: 2306:
    #####: 2307:  declare_function("section_index", "s", "i", section_index_name);
    #####: 2308:  declare_function("section_index", "i", "i", section_index_addr);
    #####: 2309:  declare_function("exports", "s", "i", exports);
    #####: 2310:  declare_function("exports", "r", "i", exports_regexp);
    #####: 2311:  declare_function("exports", "i", "i", exports_ordinal);
    #####: 2312:  declare_function("imports", "ss", "i", imports);
    #####: 2313:  declare_function("imports", "si", "i", imports_ordinal);
    #####: 2314:  declare_function("imports", "s", "i", imports_dll);
    #####: 2315:  declare_function("locale", "i", "i", locale);
    #####: 2316:  declare_function("language", "i", "i", language);
    #####: 2317:  declare_function("is_dll", "", "i", is_dll);
    #####: 2318:  declare_function("is_32bit", "", "i", is_32bit);
    #####: 2319:  declare_function("is_64bit", "", "i", is_64bit);
        -: 2320:
    #####: 2321:  declare_integer("number_of_imports");
    #####: 2322:  declare_integer("number_of_exports");
        -: 2323:
    #####: 2324:  declare_integer("resource_timestamp");
        -: 2325:
    #####: 2326:  begin_struct("resource_version");
    #####: 2327:    declare_integer("major");
    #####: 2328:    declare_integer("minor");
    #####: 2329:  end_struct("resource_version");
        -: 2330:
    #####: 2331:  begin_struct_array("resources");
    #####: 2332:    declare_integer("offset");
    #####: 2333:    declare_integer("length");
    #####: 2334:    declare_integer("type");
    #####: 2335:    declare_integer("id");
    #####: 2336:    declare_integer("language");
    #####: 2337:    declare_string("type_string");
    #####: 2338:    declare_string("name_string");
    #####: 2339:    declare_string("language_string");
    #####: 2340:  end_struct_array("resources");
        -: 2341:
    #####: 2342:  declare_integer("number_of_resources");
        -: 2343:
        -: 2344:  #if defined(HAVE_LIBCRYPTO)
    #####: 2345:  begin_struct_array("signatures");
    #####: 2346:    declare_string("issuer");
    #####: 2347:    declare_string("subject");
    #####: 2348:    declare_integer("version");
    #####: 2349:    declare_string("algorithm");
    #####: 2350:    declare_string("serial");
    #####: 2351:    declare_integer("not_before");
    #####: 2352:    declare_integer("not_after");
    #####: 2353:    declare_function("valid_on", "i", "i", valid_on);
    #####: 2354:  end_struct_array("signatures");
        -: 2355:
    #####: 2356:  declare_integer("number_of_signatures");
        -: 2357:  #endif
        -: 2358:
    #####: 2359:  declare_function("rva_to_offset", "i", "i", rva_to_offset);
        -: 2360:
    #####: 2361:end_declarations;
        -: 2362:
        -: 2363:
        5: 2364:int module_initialize(
        -: 2365:    YR_MODULE* module)
        -: 2366:{
        5: 2367:  return ERROR_SUCCESS;
        -: 2368:}
        -: 2369:
        -: 2370:
        4: 2371:int module_finalize(
        -: 2372:    YR_MODULE* module)
        -: 2373:{
        4: 2374:  return ERROR_SUCCESS;
        -: 2375:}
        -: 2376:
        -: 2377:
    #####: 2378:int module_load(
        -: 2379:    YR_SCAN_CONTEXT* context,
        -: 2380:    YR_OBJECT* module_object,
        -: 2381:    void* module_data,
        -: 2382:    size_t module_data_size)
        -: 2383:{
        -: 2384:  YR_MEMORY_BLOCK* block;
    #####: 2385:  YR_MEMORY_BLOCK_ITERATOR* iterator = context->iterator;
        -: 2386:
        -: 2387:  PIMAGE_NT_HEADERS32 pe_header;
    #####: 2388:  const uint8_t* block_data = NULL;
    #####: 2389:  PE* pe = NULL;
        -: 2390:
    #####: 2391:  set_integer(
        -: 2392:      IMAGE_FILE_MACHINE_UNKNOWN, module_object,
        -: 2393:      "MACHINE_UNKNOWN");
    #####: 2394:  set_integer(
        -: 2395:      IMAGE_FILE_MACHINE_AM33, module_object,
        -: 2396:      "MACHINE_AM33");
    #####: 2397:  set_integer(
        -: 2398:      IMAGE_FILE_MACHINE_AMD64, module_object,
        -: 2399:      "MACHINE_AMD64");
    #####: 2400:  set_integer(
        -: 2401:      IMAGE_FILE_MACHINE_ARM, module_object,
        -: 2402:      "MACHINE_ARM");
    #####: 2403:  set_integer(
        -: 2404:      IMAGE_FILE_MACHINE_ARMNT, module_object,
        -: 2405:      "MACHINE_ARMNT");
    #####: 2406:  set_integer(
        -: 2407:      IMAGE_FILE_MACHINE_ARM64, module_object,
        -: 2408:      "MACHINE_ARM64");
    #####: 2409:  set_integer(
        -: 2410:      IMAGE_FILE_MACHINE_EBC, module_object,
        -: 2411:      "MACHINE_EBC");
    #####: 2412:  set_integer(
        -: 2413:      IMAGE_FILE_MACHINE_I386, module_object,
        -: 2414:      "MACHINE_I386");
    #####: 2415:  set_integer(
        -: 2416:      IMAGE_FILE_MACHINE_IA64, module_object,
        -: 2417:      "MACHINE_IA64");
    #####: 2418:  set_integer(
        -: 2419:      IMAGE_FILE_MACHINE_M32R, module_object,
        -: 2420:      "MACHINE_M32R");
    #####: 2421:  set_integer(
        -: 2422:      IMAGE_FILE_MACHINE_MIPS16, module_object,
        -: 2423:      "MACHINE_MIPS16");
    #####: 2424:  set_integer(
        -: 2425:      IMAGE_FILE_MACHINE_MIPSFPU, module_object,
        -: 2426:      "MACHINE_MIPSFPU");
    #####: 2427:  set_integer(
        -: 2428:      IMAGE_FILE_MACHINE_MIPSFPU16, module_object,
        -: 2429:      "MACHINE_MIPSFPU16");
    #####: 2430:  set_integer(
        -: 2431:      IMAGE_FILE_MACHINE_POWERPC, module_object,
        -: 2432:      "MACHINE_POWERPC");
    #####: 2433:  set_integer(
        -: 2434:      IMAGE_FILE_MACHINE_POWERPCFP, module_object,
        -: 2435:      "MACHINE_POWERPCFP");
    #####: 2436:  set_integer(
        -: 2437:      IMAGE_FILE_MACHINE_R4000, module_object,
        -: 2438:      "MACHINE_R4000");
    #####: 2439:  set_integer(
        -: 2440:      IMAGE_FILE_MACHINE_SH3, module_object,
        -: 2441:      "MACHINE_SH3");
    #####: 2442:  set_integer(
        -: 2443:      IMAGE_FILE_MACHINE_SH3DSP, module_object,
        -: 2444:      "MACHINE_SH3DSP");
    #####: 2445:  set_integer(
        -: 2446:      IMAGE_FILE_MACHINE_SH4, module_object,
        -: 2447:      "MACHINE_SH4");
    #####: 2448:  set_integer(
        -: 2449:      IMAGE_FILE_MACHINE_SH5, module_object,
        -: 2450:      "MACHINE_SH5");
    #####: 2451:  set_integer(
        -: 2452:      IMAGE_FILE_MACHINE_THUMB, module_object,
        -: 2453:      "MACHINE_THUMB");
    #####: 2454:  set_integer(
        -: 2455:      IMAGE_FILE_MACHINE_WCEMIPSV2, module_object,
        -: 2456:      "MACHINE_WCEMIPSV2");
        -: 2457:
    #####: 2458:  set_integer(
        -: 2459:      IMAGE_SUBSYSTEM_UNKNOWN, module_object,
        -: 2460:      "SUBSYSTEM_UNKNOWN");
    #####: 2461:  set_integer(
        -: 2462:      IMAGE_SUBSYSTEM_NATIVE, module_object,
        -: 2463:      "SUBSYSTEM_NATIVE");
    #####: 2464:  set_integer(
        -: 2465:      IMAGE_SUBSYSTEM_WINDOWS_GUI, module_object,
        -: 2466:      "SUBSYSTEM_WINDOWS_GUI");
    #####: 2467:  set_integer(
        -: 2468:      IMAGE_SUBSYSTEM_WINDOWS_CUI, module_object,
        -: 2469:      "SUBSYSTEM_WINDOWS_CUI");
    #####: 2470:  set_integer(
        -: 2471:      IMAGE_SUBSYSTEM_OS2_CUI, module_object,
        -: 2472:      "SUBSYSTEM_OS2_CUI");
    #####: 2473:  set_integer(
        -: 2474:      IMAGE_SUBSYSTEM_POSIX_CUI, module_object,
        -: 2475:      "SUBSYSTEM_POSIX_CUI");
    #####: 2476:  set_integer(
        -: 2477:      IMAGE_SUBSYSTEM_NATIVE_WINDOWS, module_object,
        -: 2478:      "SUBSYSTEM_NATIVE_WINDOWS");
    #####: 2479:  set_integer(
        -: 2480:      IMAGE_SUBSYSTEM_WINDOWS_CE_GUI, module_object,
        -: 2481:      "SUBSYSTEM_WINDOWS_CE_GUI");
    #####: 2482:  set_integer(
        -: 2483:      IMAGE_SUBSYSTEM_EFI_APPLICATION, module_object,
        -: 2484:      "SUBSYSTEM_EFI_APPLICATION");
    #####: 2485:  set_integer(
        -: 2486:      IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER, module_object,
        -: 2487:      "SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER");
    #####: 2488:  set_integer(
        -: 2489:      IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER, module_object,
        -: 2490:      "SUBSYSTEM_EFI_RUNTIME_DRIVER");
    #####: 2491:  set_integer(
        -: 2492:      IMAGE_SUBSYSTEM_XBOX, module_object,
        -: 2493:      "SUBSYSTEM_XBOX");
    #####: 2494:  set_integer(
        -: 2495:      IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION, module_object,
        -: 2496:      "SUBSYSTEM_WINDOWS_BOOT_APPLICATION");
        -: 2497:
    #####: 2498:  set_integer(
        -: 2499:      IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE, module_object,
        -: 2500:      "DYNAMIC_BASE");
    #####: 2501:  set_integer(
        -: 2502:      IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY, module_object,
        -: 2503:      "FORCE_INTEGRITY");
    #####: 2504:  set_integer(
        -: 2505:      IMAGE_DLLCHARACTERISTICS_NX_COMPAT, module_object,
        -: 2506:      "NX_COMPAT");
    #####: 2507:  set_integer(
        -: 2508:      IMAGE_DLLCHARACTERISTICS_NO_ISOLATION, module_object,
        -: 2509:      "NO_ISOLATION");
    #####: 2510:  set_integer(
        -: 2511:      IMAGE_DLLCHARACTERISTICS_NO_SEH, module_object,
        -: 2512:      "NO_SEH");
    #####: 2513:  set_integer(
        -: 2514:      IMAGE_DLLCHARACTERISTICS_NO_BIND, module_object,
        -: 2515:      "NO_BIND");
    #####: 2516:  set_integer(
        -: 2517:      IMAGE_DLLCHARACTERISTICS_WDM_DRIVER, module_object,
        -: 2518:      "WDM_DRIVER");
    #####: 2519:  set_integer(
        -: 2520:      IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE, module_object,
        -: 2521:      "TERMINAL_SERVER_AWARE");
        -: 2522:
    #####: 2523:  set_integer(
        -: 2524:      IMAGE_FILE_RELOCS_STRIPPED, module_object,
        -: 2525:      "RELOCS_STRIPPED");
    #####: 2526:  set_integer(
        -: 2527:      IMAGE_FILE_EXECUTABLE_IMAGE, module_object,
        -: 2528:      "EXECUTABLE_IMAGE");
    #####: 2529:  set_integer(
        -: 2530:      IMAGE_FILE_LINE_NUMS_STRIPPED, module_object,
        -: 2531:      "LINE_NUMS_STRIPPED");
    #####: 2532:  set_integer(
        -: 2533:      IMAGE_FILE_LOCAL_SYMS_STRIPPED, module_object,
        -: 2534:      "LOCAL_SYMS_STRIPPED");
    #####: 2535:  set_integer(
        -: 2536:      IMAGE_FILE_AGGRESIVE_WS_TRIM, module_object,
        -: 2537:      "AGGRESIVE_WS_TRIM");
    #####: 2538:  set_integer(
        -: 2539:      IMAGE_FILE_LARGE_ADDRESS_AWARE, module_object,
        -: 2540:      "LARGE_ADDRESS_AWARE");
    #####: 2541:  set_integer(
        -: 2542:      IMAGE_FILE_BYTES_REVERSED_LO, module_object,
        -: 2543:      "BYTES_REVERSED_LO");
    #####: 2544:  set_integer(
        -: 2545:      IMAGE_FILE_32BIT_MACHINE, module_object,
        -: 2546:      "MACHINE_32BIT");
    #####: 2547:  set_integer(
        -: 2548:      IMAGE_FILE_DEBUG_STRIPPED, module_object,
        -: 2549:      "DEBUG_STRIPPED");
    #####: 2550:  set_integer(
        -: 2551:      IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP, module_object,
        -: 2552:      "REMOVABLE_RUN_FROM_SWAP");
    #####: 2553:  set_integer(
        -: 2554:      IMAGE_FILE_NET_RUN_FROM_SWAP, module_object,
        -: 2555:      "NET_RUN_FROM_SWAP");
    #####: 2556:  set_integer(
        -: 2557:      IMAGE_FILE_SYSTEM, module_object,
        -: 2558:      "SYSTEM");
    #####: 2559:  set_integer(
        -: 2560:      IMAGE_FILE_DLL, module_object,
        -: 2561:      "DLL");
    #####: 2562:  set_integer(
        -: 2563:      IMAGE_FILE_UP_SYSTEM_ONLY, module_object,
        -: 2564:      "UP_SYSTEM_ONLY");
    #####: 2565:  set_integer(
        -: 2566:      IMAGE_FILE_BYTES_REVERSED_HI, module_object,
        -: 2567:      "BYTES_REVERSED_HI");
        -: 2568:
    #####: 2569:  set_integer(
        -: 2570:      IMAGE_SCN_CNT_CODE, module_object,
        -: 2571:      "SECTION_CNT_CODE");
    #####: 2572:  set_integer(
        -: 2573:      IMAGE_SCN_CNT_INITIALIZED_DATA, module_object,
        -: 2574:      "SECTION_CNT_INITIALIZED_DATA");
    #####: 2575:  set_integer(
        -: 2576:      IMAGE_SCN_CNT_UNINITIALIZED_DATA, module_object,
        -: 2577:      "SECTION_CNT_UNINITIALIZED_DATA");
    #####: 2578:  set_integer(
        -: 2579:      IMAGE_SCN_GPREL, module_object,
        -: 2580:      "SECTION_GPREL");
    #####: 2581:  set_integer(
        -: 2582:      IMAGE_SCN_MEM_16BIT, module_object,
        -: 2583:      "SECTION_MEM_16BIT");
    #####: 2584:  set_integer(
        -: 2585:      IMAGE_SCN_LNK_NRELOC_OVFL, module_object,
        -: 2586:      "SECTION_LNK_NRELOC_OVFL");
    #####: 2587:  set_integer(
        -: 2588:      IMAGE_SCN_MEM_DISCARDABLE, module_object,
        -: 2589:      "SECTION_MEM_DISCARDABLE");
    #####: 2590:  set_integer(
        -: 2591:      IMAGE_SCN_MEM_NOT_CACHED, module_object,
        -: 2592:      "SECTION_MEM_NOT_CACHED");
    #####: 2593:  set_integer(
        -: 2594:      IMAGE_SCN_MEM_NOT_PAGED, module_object,
        -: 2595:      "SECTION_MEM_NOT_PAGED");
    #####: 2596:  set_integer(
        -: 2597:      IMAGE_SCN_MEM_SHARED, module_object,
        -: 2598:      "SECTION_MEM_SHARED");
    #####: 2599:  set_integer(
        -: 2600:      IMAGE_SCN_MEM_EXECUTE, module_object,
        -: 2601:      "SECTION_MEM_EXECUTE");
    #####: 2602:  set_integer(
        -: 2603:      IMAGE_SCN_MEM_READ, module_object,
        -: 2604:      "SECTION_MEM_READ");
    #####: 2605:  set_integer(
        -: 2606:      IMAGE_SCN_MEM_WRITE, module_object,
        -: 2607:      "SECTION_MEM_WRITE");
        -: 2608:
    #####: 2609:  set_integer(
        -: 2610:      RESOURCE_TYPE_CURSOR, module_object,
        -: 2611:      "RESOURCE_TYPE_CURSOR");
    #####: 2612:  set_integer(
        -: 2613:      RESOURCE_TYPE_BITMAP, module_object,
        -: 2614:      "RESOURCE_TYPE_BITMAP");
    #####: 2615:  set_integer(
        -: 2616:      RESOURCE_TYPE_ICON, module_object,
        -: 2617:      "RESOURCE_TYPE_ICON");
    #####: 2618:  set_integer(
        -: 2619:      RESOURCE_TYPE_MENU, module_object,
        -: 2620:      "RESOURCE_TYPE_MENU");
    #####: 2621:  set_integer(
        -: 2622:      RESOURCE_TYPE_DIALOG, module_object,
        -: 2623:      "RESOURCE_TYPE_DIALOG");
    #####: 2624:  set_integer(
        -: 2625:      RESOURCE_TYPE_STRING, module_object,
        -: 2626:      "RESOURCE_TYPE_STRING");
    #####: 2627:  set_integer(
        -: 2628:      RESOURCE_TYPE_FONTDIR, module_object,
        -: 2629:      "RESOURCE_TYPE_FONTDIR");
    #####: 2630:  set_integer(
        -: 2631:      RESOURCE_TYPE_FONT, module_object,
        -: 2632:      "RESOURCE_TYPE_FONT");
    #####: 2633:  set_integer(
        -: 2634:      RESOURCE_TYPE_ACCELERATOR, module_object,
        -: 2635:      "RESOURCE_TYPE_ACCELERATOR");
    #####: 2636:  set_integer(
        -: 2637:      RESOURCE_TYPE_RCDATA, module_object,
        -: 2638:      "RESOURCE_TYPE_RCDATA");
    #####: 2639:  set_integer(
        -: 2640:      RESOURCE_TYPE_MESSAGETABLE, module_object,
        -: 2641:      "RESOURCE_TYPE_MESSAGETABLE");
    #####: 2642:  set_integer(
        -: 2643:      RESOURCE_TYPE_GROUP_CURSOR, module_object,
        -: 2644:      "RESOURCE_TYPE_GROUP_CURSOR");
    #####: 2645:  set_integer(
        -: 2646:      RESOURCE_TYPE_GROUP_ICON, module_object,
        -: 2647:      "RESOURCE_TYPE_GROUP_ICON");
    #####: 2648:  set_integer(
        -: 2649:      RESOURCE_TYPE_VERSION, module_object,
        -: 2650:      "RESOURCE_TYPE_VERSION");
    #####: 2651:  set_integer(
        -: 2652:      RESOURCE_TYPE_DLGINCLUDE, module_object,
        -: 2653:      "RESOURCE_TYPE_DLGINCLUDE");
    #####: 2654:  set_integer(
        -: 2655:      RESOURCE_TYPE_PLUGPLAY, module_object,
        -: 2656:      "RESOURCE_TYPE_PLUGPLAY");
    #####: 2657:  set_integer(
        -: 2658:      RESOURCE_TYPE_VXD, module_object,
        -: 2659:      "RESOURCE_TYPE_VXD");
    #####: 2660:  set_integer(
        -: 2661:      RESOURCE_TYPE_ANICURSOR, module_object,
        -: 2662:      "RESOURCE_TYPE_ANICURSOR");
    #####: 2663:  set_integer(
        -: 2664:      RESOURCE_TYPE_ANIICON, module_object,
        -: 2665:      "RESOURCE_TYPE_ANIICON");
    #####: 2666:  set_integer(
        -: 2667:      RESOURCE_TYPE_HTML, module_object,
        -: 2668:      "RESOURCE_TYPE_HTML");
    #####: 2669:  set_integer(
        -: 2670:      RESOURCE_TYPE_MANIFEST, module_object,
        -: 2671:      "RESOURCE_TYPE_MANIFEST");
        -: 2672:
    #####: 2673:  foreach_memory_block(iterator, block)
        -: 2674:  {
    #####: 2675:    block_data = block->fetch_data(block);
        -: 2676:
    #####: 2677:    if (block_data == NULL)
    #####: 2678:      continue;
        -: 2679:
    #####: 2680:    pe_header = pe_get_header(block_data, block->size);
        -: 2681:
    #####: 2682:    if (pe_header != NULL)
        -: 2683:    {
        -: 2684:      // Ignore DLLs while scanning a process
        -: 2685:
    #####: 2686:      if (!(context->flags & SCAN_FLAGS_PROCESS_MEMORY) ||
    #####: 2687:          !(yr_le16toh(pe_header->FileHeader.Characteristics) & IMAGE_FILE_DLL))
        -: 2688:      {
    #####: 2689:        pe = (PE*) yr_malloc(sizeof(PE));
        -: 2690:
    #####: 2691:        if (pe == NULL)
    #####: 2692:          return ERROR_INSUFFICIENT_MEMORY;
        -: 2693:
    #####: 2694:        pe->data = block_data;
    #####: 2695:        pe->data_size = block->size;
    #####: 2696:        pe->header = pe_header;
    #####: 2697:        pe->object = module_object;
    #####: 2698:        pe->resources = 0;
        -: 2699:
    #####: 2700:        module_object->data = pe;
        -: 2701:
    #####: 2702:        pe_parse_header(pe, block->base, context->flags);
    #####: 2703:        pe_parse_rich_signature(pe, block->base);
        -: 2704:
        -: 2705:        #if defined(HAVE_LIBCRYPTO)
    #####: 2706:        pe_parse_certificates(pe);
        -: 2707:        #endif
        -: 2708:
    #####: 2709:        pe->imported_dlls = pe_parse_imports(pe);
    #####: 2710:        pe->exported_functions = pe_parse_exports(pe);
        -: 2711:
    #####: 2712:        break;
        -: 2713:      }
        -: 2714:    }
        -: 2715:  }
        -: 2716:
    #####: 2717:  return ERROR_SUCCESS;
        -: 2718:}
        -: 2719:
        -: 2720:
    #####: 2721:int module_unload(
        -: 2722:    YR_OBJECT* module_object)
        -: 2723:{
    #####: 2724:  IMPORTED_DLL* dll = NULL;
    #####: 2725:  IMPORTED_DLL* next_dll = NULL;
    #####: 2726:  IMPORT_FUNCTION* func = NULL;
    #####: 2727:  IMPORT_FUNCTION* next_func = NULL;
    #####: 2728:  int i = 0;
        -: 2729:
    #####: 2730:  PE* pe = (PE *) module_object->data;
        -: 2731:
    #####: 2732:  if (pe == NULL)
    #####: 2733:    return ERROR_SUCCESS;
        -: 2734:
    #####: 2735:  dll = pe->imported_dlls;
        -: 2736:
    #####: 2737:  while (dll)
        -: 2738:  {
    #####: 2739:    if (dll->name)
    #####: 2740:      yr_free(dll->name);
        -: 2741:
    #####: 2742:    func = dll->functions;
        -: 2743:
    #####: 2744:    while (func)
        -: 2745:    {
    #####: 2746:      if (func->name)
    #####: 2747:        yr_free(func->name);
        -: 2748:
    #####: 2749:      next_func = func->next;
    #####: 2750:      yr_free(func);
    #####: 2751:      func = next_func;
        -: 2752:    }
        -: 2753:
    #####: 2754:    next_dll = dll->next;
    #####: 2755:    yr_free(dll);
    #####: 2756:    dll = next_dll;
        -: 2757:  }
        -: 2758:
    #####: 2759:  if (pe->exported_functions)
        -: 2760:  {
    #####: 2761:    for (i = 0; i < pe->exported_functions->number_of_exports; i++)
        -: 2762:    {
    #####: 2763:      if (pe->exported_functions->functions[i].name)
    #####: 2764:        yr_free(pe->exported_functions->functions[i].name);
        -: 2765:    }
        -: 2766:
    #####: 2767:    yr_free(pe->exported_functions->functions);
    #####: 2768:    yr_free(pe->exported_functions);
        -: 2769:  }
        -: 2770:
    #####: 2771:  yr_free(pe);
        -: 2772:
    #####: 2773:  return ERROR_SUCCESS;
        -: 2774:}
