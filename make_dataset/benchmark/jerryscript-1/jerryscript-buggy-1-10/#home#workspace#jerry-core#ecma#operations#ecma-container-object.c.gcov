        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-container-object.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:#include "jcontext.h"
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtins.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-exceptions.h"
        -:   21:#include "ecma-function-object.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-helpers.h"
        -:   24:#include "ecma-iterator-object.h"
        -:   25:#include "ecma-container-object.h"
        -:   26:#include "ecma-property-hashmap.h"
        -:   27:#include "ecma-objects.h"
        -:   28:
        -:   29:#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup \addtogroup ecmamaphelpers ECMA builtin Map/Set helper functions
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:/**
        -:   39: * Create a new internal buffer.
        -:   40: *
        -:   41: * Note:
        -:   42: *   The first element of the collection tracks the size of the buffer.
        -:   43: *   ECMA_VALUE_EMPTY values are not calculated into the size.
        -:   44: *
        -:   45: * @return pointer to the internal buffer
        -:   46: */
        -:   47:static inline ecma_collection_t *
    #####:   48:ecma_op_create_internal_buffer (void)
        -:   49:{
    #####:   50:  ecma_collection_t *collection_p = ecma_new_collection ();
    #####:   51:  ecma_collection_push_back (collection_p, (ecma_value_t) 0);
        -:   52:
    #####:   53:  return collection_p;
        -:   54:} /* ecma_op_create_internal_buffer */
        -:   55:
        -:   56:/**
        -:   57: * Append values to the internal buffer.
        -:   58: */
        -:   59:static void
    #####:   60:ecma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */
        -:   61:                                ecma_value_t key_arg, /**< key argument */
        -:   62:                                ecma_value_t value_arg, /**< value argument */
        -:   63:                                lit_magic_string_id_t lit_id) /**< class id */
        -:   64:{
    #####:   65:  JERRY_ASSERT (container_p != NULL);
        -:   66:
    #####:   67:  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));
        -:   68:
    #####:   69:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:   70:  {
    #####:   71:    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));
        -:   72:  }
        -:   73:
    #####:   74:  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);
    #####:   75:} /* ecma_op_internal_buffer_append */
        -:   76:
        -:   77:/**
        -:   78: * Update the value of a given entry.
        -:   79: */
        -:   80:static inline void
    #####:   81:ecma_op_internal_buffer_update (ecma_value_t *entry_p, /**< entry pointer */
        -:   82:                                ecma_value_t value_arg, /**< value argument */
        -:   83:                                lit_magic_string_id_t lit_id) /**< class id */
        -:   84:{
    #####:   85:  JERRY_ASSERT (entry_p != NULL);
        -:   86:
    #####:   87:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:   88:  {
    #####:   89:    ecma_free_value_if_not_object (((ecma_container_pair_t *) entry_p)->value);
        -:   90:
    #####:   91:    ((ecma_container_pair_t *) entry_p)->value = ecma_copy_value_if_not_object (value_arg);
        -:   92:  }
    #####:   93:} /* ecma_op_internal_buffer_update */
        -:   94:
        -:   95:/**
        -:   96: * Delete element from the internal buffer.
        -:   97: */
        -:   98:static void
    #####:   99:ecma_op_internal_buffer_delete (ecma_collection_t *container_p, /**< internal container pointer */
        -:  100:                                ecma_container_pair_t *entry_p, /**< entry pointer */
        -:  101:                                lit_magic_string_id_t lit_id) /**< class id */
        -:  102:{
    #####:  103:  JERRY_ASSERT (container_p != NULL);
    #####:  104:  JERRY_ASSERT (entry_p != NULL);
        -:  105:
    #####:  106:  ecma_free_value_if_not_object (entry_p->key);
    #####:  107:  entry_p->key = ECMA_VALUE_EMPTY;
        -:  108:
    #####:  109:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  110:  {
    #####:  111:    ecma_free_value_if_not_object (entry_p->value);
    #####:  112:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  113:  }
        -:  114:
    #####:  115:  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) - 1);
    #####:  116:} /* ecma_op_internal_buffer_delete */
        -:  117:
        -:  118:/**
        -:  119: * Find an entry in the collection.
        -:  120: *
        -:  121: * @return pointer to the appropriate entry.
        -:  122: */
        -:  123:static ecma_value_t *
    #####:  124:ecma_op_internal_buffer_find (ecma_collection_t *container_p, /**< internal container pointer */
        -:  125:                              ecma_value_t key_arg, /**< key argument */
        -:  126:                              lit_magic_string_id_t lit_id) /**< class id */
        -:  127:{
    #####:  128:  JERRY_ASSERT (container_p != NULL);
        -:  129:
    #####:  130:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
    #####:  131:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  132:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  133:
    #####:  134:  for (uint32_t i = 0; i < entry_count; i += entry_size)
        -:  135:  {
    #####:  136:    ecma_value_t *entry_p = start_p + i;
        -:  137:
    #####:  138:    if (ecma_op_same_value_zero (*entry_p, key_arg))
        -:  139:    {
    #####:  140:      return entry_p;
        -:  141:    }
        -:  142:  }
        -:  143:
    #####:  144:  return NULL;
        -:  145:} /* ecma_op_internal_buffer_find */
        -:  146:
        -:  147:/**
        -:  148: * Get the value that belongs to the key.
        -:  149: *
        -:  150: * Note: in case of Set containers, the values are the same as the keys.
        -:  151: *
        -:  152: * @return ecma value
        -:  153: */
        -:  154:static ecma_value_t
    #####:  155:ecma_op_container_get_value (ecma_value_t *entry_p, /**< entry (key) pointer */
        -:  156:                             lit_magic_string_id_t lit_id) /**< class id */
        -:  157:{
    #####:  158:  JERRY_ASSERT (entry_p != NULL);
        -:  159:
    #####:  160:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  161:  {
    #####:  162:    return ((ecma_container_pair_t *) entry_p)->value;
        -:  163:  }
        -:  164:
    #####:  165:  return *entry_p;
        -:  166:} /* ecma_op_container_get_value */
        -:  167:
        -:  168:/**
        -:  169: * Get the size (in ecma_value_t) of the stored entries.
        -:  170: *
        -:  171: * @return size of the entries.
        -:  172: */
        -:  173:uint8_t
    #####:  174:ecma_op_container_entry_size (lit_magic_string_id_t lit_id) /**< class id */
        -:  175:{
    #####:  176:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  177:  {
    #####:  178:    return ECMA_CONTAINER_PAIR_SIZE;
        -:  179:  }
        -:  180:
    #####:  181:  return ECMA_CONTAINER_VALUE_SIZE;
        -:  182:} /* ecma_op_container_entry_size */
        -:  183:
        -:  184:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
        -:  185:/**
        -:  186: * Release the entries in the WeakSet container.
        -:  187: */
        -:  188:static void
    #####:  189:ecma_op_container_free_weakset_entries (ecma_object_t *object_p, /**< object pointer */
        -:  190:                                        ecma_collection_t *container_p) /** internal buffer pointer */
        -:  191:{
    #####:  192:  JERRY_ASSERT (object_p != NULL);
    #####:  193:  JERRY_ASSERT (container_p != NULL);
        -:  194:
    #####:  195:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  196:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  197:
    #####:  198:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)
        -:  199:  {
    #####:  200:    ecma_value_t *entry_p = start_p + i;
        -:  201:
    #####:  202:    if (ecma_is_value_empty (*entry_p))
        -:  203:    {
    #####:  204:      continue;
        -:  205:    }
        -:  206:
    #####:  207:    ecma_op_container_unref_weak (ecma_get_object_from_value (*entry_p), ecma_make_object_value (object_p));
    #####:  208:    ecma_op_container_remove_weak_entry (object_p, *entry_p);
        -:  209:
    #####:  210:    *entry_p = ECMA_VALUE_EMPTY;
        -:  211:  }
    #####:  212:} /* ecma_op_container_free_weakset_entries */
        -:  213:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
        -:  214:
        -:  215:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)
        -:  216:/**
        -:  217: * Release the entries in the WeakMap container.
        -:  218: */
        -:  219:static void
    #####:  220:ecma_op_container_free_weakmap_entries (ecma_object_t *object_p, /**< object pointer */
        -:  221:                                        ecma_collection_t *container_p) /**< internal buffer pointer */
        -:  222:{
    #####:  223:  JERRY_ASSERT (object_p != NULL);
    #####:  224:  JERRY_ASSERT (container_p != NULL);
        -:  225:
    #####:  226:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  227:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  228:
    #####:  229:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)
        -:  230:  {
    #####:  231:    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);
        -:  232:
    #####:  233:    if (ecma_is_value_empty (entry_p->key))
        -:  234:    {
    #####:  235:      continue;
        -:  236:    }
        -:  237:
    #####:  238:    ecma_op_container_unref_weak (ecma_get_object_from_value (entry_p->key), ecma_make_object_value (object_p));
    #####:  239:    ecma_op_container_remove_weak_entry (object_p, entry_p->key);
        -:  240:
    #####:  241:    ecma_free_value_if_not_object (entry_p->value);
        -:  242:
    #####:  243:    entry_p->key = ECMA_VALUE_EMPTY;
    #####:  244:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  245:  }
    #####:  246:} /* ecma_op_container_free_weakmap_entries */
        -:  247:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */
        -:  248:
        -:  249:#if ENABLED (JERRY_ES2015_BUILTIN_SET)
        -:  250:/**
        -:  251: * Release the entries in the Set container.
        -:  252: */
        -:  253:static void
    #####:  254:ecma_op_container_free_set_entries (ecma_collection_t *container_p)
        -:  255:{
    #####:  256:  JERRY_ASSERT (container_p != NULL);
        -:  257:
    #####:  258:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  259:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  260:
    #####:  261:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)
        -:  262:  {
    #####:  263:    ecma_value_t *entry_p = start_p + i;
        -:  264:
    #####:  265:    if (ecma_is_value_empty (*entry_p))
        -:  266:    {
    #####:  267:      continue;
        -:  268:    }
        -:  269:
    #####:  270:    ecma_free_value_if_not_object (*entry_p);
    #####:  271:    *entry_p = ECMA_VALUE_EMPTY;
        -:  272:  }
    #####:  273:} /* ecma_op_container_free_set_entries */
        -:  274:#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */
        -:  275:
        -:  276:#if ENABLED (JERRY_ES2015_BUILTIN_MAP)
        -:  277:/**
        -:  278: * Release the entries in the Map container.
        -:  279: */
        -:  280:static void
    #####:  281:ecma_op_container_free_map_entries (ecma_collection_t *container_p)
        -:  282:{
    #####:  283:  JERRY_ASSERT (container_p != NULL);
        -:  284:
    #####:  285:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  286:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  287:
    #####:  288:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)
        -:  289:  {
    #####:  290:    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);
        -:  291:
    #####:  292:    if (ecma_is_value_empty (entry_p->key))
        -:  293:    {
    #####:  294:      continue;
        -:  295:    }
        -:  296:
    #####:  297:    ecma_free_value_if_not_object (entry_p->key);
    #####:  298:    ecma_free_value_if_not_object (entry_p->value);
        -:  299:
    #####:  300:    entry_p->key = ECMA_VALUE_EMPTY;
    #####:  301:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  302:  }
    #####:  303:} /* ecma_op_container_free_map_entries */
        -:  304:#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */
        -:  305:
        -:  306:/**
        -:  307: * Release the internal buffer and the stored entries.
        -:  308: */
        -:  309:void
    #####:  310:ecma_op_container_free_entries (ecma_object_t *object_p) /**< collection object pointer */
        -:  311:{
    #####:  312:  JERRY_ASSERT (object_p != NULL);
        -:  313:
    #####:  314:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
    #####:  315:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  316:                                                                    map_object_p->u.class_prop.u.value);
        -:  317:
    #####:  318:  switch (map_object_p->u.class_prop.class_id)
        -:  319:  {
        -:  320:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
    #####:  321:    case LIT_MAGIC_STRING_WEAKSET_UL:
        -:  322:    {
    #####:  323:      ecma_op_container_free_weakset_entries (object_p, container_p);
    #####:  324:      break;
        -:  325:    }
        -:  326:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
        -:  327:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)
    #####:  328:    case LIT_MAGIC_STRING_WEAKMAP_UL:
        -:  329:    {
    #####:  330:      ecma_op_container_free_weakmap_entries (object_p, container_p);
    #####:  331:      break;
        -:  332:    }
        -:  333:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */
        -:  334:#if ENABLED (JERRY_ES2015_BUILTIN_SET)
    #####:  335:    case LIT_MAGIC_STRING_SET_UL:
        -:  336:    {
    #####:  337:      ecma_op_container_free_set_entries (container_p);
    #####:  338:      break;
        -:  339:    }
        -:  340:#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */
        -:  341:#if ENABLED (JERRY_ES2015_BUILTIN_MAP)
    #####:  342:    case LIT_MAGIC_STRING_MAP_UL:
        -:  343:    {
    #####:  344:      ecma_op_container_free_map_entries (container_p);
    #####:  345:      break;
        -:  346:    }
        -:  347:#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */
    #####:  348:    default:
        -:  349:    {
    #####:  350:      break;
        -:  351:    }
        -:  352:  }
        -:  353:
    #####:  354:  ECMA_CONTAINER_SET_SIZE (container_p, 0);
    #####:  355:} /* ecma_op_container_free_entries */
        -:  356:
        -:  357:/**
        -:  358: * Handle calling [[Construct]] of built-in Map/Set like objects
        -:  359: *
        -:  360: * @return ecma value
        -:  361: */
        -:  362:ecma_value_t
    #####:  363:ecma_op_container_create (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  364:                          ecma_length_t arguments_list_len, /**< number of arguments */
        -:  365:                          lit_magic_string_id_t lit_id, /**< internal class id */
        -:  366:                          ecma_builtin_id_t proto_id) /**< prototype builtin id */
        -:  367:{
    #####:  368:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
    #####:  369:  JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_MAP_UL
        -:  370:                || lit_id == LIT_MAGIC_STRING_SET_UL
        -:  371:                || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL
        -:  372:                || lit_id == LIT_MAGIC_STRING_WEAKSET_UL);
    #####:  373:  JERRY_ASSERT (JERRY_CONTEXT (current_new_target) != NULL);
        -:  374:
    #####:  375:  ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target), proto_id);
        -:  376:
    #####:  377:  if (JERRY_UNLIKELY (proto_p == NULL))
        -:  378:  {
    #####:  379:    return ECMA_VALUE_ERROR;
        -:  380:  }
        -:  381:
    #####:  382:  ecma_collection_t *container_p = ecma_op_create_internal_buffer ();
    #####:  383:  ecma_object_t *object_p  = ecma_create_object (proto_p,
        -:  384:                                                 sizeof (ecma_extended_object_t),
        -:  385:                                                 ECMA_OBJECT_TYPE_CLASS);
    #####:  386:  ecma_deref_object (proto_p);
    #####:  387:  ecma_extended_object_t *map_obj_p = (ecma_extended_object_t *) object_p;
    #####:  388:  map_obj_p->u.class_prop.extra_info = ECMA_CONTAINER_FLAGS_EMPTY;
    #####:  389:  map_obj_p->u.class_prop.class_id = (uint16_t) lit_id;
        -:  390:
    #####:  391:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)
        -:  392:  {
    #####:  393:    map_obj_p->u.class_prop.extra_info |= ECMA_CONTAINER_FLAGS_WEAK;
        -:  394:  }
        -:  395:
    #####:  396:  ECMA_SET_INTERNAL_VALUE_POINTER (map_obj_p->u.class_prop.u.value, container_p);
        -:  397:
    #####:  398:  ecma_value_t set_value = ecma_make_object_value (object_p);
    #####:  399:  ecma_value_t result = set_value;
        -:  400:
        -:  401:#if ENABLED (JERRY_ES2015)
    #####:  402:  if (arguments_list_len == 0)
        -:  403:  {
    #####:  404:    return result;
        -:  405:  }
        -:  406:
    #####:  407:  ecma_value_t iterable = arguments_list_p[0];
        -:  408:
    #####:  409:  if (ecma_is_value_undefined (iterable) || ecma_is_value_null (iterable))
        -:  410:  {
    #####:  411:    return result;
        -:  412:  }
        -:  413:
        -:  414:  lit_magic_string_id_t adder_string_id;
    #####:  415:  if (lit_id == LIT_MAGIC_STRING_MAP_UL || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -:  416:  {
    #####:  417:    adder_string_id = LIT_MAGIC_STRING_SET;
        -:  418:  }
        -:  419:  else
        -:  420:  {
    #####:  421:    adder_string_id = LIT_MAGIC_STRING_ADD;
        -:  422:  }
        -:  423:
    #####:  424:  result = ecma_op_object_get_by_magic_id (object_p, adder_string_id);
    #####:  425:  if (ECMA_IS_VALUE_ERROR (result))
        -:  426:  {
    #####:  427:    goto cleanup_object;
        -:  428:  }
        -:  429:
    #####:  430:  if (!ecma_op_is_callable (result))
        -:  431:  {
    #####:  432:    ecma_free_value (result);
    #####:  433:    result = ecma_raise_type_error (ECMA_ERR_MSG ("add/set function is not callable."));
    #####:  434:    goto cleanup_object;
        -:  435:  }
        -:  436:
    #####:  437:  ecma_object_t *adder_func_p = ecma_get_object_from_value (result);
        -:  438:
    #####:  439:  result = ecma_op_get_iterator (iterable, ECMA_VALUE_EMPTY);
        -:  440:
    #####:  441:  if (ECMA_IS_VALUE_ERROR (result))
        -:  442:  {
    #####:  443:    goto cleanup_adder;
        -:  444:  }
        -:  445:
    #####:  446:  const ecma_value_t iter = result;
        -:  447:
        -:  448:  while (true)
    #####:  449:  {
    #####:  450:    result = ecma_op_iterator_step (iter);
        -:  451:
    #####:  452:    if (ECMA_IS_VALUE_ERROR (result))
        -:  453:    {
    #####:  454:      goto cleanup_iter;
        -:  455:    }
        -:  456:
    #####:  457:    if (ecma_is_value_false (result))
        -:  458:    {
    #####:  459:      break;
        -:  460:    }
        -:  461:
    #####:  462:    const ecma_value_t next = result;
    #####:  463:    result = ecma_op_iterator_value (next);
    #####:  464:    ecma_free_value (next);
        -:  465:
    #####:  466:    if (ECMA_IS_VALUE_ERROR (result))
        -:  467:    {
    #####:  468:      goto cleanup_iter;
        -:  469:    }
        -:  470:
    #####:  471:    if (lit_id == LIT_MAGIC_STRING_SET_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)
    #####:  472:    {
    #####:  473:      const ecma_value_t value = result;
        -:  474:
    #####:  475:      ecma_value_t arguments[] = { value };
    #####:  476:      result = ecma_op_function_call (adder_func_p, set_value, arguments, 1);
        -:  477:
    #####:  478:      ecma_free_value (value);
        -:  479:    }
        -:  480:    else
        -:  481:    {
    #####:  482:      if (!ecma_is_value_object (result))
        -:  483:      {
    #####:  484:        ecma_free_value (result);
    #####:  485:        ecma_raise_type_error (ECMA_ERR_MSG ("Iterator value is not an object."));
    #####:  486:        result = ecma_op_iterator_close (iter);
    #####:  487:        JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####:  488:        goto cleanup_iter;
        -:  489:      }
        -:  490:
    #####:  491:      ecma_object_t *next_object_p = ecma_get_object_from_value (result);
        -:  492:
    #####:  493:      result = ecma_op_object_get_by_uint32_index (next_object_p, 0);
        -:  494:
    #####:  495:      if (ECMA_IS_VALUE_ERROR (result))
        -:  496:      {
    #####:  497:        ecma_deref_object (next_object_p);
    #####:  498:        ecma_op_iterator_close (iter);
    #####:  499:        goto cleanup_iter;
        -:  500:      }
        -:  501:
    #####:  502:      const ecma_value_t key = result;
        -:  503:
    #####:  504:      result = ecma_op_object_get_by_uint32_index (next_object_p, 1);
        -:  505:
    #####:  506:      if (ECMA_IS_VALUE_ERROR (result))
        -:  507:      {
    #####:  508:        ecma_deref_object (next_object_p);
    #####:  509:        ecma_free_value (key);
    #####:  510:        ecma_op_iterator_close (iter);
    #####:  511:        goto cleanup_iter;
        -:  512:      }
        -:  513:
    #####:  514:      const ecma_value_t value = result;
    #####:  515:      ecma_value_t arguments[] = { key, value };
    #####:  516:      result = ecma_op_function_call (adder_func_p, set_value, arguments, 2);
        -:  517:
    #####:  518:      ecma_free_value (key);
    #####:  519:      ecma_free_value (value);
    #####:  520:      ecma_deref_object (next_object_p);
        -:  521:    }
        -:  522:
    #####:  523:    if (ECMA_IS_VALUE_ERROR (result))
        -:  524:    {
    #####:  525:      ecma_op_iterator_close (iter);
    #####:  526:      goto cleanup_iter;
        -:  527:    }
        -:  528:
    #####:  529:    ecma_free_value (result);
        -:  530:  }
        -:  531:
    #####:  532:  ecma_free_value (iter);
    #####:  533:  ecma_deref_object (adder_func_p);
    #####:  534:  return ecma_make_object_value (object_p);
        -:  535:
    #####:  536:cleanup_iter:
    #####:  537:  ecma_free_value (iter);
    #####:  538:cleanup_adder:
    #####:  539:  ecma_deref_object (adder_func_p);
    #####:  540:cleanup_object:
    #####:  541:  ecma_deref_object (object_p);
        -:  542:#endif /* ENABLED (JERRY_ES2015) */
        -:  543:
    #####:  544:  return result;
        -:  545:} /* ecma_op_container_create */
        -:  546:
        -:  547:/**
        -:  548: * Get Map/Set object pointer
        -:  549: *
        -:  550: * Note:
        -:  551: *   If the function returns with NULL, the error object has
        -:  552: *   already set, and the caller must return with ECMA_VALUE_ERROR
        -:  553: *
        -:  554: * @return pointer to the Map/Set if this_arg is a valid Map/Set object
        -:  555: *         NULL otherwise
        -:  556: */
        -:  557:static ecma_extended_object_t *
    #####:  558:ecma_op_container_get_object (ecma_value_t this_arg, /**< this argument */
        -:  559:                              lit_magic_string_id_t lit_id) /**< internal class id */
        -:  560:{
    #####:  561:  if (ecma_is_value_object (this_arg))
        -:  562:  {
    #####:  563:    ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) ecma_get_object_from_value (this_arg);
        -:  564:
    #####:  565:    if (ecma_get_object_type ((ecma_object_t *) map_object_p) == ECMA_OBJECT_TYPE_CLASS
    #####:  566:        && map_object_p->u.class_prop.class_id == lit_id)
        -:  567:    {
    #####:  568:      return map_object_p;
        -:  569:    }
        -:  570:  }
        -:  571:
        -:  572:#if ENABLED (JERRY_ERROR_MESSAGES)
    #####:  573:  ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,
        -:  574:                                         "Expected a % object.",
    #####:  575:                                         ecma_make_string_value (ecma_get_magic_string (lit_id)));
        -:  576:#else /* !ENABLED (JERRY_ERROR_MESSAGES) */
        -:  577:  ecma_raise_type_error (NULL);
        -:  578:#endif /* ENABLED (JERRY_ERROR_MESSAGES) */
        -:  579:
    #####:  580:  return NULL;
        -:  581:} /* ecma_op_container_get_object */
        -:  582:
        -:  583:/**
        -:  584: * Returns with the size of the Map/Set object.
        -:  585: *
        -:  586: * @return size of the Map/Set object as ecma-value.
        -:  587: */
        -:  588:ecma_value_t
    #####:  589:ecma_op_container_size (ecma_value_t this_arg, /**< this argument */
        -:  590:                        lit_magic_string_id_t lit_id) /**< internal class id */
        -:  591:{
    #####:  592:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -:  593:
    #####:  594:  if (map_object_p == NULL)
        -:  595:  {
    #####:  596:    return ECMA_VALUE_ERROR;
        -:  597:  }
        -:  598:
    #####:  599:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  600:                                                                    map_object_p->u.class_prop.u.value);
        -:  601:
    #####:  602:  return ecma_make_uint32_value (ECMA_CONTAINER_GET_SIZE (container_p));
        -:  603:} /* ecma_op_container_size */
        -:  604:
        -:  605:/**
        -:  606: * The generic Map/WeakMap prototype object's 'get' routine
        -:  607: *
        -:  608: * @return ecma value
        -:  609: *         Returned value must be freed with ecma_free_value.
        -:  610: */
        -:  611:ecma_value_t
    #####:  612:ecma_op_container_get (ecma_value_t this_arg, /**< this argument */
        -:  613:                       ecma_value_t key_arg, /**< key argument */
        -:  614:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  615:{
    #####:  616:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -:  617:
    #####:  618:  if (map_object_p == NULL)
        -:  619:  {
    #####:  620:    return ECMA_VALUE_ERROR;
        -:  621:  }
        -:  622:
        -:  623:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)
    #####:  624:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL && !ecma_is_value_object (key_arg))
        -:  625:  {
    #####:  626:    return ECMA_VALUE_UNDEFINED;
        -:  627:  }
        -:  628:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */
        -:  629:
    #####:  630:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  631:                                                                    map_object_p->u.class_prop.u.value);
        -:  632:
    #####:  633:  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)
        -:  634:  {
    #####:  635:    return ECMA_VALUE_UNDEFINED;
        -:  636:  }
        -:  637:
    #####:  638:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  639:
    #####:  640:  if (entry_p == NULL)
        -:  641:  {
    #####:  642:    return ECMA_VALUE_UNDEFINED;
        -:  643:  }
        -:  644:
    #####:  645:  return ecma_copy_value (((ecma_container_pair_t *) entry_p)->value);
        -:  646:} /* ecma_op_container_get */
        -:  647:
        -:  648:/**
        -:  649: * The generic Map/Set prototype object's 'has' routine
        -:  650: *
        -:  651: * @return ecma value
        -:  652: *         Returned value must be freed with ecma_free_value.
        -:  653: */
        -:  654:ecma_value_t
    #####:  655:ecma_op_container_has (ecma_value_t this_arg, /**< this argument */
        -:  656:                       ecma_value_t key_arg, /**< key argument */
        -:  657:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  658:{
    #####:  659:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -:  660:
    #####:  661:  if (map_object_p == NULL)
        -:  662:  {
    #####:  663:    return ECMA_VALUE_ERROR;
        -:  664:  }
        -:  665:
    #####:  666:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  667:                                                                    map_object_p->u.class_prop.u.value);
        -:  668:
        -:  669:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) || ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
    #####:  670:  if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0
    #####:  671:      && !ecma_is_value_object (key_arg))
        -:  672:  {
    #####:  673:    return ECMA_VALUE_FALSE;
        -:  674:  }
        -:  675:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
        -:  676:
    #####:  677:  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)
        -:  678:  {
    #####:  679:    return ECMA_VALUE_FALSE;
        -:  680:  }
        -:  681:
    #####:  682:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  683:
    #####:  684:  return ecma_make_boolean_value (entry_p != NULL);
        -:  685:} /* ecma_op_container_has */
        -:  686:
        -:  687:/**
        -:  688: * Set a weak reference from a container to a key object
        -:  689: */
        -:  690:static void
    #####:  691:ecma_op_container_set_weak (ecma_object_t *const key_p, /**< key object */
        -:  692:                            ecma_extended_object_t *const container_p) /**< container */
        -:  693:{
    #####:  694:  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (key_p)))
        -:  695:  {
    #####:  696:    ecma_fast_array_convert_to_normal (key_p);
        -:  697:  }
        -:  698:
    #####:  699:  ecma_string_t *weak_refs_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);
    #####:  700:  ecma_property_t *property_p = ecma_find_named_property (key_p, weak_refs_string_p);
        -:  701:  ecma_collection_t *refs_p;
        -:  702:
    #####:  703:  if (property_p == NULL)
        -:  704:  {
    #####:  705:    ecma_property_value_t *value_p = ecma_create_named_data_property (key_p,
        -:  706:                                                                      weak_refs_string_p,
        -:  707:                                                                      ECMA_PROPERTY_CONFIGURABLE_WRITABLE,
        -:  708:                                                                      &property_p);
    #####:  709:    ECMA_CONVERT_DATA_PROPERTY_TO_INTERNAL_PROPERTY (property_p);
    #####:  710:    refs_p = ecma_new_collection ();
    #####:  711:    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, refs_p);
        -:  712:  }
        -:  713:  else
        -:  714:  {
    #####:  715:    refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -:  716:  }
        -:  717:
    #####:  718:  const ecma_value_t container_value = ecma_make_object_value ((ecma_object_t *) container_p);
    #####:  719:  for (uint32_t i = 0; i < refs_p->item_count; i++)
        -:  720:  {
    #####:  721:    if (ecma_is_value_empty (refs_p->buffer_p[i]))
        -:  722:    {
    #####:  723:      refs_p->buffer_p[i] = container_value;
    #####:  724:      return;
        -:  725:    }
        -:  726:  }
        -:  727:
    #####:  728:  ecma_collection_push_back (refs_p, container_value);
        -:  729:} /* ecma_op_container_set_weak */
        -:  730:
        -:  731:/**
        -:  732: * Helper method for the Map.prototype.set and Set.prototype.add methods to swap the sign of the given value if needed
        -:  733: *
        -:  734: * See also:
        -:  735: *          ECMA-262 v6, 23.2.3.1 step 6
        -:  736: *          ECMA-262 v6, 23.1.3.9 step 6
        -:  737: *
        -:  738: * @return ecma value
        -:  739: */
        -:  740:static ecma_value_t
    #####:  741:ecma_op_container_set_noramlize_zero (ecma_value_t this_arg) /*< this arg */
        -:  742:{
    #####:  743:  if (ecma_is_value_number (this_arg))
        -:  744:  {
    #####:  745:    ecma_number_t number_value = ecma_get_number_from_value (this_arg);
        -:  746:
    #####:  747:    if (JERRY_UNLIKELY (ecma_number_is_zero (number_value) && ecma_number_is_negative (number_value)))
        -:  748:    {
    #####:  749:      return ecma_make_integer_value (0);
        -:  750:    }
        -:  751:  }
        -:  752:
    #####:  753:  return this_arg;
        -:  754:} /* ecma_op_container_set_noramlize_zero */
        -:  755:
        -:  756:/**
        -:  757: * The generic Map prototype object's 'set' and Set prototype object's 'add' routine
        -:  758: *
        -:  759: * @return ecma value
        -:  760: *         Returned value must be freed with ecma_free_value.
        -:  761: */
        -:  762:ecma_value_t
    #####:  763:ecma_op_container_set (ecma_value_t this_arg, /**< this argument */
        -:  764:                       ecma_value_t key_arg, /**< key argument */
        -:  765:                       ecma_value_t value_arg, /**< value argument */
        -:  766:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  767:{
    #####:  768:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -:  769:
    #####:  770:  if (map_object_p == NULL)
        -:  771:  {
    #####:  772:    return ECMA_VALUE_ERROR;
        -:  773:  }
        -:  774:
    #####:  775:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  776:                                                                    map_object_p->u.class_prop.u.value);
        -:  777:
        -:  778:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
    #####:  779:  if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0
    #####:  780:      && !ecma_is_value_object (key_arg))
        -:  781:  {
    #####:  782:    return ecma_raise_type_error (ECMA_ERR_MSG ("Key must be an object"));
        -:  783:  }
        -:  784:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
        -:  785:
    #####:  786:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  787:
    #####:  788:  if (entry_p == NULL)
        -:  789:  {
    #####:  790:    ecma_op_internal_buffer_append (container_p,
        -:  791:                                    ecma_op_container_set_noramlize_zero (key_arg),
        -:  792:                                    value_arg,
        -:  793:                                    lit_id);
        -:  794:
        -:  795:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
    #####:  796:    if ((map_object_p->u.class_prop.extra_info & ECMA_CONTAINER_FLAGS_WEAK) != 0)
        -:  797:    {
    #####:  798:      ecma_object_t *key_p = ecma_get_object_from_value (key_arg);
    #####:  799:      ecma_op_container_set_weak (key_p, map_object_p);
        -:  800:    }
        -:  801:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) ||  ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
        -:  802:  }
        -:  803:  else
        -:  804:  {
    #####:  805:    ecma_op_internal_buffer_update (entry_p, ecma_op_container_set_noramlize_zero (value_arg), lit_id);
        -:  806:  }
        -:  807:
    #####:  808:  ecma_ref_object ((ecma_object_t *) map_object_p);
    #####:  809:  return this_arg;
        -:  810:} /* ecma_op_container_set */
        -:  811:
        -:  812:/**
        -:  813: * The generic Map/Set prototype object's 'forEach' routine
        -:  814: *
        -:  815: * @return ecma value
        -:  816: *         Returned value must be freed with ecma_free_value.
        -:  817: */
        -:  818:ecma_value_t
    #####:  819:ecma_op_container_foreach (ecma_value_t this_arg, /**< this argument */
        -:  820:                           ecma_value_t predicate, /**< callback function */
        -:  821:                           ecma_value_t predicate_this_arg, /**< this argument for
        -:  822:                                                             *   invoke predicate */
        -:  823:                           lit_magic_string_id_t lit_id) /**< internal class id */
        -:  824:{
    #####:  825:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -:  826:
    #####:  827:  if (map_object_p == NULL)
        -:  828:  {
    #####:  829:    return ECMA_VALUE_ERROR;
        -:  830:  }
        -:  831:
    #####:  832:  if (!ecma_op_is_callable (predicate))
        -:  833:  {
    #####:  834:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -:  835:  }
        -:  836:
    #####:  837:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####:  838:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
    #####:  839:  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;
        -:  840:
    #####:  841:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  842:                                                                    map_object_p->u.class_prop.u.value);
        -:  843:
    #####:  844:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
        -:  845:
    #####:  846:  for (uint32_t i = 0; i < ECMA_CONTAINER_ENTRY_COUNT (container_p); i += entry_size)
        -:  847:  {
    #####:  848:    ecma_value_t *entry_p = ECMA_CONTAINER_START (container_p) + i;
        -:  849:
    #####:  850:    if (ecma_is_value_empty (*entry_p))
        -:  851:    {
    #####:  852:      continue;
        -:  853:    }
        -:  854:
    #####:  855:    ecma_value_t key_arg = *entry_p;
    #####:  856:    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);
        -:  857:
    #####:  858:    ecma_value_t call_args[] = { value_arg, key_arg, this_arg };
    #####:  859:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -:  860:
    #####:  861:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  862:    {
    #####:  863:      ret_value = call_value;
    #####:  864:      break;
        -:  865:    }
        -:  866:
    #####:  867:    ecma_free_value (call_value);
        -:  868:  }
        -:  869:
    #####:  870:  return ret_value;
        -:  871:} /* ecma_op_container_foreach */
        -:  872:
        -:  873:/**
        -:  874: * The Map/Set prototype object's 'clear' routine
        -:  875: *
        -:  876: * @return ecma value
        -:  877: *         Returned value must be freed with ecma_free_value.
        -:  878: */
        -:  879:ecma_value_t
    #####:  880:ecma_op_container_clear (ecma_value_t this_arg, /**< this argument */
        -:  881:                         lit_magic_string_id_t lit_id) /**< internal class id */
        -:  882:{
    #####:  883:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -:  884:
    #####:  885:  if (map_object_p == NULL)
        -:  886:  {
    #####:  887:    return ECMA_VALUE_ERROR;
        -:  888:  }
        -:  889:
    #####:  890:  ecma_op_container_free_entries ((ecma_object_t *) map_object_p);
        -:  891:
    #####:  892:  return ECMA_VALUE_UNDEFINED;
        -:  893:} /* ecma_op_container_clear */
        -:  894:
        -:  895:/**
        -:  896: * The generic Map/Set prototype object's 'delete' routine
        -:  897: *
        -:  898: * @return ecma value
        -:  899: *         Returned value must be freed with ecma_free_value.
        -:  900: */
        -:  901:ecma_value_t
    #####:  902:ecma_op_container_delete (ecma_value_t this_arg, /**< this argument */
        -:  903:                          ecma_value_t key_arg, /**< key argument */
        -:  904:                          lit_magic_string_id_t lit_id) /**< internal class id */
        -:  905:{
    #####:  906:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -:  907:
    #####:  908:  if (map_object_p == NULL)
        -:  909:  {
    #####:  910:    return ECMA_VALUE_ERROR;
        -:  911:  }
        -:  912:
    #####:  913:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  914:                                                                    map_object_p->u.class_prop.u.value);
        -:  915:
    #####:  916:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  917:
    #####:  918:  if (entry_p == NULL)
        -:  919:  {
    #####:  920:    return ECMA_VALUE_FALSE;
        -:  921:  }
        -:  922:
    #####:  923:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);
    #####:  924:  return ECMA_VALUE_TRUE;
        -:  925:} /* ecma_op_container_delete */
        -:  926:
        -:  927:/**
        -:  928: * The generic WeakMap/WeakSet prototype object's 'delete' routine
        -:  929: *
        -:  930: * @return ecma value
        -:  931: *         Returned value must be freed with ecma_free_value.
        -:  932: */
        -:  933:ecma_value_t
    #####:  934:ecma_op_container_delete_weak (ecma_value_t this_arg, /**< this argument */
        -:  935:                               ecma_value_t key_arg, /**< key argument */
        -:  936:                               lit_magic_string_id_t lit_id) /**< internal class id */
        -:  937:{
    #####:  938:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -:  939:
    #####:  940:  if (map_object_p == NULL)
        -:  941:  {
    #####:  942:    return ECMA_VALUE_ERROR;
        -:  943:  }
        -:  944:
    #####:  945:  if (!ecma_is_value_object (key_arg))
        -:  946:  {
    #####:  947:    return ECMA_VALUE_FALSE;
        -:  948:  }
        -:  949:
    #####:  950:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  951:                                                                    map_object_p->u.class_prop.u.value);
        -:  952:
    #####:  953:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  954:
    #####:  955:  if (entry_p == NULL)
        -:  956:  {
    #####:  957:    return ECMA_VALUE_FALSE;
        -:  958:  }
        -:  959:
    #####:  960:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);
        -:  961:
    #####:  962:  ecma_object_t *key_object_p = ecma_get_object_from_value (key_arg);
    #####:  963:  ecma_op_container_unref_weak (key_object_p, ecma_make_object_value ((ecma_object_t *) map_object_p));
        -:  964:
    #####:  965:  return ECMA_VALUE_TRUE;
        -:  966:} /* ecma_op_container_delete_weak */
        -:  967:
        -:  968:/**
        -:  969: * Helper function to remove a weak reference to an object.
        -:  970: *
        -:  971: * @return ecma value
        -:  972: *         Returned value must be freed with ecma_free_value.
        -:  973: */
        -:  974:void
    #####:  975:ecma_op_container_unref_weak (ecma_object_t *object_p, /**< this argument */
        -:  976:                              ecma_value_t ref_holder) /**< key argument */
        -:  977:{
    #####:  978:  ecma_string_t *weak_refs_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);
        -:  979:
    #####:  980:  ecma_property_t *property_p = ecma_find_named_property (object_p, weak_refs_string_p);
    #####:  981:  JERRY_ASSERT (property_p != NULL);
        -:  982:
    #####:  983:  ecma_collection_t *refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  984:                                                               ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####:  985:  for (uint32_t i = 0; i < refs_p->item_count; i++)
        -:  986:  {
    #####:  987:    if (refs_p->buffer_p[i] == ref_holder)
        -:  988:    {
    #####:  989:      refs_p->buffer_p[i] = ECMA_VALUE_EMPTY;
    #####:  990:      break;
        -:  991:    }
        -:  992:  }
    #####:  993:} /* ecma_op_container_unref_weak */
        -:  994:
        -:  995:/**
        -:  996: * Helper function to remove a key/value pair from a weak container object
        -:  997: */
        -:  998:void
    #####:  999:ecma_op_container_remove_weak_entry (ecma_object_t *object_p, /**< internal container object */
        -: 1000:                                     ecma_value_t key_arg) /**< key */
        -: 1001:{
    #####: 1002:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
        -: 1003:
    #####: 1004:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -: 1005:                                                                    map_object_p->u.class_prop.u.value);
        -: 1006:
    #####: 1007:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, map_object_p->u.class_prop.class_id);
        -: 1008:
    #####: 1009:  JERRY_ASSERT (entry_p != NULL);
        -: 1010:
    #####: 1011:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, map_object_p->u.class_prop.class_id);
    #####: 1012:} /* ecma_op_container_remove_weak_entry */
        -: 1013:
        -: 1014:#if ENABLED (JERRY_ES2015)
        -: 1015:
        -: 1016:/**
        -: 1017: * The Create{Set, Map}Iterator Abstract operation
        -: 1018: *
        -: 1019: * See also:
        -: 1020: *          ECMA-262 v6, 23.1.5.1
        -: 1021: *          ECMA-262 v6, 23.2.5.1
        -: 1022: *
        -: 1023: * Note:
        -: 1024: *     Returned value must be freed with ecma_free_value.
        -: 1025: *
        -: 1026: * @return Map/Set iterator object, if success
        -: 1027: *         error - otherwise
        -: 1028: */
        -: 1029:ecma_value_t
    #####: 1030:ecma_op_container_create_iterator (ecma_value_t this_arg, /**< this argument */
        -: 1031:                                   uint8_t type, /**< any combination of
        -: 1032:                                                  *   ecma_iterator_type_t bits */
        -: 1033:                                   lit_magic_string_id_t lit_id, /**< internal class id */
        -: 1034:                                   ecma_builtin_id_t proto_id, /**< prototype builtin id */
        -: 1035:                                   ecma_pseudo_array_type_t iterator_type) /**< type of the iterator */
        -: 1036:{
    #####: 1037:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -: 1038:
    #####: 1039:  if (map_object_p == NULL)
        -: 1040:  {
    #####: 1041:    return ECMA_VALUE_ERROR;
        -: 1042:  }
        -: 1043:
    #####: 1044:  return ecma_op_create_iterator_object (this_arg,
        -: 1045:                                         ecma_builtin_get (proto_id),
    #####: 1046:                                         (uint8_t) iterator_type,
        -: 1047:                                         type);
        -: 1048:} /* ecma_op_container_create_iterator */
        -: 1049:
        -: 1050:/**
        -: 1051: * Get the index of the iterator object.
        -: 1052: *
        -: 1053: * @return index of the iterator.
        -: 1054: */
        -: 1055:static uint32_t
    #####: 1056:ecma_op_iterator_get_index (ecma_object_t *iter_obj_p)  /**< iterator object pointer */
        -: 1057:{
    #####: 1058:  uint32_t index = ((ecma_extended_object_t *) iter_obj_p)->u.pseudo_array.u1.iterator_index;
        -: 1059:
    #####: 1060:  if (JERRY_UNLIKELY (index == ECMA_ITERATOR_INDEX_LIMIT))
        -: 1061:  {
    #####: 1062:    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);
    #####: 1063:    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);
    #####: 1064:    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1065:
    #####: 1066:    return (uint32_t) (ecma_get_number_from_value (value_p->value));
        -: 1067:  }
        -: 1068:
    #####: 1069:  return index;
        -: 1070:} /* ecma_op_iterator_get_index */
        -: 1071:
        -: 1072:/**
        -: 1073: * Set the index of the iterator object.
        -: 1074: */
        -: 1075:static void
    #####: 1076:ecma_op_iterator_set_index (ecma_object_t *iter_obj_p, /**< iterator object pointer */
        -: 1077:                            uint32_t index) /* iterator index to set */
        -: 1078:{
    #####: 1079:  if (JERRY_UNLIKELY (index >= ECMA_ITERATOR_INDEX_LIMIT))
        -: 1080:  {
        -: 1081:    /* After the ECMA_ITERATOR_INDEX_LIMIT limit is reached the [[%Iterator%NextIndex]]
        -: 1082:       property is stored as an internal property */
    #####: 1083:    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);
    #####: 1084:    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);
        -: 1085:    ecma_property_value_t *value_p;
        -: 1086:
    #####: 1087:    if (property_p == NULL)
        -: 1088:    {
    #####: 1089:      value_p = ecma_create_named_data_property (iter_obj_p, prop_name_p, ECMA_PROPERTY_FLAG_WRITABLE, &property_p);
    #####: 1090:      value_p->value = ecma_make_uint32_value (index);
        -: 1091:    }
        -: 1092:    else
        -: 1093:    {
    #####: 1094:      value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1095:      value_p->value = ecma_make_uint32_value (index);
        -: 1096:    }
        -: 1097:  }
        -: 1098:  else
        -: 1099:  {
    #####: 1100:    ((ecma_extended_object_t *) iter_obj_p)->u.pseudo_array.u1.iterator_index = (uint16_t) index;
        -: 1101:  }
    #####: 1102:} /* ecma_op_iterator_set_index */
        -: 1103:
        -: 1104:/**
        -: 1105: * The %{Set, Map}IteratorPrototype% object's 'next' routine
        -: 1106: *
        -: 1107: * See also:
        -: 1108: *          ECMA-262 v6, 23.1.5.2.1
        -: 1109: *          ECMA-262 v6, 23.2.5.2.1
        -: 1110: *
        -: 1111: * Note:
        -: 1112: *     Returned value must be freed with ecma_free_value.
        -: 1113: *
        -: 1114: * @return iterator result object, if success
        -: 1115: *         error - otherwise
        -: 1116: */
        -: 1117:ecma_value_t
    #####: 1118:ecma_op_container_iterator_next (ecma_value_t this_val, /**< this argument */
        -: 1119:                                 ecma_pseudo_array_type_t iterator_type) /**< type of the iterator */
        -: 1120:{
    #####: 1121:  if (!ecma_is_value_object (this_val))
        -: 1122:  {
    #####: 1123:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an object."));
        -: 1124:  }
        -: 1125:
    #####: 1126:  ecma_object_t *obj_p = ecma_get_object_from_value (this_val);
    #####: 1127:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1128:
    #####: 1129:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_PSEUDO_ARRAY
    #####: 1130:      || ext_obj_p->u.pseudo_array.type != iterator_type)
        -: 1131:  {
    #####: 1132:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an iterator."));
        -: 1133:  }
        -: 1134:
    #####: 1135:  ecma_value_t iterated_value = ext_obj_p->u.pseudo_array.u2.iterated_value;
        -: 1136:
    #####: 1137:  if (ecma_is_value_empty (iterated_value))
        -: 1138:  {
    #####: 1139:    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
        -: 1140:  }
        -: 1141:
    #####: 1142:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));
    #####: 1143:  lit_magic_string_id_t lit_id = map_object_p->u.class_prop.class_id;
        -: 1144:
    #####: 1145:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -: 1146:                                                                    map_object_p->u.class_prop.u.value);
    #####: 1147:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 1148:  uint32_t index = ecma_op_iterator_get_index (obj_p);
        -: 1149:
    #####: 1150:  if (index == entry_count)
        -: 1151:  {
    #####: 1152:    ext_obj_p->u.pseudo_array.u2.iterated_value = ECMA_VALUE_EMPTY;
        -: 1153:
    #####: 1154:    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
        -: 1155:  }
        -: 1156:
    #####: 1157:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
    #####: 1158:  uint8_t iterator_kind = ext_obj_p->u.pseudo_array.extra_info;
    #####: 1159:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
    #####: 1160:  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;
        -: 1161:
    #####: 1162:  for (uint32_t i = index; i < entry_count; i += entry_size)
        -: 1163:  {
    #####: 1164:    ecma_value_t *entry_p = start_p + i;
        -: 1165:
    #####: 1166:    if (ecma_is_value_empty (*entry_p))
        -: 1167:    {
    #####: 1168:      if (i == (entry_count - entry_size))
        -: 1169:      {
    #####: 1170:        ret_value = ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
    #####: 1171:        break;
        -: 1172:      }
        -: 1173:
    #####: 1174:      continue;
        -: 1175:    }
        -: 1176:
    #####: 1177:    ecma_op_iterator_set_index (obj_p, i + entry_size);
        -: 1178:
    #####: 1179:    ecma_value_t key_arg = *entry_p;
    #####: 1180:    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);
        -: 1181:
    #####: 1182:    if (iterator_kind == ECMA_ITERATOR_KEYS)
        -: 1183:    {
    #####: 1184:      ret_value = ecma_create_iter_result_object (key_arg, ECMA_VALUE_FALSE);
        -: 1185:    }
    #####: 1186:    else if (iterator_kind == ECMA_ITERATOR_VALUES)
        -: 1187:    {
    #####: 1188:      ret_value = ecma_create_iter_result_object (value_arg, ECMA_VALUE_FALSE);
        -: 1189:    }
        -: 1190:    else
        -: 1191:    {
    #####: 1192:      JERRY_ASSERT (iterator_kind == ECMA_ITERATOR_KEYS_VALUES);
        -: 1193:
        -: 1194:      ecma_value_t entry_array_value;
    #####: 1195:      entry_array_value = ecma_create_array_from_iter_element (value_arg, key_arg);
        -: 1196:
    #####: 1197:      ret_value = ecma_create_iter_result_object (entry_array_value, ECMA_VALUE_FALSE);
    #####: 1198:      ecma_free_value (entry_array_value);
        -: 1199:    }
        -: 1200:
    #####: 1201:    break;
        -: 1202:  }
        -: 1203:
    #####: 1204:  return ret_value;
        -: 1205:} /* ecma_op_container_iterator_next */
        -: 1206:
        -: 1207:#endif /* ENABLED (JERRY_ES2015) */
        -: 1208:
        -: 1209:/**
        -: 1210: * @}
        -: 1211: * @}
        -: 1212: */
        -: 1213:
        -: 1214:#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */
