        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-gc.h"
        -:   19:#include "ecma-globals.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:#include "ecma-lcache.h"
        -:   22:#include "ecma-property-hashmap.h"
        -:   23:#include "jcontext.h"
        -:   24:#include "jrt-bit-fields.h"
        -:   25:#include "byte-code.h"
        -:   26:#include "re-compiler.h"
        -:   27:#include "ecma-builtins.h"
        -:   28:
        -:   29:#if ENABLED (JERRY_DEBUGGER)
        -:   30:#include "debugger.h"
        -:   31:#endif /* ENABLED (JERRY_DEBUGGER) */
        -:   32:
        -:   33:/** \addtogroup ecma ECMA
        -:   34: * @{
        -:   35: *
        -:   36: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   37: * @{
        -:   38: */
        -:   39:
        -:   40:JERRY_STATIC_ASSERT (ECMA_PROPERTY_TYPE_MASK >= ECMA_PROPERTY_TYPE__MAX,
        -:   41:                     ecma_property_types_must_be_lower_than_the_container_mask);
        -:   42:
        -:   43:JERRY_STATIC_ASSERT (ECMA_OBJECT_TYPE_MASK >= ECMA_OBJECT_TYPE__MAX - 1,
        -:   44:                     ecma_object_types_must_be_lower_than_the_container_mask);
        -:   45:
        -:   46:JERRY_STATIC_ASSERT (ECMA_OBJECT_TYPE_MASK >= ECMA_LEXICAL_ENVIRONMENT_TYPE__MAX,
        -:   47:                     ecma_lexical_environment_types_must_be_lower_than_the_container_mask);
        -:   48:
        -:   49:JERRY_STATIC_ASSERT (ECMA_OBJECT_TYPE_MASK + 1 == ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV,
        -:   50:                     ecma_built_in_flag_must_follow_the_object_type);
        -:   51:
        -:   52:JERRY_STATIC_ASSERT (ECMA_OBJECT_FLAG_EXTENSIBLE == (ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV << 1),
        -:   53:                     ecma_extensible_flag_must_follow_the_built_in_flag);
        -:   54:
        -:   55:JERRY_STATIC_ASSERT (ECMA_OBJECT_REF_ONE == (ECMA_OBJECT_FLAG_EXTENSIBLE << 1),
        -:   56:                     ecma_object_ref_one_must_follow_the_extensible_flag);
        -:   57:
        -:   58:JERRY_STATIC_ASSERT (((ECMA_OBJECT_MAX_REF + ECMA_OBJECT_REF_ONE) | (ECMA_OBJECT_REF_ONE - 1)) == UINT16_MAX,
        -:   59:                      ecma_object_max_ref_does_not_fill_the_remaining_bits);
        -:   60:
        -:   61:JERRY_STATIC_ASSERT (ECMA_PROPERTY_TYPE_DELETED == (ECMA_DIRECT_STRING_MAGIC << ECMA_PROPERTY_NAME_TYPE_SHIFT),
        -:   62:                     ecma_property_type_deleted_must_have_magic_string_name_type);
        -:   63:
        -:   64:/**
        -:   65: * Create an object with specified prototype object
        -:   66: * (or NULL prototype if there is not prototype for the object)
        -:   67: * and value of 'Extensible' attribute.
        -:   68: *
        -:   69: * Reference counter's value will be set to one.
        -:   70: *
        -:   71: * @return pointer to the object's descriptor
        -:   72: */
        -:   73:ecma_object_t *
     7880:   74:ecma_create_object (ecma_object_t *prototype_object_p, /**< pointer to prototybe of the object (or NULL) */
        -:   75:                    size_t ext_object_size, /**< size of extended objects */
        -:   76:                    ecma_object_type_t type) /**< object type */
        -:   77:{
        -:   78:  ecma_object_t *new_object_p;
        -:   79:
     7880:   80:  if (ext_object_size > 0)
        -:   81:  {
     7879:   82:    new_object_p = (ecma_object_t *) ecma_alloc_extended_object (ext_object_size);
        -:   83:  }
        -:   84:  else
        -:   85:  {
        1:   86:    new_object_p = ecma_alloc_object ();
        -:   87:  }
        -:   88:
     7880:   89:  new_object_p->type_flags_refs = (uint16_t) (type | ECMA_OBJECT_FLAG_EXTENSIBLE);
        -:   90:
     7880:   91:  ecma_init_gc_info (new_object_p);
        -:   92:
     7880:   93:  new_object_p->u1.property_list_cp = JMEM_CP_NULL;
        -:   94:
     7880:   95:  ECMA_SET_POINTER (new_object_p->u2.prototype_cp, prototype_object_p);
        -:   96:
     7880:   97:  return new_object_p;
        -:   98:} /* ecma_create_object */
        -:   99:
        -:  100:/**
        -:  101: * Create a declarative lexical environment with specified outer lexical environment
        -:  102: * (or NULL if the environment is not nested).
        -:  103: *
        -:  104: * See also: ECMA-262 v5, 10.2.1.1
        -:  105: *
        -:  106: * Reference counter's value will be set to one.
        -:  107: *
        -:  108: * @return pointer to the descriptor of lexical environment
        -:  109: */
        -:  110:ecma_object_t *
     2619:  111:ecma_create_decl_lex_env (ecma_object_t *outer_lexical_environment_p) /**< outer lexical environment */
        -:  112:{
     2619:  113:  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();
        -:  114:
     2619:  115:  uint16_t type = ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE;
     2619:  116:  new_lexical_environment_p->type_flags_refs = type;
        -:  117:
     2619:  118:  ecma_init_gc_info (new_lexical_environment_p);
        -:  119:
     2619:  120:  new_lexical_environment_p->u1.property_list_cp = JMEM_CP_NULL;
        -:  121:
     2619:  122:  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);
        -:  123:
     2619:  124:  return new_lexical_environment_p;
        -:  125:} /* ecma_create_decl_lex_env */
        -:  126:
        -:  127:/**
        -:  128: * Create a object lexical environment with specified outer lexical environment
        -:  129: * (or NULL if the environment is not nested), binding object and provided type flag.
        -:  130: *
        -:  131: * See also: ECMA-262 v5, 10.2.1.2
        -:  132: *
        -:  133: * Reference counter's value will be set to one.
        -:  134: *
        -:  135: * @return pointer to the descriptor of lexical environment
        -:  136: */
        -:  137:ecma_object_t *
        1:  138:ecma_create_object_lex_env (ecma_object_t *outer_lexical_environment_p, /**< outer lexical environment */
        -:  139:                            ecma_object_t *binding_obj_p, /**< binding object */
        -:  140:                            ecma_lexical_environment_type_t type) /**< type of the new lexical environment */
        -:  141:{
        -:  142:#if ENABLED (JERRY_ES2015)
        1:  143:  JERRY_ASSERT (type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND
        -:  144:                || type == ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND);
        -:  145:#else /* !ENABLED (JERRY_ES2015) */
    #####:  146:  JERRY_ASSERT (type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  147:#endif /* ENABLED (JERRY_ES2015) */
        -:  148:
        1:  149:  JERRY_ASSERT (binding_obj_p != NULL
        -:  150:                && !ecma_is_lexical_environment (binding_obj_p));
        -:  151:
        1:  152:  ecma_object_t *new_lexical_environment_p = ecma_alloc_object ();
        -:  153:
        1:  154:  new_lexical_environment_p->type_flags_refs = (uint16_t) (ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | type);
        -:  155:
        1:  156:  ecma_init_gc_info (new_lexical_environment_p);
        -:  157:
        1:  158:  ECMA_SET_NON_NULL_POINTER (new_lexical_environment_p->u1.bound_object_cp,
        -:  159:                             binding_obj_p);
        -:  160:
        1:  161:  ECMA_SET_POINTER (new_lexical_environment_p->u2.outer_reference_cp, outer_lexical_environment_p);
        -:  162:
        1:  163:  return new_lexical_environment_p;
        -:  164:} /* ecma_create_object_lex_env */
        -:  165:
        -:  166:/**
        -:  167: * Check if the object is lexical environment.
        -:  168: *
        -:  169: * @return true  - if object is a lexical environment
        -:  170: *         false - otherwise
        -:  171: */
        -:  172:inline bool JERRY_ATTR_PURE
   847033:  173:ecma_is_lexical_environment (const ecma_object_t *object_p) /**< object or lexical environment */
        -:  174:{
   847033:  175:  JERRY_ASSERT (object_p != NULL);
        -:  176:
   847033:  177:  uint32_t full_type = object_p->type_flags_refs & (ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | ECMA_OBJECT_TYPE_MASK);
        -:  178:
   847033:  179:  return full_type >= (ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV | ECMA_LEXICAL_ENVIRONMENT_TYPE_START);
        -:  180:} /* ecma_is_lexical_environment */
        -:  181:
        -:  182:/**
        -:  183: * Set value of [[Extensible]] object's internal property.
        -:  184: */
        -:  185:inline void
       18:  186:ecma_op_ordinary_object_set_extensible (ecma_object_t *object_p) /**< object */
        -:  187:{
       18:  188:  JERRY_ASSERT (object_p != NULL);
       18:  189:  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));
        -:  190:
       18:  191:  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs | ECMA_OBJECT_FLAG_EXTENSIBLE);
       18:  192:} /* ecma_op_ordinary_object_set_extensible */
        -:  193:
        -:  194:/**
        -:  195: * Get object's internal implementation-defined type.
        -:  196: *
        -:  197: * @return type of the object (ecma_object_type_t)
        -:  198: */
        -:  199:inline ecma_object_type_t JERRY_ATTR_PURE
   379849:  200:ecma_get_object_type (const ecma_object_t *object_p) /**< object */
        -:  201:{
   379849:  202:  JERRY_ASSERT (object_p != NULL);
   379849:  203:  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));
        -:  204:
   379849:  205:  return (ecma_object_type_t) (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK);
        -:  206:} /* ecma_get_object_type */
        -:  207:
        -:  208:/**
        -:  209: * Check if the object is a built-in object
        -:  210: *
        -:  211: * @return true  - if object is a built-in object
        -:  212: *         false - otherwise
        -:  213: */
        -:  214:inline bool JERRY_ATTR_PURE
   111767:  215:ecma_get_object_is_builtin (const ecma_object_t *object_p) /**< object */
        -:  216:{
   111767:  217:  JERRY_ASSERT (object_p != NULL);
   111767:  218:  JERRY_ASSERT (!ecma_is_lexical_environment (object_p));
        -:  219:
   111767:  220:  return (object_p->type_flags_refs & ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV) != 0;
        -:  221:} /* ecma_get_object_is_builtin */
        -:  222:
        -:  223:/**
        -:  224: * Set flag indicating whether the object is a built-in object
        -:  225: */
        -:  226:inline void
       24:  227:ecma_set_object_is_builtin (ecma_object_t *object_p) /**< object */
        -:  228:{
       24:  229:  JERRY_ASSERT (object_p != NULL);
       24:  230:  JERRY_ASSERT (!(object_p->type_flags_refs & ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV));
       24:  231:  JERRY_ASSERT ((object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK) < ECMA_LEXICAL_ENVIRONMENT_TYPE_START);
        -:  232:
       24:  233:  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs | ECMA_OBJECT_FLAG_BUILT_IN_OR_LEXICAL_ENV);
       24:  234:} /* ecma_set_object_is_builtin */
        -:  235:
        -:  236:/**
        -:  237: * Get the built-in ID of the object.
        -:  238: * If the object is not builtin, return ECMA_BUILTIN_ID__COUNT
        -:  239: *
        -:  240: * @return the ID of the built-in
        -:  241: */
        -:  242:inline uint8_t
    #####:  243:ecma_get_object_builtin_id (ecma_object_t *object_p) /**< object */
        -:  244:{
    #####:  245:  if (!ecma_get_object_is_builtin (object_p))
        -:  246:  {
    #####:  247:    return ECMA_BUILTIN_ID__COUNT;
        -:  248:  }
        -:  249:
        -:  250:  ecma_built_in_props_t *built_in_props_p;
    #####:  251:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -:  252:
    #####:  253:  if (object_type == ECMA_OBJECT_TYPE_CLASS || object_type == ECMA_OBJECT_TYPE_ARRAY)
        -:  254:  {
    #####:  255:    built_in_props_p = &((ecma_extended_built_in_object_t *) object_p)->built_in;
        -:  256:  }
        -:  257:  else
        -:  258:  {
    #####:  259:    built_in_props_p = &((ecma_extended_object_t *) object_p)->u.built_in;
        -:  260:  }
        -:  261:
    #####:  262:  return built_in_props_p->id;
        -:  263:} /* ecma_get_object_builtin_id */
        -:  264:
        -:  265:/**
        -:  266: * Get type of lexical environment.
        -:  267: *
        -:  268: * @return type of the lexical environment (ecma_lexical_environment_type_t)
        -:  269: */
        -:  270:inline ecma_lexical_environment_type_t JERRY_ATTR_PURE
    61922:  271:ecma_get_lex_env_type (const ecma_object_t *object_p) /**< lexical environment */
        -:  272:{
    61922:  273:  JERRY_ASSERT (object_p != NULL);
    61922:  274:  JERRY_ASSERT (ecma_is_lexical_environment (object_p));
        -:  275:
    61922:  276:  return (ecma_lexical_environment_type_t) (object_p->type_flags_refs & ECMA_OBJECT_TYPE_MASK);
        -:  277:} /* ecma_get_lex_env_type */
        -:  278:
        -:  279:/**
        -:  280: * Get lexical environment's bound object.
        -:  281: *
        -:  282: * @return pointer to ecma object
        -:  283: */
        -:  284:inline ecma_object_t *JERRY_ATTR_PURE
     4239:  285:ecma_get_lex_env_binding_object (const ecma_object_t *object_p) /**< object-bound lexical environment */
        -:  286:{
     4239:  287:  JERRY_ASSERT (object_p != NULL);
     4239:  288:  JERRY_ASSERT (ecma_is_lexical_environment (object_p));
        -:  289:#if ENABLED (JERRY_ES2015)
     4239:  290:  JERRY_ASSERT (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND
        -:  291:                || ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_HOME_OBJECT_BOUND);
        -:  292:#else /* !ENABLED (JERRY_ES2015) */
    #####:  293:  JERRY_ASSERT (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  294:#endif /* ENABLED (JERRY_ES2015) */
        -:  295:
     4239:  296:  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u1.bound_object_cp);
        -:  297:} /* ecma_get_lex_env_binding_object */
        -:  298:
        -:  299:/**
        -:  300: * Create a new lexical environment with the same property list as the passed lexical environment
        -:  301: *
        -:  302: * @return pointer to the newly created lexical environment
        -:  303: */
        -:  304:ecma_object_t *
    #####:  305:ecma_clone_decl_lexical_environment (ecma_object_t *lex_env_p, /**< declarative lexical environment */
        -:  306:                                     bool copy_values) /**< copy property values as well */
        -:  307:{
    #####:  308:  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####:  309:  JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
        -:  310:
    #####:  311:  ecma_object_t *outer_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####:  312:  ecma_object_t *new_lex_env_p = ecma_create_decl_lex_env (outer_lex_env_p);
        -:  313:
    #####:  314:  jmem_cpointer_t prop_iter_cp = lex_env_p->u1.property_list_cp;
    #####:  315:  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);
        -:  316:
    #####:  317:  ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  318:                                                                   prop_iter_cp);
    #####:  319:  if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  320:  {
    #####:  321:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  322:  }
        -:  323:
    #####:  324:  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);
        -:  325:
        -:  326:  do
        -:  327:  {
    #####:  328:    prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  329:
    #####:  330:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  331:
    #####:  332:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  333:
    #####:  334:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  335:    {
    #####:  336:      if (prop_iter_p->types[i] != ECMA_PROPERTY_TYPE_DELETED)
        -:  337:      {
    #####:  338:        JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (prop_iter_p->types[i]) == ECMA_PROPERTY_TYPE_NAMEDDATA);
        -:  339:
    #####:  340:        uint8_t prop_attributes = (uint8_t) (prop_iter_p->types[i] & ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  341:        ecma_string_t *name_p = ecma_string_from_property_name (prop_iter_p->types[i], prop_pair_p->names_cp[i]);
        -:  342:
        -:  343:        ecma_property_value_t *property_value_p;
    #####:  344:        property_value_p = ecma_create_named_data_property (new_lex_env_p, name_p, prop_attributes, NULL);
        -:  345:
    #####:  346:        ecma_deref_ecma_string (name_p);
        -:  347:
    #####:  348:        JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -:  349:
    #####:  350:        if (copy_values)
        -:  351:        {
    #####:  352:          property_value_p->value = ecma_copy_value_if_not_object (prop_pair_p->values[i].value);
        -:  353:        }
        -:  354:        else
        -:  355:        {
    #####:  356:          property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -:  357:        }
        -:  358:      }
        -:  359:    }
        -:  360:
    #####:  361:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  362:  }
    #####:  363:  while (prop_iter_cp != JMEM_CP_NULL);
        -:  364:
    #####:  365:  ecma_deref_object (lex_env_p);
    #####:  366:  return new_lex_env_p;
        -:  367:} /* ecma_clone_decl_lexical_environment */
        -:  368:
        -:  369:/**
        -:  370: * Create a property in an object and link it into
        -:  371: * the object's properties' linked-list (at start of the list).
        -:  372: *
        -:  373: * @return pointer to the newly created property value
        -:  374: */
        -:  375:static ecma_property_value_t *
    24892:  376:ecma_create_property (ecma_object_t *object_p, /**< the object */
        -:  377:                      ecma_string_t *name_p, /**< property name */
        -:  378:                      uint8_t type_and_flags, /**< type and flags, see ecma_property_info_t */
        -:  379:                      ecma_property_value_t value, /**< property value */
        -:  380:                      ecma_property_t **out_prop_p) /**< [out] the property is also returned
        -:  381:                                                     *         if this field is non-NULL */
        -:  382:{
        -:  383:  JERRY_ASSERT (ECMA_PROPERTY_PAIR_ITEM_COUNT == 2);
    24892:  384:  JERRY_ASSERT (name_p != NULL);
    24892:  385:  JERRY_ASSERT (object_p != NULL);
        -:  386:
    24892:  387:  jmem_cpointer_t *property_list_head_p = &object_p->u1.property_list_cp;
        -:  388:
    24892:  389:  if (*property_list_head_p != ECMA_NULL_POINTER)
        -:  390:  {
        -:  391:    /* If the first entry is free (deleted), it is reused. */
    15730:  392:    ecma_property_header_t *first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  393:                                                                          *property_list_head_p);
        -:  394:
        -:  395:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    15730:  396:    bool has_hashmap = false;
        -:  397:
    15730:  398:    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  399:    {
      419:  400:      property_list_head_p = &first_property_p->next_property_cp;
      419:  401:      first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  402:                                                    *property_list_head_p);
      419:  403:      has_hashmap = true;
        -:  404:    }
        -:  405:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -:  406:
    15730:  407:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (first_property_p));
        -:  408:
    15730:  409:    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_DELETED)
        -:  410:    {
     9830:  411:      ecma_property_pair_t *first_property_pair_p = (ecma_property_pair_t *) first_property_p;
        -:  412:
     9830:  413:      ecma_property_t name_type;
     9830:  414:      first_property_pair_p->names_cp[0] = ecma_string_to_property_name (name_p,
        -:  415:                                                                         &name_type);
     9830:  416:      first_property_p->types[0] = (ecma_property_t) (type_and_flags | name_type);
        -:  417:
     9830:  418:      ecma_property_t *property_p = first_property_p->types + 0;
        -:  419:
     9830:  420:      JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 0);
        -:  421:
     9830:  422:      if (out_prop_p != NULL)
        -:  423:      {
        3:  424:        *out_prop_p = property_p;
        -:  425:      }
        -:  426:
     9830:  427:      first_property_pair_p->values[0] = value;
        -:  428:
        -:  429:#if ENABLED (JERRY_PROPRETY_HASHMAP)
        -:  430:      /* The property must be fully initialized before ecma_property_hashmap_insert
        -:  431:       * is called, because the insert operation may reallocate the hashmap, and
        -:  432:       * that triggers garbage collection which scans all properties of all objects.
        -:  433:       * A not fully initialized but queued property may cause a crash. */
        -:  434:
     9830:  435:      if (has_hashmap)
        -:  436:      {
      210:  437:        ecma_property_hashmap_insert (object_p,
        -:  438:                                      name_p,
        -:  439:                                      first_property_pair_p,
        -:  440:                                      0);
        -:  441:      }
        -:  442:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -:  443:
     9830:  444:      return first_property_pair_p->values + 0;
        -:  445:    }
        -:  446:  }
        -:  447:
        -:  448:  /* Otherwise we create a new property pair and use its second value. */
    15062:  449:  ecma_property_pair_t *first_property_pair_p = ecma_alloc_property_pair ();
        -:  450:
        -:  451:  /* Need to query property_list_head_p again and recheck the existennce
        -:  452:   * of property hasmap, because ecma_alloc_property_pair may delete them. */
    15062:  453:  property_list_head_p = &object_p->u1.property_list_cp;
        -:  454:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    15062:  455:  bool has_hashmap = false;
        -:  456:
    15062:  457:  if (*property_list_head_p != ECMA_NULL_POINTER)
        -:  458:  {
     5900:  459:    ecma_property_header_t *first_property_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  460:                                                                          *property_list_head_p);
        -:  461:
     5900:  462:    if (first_property_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  463:    {
      209:  464:      property_list_head_p = &first_property_p->next_property_cp;
      209:  465:      has_hashmap = true;
        -:  466:    }
        -:  467:  }
        -:  468:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -:  469:
        -:  470:  /* Just copy the previous value (no need to decompress, compress). */
    15062:  471:  first_property_pair_p->header.next_property_cp = *property_list_head_p;
    15062:  472:  first_property_pair_p->header.types[0] = ECMA_PROPERTY_TYPE_DELETED;
    15062:  473:  first_property_pair_p->names_cp[0] = LIT_INTERNAL_MAGIC_STRING_DELETED;
        -:  474:
    15062:  475:  ecma_property_t name_type;
    15062:  476:  first_property_pair_p->names_cp[1] = ecma_string_to_property_name (name_p,
        -:  477:                                                                     &name_type);
        -:  478:
    15062:  479:  first_property_pair_p->header.types[1] = (ecma_property_t) (type_and_flags | name_type);
        -:  480:
    15062:  481:  ECMA_SET_NON_NULL_POINTER (*property_list_head_p, &first_property_pair_p->header);
        -:  482:
    15062:  483:  ecma_property_t *property_p = first_property_pair_p->header.types + 1;
        -:  484:
    15062:  485:  JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p) == first_property_pair_p->values + 1);
        -:  486:
    15062:  487:  if (out_prop_p != NULL)
        -:  488:  {
        8:  489:    *out_prop_p = property_p;
        -:  490:  }
        -:  491:
    15062:  492:  first_property_pair_p->values[1] = value;
        -:  493:
        -:  494:#if ENABLED (JERRY_PROPRETY_HASHMAP)
        -:  495:  /* See the comment before the other ecma_property_hashmap_insert above. */
        -:  496:
    15062:  497:  if (has_hashmap)
        -:  498:  {
      209:  499:    ecma_property_hashmap_insert (object_p,
        -:  500:                                  name_p,
        -:  501:                                  first_property_pair_p,
        -:  502:                                  1);
        -:  503:  }
        -:  504:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -:  505:
    15062:  506:  return first_property_pair_p->values + 1;
        -:  507:} /* ecma_create_property */
        -:  508:
        -:  509:/**
        -:  510: * Create named data property with given name, attributes and undefined value
        -:  511: * in the specified object.
        -:  512: *
        -:  513: * @return pointer to the newly created property value
        -:  514: */
        -:  515:ecma_property_value_t *
    22274:  516:ecma_create_named_data_property (ecma_object_t *object_p, /**< object */
        -:  517:                                 ecma_string_t *name_p, /**< property name */
        -:  518:                                 uint8_t prop_attributes, /**< property attributes (See: ecma_property_flags_t) */
        -:  519:                                 ecma_property_t **out_prop_p) /**< [out] the property is also returned
        -:  520:                                                                *         if this field is non-NULL */
        -:  521:{
    22274:  522:  JERRY_ASSERT (object_p != NULL && name_p != NULL);
    22274:  523:  JERRY_ASSERT (ecma_is_lexical_environment (object_p)
        -:  524:                || !ecma_op_object_is_fast_array (object_p));
    22274:  525:  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);
    22274:  526:  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE) == 0);
        -:  527:
    22274:  528:  uint8_t type_and_flags = ECMA_PROPERTY_TYPE_NAMEDDATA | prop_attributes;
        -:  529:
        -:  530:  ecma_property_value_t value;
    22274:  531:  value.value = ECMA_VALUE_UNDEFINED;
        -:  532:
    22274:  533:  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);
        -:  534:} /* ecma_create_named_data_property */
        -:  535:
        -:  536:/**
        -:  537: * Create named accessor property with given name, attributes, getter and setter.
        -:  538: *
        -:  539: * @return pointer to the newly created property value
        -:  540: */
        -:  541:ecma_property_value_t *
     2618:  542:ecma_create_named_accessor_property (ecma_object_t *object_p, /**< object */
        -:  543:                                     ecma_string_t *name_p, /**< property name */
        -:  544:                                     ecma_object_t *get_p, /**< getter */
        -:  545:                                     ecma_object_t *set_p, /**< setter */
        -:  546:                                     uint8_t prop_attributes, /**< property attributes */
        -:  547:                                     ecma_property_t **out_prop_p) /**< [out] the property is also returned
        -:  548:                                                                    *         if this field is non-NULL */
        -:  549:{
     2618:  550:  JERRY_ASSERT (object_p != NULL && name_p != NULL);
     2618:  551:  JERRY_ASSERT (ecma_is_lexical_environment (object_p)
        -:  552:                || !ecma_op_object_is_fast_array (object_p));
     2618:  553:  JERRY_ASSERT (ecma_find_named_property (object_p, name_p) == NULL);
     2618:  554:  JERRY_ASSERT ((prop_attributes & ~ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE) == 0);
        -:  555:
     2618:  556:  uint8_t type_and_flags = ECMA_PROPERTY_TYPE_NAMEDACCESSOR | prop_attributes;
        -:  557:
        -:  558:  ecma_property_value_t value;
        -:  559:#if ENABLED (JERRY_CPOINTER_32_BIT)
        -:  560:  ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -:  561:  getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));
        -:  562:  ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, get_p);
        -:  563:  ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, set_p);
        -:  564:  ECMA_SET_NON_NULL_POINTER (value.getter_setter_pair_cp, getter_setter_pair_p);
        -:  565:#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */
     2618:  566:  ECMA_SET_POINTER (value.getter_setter_pair.getter_cp, get_p);
     2618:  567:  ECMA_SET_POINTER (value.getter_setter_pair.setter_cp, set_p);
        -:  568:#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */
        -:  569:
     2618:  570:  return ecma_create_property (object_p, name_p, type_and_flags, value, out_prop_p);
        -:  571:} /* ecma_create_named_accessor_property */
        -:  572:
        -:  573:/**
        -:  574: * Find named data property or named access property in specified object.
        -:  575: *
        -:  576: * @return pointer to the property, if it is found,
        -:  577: *         NULL - otherwise.
        -:  578: */
        -:  579:ecma_property_t *
   116566:  580:ecma_find_named_property (ecma_object_t *obj_p, /**< object to find property in */
        -:  581:                          ecma_string_t *name_p) /**< property's name */
        -:  582:{
   116566:  583:  JERRY_ASSERT (obj_p != NULL);
   116566:  584:  JERRY_ASSERT (name_p != NULL);
   116566:  585:  JERRY_ASSERT (ecma_is_lexical_environment (obj_p)
        -:  586:                || !ecma_op_object_is_fast_array (obj_p));
        -:  587:
   116566:  588:  ecma_property_t *property_p = NULL;
        -:  589:
        -:  590:#if ENABLED (JERRY_LCACHE)
   116566:  591:  property_p = ecma_lcache_lookup (obj_p, name_p);
   116566:  592:  if (property_p != NULL)
        -:  593:  {
    23535:  594:    return property_p;
        -:  595:  }
        -:  596:#endif /* ENABLED (JERRY_LCACHE) */
        -:  597:
    93031:  598:  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -:  599:
        -:  600:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    93031:  601:  if (prop_iter_cp != JMEM_CP_NULL)
        -:  602:  {
    66829:  603:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  604:                                                                     prop_iter_cp);
    66829:  605:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  606:    {
     1256:  607:      jmem_cpointer_t property_real_name_cp;
     1256:  608:      property_p = ecma_property_hashmap_find ((ecma_property_hashmap_t *) prop_iter_p,
        -:  609:                                               name_p,
        -:  610:                                               &property_real_name_cp);
        -:  611:#if ENABLED (JERRY_LCACHE)
     1256:  612:      if (property_p != NULL
    #####:  613:          && !ecma_is_property_lcached (property_p))
        -:  614:      {
    #####:  615:        ecma_lcache_insert (obj_p, property_real_name_cp, property_p);
        -:  616:      }
        -:  617:#endif /* ENABLED (JERRY_LCACHE) */
     1256:  618:      return property_p;
        -:  619:    }
        -:  620:  }
        -:  621:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -:  622:
        -:  623:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    91775:  624:  uint32_t steps = 0;
        -:  625:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
    91775:  626:  jmem_cpointer_t property_name_cp = ECMA_NULL_POINTER;
        -:  627:
    91775:  628:  if (ECMA_IS_DIRECT_STRING (name_p))
        -:  629:  {
    61611:  630:    ecma_property_t prop_name_type = (ecma_property_t) ECMA_GET_DIRECT_STRING_TYPE (name_p);
    61611:  631:    property_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (name_p);
        -:  632:
    61611:  633:    JERRY_ASSERT (prop_name_type > 0);
        -:  634:
  1323990:  635:    while (prop_iter_cp != JMEM_CP_NULL)
        -:  636:    {
  1202097:  637:      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  638:                                                                       prop_iter_cp);
        -:  639:
  1202097:  640:      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  641:
  1202097:  642:      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  643:
  1202097:  644:      if (prop_pair_p->names_cp[0] == property_name_cp
        4:  645:          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == prop_name_type)
        -:  646:      {
        2:  647:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[0]));
        -:  648:
        2:  649:        property_p = prop_iter_p->types + 0;
        2:  650:        break;
        -:  651:      }
        -:  652:
  1202095:  653:      if (prop_pair_p->names_cp[1] == property_name_cp
     1329:  654:          && ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == prop_name_type)
        -:  655:      {
     1327:  656:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (prop_iter_p->types[1]));
        -:  657:
     1327:  658:        property_p = prop_iter_p->types + 1;
     1327:  659:        break;
        -:  660:      }
        -:  661:
        -:  662:#if ENABLED (JERRY_PROPRETY_HASHMAP)
  1200768:  663:      steps++;
        -:  664:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
  1200768:  665:      prop_iter_cp = prop_iter_p->next_property_cp;
        -:  666:    }
        -:  667:  }
        -:  668:  else
        -:  669:  {
    97100:  670:    while (prop_iter_cp != JMEM_CP_NULL)
        -:  671:    {
    39410:  672:      ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  673:                                                                       prop_iter_cp);
        -:  674:
    39410:  675:      JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  676:
    39410:  677:      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  678:
    39410:  679:      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[0]) == ECMA_DIRECT_STRING_PTR)
        -:  680:      {
    17143:  681:        property_name_cp = prop_pair_p->names_cp[0];
    17143:  682:        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);
        -:  683:
    17143:  684:        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))
        -:  685:        {
       11:  686:          property_p = prop_iter_p->types + 0;
       11:  687:          break;
        -:  688:        }
        -:  689:      }
        -:  690:
    39399:  691:      if (ECMA_PROPERTY_GET_NAME_TYPE (prop_iter_p->types[1]) == ECMA_DIRECT_STRING_PTR)
        -:  692:      {
    23666:  693:        property_name_cp = prop_pair_p->names_cp[1];
    23666:  694:        ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, property_name_cp);
        -:  695:
    23666:  696:        if (ecma_compare_ecma_non_direct_strings (name_p, prop_name_p))
        -:  697:        {
     2627:  698:          property_p = prop_iter_p->types + 1;
     2627:  699:          break;
        -:  700:        }
        -:  701:      }
        -:  702:
        -:  703:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    36772:  704:      steps++;
        -:  705:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
    36772:  706:      prop_iter_cp = prop_iter_p->next_property_cp;
        -:  707:    }
        -:  708:  }
        -:  709:
        -:  710:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    91775:  711:  if (steps >= (ECMA_PROPERTY_HASMAP_MINIMUM_SIZE / 2))
        -:  712:  {
     2578:  713:    ecma_property_hashmap_create (obj_p);
        -:  714:  }
        -:  715:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -:  716:
        -:  717:#if ENABLED (JERRY_LCACHE)
    91775:  718:  if (property_p != NULL
     3967:  719:      && !ecma_is_property_lcached (property_p))
        -:  720:  {
     3967:  721:    ecma_lcache_insert (obj_p, property_name_cp, property_p);
        -:  722:  }
        -:  723:#endif /* ENABLED (JERRY_LCACHE) */
        -:  724:
    91775:  725:  return property_p;
        -:  726:} /* ecma_find_named_property */
        -:  727:
        -:  728:/**
        -:  729: * Get named data property or named access property in specified object.
        -:  730: *
        -:  731: * Warning:
        -:  732: *         the property must exist
        -:  733: *
        -:  734: * @return pointer to the property, if it is found,
        -:  735: *         NULL - otherwise.
        -:  736: */
        -:  737:ecma_property_value_t *
    #####:  738:ecma_get_named_data_property (ecma_object_t *obj_p, /**< object to find property in */
        -:  739:                              ecma_string_t *name_p) /**< property's name */
        -:  740:{
    #####:  741:  JERRY_ASSERT (obj_p != NULL);
    #####:  742:  JERRY_ASSERT (name_p != NULL);
    #####:  743:  JERRY_ASSERT (ecma_is_lexical_environment (obj_p)
        -:  744:                || !ecma_op_object_is_fast_array (obj_p));
        -:  745:
    #####:  746:  ecma_property_t *property_p = ecma_find_named_property (obj_p, name_p);
        -:  747:
    #####:  748:  JERRY_ASSERT (property_p != NULL
        -:  749:                && ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA);
        -:  750:
    #####:  751:  return ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  752:} /* ecma_get_named_data_property */
        -:  753:
        -:  754:/**
        -:  755: * Free property values and change their type to deleted.
        -:  756: */
        -:  757:void
    23528:  758:ecma_free_property (ecma_object_t *object_p, /**< object the property belongs to */
        -:  759:                    jmem_cpointer_t name_cp, /**< name of the property or ECMA_NULL_POINTER */
        -:  760:                    ecma_property_t *property_p) /**< property */
        -:  761:{
    23528:  762:  JERRY_ASSERT (object_p != NULL && property_p != NULL);
        -:  763:
    23528:  764:  switch (ECMA_PROPERTY_GET_TYPE (*property_p))
        -:  765:  {
    20912:  766:    case ECMA_PROPERTY_TYPE_NAMEDDATA:
        -:  767:    {
    20912:  768:      ecma_free_value_if_not_object (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    20912:  769:      break;
        -:  770:    }
     2616:  771:    case ECMA_PROPERTY_TYPE_NAMEDACCESSOR:
        -:  772:    {
        -:  773:#if ENABLED (JERRY_CPOINTER_32_BIT)
        -:  774:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -:  775:      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,
        -:  776:                                                        ECMA_PROPERTY_VALUE_PTR (property_p)->getter_setter_pair_cp);
        -:  777:      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));
        -:  778:#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */
     2616:  779:      break;
        -:  780:    }
    #####:  781:    default:
        -:  782:    {
    #####:  783:      JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_INTERNAL);
        -:  784:
        -:  785:      /* Must be a native pointer. */
    #####:  786:      JERRY_ASSERT (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC
        -:  787:                    && name_cp >= LIT_FIRST_INTERNAL_MAGIC_STRING);
    #####:  788:      break;
        -:  789:    }
        -:  790:  }
        -:  791:
        -:  792:#if ENABLED (JERRY_LCACHE)
    23528:  793:  if (ecma_is_property_lcached (property_p))
        -:  794:  {
     3862:  795:    ecma_lcache_invalidate (object_p, name_cp, property_p);
        -:  796:  }
        -:  797:#endif /* ENABLED (JERRY_LCACHE) */
        -:  798:
    23528:  799:  if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_PTR)
        -:  800:  {
     9156:  801:    ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, name_cp);
     9156:  802:    ecma_deref_ecma_string (prop_name_p);
        -:  803:  }
    23528:  804:} /* ecma_free_property */
        -:  805:
        -:  806:/**
        -:  807: * Delete the object's property referenced by its value pointer.
        -:  808: *
        -:  809: * Note: specified property must be owned by specified object.
        -:  810: */
        -:  811:void
    #####:  812:ecma_delete_property (ecma_object_t *object_p, /**< object */
        -:  813:                      ecma_property_value_t *prop_value_p) /**< property value reference */
        -:  814:{
    #####:  815:  jmem_cpointer_t cur_prop_cp = object_p->u1.property_list_cp;
        -:  816:
    #####:  817:  ecma_property_header_t *prev_prop_p = NULL;
        -:  818:
        -:  819:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    #####:  820:  ecma_property_hashmap_delete_status hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_NO_HASHMAP;
        -:  821:
    #####:  822:  if (cur_prop_cp != JMEM_CP_NULL)
        -:  823:  {
    #####:  824:    ecma_property_header_t *cur_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  825:                                                                    cur_prop_cp);
        -:  826:
    #####:  827:    if (cur_prop_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  828:    {
    #####:  829:      prev_prop_p = cur_prop_p;
    #####:  830:      cur_prop_cp = cur_prop_p->next_property_cp;
    #####:  831:      hashmap_status = ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP;
        -:  832:    }
        -:  833:  }
        -:  834:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -:  835:
    #####:  836:  while (cur_prop_cp != JMEM_CP_NULL)
        -:  837:  {
    #####:  838:    ecma_property_header_t *cur_prop_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -:  839:                                                                    cur_prop_cp);
        -:  840:
    #####:  841:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (cur_prop_p));
        -:  842:
    #####:  843:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) cur_prop_p;
        -:  844:
    #####:  845:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  846:    {
    #####:  847:      if ((prop_pair_p->values + i) == prop_value_p)
        -:  848:      {
    #####:  849:        JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (cur_prop_p->types[i]) != ECMA_PROPERTY_TYPE_SPECIAL);
        -:  850:
        -:  851:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    #####:  852:        if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_HAS_HASHMAP)
        -:  853:        {
    #####:  854:          hashmap_status = ecma_property_hashmap_delete (object_p,
    #####:  855:                                                         prop_pair_p->names_cp[i],
    #####:  856:                                                         cur_prop_p->types + i);
        -:  857:        }
        -:  858:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -:  859:
    #####:  860:        ecma_free_property (object_p, prop_pair_p->names_cp[i], cur_prop_p->types + i);
    #####:  861:        cur_prop_p->types[i] = ECMA_PROPERTY_TYPE_DELETED;
    #####:  862:        prop_pair_p->names_cp[i] = LIT_INTERNAL_MAGIC_STRING_DELETED;
        -:  863:
        -:  864:        JERRY_ASSERT (ECMA_PROPERTY_PAIR_ITEM_COUNT == 2);
        -:  865:
    #####:  866:        if (cur_prop_p->types[1 - i] != ECMA_PROPERTY_TYPE_DELETED)
        -:  867:        {
        -:  868:#if ENABLED (JERRY_PROPRETY_HASHMAP)
        -:  869:          /* The other property is still valid. */
    #####:  870:          if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP)
        -:  871:          {
    #####:  872:            ecma_property_hashmap_free (object_p);
    #####:  873:            ecma_property_hashmap_create (object_p);
        -:  874:          }
        -:  875:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
    #####:  876:          return;
        -:  877:        }
        -:  878:
    #####:  879:        JERRY_ASSERT (cur_prop_p->types[i] == ECMA_PROPERTY_TYPE_DELETED);
        -:  880:
    #####:  881:        if (prev_prop_p == NULL)
        -:  882:        {
    #####:  883:          object_p->u1.property_list_cp = cur_prop_p->next_property_cp;
        -:  884:        }
        -:  885:        else
        -:  886:        {
    #####:  887:          prev_prop_p->next_property_cp = cur_prop_p->next_property_cp;
        -:  888:        }
        -:  889:
    #####:  890:        ecma_dealloc_property_pair ((ecma_property_pair_t *) cur_prop_p);
        -:  891:
        -:  892:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    #####:  893:        if (hashmap_status == ECMA_PROPERTY_HASHMAP_DELETE_RECREATE_HASHMAP)
        -:  894:        {
    #####:  895:          ecma_property_hashmap_free (object_p);
    #####:  896:          ecma_property_hashmap_create (object_p);
        -:  897:        }
        -:  898:#endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
    #####:  899:        return;
        -:  900:      }
        -:  901:    }
        -:  902:
    #####:  903:    prev_prop_p = cur_prop_p;
    #####:  904:    cur_prop_cp = cur_prop_p->next_property_cp;
        -:  905:  }
        -:  906:} /* ecma_delete_property */
        -:  907:
        -:  908:/**
        -:  909: * Check whether the object contains a property
        -:  910: */
        -:  911:static void
     6554:  912:ecma_assert_object_contains_the_property (const ecma_object_t *object_p, /**< ecma-object */
        -:  913:                                          const ecma_property_value_t *prop_value_p, /**< property value */
        -:  914:                                          ecma_property_types_t type) /**< expected property type */
        -:  915:{
        -:  916:#ifndef JERRY_NDEBUG
     6554:  917:  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;
     6554:  918:  JERRY_ASSERT (prop_iter_cp != JMEM_CP_NULL);
        -:  919:
     6554:  920:  ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  921:
     6554:  922:  if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  923:  {
    #####:  924:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  925:  }
        -:  926:
    17057:  927:  while (prop_iter_cp != JMEM_CP_NULL)
        -:  928:  {
    10503:  929:    prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -:  930:
    10503:  931:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  932:
    10503:  933:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  934:
    21025:  935:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -:  936:    {
    17076:  937:      if ((prop_pair_p->values + i) == prop_value_p)
        -:  938:      {
     6554:  939:        JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (prop_pair_p->header.types[i]) == type);
     6554:  940:        return;
        -:  941:      }
        -:  942:    }
        -:  943:
     3949:  944:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  945:  }
        -:  946:#else /* JERRY_NDEBUG */
        -:  947:  JERRY_UNUSED (object_p);
        -:  948:  JERRY_UNUSED (prop_value_p);
        -:  949:  JERRY_UNUSED (type);
        -:  950:#endif /* !JERRY_NDEBUG */
        -:  951:} /* ecma_assert_object_contains_the_property */
        -:  952:
        -:  953:/**
        -:  954: * Assign value to named data property
        -:  955: *
        -:  956: * Note:
        -:  957: *      value previously stored in the property is freed
        -:  958: */
        -:  959:inline void JERRY_ATTR_ALWAYS_INLINE
     6554:  960:ecma_named_data_property_assign_value (ecma_object_t *obj_p, /**< object */
        -:  961:                                       ecma_property_value_t *prop_value_p, /**< property value reference */
        -:  962:                                       ecma_value_t value) /**< value to assign */
        -:  963:{
     6554:  964:  ecma_assert_object_contains_the_property (obj_p, prop_value_p, ECMA_PROPERTY_TYPE_NAMEDDATA);
        -:  965:
     6554:  966:  ecma_value_assign_value (&prop_value_p->value, value);
     6554:  967:} /* ecma_named_data_property_assign_value */
        -:  968:
        -:  969:/**
        -:  970: * Get named accessor property getter-setter-pair
        -:  971: *
        -:  972: * @return pointer to object's getter-setter pair
        -:  973: */
        -:  974:ecma_getter_setter_pointers_t *
      292:  975:ecma_get_named_accessor_property (const ecma_property_value_t *prop_value_p) /**< property value reference */
        -:  976:{
        -:  977:#if ENABLED (JERRY_CPOINTER_32_BIT)
        -:  978:  return ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t, prop_value_p->getter_setter_pair_cp);
        -:  979:#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */
      292:  980:  return (ecma_getter_setter_pointers_t *) &prop_value_p->getter_setter_pair;
        -:  981:#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */
        -:  982:} /* ecma_get_named_accessor_property */
        -:  983:
        -:  984:/**
        -:  985: * Set getter of named accessor property
        -:  986: */
        -:  987:void
    #####:  988:ecma_set_named_accessor_property_getter (ecma_object_t *object_p, /**< the property's container */
        -:  989:                                         ecma_property_value_t *prop_value_p, /**< property value reference */
        -:  990:                                         ecma_object_t *getter_p) /**< getter object */
        -:  991:{
    #####:  992:  ecma_assert_object_contains_the_property (object_p, prop_value_p, ECMA_PROPERTY_TYPE_NAMEDACCESSOR);
        -:  993:
        -:  994:#if ENABLED (JERRY_CPOINTER_32_BIT)
        -:  995:  ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -:  996:  getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,
        -:  997:                                                    prop_value_p->getter_setter_pair_cp);
        -:  998:  ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, getter_p);
        -:  999:#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */
    #####: 1000:  ECMA_SET_POINTER (prop_value_p->getter_setter_pair.getter_cp, getter_p);
        -: 1001:#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */
    #####: 1002:} /* ecma_set_named_accessor_property_getter */
        -: 1003:
        -: 1004:/**
        -: 1005: * Set setter of named accessor property
        -: 1006: */
        -: 1007:void
    #####: 1008:ecma_set_named_accessor_property_setter (ecma_object_t *object_p, /**< the property's container */
        -: 1009:                                         ecma_property_value_t *prop_value_p, /**< property value reference */
        -: 1010:                                         ecma_object_t *setter_p) /**< setter object */
        -: 1011:{
    #####: 1012:  ecma_assert_object_contains_the_property (object_p, prop_value_p, ECMA_PROPERTY_TYPE_NAMEDACCESSOR);
        -: 1013:
        -: 1014:#if ENABLED (JERRY_CPOINTER_32_BIT)
        -: 1015:  ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -: 1016:  getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,
        -: 1017:                                                    prop_value_p->getter_setter_pair_cp);
        -: 1018:  ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, setter_p);
        -: 1019:#else /* !ENABLED (JERRY_CPOINTER_32_BIT) */
    #####: 1020:  ECMA_SET_POINTER (prop_value_p->getter_setter_pair.setter_cp, setter_p);
        -: 1021:#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */
    #####: 1022:} /* ecma_set_named_accessor_property_setter */
        -: 1023:
        -: 1024:/**
        -: 1025: * Get property's 'Writable' attribute value
        -: 1026: *
        -: 1027: * @return true - property is writable,
        -: 1028: *         false - otherwise
        -: 1029: */
        -: 1030:inline bool JERRY_ATTR_ALWAYS_INLINE
     6552: 1031:ecma_is_property_writable (ecma_property_t property) /**< property */
        -: 1032:{
     6552: 1033:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_NAMEDDATA
        -: 1034:                || ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_VIRTUAL);
        -: 1035:
     6552: 1036:  return (property & ECMA_PROPERTY_FLAG_WRITABLE) != 0;
        -: 1037:} /* ecma_is_property_writable */
        -: 1038:
        -: 1039:/**
        -: 1040: * Set property's 'Writable' attribute value
        -: 1041: */
        -: 1042:void
    #####: 1043:ecma_set_property_writable_attr (ecma_property_t *property_p, /**< [in,out] property */
        -: 1044:                                 bool is_writable) /**< new value for writable flag */
        -: 1045:{
    #####: 1046:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA);
        -: 1047:
    #####: 1048:  if (is_writable)
        -: 1049:  {
    #####: 1050:    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_WRITABLE);
        -: 1051:  }
        -: 1052:  else
        -: 1053:  {
    #####: 1054:    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_WRITABLE);
        -: 1055:  }
    #####: 1056:} /* ecma_set_property_writable_attr */
        -: 1057:
        -: 1058:/**
        -: 1059: * Get property's 'Enumerable' attribute value
        -: 1060: *
        -: 1061: * @return true - property is enumerable,
        -: 1062: *         false - otherwise
        -: 1063: */
        -: 1064:inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1065:ecma_is_property_enumerable (ecma_property_t property) /**< property */
        -: 1066:{
    #####: 1067:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_NAMEDDATA
        -: 1068:                || ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR
        -: 1069:                || ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_VIRTUAL);
        -: 1070:
    #####: 1071:  return (property & ECMA_PROPERTY_FLAG_ENUMERABLE) != 0;
        -: 1072:} /* ecma_is_property_enumerable */
        -: 1073:
        -: 1074:/**
        -: 1075: * Set property's 'Enumerable' attribute value
        -: 1076: */
        -: 1077:void
    #####: 1078:ecma_set_property_enumerable_attr (ecma_property_t *property_p, /**< [in,out] property */
        -: 1079:                                   bool is_enumerable) /**< new value for enumerable flag */
        -: 1080:{
    #####: 1081:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA
        -: 1082:                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);
        -: 1083:
    #####: 1084:  if (is_enumerable)
        -: 1085:  {
    #####: 1086:    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_ENUMERABLE);
        -: 1087:  }
        -: 1088:  else
        -: 1089:  {
    #####: 1090:    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
        -: 1091:  }
    #####: 1092:} /* ecma_set_property_enumerable_attr */
        -: 1093:
        -: 1094:/**
        -: 1095: * Get property's 'Configurable' attribute value
        -: 1096: *
        -: 1097: * @return true - property is configurable,
        -: 1098: *         false - otherwise
        -: 1099: */
        -: 1100:inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1101:ecma_is_property_configurable (ecma_property_t property) /**< property */
        -: 1102:{
    #####: 1103:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_NAMEDDATA
        -: 1104:                || ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR
        -: 1105:                || ECMA_PROPERTY_GET_TYPE (property) == ECMA_PROPERTY_TYPE_VIRTUAL);
        -: 1106:
    #####: 1107:  return (property & ECMA_PROPERTY_FLAG_CONFIGURABLE) != 0;
        -: 1108:} /* ecma_is_property_configurable */
        -: 1109:
        -: 1110:/**
        -: 1111: * Set property's 'Configurable' attribute value
        -: 1112: */
        -: 1113:void
    #####: 1114:ecma_set_property_configurable_attr (ecma_property_t *property_p, /**< [in,out] property */
        -: 1115:                                     bool is_configurable) /**< new value for configurable flag */
        -: 1116:{
    #####: 1117:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA
        -: 1118:                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);
        -: 1119:
    #####: 1120:  if (is_configurable)
        -: 1121:  {
    #####: 1122:    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_CONFIGURABLE);
        -: 1123:  }
        -: 1124:  else
        -: 1125:  {
    #####: 1126:    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_CONFIGURABLE);
        -: 1127:  }
    #####: 1128:} /* ecma_set_property_configurable_attr */
        -: 1129:
        -: 1130:#if ENABLED (JERRY_LCACHE)
        -: 1131:
        -: 1132:/**
        -: 1133: * Check whether the property is registered in LCache
        -: 1134: *
        -: 1135: * @return true / false
        -: 1136: */
        -: 1137:inline bool JERRY_ATTR_ALWAYS_INLINE
    35282: 1138:ecma_is_property_lcached (ecma_property_t *property_p) /**< property */
        -: 1139:{
    62777: 1140:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA
        -: 1141:                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR
        -: 1142:                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_INTERNAL);
        -: 1143:
    62777: 1144:  return (*property_p & ECMA_PROPERTY_FLAG_LCACHED) != 0;
        -: 1145:} /* ecma_is_property_lcached */
        -: 1146:
        -: 1147:/**
        -: 1148: * Set value of flag indicating whether the property is registered in LCache
        -: 1149: */
        -: 1150:inline void JERRY_ATTR_ALWAYS_INLINE
     7914: 1151:ecma_set_property_lcached (ecma_property_t *property_p, /**< property */
        -: 1152:                           bool is_lcached) /**< new value for lcached flag */
        -: 1153:{
     7914: 1154:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA
        -: 1155:                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR
        -: 1156:                || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_INTERNAL);
        -: 1157:
     7914: 1158:  if (is_lcached)
        -: 1159:  {
     3967: 1160:    *property_p = (uint8_t) (*property_p | ECMA_PROPERTY_FLAG_LCACHED);
        -: 1161:  }
        -: 1162:  else
        -: 1163:  {
     3947: 1164:    *property_p = (uint8_t) (*property_p & ~ECMA_PROPERTY_FLAG_LCACHED);
        -: 1165:  }
     7914: 1166:} /* ecma_set_property_lcached */
        -: 1167:
        -: 1168:#endif /* ENABLED (JERRY_LCACHE) */
        -: 1169:
        -: 1170:/**
        -: 1171: * Construct empty property descriptor, i.e.:
        -: 1172: *  property descriptor with all is_defined flags set to false and the rest - to default value.
        -: 1173: *
        -: 1174: * @return empty property descriptor
        -: 1175: */
        -: 1176:ecma_property_descriptor_t
     2619: 1177:ecma_make_empty_property_descriptor (void)
        -: 1178:{
        -: 1179:  ecma_property_descriptor_t prop_desc;
        -: 1180:
     2619: 1181:  prop_desc.flags = 0;
     2619: 1182:  prop_desc.value = ECMA_VALUE_UNDEFINED;
     2619: 1183:  prop_desc.get_p = NULL;
     2619: 1184:  prop_desc.set_p = NULL;
        -: 1185:
     2619: 1186:  return prop_desc;
        -: 1187:} /* ecma_make_empty_property_descriptor */
        -: 1188:
        -: 1189:/**
        -: 1190: * Free values contained in the property descriptor
        -: 1191: * and make it empty property descriptor
        -: 1192: */
        -: 1193:void
    #####: 1194:ecma_free_property_descriptor (ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 1195:{
    #####: 1196:  if (prop_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)
        -: 1197:  {
    #####: 1198:    ecma_free_value (prop_desc_p->value);
        -: 1199:  }
        -: 1200:
    #####: 1201:  if ((prop_desc_p->flags & ECMA_PROP_IS_GET_DEFINED)
    #####: 1202:      && prop_desc_p->get_p != NULL)
        -: 1203:  {
    #####: 1204:    ecma_deref_object (prop_desc_p->get_p);
        -: 1205:  }
        -: 1206:
    #####: 1207:  if ((prop_desc_p->flags & ECMA_PROP_IS_SET_DEFINED)
    #####: 1208:      && prop_desc_p->set_p != NULL)
        -: 1209:  {
    #####: 1210:    ecma_deref_object (prop_desc_p->set_p);
        -: 1211:  }
        -: 1212:
    #####: 1213:  *prop_desc_p = ecma_make_empty_property_descriptor ();
    #####: 1214:} /* ecma_free_property_descriptor */
        -: 1215:
        -: 1216:/**
        -: 1217: * The size of error reference must be 8 bytes to use jmem_pools_alloc().
        -: 1218: */
        -: 1219:JERRY_STATIC_ASSERT (sizeof (ecma_error_reference_t) == 8,
        -: 1220:                     ecma_error_reference_size_must_be_8_bytes);
        -: 1221:
        -: 1222:/**
        -: 1223: * Create an error reference from a given value.
        -: 1224: *
        -: 1225: * Note:
        -: 1226: *   Reference of the value is taken.
        -: 1227: *
        -: 1228: * @return error reference value
        -: 1229: */
        -: 1230:ecma_value_t
    #####: 1231:ecma_create_error_reference (ecma_value_t value, /**< referenced value */
        -: 1232:                             bool is_exception) /**< error reference is an exception */
        -: 1233:{
    #####: 1234:  ecma_error_reference_t *error_ref_p = (ecma_error_reference_t *) jmem_pools_alloc (sizeof (ecma_error_reference_t));
        -: 1235:
    #####: 1236:  error_ref_p->refs_and_flags = ECMA_ERROR_REF_ONE | (is_exception ? 0 : ECMA_ERROR_REF_ABORT);
    #####: 1237:  error_ref_p->value = value;
    #####: 1238:  return ecma_make_error_reference_value (error_ref_p);
        -: 1239:} /* ecma_create_error_reference */
        -: 1240:
        -: 1241:/**
        -: 1242: * Create an error reference from the currently thrown error value.
        -: 1243: *
        -: 1244: * @return error reference value
        -: 1245: */
        -: 1246:ecma_value_t
    #####: 1247:ecma_create_error_reference_from_context (void)
        -: 1248:{
    #####: 1249:  bool is_abort = jcontext_has_pending_abort ();
        -: 1250:
    #####: 1251:  if (is_abort)
        -: 1252:  {
    #####: 1253:    jcontext_set_abort_flag (false);
        -: 1254:  }
    #####: 1255:  return ecma_create_error_reference (jcontext_take_exception (), !is_abort);
        -: 1256:} /* ecma_create_error_reference_from_context */
        -: 1257:
        -: 1258:/**
        -: 1259: * Create an error reference from a given object.
        -: 1260: *
        -: 1261: * Note:
        -: 1262: *   Reference of the value is taken.
        -: 1263: *
        -: 1264: * @return error reference value
        -: 1265: */
        -: 1266:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 1267:ecma_create_error_object_reference (ecma_object_t *object_p) /**< referenced object */
        -: 1268:{
    #####: 1269:  return ecma_create_error_reference (ecma_make_object_value (object_p), true);
        -: 1270:} /* ecma_create_error_object_reference */
        -: 1271:
        -: 1272:/**
        -: 1273: * Increase ref count of an error reference.
        -: 1274: */
        -: 1275:void
    #####: 1276:ecma_ref_error_reference (ecma_error_reference_t *error_ref_p) /**< error reference */
        -: 1277:{
    #####: 1278:  if (JERRY_LIKELY (error_ref_p->refs_and_flags < ECMA_ERROR_MAX_REF))
        -: 1279:  {
    #####: 1280:    error_ref_p->refs_and_flags += ECMA_ERROR_REF_ONE;
        -: 1281:  }
        -: 1282:  else
        -: 1283:  {
    #####: 1284:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -: 1285:  }
    #####: 1286:} /* ecma_ref_error_reference */
        -: 1287:
        -: 1288:/**
        -: 1289: * Decrease ref count of an error reference.
        -: 1290: */
        -: 1291:void
    #####: 1292:ecma_deref_error_reference (ecma_error_reference_t *error_ref_p) /**< error reference */
        -: 1293:{
    #####: 1294:  JERRY_ASSERT (error_ref_p->refs_and_flags >= ECMA_ERROR_REF_ONE);
        -: 1295:
    #####: 1296:  error_ref_p->refs_and_flags -= ECMA_ERROR_REF_ONE;
        -: 1297:
    #####: 1298:  if (error_ref_p->refs_and_flags < ECMA_ERROR_REF_ONE)
        -: 1299:  {
    #####: 1300:    ecma_free_value (error_ref_p->value);
    #####: 1301:    jmem_pools_free (error_ref_p, sizeof (ecma_error_reference_t));
        -: 1302:  }
    #####: 1303:} /* ecma_deref_error_reference */
        -: 1304:
        -: 1305:/**
        -: 1306: * Raise error from the given error reference.
        -: 1307: *
        -: 1308: * Note: the error reference's ref count is also decreased
        -: 1309: */
        -: 1310:void
    #####: 1311:ecma_raise_error_from_error_reference (ecma_value_t value) /**< error reference */
        -: 1312:{
    #####: 1313:  JERRY_ASSERT (!jcontext_has_pending_exception () && !jcontext_has_pending_abort ());
    #####: 1314:  ecma_error_reference_t *error_ref_p = ecma_get_error_reference_from_value (value);
        -: 1315:
    #####: 1316:  JERRY_ASSERT (error_ref_p->refs_and_flags >= ECMA_ERROR_REF_ONE);
        -: 1317:
    #####: 1318:  ecma_value_t referenced_value = error_ref_p->value;
        -: 1319:
    #####: 1320:  jcontext_set_exception_flag (true);
    #####: 1321:  jcontext_set_abort_flag (error_ref_p->refs_and_flags & ECMA_ERROR_REF_ABORT);
        -: 1322:
    #####: 1323:  if (error_ref_p->refs_and_flags >= 2 * ECMA_ERROR_REF_ONE)
        -: 1324:  {
    #####: 1325:    error_ref_p->refs_and_flags -= ECMA_ERROR_REF_ONE;
    #####: 1326:    referenced_value = ecma_copy_value (referenced_value);
        -: 1327:  }
        -: 1328:  else
        -: 1329:  {
    #####: 1330:    jmem_pools_free (error_ref_p, sizeof (ecma_error_reference_t));
        -: 1331:  }
        -: 1332:
    #####: 1333:  JERRY_CONTEXT (error_value) = referenced_value;
    #####: 1334:} /* ecma_raise_error_from_error_reference */
        -: 1335:
        -: 1336:/**
        -: 1337: * Increase reference counter of Compact
        -: 1338: * Byte Code or regexp byte code.
        -: 1339: */
        -: 1340:void
     1311: 1341:ecma_bytecode_ref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */
        -: 1342:{
        -: 1343:  /* Abort program if maximum reference number is reached. */
     1311: 1344:  if (bytecode_p->refs >= UINT16_MAX)
        -: 1345:  {
    #####: 1346:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -: 1347:  }
        -: 1348:
     1311: 1349:  bytecode_p->refs++;
     1311: 1350:} /* ecma_bytecode_ref */
        -: 1351:
        -: 1352:/**
        -: 1353: * Decrease reference counter of Compact
        -: 1354: * Byte Code or regexp byte code.
        -: 1355: */
        -: 1356:void
     1309: 1357:ecma_bytecode_deref (ecma_compiled_code_t *bytecode_p) /**< byte code pointer */
        -: 1358:{
     1309: 1359:  JERRY_ASSERT (bytecode_p->refs > 0);
     1309: 1360:  JERRY_ASSERT (!(bytecode_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));
        -: 1361:
     1309: 1362:  bytecode_p->refs--;
        -: 1363:
     1309: 1364:  if (bytecode_p->refs > 0)
        -: 1365:  {
        -: 1366:    /* Non-zero reference counter. */
     1309: 1367:    return;
        -: 1368:  }
        -: 1369:
    #####: 1370:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION)
        -: 1371:  {
    #####: 1372:    ecma_value_t *literal_start_p = NULL;
        -: 1373:    uint32_t literal_end;
        -: 1374:    uint32_t const_literal_end;
        -: 1375:
    #####: 1376:    if (bytecode_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1377:    {
    #####: 1378:      cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_p;
    #####: 1379:      literal_end = args_p->literal_end;
    #####: 1380:      const_literal_end = args_p->const_literal_end;
        -: 1381:
    #####: 1382:      literal_start_p = (ecma_value_t *) ((uint8_t *) bytecode_p + sizeof (cbc_uint16_arguments_t));
    #####: 1383:      literal_start_p -= args_p->register_end;
        -: 1384:    }
        -: 1385:    else
        -: 1386:    {
    #####: 1387:      cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_p;
    #####: 1388:      literal_end = args_p->literal_end;
    #####: 1389:      const_literal_end = args_p->const_literal_end;
        -: 1390:
    #####: 1391:      literal_start_p = (ecma_value_t *) ((uint8_t *) bytecode_p + sizeof (cbc_uint8_arguments_t));
    #####: 1392:      literal_start_p -= args_p->register_end;
        -: 1393:    }
        -: 1394:
    #####: 1395:    for (uint32_t i = const_literal_end; i < literal_end; i++)
        -: 1396:    {
    #####: 1397:      ecma_compiled_code_t *bytecode_literal_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 1398:                                                                                  literal_start_p[i]);
        -: 1399:
        -: 1400:      /* Self references are ignored. */
    #####: 1401:      if (bytecode_literal_p != bytecode_p)
        -: 1402:      {
    #####: 1403:        ecma_bytecode_deref (bytecode_literal_p);
        -: 1404:      }
        -: 1405:    }
        -: 1406:
        -: 1407:#if ENABLED (JERRY_DEBUGGER)
        -: 1408:    if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1409:        && !(bytecode_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE)
        -: 1410:        && jerry_debugger_send_function_cp (JERRY_DEBUGGER_RELEASE_BYTE_CODE_CP, bytecode_p))
        -: 1411:    {
        -: 1412:      /* Delay the byte code free until the debugger client is notified.
        -: 1413:       * If the connection is aborted the pointer is still freed by
        -: 1414:       * jerry_debugger_close_connection(). */
        -: 1415:      jerry_debugger_byte_code_free_t *byte_code_free_p = (jerry_debugger_byte_code_free_t *) bytecode_p;
        -: 1416:      jmem_cpointer_t byte_code_free_head = JERRY_CONTEXT (debugger_byte_code_free_head);
        -: 1417:
        -: 1418:      byte_code_free_p->prev_cp = ECMA_NULL_POINTER;
        -: 1419:
        -: 1420:      jmem_cpointer_t byte_code_free_cp;
        -: 1421:      JMEM_CP_SET_NON_NULL_POINTER (byte_code_free_cp, byte_code_free_p);
        -: 1422:
        -: 1423:      if (byte_code_free_head == ECMA_NULL_POINTER)
        -: 1424:      {
        -: 1425:        JERRY_CONTEXT (debugger_byte_code_free_tail) = byte_code_free_cp;
        -: 1426:      }
        -: 1427:      else
        -: 1428:      {
        -: 1429:        jerry_debugger_byte_code_free_t *first_byte_code_free_p;
        -: 1430:
        -: 1431:        first_byte_code_free_p = JMEM_CP_GET_NON_NULL_POINTER (jerry_debugger_byte_code_free_t,
        -: 1432:                                                               byte_code_free_head);
        -: 1433:        first_byte_code_free_p->prev_cp = byte_code_free_cp;
        -: 1434:      }
        -: 1435:
        -: 1436:      JERRY_CONTEXT (debugger_byte_code_free_head) = byte_code_free_cp;
        -: 1437:      return;
        -: 1438:    }
        -: 1439:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 1440:
        -: 1441:#if ENABLED (JERRY_ES2015)
    #####: 1442:    if (bytecode_p->status_flags & CBC_CODE_FLAG_HAS_TAGGED_LITERALS)
        -: 1443:    {
    #####: 1444:      ecma_length_t formal_params_number = ecma_compiled_code_get_formal_params (bytecode_p);
        -: 1445:
    #####: 1446:      uint8_t *byte_p = (uint8_t *) bytecode_p;
    #####: 1447:      byte_p += ((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG;
        -: 1448:
    #####: 1449:      ecma_value_t *tagged_base_p = (ecma_value_t *) byte_p;
    #####: 1450:      tagged_base_p -= formal_params_number;
        -: 1451:
    #####: 1452:      ecma_collection_t *coll_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, tagged_base_p[-1]);
        -: 1453:
    #####: 1454:      ecma_collection_destroy (coll_p);
        -: 1455:    }
        -: 1456:#endif /* ENABLED (JERRY_ES2015) */
        -: 1457:
        -: 1458:#if ENABLED (JERRY_MEM_STATS)
    #####: 1459:    jmem_stats_free_byte_code_bytes (((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);
        -: 1460:#endif /* ENABLED (JERRY_MEM_STATS) */
        -: 1461:  }
        -: 1462:  else
        -: 1463:  {
        -: 1464:#if ENABLED (JERRY_BUILTIN_REGEXP)
    #####: 1465:    re_compiled_code_t *re_bytecode_p = (re_compiled_code_t *) bytecode_p;
        -: 1466:
    #####: 1467:    ecma_deref_ecma_string (ecma_get_string_from_value (re_bytecode_p->source));
        -: 1468:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
        -: 1469:  }
        -: 1470:
    #####: 1471:  jmem_heap_free_block (bytecode_p,
    #####: 1472:                        ((size_t) bytecode_p->size) << JMEM_ALIGNMENT_LOG);
        -: 1473:} /* ecma_bytecode_deref */
        -: 1474:
        -: 1475:#if ENABLED (JERRY_ES2015)
        -: 1476:/**
        -: 1477: * Get the tagged template collection of the compiled code
        -: 1478: *
        -: 1479: * @return pointer to the tagged template collection
        -: 1480: */
        -: 1481:ecma_collection_t *
    #####: 1482:ecma_compiled_code_get_tagged_template_collection (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */
        -: 1483:{
    #####: 1484:  JERRY_ASSERT (bytecode_header_p != NULL);
    #####: 1485:  JERRY_ASSERT (bytecode_header_p->status_flags & CBC_CODE_FLAG_HAS_TAGGED_LITERALS);
        -: 1486:
    #####: 1487:  uint8_t *byte_p = (uint8_t *) bytecode_header_p;
    #####: 1488:  byte_p += ((size_t) bytecode_header_p->size) << JMEM_ALIGNMENT_LOG;
        -: 1489:
    #####: 1490:  ecma_value_t *tagged_base_p = (ecma_value_t *) byte_p;
    #####: 1491:  tagged_base_p -= ecma_compiled_code_get_formal_params (bytecode_header_p);
        -: 1492:
    #####: 1493:  return ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, tagged_base_p[-1]);
        -: 1494:} /* ecma_compiled_code_get_tagged_template_collection */
        -: 1495:#endif /* ENABLED (JERRY_ES2015) */
        -: 1496:
        -: 1497:#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) || ENABLED (JERRY_ES2015)
        -: 1498:/**
        -: 1499: * Get the number of formal parameters of the compiled code
        -: 1500: *
        -: 1501: * @return number of formal parameters
        -: 1502: */
        -: 1503:ecma_length_t
     1311: 1504:ecma_compiled_code_get_formal_params (const ecma_compiled_code_t *bytecode_header_p) /**< compiled code */
        -: 1505:{
     1311: 1506:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED))
        -: 1507:  {
     1310: 1508:    return 0;
        -: 1509:  }
        -: 1510:
        1: 1511:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1512:  {
    #####: 1513:    return ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;
        -: 1514:  }
        -: 1515:
        1: 1516:  return ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;
        -: 1517:} /* ecma_compiled_code_get_formal_params */
        -: 1518:#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) || ENABLED (JERRY_ES2015) */
        -: 1519:
        -: 1520:#if (JERRY_STACK_LIMIT != 0)
        -: 1521:/**
        -: 1522: * Check the current stack usage by calculating the difference from the initial stack base.
        -: 1523: *
        -: 1524: * @return current stack usage in bytes
        -: 1525: */
        -: 1526:uintptr_t JERRY_ATTR_NOINLINE
     6545: 1527:ecma_get_current_stack_usage (void)
        -: 1528:{
     6545: 1529:  volatile int __sp;
     6545: 1530:  return (uintptr_t) (JERRY_CONTEXT (stack_base) - (uintptr_t) &__sp);
        -: 1531:} /* ecma_get_current_stack_usage */
        -: 1532:
        -: 1533:#endif /* (JERRY_STACK_LIMIT != 0) */
        -: 1534:
        -: 1535:/**
        -: 1536: * @}
        -: 1537: * @}
        -: 1538: */
