        -:    0:Source:/home/workspace/jerry-core/parser/regexp/re-parser.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-exceptions.h"
        -:   17:#include "ecma-globals.h"
        -:   18:#include "ecma-try-catch-macro.h"
        -:   19:#include "jcontext.h"
        -:   20:#include "jrt-libc-includes.h"
        -:   21:#include "lit-char-helpers.h"
        -:   22:#include "re-compiler.h"
        -:   23:#include "re-parser.h"
        -:   24:
        -:   25:#if ENABLED (JERRY_BUILTIN_REGEXP)
        -:   26:
        -:   27:/** \addtogroup parser Parser
        -:   28: * @{
        -:   29: *
        -:   30: * \addtogroup regexparser Regular expression
        -:   31: * @{
        -:   32: *
        -:   33: * \addtogroup regexparser_parser Parser
        -:   34: * @{
        -:   35: */
        -:   36:
        -:   37:/**
        -:   38: * Get the start opcode for the current group.
        -:   39: *
        -:   40: * @return RegExp opcode
        -:   41: */
        -:   42:static re_opcode_t
    #####:   43:re_get_group_start_opcode (bool is_capturing) /**< is capturing group */
        -:   44:{
    #####:   45:  return (is_capturing) ? RE_OP_CAPTURING_GROUP_START : RE_OP_NON_CAPTURING_GROUP_START;
        -:   46:} /* re_get_group_start_opcode*/
        -:   47:
        -:   48:/**
        -:   49: * Get the end opcode for the current group.
        -:   50: *
        -:   51: * @return RegExp opcode
        -:   52: */
        -:   53:static re_opcode_t
    #####:   54:re_get_group_end_opcode (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:   55:                         bool is_capturing) /**< is capturing group */
        -:   56:{
    #####:   57:  if (is_capturing)
        -:   58:  {
    #####:   59:    if (re_ctx_p->token.greedy)
        -:   60:    {
    #####:   61:      return RE_OP_GREEDY_CAPTURING_GROUP_END;
        -:   62:    }
        -:   63:
    #####:   64:    return RE_OP_LAZY_CAPTURING_GROUP_END;
        -:   65:  }
        -:   66:
    #####:   67:  if (re_ctx_p->token.greedy)
        -:   68:  {
    #####:   69:    return RE_OP_GREEDY_NON_CAPTURING_GROUP_END;
        -:   70:  }
        -:   71:
    #####:   72:  return RE_OP_LAZY_NON_CAPTURING_GROUP_END;
        -:   73:} /* re_get_group_end_opcode */
        -:   74:
        -:   75:/**
        -:   76: * Enclose the given bytecode to a group.
        -:   77: */
        -:   78:static void
    #####:   79:re_insert_into_group (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:   80:                      uint32_t group_start_offset, /**< offset of group start */
        -:   81:                      uint32_t idx, /**< index of group */
        -:   82:                      uint32_t capture_start, /**< index of first nested capture */
        -:   83:                      bool is_capturing) /**< is capturing group */
        -:   84:{
    #####:   85:  uint32_t qmin = re_ctx_p->token.qmin;
    #####:   86:  uint32_t qmax = re_ctx_p->token.qmax;
        -:   87:
    #####:   88:  if (JERRY_UNLIKELY (!is_capturing && re_bytecode_size (re_ctx_p) == group_start_offset))
        -:   89:  {
    #####:   90:    return;
        -:   91:  }
        -:   92:
    #####:   93:  if (qmin == 0)
        -:   94:  {
    #####:   95:    re_insert_value (re_ctx_p,
        -:   96:                     group_start_offset,
    #####:   97:                     re_bytecode_size (re_ctx_p) - group_start_offset);
        -:   98:  }
        -:   99:
    #####:  100:  re_insert_value (re_ctx_p, group_start_offset, qmin);
    #####:  101:  re_insert_value (re_ctx_p, group_start_offset, re_ctx_p->captures_count - capture_start);
        -:  102:
    #####:  103:  if (!is_capturing)
        -:  104:  {
    #####:  105:    re_insert_value (re_ctx_p, group_start_offset, capture_start);
        -:  106:  }
        -:  107:  else
        -:  108:  {
    #####:  109:    JERRY_ASSERT (idx == capture_start);
        -:  110:  }
        -:  111:
    #####:  112:  re_insert_value (re_ctx_p, group_start_offset, idx);
    #####:  113:  re_insert_opcode (re_ctx_p, group_start_offset, re_get_group_start_opcode (is_capturing));
        -:  114:
    #####:  115:  re_append_opcode (re_ctx_p, re_get_group_end_opcode (re_ctx_p, is_capturing));
    #####:  116:  re_append_value (re_ctx_p, idx);
    #####:  117:  re_append_value (re_ctx_p, qmin);
    #####:  118:  re_append_value (re_ctx_p, qmax + RE_QMAX_OFFSET);
        -:  119:} /* re_insert_into_group */
        -:  120:
        -:  121:/**
        -:  122: * Insert simple atom iterator.
        -:  123: */
        -:  124:static void
    #####:  125:re_insert_atom_iterator (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  126:                         uint32_t start_offset) /**< atom start offset */
        -:  127:{
    #####:  128:  const uint32_t qmin = re_ctx_p->token.qmin;
    #####:  129:  const uint32_t qmax = re_ctx_p->token.qmax;
        -:  130:
    #####:  131:  if (qmin == 1 && qmax == 1)
        -:  132:  {
    #####:  133:    return;
        -:  134:  }
        -:  135:
    #####:  136:  re_append_opcode (re_ctx_p, RE_OP_ITERATOR_END);
    #####:  137:  re_insert_value (re_ctx_p, start_offset, re_bytecode_size (re_ctx_p) - start_offset);
    #####:  138:  re_insert_value (re_ctx_p, start_offset, qmax + RE_QMAX_OFFSET);
    #####:  139:  re_insert_value (re_ctx_p, start_offset, qmin);
    #####:  140:  re_insert_opcode (re_ctx_p, start_offset, re_ctx_p->token.greedy ? RE_OP_GREEDY_ITERATOR : RE_OP_LAZY_ITERATOR);
        -:  141:} /* re_insert_atom_iterator */
        -:  142:
        -:  143:/**
        -:  144: * Insert a lookahead assertion.
        -:  145: */
        -:  146:static void
    #####:  147:re_insert_assertion_lookahead (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  148:                               uint32_t start_offset, /**< atom start offset */
        -:  149:                               uint32_t capture_start, /**< index of first nested capture */
        -:  150:                               bool negative) /** lookahead type */
        -:  151:{
    #####:  152:  const uint32_t qmin = re_ctx_p->token.qmin;
        -:  153:
    #####:  154:  re_append_opcode (re_ctx_p, RE_OP_ASSERT_END);
    #####:  155:  re_insert_value (re_ctx_p, start_offset, re_bytecode_size (re_ctx_p) - start_offset);
        -:  156:
        -:  157:  /* We need to clear nested capturing group results when a negative assertion or the tail after a positive assertion
        -:  158:   * does not match, so we store the begin and end index of nested capturing groups. */
    #####:  159:  re_insert_value (re_ctx_p, start_offset, re_ctx_p->captures_count - capture_start);
    #####:  160:  re_insert_value (re_ctx_p, start_offset, capture_start);
        -:  161:
        -:  162:  /* Lookaheads always result in zero length matches, which means iterations will always stop on the first match.
        -:  163:   * This allows us to not have to deal with iterations beyond one. Either qmin == 0 which will implicitly match,
        -:  164:   * or qmin > 0, in which case the first iteration will decide whether the assertion matches depending on whether
        -:  165:   * the iteration matched or not. This also allows us to ignore qmax entirely. */
    #####:  166:  re_insert_byte (re_ctx_p, start_offset, (uint8_t) JERRY_MIN (qmin, 1));
        -:  167:
    #####:  168:  const re_opcode_t opcode = (negative) ? RE_OP_ASSERT_LOOKAHEAD_NEG : RE_OP_ASSERT_LOOKAHEAD_POS;
    #####:  169:  re_insert_opcode (re_ctx_p, start_offset, opcode);
    #####:  170:} /* re_insert_assertion_lookahead */
        -:  171:
        -:  172:/**
        -:  173: * Consume non greedy (question mark) character if present.
        -:  174: */
        -:  175:static void
    #####:  176:re_parse_lazy_char (re_compiler_ctx_t *re_ctx_p) /**< RegExp parser context */
        -:  177:{
    #####:  178:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p
    #####:  179:      && *re_ctx_p->input_curr_p == LIT_CHAR_QUESTION)
        -:  180:  {
    #####:  181:    re_ctx_p->input_curr_p++;
    #####:  182:    re_ctx_p->token.greedy = false;
    #####:  183:    return;
        -:  184:  }
        -:  185:
    #####:  186:  re_ctx_p->token.greedy = true;
        -:  187:} /* re_parse_lazy_char */
        -:  188:
        -:  189:/**
        -:  190: * Parse a max 3 digit long octal number from the input string, with a decimal value less than 256.
        -:  191: *
        -:  192: * @return value of the octal number
        -:  193: */
        -:  194:static uint32_t
    #####:  195:re_parse_octal (re_compiler_ctx_t *re_ctx_p) /**< RegExp parser context */
        -:  196:{
    #####:  197:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  198:  JERRY_ASSERT (lit_char_is_octal_digit (*re_ctx_p->input_curr_p));
        -:  199:
    #####:  200:  uint32_t value = (uint32_t) (*re_ctx_p->input_curr_p++) - LIT_CHAR_0;
        -:  201:
    #####:  202:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p
    #####:  203:      && lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  204:  {
    #####:  205:    value = value * 8 + (*re_ctx_p->input_curr_p++) - LIT_CHAR_0;
        -:  206:  }
        -:  207:
    #####:  208:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p
    #####:  209:      && lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  210:  {
    #####:  211:    const uint32_t new_value = value * 8 + (*re_ctx_p->input_curr_p) - LIT_CHAR_0;
        -:  212:
    #####:  213:    if (new_value <= RE_MAX_OCTAL_VALUE)
        -:  214:    {
    #####:  215:      value = new_value;
    #####:  216:      re_ctx_p->input_curr_p++;
        -:  217:    }
        -:  218:  }
        -:  219:
    #####:  220:  return value;
        -:  221:} /* re_parse_octal */
        -:  222:
        -:  223:/**
        -:  224: * Check that the currently parsed quantifier is valid.
        -:  225: *
        -:  226: * @return ECMA_VALUE_ERROR, if quantifier is invalid
        -:  227: *         ECMA_VALUE_EMPTY, otherwise
        -:  228: */
        -:  229:static ecma_value_t
    #####:  230:re_check_quantifier (re_compiler_ctx_t *re_ctx_p)
        -:  231:{
    #####:  232:  if (re_ctx_p->token.qmin > re_ctx_p->token.qmax)
        -:  233:  {
        -:  234:    /* ECMA-262 v5.1 15.10.2.5 */
    #####:  235:    return ecma_raise_syntax_error (ECMA_ERR_MSG ("quantifier error: min > max."));
        -:  236:  }
        -:  237:
    #####:  238:  return ECMA_VALUE_EMPTY;
        -:  239:} /* re_check_quantifier */
        -:  240:
        -:  241:/**
        -:  242: * Parse RegExp quantifier.
        -:  243: *
        -:  244: * @return ECMA_VALUE_TRUE - if parsed successfully
        -:  245: *         ECMA_VALUE_FALSE - otherwise
        -:  246: */
        -:  247:static ecma_value_t
    #####:  248:re_parse_quantifier (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  249:{
    #####:  250:  if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p)
        -:  251:  {
    #####:  252:    switch (*re_ctx_p->input_curr_p)
        -:  253:    {
    #####:  254:      case LIT_CHAR_QUESTION:
        -:  255:      {
    #####:  256:        re_ctx_p->input_curr_p++;
    #####:  257:        re_ctx_p->token.qmin = 0;
    #####:  258:        re_ctx_p->token.qmax = 1;
        -:  259:
    #####:  260:        re_parse_lazy_char (re_ctx_p);
    #####:  261:        return ECMA_VALUE_TRUE;
        -:  262:      }
    #####:  263:      case LIT_CHAR_ASTERISK:
        -:  264:      {
    #####:  265:        re_ctx_p->input_curr_p++;
    #####:  266:        re_ctx_p->token.qmin = 0;
    #####:  267:        re_ctx_p->token.qmax = RE_INFINITY;
        -:  268:
    #####:  269:        re_parse_lazy_char (re_ctx_p);
    #####:  270:        return ECMA_VALUE_TRUE;
        -:  271:      }
    #####:  272:      case LIT_CHAR_PLUS:
        -:  273:      {
    #####:  274:        re_ctx_p->input_curr_p++;
    #####:  275:        re_ctx_p->token.qmin = 1;
    #####:  276:        re_ctx_p->token.qmax = RE_INFINITY;
        -:  277:
    #####:  278:        re_parse_lazy_char (re_ctx_p);
    #####:  279:        return ECMA_VALUE_TRUE;
        -:  280:      }
    #####:  281:      case LIT_CHAR_LEFT_BRACE:
        -:  282:      {
    #####:  283:        const lit_utf8_byte_t *current_p = re_ctx_p->input_curr_p + 1;
    #####:  284:        uint32_t qmin = 0;
    #####:  285:        uint32_t qmax = RE_INFINITY;
        -:  286:
    #####:  287:        if (current_p >= re_ctx_p->input_end_p)
        -:  288:        {
    #####:  289:          break;
        -:  290:        }
        -:  291:
    #####:  292:        if (!lit_char_is_decimal_digit (*current_p))
        -:  293:        {
    #####:  294:          break;
        -:  295:        }
        -:  296:
    #####:  297:        qmin = lit_parse_decimal (&current_p, re_ctx_p->input_end_p);
        -:  298:
    #####:  299:        if (current_p >= re_ctx_p->input_end_p)
        -:  300:        {
    #####:  301:          break;
        -:  302:        }
        -:  303:
    #####:  304:        lit_utf8_byte_t ch = *current_p++;
    #####:  305:        if (ch == LIT_CHAR_RIGHT_BRACE)
        -:  306:        {
    #####:  307:          qmax = qmin;
        -:  308:        }
    #####:  309:        else if (ch == LIT_CHAR_COMMA)
        -:  310:        {
    #####:  311:          if (current_p >= re_ctx_p->input_end_p)
        -:  312:          {
    #####:  313:            break;
        -:  314:          }
        -:  315:
    #####:  316:          if (lit_char_is_decimal_digit (*current_p))
        -:  317:          {
    #####:  318:            qmax = lit_parse_decimal (&current_p, re_ctx_p->input_end_p);
        -:  319:          }
        -:  320:
    #####:  321:          if (current_p >= re_ctx_p->input_end_p || *current_p++ != LIT_CHAR_RIGHT_BRACE)
        -:  322:          {
        -:  323:            break;
        -:  324:          }
        -:  325:        }
        -:  326:        else
        -:  327:        {
    #####:  328:          break;
        -:  329:        }
        -:  330:
    #####:  331:        re_ctx_p->token.qmin = qmin;
    #####:  332:        re_ctx_p->token.qmax = qmax;
    #####:  333:        re_ctx_p->input_curr_p = current_p;
    #####:  334:        re_parse_lazy_char (re_ctx_p);
    #####:  335:        return ECMA_VALUE_TRUE;
        -:  336:      }
    #####:  337:      default:
        -:  338:      {
    #####:  339:        break;
        -:  340:      }
        -:  341:    }
    #####:  342:  }
        -:  343:
    #####:  344:  re_ctx_p->token.qmin = 1;
    #####:  345:  re_ctx_p->token.qmax = 1;
    #####:  346:  re_ctx_p->token.greedy = true;
        -:  347:
    #####:  348:  return ECMA_VALUE_FALSE;
        -:  349:} /* re_parse_quantifier */
        -:  350:
        -:  351:/**
        -:  352: * Count the number of groups in the current pattern.
        -:  353: */
        -:  354:static void
    #####:  355:re_count_groups (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  356:{
    #####:  357:  bool is_char_class = 0;
    #####:  358:  re_ctx_p->groups_count = 0;
    #####:  359:  const lit_utf8_byte_t *curr_p = re_ctx_p->input_start_p;
        -:  360:
    #####:  361:  while (curr_p < re_ctx_p->input_end_p)
        -:  362:  {
    #####:  363:    switch (*curr_p++)
        -:  364:    {
    #####:  365:      case LIT_CHAR_BACKSLASH:
        -:  366:      {
    #####:  367:        if (curr_p < re_ctx_p->input_end_p)
        -:  368:        {
    #####:  369:          lit_utf8_incr (&curr_p);
        -:  370:        }
    #####:  371:        break;
        -:  372:      }
    #####:  373:      case LIT_CHAR_LEFT_SQUARE:
        -:  374:      {
    #####:  375:        is_char_class = true;
    #####:  376:        break;
        -:  377:      }
    #####:  378:      case LIT_CHAR_RIGHT_SQUARE:
        -:  379:      {
    #####:  380:        is_char_class = false;
    #####:  381:        break;
        -:  382:      }
    #####:  383:      case LIT_CHAR_LEFT_PAREN:
        -:  384:      {
    #####:  385:        if (curr_p < re_ctx_p->input_end_p
    #####:  386:            && *curr_p != LIT_CHAR_QUESTION
    #####:  387:            && !is_char_class)
        -:  388:        {
    #####:  389:          re_ctx_p->groups_count++;
        -:  390:        }
    #####:  391:        break;
        -:  392:      }
        -:  393:    }
        -:  394:  }
    #####:  395:} /* re_count_groups */
        -:  396:
        -:  397:#if ENABLED (JERRY_ES2015)
        -:  398:/**
        -:  399: * Check if a code point is a Syntax character
        -:  400: *
        -:  401: * @return true, if syntax character
        -:  402: *         false, otherwise
        -:  403: */
        -:  404:static bool
    #####:  405:re_is_syntax_char (lit_code_point_t cp) /**< code point */
        -:  406:{
    #####:  407:  return (cp == LIT_CHAR_CIRCUMFLEX
    #####:  408:          || cp == LIT_CHAR_DOLLAR_SIGN
    #####:  409:          || cp == LIT_CHAR_BACKSLASH
    #####:  410:          || cp == LIT_CHAR_DOT
    #####:  411:          || cp == LIT_CHAR_ASTERISK
    #####:  412:          || cp == LIT_CHAR_PLUS
    #####:  413:          || cp == LIT_CHAR_QUESTION
    #####:  414:          || cp == LIT_CHAR_LEFT_PAREN
    #####:  415:          || cp == LIT_CHAR_RIGHT_PAREN
    #####:  416:          || cp == LIT_CHAR_LEFT_SQUARE
    #####:  417:          || cp == LIT_CHAR_RIGHT_SQUARE
    #####:  418:          || cp == LIT_CHAR_LEFT_BRACE
    #####:  419:          || cp == LIT_CHAR_RIGHT_BRACE
    #####:  420:          || cp == LIT_CHAR_VLINE);
        -:  421:} /* re_is_syntax_char */
        -:  422:#endif /* ENABLED (JERRY_ES2015) */
        -:  423:
        -:  424:/**
        -:  425: * Parse a Character Escape or a Character Class Escape.
        -:  426: *
        -:  427: * @return ECMA_VALUE_EMPTY, if parsed successfully
        -:  428: *         ECMA_VALUE_ERROR, otherwise
        -:  429: */
        -:  430:static ecma_value_t
    #####:  431:re_parse_char_escape (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  432:{
    #####:  433:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  434:  re_ctx_p->token.type = RE_TOK_CHAR;
        -:  435:
    #####:  436:  if (lit_char_is_decimal_digit (*re_ctx_p->input_curr_p))
        -:  437:  {
        -:  438:    /* NULL code point escape, only valid if there are no following digits. */
    #####:  439:    if (*re_ctx_p->input_curr_p == LIT_CHAR_0
    #####:  440:        && (re_ctx_p->input_curr_p + 1 >= re_ctx_p->input_end_p
    #####:  441:            || !lit_char_is_decimal_digit (re_ctx_p->input_curr_p[1])))
        -:  442:    {
    #####:  443:      re_ctx_p->input_curr_p++;
    #####:  444:      re_ctx_p->token.value = LIT_UNICODE_CODE_POINT_NULL;
    #####:  445:      return ECMA_VALUE_EMPTY;
        -:  446:    }
        -:  447:
        -:  448:#if ENABLED (JERRY_ES2015)
    #####:  449:    if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  450:    {
    #####:  451:      return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid escape sequence"));
        -:  452:    }
        -:  453:#endif /* ENABLED (JERRY_ES2015) */
        -:  454:
        -:  455:    /* Legacy octal escape sequence */
    #####:  456:    if (lit_char_is_octal_digit (*re_ctx_p->input_curr_p))
        -:  457:    {
    #####:  458:      re_ctx_p->token.value = re_parse_octal (re_ctx_p);
    #####:  459:      return ECMA_VALUE_EMPTY;
        -:  460:    }
        -:  461:
        -:  462:    /* Identity escape */
    #####:  463:    re_ctx_p->token.value = *re_ctx_p->input_curr_p++;
    #####:  464:    return ECMA_VALUE_EMPTY;
        -:  465:  }
        -:  466:
    #####:  467:  lit_code_point_t ch = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
    #####:  468:  switch (ch)
        -:  469:  {
        -:  470:    /* Character Class escapes */
    #####:  471:    case LIT_CHAR_LOWERCASE_D:
        -:  472:    {
    #####:  473:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  474:      re_ctx_p->token.value = RE_ESCAPE_DIGIT;
    #####:  475:      break;
        -:  476:    }
    #####:  477:    case LIT_CHAR_UPPERCASE_D:
        -:  478:    {
    #####:  479:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  480:      re_ctx_p->token.value = RE_ESCAPE_NOT_DIGIT;
    #####:  481:      break;
        -:  482:    }
    #####:  483:    case LIT_CHAR_LOWERCASE_S:
        -:  484:    {
    #####:  485:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  486:      re_ctx_p->token.value = RE_ESCAPE_WHITESPACE;
    #####:  487:      break;
        -:  488:    }
    #####:  489:    case LIT_CHAR_UPPERCASE_S:
        -:  490:    {
    #####:  491:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  492:      re_ctx_p->token.value = RE_ESCAPE_NOT_WHITESPACE;
    #####:  493:      break;
        -:  494:    }
    #####:  495:    case LIT_CHAR_LOWERCASE_W:
        -:  496:    {
    #####:  497:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  498:      re_ctx_p->token.value = RE_ESCAPE_WORD_CHAR;
    #####:  499:      break;
        -:  500:    }
    #####:  501:    case LIT_CHAR_UPPERCASE_W:
        -:  502:    {
    #####:  503:      re_ctx_p->token.type = RE_TOK_CLASS_ESCAPE;
    #####:  504:      re_ctx_p->token.value = RE_ESCAPE_NOT_WORD_CHAR;
    #####:  505:      break;
        -:  506:    }
        -:  507:    /* Control escapes */
    #####:  508:    case LIT_CHAR_LOWERCASE_F:
        -:  509:    {
    #####:  510:      re_ctx_p->token.value = LIT_CHAR_FF;
    #####:  511:      break;
        -:  512:    }
    #####:  513:    case LIT_CHAR_LOWERCASE_N:
        -:  514:    {
    #####:  515:      re_ctx_p->token.value = LIT_CHAR_LF;
    #####:  516:      break;
        -:  517:    }
    #####:  518:    case LIT_CHAR_LOWERCASE_R:
        -:  519:    {
    #####:  520:      re_ctx_p->token.value = LIT_CHAR_CR;
    #####:  521:      break;
        -:  522:    }
    #####:  523:    case LIT_CHAR_LOWERCASE_T:
        -:  524:    {
    #####:  525:      re_ctx_p->token.value = LIT_CHAR_TAB;
    #####:  526:      break;
        -:  527:    }
    #####:  528:    case LIT_CHAR_LOWERCASE_V:
        -:  529:    {
    #####:  530:      re_ctx_p->token.value = LIT_CHAR_VTAB;
    #####:  531:      break;
        -:  532:    }
        -:  533:    /* Control letter */
    #####:  534:    case LIT_CHAR_LOWERCASE_C:
        -:  535:    {
    #####:  536:      if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p)
        -:  537:      {
    #####:  538:        ch = *re_ctx_p->input_curr_p;
        -:  539:
    #####:  540:        if ((ch >= LIT_CHAR_ASCII_UPPERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_UPPERCASE_LETTERS_END)
    #####:  541:            || (ch >= LIT_CHAR_ASCII_LOWERCASE_LETTERS_BEGIN && ch <= LIT_CHAR_ASCII_LOWERCASE_LETTERS_END))
        -:  542:        {
    #####:  543:          re_ctx_p->token.value = (ch % 32);
    #####:  544:          re_ctx_p->input_curr_p++;
        -:  545:
    #####:  546:          break;
        -:  547:        }
        -:  548:      }
        -:  549:
        -:  550:#if ENABLED (JERRY_ES2015)
    #####:  551:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  552:      {
    #####:  553:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid control escape sequence"));
        -:  554:      }
        -:  555:#endif /* ENABLED (JERRY_ES2015) */
        -:  556:
    #####:  557:      re_ctx_p->token.value = LIT_CHAR_BACKSLASH;
    #####:  558:      re_ctx_p->input_curr_p--;
        -:  559:
    #####:  560:      break;
        -:  561:    }
        -:  562:    /* Hex escape */
    #####:  563:    case LIT_CHAR_LOWERCASE_X:
        -:  564:    {
    #####:  565:      uint32_t hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p, re_ctx_p->input_end_p, 2);
    #####:  566:      if (hex_value != UINT32_MAX)
        -:  567:      {
    #####:  568:        re_ctx_p->token.value = hex_value;
    #####:  569:        re_ctx_p->input_curr_p += 2;
    #####:  570:        break;
        -:  571:      }
        -:  572:
        -:  573:#if ENABLED (JERRY_ES2015)
    #####:  574:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  575:      {
    #####:  576:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid hex escape sequence"));
        -:  577:      }
        -:  578:#endif /* ENABLED (JERRY_ES2015) */
        -:  579:
    #####:  580:      re_ctx_p->token.value = LIT_CHAR_LOWERCASE_X;
    #####:  581:      break;
        -:  582:    }
        -:  583:    /* Unicode escape */
    #####:  584:    case LIT_CHAR_LOWERCASE_U:
        -:  585:    {
    #####:  586:      uint32_t hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p, re_ctx_p->input_end_p, 4);
    #####:  587:      if (hex_value != UINT32_MAX)
        -:  588:      {
    #####:  589:        re_ctx_p->token.value = hex_value;
    #####:  590:        re_ctx_p->input_curr_p += 4;
        -:  591:
        -:  592:#if ENABLED (JERRY_ES2015)
    #####:  593:        if (re_ctx_p->flags & RE_FLAG_UNICODE
    #####:  594:            && lit_is_code_point_utf16_high_surrogate (re_ctx_p->token.value)
    #####:  595:            && re_ctx_p->input_curr_p + 6 <= re_ctx_p->input_end_p
    #####:  596:            && re_ctx_p->input_curr_p[0] == '\\'
    #####:  597:            && re_ctx_p->input_curr_p[1] == 'u')
        -:  598:        {
    #####:  599:          hex_value = lit_char_hex_lookup (re_ctx_p->input_curr_p + 2, re_ctx_p->input_end_p, 4);
    #####:  600:          if (lit_is_code_point_utf16_low_surrogate (hex_value))
        -:  601:          {
    #####:  602:            re_ctx_p->token.value = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) re_ctx_p->token.value,
    #####:  603:                                                                              (ecma_char_t) hex_value);
    #####:  604:            re_ctx_p->input_curr_p += 6;
        -:  605:          }
        -:  606:        }
        -:  607:#endif /* ENABLED (JERRY_ES2015) */
        -:  608:
    #####:  609:        break;
        -:  610:      }
        -:  611:
        -:  612:#if ENABLED (JERRY_ES2015)
    #####:  613:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  614:      {
    #####:  615:        if (*re_ctx_p->input_curr_p == LIT_CHAR_LEFT_BRACE)
        -:  616:        {
    #####:  617:          re_ctx_p->input_curr_p++;
        -:  618:
    #####:  619:          if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && lit_char_is_hex_digit (*re_ctx_p->input_curr_p))
        -:  620:          {
    #####:  621:            lit_code_point_t cp = lit_char_hex_to_int (*re_ctx_p->input_curr_p++);
        -:  622:
    #####:  623:            while (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && lit_char_is_hex_digit (*re_ctx_p->input_curr_p))
        -:  624:            {
    #####:  625:              cp = cp * 16 + lit_char_hex_to_int (*re_ctx_p->input_curr_p++);
        -:  626:
    #####:  627:              if (JERRY_UNLIKELY (cp > LIT_UNICODE_CODE_POINT_MAX))
        -:  628:              {
    #####:  629:                return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid unicode escape sequence"));
        -:  630:              }
        -:  631:            }
        -:  632:
    #####:  633:            if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p && *re_ctx_p->input_curr_p == LIT_CHAR_RIGHT_BRACE)
        -:  634:            {
    #####:  635:              re_ctx_p->input_curr_p++;
    #####:  636:              re_ctx_p->token.value = cp;
    #####:  637:              break;
        -:  638:            }
        -:  639:          }
        -:  640:        }
        -:  641:
    #####:  642:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid unicode escape sequence"));
        -:  643:      }
        -:  644:#endif /* ENABLED (JERRY_ES2015) */
        -:  645:
    #####:  646:      re_ctx_p->token.value = LIT_CHAR_LOWERCASE_U;
    #####:  647:      break;
        -:  648:    }
        -:  649:    /* Identity escape */
    #####:  650:    default:
        -:  651:    {
        -:  652:#if ENABLED (JERRY_ES2015)
        -:  653:      /* Must be '/', or one of SyntaxCharacter */
    #####:  654:      if (re_ctx_p->flags & RE_FLAG_UNICODE
    #####:  655:          && ch != LIT_CHAR_SLASH
    #####:  656:          && !re_is_syntax_char (ch))
        -:  657:      {
    #####:  658:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid escape"));
        -:  659:      }
        -:  660:#endif /* ENABLED (JERRY_ES2015) */
    #####:  661:      re_ctx_p->token.value = ch;
        -:  662:    }
        -:  663:  }
        -:  664:
    #####:  665:  return ECMA_VALUE_EMPTY;
        -:  666:} /* re_parse_char_escape */
        -:  667:
        -:  668:/**
        -:  669: * Read the input pattern and parse the next token for the RegExp compiler
        -:  670: *
        -:  671: * @return empty ecma value - if parsed successfully
        -:  672: *         error ecma value - otherwise
        -:  673: *
        -:  674: *         Returned value must be freed with ecma_free_value
        -:  675: */
        -:  676:static ecma_value_t
    #####:  677:re_parse_next_token (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  678:{
    #####:  679:  if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  680:  {
    #####:  681:    re_ctx_p->token.type = RE_TOK_EOF;
    #####:  682:    return ECMA_VALUE_EMPTY;
        -:  683:  }
        -:  684:
    #####:  685:  ecma_char_t ch = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
        -:  686:
    #####:  687:  switch (ch)
        -:  688:  {
    #####:  689:    case LIT_CHAR_CIRCUMFLEX:
        -:  690:    {
    #####:  691:      re_ctx_p->token.type = RE_TOK_ASSERT_START;
    #####:  692:      return ECMA_VALUE_EMPTY;
        -:  693:    }
    #####:  694:    case LIT_CHAR_DOLLAR_SIGN:
        -:  695:    {
    #####:  696:      re_ctx_p->token.type = RE_TOK_ASSERT_END;
    #####:  697:      return ECMA_VALUE_EMPTY;
        -:  698:    }
    #####:  699:    case LIT_CHAR_VLINE:
        -:  700:    {
    #####:  701:      re_ctx_p->token.type = RE_TOK_ALTERNATIVE;
    #####:  702:      return ECMA_VALUE_EMPTY;
        -:  703:    }
    #####:  704:    case LIT_CHAR_DOT:
        -:  705:    {
    #####:  706:      re_ctx_p->token.type = RE_TOK_PERIOD;
        -:  707:      /* Check quantifier */
    #####:  708:      break;
        -:  709:    }
    #####:  710:    case LIT_CHAR_BACKSLASH:
        -:  711:    {
    #####:  712:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  713:      {
    #####:  714:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid escape"));
        -:  715:      }
        -:  716:
        -:  717:      /* DecimalEscape, Backreferences cannot start with a zero digit. */
    #####:  718:      if (*re_ctx_p->input_curr_p > LIT_CHAR_0 && *re_ctx_p->input_curr_p <= LIT_CHAR_9)
        -:  719:      {
    #####:  720:        const lit_utf8_byte_t *digits_p = re_ctx_p->input_curr_p;
    #####:  721:        const uint32_t value = lit_parse_decimal (&digits_p, re_ctx_p->input_end_p);
        -:  722:
    #####:  723:        if (re_ctx_p->groups_count < 0)
        -:  724:        {
    #####:  725:          re_count_groups (re_ctx_p);
        -:  726:        }
        -:  727:
    #####:  728:        if (value <= (uint32_t) re_ctx_p->groups_count)
        -:  729:        {
        -:  730:          /* Valid backreference */
    #####:  731:          re_ctx_p->input_curr_p = digits_p;
    #####:  732:          re_ctx_p->token.type = RE_TOK_BACKREFERENCE;
    #####:  733:          re_ctx_p->token.value = value;
        -:  734:
        -:  735:          /* Check quantifier */
    #####:  736:          break;
        -:  737:        }
        -:  738:      }
        -:  739:
    #####:  740:      if (*re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_B)
        -:  741:      {
    #####:  742:        re_ctx_p->input_curr_p++;
    #####:  743:        re_ctx_p->token.type = RE_TOK_ASSERT_WORD_BOUNDARY;
    #####:  744:        return ECMA_VALUE_EMPTY;
        -:  745:      }
    #####:  746:      else if (*re_ctx_p->input_curr_p == LIT_CHAR_UPPERCASE_B)
        -:  747:      {
    #####:  748:        re_ctx_p->input_curr_p++;
    #####:  749:        re_ctx_p->token.type = RE_TOK_ASSERT_NOT_WORD_BOUNDARY;
    #####:  750:        return ECMA_VALUE_EMPTY;
        -:  751:      }
        -:  752:
    #####:  753:      const ecma_value_t parse_result = re_parse_char_escape (re_ctx_p);
        -:  754:
    #####:  755:      if (ECMA_IS_VALUE_ERROR (parse_result))
        -:  756:      {
    #####:  757:        return parse_result;
        -:  758:      }
        -:  759:
        -:  760:      /* Check quantifier */
    #####:  761:      break;
        -:  762:    }
    #####:  763:    case LIT_CHAR_LEFT_PAREN:
        -:  764:    {
    #####:  765:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  766:      {
    #####:  767:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unterminated group"));
        -:  768:      }
        -:  769:
    #####:  770:      if (*re_ctx_p->input_curr_p == LIT_CHAR_QUESTION)
        -:  771:      {
    #####:  772:        re_ctx_p->input_curr_p++;
    #####:  773:        if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  774:        {
    #####:  775:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid group"));
        -:  776:        }
        -:  777:
    #####:  778:        ch = *re_ctx_p->input_curr_p++;
        -:  779:
    #####:  780:        if (ch == LIT_CHAR_EQUALS)
        -:  781:        {
    #####:  782:          re_ctx_p->token.type = RE_TOK_ASSERT_LOOKAHEAD;
    #####:  783:          re_ctx_p->token.value = false;
        -:  784:        }
    #####:  785:        else if (ch == LIT_CHAR_EXCLAMATION)
        -:  786:        {
    #####:  787:          re_ctx_p->token.type = RE_TOK_ASSERT_LOOKAHEAD;
    #####:  788:          re_ctx_p->token.value = true;
        -:  789:        }
    #####:  790:        else if (ch == LIT_CHAR_COLON)
        -:  791:        {
    #####:  792:          re_ctx_p->token.type = RE_TOK_START_NON_CAPTURE_GROUP;
        -:  793:        }
        -:  794:        else
        -:  795:        {
    #####:  796:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid group"));
        -:  797:        }
        -:  798:      }
        -:  799:      else
        -:  800:      {
    #####:  801:        re_ctx_p->token.type = RE_TOK_START_CAPTURE_GROUP;
        -:  802:      }
        -:  803:
    #####:  804:      return ECMA_VALUE_EMPTY;
        -:  805:    }
    #####:  806:    case LIT_CHAR_RIGHT_PAREN:
        -:  807:    {
    #####:  808:      re_ctx_p->token.type = RE_TOK_END_GROUP;
        -:  809:
    #####:  810:      return ECMA_VALUE_EMPTY;
        -:  811:    }
    #####:  812:    case LIT_CHAR_LEFT_SQUARE:
        -:  813:    {
    #####:  814:      re_ctx_p->token.type = RE_TOK_CHAR_CLASS;
        -:  815:
    #####:  816:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  817:      {
    #####:  818:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unterminated character class."));
        -:  819:      }
        -:  820:
    #####:  821:      return ECMA_VALUE_EMPTY;
        -:  822:    }
    #####:  823:    case LIT_CHAR_QUESTION:
        -:  824:    case LIT_CHAR_ASTERISK:
        -:  825:    case LIT_CHAR_PLUS:
        -:  826:    {
    #####:  827:      return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid quantifier."));
        -:  828:    }
    #####:  829:    case LIT_CHAR_LEFT_BRACE:
        -:  830:    {
    #####:  831:      re_ctx_p->input_curr_p--;
    #####:  832:      if (ecma_is_value_true (re_parse_quantifier (re_ctx_p)))
        -:  833:      {
    #####:  834:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Nothing to repeat."));
        -:  835:      }
        -:  836:
        -:  837:#if ENABLED (JERRY_ES2015)
    #####:  838:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  839:      {
    #####:  840:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Lone quantifier bracket."));
        -:  841:      }
        -:  842:#endif /* ENABLED (JERRY_ES2015) */
        -:  843:
    #####:  844:      re_ctx_p->input_curr_p++;
    #####:  845:      re_ctx_p->token.type = RE_TOK_CHAR;
    #####:  846:      re_ctx_p->token.value = ch;
        -:  847:
        -:  848:      /* Check quantifier */
    #####:  849:      break;
        -:  850:    }
        -:  851:#if ENABLED (JERRY_ES2015)
    #####:  852:    case LIT_CHAR_RIGHT_SQUARE:
        -:  853:    case LIT_CHAR_RIGHT_BRACE:
        -:  854:    {
    #####:  855:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -:  856:      {
    #####:  857:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Lone quantifier bracket."));
        -:  858:      }
        -:  859:
        -:  860:      /* FALLTHRU */
        -:  861:    }
        -:  862:#endif /* ENABLED (JERRY_ES2015) */
    #####:  863:    default:
        -:  864:    {
    #####:  865:      re_ctx_p->token.type = RE_TOK_CHAR;
    #####:  866:      re_ctx_p->token.value = ch;
        -:  867:
        -:  868:#if ENABLED (JERRY_ES2015)
    #####:  869:      if (re_ctx_p->flags & RE_FLAG_UNICODE
    #####:  870:          && lit_is_code_point_utf16_high_surrogate (ch))
        -:  871:      {
    #####:  872:        const ecma_char_t next = lit_cesu8_peek_next (re_ctx_p->input_curr_p);
    #####:  873:        if (lit_is_code_point_utf16_low_surrogate (next))
        -:  874:        {
    #####:  875:          re_ctx_p->token.value = lit_convert_surrogate_pair_to_code_point (ch, next);
    #####:  876:          re_ctx_p->input_curr_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  877:        }
        -:  878:      }
        -:  879:#endif /* ENABLED (JERRY_ES2015) */
        -:  880:
        -:  881:      /* Check quantifier */
    #####:  882:      break;
        -:  883:    }
        -:  884:  }
        -:  885:
    #####:  886:  re_parse_quantifier (re_ctx_p);
    #####:  887:  return re_check_quantifier (re_ctx_p);
        -:  888:} /* re_parse_next_token */
        -:  889:
        -:  890:/**
        -:  891: * Append a character class range to the bytecode.
        -:  892: */
        -:  893:static void
    #####:  894:re_class_add_range (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  895:                    lit_code_point_t start, /**< range begin */
        -:  896:                    lit_code_point_t end) /**< range end */
        -:  897:{
    #####:  898:  if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -:  899:  {
    #####:  900:    start = ecma_regexp_canonicalize_char (start, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####:  901:    end = ecma_regexp_canonicalize_char (end, re_ctx_p->flags & RE_FLAG_UNICODE);
        -:  902:  }
        -:  903:
    #####:  904:  re_append_char (re_ctx_p, start);
    #####:  905:  re_append_char (re_ctx_p, end);
    #####:  906:} /* re_class_add_range */
        -:  907:
        -:  908:/**
        -:  909: * Add a single character to the character class
        -:  910: */
        -:  911:static void
    #####:  912:re_class_add_char (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -:  913:                    uint32_t class_offset, /**< character class bytecode offset*/
        -:  914:                    lit_code_point_t cp) /**< code point */
        -:  915:{
    #####:  916:  if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -:  917:  {
    #####:  918:    cp = ecma_regexp_canonicalize_char (cp, re_ctx_p->flags & RE_FLAG_UNICODE);
        -:  919:  }
        -:  920:
    #####:  921:  re_insert_char (re_ctx_p, class_offset, cp);
    #####:  922:} /* re_class_add_char */
        -:  923:
        -:  924:/**
        -:  925: * Invalid character code point
        -:  926: */
        -:  927:#define RE_INVALID_CP 0xFFFFFFFF
        -:  928:
        -:  929:/**
        -:  930: * Read the input pattern and parse the range of character class
        -:  931: *
        -:  932: * @return empty ecma value - if parsed successfully
        -:  933: *         error ecma value - otherwise
        -:  934: *
        -:  935: *         Returned value must be freed with ecma_free_value
        -:  936: */
        -:  937:static ecma_value_t
    #####:  938:re_parse_char_class (re_compiler_ctx_t *re_ctx_p) /**< RegExp compiler context */
        -:  939:{
        -:  940:  static const uint8_t escape_flags[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20};
    #####:  941:  const uint32_t class_offset = re_bytecode_size (re_ctx_p);
        -:  942:
    #####:  943:  uint8_t found_escape_flags = 0;
    #####:  944:  uint8_t out_class_flags = 0;
        -:  945:
    #####:  946:  uint32_t range_count = 0;
    #####:  947:  uint32_t char_count = 0;
    #####:  948:  bool is_range = false;
        -:  949:
    #####:  950:  JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
    #####:  951:  if (*re_ctx_p->input_curr_p == LIT_CHAR_CIRCUMFLEX)
        -:  952:  {
    #####:  953:    re_ctx_p->input_curr_p++;
    #####:  954:    out_class_flags |= RE_CLASS_INVERT;
        -:  955:  }
        -:  956:
    #####:  957:  lit_code_point_t start = RE_INVALID_CP;
        -:  958:
        -:  959:  while (true)
    #####:  960:  {
    #####:  961:    if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  962:    {
    #####:  963:      return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unterminated character class."));
        -:  964:    }
        -:  965:
    #####:  966:    if (*re_ctx_p->input_curr_p == LIT_CHAR_RIGHT_SQUARE)
        -:  967:    {
    #####:  968:      if (is_range)
        -:  969:      {
    #####:  970:        if (start != RE_INVALID_CP)
        -:  971:        {
    #####:  972:          re_class_add_char (re_ctx_p, class_offset, start);
    #####:  973:          char_count++;
        -:  974:        }
        -:  975:
    #####:  976:        re_class_add_char (re_ctx_p, class_offset, LIT_CHAR_MINUS);
    #####:  977:        char_count++;
        -:  978:      }
        -:  979:
    #####:  980:      re_ctx_p->input_curr_p++;
    #####:  981:      break;
        -:  982:    }
        -:  983:
    #####:  984:    JERRY_ASSERT (re_ctx_p->input_curr_p < re_ctx_p->input_end_p);
        -:  985:    lit_code_point_t current;
        -:  986:
    #####:  987:    if (*re_ctx_p->input_curr_p == LIT_CHAR_BACKSLASH)
        -:  988:    {
    #####:  989:      re_ctx_p->input_curr_p++;
    #####:  990:      if (re_ctx_p->input_curr_p >= re_ctx_p->input_end_p)
        -:  991:      {
    #####:  992:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid escape"));
        -:  993:      }
        -:  994:
    #####:  995:      if (*re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_B)
        -:  996:      {
    #####:  997:        re_ctx_p->input_curr_p++;
    #####:  998:        current = LIT_CHAR_BS;
        -:  999:      }
        -: 1000:#if ENABLED (JERRY_ES2015)
    #####: 1001:      else if (*re_ctx_p->input_curr_p == LIT_CHAR_MINUS)
        -: 1002:      {
    #####: 1003:        re_ctx_p->input_curr_p++;
    #####: 1004:        current = LIT_CHAR_MINUS;
        -: 1005:      }
        -: 1006:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1007:      else if ((re_ctx_p->flags & RE_FLAG_UNICODE) == 0
    #####: 1008:               && *re_ctx_p->input_curr_p == LIT_CHAR_LOWERCASE_C
    #####: 1009:               && re_ctx_p->input_curr_p + 1 < re_ctx_p->input_end_p
    #####: 1010:               && (lit_char_is_decimal_digit (*(re_ctx_p->input_curr_p + 1))
    #####: 1011:                   || *(re_ctx_p->input_curr_p + 1) == LIT_CHAR_UNDERSCORE))
        -: 1012:      {
    #####: 1013:        current = ((uint8_t) *(re_ctx_p->input_curr_p + 1) % 32);
    #####: 1014:        re_ctx_p->input_curr_p += 2;
        -: 1015:      }
        -: 1016:      else
        -: 1017:      {
    #####: 1018:        if (ECMA_IS_VALUE_ERROR (re_parse_char_escape (re_ctx_p)))
        -: 1019:        {
    #####: 1020:          return ECMA_VALUE_ERROR;
        -: 1021:        }
        -: 1022:
    #####: 1023:        if (re_ctx_p->token.type == RE_TOK_CLASS_ESCAPE)
        -: 1024:        {
    #####: 1025:          const uint8_t escape = (uint8_t) re_ctx_p->token.value;
    #####: 1026:          found_escape_flags |= escape_flags[escape];
    #####: 1027:          current = RE_INVALID_CP;
        -: 1028:        }
        -: 1029:        else
        -: 1030:        {
    #####: 1031:          JERRY_ASSERT (re_ctx_p->token.type == RE_TOK_CHAR);
    #####: 1032:          current = re_ctx_p->token.value;
        -: 1033:        }
        -: 1034:      }
        -: 1035:    }
        -: 1036:#if ENABLED (JERRY_ES2015)
    #####: 1037:    else if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1038:    {
    #####: 1039:      current = ecma_regexp_unicode_advance (&re_ctx_p->input_curr_p, re_ctx_p->input_end_p);
        -: 1040:    }
        -: 1041:#endif /* ENABLED (JERRY_ES2015) */
        -: 1042:    else
        -: 1043:    {
    #####: 1044:      current = lit_cesu8_read_next (&re_ctx_p->input_curr_p);
        -: 1045:    }
        -: 1046:
    #####: 1047:    if (is_range)
        -: 1048:    {
    #####: 1049:      is_range = false;
        -: 1050:
    #####: 1051:      if (start != RE_INVALID_CP && current != RE_INVALID_CP)
        -: 1052:      {
    #####: 1053:        if (start > current)
        -: 1054:        {
    #####: 1055:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Range out of order in character class"));
        -: 1056:        }
        -: 1057:
    #####: 1058:        re_class_add_range (re_ctx_p, start, current);
    #####: 1059:        range_count++;
    #####: 1060:        continue;
        -: 1061:      }
        -: 1062:
        -: 1063:#if ENABLED (JERRY_ES2015)
    #####: 1064:      if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1065:      {
    #####: 1066:        return ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid character class"));
        -: 1067:      }
        -: 1068:#endif /* ENABLED (JERRY_ES2015) */
        -: 1069:
    #####: 1070:      if (start != RE_INVALID_CP)
        -: 1071:      {
    #####: 1072:        re_class_add_char (re_ctx_p, class_offset, start);
    #####: 1073:        char_count++;
        -: 1074:      }
    #####: 1075:      else if (current != RE_INVALID_CP)
        -: 1076:      {
    #####: 1077:        re_class_add_char (re_ctx_p, class_offset, current);
    #####: 1078:        char_count++;
        -: 1079:      }
        -: 1080:
    #####: 1081:      re_class_add_char (re_ctx_p, class_offset, LIT_CHAR_MINUS);
    #####: 1082:      char_count++;
    #####: 1083:      continue;
        -: 1084:    }
        -: 1085:
    #####: 1086:    if (re_ctx_p->input_curr_p < re_ctx_p->input_end_p
    #####: 1087:        && *re_ctx_p->input_curr_p == LIT_CHAR_MINUS)
        -: 1088:    {
    #####: 1089:      re_ctx_p->input_curr_p++;
    #####: 1090:      start = current;
    #####: 1091:      is_range = true;
    #####: 1092:      continue;
        -: 1093:    }
        -: 1094:
    #####: 1095:    if (current != RE_INVALID_CP)
        -: 1096:    {
    #####: 1097:      re_class_add_char (re_ctx_p, class_offset, current);
    #####: 1098:      char_count++;
        -: 1099:    }
        -: 1100:  }
        -: 1101:
    #####: 1102:  uint8_t escape_count = 0;
    #####: 1103:  for (ecma_class_escape_t escape = RE_ESCAPE__START; escape < RE_ESCAPE__COUNT; ++escape)
        -: 1104:  {
    #####: 1105:    if (found_escape_flags & escape_flags[escape])
        -: 1106:    {
    #####: 1107:      re_insert_byte (re_ctx_p, class_offset, (uint8_t) escape);
    #####: 1108:      escape_count++;
        -: 1109:    }
        -: 1110:  }
        -: 1111:
    #####: 1112:  if (range_count > 0)
        -: 1113:  {
    #####: 1114:    re_insert_value (re_ctx_p, class_offset, range_count);
    #####: 1115:    out_class_flags |= RE_CLASS_HAS_RANGES;
        -: 1116:  }
        -: 1117:
    #####: 1118:  if (char_count > 0)
        -: 1119:  {
    #####: 1120:    re_insert_value (re_ctx_p, class_offset, char_count);
    #####: 1121:    out_class_flags |= RE_CLASS_HAS_CHARS;
        -: 1122:  }
        -: 1123:
    #####: 1124:  JERRY_ASSERT (escape_count <= RE_CLASS_ESCAPE_COUNT_MASK);
    #####: 1125:  out_class_flags |= escape_count;
        -: 1126:
    #####: 1127:  re_insert_byte (re_ctx_p, class_offset, out_class_flags);
    #####: 1128:  re_insert_opcode (re_ctx_p, class_offset, RE_OP_CHAR_CLASS);
        -: 1129:
    #####: 1130:  re_parse_quantifier (re_ctx_p);
    #####: 1131:  return re_check_quantifier (re_ctx_p);
        -: 1132:} /* re_parse_char_class */
        -: 1133:
        -: 1134:/**
        -: 1135: * Parse alternatives
        -: 1136: *
        -: 1137: * @return empty ecma value - if alternative was successfully parsed
        -: 1138: *         error ecma value - otherwise
        -: 1139: *
        -: 1140: *         Returned value must be freed with ecma_free_value
        -: 1141: */
        -: 1142:ecma_value_t
    #####: 1143:re_parse_alternative (re_compiler_ctx_t *re_ctx_p, /**< RegExp compiler context */
        -: 1144:                      bool expect_eof) /**< expect end of file */
        -: 1145:{
    #####: 1146:  ECMA_CHECK_STACK_USAGE ();
    #####: 1147:  uint32_t alternative_offset = re_bytecode_size (re_ctx_p);
    #####: 1148:  bool first_alternative = true;
        -: 1149:
        -: 1150:  while (true)
    #####: 1151:  {
    #####: 1152:    ecma_value_t next_token_result = re_parse_next_token (re_ctx_p);
    #####: 1153:    if (ECMA_IS_VALUE_ERROR (next_token_result))
        -: 1154:    {
    #####: 1155:      return next_token_result;
        -: 1156:    }
        -: 1157:
    #####: 1158:    JERRY_ASSERT (ecma_is_value_empty (next_token_result));
        -: 1159:
    #####: 1160:    uint32_t atom_offset = re_bytecode_size (re_ctx_p);
        -: 1161:
    #####: 1162:    switch (re_ctx_p->token.type)
        -: 1163:    {
    #####: 1164:      case RE_TOK_START_CAPTURE_GROUP:
        -: 1165:      {
    #####: 1166:        const uint32_t idx = re_ctx_p->captures_count++;
    #####: 1167:        const uint32_t capture_start = idx;
        -: 1168:
    #####: 1169:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
    #####: 1170:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1171:        {
    #####: 1172:          return result;
        -: 1173:        }
        -: 1174:
    #####: 1175:        re_parse_quantifier (re_ctx_p);
        -: 1176:
    #####: 1177:        if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1178:        {
    #####: 1179:          return ECMA_VALUE_ERROR;
        -: 1180:        }
        -: 1181:
    #####: 1182:        re_insert_into_group (re_ctx_p, atom_offset, idx, capture_start, true);
    #####: 1183:        break;
        -: 1184:      }
    #####: 1185:      case RE_TOK_START_NON_CAPTURE_GROUP:
        -: 1186:      {
    #####: 1187:        const uint32_t idx = re_ctx_p->non_captures_count++;
    #####: 1188:        const uint32_t capture_start = re_ctx_p->captures_count;
        -: 1189:
    #####: 1190:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
    #####: 1191:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1192:        {
    #####: 1193:          return result;
        -: 1194:        }
        -: 1195:
    #####: 1196:        re_parse_quantifier (re_ctx_p);
        -: 1197:
    #####: 1198:        if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1199:        {
    #####: 1200:          return ECMA_VALUE_ERROR;
        -: 1201:        }
        -: 1202:
    #####: 1203:        re_insert_into_group (re_ctx_p, atom_offset, idx, capture_start, false);
    #####: 1204:        break;
        -: 1205:      }
    #####: 1206:      case RE_TOK_PERIOD:
        -: 1207:      {
        -: 1208:#if ENABLED (JERRY_ES2015)
    #####: 1209:        re_append_opcode (re_ctx_p, (re_ctx_p->flags & RE_FLAG_UNICODE) ? RE_OP_UNICODE_PERIOD : RE_OP_PERIOD);
        -: 1210:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1211:        re_append_opcode (re_ctx_p, RE_OP_PERIOD);
        -: 1212:#endif /* !ENABLED (JERRY_ES2015) */
        -: 1213:
    #####: 1214:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1215:        break;
        -: 1216:      }
    #####: 1217:      case RE_TOK_ALTERNATIVE:
        -: 1218:      {
    #####: 1219:        re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1220:        re_insert_opcode (re_ctx_p, alternative_offset, first_alternative ? RE_OP_ALTERNATIVE_START
        -: 1221:                                                                          : RE_OP_ALTERNATIVE_NEXT);
        -: 1222:
    #####: 1223:        alternative_offset = re_bytecode_size (re_ctx_p);
    #####: 1224:        first_alternative = false;
    #####: 1225:        break;
        -: 1226:      }
    #####: 1227:      case RE_TOK_ASSERT_START:
        -: 1228:      {
    #####: 1229:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_LINE_START);
    #####: 1230:        break;
        -: 1231:      }
    #####: 1232:      case RE_TOK_ASSERT_END:
        -: 1233:      {
    #####: 1234:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_LINE_END);
    #####: 1235:        break;
        -: 1236:      }
    #####: 1237:      case RE_TOK_ASSERT_WORD_BOUNDARY:
        -: 1238:      {
    #####: 1239:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_WORD_BOUNDARY);
    #####: 1240:        break;
        -: 1241:      }
    #####: 1242:      case RE_TOK_ASSERT_NOT_WORD_BOUNDARY:
        -: 1243:      {
    #####: 1244:        re_append_opcode (re_ctx_p, RE_OP_ASSERT_NOT_WORD_BOUNDARY);
    #####: 1245:        break;
        -: 1246:      }
    #####: 1247:      case RE_TOK_ASSERT_LOOKAHEAD:
        -: 1248:      {
    #####: 1249:        const uint32_t start_capture_count = re_ctx_p->captures_count;
    #####: 1250:        const bool is_negative = !!re_ctx_p->token.value;
        -: 1251:
    #####: 1252:        ecma_value_t result = re_parse_alternative (re_ctx_p, false);
        -: 1253:
    #####: 1254:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1255:        {
    #####: 1256:          return result;
        -: 1257:        }
        -: 1258:
        -: 1259:#if ENABLED (JERRY_ES2015)
    #####: 1260:        if (re_ctx_p->flags & RE_FLAG_UNICODE)
        -: 1261:        {
    #####: 1262:          re_ctx_p->token.qmin = 1;
    #####: 1263:          re_ctx_p->token.qmax = 1;
    #####: 1264:          re_ctx_p->token.greedy = true;
        -: 1265:        }
        -: 1266:        else
        -: 1267:#endif /* ENABLED (JERRY_ES2015) */
        -: 1268:        {
    #####: 1269:          re_parse_quantifier (re_ctx_p);
        -: 1270:
    #####: 1271:          if (ECMA_IS_VALUE_ERROR (re_check_quantifier (re_ctx_p)))
        -: 1272:          {
    #####: 1273:            return ECMA_VALUE_ERROR;
        -: 1274:          }
        -: 1275:        }
        -: 1276:
    #####: 1277:        re_insert_assertion_lookahead (re_ctx_p, atom_offset, start_capture_count, is_negative);
    #####: 1278:        break;
        -: 1279:      }
    #####: 1280:      case RE_TOK_BACKREFERENCE:
        -: 1281:      {
    #####: 1282:        const uint32_t backref_idx = re_ctx_p->token.value;
    #####: 1283:        re_append_opcode (re_ctx_p, RE_OP_BACKREFERENCE);
    #####: 1284:        re_append_value (re_ctx_p, backref_idx);
        -: 1285:
    #####: 1286:        if (re_ctx_p->token.qmin != 1 || re_ctx_p->token.qmax != 1)
        -: 1287:        {
    #####: 1288:          const uint32_t group_idx = re_ctx_p->non_captures_count++;
    #####: 1289:          re_insert_into_group (re_ctx_p, atom_offset, group_idx, re_ctx_p->captures_count, false);
        -: 1290:        }
        -: 1291:
    #####: 1292:        break;
        -: 1293:      }
    #####: 1294:      case RE_TOK_CLASS_ESCAPE:
        -: 1295:      {
    #####: 1296:        const ecma_class_escape_t escape = (ecma_class_escape_t) re_ctx_p->token.value;
    #####: 1297:        re_append_opcode (re_ctx_p, RE_OP_CLASS_ESCAPE);
    #####: 1298:        re_append_byte (re_ctx_p, (uint8_t) escape);
        -: 1299:
    #####: 1300:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1301:        break;
        -: 1302:      }
    #####: 1303:      case RE_TOK_CHAR_CLASS:
        -: 1304:      {
    #####: 1305:        ecma_value_t result = re_parse_char_class (re_ctx_p);
        -: 1306:
    #####: 1307:        if (ECMA_IS_VALUE_ERROR (result))
        -: 1308:        {
    #####: 1309:          return result;
        -: 1310:        }
        -: 1311:
    #####: 1312:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1313:        break;
        -: 1314:      }
    #####: 1315:      case RE_TOK_END_GROUP:
        -: 1316:      {
    #####: 1317:        if (expect_eof)
        -: 1318:        {
    #####: 1319:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unmatched ')'"));
        -: 1320:        }
        -: 1321:
    #####: 1322:        if (!first_alternative)
        -: 1323:        {
    #####: 1324:          re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1325:          re_insert_opcode (re_ctx_p, alternative_offset, RE_OP_ALTERNATIVE_NEXT);
        -: 1326:        }
        -: 1327:
    #####: 1328:        return ECMA_VALUE_EMPTY;
        -: 1329:      }
    #####: 1330:      case RE_TOK_EOF:
        -: 1331:      {
    #####: 1332:        if (!expect_eof)
        -: 1333:        {
    #####: 1334:          return ecma_raise_syntax_error (ECMA_ERR_MSG ("Unexpected end of pattern."));
        -: 1335:        }
        -: 1336:
    #####: 1337:        if (!first_alternative)
        -: 1338:        {
    #####: 1339:          re_insert_value (re_ctx_p, alternative_offset, re_bytecode_size (re_ctx_p) - alternative_offset);
    #####: 1340:          re_insert_opcode (re_ctx_p, alternative_offset, RE_OP_ALTERNATIVE_NEXT);
        -: 1341:        }
        -: 1342:
    #####: 1343:        re_append_opcode (re_ctx_p, RE_OP_EOF);
    #####: 1344:        return ECMA_VALUE_EMPTY;
        -: 1345:      }
    #####: 1346:      default:
        -: 1347:      {
    #####: 1348:        JERRY_ASSERT (re_ctx_p->token.type == RE_TOK_CHAR);
        -: 1349:
    #####: 1350:        lit_code_point_t ch = re_ctx_p->token.value;
        -: 1351:
    #####: 1352:        if (ch <= LIT_UTF8_1_BYTE_CODE_POINT_MAX && (re_ctx_p->flags & RE_FLAG_IGNORE_CASE) == 0)
        -: 1353:        {
    #####: 1354:          re_append_opcode (re_ctx_p, RE_OP_BYTE);
    #####: 1355:          re_append_byte (re_ctx_p, (uint8_t) ch);
        -: 1356:
    #####: 1357:          re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1358:          break;
        -: 1359:        }
        -: 1360:
    #####: 1361:        if (re_ctx_p->flags & RE_FLAG_IGNORE_CASE)
        -: 1362:        {
    #####: 1363:          ch = ecma_regexp_canonicalize_char (ch, re_ctx_p->flags & RE_FLAG_UNICODE);
        -: 1364:        }
        -: 1365:
    #####: 1366:        re_append_opcode (re_ctx_p, RE_OP_CHAR);
    #####: 1367:        re_append_char (re_ctx_p, ch);
        -: 1368:
    #####: 1369:        re_insert_atom_iterator (re_ctx_p, atom_offset);
    #####: 1370:        break;
        -: 1371:      }
        -: 1372:    }
        -: 1373:  }
        -: 1374:
        -: 1375:  return ECMA_VALUE_EMPTY;
        -: 1376:} /* re_parse_alternative */
        -: 1377:
        -: 1378:/**
        -: 1379: * @}
        -: 1380: * @}
        -: 1381: * @}
        -: 1382: */
        -: 1383:
        -: 1384:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
