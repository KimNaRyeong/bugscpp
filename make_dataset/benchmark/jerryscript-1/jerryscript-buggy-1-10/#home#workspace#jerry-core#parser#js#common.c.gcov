        -:    0:Source:/home/workspace/jerry-core/parser/js/common.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "common.h"
        -:   17:#include "ecma-helpers.h"
        -:   18:
        -:   19:#if ENABLED (JERRY_PARSER)
        -:   20:
        -:   21:/** \addtogroup parser Parser
        -:   22: * @{
        -:   23: *
        -:   24: * \addtogroup jsparser JavaScript
        -:   25: * @{
        -:   26: *
        -:   27: * \addtogroup jsparser_utils Utility
        -:   28: * @{
        -:   29: */
        -:   30:
        -:   31:/**
        -:   32: * Free literal.
        -:   33: */
        -:   34:void
    #####:   35:util_free_literal (lexer_literal_t *literal_p) /**< literal */
        -:   36:{
    #####:   37:  if (literal_p->type == LEXER_IDENT_LITERAL
    #####:   38:      || literal_p->type == LEXER_STRING_LITERAL)
        -:   39:  {
    #####:   40:    if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:   41:    {
    #####:   42:      jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);
        -:   43:    }
        -:   44:  }
    #####:   45:  else if ((literal_p->type == LEXER_FUNCTION_LITERAL)
    #####:   46:           || (literal_p->type == LEXER_REGEXP_LITERAL))
        -:   47:  {
    #####:   48:    ecma_bytecode_deref (literal_p->u.bytecode_p);
        -:   49:  }
    #####:   50:} /* util_free_literal */
        -:   51:
        -:   52:#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)
        -:   53:
        -:   54:/**
        -:   55: * Debug utility to print a character sequence.
        -:   56: */
        -:   57:static void
        -:   58:util_print_chars (const uint8_t *char_p, /**< character pointer */
        -:   59:                  size_t size) /**< size */
        -:   60:{
        -:   61:  while (size > 0)
        -:   62:  {
        -:   63:    JERRY_DEBUG_MSG ("%c", *char_p++);
        -:   64:    size--;
        -:   65:  }
        -:   66:} /* util_print_chars */
        -:   67:
        -:   68:/**
        -:   69: * Debug utility to print a number.
        -:   70: */
        -:   71:static void
        -:   72:util_print_number (ecma_number_t num_p) /**< number to print */
        -:   73:{
        -:   74:  lit_utf8_byte_t str_buf[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
        -:   75:  lit_utf8_size_t str_size = ecma_number_to_utf8_string (num_p, str_buf, sizeof (str_buf));
        -:   76:  str_buf[str_size] = 0;
        -:   77:  JERRY_DEBUG_MSG ("%s", str_buf);
        -:   78:} /* util_print_number */
        -:   79:
        -:   80:/**
        -:   81: * Print literal.
        -:   82: */
        -:   83:void
        -:   84:util_print_literal (lexer_literal_t *literal_p) /**< literal */
        -:   85:{
        -:   86:  if (literal_p->type == LEXER_IDENT_LITERAL)
        -:   87:  {
        -:   88:    JERRY_DEBUG_MSG ("ident(");
        -:   89:    util_print_chars (literal_p->u.char_p, literal_p->prop.length);
        -:   90:  }
        -:   91:  else if (literal_p->type == LEXER_FUNCTION_LITERAL)
        -:   92:  {
        -:   93:    JERRY_DEBUG_MSG ("function");
        -:   94:    return;
        -:   95:  }
        -:   96:  else if (literal_p->type == LEXER_STRING_LITERAL)
        -:   97:  {
        -:   98:    JERRY_DEBUG_MSG ("string(");
        -:   99:    util_print_chars (literal_p->u.char_p, literal_p->prop.length);
        -:  100:  }
        -:  101:  else if (literal_p->type == LEXER_NUMBER_LITERAL)
        -:  102:  {
        -:  103:    JERRY_DEBUG_MSG ("number(");
        -:  104:    util_print_number (ecma_get_number_from_value (literal_p->u.value));
        -:  105:  }
        -:  106:  else if (literal_p->type == LEXER_REGEXP_LITERAL)
        -:  107:  {
        -:  108:    JERRY_DEBUG_MSG ("regexp");
        -:  109:    return;
        -:  110:  }
        -:  111:  else
        -:  112:  {
        -:  113:    JERRY_DEBUG_MSG ("unknown");
        -:  114:    return;
        -:  115:  }
        -:  116:
        -:  117:  JERRY_DEBUG_MSG (")");
        -:  118:} /* util_print_literal */
        -:  119:
        -:  120:#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */
        -:  121:
        -:  122:/**
        -:  123: * @}
        -:  124: * @}
        -:  125: * @}
        -:  126: */
        -:  127:
        -:  128:#endif /* ENABLED (JERRY_PARSER) */
