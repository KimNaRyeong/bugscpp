        -:    0:Source:/home/workspace/jerry-libm/log1p.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: *
        -:   15: * This file is based on work under the following copyright and permission
        -:   16: * notice:
        -:   17: *
        -:   18: *     Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
        -:   19: *
        -:   20: *     Permission to use, copy, modify, and distribute this
        -:   21: *     software is freely granted, provided that this notice
        -:   22: *     is preserved.
        -:   23: *
        -:   24: *     @(#)s_log1p.c 5.1 93/09/24
        -:   25: */
        -:   26:
        -:   27:#include "jerry-libm-internal.h"
        -:   28:
        -:   29:/* log1p(x)
        -:   30: * Method :
        -:   31: *   1. Argument Reduction: find k and f such that
        -:   32: *      1+x = 2^k * (1+f),
        -:   33: *     where  sqrt(2)/2 < 1+f < sqrt(2) .
        -:   34: *
        -:   35: *      Note. If k=0, then f=x is exact. However, if k!=0, then f
        -:   36: *  may not be representable exactly. In that case, a correction
        -:   37: *  term is need. Let u=1+x rounded. Let c = (1+x)-u, then
        -:   38: *  log(1+x) - log(u) ~ c/u. Thus, we proceed to compute log(u),
        -:   39: *  and add back the correction term c/u.
        -:   40: *  (Note: when x > 2**53, one can simply return log(x))
        -:   41: *
        -:   42: *   2. Approximation of log1p(f).
        -:   43: *  Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)
        -:   44: *     = 2s + 2/3 s**3 + 2/5 s**5 + .....,
        -:   45: *          = 2s + s*R
        -:   46: *      We use a special Reme algorithm on [0,0.1716] to generate
        -:   47: *   a polynomial of degree 14 to approximate R The maximum error
        -:   48: *  of this polynomial approximation is bounded by 2**-58.45. In
        -:   49: *  other words,
        -:   50: *            2      4      6      8      10      12      14
        -:   51: *      R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s
        -:   52: *    (the values of Lp1 to Lp7 are listed in the program)
        -:   53: *  and
        -:   54: *      |      2          14          |     -58.45
        -:   55: *      | Lp1*s +...+Lp7*s    -  R(z) | <= 2
        -:   56: *      |                             |
        -:   57: *  Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.
        -:   58: *  In order to guarantee error in log below 1ulp, we compute log
        -:   59: *  by
        -:   60: *    log1p(f) = f - (hfsq - s*(hfsq+R)).
        -:   61: *
        -:   62: *  3. Finally, log1p(x) = k*ln2 + log1p(f).
        -:   63: *            = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))
        -:   64: *     Here ln2 is split into two floating point number:
        -:   65: *      ln2_hi + ln2_lo,
        -:   66: *     where n*ln2_hi is always exact for |n| < 2000.
        -:   67: *
        -:   68: * Special cases:
        -:   69: *  log1p(x) is NaN with signal if x < -1 (including -INF) ;
        -:   70: *  log1p(+INF) is +INF; log1p(-1) is -INF with signal;
        -:   71: *  log1p(NaN) is that NaN with no signal.
        -:   72: *
        -:   73: * Accuracy:
        -:   74: *  according to an error analysis, the error is always less than
        -:   75: *  1 ulp (unit in the last place).
        -:   76: *
        -:   77: * Constants:
        -:   78: * The hexadecimal values are the intended ones for the following
        -:   79: * constants. The decimal values may be used, provided that the
        -:   80: * compiler will convert from decimal to binary accurately enough
        -:   81: * to produce the hexadecimal values shown.
        -:   82: *
        -:   83: * Note: Assuming log() return accurate answer, the following
        -:   84: *    algorithm can be used to compute log1p(x) to within a few ULP:
        -:   85: *
        -:   86: *    u = 1+x;
        -:   87: *    if(u==1.0) return x ; else
        -:   88: *         return log(u)*(x/(u-1.0));
        -:   89: *
        -:   90: *   See HP-15C Advanced Functions Handbook, p.193.
        -:   91: */
        -:   92:
        -:   93:#define zero 0.0
        -:   94:#define ln2_hi 6.93147180369123816490e-01 /* 3fe62e42 fee00000 */
        -:   95:#define ln2_lo 1.90821492927058770002e-10 /* 3dea39ef 35793c76 */
        -:   96:#define two54 1.80143985094819840000e+16  /* 43500000 00000000 */
        -:   97:#define Lp1 6.666666666666735130e-01      /* 3FE55555 55555593 */
        -:   98:#define Lp2 3.999999999940941908e-01      /* 3FD99999 9997FA04 */
        -:   99:#define Lp3 2.857142874366239149e-01      /* 3FD24924 94229359 */
        -:  100:#define Lp4 2.222219843214978396e-01      /* 3FCC71C5 1D8E78AF */
        -:  101:#define Lp5 1.818357216161805012e-01      /* 3FC74664 96CB03DE */
        -:  102:#define Lp6 1.531383769920937332e-01      /* 3FC39A09 D078C69F */
        -:  103:#define Lp7 1.479819860511658591e-01      /* 3FC2F112 DF3E5244 */
        -:  104:
        -:  105:double
    #####:  106:log1p (double x)
        -:  107:{
        -:  108:  double hfsq, f, c, s, z, R;
        -:  109:  double_accessor u;
        -:  110:  int k, hx, hu, ax;
        -:  111:
    #####:  112:  hx = __HI (x);
    #####:  113:  ax = hx & 0x7fffffff;
    #####:  114:  c = 0;
    #####:  115:  k = 1;
    #####:  116:  if (hx < 0x3FDA827A)
        -:  117:  {
        -:  118:    /* 1+x < sqrt(2)+ */
    #####:  119:    if (ax >= 0x3ff00000)
        -:  120:    {
        -:  121:      /* x <= -1.0 */
    #####:  122:      if (x == -1.0)
        -:  123:      {
        -:  124:        /* log1p(-1) = +inf */
    #####:  125:        return -two54 / zero;
        -:  126:      }
        -:  127:      else
        -:  128:      {
        -:  129:        /* log1p(x<-1) = NaN */
    #####:  130:        return NAN;
        -:  131:      }
        -:  132:    }
    #####:  133:    if (ax < 0x3e200000)
        -:  134:    {                         /* |x| < 2**-29 */
    #####:  135:      if ((two54 + x > zero)    /* raise inexact */
    #####:  136:          && (ax < 0x3c900000)) /* |x| < 2**-54 */
        -:  137:      {
    #####:  138:        return x;
        -:  139:      }
        -:  140:      else
        -:  141:      {
    #####:  142:        return x - x * x * 0.5;
        -:  143:      }
        -:  144:    }
    #####:  145:    if ((hx > 0) || hx <= ((int) 0xbfd2bec4))
        -:  146:    {
        -:  147:      /* sqrt(2)/2- <= 1+x < sqrt(2)+ */
    #####:  148:      k = 0;
    #####:  149:      f = x;
    #####:  150:      hu = 1;
        -:  151:    }
        -:  152:  }
    #####:  153:  if (hx >= 0x7ff00000)
        -:  154:  {
    #####:  155:    return x + x;
        -:  156:  }
    #####:  157:  if (k != 0)
        -:  158:  {
    #####:  159:    if (hx < 0x43400000)
        -:  160:    {
    #####:  161:      u.dbl = 1.0 + x;
    #####:  162:      hu = u.as_int.hi;
    #####:  163:      k = (hu >> 20) - 1023;
    #####:  164:      c = (k > 0) ? 1.0 - (u.dbl - x) : x - (u.dbl - 1.0); /* correction term */
    #####:  165:      c /= u.dbl;
        -:  166:    }
        -:  167:    else
        -:  168:    {
    #####:  169:      u.dbl = x;
    #####:  170:      hu = u.as_int.hi;
    #####:  171:      k = (hu >> 20) - 1023;
    #####:  172:      c = 0;
        -:  173:    }
    #####:  174:    hu &= 0x000fffff;
        -:  175:    /*
        -:  176:     * The approximation to sqrt(2) used in thresholds is not
        -:  177:     * critical.  However, the ones used above must give less
        -:  178:     * strict bounds than the one here so that the k==0 case is
        -:  179:     * never reached from here, since here we have committed to
        -:  180:     * using the correction term but don't use it if k==0.
        -:  181:     */
    #####:  182:    if (hu < 0x6a09e)
        -:  183:    {
        -:  184:      /* u ~< sqrt(2) */
    #####:  185:      u.as_int.hi = hu | 0x3ff00000; /* normalize u */
        -:  186:    }
        -:  187:    else
        -:  188:    {
    #####:  189:      k += 1;
    #####:  190:      u.as_int.hi = hu | 0x3fe00000; /* normalize u/2 */
    #####:  191:      hu = (0x00100000 - hu) >> 2;
        -:  192:    }
    #####:  193:    f = u.dbl - 1.0;
        -:  194:  }
    #####:  195:  hfsq = 0.5 * f * f;
    #####:  196:  if (hu == 0)
        -:  197:  {
        -:  198:    /* |f| < 2**-20 */
    #####:  199:    if (f == zero)
        -:  200:    {
    #####:  201:      if (k == 0)
        -:  202:      {
    #####:  203:        return zero;
        -:  204:      }
        -:  205:      else
        -:  206:      {
    #####:  207:        c += k * ln2_lo;
    #####:  208:        return k * ln2_hi + c;
        -:  209:      }
        -:  210:    }
    #####:  211:    R = hfsq * (1.0 - 0.66666666666666666 * f);
    #####:  212:    if (k == 0)
        -:  213:    {
    #####:  214:      return f - R;
        -:  215:    }
        -:  216:    else
        -:  217:    {
    #####:  218:      return k * ln2_hi - ((R - (k * ln2_lo + c)) - f);
        -:  219:    }
        -:  220:  }
    #####:  221:  s = f / (2.0 + f);
    #####:  222:  z = s * s;
    #####:  223:  R = z * (Lp1 +
    #####:  224:           z * (Lp2 + z * (Lp3 + z * (Lp4 + z * (Lp5 + z * (Lp6 + z * Lp7))))));
    #####:  225:  if (k == 0)
        -:  226:  {
    #####:  227:    return f - (hfsq - s * (hfsq + R));
        -:  228:  }
        -:  229:  else
        -:  230:  {
    #####:  231:    return k * ln2_hi - ((hfsq - (s * (hfsq + R) + (k * ln2_lo + c))) - f);
        -:  232:  }
        -:  233:} /* log1p */
        -:  234:
        -:  235:#undef zero
        -:  236:#undef ln2_hi
        -:  237:#undef ln2_lo
        -:  238:#undef two54
        -:  239:#undef Lp1
        -:  240:#undef Lp2
        -:  241:#undef Lp3
        -:  242:#undef Lp4
        -:  243:#undef Lp5
        -:  244:#undef Lp6
        -:  245:#undef Lp7
