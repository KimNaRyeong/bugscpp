        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jcontext.h"
        -:   17:#include "js-parser-internal.h"
        -:   18:#include "js-scanner-internal.h"
        -:   19:#include "lit-char-helpers.h"
        -:   20:
        -:   21:#if ENABLED (JERRY_PARSER)
        -:   22:
        -:   23:/** \addtogroup parser Parser
        -:   24: * @{
        -:   25: *
        -:   26: * \addtogroup jsparser JavaScript
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup jsparser_scanner Scanner
        -:   30: * @{
        -:   31: */
        -:   32:
        -:   33:/**
        -:   34: * Scan return types.
        -:   35: */
        -:   36:typedef enum
        -:   37:{
        -:   38:  SCAN_NEXT_TOKEN, /**< get next token after return */
        -:   39:  SCAN_KEEP_TOKEN, /**< keep the current token after return */
        -:   40:} scan_return_types_t;
        -:   41:
        -:   42:/**
        -:   43: * Checks whether token type is "of".
        -:   44: */
        -:   45:#if ENABLED (JERRY_ES2015)
        -:   46:#define SCANNER_IDENTIFIER_IS_OF() (lexer_token_is_identifier (context_p, "of", 2))
        -:   47:#else
        -:   48:#define SCANNER_IDENTIFIER_IS_OF() (false)
        -:   49:#endif /* ENABLED (JERRY_ES2015) */
        -:   50:
        -:   51:#if ENABLED (JERRY_ES2015)
        -:   52:
        -:   53:JERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_GENERATOR)
        -:   54:                     == SCAN_STACK_COMPUTED_GENERATOR,
        -:   55:                     scanner_invalid_conversion_from_literal_pool_generator_to_computed_generator);
        -:   56:JERRY_STATIC_ASSERT (SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (SCANNER_LITERAL_POOL_ASYNC)
        -:   57:                     == SCAN_STACK_COMPUTED_ASYNC,
        -:   58:                     scanner_invalid_conversion_from_literal_pool_async_to_computed_async);
        -:   59:
        -:   60:JERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_GENERATOR)
        -:   61:                     == SCANNER_LITERAL_POOL_GENERATOR,
        -:   62:                     scanner_invalid_conversion_from_computed_generator_to_literal_pool_generator);
        -:   63:JERRY_STATIC_ASSERT (SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (SCAN_STACK_COMPUTED_ASYNC)
        -:   64:                     == SCANNER_LITERAL_POOL_ASYNC,
        -:   65:                     scanner_invalid_conversion_from_computed_async_to_literal_pool_async);
        -:   66:
        -:   67:#endif /* ENABLED (JERRY_ES2015) */
        -:   68:
        -:   69:/**
        -:   70: * Scan primary expression.
        -:   71: *
        -:   72: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -:   73: */
        -:   74:static scan_return_types_t
       35:   75:scanner_scan_primary_expression (parser_context_t *context_p, /**< context */
        -:   76:                                 scanner_context_t *scanner_context_p, /* scanner context */
        -:   77:                                 lexer_token_type_t type, /**< current token type */
        -:   78:                                 scan_stack_modes_t stack_top) /**< current stack top */
        -:   79:{
       35:   80:  switch (type)
        -:   81:  {
        3:   82:    case LEXER_KEYW_NEW:
        -:   83:    {
        3:   84:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW;
        -:   85:
        -:   86:#if ENABLED (JERRY_ES2015)
        3:   87:      if (scanner_try_scan_new_target (context_p))
        -:   88:      {
    #####:   89:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -:   90:      }
        -:   91:#endif /* ENABLED (JERRY_ES2015) */
        3:   92:      break;
        -:   93:    }
    #####:   94:    case LEXER_DIVIDE:
        -:   95:    case LEXER_ASSIGN_DIVIDE:
        -:   96:    {
    #####:   97:      lexer_construct_regexp_object (context_p, true);
    #####:   98:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:   99:      break;
        -:  100:    }
    #####:  101:    case LEXER_KEYW_FUNCTION:
        -:  102:    {
    #####:  103:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -:  104:
        -:  105:#if ENABLED (JERRY_ES2015)
    #####:  106:      if (scanner_context_p->async_source_p != NULL)
        -:  107:      {
    #####:  108:        status_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -:  109:      }
        -:  110:
    #####:  111:      if (lexer_consume_generator (context_p))
        -:  112:      {
    #####:  113:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -:  114:      }
        -:  115:#endif /* ENABLED (JERRY_ES2015) */
        -:  116:
    #####:  117:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -:  118:
    #####:  119:      lexer_next_token (context_p);
        -:  120:
    #####:  121:      if (context_p->token.type == LEXER_LITERAL
    #####:  122:          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  123:      {
    #####:  124:        lexer_next_token (context_p);
        -:  125:      }
        -:  126:
    #####:  127:      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_EXPRESSION);
    #####:  128:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####:  129:      return SCAN_KEEP_TOKEN;
        -:  130:    }
    #####:  131:    case LEXER_LEFT_PAREN:
        -:  132:    {
    #####:  133:      scanner_scan_bracket (context_p, scanner_context_p);
    #####:  134:      return SCAN_KEEP_TOKEN;
        -:  135:    }
        2:  136:    case LEXER_LEFT_SQUARE:
        -:  137:    {
        -:  138:#if ENABLED (JERRY_ES2015)
        2:  139:      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);
        -:  140:#endif /* ENABLED (JERRY_ES2015) */
        -:  141:
        2:  142:      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
        2:  143:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        2:  144:      break;
        -:  145:    }
        1:  146:    case LEXER_LEFT_BRACE:
        -:  147:    {
        -:  148:#if ENABLED (JERRY_ES2015)
        1:  149:      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_NONE, false);
        -:  150:#endif /* ENABLED (JERRY_ES2015) */
        -:  151:
        1:  152:      parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
        1:  153:      scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
        1:  154:      return SCAN_KEEP_TOKEN;
        -:  155:    }
        -:  156:#if ENABLED (JERRY_ES2015)
    #####:  157:    case LEXER_TEMPLATE_LITERAL:
        -:  158:    {
    #####:  159:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -:  160:      {
    #####:  161:        parser_stack_push_uint8 (context_p, SCAN_STACK_TEMPLATE_STRING);
    #####:  162:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  163:        break;
        -:  164:      }
        -:  165:
        -:  166:      /* The string is a normal string literal. */
        -:  167:      /* FALLTHRU */
        -:  168:    }
        -:  169:#endif /* ENABLED (JERRY_ES2015) */
    #####:  170:    case LEXER_LITERAL:
        -:  171:    {
        -:  172:#if ENABLED (JERRY_ES2015)
       25:  173:      const uint8_t *source_p = context_p->source_p;
        -:  174:
       25:  175:      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL
       16:  176:          && lexer_check_arrow (context_p))
        -:  177:      {
    #####:  178:        scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);
    #####:  179:        return SCAN_KEEP_TOKEN;
        -:  180:      }
       25:  181:      else if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -:  182:      {
    #####:  183:        scanner_context_p->async_source_p = source_p;
    #####:  184:        scanner_check_async_function (context_p, scanner_context_p);
    #####:  185:        return SCAN_KEEP_TOKEN;
        -:  186:      }
        -:  187:#endif /* ENABLED (JERRY_ES2015) */
        -:  188:
       25:  189:      if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  190:      {
       16:  191:        scanner_add_reference (context_p, scanner_context_p);
        -:  192:      }
        -:  193:      /* FALLTHRU */
        -:  194:    }
        -:  195:    case LEXER_KEYW_THIS:
        -:  196:    case LEXER_KEYW_SUPER:
        -:  197:    case LEXER_LIT_TRUE:
        -:  198:    case LEXER_LIT_FALSE:
        -:  199:    case LEXER_LIT_NULL:
        -:  200:    {
       25:  201:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
       25:  202:      break;
        -:  203:    }
        -:  204:#if ENABLED (JERRY_ES2015)
    #####:  205:    case LEXER_KEYW_CLASS:
        -:  206:    {
    #####:  207:      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_EXPRESSION);
        -:  208:
    #####:  209:      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  210:      {
    #####:  211:        return SCAN_KEEP_TOKEN;
        -:  212:      }
    #####:  213:      break;
        -:  214:    }
        -:  215:#endif /* ENABLED (JERRY_ES2015) */
        1:  216:    case LEXER_RIGHT_SQUARE:
        -:  217:    {
        1:  218:      if (stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  219:      {
    #####:  220:        scanner_raise_error (context_p);
        -:  221:      }
        -:  222:
        1:  223:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        1:  224:      return SCAN_KEEP_TOKEN;
        -:  225:    }
        -:  226:#if ENABLED (JERRY_ES2015)
    #####:  227:    case LEXER_THREE_DOTS:
        -:  228:    {
        -:  229:      /* Elision or spread arguments */
    #####:  230:      if (stack_top != SCAN_STACK_PAREN_EXPRESSION && stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  231:      {
    #####:  232:        scanner_raise_error (context_p);
        -:  233:      }
    #####:  234:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  235:      break;
        -:  236:    }
        -:  237:#endif /* ENABLED (JERRY_ES2015) */
    #####:  238:    case LEXER_COMMA:
        -:  239:    {
    #####:  240:      if (stack_top != SCAN_STACK_ARRAY_LITERAL)
        -:  241:      {
    #####:  242:        scanner_raise_error (context_p);
        -:  243:      }
    #####:  244:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  245:
        -:  246:#if ENABLED (JERRY_ES2015)
    #####:  247:      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -:  248:      {
    #####:  249:        scanner_context_p->mode = SCAN_MODE_BINDING;
        -:  250:      }
        -:  251:#endif /* ENABLED (JERRY_ES2015) */
    #####:  252:      break;
        -:  253:    }
        -:  254:#if ENABLED (JERRY_ES2015)
    #####:  255:    case LEXER_KEYW_YIELD:
        -:  256:    {
    #####:  257:      lexer_next_token (context_p);
        -:  258:
    #####:  259:      if (lexer_check_yield_no_arg (context_p))
        -:  260:      {
    #####:  261:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  262:      }
        -:  263:
    #####:  264:      if (context_p->token.type == LEXER_MULTIPLY)
        -:  265:      {
    #####:  266:        return SCAN_NEXT_TOKEN;
        -:  267:      }
    #####:  268:      return SCAN_KEEP_TOKEN;
        -:  269:    }
        -:  270:#endif /* ENABLED (JERRY_ES2015) */
        3:  271:    case LEXER_RIGHT_PAREN:
        -:  272:    {
        3:  273:      if (stack_top == SCAN_STACK_PAREN_EXPRESSION)
        -:  274:      {
        3:  275:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        3:  276:        parser_stack_pop_uint8 (context_p);
        3:  277:        break;
        -:  278:      }
        -:  279:      /* FALLTHRU */
        -:  280:    }
        -:  281:    default:
        -:  282:    {
    #####:  283:      scanner_raise_error (context_p);
        -:  284:    }
        -:  285:  }
       33:  286:  return SCAN_NEXT_TOKEN;
        -:  287:} /* scanner_scan_primary_expression */
        -:  288:
        -:  289:/**
        -:  290: * Scan the tokens after the primary expression.
        -:  291: *
        -:  292: * @return true for break, false for fall through
        -:  293: */
        -:  294:static bool
       55:  295:scanner_scan_post_primary_expression (parser_context_t *context_p, /**< context */
        -:  296:                                      scanner_context_t *scanner_context_p, /**< scanner context */
        -:  297:                                      lexer_token_type_t type, /**< current token type */
        -:  298:                                      scan_stack_modes_t stack_top) /**< current stack top */
        -:  299:{
       55:  300:  switch (type)
        -:  301:  {
        4:  302:    case LEXER_DOT:
        -:  303:    {
        4:  304:      lexer_scan_identifier (context_p);
        -:  305:
        4:  306:      if (context_p->token.type != LEXER_LITERAL
        4:  307:          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  308:      {
    #####:  309:        scanner_raise_error (context_p);
        -:  310:      }
        -:  311:
        4:  312:      return true;
        -:  313:    }
        6:  314:    case LEXER_LEFT_PAREN:
        -:  315:    {
        6:  316:      parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
        6:  317:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        6:  318:      return true;
        -:  319:    }
        -:  320:#if ENABLED (JERRY_ES2015)
    #####:  321:    case LEXER_TEMPLATE_LITERAL:
        -:  322:    {
    #####:  323:      if (JERRY_UNLIKELY (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT))
        -:  324:      {
    #####:  325:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  326:        parser_stack_push_uint8 (context_p, SCAN_STACK_TAGGED_TEMPLATE_LITERAL);
        -:  327:      }
    #####:  328:      return true;
        -:  329:    }
        -:  330:#endif /* ENABLED (JERRY_ES2015) */
        1:  331:    case LEXER_LEFT_SQUARE:
        -:  332:    {
        1:  333:      parser_stack_push_uint8 (context_p, SCAN_STACK_PROPERTY_ACCESSOR);
        1:  334:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        1:  335:      return true;
        -:  336:    }
    #####:  337:    case LEXER_INCREASE:
        -:  338:    case LEXER_DECREASE:
        -:  339:    {
    #####:  340:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  341:
    #####:  342:      if (context_p->token.flags & LEXER_WAS_NEWLINE)
        -:  343:      {
    #####:  344:        return false;
        -:  345:      }
        -:  346:
    #####:  347:      lexer_next_token (context_p);
    #####:  348:      type = (lexer_token_type_t) context_p->token.type;
        -:  349:
    #####:  350:      if (type != LEXER_QUESTION_MARK)
        -:  351:      {
    #####:  352:        break;
        -:  353:      }
        -:  354:      /* FALLTHRU */
        -:  355:    }
        -:  356:    case LEXER_QUESTION_MARK:
        -:  357:    {
    #####:  358:      parser_stack_push_uint8 (context_p, SCAN_STACK_COLON_EXPRESSION);
    #####:  359:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  360:      return true;
        -:  361:    }
       44:  362:    default:
        -:  363:    {
       44:  364:      break;
        -:  365:    }
        -:  366:  }
        -:  367:
       44:  368:  if (LEXER_IS_BINARY_OP_TOKEN (type)
        5:  369:      && (type != LEXER_KEYW_IN || !SCANNER_IS_FOR_START (stack_top)))
        -:  370:  {
        5:  371:    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        5:  372:    return true;
        -:  373:  }
        -:  374:
       39:  375:  return false;
        -:  376:} /* scanner_scan_post_primary_expression */
        -:  377:
        -:  378:/**
        -:  379: * Scan the tokens after the primary expression.
        -:  380: *
        -:  381: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -:  382: */
        -:  383:static scan_return_types_t
       40:  384:scanner_scan_primary_expression_end (parser_context_t *context_p, /**< context */
        -:  385:                                     scanner_context_t *scanner_context_p, /**< scanner context */
        -:  386:                                     lexer_token_type_t type, /**< current token type */
        -:  387:                                     scan_stack_modes_t stack_top) /**< current stack top */
        -:  388:{
       40:  389:  if (type == LEXER_COMMA)
        -:  390:  {
        4:  391:    switch (stack_top)
        -:  392:    {
    #####:  393:      case SCAN_STACK_VAR:
        -:  394:#if ENABLED (JERRY_ES2015)
        -:  395:      case SCAN_STACK_LET:
        -:  396:      case SCAN_STACK_CONST:
        -:  397:#endif /* ENABLED (JERRY_ES2015) */
        -:  398:      case SCAN_STACK_FOR_VAR_START:
        -:  399:#if ENABLED (JERRY_ES2015)
        -:  400:      case SCAN_STACK_FOR_LET_START:
        -:  401:      case SCAN_STACK_FOR_CONST_START:
        -:  402:#endif /* ENABLED (JERRY_ES2015) */
        -:  403:      {
    #####:  404:        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####:  405:        return SCAN_NEXT_TOKEN;
        -:  406:      }
    #####:  407:      case SCAN_STACK_COLON_EXPRESSION:
        -:  408:      {
    #####:  409:        scanner_raise_error (context_p);
    #####:  410:        break;
        -:  411:      }
        -:  412:#if ENABLED (JERRY_ES2015)
    #####:  413:      case SCAN_STACK_BINDING_INIT:
        -:  414:      case SCAN_STACK_BINDING_LIST_INIT:
        -:  415:      {
    #####:  416:        break;
        -:  417:      }
    #####:  418:      case SCAN_STACK_ARROW_ARGUMENTS:
        -:  419:      {
    #####:  420:        lexer_next_token (context_p);
    #####:  421:        scanner_check_arrow_arg (context_p, scanner_context_p);
    #####:  422:        return SCAN_KEEP_TOKEN;
        -:  423:      }
    #####:  424:      case SCAN_STACK_ARROW_EXPRESSION:
        -:  425:      {
    #####:  426:        break;
        -:  427:      }
    #####:  428:      case SCAN_STACK_FUNCTION_PARAMETERS:
        -:  429:      {
    #####:  430:        scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;
    #####:  431:        parser_stack_pop_uint8 (context_p);
    #####:  432:        return SCAN_NEXT_TOKEN;
        -:  433:      }
        3:  434:      case SCAN_STACK_ARRAY_LITERAL:
        -:  435:      {
        3:  436:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  437:
        3:  438:        if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -:  439:        {
    #####:  440:          scanner_context_p->mode = SCAN_MODE_BINDING;
        -:  441:        }
        -:  442:
        3:  443:        return SCAN_NEXT_TOKEN;
        -:  444:      }
        -:  445:#endif /* ENABLED (JERRY_ES2015) */
        1:  446:      case SCAN_STACK_OBJECT_LITERAL:
        -:  447:      {
        1:  448:        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
        1:  449:        return SCAN_KEEP_TOKEN;
        -:  450:      }
    #####:  451:      default:
        -:  452:      {
    #####:  453:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  454:        return SCAN_NEXT_TOKEN;
        -:  455:      }
        -:  456:    }
       36:  457:  }
        -:  458:
       36:  459:  switch (stack_top)
        -:  460:  {
    #####:  461:    case SCAN_STACK_WITH_EXPRESSION:
        -:  462:    {
    #####:  463:      if (type != LEXER_RIGHT_PAREN)
        -:  464:      {
    #####:  465:        break;
        -:  466:      }
        -:  467:
    #####:  468:      parser_stack_pop_uint8 (context_p);
        -:  469:
    #####:  470:      uint16_t status_flags = scanner_context_p->active_literal_pool_p->status_flags;
    #####:  471:      parser_stack_push_uint8 (context_p, (status_flags & SCANNER_LITERAL_POOL_IN_WITH) ? 1 : 0);
    #####:  472:      parser_stack_push_uint8 (context_p, SCAN_STACK_WITH_STATEMENT);
    #####:  473:      status_flags |= SCANNER_LITERAL_POOL_IN_WITH;
    #####:  474:      scanner_context_p->active_literal_pool_p->status_flags = status_flags;
        -:  475:
    #####:  476:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  477:      return SCAN_NEXT_TOKEN;
        -:  478:    }
        1:  479:    case SCAN_STACK_DO_EXPRESSION:
        -:  480:    {
        1:  481:      if (type != LEXER_RIGHT_PAREN)
        -:  482:      {
    #####:  483:        break;
        -:  484:      }
        -:  485:
        1:  486:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        1:  487:      return SCAN_NEXT_TOKEN;
        -:  488:    }
    #####:  489:    case SCAN_STACK_WHILE_EXPRESSION:
        -:  490:    {
    #####:  491:      if (type != LEXER_RIGHT_PAREN)
        -:  492:      {
    #####:  493:        break;
        -:  494:      }
        -:  495:
    #####:  496:      scanner_source_start_t source_start;
        -:  497:
    #####:  498:      parser_stack_pop_uint8 (context_p);
    #####:  499:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  500:
        -:  501:      scanner_location_info_t *location_info_p;
    #####:  502:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  503:                                                                         source_start.source_p,
        -:  504:                                                                         sizeof (scanner_location_info_t));
    #####:  505:      location_info_p->info.type = SCANNER_TYPE_WHILE;
        -:  506:
    #####:  507:      scanner_get_location (&location_info_p->location, context_p);
        -:  508:
    #####:  509:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  510:      return SCAN_NEXT_TOKEN;
        -:  511:    }
        3:  512:    case SCAN_STACK_PAREN_EXPRESSION:
        -:  513:    {
        3:  514:      if (type != LEXER_RIGHT_PAREN)
        -:  515:      {
    #####:  516:        break;
        -:  517:      }
        -:  518:
        3:  519:      parser_stack_pop_uint8 (context_p);
        -:  520:
        -:  521:#if ENABLED (JERRY_ES2015)
        3:  522:      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  523:      {
    #####:  524:        scanner_add_async_literal (context_p, scanner_context_p);
        -:  525:      }
        -:  526:#endif /* ENABLED (JERRY_ES2015) */
        -:  527:
        3:  528:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        3:  529:      return SCAN_NEXT_TOKEN;
        -:  530:    }
    #####:  531:    case SCAN_STACK_STATEMENT_WITH_EXPR:
        -:  532:    {
    #####:  533:      if (type != LEXER_RIGHT_PAREN)
        -:  534:      {
    #####:  535:        break;
        -:  536:      }
        -:  537:
    #####:  538:      parser_stack_pop_uint8 (context_p);
        -:  539:
        -:  540:#if ENABLED (JERRY_ES2015)
    #####:  541:      if (context_p->stack_top_uint8 == SCAN_STACK_IF_STATEMENT)
        -:  542:      {
    #####:  543:        scanner_check_function_after_if (context_p, scanner_context_p);
    #####:  544:        return SCAN_KEEP_TOKEN;
        -:  545:      }
        -:  546:#endif /* ENABLED (JERRY_ES2015) */
        -:  547:
    #####:  548:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  549:      return SCAN_NEXT_TOKEN;
        -:  550:    }
        -:  551:#if ENABLED (JERRY_ES2015)
    #####:  552:    case SCAN_STACK_BINDING_LIST_INIT:
        -:  553:    {
    #####:  554:      parser_stack_pop_uint8 (context_p);
        -:  555:
    #####:  556:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL
        -:  557:                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -:  558:                    || context_p->stack_top_uint8 == SCAN_STACK_LET
        -:  559:                    || context_p->stack_top_uint8 == SCAN_STACK_CONST
        -:  560:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START
        -:  561:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START
        -:  562:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS
        -:  563:                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  564:
    #####:  565:      scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;
        -:  566:
    #####:  567:      while (item_p != NULL)
        -:  568:      {
    #####:  569:        if (item_p->literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  570:        {
    #####:  571:          item_p->literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  572:        }
    #####:  573:        item_p = item_p->next_p;
        -:  574:      }
        -:  575:
    #####:  576:      scanner_pop_binding_list (scanner_context_p);
    #####:  577:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  578:      return SCAN_KEEP_TOKEN;
        -:  579:    }
    #####:  580:    case SCAN_STACK_BINDING_INIT:
        -:  581:    {
    #####:  582:      scanner_binding_literal_t binding_literal;
        -:  583:
    #####:  584:      parser_stack_pop_uint8 (context_p);
    #####:  585:      parser_stack_pop (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
        -:  586:
    #####:  587:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARRAY_LITERAL
        -:  588:                    || context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -:  589:                    || context_p->stack_top_uint8 == SCAN_STACK_LET
        -:  590:                    || context_p->stack_top_uint8 == SCAN_STACK_CONST
        -:  591:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_LET_START
        -:  592:                    || context_p->stack_top_uint8 == SCAN_STACK_FOR_CONST_START
        -:  593:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PARAMETERS
        -:  594:                    || context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  595:
    #####:  596:      JERRY_ASSERT ((stack_top != SCAN_STACK_ARRAY_LITERAL && stack_top != SCAN_STACK_OBJECT_LITERAL)
        -:  597:                    || SCANNER_NEEDS_BINDING_LIST (scanner_context_p->binding_type));
        -:  598:
    #####:  599:      if (binding_literal.literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  600:      {
    #####:  601:        binding_literal.literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  602:      }
        -:  603:
    #####:  604:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  605:      return SCAN_KEEP_TOKEN;
        -:  606:    }
        -:  607:#endif /* ENABLED (JERRY_ES2015) */
       12:  608:    case SCAN_STACK_VAR:
        -:  609:#if ENABLED (JERRY_ES2015)
        -:  610:    case SCAN_STACK_LET:
        -:  611:    case SCAN_STACK_CONST:
        -:  612:#endif /* ENABLED (JERRY_ES2015) */
        -:  613:    {
        -:  614:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
       12:  615:      scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -:  616:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  617:
       12:  618:      parser_stack_pop_uint8 (context_p);
       12:  619:      return SCAN_KEEP_TOKEN;
        -:  620:    }
    #####:  621:    case SCAN_STACK_FOR_VAR_START:
        -:  622:#if ENABLED (JERRY_ES2015)
        -:  623:    case SCAN_STACK_FOR_LET_START:
        -:  624:    case SCAN_STACK_FOR_CONST_START:
        -:  625:#endif /* ENABLED (JERRY_ES2015) */
        -:  626:    case SCAN_STACK_FOR_START:
        -:  627:    {
    #####:  628:      if (type == LEXER_KEYW_IN || SCANNER_IDENTIFIER_IS_OF ())
        -:  629:      {
    #####:  630:        scanner_for_statement_t for_statement;
        -:  631:
    #####:  632:        parser_stack_pop_uint8 (context_p);
    #####:  633:        parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  634:
        -:  635:        scanner_location_info_t *location_info;
    #####:  636:        location_info = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  637:                                                                         for_statement.u.source_p,
        -:  638:                                                                         sizeof (scanner_location_info_t));
        -:  639:#if ENABLED (JERRY_ES2015)
    #####:  640:        location_info->info.type = (type == LEXER_KEYW_IN) ? SCANNER_TYPE_FOR_IN : SCANNER_TYPE_FOR_OF;
        -:  641:
    #####:  642:        if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)
        -:  643:        {
    #####:  644:          parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK_EARLY);
        -:  645:        }
        -:  646:#else /* !ENABLED (JERRY_ES2015) */
    #####:  647:        location_info->info.type = SCANNER_TYPE_FOR_IN;
        -:  648:#endif /* ENABLED (JERRY_ES2015) */
        -:  649:
    #####:  650:        scanner_get_location (&location_info->location, context_p);
        -:  651:
    #####:  652:        parser_stack_push_uint8 (context_p, SCAN_STACK_STATEMENT_WITH_EXPR);
    #####:  653:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  654:        return SCAN_NEXT_TOKEN;
        -:  655:      }
        -:  656:
    #####:  657:      if (type != LEXER_SEMICOLON)
        -:  658:      {
    #####:  659:        break;
        -:  660:      }
        -:  661:
    #####:  662:      scanner_for_statement_t for_statement;
        -:  663:
    #####:  664:      parser_stack_pop_uint8 (context_p);
    #####:  665:      parser_stack_pop (context_p, NULL, sizeof (scanner_for_statement_t));
        -:  666:
        -:  667:#if ENABLED (JERRY_ES2015)
    #####:  668:      if (stack_top == SCAN_STACK_FOR_LET_START || stack_top == SCAN_STACK_FOR_CONST_START)
        -:  669:      {
    #####:  670:        parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);
        -:  671:      }
        -:  672:#endif /* ENABLED (JERRY_ES2015) */
        -:  673:
    #####:  674:      for_statement.u.source_p = context_p->source_p;
    #####:  675:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
    #####:  676:      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_CONDITION);
        -:  677:
    #####:  678:      lexer_next_token (context_p);
        -:  679:
    #####:  680:      if (context_p->token.type != LEXER_SEMICOLON)
        -:  681:      {
    #####:  682:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  683:        return SCAN_KEEP_TOKEN;
        -:  684:      }
        -:  685:
    #####:  686:      type = LEXER_SEMICOLON;
        -:  687:      /* FALLTHRU */
        -:  688:    }
        -:  689:    case SCAN_STACK_FOR_CONDITION:
        -:  690:    {
    #####:  691:      if (type != LEXER_SEMICOLON)
        -:  692:      {
    #####:  693:        break;
        -:  694:      }
        -:  695:
    #####:  696:      scanner_for_statement_t for_statement;
        -:  697:
    #####:  698:      parser_stack_pop_uint8 (context_p);
    #####:  699:      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  700:
        -:  701:      scanner_for_info_t *for_info_p;
    #####:  702:      for_info_p = (scanner_for_info_t *) scanner_insert_info (context_p,
        -:  703:                                                               for_statement.u.source_p,
        -:  704:                                                               sizeof (scanner_for_info_t));
    #####:  705:      for_info_p->info.type = SCANNER_TYPE_FOR;
        -:  706:
    #####:  707:      scanner_get_location (&for_info_p->expression_location, context_p);
    #####:  708:      for_info_p->end_location.source_p = NULL;
        -:  709:
    #####:  710:      for_statement.u.for_info_p = for_info_p;
        -:  711:
    #####:  712:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
    #####:  713:      parser_stack_push_uint8 (context_p, SCAN_STACK_FOR_EXPRESSION);
        -:  714:
    #####:  715:      lexer_next_token (context_p);
        -:  716:
    #####:  717:      if (context_p->token.type != LEXER_RIGHT_PAREN)
        -:  718:      {
    #####:  719:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  720:        return SCAN_KEEP_TOKEN;
        -:  721:      }
        -:  722:
    #####:  723:      type = LEXER_RIGHT_PAREN;
        -:  724:      /* FALLTHRU */
        -:  725:    }
        -:  726:    case SCAN_STACK_FOR_EXPRESSION:
        -:  727:    {
    #####:  728:      if (type != LEXER_RIGHT_PAREN)
        -:  729:      {
    #####:  730:        break;
        -:  731:      }
        -:  732:
    #####:  733:      scanner_for_statement_t for_statement;
        -:  734:
    #####:  735:      parser_stack_pop_uint8 (context_p);
    #####:  736:      parser_stack_pop (context_p, &for_statement, sizeof (scanner_for_statement_t));
        -:  737:
    #####:  738:      scanner_get_location (&for_statement.u.for_info_p->end_location, context_p);
        -:  739:
    #####:  740:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####:  741:      return SCAN_NEXT_TOKEN;
        -:  742:    }
    #####:  743:    case SCAN_STACK_SWITCH_EXPRESSION:
        -:  744:    {
    #####:  745:      if (type != LEXER_RIGHT_PAREN)
        -:  746:      {
    #####:  747:        break;
        -:  748:      }
        -:  749:
    #####:  750:      lexer_next_token (context_p);
        -:  751:
    #####:  752:      if (context_p->token.type != LEXER_LEFT_BRACE)
        -:  753:      {
    #####:  754:        break;
        -:  755:      }
        -:  756:
        -:  757:#if ENABLED (JERRY_ES2015)
        -:  758:      scanner_literal_pool_t *literal_pool_p;
    #####:  759:      literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);
    #####:  760:      literal_pool_p->source_p = context_p->source_p - 1;
        -:  761:#endif /* ENABLED (JERRY_ES2015) */
        -:  762:
    #####:  763:      parser_stack_pop_uint8 (context_p);
        -:  764:
    #####:  765:      scanner_switch_statement_t switch_statement = scanner_context_p->active_switch_statement;
    #####:  766:      parser_stack_push (context_p, &switch_statement, sizeof (scanner_switch_statement_t));
    #####:  767:      parser_stack_push_uint8 (context_p, SCAN_STACK_SWITCH_BLOCK);
        -:  768:
        -:  769:      scanner_switch_info_t *switch_info_p;
    #####:  770:      switch_info_p = (scanner_switch_info_t *) scanner_insert_info (context_p,
        -:  771:                                                                     context_p->source_p,
        -:  772:                                                                     sizeof (scanner_switch_info_t));
    #####:  773:      switch_info_p->info.type = SCANNER_TYPE_SWITCH;
    #####:  774:      switch_info_p->case_p = NULL;
    #####:  775:      scanner_context_p->active_switch_statement.last_case_p = &switch_info_p->case_p;
        -:  776:
    #####:  777:      lexer_next_token (context_p);
        -:  778:
    #####:  779:      if (context_p->token.type != LEXER_RIGHT_BRACE
    #####:  780:          && context_p->token.type != LEXER_KEYW_CASE
    #####:  781:          && context_p->token.type != LEXER_KEYW_DEFAULT)
        -:  782:      {
    #####:  783:        break;
        -:  784:      }
        -:  785:
    #####:  786:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  787:      return SCAN_KEEP_TOKEN;
        -:  788:    }
    #####:  789:    case SCAN_STACK_CASE_STATEMENT:
        -:  790:    {
    #####:  791:      if (type != LEXER_COLON)
        -:  792:      {
    #####:  793:        break;
        -:  794:      }
        -:  795:
    #####:  796:      scanner_source_start_t source_start;
        -:  797:
    #####:  798:      parser_stack_pop_uint8 (context_p);
    #####:  799:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  800:
        -:  801:      scanner_location_info_t *location_info_p;
    #####:  802:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  803:                                                                         source_start.source_p,
        -:  804:                                                                         sizeof (scanner_location_info_t));
    #####:  805:      location_info_p->info.type = SCANNER_TYPE_CASE;
        -:  806:
    #####:  807:      scanner_get_location (&location_info_p->location, context_p);
        -:  808:
    #####:  809:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  810:      return SCAN_NEXT_TOKEN;
        -:  811:    }
    #####:  812:    case SCAN_STACK_COLON_EXPRESSION:
        -:  813:    {
    #####:  814:      if (type != LEXER_COLON)
        -:  815:      {
    #####:  816:        break;
        -:  817:      }
        -:  818:
    #####:  819:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:  820:      parser_stack_pop_uint8 (context_p);
    #####:  821:      return SCAN_NEXT_TOKEN;
        -:  822:    }
        -:  823:#if ENABLED (JERRY_ES2015)
        3:  824:    case SCAN_STACK_ARRAY_LITERAL:
        -:  825:    case SCAN_STACK_OBJECT_LITERAL:
        -:  826:    {
        3:  827:      if (((stack_top == SCAN_STACK_ARRAY_LITERAL) && (type != LEXER_RIGHT_SQUARE))
        3:  828:          || ((stack_top == SCAN_STACK_OBJECT_LITERAL) && (type != LEXER_RIGHT_BRACE)))
        -:  829:      {
        -:  830:        break;
        -:  831:      }
        -:  832:
        3:  833:      scanner_source_start_t source_start;
        3:  834:      uint8_t binding_type = scanner_context_p->binding_type;
        -:  835:
        3:  836:      parser_stack_pop_uint8 (context_p);
        3:  837:      scanner_context_p->binding_type = context_p->stack_top_uint8;
        3:  838:      parser_stack_pop_uint8 (context_p);
        3:  839:      parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -:  840:
        3:  841:      lexer_next_token (context_p);
        -:  842:
        3:  843:      if (binding_type == SCANNER_BINDING_CATCH && context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT)
        -:  844:      {
    #####:  845:        scanner_pop_binding_list (scanner_context_p);
        -:  846:
    #####:  847:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -:  848:        {
    #####:  849:          scanner_raise_error (context_p);
        -:  850:        }
        -:  851:
    #####:  852:        lexer_next_token (context_p);
        -:  853:
    #####:  854:        if (context_p->token.type != LEXER_LEFT_BRACE)
        -:  855:        {
    #####:  856:          scanner_raise_error (context_p);
        -:  857:        }
        -:  858:
    #####:  859:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####:  860:        return SCAN_NEXT_TOKEN;
        -:  861:      }
        -:  862:
        3:  863:      if (context_p->token.type != LEXER_ASSIGN)
        -:  864:      {
        3:  865:        if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -:  866:        {
    #####:  867:          scanner_pop_binding_list (scanner_context_p);
        -:  868:        }
        -:  869:
        3:  870:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        3:  871:        return SCAN_KEEP_TOKEN;
        -:  872:      }
        -:  873:
        -:  874:      scanner_location_info_t *location_info_p;
    #####:  875:      location_info_p = (scanner_location_info_t *) scanner_insert_info (context_p,
        -:  876:                                                                         source_start.source_p,
        -:  877:                                                                         sizeof (scanner_location_info_t));
    #####:  878:      location_info_p->info.type = SCANNER_TYPE_INITIALIZER;
    #####:  879:      scanner_get_location (&location_info_p->location, context_p);
    #####:  880:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  881:
    #####:  882:      if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -:  883:      {
    #####:  884:        scanner_binding_item_t *item_p = scanner_context_p->active_binding_list_p->items_p;
        -:  885:
    #####:  886:        while (item_p != NULL)
        -:  887:        {
    #####:  888:          item_p->literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_USED;
    #####:  889:          item_p = item_p->next_p;
        -:  890:        }
        -:  891:
    #####:  892:        parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_LIST_INIT);
        -:  893:      }
    #####:  894:      return SCAN_NEXT_TOKEN;
        -:  895:    }
        -:  896:#else /* !ENABLED (JERRY_ES2015) */
    #####:  897:    case SCAN_STACK_ARRAY_LITERAL:
        -:  898:#endif /* ENABLED (JERRY_ES2015) */
        1:  899:    case SCAN_STACK_PROPERTY_ACCESSOR:
        -:  900:    {
        1:  901:      if (type != LEXER_RIGHT_SQUARE)
        -:  902:      {
    #####:  903:        break;
        -:  904:      }
        -:  905:
        1:  906:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        1:  907:      parser_stack_pop_uint8 (context_p);
        1:  908:      return SCAN_NEXT_TOKEN;
        -:  909:    }
        -:  910:#if !ENABLED (JERRY_ES2015)
    #####:  911:    case SCAN_STACK_OBJECT_LITERAL:
        -:  912:    {
    #####:  913:      if (type != LEXER_RIGHT_BRACE)
        -:  914:      {
    #####:  915:        break;
        -:  916:      }
        -:  917:
    #####:  918:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  919:      parser_stack_pop_uint8 (context_p);
    #####:  920:      return SCAN_NEXT_TOKEN;
        -:  921:    }
        -:  922:#endif /* !ENABLED (JERRY_ES2015) */
        -:  923:#if ENABLED (JERRY_ES2015)
    #####:  924:    case SCAN_STACK_COMPUTED_PROPERTY:
        -:  925:    {
    #####:  926:      if (type != LEXER_RIGHT_SQUARE)
        -:  927:      {
    #####:  928:        break;
        -:  929:      }
        -:  930:
    #####:  931:      lexer_next_token (context_p);
        -:  932:
    #####:  933:      parser_stack_pop_uint8 (context_p);
    #####:  934:      stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        -:  935:
    #####:  936:      if (stack_top == SCAN_STACK_FUNCTION_PROPERTY)
        -:  937:      {
    #####:  938:        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
        -:  939:
    #####:  940:        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####:  941:        return SCAN_KEEP_TOKEN;
        -:  942:      }
        -:  943:
    #####:  944:      JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);
        -:  945:
    #####:  946:      if (context_p->token.type == LEXER_LEFT_PAREN)
        -:  947:      {
    #####:  948:        scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
        -:  949:
    #####:  950:        parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####:  951:        scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####:  952:        return SCAN_KEEP_TOKEN;
        -:  953:      }
        -:  954:
    #####:  955:      if (context_p->token.type != LEXER_COLON)
        -:  956:      {
    #####:  957:        scanner_raise_error (context_p);
        -:  958:      }
        -:  959:
    #####:  960:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  961:
    #####:  962:      if (scanner_context_p->binding_type != SCANNER_BINDING_NONE)
        -:  963:      {
    #####:  964:        scanner_context_p->mode = SCAN_MODE_BINDING;
        -:  965:      }
    #####:  966:      return SCAN_NEXT_TOKEN;
        -:  967:    }
    #####:  968:    case SCAN_STACK_COMPUTED_GENERATOR:
        -:  969:    case SCAN_STACK_COMPUTED_ASYNC:
        -:  970:    case SCAN_STACK_COMPUTED_ASYNC_GENERATOR:
        -:  971:    {
    #####:  972:      if (type != LEXER_RIGHT_SQUARE)
        -:  973:      {
    #####:  974:        break;
        -:  975:      }
        -:  976:
    #####:  977:      lexer_next_token (context_p);
    #####:  978:      parser_stack_pop_uint8 (context_p);
        -:  979:
    #####:  980:      JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL
        -:  981:                    || context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_PROPERTY);
        -:  982:
    #####:  983:      uint16_t status_flags = (uint16_t) (SCANNER_LITERAL_POOL_FUNCTION
        -:  984:                                          | SCANNER_LITERAL_POOL_GENERATOR
    #####:  985:                                          | SCANNER_FROM_COMPUTED_TO_LITERAL_POOL (stack_top));
        -:  986:
    #####:  987:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -:  988:
    #####:  989:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####:  990:      return SCAN_KEEP_TOKEN;
        -:  991:    }
    #####:  992:    case SCAN_STACK_TEMPLATE_STRING:
        -:  993:    case SCAN_STACK_TAGGED_TEMPLATE_LITERAL:
        -:  994:    {
    #####:  995:      if (type != LEXER_RIGHT_BRACE)
        -:  996:      {
    #####:  997:        break;
        -:  998:      }
        -:  999:
    #####: 1000:      context_p->source_p--;
    #####: 1001:      context_p->column--;
    #####: 1002:      lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1003:
    #####: 1004:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1005:      {
    #####: 1006:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1007:      }
        -: 1008:      else
        -: 1009:      {
    #####: 1010:        parser_stack_pop_uint8 (context_p);
    #####: 1011:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 1012:      }
    #####: 1013:      return SCAN_NEXT_TOKEN;
        -: 1014:    }
    #####: 1015:    case SCAN_STACK_ARROW_ARGUMENTS:
        -: 1016:    {
    #####: 1017:      if (type != LEXER_RIGHT_PAREN)
        -: 1018:      {
    #####: 1019:        break;
        -: 1020:      }
        -: 1021:
    #####: 1022:      scanner_check_arrow (context_p, scanner_context_p);
    #####: 1023:      return SCAN_KEEP_TOKEN;
        -: 1024:    }
    #####: 1025:    case SCAN_STACK_ARROW_EXPRESSION:
        -: 1026:    {
    #####: 1027:      scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 1028:      parser_stack_pop_uint8 (context_p);
    #####: 1029:      lexer_update_await_yield (context_p, context_p->status_flags);
    #####: 1030:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 1031:      return SCAN_KEEP_TOKEN;
        -: 1032:    }
    #####: 1033:    case SCAN_STACK_CLASS_EXTENDS:
        -: 1034:    {
    #####: 1035:      if (type != LEXER_LEFT_BRACE)
        -: 1036:      {
    #####: 1037:        break;
        -: 1038:      }
        -: 1039:
    #####: 1040:      scanner_context_p->mode = SCAN_MODE_CLASS_METHOD;
    #####: 1041:      parser_stack_pop_uint8 (context_p);
        -: 1042:
    #####: 1043:      return SCAN_KEEP_TOKEN;
        -: 1044:    }
    #####: 1045:    case SCAN_STACK_FUNCTION_PARAMETERS:
        -: 1046:    {
    #####: 1047:      parser_stack_pop_uint8 (context_p);
        -: 1048:
    #####: 1049:      if (type != LEXER_RIGHT_PAREN
    #####: 1050:          && (type != LEXER_EOS || context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION))
        -: 1051:      {
        -: 1052:        break;
        -: 1053:      }
        -: 1054:
    #####: 1055:      scanner_context_p->mode = SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS;
    #####: 1056:      return SCAN_KEEP_TOKEN;
        -: 1057:    }
        -: 1058:#endif /* ENABLED (JERRY_ES2015) */
       16: 1059:    default:
        -: 1060:    {
       16: 1061:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
       16: 1062:      return SCAN_KEEP_TOKEN;
        -: 1063:    }
        -: 1064:  }
        -: 1065:
    #####: 1066:  scanner_raise_error (context_p);
    #####: 1067:  return SCAN_NEXT_TOKEN;
        -: 1068:} /* scanner_scan_primary_expression_end */
        -: 1069:
        -: 1070:/**
        -: 1071: * Scan statements.
        -: 1072: *
        -: 1073: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -: 1074: */
        -: 1075:static scan_return_types_t
     1317: 1076:scanner_scan_statement (parser_context_t *context_p, /**< context */
        -: 1077:                        scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1078:                        lexer_token_type_t type, /**< current token type */
        -: 1079:                        scan_stack_modes_t stack_top) /**< current stack top */
        -: 1080:{
     1317: 1081:  switch (type)
        -: 1082:  {
    #####: 1083:    case LEXER_SEMICOLON:
        -: 1084:    {
    #####: 1085:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1086:      return SCAN_KEEP_TOKEN;
        -: 1087:    }
        1: 1088:    case LEXER_LEFT_BRACE:
        -: 1089:    {
        -: 1090:#if ENABLED (JERRY_ES2015)
        -: 1091:      scanner_literal_pool_t *literal_pool_p;
        1: 1092:      literal_pool_p = scanner_push_literal_pool (context_p,
        -: 1093:                                                  scanner_context_p,
        -: 1094:                                                  SCANNER_LITERAL_POOL_BLOCK);
        1: 1095:      literal_pool_p->source_p = context_p->source_p;
        -: 1096:#endif /* ENABLED (JERRY_ES2015) */
        -: 1097:
        1: 1098:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        1: 1099:      parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);
        1: 1100:      return SCAN_NEXT_TOKEN;
        -: 1101:    }
        1: 1102:    case LEXER_KEYW_DO:
        -: 1103:    {
        1: 1104:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
        1: 1105:      parser_stack_push_uint8 (context_p, SCAN_STACK_DO_STATEMENT);
        1: 1106:      return SCAN_NEXT_TOKEN;
        -: 1107:    }
    #####: 1108:    case LEXER_KEYW_TRY:
        -: 1109:    {
    #####: 1110:      lexer_next_token (context_p);
        -: 1111:
    #####: 1112:      if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 1113:      {
    #####: 1114:        scanner_raise_error (context_p);
        -: 1115:      }
        -: 1116:
        -: 1117:#if ENABLED (JERRY_ES2015)
        -: 1118:      scanner_literal_pool_t *literal_pool_p;
    #####: 1119:      literal_pool_p = scanner_push_literal_pool (context_p,
        -: 1120:                                                  scanner_context_p,
        -: 1121:                                                  SCANNER_LITERAL_POOL_BLOCK);
    #####: 1122:      literal_pool_p->source_p = context_p->source_p;
        -: 1123:#endif /* ENABLED (JERRY_ES2015) */
        -: 1124:
    #####: 1125:      scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 1126:      parser_stack_push_uint8 (context_p, SCAN_STACK_TRY_STATEMENT);
    #####: 1127:      return SCAN_NEXT_TOKEN;
        -: 1128:    }
    #####: 1129:    case LEXER_KEYW_DEBUGGER:
        -: 1130:    {
    #####: 1131:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1132:      return SCAN_NEXT_TOKEN;
        -: 1133:    }
    #####: 1134:    case LEXER_KEYW_IF:
        -: 1135:    case LEXER_KEYW_WITH:
        -: 1136:    case LEXER_KEYW_SWITCH:
        -: 1137:    {
    #####: 1138:      lexer_next_token (context_p);
    #####: 1139:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1140:      {
    #####: 1141:        scanner_raise_error (context_p);
        -: 1142:      }
        -: 1143:
    #####: 1144:      uint8_t mode = SCAN_STACK_STATEMENT_WITH_EXPR;
        -: 1145:
    #####: 1146:      if (type == LEXER_KEYW_IF)
        -: 1147:      {
    #####: 1148:        parser_stack_push_uint8 (context_p, SCAN_STACK_IF_STATEMENT);
        -: 1149:      }
    #####: 1150:      else if (type == LEXER_KEYW_WITH)
        -: 1151:      {
    #####: 1152:        mode = SCAN_STACK_WITH_EXPRESSION;
        -: 1153:      }
    #####: 1154:      else if (type == LEXER_KEYW_SWITCH)
        -: 1155:      {
    #####: 1156:        mode = SCAN_STACK_SWITCH_EXPRESSION;
        -: 1157:      }
        -: 1158:
    #####: 1159:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1160:      parser_stack_push_uint8 (context_p, mode);
    #####: 1161:      return SCAN_NEXT_TOKEN;
        -: 1162:    }
    #####: 1163:    case LEXER_KEYW_WHILE:
        -: 1164:    {
    #####: 1165:      lexer_next_token (context_p);
        -: 1166:
    #####: 1167:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1168:      {
    #####: 1169:        scanner_raise_error (context_p);
        -: 1170:      }
        -: 1171:
    #####: 1172:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1173:
    #####: 1174:      scanner_source_start_t source_start;
    #####: 1175:      source_start.source_p = context_p->source_p;
        -: 1176:
    #####: 1177:      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1178:      parser_stack_push_uint8 (context_p, SCAN_STACK_WHILE_EXPRESSION);
    #####: 1179:      return SCAN_NEXT_TOKEN;
        -: 1180:    }
    #####: 1181:    case LEXER_KEYW_FOR:
        -: 1182:    {
    #####: 1183:      lexer_next_token (context_p);
    #####: 1184:      if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1185:      {
    #####: 1186:        scanner_raise_error (context_p);
        -: 1187:      }
        -: 1188:
    #####: 1189:      scanner_for_statement_t for_statement;
    #####: 1190:      for_statement.u.source_p = context_p->source_p;
    #####: 1191:      uint8_t stack_mode = SCAN_STACK_FOR_START;
    #####: 1192:      scan_return_types_t return_type = SCAN_KEEP_TOKEN;
        -: 1193:
    #####: 1194:      lexer_next_token (context_p);
    #####: 1195:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1196:
        -: 1197:#if ENABLED (JERRY_ES2015)
    #####: 1198:      const uint8_t *source_p = context_p->source_p;
        -: 1199:#endif /* ENABLED (JERRY_ES2015) */
        -: 1200:
    #####: 1201:      switch (context_p->token.type)
        -: 1202:      {
    #####: 1203:        case LEXER_SEMICOLON:
        -: 1204:        {
    #####: 1205:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 1206:          break;
        -: 1207:        }
    #####: 1208:        case LEXER_KEYW_VAR:
        -: 1209:        {
    #####: 1210:          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1211:          stack_mode = SCAN_STACK_FOR_VAR_START;
    #####: 1212:          return_type = SCAN_NEXT_TOKEN;
    #####: 1213:          break;
        -: 1214:        }
        -: 1215:#if ENABLED (JERRY_ES2015)
    #####: 1216:        case LEXER_LITERAL:
        -: 1217:        {
    #####: 1218:          if (!lexer_token_is_let (context_p))
        -: 1219:          {
    #####: 1220:            break;
        -: 1221:          }
        -: 1222:
    #####: 1223:          parser_line_counter_t line = context_p->line;
    #####: 1224:          parser_line_counter_t column = context_p->column;
        -: 1225:
    #####: 1226:          if (lexer_check_arrow (context_p))
        -: 1227:          {
    #####: 1228:            context_p->source_p = source_p;
    #####: 1229:            context_p->line = line;
    #####: 1230:            context_p->column = column;
    #####: 1231:            context_p->token.flags &= (uint8_t) ~LEXER_NO_SKIP_SPACES;
    #####: 1232:            break;
        -: 1233:          }
        -: 1234:
    #####: 1235:          lexer_next_token (context_p);
        -: 1236:
    #####: 1237:          type = (lexer_token_type_t) context_p->token.type;
        -: 1238:
    #####: 1239:          if (type != LEXER_LEFT_SQUARE
    #####: 1240:              && type != LEXER_LEFT_BRACE
    #####: 1241:              && (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL))
        -: 1242:          {
    #####: 1243:            scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));
    #####: 1244:            info_p->type = SCANNER_TYPE_LET_EXPRESSION;
        -: 1245:
    #####: 1246:            scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1247:            break;
        -: 1248:          }
        -: 1249:
    #####: 1250:          scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
        -: 1251:          /* FALLTHRU */
        -: 1252:        }
    #####: 1253:        case LEXER_KEYW_LET:
        -: 1254:        case LEXER_KEYW_CONST:
        -: 1255:        {
        -: 1256:          scanner_literal_pool_t *literal_pool_p;
    #####: 1257:          literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);
    #####: 1258:          literal_pool_p->source_p = source_p;
        -: 1259:
    #####: 1260:          if (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION)
        -: 1261:          {
    #####: 1262:            scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1263:            return_type = SCAN_NEXT_TOKEN;
        -: 1264:          }
        -: 1265:
    #####: 1266:          stack_mode = ((context_p->token.type == LEXER_KEYW_CONST) ? SCAN_STACK_FOR_CONST_START
        -: 1267:                                                                    : SCAN_STACK_FOR_LET_START);
    #####: 1268:          break;
        -: 1269:        }
        -: 1270:#endif /* ENABLED (JERRY_ES2015) */
        -: 1271:      }
        -: 1272:
    #####: 1273:      parser_stack_push (context_p, &for_statement, sizeof (scanner_for_statement_t));
    #####: 1274:      parser_stack_push_uint8 (context_p, stack_mode);
    #####: 1275:      return return_type;
        -: 1276:    }
       12: 1277:    case LEXER_KEYW_VAR:
        -: 1278:    {
       12: 1279:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
       12: 1280:      parser_stack_push_uint8 (context_p, SCAN_STACK_VAR);
       12: 1281:      return SCAN_NEXT_TOKEN;
        -: 1282:    }
        -: 1283:#if ENABLED (JERRY_ES2015)
    #####: 1284:    case LEXER_KEYW_LET:
        -: 1285:    {
    #####: 1286:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1287:      parser_stack_push_uint8 (context_p, SCAN_STACK_LET);
    #####: 1288:      return SCAN_NEXT_TOKEN;
        -: 1289:    }
    #####: 1290:    case LEXER_KEYW_CONST:
        -: 1291:    {
    #####: 1292:      scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1293:      parser_stack_push_uint8 (context_p, SCAN_STACK_CONST);
    #####: 1294:      return SCAN_NEXT_TOKEN;
        -: 1295:    }
        -: 1296:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1297:    case LEXER_KEYW_THROW:
        -: 1298:    {
    #####: 1299:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1300:      return SCAN_NEXT_TOKEN;
        -: 1301:    }
    #####: 1302:    case LEXER_KEYW_RETURN:
        -: 1303:    {
    #####: 1304:      lexer_next_token (context_p);
        -: 1305:
    #####: 1306:      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####: 1307:          && context_p->token.type != LEXER_SEMICOLON
    #####: 1308:          && context_p->token.type != LEXER_EOS
    #####: 1309:          && context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1310:      {
    #####: 1311:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1312:        return SCAN_KEEP_TOKEN;
        -: 1313:      }
        -: 1314:
    #####: 1315:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1316:      return SCAN_KEEP_TOKEN;
        -: 1317:    }
    #####: 1318:    case LEXER_KEYW_BREAK:
        -: 1319:    case LEXER_KEYW_CONTINUE:
        -: 1320:    {
    #####: 1321:      lexer_next_token (context_p);
    #####: 1322:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        -: 1323:
    #####: 1324:      if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####: 1325:          && context_p->token.type == LEXER_LITERAL
    #####: 1326:          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1327:      {
    #####: 1328:        return SCAN_NEXT_TOKEN;
        -: 1329:      }
    #####: 1330:      return SCAN_KEEP_TOKEN;
        -: 1331:    }
    #####: 1332:    case LEXER_KEYW_CASE:
        -: 1333:    case LEXER_KEYW_DEFAULT:
        -: 1334:    {
    #####: 1335:      if (stack_top != SCAN_STACK_SWITCH_BLOCK)
        -: 1336:      {
    #####: 1337:        scanner_raise_error (context_p);
        -: 1338:      }
        -: 1339:
        -: 1340:      scanner_case_info_t *case_info_p;
    #####: 1341:      case_info_p = (scanner_case_info_t *) scanner_malloc (context_p, sizeof (scanner_case_info_t));
        -: 1342:
    #####: 1343:      *(scanner_context_p->active_switch_statement.last_case_p) = case_info_p;
    #####: 1344:      scanner_context_p->active_switch_statement.last_case_p = &case_info_p->next_p;
        -: 1345:
    #####: 1346:      case_info_p->next_p = NULL;
    #####: 1347:      scanner_get_location (&case_info_p->location, context_p);
        -: 1348:
    #####: 1349:      if (type == LEXER_KEYW_DEFAULT)
        -: 1350:      {
    #####: 1351:        lexer_next_token (context_p);
        -: 1352:
    #####: 1353:        if (context_p->token.type != LEXER_COLON)
        -: 1354:        {
    #####: 1355:          scanner_raise_error (context_p);
        -: 1356:        }
        -: 1357:
    #####: 1358:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 1359:        return SCAN_NEXT_TOKEN;
        -: 1360:      }
        -: 1361:
    #####: 1362:      scanner_source_start_t source_start;
    #####: 1363:      source_start.source_p = context_p->source_p;
        -: 1364:
    #####: 1365:      parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1366:      parser_stack_push_uint8 (context_p, SCAN_STACK_CASE_STATEMENT);
        -: 1367:
    #####: 1368:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1369:      return SCAN_NEXT_TOKEN;
        -: 1370:    }
     1299: 1371:    case LEXER_KEYW_FUNCTION:
        -: 1372:    {
        -: 1373:#if ENABLED (JERRY_ES2015)
     1299: 1374:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_FUNCTION_STATEMENT;
        -: 1375:
     1299: 1376:      if (scanner_context_p->async_source_p != NULL)
        -: 1377:      {
    #####: 1378:        scanner_context_p->status_flags |= SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;
    #####: 1379:        status_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 1380:      }
        -: 1381:#endif /* ENABLED (JERRY_ES2015) */
        -: 1382:
     1299: 1383:      lexer_next_token (context_p);
        -: 1384:
        -: 1385:#if ENABLED (JERRY_ES2015)
     1299: 1386:      if (context_p->token.type == LEXER_MULTIPLY)
        -: 1387:      {
    #####: 1388:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
    #####: 1389:        lexer_next_token (context_p);
        -: 1390:      }
        -: 1391:#endif /* ENABLED (JERRY_ES2015) */
        -: 1392:
     1299: 1393:      if (context_p->token.type != LEXER_LITERAL
        2: 1394:          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1395:      {
     1297: 1396:        scanner_raise_error (context_p);
        -: 1397:      }
        -: 1398:
        2: 1399:      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1400:
        -: 1401:#if ENABLED (JERRY_ES2015)
        2: 1402:      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL);
        -: 1403:
        2: 1404:      if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)
    #####: 1405:          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
    #####: 1406:          && (literal_p->type & mask) != (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION))
        -: 1407:      {
    #####: 1408:        scanner_raise_redeclaration_error (context_p);
        -: 1409:      }
        -: 1410:
        2: 1411:      literal_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION;
        -: 1412:
        2: 1413:      scanner_context_p->status_flags &= (uint16_t) ~SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION;
        -: 1414:#else
    #####: 1415:      literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;
        -: 1416:
    #####: 1417:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 1418:#endif /* ENABLED (JERRY_ES2015) */
        -: 1419:
        2: 1420:      scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
        -: 1421:
        2: 1422:      scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
        2: 1423:      parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);
        2: 1424:      return SCAN_NEXT_TOKEN;
        -: 1425:    }
        -: 1426:#if ENABLED (JERRY_ES2015)
    #####: 1427:    case LEXER_KEYW_CLASS:
        -: 1428:    {
    #####: 1429:      scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);
        -: 1430:
    #####: 1431:      if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1432:      {
    #####: 1433:        scanner_raise_error (context_p);
        -: 1434:      }
        -: 1435:
    #####: 1436:      lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1437:
    #####: 1438:      scanner_detect_invalid_let (context_p, literal_p);
    #####: 1439:      literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 1440:
        -: 1441:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####: 1442:      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)
        -: 1443:      {
    #####: 1444:        literal_p->type |= SCANNER_LITERAL_NO_REG;
    #####: 1445:        scanner_context_p->active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -: 1446:      }
        -: 1447:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 1448:
    #####: 1449:      return SCAN_NEXT_TOKEN;
        -: 1450:    }
        -: 1451:#endif /* ENABLED (JERRY_ES2015) */
        -: 1452:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####: 1453:    case LEXER_KEYW_IMPORT:
        -: 1454:    {
    #####: 1455:      if (stack_top != SCAN_STACK_SCRIPT)
        -: 1456:      {
    #####: 1457:        scanner_raise_error (context_p);
        -: 1458:      }
        -: 1459:
    #####: 1460:      context_p->global_status_flags |= ECMA_PARSE_MODULE;
        -: 1461:
    #####: 1462:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
    #####: 1463:      lexer_next_token (context_p);
        -: 1464:
    #####: 1465:      if (context_p->token.type == LEXER_LITERAL
    #####: 1466:          && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1467:      {
    #####: 1468:        return SCAN_NEXT_TOKEN;
        -: 1469:      }
        -: 1470:
    #####: 1471:      bool parse_imports = true;
        -: 1472:
    #####: 1473:      if (context_p->token.type == LEXER_LITERAL
    #####: 1474:          && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1475:      {
    #####: 1476:        lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1477:
        -: 1478:#if ENABLED (JERRY_ES2015)
    #####: 1479:        scanner_detect_invalid_let (context_p, literal_p);
    #####: 1480:        literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1481:#else /* !ENABLED (JERRY_ES2015) */
        -: 1482:        literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;
        -: 1483:#endif /* ENABLED (JERRY_ES2015) */
        -: 1484:
    #####: 1485:        lexer_next_token (context_p);
        -: 1486:
    #####: 1487:        if (context_p->token.type == LEXER_COMMA)
        -: 1488:        {
    #####: 1489:          lexer_next_token (context_p);
        -: 1490:        }
        -: 1491:        else
        -: 1492:        {
    #####: 1493:          parse_imports = false;
        -: 1494:        }
        -: 1495:      }
        -: 1496:
    #####: 1497:      if (parse_imports)
        -: 1498:      {
    #####: 1499:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 1500:        {
    #####: 1501:          lexer_next_token (context_p);
    #####: 1502:          if (!lexer_token_is_identifier (context_p, "as", 2))
        -: 1503:          {
    #####: 1504:            scanner_raise_error (context_p);
        -: 1505:          }
        -: 1506:
    #####: 1507:          lexer_next_token (context_p);
        -: 1508:
    #####: 1509:          if (context_p->token.type != LEXER_LITERAL
    #####: 1510:              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1511:          {
    #####: 1512:            scanner_raise_error (context_p);
        -: 1513:          }
        -: 1514:
    #####: 1515:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1516:
        -: 1517:#if ENABLED (JERRY_ES2015)
    #####: 1518:          scanner_detect_invalid_let (context_p, literal_p);
    #####: 1519:          literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1520:#else /* !ENABLED (JERRY_ES2015) */
        -: 1521:          literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;
        -: 1522:#endif /* ENABLED (JERRY_ES2015) */
        -: 1523:
    #####: 1524:          lexer_next_token (context_p);
        -: 1525:        }
    #####: 1526:        else if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 1527:        {
    #####: 1528:          lexer_next_token (context_p);
        -: 1529:
    #####: 1530:          while (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1531:          {
    #####: 1532:            if (context_p->token.type != LEXER_LITERAL
    #####: 1533:                || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1534:            {
    #####: 1535:              scanner_raise_error (context_p);
        -: 1536:            }
        -: 1537:
        -: 1538:#if ENABLED (JERRY_ES2015)
    #####: 1539:            const uint8_t *source_p = context_p->source_p;
        -: 1540:#endif /* ENABLED (JERRY_ES2015) */
        -: 1541:
    #####: 1542:            if (lexer_check_next_character (context_p, LIT_CHAR_LOWERCASE_A))
        -: 1543:            {
    #####: 1544:              lexer_next_token (context_p);
        -: 1545:
    #####: 1546:              if (!lexer_token_is_identifier (context_p, "as", 2))
        -: 1547:              {
    #####: 1548:                scanner_raise_error (context_p);
        -: 1549:              }
        -: 1550:
    #####: 1551:              lexer_next_token (context_p);
        -: 1552:
    #####: 1553:              if (context_p->token.type != LEXER_LITERAL
    #####: 1554:                  && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1555:              {
    #####: 1556:                scanner_raise_error (context_p);
        -: 1557:              }
        -: 1558:
        -: 1559:#if ENABLED (JERRY_ES2015)
    #####: 1560:              source_p = context_p->source_p;
        -: 1561:#endif /* ENABLED (JERRY_ES2015) */
        -: 1562:            }
        -: 1563:
    #####: 1564:            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1565:
        -: 1566:#if ENABLED (JERRY_ES2015)
    #####: 1567:            if (literal_p->type & (SCANNER_LITERAL_IS_ARG
        -: 1568:                                   | SCANNER_LITERAL_IS_VAR
        -: 1569:                                   | SCANNER_LITERAL_IS_LOCAL))
        -: 1570:            {
    #####: 1571:              context_p->source_p = source_p;
    #####: 1572:              scanner_raise_redeclaration_error (context_p);
        -: 1573:            }
        -: 1574:
    #####: 1575:            if (literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1576:            {
    #####: 1577:              literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
        -: 1578:            }
        -: 1579:
    #####: 1580:            literal_p->type |= SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_NO_REG;
        -: 1581:#else /* !ENABLED (JERRY_ES2015) */
        -: 1582:            literal_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_NO_REG;
        -: 1583:#endif /* ENABLED (JERRY_ES2015) */
        -: 1584:
    #####: 1585:            lexer_next_token (context_p);
        -: 1586:
    #####: 1587:            if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1588:            {
    #####: 1589:              if (context_p->token.type != LEXER_COMMA)
        -: 1590:              {
    #####: 1591:                scanner_raise_error (context_p);
        -: 1592:              }
        -: 1593:
    #####: 1594:              lexer_next_token (context_p);
        -: 1595:            }
        -: 1596:          }
        -: 1597:
    #####: 1598:          lexer_next_token (context_p);
        -: 1599:        }
        -: 1600:        else
        -: 1601:        {
    #####: 1602:          scanner_raise_error (context_p);
        -: 1603:        }
        -: 1604:      }
        -: 1605:
    #####: 1606:      if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1607:      {
    #####: 1608:        scanner_raise_error (context_p);
        -: 1609:      }
        -: 1610:
    #####: 1611:      lexer_next_token (context_p);
        -: 1612:
    #####: 1613:      if (context_p->token.type != LEXER_LITERAL
    #####: 1614:          && context_p->token.lit_location.type != LEXER_STRING_LITERAL)
        -: 1615:      {
    #####: 1616:        scanner_raise_error (context_p);
        -: 1617:      }
        -: 1618:
    #####: 1619:      return SCAN_NEXT_TOKEN;
        -: 1620:    }
    #####: 1621:    case LEXER_KEYW_EXPORT:
        -: 1622:    {
    #####: 1623:      if (stack_top != SCAN_STACK_SCRIPT)
        -: 1624:      {
    #####: 1625:        scanner_raise_error (context_p);
        -: 1626:      }
        -: 1627:
    #####: 1628:      context_p->global_status_flags |= ECMA_PARSE_MODULE;
        -: 1629:
    #####: 1630:      lexer_next_token (context_p);
        -: 1631:
    #####: 1632:      if (context_p->token.type == LEXER_KEYW_DEFAULT)
        -: 1633:      {
    #####: 1634:        lexer_next_token (context_p);
        -: 1635:
    #####: 1636:        if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -: 1637:        {
    #####: 1638:          lexer_next_token (context_p);
    #####: 1639:          if (context_p->token.type == LEXER_LITERAL
    #####: 1640:              && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
    #####: 1641:          {
    #####: 1642:            lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1643:
        -: 1644:#if ENABLED (JERRY_ES2015)
    #####: 1645:            if (location_p->type & SCANNER_LITERAL_IS_LOCAL
    #####: 1646:                && !(location_p->type & SCANNER_LITERAL_IS_FUNC))
        -: 1647:            {
    #####: 1648:              scanner_raise_redeclaration_error (context_p);
        -: 1649:            }
    #####: 1650:            location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;
        -: 1651:#else /* !ENABLED (JERRY_ES2015) */
        -: 1652:            location_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;
        -: 1653:#endif /* ENABLED (JERRY_ES2015) */
        -: 1654:
    #####: 1655:            lexer_next_token (context_p);
        -: 1656:          }
        -: 1657:          else
        -: 1658:          {
        -: 1659:            lexer_lit_location_t *location_p;
    #####: 1660:            location_p = scanner_add_custom_literal (context_p,
        -: 1661:                                                     scanner_context_p->active_literal_pool_p,
        -: 1662:                                                     &lexer_default_literal);
        -: 1663:#if ENABLED (JERRY_ES2015)
    #####: 1664:            location_p->type |= SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LET;
        -: 1665:#else /* !ENABLED (JERRY_ES2015) */
        -: 1666:            location_p->type |= SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC;
        -: 1667:#endif /* ENABLED (JERRY_ES2015) */
        -: 1668:          }
        -: 1669:
    #####: 1670:          scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_FUNCTION);
        -: 1671:
    #####: 1672:          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_STATEMENT);
    #####: 1673:          scanner_context_p->mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 1674:          return SCAN_KEEP_TOKEN;
        -: 1675:        }
        -: 1676:#if ENABLED (JERRY_ES2015)
    #####: 1677:        if (context_p->token.type == LEXER_KEYW_CLASS)
        -: 1678:        {
    #####: 1679:          scanner_push_class_declaration (context_p, scanner_context_p, SCAN_STACK_CLASS_STATEMENT);
        -: 1680:
    #####: 1681:          if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1682:          {
    #####: 1683:            lexer_lit_location_t *literal_p = scanner_add_literal (context_p, scanner_context_p);
        -: 1684:
    #####: 1685:            scanner_detect_invalid_let (context_p, literal_p);
        -: 1686:
    #####: 1687:            literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;
    #####: 1688:            return SCAN_NEXT_TOKEN;
        -: 1689:          }
        -: 1690:
        -: 1691:          lexer_lit_location_t *literal_p;
    #####: 1692:          literal_p = scanner_add_custom_literal (context_p,
        -: 1693:                                                  scanner_context_p->active_literal_pool_p,
        -: 1694:                                                  &lexer_default_literal);
    #####: 1695:          literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;
    #####: 1696:          return SCAN_KEEP_TOKEN;
        -: 1697:        }
        -: 1698:#endif /* ENABLED (JERRY_ES2015) */
        -: 1699:
        -: 1700:        /* Assignment expression. */
        -: 1701:        lexer_lit_location_t *location_p;
    #####: 1702:        location_p = scanner_add_custom_literal (context_p,
        -: 1703:                                                 scanner_context_p->active_literal_pool_p,
        -: 1704:                                                 &lexer_default_literal);
    #####: 1705:        location_p->type |= SCANNER_LITERAL_IS_VAR;
    #####: 1706:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1707:
    #####: 1708:        if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1709:        {
    #####: 1710:          return SCAN_KEEP_TOKEN;
        -: 1711:        }
        -: 1712:
    #####: 1713:        location_p = scanner_add_literal (context_p, scanner_context_p);
    #####: 1714:        location_p->type |= SCANNER_LITERAL_IS_VAR;
    #####: 1715:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1716:        return SCAN_NEXT_TOKEN;
        -: 1717:      }
        -: 1718:
    #####: 1719:      scanner_context_p->mode = SCAN_MODE_STATEMENT_END;
        -: 1720:
    #####: 1721:      if (context_p->token.type == LEXER_MULTIPLY)
        -: 1722:      {
    #####: 1723:        lexer_next_token (context_p);
    #####: 1724:        if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1725:        {
    #####: 1726:          scanner_raise_error (context_p);
        -: 1727:        }
        -: 1728:
    #####: 1729:        lexer_next_token (context_p);
        -: 1730:
    #####: 1731:        if (context_p->token.type != LEXER_LITERAL
    #####: 1732:            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1733:        {
    #####: 1734:          scanner_raise_error (context_p);
        -: 1735:        }
        -: 1736:
    #####: 1737:        return SCAN_NEXT_TOKEN;
        -: 1738:      }
        -: 1739:
    #####: 1740:      if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 1741:      {
    #####: 1742:        lexer_next_token (context_p);
        -: 1743:
    #####: 1744:        while (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1745:        {
    #####: 1746:          if (context_p->token.type != LEXER_LITERAL
    #####: 1747:              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1748:          {
    #####: 1749:            scanner_raise_error (context_p);
        -: 1750:          }
        -: 1751:
    #####: 1752:          lexer_next_token (context_p);
        -: 1753:
    #####: 1754:          if (lexer_token_is_identifier (context_p, "as", 2))
        -: 1755:          {
    #####: 1756:            lexer_next_token (context_p);
        -: 1757:
    #####: 1758:            if (context_p->token.type != LEXER_LITERAL
    #####: 1759:                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1760:            {
    #####: 1761:              scanner_raise_error (context_p);
        -: 1762:            }
        -: 1763:
    #####: 1764:            lexer_next_token (context_p);
        -: 1765:          }
        -: 1766:
    #####: 1767:          if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1768:          {
    #####: 1769:            if (context_p->token.type != LEXER_COMMA)
        -: 1770:            {
    #####: 1771:              scanner_raise_error (context_p);
        -: 1772:            }
        -: 1773:
    #####: 1774:            lexer_next_token (context_p);
        -: 1775:          }
        -: 1776:        }
        -: 1777:
    #####: 1778:        lexer_next_token (context_p);
        -: 1779:
    #####: 1780:        if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 1781:        {
    #####: 1782:          return SCAN_KEEP_TOKEN;
        -: 1783:        }
        -: 1784:
    #####: 1785:        lexer_next_token (context_p);
        -: 1786:
    #####: 1787:        if (context_p->token.type != LEXER_LITERAL
    #####: 1788:            && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 1789:        {
    #####: 1790:          scanner_raise_error (context_p);
        -: 1791:        }
        -: 1792:
    #####: 1793:        return SCAN_NEXT_TOKEN;
        -: 1794:      }
        -: 1795:
    #####: 1796:      switch (context_p->token.type)
        -: 1797:      {
        -: 1798:#if ENABLED (JERRY_ES2015)
    #####: 1799:        case LEXER_KEYW_CLASS:
        -: 1800:        case LEXER_KEYW_LET:
        -: 1801:        case LEXER_KEYW_CONST:
        -: 1802:#endif /* ENABLED (JERRY_ES2015) */
        -: 1803:        case LEXER_KEYW_VAR:
        -: 1804:        {
    #####: 1805:          scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IN_EXPORT;
    #####: 1806:          break;
        -: 1807:        }
        -: 1808:      }
        -: 1809:
    #####: 1810:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 1811:      return SCAN_KEEP_TOKEN;
        -: 1812:    }
        -: 1813:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        4: 1814:    default:
        -: 1815:    {
        4: 1816:      break;
        -: 1817:    }
        -: 1818:  }
        -: 1819:
        4: 1820:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 1821:
        4: 1822:  if (type == LEXER_LITERAL
        4: 1823:      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 1824:  {
        4: 1825:    if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))
        -: 1826:    {
    #####: 1827:      lexer_consume_next_character (context_p);
    #####: 1828:      scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 1829:      return SCAN_NEXT_TOKEN;
        -: 1830:    }
        -: 1831:
        4: 1832:    JERRY_ASSERT (context_p->token.flags & LEXER_NO_SKIP_SPACES);
        -: 1833:
        -: 1834:#if ENABLED (JERRY_ES2015)
        -: 1835:    /* The colon needs to be checked first because the parser also checks
        -: 1836:     * it first, and this check skips the spaces which affects source_p. */
        4: 1837:    if (JERRY_UNLIKELY (lexer_check_arrow (context_p)))
        -: 1838:    {
    #####: 1839:      scanner_scan_simple_arrow (context_p, scanner_context_p, context_p->source_p);
    #####: 1840:      return SCAN_KEEP_TOKEN;
        -: 1841:    }
        -: 1842:
        4: 1843:    if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))
        -: 1844:    {
    #####: 1845:      lexer_lit_location_t let_literal = context_p->token.lit_location;
    #####: 1846:      const uint8_t *source_p = context_p->source_p;
        -: 1847:
    #####: 1848:      lexer_next_token (context_p);
        -: 1849:
    #####: 1850:      type = (lexer_token_type_t) context_p->token.type;
        -: 1851:
    #####: 1852:      if (type == LEXER_LEFT_SQUARE
    #####: 1853:          || type == LEXER_LEFT_BRACE
    #####: 1854:          || (type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL))
        -: 1855:      {
    #####: 1856:        scanner_context_p->mode = SCAN_MODE_VAR_STATEMENT;
    #####: 1857:        parser_stack_push_uint8 (context_p, SCAN_STACK_LET);
    #####: 1858:        return SCAN_KEEP_TOKEN;
        -: 1859:      }
        -: 1860:
    #####: 1861:      scanner_info_t *info_p = scanner_insert_info (context_p, source_p, sizeof (scanner_info_t));
    #####: 1862:      info_p->type = SCANNER_TYPE_LET_EXPRESSION;
        -: 1863:
    #####: 1864:      lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,
        -: 1865:                                                                         scanner_context_p->active_literal_pool_p,
        -: 1866:                                                                         &let_literal);
    #####: 1867:      lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -: 1868:
    #####: 1869:      if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 1870:      {
    #####: 1871:        lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -: 1872:      }
        -: 1873:
    #####: 1874:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 1875:      return SCAN_KEEP_TOKEN;
        -: 1876:    }
        -: 1877:
        4: 1878:    if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -: 1879:    {
    #####: 1880:      scanner_context_p->async_source_p = context_p->source_p;
        -: 1881:
    #####: 1882:      if (scanner_check_async_function (context_p, scanner_context_p))
        -: 1883:      {
    #####: 1884:        scanner_context_p->mode = SCAN_MODE_STATEMENT;
        -: 1885:      }
    #####: 1886:      return SCAN_KEEP_TOKEN;
        -: 1887:    }
        -: 1888:#endif /* ENABLED (JERRY_ES2015) */
        -: 1889:
        4: 1890:    scanner_add_reference (context_p, scanner_context_p);
        -: 1891:
        4: 1892:    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        4: 1893:    return SCAN_NEXT_TOKEN;
        -: 1894:  }
        -: 1895:
    #####: 1896:  return SCAN_KEEP_TOKEN;
        -: 1897:} /* scanner_scan_statement */
        -: 1898:
        -: 1899:/**
        -: 1900: * Scan statement terminator.
        -: 1901: *
        -: 1902: * @return SCAN_NEXT_TOKEN to read the next token, or SCAN_KEEP_TOKEN to do nothing
        -: 1903: */
        -: 1904:static scan_return_types_t
       17: 1905:scanner_scan_statement_end (parser_context_t *context_p, /**< context */
        -: 1906:                            scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1907:                            lexer_token_type_t type) /**< current token type */
        -: 1908:{
       17: 1909:  bool terminator_found = false;
        -: 1910:
       17: 1911:  if (type == LEXER_SEMICOLON)
        -: 1912:  {
       17: 1913:    lexer_next_token (context_p);
       17: 1914:    terminator_found = true;
        -: 1915:  }
        -: 1916:
        -: 1917:  while (true)
        -: 1918:  {
       25: 1919:    type = (lexer_token_type_t) context_p->token.type;
        -: 1920:
       21: 1921:    switch (context_p->stack_top_uint8)
        -: 1922:    {
        2: 1923:      case SCAN_STACK_SCRIPT:
        -: 1924:      case SCAN_STACK_SCRIPT_FUNCTION:
        -: 1925:      {
        2: 1926:        if (type == LEXER_EOS)
        -: 1927:        {
        1: 1928:          return SCAN_NEXT_TOKEN;
        -: 1929:        }
        1: 1930:        break;
        -: 1931:      }
       17: 1932:      case SCAN_STACK_BLOCK_STATEMENT:
        -: 1933:#if ENABLED (JERRY_ES2015)
        -: 1934:      case SCAN_STACK_CLASS_STATEMENT:
        -: 1935:#endif /* ENABLED (JERRY_ES2015) */
        -: 1936:      case SCAN_STACK_FUNCTION_STATEMENT:
        -: 1937:      {
       17: 1938:        if (type != LEXER_RIGHT_BRACE)
        -: 1939:        {
       14: 1940:          break;
        -: 1941:        }
        -: 1942:
        -: 1943:#if ENABLED (JERRY_ES2015)
        3: 1944:        if (context_p->stack_top_uint8 != SCAN_STACK_CLASS_STATEMENT)
        -: 1945:        {
        3: 1946:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 1947:        }
        -: 1948:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1949:        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_STATEMENT)
        -: 1950:        {
    #####: 1951:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 1952:        }
        -: 1953:#endif /* ENABLED (JERRY_ES2015) */
        -: 1954:
        3: 1955:        terminator_found = true;
        3: 1956:        parser_stack_pop_uint8 (context_p);
        3: 1957:        lexer_next_token (context_p);
        3: 1958:        continue;
        -: 1959:      }
    #####: 1960:      case SCAN_STACK_FUNCTION_EXPRESSION:
        -: 1961:#if ENABLED (JERRY_ES2015)
        -: 1962:      case SCAN_STACK_FUNCTION_ARROW:
        -: 1963:#endif /* ENABLED (JERRY_ES2015) */
        -: 1964:      {
    #####: 1965:        if (type != LEXER_RIGHT_BRACE)
        -: 1966:        {
    #####: 1967:          break;
        -: 1968:        }
        -: 1969:
    #####: 1970:        scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 1971:#if ENABLED (JERRY_ES2015)
    #####: 1972:        if (context_p->stack_top_uint8 == SCAN_STACK_FUNCTION_ARROW)
        -: 1973:        {
    #####: 1974:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -: 1975:        }
        -: 1976:#endif /* ENABLED (JERRY_ES2015) */
        -: 1977:
    #####: 1978:        scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 1979:        parser_stack_pop_uint8 (context_p);
    #####: 1980:        return SCAN_NEXT_TOKEN;
        -: 1981:      }
    #####: 1982:      case SCAN_STACK_FUNCTION_PROPERTY:
        -: 1983:      {
    #####: 1984:        if (type != LEXER_RIGHT_BRACE)
        -: 1985:        {
    #####: 1986:          break;
        -: 1987:        }
        -: 1988:
    #####: 1989:        scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 1990:        parser_stack_pop_uint8 (context_p);
        -: 1991:
        -: 1992:#if ENABLED (JERRY_ES2015)
    #####: 1993:        if (context_p->stack_top_uint8 == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR
    #####: 1994:            || context_p->stack_top_uint8 == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
        -: 1995:        {
    #####: 1996:          scanner_context_p->mode = SCAN_MODE_CLASS_METHOD;
    #####: 1997:          return SCAN_KEEP_TOKEN;
        -: 1998:        }
        -: 1999:#endif /* ENABLED (JERRY_ES2015) */
        -: 2000:
    #####: 2001:        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_OBJECT_LITERAL);
        -: 2002:
    #####: 2003:        lexer_next_token (context_p);
        -: 2004:
    #####: 2005:        if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 2006:        {
    #####: 2007:          scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 2008:          return SCAN_KEEP_TOKEN;
        -: 2009:        }
        -: 2010:
    #####: 2011:        if (context_p->token.type != LEXER_COMMA)
        -: 2012:        {
    #####: 2013:          scanner_raise_error (context_p);
        -: 2014:        }
        -: 2015:
    #####: 2016:        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2017:        return SCAN_KEEP_TOKEN;
        -: 2018:      }
    #####: 2019:      case SCAN_STACK_SWITCH_BLOCK:
        -: 2020:      {
    #####: 2021:        if (type != LEXER_RIGHT_BRACE)
        -: 2022:        {
    #####: 2023:          break;
        -: 2024:        }
        -: 2025:
    #####: 2026:        scanner_switch_statement_t switch_statement;
        -: 2027:
    #####: 2028:        parser_stack_pop_uint8 (context_p);
    #####: 2029:        parser_stack_pop (context_p, &switch_statement, sizeof (scanner_switch_statement_t));
        -: 2030:
    #####: 2031:        scanner_context_p->active_switch_statement = switch_statement;
        -: 2032:
        -: 2033:#if ENABLED (JERRY_ES2015)
    #####: 2034:        scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2035:#endif /* ENABLED (JERRY_ES2015) */
        -: 2036:
    #####: 2037:        terminator_found = true;
    #####: 2038:        lexer_next_token (context_p);
    #####: 2039:        continue;
        -: 2040:      }
    #####: 2041:      case SCAN_STACK_IF_STATEMENT:
        -: 2042:      {
    #####: 2043:        parser_stack_pop_uint8 (context_p);
        -: 2044:
    #####: 2045:        if (type == LEXER_KEYW_ELSE
    #####: 2046:            && (terminator_found || (context_p->token.flags & LEXER_WAS_NEWLINE)))
        -: 2047:        {
        -: 2048:#if ENABLED (JERRY_ES2015)
    #####: 2049:          scanner_check_function_after_if (context_p, scanner_context_p);
    #####: 2050:          return SCAN_KEEP_TOKEN;
        -: 2051:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2052:          scanner_context_p->mode = SCAN_MODE_STATEMENT;
    #####: 2053:          return SCAN_NEXT_TOKEN;
        -: 2054:#endif /* ENABLED (JERRY_ES2015) */
        -: 2055:        }
    #####: 2056:        continue;
        -: 2057:      }
    #####: 2058:      case SCAN_STACK_WITH_STATEMENT:
        -: 2059:      {
    #####: 2060:        scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 2061:
    #####: 2062:        JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH);
        -: 2063:
    #####: 2064:        parser_stack_pop_uint8 (context_p);
        -: 2065:
    #####: 2066:        if (context_p->stack_top_uint8 == 0)
        -: 2067:        {
    #####: 2068:          literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_WITH;
        -: 2069:        }
        -: 2070:
    #####: 2071:        parser_stack_pop_uint8 (context_p);
    #####: 2072:        continue;
        -: 2073:      }
        1: 2074:      case SCAN_STACK_DO_STATEMENT:
        -: 2075:      {
        1: 2076:        parser_stack_pop_uint8 (context_p);
        -: 2077:
        1: 2078:        if (type != LEXER_KEYW_WHILE
        1: 2079:            || (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE)))
        -: 2080:        {
    #####: 2081:          scanner_raise_error (context_p);
        -: 2082:        }
        -: 2083:
        1: 2084:        lexer_next_token (context_p);
        1: 2085:        if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2086:        {
    #####: 2087:          scanner_raise_error (context_p);
        -: 2088:        }
        -: 2089:
        1: 2090:        parser_stack_push_uint8 (context_p, SCAN_STACK_DO_EXPRESSION);
        1: 2091:        scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        1: 2092:        return SCAN_NEXT_TOKEN;
        -: 2093:      }
        1: 2094:      case SCAN_STACK_DO_EXPRESSION:
        -: 2095:      {
        1: 2096:        parser_stack_pop_uint8 (context_p);
        1: 2097:        terminator_found = true;
        1: 2098:        continue;
        -: 2099:      }
        -: 2100:#if ENABLED (JERRY_ES2015)
    #####: 2101:      case SCAN_STACK_PRIVATE_BLOCK_EARLY:
        -: 2102:      {
    #####: 2103:        parser_list_iterator_t literal_iterator;
        -: 2104:        lexer_lit_location_t *literal_p;
        -: 2105:
    #####: 2106:        parser_list_iterator_init (&scanner_context_p->active_literal_pool_p->literal_pool, &literal_iterator);
        -: 2107:
    #####: 2108:        while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 2109:        {
    #####: 2110:          if ((literal_p->type & (SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_IS_CONST))
    #####: 2111:              && literal_p->type & SCANNER_LITERAL_NO_REG)
        -: 2112:          {
    #####: 2113:            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 2114:          }
        -: 2115:        }
        -: 2116:        /* FALLTHRU */
        -: 2117:      }
    #####: 2118:      case SCAN_STACK_PRIVATE_BLOCK:
        -: 2119:      {
    #####: 2120:        parser_stack_pop_uint8 (context_p);
    #####: 2121:        scanner_pop_literal_pool (context_p, scanner_context_p);
    #####: 2122:        continue;
        -: 2123:      }
        -: 2124:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2125:      default:
        -: 2126:      {
    #####: 2127:        JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_TRY_STATEMENT
        -: 2128:                      || context_p->stack_top_uint8 == SCAN_STACK_CATCH_STATEMENT);
        -: 2129:
    #####: 2130:        if (type != LEXER_RIGHT_BRACE)
        -: 2131:        {
    #####: 2132:          break;
        -: 2133:        }
        -: 2134:
    #####: 2135:        uint8_t stack_top = context_p->stack_top_uint8;
    #####: 2136:        parser_stack_pop_uint8 (context_p);
    #####: 2137:        lexer_next_token (context_p);
        -: 2138:
        -: 2139:#if ENABLED (JERRY_ES2015)
    #####: 2140:        scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2141:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2142:        if (stack_top == SCAN_STACK_CATCH_STATEMENT)
        -: 2143:        {
    #####: 2144:          scanner_pop_literal_pool (context_p, scanner_context_p);
        -: 2145:        }
        -: 2146:#endif /* ENABLED (JERRY_ES2015) */
        -: 2147:
        -: 2148:        /* A finally statement is optional after a try or catch statement. */
    #####: 2149:        if (context_p->token.type == LEXER_KEYW_FINALLY)
        -: 2150:        {
    #####: 2151:          lexer_next_token (context_p);
        -: 2152:
    #####: 2153:          if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2154:          {
    #####: 2155:            scanner_raise_error (context_p);
        -: 2156:          }
        -: 2157:
        -: 2158:#if ENABLED (JERRY_ES2015)
        -: 2159:          scanner_literal_pool_t *literal_pool_p;
    #####: 2160:          literal_pool_p = scanner_push_literal_pool (context_p,
        -: 2161:                                                      scanner_context_p,
        -: 2162:                                                      SCANNER_LITERAL_POOL_BLOCK);
    #####: 2163:          literal_pool_p->source_p = context_p->source_p;
        -: 2164:#endif /* ENABLED (JERRY_ES2015) */
        -: 2165:
    #####: 2166:          parser_stack_push_uint8 (context_p, SCAN_STACK_BLOCK_STATEMENT);
    #####: 2167:          scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 2168:          return SCAN_NEXT_TOKEN;
        -: 2169:        }
        -: 2170:
    #####: 2171:        if (stack_top == SCAN_STACK_CATCH_STATEMENT)
        -: 2172:        {
    #####: 2173:          terminator_found = true;
    #####: 2174:          continue;
        -: 2175:        }
        -: 2176:
        -: 2177:        /* A catch statement must be present after a try statement unless a finally is provided. */
    #####: 2178:        if (context_p->token.type != LEXER_KEYW_CATCH)
        -: 2179:        {
    #####: 2180:          scanner_raise_error (context_p);
        -: 2181:        }
        -: 2182:
    #####: 2183:        lexer_next_token (context_p);
        -: 2184:
    #####: 2185:        if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2186:        {
    #####: 2187:          scanner_raise_error (context_p);
        -: 2188:        }
        -: 2189:
        -: 2190:        scanner_literal_pool_t *literal_pool_p;
    #####: 2191:        literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_BLOCK);
    #####: 2192:        literal_pool_p->source_p = context_p->source_p;
        -: 2193:
    #####: 2194:        lexer_next_token (context_p);
    #####: 2195:        parser_stack_push_uint8 (context_p, SCAN_STACK_CATCH_STATEMENT);
        -: 2196:
        -: 2197:#if ENABLED (JERRY_ES2015)
    #####: 2198:        if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 2199:        {
    #####: 2200:          scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_CATCH, false);
        -: 2201:
    #####: 2202:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2203:          {
    #####: 2204:            parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 2205:            scanner_context_p->mode = SCAN_MODE_BINDING;
    #####: 2206:            return SCAN_NEXT_TOKEN;
        -: 2207:          }
        -: 2208:
    #####: 2209:          parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 2210:          scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2211:          return SCAN_KEEP_TOKEN;
        -: 2212:        }
        -: 2213:#endif /* ENABLED (JERRY_ES2015) */
        -: 2214:
    #####: 2215:        if (context_p->token.type != LEXER_LITERAL
    #####: 2216:            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2217:        {
    #####: 2218:          scanner_raise_error (context_p);
        -: 2219:        }
        -: 2220:
    #####: 2221:        lexer_lit_location_t *lit_location_p = scanner_add_literal (context_p, scanner_context_p);
    #####: 2222:        lit_location_p->type |= SCANNER_LITERAL_IS_LOCAL;
        -: 2223:
    #####: 2224:        lexer_next_token (context_p);
        -: 2225:
    #####: 2226:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2227:        {
    #####: 2228:          scanner_raise_error (context_p);
        -: 2229:        }
        -: 2230:
    #####: 2231:        lexer_next_token (context_p);
        -: 2232:
    #####: 2233:        if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2234:        {
    #####: 2235:          scanner_raise_error (context_p);
        -: 2236:        }
        -: 2237:
    #####: 2238:        scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
    #####: 2239:        return SCAN_NEXT_TOKEN;
        -: 2240:      }
        -: 2241:    }
        -: 2242:
       15: 2243:    if (!terminator_found && !(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 2244:    {
    #####: 2245:      scanner_raise_error (context_p);
        -: 2246:    }
        -: 2247:
       15: 2248:    scanner_context_p->mode = SCAN_MODE_STATEMENT;
       15: 2249:    return SCAN_KEEP_TOKEN;
        -: 2250:  }
        -: 2251:} /* scanner_scan_statement_end */
        -: 2252:
        -: 2253:/**
        -: 2254: * Scan the whole source code.
        -: 2255: */
        -: 2256:void JERRY_ATTR_NOINLINE
     1310: 2257:scanner_scan_all (parser_context_t *context_p, /**< context */
        -: 2258:                  const uint8_t *arg_list_p, /**< function argument list */
        -: 2259:                  const uint8_t *arg_list_end_p, /**< end of argument list */
        -: 2260:                  const uint8_t *source_p, /**< valid UTF-8 source code */
        -: 2261:                  const uint8_t *source_end_p) /**< end of source code */
        -: 2262:{
     1310: 2263:  scanner_context_t scanner_context;
        -: 2264:
        -: 2265:#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)
        -: 2266:  if (context_p->is_show_opcodes)
        -: 2267:  {
        -: 2268:    JERRY_DEBUG_MSG ("\n--- Scanning start ---\n\n");
        -: 2269:  }
        -: 2270:#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */
        -: 2271:
     1310: 2272:  scanner_context.context_status_flags = context_p->status_flags;
     1310: 2273:  scanner_context.status_flags = SCANNER_CONTEXT_NO_FLAGS;
        -: 2274:#if ENABLED (JERRY_DEBUGGER)
        -: 2275:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2276:  {
        -: 2277:    scanner_context.status_flags |= SCANNER_CONTEXT_DEBUGGER_ENABLED;
        -: 2278:  }
        -: 2279:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 2280:#if ENABLED (JERRY_ES2015)
     1310: 2281:  scanner_context.binding_type = SCANNER_BINDING_NONE;
     1310: 2282:  scanner_context.active_binding_list_p = NULL;
        -: 2283:#endif /* ENABLED (JERRY_ES2015) */
     1310: 2284:  scanner_context.active_literal_pool_p = NULL;
     1310: 2285:  scanner_context.active_switch_statement.last_case_p = NULL;
     1310: 2286:  scanner_context.end_arguments_p = NULL;
        -: 2287:#if ENABLED (JERRY_ES2015)
     1310: 2288:  scanner_context.async_source_p = NULL;
        -: 2289:#endif /* ENABLED (JERRY_ES2015) */
        -: 2290:
        -: 2291:  /* This assignment must be here because of Apple compilers. */
     1310: 2292:  context_p->u.scanner_context_p = &scanner_context;
        -: 2293:
     1310: 2294:  parser_stack_init (context_p);
        -: 2295:
     1310: 2296:  PARSER_TRY (context_p->try_buffer)
        -: 2297:  {
     1310: 2298:    context_p->line = 1;
     1310: 2299:    context_p->column = 1;
        -: 2300:
     1310: 2301:    if (arg_list_p == NULL)
        -: 2302:    {
     1310: 2303:      context_p->source_p = source_p;
     1310: 2304:      context_p->source_end_p = source_end_p;
        -: 2305:
     1310: 2306:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION_WITHOUT_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 2307:
     1310: 2308:      if (context_p->status_flags & PARSER_IS_STRICT)
        -: 2309:      {
     1309: 2310:        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -: 2311:      }
        -: 2312:
     1310: 2313:      scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, &scanner_context, status_flags);
     1309: 2314:      literal_pool_p->source_p = source_p;
        -: 2315:
     1309: 2316:      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT);
        -: 2317:
     1298: 2318:      lexer_next_token (context_p);
     1298: 2319:      scanner_check_directives (context_p, &scanner_context);
        -: 2320:    }
        -: 2321:    else
        -: 2322:    {
    #####: 2323:      context_p->source_p = arg_list_p;
    #####: 2324:      context_p->source_end_p = arg_list_end_p;
        -: 2325:
    #####: 2326:      uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 2327:
    #####: 2328:      if (context_p->status_flags & PARSER_IS_STRICT)
        -: 2329:      {
    #####: 2330:        status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -: 2331:      }
        -: 2332:
        -: 2333:#if ENABLED (JERRY_ES2015)
    #####: 2334:      if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 2335:      {
    #####: 2336:        status_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2337:      }
        -: 2338:#endif /* ENABLED (JERRY_ES2015) */
        -: 2339:
    #####: 2340:      scanner_push_literal_pool (context_p, &scanner_context, status_flags);
    #####: 2341:      scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 2342:      parser_stack_push_uint8 (context_p, SCAN_STACK_SCRIPT_FUNCTION);
        -: 2343:
        -: 2344:      /* Faking the first token. */
    #####: 2345:      context_p->token.type = LEXER_LEFT_PAREN;
        -: 2346:    }
        -: 2347:
        -: 2348:    while (true)
      143: 2349:    {
     1441: 2350:      lexer_token_type_t type = (lexer_token_type_t) context_p->token.type;
     1441: 2351:      scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        -: 2352:
     1441: 2353:      switch (scanner_context.mode)
        -: 2354:      {
       32: 2355:        case SCAN_MODE_PRIMARY_EXPRESSION:
        -: 2356:        {
       32: 2357:          if (type == LEXER_ADD
       32: 2358:              || type == LEXER_SUBTRACT
       32: 2359:              || LEXER_IS_UNARY_OP_TOKEN (type))
        -: 2360:          {
        -: 2361:            break;
        -: 2362:          }
        -: 2363:          /* FALLTHRU */
        -: 2364:        }
        -: 2365:        case SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW:
        -: 2366:        {
       35: 2367:          if (scanner_scan_primary_expression (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2368:          {
        2: 2369:            continue;
        -: 2370:          }
       33: 2371:          break;
        -: 2372:        }
        -: 2373:#if ENABLED (JERRY_ES2015)
    #####: 2374:        case SCAN_MODE_CLASS_DECLARATION:
        -: 2375:        {
    #####: 2376:          if (context_p->token.type == LEXER_KEYW_EXTENDS)
        -: 2377:          {
    #####: 2378:            parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_EXTENDS);
    #####: 2379:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2380:            break;
        -: 2381:          }
    #####: 2382:          else if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2383:          {
    #####: 2384:            scanner_raise_error (context_p);
        -: 2385:          }
        -: 2386:
    #####: 2387:          scanner_context.mode = SCAN_MODE_CLASS_METHOD;
        -: 2388:          /* FALLTHRU */
        -: 2389:        }
    #####: 2390:        case SCAN_MODE_CLASS_METHOD:
        -: 2391:        {
    #####: 2392:          JERRY_ASSERT (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR
        -: 2393:                        || stack_top == SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);
        -: 2394:
    #####: 2395:          lexer_skip_empty_statements (context_p);
        -: 2396:
    #####: 2397:          lexer_scan_identifier (context_p);
        -: 2398:
    #####: 2399:          if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 2400:          {
    #####: 2401:            scanner_source_start_t source_start;
        -: 2402:
    #####: 2403:            parser_stack_pop_uint8 (context_p);
        -: 2404:
    #####: 2405:            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
        -: 2406:            {
    #####: 2407:              parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -: 2408:            }
        -: 2409:
    #####: 2410:            stack_top = context_p->stack_top_uint8;
        -: 2411:
    #####: 2412:            JERRY_ASSERT (stack_top == SCAN_STACK_CLASS_STATEMENT || stack_top == SCAN_STACK_CLASS_EXPRESSION);
        -: 2413:
    #####: 2414:            if (stack_top == SCAN_STACK_CLASS_STATEMENT)
        -: 2415:            {
        -: 2416:              /* The token is kept to disallow consuming a semicolon after it. */
    #####: 2417:              scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2418:              continue;
        -: 2419:            }
        -: 2420:
    #####: 2421:            scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####: 2422:            parser_stack_pop_uint8 (context_p);
    #####: 2423:            break;
        -: 2424:          }
        -: 2425:
    #####: 2426:          if (context_p->token.type == LEXER_LITERAL
    #####: 2427:              && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
    #####: 2428:              && lexer_compare_literal_to_string (context_p, "constructor", 11))
        -: 2429:          {
    #####: 2430:            if (stack_top == SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR)
        -: 2431:            {
    #####: 2432:              scanner_source_start_t source_start;
    #####: 2433:              parser_stack_pop_uint8 (context_p);
    #####: 2434:              parser_stack_pop (context_p, &source_start, sizeof (scanner_source_start_t));
        -: 2435:
    #####: 2436:              scanner_info_t *info_p = scanner_insert_info (context_p, source_start.source_p, sizeof (scanner_info_t));
    #####: 2437:              info_p->type = SCANNER_TYPE_CLASS_CONSTRUCTOR;
    #####: 2438:              parser_stack_push_uint8 (context_p, SCAN_STACK_EXPLICIT_CLASS_CONSTRUCTOR);
        -: 2439:            }
        -: 2440:          }
        -: 2441:
    #####: 2442:          if (lexer_token_is_identifier (context_p, "static", 6))
        -: 2443:          {
    #####: 2444:            lexer_scan_identifier (context_p);
        -: 2445:          }
        -: 2446:
    #####: 2447:          parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 2448:          scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
        -: 2449:
    #####: 2450:          uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 2451:
    #####: 2452:          if (lexer_token_is_identifier (context_p, "get", 3)
    #####: 2453:              || lexer_token_is_identifier (context_p, "set", 3))
        -: 2454:          {
    #####: 2455:            lexer_scan_identifier (context_p);
        -: 2456:
    #####: 2457:            if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2458:            {
    #####: 2459:              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
    #####: 2460:              continue;
        -: 2461:            }
        -: 2462:          }
    #####: 2463:          else if (lexer_token_is_identifier (context_p, "async", 5))
        -: 2464:          {
    #####: 2465:            lexer_scan_identifier (context_p);
        -: 2466:
    #####: 2467:            if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2468:            {
    #####: 2469:              scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
    #####: 2470:              continue;
        -: 2471:            }
        -: 2472:
    #####: 2473:            literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 2474:
    #####: 2475:            if (context_p->token.type == LEXER_MULTIPLY)
        -: 2476:            {
    #####: 2477:              lexer_scan_identifier (context_p);
    #####: 2478:              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2479:            }
        -: 2480:          }
    #####: 2481:          else if (context_p->token.type == LEXER_MULTIPLY)
        -: 2482:          {
    #####: 2483:            lexer_scan_identifier (context_p);
    #####: 2484:            literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2485:          }
        -: 2486:
    #####: 2487:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2488:          {
    #####: 2489:            parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));
    #####: 2490:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2491:            break;
        -: 2492:          }
        -: 2493:
    #####: 2494:          if (context_p->token.type != LEXER_LITERAL)
        -: 2495:          {
    #####: 2496:            scanner_raise_error (context_p);
        -: 2497:          }
        -: 2498:
    #####: 2499:          if (literal_pool_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -: 2500:          {
    #####: 2501:            context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 2502:          }
        -: 2503:
    #####: 2504:          scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);
    #####: 2505:          lexer_next_token (context_p);
    #####: 2506:          continue;
        -: 2507:        }
        -: 2508:#endif /* ENABLED (JERRY_ES2015) */
       55: 2509:        case SCAN_MODE_POST_PRIMARY_EXPRESSION:
        -: 2510:        {
       55: 2511:          if (scanner_scan_post_primary_expression (context_p, &scanner_context, type, stack_top))
        -: 2512:          {
       16: 2513:            break;
        -: 2514:          }
       39: 2515:          type = (lexer_token_type_t) context_p->token.type;
        -: 2516:          /* FALLTHRU */
        -: 2517:        }
       40: 2518:        case SCAN_MODE_PRIMARY_EXPRESSION_END:
        -: 2519:        {
       40: 2520:          if (scanner_scan_primary_expression_end (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2521:          {
       32: 2522:            continue;
        -: 2523:          }
        8: 2524:          break;
        -: 2525:        }
     1301: 2526:        case SCAN_MODE_STATEMENT_OR_TERMINATOR:
        -: 2527:        {
     1301: 2528:          if (type == LEXER_RIGHT_BRACE || type == LEXER_EOS)
        -: 2529:          {
    #####: 2530:            scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2531:            continue;
        -: 2532:          }
        -: 2533:          /* FALLTHRU */
        -: 2534:        }
        -: 2535:        case SCAN_MODE_STATEMENT:
        -: 2536:        {
     1317: 2537:          if (scanner_scan_statement (context_p, &scanner_context, type, stack_top) != SCAN_NEXT_TOKEN)
        -: 2538:          {
    #####: 2539:            continue;
        -: 2540:          }
       20: 2541:          break;
        -: 2542:        }
       17: 2543:        case SCAN_MODE_STATEMENT_END:
        -: 2544:        {
       17: 2545:          if (scanner_scan_statement_end (context_p, &scanner_context, type) != SCAN_NEXT_TOKEN)
        -: 2546:          {
       15: 2547:            continue;
        -: 2548:          }
        -: 2549:
        2: 2550:          if (context_p->token.type == LEXER_EOS)
        -: 2551:          {
        1: 2552:            goto scan_completed;
        -: 2553:          }
        -: 2554:
        1: 2555:          break;
        -: 2556:        }
       12: 2557:        case SCAN_MODE_VAR_STATEMENT:
        -: 2558:        {
        -: 2559:#if ENABLED (JERRY_ES2015)
       12: 2560:          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)
        -: 2561:          {
    #####: 2562:            uint8_t binding_type = SCANNER_BINDING_VAR;
        -: 2563:
    #####: 2564:            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)
        -: 2565:            {
    #####: 2566:              binding_type = SCANNER_BINDING_LET;
        -: 2567:            }
    #####: 2568:            else if (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START)
        -: 2569:            {
    #####: 2570:              binding_type = SCANNER_BINDING_CONST;
        -: 2571:            }
        -: 2572:
    #####: 2573:            scanner_push_destructuring_pattern (context_p, &scanner_context, binding_type, false);
        -: 2574:
    #####: 2575:            if (type == LEXER_LEFT_SQUARE)
        -: 2576:            {
    #####: 2577:              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 2578:              scanner_context.mode = SCAN_MODE_BINDING;
    #####: 2579:              break;
        -: 2580:            }
        -: 2581:
    #####: 2582:            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 2583:            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2584:            continue;
        -: 2585:          }
        -: 2586:#endif /* ENABLED (JERRY_ES2015) */
        -: 2587:
       12: 2588:          if (type != LEXER_LITERAL
       12: 2589:              || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2590:          {
    #####: 2591:            scanner_raise_error (context_p);
        -: 2592:          }
        -: 2593:
       12: 2594:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);
        -: 2595:
        -: 2596:#if ENABLED (JERRY_ES2015)
       12: 2597:          if (stack_top != SCAN_STACK_VAR && stack_top != SCAN_STACK_FOR_VAR_START)
        -: 2598:          {
    #####: 2599:            scanner_detect_invalid_let (context_p, literal_p);
        -: 2600:
    #####: 2601:            if (stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_FOR_LET_START)
        -: 2602:            {
    #####: 2603:              literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 2604:            }
        -: 2605:            else
        -: 2606:            {
    #####: 2607:              JERRY_ASSERT (stack_top == SCAN_STACK_CONST || stack_top == SCAN_STACK_FOR_CONST_START);
    #####: 2608:              literal_p->type |= SCANNER_LITERAL_IS_CONST;
        -: 2609:            }
        -: 2610:
    #####: 2611:            lexer_next_token (context_p);
        -: 2612:
    #####: 2613:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 2614:            {
    #####: 2615:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 2616:            }
    #####: 2617:            else if (context_p->token.type == LEXER_ASSIGN)
        -: 2618:            {
    #####: 2619:              scanner_binding_literal_t binding_literal;
    #####: 2620:              binding_literal.literal_p = literal_p;
        -: 2621:
    #####: 2622:              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####: 2623:              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
        -: 2624:            }
        -: 2625:          }
        -: 2626:          else
        -: 2627:          {
       12: 2628:            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))
        -: 2629:            {
       12: 2630:              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);
       12: 2631:              literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 2632:
       12: 2633:              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 2634:              {
    #####: 2635:                literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2636:              }
        -: 2637:            }
        -: 2638:
       12: 2639:            lexer_next_token (context_p);
        -: 2640:          }
        -: 2641:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2642:          literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 2643:
    #####: 2644:          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 2645:          {
    #####: 2646:            literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2647:          }
        -: 2648:
    #####: 2649:          lexer_next_token (context_p);
        -: 2650:#endif /* ENABLED (JERRY_ES2015) */
        -: 2651:
        -: 2652:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
       12: 2653:          if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT)
        -: 2654:          {
    #####: 2655:            literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 2656:          }
        -: 2657:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 2658:
       12: 2659:          switch (context_p->token.type)
        -: 2660:          {
       12: 2661:            case LEXER_ASSIGN:
        -: 2662:            {
       12: 2663:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 2664:              /* FALLTHRU */
        -: 2665:            }
       12: 2666:            case LEXER_COMMA:
        -: 2667:            {
       12: 2668:              lexer_next_token (context_p);
       12: 2669:              continue;
        -: 2670:            }
        -: 2671:          }
        -: 2672:
    #####: 2673:          if (SCANNER_IS_FOR_START (stack_top))
        -: 2674:          {
        -: 2675:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####: 2676:            JERRY_ASSERT (!(scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_EXPORT));
        -: 2677:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 2678:
    #####: 2679:            if (context_p->token.type != LEXER_SEMICOLON
    #####: 2680:                && context_p->token.type != LEXER_KEYW_IN
    #####: 2681:                && !SCANNER_IDENTIFIER_IS_OF ())
        -: 2682:            {
    #####: 2683:              scanner_raise_error (context_p);
        -: 2684:            }
        -: 2685:
    #####: 2686:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 2687:            continue;
        -: 2688:          }
        -: 2689:
        -: 2690:#if ENABLED (JERRY_ES2015)
    #####: 2691:          JERRY_ASSERT (stack_top == SCAN_STACK_VAR || stack_top == SCAN_STACK_LET || stack_top == SCAN_STACK_CONST);
        -: 2692:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2693:          JERRY_ASSERT (stack_top == SCAN_STACK_VAR);
        -: 2694:#endif /* ENABLED (JERRY_ES2015) */
        -: 2695:
        -: 2696:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####: 2697:          scanner_context.active_literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_IN_EXPORT;
        -: 2698:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 2699:
    #####: 2700:          scanner_context.mode = SCAN_MODE_STATEMENT_END;
    #####: 2701:          parser_stack_pop_uint8 (context_p);
    #####: 2702:          continue;
        -: 2703:        }
        2: 2704:        case SCAN_MODE_FUNCTION_ARGUMENTS:
        -: 2705:        {
        2: 2706:          JERRY_ASSERT (stack_top == SCAN_STACK_SCRIPT_FUNCTION
        -: 2707:                        || stack_top == SCAN_STACK_FUNCTION_STATEMENT
        -: 2708:                        || stack_top == SCAN_STACK_FUNCTION_EXPRESSION
        -: 2709:                        || stack_top == SCAN_STACK_FUNCTION_PROPERTY);
        -: 2710:
        2: 2711:          scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;
        -: 2712:
        2: 2713:          JERRY_ASSERT (literal_pool_p != NULL && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION));
        -: 2714:
        2: 2715:          literal_pool_p->source_p = context_p->source_p;
        -: 2716:
        -: 2717:#if ENABLED (JERRY_ES2015)
        2: 2718:          if (JERRY_UNLIKELY (scanner_context.async_source_p != NULL))
        -: 2719:          {
    #####: 2720:            literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####: 2721:            literal_pool_p->source_p = scanner_context.async_source_p;
    #####: 2722:            scanner_context.async_source_p = NULL;
        -: 2723:          }
        -: 2724:#endif /* ENABLED (JERRY_ES2015) */
        -: 2725:
        2: 2726:          if (type != LEXER_LEFT_PAREN)
        -: 2727:          {
    #####: 2728:            scanner_raise_error (context_p);
        -: 2729:          }
        2: 2730:          lexer_next_token (context_p);
        -: 2731:
        -: 2732:#if ENABLED (JERRY_ES2015)
        -: 2733:          /* FALLTHRU */
        -: 2734:        }
        2: 2735:        case SCAN_MODE_CONTINUE_FUNCTION_ARGUMENTS:
        -: 2736:        {
        -: 2737:#endif /* ENABLED (JERRY_ES2015) */
        2: 2738:          if (context_p->token.type != LEXER_RIGHT_PAREN && context_p->token.type != LEXER_EOS)
        -: 2739:          {
        -: 2740:#if ENABLED (JERRY_ES2015)
        -: 2741:            lexer_lit_location_t *argument_literal_p;
        -: 2742:#endif /* ENABLED (JERRY_ES2015) */
        -: 2743:
        -: 2744:            while (true)
        -: 2745:            {
        -: 2746:#if ENABLED (JERRY_ES2015)
        5: 2747:              if (context_p->token.type == LEXER_THREE_DOTS)
        -: 2748:              {
    #####: 2749:                scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;
        -: 2750:
    #####: 2751:                lexer_next_token (context_p);
        -: 2752:              }
        -: 2753:
        3: 2754:              if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 2755:              {
    #####: 2756:                argument_literal_p = NULL;
    #####: 2757:                break;
        -: 2758:              }
        -: 2759:#endif /* ENABLED (JERRY_ES2015) */
        -: 2760:
        3: 2761:              if (context_p->token.type != LEXER_LITERAL
        3: 2762:                  || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2763:              {
    #####: 2764:                scanner_raise_error (context_p);
        -: 2765:              }
        -: 2766:
        -: 2767:#if ENABLED (JERRY_ES2015)
        3: 2768:              argument_literal_p = scanner_append_argument (context_p, &scanner_context);
        -: 2769:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2770:              scanner_append_argument (context_p, &scanner_context);
        -: 2771:#endif /* ENABLED (JERRY_ES2015) */
        -: 2772:
        3: 2773:              lexer_next_token (context_p);
        -: 2774:
        3: 2775:              if (context_p->token.type != LEXER_COMMA)
        -: 2776:              {
        1: 2777:                break;
        -: 2778:              }
        2: 2779:              lexer_next_token (context_p);
        -: 2780:            }
        -: 2781:
        -: 2782:#if ENABLED (JERRY_ES2015)
        1: 2783:            if (argument_literal_p == NULL)
        -: 2784:            {
    #####: 2785:              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;
        -: 2786:
    #####: 2787:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);
    #####: 2788:              scanner_append_hole (context_p, &scanner_context);
    #####: 2789:              scanner_push_destructuring_pattern (context_p, &scanner_context, SCANNER_BINDING_ARG, false);
        -: 2790:
    #####: 2791:              if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2792:              {
    #####: 2793:                parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 2794:                scanner_context.mode = SCAN_MODE_BINDING;
    #####: 2795:                break;
        -: 2796:              }
        -: 2797:
    #####: 2798:              parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 2799:              scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 2800:              continue;
        -: 2801:            }
        -: 2802:
        1: 2803:            if (context_p->token.type == LEXER_ASSIGN)
        -: 2804:            {
    #####: 2805:              scanner_context.active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;
        -: 2806:
    #####: 2807:              parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PARAMETERS);
    #####: 2808:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 2809:
    #####: 2810:              if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 2811:              {
    #####: 2812:                JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);
    #####: 2813:                break;
        -: 2814:              }
        -: 2815:
    #####: 2816:              scanner_binding_literal_t binding_literal;
    #####: 2817:              binding_literal.literal_p = argument_literal_p;
        -: 2818:
    #####: 2819:              parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####: 2820:              parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
    #####: 2821:              break;
        -: 2822:            }
        -: 2823:#endif /* ENABLED (JERRY_ES2015) */
        -: 2824:          }
        -: 2825:
        2: 2826:          if (context_p->token.type == LEXER_EOS && stack_top == SCAN_STACK_SCRIPT_FUNCTION)
        -: 2827:          {
        -: 2828:            /* End of argument parsing. */
    #####: 2829:            scanner_info_t *scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, sizeof (scanner_info_t));
    #####: 2830:            scanner_info_p->next_p = context_p->next_scanner_info_p;
    #####: 2831:            scanner_info_p->source_p = NULL;
    #####: 2832:            scanner_info_p->type = SCANNER_TYPE_END_ARGUMENTS;
    #####: 2833:            scanner_context.end_arguments_p = scanner_info_p;
        -: 2834:
    #####: 2835:            context_p->next_scanner_info_p = scanner_info_p;
    #####: 2836:            context_p->source_p = source_p;
    #####: 2837:            context_p->source_end_p = source_end_p;
    #####: 2838:            context_p->line = 1;
    #####: 2839:            context_p->column = 1;
        -: 2840:
    #####: 2841:            scanner_filter_arguments (context_p, &scanner_context);
    #####: 2842:            lexer_next_token (context_p);
    #####: 2843:            scanner_check_directives (context_p, &scanner_context);
    #####: 2844:            continue;
        -: 2845:          }
        -: 2846:
        2: 2847:          if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2848:          {
    #####: 2849:            scanner_raise_error (context_p);
        -: 2850:          }
        -: 2851:
        2: 2852:          lexer_next_token (context_p);
        -: 2853:
        2: 2854:          if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2855:          {
    #####: 2856:            scanner_raise_error (context_p);
        -: 2857:          }
        -: 2858:
        2: 2859:          scanner_filter_arguments (context_p, &scanner_context);
        2: 2860:          lexer_next_token (context_p);
        2: 2861:          scanner_check_directives (context_p, &scanner_context);
        2: 2862:          continue;
        -: 2863:        }
        2: 2864:        case SCAN_MODE_PROPERTY_NAME:
        -: 2865:        {
        2: 2866:          JERRY_ASSERT (stack_top == SCAN_STACK_OBJECT_LITERAL);
        -: 2867:
        2: 2868:          if (lexer_scan_identifier (context_p))
        -: 2869:          {
        2: 2870:            lexer_check_property_modifier (context_p);
        -: 2871:          }
        -: 2872:
        -: 2873:#if ENABLED (JERRY_ES2015)
        2: 2874:          if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2875:          {
    #####: 2876:            parser_stack_push_uint8 (context_p, SCAN_STACK_COMPUTED_PROPERTY);
    #####: 2877:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2878:            break;
        -: 2879:          }
        -: 2880:#endif /* ENABLED (JERRY_ES2015) */
        -: 2881:
        2: 2882:          if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 2883:          {
    #####: 2884:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 2885:            continue;
        -: 2886:          }
        -: 2887:
        2: 2888:          if (context_p->token.type == LEXER_PROPERTY_GETTER
        -: 2889:#if ENABLED (JERRY_ES2015)
        2: 2890:              || context_p->token.type == LEXER_KEYW_ASYNC
        2: 2891:              || context_p->token.type == LEXER_MULTIPLY
        -: 2892:#endif /* ENABLED (JERRY_ES2015) */
        2: 2893:              || context_p->token.type == LEXER_PROPERTY_SETTER)
        -: 2894:          {
    #####: 2895:            uint16_t literal_pool_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -: 2896:
        -: 2897:#if ENABLED (JERRY_ES2015)
    #####: 2898:            if (context_p->token.type == LEXER_MULTIPLY)
        -: 2899:            {
    #####: 2900:              literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2901:            }
    #####: 2902:            else if (context_p->token.type == LEXER_KEYW_ASYNC)
        -: 2903:            {
    #####: 2904:              literal_pool_flags |= SCANNER_LITERAL_POOL_ASYNC;
        -: 2905:
    #####: 2906:              if (lexer_consume_generator (context_p))
        -: 2907:              {
    #####: 2908:                literal_pool_flags |= SCANNER_LITERAL_POOL_GENERATOR;
        -: 2909:              }
        -: 2910:            }
        -: 2911:#endif /* ENABLED (JERRY_ES2015) */
        -: 2912:
    #####: 2913:            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 2914:            lexer_scan_identifier (context_p);
        -: 2915:
        -: 2916:#if ENABLED (JERRY_ES2015)
    #####: 2917:            if (context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2918:            {
    #####: 2919:              parser_stack_push_uint8 (context_p, SCANNER_FROM_LITERAL_POOL_TO_COMPUTED (literal_pool_flags));
    #####: 2920:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2921:              break;
        -: 2922:            }
        -: 2923:#endif /* ENABLED (JERRY_ES2015) */
        -: 2924:
    #####: 2925:            if (context_p->token.type != LEXER_LITERAL)
        -: 2926:            {
    #####: 2927:              scanner_raise_error (context_p);
        -: 2928:            }
        -: 2929:
    #####: 2930:            scanner_push_literal_pool (context_p, &scanner_context, literal_pool_flags);
    #####: 2931:            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 2932:            break;
        -: 2933:          }
        -: 2934:
        2: 2935:          if (context_p->token.type != LEXER_LITERAL)
        -: 2936:          {
    #####: 2937:            scanner_raise_error (context_p);
        -: 2938:          }
        -: 2939:
        -: 2940:#if ENABLED (JERRY_ES2015)
        2: 2941:          parser_line_counter_t start_line = context_p->token.line;
        2: 2942:          parser_line_counter_t start_column = context_p->token.column;
        2: 2943:          bool is_ident = (context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 2944:#endif /* ENABLED (JERRY_ES2015) */
        -: 2945:
        2: 2946:          lexer_next_token (context_p);
        -: 2947:
        -: 2948:#if ENABLED (JERRY_ES2015)
        2: 2949:          if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2950:          {
    #####: 2951:            scanner_push_literal_pool (context_p, &scanner_context, SCANNER_LITERAL_POOL_FUNCTION);
        -: 2952:
    #####: 2953:            parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_PROPERTY);
    #####: 2954:            scanner_context.mode = SCAN_MODE_FUNCTION_ARGUMENTS;
    #####: 2955:            continue;
        -: 2956:          }
        -: 2957:
        2: 2958:          if (is_ident
        2: 2959:              && (context_p->token.type == LEXER_COMMA
        2: 2960:                  || context_p->token.type == LEXER_RIGHT_BRACE
        2: 2961:                  || context_p->token.type == LEXER_ASSIGN))
        -: 2962:          {
    #####: 2963:            context_p->source_p = context_p->token.lit_location.char_p;
    #####: 2964:            context_p->line = start_line;
    #####: 2965:            context_p->column = start_column;
        -: 2966:
    #####: 2967:            lexer_next_token (context_p);
        -: 2968:
    #####: 2969:            JERRY_ASSERT (context_p->token.type != LEXER_LITERAL
        -: 2970:                          || context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 2971:
    #####: 2972:            if (context_p->token.type != LEXER_LITERAL)
        -: 2973:            {
    #####: 2974:              scanner_raise_error (context_p);
        -: 2975:            }
        -: 2976:
    #####: 2977:            if (scanner_context.binding_type != SCANNER_BINDING_NONE)
        -: 2978:            {
    #####: 2979:              scanner_context.mode = SCAN_MODE_BINDING;
    #####: 2980:              continue;
        -: 2981:            }
        -: 2982:
    #####: 2983:            scanner_add_reference (context_p, &scanner_context);
        -: 2984:
    #####: 2985:            lexer_next_token (context_p);
        -: 2986:
    #####: 2987:            if (context_p->token.type == LEXER_ASSIGN)
        -: 2988:            {
    #####: 2989:              scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 2990:              break;
        -: 2991:            }
        -: 2992:
    #####: 2993:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####: 2994:            continue;
        -: 2995:          }
        -: 2996:#endif /* ENABLED (JERRY_ES2015) */
        -: 2997:
        2: 2998:          if (context_p->token.type != LEXER_COLON)
        -: 2999:          {
    #####: 3000:            scanner_raise_error (context_p);
        -: 3001:          }
        -: 3002:
        2: 3003:          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -: 3004:
        -: 3005:#if ENABLED (JERRY_ES2015)
        2: 3006:          if (scanner_context.binding_type != SCANNER_BINDING_NONE)
        -: 3007:          {
    #####: 3008:            scanner_context.mode = SCAN_MODE_BINDING;
        -: 3009:          }
        -: 3010:#endif /* ENABLED (JERRY_ES2015) */
        2: 3011:          break;
        -: 3012:        }
        -: 3013:#if ENABLED (JERRY_ES2015)
    #####: 3014:        case SCAN_MODE_BINDING:
        -: 3015:        {
    #####: 3016:          JERRY_ASSERT (scanner_context.binding_type == SCANNER_BINDING_VAR
        -: 3017:                        || scanner_context.binding_type == SCANNER_BINDING_LET
        -: 3018:                        || scanner_context.binding_type == SCANNER_BINDING_CATCH
        -: 3019:                        || scanner_context.binding_type == SCANNER_BINDING_CONST
        -: 3020:                        || scanner_context.binding_type == SCANNER_BINDING_ARG
        -: 3021:                        || scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG);
        -: 3022:
    #####: 3023:          if (type == LEXER_THREE_DOTS)
        -: 3024:          {
    #####: 3025:            lexer_next_token (context_p);
    #####: 3026:            type = (lexer_token_type_t) context_p->token.type;
        -: 3027:          }
        -: 3028:
    #####: 3029:          if (type == LEXER_LEFT_SQUARE || type == LEXER_LEFT_BRACE)
        -: 3030:          {
    #####: 3031:            scanner_push_destructuring_pattern (context_p, &scanner_context, scanner_context.binding_type, true);
        -: 3032:
    #####: 3033:            if (type == LEXER_LEFT_SQUARE)
        -: 3034:            {
    #####: 3035:              parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####: 3036:              break;
        -: 3037:            }
        -: 3038:
    #####: 3039:            parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####: 3040:            scanner_context.mode = SCAN_MODE_PROPERTY_NAME;
    #####: 3041:            continue;
        -: 3042:          }
        -: 3043:
    #####: 3044:          if (type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 3045:          {
    #####: 3046:            scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3047:            continue;
        -: 3048:          }
        -: 3049:
    #####: 3050:          lexer_lit_location_t *literal_p = scanner_add_literal (context_p, &scanner_context);
        -: 3051:
    #####: 3052:          scanner_context.mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -: 3053:
    #####: 3054:          if (scanner_context.binding_type == SCANNER_BINDING_VAR)
        -: 3055:          {
    #####: 3056:            if (!(literal_p->type & SCANNER_LITERAL_IS_VAR))
        -: 3057:            {
    #####: 3058:              scanner_detect_invalid_var (context_p, &scanner_context, literal_p);
    #####: 3059:              literal_p->type |= SCANNER_LITERAL_IS_VAR;
        -: 3060:
    #####: 3061:              if (scanner_context.active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 3062:              {
    #####: 3063:                literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 3064:              }
        -: 3065:            }
    #####: 3066:            break;
        -: 3067:          }
        -: 3068:
    #####: 3069:          if (scanner_context.binding_type == SCANNER_BINDING_ARROW_ARG)
        -: 3070:          {
    #####: 3071:            literal_p->type |= SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
        -: 3072:
    #####: 3073:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3074:            {
    #####: 3075:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3076:              break;
        -: 3077:            }
        -: 3078:          }
        -: 3079:          else
        -: 3080:          {
    #####: 3081:            scanner_detect_invalid_let (context_p, literal_p);
        -: 3082:
    #####: 3083:            if (scanner_context.binding_type <= SCANNER_BINDING_CATCH)
        -: 3084:            {
    #####: 3085:              JERRY_ASSERT ((scanner_context.binding_type == SCANNER_BINDING_LET)
        -: 3086:                            || (scanner_context.binding_type == SCANNER_BINDING_CATCH));
        -: 3087:
    #####: 3088:              literal_p->type |= SCANNER_LITERAL_IS_LET;
        -: 3089:            }
        -: 3090:            else
        -: 3091:            {
    #####: 3092:              literal_p->type |= SCANNER_LITERAL_IS_CONST;
        -: 3093:
    #####: 3094:              if (scanner_context.binding_type == SCANNER_BINDING_ARG)
        -: 3095:              {
    #####: 3096:                literal_p->type |= SCANNER_LITERAL_IS_ARG;
        -: 3097:
    #####: 3098:                if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3099:                {
    #####: 3100:                  literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3101:                  break;
        -: 3102:                }
        -: 3103:              }
        -: 3104:            }
        -: 3105:
    #####: 3106:            if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 3107:            {
    #####: 3108:              literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
    #####: 3109:              break;
        -: 3110:            }
        -: 3111:          }
        -: 3112:
        -: 3113:          scanner_binding_item_t *binding_item_p;
    #####: 3114:          binding_item_p = (scanner_binding_item_t *) scanner_malloc (context_p, sizeof (scanner_binding_item_t));
        -: 3115:
    #####: 3116:          binding_item_p->next_p = scanner_context.active_binding_list_p->items_p;
    #####: 3117:          binding_item_p->literal_p = literal_p;
        -: 3118:
    #####: 3119:          scanner_context.active_binding_list_p->items_p = binding_item_p;
        -: 3120:
    #####: 3121:          lexer_next_token (context_p);
    #####: 3122:          if (context_p->token.type != LEXER_ASSIGN)
        -: 3123:          {
    #####: 3124:            continue;
        -: 3125:          }
        -: 3126:
    #####: 3127:          scanner_binding_literal_t binding_literal;
    #####: 3128:          binding_literal.literal_p = literal_p;
        -: 3129:
    #####: 3130:          parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####: 3131:          parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
        -: 3132:
    #####: 3133:          scanner_context.mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 3134:          break;
        -: 3135:        }
        -: 3136:#endif /* ENABLED (JERRY_ES2015) */
        -: 3137:      }
        -: 3138:
       80: 3139:      lexer_next_token (context_p);
        -: 3140:    }
        -: 3141:
        1: 3142:scan_completed:
        1: 3143:    if (context_p->stack_top_uint8 != SCAN_STACK_SCRIPT
    #####: 3144:        && context_p->stack_top_uint8 != SCAN_STACK_SCRIPT_FUNCTION)
        -: 3145:    {
    #####: 3146:      scanner_raise_error (context_p);
        -: 3147:    }
        -: 3148:
        1: 3149:    scanner_pop_literal_pool (context_p, &scanner_context);
        -: 3150:
        -: 3151:#if ENABLED (JERRY_ES2015)
        1: 3152:    JERRY_ASSERT (scanner_context.active_binding_list_p == NULL);
        -: 3153:#endif /* ENABLED (JERRY_ES2015) */
        1: 3154:    JERRY_ASSERT (scanner_context.active_literal_pool_p == NULL);
        -: 3155:
        -: 3156:#ifndef JERRY_NDEBUG
        1: 3157:    scanner_context.context_status_flags |= PARSER_SCANNING_SUCCESSFUL;
        -: 3158:#endif /* !JERRY_NDEBUG */
        -: 3159:  }
        -: 3160:  PARSER_CATCH
        -: 3161:  {
     1309: 3162:    if (context_p->error != PARSER_ERR_OUT_OF_MEMORY)
        -: 3163:    {
     1297: 3164:      context_p->error = PARSER_ERR_NO_ERROR;
        -: 3165:    }
        -: 3166:
        -: 3167:#if ENABLED (JERRY_ES2015)
     2618: 3168:    while (scanner_context.active_binding_list_p != NULL)
        -: 3169:    {
    #####: 3170:      scanner_pop_binding_list (&scanner_context);
        -: 3171:    }
        -: 3172:#endif /* ENABLED (JERRY_ES2015) */
        -: 3173:
     1309: 3174:    PARSER_TRY (context_p->try_buffer)
        -: 3175:    {
        -: 3176:#if ENABLED (JERRY_ES2015)
     1309: 3177:      if (scanner_context.status_flags & SCANNER_CONTEXT_THROW_ERR_ASYNC_FUNCTION)
        -: 3178:      {
    #####: 3179:        JERRY_ASSERT (scanner_context.async_source_p != NULL);
        -: 3180:
        -: 3181:        scanner_info_t *info_p;
    #####: 3182:        info_p = scanner_insert_info (context_p, scanner_context.async_source_p, sizeof (scanner_info_t));
    #####: 3183:        info_p->type = SCANNER_TYPE_ERR_ASYNC_FUNCTION;
        -: 3184:      }
        -: 3185:#endif /* ENABLED (JERRY_ES2015) */
        -: 3186:
     3926: 3187:      while (scanner_context.active_literal_pool_p != NULL)
        -: 3188:      {
     1308: 3189:        scanner_pop_literal_pool (context_p, &scanner_context);
        -: 3190:      }
        -: 3191:    }
        -: 3192:    PARSER_CATCH
        -: 3193:    {
    #####: 3194:      JERRY_ASSERT (context_p->error == PARSER_ERR_NO_ERROR);
        -: 3195:
    #####: 3196:      while (scanner_context.active_literal_pool_p != NULL)
        -: 3197:      {
    #####: 3198:        scanner_literal_pool_t *literal_pool_p = scanner_context.active_literal_pool_p;
        -: 3199:
    #####: 3200:        scanner_context.active_literal_pool_p = literal_pool_p->prev_p;
        -: 3201:
    #####: 3202:        parser_list_free (&literal_pool_p->literal_pool);
    #####: 3203:        scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 3204:      }
        -: 3205:    }
        -: 3206:    PARSER_TRY_END
        -: 3207:
        -: 3208:#if ENABLED (JERRY_ES2015)
     1309: 3209:    context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;
        -: 3210:#endif /* ENABLED (JERRY_ES2015) */
        -: 3211:  }
        -: 3212:  PARSER_TRY_END
        -: 3213:
     1310: 3214:  context_p->status_flags = scanner_context.context_status_flags;
     1310: 3215:  scanner_reverse_info_list (context_p);
        -: 3216:
        -: 3217:#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)
        -: 3218:  if (context_p->is_show_opcodes)
        -: 3219:  {
        -: 3220:    scanner_info_t *info_p = context_p->next_scanner_info_p;
        -: 3221:    const uint8_t *source_start_p = (arg_list_p == NULL) ? source_p : arg_list_p;
        -: 3222:
        -: 3223:    while (info_p->type != SCANNER_TYPE_END)
        -: 3224:    {
        -: 3225:      const char *name_p = NULL;
        -: 3226:      bool print_location = false;
        -: 3227:
        -: 3228:      switch (info_p->type)
        -: 3229:      {
        -: 3230:        case SCANNER_TYPE_END_ARGUMENTS:
        -: 3231:        {
        -: 3232:          JERRY_DEBUG_MSG ("  END_ARGUMENTS\n");
        -: 3233:          source_start_p = source_p;
        -: 3234:          break;
        -: 3235:        }
        -: 3236:        case SCANNER_TYPE_FUNCTION:
        -: 3237:        case SCANNER_TYPE_BLOCK:
        -: 3238:        {
        -: 3239:          const uint8_t *prev_source_p = info_p->source_p - 1;
        -: 3240:          const uint8_t *data_p;
        -: 3241:
        -: 3242:          if (info_p->type == SCANNER_TYPE_FUNCTION)
        -: 3243:          {
        -: 3244:            data_p = (const uint8_t *) (info_p + 1);
        -: 3245:
        -: 3246:            JERRY_DEBUG_MSG ("  FUNCTION: flags: 0x%x declarations: %d",
        -: 3247:                             (int) info_p->u8_arg,
        -: 3248:                             (int) info_p->u16_arg);
        -: 3249:          }
        -: 3250:          else
        -: 3251:          {
        -: 3252:            data_p = (const uint8_t *) (info_p + 1);
        -: 3253:
        -: 3254:            JERRY_DEBUG_MSG ("  BLOCK:");
        -: 3255:          }
        -: 3256:
        -: 3257:          JERRY_DEBUG_MSG (" source:%d\n", (int) (info_p->source_p - source_start_p));
        -: 3258:
        -: 3259:          while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 3260:          {
        -: 3261:            switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)
        -: 3262:            {
        -: 3263:              case SCANNER_STREAM_TYPE_VAR:
        -: 3264:              {
        -: 3265:                JERRY_DEBUG_MSG ("    VAR ");
        -: 3266:                break;
        -: 3267:              }
        -: 3268:#if ENABLED (JERRY_ES2015)
        -: 3269:              case SCANNER_STREAM_TYPE_LET:
        -: 3270:              {
        -: 3271:                JERRY_DEBUG_MSG ("    LET ");
        -: 3272:                break;
        -: 3273:              }
        -: 3274:              case SCANNER_STREAM_TYPE_CONST:
        -: 3275:              {
        -: 3276:                JERRY_DEBUG_MSG ("    CONST ");
        -: 3277:                break;
        -: 3278:              }
        -: 3279:              case SCANNER_STREAM_TYPE_LOCAL:
        -: 3280:              {
        -: 3281:                JERRY_DEBUG_MSG ("    LOCAL ");
        -: 3282:                break;
        -: 3283:              }
        -: 3284:#endif /* ENABLED (JERRY_ES2015) */
        -: 3285:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
        -: 3286:              case SCANNER_STREAM_TYPE_IMPORT:
        -: 3287:              {
        -: 3288:                JERRY_DEBUG_MSG ("    IMPORT ");
        -: 3289:                break;
        -: 3290:              }
        -: 3291:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 3292:              case SCANNER_STREAM_TYPE_ARG:
        -: 3293:              {
        -: 3294:                JERRY_DEBUG_MSG ("    ARG ");
        -: 3295:                break;
        -: 3296:              }
        -: 3297:#if ENABLED (JERRY_ES2015)
        -: 3298:              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 3299:              {
        -: 3300:                JERRY_DEBUG_MSG ("    DESTRUCTURED_ARG ");
        -: 3301:                break;
        -: 3302:              }
        -: 3303:#endif /* ENABLED (JERRY_ES2015) */
        -: 3304:              case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 3305:              {
        -: 3306:                JERRY_DEBUG_MSG ("    ARG_FUNC ");
        -: 3307:                break;
        -: 3308:              }
        -: 3309:#if ENABLED (JERRY_ES2015)
        -: 3310:              case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 3311:              {
        -: 3312:                JERRY_DEBUG_MSG ("    DESTRUCTURED_ARG_FUNC ");
        -: 3313:                break;
        -: 3314:              }
        -: 3315:#endif /* ENABLED (JERRY_ES2015) */
        -: 3316:              case SCANNER_STREAM_TYPE_FUNC:
        -: 3317:              {
        -: 3318:                JERRY_DEBUG_MSG ("    FUNC ");
        -: 3319:                break;
        -: 3320:              }
        -: 3321:              default:
        -: 3322:              {
        -: 3323:                JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE);
        -: 3324:                JERRY_DEBUG_MSG ("    HOLE\n");
        -: 3325:                data_p++;
        -: 3326:                continue;
        -: 3327:              }
        -: 3328:            }
        -: 3329:
        -: 3330:            size_t length;
        -: 3331:
        -: 3332:            if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 3333:            {
        -: 3334:              if (data_p[2] != 0)
        -: 3335:              {
        -: 3336:                prev_source_p += data_p[2];
        -: 3337:                length = 2 + 1;
        -: 3338:              }
        -: 3339:              else
        -: 3340:              {
        -: 3341:                memcpy (&prev_source_p, data_p + 2 + 1, sizeof (const uint8_t *));
        -: 3342:                length = 2 + 1 + sizeof (const uint8_t *);
        -: 3343:              }
        -: 3344:            }
        -: 3345:            else
        -: 3346:            {
        -: 3347:              int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 3348:
        -: 3349:              if (diff <= UINT8_MAX)
        -: 3350:              {
        -: 3351:                diff = -diff;
        -: 3352:              }
        -: 3353:
        -: 3354:              prev_source_p += diff;
        -: 3355:              length = 2 + 2;
        -: 3356:            }
        -: 3357:
        -: 3358:#if ENABLED (JERRY_ES2015)
        -: 3359:            if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)
        -: 3360:            {
        -: 3361:              JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);
        -: 3362:              JERRY_DEBUG_MSG ("*");
        -: 3363:            }
        -: 3364:#endif /* ENABLED (JERRY_ES2015) */
        -: 3365:
        -: 3366:            if (data_p[0] & SCANNER_STREAM_NO_REG)
        -: 3367:            {
        -: 3368:              JERRY_DEBUG_MSG ("* ");
        -: 3369:            }
        -: 3370:
        -: 3371:            JERRY_DEBUG_MSG ("'%.*s'\n", data_p[1], (char *) prev_source_p);
        -: 3372:            prev_source_p += data_p[1];
        -: 3373:            data_p += length;
        -: 3374:          }
        -: 3375:          break;
        -: 3376:        }
        -: 3377:        case SCANNER_TYPE_WHILE:
        -: 3378:        {
        -: 3379:          name_p = "WHILE";
        -: 3380:          print_location = true;
        -: 3381:          break;
        -: 3382:        }
        -: 3383:        case SCANNER_TYPE_FOR:
        -: 3384:        {
        -: 3385:          scanner_for_info_t *for_info_p = (scanner_for_info_t *) info_p;
        -: 3386:          JERRY_DEBUG_MSG ("  FOR: source:%d expression:%d[%d:%d] end:%d[%d:%d]\n",
        -: 3387:                           (int) (for_info_p->info.source_p - source_start_p),
        -: 3388:                           (int) (for_info_p->expression_location.source_p - source_start_p),
        -: 3389:                           (int) for_info_p->expression_location.line,
        -: 3390:                           (int) for_info_p->expression_location.column,
        -: 3391:                           (int) (for_info_p->end_location.source_p - source_start_p),
        -: 3392:                           (int) for_info_p->end_location.line,
        -: 3393:                           (int) for_info_p->end_location.column);
        -: 3394:          break;
        -: 3395:        }
        -: 3396:        case SCANNER_TYPE_FOR_IN:
        -: 3397:        {
        -: 3398:          name_p = "FOR-IN";
        -: 3399:          print_location = true;
        -: 3400:          break;
        -: 3401:        }
        -: 3402:#if ENABLED (JERRY_ES2015)
        -: 3403:        case SCANNER_TYPE_FOR_OF:
        -: 3404:        {
        -: 3405:          name_p = "FOR-OF";
        -: 3406:          print_location = true;
        -: 3407:          break;
        -: 3408:        }
        -: 3409:#endif /* ENABLED (JERRY_ES2015) */
        -: 3410:        case SCANNER_TYPE_SWITCH:
        -: 3411:        {
        -: 3412:          JERRY_DEBUG_MSG ("  SWITCH: source:%d\n",
        -: 3413:                           (int) (info_p->source_p - source_start_p));
        -: 3414:
        -: 3415:          scanner_case_info_t *current_case_p = ((scanner_switch_info_t *) info_p)->case_p;
        -: 3416:
        -: 3417:          while (current_case_p != NULL)
        -: 3418:          {
        -: 3419:            JERRY_DEBUG_MSG ("    CASE: location:%d[%d:%d]\n",
        -: 3420:                             (int) (current_case_p->location.source_p - source_start_p),
        -: 3421:                             (int) current_case_p->location.line,
        -: 3422:                             (int) current_case_p->location.column);
        -: 3423:
        -: 3424:            current_case_p = current_case_p->next_p;
        -: 3425:          }
        -: 3426:          break;
        -: 3427:        }
        -: 3428:        case SCANNER_TYPE_CASE:
        -: 3429:        {
        -: 3430:          name_p = "CASE";
        -: 3431:          print_location = true;
        -: 3432:          break;
        -: 3433:        }
        -: 3434:#if ENABLED (JERRY_ES2015)
        -: 3435:        case SCANNER_TYPE_INITIALIZER:
        -: 3436:        {
        -: 3437:          name_p = "INITIALIZER";
        -: 3438:          print_location = true;
        -: 3439:          break;
        -: 3440:        }
        -: 3441:        case SCANNER_TYPE_CLASS_CONSTRUCTOR:
        -: 3442:        {
        -: 3443:          JERRY_DEBUG_MSG ("  CLASS-CONSTRUCTOR: source:%d\n",
        -: 3444:                           (int) (info_p->source_p - source_start_p));
        -: 3445:          print_location = false;
        -: 3446:          break;
        -: 3447:        }
        -: 3448:        case SCANNER_TYPE_LET_EXPRESSION:
        -: 3449:        {
        -: 3450:          JERRY_DEBUG_MSG ("  LET_EXPRESSION: source:%d\n",
        -: 3451:                           (int) (info_p->source_p - source_start_p));
        -: 3452:          break;
        -: 3453:        }
        -: 3454:        case SCANNER_TYPE_ERR_REDECLARED:
        -: 3455:        {
        -: 3456:          JERRY_DEBUG_MSG ("  ERR_REDECLARED: source:%d\n",
        -: 3457:                           (int) (info_p->source_p - source_start_p));
        -: 3458:          break;
        -: 3459:        }
        -: 3460:        case SCANNER_TYPE_ERR_ASYNC_FUNCTION:
        -: 3461:        {
        -: 3462:          JERRY_DEBUG_MSG ("  ERR_ASYNC_FUNCTION: source:%d\n",
        -: 3463:                           (int) (info_p->source_p - source_start_p));
        -: 3464:          break;
        -: 3465:        }
        -: 3466:#endif /* ENABLED (JERRY_ES2015) */
        -: 3467:      }
        -: 3468:
        -: 3469:      if (print_location)
        -: 3470:      {
        -: 3471:        scanner_location_info_t *location_info_p = (scanner_location_info_t *) info_p;
        -: 3472:        JERRY_DEBUG_MSG ("  %s: source:%d location:%d[%d:%d]\n",
        -: 3473:                         name_p,
        -: 3474:                         (int) (location_info_p->info.source_p - source_start_p),
        -: 3475:                         (int) (location_info_p->location.source_p - source_start_p),
        -: 3476:                         (int) location_info_p->location.line,
        -: 3477:                         (int) location_info_p->location.column);
        -: 3478:      }
        -: 3479:
        -: 3480:      info_p = info_p->next_p;
        -: 3481:    }
        -: 3482:
        -: 3483:    JERRY_DEBUG_MSG ("\n--- Scanning end ---\n\n");
        -: 3484:  }
        -: 3485:#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */
        -: 3486:
     1309: 3487:  parser_stack_free (context_p);
     1309: 3488:} /* scanner_scan_all */
        -: 3489:
        -: 3490:/**
        -: 3491: * @}
        -: 3492: * @}
        -: 3493: * @}
        -: 3494: */
        -: 3495:
        -: 3496:#endif /* ENABLED (JERRY_PARSER) */
