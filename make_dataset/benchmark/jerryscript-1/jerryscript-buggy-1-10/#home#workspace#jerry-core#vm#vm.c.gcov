        -:    0:Source:/home/workspace/jerry-core/vm/vm.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "common.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-array-object.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-builtin-object.h"
        -:   22:#include "ecma-comparison.h"
        -:   23:#include "ecma-conversion.h"
        -:   24:#include "ecma-exceptions.h"
        -:   25:#include "ecma-function-object.h"
        -:   26:#include "ecma-gc.h"
        -:   27:#include "ecma-helpers.h"
        -:   28:#include "ecma-iterator-object.h"
        -:   29:#include "ecma-lcache.h"
        -:   30:#include "ecma-lex-env.h"
        -:   31:#include "ecma-objects.h"
        -:   32:#include "ecma-objects-general.h"
        -:   33:#include "ecma-regexp-object.h"
        -:   34:#include "ecma-try-catch-macro.h"
        -:   35:#include "jcontext.h"
        -:   36:#include "opcodes.h"
        -:   37:#include "vm.h"
        -:   38:#include "vm-stack.h"
        -:   39:
        -:   40:/** \addtogroup vm Virtual machine
        -:   41: * @{
        -:   42: *
        -:   43: * \addtogroup vm_executor Executor
        -:   44: * @{
        -:   45: */
        -:   46:
        -:   47:/**
        -:   48: * Special constant to represent direct eval code.
        -:   49: */
        -:   50:#define VM_DIRECT_EVAL ((void *) 0x1)
        -:   51:
        -:   52:/**
        -:   53: * Get the value of object[property].
        -:   54: *
        -:   55: * @return ecma value
        -:   56: */
        -:   57:static ecma_value_t
     1311:   58:vm_op_get_value (ecma_value_t object, /**< base object */
        -:   59:                 ecma_value_t property) /**< property name */
        -:   60:{
     1311:   61:  if (ecma_is_value_object (object))
        -:   62:  {
     1310:   63:    ecma_object_t *object_p = ecma_get_object_from_value (object);
     1310:   64:    ecma_string_t *property_name_p = NULL;
        -:   65:
     1310:   66:    if (ecma_is_value_integer_number (property))
        -:   67:    {
    #####:   68:      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);
        -:   69:
    #####:   70:      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)
        -:   71:      {
    #####:   72:        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)
        -:   73:        {
    #####:   74:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   75:
    #####:   76:          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)
        -:   77:                            && (uint32_t) int_value < ext_object_p->u.array.length))
        -:   78:          {
    #####:   79:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:   80:
    #####:   81:            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))
        -:   82:            {
    #####:   83:              return ecma_fast_copy_value (values_p[int_value]);
        -:   84:            }
        -:   85:          }
        -:   86:        }
        -:   87:
    #####:   88:        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT,
        -:   89:                                                                       (uintptr_t) int_value);
        -:   90:      }
        -:   91:    }
     1310:   92:    else if (ecma_is_value_string (property))
        -:   93:    {
     1310:   94:      property_name_p = ecma_get_string_from_value (property);
        -:   95:    }
        -:   96:
        -:   97:#if ENABLED (JERRY_ES2015)
     1310:   98:    if (ecma_is_value_symbol (property))
        -:   99:    {
    #####:  100:      property_name_p = ecma_get_symbol_from_value (property);
        -:  101:    }
        -:  102:#endif /* ENABLED (JERRY_ES2015) */
        -:  103:
     1310:  104:    if (property_name_p != NULL)
        -:  105:    {
        -:  106:#if ENABLED (JERRY_LCACHE)
     1310:  107:      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);
        -:  108:
     1310:  109:      if (property_p != NULL &&
    #####:  110:          ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)
        -:  111:      {
    #####:  112:        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  113:      }
        -:  114:#endif /* ENABLED (JERRY_LCACHE) */
        -:  115:
        -:  116:      /* There is no need to free the name. */
     1310:  117:      return ecma_op_object_get (object_p, property_name_p);
        -:  118:    }
        -:  119:  }
        -:  120:
        1:  121:  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))
        -:  122:  {
        -:  123:#if ENABLED (JERRY_ERROR_MESSAGES)
    #####:  124:    ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,
        -:  125:                                                                      "Cannot read property '%' of %",
        -:  126:                                                                      property,
        -:  127:                                                                      object);
        -:  128:#else /* !ENABLED (JERRY_ERROR_MESSAGES) */
        -:  129:    ecma_value_t error_value = ecma_raise_type_error (NULL);
        -:  130:#endif /* ENABLED (JERRY_ERROR_MESSAGES) */
    #####:  131:    return error_value;
        -:  132:  }
        -:  133:
        1:  134:  ecma_string_t *property_name_p = ecma_op_to_prop_name (property);
        -:  135:
        1:  136:  if (property_name_p == NULL)
        -:  137:  {
    #####:  138:    return ECMA_VALUE_ERROR;
        -:  139:  }
        -:  140:
        1:  141:  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);
        -:  142:
        1:  143:  ecma_deref_ecma_string (property_name_p);
        1:  144:  return get_value_result;
        -:  145:} /* vm_op_get_value */
        -:  146:
        -:  147:/**
        -:  148: * Set the value of object[property].
        -:  149: *
        -:  150: * Note:
        -:  151: *  this function frees its object and property arguments
        -:  152: *
        -:  153: * @return an ecma value which contains an error
        -:  154: *         if the property setting is unsuccessful
        -:  155: */
        -:  156:static ecma_value_t
     1309:  157:vm_op_set_value (ecma_value_t object, /**< base object */
        -:  158:                 ecma_value_t property, /**< property name */
        -:  159:                 ecma_value_t value, /**< ecma value */
        -:  160:                 bool is_strict) /**< strict mode */
        -:  161:{
        -:  162:  ecma_object_t * object_p;
        -:  163:
     1309:  164:  if (JERRY_UNLIKELY (!ecma_is_value_object (object)))
        -:  165:  {
    #####:  166:    ecma_value_t to_object = ecma_op_to_object (object);
    #####:  167:    ecma_free_value (object);
        -:  168:
    #####:  169:    if (ECMA_IS_VALUE_ERROR (to_object))
        -:  170:    {
        -:  171:#if ENABLED (JERRY_ERROR_MESSAGES)
    #####:  172:      ecma_free_value (to_object);
    #####:  173:      jcontext_release_exception ();
        -:  174:
    #####:  175:      ecma_value_t error_value = ecma_raise_standard_error_with_format (ECMA_ERROR_TYPE,
        -:  176:                                                                        "Cannot set property '%' of %",
        -:  177:                                                                        property,
        -:  178:                                                                        object);
    #####:  179:      ecma_free_value (property);
        -:  180:
    #####:  181:      return error_value;
        -:  182:#else /* !ENABLED (JERRY_ERROR_MESSAGES) */
        -:  183:      ecma_free_value (property);
        -:  184:      return to_object;
        -:  185:#endif /* ENABLED (JERRY_ERROR_MESSAGES) */
        -:  186:    }
        -:  187:
    #####:  188:    object_p = ecma_get_object_from_value (to_object);
    #####:  189:    ecma_op_ordinary_object_prevent_extensions (object_p);
        -:  190:  }
        -:  191:  else
        -:  192:  {
     1309:  193:    object_p = ecma_get_object_from_value (object);
        -:  194:  }
        -:  195:
        -:  196:  ecma_string_t *property_p;
        -:  197:
     1309:  198:  if (!ecma_is_value_prop_name (property))
        -:  199:  {
     1308:  200:    property_p = ecma_op_to_prop_name (property);
     1308:  201:    ecma_fast_free_value (property);
        -:  202:
     1308:  203:    if (JERRY_UNLIKELY (property_p == NULL))
        -:  204:    {
    #####:  205:      ecma_deref_object (object_p);
    #####:  206:      return ECMA_VALUE_ERROR;
        -:  207:    }
        -:  208:  }
        -:  209:  else
        -:  210:  {
        1:  211:    property_p = ecma_get_prop_name_from_value (property);
        -:  212:  }
        -:  213:
     1309:  214:  ecma_value_t completion_value = ECMA_VALUE_EMPTY;
        -:  215:
     1309:  216:  if (!ecma_is_lexical_environment (object_p))
        -:  217:  {
     1309:  218:    completion_value = ecma_op_object_put (object_p,
        -:  219:                                           property_p,
        -:  220:                                           value,
        -:  221:                                           is_strict);
        -:  222:  }
        -:  223:  else
        -:  224:  {
    #####:  225:    completion_value = ecma_op_set_mutable_binding (object_p,
        -:  226:                                                    property_p,
        -:  227:                                                    value,
        -:  228:                                                    is_strict);
        -:  229:  }
        -:  230:
     1309:  231:  ecma_deref_object (object_p);
     1309:  232:  ecma_deref_ecma_string (property_p);
        -:  233:
     1309:  234:  return completion_value;
        -:  235:} /* vm_op_set_value */
        -:  236:
        -:  237:/** Compact bytecode define */
        -:  238:#define CBC_OPCODE(arg1, arg2, arg3, arg4) arg4,
        -:  239:
        -:  240:/**
        -:  241: * Decode table for both opcodes and extended opcodes.
        -:  242: */
        -:  243:static const uint16_t vm_decode_table[] JERRY_ATTR_CONST_DATA =
        -:  244:{
        -:  245:  CBC_OPCODE_LIST
        -:  246:  CBC_EXT_OPCODE_LIST
        -:  247:};
        -:  248:
        -:  249:#undef CBC_OPCODE
        -:  250:
        -:  251:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
        -:  252:/**
        -:  253: * Run ES2015 module code
        -:  254: *
        -:  255: * Note:
        -:  256: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  257: *
        -:  258: * @return ecma value
        -:  259: */
        -:  260:ecma_value_t
    #####:  261:vm_run_module (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */
        -:  262:               ecma_object_t *lex_env_p) /**< pointer to the specified lexenv to run in */
        -:  263:{
    #####:  264:  const ecma_value_t module_init_result = ecma_module_initialize_current ();
    #####:  265:  if (ECMA_IS_VALUE_ERROR (module_init_result))
        -:  266:  {
    #####:  267:    return module_init_result;
        -:  268:  }
        -:  269:
    #####:  270:  return vm_run (bytecode_p,
        -:  271:                 ECMA_VALUE_UNDEFINED,
        -:  272:                 lex_env_p,
        -:  273:                 NULL,
        -:  274:                 0);
        -:  275:} /* vm_run_module */
        -:  276:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  277:
        -:  278:/**
        -:  279: * Run global code
        -:  280: *
        -:  281: * Note:
        -:  282: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  283: *
        -:  284: * @return ecma value
        -:  285: */
        -:  286:ecma_value_t
        1:  287:vm_run_global (const ecma_compiled_code_t *bytecode_p) /**< pointer to bytecode to run */
        -:  288:{
        1:  289:  ecma_object_t *glob_obj_p = ecma_builtin_get_global ();
        -:  290:
        -:  291:#if ENABLED (JERRY_ES2015)
        1:  292:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)
        -:  293:  {
    #####:  294:    ecma_create_global_lexical_block ();
        -:  295:  }
        -:  296:#endif /* ENABLED (JERRY_ES2015) */
        -:  297:
        1:  298:  ecma_object_t *const global_scope_p = ecma_get_global_scope ();
        -:  299:
        -:  300:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
        1:  301:  if (JERRY_CONTEXT (module_top_context_p) != NULL)
        -:  302:  {
    #####:  303:    JERRY_ASSERT (JERRY_CONTEXT (module_top_context_p)->parent_p == NULL);
    #####:  304:    ecma_module_t *module_p = JERRY_CONTEXT (module_top_context_p)->module_p;
        -:  305:
    #####:  306:    JERRY_ASSERT (module_p->scope_p == NULL);
    #####:  307:    ecma_ref_object (global_scope_p);
    #####:  308:    module_p->scope_p = global_scope_p;
        -:  309:
    #####:  310:    const ecma_value_t module_init_result = ecma_module_initialize_current ();
    #####:  311:    ecma_module_cleanup ();
    #####:  312:    JERRY_CONTEXT (module_top_context_p) = NULL;
        -:  313:
    #####:  314:    if (ECMA_IS_VALUE_ERROR (module_init_result))
        -:  315:    {
    #####:  316:      return module_init_result;
        -:  317:    }
        -:  318:  }
        -:  319:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  320:
        1:  321:  return vm_run (bytecode_p,
        -:  322:                 ecma_make_object_value (glob_obj_p),
        -:  323:                 global_scope_p,
        -:  324:                 NULL,
        -:  325:                 0);
        -:  326:} /* vm_run_global */
        -:  327:
        -:  328:/**
        -:  329: * Run specified eval-mode bytecode
        -:  330: *
        -:  331: * @return ecma value
        -:  332: */
        -:  333:ecma_value_t
    #####:  334:vm_run_eval (ecma_compiled_code_t *bytecode_data_p, /**< byte-code data */
        -:  335:             uint32_t parse_opts) /**< ecma_parse_opts_t option bits */
        -:  336:{
        -:  337:  ecma_value_t this_binding;
        -:  338:  ecma_object_t *lex_env_p;
        -:  339:
        -:  340:  /* ECMA-262 v5, 10.4.2 */
    #####:  341:  if (parse_opts & ECMA_PARSE_DIRECT_EVAL)
        -:  342:  {
    #####:  343:    this_binding = ecma_copy_value (JERRY_CONTEXT (vm_top_context_p)->this_binding);
    #####:  344:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  345:
        -:  346:#if ENABLED (JERRY_DEBUGGER)
        -:  347:    uint32_t chain_index = parse_opts >> ECMA_PARSE_CHAIN_INDEX_SHIFT;
        -:  348:    parse_opts &= (1 << ECMA_PARSE_CHAIN_INDEX_SHIFT) - 1;
        -:  349:
        -:  350:    while (chain_index != 0)
        -:  351:    {
        -:  352:      if (JERRY_UNLIKELY (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL))
        -:  353:      {
        -:  354:        return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid scope chain index for eval"));
        -:  355:      }
        -:  356:
        -:  357:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  358:
        -:  359:      if ((ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)
        -:  360:          || (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE))
        -:  361:      {
        -:  362:        chain_index--;
        -:  363:      }
        -:  364:    }
        -:  365:#endif /* ENABLED (JERRY_DEBUGGER) */
        -:  366:  }
        -:  367:  else
        -:  368:  {
    #####:  369:    ecma_object_t *global_obj_p = ecma_builtin_get_global ();
    #####:  370:    ecma_ref_object (global_obj_p);
    #####:  371:    this_binding = ecma_make_object_value (global_obj_p);
    #####:  372:    lex_env_p = ecma_get_global_scope ();
        -:  373:  }
        -:  374:
    #####:  375:  ecma_ref_object (lex_env_p);
        -:  376:
    #####:  377:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0)
        -:  378:  {
    #####:  379:    ecma_object_t *strict_lex_env_p = ecma_create_decl_lex_env (lex_env_p);
        -:  380:
    #####:  381:    ecma_deref_object (lex_env_p);
    #####:  382:    lex_env_p = strict_lex_env_p;
        -:  383:  }
        -:  384:
    #####:  385:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED) != 0)
        -:  386:  {
    #####:  387:    ecma_object_t *lex_block_p = ecma_create_decl_lex_env (lex_env_p);
    #####:  388:    lex_block_p->type_flags_refs |= (uint16_t) ECMA_OBJECT_FLAG_BLOCK;
        -:  389:
    #####:  390:    ecma_deref_object (lex_env_p);
    #####:  391:    lex_env_p = lex_block_p;
        -:  392:  }
        -:  393:
    #####:  394:  ecma_value_t completion_value = vm_run (bytecode_data_p,
        -:  395:                                          this_binding,
        -:  396:                                          lex_env_p,
    #####:  397:                                          (parse_opts & ECMA_PARSE_DIRECT_EVAL) ? VM_DIRECT_EVAL : NULL,
        -:  398:                                          0);
        -:  399:
    #####:  400:  ecma_deref_object (lex_env_p);
    #####:  401:  ecma_free_value (this_binding);
        -:  402:
        -:  403:#if ENABLED (JERRY_SNAPSHOT_EXEC)
    #####:  404:  if (!(bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -:  405:  {
    #####:  406:    ecma_bytecode_deref (bytecode_data_p);
        -:  407:  }
        -:  408:#else /* !ENABLED (JERRY_SNAPSHOT_EXEC) */
    #####:  409:  ecma_bytecode_deref (bytecode_data_p);
        -:  410:#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */
        -:  411:
    #####:  412:  return completion_value;
        -:  413:} /* vm_run_eval */
        -:  414:
        -:  415:/**
        -:  416: * Construct object
        -:  417: *
        -:  418: * @return object value
        -:  419: */
        -:  420:static ecma_value_t
     1310:  421:vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  422:                             ecma_value_t lit_value) /**< literal */
        -:  423:{
        -:  424:  ecma_compiled_code_t *bytecode_p;
        -:  425:
        -:  426:#if ENABLED (JERRY_SNAPSHOT_EXEC)
    #####:  427:  if (JERRY_LIKELY (!(frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -:  428:  {
        -:  429:#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */
     1310:  430:    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -:  431:                                                  lit_value);
        -:  432:#if ENABLED (JERRY_SNAPSHOT_EXEC)
        -:  433:  }
        -:  434:  else
        -:  435:  {
    #####:  436:    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->bytecode_header_p) + lit_value;
    #####:  437:    bytecode_p = (ecma_compiled_code_t *) byte_p;
        -:  438:  }
        -:  439:#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */
        -:  440:
        -:  441:#if ENABLED (JERRY_BUILTIN_REGEXP)
     1310:  442:  if (!(bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION))
        -:  443:  {
    #####:  444:    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  445:
    #####:  446:    if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  447:    {
    #####:  448:      return ECMA_VALUE_ERROR;
        -:  449:    }
        -:  450:
    #####:  451:    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);;
        -:  452:  }
        -:  453:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
        -:  454:
     1310:  455:  JERRY_ASSERT (bytecode_p->status_flags & CBC_CODE_FLAGS_FUNCTION);
        -:  456:
        -:  457:  ecma_object_t *func_obj_p;
        -:  458:
        -:  459:#if ENABLED (JERRY_ES2015)
     1310:  460:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_ARROW_FUNCTION)
        -:  461:  {
    #####:  462:    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p,
        -:  463:                                                       bytecode_p,
        -:  464:                                                       frame_ctx_p->this_binding);
        -:  465:  }
     1310:  466:  else if (bytecode_p->status_flags & CBC_CODE_FLAGS_GENERATOR)
        -:  467:  {
    #####:  468:    func_obj_p = ecma_op_create_generator_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  469:  }
        -:  470:  else
        -:  471:  {
        -:  472:#endif /* ENABLED (JERRY_ES2015) */
     1310:  473:    func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  474:#if ENABLED (JERRY_ES2015)
        -:  475:  }
        -:  476:#endif /* ENABLED (JERRY_ES2015) */
        -:  477:
     1310:  478:  return ecma_make_object_value (func_obj_p);
        -:  479:} /* vm_construct_literal_object */
        -:  480:
        -:  481:/**
        -:  482: * Get implicit this value
        -:  483: *
        -:  484: * @return true - if the implicit 'this' value is updated,
        -:  485: *         false - otherwise
        -:  486: */
        -:  487:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  488:vm_get_implicit_this_value (ecma_value_t *this_value_p) /**< [in,out] this value */
        -:  489:{
    #####:  490:  if (ecma_is_value_object (*this_value_p))
        -:  491:  {
    #####:  492:    ecma_object_t *this_obj_p = ecma_get_object_from_value (*this_value_p);
        -:  493:
    #####:  494:    if (ecma_is_lexical_environment (this_obj_p))
        -:  495:    {
    #####:  496:      ecma_value_t completion_value = ecma_op_implicit_this_value (this_obj_p);
        -:  497:
    #####:  498:      JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion_value));
        -:  499:
    #####:  500:      *this_value_p = completion_value;
    #####:  501:      return true;
        -:  502:    }
        -:  503:  }
    #####:  504:  return false;
        -:  505:} /* vm_get_implicit_this_value */
        -:  506:
        -:  507:/**
        -:  508: * Special bytecode sequence for error handling while the vm_loop
        -:  509: * is preserved for an execute operation
        -:  510: */
        -:  511:static const uint8_t vm_error_byte_code_p[] =
        -:  512:{
        -:  513:  CBC_EXT_OPCODE, CBC_EXT_ERROR
        -:  514:};
        -:  515:
        -:  516:#if ENABLED (JERRY_ES2015)
        -:  517:/**
        -:  518: * 'super(...)' function call handler.
        -:  519: */
        -:  520:static void
    #####:  521:vm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  522:{
    #####:  523:  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);
    #####:  524:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  525:
    #####:  526:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;
    #####:  527:  uint8_t opcode = byte_code_p[-2];
        -:  528:  uint32_t arguments_list_len;
        -:  529:
    #####:  530:  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;
        -:  531:
    #####:  532:  ecma_collection_t *collection_p = NULL;
        -:  533:  ecma_value_t *arguments_p;
        -:  534:
    #####:  535:  if (spread_arguments)
        -:  536:  {
    #####:  537:    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
    #####:  538:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  539:    arguments_p = collection_p->buffer_p;
    #####:  540:    arguments_list_len = collection_p->item_count;
        -:  541:  }
        -:  542:  else
        -:  543:  {
    #####:  544:    arguments_list_len = byte_code_p[-1];
    #####:  545:    arguments_p = frame_ctx_p->stack_top_p;
        -:  546:  }
        -:  547:
    #####:  548:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
        -:  549:  ecma_value_t completion_value;
        -:  550:
    #####:  551:  ecma_property_t *prop_p = ecma_op_get_this_property (frame_ctx_p->lex_env_p);
        -:  552:
    #####:  553:  if (ecma_op_this_binding_is_initialized (prop_p))
        -:  554:  {
    #####:  555:    completion_value = ecma_raise_reference_error (ECMA_ERR_MSG ("Super constructor may only be called once"));
        -:  556:  }
    #####:  557:  else if (!ecma_is_constructor (func_value))
        -:  558:  {
    #####:  559:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG ("Class extends value is not a constructor."));
        -:  560:  }
        -:  561:  else
        -:  562:  {
    #####:  563:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
    #####:  564:    completion_value = ecma_op_function_construct (func_obj_p,
        -:  565:                                                   JERRY_CONTEXT (current_new_target),
        -:  566:                                                   arguments_p,
        -:  567:                                                   arguments_list_len);
        -:  568:
    #####:  569:    if (ecma_is_value_object (completion_value))
        -:  570:    {
    #####:  571:      ecma_value_t proto_value = ecma_op_object_get_by_magic_id (JERRY_CONTEXT (current_new_target),
        -:  572:                                                                 LIT_MAGIC_STRING_PROTOTYPE);
    #####:  573:      if (ECMA_IS_VALUE_ERROR (proto_value))
        -:  574:      {
    #####:  575:        ecma_free_value (completion_value);
    #####:  576:        completion_value = ECMA_VALUE_ERROR;
        -:  577:      }
    #####:  578:      else if (ecma_is_value_object (proto_value))
        -:  579:      {
    #####:  580:        ECMA_SET_POINTER (ecma_get_object_from_value (completion_value)->u2.prototype_cp,
        -:  581:                          ecma_get_object_from_value (proto_value));
        -:  582:      }
    #####:  583:      ecma_free_value (proto_value);
        -:  584:    }
        -:  585:  }
        -:  586:
        -:  587:  /* Free registers. */
    #####:  588:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  589:  {
    #####:  590:    ecma_fast_free_value (arguments_p[i]);
        -:  591:  }
        -:  592:
    #####:  593:  if (collection_p != NULL)
        -:  594:  {
    #####:  595:    ecma_collection_destroy (collection_p);
        -:  596:  }
        -:  597:
    #####:  598:  ecma_free_value (func_value);
        -:  599:
    #####:  600:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  601:  {
        -:  602:#if ENABLED (JERRY_DEBUGGER)
        -:  603:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  604:#endif /* ENABLED (JERRY_DEBUGGER) */
    #####:  605:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  606:  }
        -:  607:  else
        -:  608:  {
    #####:  609:    ecma_op_bind_this_value (prop_p, completion_value);
    #####:  610:    frame_ctx_p->this_binding = completion_value;
        -:  611:
    #####:  612:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  613:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  614:
    #####:  615:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  616:    {
    #####:  617:      ecma_fast_free_value (completion_value);
        -:  618:    }
    #####:  619:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  620:    {
    #####:  621:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  622:    }
        -:  623:    else
        -:  624:    {
    #####:  625:      ecma_fast_free_value (frame_ctx_p->block_result);
    #####:  626:      frame_ctx_p->block_result = completion_value;
        -:  627:    }
        -:  628:  }
    #####:  629:} /* vm_super_call */
        -:  630:
        -:  631:/**
        -:  632: * Perform one of the following call/construct operation with spreaded argument list
        -:  633: *   - f(...args)
        -:  634: *   - o.f(...args)
        -:  635: *   - new O(...args)
        -:  636: */
        -:  637:static void
    #####:  638:vm_spread_operation (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  639:{
    #####:  640:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  641:
    #####:  642:  uint8_t opcode = frame_ctx_p->byte_code_p[1];
        -:  643:  ecma_value_t completion_value;
    #####:  644:  ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
        -:  645:
    #####:  646:  ecma_collection_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  647:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
    #####:  648:  bool is_call_prop = opcode >= CBC_EXT_SPREAD_CALL_PROP;
        -:  649:
    #####:  650:  if (frame_ctx_p->byte_code_p[1] == CBC_EXT_SPREAD_NEW)
        -:  651:  {
    #####:  652:    if (!ecma_is_value_object (func_value)
    #####:  653:        || !ecma_object_is_constructor (ecma_get_object_from_value (func_value)))
        -:  654:    {
    #####:  655:      completion_value = ecma_raise_type_error (ECMA_ERR_MSG ("Expected a constructor."));
        -:  656:    }
        -:  657:    else
        -:  658:    {
    #####:  659:      ecma_object_t *constructor_obj_p = ecma_get_object_from_value (func_value);
        -:  660:
    #####:  661:      completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  662:                                                     constructor_obj_p,
    #####:  663:                                                     collection_p->buffer_p,
        -:  664:                                                     collection_p->item_count);
        -:  665:    }
        -:  666:  }
        -:  667:  else
        -:  668:  {
    #####:  669:    ecma_value_t this_value = is_call_prop ? frame_ctx_p->stack_top_p[-2] : ECMA_VALUE_UNDEFINED;
        -:  670:
    #####:  671:    if (!ecma_is_value_object (func_value)
    #####:  672:        || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  673:    {
    #####:  674:      completion_value = ecma_raise_type_error (ECMA_ERR_MSG ("Expected a function."));
        -:  675:    }
        -:  676:    else
        -:  677:    {
    #####:  678:      ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  679:
    #####:  680:      completion_value = ecma_op_function_call (func_obj_p,
        -:  681:                                                this_value,
    #####:  682:                                                collection_p->buffer_p,
        -:  683:                                                collection_p->item_count);
        -:  684:    }
        -:  685:
    #####:  686:    if (is_call_prop)
        -:  687:    {
    #####:  688:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
    #####:  689:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
        -:  690:    }
        -:  691:  }
        -:  692:
    #####:  693:  ecma_collection_free (collection_p);
    #####:  694:  ecma_free_value (func_value);
        -:  695:
    #####:  696:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  697:  {
        -:  698:#if ENABLED (JERRY_DEBUGGER)
        -:  699:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  700:#endif /* ENABLED (JERRY_DEBUGGER) */
    #####:  701:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  702:  }
        -:  703:  else
        -:  704:  {
    #####:  705:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  706:
    #####:  707:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  708:    {
    #####:  709:      ecma_fast_free_value (completion_value);
        -:  710:    }
    #####:  711:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  712:    {
    #####:  713:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  714:    }
        -:  715:    else
        -:  716:    {
    #####:  717:      ecma_fast_free_value (frame_ctx_p->block_result);
    #####:  718:      frame_ctx_p->block_result = completion_value;
        -:  719:    }
        -:  720:
        -:  721:    /* EXT_OPCODE, SPREAD_OPCODE, BYTE_ARG */
    #####:  722:    frame_ctx_p->byte_code_p += 3;
        -:  723:  }
    #####:  724:} /* vm_spread_operation */
        -:  725:#endif /* ENABLED (JERRY_ES2015) */
        -:  726:
        -:  727:/**
        -:  728: * 'Function call' opcode handler.
        -:  729: *
        -:  730: * See also: ECMA-262 v5, 11.2.3
        -:  731: */
        -:  732:static void
     2619:  733:opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  734:{
     2619:  735:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
     2619:  736:  uint8_t opcode = byte_code_p[-1];
        -:  737:  uint32_t arguments_list_len;
        -:  738:
     2619:  739:  if (opcode >= CBC_CALL0)
        -:  740:  {
     2619:  741:    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);
        -:  742:  }
        -:  743:  else
        -:  744:  {
    #####:  745:    arguments_list_len = *byte_code_p++;
        -:  746:  }
        -:  747:
     2619:  748:  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;
        -:  749:
     2619:  750:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
     2619:  751:  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;
     2619:  752:  ecma_value_t func_value = stack_top_p[-1];
        -:  753:  ecma_value_t completion_value;
        -:  754:
     2619:  755:  if (!ecma_is_value_object (func_value)
     2619:  756:      || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  757:  {
    #####:  758:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG ("Expected a function."));
        -:  759:  }
        -:  760:  else
        -:  761:  {
     2619:  762:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  763:
     2619:  764:    completion_value = ecma_op_function_call (func_obj_p,
        -:  765:                                              this_value,
        -:  766:                                              stack_top_p,
        -:  767:                                              arguments_list_len);
        -:  768:  }
        -:  769:
     2617:  770:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        -:  771:
        -:  772:  /* Free registers. */
     3925:  773:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  774:  {
     1308:  775:    ecma_fast_free_value (stack_top_p[i]);
        -:  776:  }
        -:  777:
     2617:  778:  if (is_call_prop)
        -:  779:  {
     1309:  780:    ecma_free_value (*(--stack_top_p));
     1309:  781:    ecma_free_value (*(--stack_top_p));
        -:  782:  }
        -:  783:
     2617:  784:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  785:  {
        -:  786:#if ENABLED (JERRY_DEBUGGER)
        -:  787:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  788:#endif /* ENABLED (JERRY_DEBUGGER) */
     1308:  789:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  790:  }
        -:  791:  else
        -:  792:  {
     1309:  793:    frame_ctx_p->byte_code_p = byte_code_p;
     1309:  794:    ecma_free_value (*(--stack_top_p));
     1309:  795:    uint32_t opcode_data = vm_decode_table[opcode];
        -:  796:
     1309:  797:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  798:    {
    #####:  799:      ecma_fast_free_value (completion_value);
        -:  800:    }
     1309:  801:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  802:    {
     1309:  803:      *stack_top_p++ = completion_value;
        -:  804:    }
        -:  805:    else
        -:  806:    {
    #####:  807:      ecma_fast_free_value (frame_ctx_p->block_result);
    #####:  808:      frame_ctx_p->block_result = completion_value;
        -:  809:    }
        -:  810:  }
        -:  811:
     2617:  812:  frame_ctx_p->stack_top_p = stack_top_p;
     2617:  813:} /* opfunc_call */
        -:  814:
        -:  815:/**
        -:  816: * 'Constructor call' opcode handler.
        -:  817: *
        -:  818: * See also: ECMA-262 v5, 11.2.2
        -:  819: */
        -:  820:static void
     1311:  821:opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  822:{
     1311:  823:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
     1311:  824:  uint8_t opcode = byte_code_p[-1];
        -:  825:  unsigned int arguments_list_len;
        -:  826:
     1311:  827:  if (opcode >= CBC_NEW0)
        -:  828:  {
     1311:  829:    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);
        -:  830:  }
        -:  831:  else
        -:  832:  {
    #####:  833:    arguments_list_len = *byte_code_p++;
        -:  834:  }
        -:  835:
     1311:  836:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
     1311:  837:  ecma_value_t constructor_value = stack_top_p[-1];
        -:  838:  ecma_value_t completion_value;
        -:  839:
     1311:  840:  if (!ecma_is_value_object (constructor_value)
     1311:  841:      || !ecma_object_is_constructor (ecma_get_object_from_value (constructor_value)))
        -:  842:  {
    #####:  843:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG ("Expected a constructor."));
        -:  844:  }
        -:  845:  else
        -:  846:  {
     1311:  847:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);
        -:  848:
     1311:  849:    completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  850:                                                   constructor_obj_p,
        -:  851:                                                   stack_top_p,
        -:  852:                                                   arguments_list_len);
        -:  853:  }
        -:  854:
        -:  855:  /* Free registers. */
     2619:  856:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  857:  {
     1309:  858:    ecma_fast_free_value (stack_top_p[i]);
        -:  859:  }
        -:  860:
     1310:  861:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  862:  {
        -:  863:#if ENABLED (JERRY_DEBUGGER)
        -:  864:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  865:#endif /* ENABLED (JERRY_DEBUGGER) */
    #####:  866:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  867:  }
        -:  868:  else
        -:  869:  {
     1310:  870:    ecma_free_value (stack_top_p[-1]);
     1310:  871:    frame_ctx_p->byte_code_p = byte_code_p;
     1310:  872:    stack_top_p[-1] = completion_value;
        -:  873:  }
        -:  874:
     1310:  875:  frame_ctx_p->stack_top_p = stack_top_p;
     1310:  876:} /* opfunc_construct */
        -:  877:
        -:  878:/**
        -:  879: * Read literal index from the byte code stream into destination.
        -:  880: *
        -:  881: * @param destination destination
        -:  882: */
        -:  883:#define READ_LITERAL_INDEX(destination) \
        -:  884:  do \
        -:  885:  { \
        -:  886:    (destination) = *byte_code_p++; \
        -:  887:    if ((destination) >= encoding_limit) \
        -:  888:    { \
        -:  889:      (destination) = (uint16_t) ((((destination) << 8) | *byte_code_p++) - encoding_delta); \
        -:  890:    } \
        -:  891:  } \
        -:  892:  while (0)
        -:  893:
        -:  894:/**
        -:  895: * Get literal value by literal index.
        -:  896: *
        -:  897: * @param literal_index literal index
        -:  898: * @param target_value target value
        -:  899: *
        -:  900: * TODO: For performance reasons, we define this as a macro.
        -:  901: * When we are able to construct a function with similar speed,
        -:  902: * we can remove this macro.
        -:  903: */
        -:  904:#define READ_LITERAL(literal_index, target_value) \
        -:  905:  do \
        -:  906:  { \
        -:  907:    if ((literal_index) < ident_end) \
        -:  908:    { \
        -:  909:      if ((literal_index) < register_end) \
        -:  910:      { \
        -:  911:        /* Note: There should be no specialization for arguments. */ \
        -:  912:        (target_value) = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index)); \
        -:  913:      } \
        -:  914:      else \
        -:  915:      { \
        -:  916:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]); \
        -:  917:        \
        -:  918:        result = ecma_op_resolve_reference_value (frame_ctx_p->lex_env_p, \
        -:  919:                                                  name_p); \
        -:  920:        \
        -:  921:        if (ECMA_IS_VALUE_ERROR (result)) \
        -:  922:        { \
        -:  923:          goto error; \
        -:  924:        } \
        -:  925:        (target_value) = result; \
        -:  926:      } \
        -:  927:    } \
        -:  928:    else if (literal_index < const_literal_end) \
        -:  929:    { \
        -:  930:      (target_value) = ecma_fast_copy_value (literal_start_p[literal_index]); \
        -:  931:    } \
        -:  932:    else \
        -:  933:    { \
        -:  934:      /* Object construction. */ \
        -:  935:      (target_value) = vm_construct_literal_object (frame_ctx_p, \
        -:  936:                                                    literal_start_p[literal_index]); \
        -:  937:    } \
        -:  938:  } \
        -:  939:  while (0)
        -:  940:
        -:  941:/**
        -:  942: * Run generic byte code.
        -:  943: *
        -:  944: * @return ecma value
        -:  945: */
        -:  946:static ecma_value_t JERRY_ATTR_NOINLINE
     5238:  947:vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  948:{
     5238:  949:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->bytecode_header_p;
     5238:  950:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;
     5238:  951:  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;
        -:  952:
     5238:  953:  ecma_value_t *stack_top_p;
        -:  954:  uint16_t encoding_limit;
        -:  955:  uint16_t encoding_delta;
        -:  956:  uint16_t register_end;
        -:  957:  uint16_t ident_end;
        -:  958:  uint16_t const_literal_end;
     5238:  959:  int32_t branch_offset = 0;
     5238:  960:  uint8_t branch_offset_length = 0;
        -:  961:  ecma_value_t left_value;
        -:  962:  ecma_value_t right_value;
     5238:  963:  ecma_value_t result = ECMA_VALUE_EMPTY;
     5238:  964:  bool is_strict = ((frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);
        -:  965:
        -:  966:  /* Prepare for byte code execution. */
     5238:  967:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -:  968:  {
     5238:  969:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
     5238:  970:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -:  971:  }
        -:  972:  else
        -:  973:  {
    #####:  974:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####:  975:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -:  976:  }
        -:  977:
     5238:  978:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  979:  {
    #####:  980:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);
    #####:  981:    register_end = args_p->register_end;
    #####:  982:    ident_end = args_p->ident_end;
    #####:  983:    const_literal_end = args_p->const_literal_end;
        -:  984:  }
        -:  985:  else
        -:  986:  {
     5238:  987:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);
     5238:  988:    register_end = args_p->register_end;
     5238:  989:    ident_end = args_p->ident_end;
     5238:  990:    const_literal_end = args_p->const_literal_end;
        -:  991:  }
        -:  992:
     5238:  993:  stack_top_p = frame_ctx_p->stack_top_p;
        -:  994:
        -:  995:  /* Outer loop for exception handling. */
    #####:  996:  while (true)
        -:  997:  {
        -:  998:    /* Internal loop for byte code execution. */
        -:  999:    while (true)
    28829: 1000:    {
    34067: 1001:      const uint8_t *byte_code_start_p = byte_code_p;
    34067: 1002:      uint8_t opcode = *byte_code_p++;
    34067: 1003:      uint32_t opcode_data = opcode;
        -: 1004:
    34067: 1005:      if (opcode == CBC_EXT_OPCODE)
        -: 1006:      {
     3928: 1007:        opcode = *byte_code_p++;
     3928: 1008:        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);
        -: 1009:      }
        -: 1010:
    34067: 1011:      opcode_data = vm_decode_table[opcode_data];
        -: 1012:
    34067: 1013:      left_value = ECMA_VALUE_UNDEFINED;
    34067: 1014:      right_value = ECMA_VALUE_UNDEFINED;
        -: 1015:
    34067: 1016:      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);
        -: 1017:
    34067: 1018:      if (operands >= VM_OC_GET_LITERAL)
        -: 1019:      {
        -: 1020:        uint16_t literal_index;
    10478: 1021:        READ_LITERAL_INDEX (literal_index);
    10478: 1022:        READ_LITERAL (literal_index, left_value);
        -: 1023:
    10478: 1024:        if (operands != VM_OC_GET_LITERAL)
        -: 1025:        {
     7858: 1026:          switch (operands)
        -: 1027:          {
     7858: 1028:            case VM_OC_GET_LITERAL_LITERAL:
        -: 1029:            {
        -: 1030:              uint16_t second_literal_index;
     7858: 1031:              READ_LITERAL_INDEX (second_literal_index);
     7858: 1032:              READ_LITERAL (second_literal_index, right_value);
     7858: 1033:              break;
        -: 1034:            }
    #####: 1035:            case VM_OC_GET_STACK_LITERAL:
        -: 1036:            {
    #####: 1037:              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1038:              right_value = left_value;
    #####: 1039:              left_value = *(--stack_top_p);
    #####: 1040:              break;
        -: 1041:            }
    #####: 1042:            default:
        -: 1043:            {
    #####: 1044:              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);
        -: 1045:
    #####: 1046:              right_value = left_value;
    #####: 1047:              left_value = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1048:              break;
        -: 1049:            }
        -: 1050:          }
     2620: 1051:        }
        -: 1052:      }
    23589: 1053:      else if (operands >= VM_OC_GET_STACK)
        -: 1054:      {
     5242: 1055:        JERRY_ASSERT (operands == VM_OC_GET_STACK
        -: 1056:                      || operands == VM_OC_GET_STACK_STACK);
        -: 1057:
     5242: 1058:        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
     5242: 1059:        left_value = *(--stack_top_p);
        -: 1060:
     5242: 1061:        if (operands == VM_OC_GET_STACK_STACK)
        -: 1062:        {
    #####: 1063:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1064:          right_value = left_value;
    #####: 1065:          left_value = *(--stack_top_p);
        -: 1066:        }
        -: 1067:      }
    18347: 1068:      else if (operands == VM_OC_GET_BRANCH)
        -: 1069:      {
     1309: 1070:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
     1309: 1071:        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 1072:
     1309: 1073:        branch_offset = *(byte_code_p++);
        -: 1074:
     1309: 1075:        if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 1076:        {
    #####: 1077:          branch_offset <<= 8;
    #####: 1078:          branch_offset |= *(byte_code_p++);
        -: 1079:
    #####: 1080:          if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 1081:          {
    #####: 1082:            branch_offset <<= 8;
    #####: 1083:            branch_offset |= *(byte_code_p++);
        -: 1084:          }
        -: 1085:        }
        -: 1086:
     1309: 1087:        if (opcode_data & VM_OC_BACKWARD_BRANCH)
        -: 1088:        {
        -: 1089:#if ENABLED (JERRY_VM_EXEC_STOP)
    #####: 1090:          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL
    #####: 1091:              && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)
        -: 1092:          {
    #####: 1093:            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));
        -: 1094:
    #####: 1095:            if (ecma_is_value_undefined (result))
        -: 1096:            {
    #####: 1097:              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);
        -: 1098:            }
        -: 1099:            else
        -: 1100:            {
    #####: 1101:              JERRY_CONTEXT (vm_exec_stop_counter) = 1;
        -: 1102:
    #####: 1103:              if (ecma_is_value_error_reference (result))
        -: 1104:              {
    #####: 1105:                ecma_raise_error_from_error_reference (result);
        -: 1106:              }
        -: 1107:              else
        -: 1108:              {
    #####: 1109:                jcontext_raise_exception (result);
        -: 1110:              }
        -: 1111:
    #####: 1112:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 1113:              jcontext_set_abort_flag (true);
    #####: 1114:              result = ECMA_VALUE_ERROR;
    #####: 1115:              goto error;
        -: 1116:            }
        -: 1117:          }
        -: 1118:#endif /* ENABLED (JERRY_VM_EXEC_STOP) */
        -: 1119:
    #####: 1120:          branch_offset = -branch_offset;
        -: 1121:        }
        -: 1122:      }
        -: 1123:
    34067: 1124:      switch (VM_OC_GROUP_GET_INDEX (opcode_data))
        -: 1125:      {
    #####: 1126:        case VM_OC_POP:
        -: 1127:        {
    #####: 1128:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1129:          ecma_free_value (*(--stack_top_p));
    #####: 1130:          continue;
        -: 1131:        }
    #####: 1132:        case VM_OC_POP_BLOCK:
        -: 1133:        {
    #####: 1134:          ecma_fast_free_value (frame_ctx_p->block_result);
    #####: 1135:          frame_ctx_p->block_result = *(--stack_top_p);
    #####: 1136:          continue;
        -: 1137:        }
        3: 1138:        case VM_OC_PUSH:
        -: 1139:        {
        3: 1140:          *stack_top_p++ = left_value;
        3: 1141:          continue;
        -: 1142:        }
     2619: 1143:        case VM_OC_PUSH_TWO:
        -: 1144:        {
     2619: 1145:          *stack_top_p++ = left_value;
     2619: 1146:          *stack_top_p++ = right_value;
     2619: 1147:          continue;
        -: 1148:        }
     1310: 1149:        case VM_OC_PUSH_THREE:
        -: 1150:        {
        -: 1151:          uint16_t literal_index;
        -: 1152:
     1310: 1153:          *stack_top_p++ = left_value;
     1310: 1154:          left_value = ECMA_VALUE_UNDEFINED;
        -: 1155:
     1310: 1156:          READ_LITERAL_INDEX (literal_index);
     1310: 1157:          READ_LITERAL (literal_index, left_value);
        -: 1158:
     1310: 1159:          *stack_top_p++ = right_value;
     1310: 1160:          *stack_top_p++ = left_value;
     1310: 1161:          continue;
        -: 1162:        }
    #####: 1163:        case VM_OC_PUSH_UNDEFINED:
        -: 1164:        {
    #####: 1165:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 1166:          continue;
        -: 1167:        }
    #####: 1168:        case VM_OC_PUSH_TRUE:
        -: 1169:        {
    #####: 1170:          *stack_top_p++ = ECMA_VALUE_TRUE;
    #####: 1171:          continue;
        -: 1172:        }
    #####: 1173:        case VM_OC_PUSH_FALSE:
        -: 1174:        {
    #####: 1175:          *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 1176:          continue;
        -: 1177:        }
    #####: 1178:        case VM_OC_PUSH_NULL:
        -: 1179:        {
    #####: 1180:          *stack_top_p++ = ECMA_VALUE_NULL;
    #####: 1181:          continue;
        -: 1182:        }
    #####: 1183:        case VM_OC_PUSH_THIS:
        -: 1184:        {
    #####: 1185:          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1186:          continue;
        -: 1187:        }
        1: 1188:        case VM_OC_PUSH_0:
        -: 1189:        {
        1: 1190:          *stack_top_p++ = ecma_make_integer_value (0);
        1: 1191:          continue;
        -: 1192:        }
    #####: 1193:        case VM_OC_PUSH_POS_BYTE:
        -: 1194:        {
    #####: 1195:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1196:          *stack_top_p++ = ecma_make_integer_value (number + 1);
    #####: 1197:          continue;
        -: 1198:        }
    #####: 1199:        case VM_OC_PUSH_NEG_BYTE:
        -: 1200:        {
    #####: 1201:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1202:          *stack_top_p++ = ecma_make_integer_value (-(number + 1));
    #####: 1203:          continue;
        -: 1204:        }
    #####: 1205:        case VM_OC_PUSH_LIT_0:
        -: 1206:        {
    #####: 1207:          stack_top_p[0] = left_value;
    #####: 1208:          stack_top_p[1] = ecma_make_integer_value (0);
    #####: 1209:          stack_top_p += 2;
    #####: 1210:          continue;
        -: 1211:        }
    #####: 1212:        case VM_OC_PUSH_LIT_POS_BYTE:
        -: 1213:        {
    #####: 1214:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1215:          stack_top_p[0] = left_value;
    #####: 1216:          stack_top_p[1] = ecma_make_integer_value (number + 1);
    #####: 1217:          stack_top_p += 2;
    #####: 1218:          continue;
        -: 1219:        }
    #####: 1220:        case VM_OC_PUSH_LIT_NEG_BYTE:
        -: 1221:        {
    #####: 1222:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1223:          stack_top_p[0] = left_value;
    #####: 1224:          stack_top_p[1] = ecma_make_integer_value (-(number + 1));
    #####: 1225:          stack_top_p += 2;
    #####: 1226:          continue;
        -: 1227:        }
        1: 1228:        case VM_OC_PUSH_OBJECT:
        -: 1229:        {
        1: 1230:          ecma_object_t *obj_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE),
        -: 1231:                                                     0,
        -: 1232:                                                     ECMA_OBJECT_TYPE_GENERAL);
        -: 1233:
        1: 1234:          *stack_top_p++ = ecma_make_object_value (obj_p);
        1: 1235:          continue;
        -: 1236:        }
    #####: 1237:        case VM_OC_PUSH_NAMED_FUNC_EXPR:
        -: 1238:        {
    #####: 1239:          ecma_object_t *func_p = ecma_get_object_from_value (left_value);
        -: 1240:
    #####: 1241:          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);
        -: 1242:
    #####: 1243:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
        -: 1244:
    #####: 1245:          JERRY_ASSERT (frame_ctx_p->lex_env_p ==
        -: 1246:                        ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));
        -: 1247:
    #####: 1248:          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1249:
    #####: 1250:          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);
        -: 1251:
    #####: 1252:          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);
        -: 1253:
    #####: 1254:          ecma_free_value (right_value);
    #####: 1255:          ecma_deref_object (name_lex_env);
    #####: 1256:          *stack_top_p++ = left_value;
    #####: 1257:          continue;
        -: 1258:        }
     2629: 1259:        case VM_OC_CREATE_BINDING:
        -: 1260:        {
        -: 1261:#if !ENABLED (JERRY_ES2015)
    #####: 1262:          JERRY_ASSERT (opcode == CBC_CREATE_VAR);
        -: 1263:#endif /* !ENABLED (JERRY_ES2015) */
        -: 1264:
        -: 1265:          uint32_t literal_index;
        -: 1266:
     2629: 1267:          READ_LITERAL_INDEX (literal_index);
        -: 1268:
     2629: 1269:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1270:
     2629: 1271:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
     2629: 1272:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1273:
     2629: 1274:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1275:
        -: 1276:#if ENABLED (JERRY_ES2015)
     2629: 1277:          if (opcode == CBC_CREATE_LET)
        -: 1278:          {
    #####: 1279:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1280:          }
     2629: 1281:          else if (opcode == CBC_CREATE_CONST)
        -: 1282:          {
    #####: 1283:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1284:          }
        -: 1285:
        -: 1286:          ecma_property_value_t *property_value_p;
     2629: 1287:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1288:
     2629: 1289:          if (opcode != CBC_CREATE_VAR)
        -: 1290:          {
    #####: 1291:            property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 1292:          }
        -: 1293:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1294:          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1295:#endif /* ENABLED (JERRY_ES2015) */
        -: 1296:
     2629: 1297:          continue;
        -: 1298:        }
        1: 1299:        case VM_OC_VAR_EVAL:
        -: 1300:        {
        -: 1301:          uint32_t literal_index;
        1: 1302:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1303:
        1: 1304:          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)
        -: 1305:          {
        -: 1306:            uint32_t value_index;
        1: 1307:            READ_LITERAL_INDEX (value_index);
        -: 1308:
        1: 1309:            lit_value = vm_construct_literal_object (frame_ctx_p,
        1: 1310:                                                     literal_start_p[value_index]);
        -: 1311:          }
        -: 1312:
        1: 1313:          READ_LITERAL_INDEX (literal_index);
        -: 1314:
        1: 1315:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        1: 1316:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1317:
        2: 1318:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1319:          {
        -: 1320:  #if ENABLED (JERRY_ES2015) && !(defined JERRY_NDEBUG)
    #####: 1321:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1322:            {
    #####: 1323:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1324:
    #####: 1325:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1326:            }
        -: 1327:  #endif /* ENABLED (JERRY_ES2015) && !JERRY_NDEBUG */
        -: 1328:
    #####: 1329:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1330:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1331:          }
        -: 1332:
        -: 1333:  #if ENABLED (JERRY_ES2015) && !(defined JERRY_NDEBUG)
        1: 1334:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1335:          {
    #####: 1336:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1337:
    #####: 1338:            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1339:          }
        -: 1340:  #endif /* ENABLED (JERRY_ES2015) && !JERRY_NDEBUG */
        -: 1341:
        1: 1342:          result = vm_var_decl (lex_env_p, name_p, frame_ctx_p->is_eval_code);
        -: 1343:
        1: 1344:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1345:          {
    #####: 1346:            goto error;
        -: 1347:          }
        -: 1348:
        1: 1349:          if (lit_value != ECMA_VALUE_UNDEFINED)
        -: 1350:          {
        1: 1351:            result = vm_set_var (lex_env_p, name_p, is_strict, lit_value);
        -: 1352:
        1: 1353:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1354:            {
    #####: 1355:              goto error;
        -: 1356:            }
        -: 1357:          }
        -: 1358:
        1: 1359:          continue;
        -: 1360:        }
        -: 1361:#if ENABLED (JERRY_SNAPSHOT_EXEC)
    #####: 1362:        case VM_OC_SET_BYTECODE_PTR:
        -: 1363:        {
    #####: 1364:          memcpy (&byte_code_p, byte_code_p++, sizeof (uint8_t *));
    #####: 1365:          frame_ctx_p->byte_code_start_p = byte_code_p;
    #####: 1366:          continue;
        -: 1367:        }
        -: 1368:#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */
     5236: 1369:        case VM_OC_INIT_ARG_OR_FUNC:
        -: 1370:        {
        -: 1371:          uint32_t literal_index, value_index;
        -: 1372:          ecma_value_t lit_value;
        -: 1373:
     5236: 1374:          READ_LITERAL_INDEX (value_index);
     5236: 1375:          READ_LITERAL_INDEX (literal_index);
        -: 1376:
     5236: 1377:          JERRY_ASSERT (value_index != literal_index);
     5236: 1378:          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);
        -: 1379:
     5236: 1380:          if (value_index < register_end)
        -: 1381:          {
        -: 1382:            /* Take (not copy) the reference. */
     3927: 1383:            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));
        -: 1384:          }
        -: 1385:          else
        -: 1386:          {
     1309: 1387:            lit_value = vm_construct_literal_object (frame_ctx_p,
     1309: 1388:                                                     literal_start_p[value_index]);
        -: 1389:          }
        -: 1390:
     5236: 1391:          if (literal_index < register_end)
        -: 1392:          {
    #####: 1393:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 1394:            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;
    #####: 1395:            continue;
        -: 1396:          }
        -: 1397:
     5236: 1398:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1399:
     5236: 1400:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
     5236: 1401:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1402:
        -: 1403:          ecma_property_value_t *property_value_p;
     5236: 1404:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,
        -: 1405:                                                              name_p,
        -: 1406:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1407:                                                              NULL);
        -: 1408:
     5236: 1409:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
     5236: 1410:          property_value_p->value = lit_value;
        -: 1411:
     5236: 1412:          if (value_index >= register_end)
        -: 1413:          {
     1309: 1414:            ecma_free_value (lit_value);
        -: 1415:          }
        -: 1416:
     5236: 1417:          continue;
        -: 1418:        }
        -: 1419:#if ENABLED (JERRY_ES2015)
        1: 1420:        case VM_OC_CHECK_VAR:
        -: 1421:        {
        1: 1422:          JERRY_ASSERT (ecma_get_global_scope () == frame_ctx_p->lex_env_p);
        -: 1423:
        -: 1424:          uint32_t literal_index;
        1: 1425:          READ_LITERAL_INDEX (literal_index);
        -: 1426:
        1: 1427:          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)
        -: 1428:          {
        1: 1429:            continue;
        -: 1430:          }
        -: 1431:
    #####: 1432:          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1433:          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);
        -: 1434:
    #####: 1435:          if (binding_p != NULL)
        -: 1436:          {
    #####: 1437:            result = ecma_raise_syntax_error (ECMA_ERR_MSG ("Local variable is redeclared."));
    #####: 1438:            goto error;
        -: 1439:          }
        -: 1440:
    #####: 1441:          continue;
        -: 1442:        }
    #####: 1443:        case VM_OC_CHECK_LET:
        -: 1444:        {
    #####: 1445:          JERRY_ASSERT (ecma_get_global_scope () == frame_ctx_p->lex_env_p);
        -: 1446:
        -: 1447:          uint32_t literal_index;
    #####: 1448:          READ_LITERAL_INDEX (literal_index);
        -: 1449:
    #####: 1450:          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1451:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1452:          ecma_property_t *binding_p = NULL;
        -: 1453:
    #####: 1454:          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1455:          {
    #####: 1456:            binding_p = ecma_find_named_property (lex_env_p, literal_name_p);
        -: 1457:
    #####: 1458:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1459:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1460:          }
        -: 1461:
    #####: 1462:          if (binding_p != NULL)
        -: 1463:          {
    #####: 1464:            result = ecma_raise_syntax_error (ECMA_ERR_MSG ("Local variable is redeclared."));
    #####: 1465:            goto error;
        -: 1466:          }
        -: 1467:
    #####: 1468:          result = ecma_op_has_binding (lex_env_p, literal_name_p);
        -: 1469:
        -: 1470:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 1471:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1472:          {
    #####: 1473:            goto error;
        -: 1474:          }
        -: 1475:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1476:
    #####: 1477:          if (ecma_is_value_true (result))
        -: 1478:          {
    #####: 1479:            result = ecma_raise_syntax_error (ECMA_ERR_MSG ("Local variable is redeclared."));
    #####: 1480:            goto error;
        -: 1481:          }
        -: 1482:
    #####: 1483:          continue;
        -: 1484:        }
    #####: 1485:        case VM_OC_ASSIGN_LET_CONST:
        -: 1486:        {
        -: 1487:          uint32_t literal_index;
    #####: 1488:          READ_LITERAL_INDEX (literal_index);
        -: 1489:
    #####: 1490:          JERRY_ASSERT (literal_index >= register_end);
    #####: 1491:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1492:
    #####: 1493:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1494:          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);
        -: 1495:
    #####: 1496:          JERRY_ASSERT (property_p != NULL
        -: 1497:                        && ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA);
    #####: 1498:          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);
        -: 1499:
    #####: 1500:          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;
        -: 1501:
    #####: 1502:          if (ecma_is_value_object (left_value))
        -: 1503:          {
    #####: 1504:            ecma_deref_object (ecma_get_object_from_value (left_value));
        -: 1505:          }
    #####: 1506:          continue;
        -: 1507:        }
    #####: 1508:        case VM_OC_INIT_BINDING:
        -: 1509:        {
        -: 1510:          uint32_t literal_index;
        -: 1511:
    #####: 1512:          READ_LITERAL_INDEX (literal_index);
        -: 1513:
    #####: 1514:          JERRY_ASSERT (literal_index >= register_end);
        -: 1515:
    #####: 1516:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1517:
    #####: 1518:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1519:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1520:
    #####: 1521:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1522:
    #####: 1523:          if (opcode == CBC_INIT_LET)
        -: 1524:          {
    #####: 1525:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1526:          }
    #####: 1527:          else if (opcode == CBC_INIT_CONST)
        -: 1528:          {
    #####: 1529:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1530:          }
        -: 1531:
        -: 1532:          ecma_property_value_t *property_value_p;
    #####: 1533:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,
        -: 1534:                                                              name_p,
        -: 1535:                                                              prop_attributes,
        -: 1536:                                                              NULL);
        -: 1537:
    #####: 1538:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -: 1539:
    #####: 1540:          ecma_value_t value = *(--stack_top_p);
        -: 1541:
    #####: 1542:          property_value_p->value = value;
    #####: 1543:          ecma_deref_if_object (value);
    #####: 1544:          continue;
        -: 1545:        }
    #####: 1546:        case VM_OC_THROW_CONST_ERROR:
        -: 1547:        {
    #####: 1548:          result = ecma_raise_type_error (ECMA_ERR_MSG ("Constant bindings cannot be reassigned."));
    #####: 1549:          goto error;
        -: 1550:        }
     1309: 1551:        case VM_OC_COPY_TO_GLOBAL:
        -: 1552:        {
        -: 1553:          uint32_t literal_index;
     1309: 1554:          READ_LITERAL_INDEX (literal_index);
        -: 1555:
     1309: 1556:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
     1309: 1557:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1558:
     3927: 1559:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1560:          {
        -: 1561:#ifndef JERRY_NDEBUG
     1309: 1562:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1563:            {
     1309: 1564:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1565:
     1309: 1566:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1567:            }
        -: 1568:#endif /* !JERRY_NDEBUG */
        -: 1569:
     1309: 1570:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
     1309: 1571:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1572:          }
        -: 1573:
     1309: 1574:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1575:          {
     1309: 1576:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1577:            ecma_property_value_t *prop_value_p;
        -: 1578:
     1309: 1579:            if (property_p == NULL)
        -: 1580:            {
    #####: 1581:              prop_value_p = ecma_create_named_data_property (lex_env_p,
        -: 1582:                                                              name_p,
        -: 1583:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1584:                                                              NULL);
        -: 1585:            }
        -: 1586:            else
        -: 1587:            {
        -: 1588:#ifndef JERRY_NDEBUG
     1309: 1589:              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1590:#endif /* !JERRY_NDEBUG */
     1309: 1591:              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1592:            }
        -: 1593:
     1309: 1594:            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);
        -: 1595:          }
        -: 1596:          else
        -: 1597:          {
    #####: 1598:            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);
        -: 1599:
    #####: 1600:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1601:            {
    #####: 1602:              goto error;
        -: 1603:            }
        -: 1604:          }
        -: 1605:
     1309: 1606:          goto free_left_value;
        -: 1607:        }
    #####: 1608:        case VM_OC_CLONE_CONTEXT:
        -: 1609:        {
    #####: 1610:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1611:
    #####: 1612:          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);
    #####: 1613:          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);
    #####: 1614:          continue;
        -: 1615:        }
    #####: 1616:        case VM_OC_SET__PROTO__:
        -: 1617:        {
    #####: 1618:          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);
    #####: 1619:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1620:          {
    #####: 1621:            goto error;
        -: 1622:          }
    #####: 1623:          goto free_left_value;
        -: 1624:        }
    #####: 1625:        case VM_OC_SET_COMPUTED_PROPERTY:
        -: 1626:        {
        -: 1627:          /* Swap values. */
    #####: 1628:          left_value ^= right_value;
    #####: 1629:          right_value ^= left_value;
    #####: 1630:          left_value ^= right_value;
        -: 1631:          /* FALLTHRU */
        -: 1632:        }
        -: 1633:#endif /* ENABLED (JERRY_ES2015) */
        2: 1634:        case VM_OC_SET_PROPERTY:
        -: 1635:        {
        -: 1636:          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,
        -: 1637:                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);
        -: 1638:
        2: 1639:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1640:
        2: 1641:          ecma_string_t *prop_name_p = ecma_op_to_prop_name (right_value);
        -: 1642:
        2: 1643:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1644:          {
    #####: 1645:            result = ECMA_VALUE_ERROR;
    #####: 1646:            goto error;
        -: 1647:          }
        -: 1648:
        -: 1649:#if ENABLED (JERRY_ES2015)
        2: 1650:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1651:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1652:          {
    #####: 1653:            result = ecma_raise_type_error (ECMA_ERR_MSG ("prototype property of a class is non-configurable"));
    #####: 1654:            goto error;
        -: 1655:          }
        -: 1656:
        2: 1657:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1658:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1659:          const int index = -1;
        -: 1660:#endif /* ENABLED (JERRY_ES2015) */
        -: 1661:
        2: 1662:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);
        -: 1663:
        2: 1664:          JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -: 1665:
        2: 1666:          ecma_property_t *property_p = ecma_find_named_property (object_p, prop_name_p);
        -: 1667:
        2: 1668:          if (property_p != NULL
    #####: 1669:              && ECMA_PROPERTY_GET_TYPE (*property_p) != ECMA_PROPERTY_TYPE_NAMEDDATA)
        -: 1670:          {
    #####: 1671:            ecma_delete_property (object_p, ECMA_PROPERTY_VALUE_PTR (property_p));
    #####: 1672:            property_p = NULL;
        -: 1673:          }
        -: 1674:
        -: 1675:          ecma_property_value_t *prop_value_p;
        -: 1676:
        2: 1677:          if (property_p == NULL)
        -: 1678:          {
        2: 1679:            prop_value_p = ecma_create_named_data_property (object_p,
        -: 1680:                                                            prop_name_p,
        -: 1681:                                                            ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 1682:                                                            NULL);
        -: 1683:          }
        -: 1684:          else
        -: 1685:          {
    #####: 1686:            prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1687:          }
        -: 1688:
        2: 1689:          ecma_named_data_property_assign_value (object_p, prop_value_p, left_value);
        -: 1690:
        2: 1691:          ecma_deref_ecma_string (prop_name_p);
        -: 1692:
        2: 1693:          goto free_both_values;
        -: 1694:        }
    #####: 1695:        case VM_OC_SET_GETTER:
        -: 1696:        case VM_OC_SET_SETTER:
        -: 1697:        {
    #####: 1698:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1699:
    #####: 1700:          ecma_string_t *prop_name_p = ecma_op_to_prop_name (left_value);
        -: 1701:
    #####: 1702:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1703:          {
    #####: 1704:            result = ECMA_VALUE_ERROR;
    #####: 1705:            goto error;
        -: 1706:          }
        -: 1707:
        -: 1708:#if ENABLED (JERRY_ES2015)
    #####: 1709:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1710:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1711:          {
    #####: 1712:            result = ecma_raise_type_error (ECMA_ERR_MSG ("prototype property of a class is non-configurable"));
    #####: 1713:            goto error;
        -: 1714:          }
        -: 1715:
    #####: 1716:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1717:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1718:          const int index = -1;
        -: 1719:#endif /* ENABLED (JERRY_ES2015) */
        -: 1720:
    #####: 1721:          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,
    #####: 1722:                               stack_top_p[index],
        -: 1723:                               prop_name_p,
        -: 1724:                               right_value);
        -: 1725:
    #####: 1726:          ecma_deref_ecma_string (prop_name_p);
        -: 1727:
    #####: 1728:          goto free_both_values;
        -: 1729:        }
        2: 1730:        case VM_OC_PUSH_ARRAY:
        -: 1731:        {
        -: 1732:          // Note: this operation cannot throw an exception
        2: 1733:          *stack_top_p++ = ecma_make_object_value (ecma_op_new_fast_array_object (0));
        2: 1734:          continue;
        -: 1735:        }
        -: 1736:#if ENABLED (JERRY_ES2015)
     1309: 1737:        case VM_OC_LOCAL_EVAL:
        -: 1738:        {
     1309: 1739:          ECMA_CLEAR_LOCAL_PARSE_OPTS ();
     1309: 1740:          uint8_t parse_opts = *byte_code_p++;
     1309: 1741:          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);
     1309: 1742:          continue;
        -: 1743:        }
    #####: 1744:        case VM_OC_SUPER_CALL:
        -: 1745:        {
    #####: 1746:          uint8_t arguments_list_len = *byte_code_p++;
        -: 1747:
    #####: 1748:          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)
        -: 1749:          {
    #####: 1750:            stack_top_p -= arguments_list_len;
    #####: 1751:            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 1752:
    #####: 1753:            if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 1754:            {
    #####: 1755:              result = ECMA_VALUE_ERROR;
    #####: 1756:              goto error;
        -: 1757:            }
        -: 1758:
    #####: 1759:            stack_top_p++;
    #####: 1760:            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 1761:          }
        -: 1762:          else
        -: 1763:          {
    #####: 1764:            stack_top_p -= arguments_list_len;
        -: 1765:          }
        -: 1766:
    #####: 1767:          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;
    #####: 1768:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 1769:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 1770:          return ECMA_VALUE_UNDEFINED;
        -: 1771:        }
    #####: 1772:        case VM_OC_PUSH_CLASS_ENVIRONMENT:
        -: 1773:        {
    #####: 1774:          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, left_value);
    #####: 1775:          goto free_left_value;
        -: 1776:        }
    #####: 1777:        case VM_OC_PUSH_IMPLICIT_CTOR:
        -: 1778:        {
    #####: 1779:          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode);
    #####: 1780:          continue;
        -: 1781:        }
    #####: 1782:        case VM_OC_INIT_CLASS:
        -: 1783:        {
    #####: 1784:          result = opfunc_init_class (frame_ctx_p, stack_top_p);
        -: 1785:
    #####: 1786:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1787:          {
    #####: 1788:            goto error;
        -: 1789:          }
    #####: 1790:          continue;
        -: 1791:        }
    #####: 1792:        case VM_OC_FINALIZE_CLASS:
        -: 1793:        {
    #####: 1794:          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);
    #####: 1795:          goto free_left_value;
        -: 1796:        }
    #####: 1797:        case VM_OC_PUSH_SUPER_CONSTRUCTOR:
        -: 1798:        {
    #####: 1799:          result = ecma_op_function_get_super_constructor (JERRY_CONTEXT (current_function_obj_p));
        -: 1800:
    #####: 1801:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1802:          {
    #####: 1803:            goto error;
        -: 1804:          }
        -: 1805:
    #####: 1806:          *stack_top_p++ = result;
    #####: 1807:          continue;
        -: 1808:        }
    #####: 1809:        case VM_OC_RESOLVE_LEXICAL_THIS:
        -: 1810:        {
    #####: 1811:          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);
        -: 1812:
    #####: 1813:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1814:          {
    #####: 1815:            goto error;
        -: 1816:          }
        -: 1817:
    #####: 1818:          *stack_top_p++ = result;
    #####: 1819:          continue;
        -: 1820:        }
    #####: 1821:        case VM_OC_SUPER_REFERENCE:
        -: 1822:        {
    #####: 1823:          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);
        -: 1824:
    #####: 1825:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1826:          {
    #####: 1827:            goto error;
        -: 1828:          }
        -: 1829:
    #####: 1830:          goto free_left_value;
        -: 1831:        }
    #####: 1832:        case VM_OC_PUSH_SPREAD_ELEMENT:
        -: 1833:        {
    #####: 1834:          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;
    #####: 1835:          continue;
        -: 1836:        }
    #####: 1837:        case VM_OC_GET_ITERATOR:
        -: 1838:        {
    #####: 1839:          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_EMPTY);
        -: 1840:
    #####: 1841:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1842:          {
    #####: 1843:            goto error;
        -: 1844:          }
        -: 1845:
    #####: 1846:          *stack_top_p++ = result;
    #####: 1847:          continue;
        -: 1848:        }
    #####: 1849:        case VM_OC_ITERATOR_STEP:
        -: 1850:        {
    #####: 1851:          JERRY_ASSERT (opcode >= CBC_EXT_ITERATOR_STEP && opcode <= CBC_EXT_ITERATOR_STEP_3);
    #####: 1852:          const uint8_t index = (uint8_t) (1 + (opcode - CBC_EXT_ITERATOR_STEP));
    #####: 1853:          result = ecma_op_iterator_step (stack_top_p[-index]);
        -: 1854:
    #####: 1855:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1856:          {
    #####: 1857:            goto error;
        -: 1858:          }
        -: 1859:
    #####: 1860:          ecma_value_t value = ECMA_VALUE_UNDEFINED;
        -: 1861:
    #####: 1862:          if (!ecma_is_value_false (result))
        -: 1863:          {
    #####: 1864:            value = ecma_op_iterator_value (result);
    #####: 1865:            ecma_free_value (result);
        -: 1866:
    #####: 1867:            if (ECMA_IS_VALUE_ERROR (value))
        -: 1868:            {
    #####: 1869:              result = value;
    #####: 1870:              goto error;
        -: 1871:            }
        -: 1872:          }
        -: 1873:
    #####: 1874:          *stack_top_p++ = value;
    #####: 1875:          continue;
        -: 1876:        }
    #####: 1877:        case VM_OC_ITERATOR_CLOSE:
        -: 1878:        {
    #####: 1879:          result = ecma_op_iterator_close (left_value);
        -: 1880:
    #####: 1881:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1882:          {
    #####: 1883:            goto error;
        -: 1884:          }
        -: 1885:
    #####: 1886:          goto free_left_value;
        -: 1887:        }
    #####: 1888:        case VM_OC_DEFAULT_INITIALIZER:
        -: 1889:        {
    #####: 1890:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 1891:
    #####: 1892:          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)
        -: 1893:          {
    #####: 1894:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 1895:            continue;
        -: 1896:          }
        -: 1897:
    #####: 1898:          stack_top_p--;
    #####: 1899:          continue;
        -: 1900:        }
    #####: 1901:        case VM_OC_REST_INITIALIZER:
        -: 1902:        {
    #####: 1903:          JERRY_ASSERT (opcode >= CBC_EXT_REST_INITIALIZER && opcode <= CBC_EXT_REST_INITIALIZER_3);
    #####: 1904:          const uint8_t iterator_index = (uint8_t) (1 + (opcode - CBC_EXT_REST_INITIALIZER));
    #####: 1905:          ecma_object_t *array_p = ecma_op_new_fast_array_object (0);
    #####: 1906:          ecma_value_t iterator = stack_top_p[-iterator_index];
    #####: 1907:          uint32_t index = 0;
        -: 1908:
        -: 1909:          while (true)
    #####: 1910:          {
    #####: 1911:            result = ecma_op_iterator_step (iterator);
        -: 1912:
    #####: 1913:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1914:            {
    #####: 1915:              ecma_deref_object (array_p);
    #####: 1916:              goto error;
        -: 1917:            }
        -: 1918:
    #####: 1919:            if (ecma_is_value_false (result))
        -: 1920:            {
    #####: 1921:              break;
        -: 1922:            }
        -: 1923:
    #####: 1924:            ecma_value_t value = ecma_op_iterator_value (result);
    #####: 1925:            ecma_free_value (result);
        -: 1926:
    #####: 1927:            if (ECMA_IS_VALUE_ERROR (value))
        -: 1928:            {
    #####: 1929:              ecma_deref_object (array_p);
    #####: 1930:              result = value;
    #####: 1931:              goto error;
        -: 1932:            }
        -: 1933:
    #####: 1934:            bool set_result = ecma_fast_array_set_property (array_p, index++, value);
    #####: 1935:            JERRY_ASSERT (set_result);
    #####: 1936:            ecma_free_value (value);
        -: 1937:          }
        -: 1938:
    #####: 1939:          *stack_top_p++ = ecma_make_object_value (array_p);
    #####: 1940:          continue;
        -: 1941:        }
    #####: 1942:        case VM_OC_INITIALIZER_PUSH_PROP:
        -: 1943:        {
    #####: 1944:          result = vm_op_get_value (stack_top_p[-1], left_value);
        -: 1945:
    #####: 1946:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1947:          {
    #####: 1948:            goto error;
        -: 1949:          }
        -: 1950:
    #####: 1951:          *stack_top_p++ = result;
    #####: 1952:          goto free_left_value;
        -: 1953:        }
    #####: 1954:        case VM_OC_SPREAD_ARGUMENTS:
        -: 1955:        {
    #####: 1956:          uint8_t arguments_list_len = *byte_code_p++;
    #####: 1957:          stack_top_p -= arguments_list_len;
        -: 1958:
    #####: 1959:          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 1960:
    #####: 1961:          if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 1962:          {
    #####: 1963:            result = ECMA_VALUE_ERROR;
    #####: 1964:            goto error;
        -: 1965:          }
        -: 1966:
    #####: 1967:          stack_top_p++;
    #####: 1968:          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 1969:
    #####: 1970:          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;
    #####: 1971:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 1972:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 1973:          return ECMA_VALUE_UNDEFINED;
        -: 1974:        }
    #####: 1975:        case VM_OC_CREATE_GENERATOR:
        -: 1976:        {
    #####: 1977:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 1978:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 1979:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 1980:          result = opfunc_create_executable_object (frame_ctx_p);
        -: 1981:
    #####: 1982:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1983:          {
    #####: 1984:            goto error;
        -: 1985:          }
        -: 1986:
    #####: 1987:          return result;
        -: 1988:        }
    #####: 1989:        case VM_OC_YIELD:
        -: 1990:        {
    #####: 1991:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 1992:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 1993:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 1994:          return *stack_top_p;
        -: 1995:        }
    #####: 1996:        case VM_OC_AWAIT:
        -: 1997:        {
    #####: 1998:          continue;
        -: 1999:        }
    #####: 2000:        case VM_OC_EXT_RETURN:
        -: 2001:        {
    #####: 2002:          result = left_value;
    #####: 2003:          left_value = ECMA_VALUE_UNDEFINED;
        -: 2004:
    #####: 2005:          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 2006:
    #####: 2007:          while (stack_top_p > stack_bottom_p)
        -: 2008:          {
    #####: 2009:            ecma_fast_free_value (*(--stack_top_p));
        -: 2010:          }
        -: 2011:
    #####: 2012:          goto error;
        -: 2013:        }
    #####: 2014:        case VM_OC_RETURN_PROMISE:
        -: 2015:        {
    #####: 2016:          result = opfunc_return_promise (left_value);
    #####: 2017:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 2018:          goto error;
        -: 2019:        }
    #####: 2020:        case VM_OC_STRING_CONCAT:
        -: 2021:        {
    #####: 2022:          ecma_string_t *left_str_p = ecma_op_to_string (left_value);
        -: 2023:
    #####: 2024:          if (JERRY_UNLIKELY (left_str_p == NULL))
        -: 2025:          {
    #####: 2026:            result = ECMA_VALUE_ERROR;
    #####: 2027:            goto error;
        -: 2028:          }
    #####: 2029:          ecma_string_t *right_str_p = ecma_op_to_string (right_value);
        -: 2030:
    #####: 2031:          if (JERRY_UNLIKELY (right_str_p == NULL))
        -: 2032:          {
    #####: 2033:            ecma_deref_ecma_string (left_str_p);
    #####: 2034:            result = ECMA_VALUE_ERROR;
    #####: 2035:            goto error;
        -: 2036:          }
        -: 2037:
    #####: 2038:          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);
    #####: 2039:          ecma_deref_ecma_string (right_str_p);
        -: 2040:
    #####: 2041:          *stack_top_p++ = ecma_make_string_value (result_str_p);
    #####: 2042:          goto free_both_values;
        -: 2043:        }
    #####: 2044:        case VM_OC_GET_TEMPLATE_OBJECT:
        -: 2045:        {
    #####: 2046:          uint8_t tagged_idx = *byte_code_p++;
    #####: 2047:          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);
    #####: 2048:          JERRY_ASSERT (tagged_idx < collection_p->item_count);
        -: 2049:
    #####: 2050:          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);
    #####: 2051:          continue;
        -: 2052:        }
    #####: 2053:        case VM_OC_PUSH_NEW_TARGET:
        -: 2054:        {
    #####: 2055:          ecma_object_t *new_target_object = JERRY_CONTEXT (current_new_target);
    #####: 2056:          if (new_target_object == NULL)
        -: 2057:          {
    #####: 2058:            *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2059:          }
        -: 2060:          else
        -: 2061:          {
    #####: 2062:            ecma_ref_object (new_target_object);
    #####: 2063:            *stack_top_p++ = ecma_make_object_value (new_target_object);
        -: 2064:          }
    #####: 2065:          continue;
        -: 2066:        }
    #####: 2067:        case VM_OC_REQUIRE_OBJECT_COERCIBLE:
        -: 2068:        {
    #####: 2069:          result = ecma_op_check_object_coercible (stack_top_p[-1]);
        -: 2070:
    #####: 2071:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2072:          {
    #####: 2073:            goto error;
        -: 2074:          }
    #####: 2075:          continue;
        -: 2076:        }
    #####: 2077:        case VM_OC_ASSIGN_SUPER:
        -: 2078:        {
    #####: 2079:          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);
        -: 2080:
    #####: 2081:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2082:          {
    #####: 2083:            goto error;
        -: 2084:          }
    #####: 2085:          continue;
        -: 2086:        }
        -: 2087:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2088:        case VM_OC_PUSH_ELISON:
        -: 2089:        {
    #####: 2090:          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;
    #####: 2091:          continue;
        -: 2092:        }
        1: 2093:        case VM_OC_APPEND_ARRAY:
        -: 2094:        {
        1: 2095:          uint16_t values_length = *byte_code_p++;
        1: 2096:          stack_top_p -= values_length;
        -: 2097:
        -: 2098:#if ENABLED (JERRY_ES2015)
        1: 2099:          if (*byte_code_start_p == CBC_EXT_OPCODE)
        -: 2100:          {
    #####: 2101:            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);
        -: 2102:          }
        -: 2103:#endif /* ENABLED (JERRY_ES2015) */
        1: 2104:          result = opfunc_append_array (stack_top_p, values_length);
        -: 2105:
        -: 2106:#if ENABLED (JERRY_ES2015)
        1: 2107:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2108:          {
    #####: 2109:            goto error;
        -: 2110:          }
        -: 2111:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2112:          JERRY_ASSERT (ecma_is_value_empty (result));
        -: 2113:#endif /* ENABLED (JERRY_ES2015) */
        1: 2114:          continue;
        -: 2115:        }
    #####: 2116:        case VM_OC_IDENT_REFERENCE:
        -: 2117:        {
        -: 2118:          uint16_t literal_index;
        -: 2119:
    #####: 2120:          READ_LITERAL_INDEX (literal_index);
        -: 2121:
    #####: 2122:          JERRY_ASSERT (literal_index < ident_end);
        -: 2123:
    #####: 2124:          if (literal_index < register_end)
        -: 2125:          {
    #####: 2126:            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;
    #####: 2127:            *stack_top_p++ = ecma_make_integer_value (literal_index);
    #####: 2128:            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 2129:          }
        -: 2130:          else
        -: 2131:          {
    #####: 2132:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 2133:
    #####: 2134:            ecma_object_t *ref_base_lex_env_p;
        -: 2135:
    #####: 2136:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 2137:                                                     &ref_base_lex_env_p,
        -: 2138:                                                     name_p);
        -: 2139:
    #####: 2140:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2141:            {
    #####: 2142:              goto error;
        -: 2143:            }
        -: 2144:
    #####: 2145:            ecma_ref_object (ref_base_lex_env_p);
    #####: 2146:            ecma_ref_ecma_string (name_p);
    #####: 2147:            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);
    #####: 2148:            *stack_top_p++ = ecma_make_string_value (name_p);
    #####: 2149:            *stack_top_p++ = result;
        -: 2150:          }
    #####: 2151:          continue;
        -: 2152:        }
        2: 2153:        case VM_OC_PROP_GET:
        -: 2154:        {
        2: 2155:          result = vm_op_get_value (left_value, right_value);
        -: 2156:
        2: 2157:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2158:          {
    #####: 2159:            goto error;
        -: 2160:          }
        -: 2161:
        2: 2162:          *stack_top_p++ = result;
        2: 2163:          goto free_both_values;
        -: 2164:        }
     1309: 2165:        case VM_OC_PROP_REFERENCE:
        -: 2166:        {
        -: 2167:          /* Forms with reference requires preserving the base and offset. */
        -: 2168:
     1309: 2169:          if (opcode == CBC_PUSH_PROP_REFERENCE)
        -: 2170:          {
    #####: 2171:            left_value = stack_top_p[-2];
    #####: 2172:            right_value = stack_top_p[-1];
        -: 2173:          }
     1309: 2174:          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)
        -: 2175:          {
    #####: 2176:            *stack_top_p++ = left_value;
    #####: 2177:            right_value = left_value;
    #####: 2178:            left_value = stack_top_p[-2];
        -: 2179:          }
        -: 2180:          else
        -: 2181:          {
     1309: 2182:            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE
        -: 2183:                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);
     1309: 2184:            *stack_top_p++ = left_value;
     1309: 2185:            *stack_top_p++ = right_value;
        -: 2186:          }
        -: 2187:          /* FALLTHRU */
        -: 2188:        }
        -: 2189:        case VM_OC_PROP_PRE_INCR:
        -: 2190:        case VM_OC_PROP_PRE_DECR:
        -: 2191:        case VM_OC_PROP_POST_INCR:
        -: 2192:        case VM_OC_PROP_POST_DECR:
        -: 2193:        {
     1309: 2194:          result = vm_op_get_value (left_value,
        -: 2195:                                    right_value);
        -: 2196:
     1309: 2197:          if (opcode < CBC_PRE_INCR)
        -: 2198:          {
     1309: 2199:            left_value = ECMA_VALUE_UNDEFINED;
     1309: 2200:            right_value = ECMA_VALUE_UNDEFINED;
        -: 2201:          }
        -: 2202:
     1309: 2203:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2204:          {
    #####: 2205:            goto error;
        -: 2206:          }
        -: 2207:
     1309: 2208:          if (opcode < CBC_PRE_INCR)
        -: 2209:          {
     1309: 2210:            break;
        -: 2211:          }
        -: 2212:
    #####: 2213:          stack_top_p += 2;
    #####: 2214:          left_value = result;
    #####: 2215:          right_value = ECMA_VALUE_UNDEFINED;
        -: 2216:          /* FALLTHRU */
        -: 2217:        }
    #####: 2218:        case VM_OC_PRE_INCR:
        -: 2219:        case VM_OC_PRE_DECR:
        -: 2220:        case VM_OC_POST_INCR:
        -: 2221:        case VM_OC_POST_DECR:
        -: 2222:        {
    #####: 2223:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;
        -: 2224:
    #####: 2225:          byte_code_p = byte_code_start_p + 1;
        -: 2226:
    #####: 2227:          if (ecma_is_value_integer_number (left_value))
        -: 2228:          {
    #####: 2229:            result = left_value;
    #####: 2230:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2231:
    #####: 2232:            ecma_integer_value_t int_value = (ecma_integer_value_t) result;
    #####: 2233:            ecma_integer_value_t int_increase = 0;
        -: 2234:
    #####: 2235:            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 2236:            {
    #####: 2237:              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)
        -: 2238:              {
    #####: 2239:                int_increase = -(1 << ECMA_DIRECT_SHIFT);
        -: 2240:              }
        -: 2241:            }
    #####: 2242:            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)
        -: 2243:            {
    #####: 2244:              int_increase = 1 << ECMA_DIRECT_SHIFT;
        -: 2245:            }
        -: 2246:
    #####: 2247:            if (JERRY_LIKELY (int_increase != 0))
        -: 2248:            {
        -: 2249:              /* Postfix operators require the unmodifed number value. */
    #####: 2250:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 2251:              {
    #####: 2252:                if (opcode_data & VM_OC_PUT_STACK)
        -: 2253:                {
    #####: 2254:                  if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG)
        -: 2255:                  {
    #####: 2256:                    JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT
        -: 2257:                                  || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT);
        -: 2258:
    #####: 2259:                    *stack_top_p++ = result;
        -: 2260:                  }
        -: 2261:                  else
        -: 2262:                  {
        -: 2263:                    /* The parser ensures there is enough space for the
        -: 2264:                     * extra value on the stack. See js-parser-expr.c. */
        -: 2265:
    #####: 2266:                    JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT
        -: 2267:                                  || opcode == CBC_POST_DECR_PUSH_RESULT);
        -: 2268:
    #####: 2269:                    stack_top_p++;
    #####: 2270:                    stack_top_p[-1] = stack_top_p[-2];
    #####: 2271:                    stack_top_p[-2] = stack_top_p[-3];
    #####: 2272:                    stack_top_p[-3] = result;
        -: 2273:                  }
    #####: 2274:                  opcode_data &= (uint32_t) ~VM_OC_PUT_STACK;
        -: 2275:                }
    #####: 2276:                else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 2277:                {
    #####: 2278:                  ecma_free_value (frame_ctx_p->block_result);
    #####: 2279:                  frame_ctx_p->block_result = result;
    #####: 2280:                  opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK;
        -: 2281:                }
        -: 2282:              }
        -: 2283:
    #####: 2284:              result = (ecma_value_t) (int_value + int_increase);
    #####: 2285:              break;
        -: 2286:            }
        -: 2287:          }
    #####: 2288:          else if (ecma_is_value_float_number (left_value))
        -: 2289:          {
    #####: 2290:            result = left_value;
    #####: 2291:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2292:          }
        -: 2293:          else
        -: 2294:          {
    #####: 2295:            result = ecma_op_to_number (left_value);
        -: 2296:
    #####: 2297:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2298:            {
    #####: 2299:              goto error;
        -: 2300:            }
        -: 2301:          }
        -: 2302:
    #####: 2303:          ecma_number_t increase = ECMA_NUMBER_ONE;
    #####: 2304:          ecma_number_t result_number = ecma_get_number_from_value (result);
        -: 2305:
    #####: 2306:          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 2307:          {
        -: 2308:            /* For decrement operators */
    #####: 2309:            increase = ECMA_NUMBER_MINUS_ONE;
        -: 2310:          }
        -: 2311:
        -: 2312:          /* Post operators require the unmodifed number value. */
    #####: 2313:          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 2314:          {
    #####: 2315:            if (opcode_data & VM_OC_PUT_STACK)
        -: 2316:            {
    #####: 2317:              if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG)
        -: 2318:              {
    #####: 2319:                JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT
        -: 2320:                              || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT);
        -: 2321:
    #####: 2322:                *stack_top_p++ = ecma_copy_value (result);
        -: 2323:              }
        -: 2324:              else
        -: 2325:              {
        -: 2326:                /* The parser ensures there is enough space for the
        -: 2327:                 * extra value on the stack. See js-parser-expr.c. */
        -: 2328:
    #####: 2329:                JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT
        -: 2330:                              || opcode == CBC_POST_DECR_PUSH_RESULT);
        -: 2331:
    #####: 2332:                stack_top_p++;
    #####: 2333:                stack_top_p[-1] = stack_top_p[-2];
    #####: 2334:                stack_top_p[-2] = stack_top_p[-3];
    #####: 2335:                stack_top_p[-3] = ecma_copy_value (result);
        -: 2336:              }
    #####: 2337:              opcode_data &= (uint32_t) ~VM_OC_PUT_STACK;
        -: 2338:            }
    #####: 2339:            else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 2340:            {
    #####: 2341:              ecma_free_value (frame_ctx_p->block_result);
    #####: 2342:              frame_ctx_p->block_result = ecma_copy_value (result);
    #####: 2343:              opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK;
        -: 2344:            }
        -: 2345:          }
        -: 2346:
    #####: 2347:          if (ecma_is_value_integer_number (result))
        -: 2348:          {
    #####: 2349:            result = ecma_make_number_value (result_number + increase);
        -: 2350:          }
        -: 2351:          else
        -: 2352:          {
    #####: 2353:            result = ecma_update_float_number (result, result_number + increase);
        -: 2354:          }
    #####: 2355:          break;
        -: 2356:        }
     6550: 2357:        case VM_OC_ASSIGN:
        -: 2358:        {
     6550: 2359:          result = left_value;
     6550: 2360:          left_value = ECMA_VALUE_UNDEFINED;
     6550: 2361:          break;
        -: 2362:        }
    #####: 2363:        case VM_OC_MOV_IDENT:
        -: 2364:        {
        -: 2365:          uint32_t literal_index;
        -: 2366:
    #####: 2367:          READ_LITERAL_INDEX (literal_index);
        -: 2368:
    #####: 2369:          JERRY_ASSERT (literal_index < register_end);
    #####: 2370:          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));
        -: 2371:
    #####: 2372:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 2373:          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;
    #####: 2374:          continue;
        -: 2375:        }
    #####: 2376:        case VM_OC_ASSIGN_PROP:
        -: 2377:        {
    #####: 2378:          result = stack_top_p[-1];
    #####: 2379:          stack_top_p[-1] = left_value;
    #####: 2380:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 2381:          break;
        -: 2382:        }
    #####: 2383:        case VM_OC_ASSIGN_PROP_THIS:
        -: 2384:        {
    #####: 2385:          result = stack_top_p[-1];
    #####: 2386:          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 2387:          *stack_top_p++ = left_value;
    #####: 2388:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 2389:          break;
        -: 2390:        }
    #####: 2391:        case VM_OC_RETURN:
        -: 2392:        {
    #####: 2393:          JERRY_ASSERT (opcode == CBC_RETURN
        -: 2394:                        || opcode == CBC_RETURN_WITH_BLOCK
        -: 2395:                        || opcode == CBC_RETURN_WITH_LITERAL);
        -: 2396:
    #####: 2397:          if (opcode == CBC_RETURN_WITH_BLOCK)
        -: 2398:          {
    #####: 2399:            left_value = frame_ctx_p->block_result;
    #####: 2400:            frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;
        -: 2401:          }
        -: 2402:
    #####: 2403:          result = left_value;
    #####: 2404:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 2405:          goto error;
        -: 2406:        }
    #####: 2407:        case VM_OC_THROW:
        -: 2408:        {
    #####: 2409:          jcontext_raise_exception (left_value);
        -: 2410:
    #####: 2411:          result = ECMA_VALUE_ERROR;
    #####: 2412:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 2413:          goto error;
        -: 2414:        }
    #####: 2415:        case VM_OC_THROW_REFERENCE_ERROR:
        -: 2416:        {
    #####: 2417:          result = ecma_raise_reference_error (ECMA_ERR_MSG ("Undefined reference."));
    #####: 2418:          goto error;
        -: 2419:        }
    #####: 2420:        case VM_OC_EVAL:
        -: 2421:        {
    #####: 2422:          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;
    #####: 2423:          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)
        -: 2424:                        || (*byte_code_p == CBC_EXT_OPCODE
        -: 2425:                            && byte_code_p[1] >= CBC_EXT_SPREAD_CALL
        -: 2426:                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));
    #####: 2427:          continue;
        -: 2428:        }
     2619: 2429:        case VM_OC_CALL:
        -: 2430:        {
     2619: 2431:          frame_ctx_p->call_operation = VM_EXEC_CALL;
     2619: 2432:          frame_ctx_p->byte_code_p = byte_code_start_p;
     2619: 2433:          frame_ctx_p->stack_top_p = stack_top_p;
     2619: 2434:          return ECMA_VALUE_UNDEFINED;
        -: 2435:        }
     1311: 2436:        case VM_OC_NEW:
        -: 2437:        {
     1311: 2438:          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;
     1311: 2439:          frame_ctx_p->byte_code_p = byte_code_start_p;
     1311: 2440:          frame_ctx_p->stack_top_p = stack_top_p;
     1311: 2441:          return ECMA_VALUE_UNDEFINED;
        -: 2442:        }
     1308: 2443:        case VM_OC_ERROR:
        -: 2444:        {
     1308: 2445:          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);
        -: 2446:#if ENABLED (JERRY_DEBUGGER)
        -: 2447:          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);
        -: 2448:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 2449:
     1308: 2450:          result = ECMA_VALUE_ERROR;
     1308: 2451:          goto error;
        -: 2452:        }
    #####: 2453:        case VM_OC_RESOLVE_BASE_FOR_CALL:
        -: 2454:        {
    #####: 2455:          ecma_value_t this_value = stack_top_p[-3];
        -: 2456:
    #####: 2457:          if (this_value == ECMA_VALUE_REGISTER_REF)
        -: 2458:          {
        -: 2459:            /* Lexical environment cannot be 'this' value. */
    #####: 2460:            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 2461:            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;
        -: 2462:          }
    #####: 2463:          else if (vm_get_implicit_this_value (&this_value))
        -: 2464:          {
    #####: 2465:            ecma_free_value (stack_top_p[-3]);
    #####: 2466:            stack_top_p[-3] = this_value;
        -: 2467:          }
        -: 2468:
    #####: 2469:          continue;
        -: 2470:        }
    #####: 2471:        case VM_OC_PROP_DELETE:
        -: 2472:        {
    #####: 2473:          result = vm_op_delete_prop (left_value, right_value, is_strict);
        -: 2474:
    #####: 2475:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2476:          {
    #####: 2477:            goto error;
        -: 2478:          }
        -: 2479:
    #####: 2480:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 2481:
    #####: 2482:          *stack_top_p++ = result;
    #####: 2483:          goto free_both_values;
        -: 2484:        }
    #####: 2485:        case VM_OC_DELETE:
        -: 2486:        {
        -: 2487:          uint16_t literal_index;
        -: 2488:
    #####: 2489:          READ_LITERAL_INDEX (literal_index);
        -: 2490:
    #####: 2491:          if (literal_index < register_end)
        -: 2492:          {
    #####: 2493:            *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 2494:            continue;
        -: 2495:          }
        -: 2496:
    #####: 2497:          result = vm_op_delete_var (literal_start_p[literal_index],
        -: 2498:                                     frame_ctx_p->lex_env_p);
        -: 2499:
    #####: 2500:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2501:          {
    #####: 2502:            goto error;
        -: 2503:          }
        -: 2504:
    #####: 2505:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 2506:
    #####: 2507:          *stack_top_p++ = result;
    #####: 2508:          continue;
        -: 2509:        }
    #####: 2510:        case VM_OC_JUMP:
        -: 2511:        {
    #####: 2512:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 2513:          continue;
        -: 2514:        }
    #####: 2515:        case VM_OC_BRANCH_IF_STRICT_EQUAL:
        -: 2516:        {
    #####: 2517:          ecma_value_t value = *(--stack_top_p);
        -: 2518:
    #####: 2519:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 2520:
    #####: 2521:          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))
        -: 2522:          {
    #####: 2523:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 2524:            ecma_free_value (*--stack_top_p);
        -: 2525:          }
    #####: 2526:          ecma_free_value (value);
    #####: 2527:          continue;
        -: 2528:        }
    #####: 2529:        case VM_OC_BRANCH_IF_TRUE:
        -: 2530:        case VM_OC_BRANCH_IF_FALSE:
        -: 2531:        case VM_OC_BRANCH_IF_LOGICAL_TRUE:
        -: 2532:        case VM_OC_BRANCH_IF_LOGICAL_FALSE:
        -: 2533:        {
    #####: 2534:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;
    #####: 2535:          ecma_value_t value = *(--stack_top_p);
        -: 2536:
    #####: 2537:          bool boolean_value = ecma_op_to_boolean (value);
        -: 2538:
    #####: 2539:          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)
        -: 2540:          {
    #####: 2541:            boolean_value = !boolean_value;
        -: 2542:          }
        -: 2543:
    #####: 2544:          if (boolean_value)
        -: 2545:          {
    #####: 2546:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 2547:            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)
        -: 2548:            {
        -: 2549:              /* "Push" the value back to the stack. */
    #####: 2550:              ++stack_top_p;
    #####: 2551:              continue;
        -: 2552:            }
        -: 2553:          }
        -: 2554:
    #####: 2555:          ecma_fast_free_value (value);
    #####: 2556:          continue;
        -: 2557:        }
    #####: 2558:        case VM_OC_PLUS:
        -: 2559:        case VM_OC_MINUS:
        -: 2560:        {
    #####: 2561:          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);
        -: 2562:
    #####: 2563:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2564:          {
    #####: 2565:            goto error;
        -: 2566:          }
        -: 2567:
    #####: 2568:          *stack_top_p++ = result;
    #####: 2569:          goto free_left_value;
        -: 2570:        }
    #####: 2571:        case VM_OC_NOT:
        -: 2572:        {
    #####: 2573:          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));
    #####: 2574:          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));
    #####: 2575:          goto free_left_value;
        -: 2576:        }
    #####: 2577:        case VM_OC_BIT_NOT:
        -: 2578:        {
        -: 2579:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 2580:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 2581:
    #####: 2582:          if (ecma_is_value_integer_number (left_value))
        -: 2583:          {
    #####: 2584:            *stack_top_p++ = (~left_value) & (ecma_value_t) (~ECMA_DIRECT_TYPE_MASK);
    #####: 2585:            goto free_left_value;
        -: 2586:          }
        -: 2587:
    #####: 2588:          result = do_number_bitwise_logic (NUMBER_BITWISE_NOT,
        -: 2589:                                            left_value,
        -: 2590:                                            left_value);
        -: 2591:
    #####: 2592:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2593:          {
    #####: 2594:            goto error;
        -: 2595:          }
        -: 2596:
    #####: 2597:          *stack_top_p++ = result;
    #####: 2598:          goto free_left_value;
        -: 2599:        }
    #####: 2600:        case VM_OC_VOID:
        -: 2601:        {
    #####: 2602:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 2603:          goto free_left_value;
        -: 2604:        }
    #####: 2605:        case VM_OC_TYPEOF_IDENT:
        -: 2606:        {
        -: 2607:          uint16_t literal_index;
        -: 2608:
    #####: 2609:          READ_LITERAL_INDEX (literal_index);
        -: 2610:
    #####: 2611:          JERRY_ASSERT (literal_index < ident_end);
        -: 2612:
    #####: 2613:          if (literal_index < register_end)
        -: 2614:          {
    #####: 2615:            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 2616:          }
        -: 2617:          else
        -: 2618:          {
    #####: 2619:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 2620:
    #####: 2621:            ecma_object_t *ref_base_lex_env_p;
        -: 2622:
    #####: 2623:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 2624:                                                     &ref_base_lex_env_p,
        -: 2625:                                                     name_p);
        -: 2626:
    #####: 2627:            if (ref_base_lex_env_p == NULL)
        -: 2628:            {
    #####: 2629:              jcontext_release_exception ();
    #####: 2630:              result = ECMA_VALUE_UNDEFINED;
        -: 2631:            }
    #####: 2632:            else if (ECMA_IS_VALUE_ERROR (result))
        -: 2633:            {
    #####: 2634:              goto error;
        -: 2635:            }
        -: 2636:
    #####: 2637:            left_value = result;
        -: 2638:          }
        -: 2639:          /* FALLTHRU */
        -: 2640:        }
        -: 2641:        case VM_OC_TYPEOF:
        -: 2642:        {
    #####: 2643:          result = opfunc_typeof (left_value);
        -: 2644:
    #####: 2645:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2646:          {
    #####: 2647:            goto error;
        -: 2648:          }
        -: 2649:
    #####: 2650:          *stack_top_p++ = result;
    #####: 2651:          goto free_left_value;
        -: 2652:        }
     1308: 2653:        case VM_OC_ADD:
        -: 2654:        {
     1308: 2655:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 2656:          {
     1308: 2657:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
     1308: 2658:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
     1308: 2659:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));
     1308: 2660:            continue;
        -: 2661:          }
        -: 2662:
    #####: 2663:          if (ecma_is_value_float_number (left_value)
    #####: 2664:              && ecma_is_value_number (right_value))
        -: 2665:          {
    #####: 2666:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) +
    #####: 2667:                                       ecma_get_number_from_value (right_value));
        -: 2668:
    #####: 2669:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 2670:            ecma_free_number (right_value);
    #####: 2671:            continue;
        -: 2672:          }
        -: 2673:
    #####: 2674:          if (ecma_is_value_float_number (right_value)
    #####: 2675:              && ecma_is_value_integer_number (left_value))
        -: 2676:          {
    #####: 2677:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) +
    #####: 2678:                                       ecma_get_float_from_value (right_value));
        -: 2679:
    #####: 2680:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 2681:            continue;
        -: 2682:          }
        -: 2683:
    #####: 2684:          result = opfunc_addition (left_value, right_value);
        -: 2685:
    #####: 2686:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2687:          {
    #####: 2688:            goto error;
        -: 2689:          }
        -: 2690:
    #####: 2691:          *stack_top_p++ = result;
    #####: 2692:          goto free_both_values;
        -: 2693:        }
    #####: 2694:        case VM_OC_SUB:
        -: 2695:        {
        -: 2696:          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX
        -: 2697:                               && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,
        -: 2698:                               doubled_ecma_numbers_must_fit_into_int32_range);
        -: 2699:
    #####: 2700:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 2701:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 2702:
    #####: 2703:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 2704:          {
    #####: 2705:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 2706:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 2707:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));
    #####: 2708:            continue;
        -: 2709:          }
        -: 2710:
    #####: 2711:          if (ecma_is_value_float_number (left_value)
    #####: 2712:              && ecma_is_value_number (right_value))
        -: 2713:          {
    #####: 2714:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) -
    #####: 2715:                                       ecma_get_number_from_value (right_value));
        -: 2716:
    #####: 2717:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 2718:            ecma_free_number (right_value);
    #####: 2719:            continue;
        -: 2720:          }
        -: 2721:
    #####: 2722:          if (ecma_is_value_float_number (right_value)
    #####: 2723:              && ecma_is_value_integer_number (left_value))
        -: 2724:          {
    #####: 2725:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) -
    #####: 2726:                                       ecma_get_float_from_value (right_value));
        -: 2727:
    #####: 2728:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 2729:            continue;
        -: 2730:          }
        -: 2731:
    #####: 2732:          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION,
        -: 2733:                                         left_value,
        -: 2734:                                         right_value);
        -: 2735:
    #####: 2736:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2737:          {
    #####: 2738:            goto error;
        -: 2739:          }
        -: 2740:
    #####: 2741:          *stack_top_p++ = result;
    #####: 2742:          goto free_both_values;
        -: 2743:        }
    #####: 2744:        case VM_OC_MUL:
        -: 2745:        {
    #####: 2746:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 2747:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 2748:
        -: 2749:          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX
        -: 2750:                               && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,
        -: 2751:                               square_of_integer_multiply_max_must_fit_into_integer_value_range);
        -: 2752:
    #####: 2753:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 2754:          {
    #####: 2755:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 2756:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 2757:
    #####: 2758:            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer
    #####: 2759:                && left_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 2760:                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer
    #####: 2761:                && right_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 2762:                && left_value != 0
    #####: 2763:                && right_value != 0)
        -: 2764:            {
    #####: 2765:              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);
    #####: 2766:              continue;
        -: 2767:            }
        -: 2768:
    #####: 2769:            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;
    #####: 2770:            *stack_top_p++ = ecma_make_number_value (multiply);
    #####: 2771:            continue;
        -: 2772:          }
        -: 2773:
    #####: 2774:          if (ecma_is_value_float_number (left_value)
    #####: 2775:              && ecma_is_value_number (right_value))
        -: 2776:          {
    #####: 2777:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) *
    #####: 2778:                                       ecma_get_number_from_value (right_value));
        -: 2779:
    #####: 2780:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 2781:            ecma_free_number (right_value);
    #####: 2782:            continue;
        -: 2783:          }
        -: 2784:
    #####: 2785:          if (ecma_is_value_float_number (right_value)
    #####: 2786:              && ecma_is_value_integer_number (left_value))
        -: 2787:          {
    #####: 2788:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) *
    #####: 2789:                                       ecma_get_float_from_value (right_value));
        -: 2790:
    #####: 2791:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 2792:            continue;
        -: 2793:          }
        -: 2794:
    #####: 2795:          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION,
        -: 2796:                                         left_value,
        -: 2797:                                         right_value);
        -: 2798:
    #####: 2799:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2800:          {
    #####: 2801:            goto error;
        -: 2802:          }
        -: 2803:
    #####: 2804:          *stack_top_p++ = result;
    #####: 2805:          goto free_both_values;
        -: 2806:        }
    #####: 2807:        case VM_OC_DIV:
        -: 2808:        {
    #####: 2809:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 2810:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 2811:
    #####: 2812:          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION,
        -: 2813:                                         left_value,
        -: 2814:                                         right_value);
        -: 2815:
    #####: 2816:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2817:          {
    #####: 2818:            goto error;
        -: 2819:          }
        -: 2820:
    #####: 2821:          *stack_top_p++ = result;
    #####: 2822:          goto free_both_values;
        -: 2823:        }
    #####: 2824:        case VM_OC_MOD:
        -: 2825:        {
    #####: 2826:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 2827:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 2828:
    #####: 2829:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 2830:          {
    #####: 2831:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 2832:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 2833:
    #####: 2834:            if (right_integer != 0)
        -: 2835:            {
    #####: 2836:              ecma_integer_value_t mod_result = left_integer % right_integer;
        -: 2837:
    #####: 2838:              if (mod_result != 0 || left_integer >= 0)
        -: 2839:              {
    #####: 2840:                *stack_top_p++ = ecma_make_integer_value (mod_result);
    #####: 2841:                continue;
        -: 2842:              }
        -: 2843:            }
        -: 2844:          }
        -: 2845:
    #####: 2846:          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER,
        -: 2847:                                         left_value,
        -: 2848:                                         right_value);
        -: 2849:
    #####: 2850:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2851:          {
    #####: 2852:            goto error;
        -: 2853:          }
        -: 2854:
    #####: 2855:          *stack_top_p++ = result;
    #####: 2856:          goto free_both_values;
        -: 2857:        }
        -: 2858:#if ENABLED (JERRY_ES2015)
    #####: 2859:        case VM_OC_EXP:
        -: 2860:        {
    #####: 2861:          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION,
        -: 2862:                                         left_value,
        -: 2863:                                         right_value);
        -: 2864:
    #####: 2865:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2866:          {
    #####: 2867:            goto error;
        -: 2868:          }
        -: 2869:
    #####: 2870:          *stack_top_p++ = result;
    #####: 2871:          goto free_both_values;
        -: 2872:        }
        -: 2873:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2874:        case VM_OC_EQUAL:
        -: 2875:        {
    #####: 2876:          result = opfunc_equality (left_value, right_value);
        -: 2877:
    #####: 2878:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2879:          {
    #####: 2880:            goto error;
        -: 2881:          }
        -: 2882:
    #####: 2883:          *stack_top_p++ = result;
    #####: 2884:          goto free_both_values;
        -: 2885:        }
    #####: 2886:        case VM_OC_NOT_EQUAL:
        -: 2887:        {
    #####: 2888:          result = opfunc_equality (left_value, right_value);
        -: 2889:
    #####: 2890:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2891:          {
    #####: 2892:            goto error;
        -: 2893:          }
        -: 2894:
    #####: 2895:          *stack_top_p++ = ecma_invert_boolean_value (result);
    #####: 2896:          goto free_both_values;
        -: 2897:        }
    #####: 2898:        case VM_OC_STRICT_EQUAL:
        -: 2899:        {
    #####: 2900:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 2901:
    #####: 2902:          result = ecma_make_boolean_value (is_equal);
        -: 2903:
    #####: 2904:          *stack_top_p++ = result;
    #####: 2905:          goto free_both_values;
        -: 2906:        }
    #####: 2907:        case VM_OC_STRICT_NOT_EQUAL:
        -: 2908:        {
    #####: 2909:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 2910:
    #####: 2911:          result = ecma_make_boolean_value (!is_equal);
        -: 2912:
    #####: 2913:          *stack_top_p++ = result;
    #####: 2914:          goto free_both_values;
        -: 2915:        }
    #####: 2916:        case VM_OC_BIT_OR:
        -: 2917:        {
        -: 2918:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 2919:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 2920:
    #####: 2921:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 2922:          {
    #####: 2923:            *stack_top_p++ = left_value | right_value;
    #####: 2924:            continue;
        -: 2925:          }
        -: 2926:
    #####: 2927:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR,
        -: 2928:                                            left_value,
        -: 2929:                                            right_value);
        -: 2930:
    #####: 2931:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2932:          {
    #####: 2933:            goto error;
        -: 2934:          }
        -: 2935:
    #####: 2936:          *stack_top_p++ = result;
    #####: 2937:          goto free_both_values;
        -: 2938:        }
    #####: 2939:        case VM_OC_BIT_XOR:
        -: 2940:        {
        -: 2941:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 2942:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 2943:
    #####: 2944:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 2945:          {
    #####: 2946:            *stack_top_p++ = (left_value ^ right_value) & (ecma_value_t) (~ECMA_DIRECT_TYPE_MASK);
    #####: 2947:            continue;
        -: 2948:          }
        -: 2949:
    #####: 2950:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR,
        -: 2951:                                            left_value,
        -: 2952:                                            right_value);
        -: 2953:
    #####: 2954:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2955:          {
    #####: 2956:            goto error;
        -: 2957:          }
        -: 2958:
    #####: 2959:          *stack_top_p++ = result;
    #####: 2960:          goto free_both_values;
        -: 2961:        }
    #####: 2962:        case VM_OC_BIT_AND:
        -: 2963:        {
        -: 2964:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 2965:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 2966:
    #####: 2967:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 2968:          {
    #####: 2969:            *stack_top_p++ = left_value & right_value;
    #####: 2970:            continue;
        -: 2971:          }
        -: 2972:
    #####: 2973:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND,
        -: 2974:                                            left_value,
        -: 2975:                                            right_value);
        -: 2976:
    #####: 2977:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2978:          {
    #####: 2979:            goto error;
        -: 2980:          }
        -: 2981:
    #####: 2982:          *stack_top_p++ = result;
    #####: 2983:          goto free_both_values;
        -: 2984:        }
    #####: 2985:        case VM_OC_LEFT_SHIFT:
        -: 2986:        {
        -: 2987:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 2988:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 2989:
    #####: 2990:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 2991:          {
    #####: 2992:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 2993:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 2994:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer << (right_integer & 0x1f)));
    #####: 2995:            continue;
        -: 2996:          }
        -: 2997:
    #####: 2998:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT,
        -: 2999:                                            left_value,
        -: 3000:                                            right_value);
        -: 3001:
    #####: 3002:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3003:          {
    #####: 3004:            goto error;
        -: 3005:          }
        -: 3006:
    #####: 3007:          *stack_top_p++ = result;
    #####: 3008:          goto free_both_values;
        -: 3009:        }
    #####: 3010:        case VM_OC_RIGHT_SHIFT:
        -: 3011:        {
        -: 3012:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3013:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3014:
    #####: 3015:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3016:          {
    #####: 3017:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3018:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3019:            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));
    #####: 3020:            continue;
        -: 3021:          }
        -: 3022:
    #####: 3023:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT,
        -: 3024:                                            left_value,
        -: 3025:                                            right_value);
        -: 3026:
    #####: 3027:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3028:          {
    #####: 3029:            goto error;
        -: 3030:          }
        -: 3031:
    #####: 3032:          *stack_top_p++ = result;
    #####: 3033:          goto free_both_values;
        -: 3034:        }
    #####: 3035:        case VM_OC_UNS_RIGHT_SHIFT:
        -: 3036:        {
        -: 3037:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3038:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3039:
    #####: 3040:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3041:          {
    #####: 3042:            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);
    #####: 3043:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3044:            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));
    #####: 3045:            continue;
        -: 3046:          }
        -: 3047:
    #####: 3048:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT,
        -: 3049:                                            left_value,
        -: 3050:                                            right_value);
        -: 3051:
    #####: 3052:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3053:          {
    #####: 3054:            goto error;
        -: 3055:          }
        -: 3056:
    #####: 3057:          *stack_top_p++ = result;
    #####: 3058:          goto free_both_values;
        -: 3059:        }
     1308: 3060:        case VM_OC_LESS:
        -: 3061:        {
     1308: 3062:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3063:          {
     1308: 3064:            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;
        -: 3065:#if !ENABLED (JERRY_VM_EXEC_STOP)
        -: 3066:            /* This is a lookahead to the next opcode to improve performance.
        -: 3067:             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */
     1308: 3068:            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)
        -: 3069:            {
     1308: 3070:              byte_code_start_p = byte_code_p++;
     1308: 3071:              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);
     1308: 3072:              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 3073:
     1308: 3074:              if (is_less)
        -: 3075:              {
     1308: 3076:                branch_offset = *(byte_code_p++);
        -: 3077:
     1308: 3078:                if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 3079:                {
    #####: 3080:                  branch_offset <<= 8;
    #####: 3081:                  branch_offset |= *(byte_code_p++);
    #####: 3082:                  if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 3083:                  {
    #####: 3084:                    branch_offset <<= 8;
    #####: 3085:                    branch_offset |= *(byte_code_p++);
        -: 3086:                  }
        -: 3087:                }
        -: 3088:
        -: 3089:                /* Note: The opcode is a backward branch. */
     1308: 3090:                byte_code_p = byte_code_start_p - branch_offset;
        -: 3091:              }
        -: 3092:              else
        -: 3093:              {
    #####: 3094:                byte_code_p += branch_offset_length;
        -: 3095:              }
        -: 3096:
     1308: 3097:              continue;
        -: 3098:            }
        -: 3099:#endif /* !ENABLED (JERRY_VM_EXEC_STOP) */
    #####: 3100:            *stack_top_p++ = ecma_make_boolean_value (is_less);
    #####: 3101:            continue;
        -: 3102:          }
        -: 3103:
    #####: 3104:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3105:          {
    #####: 3106:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3107:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3108:
    #####: 3109:            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);
    #####: 3110:            goto free_both_values;
        -: 3111:          }
        -: 3112:
    #####: 3113:          result = opfunc_relation (left_value, right_value, true, false);
        -: 3114:
    #####: 3115:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3116:          {
    #####: 3117:            goto error;
        -: 3118:          }
        -: 3119:
    #####: 3120:          *stack_top_p++ = result;
    #####: 3121:          goto free_both_values;
        -: 3122:        }
    #####: 3123:        case VM_OC_GREATER:
        -: 3124:        {
    #####: 3125:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3126:          {
    #####: 3127:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3128:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3129:
    #####: 3130:            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);
    #####: 3131:            continue;
        -: 3132:          }
        -: 3133:
    #####: 3134:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3135:          {
    #####: 3136:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3137:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3138:
    #####: 3139:            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);
    #####: 3140:            goto free_both_values;
        -: 3141:          }
        -: 3142:
    #####: 3143:          result = opfunc_relation (left_value, right_value, false, false);
        -: 3144:
    #####: 3145:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3146:          {
    #####: 3147:            goto error;
        -: 3148:          }
        -: 3149:
    #####: 3150:          *stack_top_p++ = result;
    #####: 3151:          goto free_both_values;
        -: 3152:        }
    #####: 3153:        case VM_OC_LESS_EQUAL:
        -: 3154:        {
    #####: 3155:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3156:          {
    #####: 3157:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3158:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3159:
    #####: 3160:            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);
    #####: 3161:            continue;
        -: 3162:          }
        -: 3163:
    #####: 3164:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3165:          {
    #####: 3166:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3167:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3168:
    #####: 3169:            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);
    #####: 3170:            goto free_both_values;
        -: 3171:          }
        -: 3172:
    #####: 3173:          result = opfunc_relation (left_value, right_value, false, true);
        -: 3174:
    #####: 3175:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3176:          {
    #####: 3177:            goto error;
        -: 3178:          }
        -: 3179:
    #####: 3180:          *stack_top_p++ = result;
    #####: 3181:          goto free_both_values;
        -: 3182:        }
    #####: 3183:        case VM_OC_GREATER_EQUAL:
        -: 3184:        {
    #####: 3185:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3186:          {
    #####: 3187:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3188:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3189:
    #####: 3190:            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);
    #####: 3191:            continue;
        -: 3192:          }
        -: 3193:
    #####: 3194:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3195:          {
    #####: 3196:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3197:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3198:
    #####: 3199:            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);
    #####: 3200:            goto free_both_values;
        -: 3201:          }
        -: 3202:
    #####: 3203:          result = opfunc_relation (left_value, right_value, true, true);
        -: 3204:
    #####: 3205:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3206:          {
    #####: 3207:            goto error;
        -: 3208:          }
        -: 3209:
    #####: 3210:          *stack_top_p++ = result;
    #####: 3211:          goto free_both_values;
        -: 3212:        }
    #####: 3213:        case VM_OC_IN:
        -: 3214:        {
    #####: 3215:          result = opfunc_in (left_value, right_value);
        -: 3216:
    #####: 3217:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3218:          {
    #####: 3219:            goto error;
        -: 3220:          }
        -: 3221:
    #####: 3222:          *stack_top_p++ = result;
    #####: 3223:          goto free_both_values;
        -: 3224:        }
    #####: 3225:        case VM_OC_INSTANCEOF:
        -: 3226:        {
    #####: 3227:          result = opfunc_instanceof (left_value, right_value);
        -: 3228:
    #####: 3229:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3230:          {
    #####: 3231:            goto error;
        -: 3232:          }
        -: 3233:
    #####: 3234:          *stack_top_p++ = result;
    #####: 3235:          goto free_both_values;
        -: 3236:        }
     1309: 3237:        case VM_OC_BLOCK_CREATE_CONTEXT:
        -: 3238:        {
        -: 3239:#if ENABLED (JERRY_ES2015)
        -: 3240:          ecma_value_t *stack_context_top_p;
     1309: 3241:          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 3242:
     1309: 3243:          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);
        -: 3244:
     1309: 3245:          if (byte_code_start_p[0] != CBC_EXT_OPCODE)
        -: 3246:          {
     1309: 3247:            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3248:
     1309: 3249:            if (stack_context_top_p != stack_top_p)
        -: 3250:            {
        -: 3251:               /* Preserve the value of switch statement. */
    #####: 3252:              stack_context_top_p[1] = stack_context_top_p[0];
        -: 3253:            }
        -: 3254:
     1309: 3255:            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);
        -: 3256:
     1309: 3257:            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
     1309: 3258:            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;
        -: 3259:          }
        -: 3260:          else
        -: 3261:          {
    #####: 3262:            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);
        -: 3263:
    #####: 3264:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY
        -: 3265:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH
        -: 3266:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP
        -: 3267:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW
        -: 3268:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
        -: 3269:
    #####: 3270:            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 3271:
    #####: 3272:            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 3273:          }
        -: 3274:#else /* !ENABLED (JERRY_ES2015) */
    #####: 3275:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH
        -: 3276:                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));
        -: 3277:
    #####: 3278:          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 3279:#endif /* ENABLED (JERRY_ES2015) */
        -: 3280:
     1309: 3281:          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
     1309: 3282:          frame_ctx_p->lex_env_p->type_flags_refs |= (uint16_t) ECMA_OBJECT_FLAG_BLOCK;
        -: 3283:
     1309: 3284:          continue;
        -: 3285:        }
    #####: 3286:        case VM_OC_WITH:
        -: 3287:        {
    #####: 3288:          ecma_value_t value = *(--stack_top_p);
        -: 3289:          ecma_object_t *object_p;
        -: 3290:          ecma_object_t *with_env_p;
        -: 3291:
    #####: 3292:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3293:
    #####: 3294:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3295:
    #####: 3296:          result = ecma_op_to_object (value);
    #####: 3297:          ecma_free_value (value);
        -: 3298:
    #####: 3299:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3300:          {
    #####: 3301:            goto error;
        -: 3302:          }
        -: 3303:
    #####: 3304:          object_p = ecma_get_object_from_value (result);
        -: 3305:
    #####: 3306:          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p,
        -: 3307:                                                   object_p,
        -: 3308:                                                   ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
    #####: 3309:          ecma_deref_object (object_p);
        -: 3310:
    #####: 3311:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
    #####: 3312:          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;
        -: 3313:
    #####: 3314:          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);
        -: 3315:
    #####: 3316:          with_env_p->type_flags_refs |= (uint16_t) ECMA_OBJECT_FLAG_BLOCK;
    #####: 3317:          frame_ctx_p->lex_env_p = with_env_p;
    #####: 3318:          continue;
        -: 3319:        }
    #####: 3320:        case VM_OC_FOR_IN_CREATE_CONTEXT:
        -: 3321:        {
    #####: 3322:          ecma_value_t value = *(--stack_top_p);
        -: 3323:
    #####: 3324:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3325:
        -: 3326:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 3327:          if (ecma_is_value_object (value)
    #####: 3328:              && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (value)))
        -: 3329:          {
        -: 3330:            /* Note: - For proxy objects we should create a new object which implements the iterable protocol,
        -: 3331:                       and iterates through the enumerated collection below.
        -: 3332:                     - This inkoves that the VM context type should be adjusted and checked in all FOR-IN related
        -: 3333:                       instruction.
        -: 3334:                     - For other objects we should keep the current implementation due to performance reasons.*/
    #####: 3335:            result = ecma_raise_type_error (ECMA_ERR_MSG ("UNIMPLEMENTED: Proxy support in for-in."));
    #####: 3336:            goto error;
        -: 3337:          }
        -: 3338:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 3339:
    #####: 3340:          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;
    #####: 3341:          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);
    #####: 3342:          ecma_free_value (value);
        -: 3343:
    #####: 3344:          if (prop_names_p == NULL)
        -: 3345:          {
        -: 3346:            /* The collection is already released */
    #####: 3347:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3348:            continue;
        -: 3349:          }
        -: 3350:
    #####: 3351:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3352:
    #####: 3353:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 3354:          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
    #####: 3355:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);
    #####: 3356:          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);
    #####: 3357:          stack_top_p[-3] = 0;
    #####: 3358:          stack_top_p[-4] = expr_obj_value;
        -: 3359:
        -: 3360:#if ENABLED (JERRY_ES2015)
    #####: 3361:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 3362:          {
        -: 3363:            /* No need to duplicate the first context. */
    #####: 3364:            byte_code_p += 2;
        -: 3365:          }
        -: 3366:#endif /* ENABLED (JERRY_ES2015) */
    #####: 3367:          continue;
        -: 3368:        }
    #####: 3369:        case VM_OC_FOR_IN_GET_NEXT:
        -: 3370:        {
    #####: 3371:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 3372:
        -: 3373:          ecma_collection_t *collection_p;
    #####: 3374:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);
        -: 3375:
    #####: 3376:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 3377:
    #####: 3378:          uint32_t index = context_top_p[-3];
    #####: 3379:          ecma_value_t *buffer_p = collection_p->buffer_p;
        -: 3380:
    #####: 3381:          *stack_top_p++ = buffer_p[index];
    #####: 3382:          context_top_p[-3]++;
    #####: 3383:          continue;
        -: 3384:        }
    #####: 3385:        case VM_OC_FOR_IN_HAS_NEXT:
        -: 3386:        {
    #####: 3387:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3388:
        -: 3389:          ecma_collection_t *collection_p;
    #####: 3390:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);
        -: 3391:
    #####: 3392:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 3393:
    #####: 3394:          ecma_value_t *buffer_p = collection_p->buffer_p;
    #####: 3395:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);
    #####: 3396:          uint32_t index = stack_top_p[-3];
        -: 3397:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 3398:          JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3399:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 3400:
    #####: 3401:          while (index < collection_p->item_count)
        -: 3402:          {
    #####: 3403:            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);
        -: 3404:
    #####: 3405:            result = ecma_op_object_has_property (object_p, prop_name_p);
        -: 3406:
    #####: 3407:            if (JERRY_LIKELY (ecma_is_value_true (result)))
        -: 3408:            {
    #####: 3409:              byte_code_p = byte_code_start_p + branch_offset;
    #####: 3410:              break;
        -: 3411:            }
        -: 3412:
    #####: 3413:            ecma_deref_ecma_string (prop_name_p);
    #####: 3414:            index++;
        -: 3415:          }
        -: 3416:
    #####: 3417:          if (index == collection_p->item_count)
        -: 3418:          {
    #####: 3419:            ecma_deref_object (object_p);
    #####: 3420:            ecma_collection_destroy (collection_p);
    #####: 3421:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 3422:            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 3423:          }
        -: 3424:          else
        -: 3425:          {
    #####: 3426:            stack_top_p[-3] = index;
        -: 3427:          }
    #####: 3428:          continue;
        -: 3429:        }
        -: 3430:#if ENABLED (JERRY_ES2015)
    #####: 3431:        case VM_OC_FOR_OF_CREATE_CONTEXT:
        -: 3432:        {
    #####: 3433:          ecma_value_t value = *(--stack_top_p);
        -: 3434:
    #####: 3435:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3436:
    #####: 3437:          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_EMPTY);
        -: 3438:
    #####: 3439:          ecma_free_value (value);
        -: 3440:
    #####: 3441:          if (ECMA_IS_VALUE_ERROR (iterator))
        -: 3442:          {
    #####: 3443:            result = iterator;
    #####: 3444:            goto error;
        -: 3445:          }
        -: 3446:
    #####: 3447:          ecma_value_t next_value = ecma_op_iterator_step (iterator);
        -: 3448:
    #####: 3449:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 3450:          {
    #####: 3451:            ecma_free_value (iterator);
    #####: 3452:            result = next_value;
    #####: 3453:            goto error;
        -: 3454:          }
        -: 3455:
    #####: 3456:          if (ecma_is_value_false (next_value))
        -: 3457:          {
    #####: 3458:            ecma_free_value (iterator);
    #####: 3459:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3460:            continue;
        -: 3461:          }
        -: 3462:
    #####: 3463:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3464:
    #####: 3465:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 3466:          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 3467:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 3468:          stack_top_p[-2] = next_value;
    #####: 3469:          stack_top_p[-3] = iterator;
        -: 3470:
    #####: 3471:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 3472:          {
        -: 3473:            /* No need to duplicate the first context. */
    #####: 3474:            byte_code_p += 2;
        -: 3475:          }
    #####: 3476:          continue;
        -: 3477:        }
    #####: 3478:        case VM_OC_FOR_OF_GET_NEXT:
        -: 3479:        {
    #####: 3480:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
    #####: 3481:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF);
        -: 3482:
    #####: 3483:          ecma_value_t next_value = ecma_op_iterator_value (context_top_p[-2]);
        -: 3484:
    #####: 3485:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 3486:          {
    #####: 3487:            result = next_value;
    #####: 3488:            goto error;
        -: 3489:          }
        -: 3490:
    #####: 3491:          *stack_top_p++ = next_value;
    #####: 3492:          continue;
        -: 3493:        }
    #####: 3494:        case VM_OC_FOR_OF_HAS_NEXT:
        -: 3495:        {
    #####: 3496:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3497:
    #####: 3498:          ecma_value_t next_value = ecma_op_iterator_step (stack_top_p[-3]);
        -: 3499:
    #####: 3500:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 3501:          {
    #####: 3502:            result = next_value;
    #####: 3503:            goto error;
        -: 3504:          }
        -: 3505:
    #####: 3506:          if (!ecma_is_value_false (next_value))
        -: 3507:          {
    #####: 3508:            ecma_free_value (stack_top_p[-2]);
    #####: 3509:            stack_top_p[-2] = next_value;
    #####: 3510:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3511:            continue;
        -: 3512:          }
        -: 3513:
    #####: 3514:          ecma_free_value (stack_top_p[-2]);
    #####: 3515:          ecma_free_value (stack_top_p[-3]);
    #####: 3516:          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 3517:          stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 3518:          continue;
        -: 3519:        }
        -: 3520:#endif /* ENABLED (JERRY_ES2015) */
    #####: 3521:        case VM_OC_TRY:
        -: 3522:        {
        -: 3523:          /* Try opcode simply creates the try context. */
    #####: 3524:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3525:
    #####: 3526:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3527:
    #####: 3528:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 3529:          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 3530:
    #####: 3531:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);
    #####: 3532:          continue;
        -: 3533:        }
    #####: 3534:        case VM_OC_CATCH:
        -: 3535:        {
        -: 3536:          /* Catches are ignored and turned to jumps. */
    #####: 3537:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 3538:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);
        -: 3539:
    #####: 3540:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 3541:          continue;
        -: 3542:        }
    #####: 3543:        case VM_OC_FINALLY:
        -: 3544:        {
    #####: 3545:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3546:
    #####: 3547:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3548:
    #####: 3549:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY
        -: 3550:                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 3551:
    #####: 3552:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 3553:          {
    #####: 3554:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 3555:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 3556:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 3557:            ecma_deref_object (lex_env_p);
        -: 3558:
    #####: 3559:            stack_top_p[-1] &= (ecma_value_t) ~VM_CONTEXT_HAS_LEX_ENV;
        -: 3560:          }
        -: 3561:
    #####: 3562:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);
    #####: 3563:          stack_top_p[-2] = (ecma_value_t) branch_offset;
    #####: 3564:          continue;
        -: 3565:        }
     1308: 3566:        case VM_OC_CONTEXT_END:
        -: 3567:        {
     1308: 3568:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
     1308: 3569:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -: 3570:
     1308: 3571:          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 3572:
     1308: 3573:          if (!VM_CONTEXT_IS_FINALLY (context_type))
        -: 3574:          {
     1308: 3575:            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 3576:
     1308: 3577:            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
     1308: 3578:            continue;
        -: 3579:          }
        -: 3580:
        -: 3581:#if ENABLED (JERRY_ES2015)
    #####: 3582:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 3583:          {
    #####: 3584:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 3585:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 3586:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 3587:            ecma_deref_object (lex_env_p);
        -: 3588:          }
        -: 3589:#endif /* ENABLED (JERRY_ES2015) */
        -: 3590:
    #####: 3591:          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth,
        -: 3592:                              PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 3593:          stack_top_p -= PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 3594:
    #####: 3595:          if (context_type == VM_CONTEXT_FINALLY_RETURN)
        -: 3596:          {
    #####: 3597:            result = *stack_top_p;
    #####: 3598:            goto error;
        -: 3599:          }
        -: 3600:
    #####: 3601:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 3602:          {
    #####: 3603:            jcontext_raise_exception (*stack_top_p);
    #####: 3604:            result = ECMA_VALUE_ERROR;
        -: 3605:
        -: 3606:#if ENABLED (JERRY_DEBUGGER)
        -: 3607:            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 3608:#endif /* ENABLED (JERRY_DEBUGGER) */
    #####: 3609:            goto error;
        -: 3610:          }
        -: 3611:
    #####: 3612:          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);
        -: 3613:
    #####: 3614:          uint32_t jump_target = *stack_top_p;
        -: 3615:
    #####: 3616:          if (vm_stack_find_finally (frame_ctx_p,
        -: 3617:                                     &stack_top_p,
        -: 3618:                                     VM_CONTEXT_FINALLY_JUMP,
        -: 3619:                                     jump_target))
        -: 3620:          {
    #####: 3621:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 3622:            byte_code_p = frame_ctx_p->byte_code_p;
    #####: 3623:            stack_top_p[-2] = jump_target;
        -: 3624:          }
        -: 3625:          else
        -: 3626:          {
    #####: 3627:            byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;
        -: 3628:          }
        -: 3629:
    #####: 3630:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 3631:          continue;
        -: 3632:        }
    #####: 3633:        case VM_OC_JUMP_AND_EXIT_CONTEXT:
        -: 3634:        {
    #####: 3635:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 3636:          JERRY_ASSERT (!jcontext_has_pending_exception ());
        -: 3637:
    #####: 3638:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3639:
    #####: 3640:          if (vm_stack_find_finally (frame_ctx_p,
        -: 3641:                                     &stack_top_p,
        -: 3642:                                     VM_CONTEXT_FINALLY_JUMP,
        -: 3643:                                     (uint32_t) branch_offset))
        -: 3644:          {
    #####: 3645:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 3646:            byte_code_p = frame_ctx_p->byte_code_p;
    #####: 3647:            stack_top_p[-2] = (uint32_t) branch_offset;
        -: 3648:          }
        -: 3649:          else
        -: 3650:          {
    #####: 3651:            byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;
        -: 3652:          }
        -: 3653:
        -: 3654:#if ENABLED (JERRY_ES2015)
    #####: 3655:          if (jcontext_has_pending_exception ())
        -: 3656:          {
    #####: 3657:            result = ECMA_VALUE_ERROR;
    #####: 3658:            goto error;
        -: 3659:          }
        -: 3660:#endif /* ENABLED (JERRY_ES2015) */
        -: 3661:
    #####: 3662:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 3663:          continue;
        -: 3664:        }
        -: 3665:#if ENABLED (JERRY_DEBUGGER)
        -: 3666:        case VM_OC_BREAKPOINT_ENABLED:
        -: 3667:        {
        -: 3668:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 3669:          {
        -: 3670:            continue;
        -: 3671:          }
        -: 3672:
        -: 3673:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 3674:
        -: 3675:          JERRY_ASSERT (!(frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 3676:
        -: 3677:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 3678:
        -: 3679:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 3680:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 3681:          {
        -: 3682:            result = ECMA_VALUE_ERROR;
        -: 3683:            goto error;
        -: 3684:          }
        -: 3685:          continue;
        -: 3686:        }
        -: 3687:        case VM_OC_BREAKPOINT_DISABLED:
        -: 3688:        {
        -: 3689:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 3690:          {
        -: 3691:            continue;
        -: 3692:          }
        -: 3693:
        -: 3694:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 3695:
        -: 3696:          JERRY_ASSERT (!(frame_ctx_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 3697:
        -: 3698:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 3699:
        -: 3700:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 3701:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 3702:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 3703:          {
        -: 3704:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 3705:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 3706:            {
        -: 3707:              result = ECMA_VALUE_ERROR;
        -: 3708:              goto error;
        -: 3709:            }
        -: 3710:            continue;
        -: 3711:          }
        -: 3712:
        -: 3713:          if (JERRY_CONTEXT (debugger_message_delay) > 0)
        -: 3714:          {
        -: 3715:            JERRY_CONTEXT (debugger_message_delay)--;
        -: 3716:            continue;
        -: 3717:          }
        -: 3718:
        -: 3719:          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;
        -: 3720:
        -: 3721:          if (jerry_debugger_receive (NULL))
        -: 3722:          {
        -: 3723:            continue;
        -: 3724:          }
        -: 3725:
        -: 3726:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 3727:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 3728:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 3729:          {
        -: 3730:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 3731:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 3732:            {
        -: 3733:              result = ECMA_VALUE_ERROR;
        -: 3734:              goto error;
        -: 3735:            }
        -: 3736:          }
        -: 3737:          continue;
        -: 3738:        }
        -: 3739:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 3740:#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)
     1311: 3741:        case VM_OC_RESOURCE_NAME:
        -: 3742:        {
     1311: 3743:          frame_ctx_p->resource_name = ecma_op_resource_name (bytecode_header_p);
     1311: 3744:          continue;
        -: 3745:        }
        -: 3746:#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 3747:#if ENABLED (JERRY_LINE_INFO)
    #####: 3748:        case VM_OC_LINE:
        -: 3749:        {
    #####: 3750:          uint32_t value = 0;
        -: 3751:          uint8_t byte;
        -: 3752:
        -: 3753:          do
        -: 3754:          {
    #####: 3755:            byte = *byte_code_p++;
    #####: 3756:            value = (value << 7) | (byte & CBC_LOWER_SEVEN_BIT_MASK);
        -: 3757:          }
    #####: 3758:          while (byte & CBC_HIGHEST_BIT_MASK);
        -: 3759:
    #####: 3760:          frame_ctx_p->current_line = value;
    #####: 3761:          continue;
        -: 3762:        }
        -: 3763:#endif /* ENABLED (JERRY_LINE_INFO) */
    #####: 3764:        case VM_OC_NONE:
        -: 3765:        default:
        -: 3766:        {
    #####: 3767:          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);
        -: 3768:
    #####: 3769:          jerry_fatal (ERR_DISABLED_BYTE_CODE);
        -: 3770:        }
        -: 3771:      }
        -: 3772:
     7859: 3773:      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));
        -: 3774:
     7859: 3775:      if (opcode_data & VM_OC_PUT_IDENT)
        -: 3776:      {
        -: 3777:        uint16_t literal_index;
        -: 3778:
     5241: 3779:        READ_LITERAL_INDEX (literal_index);
        -: 3780:
     5241: 3781:        if (literal_index < register_end)
        -: 3782:        {
    #####: 3783:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 3784:          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
        -: 3785:
    #####: 3786:          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))
        -: 3787:          {
    #####: 3788:            result = ecma_fast_copy_value (result);
        -: 3789:          }
        -: 3790:        }
        -: 3791:        else
        -: 3792:        {
     5241: 3793:          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 3794:
     5241: 3795:          ecma_value_t put_value_result = ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 3796:                                                                          var_name_str_p,
        -: 3797:                                                                          is_strict,
        -: 3798:                                                                          result);
        -: 3799:
     5241: 3800:          if (ECMA_IS_VALUE_ERROR (put_value_result))
        -: 3801:          {
    #####: 3802:            ecma_free_value (result);
    #####: 3803:            result = put_value_result;
    #####: 3804:            goto error;
        -: 3805:          }
        -: 3806:
     5241: 3807:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 3808:          {
     5241: 3809:            ecma_fast_free_value (result);
        -: 3810:          }
        -: 3811:        }
        -: 3812:      }
     2618: 3813:      else if (opcode_data & VM_OC_PUT_REFERENCE)
        -: 3814:      {
     1309: 3815:        ecma_value_t property = *(--stack_top_p);
     1309: 3816:        ecma_value_t object = *(--stack_top_p);
        -: 3817:
     1309: 3818:        if (object == ECMA_VALUE_REGISTER_REF)
        -: 3819:        {
    #####: 3820:          property = (ecma_value_t) ecma_get_integer_from_value (property);
    #####: 3821:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));
    #####: 3822:          VM_GET_REGISTER (frame_ctx_p, property) = result;
        -: 3823:
    #####: 3824:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 3825:          {
    #####: 3826:            goto free_both_values;
        -: 3827:          }
    #####: 3828:          result = ecma_fast_copy_value (result);
        -: 3829:        }
        -: 3830:        else
        -: 3831:        {
     1309: 3832:          ecma_value_t set_value_result = vm_op_set_value (object,
        -: 3833:                                                           property,
        -: 3834:                                                           result,
        -: 3835:                                                           is_strict);
        -: 3836:
     1309: 3837:          if (ECMA_IS_VALUE_ERROR (set_value_result))
        -: 3838:          {
    #####: 3839:            ecma_free_value (result);
    #####: 3840:            result = set_value_result;
    #####: 3841:            goto error;
        -: 3842:          }
        -: 3843:
     1309: 3844:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 3845:          {
     1309: 3846:            ecma_fast_free_value (result);
     1309: 3847:            goto free_both_values;
        -: 3848:          }
        -: 3849:        }
        -: 3850:      }
        -: 3851:
     6550: 3852:      if (opcode_data & VM_OC_PUT_STACK)
        -: 3853:      {
     1309: 3854:        *stack_top_p++ = result;
        -: 3855:      }
     5241: 3856:      else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 3857:      {
    #####: 3858:        ecma_fast_free_value (frame_ctx_p->block_result);
    #####: 3859:        frame_ctx_p->block_result = result;
        -: 3860:      }
        -: 3861:
    13104: 3862:free_both_values:
     7863: 3863:      ecma_fast_free_value (right_value);
     9172: 3864:free_left_value:
     9172: 3865:      ecma_fast_free_value (left_value);
        -: 3866:    }
        -: 3867:
     1308: 3868:error:
     1308: 3869:    ecma_fast_free_value (left_value);
     1308: 3870:    ecma_fast_free_value (right_value);
        -: 3871:
     1308: 3872:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3873:    {
     1308: 3874:      JERRY_ASSERT (jcontext_has_pending_exception ());
     1308: 3875:      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 3876:
     3924: 3877:      while (stack_top_p > stack_bottom_p)
        -: 3878:      {
     1308: 3879:        ecma_value_t stack_item = *(--stack_top_p);
        -: 3880:#if ENABLED (JERRY_ES2015)
     1308: 3881:        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 3882:        {
    #####: 3883:          opfunc_pop_lexical_environment (frame_ctx_p);
    #####: 3884:          continue;
        -: 3885:        }
        -: 3886:#endif /* ENABLED (JERRY_ES2015) */
     1308: 3887:        ecma_fast_free_value (stack_item);
        -: 3888:      }
        -: 3889:
        -: 3890:#if ENABLED (JERRY_DEBUGGER)
        -: 3891:      const uint32_t dont_stop = (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION
        -: 3892:                                  | JERRY_DEBUGGER_VM_IGNORE
        -: 3893:                                  | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 3894:
        -: 3895:      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 3896:          && !(frame_ctx_p->bytecode_header_p->status_flags
        -: 3897:               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 3898:          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))
        -: 3899:      {
        -: 3900:        /* Save the error to a local value, because the engine enters breakpoint mode after,
        -: 3901:           therefore an evaluation error, or user-created error throw would overwrite it. */
        -: 3902:        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);
        -: 3903:
        -: 3904:        if (jerry_debugger_send_exception_string (current_error_value))
        -: 3905:        {
        -: 3906:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);
        -: 3907:
        -: 3908:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 3909:          {
        -: 3910:            ecma_free_value (current_error_value);
        -: 3911:          }
        -: 3912:          else
        -: 3913:          {
        -: 3914:            JERRY_CONTEXT (error_value) = current_error_value;
        -: 3915:          }
        -: 3916:
        -: 3917:          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 3918:        }
        -: 3919:      }
        -: 3920:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 3921:    }
        -: 3922:
     1308: 3923:    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3924:
     1308: 3925:    if (frame_ctx_p->context_depth == 0)
        -: 3926:    {
        -: 3927:      /* In most cases there is no context. */
        -: 3928:
     1308: 3929:      ecma_fast_free_value (frame_ctx_p->block_result);
     1308: 3930:      frame_ctx_p->call_operation = VM_NO_EXEC_OP;
     1308: 3931:      return result;
        -: 3932:    }
        -: 3933:
    #####: 3934:    if (!ECMA_IS_VALUE_ERROR (result))
        -: 3935:    {
    #####: 3936:      if (vm_stack_find_finally (frame_ctx_p,
        -: 3937:                                 &stack_top_p,
        -: 3938:                                 VM_CONTEXT_FINALLY_RETURN,
        -: 3939:                                 0))
        -: 3940:      {
    #####: 3941:        JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 3942:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 3943:
        -: 3944:#if ENABLED (JERRY_ES2015)
    #####: 3945:        if (jcontext_has_pending_exception ())
        -: 3946:        {
    #####: 3947:          stack_top_p[-1] = (ecma_value_t) (stack_top_p[-1] - VM_CONTEXT_FINALLY_RETURN + VM_CONTEXT_FINALLY_THROW);
    #####: 3948:          ecma_free_value (result);
    #####: 3949:          result = jcontext_take_exception ();
        -: 3950:        }
        -: 3951:#endif /* ENABLED (JERRY_ES2015) */
        -: 3952:
    #####: 3953:        byte_code_p = frame_ctx_p->byte_code_p;
    #####: 3954:        stack_top_p[-2] = result;
    #####: 3955:        continue;
        -: 3956:      }
        -: 3957:
        -: 3958:#if ENABLED (JERRY_ES2015)
    #####: 3959:      if (jcontext_has_pending_exception ())
        -: 3960:      {
    #####: 3961:        ecma_free_value (result);
    #####: 3962:        result = ECMA_VALUE_ERROR;
        -: 3963:      }
        -: 3964:#endif /* ENABLED (JERRY_ES2015) */
        -: 3965:    }
    #####: 3966:    else if (jcontext_has_pending_exception () && !jcontext_has_pending_abort ())
        -: 3967:    {
    #####: 3968:      if (vm_stack_find_finally (frame_ctx_p,
        -: 3969:                                 &stack_top_p,
        -: 3970:                                 VM_CONTEXT_FINALLY_THROW,
        -: 3971:                                 0))
        -: 3972:      {
    #####: 3973:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 3974:        JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 3975:
        -: 3976:#if ENABLED (JERRY_DEBUGGER)
        -: 3977:        JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 3978:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 3979:
    #####: 3980:        result = jcontext_take_exception ();
        -: 3981:
    #####: 3982:        byte_code_p = frame_ctx_p->byte_code_p;
        -: 3983:
    #####: 3984:        if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)
        -: 3985:        {
    #####: 3986:          stack_top_p[-2] = result;
    #####: 3987:          continue;
        -: 3988:        }
        -: 3989:
    #####: 3990:        JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 3991:
    #####: 3992:        *stack_top_p++ = result;
    #####: 3993:        continue;
        -: 3994:      }
        -: 3995:    }
        -: 3996:    else
        -: 3997:    {
        -: 3998:      do
        -: 3999:      {
    #####: 4000:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4001:
    #####: 4002:        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4003:      }
    #####: 4004:      while (frame_ctx_p->context_depth > 0);
        -: 4005:    }
        -: 4006:
    #####: 4007:    ecma_free_value (frame_ctx_p->block_result);
    #####: 4008:    frame_ctx_p->call_operation = VM_NO_EXEC_OP;
        -: 4009:
    #####: 4010:    return result;
        -: 4011:  }
        -: 4012:} /* vm_loop */
        -: 4013:
        -: 4014:#undef READ_LITERAL
        -: 4015:#undef READ_LITERAL_INDEX
        -: 4016:
        -: 4017:/**
        -: 4018: * Initialize code block execution
        -: 4019: *
        -: 4020: * @return ECMA_VALUE_ERROR - if the initialization fails
        -: 4021: *         ECMA_VALUE_EMPTY - otherwise
        -: 4022: */
        -: 4023:static void JERRY_ATTR_NOINLINE
     1311: 4024:vm_init_exec (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 4025:              const ecma_value_t *arg_p, /**< arguments list */
        -: 4026:              ecma_length_t arg_list_len) /**< length of arguments list */
        -: 4027:{
     1311: 4028:  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);
     1311: 4029:  frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;
        -: 4030:#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)
     1311: 4031:  frame_ctx_p->resource_name = ECMA_VALUE_UNDEFINED;
        -: 4032:#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 4033:#if ENABLED (JERRY_LINE_INFO)
    #####: 4034:  frame_ctx_p->current_line = 0;
        -: 4035:#endif /* ENABLED (JERRY_LINE_INFO) */
     1311: 4036:  frame_ctx_p->context_depth = 0;
     1311: 4037:  frame_ctx_p->is_eval_code = (arg_p == VM_DIRECT_EVAL);
        -: 4038:
     1311: 4039:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->bytecode_header_p;
        -: 4040:  uint16_t argument_end, register_end;
        -: 4041:  ecma_value_t *literal_p;
        -: 4042:
     1311: 4043:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 4044:  {
    #####: 4045:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -: 4046:
    #####: 4047:    argument_end = args_p->argument_end;
    #####: 4048:    register_end = args_p->register_end;
        -: 4049:
    #####: 4050:    literal_p = (ecma_value_t *) ((uint8_t *) bytecode_header_p + sizeof (cbc_uint16_arguments_t));
    #####: 4051:    literal_p -= register_end;
    #####: 4052:    frame_ctx_p->literal_start_p = literal_p;
    #####: 4053:    literal_p += args_p->literal_end;
        -: 4054:  }
        -: 4055:  else
        -: 4056:  {
     1311: 4057:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -: 4058:
     1311: 4059:    argument_end = args_p->argument_end;
     1311: 4060:    register_end = args_p->register_end;
        -: 4061:
     1311: 4062:    literal_p = (ecma_value_t *) ((uint8_t *) bytecode_header_p + sizeof (cbc_uint8_arguments_t));
     1311: 4063:    literal_p -= register_end;
     1311: 4064:    frame_ctx_p->literal_start_p = literal_p;
     1311: 4065:    literal_p += args_p->literal_end;
        -: 4066:  }
        -: 4067:
     1311: 4068:  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;
     1311: 4069:  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;
     1311: 4070:  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;
        -: 4071:
        -: 4072:#if ENABLED (JERRY_ES2015)
     1311: 4073:  uint32_t function_call_argument_count = arg_list_len;
        -: 4074:#endif /* ENABLED (JERRY_ES2015) */
        -: 4075:
     1311: 4076:  if (arg_list_len > argument_end)
        -: 4077:  {
    #####: 4078:    arg_list_len = argument_end;
        -: 4079:  }
        -: 4080:
     3929: 4081:  for (uint32_t i = 0; i < arg_list_len; i++)
        -: 4082:  {
     2618: 4083:    VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_p[i]);
        -: 4084:  }
        -: 4085:
        -: 4086:  /* The arg_list_len contains the end of the copied arguments.
        -: 4087:   * Fill everything else with undefined. */
     1311: 4088:  if (register_end > arg_list_len)
        -: 4089:  {
     1309: 4090:    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;
        -: 4091:
     2618: 4092:    for (uint32_t i = arg_list_len; i < register_end; i++)
        -: 4093:    {
     1309: 4094:      *stack_p++ = ECMA_VALUE_UNDEFINED;
        -: 4095:    }
        -: 4096:  }
        -: 4097:
        -: 4098:#if ENABLED (JERRY_ES2015)
     1311: 4099:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_REST_PARAMETER)
        -: 4100:  {
    #####: 4101:    JERRY_ASSERT (function_call_argument_count >= arg_list_len);
    #####: 4102:    ecma_value_t new_array = ecma_op_create_array_object (arg_p + arg_list_len,
        -: 4103:                                                          function_call_argument_count - arg_list_len,
        -: 4104:                                                          false);
    #####: 4105:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_array));
    #####: 4106:    VM_GET_REGISTER (frame_ctx_p, argument_end) = new_array;
        -: 4107:  }
        -: 4108:#endif /* ENABLED (JERRY_ES2015) */
        -: 4109:
     1311: 4110:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
     1311: 4111:  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;
     1311: 4112:} /* vm_init_exec */
        -: 4113:
        -: 4114:/**
        -: 4115: * Resume execution of a code block.
        -: 4116: *
        -: 4117: * @return ecma value
        -: 4118: */
        -: 4119:ecma_value_t JERRY_ATTR_NOINLINE
     5238: 4120:vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 4121:{
        -: 4122:  while (true)
     3927: 4123:  {
     5238: 4124:    ecma_value_t completion_value = vm_loop (frame_ctx_p);
        -: 4125:
     5238: 4126:    switch (frame_ctx_p->call_operation)
        -: 4127:    {
     2619: 4128:      case VM_EXEC_CALL:
        -: 4129:      {
     2619: 4130:        opfunc_call (frame_ctx_p);
     2617: 4131:        break;
        -: 4132:      }
        -: 4133:#if ENABLED (JERRY_ES2015)
    #####: 4134:      case VM_EXEC_SUPER_CALL:
        -: 4135:      {
    #####: 4136:        vm_super_call (frame_ctx_p);
    #####: 4137:        break;
        -: 4138:      }
    #####: 4139:      case VM_EXEC_SPREAD_OP:
        -: 4140:      {
    #####: 4141:        vm_spread_operation (frame_ctx_p);
    #####: 4142:        break;
        -: 4143:      }
    #####: 4144:      case VM_EXEC_RETURN:
        -: 4145:      {
    #####: 4146:        return completion_value;
        -: 4147:      }
        -: 4148:#endif /* ENABLED (JERRY_ES2015) */
     1311: 4149:      case VM_EXEC_CONSTRUCT:
        -: 4150:      {
     1311: 4151:        opfunc_construct (frame_ctx_p);
     1310: 4152:        break;
        -: 4153:      }
     1308: 4154:      default:
        -: 4155:      {
     1308: 4156:        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);
        -: 4157:
     1308: 4158:        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->bytecode_header_p;
        -: 4159:        uint32_t register_end;
        -: 4160:
     1308: 4161:        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 4162:        {
    #####: 4163:          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;
        -: 4164:        }
        -: 4165:        else
        -: 4166:        {
     1308: 4167:          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;
        -: 4168:        }
        -: 4169:
        -: 4170:        /* Free arguments and registers */
     1308: 4171:        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);
     5232: 4172:        for (uint32_t i = 0; i < register_end; i++)
        -: 4173:        {
     3924: 4174:          ecma_fast_free_value (registers_p[i]);
        -: 4175:        }
        -: 4176:
        -: 4177:#if ENABLED (JERRY_DEBUGGER)
        -: 4178:        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))
        -: 4179:        {
        -: 4180:          /* The engine will stop when the next breakpoint is reached. */
        -: 4181:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);
        -: 4182:          JERRY_CONTEXT (debugger_stop_context) = NULL;
        -: 4183:        }
        -: 4184:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 4185:
     1308: 4186:        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;
     1308: 4187:        return completion_value;
        -: 4188:      }
        -: 4189:    }
        -: 4190:  }
        -: 4191:} /* vm_execute */
        -: 4192:
        -: 4193:/**
        -: 4194: * Run the code.
        -: 4195: *
        -: 4196: * @return ecma value
        -: 4197: */
        -: 4198:ecma_value_t
     1311: 4199:vm_run (const ecma_compiled_code_t *bytecode_header_p, /**< byte-code data header */
        -: 4200:        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */
        -: 4201:        ecma_object_t *lex_env_p, /**< lexical environment to use */
        -: 4202:        const ecma_value_t *arg_list_p, /**< arguments list */
        -: 4203:        ecma_length_t arg_list_len) /**< length of arguments list */
     1311: 4204:{
        -: 4205:  vm_frame_ctx_t *frame_ctx_p;
        -: 4206:  size_t frame_size;
        -: 4207:
     1311: 4208:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 4209:  {
    #####: 4210:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####: 4211:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 4212:  }
        -: 4213:  else
        -: 4214:  {
     1311: 4215:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
     1311: 4216:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 4217:  }
        -: 4218:
     1311: 4219:  frame_size = frame_size * sizeof (ecma_value_t) + sizeof (vm_frame_ctx_t);
     1311: 4220:  frame_size = (frame_size + sizeof (uintptr_t) - 1) / sizeof (uintptr_t);
        -: 4221:
        -: 4222:  /* Use JERRY_MAX() to avoid array declaration with size 0. */
     1311: 4223:  JERRY_VLA (uintptr_t, stack, frame_size);
        -: 4224:
     1311: 4225:  frame_ctx_p = (vm_frame_ctx_t *) stack;
        -: 4226:
     1311: 4227:  frame_ctx_p->bytecode_header_p = bytecode_header_p;
     1311: 4228:  frame_ctx_p->lex_env_p = lex_env_p;
     1311: 4229:  frame_ctx_p->this_binding = this_binding_value;
        -: 4230:
     1311: 4231:  vm_init_exec (frame_ctx_p, arg_list_p, arg_list_len);
     1311: 4232:  return vm_execute (frame_ctx_p);
        -: 4233:} /* vm_run */
        -: 4234:
        -: 4235:/**
        -: 4236: * @}
        -: 4237: * @}
        -: 4238: */
