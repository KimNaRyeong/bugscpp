        -:    0:Source:/home/workspace/jerry-port/default/default-module.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#if !defined (WIN32)
        -:   17:#include <libgen.h>
        -:   18:#endif /* !defined (WIN32) */
        -:   19:#include <limits.h>
        -:   20:#include <stdarg.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:#include "jerryscript-port.h"
        -:   25:#include "jerryscript-port-default.h"
        -:   26:
        -:   27:/**
        -:   28: * Determines the size of the given file.
        -:   29: * @return size of the file
        -:   30: */
        -:   31:static size_t
    #####:   32:jerry_port_get_file_size (FILE *file_p) /**< opened file */
        -:   33:{
    #####:   34:  fseek (file_p, 0, SEEK_END);
    #####:   35:  long size = ftell (file_p);
    #####:   36:  fseek (file_p, 0, SEEK_SET);
        -:   37:
    #####:   38:  return (size_t) size;
        -:   39:} /* jerry_port_get_file_size */
        -:   40:
        -:   41:/**
        -:   42: * Opens file with the given path and reads its source.
        -:   43: * @return the source of the file
        -:   44: */
        -:   45:uint8_t *
    #####:   46:jerry_port_read_source (const char *file_name_p, /**< file name */
        -:   47:                        size_t *out_size_p) /**< [out] read bytes */
        -:   48:{
    #####:   49:  FILE *file_p = fopen (file_name_p, "rb");
        -:   50:
    #####:   51:  if (file_p == NULL)
        -:   52:  {
    #####:   53:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: failed to open file: %s\n", file_name_p);
    #####:   54:    return NULL;
        -:   55:  }
        -:   56:
    #####:   57:  size_t file_size = jerry_port_get_file_size (file_p);
    #####:   58:  uint8_t *buffer_p = (uint8_t *) malloc (file_size);
        -:   59:
    #####:   60:  if (buffer_p == NULL)
        -:   61:  {
    #####:   62:    fclose (file_p);
        -:   63:
    #####:   64:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: failed to allocate memory for module");
    #####:   65:    return NULL;
        -:   66:  }
        -:   67:
    #####:   68:  size_t bytes_read = fread (buffer_p, 1u, file_size, file_p);
        -:   69:
    #####:   70:  if (!bytes_read)
        -:   71:  {
    #####:   72:    fclose (file_p);
    #####:   73:    free (buffer_p);
        -:   74:
    #####:   75:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: failed to read file: %s\n", file_name_p);
    #####:   76:    return NULL;
        -:   77:  }
        -:   78:
    #####:   79:  fclose (file_p);
    #####:   80:  *out_size_p = bytes_read;
        -:   81:
    #####:   82:  return buffer_p;
        -:   83:} /* jerry_port_read_source */
        -:   84:
        -:   85:/**
        -:   86: * Release the previously opened file's content.
        -:   87: */
        -:   88:void
    #####:   89:jerry_port_release_source (uint8_t *buffer_p) /**< buffer to free */
        -:   90:{
    #####:   91:  free (buffer_p);
    #####:   92:} /* jerry_port_release_source */
        -:   93:
        -:   94:/**
        -:   95: * Normalize a file path
        -:   96: *
        -:   97: * @return length of the path written to the output buffer
        -:   98: */
        -:   99:size_t
    #####:  100:jerry_port_normalize_path (const char *in_path_p,   /**< input file path */
        -:  101:                           char *out_buf_p,         /**< output buffer */
        -:  102:                           size_t out_buf_size,     /**< size of output buffer */
        -:  103:                           char *base_file_p)       /**< base file path */
        -:  104:{
    #####:  105:  size_t ret = 0;
        -:  106:
        -:  107:#if defined (WIN32)
        -:  108:  char drive[_MAX_DRIVE];
        -:  109:  char *dir_p = (char *) malloc (_MAX_DIR);
        -:  110:
        -:  111:  char *path_p = (char *) malloc (_MAX_PATH * 2);
        -:  112:  *path_p = '\0';
        -:  113:
        -:  114:  if (base_file_p != NULL)
        -:  115:  {
        -:  116:    _splitpath_s (base_file_p,
        -:  117:                  &drive,
        -:  118:                  _MAX_DRIVE,
        -:  119:                  dir_p,
        -:  120:                  _MAX_DIR,
        -:  121:                  NULL,
        -:  122:                  0,
        -:  123:                  NULL,
        -:  124:                  0);
        -:  125:    strncat (path_p, &drive, _MAX_DRIVE);
        -:  126:    strncat (path_p, dir_p, _MAX_DIR);
        -:  127:  }
        -:  128:
        -:  129:  strncat (path_p, in_path_p, _MAX_PATH);
        -:  130:
        -:  131:  char *norm_p = _fullpath (out_buf_p, path_p, out_buf_size);
        -:  132:
        -:  133:  free (path_p);
        -:  134:  free (dir_p);
        -:  135:
        -:  136:  if (norm_p != NULL)
        -:  137:  {
        -:  138:    ret = strnlen (norm_p, out_buf_size);
        -:  139:  }
        -:  140:#elif defined (__unix__) || defined (__APPLE__)
        -:  141:#define MAX_JERRY_PATH_SIZE 256
    #####:  142:  char *buffer_p = (char *) malloc (PATH_MAX);
    #####:  143:  char *path_p = (char *) malloc (PATH_MAX);
        -:  144:
    #####:  145:  char *base_p = dirname (base_file_p);
    #####:  146:  strncpy (path_p, base_p, MAX_JERRY_PATH_SIZE);
    #####:  147:  strncat (path_p, "/", 1);
    #####:  148:  strncat (path_p, in_path_p, MAX_JERRY_PATH_SIZE);
        -:  149:
    #####:  150:  char *norm_p = realpath (path_p, buffer_p);
    #####:  151:  free (path_p);
        -:  152:
    #####:  153:  if (norm_p != NULL)
        -:  154:  {
    #####:  155:    const size_t len = strnlen (norm_p, out_buf_size);
    #####:  156:    if (len < out_buf_size)
        -:  157:    {
    #####:  158:      strncpy (out_buf_p, norm_p, out_buf_size);
    #####:  159:      ret = len;
        -:  160:    }
        -:  161:  }
        -:  162:
    #####:  163:  free (buffer_p);
        -:  164:#undef MAX_JERRY_PATH_SIZE
        -:  165:#else
        -:  166:  (void) base_file_p;
        -:  167:
        -:  168:  /* Do nothing, just copy the input. */
        -:  169:  const size_t len = strnlen (in_path_p, out_buf_size);
        -:  170:  if (len < out_buf_size)
        -:  171:  {
        -:  172:    strncpy (out_buf_p, in_path_p, out_buf_size);
        -:  173:    ret = len;
        -:  174:  }
        -:  175:#endif
        -:  176:
    #####:  177:  return ret;
        -:  178:} /* jerry_port_normalize_path */
        -:  179:
        -:  180:/**
        -:  181: * Get the module object of a native module.
        -:  182: *
        -:  183: * @return Undefined, if 'name' is not a native module
        -:  184: *         jerry_value_t containing the module object, otherwise
        -:  185: */
        -:  186:jerry_value_t
    #####:  187:jerry_port_get_native_module (jerry_value_t name) /**< module specifier */
        -:  188:{
        -:  189:  (void) name;
    #####:  190:  return jerry_create_undefined ();
        -:  191:} /* jerry_port_get_native_module */
