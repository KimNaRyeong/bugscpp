        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-arraybuffer-object.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-arraybuffer-object.h"
        -:   17:#include "ecma-try-catch-macro.h"
        -:   18:#include "ecma-objects.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-exceptions.h"
        -:   21:#include "ecma-gc.h"
        -:   22:#include "ecma-globals.h"
        -:   23:#include "ecma-helpers.h"
        -:   24:#include "jmem.h"
        -:   25:
        -:   26:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -:   27:
        -:   28:/** \addtogroup ecma ECMA
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup ecmaarraybufferobject ECMA ArrayBuffer object related routines
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:/**
        -:   36: * Helper function: create arraybuffer object based on the array length
        -:   37: *
        -:   38: * The struct of arraybuffer object:
        -:   39: *   ecma_object_t
        -:   40: *   extend_part
        -:   41: *   data buffer
        -:   42: *
        -:   43: * @return ecma_object_t *
        -:   44: */
        -:   45:ecma_object_t *
        2:   46:ecma_arraybuffer_new_object (ecma_length_t length) /**< length of the arraybuffer */
        -:   47:{
        2:   48:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE);
        2:   49:  ecma_object_t *object_p = ecma_create_object (prototype_obj_p,
        -:   50:                                                sizeof (ecma_extended_object_t) + length,
        -:   51:                                                ECMA_OBJECT_TYPE_CLASS);
        -:   52:
        2:   53:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        2:   54:  ext_object_p->u.class_prop.extra_info = ECMA_ARRAYBUFFER_INTERNAL_MEMORY;
        2:   55:  ext_object_p->u.class_prop.class_id = LIT_MAGIC_STRING_ARRAY_BUFFER_UL;
        2:   56:  ext_object_p->u.class_prop.u.length = length;
        -:   57:
        2:   58:  lit_utf8_byte_t *buf = (lit_utf8_byte_t *) (ext_object_p + 1);
        2:   59:  memset (buf, 0, length);
        -:   60:
        2:   61:  return object_p;
        -:   62:} /* ecma_arraybuffer_new_object */
        -:   63:
        -:   64:/**
        -:   65: * Helper function: create arraybuffer object with external buffer backing.
        -:   66: *
        -:   67: * The struct of external arraybuffer object:
        -:   68: *   ecma_object_t
        -:   69: *   extend_part
        -:   70: *   arraybuffer external info part
        -:   71: *
        -:   72: * @return ecma_object_t *, pointer to the created ArrayBuffer object
        -:   73: */
        -:   74:ecma_object_t *
    #####:   75:ecma_arraybuffer_new_object_external (ecma_length_t length, /**< length of the buffer_p to use */
        -:   76:                                      void *buffer_p, /**< pointer for ArrayBuffer's buffer backing */
        -:   77:                                      ecma_object_native_free_callback_t free_cb) /**< buffer free callback */
        -:   78:{
    #####:   79:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE);
    #####:   80:  ecma_object_t *object_p = ecma_create_object (prototype_obj_p,
        -:   81:                                                sizeof (ecma_arraybuffer_external_info),
        -:   82:                                                ECMA_OBJECT_TYPE_CLASS);
        -:   83:
    #####:   84:  ecma_arraybuffer_external_info *array_object_p = (ecma_arraybuffer_external_info *) object_p;
    #####:   85:  array_object_p->extended_object.u.class_prop.extra_info = ECMA_ARRAYBUFFER_EXTERNAL_MEMORY;
    #####:   86:  array_object_p->extended_object.u.class_prop.class_id = LIT_MAGIC_STRING_ARRAY_BUFFER_UL;
    #####:   87:  array_object_p->extended_object.u.class_prop.u.length = length;
        -:   88:
    #####:   89:  array_object_p->buffer_p = buffer_p;
    #####:   90:  array_object_p->free_cb = free_cb;
        -:   91:
    #####:   92:  return object_p;
        -:   93:} /* ecma_arraybuffer_new_object_external */
        -:   94:
        -:   95:/**
        -:   96: * ArrayBuffer object creation operation.
        -:   97: *
        -:   98: * See also: ES2015 24.1.1.1
        -:   99: *
        -:  100: * @return ecma value
        -:  101: *         Returned value must be freed with ecma_free_value
        -:  102: */
        -:  103:ecma_value_t
    #####:  104:ecma_op_create_arraybuffer_object (const ecma_value_t *arguments_list_p, /**< list of arguments that
        -:  105:                                                                          *   are passed to String constructor */
        -:  106:                                   ecma_length_t arguments_list_len) /**< length of the arguments' list */
        -:  107:{
    #####:  108:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -:  109:
    #####:  110:  ecma_number_t length_num = 0;
        -:  111:
    #####:  112:  if (arguments_list_len > 0)
        -:  113:  {
        -:  114:
    #####:  115:    if (ecma_is_value_number (arguments_list_p[0]))
        -:  116:    {
    #####:  117:      length_num = ecma_get_number_from_value (arguments_list_p[0]);
        -:  118:    }
        -:  119:    else
        -:  120:    {
    #####:  121:      ecma_value_t to_number_value = ecma_op_to_number (arguments_list_p[0]);
        -:  122:
    #####:  123:      if (ECMA_IS_VALUE_ERROR (to_number_value))
        -:  124:      {
    #####:  125:        return to_number_value;
        -:  126:      }
        -:  127:
    #####:  128:      length_num = ecma_get_number_from_value (to_number_value);
        -:  129:
    #####:  130:      ecma_free_value (to_number_value);
        -:  131:    }
        -:  132:
    #####:  133:    if (ecma_number_is_nan (length_num))
        -:  134:    {
    #####:  135:      length_num = 0;
        -:  136:    }
        -:  137:
    #####:  138:    const uint32_t maximum_size_in_byte = UINT32_MAX - sizeof (ecma_extended_object_t) - JMEM_ALIGNMENT + 1;
        -:  139:
    #####:  140:    if (length_num <= -1.0 || length_num > (ecma_number_t) maximum_size_in_byte + 0.5)
        -:  141:    {
    #####:  142:      return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid ArrayBuffer length."));
        -:  143:    }
        -:  144:  }
        -:  145:
    #####:  146:  uint32_t length_uint32 = ecma_number_to_uint32 (length_num);
        -:  147:
    #####:  148:  return ecma_make_object_value (ecma_arraybuffer_new_object (length_uint32));
        -:  149:} /* ecma_op_create_arraybuffer_object */
        -:  150:
        -:  151:/**
        -:  152: * Helper function: check if the target is ArrayBuffer
        -:  153: *
        -:  154: *
        -:  155: * See also: ES2015 24.1.1.4
        -:  156: *
        -:  157: * @return true - if value is an ArrayBuffer object
        -:  158: *         false - otherwise
        -:  159: */
        -:  160:bool
    #####:  161:ecma_is_arraybuffer (ecma_value_t target) /**< the target value */
        -:  162:{
    #####:  163:  return (ecma_is_value_object (target)
    #####:  164:          && ecma_object_class_is (ecma_get_object_from_value (target),
        -:  165:                                   LIT_MAGIC_STRING_ARRAY_BUFFER_UL));
        -:  166:} /* ecma_is_arraybuffer */
        -:  167:
        -:  168:/**
        -:  169: * Helper function: return the length of the buffer inside the arraybuffer object
        -:  170: *
        -:  171: * @return ecma_length_t, the length of the arraybuffer
        -:  172: */
        -:  173:ecma_length_t JERRY_ATTR_PURE
    #####:  174:ecma_arraybuffer_get_length (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  175:{
    #####:  176:  JERRY_ASSERT (ecma_object_class_is (object_p, LIT_MAGIC_STRING_ARRAY_BUFFER_UL));
        -:  177:
    #####:  178:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  179:  return ext_object_p->u.class_prop.u.length;
        -:  180:} /* ecma_arraybuffer_get_length */
        -:  181:
        -:  182:/**
        -:  183: * Helper function: return the pointer to the data buffer inside the arraybuffer object
        -:  184: *
        -:  185: * @return pointer to the data buffer
        -:  186: */
        -:  187:inline lit_utf8_byte_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  188:ecma_arraybuffer_get_buffer (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  189:{
    #####:  190:  JERRY_ASSERT (ecma_object_class_is (object_p, LIT_MAGIC_STRING_ARRAY_BUFFER_UL));
        -:  191:
    #####:  192:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  193:
    #####:  194:  if (ECMA_ARRAYBUFFER_HAS_EXTERNAL_MEMORY (ext_object_p))
        -:  195:  {
    #####:  196:    ecma_arraybuffer_external_info *array_p = (ecma_arraybuffer_external_info *) ext_object_p;
    #####:  197:    return (lit_utf8_byte_t *) array_p->buffer_p;
        -:  198:  }
        -:  199:  else
        -:  200:  {
    #####:  201:    return (lit_utf8_byte_t *) (ext_object_p + 1);
        -:  202:  }
        -:  203:} /* ecma_arraybuffer_get_buffer */
        -:  204:
        -:  205:/**
        -:  206: * Helper function: check if the target ArrayBuffer is detached
        -:  207: *
        -:  208: * @return true - if value is an detached ArrayBuffer object
        -:  209: *         false - otherwise
        -:  210: */
        -:  211:inline bool JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  212:ecma_arraybuffer_is_detached (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  213:{
    #####:  214:  JERRY_ASSERT (ecma_object_class_is (object_p, LIT_MAGIC_STRING_ARRAY_BUFFER_UL));
        -:  215:
    #####:  216:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  217:
    #####:  218:  if (ECMA_ARRAYBUFFER_HAS_EXTERNAL_MEMORY (ext_object_p))
        -:  219:  {
    #####:  220:    ecma_arraybuffer_external_info *array_p = (ecma_arraybuffer_external_info *) ext_object_p;
        -:  221:    /* in case the arraybuffer has been detached */
    #####:  222:    return array_p->buffer_p == NULL;
        -:  223:  }
        -:  224:
    #####:  225:  return false;
        -:  226:} /* ecma_arraybuffer_is_detached */
        -:  227:
        -:  228:/**
        -:  229: * Helper function: check if the target ArrayBuffer is detachable
        -:  230: *
        -:  231: * @return true - if value is an detachable ArrayBuffer object
        -:  232: *         false - otherwise
        -:  233: */
        -:  234:inline bool JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  235:ecma_arraybuffer_is_detachable (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  236:{
    #####:  237:  JERRY_ASSERT (ecma_object_class_is (object_p, LIT_MAGIC_STRING_ARRAY_BUFFER_UL));
        -:  238:
    #####:  239:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  240:
    #####:  241:  if (ECMA_ARRAYBUFFER_HAS_EXTERNAL_MEMORY (ext_object_p))
        -:  242:  {
    #####:  243:    ecma_arraybuffer_external_info *array_p = (ecma_arraybuffer_external_info *) ext_object_p;
        -:  244:    /* in case the arraybuffer has been detached */
    #####:  245:    return array_p->buffer_p != NULL;
        -:  246:  }
        -:  247:
    #####:  248:  return false;
        -:  249:} /* ecma_arraybuffer_is_detachable */
        -:  250:
        -:  251:/**
        -:  252: * ArrayBuffer object detaching operation
        -:  253: *
        -:  254: * See also: ES2015 24.1.1.3
        -:  255: *
        -:  256: * @return true - if detach op succeeded
        -:  257: *         false - otherwise
        -:  258: */
        -:  259:inline bool JERRY_ATTR_ALWAYS_INLINE
    #####:  260:ecma_arraybuffer_detach (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  261:{
    #####:  262:  JERRY_ASSERT (ecma_object_class_is (object_p, LIT_MAGIC_STRING_ARRAY_BUFFER_UL));
        -:  263:
    #####:  264:  if (!ecma_arraybuffer_is_detachable (object_p))
        -:  265:  {
    #####:  266:    return false;
        -:  267:  }
        -:  268:
    #####:  269:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  270:
    #####:  271:  ecma_arraybuffer_external_info *array_object_p = (ecma_arraybuffer_external_info *) ext_object_p;
    #####:  272:  array_object_p->buffer_p = NULL;
    #####:  273:  array_object_p->extended_object.u.class_prop.u.length = 0;
        -:  274:
    #####:  275:  return true;
        -:  276:} /* ecma_arraybuffer_detach */
        -:  277:
        -:  278:/**
        -:  279: * @}
        -:  280: * @}
        -:  281: */
        -:  282:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
