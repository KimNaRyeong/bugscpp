        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-number-prototype.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-globals.h"
        -:   24:#include "ecma-helpers.h"
        -:   25:#include "ecma-objects.h"
        -:   26:#include "ecma-string-object.h"
        -:   27:#include "ecma-try-catch-macro.h"
        -:   28:#include "jrt.h"
        -:   29:#include "jrt-libc-includes.h"
        -:   30:
        -:   31:#if ENABLED (JERRY_BUILTIN_NUMBER)
        -:   32:
        -:   33:#define ECMA_BUILTINS_INTERNAL
        -:   34:#include "ecma-builtins-internal.h"
        -:   35:
        -:   36:/**
        -:   37: * This object has a custom dispatch function.
        -:   38: */
        -:   39:#define BUILTIN_CUSTOM_DISPATCH
        -:   40:
        -:   41:/**
        -:   42: * List of built-in routine identifiers.
        -:   43: */
        -:   44:enum
        -:   45:{
        -:   46:  ECMA_NUMBER_PROTOTYPE_ROUTINE_START = ECMA_BUILTIN_ID__COUNT - 1,
        -:   47:  ECMA_NUMBER_PROTOTYPE_VALUE_OF,
        -:   48:  ECMA_NUMBER_PROTOTYPE_TO_STRING,
        -:   49:  ECMA_NUMBER_PROTOTYPE_TO_LOCALE_STRING,
        -:   50:  ECMA_NUMBER_PROTOTYPE_TO_FIXED,
        -:   51:  ECMA_NUMBER_PROTOTYPE_TO_EXPONENTIAL,
        -:   52:  ECMA_NUMBER_PROTOTYPE_TO_PRECISION,
        -:   53:};
        -:   54:
        -:   55:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-number-prototype.inc.h"
        -:   56:#define BUILTIN_UNDERSCORED_ID number_prototype
        -:   57:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   58:
        -:   59:/** \addtogroup ecma ECMA
        -:   60: * @{
        -:   61: *
        -:   62: * \addtogroup ecmabuiltins
        -:   63: * @{
        -:   64: *
        -:   65: * \addtogroup numberprototype ECMA Number.prototype object built-in
        -:   66: * @{
        -:   67: */
        -:   68:
        -:   69:/**
        -:   70: * Helper for stringifying numbers
        -:   71: *
        -:   72: * @return the length of the generated string representation
        -:   73: */
        -:   74:static lit_utf8_size_t
    #####:   75:ecma_builtin_number_prototype_helper_to_string (lit_utf8_byte_t *digits_p, /**< number as string in decimal form */
        -:   76:                                                lit_utf8_size_t num_digits, /**< length of the string representation */
        -:   77:                                                int32_t exponent, /**< decimal exponent */
        -:   78:                                                lit_utf8_byte_t *to_digits_p, /**< [out] buffer to write */
        -:   79:                                                lit_utf8_size_t to_num_digits) /**< requested number of digits */
        -:   80:{
    #####:   81:  lit_utf8_byte_t *p = to_digits_p;
        -:   82:
    #####:   83:  if (exponent <= 0)
        -:   84:  {
        -:   85:    /* Add zero to the integer part. */
    #####:   86:    *p++ = '0';
    #####:   87:    to_num_digits--;
        -:   88:
    #####:   89:    if (to_num_digits > 0)
        -:   90:    {
    #####:   91:      *p++ = '.';
        -:   92:
        -:   93:      /* Add leading zeros to the fraction part. */
    #####:   94:      for (int i = 0; i < -exponent && to_num_digits > 0; i++)
        -:   95:      {
    #####:   96:        *p++ = '0';
    #####:   97:        to_num_digits--;
        -:   98:      }
        -:   99:    }
        -:  100:  }
        -:  101:  else
        -:  102:  {
        -:  103:    /* Add significant digits of the integer part. */
    #####:  104:    lit_utf8_size_t to_copy = JERRY_MIN (num_digits, to_num_digits);
    #####:  105:    to_copy = JERRY_MIN (to_copy, (lit_utf8_size_t) exponent);
    #####:  106:    memmove (p, digits_p, (size_t) to_copy);
    #####:  107:    p += to_copy;
    #####:  108:    to_num_digits -= to_copy;
    #####:  109:    digits_p += to_copy;
    #####:  110:    num_digits -= to_copy;
    #####:  111:    exponent -= (int32_t) to_copy;
        -:  112:
        -:  113:    /* Add zeros before decimal point. */
    #####:  114:    while (exponent > 0 && to_num_digits > 0)
        -:  115:    {
    #####:  116:      JERRY_ASSERT (num_digits == 0);
    #####:  117:      *p++ = '0';
    #####:  118:      to_num_digits--;
    #####:  119:      exponent--;
        -:  120:    }
        -:  121:
    #####:  122:    if (to_num_digits > 0)
        -:  123:    {
    #####:  124:      *p++ = '.';
        -:  125:    }
        -:  126:  }
        -:  127:
    #####:  128:  if (to_num_digits > 0)
        -:  129:  {
        -:  130:    /* Add significant digits of the fraction part. */
    #####:  131:    lit_utf8_size_t to_copy = JERRY_MIN (num_digits, to_num_digits);
    #####:  132:    memmove (p, digits_p, (size_t) to_copy);
    #####:  133:    p += to_copy;
    #####:  134:    to_num_digits -= to_copy;
        -:  135:
        -:  136:    /* Add trailing zeros. */
    #####:  137:    while (to_num_digits > 0)
        -:  138:    {
    #####:  139:      *p++ = '0';
    #####:  140:      to_num_digits--;
        -:  141:    }
        -:  142:  }
        -:  143:
    #####:  144:  return (lit_utf8_size_t) (p - to_digits_p);
        -:  145:} /* ecma_builtin_number_prototype_helper_to_string */
        -:  146:
        -:  147:/**
        -:  148: * Helper function to convert a binary floating point number to string.
        -:  149: *
        -:  150: * @return size of result string
        -:  151: */
        -:  152:static inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
        -:  153:ecma_builtin_binary_floating_number_to_string (lit_utf8_byte_t *digits_p, /**< number as string
        -:  154:                                                                           * in binary-floating point number */
        -:  155:                                               int32_t exponent, /**< decimal exponent */
        -:  156:                                               lit_utf8_byte_t *to_digits_p, /**< [out] buffer to write */
        -:  157:                                               lit_utf8_size_t to_num_digits) /**< requested number of digits */
        -:  158:{
    #####:  159:  lit_utf8_byte_t *p = to_digits_p;
        -:  160:  /* Add significant digits of the decimal part. */
    #####:  161:  while (exponent > 0)
        -:  162:  {
    #####:  163:    *p++ = *digits_p++;
    #####:  164:    exponent--;
    #####:  165:    to_num_digits--;
        -:  166:  }
        -:  167:
    #####:  168:  if (to_num_digits > 0)
        -:  169:  {
    #####:  170:    *p++ = '.';
        -:  171:  }
        -:  172:
    #####:  173:  if (to_num_digits > 0)
        -:  174:  {
        -:  175:    /* Add significant digits of the fraction part and fill the remaining digits with zero */
    #####:  176:    while (to_num_digits > 0)
        -:  177:    {
    #####:  178:      *p++ = (*digits_p == 0 ? '0' : *digits_p++);
    #####:  179:      to_num_digits--;
        -:  180:    }
        -:  181:  }
        -:  182:
    #####:  183:  return (lit_utf8_size_t) (p - to_digits_p);
        -:  184:} /* ecma_builtin_binary_floating_number_to_string */
        -:  185:
        -:  186:/**
        -:  187: * Helper for rounding numbers
        -:  188: *
        -:  189: * @return rounded number
        -:  190: */
        -:  191:static inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
        -:  192:ecma_builtin_number_prototype_helper_round (lit_utf8_byte_t *digits_p, /**< [in,out] number as a string in decimal
        -:  193:                                                                        *   form */
        -:  194:                                            lit_utf8_size_t num_digits, /**< length of the string representation */
        -:  195:                                            int32_t round_num, /**< number of digits to keep */
        -:  196:                                            int32_t *exponent_p, /**< [in, out] decimal exponent */
        -:  197:                                            bool zero) /**< true if digits_p represents zero */
        -:  198:{
    #####:  199:  if (round_num < 1)
        -:  200:  {
    #####:  201:    return 0;
        -:  202:  }
        -:  203:
    #####:  204:  if ((lit_utf8_size_t) round_num >= num_digits || zero)
        -:  205:  {
    #####:  206:    return num_digits;
        -:  207:  }
        -:  208:
    #####:  209:  if (digits_p[round_num] >= '5')
        -:  210:  {
    #####:  211:    digits_p[round_num] = '0';
        -:  212:
    #####:  213:    int i = 1;
        -:  214:
        -:  215:    /* Handle carry number. */
    #####:  216:    for (; i <= round_num; i++)
        -:  217:    {
    #####:  218:      if (++digits_p[round_num - i] <= '9')
        -:  219:      {
        -:  220:        break;
        -:  221:      }
    #####:  222:      digits_p[round_num - i] = '0';
        -:  223:    }
        -:  224:
        -:  225:    /* Prepend highest digit */
    #####:  226:    if (i > round_num)
        -:  227:    {
    #####:  228:      memmove (digits_p + 1, digits_p, num_digits);
    #####:  229:      digits_p[0] = '1';
    #####:  230:      *exponent_p += 1;
        -:  231:    }
        -:  232:  }
        -:  233:
    #####:  234:  return (lit_utf8_size_t) round_num;
        -:  235:} /* ecma_builtin_number_prototype_helper_round */
        -:  236:
        -:  237:/**
        -:  238: * The Number.prototype object's 'toString' and 'toLocaleString' routines
        -:  239: *
        -:  240: * See also:
        -:  241: *          ECMA-262 v5, 15.7.4.2
        -:  242: *          ECMA-262 v5, 15.7.4.7
        -:  243: *
        -:  244: * @return ecma value
        -:  245: *         Returned value must be freed with ecma_free_value.
        -:  246: */
        -:  247:static ecma_value_t
    #####:  248:ecma_builtin_number_prototype_object_to_string (ecma_number_t this_arg_number, /**< this argument number */
        -:  249:                                                const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  250:                                                ecma_length_t arguments_list_len) /**< number of arguments */
        -:  251:{
        -:  252:  static const lit_utf8_byte_t digit_chars[36] =
        -:  253:  {
        -:  254:    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        -:  255:    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
        -:  256:    'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
        -:  257:    'u', 'v', 'w', 'x', 'y', 'z'
        -:  258:  };
        -:  259:
    #####:  260:  uint32_t radix = 10;
    #####:  261:  if (arguments_list_len > 0 && !ecma_is_value_undefined (arguments_list_p[0]))
        -:  262:  {
    #####:  263:    ecma_number_t arg_num;
        -:  264:
    #####:  265:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arguments_list_p[0], &arg_num)))
        -:  266:    {
    #####:  267:      return ECMA_VALUE_ERROR;
        -:  268:    }
        -:  269:
    #####:  270:    radix = ecma_number_to_uint32 (arg_num);
        -:  271:
    #####:  272:    if (radix < 2 || radix > 36)
        -:  273:    {
    #####:  274:      return ecma_raise_range_error (ECMA_ERR_MSG ("Radix must be between 2 and 36."));
        -:  275:    }
        -:  276:  }
        -:  277:
    #####:  278:  if (ecma_number_is_nan (this_arg_number)
    #####:  279:      || ecma_number_is_infinity (this_arg_number)
    #####:  280:      || ecma_number_is_zero (this_arg_number)
    #####:  281:      || radix == 10)
        -:  282:  {
    #####:  283:    ecma_string_t *ret_str_p = ecma_new_ecma_string_from_number (this_arg_number);
    #####:  284:    return ecma_make_string_value (ret_str_p);
        -:  285:  }
        -:  286:
    #####:  287:  int buff_size = 0;
        -:  288:
    #####:  289:  bool is_number_negative = false;
    #####:  290:  if (ecma_number_is_negative (this_arg_number))
        -:  291:  {
        -:  292:    /* ecma_number_to_decimal can't handle negative numbers, so we get rid of the sign. */
    #####:  293:    this_arg_number = -this_arg_number;
    #####:  294:    is_number_negative = true;
        -:  295:
        -:  296:    /* Add space for the sign in the result. */
    #####:  297:    buff_size += 1;
        -:  298:  }
        -:  299:
        -:  300:  /* Decompose the number. */
    #####:  301:  lit_utf8_byte_t digits[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
    #####:  302:  int32_t exponent;
    #####:  303:  lit_utf8_size_t digit_count = ecma_number_to_decimal (this_arg_number, digits, &exponent);
        -:  304:
        -:  305:  /*
        -:  306:   * The 'exponent' given by 'ecma_number_to_decimal' specifies where the decimal point is located
        -:  307:   * compared to the first digit in 'digits'.
        -:  308:   * For example: 120 -> '12', exp: 3 and 0.012 -> '12', exp: -1
        -:  309:   * We convert it to be location of the decimal point compared to the last digit of 'digits':
        -:  310:   * 120 -> 12 * 10^1 and 0.012 -> 12 * 10^-3
        -:  311:   */
    #####:  312:  exponent = exponent - (int32_t) digit_count;
        -:  313:
        -:  314:  /* 'magnitude' will be the magnitude of the number in the specific radix. */
        -:  315:  int magnitude;
        -:  316:  int required_digits;
    #####:  317:  if (exponent >= 0)
        -:  318:  {
        -:  319:    /*
        -:  320:     * If the exponent is non-negative that means we won't have a fractional part, and can calculate
        -:  321:     * exactly how many digits we will have. This could be done via a mathematic formula, but in rare
        -:  322:     * cases that can cause incorrect results due to precision issues, so we use a loop instead.
        -:  323:     */
    #####:  324:    magnitude = 0;
    #####:  325:    ecma_number_t counter = this_arg_number;
    #####:  326:    while (counter >= radix)
        -:  327:    {
    #####:  328:      counter /= radix;
    #####:  329:      magnitude++;
        -:  330:    }
        -:  331:
        -:  332:    /*
        -:  333:     * The magnitude will only tell us how many digits we have after the first one, so we add one extra.
        -:  334:     * In this case we won't be needing a radix point, so we don't need to worry about space for it.
        -:  335:     */
    #####:  336:    required_digits = magnitude + 1;
        -:  337:  }
        -:  338:  else
        -:  339:  {
        -:  340:    /*
        -:  341:     * We can't know exactly how many digits we will need, since the number may be non-terminating in the
        -:  342:     * new radix, so we will have to estimate it. We do this by first calculating how many zeros we will
        -:  343:     * need in the specific radix before we hit a significant digit. This is calculated from the decimal
        -:  344:     * exponent, which we negate so that we get a positive number in the end.
        -:  345:     */
    #####:  346:    magnitude = (int) floor ((log (10) / log (radix)) * -exponent);
        -:  347:
        -:  348:    /*
        -:  349:     * We also need to add space for significant digits. The worst case is radix == 2, since this will
        -:  350:     * require the most digits. In this case, the upper limit to the number of significant digits we can have is
        -:  351:     * ECMA_NUMBER_FRACTION_WIDTH + 1. This should be sufficient for any number.
        -:  352:     */
    #####:  353:    required_digits = magnitude + ECMA_NUMBER_FRACTION_WIDTH + 1;
        -:  354:
        -:  355:    /*
        -:  356:     * We add an exta slot for the radix point. It is also likely that we will need extra space for a
        -:  357:     * leading zero before the radix point. It's better to add space for that here as well, even if we may not
        -:  358:     * need it, since later we won't be able to do so.
        -:  359:     */
    #####:  360:    buff_size += 2;
        -:  361:  }
        -:  362:
        -:  363:  /*
        -:  364:   * Here we normalize the number so that it is as close to 0 as possible, which will prevent us from losing
        -:  365:   * precision in case of extreme numbers when we later split the number into integer and fractional parts.
        -:  366:   * This has to be done in the specific radix, otherwise it messes up the result, so we use magnitude instead.
        -:  367:   */
    #####:  368:  if (exponent > 0)
        -:  369:  {
    #####:  370:    for (int i = 0; i < magnitude; i++)
        -:  371:    {
    #####:  372:      this_arg_number /= radix;
        -:  373:    }
        -:  374:  }
    #####:  375:  else if (exponent < 0)
        -:  376:  {
    #####:  377:    for (int i = 0; i < magnitude; i++)
        -:  378:    {
    #####:  379:      this_arg_number *= radix;
        -:  380:    }
        -:  381:  }
        -:  382:
        -:  383:  /* Split the number into an integer and a fractional part, since we have to handle them separately. */
    #####:  384:  uint64_t whole = (uint64_t) this_arg_number;
    #####:  385:  ecma_number_t fraction = this_arg_number - (ecma_number_t) whole;
        -:  386:
    #####:  387:  bool should_round = false;
    #####:  388:  if (!ecma_number_is_zero (fraction) && exponent >= 0)
        -:  389:  {
        -:  390:    /*
        -:  391:     * If the exponent is non-negative, and we get a non-zero fractional part, that means
        -:  392:     * the normalization might have introduced a small error, in which case we have to correct it by rounding.
        -:  393:     * We'll add one extra significant digit which we will later use to round.
        -:  394:     */
    #####:  395:    required_digits += 1;
    #####:  396:    should_round = true;
        -:  397:  }
        -:  398:
        -:  399:  /* Get the total required buffer size and allocate the buffer. */
    #####:  400:  buff_size += required_digits;
        -:  401:  ecma_value_t ret_value;
    #####:  402:  JMEM_DEFINE_LOCAL_ARRAY (buff, buff_size, lit_utf8_byte_t);
    #####:  403:  int buff_index = 0;
        -:  404:
        -:  405:  /* Calculate digits for whole part. */
    #####:  406:  while (whole > 0)
        -:  407:  {
    #####:  408:    JERRY_ASSERT (buff_index < buff_size && buff_index < required_digits);
    #####:  409:    buff[buff_index++] = (lit_utf8_byte_t) (whole % radix);
    #####:  410:    whole /= radix;
        -:  411:  }
        -:  412:
        -:  413:  /* The digits are backwards, we need to reverse them. */
    #####:  414:  for (int i = 0; i < buff_index / 2; i++)
        -:  415:  {
    #####:  416:    lit_utf8_byte_t swap = buff[i];
    #####:  417:    buff[i] = buff[buff_index - i - 1];
    #####:  418:    buff[buff_index - i - 1] = swap;
        -:  419:  }
        -:  420:
        -:  421:  /*
        -:  422:   * Calculate where we have to put the radix point relative to the beginning of
        -:  423:   * the new digits. If the exponent is non-negative this will be right after the number.
        -:  424:   */
    #####:  425:  int point = exponent >= 0 ? magnitude + 1: buff_index - magnitude;
        -:  426:
    #####:  427:  if (point < 0)
        -:  428:  {
        -:  429:    /*
        -:  430:     * In this case the radix point will be before the first digit,
        -:  431:     * so we need to leave space for leading zeros.
        -:  432:     */
    #####:  433:    JERRY_ASSERT (exponent < 0);
    #####:  434:    required_digits += point;
        -:  435:  }
        -:  436:
    #####:  437:  JERRY_ASSERT (required_digits <= buff_size);
        -:  438:
        -:  439:  /* Calculate digits for fractional part. */
    #####:  440:  while (buff_index < required_digits)
        -:  441:  {
    #####:  442:    fraction *= radix;
    #####:  443:    lit_utf8_byte_t digit = (lit_utf8_byte_t) floor (fraction);
        -:  444:
    #####:  445:    buff[buff_index++] = digit;
    #####:  446:    fraction -= (ecma_number_t) floor (fraction);
        -:  447:  }
        -:  448:
    #####:  449:  if (should_round)
        -:  450:  {
        -:  451:    /* Consume last digit for rounding. */
    #####:  452:    buff_index--;
    #####:  453:    if (buff[buff_index] > radix / 2)
        -:  454:    {
        -:  455:      /* We should be rounding up. */
    #####:  456:      buff[buff_index - 1]++;
        -:  457:
        -:  458:      /* Propagate carry forward in the digits. */
    #####:  459:      for (int i = buff_index - 1; i > 0 && buff[i] >= radix; i--)
        -:  460:      {
    #####:  461:        buff[i] = (lit_utf8_byte_t) (buff[i] - radix);
    #####:  462:        buff[i - 1]++;
        -:  463:      }
        -:  464:
    #####:  465:      if (buff[0] >= radix)
        -:  466:      {
        -:  467:        /*
        -:  468:         * Carry propagated over the whole number, we need to add a new leading digit.
        -:  469:         * We can use the place of the original rounded digit, we just need to shift everything
        -:  470:         * right by one.
        -:  471:         */
    #####:  472:        memmove (buff + 1, buff, (size_t) buff_index);
    #####:  473:        buff_index++;
    #####:  474:        buff[0] = 1;
        -:  475:      }
        -:  476:    }
        -:  477:  }
        -:  478:
        -:  479:  /* Remove trailing zeros. */
    #####:  480:  while (buff_index - 1 > point && buff[buff_index - 1] == 0)
        -:  481:  {
    #####:  482:    buff_index--;
        -:  483:  }
        -:  484:
        -:  485:  /* Add leading zeros in case place of radix point is negative. */
    #####:  486:  if (point <= 0)
        -:  487:  {
        -:  488:    /* We will have 'point' amount of zeros after the radix point, and +1 before. */
    #####:  489:    int zero_count = -point + 1;
    #####:  490:    memmove (buff + zero_count, buff, (size_t) buff_index);
    #####:  491:    buff_index += zero_count;
        -:  492:
    #####:  493:    for (int i = 0; i < zero_count; i++)
        -:  494:    {
    #####:  495:      buff[i] = 0;
        -:  496:    }
        -:  497:
        -:  498:    /* We now need to place the radix point after the first zero. */
    #####:  499:    point = 1;
        -:  500:  }
        -:  501:
        -:  502:  /* Convert digits to characters. */
    #####:  503:  for (int i = 0; i < buff_index; i++)
        -:  504:  {
    #####:  505:    buff[i] = digit_chars[buff[i]];
        -:  506:  }
        -:  507:
        -:  508:  /* Place radix point to the required position. */
    #####:  509:  if (point < buff_index)
        -:  510:  {
    #####:  511:    memmove (buff + point + 1, buff + point, (size_t) (buff_index - point));
    #####:  512:    buff[point] = '.';
    #####:  513:    buff_index++;
        -:  514:  }
        -:  515:
        -:  516:  /* Add negative sign if necessary. */
    #####:  517:  if (is_number_negative)
        -:  518:  {
    #####:  519:    memmove (buff + 1, buff, (size_t) buff_index);
    #####:  520:    buff[0] = '-';
    #####:  521:    buff_index++;
        -:  522:  }
        -:  523:
    #####:  524:  JERRY_ASSERT (buff_index <= buff_size);
    #####:  525:  ecma_string_t *str_p = ecma_new_ecma_string_from_utf8 (buff, (lit_utf8_size_t) buff_index);
    #####:  526:  ret_value = ecma_make_string_value (str_p);
    #####:  527:  JMEM_FINALIZE_LOCAL_ARRAY (buff);
        -:  528:
    #####:  529:  return ret_value;
        -:  530:} /* ecma_builtin_number_prototype_object_to_string */
        -:  531:
        -:  532:/**
        -:  533: * The Number.prototype object's 'valueOf' routine
        -:  534: *
        -:  535: * See also:
        -:  536: *          ECMA-262 v5, 15.7.4.4
        -:  537: *
        -:  538: * @return ecma value
        -:  539: *         Returned value must be freed with ecma_free_value.
        -:  540: */
        -:  541:static ecma_value_t
    #####:  542:ecma_builtin_number_prototype_object_value_of (ecma_value_t this_arg) /**< this argument */
        -:  543:{
    #####:  544:  if (ecma_is_value_number (this_arg))
        -:  545:  {
    #####:  546:    return this_arg;
        -:  547:  }
    #####:  548:  else if (ecma_is_value_object (this_arg))
        -:  549:  {
    #####:  550:    ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  551:
    #####:  552:    if (ecma_object_class_is (object_p, LIT_MAGIC_STRING_NUMBER_UL))
        -:  553:    {
    #####:  554:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  555:
    #####:  556:      JERRY_ASSERT (ecma_is_value_number (ext_object_p->u.class_prop.u.value));
        -:  557:
    #####:  558:      return ext_object_p->u.class_prop.u.value;
        -:  559:    }
        -:  560:  }
        -:  561:
    #####:  562:  return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a Number or a Number object."));
        -:  563:} /* ecma_builtin_number_prototype_object_value_of */
        -:  564:
        -:  565:/**
        -:  566: * Type of number routine
        -:  567: */
        -:  568:typedef enum
        -:  569:{
        -:  570:  NUMBER_ROUTINE_TO_FIXED,       /**< Number.prototype.toFixed: ECMA-262 v5, 15.7.4.4 */
        -:  571:  NUMBER_ROUTINE_TO_EXPONENTIAL, /**< Number.prototype.toExponential: ECMA-262 v5, 15.7.4.5 */
        -:  572:  NUMBER_ROUTINE_TO_PRECISION,   /**< Number.prototype.toPrecision: ECMA-262 v5, 15.7.4.6 */
        -:  573:  NUMBER_ROUTINE__COUNT,         /**< count of the modes */
        -:  574:} number_routine_mode_t;
        -:  575:
        -:  576:/**
        -:  577: * Helper function for the Number.prototype object's
        -:  578: * 'toFixed', 'toExponential' and 'toPrecision' routines to
        -:  579: * check the special cases before the conversion
        -:  580: *
        -:  581: * @return ECMA_VALUE_EMPTY - if the conversion should continue
        -:  582: *         ecma-value - otherwise
        -:  583: */
        -:  584:static ecma_value_t
    #####:  585:ecma_builtin_number_prepare_conversion (ecma_number_t *this_num_p, /**< [out] this argument number */
        -:  586:                                        ecma_value_t arg_1, /**< routine's argument */
        -:  587:                                        bool *is_negative_p, /**< [out] is negative */
        -:  588:                                        int32_t *arg_1_int32_p, /**< [out] routine's argument number
        -:  589:                                                                 *    converted to int32_t */
        -:  590:                                        number_routine_mode_t mode) /**< number routine mode */
        -:  591:{
    #####:  592:  JERRY_ASSERT (mode < NUMBER_ROUTINE__COUNT);
        -:  593:
    #####:  594:  ecma_number_t arg_num;
    #####:  595:  arg_1 = ecma_op_to_integer (arg_1, &arg_num);
        -:  596:
    #####:  597:  if (ECMA_IS_VALUE_ERROR (arg_1))
        -:  598:  {
    #####:  599:    return arg_1;
        -:  600:  }
        -:  601:
    #####:  602:  if (mode != NUMBER_ROUTINE_TO_PRECISION
    #####:  603:      && (arg_num <= -1 || arg_num >= 21))
        -:  604:  {
    #####:  605:    return ecma_raise_range_error (ECMA_ERR_MSG ("Fraction digits must be between 0 and 20."));
        -:  606:  }
        -:  607:
    #####:  608:  if (ecma_number_is_nan (*this_num_p))
        -:  609:  {
    #####:  610:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_NAN);
        -:  611:  }
        -:  612:
    #####:  613:  bool is_negative = false;
        -:  614:
    #####:  615:  if (ecma_number_is_negative (*this_num_p))
        -:  616:  {
    #####:  617:    is_negative = ecma_number_is_zero (*this_num_p) ? false : true;
    #####:  618:    *this_num_p *= -1;
        -:  619:  }
        -:  620:
    #####:  621:  *is_negative_p = is_negative;
        -:  622:
        -:  623:  /* We handle infinities separately. */
    #####:  624:  if (ecma_number_is_infinity (*this_num_p))
        -:  625:  {
    #####:  626:    return ecma_make_magic_string_value ((is_negative ? LIT_MAGIC_STRING_NEGATIVE_INFINITY_UL
        -:  627:                                                      : LIT_MAGIC_STRING_INFINITY_UL));
        -:  628:  }
        -:  629:
    #####:  630:  if (mode == NUMBER_ROUTINE_TO_PRECISION &&
    #####:  631:      (ecma_number_is_nan (arg_num) || arg_num < 1 || arg_num >= 22))
        -:  632:  {
    #####:  633:    return ecma_raise_range_error (ECMA_ERR_MSG ("Precision digits must be between 1 and 21."));
        -:  634:  }
        -:  635:
    #####:  636:  *arg_1_int32_p = ecma_number_to_int32 (arg_num);
        -:  637:
    #####:  638:  return ECMA_VALUE_EMPTY;
        -:  639:} /* ecma_builtin_number_prepare_conversion */
        -:  640:
        -:  641:/**
        -:  642: * The Number.prototype object's 'toFixed' routine
        -:  643: *
        -:  644: * See also:
        -:  645: *          ECMA-262 v5, 15.7.4.5
        -:  646: *
        -:  647: * @return ecma value
        -:  648: *         Returned value must be freed with ecma_free_value.
        -:  649: */
        -:  650:static ecma_value_t
    #####:  651:ecma_builtin_number_prototype_object_to_fixed (ecma_number_t this_num, /**< this argument number */
        -:  652:                                               ecma_value_t radix) /**< routine's argument */
        -:  653:{
    #####:  654:  bool is_negative;
    #####:  655:  int32_t frac_digits;
        -:  656:
    #####:  657:  ecma_value_t comp_value = ecma_builtin_number_prepare_conversion (&this_num,
        -:  658:                                                                    radix,
        -:  659:                                                                    &is_negative,
        -:  660:                                                                    &frac_digits,
        -:  661:                                                                    NUMBER_ROUTINE_TO_FIXED);
        -:  662:
    #####:  663:  if (!ecma_is_value_empty (comp_value))
        -:  664:  {
    #####:  665:    return comp_value;
        -:  666:  }
        -:  667:
        -:  668:  /* Get the parameters of the number if non-zero. */
    #####:  669:  lit_utf8_byte_t digits[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
        -:  670:  lit_utf8_size_t num_digits;
    #####:  671:  int32_t exponent;
        -:  672:
    #####:  673:  if (!ecma_number_is_zero (this_num))
        -:  674:  {
    #####:  675:    num_digits = ecma_number_to_binary_floating_point_number (this_num, digits, &exponent);
    #####:  676:    JERRY_ASSERT (exponent >= 0);
        -:  677:  }
        -:  678:  else
        -:  679:  {
    #####:  680:    for (int32_t i = 0; i <= frac_digits; i++)
        -:  681:    {
    #####:  682:      digits[i] = '0';
        -:  683:    }
    #####:  684:    num_digits = (lit_utf8_size_t) frac_digits + 1;
    #####:  685:    exponent = 1;
        -:  686:  }
        -:  687:
        -:  688:  /* 7. */
    #####:  689:  if (exponent > 21)
        -:  690:  {
    #####:  691:    return ecma_builtin_number_prototype_object_to_string (this_num, NULL, 0);
        -:  692:  }
        -:  693:
        -:  694:  /* 8. */
    #####:  695:  num_digits = ecma_builtin_number_prototype_helper_round (digits,
    #####:  696:                                                           num_digits + (lit_utf8_size_t) exponent,
        -:  697:                                                           exponent + frac_digits,
        -:  698:                                                           &exponent,
    #####:  699:                                                           ecma_number_is_zero (this_num));
        -:  700:
        -:  701:  /* Buffer that is used to construct the string. */
    #####:  702:  int buffer_size = (exponent > 0) ? exponent + frac_digits + 2 : frac_digits + 3;
        -:  703:
    #####:  704:  if (is_negative)
        -:  705:  {
    #####:  706:    buffer_size++;
        -:  707:  }
        -:  708:
    #####:  709:  JERRY_ASSERT (buffer_size > 0);
        -:  710:
        -:  711:  ecma_value_t ret_value;
    #####:  712:  JMEM_DEFINE_LOCAL_ARRAY (buff, buffer_size, lit_utf8_byte_t);
        -:  713:
    #####:  714:  lit_utf8_byte_t *p = buff;
        -:  715:
    #####:  716:  if (is_negative)
        -:  717:  {
    #####:  718:    *p++ = '-';
        -:  719:  }
        -:  720:
    #####:  721:  lit_utf8_size_t to_num_digits = ((exponent > 0) ? (lit_utf8_size_t) (exponent + frac_digits)
    #####:  722:                                                  : (lit_utf8_size_t) (frac_digits + 1));
    #####:  723:  p += ecma_builtin_binary_floating_number_to_string (digits,
        -:  724:                                                      exponent,
        -:  725:                                                      p,
        -:  726:                                                      to_num_digits);
        -:  727:
    #####:  728:  JERRY_ASSERT (p - buff < buffer_size);
        -:  729:  /* String terminator. */
    #####:  730:  *p = 0;
    #####:  731:  ecma_string_t *str = ecma_new_ecma_string_from_utf8 (buff, (lit_utf8_size_t) (p - buff));
        -:  732:
    #####:  733:  ret_value = ecma_make_string_value (str);
    #####:  734:  JMEM_FINALIZE_LOCAL_ARRAY (buff);
        -:  735:
    #####:  736:  return ret_value;
        -:  737:} /* ecma_builtin_number_prototype_object_to_fixed */
        -:  738:
        -:  739:/**
        -:  740: * The Number.prototype object's 'toExponential' routine
        -:  741: *
        -:  742: * See also:
        -:  743: *          ECMA-262 v5, 15.7.4.6
        -:  744: *
        -:  745: * @return ecma value
        -:  746: *         Returned value must be freed with ecma_free_value.
        -:  747: */
        -:  748:static ecma_value_t
    #####:  749:ecma_builtin_number_prototype_object_to_exponential (ecma_number_t this_num, /**< this argument number */
        -:  750:                                                     ecma_value_t fraction_digits) /**< routine's argument */
        -:  751:{
    #####:  752:  bool is_negative;
    #####:  753:  int32_t frac_digits;
        -:  754:
    #####:  755:  ecma_value_t comp_value = ecma_builtin_number_prepare_conversion (&this_num,
        -:  756:                                                                    fraction_digits,
        -:  757:                                                                    &is_negative,
        -:  758:                                                                    &frac_digits,
        -:  759:                                                                    NUMBER_ROUTINE_TO_EXPONENTIAL);
        -:  760:
    #####:  761:  if (!ecma_is_value_empty (comp_value))
        -:  762:  {
    #####:  763:    return comp_value;
        -:  764:  }
        -:  765:
        -:  766:  /* Get the parameters of the number if non zero. */
    #####:  767:  lit_utf8_byte_t digits[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
        -:  768:  lit_utf8_size_t num_digits;
    #####:  769:  int32_t exponent;
        -:  770:
    #####:  771:  if (!ecma_number_is_zero (this_num))
        -:  772:  {
    #####:  773:    num_digits = ecma_number_to_decimal (this_num, digits, &exponent);
        -:  774:  }
        -:  775:  else
        -:  776:  {
    #####:  777:    digits[0] = '0';
    #####:  778:    num_digits = 1;
    #####:  779:    exponent = 1;
        -:  780:  }
        -:  781:
    #####:  782:  if (ecma_is_value_undefined (fraction_digits))
        -:  783:  {
    #####:  784:    frac_digits = (int32_t) num_digits - 1;
        -:  785:  }
        -:  786:
    #####:  787:  num_digits = ecma_builtin_number_prototype_helper_round (digits, num_digits, frac_digits + 1, &exponent, false);
        -:  788:
        -:  789:  /* frac_digits + 2 characters for number, 5 characters for exponent, 1 for \0. */
    #####:  790:  int buffer_size = frac_digits + 2 + 5 + 1;
        -:  791:
    #####:  792:  if (is_negative)
        -:  793:  {
        -:  794:    /* +1 character for sign. */
    #####:  795:    buffer_size++;
        -:  796:  }
        -:  797:
        -:  798:  ecma_value_t ret_value;
    #####:  799:  JMEM_DEFINE_LOCAL_ARRAY (buff, buffer_size, lit_utf8_byte_t);
        -:  800:
    #####:  801:  lit_utf8_byte_t *actual_char_p = buff;
        -:  802:
    #####:  803:  if (is_negative)
        -:  804:  {
    #####:  805:    *actual_char_p++ = '-';
        -:  806:  }
        -:  807:
    #####:  808:  actual_char_p += ecma_builtin_number_prototype_helper_to_string (digits,
        -:  809:                                                                   num_digits,
        -:  810:                                                                   1,
        -:  811:                                                                   actual_char_p,
    #####:  812:                                                                   (lit_utf8_size_t) (frac_digits + 1));
        -:  813:
    #####:  814:  *actual_char_p++ = 'e';
        -:  815:
    #####:  816:  exponent--;
    #####:  817:  if (exponent < 0)
        -:  818:  {
    #####:  819:    exponent *= -1;
    #####:  820:    *actual_char_p++ = '-';
        -:  821:  }
        -:  822:  else
        -:  823:  {
    #####:  824:    *actual_char_p++ = '+';
        -:  825:  }
        -:  826:
        -:  827:  /* Add exponent digits. */
    #####:  828:  actual_char_p += ecma_uint32_to_utf8_string ((uint32_t) exponent, actual_char_p, 3);
        -:  829:
    #####:  830:  JERRY_ASSERT (actual_char_p - buff < buffer_size);
    #####:  831:  *actual_char_p = '\0';
    #####:  832:  ecma_string_t *str = ecma_new_ecma_string_from_utf8 (buff, (lit_utf8_size_t) (actual_char_p - buff));
    #####:  833:  ret_value = ecma_make_string_value (str);
    #####:  834:  JMEM_FINALIZE_LOCAL_ARRAY (buff);
        -:  835:
    #####:  836:  return ret_value;
        -:  837:} /* ecma_builtin_number_prototype_object_to_exponential */
        -:  838:
        -:  839:/**
        -:  840: * The Number.prototype object's 'toPrecision' routine
        -:  841: *
        -:  842: * See also:
        -:  843: *          ECMA-262 v5, 15.7.4.7
        -:  844: *
        -:  845: * @return ecma value
        -:  846: *         Returned value must be freed with ecma_free_value.
        -:  847: */
        -:  848:static ecma_value_t
    #####:  849:ecma_builtin_number_prototype_object_to_precision (ecma_number_t this_num, /**< this argument number */
        -:  850:                                                   ecma_value_t precision_value) /**< routine's argument */
        -:  851:{
    #####:  852:  if (ecma_is_value_undefined (precision_value))
        -:  853:  {
    #####:  854:    return ecma_builtin_number_prototype_object_to_string (this_num, NULL, 0);
        -:  855:  }
        -:  856:
    #####:  857:  bool is_negative;
    #####:  858:  int32_t precision;
        -:  859:
    #####:  860:  ecma_value_t comp_value = ecma_builtin_number_prepare_conversion (&this_num,
        -:  861:                                                                    precision_value,
        -:  862:                                                                    &is_negative,
        -:  863:                                                                    &precision,
        -:  864:                                                                    NUMBER_ROUTINE_TO_PRECISION);
        -:  865:
    #####:  866:  if (!ecma_is_value_empty (comp_value))
        -:  867:  {
    #####:  868:    return comp_value;
        -:  869:  }
        -:  870:
        -:  871:  /* Get the parameters of the number if non-zero. */
    #####:  872:  lit_utf8_byte_t digits[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
        -:  873:  lit_utf8_size_t num_digits;
    #####:  874:  int32_t exponent;
        -:  875:
    #####:  876:  if (!ecma_number_is_zero (this_num))
        -:  877:  {
    #####:  878:    num_digits = ecma_number_to_decimal (this_num, digits, &exponent);
        -:  879:  }
        -:  880:  else
        -:  881:  {
    #####:  882:    digits[0] = '0';
    #####:  883:    num_digits = 1;
    #####:  884:    exponent = 1;
        -:  885:  }
        -:  886:
    #####:  887:  num_digits = ecma_builtin_number_prototype_helper_round (digits, num_digits, precision, &exponent, false);
        -:  888:
        -:  889:  int buffer_size;
    #####:  890:  if (exponent  < -5 || exponent > precision)
        -:  891:  {
        -:  892:    /* Exponential notation, precision + 1 digits for number, 5 for exponent, 1 for \0 */
    #####:  893:    buffer_size = precision + 1 + 5 + 1;
        -:  894:  }
    #####:  895:  else if (exponent <= 0)
        -:  896:  {
        -:  897:    /* Fixed notation, -exponent + 2 digits for leading zeros, precision digits, 1 for \0 */
    #####:  898:    buffer_size = -exponent + 2 + precision + 1;
        -:  899:  }
        -:  900:  else
        -:  901:  {
        -:  902:    /* Fixed notation, precision + 1 digits for number, 1 for \0 */
    #####:  903:    buffer_size = precision + 1 + 1;
        -:  904:  }
        -:  905:
    #####:  906:  if (is_negative)
        -:  907:  {
    #####:  908:    buffer_size++;
        -:  909:  }
        -:  910:
        -:  911:  ecma_value_t ret_value;
    #####:  912:  JMEM_DEFINE_LOCAL_ARRAY (buff, buffer_size, lit_utf8_byte_t);
    #####:  913:  lit_utf8_byte_t *actual_char_p = buff;
        -:  914:
    #####:  915:  if (is_negative)
        -:  916:  {
    #####:  917:    *actual_char_p++ = '-';
        -:  918:  }
        -:  919:
        -:  920:  /* 10.c, Exponential notation.*/
    #####:  921:  if (exponent < -5 || exponent > precision)
        -:  922:  {
    #####:  923:    actual_char_p  += ecma_builtin_number_prototype_helper_to_string (digits,
        -:  924:                                                                      num_digits,
        -:  925:                                                                      1,
        -:  926:                                                                      actual_char_p,
        -:  927:                                                                      (lit_utf8_size_t) precision);
        -:  928:
    #####:  929:    *actual_char_p++ = 'e';
        -:  930:
    #####:  931:    exponent--;
    #####:  932:    if (exponent < 0)
        -:  933:    {
    #####:  934:      exponent *= -1;
    #####:  935:      *actual_char_p++ = '-';
        -:  936:    }
        -:  937:    else
        -:  938:    {
    #####:  939:      *actual_char_p++ = '+';
        -:  940:    }
        -:  941:
        -:  942:    /* Add exponent digits. */
    #####:  943:    actual_char_p += ecma_uint32_to_utf8_string ((uint32_t) exponent, actual_char_p, 3);
        -:  944:  }
        -:  945:  /* Fixed notation. */
        -:  946:  else
        -:  947:  {
    #####:  948:    lit_utf8_size_t to_num_digits = ((exponent <= 0) ? (lit_utf8_size_t) (1 - exponent + precision)
    #####:  949:                                                     : (lit_utf8_size_t) precision);
    #####:  950:    actual_char_p += ecma_builtin_number_prototype_helper_to_string (digits,
        -:  951:                                                                     num_digits,
        -:  952:                                                                     exponent,
        -:  953:                                                                     actual_char_p,
        -:  954:                                                                     to_num_digits);
        -:  955:
        -:  956:  }
        -:  957:
    #####:  958:  JERRY_ASSERT (actual_char_p - buff < buffer_size);
    #####:  959:  *actual_char_p = '\0';
    #####:  960:  ecma_string_t *str_p = ecma_new_ecma_string_from_utf8 (buff, (lit_utf8_size_t) (actual_char_p - buff));
        -:  961:
    #####:  962:  ret_value = ecma_make_string_value (str_p);
    #####:  963:  JMEM_FINALIZE_LOCAL_ARRAY (buff);
        -:  964:
    #####:  965:  return ret_value;
        -:  966:} /* ecma_builtin_number_prototype_object_to_precision */
        -:  967:
        -:  968:/**
        -:  969: * Dispatcher of the built-in's routines
        -:  970: *
        -:  971: * @return ecma value
        -:  972: *         Returned value must be freed with ecma_free_value.
        -:  973: */
        -:  974:ecma_value_t
    #####:  975:ecma_builtin_number_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine
        -:  976:                                                                              *   identifier */
        -:  977:                                                ecma_value_t this_arg, /**< 'this' argument value */
        -:  978:                                                const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  979:                                                                                      *   passed to routine */
        -:  980:                                                ecma_length_t arguments_number) /**< length of arguments' list */
        -:  981:{
    #####:  982:  ecma_value_t this_value = ecma_builtin_number_prototype_object_value_of (this_arg);
        -:  983:
    #####:  984:  if (ECMA_IS_VALUE_ERROR (this_value))
        -:  985:  {
    #####:  986:    return this_value;
        -:  987:  }
        -:  988:
    #####:  989:  if (builtin_routine_id == ECMA_NUMBER_PROTOTYPE_VALUE_OF)
        -:  990:  {
    #####:  991:    return ecma_copy_value (this_value);
        -:  992:  }
        -:  993:
    #####:  994:  ecma_number_t this_arg_number = ecma_get_number_from_value (this_value);
        -:  995:
    #####:  996:  ecma_value_t routine_arg_1 = arguments_list_p[0];
        -:  997:
    #####:  998:  switch (builtin_routine_id)
        -:  999:  {
    #####: 1000:    case ECMA_NUMBER_PROTOTYPE_TO_STRING:
        -: 1001:    {
    #####: 1002:      return ecma_builtin_number_prototype_object_to_string (this_arg_number, arguments_list_p, arguments_number);
        -: 1003:    }
    #####: 1004:    case ECMA_NUMBER_PROTOTYPE_TO_LOCALE_STRING:
        -: 1005:    {
    #####: 1006:      return ecma_builtin_number_prototype_object_to_string (this_arg_number, NULL, 0);
        -: 1007:    }
    #####: 1008:    case ECMA_NUMBER_PROTOTYPE_TO_FIXED:
        -: 1009:    {
    #####: 1010:      return ecma_builtin_number_prototype_object_to_fixed (this_arg_number, routine_arg_1);
        -: 1011:    }
    #####: 1012:    case ECMA_NUMBER_PROTOTYPE_TO_EXPONENTIAL:
        -: 1013:    {
    #####: 1014:      return ecma_builtin_number_prototype_object_to_exponential (this_arg_number, routine_arg_1);
        -: 1015:    }
    #####: 1016:    case ECMA_NUMBER_PROTOTYPE_TO_PRECISION:
        -: 1017:    {
    #####: 1018:      return ecma_builtin_number_prototype_object_to_precision (this_arg_number, routine_arg_1);
        -: 1019:    }
    #####: 1020:    default:
        -: 1021:    {
    #####: 1022:      JERRY_UNREACHABLE ();
        -: 1023:    }
        -: 1024:  }
        -: 1025:} /* ecma_builtin_number_prototype_dispatch_routine */
        -: 1026:
        -: 1027:/**
        -: 1028: * @}
        -: 1029: * @}
        -: 1030: * @}
        -: 1031: */
        -: 1032:
        -: 1033:#endif /* ENABLED (JERRY_BUILTIN_NUMBER) */
