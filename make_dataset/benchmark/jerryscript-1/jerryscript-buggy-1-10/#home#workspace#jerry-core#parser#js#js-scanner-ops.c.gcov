        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner-ops.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:#include "js-scanner-internal.h"
        -:   18:#include "lit-char-helpers.h"
        -:   19:
        -:   20:#if ENABLED (JERRY_PARSER)
        -:   21:
        -:   22:/** \addtogroup parser Parser
        -:   23: * @{
        -:   24: *
        -:   25: * \addtogroup jsparser JavaScript
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser_scanner Scanner
        -:   29: * @{
        -:   30: */
        -:   31:
        -:   32:#if ENABLED (JERRY_ES2015)
        -:   33:
        -:   34:/**
        -:   35: * Add the "async" literal to the literal pool.
        -:   36: */
        -:   37:void
    #####:   38:scanner_add_async_literal (parser_context_t *context_p, /**< context */
        -:   39:                           scanner_context_t *scanner_context_p) /**< scanner context */
        -:   40:{
    #####:   41:  lexer_lit_location_t async_literal;
        -:   42:
    #####:   43:  JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC);
        -:   44:
    #####:   45:  parser_stack_pop_uint8 (context_p);
    #####:   46:  parser_stack_pop (context_p, &async_literal, sizeof (lexer_lit_location_t));
        -:   47:
    #####:   48:  lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,
        -:   49:                                                                     scanner_context_p->active_literal_pool_p,
        -:   50:                                                                     &async_literal);
        -:   51:
    #####:   52:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -:   53:
    #####:   54:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -:   55:  {
    #####:   56:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -:   57:  }
    #####:   58:} /* scanner_add_async_literal */
        -:   59:
        -:   60:/**
        -:   61: * Init scanning the body of an arrow function.
        -:   62: */
        -:   63:static void
    #####:   64:scanner_check_arrow_body (parser_context_t *context_p, /**< context */
        -:   65:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:   66:{
    #####:   67:  lexer_next_token (context_p);
        -:   68:
    #####:   69:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -:   70:  {
    #####:   71:    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:   72:    parser_stack_push_uint8 (context_p, SCAN_STACK_ARROW_EXPRESSION);
    #####:   73:    return;
        -:   74:  }
        -:   75:
    #####:   76:  lexer_next_token (context_p);
    #####:   77:  parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_ARROW);
    #####:   78:  scanner_check_directives (context_p, scanner_context_p);
        -:   79:} /* scanner_check_arrow_body */
        -:   80:
        -:   81:/**
        -:   82: * Process arrow function with argument list.
        -:   83: */
        -:   84:void
    #####:   85:scanner_check_arrow (parser_context_t *context_p, /**< context */
        -:   86:                     scanner_context_t *scanner_context_p) /**< scanner context */
        -:   87:{
    #####:   88:  parser_stack_pop_uint8 (context_p);
        -:   89:
    #####:   90:  lexer_next_token (context_p);
        -:   91:
    #####:   92:  if (context_p->token.type != LEXER_ARROW
    #####:   93:      || (context_p->token.flags & LEXER_WAS_NEWLINE))
        -:   94:  {
    #####:   95:    if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:   96:    {
    #####:   97:      scanner_add_async_literal (context_p, scanner_context_p);
        -:   98:    }
        -:   99:
    #####:  100:    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  101:    scanner_pop_literal_pool (context_p, scanner_context_p);
    #####:  102:    return;
        -:  103:  }
        -:  104:
    #####:  105:  if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  106:  {
    #####:  107:    parser_stack_pop (context_p, NULL, sizeof (lexer_lit_location_t) + 1);
        -:  108:  }
        -:  109:
    #####:  110:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
    #####:  111:  uint16_t status_flags = literal_pool_p->status_flags;
        -:  112:
    #####:  113:  status_flags |= SCANNER_LITERAL_POOL_FUNCTION_WITHOUT_ARGUMENTS;
    #####:  114:  status_flags &= (uint16_t) ~(SCANNER_LITERAL_POOL_IN_WITH
        -:  115:                               | SCANNER_LITERAL_POOL_GENERATOR
        -:  116:                               | SCANNER_LITERAL_POOL_ASYNC);
        -:  117:
    #####:  118:  context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  119:
    #####:  120:  if (status_flags & SCANNER_LITERAL_POOL_ASYNC_ARROW)
        -:  121:  {
    #####:  122:    status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####:  123:    context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  124:  }
        -:  125:
    #####:  126:  literal_pool_p->status_flags = status_flags;
        -:  127:
    #####:  128:  scanner_filter_arguments (context_p, scanner_context_p);
    #####:  129:  scanner_check_arrow_body (context_p, scanner_context_p);
        -:  130:} /* scanner_check_arrow */
        -:  131:
        -:  132:/**
        -:  133: * Process arrow function with a single argument.
        -:  134: */
        -:  135:void
    #####:  136:scanner_scan_simple_arrow (parser_context_t *context_p, /**< context */
        -:  137:                           scanner_context_t *scanner_context_p, /**< scanner context */
        -:  138:                           const uint8_t *source_p) /**< identifier end position */
        -:  139:{
    #####:  140:  uint16_t status_flags = SCANNER_LITERAL_POOL_FUNCTION_WITHOUT_ARGUMENTS;
        -:  141:
    #####:  142:  context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  143:
    #####:  144:  if (scanner_context_p->async_source_p != NULL)
        -:  145:  {
    #####:  146:    JERRY_ASSERT (scanner_context_p->async_source_p == source_p);
        -:  147:
    #####:  148:    status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####:  149:    context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  150:  }
        -:  151:
    #####:  152:  scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
    #####:  153:  literal_pool_p->source_p = source_p;
        -:  154:
    #####:  155:  lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);
    #####:  156:  location_p->type |= SCANNER_LITERAL_IS_ARG;
        -:  157:
        -:  158:  /* Skip the => token, which size is two. */
    #####:  159:  context_p->source_p += 2;
    #####:  160:  PARSER_PLUS_EQUAL_LC (context_p->column, 2);
    #####:  161:  context_p->token.flags = (uint8_t) (context_p->token.flags & ~LEXER_NO_SKIP_SPACES);
        -:  162:
    #####:  163:  scanner_check_arrow_body (context_p, scanner_context_p);
    #####:  164:} /* scanner_scan_simple_arrow */
        -:  165:
        -:  166:/**
        -:  167: * Process the next argument of a might-be arrow function.
        -:  168: */
        -:  169:void
    #####:  170:scanner_check_arrow_arg (parser_context_t *context_p, /**< context */
        -:  171:                         scanner_context_t *scanner_context_p) /**< scanner context */
        -:  172:{
    #####:  173:  JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  174:
    #####:  175:  const uint8_t *source_p = context_p->source_p;
    #####:  176:  bool process_arrow = false;
        -:  177:
    #####:  178:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  179:
    #####:  180:  if (context_p->token.type == LEXER_THREE_DOTS)
        -:  181:  {
    #####:  182:    lexer_next_token (context_p);
        -:  183:  }
        -:  184:
    #####:  185:  if (context_p->token.type == LEXER_LITERAL
    #####:  186:      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  187:  {
    #####:  188:    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -:  189:
    #####:  190:    if (lexer_check_arrow (context_p))
        -:  191:    {
    #####:  192:      process_arrow = true;
        -:  193:    }
        -:  194:    else
        -:  195:    {
    #####:  196:      lexer_lit_location_t *argument_literal_p = scanner_append_argument (context_p, scanner_context_p);
        -:  197:
    #####:  198:      scanner_detect_eval_call (context_p, scanner_context_p);
        -:  199:
    #####:  200:      lexer_next_token (context_p);
        -:  201:
    #####:  202:      if (context_p->token.type == LEXER_ASSIGN)
        -:  203:      {
    #####:  204:        if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  205:        {
    #####:  206:          JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);
    #####:  207:          return;
        -:  208:        }
        -:  209:
    #####:  210:        scanner_binding_literal_t binding_literal;
    #####:  211:        binding_literal.literal_p = argument_literal_p;
        -:  212:
    #####:  213:        parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####:  214:        parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
    #####:  215:        return;
        -:  216:      }
        -:  217:
    #####:  218:      if (context_p->token.type == LEXER_COMMA || context_p->token.type == LEXER_RIGHT_PAREN)
        -:  219:      {
    #####:  220:        return;
        -:  221:      }
        -:  222:    }
        -:  223:  }
    #####:  224:  else if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -:  225:  {
    #####:  226:    scanner_append_hole (context_p, scanner_context_p);
    #####:  227:    scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_ARROW_ARG, false);
        -:  228:
    #####:  229:    if (context_p->token.type == LEXER_LEFT_BRACE)
        -:  230:    {
    #####:  231:      parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####:  232:      scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####:  233:      return;
        -:  234:    }
        -:  235:
    #####:  236:    parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####:  237:    scanner_context_p->mode = SCAN_MODE_BINDING;
    #####:  238:    lexer_next_token (context_p);
    #####:  239:    return;
        -:  240:  }
        -:  241:
    #####:  242:  scanner_pop_literal_pool (context_p, scanner_context_p);
        -:  243:
    #####:  244:  parser_stack_pop_uint8 (context_p);
    #####:  245:  parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
        -:  246:
    #####:  247:  if (process_arrow)
        -:  248:  {
    #####:  249:    scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);
        -:  250:  }
        -:  251:} /* scanner_check_arrow_arg */
        -:  252:
        -:  253:/**
        -:  254: * Detect async functions.
        -:  255: *
        -:  256: * @return true, if async is followed by a function keyword, false otherwise
        -:  257: */
        -:  258:bool
    #####:  259:scanner_check_async_function (parser_context_t *context_p, /**< context */
        -:  260:                              scanner_context_t *scanner_context_p) /**< scanner context */
        -:  261:{
    #####:  262:  JERRY_ASSERT (lexer_token_is_async (context_p));
    #####:  263:  JERRY_ASSERT (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION);
    #####:  264:  JERRY_ASSERT (scanner_context_p->async_source_p != NULL);
        -:  265:
    #####:  266:  lexer_lit_location_t async_literal = context_p->token.lit_location;
        -:  267:
    #####:  268:  lexer_next_token (context_p);
        -:  269:
    #####:  270:  if (!(context_p->token.flags & LEXER_WAS_NEWLINE))
        -:  271:  {
    #####:  272:    if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -:  273:    {
    #####:  274:      return true;
        -:  275:    }
        -:  276:
    #####:  277:    if (context_p->token.type == LEXER_LITERAL
    #####:  278:        && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  279:    {
    #####:  280:      if (!lexer_check_arrow (context_p))
        -:  281:      {
    #####:  282:        scanner_raise_error (context_p);
        -:  283:      }
        -:  284:
    #####:  285:      scanner_scan_simple_arrow (context_p, scanner_context_p, scanner_context_p->async_source_p);
    #####:  286:      scanner_context_p->async_source_p = NULL;
    #####:  287:      return false;
        -:  288:    }
        -:  289:
    #####:  290:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -:  291:    {
    #####:  292:      parser_stack_push (context_p, &async_literal, sizeof (lexer_lit_location_t));
    #####:  293:      parser_stack_push_uint8 (context_p, SCAN_STACK_USE_ASYNC);
    #####:  294:      return false;
        -:  295:    }
        -:  296:  }
        -:  297:
    #####:  298:  lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,
        -:  299:                                                                     scanner_context_p->active_literal_pool_p,
        -:  300:                                                                     &async_literal);
    #####:  301:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -:  302:
    #####:  303:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -:  304:  {
    #####:  305:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -:  306:  }
        -:  307:
    #####:  308:  scanner_context_p->async_source_p = NULL;
    #####:  309:  scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  310:  return false;
        -:  311:} /* scanner_check_async_function */
        -:  312:
        -:  313:/**
        -:  314: * Check whether the statement of an if/else construct is a function statement.
        -:  315: */
        -:  316:void
    #####:  317:scanner_check_function_after_if (parser_context_t *context_p, /**< context */
        -:  318:                                 scanner_context_t *scanner_context_p) /**< scanner context */
        -:  319:{
    #####:  320:  lexer_next_token (context_p);
    #####:  321:  scanner_context_p->mode = SCAN_MODE_STATEMENT;
        -:  322:
    #####:  323:  if (JERRY_UNLIKELY (context_p->token.type == LEXER_KEYW_FUNCTION))
        -:  324:  {
        -:  325:    scanner_literal_pool_t *literal_pool_p;
    #####:  326:    literal_pool_p = scanner_push_literal_pool (context_p,
        -:  327:                                                scanner_context_p,
        -:  328:                                                SCANNER_LITERAL_POOL_BLOCK);
        -:  329:
    #####:  330:    literal_pool_p->source_p = context_p->source_p;
    #####:  331:    parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);
        -:  332:  }
    #####:  333:} /* scanner_check_function_after_if */
        -:  334:
        -:  335:/**
        -:  336: * Arrow types for scanner_scan_bracket() function.
        -:  337: */
        -:  338:typedef enum
        -:  339:{
        -:  340:  SCANNER_SCAN_BRACKET_NO_ARROW, /**< not an arrow function */
        -:  341:  SCANNER_SCAN_BRACKET_SIMPLE_ARROW, /**< simple arrow function */
        -:  342:  SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG, /**< arrow function with one argument */
        -:  343:} scanner_scan_bracket_arrow_type_t;
        -:  344:
        -:  345:#endif /* ENABLED (JERRY_ES2015) */
        -:  346:
        -:  347:/**
        -:  348: * Scan bracketed expressions.
        -:  349: */
        -:  350:void
    #####:  351:scanner_scan_bracket (parser_context_t *context_p, /**< context */
        -:  352:                      scanner_context_t *scanner_context_p) /**< scanner context */
        -:  353:{
    #####:  354:  size_t depth = 0;
        -:  355:#if ENABLED (JERRY_ES2015)
        -:  356:  const uint8_t *arrow_source_p;
    #####:  357:  const uint8_t *async_source_p = NULL;
    #####:  358:  scanner_scan_bracket_arrow_type_t arrow_type = SCANNER_SCAN_BRACKET_NO_ARROW;
        -:  359:#endif /* ENABLED (JERRY_ES2015) */
        -:  360:
    #####:  361:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_PAREN);
        -:  362:
        -:  363:  do
        -:  364:  {
        -:  365:#if ENABLED (JERRY_ES2015)
    #####:  366:    arrow_source_p = context_p->source_p;
        -:  367:#endif /* ENABLED (JERRY_ES2015) */
    #####:  368:    depth++;
    #####:  369:    lexer_next_token (context_p);
        -:  370:  }
    #####:  371:  while (context_p->token.type == LEXER_LEFT_PAREN);
        -:  372:
    #####:  373:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  374:
    #####:  375:  switch (context_p->token.type)
        -:  376:  {
    #####:  377:    case LEXER_LITERAL:
        -:  378:    {
    #####:  379:      if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  380:      {
        -:  381:#if ENABLED (JERRY_ES2015)
    #####:  382:        arrow_source_p = NULL;
        -:  383:#endif /* ENABLED (JERRY_ES2015) */
    #####:  384:        break;
        -:  385:      }
        -:  386:
        -:  387:#if ENABLED (JERRY_ES2015)
    #####:  388:      const uint8_t *source_p = context_p->source_p;
        -:  389:
    #####:  390:      if (lexer_check_arrow (context_p))
        -:  391:      {
    #####:  392:        arrow_source_p = source_p;
    #####:  393:        arrow_type = SCANNER_SCAN_BRACKET_SIMPLE_ARROW;
    #####:  394:        break;
        -:  395:      }
        -:  396:
    #####:  397:      size_t total_depth = depth;
        -:  398:#endif /* ENABLED (JERRY_ES2015) */
        -:  399:
    #####:  400:      while (depth > 0 && lexer_check_next_character (context_p, LIT_CHAR_RIGHT_PAREN))
        -:  401:      {
    #####:  402:        lexer_consume_next_character (context_p);
    #####:  403:        depth--;
        -:  404:      }
        -:  405:
    #####:  406:      if (context_p->token.keyword_type == LEXER_KEYW_EVAL
    #####:  407:          && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  408:      {
        -:  409:#if ENABLED (JERRY_ES2015)
        -:  410:        /* A function call cannot be an eval function. */
    #####:  411:        arrow_source_p = NULL;
        -:  412:#endif /* ENABLED (JERRY_ES2015) */
        -:  413:
    #####:  414:        scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
    #####:  415:        break;
        -:  416:      }
        -:  417:
        -:  418:#if ENABLED (JERRY_ES2015)
    #####:  419:      if (total_depth == depth)
        -:  420:      {
    #####:  421:        if (lexer_check_arrow_param (context_p))
        -:  422:        {
    #####:  423:          JERRY_ASSERT (depth > 0);
    #####:  424:          depth--;
    #####:  425:          break;
        -:  426:        }
        -:  427:
    #####:  428:        if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -:  429:        {
    #####:  430:          async_source_p = source_p;
        -:  431:        }
        -:  432:      }
    #####:  433:      else if (depth == total_depth - 1 && lexer_check_arrow (context_p))
        -:  434:      {
    #####:  435:        arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;
    #####:  436:        break;
        -:  437:      }
        -:  438:
    #####:  439:      arrow_source_p = NULL;
        -:  440:#endif /* ENABLED (JERRY_ES2015) */
    #####:  441:      break;
        -:  442:    }
        -:  443:#if ENABLED (JERRY_ES2015)
    #####:  444:    case LEXER_THREE_DOTS:
        -:  445:    case LEXER_LEFT_SQUARE:
        -:  446:    case LEXER_LEFT_BRACE:
        -:  447:    case LEXER_RIGHT_PAREN:
        -:  448:    {
    #####:  449:      JERRY_ASSERT (depth > 0);
    #####:  450:      depth--;
    #####:  451:      break;
        -:  452:    }
        -:  453:#endif /* ENABLED (JERRY_ES2015) */
    #####:  454:    default:
        -:  455:    {
        -:  456:#if ENABLED (JERRY_ES2015)
    #####:  457:      arrow_source_p = NULL;
        -:  458:#endif /* ENABLED (JERRY_ES2015) */
    #####:  459:      break;
        -:  460:    }
        -:  461:  }
        -:  462:
        -:  463:#if ENABLED (JERRY_ES2015)
    #####:  464:  if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL)
    #####:  465:      && (arrow_source_p == NULL || depth > 0))
        -:  466:  {
    #####:  467:    scanner_context_p->async_source_p = NULL;
        -:  468:  }
        -:  469:#endif /* ENABLED (JERRY_ES2015) */
        -:  470:
    #####:  471:  while (depth > 0)
        -:  472:  {
    #####:  473:    parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
    #####:  474:    depth--;
        -:  475:  }
        -:  476:
        -:  477:#if ENABLED (JERRY_ES2015)
    #####:  478:  if (arrow_source_p != NULL)
        -:  479:  {
    #####:  480:    JERRY_ASSERT (async_source_p == NULL);
        -:  481:
    #####:  482:    if (arrow_type == SCANNER_SCAN_BRACKET_SIMPLE_ARROW)
        -:  483:    {
    #####:  484:      scanner_scan_simple_arrow (context_p, scanner_context_p, arrow_source_p);
    #####:  485:      return;
        -:  486:    }
        -:  487:
    #####:  488:    parser_stack_push_uint8 (context_p, SCAN_STACK_ARROW_ARGUMENTS);
        -:  489:
    #####:  490:    uint16_t status_flags = 0;
        -:  491:
    #####:  492:    if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL))
        -:  493:    {
    #####:  494:      status_flags |= SCANNER_LITERAL_POOL_ASYNC_ARROW;
    #####:  495:      arrow_source_p = scanner_context_p->async_source_p;
    #####:  496:      scanner_context_p->async_source_p = NULL;
        -:  497:    }
        -:  498:
        -:  499:    scanner_literal_pool_t *literal_pool_p;
    #####:  500:    literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
    #####:  501:    literal_pool_p->source_p = arrow_source_p;
        -:  502:
    #####:  503:    if (arrow_type == SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG)
        -:  504:    {
    #####:  505:      scanner_append_argument (context_p, scanner_context_p);
    #####:  506:      scanner_detect_eval_call (context_p, scanner_context_p);
        -:  507:
    #####:  508:      context_p->token.type = LEXER_RIGHT_PAREN;
    #####:  509:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  510:    }
    #####:  511:    else if (context_p->token.type == LEXER_RIGHT_PAREN)
        -:  512:    {
    #####:  513:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  514:    }
        -:  515:    else
        -:  516:    {
    #####:  517:      scanner_check_arrow_arg (context_p, scanner_context_p);
        -:  518:    }
        -:  519:  }
    #####:  520:  else if (JERRY_UNLIKELY (async_source_p != NULL))
        -:  521:  {
    #####:  522:    scanner_context_p->async_source_p = async_source_p;
    #####:  523:    scanner_check_async_function (context_p, scanner_context_p);
        -:  524:  }
        -:  525:#endif /* ENABLED (JERRY_ES2015) */
    #####:  526:} /* scanner_scan_bracket */
        -:  527:
        -:  528:/**
        -:  529: * Check directives before a source block.
        -:  530: */
        -:  531:void
     1300:  532:scanner_check_directives (parser_context_t *context_p, /**< context */
        -:  533:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:  534:{
     1300:  535:  scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        -:  536:
     2601:  537:  while (context_p->token.type == LEXER_LITERAL
        1:  538:         && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -:  539:  {
        1:  540:    bool is_use_strict = false;
        -:  541:
        1:  542:    if (lexer_string_is_use_strict (context_p)
        1:  543:        && !(context_p->status_flags & PARSER_IS_STRICT))
        -:  544:    {
        1:  545:      is_use_strict = true;
        1:  546:      context_p->status_flags |= PARSER_IS_STRICT;
        -:  547:    }
        -:  548:
        1:  549:    lexer_next_token (context_p);
        -:  550:
        1:  551:    if (!lexer_string_is_directive (context_p))
        -:  552:    {
    #####:  553:      if (is_use_strict)
        -:  554:      {
    #####:  555:        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -:  556:      }
        -:  557:
        -:  558:      /* The string is part of an expression statement. */
    #####:  559:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  560:      break;
        -:  561:    }
        -:  562:
        1:  563:    if (is_use_strict)
        -:  564:    {
        1:  565:      scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -:  566:    }
        -:  567:
        1:  568:    if (context_p->token.type == LEXER_SEMICOLON)
        -:  569:    {
    #####:  570:      lexer_next_token (context_p);
        -:  571:    }
        -:  572:  }
     1300:  573:} /* scanner_check_directives */
        -:  574:
        -:  575:/**
        -:  576: * @}
        -:  577: * @}
        -:  578: * @}
        -:  579: */
        -:  580:
        -:  581:#endif /* ENABLED (JERRY_PARSER) */
