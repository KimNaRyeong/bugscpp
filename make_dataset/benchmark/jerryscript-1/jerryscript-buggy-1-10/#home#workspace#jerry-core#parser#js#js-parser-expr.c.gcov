        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-expr.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:
        -:   18:#if ENABLED (JERRY_PARSER)
        -:   19:#include "jcontext.h"
        -:   20:
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "lit-char-helpers.h"
        -:   23:#include "js-parser-tagged-template-literal.h"
        -:   24:
        -:   25:/** \addtogroup parser Parser
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser JavaScript
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup jsparser_expr Expression parser
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:/**
        -:   36: * Maximum precedence for right-to-left binary operation evaluation.
        -:   37: */
        -:   38:#define PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE 6
        -:   39:
        -:   40:/**
        -:   41: * Precedence for ternary operation.
        -:   42: */
        -:   43:#define PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE 4
        -:   44:
        -:   45:/**
        -:   46: * Precedence for exponentiation operation.
        -:   47: */
        -:   48:#define PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION 15
        -:   49:
        -:   50:/**
        -:   51: * Value of grouping level increase and decrease.
        -:   52: */
        -:   53:#define PARSER_GROUPING_LEVEL_INCREASE 2
        -:   54:
        -:   55:/**
        -:   56: * Precedence of the binary tokens.
        -:   57: *
        -:   58: * See also:
        -:   59: *    lexer_token_type_t
        -:   60: */
        -:   61:static const uint8_t parser_binary_precedence_table[] =
        -:   62:{
        -:   63:  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        -:   64:#if ENABLED (JERRY_ES2015)
        -:   65:  3,
        -:   66:#endif /* ENABLED (JERRY_ES2015) */
        -:   67:  4, 5, 6, 7, 8, 9, 10, 10, 10, 10,
        -:   68:  11, 11, 11, 11, 11, 11, 12, 12, 12,
        -:   69:  13, 13, 14, 14, 14,
        -:   70:#if ENABLED (JERRY_ES2015)
        -:   71:  15,
        -:   72:#endif /* ENABLED (JERRY_ES2015) */
        -:   73:};
        -:   74:
        -:   75:#if ENABLED (JERRY_ES2015)
        -:   76:JERRY_STATIC_ASSERT (sizeof (parser_binary_precedence_table) == 38,
        -:   77:                     parser_binary_precedence_table_should_have_38_values_in_es2015);
        -:   78:#else /* !ENABLED (JERRY_ES2015) */
        -:   79:JERRY_STATIC_ASSERT (sizeof (parser_binary_precedence_table) == 36,
        -:   80:                     parser_binary_precedence_table_should_have_36_values_in_es51);
        -:   81:#endif /* ENABLED (JERRY_ES2015) */
        -:   82:
        -:   83:/**
        -:   84: * Generate byte code for operators with lvalue.
        -:   85: */
        -:   86:static inline void
       44:   87:parser_push_result (parser_context_t *context_p) /**< context */
        -:   88:{
       44:   89:  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -:   90:  {
        2:   91:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 1));
        -:   92:
        2:   93:    if ((context_p->last_cbc_opcode == CBC_POST_INCR
        2:   94:         || context_p->last_cbc_opcode == CBC_POST_DECR)
    #####:   95:        && context_p->stack_depth >= context_p->stack_limit)
        -:   96:    {
        -:   97:      /* Stack limit is increased for CBC_POST_INCR_PUSH_RESULT
        -:   98:       * and CBC_POST_DECR_PUSH_RESULT opcodes. Needed by vm.c. */
    #####:   99:      JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);
        -:  100:
    #####:  101:      context_p->stack_limit++;
        -:  102:
    #####:  103:      if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -:  104:      {
    #####:  105:        parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  106:      }
        -:  107:    }
        -:  108:
        2:  109:    context_p->last_cbc_opcode++;
        2:  110:    parser_flush_cbc (context_p);
        -:  111:  }
       44:  112:} /* parser_push_result */
        -:  113:
        -:  114:/**
        -:  115: * Check for invalid assignment for "eval" and "arguments"
        -:  116: */
        -:  117:static void
        1:  118:parser_check_invalid_assign (parser_context_t *context_p) /**< context */
        -:  119:{
        1:  120:  JERRY_ASSERT (context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL);
        -:  121:
        1:  122:  if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))
        -:  123:  {
    #####:  124:    if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL)
        -:  125:    {
    #####:  126:      parser_raise_error (context_p, PARSER_ERR_EVAL_CANNOT_ASSIGNED);
        -:  127:    }
    #####:  128:    else if (context_p->last_cbc.literal_keyword_type == LEXER_KEYW_ARGUMENTS)
        -:  129:    {
    #####:  130:      parser_raise_error (context_p, PARSER_ERR_ARGUMENTS_CANNOT_ASSIGNED);
        -:  131:    }
        -:  132:  }
        1:  133:} /* parser_check_invalid_assign */
        -:  134:
        -:  135:#if ENABLED (JERRY_ES2015)
        -:  136:
        -:  137:/**
        -:  138: * Check and throw an error if the "new.target" is invalid as a left-hand side expression.
        -:  139: */
        -:  140:static void
    #####:  141:parser_check_invalid_new_target (parser_context_t *context_p, /**< parser context */
        -:  142:                                 cbc_opcode_t opcode) /**< current opcode under parsing */
        -:  143:{
        -:  144:  /* new.target is an invalid left-hand side target */
    #####:  145:  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NEW_TARGET))
        -:  146:  {
        -:  147:    /* Make sure that the call side is a post/pre increment or an assignment expression.
        -:  148:     * There should be no other ways the "new.target" expression should be here. */
    #####:  149:    JERRY_ASSERT ((opcode >= CBC_PRE_INCR && opcode <= CBC_POST_DECR)
        -:  150:                  || (opcode == CBC_ASSIGN
        -:  151:                      && (context_p->token.type == LEXER_ASSIGN
        -:  152:                          || LEXER_IS_BINARY_LVALUE_TOKEN (context_p->token.type))));
        -:  153:
    #####:  154:    parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);
        -:  155:  }
    #####:  156:} /* parser_check_invalid_new_target */
        -:  157:
        -:  158:#endif /* ENABLED (JERRY_ES2015) */
        -:  159:
        -:  160:/**
        -:  161: * Emit identifier reference
        -:  162: */
        -:  163:static void
    #####:  164:parser_emit_ident_reference (parser_context_t *context_p, /**< context */
        -:  165:                             uint16_t opcode) /* opcode */
        -:  166:{
    #####:  167:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -:  168:  {
    #####:  169:    context_p->last_cbc_opcode = opcode;
    #####:  170:    return;
        -:  171:  }
        -:  172:
        -:  173:  uint16_t literal_index;
        -:  174:
    #####:  175:  if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -:  176:  {
    #####:  177:    context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  178:    literal_index = context_p->last_cbc.value;
        -:  179:  }
    #####:  180:  else if (context_p->last_cbc_opcode == CBC_PUSH_THIS_LITERAL)
        -:  181:  {
    #####:  182:    context_p->last_cbc_opcode = CBC_PUSH_THIS;
    #####:  183:    literal_index = context_p->last_cbc.literal_index;
        -:  184:  }
        -:  185:  else
        -:  186:  {
    #####:  187:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);
    #####:  188:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####:  189:    literal_index = context_p->last_cbc.third_literal_index;
        -:  190:  }
        -:  191:
    #####:  192:  parser_emit_cbc_literal (context_p, opcode, literal_index);
        -:  193:} /* parser_emit_ident_reference */
        -:  194:
        -:  195:/**
        -:  196: * Generate byte code for operators with lvalue.
        -:  197: */
        -:  198:static void
    #####:  199:parser_emit_unary_lvalue_opcode (parser_context_t *context_p, /**< context */
        -:  200:                                 cbc_opcode_t opcode) /**< opcode */
        -:  201:{
    #####:  202:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####:  203:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -:  204:  {
    #####:  205:    parser_check_invalid_assign (context_p);
        -:  206:
        -:  207:    uint16_t unary_opcode;
        -:  208:
    #####:  209:    if (opcode == CBC_DELETE_PUSH_RESULT)
        -:  210:    {
    #####:  211:      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_IS_STRICT))
        -:  212:      {
    #####:  213:        parser_raise_error (context_p, PARSER_ERR_DELETE_IDENT_NOT_ALLOWED);
        -:  214:      }
        -:  215:
    #####:  216:      unary_opcode = CBC_DELETE_IDENT_PUSH_RESULT;
        -:  217:    }
        -:  218:    else
        -:  219:    {
    #####:  220:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, opcode + CBC_UNARY_LVALUE_WITH_IDENT));
    #####:  221:      unary_opcode = (uint16_t) (opcode + CBC_UNARY_LVALUE_WITH_IDENT);
        -:  222:    }
        -:  223:
    #####:  224:    parser_emit_ident_reference (context_p, unary_opcode);
        -:  225:
        -:  226:#if ENABLED (JERRY_ES2015)
    #####:  227:    if (unary_opcode != CBC_DELETE_IDENT_PUSH_RESULT
    #####:  228:        && scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))
        -:  229:    {
        -:  230:      /* The current value must be read, but it cannot be changed. */
    #####:  231:      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####:  232:      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);
        -:  233:    }
        -:  234:#endif /* ENABLED (JERRY_ES2015) */
    #####:  235:    return;
        -:  236:  }
        -:  237:
    #####:  238:  if (context_p->last_cbc_opcode == CBC_PUSH_PROP)
        -:  239:  {
    #####:  240:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, opcode));
    #####:  241:    context_p->last_cbc_opcode = (uint16_t) opcode;
    #####:  242:    return;
        -:  243:  }
        -:  244:
    #####:  245:  if (PARSER_IS_PUSH_PROP_LITERAL (context_p->last_cbc_opcode))
        -:  246:  {
    #####:  247:    context_p->last_cbc_opcode = PARSER_PUSH_PROP_LITERAL_TO_PUSH_LITERAL (context_p->last_cbc_opcode);
        -:  248:  }
        -:  249:  else
        -:  250:  {
        -:  251:    /* Invalid LeftHandSide expression. */
    #####:  252:    if (opcode == CBC_DELETE_PUSH_RESULT)
        -:  253:    {
        -:  254:#if ENABLED (JERRY_ES2015)
    #####:  255:      if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL)
    #####:  256:          || context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -:  257:      {
    #####:  258:        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
    #####:  259:        parser_emit_cbc (context_p, CBC_POP);
    #####:  260:        return;
        -:  261:      }
        -:  262:#endif /* ENABLED (JERRY_ES2015) */
    #####:  263:      parser_emit_cbc (context_p, CBC_POP);
    #####:  264:      parser_emit_cbc (context_p, CBC_PUSH_TRUE);
    #####:  265:      return;
        -:  266:    }
        -:  267:
        -:  268:#if ENABLED (JERRY_ES2015)
    #####:  269:    parser_check_invalid_new_target (context_p, opcode);
        -:  270:#endif /* ENABLED (JERRY_ES2015) */
        -:  271:
    #####:  272:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -:  273:  }
        -:  274:
    #####:  275:  parser_emit_cbc (context_p, (uint16_t) opcode);
        -:  276:} /* parser_emit_unary_lvalue_opcode */
        -:  277:
        -:  278:/**
        -:  279: * Parse array literal.
        -:  280: */
        -:  281:static void
        2:  282:parser_parse_array_literal (parser_context_t *context_p) /**< context */
        -:  283:{
        2:  284:  uint32_t pushed_items = 0;
        2:  285:  uint16_t opcode = (uint16_t) CBC_ARRAY_APPEND;
        -:  286:
        2:  287:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);
        -:  288:
        2:  289:  parser_emit_cbc (context_p, CBC_CREATE_ARRAY);
        2:  290:  lexer_next_token (context_p);
        -:  291:
        -:  292:  while (true)
        -:  293:  {
       10:  294:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  295:    {
        2:  296:      if (pushed_items > 0)
        -:  297:      {
        1:  298:        parser_emit_cbc_call (context_p, opcode, pushed_items);
        -:  299:      }
        4:  300:      return;
        -:  301:    }
        -:  302:
        4:  303:    pushed_items++;
        -:  304:
        4:  305:    if (context_p->token.type == LEXER_COMMA)
        -:  306:    {
    #####:  307:      parser_emit_cbc (context_p, CBC_PUSH_ELISION);
    #####:  308:      lexer_next_token (context_p);
        -:  309:    }
        -:  310:    else
        -:  311:    {
        -:  312:#if ENABLED (JERRY_ES2015)
        4:  313:      if (context_p->token.type == LEXER_THREE_DOTS)
        -:  314:      {
    #####:  315:        opcode = (uint16_t) (PARSER_TO_EXT_OPCODE (CBC_EXT_SPREAD_ARRAY_APPEND));
    #####:  316:        pushed_items++;
    #####:  317:        lexer_next_token (context_p);
    #####:  318:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);
        -:  319:      }
        -:  320:#endif /* ENABLED (JERRY_ES2015) */
        -:  321:
        4:  322:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -:  323:
        4:  324:      if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -:  325:      {
    #####:  326:        parser_flush_cbc (context_p);
        -:  327:      }
        -:  328:
        4:  329:      if (context_p->token.type == LEXER_COMMA)
        -:  330:      {
        3:  331:        lexer_next_token (context_p);
        -:  332:      }
        1:  333:      else if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -:  334:      {
    #####:  335:        parser_raise_error (context_p, PARSER_ERR_ARRAY_ITEM_SEPARATOR_EXPECTED);
        -:  336:      }
        -:  337:    }
        -:  338:
        4:  339:    if (pushed_items >= 64)
        -:  340:    {
    #####:  341:      parser_emit_cbc_call (context_p, opcode, pushed_items);
        -:  342:#if ENABLED (JERRY_ES2015)
    #####:  343:      opcode = (uint16_t) CBC_ARRAY_APPEND;
        -:  344:#endif /* ENABLED (JERRY_ES2015) */
    #####:  345:      pushed_items = 0;
        -:  346:    }
        -:  347:  }
        -:  348:} /* parser_parse_array_literal */
        -:  349:
        -:  350:#if !ENABLED (JERRY_ES2015)
        -:  351:/**
        -:  352: * Object literal item types.
        -:  353: */
        -:  354:typedef enum
        -:  355:{
        -:  356:  PARSER_OBJECT_PROPERTY_START,                /**< marks the start of the property list */
        -:  357:  PARSER_OBJECT_PROPERTY_VALUE,                /**< value property */
        -:  358:  PARSER_OBJECT_PROPERTY_GETTER,               /**< getter property */
        -:  359:  PARSER_OBJECT_PROPERTY_SETTER,               /**< setter property */
        -:  360:  PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS,       /**< both getter and setter properties are set */
        -:  361:} parser_object_literal_item_types_t;
        -:  362:
        -:  363:/**
        -:  364: * Parse object literal.
        -:  365: */
        -:  366:static void
    #####:  367:parser_append_object_literal_item (parser_context_t *context_p, /**< context */
        -:  368:                                   uint16_t item_index, /**< index of the item name */
        -:  369:                                   parser_object_literal_item_types_t item_type) /**< type of the item */
        -:  370:{
        -:  371:  parser_stack_iterator_t iterator;
        -:  372:  uint8_t *current_item_type_p;
        -:  373:
    #####:  374:  iterator.current_p = context_p->stack.first_p;
    #####:  375:  iterator.current_position = context_p->stack.last_position;
        -:  376:
        -:  377:  while (true)
    #####:  378:  {
    #####:  379:    current_item_type_p = iterator.current_p->bytes + iterator.current_position - 1;
        -:  380:
    #####:  381:    if (*current_item_type_p == PARSER_OBJECT_PROPERTY_START)
        -:  382:    {
    #####:  383:      parser_stack_push_uint16 (context_p, item_index);
    #####:  384:      parser_stack_push_uint8 (context_p, (uint8_t) item_type);
    #####:  385:      return;
        -:  386:    }
        -:  387:
    #####:  388:    iterator.current_position--;
    #####:  389:    if (iterator.current_position == 0)
        -:  390:    {
    #####:  391:      iterator.current_p = iterator.current_p->next_p;
    #####:  392:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  393:    }
        -:  394:
    #####:  395:    uint32_t current_item_index = iterator.current_p->bytes[iterator.current_position - 1];
        -:  396:
    #####:  397:    iterator.current_position--;
    #####:  398:    if (iterator.current_position == 0)
        -:  399:    {
    #####:  400:      iterator.current_p = iterator.current_p->next_p;
    #####:  401:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  402:    }
        -:  403:
    #####:  404:    current_item_index |= ((uint32_t) iterator.current_p->bytes[iterator.current_position - 1]) << 8;
        -:  405:
    #####:  406:    iterator.current_position--;
    #####:  407:    if (iterator.current_position == 0)
        -:  408:    {
    #####:  409:      iterator.current_p = iterator.current_p->next_p;
    #####:  410:      iterator.current_position = PARSER_STACK_PAGE_SIZE;
        -:  411:    }
        -:  412:
    #####:  413:    if (current_item_index == item_index)
        -:  414:    {
    #####:  415:      if (item_type == PARSER_OBJECT_PROPERTY_VALUE
    #####:  416:          && *current_item_type_p == PARSER_OBJECT_PROPERTY_VALUE
    #####:  417:          && !(context_p->status_flags & PARSER_IS_STRICT))
        -:  418:      {
    #####:  419:        return;
        -:  420:      }
        -:  421:
    #####:  422:      if (item_type == PARSER_OBJECT_PROPERTY_GETTER
    #####:  423:          && *current_item_type_p == PARSER_OBJECT_PROPERTY_SETTER)
        -:  424:      {
    #####:  425:        break;
        -:  426:      }
        -:  427:
    #####:  428:      if (item_type == PARSER_OBJECT_PROPERTY_SETTER
    #####:  429:          && *current_item_type_p == PARSER_OBJECT_PROPERTY_GETTER)
        -:  430:      {
    #####:  431:        break;
        -:  432:      }
        -:  433:
    #####:  434:      parser_raise_error (context_p, PARSER_ERR_OBJECT_PROPERTY_REDEFINED);
        -:  435:    }
        -:  436:  }
        -:  437:
    #####:  438:  uint8_t *last_page_p = context_p->stack.first_p->bytes;
        -:  439:
    #####:  440:  *current_item_type_p = PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS;
        -:  441:
    #####:  442:  if (current_item_type_p == (last_page_p + context_p->stack.last_position - 1))
        -:  443:  {
    #####:  444:    context_p->stack_top_uint8 = PARSER_OBJECT_PROPERTY_BOTH_ACCESSORS;
        -:  445:  }
        -:  446:} /* parser_append_object_literal_item */
        -:  447:#endif /* !ENABLED (JERRY_ES2015) */
        -:  448:
        -:  449:#if ENABLED (JERRY_ES2015)
        -:  450:/** Forward definition of parse array initializer. */
        -:  451:static void
        -:  452:parser_parse_array_initializer (parser_context_t *context_p, parser_pattern_flags_t flags);
        -:  453:
        -:  454:/** Forward definition of parse object initializer. */
        -:  455:static void
        -:  456:parser_parse_object_initializer (parser_context_t *context_p, parser_pattern_flags_t flags);
        -:  457:
        -:  458:/**
        -:  459: * Description of "get" literal string.
        -:  460: */
        -:  461:static const lexer_lit_location_t lexer_get_literal =
        -:  462:{
        -:  463:  (const uint8_t *) "get", 3, LEXER_STRING_LITERAL, false
        -:  464:};
        -:  465:
        -:  466:/**
        -:  467: * Description of "set" literal string.
        -:  468: */
        -:  469:static const lexer_lit_location_t lexer_set_literal =
        -:  470:{
        -:  471:  (const uint8_t *) "set", 3, LEXER_STRING_LITERAL, false
        -:  472:};
        -:  473:
        -:  474:/**
        -:  475: * Class literal parsing options.
        -:  476: */
        -:  477:typedef enum
        -:  478:{
        -:  479:  PARSER_CLASS_LITERAL_NO_OPTS = 0,                   /**< no options are provided */
        -:  480:  PARSER_CLASS_LITERAL_CTOR_PRESENT = (1 << 0),       /**< class constructor is present */
        -:  481:  PARSER_CLASS_LITERAL_HERTIAGE_PRESENT = (1 << 1),   /**< class heritage is present */
        -:  482:} parser_class_literal_opts_t;
        -:  483:
        -:  484:/**
        -:  485: * Parse class literal.
        -:  486: */
        -:  487:static void
    #####:  488:parser_parse_class_literal (parser_context_t *context_p, /**< context */
        -:  489:                            parser_class_literal_opts_t opts) /**< class literal parsing options */
        -:  490:{
    #####:  491:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);
        -:  492:
    #####:  493:  uint32_t status_flags = PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER;
        -:  494:
    #####:  495:  lexer_literal_t *ctor_literal_p = NULL;
        -:  496:
    #####:  497:  if (opts & PARSER_CLASS_LITERAL_CTOR_PRESENT)
        -:  498:  {
    #####:  499:    if (context_p->literal_count >= PARSER_MAXIMUM_NUMBER_OF_LITERALS)
        -:  500:    {
    #####:  501:      parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
        -:  502:    }
        -:  503:
    #####:  504:    ctor_literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
    #####:  505:    ctor_literal_p->type = LEXER_UNUSED_LITERAL;
    #####:  506:    ctor_literal_p->status_flags = 0;
    #####:  507:    parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, (uint16_t) (context_p->literal_count++));
        -:  508:  }
    #####:  509:  else if (opts & PARSER_CLASS_LITERAL_HERTIAGE_PRESENT)
        -:  510:  {
    #####:  511:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR_HERITAGE);
        -:  512:  }
        -:  513:  else
        -:  514:  {
    #####:  515:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR);
        -:  516:  }
        -:  517:
    #####:  518:  parser_emit_cbc_ext (context_p, CBC_EXT_INIT_CLASS);
        -:  519:
    #####:  520:  bool is_static = false;
        -:  521:
        -:  522:  while (true)
    #####:  523:  {
    #####:  524:    if (!is_static)
        -:  525:    {
    #####:  526:      lexer_skip_empty_statements (context_p);
        -:  527:    }
        -:  528:
    #####:  529:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_CLASS_METHOD);
        -:  530:
    #####:  531:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -:  532:    {
    #####:  533:      break;
        -:  534:    }
        -:  535:
    #####:  536:    bool is_computed = false;
        -:  537:
    #####:  538:    if (context_p->token.type == LEXER_PROPERTY_GETTER || context_p->token.type == LEXER_PROPERTY_SETTER)
        -:  539:    {
        -:  540:      uint16_t literal_index, function_literal_index;
    #####:  541:      bool is_getter = (context_p->token.type == LEXER_PROPERTY_GETTER);
        -:  542:
    #####:  543:      if (lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  544:      {
    #####:  545:        lexer_construct_literal_object (context_p,
        -:  546:                                        (is_getter ? (lexer_lit_location_t *) &lexer_get_literal
        -:  547:                                                   : (lexer_lit_location_t *) &lexer_set_literal),
        -:  548:                                        LEXER_STRING_LITERAL);
    #####:  549:        goto parse_class_method;
        -:  550:      }
        -:  551:
    #####:  552:      uint32_t accessor_status_flags = status_flags;
    #####:  553:      accessor_status_flags |= (is_getter ? PARSER_IS_PROPERTY_GETTER : PARSER_IS_PROPERTY_SETTER);
        -:  554:
    #####:  555:      lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_CLASS_METHOD | LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
    #####:  556:      literal_index = context_p->lit_object.index;
        -:  557:
    #####:  558:      if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  559:      {
    #####:  560:        is_computed = true;
        -:  561:      }
    #####:  562:      else if (!is_static
    #####:  563:               && LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type)
    #####:  564:               && lexer_compare_literal_to_string (context_p, "constructor", 11))
        -:  565:      {
    #####:  566:        parser_raise_error (context_p, PARSER_ERR_CLASS_CONSTRUCTOR_AS_ACCESSOR);
        -:  567:      }
        -:  568:
    #####:  569:      function_literal_index = lexer_construct_function_object (context_p, accessor_status_flags);
        -:  570:
    #####:  571:      parser_emit_cbc_literal (context_p,
        -:  572:                               CBC_PUSH_LITERAL,
        -:  573:                               literal_index);
        -:  574:
    #####:  575:      JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -:  576:
        -:  577:      cbc_ext_opcode_t opcode;
        -:  578:
    #####:  579:      if (is_computed)
        -:  580:      {
    #####:  581:        context_p->last_cbc.literal_index = function_literal_index;
        -:  582:
    #####:  583:        if (is_getter)
        -:  584:        {
    #####:  585:          opcode = is_static ? CBC_EXT_SET_STATIC_COMPUTED_GETTER : CBC_EXT_SET_COMPUTED_GETTER;
        -:  586:        }
        -:  587:        else
        -:  588:        {
    #####:  589:          opcode = is_static ? CBC_EXT_SET_STATIC_COMPUTED_SETTER : CBC_EXT_SET_COMPUTED_SETTER;
        -:  590:        }
        -:  591:      }
        -:  592:      else
        -:  593:      {
    #####:  594:        context_p->last_cbc.value = function_literal_index;
        -:  595:
    #####:  596:        if (is_getter)
        -:  597:        {
    #####:  598:          opcode = is_static ? CBC_EXT_SET_STATIC_GETTER : CBC_EXT_SET_GETTER;
        -:  599:        }
        -:  600:        else
        -:  601:        {
    #####:  602:          opcode = is_static ? CBC_EXT_SET_STATIC_SETTER : CBC_EXT_SET_SETTER;
        -:  603:        }
        -:  604:      }
        -:  605:
    #####:  606:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);
    #####:  607:      is_static = false;
    #####:  608:      continue;
        -:  609:    }
        -:  610:
    #####:  611:    if (!is_static)
        -:  612:    {
    #####:  613:      if (context_p->token.type == LEXER_KEYW_STATIC)
        -:  614:      {
    #####:  615:        is_static = true;
    #####:  616:        continue;
        -:  617:      }
        -:  618:
    #####:  619:      if (context_p->token.type == LEXER_CLASS_CONSTRUCTOR)
        -:  620:      {
    #####:  621:        JERRY_ASSERT (opts & PARSER_CLASS_LITERAL_CTOR_PRESENT);
    #####:  622:        JERRY_ASSERT (ctor_literal_p != NULL);
        -:  623:
    #####:  624:        if (ctor_literal_p->type == LEXER_FUNCTION_LITERAL)
        -:  625:        {
        -:  626:          /* 14.5.1 */
    #####:  627:          parser_raise_error (context_p, PARSER_ERR_MULTIPLE_CLASS_CONSTRUCTORS);
        -:  628:        }
        -:  629:
    #####:  630:        uint32_t constructor_status_flags = (status_flags
        -:  631:                                             | PARSER_CLASS_CONSTRUCTOR
        -:  632:                                             | PARSER_LEXICAL_ENV_NEEDED);
        -:  633:
    #####:  634:        if (opts & PARSER_CLASS_LITERAL_HERTIAGE_PRESENT)
        -:  635:        {
    #####:  636:          constructor_status_flags |= PARSER_ALLOW_SUPER_CALL;
        -:  637:        }
        -:  638:
    #####:  639:        parser_flush_cbc (context_p);
    #####:  640:        ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, constructor_status_flags);
    #####:  641:        ctor_literal_p->u.bytecode_p = compiled_code_p;
    #####:  642:        ctor_literal_p->type = LEXER_FUNCTION_LITERAL;
    #####:  643:        continue;
        -:  644:      }
        -:  645:    }
        -:  646:
    #####:  647:    status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION
        -:  648:                                 | PARSER_IS_ASYNC_FUNCTION
        -:  649:                                 | PARSER_DISALLOW_AWAIT_YIELD);
        -:  650:
    #####:  651:    if (context_p->token.type == LEXER_KEYW_ASYNC)
        -:  652:    {
    #####:  653:      status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  654:
    #####:  655:      if (!lexer_consume_generator (context_p))
        -:  656:      {
    #####:  657:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -:  658:      }
        -:  659:    }
        -:  660:
    #####:  661:    if (context_p->token.type == LEXER_MULTIPLY)
        -:  662:    {
    #####:  663:      lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
    #####:  664:      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  665:    }
        -:  666:
    #####:  667:    if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  668:    {
    #####:  669:      is_computed = true;
        -:  670:    }
    #####:  671:    else if (LEXER_IS_IDENT_OR_STRING (context_p->token.lit_location.type))
        -:  672:    {
    #####:  673:      if (is_static)
        -:  674:      {
    #####:  675:        if (lexer_compare_literal_to_string (context_p, "prototype", 9))
        -:  676:        {
    #####:  677:          parser_raise_error (context_p, PARSER_ERR_CLASS_STATIC_PROTOTYPE);
        -:  678:        }
        -:  679:      }
    #####:  680:      else if ((status_flags & PARSER_IS_GENERATOR_FUNCTION)
    #####:  681:               && lexer_compare_literal_to_string (context_p, "constructor", 11))
        -:  682:      {
    #####:  683:        parser_raise_error (context_p, PARSER_ERR_CLASS_CONSTRUCTOR_AS_GENERATOR);
        -:  684:      }
        -:  685:    }
        -:  686:
    #####:  687:parse_class_method:
        -:  688:    ; /* Empty statement to make compiler happy. */
    #####:  689:    uint16_t literal_index = context_p->lit_object.index;
    #####:  690:    uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -:  691:
    #####:  692:    parser_emit_cbc_literal (context_p,
        -:  693:                             CBC_PUSH_LITERAL,
        -:  694:                             function_literal_index);
        -:  695:
    #####:  696:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
        -:  697:
    #####:  698:    context_p->last_cbc.value = literal_index;
        -:  699:
    #####:  700:    if (is_static)
        -:  701:    {
    #####:  702:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (is_computed ? CBC_EXT_SET_STATIC_COMPUTED_PROPERTY_LITERAL
        -:  703:                                                                     : CBC_EXT_SET_STATIC_PROPERTY_LITERAL);
    #####:  704:      is_static = false;
        -:  705:    }
        -:  706:    else
        -:  707:    {
    #####:  708:      context_p->last_cbc_opcode = (is_computed ? PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL)
        -:  709:                                                : CBC_SET_LITERAL_PROPERTY);
        -:  710:    }
        -:  711:  }
    #####:  712:} /* parser_parse_class_literal */
        -:  713:
        -:  714:/**
        -:  715: * Parse class statement or expression.
        -:  716: */
        -:  717:void
    #####:  718:parser_parse_class (parser_context_t *context_p, /**< context */
        -:  719:                    bool is_statement) /**< true - if class is parsed as a statement
        -:  720:                                        *   false - otherwise (as an expression) */
        -:  721:{
    #####:  722:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_CLASS);
        -:  723:
    #####:  724:  uint16_t class_ident_index = PARSER_MAXIMUM_NUMBER_OF_LITERALS;
    #####:  725:  uint16_t class_name_index = PARSER_MAXIMUM_NUMBER_OF_LITERALS;
    #####:  726:  parser_class_literal_opts_t opts = PARSER_CLASS_LITERAL_NO_OPTS;
        -:  727:
    #####:  728:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -:  729:  {
    #####:  730:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_CLASS_CONSTRUCTOR);
    #####:  731:    scanner_release_next (context_p, sizeof (scanner_info_t));
    #####:  732:    opts |= PARSER_CLASS_LITERAL_CTOR_PRESENT;
        -:  733:  }
        -:  734:
    #####:  735:  if (is_statement)
        -:  736:  {
        -:  737:    /* Class statement must contain an identifier. */
    #####:  738:    lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
    #####:  739:    JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -:  740:                  && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -:  741:
    #####:  742:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -:  743:    {
    #####:  744:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####:  745:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -:  746:    }
    #####:  747:    class_ident_index = context_p->lit_object.index;
        -:  748:
    #####:  749:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####:  750:    class_name_index = context_p->lit_object.index;
        -:  751:
        -:  752:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####:  753:    parser_module_append_export_name (context_p);
    #####:  754:    context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);
        -:  755:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  756:
    #####:  757:    lexer_next_token (context_p);
        -:  758:  }
        -:  759:  else
        -:  760:  {
    #####:  761:    lexer_next_token (context_p);
        -:  762:
        -:  763:    /* Class expression may contain an identifier. */
    #####:  764:    if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  765:    {
        -:  766:      /* NOTE: If 'Function.name' will be supported, the current literal object must be set to 'name' property. */
    #####:  767:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####:  768:      class_name_index = context_p->lit_object.index;
    #####:  769:      lexer_next_token (context_p);
        -:  770:    }
        -:  771:  }
        -:  772:
    #####:  773:  if (class_name_index != PARSER_MAXIMUM_NUMBER_OF_LITERALS)
        -:  774:  {
    #####:  775:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_PUSH_NAMED_CLASS_ENV, class_name_index);
        -:  776:  }
        -:  777:  else
        -:  778:  {
    #####:  779:    parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_ANONYMOUS_CLASS_ENV);
        -:  780:  }
        -:  781:
    #####:  782:  if (context_p->token.type == LEXER_KEYW_EXTENDS)
        -:  783:  {
    #####:  784:    lexer_next_token (context_p);
    #####:  785:    parser_parse_expression (context_p, PARSE_EXPR | PARSE_EXPR_LEFT_HAND_SIDE);
    #####:  786:    opts |= PARSER_CLASS_LITERAL_HERTIAGE_PRESENT;
        -:  787:  }
        -:  788:  else
        -:  789:  {
        -:  790:    /* Elisions represents that the classHeritage is not present */
    #####:  791:    parser_emit_cbc (context_p, CBC_PUSH_ELISION);
        -:  792:  }
        -:  793:
    #####:  794:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -:  795:  {
    #####:  796:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -:  797:  }
        -:  798:
    #####:  799:  bool is_strict = context_p->status_flags & PARSER_IS_STRICT;
        -:  800:
        -:  801:  /* 14.5. A ClassBody is always strict code. */
    #####:  802:  context_p->status_flags |= PARSER_IS_STRICT;
        -:  803:
        -:  804:  /* ClassDeclaration is parsed. Continue with class body. */
    #####:  805:  parser_parse_class_literal (context_p, opts);
        -:  806:
    #####:  807:  if (class_name_index != PARSER_MAXIMUM_NUMBER_OF_LITERALS)
        -:  808:  {
    #####:  809:    parser_emit_cbc_ext_literal (context_p, CBC_EXT_FINALIZE_NAMED_CLASS, class_name_index);
        -:  810:  }
        -:  811:  else
        -:  812:  {
    #####:  813:    parser_emit_cbc_ext (context_p, CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -:  814:  }
        -:  815:
    #####:  816:  if (is_statement)
        -:  817:  {
    #####:  818:    cbc_opcode_t opcode = CBC_MOV_IDENT;
        -:  819:
    #####:  820:    if (class_ident_index < PARSER_REGISTER_START)
        -:  821:    {
    #####:  822:      opcode = (scanner_literal_is_created (context_p, class_ident_index) ? CBC_ASSIGN_LET_CONST
    #####:  823:                                                                          : CBC_INIT_LET);
        -:  824:    }
        -:  825:
    #####:  826:    parser_emit_cbc_literal (context_p, (uint16_t) opcode, class_ident_index);
        -:  827:  }
        -:  828:
    #####:  829:  parser_flush_cbc (context_p);
        -:  830:
    #####:  831:  if (!is_strict)
        -:  832:  {
        -:  833:    /* Restore flag */
    #####:  834:    context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -:  835:  }
    #####:  836:  context_p->status_flags &= (uint32_t) ~PARSER_ALLOW_SUPER;
        -:  837:
    #####:  838:  lexer_next_token (context_p);
    #####:  839:} /* parser_parse_class */
        -:  840:#endif /* ENABLED (JERRY_ES2015) */
        -:  841:
        -:  842:#if ENABLED (JERRY_ES2015)
        -:  843:/**
        -:  844: * Parse object initializer method definition.
        -:  845: *
        -:  846: * See also: ES2015 14.3
        -:  847: */
        -:  848:static void
    #####:  849:parser_parse_object_method (parser_context_t *context_p) /**< context */
        -:  850:{
    #####:  851:  context_p->source_p--;
    #####:  852:  context_p->column--;
    #####:  853:  uint16_t function_literal_index = lexer_construct_function_object (context_p, PARSER_FUNCTION_CLOSURE);
        -:  854:
    #####:  855:  parser_emit_cbc_literal (context_p,
        -:  856:                           CBC_PUSH_LITERAL,
        -:  857:                           function_literal_index);
        -:  858:
    #####:  859:  lexer_next_token (context_p);
    #####:  860:} /* parser_parse_object_method */
        -:  861:
        -:  862:/**
        -:  863: * Reparse the current literal as a common identifier.
        -:  864: */
        -:  865:static void
    #####:  866:parser_reparse_as_common_identifier (parser_context_t *context_p, /**< context */
        -:  867:                                     parser_line_counter_t start_line, /**< start line */
        -:  868:                                     parser_line_counter_t start_column) /**< start column */
        -:  869:{
    #####:  870:  context_p->source_p = context_p->token.lit_location.char_p;
    #####:  871:  context_p->line = start_line;
    #####:  872:  context_p->column = start_column;
        -:  873:
    #####:  874:  lexer_next_token (context_p);
        -:  875:
    #####:  876:  if (context_p->token.type != LEXER_LITERAL
    #####:  877:      || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  878:  {
    #####:  879:    parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -:  880:  }
        -:  881:
    #####:  882:  lexer_construct_literal_object (context_p,
    #####:  883:                                  &context_p->token.lit_location,
        -:  884:                                  LEXER_IDENT_LITERAL);
        -:  885:
    #####:  886:} /* parser_reparse_as_common_identifier */
        -:  887:#endif /* ENABLED (JERRY_ES2015) */
        -:  888:
        -:  889:/**
        -:  890: * Parse object literal.
        -:  891: */
        -:  892:static void
        1:  893:parser_parse_object_literal (parser_context_t *context_p) /**< context */
        -:  894:{
        1:  895:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE);
        -:  896:
        1:  897:  parser_emit_cbc (context_p, CBC_CREATE_OBJECT);
        -:  898:
        -:  899:#if !ENABLED (JERRY_ES2015)
    #####:  900:  parser_stack_push_uint8 (context_p, PARSER_OBJECT_PROPERTY_START);
        -:  901:#endif /* !ENABLED (JERRY_ES2015) */
        -:  902:
        -:  903:#if ENABLED (JERRY_ES2015)
        1:  904:  bool proto_seen = false;
        -:  905:#endif /* ENABLED (JERRY_ES2015) */
        -:  906:
        -:  907:  while (true)
        -:  908:  {
        3:  909:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_NO_OPTS);
        -:  910:
        2:  911:    switch (context_p->token.type)
        -:  912:    {
    #####:  913:      case LEXER_RIGHT_BRACE:
        -:  914:      {
    #####:  915:        break;
        -:  916:      }
    #####:  917:      case LEXER_PROPERTY_GETTER:
        -:  918:      case LEXER_PROPERTY_SETTER:
        -:  919:      {
        -:  920:        uint32_t status_flags;
        -:  921:        cbc_ext_opcode_t opcode;
        -:  922:#if !ENABLED (JERRY_ES2015)
        -:  923:        parser_object_literal_item_types_t item_type;
        -:  924:#endif /* !ENABLED (JERRY_ES2015) */
        -:  925:
    #####:  926:        if (context_p->token.type == LEXER_PROPERTY_GETTER)
        -:  927:        {
    #####:  928:          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_GETTER;
    #####:  929:          opcode = CBC_EXT_SET_GETTER;
        -:  930:#if !ENABLED (JERRY_ES2015)
    #####:  931:          item_type = PARSER_OBJECT_PROPERTY_GETTER;
        -:  932:#endif /* !ENABLED (JERRY_ES2015) */
        -:  933:        }
        -:  934:        else
        -:  935:        {
    #####:  936:          status_flags = PARSER_FUNCTION_CLOSURE | PARSER_IS_PROPERTY_SETTER;
    #####:  937:          opcode = CBC_EXT_SET_SETTER;
        -:  938:#if !ENABLED (JERRY_ES2015)
    #####:  939:          item_type = PARSER_OBJECT_PROPERTY_SETTER;
        -:  940:#endif /* !ENABLED (JERRY_ES2015) */
        -:  941:        }
        -:  942:
    #####:  943:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -:  944:
        -:  945:        /* This assignment is a nop for computed getters/setters. */
    #####:  946:        uint16_t literal_index = context_p->lit_object.index;
        -:  947:
        -:  948:#if ENABLED (JERRY_ES2015)
    #####:  949:        if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -:  950:        {
    #####:  951:          opcode = ((opcode == CBC_EXT_SET_GETTER) ? CBC_EXT_SET_COMPUTED_GETTER
    #####:  952:                                                   : CBC_EXT_SET_COMPUTED_SETTER);
        -:  953:        }
        -:  954:#else /* !ENABLED (JERRY_ES2015) */
    #####:  955:        parser_append_object_literal_item (context_p, literal_index, item_type);
        -:  956:#endif /* ENABLED (JERRY_ES2015) */
        -:  957:
    #####:  958:        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -:  959:
        -:  960:#if ENABLED (JERRY_ES2015)
    #####:  961:        if (opcode >= CBC_EXT_SET_COMPUTED_GETTER)
        -:  962:        {
    #####:  963:          literal_index = function_literal_index;
        -:  964:        }
        -:  965:#endif /* ENABLED (JERRY_ES2015) */
        -:  966:
    #####:  967:        parser_emit_cbc_literal (context_p,
        -:  968:                                 CBC_PUSH_LITERAL,
        -:  969:                                 literal_index);
        -:  970:
    #####:  971:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####:  972:        context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (opcode);
    #####:  973:        context_p->last_cbc.value = function_literal_index;
        -:  974:
    #####:  975:        lexer_next_token (context_p);
    #####:  976:        break;
        -:  977:      }
        -:  978:#if ENABLED (JERRY_ES2015)
    #####:  979:      case LEXER_RIGHT_SQUARE:
        -:  980:      {
    #####:  981:        lexer_next_token (context_p);
        -:  982:
    #####:  983:        if (context_p->token.type == LEXER_LEFT_PAREN)
        -:  984:        {
    #####:  985:          parser_parse_object_method (context_p);
        -:  986:
    #####:  987:          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####:  988:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
    #####:  989:          break;
        -:  990:        }
        -:  991:
    #####:  992:        if (context_p->token.type != LEXER_COLON)
        -:  993:        {
    #####:  994:          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -:  995:        }
        -:  996:
    #####:  997:        lexer_next_token (context_p);
    #####:  998:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -:  999:
    #####: 1000:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1001:        {
    #####: 1002:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
        -: 1003:        }
        -: 1004:        else
        -: 1005:        {
    #####: 1006:          parser_emit_cbc_ext (context_p, CBC_EXT_SET_COMPUTED_PROPERTY);
        -: 1007:        }
    #####: 1008:        break;
        -: 1009:      }
    #####: 1010:      case LEXER_KEYW_ASYNC:
        -: 1011:      case LEXER_MULTIPLY:
        -: 1012:      {
    #####: 1013:        uint32_t status_flags = PARSER_FUNCTION_CLOSURE;
        -: 1014:
    #####: 1015:        if (context_p->token.type == LEXER_KEYW_ASYNC)
        -: 1016:        {
    #####: 1017:          status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1018:          lexer_consume_generator (context_p);
        -: 1019:        }
        -: 1020:
    #####: 1021:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 1022:        {
    #####: 1023:          status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1024:        }
        -: 1025:
    #####: 1026:        lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_ONLY_IDENTIFIERS);
        -: 1027:
    #####: 1028:        uint16_t opcode = CBC_SET_LITERAL_PROPERTY;
        -: 1029:        /* This assignment is a nop for CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL. */
    #####: 1030:        uint16_t literal_index = context_p->lit_object.index;
        -: 1031:
    #####: 1032:        if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -: 1033:        {
    #####: 1034:          opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SET_COMPUTED_PROPERTY_LITERAL);
        -: 1035:        }
        -: 1036:
    #####: 1037:        uint16_t function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1038:
    #####: 1039:        parser_emit_cbc_literal (context_p,
        -: 1040:                                 CBC_PUSH_LITERAL,
        -: 1041:                                 function_literal_index);
        -: 1042:
    #####: 1043:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 1044:        context_p->last_cbc_opcode = opcode;
    #####: 1045:        context_p->last_cbc.value = literal_index;
        -: 1046:
    #####: 1047:        lexer_next_token (context_p);
    #####: 1048:        break;
        -: 1049:      }
        -: 1050:#endif /* ENABLED (JERRY_ES2015) */
        2: 1051:      default:
        -: 1052:      {
        -: 1053:#if ENABLED (JERRY_ES2015)
        2: 1054:        const lexer_lit_location_t *literal_p = (const lexer_lit_location_t *) context_p->lit_object.literal_p;
        4: 1055:        bool is_proto = ((context_p->token.lit_location.type == LEXER_IDENT_LITERAL
    #####: 1056:                          || context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        2: 1057:                         && lexer_compare_identifier_to_string (literal_p, (uint8_t *) "__proto__", 9)
        2: 1058:                         && lexer_check_next_character (context_p, LIT_CHAR_COLON));
        2: 1059:        if (is_proto)
        -: 1060:        {
    #####: 1061:          if (proto_seen)
        -: 1062:          {
    #####: 1063:            parser_raise_error (context_p, PARSER_ERR_DUPLICATED_PROTO);
        -: 1064:          }
        -: 1065:
    #####: 1066:          proto_seen = true;
        -: 1067:        }
        -: 1068:#endif /* ENABLED (JERRY_ES2015) */
        -: 1069:
        2: 1070:        uint16_t literal_index = context_p->lit_object.index;
        -: 1071:
        -: 1072:#if ENABLED (JERRY_ES2015)
        2: 1073:        parser_line_counter_t start_line = context_p->token.line;
        2: 1074:        parser_line_counter_t start_column = context_p->token.column;
        -: 1075:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1076:        parser_append_object_literal_item (context_p,
        -: 1077:                                           literal_index,
        -: 1078:                                           PARSER_OBJECT_PROPERTY_VALUE);
        -: 1079:#endif /* ENABLED (JERRY_ES2015) */
        -: 1080:
        2: 1081:        lexer_next_token (context_p);
        -: 1082:
        -: 1083:#if ENABLED (JERRY_ES2015)
        2: 1084:        if (context_p->token.type == LEXER_LEFT_PAREN && !is_proto)
        -: 1085:        {
    #####: 1086:          parser_parse_object_method (context_p);
        -: 1087:
    #####: 1088:          JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 1089:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1090:          context_p->last_cbc.value = literal_index;
    #####: 1091:          break;
        -: 1092:        }
        -: 1093:
        2: 1094:        if ((context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_COMMA)
    #####: 1095:            && !is_proto)
        -: 1096:        {
    #####: 1097:          parser_reparse_as_common_identifier (context_p, start_line, start_column);
    #####: 1098:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 1099:
    #####: 1100:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
    #####: 1101:          context_p->last_cbc.value = literal_index;
        -: 1102:
    #####: 1103:          lexer_next_token (context_p);
    #####: 1104:          break;
        -: 1105:        }
        -: 1106:#endif /* ENABLED (JERRY_ES2015) */
        -: 1107:
        2: 1108:        if (context_p->token.type != LEXER_COLON)
        -: 1109:        {
    #####: 1110:          parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1111:        }
        -: 1112:
        2: 1113:        lexer_next_token (context_p);
        2: 1114:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1115:
        -: 1116:#if ENABLED (JERRY_ES2015)
        2: 1117:        if (is_proto)
        -: 1118:        {
    #####: 1119:          parser_emit_cbc_ext (context_p, CBC_EXT_SET__PROTO__);
    #####: 1120:          break;
        -: 1121:        }
        -: 1122:#endif /* ENABLED (JERRY_ES2015) */
        -: 1123:
        2: 1124:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1125:        {
        2: 1126:          context_p->last_cbc_opcode = CBC_SET_LITERAL_PROPERTY;
        2: 1127:          context_p->last_cbc.value = literal_index;
        -: 1128:        }
        -: 1129:        else
        -: 1130:        {
    #####: 1131:          parser_emit_cbc_literal (context_p, CBC_SET_PROPERTY, literal_index);
        -: 1132:        }
        -: 1133:
        2: 1134:        break;
        -: 1135:      }
        -: 1136:    }
        -: 1137:
        2: 1138:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 1139:    {
        1: 1140:      break;
        -: 1141:    }
        1: 1142:    else if (context_p->token.type != LEXER_COMMA)
        -: 1143:    {
    #####: 1144:      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 1145:    }
        -: 1146:  }
        -: 1147:
        -: 1148:#if !ENABLED (JERRY_ES2015)
    #####: 1149:  while (context_p->stack_top_uint8 != PARSER_OBJECT_PROPERTY_START)
        -: 1150:  {
    #####: 1151:    parser_stack_pop (context_p, NULL, 3);
        -: 1152:  }
        -: 1153:
    #####: 1154:  parser_stack_pop_uint8 (context_p);
        -: 1155:#endif /* !ENABLED (JERRY_ES2015) */
        1: 1156:} /* parser_parse_object_literal */
        -: 1157:
        -: 1158:/**
        -: 1159: * Parse function literal.
        -: 1160: */
        -: 1161:static void
    #####: 1162:parser_parse_function_expression (parser_context_t *context_p, /**< context */
        -: 1163:                                  uint32_t status_flags) /**< function status flags */
        -: 1164:{
    #####: 1165:  int literals = 0;
    #####: 1166:  uint16_t literal1 = 0;
    #####: 1167:  uint16_t literal2 = 0;
        -: 1168:  uint16_t function_literal_index;
    #####: 1169:  int32_t function_name_index = -1;
        -: 1170:
        -: 1171:#if !ENABLED (JERRY_ES2015)
    #####: 1172:  JERRY_ASSERT (status_flags & PARSER_IS_FUNC_EXPRESSION);
        -: 1173:#endif /* !ENABLED (JERRY_ES2015) */
        -: 1174:
        -: 1175:#if ENABLED (JERRY_ES2015)
    #####: 1176:  if (status_flags & PARSER_IS_FUNC_EXPRESSION)
        -: 1177:  {
        -: 1178:#endif /* !ENABLED (JERRY_ES2015) */
        -: 1179:
        -: 1180:#if ENABLED (JERRY_DEBUGGER)
        -: 1181:    parser_line_counter_t debugger_line = context_p->token.line;
        -: 1182:    parser_line_counter_t debugger_column = context_p->token.column;
        -: 1183:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 1184:
        -: 1185:#if ENABLED (JERRY_ES2015)
    #####: 1186:    uint32_t parent_status_flags = context_p->status_flags;
        -: 1187:
    #####: 1188:    context_p->status_flags &= (uint32_t) ~(PARSER_IS_ASYNC_FUNCTION
        -: 1189:                                            | PARSER_IS_GENERATOR_FUNCTION
        -: 1190:                                            | PARSER_DISALLOW_AWAIT_YIELD);
        -: 1191:
    #####: 1192:    if (status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1193:    {
        -: 1194:      /* The name of the function cannot be await. */
    #####: 1195:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1196:    }
        -: 1197:
    #####: 1198:    if (lexer_consume_generator (context_p))
        -: 1199:    {
        -: 1200:      /* The name of the function cannot be yield. */
    #####: 1201:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1202:      status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -: 1203:    }
        -: 1204:#endif /* ENABLED (JERRY_ES2015) */
        -: 1205:
    #####: 1206:    if (!lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 1207:    {
    #####: 1208:      lexer_next_token (context_p);
        -: 1209:
    #####: 1210:      if (context_p->token.type != LEXER_LITERAL
    #####: 1211:          || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1212:      {
    #####: 1213:        parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1214:      }
        -: 1215:
    #####: 1216:      parser_flush_cbc (context_p);
        -: 1217:
    #####: 1218:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
        -: 1219:
        -: 1220:#if ENABLED (JERRY_DEBUGGER)
        -: 1221:      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1222:      {
        -: 1223:        jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,
        -: 1224:                                    JERRY_DEBUGGER_NO_SUBTYPE,
        -: 1225:                                    context_p->lit_object.literal_p->u.char_p,
        -: 1226:                                    context_p->lit_object.literal_p->prop.length);
        -: 1227:
        -: 1228:        /* Reset token position for the function. */
        -: 1229:        context_p->token.line = debugger_line;
        -: 1230:        context_p->token.column = debugger_column;
        -: 1231:      }
        -: 1232:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 1233:
    #####: 1234:      if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -: 1235:      {
    #####: 1236:        status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1237:      }
        -: 1238:
    #####: 1239:      function_name_index = context_p->lit_object.index;
        -: 1240:    }
        -: 1241:
        -: 1242:#if ENABLED (JERRY_ES2015)
    #####: 1243:    context_p->status_flags = parent_status_flags;
        -: 1244:  }
        -: 1245:#endif /* ENABLED (JERRY_ES2015) */
        -: 1246:
    #####: 1247:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1248:  {
    #####: 1249:    literals = 1;
    #####: 1250:    literal1 = context_p->last_cbc.literal_index;
    #####: 1251:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1252:  }
    #####: 1253:  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1254:  {
    #####: 1255:    literals = 2;
    #####: 1256:    literal1 = context_p->last_cbc.literal_index;
    #####: 1257:    literal2 = context_p->last_cbc.value;
    #####: 1258:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1259:  }
        -: 1260:
    #####: 1261:  function_literal_index = lexer_construct_function_object (context_p, status_flags);
        -: 1262:
    #####: 1263:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 1264:
    #####: 1265:  if (literals == 1)
        -: 1266:  {
    #####: 1267:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1268:    context_p->last_cbc.literal_index = literal1;
    #####: 1269:    context_p->last_cbc.value = function_literal_index;
        -: 1270:  }
    #####: 1271:  else if (literals == 2)
        -: 1272:  {
    #####: 1273:    context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 1274:    context_p->last_cbc.literal_index = literal1;
    #####: 1275:    context_p->last_cbc.value = literal2;
    #####: 1276:    context_p->last_cbc.third_literal_index = function_literal_index;
        -: 1277:  }
        -: 1278:  else
        -: 1279:  {
    #####: 1280:    parser_emit_cbc_literal (context_p,
        -: 1281:                             CBC_PUSH_LITERAL,
        -: 1282:                             function_literal_index);
        -: 1283:
    #####: 1284:    if (function_name_index != -1)
        -: 1285:    {
    #####: 1286:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_NAMED_FUNC_EXPRESSION);
    #####: 1287:      context_p->last_cbc.value = (uint16_t) function_name_index;
        -: 1288:    }
        -: 1289:  }
        -: 1290:
    #####: 1291:  context_p->last_cbc.literal_type = LEXER_FUNCTION_LITERAL;
    #####: 1292:  context_p->last_cbc.literal_keyword_type = LEXER_EOS;
    #####: 1293:} /* parser_parse_function_expression */
        -: 1294:
        -: 1295:#if ENABLED (JERRY_ES2015)
        -: 1296:
        -: 1297:/**
        -: 1298: * Parse template literal.
        -: 1299: */
        -: 1300:static void
    #####: 1301:parser_parse_template_literal (parser_context_t *context_p) /**< context */
        -: 1302:{
    #####: 1303:  bool is_empty_head = true;
        -: 1304:
    #####: 1305:  if (context_p->token.lit_location.length > 0)
        -: 1306:  {
    #####: 1307:    is_empty_head = false;
        -: 1308:
    #####: 1309:    lexer_construct_literal_object (context_p,
    #####: 1310:                                    &context_p->token.lit_location,
    #####: 1311:                                    context_p->token.lit_location.type);
        -: 1312:
    #####: 1313:    parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 1314:  }
        -: 1315:
    #####: 1316:  lexer_next_token (context_p);
    #####: 1317:  parser_parse_expression (context_p, PARSE_EXPR);
        -: 1318:
    #####: 1319:  if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1320:  {
    #####: 1321:    parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1322:  }
        -: 1323:
    #####: 1324:  if (!is_empty_head)
        -: 1325:  {
    #####: 1326:    if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1327:    {
    #####: 1328:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_TWO_LITERALS);
        -: 1329:    }
    #####: 1330:    else if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1331:    {
    #####: 1332:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1333:    }
        -: 1334:    else
        -: 1335:    {
    #####: 1336:      parser_emit_cbc_ext (context_p, CBC_EXT_STRING_CONCAT);
        -: 1337:    }
        -: 1338:  }
        -: 1339:
    #####: 1340:  context_p->source_p--;
    #####: 1341:  context_p->column--;
    #####: 1342:  lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1343:
    #####: 1344:  if (is_empty_head || context_p->token.lit_location.length > 0)
        -: 1345:  {
    #####: 1346:    lexer_construct_literal_object (context_p,
    #####: 1347:                                    &context_p->token.lit_location,
    #####: 1348:                                    context_p->token.lit_location.type);
        -: 1349:
    #####: 1350:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1351:    {
    #####: 1352:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_TWO_LITERALS);
    #####: 1353:      context_p->last_cbc.value = context_p->lit_object.index;
    #####: 1354:      context_p->last_cbc.literal_type = context_p->token.lit_location.type;
    #####: 1355:      context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        -: 1356:    }
        -: 1357:    else
        -: 1358:    {
    #####: 1359:      parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1360:    }
        -: 1361:  }
        -: 1362:
    #####: 1363:  while (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1364:  {
    #####: 1365:    lexer_next_token (context_p);
        -: 1366:
    #####: 1367:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1368:
    #####: 1369:    if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1370:    {
    #####: 1371:      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1372:    }
        -: 1373:
    #####: 1374:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1375:    {
    #####: 1376:      context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1377:    }
        -: 1378:    else
        -: 1379:    {
    #####: 1380:      parser_emit_cbc_ext (context_p, CBC_EXT_STRING_CONCAT);
        -: 1381:    }
        -: 1382:
    #####: 1383:    context_p->source_p--;
    #####: 1384:    context_p->column--;
    #####: 1385:    lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1386:
    #####: 1387:    if (context_p->token.lit_location.length > 0)
        -: 1388:    {
    #####: 1389:      lexer_construct_literal_object (context_p,
    #####: 1390:                                      &context_p->token.lit_location,
    #####: 1391:                                      context_p->token.lit_location.type);
        -: 1392:
    #####: 1393:      parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_STRING_CONCAT_RIGHT_LITERAL);
        -: 1394:    }
        -: 1395:  }
    #####: 1396:} /* parser_parse_template_literal */
        -: 1397:
        -: 1398:/**
        -: 1399: * Parse tagged template literal.
        -: 1400: */
        -: 1401:static size_t
    #####: 1402:parser_parse_tagged_template_literal (parser_context_t *context_p) /**< context */
        -: 1403:{
    #####: 1404:  JERRY_ASSERT (context_p->token.type == LEXER_TEMPLATE_LITERAL);
        -: 1405:
    #####: 1406:  uint32_t call_arguments = 0;
        -: 1407:  ecma_collection_t *collection_p;
        -: 1408:
    #####: 1409:  if (context_p->tagged_template_literal_cp == JMEM_CP_NULL)
        -: 1410:  {
    #####: 1411:    collection_p = ecma_new_collection ();
    #####: 1412:    ECMA_SET_INTERNAL_VALUE_POINTER (context_p->tagged_template_literal_cp, collection_p);
        -: 1413:  }
        -: 1414:  else
        -: 1415:  {
    #####: 1416:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_p->tagged_template_literal_cp);
    #####: 1417:    if (collection_p->item_count > CBC_MAXIMUM_BYTE_VALUE)
        -: 1418:    {
    #####: 1419:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1420:    }
        -: 1421:  }
        -: 1422:
    #####: 1423:  const uint32_t tagged_id = collection_p->item_count;
    #####: 1424:  uint32_t prop_idx = 0;
    #####: 1425:  ecma_object_t *raw_strings_p;
    #####: 1426:  ecma_object_t *template_obj_p = parser_new_tagged_template_literal (&raw_strings_p);
    #####: 1427:  ecma_collection_push_back (collection_p, ecma_make_object_value (template_obj_p));
        -: 1428:
    #####: 1429:  parser_tagged_template_literal_append_strings (context_p, template_obj_p, raw_strings_p, prop_idx++);
        -: 1430:
    #####: 1431:  call_arguments++;
    #####: 1432:  parser_emit_cbc_ext_call (context_p, CBC_EXT_GET_TAGGED_TEMPLATE_LITERAL, tagged_id);
        -: 1433:
    #####: 1434:  while (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1435:  {
    #####: 1436:    JERRY_ASSERT (context_p->source_p[-1] == LIT_CHAR_LEFT_BRACE);
    #####: 1437:    lexer_next_token (context_p);
        -: 1438:
    #####: 1439:    if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 1440:    {
    #####: 1441:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1442:    }
        -: 1443:
    #####: 1444:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1445:
    #####: 1446:    if (context_p->token.type != LEXER_RIGHT_BRACE)
        -: 1447:    {
    #####: 1448:      parser_raise_error (context_p, PARSER_ERR_RIGHT_BRACE_EXPECTED);
        -: 1449:    }
        -: 1450:
    #####: 1451:    context_p->source_p--;
    #####: 1452:    context_p->column--;
    #####: 1453:    lexer_parse_string (context_p, LEXER_STRING_NO_OPTS);
        -: 1454:
    #####: 1455:    parser_tagged_template_literal_append_strings (context_p, template_obj_p, raw_strings_p, prop_idx++);
        -: 1456:  }
        -: 1457:
    #####: 1458:  parser_tagged_template_literal_finalize (template_obj_p, raw_strings_p);
        -: 1459:
    #####: 1460:  return call_arguments;
        -: 1461:} /* parser_parse_tagged_template_literal */
        -: 1462:
        -: 1463:/**
        -: 1464: * Checks wheteher the current expression can be an assignment expression.
        -: 1465: *
        -: 1466: * @return true if the current expression can be an assignment expression, false otherwise
        -: 1467: */
        -: 1468:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -: 1469:parser_is_assignment_expr (parser_context_t *context_p)
        -: 1470:{
    #####: 1471:  return (context_p->stack_top_uint8 == LEXER_EXPRESSION_START
    #####: 1472:          || context_p->stack_top_uint8 == LEXER_LEFT_PAREN
    #####: 1473:          || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST
    #####: 1474:          || LEXER_IS_BINARY_LVALUE_TOKEN (context_p->stack_top_uint8));
        -: 1475:} /* parser_is_assignment_expr */
        -: 1476:
        -: 1477:/**
        -: 1478: * Throws an error if the current expression is not an assignment expression.
        -: 1479: */
        -: 1480:static inline void JERRY_ATTR_ALWAYS_INLINE
        -: 1481:parser_check_assignment_expr (parser_context_t *context_p)
        -: 1482:{
    #####: 1483:  if (!parser_is_assignment_expr (context_p))
        -: 1484:  {
    #####: 1485:    parser_raise_error (context_p, PARSER_ERR_ASSIGNMENT_EXPECTED);
        -: 1486:  }
        -: 1487:} /* parser_check_assignment_expr */
        -: 1488:
        -: 1489:/**
        -: 1490: * Checks whether the next token is a valid continuation token after an arrow function.
        -: 1491: */
        -: 1492:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -: 1493:parser_abort_parsing_after_arrow (parser_context_t *context_p)
        -: 1494:{
    #####: 1495:  return (context_p->token.type != LEXER_RIGHT_PAREN
    #####: 1496:          && context_p->token.type != LEXER_COMMA);
        -: 1497:} /* parser_abort_parsing_after_arrow */
        -: 1498:
        -: 1499:#endif /* ENABLED (JERRY_ES2015) */
        -: 1500:
        -: 1501:/**
        -: 1502: * Parse and record unary operators, and parse the primary literal.
        -: 1503: *
        -: 1504: * @return true if parsing should be aborted, true otherwise
        -: 1505: */
        -: 1506:static bool
       32: 1507:parser_parse_unary_expression (parser_context_t *context_p, /**< context */
        -: 1508:                               size_t *grouping_level_p) /**< grouping level */
        -: 1509:{
       32: 1510:  bool new_was_seen = false;
        -: 1511:
        -: 1512:  /* Collect unary operators. */
        -: 1513:  while (true)
        -: 1514:  {
        -: 1515:    /* Convert plus and minus binary operators to unary operators. */
       38: 1516:    switch (context_p->token.type)
        -: 1517:    {
    #####: 1518:      case LEXER_ADD:
        -: 1519:      {
    #####: 1520:        context_p->token.type = LEXER_PLUS;
    #####: 1521:        break;
        -: 1522:      }
    #####: 1523:      case LEXER_SUBTRACT:
        -: 1524:      {
    #####: 1525:        context_p->token.type = LEXER_NEGATE;
    #####: 1526:        break;
        -: 1527:      }
        -: 1528:#if ENABLED (JERRY_ES2015)
    #####: 1529:      case LEXER_KEYW_AWAIT:
        -: 1530:      {
    #####: 1531:        if (JERRY_UNLIKELY (context_p->token.lit_location.has_escape))
        -: 1532:        {
    #####: 1533:          parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 1534:        }
    #####: 1535:        break;
        -: 1536:      }
        -: 1537:#endif /* ENABLED (JERRY_ES2015) */
        -: 1538:    }
        -: 1539:
        -: 1540:    /* Bracketed expressions are primary expressions. At this
        -: 1541:     * point their left paren is pushed onto the stack and
        -: 1542:     * they are processed when their closing paren is reached. */
       35: 1543:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 1544:    {
        -: 1545:#if ENABLED (JERRY_ES2015)
    #####: 1546:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1547:      {
    #####: 1548:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
    #####: 1549:        break;
        -: 1550:      }
        -: 1551:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1552:      (*grouping_level_p) += PARSER_GROUPING_LEVEL_INCREASE;
    #####: 1553:      new_was_seen = false;
        -: 1554:    }
       35: 1555:    else if (context_p->token.type == LEXER_KEYW_NEW)
        -: 1556:    {
        -: 1557:      /* After 'new' unary operators are not allowed. */
        3: 1558:      new_was_seen = true;
        -: 1559:
        -: 1560:#if ENABLED (JERRY_ES2015)
        -: 1561:      /* Check if "new.target" is written here. */
        3: 1562:      if (scanner_try_scan_new_target (context_p))
        -: 1563:      {
    #####: 1564:        if (!(context_p->status_flags & PARSER_ALLOW_NEW_TARGET))
        -: 1565:        {
    #####: 1566:          parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_NOT_ALLOWED);
        -: 1567:        }
        -: 1568:
    #####: 1569:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_NEW_TARGET);
    #####: 1570:        lexer_next_token (context_p);
        -: 1571:        /* Found "new.target" return here */
    #####: 1572:        return false;
        -: 1573:      }
        -: 1574:#endif /* ENABLED (JERRY_ES2015) */
        -: 1575:    }
       32: 1576:    else if (new_was_seen
       29: 1577:             || (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE)
       29: 1578:             || !LEXER_IS_UNARY_OP_TOKEN (context_p->token.type))
        -: 1579:    {
        -: 1580:      break;
        -: 1581:    }
        -: 1582:
        3: 1583:    parser_stack_push_uint8 (context_p, context_p->token.type);
        3: 1584:    lexer_next_token (context_p);
        -: 1585:  }
        -: 1586:
        -: 1587:  /* Parse primary expression. */
       32: 1588:  switch (context_p->token.type)
        -: 1589:  {
        -: 1590:#if ENABLED (JERRY_ES2015)
    #####: 1591:    case LEXER_TEMPLATE_LITERAL:
        -: 1592:    {
    #####: 1593:      if (context_p->source_p[-1] != LIT_CHAR_GRAVE_ACCENT)
        -: 1594:      {
    #####: 1595:        parser_parse_template_literal (context_p);
    #####: 1596:        break;
        -: 1597:      }
        -: 1598:
        -: 1599:      /* The string is a normal string literal. */
        -: 1600:      /* FALLTHRU */
        -: 1601:    }
        -: 1602:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1603:    case LEXER_LITERAL:
        -: 1604:    {
        -: 1605:#if ENABLED (JERRY_ES2015)
       29: 1606:      if (JERRY_UNLIKELY (context_p->next_scanner_info_p->source_p == context_p->source_p))
        -: 1607:      {
    #####: 1608:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 1609:
    #####: 1610:        uint32_t arrow_status_flags = (PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION);
        -: 1611:
    #####: 1612:        if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)
        -: 1613:        {
    #####: 1614:          JERRY_ASSERT (lexer_token_is_async (context_p));
    #####: 1615:          JERRY_ASSERT (!(context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT));
        -: 1616:
    #####: 1617:          uint32_t saved_status_flags = context_p->status_flags;
        -: 1618:
    #####: 1619:          context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
    #####: 1620:          lexer_next_token (context_p);
    #####: 1621:          context_p->status_flags = saved_status_flags;
        -: 1622:
    #####: 1623:          if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -: 1624:          {
    #####: 1625:            uint32_t status_flags = (PARSER_FUNCTION_CLOSURE
        -: 1626:                                     | PARSER_IS_FUNC_EXPRESSION
        -: 1627:                                     | PARSER_IS_ASYNC_FUNCTION
        -: 1628:                                     | PARSER_DISALLOW_AWAIT_YIELD);
    #####: 1629:            parser_parse_function_expression (context_p, status_flags);
    #####: 1630:            break;
        -: 1631:          }
        -: 1632:
    #####: 1633:          arrow_status_flags = (PARSER_IS_FUNCTION
        -: 1634:                                | PARSER_IS_ARROW_FUNCTION
        -: 1635:                                | PARSER_IS_ASYNC_FUNCTION
        -: 1636:                                | PARSER_DISALLOW_AWAIT_YIELD);
        -: 1637:        }
        -: 1638:
    #####: 1639:        parser_check_assignment_expr (context_p);
    #####: 1640:        parser_parse_function_expression (context_p, arrow_status_flags);
    #####: 1641:        return parser_abort_parsing_after_arrow (context_p);
        -: 1642:      }
        -: 1643:#endif /* ENABLED (JERRY_ES2015) */
        -: 1644:
       29: 1645:      uint8_t type = context_p->token.lit_location.type;
        -: 1646:
       29: 1647:      if (type == LEXER_IDENT_LITERAL || type == LEXER_STRING_LITERAL)
        -: 1648:      {
       42: 1649:        lexer_construct_literal_object (context_p,
       21: 1650:                                        &context_p->token.lit_location,
       21: 1651:                                        context_p->token.lit_location.type);
        -: 1652:
        -: 1653:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
       42: 1654:        if ((context_p->status_flags & PARSER_MODULE_STORE_IDENT)
    #####: 1655:            && type == LEXER_IDENT_LITERAL)
        -: 1656:        {
    #####: 1657:          context_p->module_identifier_lit_p = context_p->lit_object.literal_p;
    #####: 1658:          context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);
        -: 1659:        }
        -: 1660:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 1661:      }
        8: 1662:      else if (type == LEXER_NUMBER_LITERAL)
        -: 1663:      {
        8: 1664:        bool is_negative_number = false;
        -: 1665:
        8: 1666:        if ((context_p->stack_top_uint8 == LEXER_PLUS || context_p->stack_top_uint8 == LEXER_NEGATE)
    #####: 1667:            && !lexer_check_post_primary_exp (context_p))
        -: 1668:        {
        -: 1669:          do
        -: 1670:          {
    #####: 1671:            if (context_p->stack_top_uint8 == LEXER_NEGATE)
        -: 1672:            {
    #####: 1673:              is_negative_number = !is_negative_number;
        -: 1674:            }
    #####: 1675:            parser_stack_pop_uint8 (context_p);
        -: 1676:          }
    #####: 1677:          while (context_p->stack_top_uint8 == LEXER_PLUS
    #####: 1678:                 || context_p->stack_top_uint8 == LEXER_NEGATE);
        -: 1679:        }
        -: 1680:
        8: 1681:        if (lexer_construct_number_object (context_p, true, is_negative_number))
        -: 1682:        {
        2: 1683:          JERRY_ASSERT (context_p->lit_object.index <= CBC_PUSH_NUMBER_BYTE_RANGE_END);
        -: 1684:
        2: 1685:          parser_emit_cbc_push_number (context_p, is_negative_number);
        2: 1686:          break;
        -: 1687:        }
        -: 1688:      }
        -: 1689:
       27: 1690:      cbc_opcode_t opcode = CBC_PUSH_LITERAL;
        -: 1691:
       27: 1692:      if (context_p->token.keyword_type != LEXER_KEYW_EVAL)
        -: 1693:      {
       26: 1694:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1695:        {
        6: 1696:          context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        6: 1697:          context_p->last_cbc.value = context_p->lit_object.index;
        6: 1698:          context_p->last_cbc.literal_type = context_p->token.lit_location.type;
        6: 1699:          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        6: 1700:          break;
        -: 1701:        }
        -: 1702:
       20: 1703:        if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1704:        {
        3: 1705:          context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
        3: 1706:          context_p->last_cbc.third_literal_index = context_p->lit_object.index;
        3: 1707:          context_p->last_cbc.literal_type = context_p->token.lit_location.type;
        3: 1708:          context_p->last_cbc.literal_keyword_type = context_p->token.keyword_type;
        3: 1709:          break;
        -: 1710:        }
        -: 1711:
       17: 1712:        if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -: 1713:        {
    #####: 1714:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1715:          opcode = CBC_PUSH_THIS_LITERAL;
        -: 1716:        }
        -: 1717:      }
        -: 1718:
       18: 1719:      parser_emit_cbc_literal_from_token (context_p, (uint16_t) opcode);
       18: 1720:      break;
        -: 1721:    }
    #####: 1722:    case LEXER_KEYW_FUNCTION:
        -: 1723:    {
    #####: 1724:      parser_parse_function_expression (context_p, PARSER_FUNCTION_CLOSURE | PARSER_IS_FUNC_EXPRESSION);
    #####: 1725:      break;
        -: 1726:    }
        1: 1727:    case LEXER_LEFT_BRACE:
        -: 1728:    {
        -: 1729:#if ENABLED (JERRY_ES2015)
        1: 1730:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1731:      {
    #####: 1732:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);
        -: 1733:
    #####: 1734:        if (parser_is_assignment_expr (context_p))
        -: 1735:        {
    #####: 1736:          parser_parse_object_initializer (context_p, PARSER_PATTERN_NO_OPTS);
    #####: 1737:          return false;
        -: 1738:        }
        -: 1739:
    #####: 1740:        scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 1741:      }
        -: 1742:#endif /* ENABLED (JERRY_ES2015) */
        -: 1743:
        1: 1744:      parser_parse_object_literal (context_p);
        1: 1745:      break;
        -: 1746:    }
        2: 1747:    case LEXER_LEFT_SQUARE:
        -: 1748:    {
        -: 1749:#if ENABLED (JERRY_ES2015)
        2: 1750:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1751:      {
    #####: 1752:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);
        -: 1753:
    #####: 1754:        if (parser_is_assignment_expr (context_p))
        -: 1755:        {
    #####: 1756:          parser_parse_array_initializer (context_p, PARSER_PATTERN_NO_OPTS);
    #####: 1757:          return false;
        -: 1758:        }
        -: 1759:
    #####: 1760:        scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 1761:      }
        -: 1762:#endif /* ENABLED (JERRY_ES2015) */
        -: 1763:
        2: 1764:      parser_parse_array_literal (context_p);
        2: 1765:      break;
        -: 1766:    }
    #####: 1767:    case LEXER_DIVIDE:
        -: 1768:    case LEXER_ASSIGN_DIVIDE:
        -: 1769:    {
    #####: 1770:      lexer_construct_regexp_object (context_p, false);
        -: 1771:
    #####: 1772:      uint16_t literal_index = (uint16_t) (context_p->literal_count - 1);
        -: 1773:
    #####: 1774:      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1775:      {
    #####: 1776:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1777:        context_p->last_cbc.value = literal_index;
        -: 1778:      }
    #####: 1779:      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 1780:      {
    #####: 1781:        context_p->last_cbc_opcode = CBC_PUSH_THREE_LITERALS;
    #####: 1782:        context_p->last_cbc.third_literal_index = literal_index;
        -: 1783:      }
        -: 1784:      else
        -: 1785:      {
    #####: 1786:        parser_emit_cbc_literal (context_p, CBC_PUSH_LITERAL, literal_index);
        -: 1787:      }
        -: 1788:
    #####: 1789:      context_p->last_cbc.literal_type = LEXER_REGEXP_LITERAL;
    #####: 1790:      context_p->last_cbc.literal_keyword_type = LEXER_EOS;
    #####: 1791:      break;
        -: 1792:    }
    #####: 1793:    case LEXER_KEYW_THIS:
        -: 1794:    {
        -: 1795:#if ENABLED (JERRY_ES2015)
    #####: 1796:      if (context_p->status_flags & PARSER_ALLOW_SUPER_CALL)
        -: 1797:      {
    #####: 1798:        parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_LEXICAL_THIS);
        -: 1799:      }
        -: 1800:      else
        -: 1801:      {
        -: 1802:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1803:        parser_emit_cbc (context_p, CBC_PUSH_THIS);
        -: 1804:#if ENABLED (JERRY_ES2015)
        -: 1805:      }
        -: 1806:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1807:      break;
        -: 1808:    }
    #####: 1809:    case LEXER_LIT_TRUE:
        -: 1810:    {
    #####: 1811:      parser_emit_cbc (context_p, CBC_PUSH_TRUE);
    #####: 1812:      break;
        -: 1813:    }
    #####: 1814:    case LEXER_LIT_FALSE:
        -: 1815:    {
    #####: 1816:      parser_emit_cbc (context_p, CBC_PUSH_FALSE);
    #####: 1817:      break;
        -: 1818:    }
    #####: 1819:    case LEXER_LIT_NULL:
        -: 1820:    {
    #####: 1821:      parser_emit_cbc (context_p, CBC_PUSH_NULL);
    #####: 1822:      break;
        -: 1823:    }
        -: 1824:#if ENABLED (JERRY_ES2015)
    #####: 1825:    case LEXER_KEYW_CLASS:
        -: 1826:    {
    #####: 1827:      parser_parse_class (context_p, false);
    #####: 1828:      return false;
        -: 1829:    }
    #####: 1830:    case LEXER_KEYW_SUPER:
        -: 1831:    {
    #####: 1832:      if (context_p->status_flags & PARSER_ALLOW_SUPER)
        -: 1833:      {
    #####: 1834:        if (lexer_check_next_characters (context_p, LIT_CHAR_DOT, LIT_CHAR_LEFT_SQUARE))
        -: 1835:        {
    #####: 1836:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER);
    #####: 1837:          break;
        -: 1838:        }
        -: 1839:
    #####: 1840:        if (lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN)
    #####: 1841:            && (context_p->status_flags & PARSER_ALLOW_SUPER_CALL))
        -: 1842:        {
    #####: 1843:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_CONSTRUCTOR);
    #####: 1844:          break;
        -: 1845:        }
        -: 1846:      }
        -: 1847:
    #####: 1848:      parser_raise_error (context_p, PARSER_ERR_UNEXPECTED_SUPER_KEYWORD);
        -: 1849:    }
    #####: 1850:    case LEXER_LEFT_PAREN:
        -: 1851:    {
    #####: 1852:      JERRY_ASSERT (context_p->next_scanner_info_p->source_p == context_p->source_p
        -: 1853:                    && context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 1854:
    #####: 1855:      parser_check_assignment_expr (context_p);
        -: 1856:
    #####: 1857:      parser_parse_function_expression (context_p, PARSER_IS_FUNCTION | PARSER_IS_ARROW_FUNCTION);
    #####: 1858:      return parser_abort_parsing_after_arrow (context_p);
        -: 1859:    }
    #####: 1860:    case LEXER_KEYW_YIELD:
        -: 1861:    {
    #####: 1862:      JERRY_ASSERT ((context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1863:                    && !(context_p->status_flags & PARSER_DISALLOW_AWAIT_YIELD));
        -: 1864:
    #####: 1865:      if (context_p->token.lit_location.has_escape)
        -: 1866:      {
    #####: 1867:        parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 1868:      }
        -: 1869:
    #####: 1870:      parser_check_assignment_expr (context_p);
    #####: 1871:      lexer_next_token (context_p);
        -: 1872:
    #####: 1873:      cbc_ext_opcode_t opcode = CBC_EXT_YIELD;
        -: 1874:
    #####: 1875:      if (!lexer_check_yield_no_arg (context_p))
        -: 1876:      {
    #####: 1877:        if (context_p->token.type == LEXER_MULTIPLY)
        -: 1878:        {
    #####: 1879:          lexer_next_token (context_p);
    #####: 1880:          opcode = CBC_EXT_YIELD_ITERATOR;
        -: 1881:        }
        -: 1882:
    #####: 1883:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1884:      }
        -: 1885:      else
        -: 1886:      {
    #####: 1887:        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 1888:      }
        -: 1889:
    #####: 1890:      parser_emit_cbc_ext (context_p, opcode);
        -: 1891:
    #####: 1892:      return (context_p->token.type != LEXER_RIGHT_PAREN
    #####: 1893:              && context_p->token.type != LEXER_COMMA);
        -: 1894:    }
        -: 1895:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1896:    default:
        -: 1897:    {
    #####: 1898:      bool is_left_hand_side = (*grouping_level_p == PARSE_EXPR_LEFT_HAND_SIDE);
    #####: 1899:      parser_raise_error (context_p, (is_left_hand_side ? PARSER_ERR_LEFT_HAND_SIDE_EXP_EXPECTED
        -: 1900:                                                        : PARSER_ERR_PRIMARY_EXP_EXPECTED));
    #####: 1901:      break;
        -: 1902:    }
        -: 1903:  }
       32: 1904:  lexer_next_token (context_p);
       32: 1905:  return false;
        -: 1906:} /* parser_parse_unary_expression */
        -: 1907:
        -: 1908:/**
        -: 1909: * Parse the postfix part of unary operators, and
        -: 1910: * generate byte code for the whole expression.
        -: 1911: */
        -: 1912:static void
       43: 1913:parser_process_unary_expression (parser_context_t *context_p, /**< context */
        -: 1914:                                 size_t grouping_level) /**< grouping level */
        -: 1915:{
        -: 1916:  /* Parse postfix part of a primary expression. */
        -: 1917:  while (true)
        -: 1918:  {
        -: 1919:    /* Since break would only break the switch, we use
        -: 1920:     * continue to continue this loop. Without continue,
        -: 1921:     * the code abandons the loop. */
       54: 1922:    switch (context_p->token.type)
        -: 1923:    {
        4: 1924:      case LEXER_DOT:
        -: 1925:      {
        4: 1926:        parser_push_result (context_p);
        -: 1927:
        4: 1928:        lexer_expect_identifier (context_p, LEXER_STRING_LITERAL);
        4: 1929:        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -: 1930:                      && context_p->lit_object.literal_p->type == LEXER_STRING_LITERAL);
        4: 1931:        context_p->token.lit_location.type = LEXER_STRING_LITERAL;
        -: 1932:
        4: 1933:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 1934:        {
        4: 1935:          JERRY_ASSERT (CBC_ARGS_EQ (CBC_PUSH_PROP_LITERAL_LITERAL,
        -: 1936:                                     CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        4: 1937:          context_p->last_cbc_opcode = CBC_PUSH_PROP_LITERAL_LITERAL;
        4: 1938:          context_p->last_cbc.value = context_p->lit_object.index;
        -: 1939:        }
    #####: 1940:        else if (context_p->last_cbc_opcode == CBC_PUSH_THIS)
        -: 1941:        {
    #####: 1942:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1943:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_THIS_LITERAL);
        -: 1944:        }
        -: 1945:#if ENABLED (JERRY_ES2015)
    #####: 1946:        else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 1947:        {
    #####: 1948:          context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL);
    #####: 1949:          context_p->last_cbc.literal_index = context_p->lit_object.index;
        -: 1950:        }
        -: 1951:#endif /* ENABLED (JERRY_ES2015) */
        -: 1952:        else
        -: 1953:        {
    #####: 1954:          parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_PROP_LITERAL);
        -: 1955:        }
        4: 1956:        lexer_next_token (context_p);
        4: 1957:        continue;
        -: 1958:      }
        -: 1959:
        1: 1960:      case LEXER_LEFT_SQUARE:
        -: 1961:      {
        1: 1962:        parser_push_result (context_p);
        -: 1963:
        -: 1964:#if ENABLED (JERRY_ES2015)
        1: 1965:        uint16_t last_cbc_opcode = context_p->last_cbc_opcode;
        -: 1966:
        1: 1967:        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 1968:        {
    #####: 1969:          context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1970:        }
        -: 1971:#endif /* ENABLED (JERRY_ES2015) */
        -: 1972:
        1: 1973:        lexer_next_token (context_p);
        1: 1974:        parser_parse_expression (context_p, PARSE_EXPR);
        1: 1975:        if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 1976:        {
    #####: 1977:          parser_raise_error (context_p, PARSER_ERR_RIGHT_SQUARE_EXPECTED);
        -: 1978:        }
        1: 1979:        lexer_next_token (context_p);
        -: 1980:
        -: 1981:#if ENABLED (JERRY_ES2015)
        1: 1982:        if (last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER))
        -: 1983:        {
    #####: 1984:          parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SUPER_PROP);
    #####: 1985:          continue;
        -: 1986:        }
        -: 1987:#endif /* ENABLED (JERRY_ES2015) */
        -: 1988:
        1: 1989:        if (PARSER_IS_MUTABLE_PUSH_LITERAL (context_p->last_cbc_opcode))
        -: 1990:        {
        1: 1991:          context_p->last_cbc_opcode = PARSER_PUSH_LITERAL_TO_PUSH_PROP_LITERAL (context_p->last_cbc_opcode);
        -: 1992:        }
        -: 1993:        else
        -: 1994:        {
    #####: 1995:          parser_emit_cbc (context_p, CBC_PUSH_PROP);
        -: 1996:        }
        1: 1997:        continue;
        -: 1998:      }
        -: 1999:
        -: 2000:#if ENABLED (JERRY_ES2015)
        6: 2001:      case LEXER_TEMPLATE_LITERAL:
        -: 2002:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2003:      case LEXER_LEFT_PAREN:
        -: 2004:      {
        6: 2005:        size_t call_arguments = 0;
        6: 2006:        uint16_t opcode = CBC_CALL;
        6: 2007:        bool is_eval = false;
        -: 2008:
        6: 2009:        parser_push_result (context_p);
        -: 2010:
        6: 2011:        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)
        -: 2012:        {
        3: 2013:          parser_stack_pop_uint8 (context_p);
        3: 2014:          opcode = CBC_NEW;
        -: 2015:        }
        -: 2016:        else
        -: 2017:        {
        3: 2018:          if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL
        2: 2019:              && context_p->last_cbc.literal_keyword_type == LEXER_KEYW_EVAL
        1: 2020:              && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2021:          {
        1: 2022:            is_eval = true;
        -: 2023:          }
        -: 2024:
        3: 2025:          if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 2026:          {
        1: 2027:            opcode = CBC_CALL_PROP;
        1: 2028:            context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);
        -: 2029:          }
        -: 2030:#if ENABLED (JERRY_ES2015)
        2: 2031:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_CONSTRUCTOR))
        -: 2032:          {
    #####: 2033:            opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL);
        -: 2034:          }
        2: 2035:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))
        -: 2036:          {
    #####: 2037:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_REFERENCE);
    #####: 2038:            opcode = CBC_CALL_PROP;
        -: 2039:          }
        2: 2040:          else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -: 2041:          {
    #####: 2042:            context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_REFERENCE);
    #####: 2043:            opcode = CBC_CALL_PROP;
        -: 2044:          }
        -: 2045:#endif /* ENABLED (JERRY_ES2015) */
        2: 2046:          else if (JERRY_UNLIKELY (context_p->status_flags & PARSER_INSIDE_WITH)
    #####: 2047:                   && PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2048:                   && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2049:          {
    #####: 2050:            opcode = CBC_CALL_PROP;
    #####: 2051:            parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);
    #####: 2052:            parser_emit_cbc_ext (context_p, CBC_EXT_RESOLVE_BASE);
        -: 2053:          }
        -: 2054:        }
        -: 2055:
        -: 2056:#if ENABLED (JERRY_ES2015)
        6: 2057:        bool has_spread_element = false;
        -: 2058:
        6: 2059:        if (context_p->token.type == LEXER_TEMPLATE_LITERAL)
        -: 2060:        {
    #####: 2061:          call_arguments = parser_parse_tagged_template_literal (context_p);
        -: 2062:        }
        -: 2063:        else
        -: 2064:        {
        6: 2065:          lexer_next_token (context_p);
        -: 2066:
        6: 2067:          while (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2068:          {
        3: 2069:            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2070:            {
    #####: 2071:              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2072:            }
        -: 2073:
        3: 2074:            if (context_p->token.type == LEXER_THREE_DOTS)
        -: 2075:            {
    #####: 2076:              has_spread_element = true;
    #####: 2077:              call_arguments++;
    #####: 2078:              parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_SPREAD_ELEMENT);
    #####: 2079:              lexer_next_token (context_p);
        -: 2080:            }
        -: 2081:
        3: 2082:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2083:
        3: 2084:            if (context_p->token.type == LEXER_COMMA)
        -: 2085:            {
    #####: 2086:              lexer_next_token (context_p);
    #####: 2087:              continue;
        -: 2088:            }
        -: 2089:
        3: 2090:            if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2091:            {
    #####: 2092:              parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2093:            }
        -: 2094:
        3: 2095:            break;
        -: 2096:          }
        -: 2097:        }
        -: 2098:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2099:        lexer_next_token (context_p);
        -: 2100:
    #####: 2101:        if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2102:        {
        -: 2103:          while (true)
        -: 2104:          {
    #####: 2105:            if (++call_arguments > CBC_MAXIMUM_BYTE_VALUE)
        -: 2106:            {
    #####: 2107:              parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 2108:            }
        -: 2109:
    #####: 2110:            parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2111:
    #####: 2112:            if (context_p->token.type != LEXER_COMMA)
        -: 2113:            {
    #####: 2114:              break;
        -: 2115:            }
    #####: 2116:            lexer_next_token (context_p);
        -: 2117:          }
        -: 2118:
    #####: 2119:          if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2120:          {
    #####: 2121:            parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2122:          }
        -: 2123:        }
        -: 2124:#endif /* ENABLED (JERRY_ES2015) */
        -: 2125:
        6: 2126:        lexer_next_token (context_p);
        -: 2127:
        6: 2128:        if (is_eval)
        -: 2129:        {
        1: 2130:          context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2131:
        -: 2132:#if ENABLED (JERRY_ES2015)
        1: 2133:          if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)
        -: 2134:          {
    #####: 2135:            context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2136:          }
        -: 2137:
        1: 2138:          if (context_p->status_flags & (PARSER_ALLOW_SUPER_CALL | PARSER_ALLOW_SUPER | PARSER_ALLOW_NEW_TARGET))
        -: 2139:          {
        1: 2140:            parser_emit_cbc_ext_call (context_p,
        -: 2141:                                      CBC_EXT_LOCAL_EVAL,
        -: 2142:                                      PARSER_SAVE_STATUS_FLAGS (context_p->status_flags));
        -: 2143:          }
        -: 2144:          else
        -: 2145:          {
        -: 2146:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2147:            parser_emit_cbc (context_p, CBC_EVAL);
        -: 2148:#if ENABLED (JERRY_ES2015)
        -: 2149:          }
        -: 2150:#endif /* ENABLED (JERRY_ES2015) */
        -: 2151:        }
        -: 2152:
        -: 2153:#if ENABLED (JERRY_ES2015)
        6: 2154:        if (has_spread_element)
        -: 2155:        {
        -: 2156:          uint16_t spread_opcode;
        -: 2157:
    #####: 2158:          if (opcode == CBC_CALL)
        -: 2159:          {
    #####: 2160:            spread_opcode = CBC_EXT_SPREAD_CALL;
        -: 2161:          }
    #####: 2162:          else if (opcode == CBC_CALL_PROP)
        -: 2163:          {
    #####: 2164:            spread_opcode = CBC_EXT_SPREAD_CALL_PROP;
        -: 2165:          }
    #####: 2166:          else if (opcode == CBC_NEW)
        -: 2167:          {
    #####: 2168:            spread_opcode = CBC_EXT_SPREAD_NEW;
        -: 2169:          }
        -: 2170:          else
        -: 2171:          {
        -: 2172:            /* opcode is unchanged */
    #####: 2173:            JERRY_ASSERT (opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_CALL));
    #####: 2174:            spread_opcode = CBC_EXT_SPREAD_SUPER_CALL;
        -: 2175:          }
        -: 2176:
    #####: 2177:          parser_emit_cbc_ext_call (context_p, spread_opcode, call_arguments);
    #####: 2178:          continue;
        -: 2179:        }
        -: 2180:#endif /* ENABLED (JERRY_ES2015) */
        -: 2181:
        6: 2182:        if (call_arguments <= 1)
        -: 2183:        {
        6: 2184:          if (opcode == CBC_CALL)
        -: 2185:          {
        2: 2186:            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0 + (call_arguments * 6)));
        2: 2187:            continue;
        -: 2188:          }
        4: 2189:          if (opcode == CBC_CALL_PROP)
        -: 2190:          {
        1: 2191:            parser_emit_cbc (context_p, (uint16_t) (CBC_CALL0_PROP + (call_arguments * 6)));
        1: 2192:            continue;
        -: 2193:          }
        3: 2194:          if (opcode == CBC_NEW)
        -: 2195:          {
        3: 2196:            parser_emit_cbc (context_p, (uint16_t) (CBC_NEW0 + call_arguments));
        3: 2197:            continue;
        -: 2198:          }
        -: 2199:        }
        -: 2200:
    #####: 2201:        if (call_arguments == 2)
        -: 2202:        {
    #####: 2203:          if (opcode == CBC_CALL)
        -: 2204:          {
    #####: 2205:            parser_emit_cbc (context_p, CBC_CALL2);
    #####: 2206:            continue;
        -: 2207:          }
    #####: 2208:          if (opcode == CBC_CALL_PROP)
        -: 2209:          {
    #####: 2210:            parser_flush_cbc (context_p);
        -: 2211:            /* Manually adjusting stack usage. */
    #####: 2212:            JERRY_ASSERT (context_p->stack_depth > 0);
    #####: 2213:            context_p->stack_depth--;
    #####: 2214:            parser_emit_cbc (context_p, CBC_CALL2_PROP);
    #####: 2215:            continue;
        -: 2216:          }
        -: 2217:        }
        -: 2218:
    #####: 2219:        parser_emit_cbc_call (context_p, opcode, call_arguments);
    #####: 2220:        continue;
        -: 2221:      }
        -: 2222:
       32: 2223:      default:
        -: 2224:      {
       32: 2225:        if (context_p->stack_top_uint8 == LEXER_KEYW_NEW)
        -: 2226:        {
    #####: 2227:          parser_push_result (context_p);
    #####: 2228:          parser_emit_cbc (context_p, CBC_NEW0);
    #####: 2229:          parser_stack_pop_uint8 (context_p);
    #####: 2230:          continue;
        -: 2231:        }
        -: 2232:
       32: 2233:        if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
       32: 2234:            && (context_p->token.type == LEXER_INCREASE || context_p->token.type == LEXER_DECREASE)
    #####: 2235:            && grouping_level != PARSE_EXPR_LEFT_HAND_SIDE)
        -: 2236:        {
    #####: 2237:          cbc_opcode_t opcode = (context_p->token.type == LEXER_INCREASE) ? CBC_POST_INCR : CBC_POST_DECR;
    #####: 2238:          parser_push_result (context_p);
    #####: 2239:          parser_emit_unary_lvalue_opcode (context_p, opcode);
    #####: 2240:          lexer_next_token (context_p);
        -: 2241:        }
       32: 2242:        break;
        -: 2243:      }
        -: 2244:    }
       32: 2245:    break;
        -: 2246:  }
        -: 2247:
        -: 2248:#if ENABLED (JERRY_ES2015)
       32: 2249:  uint8_t last_unary_token = LEXER_INCREASE;
        -: 2250:#endif /* ENABLED (JERRY_ES2015) */
        -: 2251:
        -: 2252:  /* Generate byte code for the unary operators. */
        -: 2253:  while (true)
    #####: 2254:  {
       32: 2255:    uint8_t token = context_p->stack_top_uint8;
       32: 2256:    if (!LEXER_IS_UNARY_OP_TOKEN (token))
        -: 2257:    {
        -: 2258:#if ENABLED (JERRY_ES2015)
       32: 2259:      if (context_p->token.type == LEXER_EXPONENTIATION
    #####: 2260:          && last_unary_token != LEXER_INCREASE
    #####: 2261:          && last_unary_token != LEXER_DECREASE)
        -: 2262:      {
    #####: 2263:        parser_raise_error (context_p, PARSER_ERR_INVALID_EXPONENTIATION);
        -: 2264:      }
        -: 2265:#endif /* ENABLED (JERRY_ES2015) */
       32: 2266:      break;
        -: 2267:    }
        -: 2268:
        -: 2269:#if ENABLED (JERRY_ES2015)
    #####: 2270:    last_unary_token = token;
        -: 2271:#endif /* ENABLED (JERRY_ES2015) */
        -: 2272:
    #####: 2273:    parser_push_result (context_p);
    #####: 2274:    parser_stack_pop_uint8 (context_p);
        -: 2275:
    #####: 2276:    if (LEXER_IS_UNARY_LVALUE_OP_TOKEN (token))
        -: 2277:    {
    #####: 2278:      if (token == LEXER_KEYW_DELETE)
        -: 2279:      {
    #####: 2280:        token = CBC_DELETE_PUSH_RESULT;
        -: 2281:      }
        -: 2282:      else
        -: 2283:      {
    #####: 2284:        token = (uint8_t) (LEXER_UNARY_LVALUE_OP_TOKEN_TO_OPCODE (token));
        -: 2285:      }
    #####: 2286:      parser_emit_unary_lvalue_opcode (context_p, (cbc_opcode_t) token);
        -: 2287:    }
        -: 2288:#if ENABLED (JERRY_ES2015)
    #####: 2289:    else if (JERRY_UNLIKELY (token == LEXER_KEYW_AWAIT))
        -: 2290:    {
    #####: 2291:      parser_emit_cbc_ext (context_p, CBC_EXT_AWAIT);
        -: 2292:    }
        -: 2293:#endif /* ENABLED (JERRY_ES2015) */
        -: 2294:    else
        -: 2295:    {
    #####: 2296:      token = (uint8_t) (LEXER_UNARY_OP_TOKEN_TO_OPCODE (token));
        -: 2297:
    #####: 2298:      if (token == CBC_TYPEOF)
        -: 2299:      {
    #####: 2300:        if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2301:            && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2302:        {
    #####: 2303:          parser_emit_ident_reference (context_p, CBC_TYPEOF_IDENT);
        -: 2304:        }
        -: 2305:        else
        -: 2306:        {
    #####: 2307:          parser_emit_cbc (context_p, token);
        -: 2308:        }
        -: 2309:      }
        -: 2310:      else
        -: 2311:      {
    #####: 2312:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2313:        {
        -: 2314:          /* It is not worth to combine with push multiple literals
        -: 2315:           * since the byte code size will not decrease. */
    #####: 2316:          JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, token + 1));
    #####: 2317:          context_p->last_cbc_opcode = (uint16_t) (token + 1);
        -: 2318:        }
        -: 2319:        else
        -: 2320:        {
    #####: 2321:          parser_emit_cbc (context_p, token);
        -: 2322:        }
        -: 2323:      }
        -: 2324:    }
        -: 2325:  }
       32: 2326:} /* parser_process_unary_expression */
        -: 2327:
        -: 2328:/**
        -: 2329: * Append a binary '=' token.
        -: 2330: *
        -: 2331: * @return - pushed assignment opcode onto the parser stack
        -: 2332: */
        -: 2333:static uint8_t
        3: 2334:parser_append_binary_single_assignment_token (parser_context_t *context_p, /**< context */
        -: 2335:                                              uint32_t pattern_flags) /**< pattern flags */
        -: 2336:{
        -: 2337:  JERRY_UNUSED (pattern_flags);
        -: 2338:
        -: 2339:  /* Unlike other tokens, the whole byte code is saved for binary
        -: 2340:   * assignment, since it has multiple forms depending on the
        -: 2341:   * previous instruction. */
        -: 2342:
        3: 2343:  uint8_t assign_opcode = CBC_ASSIGN;
        -: 2344:
        3: 2345:  if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
        1: 2346:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        1: 2347:  {
        1: 2348:    parser_check_invalid_assign (context_p);
        -: 2349:
        -: 2350:    uint16_t literal_index;
        -: 2351:
        1: 2352:    switch (context_p->last_cbc_opcode)
        -: 2353:    {
        1: 2354:      case CBC_PUSH_LITERAL:
        -: 2355:      {
        1: 2356:        literal_index = context_p->last_cbc.literal_index;
        1: 2357:        context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        1: 2358:        break;
        -: 2359:      }
    #####: 2360:      case CBC_PUSH_TWO_LITERALS:
        -: 2361:      {
    #####: 2362:        literal_index = context_p->last_cbc.value;
    #####: 2363:        context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
    #####: 2364:        break;
        -: 2365:      }
    #####: 2366:      case CBC_PUSH_THIS_LITERAL:
        -: 2367:      {
    #####: 2368:        literal_index = context_p->last_cbc.literal_index;
    #####: 2369:        context_p->last_cbc_opcode = CBC_PUSH_THIS;
    #####: 2370:        parser_flush_cbc (context_p);
    #####: 2371:        break;
        -: 2372:      }
    #####: 2373:      default:
        -: 2374:      {
    #####: 2375:        JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS);
    #####: 2376:        literal_index = context_p->last_cbc.third_literal_index;
    #####: 2377:        context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 2378:        break;
        -: 2379:      }
        -: 2380:    }
        -: 2381:
        1: 2382:    assign_opcode = CBC_ASSIGN_SET_IDENT;
        -: 2383:
        -: 2384:#if ENABLED (JERRY_ES2015)
        1: 2385:    if (!(pattern_flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST | PARSER_PATTERN_LOCAL)))
        -: 2386:    {
        1: 2387:      if (scanner_literal_is_const_reg (context_p, literal_index))
        -: 2388:      {
    #####: 2389:        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);
        -: 2390:      }
        -: 2391:    }
    #####: 2392:    else if (literal_index < PARSER_REGISTER_START)
        -: 2393:    {
    #####: 2394:      assign_opcode = CBC_INIT_LET;
        -: 2395:
    #####: 2396:      if (scanner_literal_is_created (context_p, literal_index))
        -: 2397:      {
    #####: 2398:        assign_opcode = CBC_ASSIGN_LET_CONST;
        -: 2399:      }
    #####: 2400:      else if (pattern_flags & PARSER_PATTERN_CONST)
        -: 2401:      {
    #####: 2402:        assign_opcode = CBC_INIT_CONST;
        -: 2403:      }
    #####: 2404:      else if (pattern_flags & PARSER_PATTERN_LOCAL)
        -: 2405:      {
    #####: 2406:        assign_opcode = CBC_INIT_ARG_OR_CATCH;
        -: 2407:      }
        -: 2408:    }
        -: 2409:#endif /* ENABLED (JERRY_ES2015) */
        -: 2410:
        1: 2411:    parser_stack_push_uint16 (context_p, literal_index);
        1: 2412:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_LITERAL, assign_opcode));
        -: 2413:  }
        2: 2414:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP)
        -: 2415:  {
    #####: 2416:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP, CBC_ASSIGN));
    #####: 2417:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2418:  }
        2: 2419:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL)
        -: 2420:  {
    #####: 2421:    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)
        -: 2422:    {
    #####: 2423:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL, CBC_ASSIGN_PROP_LITERAL));
    #####: 2424:      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);
    #####: 2425:      assign_opcode = CBC_ASSIGN_PROP_LITERAL;
    #####: 2426:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2427:    }
        -: 2428:    else
        -: 2429:    {
    #####: 2430:      context_p->last_cbc_opcode = CBC_PUSH_LITERAL;
        -: 2431:    }
        -: 2432:  }
        2: 2433:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_LITERAL_LITERAL)
        -: 2434:  {
        2: 2435:    JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_LITERAL_LITERAL, CBC_PUSH_TWO_LITERALS));
        2: 2436:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
        -: 2437:  }
    #####: 2438:  else if (context_p->last_cbc_opcode == CBC_PUSH_PROP_THIS_LITERAL)
        -: 2439:  {
    #####: 2440:    if (context_p->last_cbc.literal_type != LEXER_IDENT_LITERAL)
        -: 2441:    {
    #####: 2442:      JERRY_ASSERT (CBC_SAME_ARGS (CBC_PUSH_PROP_THIS_LITERAL, CBC_ASSIGN_PROP_THIS_LITERAL));
    #####: 2443:      parser_stack_push_uint16 (context_p, context_p->last_cbc.literal_index);
    #####: 2444:      assign_opcode = CBC_ASSIGN_PROP_THIS_LITERAL;
    #####: 2445:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2446:    }
        -: 2447:    else
        -: 2448:    {
    #####: 2449:      context_p->last_cbc_opcode = CBC_PUSH_THIS_LITERAL;
        -: 2450:    }
        -: 2451:  }
        -: 2452:#if ENABLED (JERRY_ES2015)
    #####: 2453:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP_LITERAL))
        -: 2454:  {
    #####: 2455:    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);
    #####: 2456:    assign_opcode = CBC_ASSIGN_SUPER;
        -: 2457:  }
    #####: 2458:  else if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_PUSH_SUPER_PROP))
        -: 2459:  {
    #####: 2460:    context_p->last_cbc_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE);
    #####: 2461:    assign_opcode = CBC_ASSIGN_SUPER;
        -: 2462:  }
        -: 2463:#endif /* ENABLED (JERRY_ES2015) */
        -: 2464:  else
        -: 2465:  {
        -: 2466:    /* Invalid LeftHandSide expression. */
        -: 2467:#if ENABLED (JERRY_ES2015)
    #####: 2468:    parser_check_invalid_new_target (context_p, CBC_ASSIGN);
        -: 2469:#endif /* ENABLED (JERRY_ES2015) */
        -: 2470:
    #####: 2471:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 2472:  }
        -: 2473:
        3: 2474:  parser_stack_push_uint8 (context_p, assign_opcode);
        3: 2475:  parser_stack_push_uint8 (context_p, LEXER_ASSIGN);
        -: 2476:
        3: 2477:  return assign_opcode;
        -: 2478:} /* parser_append_binary_single_assignment_token */
        -: 2479:
        -: 2480:/**
        -: 2481: * Append a binary token.
        -: 2482: */
        -: 2483:static void
        5: 2484:parser_append_binary_token (parser_context_t *context_p) /**< context */
        -: 2485:{
        5: 2486:  JERRY_ASSERT (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type));
        -: 2487:
        5: 2488:  parser_push_result (context_p);
        -: 2489:
        5: 2490:  if (context_p->token.type == LEXER_ASSIGN)
        -: 2491:  {
        3: 2492:    parser_append_binary_single_assignment_token (context_p, 0);
        3: 2493:    return;
        -: 2494:  }
        -: 2495:
        2: 2496:  if (LEXER_IS_BINARY_LVALUE_TOKEN (context_p->token.type))
        -: 2497:  {
    #####: 2498:    if (PARSER_IS_PUSH_LITERALS_WITH_THIS (context_p->last_cbc_opcode)
    #####: 2499:        && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 2500:    {
    #####: 2501:      parser_check_invalid_assign (context_p);
        -: 2502:
    #####: 2503:      parser_emit_ident_reference (context_p, CBC_PUSH_IDENT_REFERENCE);
        -: 2504:
        -: 2505:#if ENABLED (JERRY_ES2015)
    #####: 2506:      if (scanner_literal_is_const_reg (context_p, context_p->last_cbc.literal_index))
        -: 2507:      {
    #####: 2508:        parser_stack_push_uint8 (context_p, LEXER_ASSIGN_CONST);
        -: 2509:      }
        -: 2510:#endif /* ENABLED (JERRY_ES2015) */
        -: 2511:    }
    #####: 2512:    else if (PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 2513:    {
    #####: 2514:      context_p->last_cbc_opcode = PARSER_PUSH_PROP_TO_PUSH_PROP_REFERENCE (context_p->last_cbc_opcode);
        -: 2515:    }
        -: 2516:    else
        -: 2517:    {
        -: 2518:      /* Invalid LeftHandSide expression. */
        -: 2519:#if ENABLED (JERRY_ES2015)
    #####: 2520:      parser_check_invalid_new_target (context_p, CBC_ASSIGN);
        -: 2521:#endif /* ENABLED (JERRY_ES2015) */
        -: 2522:
    #####: 2523:      parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
    #####: 2524:      parser_emit_cbc (context_p, CBC_PUSH_PROP_REFERENCE);
        -: 2525:    }
        -: 2526:  }
        2: 2527:  else if (context_p->token.type == LEXER_LOGICAL_OR
        2: 2528:           || context_p->token.type == LEXER_LOGICAL_AND)
        -: 2529:  {
    #####: 2530:    parser_branch_t branch;
    #####: 2531:    uint16_t opcode = CBC_BRANCH_IF_LOGICAL_TRUE;
        -: 2532:
    #####: 2533:    if (context_p->token.type == LEXER_LOGICAL_AND)
        -: 2534:    {
    #####: 2535:      opcode = CBC_BRANCH_IF_LOGICAL_FALSE;
        -: 2536:    }
        -: 2537:
    #####: 2538:    parser_emit_cbc_forward_branch (context_p, opcode, &branch);
    #####: 2539:    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 2540:  }
        -: 2541:
        2: 2542:  parser_stack_push_uint8 (context_p, context_p->token.type);
        -: 2543:} /* parser_append_binary_token */
        -: 2544:
        -: 2545:/**
        -: 2546: * Emit opcode for binary computations.
        -: 2547: */
        -: 2548:static void
       37: 2549:parser_process_binary_opcodes (parser_context_t *context_p, /**< context */
        -: 2550:                               uint8_t min_prec_treshold) /**< minimal precedence of tokens */
        -: 2551:{
        -: 2552:  while (true)
        5: 2553:  {
       37: 2554:    uint8_t token = context_p->stack_top_uint8;
        -: 2555:    cbc_opcode_t opcode;
        -: 2556:
        -: 2557:    /* For left-to-right operators (all binary operators except assignment
        -: 2558:     * and logical operators), the byte code is flushed if the precedence
        -: 2559:     * of the next operator is less or equal than the current operator. For
        -: 2560:     * assignment and logical operators, we add 1 to the min precendence to
        -: 2561:     * force right-to-left evaluation order. */
        -: 2562:
       37: 2563:    if (!LEXER_IS_BINARY_OP_TOKEN (token)
        5: 2564:        || parser_binary_precedence_table[token - LEXER_FIRST_BINARY_OP] < min_prec_treshold)
        -: 2565:    {
       64: 2566:      return;
        -: 2567:    }
        -: 2568:
        5: 2569:    parser_push_result (context_p);
        5: 2570:    parser_stack_pop_uint8 (context_p);
        -: 2571:
        5: 2572:    if (token == LEXER_ASSIGN)
        -: 2573:    {
        3: 2574:      opcode = (cbc_opcode_t) context_p->stack_top_uint8;
        3: 2575:      parser_stack_pop_uint8 (context_p);
        -: 2576:
        3: 2577:      int32_t index = -1;
        3: 2578:      if (cbc_flags[opcode] & CBC_HAS_LITERAL_ARG)
        -: 2579:      {
        1: 2580:        JERRY_ASSERT (opcode == CBC_ASSIGN_SET_IDENT
        -: 2581:                      || opcode == CBC_ASSIGN_PROP_LITERAL
        -: 2582:                      || opcode == CBC_ASSIGN_PROP_THIS_LITERAL
        -: 2583:                      || opcode == CBC_ASSIGN_LET_CONST
        -: 2584:                      || opcode == CBC_INIT_ARG_OR_CATCH
        -: 2585:                      || opcode == CBC_INIT_LET
        -: 2586:                      || opcode == CBC_INIT_CONST);
        -: 2587:
        1: 2588:        index = parser_stack_pop_uint16 (context_p);
        -: 2589:      }
        -: 2590:
        -: 2591:#if ENABLED (JERRY_ES2015)
        3: 2592:      if (JERRY_UNLIKELY (context_p->stack_top_uint8 == LEXER_ASSIGN_CONST))
        -: 2593:      {
    #####: 2594:        parser_stack_pop_uint8 (context_p);
    #####: 2595:        parser_emit_cbc_ext (context_p, CBC_EXT_THROW_ASSIGN_CONST_ERROR);
        -: 2596:      }
        -: 2597:#endif /* ENABLED (JERRY_ES2015) */
        -: 2598:
        3: 2599:      if (index >= 0)
        -: 2600:      {
        1: 2601:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL
        1: 2602:            && opcode == CBC_ASSIGN_SET_IDENT)
        -: 2603:        {
        1: 2604:          JERRY_ASSERT (CBC_ARGS_EQ (CBC_ASSIGN_LITERAL_SET_IDENT,
        -: 2605:                                     CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        -: 2606:
        1: 2607:          context_p->last_cbc.value = (uint16_t) index;
        1: 2608:          context_p->last_cbc_opcode = CBC_ASSIGN_LITERAL_SET_IDENT;
        1: 2609:          continue;
        -: 2610:        }
        -: 2611:
    #####: 2612:        parser_emit_cbc_literal (context_p, (uint16_t) opcode, (uint16_t) index);
        -: 2613:
    #####: 2614:        if (opcode == CBC_ASSIGN_PROP_THIS_LITERAL
    #####: 2615:            && (context_p->stack_depth >= context_p->stack_limit))
        -: 2616:        {
        -: 2617:          /* Stack limit is increased for VM_OC_ASSIGN_PROP_THIS. Needed by vm.c. */
    #####: 2618:          JERRY_ASSERT (context_p->stack_depth == context_p->stack_limit);
        -: 2619:
    #####: 2620:          context_p->stack_limit++;
        -: 2621:
    #####: 2622:          if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -: 2623:          {
    #####: 2624:            parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -: 2625:          }
        -: 2626:        }
    #####: 2627:        continue;
        -: 2628:      }
        -: 2629:    }
        2: 2630:    else if (LEXER_IS_BINARY_LVALUE_TOKEN (token))
        -: 2631:    {
    #####: 2632:      parser_stack_push_uint8 (context_p, CBC_ASSIGN);
    #####: 2633:      parser_stack_push_uint8 (context_p, LEXER_ASSIGN);
    #####: 2634:      parser_stack_push_uint8 (context_p, lexer_convert_binary_lvalue_token_to_binary (token));
    #####: 2635:      continue;
        -: 2636:    }
        2: 2637:    else if (token == LEXER_LOGICAL_OR || token == LEXER_LOGICAL_AND)
        -: 2638:    {
    #####: 2639:      parser_branch_t branch;
    #####: 2640:      parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####: 2641:      parser_set_branch_to_current_position (context_p, &branch);
    #####: 2642:      continue;
        -: 2643:    }
        -: 2644:    else
        -: 2645:    {
        2: 2646:      opcode = LEXER_BINARY_OP_TOKEN_TO_OPCODE (token);
        -: 2647:
        2: 2648:      if (PARSER_IS_PUSH_NUMBER (context_p->last_cbc_opcode))
        -: 2649:      {
        1: 2650:        lexer_convert_push_number_to_push_literal (context_p);
        -: 2651:      }
        -: 2652:
        2: 2653:      if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2654:      {
    #####: 2655:        JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, opcode + CBC_BINARY_WITH_LITERAL));
    #####: 2656:        context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_LITERAL);
    #####: 2657:        continue;
        -: 2658:      }
        2: 2659:      else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 2660:      {
        2: 2661:        JERRY_ASSERT (CBC_ARGS_EQ (opcode + CBC_BINARY_WITH_TWO_LITERALS,
        -: 2662:                                   CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2));
        2: 2663:        context_p->last_cbc_opcode = (uint16_t) (opcode + CBC_BINARY_WITH_TWO_LITERALS);
        2: 2664:        continue;
        -: 2665:      }
        -: 2666:    }
        2: 2667:    parser_emit_cbc (context_p, (uint16_t) opcode);
        -: 2668:  }
        -: 2669:} /* parser_process_binary_opcodes */
        -: 2670:
        -: 2671:#if ENABLED (JERRY_ES2015)
        -: 2672:/**
        -: 2673: * End position marker of a pattern.
        -: 2674: */
        -: 2675:typedef struct
        -: 2676:{
        -: 2677:  scanner_location_t location; /**< end position of the pattern */
        -: 2678:  lexer_token_t token; /**< token at the end position */
        -: 2679:} parser_pattern_end_marker_t;
        -: 2680:
        -: 2681:/**
        -: 2682: * Literal index should not be emitted while processing rhs target value
        -: 2683: */
        -: 2684:#define PARSER_PATTERN_RHS_NO_LIT UINT16_MAX
        -: 2685:
        -: 2686:/**
        -: 2687: * Process the target of an initializer pattern.
        -: 2688: */
        -: 2689:static parser_pattern_end_marker_t
    #####: 2690:parser_pattern_get_target (parser_context_t *context_p, /**< context */
        -: 2691:                           parser_pattern_flags_t flags) /**< flags */
        -: 2692:{
    #####: 2693:  parser_pattern_end_marker_t end_marker;
    #####: 2694:  end_marker.token.type = LEXER_INVALID_PATTERN;
    #####: 2695:  parser_branch_t skip_init;
        -: 2696:
    #####: 2697:  if (flags & PARSER_PATTERN_TARGET_DEFAULT)
        -: 2698:  {
    #####: 2699:    JERRY_ASSERT (flags & PARSER_PATTERN_TARGET_ON_STACK);
        -: 2700:
    #####: 2701:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 2702:  }
        -: 2703:
    #####: 2704:  if ((flags & (PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_TARGET_DEFAULT)) != PARSER_PATTERN_TARGET_ON_STACK)
        -: 2705:  {
    #####: 2706:    scanner_location_t start_location;
        -: 2707:
    #####: 2708:    if (context_p->next_scanner_info_p->source_p != context_p->source_p
    #####: 2709:        || context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED
    #####: 2710:        || (flags & PARSER_PATTERN_REST_ELEMENT))
        -: 2711:    {
        -: 2712:      /* Found invalid pattern, push null value to fake the rhs target. */
    #####: 2713:      parser_emit_cbc (context_p, CBC_PUSH_NULL);
        -: 2714:    }
        -: 2715:    else
        -: 2716:    {
    #####: 2717:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER);
    #####: 2718:      scanner_get_location (&start_location, context_p);
        -: 2719:
    #####: 2720:      scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 2721:      scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####: 2722:      scanner_seek (context_p);
    #####: 2723:      lexer_next_token (context_p);
        -: 2724:
    #####: 2725:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 2726:      scanner_get_location (&(end_marker.location), context_p);
    #####: 2727:      end_marker.token = context_p->token;
        -: 2728:
    #####: 2729:      scanner_set_location (context_p, &start_location);
    #####: 2730:      scanner_seek (context_p);
    #####: 2731:      parser_flush_cbc (context_p);
        -: 2732:    }
        -: 2733:  }
        -: 2734:
    #####: 2735:  if (flags & PARSER_PATTERN_TARGET_DEFAULT)
        -: 2736:  {
    #####: 2737:    parser_set_branch_to_current_position (context_p, &skip_init);
        -: 2738:  }
        -: 2739:
    #####: 2740:  return end_marker;
        -: 2741:} /* parser_pattern_get_target */
        -: 2742:
        -: 2743:/**
        -: 2744: * Finalize an assignment/binding pattern.
        -: 2745: */
        -: 2746:static void
    #####: 2747:parser_pattern_finalize (parser_context_t *context_p, /**< context */
        -: 2748:                         parser_pattern_flags_t flags, /**< flags */
        -: 2749:                         parser_pattern_end_marker_t *end_marker_p) /**< pattern end position  */
        -: 2750:{
    #####: 2751:  if ((flags & (PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_TARGET_DEFAULT)) != PARSER_PATTERN_TARGET_ON_STACK)
        -: 2752:  {
    #####: 2753:    if (end_marker_p->token.type == LEXER_INVALID_PATTERN)
        -: 2754:    {
    #####: 2755:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 2756:    }
        -: 2757:
    #####: 2758:    scanner_set_location (context_p, &(end_marker_p->location));
    #####: 2759:    context_p->token = end_marker_p->token;
        -: 2760:  }
        -: 2761:  else
        -: 2762:  {
    #####: 2763:    JERRY_ASSERT (!(flags & PARSER_PATTERN_TARGET_DEFAULT));
    #####: 2764:    lexer_next_token (context_p);
        -: 2765:  }
        -: 2766:
    #####: 2767:  if ((flags & (PARSER_PATTERN_BINDING | PARSER_PATTERN_NESTED_PATTERN)) == PARSER_PATTERN_BINDING)
        -: 2768:  {
        -: 2769:    /* Pop the result of the expression. */
    #####: 2770:    parser_emit_cbc (context_p, CBC_POP);
        -: 2771:  }
        -: 2772:
    #####: 2773:  parser_flush_cbc (context_p);
    #####: 2774:} /* parser_pattern_finalize */
        -: 2775:
        -: 2776:/**
        -: 2777: * Emit right-hand-side target value.
        -: 2778: */
        -: 2779:static void
    #####: 2780:parser_pattern_emit_rhs (parser_context_t *context_p, /**< context */
        -: 2781:                         uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 2782:                         uint16_t literal_index) /**< literal index for object pattern */
        -: 2783:{
    #####: 2784:  if (literal_index != PARSER_PATTERN_RHS_NO_LIT)
        -: 2785:  {
    #####: 2786:    parser_emit_cbc_ext_literal (context_p, rhs_opcode, literal_index);
        -: 2787:  }
        -: 2788:  else
        -: 2789:  {
    #####: 2790:    parser_emit_cbc_ext (context_p, rhs_opcode);
        -: 2791:  }
    #####: 2792:} /* parser_pattern_emit_rhs */
        -: 2793:
        -: 2794:/**
        -: 2795: * Form an assignment from a pattern.
        -: 2796: */
        -: 2797:static void
    #####: 2798:parser_pattern_form_assignment (parser_context_t *context_p, /**< context */
        -: 2799:                                parser_pattern_flags_t flags, /**< flags */
        -: 2800:                                uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 2801:                                uint16_t literal_index, /**< literal index for object pattern */
        -: 2802:                                parser_line_counter_t ident_line_counter) /**< identifier line counter */
        -: 2803:{
        -: 2804:  JERRY_UNUSED (ident_line_counter);
        -: 2805:
    #####: 2806:  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);
    #####: 2807:  uint8_t assign_opcode = parser_append_binary_single_assignment_token (context_p, flags);
        -: 2808:
    #####: 2809:  if (flags & PARSER_PATTERN_ARRAY)
        -: 2810:  {
    #####: 2811:    int32_t stack_adjustment = (CBC_STACK_ADJUST_BASE - (cbc_flags[assign_opcode] >> CBC_STACK_ADJUST_SHIFT));
    #####: 2812:    JERRY_ASSERT (stack_adjustment >= 1 && stack_adjustment <= 3);
        -: 2813:
    #####: 2814:    rhs_opcode = (uint16_t) (rhs_opcode + stack_adjustment - 1);
        -: 2815:  }
        -: 2816:
    #####: 2817:  parser_pattern_emit_rhs (context_p, rhs_opcode, literal_index);
        -: 2818:
    #####: 2819:  if (context_p->token.type == LEXER_ASSIGN)
        -: 2820:  {
    #####: 2821:    parser_branch_t skip_init;
    #####: 2822:    lexer_next_token (context_p);
    #####: 2823:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 2824:
    #####: 2825:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 2826:    parser_set_branch_to_current_position (context_p, &skip_init);
        -: 2827:  }
        -: 2828:
    #####: 2829:  parser_process_binary_opcodes (context_p, 0);
        -: 2830:
    #####: 2831:  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);
    #####: 2832:  parser_stack_pop_uint8 (context_p);
        -: 2833:
        -: 2834:#if ENABLED (JERRY_DEBUGGER)
        -: 2835:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2836:      && ident_line_counter != context_p->last_breakpoint_line)
        -: 2837:  {
        -: 2838:    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -: 2839:    parser_flush_cbc (context_p);
        -: 2840:
        -: 2841:    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, ident_line_counter);
        -: 2842:
        -: 2843:    context_p->last_breakpoint_line = ident_line_counter;
        -: 2844:  }
        -: 2845:#endif /* ENABLED (JERRY_DEBUGGER) */
        -: 2846:
        -: 2847:#if ENABLED (JERRY_LINE_INFO)
    #####: 2848:  if (ident_line_counter != context_p->last_line_info_line)
        -: 2849:  {
    #####: 2850:    parser_emit_line_info (context_p, ident_line_counter, false);
        -: 2851:  }
        -: 2852:#endif /* ENABLED (JERRY_LINE_INFO) */
    #####: 2853:} /* parser_pattern_form_assignment */
        -: 2854:
        -: 2855:/**
        -: 2856: * Parse pattern inside a pattern.
        -: 2857: */
        -: 2858:static void
    #####: 2859:parser_pattern_process_nested_pattern (parser_context_t *context_p, /**< context */
        -: 2860:                                       parser_pattern_flags_t flags, /**< flags */
        -: 2861:                                       uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 2862:                                       uint16_t literal_index) /**< literal index for object pattern */
        -: 2863:{
    #####: 2864:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_BRACE || context_p->token.type == LEXER_LEFT_SQUARE);
        -: 2865:
    #####: 2866:  parser_pattern_flags_t options = (PARSER_PATTERN_NESTED_PATTERN
        -: 2867:                                    | PARSER_PATTERN_TARGET_ON_STACK
    #####: 2868:                                    | (flags & (PARSER_PATTERN_BINDING
        -: 2869:                                                | PARSER_PATTERN_LET
        -: 2870:                                                | PARSER_PATTERN_CONST
        -: 2871:                                                | PARSER_PATTERN_LOCAL
        -: 2872:                                                | PARSER_PATTERN_REST_ELEMENT
        -: 2873:                                                | PARSER_PATTERN_ARGUMENTS)));
        -: 2874:
    #####: 2875:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2876:  {
    #####: 2877:    options |= PARSER_PATTERN_TARGET_DEFAULT;
        -: 2878:  }
        -: 2879:
    #####: 2880:  parser_pattern_emit_rhs (context_p, rhs_opcode, literal_index);
        -: 2881:
    #####: 2882:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2883:  {
    #####: 2884:    parser_parse_object_initializer (context_p, options);
        -: 2885:  }
        -: 2886:  else
        -: 2887:  {
    #####: 2888:    parser_parse_array_initializer (context_p, options);
        -: 2889:  }
        -: 2890:
    #####: 2891:  parser_emit_cbc (context_p, CBC_POP);
    #####: 2892:} /* parser_pattern_process_nested_pattern */
        -: 2893:
        -: 2894:/**
        -: 2895: * Process the current {Binding, Assignment}Property
        -: 2896: */
        -: 2897:static void
    #####: 2898:parser_pattern_process_assignment (parser_context_t *context_p, /**< context */
        -: 2899:                                   parser_pattern_flags_t flags, /**< flags */
        -: 2900:                                   uint16_t rhs_opcode, /**< opcode to process the rhs value */
        -: 2901:                                   uint16_t literal_index, /**< literal index for object pattern */
        -: 2902:                                   lexer_token_type_t end_type) /**< end type token */
        -: 2903:{
    #####: 2904:  if (context_p->token.type == LEXER_LEFT_BRACE || context_p->token.type == LEXER_LEFT_SQUARE)
        -: 2905:  {
    #####: 2906:    parser_pattern_process_nested_pattern (context_p, flags, rhs_opcode, literal_index);
    #####: 2907:    return;
        -: 2908:  }
        -: 2909:
    #####: 2910:  parser_line_counter_t ident_line_counter = context_p->token.line;
        -: 2911:
    #####: 2912:  if (flags & PARSER_PATTERN_BINDING)
        -: 2913:  {
    #####: 2914:    if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2915:    {
    #####: 2916:      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 2917:    }
        -: 2918:
    #####: 2919:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 2920:
    #####: 2921:    if (flags & (PARSER_PATTERN_LET | PARSER_PATTERN_CONST)
    #####: 2922:        && context_p->token.keyword_type == LEXER_KEYW_LET)
        -: 2923:    {
    #####: 2924:      parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);
        -: 2925:    }
        -: 2926:
    #####: 2927:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2928:    {
    #####: 2929:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 2930:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 2931:    }
        -: 2932:
    #####: 2933:    if (flags & PARSER_PATTERN_ARGUMENTS)
        -: 2934:    {
    #####: 2935:      if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)
        -: 2936:      {
    #####: 2937:        parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 2938:      }
    #####: 2939:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 2940:    }
        -: 2941:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####: 2942:    parser_module_append_export_name (context_p);
        -: 2943:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 2944:
    #####: 2945:    parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
    #####: 2946:    lexer_next_token (context_p);
        -: 2947:
    #####: 2948:    if (context_p->token.type != end_type
    #####: 2949:        && context_p->token.type != LEXER_ASSIGN
    #####: 2950:        && context_p->token.type != LEXER_COMMA)
        -: 2951:    {
    #####: 2952:      parser_raise_error (context_p, PARSER_ERR_ILLEGAL_PROPERTY_IN_DECLARATION);
        -: 2953:    }
        -: 2954:  }
        -: 2955:  else
        -: 2956:  {
    #####: 2957:    parser_flush_cbc (context_p);
    #####: 2958:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA | PARSE_EXPR_LEFT_HAND_SIDE);
        -: 2959:
    #####: 2960:    if (!PARSER_IS_PUSH_LITERAL (context_p->last_cbc_opcode) && !PARSER_IS_PUSH_PROP (context_p->last_cbc_opcode))
        -: 2961:    {
    #####: 2962:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 2963:    }
        -: 2964:  }
        -: 2965:
    #####: 2966:  parser_pattern_form_assignment (context_p, flags, rhs_opcode, literal_index, ident_line_counter);
        -: 2967:} /* parser_pattern_process_assignment */
        -: 2968:
        -: 2969:/**
        -: 2970: * Parse array initializer.
        -: 2971: */
        -: 2972:static void
    #####: 2973:parser_parse_array_initializer (parser_context_t *context_p, /**< context */
        -: 2974:                                parser_pattern_flags_t flags) /**< flags */
        -: 2975:{
    #####: 2976:  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);
    #####: 2977:  flags |= PARSER_PATTERN_ARRAY;
        -: 2978:
    #####: 2979:  lexer_next_token (context_p);
    #####: 2980:  parser_emit_cbc_ext (context_p, CBC_EXT_GET_ITERATOR);
        -: 2981:
    #####: 2982:  while (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 2983:  {
    #####: 2984:    uint16_t rhs_opcode = CBC_EXT_ITERATOR_STEP;
        -: 2985:
    #####: 2986:    if (context_p->token.type == LEXER_COMMA)
        -: 2987:    {
    #####: 2988:      parser_emit_cbc_ext (context_p, rhs_opcode);
    #####: 2989:      parser_emit_cbc (context_p, CBC_POP);
    #####: 2990:      lexer_next_token (context_p);
    #####: 2991:      continue;
        -: 2992:    }
        -: 2993:
    #####: 2994:    parser_pattern_flags_t options = flags;
        -: 2995:
    #####: 2996:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 2997:    {
    #####: 2998:      lexer_next_token (context_p);
    #####: 2999:      rhs_opcode = CBC_EXT_REST_INITIALIZER;
    #####: 3000:      options |= PARSER_PATTERN_REST_ELEMENT;
        -: 3001:    }
        -: 3002:
    #####: 3003:    parser_pattern_process_assignment (context_p, options, rhs_opcode, PARSER_PATTERN_RHS_NO_LIT, LEXER_RIGHT_SQUARE);
        -: 3004:
    #####: 3005:    if (context_p->token.type == LEXER_COMMA && rhs_opcode != CBC_EXT_REST_INITIALIZER)
        -: 3006:    {
    #####: 3007:      lexer_next_token (context_p);
        -: 3008:    }
    #####: 3009:    else if (context_p->token.type != LEXER_RIGHT_SQUARE)
        -: 3010:    {
    #####: 3011:      parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 3012:    }
        -: 3013:  }
        -: 3014:
        -: 3015:  /* close the iterator */
    #####: 3016:  parser_emit_cbc_ext (context_p, CBC_EXT_ITERATOR_CLOSE);
        -: 3017:
    #####: 3018:  parser_pattern_finalize (context_p, flags, &end_pos);
    #####: 3019:} /* parser_parse_array_initializer */
        -: 3020:
        -: 3021:/**
        -: 3022: * Parse object initializer.
        -: 3023: */
        -: 3024:static void
    #####: 3025:parser_parse_object_initializer (parser_context_t *context_p, /**< context */
        -: 3026:                                 parser_pattern_flags_t flags) /**< flags */
        -: 3027:{
    #####: 3028:  parser_pattern_end_marker_t end_pos = parser_pattern_get_target (context_p, flags);
        -: 3029:
        -: 3030:  /* 12.14.5.2:  ObjectAssignmentPattern : { } */
    #####: 3031:  if (lexer_check_next_character (context_p, LIT_CHAR_RIGHT_BRACE))
        -: 3032:  {
    #####: 3033:    parser_emit_cbc_ext (context_p, CBC_EXT_REQUIRE_OBJECT_COERCIBLE);
    #####: 3034:    lexer_consume_next_character (context_p);
    #####: 3035:    parser_pattern_finalize (context_p, flags, &end_pos);
    #####: 3036:    return;
        -: 3037:  }
        -: 3038:
        -: 3039:  while (true)
    #####: 3040:  {
    #####: 3041:    lexer_expect_object_literal_id (context_p, LEXER_OBJ_IDENT_OBJECT_PATTERN);
        -: 3042:
    #####: 3043:    uint16_t prop_index = context_p->lit_object.index;
    #####: 3044:    parser_line_counter_t start_line = context_p->token.line;
    #####: 3045:    parser_line_counter_t start_column = context_p->token.column;
    #####: 3046:    uint16_t push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_PROP_LITERAL;
        -: 3047:
    #####: 3048:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3049:    {
    #####: 3050:      break;
        -: 3051:    }
    #####: 3052:    else if (context_p->token.type == LEXER_RIGHT_SQUARE)
        -: 3053:    {
    #####: 3054:      prop_index = PARSER_PATTERN_RHS_NO_LIT;
    #####: 3055:      push_prop_opcode = CBC_EXT_INITIALIZER_PUSH_PROP;
        -: 3056:    }
        -: 3057:
    #####: 3058:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3059:    {
    #####: 3060:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####: 3061:      parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3062:    }
        -: 3063:
    #####: 3064:    lexer_next_token (context_p);
        -: 3065:
    #####: 3066:    if (context_p->token.type == LEXER_COLON)
        -: 3067:    {
    #####: 3068:      lexer_next_token (context_p);
    #####: 3069:      parser_pattern_process_assignment (context_p, flags, push_prop_opcode, prop_index, LEXER_RIGHT_BRACE);
        -: 3070:    }
        -: 3071:    else
        -: 3072:    {
    #####: 3073:      if (push_prop_opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 3074:      {
    #####: 3075:        parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 3076:      }
        -: 3077:
    #####: 3078:      if (context_p->token.type != LEXER_RIGHT_BRACE
    #####: 3079:          && context_p->token.type != LEXER_ASSIGN
    #####: 3080:          && context_p->token.type != LEXER_COMMA)
        -: 3081:      {
    #####: 3082:        parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 3083:      }
        -: 3084:
    #####: 3085:      parser_reparse_as_common_identifier (context_p, start_line, start_column);
    #####: 3086:      lexer_next_token (context_p);
        -: 3087:
    #####: 3088:      JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE
        -: 3089:                    || context_p->token.type == LEXER_ASSIGN
        -: 3090:                    || context_p->token.type == LEXER_COMMA);
        -: 3091:
    #####: 3092:      if (flags & PARSER_PATTERN_ARGUMENTS)
        -: 3093:      {
    #####: 3094:        if (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT)
        -: 3095:        {
    #####: 3096:          parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -: 3097:        }
    #####: 3098:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 3099:      }
        -: 3100:
        -: 3101:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####: 3102:      parser_module_append_export_name (context_p);
        -: 3103:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 3104:
    #####: 3105:      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
    #####: 3106:      parser_pattern_form_assignment (context_p, flags, push_prop_opcode, prop_index, start_line);
        -: 3107:    }
        -: 3108:
    #####: 3109:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3110:    {
    #####: 3111:      break;
        -: 3112:    }
    #####: 3113:    else if (context_p->token.type != LEXER_COMMA)
        -: 3114:    {
    #####: 3115:      parser_raise_error (context_p, PARSER_ERR_OBJECT_ITEM_SEPARATOR_EXPECTED);
        -: 3116:    }
        -: 3117:  }
        -: 3118:
    #####: 3119:  parser_pattern_finalize (context_p, flags, &end_pos);
        -: 3120:} /* parser_parse_object_initializer */
        -: 3121:
        -: 3122:/**
        -: 3123: * Parse an initializer.
        -: 3124: */
        -: 3125:void
    #####: 3126:parser_parse_initializer (parser_context_t *context_p, /**< context */
        -: 3127:                          parser_pattern_flags_t flags) /**< flags */
        -: 3128:{
    #####: 3129:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 3130:  {
    #####: 3131:    parser_parse_object_initializer (context_p, flags);
        -: 3132:  }
        -: 3133:  else
        -: 3134:  {
    #####: 3135:    JERRY_ASSERT (context_p->token.type == LEXER_LEFT_SQUARE);
    #####: 3136:    parser_parse_array_initializer (context_p, flags);
        -: 3137:  }
    #####: 3138:} /* parser_parse_initializer */
        -: 3139:
        -: 3140:/**
        -: 3141: * Parse an initializer using the next character.
        -: 3142: */
        -: 3143:void
    #####: 3144:parser_parse_initializer_by_next_char (parser_context_t *context_p, /**< context */
        -: 3145:                                       parser_pattern_flags_t flags) /**< flags */
        -: 3146:{
    #####: 3147:  JERRY_ASSERT (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE));
        -: 3148:
    #####: 3149:  if (lexer_consume_next_character (context_p) == LIT_CHAR_LEFT_BRACE)
        -: 3150:  {
    #####: 3151:    parser_parse_object_initializer (context_p, flags);
        -: 3152:  }
        -: 3153:  else
        -: 3154:  {
    #####: 3155:    parser_parse_array_initializer (context_p, flags);
        -: 3156:  }
    #####: 3157:} /* parser_parse_initializer_by_next_char */
        -: 3158:
        -: 3159:#endif /* ENABLED (JERRY_ES2015) */
        -: 3160:
        -: 3161:/**
        -: 3162: * Process ternary expression.
        -: 3163: *
        -: 3164: * @return true - continue with primary expression parsing
        -: 3165: *         false - otherwise
        -: 3166: */
        -: 3167:static bool
    #####: 3168:parser_process_ternary_expression (parser_context_t *context_p, /**< context */
        -: 3169:                                   size_t grouping_level) /**< grouping level */
        -: 3170:{
    #####: 3171:  JERRY_ASSERT (context_p->token.type == LEXER_QUESTION_MARK);
        -: 3172:
    #####: 3173:  cbc_opcode_t opcode = CBC_BRANCH_IF_FALSE_FORWARD;
    #####: 3174:  parser_branch_t cond_branch;
    #####: 3175:  parser_branch_t uncond_branch;
        -: 3176:
    #####: 3177:  parser_push_result (context_p);
        -: 3178:
    #####: 3179:  if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -: 3180:  {
    #####: 3181:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 3182:    opcode = CBC_BRANCH_IF_TRUE_FORWARD;
        -: 3183:  }
        -: 3184:
    #####: 3185:  parser_emit_cbc_forward_branch (context_p, (uint16_t) opcode, &cond_branch);
        -: 3186:
    #####: 3187:  lexer_next_token (context_p);
    #####: 3188:  parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 3189:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &uncond_branch);
    #####: 3190:  parser_set_branch_to_current_position (context_p, &cond_branch);
        -: 3191:
        -: 3192:  /* Although byte code is constructed for two branches,
        -: 3193:   * only one of them will be executed. To reflect this
        -: 3194:   * the stack is manually adjusted. */
    #####: 3195:  JERRY_ASSERT (context_p->stack_depth > 0);
    #####: 3196:  context_p->stack_depth--;
        -: 3197:
    #####: 3198:  if (context_p->token.type != LEXER_COLON)
        -: 3199:  {
    #####: 3200:    parser_raise_error (context_p, PARSER_ERR_COLON_FOR_CONDITIONAL_EXPECTED);
        -: 3201:  }
        -: 3202:
    #####: 3203:  lexer_next_token (context_p);
        -: 3204:
    #####: 3205:  parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
    #####: 3206:  parser_set_branch_to_current_position (context_p, &uncond_branch);
        -: 3207:
        -: 3208:  /* Last opcode rewrite is not allowed because
        -: 3209:   * the result may come from the first branch. */
    #####: 3210:  parser_flush_cbc (context_p);
        -: 3211:
    #####: 3212:  parser_process_binary_opcodes (context_p, 0);
    #####: 3213:  return grouping_level >= PARSER_GROUPING_LEVEL_INCREASE;
        -: 3214:} /* parser_process_ternary_expression */
        -: 3215:
        -: 3216:/**
        -: 3217: * Process expression sequence.
        -: 3218: */
        -: 3219:static void
    #####: 3220:parser_process_expression_sequence (parser_context_t *context_p) /**< context */
        -: 3221:{
    #####: 3222:  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 3223:  {
    #####: 3224:    parser_emit_cbc (context_p, CBC_POP);
        -: 3225:  }
        -: 3226:
    #####: 3227:  if (context_p->stack_top_uint8 == LEXER_LEFT_PAREN)
        -: 3228:  {
    #####: 3229:    parser_mem_page_t *page_p = context_p->stack.first_p;
        -: 3230:
    #####: 3231:    JERRY_ASSERT (page_p != NULL);
        -: 3232:
    #####: 3233:    page_p->bytes[context_p->stack.last_position - 1] = LEXER_COMMA_SEP_LIST;
    #####: 3234:    context_p->stack_top_uint8 = LEXER_COMMA_SEP_LIST;
        -: 3235:  }
        -: 3236:
    #####: 3237:  lexer_next_token (context_p);
    #####: 3238:} /* parser_process_expression_sequence */
        -: 3239:
        -: 3240:/**
        -: 3241: * Process group expression.
        -: 3242: */
        -: 3243:static void
    #####: 3244:parser_process_group_expression (parser_context_t *context_p, /**< context */
        -: 3245:                                 size_t *grouping_level_p) /**< grouping level */
        -: 3246:{
    #####: 3247:  JERRY_ASSERT (*grouping_level_p >= PARSER_GROUPING_LEVEL_INCREASE);
    #####: 3248:  (*grouping_level_p) -= PARSER_GROUPING_LEVEL_INCREASE;
        -: 3249:
    #####: 3250:  if (context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST)
        -: 3251:  {
    #####: 3252:    parser_push_result (context_p);
    #####: 3253:    parser_flush_cbc (context_p);
        -: 3254:  }
        -: 3255:
    #####: 3256:  parser_stack_pop_uint8 (context_p);
    #####: 3257:  lexer_next_token (context_p);
    #####: 3258:} /* parser_process_group_expression */
        -: 3259:
        -: 3260:/**
        -: 3261: * Parse block expression.
        -: 3262: */
        -: 3263:void
        1: 3264:parser_parse_block_expression (parser_context_t *context_p, /**< context */
        -: 3265:                               int options) /**< option flags */
        -: 3266:{
        1: 3267:  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);
        -: 3268:
        1: 3269:  if (CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 3270:  {
        1: 3271:    JERRY_ASSERT (CBC_SAME_ARGS (context_p->last_cbc_opcode, context_p->last_cbc_opcode + 2));
        1: 3272:    PARSER_PLUS_EQUAL_U16 (context_p->last_cbc_opcode, 2);
        1: 3273:    parser_flush_cbc (context_p);
        -: 3274:  }
        -: 3275:  else
        -: 3276:  {
    #####: 3277:    parser_emit_cbc (context_p, CBC_POP_BLOCK);
        -: 3278:  }
        1: 3279:} /* parser_parse_block_expression */
        -: 3280:
        -: 3281:/**
        -: 3282: * Parse expression statement.
        -: 3283: */
        -: 3284:void
        3: 3285:parser_parse_expression_statement (parser_context_t *context_p, /**< context */
        -: 3286:                                   int options) /**< option flags */
        -: 3287:{
        3: 3288:  parser_parse_expression (context_p, options | PARSE_EXPR_NO_PUSH_RESULT);
        -: 3289:
        3: 3290:  if (!CBC_NO_RESULT_OPERATION (context_p->last_cbc_opcode))
        -: 3291:  {
    #####: 3292:    parser_emit_cbc (context_p, CBC_POP);
        -: 3293:  }
        3: 3294:} /* parser_parse_expression_statement */
        -: 3295:
        -: 3296:JERRY_STATIC_ASSERT (PARSE_EXPR_LEFT_HAND_SIDE == 0x1,
        -: 3297:                     value_of_parse_expr_left_hand_side_must_be_1);
        -: 3298:
        -: 3299:/**
        -: 3300: * Parse expression.
        -: 3301: */
        -: 3302:void
       27: 3303:parser_parse_expression (parser_context_t *context_p, /**< context */
        -: 3304:                         int options) /**< option flags */
        -: 3305:{
       27: 3306:  size_t grouping_level = (options & PARSE_EXPR_LEFT_HAND_SIDE);
        -: 3307:
       27: 3308:  parser_stack_push_uint8 (context_p, LEXER_EXPRESSION_START);
        -: 3309:
       27: 3310:  if (options & PARSE_EXPR_HAS_LITERAL)
        -: 3311:  {
    #####: 3312:    JERRY_ASSERT (context_p->last_cbc_opcode == CBC_PUSH_LITERAL);
    #####: 3313:    goto process_unary_expression;
        -: 3314:  }
        -: 3315:
        -: 3316:  while (true)
        -: 3317:  {
       37: 3318:    if (parser_parse_unary_expression (context_p, &grouping_level))
        -: 3319:    {
    #####: 3320:      parser_process_binary_opcodes (context_p, 0);
    #####: 3321:      break;
        -: 3322:    }
        -: 3323:
        -: 3324:    while (true)
        -: 3325:    {
       32: 3326:process_unary_expression:
       32: 3327:      parser_process_unary_expression (context_p, grouping_level);
        -: 3328:
       32: 3329:      if (JERRY_LIKELY (grouping_level != PARSE_EXPR_LEFT_HAND_SIDE))
        -: 3330:      {
       32: 3331:        uint8_t min_prec_treshold = 0;
        -: 3332:
       32: 3333:        if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))
        -: 3334:        {
        5: 3335:          min_prec_treshold = parser_binary_precedence_table[context_p->token.type - LEXER_FIRST_BINARY_OP];
        -: 3336:
        -: 3337:#if ENABLED (JERRY_ES2015)
        -: 3338:          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND + LEXER_EXPONENTIATION */
        5: 3339:          if ((min_prec_treshold == PARSER_RIGHT_TO_LEFT_ORDER_EXPONENTIATION)
        5: 3340:              || (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE
        3: 3341:                  && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE))
        -: 3342:          {
        -: 3343:            /* Right-to-left evaluation order. */
        3: 3344:            min_prec_treshold++;
        -: 3345:          }
        -: 3346:#else /* !ENABLED (JERRY_ES2015) */
        -: 3347:          /* Check for BINARY_LVALUE tokens + LEXER_LOGICAL_OR + LEXER_LOGICAL_AND */
    #####: 3348:          if (min_prec_treshold <= PARSER_RIGHT_TO_LEFT_ORDER_MAX_PRECEDENCE
    #####: 3349:              && min_prec_treshold != PARSER_RIGHT_TO_LEFT_ORDER_TERNARY_PRECEDENCE)
        -: 3350:          {
        -: 3351:            /* Right-to-left evaluation order. */
    #####: 3352:            min_prec_treshold++;
        -: 3353:          }
        -: 3354:#endif /* ENABLED (JERRY_ES2015) */
        -: 3355:        }
        -: 3356:
       32: 3357:        parser_process_binary_opcodes (context_p, min_prec_treshold);
        -: 3358:      }
        -: 3359:
       32: 3360:      if (context_p->token.type == LEXER_RIGHT_PAREN
        4: 3361:          && (context_p->stack_top_uint8 == LEXER_LEFT_PAREN
        4: 3362:              || context_p->stack_top_uint8 == LEXER_COMMA_SEP_LIST))
        -: 3363:      {
    #####: 3364:        parser_process_group_expression (context_p, &grouping_level);
    #####: 3365:        continue;
        -: 3366:      }
        -: 3367:
       32: 3368:      if (JERRY_UNLIKELY (context_p->token.type == LEXER_QUESTION_MARK)
    #####: 3369:          && (grouping_level != PARSE_EXPR_LEFT_HAND_SIDE)
    #####: 3370:          && parser_process_ternary_expression (context_p, grouping_level))
        -: 3371:      {
    #####: 3372:        continue;
        -: 3373:      }
       32: 3374:      break;
        -: 3375:    }
        -: 3376:
       32: 3377:    if (grouping_level == PARSE_EXPR_LEFT_HAND_SIDE)
        -: 3378:    {
    #####: 3379:      break;
        -: 3380:    }
        -: 3381:
       32: 3382:    if (JERRY_UNLIKELY (context_p->token.type == LEXER_COMMA)
        4: 3383:        && (!(options & PARSE_EXPR_NO_COMMA) || grouping_level >= PARSER_GROUPING_LEVEL_INCREASE))
        -: 3384:    {
    #####: 3385:      parser_process_expression_sequence (context_p);
    #####: 3386:      continue;
        -: 3387:    }
        -: 3388:
       32: 3389:    if (LEXER_IS_BINARY_OP_TOKEN (context_p->token.type))
        -: 3390:    {
        5: 3391:      parser_append_binary_token (context_p);
        5: 3392:      lexer_next_token (context_p);
        5: 3393:      continue;
        -: 3394:    }
       27: 3395:    break;
        -: 3396:  }
        -: 3397:
       27: 3398:  if (grouping_level >= PARSER_GROUPING_LEVEL_INCREASE)
        -: 3399:  {
    #####: 3400:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 3401:  }
        -: 3402:
       27: 3403:  JERRY_ASSERT (context_p->stack_top_uint8 == LEXER_EXPRESSION_START);
       27: 3404:  parser_stack_pop_uint8 (context_p);
        -: 3405:
       27: 3406:  if (!(options & PARSE_EXPR_NO_PUSH_RESULT))
        -: 3407:  {
       23: 3408:    parser_push_result (context_p);
        -: 3409:  }
       27: 3410:} /* parser_parse_expression */
        -: 3411:
        -: 3412:/**
        -: 3413: * @}
        -: 3414: * @}
        -: 3415: * @}
        -: 3416: */
        -: 3417:
        -: 3418:#endif /* ENABLED (JERRY_PARSER) */
