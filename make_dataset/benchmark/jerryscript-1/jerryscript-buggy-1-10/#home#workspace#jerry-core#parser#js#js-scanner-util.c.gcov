        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner-util.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-helpers.h"
        -:   17:#include "jcontext.h"
        -:   18:#include "js-parser-internal.h"
        -:   19:#include "js-scanner-internal.h"
        -:   20:#include "lit-char-helpers.h"
        -:   21:
        -:   22:#if ENABLED (JERRY_PARSER)
        -:   23:
        -:   24:/** \addtogroup parser Parser
        -:   25: * @{
        -:   26: *
        -:   27: * \addtogroup jsparser JavaScript
        -:   28: * @{
        -:   29: *
        -:   30: * \addtogroup jsparser_scanner Scanner
        -:   31: * @{
        -:   32: */
        -:   33:
        -:   34:JERRY_STATIC_ASSERT (PARSER_MAXIMUM_NUMBER_OF_LITERALS + PARSER_MAXIMUM_NUMBER_OF_REGISTERS < PARSER_REGISTER_START,
        -:   35:                     maximum_number_of_literals_plus_registers_must_be_less_than_register_start);
        -:   36:
        -:   37:#if ENABLED (JERRY_ES2015)
        -:   38:
        -:   39:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG & SCANNER_LITERAL_IS_LOCAL) == 0,
        -:   40:                     is_arrow_arg_binding_flag_must_not_use_local_flags);
        -:   41:
        -:   42:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_LET & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   43:                     is_let_flag_must_use_local_flags);
        -:   44:
        -:   45:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_CONST & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   46:                     is_const_flag_must_use_local_flags);
        -:   47:
        -:   48:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_FUNC_DECLARATION & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   49:                     is_func_declaration_flag_must_use_local_flags);
        -:   50:
        -:   51:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_DESTRUCTURED_ARG & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   52:                     is_arg_binding_flag_must_use_local_flags);
        -:   53:
        -:   54:JERRY_STATIC_ASSERT (SCANNER_LITERAL_IS_FUNC_DECLARATION != SCANNER_LITERAL_IS_DESTRUCTURED_ARG,
        -:   55:                     is_func_declaration_must_be_different_from_is_arg_binding);
        -:   56:
        -:   57:JERRY_STATIC_ASSERT (PARSER_SCOPE_STACK_IS_CONST_REG == PARSER_SCOPE_STACK_IS_LOCAL_CREATED,
        -:   58:                     scope_stack_is_const_reg_and_scope_stack_is_local_created_must_be_the_same);
        -:   59:
        -:   60:#endif /* ENABLED (JERRY_ES2015) */
        -:   61:
        -:   62:/**
        -:   63: * Raise a scanner error.
        -:   64: */
        -:   65:void
     1297:   66:scanner_raise_error (parser_context_t *context_p) /**< context */
        -:   67:{
     1297:   68:  PARSER_THROW (context_p->try_buffer);
        -:   69:  /* Should never been reached. */
        -:   70:  JERRY_ASSERT (0);
        -:   71:} /* scanner_raise_error */
        -:   72:
        -:   73:#if ENABLED (JERRY_ES2015)
        -:   74:
        -:   75:/**
        -:   76: * Raise a variable redeclaration error.
        -:   77: */
        -:   78:void
    #####:   79:scanner_raise_redeclaration_error (parser_context_t *context_p) /**< context */
        -:   80:{
    #####:   81:  scanner_info_t *info_p = scanner_insert_info (context_p, context_p->source_p, sizeof (scanner_info_t));
    #####:   82:  info_p->type = SCANNER_TYPE_ERR_REDECLARED;
        -:   83:
    #####:   84:  scanner_raise_error (context_p);
    #####:   85:} /* scanner_raise_redeclaration_error */
        -:   86:
        -:   87:#endif /* ENABLED (JERRY_ES2015) */
        -:   88:
        -:   89:/**
        -:   90: * Allocate memory for scanner.
        -:   91: *
        -:   92: * @return allocated memory
        -:   93: */
        -:   94:void *
     2625:   95:scanner_malloc (parser_context_t *context_p, /**< context */
        -:   96:                size_t size) /**< size of the memory block */
        -:   97:{
        -:   98:  void *result;
        -:   99:
     2625:  100:  JERRY_ASSERT (size > 0);
     2625:  101:  result = jmem_heap_alloc_block_null_on_error (size);
        -:  102:
     2625:  103:  if (result == NULL)
        -:  104:  {
        1:  105:    scanner_cleanup (context_p);
        -:  106:
        -:  107:    /* This is the only error which specify its reason. */
        1:  108:    context_p->error = PARSER_ERR_OUT_OF_MEMORY;
        1:  109:    PARSER_THROW (context_p->try_buffer);
        -:  110:  }
     2624:  111:  return result;
        -:  112:} /* scanner_malloc */
        -:  113:
        -:  114:/**
        -:  115: * Free memory allocated by scanner_malloc.
        -:  116: */
        -:  117:inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  118:scanner_free (void *ptr, /**< pointer to free */
        -:  119:              size_t size) /**< size of the memory block */
        -:  120:{
     1312:  121:  jmem_heap_free_block (ptr, size);
    #####:  122:} /* scanner_free */
        -:  123:
        -:  124:/**
        -:  125: * Count the size of a stream after an info block.
        -:  126: *
        -:  127: * @return the size in bytes
        -:  128: */
        -:  129:size_t
    #####:  130:scanner_get_stream_size (scanner_info_t *info_p, /**< scanner info block */
        -:  131:                         size_t size) /**< size excluding the stream */
        -:  132:{
    #####:  133:  const uint8_t *data_p = ((const uint8_t *) info_p) + size;
    #####:  134:  const uint8_t *data_p_start = data_p;
        -:  135:
    #####:  136:  while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -:  137:  {
    #####:  138:    switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)
        -:  139:    {
    #####:  140:      case SCANNER_STREAM_TYPE_VAR:
        -:  141:#if ENABLED (JERRY_ES2015)
        -:  142:      case SCANNER_STREAM_TYPE_LET:
        -:  143:      case SCANNER_STREAM_TYPE_CONST:
        -:  144:      case SCANNER_STREAM_TYPE_LOCAL:
        -:  145:#endif /* ENABLED (JERRY_ES2015) */
        -:  146:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
        -:  147:      case SCANNER_STREAM_TYPE_IMPORT:
        -:  148:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  149:      case SCANNER_STREAM_TYPE_ARG:
        -:  150:#if ENABLED (JERRY_ES2015)
        -:  151:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -:  152:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  153:      case SCANNER_STREAM_TYPE_ARG_FUNC:
        -:  154:#if ENABLED (JERRY_ES2015)
        -:  155:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -:  156:#endif /* ENABLED (JERRY_ES2015) */
        -:  157:      case SCANNER_STREAM_TYPE_FUNC:
        -:  158:      {
    #####:  159:        break;
        -:  160:      }
    #####:  161:      default:
        -:  162:      {
    #####:  163:        JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE);
    #####:  164:        data_p++;
    #####:  165:        continue;
        -:  166:      }
        -:  167:    }
        -:  168:
    #####:  169:    data_p += 3;
        -:  170:
    #####:  171:    if (data_p[-3] & SCANNER_STREAM_UINT16_DIFF)
        -:  172:    {
    #####:  173:      data_p++;
        -:  174:    }
    #####:  175:    else if (data_p[-1] == 0)
        -:  176:    {
    #####:  177:      data_p += sizeof (const uint8_t *);
        -:  178:    }
        -:  179:  }
        -:  180:
    #####:  181:  return size + 1 + (size_t) (data_p - data_p_start);
        -:  182:} /* scanner_get_stream_size */
        -:  183:
        -:  184:/**
        -:  185: * Insert a scanner info block into the scanner info chain.
        -:  186: *
        -:  187: * @return newly allocated scanner info
        -:  188: */
        -:  189:scanner_info_t *
     1312:  190:scanner_insert_info (parser_context_t *context_p, /**< context */
        -:  191:                     const uint8_t *source_p, /**< triggering position */
        -:  192:                     size_t size) /**< size of the memory block */
        -:  193:{
     1312:  194:  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);
     1312:  195:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
     1312:  196:  scanner_info_t *prev_scanner_info_p = NULL;
        -:  197:
     1312:  198:  JERRY_ASSERT (scanner_info_p != NULL);
     1312:  199:  JERRY_ASSERT (source_p != NULL);
        -:  200:
     1312:  201:  new_scanner_info_p->source_p = source_p;
        -:  202:
     2630:  203:  while (source_p < scanner_info_p->source_p)
        -:  204:  {
        6:  205:    prev_scanner_info_p = scanner_info_p;
        6:  206:    scanner_info_p = scanner_info_p->next_p;
        -:  207:
        6:  208:    JERRY_ASSERT (scanner_info_p != NULL);
        -:  209:  }
        -:  210:
        -:  211:  /* Multiple scanner info blocks cannot be assigned to the same position. */
     1312:  212:  JERRY_ASSERT (source_p != scanner_info_p->source_p);
        -:  213:
     1312:  214:  new_scanner_info_p->next_p = scanner_info_p;
        -:  215:
     1312:  216:  if (JERRY_LIKELY (prev_scanner_info_p == NULL))
        -:  217:  {
     1309:  218:    context_p->next_scanner_info_p = new_scanner_info_p;
        -:  219:  }
        -:  220:  else
        -:  221:  {
        3:  222:    prev_scanner_info_p->next_p = new_scanner_info_p;
        -:  223:  }
        -:  224:
     1312:  225:  return new_scanner_info_p;
        -:  226:} /* scanner_insert_info */
        -:  227:
        -:  228:/**
        -:  229: * Insert a scanner info block into the scanner info chain before a given info block.
        -:  230: *
        -:  231: * @return newly allocated scanner info
        -:  232: */
        -:  233:scanner_info_t *
    #####:  234:scanner_insert_info_before (parser_context_t *context_p, /**< context */
        -:  235:                            const uint8_t *source_p, /**< triggering position */
        -:  236:                            scanner_info_t *start_info_p, /**< first info position */
        -:  237:                            size_t size) /**< size of the memory block */
        -:  238:{
    #####:  239:  JERRY_ASSERT (start_info_p != NULL);
        -:  240:
    #####:  241:  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);
    #####:  242:  scanner_info_t *scanner_info_p = start_info_p->next_p;
    #####:  243:  scanner_info_t *prev_scanner_info_p = start_info_p;
        -:  244:
    #####:  245:  new_scanner_info_p->source_p = source_p;
        -:  246:
    #####:  247:  while (source_p < scanner_info_p->source_p)
        -:  248:  {
    #####:  249:    prev_scanner_info_p = scanner_info_p;
    #####:  250:    scanner_info_p = scanner_info_p->next_p;
        -:  251:
    #####:  252:    JERRY_ASSERT (scanner_info_p != NULL);
        -:  253:  }
        -:  254:
        -:  255:  /* Multiple scanner info blocks cannot be assigned to the same position. */
    #####:  256:  JERRY_ASSERT (source_p != scanner_info_p->source_p);
        -:  257:
    #####:  258:  new_scanner_info_p->next_p = scanner_info_p;
        -:  259:
    #####:  260:  prev_scanner_info_p->next_p = new_scanner_info_p;
    #####:  261:  return new_scanner_info_p;
        -:  262:} /* scanner_insert_info_before */
        -:  263:
        -:  264:/**
        -:  265: * Release the next scanner info.
        -:  266: */
        -:  267:inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  268:scanner_release_next (parser_context_t *context_p, /**< context */
        -:  269:                      size_t size) /**< size of the memory block */
        -:  270:{
     1301:  271:  scanner_info_t *next_p = context_p->next_scanner_info_p->next_p;
        -:  272:
     1301:  273:  jmem_heap_free_block (context_p->next_scanner_info_p, size);
     1301:  274:  context_p->next_scanner_info_p = next_p;
    #####:  275:} /* scanner_release_next */
        -:  276:
        -:  277:/**
        -:  278: * Set the active scanner info to the next scanner info.
        -:  279: */
        -:  280:inline void JERRY_ATTR_ALWAYS_INLINE
        1:  281:scanner_set_active (parser_context_t *context_p) /**< context */
        -:  282:{
        1:  283:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -:  284:
        1:  285:  context_p->next_scanner_info_p = scanner_info_p->next_p;
        1:  286:  scanner_info_p->next_p = context_p->active_scanner_info_p;
        1:  287:  context_p->active_scanner_info_p = scanner_info_p;
        1:  288:} /* scanner_set_active */
        -:  289:
        -:  290:/**
        -:  291: * Set the next scanner info to the active scanner info.
        -:  292: */
        -:  293:inline void JERRY_ATTR_ALWAYS_INLINE
        1:  294:scanner_revert_active (parser_context_t *context_p) /**< context */
        -:  295:{
        1:  296:  scanner_info_t *scanner_info_p = context_p->active_scanner_info_p;
        -:  297:
        1:  298:  context_p->active_scanner_info_p = scanner_info_p->next_p;
        1:  299:  scanner_info_p->next_p = context_p->next_scanner_info_p;
        1:  300:  context_p->next_scanner_info_p = scanner_info_p;
        1:  301:} /* scanner_revert_active */
        -:  302:
        -:  303:/**
        -:  304: * Release the active scanner info.
        -:  305: */
        -:  306:inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  307:scanner_release_active (parser_context_t *context_p, /**< context */
        -:  308:                        size_t size) /**< size of the memory block */
        -:  309:{
    #####:  310:  scanner_info_t *next_p = context_p->active_scanner_info_p->next_p;
        -:  311:
    #####:  312:  jmem_heap_free_block (context_p->active_scanner_info_p, size);
    #####:  313:  context_p->active_scanner_info_p = next_p;
    #####:  314:} /* scanner_release_active */
        -:  315:
        -:  316:/**
        -:  317: * Release switch cases.
        -:  318: */
        -:  319:void
    #####:  320:scanner_release_switch_cases (scanner_case_info_t *case_p) /**< case list */
        -:  321:{
    #####:  322:  while (case_p != NULL)
        -:  323:  {
    #####:  324:    scanner_case_info_t *next_p = case_p->next_p;
        -:  325:
    #####:  326:    jmem_heap_free_block (case_p, sizeof (scanner_case_info_t));
    #####:  327:    case_p = next_p;
        -:  328:  }
    #####:  329:} /* scanner_release_switch_cases */
        -:  330:
        -:  331:/**
        -:  332: * Seek to correct position in the scanner info list.
        -:  333: */
        -:  334:void
    #####:  335:scanner_seek (parser_context_t *context_p) /**< context */
        -:  336:{
    #####:  337:  const uint8_t *source_p = context_p->source_p;
        -:  338:  scanner_info_t *prev_p;
        -:  339:
    #####:  340:  if (context_p->skipped_scanner_info_p != NULL)
        -:  341:  {
    #####:  342:    JERRY_ASSERT (context_p->skipped_scanner_info_p->source_p != NULL);
        -:  343:
    #####:  344:    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;
        -:  345:
    #####:  346:    if (context_p->skipped_scanner_info_end_p->source_p <= source_p)
        -:  347:    {
    #####:  348:      prev_p = context_p->skipped_scanner_info_end_p;
        -:  349:    }
        -:  350:    else
        -:  351:    {
    #####:  352:      prev_p = context_p->skipped_scanner_info_p;
        -:  353:
    #####:  354:      if (prev_p->source_p > source_p)
        -:  355:      {
    #####:  356:        context_p->next_scanner_info_p = prev_p;
    #####:  357:        context_p->skipped_scanner_info_p = NULL;
    #####:  358:        return;
        -:  359:      }
        -:  360:
    #####:  361:      context_p->skipped_scanner_info_p = prev_p;
        -:  362:    }
        -:  363:  }
        -:  364:  else
        -:  365:  {
    #####:  366:    prev_p = context_p->next_scanner_info_p;
        -:  367:
    #####:  368:    if (prev_p->source_p == NULL || prev_p->source_p > source_p)
        -:  369:    {
    #####:  370:      return;
        -:  371:    }
        -:  372:
    #####:  373:    context_p->skipped_scanner_info_p = prev_p;
        -:  374:  }
        -:  375:
    #####:  376:  while (prev_p->next_p->source_p != NULL && prev_p->next_p->source_p <= source_p)
        -:  377:  {
    #####:  378:    prev_p = prev_p->next_p;
        -:  379:  }
        -:  380:
    #####:  381:  context_p->skipped_scanner_info_end_p = prev_p;
    #####:  382:  context_p->next_scanner_info_p = prev_p->next_p;
        -:  383:} /* scanner_seek */
        -:  384:
        -:  385:/**
        -:  386: * Push a new literal pool.
        -:  387: *
        -:  388: * @return the newly created literal pool
        -:  389: */
        -:  390:scanner_literal_pool_t *
     1313:  391:scanner_push_literal_pool (parser_context_t *context_p, /**< context */
        -:  392:                           scanner_context_t *scanner_context_p, /**< scanner context */
        -:  393:                           uint16_t status_flags) /**< combination of scanner_literal_pool_flags_t flags */
        -:  394:{
     1313:  395:  scanner_literal_pool_t *prev_literal_pool_p = scanner_context_p->active_literal_pool_p;
        -:  396:  scanner_literal_pool_t *literal_pool_p;
        -:  397:
     1313:  398:  literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
        -:  399:
     1312:  400:  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION))
        -:  401:  {
        1:  402:    JERRY_ASSERT (prev_literal_pool_p != NULL);
        1:  403:    status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  404:
        -:  405:#if ENABLED (JERRY_ES2015)
        1:  406:    const uint16_t copied_flags = (SCANNER_LITERAL_POOL_IN_WITH
        -:  407:                                   | SCANNER_LITERAL_POOL_GENERATOR
        -:  408:                                   | SCANNER_LITERAL_POOL_ASYNC);
        -:  409:#else /* !ENABLED (JERRY_ES2015) */
    #####:  410:    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IN_WITH;
        -:  411:#endif /* ENABLED (JERRY_ES2015) */
        -:  412:
        1:  413:    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);
        -:  414:  }
        -:  415:#if ENABLED (JERRY_ES2015)
        -:  416:  else
        -:  417:  {
     1311:  418:    context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  419:
     1311:  420:    if (status_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -:  421:    {
    #####:  422:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -:  423:    }
        -:  424:
     1311:  425:    if (status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -:  426:    {
    #####:  427:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  428:    }
        -:  429:  }
        -:  430:#endif /* ENABLED (JERRY_ES2015) */
        -:  431:
     1312:  432:  if (prev_literal_pool_p != NULL)
        -:  433:  {
        3:  434:    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IS_STRICT;
        3:  435:    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);
        -:  436:
        -:  437:    /* The logical value of these flags must be the same. */
        3:  438:    JERRY_ASSERT (!(status_flags & SCANNER_LITERAL_POOL_IS_STRICT) == !(context_p->status_flags & PARSER_IS_STRICT));
        -:  439:  }
        -:  440:
     1312:  441:  parser_list_init (&literal_pool_p->literal_pool,
        -:  442:                    sizeof (lexer_lit_location_t),
        -:  443:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
     1312:  444:  literal_pool_p->source_p = NULL;
     1312:  445:  literal_pool_p->status_flags = status_flags;
     1312:  446:  literal_pool_p->no_declarations = 0;
        -:  447:
     1312:  448:  literal_pool_p->prev_p = prev_literal_pool_p;
     1312:  449:  scanner_context_p->active_literal_pool_p = literal_pool_p;
        -:  450:
     1312:  451:  return literal_pool_p;
        -:  452:} /* scanner_push_literal_pool */
        -:  453:
        -:  454:JERRY_STATIC_ASSERT (PARSER_MAXIMUM_IDENT_LENGTH <= UINT8_MAX,
        -:  455:                     maximum_ident_length_must_fit_in_a_byte);
        -:  456:
        -:  457:/**
        -:  458: * Checks whether a literal is equal to "arguments".
        -:  459: */
        -:  460:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  461:scanner_literal_is_arguments (lexer_lit_location_t *literal_p) /**< literal */
        -:  462:{
       22:  463:  return lexer_compare_identifier_to_string (literal_p, (const uint8_t *) "arguments", 9);
        -:  464:} /* scanner_literal_is_arguments */
        -:  465:
        -:  466:/**
        -:  467: * Pop the last literal pool from the end.
        -:  468: */
        -:  469:void
     1312:  470:scanner_pop_literal_pool (parser_context_t *context_p, /**< context */
        -:  471:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:  472:{
     1312:  473:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
     1312:  474:  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
        -:  475:
     1312:  476:  if (literal_pool_p->source_p == NULL)
        -:  477:  {
    #####:  478:    JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION);
    #####:  479:    JERRY_ASSERT (literal_pool_p->literal_pool.data.first_p == NULL
        -:  480:                  && literal_pool_p->literal_pool.data.last_p == NULL);
        -:  481:
    #####:  482:    scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;
    #####:  483:    scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
    #####:  484:    return;
        -:  485:  }
        -:  486:
     1312:  487:  parser_list_iterator_t literal_iterator;
        -:  488:  lexer_lit_location_t *literal_p;
     1312:  489:  uint16_t status_flags = literal_pool_p->status_flags;
     1312:  490:  bool arguments_required = ((status_flags & (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_NO_ARGUMENTS))
        -:  491:                             == SCANNER_LITERAL_POOL_CAN_EVAL);
        -:  492:
     1312:  493:  uint8_t can_eval_types = 0;
        -:  494:#if ENABLED (JERRY_ES2015)
     1312:  495:  if (prev_literal_pool_p == NULL && !(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
        -:  496:  {
        1:  497:    can_eval_types |= SCANNER_LITERAL_IS_FUNC;
        -:  498:  }
        -:  499:#endif /* ENABLED (JERRY_ES2015) */
        -:  500:
     1312:  501:  if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && prev_literal_pool_p != NULL)
        -:  502:  {
        3:  503:    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  504:  }
        -:  505:
        -:  506:#if ENABLED (JERRY_DEBUGGER)
        -:  507:  if (scanner_context_p->status_flags & SCANNER_CONTEXT_DEBUGGER_ENABLED)
        -:  508:  {
        -:  509:    /* When debugger is enabled, identifiers are not stored in registers. However,
        -:  510:     * this does not affect 'eval' detection, so 'arguments' object is not created. */
        -:  511:    status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  512:  }
        -:  513:#endif /* ENABLED (JERRY_DEBUGGER) */
        -:  514:
     1312:  515:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -:  516:
     1312:  517:  const uint8_t *prev_source_p = literal_pool_p->source_p - 1;
     1312:  518:  size_t compressed_size = 1;
     1312:  519:  uint32_t no_declarations = literal_pool_p->no_declarations;
        -:  520:
     2660:  521:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -:  522:  {
       36:  523:    uint8_t type = literal_p->type;
        -:  524:
       36:  525:    if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK))
        -:  526:    {
    #####:  527:      continue;
        -:  528:    }
        -:  529:
       58:  530:    if (!(status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) && scanner_literal_is_arguments (literal_p))
        -:  531:    {
    #####:  532:      status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  533:
    #####:  534:      if (type & (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_LOCAL))
        -:  535:      {
    #####:  536:        arguments_required = false;
        -:  537:      }
        -:  538:      else
        -:  539:      {
    #####:  540:        literal_p->type = 0;
    #####:  541:        arguments_required = true;
    #####:  542:        continue;
        -:  543:      }
        -:  544:    }
        -:  545:
        -:  546:#if ENABLED (JERRY_ES2015)
       36:  547:    if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
       27:  548:        && (type & (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_FUNC_DECLARATION)) == SCANNER_LITERAL_IS_FUNC)
        -:  549:    {
        1:  550:      if (prev_literal_pool_p == NULL
    #####:  551:          && (context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL)
    #####:  552:          && scanner_scope_find_let_declaration (context_p, literal_p))
        -:  553:      {
    #####:  554:        literal_p->type = 0;
    #####:  555:        continue;
        -:  556:      }
        -:  557:
        1:  558:      type = (uint8_t) ((type & ~SCANNER_LITERAL_IS_FUNC) | SCANNER_LITERAL_IS_VAR);
        1:  559:      literal_p->type = type;
        -:  560:    }
        -:  561:#endif /* ENABLED (JERRY_ES2015) */
        -:  562:
       36:  563:    if ((type & SCANNER_LITERAL_IS_LOCAL)
       34:  564:        || ((type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))
       18:  565:            && (status_flags & SCANNER_LITERAL_POOL_FUNCTION)))
        -:  566:    {
       18:  567:      JERRY_ASSERT ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  568:                    || !(literal_p->type & SCANNER_LITERAL_IS_ARG));
        -:  569:
       18:  570:      if (literal_p->length == 0)
        -:  571:      {
    #####:  572:        compressed_size += 1;
    #####:  573:        continue;
        -:  574:      }
        -:  575:
       18:  576:      no_declarations++;
        -:  577:
       18:  578:      if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) || (type & can_eval_types))
        -:  579:      {
       18:  580:        type |= SCANNER_LITERAL_NO_REG;
       18:  581:        literal_p->type = type;
        -:  582:      }
        -:  583:
       18:  584:      if (type & SCANNER_LITERAL_IS_FUNC)
        -:  585:      {
        2:  586:        no_declarations++;
        -:  587:
        -:  588:#if ENABLED (JERRY_ES2015)
        2:  589:        if ((type & (SCANNER_LITERAL_IS_CONST | SCANNER_LITERAL_IS_ARG)) == SCANNER_LITERAL_IS_CONST)
        -:  590:        {
    #####:  591:          JERRY_ASSERT (type & SCANNER_LITERAL_IS_LET);
        -:  592:
        -:  593:          /* Catch parameters cannot be functions. */
    #####:  594:          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);
    #####:  595:          no_declarations--;
        -:  596:        }
        -:  597:#else /* !ENABLED (JERRY_ES2015) */
    #####:  598:        if (type & SCANNER_LITERAL_IS_LOCAL)
        -:  599:        {
        -:  600:          /* Catch parameters cannot be functions. */
    #####:  601:          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);
    #####:  602:          no_declarations--;
        -:  603:        }
        -:  604:#endif /* ENABLED (JERRY_ES2015) */
        -:  605:      }
        -:  606:
       18:  607:      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);
        -:  608:
       18:  609:      if (diff >= 1 && diff <= UINT8_MAX)
        -:  610:      {
       18:  611:        compressed_size += 2 + 1;
        -:  612:      }
    #####:  613:      else if (diff >= -UINT8_MAX && diff <= UINT16_MAX)
        -:  614:      {
    #####:  615:        compressed_size += 2 + 2;
        -:  616:      }
        -:  617:      else
        -:  618:      {
    #####:  619:        compressed_size += 2 + 1 + sizeof (const uint8_t *);
        -:  620:      }
        -:  621:
       18:  622:      prev_source_p = literal_p->char_p + literal_p->length;
        -:  623:
       18:  624:      if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  625:#if ENABLED (JERRY_ES2015)
        1:  626:          || ((type & SCANNER_LITERAL_IS_FUNC) && (status_flags & SCANNER_LITERAL_POOL_IS_STRICT))
        -:  627:#endif /* ENABLED (JERRY_ES2015) */
        1:  628:          || !(type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC)))
        -:  629:      {
       17:  630:        continue;
        -:  631:      }
        -:  632:    }
        -:  633:
       19:  634:    if (prev_literal_pool_p != NULL && literal_p->length > 0)
        -:  635:    {
        -:  636:      /* Propagate literal to upper level. */
       15:  637:      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p,
        -:  638:                                                                             prev_literal_pool_p,
        -:  639:                                                                             literal_p);
       15:  640:      uint8_t extended_type = literal_location_p->type;
        -:  641:
       15:  642:      if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || (type & SCANNER_LITERAL_NO_REG))
        -:  643:      {
        9:  644:        extended_type |= SCANNER_LITERAL_NO_REG;
        -:  645:      }
        -:  646:
        -:  647:#if ENABLED (JERRY_ES2015)
       15:  648:      extended_type |= SCANNER_LITERAL_IS_USED;
        -:  649:
       15:  650:      if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)
        -:  651:      {
        6:  652:        extended_type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  653:      }
        -:  654:
       15:  655:      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_LOCAL);
        -:  656:
       15:  657:      if ((type & SCANNER_LITERAL_IS_ARG)
       15:  658:          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_LET
       15:  659:          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_CONST)
        -:  660:      {
        -:  661:        /* Clears the SCANNER_LITERAL_IS_VAR and SCANNER_LITERAL_IS_FUNC flags
        -:  662:         * for speculative arrow parameters and local (non-var) functions. */
    #####:  663:        type = 0;
        -:  664:      }
        -:  665:#endif /* ENABLED (JERRY_ES2015) */
        -:  666:
       15:  667:      type = (uint8_t) (type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC));
       15:  668:      JERRY_ASSERT (type == 0 || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION));
        -:  669:
       15:  670:      literal_location_p->type = (uint8_t) (extended_type | type);
        -:  671:    }
        -:  672:  }
        -:  673:
     1312:  674:  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || (compressed_size > 1))
        -:  675:  {
     1312:  676:    compressed_size += sizeof (scanner_info_t);
        -:  677:
        -:  678:    scanner_info_t *info_p;
        -:  679:
     1312:  680:    if (prev_literal_pool_p != NULL || scanner_context_p->end_arguments_p == NULL)
        -:  681:    {
     1312:  682:      info_p = scanner_insert_info (context_p, literal_pool_p->source_p, compressed_size);
        -:  683:    }
        -:  684:    else
        -:  685:    {
    #####:  686:      scanner_info_t *start_info_p = scanner_context_p->end_arguments_p;
    #####:  687:      info_p = scanner_insert_info_before (context_p, literal_pool_p->source_p, start_info_p, compressed_size);
        -:  688:    }
        -:  689:
     1312:  690:    if (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        -:  691:    {
    #####:  692:      no_declarations = PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK;
        -:  693:    }
        -:  694:
     1312:  695:    uint8_t *data_p = (uint8_t *) (info_p + 1);
        -:  696:
     1312:  697:    if (status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  698:    {
     1311:  699:      info_p->type = SCANNER_TYPE_FUNCTION;
        -:  700:
     1311:  701:      uint8_t u8_arg = 0;
        -:  702:
     1311:  703:      if (arguments_required)
        -:  704:      {
        2:  705:        u8_arg |= SCANNER_FUNCTION_ARGUMENTS_NEEDED;
        -:  706:
        2:  707:        if (no_declarations < PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        -:  708:        {
        2:  709:          no_declarations++;
        -:  710:        }
        -:  711:
        -:  712:#if ENABLED (JERRY_ES2015)
        2:  713:        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT | SCANNER_LITERAL_POOL_ARGUMENTS_UNMAPPED;
        -:  714:#else /* !ENABLED (JERRY_ES2015) */
    #####:  715:        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT;
        -:  716:#endif /* ENABLED (JERRY_ES2015) */
        -:  717:
        2:  718:        if (status_flags & is_unmapped)
        -:  719:        {
        1:  720:          arguments_required = false;
        -:  721:        }
        -:  722:        else
        -:  723:        {
        1:  724:          u8_arg |= SCANNER_FUNCTION_MAPPED_ARGUMENTS;
        -:  725:        }
        -:  726:      }
        -:  727:
        -:  728:#if ENABLED (JERRY_ES2015)
     1311:  729:      if (status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -:  730:      {
    #####:  731:        u8_arg |= SCANNER_FUNCTION_ASYNC;
        -:  732:
    #####:  733:        if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)
        -:  734:        {
    #####:  735:          u8_arg |= SCANNER_FUNCTION_STATEMENT;
        -:  736:        }
        -:  737:      }
        -:  738:
     1311:  739:      if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)
        -:  740:      {
     1311:  741:        u8_arg |= SCANNER_FUNCTION_LEXICAL_ENV_NEEDED;
        -:  742:      }
        -:  743:#endif /* ENABLED (JERRY_ES2015) */
        -:  744:
     1311:  745:      info_p->u8_arg = u8_arg;
     1311:  746:      info_p->u16_arg = (uint16_t) no_declarations;
        -:  747:    }
        -:  748:    else
        -:  749:    {
        1:  750:      info_p->type = SCANNER_TYPE_BLOCK;
        -:  751:
        1:  752:      JERRY_ASSERT (prev_literal_pool_p != NULL);
        -:  753:    }
        -:  754:
     1312:  755:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
     1312:  756:    prev_source_p = literal_pool_p->source_p - 1;
     1312:  757:    no_declarations = literal_pool_p->no_declarations;
        -:  758:
     2660:  759:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -:  760:    {
       36:  761:      if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
       36:  762:          || (!(literal_p->type & SCANNER_LITERAL_IS_LOCAL)
       34:  763:              && (!(literal_p->type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))
       18:  764:                  || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION))))
        -:  765:      {
       18:  766:        continue;
        -:  767:      }
        -:  768:
       18:  769:      if (literal_p->length == 0)
        -:  770:      {
    #####:  771:        *data_p++ = SCANNER_STREAM_TYPE_HOLE;
    #####:  772:        continue;
        -:  773:      }
        -:  774:
       18:  775:      no_declarations++;
        -:  776:
       18:  777:      uint8_t type = SCANNER_STREAM_TYPE_VAR;
        -:  778:
       18:  779:      if (literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -:  780:      {
        2:  781:        no_declarations++;
        2:  782:        type = SCANNER_STREAM_TYPE_FUNC;
        -:  783:
        2:  784:        if (literal_p->type & SCANNER_LITERAL_IS_ARG)
        -:  785:        {
    #####:  786:          type = SCANNER_STREAM_TYPE_ARG_FUNC;
        -:  787:
        -:  788:#if ENABLED (JERRY_ES2015)
    #####:  789:          if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -:  790:          {
    #####:  791:            type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC;
        -:  792:          }
        -:  793:#endif /* ENABLED (JERRY_ES2015) */
        -:  794:        }
        -:  795:      }
       16:  796:      else if (literal_p->type & SCANNER_LITERAL_IS_ARG)
        -:  797:      {
        3:  798:        type = SCANNER_STREAM_TYPE_ARG;
        -:  799:
        -:  800:#if ENABLED (JERRY_ES2015)
        3:  801:        if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -:  802:        {
    #####:  803:          type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG;
        -:  804:        }
        -:  805:#endif /* ENABLED (JERRY_ES2015) */
        -:  806:      }
        -:  807:#if ENABLED (JERRY_ES2015)
       13:  808:      else if (literal_p->type & SCANNER_LITERAL_IS_LET)
        -:  809:      {
    #####:  810:        if (!(literal_p->type & SCANNER_LITERAL_IS_CONST))
        -:  811:        {
    #####:  812:          type = SCANNER_STREAM_TYPE_LET;
        -:  813:
    #####:  814:          if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))
        -:  815:          {
    #####:  816:            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  817:          }
        -:  818:        }
        -:  819:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####:  820:        else if (prev_literal_pool_p == NULL)
        -:  821:        {
    #####:  822:          type = SCANNER_STREAM_TYPE_IMPORT;
        -:  823:        }
        -:  824:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  825:        else
        -:  826:        {
    #####:  827:          type = SCANNER_STREAM_TYPE_LOCAL;
        -:  828:        }
        -:  829:      }
       13:  830:      else if (literal_p->type & SCANNER_LITERAL_IS_CONST)
        -:  831:      {
    #####:  832:        type = SCANNER_STREAM_TYPE_CONST;
        -:  833:
    #####:  834:        if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))
        -:  835:        {
    #####:  836:          literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  837:        }
        -:  838:      }
        -:  839:
       18:  840:      if (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)
        -:  841:      {
    #####:  842:        type |= SCANNER_STREAM_NO_REG | SCANNER_STREAM_EARLY_CREATE;
        -:  843:      }
        -:  844:#endif /* ENABLED (JERRY_ES2015) */
        -:  845:
       18:  846:      if (literal_p->has_escape)
        -:  847:      {
    #####:  848:        type |= SCANNER_STREAM_HAS_ESCAPE;
        -:  849:      }
        -:  850:
       18:  851:      if ((literal_p->type & SCANNER_LITERAL_NO_REG)
    #####:  852:          || (arguments_required && (literal_p->type & SCANNER_LITERAL_IS_ARG)))
        -:  853:      {
       18:  854:        type |= SCANNER_STREAM_NO_REG;
        -:  855:      }
        -:  856:
       18:  857:      data_p[0] = type;
       18:  858:      data_p[1] = (uint8_t) literal_p->length;
       18:  859:      data_p += 3;
        -:  860:
       18:  861:      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);
        -:  862:
       18:  863:      if (diff >= 1 && diff <= UINT8_MAX)
        -:  864:      {
       18:  865:        data_p[-1] = (uint8_t) diff;
        -:  866:      }
    #####:  867:      else if (diff >= -UINT8_MAX && diff <= UINT16_MAX)
        -:  868:      {
    #####:  869:        if (diff < 0)
        -:  870:        {
    #####:  871:          diff = -diff;
        -:  872:        }
        -:  873:
    #####:  874:        data_p[-3] |= SCANNER_STREAM_UINT16_DIFF;
    #####:  875:        data_p[-1] = (uint8_t) diff;
    #####:  876:        data_p[0] = (uint8_t) (diff >> 8);
    #####:  877:        data_p += 1;
        -:  878:      }
        -:  879:      else
        -:  880:      {
    #####:  881:        data_p[-1] = 0;
    #####:  882:        memcpy (data_p, &literal_p->char_p, sizeof (const uint8_t *));
    #####:  883:        data_p += sizeof (const uint8_t *);
        -:  884:      }
        -:  885:
       18:  886:      prev_source_p = literal_p->char_p + literal_p->length;
        -:  887:    }
        -:  888:
     1312:  889:    data_p[0] = SCANNER_STREAM_TYPE_END;
        -:  890:
     1312:  891:    JERRY_ASSERT (((uint8_t *) info_p) + compressed_size == data_p + 1);
        -:  892:  }
        -:  893:
     1312:  894:  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        1:  895:      && prev_literal_pool_p->no_declarations < no_declarations)
        -:  896:  {
        1:  897:    prev_literal_pool_p->no_declarations = (uint16_t) no_declarations;
        -:  898:  }
        -:  899:
     1312:  900:  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) && prev_literal_pool_p != NULL)
        -:  901:  {
        2:  902:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IS_STRICT)
        -:  903:    {
    #####:  904:      context_p->status_flags |= PARSER_IS_STRICT;
        -:  905:    }
        -:  906:    else
        -:  907:    {
        2:  908:      context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -:  909:    }
        -:  910:
        -:  911:#if ENABLED (JERRY_ES2015)
        2:  912:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -:  913:    {
    #####:  914:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -:  915:    }
        -:  916:    else
        -:  917:    {
        2:  918:      context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;
        -:  919:    }
        -:  920:
        2:  921:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -:  922:    {
    #####:  923:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  924:    }
        -:  925:    else
        -:  926:    {
        2:  927:      context_p->status_flags &= (uint32_t) ~PARSER_IS_ASYNC_FUNCTION;
        -:  928:    }
        -:  929:#endif /* ENABLED (JERRY_ES2015) */
        -:  930:  }
        -:  931:
     1312:  932:  scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;
        -:  933:
     1312:  934:  parser_list_free (&literal_pool_p->literal_pool);
    #####:  935:  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -:  936:} /* scanner_pop_literal_pool */
        -:  937:
        -:  938:/**
        -:  939: * Filter out the arguments from a literal pool.
        -:  940: */
        -:  941:void
        2:  942:scanner_filter_arguments (parser_context_t *context_p, /**< context */
        -:  943:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:  944:{
        -:  945:  /* Fast case: check whether all literals are arguments. */
        2:  946:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        2:  947:  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
        2:  948:  parser_list_iterator_t literal_iterator;
        -:  949:  lexer_lit_location_t *literal_p;
        2:  950:  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;
        2:  951:  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;
        -:  952:
        2:  953:  if (can_eval && prev_literal_pool_p != NULL)
        -:  954:  {
    #####:  955:    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  956:  }
        -:  957:
        2:  958:  literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  959:
        2:  960:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -:  961:
        2:  962:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -:  963:  {
        -:  964:#if ENABLED (JERRY_ES2015)
        3:  965:    if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
        -:  966:    {
    #####:  967:      literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
        -:  968:    }
        -:  969:#else /* !ENABLED (JERRY_ES2015) */
    #####:  970:    if (can_eval)
        -:  971:    {
    #####:  972:      literal_p->type |= SCANNER_LITERAL_NO_REG;
        -:  973:    }
        -:  974:#endif /* ENABLED (JERRY_ES2015) */
        -:  975:
        3:  976:    uint8_t type = literal_p->type;
        -:  977:
        3:  978:    if (!(type & SCANNER_LITERAL_IS_ARG) && !(has_arguments && scanner_literal_is_arguments (literal_p)))
        -:  979:    {
        -:  980:      break;
        -:  981:    }
        -:  982:
        -:  983:#if ENABLED (JERRY_ES2015)
        3:  984:    if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))
        -:  985:    {
    #####:  986:      break;
        -:  987:    }
        -:  988:#endif /* ENABLED (JERRY_ES2015) */
        -:  989:  }
        -:  990:
        2:  991:  if (literal_p == NULL)
        -:  992:  {
        2:  993:    return;
        -:  994:  }
        -:  995:
        -:  996:  scanner_literal_pool_t *new_literal_pool_p;
        -:  997:
    #####:  998:  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
        -:  999:
    #####: 1000:  new_literal_pool_p->prev_p = literal_pool_p;
    #####: 1001:  scanner_context_p->active_literal_pool_p = new_literal_pool_p;
        -: 1002:
    #####: 1003:  *new_literal_pool_p = *literal_pool_p;
    #####: 1004:  parser_list_init (&new_literal_pool_p->literal_pool,
        -: 1005:                    sizeof (lexer_lit_location_t),
        -: 1006:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
        -: 1007:
    #####: 1008:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1009:
        -: 1010:#if ENABLED (JERRY_ES2015)
        -: 1011:  /* Destructured args are placed after the other arguments because of register assignments. */
    #####: 1012:  bool has_destructured_arg = false;
        -: 1013:#endif /* ENABLED (JERRY_ES2015) */
        -: 1014:
    #####: 1015:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1016:  {
    #####: 1017:    uint8_t type = literal_p->type;
        -: 1018:
    #####: 1019:    if ((type & SCANNER_LITERAL_IS_ARG) || (has_arguments && scanner_literal_is_arguments (literal_p)))
    #####: 1020:    {
        -: 1021:#if ENABLED (JERRY_ES2015)
    #####: 1022:      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
        -: 1023:      {
    #####: 1024:        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
    #####: 1025:        literal_p->type = type;
        -: 1026:      }
        -: 1027:
    #####: 1028:      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))
        -: 1029:      {
    #####: 1030:        has_destructured_arg = true;
        -: 1031:
    #####: 1032:        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1033:        {
    #####: 1034:          continue;
        -: 1035:        }
        -: 1036:
    #####: 1037:        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
    #####: 1038:        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
        -: 1039:
    #####: 1040:        literal_p->type = type;
    #####: 1041:        continue;
        -: 1042:      }
        -: 1043:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1044:      if (can_eval)
        -: 1045:      {
    #####: 1046:        literal_p->type |= SCANNER_LITERAL_NO_REG;
        -: 1047:      }
        -: 1048:#endif /* ENABLED (JERRY_ES2015) */
        -: 1049:
        -: 1050:      lexer_lit_location_t *new_literal_p;
    #####: 1051:      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
    #####: 1052:      *new_literal_p = *literal_p;
        -: 1053:    }
    #####: 1054:    else if (prev_literal_pool_p != NULL)
        -: 1055:    {
        -: 1056:      /* Propagate literal to upper level. */
    #####: 1057:      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p,
        -: 1058:                                                                             prev_literal_pool_p,
        -: 1059:                                                                             literal_p);
    #####: 1060:      type |= SCANNER_LITERAL_NO_REG;
        -: 1061:
        -: 1062:#if ENABLED (JERRY_ES2015)
    #####: 1063:      type |= SCANNER_LITERAL_IS_USED;
        -: 1064:#endif /* ENABLED (JERRY_ES2015) */
        -: 1065:
    #####: 1066:      literal_location_p->type |= type;
        -: 1067:    }
        -: 1068:  }
        -: 1069:
        -: 1070:#if ENABLED (JERRY_ES2015)
    #####: 1071:  if (has_destructured_arg)
        -: 1072:  {
    #####: 1073:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1074:
    #####: 1075:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1076:    {
    #####: 1077:      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
        -: 1078:
    #####: 1079:      if ((literal_p->type & expected_flags) == expected_flags)
        -: 1080:      {
        -: 1081:        lexer_lit_location_t *new_literal_p;
    #####: 1082:        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
    #####: 1083:        *new_literal_p = *literal_p;
        -: 1084:      }
        -: 1085:    }
        -: 1086:  }
        -: 1087:#endif /* ENABLED (JERRY_ES2015) */
        -: 1088:
    #####: 1089:  new_literal_pool_p->prev_p = prev_literal_pool_p;
        -: 1090:
    #####: 1091:  parser_list_free (&literal_pool_p->literal_pool);
    #####: 1092:  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 1093:} /* scanner_filter_arguments */
        -: 1094:
        -: 1095:/**
        -: 1096: * Add any literal to the specified literal pool.
        -: 1097: *
        -: 1098: * @return pointer to the literal
        -: 1099: */
        -: 1100:lexer_lit_location_t *
       49: 1101:scanner_add_custom_literal (parser_context_t *context_p, /**< context */
        -: 1102:                            scanner_literal_pool_t *literal_pool_p, /**< literal pool */
        -: 1103:                            const lexer_lit_location_t *literal_location_p) /**< literal */
        -: 1104:{
       49: 1105:  parser_list_iterator_t literal_iterator;
       49: 1106:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1107:  lexer_lit_location_t *literal_p;
        -: 1108:
       49: 1109:  const uint8_t *char_p = literal_location_p->char_p;
       49: 1110:  prop_length_t length = literal_location_p->length;
        -: 1111:
       49: 1112:  if (JERRY_LIKELY (!literal_location_p->has_escape))
        -: 1113:  {
      341: 1114:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1115:    {
      259: 1116:      if (literal_p->length == length)
        -: 1117:      {
       88: 1118:        if (JERRY_LIKELY (!literal_p->has_escape))
        -: 1119:        {
       88: 1120:          if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1121:          {
       16: 1122:            return literal_p;
        -: 1123:          }
        -: 1124:        }
    #####: 1125:        else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1126:        {
        -: 1127:          /* The non-escaped version is preferred. */
    #####: 1128:          literal_p->char_p = char_p;
    #####: 1129:          literal_p->has_escape = 0;
    #####: 1130:          return literal_p;
        -: 1131:        }
        -: 1132:      }
        -: 1133:    }
        -: 1134:  }
        -: 1135:  else
        -: 1136:  {
    #####: 1137:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1138:    {
    #####: 1139:      if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))
        -: 1140:      {
    #####: 1141:        return literal_p;
        -: 1142:      }
        -: 1143:    }
        -: 1144:  }
        -: 1145:
       33: 1146:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
       33: 1147:  *literal_p = *literal_location_p;
        -: 1148:
       33: 1149:  literal_p->type = 0;
        -: 1150:
       33: 1151:  return literal_p;
        -: 1152:} /* scanner_add_custom_literal */
        -: 1153:
        -: 1154:/**
        -: 1155: * Add the current literal token to the current literal pool.
        -: 1156: *
        -: 1157: * @return pointer to the literal
        -: 1158: */
        -: 1159:inline lexer_lit_location_t * JERRY_ATTR_ALWAYS_INLINE
       14: 1160:scanner_add_literal (parser_context_t *context_p, /**< context */
        -: 1161:                     scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1162:{
       14: 1163:  return scanner_add_custom_literal (context_p,
        -: 1164:                                     scanner_context_p->active_literal_pool_p,
       14: 1165:                                     &context_p->token.lit_location);
        -: 1166:} /* scanner_add_literal */
        -: 1167:
        -: 1168:/**
        -: 1169: * Add the current literal token to the current literal pool and
        -: 1170: * set SCANNER_LITERAL_NO_REG if it is inside a with statement.
        -: 1171: *
        -: 1172: * @return pointer to the literal
        -: 1173: */
        -: 1174:inline void JERRY_ATTR_ALWAYS_INLINE
       20: 1175:scanner_add_reference (parser_context_t *context_p, /**< context */
        -: 1176:                       scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1177:{
       20: 1178:  lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,
        -: 1179:                                                                     scanner_context_p->active_literal_pool_p,
       20: 1180:                                                                     &context_p->token.lit_location);
        -: 1181:#if ENABLED (JERRY_ES2015)
       20: 1182:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -: 1183:#endif /* ENABLED (JERRY_ES2015) */
        -: 1184:
       20: 1185:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 1186:  {
    #####: 1187:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -: 1188:  }
        -: 1189:
       20: 1190:  scanner_detect_eval_call (context_p, scanner_context_p);
       20: 1191:} /* scanner_add_reference */
        -: 1192:
        -: 1193:/**
        -: 1194: * Append an argument to the literal pool. If the argument is already present, make it a "hole".
        -: 1195: *
        -: 1196: * @return newly created literal
        -: 1197: */
        -: 1198:lexer_lit_location_t *
        3: 1199:scanner_append_argument (parser_context_t *context_p, /**< context */
        -: 1200:                         scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1201:{
        3: 1202:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        3: 1203:  parser_list_iterator_t literal_iterator;
        3: 1204:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        3: 1205:  lexer_lit_location_t *literal_location_p = &context_p->token.lit_location;
        -: 1206:  lexer_lit_location_t *literal_p;
        -: 1207:
        3: 1208:  const uint8_t *char_p = literal_location_p->char_p;
        3: 1209:  prop_length_t length = literal_location_p->length;
        -: 1210:
        3: 1211:  if (JERRY_LIKELY (!context_p->token.lit_location.has_escape))
        -: 1212:  {
        9: 1213:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1214:    {
        3: 1215:      if (literal_p->length == length)
        -: 1216:      {
        3: 1217:        if (JERRY_LIKELY (!literal_p->has_escape))
        -: 1218:        {
        3: 1219:          if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1220:          {
    #####: 1221:            break;
        -: 1222:          }
        -: 1223:        }
    #####: 1224:        else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1225:        {
    #####: 1226:          break;
        -: 1227:        }
        -: 1228:      }
        -: 1229:    }
        -: 1230:  }
        -: 1231:  else
        -: 1232:  {
    #####: 1233:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1234:    {
    #####: 1235:      if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))
        -: 1236:      {
    #####: 1237:        break;
        -: 1238:      }
        -: 1239:    }
        -: 1240:  }
        -: 1241:
        3: 1242:  uint8_t literal_type = SCANNER_LITERAL_IS_ARG;
        -: 1243:
        3: 1244:  if (literal_p != NULL)
        -: 1245:  {
    #####: 1246:    literal_p->length = 0;
        -: 1247:
        -: 1248:#if ENABLED (JERRY_ES2015)
    #####: 1249:    if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1250:    {
    #####: 1251:      literal_type = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_EARLY_CREATE;
        -: 1252:    }
        -: 1253:#endif /* ENABLED (JERRY_ES2015) */
        -: 1254:  }
        -: 1255:
        3: 1256:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        -: 1257:
        3: 1258:  *literal_p = context_p->token.lit_location;
        3: 1259:  literal_p->type = literal_type;
        -: 1260:
        3: 1261:  return literal_p;
        -: 1262:} /* scanner_append_argument */
        -: 1263:
        -: 1264:/**
        -: 1265: * Check whether an eval call is performed and update the status flags accordingly.
        -: 1266: */
        -: 1267:void
       20: 1268:scanner_detect_eval_call (parser_context_t *context_p, /**< context */
        -: 1269:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1270:{
       20: 1271:  if (context_p->token.keyword_type == LEXER_KEYW_EVAL
        1: 1272:      && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 1273:  {
        1: 1274:    scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1275:  }
       20: 1276:} /* scanner_detect_eval_call */
        -: 1277:
        -: 1278:#if ENABLED (JERRY_ES2015)
        -: 1279:
        -: 1280:/**
        -: 1281: * Find a let/const declaration of a given literal.
        -: 1282: *
        -: 1283: * @return true - if the literal is found, false - otherwise
        -: 1284: */
        -: 1285:bool
    #####: 1286:scanner_scope_find_let_declaration (parser_context_t *context_p, /**< context */
        -: 1287:                                    lexer_lit_location_t *literal_p) /**< literal */
        -: 1288:{
        -: 1289:  ecma_string_t *name_p;
        -: 1290:
    #####: 1291:  if (JERRY_LIKELY (!literal_p->has_escape))
        -: 1292:  {
    #####: 1293:    name_p = ecma_new_ecma_string_from_utf8 (literal_p->char_p, literal_p->length);
        -: 1294:  }
        -: 1295:  else
        -: 1296:  {
    #####: 1297:    uint8_t *destination_p = (uint8_t *) scanner_malloc (context_p, literal_p->length);
        -: 1298:
    #####: 1299:    lexer_convert_ident_to_cesu8 (destination_p, literal_p->char_p, literal_p->length);
        -: 1300:
    #####: 1301:    name_p = ecma_new_ecma_string_from_utf8 (destination_p, literal_p->length);
    #####: 1302:    scanner_free (destination_p, literal_p->length);
        -: 1303:  }
        -: 1304:
    #####: 1305:  ecma_object_t *lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -: 1306:
    #####: 1307:  while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1308:  {
    #####: 1309:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1310:    {
    #####: 1311:      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1312:
    #####: 1313:      if (property_p != NULL && ecma_is_property_enumerable (*property_p))
        -: 1314:      {
    #####: 1315:        ecma_deref_ecma_string (name_p);
    #####: 1316:        return true;
        -: 1317:      }
        -: 1318:    }
        -: 1319:
    #####: 1320:    JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1321:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1322:  }
        -: 1323:
    #####: 1324:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1325:  {
    #####: 1326:    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1327:
    #####: 1328:    if (property_p != NULL && ecma_is_property_enumerable (*property_p))
        -: 1329:    {
    #####: 1330:      ecma_deref_ecma_string (name_p);
    #####: 1331:      return true;
        -: 1332:    }
        -: 1333:  }
        -: 1334:
    #####: 1335:  ecma_deref_ecma_string (name_p);
    #####: 1336:  return false;
        -: 1337:} /* scanner_scope_find_let_declaration */
        -: 1338:
        -: 1339:/**
        -: 1340: * Throws an error for invalid var statements.
        -: 1341: */
        -: 1342:void
       12: 1343:scanner_detect_invalid_var (parser_context_t *context_p, /**< context */
        -: 1344:                            scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1345:                            lexer_lit_location_t *var_literal_p) /**< var literal */
        -: 1346:{
       12: 1347:  if (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL
    #####: 1348:      && !(var_literal_p->type & (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_ARG))
    #####: 1349:      && (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL)
        -: 1350:  {
    #####: 1351:    scanner_raise_redeclaration_error (context_p);
        -: 1352:  }
        -: 1353:
       12: 1354:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
       12: 1355:  const uint8_t *char_p = var_literal_p->char_p;
       12: 1356:  prop_length_t length = var_literal_p->length;
        -: 1357:
       26: 1358:  while (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
        -: 1359:  {
        2: 1360:    literal_pool_p = literal_pool_p->prev_p;
        -: 1361:
        2: 1362:    parser_list_iterator_t literal_iterator;
        2: 1363:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1364:    lexer_lit_location_t *literal_p;
        -: 1365:
        2: 1366:    if (JERRY_LIKELY (!context_p->token.lit_location.has_escape))
        -: 1367:    {
       24: 1368:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1369:      {
       20: 1370:        if (literal_p->type & SCANNER_LITERAL_IS_LOCAL
    #####: 1371:            && !(literal_p->type & SCANNER_LITERAL_IS_ARG)
    #####: 1372:            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL
    #####: 1373:            && literal_p->length == length)
        -: 1374:        {
    #####: 1375:          if (JERRY_LIKELY (!literal_p->has_escape))
        -: 1376:          {
    #####: 1377:            if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1378:            {
    #####: 1379:              scanner_raise_redeclaration_error (context_p);
    #####: 1380:              return;
        -: 1381:            }
        -: 1382:          }
    #####: 1383:          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1384:          {
    #####: 1385:            scanner_raise_redeclaration_error (context_p);
    #####: 1386:            return;
        -: 1387:          }
        -: 1388:        }
        -: 1389:      }
        -: 1390:    }
        -: 1391:    else
        -: 1392:    {
    #####: 1393:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1394:      {
    #####: 1395:        if (literal_p->type & SCANNER_LITERAL_IS_LOCAL
    #####: 1396:            && !(literal_p->type & SCANNER_LITERAL_IS_ARG)
    #####: 1397:            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL
    #####: 1398:            && lexer_compare_identifiers (context_p, literal_p, var_literal_p))
        -: 1399:        {
    #####: 1400:          scanner_raise_redeclaration_error (context_p);
    #####: 1401:          return;
        -: 1402:        }
        -: 1403:      }
        -: 1404:    }
        -: 1405:  }
        -: 1406:
       12: 1407:  if ((context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL)
    #####: 1408:      && scanner_scope_find_let_declaration (context_p, var_literal_p))
        -: 1409:  {
    #####: 1410:    scanner_raise_redeclaration_error (context_p);
        -: 1411:  }
        -: 1412:} /* scanner_detect_invalid_var */
        -: 1413:
        -: 1414:/**
        -: 1415: * Throws an error for invalid let statements.
        -: 1416: */
        -: 1417:void
    #####: 1418:scanner_detect_invalid_let (parser_context_t *context_p, /**< context */
        -: 1419:                            lexer_lit_location_t *let_literal_p) /**< let literal */
        -: 1420:{
    #####: 1421:  if (let_literal_p->type & (SCANNER_LITERAL_IS_ARG
        -: 1422:                             | SCANNER_LITERAL_IS_VAR
        -: 1423:                             | SCANNER_LITERAL_IS_LOCAL))
        -: 1424:  {
    #####: 1425:    scanner_raise_redeclaration_error (context_p);
        -: 1426:  }
        -: 1427:
    #####: 1428:  if (let_literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1429:  {
    #####: 1430:    let_literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
        -: 1431:  }
    #####: 1432:} /* scanner_detect_invalid_let */
        -: 1433:
        -: 1434:/**
        -: 1435: * Push the values required for class declaration parsing.
        -: 1436: */
        -: 1437:void
    #####: 1438:scanner_push_class_declaration (parser_context_t *context_p, /**< context */
        -: 1439:                                scanner_context_t *scanner_context_p, /* scanner context */
        -: 1440:                                uint8_t stack_mode) /**< stack mode */
        -: 1441:{
    #####: 1442:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_CLASS);
        -: 1443:
    #####: 1444:  parser_stack_push_uint8 (context_p, stack_mode);
    #####: 1445:  scanner_source_start_t source_start;
    #####: 1446:  source_start.source_p = context_p->source_p;
        -: 1447:
    #####: 1448:  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1449:  parser_stack_push_uint8 (context_p, SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR);
    #####: 1450:  scanner_context_p->mode = SCAN_MODE_CLASS_DECLARATION;
        -: 1451:
    #####: 1452:  lexer_next_token (context_p);
    #####: 1453:} /* scanner_push_class_declaration */
        -: 1454:
        -: 1455:/**
        -: 1456: * Push the values required for destructuring assignment or binding parsing.
        -: 1457: */
        -: 1458:void
        3: 1459:scanner_push_destructuring_pattern (parser_context_t *context_p, /**< context */
        -: 1460:                                    scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1461:                                    uint8_t binding_type, /**< type of destructuring binding pattern */
        -: 1462:                                    bool is_nested) /**< nested declaration */
        -: 1463:{
        3: 1464:  JERRY_ASSERT (binding_type != SCANNER_BINDING_NONE || !is_nested);
        -: 1465:
        3: 1466:  scanner_source_start_t source_start;
        3: 1467:  source_start.source_p = context_p->source_p;
        -: 1468:
        3: 1469:  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
        3: 1470:  parser_stack_push_uint8 (context_p, scanner_context_p->binding_type);
        3: 1471:  scanner_context_p->binding_type = binding_type;
        -: 1472:
        3: 1473:  if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -: 1474:  {
        -: 1475:    scanner_binding_list_t *binding_list_p;
    #####: 1476:    binding_list_p = (scanner_binding_list_t *) scanner_malloc (context_p, sizeof (scanner_binding_list_t));
        -: 1477:
    #####: 1478:    binding_list_p->prev_p = scanner_context_p->active_binding_list_p;
    #####: 1479:    binding_list_p->items_p = NULL;
    #####: 1480:    binding_list_p->is_nested = is_nested;
        -: 1481:
    #####: 1482:    scanner_context_p->active_binding_list_p = binding_list_p;
        -: 1483:  }
        3: 1484:} /* scanner_push_destructuring_pattern */
        -: 1485:
        -: 1486:/**
        -: 1487: * Pop binding list.
        -: 1488: */
        -: 1489:void
    #####: 1490:scanner_pop_binding_list (scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1491:{
    #####: 1492:  scanner_binding_list_t *binding_list_p = scanner_context_p->active_binding_list_p;
    #####: 1493:  scanner_binding_item_t *item_p = binding_list_p->items_p;
    #####: 1494:  scanner_binding_list_t *prev_binding_list_p = binding_list_p->prev_p;
    #####: 1495:  bool is_nested = binding_list_p->is_nested;
        -: 1496:
    #####: 1497:  scanner_free (binding_list_p, sizeof (scanner_binding_list_t));
    #####: 1498:  scanner_context_p->active_binding_list_p = prev_binding_list_p;
        -: 1499:
    #####: 1500:  JERRY_ASSERT (binding_list_p != NULL);
        -: 1501:
    #####: 1502:  if (!is_nested)
        -: 1503:  {
    #####: 1504:    while (item_p != NULL)
        -: 1505:    {
    #####: 1506:      scanner_binding_item_t *next_p = item_p->next_p;
        -: 1507:
    #####: 1508:      JERRY_ASSERT (item_p->literal_p->type & (SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_IS_ARG));
        -: 1509:
    #####: 1510:      scanner_free (item_p, sizeof (scanner_binding_item_t));
    #####: 1511:      item_p = next_p;
        -: 1512:    }
    #####: 1513:    return;
        -: 1514:  }
        -: 1515:
    #####: 1516:  JERRY_ASSERT (prev_binding_list_p != NULL);
        -: 1517:
    #####: 1518:  while (item_p != NULL)
        -: 1519:  {
    #####: 1520:    scanner_binding_item_t *next_p = item_p->next_p;
        -: 1521:
    #####: 1522:    item_p->next_p = prev_binding_list_p->items_p;
    #####: 1523:    prev_binding_list_p->items_p = item_p;
        -: 1524:
    #####: 1525:    item_p = next_p;
        -: 1526:  }
        -: 1527:} /* scanner_pop_binding_list */
        -: 1528:
        -: 1529:/**
        -: 1530: * Append a hole into the literal pool.
        -: 1531: */
        -: 1532:void
    #####: 1533:scanner_append_hole (parser_context_t *context_p, scanner_context_t *scanner_context_p)
        -: 1534:{
    #####: 1535:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1536:
        -: 1537:  lexer_lit_location_t *literal_p;
    #####: 1538:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        -: 1539:
    #####: 1540:  literal_p->char_p = NULL;
    #####: 1541:  literal_p->length = 0;
    #####: 1542:  literal_p->type = SCANNER_LITERAL_IS_ARG;
    #####: 1543:  literal_p->has_escape = 0;
    #####: 1544:} /* scanner_append_hole */
        -: 1545:
        -: 1546:#endif /* ENABLED (JERRY_ES2015) */
        -: 1547:
        -: 1548:/**
        -: 1549: * Reverse the scanner info chain after the scanning is completed.
        -: 1550: */
        -: 1551:void
     1309: 1552:scanner_reverse_info_list (parser_context_t *context_p) /**< context */
        -: 1553:{
     1309: 1554:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
     1309: 1555:  scanner_info_t *last_scanner_info_p = NULL;
        -: 1556:
     1309: 1557:  if (scanner_info_p->type == SCANNER_TYPE_END)
        -: 1558:  {
    #####: 1559:    return;
        -: 1560:  }
        -: 1561:
        -: 1562:  do
        -: 1563:  {
     1312: 1564:    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;
     1312: 1565:    scanner_info_p->next_p = last_scanner_info_p;
        -: 1566:
     1312: 1567:    last_scanner_info_p = scanner_info_p;
     1312: 1568:    scanner_info_p = next_scanner_info_p;
        -: 1569:  }
     1312: 1570:  while (scanner_info_p->type != SCANNER_TYPE_END);
        -: 1571:
     1309: 1572:  context_p->next_scanner_info_p->next_p = scanner_info_p;
     1309: 1573:  context_p->next_scanner_info_p = last_scanner_info_p;
        -: 1574:} /* scanner_reverse_info_list */
        -: 1575:
        -: 1576:/**
        -: 1577: * Release unused scanner info blocks.
        -: 1578: * This should happen only if an error is occured.
        -: 1579: */
        -: 1580:void
     1298: 1581:scanner_cleanup (parser_context_t *context_p) /**< context */
        -: 1582:{
     1298: 1583:  if (context_p->skipped_scanner_info_p != NULL)
        -: 1584:  {
    #####: 1585:    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;
    #####: 1586:    context_p->next_scanner_info_p = context_p->skipped_scanner_info_p;
    #####: 1587:    context_p->skipped_scanner_info_p = NULL;
        -: 1588:  }
        -: 1589:
     1298: 1590:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -: 1591:
     3894: 1592:  while (scanner_info_p != NULL)
        -: 1593:  {
     1298: 1594:    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;
        -: 1595:
     1298: 1596:    size_t size = sizeof (scanner_info_t);
        -: 1597:
     1298: 1598:    switch (scanner_info_p->type)
        -: 1599:    {
     1298: 1600:      case SCANNER_TYPE_END:
        -: 1601:      {
     1298: 1602:        scanner_info_p = context_p->active_scanner_info_p;
     1298: 1603:        continue;
        -: 1604:      }
    #####: 1605:      case SCANNER_TYPE_FUNCTION:
        -: 1606:      case SCANNER_TYPE_BLOCK:
        -: 1607:      {
    #####: 1608:        size = scanner_get_stream_size (scanner_info_p, sizeof (scanner_info_t));
    #####: 1609:        break;
        -: 1610:      }
    #####: 1611:      case SCANNER_TYPE_WHILE:
        -: 1612:      case SCANNER_TYPE_FOR_IN:
        -: 1613:#if ENABLED (JERRY_ES2015)
        -: 1614:      case SCANNER_TYPE_FOR_OF:
        -: 1615:#endif /* ENABLED (JERRY_ES2015) */
        -: 1616:      case SCANNER_TYPE_CASE:
        -: 1617:#if ENABLED (JERRY_ES2015)
        -: 1618:      case SCANNER_TYPE_INITIALIZER:
        -: 1619:#endif /* ENABLED (JERRY_ES2015) */
        -: 1620:      {
    #####: 1621:        size = sizeof (scanner_location_info_t);
    #####: 1622:        break;
        -: 1623:      }
    #####: 1624:      case SCANNER_TYPE_FOR:
        -: 1625:      {
    #####: 1626:        size = sizeof (scanner_for_info_t);
    #####: 1627:        break;
        -: 1628:      }
    #####: 1629:      case SCANNER_TYPE_SWITCH:
        -: 1630:      {
    #####: 1631:        scanner_release_switch_cases (((scanner_switch_info_t *) scanner_info_p)->case_p);
    #####: 1632:        size = sizeof (scanner_switch_info_t);
    #####: 1633:        break;
        -: 1634:      }
    #####: 1635:      default:
        -: 1636:      {
        -: 1637:#if ENABLED (JERRY_ES2015)
    #####: 1638:        JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS
        -: 1639:                      || scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION
        -: 1640:                      || scanner_info_p->type == SCANNER_TYPE_CLASS_CONSTRUCTOR
        -: 1641:                      || scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED
        -: 1642:                      || scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION);
        -: 1643:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1644:        JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);
        -: 1645:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1646:        break;
        -: 1647:      }
        -: 1648:    }
        -: 1649:
    #####: 1650:    scanner_free (scanner_info_p, size);
    #####: 1651:    scanner_info_p = next_scanner_info_p;
        -: 1652:  }
        -: 1653:
     1298: 1654:  context_p->next_scanner_info_p = NULL;
     1298: 1655:  context_p->active_scanner_info_p = NULL;
     1298: 1656:} /* scanner_cleanup */
        -: 1657:
        -: 1658:/**
        -: 1659: * Checks whether a context needs to be created for a block.
        -: 1660: *
        -: 1661: * @return true - if context is needed,
        -: 1662: *         false - otherwise
        -: 1663: */
        -: 1664:bool
     1299: 1665:scanner_is_context_needed (parser_context_t *context_p, /**< context */
        -: 1666:                           parser_check_context_type_t check_type) /**< context type */
        -: 1667:{
     1299: 1668:  scanner_info_t *info_p = context_p->next_scanner_info_p;
     1299: 1669:  const uint8_t *data_p = (const uint8_t *) (info_p + 1);
        -: 1670:
        -: 1671:  JERRY_UNUSED (check_type);
        -: 1672:
        -: 1673:#if ENABLED (JERRY_ES2015)
     1299: 1674:  JERRY_ASSERT ((check_type == PARSER_CHECK_BLOCK_CONTEXT ? info_p->type == SCANNER_TYPE_BLOCK
        -: 1675:                                                          : info_p->type == SCANNER_TYPE_FUNCTION));
        -: 1676:
     1300: 1677:  uint32_t scope_stack_reg_top = (check_type != PARSER_CHECK_GLOBAL_CONTEXT ? context_p->scope_stack_reg_top
     1300: 1678:                                                                            : 0);
        -: 1679:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1680:  JERRY_ASSERT (check_type == PARSER_CHECK_BLOCK_CONTEXT);
    #####: 1681:  JERRY_ASSERT (info_p->type == SCANNER_TYPE_BLOCK);
        -: 1682:
    #####: 1683:  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 1684:#endif /* !JERRY_NDEBUG */
        -: 1685:
     2599: 1686:  while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 1687:  {
        2: 1688:    uint8_t data = data_p[0];
        -: 1689:
        -: 1690:#if ENABLED (JERRY_ES2015)
        2: 1691:    uint32_t type = data & SCANNER_STREAM_TYPE_MASK;
        -: 1692:
        2: 1693:    if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))
        -: 1694:    {
    #####: 1695:      JERRY_ASSERT (check_type == PARSER_CHECK_FUNCTION_CONTEXT);
    #####: 1696:      data_p++;
    #####: 1697:      continue;
        -: 1698:    }
        -: 1699:
        -: 1700:#ifndef JERRY_NDEBUG
        2: 1701:    if (check_type == PARSER_CHECK_BLOCK_CONTEXT)
        -: 1702:    {
        1: 1703:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR
        -: 1704:                    || type == SCANNER_STREAM_TYPE_LET
        -: 1705:                    || type == SCANNER_STREAM_TYPE_CONST
        -: 1706:                    || type == SCANNER_STREAM_TYPE_LOCAL
        -: 1707:                    || type == SCANNER_STREAM_TYPE_FUNC);
        -: 1708:    }
        1: 1709:    else if (check_type == PARSER_CHECK_GLOBAL_CONTEXT)
        -: 1710:    {
        -: 1711:      /* FIXME: a private declarative lexical environment should always be present
        -: 1712:       * for modules. Remove SCANNER_STREAM_TYPE_IMPORT after it is implemented. */
        1: 1713:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR
        -: 1714:                    || type == SCANNER_STREAM_TYPE_LET
        -: 1715:                    || type == SCANNER_STREAM_TYPE_CONST
        -: 1716:                    || type == SCANNER_STREAM_TYPE_FUNC
        -: 1717:                    || type == SCANNER_STREAM_TYPE_IMPORT);
        -: 1718:
        -: 1719:      /* Only let/const can be stored in registers */
        1: 1720:      JERRY_ASSERT ((data & SCANNER_STREAM_NO_REG)
        -: 1721:                    || (type == SCANNER_STREAM_TYPE_FUNC && (context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
        -: 1722:                    || type == SCANNER_STREAM_TYPE_LET
        -: 1723:                    || type == SCANNER_STREAM_TYPE_CONST);
        -: 1724:    }
        -: 1725:    else
        -: 1726:    {
    #####: 1727:      JERRY_ASSERT (check_type == PARSER_CHECK_FUNCTION_CONTEXT);
        -: 1728:
    #####: 1729:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR
        -: 1730:                    || type == SCANNER_STREAM_TYPE_LET
        -: 1731:                    || type == SCANNER_STREAM_TYPE_CONST
        -: 1732:                    || type == SCANNER_STREAM_TYPE_LOCAL
        -: 1733:                    || type == SCANNER_STREAM_TYPE_ARG
        -: 1734:                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG
        -: 1735:                    || type == SCANNER_STREAM_TYPE_ARG_FUNC
        -: 1736:                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC
        -: 1737:                    || type == SCANNER_STREAM_TYPE_FUNC);
        -: 1738:    }
        -: 1739:#endif /* !JERRY_NDEBUG */
        -: 1740:
        -: 1741:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1742:    JERRY_ASSERT ((data & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_VAR);
        -: 1743:#endif /* ENABLED (JERRY_ES2015) */
        -: 1744:
        2: 1745:    if (!(data & SCANNER_STREAM_UINT16_DIFF))
        -: 1746:    {
        2: 1747:      if (data_p[2] != 0)
        -: 1748:      {
        2: 1749:        data_p += 2 + 1;
        -: 1750:      }
        -: 1751:      else
        -: 1752:      {
    #####: 1753:        data_p += 2 + 1 + sizeof (const uint8_t *);
        -: 1754:      }
        -: 1755:    }
        -: 1756:    else
        -: 1757:    {
    #####: 1758:      data_p += 2 + 2;
        -: 1759:    }
        -: 1760:
        -: 1761:#if ENABLED (JERRY_ES2015)
        2: 1762:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_GLOBAL_CONTEXT)
        1: 1763:        && (type == SCANNER_STREAM_TYPE_VAR
        1: 1764:            || (type == SCANNER_STREAM_TYPE_FUNC && !(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
    #####: 1765:            || type == SCANNER_STREAM_TYPE_IMPORT))
        -: 1766:    {
        1: 1767:      continue;
        -: 1768:    }
        -: 1769:
        1: 1770:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))
        -: 1771:    {
    #####: 1772:      if (SCANNER_STREAM_TYPE_IS_ARG (type))
        -: 1773:      {
    #####: 1774:        continue;
        -: 1775:      }
        -: 1776:
    #####: 1777:      if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 1778:      {
        -: 1779:        /* The return value is true, if the variable is stored in the lexical environment
        -: 1780:         * or all registers have already been used for function arguments. This can be
        -: 1781:         * inprecise in the latter case, but that is a very rare corner case. A more
        -: 1782:         * sophisticated check would require to decode the literal. */
    #####: 1783:        if ((data & SCANNER_STREAM_NO_REG)
    #####: 1784:            || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1785:        {
    #####: 1786:          return true;
        -: 1787:        }
    #####: 1788:        continue;
        -: 1789:      }
        -: 1790:    }
        -: 1791:#endif /* ENABLED (JERRY_ES2015) */
        -: 1792:
        1: 1793:    if ((data & SCANNER_STREAM_NO_REG)
    #####: 1794:        || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1795:    {
        1: 1796:      return true;
        -: 1797:    }
        -: 1798:
    #####: 1799:    scope_stack_reg_top++;
        -: 1800:  }
        -: 1801:
     1298: 1802:  return false;
        -: 1803:} /* scanner_is_context_needed */
        -: 1804:
        -: 1805:#if ENABLED (JERRY_ES2015)
        -: 1806:
        -: 1807:/**
        -: 1808: * Try to scan/parse the ".target" part in the "new.target" expression.
        -: 1809: *
        -: 1810: * Upon exiting with "true" the current token will point to the "target"
        -: 1811: * literal.
        -: 1812: *
        -: 1813: * If the "target" literal is not after the "new." then a scanner/parser
        -: 1814: * error will be raised.
        -: 1815: *
        -: 1816: * @returns true if the ".target" part was found
        -: 1817: *          false if there is no "." after the new.
        -: 1818: */
        -: 1819:bool
        6: 1820:scanner_try_scan_new_target (parser_context_t *context_p) /**< parser/scanner context */
        -: 1821:{
        6: 1822:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_NEW);
        -: 1823:
        6: 1824:  if (lexer_check_next_character (context_p, LIT_CHAR_DOT))
        -: 1825:  {
    #####: 1826:    lexer_next_token (context_p);
    #####: 1827:    if (context_p->token.type != LEXER_DOT)
        -: 1828:    {
    #####: 1829:      parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);
        -: 1830:    }
        -: 1831:
    #####: 1832:    lexer_next_token (context_p);
    #####: 1833:    if (!lexer_token_is_identifier (context_p, "target", 6))
        -: 1834:    {
    #####: 1835:      parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_EXPECTED);
        -: 1836:    }
        -: 1837:
    #####: 1838:    return true;
        -: 1839:  }
        6: 1840:  return false;
        -: 1841:} /* scanner_try_scan_new_target */
        -: 1842:
        -: 1843:#endif /* ENABLED (JERRY_ES2015) */
        -: 1844:
        -: 1845:/**
        -: 1846: * Description of "arguments" literal string.
        -: 1847: */
        -: 1848:const lexer_lit_location_t lexer_arguments_literal =
        -: 1849:{
        -: 1850:  (const uint8_t *) "arguments", 9, LEXER_IDENT_LITERAL, false
        -: 1851:};
        -: 1852:
        -: 1853:/**
        -: 1854: * Create an unused literal.
        -: 1855: */
        -: 1856:static void
        2: 1857:scanner_create_unused_literal (parser_context_t *context_p, /**< context */
        -: 1858:                               uint8_t status_flags) /**< initial status flags */
        -: 1859:{
        2: 1860:  if (JERRY_UNLIKELY (context_p->literal_count >= PARSER_MAXIMUM_NUMBER_OF_LITERALS))
        -: 1861:  {
    #####: 1862:    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
        -: 1863:  }
        -: 1864:
        2: 1865:  lexer_literal_t *literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
        -: 1866:
        2: 1867:  literal_p->type = LEXER_UNUSED_LITERAL;
        2: 1868:  literal_p->status_flags = status_flags;
        -: 1869:
        2: 1870:  context_p->literal_count++;
        2: 1871:} /* scanner_create_unused_literal */
        -: 1872:
        -: 1873:#if ENABLED (JERRY_ES2015)
        -: 1874:/**
        -: 1875: * Emit checks for redeclared bindings in the global lexical scope.
        -: 1876: */
        -: 1877:void
        1: 1878:scanner_check_variables (parser_context_t *context_p) /**< context */
        -: 1879:{
        1: 1880:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        1: 1881:  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);
        1: 1882:  lexer_lit_location_t literal;
        -: 1883:
        1: 1884:  JERRY_ASSERT (info_p->type == SCANNER_TYPE_FUNCTION);
        -: 1885:
        1: 1886:  literal.char_p = info_p->source_p - 1;
        -: 1887:
        3: 1888:  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 1889:  {
        1: 1890:    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;
        1: 1891:    const uint8_t *data_p = next_data_p;
        -: 1892:
        1: 1893:    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_HOLE
        -: 1894:                  && !SCANNER_STREAM_TYPE_IS_ARG (type)
        -: 1895:                  && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type));
        1: 1896:    JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);
        -: 1897:
        1: 1898:    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 1899:    {
        1: 1900:      if (data_p[2] != 0)
        -: 1901:      {
        1: 1902:        literal.char_p += data_p[2];
        1: 1903:        next_data_p += 2 + 1;
        -: 1904:      }
        -: 1905:      else
        -: 1906:      {
    #####: 1907:        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (const uint8_t *));
    #####: 1908:        next_data_p += 2 + 1 + sizeof (const uint8_t *);
        -: 1909:      }
        -: 1910:    }
        -: 1911:    else
        -: 1912:    {
    #####: 1913:      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 1914:
    #####: 1915:      if (diff <= UINT8_MAX)
        -: 1916:      {
    #####: 1917:        diff = -diff;
        -: 1918:      }
        -: 1919:
    #####: 1920:      literal.char_p += diff;
    #####: 1921:      next_data_p += 2 + 2;
        -: 1922:    }
        -: 1923:
        1: 1924:    literal.length = data_p[1];
        1: 1925:    literal.type = LEXER_IDENT_LITERAL;
        1: 1926:    literal.has_escape = (data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? 1 : 0;
        -: 1927:
        1: 1928:    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);
        1: 1929:    literal.char_p += data_p[1];
        -: 1930:
        -: 1931:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
        1: 1932:    if (type == SCANNER_STREAM_TYPE_IMPORT)
        -: 1933:    {
    #####: 1934:      continue;
        -: 1935:    }
        -: 1936:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 1937:
        1: 1938:    context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
        -: 1939:
        -: 1940:    uint16_t opcode;
        1: 1941:    if (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_FUNC)
        -: 1942:    {
        1: 1943:      opcode = CBC_CHECK_VAR;
        -: 1944:    }
        -: 1945:    else
        -: 1946:    {
    #####: 1947:      opcode = CBC_CHECK_LET;
        -: 1948:    }
        -: 1949:
        1: 1950:    parser_emit_cbc_literal (context_p, opcode, context_p->lit_object.index);
        -: 1951:  }
        -: 1952:
        1: 1953:  parser_flush_cbc (context_p);
        1: 1954:} /* scanner_check_variables */
        -: 1955:#endif /* ENABLED (JERRY_ES2015) */
        -: 1956:
        -: 1957:/**
        -: 1958: * Create and/or initialize var/let/const/function/etc. variables.
        -: 1959: */
        -: 1960:void
     1302: 1961:scanner_create_variables (parser_context_t *context_p, /**< context */
        -: 1962:                          uint32_t option_flags) /**< combination of scanner_create_variables_flags_t bits */
        -: 1963:{
     1302: 1964:  scanner_info_t *info_p = context_p->next_scanner_info_p;
     1302: 1965:  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);
     1302: 1966:  uint8_t info_type = info_p->type;
     1302: 1967:  uint8_t info_u8_arg = info_p->u8_arg;
     1302: 1968:  lexer_lit_location_t literal;
        -: 1969:  parser_scope_stack_t *scope_stack_p;
        -: 1970:  parser_scope_stack_t *scope_stack_end_p;
        -: 1971:
     1302: 1972:  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION || info_type == SCANNER_TYPE_BLOCK);
     1302: 1973:  JERRY_ASSERT (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
        -: 1974:                || !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY));
     1302: 1975:  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION
        -: 1976:                || !(option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_ARGS | SCANNER_CREATE_VARS_IS_FUNCTION_BODY)));
        -: 1977:
     1302: 1978:  if (info_type == SCANNER_TYPE_FUNCTION && !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))
     1300: 1979:  {
     1300: 1980:    JERRY_ASSERT (context_p->scope_stack_p == NULL);
        -: 1981:
     1300: 1982:    size_t stack_size = info_p->u16_arg * sizeof (parser_scope_stack_t);
     1300: 1983:    context_p->scope_stack_size = info_p->u16_arg;
        -: 1984:
     1300: 1985:    scope_stack_p = NULL;
        -: 1986:
     1300: 1987:    if (stack_size > 0)
        -: 1988:    {
        3: 1989:      scope_stack_p = (parser_scope_stack_t *) parser_malloc (context_p, stack_size);
        -: 1990:    }
        -: 1991:
     1300: 1992:    context_p->scope_stack_p = scope_stack_p;
     1300: 1993:    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;
        -: 1994:  }
        -: 1995:  else
        -: 1996:  {
        2: 1997:    JERRY_ASSERT (context_p->scope_stack_p != NULL || context_p->scope_stack_size == 0);
        -: 1998:
        2: 1999:    scope_stack_p = context_p->scope_stack_p;
        2: 2000:    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;
        2: 2001:    scope_stack_p += context_p->scope_stack_top;
        -: 2002:  }
        -: 2003:
     1302: 2004:  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2005:
     1302: 2006:  literal.char_p = info_p->source_p - 1;
        -: 2007:
     2625: 2008:  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2009:  {
       22: 2010:    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;
       22: 2011:    const uint8_t *data_p = next_data_p;
        -: 2012:
       22: 2013:    JERRY_ASSERT ((option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_BODY | SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))
        -: 2014:                  || (type != SCANNER_STREAM_TYPE_HOLE
        -: 2015:                      && !SCANNER_STREAM_TYPE_IS_ARG (type)
        -: 2016:                      && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type)));
        -: 2017:
        -: 2018:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
       22: 2019:    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_IMPORT || (data_p[0] & SCANNER_STREAM_NO_REG));
        -: 2020:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 2021:
       22: 2022:    if (type == SCANNER_STREAM_TYPE_HOLE)
        -: 2023:    {
    #####: 2024:      next_data_p++;
        -: 2025:
    #####: 2026:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2027:      {
    #####: 2028:        continue;
        -: 2029:      }
        -: 2030:
    #####: 2031:      if (info_u8_arg & SCANNER_FUNCTION_MAPPED_ARGUMENTS)
        -: 2032:      {
    #####: 2033:        scanner_create_unused_literal (context_p, LEXER_FLAG_FUNCTION_ARGUMENT);
        -: 2034:      }
        -: 2035:
    #####: 2036:      if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2037:      {
    #####: 2038:        scope_stack_reg_top++;
        -: 2039:      }
    #####: 2040:      continue;
        -: 2041:    }
        -: 2042:
       22: 2043:    JERRY_ASSERT (context_p->scope_stack_size != 0);
        -: 2044:
       22: 2045:    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 2046:    {
       22: 2047:      if (data_p[2] != 0)
        -: 2048:      {
       22: 2049:        literal.char_p += data_p[2];
       22: 2050:        next_data_p += 2 + 1;
        -: 2051:      }
        -: 2052:      else
        -: 2053:      {
    #####: 2054:        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (const uint8_t *));
    #####: 2055:        next_data_p += 2 + 1 + sizeof (const uint8_t *);
        -: 2056:      }
        -: 2057:    }
        -: 2058:    else
        -: 2059:    {
    #####: 2060:      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 2061:
    #####: 2062:      if (diff <= UINT8_MAX)
        -: 2063:      {
    #####: 2064:        diff = -diff;
        -: 2065:      }
        -: 2066:
    #####: 2067:      literal.char_p += diff;
    #####: 2068:      next_data_p += 2 + 2;
        -: 2069:    }
        -: 2070:
       22: 2071:    if (SCANNER_STREAM_TYPE_IS_ARG (type))
        -: 2072:    {
        9: 2073:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2074:      {
        3: 2075:        literal.char_p += data_p[1];
        3: 2076:        continue;
        -: 2077:      }
        -: 2078:    }
       16: 2079:    else if ((option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
        1: 2080:             && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 2081:    {
        -: 2082:      /* Function arguments must come first. */
        1: 2083:      break;
        -: 2084:    }
        -: 2085:
       18: 2086:    literal.length = data_p[1];
       18: 2087:    literal.type = LEXER_IDENT_LITERAL;
       18: 2088:    literal.has_escape = (data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? 1 : 0;
        -: 2089:
       18: 2090:    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);
       18: 2091:    literal.char_p += data_p[1];
        -: 2092:
       18: 2093:    if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type) && (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))
        -: 2094:    {
    #####: 2095:      JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p + 2);
    #####: 2096:      JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);
        -: 2097:#if ENABLED (JERRY_ES2015)
    #####: 2098:      JERRY_ASSERT (!(context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS));
        -: 2099:#endif /* ENABLED (JERRY_ES2015) */
        -: 2100:
    #####: 2101:      parser_scope_stack_t *function_map_p = scope_stack_p - 2;
    #####: 2102:      uint16_t literal_index = context_p->lit_object.index;
        -: 2103:
    #####: 2104:      while (literal_index != function_map_p->map_from)
        -: 2105:      {
    #####: 2106:        function_map_p--;
        -: 2107:
    #####: 2108:        JERRY_ASSERT (function_map_p >= context_p->scope_stack_p);
        -: 2109:      }
        -: 2110:
    #####: 2111:      JERRY_ASSERT (function_map_p[1].map_from == PARSER_SCOPE_STACK_FUNC);
        -: 2112:
    #####: 2113:      cbc_opcode_t opcode = CBC_SET_VAR_FUNC;
        -: 2114:
        -: 2115:#if ENABLED (JERRY_ES2015)
    #####: 2116:      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
    #####: 2117:          && (function_map_p[0].map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0)
        -: 2118:      {
    #####: 2119:        opcode = CBC_INIT_ARG_OR_FUNC;
        -: 2120:      }
        -: 2121:#endif /* ENABLED (JERRY_ES2015) */
        -: 2122:
    #####: 2123:      parser_emit_cbc_literal_value (context_p,
    #####: 2124:                                     (uint16_t) opcode,
    #####: 2125:                                     function_map_p[1].map_to,
    #####: 2126:                                     scanner_decode_map_to (function_map_p));
    #####: 2127:      continue;
        -: 2128:    }
        -: 2129:
       18: 2130:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2131:    {
    #####: 2132:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2133:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2134:    }
        -: 2135:
       18: 2136:    scope_stack_p->map_from = context_p->lit_object.index;
        -: 2137:
        -: 2138:#if ENABLED (JERRY_ES2015)
       18: 2139:    if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2140:    {
       17: 2141:      if (type != SCANNER_STREAM_TYPE_LET
        -: 2142:#if ENABLED (JERRY_ES2015_MODULE_SYSTEM)
       17: 2143:          && type != SCANNER_STREAM_TYPE_IMPORT
        -: 2144:#endif /* ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
       17: 2145:          && type != SCANNER_STREAM_TYPE_CONST)
        -: 2146:      {
       17: 2147:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_GLOBAL;
        -: 2148:      }
        -: 2149:    }
        -: 2150:#endif /* ENABLED (JERRY_ES2015) */
        -: 2151:
        -: 2152:    uint16_t map_to;
       18: 2153:    uint16_t func_init_opcode = CBC_INIT_ARG_OR_FUNC;
        -: 2154:
       18: 2155:    if (!(data_p[0] & SCANNER_STREAM_NO_REG)
    #####: 2156:        && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2157:    {
    #####: 2158:      map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);
        -: 2159:
        -: 2160:#if ENABLED (JERRY_ES2015)
    #####: 2161:      scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);
        -: 2162:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2163:      scope_stack_p->map_to = map_to;
        -: 2164:#endif /* ENABLED (JERRY_ES2015) */
        -: 2165:
    #####: 2166:      scope_stack_reg_top++;
        -: 2167:#if ENABLED (JERRY_ES2015)
    #####: 2168:      switch (type)
        -: 2169:      {
    #####: 2170:        case SCANNER_STREAM_TYPE_CONST:
        -: 2171:        {
    #####: 2172:          scope_stack_p->map_to |= PARSER_SCOPE_STACK_IS_CONST_REG;
        -: 2173:          /* FALLTHRU */
        -: 2174:        }
    #####: 2175:        case SCANNER_STREAM_TYPE_LET:
        -: 2176:        case SCANNER_STREAM_TYPE_ARG:
        -: 2177:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2178:        case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 2179:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2180:        {
    #####: 2181:          scope_stack_p->map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
    #####: 2182:          break;
        -: 2183:        }
        -: 2184:      }
        -: 2185:
    #####: 2186:      func_init_opcode = CBC_SET_VAR_FUNC;
        -: 2187:#endif /* ENABLED (JERRY_ES2015) */
        -: 2188:    }
        -: 2189:    else
        -: 2190:    {
       18: 2191:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
       18: 2192:      map_to = context_p->lit_object.index;
        -: 2193:
        -: 2194:#if ENABLED (JERRY_ES2015)
       18: 2195:      uint16_t scope_stack_map_to = 0;
        -: 2196:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2197:      scope_stack_p->map_to = map_to;
        -: 2198:#endif /* ENABLED (JERRY_ES2015) */
        -: 2199:
       18: 2200:      if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2201:      {
       17: 2202:        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2203:      }
        -: 2204:
       18: 2205:      switch (type)
        -: 2206:      {
        -: 2207:#if ENABLED (JERRY_ES2015)
    #####: 2208:        case SCANNER_STREAM_TYPE_LET:
        -: 2209:        case SCANNER_STREAM_TYPE_CONST:
        -: 2210:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2211:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2212:        {
    #####: 2213:          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        -: 2214:
    #####: 2215:          if (!(data_p[0] & SCANNER_STREAM_EARLY_CREATE))
        -: 2216:          {
    #####: 2217:            break;
        -: 2218:          }
    #####: 2219:          scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;
        -: 2220:          /* FALLTHRU */
        -: 2221:        }
       13: 2222:        case SCANNER_STREAM_TYPE_LOCAL:
        -: 2223:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2224:        case SCANNER_STREAM_TYPE_VAR:
        -: 2225:        {
        -: 2226:#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)
        -: 2227:          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2228:#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */
        -: 2229:
       13: 2230:          uint16_t opcode = ((option_flags & SCANNER_CREATE_VARS_IS_SCRIPT) ? CBC_CREATE_VAR_EVAL
        -: 2231:                                                                            : CBC_CREATE_VAR);
        -: 2232:#if ENABLED (JERRY_ES2015)
       13: 2233:          switch (type)
        -: 2234:          {
    #####: 2235:            case SCANNER_STREAM_TYPE_LET:
        -: 2236:            {
    #####: 2237:              opcode = CBC_CREATE_LET;
    #####: 2238:              break;
        -: 2239:            }
    #####: 2240:            case SCANNER_STREAM_TYPE_CONST:
        -: 2241:            {
    #####: 2242:              opcode = CBC_CREATE_CONST;
    #####: 2243:              break;
        -: 2244:            }
    #####: 2245:            case SCANNER_STREAM_TYPE_LOCAL:
        -: 2246:            case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2247:            case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2248:            {
    #####: 2249:              opcode = CBC_CREATE_LOCAL;
    #####: 2250:              break;
        -: 2251:            }
        -: 2252:          }
        -: 2253:#endif /* ENABLED (JERRY_ES2015) */
        -: 2254:
       13: 2255:          parser_emit_cbc_literal (context_p, opcode, map_to);
       13: 2256:          break;
        -: 2257:        }
        3: 2258:        case SCANNER_STREAM_TYPE_ARG:
        -: 2259:        case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 2260:        {
        -: 2261:#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)
        -: 2262:          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2263:#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */
        -: 2264:
        -: 2265:#if ENABLED (JERRY_ES2015)
        3: 2266:          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        -: 2267:
        -: 2268:          /* Argument initializers of functions with mapped arguments (e.g. function f(a,b,a) {}) are
        -: 2269:           * generated here. The other initializers are handled by parser_parse_function_arguments(). */
        3: 2270:          if (info_u8_arg & SCANNER_FUNCTION_MAPPED_ARGUMENTS)
        -: 2271:          {
        -: 2272:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2273:            parser_emit_cbc_literal_value (context_p,
        -: 2274:                                           CBC_INIT_ARG_OR_FUNC,
    #####: 2275:                                           (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top),
        -: 2276:                                           map_to);
        -: 2277:#if ENABLED (JERRY_ES2015)
        -: 2278:          }
        3: 2279:          else if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)
        -: 2280:          {
    #####: 2281:            parser_emit_cbc_literal (context_p, CBC_CREATE_LOCAL, map_to);
    #####: 2282:            scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;
        -: 2283:          }
        -: 2284:#endif /* ENABLED (JERRY_ES2015) */
        -: 2285:
        3: 2286:          if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2287:          {
        3: 2288:            scope_stack_reg_top++;
        -: 2289:          }
        3: 2290:          break;
        -: 2291:        }
        -: 2292:      }
        -: 2293:
        -: 2294:#if ENABLED (JERRY_ES2015)
       18: 2295:      scope_stack_p->map_to = scope_stack_map_to;
        -: 2296:#endif /* ENABLED (JERRY_ES2015) */
        -: 2297:    }
        -: 2298:
       18: 2299:    scope_stack_p++;
        -: 2300:
       18: 2301:    if (!SCANNER_STREAM_TYPE_IS_FUNCTION (type))
        -: 2302:    {
       16: 2303:      continue;
        -: 2304:    }
        -: 2305:
        2: 2306:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2307:    {
    #####: 2308:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2309:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2310:    }
        -: 2311:
        -: 2312:#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)
        -: 2313:    context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2314:#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */
        -: 2315:
        2: 2316:    if (!SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 2317:    {
        2: 2318:      if (func_init_opcode == CBC_INIT_ARG_OR_FUNC && (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT))
        -: 2319:      {
        -: 2320:#if ENABLED (JERRY_ES2015)
        1: 2321:        literal.char_p -= data_p[1];
        1: 2322:        if (!(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL)
    #####: 2323:            || !scanner_scope_find_let_declaration (context_p, &literal))
        -: 2324:        {
        1: 2325:          func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;
        -: 2326:        }
        1: 2327:        literal.char_p += data_p[1];
        -: 2328:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2329:        func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;
        -: 2330:#endif /* ENABLED (JERRY_ES2015) */
        -: 2331:      }
        -: 2332:
        2: 2333:      parser_emit_cbc_literal_value (context_p, func_init_opcode, context_p->literal_count, map_to);
        -: 2334:    }
        -: 2335:
        2: 2336:    scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;
        2: 2337:    scope_stack_p->map_to = context_p->literal_count;
        2: 2338:    scope_stack_p++;
        -: 2339:
        2: 2340:    scanner_create_unused_literal (context_p, 0);
        -: 2341:  }
        -: 2342:
     1302: 2343:  if (info_type == SCANNER_TYPE_FUNCTION
     1301: 2344:      && !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
     1300: 2345:      && (info_u8_arg & SCANNER_FUNCTION_ARGUMENTS_NEEDED))
        -: 2346:  {
        2: 2347:    JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);
        -: 2348:
        2: 2349:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2350:    {
    #####: 2351:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2352:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2353:    }
        -: 2354:
        2: 2355:    context_p->status_flags |= PARSER_ARGUMENTS_NEEDED | PARSER_LEXICAL_ENV_NEEDED;
        -: 2356:
        2: 2357:    lexer_construct_literal_object (context_p, &lexer_arguments_literal, lexer_arguments_literal.type);
        -: 2358:
        2: 2359:    scope_stack_p->map_from = context_p->lit_object.index;
        -: 2360:#if ENABLED (JERRY_ES2015)
        2: 2361:    scope_stack_p->map_to = 0;
        -: 2362:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2363:    scope_stack_p->map_to = context_p->lit_object.index;
        -: 2364:#endif /* ENABLED (JERRY_ES2015) */
        2: 2365:    scope_stack_p++;
        -: 2366:  }
        -: 2367:
     1302: 2368:  context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
     1302: 2369:  context_p->scope_stack_reg_top = (uint16_t) scope_stack_reg_top;
        -: 2370:
        -: 2371:#if ENABLED (JERRY_ES2015)
     1302: 2372:  if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2373:  {
     1301: 2374:    context_p->scope_stack_global_end = context_p->scope_stack_top;
        -: 2375:  }
        -: 2376:#endif /* ENABLED (JERRY_ES2015) */
        -: 2377:
     1302: 2378:  if (context_p->register_count < scope_stack_reg_top)
        -: 2379:  {
        1: 2380:    context_p->register_count = (uint16_t) scope_stack_reg_top;
        -: 2381:  }
        -: 2382:
     1302: 2383:  if (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))
        -: 2384:  {
     1301: 2385:    scanner_release_next (context_p, (size_t) (next_data_p + 1 - ((const uint8_t *) info_p)));
        -: 2386:  }
     1302: 2387:  parser_flush_cbc (context_p);
     1302: 2388:} /* scanner_create_variables */
        -: 2389:
        -: 2390:/**
        -: 2391: * Get location from context.
        -: 2392: */
        -: 2393:inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 2394:scanner_get_location (scanner_location_t *location_p, /**< location */
        -: 2395:                      parser_context_t *context_p) /**< context */
        -: 2396:{
    #####: 2397:  location_p->source_p = context_p->source_p;
    #####: 2398:  location_p->line = context_p->line;
    #####: 2399:  location_p->column = context_p->column;
    #####: 2400:} /* scanner_get_location */
        -: 2401:
        -: 2402:/**
        -: 2403: * Set context location.
        -: 2404: */
        -: 2405:inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 2406:scanner_set_location (parser_context_t *context_p, /**< context */
        -: 2407:                      scanner_location_t *location_p) /**< location */
        -: 2408:{
    #####: 2409:  context_p->source_p = location_p->source_p;
    #####: 2410:  context_p->line = location_p->line;
    #####: 2411:  context_p->column = location_p->column;
    #####: 2412:} /* scanner_set_location */
        -: 2413:
        -: 2414:/**
        -: 2415: * Get the real map_to value.
        -: 2416: */
        -: 2417:inline uint16_t JERRY_ATTR_ALWAYS_INLINE
       62: 2418:scanner_decode_map_to (parser_scope_stack_t *stack_item_p) /**< scope stack item */
        -: 2419:{
       62: 2420:  JERRY_ASSERT (stack_item_p->map_from != PARSER_SCOPE_STACK_FUNC);
        -: 2421:
        -: 2422:#if ENABLED (JERRY_ES2015)
       62: 2423:  uint16_t value = (stack_item_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK);
       62: 2424:  return (value == 0) ? stack_item_p->map_from : (uint16_t) (value + (PARSER_REGISTER_START - 1));
        -: 2425:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2426:  return stack_item_p->map_to;
        -: 2427:#endif /* ENABLED (JERRY_ES2015) */
        -: 2428:} /* scanner_decode_map_to */
        -: 2429:
        -: 2430:#if ENABLED (JERRY_ES2015)
        -: 2431:
        -: 2432:/**
        -: 2433: * Checks whether the literal is a const in the current scope.
        -: 2434: *
        -: 2435: * @return true if the literal is a const, false otherwise
        -: 2436: */
        -: 2437:bool
        1: 2438:scanner_literal_is_const_reg (parser_context_t *context_p, /**< context */
        -: 2439:                              uint16_t literal_index) /**< literal index */
        -: 2440:{
        1: 2441:  if (literal_index < PARSER_REGISTER_START)
        -: 2442:  {
        -: 2443:    /* Re-assignment of non-register const bindings are detected elsewhere. */
        1: 2444:    return false;
        -: 2445:  }
        -: 2446:
    #####: 2447:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 2448:
    #####: 2449:  literal_index = (uint16_t) (literal_index - (PARSER_REGISTER_START - 1));
        -: 2450:
        -: 2451:  do
        -: 2452:  {
        -: 2453:    /* Registers must be found in the scope stack. */
    #####: 2454:    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
    #####: 2455:    scope_stack_p--;
        -: 2456:  }
    #####: 2457:  while (literal_index != (scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK));
        -: 2458:
    #####: 2459:  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_CONST_REG) != 0;
        -: 2460:} /* scanner_literal_is_const_reg */
        -: 2461:
        -: 2462:/**
        -: 2463: * Checks whether the literal is created before.
        -: 2464: *
        -: 2465: * @return true if the literal is created before, false otherwise
        -: 2466: */
        -: 2467:bool
        3: 2468:scanner_literal_is_created (parser_context_t *context_p, /**< context */
        -: 2469:                            uint16_t literal_index) /**< literal index */
        -: 2470:{
        3: 2471:  JERRY_ASSERT (literal_index < PARSER_REGISTER_START);
        -: 2472:
        3: 2473:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 2474:
        -: 2475:  do
        -: 2476:  {
        -: 2477:    /* These literals must be found in the scope stack. */
        9: 2478:    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
        9: 2479:    scope_stack_p--;
        -: 2480:  }
        9: 2481:  while (literal_index != scope_stack_p->map_from);
        -: 2482:
        3: 2483:  JERRY_ASSERT ((scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0);
        -: 2484:
        3: 2485:  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_LOCAL_CREATED) != 0;
        -: 2486:} /* scanner_literal_is_created */
        -: 2487:
        -: 2488:#endif /* ENABLED (JERRY_ES2015) */
        -: 2489:
        -: 2490:/**
        -: 2491: * @}
        -: 2492: * @}
        -: 2493: * @}
        -: 2494: */
        -: 2495:
        -: 2496:#endif /* ENABLED (JERRY_PARSER) */
