        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-objects.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-array-object.h"
        -:   17:#include "ecma-builtins.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-gc.h"
        -:   21:#include "ecma-globals.h"
        -:   22:#include "ecma-helpers.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-lex-env.h"
        -:   25:#include "ecma-string-object.h"
        -:   26:#include "ecma-objects-arguments.h"
        -:   27:#include "ecma-objects-general.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-proxy-object.h"
        -:   30:#include "jcontext.h"
        -:   31:
        -:   32:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -:   33:#include "ecma-typedarray-object.h"
        -:   34:#include "ecma-arraybuffer-object.h"
        -:   35:#include "ecma-try-catch-macro.h"
        -:   36:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -:   37:
        -:   38:/** \addtogroup ecma ECMA
        -:   39: * @{
        -:   40: *
        -:   41: * \addtogroup ecmaobjectsinternalops ECMA objects' operations
        -:   42: * @{
        -:   43: */
        -:   44:
        -:   45:/**
        -:   46: * Hash bitmap size for ecma objects
        -:   47: */
        -:   48:#define ECMA_OBJECT_HASH_BITMAP_SIZE 256
        -:   49:
        -:   50:/**
        -:   51: * Assert that specified object type value is valid
        -:   52: *
        -:   53: * @param type object's implementation-defined type
        -:   54: */
        -:   55:#ifndef JERRY_NDEBUG
        -:   56:#define JERRY_ASSERT_OBJECT_TYPE_IS_VALID(type) \
        -:   57:  JERRY_ASSERT (type < ECMA_OBJECT_TYPE__MAX);
        -:   58:#else /* JERRY_NDEBUG */
        -:   59:#define JERRY_ASSERT_OBJECT_TYPE_IS_VALID(type)
        -:   60:#endif /* !JERRY_NDEBUG */
        -:   61:
        -:   62:/**
        -:   63: * [[GetOwnProperty]] ecma object's operation
        -:   64: *
        -:   65: * See also:
        -:   66: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:   67: *
        -:   68: * @return pointer to a property - if it exists,
        -:   69: *         NULL (i.e. ecma-undefined) - otherwise.
        -:   70: */
        -:   71:ecma_property_t
    22264:   72:ecma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */
        -:   73:                                 ecma_string_t *property_name_p, /**< property name */
        -:   74:                                 ecma_property_ref_t *property_ref_p, /**< property reference */
        -:   75:                                 uint32_t options) /**< option bits */
        -:   76:{
    22264:   77:  JERRY_ASSERT (object_p != NULL
        -:   78:                && !ecma_is_lexical_environment (object_p));
        -:   79:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    22264:   80:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -:   81:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
    22264:   82:  JERRY_ASSERT (property_name_p != NULL);
    22264:   83:  JERRY_ASSERT (options == ECMA_PROPERTY_GET_NO_OPTIONS
        -:   84:                || options == ECMA_PROPERTY_GET_HAS_OWN_PROP
        -:   85:                || property_ref_p != NULL);
        -:   86:
    22264:   87:  ecma_object_type_t type = ecma_get_object_type (object_p);
        -:   88:
    22264:   89:  switch (type)
        -:   90:  {
     5236:   91:    case ECMA_OBJECT_TYPE_CLASS:
        -:   92:    {
     5236:   93:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   94:
     5236:   95:      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)
        -:   96:      {
    #####:   97:        if (ecma_string_is_length (property_name_p))
        -:   98:        {
    #####:   99:          if (options & ECMA_PROPERTY_GET_VALUE)
        -:  100:          {
    #####:  101:            ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;
    #####:  102:            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  103:
    #####:  104:            ecma_length_t length = ecma_string_get_length (prim_value_str_p);
    #####:  105:            property_ref_p->virtual_value = ecma_make_uint32_value (length);
        -:  106:          }
        -:  107:
    #####:  108:          return ECMA_PROPERTY_TYPE_VIRTUAL;
        -:  109:        }
        -:  110:
    #####:  111:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  112:
    #####:  113:        if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  114:        {
    #####:  115:          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;
    #####:  116:          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  117:
    #####:  118:          if (index < ecma_string_get_length (prim_value_str_p))
        -:  119:          {
    #####:  120:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  121:            {
    #####:  122:              ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);
    #####:  123:              ecma_string_t *char_str_p = ecma_new_ecma_string_from_code_unit (char_at_idx);
    #####:  124:              property_ref_p->virtual_value = ecma_make_string_value (char_str_p);
        -:  125:            }
        -:  126:
    #####:  127:            return ECMA_PROPERTY_FLAG_ENUMERABLE | ECMA_PROPERTY_TYPE_VIRTUAL;
        -:  128:          }
        -:  129:        }
        -:  130:      }
     5236:  131:      break;
        -:  132:    }
     2618:  133:    case ECMA_OBJECT_TYPE_ARRAY:
        -:  134:    {
     2618:  135:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  136:
     2618:  137:      if (ecma_string_is_length (property_name_p))
        -:  138:      {
    #####:  139:        if (options & ECMA_PROPERTY_GET_VALUE)
        -:  140:        {
    #####:  141:          property_ref_p->virtual_value = ecma_make_uint32_value (ext_object_p->u.array.length);
        -:  142:        }
        -:  143:
    #####:  144:        return ext_object_p->u.array.u.length_prop & (ECMA_PROPERTY_TYPE_VIRTUAL | ECMA_PROPERTY_FLAG_WRITABLE);
        -:  145:      }
        -:  146:
     2618:  147:      if (ecma_op_array_is_fast_array (ext_object_p))
        -:  148:      {
    #####:  149:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  150:
    #####:  151:        if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  152:        {
    #####:  153:          if (JERRY_LIKELY (index < ext_object_p->u.array.length))
        -:  154:          {
    #####:  155:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  156:
    #####:  157:            if (ecma_is_value_array_hole (values_p[index]))
        -:  158:            {
    #####:  159:              return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  160:            }
        -:  161:
    #####:  162:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  163:            {
    #####:  164:              property_ref_p->virtual_value = ecma_fast_copy_value (values_p[index]);
        -:  165:            }
        -:  166:
    #####:  167:            return (ecma_property_t) (ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL);
        -:  168:          }
        -:  169:        }
        -:  170:
    #####:  171:        return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  172:      }
        -:  173:
     2618:  174:      break;
        -:  175:    }
        -:  176:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####:  177:    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:
        -:  178:    {
        -:  179:      /* ES2015 9.4.5.1 */
    #####:  180:      if (ecma_object_is_typedarray (object_p))
        -:  181:      {
        -:  182:#if ENABLED (JERRY_ES2015)
    #####:  183:        if (ecma_prop_name_is_symbol (property_name_p))
        -:  184:        {
    #####:  185:          break;
        -:  186:        }
        -:  187:#endif /* ENABLED (JERRY_ES2015) */
        -:  188:
    #####:  189:        uint32_t array_index = ecma_string_get_array_index (property_name_p);
        -:  190:
    #####:  191:        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  192:        {
    #####:  193:          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
    #####:  194:          ecma_value_t value = ECMA_VALUE_UNDEFINED;
        -:  195:
    #####:  196:          if (array_index < info.length)
        -:  197:          {
    #####:  198:            ecma_length_t byte_pos = array_index << info.shift;
    #####:  199:            ecma_number_t num = ecma_get_typedarray_element (info.buffer_p + byte_pos, info.id);
    #####:  200:            value = ecma_make_number_value (num);
        -:  201:          }
        -:  202:
    #####:  203:          if (!ecma_is_value_undefined (value))
        -:  204:          {
    #####:  205:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  206:            {
    #####:  207:              property_ref_p->virtual_value = value;
        -:  208:            }
        -:  209:            else
        -:  210:            {
    #####:  211:              ecma_fast_free_value (value);
        -:  212:            }
        -:  213:
    #####:  214:            return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_TYPE_VIRTUAL;
        -:  215:          }
        -:  216:
    #####:  217:          return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -:  218:        }
        -:  219:
    #####:  220:        ecma_number_t num = ecma_string_to_number (property_name_p);
    #####:  221:        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
        -:  222:
    #####:  223:        if (ecma_compare_ecma_strings (property_name_p, num_to_str))
        -:  224:        {
    #####:  225:          ecma_deref_ecma_string (num_to_str);
        -:  226:
    #####:  227:          return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -:  228:        }
        -:  229:
    #####:  230:        ecma_deref_ecma_string (num_to_str);
        -:  231:      }
        -:  232:
    #####:  233:      break;
        -:  234:    }
        -:  235:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
    14410:  236:    default:
        -:  237:    {
    14410:  238:      break;
        -:  239:    }
        -:  240:  }
        -:  241:
    22264:  242:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -:  243:
    22264:  244:  if (property_p == NULL)
        -:  245:  {
    22263:  246:    if (ecma_get_object_is_builtin (object_p))
        -:  247:    {
    13100:  248:      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))
        -:  249:      {
    #####:  250:        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
        -:  251:      }
        -:  252:      else
        -:  253:      {
    13100:  254:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
        -:  255:      }
        -:  256:    }
     9163:  257:    else if (type == ECMA_OBJECT_TYPE_FUNCTION)
        -:  258:    {
        -:  259:#if !ENABLED (JERRY_ES2015)
    #####:  260:      if (ecma_string_is_length (property_name_p))
        -:  261:      {
    #####:  262:        if (options & ECMA_PROPERTY_GET_VALUE)
        -:  263:        {
        -:  264:          /* Get length virtual property. */
    #####:  265:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
    #####:  266:          const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);
        -:  267:
        -:  268:          uint32_t len;
    #####:  269:          if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  270:          {
    #####:  271:            cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;
    #####:  272:            len = args_p->argument_end;
        -:  273:          }
        -:  274:          else
        -:  275:          {
    #####:  276:            cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;
    #####:  277:            len = args_p->argument_end;
        -:  278:          }
        -:  279:
    #####:  280:          property_ref_p->virtual_value = ecma_make_uint32_value (len);
        -:  281:        }
        -:  282:
    #####:  283:        return ECMA_PROPERTY_TYPE_VIRTUAL;
        -:  284:      }
        -:  285:#endif /* !ENABLED (JERRY_ES2015) */
        -:  286:
        -:  287:      /* Get prototype physical property. */
    #####:  288:      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  289:    }
     9163:  290:    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)
        -:  291:    {
     2618:  292:      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  293:    }
     6545:  294:    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)
        -:  295:    {
    #####:  296:      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  297:    }
        -:  298:
    22263:  299:    if (property_p == NULL)
        -:  300:    {
    22262:  301:      return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  302:    }
        -:  303:  }
        1:  304:  else if (type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY
    #####:  305:           && (options & ECMA_PROPERTY_GET_HAS_OWN_PROP))
        -:  306:  {
    #####:  307:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  308:
    #####:  309:    if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)
        -:  310:    {
    #####:  311:      uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  312:
    #####:  313:      if (index != ECMA_STRING_NOT_ARRAY_INDEX
    #####:  314:          && index < ext_object_p->u.pseudo_array.u1.length)
        -:  315:      {
    #####:  316:        ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);
        -:  317:
    #####:  318:        if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)
        -:  319:        {
    #####:  320:          ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);
        -:  321:
    #####:  322:          ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,
        -:  323:                                                                      ext_object_p->u.pseudo_array.u2.lex_env_cp);
        -:  324:
    #####:  325:          JERRY_ASSERT (lex_env_p != NULL
        -:  326:                        && ecma_is_lexical_environment (lex_env_p));
        -:  327:
    #####:  328:          ecma_value_t binding_value = ecma_op_get_binding_value (lex_env_p, arg_name_p, true);
        -:  329:
    #####:  330:          ecma_named_data_property_assign_value (object_p,
    #####:  331:                                                 ECMA_PROPERTY_VALUE_PTR (property_p),
        -:  332:                                                 binding_value);
    #####:  333:          ecma_free_value (binding_value);
        -:  334:        }
        -:  335:      }
        -:  336:    }
        -:  337:  }
        -:  338:
        2:  339:  if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)
        -:  340:  {
    #####:  341:    ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;
        -:  342:  }
        -:  343:
        2:  344:  if (property_ref_p != NULL)
        -:  345:  {
        1:  346:    property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  347:  }
        -:  348:
        2:  349:  return *property_p;
        -:  350:} /* ecma_op_object_get_own_property */
        -:  351:
        -:  352:/**
        -:  353: * [[GetProperty]] ecma object's operation
        -:  354: *
        -:  355: * See also:
        -:  356: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  357: *
        -:  358: * @return pointer to a property - if it exists,
        -:  359: *         NULL (i.e. ecma-undefined) - otherwise.
        -:  360: */
        -:  361:static ecma_property_t
    13093:  362:ecma_op_object_get_property (ecma_object_t *object_p, /**< the object */
        -:  363:                             ecma_string_t *property_name_p, /**< property name */
        -:  364:                             ecma_property_ref_t *property_ref_p, /**< property reference */
        -:  365:                             uint32_t options) /**< option bits */
        -:  366:{
        -:  367:  while (true)
     6544:  368:  {
    13093:  369:    ecma_property_t property = ecma_op_object_get_own_property (object_p,
        -:  370:                                                                property_name_p,
        -:  371:                                                                property_ref_p,
        -:  372:                                                                options);
        -:  373:
    13093:  374:    if (property != ECMA_PROPERTY_TYPE_NOT_FOUND && property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)
        -:  375:    {
        1:  376:      return property;
        -:  377:    }
        -:  378:
    13092:  379:    if (property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)
        -:  380:    {
    #####:  381:      break;
        -:  382:    }
        -:  383:
    13092:  384:    if (object_p->u2.prototype_cp == JMEM_CP_NULL)
        -:  385:    {
     6548:  386:      break;
        -:  387:    }
        -:  388:
     6544:  389:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u2.prototype_cp);
        -:  390:  }
        -:  391:
     6548:  392:  return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  393:} /* ecma_op_object_get_property */
        -:  394:
        -:  395:/**
        -:  396: * Generic [[HasProperty]] operation
        -:  397: *
        -:  398: * See also:
        -:  399: *          ECMAScript v6, 9.1.7.1
        -:  400: *
        -:  401: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  402: *         ECMA_VALUE_{TRUE_FALSE} - whether the property is found
        -:  403: */
        -:  404:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
        3:  405:ecma_op_object_has_property (ecma_object_t *object_p, /**< the object */
        -:  406:                             ecma_string_t *property_name_p) /**< property name */
        -:  407:{
        -:  408:  while (true)
        1:  409:  {
        -:  410:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
        3:  411:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  412:    {
    #####:  413:      return ecma_proxy_object_has (object_p, property_name_p);
        -:  414:    }
        -:  415:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -:  416:
        -:  417:    /* 2 - 3. */
        3:  418:    if (ecma_op_ordinary_object_has_own_property (object_p, property_name_p))
        -:  419:    {
        1:  420:      return ECMA_VALUE_TRUE;
        -:  421:    }
        -:  422:
        2:  423:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);
        -:  424:
        -:  425:    /* 7. */
        2:  426:    if (proto_cp == JMEM_CP_NULL)
        -:  427:    {
        1:  428:      return ECMA_VALUE_FALSE;
        -:  429:    }
        -:  430:
        1:  431:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
        -:  432:  }
        -:  433:} /* ecma_op_object_has_property */
        -:  434:
        -:  435:/**
        -:  436: * Search the value corresponding to a property name
        -:  437: *
        -:  438: * Note: search includes prototypes
        -:  439: *
        -:  440: * @return ecma value if property is found
        -:  441: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  442: *         Returned value must be freed with ecma_free_value
        -:  443: */
        -:  444:ecma_value_t
    14415:  445:ecma_op_object_find_own (ecma_value_t base_value, /**< base value */
        -:  446:                         ecma_object_t *object_p, /**< target object */
        -:  447:                         ecma_string_t *property_name_p) /**< property name */
        -:  448:{
    14415:  449:  JERRY_ASSERT (object_p != NULL
        -:  450:                && !ecma_is_lexical_environment (object_p));
    14415:  451:  JERRY_ASSERT (property_name_p != NULL);
    14415:  452:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -:  453:
    14415:  454:  ecma_object_type_t type = ecma_get_object_type (object_p);
        -:  455:
    14415:  456:  switch (type)
        -:  457:  {
    #####:  458:    case ECMA_OBJECT_TYPE_CLASS:
        -:  459:    {
    #####:  460:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  461:
    #####:  462:      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)
        -:  463:      {
    #####:  464:        if (ecma_string_is_length (property_name_p))
        -:  465:        {
    #####:  466:          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;
        -:  467:
    #####:  468:          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
    #####:  469:          ecma_length_t length = ecma_string_get_length (prim_value_str_p);
        -:  470:
    #####:  471:          return ecma_make_uint32_value (length);
        -:  472:        }
        -:  473:
    #####:  474:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  475:
    #####:  476:        if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  477:        {
    #####:  478:          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;
        -:  479:
    #####:  480:          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  481:
    #####:  482:          if (index < ecma_string_get_length (prim_value_str_p))
        -:  483:          {
    #####:  484:            ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);
    #####:  485:            return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));
        -:  486:          }
        -:  487:        }
        -:  488:      }
        -:  489:
    #####:  490:      break;
        -:  491:    }
    #####:  492:    case ECMA_OBJECT_TYPE_ARRAY:
        -:  493:    {
    #####:  494:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  495:
    #####:  496:      if (ecma_string_is_length (property_name_p))
        -:  497:      {
    #####:  498:        return ecma_make_uint32_value (ext_object_p->u.array.length);
        -:  499:      }
        -:  500:
    #####:  501:      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))
        -:  502:      {
    #####:  503:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  504:
    #####:  505:        if (JERRY_LIKELY (index != ECMA_STRING_NOT_ARRAY_INDEX))
        -:  506:        {
    #####:  507:          if (JERRY_LIKELY (index < ext_object_p->u.array.length))
        -:  508:          {
    #####:  509:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  510:
    #####:  511:            return (ecma_is_value_array_hole (values_p[index]) ? ECMA_VALUE_NOT_FOUND
    #####:  512:                                                               : ecma_fast_copy_value (values_p[index]));
        -:  513:          }
        -:  514:        }
    #####:  515:        return ECMA_VALUE_NOT_FOUND;
        -:  516:      }
        -:  517:
    #####:  518:      break;
        -:  519:    }
    #####:  520:    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:
        -:  521:    {
    #####:  522:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  523:
    #####:  524:      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)
        -:  525:      {
    #####:  526:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  527:
    #####:  528:        if (index != ECMA_STRING_NOT_ARRAY_INDEX
    #####:  529:            && index < ext_object_p->u.pseudo_array.u1.length)
        -:  530:        {
    #####:  531:          ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);
        -:  532:
    #####:  533:          if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)
        -:  534:          {
    #####:  535:            ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);
        -:  536:
    #####:  537:            ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,
        -:  538:                                                                        ext_object_p->u.pseudo_array.u2.lex_env_cp);
        -:  539:
    #####:  540:            JERRY_ASSERT (lex_env_p != NULL
        -:  541:                          && ecma_is_lexical_environment (lex_env_p));
        -:  542:
    #####:  543:            return ecma_op_get_binding_value (lex_env_p, arg_name_p, true);
        -:  544:          }
        -:  545:        }
        -:  546:      }
        -:  547:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -:  548:      /* ES2015 9.4.5.4 */
    #####:  549:      if (ecma_object_is_typedarray (object_p))
        -:  550:      {
        -:  551:#if ENABLED (JERRY_ES2015)
    #####:  552:        if (ecma_prop_name_is_symbol (property_name_p))
        -:  553:        {
    #####:  554:          break;
        -:  555:        }
        -:  556:#endif /* ENABLED (JERRY_ES2015) */
        -:  557:
    #####:  558:        uint32_t array_index = ecma_string_get_array_index (property_name_p);
        -:  559:
    #####:  560:        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  561:        {
    #####:  562:          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
        -:  563:
    #####:  564:          if (array_index >= info.length)
        -:  565:          {
    #####:  566:            return ECMA_VALUE_UNDEFINED;
        -:  567:          }
        -:  568:
    #####:  569:          ecma_length_t byte_pos = array_index << info.shift;
    #####:  570:          ecma_number_t num = ecma_get_typedarray_element (info.buffer_p + byte_pos, info.id);
    #####:  571:          return ecma_make_number_value (num);
        -:  572:        }
        -:  573:
    #####:  574:        ecma_number_t num = ecma_string_to_number (property_name_p);
    #####:  575:        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
        -:  576:
    #####:  577:        if (ecma_compare_ecma_strings (property_name_p, num_to_str))
        -:  578:        {
    #####:  579:          ecma_deref_ecma_string (num_to_str);
        -:  580:
    #####:  581:          return ECMA_VALUE_UNDEFINED;
        -:  582:        }
        -:  583:
    #####:  584:        ecma_deref_ecma_string (num_to_str);
        -:  585:      }
        -:  586:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -:  587:
    #####:  588:      break;
        -:  589:    }
    14415:  590:    default:
        -:  591:    {
    14415:  592:      break;
        -:  593:    }
        -:  594:  }
        -:  595:
    14415:  596:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -:  597:
    14415:  598:  if (property_p == NULL)
        -:  599:  {
     6555:  600:    if (ecma_get_object_is_builtin (object_p))
        -:  601:    {
     6555:  602:      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))
        -:  603:      {
    #####:  604:        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
        -:  605:      }
        -:  606:      else
        -:  607:      {
     6555:  608:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
        -:  609:      }
        -:  610:    }
    #####:  611:    else if (type == ECMA_OBJECT_TYPE_FUNCTION)
        -:  612:    {
        -:  613:#if !ENABLED (JERRY_ES2015)
    #####:  614:      if (ecma_string_is_length (property_name_p))
        -:  615:      {
        -:  616:        /* Get length virtual property. */
    #####:  617:        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
    #####:  618:        const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);
        -:  619:
        -:  620:        uint32_t len;
    #####:  621:        if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  622:        {
    #####:  623:          cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;
    #####:  624:          len = args_p->argument_end;
        -:  625:        }
        -:  626:        else
        -:  627:        {
    #####:  628:          cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;
    #####:  629:          len = args_p->argument_end;
        -:  630:        }
        -:  631:
    #####:  632:        return ecma_make_uint32_value (len);
        -:  633:      }
        -:  634:#endif /* !ENABLED (JERRY_ES2015) */
        -:  635:
        -:  636:      /* Get prototype physical property. */
    #####:  637:      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  638:    }
    #####:  639:    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)
        -:  640:    {
    #####:  641:      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  642:    }
    #####:  643:    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)
        -:  644:    {
    #####:  645:      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  646:    }
        -:  647:
     6555:  648:    if (property_p == NULL)
        -:  649:    {
     6545:  650:      return ECMA_VALUE_NOT_FOUND;
        -:  651:    }
        -:  652:  }
        -:  653:
     7870:  654:  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  655:
     7870:  656:  if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)
        -:  657:  {
     7870:  658:    return ecma_fast_copy_value (prop_value_p->value);
        -:  659:  }
        -:  660:
    #####:  661:  JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);
        -:  662:
    #####:  663:  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);
        -:  664:
    #####:  665:  if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -:  666:  {
    #####:  667:    return ECMA_VALUE_UNDEFINED;
        -:  668:  }
        -:  669:
    #####:  670:  ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
        -:  671:
    #####:  672:  return ecma_op_function_call (getter_p, base_value, NULL, 0);
        -:  673:} /* ecma_op_object_find_own */
        -:  674:
        -:  675:/**
        -:  676: * Search the value corresponding to an uint32_t property index
        -:  677: *
        -:  678: * Note: this method falls back to the general ecma_op_object_find
        -:  679: *
        -:  680: * @return ecma value if property is found
        -:  681: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  682: *         Returned value must be freed with ecma_free_value
        -:  683: */
        -:  684:ecma_value_t
    #####:  685:ecma_op_object_find_by_uint32_index (ecma_object_t *object_p, /**< the object */
        -:  686:                                     uint32_t index) /**< property index */
        -:  687:{
    #####:  688:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  689:  {
    #####:  690:    return ecma_op_object_find (object_p, ECMA_CREATE_DIRECT_UINT32_STRING (index));
        -:  691:  }
        -:  692:
    #####:  693:  ecma_string_t *index_str_p = ecma_new_non_direct_string_from_uint32 (index);
    #####:  694:  ecma_value_t ret_value = ecma_op_object_find (object_p, index_str_p);
    #####:  695:  ecma_deref_ecma_string (index_str_p);
        -:  696:
    #####:  697:  return ret_value;
        -:  698:} /* ecma_op_object_find_by_uint32_index */
        -:  699:
        -:  700:/**
        -:  701: * Search the value corresponding to an ecma_number_t property index
        -:  702: *
        -:  703: * Note: this method falls back to the general ecma_op_object_find
        -:  704: *
        -:  705: * @return ecma value if property is found
        -:  706: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  707: *         Returned value must be freed with ecma_free_value
        -:  708: */
        -:  709:ecma_value_t
    #####:  710:ecma_op_object_find_by_number_index (ecma_object_t *object_p, /**< the object */
        -:  711:                                     ecma_number_t index) /**< property index */
        -:  712:{
    #####:  713:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (index);
    #####:  714:  ecma_value_t ret_value = ecma_op_object_find (object_p, index_str_p);
    #####:  715:  ecma_deref_ecma_string (index_str_p);
        -:  716:
    #####:  717:  return ret_value;
        -:  718:} /* ecma_op_object_find_by_number_index */
        -:  719:
        -:  720:/**
        -:  721: * Search the value corresponding to a property name
        -:  722: *
        -:  723: * Note: search includes prototypes
        -:  724: *
        -:  725: * @return ecma value if property is found
        -:  726: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  727: *         Returned value must be freed with ecma_free_value
        -:  728: */
        -:  729:ecma_value_t
       13:  730:ecma_op_object_find (ecma_object_t *object_p, /**< the object */
        -:  731:                     ecma_string_t *property_name_p) /**< property name */
        -:  732:{
       13:  733:  ecma_value_t base_value = ecma_make_object_value (object_p);
        -:  734:
        -:  735:  while (true)
    #####:  736:  {
        -:  737:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
       13:  738:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  739:    {
    #####:  740:      return ecma_proxy_object_find (object_p, property_name_p);
        -:  741:    }
        -:  742:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -:  743:
       13:  744:    ecma_value_t value = ecma_op_object_find_own (base_value, object_p, property_name_p);
        -:  745:
       13:  746:    if (ecma_is_value_found (value))
        -:  747:    {
       13:  748:      return value;
        -:  749:    }
        -:  750:
    #####:  751:    if (object_p->u2.prototype_cp == JMEM_CP_NULL)
        -:  752:    {
    #####:  753:      break;
        -:  754:    }
        -:  755:
    #####:  756:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u2.prototype_cp);
        -:  757:  }
        -:  758:
    #####:  759:  return ECMA_VALUE_NOT_FOUND;
        -:  760:} /* ecma_op_object_find */
        -:  761:
        -:  762:/**
        -:  763: * Get own property by name
        -:  764: *
        -:  765: * Note: property must be an existing data property
        -:  766: *
        -:  767: * @return ecma value
        -:  768: *         Returned value must be freed with ecma_free_value
        -:  769: */
        -:  770:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  771:ecma_op_object_get_own_data_prop (ecma_object_t *object_p, /**< the object */
        -:  772:                                  ecma_string_t *property_name_p) /**< property name */
        -:  773:{
    #####:  774:  JERRY_ASSERT (ecma_is_lexical_environment (object_p)
        -:  775:                || !ecma_op_object_is_fast_array (object_p));
        -:  776:
    #####:  777:  ecma_value_t result = ecma_op_object_find_own (ecma_make_object_value (object_p),
        -:  778:                                                 object_p,
        -:  779:                                                 property_name_p);
        -:  780:
        -:  781:#ifndef JERRY_NDEBUG
        -:  782:  /* Because ecma_op_object_find_own might create a property
        -:  783:   * this check is executed after the function return. */
    #####:  784:  ecma_property_t *property_p = ecma_find_named_property (object_p,
        -:  785:                                                          property_name_p);
        -:  786:
    #####:  787:  JERRY_ASSERT (property_p != NULL
        -:  788:                && ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA
        -:  789:                && !ecma_is_property_configurable (*property_p));
        -:  790:#endif /* !JERRY_NDEBUG */
        -:  791:
    #####:  792:  return result;
        -:  793:} /* ecma_op_object_get_own_data_prop */
        -:  794:
        -:  795:/**
        -:  796: * [[Get]] operation of ecma object
        -:  797: *
        -:  798: * This function returns the value of a named property, or undefined
        -:  799: * if the property is not found in the prototype chain. If the property
        -:  800: * is an accessor, it calls the "get" callback function and returns
        -:  801: * with its result (including error throws).
        -:  802: *
        -:  803: * See also:
        -:  804: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  805: *
        -:  806: * @return ecma value
        -:  807: *         Returned value must be freed with ecma_free_value
        -:  808: */
        -:  809:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
     1310:  810:ecma_op_object_get (ecma_object_t *object_p, /**< the object */
        -:  811:                    ecma_string_t *property_name_p) /**< property name */
        -:  812:{
     7856:  813:  return ecma_op_object_get_with_receiver (object_p, property_name_p, ecma_make_object_value (object_p));
        -:  814:} /* ecma_op_object_get */
        -:  815:
        -:  816:/**
        -:  817: * [[Get]] operation of ecma object with the specified receiver
        -:  818: *
        -:  819: * This function returns the value of a named property, or undefined
        -:  820: * if the property is not found in the prototype chain. If the property
        -:  821: * is an accessor, it calls the "get" callback function and returns
        -:  822: * with its result (including error throws).
        -:  823: *
        -:  824: * See also:
        -:  825: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  826: *
        -:  827: * @return ecma value
        -:  828: *         Returned value must be freed with ecma_free_value
        -:  829: */
        -:  830:ecma_value_t
    14402:  831:ecma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */
        -:  832:                                  ecma_string_t *property_name_p, /**< property name */
        -:  833:                                  ecma_value_t receiver) /**< receiver to invoke getter function */
        -:  834:{
        -:  835:  while (true)
     6545:  836:  {
        -:  837:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    14402:  838:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  839:    {
    #####:  840:      return ecma_proxy_object_get (object_p, property_name_p, receiver);
        -:  841:    }
        -:  842:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -:  843:
    14402:  844:    ecma_value_t value = ecma_op_object_find_own (receiver, object_p, property_name_p);
        -:  845:
    14402:  846:    if (ecma_is_value_found (value))
        -:  847:    {
     7857:  848:      return value;
        -:  849:    }
        -:  850:
     6545:  851:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);
        -:  852:
     6545:  853:    if (proto_cp == JMEM_CP_NULL)
        -:  854:    {
    #####:  855:      break;
        -:  856:    }
        -:  857:
     6545:  858:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
        -:  859:  }
        -:  860:
    #####:  861:  return ECMA_VALUE_UNDEFINED;
        -:  862:} /* ecma_op_object_get_with_receiver */
        -:  863:
        -:  864:/**
        -:  865: * [[Get]] operation of ecma object specified for uint32_t property index
        -:  866: *
        -:  867: * @return ecma value
        -:  868: *         Returned value must be freed with ecma_free_value
        -:  869: */
        -:  870:ecma_value_t
    #####:  871:ecma_op_object_get_by_uint32_index (ecma_object_t *object_p, /**< the object */
        -:  872:                                    uint32_t index) /**< property index */
        -:  873:{
    #####:  874:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  875:  {
    #####:  876:    return ecma_op_object_get (object_p, ECMA_CREATE_DIRECT_UINT32_STRING (index));
        -:  877:  }
        -:  878:
    #####:  879:  ecma_string_t *index_str_p = ecma_new_non_direct_string_from_uint32 (index);
    #####:  880:  ecma_value_t ret_value = ecma_op_object_get (object_p, index_str_p);
    #####:  881:  ecma_deref_ecma_string (index_str_p);
        -:  882:
    #####:  883:  return ret_value;
        -:  884:} /* ecma_op_object_get_by_uint32_index */
        -:  885:
        -:  886:/**
        -:  887: * Perform ToLength(O.[[Get]]("length")) operation
        -:  888: *
        -:  889: * The property is converted to uint32 during the operation
        -:  890: *
        -:  891: * @return ECMA_VALUE_ERROR - if there was any error during the operation
        -:  892: *         ECMA_VALUE_EMPTY - otherwise
        -:  893: */
        -:  894:ecma_value_t
    #####:  895:ecma_op_object_get_length (ecma_object_t *object_p, /**< the object */
        -:  896:                           uint32_t *length_p) /**< [out] length value converted to uint32 */
        -:  897:{
    #####:  898:  if (JERRY_LIKELY (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY))
        -:  899:  {
    #####:  900:    *length_p = ecma_array_get_length (object_p);
    #####:  901:    return ECMA_VALUE_EMPTY;
        -:  902:  }
        -:  903:
    #####:  904:  ecma_value_t len_value = ecma_op_object_get_by_magic_id (object_p, LIT_MAGIC_STRING_LENGTH);
    #####:  905:  ecma_value_t len_number = ecma_op_to_length (len_value, length_p);
    #####:  906:  ecma_free_value (len_value);
        -:  907:
    #####:  908:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (len_number) || ecma_is_value_empty (len_number));
        -:  909:
    #####:  910:  return len_number;
        -:  911:} /* ecma_op_object_get_length */
        -:  912:
        -:  913:/**
        -:  914: * [[Get]] operation of ecma object where the property name is a magic string
        -:  915: *
        -:  916: * This function returns the value of a named property, or undefined
        -:  917: * if the property is not found in the prototype chain. If the property
        -:  918: * is an accessor, it calls the "get" callback function and returns
        -:  919: * with its result (including error throws).
        -:  920: *
        -:  921: * See also:
        -:  922: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  923: *
        -:  924: * @return ecma value
        -:  925: *         Returned value must be freed with ecma_free_value
        -:  926: */
        -:  927:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
     5236:  928:ecma_op_object_get_by_magic_id (ecma_object_t *object_p, /**< the object */
        -:  929:                                lit_magic_string_id_t property_id) /**< property magic string id */
        -:  930:{
    13092:  931:  return ecma_op_object_get (object_p, ecma_get_magic_string (property_id));
        -:  932:} /* ecma_op_object_get_by_magic_id */
        -:  933:
        -:  934:#if ENABLED (JERRY_ES2015)
        -:  935:/**
        -:  936: * [[Get]] a well-known symbol by the given property id
        -:  937: *
        -:  938: * @return pointer to the requested well-known symbol
        -:  939: */
        -:  940:ecma_string_t *
     1310:  941:ecma_op_get_global_symbol (lit_magic_string_id_t property_id) /**< property symbol id */
        -:  942:{
     2620:  943:  ecma_value_t symbol_value = ecma_op_object_get_by_magic_id (ecma_builtin_get (ECMA_BUILTIN_ID_INTRINSIC_OBJECT),
        -:  944:                                                              property_id);
     1310:  945:  JERRY_ASSERT (ecma_is_value_symbol (symbol_value));
        -:  946:
     1310:  947:  return ecma_get_symbol_from_value (symbol_value);
        -:  948:} /* ecma_op_get_global_symbol */
        -:  949:
        -:  950:/**
        -:  951: * [[Get]] operation of ecma object where the property is a well-known symbol
        -:  952: *
        -:  953: * @return ecma value
        -:  954: *         Returned value must be freed with ecma_free_value
        -:  955: */
        -:  956:ecma_value_t
    #####:  957:ecma_op_object_get_by_symbol_id (ecma_object_t *object_p, /**< the object */
        -:  958:                                 lit_magic_string_id_t property_id) /**< property symbol id */
        -:  959:{
    #####:  960:  ecma_string_t *symbol_p = ecma_op_get_global_symbol (property_id);
    #####:  961:  ecma_value_t ret_value = ecma_op_object_get (object_p, symbol_p);
    #####:  962:  ecma_deref_ecma_string (symbol_p);
        -:  963:
    #####:  964:  return ret_value;
        -:  965:} /* ecma_op_object_get_by_symbol_id */
        -:  966:
        -:  967:/**
        -:  968: * GetMethod operation
        -:  969: *
        -:  970: * See also: ECMA-262 v6, 7.3.9
        -:  971: *
        -:  972: * Note:
        -:  973: *      Returned value must be freed with ecma_free_value.
        -:  974: *
        -:  975: * @return iterator function object - if success
        -:  976: *         raised error - otherwise
        -:  977: */
        -:  978:static ecma_value_t
    #####:  979:ecma_op_get_method (ecma_value_t value, /**< ecma value */
        -:  980:                    ecma_string_t *prop_name_p) /** property name */
        -:  981:{
        -:  982:  /* 2. */
    #####:  983:  ecma_value_t obj_value = ecma_op_to_object (value);
        -:  984:
    #####:  985:  if (ECMA_IS_VALUE_ERROR (obj_value))
        -:  986:  {
    #####:  987:    return obj_value;
        -:  988:  }
        -:  989:
    #####:  990:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
        -:  991:  ecma_value_t func;
        -:  992:
    #####:  993:  func = ecma_op_object_get (obj_p, prop_name_p);
    #####:  994:  ecma_deref_object (obj_p);
        -:  995:
        -:  996:  /* 3. */
    #####:  997:  if (ECMA_IS_VALUE_ERROR (func))
        -:  998:  {
    #####:  999:    return func;
        -: 1000:  }
        -: 1001:
        -: 1002:  /* 4. */
    #####: 1003:  if (ecma_is_value_undefined (func) || ecma_is_value_null (func))
        -: 1004:  {
    #####: 1005:    return ECMA_VALUE_UNDEFINED;
        -: 1006:  }
        -: 1007:
        -: 1008:  /* 5. */
    #####: 1009:  if (!ecma_op_is_callable (func))
        -: 1010:  {
    #####: 1011:    ecma_free_value (func);
    #####: 1012:    return ecma_raise_type_error (ECMA_ERR_MSG ("Iterator is not callable."));
        -: 1013:  }
        -: 1014:
        -: 1015:  /* 6. */
    #####: 1016:  return func;
        -: 1017:} /* ecma_op_get_method */
        -: 1018:
        -: 1019:/**
        -: 1020: * GetMethod operation when the property is a well-known symbol
        -: 1021: *
        -: 1022: * See also: ECMA-262 v6, 7.3.9
        -: 1023: *
        -: 1024: * Note:
        -: 1025: *      Returned value must be freed with ecma_free_value.
        -: 1026: *
        -: 1027: * @return iterator function object - if success
        -: 1028: *         raised error - otherwise
        -: 1029: */
        -: 1030:ecma_value_t
    #####: 1031:ecma_op_get_method_by_symbol_id (ecma_value_t value, /**< ecma value */
        -: 1032:                                 lit_magic_string_id_t symbol_id) /**< property symbol id */
        -: 1033:{
    #####: 1034:  ecma_string_t *prop_name_p = ecma_op_get_global_symbol (symbol_id);
    #####: 1035:  ecma_value_t ret_value = ecma_op_get_method (value, prop_name_p);
    #####: 1036:  ecma_deref_ecma_string (prop_name_p);
        -: 1037:
    #####: 1038:  return ret_value;
        -: 1039:} /* ecma_op_get_method_by_symbol_id */
        -: 1040:
        -: 1041:/**
        -: 1042: * GetMethod operation when the property is a magic string
        -: 1043: *
        -: 1044: * See also: ECMA-262 v6, 7.3.9
        -: 1045: *
        -: 1046: * Note:
        -: 1047: *      Returned value must be freed with ecma_free_value.
        -: 1048: *
        -: 1049: * @return iterator function object - if success
        -: 1050: *         raised error - otherwise
        -: 1051: */
        -: 1052:ecma_value_t
    #####: 1053:ecma_op_get_method_by_magic_id (ecma_value_t value, /**< ecma value */
        -: 1054:                                lit_magic_string_id_t magic_id) /**< property magic id */
        -: 1055:{
    #####: 1056:  return ecma_op_get_method (value, ecma_get_magic_string (magic_id));
        -: 1057:} /* ecma_op_get_method_by_magic_id */
        -: 1058:#endif /* ENABLED (JERRY_ES2015) */
        -: 1059:
        -: 1060:/**
        -: 1061: * [[Put]] ecma general object's operation specialized for uint32_ property index
        -: 1062: *
        -: 1063: * Note: This function falls back to the general ecma_op_object_put
        -: 1064: *
        -: 1065: * @return ecma value
        -: 1066: *         The returned value must be freed with ecma_free_value.
        -: 1067: */
        -: 1068:ecma_value_t
    #####: 1069:ecma_op_object_put_by_uint32_index (ecma_object_t *object_p, /**< the object */
        -: 1070:                                    uint32_t index, /**< property index */
        -: 1071:                                    ecma_value_t value, /**< ecma value */
        -: 1072:                                    bool is_throw) /**< flag that controls failure handling */
        -: 1073:{
    #####: 1074:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -: 1075:  {
    #####: 1076:    return ecma_op_object_put (object_p,
    #####: 1077:                               ECMA_CREATE_DIRECT_UINT32_STRING (index),
        -: 1078:                               value,
        -: 1079:                               is_throw);
        -: 1080:  }
        -: 1081:
    #####: 1082:  ecma_string_t *index_str_p = ecma_new_non_direct_string_from_uint32 (index);
    #####: 1083:  ecma_value_t ret_value = ecma_op_object_put (object_p, index_str_p, value, is_throw);
    #####: 1084:  ecma_deref_ecma_string (index_str_p);
        -: 1085:
    #####: 1086:  return ret_value;
        -: 1087:} /* ecma_op_object_put_by_uint32_index */
        -: 1088:
        -: 1089:/**
        -: 1090: * [[Put]] ecma general object's operation specialized for ecma_number_ property index
        -: 1091: *
        -: 1092: * Note: This function falls back to the general ecma_op_object_put
        -: 1093: *
        -: 1094: * @return ecma value
        -: 1095: *         The returned value must be freed with ecma_free_value.
        -: 1096: */
        -: 1097:ecma_value_t
    #####: 1098:ecma_op_object_put_by_number_index (ecma_object_t *object_p, /**< the object */
        -: 1099:                                    ecma_number_t index, /**< property index */
        -: 1100:                                    ecma_value_t value, /**< ecma value */
        -: 1101:                                    bool is_throw) /**< flag that controls failure handling */
        -: 1102:{
    #####: 1103:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (index);
    #####: 1104:  ecma_value_t ret_value = ecma_op_object_put (object_p, index_str_p, value, is_throw);
    #####: 1105:  ecma_deref_ecma_string (index_str_p);
        -: 1106:
    #####: 1107:  return ret_value;
        -: 1108:} /* ecma_op_object_put_by_number_index */
        -: 1109:
        -: 1110:/**
        -: 1111: * [[Put]] ecma general object's operation
        -: 1112: *
        -: 1113: * See also:
        -: 1114: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1115: *          ECMA-262 v5, 8.12.5
        -: 1116: *          Also incorporates [[CanPut]] ECMA-262 v5, 8.12.4
        -: 1117: *
        -: 1118: * @return ecma value
        -: 1119: *         The returned value must be freed with ecma_free_value.
        -: 1120: *
        -: 1121: *         Returns with ECMA_VALUE_TRUE if the operation is
        -: 1122: *         successful. Otherwise it returns with an error object
        -: 1123: *         or ECMA_VALUE_FALSE.
        -: 1124: *
        -: 1125: *         Note: even if is_throw is false, the setter can throw an
        -: 1126: *         error, and this function returns with that error.
        -: 1127: */
        -: 1128:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
     6550: 1129:ecma_op_object_put (ecma_object_t *object_p, /**< the object */
        -: 1130:                    ecma_string_t *property_name_p, /**< property name */
        -: 1131:                    ecma_value_t value, /**< ecma value */
        -: 1132:                    bool is_throw) /**< flag that controls failure handling */
        -: 1133:{
     6550: 1134:  return ecma_op_object_put_with_receiver (object_p,
        -: 1135:                                           property_name_p,
        -: 1136:                                           value,
        -: 1137:                                           ecma_make_object_value (object_p),
        -: 1138:                                           is_throw);
        -: 1139:} /* ecma_op_object_put */
        -: 1140:
        -: 1141:#if ENABLED (JERRY_ES2015)
        -: 1142:/**
        -: 1143: * [[Set]] ( P, V, Receiver) operation part for ordinary objects
        -: 1144: *
        -: 1145: * See also: ECMAScript v6, 9.19.9
        -: 1146: *
        -: 1147: * @return ecma value
        -: 1148: *         The returned value must be freed with ecma_free_value.
        -: 1149: */
        -: 1150:static ecma_value_t
     6549: 1151:ecma_op_object_put_apply_receiver (ecma_value_t receiver, /**< receiver */
        -: 1152:                                   ecma_string_t *property_name_p, /**< property name */
        -: 1153:                                   ecma_value_t value, /**< value to set */
        -: 1154:                                   bool is_throw) /**< flag that controls failure handling */
        -: 1155:{
        -: 1156:  /* 5.b */
     6549: 1157:  if (!ecma_is_value_object (receiver))
        -: 1158:  {
    #####: 1159:    return ecma_reject (is_throw);
        -: 1160:  }
        -: 1161:
     6549: 1162:  ecma_object_t *receiver_obj_p = ecma_get_object_from_value (receiver);
        -: 1163:
     6549: 1164:  ecma_property_descriptor_t prop_desc;
        -: 1165:  /* 5.c */
     6549: 1166:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (receiver_obj_p,
        -: 1167:                                                                    property_name_p,
        -: 1168:                                                                    &prop_desc);
        -: 1169:
        -: 1170:  /* 5.d */
     6549: 1171:  if (ECMA_IS_VALUE_ERROR (status))
        -: 1172:  {
    #####: 1173:    return status;
        -: 1174:  }
        -: 1175:
        -: 1176:  /* 5.e */
     6549: 1177:  if (ecma_is_value_true (status))
        -: 1178:  {
        -: 1179:    ecma_value_t result;
        -: 1180:
        -: 1181:    /* 5.e.i - 5.e.ii */
    #####: 1182:    if (prop_desc.flags & (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED)
    #####: 1183:        || !(prop_desc.flags & ECMA_PROP_IS_WRITABLE))
        -: 1184:    {
    #####: 1185:      result = ecma_reject (is_throw);
        -: 1186:    }
        -: 1187:    else
        -: 1188:    {
        -: 1189:      /* 5.e.iii */
    #####: 1190:      JERRY_ASSERT (prop_desc.flags & ECMA_PROP_IS_VALUE_DEFINED);
    #####: 1191:      ecma_free_value (prop_desc.value);
    #####: 1192:      prop_desc.value = ecma_copy_value (value);
        -: 1193:
        -: 1194:      /* 5.e.iv */
    #####: 1195:      result = ecma_op_object_define_own_property (receiver_obj_p, property_name_p, &prop_desc);
        -: 1196:    }
        -: 1197:
    #####: 1198:    ecma_free_property_descriptor (&prop_desc);
        -: 1199:
    #####: 1200:    return result;
        -: 1201:  }
        -: 1202:
        -: 1203:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
     6549: 1204:  if (ECMA_OBJECT_IS_PROXY (receiver_obj_p))
        -: 1205:  {
    #####: 1206:    ecma_property_descriptor_t desc;
    #####: 1207:    desc.flags = ECMA_NAME_DATA_PROPERTY_DESCRIPTOR_BITS;
    #####: 1208:    desc.value = value;
    #####: 1209:    return ecma_proxy_object_define_own_property (receiver_obj_p, property_name_p, &desc);
        -: 1210:  }
        -: 1211:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1212:
     6549: 1213:  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (receiver_obj_p)))
        -: 1214:  {
    #####: 1215:    ecma_fast_array_convert_to_normal (receiver_obj_p);
        -: 1216:  }
        -: 1217:
        -: 1218:  /* 5.f.i */
        -: 1219:  ecma_property_value_t *new_prop_value_p;
     6549: 1220:  new_prop_value_p = ecma_create_named_data_property (receiver_obj_p,
        -: 1221:                                                      property_name_p,
        -: 1222:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 1223:                                                      NULL);
     6549: 1224:  JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));
     6549: 1225:  new_prop_value_p->value = ecma_copy_value_if_not_object (value);
        -: 1226:
     6549: 1227:  return ECMA_VALUE_TRUE;
        -: 1228:} /* ecma_op_object_put_apply_receiver */
        -: 1229:#endif /* ENABLED (JERRY_ES2015) */
        -: 1230:
        -: 1231:/**
        -: 1232: * [[Put]] ecma general object's operation with given receiver
        -: 1233: *
        -: 1234: * See also:
        -: 1235: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1236: *          ECMA-262 v5, 8.12.5
        -: 1237: *          ECMA-262 v6, 9.1.9
        -: 1238: *          Also incorporates [[CanPut]] ECMA-262 v5, 8.12.4
        -: 1239: *
        -: 1240: * @return ecma value
        -: 1241: *         The returned value must be freed with ecma_free_value.
        -: 1242: *
        -: 1243: *         Returns with ECMA_VALUE_TRUE if the operation is
        -: 1244: *         successful. Otherwise it returns with an error object
        -: 1245: *         or ECMA_VALUE_FALSE.
        -: 1246: *
        -: 1247: *         Note: even if is_throw is false, the setter can throw an
        -: 1248: *         error, and this function returns with that error.
        -: 1249: */
        -: 1250:ecma_value_t
     6550: 1251:ecma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */
        -: 1252:                                  ecma_string_t *property_name_p, /**< property name */
        -: 1253:                                  ecma_value_t value, /**< ecma value */
        -: 1254:                                  ecma_value_t receiver, /**< receiver */
        -: 1255:                                  bool is_throw) /**< flag that controls failure handling */
        -: 1256:{
     6550: 1257:  JERRY_ASSERT (object_p != NULL
        -: 1258:                && !ecma_is_lexical_environment (object_p));
     6550: 1259:  JERRY_ASSERT (property_name_p != NULL);
        -: 1260:
        -: 1261:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
     6550: 1262:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 1263:  {
    #####: 1264:    return ecma_proxy_object_set (object_p, property_name_p, value, receiver);
        -: 1265:  }
        -: 1266:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1267:
     6550: 1268:  ecma_object_type_t type = ecma_get_object_type (object_p);
        -: 1269:
     6550: 1270:  switch (type)
        -: 1271:  {
     1309: 1272:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1273:    {
     1309: 1274:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1275:
     1309: 1276:      if (ecma_string_is_length (property_name_p))
        -: 1277:      {
    #####: 1278:        if (ecma_is_property_writable (ext_object_p->u.array.u.length_prop))
        -: 1279:        {
    #####: 1280:          return ecma_op_array_object_set_length (object_p, value, 0);
        -: 1281:        }
        -: 1282:
    #####: 1283:        return ecma_reject (is_throw);
        -: 1284:      }
        -: 1285:
     1309: 1286:      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))
        -: 1287:      {
        1: 1288:        if (JERRY_UNLIKELY (!ecma_op_ordinary_object_is_extensible (object_p)))
        -: 1289:        {
    #####: 1290:          return ecma_reject (is_throw);
        -: 1291:        }
        -: 1292:
        1: 1293:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1294:
        1: 1295:        if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))
        -: 1296:        {
        1: 1297:          ecma_fast_array_convert_to_normal (object_p);
        -: 1298:        }
    #####: 1299:        else if (ecma_fast_array_set_property (object_p, index, value))
        -: 1300:        {
    #####: 1301:          return ECMA_VALUE_TRUE;
        -: 1302:        }
        -: 1303:      }
        -: 1304:
     1309: 1305:      JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -: 1306:
     1309: 1307:      break;
        -: 1308:    }
    #####: 1309:    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:
        -: 1310:    {
    #####: 1311:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1312:
    #####: 1313:      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)
        -: 1314:      {
    #####: 1315:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1316:
    #####: 1317:        if (index != ECMA_STRING_NOT_ARRAY_INDEX
    #####: 1318:            && index < ext_object_p->u.pseudo_array.u1.length)
        -: 1319:        {
    #####: 1320:          ecma_value_t *arg_Literal_p = (ecma_value_t *) (ext_object_p + 1);
        -: 1321:
    #####: 1322:          if (arg_Literal_p[index] != ECMA_VALUE_EMPTY)
        -: 1323:          {
    #####: 1324:            ecma_string_t *arg_name_p = ecma_get_string_from_value (arg_Literal_p[index]);
        -: 1325:
    #####: 1326:            ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,
        -: 1327:                                                                        ext_object_p->u.pseudo_array.u2.lex_env_cp);
        -: 1328:
    #####: 1329:            JERRY_ASSERT (lex_env_p != NULL
        -: 1330:                          && ecma_is_lexical_environment (lex_env_p));
        -: 1331:
    #####: 1332:            ecma_op_set_mutable_binding (lex_env_p, arg_name_p, value, true);
    #####: 1333:            return ECMA_VALUE_TRUE;
        -: 1334:          }
        -: 1335:        }
        -: 1336:      }
        -: 1337:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -: 1338:      /* ES2015 9.4.5.5 */
    #####: 1339:      if (ecma_object_is_typedarray (object_p))
        -: 1340:      {
        -: 1341:#if ENABLED (JERRY_ES2015)
    #####: 1342:        if (ecma_prop_name_is_symbol (property_name_p))
        -: 1343:        {
    #####: 1344:          break;
        -: 1345:        }
        -: 1346:#endif /* ENABLED (JERRY_ES2015) */
        -: 1347:
    #####: 1348:        uint32_t array_index = ecma_string_get_array_index (property_name_p);
        -: 1349:
    #####: 1350:        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1351:        {
    #####: 1352:          ecma_number_t num_var;
    #####: 1353:          ecma_value_t error = ecma_get_number (value, &num_var);
        -: 1354:
    #####: 1355:          if (ECMA_IS_VALUE_ERROR (error))
        -: 1356:          {
    #####: 1357:            jcontext_release_exception ();
    #####: 1358:            return ecma_reject (is_throw);
        -: 1359:          }
        -: 1360:
    #####: 1361:          ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
        -: 1362:
    #####: 1363:          if (array_index >= info.length)
        -: 1364:          {
    #####: 1365:            return ecma_reject (is_throw);
        -: 1366:          }
        -: 1367:
    #####: 1368:          ecma_length_t byte_pos = array_index << info.shift;
    #####: 1369:          ecma_set_typedarray_element (info.buffer_p + byte_pos, num_var, info.id);
        -: 1370:
    #####: 1371:          return ECMA_VALUE_TRUE;
        -: 1372:        }
        -: 1373:
    #####: 1374:        ecma_number_t num = ecma_string_to_number (property_name_p);
    #####: 1375:        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
        -: 1376:
    #####: 1377:        if (ecma_compare_ecma_strings (property_name_p, num_to_str))
        -: 1378:        {
    #####: 1379:          ecma_deref_ecma_string (num_to_str);
        -: 1380:
    #####: 1381:          return ecma_reject (is_throw);
        -: 1382:        }
        -: 1383:
    #####: 1384:        ecma_deref_ecma_string (num_to_str);
        -: 1385:      }
        -: 1386:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
    #####: 1387:      break;
        -: 1388:    }
     5241: 1389:    default:
        -: 1390:    {
     5241: 1391:      break;
        -: 1392:    }
        -: 1393:  }
        -: 1394:
     6550: 1395:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -: 1396:
     6550: 1397:  if (property_p == NULL)
        -: 1398:  {
     6549: 1399:    if (type == ECMA_OBJECT_TYPE_CLASS)
        -: 1400:    {
     2618: 1401:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1402:
     2618: 1403:      if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)
        -: 1404:      {
    #####: 1405:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1406:
    #####: 1407:        if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1408:        {
    #####: 1409:          ecma_value_t prim_value_p = ext_object_p->u.class_prop.u.value;
    #####: 1410:          ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -: 1411:
    #####: 1412:          if (index < ecma_string_get_length (prim_value_str_p))
        -: 1413:          {
    #####: 1414:            return ecma_reject (is_throw);
        -: 1415:          }
        -: 1416:        }
        -: 1417:      }
        -: 1418:    }
        -: 1419:
     6549: 1420:    if (ecma_get_object_is_builtin (object_p))
        -: 1421:    {
        4: 1422:      if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (object_p))
        -: 1423:      {
    #####: 1424:        property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
        -: 1425:      }
        -: 1426:      else
        -: 1427:      {
        4: 1428:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
        -: 1429:      }
        -: 1430:    }
     6545: 1431:    else if (type == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1432:    {
        -: 1433:#if ENABLED (JERRY_ES2015)
        -: 1434:      /* Uninitialized 'length' property is non-writable (ECMA-262 v6, 19.2.4.1) */
    #####: 1435:      if ((ecma_string_is_length (property_name_p))
    #####: 1436:          && (!ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (((ecma_extended_object_t *) object_p)->u.function.scope_cp)))
        -: 1437:      {
    #####: 1438:        return ecma_reject (is_throw);
        -: 1439:      }
        -: 1440:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1441:      if (ecma_string_is_length (property_name_p))
        -: 1442:      {
    #####: 1443:        return ecma_reject (is_throw);
        -: 1444:      }
        -: 1445:#endif /* ENABLED (JERRY_ES2015) */
        -: 1446:
        -: 1447:      /* Get prototype physical property. */
    #####: 1448:      property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -: 1449:    }
     6545: 1450:    else if (type == ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION)
        -: 1451:    {
     2618: 1452:      property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -: 1453:    }
     3927: 1454:    else if (type == ECMA_OBJECT_TYPE_BOUND_FUNCTION)
        -: 1455:    {
    #####: 1456:      property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
        -: 1457:    }
        -: 1458:  }
        -: 1459:
     6550: 1460:  jmem_cpointer_t setter_cp = JMEM_CP_NULL;
        -: 1461:
     6550: 1462:  if (property_p != NULL)
        -: 1463:  {
        1: 1464:    if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA)
        -: 1465:    {
        1: 1466:      if (ecma_is_property_writable (*property_p))
        -: 1467:      {
        -: 1468:#if ENABLED (JERRY_ES2015)
        1: 1469:        if (ecma_make_object_value (object_p) != receiver)
        -: 1470:        {
    #####: 1471:          return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);
        -: 1472:        }
        -: 1473:#endif /* ENABLED (JERRY_ES2015) */
        -: 1474:
        -: 1475:        /* There is no need for special casing arrays here because changing the
        -: 1476:         * value of an existing property never changes the length of an array. */
        2: 1477:        ecma_named_data_property_assign_value (object_p,
        1: 1478:                                               ECMA_PROPERTY_VALUE_PTR (property_p),
        -: 1479:                                               value);
        1: 1480:        return ECMA_VALUE_TRUE;
        -: 1481:      }
        -: 1482:    }
        -: 1483:    else
        -: 1484:    {
    #####: 1485:      JERRY_ASSERT (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR);
        -: 1486:
        -: 1487:      ecma_getter_setter_pointers_t *get_set_pair_p;
    #####: 1488:      get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (property_p));
    #####: 1489:      setter_cp = get_set_pair_p->setter_cp;
        -: 1490:    }
        -: 1491:  }
        -: 1492:  else
        -: 1493:  {
     6549: 1494:    bool create_new_property = true;
        -: 1495:
     6549: 1496:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);
        -: 1497:
     6549: 1498:    if (proto_cp != JMEM_CP_NULL)
        -: 1499:    {
     6549: 1500:      ecma_property_ref_t property_ref = { NULL };
     6549: 1501:      ecma_object_t *proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
        -: 1502:
        -: 1503:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
     6549: 1504:      if (ECMA_OBJECT_IS_PROXY (proto_p))
        -: 1505:      {
    #####: 1506:        return ecma_op_object_put_with_receiver (proto_p,
        -: 1507:                                                 property_name_p,
        -: 1508:                                                 value,
        -: 1509:                                                 receiver,
        -: 1510:                                                 is_throw);
        -: 1511:      }
        -: 1512:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1513:
     6549: 1514:      ecma_property_t inherited_property = ecma_op_object_get_property (proto_p,
        -: 1515:                                                                        property_name_p,
        -: 1516:                                                                        &property_ref,
        -: 1517:                                                                        ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 1518:
     6549: 1519:      if (inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND)
        -: 1520:      {
        1: 1521:        if (ECMA_PROPERTY_GET_TYPE (inherited_property) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)
        -: 1522:        {
    #####: 1523:          setter_cp = ecma_get_named_accessor_property (property_ref.value_p)->setter_cp;
    #####: 1524:          create_new_property = false;
        -: 1525:        }
        -: 1526:        else
        -: 1527:        {
        1: 1528:          create_new_property = ecma_is_property_writable (inherited_property);
        -: 1529:        }
        -: 1530:      }
        -: 1531:    }
        -: 1532:
     6549: 1533:    if (create_new_property
     6549: 1534:        && ecma_op_ordinary_object_is_extensible (object_p))
        -: 1535:    {
     6549: 1536:      const ecma_object_type_t obj_type = ecma_get_object_type (object_p);
        -: 1537:
     6549: 1538:      if (obj_type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY)
        -: 1539:      {
    #####: 1540:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1541:
    #####: 1542:        if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)
        -: 1543:        {
    #####: 1544:          return ecma_builtin_helper_def_prop (object_p,
        -: 1545:                                               property_name_p,
        -: 1546:                                               value,
        -: 1547:                                               ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_IS_THROW);
        -: 1548:        }
        -: 1549:      }
        -: 1550:
     6549: 1551:      uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1552:
     6549: 1553:      if (obj_type == ECMA_OBJECT_TYPE_ARRAY
     1309: 1554:          && index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1555:      {
     1308: 1556:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1557:
     1308: 1558:        if (index < UINT32_MAX
     1308: 1559:            && index >= ext_object_p->u.array.length)
        -: 1560:        {
     1308: 1561:          if (!ecma_is_property_writable (ext_object_p->u.array.u.length_prop))
        -: 1562:          {
    #####: 1563:            return ecma_reject (is_throw);
        -: 1564:          }
        -: 1565:
     1308: 1566:          ext_object_p->u.array.length = index + 1;
        -: 1567:        }
        -: 1568:      }
        -: 1569:
        -: 1570:#if ENABLED (JERRY_ES2015)
     6549: 1571:      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);
        -: 1572:#endif /* ENABLED (JERRY_ES2015) */
        -: 1573:
        -: 1574:      ecma_property_value_t *new_prop_value_p;
    #####: 1575:      new_prop_value_p = ecma_create_named_data_property (object_p,
        -: 1576:                                                          property_name_p,
        -: 1577:                                                          ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 1578:                                                          NULL);
        -: 1579:
    #####: 1580:      JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));
    #####: 1581:      new_prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####: 1582:      return ECMA_VALUE_TRUE;
        -: 1583:    }
        -: 1584:  }
        -: 1585:
    #####: 1586:  if (setter_cp == JMEM_CP_NULL)
        -: 1587:  {
    #####: 1588:    return ecma_reject (is_throw);
        -: 1589:  }
        -: 1590:
    #####: 1591:  ecma_value_t ret_value = ecma_op_function_call (ECMA_GET_NON_NULL_POINTER (ecma_object_t, setter_cp),
        -: 1592:                                                  receiver,
        -: 1593:                                                  &value,
        -: 1594:                                                  1);
        -: 1595:
    #####: 1596:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -: 1597:  {
    #####: 1598:    ecma_fast_free_value (ret_value);
    #####: 1599:    ret_value = ECMA_VALUE_TRUE;
        -: 1600:  }
        -: 1601:
    #####: 1602:  return ret_value;
        -: 1603:} /* ecma_op_object_put_with_receiver */
        -: 1604:
        -: 1605:/**
        -: 1606: * [[Delete]] ecma object's operation specialized for uint32_t property index
        -: 1607: *
        -: 1608: * Note:
        -: 1609: *      This method falls back to the general ecma_op_object_delete
        -: 1610: *
        -: 1611: * @return true - if deleted successfully
        -: 1612: *         false - or type error otherwise (based in 'is_throw')
        -: 1613: */
        -: 1614:ecma_value_t
    #####: 1615:ecma_op_object_delete_by_uint32_index (ecma_object_t *obj_p, /**< the object */
        -: 1616:                                       uint32_t index, /**< property index */
        -: 1617:                                       bool is_throw) /**< flag that controls failure handling */
        -: 1618:{
    #####: 1619:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -: 1620:  {
    #####: 1621:    return ecma_op_object_delete (obj_p, ECMA_CREATE_DIRECT_UINT32_STRING (index), is_throw);
        -: 1622:  }
        -: 1623:
    #####: 1624:  ecma_string_t *index_str_p = ecma_new_non_direct_string_from_uint32 (index);
    #####: 1625:  ecma_value_t ret_value = ecma_op_object_delete (obj_p, index_str_p, is_throw);
    #####: 1626:  ecma_deref_ecma_string (index_str_p);
        -: 1627:
    #####: 1628:  return ret_value;
        -: 1629:} /* ecma_op_object_delete_by_uint32_index */
        -: 1630:
        -: 1631:/**
        -: 1632: * [[Delete]] ecma object's operation specialized for ecma_number_t property index
        -: 1633: *
        -: 1634: * Note:
        -: 1635: *      This method falls back to the general ecma_op_object_delete
        -: 1636: *
        -: 1637: * @return true - if deleted successfully
        -: 1638: *         false - or type error otherwise (based in 'is_throw')
        -: 1639: */
        -: 1640:ecma_value_t
    #####: 1641:ecma_op_object_delete_by_number_index (ecma_object_t *obj_p, /**< the object */
        -: 1642:                                       ecma_number_t index, /**< property index */
        -: 1643:                                       bool is_throw) /**< flag that controls failure handling */
        -: 1644:{
    #####: 1645:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (index);
    #####: 1646:  ecma_value_t ret_value = ecma_op_object_delete (obj_p, index_str_p, is_throw);
    #####: 1647:  ecma_deref_ecma_string (index_str_p);
        -: 1648:
    #####: 1649:  return ret_value;
        -: 1650:} /* ecma_op_object_delete_by_number_index */
        -: 1651:
        -: 1652:/**
        -: 1653: * [[Delete]] ecma object's operation
        -: 1654: *
        -: 1655: * See also:
        -: 1656: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1657: *
        -: 1658: * Note:
        -: 1659: *      returned value must be freed with ecma_free_value
        -: 1660: *
        -: 1661: * @return true - if deleted successfully
        -: 1662: *         false - or type error otherwise (based in 'is_throw')
        -: 1663: */
        -: 1664:ecma_value_t
    #####: 1665:ecma_op_object_delete (ecma_object_t *obj_p, /**< the object */
        -: 1666:                       ecma_string_t *property_name_p, /**< property name */
        -: 1667:                       bool is_throw) /**< flag that controls failure handling */
        -: 1668:{
    #####: 1669:  JERRY_ASSERT (obj_p != NULL
        -: 1670:                && !ecma_is_lexical_environment (obj_p));
    #####: 1671:  JERRY_ASSERT (property_name_p != NULL);
        -: 1672:
    #####: 1673:  if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_PSEUDO_ARRAY)
        -: 1674:  {
    #####: 1675:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 1676:
    #####: 1677:    if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)
        -: 1678:    {
    #####: 1679:      return ecma_op_arguments_object_delete (obj_p,
        -: 1680:                                              property_name_p,
        -: 1681:                                              is_throw);
        -: 1682:    }
        -: 1683:  }
        -: 1684:
        -: 1685:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 1686:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 1687:  {
    #####: 1688:    return ecma_proxy_object_delete_property (obj_p, property_name_p);
        -: 1689:  }
        -: 1690:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1691:
    #####: 1692:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 1693:
    #####: 1694:  return ecma_op_general_object_delete (obj_p,
        -: 1695:                                        property_name_p,
        -: 1696:                                        is_throw);
        -: 1697:} /* ecma_op_object_delete */
        -: 1698:
        -: 1699:/**
        -: 1700: * [[DefaultValue]] ecma object's operation
        -: 1701: *
        -: 1702: * See also:
        -: 1703: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1704: *
        -: 1705: * @return ecma value
        -: 1706: *         Returned value must be freed with ecma_free_value
        -: 1707: */
        -: 1708:ecma_value_t
    #####: 1709:ecma_op_object_default_value (ecma_object_t *obj_p, /**< the object */
        -: 1710:                              ecma_preferred_type_hint_t hint) /**< hint on preferred result type */
        -: 1711:{
    #####: 1712:  JERRY_ASSERT (obj_p != NULL
        -: 1713:                && !ecma_is_lexical_environment (obj_p));
        -: 1714:
    #####: 1715:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 1716:
        -: 1717:  /*
        -: 1718:   * typedef ecma_property_t * (*default_value_ptr_t) (ecma_object_t *, ecma_string_t *);
        -: 1719:   * static const default_value_ptr_t default_value [ECMA_OBJECT_TYPE__COUNT] =
        -: 1720:   * {
        -: 1721:   *   [ECMA_OBJECT_TYPE_GENERAL]           = &ecma_op_general_object_default_value,
        -: 1722:   *   [ECMA_OBJECT_TYPE_CLASS]             = &ecma_op_general_object_default_value,
        -: 1723:   *   [ECMA_OBJECT_TYPE_FUNCTION]          = &ecma_op_general_object_default_value,
        -: 1724:   *   [ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION] = &ecma_op_general_object_default_value,
        -: 1725:   *   [ECMA_OBJECT_TYPE_ARRAY]             = &ecma_op_general_object_default_value,
        -: 1726:   *   [ECMA_OBJECT_TYPE_BOUND_FUNCTION]    = &ecma_op_general_object_default_value,
        -: 1727:   *   [ECMA_OBJECT_TYPE_PSEUDO_ARRAY]      = &ecma_op_general_object_default_value
        -: 1728:   * };
        -: 1729:   *
        -: 1730:   * return default_value[type] (obj_p, property_name_p);
        -: 1731:   */
        -: 1732:
    #####: 1733:  return ecma_op_general_object_default_value (obj_p, hint);
        -: 1734:} /* ecma_op_object_default_value */
        -: 1735:
        -: 1736:/**
        -: 1737: * [[DefineOwnProperty]] ecma object's operation
        -: 1738: *
        -: 1739: * See also:
        -: 1740: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1741: *
        -: 1742: * @return ecma value
        -: 1743: *         Returned value must be freed with ecma_free_value
        -: 1744: */
        -: 1745:ecma_value_t
     2619: 1746:ecma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */
        -: 1747:                                    ecma_string_t *property_name_p, /**< property name */
        -: 1748:                                    const ecma_property_descriptor_t *property_desc_p) /**< property
        -: 1749:                                                                                        *   descriptor */
        -: 1750:{
     2619: 1751:  JERRY_ASSERT (obj_p != NULL
        -: 1752:                && !ecma_is_lexical_environment (obj_p));
     2619: 1753:  JERRY_ASSERT (property_name_p != NULL);
        -: 1754:
     2619: 1755:  const ecma_object_type_t type = ecma_get_object_type (obj_p);
        -: 1756:
        -: 1757:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
     2619: 1758:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 1759:  {
    #####: 1760:    return ecma_proxy_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1761:  }
        -: 1762:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1763:
     2619: 1764:  switch (type)
        -: 1765:  {
     2619: 1766:    case ECMA_OBJECT_TYPE_GENERAL:
        -: 1767:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1768:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1769:    case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:
        -: 1770:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1771:    {
     2619: 1772:      return ecma_op_general_object_define_own_property (obj_p,
        -: 1773:                                                         property_name_p,
        -: 1774:                                                         property_desc_p);
        -: 1775:    }
        -: 1776:
    #####: 1777:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1778:    {
    #####: 1779:      return ecma_op_array_object_define_own_property (obj_p,
        -: 1780:                                                       property_name_p,
        -: 1781:                                                       property_desc_p);
        -: 1782:    }
        -: 1783:
    #####: 1784:    default:
        -: 1785:    {
    #####: 1786:      JERRY_ASSERT (type == ECMA_OBJECT_TYPE_PSEUDO_ARRAY);
        -: 1787:
    #####: 1788:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 1789:
        -: 1790:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 1791:      if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS)
        -: 1792:      {
        -: 1793:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
    #####: 1794:        JERRY_ASSERT (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS);
        -: 1795:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
    #####: 1796:        return ecma_op_arguments_object_define_own_property (obj_p,
        -: 1797:                                                             property_name_p,
        -: 1798:                                                             property_desc_p);
        -: 1799:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -: 1800:      }
        -: 1801:      /* ES2015 9.4.5.3 */
    #####: 1802:      if (ecma_object_is_typedarray (obj_p))
        -: 1803:      {
        -: 1804:#if ENABLED (JERRY_ES2015)
    #####: 1805:        if (ecma_prop_name_is_symbol (property_name_p))
        -: 1806:        {
    #####: 1807:          return ecma_op_general_object_define_own_property (obj_p,
        -: 1808:                                                             property_name_p,
        -: 1809:                                                             property_desc_p);
        -: 1810:        }
        -: 1811:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1812:        uint32_t array_index = ecma_string_get_array_index (property_name_p);
        -: 1813:
    #####: 1814:        if (array_index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1815:        {
    #####: 1816:          bool define_status = ecma_op_typedarray_define_index_prop (obj_p,
        -: 1817:                                                                     array_index,
        -: 1818:                                                                     property_desc_p);
        -: 1819:
    #####: 1820:          if (define_status)
        -: 1821:          {
    #####: 1822:            return ECMA_VALUE_TRUE;
        -: 1823:          }
        -: 1824:
    #####: 1825:          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);
        -: 1826:        }
        -: 1827:
    #####: 1828:        ecma_number_t num = ecma_string_to_number (property_name_p);
    #####: 1829:        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
        -: 1830:
    #####: 1831:        if (ecma_compare_ecma_strings (property_name_p, num_to_str))
        -: 1832:        {
    #####: 1833:          ecma_deref_ecma_string (num_to_str);
        -: 1834:
    #####: 1835:          return ecma_reject (property_desc_p->flags & ECMA_PROP_IS_THROW);
        -: 1836:        }
        -: 1837:
    #####: 1838:        ecma_deref_ecma_string (num_to_str);
        -: 1839:      }
        -: 1840:
    #####: 1841:      return ecma_op_general_object_define_own_property (obj_p,
        -: 1842:                                                         property_name_p,
        -: 1843:                                                         property_desc_p);
        -: 1844:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 1845:      break;
        -: 1846:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 1847:    }
        -: 1848:  }
        -: 1849:} /* ecma_op_object_define_own_property */
        -: 1850:
        -: 1851:/**
        -: 1852: * Get property descriptor from specified property
        -: 1853: *
        -: 1854: * depending on the property type the following fields are set:
        -: 1855: *   - for named data properties: { [Value], [Writable], [Enumerable], [Configurable] };
        -: 1856: *   - for named accessor properties: { [Get] - if defined,
        -: 1857: *                                      [Set] - if defined,
        -: 1858: *                                      [Enumerable], [Configurable]
        -: 1859: *                                    }.
        -: 1860: *
        -: 1861: * @return true - if property found
        -: 1862: *         false - otherwise
        -: 1863: */
        -: 1864:ecma_value_t
     6549: 1865:ecma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */
        -: 1866:                                            ecma_string_t *property_name_p, /**< property name */
        -: 1867:                                            ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 1868:{
        -: 1869:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
     6549: 1870:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 1871:  {
    #####: 1872:    return ecma_proxy_object_get_own_property_descriptor (object_p, property_name_p, prop_desc_p);
        -: 1873:  }
        -: 1874:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1875:
     6549: 1876:  ecma_property_ref_t property_ref;
        -: 1877:
     6549: 1878:  ecma_property_t property = ecma_op_object_get_own_property (object_p,
        -: 1879:                                                              property_name_p,
        -: 1880:                                                              &property_ref,
        -: 1881:                                                              ECMA_PROPERTY_GET_VALUE);
        -: 1882:
     6549: 1883:  if (property == ECMA_PROPERTY_TYPE_NOT_FOUND || property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)
        -: 1884:  {
     6549: 1885:    return ECMA_VALUE_FALSE;
        -: 1886:  }
        -: 1887:
    #####: 1888:  *prop_desc_p = ecma_make_empty_property_descriptor ();
        -: 1889:
    #####: 1890:  uint32_t flags = ecma_is_property_enumerable (property) ? ECMA_PROP_IS_ENUMERABLE : ECMA_PROP_NO_OPTS;
    #####: 1891:  flags |= ecma_is_property_configurable (property) ? ECMA_PROP_IS_CONFIGURABLE: ECMA_PROP_NO_OPTS;
        -: 1892:
    #####: 1893:  prop_desc_p->flags = (uint16_t) (ECMA_PROP_IS_ENUMERABLE_DEFINED | ECMA_PROP_IS_CONFIGURABLE_DEFINED | flags);
        -: 1894:
    #####: 1895:  ecma_property_types_t type = ECMA_PROPERTY_GET_TYPE (property);
        -: 1896:
    #####: 1897:  if (type != ECMA_PROPERTY_TYPE_NAMEDACCESSOR)
        -: 1898:  {
    #####: 1899:    if (type == ECMA_PROPERTY_TYPE_NAMEDDATA)
        -: 1900:    {
    #####: 1901:      prop_desc_p->value = ecma_copy_value (property_ref.value_p->value);
        -: 1902:    }
        -: 1903:    else
        -: 1904:    {
    #####: 1905:      JERRY_ASSERT (type == ECMA_PROPERTY_TYPE_VIRTUAL);
    #####: 1906:      prop_desc_p->value = property_ref.virtual_value;
        -: 1907:    }
        -: 1908:
    #####: 1909:    prop_desc_p->flags |= (ECMA_PROP_IS_VALUE_DEFINED | ECMA_PROP_IS_WRITABLE_DEFINED);
    #####: 1910:    prop_desc_p->flags = (uint16_t) (prop_desc_p->flags | (ecma_is_property_writable (property) ? ECMA_PROP_IS_WRITABLE
        -: 1911:                                                                                                : ECMA_PROP_NO_OPTS));
        -: 1912:  }
        -: 1913:  else
        -: 1914:  {
        -: 1915:
    #####: 1916:    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (property_ref.value_p);
    #####: 1917:    prop_desc_p->flags |= (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED);
        -: 1918:
    #####: 1919:    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -: 1920:    {
    #####: 1921:      prop_desc_p->get_p = NULL;
        -: 1922:    }
        -: 1923:    else
        -: 1924:    {
    #####: 1925:      prop_desc_p->get_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
    #####: 1926:      ecma_ref_object (prop_desc_p->get_p);
        -: 1927:    }
        -: 1928:
    #####: 1929:    if (get_set_pair_p->setter_cp == JMEM_CP_NULL)
        -: 1930:    {
    #####: 1931:      prop_desc_p->set_p = NULL;
        -: 1932:    }
        -: 1933:    else
        -: 1934:    {
    #####: 1935:      prop_desc_p->set_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);
    #####: 1936:      ecma_ref_object (prop_desc_p->set_p);
        -: 1937:    }
        -: 1938:  }
        -: 1939:
    #####: 1940:  return ECMA_VALUE_TRUE;
        -: 1941:} /* ecma_op_object_get_own_property_descriptor */
        -: 1942:
        -: 1943:/**
        -: 1944: * [[HasInstance]] ecma object's operation
        -: 1945: *
        -: 1946: * See also:
        -: 1947: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 9
        -: 1948: *
        -: 1949: * @return ecma value containing a boolean value or an error
        -: 1950: *         Returned value must be freed with ecma_free_value
        -: 1951: */
        -: 1952:ecma_value_t
    #####: 1953:ecma_op_object_has_instance (ecma_object_t *obj_p, /**< the object */
        -: 1954:                             ecma_value_t value) /**< argument 'V' */
        -: 1955:{
    #####: 1956:  JERRY_ASSERT (obj_p != NULL
        -: 1957:                && !ecma_is_lexical_environment (obj_p));
        -: 1958:
    #####: 1959:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 1960:
    #####: 1961:  if (ecma_op_object_is_callable (obj_p))
        -: 1962:  {
    #####: 1963:    return ecma_op_function_has_instance (obj_p, value);
        -: 1964:  }
        -: 1965:
    #####: 1966:  return ecma_raise_type_error (ECMA_ERR_MSG ("Expected a function object."));
        -: 1967:} /* ecma_op_object_has_instance */
        -: 1968:
        -: 1969:/**
        -: 1970: * Object's isPrototypeOf operation
        -: 1971: *
        -: 1972: * See also:
        -: 1973: *          ECMA-262 v5, 15.2.4.6; 3
        -: 1974: *
        -: 1975: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1976: *         ECMA_VALUE_TRUE - if the target object is prototype of the base object
        -: 1977: *         ECMA_VALUE_FALSE - if the target object is not prototype of the base object
        -: 1978: */
        -: 1979:ecma_value_t
    #####: 1980:ecma_op_object_is_prototype_of (ecma_object_t *base_p, /**< base object */
        -: 1981:                                ecma_object_t *target_p) /**< target object */
        -: 1982:{
        -: 1983:  do
    #####: 1984:  {
        -: 1985:    jmem_cpointer_t target_cp;
        -: 1986:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 1987:    if (ECMA_OBJECT_IS_PROXY (target_p))
        -: 1988:    {
    #####: 1989:      ecma_value_t target_proto = ecma_proxy_object_get_prototype_of (target_p);
        -: 1990:
    #####: 1991:      if (ECMA_IS_VALUE_ERROR (target_proto))
        -: 1992:      {
    #####: 1993:        return target_proto;
        -: 1994:      }
    #####: 1995:      target_cp = ecma_proxy_object_prototype_to_cp (target_proto);
        -: 1996:    }
        -: 1997:    else
        -: 1998:    {
        -: 1999:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
    #####: 2000:      target_cp = ecma_op_ordinary_object_get_prototype_of (target_p);
        -: 2001:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
        -: 2002:    }
        -: 2003:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 2004:
    #####: 2005:    if (target_cp == JMEM_CP_NULL)
        -: 2006:    {
    #####: 2007:      return ECMA_VALUE_FALSE;
        -: 2008:    }
        -: 2009:
    #####: 2010:    target_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, target_cp);
        -: 2011:
    #####: 2012:    if (target_p == base_p)
        -: 2013:    {
    #####: 2014:      return ECMA_VALUE_TRUE;
        -: 2015:    }
        -: 2016:  } while (true);
        -: 2017:} /* ecma_op_object_is_prototype_of */
        -: 2018:
        -: 2019:/**
        -: 2020: * Get collection of property names
        -: 2021: *
        -: 2022: * Order of names in the collection:
        -: 2023: *  - integer indices in ascending order
        -: 2024: *  - other indices in creation order (for built-ins: the order of the properties are listed in specification).
        -: 2025: *
        -: 2026: * Note:
        -: 2027: *      Implementation of the routine assumes that new properties are appended to beginning of corresponding object's
        -: 2028: *      property list, and the list is not reordered (in other words, properties are stored in order that is reversed
        -: 2029: *      to the properties' addition order).
        -: 2030: *
        -: 2031: * @return NULL - if the Proxy.[[OwnPropertyKeys]] operation raises error
        -: 2032: *         collection of property names - otherwise
        -: 2033: */
        -: 2034:ecma_collection_t *
    #####: 2035:ecma_op_object_get_property_names (ecma_object_t *obj_p, /**< object */
        -: 2036:                                   uint32_t opts) /**< any combination of ecma_list_properties_options_t values  */
    #####: 2037:{
    #####: 2038:  JERRY_ASSERT (obj_p != NULL
        -: 2039:                && !ecma_is_lexical_environment (obj_p));
        -: 2040:
        -: 2041:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 2042:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 2043:  {
        -: 2044:    /* Integrated a part of ECMA 262 v6 7.3.21 EnumerableOwnNames operation. */
    #####: 2045:    ecma_collection_t *proxy_keys = ecma_proxy_object_own_property_keys (obj_p);
    #####: 2046:    if (JERRY_UNLIKELY (proxy_keys == NULL))
        -: 2047:    {
    #####: 2048:      return proxy_keys;
        -: 2049:    }
    #####: 2050:    ecma_collection_t *return_keys = ecma_new_collection ();
        -: 2051:
        -: 2052:    /* Move valid elements to the output collection */
    #####: 2053:    for (uint32_t i = 0; i < proxy_keys->item_count; i++)
        -: 2054:    {
    #####: 2055:      ecma_value_t entry = proxy_keys->buffer_p[i];
    #####: 2056:      ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (entry);
    #####: 2057:      bool prop_is_symbol = ecma_prop_name_is_symbol (prop_name_p);
        -: 2058:
    #####: 2059:      if (prop_is_symbol && ((opts & (ECMA_LIST_SYMBOLS | ECMA_LIST_SYMBOLS_ONLY)) != 0))
        -: 2060:      {
    #####: 2061:        ecma_collection_push_back (return_keys, entry);
        -: 2062:      }
    #####: 2063:      else if (!prop_is_symbol && (opts & ECMA_LIST_SYMBOLS_ONLY) == 0)
        -: 2064:      {
    #####: 2065:        ecma_collection_push_back (return_keys, entry);
        -: 2066:      }
        -: 2067:      else
        -: 2068:      {
    #####: 2069:        ecma_free_value (entry);
        -: 2070:      }
        -: 2071:    }
        -: 2072:
    #####: 2073:    ecma_collection_destroy (proxy_keys);
    #####: 2074:    return return_keys;
        -: 2075:  }
        -: 2076:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 2077:
    #####: 2078:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2079:  {
    #####: 2080:    return ecma_fast_array_get_property_names (obj_p, opts);
        -: 2081:  }
        -: 2082:
    #####: 2083:  ecma_collection_t *ret_p = ecma_new_collection ();
    #####: 2084:  ecma_collection_t *skipped_non_enumerable_p = ecma_new_collection ();
        -: 2085:
    #####: 2086:  const bool is_enumerable_only = (opts & ECMA_LIST_ENUMERABLE) != 0;
    #####: 2087:  const bool is_array_indices_only = (opts & ECMA_LIST_ARRAY_INDICES) != 0;
    #####: 2088:  const bool is_with_prototype_chain = (opts & ECMA_LIST_PROTOTYPE) != 0;
        -: 2089:#if ENABLED (JERRY_ES2015)
    #####: 2090:  const bool is_symbols = (opts & ECMA_LIST_SYMBOLS) != 0;
    #####: 2091:  const bool is_symbols_only = (opts & ECMA_LIST_SYMBOLS_ONLY) != 0;
        -: 2092:#endif /* ENABLED (JERRY_ES2015) */
        -: 2093:
    #####: 2094:  const size_t bitmap_row_size = sizeof (uint32_t) * JERRY_BITSINBYTE;
    #####: 2095:  const size_t names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;
    #####: 2096:  JERRY_VLA (uint32_t, names_hashes_bitmap, names_hashes_bitmap_size);
        -: 2097:
    #####: 2098:  memset (names_hashes_bitmap, 0, names_hashes_bitmap_size * sizeof (names_hashes_bitmap[0]));
        -: 2099:
        -: 2100:  while (true)
    #####: 2101:  {
    #####: 2102:    const ecma_object_type_t type = ecma_get_object_type (obj_p);
    #####: 2103:    const bool obj_is_builtin = ecma_get_object_is_builtin (obj_p);
    #####: 2104:    ecma_length_t string_named_properties_count = 0;
    #####: 2105:    ecma_length_t array_index_named_properties_count = 0;
        -: 2106:#if ENABLED (JERRY_ES2015)
    #####: 2107:    ecma_length_t symbol_named_properties_count = 0;
        -: 2108:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2109:    ecma_collection_t *prop_names_p = ecma_new_collection ();
        -: 2110:
        -: 2111:#if ENABLED (JERRY_ES2015)
    #####: 2112:    if (JERRY_LIKELY (!is_symbols_only))
        -: 2113:    {
        -: 2114:#endif /* ENABLED (JERRY_ES2015) */
        -: 2115:
    #####: 2116:      if (obj_is_builtin)
        -: 2117:      {
    #####: 2118:        if (type == ECMA_OBJECT_TYPE_FUNCTION && ecma_builtin_function_is_routine (obj_p))
        -: 2119:        {
    #####: 2120:          ecma_builtin_routine_list_lazy_property_names (obj_p,
        -: 2121:                                                          opts,
        -: 2122:                                                          prop_names_p,
        -: 2123:                                                          skipped_non_enumerable_p);
        -: 2124:        }
        -: 2125:        else
        -: 2126:        {
    #####: 2127:          ecma_builtin_list_lazy_property_names (obj_p,
        -: 2128:                                                 opts,
        -: 2129:                                                 prop_names_p,
        -: 2130:                                                 skipped_non_enumerable_p);
        -: 2131:        }
        -: 2132:      }
        -: 2133:      else
        -: 2134:      {
    #####: 2135:        switch (type)
        -: 2136:        {
    #####: 2137:          case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:
        -: 2138:          {
        -: 2139:  #if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 2140:            if (ecma_object_is_typedarray (obj_p))
        -: 2141:            {
    #####: 2142:              ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p);
        -: 2143:            }
        -: 2144:  #endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
    #####: 2145:            break;
        -: 2146:          }
    #####: 2147:          case ECMA_OBJECT_TYPE_FUNCTION:
        -: 2148:          {
    #####: 2149:            if (!is_array_indices_only)
        -: 2150:            {
    #####: 2151:              ecma_op_function_list_lazy_property_names (obj_p,
        -: 2152:                                                         opts,
        -: 2153:                                                         prop_names_p,
        -: 2154:                                                         skipped_non_enumerable_p);
        -: 2155:            }
    #####: 2156:            break;
        -: 2157:          }
    #####: 2158:          case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:
        -: 2159:          {
    #####: 2160:            if (!is_array_indices_only)
        -: 2161:            {
    #####: 2162:              ecma_op_external_function_list_lazy_property_names (obj_p,
        -: 2163:                                                                  opts,
        -: 2164:                                                                  prop_names_p,
        -: 2165:                                                                  skipped_non_enumerable_p);
        -: 2166:            }
    #####: 2167:            break;
        -: 2168:          }
    #####: 2169:          case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 2170:          {
    #####: 2171:            if (!is_array_indices_only)
        -: 2172:            {
    #####: 2173:              ecma_op_bound_function_list_lazy_property_names (obj_p,
        -: 2174:                                                               opts,
        -: 2175:                                                               prop_names_p,
        -: 2176:                                                               skipped_non_enumerable_p);
        -: 2177:            }
    #####: 2178:            break;
        -: 2179:          }
    #####: 2180:          case ECMA_OBJECT_TYPE_CLASS:
        -: 2181:          {
    #####: 2182:            ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 2183:
    #####: 2184:            if (ext_object_p->u.class_prop.class_id == LIT_MAGIC_STRING_STRING_UL)
        -: 2185:            {
    #####: 2186:              ecma_op_string_list_lazy_property_names (obj_p,
        -: 2187:                                                       opts,
        -: 2188:                                                       prop_names_p,
        -: 2189:                                                       skipped_non_enumerable_p);
        -: 2190:            }
        -: 2191:
    #####: 2192:            break;
        -: 2193:          }
    #####: 2194:          case ECMA_OBJECT_TYPE_ARRAY:
        -: 2195:          {
    #####: 2196:            ecma_op_array_list_lazy_property_names (obj_p,
        -: 2197:                                                    opts,
        -: 2198:                                                    prop_names_p,
        -: 2199:                                                    skipped_non_enumerable_p);
    #####: 2200:            break;
        -: 2201:          }
    #####: 2202:          default:
        -: 2203:          {
    #####: 2204:            JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL);
        -: 2205:
    #####: 2206:            break;
        -: 2207:          }
        -: 2208:        }
    #####: 2209:      }
        -: 2210:#if ENABLED (JERRY_ES2015)
        -: 2211:    }
        -: 2212:#endif /* ENABLED (JERRY_ES2015) */
        -: 2213:
    #####: 2214:    ecma_value_t *buffer_p = prop_names_p->buffer_p;
    #####: 2215:    uint32_t lazy_prop_name_count = prop_names_p->item_count;
        -: 2216:
    #####: 2217:    const size_t own_names_hashes_bitmap_size = ECMA_OBJECT_HASH_BITMAP_SIZE / bitmap_row_size;
    #####: 2218:    JERRY_VLA (uint32_t, own_names_hashes_bitmap, own_names_hashes_bitmap_size);
    #####: 2219:    memset (own_names_hashes_bitmap, 0, own_names_hashes_bitmap_size * sizeof (own_names_hashes_bitmap[0]));
        -: 2220:
    #####: 2221:    for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 2222:    {
    #####: 2223:      ecma_string_t *name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 2224:
    #####: 2225:      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 2226:      {
    #####: 2227:        array_index_named_properties_count++;
        -: 2228:      }
        -: 2229:#if ENABLED (JERRY_ES2015)
    #####: 2230:      else if (ecma_prop_name_is_symbol (name_p))
        -: 2231:      {
    #####: 2232:        symbol_named_properties_count++;
        -: 2233:      }
        -: 2234:#endif /* ENABLED (JERRY_ES2015) */
        -: 2235:      else
        -: 2236:      {
    #####: 2237:        string_named_properties_count++;
        -: 2238:      }
        -: 2239:
        -: 2240:#if ENABLED (JERRY_ES2015)
        -: 2241:      /* Symbols are never lazy listed */
    #####: 2242:      JERRY_ASSERT (!ecma_prop_name_is_symbol (name_p));
        -: 2243:#endif /* ENABLED (JERRY_ES2015) */
        -: 2244:
    #####: 2245:      uint8_t hash = (uint8_t) ecma_string_hash (name_p);
    #####: 2246:      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);
    #####: 2247:      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);
        -: 2248:
    #####: 2249:      if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)
        -: 2250:      {
    #####: 2251:        own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);
        -: 2252:      }
        -: 2253:    }
        -: 2254:
    #####: 2255:    jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -: 2256:
    #####: 2257:    if (ecma_op_object_is_fast_array (obj_p) && prop_iter_cp != JMEM_CP_NULL)
    #####: 2258:    {
    #####: 2259:      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2260:
    #####: 2261:      uint32_t length = ext_obj_p->u.array.length;
    #####: 2262:      array_index_named_properties_count = length - ecma_fast_array_get_hole_count (obj_p);
        -: 2263:
    #####: 2264:      ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, prop_iter_cp);
        -: 2265:
    #####: 2266:      for (uint32_t i = 0; i < length; i++)
        -: 2267:      {
    #####: 2268:        if (ecma_is_value_array_hole (values_p[i]))
        -: 2269:        {
    #####: 2270:          continue;
        -: 2271:        }
        -: 2272:
    #####: 2273:        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (i);
        -: 2274:
    #####: 2275:        uint8_t hash = (uint8_t) ecma_string_hash (index_str_p);
    #####: 2276:        uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);
    #####: 2277:        uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);
        -: 2278:
    #####: 2279:        bool is_add = true;
        -: 2280:
    #####: 2281:        if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)
        -: 2282:        {
    #####: 2283:          buffer_p = prop_names_p->buffer_p;
        -: 2284:
    #####: 2285:          for (uint32_t j = 0; j < prop_names_p->item_count; j++)
        -: 2286:          {
    #####: 2287:            ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);
        -: 2288:
    #####: 2289:            if (ecma_compare_ecma_strings (index_str_p, current_name_p))
        -: 2290:            {
    #####: 2291:              is_add = false;
    #####: 2292:              break;
        -: 2293:            }
        -: 2294:          }
        -: 2295:        }
        -: 2296:
    #####: 2297:        if (is_add)
        -: 2298:        {
    #####: 2299:          own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);
        -: 2300:
    #####: 2301:          ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_str_p));
        -: 2302:        }
        -: 2303:      }
        -: 2304:    }
        -: 2305:    else
        -: 2306:    {
        -: 2307:#if ENABLED (JERRY_PROPRETY_HASHMAP)
    #####: 2308:      if (prop_iter_cp != JMEM_CP_NULL)
        -: 2309:      {
    #####: 2310:        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -: 2311:
    #####: 2312:        if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 2313:        {
    #####: 2314:          prop_iter_cp = prop_iter_p->next_property_cp;
        -: 2315:        }
        -: 2316:      }
        -: 2317:  #endif /* ENABLED (JERRY_PROPRETY_HASHMAP) */
        -: 2318:
    #####: 2319:      while (prop_iter_cp != JMEM_CP_NULL)
        -: 2320:      {
    #####: 2321:        ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####: 2322:        JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 2323:
    #####: 2324:        for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -: 2325:        {
    #####: 2326:          ecma_property_t *property_p = prop_iter_p->types + i;
        -: 2327:
    #####: 2328:          if (ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDDATA
    #####: 2329:              || ECMA_PROPERTY_GET_TYPE (*property_p) == ECMA_PROPERTY_TYPE_NAMEDACCESSOR)
        -: 2330:          {
    #####: 2331:            ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 2332:
    #####: 2333:            if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC
    #####: 2334:                && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT
    #####: 2335:                && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)
        -: 2336:            {
        -: 2337:              /* Internal properties are never enumerated. */
    #####: 2338:              continue;
        -: 2339:            }
        -: 2340:
    #####: 2341:            ecma_string_t *name_p = ecma_string_from_property_name (*property_p,
    #####: 2342:                                                                    prop_pair_p->names_cp[i]);
        -: 2343:
    #####: 2344:            if (!(is_enumerable_only && !ecma_is_property_enumerable (*property_p)))
    #####: 2345:            {
        -: 2346:  #if ENABLED (JERRY_ES2015)
        -: 2347:              /* We skip the current property in the following cases:
        -: 2348:                 1. We don't want to list symbols (is_symbols and is_symbols_only are false)
        -: 2349:                    and the current property is a symbol.
        -: 2350:                 2. We only want to list symbols (is_symbols_only is true) and the current
        -: 2351:                    property is NOT a symbol. */
    #####: 2352:              bool is_symbol = ecma_prop_name_is_symbol (name_p);
    #####: 2353:              if ((!(is_symbols || is_symbols_only) && is_symbol) || (is_symbols_only && !is_symbol))
        -: 2354:              {
    #####: 2355:                ecma_deref_ecma_string (name_p);
    #####: 2356:                continue;
        -: 2357:              }
        -: 2358:  #endif /* ENABLED (JERRY_ES2015) */
        -: 2359:
    #####: 2360:              uint8_t hash = (uint8_t) ecma_string_hash (name_p);
    #####: 2361:              uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);
    #####: 2362:              uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);
        -: 2363:
    #####: 2364:              bool is_add = true;
        -: 2365:
    #####: 2366:              if ((own_names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0)
        -: 2367:              {
    #####: 2368:                buffer_p = prop_names_p->buffer_p;
        -: 2369:
    #####: 2370:                for (uint32_t j = 0; j < prop_names_p->item_count; j++)
        -: 2371:                {
    #####: 2372:                  ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);
        -: 2373:
    #####: 2374:                  if (ecma_compare_ecma_strings (name_p, current_name_p))
        -: 2375:                  {
    #####: 2376:                    is_add = false;
    #####: 2377:                    break;
        -: 2378:                  }
        -: 2379:                }
        -: 2380:              }
        -: 2381:
    #####: 2382:              if (is_add)
        -: 2383:              {
    #####: 2384:                if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 2385:                {
        -: 2386:                  /* The name is a valid array index. */
    #####: 2387:                  array_index_named_properties_count++;
        -: 2388:                }
    #####: 2389:                else if (!is_array_indices_only)
        -: 2390:                {
        -: 2391:  #if ENABLED (JERRY_ES2015)
    #####: 2392:                  if (ecma_prop_name_is_symbol (name_p))
        -: 2393:                  {
    #####: 2394:                    symbol_named_properties_count++;
        -: 2395:                  }
        -: 2396:                  else
        -: 2397:                  {
        -: 2398:  #endif /* ENABLED (JERRY_ES2015) */
    #####: 2399:                    string_named_properties_count++;
        -: 2400:  #if ENABLED (JERRY_ES2015)
        -: 2401:                  }
        -: 2402:  #endif /* ENABLED (JERRY_ES2015) */
        -: 2403:                }
        -: 2404:                else
        -: 2405:                {
    #####: 2406:                  ecma_deref_ecma_string (name_p);
    #####: 2407:                  continue;
        -: 2408:                }
        -: 2409:
    #####: 2410:                own_names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);
        -: 2411:
    #####: 2412:                ecma_collection_push_back (prop_names_p, ecma_make_prop_name_value (name_p));
        -: 2413:              }
        -: 2414:              else
        -: 2415:              {
    #####: 2416:                ecma_deref_ecma_string (name_p);
        -: 2417:              }
        -: 2418:            }
        -: 2419:            else
        -: 2420:            {
    #####: 2421:              JERRY_ASSERT (is_enumerable_only && !ecma_is_property_enumerable (*property_p));
        -: 2422:
    #####: 2423:              ecma_collection_push_back (skipped_non_enumerable_p, ecma_make_prop_name_value (name_p));
        -: 2424:            }
        -: 2425:          }
        -: 2426:        }
        -: 2427:
    #####: 2428:        prop_iter_cp = prop_iter_p->next_property_cp;
        -: 2429:      }
        -: 2430:    }
        -: 2431:
    #####: 2432:    ecma_length_t all_properties_count = array_index_named_properties_count + string_named_properties_count;
        -: 2433:
        -: 2434:#if ENABLED (JERRY_ES2015)
    #####: 2435:    all_properties_count += symbol_named_properties_count;
        -: 2436:#endif /* ENABLED (JERRY_ES2015) */
        -: 2437:
        -: 2438:    /* Second pass: collecting property names into an array. */
    #####: 2439:    JMEM_DEFINE_LOCAL_ARRAY (names_p, all_properties_count, ecma_string_t *);
        -: 2440:
    #####: 2441:    ecma_string_t **string_names_p = names_p + array_index_named_properties_count;
        -: 2442:#if ENABLED (JERRY_ES2015)
    #####: 2443:    ecma_string_t **symbol_names_p = string_names_p + string_named_properties_count;
        -: 2444:#endif /* ENABLED (JERRY_ES2015) */
        -: 2445:
    #####: 2446:    uint32_t array_index_name_pos = 0;
    #####: 2447:    uint32_t string_name_pos = string_named_properties_count;
    #####: 2448:    uint32_t lazy_string_name_pos = 0;
        -: 2449:#if ENABLED (JERRY_ES2015)
    #####: 2450:    uint32_t symbol_name_pos = symbol_named_properties_count;
        -: 2451:#endif /* ENABLED (JERRY_ES2015) */
        -: 2452:
    #####: 2453:    buffer_p = prop_names_p->buffer_p;
        -: 2454:
    #####: 2455:    for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 2456:    {
    #####: 2457:      ecma_string_t *name_p = ecma_get_prop_name_from_value (buffer_p[i]);
    #####: 2458:      ecma_ref_ecma_string (name_p);
        -: 2459:
    #####: 2460:      uint32_t index = ecma_string_get_array_index (name_p);
        -: 2461:
    #####: 2462:      if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 2463:      {
    #####: 2464:        JERRY_ASSERT (array_index_name_pos < array_index_named_properties_count);
        -: 2465:
    #####: 2466:        uint32_t insertion_pos = 0;
    #####: 2467:        while (insertion_pos < array_index_name_pos
    #####: 2468:               && index > ecma_string_get_array_index (names_p[insertion_pos]))
        -: 2469:        {
    #####: 2470:          insertion_pos++;
        -: 2471:        }
        -: 2472:
    #####: 2473:        if (insertion_pos == array_index_name_pos)
        -: 2474:        {
    #####: 2475:          names_p[array_index_name_pos++] = name_p;
        -: 2476:        }
        -: 2477:        else
        -: 2478:        {
    #####: 2479:          JERRY_ASSERT (insertion_pos < array_index_name_pos);
    #####: 2480:          JERRY_ASSERT (index <= ecma_string_get_array_index (names_p[insertion_pos]));
        -: 2481:
    #####: 2482:          uint32_t move_pos = array_index_name_pos++;
        -: 2483:
    #####: 2484:          while (move_pos > insertion_pos)
        -: 2485:          {
    #####: 2486:            names_p[move_pos] = names_p[move_pos - 1u];
        -: 2487:
    #####: 2488:            move_pos--;
        -: 2489:          }
        -: 2490:
    #####: 2491:          names_p[insertion_pos] = name_p;
        -: 2492:        }
        -: 2493:      }
        -: 2494:#if ENABLED (JERRY_ES2015)
    #####: 2495:      else if (ecma_prop_name_is_symbol (name_p))
        -: 2496:      {
        -: 2497:        // Put in the symbols in reverse order.
    #####: 2498:        JERRY_ASSERT (symbol_name_pos > 0);
    #####: 2499:        JERRY_ASSERT (symbol_name_pos <= symbol_named_properties_count);
        -: 2500:
    #####: 2501:        symbol_names_p[--symbol_name_pos] = name_p;
        -: 2502:      }
        -: 2503:#endif /* ENABLED (JERRY_ES2015) */
        -: 2504:      else
        -: 2505:      {
        -: 2506:        // Put in the strings in reverse order.
    #####: 2507:        JERRY_ASSERT (string_name_pos > 0);
    #####: 2508:        JERRY_ASSERT (string_name_pos <= string_named_properties_count);
        -: 2509:
    #####: 2510:        if (i < lazy_prop_name_count)
        -: 2511:        {
    #####: 2512:          string_names_p[lazy_string_name_pos++] = name_p;
        -: 2513:        }
        -: 2514:        else
        -: 2515:        {
    #####: 2516:          string_names_p[--string_name_pos] = name_p;
        -: 2517:        }
        -: 2518:      }
        -: 2519:    }
        -: 2520:
    #####: 2521:    JERRY_ASSERT (array_index_name_pos == array_index_named_properties_count);
    #####: 2522:    JERRY_ASSERT (string_name_pos - lazy_string_name_pos == 0);
        -: 2523:#if ENABLED (JERRY_ES2015)
    #####: 2524:    JERRY_ASSERT (symbol_name_pos == 0);
        -: 2525:#endif /* ENABLED (JERRY_ES2015) */
        -: 2526:
    #####: 2527:    ecma_collection_free (prop_names_p);
        -: 2528:
        -: 2529:    /* Third pass:
        -: 2530:     *   embedding own property names of current object of prototype chain to aggregate property names collection */
    #####: 2531:    for (uint32_t i = 0; i < all_properties_count; i++)
        -: 2532:    {
    #####: 2533:      bool is_append = true;
        -: 2534:
    #####: 2535:      ecma_string_t *name_p = names_p[i];
        -: 2536:
    #####: 2537:      uint8_t hash = (uint8_t) ecma_string_hash (name_p);
    #####: 2538:      uint32_t bitmap_row = (uint32_t) (hash / bitmap_row_size);
    #####: 2539:      uint32_t bitmap_column = (uint32_t) (hash % bitmap_row_size);
        -: 2540:
    #####: 2541:      if ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) == 0)
        -: 2542:      {
        -: 2543:        /* This hash has not been used before (for non-skipped). */
    #####: 2544:        names_hashes_bitmap[bitmap_row] |= (1u << bitmap_column);
        -: 2545:      }
        -: 2546:      else
        -: 2547:      {
        -: 2548:        /* Name with same hash has already occured. */
    #####: 2549:        buffer_p = ret_p->buffer_p;
        -: 2550:
    #####: 2551:        for (uint32_t j = 0; j < ret_p->item_count; j++)
        -: 2552:        {
    #####: 2553:          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);
        -: 2554:
    #####: 2555:          if (ecma_compare_ecma_strings (name_p, current_name_p))
        -: 2556:          {
    #####: 2557:            is_append = false;
    #####: 2558:            break;
        -: 2559:          }
        -: 2560:        }
        -: 2561:      }
        -: 2562:
    #####: 2563:      if (is_append)
        -: 2564:      {
    #####: 2565:        buffer_p = skipped_non_enumerable_p->buffer_p;
        -: 2566:
    #####: 2567:        for (uint32_t j = 0; j < skipped_non_enumerable_p->item_count; j++)
        -: 2568:        {
    #####: 2569:          ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[j]);
        -: 2570:
    #####: 2571:          if (ecma_compare_ecma_strings (name_p, current_name_p))
        -: 2572:          {
    #####: 2573:            is_append = false;
    #####: 2574:            break;
        -: 2575:          }
        -: 2576:        }
        -: 2577:      }
        -: 2578:
    #####: 2579:      if (is_append)
        -: 2580:      {
    #####: 2581:        JERRY_ASSERT ((names_hashes_bitmap[bitmap_row] & (1u << bitmap_column)) != 0);
        -: 2582:
    #####: 2583:        ecma_collection_push_back (ret_p, ecma_make_prop_name_value (name_p));
        -: 2584:      }
        -: 2585:      else
        -: 2586:      {
    #####: 2587:        ecma_deref_ecma_string (name_p);
        -: 2588:      }
        -: 2589:
        -: 2590:    }
        -: 2591:
    #####: 2592:    JMEM_FINALIZE_LOCAL_ARRAY (names_p);
        -: 2593:
    #####: 2594:    if (!is_with_prototype_chain || obj_p->u2.prototype_cp == JMEM_CP_NULL)
        -: 2595:    {
        -: 2596:      break;
        -: 2597:    }
        -: 2598:
    #####: 2599:    obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);
        -: 2600:  }
        -: 2601:
    #####: 2602:  ecma_collection_free (skipped_non_enumerable_p);
        -: 2603:
    #####: 2604:  return ret_p;
        -: 2605:} /* ecma_op_object_get_property_names */
        -: 2606:
        -: 2607:/**
        -: 2608: * The function is used in the assert of ecma_object_get_class_name
        -: 2609: *
        -: 2610: * @return true  - if class name is an object
        -: 2611: *         false - otherwise
        -: 2612: */
        -: 2613:inline static bool
    #####: 2614:ecma_object_check_class_name_is_object (ecma_object_t *obj_p) /**< object */
        -: 2615:{
        -: 2616:#ifndef JERRY_NDEBUG
    #####: 2617:  return (ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_GLOBAL)
        -: 2618:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
    #####: 2619:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_PROMISE_PROTOTYPE)
        -: 2620:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -: 2621:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 2622:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE)
    #####: 2623:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPEDARRAY_PROTOTYPE)
    #####: 2624:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE)
    #####: 2625:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8ARRAY_PROTOTYPE)
    #####: 2626:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT16ARRAY_PROTOTYPE)
    #####: 2627:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT16ARRAY_PROTOTYPE)
    #####: 2628:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT32ARRAY_PROTOTYPE)
    #####: 2629:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT32ARRAY_PROTOTYPE)
    #####: 2630:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT32ARRAY_PROTOTYPE)
    #####: 2631:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8CLAMPEDARRAY_PROTOTYPE)
        -: 2632:#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)
    #####: 2633:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT64ARRAY_PROTOTYPE)
        -: 2634:#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -: 2635:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 2636:#if ENABLED (JERRY_ES2015)
    #####: 2637:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_PROTOTYPE_UNSCOPABLES)
    #####: 2638:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE)
    #####: 2639:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ITERATOR_PROTOTYPE)
    #####: 2640:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_STRING_ITERATOR_PROTOTYPE)
    #####: 2641:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE)
    #####: 2642:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE)
    #####: 2643:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE)
    #####: 2644:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE)
    #####: 2645:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE)
    #####: 2646:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE)
    #####: 2647:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ERROR_PROTOTYPE)
    #####: 2648:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_STRING_PROTOTYPE)
    #####: 2649:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE)
    #####: 2650:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_NUMBER_PROTOTYPE)
    #####: 2651:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATE_PROTOTYPE)
    #####: 2652:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_PROTOTYPE)
    #####: 2653:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE)
        -: 2654:#endif /* ENABLED (JERRY_ES2015) */
        -: 2655:#if ENABLED (JERRY_ES2015_BUILTIN_MAP)
    #####: 2656:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_PROTOTYPE)
        -: 2657:#if ENABLED (JERRY_ES2015)
    #####: 2658:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_ITERATOR_PROTOTYPE)
        -: 2659:#endif /* ENABLED (JERRY_ES2015) */
        -: 2660:#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */
        -: 2661:#if ENABLED (JERRY_ES2015_BUILTIN_SET)
    #####: 2662:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_PROTOTYPE)
        -: 2663:#if ENABLED (JERRY_ES2015)
    #####: 2664:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_ITERATOR_PROTOTYPE)
        -: 2665:#endif /* ENABLED (JERRY_ES2015) */
        -: 2666:#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */
        -: 2667:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)
    #####: 2668:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE)
        -: 2669:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */
        -: 2670:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
    #####: 2671:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE)
        -: 2672:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
        -: 2673:#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)
    #####: 2674:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATAVIEW_PROTOTYPE)
        -: 2675:#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */
    #####: 2676:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE));
        -: 2677:#else /* JERRY_NDEBUG */
        -: 2678:  JERRY_UNUSED (obj_p);
        -: 2679:  return true;
        -: 2680:#endif /* !JERRY_NDEBUG */
        -: 2681:} /* ecma_object_check_class_name_is_object */
        -: 2682:
        -: 2683:/**
        -: 2684: * Get [[Class]] string of specified object
        -: 2685: *
        -: 2686: * @return class name magic string
        -: 2687: */
        -: 2688:lit_magic_string_id_t
    #####: 2689:ecma_object_get_class_name (ecma_object_t *obj_p) /**< object */
        -: 2690:{
    #####: 2691:  ecma_object_type_t type = ecma_get_object_type (obj_p);
        -: 2692:
    #####: 2693:  switch (type)
        -: 2694:  {
    #####: 2695:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 2696:    {
    #####: 2697:      return LIT_MAGIC_STRING_ARRAY_UL;
        -: 2698:    }
    #####: 2699:    case ECMA_OBJECT_TYPE_CLASS:
        -: 2700:    {
    #####: 2701:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 2702:
    #####: 2703:      return (lit_magic_string_id_t) ext_object_p->u.class_prop.class_id;
        -: 2704:    }
    #####: 2705:    case ECMA_OBJECT_TYPE_PSEUDO_ARRAY:
        -: 2706:    {
    #####: 2707:      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2708:
    #####: 2709:      switch (ext_obj_p->u.pseudo_array.type)
        -: 2710:      {
        -: 2711:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 2712:        case ECMA_PSEUDO_ARRAY_TYPEDARRAY:
        -: 2713:        case ECMA_PSEUDO_ARRAY_TYPEDARRAY_WITH_INFO:
        -: 2714:        {
    #####: 2715:          return (lit_magic_string_id_t) ext_obj_p->u.pseudo_array.u1.class_id;
        -: 2716:        }
        -: 2717:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 2718:#if ENABLED (JERRY_ES2015)
    #####: 2719:        case ECMA_PSEUDO_ARRAY_ITERATOR:
        -: 2720:        {
    #####: 2721:          return LIT_MAGIC_STRING_ARRAY_ITERATOR_UL;
        -: 2722:        }
    #####: 2723:        case ECMA_PSEUDO_SET_ITERATOR:
        -: 2724:        {
    #####: 2725:          return LIT_MAGIC_STRING_SET_ITERATOR_UL;
        -: 2726:        }
    #####: 2727:        case ECMA_PSEUDO_MAP_ITERATOR:
        -: 2728:        {
    #####: 2729:          return LIT_MAGIC_STRING_MAP_ITERATOR_UL;
        -: 2730:        }
        -: 2731:#endif /* ENABLED (JERRY_ES2015) */
        -: 2732:#if ENABLED (JERRY_ES2015)
    #####: 2733:        case ECMA_PSEUDO_STRING_ITERATOR:
        -: 2734:        {
    #####: 2735:          return LIT_MAGIC_STRING_STRING_ITERATOR_UL;
        -: 2736:        }
        -: 2737:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2738:        default:
        -: 2739:        {
    #####: 2740:          JERRY_ASSERT (ext_obj_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_ARGUMENTS);
        -: 2741:
    #####: 2742:          return LIT_MAGIC_STRING_ARGUMENTS_UL;
        -: 2743:        }
        -: 2744:      }
        -: 2745:
        -: 2746:      break;
        -: 2747:    }
    #####: 2748:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 2749:    case ECMA_OBJECT_TYPE_EXTERNAL_FUNCTION:
        -: 2750:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 2751:    {
    #####: 2752:      return LIT_MAGIC_STRING_FUNCTION_UL;
        -: 2753:    }
    #####: 2754:    default:
        -: 2755:    {
    #####: 2756:      JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL || type == ECMA_OBJECT_TYPE_PROXY);
        -: 2757:
    #####: 2758:      if (ecma_get_object_is_builtin (obj_p))
        -: 2759:      {
    #####: 2760:        ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2761:
    #####: 2762:        switch (ext_obj_p->u.built_in.id)
        -: 2763:        {
        -: 2764:#if ENABLED (JERRY_BUILTIN_MATH)
    #####: 2765:          case ECMA_BUILTIN_ID_MATH:
        -: 2766:          {
    #####: 2767:            return LIT_MAGIC_STRING_MATH_UL;
        -: 2768:          }
        -: 2769:#endif /* ENABLED (JERRY_BUILTIN_MATH) */
        -: 2770:#if ENABLED (JERRY_ES2015_BUILTIN_REFLECT)
    #####: 2771:          case ECMA_BUILTIN_ID_REFLECT:
        -: 2772:          {
    #####: 2773:            return LIT_MAGIC_STRING_REFLECT_UL;
        -: 2774:          }
        -: 2775:#endif /* ENABLED (JERRY_ES2015_BUILTIN_REFLECT) */
        -: 2776:#if ENABLED (JERRY_ES2015)
    #####: 2777:          case ECMA_BUILTIN_ID_GENERATOR:
        -: 2778:          {
    #####: 2779:            return LIT_MAGIC_STRING_GENERATOR_UL;
        -: 2780:          }
        -: 2781:#endif /* ENABLED (JERRY_ES2015) */
        -: 2782:#if ENABLED (JERRY_BUILTIN_JSON)
    #####: 2783:          case ECMA_BUILTIN_ID_JSON:
        -: 2784:          {
    #####: 2785:            return LIT_MAGIC_STRING_JSON_U;
        -: 2786:          }
        -: 2787:#endif /* ENABLED (JERRY_BUILTIN_JSON) */
        -: 2788:#if !ENABLED (JERRY_ES2015)
        -: 2789:#if ENABLED (JERRY_BUILTIN_ERRORS)
    #####: 2790:          case ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE:
        -: 2791:          case ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE:
        -: 2792:          case ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE:
        -: 2793:          case ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE:
        -: 2794:          case ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE:
        -: 2795:          case ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE:
        -: 2796:#endif /* ENABLED (JERRY_BUILTIN_ERRORS) */
        -: 2797:          case ECMA_BUILTIN_ID_ERROR_PROTOTYPE:
        -: 2798:          {
    #####: 2799:            return LIT_MAGIC_STRING_ERROR_UL;
        -: 2800:          }
        -: 2801:#endif /* !ENABLED (JERRY_ES2015) */
        -: 2802:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 2803:          case ECMA_BUILTIN_ID_PROXY:
        -: 2804:          {
    #####: 2805:            return LIT_MAGIC_STRING_FUNCTION_UL;
        -: 2806:          }
        -: 2807:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
    #####: 2808:          default:
        -: 2809:          {
    #####: 2810:            JERRY_ASSERT (ecma_object_check_class_name_is_object (obj_p));
        -: 2811:
    #####: 2812:            return LIT_MAGIC_STRING_OBJECT_UL;
        -: 2813:          }
        -: 2814:        }
        -: 2815:      }
        -: 2816:      else
        -: 2817:      {
    #####: 2818:        return LIT_MAGIC_STRING_OBJECT_UL;
        -: 2819:      }
        -: 2820:    }
        -: 2821:  }
        -: 2822:} /* ecma_object_get_class_name */
        -: 2823:
        -: 2824:/**
        -: 2825: * Get value of an object if the class matches
        -: 2826: *
        -: 2827: * @return value of the object if the class matches
        -: 2828: *         ECMA_VALUE_NOT_FOUND otherwise
        -: 2829: */
        -: 2830:inline bool JERRY_ATTR_ALWAYS_INLINE
     7848: 2831:ecma_object_class_is (ecma_object_t *object_p, /**< object */
        -: 2832:                      uint32_t class_id) /**< class id */
        -: 2833:{
     7848: 2834:  if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_CLASS)
        -: 2835:  {
     7848: 2836:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 2837:
     7848: 2838:    if (ext_object_p->u.class_prop.class_id == class_id)
        -: 2839:    {
     7848: 2840:      return true;
        -: 2841:    }
        -: 2842:  }
        -: 2843:
    #####: 2844:  return false;
        -: 2845:} /* ecma_object_class_is */
        -: 2846:
        -: 2847:/**
        -: 2848: * Checks if the given argument has [[RegExpMatcher]] internal slot
        -: 2849: *
        -: 2850: * @return true - if the given argument is a regexp
        -: 2851: *         false - otherwise
        -: 2852: */
        -: 2853:inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 2854:ecma_object_is_regexp_object (ecma_value_t arg) /**< argument */
        -: 2855:{
    #####: 2856:  return (ecma_is_value_object (arg)
    #####: 2857:          && ecma_object_class_is (ecma_get_object_from_value (arg), LIT_MAGIC_STRING_REGEXP_UL));
        -: 2858:} /* ecma_object_is_regexp_object */
        -: 2859:
        -: 2860:#if ENABLED (JERRY_ES2015)
        -: 2861:/**
        -: 2862: * Object's IsConcatSpreadable operation, used for Array.prototype.concat
        -: 2863: * It checks the argument's [Symbol.isConcatSpreadable] property value
        -: 2864: *
        -: 2865: * See also:
        -: 2866: *          ECMA-262 v6, 22.1.3.1.1;
        -: 2867: *
        -: 2868: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2869: *         ECMA_VALUE_TRUE - if the argument is concatSpreadable
        -: 2870: *         ECMA_VALUE_FALSE - otherwise
        -: 2871: */
        -: 2872:ecma_value_t
    #####: 2873:ecma_op_is_concat_spreadable (ecma_value_t arg) /**< argument */
        -: 2874:{
    #####: 2875:  if (!ecma_is_value_object (arg))
        -: 2876:  {
    #####: 2877:    return ECMA_VALUE_FALSE;
        -: 2878:  }
        -: 2879:
    #####: 2880:  ecma_value_t spreadable = ecma_op_object_get_by_symbol_id (ecma_get_object_from_value (arg),
        -: 2881:                                                             LIT_GLOBAL_SYMBOL_IS_CONCAT_SPREADABLE);
        -: 2882:
    #####: 2883:  if (ECMA_IS_VALUE_ERROR (spreadable))
        -: 2884:  {
    #####: 2885:    return spreadable;
        -: 2886:  }
        -: 2887:
    #####: 2888:  if (!ecma_is_value_undefined (spreadable))
        -: 2889:  {
    #####: 2890:    const bool to_bool = ecma_op_to_boolean (spreadable);
    #####: 2891:    ecma_free_value (spreadable);
    #####: 2892:    return ecma_make_boolean_value (to_bool);
        -: 2893:  }
        -: 2894:
    #####: 2895:  return ecma_is_value_array (arg);
        -: 2896:} /* ecma_op_is_concat_spreadable */
        -: 2897:
        -: 2898:/**
        -: 2899: * IsRegExp operation
        -: 2900: *
        -: 2901: * See also:
        -: 2902: *          ECMA-262 v6, 22.1.3.1.1;
        -: 2903: *
        -: 2904: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2905: *         ECMA_VALUE_TRUE - if the argument is regexp
        -: 2906: *         ECMA_VALUE_FALSE - otherwise
        -: 2907: */
        -: 2908:ecma_value_t
    #####: 2909:ecma_op_is_regexp (ecma_value_t arg) /**< argument */
        -: 2910:{
    #####: 2911:  if (!ecma_is_value_object (arg))
        -: 2912:  {
    #####: 2913:    return ECMA_VALUE_FALSE;
        -: 2914:  }
        -: 2915:
    #####: 2916:  ecma_value_t is_regexp = ecma_op_object_get_by_symbol_id (ecma_get_object_from_value (arg),
        -: 2917:                                                            LIT_GLOBAL_SYMBOL_MATCH);
        -: 2918:
    #####: 2919:  if (ECMA_IS_VALUE_ERROR (is_regexp))
        -: 2920:  {
    #####: 2921:    return is_regexp;
        -: 2922:  }
        -: 2923:
    #####: 2924:  if (!ecma_is_value_undefined (is_regexp))
        -: 2925:  {
    #####: 2926:    const bool to_bool = ecma_op_to_boolean (is_regexp);
    #####: 2927:    ecma_free_value (is_regexp);
    #####: 2928:    return ecma_make_boolean_value (to_bool);
        -: 2929:  }
        -: 2930:
    #####: 2931:  return ecma_make_boolean_value (ecma_object_is_regexp_object (arg));
        -: 2932:} /* ecma_op_is_regexp */
        -: 2933:
        -: 2934:/**
        -: 2935: * SpeciesConstructor operation
        -: 2936: * See also:
        -: 2937: *          ECMA-262 v6, 7.3.20;
        -: 2938: *
        -: 2939: * @return ecma_value
        -: 2940: *         returned value must be freed with ecma_free_value
        -: 2941: */
        -: 2942:ecma_value_t
    #####: 2943:ecma_op_species_constructor (ecma_object_t *this_value, /**< This Value */
        -: 2944:                             ecma_builtin_id_t default_constructor_id) /**< Builtin ID of default constructor */
        -: 2945:{
    #####: 2946:  ecma_object_t *default_constructor_p = ecma_builtin_get (default_constructor_id);
    #####: 2947:  ecma_value_t constructor = ecma_op_object_get_by_magic_id (this_value, LIT_MAGIC_STRING_CONSTRUCTOR);
    #####: 2948:  if (ECMA_IS_VALUE_ERROR (constructor))
        -: 2949:  {
    #####: 2950:    return constructor;
        -: 2951:  }
        -: 2952:
    #####: 2953:  if (ecma_is_value_undefined (constructor))
        -: 2954:  {
    #####: 2955:    ecma_ref_object (default_constructor_p);
    #####: 2956:    return ecma_make_object_value (default_constructor_p);
        -: 2957:  }
        -: 2958:
    #####: 2959:  if (!ecma_is_value_object (constructor))
        -: 2960:  {
    #####: 2961:    ecma_free_value (constructor);
    #####: 2962:    return ecma_raise_type_error (ECMA_ERR_MSG ("Constructor must be an Object"));
        -: 2963:  }
        -: 2964:
    #####: 2965:  ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
    #####: 2966:  ecma_value_t species = ecma_op_object_get_by_symbol_id (ctor_object_p, LIT_GLOBAL_SYMBOL_SPECIES);
    #####: 2967:  ecma_deref_object (ctor_object_p);
        -: 2968:
    #####: 2969:  if (ECMA_IS_VALUE_ERROR (species))
        -: 2970:  {
    #####: 2971:    return species;
        -: 2972:  }
        -: 2973:
    #####: 2974:  if (ecma_is_value_undefined (species) || ecma_is_value_null (species))
        -: 2975:  {
    #####: 2976:    ecma_ref_object (default_constructor_p);
    #####: 2977:    return ecma_make_object_value (default_constructor_p);
        -: 2978:  }
        -: 2979:
    #####: 2980:  if (!ecma_is_constructor (species))
        -: 2981:  {
    #####: 2982:    ecma_free_value (species);
    #####: 2983:    return ecma_raise_type_error (ECMA_ERR_MSG ("Species must be a Constructor"));
        -: 2984:  }
        -: 2985:
    #####: 2986:  return species;
        -: 2987:} /* ecma_op_species_constructor */
        -: 2988:
        -: 2989:/**
        -: 2990: * 7.3.18 Abstract operation Invoke when property name is a magic string
        -: 2991: *
        -: 2992: * @return ecma_value result of the invoked function or raised error
        -: 2993: *         note: returned value must be freed with ecma_free_value
        -: 2994: */
        -: 2995:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 2996:ecma_op_invoke_by_symbol_id (ecma_value_t object, /**< Object value */
        -: 2997:                             lit_magic_string_id_t symbol_id, /**< Symbol ID */
        -: 2998:                             ecma_value_t *args_p, /**< Argument list */
        -: 2999:                             ecma_length_t args_len) /**< Argument list length */
        -: 3000:{
    #####: 3001:  ecma_string_t *symbol_p = ecma_op_get_global_symbol (symbol_id);
    #####: 3002:  ecma_value_t ret_value = ecma_op_invoke (object, symbol_p, args_p, args_len);
    #####: 3003:  ecma_deref_ecma_string (symbol_p);
        -: 3004:
    #####: 3005:  return ret_value;
        -: 3006:} /* ecma_op_invoke_by_symbol_id */
        -: 3007:#endif /* ENABLED (JERRY_ES2015) */
        -: 3008:
        -: 3009:/**
        -: 3010: * 7.3.18 Abstract operation Invoke when property name is a magic string
        -: 3011: *
        -: 3012: * @return ecma_value result of the invoked function or raised error
        -: 3013: *         note: returned value must be freed with ecma_free_value
        -: 3014: */
        -: 3015:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3016:ecma_op_invoke_by_magic_id (ecma_value_t object, /**< Object value */
        -: 3017:                            lit_magic_string_id_t magic_string_id, /**< Magic string ID */
        -: 3018:                            ecma_value_t *args_p, /**< Argument list */
        -: 3019:                            ecma_length_t args_len) /**< Argument list length */
        -: 3020:{
    #####: 3021:  return ecma_op_invoke (object, ecma_get_magic_string (magic_string_id), args_p, args_len);
        -: 3022:} /* ecma_op_invoke_by_magic_id */
        -: 3023:
        -: 3024:/**
        -: 3025: * 7.3.18 Abstract operation Invoke
        -: 3026: *
        -: 3027: * @return ecma_value result of the invoked function or raised error
        -: 3028: *         note: returned value must be freed with ecma_free_value
        -: 3029: */
        -: 3030:ecma_value_t
    #####: 3031:ecma_op_invoke (ecma_value_t object, /**< Object value */
        -: 3032:                ecma_string_t *property_name_p, /**< Property name */
        -: 3033:                ecma_value_t *args_p, /**< Argument list */
        -: 3034:                ecma_length_t args_len) /**< Argument list length */
        -: 3035:{
        -: 3036:  /* 3. */
    #####: 3037:  ecma_value_t object_value = ecma_op_to_object (object);
    #####: 3038:  if (ECMA_IS_VALUE_ERROR (object_value))
        -: 3039:  {
    #####: 3040:    return object_value;
        -: 3041:  }
        -: 3042:
    #####: 3043:  ecma_object_t *object_p = ecma_get_object_from_value (object_value);
    #####: 3044:  ecma_value_t func = ecma_op_object_get (object_p, property_name_p);
        -: 3045:
    #####: 3046:  if (ECMA_IS_VALUE_ERROR (func))
        -: 3047:  {
    #####: 3048:    ecma_deref_object (object_p);
    #####: 3049:    return func;
        -: 3050:  }
        -: 3051:
        -: 3052:  /* 4. */
    #####: 3053:  if (!ecma_op_is_callable (func))
        -: 3054:  {
    #####: 3055:    ecma_free_value (func);
    #####: 3056:    ecma_deref_object (object_p);
    #####: 3057:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument is not callable"));
        -: 3058:  }
        -: 3059:
    #####: 3060:  ecma_object_t *func_obj_p = ecma_get_object_from_value (func);
    #####: 3061:  ecma_value_t call_result = ecma_op_function_call (func_obj_p, object, args_p, args_len);
    #####: 3062:  ecma_deref_object (object_p);
    #####: 3063:  ecma_deref_object (func_obj_p);
        -: 3064:
    #####: 3065:  return call_result;
        -: 3066:} /* ecma_op_invoke */
        -: 3067:
        -: 3068:/**
        -: 3069: * Ordinary object [[GetPrototypeOf]] operation
        -: 3070: *
        -: 3071: * See also:
        -: 3072: *          ECMAScript v6, 9.1.1
        -: 3073: *
        -: 3074: * @return the value of the [[Prototype]] internal slot of the given object.
        -: 3075: */
        -: 3076:inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3077:ecma_op_ordinary_object_get_prototype_of (ecma_object_t *obj_p) /**< object */
        -: 3078:{
    13096: 3079:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
    13096: 3080:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (obj_p));
        -: 3081:
    13096: 3082:  return obj_p->u2.prototype_cp;
        -: 3083:} /* ecma_op_ordinary_object_get_prototype_of */
        -: 3084:
        -: 3085:/**
        -: 3086: * Ordinary object [[SetPrototypeOf]] operation
        -: 3087: *
        -: 3088: * See also:
        -: 3089: *          ECMAScript v6, 9.1.2
        -: 3090: *
        -: 3091: * @return ECMA_VALUE_FALSE - if the operation fails
        -: 3092: *         ECMA_VALUE_TRUE - otherwise
        -: 3093: */
        -: 3094:inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3095:ecma_op_ordinary_object_set_prototype_of (ecma_object_t *obj_p, /**< base object */
        -: 3096:                                          ecma_value_t proto) /**< prototype object */
        -: 3097:{
    #####: 3098:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
    #####: 3099:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (obj_p));
        -: 3100:
        -: 3101:  /* 1. */
    #####: 3102:  JERRY_ASSERT (ecma_is_value_object (proto) || ecma_is_value_null (proto));
        -: 3103:
        -: 3104:  /* 3. */
    #####: 3105:  ecma_object_t *current_proto_p = ECMA_GET_POINTER (ecma_object_t, ecma_op_ordinary_object_get_prototype_of (obj_p));
    #####: 3106:  ecma_object_t *new_proto_p = ecma_is_value_null (proto) ? NULL : ecma_get_object_from_value (proto);
        -: 3107:
        -: 3108:  /* 4. */
    #####: 3109:  if (new_proto_p == current_proto_p)
        -: 3110:  {
    #####: 3111:    return ECMA_VALUE_TRUE;
        -: 3112:  }
        -: 3113:
        -: 3114:  /* 2 - 5. */
    #####: 3115:  if (!ecma_op_ordinary_object_is_extensible (obj_p))
        -: 3116:  {
    #####: 3117:    return ECMA_VALUE_FALSE;
        -: 3118:  }
        -: 3119:
        -: 3120:  /* 6. */
    #####: 3121:  ecma_object_t *iter_p = new_proto_p;
        -: 3122:
        -: 3123:  /* 7 - 8. */
        -: 3124:  while (true)
        -: 3125:  {
        -: 3126:    /* 8.a */
    #####: 3127:    if (iter_p == NULL)
        -: 3128:    {
    #####: 3129:      break;
        -: 3130:    }
        -: 3131:
        -: 3132:    /* 8.b */
    #####: 3133:    if (obj_p == iter_p)
        -: 3134:    {
    #####: 3135:      return ECMA_VALUE_FALSE;
        -: 3136:    }
        -: 3137:
        -: 3138:    /* 8.c.i */
        -: 3139:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 3140:    if (ECMA_OBJECT_IS_PROXY (iter_p))
        -: 3141:    {
    #####: 3142:      break;
        -: 3143:    }
        -: 3144:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 3145:
        -: 3146:    /* 8.c.ii */
    #####: 3147:    iter_p = ECMA_GET_POINTER (ecma_object_t, ecma_op_ordinary_object_get_prototype_of (iter_p));
        -: 3148:  }
        -: 3149:
        -: 3150:  /* 9. */
    #####: 3151:  ECMA_SET_POINTER (obj_p->u2.prototype_cp, new_proto_p);
        -: 3152:
        -: 3153:  /* 10. */
    #####: 3154:  return ECMA_VALUE_TRUE;
        -: 3155:} /* ecma_op_ordinary_object_set_prototype_of */
        -: 3156:
        -: 3157:/**
        -: 3158: * [[IsExtensible]] operation for Ordinary object.
        -: 3159: *
        -: 3160: * See also:
        -: 3161: *          ECMAScript v6, 9.1.2
        -: 3162: *
        -: 3163: * @return true  - if object is extensible
        -: 3164: *         false - otherwise
        -: 3165: */
        -: 3166:inline bool JERRY_ATTR_PURE
     9170: 3167:ecma_op_ordinary_object_is_extensible (ecma_object_t *object_p) /**< object */
        -: 3168:{
     9170: 3169:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3170:
     9170: 3171:  return (object_p->type_flags_refs & ECMA_OBJECT_FLAG_EXTENSIBLE) != 0;
        -: 3172:} /* ecma_op_ordinary_object_is_extensible */
        -: 3173:
        -: 3174:/**
        -: 3175: * Set value of [[Extensible]] object's internal property.
        -: 3176: */
        -: 3177:void JERRY_ATTR_NOINLINE
        1: 3178:ecma_op_ordinary_object_prevent_extensions (ecma_object_t *object_p) /**< object */
        -: 3179:{
        1: 3180:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        1: 3181:  object_p->type_flags_refs = (uint16_t) (object_p->type_flags_refs & ~ECMA_OBJECT_FLAG_EXTENSIBLE);
        1: 3182:} /* ecma_op_ordinary_object_prevent_extensions */
        -: 3183:
        -: 3184:/**
        -: 3185: * Checks whether an object (excluding prototypes) has a named property
        -: 3186: *
        -: 3187: * @return true - if property is found
        -: 3188: *         false - otherwise
        -: 3189: */
        -: 3190:inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 3191:ecma_op_ordinary_object_has_own_property (ecma_object_t *object_p, /**< the object */
        -: 3192:                                          ecma_string_t *property_name_p) /**< property name */
        -: 3193:{
        3: 3194:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3195:
        3: 3196:  ecma_property_t property = ecma_op_object_get_own_property (object_p,
        -: 3197:                                                              property_name_p,
        -: 3198:                                                              NULL,
        -: 3199:                                                              ECMA_PROPERTY_GET_HAS_OWN_PROP);
        -: 3200:
        3: 3201:  return property != ECMA_PROPERTY_TYPE_NOT_FOUND && property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -: 3202:} /* ecma_op_ordinary_object_has_own_property */
        -: 3203:
        -: 3204:/**
        -: 3205: * @}
        -: 3206: * @}
        -: 3207: */
