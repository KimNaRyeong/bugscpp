        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-typedarray-object.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-iterator-object.h"
        -:   19:#include "ecma-typedarray-object.h"
        -:   20:#include "ecma-arraybuffer-object.h"
        -:   21:#include "ecma-function-object.h"
        -:   22:#include "ecma-builtin-helpers.h"
        -:   23:#include "ecma-try-catch-macro.h"
        -:   24:#include "ecma-objects.h"
        -:   25:#include "ecma-builtins.h"
        -:   26:#include "ecma-exceptions.h"
        -:   27:#include "ecma-gc.h"
        -:   28:#include "ecma-globals.h"
        -:   29:#include "ecma-helpers.h"
        -:   30:#include "jcontext.h"
        -:   31:
        -:   32:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -:   33:
        -:   34:/** \addtogroup ecma ECMA
        -:   35: * @{
        -:   36: *
        -:   37: * \addtogroup ecmatypedarrayobject ECMA TypedArray object related routines
        -:   38: * @{
        -:   39: */
        -:   40:
        -:   41:/**
        -:   42: * Read an int8_t value from the given arraybuffer
        -:   43: */
        -:   44:static ecma_number_t
    #####:   45:ecma_typedarray_get_int8_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   46:{
    #####:   47:  int8_t num = (int8_t) *src;
    #####:   48:  return (ecma_number_t) num;
        -:   49:} /* ecma_typedarray_get_int8_element */
        -:   50:
        -:   51:/**
        -:   52: * Read an uint8_t value from the given arraybuffer
        -:   53: */
        -:   54:static ecma_number_t
    #####:   55:ecma_typedarray_get_uint8_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   56:{
    #####:   57:  uint8_t num = (uint8_t) *src;
    #####:   58:  return (ecma_number_t) num;
        -:   59:} /* ecma_typedarray_get_uint8_element */
        -:   60:
        -:   61:/**
        -:   62: * Read an int16_t value from the given arraybuffer
        -:   63: */
        -:   64:static ecma_number_t
    #####:   65:ecma_typedarray_get_int16_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   66:{
    #####:   67:  int16_t num;
    #####:   68:  memcpy (&num, src, sizeof (int16_t));
    #####:   69:  return (ecma_number_t) num;
        -:   70:} /* ecma_typedarray_get_int16_element */
        -:   71:
        -:   72:/**
        -:   73: * Read an uint16_t value from the given arraybuffer
        -:   74: */
        -:   75:static ecma_number_t
    #####:   76:ecma_typedarray_get_uint16_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   77:{
    #####:   78:  uint16_t num;
    #####:   79:  memcpy (&num, src, sizeof (uint16_t));
    #####:   80:  return (ecma_number_t) num;
        -:   81:} /* ecma_typedarray_get_uint16_element */
        -:   82:
        -:   83:/**
        -:   84: * Read an int32_t value from the given arraybuffer
        -:   85: */
        -:   86:static ecma_number_t
    #####:   87:ecma_typedarray_get_int32_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   88:{
    #####:   89:  int32_t num;
    #####:   90:  memcpy (&num, src, sizeof (int32_t));
    #####:   91:  return (ecma_number_t) num;
        -:   92:} /* ecma_typedarray_get_int32_element */
        -:   93:
        -:   94:/**
        -:   95: * Read an uint32_t value from the given arraybuffer
        -:   96: */
        -:   97:static ecma_number_t
    #####:   98:ecma_typedarray_get_uint32_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:   99:{
    #####:  100:  uint32_t num;
    #####:  101:  memcpy (&num, src, sizeof (uint32_t));
    #####:  102:  return (ecma_number_t) num;
        -:  103:} /* ecma_typedarray_get_uint32_element */
        -:  104:
        -:  105:/**
        -:  106: * Read a float value from the given arraybuffer
        -:  107: */
        -:  108:static ecma_number_t
    #####:  109:ecma_typedarray_get_float_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  110:{
    #####:  111:  float num;
    #####:  112:  memcpy (&num, src, sizeof (float));
    #####:  113:  return (ecma_number_t) num;
        -:  114:} /* ecma_typedarray_get_float_element */
        -:  115:
        -:  116:/**
        -:  117: * Read a double value from the given arraybuffer
        -:  118: */
        -:  119:static ecma_number_t
    #####:  120:ecma_typedarray_get_double_element (lit_utf8_byte_t *src) /**< the location in the internal arraybuffer */
        -:  121:{
    #####:  122:  double num;
    #####:  123:  memcpy (&num, src, sizeof (double));
    #####:  124:  return (ecma_number_t) num;
        -:  125:} /* ecma_typedarray_get_double_element */
        -:  126:
        -:  127:/**
        -:  128: * Normalize the given ecma_number_t to an uint32_t value
        -:  129: */
        -:  130:static uint32_t
    #####:  131:ecma_typedarray_setter_number_to_uint32 (ecma_number_t value) /**< the number value to normalize */
        -:  132:{
    #####:  133:  uint32_t uint32_value = 0;
        -:  134:
    #####:  135:  if (!ecma_number_is_nan (value) && !ecma_number_is_infinity (value))
        -:  136:  {
    #####:  137:    bool is_negative = false;
        -:  138:
    #####:  139:    if (value < 0)
        -:  140:    {
    #####:  141:      is_negative = true;
    #####:  142:      value = -value;
        -:  143:    }
        -:  144:
    #####:  145:    if (value > ((ecma_number_t) 0xffffffff))
        -:  146:    {
    #####:  147:      value = (ecma_number_t) (fmod (value, (ecma_number_t) 0x100000000));
        -:  148:    }
        -:  149:
    #####:  150:    uint32_value = (uint32_t) value;
        -:  151:
    #####:  152:    if (is_negative)
        -:  153:    {
    #####:  154:      uint32_value = (uint32_t) (-(int32_t) uint32_value);
        -:  155:    }
        -:  156:  }
        -:  157:
    #####:  158:  return uint32_value;
        -:  159:} /* ecma_typedarray_setter_number_to_uint32 */
        -:  160:
        -:  161:/**
        -:  162: * Write an int8_t value into the given arraybuffer
        -:  163: */
        -:  164:static void
    #####:  165:ecma_typedarray_set_int8_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  166:                                  ecma_number_t value) /**< the number value to set */
        -:  167:{
    #####:  168:  int8_t num = (int8_t) ecma_typedarray_setter_number_to_uint32 (value);
    #####:  169:  *dst_p = (lit_utf8_byte_t) num;
    #####:  170:} /* ecma_typedarray_set_int8_element */
        -:  171:
        -:  172:/**
        -:  173: * Write an uint8_t value into the given arraybuffer
        -:  174: */
        -:  175:static void
    #####:  176:ecma_typedarray_set_uint8_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  177:                                   ecma_number_t value) /**< the number value to set */
        -:  178:{
    #####:  179:  uint8_t num = (uint8_t) ecma_typedarray_setter_number_to_uint32 (value);
    #####:  180:  *dst_p = (lit_utf8_byte_t) num;
    #####:  181:} /* ecma_typedarray_set_uint8_element */
        -:  182:
        -:  183:/**
        -:  184: * Write an uint8_t clamped value into the given arraybuffer
        -:  185: */
        -:  186:static void
    #####:  187:ecma_typedarray_set_uint8_clamped_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  188:                                           ecma_number_t value) /**< the number value to set */
        -:  189:{
        -:  190:  uint8_t clamped;
        -:  191:
    #####:  192:  if (value > 255)
        -:  193:  {
    #####:  194:    clamped = 255;
        -:  195:  }
    #####:  196:  else if (value <= 0)
        -:  197:  {
    #####:  198:    clamped = 0;
        -:  199:  }
        -:  200:  else
        -:  201:  {
    #####:  202:    clamped = (uint8_t) value;
        -:  203:
    #####:  204:    if (clamped + 0.5 < value
    #####:  205:        || (clamped + 0.5 == value && (clamped % 2) == 1))
        -:  206:    {
    #####:  207:      clamped ++;
        -:  208:    }
        -:  209:  }
        -:  210:
    #####:  211:  *dst_p = (lit_utf8_byte_t) clamped;
    #####:  212:} /* ecma_typedarray_set_uint8_clamped_element */
        -:  213:
        -:  214:/**
        -:  215: * Write an int16_t value into the given arraybuffer
        -:  216: */
        -:  217:static void
    #####:  218:ecma_typedarray_set_int16_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  219:                                   ecma_number_t value) /**< the number value to set */
        -:  220:{
    #####:  221:  int16_t num = (int16_t) ecma_typedarray_setter_number_to_uint32 (value);
    #####:  222:  memcpy (dst_p, &num, sizeof (int16_t));
    #####:  223:} /* ecma_typedarray_set_int16_element */
        -:  224:
        -:  225:/**
        -:  226: * Write an uint8_t value into the given arraybuffer
        -:  227: */
        -:  228:static void
    #####:  229:ecma_typedarray_set_uint16_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  230:                                    ecma_number_t value) /**< the number value to set */
        -:  231:{
    #####:  232:  uint16_t num = (uint16_t) ecma_typedarray_setter_number_to_uint32 (value);
    #####:  233:  memcpy (dst_p, &num, sizeof (uint16_t));
    #####:  234:} /* ecma_typedarray_set_uint16_element */
        -:  235:
        -:  236:/**
        -:  237: * Write an int32_t value into the given arraybuffer
        -:  238: */
        -:  239:static void
    #####:  240:ecma_typedarray_set_int32_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  241:                                   ecma_number_t value) /**< the number value to set */
        -:  242:{
    #####:  243:  int32_t num = (int32_t) ecma_typedarray_setter_number_to_uint32 (value);
    #####:  244:  memcpy (dst_p, &num, sizeof (int32_t));
    #####:  245:} /* ecma_typedarray_set_int32_element */
        -:  246:
        -:  247:/**
        -:  248: * Write an uint32_t value into the given arraybuffer
        -:  249: */
        -:  250:static void
    #####:  251:ecma_typedarray_set_uint32_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  252:                                    ecma_number_t value) /**< the number value to set */
        -:  253:{
    #####:  254:  uint32_t num = (uint32_t) ecma_typedarray_setter_number_to_uint32 (value);
    #####:  255:  memcpy (dst_p, &num, sizeof (uint32_t));
    #####:  256:} /* ecma_typedarray_set_uint32_element */
        -:  257:
        -:  258:/**
        -:  259: * Write a float value into the given arraybuffer
        -:  260: */
        -:  261:static void
    #####:  262:ecma_typedarray_set_float_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  263:                                   ecma_number_t value) /**< the number value to set */
        -:  264:{
    #####:  265:  float num = (float) value;
    #####:  266:  memcpy (dst_p, &num, sizeof (float));
    #####:  267:} /* ecma_typedarray_set_float_element */
        -:  268:
        -:  269:#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)
        -:  270:/**
        -:  271: * Write a double value into the given arraybuffer
        -:  272: */
        -:  273:static void
    #####:  274:ecma_typedarray_set_double_element (lit_utf8_byte_t *dst_p, /**< the location in the internal arraybuffer */
        -:  275:                                    ecma_number_t value) /**< the number value to set */
        -:  276:{
    #####:  277:  double num = (double) value;
    #####:  278:  memcpy (dst_p, &num, sizeof (double));
    #####:  279:} /* ecma_typedarray_set_double_element */
        -:  280:#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -:  281:
        -:  282:/**
        -:  283: * Builtin id of the first %TypedArray% builtin routine intrinsic object
        -:  284: */
        -:  285:#define ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_INT8ARRAY
        -:  286:
        -:  287:#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)
        -:  288:/**
        -:  289: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  290: */
        -:  291:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_FLOAT64ARRAY
        -:  292:#else /* !ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -:  293:/**
        -:  294: * Builtin id of the last %TypedArray% builtin routine intrinsic object
        -:  295: */
        -:  296:#define ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID ECMA_BUILTIN_ID_FLOAT32ARRAY
        -:  297:#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -:  298:
        -:  299:/**
        -:  300: * Builtin id of the first %TypedArray% builtin prototype intrinsic object
        -:  301: */
        -:  302:#define ECMA_FIRST_TYPEDARRAY_BUILTIN_PROTOTYPE_ID ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE
        -:  303:
        -:  304:/**
        -:  305: * List of typedarray getters based on their builtin id
        -:  306: */
        -:  307:static const ecma_typedarray_getter_fn_t ecma_typedarray_getters[] =
        -:  308:{
        -:  309:  ecma_typedarray_get_int8_element,   /**< Int8Array */
        -:  310:  ecma_typedarray_get_uint8_element,  /**< Uint8Array */
        -:  311:  ecma_typedarray_get_uint8_element,  /**< Uint8ClampedArray */
        -:  312:  ecma_typedarray_get_int16_element,  /**< Int16Array */
        -:  313:  ecma_typedarray_get_uint16_element, /**< Int32Array */
        -:  314:  ecma_typedarray_get_int32_element,  /**< Uint32Array */
        -:  315:  ecma_typedarray_get_uint32_element, /**< Uint32Array */
        -:  316:  ecma_typedarray_get_float_element,  /**< Float32Array */
        -:  317:#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)
        -:  318:  ecma_typedarray_get_double_element, /**< Float64Array */
        -:  319:#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -:  320:};
        -:  321:
        -:  322:/**
        -:  323: * List of typedarray setters based on their builtin id
        -:  324: */
        -:  325:static const ecma_typedarray_setter_fn_t ecma_typedarray_setters[] =
        -:  326:{
        -:  327:  ecma_typedarray_set_int8_element,          /**< Int8Array */
        -:  328:  ecma_typedarray_set_uint8_element,         /**< Uint8Array */
        -:  329:  ecma_typedarray_set_uint8_clamped_element, /**< Uint8ClampedArray */
        -:  330:  ecma_typedarray_set_int16_element,         /**< Int16Array */
        -:  331:  ecma_typedarray_set_uint16_element,        /**< Int32Array */
        -:  332:  ecma_typedarray_set_int32_element,         /**< Uint32Array */
        -:  333:  ecma_typedarray_set_uint32_element,        /**< Uint32Array */
        -:  334:  ecma_typedarray_set_float_element,         /**< Float32Array */
        -:  335:#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)
        -:  336:  ecma_typedarray_set_double_element,        /**< Float64Array */
        -:  337:#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -:  338:};
        -:  339:
        -:  340:/**
        -:  341: * List of typedarray element shift sizes based on their builtin id
        -:  342: */
        -:  343:static const uint8_t ecma_typedarray_element_shift_sizes[] =
        -:  344:{
        -:  345:  0, /**< Int8Array */
        -:  346:  0, /**< Uint8Array */
        -:  347:  0, /**< Uint8ClampedArray */
        -:  348:  1, /**< Int16Array */
        -:  349:  1, /**< Uint16Array */
        -:  350:  2, /**< Int32Array */
        -:  351:  2, /**< Uint32Array */
        -:  352:  2, /**< Float32Array */
        -:  353:#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)
        -:  354:  3, /**< Float64Array */
        -:  355:#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -:  356:};
        -:  357:
        -:  358:/**
        -:  359: * List of typedarray class magic strings based on their builtin id
        -:  360: */
        -:  361:static const uint16_t ecma_typedarray_magic_string_list[] =
        -:  362:{
        -:  363:  (uint16_t) LIT_MAGIC_STRING_INT8_ARRAY_UL,          /**< Int8Array */
        -:  364:  (uint16_t) LIT_MAGIC_STRING_UINT8_ARRAY_UL,         /**< Uint8Array */
        -:  365:  (uint16_t) LIT_MAGIC_STRING_UINT8_CLAMPED_ARRAY_UL, /**< Uint8ClampedArray */
        -:  366:  (uint16_t) LIT_MAGIC_STRING_INT16_ARRAY_UL,         /**< Int16Array */
        -:  367:  (uint16_t) LIT_MAGIC_STRING_UINT16_ARRAY_UL,        /**< Uint16Array */
        -:  368:  (uint16_t) LIT_MAGIC_STRING_INT32_ARRAY_UL,         /**< Int32Array */
        -:  369:  (uint16_t) LIT_MAGIC_STRING_UINT32_ARRAY_UL,        /**< Uint32Array */
        -:  370:  (uint16_t) LIT_MAGIC_STRING_FLOAT32_ARRAY_UL,       /**< Float32Array */
        -:  371:#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)
        -:  372:  (uint16_t) LIT_MAGIC_STRING_FLOAT64_ARRAY_UL,       /**< Float64Array */
        -:  373:#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -:  374:};
        -:  375:
        -:  376:/**
        -:  377: * Get typedarray's getter function callback
        -:  378: *
        -:  379: * @return ecma_typedarray_getter_fn_t: the getter function for the given builtin TypedArray id
        -:  380: */
        -:  381:inline ecma_typedarray_getter_fn_t JERRY_ATTR_ALWAYS_INLINE
    #####:  382:ecma_get_typedarray_getter_fn (ecma_typedarray_type_t typedarray_id)
        -:  383:{
    #####:  384:  return ecma_typedarray_getters[typedarray_id];
        -:  385:} /* ecma_get_typedarray_getter_fn */
        -:  386:
        -:  387:/**
        -:  388: * get typedarray's element value
        -:  389: *
        -:  390: * @return ecma_number_t: the value of the element
        -:  391: */
        -:  392:inline ecma_number_t JERRY_ATTR_ALWAYS_INLINE
    #####:  393:ecma_get_typedarray_element (lit_utf8_byte_t *src_p,
        -:  394:                             ecma_typedarray_type_t typedarray_id)
        -:  395:{
    #####:  396:  return ecma_typedarray_getters[typedarray_id](src_p);
        -:  397:} /* ecma_get_typedarray_element */
        -:  398:
        -:  399:/**
        -:  400: * Get typedarray's setter function callback
        -:  401: *
        -:  402: * @return ecma_typedarray_setter_fn_t: the setter function for the given builtin TypedArray id
        -:  403: */
        -:  404:inline ecma_typedarray_setter_fn_t JERRY_ATTR_ALWAYS_INLINE
    #####:  405:ecma_get_typedarray_setter_fn (ecma_typedarray_type_t typedarray_id)
        -:  406:{
    #####:  407:  return ecma_typedarray_setters[typedarray_id];
        -:  408:} /* ecma_get_typedarray_setter_fn */
        -:  409:
        -:  410:/**
        -:  411: * set typedarray's element value
        -:  412: */
        -:  413:inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  414:ecma_set_typedarray_element (lit_utf8_byte_t *dst_p,
        -:  415:                             ecma_number_t value,
        -:  416:                             ecma_typedarray_type_t typedarray_id)
        -:  417:{
    #####:  418:  ecma_typedarray_setters[typedarray_id](dst_p, value);
    #####:  419:} /* ecma_set_typedarray_element */
        -:  420:
        -:  421:/**
        -:  422: * Get the element shift size of a TypedArray type.
        -:  423: *
        -:  424: * @return uint8_t
        -:  425: */
        -:  426:inline uint8_t JERRY_ATTR_ALWAYS_INLINE
        2:  427:ecma_typedarray_helper_get_shift_size (ecma_typedarray_type_t typedarray_id)
        -:  428:{
        2:  429:  return ecma_typedarray_element_shift_sizes[typedarray_id];
        -:  430:} /* ecma_typedarray_helper_get_shift_size */
        -:  431:
        -:  432:/**
        -:  433: * Check if the builtin is a TypedArray type.
        -:  434: *
        -:  435: * @return bool: - true if based on the given id it is a TypedArray
        -:  436: *               - false if based on the given id it is not a TypedArray
        -:  437: */
        -:  438:bool
    #####:  439:ecma_typedarray_helper_is_typedarray (ecma_builtin_id_t builtin_id) /**< the builtin id of a type **/
        -:  440:{
        -:  441:  return ((builtin_id >= ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID)
    #####:  442:          && (builtin_id <= ECMA_LAST_TYPEDARRAY_BUILTIN_ROUTINE_ID));
        -:  443:} /* ecma_typedarray_helper_is_typedarray */
        -:  444:
        -:  445:/**
        -:  446: * Get the prototype ID of a TypedArray type.
        -:  447: *
        -:  448: * @return ecma_builtin_id_t
        -:  449: */
        -:  450:ecma_builtin_id_t
        2:  451:ecma_typedarray_helper_get_prototype_id (ecma_typedarray_type_t typedarray_id) /**< the id of the typedarray **/
        -:  452:{
        2:  453:  return (ecma_builtin_id_t) (ECMA_FIRST_TYPEDARRAY_BUILTIN_PROTOTYPE_ID + typedarray_id);
        -:  454:} /* ecma_typedarray_helper_get_prototype_id */
        -:  455:
        -:  456:/**
        -:  457: * Get the constructor ID of a TypedArray type.
        -:  458: *
        -:  459: * @return ecma_builtin_id_t
        -:  460: */
        -:  461:ecma_builtin_id_t
    #####:  462:ecma_typedarray_helper_get_constructor_id (ecma_typedarray_type_t typedarray_id) /**< the id of the typedarray **/
        -:  463:{
    #####:  464:  return (ecma_builtin_id_t) (ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID + typedarray_id);
        -:  465:} /* ecma_typedarray_helper_get_constructor_id */
        -:  466:
        -:  467:/**
        -:  468: * Get the built-in TypedArray type of the given object.
        -:  469: *
        -:  470: * @return ecma_typedarray_type_t
        -:  471: */
        -:  472:ecma_typedarray_type_t
    #####:  473:ecma_get_typedarray_id (ecma_object_t *obj_p) /**< typedarray object **/
        -:  474:{
    #####:  475:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -:  476:
    #####:  477:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -:  478:
    #####:  479:  return (ecma_typedarray_type_t) ext_object_p->u.pseudo_array.extra_info;
        -:  480:} /* ecma_get_typedarray_id */
        -:  481:
        -:  482:/**
        -:  483: * Get the built-in TypedArray type of the given object.
        -:  484: *
        -:  485: * @return ecma_typedarray_type_t
        -:  486: */
        -:  487:ecma_typedarray_type_t
    #####:  488:ecma_typedarray_helper_builtin_to_typedarray_id (ecma_builtin_id_t builtin_id)
        -:  489:{
    #####:  490:  JERRY_ASSERT (ecma_typedarray_helper_is_typedarray (builtin_id));
        -:  491:
    #####:  492:  return (ecma_typedarray_type_t) (builtin_id - ECMA_FIRST_TYPEDARRAY_BUILTIN_ROUTINE_ID);
        -:  493:} /* ecma_typedarray_helper_builtin_to_typedarray_id */
        -:  494:
        -:  495:/**
        -:  496: * Create a TypedArray object by given array_length
        -:  497: *
        -:  498: * See also: ES2015 22.2.1.2.1
        -:  499: *
        -:  500: * @return ecma value of the new typedarray object
        -:  501: *         Returned value must be freed with ecma_free_value
        -:  502: */
        -:  503:ecma_value_t
        2:  504:ecma_typedarray_create_object_with_length (ecma_length_t array_length, /**< length of the typedarray */
        -:  505:                                           ecma_object_t *src_buffer_p, /**< source buffer */
        -:  506:                                           ecma_object_t *proto_p, /**< prototype object */
        -:  507:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -:  508:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  509:{
        2:  510:  if (array_length > (UINT32_MAX >> element_size_shift))
        -:  511:  {
    #####:  512:    return ecma_raise_range_error (ECMA_ERR_MSG ("Maximum typedarray size is reached."));
        -:  513:  }
        -:  514:
        2:  515:  ecma_length_t byte_length = array_length << element_size_shift;
        -:  516:
        2:  517:  if (byte_length > UINT32_MAX - sizeof (ecma_extended_object_t) - JMEM_ALIGNMENT + 1)
        -:  518:  {
    #####:  519:    return ecma_raise_range_error (ECMA_ERR_MSG ("Maximum typedarray size is reached."));
        -:  520:  }
        -:  521:
        2:  522:  ecma_object_t *new_arraybuffer_p = NULL;
        2:  523:  if (src_buffer_p == NULL)
        -:  524:  {
        2:  525:    new_arraybuffer_p = ecma_arraybuffer_new_object (byte_length);
        -:  526:  }
        -:  527:  else
        -:  528:  {
    #####:  529:    ecma_value_t ctor_proto = ecma_op_species_constructor (src_buffer_p, ECMA_BUILTIN_ID_ARRAYBUFFER);
    #####:  530:    if (ECMA_IS_VALUE_ERROR (ctor_proto))
        -:  531:    {
    #####:  532:      return ctor_proto;
        -:  533:    }
        -:  534:
    #####:  535:    ecma_object_t *ctor_proto_p = ecma_get_object_from_value (ctor_proto);
        -:  536:
    #####:  537:    ecma_value_t byte_length_val = ecma_make_uint32_value (byte_length);
    #####:  538:    ecma_value_t new_arraybuffer = ecma_op_function_construct (ctor_proto_p,
        -:  539:                                                               ctor_proto_p,
        -:  540:                                                               &byte_length_val,
        -:  541:                                                               1);
    #####:  542:    ecma_deref_object (ctor_proto_p);
    #####:  543:    ecma_free_value (byte_length_val);
        -:  544:
    #####:  545:    new_arraybuffer_p = ecma_get_object_from_value (new_arraybuffer);
        -:  546:  }
        -:  547:
        2:  548:  ecma_object_t *object_p = ecma_create_object (proto_p,
        -:  549:                                                sizeof (ecma_extended_object_t),
        -:  550:                                                ECMA_OBJECT_TYPE_PSEUDO_ARRAY);
        -:  551:
        2:  552:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        2:  553:  ext_object_p->u.pseudo_array.u1.class_id = ecma_typedarray_magic_string_list[typedarray_id];
        2:  554:  ext_object_p->u.pseudo_array.type = ECMA_PSEUDO_ARRAY_TYPEDARRAY;
        2:  555:  ext_object_p->u.pseudo_array.extra_info = (uint8_t) typedarray_id;
        2:  556:  ext_object_p->u.pseudo_array.u2.arraybuffer = ecma_make_object_value (new_arraybuffer_p);
        -:  557:
        2:  558:  ecma_deref_object (new_arraybuffer_p);
        -:  559:
        2:  560:  return ecma_make_object_value (object_p);
        -:  561:} /* ecma_typedarray_create_object_with_length */
        -:  562:
        -:  563:/**
        -:  564: * Create a TypedArray object by given buffer, offset, and array_length
        -:  565: *
        -:  566: * See also: ES2015 22.2.1.5
        -:  567: *
        -:  568: * @return ecma value of the new typedarray object
        -:  569: *         Returned value must be freed with ecma_free_value
        -:  570: */
        -:  571:static ecma_value_t
    #####:  572:ecma_typedarray_create_object_with_buffer (ecma_object_t *arraybuffer_p, /**< the arraybuffer inside */
        -:  573:                                           ecma_length_t byte_offset, /**< the byte offset of the arraybuffer */
        -:  574:                                           ecma_length_t array_length, /**< length of the typedarray */
        -:  575:                                           ecma_object_t *proto_p, /**< prototype object */
        -:  576:                                           uint8_t element_size_shift, /**< the size shift of the element length */
        -:  577:                                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  578:{
    #####:  579:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  580:  {
    #####:  581:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -:  582:  }
    #####:  583:  ecma_length_t expected_length = (ecma_arraybuffer_get_length (arraybuffer_p) >> element_size_shift);
        -:  584:
    #####:  585:  bool needs_ext_typedarray_obj = (byte_offset != 0 || array_length != expected_length);
        -:  586:
    #####:  587:  size_t object_size = (needs_ext_typedarray_obj ? sizeof (ecma_extended_typedarray_object_t)
    #####:  588:                                                 : sizeof (ecma_extended_object_t));
        -:  589:
    #####:  590:  ecma_object_t *object_p = ecma_create_object (proto_p, object_size, ECMA_OBJECT_TYPE_PSEUDO_ARRAY);
        -:  591:
    #####:  592:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  593:  ext_object_p->u.pseudo_array.u1.class_id = ecma_typedarray_magic_string_list[typedarray_id];
    #####:  594:  ext_object_p->u.pseudo_array.type = ECMA_PSEUDO_ARRAY_TYPEDARRAY;
    #####:  595:  ext_object_p->u.pseudo_array.extra_info = (uint8_t) typedarray_id;
    #####:  596:  ext_object_p->u.pseudo_array.u2.arraybuffer = ecma_make_object_value (arraybuffer_p);
        -:  597:
    #####:  598:  if (needs_ext_typedarray_obj)
        -:  599:  {
    #####:  600:    ext_object_p->u.pseudo_array.type = ECMA_PSEUDO_ARRAY_TYPEDARRAY_WITH_INFO;
        -:  601:
    #####:  602:    ecma_extended_typedarray_object_t *typedarray_info_p = (ecma_extended_typedarray_object_t *) object_p;
    #####:  603:    typedarray_info_p->array_length = array_length;
    #####:  604:    typedarray_info_p->byte_offset = byte_offset;
        -:  605:  }
        -:  606:
    #####:  607:  return ecma_make_object_value (object_p);
        -:  608:} /* ecma_typedarray_create_object_with_buffer */
        -:  609:
        -:  610:/**
        -:  611: * Create a TypedArray object by given another TypedArray object
        -:  612: *
        -:  613: * See also: ES2015 22.2.1.3
        -:  614: *
        -:  615: * @return ecma value of the new typedarray object
        -:  616: *         Returned value must be freed with ecma_free_value
        -:  617: */
        -:  618:static ecma_value_t
    #####:  619:ecma_typedarray_create_object_with_typedarray (ecma_object_t *typedarray_p, /**< a typedarray object */
        -:  620:                                               ecma_object_t *proto_p, /**< prototype object */
        -:  621:                                               uint8_t element_size_shift, /**< the size shift of the element length */
        -:  622:                                               ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  623:{
    #####:  624:  ecma_length_t array_length = ecma_typedarray_get_length (typedarray_p);
    #####:  625:  ecma_object_t *src_arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####:  626:  if (ecma_arraybuffer_is_detached (src_arraybuffer_p))
        -:  627:  {
    #####:  628:    return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid detached ArrayBuffer."));
        -:  629:  }
        -:  630:
    #####:  631:  ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (array_length,
        -:  632:                                                                           src_arraybuffer_p,
        -:  633:                                                                           proto_p,
        -:  634:                                                                           element_size_shift,
        -:  635:                                                                           typedarray_id);
        -:  636:
    #####:  637:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  638:  {
    #####:  639:    return new_typedarray;
        -:  640:  }
        -:  641:
    #####:  642:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
        -:  643:
    #####:  644:  lit_utf8_byte_t *src_buf_p = ecma_arraybuffer_get_buffer (src_arraybuffer_p);
        -:  645:
    #####:  646:  ecma_object_t *dst_arraybuffer_p = ecma_typedarray_get_arraybuffer (new_typedarray_p);
    #####:  647:  lit_utf8_byte_t *dst_buf_p = ecma_arraybuffer_get_buffer (dst_arraybuffer_p);
        -:  648:
    #####:  649:  src_buf_p += ecma_typedarray_get_offset (typedarray_p);
        -:  650:
    #####:  651:  ecma_typedarray_type_t src_id = ecma_get_typedarray_id (typedarray_p);
        -:  652:
    #####:  653:  if (src_id == typedarray_id)
        -:  654:  {
    #####:  655:    memcpy (dst_buf_p, src_buf_p, array_length << element_size_shift);
        -:  656:  }
        -:  657:  else
        -:  658:  {
    #####:  659:    uint32_t src_element_size = 1u << ecma_typedarray_get_element_size_shift (typedarray_p);
    #####:  660:    uint32_t dst_element_size = 1u << element_size_shift;
    #####:  661:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_id);
    #####:  662:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (typedarray_id);
        -:  663:
    #####:  664:    for (uint32_t i = 0; i < array_length; i++)
        -:  665:    {
        -:  666:      /* Convert values from source to destination format. */
    #####:  667:      ecma_number_t tmp = src_typedarray_getter_cb (src_buf_p);
    #####:  668:      target_typedarray_setter_cb (dst_buf_p, tmp);
        -:  669:
    #####:  670:      src_buf_p += src_element_size;
    #####:  671:      dst_buf_p += dst_element_size;
        -:  672:    }
        -:  673:  }
        -:  674:
    #####:  675:  return new_typedarray;
        -:  676:} /* ecma_typedarray_create_object_with_typedarray */
        -:  677:
        -:  678:/**
        -:  679: * Helper method for ecma_op_typedarray_from
        -:  680: *
        -:  681: * @return ECMA_VALUE_TRUE - if setting the given value to the new typedarray was successful
        -:  682: *         ECMA_VALUE_ERROR - otherwise
        -:  683: */
        -:  684:static ecma_value_t
    #####:  685:ecma_op_typedarray_from_helper (ecma_value_t this_val, /**< this_arg for the above from function */
        -:  686:                                ecma_value_t current_value, /**< given value to set */
        -:  687:                                uint32_t index, /**< currrent index */
        -:  688:                                ecma_object_t *func_object_p, /**< map function object */
        -:  689:                                ecma_typedarray_info_t *info_p, /**< typedarray info */
        -:  690:                                ecma_typedarray_setter_fn_t setter_cb) /**< setter callback function */
        -:  691:{
        -:  692:  ecma_value_t mapped_value;
    #####:  693:  if (func_object_p != NULL)
        -:  694:  {
        -:  695:    /* 17.d 17.f */
    #####:  696:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  697:    ecma_value_t call_args[] = { current_value, current_index };
        -:  698:
    #####:  699:    ecma_value_t cb_value = ecma_op_function_call (func_object_p, this_val, call_args, 2);
        -:  700:
    #####:  701:    ecma_free_value (current_index);
    #####:  702:    ecma_free_value (current_value);
        -:  703:
    #####:  704:    if (ECMA_IS_VALUE_ERROR (cb_value))
        -:  705:    {
    #####:  706:      return cb_value;
        -:  707:    }
        -:  708:
    #####:  709:    mapped_value = cb_value;
        -:  710:  }
        -:  711:  else
        -:  712:  {
    #####:  713:    mapped_value = current_value;
        -:  714:  }
        -:  715:
    #####:  716:  ecma_number_t num_var;
    #####:  717:  ecma_value_t mapped_number = ecma_get_number (mapped_value, &num_var);
    #####:  718:  ecma_free_value (mapped_value);
        -:  719:
    #####:  720:  if (ECMA_IS_VALUE_ERROR (mapped_number))
        -:  721:  {
    #####:  722:    return mapped_number;
        -:  723:  }
        -:  724:
    #####:  725:  if (index >= info_p->length)
        -:  726:  {
    #####:  727:    return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid argument type."));
        -:  728:  }
        -:  729:
    #####:  730:  setter_cb (info_p->buffer_p + (index << info_p->shift), num_var);
        -:  731:
    #####:  732:  return ECMA_VALUE_TRUE;
        -:  733:} /* ecma_op_typedarray_from_helper */
        -:  734:
        -:  735:/**
        -:  736: * Create a TypedArray object by transforming from an array-like object or iterable object
        -:  737: *
        -:  738: * See also: ES2015 22.2.2.1
        -:  739: *
        -:  740: * @return ecma value of the new typedarray object
        -:  741: *         Returned value must be freed with ecma_free_value
        -:  742: */
        -:  743:ecma_value_t
    #####:  744:ecma_op_typedarray_from (ecma_value_t items_val, /**< the source array-like object */
        -:  745:                         ecma_value_t map_fn_val, /**< map function */
        -:  746:                         ecma_value_t this_val, /**< this_arg for the above map function */
        -:  747:                         ecma_object_t *proto_p, /**< prototype object */
        -:  748:                         uint8_t element_size_shift, /**< the size shift of the element length */
        -:  749:                         ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -:  750:{
        -:  751:  /* 3 */
    #####:  752:  JERRY_ASSERT (ecma_op_is_callable (map_fn_val) || ecma_is_value_undefined (map_fn_val));
        -:  753:
        -:  754:  /* 4-5 */
    #####:  755:  ecma_object_t *func_object_p = NULL;
    #####:  756:  if (!ecma_is_value_undefined (map_fn_val))
        -:  757:  {
    #####:  758:    func_object_p = ecma_get_object_from_value (map_fn_val);
        -:  759:  }
        -:  760:
        -:  761:  /* 6 */
    #####:  762:  ecma_value_t using_iterator = ecma_op_get_method_by_symbol_id (items_val, LIT_GLOBAL_SYMBOL_ITERATOR);
        -:  763:
        -:  764:  /* 7 */
    #####:  765:  if (ECMA_IS_VALUE_ERROR (using_iterator))
        -:  766:  {
    #####:  767:    return using_iterator;
        -:  768:  }
        -:  769:
        -:  770:  /* 8 */
    #####:  771:  if (!ecma_is_value_undefined (using_iterator))
        -:  772:  {
        -:  773:    /* 8.a */
    #####:  774:    ecma_value_t iterator = ecma_op_get_iterator (items_val, using_iterator);
    #####:  775:    ecma_free_value (using_iterator);
        -:  776:
        -:  777:    /* 8.b */
    #####:  778:    if (ECMA_IS_VALUE_ERROR (iterator))
        -:  779:    {
    #####:  780:      return iterator;
        -:  781:    }
        -:  782:
        -:  783:    /* 8.c */
    #####:  784:    ecma_collection_t *values_p = ecma_new_collection ();
    #####:  785:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  786:
        -:  787:    /* 8.e */
        -:  788:    while (true)
    #####:  789:    {
        -:  790:      /* 8.e.i */
    #####:  791:      ecma_value_t next = ecma_op_iterator_step (iterator);
        -:  792:
        -:  793:      /* 8.e.ii */
    #####:  794:      if (ECMA_IS_VALUE_ERROR (next))
        -:  795:      {
    #####:  796:        ret_value = next;
    #####:  797:        break;
        -:  798:      }
        -:  799:
    #####:  800:      if (next == ECMA_VALUE_FALSE)
        -:  801:      {
    #####:  802:        break;
        -:  803:      }
        -:  804:
        -:  805:      /* 8.e.iii */
    #####:  806:      ecma_value_t next_value = ecma_op_iterator_value (next);
    #####:  807:      ecma_free_value (next);
        -:  808:
    #####:  809:      if (ECMA_IS_VALUE_ERROR (next_value))
        -:  810:      {
    #####:  811:        ret_value = next_value;
    #####:  812:        break;
        -:  813:      }
        -:  814:
    #####:  815:      ecma_collection_push_back (values_p, next_value);
        -:  816:    }
        -:  817:
    #####:  818:    ecma_free_value (iterator);
        -:  819:
    #####:  820:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  821:    {
    #####:  822:      ecma_collection_free (values_p);
    #####:  823:      return ret_value;
        -:  824:    }
        -:  825:
        -:  826:    /* 8.g */
    #####:  827:    ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (values_p->item_count,
        -:  828:                                                                             NULL,
        -:  829:                                                                             proto_p,
        -:  830:                                                                             element_size_shift,
        -:  831:                                                                             typedarray_id);
        -:  832:
        -:  833:    /* 8.h */
    #####:  834:    if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  835:    {
    #####:  836:      ecma_collection_free (values_p);
    #####:  837:      return new_typedarray;
        -:  838:    }
        -:  839:
    #####:  840:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####:  841:    ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####:  842:    ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
        -:  843:
    #####:  844:    ret_value = ecma_make_object_value (new_typedarray_p);
        -:  845:
        -:  846:    /* 8.j */
    #####:  847:    for (uint32_t index = 0; index < values_p->item_count; index++)
        -:  848:    {
    #####:  849:      ecma_value_t set_value = ecma_op_typedarray_from_helper (this_val,
    #####:  850:                                                               values_p->buffer_p[index],
        -:  851:                                                               index,
        -:  852:                                                               func_object_p,
        -:  853:                                                               &info,
        -:  854:                                                               setter_cb);
        -:  855:
    #####:  856:      if (ECMA_IS_VALUE_ERROR (set_value))
        -:  857:      {
    #####:  858:        for (uint32_t j = index + 1; j < values_p->item_count; j++)
        -:  859:        {
    #####:  860:          ecma_free_value (values_p->buffer_p[j]);
        -:  861:        }
        -:  862:
    #####:  863:        ret_value = set_value;
    #####:  864:        break;
        -:  865:      }
        -:  866:    }
        -:  867:
    #####:  868:    ecma_collection_destroy (values_p);
        -:  869:
    #####:  870:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  871:    {
    #####:  872:      ecma_deref_object (new_typedarray_p);
        -:  873:    }
        -:  874:
    #####:  875:    return ret_value;
        -:  876:  }
        -:  877:
        -:  878:  /* 10 */
    #####:  879:  ecma_value_t arraylike_object_val = ecma_op_to_object (items_val);
        -:  880:
    #####:  881:  if (ECMA_IS_VALUE_ERROR (arraylike_object_val))
        -:  882:  {
    #####:  883:    return arraylike_object_val;
        -:  884:  }
        -:  885:
    #####:  886:  ecma_object_t *arraylike_object_p = ecma_get_object_from_value (arraylike_object_val);
        -:  887:
        -:  888:  /* 12 */
    #####:  889:  uint32_t len;
    #####:  890:  ecma_value_t len_value = ecma_op_object_get_length (arraylike_object_p, &len);
        -:  891:
    #####:  892:  if (ECMA_IS_VALUE_ERROR (len_value))
        -:  893:  {
    #####:  894:    ecma_deref_object (arraylike_object_p);
    #####:  895:    return len_value;
        -:  896:  }
        -:  897:
        -:  898:  /* 14 */
    #####:  899:  ecma_value_t new_typedarray = ecma_typedarray_create_object_with_length (len,
        -:  900:                                                                           NULL,
        -:  901:                                                                           proto_p,
        -:  902:                                                                           element_size_shift,
        -:  903:                                                                           typedarray_id);
        -:  904:
    #####:  905:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  906:  {
    #####:  907:    ecma_deref_object (arraylike_object_p);
    #####:  908:    return new_typedarray;
        -:  909:  }
        -:  910:
    #####:  911:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####:  912:  ecma_typedarray_info_t info = ecma_typedarray_get_info (new_typedarray_p);
    #####:  913:  ecma_typedarray_setter_fn_t setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####:  914:  ecma_value_t ret_value = ecma_make_object_value (new_typedarray_p);
        -:  915:
        -:  916:  /* 17 */
    #####:  917:  for (uint32_t index = 0; index < len; index++)
        -:  918:  {
    #####:  919:    ecma_value_t current_value = ecma_op_object_find_by_uint32_index (arraylike_object_p, index);
        -:  920:
    #####:  921:    if (ECMA_IS_VALUE_ERROR (current_value))
        -:  922:    {
    #####:  923:      ret_value = current_value;
    #####:  924:      break;
        -:  925:    }
        -:  926:
    #####:  927:    if (ecma_is_value_found (current_value))
        -:  928:    {
    #####:  929:      ecma_value_t set_value = ecma_op_typedarray_from_helper (this_val,
        -:  930:                                                               current_value,
        -:  931:                                                               index,
        -:  932:                                                               func_object_p,
        -:  933:                                                               &info,
        -:  934:                                                               setter_cb);
        -:  935:
    #####:  936:      if (ECMA_IS_VALUE_ERROR (set_value))
        -:  937:      {
    #####:  938:        ret_value = set_value;
    #####:  939:        break;
        -:  940:      }
        -:  941:    }
        -:  942:  }
        -:  943:
    #####:  944:  ecma_deref_object (arraylike_object_p);
        -:  945:
    #####:  946:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  947:  {
    #####:  948:    ecma_deref_object (new_typedarray_p);
        -:  949:  }
        -:  950:
    #####:  951:  return ret_value;
        -:  952:} /* ecma_op_typedarray_from */
        -:  953:
        -:  954:/**
        -:  955: * Get the arraybuffer of the typedarray object
        -:  956: *
        -:  957: * @return the pointer to the internal arraybuffer
        -:  958: */
        -:  959:inline ecma_object_t * JERRY_ATTR_ALWAYS_INLINE
      584:  960:ecma_typedarray_get_arraybuffer (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -:  961:{
      584:  962:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -:  963:
      584:  964:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -:  965:
      584:  966:  return ecma_get_object_from_value (ext_object_p->u.pseudo_array.u2.arraybuffer);
        -:  967:} /* ecma_typedarray_get_arraybuffer */
        -:  968:
        -:  969:/**
        -:  970: * Get the element size shift in the typedarray object
        -:  971: *
        -:  972: * @return the size shift of the element, size is 1 << shift
        -:  973: */
        -:  974:uint8_t
    #####:  975:ecma_typedarray_get_element_size_shift (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -:  976:{
    #####:  977:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -:  978:
    #####:  979:  return ecma_typedarray_helper_get_shift_size (ecma_get_typedarray_id (typedarray_p));
        -:  980:} /* ecma_typedarray_get_element_size_shift */
        -:  981:
        -:  982:/**
        -:  983: * Get the array length of the typedarray object
        -:  984: *
        -:  985: * @return the array length
        -:  986: */
        -:  987:ecma_length_t
    #####:  988:ecma_typedarray_get_length (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -:  989:{
    #####:  990:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -:  991:
    #####:  992:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -:  993:
    #####:  994:  if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_TYPEDARRAY)
        -:  995:  {
    #####:  996:    ecma_object_t *arraybuffer_p = ecma_get_object_from_value (ext_object_p->u.pseudo_array.u2.arraybuffer);
    #####:  997:    ecma_length_t buffer_length = ecma_arraybuffer_get_length (arraybuffer_p);
    #####:  998:    uint8_t shift = ecma_typedarray_get_element_size_shift (typedarray_p);
        -:  999:
    #####: 1000:    return buffer_length >> shift;
        -: 1001:  }
        -: 1002:
    #####: 1003:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1004:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1005:  {
    #####: 1006:    return 0;
        -: 1007:  }
        -: 1008:
    #####: 1009:  ecma_extended_typedarray_object_t *info_p = (ecma_extended_typedarray_object_t *) ext_object_p;
        -: 1010:
    #####: 1011:  return info_p->array_length;
        -: 1012:} /* ecma_typedarray_get_length */
        -: 1013:
        -: 1014:/**
        -: 1015: * Get the offset of the internal arraybuffer
        -: 1016: *
        -: 1017: * @return the offset
        -: 1018: */
        -: 1019:ecma_length_t
    #####: 1020:ecma_typedarray_get_offset (ecma_object_t *typedarray_p) /**< the pointer to the typedarray object */
        -: 1021:{
    #####: 1022:  JERRY_ASSERT (ecma_object_is_typedarray (typedarray_p));
        -: 1023:
    #####: 1024:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) typedarray_p;
        -: 1025:
    #####: 1026:  if (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_TYPEDARRAY)
        -: 1027:  {
    #####: 1028:    return 0;
        -: 1029:  }
        -: 1030:
    #####: 1031:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1032:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1033:  {
    #####: 1034:    return 0;
        -: 1035:  }
        -: 1036:
    #####: 1037:  ecma_extended_typedarray_object_t *info_p = (ecma_extended_typedarray_object_t *) ext_object_p;
        -: 1038:
    #####: 1039:  return info_p->byte_offset;
        -: 1040:} /* ecma_typedarray_get_offset */
        -: 1041:
        -: 1042:/**
        -: 1043: * Utility function: return the pointer of the data buffer referenced by the typed array
        -: 1044: *
        -: 1045: * @return pointer to the data buffer
        -: 1046: */
        -: 1047:lit_utf8_byte_t *
    #####: 1048:ecma_typedarray_get_buffer (ecma_object_t *typedarray_p) /**< the pointer to the typed array object */
        -: 1049:{
    #####: 1050:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 1051:
    #####: 1052:  return ecma_arraybuffer_get_buffer (arraybuffer_p) + ecma_typedarray_get_offset (typedarray_p);
        -: 1053:} /* ecma_typedarray_get_buffer */
        -: 1054:
        -: 1055:/**
        -: 1056: * Create a new typedarray object.
        -: 1057: *
        -: 1058: * The struct of the typedarray object
        -: 1059: *   ecma_object_t
        -: 1060: *   extend_part
        -: 1061: *   typedarray_info
        -: 1062: *
        -: 1063: * @return ecma value of the new typedarray object
        -: 1064: *         Returned value must be freed with ecma_free_value
        -: 1065: */
        -: 1066:ecma_value_t
        2: 1067:ecma_op_create_typedarray (const ecma_value_t *arguments_list_p, /**< the arg list passed to typedarray construct */
        -: 1068:                           ecma_length_t arguments_list_len, /**< the length of the arguments_list_p */
        -: 1069:                           ecma_object_t *proto_p, /**< prototype object */
        -: 1070:                           uint8_t element_size_shift, /**< the size shift of the element length */
        -: 1071:                           ecma_typedarray_type_t typedarray_id) /**< id of the typedarray */
        -: 1072:{
        2: 1073:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -: 1074:
        2: 1075:  ecma_value_t ret = ECMA_VALUE_EMPTY;
        -: 1076:
        2: 1077:  if (arguments_list_len == 0)
        -: 1078:  {
        -: 1079:    /* 22.2.1.1 */
        1: 1080:    ret = ecma_typedarray_create_object_with_length (0, NULL, proto_p, element_size_shift, typedarray_id);
        -: 1081:  }
        1: 1082:  else if (!ecma_is_value_object (arguments_list_p[0]))
        -: 1083:  {
        -: 1084:    /* 22.2.1.2 */
        1: 1085:    if (ecma_is_value_undefined (arguments_list_p[0]))
        -: 1086:    {
    #####: 1087:      return ecma_raise_type_error (ECMA_ERR_MSG ("length argument is undefined"));
        -: 1088:    }
        -: 1089:
        1: 1090:    ECMA_OP_TO_NUMBER_TRY_CATCH (num, arguments_list_p[0], ret);
        -: 1091:
        1: 1092:    uint32_t length = ecma_number_to_uint32 (num);
        -: 1093:
        1: 1094:    if (num != ((ecma_number_t) length))
        -: 1095:    {
    #####: 1096:      ret = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid typedarray length."));
        -: 1097:    }
        -: 1098:    else
        -: 1099:    {
        1: 1100:      ret = ecma_typedarray_create_object_with_length (length,
        -: 1101:                                                       NULL,
        -: 1102:                                                       proto_p,
        -: 1103:                                                       element_size_shift,
        -: 1104:                                                       typedarray_id);
        -: 1105:    }
        -: 1106:
        -: 1107:    ECMA_OP_TO_NUMBER_FINALIZE (num);
        -: 1108:  }
    #####: 1109:  else if (ecma_is_value_object (arguments_list_p[0]))
        -: 1110:  {
    #####: 1111:    ecma_object_t *obj_p = ecma_get_object_from_value (arguments_list_p[0]);
    #####: 1112:    if (ecma_object_is_typedarray (obj_p))
        -: 1113:    {
        -: 1114:      /* 22.2.1.3 */
    #####: 1115:      ecma_object_t *typedarray_p = obj_p;
    #####: 1116:      ret = ecma_typedarray_create_object_with_typedarray (typedarray_p,
        -: 1117:                                                           proto_p,
        -: 1118:                                                           element_size_shift,
        -: 1119:                                                           typedarray_id);
        -: 1120:    }
    #####: 1121:    else if (ecma_object_class_is (obj_p, LIT_MAGIC_STRING_ARRAY_BUFFER_UL))
        -: 1122:    {
        -: 1123:      /* 22.2.1.5 */
    #####: 1124:      ecma_object_t *arraybuffer_p = obj_p;
    #####: 1125:      ecma_value_t arg2 = ((arguments_list_len > 1) ? arguments_list_p[1]
    #####: 1126:                                                    : ECMA_VALUE_UNDEFINED);
        -: 1127:
    #####: 1128:      ecma_value_t arg3 = ((arguments_list_len > 2) ? arguments_list_p[2]
    #####: 1129:                                                    : ECMA_VALUE_UNDEFINED);
        -: 1130:
    #####: 1131:      ecma_number_t offset;
    #####: 1132:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg2, &offset)))
        -: 1133:      {
    #####: 1134:        return ECMA_VALUE_ERROR;
        -: 1135:      }
        -: 1136:
    #####: 1137:      if (ecma_number_is_negative (offset))
        -: 1138:      {
    #####: 1139:        ret = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset."));
        -: 1140:      }
    #####: 1141:      else if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1142:      {
    #####: 1143:        ret = ecma_raise_type_error (ECMA_ERR_MSG ("Invalid detached ArrayBuffer."));
        -: 1144:      }
        -: 1145:      else
        -: 1146:      {
    #####: 1147:        ecma_length_t buf_byte_length = ecma_arraybuffer_get_length (arraybuffer_p);
    #####: 1148:        ecma_length_t new_byte_length = 0;
        -: 1149:
    #####: 1150:        if (ecma_is_value_undefined (arg3))
        -: 1151:        {
    #####: 1152:          if (buf_byte_length % (uint32_t) (1 << element_size_shift) != 0)
        -: 1153:          {
    #####: 1154:            ret = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid length."));
        -: 1155:          }
    #####: 1156:          else if (buf_byte_length < offset)
        -: 1157:          {
    #####: 1158:            ret = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid length."));
        -: 1159:          }
        -: 1160:          else
        -: 1161:          {
    #####: 1162:            new_byte_length = (ecma_length_t) (buf_byte_length - offset);
        -: 1163:          }
        -: 1164:        }
        -: 1165:        else
        -: 1166:        {
    #####: 1167:          uint32_t new_length;
    #####: 1168:          if (ECMA_IS_VALUE_ERROR (ecma_op_to_length (arg3, &new_length)))
        -: 1169:          {
    #####: 1170:            return ECMA_VALUE_ERROR;
        -: 1171:          }
        -: 1172:
    #####: 1173:          if (new_length > (UINT32_MAX >> element_size_shift))
        -: 1174:          {
    #####: 1175:            ret = ecma_raise_range_error (ECMA_ERR_MSG ("Maximum typedarray size is reached."));
        -: 1176:          }
        -: 1177:          else
        -: 1178:          {
    #####: 1179:            new_byte_length = (ecma_length_t) new_length << element_size_shift;
        -: 1180:
    #####: 1181:            if (((ecma_number_t) new_byte_length + offset) > buf_byte_length)
        -: 1182:            {
    #####: 1183:              ret = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid length."));
        -: 1184:            }
        -: 1185:          }
        -: 1186:        }
        -: 1187:
    #####: 1188:        if (ecma_is_value_empty (ret))
        -: 1189:        {
    #####: 1190:          ecma_length_t array_length = new_byte_length >> element_size_shift;
    #####: 1191:          ret = ecma_typedarray_create_object_with_buffer (arraybuffer_p,
        -: 1192:                                                           (ecma_length_t) offset,
        -: 1193:                                                           array_length,
        -: 1194:                                                           proto_p,
        -: 1195:                                                           element_size_shift,
        -: 1196:                                                           typedarray_id);
        -: 1197:        }
        -: 1198:      }
        -: 1199:    }
        -: 1200:    else
        -: 1201:    {
        -: 1202:      /* 22.2.1.4 */
    #####: 1203:      ecma_value_t undef = ECMA_VALUE_UNDEFINED;
    #####: 1204:      ret = ecma_op_typedarray_from (arguments_list_p[0],
        -: 1205:                                     undef,
        -: 1206:                                     undef,
        -: 1207:                                     proto_p,
        -: 1208:                                     element_size_shift,
        -: 1209:                                     typedarray_id);
        -: 1210:    }
        -: 1211:  }
        -: 1212:
        2: 1213:  return ret;
        -: 1214:} /* ecma_op_create_typedarray */
        -: 1215:
        -: 1216:/**
        -: 1217: * Check if the object is typedarray
        -: 1218: *
        -: 1219: * @return true - if object is a TypedArray object
        -: 1220: *         false - otherwise
        -: 1221: */
        -: 1222:bool
      584: 1223:ecma_object_is_typedarray (ecma_object_t *obj_p) /**< the target object need to be checked */
        -: 1224:{
      584: 1225:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
        -: 1226:
      584: 1227:  if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_PSEUDO_ARRAY)
        -: 1228:  {
      584: 1229:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 1230:
      584: 1231:    return ((ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_TYPEDARRAY)
      584: 1232:            || (ext_object_p->u.pseudo_array.type == ECMA_PSEUDO_ARRAY_TYPEDARRAY_WITH_INFO));
        -: 1233:  }
        -: 1234:
    #####: 1235:  return false;
        -: 1236:} /* ecma_object_is_typedarray */
        -: 1237:
        -: 1238:/**
        -: 1239: * Check if the value is typedarray
        -: 1240: *
        -: 1241: * @return true - if value is a TypedArray object
        -: 1242: *         false - otherwise
        -: 1243: */
        -: 1244:bool
    #####: 1245:ecma_is_typedarray (ecma_value_t value) /**< the target need to be checked */
        -: 1246:{
    #####: 1247:  if (!ecma_is_value_object (value))
        -: 1248:  {
    #####: 1249:    return false;
        -: 1250:  }
        -: 1251:
    #####: 1252:  return ecma_object_is_typedarray (ecma_get_object_from_value (value));
        -: 1253:} /* ecma_is_typedarray */
        -: 1254:
        -: 1255:/**
        -: 1256: * List names of a TypedArray object's integer indexed properties
        -: 1257: *
        -: 1258: * @return void
        -: 1259: */
        -: 1260:void
    #####: 1261:ecma_op_typedarray_list_lazy_property_names (ecma_object_t *obj_p, /**< a TypedArray object */
        -: 1262:                                             ecma_collection_t *main_collection_p) /**< 'main' collection */
        -: 1263:{
    #####: 1264:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -: 1265:
    #####: 1266:  ecma_length_t array_length = ecma_typedarray_get_length (obj_p);
        -: 1267:
    #####: 1268:  for (ecma_length_t i = 0; i < array_length; i++)
        -: 1269:  {
    #####: 1270:    ecma_string_t *name_p = ecma_new_ecma_string_from_uint32 (i);
        -: 1271:
    #####: 1272:    ecma_collection_push_back (main_collection_p, ecma_make_string_value (name_p));
        -: 1273:  }
    #####: 1274:} /* ecma_op_typedarray_list_lazy_property_names */
        -: 1275:
        -: 1276:/**
        -: 1277: * Define the integer number property value of the typedarray
        -: 1278: *
        -: 1279: * See also: ES2015 9.4.5.3: 3.c
        -: 1280: *
        -: 1281: * @return boolean, false if failed
        -: 1282: */
        -: 1283:bool
    #####: 1284:ecma_op_typedarray_define_index_prop (ecma_object_t *obj_p, /**< a TypedArray object */
        -: 1285:                                      uint32_t index, /**< the index number */
        -: 1286:                                      const ecma_property_descriptor_t *property_desc_p) /**< the description of
        -: 1287:                                                                                               the prop */
        -: 1288:{
    #####: 1289:  JERRY_ASSERT (ecma_object_is_typedarray (obj_p));
        -: 1290:
    #####: 1291:  ecma_length_t array_length = ecma_typedarray_get_length (obj_p);
        -: 1292:
    #####: 1293:  if ((index >= array_length)
    #####: 1294:      || (property_desc_p->flags & (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED))
    #####: 1295:      || ((property_desc_p->flags & (ECMA_PROP_IS_CONFIGURABLE_DEFINED | ECMA_PROP_IS_CONFIGURABLE))
        -: 1296:           == (ECMA_PROP_IS_CONFIGURABLE_DEFINED | ECMA_PROP_IS_CONFIGURABLE))
    #####: 1297:      || ((property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE_DEFINED)
    #####: 1298:          && !(property_desc_p->flags & ECMA_PROP_IS_ENUMERABLE))
    #####: 1299:      || ((property_desc_p->flags & ECMA_PROP_IS_WRITABLE_DEFINED)
    #####: 1300:          && !(property_desc_p->flags & ECMA_PROP_IS_WRITABLE)))
        -: 1301:  {
    #####: 1302:    return false;
        -: 1303:  }
        -: 1304:
    #####: 1305:  if (property_desc_p->flags & ECMA_PROP_IS_VALUE_DEFINED)
        -: 1306:  {
    #####: 1307:    ecma_number_t num_var;
    #####: 1308:    ecma_value_t error = ecma_get_number (property_desc_p->value, &num_var);
        -: 1309:
    #####: 1310:    if (ECMA_IS_VALUE_ERROR (error))
        -: 1311:    {
    #####: 1312:      jcontext_release_exception ();
    #####: 1313:      return false;
        -: 1314:    }
    #####: 1315:    ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
        -: 1316:
    #####: 1317:    if (index >= info.length)
        -: 1318:    {
    #####: 1319:      return false;
        -: 1320:    }
        -: 1321:
    #####: 1322:    lit_utf8_byte_t *src_buffer = info.buffer_p + (index << info.shift);
    #####: 1323:    ecma_set_typedarray_element (src_buffer, num_var, info.id);
        -: 1324:  }
        -: 1325:
    #####: 1326:  return true;
        -: 1327:} /* ecma_op_typedarray_define_index_prop */
        -: 1328:
        -: 1329:/**
        -: 1330: * Create a typedarray object based on the "type" and arraylength
        -: 1331: * The "type" is same with arg1
        -: 1332: *
        -: 1333: * @return ecma_value_t
        -: 1334: */
        -: 1335:ecma_value_t
    #####: 1336:ecma_op_create_typedarray_with_type_and_length (ecma_typedarray_type_t typedarray_id, /** TypedArray id  */
        -: 1337:                                                ecma_length_t array_length) /**< length of the typedarray */
        -: 1338:{
        -: 1339:  // TODO: assert validate typedarray_id
    #####: 1340:  ecma_object_t *proto_p = ecma_builtin_get (ecma_typedarray_helper_get_prototype_id (typedarray_id));
    #####: 1341:  uint8_t element_size_shift = ecma_typedarray_helper_get_shift_size (typedarray_id);
        -: 1342:
    #####: 1343:  ecma_value_t new_obj = ecma_typedarray_create_object_with_length (array_length,
        -: 1344:                                                                    NULL,
        -: 1345:                                                                    proto_p,
        -: 1346:                                                                    element_size_shift,
        -: 1347:                                                                    typedarray_id);
        -: 1348:
    #####: 1349:  return new_obj;
        -: 1350:} /* ecma_op_create_typedarray_with_type_and_length */
        -: 1351:
        -: 1352:/**
        -: 1353: * Method for getting the additional typedArray informations.
        -: 1354: */
        -: 1355:ecma_typedarray_info_t
    #####: 1356:ecma_typedarray_get_info (ecma_object_t *typedarray_p)
        -: 1357:{
        -: 1358:  ecma_typedarray_info_t info;
        -: 1359:
    #####: 1360:  info.id = ecma_get_typedarray_id (typedarray_p);
    #####: 1361:  info.length = ecma_typedarray_get_length (typedarray_p);
    #####: 1362:  info.shift = ecma_typedarray_get_element_size_shift (typedarray_p);
    #####: 1363:  info.element_size = (uint8_t) (1 << info.shift);
    #####: 1364:  info.offset = ecma_typedarray_get_offset (typedarray_p);
    #####: 1365:  info.array_buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1366:  info.buffer_p = ecma_arraybuffer_get_buffer (info.array_buffer_p) + info.offset;
        -: 1367:
    #####: 1368:  return info;
        -: 1369:} /* ecma_typedarray_get_info */
        -: 1370:
        -: 1371:/**
        -: 1372: * @}
        -: 1373: * @}
        -: 1374: */
        -: 1375:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
