        -:    0:Source:/home/workspace/jerry-core/api/jerry.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <stdio.h>
        -:   17:
        -:   18:#include "debugger.h"
        -:   19:#include "ecma-alloc.h"
        -:   20:#include "ecma-array-object.h"
        -:   21:#include "ecma-arraybuffer-object.h"
        -:   22:#include "ecma-builtin-helpers.h"
        -:   23:#include "ecma-builtins.h"
        -:   24:#include "ecma-comparison.h"
        -:   25:#include "ecma-container-object.h"
        -:   26:#include "ecma-dataview-object.h"
        -:   27:#include "ecma-exceptions.h"
        -:   28:#include "ecma-eval.h"
        -:   29:#include "ecma-function-object.h"
        -:   30:#include "ecma-gc.h"
        -:   31:#include "ecma-helpers.h"
        -:   32:#include "ecma-init-finalize.h"
        -:   33:#include "ecma-lex-env.h"
        -:   34:#include "lit-char-helpers.h"
        -:   35:#include "ecma-literal-storage.h"
        -:   36:#include "ecma-objects.h"
        -:   37:#include "ecma-objects-general.h"
        -:   38:#include "ecma-regexp-object.h"
        -:   39:#include "ecma-promise-object.h"
        -:   40:#include "ecma-proxy-object.h"
        -:   41:#include "ecma-symbol-object.h"
        -:   42:#include "ecma-typedarray-object.h"
        -:   43:#include "opcodes.h"
        -:   44:#include "jcontext.h"
        -:   45:#include "jerryscript.h"
        -:   46:#include "jerryscript-debugger-transport.h"
        -:   47:#include "jmem.h"
        -:   48:#include "js-parser.h"
        -:   49:#include "re-compiler.h"
        -:   50:
        -:   51:JERRY_STATIC_ASSERT (sizeof (jerry_value_t) == sizeof (ecma_value_t),
        -:   52:                     size_of_jerry_value_t_must_be_equal_to_size_of_ecma_value_t);
        -:   53:
        -:   54:JERRY_STATIC_ASSERT ((int) ECMA_ERROR_NONE == (int) JERRY_ERROR_NONE
        -:   55:                     && (int) ECMA_ERROR_COMMON == (int) JERRY_ERROR_COMMON
        -:   56:                     && (int) ECMA_ERROR_EVAL == (int) JERRY_ERROR_EVAL
        -:   57:                     && (int) ECMA_ERROR_RANGE == (int) JERRY_ERROR_RANGE
        -:   58:                     && (int) ECMA_ERROR_REFERENCE == (int) JERRY_ERROR_REFERENCE
        -:   59:                     && (int) ECMA_ERROR_SYNTAX == (int) JERRY_ERROR_SYNTAX
        -:   60:                     && (int) ECMA_ERROR_TYPE == (int) JERRY_ERROR_TYPE
        -:   61:                     && (int) ECMA_ERROR_URI == (int) JERRY_ERROR_URI,
        -:   62:                     ecma_standard_error_t_must_be_equal_to_jerry_error_t);
        -:   63:
        -:   64:JERRY_STATIC_ASSERT ((int) ECMA_INIT_EMPTY == (int) JERRY_INIT_EMPTY
        -:   65:                     && (int) ECMA_INIT_SHOW_OPCODES == (int) JERRY_INIT_SHOW_OPCODES
        -:   66:                     && (int) ECMA_INIT_SHOW_REGEXP_OPCODES == (int) JERRY_INIT_SHOW_REGEXP_OPCODES
        -:   67:                     && (int) ECMA_INIT_MEM_STATS == (int) JERRY_INIT_MEM_STATS,
        -:   68:                     ecma_init_flag_t_must_be_equal_to_jerry_init_flag_t);
        -:   69:
        -:   70:#if ENABLED (JERRY_BUILTIN_REGEXP)
        -:   71:JERRY_STATIC_ASSERT ((int) RE_FLAG_GLOBAL == (int) JERRY_REGEXP_FLAG_GLOBAL
        -:   72:                     && (int) RE_FLAG_MULTILINE == (int) JERRY_REGEXP_FLAG_MULTILINE
        -:   73:                     && (int) RE_FLAG_IGNORE_CASE == (int) JERRY_REGEXP_FLAG_IGNORE_CASE,
        -:   74:                     re_flags_t_must_be_equal_to_jerry_regexp_flags_t);
        -:   75:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
        -:   76:
        -:   77:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
        -:   78:/* The internal ECMA_PROMISE_STATE_* values are "one byte away" from the API values */
        -:   79:JERRY_STATIC_ASSERT ((int) ECMA_PROMISE_IS_PENDING == (int) JERRY_PROMISE_STATE_PENDING
        -:   80:                     && (int) ECMA_PROMISE_IS_FULFILLED == (int) JERRY_PROMISE_STATE_FULFILLED,
        -:   81:                     promise_internal_state_matches_external);
        -:   82:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -:   83:
        -:   84:/**
        -:   85: * Offset between internal and external arithmetic operator types
        -:   86: */
        -:   87:#define ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET (JERRY_BIN_OP_SUB - NUMBER_ARITHMETIC_SUBTRACTION)
        -:   88:
        -:   89:JERRY_STATIC_ASSERT (((NUMBER_ARITHMETIC_SUBTRACTION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_SUB)
        -:   90:                     && ((NUMBER_ARITHMETIC_MULTIPLICATION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_MUL)
        -:   91:                     && ((NUMBER_ARITHMETIC_DIVISION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_DIV)
        -:   92:                     && ((NUMBER_ARITHMETIC_REMAINDER + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_REM),
        -:   93:                     number_arithmetics_operation_type_matches_external);
        -:   94:
        -:   95:#if !ENABLED (JERRY_PARSER) && !ENABLED (JERRY_SNAPSHOT_EXEC)
        -:   96:#error "JERRY_SNAPSHOT_EXEC must be enabled if JERRY_PARSER is disabled!"
        -:   97:#endif /* !ENABLED (JERRY_PARSER) && !ENABLED (JERRY_SNAPSHOT_EXEC) */
        -:   98:
        -:   99:#if ENABLED (JERRY_ERROR_MESSAGES)
        -:  100:
        -:  101:/**
        -:  102: * Error message, if an argument is has an error flag
        -:  103: */
        -:  104:static const char * const error_value_msg_p = "argument cannot have an error flag";
        -:  105:
        -:  106:/**
        -:  107: * Error message, if types of arguments are incorrect
        -:  108: */
        -:  109:static const char * const wrong_args_msg_p = "wrong type of argument";
        -:  110:
        -:  111:#endif /* ENABLED (JERRY_ERROR_MESSAGES) */
        -:  112:
        -:  113:/** \addtogroup jerry Jerry engine interface
        -:  114: * @{
        -:  115: */
        -:  116:
        -:  117:/**
        -:  118: * Assert that it is correct to call API in current state.
        -:  119: *
        -:  120: * Note:
        -:  121: *         By convention, there are some states when API could not be invoked.
        -:  122: *
        -:  123: *         The API can be and only be invoked when the ECMA_STATUS_API_AVAILABLE
        -:  124: *         flag is set.
        -:  125: *
        -:  126: *         This procedure checks whether the API is available, and terminates
        -:  127: *         the engine if it is unavailable. Otherwise it is a no-op.
        -:  128: *
        -:  129: * Note:
        -:  130: *         The API could not be invoked in the following cases:
        -:  131: *           - before jerry_init and after jerry_cleanup
        -:  132: *           - between enter to and return from a native free callback
        -:  133: */
        -:  134:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  135:jerry_assert_api_available (void)
        -:  136:{
       41:  137:  JERRY_ASSERT (JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE);
        -:  138:} /* jerry_assert_api_available */
        -:  139:
        -:  140:/**
        -:  141: * Turn on API availability
        -:  142: */
        -:  143:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  144:jerry_make_api_available (void)
        -:  145:{
        1:  146:  JERRY_CONTEXT (status_flags) |= ECMA_STATUS_API_AVAILABLE;
        -:  147:} /* jerry_make_api_available */
        -:  148:
        -:  149:/**
        -:  150: * Turn off API availability
        -:  151: */
        -:  152:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  153:jerry_make_api_unavailable (void)
        -:  154:{
    #####:  155:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_API_AVAILABLE;
        -:  156:} /* jerry_make_api_unavailable */
        -:  157:
        -:  158:/**
        -:  159: * Create an API compatible return value.
        -:  160: *
        -:  161: * @return return value for Jerry API functions
        -:  162: */
        -:  163:static jerry_value_t
        4:  164:jerry_return (jerry_value_t value) /**< return value */
        -:  165:{
        4:  166:  if (ECMA_IS_VALUE_ERROR (value))
        -:  167:  {
    #####:  168:    value = ecma_create_error_reference_from_context ();
        -:  169:  }
        -:  170:
        4:  171:  return value;
        -:  172:} /* jerry_return */
        -:  173:
        -:  174:/**
        -:  175: * Throw an API compatible return value.
        -:  176: *
        -:  177: * @return return value for Jerry API functions
        -:  178: */
        -:  179:static inline jerry_value_t JERRY_ATTR_ALWAYS_INLINE
        -:  180:jerry_throw (jerry_value_t value) /**< return value */
        -:  181:{
    #####:  182:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (value));
    #####:  183:  return ecma_create_error_reference_from_context ();
        -:  184:} /* jerry_throw */
        -:  185:
        -:  186:/**
        -:  187: * Jerry engine initialization
        -:  188: */
        -:  189:void
        1:  190:jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  191:{
        -:  192:  /* This function cannot be called twice unless jerry_cleanup is called. */
        1:  193:  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE));
        -:  194:
        -:  195:  /* Zero out all non-external members. */
        1:  196:  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER), 0,
        -:  197:          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));
        -:  198:
        1:  199:  JERRY_CONTEXT (jerry_init_flags) = flags;
        -:  200:
        -:  201:  jerry_make_api_available ();
        -:  202:
        1:  203:  jmem_init ();
        1:  204:  ecma_init ();
        1:  205:} /* jerry_init */
        -:  206:
        -:  207:/**
        -:  208: * Terminate Jerry engine
        -:  209: */
        -:  210:void
    #####:  211:jerry_cleanup (void)
        -:  212:{
        -:  213:  jerry_assert_api_available ();
        -:  214:
        -:  215:#if ENABLED (JERRY_DEBUGGER)
        -:  216:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  217:  {
        -:  218:    jerry_debugger_send_type (JERRY_DEBUGGER_CLOSE_CONNECTION);
        -:  219:
        -:  220:    jerry_debugger_transport_close ();
        -:  221:  }
        -:  222:#endif /* ENABLED (JERRY_DEBUGGER) */
        -:  223:
    #####:  224:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p);
        -:  225:       this_p != NULL;
    #####:  226:       this_p = this_p->next_p)
        -:  227:  {
    #####:  228:    if (this_p->manager_p->deinit_cb)
        -:  229:    {
    #####:  230:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  231:      this_p->manager_p->deinit_cb (data);
        -:  232:    }
        -:  233:  }
        -:  234:
        -:  235:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
    #####:  236:  ecma_free_all_enqueued_jobs ();
        -:  237:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
    #####:  238:  ecma_finalize ();
        -:  239:  jerry_make_api_unavailable ();
        -:  240:
    #####:  241:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p), *next_p = NULL;
        -:  242:       this_p != NULL;
    #####:  243:       this_p = next_p)
        -:  244:  {
    #####:  245:    next_p = this_p->next_p;
    #####:  246:    if (this_p->manager_p->finalize_cb)
        -:  247:    {
    #####:  248:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  249:      this_p->manager_p->finalize_cb (data);
        -:  250:    }
    #####:  251:    jmem_heap_free_block (this_p, sizeof (jerry_context_data_header_t) + this_p->manager_p->bytes_needed);
        -:  252:  }
        -:  253:
    #####:  254:  jmem_finalize ();
    #####:  255:} /* jerry_cleanup */
        -:  256:
        -:  257:/**
        -:  258: * Retrieve a context data item, or create a new one.
        -:  259: *
        -:  260: * @param manager_p pointer to the manager whose context data item should be returned.
        -:  261: *
        -:  262: * @return a pointer to the user-provided context-specific data item for the given manager, creating such a pointer if
        -:  263: * none was found.
        -:  264: */
        -:  265:void *
    #####:  266:jerry_get_context_data (const jerry_context_data_manager_t *manager_p)
        -:  267:{
    #####:  268:  void *ret = NULL;
        -:  269:  jerry_context_data_header_t *item_p;
        -:  270:
    #####:  271:  for (item_p = JERRY_CONTEXT (context_data_p); item_p != NULL; item_p = item_p->next_p)
        -:  272:  {
    #####:  273:    if (item_p->manager_p == manager_p)
        -:  274:    {
    #####:  275:      return (manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p) : NULL;
        -:  276:    }
        -:  277:  }
        -:  278:
    #####:  279:  item_p = jmem_heap_alloc_block (sizeof (jerry_context_data_header_t) + manager_p->bytes_needed);
    #####:  280:  item_p->manager_p = manager_p;
    #####:  281:  item_p->next_p = JERRY_CONTEXT (context_data_p);
    #####:  282:  JERRY_CONTEXT (context_data_p) = item_p;
        -:  283:
    #####:  284:  if (manager_p->bytes_needed > 0)
        -:  285:  {
    #####:  286:    ret = JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p);
    #####:  287:    memset (ret, 0, manager_p->bytes_needed);
        -:  288:  }
        -:  289:
    #####:  290:  if (manager_p->init_cb)
        -:  291:  {
    #####:  292:    manager_p->init_cb (ret);
        -:  293:  }
        -:  294:
    #####:  295:  return ret;
        -:  296:} /* jerry_get_context_data */
        -:  297:
        -:  298:/**
        -:  299: * Register external magic string array
        -:  300: */
        -:  301:void
    #####:  302:jerry_register_magic_strings (const jerry_char_t * const *ex_str_items_p, /**< character arrays, representing
        -:  303:                                                                           *   external magic strings' contents */
        -:  304:                              uint32_t count, /**< number of the strings */
        -:  305:                              const jerry_length_t *str_lengths_p) /**< lengths of all strings */
        -:  306:{
        -:  307:  jerry_assert_api_available ();
        -:  308:
    #####:  309:  lit_magic_strings_ex_set ((const lit_utf8_byte_t * const *) ex_str_items_p,
        -:  310:                            count,
        -:  311:                            (const lit_utf8_size_t *) str_lengths_p);
    #####:  312:} /* jerry_register_magic_strings */
        -:  313:
        -:  314:/**
        -:  315: * Run garbage collection
        -:  316: */
        -:  317:void
    #####:  318:jerry_gc (jerry_gc_mode_t mode) /**< operational mode */
        -:  319:{
        -:  320:  jerry_assert_api_available ();
        -:  321:
    #####:  322:  if (mode == JERRY_GC_PRESSURE_LOW)
        -:  323:  {
        -:  324:    /* Call GC directly, because 'ecma_free_unused_memory' might decide it's not yet worth it. */
    #####:  325:    ecma_gc_run ();
    #####:  326:    return;
        -:  327:  }
        -:  328:
    #####:  329:  ecma_free_unused_memory (JMEM_PRESSURE_HIGH);
        -:  330:} /* jerry_gc */
        -:  331:
        -:  332:/**
        -:  333: * Get heap memory stats.
        -:  334: *
        -:  335: * @return true - get the heap stats successful
        -:  336: *         false - otherwise. Usually it is because the MEM_STATS feature is not enabled.
        -:  337: */
        -:  338:bool
    #####:  339:jerry_get_memory_stats (jerry_heap_stats_t *out_stats_p) /**< [out] heap memory stats */
        -:  340:{
        -:  341:#if ENABLED (JERRY_MEM_STATS)
    #####:  342:  if (out_stats_p == NULL)
        -:  343:  {
    #####:  344:    return false;
        -:  345:  }
        -:  346:
        -:  347:  jmem_heap_stats_t jmem_heap_stats;
    #####:  348:  memset (&jmem_heap_stats, 0, sizeof (jmem_heap_stats));
    #####:  349:  jmem_heap_get_stats (&jmem_heap_stats);
        -:  350:
    #####:  351:  *out_stats_p = (jerry_heap_stats_t)
        -:  352:  {
        -:  353:    .version = 1,
    #####:  354:    .size = jmem_heap_stats.size,
    #####:  355:    .allocated_bytes = jmem_heap_stats.allocated_bytes,
    #####:  356:    .peak_allocated_bytes = jmem_heap_stats.peak_allocated_bytes
        -:  357:  };
        -:  358:
    #####:  359:  return true;
        -:  360:#else /* !ENABLED (JERRY_MEM_STATS) */
        -:  361:  JERRY_UNUSED (out_stats_p);
    #####:  362:  return false;
        -:  363:#endif /* ENABLED (JERRY_MEM_STATS) */
        -:  364:} /* jerry_get_memory_stats */
        -:  365:
        -:  366:/**
        -:  367: * Simple Jerry runner
        -:  368: *
        -:  369: * @return true  - if run was successful
        -:  370: *         false - otherwise
        -:  371: */
        -:  372:bool
    #####:  373:jerry_run_simple (const jerry_char_t *script_source_p, /**< script source */
        -:  374:                  size_t script_source_size, /**< script source size */
        -:  375:                  jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  376:{
    #####:  377:  bool result = false;
        -:  378:
    #####:  379:  jerry_init (flags);
        -:  380:
    #####:  381:  jerry_value_t parse_ret_val = jerry_parse (NULL, 0, script_source_p, script_source_size, JERRY_PARSE_NO_OPTS);
        -:  382:
    #####:  383:  if (!ecma_is_value_error_reference (parse_ret_val))
        -:  384:  {
    #####:  385:    jerry_value_t run_ret_val = jerry_run (parse_ret_val);
        -:  386:
    #####:  387:    if (!ecma_is_value_error_reference (run_ret_val))
        -:  388:    {
    #####:  389:      result = true;
        -:  390:    }
        -:  391:
    #####:  392:    jerry_release_value (run_ret_val);
        -:  393:  }
        -:  394:
    #####:  395:  jerry_release_value (parse_ret_val);
    #####:  396:  jerry_cleanup ();
        -:  397:
    #####:  398:  return result;
        -:  399:} /* jerry_run_simple */
        -:  400:
        -:  401:/**
        -:  402: * Parse script and construct an EcmaScript function. The lexical
        -:  403: * environment is set to the global lexical environment.
        -:  404: *
        -:  405: * @return function object value - if script was parsed successfully,
        -:  406: *         thrown error - otherwise
        -:  407: */
        -:  408:jerry_value_t
        1:  409:jerry_parse (const jerry_char_t *resource_name_p, /**< resource name (usually a file name) */
        -:  410:             size_t resource_name_length, /**< length of resource name */
        -:  411:             const jerry_char_t *source_p, /**< script source */
        -:  412:             size_t source_size, /**< script source size */
        -:  413:             uint32_t parse_opts) /**< jerry_parse_opts_t option bits */
        -:  414:{
        -:  415:#if ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER)
        -:  416:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  417:      && resource_name_length > 0)
        -:  418:  {
        -:  419:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,
        -:  420:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  421:                                resource_name_p,
        -:  422:                                resource_name_length);
        -:  423:  }
        -:  424:#else /* !(ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER)) */
        -:  425:  JERRY_UNUSED (resource_name_p);
        -:  426:  JERRY_UNUSED (resource_name_length);
        -:  427:#endif /* ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER) */
        -:  428:
        -:  429:#if ENABLED (JERRY_PARSER)
        -:  430:  jerry_assert_api_available ();
        -:  431:
        -:  432:#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)
        1:  433:  if (resource_name_length == 0)
        -:  434:  {
    #####:  435:    JERRY_CONTEXT (resource_name) = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -:  436:  }
        -:  437:  else
        -:  438:  {
        1:  439:    JERRY_CONTEXT (resource_name) = ecma_find_or_create_literal_string (resource_name_p,
        -:  440:                                                                        (lit_utf8_size_t) resource_name_length);
        -:  441:  }
        -:  442:#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  443:
        1:  444:  ecma_compiled_code_t *bytecode_data_p;
        -:  445:  ecma_value_t parse_status;
        -:  446:
        1:  447:  parse_status = parser_parse_script (NULL,
        -:  448:                                      0,
        -:  449:                                      source_p,
        -:  450:                                      source_size,
        -:  451:                                      parse_opts,
        -:  452:                                      &bytecode_data_p);
        -:  453:
        1:  454:  if (ECMA_IS_VALUE_ERROR (parse_status))
        -:  455:  {
    #####:  456:    return ecma_create_error_reference_from_context ();
        -:  457:  }
        -:  458:
        1:  459:  ecma_free_value (parse_status);
        -:  460:
        1:  461:  ecma_object_t *lex_env_p = ecma_get_global_environment ();
        1:  462:  ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);
        1:  463:  ecma_bytecode_deref (bytecode_data_p);
        -:  464:
        1:  465:  return ecma_make_object_value (func_obj_p);
        -:  466:#else /* !ENABLED (JERRY_PARSER) */
        -:  467:  JERRY_UNUSED (source_p);
        -:  468:  JERRY_UNUSED (source_size);
        -:  469:  JERRY_UNUSED (parse_opts);
        -:  470:
        -:  471:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("The parser has been disabled.")));
        -:  472:#endif /* ENABLED (JERRY_PARSER) */
        -:  473:} /* jerry_parse */
        -:  474:
        -:  475:/**
        -:  476: * Parse function and construct an EcmaScript function. The lexical
        -:  477: * environment is set to the global lexical environment.
        -:  478: *
        -:  479: * @return function object value - if script was parsed successfully,
        -:  480: *         thrown error - otherwise
        -:  481: */
        -:  482:jerry_value_t
    #####:  483:jerry_parse_function (const jerry_char_t *resource_name_p, /**< resource name (usually a file name) */
        -:  484:                      size_t resource_name_length, /**< length of resource name */
        -:  485:                      const jerry_char_t *arg_list_p, /**< script source */
        -:  486:                      size_t arg_list_size, /**< script source size */
        -:  487:                      const jerry_char_t *source_p, /**< script source */
        -:  488:                      size_t source_size, /**< script source size */
        -:  489:                      uint32_t parse_opts) /**< jerry_parse_opts_t option bits */
        -:  490:{
        -:  491:#if ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER)
        -:  492:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  493:  {
        -:  494:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,
        -:  495:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  496:                                resource_name_p,
        -:  497:                                resource_name_length);
        -:  498:  }
        -:  499:#else /* !(ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER)) */
        -:  500:  JERRY_UNUSED (resource_name_p);
        -:  501:  JERRY_UNUSED (resource_name_length);
        -:  502:#endif /* ENABLED (JERRY_DEBUGGER) && ENABLED (JERRY_PARSER) */
        -:  503:
        -:  504:#if ENABLED (JERRY_PARSER)
        -:  505:  jerry_assert_api_available ();
        -:  506:
    #####:  507:  ecma_compiled_code_t *bytecode_data_p;
        -:  508:  ecma_value_t parse_status;
        -:  509:
        -:  510:#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####:  511:  if (resource_name_length == 0)
        -:  512:  {
    #####:  513:    JERRY_CONTEXT (resource_name) = ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -:  514:  }
        -:  515:  else
        -:  516:  {
    #####:  517:    JERRY_CONTEXT (resource_name) = ecma_find_or_create_literal_string (resource_name_p,
        -:  518:                                                                        (lit_utf8_size_t) resource_name_length);
        -:  519:  }
        -:  520:#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ERROR_MESSAGES) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -:  521:
    #####:  522:  if (arg_list_p == NULL)
        -:  523:  {
        -:  524:    /* Must not be a NULL value. */
    #####:  525:    arg_list_p = (const jerry_char_t *) "";
        -:  526:  }
        -:  527:
    #####:  528:  parse_status = parser_parse_script (arg_list_p,
        -:  529:                                      arg_list_size,
        -:  530:                                      source_p,
        -:  531:                                      source_size,
        -:  532:                                      parse_opts,
        -:  533:                                      &bytecode_data_p);
        -:  534:
    #####:  535:  if (ECMA_IS_VALUE_ERROR (parse_status))
        -:  536:  {
    #####:  537:    return ecma_create_error_reference_from_context ();
        -:  538:  }
        -:  539:
    #####:  540:  ecma_free_value (parse_status);
        -:  541:
    #####:  542:  ecma_object_t *lex_env_p = ecma_get_global_environment ();
    #####:  543:  ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);
    #####:  544:  ecma_bytecode_deref (bytecode_data_p);
        -:  545:
    #####:  546:  return ecma_make_object_value (func_obj_p);
        -:  547:#else /* !ENABLED (JERRY_PARSER) */
        -:  548:  JERRY_UNUSED (arg_list_p);
        -:  549:  JERRY_UNUSED (arg_list_size);
        -:  550:  JERRY_UNUSED (source_p);
        -:  551:  JERRY_UNUSED (source_size);
        -:  552:  JERRY_UNUSED (parse_opts);
        -:  553:
        -:  554:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("The parser has been disabled.")));
        -:  555:#endif /* ENABLED (JERRY_PARSER) */
        -:  556:} /* jerry_parse_function */
        -:  557:
        -:  558:/**
        -:  559: * Run an EcmaScript function created by jerry_parse.
        -:  560: *
        -:  561: * Note:
        -:  562: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  563: *
        -:  564: * @return result of bytecode - if run was successful
        -:  565: *         thrown error - otherwise
        -:  566: */
        -:  567:jerry_value_t
        1:  568:jerry_run (const jerry_value_t func_val) /**< function to run */
        -:  569:{
        -:  570:  jerry_assert_api_available ();
        -:  571:
        1:  572:  if (!ecma_is_value_object (func_val))
        -:  573:  {
    #####:  574:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -:  575:  }
        -:  576:
        1:  577:  ecma_object_t *func_obj_p = ecma_get_object_from_value (func_val);
        -:  578:
        1:  579:  if (ecma_get_object_type (func_obj_p) != ECMA_OBJECT_TYPE_FUNCTION
        1:  580:      || ecma_get_object_is_builtin (func_obj_p))
        -:  581:  {
    #####:  582:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -:  583:  }
        -:  584:
        1:  585:  ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_obj_p;
        -:  586:
        1:  587:  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -:  588:                                                                       ext_func_p->u.function.scope_cp);
        -:  589:
        1:  590:  if (scope_p != ecma_get_global_environment ())
        -:  591:  {
    #####:  592:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -:  593:  }
        -:  594:
        1:  595:  return jerry_return (vm_run_global (ecma_op_function_get_compiled_code (ext_func_p)));
        -:  596:} /* jerry_run */
        -:  597:
        -:  598:/**
        -:  599: * Perform eval
        -:  600: *
        -:  601: * Note:
        -:  602: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  603: *
        -:  604: * @return result of eval, may be error value.
        -:  605: */
        -:  606:jerry_value_t
    #####:  607:jerry_eval (const jerry_char_t *source_p, /**< source code */
        -:  608:            size_t source_size, /**< length of source code */
        -:  609:            uint32_t parse_opts) /**< jerry_parse_opts_t option bits */
        -:  610:{
        -:  611:  jerry_assert_api_available ();
        -:  612:
    #####:  613:  return jerry_return (ecma_op_eval_chars_buffer ((const lit_utf8_byte_t *) source_p,
        -:  614:                                                  source_size,
        -:  615:                                                  parse_opts));
        -:  616:} /* jerry_eval */
        -:  617:
        -:  618:/**
        -:  619: * Run enqueued Promise jobs until the first thrown error or until all get executed.
        -:  620: *
        -:  621: * Note:
        -:  622: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  623: *
        -:  624: * @return result of last executed job, may be error value.
        -:  625: */
        -:  626:jerry_value_t
    #####:  627:jerry_run_all_enqueued_jobs (void)
        -:  628:{
        -:  629:  jerry_assert_api_available ();
        -:  630:
        -:  631:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
    #####:  632:  return ecma_process_all_enqueued_jobs ();
        -:  633:#else /* !ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
    #####:  634:  return ECMA_VALUE_UNDEFINED;
        -:  635:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -:  636:} /* jerry_run_all_enqueued_jobs */
        -:  637:
        -:  638:/**
        -:  639: * Get global object
        -:  640: *
        -:  641: * Note:
        -:  642: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  643: *
        -:  644: * @return api value of global object
        -:  645: */
        -:  646:jerry_value_t
        4:  647:jerry_get_global_object (void)
        -:  648:{
        -:  649:  jerry_assert_api_available ();
        4:  650:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        4:  651:  ecma_ref_object (global_obj_p);
        4:  652:  return ecma_make_object_value (global_obj_p);
        -:  653:} /* jerry_get_global_object */
        -:  654:
        -:  655:/**
        -:  656: * Check if the specified value is an abort value.
        -:  657: *
        -:  658: * @return true  - if both the error and abort values are set,
        -:  659: *         false - otherwise
        -:  660: */
        -:  661:bool
    #####:  662:jerry_value_is_abort (const jerry_value_t value) /**< api value */
        -:  663:{
        -:  664:  jerry_assert_api_available ();
        -:  665:
    #####:  666:  if (!ecma_is_value_error_reference (value))
        -:  667:  {
    #####:  668:    return false;
        -:  669:  }
        -:  670:
    #####:  671:  ecma_error_reference_t *error_ref_p = ecma_get_error_reference_from_value (value);
        -:  672:
    #####:  673:  return (error_ref_p->refs_and_flags & ECMA_ERROR_REF_ABORT) != 0;
        -:  674:} /* jerry_value_is_abort */
        -:  675:
        -:  676:/**
        -:  677: * Check if the specified value is an array object value.
        -:  678: *
        -:  679: * @return true  - if the specified value is an array object,
        -:  680: *         false - otherwise
        -:  681: */
        -:  682:bool
    #####:  683:jerry_value_is_array (const jerry_value_t value) /**< jerry api value */
        -:  684:{
        -:  685:  jerry_assert_api_available ();
        -:  686:
    #####:  687:  return (ecma_is_value_object (value)
    #####:  688:          && ecma_get_object_type (ecma_get_object_from_value (value)) == ECMA_OBJECT_TYPE_ARRAY);
        -:  689:} /* jerry_value_is_array */
        -:  690:
        -:  691:/**
        -:  692: * Check if the specified value is boolean.
        -:  693: *
        -:  694: * @return true  - if the specified value is boolean,
        -:  695: *         false - otherwise
        -:  696: */
        -:  697:bool
    #####:  698:jerry_value_is_boolean (const jerry_value_t value) /**< api value */
        -:  699:{
        -:  700:  jerry_assert_api_available ();
        -:  701:
    #####:  702:  return ecma_is_value_boolean (value);
        -:  703:} /* jerry_value_is_boolean */
        -:  704:
        -:  705:/**
        -:  706: * Check if the specified value is a constructor function object value.
        -:  707: *
        -:  708: * @return true - if the specified value is a function value that implements [[Construct]],
        -:  709: *         false - otherwise
        -:  710: */
        -:  711:bool
    #####:  712:jerry_value_is_constructor (const jerry_value_t value) /**< jerry api value */
        -:  713:{
        -:  714:  jerry_assert_api_available ();
        -:  715:
    #####:  716:  return ecma_is_constructor (value);
        -:  717:} /* jerry_value_is_constructor */
        -:  718:
        -:  719:/**
        -:  720: * Check if the specified value is an error or abort value.
        -:  721: *
        -:  722: * @return true  - if the specified value is an error value,
        -:  723: *         false - otherwise
        -:  724: */
        -:  725:bool
        6:  726:jerry_value_is_error (const jerry_value_t value) /**< api value */
        -:  727:{
        -:  728:  jerry_assert_api_available ();
        -:  729:
        6:  730:  return ecma_is_value_error_reference (value);
        -:  731:} /* jerry_value_is_error */
        -:  732:
        -:  733:/**
        -:  734: * Check if the specified value is a function object value.
        -:  735: *
        -:  736: * @return true - if the specified value is callable,
        -:  737: *         false - otherwise
        -:  738: */
        -:  739:bool
    #####:  740:jerry_value_is_function (const jerry_value_t value) /**< api value */
        -:  741:{
        -:  742:  jerry_assert_api_available ();
        -:  743:
    #####:  744:  return ecma_op_is_callable (value);
        -:  745:} /* jerry_value_is_function */
        -:  746:
        -:  747:/**
        -:  748: * Check if the specified value is number.
        -:  749: *
        -:  750: * @return true  - if the specified value is number,
        -:  751: *         false - otherwise
        -:  752: */
        -:  753:bool
    #####:  754:jerry_value_is_number (const jerry_value_t value) /**< api value */
        -:  755:{
        -:  756:  jerry_assert_api_available ();
        -:  757:
    #####:  758:  return ecma_is_value_number (value);
        -:  759:} /* jerry_value_is_number */
        -:  760:
        -:  761:/**
        -:  762: * Check if the specified value is null.
        -:  763: *
        -:  764: * @return true  - if the specified value is null,
        -:  765: *         false - otherwise
        -:  766: */
        -:  767:bool
    #####:  768:jerry_value_is_null (const jerry_value_t value) /**< api value */
        -:  769:{
        -:  770:  jerry_assert_api_available ();
        -:  771:
    #####:  772:  return ecma_is_value_null (value);
        -:  773:} /* jerry_value_is_null */
        -:  774:
        -:  775:/**
        -:  776: * Check if the specified value is object.
        -:  777: *
        -:  778: * @return true  - if the specified value is object,
        -:  779: *         false - otherwise
        -:  780: */
        -:  781:bool
    #####:  782:jerry_value_is_object (const jerry_value_t value) /**< api value */
        -:  783:{
        -:  784:  jerry_assert_api_available ();
        -:  785:
    #####:  786:  return ecma_is_value_object (value);
        -:  787:} /* jerry_value_is_object */
        -:  788:
        -:  789:/**
        -:  790: * Check if the specified value is promise.
        -:  791: *
        -:  792: * @return true  - if the specified value is promise,
        -:  793: *         false - otherwise
        -:  794: */
        -:  795:bool
    #####:  796:jerry_value_is_promise (const jerry_value_t value) /**< api value */
        -:  797:{
        -:  798:  jerry_assert_api_available ();
        -:  799:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
    #####:  800:  return (ecma_is_value_object (value)
    #####:  801:          && ecma_is_promise (ecma_get_object_from_value (value)));
        -:  802:#else /* !ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -:  803:  JERRY_UNUSED (value);
    #####:  804:  return false;
        -:  805:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -:  806:} /* jerry_value_is_promise */
        -:  807:
        -:  808:/**
        -:  809: * Check if the specified value is a proxy object.
        -:  810: *
        -:  811: * @return true  - if the specified value is a proxy object,
        -:  812: *         false - otherwise
        -:  813: */
        -:  814:bool
    #####:  815:jerry_value_is_proxy (const jerry_value_t value) /**< api value */
        -:  816:{
        -:  817:  jerry_assert_api_available ();
        -:  818:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####:  819:  return (ecma_is_value_object (value)
    #####:  820:          && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (value)));
        -:  821:#else /* !ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -:  822:  JERRY_UNUSED (value);
    #####:  823:  return false;
        -:  824:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -:  825:} /* jerry_value_is_proxy */
        -:  826:
        -:  827:/**
        -:  828: * Check if the specified value is string.
        -:  829: *
        -:  830: * @return true  - if the specified value is string,
        -:  831: *         false - otherwise
        -:  832: */
        -:  833:bool
    #####:  834:jerry_value_is_string (const jerry_value_t value) /**< api value */
        -:  835:{
        -:  836:  jerry_assert_api_available ();
        -:  837:
    #####:  838:  return ecma_is_value_string (value);
        -:  839:} /* jerry_value_is_string */
        -:  840:
        -:  841:/**
        -:  842: * Check if the specified value is symbol.
        -:  843: *
        -:  844: * @return true  - if the specified value is symbol,
        -:  845: *         false - otherwise
        -:  846: */
        -:  847:bool
    #####:  848:jerry_value_is_symbol (const jerry_value_t value) /**< api value */
        -:  849:{
        -:  850:  jerry_assert_api_available ();
        -:  851:
        -:  852:#if ENABLED (JERRY_ES2015)
    #####:  853:  return ecma_is_value_symbol (value);
        -:  854:#else /* !ENABLED (JERRY_ES2015) */
        -:  855:  JERRY_UNUSED (value);
    #####:  856:  return false;
        -:  857:#endif /* ENABLED (JERRY_ES2015) */
        -:  858:} /* jerry_value_is_symbol */
        -:  859:
        -:  860:/**
        -:  861: * Check if the specified value is undefined.
        -:  862: *
        -:  863: * @return true  - if the specified value is undefined,
        -:  864: *         false - otherwise
        -:  865: */
        -:  866:bool
    #####:  867:jerry_value_is_undefined (const jerry_value_t value) /**< api value */
        -:  868:{
        -:  869:  jerry_assert_api_available ();
        -:  870:
    #####:  871:  return ecma_is_value_undefined (value);
        -:  872:} /* jerry_value_is_undefined */
        -:  873:
        -:  874:/**
        -:  875: * Perform the base type of the JavaScript value.
        -:  876: *
        -:  877: * @return jerry_type_t value
        -:  878: */
        -:  879:jerry_type_t
    #####:  880:jerry_value_get_type (const jerry_value_t value) /**< input value to check */
        -:  881:{
        -:  882:  jerry_assert_api_available ();
        -:  883:
    #####:  884:  if (ecma_is_value_error_reference (value))
        -:  885:  {
    #####:  886:    return JERRY_TYPE_ERROR;
        -:  887:  }
        -:  888:
    #####:  889:  lit_magic_string_id_t lit_id = ecma_get_typeof_lit_id (value);
        -:  890:
    #####:  891:  JERRY_ASSERT (lit_id != LIT_MAGIC_STRING__EMPTY);
        -:  892:
    #####:  893:  switch (lit_id)
        -:  894:  {
    #####:  895:    case LIT_MAGIC_STRING_UNDEFINED:
        -:  896:    {
    #####:  897:      return JERRY_TYPE_UNDEFINED;
        -:  898:    }
    #####:  899:    case LIT_MAGIC_STRING_BOOLEAN:
        -:  900:    {
    #####:  901:      return JERRY_TYPE_BOOLEAN;
        -:  902:    }
    #####:  903:    case LIT_MAGIC_STRING_NUMBER:
        -:  904:    {
    #####:  905:      return JERRY_TYPE_NUMBER;
        -:  906:    }
    #####:  907:    case LIT_MAGIC_STRING_STRING:
        -:  908:    {
    #####:  909:      return JERRY_TYPE_STRING;
        -:  910:    }
        -:  911:#if ENABLED (JERRY_ES2015)
    #####:  912:    case LIT_MAGIC_STRING_SYMBOL:
        -:  913:    {
    #####:  914:      return JERRY_TYPE_SYMBOL;
        -:  915:    }
        -:  916:#endif /* ENABLED (JERRY_ES2015) */
    #####:  917:    case LIT_MAGIC_STRING_FUNCTION:
        -:  918:    {
    #####:  919:      return JERRY_TYPE_FUNCTION;
        -:  920:    }
    #####:  921:    default:
        -:  922:    {
    #####:  923:      JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_OBJECT);
        -:  924:
        -:  925:      /* Based on the ECMA 262 5.1 standard the 'null' value is an object.
        -:  926:       * Thus we'll do an extra check for 'null' here.
        -:  927:       */
    #####:  928:      return ecma_is_value_null (value) ? JERRY_TYPE_NULL : JERRY_TYPE_OBJECT;
        -:  929:    }
        -:  930:  }
        -:  931:} /* jerry_value_get_type */
        -:  932:
        -:  933:/**
        -:  934: * Check if the specified feature is enabled.
        -:  935: *
        -:  936: * @return true  - if the specified feature is enabled,
        -:  937: *         false - otherwise
        -:  938: */
        -:  939:bool
        1:  940:jerry_is_feature_enabled (const jerry_feature_t feature) /**< feature to check */
        -:  941:{
        1:  942:  JERRY_ASSERT (feature < JERRY_FEATURE__COUNT);
        -:  943:
        -:  944:  return (false
        -:  945:#if ENABLED (JERRY_CPOINTER_32_BIT)
        -:  946:          || feature == JERRY_FEATURE_CPOINTER_32_BIT
        -:  947:#endif /* ENABLED (JERRY_CPOINTER_32_BIT) */
        -:  948:#if ENABLED (JERRY_ERROR_MESSAGES)
        -:  949:          || feature == JERRY_FEATURE_ERROR_MESSAGES
        -:  950:#endif /* ENABLED (JERRY_ERROR_MESSAGES) */
        -:  951:#if ENABLED (JERRY_PARSER)
        1:  952:          || feature == JERRY_FEATURE_JS_PARSER
        -:  953:#endif /* ENABLED (JERRY_PARSER) */
        -:  954:#if ENABLED (JERRY_MEM_STATS)
    #####:  955:          || feature == JERRY_FEATURE_MEM_STATS
        -:  956:#endif /* ENABLED (JERRY_MEM_STATS) */
        -:  957:#if ENABLED (JERRY_PARSER_DUMP_BYTE_CODE)
        -:  958:          || feature == JERRY_FEATURE_PARSER_DUMP
        -:  959:#endif /* ENABLED (JERRY_PARSER_DUMP_BYTE_CODE) */
        -:  960:#if ENABLED (JERRY_REGEXP_DUMP_BYTE_CODE)
        -:  961:          || feature == JERRY_FEATURE_REGEXP_DUMP
        -:  962:#endif /* ENABLED (JERRY_REGEXP_DUMP_BYTE_CODE) */
        -:  963:#if ENABLED (JERRY_SNAPSHOT_SAVE)
    #####:  964:          || feature == JERRY_FEATURE_SNAPSHOT_SAVE
        -:  965:#endif /* ENABLED (JERRY_SNAPSHOT_SAVE) */
        -:  966:#if ENABLED (JERRY_SNAPSHOT_EXEC)
    #####:  967:          || feature == JERRY_FEATURE_SNAPSHOT_EXEC
        -:  968:#endif /* ENABLED (JERRY_SNAPSHOT_EXEC) */
        -:  969:#if ENABLED (JERRY_DEBUGGER)
        -:  970:          || feature == JERRY_FEATURE_DEBUGGER
        -:  971:#endif /* ENABLED (JERRY_DEBUGGER) */
        -:  972:#if ENABLED (JERRY_VM_EXEC_STOP)
    #####:  973:          || feature == JERRY_FEATURE_VM_EXEC_STOP
        -:  974:#endif /* ENABLED (JERRY_VM_EXEC_STOP) */
        -:  975:#if ENABLED (JERRY_BUILTIN_JSON)
        1:  976:          || feature == JERRY_FEATURE_JSON
        -:  977:#endif /* ENABLED (JERRY_BUILTIN_JSON) */
        -:  978:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
        1:  979:          || feature == JERRY_FEATURE_PROMISE
        -:  980:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -:  981:#if ENABLED (JERRY_ES2015)
        1:  982:          || feature == JERRY_FEATURE_SYMBOL
        -:  983:#endif /* ENABLED (JERRY_ES2015) */
        -:  984:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        1:  985:          || feature == JERRY_FEATURE_TYPEDARRAY
        -:  986:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -:  987:#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)
        1:  988:          || feature == JERRY_FEATURE_DATAVIEW
        -:  989:#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */
        -:  990:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
        1:  991:          || feature == JERRY_FEATURE_PROXY
        -:  992:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -:  993:#if ENABLED (JERRY_BUILTIN_DATE)
        1:  994:          || feature == JERRY_FEATURE_DATE
        -:  995:#endif /* ENABLED (JERRY_BUILTIN_DATE) */
        -:  996:#if ENABLED (JERRY_BUILTIN_REGEXP)
        1:  997:          || feature == JERRY_FEATURE_REGEXP
        -:  998:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
        -:  999:#if ENABLED (JERRY_LINE_INFO)
    #####: 1000:          || feature == JERRY_FEATURE_LINE_INFO
        -: 1001:#endif /* ENABLED (JERRY_LINE_INFO) */
        -: 1002:#if ENABLED (JERRY_LOGGING)
        1: 1003:          || feature == JERRY_FEATURE_LOGGING
        -: 1004:#endif /* ENABLED (JERRY_LOGGING) */
        -: 1005:#if ENABLED (JERRY_ES2015_BUILTIN_MAP)
        1: 1006:          || feature == JERRY_FEATURE_MAP
        -: 1007:#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */
        -: 1008:#if ENABLED (JERRY_ES2015_BUILTIN_SET)
        1: 1009:          || feature == JERRY_FEATURE_SET
        -: 1010:#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */
        -: 1011:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)
        1: 1012:          || feature == JERRY_FEATURE_WEAKMAP
        -: 1013:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */
        -: 1014:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
        2: 1015:          || feature == JERRY_FEATURE_WEAKSET
        -: 1016:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
        -: 1017:          );
        -: 1018:} /* jerry_is_feature_enabled */
        -: 1019:
        -: 1020:/**
        -: 1021: * Perform binary operation on the given operands (==, ===, <, >, etc.).
        -: 1022: *
        -: 1023: * @return error - if argument has an error flag or operation is unsuccessful or unsupported
        -: 1024: *         true/false - the result of the binary operation on the given operands otherwise
        -: 1025: */
        -: 1026:jerry_value_t
    #####: 1027:jerry_binary_operation (jerry_binary_operation_t op, /**< operation */
        -: 1028:                        const jerry_value_t lhs, /**< first operand */
        -: 1029:                        const jerry_value_t rhs) /**< second operand */
        -: 1030:{
        -: 1031:  jerry_assert_api_available ();
        -: 1032:
    #####: 1033:  if (ecma_is_value_error_reference (lhs) || ecma_is_value_error_reference (rhs))
        -: 1034:  {
    #####: 1035:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 1036:  }
        -: 1037:
    #####: 1038:  switch (op)
        -: 1039:  {
    #####: 1040:    case JERRY_BIN_OP_EQUAL:
        -: 1041:    {
    #####: 1042:      return jerry_return (ecma_op_abstract_equality_compare (lhs, rhs));
        -: 1043:    }
    #####: 1044:    case JERRY_BIN_OP_STRICT_EQUAL:
        -: 1045:    {
    #####: 1046:      return ecma_make_boolean_value (ecma_op_strict_equality_compare (lhs, rhs));
        -: 1047:    }
    #####: 1048:    case JERRY_BIN_OP_LESS:
        -: 1049:    {
    #####: 1050:      return jerry_return (opfunc_relation (lhs, rhs, true, false));
        -: 1051:    }
    #####: 1052:    case JERRY_BIN_OP_LESS_EQUAL:
        -: 1053:    {
    #####: 1054:      return jerry_return (opfunc_relation (lhs, rhs, false, true));
        -: 1055:    }
    #####: 1056:    case JERRY_BIN_OP_GREATER:
        -: 1057:    {
    #####: 1058:      return jerry_return (opfunc_relation (lhs, rhs, false, false));
        -: 1059:    }
    #####: 1060:    case JERRY_BIN_OP_GREATER_EQUAL:
        -: 1061:    {
    #####: 1062:      return jerry_return (opfunc_relation (lhs, rhs, true, true));
        -: 1063:    }
    #####: 1064:    case JERRY_BIN_OP_INSTANCEOF:
        -: 1065:    {
    #####: 1066:      if (!ecma_is_value_object (lhs)
    #####: 1067:          || !ecma_op_is_callable (rhs))
        -: 1068:      {
    #####: 1069:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 1070:      }
        -: 1071:
    #####: 1072:      ecma_object_t *proto_obj_p = ecma_get_object_from_value (rhs);
    #####: 1073:      return jerry_return (ecma_op_object_has_instance (proto_obj_p, lhs));
        -: 1074:    }
    #####: 1075:    case JERRY_BIN_OP_ADD:
        -: 1076:    {
    #####: 1077:      return jerry_return (opfunc_addition (lhs, rhs));
        -: 1078:    }
    #####: 1079:    case JERRY_BIN_OP_SUB:
        -: 1080:    case JERRY_BIN_OP_MUL:
        -: 1081:    case JERRY_BIN_OP_DIV:
        -: 1082:    case JERRY_BIN_OP_REM:
        -: 1083:    {
    #####: 1084:      return jerry_return (do_number_arithmetic (op - ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET, lhs, rhs));
        -: 1085:    }
    #####: 1086:    default:
        -: 1087:    {
    #####: 1088:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Unsupported binary operation")));
        -: 1089:    }
        -: 1090:  }
        -: 1091:} /* jerry_binary_operation */
        -: 1092:
        -: 1093:/**
        -: 1094: * Create abort from an api value.
        -: 1095: *
        -: 1096: * Create abort value from an api value. If the second argument is true
        -: 1097: * it will release the input api value.
        -: 1098: *
        -: 1099: * @return api abort value
        -: 1100: */
        -: 1101:jerry_value_t
    #####: 1102:jerry_create_abort_from_value (jerry_value_t value, /**< api value */
        -: 1103:                               bool release) /**< release api value */
        -: 1104:{
        -: 1105:  jerry_assert_api_available ();
        -: 1106:
    #####: 1107:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1108:  {
        -: 1109:    /* This is a rare case so it is optimized for
        -: 1110:     * binary size rather than performance. */
    #####: 1111:    if (jerry_value_is_abort (value))
        -: 1112:    {
    #####: 1113:      return release ? value : jerry_acquire_value (value);
        -: 1114:    }
        -: 1115:
    #####: 1116:    value = jerry_get_value_from_error (value, release);
    #####: 1117:    release = true;
        -: 1118:  }
        -: 1119:
    #####: 1120:  if (!release)
        -: 1121:  {
    #####: 1122:    value = ecma_copy_value (value);
        -: 1123:  }
        -: 1124:
    #####: 1125:  return ecma_create_error_reference (value, false);
        -: 1126:} /* jerry_create_abort_from_value */
        -: 1127:
        -: 1128:/**
        -: 1129: * Create error from an api value.
        -: 1130: *
        -: 1131: * Create error value from an api value. If the second argument is true
        -: 1132: * it will release the input api value.
        -: 1133: *
        -: 1134: * @return api error value
        -: 1135: */
        -: 1136:jerry_value_t
    #####: 1137:jerry_create_error_from_value (jerry_value_t value, /**< api value */
        -: 1138:                               bool release) /**< release api value */
        -: 1139:{
        -: 1140:  jerry_assert_api_available ();
        -: 1141:
    #####: 1142:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1143:  {
        -: 1144:    /* This is a rare case so it is optimized for
        -: 1145:     * binary size rather than performance. */
    #####: 1146:    if (!jerry_value_is_abort (value))
        -: 1147:    {
    #####: 1148:      return release ? value : jerry_acquire_value (value);
        -: 1149:    }
        -: 1150:
    #####: 1151:    value = jerry_get_value_from_error (value, release);
    #####: 1152:    release = true;
        -: 1153:  }
        -: 1154:
    #####: 1155:  if (!release)
        -: 1156:  {
    #####: 1157:    value = ecma_copy_value (value);
        -: 1158:  }
        -: 1159:
    #####: 1160:  return ecma_create_error_reference (value, true);
        -: 1161:} /* jerry_create_error_from_value */
        -: 1162:
        -: 1163:/**
        -: 1164: * Get the value from an error value.
        -: 1165: *
        -: 1166: * Extract the api value from an error. If the second argument is true
        -: 1167: * it will release the input error value.
        -: 1168: *
        -: 1169: * Note:
        -: 1170: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1171: *
        -: 1172: * @return jerry_value_t value
        -: 1173: */
        -: 1174:jerry_value_t
    #####: 1175:jerry_get_value_from_error (jerry_value_t value, /**< api value */
        -: 1176:                            bool release) /**< release api value */
        -: 1177:{
        -: 1178:  jerry_assert_api_available ();
        -: 1179:
    #####: 1180:  if (!ecma_is_value_error_reference (value))
        -: 1181:  {
    #####: 1182:    return release ? value : ecma_copy_value (value);
        -: 1183:  }
        -: 1184:
    #####: 1185:  jerry_value_t ret_val = jerry_acquire_value (ecma_get_error_reference_from_value (value)->value);
        -: 1186:
    #####: 1187:  if (release)
        -: 1188:  {
    #####: 1189:    jerry_release_value (value);
        -: 1190:  }
    #####: 1191:  return ret_val;
        -: 1192:} /* jerry_get_value_from_error */
        -: 1193:
        -: 1194:/**
        -: 1195: * Return the type of the Error object if possible.
        -: 1196: *
        -: 1197: * @return one of the jerry_error_t value as the type of the Error object
        -: 1198: *         JERRY_ERROR_NONE - if the input value is not an Error object
        -: 1199: */
        -: 1200:jerry_error_t
    #####: 1201:jerry_get_error_type (jerry_value_t value) /**< api value */
        -: 1202:{
    #####: 1203:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1204:  {
    #####: 1205:    value = ecma_get_error_reference_from_value (value)->value;
        -: 1206:  }
        -: 1207:
    #####: 1208:  if (!ecma_is_value_object (value))
        -: 1209:  {
    #####: 1210:    return JERRY_ERROR_NONE;
        -: 1211:  }
        -: 1212:
    #####: 1213:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 1214:  ecma_standard_error_t error_type = ecma_get_error_type (object_p);
        -: 1215:
    #####: 1216:  return (jerry_error_t) error_type;
        -: 1217:} /* jerry_get_error_type */
        -: 1218:
        -: 1219:/**
        -: 1220: * Get boolean from the specified value.
        -: 1221: *
        -: 1222: * @return true or false.
        -: 1223: */
        -: 1224:bool
    #####: 1225:jerry_get_boolean_value (const jerry_value_t value) /**< api value */
        -: 1226:{
        -: 1227:  jerry_assert_api_available ();
        -: 1228:
    #####: 1229:  return ecma_is_value_true (value);
        -: 1230:} /* jerry_get_boolean_value */
        -: 1231:
        -: 1232:/**
        -: 1233: * Get number from the specified value as a double.
        -: 1234: *
        -: 1235: * @return stored number as double
        -: 1236: */
        -: 1237:double
    #####: 1238:jerry_get_number_value (const jerry_value_t value) /**< api value */
        -: 1239:{
        -: 1240:  jerry_assert_api_available ();
        -: 1241:
    #####: 1242:  if (!ecma_is_value_number (value))
        -: 1243:  {
    #####: 1244:    return 0;
        -: 1245:  }
        -: 1246:
    #####: 1247:  return (double) ecma_get_number_from_value (value);
        -: 1248:} /* jerry_get_number_value */
        -: 1249:
        -: 1250:/**
        -: 1251: * Call ToBoolean operation on the api value.
        -: 1252: *
        -: 1253: * @return true  - if the logical value is true
        -: 1254: *         false - otherwise
        -: 1255: */
        -: 1256:bool
    #####: 1257:jerry_value_to_boolean (const jerry_value_t value) /**< input value */
        -: 1258:{
        -: 1259:  jerry_assert_api_available ();
        -: 1260:
    #####: 1261:  if (ecma_is_value_error_reference (value))
        -: 1262:  {
    #####: 1263:    return false;
        -: 1264:  }
        -: 1265:
    #####: 1266:  return ecma_op_to_boolean (value);
        -: 1267:} /* jerry_value_to_boolean */
        -: 1268:
        -: 1269:/**
        -: 1270: * Call ToNumber operation on the api value.
        -: 1271: *
        -: 1272: * Note:
        -: 1273: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1274: *
        -: 1275: * @return converted number value - if success
        -: 1276: *         thrown error - otherwise
        -: 1277: */
        -: 1278:jerry_value_t
    #####: 1279:jerry_value_to_number (const jerry_value_t value) /**< input value */
        -: 1280:{
        -: 1281:  jerry_assert_api_available ();
        -: 1282:
    #####: 1283:  if (ecma_is_value_error_reference (value))
        -: 1284:  {
    #####: 1285:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 1286:  }
        -: 1287:
    #####: 1288:  return jerry_return (ecma_op_to_number (value));
        -: 1289:} /* jerry_value_to_number */
        -: 1290:
        -: 1291:/**
        -: 1292: * Call ToObject operation on the api value.
        -: 1293: *
        -: 1294: * Note:
        -: 1295: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1296: *
        -: 1297: * @return converted object value - if success
        -: 1298: *         thrown error - otherwise
        -: 1299: */
        -: 1300:jerry_value_t
    #####: 1301:jerry_value_to_object (const jerry_value_t value) /**< input value */
        -: 1302:{
        -: 1303:  jerry_assert_api_available ();
        -: 1304:
    #####: 1305:  if (ecma_is_value_error_reference (value))
        -: 1306:  {
    #####: 1307:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 1308:  }
        -: 1309:
    #####: 1310:  return jerry_return (ecma_op_to_object (value));
        -: 1311:} /* jerry_value_to_object */
        -: 1312:
        -: 1313:/**
        -: 1314: * Call ToPrimitive operation on the api value.
        -: 1315: *
        -: 1316: * Note:
        -: 1317: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1318: *
        -: 1319: * @return converted primitive value - if success
        -: 1320: *         thrown error - otherwise
        -: 1321: */
        -: 1322:jerry_value_t
    #####: 1323:jerry_value_to_primitive (const jerry_value_t value) /**< input value */
        -: 1324:{
        -: 1325:  jerry_assert_api_available ();
        -: 1326:
    #####: 1327:  if (ecma_is_value_error_reference (value))
        -: 1328:  {
    #####: 1329:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 1330:  }
        -: 1331:
    #####: 1332:  return jerry_return (ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_NO));
        -: 1333:} /* jerry_value_to_primitive */
        -: 1334:
        -: 1335:/**
        -: 1336: * Call the ToString ecma builtin operation on the api value.
        -: 1337: *
        -: 1338: * Note:
        -: 1339: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1340: *
        -: 1341: * @return converted string value - if success
        -: 1342: *         thrown error - otherwise
        -: 1343: */
        -: 1344:jerry_value_t
    #####: 1345:jerry_value_to_string (const jerry_value_t value) /**< input value */
        -: 1346:{
        -: 1347:
        -: 1348:  jerry_assert_api_available ();
        -: 1349:
    #####: 1350:  if (ecma_is_value_error_reference (value))
        -: 1351:  {
    #####: 1352:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 1353:  }
        -: 1354:
    #####: 1355:  ecma_string_t *str_p = ecma_op_to_string (value);
    #####: 1356:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 1357:  {
    #####: 1358:    return ecma_create_error_reference_from_context ();
        -: 1359:  }
        -: 1360:
    #####: 1361:  return jerry_return (ecma_make_string_value (str_p));
        -: 1362:} /* jerry_value_to_string */
        -: 1363:
        -: 1364:/**
        -: 1365: * Acquire specified Jerry API value.
        -: 1366: *
        -: 1367: * Note:
        -: 1368: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1369: *
        -: 1370: * @return acquired api value
        -: 1371: */
        -: 1372:jerry_value_t
    #####: 1373:jerry_acquire_value (jerry_value_t value) /**< API value */
        -: 1374:{
        -: 1375:  jerry_assert_api_available ();
        -: 1376:
    #####: 1377:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1378:  {
    #####: 1379:    ecma_ref_error_reference (ecma_get_error_reference_from_value (value));
    #####: 1380:    return value;
        -: 1381:  }
        -: 1382:
    #####: 1383:  return ecma_copy_value (value);
        -: 1384:} /* jerry_acquire_value */
        -: 1385:
        -: 1386:/**
        -: 1387: * Release specified Jerry API value
        -: 1388: */
        -: 1389:void
       16: 1390:jerry_release_value (jerry_value_t value) /**< API value */
        -: 1391:{
        -: 1392:  jerry_assert_api_available ();
        -: 1393:
       16: 1394:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1395:  {
    #####: 1396:    ecma_deref_error_reference (ecma_get_error_reference_from_value (value));
    #####: 1397:    return;
        -: 1398:  }
        -: 1399:
       16: 1400:  ecma_free_value (value);
        -: 1401:} /* jerry_release_value */
        -: 1402:
        -: 1403:/**
        -: 1404: * Create an array object value
        -: 1405: *
        -: 1406: * Note:
        -: 1407: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1408: *
        -: 1409: * @return value of the constructed array object
        -: 1410: */
        -: 1411:jerry_value_t
    #####: 1412:jerry_create_array (uint32_t size) /**< size of array */
        -: 1413:{
        -: 1414:  jerry_assert_api_available ();
        -: 1415:
    #####: 1416:  ecma_value_t array_length = ecma_make_uint32_value (size);
        -: 1417:
    #####: 1418:  const jerry_length_t argument_size = 1;
    #####: 1419:  ecma_value_t array_value = ecma_op_create_array_object (&array_length, argument_size, true);
    #####: 1420:  ecma_free_value (array_length);
        -: 1421:
    #####: 1422:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (array_value));
        -: 1423:
    #####: 1424:  return array_value;
        -: 1425:} /* jerry_create_array */
        -: 1426:
        -: 1427:/**
        -: 1428: * Create a jerry_value_t representing a boolean value from the given boolean parameter.
        -: 1429: *
        -: 1430: * @return value of the created boolean
        -: 1431: */
        -: 1432:jerry_value_t
    #####: 1433:jerry_create_boolean (bool value) /**< bool value from which a jerry_value_t will be created */
        -: 1434:{
        -: 1435:  jerry_assert_api_available ();
        -: 1436:
    #####: 1437:  return jerry_return (ecma_make_boolean_value (value));
        -: 1438:} /* jerry_create_boolean */
        -: 1439:
        -: 1440:/**
        -: 1441: * Create an error object
        -: 1442: *
        -: 1443: * Note:
        -: 1444: *      - returned value must be freed with jerry_release_value, when it is no longer needed
        -: 1445: *      - the error flag is set for the returned value
        -: 1446: *
        -: 1447: * @return value of the constructed error object
        -: 1448: */
        -: 1449:jerry_value_t
    #####: 1450:jerry_create_error (jerry_error_t error_type, /**< type of error */
        -: 1451:                    const jerry_char_t *message_p) /**< value of 'message' property
        -: 1452:                                                    *   of constructed error object */
        -: 1453:{
    #####: 1454:  return jerry_create_error_sz (error_type,
        -: 1455:                                (lit_utf8_byte_t *) message_p,
        -: 1456:                                lit_zt_utf8_string_size (message_p));
        -: 1457:} /* jerry_create_error */
        -: 1458:
        -: 1459:/**
        -: 1460: * Create an error object
        -: 1461: *
        -: 1462: * Note:
        -: 1463: *      - returned value must be freed with jerry_release_value, when it is no longer needed
        -: 1464: *      - the error flag is set for the returned value
        -: 1465: *
        -: 1466: * @return value of the constructed error object
        -: 1467: */
        -: 1468:jerry_value_t
    #####: 1469:jerry_create_error_sz (jerry_error_t error_type, /**< type of error */
        -: 1470:                       const jerry_char_t *message_p, /**< value of 'message' property
        -: 1471:                                                       *   of constructed error object */
        -: 1472:                       jerry_size_t message_size) /**< size of the message in bytes */
        -: 1473:{
        -: 1474:  jerry_assert_api_available ();
        -: 1475:
    #####: 1476:  if (message_p == NULL || message_size == 0)
        -: 1477:  {
    #####: 1478:    return ecma_create_error_object_reference (ecma_new_standard_error ((ecma_standard_error_t) error_type));
        -: 1479:  }
        -: 1480:  else
        -: 1481:  {
    #####: 1482:    ecma_string_t *message_string_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) message_p,
        -: 1483:                                                                      (lit_utf8_size_t) message_size);
        -: 1484:
    #####: 1485:    ecma_object_t *error_object_p = ecma_new_standard_error_with_message ((ecma_standard_error_t) error_type,
        -: 1486:                                                                          message_string_p);
        -: 1487:
    #####: 1488:    ecma_deref_ecma_string (message_string_p);
        -: 1489:
    #####: 1490:    return ecma_create_error_object_reference (error_object_p);
        -: 1491:  }
        -: 1492:} /* jerry_create_error_sz */
        -: 1493:
        -: 1494:/**
        -: 1495: * Create an external function object
        -: 1496: *
        -: 1497: * Note:
        -: 1498: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1499: *
        -: 1500: * @return value of the constructed function object
        -: 1501: */
        -: 1502:jerry_value_t
        4: 1503:jerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler
        -: 1504:                                                                     *   for the function */
        -: 1505:{
        -: 1506:  jerry_assert_api_available ();
        -: 1507:
        4: 1508:  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler_p);
        4: 1509:  return ecma_make_object_value (func_obj_p);
        -: 1510:} /* jerry_create_external_function */
        -: 1511:
        -: 1512:/**
        -: 1513: * Creates a jerry_value_t representing a number value.
        -: 1514: *
        -: 1515: * Note:
        -: 1516: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1517: *
        -: 1518: * @return jerry_value_t created from the given double argument.
        -: 1519: */
        -: 1520:jerry_value_t
    #####: 1521:jerry_create_number (double value) /**< double value from which a jerry_value_t will be created */
        -: 1522:{
        -: 1523:  jerry_assert_api_available ();
        -: 1524:
    #####: 1525:  return ecma_make_number_value ((ecma_number_t) value);
        -: 1526:} /* jerry_create_number */
        -: 1527:
        -: 1528:/**
        -: 1529: * Creates a jerry_value_t representing a positive or negative infinity value.
        -: 1530: *
        -: 1531: * Note:
        -: 1532: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1533: *
        -: 1534: * @return jerry_value_t representing an infinity value.
        -: 1535: */
        -: 1536:jerry_value_t
    #####: 1537:jerry_create_number_infinity (bool sign) /**< true for negative Infinity
        -: 1538:                                          *   false for positive Infinity */
        -: 1539:{
        -: 1540:  jerry_assert_api_available ();
        -: 1541:
    #####: 1542:  return ecma_make_number_value (ecma_number_make_infinity (sign));
        -: 1543:} /* jerry_create_number_infinity */
        -: 1544:
        -: 1545:/**
        -: 1546: * Creates a jerry_value_t representing a not-a-number value.
        -: 1547: *
        -: 1548: * Note:
        -: 1549: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1550: *
        -: 1551: * @return jerry_value_t representing a not-a-number value.
        -: 1552: */
        -: 1553:jerry_value_t
    #####: 1554:jerry_create_number_nan (void)
        -: 1555:{
        -: 1556:  jerry_assert_api_available ();
        -: 1557:
    #####: 1558:  return ecma_make_nan_value ();
        -: 1559:} /* jerry_create_number_nan */
        -: 1560:
        -: 1561:/**
        -: 1562: * Creates a jerry_value_t representing an undefined value.
        -: 1563: *
        -: 1564: * @return value of undefined
        -: 1565: */
        -: 1566:jerry_value_t
        1: 1567:jerry_create_undefined (void)
        -: 1568:{
        -: 1569:  jerry_assert_api_available ();
        -: 1570:
        1: 1571:  return ECMA_VALUE_UNDEFINED;
        -: 1572:} /* jerry_create_undefined */
        -: 1573:
        -: 1574:/**
        -: 1575: * Creates and returns a jerry_value_t with type null object.
        -: 1576: *
        -: 1577: * @return jerry_value_t representing null
        -: 1578: */
        -: 1579:jerry_value_t
    #####: 1580:jerry_create_null (void)
        -: 1581:{
        -: 1582:  jerry_assert_api_available ();
        -: 1583:
    #####: 1584:  return ECMA_VALUE_NULL;
        -: 1585:} /* jerry_create_null */
        -: 1586:
        -: 1587:/**
        -: 1588: * Create new JavaScript object, like with new Object().
        -: 1589: *
        -: 1590: * Note:
        -: 1591: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1592: *
        -: 1593: * @return value of the created object
        -: 1594: */
        -: 1595:jerry_value_t
    #####: 1596:jerry_create_object (void)
        -: 1597:{
        -: 1598:  jerry_assert_api_available ();
        -: 1599:
    #####: 1600:  return ecma_make_object_value (ecma_op_create_object_object_noarg ());
        -: 1601:} /* jerry_create_object */
        -: 1602:
        -: 1603:/**
        -: 1604: * Create an empty Promise object which can be resolve/reject later
        -: 1605: * by calling jerry_resolve_or_reject_promise.
        -: 1606: *
        -: 1607: * Note:
        -: 1608: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1609: *
        -: 1610: * @return value of the created object
        -: 1611: */
        -: 1612:jerry_value_t
    #####: 1613:jerry_create_promise (void)
        -: 1614:{
        -: 1615:  jerry_assert_api_available ();
        -: 1616:
        -: 1617:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
    #####: 1618:  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target);
        -: 1619:
    #####: 1620:  if (old_new_target_p == NULL)
        -: 1621:  {
    #####: 1622:    JERRY_CONTEXT (current_new_target) = ecma_builtin_get (ECMA_BUILTIN_ID_PROMISE);
        -: 1623:  }
        -: 1624:
    #####: 1625:  ecma_value_t promise_value = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_PROMISE_EXECUTOR_EMPTY);
        -: 1626:
    #####: 1627:  JERRY_CONTEXT (current_new_target) = old_new_target_p;
    #####: 1628:  return promise_value;
        -: 1629:#else /* !ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
    #####: 1630:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Promise not supported.")));
        -: 1631:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -: 1632:} /* jerry_create_promise */
        -: 1633:
        -: 1634:/**
        -: 1635: * Create a new Proxy object with the given target and handler
        -: 1636: *
        -: 1637: * Note:
        -: 1638: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1639: *
        -: 1640: * @return value of the created Proxy object
        -: 1641: */
        -: 1642:jerry_value_t
    #####: 1643:jerry_create_proxy (const jerry_value_t target, /**< target argument */
        -: 1644:                    const jerry_value_t handler) /**< handler argument */
        -: 1645:{
        -: 1646:  jerry_assert_api_available ();
        -: 1647:
    #####: 1648:  if (ecma_is_value_error_reference (target)
    #####: 1649:      || ecma_is_value_error_reference (handler))
        -: 1650:  {
    #####: 1651:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 1652:  }
        -: 1653:
        -: 1654:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 1655:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler);
    #####: 1656:  return jerry_return (proxy_p == NULL ? ECMA_VALUE_ERROR : ecma_make_object_value (proxy_p));
        -: 1657:#else /* !ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
    #####: 1658:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Proxy is not supported.")));
        -: 1659:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1660:} /* jerry_create_proxy */
        -: 1661:
        -: 1662:/**
        -: 1663: * Create string from a valid UTF-8 string
        -: 1664: *
        -: 1665: * Note:
        -: 1666: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 1667: *
        -: 1668: * @return value of the created string
        -: 1669: */
        -: 1670:jerry_value_t
    #####: 1671:jerry_create_string_from_utf8 (const jerry_char_t *str_p) /**< pointer to string */
        -: 1672:{
    #####: 1673:  return jerry_create_string_sz_from_utf8 (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));
        -: 1674:} /* jerry_create_string_from_utf8 */
        -: 1675:
        -: 1676:/**
        -: 1677: * Create string from a valid UTF-8 string
        -: 1678: *
        -: 1679: * Note:
        -: 1680: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 1681: *
        -: 1682: * @return value of the created string
        -: 1683: */
        -: 1684:jerry_value_t
    #####: 1685:jerry_create_string_sz_from_utf8 (const jerry_char_t *str_p, /**< pointer to string */
        -: 1686:                                  jerry_size_t str_size) /**< string size */
        -: 1687:{
        -: 1688:  jerry_assert_api_available ();
        -: 1689:
    #####: 1690:  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 ((lit_utf8_byte_t *) str_p,
        -: 1691:                                                                                 (lit_utf8_size_t) str_size);
        -: 1692:
    #####: 1693:  return ecma_make_string_value (ecma_str_p);
        -: 1694:} /* jerry_create_string_sz_from_utf8 */
        -: 1695:
        -: 1696:/**
        -: 1697: * Create string from a valid CESU-8 string
        -: 1698: *
        -: 1699: * Note:
        -: 1700: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1701: *
        -: 1702: * @return value of the created string
        -: 1703: */
        -: 1704:jerry_value_t
        4: 1705:jerry_create_string (const jerry_char_t *str_p) /**< pointer to string */
        -: 1706:{
        4: 1707:  return jerry_create_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));
        -: 1708:} /* jerry_create_string */
        -: 1709:
        -: 1710:/**
        -: 1711: * Create string from a valid CESU-8 string
        -: 1712: *
        -: 1713: * Note:
        -: 1714: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 1715: *
        -: 1716: * @return value of the created string
        -: 1717: */
        -: 1718:jerry_value_t
        4: 1719:jerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */
        -: 1720:                        jerry_size_t str_size) /**< string size */
        -: 1721:{
        -: 1722:  jerry_assert_api_available ();
        -: 1723:
        4: 1724:  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) str_p,
        -: 1725:                                                              (lit_utf8_size_t) str_size);
        4: 1726:  return ecma_make_string_value (ecma_str_p);
        -: 1727:} /* jerry_create_string_sz */
        -: 1728:
        -: 1729:/**
        -: 1730: * Create symbol from an api value
        -: 1731: *
        -: 1732: * Note:
        -: 1733: *      The given argument is converted to string. This operation can throw an error.
        -: 1734: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 1735: *
        -: 1736: * @return value of the created symbol, if success
        -: 1737: *         thrown error, otherwise
        -: 1738: */
        -: 1739:jerry_value_t
    #####: 1740:jerry_create_symbol (const jerry_value_t value) /**< api value */
        -: 1741:{
        -: 1742:  jerry_assert_api_available ();
        -: 1743:
    #####: 1744:  if (ecma_is_value_error_reference (value))
        -: 1745:  {
    #####: 1746:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 1747:  }
        -: 1748:
        -: 1749:#if ENABLED (JERRY_ES2015)
    #####: 1750:  return jerry_return (ecma_op_create_symbol (&value, 1));
        -: 1751:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1752:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Symbol is not supported.")));
        -: 1753:#endif /* ENABLED (JERRY_ES2015) */
        -: 1754:} /* jerry_create_symbol */
        -: 1755:
        -: 1756:/**
        -: 1757: * Calculates the size of the given pattern and creates a RegExp object.
        -: 1758: *
        -: 1759: * @return value of the constructed RegExp object.
        -: 1760: */
        -: 1761:jerry_value_t
    #####: 1762:jerry_create_regexp (const jerry_char_t *pattern_p, /**< zero-terminated UTF-8 string as RegExp pattern */
        -: 1763:                     uint16_t flags) /**< optional RegExp flags */
        -: 1764:{
    #####: 1765:  return jerry_create_regexp_sz (pattern_p, lit_zt_utf8_string_size (pattern_p), flags);
        -: 1766:} /* jerry_create_regexp */
        -: 1767:
        -: 1768:/**
        -: 1769: * Creates a RegExp object with the given pattern and flags.
        -: 1770: *
        -: 1771: * @return value of the constructed RegExp object.
        -: 1772: */
        -: 1773:jerry_value_t
    #####: 1774:jerry_create_regexp_sz (const jerry_char_t *pattern_p, /**< zero-terminated UTF-8 string as RegExp pattern */
        -: 1775:                        jerry_size_t pattern_size, /**< length of the pattern */
        -: 1776:                        uint16_t flags) /**< optional RegExp flags */
        -: 1777:{
        -: 1778:  jerry_assert_api_available ();
        -: 1779:
        -: 1780:#if ENABLED (JERRY_BUILTIN_REGEXP)
    #####: 1781:  if (!lit_is_valid_utf8_string (pattern_p, pattern_size))
        -: 1782:  {
    #####: 1783:    return jerry_throw (ecma_raise_common_error (ECMA_ERR_MSG ("Input must be a valid utf8 string")));
        -: 1784:  }
        -: 1785:
    #####: 1786:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -: 1787:
    #####: 1788:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -: 1789:  {
    #####: 1790:    return ECMA_VALUE_ERROR;
        -: 1791:  }
        -: 1792:
    #####: 1793:  ecma_string_t *ecma_pattern = ecma_new_ecma_string_from_utf8 (pattern_p, pattern_size);
        -: 1794:
    #####: 1795:  jerry_value_t ret_val = ecma_op_create_regexp_with_flags (regexp_obj_p,
        -: 1796:                                                            ecma_make_string_value (ecma_pattern),
        -: 1797:                                                            flags);
    #####: 1798:  ecma_deref_ecma_string (ecma_pattern);
        -: 1799:
    #####: 1800:  return ret_val;
        -: 1801:
        -: 1802:#else /* !ENABLED (JERRY_BUILTIN_REGEXP) */
        -: 1803:  JERRY_UNUSED (pattern_p);
        -: 1804:  JERRY_UNUSED (pattern_size);
        -: 1805:  JERRY_UNUSED (flags);
        -: 1806:
        -: 1807:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("RegExp is not supported.")));
        -: 1808:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
        -: 1809:} /* jerry_create_regexp_sz */
        -: 1810:
        -: 1811:/**
        -: 1812: * Get length of an array object
        -: 1813: *
        -: 1814: * Note:
        -: 1815: *      Returns 0, if the value parameter is not an array object.
        -: 1816: *
        -: 1817: * @return length of the given array
        -: 1818: */
        -: 1819:uint32_t
    #####: 1820:jerry_get_array_length (const jerry_value_t value) /**< api value */
        -: 1821:{
        -: 1822:  jerry_assert_api_available ();
        -: 1823:
    #####: 1824:  if (!jerry_value_is_object (value))
        -: 1825:  {
    #####: 1826:    return 0;
        -: 1827:  }
        -: 1828:
    #####: 1829:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 1830:
    #####: 1831:  if (JERRY_LIKELY (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY))
        -: 1832:  {
    #####: 1833:    return ecma_array_get_length (object_p);
        -: 1834:  }
        -: 1835:
    #####: 1836:  return 0;
        -: 1837:} /* jerry_get_array_length */
        -: 1838:
        -: 1839:/**
        -: 1840: * Get size of Jerry string
        -: 1841: *
        -: 1842: * Note:
        -: 1843: *      Returns 0, if the value parameter is not a string.
        -: 1844: *
        -: 1845: * @return number of bytes in the buffer needed to represent the string
        -: 1846: */
        -: 1847:jerry_size_t
    #####: 1848:jerry_get_string_size (const jerry_value_t value) /**< input string */
        -: 1849:{
        -: 1850:  jerry_assert_api_available ();
        -: 1851:
    #####: 1852:  if (!ecma_is_value_string (value))
        -: 1853:  {
    #####: 1854:    return 0;
        -: 1855:  }
        -: 1856:
    #####: 1857:  return ecma_string_get_size (ecma_get_string_from_value (value));
        -: 1858:} /* jerry_get_string_size */
        -: 1859:
        -: 1860:/**
        -: 1861: * Get UTF-8 encoded string size from Jerry string
        -: 1862: *
        -: 1863: * Note:
        -: 1864: *      Returns 0, if the value parameter is not a string.
        -: 1865: *
        -: 1866: * @return number of bytes in the buffer needed to represent the UTF-8 encoded string
        -: 1867: */
        -: 1868:jerry_size_t
    #####: 1869:jerry_get_utf8_string_size (const jerry_value_t value) /**< input string */
        -: 1870:{
        -: 1871:  jerry_assert_api_available ();
        -: 1872:
    #####: 1873:  if (!ecma_is_value_string (value))
        -: 1874:  {
    #####: 1875:    return 0;
        -: 1876:  }
        -: 1877:
    #####: 1878:  return ecma_string_get_utf8_size (ecma_get_string_from_value (value));
        -: 1879:} /* jerry_get_utf8_string_size */
        -: 1880:
        -: 1881:/**
        -: 1882: * Get length of Jerry string
        -: 1883: *
        -: 1884: * Note:
        -: 1885: *      Returns 0, if the value parameter is not a string.
        -: 1886: *
        -: 1887: * @return number of characters in the string
        -: 1888: */
        -: 1889:jerry_length_t
    #####: 1890:jerry_get_string_length (const jerry_value_t value) /**< input string */
        -: 1891:{
        -: 1892:  jerry_assert_api_available ();
        -: 1893:
    #####: 1894:  if (!ecma_is_value_string (value))
        -: 1895:  {
    #####: 1896:    return 0;
        -: 1897:  }
        -: 1898:
    #####: 1899:  return ecma_string_get_length (ecma_get_string_from_value (value));
        -: 1900:} /* jerry_get_string_length */
        -: 1901:
        -: 1902:/**
        -: 1903: * Get UTF-8 string length from Jerry string
        -: 1904: *
        -: 1905: * Note:
        -: 1906: *      Returns 0, if the value parameter is not a string.
        -: 1907: *
        -: 1908: * @return number of characters in the string
        -: 1909: */
        -: 1910:jerry_length_t
    #####: 1911:jerry_get_utf8_string_length (const jerry_value_t value) /**< input string */
        -: 1912:{
        -: 1913:  jerry_assert_api_available ();
        -: 1914:
    #####: 1915:  if (!ecma_is_value_string (value))
        -: 1916:  {
    #####: 1917:    return 0;
        -: 1918:  }
        -: 1919:
    #####: 1920:  return ecma_string_get_utf8_length (ecma_get_string_from_value (value));
        -: 1921:} /* jerry_get_utf8_string_length */
        -: 1922:
        -: 1923:/**
        -: 1924: * Copy the characters of a string into a specified buffer.
        -: 1925: *
        -: 1926: * Note:
        -: 1927: *      The '\0' character could occur in character buffer.
        -: 1928: *      Returns 0, if the value parameter is not a string or
        -: 1929: *      the buffer is not large enough for the whole string.
        -: 1930: *
        -: 1931: * Note:
        -: 1932: *      If the size of the string in jerry value is larger than the size of the
        -: 1933: *      target buffer, the copy will fail.
        -: 1934: *      To copy substring use jerry_substring_to_char_buffer() instead.
        -: 1935: *
        -: 1936: * @return number of bytes, actually copied to the buffer.
        -: 1937: */
        -: 1938:jerry_size_t
    #####: 1939:jerry_string_to_char_buffer (const jerry_value_t value, /**< input string value */
        -: 1940:                             jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 1941:                             jerry_size_t buffer_size) /**< size of output buffer */
        -: 1942:{
        -: 1943:  jerry_assert_api_available ();
        -: 1944:
    #####: 1945:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 1946:  {
    #####: 1947:    return 0;
        -: 1948:  }
        -: 1949:
    #####: 1950:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 1951:
    #####: 1952:  if (ecma_string_get_size (str_p) > buffer_size)
        -: 1953:  {
    #####: 1954:    return 0;
        -: 1955:  }
        -: 1956:
    #####: 1957:  return ecma_string_copy_to_cesu8_buffer (str_p,
        -: 1958:                                           (lit_utf8_byte_t *) buffer_p,
        -: 1959:                                           buffer_size);
        -: 1960:} /* jerry_string_to_char_buffer */
        -: 1961:
        -: 1962:/**
        -: 1963: * Copy the characters of an utf-8 encoded string into a specified buffer.
        -: 1964: *
        -: 1965: * Note:
        -: 1966: *      The '\0' character could occur anywhere in the returned string
        -: 1967: *      Returns 0, if the value parameter is not a string or the buffer
        -: 1968: *      is not large enough for the whole string.
        -: 1969: *
        -: 1970: * Note:
        -: 1971: *      If the size of the string in jerry value is larger than the size of the
        -: 1972: *      target buffer, the copy will fail.
        -: 1973: *      To copy a substring use jerry_substring_to_utf8_char_buffer() instead.
        -: 1974: *
        -: 1975: * @return number of bytes copied to the buffer.
        -: 1976: */
        -: 1977:jerry_size_t
    #####: 1978:jerry_string_to_utf8_char_buffer (const jerry_value_t value, /**< input string value */
        -: 1979:                                  jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 1980:                                  jerry_size_t buffer_size) /**< size of output buffer */
        -: 1981:{
        -: 1982:  jerry_assert_api_available ();
        -: 1983:
    #####: 1984:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 1985:  {
    #####: 1986:    return 0;
        -: 1987:  }
        -: 1988:
    #####: 1989:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 1990:
    #####: 1991:  if (ecma_string_get_utf8_size (str_p) > buffer_size)
        -: 1992:  {
    #####: 1993:    return 0;
        -: 1994:  }
        -: 1995:
    #####: 1996:  return ecma_string_copy_to_utf8_buffer (str_p,
        -: 1997:                                          (lit_utf8_byte_t *) buffer_p,
        -: 1998:                                          buffer_size);
        -: 1999:} /* jerry_string_to_utf8_char_buffer */
        -: 2000:
        -: 2001:/**
        -: 2002: * Copy the characters of an cesu-8 encoded substring into a specified buffer.
        -: 2003: *
        -: 2004: * Note:
        -: 2005: *      The '\0' character could occur anywhere in the returned string
        -: 2006: *      Returns 0, if the value parameter is not a string.
        -: 2007: *      It will extract the substring beetween the specified start position
        -: 2008: *      and the end position (or the end of the string, whichever comes first).
        -: 2009: *
        -: 2010: * @return number of bytes copied to the buffer.
        -: 2011: */
        -: 2012:jerry_size_t
    #####: 2013:jerry_substring_to_char_buffer (const jerry_value_t value, /**< input string value */
        -: 2014:                                jerry_length_t start_pos, /**< position of the first character */
        -: 2015:                                jerry_length_t end_pos, /**< position of the last character */
        -: 2016:                                jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 2017:                                jerry_size_t buffer_size) /**< size of output buffer */
        -: 2018:{
        -: 2019:  jerry_assert_api_available ();
        -: 2020:
    #####: 2021:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 2022:  {
    #####: 2023:    return 0;
        -: 2024:  }
        -: 2025:
    #####: 2026:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 2027:
    #####: 2028:  return ecma_substring_copy_to_cesu8_buffer (str_p,
        -: 2029:                                              start_pos,
        -: 2030:                                              end_pos,
        -: 2031:                                              (lit_utf8_byte_t *) buffer_p,
        -: 2032:                                              buffer_size);
        -: 2033:} /* jerry_substring_to_char_buffer */
        -: 2034:
        -: 2035:/**
        -: 2036: * Copy the characters of an utf-8 encoded substring into a specified buffer.
        -: 2037: *
        -: 2038: * Note:
        -: 2039: *      The '\0' character could occur anywhere in the returned string
        -: 2040: *      Returns 0, if the value parameter is not a string.
        -: 2041: *      It will extract the substring beetween the specified start position
        -: 2042: *      and the end position (or the end of the string, whichever comes first).
        -: 2043: *
        -: 2044: * @return number of bytes copied to the buffer.
        -: 2045: */
        -: 2046:jerry_size_t
    #####: 2047:jerry_substring_to_utf8_char_buffer (const jerry_value_t value, /**< input string value */
        -: 2048:                                     jerry_length_t start_pos, /**< position of the first character */
        -: 2049:                                     jerry_length_t end_pos, /**< position of the last character */
        -: 2050:                                     jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 2051:                                     jerry_size_t buffer_size) /**< size of output buffer */
        -: 2052:{
        -: 2053:  jerry_assert_api_available ();
        -: 2054:
    #####: 2055:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 2056:  {
    #####: 2057:    return 0;
        -: 2058:  }
        -: 2059:
    #####: 2060:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 2061:
    #####: 2062:  return ecma_substring_copy_to_utf8_buffer (str_p,
        -: 2063:                                             start_pos,
        -: 2064:                                             end_pos,
        -: 2065:                                             (lit_utf8_byte_t *) buffer_p,
        -: 2066:                                             buffer_size);
        -: 2067:} /* jerry_substring_to_utf8_char_buffer */
        -: 2068:
        -: 2069:/**
        -: 2070: * Checks whether the object or it's prototype objects have the given property.
        -: 2071: *
        -: 2072: * @return raised error - if the operation fail
        -: 2073: *         true/false API value  - depend on whether the property exists
        -: 2074: */
        -: 2075:jerry_value_t
    #####: 2076:jerry_has_property (const jerry_value_t obj_val, /**< object value */
        -: 2077:                    const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 2078:{
        -: 2079:  jerry_assert_api_available ();
        -: 2080:
    #####: 2081:  if (!ecma_is_value_object (obj_val)
    #####: 2082:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2083:  {
    #####: 2084:    return ECMA_VALUE_FALSE;
        -: 2085:  }
        -: 2086:
    #####: 2087:  return ecma_op_object_has_property (ecma_get_object_from_value (obj_val),
        -: 2088:                                      ecma_get_prop_name_from_value (prop_name_val));
        -: 2089:} /* jerry_has_property */
        -: 2090:
        -: 2091:/**
        -: 2092: * Checks whether the object has the given property.
        -: 2093: *
        -: 2094: * @return ECMA_VALUE_ERROR - if the operation raises error
        -: 2095: *         ECMA_VALUE_{TRUE, FALSE} - based on whether the property exists
        -: 2096: */
        -: 2097:jerry_value_t
    #####: 2098:jerry_has_own_property (const jerry_value_t obj_val, /**< object value */
        -: 2099:                        const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 2100:{
        -: 2101:  jerry_assert_api_available ();
        -: 2102:
    #####: 2103:  if (!ecma_is_value_object (obj_val)
    #####: 2104:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2105:  {
    #####: 2106:    return ECMA_VALUE_FALSE;
        -: 2107:  }
        -: 2108:
    #####: 2109:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
    #####: 2110:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (prop_name_val);
        -: 2111:
        -: 2112:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 2113:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 2114:  {
    #####: 2115:    ecma_property_descriptor_t prop_desc;
        -: 2116:
    #####: 2117:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 2118:
    #####: 2119:    if (ecma_is_value_true (status))
        -: 2120:    {
    #####: 2121:      ecma_free_property_descriptor (&prop_desc);
        -: 2122:    }
        -: 2123:
    #####: 2124:    return jerry_return (status);
        -: 2125:  }
        -: 2126:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 2127:
    #####: 2128:  return ecma_make_boolean_value (ecma_op_ordinary_object_has_own_property (obj_p, prop_name_p));
        -: 2129:} /* jerry_has_own_property */
        -: 2130:
        -: 2131:/**
        -: 2132: * Checks whether the object has the given internal property.
        -: 2133: *
        -: 2134: * @return true  - if the internal property exists
        -: 2135: *         false - otherwise
        -: 2136: */
        -: 2137:bool
    #####: 2138:jerry_has_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 2139:                             const jerry_value_t prop_name_val) /**< property name value */
        -: 2140:{
        -: 2141:  jerry_assert_api_available ();
        -: 2142:
    #####: 2143:  if (!ecma_is_value_object (obj_val)
    #####: 2144:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2145:  {
    #####: 2146:    return false;
        -: 2147:  }
        -: 2148:
    #####: 2149:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 2150:
    #####: 2151:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 2152:
    #####: 2153:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2154:  {
    #####: 2155:    return false;
        -: 2156:  }
        -: 2157:
    #####: 2158:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 2159:
    #####: 2160:  if (property_p == NULL)
        -: 2161:  {
    #####: 2162:    return false;
        -: 2163:  }
        -: 2164:
    #####: 2165:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 2166:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 2167:
    #####: 2168:  return property_p != NULL;
        -: 2169:} /* jerry_has_internal_property */
        -: 2170:
        -: 2171:/**
        -: 2172: * Delete a property from an object.
        -: 2173: *
        -: 2174: * @return true  - if property was deleted successfully
        -: 2175: *         false - otherwise
        -: 2176: */
        -: 2177:bool
    #####: 2178:jerry_delete_property (const jerry_value_t obj_val, /**< object value */
        -: 2179:                       const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 2180:{
        -: 2181:  jerry_assert_api_available ();
        -: 2182:
    #####: 2183:  if (!ecma_is_value_object (obj_val)
    #####: 2184:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2185:  {
    #####: 2186:    return false;
        -: 2187:  }
        -: 2188:
    #####: 2189:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (obj_val),
        -: 2190:                                                  ecma_get_prop_name_from_value (prop_name_val),
        -: 2191:                                                  false);
        -: 2192:
        -: 2193:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 2194:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 2195:  {
        -: 2196:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 2197:    jcontext_release_exception ();
        -: 2198:  }
        -: 2199:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 2200:
    #####: 2201:  return ecma_is_value_true (ret_value);
        -: 2202:} /* jerry_delete_property */
        -: 2203:
        -: 2204:/**
        -: 2205: * Delete indexed property from the specified object.
        -: 2206: *
        -: 2207: * @return true  - if property was deleted successfully
        -: 2208: *         false - otherwise
        -: 2209: */
        -: 2210:bool
    #####: 2211:jerry_delete_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 2212:                                uint32_t index) /**< index to be written */
        -: 2213:{
        -: 2214:  jerry_assert_api_available ();
        -: 2215:
    #####: 2216:  if (!ecma_is_value_object (obj_val))
        -: 2217:  {
    #####: 2218:    return false;
        -: 2219:  }
        -: 2220:
    #####: 2221:  ecma_string_t *str_idx_p = ecma_new_ecma_string_from_uint32 (index);
    #####: 2222:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (obj_val),
        -: 2223:                                                  str_idx_p,
        -: 2224:                                                  false);
    #####: 2225:  ecma_deref_ecma_string (str_idx_p);
        -: 2226:
        -: 2227:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 2228:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 2229:  {
        -: 2230:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 2231:    jcontext_release_exception ();
        -: 2232:  }
        -: 2233:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 2234:
    #####: 2235:  return ecma_is_value_true (ret_value);
        -: 2236:} /* jerry_delete_property_by_index */
        -: 2237:
        -: 2238:/**
        -: 2239: * Delete an internal property from an object.
        -: 2240: *
        -: 2241: * @return true  - if property was deleted successfully
        -: 2242: *         false - otherwise
        -: 2243: */
        -: 2244:bool
    #####: 2245:jerry_delete_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 2246:                                const jerry_value_t prop_name_val) /**< property name value */
        -: 2247:{
        -: 2248:  jerry_assert_api_available ();
        -: 2249:
    #####: 2250:  if (!ecma_is_value_object (obj_val)
    #####: 2251:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2252:  {
    #####: 2253:    return false;
        -: 2254:  }
        -: 2255:
    #####: 2256:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 2257:
    #####: 2258:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 2259:
    #####: 2260:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2261:  {
    #####: 2262:    return true;
        -: 2263:  }
        -: 2264:
    #####: 2265:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 2266:
    #####: 2267:  if (property_p == NULL)
        -: 2268:  {
    #####: 2269:    return true;
        -: 2270:  }
        -: 2271:
    #####: 2272:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 2273:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 2274:
    #####: 2275:  if (property_p == NULL)
        -: 2276:  {
    #####: 2277:    return true;
        -: 2278:  }
        -: 2279:
    #####: 2280:  ecma_delete_property (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p));
        -: 2281:
    #####: 2282:  return true;
        -: 2283:} /* jerry_delete_internal_property */
        -: 2284:
        -: 2285:/**
        -: 2286: * Get value of a property to the specified object with the given name.
        -: 2287: *
        -: 2288: * Note:
        -: 2289: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2290: *
        -: 2291: * @return value of the property - if success
        -: 2292: *         value marked with error flag - otherwise
        -: 2293: */
        -: 2294:jerry_value_t
    #####: 2295:jerry_get_property (const jerry_value_t obj_val, /**< object value */
        -: 2296:                    const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 2297:{
        -: 2298:  jerry_assert_api_available ();
        -: 2299:
    #####: 2300:  if (!ecma_is_value_object (obj_val)
    #####: 2301:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2302:  {
    #####: 2303:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2304:  }
        -: 2305:
    #####: 2306:  jerry_value_t ret_value = ecma_op_object_get (ecma_get_object_from_value (obj_val),
        -: 2307:                                                ecma_get_prop_name_from_value (prop_name_val));
    #####: 2308:  return jerry_return (ret_value);
        -: 2309:} /* jerry_get_property */
        -: 2310:
        -: 2311:/**
        -: 2312: * Get value by an index from the specified object.
        -: 2313: *
        -: 2314: * Note:
        -: 2315: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2316: *
        -: 2317: * @return value of the property specified by the index - if success
        -: 2318: *         value marked with error flag - otherwise
        -: 2319: */
        -: 2320:jerry_value_t
    #####: 2321:jerry_get_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 2322:                             uint32_t index) /**< index to be written */
        -: 2323:{
        -: 2324:  jerry_assert_api_available ();
        -: 2325:
    #####: 2326:  if (!ecma_is_value_object (obj_val))
        -: 2327:  {
    #####: 2328:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2329:  }
        -: 2330:
    #####: 2331:  ecma_value_t ret_value = ecma_op_object_get_by_uint32_index (ecma_get_object_from_value (obj_val), index);
        -: 2332:
    #####: 2333:  return jerry_return (ret_value);
        -: 2334:} /* jerry_get_property_by_index */
        -: 2335:
        -: 2336:/**
        -: 2337: * Get value of an internal property to the specified object with the given name.
        -: 2338: *
        -: 2339: * Note:
        -: 2340: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2341: *
        -: 2342: * @return value of the internal property - if the internal property exists
        -: 2343: *         undefined value - if the internal does not property exists
        -: 2344: *         value marked with error flag - otherwise
        -: 2345: */
        -: 2346:jerry_value_t
    #####: 2347:jerry_get_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 2348:                             const jerry_value_t prop_name_val) /**< property name value */
        -: 2349:{
        -: 2350:  jerry_assert_api_available ();
        -: 2351:
    #####: 2352:  if (!ecma_is_value_object (obj_val)
    #####: 2353:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2354:  {
    #####: 2355:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2356:  }
        -: 2357:
    #####: 2358:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 2359:
    #####: 2360:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 2361:
    #####: 2362:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2363:  {
    #####: 2364:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 2365:  }
        -: 2366:
    #####: 2367:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 2368:
    #####: 2369:  if (property_p == NULL)
        -: 2370:  {
    #####: 2371:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 2372:  }
        -: 2373:
    #####: 2374:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 2375:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 2376:
    #####: 2377:  if (property_p == NULL)
        -: 2378:  {
    #####: 2379:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 2380:  }
        -: 2381:
    #####: 2382:  return jerry_return (ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -: 2383:} /* jerry_get_internal_property */
        -: 2384:
        -: 2385:/**
        -: 2386: * Set a property to the specified object with the given name.
        -: 2387: *
        -: 2388: * Note:
        -: 2389: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2390: *
        -: 2391: * @return true value - if the operation was successful
        -: 2392: *         value marked with error flag - otherwise
        -: 2393: */
        -: 2394:jerry_value_t
        4: 2395:jerry_set_property (const jerry_value_t obj_val, /**< object value */
        -: 2396:                    const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 2397:                    const jerry_value_t value_to_set) /**< value to set */
        -: 2398:{
        -: 2399:  jerry_assert_api_available ();
        -: 2400:
        4: 2401:  if (ecma_is_value_error_reference (value_to_set)
        4: 2402:      || !ecma_is_value_object (obj_val)
        4: 2403:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2404:  {
    #####: 2405:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2406:  }
        -: 2407:
        4: 2408:  return jerry_return (ecma_op_object_put (ecma_get_object_from_value (obj_val),
        -: 2409:                                           ecma_get_prop_name_from_value (prop_name_val),
        -: 2410:                                           value_to_set,
        -: 2411:                                           true));
        -: 2412:} /* jerry_set_property */
        -: 2413:
        -: 2414:/**
        -: 2415: * Set indexed value in the specified object
        -: 2416: *
        -: 2417: * Note:
        -: 2418: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2419: *
        -: 2420: * @return true value - if the operation was successful
        -: 2421: *         value marked with error flag - otherwise
        -: 2422: */
        -: 2423:jerry_value_t
    #####: 2424:jerry_set_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 2425:                             uint32_t index, /**< index to be written */
        -: 2426:                             const jerry_value_t value_to_set) /**< value to set */
        -: 2427:{
        -: 2428:  jerry_assert_api_available ();
        -: 2429:
    #####: 2430:  if (ecma_is_value_error_reference (value_to_set)
    #####: 2431:      || !ecma_is_value_object (obj_val))
        -: 2432:  {
    #####: 2433:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2434:  }
        -: 2435:
    #####: 2436:  ecma_value_t ret_value = ecma_op_object_put_by_uint32_index (ecma_get_object_from_value (obj_val),
        -: 2437:                                                               index,
        -: 2438:                                                               value_to_set,
        -: 2439:                                                               true);
        -: 2440:
    #####: 2441:  return jerry_return (ret_value);
        -: 2442:} /* jerry_set_property_by_index */
        -: 2443:
        -: 2444:/**
        -: 2445: * Set an internal property to the specified object with the given name.
        -: 2446: *
        -: 2447: * Note:
        -: 2448: *      - the property cannot be accessed from the JavaScript context, only from the public API
        -: 2449: *      - returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2450: *
        -: 2451: * @return true value - if the operation was successful
        -: 2452: *         value marked with error flag - otherwise
        -: 2453: */
        -: 2454:bool
    #####: 2455:jerry_set_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 2456:                             const jerry_value_t prop_name_val, /**< property name value */
        -: 2457:                             const jerry_value_t value_to_set) /**< value to set */
        -: 2458:{
        -: 2459:  jerry_assert_api_available ();
        -: 2460:
    #####: 2461:  if (ecma_is_value_error_reference (value_to_set)
    #####: 2462:      || !ecma_is_value_object (obj_val)
    #####: 2463:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2464:  {
    #####: 2465:    return false;
        -: 2466:  }
        -: 2467:
    #####: 2468:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 2469:
    #####: 2470:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 2471:
    #####: 2472:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2473:  {
    #####: 2474:    ecma_fast_array_convert_to_normal (obj_p);
        -: 2475:  }
        -: 2476:
    #####: 2477:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 2478:  ecma_object_t *internal_object_p;
        -: 2479:
    #####: 2480:  if (property_p == NULL)
        -: 2481:  {
    #####: 2482:    ecma_property_value_t *value_p = ecma_create_named_data_property (obj_p,
        -: 2483:                                                                      internal_string_p,
        -: 2484:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 2485:                                                                      NULL);
        -: 2486:
    #####: 2487:    internal_object_p = ecma_create_object (NULL,
        -: 2488:                                            sizeof (ecma_extended_object_t),
        -: 2489:                                            ECMA_OBJECT_TYPE_CLASS);
        -: 2490:    {
    #####: 2491:      ecma_extended_object_t *container_p = (ecma_extended_object_t *) internal_object_p;
    #####: 2492:      container_p->u.class_prop.class_id = LIT_INTERNAL_MAGIC_STRING_INTERNAL_OBJECT;
    #####: 2493:      container_p->u.class_prop.extra_info = 0;
    #####: 2494:      container_p->u.class_prop.u.length = 0;
        -: 2495:    }
        -: 2496:
    #####: 2497:    value_p->value = ecma_make_object_value (internal_object_p);
    #####: 2498:    ecma_deref_object (internal_object_p);
        -: 2499:  }
        -: 2500:  else
        -: 2501:  {
    #####: 2502:    internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 2503:  }
        -: 2504:
    #####: 2505:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (prop_name_val);
    #####: 2506:  property_p = ecma_find_named_property (internal_object_p, prop_name_p);
        -: 2507:
    #####: 2508:  if (property_p == NULL)
        -: 2509:  {
    #####: 2510:    ecma_property_value_t *value_p = ecma_create_named_data_property (internal_object_p,
        -: 2511:                                                                      prop_name_p,
        -: 2512:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 2513:                                                                      NULL);
        -: 2514:
    #####: 2515:    value_p->value = ecma_copy_value_if_not_object (value_to_set);
        -: 2516:  }
        -: 2517:  else
        -: 2518:  {
    #####: 2519:    ecma_named_data_property_assign_value (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p), value_to_set);
        -: 2520:  }
        -: 2521:
    #####: 2522:  return true;
        -: 2523:} /* jerry_set_internal_property */
        -: 2524:
        -: 2525:/**
        -: 2526: * Initialize property descriptor.
        -: 2527: */
        -: 2528:void
    #####: 2529:jerry_init_property_descriptor_fields (jerry_property_descriptor_t *prop_desc_p) /**< [out] property descriptor */
        -: 2530:{
    #####: 2531:  prop_desc_p->is_value_defined = false;
    #####: 2532:  prop_desc_p->value = ECMA_VALUE_UNDEFINED;
    #####: 2533:  prop_desc_p->is_writable_defined = false;
    #####: 2534:  prop_desc_p->is_writable = false;
    #####: 2535:  prop_desc_p->is_enumerable_defined = false;
    #####: 2536:  prop_desc_p->is_enumerable = false;
    #####: 2537:  prop_desc_p->is_configurable_defined = false;
    #####: 2538:  prop_desc_p->is_configurable = false;
    #####: 2539:  prop_desc_p->is_get_defined = false;
    #####: 2540:  prop_desc_p->getter = ECMA_VALUE_UNDEFINED;
    #####: 2541:  prop_desc_p->is_set_defined = false;
    #####: 2542:  prop_desc_p->setter = ECMA_VALUE_UNDEFINED;
    #####: 2543:} /* jerry_init_property_descriptor_fields */
        -: 2544:
        -: 2545:/**
        -: 2546: * Define a property to the specified object with the given name.
        -: 2547: *
        -: 2548: * Note:
        -: 2549: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2550: *
        -: 2551: * @return true value - if the operation was successful
        -: 2552: *         value marked with error flag - otherwise
        -: 2553: */
        -: 2554:jerry_value_t
    #####: 2555:jerry_define_own_property (const jerry_value_t obj_val, /**< object value */
        -: 2556:                           const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 2557:                           const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 2558:{
        -: 2559:  jerry_assert_api_available ();
        -: 2560:
    #####: 2561:  if (!ecma_is_value_object (obj_val)
    #####: 2562:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2563:  {
    #####: 2564:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2565:  }
        -: 2566:
    #####: 2567:  if ((prop_desc_p->is_writable_defined || prop_desc_p->is_value_defined)
    #####: 2568:      && (prop_desc_p->is_get_defined || prop_desc_p->is_set_defined))
        -: 2569:  {
    #####: 2570:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2571:  }
        -: 2572:
    #####: 2573:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -: 2574:
    #####: 2575:  uint32_t flags = ECMA_PROP_NO_OPTS;
        -: 2576:
    #####: 2577:  if (prop_desc_p->is_enumerable_defined)
        -: 2578:  {
    #####: 2579:    flags |= (uint32_t) (ECMA_PROP_IS_ENUMERABLE_DEFINED | (prop_desc_p->is_enumerable ? ECMA_PROP_IS_ENUMERABLE
        -: 2580:                                                                                       : ECMA_PROP_NO_OPTS));
        -: 2581:  }
        -: 2582:
    #####: 2583:  if (prop_desc_p->is_configurable_defined)
        -: 2584:  {
    #####: 2585:    flags |= (uint32_t) (ECMA_PROP_IS_CONFIGURABLE_DEFINED | (prop_desc_p->is_enumerable ? ECMA_PROP_IS_CONFIGURABLE
        -: 2586:                                                                                         : ECMA_PROP_NO_OPTS));
        -: 2587:  }
        -: 2588:
        -: 2589:  /* Copy data property info. */
    #####: 2590:  flags |= (prop_desc_p->is_value_defined ? ECMA_PROP_IS_VALUE_DEFINED : ECMA_PROP_NO_OPTS);
        -: 2591:
    #####: 2592:  if (prop_desc_p->is_value_defined)
        -: 2593:  {
    #####: 2594:    if (ecma_is_value_error_reference (prop_desc_p->value))
        -: 2595:    {
    #####: 2596:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2597:    }
        -: 2598:
    #####: 2599:    prop_desc.value = prop_desc_p->value;
        -: 2600:  }
        -: 2601:
    #####: 2602:  if (prop_desc_p->is_writable_defined)
        -: 2603:  {
    #####: 2604:    flags |= (uint32_t) (ECMA_PROP_IS_WRITABLE_DEFINED | (prop_desc_p->is_writable ? ECMA_PROP_IS_WRITABLE
        -: 2605:                                                                                   : ECMA_PROP_NO_OPTS));
        -: 2606:  }
        -: 2607:
        -: 2608:  /* Copy accessor property info. */
    #####: 2609:  if (prop_desc_p->is_get_defined)
        -: 2610:  {
    #####: 2611:    ecma_value_t getter = prop_desc_p->getter;
    #####: 2612:    flags |= ECMA_PROP_IS_GET_DEFINED;
        -: 2613:
    #####: 2614:    if (ecma_is_value_error_reference (getter))
        -: 2615:    {
    #####: 2616:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2617:    }
        -: 2618:
    #####: 2619:    if (ecma_op_is_callable (getter))
        -: 2620:    {
    #####: 2621:      prop_desc.get_p = ecma_get_object_from_value (getter);
        -: 2622:    }
    #####: 2623:    else if (!ecma_is_value_null (getter))
        -: 2624:    {
    #####: 2625:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2626:    }
        -: 2627:  }
        -: 2628:
    #####: 2629:  if (prop_desc_p->is_set_defined)
        -: 2630:  {
    #####: 2631:    ecma_value_t setter = prop_desc_p->setter;
    #####: 2632:    flags |= ECMA_PROP_IS_SET_DEFINED;
        -: 2633:
    #####: 2634:    if (ecma_is_value_error_reference (setter))
        -: 2635:    {
    #####: 2636:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2637:    }
        -: 2638:
    #####: 2639:    if (ecma_op_is_callable (setter))
        -: 2640:    {
    #####: 2641:      prop_desc.set_p = ecma_get_object_from_value (setter);
        -: 2642:    }
    #####: 2643:    else if (!ecma_is_value_null (setter))
        -: 2644:    {
    #####: 2645:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2646:    }
        -: 2647:  }
        -: 2648:
    #####: 2649:  prop_desc.flags |= (uint16_t) (flags | ECMA_PROP_IS_THROW);
        -: 2650:
    #####: 2651:  return ecma_op_object_define_own_property (ecma_get_object_from_value (obj_val),
        -: 2652:                                             ecma_get_prop_name_from_value (prop_name_val),
        -: 2653:                                             &prop_desc);
        -: 2654:} /* jerry_define_own_property */
        -: 2655:
        -: 2656:/**
        -: 2657: * Construct property descriptor from specified property.
        -: 2658: *
        -: 2659: * @return true - if success, the prop_desc_p fields contains the property info
        -: 2660: *         false - otherwise, the prop_desc_p is unchanged
        -: 2661: */
        -: 2662:bool
    #####: 2663:jerry_get_own_property_descriptor (const jerry_value_t  obj_val, /**< object value */
        -: 2664:                                   const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 2665:                                   jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 2666:{
        -: 2667:  jerry_assert_api_available ();
        -: 2668:
    #####: 2669:  if (!ecma_is_value_object (obj_val)
    #####: 2670:      || !ecma_is_value_prop_name (prop_name_val))
        -: 2671:  {
    #####: 2672:    return false;
        -: 2673:  }
        -: 2674:
    #####: 2675:  ecma_property_descriptor_t prop_desc;
        -: 2676:
    #####: 2677:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (ecma_get_object_from_value (obj_val),
        -: 2678:                                                                    ecma_get_prop_name_from_value (prop_name_val),
        -: 2679:                                                                    &prop_desc);
        -: 2680:
        -: 2681:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 2682:  if (ECMA_IS_VALUE_ERROR (status))
        -: 2683:  {
        -: 2684:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 2685:    jcontext_release_exception ();
        -: 2686:  }
        -: 2687:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 2688:
    #####: 2689:  if (!ecma_is_value_true (status))
        -: 2690:  {
    #####: 2691:    return false;
        -: 2692:  }
        -: 2693:
    #####: 2694:  prop_desc_p->is_configurable_defined = true;
    #####: 2695:  prop_desc_p->is_configurable = (prop_desc.flags & ECMA_PROP_IS_CONFIGURABLE) != 0;
    #####: 2696:  prop_desc_p->is_enumerable_defined = true;
    #####: 2697:  prop_desc_p->is_enumerable = (prop_desc.flags & ECMA_PROP_IS_ENUMERABLE) != 0;
        -: 2698:
    #####: 2699:  prop_desc_p->is_writable_defined = (prop_desc.flags & ECMA_PROP_IS_WRITABLE_DEFINED) != 0;
    #####: 2700:  prop_desc_p->is_writable = prop_desc_p->is_writable_defined ? (prop_desc.flags & ECMA_PROP_IS_WRITABLE) != 0 : false;
        -: 2701:
    #####: 2702:  prop_desc_p->is_value_defined = (prop_desc.flags & ECMA_PROP_IS_VALUE_DEFINED) != 0;
    #####: 2703:  prop_desc_p->is_get_defined = (prop_desc.flags & ECMA_PROP_IS_GET_DEFINED) != 0;
    #####: 2704:  prop_desc_p->is_set_defined = (prop_desc.flags & ECMA_PROP_IS_SET_DEFINED) != 0;
        -: 2705:
    #####: 2706:  prop_desc_p->value = ECMA_VALUE_UNDEFINED;
    #####: 2707:  prop_desc_p->getter = ECMA_VALUE_UNDEFINED;
    #####: 2708:  prop_desc_p->setter = ECMA_VALUE_UNDEFINED;
        -: 2709:
    #####: 2710:  if (prop_desc_p->is_value_defined)
        -: 2711:  {
    #####: 2712:    prop_desc_p->value = prop_desc.value;
        -: 2713:  }
        -: 2714:
    #####: 2715:  if (prop_desc_p->is_get_defined)
        -: 2716:  {
    #####: 2717:    if (prop_desc.get_p != NULL)
        -: 2718:    {
    #####: 2719:      prop_desc_p->getter = ecma_make_object_value (prop_desc.get_p);
        -: 2720:    }
        -: 2721:    else
        -: 2722:    {
    #####: 2723:      prop_desc_p->getter = ECMA_VALUE_NULL;
        -: 2724:    }
        -: 2725:  }
        -: 2726:
    #####: 2727:  if (prop_desc_p->is_set_defined)
        -: 2728:  {
    #####: 2729:    if (prop_desc.set_p != NULL)
        -: 2730:    {
    #####: 2731:      prop_desc_p->setter = ecma_make_object_value (prop_desc.set_p);
        -: 2732:    }
        -: 2733:    else
        -: 2734:    {
    #####: 2735:      prop_desc_p->setter = ECMA_VALUE_NULL;
        -: 2736:    }
        -: 2737:  }
        -: 2738:
    #####: 2739:  return true;
        -: 2740:} /* jerry_get_own_property_descriptor */
        -: 2741:
        -: 2742:/**
        -: 2743: * Free fields of property descriptor (setter, getter and value).
        -: 2744: */
        -: 2745:void
    #####: 2746:jerry_free_property_descriptor_fields (const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 2747:{
    #####: 2748:  if (prop_desc_p->is_value_defined)
        -: 2749:  {
    #####: 2750:    jerry_release_value (prop_desc_p->value);
        -: 2751:  }
        -: 2752:
    #####: 2753:  if (prop_desc_p->is_get_defined)
        -: 2754:  {
    #####: 2755:    jerry_release_value (prop_desc_p->getter);
        -: 2756:  }
        -: 2757:
    #####: 2758:  if (prop_desc_p->is_set_defined)
        -: 2759:  {
    #####: 2760:    jerry_release_value (prop_desc_p->setter);
        -: 2761:  }
    #####: 2762:} /* jerry_free_property_descriptor_fields */
        -: 2763:
        -: 2764:/**
        -: 2765: * Invoke function specified by a function value
        -: 2766: *
        -: 2767: * Note:
        -: 2768: *      - returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2769: *      - If function is invoked as constructor, it should support [[Construct]] method,
        -: 2770: *        otherwise, if function is simply called - it should support [[Call]] method.
        -: 2771: *
        -: 2772: * @return returned jerry value of the invoked function
        -: 2773: */
        -: 2774:static jerry_value_t
    #####: 2775:jerry_invoke_function (bool is_invoke_as_constructor, /**< true - invoke function as constructor
        -: 2776:                                                       *          (this_arg_p should be NULL, as it is ignored),
        -: 2777:                                                       *   false - perform function call */
        -: 2778:                       const jerry_value_t func_obj_val, /**< function object to call */
        -: 2779:                       const jerry_value_t this_val, /**< object value of 'this' binding */
        -: 2780:                       const jerry_value_t args_p[], /**< function's call arguments */
        -: 2781:                       const jerry_size_t args_count) /**< number of the arguments */
        -: 2782:{
    #####: 2783:  JERRY_ASSERT (args_count == 0 || args_p != NULL);
        -: 2784:
    #####: 2785:  if (ecma_is_value_error_reference (func_obj_val)
    #####: 2786:      || ecma_is_value_error_reference (this_val))
        -: 2787:  {
    #####: 2788:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 2789:  }
        -: 2790:
    #####: 2791:  for (uint32_t i = 0; i < args_count; i++)
        -: 2792:  {
    #####: 2793:    if (ecma_is_value_error_reference (args_p[i]))
        -: 2794:    {
    #####: 2795:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 2796:    }
        -: 2797:  }
        -: 2798:
    #####: 2799:  if (is_invoke_as_constructor)
        -: 2800:  {
    #####: 2801:    JERRY_ASSERT (jerry_value_is_constructor (func_obj_val));
        -: 2802:
    #####: 2803:    return jerry_return (ecma_op_function_construct (ecma_get_object_from_value (func_obj_val),
        -: 2804:                                                     ecma_get_object_from_value (func_obj_val),
        -: 2805:                                                     args_p,
        -: 2806:                                                     args_count));
        -: 2807:  }
        -: 2808:  else
        -: 2809:  {
    #####: 2810:    JERRY_ASSERT (jerry_value_is_function (func_obj_val));
        -: 2811:
    #####: 2812:    return jerry_return (ecma_op_function_call (ecma_get_object_from_value (func_obj_val),
        -: 2813:                                                this_val,
        -: 2814:                                                args_p,
        -: 2815:                                                args_count));
        -: 2816:  }
        -: 2817:} /* jerry_invoke_function */
        -: 2818:
        -: 2819:/**
        -: 2820: * Call function specified by a function value
        -: 2821: *
        -: 2822: * Note:
        -: 2823: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2824: *      error flag must not be set for any arguments of this function.
        -: 2825: *
        -: 2826: * @return returned jerry value of the called function
        -: 2827: */
        -: 2828:jerry_value_t
    #####: 2829:jerry_call_function (const jerry_value_t func_obj_val, /**< function object to call */
        -: 2830:                     const jerry_value_t this_val, /**< object for 'this' binding */
        -: 2831:                     const jerry_value_t args_p[], /**< function's call arguments */
        -: 2832:                     jerry_size_t args_count) /**< number of the arguments */
        -: 2833:{
        -: 2834:  jerry_assert_api_available ();
        -: 2835:
    #####: 2836:  if (jerry_value_is_function (func_obj_val) && !ecma_is_value_error_reference (this_val))
        -: 2837:  {
    #####: 2838:    for (jerry_size_t i = 0; i < args_count; i++)
        -: 2839:    {
    #####: 2840:      if (ecma_is_value_error_reference (args_p[i]))
        -: 2841:      {
    #####: 2842:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 2843:      }
        -: 2844:    }
        -: 2845:
    #####: 2846:    return jerry_invoke_function (false, func_obj_val, this_val, args_p, args_count);
        -: 2847:  }
        -: 2848:
    #####: 2849:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2850:} /* jerry_call_function */
        -: 2851:
        -: 2852:/**
        -: 2853: * Construct object value invoking specified function value as a constructor
        -: 2854: *
        -: 2855: * Note:
        -: 2856: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2857: *      error flag must not be set for any arguments of this function.
        -: 2858: *
        -: 2859: * @return returned jerry value of the invoked constructor
        -: 2860: */
        -: 2861:jerry_value_t
    #####: 2862:jerry_construct_object (const jerry_value_t func_obj_val, /**< function object to call */
        -: 2863:                        const jerry_value_t args_p[], /**< function's call arguments
        -: 2864:                                                       *   (NULL if arguments number is zero) */
        -: 2865:                        jerry_size_t args_count) /**< number of the arguments */
        -: 2866:{
        -: 2867:  jerry_assert_api_available ();
        -: 2868:
    #####: 2869:  if (jerry_value_is_constructor (func_obj_val))
        -: 2870:  {
    #####: 2871:    for (jerry_size_t i = 0; i < args_count; i++)
        -: 2872:    {
    #####: 2873:      if (ecma_is_value_error_reference (args_p[i]))
        -: 2874:      {
    #####: 2875:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 2876:      }
        -: 2877:    }
        -: 2878:
    #####: 2879:    ecma_value_t this_val = ECMA_VALUE_UNDEFINED;
    #####: 2880:    return jerry_invoke_function (true, func_obj_val, this_val, args_p, args_count);
        -: 2881:  }
        -: 2882:
    #####: 2883:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2884:} /* jerry_construct_object */
        -: 2885:
        -: 2886:/**
        -: 2887: * Get keys of the specified object value
        -: 2888: *
        -: 2889: * Note:
        -: 2890: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2891: *
        -: 2892: * @return array object value - if success
        -: 2893: *         value marked with error flag - otherwise
        -: 2894: */
        -: 2895:jerry_value_t
    #####: 2896:jerry_get_object_keys (const jerry_value_t obj_val) /**< object value */
        -: 2897:{
        -: 2898:  jerry_assert_api_available ();
        -: 2899:
    #####: 2900:  if (!ecma_is_value_object (obj_val))
        -: 2901:  {
    #####: 2902:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2903:  }
        -: 2904:
    #####: 2905:  return ecma_builtin_helper_object_get_properties (ecma_get_object_from_value (obj_val),
        -: 2906:                                                    ECMA_LIST_ENUMERABLE);
        -: 2907:} /* jerry_get_object_keys */
        -: 2908:
        -: 2909:/**
        -: 2910: * Get the prototype of the specified object
        -: 2911: *
        -: 2912: * Note:
        -: 2913: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2914: *
        -: 2915: * @return prototype object or null value - if success
        -: 2916: *         value marked with error flag - otherwise
        -: 2917: */
        -: 2918:jerry_value_t
    #####: 2919:jerry_get_prototype (const jerry_value_t obj_val) /**< object value */
        -: 2920:{
        -: 2921:  jerry_assert_api_available ();
        -: 2922:
    #####: 2923:  if (!ecma_is_value_object (obj_val))
        -: 2924:  {
    #####: 2925:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2926:  }
        -: 2927:
    #####: 2928:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 2929:
        -: 2930:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 2931:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 2932:  {
    #####: 2933:    return jerry_return (ecma_proxy_object_get_prototype_of (obj_p));
        -: 2934:  }
        -: 2935:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 2936:
    #####: 2937:  if (obj_p->u2.prototype_cp == JMEM_CP_NULL)
        -: 2938:  {
    #####: 2939:    return ECMA_VALUE_NULL;
        -: 2940:  }
        -: 2941:
    #####: 2942:  ecma_object_t *proto_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);
    #####: 2943:  ecma_ref_object (proto_obj_p);
        -: 2944:
    #####: 2945:  return ecma_make_object_value (proto_obj_p);
        -: 2946:} /* jerry_get_prototype */
        -: 2947:
        -: 2948:/**
        -: 2949: * Set the prototype of the specified object
        -: 2950: *
        -: 2951: * @return true value - if success
        -: 2952: *         value marked with error flag - otherwise
        -: 2953: */
        -: 2954:jerry_value_t
    #####: 2955:jerry_set_prototype (const jerry_value_t obj_val, /**< object value */
        -: 2956:                     const jerry_value_t proto_obj_val) /**< prototype object value */
        -: 2957:{
        -: 2958:  jerry_assert_api_available ();
        -: 2959:
    #####: 2960:  if (!ecma_is_value_object (obj_val)
    #####: 2961:      || ecma_is_value_error_reference (proto_obj_val)
    #####: 2962:      || (!ecma_is_value_object (proto_obj_val) && !ecma_is_value_null (proto_obj_val)))
        -: 2963:  {
    #####: 2964:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 2965:  }
    #####: 2966:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 2967:
        -: 2968:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 2969:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 2970:  {
    #####: 2971:    return jerry_return (ecma_proxy_object_set_prototype_of (obj_p, proto_obj_val));
        -: 2972:  }
        -: 2973:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 2974:
    #####: 2975:  return ecma_op_ordinary_object_set_prototype_of (obj_p, proto_obj_val);
        -: 2976:} /* jerry_set_prototype */
        -: 2977:
        -: 2978:/**
        -: 2979: * Utility to check if a given object can be used for the foreach api calls.
        -: 2980: *
        -: 2981: * Some objects/classes uses extra internal objects to correctly store data.
        -: 2982: * These extre object should never be exposed externally to the API user.
        -: 2983: *
        -: 2984: * @returns true - if the user can access the object in the callback.
        -: 2985: *          false - if the object is an internal object which should no be accessed by the user.
        -: 2986: */
        -: 2987:static
    #####: 2988:bool jerry_object_is_valid_foreach (ecma_object_t *object_p) /**< object to test */
        -: 2989:{
    #####: 2990:  if (ecma_is_lexical_environment (object_p))
        -: 2991:  {
    #####: 2992:    return false;
        -: 2993:  }
        -: 2994:
    #####: 2995:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 2996:
    #####: 2997:  if (object_type == ECMA_OBJECT_TYPE_CLASS)
        -: 2998:  {
    #####: 2999:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 3000:    switch (ext_object_p->u.class_prop.class_id)
        -: 3001:    {
        -: 3002:      /* An object's internal property object should not be iterable by foreach. */
    #####: 3003:      case LIT_INTERNAL_MAGIC_STRING_INTERNAL_OBJECT: return false;
        -: 3004:    }
        -: 3005:  }
        -: 3006:
    #####: 3007:  return true;
        -: 3008:} /* jerry_object_is_valid_foreach */
        -: 3009:
        -: 3010:/**
        -: 3011: * Traverse objects.
        -: 3012: *
        -: 3013: * @return true - traversal was interrupted by the callback.
        -: 3014: *         false - otherwise - traversal visited all objects.
        -: 3015: */
        -: 3016:bool
    #####: 3017:jerry_objects_foreach (jerry_objects_foreach_t foreach_p, /**< function pointer of the iterator function */
        -: 3018:                       void *user_data_p) /**< pointer to user data */
        -: 3019:{
        -: 3020:  jerry_assert_api_available ();
        -: 3021:
    #####: 3022:  JERRY_ASSERT (foreach_p != NULL);
        -: 3023:
    #####: 3024:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 3025:
    #####: 3026:  while (iter_cp != JMEM_CP_NULL)
        -: 3027:  {
    #####: 3028:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 3029:
    #####: 3030:    if (jerry_object_is_valid_foreach (iter_p)
    #####: 3031:        && !foreach_p (ecma_make_object_value (iter_p), user_data_p))
        -: 3032:    {
    #####: 3033:      return true;
        -: 3034:    }
        -: 3035:
    #####: 3036:    iter_cp = iter_p->gc_next_cp;
        -: 3037:  }
        -: 3038:
    #####: 3039:  return false;
        -: 3040:} /* jerry_objects_foreach */
        -: 3041:
        -: 3042:/**
        -: 3043: * Traverse objects having a given native type info.
        -: 3044: *
        -: 3045: * @return true - traversal was interrupted by the callback.
        -: 3046: *         false - otherwise - traversal visited all objects.
        -: 3047: */
        -: 3048:bool
    #####: 3049:jerry_objects_foreach_by_native_info (const jerry_object_native_info_t *native_info_p, /**< the type info
        -: 3050:                                                                                        *   of the native pointer */
        -: 3051:                                      jerry_objects_foreach_by_native_info_t foreach_p, /**< function to apply for
        -: 3052:                                                                                         *   each matching object */
        -: 3053:                                      void *user_data_p) /**< pointer to user data */
        -: 3054:{
        -: 3055:  jerry_assert_api_available ();
        -: 3056:
    #####: 3057:  JERRY_ASSERT (native_info_p != NULL);
    #####: 3058:  JERRY_ASSERT (foreach_p != NULL);
        -: 3059:
        -: 3060:  ecma_native_pointer_t *native_pointer_p;
        -: 3061:
    #####: 3062:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 3063:
    #####: 3064:  while (iter_cp != JMEM_CP_NULL)
        -: 3065:  {
    #####: 3066:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 3067:
    #####: 3068:    if (jerry_object_is_valid_foreach (iter_p))
        -: 3069:    {
    #####: 3070:      native_pointer_p = ecma_get_native_pointer_value (iter_p, (void *) native_info_p);
    #####: 3071:      if (native_pointer_p
    #####: 3072:          && !foreach_p (ecma_make_object_value (iter_p), native_pointer_p->data_p, user_data_p))
        -: 3073:      {
    #####: 3074:        return true;
        -: 3075:      }
        -: 3076:    }
        -: 3077:
    #####: 3078:    iter_cp = iter_p->gc_next_cp;
        -: 3079:  }
        -: 3080:
    #####: 3081:  return false;
        -: 3082:} /* jerry_objects_foreach_by_native_info */
        -: 3083:
        -: 3084:/**
        -: 3085: * Get native pointer and its type information, associated with the given native type info.
        -: 3086: *
        -: 3087: * Note:
        -: 3088: *  If native pointer is present, its type information is returned in out_native_pointer_p
        -: 3089: *
        -: 3090: * @return true - if there is an associated pointer,
        -: 3091: *         false - otherwise
        -: 3092: */
        -: 3093:bool
    #####: 3094:jerry_get_object_native_pointer (const jerry_value_t obj_val, /**< object to get native pointer from */
        -: 3095:                                 void **out_native_pointer_p, /**< [out] native pointer */
        -: 3096:                                 const jerry_object_native_info_t *native_info_p) /**< the type info
        -: 3097:                                                                                   *   of the native pointer */
        -: 3098:{
        -: 3099:  jerry_assert_api_available ();
        -: 3100:
    #####: 3101:  if (!ecma_is_value_object (obj_val))
        -: 3102:  {
    #####: 3103:    return false;
        -: 3104:  }
        -: 3105:
        -: 3106:  ecma_native_pointer_t *native_pointer_p;
    #####: 3107:  native_pointer_p = ecma_get_native_pointer_value (ecma_get_object_from_value (obj_val), (void *) native_info_p);
        -: 3108:
    #####: 3109:  if (native_pointer_p == NULL)
        -: 3110:  {
    #####: 3111:    return false;
        -: 3112:  }
        -: 3113:
    #####: 3114:  if (out_native_pointer_p != NULL)
        -: 3115:  {
    #####: 3116:    *out_native_pointer_p = native_pointer_p->data_p;
        -: 3117:  }
        -: 3118:
    #####: 3119:  return true;
        -: 3120:} /* jerry_get_object_native_pointer */
        -: 3121:
        -: 3122:/**
        -: 3123: * Set native pointer and an optional type info for the specified object.
        -: 3124: *
        -: 3125: *
        -: 3126: * Note:
        -: 3127: *      If native pointer was already set for the object, its value is updated.
        -: 3128: *
        -: 3129: * Note:
        -: 3130: *      If a non-NULL free callback is specified in the native type info,
        -: 3131: *      it will be called by the garbage collector when the object is freed.
        -: 3132: *      Referred values by this method must have at least 1 reference. (Correct API usage satisfies this condition)
        -: 3133: *      The type info always overwrites the previous value, so passing
        -: 3134: *      a NULL value deletes the current type info.
        -: 3135: */
        -: 3136:void
    #####: 3137:jerry_set_object_native_pointer (const jerry_value_t obj_val, /**< object to set native pointer in */
        -: 3138:                                 void *native_pointer_p, /**< native pointer */
        -: 3139:                                 const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 3140:{
        -: 3141:  jerry_assert_api_available ();
        -: 3142:
    #####: 3143:  if (ecma_is_value_object (obj_val))
        -: 3144:  {
    #####: 3145:    ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
        -: 3146:
    #####: 3147:    ecma_create_native_pointer_property (object_p, native_pointer_p, (void *) native_info_p);
        -: 3148:  }
    #####: 3149:} /* jerry_set_object_native_pointer */
        -: 3150:
        -: 3151:/**
        -: 3152: * Delete the previously set native pointer by the native type info from the specified object.
        -: 3153: *
        -: 3154: * Note:
        -: 3155: *      If the specified object has no matching native pointer for the given native type info
        -: 3156: *      the function has no effect.
        -: 3157: *
        -: 3158: * Note:
        -: 3159: *      This operation cannot throw an exception.
        -: 3160: *
        -: 3161: * @return true - if the native pointer has been deleted succesfully
        -: 3162: *         false - otherwise
        -: 3163: */
        -: 3164:bool
    #####: 3165:jerry_delete_object_native_pointer (const jerry_value_t obj_val, /**< object to delete native pointer from */
        -: 3166:                                    const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 3167:{
        -: 3168:  jerry_assert_api_available ();
        -: 3169:
    #####: 3170:  if (ecma_is_value_object (obj_val))
        -: 3171:  {
    #####: 3172:    ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
        -: 3173:
    #####: 3174:    return ecma_delete_native_pointer_property (object_p, (void *) native_info_p);
        -: 3175:  }
        -: 3176:
    #####: 3177:  return false;
        -: 3178:} /* jerry_delete_object_native_pointer */
        -: 3179:
        -: 3180:/**
        -: 3181: * Applies the given function to the every property in the object.
        -: 3182: *
        -: 3183: * @return true - if object fields traversal was performed successfully, i.e.:
        -: 3184: *                - no unhandled exceptions were thrown in object fields traversal;
        -: 3185: *                - object fields traversal was stopped on callback that returned false;
        -: 3186: *         false - otherwise,
        -: 3187: *                 if getter of field threw a exception or unhandled exceptions were thrown during traversal;
        -: 3188: */
        -: 3189:bool
    #####: 3190:jerry_foreach_object_property (const jerry_value_t obj_val, /**< object value */
        -: 3191:                               jerry_object_property_foreach_t foreach_p, /**< foreach function */
        -: 3192:                               void *user_data_p) /**< user data for foreach function */
        -: 3193:{
        -: 3194:  jerry_assert_api_available ();
        -: 3195:
    #####: 3196:  if (!ecma_is_value_object (obj_val))
        -: 3197:  {
    #####: 3198:    return false;
        -: 3199:  }
        -: 3200:
    #####: 3201:  ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
    #####: 3202:  ecma_collection_t *names_p = ecma_op_object_get_property_names (object_p, ECMA_LIST_ENUMERABLE_PROTOTYPE);
        -: 3203:
        -: 3204:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 3205:  if (names_p == NULL)
        -: 3206:  {
        -: 3207:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 3208:    jcontext_release_exception ();
    #####: 3209:    return false;
        -: 3210:  }
        -: 3211:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 3212:
    #####: 3213:  ecma_value_t *buffer_p = names_p->buffer_p;
        -: 3214:
    #####: 3215:  ecma_value_t property_value = ECMA_VALUE_EMPTY;
        -: 3216:
    #####: 3217:  bool continuous = true;
        -: 3218:
    #####: 3219:  for (uint32_t i = 0; continuous && (i < names_p->item_count); i++)
        -: 3220:  {
    #####: 3221:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 3222:
    #####: 3223:    property_value = ecma_op_object_get (object_p, property_name_p);
        -: 3224:
    #####: 3225:    if (ECMA_IS_VALUE_ERROR (property_value))
        -: 3226:    {
    #####: 3227:      break;
        -: 3228:    }
        -: 3229:
    #####: 3230:    continuous = foreach_p (buffer_p[i], property_value, user_data_p);
    #####: 3231:    ecma_free_value (property_value);
        -: 3232:  }
        -: 3233:
    #####: 3234:  ecma_collection_free (names_p);
        -: 3235:
    #####: 3236:  if (!ECMA_IS_VALUE_ERROR (property_value))
        -: 3237:  {
    #####: 3238:    return true;
        -: 3239:  }
        -: 3240:
    #####: 3241:  jcontext_release_exception ();
    #####: 3242:  return false;
        -: 3243:} /* jerry_foreach_object_property */
        -: 3244:
        -: 3245:/**
        -: 3246: * Resolve or reject the promise with an argument.
        -: 3247: *
        -: 3248: * @return undefined value - if success
        -: 3249: *         value marked with error flag - otherwise
        -: 3250: */
        -: 3251:jerry_value_t
    #####: 3252:jerry_resolve_or_reject_promise (jerry_value_t promise, /**< the promise value */
        -: 3253:                                 jerry_value_t argument, /**< the argument */
        -: 3254:                                 bool is_resolve) /**< whether the promise should be resolved or rejected */
        -: 3255:{
        -: 3256:  jerry_assert_api_available ();
        -: 3257:
        -: 3258:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
    #####: 3259:  if (!ecma_is_value_object (promise) || !ecma_is_promise (ecma_get_object_from_value (promise)))
        -: 3260:  {
    #####: 3261:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 3262:  }
        -: 3263:
    #####: 3264:  if (ecma_is_value_error_reference (argument))
        -: 3265:  {
    #####: 3266:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 3267:  }
        -: 3268:
    #####: 3269:  lit_magic_string_id_t prop_name = (is_resolve ? LIT_INTERNAL_MAGIC_STRING_RESOLVE_FUNCTION
    #####: 3270:                                                : LIT_INTERNAL_MAGIC_STRING_REJECT_FUNCTION);
        -: 3271:
    #####: 3272:  ecma_value_t function = ecma_op_object_get_by_magic_id (ecma_get_object_from_value (promise), prop_name);
        -: 3273:
    #####: 3274:  ecma_value_t ret = ecma_op_function_call (ecma_get_object_from_value (function),
        -: 3275:                                            ECMA_VALUE_UNDEFINED,
        -: 3276:                                            &argument,
        -: 3277:                                            1);
        -: 3278:
    #####: 3279:  ecma_free_value (function);
        -: 3280:
    #####: 3281:  return ret;
        -: 3282:#else /* !ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -: 3283:  JERRY_UNUSED (promise);
        -: 3284:  JERRY_UNUSED (argument);
        -: 3285:  JERRY_UNUSED (is_resolve);
        -: 3286:
    #####: 3287:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Promise not supported.")));
        -: 3288:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -: 3289:} /* jerry_resolve_or_reject_promise */
        -: 3290:
        -: 3291:/**
        -: 3292: * Get the result of a promise.
        -: 3293: *
        -: 3294: * @return - Promise result
        -: 3295: *         - Type error if the promise support was not enabled or the input was not a promise object
        -: 3296: */
        -: 3297:jerry_value_t
    #####: 3298:jerry_get_promise_result (const jerry_value_t promise) /**< promise object to get the result from */
        -: 3299:{
        -: 3300:  jerry_assert_api_available ();
        -: 3301:
        -: 3302:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
    #####: 3303:  if (!jerry_value_is_promise (promise))
        -: 3304:  {
    #####: 3305:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 3306:  }
        -: 3307:
    #####: 3308:  return ecma_promise_get_result (ecma_get_object_from_value (promise));
        -: 3309:#else /* !ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -: 3310:  JERRY_UNUSED (promise);
    #####: 3311:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Promise not supported.")));
        -: 3312:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -: 3313:} /* jerry_get_promise_result */
        -: 3314:
        -: 3315:/**
        -: 3316: * Get the state of a promise object.
        -: 3317: *
        -: 3318: * @return - the state of the promise (one of the jerry_promise_state_t enum values)
        -: 3319: *         - JERRY_PROMISE_STATE_NONE is only returned if the input is not a promise object
        -: 3320: *           or the promise support was not enabled.
        -: 3321: */
        -: 3322:jerry_promise_state_t
    #####: 3323:jerry_get_promise_state (const jerry_value_t promise) /**< promise object to get the state from */
        -: 3324:{
        -: 3325:  jerry_assert_api_available ();
        -: 3326:
        -: 3327:#if ENABLED (JERRY_ES2015_BUILTIN_PROMISE)
    #####: 3328:  if (!jerry_value_is_promise (promise))
        -: 3329:  {
    #####: 3330:    return JERRY_PROMISE_STATE_NONE;
        -: 3331:  }
        -: 3332:
    #####: 3333:  uint16_t flags = ecma_promise_get_flags (ecma_get_object_from_value (promise));
    #####: 3334:  flags &= (ECMA_PROMISE_IS_PENDING | ECMA_PROMISE_IS_FULFILLED);
        -: 3335:
    #####: 3336:  return (flags ? flags : JERRY_PROMISE_STATE_REJECTED);
        -: 3337:#else /* !ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -: 3338:  JERRY_UNUSED (promise);
    #####: 3339:  return JERRY_PROMISE_STATE_NONE;
        -: 3340:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROMISE) */
        -: 3341:} /* jerry_get_promise_state */
        -: 3342:
        -: 3343:/**
        -: 3344: * Call the SymbolDescriptiveString ecma builtin operation on the symbol value.
        -: 3345: *
        -: 3346: * Note:
        -: 3347: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3348: *
        -: 3349: * @return string value containing the symbol's descriptive string - if success
        -: 3350: *         thrown error - otherwise
        -: 3351: */
        -: 3352:jerry_value_t
    #####: 3353:jerry_get_symbol_descriptive_string (const jerry_value_t symbol) /**< symbol value */
        -: 3354:{
        -: 3355:  jerry_assert_api_available ();
        -: 3356:
        -: 3357:#if ENABLED (JERRY_ES2015)
    #####: 3358:  if (!ecma_is_value_symbol (symbol))
        -: 3359:  {
    #####: 3360:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 3361:  }
        -: 3362:
        -: 3363:  /* Note: This operation cannot throw an error */
    #####: 3364:  return ecma_get_symbol_descriptive_string (symbol);
        -: 3365:#else /* !ENABLED (JERRY_ES2015) */
        -: 3366:  JERRY_UNUSED (symbol);
        -: 3367:
    #####: 3368:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Symbol is not supported.")));
        -: 3369:#endif /* ENABLED (JERRY_ES2015) */
        -: 3370:} /** jerry_get_symbol_descriptive_string */
        -: 3371:
        -: 3372:/**
        -: 3373: * Validate UTF-8 string
        -: 3374: *
        -: 3375: * @return true - if UTF-8 string is well-formed
        -: 3376: *         false - otherwise
        -: 3377: */
        -: 3378:bool
        1: 3379:jerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */
        -: 3380:                            jerry_size_t buf_size) /**< string size */
        -: 3381:{
        1: 3382:  return lit_is_valid_utf8_string ((lit_utf8_byte_t *) utf8_buf_p,
        -: 3383:                                   (lit_utf8_size_t) buf_size);
        -: 3384:} /* jerry_is_valid_utf8_string */
        -: 3385:
        -: 3386:/**
        -: 3387: * Validate CESU-8 string
        -: 3388: *
        -: 3389: * @return true - if CESU-8 string is well-formed
        -: 3390: *         false - otherwise
        -: 3391: */
        -: 3392:bool
    #####: 3393:jerry_is_valid_cesu8_string (const jerry_char_t *cesu8_buf_p, /**< CESU-8 string */
        -: 3394:                             jerry_size_t buf_size) /**< string size */
        -: 3395:{
    #####: 3396:  return lit_is_valid_cesu8_string ((lit_utf8_byte_t *) cesu8_buf_p,
        -: 3397:                                    (lit_utf8_size_t) buf_size);
        -: 3398:} /* jerry_is_valid_cesu8_string */
        -: 3399:
        -: 3400:/**
        -: 3401: * Allocate memory on the engine's heap.
        -: 3402: *
        -: 3403: * Note:
        -: 3404: *      This function may take away memory from the executed JavaScript code.
        -: 3405: *      If any other dynamic memory allocation API is available (e.g., libc
        -: 3406: *      malloc), it should be used instead.
        -: 3407: *
        -: 3408: * @return allocated memory on success
        -: 3409: *         NULL otherwise
        -: 3410: */
        -: 3411:void *
    #####: 3412:jerry_heap_alloc (size_t size) /**< size of the memory block */
        -: 3413:{
        -: 3414:  jerry_assert_api_available ();
        -: 3415:
    #####: 3416:  return jmem_heap_alloc_block_null_on_error (size);
        -: 3417:} /* jerry_heap_alloc */
        -: 3418:
        -: 3419:/**
        -: 3420: * Free memory allocated on the engine's heap.
        -: 3421: */
        -: 3422:void
    #####: 3423:jerry_heap_free (void *mem_p, /**< value returned by jerry_heap_alloc */
        -: 3424:                 size_t size) /**< same size as passed to jerry_heap_alloc */
        -: 3425:{
        -: 3426:  jerry_assert_api_available ();
        -: 3427:
    #####: 3428:  jmem_heap_free_block (mem_p, size);
    #####: 3429:} /* jerry_heap_free */
        -: 3430:
        -: 3431:/**
        -: 3432: * Create an external engine context.
        -: 3433: *
        -: 3434: * @return the pointer to the context.
        -: 3435: */
        -: 3436:jerry_context_t *
    #####: 3437:jerry_create_context (uint32_t heap_size, /**< the size of heap */
        -: 3438:                      jerry_context_alloc_t alloc, /**< the alloc function */
        -: 3439:                      void *cb_data_p) /**< the cb_data for alloc function */
        -: 3440:{
        -: 3441:  JERRY_UNUSED (heap_size);
        -: 3442:
        -: 3443:#if ENABLED (JERRY_EXTERNAL_CONTEXT)
        -: 3444:
        -: 3445:  size_t total_size = sizeof (jerry_context_t) + JMEM_ALIGNMENT;
        -: 3446:
        -: 3447:#if !ENABLED (JERRY_SYSTEM_ALLOCATOR)
        -: 3448:  heap_size = JERRY_ALIGNUP (heap_size, JMEM_ALIGNMENT);
        -: 3449:
        -: 3450:  /* Minimum heap size is 1Kbyte. */
        -: 3451:  if (heap_size < 1024)
        -: 3452:  {
        -: 3453:    return NULL;
        -: 3454:  }
        -: 3455:
        -: 3456:  total_size += heap_size;
        -: 3457:#endif /* !ENABLED (JERRY_SYSTEM_ALLOCATOR) */
        -: 3458:
        -: 3459:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -: 3460:
        -: 3461:  jerry_context_t *context_p = (jerry_context_t *) alloc (total_size, cb_data_p);
        -: 3462:
        -: 3463:  if (context_p == NULL)
        -: 3464:  {
        -: 3465:    return NULL;
        -: 3466:  }
        -: 3467:
        -: 3468:  memset (context_p, 0, total_size);
        -: 3469:
        -: 3470:  uintptr_t context_ptr = ((uintptr_t) context_p) + sizeof (jerry_context_t);
        -: 3471:  context_ptr = JERRY_ALIGNUP (context_ptr, (uintptr_t) JMEM_ALIGNMENT);
        -: 3472:
        -: 3473:  uint8_t *byte_p = (uint8_t *) context_ptr;
        -: 3474:
        -: 3475:#if !ENABLED (JERRY_SYSTEM_ALLOCATOR)
        -: 3476:  context_p->heap_p = (jmem_heap_t *) byte_p;
        -: 3477:  context_p->heap_size = heap_size;
        -: 3478:  byte_p += heap_size;
        -: 3479:#endif /* !ENABLED (JERRY_SYSTEM_ALLOCATOR) */
        -: 3480:
        -: 3481:  JERRY_ASSERT (byte_p <= ((uint8_t *) context_p) + total_size);
        -: 3482:
        -: 3483:  JERRY_UNUSED (byte_p);
        -: 3484:  return context_p;
        -: 3485:
        -: 3486:#else /* !ENABLED (JERRY_EXTERNAL_CONTEXT) */
        -: 3487:
        -: 3488:  JERRY_UNUSED (alloc);
        -: 3489:  JERRY_UNUSED (cb_data_p);
        -: 3490:
    #####: 3491:  return NULL;
        -: 3492:
        -: 3493:#endif /* ENABLED (JERRY_EXTERNAL_CONTEXT) */
        -: 3494:} /* jerry_create_context */
        -: 3495:
        -: 3496:/**
        -: 3497: * If JERRY_VM_EXEC_STOP is enabled the callback passed to this function is
        -: 3498: * periodically called with the user_p argument. If frequency is greater
        -: 3499: * than 1, the callback is only called at every frequency ticks.
        -: 3500: */
        -: 3501:void
    #####: 3502:jerry_set_vm_exec_stop_callback (jerry_vm_exec_stop_callback_t stop_cb, /**< periodically called user function */
        -: 3503:                                 void *user_p, /**< pointer passed to the function */
        -: 3504:                                 uint32_t frequency) /**< frequency of the function call */
        -: 3505:{
        -: 3506:#if ENABLED (JERRY_VM_EXEC_STOP)
    #####: 3507:  if (frequency == 0)
        -: 3508:  {
    #####: 3509:    frequency = 1;
        -: 3510:  }
        -: 3511:
    #####: 3512:  JERRY_CONTEXT (vm_exec_stop_frequency) = frequency;
    #####: 3513:  JERRY_CONTEXT (vm_exec_stop_counter) = frequency;
    #####: 3514:  JERRY_CONTEXT (vm_exec_stop_user_p) = user_p;
    #####: 3515:  JERRY_CONTEXT (vm_exec_stop_cb) = stop_cb;
        -: 3516:#else /* !ENABLED (JERRY_VM_EXEC_STOP) */
        -: 3517:  JERRY_UNUSED (stop_cb);
        -: 3518:  JERRY_UNUSED (user_p);
        -: 3519:  JERRY_UNUSED (frequency);
        -: 3520:#endif /* ENABLED (JERRY_VM_EXEC_STOP) */
    #####: 3521:} /* jerry_set_vm_exec_stop_callback */
        -: 3522:
        -: 3523:/**
        -: 3524: * Get backtrace. The backtrace is an array of strings where
        -: 3525: * each string contains the position of the corresponding frame.
        -: 3526: * The array length is zero if the backtrace is not available.
        -: 3527: *
        -: 3528: * @return array value
        -: 3529: */
        -: 3530:jerry_value_t
    #####: 3531:jerry_get_backtrace (uint32_t max_depth) /**< depth limit of the backtrace */
        -: 3532:{
    #####: 3533:  return vm_get_backtrace (max_depth);
        -: 3534:} /* jerry_get_backtrace */
        -: 3535:
        -: 3536:/**
        -: 3537: * Get the resource name (usually a file name) of the currently executed script or the given function object
        -: 3538: *
        -: 3539: * Note: returned value must be freed with jerry_release_value, when it is no longer needed
        -: 3540: *
        -: 3541: * @return JS string constructed from
        -: 3542: *         - the currently executed function object's resource name, if the given value is undefined
        -: 3543: *         - resource name of the function object, if the given value is a function object
        -: 3544: *         - "<anonymous>", otherwise
        -: 3545: */
        -: 3546:jerry_value_t
    #####: 3547:jerry_get_resource_name (const jerry_value_t value) /**< jerry api value */
        -: 3548:{
        -: 3549:#if ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM)
    #####: 3550:  if (ecma_is_value_undefined (value))
        -: 3551:  {
    #####: 3552:    if (JERRY_CONTEXT (vm_top_context_p) != NULL)
        -: 3553:    {
    #####: 3554:      return ecma_copy_value (JERRY_CONTEXT (vm_top_context_p)->resource_name);
        -: 3555:    }
        -: 3556:  }
        -: 3557:#endif /* ENABLED (JERRY_LINE_INFO) || ENABLED (JERRY_ES2015_MODULE_SYSTEM) */
        -: 3558:#if ENABLED (JERRY_LINE_INFO)
    #####: 3559:  else if (ecma_is_value_object (value))
        -: 3560:  {
    #####: 3561:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 3562:
    #####: 3563:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION
    #####: 3564:        && !ecma_get_object_is_builtin (obj_p))
        -: 3565:    {
    #####: 3566:      ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) obj_p;
        -: 3567:
    #####: 3568:      const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);
        -: 3569:
    #####: 3570:      return ecma_copy_value (ecma_op_resource_name (bytecode_data_p));
        -: 3571:    }
        -: 3572:  }
        -: 3573:#endif /* ENABLED (JERRY_LINE_INFO) */
        -: 3574:
        -: 3575:  JERRY_UNUSED (value);
    #####: 3576:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -: 3577:} /* jerry_get_resource_name */
        -: 3578:
        -: 3579:/**
        -: 3580: * Access the "new.target" value.
        -: 3581: *
        -: 3582: * The "new.target" value depends on the current call site. That is
        -: 3583: * this method will only have a function object result if, at the call site
        -: 3584: * it was called inside a constructor method invoked with "new".
        -: 3585: *
        -: 3586: * @return "undefined" - if at the call site it was not a constructor call.
        -: 3587: *         function object - if the current call site is in a constructor call.
        -: 3588: */
        -: 3589:jerry_value_t
    #####: 3590:jerry_get_new_target (void)
        -: 3591:{
        -: 3592:#if ENABLED (JERRY_ES2015)
    #####: 3593:  ecma_object_t *current_new_target = JERRY_CONTEXT (current_new_target);
        -: 3594:
    #####: 3595:  if (current_new_target == NULL)
        -: 3596:  {
    #####: 3597:    return jerry_create_undefined ();
        -: 3598:  }
        -: 3599:
    #####: 3600:  ecma_ref_object (current_new_target);
    #####: 3601:  return ecma_make_object_value (current_new_target);
        -: 3602:#else /* !ENABLED (JERRY_ES2015) */
    #####: 3603:  return jerry_create_undefined ();
        -: 3604:#endif /* ENABLED (JERRY_ES2015) */
        -: 3605:} /* jerry_get_new_target */
        -: 3606:
        -: 3607:/**
        -: 3608: * Check if the given value is an ArrayBuffer object.
        -: 3609: *
        -: 3610: * @return true - if it is an ArrayBuffer object
        -: 3611: *         false - otherwise
        -: 3612: */
        -: 3613:bool
    #####: 3614:jerry_value_is_arraybuffer (const jerry_value_t value) /**< value to check if it is an ArrayBuffer */
        -: 3615:{
        -: 3616:  jerry_assert_api_available ();
        -: 3617:
        -: 3618:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 3619:  return ecma_is_arraybuffer (value);
        -: 3620:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3621:  JERRY_UNUSED (value);
    #####: 3622:  return false;
        -: 3623:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3624:} /* jerry_value_is_arraybuffer */
        -: 3625:
        -: 3626:/**
        -: 3627: * Creates an ArrayBuffer object with the given length (size).
        -: 3628: *
        -: 3629: * Notes:
        -: 3630: *      * the length is specified in bytes.
        -: 3631: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3632: *      * if the typed arrays are disabled this will return a TypeError.
        -: 3633: *
        -: 3634: * @return value of the constructed ArrayBuffer object
        -: 3635: */
        -: 3636:jerry_value_t
    #####: 3637:jerry_create_arraybuffer (const jerry_length_t size) /**< size of the ArrayBuffer to create */
        -: 3638:{
        -: 3639:  jerry_assert_api_available ();
        -: 3640:
        -: 3641:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 3642:  return jerry_return (ecma_make_object_value (ecma_arraybuffer_new_object (size)));
        -: 3643:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3644:  JERRY_UNUSED (size);
    #####: 3645:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer not supported.")));
        -: 3646:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3647:} /* jerry_create_arraybuffer */
        -: 3648:
        -: 3649:/**
        -: 3650: * Creates an ArrayBuffer object with user specified buffer.
        -: 3651: *
        -: 3652: * Notes:
        -: 3653: *     * the size is specified in bytes.
        -: 3654: *     * the buffer passed should be at least the specified bytes big.
        -: 3655: *     * if the typed arrays are disabled this will return a TypeError.
        -: 3656: *     * if the size is zero or buffer_p is a null pointer this will return an empty ArrayBuffer.
        -: 3657: *
        -: 3658: * @return value of the construced ArrayBuffer object
        -: 3659: */
        -: 3660:jerry_value_t
    #####: 3661:jerry_create_arraybuffer_external (const jerry_length_t size, /**< size of the buffer to used */
        -: 3662:                                   uint8_t *buffer_p, /**< buffer to use as the ArrayBuffer's backing */
        -: 3663:                                   jerry_object_native_free_callback_t free_cb) /**< buffer free callback */
        -: 3664:{
        -: 3665:  jerry_assert_api_available ();
        -: 3666:
        -: 3667:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -: 3668:  ecma_object_t *arraybuffer;
        -: 3669:
    #####: 3670:  if (JERRY_UNLIKELY (size == 0 || buffer_p == NULL))
        -: 3671:  {
    #####: 3672:    arraybuffer = ecma_arraybuffer_new_object_external (0, NULL, (ecma_object_native_free_callback_t) free_cb);
        -: 3673:  }
        -: 3674:  else
        -: 3675:  {
    #####: 3676:    arraybuffer = ecma_arraybuffer_new_object_external (size,
        -: 3677:                                                        buffer_p,
        -: 3678:                                                        (ecma_object_native_free_callback_t) free_cb);
        -: 3679:  }
        -: 3680:
    #####: 3681:  return jerry_return (ecma_make_object_value (arraybuffer));
        -: 3682:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3683:  JERRY_UNUSED (size);
        -: 3684:  JERRY_UNUSED (buffer_p);
        -: 3685:  JERRY_UNUSED (free_cb);
    #####: 3686:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer not supported.")));
        -: 3687:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3688:} /* jerry_create_arraybuffer_external */
        -: 3689:
        -: 3690:/**
        -: 3691: * Copy bytes into the ArrayBuffer from a buffer.
        -: 3692: *
        -: 3693: * Note:
        -: 3694: *     * if the object passed is not an ArrayBuffer will return 0.
        -: 3695: *
        -: 3696: * @return number of bytes copied into the ArrayBuffer.
        -: 3697: */
        -: 3698:jerry_length_t
    #####: 3699:jerry_arraybuffer_write (const jerry_value_t value, /**< target ArrayBuffer */
        -: 3700:                         jerry_length_t offset, /**< start offset of the ArrayBuffer */
        -: 3701:                         const uint8_t *buf_p, /**< buffer to copy from */
        -: 3702:                         jerry_length_t buf_size) /**< number of bytes to copy from the buffer */
        -: 3703:{
        -: 3704:  jerry_assert_api_available ();
        -: 3705:
        -: 3706:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 3707:  if (!ecma_is_arraybuffer (value))
        -: 3708:  {
    #####: 3709:    return 0;
        -: 3710:  }
        -: 3711:
    #####: 3712:  ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 3713:  jerry_length_t length = ecma_arraybuffer_get_length (buffer_p);
        -: 3714:
    #####: 3715:  if (offset >= length)
        -: 3716:  {
    #####: 3717:    return 0;
        -: 3718:  }
        -: 3719:
    #####: 3720:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 3721:
    #####: 3722:  if (copy_count > 0)
        -: 3723:  {
    #####: 3724:    lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
        -: 3725:
    #####: 3726:    memcpy ((void *) (mem_buffer_p + offset), (void *) buf_p, copy_count);
        -: 3727:  }
        -: 3728:
    #####: 3729:  return copy_count;
        -: 3730:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3731:  JERRY_UNUSED (value);
        -: 3732:  JERRY_UNUSED (offset);
        -: 3733:  JERRY_UNUSED (buf_p);
        -: 3734:  JERRY_UNUSED (buf_size);
    #####: 3735:  return 0;
        -: 3736:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3737:} /* jerry_arraybuffer_write */
        -: 3738:
        -: 3739:/**
        -: 3740: * Copy bytes from a buffer into an ArrayBuffer.
        -: 3741: *
        -: 3742: * Note:
        -: 3743: *     * if the object passed is not an ArrayBuffer will return 0.
        -: 3744: *
        -: 3745: * @return number of bytes read from the ArrayBuffer.
        -: 3746: */
        -: 3747:jerry_length_t
    #####: 3748:jerry_arraybuffer_read (const jerry_value_t value, /**< ArrayBuffer to read from */
        -: 3749:                        jerry_length_t offset, /**< start offset of the ArrayBuffer */
        -: 3750:                        uint8_t *buf_p, /**< destination buffer to copy to */
        -: 3751:                        jerry_length_t buf_size) /**< number of bytes to copy into the buffer */
        -: 3752:{
        -: 3753:  jerry_assert_api_available ();
        -: 3754:
        -: 3755:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 3756:  if (!ecma_is_arraybuffer (value))
        -: 3757:  {
    #####: 3758:    return 0;
        -: 3759:  }
        -: 3760:
    #####: 3761:  ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 3762:  jerry_length_t length = ecma_arraybuffer_get_length (buffer_p);
        -: 3763:
    #####: 3764:  if (offset >= length)
        -: 3765:  {
    #####: 3766:    return 0;
        -: 3767:  }
        -: 3768:
    #####: 3769:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 3770:
    #####: 3771:  if (copy_count > 0)
        -: 3772:  {
    #####: 3773:    lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
        -: 3774:
    #####: 3775:    memcpy ((void *) buf_p, (void *) (mem_buffer_p + offset), copy_count);
        -: 3776:  }
        -: 3777:
    #####: 3778:  return copy_count;
        -: 3779:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3780:  JERRY_UNUSED (value);
        -: 3781:  JERRY_UNUSED (offset);
        -: 3782:  JERRY_UNUSED (buf_p);
        -: 3783:  JERRY_UNUSED (buf_size);
    #####: 3784:  return 0;
        -: 3785:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3786:} /* jerry_arraybuffer_read */
        -: 3787:
        -: 3788:/**
        -: 3789: * Get the length (size) of the ArrayBuffer in bytes.
        -: 3790: *
        -: 3791: * Note:
        -: 3792: *     This is the 'byteLength' property of an ArrayBuffer.
        -: 3793: *
        -: 3794: * @return the length of the ArrayBuffer in bytes.
        -: 3795: */
        -: 3796:jerry_length_t
    #####: 3797:jerry_get_arraybuffer_byte_length (const jerry_value_t value) /**< ArrayBuffer */
        -: 3798:{
        -: 3799:  jerry_assert_api_available ();
        -: 3800:
        -: 3801:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 3802:  if (ecma_is_arraybuffer (value))
        -: 3803:  {
    #####: 3804:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 3805:    return ecma_arraybuffer_get_length (buffer_p);
        -: 3806:  }
        -: 3807:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3808:  JERRY_UNUSED (value);
        -: 3809:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
    #####: 3810:  return 0;
        -: 3811:} /* jerry_get_arraybuffer_byte_length */
        -: 3812:
        -: 3813:/**
        -: 3814: * Get a pointer for the start of the ArrayBuffer.
        -: 3815: *
        -: 3816: * Note:
        -: 3817: *    * This is a high-risk operation as the bounds are not checked
        -: 3818: *      when accessing the pointer elements.
        -: 3819: *
        -: 3820: * @return pointer to the back-buffer of the ArrayBuffer.
        -: 3821: *         pointer is NULL if the parameter is not an ArrayBuffer
        -: 3822: */
        -: 3823:uint8_t *
    #####: 3824:jerry_get_arraybuffer_pointer (const jerry_value_t array_buffer) /**< Array Buffer to use */
        -: 3825:{
        -: 3826:  jerry_assert_api_available ();
        -: 3827:
        -: 3828:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 3829:  if (ecma_is_value_error_reference (array_buffer)
    #####: 3830:      || !ecma_is_arraybuffer (array_buffer))
        -: 3831:  {
    #####: 3832:    return NULL;
        -: 3833:  }
        -: 3834:
    #####: 3835:  ecma_object_t *buffer_p = ecma_get_object_from_value (array_buffer);
    #####: 3836:  lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
    #####: 3837:  return (uint8_t *const) mem_buffer_p;
        -: 3838:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3839:  JERRY_UNUSED (array_buffer);
        -: 3840:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3841:
    #####: 3842:  return NULL;
        -: 3843:} /* jerry_get_arraybuffer_pointer */
        -: 3844:
        -: 3845:/**
        -: 3846: * Get if the ArrayBuffer is detachable.
        -: 3847: *
        -: 3848: * @return boolean value - if success
        -: 3849: *         value marked with error flag - otherwise
        -: 3850: */
        -: 3851:jerry_value_t
    #####: 3852:jerry_is_arraybuffer_detachable (const jerry_value_t value) /**< ArrayBuffer */
        -: 3853:{
        -: 3854:  jerry_assert_api_available ();
        -: 3855:
        -: 3856:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 3857:  if (ecma_is_arraybuffer (value))
        -: 3858:  {
    #####: 3859:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 3860:    return ecma_arraybuffer_is_detachable (buffer_p) ? ECMA_VALUE_TRUE : ECMA_VALUE_FALSE;
        -: 3861:  }
        -: 3862:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3863:  JERRY_UNUSED (value);
        -: 3864:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
    #####: 3865:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expects an ArrayBuffer")));
        -: 3866:} /* jerry_is_arraybuffer_detachable */
        -: 3867:
        -: 3868:/**
        -: 3869: * Detach the underlying data block from ArrayBuffer and set its bytelength to 0.
        -: 3870: * This operation requires the ArrayBuffer to be external that created by
        -: 3871: * `jerry_create_arraybuffer_external`.
        -: 3872: *
        -: 3873: * @return null value - if success
        -: 3874: *         value marked with error flag - otherwise
        -: 3875: */
        -: 3876:jerry_value_t
    #####: 3877:jerry_detach_arraybuffer (const jerry_value_t value) /**< ArrayBuffer */
        -: 3878:{
        -: 3879:  jerry_assert_api_available ();
        -: 3880:
        -: 3881:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 3882:  if (ecma_is_arraybuffer (value))
        -: 3883:  {
    #####: 3884:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 3885:    bool detached = ecma_arraybuffer_detach (buffer_p);
    #####: 3886:    if (!detached)
        -: 3887:    {
    #####: 3888:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expects a detachable ArrayBuffer.")));
        -: 3889:    }
    #####: 3890:    return ECMA_VALUE_NULL;
        -: 3891:  }
        -: 3892:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 3893:  JERRY_UNUSED (value);
        -: 3894:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
    #####: 3895:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expects an ArrayBuffer")));
        -: 3896:} /* jerry_detach_arraybuffer */
        -: 3897:
        -: 3898:/**
        -: 3899: * DataView related functions
        -: 3900: */
        -: 3901:
        -: 3902:/**
        -: 3903: * Creates a DataView object with the given ArrayBuffer, ByteOffset and ByteLength arguments.
        -: 3904: *
        -: 3905: * Notes:
        -: 3906: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3907: *      * if the DataView bulitin is disabled this will return a TypeError.
        -: 3908: *
        -: 3909: * @return value of the constructed DataView object - if success
        -: 3910: *         created error - otherwise
        -: 3911: */
        -: 3912:jerry_value_t
    #####: 3913:jerry_create_dataview (const jerry_value_t array_buffer, /**< arraybuffer to create DataView from */
        -: 3914:                       const jerry_length_t byte_offset, /**< offset in bytes, to the first byte in the buffer */
        -: 3915:                       const jerry_length_t byte_length) /**< number of elements in the byte array */
        -: 3916:{
        -: 3917:  jerry_assert_api_available ();
        -: 3918:
        -: 3919:#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)
    #####: 3920:  if (ecma_is_value_error_reference (array_buffer))
        -: 3921:  {
    #####: 3922:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 3923:  }
        -: 3924:
    #####: 3925:  ecma_value_t arguments_p[3] =
        -: 3926:  {
        -: 3927:    array_buffer,
    #####: 3928:    ecma_make_uint32_value (byte_offset),
    #####: 3929:    ecma_make_uint32_value (byte_length)
        -: 3930:  };
        -: 3931:
    #####: 3932:  return jerry_return (ecma_op_dataview_create (arguments_p, 3));
        -: 3933:#else /* !ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */
        -: 3934:  JERRY_UNUSED (array_buffer);
        -: 3935:  JERRY_UNUSED (byte_offset);
        -: 3936:  JERRY_UNUSED (byte_length);
    #####: 3937:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("DataView is not supported.")));
        -: 3938:#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW */
        -: 3939:} /* jerry_create_dataview */
        -: 3940:
        -: 3941:/**
        -: 3942: * Check if the given value is a DataView object.
        -: 3943: *
        -: 3944: * @return true - if it is a DataView object
        -: 3945: *         false - otherwise
        -: 3946: */
        -: 3947:bool
    #####: 3948:jerry_value_is_dataview (const jerry_value_t value) /**< value to check if it is a DataView object */
        -: 3949:{
        -: 3950:  jerry_assert_api_available ();
        -: 3951:
        -: 3952:#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)
    #####: 3953:  return ecma_is_dataview (value);
        -: 3954:#else /* !ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */
        -: 3955:  JERRY_UNUSED (value);
    #####: 3956:  return false;
        -: 3957:#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW */
        -: 3958:} /* jerry_value_is_dataview */
        -: 3959:
        -: 3960:/**
        -: 3961: * Get the underlying ArrayBuffer from a DataView.
        -: 3962: *
        -: 3963: * Additionally the byteLength and byteOffset properties are also returned
        -: 3964: * which were specified when the DataView was created.
        -: 3965: *
        -: 3966: * Note:
        -: 3967: *     the returned value must be freed with a jerry_release_value call
        -: 3968: *
        -: 3969: * @return ArrayBuffer of a DataView
        -: 3970: *         TypeError if the object is not a DataView.
        -: 3971: */
        -: 3972:jerry_value_t
    #####: 3973:jerry_get_dataview_buffer (const jerry_value_t value, /**< DataView to get the arraybuffer from */
        -: 3974:                           jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 3975:                           jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 3976:{
        -: 3977:  jerry_assert_api_available ();
        -: 3978:
        -: 3979:#if ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW)
    #####: 3980:  if (ecma_is_value_error_reference (value))
        -: 3981:  {
    #####: 3982:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (wrong_args_msg_p)));
        -: 3983:  }
        -: 3984:
    #####: 3985:  ecma_dataview_object_t *dataview_p = ecma_op_dataview_get_object (value);
        -: 3986:
    #####: 3987:  if (JERRY_UNLIKELY (dataview_p == NULL))
        -: 3988:  {
    #####: 3989:    return ecma_create_error_reference_from_context ();
        -: 3990:  }
        -: 3991:
    #####: 3992:  if (byte_offset != NULL)
        -: 3993:  {
    #####: 3994:    *byte_offset = dataview_p->byte_offset;
        -: 3995:  }
        -: 3996:
    #####: 3997:  if (byte_length != NULL)
        -: 3998:  {
    #####: 3999:    *byte_length = dataview_p->header.u.class_prop.u.length;
        -: 4000:  }
        -: 4001:
    #####: 4002:  ecma_object_t *arraybuffer_p = dataview_p->buffer_p;
    #####: 4003:  ecma_ref_object (arraybuffer_p);
        -: 4004:
    #####: 4005:  return ecma_make_object_value (arraybuffer_p);
        -: 4006:#else /* !ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW) */
        -: 4007:  JERRY_UNUSED (value);
        -: 4008:  JERRY_UNUSED (byte_offset);
        -: 4009:  JERRY_UNUSED (byte_length);
    #####: 4010:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("DataView is not supported.")));
        -: 4011:#endif /* ENABLED (JERRY_ES2015_BUILTIN_DATAVIEW */
        -: 4012:} /* jerry_get_dataview_buffer */
        -: 4013:
        -: 4014:/**
        -: 4015: * TypedArray related functions
        -: 4016: */
        -: 4017:
        -: 4018:/**
        -: 4019: * Check if the given value is a TypedArray object.
        -: 4020: *
        -: 4021: * @return true - if it is a TypedArray object
        -: 4022: *         false - otherwise
        -: 4023: */
        -: 4024:bool
    #####: 4025:jerry_value_is_typedarray (jerry_value_t value) /**< value to check if it is a TypedArray */
        -: 4026:{
        -: 4027:  jerry_assert_api_available ();
        -: 4028:
        -: 4029:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 4030:  return ecma_is_typedarray (value);
        -: 4031:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4032:  JERRY_UNUSED (value);
    #####: 4033:  return false;
        -: 4034:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4035:} /* jerry_value_is_typedarray */
        -: 4036:
        -: 4037:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -: 4038:/**
        -: 4039: * TypedArray mapping type
        -: 4040: */
        -: 4041:typedef struct
        -: 4042:{
        -: 4043:  jerry_typedarray_type_t api_type; /**< api type */
        -: 4044:  ecma_builtin_id_t prototype_id; /**< prototype ID */
        -: 4045:  ecma_typedarray_type_t id; /**< typedArray ID */
        -: 4046:  uint8_t element_size_shift; /**< element size shift */
        -: 4047:} jerry_typedarray_mapping_t;
        -: 4048:
        -: 4049:/**
        -: 4050: * List of TypedArray mappings
        -: 4051: */
        -: 4052:static jerry_typedarray_mapping_t jerry_typedarray_mappings[] =
        -: 4053:{
        -: 4054:#define TYPEDARRAY_ENTRY(NAME, LIT_NAME, SIZE_SHIFT) \
        -: 4055:  { JERRY_TYPEDARRAY_ ## NAME, ECMA_BUILTIN_ID_ ## NAME ## ARRAY_PROTOTYPE, \
        -: 4056:    ECMA_ ## LIT_NAME ## _ARRAY, SIZE_SHIFT }
        -: 4057:
        -: 4058:  TYPEDARRAY_ENTRY (UINT8, UINT8, 0),
        -: 4059:  TYPEDARRAY_ENTRY (UINT8CLAMPED, UINT8_CLAMPED, 0),
        -: 4060:  TYPEDARRAY_ENTRY (INT8, INT8, 0),
        -: 4061:  TYPEDARRAY_ENTRY (UINT16, UINT16, 1),
        -: 4062:  TYPEDARRAY_ENTRY (INT16, INT16, 1),
        -: 4063:  TYPEDARRAY_ENTRY (UINT32, UINT32, 2),
        -: 4064:  TYPEDARRAY_ENTRY (INT32, INT32, 2),
        -: 4065:  TYPEDARRAY_ENTRY (FLOAT32, FLOAT32, 2),
        -: 4066:#if ENABLED (JERRY_NUMBER_TYPE_FLOAT64)
        -: 4067:  TYPEDARRAY_ENTRY (FLOAT64, FLOAT64, 3),
        -: 4068:#endif /* ENABLED (JERRY_NUMBER_TYPE_FLOAT64) */
        -: 4069:
        -: 4070:#undef TYPEDARRAY_ENTRY
        -: 4071:};
        -: 4072:
        -: 4073:/**
        -: 4074: * Helper function to get the TypedArray prototype, typedArray id, and element size shift
        -: 4075: * information.
        -: 4076: *
        -: 4077: * @return true - if the TypedArray information was found
        -: 4078: *         false - if there is no such TypedArray type
        -: 4079: */
        -: 4080:static bool
    #####: 4081:jerry_typedarray_find_by_type (jerry_typedarray_type_t type_name, /**< type of the TypedArray */
        -: 4082:                               ecma_builtin_id_t *prototype_id, /**< [out] found prototype object id */
        -: 4083:                               ecma_typedarray_type_t *id, /**< [out] found typedArray id */
        -: 4084:                               uint8_t *element_size_shift) /**< [out] found element size shift value */
        -: 4085:{
    #####: 4086:  JERRY_ASSERT (prototype_id != NULL);
    #####: 4087:  JERRY_ASSERT (id != NULL);
    #####: 4088:  JERRY_ASSERT (element_size_shift != NULL);
        -: 4089:
    #####: 4090:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 4091:  {
    #####: 4092:    if (type_name == jerry_typedarray_mappings[i].api_type)
        -: 4093:    {
    #####: 4094:      *prototype_id = jerry_typedarray_mappings[i].prototype_id;
    #####: 4095:      *id = jerry_typedarray_mappings[i].id;
    #####: 4096:      *element_size_shift = jerry_typedarray_mappings[i].element_size_shift;
    #####: 4097:      return true;
        -: 4098:    }
        -: 4099:  }
        -: 4100:
    #####: 4101:  return false;
        -: 4102:} /* jerry_typedarray_find_by_type */
        -: 4103:
        -: 4104:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4105:
        -: 4106:/**
        -: 4107: * Create a TypedArray object with a given type and length.
        -: 4108: *
        -: 4109: * Notes:
        -: 4110: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 4111: *      * byteOffset property will be set to 0.
        -: 4112: *      * byteLength property will be a multiple of the length parameter (based on the type).
        -: 4113: *
        -: 4114: * @return - new TypedArray object
        -: 4115: */
        -: 4116:jerry_value_t
    #####: 4117:jerry_create_typedarray (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 4118:                         jerry_length_t length) /**< element count of the new TypedArray */
        -: 4119:{
        -: 4120:  jerry_assert_api_available ();
        -: 4121:
        -: 4122:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 4123:  ecma_builtin_id_t prototype_id = 0;
    #####: 4124:  ecma_typedarray_type_t id = 0;
    #####: 4125:  uint8_t element_size_shift = 0;
        -: 4126:
    #####: 4127:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 4128:  {
    #####: 4129:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("incorrect type for TypedArray.")));
        -: 4130:  }
        -: 4131:
    #####: 4132:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
        -: 4133:
    #####: 4134:  ecma_value_t array_value = ecma_typedarray_create_object_with_length (length,
        -: 4135:                                                                        NULL,
        -: 4136:                                                                        prototype_obj_p,
        -: 4137:                                                                        element_size_shift,
        -: 4138:                                                                        id);
        -: 4139:
    #####: 4140:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (array_value));
        -: 4141:
    #####: 4142:  return array_value;
        -: 4143:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4144:  JERRY_UNUSED (type_name);
        -: 4145:  JERRY_UNUSED (length);
    #####: 4146:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("TypedArray not supported.")));
        -: 4147:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4148:} /* jerry_create_typedarray */
        -: 4149:
        -: 4150:/**
        -: 4151: * Create a TypedArray object using the given arraybuffer and size information.
        -: 4152: *
        -: 4153: * Notes:
        -: 4154: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 4155: *      * this is the 'new %TypedArray%(arraybuffer, byteOffset, length)' equivalent call.
        -: 4156: *
        -: 4157: * @return - new TypedArray object
        -: 4158: */
        -: 4159:jerry_value_t
    #####: 4160:jerry_create_typedarray_for_arraybuffer_sz (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 4161:                                            const jerry_value_t arraybuffer, /**< ArrayBuffer to use */
        -: 4162:                                            jerry_length_t byte_offset, /**< offset for the ArrayBuffer */
        -: 4163:                                            jerry_length_t length) /**< number of elements to use from ArrayBuffer */
        -: 4164:{
        -: 4165:  jerry_assert_api_available ();
        -: 4166:
        -: 4167:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 4168:  if (ecma_is_value_error_reference (arraybuffer))
        -: 4169:  {
    #####: 4170:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 4171:  }
        -: 4172:
    #####: 4173:  ecma_builtin_id_t prototype_id = 0;
    #####: 4174:  ecma_typedarray_type_t id = 0;
    #####: 4175:  uint8_t element_size_shift = 0;
        -: 4176:
    #####: 4177:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 4178:  {
    #####: 4179:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("incorrect type for TypedArray.")));
        -: 4180:  }
        -: 4181:
    #####: 4182:  if (!ecma_is_arraybuffer (arraybuffer))
        -: 4183:  {
    #####: 4184:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Argument is not an ArrayBuffer")));
        -: 4185:  }
        -: 4186:
    #####: 4187:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
    #####: 4188:  ecma_value_t arguments_p[3] =
        -: 4189:  {
        -: 4190:    arraybuffer,
    #####: 4191:    ecma_make_uint32_value (byte_offset),
    #####: 4192:    ecma_make_uint32_value (length)
        -: 4193:  };
        -: 4194:
    #####: 4195:  ecma_value_t array_value = ecma_op_create_typedarray (arguments_p, 3, prototype_obj_p, element_size_shift, id);
    #####: 4196:  ecma_free_value (arguments_p[1]);
    #####: 4197:  ecma_free_value (arguments_p[2]);
        -: 4198:
    #####: 4199:  return jerry_return (array_value);
        -: 4200:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4201:  JERRY_UNUSED (type_name);
        -: 4202:  JERRY_UNUSED (arraybuffer);
        -: 4203:  JERRY_UNUSED (byte_offset);
        -: 4204:  JERRY_UNUSED (length);
    #####: 4205:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("TypedArray not supported.")));
        -: 4206:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4207:} /* jerry_create_typedarray_for_arraybuffer_sz */
        -: 4208:
        -: 4209:/**
        -: 4210: * Create a TypedArray object using the given arraybuffer and size information.
        -: 4211: *
        -: 4212: * Notes:
        -: 4213: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 4214: *      * this is the 'new %TypedArray%(arraybuffer)' equivalent call.
        -: 4215: *
        -: 4216: * @return - new TypedArray object
        -: 4217: */
        -: 4218:jerry_value_t
    #####: 4219:jerry_create_typedarray_for_arraybuffer (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 4220:                                         const jerry_value_t arraybuffer) /**< ArrayBuffer to use */
        -: 4221:{
        -: 4222:  jerry_assert_api_available ();
        -: 4223:
        -: 4224:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 4225:  if (ecma_is_value_error_reference (arraybuffer))
        -: 4226:  {
    #####: 4227:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 4228:  }
        -: 4229:
    #####: 4230:  jerry_length_t byteLength = jerry_get_arraybuffer_byte_length (arraybuffer);
    #####: 4231:  return jerry_create_typedarray_for_arraybuffer_sz (type_name, arraybuffer, 0, byteLength);
        -: 4232:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4233:  JERRY_UNUSED (type_name);
        -: 4234:  JERRY_UNUSED (arraybuffer);
    #####: 4235:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("TypedArray not supported.")));
        -: 4236:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4237:} /* jerry_create_typedarray_for_arraybuffer */
        -: 4238:
        -: 4239:/**
        -: 4240: * Get the type of the TypedArray.
        -: 4241: *
        -: 4242: * @return - type of the TypedArray
        -: 4243: *         - JERRY_TYPEDARRAY_INVALID if the argument is not a TypedArray
        -: 4244: */
        -: 4245:jerry_typedarray_type_t
    #####: 4246:jerry_get_typedarray_type (jerry_value_t value) /**< object to get the TypedArray type */
        -: 4247:{
        -: 4248:  jerry_assert_api_available ();
        -: 4249:
        -: 4250:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 4251:  if (!ecma_is_typedarray (value))
        -: 4252:  {
    #####: 4253:    return JERRY_TYPEDARRAY_INVALID;
        -: 4254:  }
        -: 4255:
    #####: 4256:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 4257:  ecma_typedarray_type_t class_type = ecma_get_typedarray_id (array_p);
        -: 4258:
    #####: 4259:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 4260:  {
    #####: 4261:    if (class_type == jerry_typedarray_mappings[i].id)
        -: 4262:    {
    #####: 4263:      return jerry_typedarray_mappings[i].api_type;
        -: 4264:    }
        -: 4265:  }
        -: 4266:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4267:  JERRY_UNUSED (value);
        -: 4268:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4269:
    #####: 4270:  return JERRY_TYPEDARRAY_INVALID;
        -: 4271:} /* jerry_get_typedarray_type */
        -: 4272:
        -: 4273:/**
        -: 4274: * Get the element count of the TypedArray.
        -: 4275: *
        -: 4276: * @return length of the TypedArray.
        -: 4277: */
        -: 4278:jerry_length_t
    #####: 4279:jerry_get_typedarray_length (jerry_value_t value) /**< TypedArray to query */
        -: 4280:{
        -: 4281:  jerry_assert_api_available ();
        -: 4282:
        -: 4283:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 4284:  if (ecma_is_typedarray (value))
        -: 4285:  {
    #####: 4286:    ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 4287:    return ecma_typedarray_get_length (array_p);
        -: 4288:  }
        -: 4289:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4290:  JERRY_UNUSED (value);
        -: 4291:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4292:
    #####: 4293:  return 0;
        -: 4294:} /* jerry_get_typedarray_length */
        -: 4295:
        -: 4296:/**
        -: 4297: * Get the underlying ArrayBuffer from a TypedArray.
        -: 4298: *
        -: 4299: * Additionally the byteLength and byteOffset properties are also returned
        -: 4300: * which were specified when the TypedArray was created.
        -: 4301: *
        -: 4302: * Note:
        -: 4303: *     the returned value must be freed with a jerry_release_value call
        -: 4304: *
        -: 4305: * @return ArrayBuffer of a TypedArray
        -: 4306: *         TypeError if the object is not a TypedArray.
        -: 4307: */
        -: 4308:jerry_value_t
    #####: 4309:jerry_get_typedarray_buffer (jerry_value_t value, /**< TypedArray to get the arraybuffer from */
        -: 4310:                             jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 4311:                             jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 4312:{
        -: 4313:  jerry_assert_api_available ();
        -: 4314:
        -: 4315:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
    #####: 4316:  if (!ecma_is_typedarray (value))
        -: 4317:  {
    #####: 4318:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Object is not a TypedArray.")));
        -: 4319:  }
        -: 4320:
    #####: 4321:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 4322:  uint8_t shift = ecma_typedarray_get_element_size_shift (array_p);
        -: 4323:
    #####: 4324:  if (byte_length != NULL)
        -: 4325:  {
    #####: 4326:    *byte_length = (jerry_length_t) (ecma_typedarray_get_length (array_p) << shift);
        -: 4327:  }
        -: 4328:
    #####: 4329:  if (byte_offset != NULL)
        -: 4330:  {
    #####: 4331:    *byte_offset = (jerry_length_t) ecma_typedarray_get_offset (array_p);
        -: 4332:  }
        -: 4333:
    #####: 4334:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (array_p);
    #####: 4335:  ecma_ref_object (arraybuffer_p);
    #####: 4336:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 4337:#else /* !ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4338:  JERRY_UNUSED (value);
        -: 4339:  JERRY_UNUSED (byte_length);
        -: 4340:  JERRY_UNUSED (byte_offset);
    #####: 4341:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("TypedArray is not supported.")));
        -: 4342:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
        -: 4343:} /* jerry_get_typedarray_buffer */
        -: 4344:
        -: 4345:/**
        -: 4346: * Create an object from JSON
        -: 4347: *
        -: 4348: * Note:
        -: 4349: *      The returned value must be freed with jerry_release_value
        -: 4350: * @return jerry_value_t from json formated string or an error massage
        -: 4351: */
        -: 4352:jerry_value_t
    #####: 4353:jerry_json_parse (const jerry_char_t *string_p, /**< json string */
        -: 4354:                  jerry_size_t string_size) /**< json string size */
        -: 4355:{
        -: 4356:  jerry_assert_api_available ();
        -: 4357:
        -: 4358:#if ENABLED (JERRY_BUILTIN_JSON)
    #####: 4359:  ecma_value_t ret_value = ecma_builtin_json_parse_buffer (string_p, string_size);
        -: 4360:
    #####: 4361:  if (ecma_is_value_undefined (ret_value))
        -: 4362:  {
    #####: 4363:    ret_value = jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("JSON string parse error.")));
        -: 4364:  }
        -: 4365:
    #####: 4366:  return ret_value;
        -: 4367:#else /* !ENABLED (JERRY_BUILTIN_JSON) */
        -: 4368:  JERRY_UNUSED (string_p);
        -: 4369:  JERRY_UNUSED (string_size);
        -: 4370:
        -: 4371:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("The JSON has been disabled.")));
        -: 4372:#endif /* ENABLED (JERRY_BUILTIN_JSON) */
        -: 4373:} /* jerry_json_parse */
        -: 4374:
        -: 4375:/**
        -: 4376: * Create a Json formated string from an object
        -: 4377: *
        -: 4378: * Note:
        -: 4379: *      The returned value must be freed with jerry_release_value
        -: 4380: * @return json formated jerry_value_t or an error massage
        -: 4381: */
        -: 4382:jerry_value_t
    #####: 4383:jerry_json_stringify (const jerry_value_t object_to_stringify) /**< a jerry_object_t to stringify */
        -: 4384:{
        -: 4385:  jerry_assert_api_available ();
        -: 4386:#if ENABLED (JERRY_BUILTIN_JSON)
    #####: 4387:  ecma_value_t ret_value = ecma_builtin_json_string_from_object (object_to_stringify);
        -: 4388:
    #####: 4389:  if (ecma_is_value_error_reference (object_to_stringify))
        -: 4390:  {
    #####: 4391:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 4392:  }
        -: 4393:
    #####: 4394:  if (ecma_is_value_undefined (ret_value))
        -: 4395:  {
    #####: 4396:    ret_value = jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("JSON stringify error.")));
        -: 4397:  }
        -: 4398:
    #####: 4399:  return ret_value;
        -: 4400:#else /* ENABLED (JERRY_BUILTIN_JSON) */
        -: 4401:  JERRY_UNUSED (object_to_stringify);
        -: 4402:
        -: 4403:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("The JSON has been disabled.")));
        -: 4404:#endif /* ENABLED (JERRY_BUILTIN_JSON) */
        -: 4405:} /* jerry_json_stringify */
        -: 4406:
        -: 4407:/**
        -: 4408: * Create a container type specified in jerry_container_type_t.
        -: 4409: * The container can be created with a list of arguments, which will be passed to the container constructor to be
        -: 4410: * inserted to the container.
        -: 4411: *
        -: 4412: * Note:
        -: 4413: *      The returned value must be freed with jerry_release_value
        -: 4414: * @return jerry_value_t representing a container with the given type.
        -: 4415: */
        -: 4416:jerry_value_t
    #####: 4417:jerry_create_container (jerry_container_type_t container_type, /**< Type of the container */
        -: 4418:                        const jerry_value_t *arguments_list_p, /**< arguments list */
        -: 4419:                        jerry_length_t arguments_list_len) /**< Length of arguments list */
        -: 4420:{
        -: 4421:  jerry_assert_api_available ();
        -: 4422:
        -: 4423:#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)
    #####: 4424:  for (jerry_length_t i = 0; i < arguments_list_len; i++)
        -: 4425:  {
    #####: 4426:    if (ecma_is_value_error_reference (arguments_list_p[i]))
        -: 4427:    {
    #####: 4428:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (error_value_msg_p)));
        -: 4429:    }
        -: 4430:  }
        -: 4431:
        -: 4432:  lit_magic_string_id_t lit_id;
        -: 4433:  ecma_builtin_id_t proto_id;
        -: 4434:  ecma_builtin_id_t ctor_id;
        -: 4435:
    #####: 4436:  switch (container_type)
        -: 4437:  {
        -: 4438:#if ENABLED (JERRY_ES2015_BUILTIN_MAP)
    #####: 4439:    case JERRY_CONTAINER_TYPE_MAP:
        -: 4440:    {
    #####: 4441:      lit_id = LIT_MAGIC_STRING_MAP_UL;
    #####: 4442:      proto_id = ECMA_BUILTIN_ID_MAP_PROTOTYPE;
    #####: 4443:      ctor_id = ECMA_BUILTIN_ID_MAP;
    #####: 4444:      break;
        -: 4445:    }
        -: 4446:#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */
        -: 4447:#if ENABLED (JERRY_ES2015_BUILTIN_SET)
    #####: 4448:    case JERRY_CONTAINER_TYPE_SET:
        -: 4449:    {
    #####: 4450:      lit_id = LIT_MAGIC_STRING_SET_UL;
    #####: 4451:      proto_id = ECMA_BUILTIN_ID_SET_PROTOTYPE;
    #####: 4452:      ctor_id = ECMA_BUILTIN_ID_SET;
    #####: 4453:      break;
        -: 4454:    }
        -: 4455:#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */
        -: 4456:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)
    #####: 4457:    case JERRY_CONTAINER_TYPE_WEAKMAP:
        -: 4458:    {
    #####: 4459:      lit_id = LIT_MAGIC_STRING_WEAKMAP_UL;
    #####: 4460:      proto_id = ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE;
    #####: 4461:      ctor_id = ECMA_BUILTIN_ID_WEAKMAP;
    #####: 4462:      break;
        -: 4463:    }
        -: 4464:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */
        -: 4465:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
    #####: 4466:    case JERRY_CONTAINER_TYPE_WEAKSET:
        -: 4467:    {
    #####: 4468:      lit_id = LIT_MAGIC_STRING_WEAKSET_UL;
    #####: 4469:      proto_id = ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE;
    #####: 4470:      ctor_id = ECMA_BUILTIN_ID_WEAKSET;
    #####: 4471:      break;
        -: 4472:    }
        -: 4473:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
    #####: 4474:    default:
        -: 4475:    {
    #####: 4476:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Invalid container type.")));
        -: 4477:    }
        -: 4478:  }
    #####: 4479:  ecma_object_t * old_new_target_p = JERRY_CONTEXT (current_new_target);
        -: 4480:
    #####: 4481:  if (old_new_target_p == NULL)
        -: 4482:  {
    #####: 4483:    JERRY_CONTEXT (current_new_target) = ecma_builtin_get (ctor_id);
        -: 4484:  }
        -: 4485:
    #####: 4486:  ecma_value_t container_value = ecma_op_container_create (arguments_list_p,
        -: 4487:                                                           arguments_list_len,
        -: 4488:                                                           lit_id,
        -: 4489:                                                           proto_id);
        -: 4490:
    #####: 4491:  JERRY_CONTEXT (current_new_target) = old_new_target_p;
    #####: 4492:  return container_value;
        -: 4493:#else /* !ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */
        -: 4494:  JERRY_UNUSED (arguments_list_p);
        -: 4495:  JERRY_UNUSED (arguments_list_len);
        -: 4496:  JERRY_UNUSED (container_type);
    #####: 4497:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Containers are disabled.")));
        -: 4498:#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */
        -: 4499:} /* jerry_create_container */
        -: 4500:
        -: 4501:/**
        -: 4502: * Get the type of the given container object.
        -: 4503: *
        -: 4504: * @return Corresponding type to the given container object.
        -: 4505: */
        -: 4506:jerry_container_type_t
    #####: 4507:jerry_get_container_type (const jerry_value_t value) /**< the container object */
        -: 4508:{
        -: 4509:  jerry_assert_api_available ();
        -: 4510:
        -: 4511:#if ENABLED (JERRY_ES2015_BUILTIN_CONTAINER)
    #####: 4512:  if (ecma_is_value_object (value))
        -: 4513:  {
    #####: 4514:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 4515:
    #####: 4516:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_CLASS)
        -: 4517:    {
    #####: 4518:      uint16_t type = ((ecma_extended_object_t *) obj_p)->u.class_prop.class_id;
        -: 4519:
    #####: 4520:      switch (type)
        -: 4521:      {
        -: 4522:#if ENABLED (JERRY_ES2015_BUILTIN_MAP)
    #####: 4523:        case LIT_MAGIC_STRING_MAP_UL:
        -: 4524:        {
    #####: 4525:          return JERRY_CONTAINER_TYPE_MAP;
        -: 4526:        }
        -: 4527:#endif /* ENABLED (JERRY_ES2015_BUILTIN_MAP) */
        -: 4528:#if ENABLED (JERRY_ES2015_BUILTIN_SET)
    #####: 4529:        case LIT_MAGIC_STRING_SET_UL:
        -: 4530:        {
    #####: 4531:          return JERRY_CONTAINER_TYPE_SET;
        -: 4532:        }
        -: 4533:#endif /* ENABLED (JERRY_ES2015_BUILTIN_SET) */
        -: 4534:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP)
    #####: 4535:        case LIT_MAGIC_STRING_WEAKMAP_UL:
        -: 4536:        {
    #####: 4537:          return JERRY_CONTAINER_TYPE_WEAKMAP;
        -: 4538:        }
        -: 4539:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKMAP) */
        -: 4540:#if ENABLED (JERRY_ES2015_BUILTIN_WEAKSET)
    #####: 4541:        case LIT_MAGIC_STRING_WEAKSET_UL:
        -: 4542:        {
    #####: 4543:          return JERRY_CONTAINER_TYPE_WEAKSET;
        -: 4544:        }
        -: 4545:#endif /* ENABLED (JERRY_ES2015_BUILTIN_WEAKSET) */
    #####: 4546:        default:
        -: 4547:        {
    #####: 4548:          return JERRY_CONTAINER_TYPE_INVALID;
        -: 4549:        }
        -: 4550:      }
        -: 4551:    }
        -: 4552:  }
        -: 4553:
        -: 4554:#else /* !ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */
        -: 4555:  JERRY_UNUSED (value);
        -: 4556:#endif /* ENABLED (JERRY_ES2015_BUILTIN_CONTAINER) */
    #####: 4557:  return JERRY_CONTAINER_TYPE_INVALID;
        -: 4558:} /* jerry_get_container_type */
        -: 4559:
        -: 4560:/**
        -: 4561: * @}
        -: 4562: */
