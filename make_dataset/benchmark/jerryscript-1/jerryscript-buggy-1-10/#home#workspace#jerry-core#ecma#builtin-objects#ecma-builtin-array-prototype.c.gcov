        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-comparison.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "ecma-objects.h"
        -:   28:#include "ecma-string-object.h"
        -:   29:#include "lit-char-helpers.h"
        -:   30:#include "jrt.h"
        -:   31:
        -:   32:#if ENABLED (JERRY_BUILTIN_ARRAY)
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/**
        -:   38: * This object has a custom dispatch function.
        -:   39: */
        -:   40:#define BUILTIN_CUSTOM_DISPATCH
        -:   41:
        -:   42:/**
        -:   43: * List of built-in routine identifiers.
        -:   44: */
        -:   45:enum
        -:   46:{
        -:   47:  ECMA_ARRAY_PROTOTYPE_ROUTINE_START = ECMA_BUILTIN_ID__COUNT - 1,
        -:   48:  /* Note: these 2 routine ids must be in this order */
        -:   49:  ECMA_ARRAY_PROTOTYPE_TO_STRING,
        -:   50:  ECMA_ARRAY_PROTOTYPE_CONCAT,
        -:   51:  ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING,
        -:   52:  ECMA_ARRAY_PROTOTYPE_JOIN,
        -:   53:  ECMA_ARRAY_PROTOTYPE_POP,
        -:   54:  ECMA_ARRAY_PROTOTYPE_PUSH,
        -:   55:  ECMA_ARRAY_PROTOTYPE_REVERSE,
        -:   56:  ECMA_ARRAY_PROTOTYPE_SHIFT,
        -:   57:  ECMA_ARRAY_PROTOTYPE_SLICE,
        -:   58:  ECMA_ARRAY_PROTOTYPE_SORT,
        -:   59:  ECMA_ARRAY_PROTOTYPE_SPLICE,
        -:   60:  ECMA_ARRAY_PROTOTYPE_UNSHIFT,
        -:   61:  ECMA_ARRAY_PROTOTYPE_INDEX_OF,
        -:   62:  ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF,
        -:   63:  /* Note these 3 routines must be in this order */
        -:   64:  ECMA_ARRAY_PROTOTYPE_EVERY,
        -:   65:  ECMA_ARRAY_PROTOTYPE_SOME,
        -:   66:  ECMA_ARRAY_PROTOTYPE_FOR_EACH,
        -:   67:  ECMA_ARRAY_PROTOTYPE_MAP,
        -:   68:  ECMA_ARRAY_PROTOTYPE_FILTER,
        -:   69:  /* Note these 2 routines must be in this order */
        -:   70:  ECMA_ARRAY_PROTOTYPE_REDUCE,
        -:   71:  ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT,
        -:   72:  ECMA_ARRAY_PROTOTYPE_FIND,
        -:   73:  ECMA_ARRAY_PROTOTYPE_FIND_INDEX,
        -:   74:  ECMA_ARRAY_PROTOTYPE_ENTRIES,
        -:   75:  ECMA_ARRAY_PROTOTYPE_KEYS,
        -:   76:  ECMA_ARRAY_PROTOTYPE_SYMBOL_ITERATOR,
        -:   77:  ECMA_ARRAY_PROTOTYPE_FILL,
        -:   78:  ECMA_ARRAY_PROTOTYPE_COPY_WITHIN,
        -:   79:};
        -:   80:
        -:   81:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-array-prototype.inc.h"
        -:   82:#define BUILTIN_UNDERSCORED_ID array_prototype
        -:   83:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   84:
        -:   85:/** \addtogroup ecma ECMA
        -:   86: * @{
        -:   87: *
        -:   88: * \addtogroup ecmabuiltins
        -:   89: * @{
        -:   90: *
        -:   91: * \addtogroup arrayprototype ECMA Array.prototype object built-in
        -:   92: * @{
        -:   93: */
        -:   94:
        -:   95:/**
        -:   96: * Helper function to set an object's length property
        -:   97: *
        -:   98: * @return ecma value (return value of the [[Put]] method)
        -:   99: *         Calling ecma_free_value on the returned value is optional if it is not abrupt completion.
        -:  100: */
        -:  101:static ecma_value_t
    #####:  102:ecma_builtin_array_prototype_helper_set_length (ecma_object_t *object, /**< object*/
        -:  103:                                                ecma_number_t length) /**< new length */
        -:  104:{
    #####:  105:  ecma_value_t length_value = ecma_make_number_value (length);
    #####:  106:  ecma_value_t ret_value = ecma_op_object_put (object,
        -:  107:                                               ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -:  108:                                               length_value,
        -:  109:                                               true);
        -:  110:
    #####:  111:  ecma_free_value (length_value);
        -:  112:
    #####:  113:  JERRY_ASSERT (ecma_is_value_boolean (ret_value)
        -:  114:                || ecma_is_value_empty (ret_value)
        -:  115:                || ECMA_IS_VALUE_ERROR (ret_value));
    #####:  116:  return ret_value;
        -:  117:} /* ecma_builtin_array_prototype_helper_set_length */
        -:  118:
        -:  119:/**
        -:  120: * The Array.prototype object's 'toString' routine
        -:  121: *
        -:  122: * See also:
        -:  123: *          ECMA-262 v5, 15.4.4.2
        -:  124: *
        -:  125: * @return ecma value
        -:  126: *         Returned value must be freed with ecma_free_value.
        -:  127: */
        -:  128:static ecma_value_t
    #####:  129:ecma_builtin_array_prototype_object_to_string (ecma_value_t this_arg, /**< this argument */
        -:  130:                                               ecma_object_t *obj_p) /**< array object */
        -:  131:
        -:  132:{
        -:  133:  /* 2. */
    #####:  134:  ecma_value_t join_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_JOIN);
        -:  135:
    #####:  136:  if (ECMA_IS_VALUE_ERROR (join_value))
        -:  137:  {
    #####:  138:    return join_value;
        -:  139:  }
        -:  140:
    #####:  141:  if (!ecma_op_is_callable (join_value))
        -:  142:  {
        -:  143:    /* 3. */
    #####:  144:    ecma_free_value (join_value);
    #####:  145:    return ecma_builtin_helper_object_to_string (this_arg);
        -:  146:  }
        -:  147:
        -:  148:  /* 4. */
    #####:  149:  ecma_object_t *join_func_obj_p = ecma_get_object_from_value (join_value);
        -:  150:
    #####:  151:  ecma_value_t ret_value = ecma_op_function_call (join_func_obj_p, this_arg, NULL, 0);
        -:  152:
    #####:  153:  ecma_deref_object (join_func_obj_p);
        -:  154:
    #####:  155:  return ret_value;
        -:  156:} /* ecma_builtin_array_prototype_object_to_string */
        -:  157:
        -:  158:/**
        -:  159: * The Array.prototype object's 'toLocaleString' routine
        -:  160: *
        -:  161: * See also:
        -:  162: *          ECMA-262 v5, 15.4.4.3
        -:  163: *
        -:  164: * @return ecma value
        -:  165: *         Returned value must be freed with ecma_free_value.
        -:  166: */
        -:  167:static ecma_value_t
    #####:  168:ecma_builtin_array_prototype_object_to_locale_string (ecma_object_t *obj_p, /**< array object */
        -:  169:                                                      uint32_t length) /**< array object's length */
        -:  170:{
        -:  171:  /* 5. */
    #####:  172:  if (length == 0)
        -:  173:  {
    #####:  174:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  175:  }
        -:  176:
        -:  177:  /* 7-8. */
    #####:  178:  ecma_string_t *first_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, 0);
        -:  179:
    #####:  180:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  181:  {
    #####:  182:    return ECMA_VALUE_ERROR;
        -:  183:  }
        -:  184:
    #####:  185:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  186:  ecma_deref_ecma_string (first_string_p);
        -:  187:
        -:  188:  /* 9-10. */
    #####:  189:  for (uint32_t k = 1; k < length; k++)
        -:  190:  {
        -:  191:    /* 4. Implementation-defined: set the separator to a single comma character. */
    #####:  192:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
        -:  193:
    #####:  194:    ecma_string_t *next_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, k);
        -:  195:
    #####:  196:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  197:    {
    #####:  198:      ecma_stringbuilder_destroy (&builder);
    #####:  199:      return ECMA_VALUE_ERROR;
        -:  200:    }
        -:  201:
    #####:  202:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  203:    ecma_deref_ecma_string (next_string_p);
        -:  204:  }
        -:  205:
    #####:  206:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  207:} /* ecma_builtin_array_prototype_object_to_locale_string */
        -:  208:
        -:  209:/**
        -:  210: * The Array.prototype object's 'concat' routine
        -:  211: *
        -:  212: * See also:
        -:  213: *          ECMA-262 v5, 15.4.4.4
        -:  214: *
        -:  215: * @return ecma value
        -:  216: *         Returned value must be freed with ecma_free_value.
        -:  217: */
        -:  218:static ecma_value_t
    #####:  219:ecma_builtin_array_prototype_object_concat (const ecma_value_t args[], /**< arguments list */
        -:  220:                                            ecma_length_t args_number, /**< number of arguments */
        -:  221:                                            ecma_object_t *obj_p) /**< array object */
        -:  222:{
        -:  223:  /* 2. */
        -:  224:#if ENABLED (JERRY_ES2015)
    #####:  225:  ecma_value_t new_array = ecma_op_array_species_create (obj_p, 0);
        -:  226:
    #####:  227:  if (ECMA_IS_VALUE_ERROR (new_array))
        -:  228:  {
    #####:  229:    return new_array;
        -:  230:  }
        -:  231:#else /* !ENABLED (JERRY_ES2015) */
    #####:  232:  ecma_value_t new_array = ecma_op_create_array_object (NULL, 0, false);
    #####:  233:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_array));
        -:  234:#endif /* ENABLED (JERRY_ES2015) */
        -:  235:
    #####:  236:  ecma_object_t *new_array_p = ecma_get_object_from_value (new_array);
    #####:  237:  uint32_t new_length = 0;
        -:  238:
        -:  239:  /* 5.b - 5.c for this_arg */
    #####:  240:  ecma_value_t concat_this_value = ecma_builtin_helper_array_concat_value (new_array_p,
        -:  241:                                                                           &new_length,
        -:  242:                                                                           ecma_make_object_value (obj_p));
    #####:  243:  if (ECMA_IS_VALUE_ERROR (concat_this_value))
        -:  244:  {
    #####:  245:    ecma_deref_object (new_array_p);
    #####:  246:    return concat_this_value;
        -:  247:  }
        -:  248:
    #####:  249:  JERRY_ASSERT (ecma_is_value_empty (concat_this_value));
        -:  250:
        -:  251:  /* 5. */
    #####:  252:  for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -:  253:  {
    #####:  254:    ecma_value_t concat_value = ecma_builtin_helper_array_concat_value (new_array_p, &new_length, args[arg_index]);
        -:  255:
    #####:  256:    if (ECMA_IS_VALUE_ERROR (concat_value))
        -:  257:    {
    #####:  258:      ecma_deref_object (new_array_p);
    #####:  259:      return concat_value;
        -:  260:    }
        -:  261:
    #####:  262:    JERRY_ASSERT (ecma_is_value_empty (concat_value));
        -:  263:  }
        -:  264:
    #####:  265:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p,
        -:  266:                                                                                  ((ecma_number_t) new_length));
    #####:  267:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  268:  {
    #####:  269:    ecma_deref_object (new_array_p);
    #####:  270:    return set_length_value;
        -:  271:  }
        -:  272:
    #####:  273:  return new_array;
        -:  274:} /* ecma_builtin_array_prototype_object_concat */
        -:  275:
        -:  276:/**
        -:  277: * The Array.prototype.toString's separator creation routine
        -:  278: *
        -:  279: * See also:
        -:  280: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -:  281: *
        -:  282: * @return NULL - if the conversion fails
        -:  283: *         ecma_string_t * - otherwise
        -:  284: */
        -:  285:
        -:  286:static ecma_string_t *
    #####:  287:ecma_op_array_get_separator_string (ecma_value_t separator) /**< possible separator */
        -:  288:{
    #####:  289:  if (ecma_is_value_undefined (separator))
        -:  290:  {
    #####:  291:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -:  292:  }
        -:  293:
    #####:  294:  return ecma_op_to_string (separator);
        -:  295:} /* ecma_op_array_get_separator_string */
        -:  296:
        -:  297:/**
        -:  298: * The Array.prototype's 'toString' single element operation routine
        -:  299: *
        -:  300: * See also:
        -:  301: *          ECMA-262 v5.1, 15.4.4.2
        -:  302: *
        -:  303: * @return NULL - if the conversion fails
        -:  304: *         ecma_string_t * - otherwise
        -:  305: */
        -:  306:static ecma_string_t *
    #####:  307:ecma_op_array_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  308:                                      uint32_t index) /**< array index */
        -:  309:{
    #####:  310:  ecma_value_t index_value = ecma_op_object_get_by_uint32_index (obj_p, index);
        -:  311:
    #####:  312:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  313:  {
    #####:  314:    return NULL;
        -:  315:  }
        -:  316:
    #####:  317:  if (ecma_is_value_undefined (index_value)
    #####:  318:      || ecma_is_value_null (index_value))
        -:  319:  {
    #####:  320:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  321:  }
        -:  322:
    #####:  323:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -:  324:
    #####:  325:  ecma_free_value (index_value);
        -:  326:
    #####:  327:  return ret_str_p;
        -:  328:} /* ecma_op_array_get_to_string_at_index */
        -:  329:
        -:  330:/**
        -:  331: * The Array.prototype object's 'join' routine
        -:  332: *
        -:  333: * See also:
        -:  334: *          ECMA-262 v5, 15.4.4.5
        -:  335: *
        -:  336: * @return ecma value
        -:  337: *         Returned value must be freed with ecma_free_value.
        -:  338: */
        -:  339:static ecma_value_t
    #####:  340:ecma_builtin_array_prototype_join (ecma_value_t separator_arg, /**< separator argument */
        -:  341:                                   ecma_object_t *obj_p, /**< array object */
        -:  342:                                   uint32_t length) /**< array object's length */
        -:  343:{
        -:  344:  /* 4-5. */
    #####:  345:  ecma_string_t *separator_string_p = ecma_op_array_get_separator_string (separator_arg);
        -:  346:
    #####:  347:  if (JERRY_UNLIKELY (separator_string_p == NULL))
        -:  348:  {
    #####:  349:    return ECMA_VALUE_ERROR;
        -:  350:  }
        -:  351:
    #####:  352:  if (length == 0)
        -:  353:  {
        -:  354:    /* 6. */
    #####:  355:    ecma_deref_ecma_string (separator_string_p);
    #####:  356:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  357:  }
        -:  358:
        -:  359:  /* 7-8. */
    #####:  360:  ecma_string_t *first_string_p = ecma_op_array_get_to_string_at_index (obj_p, 0);
        -:  361:
    #####:  362:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  363:  {
    #####:  364:    ecma_deref_ecma_string (separator_string_p);
    #####:  365:    return ECMA_VALUE_ERROR;
        -:  366:  }
        -:  367:
    #####:  368:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  369:  ecma_deref_ecma_string (first_string_p);
        -:  370:
        -:  371:  /* 9-10. */
    #####:  372:  for (uint32_t k = 1; k < length; k++)
        -:  373:  {
        -:  374:    /* 10.a */
    #####:  375:    ecma_stringbuilder_append (&builder, separator_string_p);
        -:  376:
        -:  377:    /* 10.d */
    #####:  378:    ecma_string_t *next_string_p = ecma_op_array_get_to_string_at_index (obj_p, k);
        -:  379:
    #####:  380:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  381:    {
    #####:  382:      ecma_deref_ecma_string (separator_string_p);
    #####:  383:      ecma_stringbuilder_destroy (&builder);
    #####:  384:      return ECMA_VALUE_ERROR;
        -:  385:    }
        -:  386:
    #####:  387:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  388:    ecma_deref_ecma_string (next_string_p);
        -:  389:  }
        -:  390:
    #####:  391:  ecma_deref_ecma_string (separator_string_p);
    #####:  392:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  393:} /* ecma_builtin_array_prototype_join */
        -:  394:
        -:  395:/**
        -:  396: * The Array.prototype object's 'pop' routine
        -:  397: *
        -:  398: * See also:
        -:  399: *          ECMA-262 v5, 15.4.4.6
        -:  400: *
        -:  401: * @return ecma value
        -:  402: *         Returned value must be freed with ecma_free_value.
        -:  403: */
        -:  404:static ecma_value_t
    #####:  405:ecma_builtin_array_prototype_object_pop (ecma_object_t *obj_p, /**< array object */
        -:  406:                                         uint32_t len) /**< array object's length */
        -:  407:{
        -:  408:   /* 4. */
    #####:  409:  if (len == 0)
        -:  410:  {
        -:  411:    /* 4.a */
    #####:  412:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  413:
        -:  414:    /* 4.b */
    #####:  415:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  416:  }
        -:  417:
        -:  418:  /* 5.b */
    #####:  419:  len--;
    #####:  420:  ecma_value_t get_value = ecma_op_object_get_by_uint32_index (obj_p, len);
        -:  421:
    #####:  422:  if (ECMA_IS_VALUE_ERROR (get_value))
        -:  423:  {
    #####:  424:    return get_value;
        -:  425:  }
        -:  426:
    #####:  427:  if (ecma_op_object_is_fast_array (obj_p))
        -:  428:  {
    #####:  429:    if (!ecma_op_ordinary_object_is_extensible (obj_p))
        -:  430:    {
    #####:  431:      ecma_free_value (get_value);
    #####:  432:      return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid argument type."));
        -:  433:    }
        -:  434:
    #####:  435:    ecma_delete_fast_array_properties (obj_p, len);
        -:  436:
    #####:  437:    return get_value;
        -:  438:  }
        -:  439:
        -:  440:  /* 5.c */
    #####:  441:  ecma_value_t del_value = ecma_op_object_delete_by_uint32_index (obj_p, len, true);
        -:  442:
    #####:  443:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  444:  {
    #####:  445:    ecma_free_value (get_value);
    #####:  446:    return del_value;
        -:  447:  }
        -:  448:
    #####:  449:  ecma_free_value (del_value);
        -:  450:
        -:  451:  /* 5.d */
    #####:  452:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  453:
    #####:  454:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  455:  {
    #####:  456:    ecma_free_value (get_value);
    #####:  457:    return set_length_value;
        -:  458:  }
        -:  459:
    #####:  460:  return get_value;
        -:  461:} /* ecma_builtin_array_prototype_object_pop */
        -:  462:
        -:  463:/**
        -:  464: * The Array.prototype object's 'push' routine
        -:  465: *
        -:  466: * See also:
        -:  467: *          ECMA-262 v5, 15.4.4.7
        -:  468: *
        -:  469: * @return ecma value
        -:  470: *         Returned value must be freed with ecma_free_value.
        -:  471: */
        -:  472:static ecma_value_t
    #####:  473:ecma_builtin_array_prototype_object_push (const ecma_value_t *argument_list_p, /**< arguments list */
        -:  474:                                          ecma_length_t arguments_number, /**< number of arguments */
        -:  475:                                          ecma_object_t *obj_p, /**< array object */
        -:  476:                                          uint32_t length) /**< array object's length */
        -:  477:{
    #####:  478:  ecma_number_t n = (ecma_number_t) length;
        -:  479:
    #####:  480:  if (ecma_op_object_is_fast_array (obj_p))
        -:  481:  {
    #####:  482:    if (!ecma_op_ordinary_object_is_extensible (obj_p))
        -:  483:    {
    #####:  484:      return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid argument type."));
        -:  485:    }
        -:  486:
    #####:  487:    if ((ecma_number_t) (length + arguments_number) > UINT32_MAX)
        -:  488:    {
    #####:  489:      return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid array length"));
        -:  490:    }
        -:  491:
    #####:  492:    if (arguments_number == 0)
        -:  493:    {
    #####:  494:      return ecma_make_uint32_value (length);
        -:  495:    }
        -:  496:
    #####:  497:    uint32_t new_length = length + arguments_number;
    #####:  498:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####:  499:    ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length) + length;
        -:  500:
    #####:  501:    for (uint32_t index = 0; index < arguments_number; index++)
        -:  502:    {
    #####:  503:      buffer_p[index] = ecma_copy_value_if_not_object (argument_list_p[index]);
        -:  504:    }
        -:  505:
    #####:  506:    ext_obj_p->u.array.u.hole_count -= ECMA_FAST_ARRAY_HOLE_ONE * arguments_number;
        -:  507:
    #####:  508:    return ecma_make_uint32_value (new_length);
        -:  509:  }
        -:  510:
        -:  511:  /* 5. */
    #####:  512:  for (uint32_t index = 0; index < arguments_number; index++, n++)
        -:  513:  {
        -:  514:    /* 5.b */
    #####:  515:    ecma_value_t put_value = ecma_op_object_put_by_number_index (obj_p, n, argument_list_p[index], true);
        -:  516:
    #####:  517:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  518:    {
    #####:  519:      return put_value;
        -:  520:    }
        -:  521:  }
        -:  522:
        -:  523:  /* 6. */
    #####:  524:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, n);
        -:  525:
    #####:  526:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  527:  {
    #####:  528:    return set_length_value;
        -:  529:  }
        -:  530:
    #####:  531:  return ecma_make_number_value (n);
        -:  532:} /* ecma_builtin_array_prototype_object_push */
        -:  533:
        -:  534:/**
        -:  535: * The Array.prototype object's 'reverse' routine
        -:  536: *
        -:  537: * See also:
        -:  538: *          ECMA-262 v5, 15.4.4.8
        -:  539: *
        -:  540: * @return ecma value
        -:  541: *         Returned value must be freed with ecma_free_value.
        -:  542: */
        -:  543:static ecma_value_t
    #####:  544:ecma_builtin_array_prototype_object_reverse (ecma_value_t this_arg, /**< this argument */
        -:  545:                                             ecma_object_t *obj_p, /**< array object */
        -:  546:                                             uint32_t len) /**< array object's length */
        -:  547:{
    #####:  548:  uint32_t middle = len / 2;
        -:  549:
    #####:  550:  if (ecma_op_object_is_fast_array (obj_p))
        -:  551:  {
    #####:  552:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  553:
    #####:  554:    if (ext_obj_p->u.array.u.hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####:  555:        && len != 0
    #####:  556:        && ecma_op_ordinary_object_is_extensible (obj_p))
        -:  557:    {
    #####:  558:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  559:
    #####:  560:      for (uint32_t i = 0; i < middle; i++)
        -:  561:      {
    #####:  562:        ecma_value_t tmp = buffer_p[i];
    #####:  563:        buffer_p[i] = buffer_p[len - 1 - i];
    #####:  564:        buffer_p[len - 1 - i] = tmp;
        -:  565:      }
        -:  566:
    #####:  567:      return ecma_copy_value (this_arg);
        -:  568:    }
        -:  569:  }
        -:  570:
    #####:  571:  for (uint32_t lower = 0; lower < middle; lower++)
        -:  572:  {
    #####:  573:    uint32_t upper = len - lower - 1;
    #####:  574:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  575:
    #####:  576:    ecma_string_t *lower_str_p = ecma_new_ecma_string_from_uint32 (lower);
    #####:  577:    ecma_string_t *upper_str_p = ecma_new_ecma_string_from_uint32 (upper);
        -:  578:
        -:  579:#if ENABLED (JERRY_ES2015)
    #####:  580:    ecma_value_t lower_value = ECMA_VALUE_EMPTY;
    #####:  581:    ecma_value_t upper_value = ECMA_VALUE_EMPTY;
        -:  582:
    #####:  583:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
        -:  584:
        -:  585:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####:  586:    if (ECMA_IS_VALUE_ERROR (has_lower))
        -:  587:    {
    #####:  588:      goto clean_up;
        -:  589:    }
        -:  590:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -:  591:
    #####:  592:    bool lower_exist = ecma_is_value_true (has_lower);
        -:  593:
    #####:  594:    if (lower_exist)
        -:  595:    {
    #####:  596:      lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  597:
    #####:  598:      if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  599:      {
    #####:  600:        goto clean_up;
        -:  601:      }
        -:  602:    }
        -:  603:
    #####:  604:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  605:
        -:  606:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####:  607:    if (ECMA_IS_VALUE_ERROR (has_upper))
        -:  608:    {
    #####:  609:      goto clean_up;
        -:  610:    }
        -:  611:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -:  612:
    #####:  613:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  614:
    #####:  615:    if (upper_exist)
        -:  616:    {
    #####:  617:      upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  618:
    #####:  619:      if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  620:      {
    #####:  621:        goto clean_up;
        -:  622:      }
        -:  623:    }
        -:  624:#else /* !ENABLED (JERRY_ES2015) */
    #####:  625:    ecma_value_t lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  626:
    #####:  627:    if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  628:    {
    #####:  629:      ecma_deref_ecma_string (lower_str_p);
    #####:  630:      ecma_deref_ecma_string (upper_str_p);
    #####:  631:      return ret_value;
        -:  632:    }
        -:  633:
    #####:  634:    ecma_value_t upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  635:
    #####:  636:    if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  637:    {
    #####:  638:      goto clean_up;
        -:  639:    }
        -:  640:
    #####:  641:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
    #####:  642:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  643:
    #####:  644:    bool lower_exist = ecma_is_value_true (has_lower);
    #####:  645:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  646:#endif /* ENABLED (JERRY_ES2015) */
        -:  647:
    #####:  648:    if (lower_exist && upper_exist)
    #####:  649:    {
    #####:  650:      ecma_value_t outer_put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  651:
    #####:  652:      if (ECMA_IS_VALUE_ERROR (outer_put_value))
        -:  653:      {
    #####:  654:        goto clean_up;
        -:  655:      }
        -:  656:
    #####:  657:      ecma_value_t inner_put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  658:
    #####:  659:      if (ECMA_IS_VALUE_ERROR (inner_put_value))
        -:  660:      {
    #####:  661:        goto clean_up;
        -:  662:      }
        -:  663:    }
    #####:  664:    else if (!lower_exist && upper_exist)
    #####:  665:    {
    #####:  666:      ecma_value_t put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  667:
    #####:  668:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  669:      {
    #####:  670:        goto clean_up;
        -:  671:      }
        -:  672:
    #####:  673:      ecma_value_t del_value = ecma_op_object_delete (obj_p, upper_str_p, true);
        -:  674:
    #####:  675:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  676:      {
    #####:  677:        goto clean_up;
        -:  678:      }
        -:  679:    }
    #####:  680:    else if (lower_exist)
        -:  681:    {
    #####:  682:      ecma_value_t del_value = ecma_op_object_delete (obj_p, lower_str_p, true);
        -:  683:
    #####:  684:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  685:      {
    #####:  686:        goto clean_up;
        -:  687:      }
        -:  688:
    #####:  689:      ecma_value_t put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  690:
    #####:  691:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  692:      {
    #####:  693:        goto clean_up;
        -:  694:      }
        -:  695:    }
        -:  696:
    #####:  697:    ret_value = ECMA_VALUE_EMPTY;
        -:  698:
    #####:  699:clean_up:
    #####:  700:    ecma_free_value (upper_value);
    #####:  701:    ecma_free_value (lower_value);
    #####:  702:    ecma_deref_ecma_string (lower_str_p);
    #####:  703:    ecma_deref_ecma_string (upper_str_p);
        -:  704:
    #####:  705:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  706:    {
    #####:  707:      return ret_value;
        -:  708:    }
        -:  709:  }
        -:  710:
    #####:  711:  return ecma_copy_value (this_arg);
        -:  712:} /* ecma_builtin_array_prototype_object_reverse */
        -:  713:
        -:  714:/**
        -:  715: * The Array.prototype object's 'shift' routine
        -:  716: *
        -:  717: * See also:
        -:  718: *          ECMA-262 v5, 15.4.4.9
        -:  719: *
        -:  720: * @return ecma value
        -:  721: *         Returned value must be freed with ecma_free_value.
        -:  722: */
        -:  723:static ecma_value_t
    #####:  724:ecma_builtin_array_prototype_object_shift (ecma_object_t *obj_p, /**< array object */
        -:  725:                                           uint32_t len) /**< array object's length */
        -:  726:{
        -:  727:  /* 4. */
    #####:  728:  if (len == 0)
        -:  729:  {
    #####:  730:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  731:
    #####:  732:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  733:  }
        -:  734:
    #####:  735:  if (ecma_op_object_is_fast_array (obj_p))
        -:  736:  {
    #####:  737:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  738:
    #####:  739:    if (ext_obj_p->u.array.u.hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####:  740:        && len != 0
    #####:  741:        && ecma_op_ordinary_object_is_extensible (obj_p))
        -:  742:    {
    #####:  743:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
    #####:  744:      ecma_value_t ret_value = buffer_p[0];
        -:  745:
    #####:  746:      if (ecma_is_value_object (ret_value))
        -:  747:      {
    #####:  748:        ecma_ref_object (ecma_get_object_from_value (ret_value));
        -:  749:      }
        -:  750:
    #####:  751:      memmove (buffer_p, buffer_p + 1, sizeof (ecma_value_t) * (len - 1));
        -:  752:
    #####:  753:      buffer_p[len - 1] = ECMA_VALUE_UNDEFINED;
    #####:  754:      ecma_delete_fast_array_properties (obj_p, len - 1);
        -:  755:
    #####:  756:      return ret_value;
        -:  757:    }
        -:  758:  }
        -:  759:
        -:  760:  /* 5. */
    #####:  761:  ecma_value_t first_value = ecma_op_object_get_by_uint32_index (obj_p, 0);
        -:  762:
    #####:  763:  if (ECMA_IS_VALUE_ERROR (first_value))
        -:  764:  {
    #####:  765:    return first_value;
        -:  766:  }
        -:  767:
        -:  768:  /* 6. and 7. */
    #####:  769:  for (uint32_t k = 1; k < len; k++)
        -:  770:  {
        -:  771:    /* 7.a - 7.c */
    #####:  772:    ecma_value_t curr_value = ecma_op_object_find_by_uint32_index (obj_p, k);
        -:  773:
    #####:  774:    if (ECMA_IS_VALUE_ERROR (curr_value))
        -:  775:    {
    #####:  776:      ecma_free_value (first_value);
    #####:  777:      return curr_value;
        -:  778:    }
        -:  779:
        -:  780:    /* 7.b */
    #####:  781:    uint32_t to = k - 1;
        -:  782:    ecma_value_t operation_value;
        -:  783:
    #####:  784:    if (ecma_is_value_found (curr_value))
        -:  785:    {
        -:  786:      /* 7.d.i, 7.d.ii */
    #####:  787:      operation_value = ecma_op_object_put_by_uint32_index (obj_p, to, curr_value, true);
    #####:  788:      ecma_free_value (curr_value);
        -:  789:    }
        -:  790:    else
        -:  791:    {
        -:  792:      /* 7.e.i */
    #####:  793:      operation_value = ecma_op_object_delete_by_uint32_index (obj_p, to, true);
        -:  794:    }
        -:  795:
    #####:  796:    if (ECMA_IS_VALUE_ERROR (operation_value))
        -:  797:    {
    #####:  798:      ecma_free_value (first_value);
    #####:  799:      return operation_value;
        -:  800:    }
        -:  801:  }
        -:  802:
        -:  803:  /* 8. */
    #####:  804:  ecma_value_t del_value = ecma_op_object_delete_by_uint32_index (obj_p, --len, true);
        -:  805:
    #####:  806:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  807:  {
    #####:  808:    ecma_free_value (first_value);
    #####:  809:    return del_value;
        -:  810:  }
        -:  811:
        -:  812:  /* 9. */
    #####:  813:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  814:
    #####:  815:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  816:  {
    #####:  817:    ecma_free_value (first_value);
    #####:  818:    return set_length_value;
        -:  819:  }
        -:  820:
        -:  821:  /* 10. */
    #####:  822:  return first_value;
        -:  823:} /* ecma_builtin_array_prototype_object_shift */
        -:  824:
        -:  825:/**
        -:  826: * The Array.prototype object's 'slice' routine
        -:  827: *
        -:  828: * See also:
        -:  829: *          ECMA-262 v5, 15.4.4.10
        -:  830: *
        -:  831: * @return ecma value
        -:  832: *         Returned value must be freed with ecma_free_value.
        -:  833: */
        -:  834:static ecma_value_t
    #####:  835:ecma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */
        -:  836:                                           ecma_value_t arg2, /**< end */
        -:  837:                                           ecma_object_t *obj_p, /**< array object */
        -:  838:                                           uint32_t len) /**< array object's length */
        -:  839:{
    #####:  840:  uint32_t start = 0, end = len;
        -:  841:
        -:  842:  /* 5. 6.*/
    #####:  843:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,
        -:  844:                                                                      len,
        -:  845:                                                                      &start)))
        -:  846:  {
    #####:  847:    return ECMA_VALUE_ERROR;
        -:  848:  }
        -:  849:
        -:  850:  /* 7. */
    #####:  851:  if (ecma_is_value_undefined (arg2))
        -:  852:  {
    #####:  853:    end = len;
        -:  854:  }
        -:  855:  else
        -:  856:  {
        -:  857:    /* 7. part 2, 8.*/
    #####:  858:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,
        -:  859:                                                                        len,
        -:  860:                                                                        &end)))
        -:  861:    {
    #####:  862:      return ECMA_VALUE_ERROR;
        -:  863:    }
        -:  864:  }
        -:  865:
    #####:  866:  JERRY_ASSERT (start <= len && end <= len);
        -:  867:
    #####:  868:  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);
    #####:  869:  uint32_t copied_length = (end > start) ? end - start : 0;
        -:  870:#if ENABLED (JERRY_ES2015)
    #####:  871:  ecma_value_t new_array = ecma_op_array_species_create (obj_p, copied_length);
        -:  872:
    #####:  873:  if (ECMA_IS_VALUE_ERROR (new_array))
        -:  874:  {
    #####:  875:    return new_array;
        -:  876:  }
    #####:  877:  use_fast_path &= ecma_op_object_is_fast_array (ecma_get_object_from_value (new_array));
        -:  878:#else /* !ENABLED (JERRY_ES2015) */
    #####:  879:  ecma_value_t new_array = ecma_op_create_array_object (NULL, 0, false);
    #####:  880:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_array));
        -:  881:#endif /* ENABLED (JERRY_ES2015) */
        -:  882:
    #####:  883:  ecma_object_t *new_array_p = ecma_get_object_from_value (new_array);
        -:  884:
        -:  885:  /* 9. */
    #####:  886:  uint32_t n = 0;
        -:  887:
    #####:  888:  if (use_fast_path && copied_length > 0)
        -:  889:  {
    #####:  890:    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;
        -:  891:
    #####:  892:    if (ext_from_obj_p->u.array.u.hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -:  893:    {
    #####:  894:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -:  895:      {
        -:  896:        /**
        -:  897:         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.
        -:  898:         * There is no need to do any copy.
        -:  899:         */
    #####:  900:        return new_array;
        -:  901:      }
        -:  902:
    #####:  903:      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;
        -:  904:
        -:  905:#if ENABLED (JERRY_ES2015)
    #####:  906:      uint32_t target_length = ext_to_obj_p->u.array.length;
        -:  907:      ecma_value_t *to_buffer_p;
    #####:  908:      if (copied_length == target_length)
        -:  909:      {
    #####:  910:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  911:      }
    #####:  912:      else if (copied_length > target_length)
        -:  913:      {
    #####:  914:        to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);
        -:  915:      }
        -:  916:      else
        -:  917:      {
    #####:  918:        ecma_delete_fast_array_properties (new_array_p, copied_length);
    #####:  919:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  920:      }
        -:  921:#else /* !ENABLED (JERRY_ES2015) */
    #####:  922:      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);
        -:  923:#endif /* ENABLED (JERRY_ES2015) */
        -:  924:
    #####:  925:      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  926:
    #####:  927:      for (uint32_t k = start; k < end; k++, n++)
        -:  928:      {
        -:  929:#if ENABLED (JERRY_ES2015)
    #####:  930:        ecma_free_value_if_not_object (to_buffer_p[n]);
        -:  931:#endif /* ENABLED (JERRY_ES2015) */
    #####:  932:        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);
        -:  933:      }
        -:  934:
    #####:  935:      ext_to_obj_p->u.array.u.hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;
        -:  936:
    #####:  937:      return new_array;
        -:  938:    }
        -:  939:  }
        -:  940:
        -:  941:  /* 10. */
    #####:  942:  for (uint32_t k = start; k < end; k++, n++)
        -:  943:  {
        -:  944:    /* 10.c */
    #####:  945:    ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, k);
        -:  946:
    #####:  947:    if (ECMA_IS_VALUE_ERROR (get_value))
        -:  948:    {
    #####:  949:      ecma_deref_object (new_array_p);
    #####:  950:      return get_value;
        -:  951:    }
        -:  952:
    #####:  953:    if (ecma_is_value_found (get_value))
        -:  954:    {
        -:  955:      /* 10.c.ii */
    #####:  956:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -:  957:                                                                     n,
        -:  958:                                                                     get_value,
        -:  959:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  960:      ecma_free_value (get_value);
        -:  961:
        -:  962:#if ENABLED (JERRY_ES2015)
    #####:  963:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  964:      {
    #####:  965:        ecma_deref_object (new_array_p);
    #####:  966:        return put_comp;
        -:  967:      }
        -:  968:#else /* !ENABLED (JERRY_ES2015) */
    #####:  969:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  970:#endif /* ENABLED (JERRY_ES2015) */
        -:  971:    }
        -:  972:  }
        -:  973:
        -:  974:#if ENABLED (JERRY_ES2015)
    #####:  975:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));
        -:  976:
    #####:  977:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  978:  {
    #####:  979:    ecma_deref_object (new_array_p);
    #####:  980:    return set_length_value;
        -:  981:  }
        -:  982:#endif /* ENABLED (JERRY_ES2015) */
        -:  983:
    #####:  984:  return new_array;
        -:  985:} /* ecma_builtin_array_prototype_object_slice */
        -:  986:
        -:  987:/**
        -:  988: * SortCompare abstract method
        -:  989: *
        -:  990: * See also:
        -:  991: *          ECMA-262 v5, 15.4.4.11
        -:  992: *
        -:  993: * @return ecma value
        -:  994: *         Returned value must be freed with ecma_free_value.
        -:  995: */
        -:  996:static ecma_value_t
    #####:  997:ecma_builtin_array_prototype_object_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -:  998:                                                         ecma_value_t rhs, /**< right value */
        -:  999:                                                         ecma_value_t compare_func) /**< compare function */
        -: 1000:{
        -: 1001:  /*
        -: 1002:   * ECMA-262 v5, 15.4.4.11 NOTE1: Because non-existent property values always
        -: 1003:   * compare greater than undefined property values, and undefined always
        -: 1004:   * compares greater than any other value, undefined property values always
        -: 1005:   * sort to the end of the result, followed by non-existent property values.
        -: 1006:   */
    #####: 1007:  bool lhs_is_undef = ecma_is_value_undefined (lhs);
    #####: 1008:  bool rhs_is_undef = ecma_is_value_undefined (rhs);
        -: 1009:
    #####: 1010:  if (lhs_is_undef)
        -: 1011:  {
    #####: 1012:    return ecma_make_number_value (rhs_is_undef ? ECMA_NUMBER_ZERO : ECMA_NUMBER_ONE);
        -: 1013:  }
        -: 1014:
    #####: 1015:  if (rhs_is_undef)
        -: 1016:  {
    #####: 1017:    return ecma_make_number_value (ECMA_NUMBER_MINUS_ONE);
        -: 1018:  }
        -: 1019:
    #####: 1020:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1021:
    #####: 1022:  if (ecma_is_value_undefined (compare_func))
        -: 1023:  {
        -: 1024:    /* Default comparison when no compare_func is passed. */
    #####: 1025:    ecma_string_t *lhs_str_p = ecma_op_to_string (lhs);
    #####: 1026:    if (JERRY_UNLIKELY (lhs_str_p == NULL))
        -: 1027:    {
    #####: 1028:      return ECMA_VALUE_ERROR;
        -: 1029:    }
        -: 1030:
    #####: 1031:    ecma_string_t *rhs_str_p = ecma_op_to_string (rhs);
    #####: 1032:    if (JERRY_UNLIKELY (rhs_str_p == NULL))
        -: 1033:    {
    #####: 1034:      ecma_deref_ecma_string (lhs_str_p);
    #####: 1035:      return ECMA_VALUE_ERROR;
        -: 1036:    }
        -: 1037:
    #####: 1038:    if (ecma_compare_ecma_strings_relational (lhs_str_p, rhs_str_p))
        -: 1039:    {
    #####: 1040:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1041:    }
    #####: 1042:    else if (!ecma_compare_ecma_strings (lhs_str_p, rhs_str_p))
        -: 1043:    {
    #####: 1044:      result = ECMA_NUMBER_ONE;
        -: 1045:    }
        -: 1046:    else
        -: 1047:    {
    #####: 1048:      result = ECMA_NUMBER_ZERO;
        -: 1049:    }
        -: 1050:
    #####: 1051:    ecma_deref_ecma_string (rhs_str_p);
    #####: 1052:    ecma_deref_ecma_string (lhs_str_p);
        -: 1053:  }
        -: 1054:  else
        -: 1055:  {
        -: 1056:    /*
        -: 1057:     * compare_func, if not undefined, will always contain a callable function object.
        -: 1058:     * We checked this previously, before this function was called.
        -: 1059:     */
    #####: 1060:    JERRY_ASSERT (ecma_op_is_callable (compare_func));
    #####: 1061:    ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1062:
    #####: 1063:    ecma_value_t compare_args[] = { lhs, rhs };
        -: 1064:
    #####: 1065:    ecma_value_t call_value = ecma_op_function_call (comparefn_obj_p,
        -: 1066:                                                     ECMA_VALUE_UNDEFINED,
        -: 1067:                                                     compare_args,
        -: 1068:                                                     2);
    #####: 1069:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1070:    {
    #####: 1071:      return call_value;
        -: 1072:    }
        -: 1073:
    #####: 1074:    if (!ecma_is_value_number (call_value))
        -: 1075:    {
    #####: 1076:      ecma_number_t ret_num;
        -: 1077:
    #####: 1078:      if (ECMA_IS_VALUE_ERROR (ecma_get_number (call_value, &ret_num)))
        -: 1079:      {
    #####: 1080:        ecma_free_value (call_value);
    #####: 1081:        return ECMA_VALUE_ERROR;
        -: 1082:      }
        -: 1083:
    #####: 1084:      result = ret_num;
        -: 1085:    }
        -: 1086:    else
        -: 1087:    {
    #####: 1088:      result = ecma_get_number_from_value (call_value);
        -: 1089:    }
        -: 1090:
    #####: 1091:    ecma_free_value (call_value);
        -: 1092:  }
        -: 1093:
    #####: 1094:  return ecma_make_number_value (result);
        -: 1095:} /* ecma_builtin_array_prototype_object_sort_compare_helper */
        -: 1096:
        -: 1097:/**
        -: 1098: * The Array.prototype object's 'sort' routine
        -: 1099: *
        -: 1100: * See also:
        -: 1101: *          ECMA-262 v5, 15.4.4.11
        -: 1102: *
        -: 1103: * @return ecma value
        -: 1104: *         Returned value must be freed with ecma_free_value.
        -: 1105: */
        -: 1106:static ecma_value_t
    #####: 1107:ecma_builtin_array_prototype_object_sort (ecma_value_t this_arg, /**< this argument */
        -: 1108:                                          ecma_value_t arg1, /**< comparefn */
        -: 1109:                                          ecma_object_t *obj_p, /**< array object */
        -: 1110:                                          uint32_t len) /**< array object's length */
        -: 1111:{
        -: 1112:  /* Check if the provided compare function is callable. */
    #####: 1113:  if (!ecma_is_value_undefined (arg1) && !ecma_op_is_callable (arg1))
        -: 1114:  {
    #####: 1115:    return ecma_raise_type_error (ECMA_ERR_MSG ("Compare function is not callable."));
        -: 1116:  }
        -: 1117:
    #####: 1118:  ecma_collection_t *array_index_props_p = ecma_op_object_get_property_names (obj_p, ECMA_LIST_ARRAY_INDICES);
        -: 1119:
        -: 1120:#if ENABLED (JERRY_ES2015_BUILTIN_PROXY)
    #####: 1121:  if (array_index_props_p == NULL)
        -: 1122:  {
    #####: 1123:    return ECMA_VALUE_ERROR;
        -: 1124:  }
        -: 1125:#endif /* ENABLED (JERRY_ES2015_BUILTIN_PROXY) */
        -: 1126:
    #####: 1127:  uint32_t defined_prop_count = 0;
        -: 1128:
    #####: 1129:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1130:
        -: 1131:  /* Count properties with name that is array index less than len */
    #####: 1132:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1133:  {
    #####: 1134:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1135:
    #####: 1136:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1137:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1138:
    #####: 1139:    if (index < len)
        -: 1140:    {
    #####: 1141:      defined_prop_count++;
        -: 1142:    }
        -: 1143:  }
        -: 1144:
    #####: 1145:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####: 1146:  uint32_t copied_num = 0;
    #####: 1147:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, defined_prop_count, ecma_value_t);
        -: 1148:
    #####: 1149:  buffer_p = array_index_props_p->buffer_p;
        -: 1150:
        -: 1151:  /* Copy unsorted array into a native c array. */
    #####: 1152:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1153:  {
    #####: 1154:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1155:
    #####: 1156:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1157:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1158:
    #####: 1159:    if (index >= len)
        -: 1160:    {
    #####: 1161:      break;
        -: 1162:    }
        -: 1163:
    #####: 1164:    ecma_value_t index_value = ecma_op_object_get (obj_p, property_name_p);
        -: 1165:
    #####: 1166:    if (ECMA_IS_VALUE_ERROR (index_value))
        -: 1167:    {
    #####: 1168:      goto clean_up;
        -: 1169:    }
        -: 1170:
    #####: 1171:    values_buffer[copied_num++] = index_value;
        -: 1172:  }
        -: 1173:
    #####: 1174:  JERRY_ASSERT (copied_num == defined_prop_count);
        -: 1175:
        -: 1176:  /* Sorting. */
    #####: 1177:  if (copied_num > 1)
        -: 1178:  {
    #####: 1179:    const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_array_prototype_object_sort_compare_helper;
    #####: 1180:    ecma_value_t sort_value = ecma_builtin_helper_array_heap_sort_helper (values_buffer,
    #####: 1181:                                                                          (uint32_t) (copied_num - 1),
        -: 1182:                                                                          arg1,
        -: 1183:                                                                          sort_cb);
    #####: 1184:    if (ECMA_IS_VALUE_ERROR (sort_value))
        -: 1185:    {
    #####: 1186:      goto clean_up;
        -: 1187:    }
        -: 1188:
    #####: 1189:    ecma_free_value (sort_value);
        -: 1190:  }
        -: 1191:
        -: 1192:  /* Put sorted values to the front of the array. */
    #####: 1193:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1194:  {
    #####: 1195:    ecma_value_t put_value = ecma_op_object_put_by_uint32_index (obj_p, index, values_buffer[index], true);
        -: 1196:
    #####: 1197:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1198:    {
    #####: 1199:      goto clean_up;
        -: 1200:    }
        -: 1201:  }
        -: 1202:
    #####: 1203:  ret_value = ECMA_VALUE_EMPTY;
        -: 1204:
    #####: 1205:clean_up:
        -: 1206:  /* Free values that were copied to the local array. */
    #####: 1207:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1208:  {
    #####: 1209:    ecma_free_value (values_buffer[index]);
        -: 1210:  }
        -: 1211:
    #####: 1212:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1213:
    #####: 1214:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1215:  {
    #####: 1216:    ecma_collection_free (array_index_props_p);
    #####: 1217:    return ret_value;
        -: 1218:  }
        -: 1219:
    #####: 1220:  JERRY_ASSERT (ecma_is_value_empty (ret_value));
        -: 1221:
        -: 1222:  /* Undefined properties should be in the back of the array. */
        -: 1223:
    #####: 1224:  buffer_p = array_index_props_p->buffer_p;
        -: 1225:
    #####: 1226:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1227:  {
    #####: 1228:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1229:
    #####: 1230:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1231:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1232:
    #####: 1233:    if (index >= copied_num && index < len)
        -: 1234:    {
    #####: 1235:      ecma_value_t del_value = ecma_op_object_delete (obj_p, property_name_p, true);
        -: 1236:
    #####: 1237:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1238:      {
    #####: 1239:        ecma_collection_free (array_index_props_p);
    #####: 1240:        return del_value;
        -: 1241:      }
        -: 1242:    }
        -: 1243:  }
        -: 1244:
    #####: 1245:  ecma_collection_free (array_index_props_p);
        -: 1246:
    #####: 1247:  return ecma_copy_value (this_arg);
        -: 1248:} /* ecma_builtin_array_prototype_object_sort */
        -: 1249:
        -: 1250:/**
        -: 1251: * The Array.prototype object's 'splice' routine
        -: 1252: *
        -: 1253: * See also:
        -: 1254: *          ECMA-262 v5, 15.4.4.12
        -: 1255: *
        -: 1256: * @return ecma value
        -: 1257: *         Returned value must be freed with ecma_free_value.
        -: 1258: */
        -: 1259:static ecma_value_t
    #####: 1260:ecma_builtin_array_prototype_object_splice (const ecma_value_t args[], /**< arguments list */
        -: 1261:                                            ecma_length_t args_number, /**< number of arguments */
        -: 1262:                                            ecma_object_t *obj_p, /**< array object */
        -: 1263:                                            uint32_t len) /**< array object's length */
        -: 1264:{
        -: 1265:#if ENABLED (JERRY_ES2015)
    #####: 1266:  ecma_value_t new_array = ecma_op_array_species_create (obj_p, 0);
        -: 1267:
    #####: 1268:  if (ECMA_IS_VALUE_ERROR (new_array))
        -: 1269:  {
    #####: 1270:    return new_array;
        -: 1271:  }
        -: 1272:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1273:  ecma_value_t new_array = ecma_op_create_array_object (NULL, 0, false);
    #####: 1274:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_array));
        -: 1275:#endif /* ENABLED (JERRY_ES2015) */
        -: 1276:
    #####: 1277:  ecma_object_t *new_array_p = ecma_get_object_from_value (new_array);
        -: 1278:
    #####: 1279:  uint32_t start = 0;
    #####: 1280:  uint32_t delete_count = 0;
        -: 1281:
    #####: 1282:  if (args_number > 0)
        -: 1283:  {
        -: 1284:    /* 5. 6. */
    #####: 1285:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0],
        -: 1286:                                                                        len,
        -: 1287:                                                                        &start)))
        -: 1288:    {
    #####: 1289:      ecma_deref_object (new_array_p);
    #####: 1290:      return ECMA_VALUE_ERROR;
        -: 1291:    }
        -: 1292:
        -: 1293:    /*
        -: 1294:     * If there is only one argument, that will be the start argument,
        -: 1295:     * and we must delete the additional elements.
        -: 1296:     */
    #####: 1297:    if (args_number == 1)
        -: 1298:    {
    #####: 1299:      delete_count = len - start;
        -: 1300:    }
        -: 1301:    else
        -: 1302:    {
        -: 1303:      /* 7. */
    #####: 1304:      ecma_number_t delete_num;
    #####: 1305:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &delete_num)))
        -: 1306:      {
    #####: 1307:        ecma_deref_object (new_array_p);
    #####: 1308:        return ECMA_VALUE_ERROR;
        -: 1309:      }
        -: 1310:
    #####: 1311:      if (!ecma_number_is_nan (delete_num))
        -: 1312:      {
    #####: 1313:        if (ecma_number_is_negative (delete_num))
        -: 1314:        {
    #####: 1315:          delete_count = 0;
        -: 1316:        }
        -: 1317:        else
        -: 1318:        {
    #####: 1319:          delete_count = ecma_number_is_infinity (delete_num) ? len : ecma_number_to_uint32 (delete_num);
        -: 1320:
    #####: 1321:          if (delete_count > len - start)
        -: 1322:          {
    #####: 1323:            delete_count = len - start;
        -: 1324:          }
        -: 1325:        }
        -: 1326:      }
        -: 1327:      else
        -: 1328:      {
    #####: 1329:        delete_count = 0;
        -: 1330:      }
        -: 1331:    }
        -: 1332:  }
        -: 1333:
        -: 1334:  /* 8-9. */
    #####: 1335:  uint32_t k = 0;
        -: 1336:
    #####: 1337:  for (uint32_t del_item_idx; k < delete_count; k++)
        -: 1338:  {
        -: 1339:    /* 9.a - 9.b */
    #####: 1340:    del_item_idx = k + start;
        -: 1341:
    #####: 1342:    ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, del_item_idx);
        -: 1343:
    #####: 1344:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1345:    {
    #####: 1346:      ecma_deref_object (new_array_p);
    #####: 1347:      return get_value;
        -: 1348:    }
        -: 1349:
    #####: 1350:    if (ecma_is_value_found (get_value))
        -: 1351:    {
        -: 1352:      /* 9.c.ii */
    #####: 1353:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 1354:                                                                     k,
        -: 1355:                                                                     get_value,
        -: 1356:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1357:      ecma_free_value (get_value);
        -: 1358:#if ENABLED (JERRY_ES2015)
    #####: 1359:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 1360:      {
    #####: 1361:        ecma_deref_object (new_array_p);
    #####: 1362:        return put_comp;
        -: 1363:      }
        -: 1364:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1365:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 1366:#endif /* ENABLED (JERRY_ES2015) */
        -: 1367:    }
        -: 1368:  }
        -: 1369:
        -: 1370:#if ENABLED (JERRY_ES2015)
    #####: 1371:  ecma_value_t new_set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p,
        -: 1372:                                                                                      ((ecma_number_t) delete_count));
        -: 1373:
    #####: 1374:  if (ECMA_IS_VALUE_ERROR (new_set_length_value))
        -: 1375:  {
    #####: 1376:    ecma_deref_object (new_array_p);
    #####: 1377:    return new_set_length_value;
        -: 1378:  }
        -: 1379:#endif /* ENABLED (JERRY_ES2015) */
        -: 1380:
        -: 1381:  /* 11. */
        -: 1382:  ecma_length_t item_count;
        -: 1383:
    #####: 1384:  if (args_number > 2)
        -: 1385:  {
    #####: 1386:    item_count = (ecma_length_t) (args_number - 2);
        -: 1387:  }
        -: 1388:  else
        -: 1389:  {
    #####: 1390:    item_count = 0;
        -: 1391:  }
        -: 1392:
    #####: 1393:  const uint32_t new_len = len - delete_count + item_count;
        -: 1394:
    #####: 1395:  if (item_count != delete_count)
        -: 1396:  {
        -: 1397:    uint32_t from, to;
        -: 1398:
        -: 1399:    /* 12. */
    #####: 1400:    if (item_count < delete_count)
        -: 1401:    {
        -: 1402:      /* 12.b */
    #####: 1403:      for (k = start; k < (len - delete_count); k++)
        -: 1404:      {
    #####: 1405:        from = k + delete_count;
    #####: 1406:        to = k + item_count;
        -: 1407:
    #####: 1408:        ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, from);
        -: 1409:
    #####: 1410:        if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1411:        {
    #####: 1412:          ecma_deref_object (new_array_p);
    #####: 1413:          return get_value;
        -: 1414:        }
        -: 1415:
        -: 1416:        /* 12.b.iii */
        -: 1417:        ecma_value_t operation_value;
    #####: 1418:        if (ecma_is_value_found (get_value))
        -: 1419:        {
        -: 1420:          /* 12.b.iv */
    #####: 1421:          operation_value = ecma_op_object_put_by_uint32_index (obj_p, to, get_value, true);
    #####: 1422:          ecma_free_value (get_value);
        -: 1423:        }
        -: 1424:        else
        -: 1425:        {
        -: 1426:          /* 12.b.v */
    #####: 1427:          operation_value = ecma_op_object_delete_by_uint32_index (obj_p, to, true);
        -: 1428:        }
        -: 1429:
    #####: 1430:        if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1431:        {
    #####: 1432:          ecma_deref_object (new_array_p);
    #####: 1433:          return operation_value;
        -: 1434:        }
        -: 1435:      }
        -: 1436:
        -: 1437:      /* 12.d */
    #####: 1438:      for (k = len; k > new_len; k--)
        -: 1439:      {
    #####: 1440:        ecma_value_t del_value = ecma_op_object_delete_by_uint32_index (obj_p, k - 1, true);
        -: 1441:
    #####: 1442:        if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1443:        {
    #####: 1444:          ecma_deref_object (new_array_p);
    #####: 1445:          return del_value;
        -: 1446:        }
        -: 1447:      }
        -: 1448:    }
        -: 1449:    /* 13. */
        -: 1450:    else
        -: 1451:    {
    #####: 1452:      JERRY_ASSERT (item_count > delete_count);
        -: 1453:      /* 13.b */
    #####: 1454:      for (k = len - delete_count; k > start; k--)
        -: 1455:      {
    #####: 1456:        from = k + delete_count - 1;
    #####: 1457:        to = k + item_count - 1;
        -: 1458:        /* 13.b.iii */
    #####: 1459:        ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, from);
        -: 1460:
    #####: 1461:        if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1462:        {
    #####: 1463:          ecma_deref_object (new_array_p);
    #####: 1464:          return get_value;
        -: 1465:        }
        -: 1466:
        -: 1467:        ecma_value_t operation_value;
        -: 1468:
    #####: 1469:        if (ecma_is_value_found (get_value))
        -: 1470:        {
        -: 1471:          /* 13.b.iv */
    #####: 1472:          operation_value = ecma_op_object_put_by_uint32_index (obj_p, to, get_value, true);
    #####: 1473:          ecma_free_value (get_value);
        -: 1474:        }
        -: 1475:        else
        -: 1476:        {
        -: 1477:          /* 13.b.v */
    #####: 1478:          operation_value = ecma_op_object_delete_by_uint32_index (obj_p, to, true);
        -: 1479:        }
        -: 1480:
    #####: 1481:        if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1482:        {
    #####: 1483:          ecma_deref_object (new_array_p);
    #####: 1484:          return operation_value;
        -: 1485:        }
        -: 1486:      }
        -: 1487:    }
        -: 1488:  }
        -: 1489:
        -: 1490:  /* 15. */
    #####: 1491:  ecma_length_t idx = 0;
    #####: 1492:  for (ecma_length_t arg_index = 2; arg_index < args_number; arg_index++, idx++)
        -: 1493:  {
    #####: 1494:    ecma_value_t put_value = ecma_op_object_put_by_uint32_index (obj_p,
    #####: 1495:                                                                 (uint32_t) (start + idx),
    #####: 1496:                                                                 args[arg_index],
        -: 1497:                                                                 true);
        -: 1498:
    #####: 1499:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1500:    {
    #####: 1501:      ecma_deref_object (new_array_p);
    #####: 1502:      return put_value;
        -: 1503:    }
        -: 1504:  }
        -: 1505:
        -: 1506:  /* 16. */
    #####: 1507:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) new_len));
        -: 1508:
    #####: 1509:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -: 1510:  {
    #####: 1511:    ecma_deref_object (new_array_p);
    #####: 1512:    return set_length_value;
        -: 1513:  }
        -: 1514:
    #####: 1515:  return new_array;
        -: 1516:} /* ecma_builtin_array_prototype_object_splice */
        -: 1517:
        -: 1518:/**
        -: 1519: * The Array.prototype object's 'unshift' routine
        -: 1520: *
        -: 1521: * See also:
        -: 1522: *          ECMA-262 v5, 15.4.4.13
        -: 1523: *
        -: 1524: * @return ecma value
        -: 1525: *         Returned value must be freed with ecma_free_value.
        -: 1526: */
        -: 1527:static ecma_value_t
    #####: 1528:ecma_builtin_array_prototype_object_unshift (const ecma_value_t args[], /**< arguments list */
        -: 1529:                                             ecma_length_t args_number, /**< number of arguments */
        -: 1530:                                             ecma_object_t *obj_p, /**< array object */
        -: 1531:                                             uint32_t len) /**< array object's length */
        -: 1532:{
        -: 1533:
    #####: 1534:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1535:  {
    #####: 1536:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1537:
    #####: 1538:    if (ext_obj_p->u.array.u.hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 1539:        && len != 0
    #####: 1540:        && ecma_op_ordinary_object_is_extensible (obj_p))
        -: 1541:    {
    #####: 1542:      if ((ecma_number_t) (len + args_number) > UINT32_MAX)
        -: 1543:      {
    #####: 1544:        return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid array length"));
        -: 1545:      }
        -: 1546:
    #####: 1547:      if (args_number == 0)
        -: 1548:      {
    #####: 1549:        return ecma_make_uint32_value (len);
        -: 1550:      }
        -: 1551:
    #####: 1552:      uint32_t new_length = len + args_number;
    #####: 1553:      ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length);
    #####: 1554:      memmove (buffer_p + args_number, buffer_p, sizeof (ecma_value_t) * len);
        -: 1555:
    #####: 1556:      uint32_t index = 0;
        -: 1557:
    #####: 1558:      while (index < args_number)
        -: 1559:      {
    #####: 1560:        buffer_p[index] = ecma_copy_value_if_not_object (args[index]);
    #####: 1561:        index++;
        -: 1562:      }
        -: 1563:
    #####: 1564:      ext_obj_p->u.array.u.hole_count -= args_number * ECMA_FAST_ARRAY_HOLE_ONE;
        -: 1565:
    #####: 1566:      return ecma_make_uint32_value (new_length);
        -: 1567:    }
        -: 1568:  }
        -: 1569:
        -: 1570:  /* 5. and 6. */
    #####: 1571:  for (uint32_t k = len; k > 0; k--)
        -: 1572:  {
        -: 1573:    /* 6.a, 6.c*/
    #####: 1574:    ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, k - 1);
        -: 1575:
    #####: 1576:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1577:    {
    #####: 1578:      return get_value;
        -: 1579:    }
        -: 1580:
        -: 1581:    /* 6.b */
    #####: 1582:    ecma_number_t new_idx = ((ecma_number_t) k) + ((ecma_number_t) args_number) - 1;
        -: 1583:    ecma_value_t operation_value;
        -: 1584:
    #####: 1585:    if (ecma_is_value_found (get_value))
        -: 1586:    {
        -: 1587:      /* 6.d.i, 6.d.ii */
    #####: 1588:      operation_value = ecma_op_object_put_by_number_index (obj_p, new_idx, get_value, true);
    #####: 1589:      ecma_free_value (get_value);
        -: 1590:    }
        -: 1591:    else
        -: 1592:    {
        -: 1593:      /* 6.e.i */
    #####: 1594:      operation_value = ecma_op_object_delete_by_number_index (obj_p, new_idx, true);
        -: 1595:    }
        -: 1596:
    #####: 1597:    if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1598:    {
    #####: 1599:      return operation_value;
        -: 1600:    }
        -: 1601:  }
        -: 1602:
    #####: 1603:  for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -: 1604:  {
        -: 1605:    /* 9.b */
    #####: 1606:    ecma_value_t put_value = ecma_op_object_put_by_uint32_index (obj_p, arg_index, args[arg_index], true);
        -: 1607:
    #####: 1608:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1609:    {
    #####: 1610:      return put_value;
        -: 1611:    }
        -: 1612:  }
        -: 1613:
        -: 1614:  /* 10. */
    #####: 1615:  ecma_number_t new_len = ((ecma_number_t) len) + ((ecma_number_t) args_number);
    #####: 1616:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, new_len);
        -: 1617:
    #####: 1618:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -: 1619:  {
    #####: 1620:    return set_length_value;
        -: 1621:  }
        -: 1622:
    #####: 1623:  return ecma_make_number_value (new_len);
        -: 1624:} /* ecma_builtin_array_prototype_object_unshift */
        -: 1625:
        -: 1626:/**
        -: 1627: * The Array.prototype object's 'indexOf' routine
        -: 1628: *
        -: 1629: * See also:
        -: 1630: *          ECMA-262 v5, 15.4.4.14
        -: 1631: *
        -: 1632: * @return ecma value
        -: 1633: *         Returned value must be freed with ecma_free_value.
        -: 1634: */
        -: 1635:static ecma_value_t
    #####: 1636:ecma_builtin_array_prototype_object_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1637:                                              ecma_length_t args_number, /**< number of arguments */
        -: 1638:                                              ecma_object_t *obj_p, /**< array object */
        -: 1639:                                              uint32_t len) /**< array object's length */
        -: 1640:{
        -: 1641:  /* 4. */
    #####: 1642:  if (len == 0)
        -: 1643:  {
    #####: 1644:    return ecma_make_integer_value (-1);
        -: 1645:  }
        -: 1646:
        -: 1647:  /* 5. */
    #####: 1648:  ecma_number_t idx = 0;
    #####: 1649:  if (args_number > 1)
        -: 1650:  {
    #####: 1651:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1652:    {
    #####: 1653:      return ECMA_VALUE_ERROR;
        -: 1654:    }
        -: 1655:  }
        -: 1656:
        -: 1657:  /* 6. */
    #####: 1658:  if (idx >= len)
        -: 1659:  {
    #####: 1660:    return ecma_make_number_value (-1);
        -: 1661:  }
        -: 1662:
        -: 1663:  /* 7. */
    #####: 1664:  ecma_number_t from_idx_num = idx;
        -: 1665:
        -: 1666:  /* 8. */
    #####: 1667:  if (idx < 0)
        -: 1668:  {
    #####: 1669:    from_idx_num = JERRY_MAX ((ecma_number_t) len + idx, 0);
        -: 1670:  }
        -: 1671:
    #####: 1672:  JERRY_ASSERT (from_idx_num >= 0 && from_idx_num <= UINT32_MAX);
    #####: 1673:  uint32_t from_idx = (uint32_t) from_idx_num;
        -: 1674:
    #####: 1675:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1676:  {
    #####: 1677:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1678:
    #####: 1679:    if (ext_obj_p->u.array.u.hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 1680:        && len != 0)
        -: 1681:    {
    #####: 1682:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1683:
    #####: 1684:      while (from_idx < len)
        -: 1685:      {
    #####: 1686:        if (ecma_op_strict_equality_compare (args[0], buffer_p[from_idx]))
        -: 1687:        {
    #####: 1688:          return ecma_make_uint32_value (from_idx);
        -: 1689:        }
        -: 1690:
    #####: 1691:        from_idx++;
        -: 1692:      }
        -: 1693:
    #####: 1694:      return ecma_make_integer_value (-1);
        -: 1695:    }
        -: 1696:  }
        -: 1697:
        -: 1698:  /* 6. */
    #####: 1699:  while (from_idx < len)
        -: 1700:  {
        -: 1701:    /* 9.a */
    #####: 1702:    ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, from_idx);
        -: 1703:
    #####: 1704:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1705:    {
    #####: 1706:      return get_value;
        -: 1707:    }
        -: 1708:
        -: 1709:    /* 9.b.i, 9.b.ii */
    #####: 1710:    if (ecma_is_value_found (get_value)
    #####: 1711:        && ecma_op_strict_equality_compare (args[0], get_value))
        -: 1712:    {
    #####: 1713:      ecma_free_value (get_value);
    #####: 1714:      return ecma_make_uint32_value (from_idx);
        -: 1715:    }
        -: 1716:
    #####: 1717:    from_idx++;
        -: 1718:
    #####: 1719:    ecma_free_value (get_value);
        -: 1720:  }
        -: 1721:
    #####: 1722:  return ecma_make_integer_value (-1);
        -: 1723:} /* ecma_builtin_array_prototype_object_index_of */
        -: 1724:
        -: 1725:/**
        -: 1726: * The Array.prototype object's 'lastIndexOf' routine
        -: 1727: *
        -: 1728: * See also:
        -: 1729: *          ECMA-262 v5, 15.4.4.15
        -: 1730: *
        -: 1731: * @return ecma value
        -: 1732: *         Returned value must be freed with ecma_free_value.
        -: 1733: */
        -: 1734:static ecma_value_t
    #####: 1735:ecma_builtin_array_prototype_object_last_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1736:                                                   ecma_length_t args_number, /**< number of arguments */
        -: 1737:                                                   ecma_object_t *obj_p, /**< array object */
        -: 1738:                                                   uint32_t len) /**< array object's length */
        -: 1739:{
        -: 1740:  /* 4. */
    #####: 1741:  if (len == 0)
        -: 1742:  {
    #####: 1743:    return ecma_make_integer_value (-1);
        -: 1744:  }
        -: 1745:
        -: 1746:  /* 5. */
    #####: 1747:  ecma_number_t idx = (ecma_number_t) len - 1;
    #####: 1748:  if (args_number > 1)
        -: 1749:  {
    #####: 1750:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1751:    {
    #####: 1752:      return ECMA_VALUE_ERROR;
        -: 1753:    }
        -: 1754:  }
        -: 1755:
        -: 1756:  uint32_t from_idx;
        -: 1757:
        -: 1758:  /* 6 */
    #####: 1759:  if (idx >= 0)
        -: 1760:  {
    #####: 1761:    from_idx = (uint32_t) (JERRY_MIN (idx, len - 1));
        -: 1762:  }
        -: 1763:  else
        -: 1764:  {
    #####: 1765:    ecma_number_t k = len + idx;
    #####: 1766:    if (k < 0)
        -: 1767:    {
    #####: 1768:      return ecma_make_integer_value (-1);
        -: 1769:    }
    #####: 1770:    from_idx = (uint32_t) k;
        -: 1771:  }
        -: 1772:
    #####: 1773:  ecma_value_t search_element = (args_number > 0) ? args[0] : ECMA_VALUE_UNDEFINED;
        -: 1774:
    #####: 1775:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1776:  {
    #####: 1777:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1778:    // It is possible that the length changed due to the callback performed above.
    #####: 1779:    uint32_t array_length = ext_obj_p->u.array.length;
        -: 1780:
    #####: 1781:    if (ext_obj_p->u.array.u.hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 1782:        && array_length > 0)
        -: 1783:    {
    #####: 1784:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1785:
    #####: 1786:      while (from_idx < len)
        -: 1787:      {
    #####: 1788:        if (ecma_op_strict_equality_compare (search_element, buffer_p[from_idx]))
        -: 1789:        {
    #####: 1790:          return ecma_make_uint32_value (from_idx);
        -: 1791:        }
    #####: 1792:        from_idx--;
        -: 1793:      }
    #####: 1794:      return ecma_make_integer_value (-1);
        -: 1795:    }
        -: 1796:  }
        -: 1797:
        -: 1798:    /* 8. */
    #####: 1799:  while (from_idx < len)
        -: 1800:  {
        -: 1801:    /* 8.a */
    #####: 1802:    ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, from_idx);
        -: 1803:
    #####: 1804:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1805:    {
    #####: 1806:      return get_value;
        -: 1807:    }
        -: 1808:
        -: 1809:    /* 8.b.i, 8.b.ii */
    #####: 1810:    if (ecma_is_value_found (get_value)
    #####: 1811:        && ecma_op_strict_equality_compare (search_element, get_value))
        -: 1812:    {
    #####: 1813:      ecma_free_value (get_value);
    #####: 1814:      return ecma_make_uint32_value (from_idx);
        -: 1815:    }
        -: 1816:
    #####: 1817:    from_idx--;
        -: 1818:
    #####: 1819:    ecma_free_value (get_value);
        -: 1820:  }
        -: 1821:
    #####: 1822:  return ecma_make_integer_value (-1);
        -: 1823:} /* ecma_builtin_array_prototype_object_last_index_of */
        -: 1824:
        -: 1825:/**
        -: 1826: * Type of array routine.
        -: 1827: */
        -: 1828:typedef enum
        -: 1829:{
        -: 1830:  ARRAY_ROUTINE_EVERY, /**< Array.every: ECMA-262 v5, 15.4.4.16 */
        -: 1831:  ARRAY_ROUTINE_SOME, /**< Array.some: ECMA-262 v5, 15.4.4.17 */
        -: 1832:  ARRAY_ROUTINE_FOREACH, /**< Array.forEach: ECMA-262 v5, 15.4.4.18 */
        -: 1833:  ARRAY_ROUTINE__COUNT /**< count of the modes */
        -: 1834:} array_routine_mode;
        -: 1835:
        -: 1836:/**
        -: 1837: * Applies the provided function to each element of the array as long as
        -: 1838: * the return value stays empty. The common function for 'every', 'some'
        -: 1839: * and 'forEach' of the Array prototype.
        -: 1840: *
        -: 1841: * See also:
        -: 1842: *          ECMA-262 v5, 15.4.4.16
        -: 1843: *          ECMA-262 v5, 15.4.4.17
        -: 1844: *          ECMA-262 v5, 15.4.4.18
        -: 1845: *
        -: 1846: * @return ecma value
        -: 1847: *         Returned value must be freed with ecma_free_value.
        -: 1848: */
        -: 1849:static ecma_value_t
    #####: 1850:ecma_builtin_array_apply (ecma_value_t arg1, /**< callbackfn */
        -: 1851:                          ecma_value_t arg2, /**< thisArg */
        -: 1852:                          array_routine_mode mode, /**< array routine mode */
        -: 1853:                          ecma_object_t *obj_p, /**< array object */
        -: 1854:                          uint32_t len) /**< array object's length */
        -: 1855:
        -: 1856:{
    #####: 1857:  JERRY_ASSERT (mode < ARRAY_ROUTINE__COUNT);
        -: 1858:
        -: 1859:  /* 4. */
    #####: 1860:  if (!ecma_op_is_callable (arg1))
        -: 1861:  {
    #####: 1862:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -: 1863:  }
        -: 1864:
        -: 1865:  /* We already checked that arg1 is callable */
    #####: 1866:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1867:  ecma_value_t current_index;
        -: 1868:
        -: 1869:  /* 7. */
    #####: 1870:  for (uint32_t index = 0; index < len; index++)
        -: 1871:  {
        -: 1872:    /* 7.a - 7.c */
    #####: 1873:    ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, index);
        -: 1874:
    #####: 1875:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1876:    {
    #####: 1877:      return get_value;
        -: 1878:    }
        -: 1879:
    #####: 1880:    if (ecma_is_value_found (get_value))
        -: 1881:    {
        -: 1882:      /* 7.c.i */
    #####: 1883:      current_index = ecma_make_uint32_value (index);
        -: 1884:
    #####: 1885:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 1886:      /* 7.c.ii */
    #####: 1887:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 1888:
    #####: 1889:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1890:      {
    #####: 1891:        ecma_free_value (get_value);
    #####: 1892:        return call_value;
        -: 1893:      }
        -: 1894:
    #####: 1895:      bool to_boolean = ecma_op_to_boolean (call_value);
        -: 1896:
    #####: 1897:      ecma_free_value (call_value);
    #####: 1898:      ecma_free_value (get_value);
        -: 1899:
        -: 1900:      /* 7.c.iii */
    #####: 1901:      if (mode == ARRAY_ROUTINE_EVERY && !to_boolean)
        -: 1902:      {
    #####: 1903:        return ECMA_VALUE_FALSE;
        -: 1904:      }
    #####: 1905:      else if (mode == ARRAY_ROUTINE_SOME && to_boolean)
        -: 1906:      {
    #####: 1907:        return ECMA_VALUE_TRUE;
        -: 1908:      }
        -: 1909:    }
        -: 1910:  }
        -: 1911:
        -: 1912:  /* 8. */
        -: 1913:
    #####: 1914:  if (mode == ARRAY_ROUTINE_EVERY)
        -: 1915:  {
    #####: 1916:    return ECMA_VALUE_TRUE;
        -: 1917:  }
    #####: 1918:  else if (mode == ARRAY_ROUTINE_SOME)
        -: 1919:  {
    #####: 1920:    return ECMA_VALUE_FALSE;
        -: 1921:  }
        -: 1922:
    #####: 1923:  JERRY_ASSERT (mode == ARRAY_ROUTINE_FOREACH);
    #####: 1924:  return ECMA_VALUE_UNDEFINED;
        -: 1925:} /* ecma_builtin_array_apply */
        -: 1926:
        -: 1927:/**
        -: 1928: * The Array.prototype object's 'map' routine
        -: 1929: *
        -: 1930: * See also:
        -: 1931: *          ECMA-262 v5, 15.4.4.19
        -: 1932: *
        -: 1933: * @return ecma value
        -: 1934: *         Returned value must be freed with ecma_free_value.
        -: 1935: */
        -: 1936:static ecma_value_t
    #####: 1937:ecma_builtin_array_prototype_object_map (ecma_value_t arg1, /**< callbackfn */
        -: 1938:                                         ecma_value_t arg2, /**< thisArg */
        -: 1939:                                         ecma_object_t *obj_p, /**< array object */
        -: 1940:                                         uint32_t len) /**< array object's length */
        -: 1941:{
        -: 1942:  /* 4. */
    #####: 1943:  if (!ecma_op_is_callable (arg1))
        -: 1944:  {
    #####: 1945:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -: 1946:  }
        -: 1947:
        -: 1948:  /* 6. */
        -: 1949:#if ENABLED (JERRY_ES2015)
    #####: 1950:  ecma_value_t new_array = ecma_op_array_species_create (obj_p, len);
        -: 1951:
    #####: 1952:  if (ECMA_IS_VALUE_ERROR (new_array))
        -: 1953:  {
    #####: 1954:    return new_array;
        -: 1955:  }
        -: 1956:#else /* !ENABLED (JERRY_ES2015) */
    #####: 1957:  ecma_value_t length_value = ecma_make_number_value (len);
    #####: 1958:  ecma_value_t new_array = ecma_op_create_array_object (&length_value, 1, true);
    #####: 1959:  ecma_free_value (length_value);
    #####: 1960:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_array));
        -: 1961:#endif /* ENABLED (JERRY_ES2015) */
        -: 1962:
    #####: 1963:  ecma_object_t *new_array_p = ecma_get_object_from_value (new_array);
        -: 1964:
    #####: 1965:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 1966:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1967:
        -: 1968:  /* 7-8. */
        -: 1969:  ecma_value_t current_index;
        -: 1970:
    #####: 1971:  for (uint32_t index = 0; index < len; index++)
        -: 1972:  {
        -: 1973:    /* 8.a - 8.b */
    #####: 1974:    ecma_value_t current_value = ecma_op_object_find_by_uint32_index (obj_p, index);
        -: 1975:
    #####: 1976:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 1977:    {
    #####: 1978:      ecma_deref_object (new_array_p);
    #####: 1979:      return current_value;
        -: 1980:    }
        -: 1981:
    #####: 1982:    if (ecma_is_value_found (current_value))
        -: 1983:    {
        -: 1984:      /* 8.c.i, 8.c.ii */
    #####: 1985:      current_index = ecma_make_uint32_value (index);
    #####: 1986:      ecma_value_t call_args[] = { current_value, current_index, ecma_make_object_value (obj_p) };
        -: 1987:
    #####: 1988:      ecma_value_t mapped_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 1989:
    #####: 1990:      if (ECMA_IS_VALUE_ERROR (mapped_value))
        -: 1991:      {
    #####: 1992:        ecma_free_value (current_value);
    #####: 1993:        ecma_deref_object (new_array_p);
    #####: 1994:        return mapped_value;
        -: 1995:      }
        -: 1996:
        -: 1997:      /* 8.c.iii */
    #####: 1998:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 1999:                                                                     index,
        -: 2000:                                                                     mapped_value,
        -: 2001:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2002:
    #####: 2003:      ecma_free_value (mapped_value);
    #####: 2004:      ecma_free_value (current_value);
        -: 2005:#if ENABLED (JERRY_ES2015)
    #####: 2006:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2007:      {
    #####: 2008:        ecma_deref_object (new_array_p);
    #####: 2009:        return put_comp;
        -: 2010:      }
        -: 2011:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2012:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2013:#endif /* ENABLED (JERRY_ES2015) */
        -: 2014:    }
        -: 2015:  }
        -: 2016:
    #####: 2017:  return ecma_make_object_value (new_array_p);
        -: 2018:} /* ecma_builtin_array_prototype_object_map */
        -: 2019:
        -: 2020:/**
        -: 2021: * The Array.prototype object's 'filter' routine
        -: 2022: *
        -: 2023: * See also:
        -: 2024: *          ECMA-262 v5, 15.4.4.20
        -: 2025: *
        -: 2026: * @return ecma value
        -: 2027: *         Returned value must be freed with ecma_free_value.
        -: 2028: */
        -: 2029:static ecma_value_t
    #####: 2030:ecma_builtin_array_prototype_object_filter (ecma_value_t arg1, /**< callbackfn */
        -: 2031:                                            ecma_value_t arg2, /**< thisArg */
        -: 2032:                                            ecma_object_t *obj_p, /**< array object */
        -: 2033:                                            uint32_t len) /**< array object's length */
        -: 2034:{
        -: 2035:  /* 4. */
    #####: 2036:  if (!ecma_op_is_callable (arg1))
        -: 2037:  {
    #####: 2038:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -: 2039:  }
        -: 2040:
        -: 2041:  /* 6. */
        -: 2042:#if ENABLED (JERRY_ES2015)
    #####: 2043:  ecma_value_t new_array = ecma_op_array_species_create (obj_p, 0);
        -: 2044:
    #####: 2045:  if (ECMA_IS_VALUE_ERROR (new_array))
        -: 2046:  {
    #####: 2047:    return new_array;
        -: 2048:  }
        -: 2049:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2050:  ecma_value_t new_array = ecma_op_create_array_object (NULL, 0, false);
    #####: 2051:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_array));
        -: 2052:#endif /* ENABLED (JERRY_ES2015) */
        -: 2053:
    #####: 2054:  ecma_object_t *new_array_p = ecma_get_object_from_value (new_array);
        -: 2055:
        -: 2056:  /* We already checked that arg1 is callable, so it will always be an object. */
    #####: 2057:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 2058:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 2059:
        -: 2060:  /* 8. */
    #####: 2061:  uint32_t new_array_index = 0;
        -: 2062:  ecma_value_t current_index;
        -: 2063:
        -: 2064:  /* 9. */
    #####: 2065:  for (uint32_t index = 0; index < len; index++)
        -: 2066:  {
        -: 2067:    /* 9.a - 9.c */
    #####: 2068:    ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, index);
        -: 2069:
    #####: 2070:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2071:    {
    #####: 2072:      ecma_deref_object (new_array_p);
    #####: 2073:      return get_value;
        -: 2074:    }
        -: 2075:
    #####: 2076:    if (ecma_is_value_found (get_value))
        -: 2077:    {
        -: 2078:      /* 9.c.i */
    #####: 2079:      current_index = ecma_make_uint32_value (index);
        -: 2080:
    #####: 2081:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2082:      /* 9.c.ii */
    #####: 2083:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 2084:
    #####: 2085:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2086:      {
    #####: 2087:        ecma_free_value (get_value);
    #####: 2088:        ecma_deref_object (new_array_p);
    #####: 2089:        return call_value;
        -: 2090:      }
        -: 2091:
        -: 2092:      /* 9.c.iii */
    #####: 2093:      if (ecma_op_to_boolean (call_value))
        -: 2094:      {
    #####: 2095:        ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 2096:                                                                       new_array_index,
        -: 2097:                                                                       get_value,
        -: 2098:                                                                       ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2099:#if ENABLED (JERRY_ES2015)
    #####: 2100:        if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2101:        {
    #####: 2102:          ecma_free_value (call_value);
    #####: 2103:          ecma_free_value (get_value);
    #####: 2104:          ecma_deref_object (new_array_p);
        -: 2105:
    #####: 2106:          return put_comp;
        -: 2107:        }
        -: 2108:#else /* !ENABLED (JERRY_ES2015) */
    #####: 2109:        JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2110:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2111:        new_array_index++;
        -: 2112:      }
        -: 2113:
    #####: 2114:      ecma_free_value (call_value);
    #####: 2115:      ecma_free_value (get_value);
        -: 2116:    }
        -: 2117:  }
        -: 2118:
    #####: 2119:  return new_array;
        -: 2120:} /* ecma_builtin_array_prototype_object_filter */
        -: 2121:
        -: 2122:/**
        -: 2123: * The Array.prototype object's 'reduce' and 'reduceRight' routine
        -: 2124: *
        -: 2125: * See also:
        -: 2126: *         ECMA-262 v5, 15.4.4.21
        -: 2127: *         ECMA-262 v5, 15.4.4.22
        -: 2128: *
        -: 2129: * @return ecma value
        -: 2130: *         Returned value must be freed with ecma_free_value.
        -: 2131: */
        -: 2132:static ecma_value_t
    #####: 2133:ecma_builtin_array_reduce_from (const ecma_value_t args_p[], /**< routine's arguments */
        -: 2134:                                ecma_length_t args_number, /**< arguments list length */
        -: 2135:                                bool start_from_left, /**< whether the reduce starts from left or right */
        -: 2136:                                ecma_object_t *obj_p, /**< array object */
        -: 2137:                                uint32_t len) /**< array object's length */
        -: 2138:{
        -: 2139:  /* 4. */
    #####: 2140:  if (!ecma_op_is_callable (args_p[0]))
        -: 2141:  {
    #####: 2142:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -: 2143:  }
        -: 2144:
        -: 2145:  /* 5. */
    #####: 2146:  if (len == 0 && args_number == 1)
        -: 2147:  {
    #####: 2148:    return ecma_raise_type_error (ECMA_ERR_MSG ("Reduce of empty array with no initial value."));
        -: 2149:  }
        -: 2150:
    #####: 2151:  JERRY_ASSERT (ecma_is_value_object (args_p[0]));
    #####: 2152:  ecma_object_t *func_object_p = ecma_get_object_from_value (args_p[0]);
        -: 2153:
    #####: 2154:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
        -: 2155:
        -: 2156:  /* 6. */
    #####: 2157:  uint32_t index = 0;
    #####: 2158:  const uint32_t last_index = len - 1;
        -: 2159:
        -: 2160:  /* 7.a */
    #####: 2161:  if (args_number > 1)
        -: 2162:  {
    #####: 2163:    accumulator = ecma_copy_value (args_p[1]);
        -: 2164:  }
        -: 2165:  else
        -: 2166:  {
        -: 2167:    /* 8.a */
    #####: 2168:    bool k_present = false;
        -: 2169:
        -: 2170:    /* 8.b */
    #####: 2171:    while (!k_present && index < len)
        -: 2172:    {
        -: 2173:      /* 8.b.i */
    #####: 2174:      k_present = true;
        -: 2175:
        -: 2176:      /* 8.b.ii-iii */
    #####: 2177:      ecma_value_t current_value = ecma_op_object_find_by_uint32_index (obj_p, start_from_left ? index :
        -: 2178:                                                                                                 last_index - index);
        -: 2179:
    #####: 2180:      if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2181:      {
    #####: 2182:        return current_value;
        -: 2183:      }
        -: 2184:
    #####: 2185:      if (ecma_is_value_found (current_value))
        -: 2186:      {
    #####: 2187:        accumulator = current_value;
        -: 2188:      }
        -: 2189:      else
        -: 2190:      {
    #####: 2191:        k_present = false;
        -: 2192:      }
        -: 2193:
        -: 2194:      /* 8.b.iv */
    #####: 2195:      index++;
        -: 2196:    }
        -: 2197:
        -: 2198:    /* 8.c */
    #####: 2199:    if (!k_present)
        -: 2200:    {
    #####: 2201:      return ecma_raise_type_error (ECMA_ERR_MSG ("Missing array element."));
        -: 2202:    }
        -: 2203:  }
        -: 2204:  /* 9. */
        -: 2205:  ecma_value_t current_index;
        -: 2206:
    #####: 2207:  for (; index < len; index++)
        -: 2208:  {
    #####: 2209:    const uint32_t corrected_index = start_from_left ? index : last_index - index;
        -: 2210:
        -: 2211:    /* 9.a - 9.b */
    #####: 2212:    ecma_value_t current_value = ecma_op_object_find_by_uint32_index (obj_p, corrected_index);
        -: 2213:
    #####: 2214:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2215:    {
    #####: 2216:      ecma_free_value (accumulator);
    #####: 2217:      return current_value;
        -: 2218:    }
        -: 2219:
    #####: 2220:    if (ecma_is_value_found (current_value))
        -: 2221:    {
        -: 2222:      /* 9.c.i, 9.c.ii */
    #####: 2223:      current_index = ecma_make_uint32_value (corrected_index);
    #####: 2224:      ecma_value_t call_args[] = {accumulator, current_value, current_index, ecma_make_object_value (obj_p)};
        -: 2225:
    #####: 2226:      ecma_value_t call_value = ecma_op_function_call (func_object_p,
        -: 2227:                                                       ECMA_VALUE_UNDEFINED,
        -: 2228:                                                       call_args,
        -: 2229:                                                       4);
    #####: 2230:      ecma_free_value (current_index);
    #####: 2231:      ecma_free_value (accumulator);
    #####: 2232:      ecma_free_value (current_value);
        -: 2233:
    #####: 2234:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2235:      {
    #####: 2236:        return call_value;
        -: 2237:      }
        -: 2238:
    #####: 2239:      accumulator = call_value;
        -: 2240:    }
        -: 2241:  }
        -: 2242:
    #####: 2243:  return accumulator;
        -: 2244:} /* ecma_builtin_array_reduce_from */
        -: 2245:
        -: 2246:#if ENABLED (JERRY_ES2015)
        -: 2247:
        -: 2248:/**
        -: 2249: * The Array.prototype object's 'fill' routine
        -: 2250: *
        -: 2251: * Note: this method only supports length up to uint32, instead of max_safe_integer
        -: 2252: *
        -: 2253: * See also:
        -: 2254: *          ECMA-262 v6, 22.1.3.6
        -: 2255: *
        -: 2256: * @return ecma value
        -: 2257: *         Returned value must be freed with ecma_free_value.
        -: 2258: */
        -: 2259:static ecma_value_t
    #####: 2260:ecma_builtin_array_prototype_fill (ecma_value_t value, /**< value */
        -: 2261:                                   ecma_value_t start_val, /**< start value */
        -: 2262:                                   ecma_value_t end_val, /**< end value */
        -: 2263:                                   ecma_object_t *obj_p, /**< array object */
        -: 2264:                                   uint32_t len) /**< array object's length */
        -: 2265:{
    #####: 2266:  uint32_t k, final;
        -: 2267:
        -: 2268:  /* 5. 6. 7. */
    #####: 2269:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (start_val,
        -: 2270:                                                                      len,
        -: 2271:                                                                      &k)))
        -: 2272:  {
    #####: 2273:    return ECMA_VALUE_ERROR;
        -: 2274:  }
        -: 2275:
        -: 2276:  /* 8. */
    #####: 2277:  if (ecma_is_value_undefined (end_val))
        -: 2278:  {
    #####: 2279:    final = len;
        -: 2280:  }
        -: 2281:  else
        -: 2282:  {
        -: 2283:    /* 8 part 2, 9, 10 */
    #####: 2284:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (end_val,
        -: 2285:                                                                        len,
        -: 2286:                                                                        &final)))
        -: 2287:    {
    #####: 2288:      return ECMA_VALUE_ERROR;
        -: 2289:    }
        -: 2290:  }
        -: 2291:
    #####: 2292:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2293:  {
    #####: 2294:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2295:
    #####: 2296:    if (ext_obj_p->u.array.u.hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 2297:        && len != 0
    #####: 2298:        && ecma_op_ordinary_object_is_extensible (obj_p))
        -: 2299:    {
    #####: 2300:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2301:
    #####: 2302:      while (k < final)
        -: 2303:      {
    #####: 2304:        ecma_free_value_if_not_object (buffer_p[k]);
    #####: 2305:        buffer_p[k] = ecma_copy_value_if_not_object (value);
    #####: 2306:        k++;
        -: 2307:      }
        -: 2308:
    #####: 2309:      ecma_ref_object (obj_p);
    #####: 2310:      return ecma_make_object_value (obj_p);
        -: 2311:    }
        -: 2312:  }
        -: 2313:
        -: 2314:  /* 11. */
    #####: 2315:  while (k < final)
        -: 2316:  {
        -: 2317:    /* 11.a - 11.b */
    #####: 2318:    ecma_value_t put_val = ecma_op_object_put_by_number_index (obj_p, k, value, true);
        -: 2319:
        -: 2320:    /* 11. c */
    #####: 2321:    if (ECMA_IS_VALUE_ERROR (put_val))
        -: 2322:    {
    #####: 2323:      return put_val;
        -: 2324:    }
        -: 2325:
        -: 2326:    /* 11.d */
    #####: 2327:    k++;
        -: 2328:  }
        -: 2329:
    #####: 2330:  ecma_ref_object (obj_p);
    #####: 2331:  return ecma_make_object_value (obj_p);
        -: 2332:} /* ecma_builtin_array_prototype_fill */
        -: 2333:
        -: 2334:/**
        -: 2335: * The Array.prototype object's 'find' and 'findIndex' routine
        -: 2336: *
        -: 2337: * See also:
        -: 2338: *          ECMA-262 v6, 22.1.3.8
        -: 2339: *          ECMA-262 v6, 22.1.3.9
        -: 2340: *
        -: 2341: * @return ecma value
        -: 2342: *         Returned value must be freed with ecma_free_value.
        -: 2343: */
        -: 2344:static ecma_value_t
    #####: 2345:ecma_builtin_array_prototype_object_find (ecma_value_t predicate, /**< callback function */
        -: 2346:                                          ecma_value_t predicate_this_arg, /**< this argument for
        -: 2347:                                                                            *   invoke predicate */
        -: 2348:                                          bool is_find, /**< true - find routine
        -: 2349:                                                         *   false - findIndex routine */
        -: 2350:                                          ecma_object_t *obj_p, /**< array object */
        -: 2351:                                          uint32_t len) /**< array object's length */
        -: 2352:{
        -: 2353:  /* 5. */
    #####: 2354:  if (!ecma_op_is_callable (predicate))
        -: 2355:  {
    #####: 2356:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -: 2357:  }
        -: 2358:
        -: 2359:  /* We already checked that predicate is callable, so it will always be an object. */
    #####: 2360:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 2361:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
        -: 2362:
        -: 2363:  /* 7 - 8. */
    #####: 2364:  for (uint32_t index = 0; index < len; index++)
        -: 2365:  {
        -: 2366:    /* 8.a - 8.c */
    #####: 2367:    ecma_value_t get_value = ecma_op_object_get_by_uint32_index (obj_p, index);
        -: 2368:
    #####: 2369:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2370:    {
    #####: 2371:      return get_value;
        -: 2372:    }
        -: 2373:
        -: 2374:    /* 8.d - 8.e */
    #####: 2375:    ecma_value_t current_index = ecma_make_uint32_value (index);
        -: 2376:
    #####: 2377:    ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2378:
    #####: 2379:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 2380:
    #####: 2381:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2382:    {
    #####: 2383:      ecma_free_value (get_value);
    #####: 2384:      return call_value;
        -: 2385:    }
        -: 2386:
    #####: 2387:    bool call_value_to_bool = ecma_op_to_boolean (call_value);
        -: 2388:
    #####: 2389:    ecma_free_value (call_value);
        -: 2390:
    #####: 2391:    if (call_value_to_bool)
        -: 2392:    {
        -: 2393:      /* 8.f */
    #####: 2394:      if (is_find)
        -: 2395:      {
    #####: 2396:        ecma_free_value (current_index);
    #####: 2397:        return get_value;
        -: 2398:      }
        -: 2399:
    #####: 2400:      ecma_free_value (get_value);
    #####: 2401:      return current_index;
        -: 2402:    }
        -: 2403:
    #####: 2404:    ecma_free_value (get_value);
    #####: 2405:    ecma_free_value (current_index);
        -: 2406:  }
        -: 2407:
        -: 2408:  /* 9. */
    #####: 2409:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 2410:} /* ecma_builtin_array_prototype_object_find */
        -: 2411:
        -: 2412:/**
        -: 2413: * The Array.prototype object's 'copyWithin' routine
        -: 2414: *
        -: 2415: * See also:
        -: 2416: *          ECMA-262 v6, 22.1.3.3
        -: 2417: *
        -: 2418: * @return ecma value
        -: 2419: *         Returned value must be freed with ecma_free_value.
        -: 2420: */
        -: 2421:static ecma_value_t
    #####: 2422:ecma_builtin_array_prototype_object_copy_within (const ecma_value_t args[], /**< arguments list */
        -: 2423:                                                 ecma_length_t args_number, /**< number of arguments */
        -: 2424:                                                 ecma_object_t *obj_p, /**< array object */
        -: 2425:                                                 uint32_t len) /**< array object's length */
        -: 2426:{
    #####: 2427:  if (args_number == 0)
        -: 2428:  {
    #####: 2429:    return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2430:  }
        -: 2431:
        -: 2432:  /* 5 - 7 */
    #####: 2433:  uint32_t target;
        -: 2434:
    #####: 2435:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0], len, &target)))
        -: 2436:  {
    #####: 2437:    return ECMA_VALUE_ERROR;
        -: 2438:  }
        -: 2439:
    #####: 2440:  uint32_t start = 0;
    #####: 2441:  uint32_t end = len;
        -: 2442:
    #####: 2443:  if (args_number > 1)
        -: 2444:  {
        -: 2445:    /* 8 - 10 */
    #####: 2446:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &start)))
        -: 2447:    {
    #####: 2448:      return ECMA_VALUE_ERROR;
        -: 2449:    }
        -: 2450:
    #####: 2451:    if (args_number > 2)
        -: 2452:    {
        -: 2453:      /* 11 */
    #####: 2454:      if (ecma_is_value_undefined (args[2]))
        -: 2455:      {
    #####: 2456:        end = len;
        -: 2457:      }
        -: 2458:      else
        -: 2459:      {
        -: 2460:        /* 11 part 2, 12, 13 */
    #####: 2461:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[2], len, &end)))
        -: 2462:        {
    #####: 2463:          return ECMA_VALUE_ERROR;
        -: 2464:        }
        -: 2465:      }
        -: 2466:    }
        -: 2467:  }
        -: 2468:
    #####: 2469:  if (target >= len || start >= end || end == 0)
        -: 2470:  {
    #####: 2471:    ecma_ref_object (obj_p);
    #####: 2472:    return ecma_make_object_value (obj_p);
        -: 2473:  }
        -: 2474:
    #####: 2475:  uint32_t count = JERRY_MIN (end - start, len - target);
        -: 2476:
    #####: 2477:  bool forward = true;
        -: 2478:
    #####: 2479:  if (start < target && target < start + count)
        -: 2480:  {
    #####: 2481:    start = start + count - 1;
    #####: 2482:    target = target + count - 1;
    #####: 2483:    forward = false;
        -: 2484:  }
        -: 2485:
    #####: 2486:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2487:  {
    #####: 2488:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2489:
    #####: 2490:    if (ext_obj_p->u.array.u.hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2491:    {
    #####: 2492:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2493:      {
    #####: 2494:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2495:
    #####: 2496:        for (; count > 0; count--)
        -: 2497:        {
    #####: 2498:          ecma_value_t copy_value = ecma_copy_value_if_not_object (buffer_p[start]);
        -: 2499:
    #####: 2500:          ecma_free_value_if_not_object (buffer_p[target]);
        -: 2501:
    #####: 2502:          buffer_p[target] = copy_value;
        -: 2503:
    #####: 2504:          if (forward)
        -: 2505:          {
    #####: 2506:            start++;
    #####: 2507:            target++;
        -: 2508:          }
        -: 2509:          else
        -: 2510:          {
    #####: 2511:            start--;
    #####: 2512:            target--;
        -: 2513:          }
        -: 2514:        }
        -: 2515:      }
        -: 2516:
    #####: 2517:      ecma_ref_object (obj_p);
    #####: 2518:      return ecma_make_object_value (obj_p);
        -: 2519:    }
        -: 2520:  }
        -: 2521:
    #####: 2522:  while (count > 0)
        -: 2523:  {
    #####: 2524:    ecma_value_t get_value = ecma_op_object_find_by_uint32_index (obj_p, start);
        -: 2525:
    #####: 2526:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2527:    {
    #####: 2528:      return get_value;
        -: 2529:    }
        -: 2530:
        -: 2531:    ecma_value_t op_value;
        -: 2532:
    #####: 2533:    if (ecma_is_value_found (get_value))
        -: 2534:    {
    #####: 2535:      op_value = ecma_op_object_put_by_uint32_index (obj_p, target, get_value, true);
        -: 2536:    }
        -: 2537:    else
        -: 2538:    {
    #####: 2539:      op_value = ecma_op_object_delete_by_uint32_index (obj_p, target, true);
        -: 2540:    }
        -: 2541:
    #####: 2542:    ecma_free_value (get_value);
        -: 2543:
    #####: 2544:    if (ECMA_IS_VALUE_ERROR (op_value))
        -: 2545:    {
    #####: 2546:      return op_value;
        -: 2547:    }
        -: 2548:
    #####: 2549:    ecma_free_value (op_value);
        -: 2550:
    #####: 2551:    if (forward)
        -: 2552:    {
    #####: 2553:      start++;
    #####: 2554:      target++;
        -: 2555:    }
        -: 2556:    else
        -: 2557:    {
    #####: 2558:      start--;
    #####: 2559:      target--;
        -: 2560:    }
        -: 2561:
    #####: 2562:    count--;
        -: 2563:  }
        -: 2564:
    #####: 2565:  return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2566:} /* ecma_builtin_array_prototype_object_copy_within */
        -: 2567:#endif /* ENABLED (JERRY_ES2015) */
        -: 2568:
        -: 2569:/**
        -: 2570: * Dispatcher of the built-in's routines
        -: 2571: *
        -: 2572: * @return ecma value
        -: 2573: *         Returned value must be freed with ecma_free_value.
        -: 2574: */
        -: 2575:ecma_value_t
    #####: 2576:ecma_builtin_array_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine
        -: 2577:                                                                            *   identifier */
        -: 2578:                                              ecma_value_t this_arg, /**< 'this' argument value */
        -: 2579:                                              const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 2580:                                                                                    *   passed to routine */
        -: 2581:                                              ecma_length_t arguments_number) /**< length of arguments' list */
        -: 2582:{
    #####: 2583:  ecma_value_t obj_this = ecma_op_to_object (this_arg);
        -: 2584:
    #####: 2585:  if (ECMA_IS_VALUE_ERROR (obj_this))
        -: 2586:  {
    #####: 2587:    return obj_this;
        -: 2588:  }
        -: 2589:
    #####: 2590:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);
        -: 2591:
    #####: 2592:  if (JERRY_UNLIKELY (builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_CONCAT))
        -: 2593:  {
        -: 2594:    ecma_value_t ret_value;
        -: 2595:
    #####: 2596:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_TO_STRING)
        -: 2597:    {
    #####: 2598:      ret_value = ecma_builtin_array_prototype_object_to_string (this_arg, obj_p);
        -: 2599:    }
        -: 2600:    else
        -: 2601:    {
    #####: 2602:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_CONCAT);
    #####: 2603:      ret_value = ecma_builtin_array_prototype_object_concat (arguments_list_p,
        -: 2604:                                                              arguments_number,
        -: 2605:                                                              obj_p);
        -: 2606:    }
        -: 2607:
    #####: 2608:    ecma_deref_object (obj_p);
    #####: 2609:    return ret_value;
        -: 2610:  }
        -: 2611:
        -: 2612:#if ENABLED (JERRY_ES2015)
    #####: 2613:  if (JERRY_UNLIKELY (builtin_routine_id >= ECMA_ARRAY_PROTOTYPE_ENTRIES
        -: 2614:                      && builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_KEYS))
        -: 2615:  {
        -: 2616:    ecma_value_t ret_value;
        -: 2617:
    #####: 2618:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_ENTRIES)
        -: 2619:    {
    #####: 2620:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_KEYS_VALUES);
        -: 2621:    }
        -: 2622:    else
        -: 2623:    {
    #####: 2624:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_KEYS);
    #####: 2625:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_KEYS);
        -: 2626:    }
        -: 2627:
    #####: 2628:    ecma_deref_object (obj_p);
    #####: 2629:    return ret_value;
        -: 2630:  }
        -: 2631:#endif /* ENABLED (JERRY_ES2015) */
        -: 2632:
    #####: 2633:  uint32_t length;
    #####: 2634:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &length);
        -: 2635:
    #####: 2636:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2637:  {
    #####: 2638:    ecma_deref_object (obj_p);
    #####: 2639:    return len_value;
        -: 2640:  }
        -: 2641:
        -: 2642:  ecma_value_t ret_value;
    #####: 2643:  ecma_value_t routine_arg_1 = arguments_list_p[0];
    #####: 2644:  ecma_value_t routine_arg_2 = arguments_list_p[1];
        -: 2645:
    #####: 2646:  switch (builtin_routine_id)
        -: 2647:  {
    #####: 2648:    case ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING:
        -: 2649:    {
    #####: 2650:      ret_value = ecma_builtin_array_prototype_object_to_locale_string (obj_p, length);
    #####: 2651:      break;
        -: 2652:    }
    #####: 2653:    case ECMA_ARRAY_PROTOTYPE_JOIN:
        -: 2654:    {
    #####: 2655:      ret_value = ecma_builtin_array_prototype_join (routine_arg_1, obj_p, length);
    #####: 2656:      break;
        -: 2657:    }
    #####: 2658:    case ECMA_ARRAY_PROTOTYPE_POP:
        -: 2659:    {
    #####: 2660:      ret_value = ecma_builtin_array_prototype_object_pop (obj_p, length);
    #####: 2661:      break;
        -: 2662:    }
    #####: 2663:    case ECMA_ARRAY_PROTOTYPE_PUSH:
        -: 2664:    {
    #####: 2665:      ret_value = ecma_builtin_array_prototype_object_push (arguments_list_p,
        -: 2666:                                                            arguments_number,
        -: 2667:                                                            obj_p,
        -: 2668:                                                            length);
    #####: 2669:      break;
        -: 2670:    }
    #####: 2671:    case ECMA_ARRAY_PROTOTYPE_REVERSE:
        -: 2672:    {
    #####: 2673:      ret_value = ecma_builtin_array_prototype_object_reverse (this_arg, obj_p, length);
    #####: 2674:      break;
        -: 2675:    }
    #####: 2676:    case ECMA_ARRAY_PROTOTYPE_SHIFT:
        -: 2677:    {
    #####: 2678:      ret_value = ecma_builtin_array_prototype_object_shift (obj_p, length);
    #####: 2679:      break;
        -: 2680:    }
    #####: 2681:    case ECMA_ARRAY_PROTOTYPE_SLICE:
        -: 2682:    {
    #####: 2683:      ret_value = ecma_builtin_array_prototype_object_slice (routine_arg_1,
        -: 2684:                                                             routine_arg_2,
        -: 2685:                                                             obj_p,
        -: 2686:                                                             length);
    #####: 2687:      break;
        -: 2688:    }
    #####: 2689:    case ECMA_ARRAY_PROTOTYPE_SORT:
        -: 2690:    {
    #####: 2691:      ret_value = ecma_builtin_array_prototype_object_sort (this_arg,
        -: 2692:                                                            routine_arg_1,
        -: 2693:                                                            obj_p,
        -: 2694:                                                            length);
    #####: 2695:      break;
        -: 2696:    }
    #####: 2697:    case ECMA_ARRAY_PROTOTYPE_SPLICE:
        -: 2698:    {
    #####: 2699:      ret_value = ecma_builtin_array_prototype_object_splice (arguments_list_p,
        -: 2700:                                                              arguments_number,
        -: 2701:                                                              obj_p,
        -: 2702:                                                              length);
    #####: 2703:      break;
        -: 2704:    }
    #####: 2705:    case ECMA_ARRAY_PROTOTYPE_UNSHIFT:
        -: 2706:    {
    #####: 2707:      ret_value = ecma_builtin_array_prototype_object_unshift (arguments_list_p,
        -: 2708:                                                               arguments_number,
        -: 2709:                                                               obj_p,
        -: 2710:                                                               length);
    #####: 2711:      break;
        -: 2712:    }
    #####: 2713:    case ECMA_ARRAY_PROTOTYPE_INDEX_OF:
        -: 2714:    {
    #####: 2715:      ret_value = ecma_builtin_array_prototype_object_index_of (arguments_list_p,
        -: 2716:                                                                arguments_number,
        -: 2717:                                                                obj_p,
        -: 2718:                                                                length);
    #####: 2719:      break;
        -: 2720:    }
    #####: 2721:    case ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF:
        -: 2722:    {
    #####: 2723:      ret_value = ecma_builtin_array_prototype_object_last_index_of (arguments_list_p,
        -: 2724:                                                                     arguments_number,
        -: 2725:                                                                     obj_p,
        -: 2726:                                                                     length);
    #####: 2727:      break;
        -: 2728:    }
    #####: 2729:    case ECMA_ARRAY_PROTOTYPE_EVERY:
        -: 2730:    case ECMA_ARRAY_PROTOTYPE_SOME:
        -: 2731:    case ECMA_ARRAY_PROTOTYPE_FOR_EACH:
        -: 2732:    {
    #####: 2733:      ret_value = ecma_builtin_array_apply (routine_arg_1,
        -: 2734:                                            routine_arg_2,
    #####: 2735:                                            (array_routine_mode) builtin_routine_id - ECMA_ARRAY_PROTOTYPE_EVERY,
        -: 2736:                                            obj_p,
        -: 2737:                                            length);
    #####: 2738:      break;
        -: 2739:    }
    #####: 2740:    case ECMA_ARRAY_PROTOTYPE_MAP:
        -: 2741:    {
    #####: 2742:      ret_value = ecma_builtin_array_prototype_object_map (routine_arg_1,
        -: 2743:                                                           routine_arg_2,
        -: 2744:                                                           obj_p,
        -: 2745:                                                           length);
    #####: 2746:      break;
        -: 2747:    }
    #####: 2748:    case ECMA_ARRAY_PROTOTYPE_REDUCE:
        -: 2749:    case ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT:
        -: 2750:    {
    #####: 2751:      ret_value = ecma_builtin_array_reduce_from (arguments_list_p,
        -: 2752:                                                  arguments_number,
        -: 2753:                                                  builtin_routine_id == ECMA_ARRAY_PROTOTYPE_REDUCE,
        -: 2754:                                                  obj_p,
        -: 2755:                                                  length);
    #####: 2756:      break;
        -: 2757:    }
        -: 2758:#if ENABLED (JERRY_ES2015)
    #####: 2759:    case ECMA_ARRAY_PROTOTYPE_COPY_WITHIN:
        -: 2760:    {
    #####: 2761:      ret_value = ecma_builtin_array_prototype_object_copy_within (arguments_list_p,
        -: 2762:                                                                   arguments_number,
        -: 2763:                                                                   obj_p,
        -: 2764:                                                                   length);
    #####: 2765:      break;
        -: 2766:    }
    #####: 2767:    case ECMA_ARRAY_PROTOTYPE_FIND:
        -: 2768:    case ECMA_ARRAY_PROTOTYPE_FIND_INDEX:
        -: 2769:    {
    #####: 2770:      ret_value = ecma_builtin_array_prototype_object_find (routine_arg_1,
        -: 2771:                                                            routine_arg_2,
        -: 2772:                                                            builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FIND,
        -: 2773:                                                            obj_p,
        -: 2774:                                                            length);
    #####: 2775:      break;
        -: 2776:    }
    #####: 2777:    case ECMA_ARRAY_PROTOTYPE_FILL:
        -: 2778:    {
    #####: 2779:      ret_value = ecma_builtin_array_prototype_fill (routine_arg_1,
        -: 2780:                                                     routine_arg_2,
    #####: 2781:                                                     arguments_list_p[2],
        -: 2782:                                                     obj_p,
        -: 2783:                                                     length);
    #####: 2784:      break;
        -: 2785:    }
        -: 2786:#endif /* ENABLED (JERRY_ES2015) */
    #####: 2787:    default:
        -: 2788:    {
    #####: 2789:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FILTER);
        -: 2790:
    #####: 2791:      ret_value = ecma_builtin_array_prototype_object_filter (routine_arg_1,
        -: 2792:                                                              routine_arg_2,
        -: 2793:                                                              obj_p,
        -: 2794:                                                              length);
    #####: 2795:      break;
        -: 2796:    }
        -: 2797:  }
        -: 2798:
    #####: 2799:  ecma_free_value (len_value);
    #####: 2800:  ecma_deref_object (obj_p);
        -: 2801:
    #####: 2802:  return ret_value;
        -: 2803:} /* ecma_builtin_array_prototype_dispatch_routine */
        -: 2804:
        -: 2805:/**
        -: 2806: * @}
        -: 2807: * @}
        -: 2808: * @}
        -: 2809: */
        -: 2810:
        -: 2811:#endif /* ENABLED (JERRY_BUILTIN_ARRAY) */
