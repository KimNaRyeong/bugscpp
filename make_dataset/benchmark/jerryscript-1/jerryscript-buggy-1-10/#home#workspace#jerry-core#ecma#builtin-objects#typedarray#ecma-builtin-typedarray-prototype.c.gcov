        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/typedarray/ecma-builtin-typedarray-prototype.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-arraybuffer-object.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-builtin-typedarray-helpers.h"
        -:   21:#include "ecma-builtins.h"
        -:   22:#include "ecma-comparison.h"
        -:   23:#include "ecma-conversion.h"
        -:   24:#include "ecma-exceptions.h"
        -:   25:#include "ecma-function-object.h"
        -:   26:#include "ecma-gc.h"
        -:   27:#include "ecma-globals.h"
        -:   28:#include "ecma-helpers.h"
        -:   29:#include "ecma-iterator-object.h"
        -:   30:#include "ecma-number-object.h"
        -:   31:#include "ecma-objects.h"
        -:   32:#include "ecma-try-catch-macro.h"
        -:   33:#include "ecma-typedarray-object.h"
        -:   34:#include "jcontext.h"
        -:   35:#include "jmem.h"
        -:   36:#include "jrt-libc-includes.h"
        -:   37:#include "jrt.h"
        -:   38:#include "lit-char-helpers.h"
        -:   39:
        -:   40:#if ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY)
        -:   41:
        -:   42:#define ECMA_BUILTINS_INTERNAL
        -:   43:#include "ecma-builtins-internal.h"
        -:   44:
        -:   45:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-typedarray-prototype.inc.h"
        -:   46:#define BUILTIN_UNDERSCORED_ID typedarray_prototype
        -:   47:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   48:
        -:   49:/** \addtogroup ecma ECMA
        -:   50: * @{
        -:   51: *
        -:   52: * \addtogroup ecmabuiltins
        -:   53: * @{
        -:   54: *
        -:   55: * \addtogroup typedarrayprototype ECMA %TypedArray%.prototype object built-in
        -:   56: * @{
        -:   57: */
        -:   58:
        -:   59:/**
        -:   60: * The %TypedArray%.prototype.buffer accessor
        -:   61: *
        -:   62: * See also:
        -:   63: *          ES2015, 22.2.3.1
        -:   64: *
        -:   65: * @return ecma value
        -:   66: *         Returned value must be freed with ecma_free_value.
        -:   67: */
        -:   68:static ecma_value_t
    #####:   69:ecma_builtin_typedarray_prototype_buffer_getter (ecma_value_t this_arg) /**< this argument */
        -:   70:{
    #####:   71:  if (ecma_is_typedarray (this_arg))
        -:   72:  {
    #####:   73:    ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####:   74:    ecma_object_t *obj_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####:   75:    ecma_ref_object (obj_p);
        -:   76:
    #####:   77:    return ecma_make_object_value (obj_p);
        -:   78:  }
        -:   79:
    #####:   80:  return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:   81:} /* ecma_builtin_typedarray_prototype_buffer_getter */
        -:   82:
        -:   83:/**
        -:   84: * The %TypedArray%.prototype.byteLength accessor
        -:   85: *
        -:   86: * See also:
        -:   87: *          ES2015, 22.2.3.2
        -:   88: *
        -:   89: * @return ecma value
        -:   90: *         Returned value must be freed with ecma_free_value.
        -:   91: */
        -:   92:static ecma_value_t
    #####:   93:ecma_builtin_typedarray_prototype_bytelength_getter (ecma_value_t this_arg) /**< this argument */
        -:   94:{
    #####:   95:  if (ecma_is_typedarray (this_arg))
        -:   96:  {
    #####:   97:    ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####:   98:    uint8_t shift = ecma_typedarray_get_element_size_shift (typedarray_p);
        -:   99:
    #####:  100:    return ecma_make_uint32_value (ecma_typedarray_get_length (typedarray_p) << shift);
        -:  101:  }
        -:  102:
    #####:  103:  return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  104:} /* ecma_builtin_typedarray_prototype_bytelength_getter */
        -:  105:
        -:  106:/**
        -:  107: * The %TypedArray%.prototype.byteOffset accessor
        -:  108: *
        -:  109: * See also:
        -:  110: *          ES2015, 22.2.3.3
        -:  111: *
        -:  112: * @return ecma value
        -:  113: *         Returned value must be freed with ecma_free_value.
        -:  114: */
        -:  115:static ecma_value_t
    #####:  116:ecma_builtin_typedarray_prototype_byteoffset_getter (ecma_value_t this_arg) /**< this argument */
        -:  117:{
    #####:  118:  if (ecma_is_typedarray (this_arg))
        -:  119:  {
    #####:  120:    ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
        -:  121:
    #####:  122:    return ecma_make_uint32_value (ecma_typedarray_get_offset (typedarray_p));
        -:  123:  }
        -:  124:
    #####:  125:  return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  126:} /* ecma_builtin_typedarray_prototype_byteoffset_getter */
        -:  127:
        -:  128:/**
        -:  129: * The %TypedArray%.prototype.length accessor
        -:  130: *
        -:  131: * See also:
        -:  132: *          ES2015, 22.2.3.17
        -:  133: *
        -:  134: * @return ecma value
        -:  135: *         Returned value must be freed with ecma_free_value.
        -:  136: */
        -:  137:static ecma_value_t
    #####:  138:ecma_builtin_typedarray_prototype_length_getter (ecma_value_t this_arg) /**< this argument */
        -:  139:{
    #####:  140:  if (ecma_is_typedarray (this_arg))
        -:  141:  {
    #####:  142:    ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
        -:  143:
    #####:  144:    return ecma_make_uint32_value (ecma_typedarray_get_length (typedarray_p));
        -:  145:  }
        -:  146:
    #####:  147:  return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  148:} /* ecma_builtin_typedarray_prototype_length_getter */
        -:  149:
        -:  150:#if ENABLED (JERRY_ES2015)
        -:  151:/**
        -:  152: * The %TypedArray%.prototype[Symbol.toStringTag] accessor
        -:  153: *
        -:  154: * See also:
        -:  155: *          ES2015, 22.2.3.31
        -:  156: *
        -:  157: * @return ecma value
        -:  158: *         Returned value must be freed with ecma_free_value.
        -:  159: */
        -:  160:static ecma_value_t
    #####:  161:ecma_builtin_typedarray_prototype_to_string_tag_getter (ecma_value_t this_arg) /**< this argument */
        -:  162:{
    #####:  163:  if (!ecma_is_typedarray (this_arg))
        -:  164:  {
    #####:  165:    return ECMA_VALUE_UNDEFINED;
        -:  166:  }
        -:  167:
    #####:  168:  return ecma_make_magic_string_value (ecma_object_get_class_name (ecma_get_object_from_value (this_arg)));
        -:  169:} /* ecma_builtin_typedarray_prototype_to_string_tag_getter */
        -:  170:#endif /* ENABLED (JERRY_ES2015) */
        -:  171:
        -:  172:/**
        -:  173: * Type of routine.
        -:  174: */
        -:  175:typedef enum
        -:  176:{
        -:  177:  TYPEDARRAY_ROUTINE_EVERY, /**< routine: every ES2015, 22.2.3.7 */
        -:  178:  TYPEDARRAY_ROUTINE_SOME, /**< routine: some ES2015, 22.2.3.9 */
        -:  179:  TYPEDARRAY_ROUTINE_FOREACH, /**< routine: forEach ES2015, 15.4.4.18 */
        -:  180:  TYPEDARRAY_ROUTINE__COUNT /**< count of the modes */
        -:  181:} typedarray_routine_mode;
        -:  182:
        -:  183:/**
        -:  184: * The common function for 'every', 'some' and 'forEach'
        -:  185: * because they have a similar structure.
        -:  186: *
        -:  187: * @return ecma value
        -:  188: *         Returned value must be freed with ecma_free_value.
        -:  189: */
        -:  190:static ecma_value_t
    #####:  191:ecma_builtin_typedarray_prototype_exec_routine (ecma_value_t this_arg, /**< this argument */
        -:  192:                                                ecma_value_t cb_func_val, /**< callback function */
        -:  193:                                                ecma_value_t cb_this_arg, /**< 'this' of the callback function */
        -:  194:                                                typedarray_routine_mode mode) /**< mode: which routine */
        -:  195:{
    #####:  196:  JERRY_ASSERT (mode < TYPEDARRAY_ROUTINE__COUNT);
        -:  197:
    #####:  198:  if (!ecma_is_typedarray (this_arg))
        -:  199:  {
    #####:  200:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  201:  }
        -:  202:
    #####:  203:  if (!ecma_op_is_callable (cb_func_val))
        -:  204:  {
    #####:  205:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -:  206:  }
        -:  207:
    #####:  208:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
    #####:  209:  ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
    #####:  210:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (obj_p);
    #####:  211:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  212:  {
    #####:  213:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -:  214:  }
        -:  215:
    #####:  216:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info.id);
        -:  217:
    #####:  218:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
    #####:  219:  ecma_length_t byte_pos = 0;
    #####:  220:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  221:
    #####:  222:  for (uint32_t index = 0; index < info.length && ecma_is_value_empty (ret_value); index++)
        -:  223:  {
    #####:  224:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  225:    ecma_number_t element_num = typedarray_getter_cb (info.buffer_p + byte_pos);
    #####:  226:    ecma_value_t get_value = ecma_make_number_value (element_num);
        -:  227:
    #####:  228:    ecma_value_t call_args[] = { get_value, current_index, this_arg };
        -:  229:
    #####:  230:    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  231:
    #####:  232:    ecma_fast_free_value (current_index);
    #####:  233:    ecma_fast_free_value (get_value);
        -:  234:
    #####:  235:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  236:    {
    #####:  237:      return call_value;
        -:  238:    }
        -:  239:
    #####:  240:    bool to_bool_result = ecma_op_to_boolean (call_value);
    #####:  241:    ecma_free_value (call_value);
        -:  242:
    #####:  243:    if (mode == TYPEDARRAY_ROUTINE_EVERY)
        -:  244:    {
    #####:  245:      if (!to_bool_result)
        -:  246:      {
    #####:  247:        return ECMA_VALUE_FALSE;
        -:  248:      }
        -:  249:    }
    #####:  250:    else if (mode == TYPEDARRAY_ROUTINE_SOME
    #####:  251:             && to_bool_result)
        -:  252:    {
    #####:  253:      return ECMA_VALUE_TRUE;
        -:  254:    }
        -:  255:
    #####:  256:    byte_pos += info.element_size;
        -:  257:  }
        -:  258:
    #####:  259:  if (mode == TYPEDARRAY_ROUTINE_EVERY)
        -:  260:  {
    #####:  261:    ret_value = ECMA_VALUE_TRUE;
        -:  262:  }
    #####:  263:  else if (mode == TYPEDARRAY_ROUTINE_SOME)
        -:  264:  {
    #####:  265:    ret_value = ECMA_VALUE_FALSE;
        -:  266:  }
        -:  267:  else
        -:  268:  {
    #####:  269:    ret_value = ECMA_VALUE_UNDEFINED;
        -:  270:  }
        -:  271:
    #####:  272:  return ret_value;
        -:  273:} /* ecma_builtin_typedarray_prototype_exec_routine */
        -:  274:
        -:  275:/**
        -:  276: * The %TypedArray%.prototype object's 'every' routine
        -:  277: *
        -:  278: * See also:
        -:  279: *          ES2015, 22.2.3.7
        -:  280: *
        -:  281: * @return ecma value
        -:  282: *         Returned value must be freed with ecma_free_value.
        -:  283: */
        -:  284:static ecma_value_t
    #####:  285:ecma_builtin_typedarray_prototype_every (ecma_value_t this_arg, /**< this argument */
        -:  286:                                         ecma_value_t cb_func_val, /**< callback function */
        -:  287:                                         ecma_value_t cb_this_arg) /**< this' of the callback function */
        -:  288:{
    #####:  289:  return ecma_builtin_typedarray_prototype_exec_routine (this_arg,
        -:  290:                                                         cb_func_val,
        -:  291:                                                         cb_this_arg,
        -:  292:                                                         TYPEDARRAY_ROUTINE_EVERY);
        -:  293:} /* ecma_builtin_typedarray_prototype_every */
        -:  294:
        -:  295:/**
        -:  296: * The %TypedArray%.prototype object's 'some' routine
        -:  297: *
        -:  298: * See also:
        -:  299: *          ES2015, 22.2.3.9
        -:  300: *
        -:  301: * @return ecma value
        -:  302: *         Returned value must be freed with ecma_free_value.
        -:  303: */
        -:  304:static ecma_value_t
    #####:  305:ecma_builtin_typedarray_prototype_some (ecma_value_t this_arg, /**< this argument */
        -:  306:                                        ecma_value_t cb_func_val, /**< callback function */
        -:  307:                                        ecma_value_t cb_this_arg) /**< this' of the callback function */
        -:  308:{
    #####:  309:  return ecma_builtin_typedarray_prototype_exec_routine (this_arg,
        -:  310:                                                         cb_func_val,
        -:  311:                                                         cb_this_arg,
        -:  312:                                                         TYPEDARRAY_ROUTINE_SOME);
        -:  313:} /* ecma_builtin_typedarray_prototype_some */
        -:  314:
        -:  315:/**
        -:  316: * The %TypedArray%.prototype object's 'forEach' routine
        -:  317: *
        -:  318: * See also:
        -:  319: *          ES2015, 15.4.4.18
        -:  320: *
        -:  321: * @return ecma value
        -:  322: *         Returned value must be freed with ecma_free_value.
        -:  323: */
        -:  324:static ecma_value_t
    #####:  325:ecma_builtin_typedarray_prototype_for_each (ecma_value_t this_arg, /**< this argument */
        -:  326:                                            ecma_value_t cb_func_val, /**< callback function */
        -:  327:                                            ecma_value_t cb_this_arg) /**< this' of the callback function */
        -:  328:{
    #####:  329:  return ecma_builtin_typedarray_prototype_exec_routine (this_arg,
        -:  330:                                                         cb_func_val,
        -:  331:                                                         cb_this_arg,
        -:  332:                                                         TYPEDARRAY_ROUTINE_FOREACH);
        -:  333:} /* ecma_builtin_typedarray_prototype_for_each */
        -:  334:
        -:  335:#if ENABLED (JERRY_ES2015)
        -:  336:
        -:  337:/**
        -:  338: * Helper function for typedArray.prototype object's {'keys', 'values', 'entries', '@@iterator'}
        -:  339: * routines common parts.
        -:  340: *
        -:  341: * See also:
        -:  342: *          ECMA-262 v6, 22.2.3.15
        -:  343: *          ECMA-262 v6, 22.2.3.29
        -:  344: *          ECMA-262 v6, 22.2.3.6
        -:  345: *          ECMA-262 v6, 22.1.3.30
        -:  346: *
        -:  347: * Note:
        -:  348: *      Returned value must be freed with ecma_free_value.
        -:  349: *
        -:  350: * @return iterator result object, if success
        -:  351: *         error - otherwise
        -:  352: */
        -:  353:static ecma_value_t
    #####:  354:ecma_builtin_typedarray_iterators_helper (ecma_value_t this_arg, /**< this argument */
        -:  355:                                          uint8_t type) /**< any combination of ecma_iterator_type_t bits */
        -:  356:{
    #####:  357:  if (!ecma_is_typedarray (this_arg))
        -:  358:  {
    #####:  359:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  360:  }
        -:  361:
    #####:  362:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE);
        -:  363:
    #####:  364:  return ecma_op_create_iterator_object (this_arg,
        -:  365:                                         prototype_obj_p,
        -:  366:                                         ECMA_PSEUDO_ARRAY_ITERATOR,
        -:  367:                                         type);
        -:  368:} /* ecma_builtin_typedarray_iterators_helper */
        -:  369:
        -:  370:/**
        -:  371: * The %TypedArray%.prototype object's 'keys' routine
        -:  372: *
        -:  373: * See also:
        -:  374: *          ES2015, 22.2.3.15
        -:  375: *          ES2015, 22.1.3.30
        -:  376: *
        -:  377: * @return ecma value
        -:  378: *         Returned value must be freed with ecma_free_value.
        -:  379: */
        -:  380:static ecma_value_t
    #####:  381:ecma_builtin_typedarray_prototype_keys (ecma_value_t this_arg) /**< this argument */
        -:  382:{
    #####:  383:  return ecma_builtin_typedarray_iterators_helper (this_arg, ECMA_ITERATOR_KEYS);
        -:  384:} /* ecma_builtin_typedarray_prototype_keys */
        -:  385:
        -:  386:/**
        -:  387: * The %TypedArray%.prototype object's 'values' and @@iterator routines
        -:  388: *
        -:  389: * See also:
        -:  390: *          ES2015, 22.2.3.29
        -:  391: *          ES2015, 22.1.3.30
        -:  392: *
        -:  393: * @return ecma value
        -:  394: *         Returned value must be freed with ecma_free_value.
        -:  395: */
        -:  396:static ecma_value_t
    #####:  397:ecma_builtin_typedarray_prototype_values (ecma_value_t this_arg) /**< this argument */
        -:  398:{
    #####:  399:  return ecma_builtin_typedarray_iterators_helper (this_arg, ECMA_ITERATOR_VALUES);
        -:  400:} /* ecma_builtin_typedarray_prototype_values */
        -:  401:
        -:  402:/**
        -:  403: * The %TypedArray%.prototype object's 'entries' routine
        -:  404: *
        -:  405: * See also:
        -:  406: *          ES2015, 22.2.3.6
        -:  407: *          ES2015, 22.1.3.30
        -:  408: *
        -:  409: * @return ecma value
        -:  410: *         Returned value must be freed with ecma_free_value.
        -:  411: */
        -:  412:static ecma_value_t
    #####:  413:ecma_builtin_typedarray_prototype_entries (ecma_value_t this_arg) /**< this argument */
        -:  414:{
    #####:  415:  return ecma_builtin_typedarray_iterators_helper (this_arg, ECMA_ITERATOR_KEYS_VALUES);
        -:  416:} /* ecma_builtin_typedarray_prototype_entries */
        -:  417:
        -:  418:#endif /* ENABLED (JERRY_ES2015) */
        -:  419:
        -:  420:/**
        -:  421: * The %TypedArray%.prototype object's 'map' routine
        -:  422: *
        -:  423: * See also:
        -:  424: *          ES2015, 22.2.3.8
        -:  425: *
        -:  426: * @return ecma value
        -:  427: *         Returned value must be freed with ecma_free_value.
        -:  428: */
        -:  429:static ecma_value_t
    #####:  430:ecma_builtin_typedarray_prototype_map (ecma_value_t this_arg, /**< this argument */
        -:  431:                                       ecma_value_t cb_func_val, /**< callback function */
        -:  432:                                       ecma_value_t cb_this_arg) /**< this' of the callback function */
        -:  433:{
    #####:  434:  if (!ecma_is_typedarray (this_arg))
        -:  435:  {
    #####:  436:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  437:  }
        -:  438:
    #####:  439:  if (!ecma_op_is_callable (cb_func_val))
        -:  440:  {
    #####:  441:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -:  442:  }
        -:  443:
    #####:  444:  ecma_object_t *src_obj_p = ecma_get_object_from_value (this_arg);
    #####:  445:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (src_obj_p);
    #####:  446:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  447:  {
    #####:  448:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -:  449:  }
        -:  450:
    #####:  451:  ecma_typedarray_info_t src_info = ecma_typedarray_get_info (src_obj_p);
        -:  452:
    #####:  453:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
        -:  454:
        -:  455:  // TODO: 22.2.3.18, 7-8.
    #####:  456:  ecma_value_t new_typedarray = ecma_op_create_typedarray_with_type_and_length (src_info.id, src_info.length);
        -:  457:
    #####:  458:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  459:  {
    #####:  460:    return new_typedarray;
        -:  461:  }
        -:  462:
    #####:  463:  ecma_object_t *target_obj_p = ecma_get_object_from_value (new_typedarray);
    #####:  464:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (target_obj_p);
        -:  465:
    #####:  466:  ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_info.id);
    #####:  467:  ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  468:
    #####:  469:  ecma_length_t src_byte_pos = 0;
        -:  470:
    #####:  471:  for (uint32_t index = 0; index < src_info.length; index++)
        -:  472:  {
    #####:  473:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  474:    ecma_number_t element_num = src_typedarray_getter_cb (src_info.buffer_p + src_byte_pos);
    #####:  475:    ecma_value_t get_value = ecma_make_number_value (element_num);
    #####:  476:    ecma_value_t call_args[] = { get_value, current_index, this_arg };
        -:  477:
    #####:  478:    ecma_value_t mapped_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
    #####:  479:    if (ECMA_IS_VALUE_ERROR (mapped_value))
        -:  480:    {
    #####:  481:      ecma_free_value (current_index);
    #####:  482:      ecma_free_value (get_value);
    #####:  483:      ecma_free_value (new_typedarray);
    #####:  484:      return mapped_value;
        -:  485:    }
        -:  486:
    #####:  487:    ecma_number_t mapped_num;
    #####:  488:    if (ECMA_IS_VALUE_ERROR (ecma_get_number (mapped_value, &mapped_num)))
        -:  489:    {
    #####:  490:      ecma_free_value (mapped_value);
    #####:  491:      ecma_free_value (current_index);
    #####:  492:      ecma_free_value (get_value);
    #####:  493:      ecma_free_value (new_typedarray);
    #####:  494:      return ECMA_VALUE_ERROR;
        -:  495:    }
        -:  496:    else
        -:  497:    {
    #####:  498:      ecma_length_t target_byte_pos = index << target_info.shift;
    #####:  499:      target_typedarray_setter_cb (target_info.buffer_p + target_byte_pos, mapped_num);
        -:  500:    }
        -:  501:
    #####:  502:    src_byte_pos += src_info.element_size;
        -:  503:
    #####:  504:    ecma_fast_free_value (mapped_value);
    #####:  505:    ecma_fast_free_value (current_index);
    #####:  506:    ecma_fast_free_value (get_value);
        -:  507:  }
        -:  508:
    #####:  509:  return new_typedarray;
        -:  510:} /* ecma_builtin_typedarray_prototype_map */
        -:  511:
        -:  512:/**
        -:  513: * Reduce and reduceRight routines share a similar structure.
        -:  514: * And we use 'is_right' to distinguish between them.
        -:  515: *
        -:  516: * @return ecma value
        -:  517: *         Returned value must be freed with ecma_free_value.
        -:  518: */
        -:  519:static ecma_value_t
    #####:  520:ecma_builtin_typedarray_prototype_reduce_with_direction (ecma_value_t this_arg, /**< this argument */
        -:  521:                                                         ecma_value_t cb_func_val, /**< callback function */
        -:  522:                                                         ecma_value_t initial_val, /**< initial value */
        -:  523:                                                         bool is_right) /**< choose order, true is reduceRight */
        -:  524:{
    #####:  525:  if (!ecma_is_typedarray (this_arg))
        -:  526:  {
    #####:  527:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  528:  }
        -:  529:
    #####:  530:  if (!ecma_op_is_callable (cb_func_val))
        -:  531:  {
    #####:  532:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -:  533:  }
        -:  534:
    #####:  535:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
    #####:  536:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (obj_p);
    #####:  537:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  538:  {
    #####:  539:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -:  540:  }
        -:  541:
    #####:  542:  ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
        -:  543:
    #####:  544:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info.id);
        -:  545:  ecma_length_t byte_pos;
        -:  546:
    #####:  547:  if (info.length == 0)
        -:  548:  {
    #####:  549:    if (ecma_is_value_undefined (initial_val))
        -:  550:    {
    #####:  551:      return ecma_raise_type_error (ECMA_ERR_MSG ("Initial value cannot be undefined."));
        -:  552:    }
        -:  553:
    #####:  554:    return ecma_copy_value (initial_val);
        -:  555:  }
        -:  556:
    #####:  557:  JERRY_ASSERT (info.length > 0);
        -:  558:
    #####:  559:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
    #####:  560:  uint32_t index = is_right ? (info.length - 1) : 0;
        -:  561:
    #####:  562:  if (ecma_is_value_undefined (initial_val))
        -:  563:  {
    #####:  564:    byte_pos = index << info.shift;
    #####:  565:    ecma_number_t acc_num = getter_cb (info.buffer_p + byte_pos);
    #####:  566:    accumulator = ecma_make_number_value (acc_num);
        -:  567:
    #####:  568:    JERRY_ASSERT (ecma_is_value_number (accumulator));
        -:  569:
    #####:  570:    if (is_right)
        -:  571:    {
    #####:  572:      if (index == 0)
        -:  573:      {
    #####:  574:        return accumulator;
        -:  575:      }
        -:  576:
    #####:  577:      index--;
        -:  578:    }
        -:  579:    else
        -:  580:    {
    #####:  581:      index++;
        -:  582:
    #####:  583:      if (index == info.length)
        -:  584:      {
    #####:  585:        return accumulator;
        -:  586:      }
        -:  587:    }
        -:  588:  }
        -:  589:  else
        -:  590:  {
    #####:  591:    accumulator = ecma_copy_value (initial_val);
        -:  592:  }
        -:  593:
    #####:  594:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
        -:  595:
        -:  596:  while (true)
    #####:  597:  {
    #####:  598:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  599:    byte_pos = index << info.shift;
    #####:  600:    ecma_number_t get_num = getter_cb (info.buffer_p + byte_pos);
    #####:  601:    ecma_value_t get_value = ecma_make_number_value (get_num);
        -:  602:
    #####:  603:    ecma_value_t call_args[] = { accumulator, get_value, current_index, this_arg };
        -:  604:
    #####:  605:    JERRY_ASSERT (ecma_is_value_number (get_value));
        -:  606:
    #####:  607:    ecma_value_t call_value = ecma_op_function_call (func_object_p,
        -:  608:                                                     ECMA_VALUE_UNDEFINED,
        -:  609:                                                     call_args,
        -:  610:                                                     4);
        -:  611:
    #####:  612:    ecma_fast_free_value (accumulator);
    #####:  613:    ecma_fast_free_value (get_value);
    #####:  614:    ecma_fast_free_value (current_index);
        -:  615:
    #####:  616:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  617:    {
    #####:  618:      return call_value;
        -:  619:    }
        -:  620:
    #####:  621:    accumulator = call_value;
        -:  622:
    #####:  623:    if (is_right)
        -:  624:    {
    #####:  625:      if (index == 0)
        -:  626:      {
    #####:  627:        break;
        -:  628:      }
        -:  629:
    #####:  630:      index--;
        -:  631:    }
        -:  632:    else
        -:  633:    {
    #####:  634:      index++;
        -:  635:
    #####:  636:      if (index == info.length)
        -:  637:      {
    #####:  638:        break;
        -:  639:      }
        -:  640:    }
        -:  641:  }
        -:  642:
    #####:  643:  return accumulator;
        -:  644:} /* ecma_builtin_typedarray_prototype_reduce_with_direction */
        -:  645:
        -:  646:/**
        -:  647: * The %TypedArray%.prototype object's 'reduce' routine
        -:  648: *
        -:  649: * See also:
        -:  650: *          ES2015, 22.2.3.19
        -:  651: *
        -:  652: * @return ecma value
        -:  653: *         Returned value must be freed with ecma_free_value.
        -:  654: */
        -:  655:static ecma_value_t
    #####:  656:ecma_builtin_typedarray_prototype_reduce (ecma_value_t this_arg, /**< this argument */
        -:  657:                                          ecma_value_t cb_func_val, /**< callback function */
        -:  658:                                          ecma_value_t initial_val) /**< initial value */
        -:  659:{
    #####:  660:  return ecma_builtin_typedarray_prototype_reduce_with_direction (this_arg,
        -:  661:                                                                  cb_func_val,
        -:  662:                                                                  initial_val,
        -:  663:                                                                  false);
        -:  664:} /* ecma_builtin_typedarray_prototype_reduce */
        -:  665:
        -:  666:/**
        -:  667: * The %TypedArray%.prototype object's 'reduceRight' routine
        -:  668: *
        -:  669: * See also:
        -:  670: *          ES2015, 22.2.3.20
        -:  671: *
        -:  672: * @return ecma value
        -:  673: *         Returned value must be freed with ecma_free_value.
        -:  674: */
        -:  675:static ecma_value_t
    #####:  676:ecma_builtin_typedarray_prototype_reduce_right (ecma_value_t this_arg, /**< this argument */
        -:  677:                                                ecma_value_t cb_func_val, /**< callback function */
        -:  678:                                                ecma_value_t initial_val) /**< initial value */
        -:  679:{
    #####:  680:  return ecma_builtin_typedarray_prototype_reduce_with_direction (this_arg,
        -:  681:                                                                  cb_func_val,
        -:  682:                                                                  initial_val,
        -:  683:                                                                  true);
        -:  684:} /* ecma_builtin_typedarray_prototype_reduce_right */
        -:  685:
        -:  686:/**
        -:  687: * The %TypedArray%.prototype object's 'filter' routine
        -:  688: *
        -:  689: * See also:
        -:  690: *          ES2015, 22.2.3.9
        -:  691: *
        -:  692: * @return ecma value
        -:  693: *         Returned value must be freed with ecma_free_value.
        -:  694: */
        -:  695:static ecma_value_t
    #####:  696:ecma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, /**< this argument */
        -:  697:                                          ecma_value_t cb_func_val, /**< callback function */
        -:  698:                                          ecma_value_t cb_this_arg) /**< 'this' of the callback function */
        -:  699:{
    #####:  700:  if (!ecma_is_typedarray (this_arg))
        -:  701:  {
    #####:  702:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  703:  }
        -:  704:
    #####:  705:  if (!ecma_op_is_callable (cb_func_val))
        -:  706:  {
    #####:  707:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -:  708:  }
        -:  709:
    #####:  710:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
    #####:  711:  ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
        -:  712:
    #####:  713:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info.id);
        -:  714:
    #####:  715:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
    #####:  716:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  717:
        -:  718:  // TODO: 22.2.3.9, 7-8.
    #####:  719:  if (info.length == 0)
        -:  720:  {
    #####:  721:    return ecma_op_create_typedarray_with_type_and_length (info.id, 0);
        -:  722:  }
        -:  723:
    #####:  724:  JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, info.length * info.element_size, lit_utf8_byte_t);
        -:  725:
    #####:  726:  lit_utf8_byte_t *pass_value_p = pass_value_list_p;
    #####:  727:  ecma_length_t byte_pos = 0;
        -:  728:
    #####:  729:  for (uint32_t index = 0; index < info.length; index++)
        -:  730:  {
    #####:  731:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  732:    ecma_number_t get_num = getter_cb (info.buffer_p + byte_pos);
    #####:  733:    ecma_value_t get_value = ecma_make_number_value (get_num);
        -:  734:
    #####:  735:    JERRY_ASSERT (ecma_is_value_number (get_value));
        -:  736:
    #####:  737:    ecma_value_t call_args[] = { get_value, current_index, this_arg };
        -:  738:
    #####:  739:    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  740:
    #####:  741:    ecma_fast_free_value (current_index);
    #####:  742:    ecma_fast_free_value (get_value);
        -:  743:
    #####:  744:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  745:    {
    #####:  746:      goto cleanup;
        -:  747:    }
        -:  748:
    #####:  749:    if (ecma_op_to_boolean (call_value))
        -:  750:    {
    #####:  751:      memcpy (pass_value_p, info.buffer_p + byte_pos, info.element_size);
    #####:  752:      pass_value_p += info.element_size;
        -:  753:    }
        -:  754:
    #####:  755:    byte_pos += info.element_size;
        -:  756:
    #####:  757:    ecma_free_value (call_value);
        -:  758:  }
        -:  759:
    #####:  760:  uint32_t pass_num = (uint32_t) ((pass_value_p - pass_value_list_p) >> info.shift);
        -:  761:
    #####:  762:  ret_value = ecma_op_create_typedarray_with_type_and_length (info.id, pass_num);
        -:  763:
    #####:  764:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -:  765:  {
    #####:  766:    obj_p = ecma_get_object_from_value (ret_value);
        -:  767:
    #####:  768:    JERRY_ASSERT (ecma_typedarray_get_offset (obj_p) == 0);
        -:  769:
    #####:  770:    memcpy (ecma_typedarray_get_buffer (obj_p),
        -:  771:            pass_value_list_p,
    #####:  772:            (size_t) (pass_value_p - pass_value_list_p));
        -:  773:  }
        -:  774:
    #####:  775:cleanup:
    #####:  776:  JMEM_FINALIZE_LOCAL_ARRAY (pass_value_list_p);
        -:  777:
    #####:  778:  return ret_value;
        -:  779:} /* ecma_builtin_typedarray_prototype_filter */
        -:  780:
        -:  781:/**
        -:  782: * The %TypedArray%.prototype object's 'reverse' routine
        -:  783: *
        -:  784: * See also:
        -:  785: *          ES2015, 22.2.3.21
        -:  786: *
        -:  787: * @return ecma value
        -:  788: *         Returned value must be freed with ecma_free_value.
        -:  789: */
        -:  790:ecma_value_t
    #####:  791:ecma_builtin_typedarray_prototype_reverse (ecma_value_t this_arg) /**< this argument */
        -:  792:{
    #####:  793:  if (!ecma_is_typedarray (this_arg))
        -:  794:  {
    #####:  795:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  796:  }
        -:  797:
    #####:  798:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
    #####:  799:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (obj_p);
    #####:  800:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  801:  {
    #####:  802:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -:  803:  }
        -:  804:
    #####:  805:  ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
        -:  806:
    #####:  807:  uint32_t middle = (info.length / 2) << info.shift;
    #####:  808:  uint32_t buffer_last = (info.length << info.shift) - info.element_size;
        -:  809:
    #####:  810:  for (uint32_t lower = 0; lower < middle; lower += info.element_size)
        -:  811:  {
    #####:  812:    uint32_t upper = buffer_last - lower;
    #####:  813:    lit_utf8_byte_t *lower_p = info.buffer_p + lower;
    #####:  814:    lit_utf8_byte_t *upper_p = info.buffer_p + upper;
        -:  815:
    #####:  816:    lit_utf8_byte_t tmp[8];
    #####:  817:    memcpy (&tmp[0], lower_p, info.element_size);
    #####:  818:    memcpy (lower_p, upper_p, info.element_size);
    #####:  819:    memcpy (upper_p, &tmp[0], info.element_size);
        -:  820:  }
        -:  821:
    #####:  822:  return ecma_copy_value (this_arg);
        -:  823:} /* ecma_builtin_typedarray_prototype_reverse */
        -:  824:
        -:  825:/**
        -:  826: * The %TypedArray%.prototype object's 'set' routine for a typedArray source
        -:  827: *
        -:  828: * See also:
        -:  829: *          ES2015, 22.2.3.22, 22.2.3.22.2
        -:  830: *
        -:  831: * @return ecma value of undefined if success, error otherwise.
        -:  832: *         Returned value must be freed with ecma_free_value.
        -:  833: */
        -:  834:static ecma_value_t
    #####:  835:ecma_op_typedarray_set_with_typedarray (ecma_value_t this_arg, /**< this argument */
        -:  836:                                        ecma_value_t arr_val, /**< typedarray object */
        -:  837:                                        ecma_value_t offset_val) /**< offset value */
        -:  838:{
        -:  839:  /* 6.~ 8. targetOffset */
    #####:  840:  ecma_number_t target_offset_num;
    #####:  841:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (offset_val, &target_offset_num)))
        -:  842:  {
    #####:  843:    return ECMA_VALUE_ERROR;
        -:  844:  }
        -:  845:
    #####:  846:  if (target_offset_num <= -1.0 || target_offset_num >= (ecma_number_t) UINT32_MAX + 0.5)
        -:  847:  {
    #####:  848:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset"));
        -:  849:  }
        -:  850:
    #####:  851:  ecma_object_t *target_typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  852:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (target_typedarray_p);
    #####:  853:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  854:  {
    #####:  855:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -:  856:  }
        -:  857:
    #####:  858:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (target_typedarray_p);
        -:  859:
    #####:  860:  ecma_object_t *src_typedarray_p = ecma_get_object_from_value (arr_val);
    #####:  861:  ecma_object_t *src_arraybuffer_p = ecma_typedarray_get_arraybuffer (src_typedarray_p);
    #####:  862:  if (ecma_arraybuffer_is_detached (src_arraybuffer_p))
        -:  863:  {
    #####:  864:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -:  865:  }
        -:  866:
    #####:  867:  ecma_typedarray_info_t src_info = ecma_typedarray_get_info (src_typedarray_p);
        -:  868:
    #####:  869:  uint32_t target_offset_uint32 = ecma_number_to_uint32 (target_offset_num);
        -:  870:
    #####:  871:  if ((int64_t) src_info.length + target_offset_uint32 > target_info.length)
        -:  872:  {
    #####:  873:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid range of index"));
        -:  874:  }
        -:  875:
        -:  876:  /* Fast path first. If the source and target arrays are the same we do not need to copy anything. */
    #####:  877:  if (this_arg == arr_val)
        -:  878:  {
    #####:  879:    return ECMA_VALUE_UNDEFINED;
        -:  880:  }
        -:  881:
        -:  882:  /* 26. targetByteIndex */
    #####:  883:  uint32_t target_byte_index = target_offset_uint32 * target_info.element_size;
        -:  884:
        -:  885:  /* 27. limit */
    #####:  886:  uint32_t limit = target_byte_index + target_info.element_size * src_info.length;
        -:  887:
    #####:  888:  if (src_info.id == target_info.id)
        -:  889:  {
    #####:  890:    memmove (target_info.buffer_p + target_byte_index, src_info.buffer_p,
    #####:  891:             target_info.element_size * src_info.length);
        -:  892:  }
        -:  893:  else
        -:  894:  {
    #####:  895:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_info.id);
    #####:  896:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  897:
    #####:  898:    uint32_t src_byte_index = 0;
    #####:  899:    while (target_byte_index < limit)
        -:  900:    {
    #####:  901:      ecma_number_t elem_num = src_typedarray_getter_cb (src_info.buffer_p + src_byte_index);
    #####:  902:      target_typedarray_setter_cb (target_info.buffer_p + target_byte_index, elem_num);
    #####:  903:      src_byte_index += src_info.element_size;
    #####:  904:      target_byte_index += target_info.element_size;
        -:  905:    }
        -:  906:  }
        -:  907:
    #####:  908:  return ECMA_VALUE_UNDEFINED;
        -:  909:} /* ecma_op_typedarray_set_with_typedarray */
        -:  910:
        -:  911:/**
        -:  912: * The %TypedArray%.prototype object's 'set' routine
        -:  913: *
        -:  914: * See also:
        -:  915: *          ES2015, 22.2.3.22, 22.2.3.22.1
        -:  916: *
        -:  917: * @return ecma value of undefined if success, error otherwise.
        -:  918: *         Returned value must be freed with ecma_free_value.
        -:  919: */
        -:  920:ecma_value_t
    #####:  921:ecma_builtin_typedarray_prototype_set (ecma_value_t this_arg, /**< this argument */
        -:  922:                                       ecma_value_t arr_val, /**< array object */
        -:  923:                                       ecma_value_t offset_val) /**< offset value */
        -:  924:{
        -:  925:  /* 2.~ 4. */
    #####:  926:  if (!ecma_is_typedarray (this_arg))
        -:  927:  {
    #####:  928:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -:  929:  }
        -:  930:
        -:  931:  /* 1. */
    #####:  932:  if (ecma_is_typedarray (arr_val))
        -:  933:  {
        -:  934:    /* 22.2.3.22.2 */
    #####:  935:    return ecma_op_typedarray_set_with_typedarray (this_arg, arr_val, offset_val);
        -:  936:  }
        -:  937:
        -:  938:  /* 6.~ 8. targetOffset */
    #####:  939:  ecma_number_t target_offset_num;
    #####:  940:  ecma_value_t ret_val = ecma_op_to_integer (offset_val, &target_offset_num);
        -:  941:
    #####:  942:  if (ECMA_IS_VALUE_ERROR (ret_val))
        -:  943:  {
    #####:  944:    return ret_val;
        -:  945:  }
        -:  946:
    #####:  947:  if (target_offset_num <= -1.0 || target_offset_num >= (ecma_number_t) UINT32_MAX + 0.5)
        -:  948:  {
    #####:  949:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset"));
        -:  950:  }
    #####:  951:  uint32_t target_offset_uint32 = ecma_number_to_uint32 (target_offset_num);
        -:  952:
        -:  953:  /* 11. ~ 15. */
    #####:  954:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  955:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####:  956:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  957:  {
    #####:  958:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -:  959:  }
        -:  960:
    #####:  961:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (typedarray_p);
        -:  962:
        -:  963:  /* 16.~ 17. */
    #####:  964:  ECMA_TRY_CATCH (source_obj, ecma_op_to_object (arr_val), ret_val);
        -:  965:
        -:  966:  /* 18.~ 19. */
    #####:  967:  ecma_object_t *source_obj_p = ecma_get_object_from_value (source_obj);
        -:  968:
    #####:  969:  ECMA_TRY_CATCH (source_length,
        -:  970:                  ecma_op_object_get_by_magic_id (source_obj_p, LIT_MAGIC_STRING_LENGTH),
        -:  971:                  ret_val);
        -:  972:
    #####:  973:  uint32_t source_length_uint32;
    #####:  974:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_length (source_length, &source_length_uint32)))
        -:  975:  {
    #####:  976:    return ECMA_VALUE_ERROR;
        -:  977:  }
        -:  978:
        -:  979:  /* 20. if srcLength + targetOffset > targetLength, throw a RangeError */
    #####:  980:  if ((int64_t) source_length_uint32 + target_offset_uint32 > target_info.length)
        -:  981:  {
    #####:  982:    ret_val = ecma_raise_range_error (ECMA_ERR_MSG ("Invalid range of index"));
        -:  983:  }
        -:  984:
        -:  985:  /* 21.~ 25. */
    #####:  986:  uint32_t target_byte_index = target_offset_uint32 * target_info.element_size;
    #####:  987:  uint32_t k = 0;
        -:  988:
    #####:  989:  ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  990:
    #####:  991:  while (k < source_length_uint32 && ecma_is_value_empty (ret_val))
        -:  992:  {
    #####:  993:    ECMA_TRY_CATCH (elem,
        -:  994:                    ecma_op_object_get_by_uint32_index (source_obj_p, k),
        -:  995:                    ret_val);
        -:  996:
    #####:  997:    ECMA_OP_TO_NUMBER_TRY_CATCH (elem_num, elem, ret_val);
        -:  998:
    #####:  999:    target_typedarray_setter_cb (target_info.buffer_p + target_byte_index, elem_num);
        -: 1000:
        -: 1001:    ECMA_OP_TO_NUMBER_FINALIZE (elem_num);
    #####: 1002:    ECMA_FINALIZE (elem);
        -: 1003:
    #####: 1004:    k++;
    #####: 1005:    target_byte_index += target_info.element_size;
        -: 1006:  }
        -: 1007:
    #####: 1008:  ECMA_FINALIZE (source_length);
    #####: 1009:  ECMA_FINALIZE (source_obj);
        -: 1010:
    #####: 1011:  if (ecma_is_value_empty (ret_val))
        -: 1012:  {
    #####: 1013:    ret_val = ECMA_VALUE_UNDEFINED;
        -: 1014:  }
    #####: 1015:  return ret_val;
        -: 1016:} /* ecma_builtin_typedarray_prototype_set */
        -: 1017:
        -: 1018:/**
        -: 1019: * TypedArray.prototype's 'toString' single element operation routine based
        -: 1020: * on the Array.prototype's 'toString' single element operation routine
        -: 1021: *
        -: 1022: * See also:
        -: 1023: *          ECMA-262 v5.1, 15.4.4.2
        -: 1024: *
        -: 1025: * @return NULL - if the converison fails
        -: 1026: *         ecma_string_t * - otherwise
        -: 1027: */
        -: 1028:static ecma_string_t *
    #####: 1029:ecma_op_typedarray_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -: 1030:                                           uint32_t index) /**< array index */
        -: 1031:{
    #####: 1032:  ecma_value_t index_value = ecma_op_object_get_by_uint32_index (obj_p, index);
        -: 1033:
    #####: 1034:  if (ECMA_IS_VALUE_ERROR (index_value))
        -: 1035:  {
    #####: 1036:    return NULL;
        -: 1037:  }
        -: 1038:
    #####: 1039:  if (ecma_is_value_undefined (index_value)
    #####: 1040:      || ecma_is_value_null (index_value))
        -: 1041:  {
    #####: 1042:    ecma_free_value (index_value);
    #####: 1043:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 1044:  }
        -: 1045:
    #####: 1046:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -: 1047:
    #####: 1048:  ecma_free_value (index_value);
        -: 1049:
    #####: 1050:  return ret_str_p;
        -: 1051:} /* ecma_op_typedarray_get_to_string_at_index */
        -: 1052:
        -: 1053:/**
        -: 1054: * The TypedArray.prototype.toString's separator creation routine based on
        -: 1055: * the Array.prototype.toString's separator routine
        -: 1056: *
        -: 1057: * See also:
        -: 1058: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -: 1059: *
        -: 1060: * @return NULL - if the conversion fails
        -: 1061: *         ecma_string_t * - otherwise
        -: 1062: */
        -: 1063:static ecma_string_t *
    #####: 1064:ecma_op_typedarray_get_separator_string (ecma_value_t separator) /**< possible separator */
        -: 1065:{
    #####: 1066:  if (ecma_is_value_undefined (separator))
        -: 1067:  {
    #####: 1068:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -: 1069:  }
        -: 1070:
    #####: 1071:  return ecma_op_to_string (separator);
        -: 1072:} /* ecma_op_typedarray_get_separator_string */
        -: 1073:
        -: 1074:/**
        -: 1075: * The TypedArray.prototype object's 'join' routine basen on
        -: 1076: * the Array.porottype object's 'join'
        -: 1077: *
        -: 1078: * See also:
        -: 1079: *          ECMA-262 v5, 15.4.4.5
        -: 1080: *
        -: 1081: * @return ecma value
        -: 1082: *         Returned value must be freed with ecma_free_value.
        -: 1083: */
        -: 1084:static ecma_value_t
    #####: 1085:ecma_builtin_typedarray_prototype_join (ecma_value_t this_arg, /**< this argument */
        -: 1086:                                        ecma_value_t separator_arg) /**< separator argument */
        -: 1087:{
        -: 1088:  /* 1. */
    #####: 1089:  ecma_value_t obj_value = ecma_op_to_object (this_arg);
        -: 1090:
    #####: 1091:  if (ECMA_IS_VALUE_ERROR (obj_value))
        -: 1092:  {
    #####: 1093:    return obj_value;
        -: 1094:  }
    #####: 1095:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
        -: 1096:
        -: 1097:  /* 2. */
    #####: 1098:  ecma_value_t length_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_LENGTH);
        -: 1099:
    #####: 1100:  if (ECMA_IS_VALUE_ERROR (length_value))
        -: 1101:  {
    #####: 1102:    ecma_free_value (obj_value);
    #####: 1103:    return length_value;
        -: 1104:  }
        -: 1105:
    #####: 1106:  ecma_number_t length_number;
        -: 1107:
    #####: 1108:  if (ECMA_IS_VALUE_ERROR (ecma_get_number (length_value, &length_number)))
        -: 1109:  {
    #####: 1110:    ecma_free_value (length_value);
    #####: 1111:    ecma_free_value (obj_value);
    #####: 1112:    return ECMA_VALUE_ERROR;
        -: 1113:  }
        -: 1114:
    #####: 1115:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -: 1116:
        -: 1117:  /* 3. */
    #####: 1118:  uint32_t length = ecma_number_to_uint32 (length_number);
        -: 1119:
    #####: 1120:  if (length == 0)
        -: 1121:  {
        -: 1122:    /* 6. */
    #####: 1123:    ecma_free_value (length_value);
    #####: 1124:    ecma_free_value (obj_value);
    #####: 1125:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1126:  }
        -: 1127:  else
        -: 1128:  {
    #####: 1129:    ecma_string_t *separator_string_p = ecma_op_typedarray_get_separator_string (separator_arg);
        -: 1130:
    #####: 1131:    if (JERRY_UNLIKELY (separator_string_p == NULL))
        -: 1132:    {
    #####: 1133:      goto cleanup;
        -: 1134:    }
        -: 1135:
        -: 1136:    /* 7-8. */
    #####: 1137:    ecma_string_t *first_string_p = ecma_op_typedarray_get_to_string_at_index (obj_p, 0);
        -: 1138:
    #####: 1139:    if (JERRY_UNLIKELY (first_string_p == NULL))
        -: 1140:    {
    #####: 1141:      ecma_deref_ecma_string (separator_string_p);
    #####: 1142:      goto cleanup;
        -: 1143:    }
        -: 1144:
    #####: 1145:    ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
        -: 1146:
    #####: 1147:    ecma_deref_ecma_string (first_string_p);
        -: 1148:
        -: 1149:    /* 9-10. */
    #####: 1150:    for (uint32_t k = 1; k < length; k++)
        -: 1151:    {
        -: 1152:      /* 10.a */
    #####: 1153:      ecma_stringbuilder_append (&builder, separator_string_p);
        -: 1154:
        -: 1155:      /* 10.d */
    #####: 1156:      ecma_string_t *next_string_p = ecma_op_typedarray_get_to_string_at_index (obj_p, k);
        -: 1157:
    #####: 1158:      if (JERRY_UNLIKELY (next_string_p == NULL))
        -: 1159:      {
    #####: 1160:        ecma_stringbuilder_destroy (&builder);
    #####: 1161:        ecma_deref_ecma_string (separator_string_p);
    #####: 1162:        goto cleanup;
        -: 1163:      }
        -: 1164:
    #####: 1165:      ecma_stringbuilder_append (&builder, next_string_p);
        -: 1166:
    #####: 1167:      ecma_deref_ecma_string (next_string_p);
        -: 1168:    }
        -: 1169:
    #####: 1170:    ecma_deref_ecma_string (separator_string_p);
    #####: 1171:    ret_value = ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 1172:  }
        -: 1173:
    #####: 1174:cleanup:
    #####: 1175:  ecma_free_value (length_value);
    #####: 1176:  ecma_free_value (obj_value);
        -: 1177:
    #####: 1178:  return ret_value;
        -: 1179:} /* ecma_builtin_typedarray_prototype_join */
        -: 1180:
        -: 1181:/**
        -: 1182: * The TypedArray.prototype object's 'toString' routine basen on
        -: 1183: * the Array.porottype object's 'toString'
        -: 1184: *
        -: 1185: * See also:
        -: 1186: *          ECMA-262 v5, 15.4.4.2
        -: 1187: *
        -: 1188: * @return ecma value
        -: 1189: *         Returned value must be freed with ecma_free_value.
        -: 1190: */
        -: 1191:static ecma_value_t
    #####: 1192:ecma_builtin_typedarray_prototype_object_to_string (ecma_value_t this_arg) /**< this argument */
        -: 1193:{
    #####: 1194:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1195:
        -: 1196:  /* 1. */
    #####: 1197:  ecma_value_t obj_this_value = ecma_op_to_object (this_arg);
    #####: 1198:  if (ECMA_IS_VALUE_ERROR (obj_this_value))
        -: 1199:  {
    #####: 1200:    return obj_this_value;
        -: 1201:  }
    #####: 1202:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_this_value);
        -: 1203:
        -: 1204:  /* 2. */
    #####: 1205:  ecma_value_t join_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_JOIN);
    #####: 1206:  if (ECMA_IS_VALUE_ERROR (join_value))
        -: 1207:  {
    #####: 1208:    ecma_free_value (obj_this_value);
    #####: 1209:    return join_value;
        -: 1210:  }
        -: 1211:
    #####: 1212:  if (!ecma_op_is_callable (join_value))
        -: 1213:  {
        -: 1214:    /* 3. */
    #####: 1215:    ret_value = ecma_builtin_helper_object_to_string (this_arg);
        -: 1216:  }
        -: 1217:  else
        -: 1218:  {
        -: 1219:    /* 4. */
    #####: 1220:    ecma_object_t *join_func_obj_p = ecma_get_object_from_value (join_value);
        -: 1221:
    #####: 1222:    ret_value = ecma_op_function_call (join_func_obj_p, this_arg, NULL, 0);
        -: 1223:  }
        -: 1224:
    #####: 1225:  ecma_free_value (join_value);
    #####: 1226:  ecma_free_value (obj_this_value);
        -: 1227:
    #####: 1228:  return ret_value;
        -: 1229:} /* ecma_builtin_typedarray_prototype_object_to_string */
        -: 1230:
        -: 1231:/**
        -: 1232: * The %TypedArray%.prototype object's 'subarray' routine.
        -: 1233: *
        -: 1234: * See also:
        -: 1235: *          ES2015, 22.2.3.26
        -: 1236: *
        -: 1237: * @return ecma value
        -: 1238: *         Returned value must be freed with ecma_free_value.
        -: 1239: */
        -: 1240:static ecma_value_t
    #####: 1241:ecma_builtin_typedarray_prototype_subarray (ecma_value_t this_arg, /**< this argument */
        -: 1242:                                            ecma_value_t begin, /**< begin */
        -: 1243:                                            ecma_value_t end) /**< end */
        -: 1244:{
    #####: 1245:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1246:
        -: 1247:  /* 2.~ 4. */
    #####: 1248:  if (!ecma_is_typedarray (this_arg))
        -: 1249:  {
    #####: 1250:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 1251:  }
        -: 1252:
    #####: 1253:  ecma_object_t *src_typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1254:  ecma_typedarray_info_t info = ecma_typedarray_get_info (src_typedarray_p);
        -: 1255:
        -: 1256:  /* 9. beginIndex, 12. endIndex */
    #####: 1257:  uint32_t begin_index_uint32 = 0, end_index_uint32 = 0;
        -: 1258:
        -: 1259:  /* 7. relativeBegin */
    #####: 1260:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (begin,
        -: 1261:                                                                      info.length,
        -: 1262:                                                                      &begin_index_uint32)))
        -: 1263:  {
    #####: 1264:    return ECMA_VALUE_ERROR;
        -: 1265:  }
        -: 1266:
    #####: 1267:  if (ecma_is_value_undefined (end))
        -: 1268:  {
    #####: 1269:    end_index_uint32 = (uint32_t) info.length;
        -: 1270:  }
        -: 1271:  else
        -: 1272:  {
        -: 1273:    /* 10. relativeEnd */
    #####: 1274:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (end,
        -: 1275:                                                                        info.length,
        -: 1276:                                                                        &end_index_uint32)))
        -: 1277:    {
    #####: 1278:      return ECMA_VALUE_ERROR;
        -: 1279:    }
        -: 1280:  }
        -: 1281:
    #####: 1282:  if (!ecma_is_value_empty (ret_value))
        -: 1283:  {
    #####: 1284:    return ret_value;
        -: 1285:  }
        -: 1286:
        -: 1287:  /* 13. newLength */
    #####: 1288:  ecma_length_t subarray_length = 0;
        -: 1289:
    #####: 1290:  if (end_index_uint32 > begin_index_uint32)
        -: 1291:  {
    #####: 1292:    subarray_length = end_index_uint32 - begin_index_uint32;
        -: 1293:  }
        -: 1294:
        -: 1295:  /* 17. beginByteOffset */
    #####: 1296:  ecma_length_t begin_byte_offset = info.offset + begin_index_uint32 * info.element_size;
        -: 1297:
    #####: 1298:  ecma_value_t arguments_p[3] =
        -: 1299:  {
    #####: 1300:    ecma_make_object_value (info.array_buffer_p),
    #####: 1301:    ecma_make_uint32_value (begin_byte_offset),
    #####: 1302:    ecma_make_uint32_value (subarray_length)
        -: 1303:  };
        -: 1304:
    #####: 1305:  ret_value = ecma_typedarray_helper_dispatch_construct (arguments_p, 3, info.id);
        -: 1306:
    #####: 1307:  ecma_free_value (arguments_p[1]);
    #####: 1308:  ecma_free_value (arguments_p[2]);
    #####: 1309:  return ret_value;
        -: 1310:} /* ecma_builtin_typedarray_prototype_subarray */
        -: 1311:
        -: 1312:/**
        -: 1313: * The %TypedArray%.prototype object's 'fill' routine.
        -: 1314: *
        -: 1315: * See also:
        -: 1316: *          ES2015, 22.2.3.8, 22.1.3.6
        -: 1317: *
        -: 1318: * @return ecma value
        -: 1319: *         Returned value must be freed with ecma_free_value.
        -: 1320: */
        -: 1321:static ecma_value_t
    #####: 1322:ecma_builtin_typedarray_prototype_fill (ecma_value_t this_arg, /**< this argument */
        -: 1323:                                        ecma_value_t value, /**< value */
        -: 1324:                                        ecma_value_t begin, /**< begin */
        -: 1325:                                        ecma_value_t end) /**< end */
        -: 1326:{
    #####: 1327:  if (!ecma_is_typedarray (this_arg))
        -: 1328:  {
    #####: 1329:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 1330:  }
        -: 1331:
    #####: 1332:  ecma_number_t value_num;
    #####: 1333:  ecma_value_t ret_value = ecma_get_number (value, &value_num);
        -: 1334:
    #####: 1335:  if (!ecma_is_value_empty (ret_value))
        -: 1336:  {
    #####: 1337:    return ret_value;
        -: 1338:  }
        -: 1339:
    #####: 1340:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1341:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 1342:
    #####: 1343:  uint32_t begin_index_uint32 = 0, end_index_uint32 = 0;
        -: 1344:
    #####: 1345:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (begin,
        -: 1346:                                                                      info.length,
        -: 1347:                                                                      &begin_index_uint32)))
        -: 1348:  {
    #####: 1349:    return ECMA_VALUE_ERROR;
        -: 1350:  }
        -: 1351:
    #####: 1352:  if (ecma_is_value_undefined (end))
        -: 1353:  {
    #####: 1354:    end_index_uint32 = (uint32_t) info.length;
        -: 1355:  }
        -: 1356:  else
        -: 1357:  {
    #####: 1358:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (end,
        -: 1359:                                                                        info.length,
        -: 1360:                                                                        &end_index_uint32)))
        -: 1361:    {
    #####: 1362:      return ECMA_VALUE_ERROR;
        -: 1363:    }
        -: 1364:  }
        -: 1365:
    #####: 1366:  ecma_length_t subarray_length = 0;
        -: 1367:
    #####: 1368:  if (end_index_uint32 > begin_index_uint32)
        -: 1369:  {
    #####: 1370:    subarray_length = end_index_uint32 - begin_index_uint32;
        -: 1371:  }
        -: 1372:
    #####: 1373:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info.id);
    #####: 1374:  uint32_t byte_index = begin_index_uint32 * info.element_size;
    #####: 1375:  uint32_t limit = byte_index + subarray_length * info.element_size;
        -: 1376:
    #####: 1377:  while (byte_index < limit)
        -: 1378:  {
    #####: 1379:    typedarray_setter_cb (info.buffer_p + byte_index, value_num);
    #####: 1380:    byte_index += info.element_size;
        -: 1381:  }
        -: 1382:
    #####: 1383:  return ecma_copy_value (this_arg);
        -: 1384:} /* ecma_builtin_typedarray_prototype_fill */
        -: 1385:
        -: 1386:/**
        -: 1387: * SortCompare abstract method
        -: 1388: *
        -: 1389: * See also:
        -: 1390: *          ECMA-262 v5, 15.4.4.11
        -: 1391: *
        -: 1392: * @return ecma value
        -: 1393: *         Returned value must be freed with ecma_free_value.
        -: 1394: */
        -: 1395:static ecma_value_t
    #####: 1396:ecma_builtin_typedarray_prototype_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -: 1397:                                                       ecma_value_t rhs, /**< right value */
        -: 1398:                                                       ecma_value_t compare_func) /**< compare function */
        -: 1399:{
    #####: 1400:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####: 1401:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1402:
    #####: 1403:  if (ecma_is_value_undefined (compare_func))
        -: 1404:  {
        -: 1405:    /* Default comparison when no comparefn is passed. */
    #####: 1406:    double lhs_value = (double) ecma_get_number_from_value (lhs);
    #####: 1407:    double rhs_value = (double) ecma_get_number_from_value (rhs);
        -: 1408:
    #####: 1409:    if (ecma_number_is_nan (lhs_value))
        -: 1410:    {
        -: 1411:      // Keep NaNs at the end of the array.
    #####: 1412:      result = ECMA_NUMBER_ONE;
        -: 1413:    }
    #####: 1414:    else if (ecma_number_is_nan (rhs_value))
        -: 1415:    {
        -: 1416:      // Keep NaNs at the end of the array.
    #####: 1417:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1418:    }
    #####: 1419:    else if (lhs_value < rhs_value)
        -: 1420:    {
    #####: 1421:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1422:    }
    #####: 1423:    else if (lhs_value > rhs_value)
        -: 1424:    {
    #####: 1425:      result = ECMA_NUMBER_ONE;
        -: 1426:    }
        -: 1427:    else
        -: 1428:    {
    #####: 1429:      result = ECMA_NUMBER_ZERO;
        -: 1430:    }
        -: 1431:
    #####: 1432:    return ecma_make_number_value (result);
        -: 1433:  }
        -: 1434:
        -: 1435:  /*
        -: 1436:   * compare_func, if not undefined, will always contain a callable function object.
        -: 1437:   * We checked this previously, before this function was called.
        -: 1438:   */
    #####: 1439:  JERRY_ASSERT (ecma_op_is_callable (compare_func));
    #####: 1440:  ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1441:
    #####: 1442:  ecma_value_t compare_args[] = { lhs, rhs };
        -: 1443:
    #####: 1444:  ECMA_TRY_CATCH (call_value,
        -: 1445:                  ecma_op_function_call (comparefn_obj_p,
        -: 1446:                                         ECMA_VALUE_UNDEFINED,
        -: 1447:                                         compare_args,
        -: 1448:                                         2),
        -: 1449:                  ret_value);
        -: 1450:
    #####: 1451:  if (!ecma_is_value_number (call_value))
        -: 1452:  {
    #####: 1453:    ECMA_OP_TO_NUMBER_TRY_CATCH (ret_num, call_value, ret_value);
    #####: 1454:    result = ret_num;
        -: 1455:    ECMA_OP_TO_NUMBER_FINALIZE (ret_num);
        -: 1456:
        -: 1457:    // If the coerced value can't be represented as a Number, compare them as equals.
    #####: 1458:    if (ecma_number_is_nan (result))
        -: 1459:    {
    #####: 1460:      result = ECMA_NUMBER_ZERO;
        -: 1461:    }
        -: 1462:  }
        -: 1463:  else
        -: 1464:  {
    #####: 1465:    result = ecma_get_number_from_value (call_value);
        -: 1466:  }
        -: 1467:
    #####: 1468:  ECMA_FINALIZE (call_value);
        -: 1469:
    #####: 1470:  if (ecma_is_value_empty (ret_value))
        -: 1471:  {
    #####: 1472:    ret_value = ecma_make_number_value (result);
        -: 1473:  }
        -: 1474:
    #####: 1475:  return ret_value;
        -: 1476:} /* ecma_builtin_typedarray_prototype_sort_compare_helper */
        -: 1477:
        -: 1478:/**
        -: 1479: * The %TypedArray%.prototype object's 'sort' routine.
        -: 1480: *
        -: 1481: * See also:
        -: 1482: *          ES2015, 22.2.3.25, 22.1.3.24
        -: 1483: *
        -: 1484: * @return ecma value
        -: 1485: *         Returned value must be freed with ecma_free_value.
        -: 1486: */
        -: 1487:static ecma_value_t
    #####: 1488:ecma_builtin_typedarray_prototype_sort (ecma_value_t this_arg, /**< this argument */
        -: 1489:                                        ecma_value_t compare_func) /**< comparator fn */
        -: 1490:{
    #####: 1491:  if (!ecma_is_typedarray (this_arg))
        -: 1492:  {
    #####: 1493:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 1494:  }
        -: 1495:
    #####: 1496:  if (!ecma_is_value_undefined (compare_func) && !ecma_op_is_callable (compare_func))
        -: 1497:  {
    #####: 1498:    return ecma_raise_type_error (ECMA_ERR_MSG ("Compare function is not callable."));
        -: 1499:  }
        -: 1500:
    #####: 1501:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1502:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1503:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1504:  {
    #####: 1505:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -: 1506:  }
    #####: 1507:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -: 1508:
    #####: 1509:  if (!info.length)
        -: 1510:  {
    #####: 1511:    return ecma_copy_value (this_arg);
        -: 1512:  }
        -: 1513:
    #####: 1514:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1515:
    #####: 1516:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, info.length, ecma_value_t);
        -: 1517:
    #####: 1518:  uint32_t byte_index = 0, buffer_index = 0;
    #####: 1519:  uint32_t limit = info.length * info.element_size;
        -: 1520:
    #####: 1521:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info.id);
        -: 1522:  /* Copy unsorted array into a native c array. */
    #####: 1523:  while (byte_index < limit)
        -: 1524:  {
    #####: 1525:    JERRY_ASSERT (buffer_index < info.length);
    #####: 1526:    ecma_number_t element_num = typedarray_getter_cb (info.buffer_p + byte_index);
    #####: 1527:    ecma_value_t element_value = ecma_make_number_value (element_num);
    #####: 1528:    values_buffer[buffer_index++] = element_value;
    #####: 1529:    byte_index += info.element_size;
        -: 1530:  }
        -: 1531:
    #####: 1532:  JERRY_ASSERT (buffer_index == info.length);
        -: 1533:
    #####: 1534:  const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_typedarray_prototype_sort_compare_helper;
    #####: 1535:  ECMA_TRY_CATCH (sort_value,
        -: 1536:                  ecma_builtin_helper_array_heap_sort_helper (values_buffer,
        -: 1537:                                                              (uint32_t) (info.length - 1),
        -: 1538:                                                              compare_func,
        -: 1539:                                                              sort_cb),
        -: 1540:                  ret_value);
    #####: 1541:  ECMA_FINALIZE (sort_value);
        -: 1542:
    #####: 1543:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info.id);
        -: 1544:
    #####: 1545:  if (ecma_is_value_empty (ret_value))
        -: 1546:  {
    #####: 1547:    byte_index = 0;
    #####: 1548:    buffer_index = 0;
    #####: 1549:    limit = info.length * info.element_size;
        -: 1550:    /* Put sorted values from the native array back into the typedarray buffer. */
    #####: 1551:    while (byte_index < limit)
        -: 1552:    {
    #####: 1553:      JERRY_ASSERT (buffer_index < info.length);
    #####: 1554:      ecma_value_t element_value = values_buffer[buffer_index++];
    #####: 1555:      ecma_number_t element_num = ecma_get_number_from_value (element_value);
    #####: 1556:      typedarray_setter_cb (info.buffer_p + byte_index, element_num);
    #####: 1557:      byte_index += info.element_size;
        -: 1558:    }
        -: 1559:
    #####: 1560:    JERRY_ASSERT (buffer_index == info.length);
        -: 1561:  }
        -: 1562:
        -: 1563:  /* Free values that were copied to the local array. */
    #####: 1564:  for (uint32_t index = 0; index < info.length; index++)
        -: 1565:  {
    #####: 1566:    ecma_free_value (values_buffer[index]);
        -: 1567:  }
        -: 1568:
    #####: 1569:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1570:
    #####: 1571:  if (ecma_is_value_empty (ret_value))
        -: 1572:  {
    #####: 1573:    ret_value = ecma_copy_value (this_arg);
        -: 1574:  }
        -: 1575:
    #####: 1576:  return ret_value;
        -: 1577:} /* ecma_builtin_typedarray_prototype_sort */
        -: 1578:
        -: 1579:/**
        -: 1580: * The %TypedArray%.prototype object's 'find' and 'findIndex' routine helper
        -: 1581: *
        -: 1582: * @return ecma value
        -: 1583: *         Returned value must be freed with ecma_free_value.
        -: 1584: */
        -: 1585:static ecma_value_t
    #####: 1586:ecma_builtin_typedarray_prototype_find_helper (ecma_value_t this_arg, /**< this argument */
        -: 1587:                                               ecma_value_t predicate, /**< callback function */
        -: 1588:                                               ecma_value_t predicate_this_arg, /**< this argument for
        -: 1589:                                                                                 *   invoke predicate */
        -: 1590:                                               bool is_find) /**< true - find routine
        -: 1591:                                                              *   false - findIndex routine */
        -: 1592:{
    #####: 1593:  if (!ecma_is_typedarray (this_arg))
        -: 1594:  {
    #####: 1595:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 1596:  }
        -: 1597:
    #####: 1598:  if (!ecma_op_is_callable (predicate))
        -: 1599:  {
    #####: 1600:    return ecma_raise_type_error (ECMA_ERR_MSG ("Callback function is not callable."));
        -: 1601:  }
        -: 1602:
    #####: 1603:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 1604:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
        -: 1605:
    #####: 1606:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1607:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
    #####: 1608:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1609:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1610:  {
    #####: 1611:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -: 1612:  }
        -: 1613:
    #####: 1614:  uint32_t buffer_index = 0;
    #####: 1615:  uint32_t limit = info.length * info.element_size;
        -: 1616:
    #####: 1617:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info.id);
        -: 1618:
    #####: 1619:  for (uint32_t byte_index = 0; byte_index < limit; byte_index += info.element_size)
        -: 1620:  {
    #####: 1621:    JERRY_ASSERT (buffer_index < info.length);
    #####: 1622:    ecma_number_t element_num = typedarray_getter_cb (info.buffer_p + byte_index);
    #####: 1623:    ecma_value_t element_value = ecma_make_number_value (element_num);
        -: 1624:
    #####: 1625:    ecma_value_t call_args[] = { element_value, ecma_make_uint32_value (buffer_index), this_arg };
        -: 1626:
    #####: 1627:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 1628:
    #####: 1629:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1630:    {
    #####: 1631:      ecma_free_value (element_value);
    #####: 1632:      return call_value;
        -: 1633:    }
        -: 1634:
    #####: 1635:    bool call_result = ecma_op_to_boolean (call_value);
    #####: 1636:    ecma_free_value (call_value);
        -: 1637:
    #####: 1638:    if (call_result)
        -: 1639:    {
    #####: 1640:      if (is_find)
        -: 1641:      {
    #####: 1642:        return element_value;
        -: 1643:      }
        -: 1644:
    #####: 1645:      ecma_free_value (element_value);
    #####: 1646:      return ecma_make_uint32_value (buffer_index);
        -: 1647:    }
    #####: 1648:    buffer_index++;
    #####: 1649:    ecma_free_value (element_value);
        -: 1650:  }
        -: 1651:
    #####: 1652:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 1653:} /* ecma_builtin_typedarray_prototype_find_helper */
        -: 1654:
        -: 1655:/**
        -: 1656: * The %TypedArray%.prototype object's 'find' routine
        -: 1657: *
        -: 1658: * See also:
        -: 1659: *          ECMA-262 v6, 22.2.3.10
        -: 1660: *
        -: 1661: * @return ecma value
        -: 1662: *         Returned value must be freed with ecma_free_value.
        -: 1663: */
        -: 1664:static ecma_value_t
    #####: 1665:ecma_builtin_typedarray_prototype_find (ecma_value_t this_arg, /**< this argument */
        -: 1666:                                        ecma_value_t predicate, /**< callback function */
        -: 1667:                                        ecma_value_t predicate_this_arg) /**< this argument for
        -: 1668:                                                                          *   invoke predicate */
        -: 1669:{
    #####: 1670:  return ecma_builtin_typedarray_prototype_find_helper (this_arg, predicate, predicate_this_arg, true);
        -: 1671:} /* ecma_builtin_typedarray_prototype_find */
        -: 1672:
        -: 1673:/**
        -: 1674: * The %TypedArray%.prototype object's 'findIndex' routine
        -: 1675: *
        -: 1676: * See also:
        -: 1677: *          ECMA-262 v6, 22.2.3.11
        -: 1678: *
        -: 1679: * @return ecma value
        -: 1680: *         Returned value must be freed with ecma_free_value.
        -: 1681: */
        -: 1682:static ecma_value_t
    #####: 1683:ecma_builtin_typedarray_prototype_find_index (ecma_value_t this_arg, /**< this argument */
        -: 1684:                                              ecma_value_t predicate, /**< callback function */
        -: 1685:                                              ecma_value_t predicate_this_arg) /**< this argument for
        -: 1686:                                                                                *   invoke predicate */
        -: 1687:{
    #####: 1688:  return ecma_builtin_typedarray_prototype_find_helper (this_arg, predicate, predicate_this_arg, false);
        -: 1689:} /* ecma_builtin_typedarray_prototype_find_index */
        -: 1690:
        -: 1691:/**
        -: 1692: * The %TypedArray%.prototype object's 'indexOf' routine
        -: 1693: *
        -: 1694: * See also:
        -: 1695: *         ECMA-262 v6, 22.2.3.13
        -: 1696: *
        -: 1697: * @return ecma value
        -: 1698: *         Returned value must be freed with ecma_free_value.
        -: 1699: */
        -: 1700:static ecma_value_t
    #####: 1701:ecma_builtin_typedarray_prototype_index_of (ecma_value_t this_arg, /**< this argument */
        -: 1702:                                            const ecma_value_t args[], /**< arguments list */
        -: 1703:                                            ecma_length_t args_number) /**< number of arguments */
        -: 1704:{
    #####: 1705:  if (!ecma_is_typedarray (this_arg))
        -: 1706:  {
    #####: 1707:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 1708:  }
        -: 1709:
    #####: 1710:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1711:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
    #####: 1712:  if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 1713:  {
    #####: 1714:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -: 1715:  }
        -: 1716:
    #####: 1717:  uint32_t limit = info.length * info.element_size;
        -: 1718:  uint32_t from_index;
        -: 1719:
        -: 1720:   /* 5. */
    #####: 1721:  if (args_number == 0
    #####: 1722:      || !ecma_is_value_number (args[0])
    #####: 1723:      || info.length == 0)
        -: 1724:  {
    #####: 1725:    return ecma_make_integer_value (-1);
        -: 1726:  }
    #####: 1727:  if (args_number == 1)
        -: 1728:  {
    #####: 1729:    from_index = 0;
        -: 1730:  }
        -: 1731:  else
        -: 1732:  {
        -: 1733:    /* 6. 7. */
    #####: 1734:    ecma_number_t num_var;
    #####: 1735:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &num_var)))
        -: 1736:    {
    #####: 1737:      return ECMA_VALUE_ERROR;
        -: 1738:    }
        -: 1739:    /* 8. */
    #####: 1740:    if (num_var >= info.length)
        -: 1741:    {
    #####: 1742:      return ecma_make_integer_value (-1);
        -: 1743:    }
        -: 1744:
        -: 1745:    /* 9. 10. */
    #####: 1746:    from_index = ((num_var >= 0) ? (uint32_t) num_var
    #####: 1747:                                 : (uint32_t) (info.length + num_var));
        -: 1748:  }
        -: 1749:
    #####: 1750:  ecma_number_t search_num = ecma_get_number_from_value (args[0]);
        -: 1751:
    #####: 1752:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info.id);
        -: 1753:
        -: 1754:  /* 11. */
    #####: 1755:  for (int32_t position = (int32_t) from_index * info.element_size;
    #####: 1756:       (uint32_t) position < limit;
    #####: 1757:       position += info.element_size)
        -: 1758:  {
    #####: 1759:    ecma_number_t element_num = getter_cb (info.buffer_p + position);
        -: 1760:
    #####: 1761:    if (search_num == element_num)
        -: 1762:    {
    #####: 1763:      return ecma_make_number_value ((ecma_number_t) position / info.element_size);
        -: 1764:    }
        -: 1765:  }
        -: 1766:
        -: 1767:  /* 12. */
    #####: 1768:  return ecma_make_integer_value (-1);
        -: 1769:} /* ecma_builtin_typedarray_prototype_index_of */
        -: 1770:
        -: 1771:/**
        -: 1772: * The %TypedArray%.prototype object's 'lastIndexOf' routine
        -: 1773: *
        -: 1774: * See also:
        -: 1775: *          ECMA-262 v6, 22.2.3.16
        -: 1776: *
        -: 1777: * @return ecma value
        -: 1778: *         Returned value must be freed with ecma_free_value.
        -: 1779: */
        -: 1780:static ecma_value_t
    #####: 1781:ecma_builtin_typedarray_prototype_last_index_of (ecma_value_t this_arg, /**< this argument */
        -: 1782:                                                const ecma_value_t args[], /**< arguments list */
        -: 1783:                                                ecma_length_t args_number) /**< number of arguments */
        -: 1784:{
    #####: 1785:  if (!ecma_is_typedarray (this_arg))
        -: 1786:  {
    #####: 1787:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 1788:  }
        -: 1789:
    #####: 1790:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1791:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
    #####: 1792:  if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -: 1793:  {
    #####: 1794:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -: 1795:  }
        -: 1796:
        -: 1797:  uint32_t from_index;
        -: 1798:
        -: 1799:  /* 5. */
    #####: 1800:  if (args_number == 0
    #####: 1801:      || !ecma_is_value_number (args[0])
    #####: 1802:      || info.length == 0)
        -: 1803:  {
    #####: 1804:    return ecma_make_integer_value (-1);
        -: 1805:  }
        -: 1806:
    #####: 1807:  if (args_number == 1)
        -: 1808:  {
    #####: 1809:    from_index = info.length - 1;
        -: 1810:  }
        -: 1811:  else
        -: 1812:  {
        -: 1813:    /* 6. 7. */
    #####: 1814:    ecma_number_t num_var;
    #####: 1815:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &num_var)))
        -: 1816:    {
    #####: 1817:      return ECMA_VALUE_ERROR;
        -: 1818:    }
        -: 1819:
    #####: 1820:    if (!ecma_number_is_nan (num_var)
    #####: 1821:        && -num_var > info.length)
        -: 1822:    {
    #####: 1823:      return ecma_make_integer_value (-1);
        -: 1824:    }
        -: 1825:
        -: 1826:    /* 8. 9. */
    #####: 1827:    from_index = ((num_var >= 0) ? (uint32_t) JERRY_MIN (num_var, info.length - 1)
    #####: 1828:                                 : (uint32_t) (info.length + num_var));
        -: 1829:  }
        -: 1830:
    #####: 1831:  ecma_number_t search_num = ecma_get_number_from_value (args[0]);
        -: 1832:
    #####: 1833:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info.id);
        -: 1834:
        -: 1835:  /* 10. */
    #####: 1836:  for (int32_t position = (int32_t) from_index * info.element_size;
        -: 1837:       position >= 0;
    #####: 1838:       position += -info.element_size)
        -: 1839:  {
    #####: 1840:    ecma_number_t element_num = getter_cb (info.buffer_p + position);
        -: 1841:
    #####: 1842:    if (search_num == element_num)
        -: 1843:    {
    #####: 1844:      return ecma_make_number_value ((ecma_number_t) position / info.element_size);
        -: 1845:    }
        -: 1846:  }
        -: 1847:
        -: 1848:  /* 11. */
    #####: 1849:  return ecma_make_integer_value (-1);
        -: 1850:} /* ecma_builtin_typedarray_prototype_last_index_of */
        -: 1851:
        -: 1852:/**
        -: 1853: * The %TypedArray%.prototype object's 'copyWithin' routine
        -: 1854: *
        -: 1855: * See also:
        -: 1856: *          ECMA-262 v6, 22.2.3.5
        -: 1857: *
        -: 1858: * @return ecma value
        -: 1859: *         Returned value must be freed with ecma_free_value.
        -: 1860: */
        -: 1861:static ecma_value_t
    #####: 1862:ecma_builtin_typedarray_prototype_copy_within (ecma_value_t this_arg, /**< this argument */
        -: 1863:                                               const ecma_value_t args[], /**< arguments list */
        -: 1864:                                               ecma_length_t args_number) /**< number of arguments */
        -: 1865:{
    #####: 1866:  if (!ecma_is_typedarray (this_arg))
        -: 1867:  {
    #####: 1868:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 1869:  }
        -: 1870:
    #####: 1871:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1872:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
    #####: 1873:  uint32_t relative_target = 0;
    #####: 1874:  uint32_t relative_start = 0;
    #####: 1875:  uint32_t relative_end = info.length;
        -: 1876:
    #####: 1877:  if (args_number > 0)
        -: 1878:  {
    #####: 1879:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0],
        -: 1880:                                                                        info.length,
        -: 1881:                                                                        &relative_target)))
        -: 1882:    {
    #####: 1883:      return ECMA_VALUE_ERROR;
        -: 1884:    }
        -: 1885:
    #####: 1886:    if (args_number > 1)
        -: 1887:    {
    #####: 1888:      if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1],
        -: 1889:                                                                          info.length,
        -: 1890:                                                                          &relative_start)))
        -: 1891:      {
    #####: 1892:        return ECMA_VALUE_ERROR;
        -: 1893:      }
        -: 1894:
    #####: 1895:      if (args_number > 2 && args[2] != ECMA_VALUE_UNDEFINED)
        -: 1896:      {
    #####: 1897:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[2],
        -: 1898:                                                                            info.length,
        -: 1899:                                                                            &relative_end)))
        -: 1900:        {
    #####: 1901:          return ECMA_VALUE_ERROR;
        -: 1902:        }
        -: 1903:      }
        -: 1904:    }
        -: 1905:  }
        -: 1906:
    #####: 1907:  if (relative_target >= info.length || relative_start >= relative_end || relative_end == 0)
        -: 1908:  {
    #####: 1909:    return ecma_copy_value (this_arg);
        -: 1910:  }
        -: 1911:  else
        -: 1912:  {
    #####: 1913:    uint32_t distance = relative_end - relative_start;
    #####: 1914:    uint32_t offset = info.length - relative_target;
    #####: 1915:    uint32_t count = JERRY_MIN (distance, offset);
        -: 1916:
    #####: 1917:    memmove (info.buffer_p + (relative_target * info.element_size),
    #####: 1918:             info.buffer_p + (relative_start * info.element_size),
    #####: 1919:             (size_t) (count * info.element_size));
        -: 1920:  }
        -: 1921:
    #####: 1922:  return ecma_copy_value (this_arg);
        -: 1923:} /* ecma_builtin_typedarray_prototype_copy_within */
        -: 1924:
        -: 1925:/**
        -: 1926: * The %TypedArray%.prototype object's 'slice' routine
        -: 1927: *
        -: 1928: * See also:
        -: 1929: *          ECMA-262 v6, 22.2.3.23
        -: 1930: *
        -: 1931: * @return ecma value
        -: 1932: *         Returned value must be freed with ecma_free_value.
        -: 1933: */
        -: 1934:static ecma_value_t
    #####: 1935:ecma_builtin_typedarray_prototype_slice (ecma_value_t this_arg, /**< this argument */
        -: 1936:                                         const ecma_value_t args[], /**< arguments list */
        -: 1937:                                         ecma_length_t args_number) /**< number of arguments */
        -: 1938:{
    #####: 1939:  if (!ecma_is_typedarray (this_arg))
        -: 1940:  {
    #####: 1941:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 1942:  }
        -: 1943:
    #####: 1944:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1945:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1946:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -: 1947:  {
    #####: 1948:    return ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has been detached."));
        -: 1949:  }
        -: 1950:
    #####: 1951:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
    #####: 1952:  uint32_t relative_start = 0;
    #####: 1953:  uint32_t relative_end = info.length;
        -: 1954:
    #####: 1955:  if (args_number > 0)
        -: 1956:  {
    #####: 1957:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0],
        -: 1958:                                                                        info.length,
        -: 1959:                                                                        &relative_start)))
        -: 1960:    {
    #####: 1961:      return ECMA_VALUE_ERROR;
        -: 1962:    }
        -: 1963:
    #####: 1964:    if (args_number > 1
    #####: 1965:        && args[1] != ECMA_VALUE_UNDEFINED
    #####: 1966:        && ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1],
        -: 1967:                                                                           info.length,
        -: 1968:                                                                           &relative_end)))
        -: 1969:    {
    #####: 1970:      return ECMA_VALUE_ERROR;
        -: 1971:    }
        -: 1972:  }
        -: 1973:
    #####: 1974:  int32_t distance = (int32_t) (relative_end - relative_start);
    #####: 1975:  uint32_t count = distance > 0 ? (uint32_t) distance : 0;
        -: 1976:
        -: 1977:  // TODO: 22.2.3.23, 12-13.
    #####: 1978:  ecma_value_t new_typedarray = ecma_op_create_typedarray_with_type_and_length (info.id, count);
        -: 1979:
    #####: 1980:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1981:  {
    #####: 1982:    return new_typedarray;
        -: 1983:  }
        -: 1984:
    #####: 1985:  if (count > 0)
        -: 1986:  {
    #####: 1987:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
        -: 1988:
    #####: 1989:    lit_utf8_byte_t *new_typedarray_buffer_p = ecma_typedarray_get_buffer (new_typedarray_p);
    #####: 1990:    uint32_t src_byte_index = (relative_start * info.element_size);
        -: 1991:
    #####: 1992:    memcpy (new_typedarray_buffer_p,
    #####: 1993:            info.buffer_p + src_byte_index,
    #####: 1994:            count * info.element_size);
        -: 1995:  }
        -: 1996:
    #####: 1997:  return new_typedarray;
        -: 1998:} /* ecma_builtin_typedarray_prototype_slice */
        -: 1999:
        -: 2000:/**
        -: 2001: * The TypedArray.prototype's 'toLocaleString' single element operation routine.
        -: 2002: *
        -: 2003: * See also:
        -: 2004: *          ECMA-262 v6, 22.1.3.26 steps 7-10 and 12.b-e
        -: 2005: *
        -: 2006: * @return ecma value
        -: 2007: *         Returned value must be freed with ecma_free_value.
        -: 2008:*/
        -: 2009:static ecma_value_t
    #####: 2010:ecma_builtin_typedarray_prototype_to_locale_string_helper (ecma_object_t *this_obj, /**< TypedArray object */
        -: 2011:                                                           uint32_t index) /** array index */
        -: 2012:{
    #####: 2013:  ecma_typedarray_type_t class_id = ecma_get_typedarray_id (this_obj);
    #####: 2014:  lit_utf8_byte_t *typedarray_buffer_p = ecma_typedarray_get_buffer (this_obj);
        -: 2015:
    #####: 2016:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####: 2017:  ecma_number_t element_num = ecma_get_typedarray_element (typedarray_buffer_p + index, class_id);
    #####: 2018:  ecma_value_t element_value = ecma_make_number_value (element_num);
        -: 2019:
    #####: 2020:  ecma_value_t element_obj = ecma_op_create_number_object (element_value);
        -: 2021:
    #####: 2022:  ecma_free_value (element_value);
        -: 2023:
    #####: 2024:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (element_obj));
        -: 2025:
    #####: 2026:  ecma_object_t *element_obj_p = ecma_get_object_from_value (element_obj);
        -: 2027:
    #####: 2028:  ecma_value_t func_value = ecma_op_object_get_by_magic_id (element_obj_p,
        -: 2029:                                                            LIT_MAGIC_STRING_TO_LOCALE_STRING_UL);
        -: 2030:
    #####: 2031:  if (ECMA_IS_VALUE_ERROR (func_value))
        -: 2032:  {
    #####: 2033:    ecma_deref_object (element_obj_p);
    #####: 2034:    return func_value;
        -: 2035:  }
        -: 2036:
    #####: 2037:  if (ecma_op_is_callable (func_value))
        -: 2038:  {
    #####: 2039:    ecma_object_t *func_obj = ecma_get_object_from_value (func_value);
    #####: 2040:    ecma_value_t call_value = ecma_op_function_call (func_obj,
        -: 2041:                                                     element_obj,
        -: 2042:                                                     NULL,
        -: 2043:                                                     0);
        -: 2044:
    #####: 2045:    ecma_deref_object (func_obj);
        -: 2046:
    #####: 2047:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2048:    {
    #####: 2049:      ecma_deref_object (element_obj_p);
    #####: 2050:      return call_value;
        -: 2051:    }
        -: 2052:
    #####: 2053:    ecma_string_t *str_p = ecma_op_to_string (call_value);
        -: 2054:
    #####: 2055:    if (JERRY_UNLIKELY (str_p == NULL))
        -: 2056:    {
    #####: 2057:      ecma_free_value (element_value);
    #####: 2058:      ecma_deref_object (element_obj_p);
    #####: 2059:      return ECMA_VALUE_ERROR;
        -: 2060:    }
        -: 2061:
    #####: 2062:    ret_value = ecma_make_string_value (str_p);
    #####: 2063:    ecma_deref_ecma_string (str_p);
        -: 2064:  }
        -: 2065:  else
        -: 2066:  {
    #####: 2067:    ecma_free_value (func_value);
    #####: 2068:    ret_value = ecma_raise_type_error (ECMA_ERR_MSG ("'toLocaleString' is missing or not a function."));
        -: 2069:  }
        -: 2070:
    #####: 2071:  ecma_deref_object (element_obj_p);
        -: 2072:
    #####: 2073:  return ret_value;
        -: 2074:} /* ecma_builtin_typedarray_prototype_to_locale_string_helper */
        -: 2075:
        -: 2076:/**
        -: 2077: * The %TypedArray%.prototype object's 'toLocaleString' routine
        -: 2078: *
        -: 2079: * See also:
        -: 2080: *          ECMA-262 v6, 22.2.3.27
        -: 2081: *
        -: 2082: * @return ecma value
        -: 2083: *         Returned value must be freed with ecma_free_value.
        -: 2084: */
        -: 2085:static ecma_value_t
    #####: 2086:ecma_builtin_typedarray_prototype_to_locale_string (ecma_value_t this_arg) /**< this argument */
        -: 2087:{
    #####: 2088:  if (!ecma_is_typedarray (this_arg))
        -: 2089:  {
    #####: 2090:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray."));
        -: 2091:  }
        -: 2092:
    #####: 2093:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 2094:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
    #####: 2095:  uint32_t limit = info.length * info.element_size;
        -: 2096:
    #####: 2097:  if (info.length == 0)
        -: 2098:  {
    #####: 2099:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 2100:  }
        -: 2101:
    #####: 2102:  ecma_value_t first_element = ecma_builtin_typedarray_prototype_to_locale_string_helper (typedarray_p, 0);
        -: 2103:
    #####: 2104:  if (ECMA_IS_VALUE_ERROR (first_element))
        -: 2105:  {
    #####: 2106:    return first_element;
        -: 2107:  }
        -: 2108:
    #####: 2109:  ecma_string_t *return_string_p = ecma_get_string_from_value (first_element);
    #####: 2110:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (return_string_p);
    #####: 2111:  ecma_deref_ecma_string (return_string_p);
        -: 2112:
    #####: 2113:  for (uint32_t k = info.element_size; k < limit; k += info.element_size)
        -: 2114:  {
    #####: 2115:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
    #####: 2116:    ecma_value_t next_element = ecma_builtin_typedarray_prototype_to_locale_string_helper (typedarray_p, k);
        -: 2117:
    #####: 2118:    if (ECMA_IS_VALUE_ERROR (next_element))
        -: 2119:    {
    #####: 2120:      ecma_stringbuilder_destroy (&builder);
    #####: 2121:      return next_element;
        -: 2122:    }
        -: 2123:
    #####: 2124:    ecma_string_t *next_element_p = ecma_get_string_from_value (next_element);
    #####: 2125:    ecma_stringbuilder_append (&builder, next_element_p);
    #####: 2126:    ecma_deref_ecma_string (next_element_p);
        -: 2127:  }
        -: 2128:
    #####: 2129:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 2130:} /* ecma_builtin_typedarray_prototype_to_locale_string */
        -: 2131:
        -: 2132:/**
        -: 2133: * @}
        -: 2134: * @}
        -: 2135: * @}
        -: 2136: */
        -: 2137:
        -: 2138:#endif /* ENABLED (JERRY_ES2015_BUILTIN_TYPEDARRAY) */
