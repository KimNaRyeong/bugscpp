        -:    0:Source:/home/workspace/jerry-ext/debugger/debugger-tcp.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript-debugger-transport.h"
        -:   17:#include "jerryscript-ext/debugger.h"
        -:   18:#include "jext-common.h"
        -:   19:
        -:   20:#if defined (JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1)
        -:   21:
        -:   22:#include <errno.h>
        -:   23:
        -:   24:#ifdef WIN32
        -:   25:#include <BaseTsd.h>
        -:   26:typedef SSIZE_T ssize_t;
        -:   27:#include <WS2tcpip.h>
        -:   28:#include <winsock2.h>
        -:   29:
        -:   30:/* On Windows the WSAEWOULDBLOCK value can be returned for non-blocking operations */
        -:   31:#define JERRYX_EWOULDBLOCK WSAEWOULDBLOCK
        -:   32:
        -:   33:/* On Windows the invalid socket's value of INVALID_SOCKET */
        -:   34:#define JERRYX_SOCKET_INVALID INVALID_SOCKET
        -:   35:
        -:   36:/* On Windows sockets have a SOCKET typedef */
        -:   37:typedef SOCKET jerryx_socket;
        -:   38:
        -:   39:#else /* !WIN32 */
        -:   40:
        -:   41:#include <arpa/inet.h>
        -:   42:#include <fcntl.h>
        -:   43:#include <sys/socket.h>
        -:   44:#include <unistd.h>
        -:   45:
        -:   46:/* On *nix the EWOULDBLOCK errno value can be returned for non-blocking operations */
        -:   47:#define JERRYX_EWOULDBLOCK EWOULDBLOCK
        -:   48:
        -:   49:/* On *nix the invalid socket has a value of -1 */
        -:   50:#define JERRYX_SOCKET_INVALID (-1)
        -:   51:
        -:   52:/* On *nix the sockets are integer identifiers */
        -:   53:typedef int jerryx_socket;
        -:   54:#endif /* WIN32 */
        -:   55:
        -:   56:/**
        -:   57: * Implementation of transport over tcp/ip.
        -:   58: */
        -:   59:typedef struct
        -:   60:{
        -:   61:  jerry_debugger_transport_header_t header; /**< transport header */
        -:   62:  jerryx_socket tcp_socket; /**< tcp socket */
        -:   63:} jerryx_debugger_transport_tcp_t;
        -:   64:
        -:   65:/**
        -:   66: * Get the network error value.
        -:   67: *
        -:   68: * On Windows this returns the result of the `WSAGetLastError ()` call and
        -:   69: * on any other system the `errno` value.
        -:   70: *
        -:   71: *
        -:   72: * @return last error value.
        -:   73: */
        -:   74:static inline int
        -:   75:jerryx_debugger_tcp_get_errno (void)
        -:   76:{
        -:   77:#ifdef WIN32
        -:   78:  return WSAGetLastError ();
        -:   79:#else /* !WIN32 */
        -:   80:  return errno;
        -:   81:#endif /* WIN32 */
        -:   82:} /* jerryx_debugger_tcp_get_errno */
        -:   83:
        -:   84:/**
        -:   85: * Correctly close a single socket.
        -:   86: */
        -:   87:static inline void
        -:   88:jerryx_debugger_tcp_close_socket (jerryx_socket socket_id) /**< socket to close */
        -:   89:{
        -:   90:#ifdef WIN32
        -:   91:  closesocket (socket_id);
        -:   92:#else /* !WIN32 */
        -:   93:  close (socket_id);
        -:   94:#endif /* WIN32 */
        -:   95:} /* jerryx_debugger_tcp_close_socket */
        -:   96:
        -:   97:/**
        -:   98: * Log tcp error message.
        -:   99: */
        -:  100:static void
        -:  101:jerryx_debugger_tcp_log_error (int errno_value) /**< error value to log */
        -:  102:{
        -:  103:  if (errno_value == 0)
        -:  104:  {
        -:  105:    return;
        -:  106:  }
        -:  107:
        -:  108:#ifdef WIN32
        -:  109:  char *error_message = NULL;
        -:  110:  FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        -:  111:                 NULL,
        -:  112:                 errno_value,
        -:  113:                 MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),
        -:  114:                 (LPTSTR) &error_message,
        -:  115:                 0,
        -:  116:                 NULL);
        -:  117:  jerry_port_log (JERRY_LOG_LEVEL_ERROR, "TCP Error: %s\n", error_message);
        -:  118:  LocalFree (error_message);
        -:  119:#else /* !WIN32 */
        -:  120:  jerry_port_log (JERRY_LOG_LEVEL_ERROR, "TCP Error: %s\n", strerror (errno_value));
        -:  121:#endif /* WIN32 */
        -:  122:} /* jerryx_debugger_tcp_log_error */
        -:  123:
        -:  124:/**
        -:  125: * Close a tcp connection.
        -:  126: */
        -:  127:static void
        -:  128:jerryx_debugger_tcp_close (jerry_debugger_transport_header_t *header_p) /**< tcp implementation */
        -:  129:{
        -:  130:  JERRYX_ASSERT (!jerry_debugger_transport_is_connected ());
        -:  131:
        -:  132:  jerryx_debugger_transport_tcp_t *tcp_p = (jerryx_debugger_transport_tcp_t *) header_p;
        -:  133:
        -:  134:  JERRYX_DEBUG_MSG ("TCP connection closed.\n");
        -:  135:
        -:  136:  jerryx_debugger_tcp_close_socket (tcp_p->tcp_socket);
        -:  137:
        -:  138:  jerry_heap_free ((void *) header_p, sizeof (jerryx_debugger_transport_tcp_t));
        -:  139:} /* jerryx_debugger_tcp_close */
        -:  140:
        -:  141:/**
        -:  142: * Send data over a tcp connection.
        -:  143: *
        -:  144: * @return true - if the data has been sent successfully
        -:  145: *         false - otherwise
        -:  146: */
        -:  147:static bool
        -:  148:jerryx_debugger_tcp_send (jerry_debugger_transport_header_t *header_p, /**< tcp implementation */
        -:  149:                          uint8_t *message_p, /**< message to be sent */
        -:  150:                          size_t message_length) /**< message length in bytes */
        -:  151:{
        -:  152:  JERRYX_ASSERT (jerry_debugger_transport_is_connected ());
        -:  153:
        -:  154:  jerryx_debugger_transport_tcp_t *tcp_p = (jerryx_debugger_transport_tcp_t *) header_p;
        -:  155:
        -:  156:  do
        -:  157:  {
        -:  158:#ifdef __linux__
        -:  159:    ssize_t is_err = recv (tcp_p->tcp_socket, NULL, 0, MSG_PEEK);
        -:  160:
        -:  161:    if (is_err == 0 && errno != JERRYX_EWOULDBLOCK)
        -:  162:    {
        -:  163:      int err_val = errno;
        -:  164:      jerry_debugger_transport_close ();
        -:  165:      jerryx_debugger_tcp_log_error (err_val);
        -:  166:      return false;
        -:  167:    }
        -:  168:#endif /* __linux__ */
        -:  169:
        -:  170:    ssize_t sent_bytes = send (tcp_p->tcp_socket, message_p, message_length, 0);
        -:  171:
        -:  172:    if (sent_bytes < 0)
        -:  173:    {
        -:  174:      int err_val = jerryx_debugger_tcp_get_errno ();
        -:  175:
        -:  176:      if (err_val == JERRYX_EWOULDBLOCK)
        -:  177:      {
        -:  178:        continue;
        -:  179:      }
        -:  180:
        -:  181:      jerry_debugger_transport_close ();
        -:  182:      jerryx_debugger_tcp_log_error (err_val);
        -:  183:      return false;
        -:  184:    }
        -:  185:
        -:  186:    message_p += sent_bytes;
        -:  187:    message_length -= (size_t) sent_bytes;
        -:  188:  }
        -:  189:  while (message_length > 0);
        -:  190:
        -:  191:  return true;
        -:  192:} /* jerryx_debugger_tcp_send */
        -:  193:
        -:  194:/**
        -:  195: * Receive data from a tcp connection.
        -:  196: */
        -:  197:static bool
        -:  198:jerryx_debugger_tcp_receive (jerry_debugger_transport_header_t *header_p, /**< tcp implementation */
        -:  199:                             jerry_debugger_transport_receive_context_t *receive_context_p) /**< receive context */
        -:  200:{
        -:  201:  jerryx_debugger_transport_tcp_t *tcp_p = (jerryx_debugger_transport_tcp_t *) header_p;
        -:  202:
        -:  203:  uint8_t *buffer_p = receive_context_p->buffer_p + receive_context_p->received_length;
        -:  204:  size_t buffer_size = JERRY_DEBUGGER_TRANSPORT_MAX_BUFFER_SIZE - receive_context_p->received_length;
        -:  205:
        -:  206:  ssize_t length = recv (tcp_p->tcp_socket, buffer_p, buffer_size, 0);
        -:  207:
        -:  208:  if (length <= 0)
        -:  209:  {
        -:  210:    int err_val = jerryx_debugger_tcp_get_errno ();
        -:  211:
        -:  212:    if (err_val != JERRYX_EWOULDBLOCK || length == 0)
        -:  213:    {
        -:  214:      jerry_debugger_transport_close ();
        -:  215:      jerryx_debugger_tcp_log_error (err_val);
        -:  216:      return false;
        -:  217:    }
        -:  218:    length = 0;
        -:  219:  }
        -:  220:
        -:  221:  receive_context_p->received_length += (size_t) length;
        -:  222:
        -:  223:  if (receive_context_p->received_length > 0)
        -:  224:  {
        -:  225:    receive_context_p->message_p = receive_context_p->buffer_p;
        -:  226:    receive_context_p->message_length = receive_context_p->received_length;
        -:  227:  }
        -:  228:
        -:  229:  return true;
        -:  230:} /* jerryx_debugger_tcp_receive */
        -:  231:
        -:  232:/**
        -:  233: * Utility method to prepare the server socket to accept connections.
        -:  234: *
        -:  235: * The following steps are performed:
        -:  236: *  * Configure address re-use.
        -:  237: *  * Bind the socket to the given port
        -:  238: *  * Start listening on the socket.
        -:  239: *
        -:  240: * @return true if everything is ok
        -:  241: *         false if there was an error
        -:  242: */
        -:  243:static bool
        -:  244:jerryx_debugger_tcp_configure_socket (jerryx_socket server_socket, /** < socket to configure */
        -:  245:                                      uint16_t port) /** < port number to be used for the socket */
        -:  246:{
        -:  247:  struct sockaddr_in addr;
        -:  248:
        -:  249:  addr.sin_family = AF_INET;
        -:  250:  addr.sin_port = htons (port);
        -:  251:  addr.sin_addr.s_addr = INADDR_ANY;
        -:  252:
        -:  253:  int opt_value = 1;
        -:  254:
        -:  255:  if (setsockopt (server_socket, SOL_SOCKET, SO_REUSEADDR, &opt_value, sizeof (int)) != 0)
        -:  256:  {
        -:  257:    return false;
        -:  258:  }
        -:  259:
        -:  260:  if (bind (server_socket, (struct sockaddr *) &addr, sizeof (struct sockaddr_in)) != 0)
        -:  261:  {
        -:  262:    return false;
        -:  263:  }
        -:  264:
        -:  265:  if (listen (server_socket, 1) != 0)
        -:  266:  {
        -:  267:    return false;
        -:  268:  }
        -:  269:
        -:  270:  return true;
        -:  271:} /* jerryx_debugger_tcp_configure_socket */
        -:  272:
        -:  273:/**
        -:  274: * Create a tcp connection.
        -:  275: *
        -:  276: * @return true if successful,
        -:  277: *         false otherwise
        -:  278: */
        -:  279:bool
        -:  280:jerryx_debugger_tcp_create (uint16_t port) /**< listening port */
        -:  281:{
        -:  282:#ifdef WIN32
        -:  283:  WSADATA wsaData;
        -:  284:  int wsa_init_status = WSAStartup (MAKEWORD (2, 2), &wsaData);
        -:  285:  if (wsa_init_status != NO_ERROR)
        -:  286:  {
        -:  287:    JERRYX_ERROR_MSG ("WSA Error: %d\n", wsa_init_status);
        -:  288:    return false;
        -:  289:  }
        -:  290:#endif /* WIN32*/
        -:  291:
        -:  292:  jerryx_socket server_socket = socket (AF_INET, SOCK_STREAM, 0);
        -:  293:  if (server_socket == JERRYX_SOCKET_INVALID)
        -:  294:  {
        -:  295:    jerryx_debugger_tcp_log_error (jerryx_debugger_tcp_get_errno ());
        -:  296:    return false;
        -:  297:  }
        -:  298:
        -:  299:  if (!jerryx_debugger_tcp_configure_socket (server_socket, port))
        -:  300:  {
        -:  301:    int error = jerryx_debugger_tcp_get_errno ();
        -:  302:    jerryx_debugger_tcp_close_socket (server_socket);
        -:  303:    jerryx_debugger_tcp_log_error (error);
        -:  304:    return false;
        -:  305:  }
        -:  306:
        -:  307:  JERRYX_DEBUG_MSG ("Waiting for client connection\n");
        -:  308:
        -:  309:  struct sockaddr_in addr;
        -:  310:  socklen_t sin_size = sizeof (struct sockaddr_in);
        -:  311:
        -:  312:  jerryx_socket tcp_socket = accept (server_socket, (struct sockaddr *) &addr, &sin_size);
        -:  313:
        -:  314:  jerryx_debugger_tcp_close_socket (server_socket);
        -:  315:
        -:  316:  if (tcp_socket == JERRYX_SOCKET_INVALID)
        -:  317:  {
        -:  318:    jerryx_debugger_tcp_log_error (jerryx_debugger_tcp_get_errno ());
        -:  319:    return false;
        -:  320:  }
        -:  321:
        -:  322:  /* Set non-blocking mode. */
        -:  323:#ifdef WIN32
        -:  324:  u_long nonblocking_enabled = 1;
        -:  325:  if (ioctlsocket (tcp_socket, FIONBIO, &nonblocking_enabled) != NO_ERROR)
        -:  326:  {
        -:  327:    jerryx_debugger_tcp_close_socket (tcp_socket);
        -:  328:    return false;
        -:  329:  }
        -:  330:#else /* !WIN32 */
        -:  331:  int socket_flags = fcntl (tcp_socket, F_GETFL, 0);
        -:  332:
        -:  333:  if (socket_flags < 0)
        -:  334:  {
        -:  335:    close (tcp_socket);
        -:  336:    return false;
        -:  337:  }
        -:  338:
        -:  339:  if (fcntl (tcp_socket, F_SETFL, socket_flags | O_NONBLOCK) == -1)
        -:  340:  {
        -:  341:    close (tcp_socket);
        -:  342:    return false;
        -:  343:  }
        -:  344:#endif /* WIN32 */
        -:  345:
        -:  346:  JERRYX_DEBUG_MSG ("Connected from: %s\n", inet_ntoa (addr.sin_addr));
        -:  347:
        -:  348:  size_t size = sizeof (jerryx_debugger_transport_tcp_t);
        -:  349:
        -:  350:  jerry_debugger_transport_header_t *header_p;
        -:  351:  header_p = (jerry_debugger_transport_header_t *) jerry_heap_alloc (size);
        -:  352:
        -:  353:  if (!header_p)
        -:  354:  {
        -:  355:    jerryx_debugger_tcp_close_socket (tcp_socket);
        -:  356:    return false;
        -:  357:  }
        -:  358:
        -:  359:  header_p->close = jerryx_debugger_tcp_close;
        -:  360:  header_p->send = jerryx_debugger_tcp_send;
        -:  361:  header_p->receive = jerryx_debugger_tcp_receive;
        -:  362:
        -:  363:  ((jerryx_debugger_transport_tcp_t *) header_p)->tcp_socket = tcp_socket;
        -:  364:
        -:  365:  jerry_debugger_transport_add (header_p,
        -:  366:                                0,
        -:  367:                                JERRY_DEBUGGER_TRANSPORT_MAX_BUFFER_SIZE,
        -:  368:                                0,
        -:  369:                                JERRY_DEBUGGER_TRANSPORT_MAX_BUFFER_SIZE);
        -:  370:
        -:  371:  return true;
        -:  372:} /* jerryx_debugger_tcp_create */
        -:  373:
        -:  374:#else /* !(defined (JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1)) */
        -:  375:
        -:  376:/**
        -:  377: * Dummy function when debugger is disabled.
        -:  378: *
        -:  379: * @return false
        -:  380: */
        -:  381:bool
    #####:  382:jerryx_debugger_tcp_create (uint16_t port)
        -:  383:{
        -:  384:  JERRYX_UNUSED (port);
    #####:  385:  return false;
        -:  386:} /* jerryx_debugger_tcp_create */
        -:  387:
        -:  388:#endif /* defined (JERRY_DEBUGGER) && (JERRY_DEBUGGER == 1) */
