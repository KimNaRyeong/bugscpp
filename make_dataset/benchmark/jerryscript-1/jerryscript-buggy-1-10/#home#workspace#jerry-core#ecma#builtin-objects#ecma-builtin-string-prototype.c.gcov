        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-string-prototype.c
        -:    0:Programs:274
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-builtin-regexp.inc.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "ecma-iterator-object.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-string-object.h"
        -:   30:#include "jcontext.h"
        -:   31:#include "jrt.h"
        -:   32:#include "jrt-libc-includes.h"
        -:   33:#include "lit-char-helpers.h"
        -:   34:#include "lit-strings.h"
        -:   35:
        -:   36:#if ENABLED (JERRY_BUILTIN_REGEXP)
        -:   37:#include "ecma-regexp-object.h"
        -:   38:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
        -:   39:
        -:   40:#if ENABLED (JERRY_BUILTIN_STRING)
        -:   41:
        -:   42:#define ECMA_BUILTINS_INTERNAL
        -:   43:#include "ecma-builtins-internal.h"
        -:   44:
        -:   45:/**
        -:   46: * This object has a custom dispatch function.
        -:   47: */
        -:   48:#define BUILTIN_CUSTOM_DISPATCH
        -:   49:
        -:   50:/**
        -:   51: * List of built-in routine identifiers.
        -:   52: */
        -:   53:enum
        -:   54:{
        -:   55:  ECMA_STRING_PROTOTYPE_ROUTINE_START = ECMA_BUILTIN_ID__COUNT - 1,
        -:   56:  /* Note: These 4 routines MUST be in this order */
        -:   57:  ECMA_STRING_PROTOTYPE_TO_STRING,
        -:   58:  ECMA_STRING_PROTOTYPE_VALUE_OF,
        -:   59:  ECMA_STRING_PROTOTYPE_CHAR_AT,
        -:   60:  ECMA_STRING_PROTOTYPE_CHAR_CODE_AT,
        -:   61:
        -:   62:  ECMA_STRING_PROTOTYPE_CONCAT,
        -:   63:  ECMA_STRING_PROTOTYPE_SLICE,
        -:   64:
        -:   65:  ECMA_STRING_PROTOTYPE_LOCALE_COMPARE,
        -:   66:
        -:   67:  ECMA_STRING_PROTOTYPE_MATCH,
        -:   68:  ECMA_STRING_PROTOTYPE_REPLACE,
        -:   69:  ECMA_STRING_PROTOTYPE_SEARCH,
        -:   70:
        -:   71:  ECMA_STRING_PROTOTYPE_SPLIT,
        -:   72:  ECMA_STRING_PROTOTYPE_SUBSTRING,
        -:   73:  ECMA_STRING_PROTOTYPE_TO_LOWER_CASE,
        -:   74:  ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE,
        -:   75:  ECMA_STRING_PROTOTYPE_TO_UPPER_CASE,
        -:   76:  ECMA_STRING_PROTOTYPE_TO_LOCAL_UPPER_CASE,
        -:   77:  ECMA_STRING_PROTOTYPE_TRIM,
        -:   78:
        -:   79:  ECMA_STRING_PROTOTYPE_SUBSTR,
        -:   80:
        -:   81:  ECMA_STRING_PROTOTYPE_REPEAT,
        -:   82:  ECMA_STRING_PROTOTYPE_CODE_POINT_AT,
        -:   83:  /* Note: These 5 routines MUST be in this order */
        -:   84:  ECMA_STRING_PROTOTYPE_LAST_INDEX_OF,
        -:   85:  ECMA_STRING_PROTOTYPE_INDEX_OF,
        -:   86:  ECMA_STRING_PROTOTYPE_STARTS_WITH,
        -:   87:  ECMA_STRING_PROTOTYPE_INCLUDES,
        -:   88:  ECMA_STRING_PROTOTYPE_ENDS_WITH,
        -:   89:
        -:   90:  ECMA_STRING_PROTOTYPE_ITERATOR,
        -:   91:};
        -:   92:
        -:   93:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-string-prototype.inc.h"
        -:   94:#define BUILTIN_UNDERSCORED_ID string_prototype
        -:   95:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   96:
        -:   97:/** \addtogroup ecma ECMA
        -:   98: * @{
        -:   99: *
        -:  100: * \addtogroup ecmabuiltins
        -:  101: * @{
        -:  102: *
        -:  103: * \addtogroup stringprototype ECMA String.prototype object built-in
        -:  104: * @{
        -:  105: */
        -:  106:
        -:  107:/**
        -:  108: * The String.prototype object's 'toString' and 'valueOf' routines
        -:  109: *
        -:  110: * See also:
        -:  111: *          ECMA-262 v5, 15.5.4.2
        -:  112: *          ECMA-262 v5, 15.5.4.3
        -:  113: *
        -:  114: * @return ecma value
        -:  115: *         Returned value must be freed with ecma_free_value.
        -:  116: */
        -:  117:static ecma_value_t
    #####:  118:ecma_builtin_string_prototype_object_to_string (ecma_value_t this_arg) /**< this argument */
        -:  119:{
    #####:  120:  if (ecma_is_value_string (this_arg))
        -:  121:  {
    #####:  122:    return ecma_copy_value (this_arg);
        -:  123:  }
        -:  124:
    #####:  125:  if (ecma_is_value_object (this_arg))
        -:  126:  {
    #####:  127:    ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  128:
    #####:  129:    if (ecma_object_class_is (object_p, LIT_MAGIC_STRING_STRING_UL))
        -:  130:    {
    #####:  131:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  132:
    #####:  133:      JERRY_ASSERT (ecma_is_value_string (ext_object_p->u.class_prop.u.value));
        -:  134:
    #####:  135:      return ecma_copy_value (ext_object_p->u.class_prop.u.value);
        -:  136:    }
        -:  137:  }
        -:  138:
    #####:  139:  return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a String or a String object."));
        -:  140:} /* ecma_builtin_string_prototype_object_to_string */
        -:  141:
        -:  142:/**
        -:  143: * Helper function for the String.prototype object's 'charAt' and charCodeAt' routine
        -:  144: *
        -:  145: * @return ecma value
        -:  146: *         Returned value must be freed with ecma_free_value.
        -:  147: */
        -:  148:static ecma_value_t
    #####:  149:ecma_builtin_string_prototype_char_at_helper (ecma_value_t this_arg, /**< this argument */
        -:  150:                                              ecma_value_t arg, /**< routine's argument */
        -:  151:                                              bool charcode_mode) /**< routine mode */
        -:  152:{
        -:  153:  /* 3 */
    #####:  154:  ecma_number_t index_num;
    #####:  155:  ecma_value_t to_num_result = ecma_op_to_integer (arg, &index_num);
        -:  156:
    #####:  157:  if (JERRY_UNLIKELY (!ecma_is_value_empty (to_num_result)))
        -:  158:  {
    #####:  159:    return to_num_result;
        -:  160:  }
        -:  161:
        -:  162:  /* 2 */
    #####:  163:  ecma_string_t *original_string_p = ecma_op_to_string (this_arg);
    #####:  164:  if (JERRY_UNLIKELY (original_string_p == NULL))
        -:  165:  {
    #####:  166:    return ECMA_VALUE_ERROR;
        -:  167:  }
        -:  168:
        -:  169:  /* 4 */
    #####:  170:  const ecma_length_t len = ecma_string_get_length (original_string_p);
        -:  171:
        -:  172:  /* 5 */
        -:  173:  // When index_num is NaN, then the first two comparisons are false
    #####:  174:  if (index_num < 0 || index_num >= len || (ecma_number_is_nan (index_num) && len == 0))
        -:  175:  {
    #####:  176:    ecma_deref_ecma_string (original_string_p);
        -:  177:    return (charcode_mode ? ecma_make_nan_value ()
    #####:  178:                          : ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY));
        -:  179:  }
        -:  180:
        -:  181:  /* 6 */
        -:  182:  /*
        -:  183:   * String length is currently uint32_t, but index_num may be bigger,
        -:  184:   * ToInteger performs floor, while ToUInt32 performs modulo 2^32,
        -:  185:   * hence after the check 0 <= index_num < len we assume to_uint32 can be used.
        -:  186:   * We assume to_uint32 (NaN) is 0.
        -:  187:   */
    #####:  188:  JERRY_ASSERT (ecma_number_is_nan (index_num) || ecma_number_to_uint32 (index_num) == ecma_number_trunc (index_num));
        -:  189:
    #####:  190:  ecma_char_t new_ecma_char = ecma_string_get_char_at_pos (original_string_p, ecma_number_to_uint32 (index_num));
    #####:  191:  ecma_deref_ecma_string (original_string_p);
        -:  192:
    #####:  193:  return (charcode_mode ? ecma_make_uint32_value (new_ecma_char)
    #####:  194:                        : ecma_make_string_value (ecma_new_ecma_string_from_code_unit (new_ecma_char)));
        -:  195:} /* ecma_builtin_string_prototype_char_at_helper */
        -:  196:
        -:  197:/**
        -:  198: * The String.prototype object's 'concat' routine
        -:  199: *
        -:  200: * See also:
        -:  201: *          ECMA-262 v5, 15.5.4.6
        -:  202: *
        -:  203: * @return ecma value
        -:  204: *         Returned value must be freed with ecma_free_value.
        -:  205: */
        -:  206:static ecma_value_t
    #####:  207:ecma_builtin_string_prototype_object_concat (ecma_string_t *this_string_p, /**< this argument */
        -:  208:                                             const ecma_value_t *argument_list_p, /**< arguments list */
        -:  209:                                             ecma_length_t arguments_number) /**< number of arguments */
        -:  210:{
    #####:  211:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (this_string_p);
        -:  212:
        -:  213:  /* 5 */
    #####:  214:  for (uint32_t arg_index = 0; arg_index < arguments_number; ++arg_index)
        -:  215:  {
        -:  216:    /* 5a, b */
    #####:  217:    ecma_string_t *get_arg_string_p = ecma_op_to_string (argument_list_p[arg_index]);
        -:  218:
    #####:  219:    if (JERRY_UNLIKELY (get_arg_string_p == NULL))
        -:  220:    {
    #####:  221:      ecma_stringbuilder_destroy (&builder);
    #####:  222:      return ECMA_VALUE_ERROR;
        -:  223:    }
        -:  224:
    #####:  225:    ecma_stringbuilder_append (&builder, get_arg_string_p);
        -:  226:
    #####:  227:    ecma_deref_ecma_string (get_arg_string_p);
        -:  228:  }
        -:  229:
        -:  230:  /* 6 */
    #####:  231:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  232:} /* ecma_builtin_string_prototype_object_concat */
        -:  233:
        -:  234:/**
        -:  235: * The String.prototype object's 'localeCompare' routine
        -:  236: *
        -:  237: * See also:
        -:  238: *          ECMA-262 v5, 15.5.4.9
        -:  239: *
        -:  240: * @return ecma value
        -:  241: *         Returned value must be freed with ecma_free_value.
        -:  242: */
        -:  243:static ecma_value_t
    #####:  244:ecma_builtin_string_prototype_object_locale_compare (ecma_string_t *this_string_p, /**< this argument */
        -:  245:                                                     ecma_value_t arg) /**< routine's argument */
        -:  246:{
        -:  247:  /* 3. */
    #####:  248:  ecma_string_t *arg_string_p = ecma_op_to_string (arg);
        -:  249:
    #####:  250:  if (JERRY_UNLIKELY (arg_string_p == NULL))
        -:  251:  {
    #####:  252:    return ECMA_VALUE_ERROR;
        -:  253:  }
        -:  254:
    #####:  255:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -:  256:
    #####:  257:  if (ecma_compare_ecma_strings_relational (this_string_p, arg_string_p))
        -:  258:  {
    #####:  259:    result = ECMA_NUMBER_MINUS_ONE;
        -:  260:  }
    #####:  261:  else if (!ecma_compare_ecma_strings (this_string_p, arg_string_p))
        -:  262:  {
    #####:  263:    result = ECMA_NUMBER_ONE;
        -:  264:  }
        -:  265:  else
        -:  266:  {
    #####:  267:    result = ECMA_NUMBER_ZERO;
        -:  268:  }
        -:  269:
    #####:  270:  ecma_deref_ecma_string (arg_string_p);
        -:  271:
    #####:  272:  return ecma_make_number_value (result);
        -:  273:} /* ecma_builtin_string_prototype_object_locale_compare */
        -:  274:
        -:  275:#if ENABLED (JERRY_BUILTIN_REGEXP)
        -:  276:/**
        -:  277: * The String.prototype object's 'match' routine
        -:  278: *
        -:  279: * See also:
        -:  280: *          ECMA-262 v5, 15.5.4.10
        -:  281: *
        -:  282: * @return ecma value
        -:  283: *         Returned value must be freed with ecma_free_value.
        -:  284: */
        -:  285:static ecma_value_t
    #####:  286:ecma_builtin_string_prototype_object_match (ecma_value_t this_argument, /**< this argument */
        -:  287:                                            ecma_value_t regexp_arg) /**< routine's argument */
        -:  288:{
        -:  289:#if ENABLED (JERRY_ES2015)
        -:  290:  /* 3. */
    #####:  291:  if (!(ecma_is_value_undefined (regexp_arg) || ecma_is_value_null (regexp_arg)))
        -:  292:  {
        -:  293:    /* 3.a */
    #####:  294:    ecma_value_t matcher = ecma_op_get_method_by_symbol_id (regexp_arg, LIT_GLOBAL_SYMBOL_MATCH);
        -:  295:
        -:  296:    /* 3.b */
    #####:  297:    if (ECMA_IS_VALUE_ERROR (matcher))
        -:  298:    {
    #####:  299:      return matcher;
        -:  300:    }
        -:  301:
        -:  302:    /* 3.c */
    #####:  303:    if (!ecma_is_value_undefined (matcher))
        -:  304:    {
        -:  305:      /* 3.c.i */
    #####:  306:      ecma_object_t *matcher_method = ecma_get_object_from_value (matcher);
    #####:  307:      ecma_value_t result = ecma_op_function_call (matcher_method, regexp_arg, &this_argument, 1);
    #####:  308:      ecma_deref_object (matcher_method);
    #####:  309:      return result;
        -:  310:    }
        -:  311:  }
        -:  312:
        -:  313:  /* 4. */
    #####:  314:  ecma_string_t *this_str_p = ecma_op_to_string (this_argument);
        -:  315:
        -:  316:  /* 5. */
    #####:  317:  if (JERRY_UNLIKELY (this_str_p == NULL))
        -:  318:  {
    #####:  319:    return ECMA_VALUE_ERROR;
        -:  320:  }
        -:  321:
        -:  322:  /* 6. */
    #####:  323:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  324:
    #####:  325:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  326:  {
    #####:  327:    ecma_deref_ecma_string (this_str_p);
    #####:  328:    return ECMA_VALUE_ERROR;
        -:  329:  }
        -:  330:
    #####:  331:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (regexp_obj_p, regexp_arg, ECMA_VALUE_UNDEFINED);
        -:  332:
        -:  333:  /* 7. */
    #####:  334:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  335:  {
        -:  336:
    #####:  337:    ecma_deref_object (regexp_obj_p);
    #####:  338:    ecma_deref_ecma_string (this_str_p);
    #####:  339:    return new_regexp;
        -:  340:  }
    #####:  341:  ecma_value_t this_str_value = ecma_make_string_value (this_str_p);
        -:  342:
        -:  343:  /* 8. */
    #####:  344:  ecma_value_t ret_value = ecma_op_invoke_by_symbol_id (new_regexp, LIT_GLOBAL_SYMBOL_MATCH, &this_str_value, 1);
        -:  345:
    #####:  346:  ecma_deref_ecma_string (this_str_p);
    #####:  347:  ecma_free_value (new_regexp);
        -:  348:
    #####:  349:  return ret_value;
        -:  350:
        -:  351:#else /* !ENABLED (JERRY_ES2015) */
    #####:  352:  if (ecma_object_is_regexp_object (regexp_arg))
        -:  353:  {
    #####:  354:    return ecma_regexp_match_helper (regexp_arg, this_argument);
        -:  355:  }
        -:  356:
    #####:  357:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  358:
    #####:  359:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  360:  {
    #####:  361:    return ECMA_VALUE_ERROR;
        -:  362:  }
        -:  363:
    #####:  364:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (regexp_obj_p, regexp_arg, ECMA_VALUE_UNDEFINED);
        -:  365:
    #####:  366:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  367:  {
    #####:  368:    ecma_deref_object (regexp_obj_p);
    #####:  369:    return new_regexp;
        -:  370:  }
        -:  371:
    #####:  372:  ecma_value_t result = ecma_regexp_match_helper (new_regexp, this_argument);
        -:  373:
    #####:  374:  ecma_free_value (new_regexp);
        -:  375:
    #####:  376:  return result;
        -:  377:#endif /* ENABLED (JERRY_ES2015) */
        -:  378:} /* ecma_builtin_string_prototype_object_match */
        -:  379:
        -:  380:/**
        -:  381: * The String.prototype object's 'replace' routine
        -:  382: *
        -:  383: * See also:
        -:  384: *          ECMA-262 v5, 15.5.4.11
        -:  385: *          ECMA-262 v6, 21.1.3.14
        -:  386: *
        -:  387: * @return ecma value
        -:  388: *         Returned value must be freed with ecma_free_value.
        -:  389: */
        -:  390:static ecma_value_t
    #####:  391:ecma_builtin_string_prototype_object_replace (ecma_value_t this_value, /**< this argument */
        -:  392:                                              ecma_value_t search_value, /**< routine's first argument */
        -:  393:                                              ecma_value_t replace_value) /**< routine's second argument */
        -:  394:{
        -:  395:#if ENABLED (JERRY_ES2015)
    #####:  396:  if (!(ecma_is_value_undefined (search_value) || ecma_is_value_null (search_value)))
        -:  397:  {
    #####:  398:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (search_value));
    #####:  399:    ecma_value_t replace_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_REPLACE);
    #####:  400:    ecma_deref_object (obj_p);
        -:  401:
    #####:  402:    if (ECMA_IS_VALUE_ERROR (replace_symbol))
        -:  403:    {
    #####:  404:      return replace_symbol;
        -:  405:    }
        -:  406:
    #####:  407:    if (!ecma_is_value_undefined (replace_symbol) && !ecma_is_value_null (replace_symbol))
        -:  408:    {
    #####:  409:      if (!ecma_op_is_callable (replace_symbol))
        -:  410:      {
    #####:  411:        ecma_free_value (replace_symbol);
    #####:  412:        return ecma_raise_type_error (ECMA_ERR_MSG ("@@replace is not callable"));
        -:  413:      }
        -:  414:
    #####:  415:      ecma_object_t *replace_method = ecma_get_object_from_value (replace_symbol);
        -:  416:
    #####:  417:      ecma_value_t arguments[] = { this_value, replace_value };
    #####:  418:      ecma_value_t replace_result = ecma_op_function_call (replace_method, search_value, arguments, 2);
        -:  419:
    #####:  420:      ecma_deref_object (replace_method);
    #####:  421:      return replace_result;
        -:  422:    }
        -:  423:  }
        -:  424:#else /* !ENABLED (JERRY_ES2015) */
    #####:  425:  if (ecma_object_is_regexp_object (search_value))
        -:  426:  {
    #####:  427:    return ecma_regexp_replace_helper (search_value, this_value, replace_value);
        -:  428:  }
        -:  429:#endif /* ENABLED (JERRY_ES2015) */
        -:  430:
    #####:  431:  ecma_string_t *input_str_p = ecma_get_string_from_value (this_value);
        -:  432:
    #####:  433:  ecma_value_t result = ECMA_VALUE_ERROR;
        -:  434:
    #####:  435:  ecma_string_t *search_str_p = ecma_op_to_string (search_value);
    #####:  436:  if (search_str_p == NULL)
        -:  437:  {
    #####:  438:    return result;
        -:  439:  }
        -:  440:
    #####:  441:  ecma_replace_context_t replace_ctx;
    #####:  442:  replace_ctx.capture_count = 0;
    #####:  443:  replace_ctx.u.captures_p = NULL;
        -:  444:
    #####:  445:  replace_ctx.replace_str_p = NULL;
    #####:  446:  if (!ecma_op_is_callable (replace_value))
        -:  447:  {
    #####:  448:    replace_ctx.replace_str_p = ecma_op_to_string (replace_value);
    #####:  449:    if (replace_ctx.replace_str_p == NULL)
        -:  450:    {
    #####:  451:      goto cleanup_search;
        -:  452:    }
        -:  453:  }
        -:  454:
    #####:  455:  uint8_t input_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  456:  replace_ctx.string_p = ecma_string_get_chars (input_str_p,
        -:  457:                                                &(replace_ctx.string_size),
        -:  458:                                                NULL,
        -:  459:                                                NULL,
        -:  460:                                                &input_flags);
        -:  461:
    #####:  462:  lit_utf8_size_t search_size;
    #####:  463:  uint8_t search_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  464:  const lit_utf8_byte_t *search_buf_p = ecma_string_get_chars (search_str_p,
        -:  465:                                                               &search_size,
        -:  466:                                                               NULL,
        -:  467:                                                               NULL,
        -:  468:                                                               &search_flags);
        -:  469:
    #####:  470:  ecma_string_t *result_string_p = NULL;
        -:  471:
    #####:  472:  if (replace_ctx.string_size >= search_size)
        -:  473:  {
    #####:  474:    replace_ctx.matched_size = search_size;
    #####:  475:    const lit_utf8_byte_t *const input_end_p = replace_ctx.string_p + replace_ctx.string_size;
    #####:  476:    const lit_utf8_byte_t *const loop_end_p = input_end_p - search_size;
        -:  477:
    #####:  478:    uint32_t pos = 0;
    #####:  479:    for (const lit_utf8_byte_t *curr_p = replace_ctx.string_p;
    #####:  480:         curr_p <= loop_end_p;
    #####:  481:         lit_utf8_incr (&curr_p), pos++)
        -:  482:    {
    #####:  483:      if (!memcmp (curr_p, search_buf_p, search_size))
        -:  484:      {
    #####:  485:        const lit_utf8_size_t byte_offset = (lit_utf8_size_t) (curr_p - replace_ctx.string_p);
    #####:  486:        replace_ctx.builder = ecma_stringbuilder_create_raw (replace_ctx.string_p, byte_offset);
        -:  487:
    #####:  488:        if (replace_ctx.replace_str_p == NULL)
        -:  489:        {
    #####:  490:          ecma_object_t *function_p = ecma_get_object_from_value (replace_value);
        -:  491:
    #####:  492:          ecma_value_t args[] =
        -:  493:          {
    #####:  494:            ecma_make_string_value (search_str_p),
    #####:  495:            ecma_make_uint32_value (pos),
    #####:  496:            ecma_make_string_value (input_str_p)
        -:  497:          };
        -:  498:
    #####:  499:          result = ecma_op_function_call (function_p,
        -:  500:                                          ECMA_VALUE_UNDEFINED,
        -:  501:                                          args,
        -:  502:                                          3);
        -:  503:
    #####:  504:          if (ECMA_IS_VALUE_ERROR (result))
        -:  505:          {
    #####:  506:            ecma_stringbuilder_destroy (&replace_ctx.builder);
    #####:  507:            goto cleanup_replace;
        -:  508:          }
        -:  509:
    #####:  510:          ecma_string_t *const result_str_p = ecma_op_to_string (result);
    #####:  511:          ecma_free_value (result);
        -:  512:
    #####:  513:          if (result_str_p == NULL)
        -:  514:          {
    #####:  515:            ecma_stringbuilder_destroy (&replace_ctx.builder);
    #####:  516:            result = ECMA_VALUE_ERROR;
    #####:  517:            goto cleanup_replace;
        -:  518:          }
        -:  519:
    #####:  520:          ecma_stringbuilder_append (&replace_ctx.builder, result_str_p);
    #####:  521:          ecma_deref_ecma_string (result_str_p);
        -:  522:        }
        -:  523:        else
        -:  524:        {
    #####:  525:          replace_ctx.matched_p = curr_p;
    #####:  526:          replace_ctx.match_byte_pos = byte_offset;
        -:  527:
    #####:  528:          ecma_builtin_replace_substitute (&replace_ctx);
        -:  529:        }
        -:  530:
    #####:  531:        const lit_utf8_byte_t *const match_end_p = curr_p + search_size;
    #####:  532:        ecma_stringbuilder_append_raw (&replace_ctx.builder,
        -:  533:                                       match_end_p,
    #####:  534:                                       (lit_utf8_size_t) (input_end_p - match_end_p));
    #####:  535:        result_string_p = ecma_stringbuilder_finalize (&replace_ctx.builder);
    #####:  536:        break;
        -:  537:      }
        -:  538:    }
        -:  539:  }
        -:  540:
    #####:  541:  if (result_string_p == NULL)
        -:  542:  {
    #####:  543:    ecma_ref_ecma_string (input_str_p);
    #####:  544:    result_string_p = input_str_p;
        -:  545:  }
        -:  546:
    #####:  547:  result = ecma_make_string_value (result_string_p);
        -:  548:
    #####:  549:cleanup_replace:
    #####:  550:  if (input_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -:  551:  {
    #####:  552:    jmem_heap_free_block ((void *) replace_ctx.string_p, replace_ctx.string_size);
        -:  553:  }
        -:  554:
    #####:  555:  if (search_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -:  556:  {
    #####:  557:    jmem_heap_free_block ((void *) search_buf_p, search_size);
        -:  558:  }
        -:  559:
    #####:  560:  if (replace_ctx.replace_str_p != NULL)
        -:  561:  {
    #####:  562:    ecma_deref_ecma_string (replace_ctx.replace_str_p);
        -:  563:  }
        -:  564:
    #####:  565:cleanup_search:
    #####:  566:  ecma_deref_ecma_string (search_str_p);
    #####:  567:  return result;
        -:  568:} /* ecma_builtin_string_prototype_object_replace */
        -:  569:
        -:  570:/**
        -:  571: * The String.prototype object's 'search' routine
        -:  572: *
        -:  573: * See also:
        -:  574: *          ECMA-262 v5, 15.5.4.12
        -:  575: *          ECMA-262 v6, 21.1.3.15
        -:  576: *
        -:  577: * @return ecma value
        -:  578: *         Returned value must be freed with ecma_free_value.
        -:  579: */
        -:  580:static ecma_value_t
    #####:  581:ecma_builtin_string_prototype_object_search (ecma_value_t this_value, /**< this argument */
        -:  582:                                             ecma_value_t regexp_value) /**< routine's argument */
        -:  583:{
        -:  584:#if ENABLED (JERRY_ES2015)
    #####:  585:  if (!(ecma_is_value_undefined (regexp_value) || ecma_is_value_null (regexp_value)))
        -:  586:  {
    #####:  587:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (regexp_value));
    #####:  588:    ecma_value_t search_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_SEARCH);
    #####:  589:    ecma_deref_object (obj_p);
        -:  590:
    #####:  591:    if (ECMA_IS_VALUE_ERROR (search_symbol))
        -:  592:    {
    #####:  593:      return search_symbol;
        -:  594:    }
        -:  595:
    #####:  596:    if (!ecma_is_value_undefined (search_symbol) && !ecma_is_value_null (search_symbol))
        -:  597:    {
    #####:  598:      if (!ecma_op_is_callable (search_symbol))
        -:  599:      {
    #####:  600:        ecma_free_value (search_symbol);
    #####:  601:        return ecma_raise_type_error (ECMA_ERR_MSG ("@@search is not callable"));
        -:  602:      }
        -:  603:
    #####:  604:      ecma_object_t *search_method = ecma_get_object_from_value (search_symbol);
    #####:  605:      ecma_value_t search_result = ecma_op_function_call (search_method, regexp_value, &this_value, 1);
        -:  606:
    #####:  607:      ecma_deref_object (search_method);
    #####:  608:      return search_result;
        -:  609:    }
        -:  610:  }
        -:  611:#else /* !ENABLED (JERRY_ES2015) */
    #####:  612:  if (ecma_object_is_regexp_object (regexp_value))
        -:  613:  {
    #####:  614:    return ecma_regexp_search_helper (regexp_value, this_value);
        -:  615:  }
        -:  616:#endif /* ENABLED (JERRY_ES2015) */
        -:  617:
    #####:  618:  ecma_value_t result = ECMA_VALUE_ERROR;
        -:  619:
    #####:  620:  ecma_string_t *string_p = ecma_op_to_string (this_value);
    #####:  621:  if (string_p == NULL)
        -:  622:  {
    #####:  623:    return result;
        -:  624:  }
        -:  625:
    #####:  626:  ecma_string_t *pattern_p = ecma_regexp_read_pattern_str_helper (regexp_value);
    #####:  627:  if (pattern_p == NULL)
        -:  628:  {
    #####:  629:    goto cleanup_string;
        -:  630:  }
        -:  631:
    #####:  632:  ecma_object_t *new_regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  633:
    #####:  634:  if (JERRY_UNLIKELY (new_regexp_obj_p == NULL))
        -:  635:  {
    #####:  636:    ecma_deref_ecma_string (string_p);
    #####:  637:    ecma_deref_ecma_string (pattern_p);
    #####:  638:    return ECMA_VALUE_ERROR;
        -:  639:  }
        -:  640:
    #####:  641:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (new_regexp_obj_p,
        -:  642:                                                                ecma_make_string_value (pattern_p),
        -:  643:                                                                ECMA_VALUE_UNDEFINED);
        -:  644:
    #####:  645:  ecma_deref_ecma_string (pattern_p);
        -:  646:
    #####:  647:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  648:  {
    #####:  649:    ecma_deref_object (new_regexp_obj_p);
    #####:  650:    goto cleanup_string;
        -:  651:  }
        -:  652:
        -:  653:#if !ENABLED (JERRY_ES2015)
    #####:  654:  result = ecma_regexp_search_helper (new_regexp, ecma_make_string_value (string_p));
    #####:  655:  ecma_deref_object (ecma_get_object_from_value (new_regexp));
        -:  656:#else /* ENABLED (JERRY_ES2015) */
    #####:  657:  ecma_object_t *regexp_obj_p = ecma_get_object_from_value (new_regexp);
    #####:  658:  ecma_value_t search_symbol = ecma_op_object_get_by_symbol_id (regexp_obj_p, LIT_GLOBAL_SYMBOL_SEARCH);
    #####:  659:  if (ECMA_IS_VALUE_ERROR (search_symbol))
        -:  660:  {
    #####:  661:    goto cleanup_regexp;
        -:  662:  }
        -:  663:
    #####:  664:  if (!ecma_op_is_callable (search_symbol))
        -:  665:  {
    #####:  666:    result = ecma_raise_type_error (ECMA_ERR_MSG ("@@search is not callable"));
    #####:  667:    goto cleanup_regexp;
        -:  668:  }
        -:  669:
    #####:  670:  ecma_object_t *search_method_p = ecma_get_object_from_value (search_symbol);
    #####:  671:  ecma_value_t arguments[] = { ecma_make_string_value (string_p) };
    #####:  672:  result = ecma_op_function_call (search_method_p, new_regexp, arguments, 1);
    #####:  673:  ecma_deref_object (search_method_p);
        -:  674:
    #####:  675:cleanup_regexp:
    #####:  676:  ecma_deref_object (regexp_obj_p);
        -:  677:#endif /* !ENABLED (JERRY_ES2015) */
        -:  678:
    #####:  679:cleanup_string:
    #####:  680:  ecma_deref_ecma_string (string_p);
    #####:  681:  return result;
        -:  682:} /* ecma_builtin_string_prototype_object_search */
        -:  683:
        -:  684:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
        -:  685:
        -:  686:/**
        -:  687: * The String.prototype object's 'slice' routine
        -:  688: *
        -:  689: * See also:
        -:  690: *          ECMA-262 v5, 15.5.4.13
        -:  691: *
        -:  692: * @return ecma value
        -:  693: *         Returned value must be freed with ecma_free_value.
        -:  694: */
        -:  695:static ecma_value_t
    #####:  696:ecma_builtin_string_prototype_object_slice (ecma_string_t *get_string_val, /**< this argument */
        -:  697:                                            ecma_value_t arg1, /**< routine's first argument */
        -:  698:                                            ecma_value_t arg2) /**< routine's second argument */
        -:  699:{
    #####:  700:  const ecma_length_t len = ecma_string_get_length (get_string_val);
        -:  701:
        -:  702:  /* 4. 6. */
    #####:  703:  ecma_length_t start = 0, end = len;
        -:  704:
    #####:  705:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,
        -:  706:                                                                      len,
        -:  707:                                                                      &start)))
        -:  708:  {
    #####:  709:    return ECMA_VALUE_ERROR;
        -:  710:  }
        -:  711:
        -:  712:  /* 5. 7. */
    #####:  713:  if (ecma_is_value_undefined (arg2))
        -:  714:  {
    #####:  715:    end = len;
        -:  716:  }
        -:  717:  else
        -:  718:  {
    #####:  719:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,
        -:  720:                                                                        len,
        -:  721:                                                                        &end)))
        -:  722:    {
    #####:  723:      return ECMA_VALUE_ERROR;
        -:  724:    }
        -:  725:  }
        -:  726:
    #####:  727:  JERRY_ASSERT (start <= len && end <= len);
        -:  728:
        -:  729:  /* 8-9. */
    #####:  730:  ecma_string_t *new_str_p = ecma_string_substr (get_string_val, start, end);
        -:  731:
    #####:  732:  return ecma_make_string_value (new_str_p);
        -:  733:} /* ecma_builtin_string_prototype_object_slice */
        -:  734:
        -:  735:/**
        -:  736: * The String.prototype object's 'split' routine
        -:  737: *
        -:  738: * See also:
        -:  739: *          ECMA-262 v5, 15.5.4.14
        -:  740: *
        -:  741: * @return ecma value
        -:  742: *         Returned value must be freed with ecma_free_value.
        -:  743: */
        -:  744:static ecma_value_t
    #####:  745:ecma_builtin_string_prototype_object_split (ecma_value_t this_value, /**< this argument */
        -:  746:                                            ecma_value_t separator_value, /**< separator */
        -:  747:                                            ecma_value_t limit_value) /**< limit */
        -:  748:{
        -:  749:#if ENABLED (JERRY_ES2015)
    #####:  750:  if (!(ecma_is_value_undefined (separator_value) || ecma_is_value_null (separator_value)))
        -:  751:  {
    #####:  752:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (separator_value));
    #####:  753:    ecma_value_t split_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_SPLIT);
    #####:  754:    ecma_deref_object (obj_p);
        -:  755:
    #####:  756:    if (ECMA_IS_VALUE_ERROR (split_symbol))
        -:  757:    {
    #####:  758:      return split_symbol;
        -:  759:    }
        -:  760:
    #####:  761:    if (!ecma_is_value_undefined (split_symbol) && !ecma_is_value_null (split_symbol))
        -:  762:    {
    #####:  763:      if (!ecma_op_is_callable (split_symbol))
        -:  764:      {
    #####:  765:        ecma_free_value (split_symbol);
    #####:  766:        return ecma_raise_type_error (ECMA_ERR_MSG ("@@split is not callable"));
        -:  767:      }
        -:  768:
    #####:  769:      ecma_object_t *split_method_p = ecma_get_object_from_value (split_symbol);
        -:  770:
    #####:  771:      ecma_value_t arguments[] = { this_value, limit_value };
    #####:  772:      ecma_value_t split_result = ecma_op_function_call (split_method_p, separator_value, arguments, 2);
        -:  773:
    #####:  774:      ecma_deref_object (split_method_p);
    #####:  775:      return split_result;
        -:  776:    }
        -:  777:  }
        -:  778:#else /* !ENABLED (JERRY_ES2015) */
    #####:  779:  if (ecma_object_is_regexp_object (separator_value))
        -:  780:  {
    #####:  781:    return ecma_regexp_split_helper (separator_value, this_value, limit_value);
        -:  782:  }
        -:  783:#endif /* ENABLED (JERRY_ES2015) */
        -:  784:
    #####:  785:  ecma_value_t result = ECMA_VALUE_ERROR;
        -:  786:
        -:  787:  /* 4. */
    #####:  788:  ecma_string_t *string_p = ecma_op_to_string (this_value);
    #####:  789:  if (string_p == NULL)
        -:  790:  {
    #####:  791:    return result;
        -:  792:  }
        -:  793:
        -:  794:  /* 8. */
    #####:  795:  uint32_t limit = UINT32_MAX;
    #####:  796:  if (!ecma_is_value_undefined (limit_value))
        -:  797:  {
    #####:  798:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_length (limit_value, &limit)))
        -:  799:    {
    #####:  800:      goto cleanup_string;
        -:  801:    }
        -:  802:  }
        -:  803:
        -:  804:  /* 12. */
    #####:  805:  ecma_string_t *separator_p = ecma_op_to_string (separator_value);
    #####:  806:  if (separator_p == NULL)
        -:  807:  {
    #####:  808:    goto cleanup_string;
        -:  809:  }
        -:  810:
        -:  811:  /* 6. */
    #####:  812:  result = ecma_op_create_array_object (NULL, 0, false);
        -:  813:
        -:  814:  /* 14. */
    #####:  815:  if (limit == 0)
        -:  816:  {
    #####:  817:    goto cleanup_separator;
        -:  818:  }
        -:  819:
    #####:  820:  ecma_object_t *array_p = ecma_get_object_from_value (result);
    #####:  821:  ecma_length_t array_length = 0;
        -:  822:
        -:  823:  /* 15. */
    #####:  824:  if (ecma_is_value_undefined (separator_value))
        -:  825:  {
    #####:  826:    ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -:  827:                                                                     array_length,
        -:  828:                                                                     ecma_make_string_value (string_p),
        -:  829:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  830:    JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####:  831:    goto cleanup_separator;
        -:  832:  }
        -:  833:
        -:  834:  /* 16. */
    #####:  835:  if (ecma_string_is_empty (string_p))
        -:  836:  {
    #####:  837:    if (!ecma_string_is_empty (separator_p))
        -:  838:    {
    #####:  839:      ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -:  840:                                                                       array_length,
        -:  841:                                                                       ecma_make_string_value (string_p),
        -:  842:                                                                       ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  843:      JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
        -:  844:    }
        -:  845:
    #####:  846:    goto cleanup_separator;
        -:  847:  }
        -:  848:
    #####:  849:  lit_utf8_size_t string_size;
    #####:  850:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  851:  const lit_utf8_byte_t *string_buffer_p = ecma_string_get_chars (string_p,
        -:  852:                                                                  &string_size,
        -:  853:                                                                  NULL,
        -:  854:                                                                  NULL,
        -:  855:                                                                  &string_flags);
    #####:  856:  lit_utf8_size_t separator_size;
    #####:  857:  uint8_t separator_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  858:  const lit_utf8_byte_t *separator_buffer_p = ecma_string_get_chars (separator_p,
        -:  859:                                                                     &separator_size,
        -:  860:                                                                     NULL,
        -:  861:                                                                     NULL,
        -:  862:                                                                     &separator_flags);
        -:  863:
    #####:  864:  const lit_utf8_byte_t *const string_end_p = string_buffer_p + string_size;
    #####:  865:  const lit_utf8_byte_t *const compare_end_p = JERRY_MIN (string_end_p - separator_size + 1,
        -:  866:                                                          string_end_p);
    #####:  867:  const lit_utf8_byte_t *current_p = string_buffer_p;
    #####:  868:  const lit_utf8_byte_t *last_str_begin_p = string_buffer_p;
        -:  869:
    #####:  870:  while (current_p < compare_end_p)
        -:  871:  {
    #####:  872:    if (!memcmp (current_p, separator_buffer_p, separator_size)
    #####:  873:        && (last_str_begin_p != current_p + separator_size))
        -:  874:    {
    #####:  875:      ecma_string_t *substr_p = ecma_new_ecma_string_from_utf8 (last_str_begin_p,
    #####:  876:                                                                (lit_utf8_size_t) (current_p - last_str_begin_p));
    #####:  877:      ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -:  878:                                                                       array_length++,
        -:  879:                                                                       ecma_make_string_value (substr_p),
        -:  880:                                                                       ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  881:      JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####:  882:      ecma_deref_ecma_string (substr_p);
        -:  883:
    #####:  884:      if (array_length >= limit)
        -:  885:      {
    #####:  886:        goto cleanup_buffers;
        -:  887:      }
        -:  888:
    #####:  889:      current_p += separator_size;
    #####:  890:      last_str_begin_p = current_p;
    #####:  891:      continue;
        -:  892:    }
        -:  893:
    #####:  894:    lit_utf8_incr (&current_p);
        -:  895:  }
        -:  896:
    #####:  897:  ecma_string_t *end_substr_p = ecma_new_ecma_string_from_utf8 (last_str_begin_p,
    #####:  898:                                                                (lit_utf8_size_t) (string_end_p - last_str_begin_p));
    #####:  899:  ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -:  900:                                                                   array_length,
        -:  901:                                                                   ecma_make_string_value (end_substr_p),
        -:  902:                                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  903:  JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####:  904:  ecma_deref_ecma_string (end_substr_p);
        -:  905:
    #####:  906:cleanup_buffers:
    #####:  907:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -:  908:  {
    #####:  909:    jmem_heap_free_block ((void *) string_buffer_p, string_size);
        -:  910:  }
        -:  911:
    #####:  912:  if (separator_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -:  913:  {
    #####:  914:    jmem_heap_free_block ((void *) separator_buffer_p, separator_size);
        -:  915:  }
        -:  916:
    #####:  917:cleanup_separator:
    #####:  918:  ecma_deref_ecma_string (separator_p);
    #####:  919:cleanup_string:
    #####:  920:  ecma_deref_ecma_string (string_p);
    #####:  921:  return result;
        -:  922:} /* ecma_builtin_string_prototype_object_split */
        -:  923:
        -:  924:/**
        -:  925: * The String.prototype object's 'substring' routine
        -:  926: *
        -:  927: * See also:
        -:  928: *          ECMA-262 v5, 15.5.4.15
        -:  929: *
        -:  930: * @return ecma value
        -:  931: *         Returned value must be freed with ecma_free_value.
        -:  932: */
        -:  933:static ecma_value_t
    #####:  934:ecma_builtin_string_prototype_object_substring (ecma_string_t *original_string_p, /**< this argument */
        -:  935:                                                ecma_value_t arg1, /**< routine's first argument */
        -:  936:                                                ecma_value_t arg2) /**< routine's second argument */
        -:  937:{
        -:  938:  /* 3 */
    #####:  939:  const ecma_length_t len = ecma_string_get_length (original_string_p);
    #####:  940:  ecma_length_t start = 0, end = len;
        -:  941:
        -:  942:  /* 4 */
    #####:  943:  ecma_number_t start_num;
        -:  944:
    #####:  945:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg1, &start_num)))
        -:  946:  {
    #####:  947:    return ECMA_VALUE_ERROR;
        -:  948:  }
        -:  949:
        -:  950:  /* 6 */
    #####:  951:  start = (uint32_t) JERRY_MIN (JERRY_MAX (start_num, 0), len);
        -:  952:
        -:  953:  /* 5 */
    #####:  954:  if (ecma_is_value_undefined (arg2))
        -:  955:  {
    #####:  956:    end = len;
        -:  957:  }
        -:  958:  else
        -:  959:  {
        -:  960:    /* 5 part 2 */
    #####:  961:    ecma_number_t end_num;
        -:  962:
    #####:  963:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg2, &end_num)))
        -:  964:    {
    #####:  965:      return ECMA_VALUE_ERROR;
        -:  966:    }
        -:  967:    /* 7 */
    #####:  968:    end = (uint32_t) JERRY_MIN (JERRY_MAX (end_num, 0), len);
        -:  969:  }
        -:  970:
    #####:  971:  JERRY_ASSERT (start <= len && end <= len);
        -:  972:
        -:  973:  /* 8 */
    #####:  974:  uint32_t from = start < end ? start : end;
        -:  975:
        -:  976:  /* 9 */
    #####:  977:  uint32_t to = start > end ? start : end;
        -:  978:
        -:  979:  /* 10 */
    #####:  980:  ecma_string_t *new_str_p = ecma_string_substr (original_string_p, from, to);
    #####:  981:  return ecma_make_string_value (new_str_p);
        -:  982:} /* ecma_builtin_string_prototype_object_substring */
        -:  983:
        -:  984:/**
        -:  985: * The common implementation of the String.prototype object's
        -:  986: * 'toLowerCase', 'toLocaleLowerCase', 'toUpperCase', 'toLocalUpperCase' routines
        -:  987: *
        -:  988: * See also:
        -:  989: *          ECMA-262 v5, 15.5.4.16
        -:  990: *          ECMA-262 v5, 15.5.4.17
        -:  991: *          ECMA-262 v5, 15.5.4.18
        -:  992: *          ECMA-262 v5, 15.5.4.19
        -:  993: *
        -:  994: * Helper function to convert a string to upper or lower case.
        -:  995: *
        -:  996: * @return ecma value
        -:  997: *         Returned value must be freed with ecma_free_value.
        -:  998: */
        -:  999:static ecma_value_t
    #####: 1000:ecma_builtin_string_prototype_object_conversion_helper (ecma_string_t *input_string_p, /**< this argument */
        -: 1001:                                                        bool lower_case) /**< convert to lower (true)
        -: 1002:                                                                          *   or upper (false) case */
        -: 1003:{
    #####: 1004:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1005:
        -: 1006:  /* 3. */
    #####: 1007:  ECMA_STRING_TO_UTF8_STRING (input_string_p, input_start_p, input_start_size);
        -: 1008:
        -: 1009:  /*
        -: 1010:   * The URI encoding has two major phases: first we compute
        -: 1011:   * the length of the lower case string, then we encode it.
        -: 1012:   */
        -: 1013:
    #####: 1014:  lit_utf8_size_t output_length = 0;
    #####: 1015:  const lit_utf8_byte_t *input_str_curr_p = input_start_p;
    #####: 1016:  const lit_utf8_byte_t *input_str_end_p = input_start_p + input_start_size;
        -: 1017:
    #####: 1018:  while (input_str_curr_p < input_str_end_p)
        -: 1019:  {
    #####: 1020:    ecma_char_t character = lit_cesu8_read_next (&input_str_curr_p);
    #####: 1021:    ecma_char_t character_buffer[LIT_MAXIMUM_OTHER_CASE_LENGTH];
        -: 1022:    ecma_length_t character_length;
    #####: 1023:    lit_utf8_byte_t utf8_byte_buffer[LIT_CESU8_MAX_BYTES_IN_CODE_POINT];
        -: 1024:
    #####: 1025:    if (lower_case)
        -: 1026:    {
    #####: 1027:      character_length = lit_char_to_lower_case (character,
        -: 1028:                                                 character_buffer,
        -: 1029:                                                 LIT_MAXIMUM_OTHER_CASE_LENGTH);
        -: 1030:    }
        -: 1031:    else
        -: 1032:    {
    #####: 1033:      character_length = lit_char_to_upper_case (character,
        -: 1034:                                                 character_buffer,
        -: 1035:                                                 LIT_MAXIMUM_OTHER_CASE_LENGTH);
        -: 1036:    }
        -: 1037:
    #####: 1038:    JERRY_ASSERT (character_length >= 1 && character_length <= LIT_MAXIMUM_OTHER_CASE_LENGTH);
        -: 1039:
    #####: 1040:    for (ecma_length_t i = 0; i < character_length; i++)
        -: 1041:    {
    #####: 1042:      output_length += lit_code_unit_to_utf8 (character_buffer[i], utf8_byte_buffer);
        -: 1043:    }
        -: 1044:  }
        -: 1045:
        -: 1046:  /* Second phase. */
        -: 1047:
    #####: 1048:  JMEM_DEFINE_LOCAL_ARRAY (output_start_p,
        -: 1049:                           output_length,
        -: 1050:                           lit_utf8_byte_t);
        -: 1051:
    #####: 1052:  lit_utf8_byte_t *output_char_p = output_start_p;
        -: 1053:
        -: 1054:  /* Encoding the output. */
    #####: 1055:  input_str_curr_p = input_start_p;
        -: 1056:
    #####: 1057:  while (input_str_curr_p < input_str_end_p)
        -: 1058:  {
    #####: 1059:    ecma_char_t character = lit_cesu8_read_next (&input_str_curr_p);
    #####: 1060:    ecma_char_t character_buffer[LIT_MAXIMUM_OTHER_CASE_LENGTH];
        -: 1061:    ecma_length_t character_length;
        -: 1062:
    #####: 1063:    if (lower_case)
        -: 1064:    {
    #####: 1065:      character_length = lit_char_to_lower_case (character,
        -: 1066:                                                 character_buffer,
        -: 1067:                                                 LIT_MAXIMUM_OTHER_CASE_LENGTH);
        -: 1068:    }
        -: 1069:    else
        -: 1070:    {
    #####: 1071:      character_length = lit_char_to_upper_case (character,
        -: 1072:                                                 character_buffer,
        -: 1073:                                                 LIT_MAXIMUM_OTHER_CASE_LENGTH);
        -: 1074:    }
        -: 1075:
    #####: 1076:    JERRY_ASSERT (character_length >= 1 && character_length <= LIT_MAXIMUM_OTHER_CASE_LENGTH);
        -: 1077:
    #####: 1078:    for (ecma_length_t i = 0; i < character_length; i++)
        -: 1079:    {
    #####: 1080:      output_char_p += lit_code_unit_to_utf8 (character_buffer[i], output_char_p);
        -: 1081:    }
        -: 1082:  }
        -: 1083:
    #####: 1084:  JERRY_ASSERT (output_start_p + output_length == output_char_p);
        -: 1085:
    #####: 1086:  ecma_string_t *output_string_p = ecma_new_ecma_string_from_utf8 (output_start_p, output_length);
        -: 1087:
    #####: 1088:  ret_value = ecma_make_string_value (output_string_p);
        -: 1089:
    #####: 1090:  JMEM_FINALIZE_LOCAL_ARRAY (output_start_p);
    #####: 1091:  ECMA_FINALIZE_UTF8_STRING (input_start_p, input_start_size);
        -: 1092:
    #####: 1093:  return ret_value;
        -: 1094:} /* ecma_builtin_string_prototype_object_conversion_helper */
        -: 1095:
        -: 1096:/**
        -: 1097: * The String.prototype object's 'trim' routine
        -: 1098: *
        -: 1099: * See also:
        -: 1100: *          ECMA-262 v5, 15.5.4.20
        -: 1101: *
        -: 1102: * @return ecma value
        -: 1103: *         Returned value must be freed with ecma_free_value.
        -: 1104: */
        -: 1105:static ecma_value_t
    #####: 1106:ecma_builtin_string_prototype_object_trim (ecma_string_t *original_string_p) /**< this argument */
        -: 1107:{
    #####: 1108:  ecma_string_t *trimmed_string_p = ecma_string_trim (original_string_p);
        -: 1109:
    #####: 1110:  return ecma_make_string_value (trimmed_string_p);
        -: 1111:} /* ecma_builtin_string_prototype_object_trim */
        -: 1112:
        -: 1113:#if ENABLED (JERRY_ES2015)
        -: 1114:
        -: 1115:/**
        -: 1116: * The String.prototype object's 'repeat' routine
        -: 1117: *
        -: 1118: * See also:
        -: 1119: *          ECMA-262 v6, 21.1.3.13
        -: 1120: *
        -: 1121: * @return ecma value
        -: 1122: *         Returned value must be freed with ecma_free_value.
        -: 1123: */
        -: 1124:static ecma_value_t
    #####: 1125:ecma_builtin_string_prototype_object_repeat (ecma_string_t *original_string_p, /**< this argument */
        -: 1126:                                             ecma_value_t repeat) /**< times to repeat */
        -: 1127:{
        -: 1128:  ecma_string_t *ret_string_p;
        -: 1129:
        -: 1130:  /* 4 */
    #####: 1131:  ecma_number_t count_number;
    #####: 1132:  ecma_value_t count_value = ecma_op_to_integer (repeat, &count_number);
        -: 1133:
        -: 1134:  /* 5 */
    #####: 1135:  if (ECMA_IS_VALUE_ERROR (count_value))
        -: 1136:  {
    #####: 1137:    return count_value;
        -: 1138:  }
        -: 1139:
    #####: 1140:  int32_t repeat_count = ecma_number_to_int32 (count_number);
        -: 1141:
    #####: 1142:  bool isNan = ecma_number_is_nan (count_number);
        -: 1143:
        -: 1144:  /* 6, 7 */
    #####: 1145:  if (count_number < 0 || (!isNan && ecma_number_is_infinity (count_number)))
        -: 1146:  {
    #####: 1147:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid count value"));
        -: 1148:  }
        -: 1149:
    #####: 1150:  lit_utf8_size_t size = ecma_string_get_size (original_string_p);
        -: 1151:
    #####: 1152:  if (repeat_count == 0 || size == 0 || isNan)
        -: 1153:  {
    #####: 1154:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1155:  }
        -: 1156:
    #####: 1157:  if ((uint32_t) repeat_count >= (ECMA_STRING_SIZE_LIMIT / size))
        -: 1158:  {
    #####: 1159:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid string length"));
        -: 1160:  }
        -: 1161:
    #####: 1162:  lit_utf8_size_t total_size = size * (lit_utf8_size_t) repeat_count;
        -: 1163:
    #####: 1164:  JMEM_DEFINE_LOCAL_ARRAY (str_buffer, total_size, lit_utf8_byte_t);
        -: 1165:
    #####: 1166:  lit_utf8_byte_t *buffer_ptr = str_buffer;
        -: 1167:
    #####: 1168:  for (int32_t n = 0; n < repeat_count; n++)
        -: 1169:  {
    #####: 1170:    buffer_ptr += ecma_string_copy_to_cesu8_buffer (original_string_p, buffer_ptr,
        -: 1171:                                                    (lit_utf8_size_t) (size));
        -: 1172:  }
        -: 1173:
    #####: 1174:  ret_string_p = ecma_new_ecma_string_from_utf8 (str_buffer, (lit_utf8_size_t) (buffer_ptr - str_buffer));
    #####: 1175:  JMEM_FINALIZE_LOCAL_ARRAY (str_buffer);
        -: 1176:
    #####: 1177:  return ecma_make_string_value (ret_string_p);
        -: 1178:} /* ecma_builtin_string_prototype_object_repeat */
        -: 1179:
        -: 1180:/**
        -: 1181: * The String.prototype object's 'codePointAt' routine
        -: 1182: *
        -: 1183: * See also:
        -: 1184: *          ECMA-262 v6, 21.1.3.3
        -: 1185: *
        -: 1186: * @return lit_code_point_t
        -: 1187: */
        -: 1188:static ecma_value_t
    #####: 1189:ecma_builtin_string_prototype_object_code_point_at (ecma_string_t *this_string_p, /**< this argument */
        -: 1190:                                                    ecma_value_t pos) /**< given position */
        -: 1191:{
    #####: 1192:  ecma_number_t pos_num;
    #####: 1193:  ecma_value_t error = ecma_op_to_integer (pos, &pos_num);
        -: 1194:
    #####: 1195:  if (ECMA_IS_VALUE_ERROR (error))
        -: 1196:  {
    #####: 1197:    return error;
        -: 1198:  }
        -: 1199:
    #####: 1200:  ecma_length_t size = ecma_string_get_length (this_string_p);
        -: 1201:
    #####: 1202:  if (pos_num < 0 || pos_num >= size)
        -: 1203:  {
    #####: 1204:    return ECMA_VALUE_UNDEFINED;
        -: 1205:  }
        -: 1206:
    #####: 1207:  uint32_t index = (uint32_t) pos_num;
        -: 1208:
    #####: 1209:  ecma_char_t first = ecma_string_get_char_at_pos (this_string_p, index);
        -: 1210:
    #####: 1211:  if (first < LIT_UTF16_HIGH_SURROGATE_MIN
    #####: 1212:      || first > LIT_UTF16_HIGH_SURROGATE_MAX
    #####: 1213:      || index + 1 == size)
        -: 1214:  {
    #####: 1215:    return ecma_make_uint32_value (first);
        -: 1216:  }
        -: 1217:
    #####: 1218:  ecma_char_t second = ecma_string_get_char_at_pos (this_string_p, index + 1);
        -: 1219:
    #####: 1220:  if (second < LIT_UTF16_LOW_SURROGATE_MARKER
    #####: 1221:      || second > LIT_UTF16_LOW_SURROGATE_MAX)
        -: 1222:  {
    #####: 1223:    return ecma_make_uint32_value (first);
        -: 1224:  }
        -: 1225:
    #####: 1226:  return ecma_make_uint32_value (lit_convert_surrogate_pair_to_code_point (first, second));
        -: 1227:} /* ecma_builtin_string_prototype_object_code_point_at */
        -: 1228:
        -: 1229:#endif /* ENABLED (JERRY_ES2015) */
        -: 1230:
        -: 1231:#if ENABLED (JERRY_BUILTIN_ANNEXB)
        -: 1232:
        -: 1233:/**
        -: 1234: * The String.prototype object's 'substr' routine
        -: 1235: *
        -: 1236: * See also:
        -: 1237: *          ECMA-262 v5, B.2.3
        -: 1238: *
        -: 1239: * @return ecma value
        -: 1240: *         Returned value must be freed with ecma_free_value.
        -: 1241: */
        -: 1242:static ecma_value_t
    #####: 1243:ecma_builtin_string_prototype_object_substr (ecma_string_t *this_string_p, /**< this argument */
        -: 1244:                                             ecma_value_t start, /**< routine's first argument */
        -: 1245:                                             ecma_value_t length) /**< routine's second argument */
        -: 1246:{
        -: 1247:  /* 2. */
    #####: 1248:  ecma_number_t start_num;
        -: 1249:
    #####: 1250:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (start, &start_num)))
        -: 1251:  {
    #####: 1252:    return ECMA_VALUE_ERROR;
        -: 1253:  }
        -: 1254:
        -: 1255:  /* 3. */
    #####: 1256:  ecma_number_t length_num = ecma_number_make_infinity (false);
        -: 1257:
    #####: 1258:  if (!ecma_is_value_undefined (length))
        -: 1259:  {
    #####: 1260:    ecma_number_t len;
        -: 1261:
    #####: 1262:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (length, &len)))
        -: 1263:    {
    #####: 1264:      return ECMA_VALUE_ERROR;
        -: 1265:    }
        -: 1266:
    #####: 1267:    length_num = ecma_number_is_nan (len) ? 0 : len;
        -: 1268:  }
        -: 1269:
        -: 1270:  /* 4. */
    #####: 1271:  ecma_length_t this_len = ecma_string_get_length (this_string_p);
        -: 1272:
        -: 1273:  /* 5. */
    #####: 1274:  uint32_t from = (uint32_t) ((start_num < 0) ? JERRY_MAX (this_len + start_num, 0) : start_num);
        -: 1275:
    #####: 1276:  if (from > this_len)
        -: 1277:  {
    #####: 1278:    from = this_len;
        -: 1279:  }
        -: 1280:
        -: 1281:  /* 6. */
    #####: 1282:  ecma_number_t to_num = JERRY_MIN (JERRY_MAX (length_num, 0), this_len - from);
        -: 1283:
        -: 1284:  /* 7. */
    #####: 1285:  uint32_t to = from + (uint32_t) to_num;
        -: 1286:
        -: 1287:  /* 8. */
    #####: 1288:  ecma_string_t *new_str_p = ecma_string_substr (this_string_p, from, to);
    #####: 1289:  return ecma_make_string_value (new_str_p);
        -: 1290:} /* ecma_builtin_string_prototype_object_substr */
        -: 1291:
        -: 1292:#endif /* ENABLED (JERRY_BUILTIN_ANNEXB) */
        -: 1293:
        -: 1294:#if ENABLED (JERRY_ES2015)
        -: 1295:
        -: 1296:/**
        -: 1297: * The String.prototype object's @@iterator routine
        -: 1298: *
        -: 1299: * See also:
        -: 1300: *          ECMA-262 v6, 21.1.3.27
        -: 1301: *
        -: 1302: * @return ecma value
        -: 1303: *         Returned value must be freed with ecma_free_value.
        -: 1304: */
        -: 1305:static ecma_value_t
    #####: 1306:ecma_builtin_string_prototype_object_iterator (ecma_value_t to_string) /**< this argument */
        -: 1307:{
    #####: 1308:  return ecma_op_create_iterator_object (ecma_copy_value (to_string),
        -: 1309:                                         ecma_builtin_get (ECMA_BUILTIN_ID_STRING_ITERATOR_PROTOTYPE),
        -: 1310:                                         ECMA_PSEUDO_STRING_ITERATOR,
        -: 1311:                                         0);
        -: 1312:} /* ecma_builtin_string_prototype_object_iterator */
        -: 1313:
        -: 1314:#endif /* ENABLED (JERRY_ES2015) */
        -: 1315:
        -: 1316:/**
        -: 1317: * Dispatcher of the built-in's routines
        -: 1318: *
        -: 1319: * @return ecma value
        -: 1320: *         Returned value must be freed with ecma_free_value.
        -: 1321: */
        -: 1322:ecma_value_t
    #####: 1323:ecma_builtin_string_prototype_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine
        -: 1324:                                                                              *   identifier */
        -: 1325:                                                ecma_value_t this_arg, /**< 'this' argument value */
        -: 1326:                                                const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1327:                                                                                      *   passed to routine */
        -: 1328:                                                ecma_length_t arguments_number) /**< length of arguments' list */
        -: 1329:{
    #####: 1330:  if (builtin_routine_id <= ECMA_STRING_PROTOTYPE_VALUE_OF)
        -: 1331:  {
    #####: 1332:    return ecma_builtin_string_prototype_object_to_string (this_arg);
        -: 1333:  }
        -: 1334:
    #####: 1335:  ecma_value_t coercible = ecma_op_check_object_coercible (this_arg);
        -: 1336:
    #####: 1337:  if (ECMA_IS_VALUE_ERROR (coercible))
        -: 1338:  {
    #####: 1339:    return coercible;
        -: 1340:  }
        -: 1341:
    #####: 1342:  ecma_value_t arg1 = arguments_list_p[0];
    #####: 1343:  ecma_value_t arg2 = arguments_list_p[1];
        -: 1344:
        -: 1345:#if ENABLED (JERRY_BUILTIN_REGEXP)
    #####: 1346:  if (builtin_routine_id == ECMA_STRING_PROTOTYPE_MATCH)
        -: 1347:  {
    #####: 1348:    return ecma_builtin_string_prototype_object_match (this_arg, arg1);
        -: 1349:  }
        -: 1350:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
        -: 1351:
    #####: 1352:  if (builtin_routine_id <= ECMA_STRING_PROTOTYPE_CHAR_CODE_AT)
        -: 1353:  {
    #####: 1354:    return ecma_builtin_string_prototype_char_at_helper (this_arg,
        -: 1355:                                                         arg1,
        -: 1356:                                                         builtin_routine_id == ECMA_STRING_PROTOTYPE_CHAR_CODE_AT);
        -: 1357:  }
        -: 1358:
    #####: 1359:  ecma_string_t *string_p = ecma_op_to_string (this_arg);
        -: 1360:
    #####: 1361:  if (JERRY_UNLIKELY (string_p == NULL))
        -: 1362:  {
    #####: 1363:    return ECMA_VALUE_ERROR;
        -: 1364:  }
        -: 1365:
    #####: 1366:  ecma_value_t to_string_val = ecma_make_string_value (string_p);
    #####: 1367:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1368:
    #####: 1369:  switch (builtin_routine_id)
        -: 1370:  {
    #####: 1371:    case ECMA_STRING_PROTOTYPE_CONCAT:
        -: 1372:    {
    #####: 1373:      ret_value = ecma_builtin_string_prototype_object_concat (string_p, arguments_list_p, arguments_number);
    #####: 1374:      break;
        -: 1375:    }
    #####: 1376:    case ECMA_STRING_PROTOTYPE_SLICE:
        -: 1377:    {
    #####: 1378:      ret_value = ecma_builtin_string_prototype_object_slice (string_p, arg1, arg2);
    #####: 1379:      break;
        -: 1380:    }
    #####: 1381:    case ECMA_STRING_PROTOTYPE_LAST_INDEX_OF:
        -: 1382:    case ECMA_STRING_PROTOTYPE_INDEX_OF:
        -: 1383:#if ENABLED (JERRY_ES2015)
        -: 1384:    case ECMA_STRING_PROTOTYPE_STARTS_WITH:
        -: 1385:    case ECMA_STRING_PROTOTYPE_INCLUDES:
        -: 1386:    case ECMA_STRING_PROTOTYPE_ENDS_WITH:
        -: 1387:#endif /* ENABLED (JERRY_ES2015) */
        -: 1388:    {
        -: 1389:      ecma_string_index_of_mode_t mode;
    #####: 1390:      mode = (ecma_string_index_of_mode_t) (builtin_routine_id - ECMA_STRING_PROTOTYPE_LAST_INDEX_OF);
    #####: 1391:      ret_value = ecma_builtin_helper_string_prototype_object_index_of (string_p, arg1, arg2, mode);
    #####: 1392:      break;
        -: 1393:    }
    #####: 1394:    case ECMA_STRING_PROTOTYPE_LOCALE_COMPARE:
        -: 1395:    {
    #####: 1396:      ret_value = ecma_builtin_string_prototype_object_locale_compare (string_p, arg1);
    #####: 1397:      break;
        -: 1398:    }
        -: 1399:#if ENABLED (JERRY_BUILTIN_REGEXP)
    #####: 1400:    case ECMA_STRING_PROTOTYPE_REPLACE:
        -: 1401:    {
    #####: 1402:      ret_value = ecma_builtin_string_prototype_object_replace (to_string_val, arg1, arg2);
    #####: 1403:      break;
        -: 1404:    }
    #####: 1405:    case ECMA_STRING_PROTOTYPE_SEARCH:
        -: 1406:    {
    #####: 1407:      ret_value = ecma_builtin_string_prototype_object_search (to_string_val, arg1);
    #####: 1408:      break;
        -: 1409:    }
        -: 1410:#endif /* ENABLED (JERRY_BUILTIN_REGEXP) */
    #####: 1411:    case ECMA_STRING_PROTOTYPE_SPLIT:
        -: 1412:    {
    #####: 1413:      ret_value = ecma_builtin_string_prototype_object_split (to_string_val, arg1, arg2);
    #####: 1414:      break;
        -: 1415:    }
    #####: 1416:    case ECMA_STRING_PROTOTYPE_SUBSTRING:
        -: 1417:    {
    #####: 1418:      ret_value = ecma_builtin_string_prototype_object_substring (string_p, arg1, arg2);
    #####: 1419:      break;
        -: 1420:    }
    #####: 1421:    case ECMA_STRING_PROTOTYPE_TO_LOWER_CASE:
        -: 1422:    case ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE:
        -: 1423:    case ECMA_STRING_PROTOTYPE_TO_UPPER_CASE:
        -: 1424:    case ECMA_STRING_PROTOTYPE_TO_LOCAL_UPPER_CASE:
        -: 1425:    {
    #####: 1426:      bool is_lower_case = builtin_routine_id <= ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE;
    #####: 1427:      ret_value = ecma_builtin_string_prototype_object_conversion_helper (string_p, is_lower_case);
    #####: 1428:      break;
        -: 1429:    }
    #####: 1430:    case ECMA_STRING_PROTOTYPE_TRIM:
        -: 1431:    {
    #####: 1432:      ret_value = ecma_builtin_string_prototype_object_trim (string_p);
    #####: 1433:      break;
        -: 1434:    }
        -: 1435:#if ENABLED (JERRY_BUILTIN_ANNEXB)
    #####: 1436:    case ECMA_STRING_PROTOTYPE_SUBSTR:
        -: 1437:    {
    #####: 1438:      ret_value = ecma_builtin_string_prototype_object_substr (string_p, arg1, arg2);
    #####: 1439:      break;
        -: 1440:    }
        -: 1441:#endif /* ENABLED (JERRY_BUILTIN_ANNEXB) */
        -: 1442:#if ENABLED (JERRY_ES2015)
    #####: 1443:    case ECMA_STRING_PROTOTYPE_REPEAT:
        -: 1444:    {
    #####: 1445:      ret_value = ecma_builtin_string_prototype_object_repeat (string_p, arg1);
    #####: 1446:      break;
        -: 1447:    }
    #####: 1448:    case ECMA_STRING_PROTOTYPE_CODE_POINT_AT:
        -: 1449:    {
    #####: 1450:      ret_value = ecma_builtin_string_prototype_object_code_point_at (string_p, arg1);
    #####: 1451:      break;
        -: 1452:    }
    #####: 1453:    case ECMA_STRING_PROTOTYPE_ITERATOR:
        -: 1454:    {
    #####: 1455:      ret_value = ecma_builtin_string_prototype_object_iterator (to_string_val);
    #####: 1456:      break;
        -: 1457:    }
        -: 1458:#endif /* ENABLED (JERRY_ES2015) */
    #####: 1459:    default:
        -: 1460:    {
    #####: 1461:      JERRY_UNREACHABLE ();
        -: 1462:    }
        -: 1463:  }
        -: 1464:
    #####: 1465:  ecma_deref_ecma_string (string_p);
        -: 1466:
    #####: 1467:  return ret_value;
        -: 1468:} /* ecma_builtin_string_prototype_dispatch_routine */
        -: 1469:
        -: 1470:/**
        -: 1471: * @}
        -: 1472: * @}
        -: 1473: * @}
        -: 1474: */
        -: 1475:
        -: 1476:#endif /* ENABLED (JERRY_BUILTIN_STRING) */
