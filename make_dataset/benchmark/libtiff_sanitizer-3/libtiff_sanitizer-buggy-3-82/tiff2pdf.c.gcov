        -:    0:Source:tiff2pdf.c
        -:    1:/* $Id$
        -:    2: *
        -:    3: * tiff2pdf - converts a TIFF image to a PDF document
        -:    4: *
        -:    5: * Copyright (c) 2003 Ross Finlayson
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the name of
        -:   11: * Ross Finlayson may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Ross Finlayson.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL ROSS FINLAYSON BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:#include "tif_config.h"
        -:   28:
        -:   29:#include <stdio.h>
        -:   30:#include <stdlib.h>
        -:   31:#include <string.h>
        -:   32:#include <ctype.h>
        -:   33:#include <time.h>
        -:   34:#include <errno.h>
        -:   35:#include <limits.h>
        -:   36:
        -:   37:#if HAVE_UNISTD_H
        -:   38:# include <unistd.h>
        -:   39:#endif
        -:   40:
        -:   41:#ifdef HAVE_FCNTL_H
        -:   42:# include <fcntl.h>
        -:   43:#endif
        -:   44:
        -:   45:#ifdef HAVE_IO_H
        -:   46:# include <io.h>
        -:   47:#endif
        -:   48:
        -:   49:#ifdef NEED_LIBPORT
        -:   50:# include "libport.h"
        -:   51:#endif
        -:   52:
        -:   53:#include "tiffiop.h"
        -:   54:#include "tiffio.h"
        -:   55:
        -:   56:#ifndef HAVE_GETOPT
        -:   57:extern int getopt(int, char**, char*);
        -:   58:#endif
        -:   59:
        -:   60:#ifndef EXIT_SUCCESS
        -:   61:# define EXIT_SUCCESS	0
        -:   62:#endif
        -:   63:#ifndef EXIT_FAILURE
        -:   64:# define EXIT_FAILURE	1
        -:   65:#endif
        -:   66:
        -:   67:#define TIFF2PDF_MODULE "tiff2pdf"
        -:   68:
        -:   69:#define PS_UNIT_SIZE	72.0F
        -:   70:
        -:   71:/* This type is of PDF color spaces. */
        -:   72:typedef enum {
        -:   73:	T2P_CS_BILEVEL = 0x01,	/* Bilevel, black and white */
        -:   74:	T2P_CS_GRAY = 0x02,	/* Single channel */
        -:   75:	T2P_CS_RGB = 0x04,	/* Three channel tristimulus RGB */
        -:   76:	T2P_CS_CMYK = 0x08,	/* Four channel CMYK print inkset */
        -:   77:	T2P_CS_LAB = 0x10,	/* Three channel L*a*b* color space */
        -:   78:	T2P_CS_PALETTE = 0x1000,/* One of the above with a color map */
        -:   79:	T2P_CS_CALGRAY = 0x20,	/* Calibrated single channel */
        -:   80:	T2P_CS_CALRGB = 0x40,	/* Calibrated three channel tristimulus RGB */
        -:   81:	T2P_CS_ICCBASED = 0x80	/* ICC profile color specification */
        -:   82:} t2p_cs_t;
        -:   83:
        -:   84:/* This type is of PDF compression types.  */
        -:   85:typedef enum{
        -:   86:	T2P_COMPRESS_NONE=0x00
        -:   87:#ifdef CCITT_SUPPORT
        -:   88:	, T2P_COMPRESS_G4=0x01
        -:   89:#endif
        -:   90:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
        -:   91:	, T2P_COMPRESS_JPEG=0x02
        -:   92:#endif
        -:   93:#ifdef ZIP_SUPPORT
        -:   94:	, T2P_COMPRESS_ZIP=0x04
        -:   95:#endif
        -:   96:} t2p_compress_t;
        -:   97:
        -:   98:/* This type is whether TIFF image data can be used in PDF without transcoding. */
        -:   99:typedef enum{
        -:  100:	T2P_TRANSCODE_RAW=0x01, /* The raw data from the input can be used without recompressing */
        -:  101:	T2P_TRANSCODE_ENCODE=0x02 /* The data from the input is perhaps unencoded and reencoded */
        -:  102:} t2p_transcode_t;
        -:  103:
        -:  104:/* This type is of information about the data samples of the input image. */
        -:  105:typedef enum{
        -:  106:	T2P_SAMPLE_NOTHING=0x0000, /* The unencoded samples are normal for the output colorspace */
        -:  107:	T2P_SAMPLE_ABGR_TO_RGB=0x0001, /* The unencoded samples are the result of ReadRGBAImage */
        -:  108:	T2P_SAMPLE_RGBA_TO_RGB=0x0002, /* The unencoded samples are contiguous RGBA */
        -:  109:	T2P_SAMPLE_RGBAA_TO_RGB=0x0004, /* The unencoded samples are RGBA with premultiplied alpha */
        -:  110:	T2P_SAMPLE_YCBCR_TO_RGB=0x0008, 
        -:  111:	T2P_SAMPLE_YCBCR_TO_LAB=0x0010, 
        -:  112:	T2P_SAMPLE_REALIZE_PALETTE=0x0020, /* The unencoded samples are indexes into the color map */
        -:  113:	T2P_SAMPLE_SIGNED_TO_UNSIGNED=0x0040, /* The unencoded samples are signed instead of unsignd */
        -:  114:	T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED=0x0040, /* The L*a*b* samples have a* and b* signed */
        -:  115:	T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG=0x0100 /* The unencoded samples are separate instead of contiguous */
        -:  116:} t2p_sample_t;
        -:  117:
        -:  118:/* This type is of error status of the T2P struct. */
        -:  119:typedef enum{
        -:  120:	T2P_ERR_OK = 0, /* This is the value of t2p->t2p_error when there is no error */
        -:  121:	T2P_ERR_ERROR = 1 /* This is the value of t2p->t2p_error when there was an error */
        -:  122:} t2p_err_t;
        -:  123:
        -:  124:/* This struct defines a logical page of a TIFF. */
        -:  125:typedef struct {
        -:  126:	tdir_t page_directory;
        -:  127:	uint32 page_number;
        -:  128:	ttile_t page_tilecount;
        -:  129:	uint32 page_extra;
        -:  130:} T2P_PAGE;
        -:  131:
        -:  132:/* This struct defines a PDF rectangle's coordinates. */
        -:  133:typedef struct {
        -:  134:	float x1;
        -:  135:	float y1;
        -:  136:	float x2;
        -:  137:	float y2;
        -:  138:	float mat[9];
        -:  139:} T2P_BOX;
        -:  140:
        -:  141:/* This struct defines a tile of a PDF.  */
        -:  142:typedef struct {
        -:  143:	T2P_BOX tile_box;
        -:  144:} T2P_TILE;
        -:  145:
        -:  146:/* This struct defines information about the tiles on a PDF page. */
        -:  147:typedef struct {
        -:  148:	ttile_t tiles_tilecount;
        -:  149:	uint32 tiles_tilewidth;
        -:  150:	uint32 tiles_tilelength;
        -:  151:	uint32 tiles_tilecountx;
        -:  152:	uint32 tiles_tilecounty;
        -:  153:	uint32 tiles_edgetilewidth;
        -:  154:	uint32 tiles_edgetilelength;
        -:  155:	T2P_TILE* tiles_tiles;
        -:  156:} T2P_TILES;
        -:  157:
        -:  158:/* This struct is the context of a function to generate PDF from a TIFF. */
        -:  159:typedef struct {
        -:  160:	t2p_err_t t2p_error;
        -:  161:	T2P_PAGE* tiff_pages;
        -:  162:	T2P_TILES* tiff_tiles;
        -:  163:	tdir_t tiff_pagecount;
        -:  164:	uint16 tiff_compression;
        -:  165:	uint16 tiff_photometric;
        -:  166:	uint16 tiff_fillorder;
        -:  167:	uint16 tiff_bitspersample;
        -:  168:	uint16 tiff_samplesperpixel;
        -:  169:	uint16 tiff_planar;
        -:  170:	uint32 tiff_width;
        -:  171:	uint32 tiff_length;
        -:  172:	float tiff_xres;
        -:  173:	float tiff_yres;
        -:  174:	uint16 tiff_orientation;
        -:  175:	toff_t tiff_dataoffset;
        -:  176:	tsize_t tiff_datasize;
        -:  177:	uint16 tiff_resunit;
        -:  178:	uint16 pdf_centimeters;
        -:  179:	uint16 pdf_overrideres;
        -:  180:	uint16 pdf_overridepagesize;
        -:  181:	float pdf_defaultxres;
        -:  182:	float pdf_defaultyres;
        -:  183:	float pdf_xres;
        -:  184:	float pdf_yres;
        -:  185:	float pdf_defaultpagewidth;
        -:  186:	float pdf_defaultpagelength;
        -:  187:	float pdf_pagewidth;
        -:  188:	float pdf_pagelength;
        -:  189:	float pdf_imagewidth;
        -:  190:	float pdf_imagelength;
        -:  191:	int pdf_image_fillpage; /* 0 (default: no scaling, 1:scale imagesize to pagesize */
        -:  192:	T2P_BOX pdf_mediabox;
        -:  193:	T2P_BOX pdf_imagebox;
        -:  194:	uint16 pdf_majorversion;
        -:  195:	uint16 pdf_minorversion;
        -:  196:	uint32 pdf_catalog;
        -:  197:	uint32 pdf_pages;
        -:  198:	uint32 pdf_info;
        -:  199:	uint32 pdf_palettecs;
        -:  200:	uint16 pdf_fitwindow;
        -:  201:	uint32 pdf_startxref;
        -:  202:#define TIFF2PDF_FILEID_SIZE 33
        -:  203:	char pdf_fileid[TIFF2PDF_FILEID_SIZE];
        -:  204:#define TIFF2PDF_DATETIME_SIZE 17
        -:  205:	char pdf_datetime[TIFF2PDF_DATETIME_SIZE];
        -:  206:#define TIFF2PDF_CREATOR_SIZE 512
        -:  207:	char pdf_creator[TIFF2PDF_CREATOR_SIZE];
        -:  208:#define TIFF2PDF_AUTHOR_SIZE 512
        -:  209:	char pdf_author[TIFF2PDF_AUTHOR_SIZE];
        -:  210:#define TIFF2PDF_TITLE_SIZE 512
        -:  211:	char pdf_title[TIFF2PDF_TITLE_SIZE];
        -:  212:#define TIFF2PDF_SUBJECT_SIZE 512
        -:  213:	char pdf_subject[TIFF2PDF_SUBJECT_SIZE];
        -:  214:#define TIFF2PDF_KEYWORDS_SIZE 512
        -:  215:	char pdf_keywords[TIFF2PDF_KEYWORDS_SIZE];
        -:  216:	t2p_cs_t pdf_colorspace;
        -:  217:	uint16 pdf_colorspace_invert;
        -:  218:	uint16 pdf_switchdecode;
        -:  219:	uint16 pdf_palettesize;
        -:  220:	unsigned char* pdf_palette;
        -:  221:	int pdf_labrange[4];
        -:  222:	t2p_compress_t pdf_defaultcompression;
        -:  223:	uint16 pdf_defaultcompressionquality;
        -:  224:	t2p_compress_t pdf_compression;
        -:  225:	uint16 pdf_compressionquality;
        -:  226:	uint16 pdf_nopassthrough;
        -:  227:	t2p_transcode_t pdf_transcode;
        -:  228:	t2p_sample_t pdf_sample;
        -:  229:	uint32* pdf_xrefoffsets;
        -:  230:	uint32 pdf_xrefcount;
        -:  231:	tdir_t pdf_page;
        -:  232:#ifdef OJPEG_SUPPORT
        -:  233:	tdata_t pdf_ojpegdata;
        -:  234:	uint32 pdf_ojpegdatalength;
        -:  235:	uint32 pdf_ojpegiflength;
        -:  236:#endif
        -:  237:	float tiff_whitechromaticities[2];
        -:  238:	float tiff_primarychromaticities[6];
        -:  239:	float tiff_referenceblackwhite[2];
        -:  240:	float* tiff_transferfunction[3];
        -:  241:	int pdf_image_interpolate;	/* 0 (default) : do not interpolate,
        -:  242:					   1 : interpolate */
        -:  243:	uint16 tiff_transferfunctioncount;
        -:  244:	uint32 pdf_icccs;
        -:  245:	uint32 tiff_iccprofilelength;
        -:  246:	tdata_t tiff_iccprofile;
        -:  247:
        -:  248:	/* fields for custom read/write procedures */
        -:  249:	FILE *outputfile;
        -:  250:	int outputdisable;
        -:  251:	tsize_t outputwritten;
        -:  252:} T2P;
        -:  253:
        -:  254:/* These functions are called by main. */
        -:  255:
        -:  256:void tiff2pdf_usage(void);
        -:  257:int tiff2pdf_match_paper_size(float*, float*, char*);
        -:  258:
        -:  259:/* These functions are used to generate a PDF from a TIFF. */ 
        -:  260:
        -:  261:#ifdef __cplusplus
        -:  262:extern "C" {
        -:  263:#endif
        -:  264:
        -:  265:T2P* t2p_init(void);
        -:  266:void t2p_validate(T2P*);
        -:  267:tsize_t t2p_write_pdf(T2P*, TIFF*, TIFF*);
        -:  268:void t2p_free(T2P*);
        -:  269:
        -:  270:#ifdef __cplusplus
        -:  271:}
        -:  272:#endif
        -:  273:
        -:  274:void t2p_read_tiff_init(T2P*, TIFF*);
        -:  275:int t2p_cmp_t2p_page(const void*, const void*);
        -:  276:void t2p_read_tiff_data(T2P*, TIFF*);
        -:  277:void t2p_read_tiff_size(T2P*, TIFF*);
        -:  278:void t2p_read_tiff_size_tile(T2P*, TIFF*, ttile_t);
        -:  279:int t2p_tile_is_right_edge(T2P_TILES, ttile_t);
        -:  280:int t2p_tile_is_bottom_edge(T2P_TILES, ttile_t);
        -:  281:int t2p_tile_is_edge(T2P_TILES, ttile_t);
        -:  282:int t2p_tile_is_corner_edge(T2P_TILES, ttile_t);
        -:  283:tsize_t t2p_readwrite_pdf_image(T2P*, TIFF*, TIFF*);
        -:  284:tsize_t t2p_readwrite_pdf_image_tile(T2P*, TIFF*, TIFF*, ttile_t);
        -:  285:#ifdef OJPEG_SUPPORT
        -:  286:int t2p_process_ojpeg_tables(T2P*, TIFF*);
        -:  287:#endif
        -:  288:#ifdef JPEG_SUPPORT
        -:  289:int t2p_process_jpeg_strip(unsigned char*, tsize_t*, unsigned char*, tsize_t, tsize_t*, tstrip_t, uint32);
        -:  290:#endif
        -:  291:void t2p_tile_collapse_left(tdata_t, tsize_t, uint32, uint32, uint32);
        -:  292:void t2p_write_advance_directory(T2P*, TIFF*);
        -:  293:tsize_t t2p_sample_planar_separate_to_contig(T2P*, unsigned char*, unsigned char*, tsize_t);
        -:  294:tsize_t t2p_sample_realize_palette(T2P*, unsigned char*);
        -:  295:tsize_t t2p_sample_abgr_to_rgb(tdata_t, uint32);
        -:  296:tsize_t t2p_sample_rgba_to_rgb(tdata_t, uint32);
        -:  297:tsize_t t2p_sample_rgbaa_to_rgb(tdata_t, uint32);
        -:  298:tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t, uint32);
        -:  299:tsize_t t2p_write_pdf_header(T2P*, TIFF*);
        -:  300:tsize_t t2p_write_pdf_obj_start(uint32, TIFF*);
        -:  301:tsize_t t2p_write_pdf_obj_end(TIFF*);
        -:  302:tsize_t t2p_write_pdf_name(unsigned char*, TIFF*);
        -:  303:tsize_t t2p_write_pdf_string(char*, TIFF*);
        -:  304:tsize_t t2p_write_pdf_stream(tdata_t, tsize_t, TIFF*);
        -:  305:tsize_t t2p_write_pdf_stream_start(TIFF*);
        -:  306:tsize_t t2p_write_pdf_stream_end(TIFF*);
        -:  307:tsize_t t2p_write_pdf_stream_dict(tsize_t, uint32, TIFF*);
        -:  308:tsize_t t2p_write_pdf_stream_dict_start(TIFF*);
        -:  309:tsize_t t2p_write_pdf_stream_dict_end(TIFF*);
        -:  310:tsize_t t2p_write_pdf_stream_length(tsize_t, TIFF*);
        -:  311:tsize_t t2p_write_pdf_catalog(T2P*, TIFF*);
        -:  312:tsize_t t2p_write_pdf_info(T2P*, TIFF*, TIFF*);
        -:  313:void t2p_pdf_currenttime(T2P*);
        -:  314:void t2p_pdf_tifftime(T2P*, TIFF*);
        -:  315:tsize_t t2p_write_pdf_pages(T2P*, TIFF*);
        -:  316:tsize_t t2p_write_pdf_page(uint32, T2P*, TIFF*);
        -:  317:void t2p_compose_pdf_page(T2P*);
        -:  318:void t2p_compose_pdf_page_orient(T2P_BOX*, uint16);
        -:  319:void t2p_compose_pdf_page_orient_flip(T2P_BOX*, uint16);
        -:  320:tsize_t t2p_write_pdf_page_content(T2P*, TIFF*);
        -:  321:tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t, T2P*, TIFF*);
        -:  322:tsize_t t2p_write_pdf_xobject_cs(T2P*, TIFF*);
        -:  323:tsize_t t2p_write_pdf_transfer(T2P*, TIFF*);
        -:  324:tsize_t t2p_write_pdf_transfer_dict(T2P*, TIFF*, uint16);
        -:  325:tsize_t t2p_write_pdf_transfer_stream(T2P*, TIFF*, uint16);
        -:  326:tsize_t t2p_write_pdf_xobject_calcs(T2P*, TIFF*);
        -:  327:tsize_t t2p_write_pdf_xobject_icccs(T2P*, TIFF*);
        -:  328:tsize_t t2p_write_pdf_xobject_icccs_dict(T2P*, TIFF*);
        -:  329:tsize_t t2p_write_pdf_xobject_icccs_stream(T2P*, TIFF*);
        -:  330:tsize_t t2p_write_pdf_xobject_cs_stream(T2P*, TIFF*);
        -:  331:tsize_t t2p_write_pdf_xobject_decode(T2P*, TIFF*);
        -:  332:tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t, T2P*, TIFF*);
        -:  333:tsize_t t2p_write_pdf_xreftable(T2P*, TIFF*);
        -:  334:tsize_t t2p_write_pdf_trailer(T2P*, TIFF*);
        -:  335:
        -:  336:#define check_snprintf_ret(t2p, rv, buf) do { \
        -:  337:	if ((rv) < 0) rv = 0; \
        -:  338:	else if((rv) >= (int)sizeof(buf)) (rv) = sizeof(buf) - 1; \
        -:  339:	else break; \
        -:  340:	if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; \
        -:  341:} while(0)
        -:  342:
        -:  343:static void
    #####:  344:t2p_disable(TIFF *tif)
        -:  345:{
    #####:  346:	T2P *t2p = (T2P*) TIFFClientdata(tif);
    #####:  347:	t2p->outputdisable = 1;
    #####:  348:}
        -:  349:
        -:  350:static void
    #####:  351:t2p_enable(TIFF *tif)
        -:  352:{
    #####:  353:	T2P *t2p = (T2P*) TIFFClientdata(tif);
    #####:  354:	t2p->outputdisable = 0;
    #####:  355:}
        -:  356:
        -:  357:/*
        -:  358: * Procs for TIFFClientOpen
        -:  359: */
        -:  360:
        -:  361:#ifdef OJPEG_SUPPORT
        -:  362:static tmsize_t 
    #####:  363:t2pReadFile(TIFF *tif, tdata_t data, tmsize_t size)
        -:  364:{
    #####:  365:	thandle_t client = TIFFClientdata(tif);
    #####:  366:	TIFFReadWriteProc proc = TIFFGetReadProc(tif);
    #####:  367:	if (proc)
    #####:  368:		return proc(client, data, size);
    #####:  369:	return -1;
        -:  370:}
        -:  371:#endif /* OJPEG_SUPPORT */
        -:  372:
        -:  373:static tmsize_t 
    #####:  374:t2pWriteFile(TIFF *tif, tdata_t data, tmsize_t size)
        -:  375:{
    #####:  376:	thandle_t client = TIFFClientdata(tif);
    #####:  377:	TIFFReadWriteProc proc = TIFFGetWriteProc(tif);
    #####:  378:	if (proc)
    #####:  379:		return proc(client, data, size);
    #####:  380:	return -1;
        -:  381:}
        -:  382:
        -:  383:static uint64
    #####:  384:t2pSeekFile(TIFF *tif, toff_t offset, int whence)
        -:  385:{
    #####:  386:	thandle_t client = TIFFClientdata(tif);
    #####:  387:	TIFFSeekProc proc = TIFFGetSeekProc(tif);
    #####:  388:	if (proc)
    #####:  389:		return proc(client, offset, whence);
    #####:  390:	return -1;
        -:  391:}
        -:  392:
        -:  393:static tmsize_t 
    #####:  394:t2p_readproc(thandle_t handle, tdata_t data, tmsize_t size) 
        -:  395:{
        -:  396:	(void) handle, (void) data, (void) size;
    #####:  397:	return -1;
        -:  398:}
        -:  399:
        -:  400:static tmsize_t 
    #####:  401:t2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size) 
        -:  402:{
    #####:  403:	T2P *t2p = (T2P*) handle;
    #####:  404:	if (t2p->outputdisable <= 0 && t2p->outputfile) {
    #####:  405:		tsize_t written = fwrite(data, 1, size, t2p->outputfile);
    #####:  406:		t2p->outputwritten += written;
    #####:  407:		return written;
        -:  408:	}
    #####:  409:	return size; 
        -:  410:}
        -:  411:
        -:  412:static uint64 
    #####:  413:t2p_seekproc(thandle_t handle, uint64 offset, int whence) 
        -:  414:{ 
    #####:  415:	T2P *t2p = (T2P*) handle;
    #####:  416:	if (t2p->outputdisable <= 0 && t2p->outputfile)
    #####:  417:		return _TIFF_fseek_f(t2p->outputfile, (_TIFF_off_t) offset, whence);
    #####:  418:	return offset;
        -:  419:}
        -:  420:
        -:  421:static int 
    #####:  422:t2p_closeproc(thandle_t handle)
        -:  423:{ 
    #####:  424:	T2P *t2p = (T2P*) handle;
    #####:  425:	return fclose(t2p->outputfile);
        -:  426:}
        -:  427:
        -:  428:static uint64 
    #####:  429:t2p_sizeproc(thandle_t handle) 
        -:  430:{
        -:  431:	(void) handle;
    #####:  432:	return -1;
        -:  433:}
        -:  434:
        -:  435:static int 
    #####:  436:t2p_mapproc(thandle_t handle, void **data, toff_t *offset) 
        -:  437:{ 
        -:  438:	(void) handle, (void) data, (void) offset;
    #####:  439:	return -1; 
        -:  440:}
        -:  441:
        -:  442:static void 
    #####:  443:t2p_unmapproc(thandle_t handle, void *data, toff_t offset)
        -:  444:{ 
        -:  445:	(void) handle, (void) data, (void) offset;
    #####:  446:}
        -:  447:
        -:  448:#if defined(OJPEG_SUPPORT) || defined(JPEG_SUPPORT)
        -:  449:static uint64
    #####:  450:checkAdd64(uint64 summand1, uint64 summand2, T2P* t2p)
        -:  451:{
    #####:  452:	uint64 bytes = summand1 + summand2;
        -:  453:
    #####:  454:	if (bytes < summand1) {
    #####:  455:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####:  456:		t2p->t2p_error = T2P_ERR_ERROR;
    #####:  457:		bytes = 0;
        -:  458:	}
        -:  459:
    #####:  460:	return bytes;
        -:  461:}
        -:  462:#endif /* defined(OJPEG_SUPPORT) || defined(JPEG_SUPPORT) */
        -:  463:
        -:  464:static uint64
    #####:  465:checkMultiply64(uint64 first, uint64 second, T2P* t2p)
        -:  466:{
    #####:  467:	uint64 bytes = first * second;
        -:  468:
    #####:  469:	if (second && bytes / second != first) {
    #####:  470:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####:  471:		t2p->t2p_error = T2P_ERR_ERROR;
    #####:  472:		bytes = 0;
        -:  473:	}
        -:  474:
    #####:  475:	return bytes;
        -:  476:}
        -:  477:
        -:  478:/*
        -:  479:
        -:  480:  This is the main function.
        -:  481:
        -:  482:  The program converts one TIFF file to one PDF file, including multiple page 
        -:  483:  TIFF files, tiled TIFF files, black and white. grayscale, and color TIFF 
        -:  484:  files that contain data of TIFF photometric interpretations of bilevel, 
        -:  485:  grayscale, RGB, YCbCr, CMYK separation, and ICC L*a*b* as supported by 
        -:  486:  libtiff and PDF.
        -:  487:
        -:  488:  If you have multiple TIFF files to convert into one PDF file then use tiffcp 
        -:  489:  or other program to concatenate the files into a multiple page TIFF file.  
        -:  490:  If the input TIFF file is of huge dimensions (greater than 10000 pixels height
        -:  491:  or width) convert the input image to a tiled TIFF if it is not already.
        -:  492:
        -:  493:  The standard output is standard output.  Set the output file name with the 
        -:  494:  "-o output.pdf" option.
        -:  495:
        -:  496:  All black and white files are compressed into a single strip CCITT G4 Fax 
        -:  497:  compressed PDF, unless tiled, where tiled black and white images are 
        -:  498:  compressed into tiled CCITT G4 Fax compressed PDF, libtiff CCITT support 
        -:  499:  is assumed.
        -:  500:
        -:  501:  Color and grayscale data can be compressed using either JPEG compression, 
        -:  502:  ITU-T T.81, or Zip/Deflate LZ77 compression, per PNG 1.2 and RFC 1951.  Set 
        -:  503:  the compression type using the -j or -z options.  JPEG compression support 
        -:  504:  requires that libtiff be configured with JPEG support, and Zip/Deflate 
        -:  505:  compression support requires that libtiff is configured with Zip support, 
        -:  506:  in tiffconf.h.  Use only one or the other of -j and -z.  The -q option 
        -:  507:  sets the image compression quality, that is 1-100 with libjpeg JPEG 
        -:  508:  compression and one of 1, 10, 11, 12, 13, 14, or 15 for PNG group compression 
        -:  509:  predictor methods, add 100, 200, ..., 900 to set zlib compression quality 1-9.
        -:  510:  PNG Group differencing predictor methods are not currently implemented.
        -:  511:
        -:  512:  If the input TIFF contains single strip CCITT G4 Fax compressed information, 
        -:  513:  then that is written to the PDF file without transcoding, unless the options 
        -:  514:  of no compression and no passthrough are set, -d and -n.
        -:  515:
        -:  516:  If the input TIFF contains JPEG or single strip Zip/Deflate compressed 
        -:  517:  information, and they are configured, then that is written to the PDF file 
        -:  518:  without transcoding, unless the options of no compression and no passthrough 
        -:  519:  are set.
        -:  520:
        -:  521:  The default page size upon which the TIFF image is placed is determined by 
        -:  522:  the resolution and extent of the image data.  Default values for the TIFF 
        -:  523:  image resolution can be set using the -x and -y options.  The page size can 
        -:  524:  be set using the -p option for paper size, or -w and -l for paper width and 
        -:  525:  length, then each page of the TIFF image is centered on its page.  The 
        -:  526:  distance unit for default resolution and page width and length can be set 
        -:  527:  by the -u option, the default unit is inch.
        -:  528:
        -:  529:  Various items of the output document information can be set with the -e, -c, 
        -:  530:  -a, -t, -s, and -k tags.  Setting the argument of the option to "" for these 
        -:  531:  tags causes the relevant document information field to be not written.  Some 
        -:  532:  of the document information values otherwise get their information from the 
        -:  533:  input TIFF image, the software, author, document name, and image description.
        -:  534:
        -:  535:  The output PDF file conforms to the PDF 1.1 specification or PDF 1.2 if using 
        -:  536:  Zip/Deflate compression.  
        -:  537:  
        -:  538:  The Portable Document Format (PDF) specification is copyrighted by Adobe 
        -:  539:  Systems, Incorporated.  Todos derechos reservados.
        -:  540:
        -:  541:  Here is a listing of the usage example and the options to the tiff2pdf 
        -:  542:  program that is part of the libtiff distribution.  Options followed by 
        -:  543:  a colon have a required argument.
        -:  544:  
        -:  545:    usage:  tiff2pdf [options] input.tif
        -:  546:
        -:  547:    options:
        -:  548:    -o: output to file name
        -:  549:
        -:  550:    -j: compress with JPEG (requires libjpeg configured with libtiff)
        -:  551:    -z: compress with Zip/Deflate (requires zlib configured with libtiff)
        -:  552:    -q: compression quality
        -:  553:    -n: no compressed data passthrough
        -:  554:    -d: do not compress (decompress)
        -:  555:    -i: invert colors
        -:  556:    -u: set distance unit, 'i' for inch, 'm' for centimeter
        -:  557:    -x: set x resolution default
        -:  558:    -y: set y resolution default
        -:  559:    -w: width in units
        -:  560:    -l: length in units
        -:  561:    -r: 'd' for resolution default, 'o' for resolution override
        -:  562:    -p: paper size, eg "letter", "legal", "a4"
        -:  563:    -F: make the tiff fill the PDF page
        -:  564:    -f: set pdf "fit window" user preference
        -:  565:    -b:	set PDF "Interpolate" user preference
        -:  566:    -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS
        -:  567:    -c: creator, overrides image software default
        -:  568:    -a: author, overrides image artist default
        -:  569:    -t: title, overrides image document name default
        -:  570:    -s: subject, overrides image image description default
        -:  571:    -k: keywords
        -:  572:
        -:  573:    -h: usage
        -:  574:
        -:  575:    examples:
        -:  576:
        -:  577:        tiff2pdf -o output.pdf input.tiff
        -:  578:
        -:  579:    The above example would generate the file output.pdf from input.tiff.
        -:  580:
        -:  581:        tiff2pdf input.tiff
        -:  582:
        -:  583:    The above example would generate PDF output from input.tiff and write it
        -:  584:    to standard output.
        -:  585:
        -:  586:        tiff2pdf -j -p letter -o output.pdf input.tiff
        -:  587:
        -:  588:    The above example would generate the file output.pdf from input.tiff,
        -:  589:    putting the image pages on a letter sized page, compressing the output
        -:  590:    with JPEG.
        -:  591:
        -:  592:	Please report bugs through:
        -:  593:
        -:  594:	http://bugzilla.remotesensing.org/buglist.cgi?product=libtiff
        -:  595:
        -:  596:    See also libtiff.3t, tiffcp.
        -:  597:  */
        -:  598:
    #####:  599:int main(int argc, char** argv){
        -:  600:#if !HAVE_DECL_OPTARG
        -:  601:	extern char *optarg;
        -:  602:	extern int optind;
        -:  603:#endif
    #####:  604:	const char *outfilename = NULL;
    #####:  605:	T2P *t2p = NULL;
    #####:  606:	TIFF *input = NULL, *output = NULL;
    #####:  607:	int c, ret = EXIT_SUCCESS;
        -:  608:
    #####:  609:	t2p = t2p_init();
        -:  610:
    #####:  611:	if (t2p == NULL){
    #####:  612:		TIFFError(TIFF2PDF_MODULE, "Can't initialize context");
    #####:  613:		goto fail;
        -:  614:	}
        -:  615:
    #####:  616:	while (argv &&
    #####:  617:	       (c = getopt(argc, argv,
        -:  618:			   "o:q:u:x:y:w:l:r:p:e:c:a:t:s:k:jzndifbhF")) != -1){
    #####:  619:		switch (c) {
    #####:  620:			case 'o':
    #####:  621:				outfilename = optarg;
    #####:  622:				break;
        -:  623:#ifdef JPEG_SUPPORT
    #####:  624:			case 'j':  
    #####:  625:				t2p->pdf_defaultcompression=T2P_COMPRESS_JPEG;
    #####:  626:				break;
        -:  627:#endif
        -:  628:#ifndef JPEG_SUPPORT
        -:  629:			case 'j':  
        -:  630:				TIFFWarning(
        -:  631:					TIFF2PDF_MODULE, 
        -:  632:					"JPEG support in libtiff required for JPEG compression, ignoring option");
        -:  633:				break;
        -:  634:#endif
        -:  635:#ifdef ZIP_SUPPORT
        -:  636:			case 'z':  
        -:  637:				t2p->pdf_defaultcompression=T2P_COMPRESS_ZIP;
        -:  638:				break;
        -:  639:#endif
        -:  640:#ifndef ZIP_SUPPORT
    #####:  641:			case 'z':  
    #####:  642:				TIFFWarning(
        -:  643:					TIFF2PDF_MODULE, 
        -:  644:					"Zip support in libtiff required for Zip compression, ignoring option");
    #####:  645:				break;
        -:  646:#endif
    #####:  647:			case 'q': 
    #####:  648:				t2p->pdf_defaultcompressionquality=atoi(optarg);
    #####:  649:				break;
    #####:  650:			case 'n': 
    #####:  651:				t2p->pdf_nopassthrough=1;
    #####:  652:				break;
    #####:  653:			case 'd': 
    #####:  654:				t2p->pdf_defaultcompression=T2P_COMPRESS_NONE;
    #####:  655:				break;
    #####:  656:			case 'u': 
    #####:  657:				if(optarg[0]=='m'){
    #####:  658:					t2p->pdf_centimeters=1;
        -:  659:				}
    #####:  660:				break;
    #####:  661:			case 'x': 
    #####:  662:				t2p->pdf_defaultxres = 
    #####:  663:					(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  664:				break;
    #####:  665:			case 'y': 
    #####:  666:				t2p->pdf_defaultyres = 
    #####:  667:					(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  668:				break;
    #####:  669:			case 'w': 
    #####:  670:				t2p->pdf_overridepagesize=1;
    #####:  671:				t2p->pdf_defaultpagewidth = 
    #####:  672:					((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  673:				break;
    #####:  674:			case 'l': 
    #####:  675:				t2p->pdf_overridepagesize=1;
    #####:  676:				t2p->pdf_defaultpagelength = 
    #####:  677:					((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  678:				break;
    #####:  679:			case 'r': 
    #####:  680:				if(optarg[0]=='o'){
    #####:  681:					t2p->pdf_overrideres=1;
        -:  682:				}
    #####:  683:				break;
    #####:  684:			case 'p': 
    #####:  685:				if(tiff2pdf_match_paper_size(
        -:  686:					&(t2p->pdf_defaultpagewidth), 
        -:  687:					&(t2p->pdf_defaultpagelength), 
        -:  688:					optarg)){
    #####:  689:					t2p->pdf_overridepagesize=1;
        -:  690:				} else {
    #####:  691:					TIFFWarning(TIFF2PDF_MODULE, 
        -:  692:					"Unknown paper size %s, ignoring option",
        -:  693:						optarg);
        -:  694:				}
    #####:  695:				break;
    #####:  696:			case 'i':
    #####:  697:				t2p->pdf_colorspace_invert=1;
    #####:  698:				break;
    #####:  699:			case 'F':
    #####:  700:				t2p->pdf_image_fillpage = 1;
    #####:  701:				break;
    #####:  702:			case 'f': 
    #####:  703:				t2p->pdf_fitwindow=1;
    #####:  704:				break;
    #####:  705:			case 'e':
    #####:  706:				if (strlen(optarg) == 0) {
    #####:  707:					t2p->pdf_datetime[0] = '\0';
        -:  708:				} else {
    #####:  709:					t2p->pdf_datetime[0] = 'D';
    #####:  710:					t2p->pdf_datetime[1] = ':';
    #####:  711:					strncpy(t2p->pdf_datetime + 2, optarg,
        -:  712:						sizeof(t2p->pdf_datetime) - 3);
    #####:  713:					t2p->pdf_datetime[sizeof(t2p->pdf_datetime) - 1] = '\0';
        -:  714:				}
    #####:  715:				break;
    #####:  716:			case 'c': 
    #####:  717:				strncpy(t2p->pdf_creator, optarg, sizeof(t2p->pdf_creator) - 1);
    #####:  718:				t2p->pdf_creator[sizeof(t2p->pdf_creator) - 1] = '\0';
    #####:  719:				break;
    #####:  720:			case 'a': 
    #####:  721:				strncpy(t2p->pdf_author, optarg, sizeof(t2p->pdf_author) - 1);
    #####:  722:				t2p->pdf_author[sizeof(t2p->pdf_author) - 1] = '\0';
    #####:  723:				break;
    #####:  724:			case 't': 
    #####:  725:				strncpy(t2p->pdf_title, optarg, sizeof(t2p->pdf_title) - 1);
    #####:  726:				t2p->pdf_title[sizeof(t2p->pdf_title) - 1] = '\0';
    #####:  727:				break;
    #####:  728:			case 's': 
    #####:  729:				strncpy(t2p->pdf_subject, optarg, sizeof(t2p->pdf_subject) - 1);
    #####:  730:				t2p->pdf_subject[sizeof(t2p->pdf_subject) - 1] = '\0';
    #####:  731:				break;
    #####:  732:			case 'k': 
    #####:  733:				strncpy(t2p->pdf_keywords, optarg, sizeof(t2p->pdf_keywords) - 1);
    #####:  734:				t2p->pdf_keywords[sizeof(t2p->pdf_keywords) - 1] = '\0';
    #####:  735:				break;
    #####:  736:			case 'b':
    #####:  737:				t2p->pdf_image_interpolate = 1;
    #####:  738:				break;
    #####:  739:			case 'h': 
        -:  740:			case '?': 
    #####:  741:				tiff2pdf_usage();
    #####:  742:				goto success;
        -:  743:				break;
        -:  744:		}
    #####:  745:	}
        -:  746:
        -:  747:	/*
        -:  748:	 * Input
        -:  749:	 */
    #####:  750:	if(argc > optind) {
    #####:  751:		input = TIFFOpen(argv[optind++], "r");
    #####:  752:		if (input==NULL) {
    #####:  753:			TIFFError(TIFF2PDF_MODULE, 
        -:  754:				  "Can't open input file %s for reading", 
    #####:  755:				  argv[optind-1]);
    #####:  756:			goto fail;
        -:  757:		}
        -:  758:	} else {
    #####:  759:		TIFFError(TIFF2PDF_MODULE, "No input file specified"); 
    #####:  760:		tiff2pdf_usage();
    #####:  761:		goto fail;
        -:  762:	}
        -:  763:
    #####:  764:	if(argc > optind) {
    #####:  765:		TIFFError(TIFF2PDF_MODULE, 
        -:  766:			  "No support for multiple input files"); 
    #####:  767:		tiff2pdf_usage();
    #####:  768:		goto fail;
        -:  769:	}
        -:  770:
        -:  771:	/*
        -:  772:	 * Output
        -:  773:	 */
    #####:  774:	t2p->outputdisable = 1;
    #####:  775:	if (outfilename) {
    #####:  776:		t2p->outputfile = fopen(outfilename, "wb");
    #####:  777:		if (t2p->outputfile == NULL) {
    #####:  778:			TIFFError(TIFF2PDF_MODULE,
        -:  779:				  "Can't open output file %s for writing",
        -:  780:				  outfilename);
    #####:  781:			goto fail;
        -:  782:		}
        -:  783:	} else {
    #####:  784:		outfilename = "-";
    #####:  785:		t2p->outputfile = stdout;
        -:  786:	}
        -:  787:
    #####:  788:	output = TIFFClientOpen(outfilename, "w", (thandle_t) t2p,
        -:  789:				t2p_readproc, t2p_writeproc, t2p_seekproc, 
        -:  790:				t2p_closeproc, t2p_sizeproc, 
        -:  791:				t2p_mapproc, t2p_unmapproc);
    #####:  792:	t2p->outputdisable = 0;
    #####:  793:	if (output == NULL) {
    #####:  794:		TIFFError(TIFF2PDF_MODULE,
        -:  795:			  "Can't initialize output descriptor");
    #####:  796:		goto fail;
        -:  797:	}
        -:  798:	
        -:  799:	/*
        -:  800:	 * Validate
        -:  801:	 */
    #####:  802:	t2p_validate(t2p);
    #####:  803:	t2pSeekFile(output, (toff_t) 0, SEEK_SET);
        -:  804:
        -:  805:	/*
        -:  806:	 * Write
        -:  807:	 */
    #####:  808:	t2p_write_pdf(t2p, input, output);
    #####:  809:	if (t2p->t2p_error != 0) {
    #####:  810:		TIFFError(TIFF2PDF_MODULE,
        -:  811:			  "An error occurred creating output PDF file");
    #####:  812:		goto fail;
        -:  813:	}
        -:  814:
    #####:  815:	goto success;
    #####:  816:fail:
    #####:  817:	ret = EXIT_FAILURE;
    #####:  818:success:
    #####:  819:	if(input != NULL)
    #####:  820:		TIFFClose(input);
    #####:  821:	if (output != NULL)
    #####:  822:		TIFFClose(output);
    #####:  823:	if (t2p != NULL)
    #####:  824:		t2p_free(t2p);
    #####:  825:	return ret;
        -:  826:  
        -:  827:}
        -:  828:
    #####:  829:void tiff2pdf_usage(){
    #####:  830:	char* lines[]={
        -:  831:	"usage:  tiff2pdf [options] input.tiff",
        -:  832:	"options:",
        -:  833:	" -o: output to file name",
        -:  834:#ifdef JPEG_SUPPORT
        -:  835:	" -j: compress with JPEG", 
        -:  836:#endif
        -:  837:#ifdef ZIP_SUPPORT
        -:  838:	" -z: compress with Zip/Deflate",
        -:  839:#endif
        -:  840:	" -q: compression quality",
        -:  841:	" -n: no compressed data passthrough",
        -:  842:	" -d: do not compress (decompress)",
        -:  843:	" -i: invert colors",
        -:  844:	" -u: set distance unit, 'i' for inch, 'm' for centimeter",
        -:  845:	" -x: set x resolution default in dots per unit",
        -:  846:	" -y: set y resolution default in dots per unit",
        -:  847:	" -w: width in units",
        -:  848:	" -l: length in units",
        -:  849:	" -r: 'd' for resolution default, 'o' for resolution override",
        -:  850:	" -p: paper size, eg \"letter\", \"legal\", \"A4\"",
        -:  851:  " -F: make the tiff fill the PDF page",
        -:  852:	" -f: set PDF \"Fit Window\" user preference",
        -:  853:	" -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS",
        -:  854:	" -c: sets document creator, overrides image software default",
        -:  855:	" -a: sets document author, overrides image artist default",
        -:  856:	" -t: sets document title, overrides image document name default",
        -:  857:	" -s: sets document subject, overrides image image description default",
        -:  858:	" -k: sets document keywords",
        -:  859:	" -b: set PDF \"Interpolate\" user preference",
        -:  860:	" -h: usage",
        -:  861:	NULL
        -:  862:	};
    #####:  863:	int i=0;
        -:  864:
    #####:  865:	fprintf(stderr, "%s\n\n", TIFFGetVersion());
    #####:  866:	for (i=0;lines[i]!=NULL;i++){
    #####:  867:		fprintf(stderr, "%s\n", lines[i]);
        -:  868:	}
        -:  869:
    #####:  870:	return;
        -:  871:}
        -:  872:
    #####:  873:int tiff2pdf_match_paper_size(float* width, float* length, char* papersize){
        -:  874:
        -:  875:	size_t i, len;
    #####:  876:	const char* sizes[]={
        -:  877:		"LETTER", "A4", "LEGAL",
        -:  878:		"EXECUTIVE", "LETTER", "LEGAL", "LEDGER", "TABLOID", 
        -:  879:		"A", "B", "C", "D", "E", "F", "G", "H", "J", "K", 
        -:  880:		"A10", "A9", "A8", "A7", "A6", "A5", "A4", "A3", "A2", "A1", "A0", 
        -:  881:		"2A0", "4A0", "2A", "4A", 
        -:  882:		"B10", "B9", "B8", "B7", "B6", "B5", "B4", "B3", "B2", "B1", "B0", 
        -:  883:		"JISB10", "JISB9", "JISB8", "JISB7", "JISB6", "JISB5", "JISB4", 
        -:  884:		"JISB3", "JISB2", "JISB1", "JISB0", 
        -:  885:		"C10", "C9", "C8", "C7", "C6", "C5", "C4", "C3", "C2", "C1", "C0", 
        -:  886:		"RA2", "RA1", "RA0", "SRA4", "SRA3", "SRA2", "SRA1", "SRA0", 
        -:  887:		"A3EXTRA", "A4EXTRA", 
        -:  888:		"STATEMENT", "FOLIO", "QUARTO", 
        -:  889:		NULL
        -:  890:	} ;
    #####:  891:	const int widths[]={
        -:  892:		612, 595, 612,
        -:  893:		522, 612,612,792,792,
        -:  894:		612,792,1224,1584,2448,2016,792,2016,2448,2880,
        -:  895:		74,105,147,210,298,420,595,842,1191,1684,2384,3370,4768,3370,4768,
        -:  896:		88,125,176,249,354,499,709,1001,1417,2004,2835,
        -:  897:		91,128,181,258,363,516,729,1032,1460,2064,2920,
        -:  898:		79,113,162,230,323,459,649,918,1298,1298,2599,
        -:  899:		1219,1729,2438,638,907,1276,1814,2551,
        -:  900:		914,667,
        -:  901:		396, 612, 609, 
        -:  902:		0
        -:  903:	};
    #####:  904:	const int lengths[]={
        -:  905:		792,842,1008,
        -:  906:		756,792,1008,1224,1224,
        -:  907:		792,1224,1584,2448,3168,2880,6480,10296,12672,10296,
        -:  908:		105,147,210,298,420,595,842,1191,1684,2384,3370,4768,6741,4768,6741,
        -:  909:		125,176,249,354,499,709,1001,1417,2004,2835,4008,
        -:  910:		128,181,258,363,516,729,1032,1460,2064,2920,4127,
        -:  911:		113,162,230,323,459,649,918,1298,1837,1837,3677,
        -:  912:		1729,2438,3458,907,1276,1814,2551,3628,
        -:  913:		1262,914,
        -:  914:		612, 936, 780, 
        -:  915:		0
        -:  916:	};
        -:  917:
    #####:  918:	len=strlen(papersize);
    #####:  919:	for(i=0;i<len;i++){
    #####:  920:		papersize[i]=toupper((int) papersize[i]);
        -:  921:	}
    #####:  922:	for(i=0;sizes[i]!=NULL; i++){
    #####:  923:		if (strcmp( (const char*)papersize, sizes[i])==0){
    #####:  924:			*width=(float)widths[i];
    #####:  925:			*length=(float)lengths[i];
    #####:  926:			return(1);
        -:  927:		}
        -:  928:	}
        -:  929:
    #####:  930:	return(0);
        -:  931:}
        -:  932:
        -:  933:/*
        -:  934: * This function allocates and initializes a T2P context struct pointer.
        -:  935: */
        -:  936:
    #####:  937:T2P* t2p_init()
        -:  938:{
    #####:  939:	T2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));
    #####:  940:	if(t2p==NULL){
    #####:  941:		TIFFError(
        -:  942:			TIFF2PDF_MODULE, 
        -:  943:			"Can't allocate %lu bytes of memory for t2p_init", 
        -:  944:			(unsigned long) sizeof(T2P));
    #####:  945:		return( (T2P*) NULL );
        -:  946:	}
    #####:  947:	_TIFFmemset(t2p, 0x00, sizeof(T2P));
    #####:  948:	t2p->pdf_majorversion=1;
    #####:  949:	t2p->pdf_minorversion=1;
    #####:  950:	t2p->pdf_defaultxres=300.0;
    #####:  951:	t2p->pdf_defaultyres=300.0;
    #####:  952:	t2p->pdf_defaultpagewidth=612.0;
    #####:  953:	t2p->pdf_defaultpagelength=792.0;
    #####:  954:	t2p->pdf_xrefcount=3; /* Catalog, Info, Pages */
        -:  955:	
    #####:  956:	return(t2p);
        -:  957:}
        -:  958:
        -:  959:/*
        -:  960: * This function frees a T2P context struct pointer and any allocated data fields of it.
        -:  961: */
        -:  962:
    #####:  963:void t2p_free(T2P* t2p)
        -:  964:{
    #####:  965:	int i = 0;
        -:  966:
    #####:  967:	if (t2p != NULL) {
    #####:  968:		if(t2p->pdf_xrefoffsets != NULL){
    #####:  969:			_TIFFfree( (tdata_t) t2p->pdf_xrefoffsets);
        -:  970:		}
    #####:  971:		if(t2p->tiff_pages != NULL){
    #####:  972:			_TIFFfree( (tdata_t) t2p->tiff_pages);
        -:  973:		}
    #####:  974:		for(i=0;i<t2p->tiff_pagecount;i++){
    #####:  975:			if(t2p->tiff_tiles[i].tiles_tiles != NULL){
    #####:  976:				_TIFFfree( (tdata_t) t2p->tiff_tiles[i].tiles_tiles);
        -:  977:			}
        -:  978:		}
    #####:  979:		if(t2p->tiff_tiles != NULL){
    #####:  980:			_TIFFfree( (tdata_t) t2p->tiff_tiles);
        -:  981:		}
    #####:  982:		if(t2p->pdf_palette != NULL){
    #####:  983:			_TIFFfree( (tdata_t) t2p->pdf_palette);
        -:  984:		}
        -:  985:#ifdef OJPEG_SUPPORT
    #####:  986:		if(t2p->pdf_ojpegdata != NULL){
    #####:  987:			_TIFFfree( (tdata_t) t2p->pdf_ojpegdata);
        -:  988:		}
        -:  989:#endif
    #####:  990:		_TIFFfree( (tdata_t) t2p );
        -:  991:	}
        -:  992:
    #####:  993:	return;
        -:  994:}
        -:  995:
        -:  996:/*
        -:  997:	This function validates the values of a T2P context struct pointer
        -:  998:        before calling t2p_write_pdf with it.
        -:  999:*/
        -: 1000:
    #####: 1001:void t2p_validate(T2P* t2p){
        -: 1002:
        -: 1003:#ifdef JPEG_SUPPORT
    #####: 1004:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1005:		if(t2p->pdf_defaultcompressionquality>100 ||
    #####: 1006:			t2p->pdf_defaultcompressionquality<1){
    #####: 1007:			t2p->pdf_defaultcompressionquality=0;
        -: 1008:		}
        -: 1009:	}
        -: 1010:#endif
        -: 1011:#ifdef ZIP_SUPPORT
        -: 1012:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_ZIP){
        -: 1013: 		uint16 m=t2p->pdf_defaultcompressionquality%100;
        -: 1014: 		if(t2p->pdf_defaultcompressionquality/100 > 9 ||
        -: 1015: 			(m>1 && m<10) || m>15){
        -: 1016: 			t2p->pdf_defaultcompressionquality=0;
        -: 1017:		}
        -: 1018:		if(t2p->pdf_defaultcompressionquality%100 !=0){
        -: 1019: 			t2p->pdf_defaultcompressionquality/=100;
        -: 1020: 			t2p->pdf_defaultcompressionquality*=100;
        -: 1021:			TIFFError(
        -: 1022:				TIFF2PDF_MODULE, 
        -: 1023:				"PNG Group predictor differencing not implemented, assuming compression quality %u", 
        -: 1024:				t2p->pdf_defaultcompressionquality);
        -: 1025:		}
        -: 1026:		t2p->pdf_defaultcompressionquality%=100;
        -: 1027:		if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}
        -: 1028:	}
        -: 1029:#endif
        -: 1030:	(void)0;
        -: 1031:
    #####: 1032:	return;
        -: 1033:}
        -: 1034:
        -: 1035:
        -: 1036:/*
        -: 1037:	This function scans the input TIFF file for pages.  It attempts
        -: 1038:        to determine which IFD's of the TIFF file contain image document
        -: 1039:        pages.  For each, it gathers some information that has to do
        -: 1040:        with the output of the PDF document as a whole.  
        -: 1041:*/
        -: 1042:
    #####: 1043:void t2p_read_tiff_init(T2P* t2p, TIFF* input){
        -: 1044:
    #####: 1045:	tdir_t directorycount=0;
    #####: 1046:	tdir_t i=0;
    #####: 1047:	uint16 pagen=0;
    #####: 1048:	uint16 paged=0;
    #####: 1049:	uint16 xuint16=0;
        -: 1050:
    #####: 1051:	directorycount=TIFFNumberOfDirectories(input);
    #####: 1052:	t2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_PAGE)));
    #####: 1053:	if(t2p->tiff_pages==NULL){
    #####: 1054:		TIFFError(
        -: 1055:			TIFF2PDF_MODULE, 
        -: 1056:			"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for tiff_pages array, %s", 
    #####: 1057:			(TIFF_SIZE_T) directorycount * sizeof(T2P_PAGE), 
        -: 1058:			TIFFFileName(input));
    #####: 1059:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1060:		return;
        -: 1061:	}
    #####: 1062:	_TIFFmemset( t2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));
    #####: 1063:	t2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_TILES)));
    #####: 1064:	if(t2p->tiff_tiles==NULL){
    #####: 1065:		TIFFError(
        -: 1066:			TIFF2PDF_MODULE, 
        -: 1067:			"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for tiff_tiles array, %s", 
    #####: 1068:			(TIFF_SIZE_T) directorycount * sizeof(T2P_TILES), 
        -: 1069:			TIFFFileName(input));
    #####: 1070:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1071:		return;
        -: 1072:	}
    #####: 1073:	_TIFFmemset( t2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));
    #####: 1074:	for(i=0;i<directorycount;i++){
    #####: 1075:		uint32 subfiletype = 0;
        -: 1076:		
    #####: 1077:		if(!TIFFSetDirectory(input, i)){
    #####: 1078:			TIFFError(
        -: 1079:				TIFF2PDF_MODULE, 
        -: 1080:				"Can't set directory %u of input file %s", 
        -: 1081:				i,
        -: 1082:				TIFFFileName(input));
    #####: 1083:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1084:			return;
        -: 1085:		}
    #####: 1086:		if(TIFFGetField(input, TIFFTAG_PAGENUMBER, &pagen, &paged)){
    #####: 1087:			if((pagen>paged) && (paged != 0)){
    #####: 1088:				t2p->tiff_pages[t2p->tiff_pagecount].page_number = 
        -: 1089:					paged;
        -: 1090:			} else {
    #####: 1091:				t2p->tiff_pages[t2p->tiff_pagecount].page_number = 
        -: 1092:					pagen;
        -: 1093:			}
    #####: 1094:			goto ispage2;
        -: 1095:		}
    #####: 1096:		if(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &subfiletype)){
    #####: 1097:			if ( ((subfiletype & FILETYPE_PAGE) != 0)
    #####: 1098:                             || (subfiletype == 0)){
    #####: 1099:				goto ispage;
        -: 1100:			} else {
    #####: 1101:				goto isnotpage;
        -: 1102:			}
        -: 1103:		}
    #####: 1104:		if(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &subfiletype)){
    #####: 1105:			if ((subfiletype == OFILETYPE_IMAGE) 
    #####: 1106:				|| (subfiletype == OFILETYPE_PAGE)
    #####: 1107:				|| (subfiletype == 0) ){
    #####: 1108:				goto ispage;
        -: 1109:			} else {
    #####: 1110:				goto isnotpage;
        -: 1111:			}
        -: 1112:		}
    #####: 1113:		ispage:
    #####: 1114:		t2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount;
    #####: 1115:		ispage2:
    #####: 1116:		t2p->tiff_pages[t2p->tiff_pagecount].page_directory=i;
    #####: 1117:		if(TIFFIsTiled(input)){
    #####: 1118:			t2p->tiff_pages[t2p->tiff_pagecount].page_tilecount = 
    #####: 1119:				TIFFNumberOfTiles(input);
        -: 1120:		}
    #####: 1121:		t2p->tiff_pagecount++;
    #####: 1122:		isnotpage:
        -: 1123:		(void)0;
        -: 1124:	}
        -: 1125:	
    #####: 1126:	qsort((void*) t2p->tiff_pages, t2p->tiff_pagecount,
        -: 1127:              sizeof(T2P_PAGE), t2p_cmp_t2p_page);
        -: 1128:
    #####: 1129:	for(i=0;i<t2p->tiff_pagecount;i++){
    #####: 1130:		t2p->pdf_xrefcount += 5;
    #####: 1131:		TIFFSetDirectory(input, t2p->tiff_pages[i].page_directory );
    #####: 1132:		if((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &xuint16)
    #####: 1133:                    && (xuint16==PHOTOMETRIC_PALETTE))
    #####: 1134:		   || TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)) {
    #####: 1135:			t2p->tiff_pages[i].page_extra++;
    #####: 1136:			t2p->pdf_xrefcount++;
        -: 1137:		}
        -: 1138:#ifdef ZIP_SUPPORT
        -: 1139:		if (TIFFGetField(input, TIFFTAG_COMPRESSION, &xuint16)) {
        -: 1140:                        if( (xuint16== COMPRESSION_DEFLATE ||
        -: 1141:                             xuint16== COMPRESSION_ADOBE_DEFLATE) && 
        -: 1142:                            ((t2p->tiff_pages[i].page_tilecount != 0) 
        -: 1143:                             || TIFFNumberOfStrips(input)==1) &&
        -: 1144:                            (t2p->pdf_nopassthrough==0)	){
        -: 1145:                                if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}
        -: 1146:                        }
        -: 1147:                }
        -: 1148:#endif
    #####: 1149:		if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,
        -: 1150:                                 &(t2p->tiff_transferfunction[0]),
        -: 1151:                                 &(t2p->tiff_transferfunction[1]),
        -: 1152:                                 &(t2p->tiff_transferfunction[2]))) {
    #####: 1153:			if((t2p->tiff_transferfunction[1] != (float*) NULL) &&
    #####: 1154:                           (t2p->tiff_transferfunction[2] != (float*) NULL) &&
    #####: 1155:                           (t2p->tiff_transferfunction[1] !=
    #####: 1156:                            t2p->tiff_transferfunction[0])) {
    #####: 1157:				t2p->tiff_transferfunctioncount = 3;
    #####: 1158:				t2p->tiff_pages[i].page_extra += 4;
    #####: 1159:				t2p->pdf_xrefcount += 4;
        -: 1160:			} else {
    #####: 1161:				t2p->tiff_transferfunctioncount = 1;
    #####: 1162:				t2p->tiff_pages[i].page_extra += 2;
    #####: 1163:				t2p->pdf_xrefcount += 2;
        -: 1164:			}
    #####: 1165:			if(t2p->pdf_minorversion < 2)
    #####: 1166:				t2p->pdf_minorversion = 2;
        -: 1167:                } else {
    #####: 1168:			t2p->tiff_transferfunctioncount=0;
        -: 1169:		}
    #####: 1170:		if( TIFFGetField(
        -: 1171:			input, 
        -: 1172:			TIFFTAG_ICCPROFILE, 
        -: 1173:			&(t2p->tiff_iccprofilelength), 
        -: 1174:			&(t2p->tiff_iccprofile)) != 0){
    #####: 1175:			t2p->tiff_pages[i].page_extra++;
    #####: 1176:			t2p->pdf_xrefcount++;
    #####: 1177:			if(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;}
        -: 1178:		}
    #####: 1179:		t2p->tiff_tiles[i].tiles_tilecount=
    #####: 1180:			t2p->tiff_pages[i].page_tilecount;
    #####: 1181:		if( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)
    #####: 1182:			&& (xuint16 == PLANARCONFIG_SEPARATE ) ){
    #####: 1183:				if( !TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16) )
        -: 1184:				{
    #####: 1185:					TIFFError(
        -: 1186:                        TIFF2PDF_MODULE, 
        -: 1187:                        "Missing SamplesPerPixel, %s", 
        -: 1188:                        TIFFFileName(input));
    #####: 1189:                    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1190:                    return;
        -: 1191:				}
    #####: 1192:                if( (t2p->tiff_tiles[i].tiles_tilecount % xuint16) != 0 )
        -: 1193:                {
    #####: 1194:                    TIFFError(
        -: 1195:                        TIFF2PDF_MODULE, 
        -: 1196:                        "Invalid tile count, %s", 
        -: 1197:                        TIFFFileName(input));
    #####: 1198:                    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1199:                    return;
        -: 1200:                }
    #####: 1201:				t2p->tiff_tiles[i].tiles_tilecount/= xuint16;
        -: 1202:		}
    #####: 1203:		if( t2p->tiff_tiles[i].tiles_tilecount > 0){
    #####: 1204:			t2p->pdf_xrefcount += 
    #####: 1205:				(t2p->tiff_tiles[i].tiles_tilecount -1)*2;
    #####: 1206:			TIFFGetField(input, 
        -: 1207:				TIFFTAG_TILEWIDTH, 
    #####: 1208:				&( t2p->tiff_tiles[i].tiles_tilewidth) );
    #####: 1209:			TIFFGetField(input, 
        -: 1210:				TIFFTAG_TILELENGTH, 
    #####: 1211:				&( t2p->tiff_tiles[i].tiles_tilelength) );
    #####: 1212:			t2p->tiff_tiles[i].tiles_tiles = 
    #####: 1213:			(T2P_TILE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->tiff_tiles[i].tiles_tilecount,
        -: 1214:                                                                 sizeof(T2P_TILE)) );
    #####: 1215:			if( t2p->tiff_tiles[i].tiles_tiles == NULL){
    #####: 1216:				TIFFError(
        -: 1217:					TIFF2PDF_MODULE, 
        -: 1218:					"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for t2p_read_tiff_init, %s", 
    #####: 1219:					(TIFF_SIZE_T) t2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE), 
        -: 1220:					TIFFFileName(input));
    #####: 1221:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1222:				return;
        -: 1223:			}
        -: 1224:		}
        -: 1225:	}
        -: 1226:
    #####: 1227:	return;
        -: 1228:}
        -: 1229:
        -: 1230:/*
        -: 1231: * This function is used by qsort to sort a T2P_PAGE* array of page structures
        -: 1232: * by page number. If the page numbers are the same, we fall back to comparing
        -: 1233: * directory numbers to preserve the order of the input file.
        -: 1234: */
        -: 1235:
    #####: 1236:int t2p_cmp_t2p_page(const void* e1, const void* e2){
        -: 1237:
        -: 1238:	int d;
    #####: 1239:	d = (int32)(((T2P_PAGE*)e1)->page_number) - (int32)(((T2P_PAGE*)e2)->page_number);
    #####: 1240:	if(d == 0){
    #####: 1241:		d = (int32)(((T2P_PAGE*)e1)->page_directory) - (int32)(((T2P_PAGE*)e2)->page_directory);
        -: 1242:	}
    #####: 1243:	return d;
        -: 1244:}
        -: 1245:
        -: 1246:/*
        -: 1247:	This function sets the input directory to the directory of a given
        -: 1248:	page and determines information about the image.  It checks
        -: 1249:	the image characteristics to determine if it is possible to convert
        -: 1250:	the image data into a page of PDF output, setting values of the T2P
        -: 1251:	struct for this page.  It determines what color space is used in
        -: 1252:	the output PDF to represent the image.
        -: 1253:	
        -: 1254:	It determines if the image can be converted as raw data without
        -: 1255:	requiring transcoding of the image data.
        -: 1256:*/
        -: 1257:
    #####: 1258:void t2p_read_tiff_data(T2P* t2p, TIFF* input){
        -: 1259:
    #####: 1260:	int i=0;
    #####: 1261:	uint16* r;
    #####: 1262:	uint16* g;
    #####: 1263:	uint16* b;
    #####: 1264:	uint16* a;
    #####: 1265:	uint16 xuint16;
    #####: 1266:	uint16* xuint16p;
    #####: 1267:	float* xfloatp;
        -: 1268:
    #####: 1269:	t2p->pdf_transcode = T2P_TRANSCODE_ENCODE;
    #####: 1270:	t2p->pdf_sample = T2P_SAMPLE_NOTHING;
    #####: 1271:        t2p->pdf_switchdecode = t2p->pdf_colorspace_invert;
        -: 1272:        
        -: 1273:	
    #####: 1274:	TIFFSetDirectory(input, t2p->tiff_pages[t2p->pdf_page].page_directory);
        -: 1275:
    #####: 1276:	TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width));
    #####: 1277:	if(t2p->tiff_width == 0){
    #####: 1278:		TIFFError(
        -: 1279:			TIFF2PDF_MODULE, 
        -: 1280:			"No support for %s with zero width", 
        -: 1281:			TIFFFileName(input)	);
    #####: 1282:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1283:		return;
        -: 1284:	}
        -: 1285:
    #####: 1286:	TIFFGetField(input, TIFFTAG_IMAGELENGTH, &(t2p->tiff_length));
    #####: 1287:	if(t2p->tiff_length == 0){
    #####: 1288:		TIFFError(
        -: 1289:			TIFF2PDF_MODULE, 
        -: 1290:			"No support for %s with zero length", 
        -: 1291:			TIFFFileName(input)	);
    #####: 1292:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1293:		return;
        -: 1294:	}
        -: 1295:
    #####: 1296:        if(TIFFGetField(input, TIFFTAG_COMPRESSION, &(t2p->tiff_compression)) == 0){
    #####: 1297:                TIFFError(
        -: 1298:                        TIFF2PDF_MODULE, 
        -: 1299:                        "No support for %s with no compression tag", 
        -: 1300:                        TIFFFileName(input)     );
    #####: 1301:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1302:                return;
        -: 1303:
        -: 1304:        }
    #####: 1305:        if( TIFFIsCODECConfigured(t2p->tiff_compression) == 0){
    #####: 1306:		TIFFError(
        -: 1307:			TIFF2PDF_MODULE, 
        -: 1308:			"No support for %s with compression type %u:  not configured", 
        -: 1309:			TIFFFileName(input), 
    #####: 1310:			t2p->tiff_compression	
        -: 1311:			);
    #####: 1312:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1313:		return;
        -: 1314:	
        -: 1315:	}
        -: 1316:
    #####: 1317:	TIFFGetFieldDefaulted(input, TIFFTAG_BITSPERSAMPLE, &(t2p->tiff_bitspersample));
    #####: 1318:	switch(t2p->tiff_bitspersample){
    #####: 1319:		case 1:
        -: 1320:		case 2:
        -: 1321:		case 4:
        -: 1322:		case 8:
    #####: 1323:			break;
    #####: 1324:		case 0:
    #####: 1325:			TIFFWarning(
        -: 1326:				TIFF2PDF_MODULE, 
        -: 1327:				"Image %s has 0 bits per sample, assuming 1",
        -: 1328:				TIFFFileName(input));
    #####: 1329:			t2p->tiff_bitspersample=1;
    #####: 1330:			break;
    #####: 1331:		default:
    #####: 1332:			TIFFError(
        -: 1333:				TIFF2PDF_MODULE, 
        -: 1334:				"No support for %s with %u bits per sample",
        -: 1335:				TIFFFileName(input),
    #####: 1336:				t2p->tiff_bitspersample);
    #####: 1337:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1338:			return;
        -: 1339:	}
        -: 1340:
    #####: 1341:	TIFFGetFieldDefaulted(input, TIFFTAG_SAMPLESPERPIXEL, &(t2p->tiff_samplesperpixel));
    #####: 1342:	if(t2p->tiff_samplesperpixel>4){
    #####: 1343:		TIFFError(
        -: 1344:			TIFF2PDF_MODULE, 
        -: 1345:			"No support for %s with %u samples per pixel",
        -: 1346:			TIFFFileName(input),
    #####: 1347:			t2p->tiff_samplesperpixel);
    #####: 1348:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1349:		return;
        -: 1350:	}
    #####: 1351:	if(t2p->tiff_samplesperpixel==0){
    #####: 1352:		TIFFWarning(
        -: 1353:			TIFF2PDF_MODULE, 
        -: 1354:			"Image %s has 0 samples per pixel, assuming 1",
        -: 1355:			TIFFFileName(input));
    #####: 1356:		t2p->tiff_samplesperpixel=1;
        -: 1357:	}
        -: 1358:	
    #####: 1359:	if(TIFFGetField(input, TIFFTAG_SAMPLEFORMAT, &xuint16) != 0 ){
    #####: 1360:		switch(xuint16){
    #####: 1361:			case 0:
        -: 1362:			case 1:
        -: 1363:			case 4:
    #####: 1364:				break;
    #####: 1365:			default:
    #####: 1366:				TIFFError(
        -: 1367:					TIFF2PDF_MODULE, 
        -: 1368:					"No support for %s with sample format %u",
        -: 1369:					TIFFFileName(input),
        -: 1370:					xuint16);
    #####: 1371:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1372:				return;
        -: 1373:				break;
        -: 1374:		}
    #####: 1375:	}
        -: 1376:	
    #####: 1377:	TIFFGetFieldDefaulted(input, TIFFTAG_FILLORDER, &(t2p->tiff_fillorder));
        -: 1378:	
    #####: 1379:        if(TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &(t2p->tiff_photometric)) == 0){
    #####: 1380:                TIFFError(
        -: 1381:                        TIFF2PDF_MODULE, 
        -: 1382:                        "No support for %s with no photometric interpretation tag", 
        -: 1383:                        TIFFFileName(input)     );
    #####: 1384:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1385:                return;
        -: 1386:
        -: 1387:        }
        -: 1388:        
    #####: 1389:	switch(t2p->tiff_photometric){
    #####: 1390:		case PHOTOMETRIC_MINISWHITE:
        -: 1391:		case PHOTOMETRIC_MINISBLACK: 
    #####: 1392:			if (t2p->tiff_bitspersample==1){
    #####: 1393:				t2p->pdf_colorspace=T2P_CS_BILEVEL;
    #####: 1394:				if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){
    #####: 1395:					t2p->pdf_switchdecode ^= 1;
        -: 1396:				}
        -: 1397:			} else {
    #####: 1398:				t2p->pdf_colorspace=T2P_CS_GRAY;
    #####: 1399:				if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){
    #####: 1400:					t2p->pdf_switchdecode ^= 1;
        -: 1401:				} 
        -: 1402:			}
    #####: 1403:			break;
    #####: 1404:		case PHOTOMETRIC_RGB: 
    #####: 1405:			t2p->pdf_colorspace=T2P_CS_RGB;
    #####: 1406:			if(t2p->tiff_samplesperpixel == 3){
    #####: 1407:				break;
        -: 1408:			}
    #####: 1409:			if(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){
    #####: 1410:				if(xuint16==1)
    #####: 1411:					goto photometric_palette;
        -: 1412:			}
    #####: 1413:			if(t2p->tiff_samplesperpixel > 3) {
    #####: 1414:				if(t2p->tiff_samplesperpixel == 4) {
    #####: 1415:					t2p->pdf_colorspace = T2P_CS_RGB;
    #####: 1416:					if(TIFFGetField(input,
        -: 1417:							TIFFTAG_EXTRASAMPLES,
        -: 1418:							&xuint16, &xuint16p)
    #####: 1419:					   && xuint16 == 1) {
    #####: 1420:						if(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA){
    #####: 1421:							if( t2p->tiff_bitspersample != 8 )
        -: 1422:							{
    #####: 1423:							    TIFFError(
        -: 1424:								    TIFF2PDF_MODULE, 
        -: 1425:								    "No support for BitsPerSample=%d for RGBA",
    #####: 1426:								    t2p->tiff_bitspersample);
    #####: 1427:							    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1428:							    return;
        -: 1429:							}
    #####: 1430:							t2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;
    #####: 1431:							break;
        -: 1432:						}
    #####: 1433:						if(xuint16p[0] == EXTRASAMPLE_UNASSALPHA){
    #####: 1434:							if( t2p->tiff_bitspersample != 8 )
        -: 1435:							{
    #####: 1436:							    TIFFError(
        -: 1437:								    TIFF2PDF_MODULE, 
        -: 1438:								    "No support for BitsPerSample=%d for RGBA",
    #####: 1439:								    t2p->tiff_bitspersample);
    #####: 1440:							    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1441:							    return;
        -: 1442:							}
    #####: 1443:							t2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;
    #####: 1444:							break;
        -: 1445:						}
    #####: 1446:						TIFFWarning(
        -: 1447:							TIFF2PDF_MODULE, 
        -: 1448:							"RGB image %s has 4 samples per pixel, assuming RGBA",
        -: 1449:							TIFFFileName(input));
    #####: 1450:							break;
        -: 1451:					}
    #####: 1452:					t2p->pdf_colorspace=T2P_CS_CMYK;
    #####: 1453:					t2p->pdf_switchdecode ^= 1;
    #####: 1454:					TIFFWarning(
        -: 1455:						TIFF2PDF_MODULE, 
        -: 1456:						"RGB image %s has 4 samples per pixel, assuming inverse CMYK",
        -: 1457:					TIFFFileName(input));
    #####: 1458:					break;
        -: 1459:				} else {
    #####: 1460:					TIFFError(
        -: 1461:						TIFF2PDF_MODULE, 
        -: 1462:						"No support for RGB image %s with %u samples per pixel", 
        -: 1463:						TIFFFileName(input), 
    #####: 1464:						t2p->tiff_samplesperpixel);
    #####: 1465:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1466:					break;
        -: 1467:				}
        -: 1468:			} else {
    #####: 1469:				TIFFError(
        -: 1470:					TIFF2PDF_MODULE, 
        -: 1471:					"No support for RGB image %s with %u samples per pixel", 
        -: 1472:					TIFFFileName(input), 
    #####: 1473:					t2p->tiff_samplesperpixel);
    #####: 1474:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1475:				break;
        -: 1476:			}
        -: 1477:		case PHOTOMETRIC_PALETTE: 
    #####: 1478:			photometric_palette:
    #####: 1479:			if(t2p->tiff_samplesperpixel!=1){
    #####: 1480:				TIFFError(
        -: 1481:					TIFF2PDF_MODULE, 
        -: 1482:					"No support for palettized image %s with not one sample per pixel", 
        -: 1483:					TIFFFileName(input));
    #####: 1484:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1485:				return;
        -: 1486:			}
    #####: 1487:			t2p->pdf_colorspace=T2P_CS_RGB | T2P_CS_PALETTE;
    #####: 1488:			t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;
    #####: 1489:			if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b)){
    #####: 1490:				TIFFError(
        -: 1491:					TIFF2PDF_MODULE, 
        -: 1492:					"Palettized image %s has no color map", 
        -: 1493:					TIFFFileName(input));
    #####: 1494:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1495:				return;
        -: 1496:			} 
    #####: 1497:			if(t2p->pdf_palette != NULL){
    #####: 1498:				_TIFFfree(t2p->pdf_palette);
    #####: 1499:				t2p->pdf_palette=NULL;
        -: 1500:			}
    #####: 1501:			t2p->pdf_palette = (unsigned char*)
    #####: 1502:				_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,3));
    #####: 1503:			if(t2p->pdf_palette==NULL){
    #####: 1504:				TIFFError(
        -: 1505:					TIFF2PDF_MODULE, 
        -: 1506:					"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s", 
    #####: 1507:					t2p->pdf_palettesize, 
        -: 1508:					TIFFFileName(input));
    #####: 1509:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1510:				return;
        -: 1511:			}
    #####: 1512:			for(i=0;i<t2p->pdf_palettesize;i++){
    #####: 1513:				t2p->pdf_palette[(i*3)]  = (unsigned char) (r[i]>>8);
    #####: 1514:				t2p->pdf_palette[(i*3)+1]= (unsigned char) (g[i]>>8);
    #####: 1515:				t2p->pdf_palette[(i*3)+2]= (unsigned char) (b[i]>>8);
        -: 1516:			}
    #####: 1517:			t2p->pdf_palettesize *= 3;
    #####: 1518:			break;
    #####: 1519:		case PHOTOMETRIC_SEPARATED:
    #####: 1520:			if(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){
    #####: 1521:				if(xuint16==1){
    #####: 1522:						goto photometric_palette_cmyk;
        -: 1523:				}
        -: 1524:			}
    #####: 1525:			if( TIFFGetField(input, TIFFTAG_INKSET, &xuint16) ){
    #####: 1526:				if(xuint16 != INKSET_CMYK){
    #####: 1527:					TIFFError(
        -: 1528:						TIFF2PDF_MODULE, 
        -: 1529:						"No support for %s because its inkset is not CMYK",
        -: 1530:						TIFFFileName(input) );
    #####: 1531:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1532:					return;
        -: 1533:				}
        -: 1534:			}
    #####: 1535:			if(t2p->tiff_samplesperpixel==4){
    #####: 1536:				t2p->pdf_colorspace=T2P_CS_CMYK;
        -: 1537:			} else {
    #####: 1538:				TIFFError(
        -: 1539:					TIFF2PDF_MODULE, 
        -: 1540:					"No support for %s because it has %u samples per pixel",
        -: 1541:					TIFFFileName(input), 
    #####: 1542:					t2p->tiff_samplesperpixel);
    #####: 1543:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1544:				return;
        -: 1545:			}
    #####: 1546:			break;
    #####: 1547:			photometric_palette_cmyk:
    #####: 1548:			if(t2p->tiff_samplesperpixel!=1){
    #####: 1549:				TIFFError(
        -: 1550:					TIFF2PDF_MODULE, 
        -: 1551:					"No support for palettized CMYK image %s with not one sample per pixel", 
        -: 1552:					TIFFFileName(input));
    #####: 1553:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1554:				return;
        -: 1555:			}
    #####: 1556:			t2p->pdf_colorspace=T2P_CS_CMYK | T2P_CS_PALETTE;
    #####: 1557:			t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;
    #####: 1558:			if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b, &a)){
    #####: 1559:				TIFFError(
        -: 1560:					TIFF2PDF_MODULE, 
        -: 1561:					"Palettized image %s has no color map", 
        -: 1562:					TIFFFileName(input));
    #####: 1563:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1564:				return;
        -: 1565:			} 
    #####: 1566:			if(t2p->pdf_palette != NULL){
    #####: 1567:				_TIFFfree(t2p->pdf_palette);
    #####: 1568:				t2p->pdf_palette=NULL;
        -: 1569:			}
    #####: 1570:			t2p->pdf_palette = (unsigned char*) 
    #####: 1571:				_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,4));
    #####: 1572:			if(t2p->pdf_palette==NULL){
    #####: 1573:				TIFFError(
        -: 1574:					TIFF2PDF_MODULE, 
        -: 1575:					"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s", 
    #####: 1576:					t2p->pdf_palettesize, 
        -: 1577:					TIFFFileName(input));
    #####: 1578:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1579:				return;
        -: 1580:			}
    #####: 1581:			for(i=0;i<t2p->pdf_palettesize;i++){
    #####: 1582:				t2p->pdf_palette[(i*4)]  = (unsigned char) (r[i]>>8);
    #####: 1583:				t2p->pdf_palette[(i*4)+1]= (unsigned char) (g[i]>>8);
    #####: 1584:				t2p->pdf_palette[(i*4)+2]= (unsigned char) (b[i]>>8);
    #####: 1585:				t2p->pdf_palette[(i*4)+3]= (unsigned char) (a[i]>>8);
        -: 1586:			}
    #####: 1587:			t2p->pdf_palettesize *= 4;
    #####: 1588:			break;
    #####: 1589:		case PHOTOMETRIC_YCBCR:
    #####: 1590:			t2p->pdf_colorspace=T2P_CS_RGB;
    #####: 1591:			if(t2p->tiff_samplesperpixel==1){
    #####: 1592:				t2p->pdf_colorspace=T2P_CS_GRAY;
    #####: 1593:				t2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;
    #####: 1594:				break;
        -: 1595:			}
    #####: 1596:			t2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;
        -: 1597:#ifdef JPEG_SUPPORT
    #####: 1598:			if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1599:				t2p->pdf_sample=T2P_SAMPLE_NOTHING;
        -: 1600:			}
        -: 1601:#endif
    #####: 1602:			break;
    #####: 1603:		case PHOTOMETRIC_CIELAB:
    #####: 1604:            if( t2p->tiff_samplesperpixel != 3){
    #####: 1605:                TIFFError(
        -: 1606:                    TIFF2PDF_MODULE, 
        -: 1607:                    "Unsupported samplesperpixel = %d for CIELAB", 
    #####: 1608:                    t2p->tiff_samplesperpixel);
    #####: 1609:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1610:                return;
        -: 1611:            }
    #####: 1612:            if( t2p->tiff_bitspersample != 8){
    #####: 1613:                TIFFError(
        -: 1614:                    TIFF2PDF_MODULE, 
        -: 1615:                    "Invalid bitspersample = %d for CIELAB", 
    #####: 1616:                    t2p->tiff_bitspersample);
    #####: 1617:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1618:                return;
        -: 1619:            }
    #####: 1620:			t2p->pdf_labrange[0]= -127;
    #####: 1621:			t2p->pdf_labrange[1]= 127;
    #####: 1622:			t2p->pdf_labrange[2]= -127;
    #####: 1623:			t2p->pdf_labrange[3]= 127;
    #####: 1624:			t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;
    #####: 1625:			t2p->pdf_colorspace=T2P_CS_LAB;
    #####: 1626:			break;
    #####: 1627:		case PHOTOMETRIC_ICCLAB:
    #####: 1628:			t2p->pdf_labrange[0]= 0;
    #####: 1629:			t2p->pdf_labrange[1]= 255;
    #####: 1630:			t2p->pdf_labrange[2]= 0;
    #####: 1631:			t2p->pdf_labrange[3]= 255;
    #####: 1632:			t2p->pdf_colorspace=T2P_CS_LAB;
    #####: 1633:			break;
    #####: 1634:		case PHOTOMETRIC_ITULAB:
    #####: 1635:            if( t2p->tiff_samplesperpixel != 3){
    #####: 1636:                TIFFError(
        -: 1637:                    TIFF2PDF_MODULE, 
        -: 1638:                    "Unsupported samplesperpixel = %d for ITULAB", 
    #####: 1639:                    t2p->tiff_samplesperpixel);
    #####: 1640:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1641:                return;
        -: 1642:            }
    #####: 1643:            if( t2p->tiff_bitspersample != 8){
    #####: 1644:                TIFFError(
        -: 1645:                    TIFF2PDF_MODULE, 
        -: 1646:                    "Invalid bitspersample = %d for ITULAB", 
    #####: 1647:                    t2p->tiff_bitspersample);
    #####: 1648:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1649:                return;
        -: 1650:            }
    #####: 1651:			t2p->pdf_labrange[0]=-85;
    #####: 1652:			t2p->pdf_labrange[1]=85;
    #####: 1653:			t2p->pdf_labrange[2]=-75;
    #####: 1654:			t2p->pdf_labrange[3]=124;
    #####: 1655:			t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;
    #####: 1656:			t2p->pdf_colorspace=T2P_CS_LAB;
    #####: 1657:			break;
    #####: 1658:		case PHOTOMETRIC_LOGL:
        -: 1659:		case PHOTOMETRIC_LOGLUV:
    #####: 1660:			TIFFError(
        -: 1661:				TIFF2PDF_MODULE, 
        -: 1662:				"No support for %s with photometric interpretation LogL/LogLuv", 
        -: 1663:				TIFFFileName(input));
    #####: 1664:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1665:			return;
    #####: 1666:		default:
    #####: 1667:			TIFFError(
        -: 1668:				TIFF2PDF_MODULE, 
        -: 1669:				"No support for %s with photometric interpretation %u", 
        -: 1670:				TIFFFileName(input),
    #####: 1671:				t2p->tiff_photometric);
    #####: 1672:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1673:			return;
        -: 1674:	}
        -: 1675:
    #####: 1676:	if(TIFFGetField(input, TIFFTAG_PLANARCONFIG, &(t2p->tiff_planar))){
    #####: 1677:		switch(t2p->tiff_planar){
    #####: 1678:			case 0:
    #####: 1679:				TIFFWarning(
        -: 1680:					TIFF2PDF_MODULE, 
        -: 1681:					"Image %s has planar configuration 0, assuming 1", 
        -: 1682:					TIFFFileName(input));
    #####: 1683:				t2p->tiff_planar=PLANARCONFIG_CONTIG;
    #####: 1684:			case PLANARCONFIG_CONTIG:
    #####: 1685:				break;
    #####: 1686:			case PLANARCONFIG_SEPARATE:
    #####: 1687:				t2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;
    #####: 1688:				if(t2p->tiff_bitspersample!=8){
    #####: 1689:					TIFFError(
        -: 1690:						TIFF2PDF_MODULE, 
        -: 1691:						"No support for %s with separated planar configuration and %u bits per sample", 
        -: 1692:						TIFFFileName(input),
    #####: 1693:						t2p->tiff_bitspersample);
    #####: 1694:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1695:					return;
        -: 1696:				}
    #####: 1697:				break;
    #####: 1698:			default:
    #####: 1699:				TIFFError(
        -: 1700:					TIFF2PDF_MODULE, 
        -: 1701:					"No support for %s with planar configuration %u", 
        -: 1702:					TIFFFileName(input),
    #####: 1703:					t2p->tiff_planar);
    #####: 1704:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1705:				return;
        -: 1706:		}
    #####: 1707:	}
        -: 1708:
    #####: 1709:        TIFFGetFieldDefaulted(input, TIFFTAG_ORIENTATION,
        -: 1710:                              &(t2p->tiff_orientation));
    #####: 1711:        if(t2p->tiff_orientation>8){
    #####: 1712:                TIFFWarning(TIFF2PDF_MODULE,
        -: 1713:                            "Image %s has orientation %u, assuming 0",
    #####: 1714:                            TIFFFileName(input), t2p->tiff_orientation);
    #####: 1715:                t2p->tiff_orientation=0;
        -: 1716:        }
        -: 1717:
    #####: 1718:        if(TIFFGetField(input, TIFFTAG_XRESOLUTION, &(t2p->tiff_xres) ) == 0){
    #####: 1719:                t2p->tiff_xres=0.0;
        -: 1720:        }
    #####: 1721:        if(TIFFGetField(input, TIFFTAG_YRESOLUTION, &(t2p->tiff_yres) ) == 0){
    #####: 1722:                t2p->tiff_yres=0.0;
        -: 1723:        }
    #####: 1724:	TIFFGetFieldDefaulted(input, TIFFTAG_RESOLUTIONUNIT,
        -: 1725:			      &(t2p->tiff_resunit));
    #####: 1726:	if(t2p->tiff_resunit == RESUNIT_CENTIMETER) {
    #####: 1727:		t2p->tiff_xres *= 2.54F;
    #####: 1728:		t2p->tiff_yres *= 2.54F;
    #####: 1729:	} else if (t2p->tiff_resunit != RESUNIT_INCH
    #####: 1730:		   && t2p->pdf_centimeters != 0) {
    #####: 1731:		t2p->tiff_xres *= 2.54F;
    #####: 1732:		t2p->tiff_yres *= 2.54F;
        -: 1733:	}
        -: 1734:
    #####: 1735:	t2p_compose_pdf_page(t2p);
    #####: 1736:        if( t2p->t2p_error == T2P_ERR_ERROR )
    #####: 1737:	    return;
        -: 1738:
    #####: 1739:	t2p->pdf_transcode = T2P_TRANSCODE_ENCODE;
    #####: 1740:	if(t2p->pdf_nopassthrough==0){
        -: 1741:#ifdef CCITT_SUPPORT
    #####: 1742:		if(t2p->tiff_compression==COMPRESSION_CCITTFAX4  
        -: 1743:			){
    #####: 1744:			if(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){
    #####: 1745:				t2p->pdf_transcode = T2P_TRANSCODE_RAW;
    #####: 1746:				t2p->pdf_compression=T2P_COMPRESS_G4;
        -: 1747:			}
        -: 1748:		}
        -: 1749:#endif
        -: 1750:#ifdef ZIP_SUPPORT
        -: 1751:		if(t2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE 
        -: 1752:			|| t2p->tiff_compression==COMPRESSION_DEFLATE){
        -: 1753:			if(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){
        -: 1754:				t2p->pdf_transcode = T2P_TRANSCODE_RAW;
        -: 1755:				t2p->pdf_compression=T2P_COMPRESS_ZIP;
        -: 1756:			}
        -: 1757:		}
        -: 1758:#endif
        -: 1759:#ifdef OJPEG_SUPPORT
    #####: 1760:		if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 1761:			t2p->pdf_transcode = T2P_TRANSCODE_RAW;
    #####: 1762:			t2p->pdf_compression=T2P_COMPRESS_JPEG;
    #####: 1763:			t2p_process_ojpeg_tables(t2p, input);
        -: 1764:		}
        -: 1765:#endif
        -: 1766:#ifdef JPEG_SUPPORT
    #####: 1767:		if(t2p->tiff_compression==COMPRESSION_JPEG){
    #####: 1768:			t2p->pdf_transcode = T2P_TRANSCODE_RAW;
    #####: 1769:			t2p->pdf_compression=T2P_COMPRESS_JPEG;
        -: 1770:		}
        -: 1771:#endif
        -: 1772:		(void)0;
        -: 1773:	}
        -: 1774:
    #####: 1775:	if(t2p->pdf_transcode!=T2P_TRANSCODE_RAW){
    #####: 1776:		t2p->pdf_compression = t2p->pdf_defaultcompression;
        -: 1777:	}
        -: 1778:
        -: 1779:#ifdef JPEG_SUPPORT
    #####: 1780:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1781:		if(t2p->pdf_colorspace & T2P_CS_PALETTE){
    #####: 1782:			t2p->pdf_sample|=T2P_SAMPLE_REALIZE_PALETTE;
    #####: 1783:			t2p->pdf_colorspace ^= T2P_CS_PALETTE;
    #####: 1784:			t2p->tiff_pages[t2p->pdf_page].page_extra--;
        -: 1785:		}
        -: 1786:	}
    #####: 1787:	if(t2p->tiff_compression==COMPRESSION_JPEG){
    #####: 1788:		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 1789:			TIFFError(
        -: 1790:				TIFF2PDF_MODULE, 
        -: 1791:				"No support for %s with JPEG compression and separated planar configuration", 
        -: 1792:				TIFFFileName(input));
    #####: 1793:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 1794:			return;
        -: 1795:		}
        -: 1796:	}
        -: 1797:#endif
        -: 1798:#ifdef OJPEG_SUPPORT
    #####: 1799:	if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 1800:		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 1801:			TIFFError(
        -: 1802:				TIFF2PDF_MODULE, 
        -: 1803:				"No support for %s with OJPEG compression and separated planar configuration", 
        -: 1804:				TIFFFileName(input));
    #####: 1805:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 1806:			return;
        -: 1807:		}
        -: 1808:	}
        -: 1809:#endif
        -: 1810:
    #####: 1811:	if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){
    #####: 1812:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
    #####: 1813:			t2p->tiff_samplesperpixel=4;
    #####: 1814:			t2p->tiff_photometric=PHOTOMETRIC_SEPARATED;
        -: 1815:		} else {
    #####: 1816:			t2p->tiff_samplesperpixel=3;
    #####: 1817:			t2p->tiff_photometric=PHOTOMETRIC_RGB;
        -: 1818:		}
        -: 1819:	}
        -: 1820:
    #####: 1821:	if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,
        -: 1822:			 &(t2p->tiff_transferfunction[0]),
        -: 1823:			 &(t2p->tiff_transferfunction[1]),
        -: 1824:			 &(t2p->tiff_transferfunction[2]))) {
    #####: 1825:		if((t2p->tiff_transferfunction[1] != (float*) NULL) &&
    #####: 1826:                   (t2p->tiff_transferfunction[2] != (float*) NULL) &&
    #####: 1827:                   (t2p->tiff_transferfunction[1] !=
    #####: 1828:                    t2p->tiff_transferfunction[0])) {
    #####: 1829:			t2p->tiff_transferfunctioncount=3;
        -: 1830:		} else {
    #####: 1831:			t2p->tiff_transferfunctioncount=1;
        -: 1832:		}
        -: 1833:	} else {
    #####: 1834:		t2p->tiff_transferfunctioncount=0;
        -: 1835:	}
    #####: 1836:	if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp)!=0){
    #####: 1837:		t2p->tiff_whitechromaticities[0]=xfloatp[0];
    #####: 1838:		t2p->tiff_whitechromaticities[1]=xfloatp[1];
    #####: 1839:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
    #####: 1840:			t2p->pdf_colorspace |= T2P_CS_CALGRAY;
        -: 1841:		}
    #####: 1842:		if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 1843:			t2p->pdf_colorspace |= T2P_CS_CALRGB;
        -: 1844:		}
        -: 1845:	}
    #####: 1846:	if(TIFFGetField(input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0){
    #####: 1847:		t2p->tiff_primarychromaticities[0]=xfloatp[0];
    #####: 1848:		t2p->tiff_primarychromaticities[1]=xfloatp[1];
    #####: 1849:		t2p->tiff_primarychromaticities[2]=xfloatp[2];
    #####: 1850:		t2p->tiff_primarychromaticities[3]=xfloatp[3];
    #####: 1851:		t2p->tiff_primarychromaticities[4]=xfloatp[4];
    #####: 1852:		t2p->tiff_primarychromaticities[5]=xfloatp[5];
    #####: 1853:		if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 1854:			t2p->pdf_colorspace |= T2P_CS_CALRGB;
        -: 1855:		}
        -: 1856:	}
    #####: 1857:	if(t2p->pdf_colorspace & T2P_CS_LAB){
    #####: 1858:		if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp) != 0){
    #####: 1859:			t2p->tiff_whitechromaticities[0]=xfloatp[0];
    #####: 1860:			t2p->tiff_whitechromaticities[1]=xfloatp[1];
        -: 1861:		} else {
    #####: 1862:			t2p->tiff_whitechromaticities[0]=0.3457F; /* 0.3127F; */
    #####: 1863:			t2p->tiff_whitechromaticities[1]=0.3585F; /* 0.3290F; */
        -: 1864:		}
        -: 1865:	}
    #####: 1866:	if(TIFFGetField(input, 
        -: 1867:		TIFFTAG_ICCPROFILE, 
        -: 1868:		&(t2p->tiff_iccprofilelength), 
        -: 1869:		&(t2p->tiff_iccprofile))!=0){
    #####: 1870:		t2p->pdf_colorspace |= T2P_CS_ICCBASED;
        -: 1871:	} else {
    #####: 1872:		t2p->tiff_iccprofilelength=0;
    #####: 1873:		t2p->tiff_iccprofile=NULL;
        -: 1874:	}
        -: 1875:	
        -: 1876:#ifdef CCITT_SUPPORT
    #####: 1877:	if( t2p->tiff_bitspersample==1 &&
    #####: 1878:		t2p->tiff_samplesperpixel==1){
    #####: 1879:		t2p->pdf_compression = T2P_COMPRESS_G4;
        -: 1880:	}
        -: 1881:#endif
        -: 1882:
        -: 1883:
    #####: 1884:	return;
        -: 1885:}
        -: 1886:
        -: 1887:/*
        -: 1888:	This function returns the necessary size of a data buffer to contain the raw or 
        -: 1889:	uncompressed image data from the input TIFF for a page.
        -: 1890:*/
        -: 1891:
    #####: 1892:void t2p_read_tiff_size(T2P* t2p, TIFF* input){
        -: 1893:
    #####: 1894:	uint64* sbc=NULL;
        -: 1895:#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
    #####: 1896:	unsigned char* jpt=NULL;
    #####: 1897:	tstrip_t i=0;
    #####: 1898:	tstrip_t stripcount=0;
        -: 1899:#endif
    #####: 1900:        uint64 k = 0;
        -: 1901:
    #####: 1902:	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
        -: 1903:#ifdef CCITT_SUPPORT
    #####: 1904:		if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
    #####: 1905:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
        -: 1906:            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
        -: 1907:                TIFFError(TIFF2PDF_MODULE, "Integer overflow");
        -: 1908:                t2p->t2p_error = T2P_ERR_ERROR;
        -: 1909:            }
    #####: 1910:			t2p->tiff_datasize=(tmsize_t)sbc[0];
    #####: 1911:			return;
        -: 1912:		}
        -: 1913:#endif
        -: 1914:#ifdef ZIP_SUPPORT
        -: 1915:		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
        -: 1916:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
        -: 1917:            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
        -: 1918:                TIFFError(TIFF2PDF_MODULE, "Integer overflow");
        -: 1919:                t2p->t2p_error = T2P_ERR_ERROR;
        -: 1920:            }
        -: 1921:			t2p->tiff_datasize=(tmsize_t)sbc[0];
        -: 1922:			return;
        -: 1923:		}
        -: 1924:#endif
        -: 1925:#ifdef OJPEG_SUPPORT
    #####: 1926:		if(t2p->tiff_compression == COMPRESSION_OJPEG){
    #####: 1927:			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
    #####: 1928:				TIFFError(TIFF2PDF_MODULE, 
        -: 1929:					"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS",
        -: 1930:					TIFFFileName(input));
    #####: 1931:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1932:				return;
        -: 1933:			}
    #####: 1934:			stripcount=TIFFNumberOfStrips(input);
    #####: 1935:			for(i=0;i<stripcount;i++){
    #####: 1936:				k = checkAdd64(k, sbc[i], t2p);
        -: 1937:			}
    #####: 1938:			if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
    #####: 1939:				if(t2p->tiff_dataoffset != 0){
    #####: 1940:					if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
    #####: 1941:						if((uint64)t2p->tiff_datasize < k) {
    #####: 1942:							TIFFWarning(TIFF2PDF_MODULE, 
        -: 1943:								"Input file %s has short JPEG interchange file byte count", 
        -: 1944:								TIFFFileName(input));
    #####: 1945:							t2p->pdf_ojpegiflength=t2p->tiff_datasize;
    #####: 1946:							k = checkAdd64(k, t2p->tiff_datasize, t2p);
    #####: 1947:							k = checkAdd64(k, 6, t2p);
    #####: 1948:							k = checkAdd64(k, stripcount, t2p);
    #####: 1949:							k = checkAdd64(k, stripcount, t2p);
    #####: 1950:							t2p->tiff_datasize = (tsize_t) k;
    #####: 1951:							if ((uint64) t2p->tiff_datasize != k) {
    #####: 1952:								TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 1953:								t2p->t2p_error = T2P_ERR_ERROR;
        -: 1954:							}
    #####: 1955:							return;
        -: 1956:						}
    #####: 1957:						return;
        -: 1958:					}else {
    #####: 1959:						TIFFError(TIFF2PDF_MODULE, 
        -: 1960:							"Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT",
        -: 1961:							TIFFFileName(input));
    #####: 1962:							t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1963:							return;
        -: 1964:					}
        -: 1965:				}
        -: 1966:			}
    #####: 1967:			k = checkAdd64(k, stripcount, t2p);
    #####: 1968:			k = checkAdd64(k, stripcount, t2p);
    #####: 1969:			k = checkAdd64(k, 2048, t2p);
    #####: 1970:			t2p->tiff_datasize = (tsize_t) k;
    #####: 1971:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 1972:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 1973:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 1974:			}
    #####: 1975:			return;
        -: 1976:		}
        -: 1977:#endif
        -: 1978:#ifdef JPEG_SUPPORT
    #####: 1979:		if(t2p->tiff_compression == COMPRESSION_JPEG) {
    #####: 1980:			uint32 count = 0;
    #####: 1981:			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
    #####: 1982:				if(count > 4){
    #####: 1983:					k += count;
    #####: 1984:					k -= 2; /* don't use EOI of header */
        -: 1985:				}
        -: 1986:			} else {
    #####: 1987:				k = 2; /* SOI for first strip */
        -: 1988:			}
    #####: 1989:			stripcount=TIFFNumberOfStrips(input);
    #####: 1990:			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
    #####: 1991:				TIFFError(TIFF2PDF_MODULE, 
        -: 1992:					"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS",
        -: 1993:					TIFFFileName(input));
    #####: 1994:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1995:				return;
        -: 1996:			}
    #####: 1997:			for(i=0;i<stripcount;i++){
    #####: 1998:				k = checkAdd64(k, sbc[i], t2p);
    #####: 1999:				k -=2; /* don't use EOI of strip */
    #####: 2000:				k +=2; /* add space for restart marker */
        -: 2001:			}
    #####: 2002:			k = checkAdd64(k, 2, t2p); /* use EOI of last strip */
    #####: 2003:			k = checkAdd64(k, 6, t2p); /* for DRI marker of first strip */
    #####: 2004:			t2p->tiff_datasize = (tsize_t) k;
    #####: 2005:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 2006:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2007:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2008:			}
    #####: 2009:			return;
        -: 2010:		}
        -: 2011:#endif
        -: 2012:		(void) 0;
        -: 2013:	}
    #####: 2014:	k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
    #####: 2015:	if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 2016:		k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
        -: 2017:	}
    #####: 2018:	if (k == 0) {
        -: 2019:		/* Assume we had overflow inside TIFFScanlineSize */
    #####: 2020:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2021:	}
        -: 2022:
    #####: 2023:	t2p->tiff_datasize = (tsize_t) k;
    #####: 2024:	if ((uint64) t2p->tiff_datasize != k) {
    #####: 2025:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2026:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2027:	}
        -: 2028:
    #####: 2029:	return;
        -: 2030:}
        -: 2031:
        -: 2032:/*
        -: 2033:	This function returns the necessary size of a data buffer to contain the raw or 
        -: 2034:	uncompressed image data from the input TIFF for a tile of a page.
        -: 2035:*/
        -: 2036:
    #####: 2037:void t2p_read_tiff_size_tile(T2P* t2p, TIFF* input, ttile_t tile){
        -: 2038:
    #####: 2039:	uint64* tbc = NULL;
    #####: 2040:	uint16 edge=0;
        -: 2041:#ifdef JPEG_SUPPORT
    #####: 2042:	unsigned char* jpt;
        -: 2043:#endif
        -: 2044:        uint64 k;
        -: 2045:
    #####: 2046:	edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
    #####: 2047:	edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
        -: 2048:	
    #####: 2049:	if(t2p->pdf_transcode==T2P_TRANSCODE_RAW){
    #####: 2050:		if(edge
        -: 2051:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
    #####: 2052:		&& !(t2p->pdf_compression==T2P_COMPRESS_JPEG)
        -: 2053:#endif
        -: 2054:		){
    #####: 2055:			t2p->tiff_datasize=TIFFTileSize(input);
    #####: 2056:			if (t2p->tiff_datasize == 0) {
        -: 2057:				/* Assume we had overflow inside TIFFTileSize */
    #####: 2058:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2059:			}
    #####: 2060:			return;
        -: 2061:		} else {
    #####: 2062:			TIFFGetField(input, TIFFTAG_TILEBYTECOUNTS, &tbc);
    #####: 2063:			k=tbc[tile];
        -: 2064:#ifdef OJPEG_SUPPORT
    #####: 2065:			if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 2066:			  	k = checkAdd64(k, 2048, t2p);
        -: 2067:			}
        -: 2068:#endif
        -: 2069:#ifdef JPEG_SUPPORT
    #####: 2070:			if(t2p->tiff_compression==COMPRESSION_JPEG) {
    #####: 2071:				uint32 count = 0;
    #####: 2072:				if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt)!=0){
    #####: 2073:					if(count > 4){
    #####: 2074:						k = checkAdd64(k, count, t2p);
    #####: 2075:						k -= 2; /* don't use EOI of header or SOI of tile */
        -: 2076:					}
        -: 2077:				}
        -: 2078:			}
        -: 2079:#endif
    #####: 2080:			t2p->tiff_datasize = (tsize_t) k;
    #####: 2081:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 2082:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2083:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2084:			}
    #####: 2085:			return;
        -: 2086:		}
        -: 2087:	}
    #####: 2088:	k = TIFFTileSize(input);
    #####: 2089:	if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 2090:		k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
        -: 2091:	}
    #####: 2092:	if (k == 0) {
        -: 2093:		/* Assume we had overflow inside TIFFTileSize */
    #####: 2094:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2095:	}
        -: 2096:
    #####: 2097:	t2p->tiff_datasize = (tsize_t) k;
    #####: 2098:	if ((uint64) t2p->tiff_datasize != k) {
    #####: 2099:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2100:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2101:	}
        -: 2102:
    #####: 2103:	return;
        -: 2104:}
        -: 2105:
        -: 2106:/*
        -: 2107: * This functions returns a non-zero value when the tile is on the right edge
        -: 2108: * and does not have full imaged tile width.
        -: 2109: */
        -: 2110:
    #####: 2111:int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){
        -: 2112:
    #####: 2113:	if( ((tile+1) % tiles.tiles_tilecountx == 0) 
    #####: 2114:		&& (tiles.tiles_edgetilewidth != 0) ){
    #####: 2115:		return(1);
        -: 2116:	} else {
    #####: 2117:		return(0);
        -: 2118:	}
        -: 2119:}
        -: 2120:
        -: 2121:/*
        -: 2122: * This functions returns a non-zero value when the tile is on the bottom edge
        -: 2123: * and does not have full imaged tile length.
        -: 2124: */
        -: 2125:
    #####: 2126:int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){
        -: 2127:
    #####: 2128:	if( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) )
    #####: 2129:		&& (tiles.tiles_edgetilelength != 0) ){
    #####: 2130:		return(1);
        -: 2131:	} else {
    #####: 2132:		return(0);
        -: 2133:	}
        -: 2134:}
        -: 2135:
        -: 2136:/*
        -: 2137: * This function returns a non-zero value when the tile is a right edge tile
        -: 2138: * or a bottom edge tile.
        -: 2139: */
        -: 2140:
    #####: 2141:int t2p_tile_is_edge(T2P_TILES tiles, ttile_t tile){
        -: 2142:
    #####: 2143:	return(t2p_tile_is_right_edge(tiles, tile) | t2p_tile_is_bottom_edge(tiles, tile) );
        -: 2144:}
        -: 2145:
        -: 2146:/*
        -: 2147:	This function returns a non-zero value when the tile is a right edge tile and a bottom 
        -: 2148:	edge tile.
        -: 2149:*/
        -: 2150:
    #####: 2151:int t2p_tile_is_corner_edge(T2P_TILES tiles, ttile_t tile){
        -: 2152:
    #####: 2153:	return(t2p_tile_is_right_edge(tiles, tile) & t2p_tile_is_bottom_edge(tiles, tile) );
        -: 2154:}
        -: 2155:
        -: 2156:
        -: 2157:/*
        -: 2158:	This function reads the raster image data from the input TIFF for an image and writes 
        -: 2159:	the data to the output PDF XObject image dictionary stream.  It returns the amount written 
        -: 2160:	or zero on error.
        -: 2161:*/
        -: 2162:
    #####: 2163:tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){
        -: 2164:
    #####: 2165:	tsize_t written=0;
    #####: 2166:	unsigned char* buffer=NULL;
    #####: 2167:	unsigned char* samplebuffer=NULL;
    #####: 2168:	tsize_t bufferoffset=0;
    #####: 2169:	tsize_t samplebufferoffset=0;
    #####: 2170:	tsize_t read=0;
    #####: 2171:	tstrip_t i=0;
    #####: 2172:	tstrip_t j=0;
    #####: 2173:	tstrip_t stripcount=0;
    #####: 2174:	tsize_t stripsize=0;
    #####: 2175:	tsize_t sepstripcount=0;
    #####: 2176:	tsize_t sepstripsize=0;
        -: 2177:#ifdef OJPEG_SUPPORT
    #####: 2178:	toff_t inputoffset=0;
    #####: 2179:	uint16 h_samp=1;
    #####: 2180:	uint16 v_samp=1;
    #####: 2181:	uint16 ri=1;
    #####: 2182:	uint32 rows=0;
        -: 2183:#endif /* ifdef OJPEG_SUPPORT */
        -: 2184:#ifdef JPEG_SUPPORT
    #####: 2185:	unsigned char* jpt;
    #####: 2186:	float* xfloatp;
    #####: 2187:	uint64* sbc;
        -: 2188:	unsigned char* stripbuffer;
    #####: 2189:	tsize_t striplength=0;
    #####: 2190:	uint32 max_striplength=0;
        -: 2191:#endif /* ifdef JPEG_SUPPORT */
        -: 2192:
        -: 2193:	/* Fail if prior error (in particular, can't trust tiff_datasize) */
    #####: 2194:	if (t2p->t2p_error != T2P_ERR_OK)
    #####: 2195:		return(0);
        -: 2196:
    #####: 2197:	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
        -: 2198:#ifdef CCITT_SUPPORT
    #####: 2199:		if(t2p->pdf_compression == T2P_COMPRESS_G4){
        -: 2200:			buffer = (unsigned char*)
    #####: 2201:				_TIFFmalloc(t2p->tiff_datasize);
    #####: 2202:			if (buffer == NULL) {
    #####: 2203:				TIFFError(TIFF2PDF_MODULE, 
        -: 2204:                                          "Can't allocate %lu bytes of memory for "
        -: 2205:                                          "t2p_readwrite_pdf_image, %s", 
    #####: 2206:					(unsigned long) t2p->tiff_datasize, 
        -: 2207:					TIFFFileName(input));
    #####: 2208:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2209:				return(0);
        -: 2210:			}
    #####: 2211:			TIFFReadRawStrip(input, 0, (tdata_t) buffer,
        -: 2212:					 t2p->tiff_datasize);
    #####: 2213:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
        -: 2214:					/*
        -: 2215:					 * make sure is lsb-to-msb
        -: 2216:					 * bit-endianness fill order
        -: 2217:					 */
    #####: 2218:					TIFFReverseBits(buffer,
        -: 2219:							t2p->tiff_datasize);
        -: 2220:			}
    #####: 2221:			t2pWriteFile(output, (tdata_t) buffer,
        -: 2222:				      t2p->tiff_datasize);
    #####: 2223:			_TIFFfree(buffer);
    #####: 2224:			return(t2p->tiff_datasize);
        -: 2225:		}
        -: 2226:#endif /* ifdef CCITT_SUPPORT */
        -: 2227:#ifdef ZIP_SUPPORT
        -: 2228:		if (t2p->pdf_compression == T2P_COMPRESS_ZIP) {
        -: 2229:			buffer = (unsigned char*)
        -: 2230:				_TIFFmalloc(t2p->tiff_datasize);
        -: 2231:			if(buffer == NULL){
        -: 2232:				TIFFError(TIFF2PDF_MODULE, 
        -: 2233:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
        -: 2234:					(unsigned long) t2p->tiff_datasize, 
        -: 2235:					TIFFFileName(input));
        -: 2236:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2237:				return(0);
        -: 2238:			}
        -: 2239:                        memset(buffer, 0, t2p->tiff_datasize);
        -: 2240:			TIFFReadRawStrip(input, 0, (tdata_t) buffer,
        -: 2241:					 t2p->tiff_datasize);
        -: 2242:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB) {
        -: 2243:					TIFFReverseBits(buffer,
        -: 2244:							t2p->tiff_datasize);
        -: 2245:			}
        -: 2246:			t2pWriteFile(output, (tdata_t) buffer,
        -: 2247:				      t2p->tiff_datasize);
        -: 2248:			_TIFFfree(buffer);
        -: 2249:			return(t2p->tiff_datasize);
        -: 2250:		}
        -: 2251:#endif /* ifdef ZIP_SUPPORT */
        -: 2252:#ifdef OJPEG_SUPPORT
    #####: 2253:		if(t2p->tiff_compression == COMPRESSION_OJPEG) {
        -: 2254:
    #####: 2255:			if(t2p->tiff_dataoffset != 0) {
        -: 2256:				buffer = (unsigned char*)
    #####: 2257:					_TIFFmalloc(t2p->tiff_datasize);
    #####: 2258:				if(buffer == NULL) {
    #####: 2259:					TIFFError(TIFF2PDF_MODULE, 
        -: 2260:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2261:						(unsigned long) t2p->tiff_datasize, 
        -: 2262:						TIFFFileName(input));
    #####: 2263:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2264:					return(0);
        -: 2265:				}
    #####: 2266:                                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2267:				if(t2p->pdf_ojpegiflength==0){
    #####: 2268:					inputoffset=t2pSeekFile(input, 0,
        -: 2269:								 SEEK_CUR);
    #####: 2270:					t2pSeekFile(input,
        -: 2271:						     t2p->tiff_dataoffset,
        -: 2272:						     SEEK_SET);
    #####: 2273:					t2pReadFile(input, (tdata_t) buffer,
        -: 2274:						     t2p->tiff_datasize);
    #####: 2275:					t2pSeekFile(input, inputoffset,
        -: 2276:						     SEEK_SET);
    #####: 2277:					t2pWriteFile(output, (tdata_t) buffer,
        -: 2278:						      t2p->tiff_datasize);
    #####: 2279:					_TIFFfree(buffer);
    #####: 2280:					return(t2p->tiff_datasize);
        -: 2281:				} else {
    #####: 2282:					inputoffset=t2pSeekFile(input, 0,
        -: 2283:								 SEEK_CUR);
    #####: 2284:					t2pSeekFile(input,
        -: 2285:						     t2p->tiff_dataoffset,
        -: 2286:						     SEEK_SET);
    #####: 2287:					bufferoffset = t2pReadFile(input,
        -: 2288:						(tdata_t) buffer,
    #####: 2289:						t2p->pdf_ojpegiflength);
    #####: 2290:					t2p->pdf_ojpegiflength = 0;
    #####: 2291:					t2pSeekFile(input, inputoffset,
        -: 2292:						     SEEK_SET);
    #####: 2293:					TIFFGetField(input,
        -: 2294:						     TIFFTAG_YCBCRSUBSAMPLING,
        -: 2295:						     &h_samp, &v_samp);
    #####: 2296:					buffer[bufferoffset++]= 0xff;
    #####: 2297:					buffer[bufferoffset++]= 0xdd;
    #####: 2298:					buffer[bufferoffset++]= 0x00;
    #####: 2299:					buffer[bufferoffset++]= 0x04;
    #####: 2300:					h_samp*=8;
    #####: 2301:					v_samp*=8;
    #####: 2302:					ri=(t2p->tiff_width+h_samp-1) / h_samp;
    #####: 2303:					TIFFGetField(input,
        -: 2304:						     TIFFTAG_ROWSPERSTRIP,
        -: 2305:						     &rows);
    #####: 2306:					ri*=(rows+v_samp-1)/v_samp;
    #####: 2307:					buffer[bufferoffset++]= (ri>>8) & 0xff;
    #####: 2308:					buffer[bufferoffset++]= ri & 0xff;
    #####: 2309:					stripcount=TIFFNumberOfStrips(input);
    #####: 2310:					for(i=0;i<stripcount;i++){
    #####: 2311:						if(i != 0 ){ 
    #####: 2312:							buffer[bufferoffset++]=0xff;
    #####: 2313:							buffer[bufferoffset++]=(0xd0 | ((i-1)%8));
        -: 2314:						}
    #####: 2315:						bufferoffset+=TIFFReadRawStrip(input, 
        -: 2316:							i, 
    #####: 2317:							(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2318:							-1);
        -: 2319:					}
    #####: 2320:					t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2321:					_TIFFfree(buffer);
    #####: 2322:					return(bufferoffset);
        -: 2323:				}
        -: 2324:			} else {
    #####: 2325:				if(! t2p->pdf_ojpegdata){
    #####: 2326:					TIFFError(TIFF2PDF_MODULE, 
        -: 2327:				"No support for OJPEG image %s with bad tables", 
        -: 2328:						TIFFFileName(input));
    #####: 2329:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2330:					return(0);
        -: 2331:				}
        -: 2332:				buffer = (unsigned char*)
    #####: 2333:					_TIFFmalloc(t2p->tiff_datasize);
    #####: 2334:				if(buffer==NULL){
    #####: 2335:					TIFFError(TIFF2PDF_MODULE, 
        -: 2336:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2337:						(unsigned long) t2p->tiff_datasize, 
        -: 2338:						TIFFFileName(input));
    #####: 2339:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2340:					return(0);
        -: 2341:				}
    #####: 2342:                                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2343:				_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);
    #####: 2344:				bufferoffset=t2p->pdf_ojpegdatalength;
    #####: 2345:				stripcount=TIFFNumberOfStrips(input);
    #####: 2346:				for(i=0;i<stripcount;i++){
    #####: 2347:					if(i != 0){
    #####: 2348:						buffer[bufferoffset++]=0xff;
    #####: 2349:						buffer[bufferoffset++]=(0xd0 | ((i-1)%8));
        -: 2350:					}
    #####: 2351:					bufferoffset+=TIFFReadRawStrip(input, 
        -: 2352:						i, 
    #####: 2353:						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2354:						-1);
        -: 2355:				}
    #####: 2356:				if( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){
    #####: 2357:						buffer[bufferoffset++]=0xff;
    #####: 2358:						buffer[bufferoffset++]=0xd9;
        -: 2359:				}
    #####: 2360:				t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2361:				_TIFFfree(buffer);
    #####: 2362:				return(bufferoffset);
        -: 2363:#if 0
        -: 2364:                                /*
        -: 2365:                                  This hunk of code removed code is clearly
        -: 2366:                                  mis-placed and we are not sure where it
        -: 2367:                                  should be (if anywhere)
        -: 2368:                                */
        -: 2369:				TIFFError(TIFF2PDF_MODULE, 
        -: 2370:	"No support for OJPEG image %s with no JPEG File Interchange offset", 
        -: 2371:					TIFFFileName(input));
        -: 2372:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2373:				return(0);
        -: 2374:#endif
        -: 2375:			}
        -: 2376:		}
        -: 2377:#endif /* ifdef OJPEG_SUPPORT */
        -: 2378:#ifdef JPEG_SUPPORT
    #####: 2379:		if(t2p->tiff_compression == COMPRESSION_JPEG) {
    #####: 2380:			uint32 count = 0;
        -: 2381:			buffer = (unsigned char*)
    #####: 2382:				_TIFFmalloc(t2p->tiff_datasize);
    #####: 2383:			if(buffer==NULL){
    #####: 2384:				TIFFError(TIFF2PDF_MODULE, 
        -: 2385:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2386:					(unsigned long) t2p->tiff_datasize, 
        -: 2387:					TIFFFileName(input));
    #####: 2388:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2389:				return(0);
        -: 2390:			}
    #####: 2391:                        memset(buffer, 0, t2p->tiff_datasize);
    #####: 2392:			if (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
    #####: 2393:				if(count > 4) {
    #####: 2394:					_TIFFmemcpy(buffer, jpt, count);
    #####: 2395:					bufferoffset += count - 2;
        -: 2396:				}
        -: 2397:			}
    #####: 2398:			stripcount=TIFFNumberOfStrips(input);
    #####: 2399:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
    #####: 2400:			for(i=0;i<stripcount;i++){
    #####: 2401:				if(sbc[i]>max_striplength) max_striplength=sbc[i];
        -: 2402:			}
        -: 2403:			stripbuffer = (unsigned char*)
    #####: 2404:				_TIFFmalloc(max_striplength);
    #####: 2405:			if(stripbuffer==NULL){
    #####: 2406:				TIFFError(TIFF2PDF_MODULE, 
        -: 2407:	"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s", 
        -: 2408:					max_striplength, 
        -: 2409:					TIFFFileName(input));
    #####: 2410:				_TIFFfree(buffer);
    #####: 2411:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2412:				return(0);
        -: 2413:			}
    #####: 2414:			for(i=0;i<stripcount;i++){
    #####: 2415:				striplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1);
    #####: 2416:				if(!t2p_process_jpeg_strip(
        -: 2417:					stripbuffer, 
        -: 2418:					&striplength, 
        -: 2419:					buffer,
        -: 2420:                    t2p->tiff_datasize,
        -: 2421:					&bufferoffset, 
        -: 2422:					i, 
        -: 2423:					t2p->tiff_length)){
    #####: 2424:						TIFFError(TIFF2PDF_MODULE, 
        -: 2425:				"Can't process JPEG data in input file %s", 
        -: 2426:							TIFFFileName(input));
    #####: 2427:						_TIFFfree(samplebuffer);
    #####: 2428:						_TIFFfree(buffer);
    #####: 2429:						t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2430:						return(0);
        -: 2431:				}
        -: 2432:			}
    #####: 2433:			buffer[bufferoffset++]=0xff; 
    #####: 2434:			buffer[bufferoffset++]=0xd9;
    #####: 2435:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2436:			_TIFFfree(stripbuffer);
    #####: 2437:			_TIFFfree(buffer);
    #####: 2438:			return(bufferoffset);
        -: 2439:		}
        -: 2440:#endif /* ifdef JPEG_SUPPORT */
        -: 2441:		(void)0;
        -: 2442:	}
        -: 2443:
    #####: 2444:	if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
    #####: 2445:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2446:		if(buffer==NULL){
    #####: 2447:			TIFFError(TIFF2PDF_MODULE, 
        -: 2448:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2449:				(unsigned long) t2p->tiff_datasize, 
        -: 2450:				TIFFFileName(input));
    #####: 2451:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2452:			return(0);
        -: 2453:		}
    #####: 2454:                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2455:		stripsize=TIFFStripSize(input);
    #####: 2456:		stripcount=TIFFNumberOfStrips(input);
    #####: 2457:		for(i=0;i<stripcount;i++){
        -: 2458:			read = 
    #####: 2459:				TIFFReadEncodedStrip(input, 
        -: 2460:				i, 
    #####: 2461:				(tdata_t) &buffer[bufferoffset], 
    #####: 2462:				TIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));
    #####: 2463:			if(read==-1){
    #####: 2464:				TIFFError(TIFF2PDF_MODULE, 
        -: 2465:					"Error on decoding strip %u of %s", 
        -: 2466:					i, 
        -: 2467:					TIFFFileName(input));
    #####: 2468:				_TIFFfree(buffer);
    #####: 2469:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2470:				return(0);
        -: 2471:			}
    #####: 2472:			bufferoffset+=read;
        -: 2473:		}
        -: 2474:	} else {
    #####: 2475:		if(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
        -: 2476:		
    #####: 2477:			sepstripsize=TIFFStripSize(input);
    #####: 2478:			sepstripcount=TIFFNumberOfStrips(input);
        -: 2479:		
    #####: 2480:			stripsize=sepstripsize*t2p->tiff_samplesperpixel;
    #####: 2481:			stripcount=sepstripcount/t2p->tiff_samplesperpixel;
        -: 2482:			
    #####: 2483:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2484:			if(buffer==NULL){
    #####: 2485:				TIFFError(TIFF2PDF_MODULE, 
        -: 2486:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2487:					(unsigned long) t2p->tiff_datasize, 
        -: 2488:					TIFFFileName(input));
    #####: 2489:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2490:				return(0);
        -: 2491:			}
    #####: 2492:                        memset(buffer, 0, t2p->tiff_datasize);
    #####: 2493:			samplebuffer = (unsigned char*) _TIFFmalloc(stripsize);
    #####: 2494:			if(samplebuffer==NULL){
    #####: 2495:				TIFFError(TIFF2PDF_MODULE, 
        -: 2496:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2497:					(unsigned long) t2p->tiff_datasize, 
        -: 2498:					TIFFFileName(input));
    #####: 2499:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2500:                                _TIFFfree(buffer);
    #####: 2501:				return(0);
        -: 2502:			}
    #####: 2503:			for(i=0;i<stripcount;i++){
    #####: 2504:				samplebufferoffset=0;
    #####: 2505:				for(j=0;j<t2p->tiff_samplesperpixel;j++){
        -: 2506:					read = 
    #####: 2507:						TIFFReadEncodedStrip(input, 
    #####: 2508:							i + j*stripcount, 
    #####: 2509:							(tdata_t) &(samplebuffer[samplebufferoffset]), 
    #####: 2510:							TIFFmin(sepstripsize, stripsize - samplebufferoffset));
    #####: 2511:					if(read==-1){
    #####: 2512:						TIFFError(TIFF2PDF_MODULE, 
        -: 2513:					"Error on decoding strip %u of %s", 
    #####: 2514:							i + j*stripcount, 
        -: 2515:							TIFFFileName(input));
    #####: 2516:							_TIFFfree(buffer);
    #####: 2517:						t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2518:						return(0);
        -: 2519:					}
    #####: 2520:					samplebufferoffset+=read;
        -: 2521:				}
    #####: 2522:				t2p_sample_planar_separate_to_contig(
        -: 2523:					t2p,
        -: 2524:					&(buffer[bufferoffset]),
        -: 2525:					samplebuffer, 
        -: 2526:					samplebufferoffset); 
    #####: 2527:				bufferoffset+=samplebufferoffset;
        -: 2528:			}
    #####: 2529:			_TIFFfree(samplebuffer);
    #####: 2530:			goto dataready;
        -: 2531:		}
        -: 2532:
    #####: 2533:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2534:		if(buffer==NULL){
    #####: 2535:			TIFFError(TIFF2PDF_MODULE, 
        -: 2536:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2537:				(unsigned long) t2p->tiff_datasize, 
        -: 2538:				TIFFFileName(input));
    #####: 2539:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2540:			return(0);
        -: 2541:		}
    #####: 2542:                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2543:		stripsize=TIFFStripSize(input);
    #####: 2544:		stripcount=TIFFNumberOfStrips(input);
    #####: 2545:		for(i=0;i<stripcount;i++){
        -: 2546:			read = 
    #####: 2547:				TIFFReadEncodedStrip(input, 
        -: 2548:				i, 
    #####: 2549:				(tdata_t) &buffer[bufferoffset], 
    #####: 2550:				TIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));
    #####: 2551:			if(read==-1){
    #####: 2552:				TIFFError(TIFF2PDF_MODULE, 
        -: 2553:					"Error on decoding strip %u of %s", 
        -: 2554:					i, 
        -: 2555:					TIFFFileName(input));
    #####: 2556:				_TIFFfree(samplebuffer);
    #####: 2557:				_TIFFfree(buffer);
    #####: 2558:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2559:				return(0);
        -: 2560:			}
    #####: 2561:			bufferoffset+=read;
        -: 2562:		}
        -: 2563:
    #####: 2564:		if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){
        -: 2565:			// FIXME: overflow?
    #####: 2566:			samplebuffer=(unsigned char*)_TIFFrealloc( 
        -: 2567:				(tdata_t) buffer, 
    #####: 2568:				t2p->tiff_datasize * t2p->tiff_samplesperpixel);
    #####: 2569:			if(samplebuffer==NULL){
    #####: 2570:				TIFFError(TIFF2PDF_MODULE, 
        -: 2571:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2572:					(unsigned long) t2p->tiff_datasize, 
        -: 2573:					TIFFFileName(input));
    #####: 2574:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2575:				_TIFFfree(buffer);
    #####: 2576:				return(0);
        -: 2577:			} else {
    #####: 2578:				buffer=samplebuffer;
    #####: 2579:				t2p->tiff_datasize *= t2p->tiff_samplesperpixel;
        -: 2580:			}
    #####: 2581:			t2p_sample_realize_palette(t2p, buffer);
        -: 2582:		}
        -: 2583:
    #####: 2584:		if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
    #####: 2585:			t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
        -: 2586:				(tdata_t)buffer, 
    #####: 2587:				t2p->tiff_width*t2p->tiff_length);
        -: 2588:		}
        -: 2589:
    #####: 2590:		if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
    #####: 2591:			t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
        -: 2592:				(tdata_t)buffer, 
    #####: 2593:				t2p->tiff_width*t2p->tiff_length);
        -: 2594:		}
        -: 2595:
    #####: 2596:		if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
    #####: 2597:			samplebuffer=(unsigned char*)_TIFFrealloc(
        -: 2598:				(tdata_t)buffer, 
    #####: 2599:				t2p->tiff_width*t2p->tiff_length*4);
    #####: 2600:			if(samplebuffer==NULL){
    #####: 2601:				TIFFError(TIFF2PDF_MODULE, 
        -: 2602:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2603:					(unsigned long) t2p->tiff_datasize, 
        -: 2604:					TIFFFileName(input));
    #####: 2605:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2606:				_TIFFfree(buffer);
    #####: 2607:				return(0);
        -: 2608:			} else {
    #####: 2609:				buffer=samplebuffer;
        -: 2610:			}
    #####: 2611:			if(!TIFFReadRGBAImageOriented(
        -: 2612:				input, 
        -: 2613:				t2p->tiff_width, 
        -: 2614:				t2p->tiff_length, 
        -: 2615:				(uint32*)buffer, 
        -: 2616:				ORIENTATION_TOPLEFT,
        -: 2617:				0)){
    #####: 2618:				TIFFError(TIFF2PDF_MODULE, 
        -: 2619:	"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s", 
        -: 2620:					TIFFFileName(input));
    #####: 2621:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2622:				return(0);
        -: 2623:			}
    #####: 2624:			t2p->tiff_datasize=t2p_sample_abgr_to_rgb(
        -: 2625:				(tdata_t) buffer, 
    #####: 2626:				t2p->tiff_width*t2p->tiff_length);
        -: 2627:
        -: 2628:		}
        -: 2629:
    #####: 2630:		if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
    #####: 2631:			t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
        -: 2632:				(tdata_t)buffer, 
    #####: 2633:				t2p->tiff_width*t2p->tiff_length);
        -: 2634:		}
        -: 2635:	}
        -: 2636:
    #####: 2637:dataready:
        -: 2638:
    #####: 2639:	t2p_disable(output);
    #####: 2640:	TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
    #####: 2641:	TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
    #####: 2642:	TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
    #####: 2643:	TIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);
    #####: 2644:	TIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);
    #####: 2645:	TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);
    #####: 2646:	TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    #####: 2647:	TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
        -: 2648:
    #####: 2649:	switch(t2p->pdf_compression){
    #####: 2650:	case T2P_COMPRESS_NONE:
    #####: 2651:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
    #####: 2652:		break;
        -: 2653:#ifdef CCITT_SUPPORT
    #####: 2654:	case T2P_COMPRESS_G4:
    #####: 2655:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
    #####: 2656:		break;
        -: 2657:#endif /* ifdef CCITT_SUPPORT */
        -: 2658:#ifdef JPEG_SUPPORT
    #####: 2659:	case T2P_COMPRESS_JPEG:
    #####: 2660:		if(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {
    #####: 2661:			uint16 hor = 0, ver = 0;
    #####: 2662:			if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) {
    #####: 2663:				if(hor != 0 && ver != 0){
    #####: 2664:					TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);
        -: 2665:				}
        -: 2666:			}
    #####: 2667:			if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){
    #####: 2668:				TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);
        -: 2669:			}
        -: 2670:		}
    #####: 2671:		if(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){
    #####: 2672:			TIFFError(TIFF2PDF_MODULE, 
        -: 2673:		"Unable to use JPEG compression for input %s and output %s", 
        -: 2674:				TIFFFileName(input),
        -: 2675:				TIFFFileName(output));
    #####: 2676:			_TIFFfree(buffer);
    #####: 2677:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2678:			return(0);
        -: 2679:		}
    #####: 2680:		TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);
        -: 2681:
    #####: 2682:		if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){
    #####: 2683:			TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    #####: 2684:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){
    #####: 2685:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
        -: 2686:			} else {
    #####: 2687:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);
        -: 2688:			}
        -: 2689:		}
    #####: 2690:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
        -: 2691:			(void)0;
        -: 2692:		}
    #####: 2693:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
        -: 2694:			(void)0;
        -: 2695:		}
    #####: 2696:		if(t2p->pdf_defaultcompressionquality != 0){
    #####: 2697:			TIFFSetField(output, 
        -: 2698:				TIFFTAG_JPEGQUALITY, 
    #####: 2699:				t2p->pdf_defaultcompressionquality);
        -: 2700:		}
        -: 2701:	
    #####: 2702:		break;
        -: 2703:#endif /* ifdef JPEG_SUPPORT */
        -: 2704:#ifdef ZIP_SUPPORT
        -: 2705:	case T2P_COMPRESS_ZIP:
        -: 2706:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
        -: 2707:		if(t2p->pdf_defaultcompressionquality%100 != 0){
        -: 2708:			TIFFSetField(output, 
        -: 2709:				TIFFTAG_PREDICTOR, 
        -: 2710:				t2p->pdf_defaultcompressionquality % 100);
        -: 2711:		}
        -: 2712:		if(t2p->pdf_defaultcompressionquality/100 != 0){
        -: 2713:			TIFFSetField(output, 
        -: 2714:				TIFFTAG_ZIPQUALITY, 
        -: 2715:				(t2p->pdf_defaultcompressionquality / 100));
        -: 2716:		}
        -: 2717:		break;
        -: 2718:#endif /* ifdef ZIP_SUPPORT */
    #####: 2719:	default:
    #####: 2720:		break;
        -: 2721:	}
        -: 2722:
    #####: 2723:	t2p_enable(output);
    #####: 2724:	t2p->outputwritten = 0;
        -: 2725:#ifdef JPEG_SUPPORT
    #####: 2726:	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
    #####: 2727:	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){
    #####: 2728:		bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,
        -: 2729:						     buffer,
        -: 2730:						     stripsize * stripcount); 
        -: 2731:	} else
        -: 2732:#endif /* ifdef JPEG_SUPPORT */
        -: 2733:        {
    #####: 2734:		bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,
        -: 2735:						     buffer,
        -: 2736:						     t2p->tiff_datasize); 
        -: 2737:	}
    #####: 2738:	if (buffer != NULL) {
    #####: 2739:		_TIFFfree(buffer);
    #####: 2740:		buffer=NULL;
        -: 2741:	}
        -: 2742:
    #####: 2743:	if (bufferoffset == (tsize_t)-1) {
    #####: 2744:		TIFFError(TIFF2PDF_MODULE, 
        -: 2745:			  "Error writing encoded strip to output PDF %s", 
        -: 2746:			  TIFFFileName(output));
    #####: 2747:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2748:		return(0);
        -: 2749:	}
        -: 2750:	
    #####: 2751:	written = t2p->outputwritten;
    #####: 2752:	return(written);
        -: 2753:}
        -: 2754:
        -: 2755:/*
        -: 2756: * This function reads the raster image data from the input TIFF for an image
        -: 2757: * tile and writes the data to the output PDF XObject image dictionary stream
        -: 2758: * for the tile.  It returns the amount written or zero on error.
        -: 2759: */
        -: 2760:
    #####: 2761:tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){
        -: 2762:
    #####: 2763:	uint16 edge=0;
    #####: 2764:	tsize_t written=0;
    #####: 2765:	unsigned char* buffer=NULL;
    #####: 2766:	tsize_t bufferoffset=0;
    #####: 2767:	unsigned char* samplebuffer=NULL;
    #####: 2768:	tsize_t samplebufferoffset=0;
    #####: 2769:	tsize_t read=0;
    #####: 2770:	uint16 i=0;
    #####: 2771:	ttile_t tilecount=0;
        -: 2772:	/* tsize_t tilesize=0; */
    #####: 2773:	ttile_t septilecount=0;
    #####: 2774:	tsize_t septilesize=0;
        -: 2775:#ifdef JPEG_SUPPORT
    #####: 2776:	unsigned char* jpt;
    #####: 2777:	float* xfloatp;
    #####: 2778:	uint32 xuint32=0;
        -: 2779:#endif
        -: 2780:
        -: 2781:	/* Fail if prior error (in particular, can't trust tiff_datasize) */
    #####: 2782:	if (t2p->t2p_error != T2P_ERR_OK)
    #####: 2783:		return(0);
        -: 2784:
    #####: 2785:	edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
    #####: 2786:	edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
        -: 2787:
    #####: 2788:	if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)
        -: 2789:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
    #####: 2790:		|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)
        -: 2791:#endif
        -: 2792:	)
        -: 2793:	){
        -: 2794:#ifdef CCITT_SUPPORT
    #####: 2795:		if(t2p->pdf_compression == T2P_COMPRESS_G4){
    #####: 2796:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2797:			if(buffer==NULL){
    #####: 2798:				TIFFError(TIFF2PDF_MODULE, 
        -: 2799:					"Can't allocate %lu bytes of memory "
        -: 2800:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2801:					(unsigned long) t2p->tiff_datasize, 
        -: 2802:					TIFFFileName(input));
    #####: 2803:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2804:				return(0);
        -: 2805:			}
    #####: 2806:			TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
    #####: 2807:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
    #####: 2808:					TIFFReverseBits(buffer, t2p->tiff_datasize);
        -: 2809:			}
    #####: 2810:			t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
    #####: 2811:			_TIFFfree(buffer);
    #####: 2812:			return(t2p->tiff_datasize);
        -: 2813:		}
        -: 2814:#endif
        -: 2815:#ifdef ZIP_SUPPORT
        -: 2816:		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
        -: 2817:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
        -: 2818:			if(buffer==NULL){
        -: 2819:				TIFFError(TIFF2PDF_MODULE, 
        -: 2820:					"Can't allocate %lu bytes of memory "
        -: 2821:                                        "for t2p_readwrite_pdf_image_tile, %s", 
        -: 2822:					(unsigned long) t2p->tiff_datasize, 
        -: 2823:					TIFFFileName(input));
        -: 2824:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2825:				return(0);
        -: 2826:			}
        -: 2827:			TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
        -: 2828:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
        -: 2829:					TIFFReverseBits(buffer, t2p->tiff_datasize);
        -: 2830:			}
        -: 2831:			t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
        -: 2832:			_TIFFfree(buffer);
        -: 2833:			return(t2p->tiff_datasize);
        -: 2834:		}
        -: 2835:#endif
        -: 2836:#ifdef OJPEG_SUPPORT
    #####: 2837:		if(t2p->tiff_compression == COMPRESSION_OJPEG){
    #####: 2838:			if(! t2p->pdf_ojpegdata){
    #####: 2839:				TIFFError(TIFF2PDF_MODULE, 
        -: 2840:					"No support for OJPEG image %s with "
        -: 2841:                                        "bad tables", 
        -: 2842:					TIFFFileName(input));
    #####: 2843:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2844:				return(0);
        -: 2845:			}
    #####: 2846:			buffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2847:			if(buffer==NULL){
    #####: 2848:				TIFFError(TIFF2PDF_MODULE, 
        -: 2849:					"Can't allocate %lu bytes of memory "
        -: 2850:                                        "for t2p_readwrite_pdf_image, %s", 
    #####: 2851:					(unsigned long) t2p->tiff_datasize, 
        -: 2852:					TIFFFileName(input));
    #####: 2853:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2854:				return(0);
        -: 2855:			}
    #####: 2856:			_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);
    #####: 2857:			if(edge!=0){
    #####: 2858:				if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
    #####: 2859:					buffer[7]=
    #####: 2860:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;
    #####: 2861:					buffer[8]=
    #####: 2862:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;
        -: 2863:				}
    #####: 2864:				if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
    #####: 2865:					buffer[9]=
    #####: 2866:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;
    #####: 2867:					buffer[10]=
    #####: 2868:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;
        -: 2869:				}
        -: 2870:			}
    #####: 2871:			bufferoffset=t2p->pdf_ojpegdatalength;
    #####: 2872:			bufferoffset+=TIFFReadRawTile(input, 
        -: 2873:					tile, 
    #####: 2874:					(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2875:					-1);
    #####: 2876:			((unsigned char*)buffer)[bufferoffset++]=0xff;
    #####: 2877:			((unsigned char*)buffer)[bufferoffset++]=0xd9;
    #####: 2878:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2879:			_TIFFfree(buffer);
    #####: 2880:			return(bufferoffset);
        -: 2881:		}
        -: 2882:#endif
        -: 2883:#ifdef JPEG_SUPPORT
    #####: 2884:		if(t2p->tiff_compression == COMPRESSION_JPEG){
        -: 2885:			unsigned char table_end[2];
    #####: 2886:			uint32 count = 0;
    #####: 2887:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2888:			if(buffer==NULL){
    #####: 2889:				TIFFError(TIFF2PDF_MODULE, 
        -: 2890:					"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory "
        -: 2891:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2892:                                          (TIFF_SIZE_T) t2p->tiff_datasize, 
        -: 2893:					TIFFFileName(input));
    #####: 2894:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2895:				return(0);
        -: 2896:			}
    #####: 2897:			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
    #####: 2898:				if (count > 4) {
        -: 2899:                                        int retTIFFReadRawTile;
        -: 2900:                    /* Ignore EOI marker of JpegTables */
    #####: 2901:					_TIFFmemcpy(buffer, jpt, count - 2);
    #####: 2902:					bufferoffset += count - 2;
        -: 2903:                    /* Store last 2 bytes of the JpegTables */
    #####: 2904:					table_end[0] = buffer[bufferoffset-2];
    #####: 2905:					table_end[1] = buffer[bufferoffset-1];
    #####: 2906:					xuint32 = bufferoffset;
    #####: 2907:                                        bufferoffset -= 2;
    #####: 2908:                                        retTIFFReadRawTile= TIFFReadRawTile(
        -: 2909:						input, 
        -: 2910:						tile, 
    #####: 2911:						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2912:						-1);
    #####: 2913:                                        if( retTIFFReadRawTile < 0 )
        -: 2914:                                        {
    #####: 2915:                                            _TIFFfree(buffer);
    #####: 2916:                                            t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2917:                                            return(0);
        -: 2918:                                        }
    #####: 2919:					bufferoffset += retTIFFReadRawTile;
        -: 2920:                    /* Overwrite SOI marker of image scan with previously */
        -: 2921:                    /* saved end of JpegTables */
    #####: 2922:					buffer[xuint32-2]=table_end[0];
    #####: 2923:					buffer[xuint32-1]=table_end[1];
        -: 2924:				}
        -: 2925:			}
    #####: 2926:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2927:			_TIFFfree(buffer);
    #####: 2928:			return(bufferoffset);
        -: 2929:		}
        -: 2930:#endif
        -: 2931:		(void)0;
        -: 2932:	}
        -: 2933:
    #####: 2934:	if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
    #####: 2935:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2936:		if(buffer==NULL){
    #####: 2937:			TIFFError(TIFF2PDF_MODULE, 
        -: 2938:				"Can't allocate %lu bytes of memory for "
        -: 2939:                                "t2p_readwrite_pdf_image_tile, %s", 
    #####: 2940:				(unsigned long) t2p->tiff_datasize, 
        -: 2941:				TIFFFileName(input));
    #####: 2942:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2943:			return(0);
        -: 2944:		}
        -: 2945:
    #####: 2946:		read = TIFFReadEncodedTile(
        -: 2947:			input, 
        -: 2948:			tile, 
    #####: 2949:			(tdata_t) &buffer[bufferoffset], 
        -: 2950:			t2p->tiff_datasize);
    #####: 2951:		if(read==-1){
    #####: 2952:			TIFFError(TIFF2PDF_MODULE, 
        -: 2953:				"Error on decoding tile %u of %s", 
        -: 2954:				tile, 
        -: 2955:				TIFFFileName(input));
    #####: 2956:			_TIFFfree(buffer);
    #####: 2957:			t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2958:			return(0);
        -: 2959:		}
        -: 2960:
        -: 2961:	} else {
        -: 2962:
    #####: 2963:		if(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
    #####: 2964:			septilesize=TIFFTileSize(input);
    #####: 2965:			septilecount=TIFFNumberOfTiles(input);
        -: 2966:			/* tilesize=septilesize*t2p->tiff_samplesperpixel; */
    #####: 2967:			tilecount=septilecount/t2p->tiff_samplesperpixel;
    #####: 2968:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2969:			if(buffer==NULL){
    #####: 2970:				TIFFError(TIFF2PDF_MODULE, 
        -: 2971:					"Can't allocate %lu bytes of memory "
        -: 2972:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2973:					(unsigned long) t2p->tiff_datasize, 
        -: 2974:					TIFFFileName(input));
    #####: 2975:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2976:				return(0);
        -: 2977:			}
    #####: 2978:			samplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2979:			if(samplebuffer==NULL){
    #####: 2980:				TIFFError(TIFF2PDF_MODULE, 
        -: 2981:					"Can't allocate %lu bytes of memory "
        -: 2982:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2983:					(unsigned long) t2p->tiff_datasize, 
        -: 2984:					TIFFFileName(input));
    #####: 2985:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2986:				return(0);
        -: 2987:			}
    #####: 2988:			samplebufferoffset=0;
    #####: 2989:			for(i=0;i<t2p->tiff_samplesperpixel;i++){
        -: 2990:				read = 
    #####: 2991:					TIFFReadEncodedTile(input, 
    #####: 2992:						tile + i*tilecount, 
    #####: 2993:						(tdata_t) &(samplebuffer[samplebufferoffset]), 
        -: 2994:						septilesize);
    #####: 2995:				if(read==-1){
    #####: 2996:					TIFFError(TIFF2PDF_MODULE, 
        -: 2997:						"Error on decoding tile %u of %s", 
    #####: 2998:						tile + i*tilecount, 
        -: 2999:						TIFFFileName(input));
    #####: 3000:						_TIFFfree(samplebuffer);
    #####: 3001:						_TIFFfree(buffer);
    #####: 3002:					t2p->t2p_error=T2P_ERR_ERROR;
    #####: 3003:					return(0);
        -: 3004:				}
    #####: 3005:				samplebufferoffset+=read;
        -: 3006:			}
    #####: 3007:			t2p_sample_planar_separate_to_contig(
        -: 3008:				t2p,
        -: 3009:				&(buffer[bufferoffset]),
        -: 3010:				samplebuffer, 
        -: 3011:				samplebufferoffset); 
    #####: 3012:			bufferoffset+=samplebufferoffset;
    #####: 3013:			_TIFFfree(samplebuffer);
        -: 3014:		}
        -: 3015:
    #####: 3016:		if(buffer==NULL){
    #####: 3017:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 3018:			if(buffer==NULL){
    #####: 3019:				TIFFError(TIFF2PDF_MODULE, 
        -: 3020:					"Can't allocate %lu bytes of memory "
        -: 3021:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 3022:					(unsigned long) t2p->tiff_datasize, 
        -: 3023:					TIFFFileName(input));
    #####: 3024:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3025:				return(0);
        -: 3026:			}
    #####: 3027:			read = TIFFReadEncodedTile(
        -: 3028:				input, 
        -: 3029:				tile, 
    #####: 3030:				(tdata_t) &buffer[bufferoffset], 
        -: 3031:				t2p->tiff_datasize);
    #####: 3032:			if(read==-1){
    #####: 3033:				TIFFError(TIFF2PDF_MODULE, 
        -: 3034:					"Error on decoding tile %u of %s", 
        -: 3035:					tile, 
        -: 3036:					TIFFFileName(input));
    #####: 3037:				_TIFFfree(buffer);
    #####: 3038:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 3039:				return(0);
        -: 3040:			}
        -: 3041:		}
        -: 3042:
    #####: 3043:		if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
    #####: 3044:			t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
        -: 3045:				(tdata_t)buffer, 
    #####: 3046:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3047:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3048:		}
        -: 3049:
    #####: 3050:		if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
    #####: 3051:			t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
        -: 3052:				(tdata_t)buffer, 
    #####: 3053:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3054:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3055:		}
        -: 3056:
    #####: 3057:		if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
    #####: 3058:			TIFFError(TIFF2PDF_MODULE, 
        -: 3059:				"No support for YCbCr to RGB in tile for %s", 
        -: 3060:				TIFFFileName(input));
    #####: 3061:			_TIFFfree(buffer);
    #####: 3062:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3063:			return(0);
        -: 3064:		}
        -: 3065:
    #####: 3066:		if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
    #####: 3067:			t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
        -: 3068:				(tdata_t)buffer, 
    #####: 3069:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3070:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3071:		}
        -: 3072:	}
        -: 3073:
    #####: 3074:	if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){
    #####: 3075:		t2p_tile_collapse_left(
        -: 3076:			buffer, 
        -: 3077:			TIFFTileRowSize(input),
    #####: 3078:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,
    #####: 3079:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, 
    #####: 3080:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3081:	}
        -: 3082:
        -: 3083:
    #####: 3084:	t2p_disable(output);
    #####: 3085:	TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
    #####: 3086:	TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
    #####: 3087:	TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
    #####: 3088:	if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
    #####: 3089:		TIFFSetField(
        -: 3090:			output, 
        -: 3091:			TIFFTAG_IMAGEWIDTH, 
    #####: 3092:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
        -: 3093:	} else {
    #####: 3094:		TIFFSetField(
        -: 3095:			output, 
        -: 3096:			TIFFTAG_IMAGEWIDTH, 
    #####: 3097:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
        -: 3098:	}
    #####: 3099:	if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
    #####: 3100:		TIFFSetField(
        -: 3101:			output, 
        -: 3102:			TIFFTAG_IMAGELENGTH, 
    #####: 3103:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
    #####: 3104:		TIFFSetField(
        -: 3105:			output, 
        -: 3106:			TIFFTAG_ROWSPERSTRIP, 
    #####: 3107:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3108:	} else {
    #####: 3109:		TIFFSetField(
        -: 3110:			output, 
        -: 3111:			TIFFTAG_IMAGELENGTH, 
    #####: 3112:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
    #####: 3113:		TIFFSetField(
        -: 3114:			output, 
        -: 3115:			TIFFTAG_ROWSPERSTRIP, 
    #####: 3116:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
        -: 3117:	}
    #####: 3118:	TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    #####: 3119:	TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
        -: 3120:
    #####: 3121:	switch(t2p->pdf_compression){
    #####: 3122:	case T2P_COMPRESS_NONE:
    #####: 3123:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
    #####: 3124:		break;
        -: 3125:#ifdef CCITT_SUPPORT
    #####: 3126:	case T2P_COMPRESS_G4:
    #####: 3127:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
    #####: 3128:		break;
        -: 3129:#endif
        -: 3130:#ifdef JPEG_SUPPORT
    #####: 3131:	case T2P_COMPRESS_JPEG:
    #####: 3132:		if (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {
    #####: 3133:			uint16 hor = 0, ver = 0;
    #####: 3134:			if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {
    #####: 3135:				if (hor != 0 && ver != 0) {
    #####: 3136:					TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);
        -: 3137:				}
        -: 3138:			}
    #####: 3139:			if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){
    #####: 3140:				TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);
        -: 3141:			}
        -: 3142:		}
    #####: 3143:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
    #####: 3144:		TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */
    #####: 3145:		if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){
    #####: 3146:			TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    #####: 3147:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){
    #####: 3148:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
        -: 3149:			} else {
    #####: 3150:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);
        -: 3151:			}
        -: 3152:		}
    #####: 3153:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
        -: 3154:			(void)0;
        -: 3155:		}
    #####: 3156:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
        -: 3157:			(void)0;
        -: 3158:		}
    #####: 3159:		if(t2p->pdf_defaultcompressionquality != 0){
    #####: 3160:			TIFFSetField(output, 
        -: 3161:				TIFFTAG_JPEGQUALITY, 
    #####: 3162:				t2p->pdf_defaultcompressionquality);
        -: 3163:		}
    #####: 3164:		break;
        -: 3165:#endif
        -: 3166:#ifdef ZIP_SUPPORT
        -: 3167:	case T2P_COMPRESS_ZIP:
        -: 3168:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
        -: 3169:		if(t2p->pdf_defaultcompressionquality%100 != 0){
        -: 3170:			TIFFSetField(output, 
        -: 3171:				TIFFTAG_PREDICTOR, 
        -: 3172:				t2p->pdf_defaultcompressionquality % 100);
        -: 3173:		}
        -: 3174:		if(t2p->pdf_defaultcompressionquality/100 != 0){
        -: 3175:			TIFFSetField(output, 
        -: 3176:				TIFFTAG_ZIPQUALITY, 
        -: 3177:				(t2p->pdf_defaultcompressionquality / 100));
        -: 3178:		}
        -: 3179:		break;
        -: 3180:#endif
    #####: 3181:	default:
    #####: 3182:		break;
        -: 3183:	}
        -: 3184:
    #####: 3185:	t2p_enable(output);
    #####: 3186:	t2p->outputwritten = 0;
    #####: 3187:	bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,
        -: 3188:					     TIFFStripSize(output)); 
    #####: 3189:	if (buffer != NULL) {
    #####: 3190:		_TIFFfree(buffer);
    #####: 3191:		buffer = NULL;
        -: 3192:	}
    #####: 3193:	if (bufferoffset == -1) {
    #####: 3194:		TIFFError(TIFF2PDF_MODULE, 
        -: 3195:			  "Error writing encoded tile to output PDF %s", 
        -: 3196:			  TIFFFileName(output));
    #####: 3197:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3198:		return(0);
        -: 3199:	}
        -: 3200:	
    #####: 3201:	written = t2p->outputwritten;
        -: 3202:	
    #####: 3203:	return(written);
        -: 3204:}
        -: 3205:
        -: 3206:#ifdef OJPEG_SUPPORT
    #####: 3207:int t2p_process_ojpeg_tables(T2P* t2p, TIFF* input){
    #####: 3208:	uint16 proc=0;
    #####: 3209:	void* q;
    #####: 3210:	uint32 q_length=0;
    #####: 3211:	void* dc;
    #####: 3212:	uint32 dc_length=0;
    #####: 3213:	void* ac;
    #####: 3214:	uint32 ac_length=0;
    #####: 3215:	uint16* lp;
    #####: 3216:	uint16* pt;
    #####: 3217:	uint16 h_samp=1;
    #####: 3218:	uint16 v_samp=1;
        -: 3219:	unsigned char* ojpegdata;
        -: 3220:	uint16 table_count;
        -: 3221:	uint32 offset_table;
        -: 3222:	uint32 offset_ms_l;
        -: 3223:	uint32 code_count;
    #####: 3224:	uint32 i=0;
    #####: 3225:	uint32 dest=0;
    #####: 3226:	uint16 ri=0;
    #####: 3227:	uint32 rows=0;
        -: 3228:	
    #####: 3229:	if(!TIFFGetField(input, TIFFTAG_JPEGPROC, &proc)){
    #####: 3230:		TIFFError(TIFF2PDF_MODULE, 
        -: 3231:			"Missing JPEGProc field in OJPEG image %s", 
        -: 3232:			TIFFFileName(input));
    #####: 3233:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3234:		return(0);
        -: 3235:	}
    #####: 3236:	if(proc!=JPEGPROC_BASELINE && proc!=JPEGPROC_LOSSLESS){
    #####: 3237:		TIFFError(TIFF2PDF_MODULE, 
        -: 3238:			"Bad JPEGProc field in OJPEG image %s", 
        -: 3239:			TIFFFileName(input));
    #####: 3240:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3241:		return(0);
        -: 3242:	}
    #####: 3243:	if(!TIFFGetField(input, TIFFTAG_JPEGQTABLES, &q_length, &q)){
    #####: 3244:		TIFFError(TIFF2PDF_MODULE, 
        -: 3245:			"Missing JPEGQTables field in OJPEG image %s", 
        -: 3246:			TIFFFileName(input));
    #####: 3247:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3248:		return(0);
        -: 3249:	}
    #####: 3250:	if(q_length < (64U * t2p->tiff_samplesperpixel)){
    #####: 3251:		TIFFError(TIFF2PDF_MODULE, 
        -: 3252:			"Bad JPEGQTables field in OJPEG image %s", 
        -: 3253:			TIFFFileName(input));
    #####: 3254:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3255:		return(0);
        -: 3256:	} 
    #####: 3257:	if(!TIFFGetField(input, TIFFTAG_JPEGDCTABLES, &dc_length, &dc)){
    #####: 3258:		TIFFError(TIFF2PDF_MODULE, 
        -: 3259:			"Missing JPEGDCTables field in OJPEG image %s", 
        -: 3260:			TIFFFileName(input));
    #####: 3261:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3262:		return(0);
        -: 3263:	}
    #####: 3264:	if(proc==JPEGPROC_BASELINE){
    #####: 3265:		if(!TIFFGetField(input, TIFFTAG_JPEGACTABLES, &ac_length, &ac)){
    #####: 3266:			TIFFError(TIFF2PDF_MODULE, 
        -: 3267:				"Missing JPEGACTables field in OJPEG image %s", 
        -: 3268:				TIFFFileName(input));
    #####: 3269:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3270:			return(0);
        -: 3271:		}
        -: 3272:	} else {
    #####: 3273:		if(!TIFFGetField(input, TIFFTAG_JPEGLOSSLESSPREDICTORS, &lp)){
    #####: 3274:			TIFFError(TIFF2PDF_MODULE, 
        -: 3275:				"Missing JPEGLosslessPredictors field in OJPEG image %s", 
        -: 3276:				TIFFFileName(input));
    #####: 3277:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3278:				return(0);
        -: 3279:		}
    #####: 3280:		if(!TIFFGetField(input, TIFFTAG_JPEGPOINTTRANSFORM, &pt)){
    #####: 3281:			TIFFError(TIFF2PDF_MODULE, 
        -: 3282:				"Missing JPEGPointTransform field in OJPEG image %s", 
        -: 3283:				TIFFFileName(input));
    #####: 3284:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3285:			return(0);
        -: 3286:		}
        -: 3287:	}
    #####: 3288:	if(!TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &h_samp, &v_samp)){
    #####: 3289:		h_samp=1;
    #####: 3290:		v_samp=1;
        -: 3291:	}
    #####: 3292:	if(t2p->pdf_ojpegdata != NULL){
    #####: 3293:		_TIFFfree(t2p->pdf_ojpegdata);
    #####: 3294:		t2p->pdf_ojpegdata=NULL;
        -: 3295:	} 
    #####: 3296:	t2p->pdf_ojpegdata = _TIFFmalloc(2048);
    #####: 3297:	if(t2p->pdf_ojpegdata == NULL){
    #####: 3298:		TIFFError(TIFF2PDF_MODULE, 
        -: 3299:			"Can't allocate %u bytes of memory for t2p_process_ojpeg_tables, %s", 
        -: 3300:			2048, 
        -: 3301:			TIFFFileName(input));
    #####: 3302:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3303:		return(0);
        -: 3304:	}
    #####: 3305:	_TIFFmemset(t2p->pdf_ojpegdata, 0x00, 2048);
    #####: 3306:	t2p->pdf_ojpegdatalength = 0;
    #####: 3307:	table_count=t2p->tiff_samplesperpixel;
    #####: 3308:	if(proc==JPEGPROC_BASELINE){
    #####: 3309:		if(table_count>2) table_count=2;
        -: 3310:	}
    #####: 3311:	ojpegdata=(unsigned char*)t2p->pdf_ojpegdata;
    #####: 3312:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3313:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xd8;
    #####: 3314:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3315:	if(proc==JPEGPROC_BASELINE){
    #####: 3316:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc0;
        -: 3317:	} else {
    #####: 3318:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc3;
        -: 3319:	}
    #####: 3320:	ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3321:	ojpegdata[t2p->pdf_ojpegdatalength++]=(8 + 3*t2p->tiff_samplesperpixel);
    #####: 3322:	ojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_bitspersample & 0xff);
    #####: 3323:	if(TIFFIsTiled(input)){
    #####: 3324:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3325:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength >> 8) & 0xff;
    #####: 3326:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3327:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength ) & 0xff;
    #####: 3328:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3329:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth >> 8) & 0xff;
    #####: 3330:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3331:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth ) & 0xff;
        -: 3332:	} else {
    #####: 3333:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3334:			(t2p->tiff_length >> 8) & 0xff;
    #####: 3335:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3336:			(t2p->tiff_length ) & 0xff;
    #####: 3337:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3338:			(t2p->tiff_width >> 8) & 0xff;
    #####: 3339:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3340:			(t2p->tiff_width ) & 0xff;
        -: 3341:	}
    #####: 3342:	ojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_samplesperpixel & 0xff);
    #####: 3343:	for(i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 3344:		ojpegdata[t2p->pdf_ojpegdatalength++]=i;
    #####: 3345:		if(i==0){
    #####: 3346:			ojpegdata[t2p->pdf_ojpegdatalength] |= h_samp<<4 & 0xf0;;
    #####: 3347:			ojpegdata[t2p->pdf_ojpegdatalength++] |= v_samp & 0x0f;
        -: 3348:		} else {
    #####: 3349:				ojpegdata[t2p->pdf_ojpegdatalength++]= 0x11;
        -: 3350:		}
    #####: 3351:		ojpegdata[t2p->pdf_ojpegdatalength++]=i;
        -: 3352:	}
    #####: 3353:	for(dest=0;dest<t2p->tiff_samplesperpixel;dest++){
    #####: 3354:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3355:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xdb;
    #####: 3356:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3357:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x43;
    #####: 3358:		ojpegdata[t2p->pdf_ojpegdatalength++]=dest;
    #####: 3359:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength++]), 
    #####: 3360:			&(((unsigned char*)q)[64*dest]), 64);
    #####: 3361:		t2p->pdf_ojpegdatalength+=64;
        -: 3362:	}
    #####: 3363:	offset_table=0;
    #####: 3364:	for(dest=0;dest<table_count;dest++){
    #####: 3365:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3366:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;
    #####: 3367:		offset_ms_l=t2p->pdf_ojpegdatalength;
    #####: 3368:		t2p->pdf_ojpegdatalength+=2;
    #####: 3369:		ojpegdata[t2p->pdf_ojpegdatalength++]=dest & 0x0f;
    #####: 3370:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3371:			&(((unsigned char*)dc)[offset_table]), 16);
    #####: 3372:		code_count=0;
    #####: 3373:		offset_table+=16;
    #####: 3374:		for(i=0;i<16;i++){
    #####: 3375:			code_count+=ojpegdata[t2p->pdf_ojpegdatalength++];
        -: 3376:		}
    #####: 3377:		ojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;
    #####: 3378:		ojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;
    #####: 3379:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3380:			&(((unsigned char*)dc)[offset_table]), code_count);
    #####: 3381:		offset_table+=code_count;
    #####: 3382:		t2p->pdf_ojpegdatalength+=code_count;
        -: 3383:	}
    #####: 3384:	if(proc==JPEGPROC_BASELINE){
    #####: 3385:	offset_table=0;
    #####: 3386:		for(dest=0;dest<table_count;dest++){
    #####: 3387:			ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3388:			ojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;
    #####: 3389:			offset_ms_l=t2p->pdf_ojpegdatalength;
    #####: 3390:			t2p->pdf_ojpegdatalength+=2;
    #####: 3391:			ojpegdata[t2p->pdf_ojpegdatalength] |= 0x10;
    #####: 3392:			ojpegdata[t2p->pdf_ojpegdatalength++] |=dest & 0x0f;
    #####: 3393:			_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3394:				&(((unsigned char*)ac)[offset_table]), 16);
    #####: 3395:			code_count=0;
    #####: 3396:			offset_table+=16;
    #####: 3397:			for(i=0;i<16;i++){
    #####: 3398:				code_count+=ojpegdata[t2p->pdf_ojpegdatalength++];
        -: 3399:			}	
    #####: 3400:			ojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;
    #####: 3401:			ojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;
    #####: 3402:			_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3403:				&(((unsigned char*)ac)[offset_table]), code_count);
    #####: 3404:			offset_table+=code_count;
    #####: 3405:			t2p->pdf_ojpegdatalength+=code_count;
        -: 3406:		}
        -: 3407:	}
    #####: 3408:	if(TIFFNumberOfStrips(input)>1){
    #####: 3409:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3410:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xdd;
    #####: 3411:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3412:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x04;
    #####: 3413:		h_samp*=8;
    #####: 3414:		v_samp*=8;
    #####: 3415:		ri=(t2p->tiff_width+h_samp-1) / h_samp;
    #####: 3416:		TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rows);
    #####: 3417:		ri*=(rows+v_samp-1)/v_samp;
    #####: 3418:		ojpegdata[t2p->pdf_ojpegdatalength++]= (ri>>8) & 0xff;
    #####: 3419:		ojpegdata[t2p->pdf_ojpegdatalength++]= ri & 0xff;
        -: 3420:	}
    #####: 3421:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3422:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xda;
    #####: 3423:	ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3424:	ojpegdata[t2p->pdf_ojpegdatalength++]=(6 + 2*t2p->tiff_samplesperpixel);
    #####: 3425:	ojpegdata[t2p->pdf_ojpegdatalength++]=t2p->tiff_samplesperpixel & 0xff;
    #####: 3426:	for(i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 3427:		ojpegdata[t2p->pdf_ojpegdatalength++]= i & 0xff;
    #####: 3428:		if(proc==JPEGPROC_BASELINE){
    #####: 3429:			ojpegdata[t2p->pdf_ojpegdatalength] |= 
    #####: 3430:				( ( (i>(table_count-1U)) ? (table_count-1U) : i) << 4U) & 0xf0;
    #####: 3431:			ojpegdata[t2p->pdf_ojpegdatalength++] |= 
    #####: 3432:				( (i>(table_count-1U)) ? (table_count-1U) : i) & 0x0f;
        -: 3433:		} else {
    #####: 3434:			ojpegdata[t2p->pdf_ojpegdatalength++] =  (i << 4) & 0xf0;
        -: 3435:		}
        -: 3436:	}
    #####: 3437:	if(proc==JPEGPROC_BASELINE){
    #####: 3438:		t2p->pdf_ojpegdatalength++;
    #####: 3439:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x3f;
    #####: 3440:		t2p->pdf_ojpegdatalength++;
        -: 3441:	} else {
    #####: 3442:		ojpegdata[t2p->pdf_ojpegdatalength++]= (lp[0] & 0xff);
    #####: 3443:		t2p->pdf_ojpegdatalength++;
    #####: 3444:		ojpegdata[t2p->pdf_ojpegdatalength++]= (pt[0] & 0x0f);
        -: 3445:	}
        -: 3446:
    #####: 3447:	return(1);
        -: 3448:}
        -: 3449:#endif
        -: 3450:
        -: 3451:#ifdef JPEG_SUPPORT
    #####: 3452:int t2p_process_jpeg_strip(
        -: 3453:	unsigned char* strip, 
        -: 3454:	tsize_t* striplength, 
        -: 3455:	unsigned char* buffer, 
        -: 3456:    tsize_t buffersize,
        -: 3457:	tsize_t* bufferoffset, 
        -: 3458:	tstrip_t no, 
        -: 3459:	uint32 height){
        -: 3460:
    #####: 3461:	tsize_t i=0;
        -: 3462:
    #####: 3463:	while (i < *striplength) {
        -: 3464:		tsize_t datalen;
        -: 3465:		uint16 ri;
        -: 3466:		uint16 v_samp;
        -: 3467:		uint16 h_samp;
        -: 3468:		int j;
        -: 3469:		int ncomp;
        -: 3470:
        -: 3471:		/* marker header: one or more FFs */
    #####: 3472:		if (strip[i] != 0xff)
    #####: 3473:			return(0);
    #####: 3474:		i++;
    #####: 3475:		while (i < *striplength && strip[i] == 0xff)
    #####: 3476:			i++;
    #####: 3477:		if (i >= *striplength)
    #####: 3478:			return(0);
        -: 3479:		/* SOI is the only pre-SOS marker without a length word */
    #####: 3480:		if (strip[i] == 0xd8)
    #####: 3481:			datalen = 0;
        -: 3482:		else {
    #####: 3483:			if ((*striplength - i) <= 2)
    #####: 3484:				return(0);
    #####: 3485:			datalen = (strip[i+1] << 8) | strip[i+2];
    #####: 3486:			if (datalen < 2 || datalen >= (*striplength - i))
    #####: 3487:				return(0);
        -: 3488:		}
    #####: 3489:		switch( strip[i] ){
    #####: 3490:			case 0xd8:	/* SOI - start of image */
    #####: 3491:                if( *bufferoffset + 2 > buffersize )
    #####: 3492:                    return(0);
    #####: 3493:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);
    #####: 3494:				*bufferoffset+=2;
    #####: 3495:				break;
    #####: 3496:			case 0xc0:	/* SOF0 */
        -: 3497:			case 0xc1:	/* SOF1 */
        -: 3498:			case 0xc3:	/* SOF3 */
        -: 3499:			case 0xc9:	/* SOF9 */
        -: 3500:			case 0xca:	/* SOF10 */
    #####: 3501:				if(no==0){
    #####: 3502:                    if( *bufferoffset + datalen + 2 + 6 > buffersize )
    #####: 3503:                        return(0);
    #####: 3504:					_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3505:                    if( *bufferoffset + 9 >= buffersize )
    #####: 3506:                        return(0);
    #####: 3507:					ncomp = buffer[*bufferoffset+9];
    #####: 3508:					if (ncomp < 1 || ncomp > 4)
    #####: 3509:						return(0);
    #####: 3510:					v_samp=1;
    #####: 3511:					h_samp=1;
    #####: 3512:                    if( *bufferoffset + 11 + 3*(ncomp-1) >= buffersize )
    #####: 3513:                        return(0);
    #####: 3514:					for(j=0;j<ncomp;j++){
    #####: 3515:						uint16 samp = buffer[*bufferoffset+11+(3*j)];
    #####: 3516:						if( (samp>>4) > h_samp) 
    #####: 3517:							h_samp = (samp>>4);
    #####: 3518:						if( (samp & 0x0f) > v_samp) 
    #####: 3519:							v_samp = (samp & 0x0f);
        -: 3520:					}
    #####: 3521:					v_samp*=8;
    #####: 3522:					h_samp*=8;
    #####: 3523:					ri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | 
    #####: 3524:					(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ 
        -: 3525:					v_samp);
    #####: 3526:					ri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | 
    #####: 3527:					(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ 
        -: 3528:					h_samp);
    #####: 3529:					buffer[*bufferoffset+5]=
    #####: 3530:                                          (unsigned char) ((height>>8) & 0xff);
    #####: 3531:					buffer[*bufferoffset+6]=
    #####: 3532:                                            (unsigned char) (height & 0xff);
    #####: 3533:					*bufferoffset+=datalen+2;
        -: 3534:					/* insert a DRI marker */
    #####: 3535:					buffer[(*bufferoffset)++]=0xff;
    #####: 3536:					buffer[(*bufferoffset)++]=0xdd;
    #####: 3537:					buffer[(*bufferoffset)++]=0x00;
    #####: 3538:					buffer[(*bufferoffset)++]=0x04;
    #####: 3539:					buffer[(*bufferoffset)++]=(ri >> 8) & 0xff;
    #####: 3540:					buffer[(*bufferoffset)++]= ri & 0xff;
        -: 3541:				}
    #####: 3542:				break;
    #####: 3543:			case 0xc4: /* DHT */
        -: 3544:			case 0xdb: /* DQT */
    #####: 3545:                if( *bufferoffset + datalen + 2 > buffersize )
    #####: 3546:                    return(0);
    #####: 3547:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3548:				*bufferoffset+=datalen+2;
    #####: 3549:				break;
    #####: 3550:			case 0xda: /* SOS */
    #####: 3551:				if(no==0){
    #####: 3552:                    if( *bufferoffset + datalen + 2 > buffersize )
    #####: 3553:                        return(0);
    #####: 3554:					_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3555:					*bufferoffset+=datalen+2;
        -: 3556:				} else {
    #####: 3557:                    if( *bufferoffset + 2 > buffersize )
    #####: 3558:                        return(0);
    #####: 3559:					buffer[(*bufferoffset)++]=0xff;
    #####: 3560:					buffer[(*bufferoffset)++]=
    #####: 3561:                                            (unsigned char)(0xd0 | ((no-1)%8));
        -: 3562:				}
    #####: 3563:				i += datalen + 1;
        -: 3564:				/* copy remainder of strip */
    #####: 3565:                if( *bufferoffset + *striplength - i > buffersize )
    #####: 3566:                    return(0);
    #####: 3567:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);
    #####: 3568:				*bufferoffset+= *striplength - i;
    #####: 3569:				return(1);
    #####: 3570:			default:
        -: 3571:				/* ignore any other marker */
    #####: 3572:				break;
        -: 3573:		}
    #####: 3574:		i += datalen + 1;
        -: 3575:	}
        -: 3576:
        -: 3577:	/* failed to find SOS marker */
    #####: 3578:	return(0);
        -: 3579:}
        -: 3580:#endif
        -: 3581:
        -: 3582:/*
        -: 3583:	This functions converts a tilewidth x tilelength buffer of samples into an edgetilewidth x 
        -: 3584:	tilelength buffer of samples.
        -: 3585:*/
    #####: 3586:void t2p_tile_collapse_left(
        -: 3587:	tdata_t buffer, 
        -: 3588:	tsize_t scanwidth, 
        -: 3589:	uint32 tilewidth, 
        -: 3590:	uint32 edgetilewidth, 
        -: 3591:	uint32 tilelength){
        -: 3592:	
        -: 3593:	uint32 i;
    #####: 3594:	tsize_t edgescanwidth=0;
        -: 3595:	
    #####: 3596:	edgescanwidth = (scanwidth * edgetilewidth + (tilewidth - 1))/ tilewidth;
    #####: 3597:	for(i=0;i<tilelength;i++){
        -: 3598:                /* We use memmove() since there can be overlaps in src and dst buffers for the first items */
    #####: 3599:		memmove( 
    #####: 3600:			&(((char*)buffer)[edgescanwidth*i]), 
    #####: 3601:			&(((char*)buffer)[scanwidth*i]), 
        -: 3602:			edgescanwidth);
        -: 3603:	}
        -: 3604:	
    #####: 3605:	return;
        -: 3606:}
        -: 3607:
        -: 3608:
        -: 3609:/*
        -: 3610: * This function calls TIFFWriteDirectory on the output after blanking its
        -: 3611: * output by replacing the read, write, and seek procedures with empty
        -: 3612: * implementations, then it replaces the original implementations.
        -: 3613: */
        -: 3614:
        -: 3615:void
    #####: 3616:t2p_write_advance_directory(T2P* t2p, TIFF* output)
        -: 3617:{
    #####: 3618:	t2p_disable(output);
    #####: 3619:	if(!TIFFWriteDirectory(output)){
    #####: 3620:		TIFFError(TIFF2PDF_MODULE, 
        -: 3621:			"Error writing virtual directory to output PDF %s", 
        -: 3622:			TIFFFileName(output));
    #####: 3623:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3624:		return;
        -: 3625:	}
    #####: 3626:	t2p_enable(output);
    #####: 3627:	return;
        -: 3628:}
        -: 3629:
    #####: 3630:tsize_t t2p_sample_planar_separate_to_contig(
        -: 3631:											T2P* t2p, 
        -: 3632:											unsigned char* buffer, 
        -: 3633:											unsigned char* samplebuffer, 
        -: 3634:											tsize_t samplebuffersize){
        -: 3635:
    #####: 3636:	tsize_t stride=0;
    #####: 3637:	tsize_t i=0;
    #####: 3638:	tsize_t j=0;
        -: 3639:	
    #####: 3640:	stride=samplebuffersize/t2p->tiff_samplesperpixel;
    #####: 3641:	for(i=0;i<stride;i++){
    #####: 3642:		for(j=0;j<t2p->tiff_samplesperpixel;j++){
    #####: 3643:			buffer[i*t2p->tiff_samplesperpixel + j] = samplebuffer[i + j*stride];
        -: 3644:		}
        -: 3645:	}
        -: 3646:
    #####: 3647:	return(samplebuffersize);
        -: 3648:}
        -: 3649:
    #####: 3650:tsize_t t2p_sample_realize_palette(T2P* t2p, unsigned char* buffer){
        -: 3651:
    #####: 3652:	uint32 sample_count=0;
    #####: 3653:	uint16 component_count=0;
    #####: 3654:	uint32 palette_offset=0;
    #####: 3655:	uint32 sample_offset=0;
    #####: 3656:	uint32 i=0;
    #####: 3657:	uint32 j=0;
    #####: 3658:	sample_count=t2p->tiff_width*t2p->tiff_length;
    #####: 3659:	component_count=t2p->tiff_samplesperpixel;
    #####: 3660:        if( sample_count * component_count > t2p->tiff_datasize )
        -: 3661:        {
    #####: 3662:            TIFFError(TIFF2PDF_MODULE,  "Error: sample_count * component_count > t2p->tiff_datasize");
    #####: 3663:            t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3664:            return 1;
        -: 3665:        }
        -: 3666:	
    #####: 3667:	for(i=sample_count;i>0;i--){
    #####: 3668:		palette_offset=buffer[i-1] * component_count;
    #####: 3669:		sample_offset= (i-1) * component_count;
    #####: 3670:		for(j=0;j<component_count;j++){
    #####: 3671:			buffer[sample_offset+j]=t2p->pdf_palette[palette_offset+j];
        -: 3672:		}
        -: 3673:	}
        -: 3674:
    #####: 3675:	return(0);
        -: 3676:}
        -: 3677:
        -: 3678:/*
        -: 3679:	This functions converts in place a buffer of ABGR interleaved data
        -: 3680:	into RGB interleaved data, discarding A.
        -: 3681:*/
        -: 3682:
    #####: 3683:tsize_t t2p_sample_abgr_to_rgb(tdata_t data, uint32 samplecount)
        -: 3684:{
    #####: 3685:	uint32 i=0;
    #####: 3686:	uint32 sample=0;
        -: 3687:	
    #####: 3688:	for(i=0;i<samplecount;i++){
    #####: 3689:		sample=((uint32*)data)[i];
    #####: 3690:		((char*)data)[i*3]= (char) (sample & 0xff);
    #####: 3691:		((char*)data)[i*3+1]= (char) ((sample>>8) & 0xff);
    #####: 3692:		((char*)data)[i*3+2]= (char) ((sample>>16) & 0xff);
        -: 3693:	}
        -: 3694:
    #####: 3695:	return(i*3);
        -: 3696:}
        -: 3697:
        -: 3698:/*
        -: 3699: * This functions converts in place a buffer of RGBA interleaved data
        -: 3700: * into RGB interleaved data, discarding A.
        -: 3701: */
        -: 3702:
        -: 3703:tsize_t
    #####: 3704:t2p_sample_rgbaa_to_rgb(tdata_t data, uint32 samplecount)
        -: 3705:{
        -: 3706:	uint32 i;
        -: 3707:	
        -: 3708:    /* For the 3 first samples, there is overlapping between souce and
        -: 3709:       destination, so use memmove().
        -: 3710:       See http://bugzilla.maptools.org/show_bug.cgi?id=2577 */
    #####: 3711:    for(i = 0; i < 3 && i < samplecount; i++)
    #####: 3712:        memmove((uint8*)data + i * 3, (uint8*)data + i * 4, 3);
    #####: 3713:	for(; i < samplecount; i++)
    #####: 3714:		memcpy((uint8*)data + i * 3, (uint8*)data + i * 4, 3);
        -: 3715:
    #####: 3716:	return(i * 3);
        -: 3717:}
        -: 3718:
        -: 3719:/*
        -: 3720: * This functions converts in place a buffer of RGBA interleaved data
        -: 3721: * into RGB interleaved data, adding 255-A to each component sample.
        -: 3722: */
        -: 3723:
        -: 3724:tsize_t
    #####: 3725:t2p_sample_rgba_to_rgb(tdata_t data, uint32 samplecount)
        -: 3726:{
    #####: 3727:	uint32 i = 0;
    #####: 3728:	uint32 sample = 0;
    #####: 3729:	uint8 alpha = 0;
        -: 3730:
    #####: 3731:	for (i = 0; i < samplecount; i++) {
    #####: 3732:		sample=((uint32*)data)[i];
    #####: 3733:		alpha=(uint8)((255 - ((sample >> 24) & 0xff)));
    #####: 3734:		((uint8 *)data)[i * 3] = (uint8) ((sample >> 16) & 0xff) + alpha;
    #####: 3735:		((uint8 *)data)[i * 3 + 1] = (uint8) ((sample >> 8) & 0xff) + alpha;
    #####: 3736:		((uint8 *)data)[i * 3 + 2] = (uint8) (sample & 0xff) + alpha;
        -: 3737:	}
        -: 3738:
    #####: 3739:	return (i * 3);
        -: 3740:}
        -: 3741:
        -: 3742:/*
        -: 3743:	This function converts the a and b samples of Lab data from signed
        -: 3744:	to unsigned.
        -: 3745:*/
        -: 3746:
    #####: 3747:tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t buffer, uint32 samplecount){
        -: 3748:
    #####: 3749:	uint32 i=0;
        -: 3750:
    #####: 3751:	for(i=0;i<samplecount;i++){
    #####: 3752:		if( (((unsigned char*)buffer)[(i*3)+1] & 0x80) !=0){
    #####: 3753:			((unsigned char*)buffer)[(i*3)+1] =
    #####: 3754:				(unsigned char)(0x80 + ((char*)buffer)[(i*3)+1]);
        -: 3755:		} else {
    #####: 3756:			((unsigned char*)buffer)[(i*3)+1] |= 0x80;
        -: 3757:		}
    #####: 3758:		if( (((unsigned char*)buffer)[(i*3)+2] & 0x80) !=0){
    #####: 3759:			((unsigned char*)buffer)[(i*3)+2] =
    #####: 3760:				(unsigned char)(0x80 + ((char*)buffer)[(i*3)+2]);
        -: 3761:		} else {
    #####: 3762:			((unsigned char*)buffer)[(i*3)+2] |= 0x80;
        -: 3763:		}
        -: 3764:	}
        -: 3765:
    #####: 3766:	return(samplecount*3);
        -: 3767:}
        -: 3768:
        -: 3769:/* 
        -: 3770:	This function writes the PDF header to output.
        -: 3771:*/
        -: 3772:
    #####: 3773:tsize_t t2p_write_pdf_header(T2P* t2p, TIFF* output){
        -: 3774:
    #####: 3775:	tsize_t written=0;
    #####: 3776:	char buffer[16];
    #####: 3777:	int buflen=0;
        -: 3778:	
    #####: 3779:	buflen = snprintf(buffer, sizeof(buffer), "%%PDF-%u.%u ",
    #####: 3780:			  t2p->pdf_majorversion&0xff,
    #####: 3781:			  t2p->pdf_minorversion&0xff);
    #####: 3782:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 3783:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 3784:	written += t2pWriteFile(output, (tdata_t)"\n%\342\343\317\323\n", 7);
        -: 3785:
    #####: 3786:	return(written);
        -: 3787:}
        -: 3788:
        -: 3789:/*
        -: 3790:	This function writes the beginning of a PDF object to output.
        -: 3791:*/
        -: 3792:
    #####: 3793:tsize_t t2p_write_pdf_obj_start(uint32 number, TIFF* output){
        -: 3794:
    #####: 3795:	tsize_t written=0;
    #####: 3796:	char buffer[32];
    #####: 3797:	int buflen=0;
        -: 3798:
    #####: 3799:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)number);
    #####: 3800:	check_snprintf_ret((T2P*)NULL, buflen, buffer);
    #####: 3801:	written += t2pWriteFile(output, (tdata_t) buffer, buflen );
    #####: 3802:	written += t2pWriteFile(output, (tdata_t) " 0 obj\n", 7);
        -: 3803:
    #####: 3804:	return(written);
        -: 3805:}
        -: 3806:
        -: 3807:/*
        -: 3808:	This function writes the end of a PDF object to output.
        -: 3809:*/
        -: 3810:
    #####: 3811:tsize_t t2p_write_pdf_obj_end(TIFF* output){
        -: 3812:
    #####: 3813:	tsize_t written=0;
        -: 3814:
    #####: 3815:	written += t2pWriteFile(output, (tdata_t) "endobj\n", 7);
        -: 3816:
    #####: 3817:	return(written);
        -: 3818:}
        -: 3819:
        -: 3820:/*
        -: 3821:	This function writes a PDF name object to output.
        -: 3822:*/
        -: 3823:
    #####: 3824:tsize_t t2p_write_pdf_name(unsigned char* name, TIFF* output){
        -: 3825:
    #####: 3826:	tsize_t written=0;
    #####: 3827:	uint32 i=0;
    #####: 3828:	char buffer[64];
    #####: 3829:	uint16 nextchar=0;
    #####: 3830:	size_t namelen=0;
        -: 3831:	
    #####: 3832:	namelen = strlen((char *)name);
    #####: 3833:	if (namelen>126) {
    #####: 3834:		namelen=126;
        -: 3835:	}
    #####: 3836:	written += t2pWriteFile(output, (tdata_t) "/", 1);
    #####: 3837:	for (i=0;i<namelen;i++){
    #####: 3838:		if ( ((unsigned char)name[i]) < 0x21){
    #####: 3839:			snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3840:			buffer[sizeof(buffer) - 1] = '\0';
    #####: 3841:			written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3842:			nextchar=1;
        -: 3843:		}
    #####: 3844:		if ( ((unsigned char)name[i]) > 0x7E){
    #####: 3845:			snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3846:			buffer[sizeof(buffer) - 1] = '\0';
    #####: 3847:			written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3848:			nextchar=1;
        -: 3849:		}
    #####: 3850:		if (nextchar==0){
    #####: 3851:			switch (name[i]){
    #####: 3852:				case 0x23:
    #####: 3853:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3854:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3855:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3856:					break;
    #####: 3857:				case 0x25:
    #####: 3858:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3859:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3860:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3861:					break;
    #####: 3862:				case 0x28:
    #####: 3863:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3864:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3865:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3866:					break;
    #####: 3867:				case 0x29:
    #####: 3868:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3869:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3870:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3871:					break;
    #####: 3872:				case 0x2F:
    #####: 3873:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3874:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3875:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3876:					break;
    #####: 3877:				case 0x3C:
    #####: 3878:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3879:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3880:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3881:					break;
    #####: 3882:				case 0x3E:
    #####: 3883:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3884:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3885:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3886:					break;
    #####: 3887:				case 0x5B:
    #####: 3888:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3889:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3890:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3891:					break;
    #####: 3892:				case 0x5D:
    #####: 3893:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3894:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3895:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3896:					break;
    #####: 3897:				case 0x7B:
    #####: 3898:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3899:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3900:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3901:					break;
    #####: 3902:				case 0x7D:
    #####: 3903:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3904:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3905:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3906:					break;
    #####: 3907:				default:
    #####: 3908:					written += t2pWriteFile(output, (tdata_t) &name[i], 1);
        -: 3909:			}
    #####: 3910:		}
    #####: 3911:		nextchar=0;
        -: 3912:	}
    #####: 3913:	written += t2pWriteFile(output, (tdata_t) " ", 1);
        -: 3914:
    #####: 3915:	return(written);
        -: 3916:}
        -: 3917:
        -: 3918:/*
        -: 3919: * This function writes a PDF string object to output.
        -: 3920: */
        -: 3921:	
    #####: 3922:tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output)
        -: 3923:{
    #####: 3924:	tsize_t written = 0;
    #####: 3925:	uint32 i = 0;
    #####: 3926:	char buffer[64];
    #####: 3927:	size_t len = 0;
        -: 3928:	
    #####: 3929:	len = strlen(pdfstr);
    #####: 3930:	written += t2pWriteFile(output, (tdata_t) "(", 1);
    #####: 3931:	for (i=0; i<len; i++) {
    #####: 3932:		if((pdfstr[i]&0x80) || (pdfstr[i]==127) || (pdfstr[i]<32)){
    #####: 3933:			snprintf(buffer, sizeof(buffer), "\\%.3o", ((unsigned char)pdfstr[i]));
    #####: 3934:			written += t2pWriteFile(output, (tdata_t)buffer, 4);
        -: 3935:		} else {
    #####: 3936:			switch (pdfstr[i]){
    #####: 3937:				case 0x08:
    #####: 3938:					written += t2pWriteFile(output, (tdata_t) "\\b", 2);
    #####: 3939:					break;
    #####: 3940:				case 0x09:
    #####: 3941:					written += t2pWriteFile(output, (tdata_t) "\\t", 2);
    #####: 3942:					break;
    #####: 3943:				case 0x0A:
    #####: 3944:					written += t2pWriteFile(output, (tdata_t) "\\n", 2);
    #####: 3945:					break;
    #####: 3946:				case 0x0C:
    #####: 3947:					written += t2pWriteFile(output, (tdata_t) "\\f", 2);
    #####: 3948:					break;
    #####: 3949:				case 0x0D:
    #####: 3950:					written += t2pWriteFile(output, (tdata_t) "\\r", 2);
    #####: 3951:					break;
    #####: 3952:				case 0x28:
    #####: 3953:					written += t2pWriteFile(output, (tdata_t) "\\(", 2);
    #####: 3954:					break;
    #####: 3955:				case 0x29:
    #####: 3956:					written += t2pWriteFile(output, (tdata_t) "\\)", 2);
    #####: 3957:					break;
    #####: 3958:				case 0x5C:
    #####: 3959:					written += t2pWriteFile(output, (tdata_t) "\\\\", 2);
    #####: 3960:					break;
    #####: 3961:				default:
    #####: 3962:					written += t2pWriteFile(output, (tdata_t) &pdfstr[i], 1);
        -: 3963:			}
        -: 3964:		}
        -: 3965:	}
    #####: 3966:	written += t2pWriteFile(output, (tdata_t) ") ", 1);
        -: 3967:
    #####: 3968:	return(written);
        -: 3969:}
        -: 3970:
        -: 3971:
        -: 3972:/*
        -: 3973:	This function writes a buffer of data to output.
        -: 3974:*/
        -: 3975:
    #####: 3976:tsize_t t2p_write_pdf_stream(tdata_t buffer, tsize_t len, TIFF* output){
        -: 3977:
    #####: 3978:	tsize_t written=0;
        -: 3979:
    #####: 3980:	written += t2pWriteFile(output, (tdata_t) buffer, len);
        -: 3981:
    #####: 3982:	return(written);
        -: 3983:}
        -: 3984:
        -: 3985:/*
        -: 3986:	This functions writes the beginning of a PDF stream to output.
        -: 3987:*/
        -: 3988:
    #####: 3989:tsize_t t2p_write_pdf_stream_start(TIFF* output){
        -: 3990:
    #####: 3991:	tsize_t written=0;
        -: 3992:
    #####: 3993:	written += t2pWriteFile(output, (tdata_t) "stream\n", 7);
        -: 3994:
    #####: 3995:	return(written);
        -: 3996:}
        -: 3997:
        -: 3998:/*
        -: 3999:	This function writes the end of a PDF stream to output. 
        -: 4000:*/
        -: 4001:
    #####: 4002:tsize_t t2p_write_pdf_stream_end(TIFF* output){
        -: 4003:
    #####: 4004:	tsize_t written=0;
        -: 4005:
    #####: 4006:	written += t2pWriteFile(output, (tdata_t) "\nendstream\n", 11);
        -: 4007:
    #####: 4008:	return(written);
        -: 4009:}
        -: 4010:
        -: 4011:/*
        -: 4012:	This function writes a stream dictionary for a PDF stream to output.
        -: 4013:*/
        -: 4014:
    #####: 4015:tsize_t t2p_write_pdf_stream_dict(tsize_t len, uint32 number, TIFF* output){
        -: 4016:	
    #####: 4017:	tsize_t written=0;
    #####: 4018:	char buffer[32];
    #####: 4019:	int buflen=0;
        -: 4020:	
    #####: 4021:	written += t2pWriteFile(output, (tdata_t) "/Length ", 8);
    #####: 4022:	if(len!=0){
    #####: 4023:		written += t2p_write_pdf_stream_length(len, output);
        -: 4024:	} else {
    #####: 4025:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)number);
    #####: 4026:		check_snprintf_ret((T2P*)NULL, buflen, buffer);
    #####: 4027:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4028:		written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
        -: 4029:	}
        -: 4030:	
    #####: 4031:	return(written);
        -: 4032:}
        -: 4033:
        -: 4034:/*
        -: 4035:	This functions writes the beginning of a PDF stream dictionary to output.
        -: 4036:*/
        -: 4037:
    #####: 4038:tsize_t t2p_write_pdf_stream_dict_start(TIFF* output){
        -: 4039:
    #####: 4040:	tsize_t written=0;
        -: 4041:
    #####: 4042:	written += t2pWriteFile(output, (tdata_t) "<< \n", 4);
        -: 4043:
    #####: 4044:	return(written);
        -: 4045:}
        -: 4046:
        -: 4047:/*
        -: 4048:	This function writes the end of a PDF stream dictionary to output. 
        -: 4049:*/
        -: 4050:
    #####: 4051:tsize_t t2p_write_pdf_stream_dict_end(TIFF* output){
        -: 4052:
    #####: 4053:	tsize_t written=0;
        -: 4054:
    #####: 4055:	written += t2pWriteFile(output, (tdata_t) " >>\n", 4);
        -: 4056:
    #####: 4057:	return(written);
        -: 4058:}
        -: 4059:
        -: 4060:/*
        -: 4061:	This function writes a number to output.
        -: 4062:*/
        -: 4063:
    #####: 4064:tsize_t t2p_write_pdf_stream_length(tsize_t len, TIFF* output){
        -: 4065:
    #####: 4066:	tsize_t written=0;
    #####: 4067:	char buffer[32];
    #####: 4068:	int buflen=0;
        -: 4069:
    #####: 4070:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)len);
    #####: 4071:	check_snprintf_ret((T2P*)NULL, buflen, buffer);
    #####: 4072:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4073:	written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4074:
    #####: 4075:	return(written);
        -: 4076:}
        -: 4077:
        -: 4078:/*
        -: 4079: * This function writes the PDF Catalog structure to output.
        -: 4080: */
        -: 4081:
    #####: 4082:tsize_t t2p_write_pdf_catalog(T2P* t2p, TIFF* output)
        -: 4083:{
    #####: 4084:	tsize_t written = 0;
    #####: 4085:	char buffer[32];
    #####: 4086:	int buflen = 0;
        -: 4087:
    #####: 4088:	written += t2pWriteFile(output, 
        -: 4089:		(tdata_t)"<< \n/Type /Catalog \n/Pages ", 
        -: 4090:		27);
    #####: 4091:	buflen = snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_pages);
    #####: 4092:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4093:	written += t2pWriteFile(output, (tdata_t) buffer,
    #####: 4094:				TIFFmin((size_t)buflen, sizeof(buffer) - 1));
    #####: 4095:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
    #####: 4096:	if(t2p->pdf_fitwindow){
    #####: 4097:		written += t2pWriteFile(output, 
        -: 4098:			(tdata_t) "/ViewerPreferences <</FitWindow true>>\n", 
        -: 4099:			39);
        -: 4100:	}
    #####: 4101:	written += t2pWriteFile(output, (tdata_t)">>\n", 3);
        -: 4102:
    #####: 4103:	return(written);
        -: 4104:}
        -: 4105:
        -: 4106:/*
        -: 4107:	This function writes the PDF Info structure to output.
        -: 4108:*/
        -: 4109:
    #####: 4110:tsize_t t2p_write_pdf_info(T2P* t2p, TIFF* input, TIFF* output)
        -: 4111:{
    #####: 4112:	tsize_t written = 0;
    #####: 4113:	char* info;
    #####: 4114:	char buffer[512];
        -: 4115:
    #####: 4116:	if(t2p->pdf_datetime[0] == '\0')
    #####: 4117:		t2p_pdf_tifftime(t2p, input);
    #####: 4118:	if (strlen(t2p->pdf_datetime) > 0) {
    #####: 4119:		written += t2pWriteFile(output, (tdata_t) "<< \n/CreationDate ", 18);
    #####: 4120:		written += t2p_write_pdf_string(t2p->pdf_datetime, output);
    #####: 4121:		written += t2pWriteFile(output, (tdata_t) "\n/ModDate ", 10);
    #####: 4122:		written += t2p_write_pdf_string(t2p->pdf_datetime, output);
        -: 4123:	}
    #####: 4124:	written += t2pWriteFile(output, (tdata_t) "\n/Producer ", 11);
    #####: 4125:	snprintf(buffer, sizeof(buffer), "libtiff / tiff2pdf - %d", TIFFLIB_VERSION);
    #####: 4126:	written += t2p_write_pdf_string(buffer, output);
    #####: 4127:	written += t2pWriteFile(output, (tdata_t) "\n", 1);
    #####: 4128:	if (t2p->pdf_creator[0] != '\0') {
    #####: 4129:		written += t2pWriteFile(output, (tdata_t) "/Creator ", 9);
    #####: 4130:		written += t2p_write_pdf_string(t2p->pdf_creator, output);
    #####: 4131:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4132:	} else {
    #####: 4133:		if (TIFFGetField(input, TIFFTAG_SOFTWARE, &info) != 0 && info) {
    #####: 4134:			if(strlen(info) >= sizeof(t2p->pdf_creator))
    #####: 4135:				info[sizeof(t2p->pdf_creator) - 1] = '\0';
    #####: 4136:			written += t2pWriteFile(output, (tdata_t) "/Creator ", 9);
    #####: 4137:			written += t2p_write_pdf_string(info, output);
    #####: 4138:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4139:		}
        -: 4140:	}
    #####: 4141:	if (t2p->pdf_author[0] != '\0') {
    #####: 4142:		written += t2pWriteFile(output, (tdata_t) "/Author ", 8);
    #####: 4143:		written += t2p_write_pdf_string(t2p->pdf_author, output);
    #####: 4144:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4145:	} else {
    #####: 4146:		if ((TIFFGetField(input, TIFFTAG_ARTIST, &info) != 0
    #####: 4147:		     || TIFFGetField(input, TIFFTAG_COPYRIGHT, &info) != 0)
    #####: 4148:		    && info) {
    #####: 4149:			if (strlen(info) >= sizeof(t2p->pdf_author))
    #####: 4150:				info[sizeof(t2p->pdf_author) - 1] = '\0';
    #####: 4151:			written += t2pWriteFile(output, (tdata_t) "/Author ", 8);
    #####: 4152:			written += t2p_write_pdf_string(info, output);
    #####: 4153:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4154:		}
        -: 4155:	}
    #####: 4156:	if (t2p->pdf_title[0] != '\0') {
    #####: 4157:		written += t2pWriteFile(output, (tdata_t) "/Title ", 7);
    #####: 4158:		written += t2p_write_pdf_string(t2p->pdf_title, output);
    #####: 4159:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4160:	} else {
    #####: 4161:		if (TIFFGetField(input, TIFFTAG_DOCUMENTNAME, &info) != 0){
    #####: 4162:			if(strlen(info) > 511) {
    #####: 4163:				info[512] = '\0';
        -: 4164:			}
    #####: 4165:			written += t2pWriteFile(output, (tdata_t) "/Title ", 7);
    #####: 4166:			written += t2p_write_pdf_string(info, output);
    #####: 4167:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4168:		}
        -: 4169:	}
    #####: 4170:	if (t2p->pdf_subject[0] != '\0') {
    #####: 4171:		written += t2pWriteFile(output, (tdata_t) "/Subject ", 9);
    #####: 4172:		written += t2p_write_pdf_string(t2p->pdf_subject, output);
    #####: 4173:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4174:	} else {
    #####: 4175:		if (TIFFGetField(input, TIFFTAG_IMAGEDESCRIPTION, &info) != 0 && info) {
    #####: 4176:			if (strlen(info) >= sizeof(t2p->pdf_subject))
    #####: 4177:				info[sizeof(t2p->pdf_subject) - 1] = '\0';
    #####: 4178:			written += t2pWriteFile(output, (tdata_t) "/Subject ", 9);
    #####: 4179:			written += t2p_write_pdf_string(info, output);
    #####: 4180:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4181:		}
        -: 4182:	}
    #####: 4183:	if (t2p->pdf_keywords[0] != '\0') {
    #####: 4184:		written += t2pWriteFile(output, (tdata_t) "/Keywords ", 10);
    #####: 4185:		written += t2p_write_pdf_string(t2p->pdf_keywords, output);
    #####: 4186:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4187:	}
    #####: 4188:	written += t2pWriteFile(output, (tdata_t) ">> \n", 4);
        -: 4189:
    #####: 4190:	return(written);
        -: 4191:}
        -: 4192:
        -: 4193:/*
        -: 4194: * This function fills a string of a T2P struct with the current time as a PDF
        -: 4195: * date string, it is called by t2p_pdf_tifftime.
        -: 4196: */
        -: 4197:
    #####: 4198:void t2p_pdf_currenttime(T2P* t2p)
        -: 4199:{
        -: 4200:	struct tm* currenttime;
    #####: 4201:	time_t timenow;
        -: 4202:
    #####: 4203:	if (time(&timenow) == (time_t) -1) {
    #####: 4204:		TIFFError(TIFF2PDF_MODULE,
    #####: 4205:			  "Can't get the current time: %s", strerror(errno));
    #####: 4206:		timenow = (time_t) 0;
        -: 4207:	}
        -: 4208:
    #####: 4209:	currenttime = localtime(&timenow);
    #####: 4210:	snprintf(t2p->pdf_datetime, sizeof(t2p->pdf_datetime),
        -: 4211:		 "D:%.4d%.2d%.2d%.2d%.2d%.2d",
    #####: 4212:		 (currenttime->tm_year + 1900) % 65536,
    #####: 4213:		 (currenttime->tm_mon + 1) % 256,
    #####: 4214:		 (currenttime->tm_mday) % 256,
    #####: 4215:		 (currenttime->tm_hour) % 256,
    #####: 4216:		 (currenttime->tm_min) % 256,
    #####: 4217:		 (currenttime->tm_sec) % 256);
        -: 4218:
    #####: 4219:	return;
        -: 4220:}
        -: 4221:
        -: 4222:/*
        -: 4223: * This function fills a string of a T2P struct with the date and time of a
        -: 4224: * TIFF file if it exists or the current time as a PDF date string.
        -: 4225: */
        -: 4226:
    #####: 4227:void t2p_pdf_tifftime(T2P* t2p, TIFF* input)
        -: 4228:{
    #####: 4229:	char* datetime;
        -: 4230:
    #####: 4231:	if (TIFFGetField(input, TIFFTAG_DATETIME, &datetime) != 0
    #####: 4232:	    && (strlen(datetime) >= 19) ){
    #####: 4233:		t2p->pdf_datetime[0]='D';
    #####: 4234:		t2p->pdf_datetime[1]=':';
    #####: 4235:		t2p->pdf_datetime[2]=datetime[0];
    #####: 4236:		t2p->pdf_datetime[3]=datetime[1];
    #####: 4237:		t2p->pdf_datetime[4]=datetime[2];
    #####: 4238:		t2p->pdf_datetime[5]=datetime[3];
    #####: 4239:		t2p->pdf_datetime[6]=datetime[5];
    #####: 4240:		t2p->pdf_datetime[7]=datetime[6];
    #####: 4241:		t2p->pdf_datetime[8]=datetime[8];
    #####: 4242:		t2p->pdf_datetime[9]=datetime[9];
    #####: 4243:		t2p->pdf_datetime[10]=datetime[11];
    #####: 4244:		t2p->pdf_datetime[11]=datetime[12];
    #####: 4245:		t2p->pdf_datetime[12]=datetime[14];
    #####: 4246:		t2p->pdf_datetime[13]=datetime[15];
    #####: 4247:		t2p->pdf_datetime[14]=datetime[17];
    #####: 4248:		t2p->pdf_datetime[15]=datetime[18];
    #####: 4249:		t2p->pdf_datetime[16] = '\0';
        -: 4250:	} else {
    #####: 4251:		t2p_pdf_currenttime(t2p);
        -: 4252:	}
        -: 4253:
    #####: 4254:	return;
        -: 4255:}
        -: 4256:
        -: 4257:/*
        -: 4258: * This function writes a PDF Pages Tree structure to output.
        -: 4259: */
        -: 4260:
    #####: 4261:tsize_t t2p_write_pdf_pages(T2P* t2p, TIFF* output)
        -: 4262:{
    #####: 4263:	tsize_t written=0;
    #####: 4264:	tdir_t i=0;
    #####: 4265:	char buffer[32];
    #####: 4266:	int buflen=0;
        -: 4267:
    #####: 4268:	int page=0;
    #####: 4269:	written += t2pWriteFile(output,
        -: 4270:		(tdata_t) "<< \n/Type /Pages \n/Kids [ ", 26);
    #####: 4271:	page = t2p->pdf_pages+1;
    #####: 4272:	for (i=0;i<t2p->tiff_pagecount;i++){
    #####: 4273:		buflen=snprintf(buffer, sizeof(buffer), "%d", page);
    #####: 4274:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4275:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4276:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4277:		if ( ((i+1)%8)==0 ) {
    #####: 4278:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4279:		}
    #####: 4280:		page +=3;
    #####: 4281:		page += t2p->tiff_pages[i].page_extra;
    #####: 4282:		if(t2p->tiff_pages[i].page_tilecount>0){
    #####: 4283:			page += (2 * t2p->tiff_pages[i].page_tilecount);
        -: 4284:		} else {
    #####: 4285:			page +=2;
        -: 4286:		}
        -: 4287:	}
    #####: 4288:	written += t2pWriteFile(output, (tdata_t) "] \n/Count ", 10);
    #####: 4289:	buflen=snprintf(buffer, sizeof(buffer), "%d", t2p->tiff_pagecount);
    #####: 4290:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4291:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4292:	written += t2pWriteFile(output, (tdata_t) " \n>> \n", 6);
        -: 4293:
    #####: 4294:	return(written);
        -: 4295:}
        -: 4296:
        -: 4297:/*
        -: 4298:	This function writes a PDF Page structure to output.
        -: 4299:*/
        -: 4300:
    #####: 4301:tsize_t t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output){
        -: 4302:
    #####: 4303:	unsigned int i=0;
    #####: 4304:	tsize_t written=0;
    #####: 4305:	char buffer[256];
    #####: 4306:	int buflen=0;
        -: 4307:
    #####: 4308:	written += t2pWriteFile(output, (tdata_t) "<<\n/Type /Page \n/Parent ", 24);
    #####: 4309:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_pages);
    #####: 4310:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4311:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4312:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
    #####: 4313:	written += t2pWriteFile(output, (tdata_t) "/MediaBox [", 11); 
    #####: 4314:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.x1);
    #####: 4315:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4316:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4317:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
    #####: 4318:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.y1);
    #####: 4319:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4320:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4321:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
    #####: 4322:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.x2);
    #####: 4323:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4324:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4325:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
    #####: 4326:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.y2);
    #####: 4327:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4328:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4329:	written += t2pWriteFile(output, (tdata_t) "] \n", 3); 
    #####: 4330:	written += t2pWriteFile(output, (tdata_t) "/Contents ", 10);
    #####: 4331:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(object + 1));
    #####: 4332:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4333:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4334:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
    #####: 4335:	written += t2pWriteFile(output, (tdata_t) "/Resources << \n", 15);
    #####: 4336:	if( t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount != 0 ){
    #####: 4337:		written += t2pWriteFile(output, (tdata_t) "/XObject <<\n", 12);
    #####: 4338:		for(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i++){
    #####: 4339:			written += t2pWriteFile(output, (tdata_t) "/Im", 3);
    #####: 4340:			buflen = snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
    #####: 4341:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4342:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4343:			written += t2pWriteFile(output, (tdata_t) "_", 1);
    #####: 4344:			buflen = snprintf(buffer, sizeof(buffer), "%u", i+1);
    #####: 4345:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4346:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4347:			written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4348:			buflen = snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4349:				(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); 
    #####: 4350:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4351:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4352:			written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4353:			if(i%4==3){
    #####: 4354:				written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4355:			}
        -: 4356:		}
    #####: 4357:		written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 4358:	} else {
    #####: 4359:			written += t2pWriteFile(output, (tdata_t) "/XObject <<\n", 12);
    #####: 4360:			written += t2pWriteFile(output, (tdata_t) "/Im", 3);
    #####: 4361:			buflen = snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
    #####: 4362:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4363:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4364:			written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4365:			buflen = snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4366:				(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); 
    #####: 4367:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4368:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4369:			written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4370:		written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 4371:	}
    #####: 4372:	if(t2p->tiff_transferfunctioncount != 0) {
    #####: 4373:		written += t2pWriteFile(output, (tdata_t) "/ExtGState <<", 13);
    #####: 4374:		t2pWriteFile(output, (tdata_t) "/GS1 ", 5);
    #####: 4375:		buflen = snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4376:			(unsigned long)(object + 3)); 
    #####: 4377:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4378:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4379:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4380:		written += t2pWriteFile(output, (tdata_t) ">> \n", 4);
        -: 4381:	}
    #####: 4382:	written += t2pWriteFile(output, (tdata_t) "/ProcSet [ ", 11);
    #####: 4383:	if(t2p->pdf_colorspace & T2P_CS_BILEVEL 
    #####: 4384:		|| t2p->pdf_colorspace & T2P_CS_GRAY
        -: 4385:		){
    #####: 4386:		written += t2pWriteFile(output, (tdata_t) "/ImageB ", 8);
        -: 4387:	} else {
    #####: 4388:		written += t2pWriteFile(output, (tdata_t) "/ImageC ", 8);
    #####: 4389:		if(t2p->pdf_colorspace & T2P_CS_PALETTE){
    #####: 4390:			written += t2pWriteFile(output, (tdata_t) "/ImageI ", 8);
        -: 4391:		}
        -: 4392:	}
    #####: 4393:	written += t2pWriteFile(output, (tdata_t) "]\n>>\n>>\n", 8);
        -: 4394:
    #####: 4395:	return(written);
        -: 4396:}
        -: 4397:
        -: 4398:/*
        -: 4399:	This function composes the page size and image and tile locations on a page.
        -: 4400:*/
        -: 4401:
    #####: 4402:void t2p_compose_pdf_page(T2P* t2p){
        -: 4403:
    #####: 4404:	uint32 i=0;
    #####: 4405:	uint32 i2=0;
    #####: 4406:	T2P_TILE* tiles=NULL;
    #####: 4407:	T2P_BOX* boxp=NULL;
    #####: 4408:	uint32 tilecountx=0;
    #####: 4409:	uint32 tilecounty=0;
    #####: 4410:	uint32 tilewidth=0;
    #####: 4411:	uint32 tilelength=0;
    #####: 4412:	int istiled=0;
    #####: 4413:	float f=0;
    #####: 4414:	float width_ratio=0;
    #####: 4415:	float length_ratio=0;
        -: 4416:	
    #####: 4417:	t2p->pdf_xres = t2p->tiff_xres;
    #####: 4418:	t2p->pdf_yres = t2p->tiff_yres;
    #####: 4419:	if(t2p->pdf_overrideres) {
    #####: 4420:		t2p->pdf_xres = t2p->pdf_defaultxres;
    #####: 4421:		t2p->pdf_yres = t2p->pdf_defaultyres;
        -: 4422:	}
    #####: 4423:	if(t2p->pdf_xres == 0.0)
    #####: 4424:		t2p->pdf_xres = t2p->pdf_defaultxres;
    #####: 4425:	if(t2p->pdf_yres == 0.0)
    #####: 4426:		t2p->pdf_yres = t2p->pdf_defaultyres;
    #####: 4427:	if (t2p->pdf_image_fillpage) {
    #####: 4428:		width_ratio = t2p->pdf_defaultpagewidth/t2p->tiff_width;
    #####: 4429:		length_ratio = t2p->pdf_defaultpagelength/t2p->tiff_length;
    #####: 4430:		if (width_ratio < length_ratio ) {
    #####: 4431:			t2p->pdf_imagewidth = t2p->pdf_defaultpagewidth;
    #####: 4432:			t2p->pdf_imagelength = t2p->tiff_length * width_ratio;
        -: 4433:		} else {
    #####: 4434:			t2p->pdf_imagewidth = t2p->tiff_width * length_ratio;
    #####: 4435:			t2p->pdf_imagelength = t2p->pdf_defaultpagelength;
        -: 4436:		}
    #####: 4437:	} else if (t2p->tiff_resunit != RESUNIT_CENTIMETER	/* RESUNIT_NONE and */
    #####: 4438:		&& t2p->tiff_resunit != RESUNIT_INCH) {	/* other cases */
    #####: 4439:		t2p->pdf_imagewidth = ((float)(t2p->tiff_width))/t2p->pdf_xres;
    #####: 4440:		t2p->pdf_imagelength = ((float)(t2p->tiff_length))/t2p->pdf_yres;
        -: 4441:	} else {
    #####: 4442:		t2p->pdf_imagewidth = 
    #####: 4443:			((float)(t2p->tiff_width))*PS_UNIT_SIZE/t2p->pdf_xres;
    #####: 4444:		t2p->pdf_imagelength = 
    #####: 4445:			((float)(t2p->tiff_length))*PS_UNIT_SIZE/t2p->pdf_yres;
        -: 4446:	}
    #####: 4447:	if(t2p->pdf_overridepagesize != 0) {
    #####: 4448:		t2p->pdf_pagewidth = t2p->pdf_defaultpagewidth;
    #####: 4449:		t2p->pdf_pagelength = t2p->pdf_defaultpagelength;
        -: 4450:	} else {
    #####: 4451:		t2p->pdf_pagewidth = t2p->pdf_imagewidth;
    #####: 4452:		t2p->pdf_pagelength = t2p->pdf_imagelength;
        -: 4453:	}
    #####: 4454:	t2p->pdf_mediabox.x1=0.0;
    #####: 4455:	t2p->pdf_mediabox.y1=0.0;
    #####: 4456:	t2p->pdf_mediabox.x2=t2p->pdf_pagewidth;
    #####: 4457:	t2p->pdf_mediabox.y2=t2p->pdf_pagelength;
    #####: 4458:	t2p->pdf_imagebox.x1=0.0;
    #####: 4459:	t2p->pdf_imagebox.y1=0.0;
    #####: 4460:	t2p->pdf_imagebox.x2=t2p->pdf_imagewidth;
    #####: 4461:	t2p->pdf_imagebox.y2=t2p->pdf_imagelength;
    #####: 4462:	if(t2p->pdf_overridepagesize!=0){
    #####: 4463:		t2p->pdf_imagebox.x1+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);
    #####: 4464:		t2p->pdf_imagebox.y1+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);
    #####: 4465:		t2p->pdf_imagebox.x2+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);
    #####: 4466:		t2p->pdf_imagebox.y2+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);
        -: 4467:	}
    #####: 4468:	if(t2p->tiff_orientation > 4){
    #####: 4469:		f=t2p->pdf_mediabox.x2;
    #####: 4470:		t2p->pdf_mediabox.x2=t2p->pdf_mediabox.y2;
    #####: 4471:		t2p->pdf_mediabox.y2=f;
        -: 4472:	}
    #####: 4473:	istiled=((t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount==0) ? 0 : 1;
    #####: 4474:	if(istiled==0){
    #####: 4475:		t2p_compose_pdf_page_orient(&(t2p->pdf_imagebox), t2p->tiff_orientation);
    #####: 4476:		return;
        -: 4477:	} else {
    #####: 4478:		tilewidth=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilewidth;
    #####: 4479:		tilelength=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilelength;
    #####: 4480:		if( tilewidth > INT_MAX ||
    #####: 4481:		    tilelength > INT_MAX ||
    #####: 4482:		    t2p->tiff_width > INT_MAX - tilewidth ||
    #####: 4483:		    t2p->tiff_length > INT_MAX - tilelength )
        -: 4484:		{
    #####: 4485:		    TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 4486:		    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 4487:		    return;
        -: 4488:		}
    #####: 4489:		tilecountx=(t2p->tiff_width + 
    #####: 4490:			tilewidth -1)/ 
        -: 4491:			tilewidth;
    #####: 4492:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecountx=tilecountx;
    #####: 4493:		tilecounty=(t2p->tiff_length + 
    #####: 4494:			tilelength -1)/ 
        -: 4495:			tilelength;
    #####: 4496:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecounty=tilecounty;
    #####: 4497:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilewidth=
    #####: 4498:			t2p->tiff_width % tilewidth;
    #####: 4499:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilelength=
    #####: 4500:			t2p->tiff_length % tilelength;
    #####: 4501:		tiles=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tiles;
    #####: 4502:		for(i2=0;i2<tilecounty-1;i2++){
    #####: 4503:			for(i=0;i<tilecountx-1;i++){
    #####: 4504:				boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4505:				boxp->x1 = 
    #####: 4506:					t2p->pdf_imagebox.x1 
    #####: 4507:					+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4508:					/ (float)t2p->tiff_width);
    #####: 4509:				boxp->x2 = 
    #####: 4510:					t2p->pdf_imagebox.x1 
    #####: 4511:					+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)
    #####: 4512:					/ (float)t2p->tiff_width);
    #####: 4513:				boxp->y1 = 
    #####: 4514:					t2p->pdf_imagebox.y2 
    #####: 4515:					- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)
    #####: 4516:					/ (float)t2p->tiff_length);
    #####: 4517:				boxp->y2 = 
    #####: 4518:					t2p->pdf_imagebox.y2 
    #####: 4519:					- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4520:					/ (float)t2p->tiff_length);
        -: 4521:			}
    #####: 4522:			boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4523:			boxp->x1 = 
    #####: 4524:				t2p->pdf_imagebox.x1 
    #####: 4525:				+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4526:				/ (float)t2p->tiff_width);
    #####: 4527:			boxp->x2 = t2p->pdf_imagebox.x2;
    #####: 4528:			boxp->y1 = 
    #####: 4529:				t2p->pdf_imagebox.y2 
    #####: 4530:				- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)
    #####: 4531:				/ (float)t2p->tiff_length);
    #####: 4532:			boxp->y2 = 
    #####: 4533:				t2p->pdf_imagebox.y2 
    #####: 4534:				- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4535:				/ (float)t2p->tiff_length);
        -: 4536:		}
    #####: 4537:		for(i=0;i<tilecountx-1;i++){
    #####: 4538:			boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4539:			boxp->x1 = 
    #####: 4540:				t2p->pdf_imagebox.x1 
    #####: 4541:				+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4542:				/ (float)t2p->tiff_width);
    #####: 4543:			boxp->x2 = 
    #####: 4544:				t2p->pdf_imagebox.x1 
    #####: 4545:				+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)
    #####: 4546:				/ (float)t2p->tiff_width);
    #####: 4547:			boxp->y1 = t2p->pdf_imagebox.y1;
    #####: 4548:			boxp->y2 = 
    #####: 4549:				t2p->pdf_imagebox.y2 
    #####: 4550:				- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4551:				/ (float)t2p->tiff_length);
        -: 4552:		}
    #####: 4553:		boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4554:		boxp->x1 = 
    #####: 4555:			t2p->pdf_imagebox.x1 
    #####: 4556:			+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4557:			/ (float)t2p->tiff_width);
    #####: 4558:		boxp->x2 = t2p->pdf_imagebox.x2;
    #####: 4559:		boxp->y1 = t2p->pdf_imagebox.y1;
    #####: 4560:		boxp->y2 = 
    #####: 4561:			t2p->pdf_imagebox.y2 
    #####: 4562:			- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4563:			/ (float)t2p->tiff_length);
        -: 4564:	}
    #####: 4565:	if(t2p->tiff_orientation==0 || t2p->tiff_orientation==1){
    #####: 4566:		for(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){
    #####: 4567:			t2p_compose_pdf_page_orient( &(tiles[i].tile_box) , 0);
        -: 4568:		}
    #####: 4569:		return;
        -: 4570:	}
    #####: 4571:	for(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){
    #####: 4572:		boxp=&(tiles[i].tile_box);
    #####: 4573:		boxp->x1 -= t2p->pdf_imagebox.x1;
    #####: 4574:		boxp->x2 -= t2p->pdf_imagebox.x1;
    #####: 4575:		boxp->y1 -= t2p->pdf_imagebox.y1;
    #####: 4576:		boxp->y2 -= t2p->pdf_imagebox.y1;
    #####: 4577:		if(t2p->tiff_orientation==2 || t2p->tiff_orientation==3){
    #####: 4578:			boxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;
    #####: 4579:			boxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;
        -: 4580:		}
    #####: 4581:		if(t2p->tiff_orientation==3 || t2p->tiff_orientation==4){
    #####: 4582:			boxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;
    #####: 4583:			boxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;
        -: 4584:		}
    #####: 4585:		if(t2p->tiff_orientation==8 || t2p->tiff_orientation==5){
    #####: 4586:			boxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;
    #####: 4587:			boxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;
        -: 4588:		}
    #####: 4589:		if(t2p->tiff_orientation==5 || t2p->tiff_orientation==6){
    #####: 4590:			boxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;
    #####: 4591:			boxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;
        -: 4592:		}
    #####: 4593:		if(t2p->tiff_orientation > 4){
    #####: 4594:			f=boxp->x1;
    #####: 4595:			boxp->x1 = boxp->y1;
    #####: 4596:			boxp->y1 = f;
    #####: 4597:			f=boxp->x2;
    #####: 4598:			boxp->x2 = boxp->y2;
    #####: 4599:			boxp->y2 = f; 
    #####: 4600:			t2p_compose_pdf_page_orient_flip(boxp, t2p->tiff_orientation);
        -: 4601:		} else {
    #####: 4602:			t2p_compose_pdf_page_orient(boxp, t2p->tiff_orientation);
        -: 4603:		}
        -: 4604:		
        -: 4605:	}
        -: 4606:
    #####: 4607:	return;
        -: 4608:}
        -: 4609:
    #####: 4610:void t2p_compose_pdf_page_orient(T2P_BOX* boxp, uint16 orientation){
        -: 4611:
        -: 4612:	float m1[9];
    #####: 4613:	float f=0.0;
        -: 4614:	
    #####: 4615:	if( boxp->x1 > boxp->x2){
    #####: 4616:		f=boxp->x1;
    #####: 4617:		boxp->x1=boxp->x2;
    #####: 4618:		boxp->x2 = f;
        -: 4619:	}
    #####: 4620:	if( boxp->y1 > boxp->y2){
    #####: 4621:		f=boxp->y1;
    #####: 4622:		boxp->y1=boxp->y2;
    #####: 4623:		boxp->y2 = f;
        -: 4624:	}
    #####: 4625:	boxp->mat[0]=m1[0]=boxp->x2-boxp->x1;
    #####: 4626:	boxp->mat[1]=m1[1]=0.0;
    #####: 4627:	boxp->mat[2]=m1[2]=0.0;
    #####: 4628:	boxp->mat[3]=m1[3]=0.0;
    #####: 4629:	boxp->mat[4]=m1[4]=boxp->y2-boxp->y1;
    #####: 4630:	boxp->mat[5]=m1[5]=0.0;
    #####: 4631:	boxp->mat[6]=m1[6]=boxp->x1;
    #####: 4632:	boxp->mat[7]=m1[7]=boxp->y1;
    #####: 4633:	boxp->mat[8]=m1[8]=1.0;
    #####: 4634:	switch(orientation){
    #####: 4635:		case 0:
        -: 4636:		case 1:
    #####: 4637:			break;
    #####: 4638:		case 2:
    #####: 4639:			boxp->mat[0]=0.0F-m1[0];
    #####: 4640:			boxp->mat[6]+=m1[0];
    #####: 4641:			break;
    #####: 4642:		case 3:
    #####: 4643:			boxp->mat[0]=0.0F-m1[0];
    #####: 4644:			boxp->mat[4]=0.0F-m1[4];
    #####: 4645:			boxp->mat[6]+=m1[0];
    #####: 4646:			boxp->mat[7]+=m1[4];
    #####: 4647:			break;
    #####: 4648:		case 4:
    #####: 4649:			boxp->mat[4]=0.0F-m1[4];
    #####: 4650:			boxp->mat[7]+=m1[4];
    #####: 4651:			break;
    #####: 4652:		case 5:
    #####: 4653:			boxp->mat[0]=0.0F;
    #####: 4654:			boxp->mat[1]=0.0F-m1[0];
    #####: 4655:			boxp->mat[3]=0.0F-m1[4];
    #####: 4656:			boxp->mat[4]=0.0F;
    #####: 4657:			boxp->mat[6]+=m1[4];
    #####: 4658:			boxp->mat[7]+=m1[0];
    #####: 4659:			break;
    #####: 4660:		case 6:
    #####: 4661:			boxp->mat[0]=0.0F;
    #####: 4662:			boxp->mat[1]=0.0F-m1[0];
    #####: 4663:			boxp->mat[3]=m1[4];
    #####: 4664:			boxp->mat[4]=0.0F;
    #####: 4665:			boxp->mat[7]+=m1[0];
    #####: 4666:			break;
    #####: 4667:		case 7:
    #####: 4668:			boxp->mat[0]=0.0F;
    #####: 4669:			boxp->mat[1]=m1[0];
    #####: 4670:			boxp->mat[3]=m1[4];
    #####: 4671:			boxp->mat[4]=0.0F;
    #####: 4672:			break;
    #####: 4673:		case 8:
    #####: 4674:			boxp->mat[0]=0.0F;
    #####: 4675:			boxp->mat[1]=m1[0];
    #####: 4676:			boxp->mat[3]=0.0F-m1[4];
    #####: 4677:			boxp->mat[4]=0.0F;
    #####: 4678:			boxp->mat[6]+=m1[4];
    #####: 4679:			break;
        -: 4680:	}
        -: 4681:
    #####: 4682:	return;
        -: 4683:}
        -: 4684:
    #####: 4685:void t2p_compose_pdf_page_orient_flip(T2P_BOX* boxp, uint16 orientation){
        -: 4686:
        -: 4687:	float m1[9];
    #####: 4688:	float f=0.0;
        -: 4689:	
    #####: 4690:	if( boxp->x1 > boxp->x2){
    #####: 4691:		f=boxp->x1;
    #####: 4692:		boxp->x1=boxp->x2;
    #####: 4693:		boxp->x2 = f;
        -: 4694:	}
    #####: 4695:	if( boxp->y1 > boxp->y2){
    #####: 4696:		f=boxp->y1;
    #####: 4697:		boxp->y1=boxp->y2;
    #####: 4698:		boxp->y2 = f;
        -: 4699:	}
    #####: 4700:	boxp->mat[0]=m1[0]=boxp->x2-boxp->x1;
    #####: 4701:	boxp->mat[1]=m1[1]=0.0F;
    #####: 4702:	boxp->mat[2]=m1[2]=0.0F;
    #####: 4703:	boxp->mat[3]=m1[3]=0.0F;
    #####: 4704:	boxp->mat[4]=m1[4]=boxp->y2-boxp->y1;
    #####: 4705:	boxp->mat[5]=m1[5]=0.0F;
    #####: 4706:	boxp->mat[6]=m1[6]=boxp->x1;
    #####: 4707:	boxp->mat[7]=m1[7]=boxp->y1;
    #####: 4708:	boxp->mat[8]=m1[8]=1.0F;
    #####: 4709:	switch(orientation){
    #####: 4710:		case 5:
    #####: 4711:			boxp->mat[0]=0.0F;
    #####: 4712:			boxp->mat[1]=0.0F-m1[4];
    #####: 4713:			boxp->mat[3]=0.0F-m1[0];
    #####: 4714:			boxp->mat[4]=0.0F;
    #####: 4715:			boxp->mat[6]+=m1[0];
    #####: 4716:			boxp->mat[7]+=m1[4];
    #####: 4717:			break;
    #####: 4718:		case 6:
    #####: 4719:			boxp->mat[0]=0.0F;
    #####: 4720:			boxp->mat[1]=0.0F-m1[4];
    #####: 4721:			boxp->mat[3]=m1[0];
    #####: 4722:			boxp->mat[4]=0.0F;
    #####: 4723:			boxp->mat[7]+=m1[4];
    #####: 4724:			break;
    #####: 4725:		case 7:
    #####: 4726:			boxp->mat[0]=0.0F;
    #####: 4727:			boxp->mat[1]=m1[4];
    #####: 4728:			boxp->mat[3]=m1[0];
    #####: 4729:			boxp->mat[4]=0.0F;
    #####: 4730:			break;
    #####: 4731:		case 8:
    #####: 4732:			boxp->mat[0]=0.0F;
    #####: 4733:			boxp->mat[1]=m1[4];
    #####: 4734:			boxp->mat[3]=0.0F-m1[0];
    #####: 4735:			boxp->mat[4]=0.0F;
    #####: 4736:			boxp->mat[6]+=m1[0];
    #####: 4737:			break;
        -: 4738:	}
        -: 4739:
    #####: 4740:	return;
        -: 4741:}
        -: 4742:
        -: 4743:/*
        -: 4744:	This function writes a PDF Contents stream to output.
        -: 4745:*/
        -: 4746:
    #####: 4747:tsize_t t2p_write_pdf_page_content_stream(T2P* t2p, TIFF* output){
        -: 4748:
    #####: 4749:	tsize_t written=0;
    #####: 4750:	ttile_t i=0;
    #####: 4751:	char buffer[512];
    #####: 4752:	int buflen=0;
        -: 4753:	T2P_BOX box;
        -: 4754:	
    #####: 4755:	if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount>0){ 
    #####: 4756:		for(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount; i++){
    #####: 4757:			box=t2p->tiff_tiles[t2p->pdf_page].tiles_tiles[i].tile_box;
    #####: 4758:			buflen=snprintf(buffer, sizeof(buffer), 
        -: 4759:				"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d_%ld Do Q\n", 
    #####: 4760:				t2p->tiff_transferfunctioncount?"/GS1 gs ":"",
    #####: 4761:				box.mat[0],
    #####: 4762:				box.mat[1],
    #####: 4763:				box.mat[3],
    #####: 4764:				box.mat[4],
    #####: 4765:				box.mat[6],
    #####: 4766:				box.mat[7],
    #####: 4767:				t2p->pdf_page + 1, 
    #####: 4768:				(long)(i + 1));
    #####: 4769:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4770:			written += t2p_write_pdf_stream(buffer, buflen, output);
        -: 4771:		}
        -: 4772:	} else {
    #####: 4773:		box=t2p->pdf_imagebox;
    #####: 4774:		buflen=snprintf(buffer, sizeof(buffer), 
        -: 4775:			"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d Do Q\n", 
    #####: 4776:			t2p->tiff_transferfunctioncount?"/GS1 gs ":"",
    #####: 4777:			box.mat[0],
    #####: 4778:			box.mat[1],
    #####: 4779:			box.mat[3],
    #####: 4780:			box.mat[4],
    #####: 4781:			box.mat[6],
    #####: 4782:			box.mat[7],
    #####: 4783:			t2p->pdf_page+1);
    #####: 4784:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4785:		written += t2p_write_pdf_stream(buffer, buflen, output);
        -: 4786:	}
        -: 4787:
    #####: 4788:	return(written);
        -: 4789:}
        -: 4790:
        -: 4791:/*
        -: 4792:	This function writes a PDF Image XObject stream dictionary to output. 
        -: 4793:*/
        -: 4794:
    #####: 4795:tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t tile, 
        -: 4796:												T2P* t2p, 
        -: 4797:												TIFF* output){
        -: 4798:
    #####: 4799:	tsize_t written=0;
    #####: 4800:	char buffer[32];
    #####: 4801:	int buflen=0;
        -: 4802:
    #####: 4803:	written += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output); 
    #####: 4804:	written += t2pWriteFile(output, 
        -: 4805:		(tdata_t) "/Type /XObject \n/Subtype /Image \n/Name /Im", 
        -: 4806:		42);
    #####: 4807:	buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
    #####: 4808:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4809:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4810:	if(tile != 0){
    #####: 4811:		written += t2pWriteFile(output, (tdata_t) "_", 1);
    #####: 4812:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)tile);
    #####: 4813:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4814:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 4815:	}
    #####: 4816:	written += t2pWriteFile(output, (tdata_t) "\n/Width ", 8);
    #####: 4817:	if(tile==0){
    #####: 4818:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->tiff_width);
        -: 4819:	} else {
    #####: 4820:		if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){
    #####: 4821:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4822:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
        -: 4823:		} else {
    #####: 4824:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4825:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
        -: 4826:		}
        -: 4827:	}
    #####: 4828:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4829:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4830:	written += t2pWriteFile(output, (tdata_t) "\n/Height ", 9);
    #####: 4831:	if(tile==0){
    #####: 4832:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->tiff_length);
        -: 4833:	} else {
    #####: 4834:		if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){
    #####: 4835:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4836:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
        -: 4837:		} else {
    #####: 4838:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4839:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 4840:		}
        -: 4841:	}
    #####: 4842:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4843:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4844:	written += t2pWriteFile(output, (tdata_t) "\n/BitsPerComponent ", 19);
    #####: 4845:	buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_bitspersample);
    #####: 4846:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4847:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4848:	written += t2pWriteFile(output, (tdata_t) "\n/ColorSpace ", 13);
    #####: 4849:	written += t2p_write_pdf_xobject_cs(t2p, output);
    #####: 4850:	if (t2p->pdf_image_interpolate)
    #####: 4851:		written += t2pWriteFile(output,
        -: 4852:					 (tdata_t) "\n/Interpolate true", 18);
    #####: 4853:	if( (t2p->pdf_switchdecode != 0)
        -: 4854:#ifdef CCITT_SUPPORT
    #####: 4855:		&& ! (t2p->pdf_colorspace & T2P_CS_BILEVEL 
    #####: 4856:		&& t2p->pdf_compression == T2P_COMPRESS_G4)
        -: 4857:#endif
        -: 4858:		){
    #####: 4859:		written += t2p_write_pdf_xobject_decode(t2p, output);
        -: 4860:	}
    #####: 4861:	written += t2p_write_pdf_xobject_stream_filter(tile, t2p, output);
        -: 4862:	
    #####: 4863:	return(written);
        -: 4864:}
        -: 4865:
        -: 4866:/*
        -: 4867: * 	This function writes a PDF Image XObject Colorspace name to output.
        -: 4868: */
        -: 4869:
        -: 4870:
    #####: 4871:tsize_t t2p_write_pdf_xobject_cs(T2P* t2p, TIFF* output){
        -: 4872:
    #####: 4873:	tsize_t written=0;
    #####: 4874:	char buffer[128];
    #####: 4875:	int buflen=0;
        -: 4876:
    #####: 4877:	float X_W=1.0;
    #####: 4878:	float Y_W=1.0;
    #####: 4879:	float Z_W=1.0;
        -: 4880:	
    #####: 4881:	if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){
    #####: 4882:		written += t2p_write_pdf_xobject_icccs(t2p, output);
    #####: 4883:		return(written);
        -: 4884:	}
    #####: 4885:	if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){
    #####: 4886:		written += t2pWriteFile(output, (tdata_t) "[ /Indexed ", 11);
    #####: 4887:		t2p->pdf_colorspace ^= T2P_CS_PALETTE;
    #####: 4888:		written += t2p_write_pdf_xobject_cs(t2p, output);
    #####: 4889:		t2p->pdf_colorspace |= T2P_CS_PALETTE;
    #####: 4890:		buflen=snprintf(buffer, sizeof(buffer), "%u", (0x0001 << t2p->tiff_bitspersample)-1 );
    #####: 4891:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4892:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4893:		written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4894:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_palettecs ); 
    #####: 4895:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4896:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4897:		written += t2pWriteFile(output, (tdata_t) " 0 R ]\n", 7);
    #####: 4898:		return(written);
        -: 4899:	}
    #####: 4900:	if(t2p->pdf_colorspace & T2P_CS_BILEVEL){
    #####: 4901:			written += t2pWriteFile(output, (tdata_t) "/DeviceGray \n", 13);
        -: 4902:	}
    #####: 4903:	if(t2p->pdf_colorspace & T2P_CS_GRAY){
    #####: 4904:			if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 4905:				written += t2p_write_pdf_xobject_calcs(t2p, output);
        -: 4906:			} else {
    #####: 4907:				written += t2pWriteFile(output, (tdata_t) "/DeviceGray \n", 13);
        -: 4908:			}
        -: 4909:	}
    #####: 4910:	if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 4911:			if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 4912:				written += t2p_write_pdf_xobject_calcs(t2p, output);
        -: 4913:			} else {
    #####: 4914:				written += t2pWriteFile(output, (tdata_t) "/DeviceRGB \n", 12);
        -: 4915:			}
        -: 4916:	}
    #####: 4917:	if(t2p->pdf_colorspace & T2P_CS_CMYK){
    #####: 4918:			written += t2pWriteFile(output, (tdata_t) "/DeviceCMYK \n", 13);
        -: 4919:	}
    #####: 4920:	if(t2p->pdf_colorspace & T2P_CS_LAB){
    #####: 4921:			written += t2pWriteFile(output, (tdata_t) "[/Lab << \n", 10);
    #####: 4922:			written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
    #####: 4923:			X_W = t2p->tiff_whitechromaticities[0];
    #####: 4924:			Y_W = t2p->tiff_whitechromaticities[1];
    #####: 4925:			Z_W = 1.0F - (X_W + Y_W);
    #####: 4926:			X_W /= Y_W;
    #####: 4927:			Z_W /= Y_W;
    #####: 4928:			Y_W = 1.0F;
    #####: 4929:			buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
    #####: 4930:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4931:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4932:			written += t2pWriteFile(output, (tdata_t) "/Range ", 7);
    #####: 4933:			buflen=snprintf(buffer, sizeof(buffer), "[%d %d %d %d] \n", 
        -: 4934:				t2p->pdf_labrange[0], 
        -: 4935:				t2p->pdf_labrange[1], 
        -: 4936:				t2p->pdf_labrange[2], 
        -: 4937:				t2p->pdf_labrange[3]);
    #####: 4938:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4939:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4940:			written += t2pWriteFile(output, (tdata_t) ">>] \n", 5);
        -: 4941:			
        -: 4942:	}
        -: 4943:	
    #####: 4944:	return(written);
        -: 4945:}
        -: 4946:
    #####: 4947:tsize_t t2p_write_pdf_transfer(T2P* t2p, TIFF* output){
        -: 4948:
    #####: 4949:	tsize_t written=0;
    #####: 4950:	char buffer[32];
    #####: 4951:	int buflen=0;
        -: 4952:
    #####: 4953:	written += t2pWriteFile(output, (tdata_t) "<< /Type /ExtGState \n/TR ", 25);
    #####: 4954:	if(t2p->tiff_transferfunctioncount == 1){
    #####: 4955:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4956:			       (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 4957:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4958:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4959:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
        -: 4960:	} else {
    #####: 4961:		written += t2pWriteFile(output, (tdata_t) "[ ", 2);
    #####: 4962:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4963:			       (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 4964:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4965:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4966:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4967:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4968:			       (unsigned long)(t2p->pdf_xrefcount + 2));
    #####: 4969:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4970:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4971:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4972:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4973:			       (unsigned long)(t2p->pdf_xrefcount + 3));
    #####: 4974:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4975:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4976:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4977:		written += t2pWriteFile(output, (tdata_t) "/Identity ] ", 12);
        -: 4978:	}
        -: 4979:
    #####: 4980:	written += t2pWriteFile(output, (tdata_t) " >> \n", 5);
        -: 4981:
    #####: 4982:	return(written);
        -: 4983:}
        -: 4984:
    #####: 4985:tsize_t t2p_write_pdf_transfer_dict(T2P* t2p, TIFF* output, uint16 i){
        -: 4986:
    #####: 4987:	tsize_t written=0;
    #####: 4988:	char buffer[32];
    #####: 4989:	int buflen=0;
        -: 4990:	(void)i; /* XXX */
        -: 4991:
    #####: 4992:	written += t2pWriteFile(output, (tdata_t) "/FunctionType 0 \n", 17);
    #####: 4993:	written += t2pWriteFile(output, (tdata_t) "/Domain [0.0 1.0] \n", 19);
    #####: 4994:	written += t2pWriteFile(output, (tdata_t) "/Range [0.0 1.0] \n", 18);
    #####: 4995:	buflen=snprintf(buffer, sizeof(buffer), "/Size [%u] \n", (1<<t2p->tiff_bitspersample));
    #####: 4996:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 4997:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4998:	written += t2pWriteFile(output, (tdata_t) "/BitsPerSample 16 \n", 19);
    #####: 4999:	written += t2p_write_pdf_stream_dict(((tsize_t)1)<<(t2p->tiff_bitspersample+1), 0, output);
        -: 5000:
    #####: 5001:	return(written);
        -: 5002:}
        -: 5003:
    #####: 5004:tsize_t t2p_write_pdf_transfer_stream(T2P* t2p, TIFF* output, uint16 i){
        -: 5005:
    #####: 5006:	tsize_t written=0;
        -: 5007:
    #####: 5008:	written += t2p_write_pdf_stream(
    #####: 5009:		t2p->tiff_transferfunction[i], 
    #####: 5010:		(((tsize_t)1)<<(t2p->tiff_bitspersample+1)), 
        -: 5011:		output);
        -: 5012:
    #####: 5013:	return(written);
        -: 5014:}
        -: 5015:
        -: 5016:/*
        -: 5017:	This function writes a PDF Image XObject Colorspace array to output.
        -: 5018:*/
        -: 5019:
    #####: 5020:tsize_t t2p_write_pdf_xobject_calcs(T2P* t2p, TIFF* output){
        -: 5021:
    #####: 5022:	tsize_t written=0;
    #####: 5023:	char buffer[256];
    #####: 5024:	int buflen=0;
        -: 5025:	
    #####: 5026:	float X_W=0.0;
    #####: 5027:	float Y_W=0.0;
    #####: 5028:	float Z_W=0.0;
    #####: 5029:	float X_R=0.0;
    #####: 5030:	float Y_R=0.0;
    #####: 5031:	float Z_R=0.0;
    #####: 5032:	float X_G=0.0;
    #####: 5033:	float Y_G=0.0;
    #####: 5034:	float Z_G=0.0;
    #####: 5035:	float X_B=0.0;
    #####: 5036:	float Y_B=0.0;
    #####: 5037:	float Z_B=0.0;
    #####: 5038:	float x_w=0.0;
    #####: 5039:	float y_w=0.0;
    #####: 5040:	float z_w=0.0;
    #####: 5041:	float x_r=0.0;
    #####: 5042:	float y_r=0.0;
    #####: 5043:	float x_g=0.0;
    #####: 5044:	float y_g=0.0;
    #####: 5045:	float x_b=0.0;
    #####: 5046:	float y_b=0.0;
    #####: 5047:	float R=1.0;
    #####: 5048:	float G=1.0;
    #####: 5049:	float B=1.0;
        -: 5050:	
    #####: 5051:	written += t2pWriteFile(output, (tdata_t) "[", 1);
    #####: 5052:	if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 5053:		written += t2pWriteFile(output, (tdata_t) "/CalGray ", 9);
    #####: 5054:		X_W = t2p->tiff_whitechromaticities[0];
    #####: 5055:		Y_W = t2p->tiff_whitechromaticities[1];
    #####: 5056:		Z_W = 1.0F - (X_W + Y_W);
    #####: 5057:		X_W /= Y_W;
    #####: 5058:		Z_W /= Y_W;
    #####: 5059:		Y_W = 1.0F;
        -: 5060:	}
    #####: 5061:	if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 5062:		written += t2pWriteFile(output, (tdata_t) "/CalRGB ", 8);
    #####: 5063:		x_w = t2p->tiff_whitechromaticities[0];
    #####: 5064:		y_w = t2p->tiff_whitechromaticities[1];
    #####: 5065:		x_r = t2p->tiff_primarychromaticities[0];
    #####: 5066:		y_r = t2p->tiff_primarychromaticities[1];
    #####: 5067:		x_g = t2p->tiff_primarychromaticities[2];
    #####: 5068:		y_g = t2p->tiff_primarychromaticities[3];
    #####: 5069:		x_b = t2p->tiff_primarychromaticities[4];
    #####: 5070:		y_b = t2p->tiff_primarychromaticities[5];
    #####: 5071:		z_w = y_w * ((x_g - x_b)*y_r - (x_r-x_b)*y_g + (x_r-x_g)*y_b);
    #####: 5072:		Y_R = (y_r/R) * ((x_g-x_b)*y_w - (x_w-x_b)*y_g + (x_w-x_g)*y_b) / z_w;
    #####: 5073:		X_R = Y_R * x_r / y_r;
    #####: 5074:		Z_R = Y_R * (((1-x_r)/y_r)-1);
    #####: 5075:		Y_G = ((0.0F-(y_g))/G) * ((x_r-x_b)*y_w - (x_w-x_b)*y_r + (x_w-x_r)*y_b) / z_w;
    #####: 5076:		X_G = Y_G * x_g / y_g;
    #####: 5077:		Z_G = Y_G * (((1-x_g)/y_g)-1);
    #####: 5078:		Y_B = (y_b/B) * ((x_r-x_g)*y_w - (x_w-x_g)*y_r + (x_w-x_r)*y_g) / z_w;
    #####: 5079:		X_B = Y_B * x_b / y_b;
    #####: 5080:		Z_B = Y_B * (((1-x_b)/y_b)-1);
    #####: 5081:		X_W = (X_R * R) + (X_G * G) + (X_B * B);
    #####: 5082:		Y_W = (Y_R * R) + (Y_G * G) + (Y_B * B);
    #####: 5083:		Z_W = (Z_R * R) + (Z_G * G) + (Z_B * B);
    #####: 5084:		X_W /= Y_W;
    #####: 5085:		Z_W /= Y_W;
    #####: 5086:		Y_W = 1.0;
        -: 5087:	}
    #####: 5088:	written += t2pWriteFile(output, (tdata_t) "<< \n", 4);
    #####: 5089:	if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 5090:		written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
    #####: 5091:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
    #####: 5092:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5093:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5094:		written += t2pWriteFile(output, (tdata_t) "/Gamma 2.2 \n", 12);
        -: 5095:	}
    #####: 5096:	if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 5097:		written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
    #####: 5098:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
    #####: 5099:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5100:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5101:		written += t2pWriteFile(output, (tdata_t) "/Matrix ", 8);
    #####: 5102:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f] \n", 
        -: 5103:			X_R, Y_R, Z_R, 
        -: 5104:			X_G, Y_G, Z_G, 
        -: 5105:			X_B, Y_B, Z_B); 
    #####: 5106:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5107:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5108:		written += t2pWriteFile(output, (tdata_t) "/Gamma [2.2 2.2 2.2] \n", 22);
        -: 5109:	}
    #####: 5110:	written += t2pWriteFile(output, (tdata_t) ">>] \n", 5);
        -: 5111:
    #####: 5112:	return(written);
        -: 5113:}
        -: 5114:
        -: 5115:/*
        -: 5116:	This function writes a PDF Image XObject Colorspace array to output.
        -: 5117:*/
        -: 5118:
    #####: 5119:tsize_t t2p_write_pdf_xobject_icccs(T2P* t2p, TIFF* output){
        -: 5120:
    #####: 5121:	tsize_t written=0;
    #####: 5122:	char buffer[32];
    #####: 5123:	int buflen=0;
        -: 5124:	
    #####: 5125:	written += t2pWriteFile(output, (tdata_t) "[/ICCBased ", 11);
    #####: 5126:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_icccs);
    #####: 5127:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5128:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5129:	written += t2pWriteFile(output, (tdata_t) " 0 R] \n", 7);
        -: 5130:
    #####: 5131:	return(written);
        -: 5132:}
        -: 5133:
    #####: 5134:tsize_t t2p_write_pdf_xobject_icccs_dict(T2P* t2p, TIFF* output){
        -: 5135:
    #####: 5136:	tsize_t written=0;
    #####: 5137:	char buffer[32];
    #####: 5138:	int buflen=0;
        -: 5139:	
    #####: 5140:	written += t2pWriteFile(output, (tdata_t) "/N ", 3);
    #####: 5141:	buflen=snprintf(buffer, sizeof(buffer), "%u \n", t2p->tiff_samplesperpixel);
    #####: 5142:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5143:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5144:	written += t2pWriteFile(output, (tdata_t) "/Alternate ", 11);
    #####: 5145:	t2p->pdf_colorspace ^= T2P_CS_ICCBASED;
    #####: 5146:	written += t2p_write_pdf_xobject_cs(t2p, output);
    #####: 5147:	t2p->pdf_colorspace |= T2P_CS_ICCBASED;
    #####: 5148:	written += t2p_write_pdf_stream_dict(t2p->tiff_iccprofilelength, 0, output);
        -: 5149:	
    #####: 5150:	return(written);
        -: 5151:}
        -: 5152:
    #####: 5153:tsize_t t2p_write_pdf_xobject_icccs_stream(T2P* t2p, TIFF* output){
        -: 5154:
    #####: 5155:	tsize_t written=0;
        -: 5156:
    #####: 5157:	written += t2p_write_pdf_stream(
    #####: 5158:				(tdata_t) t2p->tiff_iccprofile, 
    #####: 5159:				(tsize_t) t2p->tiff_iccprofilelength, 
        -: 5160:				output);
        -: 5161:	
    #####: 5162:	return(written);
        -: 5163:}
        -: 5164:
        -: 5165:/*
        -: 5166:	This function writes a palette stream for an indexed color space to output.
        -: 5167:*/
        -: 5168:
    #####: 5169:tsize_t t2p_write_pdf_xobject_palettecs_stream(T2P* t2p, TIFF* output){
        -: 5170:
    #####: 5171:	tsize_t written=0;
        -: 5172:
    #####: 5173:	written += t2p_write_pdf_stream(
    #####: 5174:				(tdata_t) t2p->pdf_palette, 
    #####: 5175:				(tsize_t) t2p->pdf_palettesize, 
        -: 5176:				output);
        -: 5177:	
    #####: 5178:	return(written);
        -: 5179:}
        -: 5180:
        -: 5181:/*
        -: 5182:	This function writes a PDF Image XObject Decode array to output.
        -: 5183:*/
        -: 5184:
    #####: 5185:tsize_t t2p_write_pdf_xobject_decode(T2P* t2p, TIFF* output){
        -: 5186:
    #####: 5187:	tsize_t written=0;
    #####: 5188:	int i=0;
        -: 5189:
    #####: 5190:	written += t2pWriteFile(output, (tdata_t) "/Decode [ ", 10);
    #####: 5191:	for (i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 5192:		written += t2pWriteFile(output, (tdata_t) "1 0 ", 4);
        -: 5193:	}
    #####: 5194:	written += t2pWriteFile(output, (tdata_t) "]\n", 2);
        -: 5195:
    #####: 5196:	return(written);
        -: 5197:}
        -: 5198:
        -: 5199:/*
        -: 5200:	This function writes a PDF Image XObject stream filter name and parameters to 
        -: 5201:	output.
        -: 5202:*/
        -: 5203:
    #####: 5204:tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t tile, T2P* t2p, TIFF* output){
        -: 5205:
    #####: 5206:	tsize_t written=0;
    #####: 5207:	char buffer[32];
    #####: 5208:	int buflen=0;
        -: 5209:
    #####: 5210:	if(t2p->pdf_compression==T2P_COMPRESS_NONE){
    #####: 5211:		return(written);
        -: 5212:	}
    #####: 5213:	written += t2pWriteFile(output, (tdata_t) "/Filter ", 8);
    #####: 5214:	switch(t2p->pdf_compression){
        -: 5215:#ifdef CCITT_SUPPORT
    #####: 5216:		case T2P_COMPRESS_G4:
    #####: 5217:			written += t2pWriteFile(output, (tdata_t) "/CCITTFaxDecode ", 16);
    #####: 5218:			written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
    #####: 5219:			written += t2pWriteFile(output, (tdata_t) "<< /K -1 ", 9);
    #####: 5220:			if(tile==0){
    #####: 5221:				written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5222:				buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5223:					       (unsigned long)t2p->tiff_width);
    #####: 5224:				check_snprintf_ret(t2p, buflen, buffer);
    #####: 5225:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5226:				written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5227:				buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5228:					       (unsigned long)t2p->tiff_length);
    #####: 5229:				check_snprintf_ret(t2p, buflen, buffer);
    #####: 5230:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5231:			} else {
    #####: 5232:				if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){
    #####: 5233:					written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5234:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5235:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
    #####: 5236:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5237:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5238:				} else {
    #####: 5239:					written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5240:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5241:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
    #####: 5242:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5243:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5244:				}
    #####: 5245:				if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){
    #####: 5246:					written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5247:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5248:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
    #####: 5249:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5250:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5251:				} else {
    #####: 5252:					written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5253:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5254:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
    #####: 5255:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5256:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5257:				}
        -: 5258:			}
    #####: 5259:			if(t2p->pdf_switchdecode == 0){
    #####: 5260:				written += t2pWriteFile(output, (tdata_t) " /BlackIs1 true ", 16);
        -: 5261:			}
    #####: 5262:			written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
    #####: 5263:			break;
        -: 5264:#endif
        -: 5265:#ifdef JPEG_SUPPORT
    #####: 5266:		case T2P_COMPRESS_JPEG:
    #####: 5267:			written += t2pWriteFile(output, (tdata_t) "/DCTDecode ", 11);
        -: 5268:
    #####: 5269:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR) {
    #####: 5270:				written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
    #####: 5271:				written += t2pWriteFile(output, (tdata_t) "<< /ColorTransform 1 >>\n", 24);
        -: 5272:			}
    #####: 5273:			break;
        -: 5274:#endif
        -: 5275:#ifdef ZIP_SUPPORT
        -: 5276:		case T2P_COMPRESS_ZIP:
        -: 5277:			written += t2pWriteFile(output, (tdata_t) "/FlateDecode ", 13);
        -: 5278:			if(t2p->pdf_compressionquality%100){
        -: 5279:				written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
        -: 5280:				written += t2pWriteFile(output, (tdata_t) "<< /Predictor ", 14);
        -: 5281:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_compressionquality%100);
        -: 5282:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5283:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5284:				written += t2pWriteFile(output, (tdata_t) " /Columns ", 10);
        -: 5285:				buflen = snprintf(buffer, sizeof(buffer), "%lu",
        -: 5286:						 (unsigned long)t2p->tiff_width);
        -: 5287:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5288:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5289:				written += t2pWriteFile(output, (tdata_t) " /Colors ", 9);
        -: 5290:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_samplesperpixel);
        -: 5291:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5292:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5293:				written += t2pWriteFile(output, (tdata_t) " /BitsPerComponent ", 19);
        -: 5294:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_bitspersample);
        -: 5295:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5296:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5297:				written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 5298:			}
        -: 5299:			break;
        -: 5300:#endif
    #####: 5301:		default:
    #####: 5302:			break;
        -: 5303:	}
        -: 5304:
    #####: 5305:	return(written);
        -: 5306:}
        -: 5307:
        -: 5308:/*
        -: 5309:	This function writes a PDF xref table to output.
        -: 5310:*/
        -: 5311:
    #####: 5312:tsize_t t2p_write_pdf_xreftable(T2P* t2p, TIFF* output){
        -: 5313:
    #####: 5314:	tsize_t written=0;
    #####: 5315:	char buffer[64];
    #####: 5316:	int buflen=0;
    #####: 5317:	uint32 i=0;
        -: 5318:
    #####: 5319:	written += t2pWriteFile(output, (tdata_t) "xref\n0 ", 7);
    #####: 5320:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 5321:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5322:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5323:	written += t2pWriteFile(output, (tdata_t) " \n0000000000 65535 f \n", 22);
    #####: 5324:	for (i=0;i<t2p->pdf_xrefcount;i++){
    #####: 5325:		snprintf(buffer, sizeof(buffer), "%.10lu 00000 n \n",
    #####: 5326:			(unsigned long)t2p->pdf_xrefoffsets[i]);
    #####: 5327:		written += t2pWriteFile(output, (tdata_t) buffer, 20);
        -: 5328:	}
        -: 5329:
    #####: 5330:	return(written);
        -: 5331:}
        -: 5332:
        -: 5333:/*
        -: 5334: * This function writes a PDF trailer to output.
        -: 5335: */
        -: 5336:
    #####: 5337:tsize_t t2p_write_pdf_trailer(T2P* t2p, TIFF* output)
        -: 5338:{
        -: 5339:
    #####: 5340:	tsize_t written = 0;
    #####: 5341:	char buffer[32];
    #####: 5342:	int buflen = 0;
    #####: 5343:	size_t i = 0;
        -: 5344:
    #####: 5345:	for (i = 0; i < sizeof(t2p->pdf_fileid) - 8; i += 8)
    #####: 5346:		snprintf(t2p->pdf_fileid + i, 9, "%.8X", rand());
        -: 5347:
    #####: 5348:	written += t2pWriteFile(output, (tdata_t) "trailer\n<<\n/Size ", 17);
    #####: 5349:	buflen = snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(t2p->pdf_xrefcount+1));
    #####: 5350:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5351:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5352:	written += t2pWriteFile(output, (tdata_t) "\n/Root ", 7);
    #####: 5353:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_catalog);
    #####: 5354:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5355:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5356:	written += t2pWriteFile(output, (tdata_t) " 0 R \n/Info ", 12);
    #####: 5357:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_info);
    #####: 5358:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5359:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5360:	written += t2pWriteFile(output, (tdata_t) " 0 R \n/ID[<", 11);
    #####: 5361:	written += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,
        -: 5362:				sizeof(t2p->pdf_fileid) - 1);
    #####: 5363:	written += t2pWriteFile(output, (tdata_t) "><", 2);
    #####: 5364:	written += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,
        -: 5365:				sizeof(t2p->pdf_fileid) - 1);
    #####: 5366:	written += t2pWriteFile(output, (tdata_t) ">]\n>>\nstartxref\n", 16);
    #####: 5367:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_startxref);
    #####: 5368:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5369:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5370:	written += t2pWriteFile(output, (tdata_t) "\n%%EOF\n", 7);
        -: 5371:
    #####: 5372:	return(written);
        -: 5373:}
        -: 5374: 
        -: 5375:/*
        -: 5376:
        -: 5377:  This function writes a PDF to a file given a pointer to a TIFF.
        -: 5378:
        -: 5379:  The idea with using a TIFF* as output for a PDF file is that the file 
        -: 5380:  can be created with TIFFClientOpen for memory-mapped use within the TIFF 
        -: 5381:  library, and TIFFWriteEncodedStrip can be used to write compressed data to 
        -: 5382:  the output.  The output is not actually a TIFF file, it is a PDF file.  
        -: 5383:
        -: 5384:  This function uses only t2pWriteFile and TIFFWriteEncodedStrip to write to 
        -: 5385:  the output TIFF file.  When libtiff would otherwise be writing data to the 
        -: 5386:  output file, the write procedure of the TIFF structure is replaced with an 
        -: 5387:  empty implementation.
        -: 5388:
        -: 5389:  The first argument to the function is an initialized and validated T2P 
        -: 5390:  context struct pointer.
        -: 5391:
        -: 5392:  The second argument to the function is the TIFF* that is the input that has 
        -: 5393:  been opened for reading and no other functions have been called upon it.
        -: 5394:
        -: 5395:  The third argument to the function is the TIFF* that is the output that has 
        -: 5396:  been opened for writing.  It has to be opened so that it hasn't written any 
        -: 5397:  data to the output.  If the output is seekable then it's OK to seek to the 
        -: 5398:  beginning of the file.  The function only writes to the output PDF and does 
        -: 5399:  not seek.  See the example usage in the main() function.
        -: 5400:
        -: 5401:	TIFF* output = TIFFOpen("output.pdf", "w");
        -: 5402:	assert(output != NULL);
        -: 5403:
        -: 5404:	if(output->tif_seekproc != NULL){
        -: 5405:		t2pSeekFile(output, (toff_t) 0, SEEK_SET);
        -: 5406:	}
        -: 5407:
        -: 5408:  This function returns the file size of the output PDF file.  On error it 
        -: 5409:  returns zero and the t2p->t2p_error variable is set to T2P_ERR_ERROR.
        -: 5410:
        -: 5411:  After this function completes, call t2p_free on t2p, TIFFClose on input, 
        -: 5412:  and TIFFClose on output.
        -: 5413:*/
        -: 5414:
    #####: 5415:tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){
        -: 5416:
    #####: 5417:	tsize_t written=0;
    #####: 5418:	ttile_t i2=0;
    #####: 5419:	tsize_t streamlen=0;
    #####: 5420:	uint16 i=0;
        -: 5421:
    #####: 5422:	t2p_read_tiff_init(t2p, input);
    #####: 5423:	if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5424:	t2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) );
    #####: 5425:	if(t2p->pdf_xrefoffsets==NULL){
    #####: 5426:		TIFFError(
        -: 5427:			TIFF2PDF_MODULE, 
        -: 5428:			"Can't allocate %u bytes of memory for t2p_write_pdf", 
    #####: 5429:			(unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) );
    #####: 5430:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 5431:		return(written);
        -: 5432:	}
    #####: 5433:	t2p->pdf_xrefcount=0;
    #####: 5434:	t2p->pdf_catalog=1;
    #####: 5435:	t2p->pdf_info=2;
    #####: 5436:	t2p->pdf_pages=3;
    #####: 5437:	written += t2p_write_pdf_header(t2p, output);
    #####: 5438:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5439:	t2p->pdf_catalog=t2p->pdf_xrefcount;
    #####: 5440:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5441:	written += t2p_write_pdf_catalog(t2p, output);
    #####: 5442:	written += t2p_write_pdf_obj_end(output);
    #####: 5443:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5444:	t2p->pdf_info=t2p->pdf_xrefcount;
    #####: 5445:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5446:	written += t2p_write_pdf_info(t2p, input, output);
    #####: 5447:	written += t2p_write_pdf_obj_end(output);
    #####: 5448:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5449:	t2p->pdf_pages=t2p->pdf_xrefcount;
    #####: 5450:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5451:	written += t2p_write_pdf_pages(t2p, output);
    #####: 5452:	written += t2p_write_pdf_obj_end(output);
    #####: 5453:	for(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){
    #####: 5454:		t2p_read_tiff_data(t2p, input);
    #####: 5455:		if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5456:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5457:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5458:		written += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output);
    #####: 5459:		written += t2p_write_pdf_obj_end(output);
    #####: 5460:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5461:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5462:		written += t2p_write_pdf_stream_dict_start(output);
    #####: 5463:		written += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);
    #####: 5464:		written += t2p_write_pdf_stream_dict_end(output);
    #####: 5465:		written += t2p_write_pdf_stream_start(output);
    #####: 5466:		streamlen=written;
    #####: 5467:		written += t2p_write_pdf_page_content_stream(t2p, output);
    #####: 5468:		streamlen=written-streamlen;
    #####: 5469:		written += t2p_write_pdf_stream_end(output);
    #####: 5470:		written += t2p_write_pdf_obj_end(output);
    #####: 5471:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5472:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5473:		written += t2p_write_pdf_stream_length(streamlen, output);
    #####: 5474:		written += t2p_write_pdf_obj_end(output);
    #####: 5475:		if(t2p->tiff_transferfunctioncount != 0){
    #####: 5476:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5477:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5478:			written += t2p_write_pdf_transfer(t2p, output);
    #####: 5479:			written += t2p_write_pdf_obj_end(output);
    #####: 5480:			for(i=0; i < t2p->tiff_transferfunctioncount; i++){
    #####: 5481:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5482:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5483:				written += t2p_write_pdf_stream_dict_start(output);
    #####: 5484:				written += t2p_write_pdf_transfer_dict(t2p, output, i);
    #####: 5485:				written += t2p_write_pdf_stream_dict_end(output);
    #####: 5486:				written += t2p_write_pdf_stream_start(output);
        -: 5487:				/* streamlen=written; */ /* value not used */
    #####: 5488:				written += t2p_write_pdf_transfer_stream(t2p, output, i);
        -: 5489:				/* streamlen=written-streamlen; */ /* value not used */
    #####: 5490:				written += t2p_write_pdf_stream_end(output);
    #####: 5491:				written += t2p_write_pdf_obj_end(output);
        -: 5492:			}
        -: 5493:		}
    #####: 5494:		if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){
    #####: 5495:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5496:			t2p->pdf_palettecs=t2p->pdf_xrefcount;
    #####: 5497:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5498:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5499:			written += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output);
    #####: 5500:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5501:			written += t2p_write_pdf_stream_start(output);
        -: 5502:			/* streamlen=written; */ /* value not used */
    #####: 5503:			written += t2p_write_pdf_xobject_palettecs_stream(t2p, output);
        -: 5504:			/* streamlen=written-streamlen; */ /* value not used */
    #####: 5505:			written += t2p_write_pdf_stream_end(output);
    #####: 5506:			written += t2p_write_pdf_obj_end(output);
        -: 5507:		}
    #####: 5508:		if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){
    #####: 5509:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5510:			t2p->pdf_icccs=t2p->pdf_xrefcount;
    #####: 5511:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5512:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5513:			written += t2p_write_pdf_xobject_icccs_dict(t2p, output);
    #####: 5514:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5515:			written += t2p_write_pdf_stream_start(output);
        -: 5516:			/* streamlen=written; */ /* value not used */
    #####: 5517:			written += t2p_write_pdf_xobject_icccs_stream(t2p, output);
        -: 5518:			/* streamlen=written-streamlen; */ /* value not used */
    #####: 5519:			written += t2p_write_pdf_stream_end(output);
    #####: 5520:			written += t2p_write_pdf_obj_end(output);
        -: 5521:		}
    #####: 5522:		if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){
    #####: 5523:			for(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){
    #####: 5524:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5525:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5526:				written += t2p_write_pdf_stream_dict_start(output);
    #####: 5527:				written += t2p_write_pdf_xobject_stream_dict(
        -: 5528:					i2+1, 
        -: 5529:					t2p, 
        -: 5530:					output);
    #####: 5531:				written += t2p_write_pdf_stream_dict_end(output);
    #####: 5532:				written += t2p_write_pdf_stream_start(output);
    #####: 5533:				streamlen=written;
    #####: 5534:				t2p_read_tiff_size_tile(t2p, input, i2);
    #####: 5535:				written += t2p_readwrite_pdf_image_tile(t2p, input, output, i2);
    #####: 5536:				t2p_write_advance_directory(t2p, output);
    #####: 5537:				if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5538:				streamlen=written-streamlen;
    #####: 5539:				written += t2p_write_pdf_stream_end(output);
    #####: 5540:				written += t2p_write_pdf_obj_end(output);
    #####: 5541:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5542:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5543:				written += t2p_write_pdf_stream_length(streamlen, output);
    #####: 5544:				written += t2p_write_pdf_obj_end(output);
        -: 5545:			}
        -: 5546:		} else {
    #####: 5547:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5548:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5549:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5550:			written += t2p_write_pdf_xobject_stream_dict(
        -: 5551:				0, 
        -: 5552:				t2p, 
        -: 5553:				output);
    #####: 5554:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5555:			written += t2p_write_pdf_stream_start(output);
    #####: 5556:			streamlen=written;
    #####: 5557:			t2p_read_tiff_size(t2p, input);
    #####: 5558:			written += t2p_readwrite_pdf_image(t2p, input, output);
    #####: 5559:			t2p_write_advance_directory(t2p, output);
    #####: 5560:			if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5561:			streamlen=written-streamlen;
    #####: 5562:			written += t2p_write_pdf_stream_end(output);
    #####: 5563:			written += t2p_write_pdf_obj_end(output);
    #####: 5564:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5565:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5566:			written += t2p_write_pdf_stream_length(streamlen, output);
    #####: 5567:			written += t2p_write_pdf_obj_end(output);
        -: 5568:		}
        -: 5569:	}
    #####: 5570:	t2p->pdf_startxref = written;
    #####: 5571:	written += t2p_write_pdf_xreftable(t2p, output);
    #####: 5572:	written += t2p_write_pdf_trailer(t2p, output);
    #####: 5573:	t2p_disable(output);
        -: 5574:
    #####: 5575:	return(written);
        -: 5576:}
        -: 5577:
        -: 5578:/* vim: set ts=8 sts=8 sw=8 noet: */
        -: 5579:/*
        -: 5580: * Local Variables:
        -: 5581: * mode: c
        -: 5582: * c-basic-offset: 8
        -: 5583: * fill-column: 78
        -: 5584: * End:
        -: 5585: */
