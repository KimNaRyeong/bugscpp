        -:    0:Source:tif_dirread.c
        -:    1:/* $Id$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1988-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: *
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
        -:   18: *
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:/*
        -:   28: * TIFF Library.
        -:   29: *
        -:   30: * Directory Read Support Routines.
        -:   31: */
        -:   32:
        -:   33:/* Suggested pending improvements:
        -:   34: * - add a field 'ignore' to the TIFFDirEntry structure, to flag status,
        -:   35: *   eliminating current use of the IGNORE value, and therefore eliminating
        -:   36: *   current irrational behaviour on tags with tag id code 0
        -:   37: * - add a field 'field_info' to the TIFFDirEntry structure, and set that with
        -:   38: *   the pointer to the appropriate TIFFField structure early on in
        -:   39: *   TIFFReadDirectory, so as to eliminate current possibly repetitive lookup.
        -:   40: */
        -:   41:
        -:   42:#include "tiffiop.h"
        -:   43:#include <float.h>
        -:   44:
        -:   45:#define IGNORE 0          /* tag placeholder used below */
        -:   46:#define FAILED_FII    ((uint32) -1)
        -:   47:
        -:   48:#ifdef HAVE_IEEEFP
        -:   49:# define TIFFCvtIEEEFloatToNative(tif, n, fp)
        -:   50:# define TIFFCvtIEEEDoubleToNative(tif, n, dp)
        -:   51:#else
        -:   52:extern void TIFFCvtIEEEFloatToNative(TIFF*, uint32, float*);
        -:   53:extern void TIFFCvtIEEEDoubleToNative(TIFF*, uint32, double*);
        -:   54:#endif
        -:   55:
        -:   56:enum TIFFReadDirEntryErr {
        -:   57:	TIFFReadDirEntryErrOk = 0,
        -:   58:	TIFFReadDirEntryErrCount = 1,
        -:   59:	TIFFReadDirEntryErrType = 2,
        -:   60:	TIFFReadDirEntryErrIo = 3,
        -:   61:	TIFFReadDirEntryErrRange = 4,
        -:   62:	TIFFReadDirEntryErrPsdif = 5,
        -:   63:	TIFFReadDirEntryErrSizesan = 6,
        -:   64:	TIFFReadDirEntryErrAlloc = 7,
        -:   65:};
        -:   66:
        -:   67:static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value);
        -:   68:static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value);
        -:   69:static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value);
        -:   70:static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value);
        -:   71:static enum TIFFReadDirEntryErr TIFFReadDirEntryFloat(TIFF* tif, TIFFDirEntry* direntry, float* value);
        -:   72:static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value);
        -:   73:static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* direntry, uint64* value);
        -:   74:
        -:   75:static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value);
        -:   76:static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value);
        -:   77:static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEntry* direntry, int8** value);
        -:   78:static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value);
        -:   79:static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEntry* direntry, int16** value);
        -:   80:static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntry* direntry, uint32** value);
        -:   81:static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEntry* direntry, int32** value);
        -:   82:static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value);
        -:   83:static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64** value);
        -:   84:static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEntry* direntry, float** value);
        -:   85:static enum TIFFReadDirEntryErr TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value);
        -:   86:static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value);
        -:   87:
        -:   88:static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value);
        -:   89:#if 0
        -:   90:static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleDouble(TIFF* tif, TIFFDirEntry* direntry, double* value);
        -:   91:#endif
        -:   92:
        -:   93:static void TIFFReadDirEntryCheckedByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value);
        -:   94:static void TIFFReadDirEntryCheckedSbyte(TIFF* tif, TIFFDirEntry* direntry, int8* value);
        -:   95:static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value);
        -:   96:static void TIFFReadDirEntryCheckedSshort(TIFF* tif, TIFFDirEntry* direntry, int16* value);
        -:   97:static void TIFFReadDirEntryCheckedLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value);
        -:   98:static void TIFFReadDirEntryCheckedSlong(TIFF* tif, TIFFDirEntry* direntry, int32* value);
        -:   99:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value);
        -:  100:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDirEntry* direntry, int64* value);
        -:  101:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value);
        -:  102:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFFDirEntry* direntry, double* value);
        -:  103:static void TIFFReadDirEntryCheckedFloat(TIFF* tif, TIFFDirEntry* direntry, float* value);
        -:  104:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedDouble(TIFF* tif, TIFFDirEntry* direntry, double* value);
        -:  105:
        -:  106:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSbyte(int8 value);
        -:  107:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16 value);
        -:  108:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSshort(int16 value);
        -:  109:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32 value);
        -:  110:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong(int32 value);
        -:  111:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong8(uint64 value);
        -:  112:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong8(int64 value);
        -:  113:
        -:  114:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteByte(uint8 value);
        -:  115:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteShort(uint16 value);
        -:  116:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSshort(int16 value);
        -:  117:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong(uint32 value);
        -:  118:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong(int32 value);
        -:  119:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong8(uint64 value);
        -:  120:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong8(int64 value);
        -:  121:
        -:  122:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSbyte(int8 value);
        -:  123:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSshort(int16 value);
        -:  124:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong(uint32 value);
        -:  125:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong(int32 value);
        -:  126:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong8(uint64 value);
        -:  127:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong8(int64 value);
        -:  128:
        -:  129:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortShort(uint16 value);
        -:  130:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong(uint32 value);
        -:  131:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong(int32 value);
        -:  132:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong8(uint64 value);
        -:  133:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong8(int64 value);
        -:  134:
        -:  135:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSbyte(int8 value);
        -:  136:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16 value);
        -:  137:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong(int32 value);
        -:  138:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongLong8(uint64 value);
        -:  139:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong8(int64 value);
        -:  140:
        -:  141:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongLong(uint32 value);
        -:  142:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongLong8(uint64 value);
        -:  143:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlongSlong8(int64 value);
        -:  144:
        -:  145:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Sbyte(int8 value);
        -:  146:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Sshort(int16 value);
        -:  147:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Slong(int32 value);
        -:  148:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLong8Slong8(int64 value);
        -:  149:
        -:  150:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSlong8Long8(uint64 value);
        -:  151:
        -:  152:static enum TIFFReadDirEntryErr TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest);
        -:  153:static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover);
        -:  154:
        -:  155:static void TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount);
        -:  156:static TIFFDirEntry* TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid);
        -:  157:static void TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii);
        -:  158:
        -:  159:static int EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount);
        -:  160:static void MissingRequired(TIFF*, const char*);
        -:  161:static int TIFFCheckDirOffset(TIFF* tif, uint64 diroff);
        -:  162:static int CheckDirCount(TIFF*, TIFFDirEntry*, uint32);
        -:  163:static uint16 TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir, uint64* nextdiroff);
        -:  164:static int TIFFFetchNormalTag(TIFF*, TIFFDirEntry*, int recover);
        -:  165:static int TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp);
        -:  166:static int TIFFFetchSubjectDistance(TIFF*, TIFFDirEntry*);
        -:  167:static void ChopUpSingleUncompressedStrip(TIFF*);
        -:  168:static uint64 TIFFReadUInt64(const uint8 *value);
        -:  169:
        -:  170:static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount );
        -:  171:
        -:  172:typedef union _UInt64Aligned_t
        -:  173:{
        -:  174:        double d;
        -:  175:	uint64 l;
        -:  176:	uint32 i[2];
        -:  177:	uint16 s[4];
        -:  178:	uint8  c[8];
        -:  179:} UInt64Aligned_t;
        -:  180:
        -:  181:/*
        -:  182:  Unaligned safe copy of a uint64 value from an octet array.
        -:  183:*/
       36:  184:static uint64 TIFFReadUInt64(const uint8 *value)
        -:  185:{
        -:  186:	UInt64Aligned_t result;
        -:  187:
       36:  188:	result.c[0]=value[0];
       36:  189:	result.c[1]=value[1];
       36:  190:	result.c[2]=value[2];
       36:  191:	result.c[3]=value[3];
       36:  192:	result.c[4]=value[4];
       36:  193:	result.c[5]=value[5];
       36:  194:	result.c[6]=value[6];
       36:  195:	result.c[7]=value[7];
        -:  196:
       36:  197:	return result.l;
        -:  198:}
        -:  199:
        1:  200:static enum TIFFReadDirEntryErr TIFFReadDirEntryByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)
        -:  201:{
        -:  202:	enum TIFFReadDirEntryErr err;
        1:  203:	if (direntry->tdir_count!=1)
    #####:  204:		return(TIFFReadDirEntryErrCount);
        1:  205:	switch (direntry->tdir_type)
        -:  206:	{
    #####:  207:		case TIFF_BYTE:
    #####:  208:			TIFFReadDirEntryCheckedByte(tif,direntry,value);
    #####:  209:			return(TIFFReadDirEntryErrOk);
    #####:  210:		case TIFF_SBYTE:
        -:  211:			{
    #####:  212:				int8 m;
    #####:  213:				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
    #####:  214:				err=TIFFReadDirEntryCheckRangeByteSbyte(m);
    #####:  215:				if (err!=TIFFReadDirEntryErrOk)
    #####:  216:					return(err);
    #####:  217:				*value=(uint8)m;
    #####:  218:				return(TIFFReadDirEntryErrOk);
        -:  219:			}
        1:  220:		case TIFF_SHORT:
        -:  221:			{
        1:  222:				uint16 m;
        1:  223:				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
        1:  224:				err=TIFFReadDirEntryCheckRangeByteShort(m);
        1:  225:				if (err!=TIFFReadDirEntryErrOk)
    #####:  226:					return(err);
        1:  227:				*value=(uint8)m;
        1:  228:				return(TIFFReadDirEntryErrOk);
        -:  229:			}
    #####:  230:		case TIFF_SSHORT:
        -:  231:			{
    #####:  232:				int16 m;
    #####:  233:				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
    #####:  234:				err=TIFFReadDirEntryCheckRangeByteSshort(m);
    #####:  235:				if (err!=TIFFReadDirEntryErrOk)
    #####:  236:					return(err);
    #####:  237:				*value=(uint8)m;
    #####:  238:				return(TIFFReadDirEntryErrOk);
        -:  239:			}
    #####:  240:		case TIFF_LONG:
        -:  241:			{
    #####:  242:				uint32 m;
    #####:  243:				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
    #####:  244:				err=TIFFReadDirEntryCheckRangeByteLong(m);
    #####:  245:				if (err!=TIFFReadDirEntryErrOk)
    #####:  246:					return(err);
    #####:  247:				*value=(uint8)m;
    #####:  248:				return(TIFFReadDirEntryErrOk);
        -:  249:			}
    #####:  250:		case TIFF_SLONG:
        -:  251:			{
    #####:  252:				int32 m;
    #####:  253:				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
    #####:  254:				err=TIFFReadDirEntryCheckRangeByteSlong(m);
    #####:  255:				if (err!=TIFFReadDirEntryErrOk)
    #####:  256:					return(err);
    #####:  257:				*value=(uint8)m;
    #####:  258:				return(TIFFReadDirEntryErrOk);
        -:  259:			}
    #####:  260:		case TIFF_LONG8:
        -:  261:			{
    #####:  262:				uint64 m;
    #####:  263:				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
    #####:  264:				if (err!=TIFFReadDirEntryErrOk)
    #####:  265:					return(err);
    #####:  266:				err=TIFFReadDirEntryCheckRangeByteLong8(m);
    #####:  267:				if (err!=TIFFReadDirEntryErrOk)
    #####:  268:					return(err);
    #####:  269:				*value=(uint8)m;
    #####:  270:				return(TIFFReadDirEntryErrOk);
        -:  271:			}
    #####:  272:		case TIFF_SLONG8:
        -:  273:			{
    #####:  274:				int64 m;
    #####:  275:				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
    #####:  276:				if (err!=TIFFReadDirEntryErrOk)
    #####:  277:					return(err);
    #####:  278:				err=TIFFReadDirEntryCheckRangeByteSlong8(m);
    #####:  279:				if (err!=TIFFReadDirEntryErrOk)
    #####:  280:					return(err);
    #####:  281:				*value=(uint8)m;
    #####:  282:				return(TIFFReadDirEntryErrOk);
        -:  283:			}
    #####:  284:		default:
    #####:  285:			return(TIFFReadDirEntryErrType);
        -:  286:	}
        -:  287:}
        -:  288:
        5:  289:static enum TIFFReadDirEntryErr TIFFReadDirEntryShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)
        -:  290:{
        -:  291:	enum TIFFReadDirEntryErr err;
        5:  292:	if (direntry->tdir_count!=1)
        1:  293:		return(TIFFReadDirEntryErrCount);
        4:  294:	switch (direntry->tdir_type)
        -:  295:	{
    #####:  296:		case TIFF_BYTE:
        -:  297:			{
    #####:  298:				uint8 m;
    #####:  299:				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
    #####:  300:				*value=(uint16)m;
    #####:  301:				return(TIFFReadDirEntryErrOk);
        -:  302:			}
    #####:  303:		case TIFF_SBYTE:
        -:  304:			{
    #####:  305:				int8 m;
    #####:  306:				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
    #####:  307:				err=TIFFReadDirEntryCheckRangeShortSbyte(m);
    #####:  308:				if (err!=TIFFReadDirEntryErrOk)
    #####:  309:					return(err);
    #####:  310:				*value=(uint16)m;
    #####:  311:				return(TIFFReadDirEntryErrOk);
        -:  312:			}
        4:  313:		case TIFF_SHORT:
        4:  314:			TIFFReadDirEntryCheckedShort(tif,direntry,value);
        4:  315:			return(TIFFReadDirEntryErrOk);
    #####:  316:		case TIFF_SSHORT:
        -:  317:			{
    #####:  318:				int16 m;
    #####:  319:				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
    #####:  320:				err=TIFFReadDirEntryCheckRangeShortSshort(m);
    #####:  321:				if (err!=TIFFReadDirEntryErrOk)
    #####:  322:					return(err);
    #####:  323:				*value=(uint16)m;
    #####:  324:				return(TIFFReadDirEntryErrOk);
        -:  325:			}
    #####:  326:		case TIFF_LONG:
        -:  327:			{
    #####:  328:				uint32 m;
    #####:  329:				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
    #####:  330:				err=TIFFReadDirEntryCheckRangeShortLong(m);
    #####:  331:				if (err!=TIFFReadDirEntryErrOk)
    #####:  332:					return(err);
    #####:  333:				*value=(uint16)m;
    #####:  334:				return(TIFFReadDirEntryErrOk);
        -:  335:			}
    #####:  336:		case TIFF_SLONG:
        -:  337:			{
    #####:  338:				int32 m;
    #####:  339:				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
    #####:  340:				err=TIFFReadDirEntryCheckRangeShortSlong(m);
    #####:  341:				if (err!=TIFFReadDirEntryErrOk)
    #####:  342:					return(err);
    #####:  343:				*value=(uint16)m;
    #####:  344:				return(TIFFReadDirEntryErrOk);
        -:  345:			}
    #####:  346:		case TIFF_LONG8:
        -:  347:			{
    #####:  348:				uint64 m;
    #####:  349:				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
    #####:  350:				if (err!=TIFFReadDirEntryErrOk)
    #####:  351:					return(err);
    #####:  352:				err=TIFFReadDirEntryCheckRangeShortLong8(m);
    #####:  353:				if (err!=TIFFReadDirEntryErrOk)
    #####:  354:					return(err);
    #####:  355:				*value=(uint16)m;
    #####:  356:				return(TIFFReadDirEntryErrOk);
        -:  357:			}
    #####:  358:		case TIFF_SLONG8:
        -:  359:			{
    #####:  360:				int64 m;
    #####:  361:				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
    #####:  362:				if (err!=TIFFReadDirEntryErrOk)
    #####:  363:					return(err);
    #####:  364:				err=TIFFReadDirEntryCheckRangeShortSlong8(m);
    #####:  365:				if (err!=TIFFReadDirEntryErrOk)
    #####:  366:					return(err);
    #####:  367:				*value=(uint16)m;
    #####:  368:				return(TIFFReadDirEntryErrOk);
        -:  369:			}
    #####:  370:		default:
    #####:  371:			return(TIFFReadDirEntryErrType);
        -:  372:	}
        -:  373:}
        -:  374:
        3:  375:static enum TIFFReadDirEntryErr TIFFReadDirEntryLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)
        -:  376:{
        -:  377:	enum TIFFReadDirEntryErr err;
        3:  378:	if (direntry->tdir_count!=1)
    #####:  379:		return(TIFFReadDirEntryErrCount);
        3:  380:	switch (direntry->tdir_type)
        -:  381:	{
    #####:  382:		case TIFF_BYTE:
        -:  383:			{
    #####:  384:				uint8 m;
    #####:  385:				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
    #####:  386:				*value=(uint32)m;
    #####:  387:				return(TIFFReadDirEntryErrOk);
        -:  388:			}
    #####:  389:		case TIFF_SBYTE:
        -:  390:			{
    #####:  391:				int8 m;
    #####:  392:				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
    #####:  393:				err=TIFFReadDirEntryCheckRangeLongSbyte(m);
    #####:  394:				if (err!=TIFFReadDirEntryErrOk)
    #####:  395:					return(err);
    #####:  396:				*value=(uint32)m;
    #####:  397:				return(TIFFReadDirEntryErrOk);
        -:  398:			}
        3:  399:		case TIFF_SHORT:
        -:  400:			{
        3:  401:				uint16 m;
        3:  402:				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
        3:  403:				*value=(uint32)m;
        3:  404:				return(TIFFReadDirEntryErrOk);
        -:  405:			}
    #####:  406:		case TIFF_SSHORT:
        -:  407:			{
    #####:  408:				int16 m;
    #####:  409:				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
    #####:  410:				err=TIFFReadDirEntryCheckRangeLongSshort(m);
    #####:  411:				if (err!=TIFFReadDirEntryErrOk)
    #####:  412:					return(err);
    #####:  413:				*value=(uint32)m;
    #####:  414:				return(TIFFReadDirEntryErrOk);
        -:  415:			}
    #####:  416:		case TIFF_LONG:
    #####:  417:			TIFFReadDirEntryCheckedLong(tif,direntry,value);
    #####:  418:			return(TIFFReadDirEntryErrOk);
    #####:  419:		case TIFF_SLONG:
        -:  420:			{
    #####:  421:				int32 m;
    #####:  422:				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
    #####:  423:				err=TIFFReadDirEntryCheckRangeLongSlong(m);
    #####:  424:				if (err!=TIFFReadDirEntryErrOk)
    #####:  425:					return(err);
    #####:  426:				*value=(uint32)m;
    #####:  427:				return(TIFFReadDirEntryErrOk);
        -:  428:			}
    #####:  429:		case TIFF_LONG8:
        -:  430:			{
    #####:  431:				uint64 m;
    #####:  432:				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
    #####:  433:				if (err!=TIFFReadDirEntryErrOk)
    #####:  434:					return(err);
    #####:  435:				err=TIFFReadDirEntryCheckRangeLongLong8(m);
    #####:  436:				if (err!=TIFFReadDirEntryErrOk)
    #####:  437:					return(err);
    #####:  438:				*value=(uint32)m;
    #####:  439:				return(TIFFReadDirEntryErrOk);
        -:  440:			}
    #####:  441:		case TIFF_SLONG8:
        -:  442:			{
    #####:  443:				int64 m;
    #####:  444:				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
    #####:  445:				if (err!=TIFFReadDirEntryErrOk)
    #####:  446:					return(err);
    #####:  447:				err=TIFFReadDirEntryCheckRangeLongSlong8(m);
    #####:  448:				if (err!=TIFFReadDirEntryErrOk)
    #####:  449:					return(err);
    #####:  450:				*value=(uint32)m;
    #####:  451:				return(TIFFReadDirEntryErrOk);
        -:  452:			}
    #####:  453:		default:
    #####:  454:			return(TIFFReadDirEntryErrType);
        -:  455:	}
        -:  456:}
        -:  457:
    #####:  458:static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)
        -:  459:{
        -:  460:	enum TIFFReadDirEntryErr err;
    #####:  461:	if (direntry->tdir_count!=1)
    #####:  462:		return(TIFFReadDirEntryErrCount);
    #####:  463:	switch (direntry->tdir_type)
        -:  464:	{
    #####:  465:		case TIFF_BYTE:
        -:  466:			{
    #####:  467:				uint8 m;
    #####:  468:				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
    #####:  469:				*value=(uint64)m;
    #####:  470:				return(TIFFReadDirEntryErrOk);
        -:  471:			}
    #####:  472:		case TIFF_SBYTE:
        -:  473:			{
    #####:  474:				int8 m;
    #####:  475:				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
    #####:  476:				err=TIFFReadDirEntryCheckRangeLong8Sbyte(m);
    #####:  477:				if (err!=TIFFReadDirEntryErrOk)
    #####:  478:					return(err);
    #####:  479:				*value=(uint64)m;
    #####:  480:				return(TIFFReadDirEntryErrOk);
        -:  481:			}
    #####:  482:		case TIFF_SHORT:
        -:  483:			{
    #####:  484:				uint16 m;
    #####:  485:				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
    #####:  486:				*value=(uint64)m;
    #####:  487:				return(TIFFReadDirEntryErrOk);
        -:  488:			}
    #####:  489:		case TIFF_SSHORT:
        -:  490:			{
    #####:  491:				int16 m;
    #####:  492:				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
    #####:  493:				err=TIFFReadDirEntryCheckRangeLong8Sshort(m);
    #####:  494:				if (err!=TIFFReadDirEntryErrOk)
    #####:  495:					return(err);
    #####:  496:				*value=(uint64)m;
    #####:  497:				return(TIFFReadDirEntryErrOk);
        -:  498:			}
    #####:  499:		case TIFF_LONG:
        -:  500:			{
    #####:  501:				uint32 m;
    #####:  502:				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
    #####:  503:				*value=(uint64)m;
    #####:  504:				return(TIFFReadDirEntryErrOk);
        -:  505:			}
    #####:  506:		case TIFF_SLONG:
        -:  507:			{
    #####:  508:				int32 m;
    #####:  509:				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
    #####:  510:				err=TIFFReadDirEntryCheckRangeLong8Slong(m);
    #####:  511:				if (err!=TIFFReadDirEntryErrOk)
    #####:  512:					return(err);
    #####:  513:				*value=(uint64)m;
    #####:  514:				return(TIFFReadDirEntryErrOk);
        -:  515:			}
    #####:  516:		case TIFF_LONG8:
    #####:  517:			err=TIFFReadDirEntryCheckedLong8(tif,direntry,value);
    #####:  518:			return(err);
    #####:  519:		case TIFF_SLONG8:
        -:  520:			{
    #####:  521:				int64 m;
    #####:  522:				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
    #####:  523:				if (err!=TIFFReadDirEntryErrOk)
    #####:  524:					return(err);
    #####:  525:				err=TIFFReadDirEntryCheckRangeLong8Slong8(m);
    #####:  526:				if (err!=TIFFReadDirEntryErrOk)
    #####:  527:					return(err);
    #####:  528:				*value=(uint64)m;
    #####:  529:				return(TIFFReadDirEntryErrOk);
        -:  530:			}
    #####:  531:		default:
    #####:  532:			return(TIFFReadDirEntryErrType);
        -:  533:	}
        -:  534:}
        -:  535:
    #####:  536:static enum TIFFReadDirEntryErr TIFFReadDirEntryFloat(TIFF* tif, TIFFDirEntry* direntry, float* value)
        -:  537:{
        -:  538:	enum TIFFReadDirEntryErr err;
    #####:  539:	if (direntry->tdir_count!=1)
    #####:  540:		return(TIFFReadDirEntryErrCount);
    #####:  541:	switch (direntry->tdir_type)
        -:  542:	{
    #####:  543:		case TIFF_BYTE:
        -:  544:			{
    #####:  545:				uint8 m;
    #####:  546:				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
    #####:  547:				*value=(float)m;
    #####:  548:				return(TIFFReadDirEntryErrOk);
        -:  549:			}
    #####:  550:		case TIFF_SBYTE:
        -:  551:			{
    #####:  552:				int8 m;
    #####:  553:				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
    #####:  554:				*value=(float)m;
    #####:  555:				return(TIFFReadDirEntryErrOk);
        -:  556:			}
    #####:  557:		case TIFF_SHORT:
        -:  558:			{
    #####:  559:				uint16 m;
    #####:  560:				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
    #####:  561:				*value=(float)m;
    #####:  562:				return(TIFFReadDirEntryErrOk);
        -:  563:			}
    #####:  564:		case TIFF_SSHORT:
        -:  565:			{
    #####:  566:				int16 m;
    #####:  567:				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
    #####:  568:				*value=(float)m;
    #####:  569:				return(TIFFReadDirEntryErrOk);
        -:  570:			}
    #####:  571:		case TIFF_LONG:
        -:  572:			{
    #####:  573:				uint32 m;
    #####:  574:				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
    #####:  575:				*value=(float)m;
    #####:  576:				return(TIFFReadDirEntryErrOk);
        -:  577:			}
    #####:  578:		case TIFF_SLONG:
        -:  579:			{
    #####:  580:				int32 m;
    #####:  581:				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
    #####:  582:				*value=(float)m;
    #####:  583:				return(TIFFReadDirEntryErrOk);
        -:  584:			}
    #####:  585:		case TIFF_LONG8:
        -:  586:			{
    #####:  587:				uint64 m;
    #####:  588:				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
    #####:  589:				if (err!=TIFFReadDirEntryErrOk)
    #####:  590:					return(err);
        -:  591:#if defined(__WIN32__) && (_MSC_VER < 1500)
        -:  592:				/*
        -:  593:				 * XXX: MSVC 6.0 does not support conversion
        -:  594:				 * of 64-bit integers into floating point
        -:  595:				 * values.
        -:  596:				 */
        -:  597:				*value = _TIFFUInt64ToFloat(m);
        -:  598:#else
    #####:  599:				*value=(float)m;
        -:  600:#endif
    #####:  601:				return(TIFFReadDirEntryErrOk);
        -:  602:			}
    #####:  603:		case TIFF_SLONG8:
        -:  604:			{
    #####:  605:				int64 m;
    #####:  606:				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
    #####:  607:				if (err!=TIFFReadDirEntryErrOk)
    #####:  608:					return(err);
    #####:  609:				*value=(float)m;
    #####:  610:				return(TIFFReadDirEntryErrOk);
        -:  611:			}
    #####:  612:		case TIFF_RATIONAL:
        -:  613:			{
    #####:  614:				double m;
    #####:  615:				err=TIFFReadDirEntryCheckedRational(tif,direntry,&m);
    #####:  616:				if (err!=TIFFReadDirEntryErrOk)
    #####:  617:					return(err);
    #####:  618:				*value=(float)m;
    #####:  619:				return(TIFFReadDirEntryErrOk);
        -:  620:			}
    #####:  621:		case TIFF_SRATIONAL:
        -:  622:			{
    #####:  623:				double m;
    #####:  624:				err=TIFFReadDirEntryCheckedSrational(tif,direntry,&m);
    #####:  625:				if (err!=TIFFReadDirEntryErrOk)
    #####:  626:					return(err);
    #####:  627:				*value=(float)m;
    #####:  628:				return(TIFFReadDirEntryErrOk);
        -:  629:			}
    #####:  630:		case TIFF_FLOAT:
    #####:  631:			TIFFReadDirEntryCheckedFloat(tif,direntry,value);
    #####:  632:			return(TIFFReadDirEntryErrOk);
    #####:  633:		case TIFF_DOUBLE:
        -:  634:			{
    #####:  635:				double m;
    #####:  636:				err=TIFFReadDirEntryCheckedDouble(tif,direntry,&m);
    #####:  637:				if (err!=TIFFReadDirEntryErrOk)
    #####:  638:					return(err);
    #####:  639:				*value=(float)m;
    #####:  640:				return(TIFFReadDirEntryErrOk);
        -:  641:			}
    #####:  642:		default:
    #####:  643:			return(TIFFReadDirEntryErrType);
        -:  644:	}
        -:  645:}
        -:  646:
        2:  647:static enum TIFFReadDirEntryErr TIFFReadDirEntryDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)
        -:  648:{
        -:  649:	enum TIFFReadDirEntryErr err;
        2:  650:	if (direntry->tdir_count!=1)
    #####:  651:		return(TIFFReadDirEntryErrCount);
        2:  652:	switch (direntry->tdir_type)
        -:  653:	{
    #####:  654:		case TIFF_BYTE:
        -:  655:			{
    #####:  656:				uint8 m;
    #####:  657:				TIFFReadDirEntryCheckedByte(tif,direntry,&m);
    #####:  658:				*value=(double)m;
    #####:  659:				return(TIFFReadDirEntryErrOk);
        -:  660:			}
    #####:  661:		case TIFF_SBYTE:
        -:  662:			{
    #####:  663:				int8 m;
    #####:  664:				TIFFReadDirEntryCheckedSbyte(tif,direntry,&m);
    #####:  665:				*value=(double)m;
    #####:  666:				return(TIFFReadDirEntryErrOk);
        -:  667:			}
    #####:  668:		case TIFF_SHORT:
        -:  669:			{
    #####:  670:				uint16 m;
    #####:  671:				TIFFReadDirEntryCheckedShort(tif,direntry,&m);
    #####:  672:				*value=(double)m;
    #####:  673:				return(TIFFReadDirEntryErrOk);
        -:  674:			}
    #####:  675:		case TIFF_SSHORT:
        -:  676:			{
    #####:  677:				int16 m;
    #####:  678:				TIFFReadDirEntryCheckedSshort(tif,direntry,&m);
    #####:  679:				*value=(double)m;
    #####:  680:				return(TIFFReadDirEntryErrOk);
        -:  681:			}
    #####:  682:		case TIFF_LONG:
        -:  683:			{
    #####:  684:				uint32 m;
    #####:  685:				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
    #####:  686:				*value=(double)m;
    #####:  687:				return(TIFFReadDirEntryErrOk);
        -:  688:			}
    #####:  689:		case TIFF_SLONG:
        -:  690:			{
    #####:  691:				int32 m;
    #####:  692:				TIFFReadDirEntryCheckedSlong(tif,direntry,&m);
    #####:  693:				*value=(double)m;
    #####:  694:				return(TIFFReadDirEntryErrOk);
        -:  695:			}
    #####:  696:		case TIFF_LONG8:
        -:  697:			{
    #####:  698:				uint64 m;
    #####:  699:				err=TIFFReadDirEntryCheckedLong8(tif,direntry,&m);
    #####:  700:				if (err!=TIFFReadDirEntryErrOk)
    #####:  701:					return(err);
        -:  702:#if defined(__WIN32__) && (_MSC_VER < 1500)
        -:  703:				/*
        -:  704:				 * XXX: MSVC 6.0 does not support conversion
        -:  705:				 * of 64-bit integers into floating point
        -:  706:				 * values.
        -:  707:				 */
        -:  708:				*value = _TIFFUInt64ToDouble(m);
        -:  709:#else
    #####:  710:				*value = (double)m;
        -:  711:#endif
    #####:  712:				return(TIFFReadDirEntryErrOk);
        -:  713:			}
    #####:  714:		case TIFF_SLONG8:
        -:  715:			{
    #####:  716:				int64 m;
    #####:  717:				err=TIFFReadDirEntryCheckedSlong8(tif,direntry,&m);
    #####:  718:				if (err!=TIFFReadDirEntryErrOk)
    #####:  719:					return(err);
    #####:  720:				*value=(double)m;
    #####:  721:				return(TIFFReadDirEntryErrOk);
        -:  722:			}
        1:  723:		case TIFF_RATIONAL:
        1:  724:			err=TIFFReadDirEntryCheckedRational(tif,direntry,value);
        1:  725:			return(err);
    #####:  726:		case TIFF_SRATIONAL:
    #####:  727:			err=TIFFReadDirEntryCheckedSrational(tif,direntry,value);
    #####:  728:			return(err);
        1:  729:		case TIFF_FLOAT:
        -:  730:			{
        1:  731:				float m;
        1:  732:				TIFFReadDirEntryCheckedFloat(tif,direntry,&m);
        1:  733:				*value=(double)m;
        1:  734:				return(TIFFReadDirEntryErrOk);
        -:  735:			}
    #####:  736:		case TIFF_DOUBLE:
    #####:  737:			err=TIFFReadDirEntryCheckedDouble(tif,direntry,value);
    #####:  738:			return(err);
    #####:  739:		default:
    #####:  740:			return(TIFFReadDirEntryErrType);
        -:  741:	}
        -:  742:}
        -:  743:
    #####:  744:static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)
        -:  745:{
        -:  746:	enum TIFFReadDirEntryErr err;
    #####:  747:	if (direntry->tdir_count!=1)
    #####:  748:		return(TIFFReadDirEntryErrCount);
    #####:  749:	switch (direntry->tdir_type)
        -:  750:	{
    #####:  751:		case TIFF_LONG:
        -:  752:		case TIFF_IFD:
        -:  753:			{
    #####:  754:				uint32 m;
    #####:  755:				TIFFReadDirEntryCheckedLong(tif,direntry,&m);
    #####:  756:				*value=(uint64)m;
    #####:  757:				return(TIFFReadDirEntryErrOk);
        -:  758:			}
    #####:  759:		case TIFF_LONG8:
        -:  760:		case TIFF_IFD8:
    #####:  761:			err=TIFFReadDirEntryCheckedLong8(tif,direntry,value);
    #####:  762:			return(err);
    #####:  763:		default:
    #####:  764:			return(TIFFReadDirEntryErrType);
        -:  765:	}
        -:  766:}
        -:  767:
        8:  768:static enum TIFFReadDirEntryErr TIFFReadDirEntryArray(TIFF* tif, TIFFDirEntry* direntry, uint32* count, uint32 desttypesize, void** value)
        -:  769:{
        -:  770:	int typesize;
        -:  771:	uint32 datasize;
        -:  772:	void* data;
        8:  773:	typesize=TIFFDataWidth(direntry->tdir_type);
        8:  774:	if ((direntry->tdir_count==0)||(typesize==0))
        -:  775:	{
    #####:  776:		*value=0;
    #####:  777:		return(TIFFReadDirEntryErrOk);
        -:  778:	}
        -:  779:        (void) desttypesize;
        -:  780:
        -:  781:        /* 
        -:  782:         * As a sanity check, make sure we have no more than a 2GB tag array 
        -:  783:         * in either the current data type or the dest data type.  This also
        -:  784:         * avoids problems with overflow of tmsize_t on 32bit systems.
        -:  785:         */
       8*:  786:	if ((uint64)(2147483647/typesize)<direntry->tdir_count)
        1:  787:		return(TIFFReadDirEntryErrSizesan);
       7*:  788:	if ((uint64)(2147483647/desttypesize)<direntry->tdir_count)
    #####:  789:		return(TIFFReadDirEntryErrSizesan);
        -:  790:
        7:  791:	*count=(uint32)direntry->tdir_count;
        7:  792:	datasize=(*count)*typesize;
       7*:  793:	assert((tmsize_t)datasize>0);
        7:  794:	data=_TIFFCheckMalloc(tif, *count, typesize, "ReadDirEntryArray");
        7:  795:	if (data==0)
    #####:  796:		return(TIFFReadDirEntryErrAlloc);
        7:  797:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -:  798:	{
    #####:  799:		if (datasize<=4)
    #####:  800:			_TIFFmemcpy(data,&direntry->tdir_offset,datasize);
        -:  801:		else
        -:  802:		{
        -:  803:			enum TIFFReadDirEntryErr err;
    #####:  804:			uint32 offset = direntry->tdir_offset.toff_long;
    #####:  805:			if (tif->tif_flags&TIFF_SWAB)
    #####:  806:				TIFFSwabLong(&offset);
    #####:  807:			err=TIFFReadDirEntryData(tif,(uint64)offset,(tmsize_t)datasize,data);
    #####:  808:			if (err!=TIFFReadDirEntryErrOk)
        -:  809:			{
    #####:  810:				_TIFFfree(data);
    #####:  811:				return(err);
        -:  812:			}
        -:  813:		}
        -:  814:	}
        -:  815:	else
        -:  816:	{
        7:  817:		if (datasize<=8)
        6:  818:			_TIFFmemcpy(data,&direntry->tdir_offset,datasize);
        -:  819:		else
        -:  820:		{
        -:  821:			enum TIFFReadDirEntryErr err;
        1:  822:			uint64 offset = direntry->tdir_offset.toff_long8;
        1:  823:			if (tif->tif_flags&TIFF_SWAB)
    #####:  824:				TIFFSwabLong8(&offset);
        1:  825:			err=TIFFReadDirEntryData(tif,offset,(tmsize_t)datasize,data);
        1:  826:			if (err!=TIFFReadDirEntryErrOk)
        -:  827:			{
    #####:  828:				_TIFFfree(data);
    #####:  829:				return(err);
        -:  830:			}
        -:  831:		}
        -:  832:	}
        7:  833:	*value=data;
        7:  834:	return(TIFFReadDirEntryErrOk);
        -:  835:}
        -:  836:
        3:  837:static enum TIFFReadDirEntryErr TIFFReadDirEntryByteArray(TIFF* tif, TIFFDirEntry* direntry, uint8** value)
        -:  838:{
        -:  839:	enum TIFFReadDirEntryErr err;
        3:  840:	uint32 count;
        3:  841:	void* origdata;
        -:  842:	uint8* data;
        3:  843:	switch (direntry->tdir_type)
        -:  844:	{
        3:  845:		case TIFF_ASCII:
        -:  846:		case TIFF_UNDEFINED:
        -:  847:		case TIFF_BYTE:
        -:  848:		case TIFF_SBYTE:
        -:  849:		case TIFF_SHORT:
        -:  850:		case TIFF_SSHORT:
        -:  851:		case TIFF_LONG:
        -:  852:		case TIFF_SLONG:
        -:  853:		case TIFF_LONG8:
        -:  854:		case TIFF_SLONG8:
        3:  855:			break;
    #####:  856:		default:
    #####:  857:			return(TIFFReadDirEntryErrType);
        -:  858:	}
        3:  859:	err=TIFFReadDirEntryArray(tif,direntry,&count,1,&origdata);
        3:  860:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -:  861:	{
        1:  862:		*value=0;
        1:  863:		return(err);
        -:  864:	}
        2:  865:	switch (direntry->tdir_type)
        -:  866:	{
        1:  867:		case TIFF_ASCII:
        -:  868:		case TIFF_UNDEFINED:
        -:  869:		case TIFF_BYTE:
        1:  870:			*value=(uint8*)origdata;
        1:  871:			return(TIFFReadDirEntryErrOk);
    #####:  872:		case TIFF_SBYTE:
        -:  873:			{
        -:  874:				int8* m;
        -:  875:				uint32 n;
    #####:  876:				m=(int8*)origdata;
    #####:  877:				for (n=0; n<count; n++)
        -:  878:				{
    #####:  879:					err=TIFFReadDirEntryCheckRangeByteSbyte(*m);
    #####:  880:					if (err!=TIFFReadDirEntryErrOk)
        -:  881:					{
    #####:  882:						_TIFFfree(origdata);
    #####:  883:						return(err);
        -:  884:					}
    #####:  885:					m++;
        -:  886:				}
    #####:  887:				*value=(uint8*)origdata;
    #####:  888:				return(TIFFReadDirEntryErrOk);
        -:  889:			}
        -:  890:	}
        1:  891:	data=(uint8*)_TIFFmalloc(count);
        1:  892:	if (data==0)
        -:  893:	{
    #####:  894:		_TIFFfree(origdata);
    #####:  895:		return(TIFFReadDirEntryErrAlloc);
        -:  896:	}
        1:  897:	switch (direntry->tdir_type)
        -:  898:	{
        1:  899:		case TIFF_SHORT:
        -:  900:			{
        -:  901:				uint16* ma;
        -:  902:				uint8* mb;
        -:  903:				uint32 n;
        1:  904:				ma=(uint16*)origdata;
        1:  905:				mb=data;
        5:  906:				for (n=0; n<count; n++)
        -:  907:				{
        4:  908:					if (tif->tif_flags&TIFF_SWAB)
    #####:  909:						TIFFSwabShort(ma);
        4:  910:					err=TIFFReadDirEntryCheckRangeByteShort(*ma);
        4:  911:					if (err!=TIFFReadDirEntryErrOk)
    #####:  912:						break;
        4:  913:					*mb++=(uint8)(*ma++);
        -:  914:				}
        -:  915:			}
        1:  916:			break;
    #####:  917:		case TIFF_SSHORT:
        -:  918:			{
        -:  919:				int16* ma;
        -:  920:				uint8* mb;
        -:  921:				uint32 n;
    #####:  922:				ma=(int16*)origdata;
    #####:  923:				mb=data;
    #####:  924:				for (n=0; n<count; n++)
        -:  925:				{
    #####:  926:					if (tif->tif_flags&TIFF_SWAB)
    #####:  927:						TIFFSwabShort((uint16*)ma);
    #####:  928:					err=TIFFReadDirEntryCheckRangeByteSshort(*ma);
    #####:  929:					if (err!=TIFFReadDirEntryErrOk)
    #####:  930:						break;
    #####:  931:					*mb++=(uint8)(*ma++);
        -:  932:				}
        -:  933:			}
    #####:  934:			break;
    #####:  935:		case TIFF_LONG:
        -:  936:			{
        -:  937:				uint32* ma;
        -:  938:				uint8* mb;
        -:  939:				uint32 n;
    #####:  940:				ma=(uint32*)origdata;
    #####:  941:				mb=data;
    #####:  942:				for (n=0; n<count; n++)
        -:  943:				{
    #####:  944:					if (tif->tif_flags&TIFF_SWAB)
    #####:  945:						TIFFSwabLong(ma);
    #####:  946:					err=TIFFReadDirEntryCheckRangeByteLong(*ma);
    #####:  947:					if (err!=TIFFReadDirEntryErrOk)
    #####:  948:						break;
    #####:  949:					*mb++=(uint8)(*ma++);
        -:  950:				}
        -:  951:			}
    #####:  952:			break;
    #####:  953:		case TIFF_SLONG:
        -:  954:			{
        -:  955:				int32* ma;
        -:  956:				uint8* mb;
        -:  957:				uint32 n;
    #####:  958:				ma=(int32*)origdata;
    #####:  959:				mb=data;
    #####:  960:				for (n=0; n<count; n++)
        -:  961:				{
    #####:  962:					if (tif->tif_flags&TIFF_SWAB)
    #####:  963:						TIFFSwabLong((uint32*)ma);
    #####:  964:					err=TIFFReadDirEntryCheckRangeByteSlong(*ma);
    #####:  965:					if (err!=TIFFReadDirEntryErrOk)
    #####:  966:						break;
    #####:  967:					*mb++=(uint8)(*ma++);
        -:  968:				}
        -:  969:			}
    #####:  970:			break;
    #####:  971:		case TIFF_LONG8:
        -:  972:			{
        -:  973:				uint64* ma;
        -:  974:				uint8* mb;
        -:  975:				uint32 n;
    #####:  976:				ma=(uint64*)origdata;
    #####:  977:				mb=data;
    #####:  978:				for (n=0; n<count; n++)
        -:  979:				{
    #####:  980:					if (tif->tif_flags&TIFF_SWAB)
    #####:  981:						TIFFSwabLong8(ma);
    #####:  982:					err=TIFFReadDirEntryCheckRangeByteLong8(*ma);
    #####:  983:					if (err!=TIFFReadDirEntryErrOk)
    #####:  984:						break;
    #####:  985:					*mb++=(uint8)(*ma++);
        -:  986:				}
        -:  987:			}
    #####:  988:			break;
    #####:  989:		case TIFF_SLONG8:
        -:  990:			{
        -:  991:				int64* ma;
        -:  992:				uint8* mb;
        -:  993:				uint32 n;
    #####:  994:				ma=(int64*)origdata;
    #####:  995:				mb=data;
    #####:  996:				for (n=0; n<count; n++)
        -:  997:				{
    #####:  998:					if (tif->tif_flags&TIFF_SWAB)
    #####:  999:						TIFFSwabLong8((uint64*)ma);
    #####: 1000:					err=TIFFReadDirEntryCheckRangeByteSlong8(*ma);
    #####: 1001:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1002:						break;
    #####: 1003:					*mb++=(uint8)(*ma++);
        -: 1004:				}
        -: 1005:			}
    #####: 1006:			break;
        -: 1007:	}
        1: 1008:	_TIFFfree(origdata);
        1: 1009:	if (err!=TIFFReadDirEntryErrOk)
        -: 1010:	{
    #####: 1011:		_TIFFfree(data);
    #####: 1012:		return(err);
        -: 1013:	}
        1: 1014:	*value=data;
        1: 1015:	return(TIFFReadDirEntryErrOk);
        -: 1016:}
        -: 1017:
    #####: 1018:static enum TIFFReadDirEntryErr TIFFReadDirEntrySbyteArray(TIFF* tif, TIFFDirEntry* direntry, int8** value)
        -: 1019:{
        -: 1020:	enum TIFFReadDirEntryErr err;
    #####: 1021:	uint32 count;
    #####: 1022:	void* origdata;
        -: 1023:	int8* data;
    #####: 1024:	switch (direntry->tdir_type)
        -: 1025:	{
    #####: 1026:		case TIFF_UNDEFINED:
        -: 1027:		case TIFF_BYTE:
        -: 1028:		case TIFF_SBYTE:
        -: 1029:		case TIFF_SHORT:
        -: 1030:		case TIFF_SSHORT:
        -: 1031:		case TIFF_LONG:
        -: 1032:		case TIFF_SLONG:
        -: 1033:		case TIFF_LONG8:
        -: 1034:		case TIFF_SLONG8:
    #####: 1035:			break;
    #####: 1036:		default:
    #####: 1037:			return(TIFFReadDirEntryErrType);
        -: 1038:	}
    #####: 1039:	err=TIFFReadDirEntryArray(tif,direntry,&count,1,&origdata);
    #####: 1040:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 1041:	{
    #####: 1042:		*value=0;
    #####: 1043:		return(err);
        -: 1044:	}
    #####: 1045:	switch (direntry->tdir_type)
        -: 1046:	{
    #####: 1047:		case TIFF_UNDEFINED:
        -: 1048:		case TIFF_BYTE:
        -: 1049:			{
        -: 1050:				uint8* m;
        -: 1051:				uint32 n;
    #####: 1052:				m=(uint8*)origdata;
    #####: 1053:				for (n=0; n<count; n++)
        -: 1054:				{
    #####: 1055:					err=TIFFReadDirEntryCheckRangeSbyteByte(*m);
    #####: 1056:					if (err!=TIFFReadDirEntryErrOk)
        -: 1057:					{
    #####: 1058:						_TIFFfree(origdata);
    #####: 1059:						return(err);
        -: 1060:					}
    #####: 1061:					m++;
        -: 1062:				}
    #####: 1063:				*value=(int8*)origdata;
    #####: 1064:				return(TIFFReadDirEntryErrOk);
        -: 1065:			}
    #####: 1066:		case TIFF_SBYTE:
    #####: 1067:			*value=(int8*)origdata;
    #####: 1068:			return(TIFFReadDirEntryErrOk);
        -: 1069:	}
    #####: 1070:	data=(int8*)_TIFFmalloc(count);
    #####: 1071:	if (data==0)
        -: 1072:	{
    #####: 1073:		_TIFFfree(origdata);
    #####: 1074:		return(TIFFReadDirEntryErrAlloc);
        -: 1075:	}
    #####: 1076:	switch (direntry->tdir_type)
        -: 1077:	{
    #####: 1078:		case TIFF_SHORT:
        -: 1079:			{
        -: 1080:				uint16* ma;
        -: 1081:				int8* mb;
        -: 1082:				uint32 n;
    #####: 1083:				ma=(uint16*)origdata;
    #####: 1084:				mb=data;
    #####: 1085:				for (n=0; n<count; n++)
        -: 1086:				{
    #####: 1087:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1088:						TIFFSwabShort(ma);
    #####: 1089:					err=TIFFReadDirEntryCheckRangeSbyteShort(*ma);
    #####: 1090:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1091:						break;
    #####: 1092:					*mb++=(int8)(*ma++);
        -: 1093:				}
        -: 1094:			}
    #####: 1095:			break;
    #####: 1096:		case TIFF_SSHORT:
        -: 1097:			{
        -: 1098:				int16* ma;
        -: 1099:				int8* mb;
        -: 1100:				uint32 n;
    #####: 1101:				ma=(int16*)origdata;
    #####: 1102:				mb=data;
    #####: 1103:				for (n=0; n<count; n++)
        -: 1104:				{
    #####: 1105:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1106:						TIFFSwabShort((uint16*)ma);
    #####: 1107:					err=TIFFReadDirEntryCheckRangeSbyteSshort(*ma);
    #####: 1108:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1109:						break;
    #####: 1110:					*mb++=(int8)(*ma++);
        -: 1111:				}
        -: 1112:			}
    #####: 1113:			break;
    #####: 1114:		case TIFF_LONG:
        -: 1115:			{
        -: 1116:				uint32* ma;
        -: 1117:				int8* mb;
        -: 1118:				uint32 n;
    #####: 1119:				ma=(uint32*)origdata;
    #####: 1120:				mb=data;
    #####: 1121:				for (n=0; n<count; n++)
        -: 1122:				{
    #####: 1123:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1124:						TIFFSwabLong(ma);
    #####: 1125:					err=TIFFReadDirEntryCheckRangeSbyteLong(*ma);
    #####: 1126:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1127:						break;
    #####: 1128:					*mb++=(int8)(*ma++);
        -: 1129:				}
        -: 1130:			}
    #####: 1131:			break;
    #####: 1132:		case TIFF_SLONG:
        -: 1133:			{
        -: 1134:				int32* ma;
        -: 1135:				int8* mb;
        -: 1136:				uint32 n;
    #####: 1137:				ma=(int32*)origdata;
    #####: 1138:				mb=data;
    #####: 1139:				for (n=0; n<count; n++)
        -: 1140:				{
    #####: 1141:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1142:						TIFFSwabLong((uint32*)ma);
    #####: 1143:					err=TIFFReadDirEntryCheckRangeSbyteSlong(*ma);
    #####: 1144:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1145:						break;
    #####: 1146:					*mb++=(int8)(*ma++);
        -: 1147:				}
        -: 1148:			}
    #####: 1149:			break;
    #####: 1150:		case TIFF_LONG8:
        -: 1151:			{
        -: 1152:				uint64* ma;
        -: 1153:				int8* mb;
        -: 1154:				uint32 n;
    #####: 1155:				ma=(uint64*)origdata;
    #####: 1156:				mb=data;
    #####: 1157:				for (n=0; n<count; n++)
        -: 1158:				{
    #####: 1159:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1160:						TIFFSwabLong8(ma);
    #####: 1161:					err=TIFFReadDirEntryCheckRangeSbyteLong8(*ma);
    #####: 1162:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1163:						break;
    #####: 1164:					*mb++=(int8)(*ma++);
        -: 1165:				}
        -: 1166:			}
    #####: 1167:			break;
    #####: 1168:		case TIFF_SLONG8:
        -: 1169:			{
        -: 1170:				int64* ma;
        -: 1171:				int8* mb;
        -: 1172:				uint32 n;
    #####: 1173:				ma=(int64*)origdata;
    #####: 1174:				mb=data;
    #####: 1175:				for (n=0; n<count; n++)
        -: 1176:				{
    #####: 1177:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1178:						TIFFSwabLong8((uint64*)ma);
    #####: 1179:					err=TIFFReadDirEntryCheckRangeSbyteSlong8(*ma);
    #####: 1180:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1181:						break;
    #####: 1182:					*mb++=(int8)(*ma++);
        -: 1183:				}
        -: 1184:			}
    #####: 1185:			break;
        -: 1186:	}
    #####: 1187:	_TIFFfree(origdata);
    #####: 1188:	if (err!=TIFFReadDirEntryErrOk)
        -: 1189:	{
    #####: 1190:		_TIFFfree(data);
    #####: 1191:		return(err);
        -: 1192:	}
    #####: 1193:	*value=data;
    #####: 1194:	return(TIFFReadDirEntryErrOk);
        -: 1195:}
        -: 1196:
        3: 1197:static enum TIFFReadDirEntryErr TIFFReadDirEntryShortArray(TIFF* tif, TIFFDirEntry* direntry, uint16** value)
        -: 1198:{
        -: 1199:	enum TIFFReadDirEntryErr err;
        3: 1200:	uint32 count;
        3: 1201:	void* origdata;
        -: 1202:	uint16* data;
        3: 1203:	switch (direntry->tdir_type)
        -: 1204:	{
        3: 1205:		case TIFF_BYTE:
        -: 1206:		case TIFF_SBYTE:
        -: 1207:		case TIFF_SHORT:
        -: 1208:		case TIFF_SSHORT:
        -: 1209:		case TIFF_LONG:
        -: 1210:		case TIFF_SLONG:
        -: 1211:		case TIFF_LONG8:
        -: 1212:		case TIFF_SLONG8:
        3: 1213:			break;
    #####: 1214:		default:
    #####: 1215:			return(TIFFReadDirEntryErrType);
        -: 1216:	}
        3: 1217:	err=TIFFReadDirEntryArray(tif,direntry,&count,2,&origdata);
        3: 1218:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 1219:	{
    #####: 1220:		*value=0;
    #####: 1221:		return(err);
        -: 1222:	}
        3: 1223:	switch (direntry->tdir_type)
        -: 1224:	{
        3: 1225:		case TIFF_SHORT:
        3: 1226:			*value=(uint16*)origdata;
        3: 1227:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1228:				TIFFSwabArrayOfShort(*value,count);  
        3: 1229:			return(TIFFReadDirEntryErrOk);
    #####: 1230:		case TIFF_SSHORT:
        -: 1231:			{
        -: 1232:				int16* m;
        -: 1233:				uint32 n;
    #####: 1234:				m=(int16*)origdata;
    #####: 1235:				for (n=0; n<count; n++)
        -: 1236:				{
    #####: 1237:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1238:						TIFFSwabShort((uint16*)m);
    #####: 1239:					err=TIFFReadDirEntryCheckRangeShortSshort(*m);
    #####: 1240:					if (err!=TIFFReadDirEntryErrOk)
        -: 1241:					{
    #####: 1242:						_TIFFfree(origdata);
    #####: 1243:						return(err);
        -: 1244:					}
    #####: 1245:					m++;
        -: 1246:				}
    #####: 1247:				*value=(uint16*)origdata;
    #####: 1248:				return(TIFFReadDirEntryErrOk);
        -: 1249:			}
        -: 1250:	}
    #####: 1251:	data=(uint16*)_TIFFmalloc(count*2);
    #####: 1252:	if (data==0)
        -: 1253:	{
    #####: 1254:		_TIFFfree(origdata);
    #####: 1255:		return(TIFFReadDirEntryErrAlloc);
        -: 1256:	}
    #####: 1257:	switch (direntry->tdir_type)
        -: 1258:	{
    #####: 1259:		case TIFF_BYTE:
        -: 1260:			{
        -: 1261:				uint8* ma;
        -: 1262:				uint16* mb;
        -: 1263:				uint32 n;
    #####: 1264:				ma=(uint8*)origdata;
    #####: 1265:				mb=data;
    #####: 1266:				for (n=0; n<count; n++)
    #####: 1267:					*mb++=(uint16)(*ma++);
        -: 1268:			}
    #####: 1269:			break;
    #####: 1270:		case TIFF_SBYTE:
        -: 1271:			{
        -: 1272:				int8* ma;
        -: 1273:				uint16* mb;
        -: 1274:				uint32 n;
    #####: 1275:				ma=(int8*)origdata;
    #####: 1276:				mb=data;
    #####: 1277:				for (n=0; n<count; n++)
        -: 1278:				{
    #####: 1279:					err=TIFFReadDirEntryCheckRangeShortSbyte(*ma);
    #####: 1280:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1281:						break;
    #####: 1282:					*mb++=(uint16)(*ma++);
        -: 1283:				}
        -: 1284:			}
    #####: 1285:			break;
    #####: 1286:		case TIFF_LONG:
        -: 1287:			{
        -: 1288:				uint32* ma;
        -: 1289:				uint16* mb;
        -: 1290:				uint32 n;
    #####: 1291:				ma=(uint32*)origdata;
    #####: 1292:				mb=data;
    #####: 1293:				for (n=0; n<count; n++)
        -: 1294:				{
    #####: 1295:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1296:						TIFFSwabLong(ma);
    #####: 1297:					err=TIFFReadDirEntryCheckRangeShortLong(*ma);
    #####: 1298:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1299:						break;
    #####: 1300:					*mb++=(uint16)(*ma++);
        -: 1301:				}
        -: 1302:			}
    #####: 1303:			break;
    #####: 1304:		case TIFF_SLONG:
        -: 1305:			{
        -: 1306:				int32* ma;
        -: 1307:				uint16* mb;
        -: 1308:				uint32 n;
    #####: 1309:				ma=(int32*)origdata;
    #####: 1310:				mb=data;
    #####: 1311:				for (n=0; n<count; n++)
        -: 1312:				{
    #####: 1313:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1314:						TIFFSwabLong((uint32*)ma);
    #####: 1315:					err=TIFFReadDirEntryCheckRangeShortSlong(*ma);
    #####: 1316:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1317:						break;
    #####: 1318:					*mb++=(uint16)(*ma++);
        -: 1319:				}
        -: 1320:			}
    #####: 1321:			break;
    #####: 1322:		case TIFF_LONG8:
        -: 1323:			{
        -: 1324:				uint64* ma;
        -: 1325:				uint16* mb;
        -: 1326:				uint32 n;
    #####: 1327:				ma=(uint64*)origdata;
    #####: 1328:				mb=data;
    #####: 1329:				for (n=0; n<count; n++)
        -: 1330:				{
    #####: 1331:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1332:						TIFFSwabLong8(ma);
    #####: 1333:					err=TIFFReadDirEntryCheckRangeShortLong8(*ma);
    #####: 1334:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1335:						break;
    #####: 1336:					*mb++=(uint16)(*ma++);
        -: 1337:				}
        -: 1338:			}
    #####: 1339:			break;
    #####: 1340:		case TIFF_SLONG8:
        -: 1341:			{
        -: 1342:				int64* ma;
        -: 1343:				uint16* mb;
        -: 1344:				uint32 n;
    #####: 1345:				ma=(int64*)origdata;
    #####: 1346:				mb=data;
    #####: 1347:				for (n=0; n<count; n++)
        -: 1348:				{
    #####: 1349:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1350:						TIFFSwabLong8((uint64*)ma);
    #####: 1351:					err=TIFFReadDirEntryCheckRangeShortSlong8(*ma);
    #####: 1352:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1353:						break;
    #####: 1354:					*mb++=(uint16)(*ma++);
        -: 1355:				}
        -: 1356:			}
    #####: 1357:			break;
        -: 1358:	}
    #####: 1359:	_TIFFfree(origdata);
    #####: 1360:	if (err!=TIFFReadDirEntryErrOk)
        -: 1361:	{
    #####: 1362:		_TIFFfree(data);
    #####: 1363:		return(err);
        -: 1364:	}
    #####: 1365:	*value=data;
    #####: 1366:	return(TIFFReadDirEntryErrOk);
        -: 1367:}
        -: 1368:
    #####: 1369:static enum TIFFReadDirEntryErr TIFFReadDirEntrySshortArray(TIFF* tif, TIFFDirEntry* direntry, int16** value)
        -: 1370:{
        -: 1371:	enum TIFFReadDirEntryErr err;
    #####: 1372:	uint32 count;
    #####: 1373:	void* origdata;
        -: 1374:	int16* data;
    #####: 1375:	switch (direntry->tdir_type)
        -: 1376:	{
    #####: 1377:		case TIFF_BYTE:
        -: 1378:		case TIFF_SBYTE:
        -: 1379:		case TIFF_SHORT:
        -: 1380:		case TIFF_SSHORT:
        -: 1381:		case TIFF_LONG:
        -: 1382:		case TIFF_SLONG:
        -: 1383:		case TIFF_LONG8:
        -: 1384:		case TIFF_SLONG8:
    #####: 1385:			break;
    #####: 1386:		default:
    #####: 1387:			return(TIFFReadDirEntryErrType);
        -: 1388:	}
    #####: 1389:	err=TIFFReadDirEntryArray(tif,direntry,&count,2,&origdata);
    #####: 1390:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 1391:	{
    #####: 1392:		*value=0;
    #####: 1393:		return(err);
        -: 1394:	}
    #####: 1395:	switch (direntry->tdir_type)
        -: 1396:	{
    #####: 1397:		case TIFF_SHORT:
        -: 1398:			{
        -: 1399:				uint16* m;
        -: 1400:				uint32 n;
    #####: 1401:				m=(uint16*)origdata;
    #####: 1402:				for (n=0; n<count; n++)
        -: 1403:				{
    #####: 1404:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1405:						TIFFSwabShort(m);
    #####: 1406:					err=TIFFReadDirEntryCheckRangeSshortShort(*m);
    #####: 1407:					if (err!=TIFFReadDirEntryErrOk)
        -: 1408:					{
    #####: 1409:						_TIFFfree(origdata);
    #####: 1410:						return(err);
        -: 1411:					}
    #####: 1412:					m++;
        -: 1413:				}
    #####: 1414:				*value=(int16*)origdata;
    #####: 1415:				return(TIFFReadDirEntryErrOk);
        -: 1416:			}
    #####: 1417:		case TIFF_SSHORT:
    #####: 1418:			*value=(int16*)origdata;
    #####: 1419:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1420:				TIFFSwabArrayOfShort((uint16*)(*value),count);
    #####: 1421:			return(TIFFReadDirEntryErrOk);
        -: 1422:	}
    #####: 1423:	data=(int16*)_TIFFmalloc(count*2);
    #####: 1424:	if (data==0)
        -: 1425:	{
    #####: 1426:		_TIFFfree(origdata);
    #####: 1427:		return(TIFFReadDirEntryErrAlloc);
        -: 1428:	}
    #####: 1429:	switch (direntry->tdir_type)
        -: 1430:	{
    #####: 1431:		case TIFF_BYTE:
        -: 1432:			{
        -: 1433:				uint8* ma;
        -: 1434:				int16* mb;
        -: 1435:				uint32 n;
    #####: 1436:				ma=(uint8*)origdata;
    #####: 1437:				mb=data;
    #####: 1438:				for (n=0; n<count; n++)
    #####: 1439:					*mb++=(int16)(*ma++);
        -: 1440:			}
    #####: 1441:			break;
    #####: 1442:		case TIFF_SBYTE:
        -: 1443:			{
        -: 1444:				int8* ma;
        -: 1445:				int16* mb;
        -: 1446:				uint32 n;
    #####: 1447:				ma=(int8*)origdata;
    #####: 1448:				mb=data;
    #####: 1449:				for (n=0; n<count; n++)
    #####: 1450:					*mb++=(int16)(*ma++);
        -: 1451:			}
    #####: 1452:			break;
    #####: 1453:		case TIFF_LONG:
        -: 1454:			{
        -: 1455:				uint32* ma;
        -: 1456:				int16* mb;
        -: 1457:				uint32 n;
    #####: 1458:				ma=(uint32*)origdata;
    #####: 1459:				mb=data;
    #####: 1460:				for (n=0; n<count; n++)
        -: 1461:				{
    #####: 1462:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1463:						TIFFSwabLong(ma);
    #####: 1464:					err=TIFFReadDirEntryCheckRangeSshortLong(*ma);
    #####: 1465:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1466:						break;
    #####: 1467:					*mb++=(int16)(*ma++);
        -: 1468:				}
        -: 1469:			}
    #####: 1470:			break;
    #####: 1471:		case TIFF_SLONG:
        -: 1472:			{
        -: 1473:				int32* ma;
        -: 1474:				int16* mb;
        -: 1475:				uint32 n;
    #####: 1476:				ma=(int32*)origdata;
    #####: 1477:				mb=data;
    #####: 1478:				for (n=0; n<count; n++)
        -: 1479:				{
    #####: 1480:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1481:						TIFFSwabLong((uint32*)ma);
    #####: 1482:					err=TIFFReadDirEntryCheckRangeSshortSlong(*ma);
    #####: 1483:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1484:						break;
    #####: 1485:					*mb++=(int16)(*ma++);
        -: 1486:				}
        -: 1487:			}
    #####: 1488:			break;
    #####: 1489:		case TIFF_LONG8:
        -: 1490:			{
        -: 1491:				uint64* ma;
        -: 1492:				int16* mb;
        -: 1493:				uint32 n;
    #####: 1494:				ma=(uint64*)origdata;
    #####: 1495:				mb=data;
    #####: 1496:				for (n=0; n<count; n++)
        -: 1497:				{
    #####: 1498:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1499:						TIFFSwabLong8(ma);
    #####: 1500:					err=TIFFReadDirEntryCheckRangeSshortLong8(*ma);
    #####: 1501:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1502:						break;
    #####: 1503:					*mb++=(int16)(*ma++);
        -: 1504:				}
        -: 1505:			}
    #####: 1506:			break;
    #####: 1507:		case TIFF_SLONG8:
        -: 1508:			{
        -: 1509:				int64* ma;
        -: 1510:				int16* mb;
        -: 1511:				uint32 n;
    #####: 1512:				ma=(int64*)origdata;
    #####: 1513:				mb=data;
    #####: 1514:				for (n=0; n<count; n++)
        -: 1515:				{
    #####: 1516:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1517:						TIFFSwabLong8((uint64*)ma);
    #####: 1518:					err=TIFFReadDirEntryCheckRangeSshortSlong8(*ma);
    #####: 1519:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1520:						break;
    #####: 1521:					*mb++=(int16)(*ma++);
        -: 1522:				}
        -: 1523:			}
    #####: 1524:			break;
        -: 1525:	}
    #####: 1526:	_TIFFfree(origdata);
    #####: 1527:	if (err!=TIFFReadDirEntryErrOk)
        -: 1528:	{
    #####: 1529:		_TIFFfree(data);
    #####: 1530:		return(err);
        -: 1531:	}
    #####: 1532:	*value=data;
    #####: 1533:	return(TIFFReadDirEntryErrOk);
        -: 1534:}
        -: 1535:
    #####: 1536:static enum TIFFReadDirEntryErr TIFFReadDirEntryLongArray(TIFF* tif, TIFFDirEntry* direntry, uint32** value)
        -: 1537:{
        -: 1538:	enum TIFFReadDirEntryErr err;
    #####: 1539:	uint32 count;
    #####: 1540:	void* origdata;
        -: 1541:	uint32* data;
    #####: 1542:	switch (direntry->tdir_type)
        -: 1543:	{
    #####: 1544:		case TIFF_BYTE:
        -: 1545:		case TIFF_SBYTE:
        -: 1546:		case TIFF_SHORT:
        -: 1547:		case TIFF_SSHORT:
        -: 1548:		case TIFF_LONG:
        -: 1549:		case TIFF_SLONG:
        -: 1550:		case TIFF_LONG8:
        -: 1551:		case TIFF_SLONG8:
    #####: 1552:			break;
    #####: 1553:		default:
    #####: 1554:			return(TIFFReadDirEntryErrType);
        -: 1555:	}
    #####: 1556:	err=TIFFReadDirEntryArray(tif,direntry,&count,4,&origdata);
    #####: 1557:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 1558:	{
    #####: 1559:		*value=0;
    #####: 1560:		return(err);
        -: 1561:	}
    #####: 1562:	switch (direntry->tdir_type)
        -: 1563:	{
    #####: 1564:		case TIFF_LONG:
    #####: 1565:			*value=(uint32*)origdata;
    #####: 1566:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1567:				TIFFSwabArrayOfLong(*value,count);
    #####: 1568:			return(TIFFReadDirEntryErrOk);
    #####: 1569:		case TIFF_SLONG:
        -: 1570:			{
        -: 1571:				int32* m;
        -: 1572:				uint32 n;
    #####: 1573:				m=(int32*)origdata;
    #####: 1574:				for (n=0; n<count; n++)
        -: 1575:				{
    #####: 1576:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1577:						TIFFSwabLong((uint32*)m);
    #####: 1578:					err=TIFFReadDirEntryCheckRangeLongSlong(*m);
    #####: 1579:					if (err!=TIFFReadDirEntryErrOk)
        -: 1580:					{
    #####: 1581:						_TIFFfree(origdata);
    #####: 1582:						return(err);
        -: 1583:					}
    #####: 1584:					m++;
        -: 1585:				}
    #####: 1586:				*value=(uint32*)origdata;
    #####: 1587:				return(TIFFReadDirEntryErrOk);
        -: 1588:			}
        -: 1589:	}
    #####: 1590:	data=(uint32*)_TIFFmalloc(count*4);
    #####: 1591:	if (data==0)
        -: 1592:	{
    #####: 1593:		_TIFFfree(origdata);
    #####: 1594:		return(TIFFReadDirEntryErrAlloc);
        -: 1595:	}
    #####: 1596:	switch (direntry->tdir_type)
        -: 1597:	{
    #####: 1598:		case TIFF_BYTE:
        -: 1599:			{
        -: 1600:				uint8* ma;
        -: 1601:				uint32* mb;
        -: 1602:				uint32 n;
    #####: 1603:				ma=(uint8*)origdata;
    #####: 1604:				mb=data;
    #####: 1605:				for (n=0; n<count; n++)
    #####: 1606:					*mb++=(uint32)(*ma++);
        -: 1607:			}
    #####: 1608:			break;
    #####: 1609:		case TIFF_SBYTE:
        -: 1610:			{
        -: 1611:				int8* ma;
        -: 1612:				uint32* mb;
        -: 1613:				uint32 n;
    #####: 1614:				ma=(int8*)origdata;
    #####: 1615:				mb=data;
    #####: 1616:				for (n=0; n<count; n++)
        -: 1617:				{
    #####: 1618:					err=TIFFReadDirEntryCheckRangeLongSbyte(*ma);
    #####: 1619:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1620:						break;
    #####: 1621:					*mb++=(uint32)(*ma++);
        -: 1622:				}
        -: 1623:			}
    #####: 1624:			break;
    #####: 1625:		case TIFF_SHORT:
        -: 1626:			{
        -: 1627:				uint16* ma;
        -: 1628:				uint32* mb;
        -: 1629:				uint32 n;
    #####: 1630:				ma=(uint16*)origdata;
    #####: 1631:				mb=data;
    #####: 1632:				for (n=0; n<count; n++)
        -: 1633:				{
    #####: 1634:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1635:						TIFFSwabShort(ma);
    #####: 1636:					*mb++=(uint32)(*ma++);
        -: 1637:				}
        -: 1638:			}
    #####: 1639:			break;
    #####: 1640:		case TIFF_SSHORT:
        -: 1641:			{
        -: 1642:				int16* ma;
        -: 1643:				uint32* mb;
        -: 1644:				uint32 n;
    #####: 1645:				ma=(int16*)origdata;
    #####: 1646:				mb=data;
    #####: 1647:				for (n=0; n<count; n++)
        -: 1648:				{
    #####: 1649:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1650:						TIFFSwabShort((uint16*)ma);
    #####: 1651:					err=TIFFReadDirEntryCheckRangeLongSshort(*ma);
    #####: 1652:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1653:						break;
    #####: 1654:					*mb++=(uint32)(*ma++);
        -: 1655:				}
        -: 1656:			}
    #####: 1657:			break;
    #####: 1658:		case TIFF_LONG8:
        -: 1659:			{
        -: 1660:				uint64* ma;
        -: 1661:				uint32* mb;
        -: 1662:				uint32 n;
    #####: 1663:				ma=(uint64*)origdata;
    #####: 1664:				mb=data;
    #####: 1665:				for (n=0; n<count; n++)
        -: 1666:				{
    #####: 1667:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1668:						TIFFSwabLong8(ma);
    #####: 1669:					err=TIFFReadDirEntryCheckRangeLongLong8(*ma);
    #####: 1670:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1671:						break;
    #####: 1672:					*mb++=(uint32)(*ma++);
        -: 1673:				}
        -: 1674:			}
    #####: 1675:			break;
    #####: 1676:		case TIFF_SLONG8:
        -: 1677:			{
        -: 1678:				int64* ma;
        -: 1679:				uint32* mb;
        -: 1680:				uint32 n;
    #####: 1681:				ma=(int64*)origdata;
    #####: 1682:				mb=data;
    #####: 1683:				for (n=0; n<count; n++)
        -: 1684:				{
    #####: 1685:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1686:						TIFFSwabLong8((uint64*)ma);
    #####: 1687:					err=TIFFReadDirEntryCheckRangeLongSlong8(*ma);
    #####: 1688:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1689:						break;
    #####: 1690:					*mb++=(uint32)(*ma++);
        -: 1691:				}
        -: 1692:			}
    #####: 1693:			break;
        -: 1694:	}
    #####: 1695:	_TIFFfree(origdata);
    #####: 1696:	if (err!=TIFFReadDirEntryErrOk)
        -: 1697:	{
    #####: 1698:		_TIFFfree(data);
    #####: 1699:		return(err);
        -: 1700:	}
    #####: 1701:	*value=data;
    #####: 1702:	return(TIFFReadDirEntryErrOk);
        -: 1703:}
        -: 1704:
    #####: 1705:static enum TIFFReadDirEntryErr TIFFReadDirEntrySlongArray(TIFF* tif, TIFFDirEntry* direntry, int32** value)
        -: 1706:{
        -: 1707:	enum TIFFReadDirEntryErr err;
    #####: 1708:	uint32 count;
    #####: 1709:	void* origdata;
        -: 1710:	int32* data;
    #####: 1711:	switch (direntry->tdir_type)
        -: 1712:	{
    #####: 1713:		case TIFF_BYTE:
        -: 1714:		case TIFF_SBYTE:
        -: 1715:		case TIFF_SHORT:
        -: 1716:		case TIFF_SSHORT:
        -: 1717:		case TIFF_LONG:
        -: 1718:		case TIFF_SLONG:
        -: 1719:		case TIFF_LONG8:
        -: 1720:		case TIFF_SLONG8:
    #####: 1721:			break;
    #####: 1722:		default:
    #####: 1723:			return(TIFFReadDirEntryErrType);
        -: 1724:	}
    #####: 1725:	err=TIFFReadDirEntryArray(tif,direntry,&count,4,&origdata);
    #####: 1726:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 1727:	{
    #####: 1728:		*value=0;
    #####: 1729:		return(err);
        -: 1730:	}
    #####: 1731:	switch (direntry->tdir_type)
        -: 1732:	{
    #####: 1733:		case TIFF_LONG:
        -: 1734:			{
        -: 1735:				uint32* m;
        -: 1736:				uint32 n;
    #####: 1737:				m=(uint32*)origdata;
    #####: 1738:				for (n=0; n<count; n++)
        -: 1739:				{
    #####: 1740:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1741:						TIFFSwabLong((uint32*)m);
    #####: 1742:					err=TIFFReadDirEntryCheckRangeSlongLong(*m);
    #####: 1743:					if (err!=TIFFReadDirEntryErrOk)
        -: 1744:					{
    #####: 1745:						_TIFFfree(origdata);
    #####: 1746:						return(err);
        -: 1747:					}
    #####: 1748:					m++;
        -: 1749:				}
    #####: 1750:				*value=(int32*)origdata;
    #####: 1751:				return(TIFFReadDirEntryErrOk);
        -: 1752:			}
    #####: 1753:		case TIFF_SLONG:
    #####: 1754:			*value=(int32*)origdata;
    #####: 1755:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1756:				TIFFSwabArrayOfLong((uint32*)(*value),count);
    #####: 1757:			return(TIFFReadDirEntryErrOk);
        -: 1758:	}
    #####: 1759:	data=(int32*)_TIFFmalloc(count*4);
    #####: 1760:	if (data==0)
        -: 1761:	{
    #####: 1762:		_TIFFfree(origdata);
    #####: 1763:		return(TIFFReadDirEntryErrAlloc);
        -: 1764:	}
    #####: 1765:	switch (direntry->tdir_type)
        -: 1766:	{
    #####: 1767:		case TIFF_BYTE:
        -: 1768:			{
        -: 1769:				uint8* ma;
        -: 1770:				int32* mb;
        -: 1771:				uint32 n;
    #####: 1772:				ma=(uint8*)origdata;
    #####: 1773:				mb=data;
    #####: 1774:				for (n=0; n<count; n++)
    #####: 1775:					*mb++=(int32)(*ma++);
        -: 1776:			}
    #####: 1777:			break;
    #####: 1778:		case TIFF_SBYTE:
        -: 1779:			{
        -: 1780:				int8* ma;
        -: 1781:				int32* mb;
        -: 1782:				uint32 n;
    #####: 1783:				ma=(int8*)origdata;
    #####: 1784:				mb=data;
    #####: 1785:				for (n=0; n<count; n++)
    #####: 1786:					*mb++=(int32)(*ma++);
        -: 1787:			}
    #####: 1788:			break;
    #####: 1789:		case TIFF_SHORT:
        -: 1790:			{
        -: 1791:				uint16* ma;
        -: 1792:				int32* mb;
        -: 1793:				uint32 n;
    #####: 1794:				ma=(uint16*)origdata;
    #####: 1795:				mb=data;
    #####: 1796:				for (n=0; n<count; n++)
        -: 1797:				{
    #####: 1798:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1799:						TIFFSwabShort(ma);
    #####: 1800:					*mb++=(int32)(*ma++);
        -: 1801:				}
        -: 1802:			}
    #####: 1803:			break;
    #####: 1804:		case TIFF_SSHORT:
        -: 1805:			{
        -: 1806:				int16* ma;
        -: 1807:				int32* mb;
        -: 1808:				uint32 n;
    #####: 1809:				ma=(int16*)origdata;
    #####: 1810:				mb=data;
    #####: 1811:				for (n=0; n<count; n++)
        -: 1812:				{
    #####: 1813:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1814:						TIFFSwabShort((uint16*)ma);
    #####: 1815:					*mb++=(int32)(*ma++);
        -: 1816:				}
        -: 1817:			}
    #####: 1818:			break;
    #####: 1819:		case TIFF_LONG8:
        -: 1820:			{
        -: 1821:				uint64* ma;
        -: 1822:				int32* mb;
        -: 1823:				uint32 n;
    #####: 1824:				ma=(uint64*)origdata;
    #####: 1825:				mb=data;
    #####: 1826:				for (n=0; n<count; n++)
        -: 1827:				{
    #####: 1828:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1829:						TIFFSwabLong8(ma);
    #####: 1830:					err=TIFFReadDirEntryCheckRangeSlongLong8(*ma);
    #####: 1831:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1832:						break;
    #####: 1833:					*mb++=(int32)(*ma++);
        -: 1834:				}
        -: 1835:			}
    #####: 1836:			break;
    #####: 1837:		case TIFF_SLONG8:
        -: 1838:			{
        -: 1839:				int64* ma;
        -: 1840:				int32* mb;
        -: 1841:				uint32 n;
    #####: 1842:				ma=(int64*)origdata;
    #####: 1843:				mb=data;
    #####: 1844:				for (n=0; n<count; n++)
        -: 1845:				{
    #####: 1846:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1847:						TIFFSwabLong8((uint64*)ma);
    #####: 1848:					err=TIFFReadDirEntryCheckRangeSlongSlong8(*ma);
    #####: 1849:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1850:						break;
    #####: 1851:					*mb++=(int32)(*ma++);
        -: 1852:				}
        -: 1853:			}
    #####: 1854:			break;
        -: 1855:	}
    #####: 1856:	_TIFFfree(origdata);
    #####: 1857:	if (err!=TIFFReadDirEntryErrOk)
        -: 1858:	{
    #####: 1859:		_TIFFfree(data);
    #####: 1860:		return(err);
        -: 1861:	}
    #####: 1862:	*value=data;
    #####: 1863:	return(TIFFReadDirEntryErrOk);
        -: 1864:}
        -: 1865:
        2: 1866:static enum TIFFReadDirEntryErr TIFFReadDirEntryLong8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)
        -: 1867:{
        -: 1868:	enum TIFFReadDirEntryErr err;
        2: 1869:	uint32 count;
        2: 1870:	void* origdata;
        -: 1871:	uint64* data;
        2: 1872:	switch (direntry->tdir_type)
        -: 1873:	{
        2: 1874:		case TIFF_BYTE:
        -: 1875:		case TIFF_SBYTE:
        -: 1876:		case TIFF_SHORT:
        -: 1877:		case TIFF_SSHORT:
        -: 1878:		case TIFF_LONG:
        -: 1879:		case TIFF_SLONG:
        -: 1880:		case TIFF_LONG8:
        -: 1881:		case TIFF_SLONG8:
        2: 1882:			break;
    #####: 1883:		default:
    #####: 1884:			return(TIFFReadDirEntryErrType);
        -: 1885:	}
        2: 1886:	err=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);
        2: 1887:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 1888:	{
    #####: 1889:		*value=0;
    #####: 1890:		return(err);
        -: 1891:	}
        2: 1892:	switch (direntry->tdir_type)
        -: 1893:	{
        2: 1894:		case TIFF_LONG8:
        2: 1895:			*value=(uint64*)origdata;
        2: 1896:			if (tif->tif_flags&TIFF_SWAB)
    #####: 1897:				TIFFSwabArrayOfLong8(*value,count);
        2: 1898:			return(TIFFReadDirEntryErrOk);
    #####: 1899:		case TIFF_SLONG8:
        -: 1900:			{
        -: 1901:				int64* m;
        -: 1902:				uint32 n;
    #####: 1903:				m=(int64*)origdata;
    #####: 1904:				for (n=0; n<count; n++)
        -: 1905:				{
    #####: 1906:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1907:						TIFFSwabLong8((uint64*)m);
    #####: 1908:					err=TIFFReadDirEntryCheckRangeLong8Slong8(*m);
    #####: 1909:					if (err!=TIFFReadDirEntryErrOk)
        -: 1910:					{
    #####: 1911:						_TIFFfree(origdata);
    #####: 1912:						return(err);
        -: 1913:					}
    #####: 1914:					m++;
        -: 1915:				}
    #####: 1916:				*value=(uint64*)origdata;
    #####: 1917:				return(TIFFReadDirEntryErrOk);
        -: 1918:			}
        -: 1919:	}
    #####: 1920:	data=(uint64*)_TIFFmalloc(count*8);
    #####: 1921:	if (data==0)
        -: 1922:	{
    #####: 1923:		_TIFFfree(origdata);
    #####: 1924:		return(TIFFReadDirEntryErrAlloc);
        -: 1925:	}
    #####: 1926:	switch (direntry->tdir_type)
        -: 1927:	{
    #####: 1928:		case TIFF_BYTE:
        -: 1929:			{
        -: 1930:				uint8* ma;
        -: 1931:				uint64* mb;
        -: 1932:				uint32 n;
    #####: 1933:				ma=(uint8*)origdata;
    #####: 1934:				mb=data;
    #####: 1935:				for (n=0; n<count; n++)
    #####: 1936:					*mb++=(uint64)(*ma++);
        -: 1937:			}
    #####: 1938:			break;
    #####: 1939:		case TIFF_SBYTE:
        -: 1940:			{
        -: 1941:				int8* ma;
        -: 1942:				uint64* mb;
        -: 1943:				uint32 n;
    #####: 1944:				ma=(int8*)origdata;
    #####: 1945:				mb=data;
    #####: 1946:				for (n=0; n<count; n++)
        -: 1947:				{
    #####: 1948:					err=TIFFReadDirEntryCheckRangeLong8Sbyte(*ma);
    #####: 1949:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1950:						break;
    #####: 1951:					*mb++=(uint64)(*ma++);
        -: 1952:				}
        -: 1953:			}
    #####: 1954:			break;
    #####: 1955:		case TIFF_SHORT:
        -: 1956:			{
        -: 1957:				uint16* ma;
        -: 1958:				uint64* mb;
        -: 1959:				uint32 n;
    #####: 1960:				ma=(uint16*)origdata;
    #####: 1961:				mb=data;
    #####: 1962:				for (n=0; n<count; n++)
        -: 1963:				{
    #####: 1964:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1965:						TIFFSwabShort(ma);
    #####: 1966:					*mb++=(uint64)(*ma++);
        -: 1967:				}
        -: 1968:			}
    #####: 1969:			break;
    #####: 1970:		case TIFF_SSHORT:
        -: 1971:			{
        -: 1972:				int16* ma;
        -: 1973:				uint64* mb;
        -: 1974:				uint32 n;
    #####: 1975:				ma=(int16*)origdata;
    #####: 1976:				mb=data;
    #####: 1977:				for (n=0; n<count; n++)
        -: 1978:				{
    #####: 1979:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1980:						TIFFSwabShort((uint16*)ma);
    #####: 1981:					err=TIFFReadDirEntryCheckRangeLong8Sshort(*ma);
    #####: 1982:					if (err!=TIFFReadDirEntryErrOk)
    #####: 1983:						break;
    #####: 1984:					*mb++=(uint64)(*ma++);
        -: 1985:				}
        -: 1986:			}
    #####: 1987:			break;
    #####: 1988:		case TIFF_LONG:
        -: 1989:			{
        -: 1990:				uint32* ma;
        -: 1991:				uint64* mb;
        -: 1992:				uint32 n;
    #####: 1993:				ma=(uint32*)origdata;
    #####: 1994:				mb=data;
    #####: 1995:				for (n=0; n<count; n++)
        -: 1996:				{
    #####: 1997:					if (tif->tif_flags&TIFF_SWAB)
    #####: 1998:						TIFFSwabLong(ma);
    #####: 1999:					*mb++=(uint64)(*ma++);
        -: 2000:				}
        -: 2001:			}
    #####: 2002:			break;
    #####: 2003:		case TIFF_SLONG:
        -: 2004:			{
        -: 2005:				int32* ma;
        -: 2006:				uint64* mb;
        -: 2007:				uint32 n;
    #####: 2008:				ma=(int32*)origdata;
    #####: 2009:				mb=data;
    #####: 2010:				for (n=0; n<count; n++)
        -: 2011:				{
    #####: 2012:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2013:						TIFFSwabLong((uint32*)ma);
    #####: 2014:					err=TIFFReadDirEntryCheckRangeLong8Slong(*ma);
    #####: 2015:					if (err!=TIFFReadDirEntryErrOk)
    #####: 2016:						break;
    #####: 2017:					*mb++=(uint64)(*ma++);
        -: 2018:				}
        -: 2019:			}
    #####: 2020:			break;
        -: 2021:	}
    #####: 2022:	_TIFFfree(origdata);
    #####: 2023:	if (err!=TIFFReadDirEntryErrOk)
        -: 2024:	{
    #####: 2025:		_TIFFfree(data);
    #####: 2026:		return(err);
        -: 2027:	}
    #####: 2028:	*value=data;
    #####: 2029:	return(TIFFReadDirEntryErrOk);
        -: 2030:}
        -: 2031:
    #####: 2032:static enum TIFFReadDirEntryErr TIFFReadDirEntrySlong8Array(TIFF* tif, TIFFDirEntry* direntry, int64** value)
        -: 2033:{
        -: 2034:	enum TIFFReadDirEntryErr err;
    #####: 2035:	uint32 count;
    #####: 2036:	void* origdata;
        -: 2037:	int64* data;
    #####: 2038:	switch (direntry->tdir_type)
        -: 2039:	{
    #####: 2040:		case TIFF_BYTE:
        -: 2041:		case TIFF_SBYTE:
        -: 2042:		case TIFF_SHORT:
        -: 2043:		case TIFF_SSHORT:
        -: 2044:		case TIFF_LONG:
        -: 2045:		case TIFF_SLONG:
        -: 2046:		case TIFF_LONG8:
        -: 2047:		case TIFF_SLONG8:
    #####: 2048:			break;
    #####: 2049:		default:
    #####: 2050:			return(TIFFReadDirEntryErrType);
        -: 2051:	}
    #####: 2052:	err=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);
    #####: 2053:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 2054:	{
    #####: 2055:		*value=0;
    #####: 2056:		return(err);
        -: 2057:	}
    #####: 2058:	switch (direntry->tdir_type)
        -: 2059:	{
    #####: 2060:		case TIFF_LONG8:
        -: 2061:			{
        -: 2062:				uint64* m;
        -: 2063:				uint32 n;
    #####: 2064:				m=(uint64*)origdata;
    #####: 2065:				for (n=0; n<count; n++)
        -: 2066:				{
    #####: 2067:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2068:						TIFFSwabLong8(m);
    #####: 2069:					err=TIFFReadDirEntryCheckRangeSlong8Long8(*m);
    #####: 2070:					if (err!=TIFFReadDirEntryErrOk)
        -: 2071:					{
    #####: 2072:						_TIFFfree(origdata);
    #####: 2073:						return(err);
        -: 2074:					}
    #####: 2075:					m++;
        -: 2076:				}
    #####: 2077:				*value=(int64*)origdata;
    #####: 2078:				return(TIFFReadDirEntryErrOk);
        -: 2079:			}
    #####: 2080:		case TIFF_SLONG8:
    #####: 2081:			*value=(int64*)origdata;
    #####: 2082:			if (tif->tif_flags&TIFF_SWAB)
    #####: 2083:				TIFFSwabArrayOfLong8((uint64*)(*value),count);
    #####: 2084:			return(TIFFReadDirEntryErrOk);
        -: 2085:	}
    #####: 2086:	data=(int64*)_TIFFmalloc(count*8);
    #####: 2087:	if (data==0)
        -: 2088:	{
    #####: 2089:		_TIFFfree(origdata);
    #####: 2090:		return(TIFFReadDirEntryErrAlloc);
        -: 2091:	}
    #####: 2092:	switch (direntry->tdir_type)
        -: 2093:	{
    #####: 2094:		case TIFF_BYTE:
        -: 2095:			{
        -: 2096:				uint8* ma;
        -: 2097:				int64* mb;
        -: 2098:				uint32 n;
    #####: 2099:				ma=(uint8*)origdata;
    #####: 2100:				mb=data;
    #####: 2101:				for (n=0; n<count; n++)
    #####: 2102:					*mb++=(int64)(*ma++);
        -: 2103:			}
    #####: 2104:			break;
    #####: 2105:		case TIFF_SBYTE:
        -: 2106:			{
        -: 2107:				int8* ma;
        -: 2108:				int64* mb;
        -: 2109:				uint32 n;
    #####: 2110:				ma=(int8*)origdata;
    #####: 2111:				mb=data;
    #####: 2112:				for (n=0; n<count; n++)
    #####: 2113:					*mb++=(int64)(*ma++);
        -: 2114:			}
    #####: 2115:			break;
    #####: 2116:		case TIFF_SHORT:
        -: 2117:			{
        -: 2118:				uint16* ma;
        -: 2119:				int64* mb;
        -: 2120:				uint32 n;
    #####: 2121:				ma=(uint16*)origdata;
    #####: 2122:				mb=data;
    #####: 2123:				for (n=0; n<count; n++)
        -: 2124:				{
    #####: 2125:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2126:						TIFFSwabShort(ma);
    #####: 2127:					*mb++=(int64)(*ma++);
        -: 2128:				}
        -: 2129:			}
    #####: 2130:			break;
    #####: 2131:		case TIFF_SSHORT:
        -: 2132:			{
        -: 2133:				int16* ma;
        -: 2134:				int64* mb;
        -: 2135:				uint32 n;
    #####: 2136:				ma=(int16*)origdata;
    #####: 2137:				mb=data;
    #####: 2138:				for (n=0; n<count; n++)
        -: 2139:				{
    #####: 2140:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2141:						TIFFSwabShort((uint16*)ma);
    #####: 2142:					*mb++=(int64)(*ma++);
        -: 2143:				}
        -: 2144:			}
    #####: 2145:			break;
    #####: 2146:		case TIFF_LONG:
        -: 2147:			{
        -: 2148:				uint32* ma;
        -: 2149:				int64* mb;
        -: 2150:				uint32 n;
    #####: 2151:				ma=(uint32*)origdata;
    #####: 2152:				mb=data;
    #####: 2153:				for (n=0; n<count; n++)
        -: 2154:				{
    #####: 2155:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2156:						TIFFSwabLong(ma);
    #####: 2157:					*mb++=(int64)(*ma++);
        -: 2158:				}
        -: 2159:			}
    #####: 2160:			break;
    #####: 2161:		case TIFF_SLONG:
        -: 2162:			{
        -: 2163:				int32* ma;
        -: 2164:				int64* mb;
        -: 2165:				uint32 n;
    #####: 2166:				ma=(int32*)origdata;
    #####: 2167:				mb=data;
    #####: 2168:				for (n=0; n<count; n++)
        -: 2169:				{
    #####: 2170:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2171:						TIFFSwabLong((uint32*)ma);
    #####: 2172:					*mb++=(int64)(*ma++);
        -: 2173:				}
        -: 2174:			}
    #####: 2175:			break;
        -: 2176:	}
    #####: 2177:	_TIFFfree(origdata);
    #####: 2178:	*value=data;
    #####: 2179:	return(TIFFReadDirEntryErrOk);
        -: 2180:}
        -: 2181:
    #####: 2182:static enum TIFFReadDirEntryErr TIFFReadDirEntryFloatArray(TIFF* tif, TIFFDirEntry* direntry, float** value)
        -: 2183:{
        -: 2184:	enum TIFFReadDirEntryErr err;
    #####: 2185:	uint32 count;
    #####: 2186:	void* origdata;
        -: 2187:	float* data;
    #####: 2188:	switch (direntry->tdir_type)
        -: 2189:	{
    #####: 2190:		case TIFF_BYTE:
        -: 2191:		case TIFF_SBYTE:
        -: 2192:		case TIFF_SHORT:
        -: 2193:		case TIFF_SSHORT:
        -: 2194:		case TIFF_LONG:
        -: 2195:		case TIFF_SLONG:
        -: 2196:		case TIFF_LONG8:
        -: 2197:		case TIFF_SLONG8:
        -: 2198:		case TIFF_RATIONAL:
        -: 2199:		case TIFF_SRATIONAL:
        -: 2200:		case TIFF_FLOAT:
        -: 2201:		case TIFF_DOUBLE:
    #####: 2202:			break;
    #####: 2203:		default:
    #####: 2204:			return(TIFFReadDirEntryErrType);
        -: 2205:	}
    #####: 2206:	err=TIFFReadDirEntryArray(tif,direntry,&count,4,&origdata);
    #####: 2207:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 2208:	{
    #####: 2209:		*value=0;
    #####: 2210:		return(err);
        -: 2211:	}
    #####: 2212:	switch (direntry->tdir_type)
        -: 2213:	{
    #####: 2214:		case TIFF_FLOAT:
    #####: 2215:			if (tif->tif_flags&TIFF_SWAB)
    #####: 2216:				TIFFSwabArrayOfLong((uint32*)origdata,count);  
        -: 2217:			TIFFCvtIEEEDoubleToNative(tif,count,(float*)origdata);
    #####: 2218:			*value=(float*)origdata;
    #####: 2219:			return(TIFFReadDirEntryErrOk);
        -: 2220:	}
    #####: 2221:	data=(float*)_TIFFmalloc(count*sizeof(float));
    #####: 2222:	if (data==0)
        -: 2223:	{
    #####: 2224:		_TIFFfree(origdata);
    #####: 2225:		return(TIFFReadDirEntryErrAlloc);
        -: 2226:	}
    #####: 2227:	switch (direntry->tdir_type)
        -: 2228:	{
    #####: 2229:		case TIFF_BYTE:
        -: 2230:			{
        -: 2231:				uint8* ma;
        -: 2232:				float* mb;
        -: 2233:				uint32 n;
    #####: 2234:				ma=(uint8*)origdata;
    #####: 2235:				mb=data;
    #####: 2236:				for (n=0; n<count; n++)
    #####: 2237:					*mb++=(float)(*ma++);
        -: 2238:			}
    #####: 2239:			break;
    #####: 2240:		case TIFF_SBYTE:
        -: 2241:			{
        -: 2242:				int8* ma;
        -: 2243:				float* mb;
        -: 2244:				uint32 n;
    #####: 2245:				ma=(int8*)origdata;
    #####: 2246:				mb=data;
    #####: 2247:				for (n=0; n<count; n++)
    #####: 2248:					*mb++=(float)(*ma++);
        -: 2249:			}
    #####: 2250:			break;
    #####: 2251:		case TIFF_SHORT:
        -: 2252:			{
        -: 2253:				uint16* ma;
        -: 2254:				float* mb;
        -: 2255:				uint32 n;
    #####: 2256:				ma=(uint16*)origdata;
    #####: 2257:				mb=data;
    #####: 2258:				for (n=0; n<count; n++)
        -: 2259:				{
    #####: 2260:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2261:						TIFFSwabShort(ma);
    #####: 2262:					*mb++=(float)(*ma++);
        -: 2263:				}
        -: 2264:			}
    #####: 2265:			break;
    #####: 2266:		case TIFF_SSHORT:
        -: 2267:			{
        -: 2268:				int16* ma;
        -: 2269:				float* mb;
        -: 2270:				uint32 n;
    #####: 2271:				ma=(int16*)origdata;
    #####: 2272:				mb=data;
    #####: 2273:				for (n=0; n<count; n++)
        -: 2274:				{
    #####: 2275:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2276:						TIFFSwabShort((uint16*)ma);
    #####: 2277:					*mb++=(float)(*ma++);
        -: 2278:				}
        -: 2279:			}
    #####: 2280:			break;
    #####: 2281:		case TIFF_LONG:
        -: 2282:			{
        -: 2283:				uint32* ma;
        -: 2284:				float* mb;
        -: 2285:				uint32 n;
    #####: 2286:				ma=(uint32*)origdata;
    #####: 2287:				mb=data;
    #####: 2288:				for (n=0; n<count; n++)
        -: 2289:				{
    #####: 2290:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2291:						TIFFSwabLong(ma);
    #####: 2292:					*mb++=(float)(*ma++);
        -: 2293:				}
        -: 2294:			}
    #####: 2295:			break;
    #####: 2296:		case TIFF_SLONG:
        -: 2297:			{
        -: 2298:				int32* ma;
        -: 2299:				float* mb;
        -: 2300:				uint32 n;
    #####: 2301:				ma=(int32*)origdata;
    #####: 2302:				mb=data;
    #####: 2303:				for (n=0; n<count; n++)
        -: 2304:				{
    #####: 2305:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2306:						TIFFSwabLong((uint32*)ma);
    #####: 2307:					*mb++=(float)(*ma++);
        -: 2308:				}
        -: 2309:			}
    #####: 2310:			break;
    #####: 2311:		case TIFF_LONG8:
        -: 2312:			{
        -: 2313:				uint64* ma;
        -: 2314:				float* mb;
        -: 2315:				uint32 n;
    #####: 2316:				ma=(uint64*)origdata;
    #####: 2317:				mb=data;
    #####: 2318:				for (n=0; n<count; n++)
        -: 2319:				{
    #####: 2320:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2321:						TIFFSwabLong8(ma);
        -: 2322:#if defined(__WIN32__) && (_MSC_VER < 1500)
        -: 2323:					/*
        -: 2324:					 * XXX: MSVC 6.0 does not support
        -: 2325:					 * conversion of 64-bit integers into
        -: 2326:					 * floating point values.
        -: 2327:					 */
        -: 2328:					*mb++ = _TIFFUInt64ToFloat(*ma++);
        -: 2329:#else
    #####: 2330:					*mb++ = (float)(*ma++);
        -: 2331:#endif
        -: 2332:				}
        -: 2333:			}
    #####: 2334:			break;
    #####: 2335:		case TIFF_SLONG8:
        -: 2336:			{
        -: 2337:				int64* ma;
        -: 2338:				float* mb;
        -: 2339:				uint32 n;
    #####: 2340:				ma=(int64*)origdata;
    #####: 2341:				mb=data;
    #####: 2342:				for (n=0; n<count; n++)
        -: 2343:				{
    #####: 2344:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2345:						TIFFSwabLong8((uint64*)ma);
    #####: 2346:					*mb++=(float)(*ma++);
        -: 2347:				}
        -: 2348:			}
    #####: 2349:			break;
    #####: 2350:		case TIFF_RATIONAL:
        -: 2351:			{
        -: 2352:				uint32* ma;
        -: 2353:				uint32 maa;
        -: 2354:				uint32 mab;
        -: 2355:				float* mb;
        -: 2356:				uint32 n;
    #####: 2357:				ma=(uint32*)origdata;
    #####: 2358:				mb=data;
    #####: 2359:				for (n=0; n<count; n++)
        -: 2360:				{
    #####: 2361:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2362:						TIFFSwabLong(ma);
    #####: 2363:					maa=*ma++;
    #####: 2364:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2365:						TIFFSwabLong(ma);
    #####: 2366:					mab=*ma++;
    #####: 2367:					if (mab==0)
    #####: 2368:						*mb++=0.0;
        -: 2369:					else
    #####: 2370:						*mb++=(float)maa/(float)mab;
        -: 2371:				}
        -: 2372:			}
    #####: 2373:			break;
    #####: 2374:		case TIFF_SRATIONAL:
        -: 2375:			{
        -: 2376:				uint32* ma;
        -: 2377:				int32 maa;
        -: 2378:				uint32 mab;
        -: 2379:				float* mb;
        -: 2380:				uint32 n;
    #####: 2381:				ma=(uint32*)origdata;
    #####: 2382:				mb=data;
    #####: 2383:				for (n=0; n<count; n++)
        -: 2384:				{
    #####: 2385:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2386:						TIFFSwabLong(ma);
    #####: 2387:					maa=*(int32*)ma;
    #####: 2388:					ma++;
    #####: 2389:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2390:						TIFFSwabLong(ma);
    #####: 2391:					mab=*ma++;
    #####: 2392:					if (mab==0)
    #####: 2393:						*mb++=0.0;
        -: 2394:					else
    #####: 2395:						*mb++=(float)maa/(float)mab;
        -: 2396:				}
        -: 2397:			}
    #####: 2398:			break;
    #####: 2399:		case TIFF_DOUBLE:
        -: 2400:			{
        -: 2401:				double* ma;
        -: 2402:				float* mb;
        -: 2403:				uint32 n;
    #####: 2404:				if (tif->tif_flags&TIFF_SWAB)
    #####: 2405:					TIFFSwabArrayOfLong8((uint64*)origdata,count);
        -: 2406:				TIFFCvtIEEEDoubleToNative(tif,count,(double*)origdata);
    #####: 2407:				ma=(double*)origdata;
    #####: 2408:				mb=data;
    #####: 2409:				for (n=0; n<count; n++)
        -: 2410:                                {
    #####: 2411:                                    double val = *ma++;
    #####: 2412:                                    if( val > FLT_MAX )
    #####: 2413:                                        val = FLT_MAX;
    #####: 2414:                                    else if( val < -FLT_MAX )
    #####: 2415:                                        val = -FLT_MAX;
    #####: 2416:                                    *mb++=(float)val;
        -: 2417:                                }
        -: 2418:			}
    #####: 2419:			break;
        -: 2420:	}
    #####: 2421:	_TIFFfree(origdata);
    #####: 2422:	*value=data;
    #####: 2423:	return(TIFFReadDirEntryErrOk);
        -: 2424:}
        -: 2425:
        -: 2426:static enum TIFFReadDirEntryErr
    #####: 2427:TIFFReadDirEntryDoubleArray(TIFF* tif, TIFFDirEntry* direntry, double** value)
        -: 2428:{
        -: 2429:	enum TIFFReadDirEntryErr err;
    #####: 2430:	uint32 count;
    #####: 2431:	void* origdata;
        -: 2432:	double* data;
    #####: 2433:	switch (direntry->tdir_type)
        -: 2434:	{
    #####: 2435:		case TIFF_BYTE:
        -: 2436:		case TIFF_SBYTE:
        -: 2437:		case TIFF_SHORT:
        -: 2438:		case TIFF_SSHORT:
        -: 2439:		case TIFF_LONG:
        -: 2440:		case TIFF_SLONG:
        -: 2441:		case TIFF_LONG8:
        -: 2442:		case TIFF_SLONG8:
        -: 2443:		case TIFF_RATIONAL:
        -: 2444:		case TIFF_SRATIONAL:
        -: 2445:		case TIFF_FLOAT:
        -: 2446:		case TIFF_DOUBLE:
    #####: 2447:			break;
    #####: 2448:		default:
    #####: 2449:			return(TIFFReadDirEntryErrType);
        -: 2450:	}
    #####: 2451:	err=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);
    #####: 2452:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 2453:	{
    #####: 2454:		*value=0;
    #####: 2455:		return(err);
        -: 2456:	}
    #####: 2457:	switch (direntry->tdir_type)
        -: 2458:	{
    #####: 2459:		case TIFF_DOUBLE:
    #####: 2460:			if (tif->tif_flags&TIFF_SWAB)
    #####: 2461:				TIFFSwabArrayOfLong8((uint64*)origdata,count);
        -: 2462:			TIFFCvtIEEEDoubleToNative(tif,count,(double*)origdata);
    #####: 2463:			*value=(double*)origdata;
    #####: 2464:			return(TIFFReadDirEntryErrOk);
        -: 2465:	}
    #####: 2466:	data=(double*)_TIFFmalloc(count*sizeof(double));
    #####: 2467:	if (data==0)
        -: 2468:	{
    #####: 2469:		_TIFFfree(origdata);
    #####: 2470:		return(TIFFReadDirEntryErrAlloc);
        -: 2471:	}
    #####: 2472:	switch (direntry->tdir_type)
        -: 2473:	{
    #####: 2474:		case TIFF_BYTE:
        -: 2475:			{
        -: 2476:				uint8* ma;
        -: 2477:				double* mb;
        -: 2478:				uint32 n;
    #####: 2479:				ma=(uint8*)origdata;
    #####: 2480:				mb=data;
    #####: 2481:				for (n=0; n<count; n++)
    #####: 2482:					*mb++=(double)(*ma++);
        -: 2483:			}
    #####: 2484:			break;
    #####: 2485:		case TIFF_SBYTE:
        -: 2486:			{
        -: 2487:				int8* ma;
        -: 2488:				double* mb;
        -: 2489:				uint32 n;
    #####: 2490:				ma=(int8*)origdata;
    #####: 2491:				mb=data;
    #####: 2492:				for (n=0; n<count; n++)
    #####: 2493:					*mb++=(double)(*ma++);
        -: 2494:			}
    #####: 2495:			break;
    #####: 2496:		case TIFF_SHORT:
        -: 2497:			{
        -: 2498:				uint16* ma;
        -: 2499:				double* mb;
        -: 2500:				uint32 n;
    #####: 2501:				ma=(uint16*)origdata;
    #####: 2502:				mb=data;
    #####: 2503:				for (n=0; n<count; n++)
        -: 2504:				{
    #####: 2505:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2506:						TIFFSwabShort(ma);
    #####: 2507:					*mb++=(double)(*ma++);
        -: 2508:				}
        -: 2509:			}
    #####: 2510:			break;
    #####: 2511:		case TIFF_SSHORT:
        -: 2512:			{
        -: 2513:				int16* ma;
        -: 2514:				double* mb;
        -: 2515:				uint32 n;
    #####: 2516:				ma=(int16*)origdata;
    #####: 2517:				mb=data;
    #####: 2518:				for (n=0; n<count; n++)
        -: 2519:				{
    #####: 2520:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2521:						TIFFSwabShort((uint16*)ma);
    #####: 2522:					*mb++=(double)(*ma++);
        -: 2523:				}
        -: 2524:			}
    #####: 2525:			break;
    #####: 2526:		case TIFF_LONG:
        -: 2527:			{
        -: 2528:				uint32* ma;
        -: 2529:				double* mb;
        -: 2530:				uint32 n;
    #####: 2531:				ma=(uint32*)origdata;
    #####: 2532:				mb=data;
    #####: 2533:				for (n=0; n<count; n++)
        -: 2534:				{
    #####: 2535:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2536:						TIFFSwabLong(ma);
    #####: 2537:					*mb++=(double)(*ma++);
        -: 2538:				}
        -: 2539:			}
    #####: 2540:			break;
    #####: 2541:		case TIFF_SLONG:
        -: 2542:			{
        -: 2543:				int32* ma;
        -: 2544:				double* mb;
        -: 2545:				uint32 n;
    #####: 2546:				ma=(int32*)origdata;
    #####: 2547:				mb=data;
    #####: 2548:				for (n=0; n<count; n++)
        -: 2549:				{
    #####: 2550:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2551:						TIFFSwabLong((uint32*)ma);
    #####: 2552:					*mb++=(double)(*ma++);
        -: 2553:				}
        -: 2554:			}
    #####: 2555:			break;
    #####: 2556:		case TIFF_LONG8:
        -: 2557:			{
        -: 2558:				uint64* ma;
        -: 2559:				double* mb;
        -: 2560:				uint32 n;
    #####: 2561:				ma=(uint64*)origdata;
    #####: 2562:				mb=data;
    #####: 2563:				for (n=0; n<count; n++)
        -: 2564:				{
    #####: 2565:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2566:						TIFFSwabLong8(ma);
        -: 2567:#if defined(__WIN32__) && (_MSC_VER < 1500)
        -: 2568:					/*
        -: 2569:					 * XXX: MSVC 6.0 does not support
        -: 2570:					 * conversion of 64-bit integers into
        -: 2571:					 * floating point values.
        -: 2572:					 */
        -: 2573:					*mb++ = _TIFFUInt64ToDouble(*ma++);
        -: 2574:#else
    #####: 2575:					*mb++ = (double)(*ma++);
        -: 2576:#endif
        -: 2577:				}
        -: 2578:			}
    #####: 2579:			break;
    #####: 2580:		case TIFF_SLONG8:
        -: 2581:			{
        -: 2582:				int64* ma;
        -: 2583:				double* mb;
        -: 2584:				uint32 n;
    #####: 2585:				ma=(int64*)origdata;
    #####: 2586:				mb=data;
    #####: 2587:				for (n=0; n<count; n++)
        -: 2588:				{
    #####: 2589:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2590:						TIFFSwabLong8((uint64*)ma);
    #####: 2591:					*mb++=(double)(*ma++);
        -: 2592:				}
        -: 2593:			}
    #####: 2594:			break;
    #####: 2595:		case TIFF_RATIONAL:
        -: 2596:			{
        -: 2597:				uint32* ma;
        -: 2598:				uint32 maa;
        -: 2599:				uint32 mab;
        -: 2600:				double* mb;
        -: 2601:				uint32 n;
    #####: 2602:				ma=(uint32*)origdata;
    #####: 2603:				mb=data;
    #####: 2604:				for (n=0; n<count; n++)
        -: 2605:				{
    #####: 2606:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2607:						TIFFSwabLong(ma);
    #####: 2608:					maa=*ma++;
    #####: 2609:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2610:						TIFFSwabLong(ma);
    #####: 2611:					mab=*ma++;
    #####: 2612:					if (mab==0)
    #####: 2613:						*mb++=0.0;
        -: 2614:					else
    #####: 2615:						*mb++=(double)maa/(double)mab;
        -: 2616:				}
        -: 2617:			}
    #####: 2618:			break;
    #####: 2619:		case TIFF_SRATIONAL:
        -: 2620:			{
        -: 2621:				uint32* ma;
        -: 2622:				int32 maa;
        -: 2623:				uint32 mab;
        -: 2624:				double* mb;
        -: 2625:				uint32 n;
    #####: 2626:				ma=(uint32*)origdata;
    #####: 2627:				mb=data;
    #####: 2628:				for (n=0; n<count; n++)
        -: 2629:				{
    #####: 2630:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2631:						TIFFSwabLong(ma);
    #####: 2632:					maa=*(int32*)ma;
    #####: 2633:					ma++;
    #####: 2634:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2635:						TIFFSwabLong(ma);
    #####: 2636:					mab=*ma++;
    #####: 2637:					if (mab==0)
    #####: 2638:						*mb++=0.0;
        -: 2639:					else
    #####: 2640:						*mb++=(double)maa/(double)mab;
        -: 2641:				}
        -: 2642:			}
    #####: 2643:			break;
    #####: 2644:		case TIFF_FLOAT:
        -: 2645:			{
        -: 2646:				float* ma;
        -: 2647:				double* mb;
        -: 2648:				uint32 n;
    #####: 2649:				if (tif->tif_flags&TIFF_SWAB)
    #####: 2650:					TIFFSwabArrayOfLong((uint32*)origdata,count);  
        -: 2651:				TIFFCvtIEEEFloatToNative(tif,count,(float*)origdata);
    #####: 2652:				ma=(float*)origdata;
    #####: 2653:				mb=data;
    #####: 2654:				for (n=0; n<count; n++)
    #####: 2655:					*mb++=(double)(*ma++);
        -: 2656:			}
    #####: 2657:			break;
        -: 2658:	}
    #####: 2659:	_TIFFfree(origdata);
    #####: 2660:	*value=data;
    #####: 2661:	return(TIFFReadDirEntryErrOk);
        -: 2662:}
        -: 2663:
    #####: 2664:static enum TIFFReadDirEntryErr TIFFReadDirEntryIfd8Array(TIFF* tif, TIFFDirEntry* direntry, uint64** value)
        -: 2665:{
        -: 2666:	enum TIFFReadDirEntryErr err;
    #####: 2667:	uint32 count;
    #####: 2668:	void* origdata;
        -: 2669:	uint64* data;
    #####: 2670:	switch (direntry->tdir_type)
        -: 2671:	{
    #####: 2672:		case TIFF_LONG:
        -: 2673:		case TIFF_LONG8:
        -: 2674:		case TIFF_IFD:
        -: 2675:		case TIFF_IFD8:
    #####: 2676:			break;
    #####: 2677:		default:
    #####: 2678:			return(TIFFReadDirEntryErrType);
        -: 2679:	}
    #####: 2680:	err=TIFFReadDirEntryArray(tif,direntry,&count,8,&origdata);
    #####: 2681:	if ((err!=TIFFReadDirEntryErrOk)||(origdata==0))
        -: 2682:	{
    #####: 2683:		*value=0;
    #####: 2684:		return(err);
        -: 2685:	}
    #####: 2686:	switch (direntry->tdir_type)
        -: 2687:	{
    #####: 2688:		case TIFF_LONG8:
        -: 2689:		case TIFF_IFD8:
    #####: 2690:			*value=(uint64*)origdata;
    #####: 2691:			if (tif->tif_flags&TIFF_SWAB)
    #####: 2692:				TIFFSwabArrayOfLong8(*value,count);
    #####: 2693:			return(TIFFReadDirEntryErrOk);
        -: 2694:	}
    #####: 2695:	data=(uint64*)_TIFFmalloc(count*8);
    #####: 2696:	if (data==0)
        -: 2697:	{
    #####: 2698:		_TIFFfree(origdata);
    #####: 2699:		return(TIFFReadDirEntryErrAlloc);
        -: 2700:	}
    #####: 2701:	switch (direntry->tdir_type)
        -: 2702:	{
    #####: 2703:		case TIFF_LONG:
        -: 2704:		case TIFF_IFD:
        -: 2705:			{
        -: 2706:				uint32* ma;
        -: 2707:				uint64* mb;
        -: 2708:				uint32 n;
    #####: 2709:				ma=(uint32*)origdata;
    #####: 2710:				mb=data;
    #####: 2711:				for (n=0; n<count; n++)
        -: 2712:				{
    #####: 2713:					if (tif->tif_flags&TIFF_SWAB)
    #####: 2714:						TIFFSwabLong(ma);
    #####: 2715:					*mb++=(uint64)(*ma++);
        -: 2716:				}
        -: 2717:			}
    #####: 2718:			break;
        -: 2719:	}
    #####: 2720:	_TIFFfree(origdata);
    #####: 2721:	*value=data;
    #####: 2722:	return(TIFFReadDirEntryErrOk);
        -: 2723:}
        -: 2724:
        1: 2725:static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)
        -: 2726:{
        -: 2727:	enum TIFFReadDirEntryErr err;
        1: 2728:	uint16* m;
        -: 2729:	uint16* na;
        -: 2730:	uint16 nb;
        1: 2731:	if (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)
    #####: 2732:		return(TIFFReadDirEntryErrCount);
        1: 2733:	err=TIFFReadDirEntryShortArray(tif,direntry,&m);
        1: 2734:	if (err!=TIFFReadDirEntryErrOk)
    #####: 2735:		return(err);
        1: 2736:	na=m;
        1: 2737:	nb=tif->tif_dir.td_samplesperpixel;
        1: 2738:	*value=*na++;
        1: 2739:	nb--;
        1: 2740:	while (nb>0)
        -: 2741:	{
    #####: 2742:		if (*na++!=*value)
        -: 2743:		{
    #####: 2744:			err=TIFFReadDirEntryErrPsdif;
    #####: 2745:			break;
        -: 2746:		}
    #####: 2747:		nb--;
        -: 2748:	}
        1: 2749:	_TIFFfree(m);
        1: 2750:	return(err);
        -: 2751:}
        -: 2752:
        -: 2753:#if 0
        -: 2754:static enum TIFFReadDirEntryErr TIFFReadDirEntryPersampleDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)
        -: 2755:{
        -: 2756:	enum TIFFReadDirEntryErr err;
        -: 2757:	double* m;
        -: 2758:	double* na;
        -: 2759:	uint16 nb;
        -: 2760:	if (direntry->tdir_count<(uint64)tif->tif_dir.td_samplesperpixel)
        -: 2761:		return(TIFFReadDirEntryErrCount);
        -: 2762:	err=TIFFReadDirEntryDoubleArray(tif,direntry,&m);
        -: 2763:	if (err!=TIFFReadDirEntryErrOk)
        -: 2764:		return(err);
        -: 2765:	na=m;
        -: 2766:	nb=tif->tif_dir.td_samplesperpixel;
        -: 2767:	*value=*na++;
        -: 2768:	nb--;
        -: 2769:	while (nb>0)
        -: 2770:	{
        -: 2771:		if (*na++!=*value)
        -: 2772:		{
        -: 2773:			err=TIFFReadDirEntryErrPsdif;
        -: 2774:			break;
        -: 2775:		}
        -: 2776:		nb--;
        -: 2777:	}
        -: 2778:	_TIFFfree(m);
        -: 2779:	return(err);
        -: 2780:}
        -: 2781:#endif
        -: 2782:
    #####: 2783:static void TIFFReadDirEntryCheckedByte(TIFF* tif, TIFFDirEntry* direntry, uint8* value)
        -: 2784:{
        -: 2785:	(void) tif;
    #####: 2786:	*value=*(uint8*)(&direntry->tdir_offset);
    #####: 2787:}
        -: 2788:
    #####: 2789:static void TIFFReadDirEntryCheckedSbyte(TIFF* tif, TIFFDirEntry* direntry, int8* value)
        -: 2790:{
        -: 2791:	(void) tif;
    #####: 2792:	*value=*(int8*)(&direntry->tdir_offset);
    #####: 2793:}
        -: 2794:
        8: 2795:static void TIFFReadDirEntryCheckedShort(TIFF* tif, TIFFDirEntry* direntry, uint16* value)
        -: 2796:{
        8: 2797:	*value = direntry->tdir_offset.toff_short;
        -: 2798:	/* *value=*(uint16*)(&direntry->tdir_offset); */
        8: 2799:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2800:		TIFFSwabShort(value);
        8: 2801:}
        -: 2802:
    #####: 2803:static void TIFFReadDirEntryCheckedSshort(TIFF* tif, TIFFDirEntry* direntry, int16* value)
        -: 2804:{
    #####: 2805:	*value=*(int16*)(&direntry->tdir_offset);
    #####: 2806:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2807:		TIFFSwabShort((uint16*)value);
    #####: 2808:}
        -: 2809:
    #####: 2810:static void TIFFReadDirEntryCheckedLong(TIFF* tif, TIFFDirEntry* direntry, uint32* value)
        -: 2811:{
    #####: 2812:	*value=*(uint32*)(&direntry->tdir_offset);
    #####: 2813:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2814:		TIFFSwabLong(value);
    #####: 2815:}
        -: 2816:
    #####: 2817:static void TIFFReadDirEntryCheckedSlong(TIFF* tif, TIFFDirEntry* direntry, int32* value)
        -: 2818:{
    #####: 2819:	*value=*(int32*)(&direntry->tdir_offset);
    #####: 2820:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2821:		TIFFSwabLong((uint32*)value);
    #####: 2822:}
        -: 2823:
    #####: 2824:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedLong8(TIFF* tif, TIFFDirEntry* direntry, uint64* value)
        -: 2825:{
    #####: 2826:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 2827:	{
        -: 2828:		enum TIFFReadDirEntryErr err;
    #####: 2829:		uint32 offset = direntry->tdir_offset.toff_long;
    #####: 2830:		if (tif->tif_flags&TIFF_SWAB)
    #####: 2831:			TIFFSwabLong(&offset);
    #####: 2832:		err=TIFFReadDirEntryData(tif,offset,8,value);
    #####: 2833:		if (err!=TIFFReadDirEntryErrOk)
    #####: 2834:			return(err);
        -: 2835:	}
        -: 2836:	else
    #####: 2837:		*value = direntry->tdir_offset.toff_long8;
    #####: 2838:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2839:		TIFFSwabLong8(value);
    #####: 2840:	return(TIFFReadDirEntryErrOk);
        -: 2841:}
        -: 2842:
    #####: 2843:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSlong8(TIFF* tif, TIFFDirEntry* direntry, int64* value)
        -: 2844:{
    #####: 2845:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 2846:	{
        -: 2847:		enum TIFFReadDirEntryErr err;
    #####: 2848:		uint32 offset = direntry->tdir_offset.toff_long;
    #####: 2849:		if (tif->tif_flags&TIFF_SWAB)
    #####: 2850:			TIFFSwabLong(&offset);
    #####: 2851:		err=TIFFReadDirEntryData(tif,offset,8,value);
    #####: 2852:		if (err!=TIFFReadDirEntryErrOk)
    #####: 2853:			return(err);
        -: 2854:	}
        -: 2855:	else
    #####: 2856:		*value=*(int64*)(&direntry->tdir_offset);
    #####: 2857:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2858:		TIFFSwabLong8((uint64*)value);
    #####: 2859:	return(TIFFReadDirEntryErrOk);
        -: 2860:}
        -: 2861:
        1: 2862:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedRational(TIFF* tif, TIFFDirEntry* direntry, double* value)
        -: 2863:{
        1: 2864:	UInt64Aligned_t m;
        -: 2865:
        -: 2866:	assert(sizeof(double)==8);
        -: 2867:	assert(sizeof(uint64)==8);
        -: 2868:	assert(sizeof(uint32)==4);
        1: 2869:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 2870:	{
        -: 2871:		enum TIFFReadDirEntryErr err;
    #####: 2872:		uint32 offset = direntry->tdir_offset.toff_long;
    #####: 2873:		if (tif->tif_flags&TIFF_SWAB)
    #####: 2874:			TIFFSwabLong(&offset);
    #####: 2875:		err=TIFFReadDirEntryData(tif,offset,8,m.i);
    #####: 2876:		if (err!=TIFFReadDirEntryErrOk)
    #####: 2877:			return(err);
        -: 2878:	}
        -: 2879:	else
        1: 2880:		m.l = direntry->tdir_offset.toff_long8;
        1: 2881:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2882:		TIFFSwabArrayOfLong(m.i,2);
        -: 2883:        /* Not completely sure what we should do when m.i[1]==0, but some */
        -: 2884:        /* sanitizers do not like division by 0.0: */
        -: 2885:        /* http://bugzilla.maptools.org/show_bug.cgi?id=2644 */
        1: 2886:	if (m.i[0]==0 || m.i[1]==0)
    #####: 2887:		*value=0.0;
        -: 2888:	else
        1: 2889:		*value=(double)m.i[0]/(double)m.i[1];
        1: 2890:	return(TIFFReadDirEntryErrOk);
        -: 2891:}
        -: 2892:
    #####: 2893:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedSrational(TIFF* tif, TIFFDirEntry* direntry, double* value)
        -: 2894:{
    #####: 2895:	UInt64Aligned_t m;
        -: 2896:	assert(sizeof(double)==8);
        -: 2897:	assert(sizeof(uint64)==8);
        -: 2898:	assert(sizeof(int32)==4);
        -: 2899:	assert(sizeof(uint32)==4);
    #####: 2900:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 2901:	{
        -: 2902:		enum TIFFReadDirEntryErr err;
    #####: 2903:		uint32 offset = direntry->tdir_offset.toff_long;
    #####: 2904:		if (tif->tif_flags&TIFF_SWAB)
    #####: 2905:			TIFFSwabLong(&offset);
    #####: 2906:		err=TIFFReadDirEntryData(tif,offset,8,m.i);
    #####: 2907:		if (err!=TIFFReadDirEntryErrOk)
    #####: 2908:			return(err);
        -: 2909:	}
        -: 2910:	else
    #####: 2911:		m.l=direntry->tdir_offset.toff_long8;
    #####: 2912:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2913:		TIFFSwabArrayOfLong(m.i,2);
        -: 2914:        /* Not completely sure what we should do when m.i[1]==0, but some */
        -: 2915:        /* sanitizers do not like division by 0.0: */
        -: 2916:        /* http://bugzilla.maptools.org/show_bug.cgi?id=2644 */
    #####: 2917:	if ((int32)m.i[0]==0 || m.i[1]==0)
    #####: 2918:		*value=0.0;
        -: 2919:	else
    #####: 2920:		*value=(double)((int32)m.i[0])/(double)m.i[1];
    #####: 2921:	return(TIFFReadDirEntryErrOk);
        -: 2922:}
        -: 2923:
        1: 2924:static void TIFFReadDirEntryCheckedFloat(TIFF* tif, TIFFDirEntry* direntry, float* value)
        -: 2925:{
        -: 2926:         union
        -: 2927:	 {
        -: 2928:	   float  f;
        -: 2929:	   uint32 i;
        -: 2930:	 } float_union;
        -: 2931:	assert(sizeof(float)==4);
        -: 2932:	assert(sizeof(uint32)==4);
        -: 2933:	assert(sizeof(float_union)==4);
        1: 2934:	float_union.i=*(uint32*)(&direntry->tdir_offset);
        1: 2935:	*value=float_union.f;
        1: 2936:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2937:		TIFFSwabLong((uint32*)value);
        1: 2938:}
        -: 2939:
    #####: 2940:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckedDouble(TIFF* tif, TIFFDirEntry* direntry, double* value)
        -: 2941:{
        -: 2942:	assert(sizeof(double)==8);
        -: 2943:	assert(sizeof(uint64)==8);
        -: 2944:	assert(sizeof(UInt64Aligned_t)==8);
    #####: 2945:	if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 2946:	{
        -: 2947:		enum TIFFReadDirEntryErr err;
    #####: 2948:		uint32 offset = direntry->tdir_offset.toff_long;
    #####: 2949:		if (tif->tif_flags&TIFF_SWAB)
    #####: 2950:			TIFFSwabLong(&offset);
    #####: 2951:		err=TIFFReadDirEntryData(tif,offset,8,value);
    #####: 2952:		if (err!=TIFFReadDirEntryErrOk)
    #####: 2953:			return(err);
        -: 2954:	}
        -: 2955:	else
        -: 2956:	{
        -: 2957:	       UInt64Aligned_t uint64_union;
    #####: 2958:	       uint64_union.l=direntry->tdir_offset.toff_long8;
    #####: 2959:	       *value=uint64_union.d;
        -: 2960:	}
    #####: 2961:	if (tif->tif_flags&TIFF_SWAB)
    #####: 2962:		TIFFSwabLong8((uint64*)value);
    #####: 2963:	return(TIFFReadDirEntryErrOk);
        -: 2964:}
        -: 2965:
    #####: 2966:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSbyte(int8 value)
        -: 2967:{
    #####: 2968:	if (value<0)
    #####: 2969:		return(TIFFReadDirEntryErrRange);
        -: 2970:	else
    #####: 2971:		return(TIFFReadDirEntryErrOk);
        -: 2972:}
        -: 2973:
        5: 2974:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteShort(uint16 value)
        -: 2975:{
        5: 2976:	if (value>0xFF)
    #####: 2977:		return(TIFFReadDirEntryErrRange);
        -: 2978:	else
        5: 2979:		return(TIFFReadDirEntryErrOk);
        -: 2980:}
        -: 2981:
    #####: 2982:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSshort(int16 value)
        -: 2983:{
    #####: 2984:	if ((value<0)||(value>0xFF))
    #####: 2985:		return(TIFFReadDirEntryErrRange);
        -: 2986:	else
    #####: 2987:		return(TIFFReadDirEntryErrOk);
        -: 2988:}
        -: 2989:
    #####: 2990:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong(uint32 value)
        -: 2991:{
    #####: 2992:	if (value>0xFF)
    #####: 2993:		return(TIFFReadDirEntryErrRange);
        -: 2994:	else
    #####: 2995:		return(TIFFReadDirEntryErrOk);
        -: 2996:}
        -: 2997:
    #####: 2998:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong(int32 value)
        -: 2999:{
    #####: 3000:	if ((value<0)||(value>0xFF))
    #####: 3001:		return(TIFFReadDirEntryErrRange);
        -: 3002:	else
    #####: 3003:		return(TIFFReadDirEntryErrOk);
        -: 3004:}
        -: 3005:
    #####: 3006:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteLong8(uint64 value)
        -: 3007:{
    #####: 3008:	if (value>0xFF)
    #####: 3009:		return(TIFFReadDirEntryErrRange);
        -: 3010:	else
    #####: 3011:		return(TIFFReadDirEntryErrOk);
        -: 3012:}
        -: 3013:
    #####: 3014:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeByteSlong8(int64 value)
        -: 3015:{
    #####: 3016:	if ((value<0)||(value>0xFF))
    #####: 3017:		return(TIFFReadDirEntryErrRange);
        -: 3018:	else
    #####: 3019:		return(TIFFReadDirEntryErrOk);
        -: 3020:}
        -: 3021:
    #####: 3022:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteByte(uint8 value)
        -: 3023:{
    #####: 3024:	if (value>0x7F)
    #####: 3025:		return(TIFFReadDirEntryErrRange);
        -: 3026:	else
    #####: 3027:		return(TIFFReadDirEntryErrOk);
        -: 3028:}
        -: 3029:
    #####: 3030:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteShort(uint16 value)
        -: 3031:{
    #####: 3032:	if (value>0x7F)
    #####: 3033:		return(TIFFReadDirEntryErrRange);
        -: 3034:	else
    #####: 3035:		return(TIFFReadDirEntryErrOk);
        -: 3036:}
        -: 3037:
    #####: 3038:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSshort(int16 value)
        -: 3039:{
    #####: 3040:	if ((value<-0x80)||(value>0x7F))
    #####: 3041:		return(TIFFReadDirEntryErrRange);
        -: 3042:	else
    #####: 3043:		return(TIFFReadDirEntryErrOk);
        -: 3044:}
        -: 3045:
    #####: 3046:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong(uint32 value)
        -: 3047:{
    #####: 3048:	if (value>0x7F)
    #####: 3049:		return(TIFFReadDirEntryErrRange);
        -: 3050:	else
    #####: 3051:		return(TIFFReadDirEntryErrOk);
        -: 3052:}
        -: 3053:
    #####: 3054:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong(int32 value)
        -: 3055:{
    #####: 3056:	if ((value<-0x80)||(value>0x7F))
    #####: 3057:		return(TIFFReadDirEntryErrRange);
        -: 3058:	else
    #####: 3059:		return(TIFFReadDirEntryErrOk);
        -: 3060:}
        -: 3061:
    #####: 3062:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteLong8(uint64 value)
        -: 3063:{
    #####: 3064:	if (value>0x7F)
    #####: 3065:		return(TIFFReadDirEntryErrRange);
        -: 3066:	else
    #####: 3067:		return(TIFFReadDirEntryErrOk);
        -: 3068:}
        -: 3069:
    #####: 3070:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSbyteSlong8(int64 value)
        -: 3071:{
    #####: 3072:	if ((value<-0x80)||(value>0x7F))
    #####: 3073:		return(TIFFReadDirEntryErrRange);
        -: 3074:	else
    #####: 3075:		return(TIFFReadDirEntryErrOk);
        -: 3076:}
        -: 3077:
    #####: 3078:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSbyte(int8 value)
        -: 3079:{
    #####: 3080:	if (value<0)
    #####: 3081:		return(TIFFReadDirEntryErrRange);
        -: 3082:	else
    #####: 3083:		return(TIFFReadDirEntryErrOk);
        -: 3084:}
        -: 3085:
    #####: 3086:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSshort(int16 value)
        -: 3087:{
    #####: 3088:	if (value<0)
    #####: 3089:		return(TIFFReadDirEntryErrRange);
        -: 3090:	else
    #####: 3091:		return(TIFFReadDirEntryErrOk);
        -: 3092:}
        -: 3093:
    #####: 3094:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong(uint32 value)
        -: 3095:{
    #####: 3096:	if (value>0xFFFF)
    #####: 3097:		return(TIFFReadDirEntryErrRange);
        -: 3098:	else
    #####: 3099:		return(TIFFReadDirEntryErrOk);
        -: 3100:}
        -: 3101:
    #####: 3102:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong(int32 value)
        -: 3103:{
    #####: 3104:	if ((value<0)||(value>0xFFFF))
    #####: 3105:		return(TIFFReadDirEntryErrRange);
        -: 3106:	else
    #####: 3107:		return(TIFFReadDirEntryErrOk);
        -: 3108:}
        -: 3109:
    #####: 3110:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortLong8(uint64 value)
        -: 3111:{
    #####: 3112:	if (value>0xFFFF)
    #####: 3113:		return(TIFFReadDirEntryErrRange);
        -: 3114:	else
    #####: 3115:		return(TIFFReadDirEntryErrOk);
        -: 3116:}
        -: 3117:
    #####: 3118:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeShortSlong8(int64 value)
        -: 3119:{
    #####: 3120:	if ((value<0)||(value>0xFFFF))
    #####: 3121:		return(TIFFReadDirEntryErrRange);
        -: 3122:	else
    #####: 3123:		return(TIFFReadDirEntryErrOk);
        -: 3124:}
        -: 3125:
    #####: 3126:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortShort(uint16 value)
        -: 3127:{
    #####: 3128:	if (value>0x7FFF)
    #####: 3129:		return(TIFFReadDirEntryErrRange);
        -: 3130:	else
    #####: 3131:		return(TIFFReadDirEntryErrOk);
        -: 3132:}
        -: 3133:
    #####: 3134:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong(uint32 value)
        -: 3135:{
    #####: 3136:	if (value>0x7FFF)
    #####: 3137:		return(TIFFReadDirEntryErrRange);
        -: 3138:	else
    #####: 3139:		return(TIFFReadDirEntryErrOk);
        -: 3140:}
        -: 3141:
    #####: 3142:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong(int32 value)
        -: 3143:{
    #####: 3144:	if ((value<-0x8000)||(value>0x7FFF))
    #####: 3145:		return(TIFFReadDirEntryErrRange);
        -: 3146:	else
    #####: 3147:		return(TIFFReadDirEntryErrOk);
        -: 3148:}
        -: 3149:
    #####: 3150:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortLong8(uint64 value)
        -: 3151:{
    #####: 3152:	if (value>0x7FFF)
    #####: 3153:		return(TIFFReadDirEntryErrRange);
        -: 3154:	else
    #####: 3155:		return(TIFFReadDirEntryErrOk);
        -: 3156:}
        -: 3157:
    #####: 3158:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeSshortSlong8(int64 value)
        -: 3159:{
    #####: 3160:	if ((value<-0x8000)||(value>0x7FFF))
    #####: 3161:		return(TIFFReadDirEntryErrRange);
        -: 3162:	else
    #####: 3163:		return(TIFFReadDirEntryErrOk);
        -: 3164:}
        -: 3165:
    #####: 3166:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSbyte(int8 value)
        -: 3167:{
    #####: 3168:	if (value<0)
    #####: 3169:		return(TIFFReadDirEntryErrRange);
        -: 3170:	else
    #####: 3171:		return(TIFFReadDirEntryErrOk);
        -: 3172:}
        -: 3173:
    #####: 3174:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSshort(int16 value)
        -: 3175:{
    #####: 3176:	if (value<0)
    #####: 3177:		return(TIFFReadDirEntryErrRange);
        -: 3178:	else
    #####: 3179:		return(TIFFReadDirEntryErrOk);
        -: 3180:}
        -: 3181:
    #####: 3182:static enum TIFFReadDirEntryErr TIFFReadDirEntryCheckRangeLongSlong(int32 value)
        -: 3183:{
    #####: 3184:	if (value<0)
    #####: 3185:		return(TIFFReadDirEntryErrRange);
        -: 3186:	else
    #####: 3187:		return(TIFFReadDirEntryErrOk);
        -: 3188:}
        -: 3189:
        -: 3190:/*
        -: 3191: * Largest 32-bit unsigned integer value.
        -: 3192: */
        -: 3193:#define TIFF_UINT32_MAX 0xFFFFFFFFU
        -: 3194:
        -: 3195:static enum TIFFReadDirEntryErr
    #####: 3196:TIFFReadDirEntryCheckRangeLongLong8(uint64 value)
        -: 3197:{
    #####: 3198:	if (value > TIFF_UINT32_MAX)
    #####: 3199:		return(TIFFReadDirEntryErrRange);
        -: 3200:	else
    #####: 3201:		return(TIFFReadDirEntryErrOk);
        -: 3202:}
        -: 3203:
        -: 3204:static enum TIFFReadDirEntryErr
    #####: 3205:TIFFReadDirEntryCheckRangeLongSlong8(int64 value)
        -: 3206:{
    #####: 3207:	if ((value < 0) || (value > (int64) TIFF_UINT32_MAX))
    #####: 3208:		return(TIFFReadDirEntryErrRange);
        -: 3209:	else
    #####: 3210:		return(TIFFReadDirEntryErrOk);
        -: 3211:}
        -: 3212:
        -: 3213:#undef TIFF_UINT32_MAX
        -: 3214:
        -: 3215:static enum TIFFReadDirEntryErr
    #####: 3216:TIFFReadDirEntryCheckRangeSlongLong(uint32 value)
        -: 3217:{
    #####: 3218:	if (value > 0x7FFFFFFFUL)
    #####: 3219:		return(TIFFReadDirEntryErrRange);
        -: 3220:	else
    #####: 3221:		return(TIFFReadDirEntryErrOk);
        -: 3222:}
        -: 3223:
        -: 3224:/* Check that the 8-byte unsigned value can fit in a 4-byte unsigned range */
        -: 3225:static enum TIFFReadDirEntryErr
    #####: 3226:TIFFReadDirEntryCheckRangeSlongLong8(uint64 value)
        -: 3227:{
    #####: 3228:	if (value > 0x7FFFFFFF)
    #####: 3229:		return(TIFFReadDirEntryErrRange);
        -: 3230:	else
    #####: 3231:		return(TIFFReadDirEntryErrOk);
        -: 3232:}
        -: 3233:
        -: 3234:/* Check that the 8-byte signed value can fit in a 4-byte signed range */
        -: 3235:static enum TIFFReadDirEntryErr
    #####: 3236:TIFFReadDirEntryCheckRangeSlongSlong8(int64 value)
        -: 3237:{
    #####: 3238:        if ((value < 0-((int64) 0x7FFFFFFF+1)) || (value > 0x7FFFFFFF))
    #####: 3239:		return(TIFFReadDirEntryErrRange);
        -: 3240:	else
    #####: 3241:		return(TIFFReadDirEntryErrOk);
        -: 3242:}
        -: 3243:
        -: 3244:static enum TIFFReadDirEntryErr
    #####: 3245:TIFFReadDirEntryCheckRangeLong8Sbyte(int8 value)
        -: 3246:{
    #####: 3247:	if (value < 0)
    #####: 3248:		return(TIFFReadDirEntryErrRange);
        -: 3249:	else
    #####: 3250:		return(TIFFReadDirEntryErrOk);
        -: 3251:}
        -: 3252:
        -: 3253:static enum TIFFReadDirEntryErr
    #####: 3254:TIFFReadDirEntryCheckRangeLong8Sshort(int16 value)
        -: 3255:{
    #####: 3256:	if (value < 0)
    #####: 3257:		return(TIFFReadDirEntryErrRange);
        -: 3258:	else
    #####: 3259:		return(TIFFReadDirEntryErrOk);
        -: 3260:}
        -: 3261:
        -: 3262:static enum TIFFReadDirEntryErr
    #####: 3263:TIFFReadDirEntryCheckRangeLong8Slong(int32 value)
        -: 3264:{
    #####: 3265:	if (value < 0)
    #####: 3266:		return(TIFFReadDirEntryErrRange);
        -: 3267:	else
    #####: 3268:		return(TIFFReadDirEntryErrOk);
        -: 3269:}
        -: 3270:
        -: 3271:static enum TIFFReadDirEntryErr
    #####: 3272:TIFFReadDirEntryCheckRangeLong8Slong8(int64 value)
        -: 3273:{
    #####: 3274:	if (value < 0)
    #####: 3275:		return(TIFFReadDirEntryErrRange);
        -: 3276:	else
    #####: 3277:		return(TIFFReadDirEntryErrOk);
        -: 3278:}
        -: 3279:
        -: 3280:/*
        -: 3281: * Largest 64-bit signed integer value.
        -: 3282: */
        -: 3283:#define TIFF_INT64_MAX ((int64)(((uint64) ~0) >> 1))
        -: 3284:
        -: 3285:static enum TIFFReadDirEntryErr
    #####: 3286:TIFFReadDirEntryCheckRangeSlong8Long8(uint64 value)
        -: 3287:{
    #####: 3288:	if (value > TIFF_INT64_MAX)
    #####: 3289:		return(TIFFReadDirEntryErrRange);
        -: 3290:	else
    #####: 3291:		return(TIFFReadDirEntryErrOk);
        -: 3292:}
        -: 3293:
        -: 3294:#undef TIFF_INT64_MAX
        -: 3295:
        -: 3296:static enum TIFFReadDirEntryErr
        1: 3297:TIFFReadDirEntryData(TIFF* tif, uint64 offset, tmsize_t size, void* dest)
        -: 3298:{
       1*: 3299:	assert(size>0);
        1: 3300:	if (!isMapped(tif)) {
    #####: 3301:		if (!SeekOK(tif,offset))
    #####: 3302:			return(TIFFReadDirEntryErrIo);
    #####: 3303:		if (!ReadOK(tif,dest,size))
    #####: 3304:			return(TIFFReadDirEntryErrIo);
        -: 3305:	} else {
        -: 3306:		size_t ma,mb;
        1: 3307:		ma=(size_t)offset;
        1: 3308:		mb=ma+size;
        1: 3309:		if (((uint64)ma!=offset)
        1: 3310:		    || (mb < ma)
        1: 3311:		    || (mb - ma != (size_t) size)
        1: 3312:		    || (mb < (size_t)size)
        1: 3313:		    || (mb > (size_t)tif->tif_size)
        -: 3314:		    )
    #####: 3315:			return(TIFFReadDirEntryErrIo);
        1: 3316:		_TIFFmemcpy(dest,tif->tif_base+ma,size);
        -: 3317:	}
        1: 3318:	return(TIFFReadDirEntryErrOk);
        -: 3319:}
        -: 3320:
        1: 3321:static void TIFFReadDirEntryOutputErr(TIFF* tif, enum TIFFReadDirEntryErr err, const char* module, const char* tagname, int recover)
        -: 3322:{
        1: 3323:	if (!recover) {
    #####: 3324:		switch (err) {
    #####: 3325:			case TIFFReadDirEntryErrCount:
    #####: 3326:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 3327:					     "Incorrect count for \"%s\"",
        -: 3328:					     tagname);
    #####: 3329:				break;
    #####: 3330:			case TIFFReadDirEntryErrType:
    #####: 3331:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 3332:					     "Incompatible type for \"%s\"",
        -: 3333:					     tagname);
    #####: 3334:				break;
    #####: 3335:			case TIFFReadDirEntryErrIo:
    #####: 3336:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 3337:					     "IO error during reading of \"%s\"",
        -: 3338:					     tagname);
    #####: 3339:				break;
    #####: 3340:			case TIFFReadDirEntryErrRange:
    #####: 3341:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 3342:					     "Incorrect value for \"%s\"",
        -: 3343:					     tagname);
    #####: 3344:				break;
    #####: 3345:			case TIFFReadDirEntryErrPsdif:
    #####: 3346:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 3347:			"Cannot handle different values per sample for \"%s\"",
        -: 3348:					     tagname);
    #####: 3349:				break;
    #####: 3350:			case TIFFReadDirEntryErrSizesan:
    #####: 3351:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 3352:				"Sanity check on size of \"%s\" value failed",
        -: 3353:					     tagname);
    #####: 3354:				break;
    #####: 3355:			case TIFFReadDirEntryErrAlloc:
    #####: 3356:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 3357:					     "Out of memory reading of \"%s\"",
        -: 3358:					     tagname);
    #####: 3359:				break;
    #####: 3360:			default:
    #####: 3361:				assert(0);   /* we should never get here */
        -: 3362:				break;
        -: 3363:		}
        -: 3364:	} else {
        1: 3365:		switch (err) {
    #####: 3366:			case TIFFReadDirEntryErrCount:
    #####: 3367:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 3368:				"Incorrect count for \"%s\"; tag ignored",
        -: 3369:					     tagname);
    #####: 3370:				break;
    #####: 3371:			case TIFFReadDirEntryErrType:
    #####: 3372:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 3373:				"Incompatible type for \"%s\"; tag ignored",
        -: 3374:					       tagname);
    #####: 3375:				break;
    #####: 3376:			case TIFFReadDirEntryErrIo:
    #####: 3377:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 3378:			"IO error during reading of \"%s\"; tag ignored",
        -: 3379:					       tagname);
    #####: 3380:				break;
    #####: 3381:			case TIFFReadDirEntryErrRange:
    #####: 3382:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 3383:				"Incorrect value for \"%s\"; tag ignored",
        -: 3384:					       tagname);
    #####: 3385:				break;
    #####: 3386:			case TIFFReadDirEntryErrPsdif:
    #####: 3387:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 3388:	"Cannot handle different values per sample for \"%s\"; tag ignored",
        -: 3389:					       tagname);
    #####: 3390:				break;
        1: 3391:			case TIFFReadDirEntryErrSizesan:
        1: 3392:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 3393:		"Sanity check on size of \"%s\" value failed; tag ignored",
        -: 3394:					       tagname);
        1: 3395:				break;
    #####: 3396:			case TIFFReadDirEntryErrAlloc:
    #####: 3397:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 3398:				"Out of memory reading of \"%s\"; tag ignored",
        -: 3399:					       tagname);
    #####: 3400:				break;
    #####: 3401:			default:
    #####: 3402:				assert(0);   /* we should never get here */
        -: 3403:				break;
        -: 3404:		}
        -: 3405:	}
        1: 3406:}
        -: 3407:
        -: 3408:/*
        -: 3409: * Read the next TIFF directory from a file and convert it to the internal
        -: 3410: * format. We read directories sequentially.
        -: 3411: */
        -: 3412:int
        1: 3413:TIFFReadDirectory(TIFF* tif)
        -: 3414:{
        -: 3415:	static const char module[] = "TIFFReadDirectory";
        1: 3416:	TIFFDirEntry* dir;
        -: 3417:	uint16 dircount;
        -: 3418:	TIFFDirEntry* dp;
        -: 3419:	uint16 di;
        -: 3420:	const TIFFField* fip;
        1: 3421:	uint32 fii=FAILED_FII;
        -: 3422:        toff_t nextdiroff;
        1: 3423:    int bitspersample_read = FALSE;
        -: 3424:
        1: 3425:	tif->tif_diroff=tif->tif_nextdiroff;
        1: 3426:	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
    #####: 3427:		return 0;           /* last offset or bad offset (IFD looping) */
        1: 3428:	(*tif->tif_cleanup)(tif);   /* cleanup any previous compression state */
        1: 3429:	tif->tif_curdir++;
        1: 3430:        nextdiroff = tif->tif_nextdiroff;
        1: 3431:	dircount=TIFFFetchDirectory(tif,nextdiroff,&dir,&tif->tif_nextdiroff);
        1: 3432:	if (!dircount)
        -: 3433:	{
    #####: 3434:		TIFFErrorExt(tif->tif_clientdata,module,
        -: 3435:		    "Failed to read directory at offset " TIFF_UINT64_FORMAT,nextdiroff);
    #####: 3436:		return 0;
        -: 3437:	}
        1: 3438:	TIFFReadDirectoryCheckOrder(tif,dir,dircount);
        -: 3439:
        -: 3440:        /*
        -: 3441:         * Mark duplicates of any tag to be ignored (bugzilla 1994)
        -: 3442:         * to avoid certain pathological problems.
        -: 3443:         */
        -: 3444:	{
        -: 3445:		TIFFDirEntry* ma;
        -: 3446:		uint16 mb;
       19: 3447:		for (ma=dir, mb=0; mb<dircount; ma++, mb++)
        -: 3448:		{
        -: 3449:			TIFFDirEntry* na;
        -: 3450:			uint16 nb;
      171: 3451:			for (na=ma+1, nb=mb+1; nb<dircount; na++, nb++)
        -: 3452:			{
      153: 3453:				if (ma->tdir_tag==na->tdir_tag)
    #####: 3454:					na->tdir_tag=IGNORE;
        -: 3455:			}
        -: 3456:		}
        -: 3457:	}
        -: 3458:        
        1: 3459:	tif->tif_flags &= ~TIFF_BEENWRITING;    /* reset before new dir */
        1: 3460:	tif->tif_flags &= ~TIFF_BUF4WRITE;      /* reset before new dir */
        -: 3461:	/* free any old stuff and reinit */
        1: 3462:	TIFFFreeDirectory(tif);
        1: 3463:	TIFFDefaultDirectory(tif);
        -: 3464:	/*
        -: 3465:	 * Electronic Arts writes gray-scale TIFF files
        -: 3466:	 * without a PlanarConfiguration directory entry.
        -: 3467:	 * Thus we setup a default value here, even though
        -: 3468:	 * the TIFF spec says there is no default value.
        -: 3469:	 */
        1: 3470:	TIFFSetField(tif,TIFFTAG_PLANARCONFIG,PLANARCONFIG_CONTIG);
        -: 3471:	/*
        -: 3472:	 * Setup default value and then make a pass over
        -: 3473:	 * the fields to check type and tag information,
        -: 3474:	 * and to extract info required to size data
        -: 3475:	 * structures.  A second pass is made afterwards
        -: 3476:	 * to read in everything not taken in the first pass.
        -: 3477:	 * But we must process the Compression tag first
        -: 3478:	 * in order to merge in codec-private tag definitions (otherwise
        -: 3479:	 * we may get complaints about unknown tags).  However, the
        -: 3480:	 * Compression tag may be dependent on the SamplesPerPixel
        -: 3481:	 * tag value because older TIFF specs permitted Compression
        -: 3482:	 * to be written as a SamplesPerPixel-count tag entry.
        -: 3483:	 * Thus if we don't first figure out the correct SamplesPerPixel
        -: 3484:	 * tag value then we may end up ignoring the Compression tag
        -: 3485:	 * value because it has an incorrect count value (if the
        -: 3486:	 * true value of SamplesPerPixel is not 1).
        -: 3487:	 */
        1: 3488:	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_SAMPLESPERPIXEL);
        1: 3489:	if (dp)
        -: 3490:	{
    #####: 3491:		if (!TIFFFetchNormalTag(tif,dp,0))
    #####: 3492:			goto bad;
    #####: 3493:		dp->tdir_tag=IGNORE;
        -: 3494:	}
        1: 3495:	dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_COMPRESSION);
        1: 3496:	if (dp)
        -: 3497:	{
        -: 3498:		/*
        -: 3499:		 * The 5.0 spec says the Compression tag has one value, while
        -: 3500:		 * earlier specs say it has one value per sample.  Because of
        -: 3501:		 * this, we accept the tag if one value is supplied with either
        -: 3502:		 * count.
        -: 3503:		 */
        1: 3504:		uint16 value;
        -: 3505:		enum TIFFReadDirEntryErr err;
        1: 3506:		err=TIFFReadDirEntryShort(tif,dp,&value);
        1: 3507:		if (err==TIFFReadDirEntryErrCount)
    #####: 3508:			err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
        1: 3509:		if (err!=TIFFReadDirEntryErrOk)
        -: 3510:		{
    #####: 3511:			TIFFReadDirEntryOutputErr(tif,err,module,"Compression",0);
    #####: 3512:			goto bad;
        -: 3513:		}
        1: 3514:		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,value))
    #####: 3515:			goto bad;
        1: 3516:		dp->tdir_tag=IGNORE;
        -: 3517:	}
        -: 3518:	else
        -: 3519:	{
    #####: 3520:		if (!TIFFSetField(tif,TIFFTAG_COMPRESSION,COMPRESSION_NONE))
    #####: 3521:			goto bad;
        -: 3522:	}
        -: 3523:	/*
        -: 3524:	 * First real pass over the directory.
        -: 3525:	 */
       19: 3526:	for (di=0, dp=dir; di<dircount; di++, dp++)
        -: 3527:	{
       18: 3528:		if (dp->tdir_tag!=IGNORE)
        -: 3529:		{
       17: 3530:			TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
       17: 3531:			if (fii == FAILED_FII)
        -: 3532:			{
    #####: 3533:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 3534:				    "Unknown field with tag %d (0x%x) encountered",
    #####: 3535:				    dp->tdir_tag,dp->tdir_tag);
        -: 3536:                                /* the following knowingly leaks the 
        -: 3537:                                   anonymous field structure */
    #####: 3538:				if (!_TIFFMergeFields(tif,
    #####: 3539:					_TIFFCreateAnonField(tif,
    #####: 3540:						dp->tdir_tag,
    #####: 3541:						(TIFFDataType) dp->tdir_type),
        -: 3542:					1)) {
    #####: 3543:					TIFFWarningExt(tif->tif_clientdata,
        -: 3544:					    module,
        -: 3545:					    "Registering anonymous field with tag %d (0x%x) failed",
    #####: 3546:					    dp->tdir_tag,
    #####: 3547:					    dp->tdir_tag);
    #####: 3548:					dp->tdir_tag=IGNORE;
        -: 3549:				} else {
    #####: 3550:					TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
    #####: 3551:					assert(fii != FAILED_FII);
        -: 3552:				}
        -: 3553:			}
        -: 3554:		}
       18: 3555:		if (dp->tdir_tag!=IGNORE)
        -: 3556:		{
       17: 3557:			fip=tif->tif_fields[fii];
       17: 3558:			if (fip->field_bit==FIELD_IGNORE)
    #####: 3559:				dp->tdir_tag=IGNORE;
        -: 3560:			else
        -: 3561:			{
       17: 3562:				switch (dp->tdir_tag)
        -: 3563:				{
        2: 3564:					case TIFFTAG_STRIPOFFSETS:
        -: 3565:					case TIFFTAG_STRIPBYTECOUNTS:
        -: 3566:					case TIFFTAG_TILEOFFSETS:
        -: 3567:					case TIFFTAG_TILEBYTECOUNTS:
       2*: 3568:						TIFFSetFieldBit(tif,fip->field_bit);
        2: 3569:						break;
        4: 3570:					case TIFFTAG_IMAGEWIDTH:
        -: 3571:					case TIFFTAG_IMAGELENGTH:
        -: 3572:					case TIFFTAG_IMAGEDEPTH:
        -: 3573:					case TIFFTAG_TILELENGTH:
        -: 3574:					case TIFFTAG_TILEWIDTH:
        -: 3575:					case TIFFTAG_TILEDEPTH:
        -: 3576:					case TIFFTAG_PLANARCONFIG:
        -: 3577:					case TIFFTAG_ROWSPERSTRIP:
        -: 3578:					case TIFFTAG_EXTRASAMPLES:
        4: 3579:						if (!TIFFFetchNormalTag(tif,dp,0))
    #####: 3580:							goto bad;
        4: 3581:						dp->tdir_tag=IGNORE;
        4: 3582:						break;
        -: 3583:				}
       18: 3584:			}
        -: 3585:		}
        -: 3586:	}
        -: 3587:	/*
        -: 3588:	 * XXX: OJPEG hack.
        -: 3589:	 * If a) compression is OJPEG, b) planarconfig tag says it's separate,
        -: 3590:	 * c) strip offsets/bytecounts tag are both present and
        -: 3591:	 * d) both contain exactly one value, then we consistently find
        -: 3592:	 * that the buggy implementation of the buggy compression scheme
        -: 3593:	 * matches contig planarconfig best. So we 'fix-up' the tag here
        -: 3594:	 */
       1*: 3595:	if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG)&&
    #####: 3596:	    (tif->tif_dir.td_planarconfig==PLANARCONFIG_SEPARATE))
        -: 3597:	{
    #####: 3598:        if (!_TIFFFillStriles(tif))
    #####: 3599:            goto bad;
    #####: 3600:		dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,TIFFTAG_STRIPOFFSETS);
    #####: 3601:		if ((dp!=0)&&(dp->tdir_count==1))
        -: 3602:		{
    #####: 3603:			dp=TIFFReadDirectoryFindEntry(tif,dir,dircount,
        -: 3604:			    TIFFTAG_STRIPBYTECOUNTS);
    #####: 3605:			if ((dp!=0)&&(dp->tdir_count==1))
        -: 3606:			{
    #####: 3607:				tif->tif_dir.td_planarconfig=PLANARCONFIG_CONTIG;
    #####: 3608:				TIFFWarningExt(tif->tif_clientdata,module,
        -: 3609:				    "Planarconfig tag value assumed incorrect, "
        -: 3610:				    "assuming data is contig instead of chunky");
        -: 3611:			}
        -: 3612:		}
        -: 3613:	}
        -: 3614:	/*
        -: 3615:	 * Allocate directory structure and setup defaults.
        -: 3616:	 */
        1: 3617:	if (!TIFFFieldSet(tif,FIELD_IMAGEDIMENSIONS))
        -: 3618:	{
    #####: 3619:		MissingRequired(tif,"ImageLength");
    #####: 3620:		goto bad;
        -: 3621:	}
        -: 3622:	/*
        -: 3623:	 * Setup appropriate structures (by strip or by tile)
        -: 3624:	 */
        1: 3625:	if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS)) {
        1: 3626:		tif->tif_dir.td_nstrips = TIFFNumberOfStrips(tif);  
        1: 3627:		tif->tif_dir.td_tilewidth = tif->tif_dir.td_imagewidth;
        1: 3628:		tif->tif_dir.td_tilelength = tif->tif_dir.td_rowsperstrip;
        1: 3629:		tif->tif_dir.td_tiledepth = tif->tif_dir.td_imagedepth;
        1: 3630:		tif->tif_flags &= ~TIFF_ISTILED;
        -: 3631:	} else {
    #####: 3632:		tif->tif_dir.td_nstrips = TIFFNumberOfTiles(tif);
    #####: 3633:		tif->tif_flags |= TIFF_ISTILED;
        -: 3634:	}
        1: 3635:	if (!tif->tif_dir.td_nstrips) {
    #####: 3636:		TIFFErrorExt(tif->tif_clientdata, module,
        -: 3637:		    "Cannot handle zero number of %s",
    #####: 3638:		    isTiled(tif) ? "tiles" : "strips");
    #####: 3639:		goto bad;
        -: 3640:	}
        1: 3641:	tif->tif_dir.td_stripsperimage = tif->tif_dir.td_nstrips;
        1: 3642:	if (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE)
    #####: 3643:		tif->tif_dir.td_stripsperimage /= tif->tif_dir.td_samplesperpixel;
        1: 3644:	if (!TIFFFieldSet(tif, FIELD_STRIPOFFSETS)) {
        -: 3645:#ifdef OJPEG_SUPPORT
    #####: 3646:		if ((tif->tif_dir.td_compression==COMPRESSION_OJPEG) &&
    #####: 3647:		    (isTiled(tif)==0) &&
    #####: 3648:		    (tif->tif_dir.td_nstrips==1)) {
        -: 3649:			/*
        -: 3650:			 * XXX: OJPEG hack.
        -: 3651:			 * If a) compression is OJPEG, b) it's not a tiled TIFF,
        -: 3652:			 * and c) the number of strips is 1,
        -: 3653:			 * then we tolerate the absence of stripoffsets tag,
        -: 3654:			 * because, presumably, all required data is in the
        -: 3655:			 * JpegInterchangeFormat stream.
        -: 3656:			 */
    #####: 3657:			TIFFSetFieldBit(tif, FIELD_STRIPOFFSETS);
        -: 3658:		} else
        -: 3659:#endif
        -: 3660:        {
    #####: 3661:			MissingRequired(tif,
    #####: 3662:				isTiled(tif) ? "TileOffsets" : "StripOffsets");
    #####: 3663:			goto bad;
        -: 3664:		}
        -: 3665:	}
        -: 3666:	/*
        -: 3667:	 * Second pass: extract other information.
        -: 3668:	 */
       19: 3669:	for (di=0, dp=dir; di<dircount; di++, dp++)
        -: 3670:	{
       18: 3671:		switch (dp->tdir_tag)
        -: 3672:		{
        5: 3673:			case IGNORE:
        5: 3674:				break;
        2: 3675:			case TIFFTAG_MINSAMPLEVALUE:
        -: 3676:			case TIFFTAG_MAXSAMPLEVALUE:
        -: 3677:			case TIFFTAG_BITSPERSAMPLE:
        -: 3678:			case TIFFTAG_DATATYPE:
        -: 3679:			case TIFFTAG_SAMPLEFORMAT:
        -: 3680:				/*
        -: 3681:				 * The MinSampleValue, MaxSampleValue, BitsPerSample
        -: 3682:				 * DataType and SampleFormat tags are supposed to be
        -: 3683:				 * written as one value/sample, but some vendors
        -: 3684:				 * incorrectly write one value only -- so we accept
        -: 3685:				 * that as well (yuck). Other vendors write correct
        -: 3686:				 * value for NumberOfSamples, but incorrect one for
        -: 3687:				 * BitsPerSample and friends, and we will read this
        -: 3688:				 * too.
        -: 3689:				 */
        -: 3690:				{
        2: 3691:					uint16 value;
        -: 3692:					enum TIFFReadDirEntryErr err;
        2: 3693:					err=TIFFReadDirEntryShort(tif,dp,&value);
        2: 3694:					if (err==TIFFReadDirEntryErrCount)
        1: 3695:						err=TIFFReadDirEntryPersampleShort(tif,dp,&value);
        2: 3696:					if (err!=TIFFReadDirEntryErrOk)
        -: 3697:					{
    #####: 3698:						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
    #####: 3699:						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
    #####: 3700:						goto bad;
        -: 3701:					}
        2: 3702:					if (!TIFFSetField(tif,dp->tdir_tag,value))
    #####: 3703:						goto bad;
        2: 3704:                    if( dp->tdir_tag == TIFFTAG_BITSPERSAMPLE )
        1: 3705:                        bitspersample_read = TRUE;
        -: 3706:				}
        2: 3707:				break;
    #####: 3708:			case TIFFTAG_SMINSAMPLEVALUE:
        -: 3709:			case TIFFTAG_SMAXSAMPLEVALUE:
        -: 3710:				{
        -: 3711:
    #####: 3712:					double *data = NULL;
        -: 3713:					enum TIFFReadDirEntryErr err;
        -: 3714:					uint32 saved_flags;
        -: 3715:					int m;
    #####: 3716:					if (dp->tdir_count != (uint64)tif->tif_dir.td_samplesperpixel)
    #####: 3717:						err = TIFFReadDirEntryErrCount;
        -: 3718:					else
    #####: 3719:						err = TIFFReadDirEntryDoubleArray(tif, dp, &data);
    #####: 3720:					if (err!=TIFFReadDirEntryErrOk)
        -: 3721:					{
    #####: 3722:						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
    #####: 3723:						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
    #####: 3724:						goto bad;
        -: 3725:					}
    #####: 3726:					saved_flags = tif->tif_flags;
    #####: 3727:					tif->tif_flags |= TIFF_PERSAMPLE;
    #####: 3728:					m = TIFFSetField(tif,dp->tdir_tag,data);
    #####: 3729:					tif->tif_flags = saved_flags;
    #####: 3730:					_TIFFfree(data);
    #####: 3731:					if (!m)
    #####: 3732:						goto bad;
        -: 3733:				}
    #####: 3734:				break;
        1: 3735:			case TIFFTAG_STRIPOFFSETS:
        -: 3736:			case TIFFTAG_TILEOFFSETS:
        -: 3737:#if defined(DEFER_STRILE_LOAD)
        -: 3738:                                _TIFFmemcpy( &(tif->tif_dir.td_stripoffset_entry),
        -: 3739:                                             dp, sizeof(TIFFDirEntry) );
        -: 3740:#else                          
        1: 3741:				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripoffset))  
    #####: 3742:					goto bad;
        -: 3743:#endif                                
        1: 3744:				break;
        1: 3745:			case TIFFTAG_STRIPBYTECOUNTS:
        -: 3746:			case TIFFTAG_TILEBYTECOUNTS:
        -: 3747:#if defined(DEFER_STRILE_LOAD)
        -: 3748:                                _TIFFmemcpy( &(tif->tif_dir.td_stripbytecount_entry),
        -: 3749:                                             dp, sizeof(TIFFDirEntry) );
        -: 3750:#else                          
        1: 3751:				if (!TIFFFetchStripThing(tif,dp,tif->tif_dir.td_nstrips,&tif->tif_dir.td_stripbytecount))  
    #####: 3752:					goto bad;
        -: 3753:#endif                                
        1: 3754:				break;
    #####: 3755:			case TIFFTAG_COLORMAP:
        -: 3756:			case TIFFTAG_TRANSFERFUNCTION:
        -: 3757:				{
        -: 3758:					enum TIFFReadDirEntryErr err;
        -: 3759:					uint32 countpersample;
        -: 3760:					uint32 countrequired;
        -: 3761:					uint32 incrementpersample;
    #####: 3762:					uint16* value=NULL;
        -: 3763:                    /* It would be dangerous to instantiate those tag values */
        -: 3764:                    /* since if td_bitspersample has not yet been read (due to */
        -: 3765:                    /* unordered tags), it could be read afterwards with a */
        -: 3766:                    /* values greater than the default one (1), which may cause */
        -: 3767:                    /* crashes in user code */
    #####: 3768:                    if( !bitspersample_read )
        -: 3769:                    {
    #####: 3770:                        fip = TIFFFieldWithTag(tif,dp->tdir_tag);
    #####: 3771:                        TIFFWarningExt(tif->tif_clientdata,module,
        -: 3772:                                       "Ignoring %s since BitsPerSample tag not found",
        -: 3773:                                       fip ? fip->field_name : "unknown tagname");
    #####: 3774:                        continue;
        -: 3775:                    }
        -: 3776:					/* ColorMap or TransferFunction for high bit */
        -: 3777:					/* depths do not make much sense and could be */
        -: 3778:					/* used as a denial of service vector */
    #####: 3779:					if (tif->tif_dir.td_bitspersample > 24)
        -: 3780:					{
    #####: 3781:					    fip = TIFFFieldWithTag(tif,dp->tdir_tag);
    #####: 3782:					    TIFFWarningExt(tif->tif_clientdata,module,
        -: 3783:						"Ignoring %s because BitsPerSample=%d>24",
        -: 3784:						fip ? fip->field_name : "unknown tagname",
    #####: 3785:						tif->tif_dir.td_bitspersample);
    #####: 3786:					    continue;
        -: 3787:					}
    #####: 3788:					countpersample=(1U<<tif->tif_dir.td_bitspersample);
    #####: 3789:					if ((dp->tdir_tag==TIFFTAG_TRANSFERFUNCTION)&&(dp->tdir_count==(uint64)countpersample))
        -: 3790:					{
    #####: 3791:						countrequired=countpersample;
    #####: 3792:						incrementpersample=0;
        -: 3793:					}
        -: 3794:					else
        -: 3795:					{
    #####: 3796:						countrequired=3*countpersample;
    #####: 3797:						incrementpersample=countpersample;
        -: 3798:					}
    #####: 3799:					if (dp->tdir_count!=(uint64)countrequired)
    #####: 3800:						err=TIFFReadDirEntryErrCount;
        -: 3801:					else
    #####: 3802:						err=TIFFReadDirEntryShortArray(tif,dp,&value);
    #####: 3803:					if (err!=TIFFReadDirEntryErrOk)
        -: 3804:                    {
    #####: 3805:						fip = TIFFFieldWithTag(tif,dp->tdir_tag);
    #####: 3806:						TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",1);
        -: 3807:                    }
        -: 3808:					else
        -: 3809:					{
    #####: 3810:						TIFFSetField(tif,dp->tdir_tag,value,value+incrementpersample,value+2*incrementpersample);
    #####: 3811:						_TIFFfree(value);
        -: 3812:					}
        -: 3813:				}
    #####: 3814:				break;
        -: 3815:/* BEGIN REV 4.0 COMPATIBILITY */
    #####: 3816:			case TIFFTAG_OSUBFILETYPE:
        -: 3817:				{
    #####: 3818:					uint16 valueo;
        -: 3819:					uint32 value;
    #####: 3820:					if (TIFFReadDirEntryShort(tif,dp,&valueo)==TIFFReadDirEntryErrOk)
        -: 3821:					{
    #####: 3822:						switch (valueo)
        -: 3823:						{
    #####: 3824:							case OFILETYPE_REDUCEDIMAGE: value=FILETYPE_REDUCEDIMAGE; break;
    #####: 3825:							case OFILETYPE_PAGE: value=FILETYPE_PAGE; break;
    #####: 3826:							default: value=0; break;
        -: 3827:						}
    #####: 3828:						if (value!=0)
    #####: 3829:							TIFFSetField(tif,TIFFTAG_SUBFILETYPE,value);
        -: 3830:					}
        -: 3831:				}
        -: 3832:				break;
        -: 3833:/* END REV 4.0 COMPATIBILITY */
        9: 3834:			default:
        9: 3835:				(void) TIFFFetchNormalTag(tif, dp, TRUE);
        9: 3836:				break;
        -: 3837:		}
        -: 3838:	}
        -: 3839:	/*
        -: 3840:	 * OJPEG hack:
        -: 3841:	 * - If a) compression is OJPEG, and b) photometric tag is missing,
        -: 3842:	 * then we consistently find that photometric should be YCbCr
        -: 3843:	 * - If a) compression is OJPEG, and b) photometric tag says it's RGB,
        -: 3844:	 * then we consistently find that the buggy implementation of the
        -: 3845:	 * buggy compression scheme matches photometric YCbCr instead.
        -: 3846:	 * - If a) compression is OJPEG, and b) bitspersample tag is missing,
        -: 3847:	 * then we consistently find bitspersample should be 8.
        -: 3848:	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
        -: 3849:	 * and c) photometric is RGB or YCbCr, then we consistently find
        -: 3850:	 * samplesperpixel should be 3
        -: 3851:	 * - If a) compression is OJPEG, b) samplesperpixel tag is missing,
        -: 3852:	 * and c) photometric is MINISWHITE or MINISBLACK, then we consistently
        -: 3853:	 * find samplesperpixel should be 3
        -: 3854:	 */
        1: 3855:	if (tif->tif_dir.td_compression==COMPRESSION_OJPEG)
        -: 3856:	{
    #####: 3857:		if (!TIFFFieldSet(tif,FIELD_PHOTOMETRIC))
        -: 3858:		{
    #####: 3859:			TIFFWarningExt(tif->tif_clientdata, module,
        -: 3860:			    "Photometric tag is missing, assuming data is YCbCr");
    #####: 3861:			if (!TIFFSetField(tif,TIFFTAG_PHOTOMETRIC,PHOTOMETRIC_YCBCR))
    #####: 3862:				goto bad;
        -: 3863:		}
    #####: 3864:		else if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
        -: 3865:		{
    #####: 3866:			tif->tif_dir.td_photometric=PHOTOMETRIC_YCBCR;
    #####: 3867:			TIFFWarningExt(tif->tif_clientdata, module,
        -: 3868:			    "Photometric tag value assumed incorrect, "
        -: 3869:			    "assuming data is YCbCr instead of RGB");
        -: 3870:		}
    #####: 3871:		if (!TIFFFieldSet(tif,FIELD_BITSPERSAMPLE))
        -: 3872:		{
    #####: 3873:			TIFFWarningExt(tif->tif_clientdata,module,
        -: 3874:			    "BitsPerSample tag is missing, assuming 8 bits per sample");
    #####: 3875:			if (!TIFFSetField(tif,TIFFTAG_BITSPERSAMPLE,8))
    #####: 3876:				goto bad;
        -: 3877:		}
    #####: 3878:		if (!TIFFFieldSet(tif,FIELD_SAMPLESPERPIXEL))
        -: 3879:		{
    #####: 3880:			if (tif->tif_dir.td_photometric==PHOTOMETRIC_RGB)
        -: 3881:			{
    #####: 3882:				TIFFWarningExt(tif->tif_clientdata,module,
        -: 3883:				    "SamplesPerPixel tag is missing, "
        -: 3884:				    "assuming correct SamplesPerPixel value is 3");
    #####: 3885:				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
    #####: 3886:					goto bad;
        -: 3887:			}
    #####: 3888:			if (tif->tif_dir.td_photometric==PHOTOMETRIC_YCBCR)
        -: 3889:			{
    #####: 3890:				TIFFWarningExt(tif->tif_clientdata,module,
        -: 3891:				    "SamplesPerPixel tag is missing, "
        -: 3892:				    "applying correct SamplesPerPixel value of 3");
    #####: 3893:				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,3))
    #####: 3894:					goto bad;
        -: 3895:			}
    #####: 3896:			else if ((tif->tif_dir.td_photometric==PHOTOMETRIC_MINISWHITE)
    #####: 3897:				 || (tif->tif_dir.td_photometric==PHOTOMETRIC_MINISBLACK))
        -: 3898:			{
        -: 3899:				/*
        -: 3900:				 * SamplesPerPixel tag is missing, but is not required
        -: 3901:				 * by spec.  Assume correct SamplesPerPixel value of 1.
        -: 3902:				 */
    #####: 3903:				if (!TIFFSetField(tif,TIFFTAG_SAMPLESPERPIXEL,1))
    #####: 3904:					goto bad;
        -: 3905:			}
        -: 3906:		}
        -: 3907:	}
        -: 3908:	/*
        -: 3909:	 * Verify Palette image has a Colormap.
        -: 3910:	 */
       1*: 3911:	if (tif->tif_dir.td_photometric == PHOTOMETRIC_PALETTE &&
    #####: 3912:	    !TIFFFieldSet(tif, FIELD_COLORMAP)) {
    #####: 3913:		if ( tif->tif_dir.td_bitspersample>=8 && tif->tif_dir.td_samplesperpixel==3)
    #####: 3914:			tif->tif_dir.td_photometric = PHOTOMETRIC_RGB;
    #####: 3915:		else if (tif->tif_dir.td_bitspersample>=8)
    #####: 3916:			tif->tif_dir.td_photometric = PHOTOMETRIC_MINISBLACK;
        -: 3917:		else {
    #####: 3918:			MissingRequired(tif, "Colormap");
    #####: 3919:			goto bad;
        -: 3920:		}
        -: 3921:	}
        -: 3922:	/*
        -: 3923:	 * OJPEG hack:
        -: 3924:	 * We do no further messing with strip/tile offsets/bytecounts in OJPEG
        -: 3925:	 * TIFFs
        -: 3926:	 */
        1: 3927:	if (tif->tif_dir.td_compression!=COMPRESSION_OJPEG)
        -: 3928:	{
        -: 3929:		/*
        -: 3930:		 * Attempt to deal with a missing StripByteCounts tag.
        -: 3931:		 */
        1: 3932:		if (!TIFFFieldSet(tif, FIELD_STRIPBYTECOUNTS)) {
        -: 3933:			/*
        -: 3934:			 * Some manufacturers violate the spec by not giving
        -: 3935:			 * the size of the strips.  In this case, assume there
        -: 3936:			 * is one uncompressed strip of data.
        -: 3937:			 */
    #####: 3938:			if ((tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG &&
    #####: 3939:			    tif->tif_dir.td_nstrips > 1) ||
    #####: 3940:			    (tif->tif_dir.td_planarconfig == PLANARCONFIG_SEPARATE &&
    #####: 3941:			     tif->tif_dir.td_nstrips != (uint32)tif->tif_dir.td_samplesperpixel)) {
    #####: 3942:			    MissingRequired(tif, "StripByteCounts");
    #####: 3943:			    goto bad;
        -: 3944:			}
    #####: 3945:			TIFFWarningExt(tif->tif_clientdata, module,
        -: 3946:				"TIFF directory is missing required "
        -: 3947:				"\"StripByteCounts\" field, calculating from imagelength");
    #####: 3948:			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
    #####: 3949:			    goto bad;
        -: 3950:		/*
        -: 3951:		 * Assume we have wrong StripByteCount value (in case
        -: 3952:		 * of single strip) in following cases:
        -: 3953:		 *   - it is equal to zero along with StripOffset;
        -: 3954:		 *   - it is larger than file itself (in case of uncompressed
        -: 3955:		 *     image);
        -: 3956:		 *   - it is smaller than the size of the bytes per row
        -: 3957:		 *     multiplied on the number of rows.  The last case should
        -: 3958:		 *     not be checked in the case of writing new image,
        -: 3959:		 *     because we may do not know the exact strip size
        -: 3960:		 *     until the whole image will be written and directory
        -: 3961:		 *     dumped out.
        -: 3962:		 */
        -: 3963:		#define	BYTECOUNTLOOKSBAD \
        -: 3964:		    ( (tif->tif_dir.td_stripbytecount[0] == 0 && tif->tif_dir.td_stripoffset[0] != 0) || \
        -: 3965:		      (tif->tif_dir.td_compression == COMPRESSION_NONE && \
        -: 3966:		       tif->tif_dir.td_stripbytecount[0] > TIFFGetFileSize(tif) - tif->tif_dir.td_stripoffset[0]) || \
        -: 3967:		      (tif->tif_mode == O_RDONLY && \
        -: 3968:		       tif->tif_dir.td_compression == COMPRESSION_NONE && \
        -: 3969:		       tif->tif_dir.td_stripbytecount[0] < TIFFScanlineSize64(tif) * tif->tif_dir.td_imagelength) )
        -: 3970:
        1: 3971:		} else if (tif->tif_dir.td_nstrips == 1
    #####: 3972:                           && _TIFFFillStriles(tif)
    #####: 3973:			   && tif->tif_dir.td_stripoffset[0] != 0
    #####: 3974:			   && BYTECOUNTLOOKSBAD) {
        -: 3975:			/*
        -: 3976:			 * XXX: Plexus (and others) sometimes give a value of
        -: 3977:			 * zero for a tag when they don't know what the
        -: 3978:			 * correct value is!  Try and handle the simple case
        -: 3979:			 * of estimating the size of a one strip image.
        -: 3980:			 */
    #####: 3981:			TIFFWarningExt(tif->tif_clientdata, module,
        -: 3982:			    "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength");
    #####: 3983:			if(EstimateStripByteCounts(tif, dir, dircount) < 0)
    #####: 3984:			    goto bad;
        -: 3985:
        -: 3986:#if !defined(DEFER_STRILE_LOAD)
        1: 3987:		} else if (tif->tif_dir.td_planarconfig == PLANARCONFIG_CONTIG
        1: 3988:			   && tif->tif_dir.td_nstrips > 2
        1: 3989:			   && tif->tif_dir.td_compression == COMPRESSION_NONE
    #####: 3990:			   && tif->tif_dir.td_stripbytecount[0] != tif->tif_dir.td_stripbytecount[1]
    #####: 3991:			   && tif->tif_dir.td_stripbytecount[0] != 0
    #####: 3992:			   && tif->tif_dir.td_stripbytecount[1] != 0 ) {
        -: 3993:			/*
        -: 3994:			 * XXX: Some vendors fill StripByteCount array with
        -: 3995:			 * absolutely wrong values (it can be equal to
        -: 3996:			 * StripOffset array, for example). Catch this case
        -: 3997:			 * here.
        -: 3998:                         *
        -: 3999:                         * We avoid this check if deferring strile loading
        -: 4000:                         * as it would always force us to load the strip/tile
        -: 4001:                         * information.
        -: 4002:			 */
    #####: 4003:			TIFFWarningExt(tif->tif_clientdata, module,
        -: 4004:			    "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength");
    #####: 4005:			if (EstimateStripByteCounts(tif, dir, dircount) < 0)
    #####: 4006:			    goto bad;
        -: 4007:#endif /* !defined(DEFER_STRILE_LOAD) */                        
        -: 4008:		}
        -: 4009:	}
        1: 4010:	if (dir)
        -: 4011:	{
        1: 4012:		_TIFFfree(dir);
        1: 4013:		dir=NULL;
        -: 4014:	}
        1: 4015:	if (!TIFFFieldSet(tif, FIELD_MAXSAMPLEVALUE))
        -: 4016:	{
    #####: 4017:		if (tif->tif_dir.td_bitspersample>=16)
    #####: 4018:			tif->tif_dir.td_maxsamplevalue=0xFFFF;
        -: 4019:		else
    #####: 4020:			tif->tif_dir.td_maxsamplevalue = (uint16)((1L<<tif->tif_dir.td_bitspersample)-1);
        -: 4021:	}
        -: 4022:	/*
        -: 4023:	 * XXX: We can optimize checking for the strip bounds using the sorted
        -: 4024:	 * bytecounts array. See also comments for TIFFAppendToStrip()
        -: 4025:	 * function in tif_write.c.
        -: 4026:	 */
        -: 4027:#if !defined(DEFER_STRILE_LOAD)        
        1: 4028:	if (tif->tif_dir.td_nstrips > 1) {
        -: 4029:		uint32 strip;
        -: 4030:
        1: 4031:		tif->tif_dir.td_stripbytecountsorted = 1;
       1*: 4032:		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {
        1: 4033:			if (tif->tif_dir.td_stripoffset[strip - 1] >
        1: 4034:			    tif->tif_dir.td_stripoffset[strip]) {
        1: 4035:				tif->tif_dir.td_stripbytecountsorted = 0;
        1: 4036:				break;
        -: 4037:			}
        -: 4038:		}
        -: 4039:	}
        -: 4040:#endif /* !defined(DEFER_STRILE_LOAD) */
        -: 4041:        
        -: 4042:	/*
        -: 4043:	 * An opportunity for compression mode dependent tag fixup
        -: 4044:	 */
        1: 4045:	(*tif->tif_fixuptags)(tif);
        -: 4046:
        -: 4047:	/*
        -: 4048:	 * Some manufacturers make life difficult by writing
        -: 4049:	 * large amounts of uncompressed data as a single strip.
        -: 4050:	 * This is contrary to the recommendations of the spec.
        -: 4051:	 * The following makes an attempt at breaking such images
        -: 4052:	 * into strips closer to the recommended 8k bytes.  A
        -: 4053:	 * side effect, however, is that the RowsPerStrip tag
        -: 4054:	 * value may be changed.
        -: 4055:	 */
        1: 4056:	if ((tif->tif_dir.td_planarconfig==PLANARCONFIG_CONTIG)&&
       1*: 4057:	    (tif->tif_dir.td_nstrips==1)&&
    #####: 4058:	    (tif->tif_dir.td_compression==COMPRESSION_NONE)&&  
    #####: 4059:	    ((tif->tif_flags&(TIFF_STRIPCHOP|TIFF_ISTILED))==TIFF_STRIPCHOP))
        -: 4060:    {
    #####: 4061:        if ( !_TIFFFillStriles(tif) || !tif->tif_dir.td_stripbytecount )
    #####: 4062:            return 0;
    #####: 4063:		ChopUpSingleUncompressedStrip(tif);
        -: 4064:    }
        -: 4065:
        -: 4066:        /*
        -: 4067:         * Clear the dirty directory flag. 
        -: 4068:         */
        1: 4069:	tif->tif_flags &= ~TIFF_DIRTYDIRECT;
        1: 4070:	tif->tif_flags &= ~TIFF_DIRTYSTRIP;
        -: 4071:
        -: 4072:	/*
        -: 4073:	 * Reinitialize i/o since we are starting on a new directory.
        -: 4074:	 */
        1: 4075:	tif->tif_row = (uint32) -1;
        1: 4076:	tif->tif_curstrip = (uint32) -1;
        1: 4077:	tif->tif_col = (uint32) -1;
        1: 4078:	tif->tif_curtile = (uint32) -1;
        1: 4079:	tif->tif_tilesize = (tmsize_t) -1;
        -: 4080:
        1: 4081:	tif->tif_scanlinesize = TIFFScanlineSize(tif);
        1: 4082:	if (!tif->tif_scanlinesize) {
    #####: 4083:		TIFFErrorExt(tif->tif_clientdata, module,
        -: 4084:		    "Cannot handle zero scanline size");
    #####: 4085:		return (0);
        -: 4086:	}
        -: 4087:
        1: 4088:	if (isTiled(tif)) {
    #####: 4089:		tif->tif_tilesize = TIFFTileSize(tif);
    #####: 4090:		if (!tif->tif_tilesize) {
    #####: 4091:			TIFFErrorExt(tif->tif_clientdata, module,
        -: 4092:			     "Cannot handle zero tile size");
    #####: 4093:			return (0);
        -: 4094:		}
        -: 4095:	} else {
        1: 4096:		if (!TIFFStripSize(tif)) {
    #####: 4097:			TIFFErrorExt(tif->tif_clientdata, module,
        -: 4098:			    "Cannot handle zero strip size");
    #####: 4099:			return (0);
        -: 4100:		}
        -: 4101:	}
        1: 4102:	return (1);
    #####: 4103:bad:
    #####: 4104:	if (dir)
    #####: 4105:		_TIFFfree(dir);
    #####: 4106:	return (0);
        -: 4107:}
        -: 4108:
        -: 4109:static void
        1: 4110:TIFFReadDirectoryCheckOrder(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
        -: 4111:{
        -: 4112:	static const char module[] = "TIFFReadDirectoryCheckOrder";
        -: 4113:	uint16 m;
        -: 4114:	uint16 n;
        -: 4115:	TIFFDirEntry* o;
        1: 4116:	m=0;
        9: 4117:	for (n=0, o=dir; n<dircount; n++, o++)
        -: 4118:	{
        9: 4119:		if (o->tdir_tag<m)
        -: 4120:		{
        1: 4121:			TIFFWarningExt(tif->tif_clientdata,module,
        -: 4122:			    "Invalid TIFF directory; tags are not sorted in ascending order");
        1: 4123:			break;
        -: 4124:		}
        8: 4125:		m=o->tdir_tag+1;
        -: 4126:	}
        1: 4127:}
        -: 4128:
        -: 4129:static TIFFDirEntry*
        2: 4130:TIFFReadDirectoryFindEntry(TIFF* tif, TIFFDirEntry* dir, uint16 dircount, uint16 tagid)
        -: 4131:{
        -: 4132:	TIFFDirEntry* m;
        -: 4133:	uint16 n;
        -: 4134:	(void) tif;
       23: 4135:	for (m=dir, n=0; n<dircount; m++, n++)
        -: 4136:	{
       22: 4137:		if (m->tdir_tag==tagid)
        1: 4138:			return(m);
        -: 4139:	}
        1: 4140:	return(0);
        -: 4141:}
        -: 4142:
        -: 4143:static void
       30: 4144:TIFFReadDirectoryFindFieldInfo(TIFF* tif, uint16 tagid, uint32* fii)
        -: 4145:{
        -: 4146:	int32 ma,mb,mc;
       30: 4147:	ma=-1;
       30: 4148:	mc=(int32)tif->tif_nfields;
        -: 4149:	while (1)
        -: 4150:	{
      187: 4151:		if (ma+1==mc)
        -: 4152:		{
    #####: 4153:			*fii = FAILED_FII;
    #####: 4154:			return;
        -: 4155:		}
      187: 4156:		mb=(ma+mc)/2;
      187: 4157:		if (tif->tif_fields[mb]->field_tag==(uint32)tagid)
       30: 4158:			break;
      157: 4159:		if (tif->tif_fields[mb]->field_tag<(uint32)tagid)
       60: 4160:			ma=mb;
        -: 4161:		else
       97: 4162:			mc=mb;
        -: 4163:	}
        -: 4164:	while (1)
        -: 4165:	{
       30: 4166:		if (mb==0)
    #####: 4167:			break;
       30: 4168:		if (tif->tif_fields[mb-1]->field_tag!=(uint32)tagid)
       30: 4169:			break;
    #####: 4170:		mb--;
        -: 4171:	}
       30: 4172:	*fii=mb;
        -: 4173:}
        -: 4174:
        -: 4175:/*
        -: 4176: * Read custom directory from the arbitrary offset.
        -: 4177: * The code is very similar to TIFFReadDirectory().
        -: 4178: */
        -: 4179:int
    #####: 4180:TIFFReadCustomDirectory(TIFF* tif, toff_t diroff,
        -: 4181:			const TIFFFieldArray* infoarray)
        -: 4182:{
        -: 4183:	static const char module[] = "TIFFReadCustomDirectory";
    #####: 4184:	TIFFDirEntry* dir;
        -: 4185:	uint16 dircount;
        -: 4186:	TIFFDirEntry* dp;
        -: 4187:	uint16 di;
        -: 4188:	const TIFFField* fip;
    #####: 4189:	uint32 fii;
    #####: 4190:	_TIFFSetupFields(tif, infoarray);
    #####: 4191:	dircount=TIFFFetchDirectory(tif,diroff,&dir,NULL);
    #####: 4192:	if (!dircount)
        -: 4193:	{
    #####: 4194:		TIFFErrorExt(tif->tif_clientdata,module,
        -: 4195:		    "Failed to read custom directory at offset " TIFF_UINT64_FORMAT,diroff);
    #####: 4196:		return 0;
        -: 4197:	}
    #####: 4198:	TIFFFreeDirectory(tif);
    #####: 4199:	_TIFFmemset(&tif->tif_dir, 0, sizeof(TIFFDirectory));
    #####: 4200:	TIFFReadDirectoryCheckOrder(tif,dir,dircount);
    #####: 4201:	for (di=0, dp=dir; di<dircount; di++, dp++)
        -: 4202:	{
    #####: 4203:		TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
    #####: 4204:		if (fii == FAILED_FII)
        -: 4205:		{
    #####: 4206:			TIFFWarningExt(tif->tif_clientdata, module,
        -: 4207:			    "Unknown field with tag %d (0x%x) encountered",
    #####: 4208:			    dp->tdir_tag, dp->tdir_tag);
    #####: 4209:			if (!_TIFFMergeFields(tif, _TIFFCreateAnonField(tif,
    #####: 4210:						dp->tdir_tag,
    #####: 4211:						(TIFFDataType) dp->tdir_type),
        -: 4212:					     1)) {
    #####: 4213:				TIFFWarningExt(tif->tif_clientdata, module,
        -: 4214:				    "Registering anonymous field with tag %d (0x%x) failed",
    #####: 4215:				    dp->tdir_tag, dp->tdir_tag);
    #####: 4216:				dp->tdir_tag=IGNORE;
        -: 4217:			} else {
    #####: 4218:				TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
    #####: 4219:				assert( fii != FAILED_FII );
        -: 4220:			}
        -: 4221:		}
    #####: 4222:		if (dp->tdir_tag!=IGNORE)
        -: 4223:		{
    #####: 4224:			fip=tif->tif_fields[fii];
    #####: 4225:			if (fip->field_bit==FIELD_IGNORE)
    #####: 4226:				dp->tdir_tag=IGNORE;
        -: 4227:			else
        -: 4228:			{
        -: 4229:				/* check data type */
    #####: 4230:				while ((fip->field_type!=TIFF_ANY)&&(fip->field_type!=dp->tdir_type))
        -: 4231:				{
    #####: 4232:					fii++;
    #####: 4233:					if ((fii==tif->tif_nfields)||
    #####: 4234:					    (tif->tif_fields[fii]->field_tag!=(uint32)dp->tdir_tag))
        -: 4235:					{
    #####: 4236:						fii=0xFFFF;
    #####: 4237:						break;
        -: 4238:					}
    #####: 4239:					fip=tif->tif_fields[fii];
        -: 4240:				}
    #####: 4241:				if (fii==0xFFFF)
        -: 4242:				{
    #####: 4243:					TIFFWarningExt(tif->tif_clientdata, module,
        -: 4244:					    "Wrong data type %d for \"%s\"; tag ignored",
    #####: 4245:					    dp->tdir_type,fip->field_name);
    #####: 4246:					dp->tdir_tag=IGNORE;
        -: 4247:				}
        -: 4248:				else
        -: 4249:				{
        -: 4250:					/* check count if known in advance */
    #####: 4251:					if ((fip->field_readcount!=TIFF_VARIABLE)&&
    #####: 4252:					    (fip->field_readcount!=TIFF_VARIABLE2))
        -: 4253:					{
        -: 4254:						uint32 expected;
    #####: 4255:						if (fip->field_readcount==TIFF_SPP)
    #####: 4256:							expected=(uint32)tif->tif_dir.td_samplesperpixel;
        -: 4257:						else
    #####: 4258:							expected=(uint32)fip->field_readcount;
    #####: 4259:						if (!CheckDirCount(tif,dp,expected))
    #####: 4260:							dp->tdir_tag=IGNORE;
        -: 4261:					}
        -: 4262:				}
        -: 4263:			}
    #####: 4264:			switch (dp->tdir_tag)
        -: 4265:			{
    #####: 4266:				case IGNORE:
    #####: 4267:					break;
    #####: 4268:				case EXIFTAG_SUBJECTDISTANCE:
    #####: 4269:					(void) TIFFFetchSubjectDistance(tif,dp);
    #####: 4270:					break;
    #####: 4271:				default:
    #####: 4272:					(void) TIFFFetchNormalTag(tif, dp, TRUE);
    #####: 4273:					break;
        -: 4274:			}
    #####: 4275:		}
        -: 4276:	}
    #####: 4277:	if (dir)
    #####: 4278:		_TIFFfree(dir);
    #####: 4279:	return 1;
        -: 4280:}
        -: 4281:
        -: 4282:/*
        -: 4283: * EXIF is important special case of custom IFD, so we have a special
        -: 4284: * function to read it.
        -: 4285: */
        -: 4286:int
    #####: 4287:TIFFReadEXIFDirectory(TIFF* tif, toff_t diroff)
        -: 4288:{
        -: 4289:	const TIFFFieldArray* exifFieldArray;
    #####: 4290:	exifFieldArray = _TIFFGetExifFields();
    #####: 4291:	return TIFFReadCustomDirectory(tif, diroff, exifFieldArray);  
        -: 4292:}
        -: 4293:
        -: 4294:static int
    #####: 4295:EstimateStripByteCounts(TIFF* tif, TIFFDirEntry* dir, uint16 dircount)
        -: 4296:{
        -: 4297:	static const char module[] = "EstimateStripByteCounts";
        -: 4298:
        -: 4299:	TIFFDirEntry *dp;
    #####: 4300:	TIFFDirectory *td = &tif->tif_dir;
        -: 4301:	uint32 strip;
        -: 4302:
        -: 4303:    /* Do not try to load stripbytecount as we will compute it */
    #####: 4304:        if( !_TIFFFillStrilesInternal( tif, 0 ) )
    #####: 4305:            return -1;
        -: 4306:
    #####: 4307:	if (td->td_stripbytecount)
    #####: 4308:		_TIFFfree(td->td_stripbytecount);
    #####: 4309:	td->td_stripbytecount = (uint64*)
    #####: 4310:	    _TIFFCheckMalloc(tif, td->td_nstrips, sizeof (uint64),
        -: 4311:		"for \"StripByteCounts\" array");
    #####: 4312:        if( td->td_stripbytecount == NULL )
    #####: 4313:            return -1;
        -: 4314:
    #####: 4315:	if (td->td_compression != COMPRESSION_NONE) {
        -: 4316:		uint64 space;
        -: 4317:		uint64 filesize;
        -: 4318:		uint16 n;
    #####: 4319:		filesize = TIFFGetFileSize(tif);
    #####: 4320:		if (!(tif->tif_flags&TIFF_BIGTIFF))
    #####: 4321:			space=sizeof(TIFFHeaderClassic)+2+dircount*12+4;
        -: 4322:		else
    #####: 4323:			space=sizeof(TIFFHeaderBig)+8+dircount*20+8;
        -: 4324:		/* calculate amount of space used by indirect values */
    #####: 4325:		for (dp = dir, n = dircount; n > 0; n--, dp++)
        -: 4326:		{
        -: 4327:			uint32 typewidth;
        -: 4328:			uint64 datasize;
    #####: 4329:			typewidth = TIFFDataWidth((TIFFDataType) dp->tdir_type);
    #####: 4330:			if (typewidth == 0) {
    #####: 4331:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4332:				    "Cannot determine size of unknown tag type %d",
    #####: 4333:				    dp->tdir_type);
    #####: 4334:				return -1;
        -: 4335:			}
    #####: 4336:			datasize=(uint64)typewidth*dp->tdir_count;
    #####: 4337:			if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 4338:			{
    #####: 4339:				if (datasize<=4)
    #####: 4340:					datasize=0;
        -: 4341:			}
        -: 4342:			else
        -: 4343:			{
    #####: 4344:				if (datasize<=8)
    #####: 4345:					datasize=0;
        -: 4346:			}
    #####: 4347:			space+=datasize;
        -: 4348:		}
    #####: 4349:		space = filesize - space;
    #####: 4350:		if (td->td_planarconfig == PLANARCONFIG_SEPARATE)
    #####: 4351:			space /= td->td_samplesperpixel;
    #####: 4352:		for (strip = 0; strip < td->td_nstrips; strip++)
    #####: 4353:			td->td_stripbytecount[strip] = space;
        -: 4354:		/*
        -: 4355:		 * This gross hack handles the case were the offset to
        -: 4356:		 * the last strip is past the place where we think the strip
        -: 4357:		 * should begin.  Since a strip of data must be contiguous,
        -: 4358:		 * it's safe to assume that we've overestimated the amount
        -: 4359:		 * of data in the strip and trim this number back accordingly.
        -: 4360:		 */
    #####: 4361:		strip--;
    #####: 4362:		if (td->td_stripoffset[strip]+td->td_stripbytecount[strip] > filesize)
    #####: 4363:			td->td_stripbytecount[strip] = filesize - td->td_stripoffset[strip];
    #####: 4364:	} else if (isTiled(tif)) {
    #####: 4365:		uint64 bytespertile = TIFFTileSize64(tif);
        -: 4366:
    #####: 4367:		for (strip = 0; strip < td->td_nstrips; strip++)
    #####: 4368:		    td->td_stripbytecount[strip] = bytespertile;
        -: 4369:	} else {
    #####: 4370:		uint64 rowbytes = TIFFScanlineSize64(tif);
    #####: 4371:		uint32 rowsperstrip = td->td_imagelength/td->td_stripsperimage;
    #####: 4372:		for (strip = 0; strip < td->td_nstrips; strip++)
    #####: 4373:			td->td_stripbytecount[strip] = rowbytes * rowsperstrip;
        -: 4374:	}
    #####: 4375:	TIFFSetFieldBit(tif, FIELD_STRIPBYTECOUNTS);
    #####: 4376:	if (!TIFFFieldSet(tif, FIELD_ROWSPERSTRIP))
    #####: 4377:		td->td_rowsperstrip = td->td_imagelength;
    #####: 4378:	return 1;
        -: 4379:}
        -: 4380:
        -: 4381:static void
    #####: 4382:MissingRequired(TIFF* tif, const char* tagname)
        -: 4383:{
        -: 4384:	static const char module[] = "MissingRequired";
        -: 4385:
    #####: 4386:	TIFFErrorExt(tif->tif_clientdata, module,
        -: 4387:	    "TIFF directory is missing required \"%s\" field",
        -: 4388:	    tagname);
    #####: 4389:}
        -: 4390:
        -: 4391:/*
        -: 4392: * Check the directory offset against the list of already seen directory
        -: 4393: * offsets. This is a trick to prevent IFD looping. The one can create TIFF
        -: 4394: * file with looped directory pointers. We will maintain a list of already
        -: 4395: * seen directories and check every IFD offset against that list.
        -: 4396: */
        -: 4397:static int
        1: 4398:TIFFCheckDirOffset(TIFF* tif, uint64 diroff)
        -: 4399:{
        -: 4400:	uint16 n;
        -: 4401:
        1: 4402:	if (diroff == 0)			/* no more directories */
    #####: 4403:		return 0;
        1: 4404:	if (tif->tif_dirnumber == 65535) {
    #####: 4405:	    TIFFErrorExt(tif->tif_clientdata, "TIFFCheckDirOffset",
        -: 4406:			 "Cannot handle more than 65535 TIFF directories");
    #####: 4407:	    return 0;
        -: 4408:	}
        -: 4409:
       1*: 4410:	for (n = 0; n < tif->tif_dirnumber && tif->tif_dirlist; n++) {
    #####: 4411:		if (tif->tif_dirlist[n] == diroff)
    #####: 4412:			return 0;
        -: 4413:	}
        -: 4414:
        1: 4415:	tif->tif_dirnumber++;
        -: 4416:
       1*: 4417:	if (tif->tif_dirlist == NULL || tif->tif_dirnumber > tif->tif_dirlistsize) {
        -: 4418:		uint64* new_dirlist;
        -: 4419:
        -: 4420:		/*
        -: 4421:		 * XXX: Reduce memory allocation granularity of the dirlist
        -: 4422:		 * array.
        -: 4423:		 */
        1: 4424:		new_dirlist = (uint64*)_TIFFCheckRealloc(tif, tif->tif_dirlist,
        1: 4425:		    tif->tif_dirnumber, 2 * sizeof(uint64), "for IFD list");
        1: 4426:		if (!new_dirlist)
    #####: 4427:			return 0;
        1: 4428:		if( tif->tif_dirnumber >= 32768 )
    #####: 4429:		    tif->tif_dirlistsize = 65535;
        -: 4430:		else
        1: 4431:		    tif->tif_dirlistsize = 2 * tif->tif_dirnumber;
        1: 4432:		tif->tif_dirlist = new_dirlist;
        -: 4433:	}
        -: 4434:
        1: 4435:	tif->tif_dirlist[tif->tif_dirnumber - 1] = diroff;
        -: 4436:
        1: 4437:	return 1;
        -: 4438:}
        -: 4439:
        -: 4440:/*
        -: 4441: * Check the count field of a directory entry against a known value.  The
        -: 4442: * caller is expected to skip/ignore the tag if there is a mismatch.
        -: 4443: */
        -: 4444:static int
    #####: 4445:CheckDirCount(TIFF* tif, TIFFDirEntry* dir, uint32 count)
        -: 4446:{
    #####: 4447:	if ((uint64)count > dir->tdir_count) {
    #####: 4448:		const TIFFField* fip = TIFFFieldWithTag(tif, dir->tdir_tag);
    #####: 4449:		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
        -: 4450:	"incorrect count for field \"%s\" (" TIFF_UINT64_FORMAT ", expecting %u); tag ignored",
        -: 4451:		    fip ? fip->field_name : "unknown tagname",
        -: 4452:		    dir->tdir_count, count);
    #####: 4453:		return (0);
    #####: 4454:	} else if ((uint64)count < dir->tdir_count) {
    #####: 4455:		const TIFFField* fip = TIFFFieldWithTag(tif, dir->tdir_tag);
    #####: 4456:		TIFFWarningExt(tif->tif_clientdata, tif->tif_name,
        -: 4457:	"incorrect count for field \"%s\" (" TIFF_UINT64_FORMAT ", expecting %u); tag trimmed",
        -: 4458:		    fip ? fip->field_name : "unknown tagname",
        -: 4459:		    dir->tdir_count, count);
    #####: 4460:		dir->tdir_count = count;
    #####: 4461:		return (1);
        -: 4462:	}
    #####: 4463:	return (1);
        -: 4464:}
        -: 4465:
        -: 4466:/*
        -: 4467: * Read IFD structure from the specified offset. If the pointer to
        -: 4468: * nextdiroff variable has been specified, read it too. Function returns a
        -: 4469: * number of fields in the directory or 0 if failed.
        -: 4470: */
        -: 4471:static uint16
        1: 4472:TIFFFetchDirectory(TIFF* tif, uint64 diroff, TIFFDirEntry** pdir,
        -: 4473:                   uint64 *nextdiroff)
        -: 4474:{
        -: 4475:	static const char module[] = "TIFFFetchDirectory";
        -: 4476:
        -: 4477:	void* origdir;
        1: 4478:	uint16 dircount16;
        -: 4479:	uint32 dirsize;
        -: 4480:	TIFFDirEntry* dir;
        -: 4481:	uint8* ma;
        -: 4482:	TIFFDirEntry* mb;
        -: 4483:	uint16 n;
        -: 4484:
       1*: 4485:	assert(pdir);
        -: 4486:
        1: 4487:	tif->tif_diroff = diroff;
        1: 4488:	if (nextdiroff)
        1: 4489:		*nextdiroff = 0;
        1: 4490:	if (!isMapped(tif)) {
    #####: 4491:		if (!SeekOK(tif, tif->tif_diroff)) {
    #####: 4492:			TIFFErrorExt(tif->tif_clientdata, module,
        -: 4493:				"%s: Seek error accessing TIFF directory",
        -: 4494:				tif->tif_name);
    #####: 4495:			return 0;
        -: 4496:		}
    #####: 4497:		if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 4498:		{
    #####: 4499:			if (!ReadOK(tif, &dircount16, sizeof (uint16))) {
    #####: 4500:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4501:				    "%s: Can not read TIFF directory count",
        -: 4502:				    tif->tif_name);
    #####: 4503:				return 0;
        -: 4504:			}
    #####: 4505:			if (tif->tif_flags & TIFF_SWAB)
    #####: 4506:				TIFFSwabShort(&dircount16);
    #####: 4507:			if (dircount16>4096)
        -: 4508:			{
    #####: 4509:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4510:				    "Sanity check on directory count failed, this is probably not a valid IFD offset");
    #####: 4511:				return 0;
        -: 4512:			}
    #####: 4513:			dirsize = 12;
        -: 4514:		} else {
    #####: 4515:			uint64 dircount64;
    #####: 4516:			if (!ReadOK(tif, &dircount64, sizeof (uint64))) {
    #####: 4517:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4518:					"%s: Can not read TIFF directory count",
        -: 4519:					tif->tif_name);
    #####: 4520:				return 0;
        -: 4521:			}
    #####: 4522:			if (tif->tif_flags & TIFF_SWAB)
    #####: 4523:				TIFFSwabLong8(&dircount64);
    #####: 4524:			if (dircount64>4096)
        -: 4525:			{
    #####: 4526:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4527:				    "Sanity check on directory count failed, this is probably not a valid IFD offset");
    #####: 4528:				return 0;
        -: 4529:			}
    #####: 4530:			dircount16 = (uint16)dircount64;
    #####: 4531:			dirsize = 20;
        -: 4532:		}
    #####: 4533:		origdir = _TIFFCheckMalloc(tif, dircount16,
        -: 4534:		    dirsize, "to read TIFF directory");
    #####: 4535:		if (origdir == NULL)
    #####: 4536:			return 0;
    #####: 4537:		if (!ReadOK(tif, origdir, (tmsize_t)(dircount16*dirsize))) {
    #####: 4538:			TIFFErrorExt(tif->tif_clientdata, module,
        -: 4539:				"%.100s: Can not read TIFF directory",
        -: 4540:				tif->tif_name);
    #####: 4541:			_TIFFfree(origdir);
    #####: 4542:			return 0;
        -: 4543:		}
        -: 4544:		/*
        -: 4545:		 * Read offset to next directory for sequential scans if
        -: 4546:		 * needed.
        -: 4547:		 */
    #####: 4548:		if (nextdiroff)
        -: 4549:		{
    #####: 4550:			if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 4551:			{
    #####: 4552:				uint32 nextdiroff32;
    #####: 4553:				if (!ReadOK(tif, &nextdiroff32, sizeof(uint32)))
    #####: 4554:					nextdiroff32 = 0;
    #####: 4555:				if (tif->tif_flags&TIFF_SWAB)
    #####: 4556:					TIFFSwabLong(&nextdiroff32);
    #####: 4557:				*nextdiroff=nextdiroff32;
        -: 4558:			} else {
    #####: 4559:				if (!ReadOK(tif, nextdiroff, sizeof(uint64)))
    #####: 4560:					*nextdiroff = 0;
    #####: 4561:				if (tif->tif_flags&TIFF_SWAB)
    #####: 4562:					TIFFSwabLong8(nextdiroff);
        -: 4563:			}
        -: 4564:		}
        -: 4565:	} else {
        -: 4566:		tmsize_t m;
        1: 4567:		tmsize_t off = (tmsize_t) tif->tif_diroff;
        1: 4568:		if ((uint64)off!=tif->tif_diroff)
        -: 4569:		{
    #####: 4570:			TIFFErrorExt(tif->tif_clientdata,module,"Can not read TIFF directory count");
    #####: 4571:			return(0);
        -: 4572:		}
        -: 4573:
        -: 4574:		/*
        -: 4575:		 * Check for integer overflow when validating the dir_off,
        -: 4576:		 * otherwise a very high offset may cause an OOB read and
        -: 4577:		 * crash the client. Make two comparisons instead of
        -: 4578:		 *
        -: 4579:		 *  off + sizeof(uint16) > tif->tif_size
        -: 4580:		 *
        -: 4581:		 * to avoid overflow.
        -: 4582:		 */
        1: 4583:		if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 4584:		{
    #####: 4585:			m=off+sizeof(uint16);
    #####: 4586:			if ((m<off)||(m<(tmsize_t)sizeof(uint16))||(m>tif->tif_size)) {
    #####: 4587:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4588:					"Can not read TIFF directory count");
    #####: 4589:				return 0;
        -: 4590:			} else {
    #####: 4591:				_TIFFmemcpy(&dircount16, tif->tif_base + off,
        -: 4592:					    sizeof(uint16));
        -: 4593:			}
    #####: 4594:			off += sizeof (uint16);
    #####: 4595:			if (tif->tif_flags & TIFF_SWAB)
    #####: 4596:				TIFFSwabShort(&dircount16);
    #####: 4597:			if (dircount16>4096)
        -: 4598:			{
    #####: 4599:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4600:				    "Sanity check on directory count failed, this is probably not a valid IFD offset");
    #####: 4601:				return 0;
        -: 4602:			}
    #####: 4603:			dirsize = 12;
        -: 4604:		}
        -: 4605:		else
        -: 4606:		{
        1: 4607:			uint64 dircount64;
        1: 4608:			m=off+sizeof(uint64);
        1: 4609:			if ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size)) {
    #####: 4610:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4611:					"Can not read TIFF directory count");
    #####: 4612:				return 0;
        -: 4613:			} else {
        1: 4614:				_TIFFmemcpy(&dircount64, tif->tif_base + off,
        -: 4615:					    sizeof(uint64));
        -: 4616:			}
        1: 4617:			off += sizeof (uint64);
        1: 4618:			if (tif->tif_flags & TIFF_SWAB)
    #####: 4619:				TIFFSwabLong8(&dircount64);
        1: 4620:			if (dircount64>4096)
        -: 4621:			{
    #####: 4622:				TIFFErrorExt(tif->tif_clientdata, module,
        -: 4623:				    "Sanity check on directory count failed, this is probably not a valid IFD offset");
    #####: 4624:				return 0;
        -: 4625:			}
        1: 4626:			dircount16 = (uint16)dircount64;
        1: 4627:			dirsize = 20;
        -: 4628:		}
        1: 4629:		if (dircount16 == 0 )
        -: 4630:		{
    #####: 4631:			TIFFErrorExt(tif->tif_clientdata, module,
        -: 4632:			             "Sanity check on directory count failed, zero tag directories not supported");
    #####: 4633:			return 0;
        -: 4634:		}
        1: 4635:		origdir = _TIFFCheckMalloc(tif, dircount16,
        -: 4636:						dirsize,
        -: 4637:						"to read TIFF directory");
        1: 4638:		if (origdir == NULL)
    #####: 4639:			return 0;
        1: 4640:		m=off+dircount16*dirsize;
        1: 4641:		if ((m<off)||(m<(tmsize_t)(dircount16*dirsize))||(m>tif->tif_size)) {
    #####: 4642:			TIFFErrorExt(tif->tif_clientdata, module,
        -: 4643:				     "Can not read TIFF directory");
    #####: 4644:			_TIFFfree(origdir);
    #####: 4645:			return 0;
        -: 4646:		} else {
        1: 4647:			_TIFFmemcpy(origdir, tif->tif_base + off,
        1: 4648:				    dircount16 * dirsize);
        -: 4649:		}
        1: 4650:		if (nextdiroff) {
        1: 4651:			off += dircount16 * dirsize;
        1: 4652:			if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 4653:			{
    #####: 4654:				uint32 nextdiroff32;
    #####: 4655:				m=off+sizeof(uint32);
    #####: 4656:				if ((m<off)||(m<(tmsize_t)sizeof(uint32))||(m>tif->tif_size))
    #####: 4657:					nextdiroff32 = 0;
        -: 4658:				else
    #####: 4659:					_TIFFmemcpy(&nextdiroff32, tif->tif_base + off,
        -: 4660:						    sizeof (uint32));
    #####: 4661:				if (tif->tif_flags&TIFF_SWAB)
    #####: 4662:					TIFFSwabLong(&nextdiroff32);
    #####: 4663:				*nextdiroff = nextdiroff32;
        -: 4664:			}
        -: 4665:			else
        -: 4666:			{
        1: 4667:				m=off+sizeof(uint64);
        1: 4668:				if ((m<off)||(m<(tmsize_t)sizeof(uint64))||(m>tif->tif_size))
    #####: 4669:					*nextdiroff = 0;
        -: 4670:				else
        1: 4671:					_TIFFmemcpy(nextdiroff, tif->tif_base + off,
        -: 4672:						    sizeof (uint64));
        1: 4673:				if (tif->tif_flags&TIFF_SWAB)
    #####: 4674:					TIFFSwabLong8(nextdiroff);
        -: 4675:			}
        -: 4676:		}
        -: 4677:	}
        1: 4678:	dir = (TIFFDirEntry*)_TIFFCheckMalloc(tif, dircount16,
        -: 4679:						sizeof(TIFFDirEntry),
        -: 4680:						"to read TIFF directory");
        1: 4681:	if (dir==0)
        -: 4682:	{
    #####: 4683:		_TIFFfree(origdir);
    #####: 4684:		return 0;
        -: 4685:	}
        1: 4686:	ma=(uint8*)origdir;
        1: 4687:	mb=dir;
       19: 4688:	for (n=0; n<dircount16; n++)
        -: 4689:	{
       18: 4690:		if (tif->tif_flags&TIFF_SWAB)
    #####: 4691:			TIFFSwabShort((uint16*)ma);
       18: 4692:		mb->tdir_tag=*(uint16*)ma;
       18: 4693:		ma+=sizeof(uint16);
       18: 4694:		if (tif->tif_flags&TIFF_SWAB)
    #####: 4695:			TIFFSwabShort((uint16*)ma);
       18: 4696:		mb->tdir_type=*(uint16*)ma;
       18: 4697:		ma+=sizeof(uint16);
       18: 4698:		if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 4699:		{
    #####: 4700:			if (tif->tif_flags&TIFF_SWAB)
    #####: 4701:				TIFFSwabLong((uint32*)ma);
    #####: 4702:			mb->tdir_count=(uint64)(*(uint32*)ma);
    #####: 4703:			ma+=sizeof(uint32);
    #####: 4704:			*(uint32*)(&mb->tdir_offset)=*(uint32*)ma;
    #####: 4705:			ma+=sizeof(uint32);
        -: 4706:		}
        -: 4707:		else
        -: 4708:		{
       18: 4709:			if (tif->tif_flags&TIFF_SWAB)
    #####: 4710:				TIFFSwabLong8((uint64*)ma);
       18: 4711:                        mb->tdir_count=TIFFReadUInt64(ma);
       18: 4712:			ma+=sizeof(uint64);
       18: 4713:			mb->tdir_offset.toff_long8=TIFFReadUInt64(ma);
       18: 4714:			ma+=sizeof(uint64);
        -: 4715:		}
       18: 4716:		mb++;
        -: 4717:	}
        1: 4718:	_TIFFfree(origdir);
        1: 4719:	*pdir = dir;
        1: 4720:	return dircount16;
        -: 4721:}
        -: 4722:
        -: 4723:/*
        -: 4724: * Fetch a tag that is not handled by special case code.
        -: 4725: */
        -: 4726:static int
       13: 4727:TIFFFetchNormalTag(TIFF* tif, TIFFDirEntry* dp, int recover)
        -: 4728:{
        -: 4729:	static const char module[] = "TIFFFetchNormalTag";
        -: 4730:	enum TIFFReadDirEntryErr err;
       13: 4731:	uint32 fii;
       13: 4732:	const TIFFField* fip = NULL;
       13: 4733:	TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii);
       13: 4734:        if( fii == FAILED_FII )
        -: 4735:        {
    #####: 4736:            TIFFErrorExt(tif->tif_clientdata, "TIFFFetchNormalTag",
        -: 4737:                         "No definition found for tag %d",
    #####: 4738:                         dp->tdir_tag);
    #####: 4739:            return 0;
        -: 4740:        }
       13: 4741:	fip=tif->tif_fields[fii];
      13*: 4742:	assert(fip != NULL); /* should not happen */
      13*: 4743:	assert(fip->set_field_type!=TIFF_SETGET_OTHER);  /* if so, we shouldn't arrive here but deal with this in specialized code */
      13*: 4744:	assert(fip->set_field_type!=TIFF_SETGET_INT);    /* if so, we shouldn't arrive here as this is only the case for pseudo-tags */
       13: 4745:	err=TIFFReadDirEntryErrOk;
       13: 4746:	switch (fip->set_field_type)
        -: 4747:	{
    #####: 4748:		case TIFF_SETGET_UNDEFINED:
    #####: 4749:			break;
        2: 4750:		case TIFF_SETGET_ASCII:
        -: 4751:			{
        2: 4752:				uint8* data;
       2*: 4753:				assert(fip->field_passcount==0);
        2: 4754:				err=TIFFReadDirEntryByteArray(tif,dp,&data);
        2: 4755:				if (err==TIFFReadDirEntryErrOk)
        -: 4756:				{
        -: 4757:					uint8* ma;
        -: 4758:					uint32 mb;
        -: 4759:					int n;
        1: 4760:					ma=data;
        1: 4761:					mb=0;
       19: 4762:					while (mb<(uint32)dp->tdir_count)
        -: 4763:					{
       18: 4764:						if (*ma==0)
    #####: 4765:							break;
       18: 4766:						ma++;
       18: 4767:						mb++;
        -: 4768:					}
        1: 4769:					if (mb+1<(uint32)dp->tdir_count)
    #####: 4770:						TIFFWarningExt(tif->tif_clientdata,module,"ASCII value for tag \"%s\" contains null byte in value; value incorrectly truncated during reading due to implementation limitations",fip->field_name);
        1: 4771:					else if (mb+1>(uint32)dp->tdir_count)
        -: 4772:					{
        -: 4773:						uint8* o;
        1: 4774:						TIFFWarningExt(tif->tif_clientdata,module,"ASCII value for tag \"%s\" does not end in null byte",fip->field_name);
        1: 4775:						if ((uint32)dp->tdir_count+1!=dp->tdir_count+1)
    #####: 4776:							o=NULL;
        -: 4777:						else
        1: 4778:							o=_TIFFmalloc((uint32)dp->tdir_count+1);
        1: 4779:						if (o==NULL)
        -: 4780:						{
    #####: 4781:							if (data!=NULL)
    #####: 4782:								_TIFFfree(data);
    #####: 4783:							return(0);
        -: 4784:						}
        1: 4785:						_TIFFmemcpy(o,data,(uint32)dp->tdir_count);
        1: 4786:						o[(uint32)dp->tdir_count]=0;
        1: 4787:						if (data!=0)
        1: 4788:							_TIFFfree(data);
        1: 4789:						data=o;
        -: 4790:					}
        1: 4791:					n=TIFFSetField(tif,dp->tdir_tag,data);
        1: 4792:					if (data!=0)
        1: 4793:						_TIFFfree(data);
        1: 4794:					if (!n)
    #####: 4795:						return(0);
        -: 4796:				}
        -: 4797:			}
        2: 4798:			break;
        1: 4799:		case TIFF_SETGET_UINT8:
        -: 4800:			{
        1: 4801:				uint8 data=0;
       1*: 4802:				assert(fip->field_readcount==1);
       1*: 4803:				assert(fip->field_passcount==0);
        1: 4804:				err=TIFFReadDirEntryByte(tif,dp,&data);
        1: 4805:				if (err==TIFFReadDirEntryErrOk)
        -: 4806:				{
        1: 4807:					if (!TIFFSetField(tif,dp->tdir_tag,data))
    #####: 4808:						return(0);
        -: 4809:				}
        -: 4810:			}
        1: 4811:			break;
        2: 4812:		case TIFF_SETGET_UINT16:
        -: 4813:			{
        2: 4814:				uint16 data;
       2*: 4815:				assert(fip->field_readcount==1);
       2*: 4816:				assert(fip->field_passcount==0);
        2: 4817:				err=TIFFReadDirEntryShort(tif,dp,&data);
        2: 4818:				if (err==TIFFReadDirEntryErrOk)
        -: 4819:				{
        2: 4820:					if (!TIFFSetField(tif,dp->tdir_tag,data))
    #####: 4821:						return(0);
        -: 4822:				}
        -: 4823:			}
        2: 4824:			break;
        3: 4825:		case TIFF_SETGET_UINT32:
        -: 4826:			{
        3: 4827:				uint32 data;
       3*: 4828:				assert(fip->field_readcount==1);
       3*: 4829:				assert(fip->field_passcount==0);
        3: 4830:				err=TIFFReadDirEntryLong(tif,dp,&data);
        3: 4831:				if (err==TIFFReadDirEntryErrOk)
        -: 4832:				{
        3: 4833:					if (!TIFFSetField(tif,dp->tdir_tag,data))
    #####: 4834:						return(0);
        -: 4835:				}
        -: 4836:			}
        3: 4837:			break;
    #####: 4838:		case TIFF_SETGET_UINT64:
        -: 4839:			{
    #####: 4840:				uint64 data;
    #####: 4841:				assert(fip->field_readcount==1);
    #####: 4842:				assert(fip->field_passcount==0);
    #####: 4843:				err=TIFFReadDirEntryLong8(tif,dp,&data);
    #####: 4844:				if (err==TIFFReadDirEntryErrOk)
        -: 4845:				{
    #####: 4846:					if (!TIFFSetField(tif,dp->tdir_tag,data))
    #####: 4847:						return(0);
        -: 4848:				}
        -: 4849:			}
    #####: 4850:			break;
    #####: 4851:		case TIFF_SETGET_FLOAT:
        -: 4852:			{
    #####: 4853:				float data;
    #####: 4854:				assert(fip->field_readcount==1);
    #####: 4855:				assert(fip->field_passcount==0);
    #####: 4856:				err=TIFFReadDirEntryFloat(tif,dp,&data);
    #####: 4857:				if (err==TIFFReadDirEntryErrOk)
        -: 4858:				{
    #####: 4859:					if (!TIFFSetField(tif,dp->tdir_tag,data))
    #####: 4860:						return(0);
        -: 4861:				}
        -: 4862:			}
    #####: 4863:			break;
        2: 4864:		case TIFF_SETGET_DOUBLE:
        -: 4865:			{
        2: 4866:				double data;
       2*: 4867:				assert(fip->field_readcount==1);
       2*: 4868:				assert(fip->field_passcount==0);
        2: 4869:				err=TIFFReadDirEntryDouble(tif,dp,&data);
        2: 4870:				if (err==TIFFReadDirEntryErrOk)
        -: 4871:				{
        2: 4872:					if (!TIFFSetField(tif,dp->tdir_tag,data))
    #####: 4873:						return(0);
        -: 4874:				}
        -: 4875:			}
        2: 4876:			break;
    #####: 4877:		case TIFF_SETGET_IFD8:
        -: 4878:			{
    #####: 4879:				uint64 data;
    #####: 4880:				assert(fip->field_readcount==1);
    #####: 4881:				assert(fip->field_passcount==0);
    #####: 4882:				err=TIFFReadDirEntryIfd8(tif,dp,&data);
    #####: 4883:				if (err==TIFFReadDirEntryErrOk)
        -: 4884:				{
    #####: 4885:					if (!TIFFSetField(tif,dp->tdir_tag,data))
    #####: 4886:						return(0);
        -: 4887:				}
        -: 4888:			}
    #####: 4889:			break;
        1: 4890:		case TIFF_SETGET_UINT16_PAIR:
        -: 4891:			{
        1: 4892:				uint16* data;
       1*: 4893:				assert(fip->field_readcount==2);
       1*: 4894:				assert(fip->field_passcount==0);
        1: 4895:				if (dp->tdir_count!=2) {
    #####: 4896:					TIFFWarningExt(tif->tif_clientdata,module,
        -: 4897:						       "incorrect count for field \"%s\", expected 2, got %d",
    #####: 4898:						       fip->field_name,(int)dp->tdir_count);
    #####: 4899:					return(0);
        -: 4900:				}
        1: 4901:				err=TIFFReadDirEntryShortArray(tif,dp,&data);
        1: 4902:				if (err==TIFFReadDirEntryErrOk)
        -: 4903:				{
        -: 4904:					int m;
        1: 4905:					m=TIFFSetField(tif,dp->tdir_tag,data[0],data[1]);
        1: 4906:					_TIFFfree(data);
        1: 4907:					if (!m)
    #####: 4908:						return(0);
        -: 4909:				}
        -: 4910:			}
        1: 4911:			break;
    #####: 4912:		case TIFF_SETGET_C0_UINT8:
        -: 4913:			{
    #####: 4914:				uint8* data;
    #####: 4915:				assert(fip->field_readcount>=1);
    #####: 4916:				assert(fip->field_passcount==0);
    #####: 4917:				if (dp->tdir_count!=(uint64)fip->field_readcount) {
    #####: 4918:					TIFFWarningExt(tif->tif_clientdata,module,
        -: 4919:						       "incorrect count for field \"%s\", expected %d, got %d",
    #####: 4920:						       fip->field_name,(int) fip->field_readcount, (int)dp->tdir_count);
    #####: 4921:					return 0;
        -: 4922:				}
        -: 4923:				else
        -: 4924:				{
    #####: 4925:					err=TIFFReadDirEntryByteArray(tif,dp,&data);
    #####: 4926:					if (err==TIFFReadDirEntryErrOk)
        -: 4927:					{
        -: 4928:						int m;
    #####: 4929:						m=TIFFSetField(tif,dp->tdir_tag,data);
    #####: 4930:						if (data!=0)
    #####: 4931:							_TIFFfree(data);
    #####: 4932:						if (!m)
    #####: 4933:							return(0);
        -: 4934:					}
        -: 4935:				}
        -: 4936:			}
    #####: 4937:			break;
    #####: 4938:		case TIFF_SETGET_C0_UINT16:
        -: 4939:			{
    #####: 4940:				uint16* data;
    #####: 4941:				assert(fip->field_readcount>=1);
    #####: 4942:				assert(fip->field_passcount==0);
    #####: 4943:				if (dp->tdir_count!=(uint64)fip->field_readcount)
        -: 4944:                                    /* corrupt file */;
        -: 4945:				else
        -: 4946:				{
    #####: 4947:					err=TIFFReadDirEntryShortArray(tif,dp,&data);
    #####: 4948:					if (err==TIFFReadDirEntryErrOk)
        -: 4949:					{
        -: 4950:						int m;
    #####: 4951:						m=TIFFSetField(tif,dp->tdir_tag,data);
    #####: 4952:						if (data!=0)
    #####: 4953:							_TIFFfree(data);
    #####: 4954:						if (!m)
    #####: 4955:							return(0);
        -: 4956:					}
        -: 4957:				}
        -: 4958:			}
    #####: 4959:			break;
    #####: 4960:		case TIFF_SETGET_C0_UINT32:
        -: 4961:			{
    #####: 4962:				uint32* data;
    #####: 4963:				assert(fip->field_readcount>=1);
    #####: 4964:				assert(fip->field_passcount==0);
    #####: 4965:				if (dp->tdir_count!=(uint64)fip->field_readcount)
        -: 4966:                                    /* corrupt file */;
        -: 4967:				else
        -: 4968:				{
    #####: 4969:					err=TIFFReadDirEntryLongArray(tif,dp,&data);
    #####: 4970:					if (err==TIFFReadDirEntryErrOk)
        -: 4971:					{
        -: 4972:						int m;
    #####: 4973:						m=TIFFSetField(tif,dp->tdir_tag,data);
    #####: 4974:						if (data!=0)
    #####: 4975:							_TIFFfree(data);
    #####: 4976:						if (!m)
    #####: 4977:							return(0);
        -: 4978:					}
        -: 4979:				}
        -: 4980:			}
    #####: 4981:			break;
    #####: 4982:		case TIFF_SETGET_C0_FLOAT:
        -: 4983:			{
    #####: 4984:				float* data;
    #####: 4985:				assert(fip->field_readcount>=1);
    #####: 4986:				assert(fip->field_passcount==0);
    #####: 4987:				if (dp->tdir_count!=(uint64)fip->field_readcount)
        -: 4988:                                    /* corrupt file */;
        -: 4989:				else
        -: 4990:				{
    #####: 4991:					err=TIFFReadDirEntryFloatArray(tif,dp,&data);
    #####: 4992:					if (err==TIFFReadDirEntryErrOk)
        -: 4993:					{
        -: 4994:						int m;
    #####: 4995:						m=TIFFSetField(tif,dp->tdir_tag,data);
    #####: 4996:						if (data!=0)
    #####: 4997:							_TIFFfree(data);
    #####: 4998:						if (!m)
    #####: 4999:							return(0);
        -: 5000:					}
        -: 5001:				}
        -: 5002:			}
    #####: 5003:			break;
    #####: 5004:		case TIFF_SETGET_C16_ASCII:
        -: 5005:			{
    #####: 5006:				uint8* data;
    #####: 5007:				assert(fip->field_readcount==TIFF_VARIABLE);
    #####: 5008:				assert(fip->field_passcount==1);
    #####: 5009:				if (dp->tdir_count>0xFFFF)
    #####: 5010:					err=TIFFReadDirEntryErrCount;
        -: 5011:				else
        -: 5012:				{
    #####: 5013:					err=TIFFReadDirEntryByteArray(tif,dp,&data);
    #####: 5014:					if (err==TIFFReadDirEntryErrOk)
        -: 5015:					{
        -: 5016:						int m;
    #####: 5017:                        if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\0' )
        -: 5018:                        {
    #####: 5019:                            TIFFWarningExt(tif->tif_clientdata,module,"ASCII value for tag \"%s\" does not end in null byte. Forcing it to be null",fip->field_name);
    #####: 5020:                            data[dp->tdir_count-1] = '\0';
        -: 5021:                        }
    #####: 5022:						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
    #####: 5023:						if (data!=0)
    #####: 5024:							_TIFFfree(data);
    #####: 5025:						if (!m)
    #####: 5026:							return(0);
        -: 5027:					}
        -: 5028:				}
        -: 5029:			}
    #####: 5030:			break;
    #####: 5031:		case TIFF_SETGET_C16_UINT8:
        -: 5032:			{
    #####: 5033:				uint8* data;
    #####: 5034:				assert(fip->field_readcount==TIFF_VARIABLE);
    #####: 5035:				assert(fip->field_passcount==1);
    #####: 5036:				if (dp->tdir_count>0xFFFF)
    #####: 5037:					err=TIFFReadDirEntryErrCount;
        -: 5038:				else
        -: 5039:				{
    #####: 5040:					err=TIFFReadDirEntryByteArray(tif,dp,&data);
    #####: 5041:					if (err==TIFFReadDirEntryErrOk)
        -: 5042:					{
        -: 5043:						int m;
    #####: 5044:						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
    #####: 5045:						if (data!=0)
    #####: 5046:							_TIFFfree(data);
    #####: 5047:						if (!m)
    #####: 5048:							return(0);
        -: 5049:					}
        -: 5050:				}
        -: 5051:			}
    #####: 5052:			break;
        1: 5053:		case TIFF_SETGET_C16_UINT16:
        -: 5054:			{
        1: 5055:				uint16* data;
       1*: 5056:				assert(fip->field_readcount==TIFF_VARIABLE);
       1*: 5057:				assert(fip->field_passcount==1);
        1: 5058:				if (dp->tdir_count>0xFFFF)
    #####: 5059:					err=TIFFReadDirEntryErrCount;
        -: 5060:				else
        -: 5061:				{
        1: 5062:					err=TIFFReadDirEntryShortArray(tif,dp,&data);
        1: 5063:					if (err==TIFFReadDirEntryErrOk)
        -: 5064:					{
        -: 5065:						int m;
        1: 5066:						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
        1: 5067:						if (data!=0)
        1: 5068:							_TIFFfree(data);
        1: 5069:						if (!m)
    #####: 5070:							return(0);
        -: 5071:					}
        -: 5072:				}
        -: 5073:			}
        1: 5074:			break;
    #####: 5075:		case TIFF_SETGET_C16_UINT32:
        -: 5076:			{
    #####: 5077:				uint32* data;
    #####: 5078:				assert(fip->field_readcount==TIFF_VARIABLE);
    #####: 5079:				assert(fip->field_passcount==1);
    #####: 5080:				if (dp->tdir_count>0xFFFF)
    #####: 5081:					err=TIFFReadDirEntryErrCount;
        -: 5082:				else
        -: 5083:				{
    #####: 5084:					err=TIFFReadDirEntryLongArray(tif,dp,&data);
    #####: 5085:					if (err==TIFFReadDirEntryErrOk)
        -: 5086:					{
        -: 5087:						int m;
    #####: 5088:						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
    #####: 5089:						if (data!=0)
    #####: 5090:							_TIFFfree(data);
    #####: 5091:						if (!m)
    #####: 5092:							return(0);
        -: 5093:					}
        -: 5094:				}
        -: 5095:			}
    #####: 5096:			break;
    #####: 5097:		case TIFF_SETGET_C16_UINT64:
        -: 5098:			{
    #####: 5099:				uint64* data;
    #####: 5100:				assert(fip->field_readcount==TIFF_VARIABLE);
    #####: 5101:				assert(fip->field_passcount==1);
    #####: 5102:				if (dp->tdir_count>0xFFFF)
    #####: 5103:					err=TIFFReadDirEntryErrCount;
        -: 5104:				else
        -: 5105:				{
    #####: 5106:					err=TIFFReadDirEntryLong8Array(tif,dp,&data);
    #####: 5107:					if (err==TIFFReadDirEntryErrOk)
        -: 5108:					{
        -: 5109:						int m;
    #####: 5110:						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
    #####: 5111:						if (data!=0)
    #####: 5112:							_TIFFfree(data);
    #####: 5113:						if (!m)
    #####: 5114:							return(0);
        -: 5115:					}
        -: 5116:				}
        -: 5117:			}
    #####: 5118:			break;
    #####: 5119:		case TIFF_SETGET_C16_FLOAT:
        -: 5120:			{
    #####: 5121:				float* data;
    #####: 5122:				assert(fip->field_readcount==TIFF_VARIABLE);
    #####: 5123:				assert(fip->field_passcount==1);
    #####: 5124:				if (dp->tdir_count>0xFFFF)
    #####: 5125:					err=TIFFReadDirEntryErrCount;
        -: 5126:				else
        -: 5127:				{
    #####: 5128:					err=TIFFReadDirEntryFloatArray(tif,dp,&data);
    #####: 5129:					if (err==TIFFReadDirEntryErrOk)
        -: 5130:					{
        -: 5131:						int m;
    #####: 5132:						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
    #####: 5133:						if (data!=0)
    #####: 5134:							_TIFFfree(data);
    #####: 5135:						if (!m)
    #####: 5136:							return(0);
        -: 5137:					}
        -: 5138:				}
        -: 5139:			}
    #####: 5140:			break;
    #####: 5141:		case TIFF_SETGET_C16_DOUBLE:
        -: 5142:			{
    #####: 5143:				double* data;
    #####: 5144:				assert(fip->field_readcount==TIFF_VARIABLE);
    #####: 5145:				assert(fip->field_passcount==1);
    #####: 5146:				if (dp->tdir_count>0xFFFF)
    #####: 5147:					err=TIFFReadDirEntryErrCount;
        -: 5148:				else
        -: 5149:				{
    #####: 5150:					err=TIFFReadDirEntryDoubleArray(tif,dp,&data);
    #####: 5151:					if (err==TIFFReadDirEntryErrOk)
        -: 5152:					{
        -: 5153:						int m;
    #####: 5154:						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
    #####: 5155:						if (data!=0)
    #####: 5156:							_TIFFfree(data);
    #####: 5157:						if (!m)
    #####: 5158:							return(0);
        -: 5159:					}
        -: 5160:				}
        -: 5161:			}
    #####: 5162:			break;
    #####: 5163:		case TIFF_SETGET_C16_IFD8:
        -: 5164:			{
    #####: 5165:				uint64* data;
    #####: 5166:				assert(fip->field_readcount==TIFF_VARIABLE);
    #####: 5167:				assert(fip->field_passcount==1);
    #####: 5168:				if (dp->tdir_count>0xFFFF)
    #####: 5169:					err=TIFFReadDirEntryErrCount;
        -: 5170:				else
        -: 5171:				{
    #####: 5172:					err=TIFFReadDirEntryIfd8Array(tif,dp,&data);
    #####: 5173:					if (err==TIFFReadDirEntryErrOk)
        -: 5174:					{
        -: 5175:						int m;
    #####: 5176:						m=TIFFSetField(tif,dp->tdir_tag,(uint16)(dp->tdir_count),data);
    #####: 5177:						if (data!=0)
    #####: 5178:							_TIFFfree(data);
    #####: 5179:						if (!m)
    #####: 5180:							return(0);
        -: 5181:					}
        -: 5182:				}
        -: 5183:			}
    #####: 5184:			break;
    #####: 5185:		case TIFF_SETGET_C32_ASCII:
        -: 5186:			{
    #####: 5187:				uint8* data;
    #####: 5188:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5189:				assert(fip->field_passcount==1);
    #####: 5190:				err=TIFFReadDirEntryByteArray(tif,dp,&data);
    #####: 5191:				if (err==TIFFReadDirEntryErrOk)
        -: 5192:				{
        -: 5193:					int m;
    #####: 5194:                    if( dp->tdir_count > 0 && data[dp->tdir_count-1] != '\0' )
        -: 5195:                    {
    #####: 5196:                        TIFFWarningExt(tif->tif_clientdata,module,"ASCII value for tag \"%s\" does not end in null byte. Forcing it to be null",fip->field_name);
    #####: 5197:                        data[dp->tdir_count-1] = '\0';
        -: 5198:                    }
    #####: 5199:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5200:					if (data!=0)
    #####: 5201:						_TIFFfree(data);
    #####: 5202:					if (!m)
    #####: 5203:						return(0);
        -: 5204:				}
        -: 5205:			}
    #####: 5206:			break;
        1: 5207:		case TIFF_SETGET_C32_UINT8:
        -: 5208:			{
        1: 5209:				uint8* data;
       1*: 5210:				assert(fip->field_readcount==TIFF_VARIABLE2);
       1*: 5211:				assert(fip->field_passcount==1);
        1: 5212:				err=TIFFReadDirEntryByteArray(tif,dp,&data);
        1: 5213:				if (err==TIFFReadDirEntryErrOk)
        -: 5214:				{
        -: 5215:					int m;
        1: 5216:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
        1: 5217:					if (data!=0)
        1: 5218:						_TIFFfree(data);
        1: 5219:					if (!m)
    #####: 5220:						return(0);
        -: 5221:				}
        -: 5222:			}
        1: 5223:			break;
    #####: 5224:		case TIFF_SETGET_C32_SINT8:
        -: 5225:			{
    #####: 5226:				int8* data = NULL;
    #####: 5227:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5228:				assert(fip->field_passcount==1);
    #####: 5229:				err=TIFFReadDirEntrySbyteArray(tif,dp,&data);
    #####: 5230:				if (err==TIFFReadDirEntryErrOk)
        -: 5231:				{
        -: 5232:					int m;
    #####: 5233:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5234:					if (data!=0)
    #####: 5235:						_TIFFfree(data);
    #####: 5236:					if (!m)
    #####: 5237:						return(0);
        -: 5238:				}
        -: 5239:			}
    #####: 5240:			break;
    #####: 5241:		case TIFF_SETGET_C32_UINT16:
        -: 5242:			{
    #####: 5243:				uint16* data;
    #####: 5244:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5245:				assert(fip->field_passcount==1);
    #####: 5246:				err=TIFFReadDirEntryShortArray(tif,dp,&data);
    #####: 5247:				if (err==TIFFReadDirEntryErrOk)
        -: 5248:				{
        -: 5249:					int m;
    #####: 5250:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5251:					if (data!=0)
    #####: 5252:						_TIFFfree(data);
    #####: 5253:					if (!m)
    #####: 5254:						return(0);
        -: 5255:				}
        -: 5256:			}
    #####: 5257:			break;
    #####: 5258:		case TIFF_SETGET_C32_SINT16:
        -: 5259:			{
    #####: 5260:				int16* data = NULL;
    #####: 5261:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5262:				assert(fip->field_passcount==1);
    #####: 5263:				err=TIFFReadDirEntrySshortArray(tif,dp,&data);
    #####: 5264:				if (err==TIFFReadDirEntryErrOk)
        -: 5265:				{
        -: 5266:					int m;
    #####: 5267:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5268:					if (data!=0)
    #####: 5269:						_TIFFfree(data);
    #####: 5270:					if (!m)
    #####: 5271:						return(0);
        -: 5272:				}
        -: 5273:			}
    #####: 5274:			break;
    #####: 5275:		case TIFF_SETGET_C32_UINT32:
        -: 5276:			{
    #####: 5277:				uint32* data;
    #####: 5278:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5279:				assert(fip->field_passcount==1);
    #####: 5280:				err=TIFFReadDirEntryLongArray(tif,dp,&data);
    #####: 5281:				if (err==TIFFReadDirEntryErrOk)
        -: 5282:				{
        -: 5283:					int m;
    #####: 5284:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5285:					if (data!=0)
    #####: 5286:						_TIFFfree(data);
    #####: 5287:					if (!m)
    #####: 5288:						return(0);
        -: 5289:				}
        -: 5290:			}
    #####: 5291:			break;
    #####: 5292:		case TIFF_SETGET_C32_SINT32:
        -: 5293:			{
    #####: 5294:				int32* data = NULL;
    #####: 5295:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5296:				assert(fip->field_passcount==1);
    #####: 5297:				err=TIFFReadDirEntrySlongArray(tif,dp,&data);
    #####: 5298:				if (err==TIFFReadDirEntryErrOk)
        -: 5299:				{
        -: 5300:					int m;
    #####: 5301:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5302:					if (data!=0)
    #####: 5303:						_TIFFfree(data);
    #####: 5304:					if (!m)
    #####: 5305:						return(0);
        -: 5306:				}
        -: 5307:			}
    #####: 5308:			break;
    #####: 5309:		case TIFF_SETGET_C32_UINT64:
        -: 5310:			{
    #####: 5311:				uint64* data;
    #####: 5312:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5313:				assert(fip->field_passcount==1);
    #####: 5314:				err=TIFFReadDirEntryLong8Array(tif,dp,&data);
    #####: 5315:				if (err==TIFFReadDirEntryErrOk)
        -: 5316:				{
        -: 5317:					int m;
    #####: 5318:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5319:					if (data!=0)
    #####: 5320:						_TIFFfree(data);
    #####: 5321:					if (!m)
    #####: 5322:						return(0);
        -: 5323:				}
        -: 5324:			}
    #####: 5325:			break;
    #####: 5326:		case TIFF_SETGET_C32_SINT64:
        -: 5327:			{
    #####: 5328:				int64* data = NULL;
    #####: 5329:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5330:				assert(fip->field_passcount==1);
    #####: 5331:				err=TIFFReadDirEntrySlong8Array(tif,dp,&data);
    #####: 5332:				if (err==TIFFReadDirEntryErrOk)
        -: 5333:				{
        -: 5334:					int m;
    #####: 5335:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5336:					if (data!=0)
    #####: 5337:						_TIFFfree(data);
    #####: 5338:					if (!m)
    #####: 5339:						return(0);
        -: 5340:				}
        -: 5341:			}
    #####: 5342:			break;
    #####: 5343:		case TIFF_SETGET_C32_FLOAT:
        -: 5344:			{
    #####: 5345:				float* data;
    #####: 5346:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5347:				assert(fip->field_passcount==1);
    #####: 5348:				err=TIFFReadDirEntryFloatArray(tif,dp,&data);
    #####: 5349:				if (err==TIFFReadDirEntryErrOk)
        -: 5350:				{
        -: 5351:					int m;
    #####: 5352:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5353:					if (data!=0)
    #####: 5354:						_TIFFfree(data);
    #####: 5355:					if (!m)
    #####: 5356:						return(0);
        -: 5357:				}
        -: 5358:			}
    #####: 5359:			break;
    #####: 5360:		case TIFF_SETGET_C32_DOUBLE:
        -: 5361:			{
    #####: 5362:				double* data;
    #####: 5363:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5364:				assert(fip->field_passcount==1);
    #####: 5365:				err=TIFFReadDirEntryDoubleArray(tif,dp,&data);
    #####: 5366:				if (err==TIFFReadDirEntryErrOk)
        -: 5367:				{
        -: 5368:					int m;
    #####: 5369:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5370:					if (data!=0)
    #####: 5371:						_TIFFfree(data);
    #####: 5372:					if (!m)
    #####: 5373:						return(0);
        -: 5374:				}
        -: 5375:			}
    #####: 5376:			break;
    #####: 5377:		case TIFF_SETGET_C32_IFD8:
        -: 5378:			{
    #####: 5379:				uint64* data;
    #####: 5380:				assert(fip->field_readcount==TIFF_VARIABLE2);
    #####: 5381:				assert(fip->field_passcount==1);
    #####: 5382:				err=TIFFReadDirEntryIfd8Array(tif,dp,&data);
    #####: 5383:				if (err==TIFFReadDirEntryErrOk)
        -: 5384:				{
        -: 5385:					int m;
    #####: 5386:					m=TIFFSetField(tif,dp->tdir_tag,(uint32)(dp->tdir_count),data);
    #####: 5387:					if (data!=0)
    #####: 5388:						_TIFFfree(data);
    #####: 5389:					if (!m)
    #####: 5390:						return(0);
        -: 5391:				}
        -: 5392:			}
    #####: 5393:			break;
    #####: 5394:		default:
    #####: 5395:			assert(0);    /* we should never get here */
        -: 5396:			break;
        -: 5397:	}
       13: 5398:	if (err!=TIFFReadDirEntryErrOk)
        -: 5399:	{
        1: 5400:		TIFFReadDirEntryOutputErr(tif,err,module,fip->field_name,recover);
        1: 5401:		return(0);
        -: 5402:	}
       12: 5403:	return(1);
        -: 5404:}
        -: 5405:
        -: 5406:/*
        -: 5407: * Fetch a set of offsets or lengths.
        -: 5408: * While this routine says "strips", in fact it's also used for tiles.
        -: 5409: */
        -: 5410:static int
        2: 5411:TIFFFetchStripThing(TIFF* tif, TIFFDirEntry* dir, uint32 nstrips, uint64** lpp)
        -: 5412:{
        -: 5413:	static const char module[] = "TIFFFetchStripThing";
        -: 5414:	enum TIFFReadDirEntryErr err;
        2: 5415:	uint64* data;
        2: 5416:	err=TIFFReadDirEntryLong8Array(tif,dir,&data);
        2: 5417:	if (err!=TIFFReadDirEntryErrOk)
        -: 5418:	{
    #####: 5419:		const TIFFField* fip = TIFFFieldWithTag(tif,dir->tdir_tag); 
    #####: 5420:		TIFFReadDirEntryOutputErr(tif,err,module,fip ? fip->field_name : "unknown tagname",0);
    #####: 5421:		return(0);
        -: 5422:	}
        2: 5423:	if (dir->tdir_count!=(uint64)nstrips)
        -: 5424:	{
        -: 5425:		uint64* resizeddata;
        2: 5426:		resizeddata=(uint64*)_TIFFCheckMalloc(tif,nstrips,sizeof(uint64),"for strip array");
        2: 5427:		if (resizeddata==0) {
    #####: 5428:			_TIFFfree(data);
    #####: 5429:			return(0);
        -: 5430:		}
        2: 5431:		if (dir->tdir_count<(uint64)nstrips)
        -: 5432:		{
        2: 5433:			_TIFFmemcpy(resizeddata,data,(uint32)dir->tdir_count*sizeof(uint64));
        2: 5434:			_TIFFmemset(resizeddata+(uint32)dir->tdir_count,0,(nstrips-(uint32)dir->tdir_count)*sizeof(uint64));
        -: 5435:		}
        -: 5436:		else
    #####: 5437:			_TIFFmemcpy(resizeddata,data,nstrips*sizeof(uint64));
        2: 5438:		_TIFFfree(data);
        2: 5439:		data=resizeddata;
        -: 5440:	}
        2: 5441:	*lpp=data;
        2: 5442:	return(1);
        -: 5443:}
        -: 5444:
        -: 5445:/*
        -: 5446: * Fetch and set the SubjectDistance EXIF tag.
        -: 5447: */
        -: 5448:static int
    #####: 5449:TIFFFetchSubjectDistance(TIFF* tif, TIFFDirEntry* dir)
        -: 5450:{
        -: 5451:	static const char module[] = "TIFFFetchSubjectDistance";
        -: 5452:	enum TIFFReadDirEntryErr err;
    #####: 5453:	UInt64Aligned_t m;
    #####: 5454:    m.l=0;
        -: 5455:	assert(sizeof(double)==8);
        -: 5456:	assert(sizeof(uint64)==8);
        -: 5457:	assert(sizeof(uint32)==4);
    #####: 5458:	if (dir->tdir_count!=1)
    #####: 5459:		err=TIFFReadDirEntryErrCount;
    #####: 5460:	else if (dir->tdir_type!=TIFF_RATIONAL)
    #####: 5461:		err=TIFFReadDirEntryErrType;
        -: 5462:	else
        -: 5463:	{
    #####: 5464:		if (!(tif->tif_flags&TIFF_BIGTIFF))
        -: 5465:		{
    #####: 5466:			uint32 offset;
    #####: 5467:			offset=*(uint32*)(&dir->tdir_offset);
    #####: 5468:			if (tif->tif_flags&TIFF_SWAB)
    #####: 5469:				TIFFSwabLong(&offset);
    #####: 5470:			err=TIFFReadDirEntryData(tif,offset,8,m.i);
        -: 5471:		}
        -: 5472:		else
        -: 5473:		{
    #####: 5474:			m.l=dir->tdir_offset.toff_long8;
    #####: 5475:			err=TIFFReadDirEntryErrOk;
        -: 5476:		}
        -: 5477:	}
    #####: 5478:	if (err==TIFFReadDirEntryErrOk)
        -: 5479:	{
        -: 5480:		double n;
    #####: 5481:		if (tif->tif_flags&TIFF_SWAB)
    #####: 5482:			TIFFSwabArrayOfLong(m.i,2);
    #####: 5483:		if (m.i[0]==0)
    #####: 5484:			n=0.0;
    #####: 5485:		else if (m.i[0]==0xFFFFFFFF)
        -: 5486:			/*
        -: 5487:			 * XXX: Numerator 0xFFFFFFFF means that we have infinite
        -: 5488:			 * distance. Indicate that with a negative floating point
        -: 5489:			 * SubjectDistance value.
        -: 5490:			 */
    #####: 5491:			n=-1.0;
        -: 5492:		else
    #####: 5493:			n=(double)m.i[0]/(double)m.i[1];
    #####: 5494:		return(TIFFSetField(tif,dir->tdir_tag,n));
        -: 5495:	}
        -: 5496:	else
        -: 5497:	{
    #####: 5498:		TIFFReadDirEntryOutputErr(tif,err,module,"SubjectDistance",TRUE);
    #####: 5499:		return(0);
        -: 5500:	}
        -: 5501:}
        -: 5502:
        -: 5503:/*
        -: 5504: * Replace a single strip (tile) of uncompressed data by multiple strips
        -: 5505: * (tiles), each approximately STRIP_SIZE_DEFAULT bytes. This is useful for
        -: 5506: * dealing with large images or for dealing with machines with a limited
        -: 5507: * amount memory.
        -: 5508: */
        -: 5509:static void
    #####: 5510:ChopUpSingleUncompressedStrip(TIFF* tif)
        -: 5511:{
    #####: 5512:	register TIFFDirectory *td = &tif->tif_dir;
        -: 5513:	uint64 bytecount;
        -: 5514:	uint64 offset;
        -: 5515:	uint32 rowblock;
        -: 5516:	uint64 rowblockbytes;
        -: 5517:	uint64 stripbytes;
        -: 5518:	uint32 strip;
        -: 5519:	uint32 nstrips;
        -: 5520:	uint32 rowsperstrip;
        -: 5521:	uint64* newcounts;
        -: 5522:	uint64* newoffsets;
        -: 5523:
    #####: 5524:	bytecount = td->td_stripbytecount[0];
    #####: 5525:	offset = td->td_stripoffset[0];
    #####: 5526:	assert(td->td_planarconfig == PLANARCONFIG_CONTIG);
    #####: 5527:	if ((td->td_photometric == PHOTOMETRIC_YCBCR)&&
    #####: 5528:	    (!isUpSampled(tif)))
    #####: 5529:		rowblock = td->td_ycbcrsubsampling[1];
        -: 5530:	else
    #####: 5531:		rowblock = 1;
    #####: 5532:	rowblockbytes = TIFFVTileSize64(tif, rowblock);
        -: 5533:	/*
        -: 5534:	 * Make the rows hold at least one scanline, but fill specified amount
        -: 5535:	 * of data if possible.
        -: 5536:	 */
    #####: 5537:	if (rowblockbytes > STRIP_SIZE_DEFAULT) {
    #####: 5538:		stripbytes = rowblockbytes;
    #####: 5539:		rowsperstrip = rowblock;
    #####: 5540:	} else if (rowblockbytes > 0 ) {
        -: 5541:		uint32 rowblocksperstrip;
    #####: 5542:		rowblocksperstrip = (uint32) (STRIP_SIZE_DEFAULT / rowblockbytes);
    #####: 5543:		rowsperstrip = rowblocksperstrip * rowblock;
    #####: 5544:		stripbytes = rowblocksperstrip * rowblockbytes;
        -: 5545:	}
        -: 5546:	else
    #####: 5547:	    return;
        -: 5548:
        -: 5549:	/*
        -: 5550:	 * never increase the number of rows per strip
        -: 5551:	 */
    #####: 5552:	if (rowsperstrip >= td->td_rowsperstrip)
    #####: 5553:		return;
    #####: 5554:        nstrips = TIFFhowmany_32(td->td_imagelength, rowsperstrip);
    #####: 5555:        if( nstrips == 0 )
    #####: 5556:            return;
        -: 5557:
    #####: 5558:	newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
        -: 5559:				"for chopped \"StripByteCounts\" array");
    #####: 5560:	newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
        -: 5561:				"for chopped \"StripOffsets\" array");
    #####: 5562:	if (newcounts == NULL || newoffsets == NULL) {
        -: 5563:		/*
        -: 5564:		 * Unable to allocate new strip information, give up and use
        -: 5565:		 * the original one strip information.
        -: 5566:		 */
    #####: 5567:		if (newcounts != NULL)
    #####: 5568:			_TIFFfree(newcounts);
    #####: 5569:		if (newoffsets != NULL)
    #####: 5570:			_TIFFfree(newoffsets);
    #####: 5571:		return;
        -: 5572:	}
        -: 5573:	/*
        -: 5574:	 * Fill the strip information arrays with new bytecounts and offsets
        -: 5575:	 * that reflect the broken-up format.
        -: 5576:	 */
    #####: 5577:	for (strip = 0; strip < nstrips; strip++) {
    #####: 5578:		if (stripbytes > bytecount)
    #####: 5579:			stripbytes = bytecount;
    #####: 5580:		newcounts[strip] = stripbytes;
    #####: 5581:		newoffsets[strip] = stripbytes ? offset : 0;
    #####: 5582:		offset += stripbytes;
    #####: 5583:		bytecount -= stripbytes;
        -: 5584:	}
        -: 5585:	/*
        -: 5586:	 * Replace old single strip info with multi-strip info.
        -: 5587:	 */
    #####: 5588:	td->td_stripsperimage = td->td_nstrips = nstrips;
    #####: 5589:	TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
        -: 5590:
    #####: 5591:	_TIFFfree(td->td_stripbytecount);
    #####: 5592:	_TIFFfree(td->td_stripoffset);
    #####: 5593:	td->td_stripbytecount = newcounts;
    #####: 5594:	td->td_stripoffset = newoffsets;
    #####: 5595:	td->td_stripbytecountsorted = 1;
        -: 5596:}
        -: 5597:
        4: 5598:int _TIFFFillStriles( TIFF *tif )
        -: 5599:{
        4: 5600:    return _TIFFFillStrilesInternal( tif, 1 );
        -: 5601:}
        -: 5602:
        4: 5603:static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount )
        -: 5604:{
        -: 5605:#if defined(DEFER_STRILE_LOAD)
        -: 5606:        register TIFFDirectory *td = &tif->tif_dir;
        -: 5607:        int return_value = 1;
        -: 5608:
        -: 5609:        if( td->td_stripoffset != NULL )
        -: 5610:                return 1;
        -: 5611:
        -: 5612:        if( td->td_stripoffset_entry.tdir_count == 0 )
        -: 5613:                return 0;
        -: 5614:
        -: 5615:        if (!TIFFFetchStripThing(tif,&(td->td_stripoffset_entry),
        -: 5616:                                 td->td_nstrips,&td->td_stripoffset))
        -: 5617:        {
        -: 5618:                return_value = 0;
        -: 5619:        }
        -: 5620:
        -: 5621:        if (loadStripByteCount &&
        -: 5622:            !TIFFFetchStripThing(tif,&(td->td_stripbytecount_entry),
        -: 5623:                                 td->td_nstrips,&td->td_stripbytecount))
        -: 5624:        {
        -: 5625:                return_value = 0;
        -: 5626:        }
        -: 5627:
        -: 5628:        _TIFFmemset( &(td->td_stripoffset_entry), 0, sizeof(TIFFDirEntry));
        -: 5629:        _TIFFmemset( &(td->td_stripbytecount_entry), 0, sizeof(TIFFDirEntry));
        -: 5630:
        -: 5631:	if (tif->tif_dir.td_nstrips > 1 && return_value == 1 ) {
        -: 5632:		uint32 strip;
        -: 5633:
        -: 5634:		tif->tif_dir.td_stripbytecountsorted = 1;
        -: 5635:		for (strip = 1; strip < tif->tif_dir.td_nstrips; strip++) {
        -: 5636:			if (tif->tif_dir.td_stripoffset[strip - 1] >
        -: 5637:			    tif->tif_dir.td_stripoffset[strip]) {
        -: 5638:				tif->tif_dir.td_stripbytecountsorted = 0;
        -: 5639:				break;
        -: 5640:			}
        -: 5641:		}
        -: 5642:	}
        -: 5643:
        -: 5644:        return return_value;
        -: 5645:#else /* !defined(DEFER_STRILE_LOAD) */
        -: 5646:        (void) tif;
        -: 5647:        (void) loadStripByteCount;
        4: 5648:        return 1;
        -: 5649:#endif 
        -: 5650:}
        -: 5651:
        -: 5652:
        -: 5653:/* vim: set ts=8 sts=8 sw=8 noet: */
        -: 5654:/*
        -: 5655: * Local Variables:
        -: 5656: * mode: c
        -: 5657: * c-basic-offset: 8
        -: 5658: * fill-column: 78
        -: 5659: * End:
        -: 5660: */
