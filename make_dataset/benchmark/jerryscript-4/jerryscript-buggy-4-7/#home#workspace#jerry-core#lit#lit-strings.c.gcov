        -:    0:Source:/home/workspace/jerry-core/lit/lit-strings.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "lit-strings.h"
        -:   17:
        -:   18:#include "jrt-libc-includes.h"
        -:   19:
        -:   20:/**
        -:   21: * Validate utf-8 string
        -:   22: *
        -:   23: * NOTE:
        -:   24: *   Isolated surrogates are allowed.
        -:   25: *
        -:   26: * @return true if utf-8 string is well-formed
        -:   27: *         false otherwise
        -:   28: */
        -:   29:bool
        1:   30:lit_is_valid_utf8_string (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:   31:                          lit_utf8_size_t buf_size, /**< string size */
        -:   32:                          bool is_strict) /**< true if surrogate pairs are not allowed */
        -:   33:{
        1:   34:  lit_utf8_size_t idx = 0;
        -:   35:
        1:   36:  bool is_prev_code_point_high_surrogate = false;
      142:   37:  while (idx < buf_size)
        -:   38:  {
      140:   39:    lit_utf8_byte_t c = utf8_buf_p[idx++];
      140:   40:    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:   41:    {
      140:   42:      is_prev_code_point_high_surrogate = false;
      140:   43:      continue;
        -:   44:    }
        -:   45:
    #####:   46:    lit_code_point_t code_point = 0;
    #####:   47:    lit_code_point_t min_code_point = 0;
        -:   48:    lit_utf8_size_t extra_bytes_count;
    #####:   49:    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:   50:    {
    #####:   51:      extra_bytes_count = 1;
    #####:   52:      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;
    #####:   53:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:   54:    }
    #####:   55:    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:   56:    {
    #####:   57:      extra_bytes_count = 2;
    #####:   58:      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;
    #####:   59:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:   60:    }
    #####:   61:    else if ((c & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)
        -:   62:    {
    #####:   63:      extra_bytes_count = 3;
    #####:   64:      min_code_point = LIT_UTF8_4_BYTE_CODE_POINT_MIN;
    #####:   65:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_3_BITS_MASK));
        -:   66:    }
        -:   67:    else
        -:   68:    {
        -:   69:      /* utf-8 string could not contain 5- and 6-byte sequences. */
    #####:   70:      return false;
        -:   71:    }
        -:   72:
    #####:   73:    if (idx + extra_bytes_count > buf_size)
        -:   74:    {
        -:   75:      /* utf-8 string breaks in the middle */
    #####:   76:      return false;
        -:   77:    }
        -:   78:
    #####:   79:    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)
        -:   80:    {
    #####:   81:      c = utf8_buf_p[idx + offset];
    #####:   82:      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:   83:      {
        -:   84:        /* invalid continuation byte */
    #####:   85:        return false;
        -:   86:      }
    #####:   87:      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:   88:      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);
        -:   89:    }
        -:   90:
    #####:   91:    if (code_point < min_code_point
    #####:   92:        || code_point > LIT_UNICODE_CODE_POINT_MAX)
        -:   93:    {
        -:   94:      /* utf-8 string doesn't encode valid unicode code point */
    #####:   95:      return false;
        -:   96:    }
        -:   97:
    #####:   98:    if (is_strict)
        -:   99:    {
    #####:  100:      is_prev_code_point_high_surrogate = false;
        -:  101:
    #####:  102:      if (code_point >= LIT_UTF16_HIGH_SURROGATE_MIN
    #####:  103:          && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX)
        -:  104:      {
    #####:  105:        is_prev_code_point_high_surrogate = true;
        -:  106:      }
    #####:  107:      else if (code_point >= LIT_UTF16_LOW_SURROGATE_MIN
    #####:  108:               && code_point <= LIT_UTF16_LOW_SURROGATE_MAX
    #####:  109:               && is_prev_code_point_high_surrogate)
        -:  110:      {
        -:  111:        /* sequence of high and low surrogate is not allowed */
    #####:  112:        return false;
        -:  113:      }
        -:  114:    }
        -:  115:
    #####:  116:    idx += extra_bytes_count;
        -:  117:  }
        -:  118:
        1:  119:  return true;
        -:  120:} /* lit_is_valid_utf8_string */
        -:  121:
        -:  122:/**
        -:  123: * Validate cesu-8 string
        -:  124: *
        -:  125: * @return true if cesu-8 string is well-formed
        -:  126: *         false otherwise
        -:  127: */
        -:  128:bool
       16:  129:lit_is_valid_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  130:                           lit_utf8_size_t buf_size) /**< string size */
        -:  131:{
       16:  132:  lit_utf8_size_t idx = 0;
        -:  133:
      114:  134:  while (idx < buf_size)
        -:  135:  {
       82:  136:    lit_utf8_byte_t c = cesu8_buf_p[idx++];
       82:  137:    if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  138:    {
       82:  139:      continue;
        -:  140:    }
        -:  141:
    #####:  142:    lit_code_point_t code_point = 0;
    #####:  143:    lit_code_point_t min_code_point = 0;
        -:  144:    lit_utf8_size_t extra_bytes_count;
    #####:  145:    if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  146:    {
    #####:  147:      extra_bytes_count = 1;
    #####:  148:      min_code_point = LIT_UTF8_2_BYTE_CODE_POINT_MIN;
    #####:  149:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  150:    }
    #####:  151:    else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  152:    {
    #####:  153:      extra_bytes_count = 2;
    #####:  154:      min_code_point = LIT_UTF8_3_BYTE_CODE_POINT_MIN;
    #####:  155:      code_point = ((uint32_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  156:    }
        -:  157:    else
        -:  158:    {
    #####:  159:      return false;
        -:  160:    }
        -:  161:
    #####:  162:    if (idx + extra_bytes_count > buf_size)
        -:  163:    {
        -:  164:      /* cesu-8 string breaks in the middle */
    #####:  165:      return false;
        -:  166:    }
        -:  167:
    #####:  168:    for (lit_utf8_size_t offset = 0; offset < extra_bytes_count; ++offset)
        -:  169:    {
    #####:  170:      c = cesu8_buf_p[idx + offset];
    #####:  171:      if ((c & LIT_UTF8_EXTRA_BYTE_MASK) != LIT_UTF8_EXTRA_BYTE_MARKER)
        -:  172:      {
        -:  173:        /* invalid continuation byte */
    #####:  174:        return false;
        -:  175:      }
    #####:  176:      code_point <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  177:      code_point |= (c & LIT_UTF8_LAST_6_BITS_MASK);
        -:  178:    }
        -:  179:
    #####:  180:    if (code_point < min_code_point)
        -:  181:    {
        -:  182:      /* cesu-8 string doesn't encode valid unicode code point */
    #####:  183:      return false;
        -:  184:    }
        -:  185:
    #####:  186:    idx += extra_bytes_count;
        -:  187:  }
        -:  188:
       16:  189:  return true;
        -:  190:} /* lit_is_valid_cesu8_string */
        -:  191:
        -:  192:/**
        -:  193: * Check if the code point is UTF-16 low surrogate
        -:  194: *
        -:  195: * @return true / false
        -:  196: */
        -:  197:bool
    #####:  198:lit_is_code_point_utf16_low_surrogate (lit_code_point_t code_point) /**< code point */
        -:  199:{
    #####:  200:  return LIT_UTF16_LOW_SURROGATE_MIN <= code_point && code_point <= LIT_UTF16_LOW_SURROGATE_MAX;
        -:  201:} /* lit_is_code_point_utf16_low_surrogate */
        -:  202:
        -:  203:/**
        -:  204: * Check if the code point is UTF-16 high surrogate
        -:  205: *
        -:  206: * @return true / false
        -:  207: */
        -:  208:bool
    #####:  209:lit_is_code_point_utf16_high_surrogate (lit_code_point_t code_point) /**< code point */
        -:  210:{
    #####:  211:  return LIT_UTF16_HIGH_SURROGATE_MIN <= code_point && code_point <= LIT_UTF16_HIGH_SURROGATE_MAX;
        -:  212:} /* lit_is_code_point_utf16_high_surrogate */
        -:  213:
        -:  214:/**
        -:  215: * Represents code point (>0xFFFF) as surrogate pair and returns its lower part
        -:  216: *
        -:  217: * @return lower code_unit of the surrogate pair
        -:  218: */
        -:  219:static ecma_char_t
    #####:  220:convert_code_point_to_low_surrogate (lit_code_point_t code_point) /**< code point, should be > 0xFFFF */
        -:  221:{
    #####:  222:  JERRY_ASSERT (code_point > LIT_UTF16_CODE_UNIT_MAX);
        -:  223:
        -:  224:  ecma_char_t code_unit_bits;
    #####:  225:  code_unit_bits = (ecma_char_t) (code_point & LIT_UTF16_LAST_10_BITS_MASK);
        -:  226:
    #####:  227:  return (ecma_char_t) (LIT_UTF16_LOW_SURROGATE_MARKER | code_unit_bits);
        -:  228:} /* convert_code_point_to_low_surrogate */
        -:  229:
        -:  230:/**
        -:  231: * Represents code point (>0xFFFF) as surrogate pair and returns its higher part
        -:  232: *
        -:  233: * @return higher code_unit of the surrogate pair
        -:  234: */
        -:  235:static ecma_char_t
    #####:  236:convert_code_point_to_high_surrogate (lit_code_point_t code_point) /**< code point, should be > 0xFFFF */
        -:  237:{
    #####:  238:  JERRY_ASSERT (code_point > LIT_UTF16_CODE_UNIT_MAX);
    #####:  239:  JERRY_ASSERT (code_point <= LIT_UNICODE_CODE_POINT_MAX);
        -:  240:
        -:  241:  ecma_char_t code_unit_bits;
    #####:  242:  code_unit_bits = (ecma_char_t) ((code_point - LIT_UTF16_FIRST_SURROGATE_CODE_POINT) >> LIT_UTF16_BITS_IN_SURROGATE);
        -:  243:
    #####:  244:  return (LIT_UTF16_HIGH_SURROGATE_MARKER | code_unit_bits);
        -:  245:} /* convert_code_point_to_high_surrogate */
        -:  246:
        -:  247:/**
        -:  248: * UTF16 Encoding method for a code point
        -:  249: *
        -:  250: * See also:
        -:  251: *          ECMA-262 v6, 10.1.1
        -:  252: *
        -:  253: * @return uint8_t, the number of returning code points
        -:  254: */
        -:  255:uint8_t
    #####:  256:lit_utf16_encode_code_point (lit_code_point_t cp, /**< the code point we encode */
        -:  257:                             ecma_char_t *cu_p) /**< result of the encoding */
        -:  258:{
    #####:  259:  if (cp <= LIT_UTF16_CODE_UNIT_MAX)
        -:  260:  {
    #####:  261:    cu_p[0] = (ecma_char_t) cp;
    #####:  262:    return 1;
        -:  263:  }
        -:  264:
    #####:  265:  cu_p[0] = convert_code_point_to_high_surrogate (cp);
    #####:  266:  cu_p[1] = convert_code_point_to_low_surrogate (cp);
    #####:  267:  return 2;
        -:  268:} /* lit_utf16_encode_code_point */
        -:  269:
        -:  270:/**
        -:  271: * Calculate size of a zero-terminated utf-8 string
        -:  272: *
        -:  273: * NOTE:
        -:  274: *   - string cannot be NULL
        -:  275: *   - string should not contain zero characters in the middle
        -:  276: *
        -:  277: * @return size of a string
        -:  278: */
        -:  279:lit_utf8_size_t
        5:  280:lit_zt_utf8_string_size (const lit_utf8_byte_t *utf8_str_p) /**< zero-terminated utf-8 string */
        -:  281:{
        5:  282:  JERRY_ASSERT (utf8_str_p != NULL);
        5:  283:  return (lit_utf8_size_t) strlen ((const char *) utf8_str_p);
        -:  284:} /* lit_zt_utf8_string_size */
        -:  285:
        -:  286:/**
        -:  287: * Calculate length of a cesu-8 encoded string
        -:  288: *
        -:  289: * @return UTF-16 code units count
        -:  290: */
        -:  291:lit_utf8_size_t
       14:  292:lit_utf8_string_length (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:  293:                        lit_utf8_size_t utf8_buf_size) /**< string size */
        -:  294:{
       14:  295:  lit_utf8_size_t length = 0;
       14:  296:  lit_utf8_size_t size = 0;
        -:  297:
      112:  298:  while (size < utf8_buf_size)
        -:  299:  {
      168:  300:    size += lit_get_unicode_char_size_by_utf8_first_byte (*(utf8_buf_p + size));
       84:  301:    length++;
        -:  302:  }
        -:  303:
       14:  304:  JERRY_ASSERT (size == utf8_buf_size);
        -:  305:
       14:  306:  return length;
        -:  307:} /* lit_utf8_string_length */
        -:  308:
        -:  309:/**
        -:  310: * Calculate the required size of an utf-8 encoded string from cesu-8 encoded string
        -:  311: *
        -:  312: * @return size of an utf-8 encoded string
        -:  313: */
        -:  314:lit_utf8_size_t
    #####:  315:lit_get_utf8_size_of_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  316:                                   lit_utf8_size_t cesu8_buf_size) /**< string size */
        -:  317:{
    #####:  318:  lit_utf8_size_t offset = 0;
    #####:  319:  lit_utf8_size_t utf8_buf_size = cesu8_buf_size;
    #####:  320:  ecma_char_t prev_ch = 0;
        -:  321:
    #####:  322:  while (offset < cesu8_buf_size)
        -:  323:  {
    #####:  324:    ecma_char_t ch;
    #####:  325:    offset += lit_read_code_unit_from_cesu8 (cesu8_buf_p + offset, &ch);
        -:  326:
    #####:  327:    if (lit_is_code_point_utf16_low_surrogate (ch) && lit_is_code_point_utf16_high_surrogate (prev_ch))
        -:  328:    {
    #####:  329:      utf8_buf_size -= 2;
        -:  330:    }
        -:  331:
    #####:  332:    prev_ch = ch;
        -:  333:  }
        -:  334:
    #####:  335:  JERRY_ASSERT (offset == cesu8_buf_size);
        -:  336:
    #####:  337:  return utf8_buf_size;
        -:  338:} /* lit_get_utf8_size_of_cesu8_string */
        -:  339:
        -:  340:/**
        -:  341: * Calculate length of an utf-8 encoded string from cesu-8 encoded string
        -:  342: *
        -:  343: * @return length of an utf-8 encoded string
        -:  344: */
        -:  345:lit_utf8_size_t
    #####:  346:lit_get_utf8_length_of_cesu8_string (const lit_utf8_byte_t *cesu8_buf_p, /**< cesu-8 string */
        -:  347:                                     lit_utf8_size_t cesu8_buf_size) /**< string size */
        -:  348:{
    #####:  349:  lit_utf8_size_t offset = 0;
    #####:  350:  lit_utf8_size_t utf8_length = 0;
    #####:  351:  ecma_char_t prev_ch = 0;
        -:  352:
    #####:  353:  while (offset < cesu8_buf_size)
        -:  354:  {
    #####:  355:    ecma_char_t ch;
    #####:  356:    offset += lit_read_code_unit_from_cesu8 (cesu8_buf_p + offset, &ch);
        -:  357:
    #####:  358:    if (!lit_is_code_point_utf16_low_surrogate (ch) || !lit_is_code_point_utf16_high_surrogate (prev_ch))
        -:  359:    {
    #####:  360:      utf8_length++;
        -:  361:    }
        -:  362:
    #####:  363:    prev_ch = ch;
        -:  364:  }
        -:  365:
    #####:  366:  JERRY_ASSERT (offset == cesu8_buf_size);
        -:  367:
    #####:  368:  return utf8_length;
        -:  369:} /* lit_get_utf8_length_of_cesu8_string */
        -:  370:
        -:  371:/**
        -:  372: * Decodes a unicode code point from non-empty utf-8-encoded buffer
        -:  373: *
        -:  374: * @return number of bytes occupied by code point in the string
        -:  375: */
        -:  376:lit_utf8_size_t
    #####:  377:lit_read_code_point_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  378:                               lit_utf8_size_t buf_size, /**< size of the buffer in bytes */
        -:  379:                               lit_code_point_t *code_point) /**< [out] code point */
        -:  380:{
    #####:  381:  JERRY_ASSERT (buf_p && buf_size);
        -:  382:
    #####:  383:  lit_utf8_byte_t c = buf_p[0];
    #####:  384:  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  385:  {
    #####:  386:    *code_point = (lit_code_point_t) (c & LIT_UTF8_LAST_7_BITS_MASK);
    #####:  387:    return 1;
        -:  388:  }
        -:  389:
    #####:  390:  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;
    #####:  391:  lit_utf8_size_t bytes_count = 0;
    #####:  392:  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  393:  {
    #####:  394:    bytes_count = 2;
    #####:  395:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  396:  }
    #####:  397:  else if ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  398:  {
    #####:  399:    bytes_count = 3;
    #####:  400:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  401:  }
        -:  402:  else
        -:  403:  {
    #####:  404:    JERRY_ASSERT ((c & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER);
    #####:  405:    bytes_count = 4;
    #####:  406:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_3_BITS_MASK));
        -:  407:  }
        -:  408:
    #####:  409:  JERRY_ASSERT (buf_size >= bytes_count);
        -:  410:
    #####:  411:  for (uint32_t i = 1; i < bytes_count; ++i)
        -:  412:  {
    #####:  413:    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  414:    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);
        -:  415:  }
        -:  416:
    #####:  417:  *code_point = ret;
    #####:  418:  return bytes_count;
        -:  419:} /* lit_read_code_point_from_utf8 */
        -:  420:
        -:  421:/**
        -:  422: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  423: *
        -:  424: * @return number of bytes occupied by code point in the string
        -:  425: */
        -:  426:lit_utf8_size_t
       10:  427:lit_read_code_unit_from_cesu8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  428:                               ecma_char_t *code_unit) /**< [out] code unit */
        -:  429:{
       10:  430:  JERRY_ASSERT (buf_p);
        -:  431:
       10:  432:  lit_utf8_byte_t c = buf_p[0];
       10:  433:  if ((c & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  434:  {
       10:  435:    *code_unit = (ecma_char_t) (c & LIT_UTF8_LAST_7_BITS_MASK);
       10:  436:    return 1;
        -:  437:  }
        -:  438:
    #####:  439:  lit_code_point_t ret = LIT_UNICODE_CODE_POINT_NULL;
        -:  440:  lit_utf8_size_t bytes_count;
        -:  441:
    #####:  442:  if ((c & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  443:  {
    #####:  444:    bytes_count = 2;
    #####:  445:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_5_BITS_MASK));
        -:  446:  }
        -:  447:  else
        -:  448:  {
    #####:  449:    JERRY_ASSERT ((c & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);
    #####:  450:    bytes_count = 3;
    #####:  451:    ret = ((lit_code_point_t) (c & LIT_UTF8_LAST_4_BITS_MASK));
        -:  452:  }
        -:  453:
    #####:  454:  for (uint32_t i = 1; i < bytes_count; ++i)
        -:  455:  {
    #####:  456:    ret <<= LIT_UTF8_BITS_IN_EXTRA_BYTES;
    #####:  457:    ret |= (buf_p[i] & LIT_UTF8_LAST_6_BITS_MASK);
        -:  458:  }
        -:  459:
    #####:  460:  JERRY_ASSERT (ret <= LIT_UTF16_CODE_UNIT_MAX);
    #####:  461:  *code_unit = (ecma_char_t) ret;
    #####:  462:  return bytes_count;
        -:  463:} /* lit_read_code_unit_from_cesu8 */
        -:  464:
        -:  465:/**
        -:  466: * Decodes a unicode code point from non-empty cesu-8-encoded buffer
        -:  467: *
        -:  468: * @return number of bytes occupied by code point in the string
        -:  469: */
        -:  470:lit_utf8_size_t
    #####:  471:lit_read_code_point_from_cesu8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  472:                                const lit_utf8_byte_t *buf_end_p, /**< buffer end */
        -:  473:                                lit_code_point_t *code_point) /**< [out] code point */
        -:  474:{
    #####:  475:  ecma_char_t code_unit;
    #####:  476:  lit_utf8_size_t size = lit_read_code_unit_from_cesu8 (buf_p, &code_unit);
        -:  477:
    #####:  478:  JERRY_ASSERT (buf_p + size <= buf_end_p);
        -:  479:
    #####:  480:  if (lit_is_code_point_utf16_high_surrogate (code_unit))
        -:  481:  {
    #####:  482:    buf_p += size;
        -:  483:
    #####:  484:    if (buf_p < buf_end_p)
        -:  485:    {
    #####:  486:      ecma_char_t next_code_unit;
    #####:  487:      lit_utf8_size_t next_size = lit_read_code_unit_from_cesu8 (buf_p, &next_code_unit);
        -:  488:
    #####:  489:      if (lit_is_code_point_utf16_low_surrogate (next_code_unit))
        -:  490:      {
    #####:  491:        JERRY_ASSERT (buf_p + next_size <= buf_end_p);
        -:  492:
    #####:  493:        *code_point = lit_convert_surrogate_pair_to_code_point (code_unit, next_code_unit);
    #####:  494:        return size + next_size;
        -:  495:      }
        -:  496:    }
        -:  497:  }
        -:  498:
    #####:  499:  *code_point = code_unit;
    #####:  500:  return size;
        -:  501:} /* lit_read_code_point_from_cesu8 */
        -:  502:
        -:  503:/**
        -:  504: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  505: *
        -:  506: * @return number of bytes occupied by code point in the string
        -:  507: */
        -:  508:lit_utf8_size_t
        5:  509:lit_read_prev_code_unit_from_utf8 (const lit_utf8_byte_t *buf_p, /**< buffer with characters */
        -:  510:                                   ecma_char_t *code_point) /**< [out] code point */
        -:  511:{
        5:  512:  JERRY_ASSERT (buf_p);
        -:  513:
        5:  514:  lit_utf8_decr (&buf_p);
        5:  515:  return lit_read_code_unit_from_cesu8 (buf_p, code_point);
        -:  516:} /* lit_read_prev_code_unit_from_utf8 */
        -:  517:
        -:  518:/**
        -:  519: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  520: *
        -:  521: * @return next code unit
        -:  522: */
        -:  523:ecma_char_t
    #####:  524:lit_cesu8_read_next (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  525:{
    #####:  526:  JERRY_ASSERT (*buf_p);
    #####:  527:  ecma_char_t ch;
        -:  528:
    #####:  529:  *buf_p += lit_read_code_unit_from_cesu8 (*buf_p, &ch);
        -:  530:
    #####:  531:  return ch;
        -:  532:} /* lit_cesu8_read_next */
        -:  533:
        -:  534:/**
        -:  535: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  536: *
        -:  537: * @return previous code unit
        -:  538: */
        -:  539:ecma_char_t
    #####:  540:lit_cesu8_read_prev (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  541:{
    #####:  542:  JERRY_ASSERT (*buf_p);
    #####:  543:  ecma_char_t ch;
        -:  544:
    #####:  545:  lit_utf8_decr (buf_p);
    #####:  546:  lit_read_code_unit_from_cesu8 (*buf_p, &ch);
        -:  547:
    #####:  548:  return ch;
        -:  549:} /* lit_cesu8_read_prev */
        -:  550:
        -:  551:/**
        -:  552: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  553: *
        -:  554: * @return next code unit
        -:  555: */
        -:  556:ecma_char_t JERRY_ATTR_NOINLINE
    #####:  557:lit_cesu8_peek_next (const lit_utf8_byte_t *buf_p) /**< [in,out] buffer with characters */
        -:  558:{
    #####:  559:  JERRY_ASSERT (buf_p != NULL);
    #####:  560:  ecma_char_t ch;
        -:  561:
    #####:  562:  lit_read_code_unit_from_cesu8 (buf_p, &ch);
        -:  563:
    #####:  564:  return ch;
        -:  565:} /* lit_cesu8_peek_next */
        -:  566:
        -:  567:/**
        -:  568: * Decodes a unicode code unit from non-empty cesu-8-encoded buffer
        -:  569: *
        -:  570: * @return previous code unit
        -:  571: */
        -:  572:ecma_char_t JERRY_ATTR_NOINLINE
    #####:  573:lit_cesu8_peek_prev (const lit_utf8_byte_t *buf_p) /**< [in,out] buffer with characters */
        -:  574:{
    #####:  575:  JERRY_ASSERT (buf_p != NULL);
    #####:  576:  ecma_char_t ch;
        -:  577:
    #####:  578:  lit_read_prev_code_unit_from_utf8 (buf_p, &ch);
        -:  579:
    #####:  580:  return ch;
        -:  581:} /* lit_cesu8_peek_prev */
        -:  582:
        -:  583:/**
        -:  584: * Increase cesu-8 encoded string pointer by one code unit.
        -:  585: */
        -:  586:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  587:lit_utf8_incr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  588:{
    #####:  589:  JERRY_ASSERT (*buf_p);
        -:  590:
    #####:  591:  *buf_p += lit_get_unicode_char_size_by_utf8_first_byte (**buf_p);
    #####:  592:} /* lit_utf8_incr */
        -:  593:
        -:  594:/**
        -:  595: * Decrease cesu-8 encoded string pointer by one code unit.
        -:  596: */
        -:  597:void
        5:  598:lit_utf8_decr (const lit_utf8_byte_t **buf_p) /**< [in,out] buffer with characters */
        -:  599:{
        5:  600:  JERRY_ASSERT (*buf_p);
        5:  601:  const lit_utf8_byte_t *current_p = *buf_p;
        -:  602:
        -:  603:  do
        -:  604:  {
        5:  605:    current_p--;
        -:  606:  }
        5:  607:  while ((*(current_p) & LIT_UTF8_EXTRA_BYTE_MASK) == LIT_UTF8_EXTRA_BYTE_MARKER);
        -:  608:
        5:  609:  *buf_p = current_p;
        5:  610:} /* lit_utf8_decr */
        -:  611:
        -:  612:/**
        -:  613: * Calc hash using the specified hash_basis.
        -:  614: *
        -:  615: * NOTE:
        -:  616: *   This is implementation of FNV-1a hash function, which is released into public domain.
        -:  617: *   Constants used, are carefully picked primes by the authors.
        -:  618: *   More info: http://www.isthe.com/chongo/tech/comp/fnv/
        -:  619: *
        -:  620: * @return ecma-string's hash
        -:  621: */
        -:  622:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
        2:  623:lit_utf8_string_hash_combine (lit_string_hash_t hash_basis, /**< hash to be combined with */
        -:  624:                              const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */
        -:  625:                              lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */
        -:  626:{
       14:  627:  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);
        -:  628:
       14:  629:  uint32_t hash = hash_basis;
        -:  630:
       98:  631:  for (uint32_t i = 0; i < utf8_buf_size; i++)
        -:  632:  {
        -:  633:    /* 16777619 is 32 bit FNV_prime = 2^24 + 2^8 + 0x93 = 16777619 */
       84:  634:    hash = (hash ^ utf8_buf_p[i]) * 16777619;
        -:  635:  }
        -:  636:
       14:  637:  return (lit_string_hash_t) hash;
        -:  638:} /* lit_utf8_string_hash_combine */
        -:  639:
        -:  640:/**
        -:  641: * Calculate hash from the buffer.
        -:  642: *
        -:  643: * @return ecma-string's hash
        -:  644: */
        -:  645:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
       12:  646:lit_utf8_string_calc_hash (const lit_utf8_byte_t *utf8_buf_p, /**< characters buffer */
        -:  647:                           lit_utf8_size_t utf8_buf_size) /**< number of characters in the buffer */
        -:  648:{
       12:  649:  JERRY_ASSERT (utf8_buf_p != NULL || utf8_buf_size == 0);
        -:  650:
        -:  651:  /* 32 bit offset_basis for FNV = 2166136261 */
       12:  652:  return lit_utf8_string_hash_combine ((lit_string_hash_t) 2166136261, utf8_buf_p, utf8_buf_size);
        -:  653:} /* lit_utf8_string_calc_hash */
        -:  654:
        -:  655:/**
        -:  656: * Return code unit at the specified position in string
        -:  657: *
        -:  658: * NOTE:
        -:  659: *   code_unit_offset should be less then string's length
        -:  660: *
        -:  661: * @return code unit value
        -:  662: */
        -:  663:ecma_char_t
    #####:  664:lit_utf8_string_code_unit_at (const lit_utf8_byte_t *utf8_buf_p, /**< utf-8 string */
        -:  665:                              lit_utf8_size_t utf8_buf_size, /**< string size in bytes */
        -:  666:                              lit_utf8_size_t code_unit_offset) /**< ofset of a code_unit */
        -:  667:{
    #####:  668:  lit_utf8_byte_t *current_p = (lit_utf8_byte_t *) utf8_buf_p;
    #####:  669:  ecma_char_t code_unit;
        -:  670:
        -:  671:  do
        -:  672:  {
    #####:  673:    JERRY_ASSERT (current_p < utf8_buf_p + utf8_buf_size);
    #####:  674:    current_p += lit_read_code_unit_from_cesu8 (current_p, &code_unit);
        -:  675:  }
    #####:  676:  while (code_unit_offset--);
        -:  677:
    #####:  678:  return code_unit;
        -:  679:} /* lit_utf8_string_code_unit_at */
        -:  680:
        -:  681:/**
        -:  682: * Get CESU-8 encoded size of character
        -:  683: *
        -:  684: * @return number of bytes occupied in CESU-8
        -:  685: */
        -:  686:extern inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
    #####:  687:lit_get_unicode_char_size_by_utf8_first_byte (const lit_utf8_byte_t first_byte) /**< buffer with characters */
        -:  688:{
       84:  689:  if ((first_byte & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  690:  {
       84:  691:    return 1;
        -:  692:  }
    #####:  693:  else if ((first_byte & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  694:  {
    #####:  695:    return 2;
        -:  696:  }
        -:  697:  else
        -:  698:  {
    #####:  699:    JERRY_ASSERT ((first_byte & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER);
    #####:  700:    return 3;
        -:  701:  }
        -:  702:} /* lit_get_unicode_char_size_by_utf8_first_byte */
        -:  703:
        -:  704:/**
        -:  705: * Convert code unit to cesu-8 representation
        -:  706: *
        -:  707: * @return byte count required to represent the code unit
        -:  708: */
        -:  709:lit_utf8_size_t
    #####:  710:lit_code_unit_to_utf8 (ecma_char_t code_unit, /**< code unit */
        -:  711:                       lit_utf8_byte_t *buf_p) /**< buffer where to store the result and its size
        -:  712:                                                *   should be at least LIT_UTF8_MAX_BYTES_IN_CODE_UNIT */
        -:  713:{
    #####:  714:  if (code_unit <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  715:  {
    #####:  716:    buf_p[0] = (lit_utf8_byte_t) code_unit;
    #####:  717:    return 1;
        -:  718:  }
    #####:  719:  else if (code_unit <= LIT_UTF8_2_BYTE_CODE_POINT_MAX)
        -:  720:  {
    #####:  721:    uint32_t code_unit_bits = code_unit;
    #####:  722:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  723:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  724:
    #####:  725:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_5_BITS_MASK);
    #####:  726:    JERRY_ASSERT (first_byte_bits == code_unit_bits);
        -:  727:
    #####:  728:    buf_p[0] = LIT_UTF8_2_BYTE_MARKER | first_byte_bits;
    #####:  729:    buf_p[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  730:    return 2;
        -:  731:  }
        -:  732:  else
        -:  733:  {
    #####:  734:    uint32_t code_unit_bits = code_unit;
    #####:  735:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  736:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  737:
    #####:  738:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  739:    code_unit_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  740:
    #####:  741:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_unit_bits & LIT_UTF8_LAST_4_BITS_MASK);
    #####:  742:    JERRY_ASSERT (first_byte_bits == code_unit_bits);
        -:  743:
    #####:  744:    buf_p[0] = LIT_UTF8_3_BYTE_MARKER | first_byte_bits;
    #####:  745:    buf_p[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  746:    buf_p[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  747:    return 3;
        -:  748:  }
        -:  749:} /* lit_code_unit_to_utf8 */
        -:  750:
        -:  751:/**
        -:  752: * Convert code point to cesu-8 representation
        -:  753: *
        -:  754: * @return byte count required to represent the code point
        -:  755: */
        -:  756:lit_utf8_size_t
    #####:  757:lit_code_point_to_cesu8 (lit_code_point_t code_point, /**< code point */
        -:  758:                         lit_utf8_byte_t *buf) /**< buffer where to store the result,
        -:  759:                                                *   its size should be at least 6 bytes */
        -:  760:{
    #####:  761:  if (code_point <= LIT_UTF16_CODE_UNIT_MAX)
        -:  762:  {
    #####:  763:    return lit_code_unit_to_utf8 ((ecma_char_t) code_point, buf);
        -:  764:  }
        -:  765:  else
        -:  766:  {
    #####:  767:    lit_utf8_size_t offset = lit_code_unit_to_utf8 (convert_code_point_to_high_surrogate (code_point), buf);
    #####:  768:    offset += lit_code_unit_to_utf8 (convert_code_point_to_low_surrogate (code_point), buf + offset);
    #####:  769:    return offset;
        -:  770:  }
        -:  771:} /* lit_code_point_to_cesu8 */
        -:  772:
        -:  773:/**
        -:  774: * Convert code point to utf-8 representation
        -:  775: *
        -:  776: * @return byte count required to represent the code point
        -:  777: */
        -:  778:lit_utf8_size_t
    #####:  779:lit_code_point_to_utf8 (lit_code_point_t code_point, /**< code point */
        -:  780:                        lit_utf8_byte_t *buf) /**< buffer where to store the result,
        -:  781:                                              *   its size should be at least 4 bytes */
        -:  782:{
    #####:  783:  if (code_point <= LIT_UTF8_1_BYTE_CODE_POINT_MAX)
        -:  784:  {
    #####:  785:    buf[0] = (lit_utf8_byte_t) code_point;
    #####:  786:    return 1;
        -:  787:  }
    #####:  788:  else if (code_point <= LIT_UTF8_2_BYTE_CODE_POINT_MAX)
        -:  789:  {
    #####:  790:    uint32_t code_point_bits = code_point;
    #####:  791:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  792:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  793:
    #####:  794:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_5_BITS_MASK);
    #####:  795:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  796:
    #####:  797:    buf[0] = LIT_UTF8_2_BYTE_MARKER | first_byte_bits;
    #####:  798:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  799:    return 2;
        -:  800:  }
    #####:  801:  else if (code_point <= LIT_UTF8_3_BYTE_CODE_POINT_MAX)
        -:  802:  {
    #####:  803:    uint32_t code_point_bits = code_point;
    #####:  804:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  805:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  806:
    #####:  807:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  808:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  809:
    #####:  810:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_4_BITS_MASK);
    #####:  811:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  812:
    #####:  813:    buf[0] = LIT_UTF8_3_BYTE_MARKER | first_byte_bits;
    #####:  814:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  815:    buf[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  816:    return 3;
        -:  817:  }
        -:  818:  else
        -:  819:  {
    #####:  820:    JERRY_ASSERT (code_point <= LIT_UTF8_4_BYTE_CODE_POINT_MAX);
        -:  821:
    #####:  822:    uint32_t code_point_bits = code_point;
    #####:  823:    lit_utf8_byte_t fourth_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  824:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  825:
    #####:  826:    lit_utf8_byte_t third_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  827:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  828:
    #####:  829:    lit_utf8_byte_t second_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_6_BITS_MASK);
    #####:  830:    code_point_bits >>= LIT_UTF8_BITS_IN_EXTRA_BYTES;
        -:  831:
    #####:  832:    lit_utf8_byte_t first_byte_bits = (lit_utf8_byte_t) (code_point_bits & LIT_UTF8_LAST_3_BITS_MASK);
    #####:  833:    JERRY_ASSERT (first_byte_bits == code_point_bits);
        -:  834:
    #####:  835:    buf[0] = LIT_UTF8_4_BYTE_MARKER | first_byte_bits;
    #####:  836:    buf[1] = LIT_UTF8_EXTRA_BYTE_MARKER | second_byte_bits;
    #####:  837:    buf[2] = LIT_UTF8_EXTRA_BYTE_MARKER | third_byte_bits;
    #####:  838:    buf[3] = LIT_UTF8_EXTRA_BYTE_MARKER | fourth_byte_bits;
    #####:  839:    return 4;
        -:  840:  }
        -:  841:} /* lit_code_point_to_utf8 */
        -:  842:
        -:  843:/**
        -:  844: * Convert cesu-8 string to an utf-8 string and put it into the buffer.
        -:  845: * It is the caller's responsibility to make sure that the string fits in the buffer.
        -:  846: *
        -:  847: * @return number of bytes copied to the buffer.
        -:  848: */
        -:  849:lit_utf8_size_t
    #####:  850:lit_convert_cesu8_string_to_utf8_string (const lit_utf8_byte_t *cesu8_string, /**< cesu-8 string */
        -:  851:                                         lit_utf8_size_t cesu8_size, /**< size of cesu-8 string */
        -:  852:                                         lit_utf8_byte_t *utf8_string, /**< destination utf-8 buffer pointer
        -:  853:                                                                        * (can be NULL if buffer_size == 0) */
        -:  854:                                         lit_utf8_size_t utf8_size) /**< size of utf-8 buffer */
        -:  855:{
    #####:  856:  const lit_utf8_byte_t *cesu8_pos = cesu8_string;
    #####:  857:  const lit_utf8_byte_t *cesu8_end_pos = cesu8_string + cesu8_size;
        -:  858:
    #####:  859:  lit_utf8_byte_t *utf8_pos = utf8_string;
    #####:  860:  lit_utf8_byte_t *utf8_end_pos = utf8_string + utf8_size;
        -:  861:
    #####:  862:  lit_utf8_size_t size = 0;
        -:  863:
    #####:  864:  ecma_char_t prev_ch = 0;
    #####:  865:  lit_utf8_size_t prev_ch_size = 0;
        -:  866:
    #####:  867:  while (cesu8_pos < cesu8_end_pos)
        -:  868:  {
    #####:  869:    ecma_char_t ch;
    #####:  870:    lit_utf8_size_t code_unit_size = lit_read_code_unit_from_cesu8 (cesu8_pos, &ch);
        -:  871:
    #####:  872:    if (lit_is_code_point_utf16_low_surrogate (ch) && lit_is_code_point_utf16_high_surrogate (prev_ch))
    #####:  873:    {
    #####:  874:      JERRY_ASSERT (code_unit_size == prev_ch_size);
    #####:  875:      utf8_pos -= prev_ch_size;
    #####:  876:      lit_code_point_t code_point = lit_convert_surrogate_pair_to_code_point (prev_ch, ch);
    #####:  877:      lit_code_point_to_utf8 (code_point, utf8_pos);
    #####:  878:      size++;
        -:  879:    }
        -:  880:    else
        -:  881:    {
    #####:  882:      memcpy (utf8_pos, cesu8_pos, code_unit_size);
    #####:  883:      size += code_unit_size;
        -:  884:    }
        -:  885:
    #####:  886:    utf8_pos = utf8_string + size;
    #####:  887:    cesu8_pos += code_unit_size;
    #####:  888:    prev_ch = ch;
    #####:  889:    prev_ch_size = code_unit_size;
        -:  890:  }
        -:  891:
    #####:  892:  JERRY_ASSERT (cesu8_pos == cesu8_end_pos);
    #####:  893:  JERRY_ASSERT (utf8_pos <= utf8_end_pos);
        -:  894:
    #####:  895:  return size;
        -:  896:} /* lit_convert_cesu8_string_to_utf8_string */
        -:  897:
        -:  898:/**
        -:  899: * Convert surrogate pair to code point
        -:  900: *
        -:  901: * @return code point
        -:  902: */
        -:  903:lit_code_point_t
    #####:  904:lit_convert_surrogate_pair_to_code_point (ecma_char_t high_surrogate, /**< high surrogate code point */
        -:  905:                                          ecma_char_t low_surrogate) /**< low surrogate code point */
        -:  906:{
    #####:  907:  JERRY_ASSERT (lit_is_code_point_utf16_high_surrogate (high_surrogate));
    #####:  908:  JERRY_ASSERT (lit_is_code_point_utf16_low_surrogate (low_surrogate));
        -:  909:
        -:  910:  lit_code_point_t code_point;
    #####:  911:  code_point = (uint16_t) (high_surrogate - LIT_UTF16_HIGH_SURROGATE_MIN);
    #####:  912:  code_point <<= LIT_UTF16_BITS_IN_SURROGATE;
        -:  913:
    #####:  914:  code_point += LIT_UTF16_FIRST_SURROGATE_CODE_POINT;
        -:  915:
    #####:  916:  code_point |= (uint16_t) (low_surrogate - LIT_UTF16_LOW_SURROGATE_MIN);
    #####:  917:  return code_point;
        -:  918:} /* lit_convert_surrogate_pair_to_code_point */
        -:  919:
        -:  920:/**
        -:  921: * Relational compare of cesu-8 strings
        -:  922: *
        -:  923: * First string is less than second string if:
        -:  924: *  - strings are not equal;
        -:  925: *  - first string is prefix of second or is lexicographically less than second.
        -:  926: *
        -:  927: * @return true - if first string is less than second string,
        -:  928: *         false - otherwise
        -:  929: */
    #####:  930:bool lit_compare_utf8_strings_relational (const lit_utf8_byte_t *string1_p, /**< utf-8 string */
        -:  931:                                          lit_utf8_size_t string1_size, /**< string size */
        -:  932:                                          const lit_utf8_byte_t *string2_p, /**< utf-8 string */
        -:  933:                                          lit_utf8_size_t string2_size) /**< string size */
        -:  934:{
    #####:  935:  lit_utf8_byte_t *string1_pos = (lit_utf8_byte_t *) string1_p;
    #####:  936:  lit_utf8_byte_t *string2_pos = (lit_utf8_byte_t *) string2_p;
    #####:  937:  const lit_utf8_byte_t *string1_end_p = string1_p + string1_size;
    #####:  938:  const lit_utf8_byte_t *string2_end_p = string2_p + string2_size;
        -:  939:
    #####:  940:  while (string1_pos < string1_end_p && string2_pos < string2_end_p)
        -:  941:  {
    #####:  942:    ecma_char_t ch1, ch2;
    #####:  943:    string1_pos += lit_read_code_unit_from_cesu8 (string1_pos, &ch1);
    #####:  944:    string2_pos += lit_read_code_unit_from_cesu8 (string2_pos, &ch2);
        -:  945:
    #####:  946:    if (ch1 < ch2)
        -:  947:    {
    #####:  948:      return true;
        -:  949:    }
    #####:  950:    else if (ch1 > ch2)
        -:  951:    {
    #####:  952:      return false;
        -:  953:    }
        -:  954:  }
        -:  955:
    #####:  956:  return (string1_pos >= string1_end_p && string2_pos < string2_end_p);
        -:  957:} /* lit_compare_utf8_strings_relational */
