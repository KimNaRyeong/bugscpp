        -:    0:Source:/home/workspace/jerry-core/vm/vm.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "common.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-arguments-object.h"
        -:   20:#include "ecma-array-object.h"
        -:   21:#include "ecma-bigint.h"
        -:   22:#include "ecma-builtins.h"
        -:   23:#include "ecma-builtin-object.h"
        -:   24:#include "ecma-comparison.h"
        -:   25:#include "ecma-conversion.h"
        -:   26:#include "ecma-exceptions.h"
        -:   27:#include "ecma-function-object.h"
        -:   28:#include "ecma-gc.h"
        -:   29:#include "ecma-helpers.h"
        -:   30:#include "ecma-iterator-object.h"
        -:   31:#include "ecma-lcache.h"
        -:   32:#include "ecma-lex-env.h"
        -:   33:#include "ecma-objects.h"
        -:   34:#include "ecma-objects-general.h"
        -:   35:#include "ecma-promise-object.h"
        -:   36:#include "ecma-regexp-object.h"
        -:   37:#include "jcontext.h"
        -:   38:#include "opcodes.h"
        -:   39:#include "vm.h"
        -:   40:#include "vm-stack.h"
        -:   41:
        -:   42:/** \addtogroup vm Virtual machine
        -:   43: * @{
        -:   44: *
        -:   45: * \addtogroup vm_executor Executor
        -:   46: * @{
        -:   47: */
        -:   48:
        -:   49:/**
        -:   50: * Get the value of object[property].
        -:   51: *
        -:   52: * @return ecma value
        -:   53: */
        -:   54:static ecma_value_t
      101:   55:vm_op_get_value (ecma_value_t object, /**< base object */
        -:   56:                 ecma_value_t property) /**< property name */
        -:   57:{
      101:   58:  if (ecma_is_value_object (object))
        -:   59:  {
      101:   60:    ecma_object_t *object_p = ecma_get_object_from_value (object);
      101:   61:    ecma_string_t *property_name_p = NULL;
        -:   62:
      101:   63:    if (ecma_is_value_integer_number (property))
        -:   64:    {
    #####:   65:      ecma_integer_value_t int_value = ecma_get_integer_from_value (property);
        -:   66:
    #####:   67:      if (int_value >= 0 && int_value <= ECMA_DIRECT_STRING_MAX_IMM)
        -:   68:      {
    #####:   69:        if (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY)
        -:   70:        {
    #####:   71:          ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   72:
    #####:   73:          if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)
        -:   74:                            && (uint32_t) int_value < ext_object_p->u.array.length))
        -:   75:          {
    #####:   76:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:   77:
    #####:   78:            if (JERRY_LIKELY (!ecma_is_value_array_hole (values_p[int_value])))
        -:   79:            {
    #####:   80:              return ecma_fast_copy_value (values_p[int_value]);
        -:   81:            }
        -:   82:          }
        -:   83:        }
        -:   84:
    #####:   85:        property_name_p = (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT,
        -:   86:                                                                       (uintptr_t) int_value);
        -:   87:      }
        -:   88:    }
      101:   89:    else if (ecma_is_value_string (property))
        -:   90:    {
      101:   91:      property_name_p = ecma_get_string_from_value (property);
        -:   92:    }
        -:   93:
        -:   94:#if JERRY_ESNEXT
      101:   95:    if (ecma_is_value_symbol (property))
        -:   96:    {
    #####:   97:      property_name_p = ecma_get_symbol_from_value (property);
        -:   98:    }
        -:   99:#endif /* JERRY_ESNEXT */
        -:  100:
      101:  101:    if (property_name_p != NULL)
        -:  102:    {
        -:  103:#if JERRY_LCACHE
      101:  104:      ecma_property_t *property_p = ecma_lcache_lookup (object_p, property_name_p);
        -:  105:
      101:  106:      if (property_p != NULL && (*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  107:      {
    #####:  108:        JERRY_ASSERT (!ECMA_PROPERTY_IS_INTERNAL (*property_p));
    #####:  109:        return ecma_fast_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  110:      }
        -:  111:#endif /* JERRY_LCACHE */
        -:  112:
        -:  113:      /* There is no need to free the name. */
      101:  114:      return ecma_op_object_get (object_p, property_name_p);
        -:  115:    }
        -:  116:  }
        -:  117:
    #####:  118:  if (JERRY_UNLIKELY (ecma_is_value_undefined (object) || ecma_is_value_null (object)))
        -:  119:  {
        -:  120:#if JERRY_ERROR_MESSAGES
    #####:  121:    ecma_value_t error_value = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,
        -:  122:                                                                      "Cannot read property '%' of %",
        -:  123:                                                                      property,
        -:  124:                                                                      object);
        -:  125:#else /* !JERRY_ERROR_MESSAGES */
        -:  126:    ecma_value_t error_value = ecma_raise_type_error (NULL);
        -:  127:#endif /* JERRY_ERROR_MESSAGES */
    #####:  128:    return error_value;
        -:  129:  }
        -:  130:
    #####:  131:  ecma_string_t *property_name_p = ecma_op_to_property_key (property);
        -:  132:
    #####:  133:  if (property_name_p == NULL)
        -:  134:  {
    #####:  135:    return ECMA_VALUE_ERROR;
        -:  136:  }
        -:  137:
    #####:  138:  ecma_value_t get_value_result = ecma_op_get_value_object_base (object, property_name_p);
        -:  139:
    #####:  140:  ecma_deref_ecma_string (property_name_p);
    #####:  141:  return get_value_result;
        -:  142:} /* vm_op_get_value */
        -:  143:
        -:  144:/**
        -:  145: * Set the value of object[property].
        -:  146: *
        -:  147: * Note:
        -:  148: *  this function frees its object and property arguments
        -:  149: *
        -:  150: * @return an ecma value which contains an error
        -:  151: *         if the property setting is unsuccessful
        -:  152: */
        -:  153:static ecma_value_t
        1:  154:vm_op_set_value (ecma_value_t base, /**< base object */
        -:  155:                 ecma_value_t property, /**< property name */
        -:  156:                 ecma_value_t value, /**< ecma value */
        -:  157:                 bool is_strict) /**< strict mode */
        -:  158:{
        1:  159:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -:  160:  ecma_object_t *object_p;
        -:  161:  ecma_string_t *property_p;
        -:  162:
        1:  163:  if (JERRY_UNLIKELY (!ecma_is_value_object (base)))
        -:  164:  {
    #####:  165:    if (JERRY_UNLIKELY (ecma_is_value_null (base) || ecma_is_value_undefined (base)))
        -:  166:    {
        -:  167:#if JERRY_ERROR_MESSAGES
    #####:  168:      result = ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,
        -:  169:                                                      "Cannot set property '%' of %",
        -:  170:                                                      property,
        -:  171:                                                      base);
        -:  172:#else /* !JERRY_ERROR_MESSAGES */
        -:  173:      result = ecma_raise_type_error (NULL);
        -:  174:#endif /* JERRY_ERROR_MESSAGES */
    #####:  175:      ecma_free_value (property);
    #####:  176:      return result;
        -:  177:    }
        -:  178:
    #####:  179:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  180:    {
    #####:  181:      property_p = ecma_op_to_string (property);
    #####:  182:      ecma_fast_free_value (property);
        -:  183:
    #####:  184:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  185:      {
    #####:  186:        ecma_free_value (base);
    #####:  187:        return ECMA_VALUE_ERROR;
        -:  188:      }
        -:  189:    }
        -:  190:    else
        -:  191:    {
    #####:  192:      property_p = ecma_get_prop_name_from_value (property);
        -:  193:    }
        -:  194:
    #####:  195:    ecma_value_t object = ecma_op_to_object (base);
    #####:  196:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (object));
        -:  197:
    #####:  198:    object_p = ecma_get_object_from_value (object);
    #####:  199:    ecma_op_ordinary_object_prevent_extensions (object_p);
        -:  200:
    #####:  201:    result = ecma_op_object_put_with_receiver (object_p,
        -:  202:                                               property_p,
        -:  203:                                               value,
        -:  204:                                               base,
        -:  205:                                               is_strict);
        -:  206:
    #####:  207:    ecma_free_value (base);
        -:  208:  }
        -:  209:  else
        -:  210:  {
        1:  211:    object_p = ecma_get_object_from_value (base);
        -:  212:
        1:  213:    if (JERRY_UNLIKELY (!ecma_is_value_prop_name (property)))
        -:  214:    {
    #####:  215:      property_p = ecma_op_to_string (property);
    #####:  216:      ecma_fast_free_value (property);
        -:  217:
    #####:  218:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  219:      {
    #####:  220:        ecma_deref_object (object_p);
    #####:  221:        return ECMA_VALUE_ERROR;
        -:  222:      }
        -:  223:    }
        -:  224:    else
        -:  225:    {
        1:  226:      property_p = ecma_get_prop_name_from_value (property);
        -:  227:    }
        -:  228:
        1:  229:    if (!ecma_is_lexical_environment (object_p))
        -:  230:    {
        1:  231:      result = ecma_op_object_put_with_receiver (object_p,
        -:  232:                                                 property_p,
        -:  233:                                                 value,
        -:  234:                                                 base,
        -:  235:                                                 is_strict);
        -:  236:    }
        -:  237:    else
        -:  238:    {
    #####:  239:      result = ecma_op_set_mutable_binding (object_p,
        -:  240:                                            property_p,
        -:  241:                                            value,
        -:  242:                                            is_strict);
        -:  243:    }
        -:  244:  }
        -:  245:
        1:  246:  ecma_deref_object (object_p);
        1:  247:  ecma_deref_ecma_string (property_p);
        1:  248:  return result;
        -:  249:} /* vm_op_set_value */
        -:  250:
        -:  251:/** Compact bytecode define */
        -:  252:#define CBC_OPCODE(arg1, arg2, arg3, arg4) arg4,
        -:  253:
        -:  254:/**
        -:  255: * Decode table for both opcodes and extended opcodes.
        -:  256: */
        -:  257:static const uint16_t vm_decode_table[] JERRY_ATTR_CONST_DATA =
        -:  258:{
        -:  259:  CBC_OPCODE_LIST
        -:  260:  CBC_EXT_OPCODE_LIST
        -:  261:};
        -:  262:
        -:  263:#undef CBC_OPCODE
        -:  264:
        -:  265:/**
        -:  266: * Run global code
        -:  267: *
        -:  268: * Note:
        -:  269: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  270: *
        -:  271: * @return ecma value
        -:  272: */
        -:  273:ecma_value_t
        1:  274:vm_run_global (const ecma_compiled_code_t *bytecode_p, /**< pointer to bytecode to run */
        -:  275:               ecma_object_t *function_object_p) /**< function object if available */
        -:  276:{
        -:  277:#if JERRY_BUILTIN_REALMS
        1:  278:  ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_p);
        -:  279:#else /* !JERRY_BUILTIN_REALMS */
    #####:  280:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        -:  281:#endif /* JERRY_BUILTIN_REALMS */
        -:  282:
        -:  283:#if JERRY_ESNEXT
        1:  284:  if (bytecode_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED)
        -:  285:  {
    #####:  286:    ecma_create_global_lexical_block (global_obj_p);
        -:  287:  }
        -:  288:#endif /* JERRY_ESNEXT */
        -:  289:
        1:  290:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -:  291:
        1:  292:  vm_frame_ctx_shared_t shared;
        1:  293:  shared.bytecode_header_p = bytecode_p;
        1:  294:  shared.function_object_p = function_object_p;
        1:  295:  shared.status_flags = 0;
        -:  296:
        -:  297:#if JERRY_BUILTIN_REALMS
        1:  298:  ecma_value_t this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
        -:  299:
        1:  300:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
        1:  301:  JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) global_obj_p;
        -:  302:#else /* !JERRY_BUILTIN_REALMS */
    #####:  303:  ecma_value_t this_binding = ecma_make_object_value (global_obj_p);
        -:  304:#endif /* JERRY_BUILTIN_REALMS */
        -:  305:
        1:  306:  ecma_value_t result = vm_run (&shared, this_binding, global_scope_p);
        -:  307:
        -:  308:#if JERRY_BUILTIN_REALMS
    #####:  309:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  310:#endif /* JERRY_BUILTIN_REALMS */
        -:  311:
    #####:  312:  return result;
        -:  313:} /* vm_run_global */
        -:  314:
        -:  315:/**
        -:  316: * Run specified eval-mode bytecode
        -:  317: *
        -:  318: * @return ecma value
        -:  319: */
        -:  320:ecma_value_t
    #####:  321:vm_run_eval (ecma_compiled_code_t *bytecode_data_p, /**< byte-code data */
        -:  322:             uint32_t parse_opts) /**< ecma_parse_opts_t option bits */
        -:  323:{
        -:  324:  ecma_value_t this_binding;
        -:  325:  ecma_object_t *lex_env_p;
        -:  326:
        -:  327:  /* ECMA-262 v5, 10.4.2 */
    #####:  328:  if (parse_opts & ECMA_PARSE_DIRECT_EVAL)
        -:  329:  {
    #####:  330:    this_binding = ecma_copy_value (JERRY_CONTEXT (vm_top_context_p)->this_binding);
    #####:  331:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  332:
        -:  333:#if JERRY_DEBUGGER
        -:  334:    uint32_t chain_index = parse_opts >> ECMA_PARSE_CHAIN_INDEX_SHIFT;
        -:  335:    parse_opts &= (1 << ECMA_PARSE_CHAIN_INDEX_SHIFT) - 1;
        -:  336:
        -:  337:    while (chain_index != 0)
        -:  338:    {
        -:  339:      if (JERRY_UNLIKELY (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL))
        -:  340:      {
        -:  341:        ecma_bytecode_deref (bytecode_data_p);
        -:  342:        ecma_free_value (this_binding);
        -:  343:        return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid scope chain index for eval"));
        -:  344:      }
        -:  345:
        -:  346:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  347:
        -:  348:      if ((ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND)
        -:  349:          || (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE))
        -:  350:      {
        -:  351:        chain_index--;
        -:  352:      }
        -:  353:    }
        -:  354:#endif /* JERRY_DEBUGGER */
        -:  355:  }
        -:  356:  else
        -:  357:  {
        -:  358:#if JERRY_BUILTIN_REALMS
    #####:  359:    ecma_object_t *global_obj_p = (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p);
    #####:  360:    this_binding = ((ecma_global_object_t *) global_obj_p)->this_binding;
    #####:  361:    ecma_ref_object (ecma_get_object_from_value (this_binding));
        -:  362:#else /* !JERRY_BUILTIN_REALMS */
    #####:  363:    ecma_object_t *global_obj_p = ecma_builtin_get_global ();
    #####:  364:    ecma_ref_object (global_obj_p);
    #####:  365:    this_binding = ecma_make_object_value (global_obj_p);
        -:  366:#endif /* JERRY_BUILTIN_REALMS */
    #####:  367:    lex_env_p = ecma_get_global_scope (global_obj_p);
        -:  368:  }
        -:  369:
    #####:  370:  ecma_ref_object (lex_env_p);
        -:  371:
    #####:  372:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0)
        -:  373:  {
    #####:  374:    ecma_object_t *strict_lex_env_p = ecma_create_decl_lex_env (lex_env_p);
        -:  375:
    #####:  376:    ecma_deref_object (lex_env_p);
    #####:  377:    lex_env_p = strict_lex_env_p;
        -:  378:  }
        -:  379:
    #####:  380:  if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED) != 0)
        -:  381:  {
    #####:  382:    ecma_object_t *lex_block_p = ecma_create_decl_lex_env (lex_env_p);
    #####:  383:    lex_block_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -:  384:
    #####:  385:    ecma_deref_object (lex_env_p);
    #####:  386:    lex_env_p = lex_block_p;
        -:  387:  }
        -:  388:
    #####:  389:  vm_frame_ctx_shared_t shared;
    #####:  390:  shared.bytecode_header_p = bytecode_data_p;
    #####:  391:  shared.function_object_p = NULL;
    #####:  392:  shared.status_flags = (parse_opts & ECMA_PARSE_DIRECT_EVAL) ? VM_FRAME_CTX_SHARED_DIRECT_EVAL : 0;
        -:  393:
    #####:  394:  ecma_value_t completion_value = vm_run (&shared, this_binding, lex_env_p);
        -:  395:
    #####:  396:  ecma_deref_object (lex_env_p);
    #####:  397:  ecma_free_value (this_binding);
        -:  398:
        -:  399:#if JERRY_SNAPSHOT_EXEC
    #####:  400:  if (!(bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -:  401:  {
    #####:  402:    ecma_bytecode_deref (bytecode_data_p);
        -:  403:  }
        -:  404:#else /* !JERRY_SNAPSHOT_EXEC */
    #####:  405:  ecma_bytecode_deref (bytecode_data_p);
        -:  406:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  407:
    #####:  408:  return completion_value;
        -:  409:} /* vm_run_eval */
        -:  410:
        -:  411:#if JERRY_MODULE_SYSTEM
        -:  412:
        -:  413:/**
        -:  414: * Run module code
        -:  415: *
        -:  416: * Note:
        -:  417: *      returned value must be freed with ecma_free_value, when it is no longer needed.
        -:  418: *
        -:  419: * @return ecma value
        -:  420: */
        -:  421:ecma_value_t
    #####:  422:vm_run_module (ecma_module_t *module_p) /**< module to be executed */
        -:  423:{
    #####:  424:  const ecma_value_t module_init_result = ecma_module_initialize (module_p);
        -:  425:
    #####:  426:  if (ECMA_IS_VALUE_ERROR (module_init_result))
        -:  427:  {
    #####:  428:    return module_init_result;
        -:  429:  }
        -:  430:
    #####:  431:  vm_frame_ctx_shared_t shared;
    #####:  432:  shared.bytecode_header_p = module_p->u.compiled_code_p;
    #####:  433:  shared.function_object_p = &module_p->header.object;
    #####:  434:  shared.status_flags = 0;
        -:  435:
    #####:  436:  return vm_run (&shared, ECMA_VALUE_UNDEFINED, module_p->scope_p);
        -:  437:} /* vm_run_module */
        -:  438:
        -:  439:#endif /* JERRY_MODULE_SYSTEM */
        -:  440:
        -:  441:/**
        -:  442: * Construct object
        -:  443: *
        -:  444: * @return object value
        -:  445: */
        -:  446:static ecma_value_t
        1:  447:vm_construct_literal_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  448:                             ecma_value_t lit_value) /**< literal */
        -:  449:{
        -:  450:  ecma_compiled_code_t *bytecode_p;
        -:  451:
        -:  452:#if JERRY_SNAPSHOT_EXEC
    #####:  453:  if (JERRY_LIKELY (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -:  454:  {
        -:  455:#endif /* JERRY_SNAPSHOT_EXEC */
        1:  456:    bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -:  457:                                                  lit_value);
        -:  458:#if JERRY_SNAPSHOT_EXEC
        -:  459:  }
        -:  460:  else
        -:  461:  {
    #####:  462:    uint8_t *byte_p = ((uint8_t *) frame_ctx_p->shared_p->bytecode_header_p) + lit_value;
    #####:  463:    bytecode_p = (ecma_compiled_code_t *) byte_p;
        -:  464:  }
        -:  465:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  466:
        -:  467:#if JERRY_BUILTIN_REGEXP
        1:  468:  if (JERRY_UNLIKELY (!CBC_IS_FUNCTION (bytecode_p->status_flags)))
        -:  469:  {
    #####:  470:    ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  471:
    #####:  472:    if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  473:    {
    #####:  474:      return ECMA_VALUE_ERROR;
        -:  475:    }
        -:  476:
    #####:  477:    return ecma_op_create_regexp_from_bytecode (regexp_obj_p, (re_compiled_code_t *) bytecode_p);
        -:  478:  }
        -:  479:#else /* !JERRY_BUILTIN_REGEXP */
        -:  480:  JERRY_ASSERT (CBC_IS_FUNCTION (bytecode_p->status_flags));
        -:  481:#endif /* JERRY_BUILTIN_REGEXP */
        -:  482:
        -:  483:  ecma_object_t *func_obj_p;
        -:  484:
        -:  485:#if JERRY_ESNEXT
        1:  486:  if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (bytecode_p->status_flags)))
        -:  487:  {
    #####:  488:    func_obj_p = ecma_op_create_arrow_function_object (frame_ctx_p->lex_env_p,
        -:  489:                                                       bytecode_p,
        -:  490:                                                       frame_ctx_p->this_binding);
        -:  491:  }
        -:  492:  else
        -:  493:  {
        1:  494:    func_obj_p = ecma_op_create_any_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  495:  }
        -:  496:#else /* !JERRY_ESNEXT */
    #####:  497:  func_obj_p = ecma_op_create_simple_function_object (frame_ctx_p->lex_env_p, bytecode_p);
        -:  498:#endif /* JERRY_ESNEXT */
        -:  499:
        1:  500:  return ecma_make_object_value (func_obj_p);
        -:  501:} /* vm_construct_literal_object */
        -:  502:
        -:  503:/**
        -:  504: * Get implicit this value
        -:  505: *
        -:  506: * @return true - if the implicit 'this' value is updated,
        -:  507: *         false - otherwise
        -:  508: */
        -:  509:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  510:vm_get_implicit_this_value (ecma_value_t *this_value_p) /**< [in,out] this value */
        -:  511:{
    #####:  512:  if (ecma_is_value_object (*this_value_p))
        -:  513:  {
    #####:  514:    ecma_object_t *this_obj_p = ecma_get_object_from_value (*this_value_p);
        -:  515:
    #####:  516:    if (ecma_is_lexical_environment (this_obj_p))
        -:  517:    {
    #####:  518:      ecma_value_t completion_value = ecma_op_implicit_this_value (this_obj_p);
        -:  519:
    #####:  520:      JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (completion_value));
        -:  521:
    #####:  522:      *this_value_p = completion_value;
    #####:  523:      return true;
        -:  524:    }
        -:  525:  }
    #####:  526:  return false;
        -:  527:} /* vm_get_implicit_this_value */
        -:  528:
        -:  529:/**
        -:  530: * Special bytecode sequence for error handling while the vm_loop
        -:  531: * is preserved for an execute operation
        -:  532: */
        -:  533:static const uint8_t vm_error_byte_code_p[] =
        -:  534:{
        -:  535:  CBC_EXT_OPCODE, CBC_EXT_ERROR
        -:  536:};
        -:  537:
        -:  538:#if JERRY_ESNEXT
        -:  539:
        -:  540:static ecma_object_t *
    #####:  541:vm_get_class_function (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  542:{
    #####:  543:  JERRY_ASSERT (frame_ctx_p != NULL);
        -:  544:
    #####:  545:  if (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC)
        -:  546:  {
    #####:  547:    return frame_ctx_p->shared_p->function_object_p;
        -:  548:  }
        -:  549:
    #####:  550:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  551:
    #####:  552:  JERRY_ASSERT (environment_record_p != NULL);
    #####:  553:  return ecma_get_object_from_value (environment_record_p->function_object);
        -:  554:} /* vm_get_class_function */
        -:  555:
        -:  556:/**
        -:  557: * 'super(...)' function call handler.
        -:  558: */
        -:  559:static void
    #####:  560:vm_super_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  561:{
    #####:  562:  JERRY_ASSERT (frame_ctx_p->call_operation == VM_EXEC_SUPER_CALL);
    #####:  563:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  564:
    #####:  565:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 3;
    #####:  566:  uint8_t opcode = byte_code_p[-2];
        -:  567:  uint32_t arguments_list_len;
        -:  568:
    #####:  569:  bool spread_arguments = opcode >= CBC_EXT_SPREAD_SUPER_CALL;
        -:  570:
    #####:  571:  ecma_collection_t *collection_p = NULL;
        -:  572:  ecma_value_t *arguments_p;
        -:  573:
    #####:  574:  if (spread_arguments)
        -:  575:  {
    #####:  576:    ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
    #####:  577:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  578:    arguments_p = collection_p->buffer_p;
    #####:  579:    arguments_list_len = collection_p->item_count;
        -:  580:  }
        -:  581:  else
        -:  582:  {
    #####:  583:    arguments_list_len = byte_code_p[-1];
    #####:  584:    arguments_p = frame_ctx_p->stack_top_p;
        -:  585:  }
        -:  586:
    #####:  587:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
        -:  588:  ecma_value_t completion_value;
        -:  589:
    #####:  590:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -:  591:
    #####:  592:  if (!ecma_is_constructor (func_value))
        -:  593:  {
    #####:  594:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG ("Value for class heritage is not a constructor"));
        -:  595:  }
        -:  596:  else
        -:  597:  {
    #####:  598:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
    #####:  599:    completion_value = ecma_op_function_construct (func_obj_p,
        -:  600:                                                   JERRY_CONTEXT (current_new_target_p),
        -:  601:                                                   arguments_p,
        -:  602:                                                   arguments_list_len);
        -:  603:
    #####:  604:    if (!ECMA_IS_VALUE_ERROR (completion_value) && ecma_op_this_binding_is_initialized (environment_record_p))
        -:  605:    {
    #####:  606:      ecma_free_value (completion_value);
    #####:  607:      completion_value = ecma_raise_reference_error (ECMA_ERR_MSG ("Super constructor may only be called once"));
        -:  608:    }
        -:  609:  }
        -:  610:
        -:  611:  /* Free registers. */
    #####:  612:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  613:  {
    #####:  614:    ecma_fast_free_value (arguments_p[i]);
        -:  615:  }
        -:  616:
    #####:  617:  if (collection_p != NULL)
        -:  618:  {
    #####:  619:    ecma_collection_destroy (collection_p);
        -:  620:  }
        -:  621:
    #####:  622:  if (ecma_is_value_object (completion_value))
        -:  623:  {
    #####:  624:    ecma_value_t fields_value = opfunc_init_class_fields (vm_get_class_function (frame_ctx_p), completion_value);
        -:  625:
    #####:  626:    if (ECMA_IS_VALUE_ERROR (fields_value))
        -:  627:    {
    #####:  628:      ecma_free_value (completion_value);
    #####:  629:      completion_value = ECMA_VALUE_ERROR;
        -:  630:    }
        -:  631:  }
        -:  632:
    #####:  633:  ecma_free_value (func_value);
        -:  634:
    #####:  635:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  636:  {
        -:  637:#if JERRY_DEBUGGER
        -:  638:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  639:#endif /* JERRY_DEBUGGER */
    #####:  640:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  641:  }
        -:  642:  else
        -:  643:  {
    #####:  644:    ecma_op_bind_this_value (environment_record_p, completion_value);
    #####:  645:    frame_ctx_p->this_binding = completion_value;
        -:  646:
    #####:  647:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  648:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  649:
    #####:  650:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  651:    {
    #####:  652:      ecma_fast_free_value (completion_value);
        -:  653:    }
    #####:  654:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  655:    {
    #####:  656:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  657:    }
        -:  658:    else
        -:  659:    {
    #####:  660:      ecma_fast_free_value (frame_ctx_p->block_result);
    #####:  661:      frame_ctx_p->block_result = completion_value;
        -:  662:    }
        -:  663:  }
    #####:  664:} /* vm_super_call */
        -:  665:
        -:  666:/**
        -:  667: * Perform one of the following call/construct operation with spreaded argument list
        -:  668: *   - f(...args)
        -:  669: *   - o.f(...args)
        -:  670: *   - new O(...args)
        -:  671: */
        -:  672:static void
    #####:  673:vm_spread_operation (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  674:{
    #####:  675:  JERRY_ASSERT (frame_ctx_p->byte_code_p[0] == CBC_EXT_OPCODE);
        -:  676:
    #####:  677:  uint8_t opcode = frame_ctx_p->byte_code_p[1];
        -:  678:  ecma_value_t completion_value;
    #####:  679:  ecma_value_t collection = *(--frame_ctx_p->stack_top_p);
        -:  680:
    #####:  681:  ecma_collection_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, collection);
    #####:  682:  ecma_value_t func_value = *(--frame_ctx_p->stack_top_p);
    #####:  683:  bool is_call_prop = opcode >= CBC_EXT_SPREAD_CALL_PROP;
        -:  684:
    #####:  685:  if (frame_ctx_p->byte_code_p[1] == CBC_EXT_SPREAD_NEW)
        -:  686:  {
    #####:  687:    const char *constructor_message_p = ecma_check_constructor (func_value);
    #####:  688:    if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)
        -:  689:    {
    #####:  690:      completion_value = ecma_raise_type_error (constructor_message_p);
        -:  691:    }
        -:  692:    else
        -:  693:    {
    #####:  694:      ecma_object_t *constructor_obj_p = ecma_get_object_from_value (func_value);
        -:  695:
    #####:  696:      completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  697:                                                     constructor_obj_p,
    #####:  698:                                                     collection_p->buffer_p,
        -:  699:                                                     collection_p->item_count);
        -:  700:    }
        -:  701:  }
        -:  702:  else
        -:  703:  {
    #####:  704:    ecma_value_t this_value = is_call_prop ? frame_ctx_p->stack_top_p[-2] : ECMA_VALUE_UNDEFINED;
        -:  705:
    #####:  706:    if (!ecma_is_value_object (func_value)
    #####:  707:        || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  708:    {
    #####:  709:      completion_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));
        -:  710:    }
        -:  711:    else
        -:  712:    {
    #####:  713:      ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  714:
    #####:  715:      completion_value = ecma_op_function_call (func_obj_p,
        -:  716:                                                this_value,
    #####:  717:                                                collection_p->buffer_p,
        -:  718:                                                collection_p->item_count);
        -:  719:    }
        -:  720:
    #####:  721:    if (is_call_prop)
        -:  722:    {
    #####:  723:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
    #####:  724:      ecma_free_value (*(--frame_ctx_p->stack_top_p));
        -:  725:    }
        -:  726:  }
        -:  727:
    #####:  728:  ecma_collection_free (collection_p);
    #####:  729:  ecma_free_value (func_value);
        -:  730:
    #####:  731:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  732:  {
        -:  733:#if JERRY_DEBUGGER
        -:  734:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  735:#endif /* JERRY_DEBUGGER */
    #####:  736:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  737:  }
        -:  738:  else
        -:  739:  {
    #####:  740:    uint32_t opcode_data = vm_decode_table[(CBC_END + 1) + opcode];
        -:  741:
    #####:  742:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  743:    {
    #####:  744:      ecma_fast_free_value (completion_value);
        -:  745:    }
    #####:  746:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  747:    {
    #####:  748:      *frame_ctx_p->stack_top_p++ = completion_value;
        -:  749:    }
        -:  750:    else
        -:  751:    {
    #####:  752:      ecma_fast_free_value (frame_ctx_p->block_result);
    #####:  753:      frame_ctx_p->block_result = completion_value;
        -:  754:    }
        -:  755:
        -:  756:    /* EXT_OPCODE, SPREAD_OPCODE, BYTE_ARG */
    #####:  757:    frame_ctx_p->byte_code_p += 3;
        -:  758:  }
    #####:  759:} /* vm_spread_operation */
        -:  760:#endif /* JERRY_ESNEXT */
        -:  761:
        -:  762:/**
        -:  763: * 'Function call' opcode handler.
        -:  764: *
        -:  765: * See also: ECMA-262 v5, 11.2.3
        -:  766: */
        -:  767:static void
      101:  768:opfunc_call (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  769:{
      101:  770:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
      101:  771:  uint8_t opcode = byte_code_p[-1];
        -:  772:  uint32_t arguments_list_len;
        -:  773:
      101:  774:  if (opcode >= CBC_CALL0)
        -:  775:  {
      101:  776:    arguments_list_len = (unsigned int) ((opcode - CBC_CALL0) / 6);
        -:  777:  }
        -:  778:  else
        -:  779:  {
    #####:  780:    arguments_list_len = *byte_code_p++;
        -:  781:  }
        -:  782:
      101:  783:  bool is_call_prop = ((opcode - CBC_CALL) % 6) >= 3;
        -:  784:
      101:  785:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
      101:  786:  ecma_value_t this_value = is_call_prop ? stack_top_p[-3] : ECMA_VALUE_UNDEFINED;
      101:  787:  ecma_value_t func_value = stack_top_p[-1];
        -:  788:  ecma_value_t completion_value;
        -:  789:
      101:  790:  if (!ecma_is_value_object (func_value)
      101:  791:      || !ecma_op_object_is_callable (ecma_get_object_from_value (func_value)))
        -:  792:  {
    #####:  793:    completion_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));
        -:  794:  }
        -:  795:  else
        -:  796:  {
      101:  797:    ecma_object_t *func_obj_p = ecma_get_object_from_value (func_value);
        -:  798:
      101:  799:    completion_value = ecma_op_function_call (func_obj_p,
        -:  800:                                              this_value,
        -:  801:                                              stack_top_p,
        -:  802:                                              arguments_list_len);
        -:  803:  }
        -:  804:
      100:  805:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        -:  806:
        -:  807:  /* Free registers. */
      200:  808:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  809:  {
      100:  810:    ecma_fast_free_value (stack_top_p[i]);
        -:  811:  }
        -:  812:
      100:  813:  if (is_call_prop)
        -:  814:  {
      100:  815:    ecma_free_value (*(--stack_top_p));
      100:  816:    ecma_free_value (*(--stack_top_p));
        -:  817:  }
        -:  818:
      100:  819:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  820:  {
        -:  821:#if JERRY_DEBUGGER
        -:  822:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  823:#endif /* JERRY_DEBUGGER */
    #####:  824:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  825:  }
        -:  826:  else
        -:  827:  {
      100:  828:    frame_ctx_p->byte_code_p = byte_code_p;
      100:  829:    ecma_free_value (*(--stack_top_p));
      100:  830:    uint32_t opcode_data = vm_decode_table[opcode];
        -:  831:
      100:  832:    if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -:  833:    {
    #####:  834:      ecma_fast_free_value (completion_value);
        -:  835:    }
      100:  836:    else if (opcode_data & VM_OC_PUT_STACK)
        -:  837:    {
    #####:  838:      *stack_top_p++ = completion_value;
        -:  839:    }
        -:  840:    else
        -:  841:    {
      100:  842:      ecma_fast_free_value (frame_ctx_p->block_result);
      100:  843:      frame_ctx_p->block_result = completion_value;
        -:  844:    }
        -:  845:  }
        -:  846:
      100:  847:  frame_ctx_p->stack_top_p = stack_top_p;
      100:  848:} /* opfunc_call */
        -:  849:
        -:  850:/**
        -:  851: * 'Constructor call' opcode handler.
        -:  852: *
        -:  853: * See also: ECMA-262 v5, 11.2.2
        -:  854: */
        -:  855:static void
    #####:  856:opfunc_construct (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -:  857:{
    #####:  858:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p + 1;
    #####:  859:  uint8_t opcode = byte_code_p[-1];
        -:  860:  unsigned int arguments_list_len;
        -:  861:
    #####:  862:  if (opcode >= CBC_NEW0)
        -:  863:  {
    #####:  864:    arguments_list_len = (unsigned int) (opcode - CBC_NEW0);
        -:  865:  }
        -:  866:  else
        -:  867:  {
    #####:  868:    arguments_list_len = *byte_code_p++;
        -:  869:  }
        -:  870:
    #####:  871:  ecma_value_t *stack_top_p = frame_ctx_p->stack_top_p - arguments_list_len;
    #####:  872:  ecma_value_t constructor_value = stack_top_p[-1];
        -:  873:  ecma_value_t completion_value;
        -:  874:
    #####:  875:  const char *constructor_message_p = ecma_check_constructor (constructor_value);
    #####:  876:  if (constructor_message_p != ECMA_IS_VALID_CONSTRUCTOR)
        -:  877:  {
    #####:  878:    completion_value = ecma_raise_type_error (constructor_message_p);
        -:  879:  }
        -:  880:  else
        -:  881:  {
    #####:  882:    ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor_value);
        -:  883:
    #####:  884:    completion_value = ecma_op_function_construct (constructor_obj_p,
        -:  885:                                                   constructor_obj_p,
        -:  886:                                                   stack_top_p,
        -:  887:                                                   arguments_list_len);
        -:  888:  }
        -:  889:
        -:  890:  /* Free registers. */
    #####:  891:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  892:  {
    #####:  893:    ecma_fast_free_value (stack_top_p[i]);
        -:  894:  }
        -:  895:
    #####:  896:  if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (completion_value)))
        -:  897:  {
        -:  898:#if JERRY_DEBUGGER
        -:  899:    JERRY_CONTEXT (debugger_exception_byte_code_p) = frame_ctx_p->byte_code_p;
        -:  900:#endif /* JERRY_DEBUGGER */
    #####:  901:    frame_ctx_p->byte_code_p = (uint8_t *) vm_error_byte_code_p;
        -:  902:  }
        -:  903:  else
        -:  904:  {
    #####:  905:    ecma_free_value (stack_top_p[-1]);
    #####:  906:    frame_ctx_p->byte_code_p = byte_code_p;
    #####:  907:    stack_top_p[-1] = completion_value;
        -:  908:  }
        -:  909:
    #####:  910:  frame_ctx_p->stack_top_p = stack_top_p;
    #####:  911:} /* opfunc_construct */
        -:  912:
        -:  913:/**
        -:  914: * Read literal index from the byte code stream into destination.
        -:  915: *
        -:  916: * @param destination destination
        -:  917: */
        -:  918:#define READ_LITERAL_INDEX(destination) \
        -:  919:  do \
        -:  920:  { \
        -:  921:    (destination) = *byte_code_p++; \
        -:  922:    if ((destination) >= encoding_limit) \
        -:  923:    { \
        -:  924:      (destination) = (uint16_t) ((((destination) << 8) | *byte_code_p++) - encoding_delta); \
        -:  925:    } \
        -:  926:  } \
        -:  927:  while (0)
        -:  928:
        -:  929:/**
        -:  930: * Get literal value by literal index.
        -:  931: *
        -:  932: * @param literal_index literal index
        -:  933: * @param target_value target value
        -:  934: *
        -:  935: * TODO: For performance reasons, we define this as a macro.
        -:  936: * When we are able to construct a function with similar speed,
        -:  937: * we can remove this macro.
        -:  938: */
        -:  939:#define READ_LITERAL(literal_index, target_value) \
        -:  940:  do \
        -:  941:  { \
        -:  942:    if ((literal_index) < ident_end) \
        -:  943:    { \
        -:  944:      if ((literal_index) < register_end) \
        -:  945:      { \
        -:  946:        /* Note: There should be no specialization for arguments. */ \
        -:  947:        (target_value) = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index)); \
        -:  948:      } \
        -:  949:      else \
        -:  950:      { \
        -:  951:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]); \
        -:  952:        \
        -:  953:        result = ecma_op_resolve_reference_value (frame_ctx_p->lex_env_p, \
        -:  954:                                                  name_p); \
        -:  955:        \
        -:  956:        if (ECMA_IS_VALUE_ERROR (result)) \
        -:  957:        { \
        -:  958:          goto error; \
        -:  959:        } \
        -:  960:        (target_value) = result; \
        -:  961:      } \
        -:  962:    } \
        -:  963:    else if (literal_index < const_literal_end) \
        -:  964:    { \
        -:  965:      (target_value) = ecma_fast_copy_value (literal_start_p[literal_index]); \
        -:  966:    } \
        -:  967:    else \
        -:  968:    { \
        -:  969:      /* Object construction. */ \
        -:  970:      (target_value) = vm_construct_literal_object (frame_ctx_p, \
        -:  971:                                                    literal_start_p[literal_index]); \
        -:  972:    } \
        -:  973:  } \
        -:  974:  while (0)
        -:  975:
        -:  976:/**
        -:  977: * Store the original value for post increase/decrease operators
        -:  978: *
        -:  979: * @param value original value
        -:  980: */
        -:  981:#define POST_INCREASE_DECREASE_PUT_RESULT(value) \
        -:  982:  if (opcode_data & VM_OC_PUT_STACK) \
        -:  983:  { \
        -:  984:    if (opcode_flags & VM_OC_IDENT_INCR_DECR_OPERATOR_FLAG) \
        -:  985:    { \
        -:  986:      JERRY_ASSERT (opcode == CBC_POST_INCR_IDENT_PUSH_RESULT \
        -:  987:                    || opcode == CBC_POST_DECR_IDENT_PUSH_RESULT); \
        -:  988:      *stack_top_p++ = (value); \
        -:  989:    } \
        -:  990:    else \
        -:  991:    { \
        -:  992:      /* The parser ensures there is enough space for the \
        -:  993:       * extra value on the stack. See js-parser-expr.c. */ \
        -:  994:      JERRY_ASSERT (opcode == CBC_POST_INCR_PUSH_RESULT \
        -:  995:                    || opcode == CBC_POST_DECR_PUSH_RESULT); \
        -:  996:      stack_top_p++; \
        -:  997:      stack_top_p[-1] = stack_top_p[-2]; \
        -:  998:      stack_top_p[-2] = stack_top_p[-3]; \
        -:  999:      stack_top_p[-3] = (value); \
        -: 1000:    } \
        -: 1001:    opcode_data &= (uint32_t) ~VM_OC_PUT_STACK; \
        -: 1002:  } \
        -: 1003:  else \
        -: 1004:  { \
        -: 1005:    JERRY_ASSERT (opcode_data & VM_OC_PUT_BLOCK); \
        -: 1006:    ecma_free_value (frame_ctx_p->block_result); \
        -: 1007:    frame_ctx_p->block_result = (value); \
        -: 1008:    opcode_data &= (uint32_t) ~VM_OC_PUT_BLOCK; \
        -: 1009:  }
        -: 1010:
        -: 1011:/**
        -: 1012: * Get the end of the existing topmost context
        -: 1013: */
        -: 1014:#define VM_LAST_CONTEXT_END() \
        -: 1015:  (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth)
        -: 1016:
        -: 1017:/**
        -: 1018: * Run generic byte code.
        -: 1019: *
        -: 1020: * @return ecma value
        -: 1021: */
        -: 1022:static ecma_value_t JERRY_ATTR_NOINLINE
      102: 1023:vm_loop (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 1024:{
      102: 1025:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
      102: 1026:  const uint8_t *byte_code_p = frame_ctx_p->byte_code_p;
      102: 1027:  ecma_value_t *literal_start_p = frame_ctx_p->literal_start_p;
        -: 1028:
      102: 1029:  ecma_value_t *stack_top_p;
        -: 1030:  uint16_t encoding_limit;
        -: 1031:  uint16_t encoding_delta;
        -: 1032:  uint16_t register_end;
        -: 1033:  uint16_t ident_end;
        -: 1034:  uint16_t const_literal_end;
      102: 1035:  int32_t branch_offset = 0;
      102: 1036:  uint8_t branch_offset_length = 0;
      102: 1037:  ecma_value_t left_value;
        -: 1038:  ecma_value_t right_value;
      102: 1039:  ecma_value_t result = ECMA_VALUE_EMPTY;
      102: 1040:  bool is_strict = ((bytecode_header_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE) != 0);
        -: 1041:
        -: 1042:  /* Prepare for byte code execution. */
      102: 1043:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 1044:  {
      102: 1045:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
      102: 1046:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 1047:  }
        -: 1048:  else
        -: 1049:  {
    #####: 1050:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1051:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1052:  }
        -: 1053:
      102: 1054:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1055:  {
    #####: 1056:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) (bytecode_header_p);
    #####: 1057:    register_end = args_p->register_end;
    #####: 1058:    ident_end = args_p->ident_end;
    #####: 1059:    const_literal_end = args_p->const_literal_end;
        -: 1060:  }
        -: 1061:  else
        -: 1062:  {
      102: 1063:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) (bytecode_header_p);
      102: 1064:    register_end = args_p->register_end;
      102: 1065:    ident_end = args_p->ident_end;
      102: 1066:    const_literal_end = args_p->const_literal_end;
        -: 1067:  }
        -: 1068:
      102: 1069:  stack_top_p = frame_ctx_p->stack_top_p;
        -: 1070:
        -: 1071:  /* Outer loop for exception handling. */
    #####: 1072:  while (true)
        -: 1073:  {
        -: 1074:    /* Internal loop for byte code execution. */
        -: 1075:    while (true)
      419: 1076:    {
      521: 1077:      const uint8_t *byte_code_start_p = byte_code_p;
      521: 1078:      uint8_t opcode = *byte_code_p++;
      521: 1079:      uint32_t opcode_data = opcode;
        -: 1080:
      521: 1081:      if (opcode == CBC_EXT_OPCODE)
        -: 1082:      {
    #####: 1083:        opcode = *byte_code_p++;
    #####: 1084:        opcode_data = (uint32_t) ((CBC_END + 1) + opcode);
        -: 1085:      }
        -: 1086:
      521: 1087:      opcode_data = vm_decode_table[opcode_data];
        -: 1088:
      521: 1089:      left_value = ECMA_VALUE_UNDEFINED;
      521: 1090:      right_value = ECMA_VALUE_UNDEFINED;
        -: 1091:
      521: 1092:      uint32_t operands = VM_OC_GET_ARGS_INDEX (opcode_data);
        -: 1093:
      521: 1094:      if (operands >= VM_OC_GET_LITERAL)
        -: 1095:      {
        -: 1096:        uint16_t literal_index;
      404: 1097:        READ_LITERAL_INDEX (literal_index);
      404: 1098:        READ_LITERAL (literal_index, left_value);
        -: 1099:
      404: 1100:        if (operands != VM_OC_GET_LITERAL)
        -: 1101:        {
      304: 1102:          switch (operands)
        -: 1103:          {
      304: 1104:            case VM_OC_GET_LITERAL_LITERAL:
        -: 1105:            {
        -: 1106:              uint16_t second_literal_index;
      304: 1107:              READ_LITERAL_INDEX (second_literal_index);
      304: 1108:              READ_LITERAL (second_literal_index, right_value);
      304: 1109:              break;
        -: 1110:            }
    #####: 1111:            case VM_OC_GET_STACK_LITERAL:
        -: 1112:            {
    #####: 1113:              JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1114:              right_value = left_value;
    #####: 1115:              left_value = *(--stack_top_p);
    #####: 1116:              break;
        -: 1117:            }
    #####: 1118:            default:
        -: 1119:            {
    #####: 1120:              JERRY_ASSERT (operands == VM_OC_GET_THIS_LITERAL);
        -: 1121:
    #####: 1122:              right_value = left_value;
    #####: 1123:              left_value = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1124:              break;
        -: 1125:            }
        -: 1126:          }
      100: 1127:        }
        -: 1128:      }
      117: 1129:      else if (operands >= VM_OC_GET_STACK)
        -: 1130:      {
        4: 1131:        JERRY_ASSERT (operands == VM_OC_GET_STACK
        -: 1132:                      || operands == VM_OC_GET_STACK_STACK);
        -: 1133:
        4: 1134:        JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        4: 1135:        left_value = *(--stack_top_p);
        -: 1136:
        4: 1137:        if (operands == VM_OC_GET_STACK_STACK)
        -: 1138:        {
    #####: 1139:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1140:          right_value = left_value;
    #####: 1141:          left_value = *(--stack_top_p);
        -: 1142:        }
        -: 1143:      }
      113: 1144:      else if (operands == VM_OC_GET_BRANCH)
        -: 1145:      {
        1: 1146:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        1: 1147:        JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 1148:
        1: 1149:        branch_offset = *(byte_code_p++);
        -: 1150:
        1: 1151:        if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 1152:        {
    #####: 1153:          branch_offset <<= 8;
    #####: 1154:          branch_offset |= *(byte_code_p++);
        -: 1155:
    #####: 1156:          if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 1157:          {
    #####: 1158:            branch_offset <<= 8;
    #####: 1159:            branch_offset |= *(byte_code_p++);
        -: 1160:          }
        -: 1161:        }
        -: 1162:
        1: 1163:        if (opcode_data & VM_OC_BACKWARD_BRANCH)
        -: 1164:        {
        -: 1165:#if JERRY_VM_EXEC_STOP
    #####: 1166:          if (JERRY_CONTEXT (vm_exec_stop_cb) != NULL
    #####: 1167:              && --JERRY_CONTEXT (vm_exec_stop_counter) == 0)
        -: 1168:          {
    #####: 1169:            result = JERRY_CONTEXT (vm_exec_stop_cb) (JERRY_CONTEXT (vm_exec_stop_user_p));
        -: 1170:
    #####: 1171:            if (ecma_is_value_undefined (result))
        -: 1172:            {
    #####: 1173:              JERRY_CONTEXT (vm_exec_stop_counter) = JERRY_CONTEXT (vm_exec_stop_frequency);
        -: 1174:            }
        -: 1175:            else
        -: 1176:            {
    #####: 1177:              JERRY_CONTEXT (vm_exec_stop_counter) = 1;
        -: 1178:
    #####: 1179:              if (ecma_is_value_error_reference (result))
        -: 1180:              {
    #####: 1181:                ecma_raise_error_from_error_reference (result);
        -: 1182:              }
        -: 1183:              else
        -: 1184:              {
    #####: 1185:                jcontext_raise_exception (result);
        -: 1186:              }
        -: 1187:
        -: 1188:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 1189:              jcontext_set_abort_flag (true);
    #####: 1190:              result = ECMA_VALUE_ERROR;
    #####: 1191:              goto error;
        -: 1192:            }
        -: 1193:          }
        -: 1194:#endif /* JERRY_VM_EXEC_STOP */
        -: 1195:
    #####: 1196:          branch_offset = -branch_offset;
        -: 1197:        }
        -: 1198:      }
        -: 1199:
      521: 1200:      switch (VM_OC_GROUP_GET_INDEX (opcode_data))
        -: 1201:      {
    #####: 1202:        case VM_OC_POP:
        -: 1203:        {
    #####: 1204:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
    #####: 1205:          ecma_free_value (*(--stack_top_p));
    #####: 1206:          continue;
        -: 1207:        }
    #####: 1208:        case VM_OC_POP_BLOCK:
        -: 1209:        {
    #####: 1210:          ecma_fast_free_value (frame_ctx_p->block_result);
    #####: 1211:          frame_ctx_p->block_result = *(--stack_top_p);
    #####: 1212:          continue;
        -: 1213:        }
    #####: 1214:        case VM_OC_PUSH:
        -: 1215:        {
    #####: 1216:          *stack_top_p++ = left_value;
    #####: 1217:          continue;
        -: 1218:        }
    #####: 1219:        case VM_OC_PUSH_TWO:
        -: 1220:        {
    #####: 1221:          *stack_top_p++ = left_value;
    #####: 1222:          *stack_top_p++ = right_value;
    #####: 1223:          continue;
        -: 1224:        }
        1: 1225:        case VM_OC_PUSH_THREE:
        -: 1226:        {
        -: 1227:          uint16_t literal_index;
        -: 1228:
        1: 1229:          *stack_top_p++ = left_value;
        1: 1230:          left_value = ECMA_VALUE_UNDEFINED;
        -: 1231:
        1: 1232:          READ_LITERAL_INDEX (literal_index);
        1: 1233:          READ_LITERAL (literal_index, left_value);
        -: 1234:
        1: 1235:          *stack_top_p++ = right_value;
        1: 1236:          *stack_top_p++ = left_value;
        1: 1237:          continue;
        -: 1238:        }
    #####: 1239:        case VM_OC_PUSH_UNDEFINED:
        -: 1240:        {
    #####: 1241:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 1242:          continue;
        -: 1243:        }
    #####: 1244:        case VM_OC_PUSH_TRUE:
        -: 1245:        {
    #####: 1246:          *stack_top_p++ = ECMA_VALUE_TRUE;
    #####: 1247:          continue;
        -: 1248:        }
    #####: 1249:        case VM_OC_PUSH_FALSE:
        -: 1250:        {
    #####: 1251:          *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 1252:          continue;
        -: 1253:        }
    #####: 1254:        case VM_OC_PUSH_NULL:
        -: 1255:        {
    #####: 1256:          *stack_top_p++ = ECMA_VALUE_NULL;
    #####: 1257:          continue;
        -: 1258:        }
    #####: 1259:        case VM_OC_PUSH_THIS:
        -: 1260:        {
    #####: 1261:          *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1262:          continue;
        -: 1263:        }
        2: 1264:        case VM_OC_PUSH_0:
        -: 1265:        {
        2: 1266:          *stack_top_p++ = ecma_make_integer_value (0);
        2: 1267:          continue;
        -: 1268:        }
        1: 1269:        case VM_OC_PUSH_POS_BYTE:
        -: 1270:        {
        1: 1271:          ecma_integer_value_t number = *byte_code_p++;
        1: 1272:          *stack_top_p++ = ecma_make_integer_value (number + 1);
        1: 1273:          continue;
        -: 1274:        }
    #####: 1275:        case VM_OC_PUSH_NEG_BYTE:
        -: 1276:        {
    #####: 1277:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1278:          *stack_top_p++ = ecma_make_integer_value (-(number + 1));
    #####: 1279:          continue;
        -: 1280:        }
    #####: 1281:        case VM_OC_PUSH_LIT_0:
        -: 1282:        {
    #####: 1283:          stack_top_p[0] = left_value;
    #####: 1284:          stack_top_p[1] = ecma_make_integer_value (0);
    #####: 1285:          stack_top_p += 2;
    #####: 1286:          continue;
        -: 1287:        }
    #####: 1288:        case VM_OC_PUSH_LIT_POS_BYTE:
        -: 1289:        {
    #####: 1290:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1291:          stack_top_p[0] = left_value;
    #####: 1292:          stack_top_p[1] = ecma_make_integer_value (number + 1);
    #####: 1293:          stack_top_p += 2;
    #####: 1294:          continue;
        -: 1295:        }
    #####: 1296:        case VM_OC_PUSH_LIT_NEG_BYTE:
        -: 1297:        {
    #####: 1298:          ecma_integer_value_t number = *byte_code_p++;
    #####: 1299:          stack_top_p[0] = left_value;
    #####: 1300:          stack_top_p[1] = ecma_make_integer_value (-(number + 1));
    #####: 1301:          stack_top_p += 2;
    #####: 1302:          continue;
        -: 1303:        }
        1: 1304:        case VM_OC_PUSH_OBJECT:
        -: 1305:        {
        1: 1306:          ecma_object_t *obj_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE),
        -: 1307:                                                     0,
        -: 1308:                                                     ECMA_OBJECT_TYPE_GENERAL);
        -: 1309:
        1: 1310:          *stack_top_p++ = ecma_make_object_value (obj_p);
        1: 1311:          continue;
        -: 1312:        }
    #####: 1313:        case VM_OC_PUSH_NAMED_FUNC_EXPR:
        -: 1314:        {
    #####: 1315:          ecma_object_t *func_p = ecma_get_object_from_value (left_value);
        -: 1316:
    #####: 1317:          JERRY_ASSERT (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION);
        -: 1318:
    #####: 1319:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
        -: 1320:
    #####: 1321:          JERRY_ASSERT (frame_ctx_p->lex_env_p ==
        -: 1322:                        ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_func_p->u.function.scope_cp));
        -: 1323:
    #####: 1324:          ecma_object_t *name_lex_env = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1325:
    #####: 1326:          ecma_op_create_immutable_binding (name_lex_env, ecma_get_string_from_value (right_value), left_value);
        -: 1327:
    #####: 1328:          ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp, name_lex_env, 0);
        -: 1329:
    #####: 1330:          ecma_free_value (right_value);
    #####: 1331:          ecma_deref_object (name_lex_env);
    #####: 1332:          *stack_top_p++ = left_value;
    #####: 1333:          continue;
        -: 1334:        }
    #####: 1335:        case VM_OC_CREATE_BINDING:
        -: 1336:        {
        -: 1337:#if !JERRY_ESNEXT
        -: 1338:          JERRY_ASSERT (opcode == CBC_CREATE_VAR);
        -: 1339:#endif /* !JERRY_ESNEXT */
        -: 1340:
        -: 1341:          uint32_t literal_index;
        -: 1342:
    #####: 1343:          READ_LITERAL_INDEX (literal_index);
        -: 1344:
    #####: 1345:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1346:
    #####: 1347:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1348:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1349:
    #####: 1350:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1351:
        -: 1352:#if JERRY_ESNEXT
    #####: 1353:          if (opcode == CBC_CREATE_LET)
        -: 1354:          {
    #####: 1355:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1356:          }
    #####: 1357:          else if (opcode == CBC_CREATE_CONST)
        -: 1358:          {
    #####: 1359:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1360:          }
        -: 1361:
        -: 1362:          ecma_property_value_t *property_value_p;
    #####: 1363:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1364:
    #####: 1365:          if (opcode != CBC_CREATE_VAR)
        -: 1366:          {
    #####: 1367:            property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 1368:          }
        -: 1369:#else /* !JERRY_ESNEXT */
    #####: 1370:          ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
        -: 1371:#endif /* JERRY_ESNEXT */
        -: 1372:
    #####: 1373:          continue;
        -: 1374:        }
        3: 1375:        case VM_OC_VAR_EVAL:
        -: 1376:        {
        -: 1377:          uint32_t literal_index;
        3: 1378:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1379:
        3: 1380:          if (opcode == CBC_CREATE_VAR_FUNC_EVAL)
        -: 1381:          {
        -: 1382:            uint32_t value_index;
    #####: 1383:            READ_LITERAL_INDEX (value_index);
    #####: 1384:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1385:
    #####: 1386:            lit_value = vm_construct_literal_object (frame_ctx_p,
    #####: 1387:                                                     literal_start_p[value_index]);
        -: 1388:          }
        -: 1389:
        3: 1390:          READ_LITERAL_INDEX (literal_index);
        3: 1391:          JERRY_ASSERT (literal_index >= register_end);
        -: 1392:
        3: 1393:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        3: 1394:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1395:
        6: 1396:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1397:          {
        -: 1398:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
    #####: 1399:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1400:            {
    #####: 1401:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1402:
    #####: 1403:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1404:            }
        -: 1405:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1406:
    #####: 1407:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1408:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1409:          }
        -: 1410:
        -: 1411:#if JERRY_ESNEXT && !(defined JERRY_NDEBUG)
        3: 1412:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1413:          {
    #####: 1414:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1415:
    #####: 1416:            JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1417:          }
        -: 1418:#endif /* JERRY_ESNEXT && !JERRY_NDEBUG */
        -: 1419:
        -: 1420:          /* 'Variable declaration' */
        3: 1421:          result = ecma_op_has_binding (lex_env_p, name_p);
        -: 1422:
        -: 1423:#if JERRY_BUILTIN_PROXY
        3: 1424:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1425:          {
    #####: 1426:            goto error;
        -: 1427:          }
        -: 1428:#endif /* JERRY_BUILTIN_PROXY */
        -: 1429:
        3: 1430:          ecma_property_t *prop_p = NULL;
        -: 1431:
        3: 1432:          if (ecma_is_value_false (result))
        -: 1433:          {
        3: 1434:            bool is_configurable = (frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL) != 0;
        3: 1435:            prop_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_configurable);
        -: 1436:
        3: 1437:            if (JERRY_UNLIKELY (prop_p == ECMA_PROPERTY_POINTER_ERROR))
        -: 1438:            {
    #####: 1439:              result = ECMA_VALUE_ERROR;
    #####: 1440:              goto error;
        -: 1441:            }
        -: 1442:          }
        -: 1443:
        3: 1444:          if (lit_value != ECMA_VALUE_UNDEFINED)
        -: 1445:          {
    #####: 1446:            JERRY_ASSERT (ecma_is_value_object (lit_value));
        -: 1447:
    #####: 1448:            if (prop_p != NULL)
        -: 1449:            {
    #####: 1450:              JERRY_ASSERT (ecma_is_value_undefined (ECMA_PROPERTY_VALUE_PTR (prop_p)->value));
    #####: 1451:              JERRY_ASSERT (ecma_is_property_writable (*prop_p));
    #####: 1452:              ECMA_PROPERTY_VALUE_PTR (prop_p)->value = lit_value;
    #####: 1453:              ecma_free_object (lit_value);
        -: 1454:            }
        -: 1455:            else
        -: 1456:            {
    #####: 1457:              result = ecma_op_put_value_lex_env_base (lex_env_p, name_p, is_strict, lit_value);
    #####: 1458:              ecma_free_object (lit_value);
        -: 1459:
    #####: 1460:              if (ECMA_IS_VALUE_ERROR (result))
        -: 1461:              {
    #####: 1462:                goto error;
        -: 1463:              }
        -: 1464:            }
        -: 1465:          }
        3: 1466:          continue;
        -: 1467:        }
        -: 1468:#if JERRY_ESNEXT
    #####: 1469:        case VM_OC_EXT_VAR_EVAL:
        -: 1470:        {
        -: 1471:          uint32_t literal_index;
    #####: 1472:          ecma_value_t lit_value = ECMA_VALUE_UNDEFINED;
        -: 1473:
    #####: 1474:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1475:
    #####: 1476:          if (opcode == CBC_EXT_CREATE_VAR_FUNC_EVAL)
        -: 1477:          {
        -: 1478:            uint32_t value_index;
    #####: 1479:            READ_LITERAL_INDEX (value_index);
    #####: 1480:            JERRY_ASSERT (value_index >= const_literal_end);
        -: 1481:
    #####: 1482:            lit_value = vm_construct_literal_object (frame_ctx_p,
    #####: 1483:                                                     literal_start_p[value_index]);
        -: 1484:          }
        -: 1485:
    #####: 1486:          READ_LITERAL_INDEX (literal_index);
    #####: 1487:          JERRY_ASSERT (literal_index >= register_end);
        -: 1488:
    #####: 1489:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1490:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1491:          ecma_object_t *prev_lex_env_p = NULL;
        -: 1492:
    #####: 1493:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1494:          {
        -: 1495:#if !(defined JERRY_NDEBUG)
    #####: 1496:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1497:            {
    #####: 1498:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1499:
    #####: 1500:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1501:            }
        -: 1502:#endif /* !JERRY_NDEBUG */
        -: 1503:
    #####: 1504:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1505:            prev_lex_env_p = lex_env_p;
    #####: 1506:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1507:          }
        -: 1508:
    #####: 1509:          JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1510:          JERRY_ASSERT (prev_lex_env_p != NULL
        -: 1511:                        && ecma_get_lex_env_type (prev_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1512:
    #####: 1513:          ecma_property_t *property_p = ecma_find_named_property (prev_lex_env_p, name_p);
        -: 1514:          ecma_property_value_t *property_value_p;
        -: 1515:
    #####: 1516:          if (property_p == NULL)
        -: 1517:          {
    #####: 1518:            property_value_p = ecma_create_named_data_property (prev_lex_env_p,
        -: 1519:                                                                name_p,
        -: 1520:                                                                ECMA_PROPERTY_CONFIGURABLE_WRITABLE,
        -: 1521:                                                                NULL);
        -: 1522:
    #####: 1523:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1524:            {
    #####: 1525:              continue;
        -: 1526:            }
        -: 1527:          }
        -: 1528:          else
        -: 1529:          {
    #####: 1530:            if (lit_value == ECMA_VALUE_UNDEFINED)
        -: 1531:            {
    #####: 1532:              continue;
        -: 1533:            }
        -: 1534:
    #####: 1535:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1536:            ecma_free_value_if_not_object (property_value_p->value);
        -: 1537:          }
        -: 1538:
    #####: 1539:          property_value_p->value = lit_value;
    #####: 1540:          ecma_deref_object (ecma_get_object_from_value (lit_value));
    #####: 1541:          continue;
        -: 1542:        }
        -: 1543:#endif /* JERRY_ESNEXT */
    #####: 1544:        case VM_OC_CREATE_ARGUMENTS:
        -: 1545:        {
        -: 1546:          uint32_t literal_index;
    #####: 1547:          READ_LITERAL_INDEX (literal_index);
        -: 1548:
    #####: 1549:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 1550:
    #####: 1551:          result = ecma_op_create_arguments_object ((vm_frame_ctx_shared_args_t *) (frame_ctx_p->shared_p),
        -: 1552:                                                    frame_ctx_p->lex_env_p);
        -: 1553:
    #####: 1554:          if (literal_index < register_end)
        -: 1555:          {
    #####: 1556:            JERRY_ASSERT (VM_GET_REGISTER (frame_ctx_p, literal_index) == ECMA_VALUE_UNDEFINED);
    #####: 1557:            VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
    #####: 1558:            continue;
        -: 1559:          }
        -: 1560:
    #####: 1561:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1562:
    #####: 1563:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1564:
    #####: 1565:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1566:          ecma_property_value_t *property_value_p;
        -: 1567:
    #####: 1568:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p, name_p, prop_attributes, NULL);
    #####: 1569:          property_value_p->value = result;
        -: 1570:
    #####: 1571:          ecma_deref_object (ecma_get_object_from_value (result));
    #####: 1572:          continue;
        -: 1573:        }
        -: 1574:#if JERRY_SNAPSHOT_EXEC
    #####: 1575:        case VM_OC_SET_BYTECODE_PTR:
        -: 1576:        {
    #####: 1577:          memcpy (&byte_code_p, byte_code_p++, sizeof (uintptr_t));
    #####: 1578:          frame_ctx_p->byte_code_start_p = byte_code_p;
    #####: 1579:          continue;
        -: 1580:        }
        -: 1581:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 1582:        case VM_OC_INIT_ARG_OR_FUNC:
        -: 1583:        {
        -: 1584:          uint32_t literal_index, value_index;
        -: 1585:          ecma_value_t lit_value;
    #####: 1586:          bool release = false;
        -: 1587:
    #####: 1588:          READ_LITERAL_INDEX (value_index);
        -: 1589:
    #####: 1590:          if (value_index < register_end)
        -: 1591:          {
        -: 1592:            /* Take (not copy) the reference. */
    #####: 1593:            lit_value = ecma_copy_value_if_not_object (VM_GET_REGISTER (frame_ctx_p, value_index));
        -: 1594:          }
        -: 1595:          else
        -: 1596:          {
    #####: 1597:            lit_value = vm_construct_literal_object (frame_ctx_p,
    #####: 1598:                                                     literal_start_p[value_index]);
    #####: 1599:            release = true;
        -: 1600:          }
        -: 1601:
    #####: 1602:          READ_LITERAL_INDEX (literal_index);
        -: 1603:
    #####: 1604:          JERRY_ASSERT (value_index != literal_index);
    #####: 1605:          JERRY_ASSERT (value_index >= register_end || literal_index >= register_end);
        -: 1606:
    #####: 1607:          if (literal_index < register_end)
        -: 1608:          {
    #####: 1609:            ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 1610:            JERRY_ASSERT (release);
    #####: 1611:            VM_GET_REGISTER (frame_ctx_p, literal_index) = lit_value;
    #####: 1612:            continue;
        -: 1613:          }
        -: 1614:
    #####: 1615:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1616:
    #####: 1617:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1618:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1619:
        -: 1620:          ecma_property_value_t *property_value_p;
    #####: 1621:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,
        -: 1622:                                                              name_p,
        -: 1623:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1624:                                                              NULL);
        -: 1625:
    #####: 1626:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 1627:          property_value_p->value = lit_value;
        -: 1628:
    #####: 1629:          if (release)
        -: 1630:          {
    #####: 1631:            ecma_deref_object (ecma_get_object_from_value (lit_value));
        -: 1632:          }
    #####: 1633:          continue;
        -: 1634:        }
        -: 1635:#if JERRY_ESNEXT
        3: 1636:        case VM_OC_CHECK_VAR:
        -: 1637:        {
        3: 1638:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1639:                        == CBC_FUNCTION_SCRIPT);
        -: 1640:
        -: 1641:          uint32_t literal_index;
        3: 1642:          READ_LITERAL_INDEX (literal_index);
        -: 1643:
        3: 1644:          if ((frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK) == 0)
        -: 1645:          {
        3: 1646:            continue;
        -: 1647:          }
        -: 1648:
    #####: 1649:          ecma_string_t *const literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1650:          ecma_property_t *const binding_p = ecma_find_named_property (frame_ctx_p->lex_env_p, literal_name_p);
        -: 1651:
    #####: 1652:          if (binding_p != NULL)
        -: 1653:          {
    #####: 1654:            result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
    #####: 1655:            goto error;
        -: 1656:          }
        -: 1657:
    #####: 1658:          continue;
        -: 1659:        }
    #####: 1660:        case VM_OC_CHECK_LET:
        -: 1661:        {
    #####: 1662:          JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -: 1663:                        == CBC_FUNCTION_SCRIPT);
        -: 1664:
        -: 1665:          uint32_t literal_index;
    #####: 1666:          READ_LITERAL_INDEX (literal_index);
        -: 1667:
    #####: 1668:          ecma_string_t *literal_name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1669:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1670:
    #####: 1671:          if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1672:          {
    #####: 1673:            result = opfunc_lexical_scope_has_restricted_binding (frame_ctx_p, literal_name_p);
        -: 1674:
    #####: 1675:            if (!ecma_is_value_false (result))
        -: 1676:            {
    #####: 1677:              if (ecma_is_value_true (result))
        -: 1678:              {
    #####: 1679:                result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
        -: 1680:              }
        -: 1681:
    #####: 1682:              JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####: 1683:              goto error;
        -: 1684:            }
        -: 1685:
    #####: 1686:            continue;
        -: 1687:          }
        -: 1688:
    #####: 1689:          result = ecma_op_has_binding (lex_env_p, literal_name_p);
        -: 1690:
        -: 1691:#if JERRY_BUILTIN_PROXY
    #####: 1692:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1693:          {
    #####: 1694:            goto error;
        -: 1695:          }
        -: 1696:#endif /* JERRY_BUILTIN_PROXY */
        -: 1697:
    #####: 1698:          if (ecma_is_value_true (result))
        -: 1699:          {
    #####: 1700:            result = ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_local_variable_is_redeclared));
    #####: 1701:            goto error;
        -: 1702:          }
        -: 1703:
    #####: 1704:          continue;
        -: 1705:        }
    #####: 1706:        case VM_OC_ASSIGN_LET_CONST:
        -: 1707:        {
        -: 1708:          uint32_t literal_index;
    #####: 1709:          READ_LITERAL_INDEX (literal_index);
        -: 1710:
    #####: 1711:          JERRY_ASSERT (literal_index >= register_end);
    #####: 1712:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE
        -: 1713:                        || (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
        -: 1714:                            && (frame_ctx_p->lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)));
        -: 1715:
    #####: 1716:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1717:          ecma_property_t *property_p = ecma_find_named_property (frame_ctx_p->lex_env_p, name_p);
        -: 1718:
    #####: 1719:          JERRY_ASSERT (property_p != NULL
        -: 1720:                        && ECMA_PROPERTY_IS_RAW_DATA (*property_p)
        -: 1721:                        && (*property_p & ECMA_PROPERTY_FLAG_DATA));
    #####: 1722:          JERRY_ASSERT (ECMA_PROPERTY_VALUE_PTR (property_p)->value == ECMA_VALUE_UNINITIALIZED);
        -: 1723:
    #####: 1724:          ECMA_PROPERTY_VALUE_PTR (property_p)->value = left_value;
        -: 1725:
    #####: 1726:          if (ecma_is_value_object (left_value))
        -: 1727:          {
    #####: 1728:            ecma_deref_object (ecma_get_object_from_value (left_value));
        -: 1729:          }
    #####: 1730:          continue;
        -: 1731:        }
    #####: 1732:        case VM_OC_INIT_BINDING:
        -: 1733:        {
        -: 1734:          uint32_t literal_index;
        -: 1735:
    #####: 1736:          READ_LITERAL_INDEX (literal_index);
        -: 1737:
    #####: 1738:          JERRY_ASSERT (literal_index >= register_end);
        -: 1739:
    #####: 1740:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 1741:
    #####: 1742:          JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1743:          JERRY_ASSERT (ecma_find_named_property (frame_ctx_p->lex_env_p, name_p) == NULL);
        -: 1744:
    #####: 1745:          uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 1746:
    #####: 1747:          if (opcode == CBC_INIT_LET)
        -: 1748:          {
    #####: 1749:            prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 1750:          }
    #####: 1751:          else if (opcode == CBC_INIT_CONST)
        -: 1752:          {
    #####: 1753:            prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 1754:          }
        -: 1755:
        -: 1756:          ecma_property_value_t *property_value_p;
    #####: 1757:          property_value_p = ecma_create_named_data_property (frame_ctx_p->lex_env_p,
        -: 1758:                                                              name_p,
        -: 1759:                                                              prop_attributes,
        -: 1760:                                                              NULL);
        -: 1761:
    #####: 1762:          JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
        -: 1763:
    #####: 1764:          ecma_value_t value = *(--stack_top_p);
        -: 1765:
    #####: 1766:          property_value_p->value = value;
    #####: 1767:          ecma_deref_if_object (value);
    #####: 1768:          continue;
        -: 1769:        }
    #####: 1770:        case VM_OC_THROW_CONST_ERROR:
        -: 1771:        {
    #####: 1772:          result = ecma_raise_type_error (ECMA_ERR_MSG ("Constant bindings cannot be reassigned"));
    #####: 1773:          goto error;
        -: 1774:        }
    #####: 1775:        case VM_OC_COPY_TO_GLOBAL:
        -: 1776:        {
        -: 1777:          uint32_t literal_index;
    #####: 1778:          READ_LITERAL_INDEX (literal_index);
        -: 1779:
    #####: 1780:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1781:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        -: 1782:
    #####: 1783:          while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1784:          {
        -: 1785:#ifndef JERRY_NDEBUG
    #####: 1786:            if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1787:            {
    #####: 1788:              ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1789:
    #####: 1790:              JERRY_ASSERT (property_p == NULL || !(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1791:            }
        -: 1792:#endif /* !JERRY_NDEBUG */
        -: 1793:
    #####: 1794:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 1795:            lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1796:          }
        -: 1797:
    #####: 1798:          if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1799:          {
    #####: 1800:            ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1801:            ecma_property_value_t *prop_value_p;
        -: 1802:
    #####: 1803:            if (property_p == NULL)
        -: 1804:            {
    #####: 1805:              prop_value_p = ecma_create_named_data_property (lex_env_p,
        -: 1806:                                                              name_p,
        -: 1807:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1808:                                                              NULL);
        -: 1809:            }
        -: 1810:            else
        -: 1811:            {
        -: 1812:#ifndef JERRY_NDEBUG
    #####: 1813:              JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_ENUMERABLE));
        -: 1814:#endif /* !JERRY_NDEBUG */
    #####: 1815:              prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -: 1816:            }
        -: 1817:
    #####: 1818:            ecma_named_data_property_assign_value (lex_env_p, prop_value_p, left_value);
        -: 1819:          }
        -: 1820:          else
        -: 1821:          {
    #####: 1822:            result = ecma_op_set_mutable_binding (lex_env_p, name_p, left_value, is_strict);
        -: 1823:
    #####: 1824:            if (ECMA_IS_VALUE_ERROR (result))
        -: 1825:            {
    #####: 1826:              goto error;
        -: 1827:            }
        -: 1828:          }
        -: 1829:
    #####: 1830:          goto free_left_value;
        -: 1831:        }
    #####: 1832:        case VM_OC_COPY_FROM_ARG:
        -: 1833:        {
        -: 1834:          uint32_t literal_index;
    #####: 1835:          READ_LITERAL_INDEX (literal_index);
    #####: 1836:          JERRY_ASSERT (literal_index >= register_end);
        -: 1837:
    #####: 1838:          ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####: 1839:          ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1840:          ecma_object_t *arg_lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1841:
    #####: 1842:          JERRY_ASSERT ((lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1843:                        && ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
    #####: 1844:          JERRY_ASSERT (arg_lex_env_p != NULL
        -: 1845:                        && !(arg_lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -: 1846:                        && ecma_get_lex_env_type (arg_lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1847:
        -: 1848:          ecma_property_value_t *property_value_p;
    #####: 1849:          property_value_p = ecma_create_named_data_property (lex_env_p,
        -: 1850:                                                              name_p,
        -: 1851:                                                              ECMA_PROPERTY_FLAG_WRITABLE,
        -: 1852:                                                              NULL);
        -: 1853:
    #####: 1854:          ecma_property_t *property_p = ecma_find_named_property (arg_lex_env_p, name_p);
    #####: 1855:          JERRY_ASSERT (property_p != NULL);
        -: 1856:
    #####: 1857:          ecma_property_value_t *arg_prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1858:          property_value_p->value = ecma_copy_value_if_not_object (arg_prop_value_p->value);
    #####: 1859:          continue;
        -: 1860:        }
    #####: 1861:        case VM_OC_CLONE_CONTEXT:
        -: 1862:        {
    #####: 1863:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE);
        -: 1864:
    #####: 1865:          bool copy_values = (byte_code_start_p[1] == CBC_EXT_CLONE_FULL_CONTEXT);
    #####: 1866:          frame_ctx_p->lex_env_p = ecma_clone_decl_lexical_environment (frame_ctx_p->lex_env_p, copy_values);
    #####: 1867:          continue;
        -: 1868:        }
    #####: 1869:        case VM_OC_SET__PROTO__:
        -: 1870:        {
    #####: 1871:          result = ecma_builtin_object_object_set_proto (stack_top_p[-1], left_value);
    #####: 1872:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1873:          {
    #####: 1874:            goto error;
        -: 1875:          }
    #####: 1876:          goto free_left_value;
        -: 1877:        }
    #####: 1878:        case VM_OC_PUSH_STATIC_FIELD_FUNC:
        -: 1879:        {
    #####: 1880:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1881:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_FIELD_FUNC
        -: 1882:                            || byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC));
        -: 1883:
    #####: 1884:          bool push_computed = (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC);
    #####: 1885:          ecma_value_t value = stack_top_p[-1];
        -: 1886:
    #####: 1887:          if (!push_computed)
        -: 1888:          {
    #####: 1889:            stack_top_p++;
        -: 1890:          }
        -: 1891:
    #####: 1892:          memmove (stack_top_p - 3, stack_top_p - 4, 3 * sizeof (ecma_value_t));
    #####: 1893:          stack_top_p[-4] = left_value;
        -: 1894:
    #####: 1895:          if (!push_computed)
        -: 1896:          {
    #####: 1897:            continue;
        -: 1898:          }
        -: 1899:
    #####: 1900:          left_value = value;
        -: 1901:          /* FALLTHRU */
        -: 1902:        }
    #####: 1903:        case VM_OC_ADD_COMPUTED_FIELD:
        -: 1904:        {
    #####: 1905:          JERRY_ASSERT (byte_code_start_p[0] == CBC_EXT_OPCODE
        -: 1906:                        && (byte_code_start_p[1] == CBC_EXT_PUSH_STATIC_COMPUTED_FIELD_FUNC
        -: 1907:                            || byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD
        -: 1908:                            || byte_code_start_p[1] == CBC_EXT_ADD_STATIC_COMPUTED_FIELD));
        -: 1909:
    #####: 1910:          int index = (byte_code_start_p[1] == CBC_EXT_ADD_COMPUTED_FIELD) ? -2 : -4;
    #####: 1911:          result = opfunc_add_computed_field (stack_top_p[index], left_value);
        -: 1912:
    #####: 1913:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1914:          {
    #####: 1915:            goto error;
        -: 1916:          }
    #####: 1917:          goto free_left_value;
        -: 1918:        }
    #####: 1919:        case VM_OC_COPY_DATA_PROPERTIES:
        -: 1920:        {
    #####: 1921:          left_value = *(--stack_top_p);
        -: 1922:
    #####: 1923:          if (ecma_is_value_undefined (left_value) || ecma_is_value_null (left_value))
        -: 1924:          {
    #####: 1925:            continue;
        -: 1926:          }
        -: 1927:
    #####: 1928:          result = opfunc_copy_data_properties (stack_top_p[-1], left_value, ECMA_VALUE_UNDEFINED);
        -: 1929:
    #####: 1930:          if (ECMA_IS_VALUE_ERROR (result))
        -: 1931:          {
    #####: 1932:            goto error;
        -: 1933:          }
        -: 1934:
    #####: 1935:          goto free_left_value;
        -: 1936:        }
    #####: 1937:        case VM_OC_SET_COMPUTED_PROPERTY:
        -: 1938:        {
        -: 1939:          /* Swap values. */
    #####: 1940:          left_value ^= right_value;
    #####: 1941:          right_value ^= left_value;
    #####: 1942:          left_value ^= right_value;
        -: 1943:          /* FALLTHRU */
        -: 1944:        }
        -: 1945:#endif /* JERRY_ESNEXT */
        1: 1946:        case VM_OC_SET_PROPERTY:
        -: 1947:        {
        -: 1948:          JERRY_STATIC_ASSERT (VM_OC_NON_STATIC_FLAG == VM_OC_BACKWARD_BRANCH,
        -: 1949:                               vm_oc_non_static_flag_must_be_equal_to_vm_oc_backward_branch);
        -: 1950:
        1: 1951:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1952:
        1: 1953:          ecma_string_t *prop_name_p = ecma_op_to_property_key (right_value);
        -: 1954:
        1: 1955:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1956:          {
    #####: 1957:            result = ECMA_VALUE_ERROR;
    #####: 1958:            goto error;
        -: 1959:          }
        -: 1960:
        -: 1961:#if JERRY_ESNEXT
        1: 1962:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1963:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1964:          {
    #####: 1965:            result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_is_non_configurable));
    #####: 1966:            goto error;
        -: 1967:          }
        -: 1968:
        1: 1969:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 1970:#else /* !JERRY_ESNEXT */
    #####: 1971:          const int index = -1;
        -: 1972:#endif /* JERRY_ESNEXT */
        -: 1973:
        1: 1974:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[index]);
        -: 1975:
        1: 1976:          opfunc_set_data_property (object_p, prop_name_p, left_value);
        1: 1977:          ecma_deref_ecma_string (prop_name_p);
        -: 1978:
        1: 1979:          goto free_both_values;
        -: 1980:        }
    #####: 1981:        case VM_OC_SET_GETTER:
        -: 1982:        case VM_OC_SET_SETTER:
        -: 1983:        {
    #####: 1984:          JERRY_ASSERT ((opcode_data >> VM_OC_NON_STATIC_SHIFT) <= 0x1);
        -: 1985:
    #####: 1986:          ecma_string_t *prop_name_p = ecma_op_to_property_key (left_value);
        -: 1987:
    #####: 1988:          if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1989:          {
    #####: 1990:            result = ECMA_VALUE_ERROR;
    #####: 1991:            goto error;
        -: 1992:          }
        -: 1993:
        -: 1994:#if JERRY_ESNEXT
    #####: 1995:          if (JERRY_UNLIKELY (ecma_compare_ecma_string_to_magic_id (prop_name_p, LIT_MAGIC_STRING_PROTOTYPE))
    #####: 1996:              && !(opcode_data & VM_OC_NON_STATIC_FLAG))
        -: 1997:          {
    #####: 1998:            result = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_class_is_non_configurable));
    #####: 1999:            goto error;
        -: 2000:          }
        -: 2001:
    #####: 2002:          const int index = (int) (opcode_data >> VM_OC_NON_STATIC_SHIFT) - 2;
        -: 2003:#else /* !JERRY_ESNEXT */
    #####: 2004:          const int index = -1;
        -: 2005:#endif /* JERRY_ESNEXT */
        -: 2006:
    #####: 2007:          opfunc_set_accessor (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_SET_GETTER,
    #####: 2008:                               stack_top_p[index],
        -: 2009:                               prop_name_p,
        -: 2010:                               right_value);
        -: 2011:
    #####: 2012:          ecma_deref_ecma_string (prop_name_p);
        -: 2013:
    #####: 2014:          goto free_both_values;
        -: 2015:        }
        1: 2016:        case VM_OC_PUSH_ARRAY:
        -: 2017:        {
        -: 2018:          /* Note: this operation cannot throw an exception */
        1: 2019:          *stack_top_p++ = ecma_make_object_value (ecma_op_new_array_object (0));
        1: 2020:          continue;
        -: 2021:        }
        -: 2022:#if JERRY_ESNEXT
    #####: 2023:        case VM_OC_LOCAL_EVAL:
        -: 2024:        {
    #####: 2025:          ECMA_CLEAR_LOCAL_PARSE_OPTS ();
    #####: 2026:          uint8_t parse_opts = *byte_code_p++;
    #####: 2027:          ECMA_SET_LOCAL_PARSE_OPTS (parse_opts);
    #####: 2028:          continue;
        -: 2029:        }
    #####: 2030:        case VM_OC_SUPER_CALL:
        -: 2031:        {
    #####: 2032:          uint8_t arguments_list_len = *byte_code_p++;
        -: 2033:
    #####: 2034:          if (opcode >= CBC_EXT_SPREAD_SUPER_CALL)
        -: 2035:          {
    #####: 2036:            stack_top_p -= arguments_list_len;
    #####: 2037:            ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2038:
    #####: 2039:            if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2040:            {
    #####: 2041:              result = ECMA_VALUE_ERROR;
    #####: 2042:              goto error;
        -: 2043:            }
        -: 2044:
    #####: 2045:            stack_top_p++;
    #####: 2046:            ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2047:          }
        -: 2048:          else
        -: 2049:          {
    #####: 2050:            stack_top_p -= arguments_list_len;
        -: 2051:          }
        -: 2052:
    #####: 2053:          frame_ctx_p->call_operation = VM_EXEC_SUPER_CALL;
    #####: 2054:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2055:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2056:          return ECMA_VALUE_UNDEFINED;
        -: 2057:        }
    #####: 2058:        case VM_OC_PUSH_CLASS_ENVIRONMENT:
        -: 2059:        {
        -: 2060:          uint16_t literal_index;
        -: 2061:
    #####: 2062:          READ_LITERAL_INDEX (literal_index);
    #####: 2063:          opfunc_push_class_environment (frame_ctx_p, &stack_top_p, literal_start_p[literal_index]);
    #####: 2064:          continue;
        -: 2065:        }
    #####: 2066:        case VM_OC_PUSH_IMPLICIT_CTOR:
        -: 2067:        {
    #####: 2068:          *stack_top_p++ = opfunc_create_implicit_class_constructor (opcode,
    #####: 2069:                                                                     frame_ctx_p->shared_p->bytecode_header_p);
    #####: 2070:          continue;
        -: 2071:        }
    #####: 2072:        case VM_OC_INIT_CLASS:
        -: 2073:        {
    #####: 2074:          result = opfunc_init_class (frame_ctx_p, stack_top_p);
        -: 2075:
    #####: 2076:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2077:          {
    #####: 2078:            goto error;
        -: 2079:          }
    #####: 2080:          continue;
        -: 2081:        }
    #####: 2082:        case VM_OC_FINALIZE_CLASS:
        -: 2083:        {
    #####: 2084:          JERRY_ASSERT (opcode == CBC_EXT_FINALIZE_NAMED_CLASS || opcode == CBC_EXT_FINALIZE_ANONYMOUS_CLASS);
        -: 2085:
    #####: 2086:          if (opcode == CBC_EXT_FINALIZE_NAMED_CLASS)
        -: 2087:          {
        -: 2088:            uint16_t literal_index;
    #####: 2089:            READ_LITERAL_INDEX (literal_index);
    #####: 2090:            left_value = literal_start_p[literal_index];
        -: 2091:          }
        -: 2092:
    #####: 2093:          opfunc_finalize_class (frame_ctx_p, &stack_top_p, left_value);
    #####: 2094:          continue;
        -: 2095:        }
    #####: 2096:        case VM_OC_SET_FIELD_INIT:
        -: 2097:        {
    #####: 2098:          ecma_string_t *property_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####: 2099:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-2]);
        -: 2100:
    #####: 2101:          ecma_property_value_t *property_value_p = ecma_create_named_data_property (object_p,
        -: 2102:                                                                                     property_name_p,
        -: 2103:                                                                                     ECMA_PROPERTY_FIXED,
        -: 2104:                                                                                     NULL);
    #####: 2105:          property_value_p->value = left_value;
        -: 2106:
    #####: 2107:          property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 2108:          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -: 2109:
    #####: 2110:          if (property_p != NULL)
        -: 2111:          {
    #####: 2112:            property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 2113:            ecma_value_t *compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t,
        -: 2114:                                                                                  property_value_p->value);
    #####: 2115:            compact_collection_p = ecma_compact_collection_shrink (compact_collection_p);
    #####: 2116:            ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
        -: 2117:          }
        -: 2118:
    #####: 2119:          goto free_left_value;
        -: 2120:        }
    #####: 2121:        case VM_OC_RUN_FIELD_INIT:
        -: 2122:        {
    #####: 2123:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####: 2124:          result = opfunc_init_class_fields (frame_ctx_p->shared_p->function_object_p, frame_ctx_p->this_binding);
        -: 2125:
    #####: 2126:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2127:          {
    #####: 2128:            goto error;
        -: 2129:          }
    #####: 2130:          continue;
        -: 2131:        }
    #####: 2132:        case VM_OC_RUN_STATIC_FIELD_INIT:
        -: 2133:        {
    #####: 2134:          left_value = stack_top_p[-2];
    #####: 2135:          stack_top_p[-2] = stack_top_p[-1];
    #####: 2136:          stack_top_p--;
        -: 2137:
    #####: 2138:          result = opfunc_init_static_class_fields (left_value, stack_top_p[-1]);
        -: 2139:
    #####: 2140:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2141:          {
    #####: 2142:            goto error;
        -: 2143:          }
    #####: 2144:          goto free_left_value;
        -: 2145:        }
    #####: 2146:        case VM_OC_SET_NEXT_COMPUTED_FIELD:
        -: 2147:        {
    #####: 2148:          ecma_integer_value_t next_index = ecma_get_integer_from_value (stack_top_p[-2]) + 1;
    #####: 2149:          stack_top_p[-2] = ecma_make_integer_value (next_index);
    #####: 2150:          stack_top_p++;
        -: 2151:
    #####: 2152:          JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS);
        -: 2153:
    #####: 2154:          ecma_value_t *computed_class_fields_p = VM_GET_COMPUTED_CLASS_FIELDS (frame_ctx_p);
    #####: 2155:          JERRY_ASSERT ((ecma_value_t) next_index < ECMA_COMPACT_COLLECTION_GET_SIZE (computed_class_fields_p));
        -: 2156:
    #####: 2157:          result = stack_top_p[-2];
    #####: 2158:          stack_top_p[-1] = ecma_copy_value (computed_class_fields_p[next_index]);
    #####: 2159:          stack_top_p[-2] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 2160:          break;
        -: 2161:        }
    #####: 2162:        case VM_OC_PUSH_SUPER_CONSTRUCTOR:
        -: 2163:        {
    #####: 2164:          result = ecma_op_function_get_super_constructor (vm_get_class_function (frame_ctx_p));
        -: 2165:
    #####: 2166:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2167:          {
    #####: 2168:            goto error;
        -: 2169:          }
        -: 2170:
    #####: 2171:          *stack_top_p++ = result;
    #####: 2172:          continue;
        -: 2173:        }
    #####: 2174:        case VM_OC_RESOLVE_LEXICAL_THIS:
        -: 2175:        {
    #####: 2176:          result = ecma_op_get_this_binding (frame_ctx_p->lex_env_p);
        -: 2177:
    #####: 2178:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2179:          {
    #####: 2180:            goto error;
        -: 2181:          }
        -: 2182:
    #####: 2183:          *stack_top_p++ = result;
    #####: 2184:          continue;
        -: 2185:        }
    #####: 2186:        case VM_OC_OBJECT_LITERAL_HOME_ENV:
        -: 2187:        {
    #####: 2188:          if (opcode == CBC_EXT_PUSH_OBJECT_SUPER_ENVIRONMENT)
        -: 2189:          {
    #####: 2190:            ecma_value_t obj_value = stack_top_p[-1];
    #####: 2191:            ecma_object_t *obj_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);
        -: 2192:
    #####: 2193:            ECMA_SET_NON_NULL_POINTER (obj_env_p->u1.bound_object_cp, ecma_get_object_from_value (obj_value));
    #####: 2194:            stack_top_p[-1] = ecma_make_object_value (obj_env_p);
    #####: 2195:            *stack_top_p++ = obj_value;
        -: 2196:          }
        -: 2197:          else
        -: 2198:          {
    #####: 2199:            JERRY_ASSERT (opcode == CBC_EXT_POP_OBJECT_SUPER_ENVIRONMENT);
    #####: 2200:            ecma_deref_object (ecma_get_object_from_value (stack_top_p[-2]));
    #####: 2201:            stack_top_p[-2] = stack_top_p[-1];
    #####: 2202:            stack_top_p--;
        -: 2203:          }
    #####: 2204:          continue;
        -: 2205:        }
    #####: 2206:        case VM_OC_SET_HOME_OBJECT:
        -: 2207:        {
    #####: 2208:          int offset = opcode == CBC_EXT_OBJECT_LITERAL_SET_HOME_OBJECT_COMPUTED ? -1 : 0;
    #####: 2209:          opfunc_set_home_object (ecma_get_object_from_value (stack_top_p[-1]),
    #####: 2210:                                  ecma_get_object_from_value (stack_top_p[-3 + offset]));
    #####: 2211:          continue;
        -: 2212:        }
    #####: 2213:        case VM_OC_SUPER_REFERENCE:
        -: 2214:        {
    #####: 2215:          result = opfunc_form_super_reference (&stack_top_p, frame_ctx_p, left_value, opcode);
        -: 2216:
    #####: 2217:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2218:          {
    #####: 2219:            goto error;
        -: 2220:          }
        -: 2221:
    #####: 2222:          goto free_left_value;
        -: 2223:        }
    #####: 2224:        case VM_OC_SET_FUNCTION_NAME:
        -: 2225:        {
    #####: 2226:          char *prefix_p = NULL;
    #####: 2227:          lit_utf8_size_t prefix_size = 0;
        -: 2228:
    #####: 2229:          if (opcode != CBC_EXT_SET_FUNCTION_NAME)
        -: 2230:          {
        -: 2231:            ecma_value_t prop_name_value;
        -: 2232:
    #####: 2233:            if (opcode == CBC_EXT_SET_CLASS_NAME)
        -: 2234:            {
        -: 2235:              uint16_t literal_index;
    #####: 2236:              READ_LITERAL_INDEX (literal_index);
    #####: 2237:              prop_name_value = literal_start_p[literal_index];
        -: 2238:            }
        -: 2239:            else
        -: 2240:            {
    #####: 2241:              prop_name_value = stack_top_p[-2];
        -: 2242:            }
        -: 2243:
    #####: 2244:            ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name_value);
        -: 2245:
    #####: 2246:            if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 2247:            {
    #####: 2248:              result = ECMA_VALUE_ERROR;
    #####: 2249:              goto error;
        -: 2250:            }
        -: 2251:
    #####: 2252:            left_value = ecma_make_prop_name_value (prop_name_p);
        -: 2253:
    #####: 2254:            if (opcode != CBC_EXT_SET_CLASS_NAME)
        -: 2255:            {
    #####: 2256:              ecma_ref_ecma_string (prop_name_p);
    #####: 2257:              ecma_free_value (stack_top_p[-2]);
    #####: 2258:              stack_top_p[-2] = left_value;
        -: 2259:            }
        -: 2260:
    #####: 2261:            if (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME || opcode == CBC_EXT_SET_COMPUTED_SETTER_NAME)
        -: 2262:            {
    #####: 2263:              prefix_p = (opcode == CBC_EXT_SET_COMPUTED_GETTER_NAME) ? "get " : "set ";
    #####: 2264:              prefix_size = 4;
        -: 2265:            }
        -: 2266:          }
        -: 2267:
    #####: 2268:          ecma_object_t *func_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 2269:
    #####: 2270:          if (ecma_find_named_property (func_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_NAME)) != NULL)
        -: 2271:          {
    #####: 2272:            ecma_free_value (left_value);
    #####: 2273:            continue;
        -: 2274:          }
        -: 2275:
        -: 2276:          ecma_property_value_t *value_p;
    #####: 2277:          value_p = ecma_create_named_data_property (func_obj_p,
        -: 2278:                                                     ecma_get_magic_string (LIT_MAGIC_STRING_NAME),
        -: 2279:                                                     ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 2280:                                                     NULL);
        -: 2281:
    #####: 2282:          if (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 2283:          {
    #####: 2284:            ECMA_SET_SECOND_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp);
        -: 2285:          }
        -: 2286:
    #####: 2287:          value_p->value = ecma_op_function_form_name (ecma_get_prop_name_from_value (left_value),
        -: 2288:                                                       prefix_p,
        -: 2289:                                                       prefix_size);
    #####: 2290:          ecma_free_value (left_value);
    #####: 2291:          continue;
        -: 2292:        }
    #####: 2293:        case VM_OC_PUSH_SPREAD_ELEMENT:
        -: 2294:        {
    #####: 2295:          *stack_top_p++ = ECMA_VALUE_SPREAD_ELEMENT;
    #####: 2296:          continue;
        -: 2297:        }
    #####: 2298:        case VM_OC_PUSH_REST_OBJECT:
        -: 2299:        {
    #####: 2300:          vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        -: 2301:
    #####: 2302:          JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 2303:
    #####: 2304:          const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 2305:          uint32_t arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 2306:          uint16_t argument_end;
        -: 2307:
    #####: 2308:          if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 2309:          {
    #####: 2310:            argument_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->argument_end;
        -: 2311:          }
        -: 2312:          else
        -: 2313:          {
    #####: 2314:            argument_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->argument_end;
        -: 2315:          }
        -: 2316:
    #####: 2317:          if (arg_list_len < argument_end)
        -: 2318:          {
    #####: 2319:            arg_list_len = argument_end;
        -: 2320:          }
        -: 2321:
    #####: 2322:          result = ecma_op_new_array_object_from_buffer (arg_list_p + argument_end,
        -: 2323:                                                         arg_list_len - argument_end);
        -: 2324:
    #####: 2325:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (result));
    #####: 2326:          *stack_top_p++ = result;
    #####: 2327:          continue;
        -: 2328:        }
    #####: 2329:        case VM_OC_ITERATOR_CONTEXT_CREATE:
        -: 2330:        {
    #####: 2331:          result = ecma_op_get_iterator (stack_top_p[-1], ECMA_VALUE_SYNC_ITERATOR, &left_value);
        -: 2332:
    #####: 2333:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2334:          {
    #####: 2335:            goto error;
        -: 2336:          }
        -: 2337:
    #####: 2338:          uint32_t context_size = (uint32_t) (stack_top_p
    #####: 2339:                                              + PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION
    #####: 2340:                                              - VM_LAST_CONTEXT_END ());
    #####: 2341:          stack_top_p += PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION;
    #####: 2342:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2343:
    #####: 2344:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_ITERATOR, context_size) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2345:          stack_top_p[-2] = result;
    #####: 2346:          stack_top_p[-3] = left_value;
        -: 2347:
    #####: 2348:          continue;
        -: 2349:        }
    #####: 2350:        case VM_OC_ITERATOR_STEP:
        -: 2351:        {
    #####: 2352:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
        -: 2353:
    #####: 2354:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2355:          ecma_value_t next_method = last_context_end_p[-3];
        -: 2356:
    #####: 2357:          result = ecma_op_iterator_step (iterator, next_method);
        -: 2358:
    #####: 2359:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2360:          {
    #####: 2361:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2362:            goto error;
        -: 2363:          }
        -: 2364:
    #####: 2365:          ecma_value_t value = ECMA_VALUE_UNDEFINED;
        -: 2366:
    #####: 2367:          if (!ecma_is_value_false (result))
        -: 2368:          {
    #####: 2369:            value = ecma_op_iterator_value (result);
    #####: 2370:            ecma_free_value (result);
        -: 2371:
    #####: 2372:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2373:            {
    #####: 2374:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2375:              result = value;
    #####: 2376:              goto error;
        -: 2377:            }
        -: 2378:          }
        -: 2379:          else
        -: 2380:          {
    #####: 2381:            last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
        -: 2382:          }
        -: 2383:
    #####: 2384:          *stack_top_p++ = value;
    #####: 2385:          continue;
        -: 2386:        }
    #####: 2387:        case VM_OC_ITERATOR_CONTEXT_END:
        -: 2388:        {
    #####: 2389:          JERRY_ASSERT (VM_LAST_CONTEXT_END () == stack_top_p);
        -: 2390:
    #####: 2391:          if (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR)
        -: 2392:          {
    #####: 2393:            stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2394:            result = ecma_op_iterator_close (stack_top_p[-2]);
        -: 2395:
    #####: 2396:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2397:            {
    #####: 2398:              goto error;
        -: 2399:            }
        -: 2400:          }
        -: 2401:
    #####: 2402:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p,
        -: 2403:                                                                stack_top_p,
        -: 2404:                                                                PARSER_ITERATOR_CONTEXT_STACK_ALLOCATION);
    #####: 2405:          continue;
        -: 2406:        }
    #####: 2407:        case VM_OC_DEFAULT_INITIALIZER:
        -: 2408:        {
    #####: 2409:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 2410:
    #####: 2411:          if (stack_top_p[-1] != ECMA_VALUE_UNDEFINED)
        -: 2412:          {
    #####: 2413:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 2414:            continue;
        -: 2415:          }
        -: 2416:
    #####: 2417:          stack_top_p--;
    #####: 2418:          continue;
        -: 2419:        }
    #####: 2420:        case VM_OC_REST_INITIALIZER:
        -: 2421:        {
    #####: 2422:          ecma_object_t *array_p = ecma_op_new_array_object (0);
    #####: 2423:          JERRY_ASSERT (ecma_op_object_is_fast_array (array_p));
        -: 2424:
    #####: 2425:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2426:          ecma_value_t iterator = last_context_end_p[-2];
    #####: 2427:          ecma_value_t next_method = last_context_end_p[-3];
    #####: 2428:          uint32_t index = 0;
        -: 2429:
        -: 2430:          while (true)
    #####: 2431:          {
    #####: 2432:            result = ecma_op_iterator_step (iterator, next_method);
        -: 2433:
    #####: 2434:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2435:            {
    #####: 2436:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2437:              ecma_deref_object (array_p);
    #####: 2438:              goto error;
        -: 2439:            }
        -: 2440:
    #####: 2441:            if (ecma_is_value_false (result))
        -: 2442:            {
    #####: 2443:              last_context_end_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 2444:              break;
        -: 2445:            }
        -: 2446:
    #####: 2447:            ecma_value_t value = ecma_op_iterator_value (result);
    #####: 2448:            ecma_free_value (result);
        -: 2449:
    #####: 2450:            if (ECMA_IS_VALUE_ERROR (value))
        -: 2451:            {
    #####: 2452:              ecma_deref_object (array_p);
    #####: 2453:              result = value;
    #####: 2454:              goto error;
        -: 2455:            }
        -: 2456:
    #####: 2457:            bool set_result = ecma_fast_array_set_property (array_p, index++, value);
    #####: 2458:            JERRY_ASSERT (set_result);
    #####: 2459:            ecma_free_value (value);
        -: 2460:          }
        -: 2461:
    #####: 2462:          *stack_top_p++ = ecma_make_object_value (array_p);
    #####: 2463:          continue;
        -: 2464:        }
    #####: 2465:        case VM_OC_OBJ_INIT_CONTEXT_CREATE:
        -: 2466:        {
    #####: 2467:          left_value = stack_top_p[-1];
    #####: 2468:          vm_stack_context_type_t context_type = VM_CONTEXT_OBJ_INIT;
    #####: 2469:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2470:
    #####: 2471:          if (opcode == CBC_EXT_OBJ_INIT_REST_CONTEXT_CREATE)
        -: 2472:          {
    #####: 2473:            context_type = VM_CONTEXT_OBJ_INIT_REST;
    #####: 2474:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2475:          }
        -: 2476:
    #####: 2477:          uint32_t context_size = (uint32_t) (stack_top_p + context_stack_allocation - VM_LAST_CONTEXT_END ());
    #####: 2478:          stack_top_p += context_stack_allocation;
    #####: 2479:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, context_size);
        -: 2480:
    #####: 2481:          stack_top_p[-1] = VM_CREATE_CONTEXT (context_type, context_size);
    #####: 2482:          stack_top_p[-2] = left_value;
        -: 2483:
    #####: 2484:          if (context_type == VM_CONTEXT_OBJ_INIT_REST)
        -: 2485:          {
    #####: 2486:            stack_top_p[-3] = ecma_make_object_value (ecma_op_new_array_object (0));
        -: 2487:          }
    #####: 2488:          continue;
        -: 2489:        }
    #####: 2490:        case VM_OC_OBJ_INIT_CONTEXT_END:
        -: 2491:        {
    #####: 2492:          JERRY_ASSERT (stack_top_p == VM_LAST_CONTEXT_END ());
        -: 2493:
    #####: 2494:          uint32_t context_stack_allocation = PARSER_OBJ_INIT_CONTEXT_STACK_ALLOCATION;
        -: 2495:
    #####: 2496:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_OBJ_INIT_REST)
        -: 2497:          {
    #####: 2498:            context_stack_allocation = PARSER_OBJ_INIT_REST_CONTEXT_STACK_ALLOCATION;
        -: 2499:          }
        -: 2500:
    #####: 2501:          stack_top_p = vm_stack_context_abort_variable_length (frame_ctx_p,
        -: 2502:                                                                stack_top_p,
        -: 2503:                                                                context_stack_allocation);
    #####: 2504:          continue;
        -: 2505:        }
    #####: 2506:        case VM_OC_OBJ_INIT_PUSH_REST:
        -: 2507:        {
    #####: 2508:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2509:          if (!ecma_op_require_object_coercible (last_context_end_p[-2]))
        -: 2510:          {
    #####: 2511:            result = ECMA_VALUE_ERROR;
    #####: 2512:            goto error;
        -: 2513:          }
        -: 2514:
    #####: 2515:          ecma_object_t *prototype_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
    #####: 2516:          ecma_object_t *result_object_p = ecma_create_object (prototype_p, 0, ECMA_OBJECT_TYPE_GENERAL);
        -: 2517:
    #####: 2518:          left_value = ecma_make_object_value (result_object_p);
    #####: 2519:          result = opfunc_copy_data_properties (left_value, last_context_end_p[-2], last_context_end_p[-3]);
        -: 2520:
    #####: 2521:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2522:          {
    #####: 2523:            goto error;
        -: 2524:          }
        -: 2525:
    #####: 2526:          ecma_free_value (last_context_end_p[-3]);
    #####: 2527:          last_context_end_p[-3] = last_context_end_p[-2];
    #####: 2528:          last_context_end_p[-2] = ECMA_VALUE_UNDEFINED;
        -: 2529:
    #####: 2530:          *stack_top_p++ = left_value;
    #####: 2531:          continue;
        -: 2532:        }
    #####: 2533:        case VM_OC_INITIALIZER_PUSH_NAME:
        -: 2534:        {
    #####: 2535:          if (JERRY_UNLIKELY (!ecma_is_value_prop_name (left_value)))
        -: 2536:          {
    #####: 2537:            ecma_string_t *property_key = ecma_op_to_property_key (left_value);
        -: 2538:
    #####: 2539:            if (property_key == NULL)
        -: 2540:            {
    #####: 2541:              result = ECMA_VALUE_ERROR;
    #####: 2542:              goto error;
        -: 2543:            }
        -: 2544:
    #####: 2545:            ecma_free_value (left_value);
    #####: 2546:            left_value = ecma_make_string_value (property_key);
        -: 2547:          }
        -: 2548:
    #####: 2549:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2550:          ecma_object_t *array_obj_p = ecma_get_object_from_value (last_context_end_p[-3]);
    #####: 2551:          JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -: 2552:
    #####: 2553:          ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####: 2554:          ecma_fast_array_set_property (array_obj_p, ext_array_obj_p->u.array.length, left_value);
        -: 2555:          /* FALLTHRU */
        -: 2556:        }
    #####: 2557:        case VM_OC_INITIALIZER_PUSH_PROP:
        -: 2558:        {
    #####: 2559:          ecma_value_t *last_context_end_p = VM_LAST_CONTEXT_END ();
    #####: 2560:          ecma_value_t base = last_context_end_p[-2];
        -: 2561:
    #####: 2562:          if (opcode == CBC_EXT_INITIALIZER_PUSH_PROP)
        -: 2563:          {
    #####: 2564:            left_value = *last_context_end_p++;
    #####: 2565:            while (last_context_end_p < stack_top_p)
        -: 2566:            {
    #####: 2567:              last_context_end_p[-1] = *last_context_end_p;
    #####: 2568:              last_context_end_p++;
        -: 2569:            }
    #####: 2570:            stack_top_p--;
        -: 2571:          }
        -: 2572:
    #####: 2573:          result = vm_op_get_value (base, left_value);
        -: 2574:
    #####: 2575:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2576:          {
    #####: 2577:            goto error;
        -: 2578:          }
        -: 2579:
    #####: 2580:          *stack_top_p++ = result;
    #####: 2581:          goto free_left_value;
        -: 2582:        }
    #####: 2583:        case VM_OC_SPREAD_ARGUMENTS:
        -: 2584:        {
    #####: 2585:          uint8_t arguments_list_len = *byte_code_p++;
    #####: 2586:          stack_top_p -= arguments_list_len;
        -: 2587:
    #####: 2588:          ecma_collection_t *arguments_p = opfunc_spread_arguments (stack_top_p, arguments_list_len);
        -: 2589:
    #####: 2590:          if (JERRY_UNLIKELY (arguments_p == NULL))
        -: 2591:          {
    #####: 2592:            result = ECMA_VALUE_ERROR;
    #####: 2593:            goto error;
        -: 2594:          }
        -: 2595:
    #####: 2596:          stack_top_p++;
    #####: 2597:          ECMA_SET_INTERNAL_VALUE_POINTER (stack_top_p[-1], arguments_p);
        -: 2598:
    #####: 2599:          frame_ctx_p->call_operation = VM_EXEC_SPREAD_OP;
    #####: 2600:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 2601:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2602:          return ECMA_VALUE_UNDEFINED;
        -: 2603:        }
    #####: 2604:        case VM_OC_CREATE_GENERATOR:
        -: 2605:        {
    #####: 2606:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2607:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2608:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 2609:
        -: 2610:          vm_executable_object_t *executable_object_p;
    #####: 2611:          executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -: 2612:
    #####: 2613:          return ecma_make_object_value ((ecma_object_t *) executable_object_p);
        -: 2614:        }
    #####: 2615:        case VM_OC_YIELD:
        -: 2616:        {
    #####: 2617:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2618:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2619:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2620:          return *stack_top_p;
        -: 2621:        }
    #####: 2622:        case VM_OC_ASYNC_YIELD:
        -: 2623:        {
    #####: 2624:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2625:
    #####: 2626:          opfunc_async_generator_yield (async_generator_object_p, stack_top_p[-1]);
        -: 2627:
    #####: 2628:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2629:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2630:          frame_ctx_p->stack_top_p = --stack_top_p;
    #####: 2631:          return ECMA_VALUE_UNDEFINED;
        -: 2632:        }
    #####: 2633:        case VM_OC_ASYNC_YIELD_ITERATOR:
        -: 2634:        {
    #####: 2635:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2636:
    #####: 2637:          JERRY_ASSERT (!(async_generator_object_p->u.cls.u2.executable_obj_flags
        -: 2638:                          & ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD));
        -: 2639:
        -: 2640:          /* Byte code is executed at the first time. */
    #####: 2641:          left_value = stack_top_p[-1];
    #####: 2642:          result = ecma_op_get_iterator (left_value, ECMA_VALUE_ASYNC_ITERATOR, stack_top_p - 1);
        -: 2643:
    #####: 2644:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2645:          {
    #####: 2646:            goto error;
        -: 2647:          }
        -: 2648:
    #####: 2649:          ecma_free_value (left_value);
    #####: 2650:          left_value = result;
    #####: 2651:          result = ecma_op_iterator_next (left_value, stack_top_p[-1], ECMA_VALUE_UNDEFINED);
        -: 2652:
    #####: 2653:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2654:          {
    #####: 2655:            goto error;
        -: 2656:          }
        -: 2657:
    #####: 2658:          result = ecma_promise_async_await (async_generator_object_p, result);
        -: 2659:
    #####: 2660:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2661:          {
    #####: 2662:            goto error;
        -: 2663:          }
        -: 2664:
    #####: 2665:          async_generator_object_p->u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD;
    #####: 2666:          frame_ctx_p->block_result = left_value;
        -: 2667:
    #####: 2668:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2669:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2670:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2671:          return ECMA_VALUE_UNDEFINED;
        -: 2672:        }
    #####: 2673:        case VM_OC_AWAIT:
        -: 2674:        {
    #####: 2675:          if (JERRY_UNLIKELY (frame_ctx_p->block_result == ECMA_VALUE_UNDEFINED))
        -: 2676:          {
    #####: 2677:            frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2678:            frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2679:            frame_ctx_p->stack_top_p = --stack_top_p;
        -: 2680:
    #####: 2681:            result = opfunc_async_create_and_await (frame_ctx_p, *stack_top_p, 0);
        -: 2682:
    #####: 2683:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2684:            {
    #####: 2685:              goto error;
        -: 2686:            }
    #####: 2687:            return result;
        -: 2688:          }
        -: 2689:          /* FALLTHRU */
        -: 2690:        }
        -: 2691:        case VM_OC_GENERATOR_AWAIT:
        -: 2692:        {
    #####: 2693:          ecma_extended_object_t *async_generator_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
        -: 2694:
    #####: 2695:          result = ecma_promise_async_await (async_generator_object_p, *(--stack_top_p));
        -: 2696:
    #####: 2697:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2698:          {
    #####: 2699:            goto error;
        -: 2700:          }
        -: 2701:
    #####: 2702:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 2703:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 2704:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 2705:          return ECMA_VALUE_UNDEFINED;
        -: 2706:        }
    #####: 2707:        case VM_OC_EXT_RETURN:
        -: 2708:        {
    #####: 2709:          result = left_value;
    #####: 2710:          left_value = ECMA_VALUE_UNDEFINED;
        -: 2711:
    #####: 2712:          ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 2713:
    #####: 2714:          while (stack_top_p > stack_bottom_p)
        -: 2715:          {
    #####: 2716:            ecma_fast_free_value (*(--stack_top_p));
        -: 2717:          }
        -: 2718:
    #####: 2719:          goto error;
        -: 2720:        }
    #####: 2721:        case VM_OC_ASYNC_EXIT:
        -: 2722:        {
    #####: 2723:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 2724:
    #####: 2725:          result = frame_ctx_p->block_result;
    #####: 2726:          frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;
        -: 2727:
    #####: 2728:          if (result == ECMA_VALUE_UNDEFINED)
        -: 2729:          {
    #####: 2730:            result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2731:          }
        -: 2732:
    #####: 2733:          vm_stack_context_type_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 2734:
    #####: 2735:          if (context_type == VM_CONTEXT_TRY)
        -: 2736:          {
    #####: 2737:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 2738:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2739:          }
        -: 2740:          else
        -: 2741:          {
    #####: 2742:            JERRY_ASSERT (frame_ctx_p->context_depth == PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 2743:            left_value = stack_top_p[-2];
        -: 2744:          }
        -: 2745:
    #####: 2746:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 2747:          {
    #####: 2748:            ecma_reject_promise (result, left_value);
        -: 2749:          }
        -: 2750:          else
        -: 2751:          {
    #####: 2752:            JERRY_ASSERT (context_type == VM_CONTEXT_TRY || context_type == VM_CONTEXT_FINALLY_RETURN);
    #####: 2753:            ecma_fulfill_promise (result, left_value);
        -: 2754:          }
        -: 2755:
    #####: 2756:          ecma_free_value (left_value);
        -: 2757:
    #####: 2758:          frame_ctx_p->context_depth = 0;
    #####: 2759:          frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 2760:          return result;
        -: 2761:        }
    #####: 2762:        case VM_OC_STRING_CONCAT:
        -: 2763:        {
    #####: 2764:          ecma_string_t *left_str_p = ecma_op_to_string (left_value);
        -: 2765:
    #####: 2766:          if (JERRY_UNLIKELY (left_str_p == NULL))
        -: 2767:          {
    #####: 2768:            result = ECMA_VALUE_ERROR;
    #####: 2769:            goto error;
        -: 2770:          }
    #####: 2771:          ecma_string_t *right_str_p = ecma_op_to_string (right_value);
        -: 2772:
    #####: 2773:          if (JERRY_UNLIKELY (right_str_p == NULL))
        -: 2774:          {
    #####: 2775:            ecma_deref_ecma_string (left_str_p);
    #####: 2776:            result = ECMA_VALUE_ERROR;
    #####: 2777:            goto error;
        -: 2778:          }
        -: 2779:
    #####: 2780:          ecma_string_t *result_str_p = ecma_concat_ecma_strings (left_str_p, right_str_p);
    #####: 2781:          ecma_deref_ecma_string (right_str_p);
        -: 2782:
    #####: 2783:          *stack_top_p++ = ecma_make_string_value (result_str_p);
    #####: 2784:          goto free_both_values;
        -: 2785:        }
    #####: 2786:        case VM_OC_GET_TEMPLATE_OBJECT:
        -: 2787:        {
    #####: 2788:          uint8_t tagged_idx = *byte_code_p++;
    #####: 2789:          ecma_collection_t *collection_p = ecma_compiled_code_get_tagged_template_collection (bytecode_header_p);
    #####: 2790:          JERRY_ASSERT (tagged_idx < collection_p->item_count);
        -: 2791:
    #####: 2792:          *stack_top_p++ = ecma_copy_value (collection_p->buffer_p[tagged_idx]);
    #####: 2793:          continue;
        -: 2794:        }
    #####: 2795:        case VM_OC_PUSH_NEW_TARGET:
        -: 2796:        {
    #####: 2797:          ecma_object_t *new_target_object_p = JERRY_CONTEXT (current_new_target_p);
    #####: 2798:          if (new_target_object_p == NULL)
        -: 2799:          {
    #####: 2800:            *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2801:          }
        -: 2802:          else
        -: 2803:          {
    #####: 2804:            ecma_ref_object (new_target_object_p);
    #####: 2805:            *stack_top_p++ = ecma_make_object_value (new_target_object_p);
        -: 2806:          }
    #####: 2807:          continue;
        -: 2808:        }
    #####: 2809:        case VM_OC_REQUIRE_OBJECT_COERCIBLE:
        -: 2810:        {
    #####: 2811:          if (!ecma_op_require_object_coercible (stack_top_p[-1]))
        -: 2812:          {
    #####: 2813:            result = ECMA_VALUE_ERROR;
    #####: 2814:            goto error;
        -: 2815:          }
    #####: 2816:          continue;
        -: 2817:        }
    #####: 2818:        case VM_OC_ASSIGN_SUPER:
        -: 2819:        {
    #####: 2820:          result = opfunc_assign_super_reference (&stack_top_p, frame_ctx_p, opcode_data);
        -: 2821:
    #####: 2822:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2823:          {
    #####: 2824:            goto error;
        -: 2825:          }
    #####: 2826:          continue;
        -: 2827:        }
        -: 2828:#endif /* JERRY_ESNEXT */
    #####: 2829:        case VM_OC_PUSH_ELISON:
        -: 2830:        {
    #####: 2831:          *stack_top_p++ = ECMA_VALUE_ARRAY_HOLE;
    #####: 2832:          continue;
        -: 2833:        }
    #####: 2834:        case VM_OC_APPEND_ARRAY:
        -: 2835:        {
    #####: 2836:          uint16_t values_length = *byte_code_p++;
    #####: 2837:          stack_top_p -= values_length;
        -: 2838:
        -: 2839:#if JERRY_ESNEXT
    #####: 2840:          if (*byte_code_start_p == CBC_EXT_OPCODE)
        -: 2841:          {
    #####: 2842:            values_length = (uint16_t) (values_length | OPFUNC_HAS_SPREAD_ELEMENT);
        -: 2843:          }
        -: 2844:#endif /* JERRY_ESNEXT */
    #####: 2845:          result = opfunc_append_array (stack_top_p, values_length);
        -: 2846:
        -: 2847:#if JERRY_ESNEXT
    #####: 2848:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2849:          {
    #####: 2850:            goto error;
        -: 2851:          }
        -: 2852:#else /* !JERRY_ESNEXT */
        -: 2853:          JERRY_ASSERT (ecma_is_value_empty (result));
        -: 2854:#endif /* JERRY_ESNEXT */
    #####: 2855:          continue;
        -: 2856:        }
    #####: 2857:        case VM_OC_IDENT_REFERENCE:
        -: 2858:        {
        -: 2859:          uint16_t literal_index;
        -: 2860:
    #####: 2861:          READ_LITERAL_INDEX (literal_index);
        -: 2862:
    #####: 2863:          JERRY_ASSERT (literal_index < ident_end);
        -: 2864:
    #####: 2865:          if (literal_index < register_end)
        -: 2866:          {
    #####: 2867:            *stack_top_p++ = ECMA_VALUE_REGISTER_REF;
    #####: 2868:            *stack_top_p++ = ecma_make_integer_value (literal_index);
    #####: 2869:            *stack_top_p++ = ecma_fast_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 2870:          }
        -: 2871:          else
        -: 2872:          {
    #####: 2873:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 2874:
    #####: 2875:            ecma_object_t *ref_base_lex_env_p;
        -: 2876:
    #####: 2877:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 2878:                                                     &ref_base_lex_env_p,
        -: 2879:                                                     name_p);
        -: 2880:
    #####: 2881:            if (ECMA_IS_VALUE_ERROR (result))
        -: 2882:            {
    #####: 2883:              goto error;
        -: 2884:            }
        -: 2885:
    #####: 2886:            ecma_ref_object (ref_base_lex_env_p);
    #####: 2887:            ecma_ref_ecma_string (name_p);
    #####: 2888:            *stack_top_p++ = ecma_make_object_value (ref_base_lex_env_p);
    #####: 2889:            *stack_top_p++ = ecma_make_string_value (name_p);
    #####: 2890:            *stack_top_p++ = result;
        -: 2891:          }
    #####: 2892:          continue;
        -: 2893:        }
    #####: 2894:        case VM_OC_PROP_GET:
        -: 2895:        {
    #####: 2896:          result = vm_op_get_value (left_value, right_value);
        -: 2897:
    #####: 2898:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2899:          {
    #####: 2900:            goto error;
        -: 2901:          }
        -: 2902:
    #####: 2903:          *stack_top_p++ = result;
    #####: 2904:          goto free_both_values;
        -: 2905:        }
      101: 2906:        case VM_OC_PROP_REFERENCE:
        -: 2907:        {
        -: 2908:          /* Forms with reference requires preserving the base and offset. */
        -: 2909:
      101: 2910:          if (opcode == CBC_PUSH_PROP_REFERENCE)
        -: 2911:          {
    #####: 2912:            left_value = stack_top_p[-2];
    #####: 2913:            right_value = stack_top_p[-1];
        -: 2914:          }
      101: 2915:          else if (opcode == CBC_PUSH_PROP_LITERAL_REFERENCE)
        -: 2916:          {
    #####: 2917:            *stack_top_p++ = left_value;
    #####: 2918:            right_value = left_value;
    #####: 2919:            left_value = stack_top_p[-2];
        -: 2920:          }
        -: 2921:          else
        -: 2922:          {
      101: 2923:            JERRY_ASSERT (opcode == CBC_PUSH_PROP_LITERAL_LITERAL_REFERENCE
        -: 2924:                          || opcode == CBC_PUSH_PROP_THIS_LITERAL_REFERENCE);
      101: 2925:            *stack_top_p++ = left_value;
      101: 2926:            *stack_top_p++ = right_value;
        -: 2927:          }
        -: 2928:          /* FALLTHRU */
        -: 2929:        }
        -: 2930:        case VM_OC_PROP_PRE_INCR:
        -: 2931:        case VM_OC_PROP_PRE_DECR:
        -: 2932:        case VM_OC_PROP_POST_INCR:
        -: 2933:        case VM_OC_PROP_POST_DECR:
        -: 2934:        {
      101: 2935:          result = vm_op_get_value (left_value,
        -: 2936:                                    right_value);
        -: 2937:
      101: 2938:          if (opcode < CBC_PRE_INCR)
        -: 2939:          {
      101: 2940:            left_value = ECMA_VALUE_UNDEFINED;
      101: 2941:            right_value = ECMA_VALUE_UNDEFINED;
        -: 2942:          }
        -: 2943:
      101: 2944:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2945:          {
    #####: 2946:            goto error;
        -: 2947:          }
        -: 2948:
      101: 2949:          if (opcode < CBC_PRE_INCR)
        -: 2950:          {
      101: 2951:            break;
        -: 2952:          }
        -: 2953:
    #####: 2954:          stack_top_p += 2;
    #####: 2955:          left_value = result;
    #####: 2956:          right_value = ECMA_VALUE_UNDEFINED;
        -: 2957:          /* FALLTHRU */
        -: 2958:        }
      100: 2959:        case VM_OC_PRE_INCR:
        -: 2960:        case VM_OC_PRE_DECR:
        -: 2961:        case VM_OC_POST_INCR:
        -: 2962:        case VM_OC_POST_DECR:
        -: 2963:        {
      100: 2964:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_PROP_PRE_INCR;
      100: 2965:          ecma_number_t result_number;
        -: 2966:
      100: 2967:          byte_code_p = byte_code_start_p + 1;
        -: 2968:
      100: 2969:          if (ecma_is_value_integer_number (left_value))
        -: 2970:          {
      100: 2971:            result = left_value;
      100: 2972:            left_value = ECMA_VALUE_UNDEFINED;
        -: 2973:
      100: 2974:            ecma_integer_value_t int_value = (ecma_integer_value_t) result;
      100: 2975:            ecma_integer_value_t int_increase = 0;
        -: 2976:
      100: 2977:            if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 2978:            {
    #####: 2979:              if (int_value > ECMA_INTEGER_NUMBER_MIN_SHIFTED)
        -: 2980:              {
    #####: 2981:                int_increase = -(1 << ECMA_DIRECT_SHIFT);
        -: 2982:              }
        -: 2983:            }
      100: 2984:            else if (int_value < ECMA_INTEGER_NUMBER_MAX_SHIFTED)
        -: 2985:            {
      100: 2986:              int_increase = 1 << ECMA_DIRECT_SHIFT;
        -: 2987:            }
        -: 2988:
      100: 2989:            if (JERRY_LIKELY (int_increase != 0))
        -: 2990:            {
        -: 2991:              /* Postfix operators require the unmodifed number value. */
      100: 2992:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 2993:              {
    #####: 2994:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 2995:              }
        -: 2996:
      100: 2997:              result = (ecma_value_t) (int_value + int_increase);
      100: 2998:              break;
        -: 2999:            }
    #####: 3000:            result_number = (ecma_number_t) ecma_get_integer_from_value (result);
        -: 3001:          }
    #####: 3002:          else if (ecma_is_value_float_number (left_value))
        -: 3003:          {
    #####: 3004:            result = left_value;
    #####: 3005:            left_value = ECMA_VALUE_UNDEFINED;
    #####: 3006:            result_number = ecma_get_number_from_value (result);
        -: 3007:          }
        -: 3008:          else
        -: 3009:          {
    #####: 3010:            result = ecma_op_to_numeric (left_value, &result_number, ECMA_TO_NUMERIC_ALLOW_BIGINT);
        -: 3011:
    #####: 3012:            if (ECMA_IS_VALUE_ERROR (result))
        -: 3013:            {
    #####: 3014:              goto error;
        -: 3015:            }
        -: 3016:
    #####: 3017:            ecma_free_value (left_value);
    #####: 3018:            left_value = ECMA_VALUE_UNDEFINED;
        -: 3019:
        -: 3020:#if JERRY_BUILTIN_BIGINT
    #####: 3021:            if (JERRY_UNLIKELY (ecma_is_value_bigint (result)))
        -: 3022:            {
    #####: 3023:              ecma_bigint_unary_operation_type operation_type = ECMA_BIGINT_UNARY_INCREASE;
        -: 3024:
    #####: 3025:              if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3026:              {
    #####: 3027:                operation_type = ECMA_BIGINT_UNARY_DECREASE;
        -: 3028:              }
        -: 3029:
        -: 3030:              /* Postfix operators require the unmodifed number value. */
    #####: 3031:              if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3032:              {
    #####: 3033:                POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3034:
    #####: 3035:                result = ecma_bigint_unary (result, operation_type);
        -: 3036:              }
        -: 3037:              else
        -: 3038:              {
    #####: 3039:                ecma_value_t original_value = result;
    #####: 3040:                result = ecma_bigint_unary (original_value, operation_type);
    #####: 3041:                ecma_free_value (original_value);
        -: 3042:              }
        -: 3043:
    #####: 3044:              if (ECMA_IS_VALUE_ERROR (result))
        -: 3045:              {
    #####: 3046:                goto error;
        -: 3047:              }
    #####: 3048:              break;
        -: 3049:            }
        -: 3050:#endif /* JERRY_BUILTIN_BIGINT */
        -: 3051:
    #####: 3052:            result = ecma_make_number_value (result_number);
        -: 3053:          }
        -: 3054:
    #####: 3055:          ecma_number_t increase = ECMA_NUMBER_ONE;
        -: 3056:
    #####: 3057:          if (opcode_flags & VM_OC_DECREMENT_OPERATOR_FLAG)
        -: 3058:          {
        -: 3059:            /* For decrement operators */
    #####: 3060:            increase = ECMA_NUMBER_MINUS_ONE;
        -: 3061:          }
        -: 3062:
        -: 3063:          /* Postfix operators require the unmodifed number value. */
    #####: 3064:          if (opcode_flags & VM_OC_POST_INCR_DECR_OPERATOR_FLAG)
        -: 3065:          {
    #####: 3066:            POST_INCREASE_DECREASE_PUT_RESULT (result);
        -: 3067:
    #####: 3068:            result = ecma_make_number_value (result_number + increase);
    #####: 3069:            break;
        -: 3070:          }
        -: 3071:
    #####: 3072:          if (ecma_is_value_integer_number (result))
        -: 3073:          {
    #####: 3074:            result = ecma_make_number_value (result_number + increase);
        -: 3075:          }
        -: 3076:          else
        -: 3077:          {
    #####: 3078:            result = ecma_update_float_number (result, result_number + increase);
        -: 3079:          }
    #####: 3080:          break;
        -: 3081:        }
        3: 3082:        case VM_OC_ASSIGN:
        -: 3083:        {
        3: 3084:          result = left_value;
        3: 3085:          left_value = ECMA_VALUE_UNDEFINED;
        3: 3086:          break;
        -: 3087:        }
    #####: 3088:        case VM_OC_MOV_IDENT:
        -: 3089:        {
        -: 3090:          uint32_t literal_index;
        -: 3091:
    #####: 3092:          READ_LITERAL_INDEX (literal_index);
        -: 3093:
    #####: 3094:          JERRY_ASSERT (literal_index < register_end);
    #####: 3095:          JERRY_ASSERT (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)));
        -: 3096:
    #####: 3097:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 3098:          VM_GET_REGISTER (frame_ctx_p, literal_index) = left_value;
    #####: 3099:          continue;
        -: 3100:        }
    #####: 3101:        case VM_OC_ASSIGN_PROP:
        -: 3102:        {
    #####: 3103:          result = stack_top_p[-1];
    #####: 3104:          stack_top_p[-1] = left_value;
    #####: 3105:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3106:          break;
        -: 3107:        }
    #####: 3108:        case VM_OC_ASSIGN_PROP_THIS:
        -: 3109:        {
    #####: 3110:          result = stack_top_p[-1];
    #####: 3111:          stack_top_p[-1] = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 3112:          *stack_top_p++ = left_value;
    #####: 3113:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3114:          break;
        -: 3115:        }
        1: 3116:        case VM_OC_RETURN:
        -: 3117:        {
        1: 3118:          JERRY_ASSERT (opcode == CBC_RETURN
        -: 3119:                        || opcode == CBC_RETURN_WITH_BLOCK
        -: 3120:                        || opcode == CBC_RETURN_WITH_LITERAL);
        -: 3121:
        1: 3122:          if (opcode == CBC_RETURN_WITH_BLOCK)
        -: 3123:          {
    #####: 3124:            left_value = frame_ctx_p->block_result;
    #####: 3125:            frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;
        -: 3126:          }
        -: 3127:
        1: 3128:          result = left_value;
        1: 3129:          left_value = ECMA_VALUE_UNDEFINED;
        1: 3130:          goto error;
        -: 3131:        }
    #####: 3132:        case VM_OC_THROW:
        -: 3133:        {
    #####: 3134:          jcontext_raise_exception (left_value);
        -: 3135:
    #####: 3136:          result = ECMA_VALUE_ERROR;
    #####: 3137:          left_value = ECMA_VALUE_UNDEFINED;
    #####: 3138:          goto error;
        -: 3139:        }
    #####: 3140:        case VM_OC_THROW_REFERENCE_ERROR:
        -: 3141:        {
    #####: 3142:          result = ecma_raise_reference_error (ECMA_ERR_MSG ("Undefined reference"));
    #####: 3143:          goto error;
        -: 3144:        }
    #####: 3145:        case VM_OC_EVAL:
        -: 3146:        {
    #####: 3147:          JERRY_CONTEXT (status_flags) |= ECMA_STATUS_DIRECT_EVAL;
    #####: 3148:          JERRY_ASSERT ((*byte_code_p >= CBC_CALL && *byte_code_p <= CBC_CALL2_PROP_BLOCK)
        -: 3149:                        || (*byte_code_p == CBC_EXT_OPCODE
        -: 3150:                            && byte_code_p[1] >= CBC_EXT_SPREAD_CALL
        -: 3151:                            && byte_code_p[1] <= CBC_EXT_SPREAD_CALL_PROP_BLOCK));
    #####: 3152:          continue;
        -: 3153:        }
      101: 3154:        case VM_OC_CALL:
        -: 3155:        {
      101: 3156:          frame_ctx_p->call_operation = VM_EXEC_CALL;
      101: 3157:          frame_ctx_p->byte_code_p = byte_code_start_p;
      101: 3158:          frame_ctx_p->stack_top_p = stack_top_p;
      101: 3159:          return ECMA_VALUE_UNDEFINED;
        -: 3160:        }
    #####: 3161:        case VM_OC_NEW:
        -: 3162:        {
    #####: 3163:          frame_ctx_p->call_operation = VM_EXEC_CONSTRUCT;
    #####: 3164:          frame_ctx_p->byte_code_p = byte_code_start_p;
    #####: 3165:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 3166:          return ECMA_VALUE_UNDEFINED;
        -: 3167:        }
    #####: 3168:        case VM_OC_ERROR:
        -: 3169:        {
    #####: 3170:          JERRY_ASSERT (frame_ctx_p->byte_code_p[1] == CBC_EXT_ERROR);
        -: 3171:#if JERRY_DEBUGGER
        -: 3172:          frame_ctx_p->byte_code_p = JERRY_CONTEXT (debugger_exception_byte_code_p);
        -: 3173:#endif /* JERRY_DEBUGGER */
        -: 3174:
    #####: 3175:          result = ECMA_VALUE_ERROR;
    #####: 3176:          goto error;
        -: 3177:        }
    #####: 3178:        case VM_OC_RESOLVE_BASE_FOR_CALL:
        -: 3179:        {
    #####: 3180:          ecma_value_t this_value = stack_top_p[-3];
        -: 3181:
    #####: 3182:          if (this_value == ECMA_VALUE_REGISTER_REF)
        -: 3183:          {
        -: 3184:            /* Lexical environment cannot be 'this' value. */
    #####: 3185:            stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 3186:            stack_top_p[-3] = ECMA_VALUE_UNDEFINED;
        -: 3187:          }
    #####: 3188:          else if (vm_get_implicit_this_value (&this_value))
        -: 3189:          {
    #####: 3190:            ecma_free_value (stack_top_p[-3]);
    #####: 3191:            stack_top_p[-3] = this_value;
        -: 3192:          }
        -: 3193:
    #####: 3194:          continue;
        -: 3195:        }
    #####: 3196:        case VM_OC_PROP_DELETE:
        -: 3197:        {
    #####: 3198:          result = vm_op_delete_prop (left_value, right_value, is_strict);
        -: 3199:
    #####: 3200:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3201:          {
    #####: 3202:            goto error;
        -: 3203:          }
        -: 3204:
    #####: 3205:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3206:
    #####: 3207:          *stack_top_p++ = result;
    #####: 3208:          goto free_both_values;
        -: 3209:        }
    #####: 3210:        case VM_OC_DELETE:
        -: 3211:        {
        -: 3212:          uint16_t literal_index;
        -: 3213:
    #####: 3214:          READ_LITERAL_INDEX (literal_index);
        -: 3215:
    #####: 3216:          if (literal_index < register_end)
        -: 3217:          {
    #####: 3218:            *stack_top_p++ = ECMA_VALUE_FALSE;
    #####: 3219:            continue;
        -: 3220:          }
        -: 3221:
    #####: 3222:          result = vm_op_delete_var (literal_start_p[literal_index],
        -: 3223:                                     frame_ctx_p->lex_env_p);
        -: 3224:
    #####: 3225:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3226:          {
    #####: 3227:            goto error;
        -: 3228:          }
        -: 3229:
    #####: 3230:          JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3231:
    #####: 3232:          *stack_top_p++ = result;
    #####: 3233:          continue;
        -: 3234:        }
        1: 3235:        case VM_OC_JUMP:
        -: 3236:        {
        1: 3237:          byte_code_p = byte_code_start_p + branch_offset;
        1: 3238:          continue;
        -: 3239:        }
    #####: 3240:        case VM_OC_BRANCH_IF_STRICT_EQUAL:
        -: 3241:        {
    #####: 3242:          ecma_value_t value = *(--stack_top_p);
        -: 3243:
    #####: 3244:          JERRY_ASSERT (stack_top_p > VM_GET_REGISTERS (frame_ctx_p) + register_end);
        -: 3245:
    #####: 3246:          if (ecma_op_strict_equality_compare (value, stack_top_p[-1]))
        -: 3247:          {
    #####: 3248:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3249:            ecma_free_value (*--stack_top_p);
        -: 3250:          }
    #####: 3251:          ecma_free_value (value);
    #####: 3252:          continue;
        -: 3253:        }
    #####: 3254:        case VM_OC_BRANCH_IF_TRUE:
        -: 3255:        case VM_OC_BRANCH_IF_FALSE:
        -: 3256:        case VM_OC_BRANCH_IF_LOGICAL_TRUE:
        -: 3257:        case VM_OC_BRANCH_IF_LOGICAL_FALSE:
        -: 3258:        {
    #####: 3259:          uint32_t opcode_flags = VM_OC_GROUP_GET_INDEX (opcode_data) - VM_OC_BRANCH_IF_TRUE;
    #####: 3260:          ecma_value_t value = *(--stack_top_p);
        -: 3261:
    #####: 3262:          bool boolean_value = ecma_op_to_boolean (value);
        -: 3263:
    #####: 3264:          if (opcode_flags & VM_OC_BRANCH_IF_FALSE_FLAG)
        -: 3265:          {
    #####: 3266:            boolean_value = !boolean_value;
        -: 3267:          }
        -: 3268:
    #####: 3269:          if (boolean_value)
        -: 3270:          {
    #####: 3271:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3272:            if (opcode_flags & VM_OC_LOGICAL_BRANCH_FLAG)
        -: 3273:            {
        -: 3274:              /* "Push" the value back to the stack. */
    #####: 3275:              ++stack_top_p;
    #####: 3276:              continue;
        -: 3277:            }
        -: 3278:          }
        -: 3279:
    #####: 3280:          ecma_fast_free_value (value);
    #####: 3281:          continue;
        -: 3282:        }
        -: 3283:#if JERRY_ESNEXT
    #####: 3284:        case VM_OC_BRANCH_IF_NULLISH:
        -: 3285:        {
    #####: 3286:          left_value = stack_top_p[-1];
        -: 3287:
    #####: 3288:          if (!ecma_is_value_null (left_value) && !ecma_is_value_undefined (left_value))
        -: 3289:          {
    #####: 3290:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 3291:            continue;
        -: 3292:          }
    #####: 3293:          --stack_top_p;
    #####: 3294:          continue;
        -: 3295:        }
        -: 3296:#endif /* JERRY_ESNEXT */
    #####: 3297:        case VM_OC_PLUS:
        -: 3298:        case VM_OC_MINUS:
        -: 3299:        {
    #####: 3300:          result = opfunc_unary_operation (left_value, VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_PLUS);
        -: 3301:
    #####: 3302:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3303:          {
    #####: 3304:            goto error;
        -: 3305:          }
        -: 3306:
    #####: 3307:          *stack_top_p++ = result;
    #####: 3308:          goto free_left_value;
        -: 3309:        }
    #####: 3310:        case VM_OC_NOT:
        -: 3311:        {
    #####: 3312:          *stack_top_p++ = ecma_make_boolean_value (!ecma_op_to_boolean (left_value));
    #####: 3313:          JERRY_ASSERT (ecma_is_value_boolean (stack_top_p[-1]));
    #####: 3314:          goto free_left_value;
        -: 3315:        }
    #####: 3316:        case VM_OC_BIT_NOT:
        -: 3317:        {
        -: 3318:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3319:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3320:
    #####: 3321:          if (ecma_is_value_integer_number (left_value))
        -: 3322:          {
    #####: 3323:            *stack_top_p++ = (~ECMA_DIRECT_TYPE_MASK) ^ left_value;
    #####: 3324:            goto free_left_value;
        -: 3325:          }
        -: 3326:
    #####: 3327:          result = do_number_bitwise_not (left_value);
        -: 3328:
    #####: 3329:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3330:          {
    #####: 3331:            goto error;
        -: 3332:          }
        -: 3333:
    #####: 3334:          *stack_top_p++ = result;
    #####: 3335:          goto free_left_value;
        -: 3336:        }
    #####: 3337:        case VM_OC_VOID:
        -: 3338:        {
    #####: 3339:          *stack_top_p++ = ECMA_VALUE_UNDEFINED;
    #####: 3340:          goto free_left_value;
        -: 3341:        }
    #####: 3342:        case VM_OC_TYPEOF_IDENT:
        -: 3343:        {
        -: 3344:          uint16_t literal_index;
        -: 3345:
    #####: 3346:          READ_LITERAL_INDEX (literal_index);
        -: 3347:
    #####: 3348:          JERRY_ASSERT (literal_index < ident_end);
        -: 3349:
    #####: 3350:          if (literal_index < register_end)
        -: 3351:          {
    #####: 3352:            left_value = ecma_copy_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
        -: 3353:          }
        -: 3354:          else
        -: 3355:          {
    #####: 3356:            ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 3357:
    #####: 3358:            ecma_object_t *ref_base_lex_env_p;
        -: 3359:
    #####: 3360:            result = ecma_op_get_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 3361:                                                     &ref_base_lex_env_p,
        -: 3362:                                                     name_p);
        -: 3363:
    #####: 3364:            if (ref_base_lex_env_p == NULL)
        -: 3365:            {
    #####: 3366:              jcontext_release_exception ();
    #####: 3367:              result = ECMA_VALUE_UNDEFINED;
        -: 3368:            }
    #####: 3369:            else if (ECMA_IS_VALUE_ERROR (result))
        -: 3370:            {
    #####: 3371:              goto error;
        -: 3372:            }
        -: 3373:
    #####: 3374:            left_value = result;
        -: 3375:          }
        -: 3376:          /* FALLTHRU */
        -: 3377:        }
        -: 3378:        case VM_OC_TYPEOF:
        -: 3379:        {
    #####: 3380:          result = opfunc_typeof (left_value);
        -: 3381:
    #####: 3382:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3383:          {
    #####: 3384:            goto error;
        -: 3385:          }
        -: 3386:
    #####: 3387:          *stack_top_p++ = result;
    #####: 3388:          goto free_left_value;
        -: 3389:        }
      100: 3390:        case VM_OC_ADD:
        -: 3391:        {
      100: 3392:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3393:          {
    #####: 3394:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3395:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3396:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer + right_integer));
    #####: 3397:            continue;
        -: 3398:          }
        -: 3399:
      100: 3400:          if (ecma_is_value_float_number (left_value)
    #####: 3401:              && ecma_is_value_number (right_value))
        -: 3402:          {
    #####: 3403:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) +
    #####: 3404:                                       ecma_get_number_from_value (right_value));
        -: 3405:
    #####: 3406:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3407:            ecma_free_number (right_value);
    #####: 3408:            continue;
        -: 3409:          }
        -: 3410:
      100: 3411:          if (ecma_is_value_float_number (right_value)
      100: 3412:              && ecma_is_value_integer_number (left_value))
        -: 3413:          {
      200: 3414:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) +
      100: 3415:                                       ecma_get_float_from_value (right_value));
        -: 3416:
      100: 3417:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
      100: 3418:            continue;
        -: 3419:          }
        -: 3420:
    #####: 3421:          result = opfunc_addition (left_value, right_value);
        -: 3422:
    #####: 3423:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3424:          {
    #####: 3425:            goto error;
        -: 3426:          }
        -: 3427:
    #####: 3428:          *stack_top_p++ = result;
    #####: 3429:          goto free_both_values;
        -: 3430:        }
    #####: 3431:        case VM_OC_SUB:
        -: 3432:        {
        -: 3433:          JERRY_STATIC_ASSERT (ECMA_INTEGER_NUMBER_MAX * 2 <= INT32_MAX
        -: 3434:                               && ECMA_INTEGER_NUMBER_MIN * 2 >= INT32_MIN,
        -: 3435:                               doubled_ecma_numbers_must_fit_into_int32_range);
        -: 3436:
    #####: 3437:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3438:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3439:
    #####: 3440:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3441:          {
    #####: 3442:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3443:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3444:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer - right_integer));
    #####: 3445:            continue;
        -: 3446:          }
        -: 3447:
    #####: 3448:          if (ecma_is_value_float_number (left_value)
    #####: 3449:              && ecma_is_value_number (right_value))
        -: 3450:          {
    #####: 3451:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) -
    #####: 3452:                                       ecma_get_number_from_value (right_value));
        -: 3453:
    #####: 3454:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3455:            ecma_free_number (right_value);
    #####: 3456:            continue;
        -: 3457:          }
        -: 3458:
    #####: 3459:          if (ecma_is_value_float_number (right_value)
    #####: 3460:              && ecma_is_value_integer_number (left_value))
        -: 3461:          {
    #####: 3462:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) -
    #####: 3463:                                       ecma_get_float_from_value (right_value));
        -: 3464:
    #####: 3465:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3466:            continue;
        -: 3467:          }
        -: 3468:
    #####: 3469:          result = do_number_arithmetic (NUMBER_ARITHMETIC_SUBTRACTION,
        -: 3470:                                         left_value,
        -: 3471:                                         right_value);
        -: 3472:
    #####: 3473:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3474:          {
    #####: 3475:            goto error;
        -: 3476:          }
        -: 3477:
    #####: 3478:          *stack_top_p++ = result;
    #####: 3479:          goto free_both_values;
        -: 3480:        }
    #####: 3481:        case VM_OC_MUL:
        -: 3482:        {
    #####: 3483:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3484:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3485:
        -: 3486:          JERRY_STATIC_ASSERT (ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX <= ECMA_INTEGER_NUMBER_MAX
        -: 3487:                               && -(ECMA_INTEGER_MULTIPLY_MAX * ECMA_INTEGER_MULTIPLY_MAX) >= ECMA_INTEGER_NUMBER_MIN,
        -: 3488:                               square_of_integer_multiply_max_must_fit_into_integer_value_range);
        -: 3489:
    #####: 3490:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3491:          {
    #####: 3492:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3493:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3494:
    #####: 3495:            if (-ECMA_INTEGER_MULTIPLY_MAX <= left_integer
    #####: 3496:                && left_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3497:                && -ECMA_INTEGER_MULTIPLY_MAX <= right_integer
    #####: 3498:                && right_integer <= ECMA_INTEGER_MULTIPLY_MAX
    #####: 3499:                && left_integer != 0
    #####: 3500:                && right_integer != 0)
        -: 3501:            {
    #####: 3502:              *stack_top_p++ = ecma_integer_multiply (left_integer, right_integer);
    #####: 3503:              continue;
        -: 3504:            }
        -: 3505:
    #####: 3506:            ecma_number_t multiply = (ecma_number_t) left_integer * (ecma_number_t) right_integer;
    #####: 3507:            *stack_top_p++ = ecma_make_number_value (multiply);
    #####: 3508:            continue;
        -: 3509:          }
        -: 3510:
    #####: 3511:          if (ecma_is_value_float_number (left_value)
    #####: 3512:              && ecma_is_value_number (right_value))
        -: 3513:          {
    #####: 3514:            ecma_number_t new_value = (ecma_get_float_from_value (left_value) *
    #####: 3515:                                       ecma_get_number_from_value (right_value));
        -: 3516:
    #####: 3517:            *stack_top_p++ = ecma_update_float_number (left_value, new_value);
    #####: 3518:            ecma_free_number (right_value);
    #####: 3519:            continue;
        -: 3520:          }
        -: 3521:
    #####: 3522:          if (ecma_is_value_float_number (right_value)
    #####: 3523:              && ecma_is_value_integer_number (left_value))
        -: 3524:          {
    #####: 3525:            ecma_number_t new_value = ((ecma_number_t) ecma_get_integer_from_value (left_value) *
    #####: 3526:                                       ecma_get_float_from_value (right_value));
        -: 3527:
    #####: 3528:            *stack_top_p++ = ecma_update_float_number (right_value, new_value);
    #####: 3529:            continue;
        -: 3530:          }
        -: 3531:
    #####: 3532:          result = do_number_arithmetic (NUMBER_ARITHMETIC_MULTIPLICATION,
        -: 3533:                                         left_value,
        -: 3534:                                         right_value);
        -: 3535:
    #####: 3536:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3537:          {
    #####: 3538:            goto error;
        -: 3539:          }
        -: 3540:
    #####: 3541:          *stack_top_p++ = result;
    #####: 3542:          goto free_both_values;
        -: 3543:        }
    #####: 3544:        case VM_OC_DIV:
        -: 3545:        {
    #####: 3546:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3547:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3548:
    #####: 3549:          result = do_number_arithmetic (NUMBER_ARITHMETIC_DIVISION,
        -: 3550:                                         left_value,
        -: 3551:                                         right_value);
        -: 3552:
    #####: 3553:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3554:          {
    #####: 3555:            goto error;
        -: 3556:          }
        -: 3557:
    #####: 3558:          *stack_top_p++ = result;
    #####: 3559:          goto free_both_values;
        -: 3560:        }
    #####: 3561:        case VM_OC_MOD:
        -: 3562:        {
    #####: 3563:          JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (left_value)
        -: 3564:                        && !ECMA_IS_VALUE_ERROR (right_value));
        -: 3565:
    #####: 3566:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3567:          {
    #####: 3568:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3569:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
        -: 3570:
    #####: 3571:            if (right_integer != 0)
        -: 3572:            {
    #####: 3573:              ecma_integer_value_t mod_result = left_integer % right_integer;
        -: 3574:
    #####: 3575:              if (mod_result != 0 || left_integer >= 0)
        -: 3576:              {
    #####: 3577:                *stack_top_p++ = ecma_make_integer_value (mod_result);
    #####: 3578:                continue;
        -: 3579:              }
        -: 3580:            }
        -: 3581:          }
        -: 3582:
    #####: 3583:          result = do_number_arithmetic (NUMBER_ARITHMETIC_REMAINDER,
        -: 3584:                                         left_value,
        -: 3585:                                         right_value);
        -: 3586:
    #####: 3587:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3588:          {
    #####: 3589:            goto error;
        -: 3590:          }
        -: 3591:
    #####: 3592:          *stack_top_p++ = result;
    #####: 3593:          goto free_both_values;
        -: 3594:        }
        -: 3595:#if JERRY_ESNEXT
    #####: 3596:        case VM_OC_EXP:
        -: 3597:        {
    #####: 3598:          result = do_number_arithmetic (NUMBER_ARITHMETIC_EXPONENTIATION,
        -: 3599:                                         left_value,
        -: 3600:                                         right_value);
        -: 3601:
    #####: 3602:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3603:          {
    #####: 3604:            goto error;
        -: 3605:          }
        -: 3606:
    #####: 3607:          *stack_top_p++ = result;
    #####: 3608:          goto free_both_values;
        -: 3609:        }
        -: 3610:#endif /* JERRY_ESNEXT */
    #####: 3611:        case VM_OC_EQUAL:
        -: 3612:        {
    #####: 3613:          result = opfunc_equality (left_value, right_value);
        -: 3614:
    #####: 3615:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3616:          {
    #####: 3617:            goto error;
        -: 3618:          }
        -: 3619:
    #####: 3620:          *stack_top_p++ = result;
    #####: 3621:          goto free_both_values;
        -: 3622:        }
    #####: 3623:        case VM_OC_NOT_EQUAL:
        -: 3624:        {
    #####: 3625:          result = opfunc_equality (left_value, right_value);
        -: 3626:
    #####: 3627:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3628:          {
    #####: 3629:            goto error;
        -: 3630:          }
        -: 3631:
    #####: 3632:          *stack_top_p++ = ecma_invert_boolean_value (result);
    #####: 3633:          goto free_both_values;
        -: 3634:        }
    #####: 3635:        case VM_OC_STRICT_EQUAL:
        -: 3636:        {
    #####: 3637:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3638:
    #####: 3639:          result = ecma_make_boolean_value (is_equal);
        -: 3640:
    #####: 3641:          *stack_top_p++ = result;
    #####: 3642:          goto free_both_values;
        -: 3643:        }
    #####: 3644:        case VM_OC_STRICT_NOT_EQUAL:
        -: 3645:        {
    #####: 3646:          bool is_equal = ecma_op_strict_equality_compare (left_value, right_value);
        -: 3647:
    #####: 3648:          result = ecma_make_boolean_value (!is_equal);
        -: 3649:
    #####: 3650:          *stack_top_p++ = result;
    #####: 3651:          goto free_both_values;
        -: 3652:        }
    #####: 3653:        case VM_OC_BIT_OR:
        -: 3654:        {
        -: 3655:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3656:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3657:
    #####: 3658:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3659:          {
    #####: 3660:            *stack_top_p++ = left_value | right_value;
    #####: 3661:            continue;
        -: 3662:          }
        -: 3663:
    #####: 3664:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_OR,
        -: 3665:                                            left_value,
        -: 3666:                                            right_value);
        -: 3667:
    #####: 3668:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3669:          {
    #####: 3670:            goto error;
        -: 3671:          }
        -: 3672:
    #####: 3673:          *stack_top_p++ = result;
    #####: 3674:          goto free_both_values;
        -: 3675:        }
    #####: 3676:        case VM_OC_BIT_XOR:
        -: 3677:        {
        -: 3678:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3679:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3680:
    #####: 3681:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3682:          {
    #####: 3683:            *stack_top_p++ = left_value ^ right_value;
    #####: 3684:            continue;
        -: 3685:          }
        -: 3686:
    #####: 3687:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_XOR,
        -: 3688:                                            left_value,
        -: 3689:                                            right_value);
        -: 3690:
    #####: 3691:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3692:          {
    #####: 3693:            goto error;
        -: 3694:          }
        -: 3695:
    #####: 3696:          *stack_top_p++ = result;
    #####: 3697:          goto free_both_values;
        -: 3698:        }
    #####: 3699:        case VM_OC_BIT_AND:
        -: 3700:        {
        -: 3701:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3702:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3703:
    #####: 3704:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3705:          {
    #####: 3706:            *stack_top_p++ = left_value & right_value;
    #####: 3707:            continue;
        -: 3708:          }
        -: 3709:
    #####: 3710:          result = do_number_bitwise_logic (NUMBER_BITWISE_LOGIC_AND,
        -: 3711:                                            left_value,
        -: 3712:                                            right_value);
        -: 3713:
    #####: 3714:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3715:          {
    #####: 3716:            goto error;
        -: 3717:          }
        -: 3718:
    #####: 3719:          *stack_top_p++ = result;
    #####: 3720:          goto free_both_values;
        -: 3721:        }
    #####: 3722:        case VM_OC_LEFT_SHIFT:
        -: 3723:        {
        -: 3724:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3725:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3726:
    #####: 3727:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3728:          {
    #####: 3729:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3730:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3731:            *stack_top_p++ = ecma_make_int32_value ((int32_t) (left_integer << (right_integer & 0x1f)));
    #####: 3732:            continue;
        -: 3733:          }
        -: 3734:
    #####: 3735:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_LEFT,
        -: 3736:                                            left_value,
        -: 3737:                                            right_value);
        -: 3738:
    #####: 3739:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3740:          {
    #####: 3741:            goto error;
        -: 3742:          }
        -: 3743:
    #####: 3744:          *stack_top_p++ = result;
    #####: 3745:          goto free_both_values;
        -: 3746:        }
    #####: 3747:        case VM_OC_RIGHT_SHIFT:
        -: 3748:        {
        -: 3749:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3750:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3751:
    #####: 3752:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3753:          {
    #####: 3754:            ecma_integer_value_t left_integer = ecma_get_integer_from_value (left_value);
    #####: 3755:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3756:            *stack_top_p++ = ecma_make_integer_value (left_integer >> (right_integer & 0x1f));
    #####: 3757:            continue;
        -: 3758:          }
        -: 3759:
    #####: 3760:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_RIGHT,
        -: 3761:                                            left_value,
        -: 3762:                                            right_value);
        -: 3763:
    #####: 3764:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3765:          {
    #####: 3766:            goto error;
        -: 3767:          }
        -: 3768:
    #####: 3769:          *stack_top_p++ = result;
    #####: 3770:          goto free_both_values;
        -: 3771:        }
    #####: 3772:        case VM_OC_UNS_RIGHT_SHIFT:
        -: 3773:        {
        -: 3774:          JERRY_STATIC_ASSERT (ECMA_DIRECT_TYPE_MASK == ((1 << ECMA_DIRECT_SHIFT) - 1),
        -: 3775:                               direct_type_mask_must_fill_all_bits_before_the_value_starts);
        -: 3776:
    #####: 3777:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3778:          {
    #####: 3779:            uint32_t left_uint32 = (uint32_t) ecma_get_integer_from_value (left_value);
    #####: 3780:            ecma_integer_value_t right_integer = ecma_get_integer_from_value (right_value);
    #####: 3781:            *stack_top_p++ = ecma_make_uint32_value (left_uint32 >> (right_integer & 0x1f));
    #####: 3782:            continue;
        -: 3783:          }
        -: 3784:
    #####: 3785:          result = do_number_bitwise_logic (NUMBER_BITWISE_SHIFT_URIGHT,
        -: 3786:                                            left_value,
        -: 3787:                                            right_value);
        -: 3788:
    #####: 3789:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3790:          {
    #####: 3791:            goto error;
        -: 3792:          }
        -: 3793:
    #####: 3794:          *stack_top_p++ = result;
    #####: 3795:          goto free_both_values;
        -: 3796:        }
      101: 3797:        case VM_OC_LESS:
        -: 3798:        {
      101: 3799:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3800:          {
      101: 3801:            bool is_less = (ecma_integer_value_t) left_value < (ecma_integer_value_t) right_value;
        -: 3802:#if !JERRY_VM_EXEC_STOP
        -: 3803:            /* This is a lookahead to the next opcode to improve performance.
        -: 3804:             * If it is CBC_BRANCH_IF_TRUE_BACKWARD, execute it. */
      101: 3805:            if (*byte_code_p <= CBC_BRANCH_IF_TRUE_BACKWARD_3 && *byte_code_p >= CBC_BRANCH_IF_TRUE_BACKWARD)
        -: 3806:            {
      101: 3807:              byte_code_start_p = byte_code_p++;
      101: 3808:              branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (*byte_code_start_p);
      101: 3809:              JERRY_ASSERT (branch_offset_length >= 1 && branch_offset_length <= 3);
        -: 3810:
      101: 3811:              if (is_less)
        -: 3812:              {
      100: 3813:                branch_offset = *(byte_code_p++);
        -: 3814:
      100: 3815:                if (JERRY_UNLIKELY (branch_offset_length != 1))
        -: 3816:                {
    #####: 3817:                  branch_offset <<= 8;
    #####: 3818:                  branch_offset |= *(byte_code_p++);
    #####: 3819:                  if (JERRY_UNLIKELY (branch_offset_length == 3))
        -: 3820:                  {
    #####: 3821:                    branch_offset <<= 8;
    #####: 3822:                    branch_offset |= *(byte_code_p++);
        -: 3823:                  }
        -: 3824:                }
        -: 3825:
        -: 3826:                /* Note: The opcode is a backward branch. */
      100: 3827:                byte_code_p = byte_code_start_p - branch_offset;
        -: 3828:              }
        -: 3829:              else
        -: 3830:              {
        1: 3831:                byte_code_p += branch_offset_length;
        -: 3832:              }
        -: 3833:
      101: 3834:              continue;
        -: 3835:            }
        -: 3836:#endif /* !JERRY_VM_EXEC_STOP */
    #####: 3837:            *stack_top_p++ = ecma_make_boolean_value (is_less);
    #####: 3838:            continue;
        -: 3839:          }
        -: 3840:
    #####: 3841:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3842:          {
    #####: 3843:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3844:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3845:
    #####: 3846:            *stack_top_p++ = ecma_make_boolean_value (left_number < right_number);
    #####: 3847:            goto free_both_values;
        -: 3848:          }
        -: 3849:
    #####: 3850:          result = opfunc_relation (left_value, right_value, true, false);
        -: 3851:
    #####: 3852:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3853:          {
    #####: 3854:            goto error;
        -: 3855:          }
        -: 3856:
    #####: 3857:          *stack_top_p++ = result;
    #####: 3858:          goto free_both_values;
        -: 3859:        }
    #####: 3860:        case VM_OC_GREATER:
        -: 3861:        {
    #####: 3862:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3863:          {
    #####: 3864:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3865:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3866:
    #####: 3867:            *stack_top_p++ = ecma_make_boolean_value (left_integer > right_integer);
    #####: 3868:            continue;
        -: 3869:          }
        -: 3870:
    #####: 3871:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3872:          {
    #####: 3873:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3874:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3875:
    #####: 3876:            *stack_top_p++ = ecma_make_boolean_value (left_number > right_number);
    #####: 3877:            goto free_both_values;
        -: 3878:          }
        -: 3879:
    #####: 3880:          result = opfunc_relation (left_value, right_value, false, false);
        -: 3881:
    #####: 3882:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3883:          {
    #####: 3884:            goto error;
        -: 3885:          }
        -: 3886:
    #####: 3887:          *stack_top_p++ = result;
    #####: 3888:          goto free_both_values;
        -: 3889:        }
    #####: 3890:        case VM_OC_LESS_EQUAL:
        -: 3891:        {
    #####: 3892:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3893:          {
    #####: 3894:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3895:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3896:
    #####: 3897:            *stack_top_p++ = ecma_make_boolean_value (left_integer <= right_integer);
    #####: 3898:            continue;
        -: 3899:          }
        -: 3900:
    #####: 3901:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3902:          {
    #####: 3903:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3904:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3905:
    #####: 3906:            *stack_top_p++ = ecma_make_boolean_value (left_number <= right_number);
    #####: 3907:            goto free_both_values;
        -: 3908:          }
        -: 3909:
    #####: 3910:          result = opfunc_relation (left_value, right_value, false, true);
        -: 3911:
    #####: 3912:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3913:          {
    #####: 3914:            goto error;
        -: 3915:          }
        -: 3916:
    #####: 3917:          *stack_top_p++ = result;
    #####: 3918:          goto free_both_values;
        -: 3919:        }
    #####: 3920:        case VM_OC_GREATER_EQUAL:
        -: 3921:        {
    #####: 3922:          if (ecma_are_values_integer_numbers (left_value, right_value))
        -: 3923:          {
    #####: 3924:            ecma_integer_value_t left_integer = (ecma_integer_value_t) left_value;
    #####: 3925:            ecma_integer_value_t right_integer = (ecma_integer_value_t) right_value;
        -: 3926:
    #####: 3927:            *stack_top_p++ = ecma_make_boolean_value (left_integer >= right_integer);
    #####: 3928:            continue;
        -: 3929:          }
        -: 3930:
    #####: 3931:          if (ecma_is_value_number (left_value) && ecma_is_value_number (right_value))
        -: 3932:          {
    #####: 3933:            ecma_number_t left_number = ecma_get_number_from_value (left_value);
    #####: 3934:            ecma_number_t right_number = ecma_get_number_from_value (right_value);
        -: 3935:
    #####: 3936:            *stack_top_p++ = ecma_make_boolean_value (left_number >= right_number);
    #####: 3937:            goto free_both_values;
        -: 3938:          }
        -: 3939:
    #####: 3940:          result = opfunc_relation (left_value, right_value, true, true);
        -: 3941:
    #####: 3942:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3943:          {
    #####: 3944:            goto error;
        -: 3945:          }
        -: 3946:
    #####: 3947:          *stack_top_p++ = result;
    #####: 3948:          goto free_both_values;
        -: 3949:        }
    #####: 3950:        case VM_OC_IN:
        -: 3951:        {
    #####: 3952:          result = opfunc_in (left_value, right_value);
        -: 3953:
    #####: 3954:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3955:          {
    #####: 3956:            goto error;
        -: 3957:          }
        -: 3958:
    #####: 3959:          *stack_top_p++ = result;
    #####: 3960:          goto free_both_values;
        -: 3961:        }
    #####: 3962:        case VM_OC_INSTANCEOF:
        -: 3963:        {
    #####: 3964:          result = opfunc_instanceof (left_value, right_value);
        -: 3965:
    #####: 3966:          if (ECMA_IS_VALUE_ERROR (result))
        -: 3967:          {
    #####: 3968:            goto error;
        -: 3969:          }
        -: 3970:
    #####: 3971:          *stack_top_p++ = result;
    #####: 3972:          goto free_both_values;
        -: 3973:        }
    #####: 3974:        case VM_OC_BLOCK_CREATE_CONTEXT:
        -: 3975:        {
        -: 3976:#if JERRY_ESNEXT
        -: 3977:          ecma_value_t *stack_context_top_p;
    #####: 3978:          stack_context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 3979:
    #####: 3980:          JERRY_ASSERT (stack_context_top_p == stack_top_p || stack_context_top_p == stack_top_p - 1);
        -: 3981:
    #####: 3982:          if (byte_code_start_p[0] != CBC_EXT_OPCODE)
        -: 3983:          {
    #####: 3984:            branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 3985:
    #####: 3986:            if (stack_context_top_p != stack_top_p)
        -: 3987:            {
        -: 3988:               /* Preserve the value of switch statement. */
    #####: 3989:              stack_context_top_p[1] = stack_context_top_p[0];
        -: 3990:            }
        -: 3991:
    #####: 3992:            stack_context_top_p[0] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_BLOCK, branch_offset);
        -: 3993:
    #####: 3994:            VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
    #####: 3995:            stack_top_p += PARSER_BLOCK_CONTEXT_STACK_ALLOCATION;
        -: 3996:          }
        -: 3997:          else
        -: 3998:          {
    #####: 3999:            JERRY_ASSERT (byte_code_start_p[1] == CBC_EXT_TRY_CREATE_ENV);
        -: 4000:
    #####: 4001:            JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_TRY
        -: 4002:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_CATCH
        -: 4003:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP
        -: 4004:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_THROW
        -: 4005:                          || VM_GET_CONTEXT_TYPE (stack_context_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
        -: 4006:
    #####: 4007:            JERRY_ASSERT (!(stack_context_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4008:
    #####: 4009:            stack_context_top_p[-1] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4010:          }
        -: 4011:#else /* !JERRY_ESNEXT */
        -: 4012:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-2]) == VM_CONTEXT_CATCH
        -: 4013:                        && !(stack_top_p[-2] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4014:
    #####: 4015:          stack_top_p[-2] |= VM_CONTEXT_HAS_LEX_ENV;
        -: 4016:#endif /* JERRY_ESNEXT */
        -: 4017:
    #####: 4018:          frame_ctx_p->lex_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
    #####: 4019:          frame_ctx_p->lex_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        -: 4020:
    #####: 4021:          continue;
        -: 4022:        }
    #####: 4023:        case VM_OC_WITH:
        -: 4024:        {
    #####: 4025:          ecma_value_t value = *(--stack_top_p);
        -: 4026:          ecma_object_t *object_p;
        -: 4027:          ecma_object_t *with_env_p;
        -: 4028:
    #####: 4029:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4030:
    #####: 4031:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4032:
    #####: 4033:          result = ecma_op_to_object (value);
    #####: 4034:          ecma_free_value (value);
        -: 4035:
    #####: 4036:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4037:          {
    #####: 4038:            goto error;
        -: 4039:          }
        -: 4040:
    #####: 4041:          object_p = ecma_get_object_from_value (result);
        -: 4042:
    #####: 4043:          with_env_p = ecma_create_object_lex_env (frame_ctx_p->lex_env_p, object_p);
    #####: 4044:          ecma_deref_object (object_p);
        -: 4045:
    #####: 4046:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
    #####: 4047:          stack_top_p += PARSER_WITH_CONTEXT_STACK_ALLOCATION;
        -: 4048:
    #####: 4049:          stack_top_p[-1] = VM_CREATE_CONTEXT_WITH_ENV (VM_CONTEXT_WITH, branch_offset);
        -: 4050:
    #####: 4051:          with_env_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
    #####: 4052:          frame_ctx_p->lex_env_p = with_env_p;
    #####: 4053:          continue;
        -: 4054:        }
    #####: 4055:        case VM_OC_FOR_IN_INIT:
        -: 4056:        {
    #####: 4057:          ecma_value_t value = *(--stack_top_p);
        -: 4058:
    #####: 4059:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4060:
    #####: 4061:          ecma_value_t expr_obj_value = ECMA_VALUE_UNDEFINED;
    #####: 4062:          ecma_collection_t *prop_names_p = opfunc_for_in (value, &expr_obj_value);
    #####: 4063:          ecma_free_value (value);
        -: 4064:
    #####: 4065:          if (prop_names_p == NULL)
        -: 4066:          {
        -: 4067:#if JERRY_ESNEXT
    #####: 4068:            if (JERRY_UNLIKELY (ECMA_IS_VALUE_ERROR (expr_obj_value)))
        -: 4069:            {
    #####: 4070:              result = expr_obj_value;
    #####: 4071:              goto error;
        -: 4072:            }
        -: 4073:#endif /* JERRY_ESNEXT */
        -: 4074:
        -: 4075:            /* The collection is already released */
    #####: 4076:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4077:            continue;
        -: 4078:          }
        -: 4079:
    #####: 4080:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4081:
    #####: 4082:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4083:          stack_top_p += PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
    #####: 4084:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_IN, branch_offset);
    #####: 4085:          ECMA_SET_INTERNAL_VALUE_ANY_POINTER (stack_top_p[-2], prop_names_p);
    #####: 4086:          stack_top_p[-3] = 0;
    #####: 4087:          stack_top_p[-4] = expr_obj_value;
        -: 4088:
        -: 4089:#if JERRY_ESNEXT
    #####: 4090:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4091:          {
        -: 4092:            /* No need to duplicate the first context. */
    #####: 4093:            byte_code_p += 2;
        -: 4094:          }
        -: 4095:#endif /* JERRY_ESNEXT */
    #####: 4096:          continue;
        -: 4097:        }
    #####: 4098:        case VM_OC_FOR_IN_GET_NEXT:
        -: 4099:        {
    #####: 4100:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4101:
        -: 4102:          ecma_collection_t *collection_p;
    #####: 4103:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_top_p[-2]);
        -: 4104:
    #####: 4105:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4106:
    #####: 4107:          uint32_t index = context_top_p[-3];
    #####: 4108:          ecma_value_t *buffer_p = collection_p->buffer_p;
        -: 4109:
    #####: 4110:          *stack_top_p++ = buffer_p[index];
    #####: 4111:          context_top_p[-3]++;
    #####: 4112:          continue;
        -: 4113:        }
    #####: 4114:        case VM_OC_FOR_IN_HAS_NEXT:
        -: 4115:        {
    #####: 4116:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4117:
        -: 4118:          ecma_collection_t *collection_p;
    #####: 4119:          collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, stack_top_p[-2]);
        -: 4120:
    #####: 4121:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_IN);
        -: 4122:
    #####: 4123:          ecma_value_t *buffer_p = collection_p->buffer_p;
    #####: 4124:          ecma_object_t *object_p = ecma_get_object_from_value (stack_top_p[-4]);
    #####: 4125:          uint32_t index = stack_top_p[-3];
        -: 4126:
    #####: 4127:          while (index < collection_p->item_count)
        -: 4128:          {
    #####: 4129:            ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (buffer_p[index]);
        -: 4130:
    #####: 4131:            result = ecma_op_object_has_property (object_p, prop_name_p);
        -: 4132:
    #####: 4133:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4134:            {
    #####: 4135:              goto error;
        -: 4136:            }
        -: 4137:
    #####: 4138:            if (JERRY_LIKELY (ecma_is_value_true (result)))
        -: 4139:            {
    #####: 4140:              byte_code_p = byte_code_start_p + branch_offset;
    #####: 4141:              break;
        -: 4142:            }
        -: 4143:
    #####: 4144:            ecma_deref_ecma_string (prop_name_p);
    #####: 4145:            index++;
        -: 4146:          }
        -: 4147:
    #####: 4148:          if (index == collection_p->item_count)
        -: 4149:          {
    #####: 4150:            ecma_deref_object (object_p);
    #####: 4151:            ecma_collection_destroy (collection_p);
    #####: 4152:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION);
    #####: 4153:            stack_top_p -= PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 4154:          }
        -: 4155:          else
        -: 4156:          {
    #####: 4157:            stack_top_p[-3] = index;
        -: 4158:          }
    #####: 4159:          continue;
        -: 4160:        }
        -: 4161:#if JERRY_ESNEXT
    #####: 4162:        case VM_OC_FOR_OF_INIT:
        -: 4163:        {
    #####: 4164:          ecma_value_t value = *(--stack_top_p);
        -: 4165:
    #####: 4166:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4167:
    #####: 4168:          ecma_value_t next_method;
    #####: 4169:          ecma_value_t iterator = ecma_op_get_iterator (value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -: 4170:
    #####: 4171:          ecma_free_value (value);
        -: 4172:
    #####: 4173:          if (ECMA_IS_VALUE_ERROR (iterator))
        -: 4174:          {
    #####: 4175:            result = iterator;
    #####: 4176:            goto error;
        -: 4177:          }
        -: 4178:
    #####: 4179:          result = ecma_op_iterator_step (iterator, next_method);
        -: 4180:
    #####: 4181:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4182:          {
    #####: 4183:            ecma_free_value (iterator);
    #####: 4184:            ecma_free_value (next_method);
    #####: 4185:            goto error;
        -: 4186:          }
        -: 4187:
    #####: 4188:          if (ecma_is_value_false (result))
        -: 4189:          {
    #####: 4190:            ecma_free_value (iterator);
    #####: 4191:            ecma_free_value (next_method);
    #####: 4192:            byte_code_p = byte_code_start_p + branch_offset;
    #####: 4193:            continue;
        -: 4194:          }
        -: 4195:
    #####: 4196:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4197:          ecma_free_value (result);
        -: 4198:
    #####: 4199:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4200:          {
    #####: 4201:            result = next_value;
    #####: 4202:            ecma_free_value (iterator);
    #####: 4203:            ecma_free_value (next_method);
    #####: 4204:            goto error;
        -: 4205:          }
        -: 4206:
    #####: 4207:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4208:
    #####: 4209:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4210:          stack_top_p += PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4211:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_OF, branch_offset) | VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4212:          stack_top_p[-2] = next_value;
    #####: 4213:          stack_top_p[-3] = iterator;
    #####: 4214:          stack_top_p[-4] = next_method;
        -: 4215:
    #####: 4216:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4217:          {
        -: 4218:            /* No need to duplicate the first context. */
    #####: 4219:            byte_code_p += 2;
        -: 4220:          }
    #####: 4221:          continue;
        -: 4222:        }
    #####: 4223:        case VM_OC_FOR_OF_GET_NEXT:
        -: 4224:        {
    #####: 4225:          ecma_value_t *context_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
    #####: 4226:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_OF
        -: 4227:                        || VM_GET_CONTEXT_TYPE (context_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4228:          JERRY_ASSERT (context_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4229:
    #####: 4230:          *stack_top_p++ = context_top_p[-2];
    #####: 4231:          context_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4232:          continue;
        -: 4233:        }
    #####: 4234:        case VM_OC_FOR_OF_HAS_NEXT:
        -: 4235:        {
    #####: 4236:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4237:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_OF);
    #####: 4238:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4239:
    #####: 4240:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4241:          result = ecma_op_iterator_step (stack_top_p[-3], stack_top_p[-4]);
        -: 4242:
    #####: 4243:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4244:          {
    #####: 4245:            goto error;
        -: 4246:          }
        -: 4247:
    #####: 4248:          if (ecma_is_value_false (result))
        -: 4249:          {
    #####: 4250:            ecma_free_value (stack_top_p[-2]);
    #####: 4251:            ecma_free_value (stack_top_p[-3]);
    #####: 4252:            ecma_free_value (stack_top_p[-4]);
    #####: 4253:            VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4254:            stack_top_p -= PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4255:            continue;
        -: 4256:          }
        -: 4257:
    #####: 4258:          ecma_value_t next_value = ecma_op_iterator_value (result);
    #####: 4259:          ecma_free_value (result);
        -: 4260:
    #####: 4261:          if (ECMA_IS_VALUE_ERROR (next_value))
        -: 4262:          {
    #####: 4263:            result = next_value;
    #####: 4264:            goto error;
        -: 4265:          }
        -: 4266:
    #####: 4267:          JERRY_ASSERT (stack_top_p[-2] == ECMA_VALUE_UNDEFINED);
    #####: 4268:          stack_top_p[-1] |= VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4269:          stack_top_p[-2] = next_value;
    #####: 4270:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4271:          continue;
        -: 4272:        }
    #####: 4273:        case VM_OC_FOR_AWAIT_OF_INIT:
        -: 4274:        {
    #####: 4275:          ecma_value_t value = *(--stack_top_p);
        -: 4276:
    #####: 4277:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4278:
    #####: 4279:          ecma_value_t next_method;
    #####: 4280:          result = ecma_op_get_iterator (value, ECMA_VALUE_ASYNC_ITERATOR, &next_method);
        -: 4281:
    #####: 4282:          ecma_free_value (value);
        -: 4283:
    #####: 4284:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4285:          {
    #####: 4286:            goto error;
        -: 4287:          }
        -: 4288:
    #####: 4289:          ecma_value_t iterator = result;
    #####: 4290:          result = ecma_op_iterator_next (result, next_method, ECMA_VALUE_EMPTY);
        -: 4291:
    #####: 4292:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4293:          {
    #####: 4294:            ecma_free_value (iterator);
    #####: 4295:            ecma_free_value (next_method);
    #####: 4296:            goto error;
        -: 4297:          }
        -: 4298:
    #####: 4299:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4300:
    #####: 4301:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
    #####: 4302:          stack_top_p += PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION;
    #####: 4303:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FOR_AWAIT_OF, branch_offset);
    #####: 4304:          stack_top_p[-2] = ECMA_VALUE_UNDEFINED;
    #####: 4305:          stack_top_p[-3] = iterator;
    #####: 4306:          stack_top_p[-4] = next_method;
        -: 4307:
    #####: 4308:          if (byte_code_p[0] == CBC_EXT_OPCODE && byte_code_p[1] == CBC_EXT_CLONE_CONTEXT)
        -: 4309:          {
        -: 4310:            /* No need to duplicate the first context. */
    #####: 4311:            byte_code_p += 2;
        -: 4312:          }
        -: 4313:
    #####: 4314:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4315:          frame_ctx_p->byte_code_p = byte_code_p;
    #####: 4316:          frame_ctx_p->stack_top_p = stack_top_p;
        -: 4317:
    #####: 4318:          uint16_t extra_flags = (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD
        -: 4319:                                  | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
        -: 4320:
    #####: 4321:          if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR
    #####: 4322:              || frame_ctx_p->block_result != ECMA_VALUE_UNDEFINED)
        -: 4323:          {
    #####: 4324:            ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4325:            result = ecma_promise_async_await (executable_object_p, result);
        -: 4326:
    #####: 4327:            if (ECMA_IS_VALUE_ERROR (result))
        -: 4328:            {
    #####: 4329:              goto error;
        -: 4330:            }
        -: 4331:
    #####: 4332:            executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
    #####: 4333:            return ECMA_VALUE_UNDEFINED;
        -: 4334:          }
        -: 4335:
    #####: 4336:          result = opfunc_async_create_and_await (frame_ctx_p, result, extra_flags);
        -: 4337:
    #####: 4338:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4339:          {
    #####: 4340:            goto error;
        -: 4341:          }
    #####: 4342:          return result;
        -: 4343:        }
    #####: 4344:        case VM_OC_FOR_AWAIT_OF_HAS_NEXT:
        -: 4345:        {
    #####: 4346:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4347:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FOR_AWAIT_OF);
    #####: 4348:          JERRY_ASSERT (stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR);
        -: 4349:
    #####: 4350:          stack_top_p[-1] &= (uint32_t) ~VM_CONTEXT_CLOSE_ITERATOR;
    #####: 4351:          result = ecma_op_iterator_next (stack_top_p[-3], stack_top_p[-4], ECMA_VALUE_EMPTY);
        -: 4352:
    #####: 4353:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4354:          {
    #####: 4355:            goto error;
        -: 4356:          }
        -: 4357:
    #####: 4358:          ecma_extended_object_t *executable_object_p = VM_GET_EXECUTABLE_OBJECT (frame_ctx_p);
    #####: 4359:          result = ecma_promise_async_await (executable_object_p, result);
        -: 4360:
    #####: 4361:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4362:          {
    #####: 4363:            goto error;
        -: 4364:          }
        -: 4365:
    #####: 4366:          uint16_t extra_flags = (ECMA_EXECUTABLE_OBJECT_DO_AWAIT_OR_YIELD
        -: 4367:                                 | (ECMA_AWAIT_FOR_NEXT << ECMA_AWAIT_STATE_SHIFT));
    #####: 4368:          executable_object_p->u.cls.u2.executable_obj_flags |= extra_flags;
        -: 4369:
    #####: 4370:          frame_ctx_p->call_operation = VM_EXEC_RETURN;
    #####: 4371:          frame_ctx_p->byte_code_p = byte_code_start_p + branch_offset;
    #####: 4372:          frame_ctx_p->stack_top_p = stack_top_p;
    #####: 4373:          return ECMA_VALUE_UNDEFINED;
        -: 4374:        }
        -: 4375:#endif /* JERRY_ESNEXT */
    #####: 4376:        case VM_OC_TRY:
        -: 4377:        {
        -: 4378:          /* Try opcode simply creates the try context. */
    #####: 4379:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4380:
    #####: 4381:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4382:
    #####: 4383:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
    #####: 4384:          stack_top_p += PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 4385:
    #####: 4386:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_TRY, branch_offset);
    #####: 4387:          continue;
        -: 4388:        }
    #####: 4389:        case VM_OC_CATCH:
        -: 4390:        {
        -: 4391:          /* Catches are ignored and turned to jumps. */
    #####: 4392:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4393:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY);
        -: 4394:
    #####: 4395:          byte_code_p = byte_code_start_p + branch_offset;
    #####: 4396:          continue;
        -: 4397:        }
    #####: 4398:        case VM_OC_FINALLY:
        -: 4399:        {
    #####: 4400:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4401:
    #####: 4402:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4403:
    #####: 4404:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_TRY
        -: 4405:                        || VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4406:
    #####: 4407:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4408:          {
    #####: 4409:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4410:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4411:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4412:            ecma_deref_object (lex_env_p);
        -: 4413:          }
        -: 4414:
    #####: 4415:          VM_PLUS_EQUAL_U16 (frame_ctx_p->context_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);
    #####: 4416:          stack_top_p += PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION;
        -: 4417:
    #####: 4418:          stack_top_p[-1] = VM_CREATE_CONTEXT (VM_CONTEXT_FINALLY_JUMP, branch_offset);
    #####: 4419:          stack_top_p[-2] = (ecma_value_t) branch_offset;
    #####: 4420:          continue;
        -: 4421:        }
    #####: 4422:        case VM_OC_CONTEXT_END:
        -: 4423:        {
    #####: 4424:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4425:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_CLOSE_ITERATOR));
        -: 4426:
    #####: 4427:          ecma_value_t context_type = VM_GET_CONTEXT_TYPE (stack_top_p[-1]);
        -: 4428:
    #####: 4429:          if (!VM_CONTEXT_IS_FINALLY (context_type))
        -: 4430:          {
    #####: 4431:            stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4432:
    #####: 4433:            JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4434:            continue;
        -: 4435:          }
        -: 4436:
        -: 4437:#if JERRY_ESNEXT
    #####: 4438:          if (stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV)
        -: 4439:          {
    #####: 4440:            ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 4441:            JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####: 4442:            frame_ctx_p->lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
    #####: 4443:            ecma_deref_object (lex_env_p);
        -: 4444:          }
        -: 4445:#endif /* JERRY_ESNEXT */
        -: 4446:
    #####: 4447:          VM_MINUS_EQUAL_U16 (frame_ctx_p->context_depth,
        -: 4448:                              PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
    #####: 4449:          stack_top_p -= PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -: 4450:
    #####: 4451:          if (context_type == VM_CONTEXT_FINALLY_RETURN)
        -: 4452:          {
    #####: 4453:            result = *stack_top_p;
    #####: 4454:            goto error;
        -: 4455:          }
        -: 4456:
    #####: 4457:          if (context_type == VM_CONTEXT_FINALLY_THROW)
        -: 4458:          {
    #####: 4459:            jcontext_raise_exception (*stack_top_p);
        -: 4460:#if JERRY_VM_THROW
    #####: 4461:            JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4462:#endif /* JERRY_VM_THROW */
    #####: 4463:            result = ECMA_VALUE_ERROR;
        -: 4464:
        -: 4465:#if JERRY_DEBUGGER
        -: 4466:            JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4467:#endif /* JERRY_DEBUGGER */
    #####: 4468:            goto error;
        -: 4469:          }
        -: 4470:
    #####: 4471:          JERRY_ASSERT (context_type == VM_CONTEXT_FINALLY_JUMP);
        -: 4472:
    #####: 4473:          uint32_t jump_target = *stack_top_p;
        -: 4474:
    #####: 4475:          vm_stack_found_type type = vm_stack_find_finally (frame_ctx_p,
        -: 4476:                                                            stack_top_p,
        -: 4477:                                                            VM_CONTEXT_FINALLY_JUMP,
        -: 4478:                                                            jump_target);
    #####: 4479:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4480:          switch (type)
        -: 4481:          {
    #####: 4482:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4483:            {
    #####: 4484:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4485:
    #####: 4486:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4487:              stack_top_p[-2] = jump_target;
    #####: 4488:              break;
        -: 4489:            }
        -: 4490:#if JERRY_ESNEXT
    #####: 4491:            case VM_CONTEXT_FOUND_ERROR:
        -: 4492:            {
    #####: 4493:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4494:              result = ECMA_VALUE_ERROR;
    #####: 4495:              goto error;
        -: 4496:            }
    #####: 4497:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4498:            {
    #####: 4499:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4500:              stack_top_p[-2] = jump_target;
    #####: 4501:              return ECMA_VALUE_UNDEFINED;
        -: 4502:            }
        -: 4503:#endif /* JERRY_ESNEXT */
    #####: 4504:            default:
        -: 4505:            {
    #####: 4506:              byte_code_p = frame_ctx_p->byte_code_start_p + jump_target;
    #####: 4507:              break;
        -: 4508:            }
        -: 4509:          }
        -: 4510:
    #####: 4511:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4512:          continue;
        -: 4513:        }
    #####: 4514:        case VM_OC_JUMP_AND_EXIT_CONTEXT:
        -: 4515:        {
    #####: 4516:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4517:          JERRY_ASSERT (!jcontext_has_pending_exception ());
        -: 4518:
    #####: 4519:          branch_offset += (int32_t) (byte_code_start_p - frame_ctx_p->byte_code_start_p);
        -: 4520:
    #####: 4521:          vm_stack_found_type type = vm_stack_find_finally (frame_ctx_p,
        -: 4522:                                                            stack_top_p,
        -: 4523:                                                            VM_CONTEXT_FINALLY_JUMP,
        -: 4524:                                                            (uint32_t) branch_offset);
    #####: 4525:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4526:          switch (type)
        -: 4527:          {
    #####: 4528:            case VM_CONTEXT_FOUND_FINALLY:
        -: 4529:            {
    #####: 4530:              byte_code_p = frame_ctx_p->byte_code_p;
        -: 4531:
    #####: 4532:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4533:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4534:              break;
        -: 4535:            }
        -: 4536:#if JERRY_ESNEXT
    #####: 4537:            case VM_CONTEXT_FOUND_ERROR:
        -: 4538:            {
    #####: 4539:              JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4540:              result = ECMA_VALUE_ERROR;
    #####: 4541:              goto error;
        -: 4542:            }
    #####: 4543:            case VM_CONTEXT_FOUND_AWAIT:
        -: 4544:            {
    #####: 4545:              JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_JUMP);
    #####: 4546:              stack_top_p[-2] = (uint32_t) branch_offset;
    #####: 4547:              return ECMA_VALUE_UNDEFINED;
        -: 4548:            }
        -: 4549:#endif /* JERRY_ESNEXT */
    #####: 4550:            default:
        -: 4551:            {
    #####: 4552:              byte_code_p = frame_ctx_p->byte_code_start_p + branch_offset;
    #####: 4553:              break;
        -: 4554:            }
        -: 4555:          }
        -: 4556:
    #####: 4557:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4558:          continue;
        -: 4559:        }
        -: 4560:#if JERRY_MODULE_SYSTEM
    #####: 4561:        case VM_OC_MODULE_IMPORT:
        -: 4562:        {
    #####: 4563:          left_value = *(--stack_top_p);
        -: 4564:
    #####: 4565:          ecma_value_t user_value = ECMA_VALUE_UNDEFINED;
    #####: 4566:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 4567:
        -: 4568:#if JERRY_SNAPSHOT_EXEC
    #####: 4569:          if (JERRY_UNLIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 4570:          {
        -: 4571:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 4572:            cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4573:
    #####: 4574:            if (script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 4575:            {
    #####: 4576:              user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);
        -: 4577:            }
        -: 4578:#if JERRY_SNAPSHOT_EXEC
        -: 4579:          }
        -: 4580:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 4581:
    #####: 4582:          result = ecma_module_import (left_value, user_value);
    #####: 4583:          ecma_free_value (left_value);
        -: 4584:
    #####: 4585:          if (ECMA_IS_VALUE_ERROR (result))
        -: 4586:          {
    #####: 4587:            goto error;
        -: 4588:          }
        -: 4589:
    #####: 4590:          *stack_top_p++ = result;
    #####: 4591:          continue;
        -: 4592:        }
    #####: 4593:        case VM_OC_MODULE_IMPORT_META:
        -: 4594:        {
    #####: 4595:          ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
    #####: 4596:          cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 4597:
    #####: 4598:          JERRY_ASSERT (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META);
        -: 4599:
    #####: 4600:          ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);
    #####: 4601:          ecma_object_t *import_meta_object_p = ecma_get_object_from_value (import_meta);
        -: 4602:
    #####: 4603:          if (ecma_get_object_type (import_meta_object_p) != ECMA_OBJECT_TYPE_GENERAL)
        -: 4604:          {
    #####: 4605:            JERRY_ASSERT (ecma_object_class_is (import_meta_object_p, ECMA_OBJECT_CLASS_MODULE));
        -: 4606:
    #####: 4607:            ecma_value_t module = import_meta;
    #####: 4608:            import_meta_object_p = ecma_create_object (NULL, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 4609:            import_meta = ecma_make_object_value (import_meta_object_p);
        -: 4610:
    #####: 4611:            if (JERRY_CONTEXT (module_import_meta_callback_p) != NULL)
        -: 4612:            {
    #####: 4613:              void *user_p = JERRY_CONTEXT (module_import_meta_callback_user_p);
    #####: 4614:              JERRY_CONTEXT (module_import_meta_callback_p) (module, import_meta, user_p);
        -: 4615:            }
        -: 4616:
    #####: 4617:            CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type) = import_meta;
        -: 4618:          }
        -: 4619:          else
        -: 4620:          {
    #####: 4621:            ecma_ref_object (import_meta_object_p);
        -: 4622:          }
        -: 4623:
    #####: 4624:          *stack_top_p++ = import_meta;
    #####: 4625:          continue;
        -: 4626:        }
        -: 4627:#endif /* JERRY_MODULE_SYSTEM */
        -: 4628:#if JERRY_DEBUGGER
        -: 4629:        case VM_OC_BREAKPOINT_ENABLED:
        -: 4630:        {
        -: 4631:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4632:          {
        -: 4633:            continue;
        -: 4634:          }
        -: 4635:
        -: 4636:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4637:
        -: 4638:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4639:
        -: 4640:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4641:
        -: 4642:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4643:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4644:          {
        -: 4645:            result = ECMA_VALUE_ERROR;
        -: 4646:            goto error;
        -: 4647:          }
        -: 4648:          continue;
        -: 4649:        }
        -: 4650:        case VM_OC_BREAKPOINT_DISABLED:
        -: 4651:        {
        -: 4652:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_IGNORE)
        -: 4653:          {
        -: 4654:            continue;
        -: 4655:          }
        -: 4656:
        -: 4657:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -: 4658:
        -: 4659:          JERRY_ASSERT (!(frame_ctx_p->shared_p->bytecode_header_p->status_flags & CBC_CODE_FLAGS_DEBUGGER_IGNORE));
        -: 4660:
        -: 4661:          frame_ctx_p->byte_code_p = byte_code_start_p;
        -: 4662:
        -: 4663:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4664:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4665:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4666:          {
        -: 4667:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4668:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4669:            {
        -: 4670:              result = ECMA_VALUE_ERROR;
        -: 4671:              goto error;
        -: 4672:            }
        -: 4673:            continue;
        -: 4674:          }
        -: 4675:
        -: 4676:          if (JERRY_CONTEXT (debugger_message_delay) > 0)
        -: 4677:          {
        -: 4678:            JERRY_CONTEXT (debugger_message_delay)--;
        -: 4679:            continue;
        -: 4680:          }
        -: 4681:
        -: 4682:          JERRY_CONTEXT (debugger_message_delay) = JERRY_DEBUGGER_MESSAGE_FREQUENCY;
        -: 4683:
        -: 4684:          if (jerry_debugger_receive (NULL))
        -: 4685:          {
        -: 4686:            continue;
        -: 4687:          }
        -: 4688:
        -: 4689:          if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP)
        -: 4690:              && (JERRY_CONTEXT (debugger_stop_context) == NULL
        -: 4691:                  || JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p)))
        -: 4692:          {
        -: 4693:            jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_BREAKPOINT_HIT);
        -: 4694:            if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4695:            {
        -: 4696:              result = ECMA_VALUE_ERROR;
        -: 4697:              goto error;
        -: 4698:            }
        -: 4699:          }
        -: 4700:          continue;
        -: 4701:        }
        -: 4702:#endif /* JERRY_DEBUGGER */
    #####: 4703:        case VM_OC_NONE:
        -: 4704:        default:
        -: 4705:        {
    #####: 4706:          JERRY_ASSERT (VM_OC_GROUP_GET_INDEX (opcode_data) == VM_OC_NONE);
        -: 4707:
    #####: 4708:          jerry_fatal (ERR_DISABLED_BYTE_CODE);
        -: 4709:        }
        -: 4710:      }
        -: 4711:
      204: 4712:      JERRY_ASSERT (VM_OC_HAS_PUT_RESULT (opcode_data));
        -: 4713:
      204: 4714:      if (opcode_data & VM_OC_PUT_IDENT)
        -: 4715:      {
        -: 4716:        uint16_t literal_index;
        -: 4717:
      102: 4718:        READ_LITERAL_INDEX (literal_index);
        -: 4719:
      102: 4720:        if (literal_index < register_end)
        -: 4721:        {
    #####: 4722:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, literal_index));
    #####: 4723:          VM_GET_REGISTER (frame_ctx_p, literal_index) = result;
        -: 4724:
    #####: 4725:          if (opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK))
        -: 4726:          {
    #####: 4727:            result = ecma_fast_copy_value (result);
        -: 4728:          }
        -: 4729:        }
        -: 4730:        else
        -: 4731:        {
      102: 4732:          ecma_string_t *var_name_str_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 4733:
      102: 4734:          ecma_value_t put_value_result = ecma_op_put_value_lex_env_base (frame_ctx_p->lex_env_p,
        -: 4735:                                                                          var_name_str_p,
        -: 4736:                                                                          is_strict,
        -: 4737:                                                                          result);
        -: 4738:
      102: 4739:          if (ECMA_IS_VALUE_ERROR (put_value_result))
        -: 4740:          {
    #####: 4741:            ecma_free_value (result);
    #####: 4742:            result = put_value_result;
    #####: 4743:            goto error;
        -: 4744:          }
        -: 4745:
      102: 4746:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4747:          {
      102: 4748:            ecma_fast_free_value (result);
        -: 4749:          }
        -: 4750:        }
        -: 4751:      }
      102: 4752:      else if (opcode_data & VM_OC_PUT_REFERENCE)
        -: 4753:      {
        1: 4754:        ecma_value_t property = *(--stack_top_p);
        1: 4755:        ecma_value_t base = *(--stack_top_p);
        -: 4756:
        1: 4757:        if (base == ECMA_VALUE_REGISTER_REF)
        -: 4758:        {
    #####: 4759:          property = (ecma_value_t) ecma_get_integer_from_value (property);
    #####: 4760:          ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, property));
    #####: 4761:          VM_GET_REGISTER (frame_ctx_p, property) = result;
        -: 4762:
    #####: 4763:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4764:          {
    #####: 4765:            goto free_both_values;
        -: 4766:          }
    #####: 4767:          result = ecma_fast_copy_value (result);
        -: 4768:        }
        -: 4769:        else
        -: 4770:        {
        1: 4771:          ecma_value_t set_value_result = vm_op_set_value (base,
        -: 4772:                                                           property,
        -: 4773:                                                           result,
        -: 4774:                                                           is_strict);
        -: 4775:
        1: 4776:          if (ECMA_IS_VALUE_ERROR (set_value_result))
        -: 4777:          {
    #####: 4778:            ecma_free_value (result);
    #####: 4779:            result = set_value_result;
    #####: 4780:            goto error;
        -: 4781:          }
        -: 4782:
        1: 4783:          if (!(opcode_data & (VM_OC_PUT_STACK | VM_OC_PUT_BLOCK)))
        -: 4784:          {
        1: 4785:            ecma_fast_free_value (result);
        1: 4786:            goto free_both_values;
        -: 4787:          }
        -: 4788:        }
        -: 4789:      }
        -: 4790:
      203: 4791:      if (opcode_data & VM_OC_PUT_STACK)
        -: 4792:      {
      101: 4793:        *stack_top_p++ = result;
        -: 4794:      }
      102: 4795:      else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 4796:      {
    #####: 4797:        ecma_fast_free_value (frame_ctx_p->block_result);
    #####: 4798:        frame_ctx_p->block_result = result;
        -: 4799:      }
        -: 4800:
      307: 4801:free_both_values:
      205: 4802:      ecma_fast_free_value (right_value);
      205: 4803:free_left_value:
      205: 4804:      ecma_fast_free_value (left_value);
        -: 4805:    }
        -: 4806:
        1: 4807:error:
        1: 4808:    ecma_fast_free_value (left_value);
        1: 4809:    ecma_fast_free_value (right_value);
        -: 4810:
        1: 4811:    if (ECMA_IS_VALUE_ERROR (result))
        -: 4812:    {
    #####: 4813:      JERRY_ASSERT (jcontext_has_pending_exception ());
    #####: 4814:      ecma_value_t *stack_bottom_p = VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth;
        -: 4815:
    #####: 4816:      while (stack_top_p > stack_bottom_p)
        -: 4817:      {
    #####: 4818:        ecma_value_t stack_item = *(--stack_top_p);
        -: 4819:#if JERRY_ESNEXT
    #####: 4820:        if (stack_item == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 4821:        {
    #####: 4822:          opfunc_pop_lexical_environment (frame_ctx_p);
    #####: 4823:          continue;
        -: 4824:        }
        -: 4825:#endif /* JERRY_ESNEXT */
    #####: 4826:        ecma_fast_free_value (stack_item);
        -: 4827:      }
        -: 4828:
        -: 4829:#if JERRY_VM_THROW
    #####: 4830:      if (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_ERROR_THROWN))
        -: 4831:      {
    #####: 4832:        JERRY_CONTEXT (status_flags) |= ECMA_STATUS_ERROR_THROWN;
        -: 4833:
    #####: 4834:        jerry_vm_throw_callback_t vm_throw_callback_p = JERRY_CONTEXT (vm_throw_callback_p);
        -: 4835:
    #####: 4836:        if (vm_throw_callback_p != NULL)
        -: 4837:        {
    #####: 4838:          vm_throw_callback_p (JERRY_CONTEXT (error_value), JERRY_CONTEXT (vm_throw_callback_user_p));
        -: 4839:        }
        -: 4840:      }
        -: 4841:#endif /* JERRY_VM_THROW */
        -: 4842:
        -: 4843:#if JERRY_DEBUGGER
        -: 4844:      const uint32_t dont_stop = (JERRY_DEBUGGER_VM_IGNORE_EXCEPTION
        -: 4845:                                  | JERRY_DEBUGGER_VM_IGNORE
        -: 4846:                                  | JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4847:
        -: 4848:      if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 4849:          && !(frame_ctx_p->shared_p->bytecode_header_p->status_flags
        -: 4850:               & (CBC_CODE_FLAGS_DEBUGGER_IGNORE | CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 4851:          && !(JERRY_CONTEXT (debugger_flags) & dont_stop))
        -: 4852:      {
        -: 4853:        /* Save the error to a local value, because the engine enters breakpoint mode after,
        -: 4854:           therefore an evaluation error, or user-created error throw would overwrite it. */
        -: 4855:        ecma_value_t current_error_value = JERRY_CONTEXT (error_value);
        -: 4856:
        -: 4857:        if (jerry_debugger_send_exception_string (current_error_value))
        -: 4858:        {
        -: 4859:          jerry_debugger_breakpoint_hit (JERRY_DEBUGGER_EXCEPTION_HIT);
        -: 4860:
        -: 4861:          if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_EXCEPTION_THROWN)
        -: 4862:          {
        -: 4863:            ecma_free_value (current_error_value);
        -: 4864:          }
        -: 4865:          else
        -: 4866:          {
        -: 4867:            JERRY_CONTEXT (error_value) = current_error_value;
        -: 4868:          }
        -: 4869:
        -: 4870:          JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4871:        }
        -: 4872:      }
        -: 4873:#endif /* JERRY_DEBUGGER */
        -: 4874:    }
        -: 4875:
        1: 4876:    JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4877:
        1: 4878:    if (frame_ctx_p->context_depth == 0)
        -: 4879:    {
        -: 4880:      /* In most cases there is no context. */
        1: 4881:      ecma_fast_free_value (frame_ctx_p->block_result);
        1: 4882:      frame_ctx_p->call_operation = VM_NO_EXEC_OP;
        1: 4883:      return result;
        -: 4884:    }
        -: 4885:
    #####: 4886:    if (!ECMA_IS_VALUE_ERROR (result))
        -: 4887:    {
    #####: 4888:      switch (vm_stack_find_finally (frame_ctx_p,
        -: 4889:                                     stack_top_p,
        -: 4890:                                     VM_CONTEXT_FINALLY_RETURN,
        -: 4891:                                     0))
        -: 4892:      {
    #####: 4893:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4894:        {
    #####: 4895:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4896:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4897:
    #####: 4898:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4899:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4900:          stack_top_p[-2] = result;
    #####: 4901:          continue;
        -: 4902:        }
        -: 4903:#if JERRY_ESNEXT
    #####: 4904:        case VM_CONTEXT_FOUND_ERROR:
        -: 4905:        {
    #####: 4906:          JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4907:
    #####: 4908:          ecma_free_value (result);
    #####: 4909:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4910:          result = ECMA_VALUE_ERROR;
    #####: 4911:          break;
        -: 4912:        }
    #####: 4913:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4914:        {
    #####: 4915:          stack_top_p = frame_ctx_p->stack_top_p;
        -: 4916:
    #####: 4917:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_RETURN);
    #####: 4918:          stack_top_p[-2] = result;
    #####: 4919:          return ECMA_VALUE_UNDEFINED;
        -: 4920:        }
        -: 4921:#endif /* JERRY_ESNEXT */
    #####: 4922:        default:
        -: 4923:        {
    #####: 4924:          goto finish;
        -: 4925:        }
        -: 4926:      }
    #####: 4927:    }
        -: 4928:
    #####: 4929:    JERRY_ASSERT (jcontext_has_pending_exception ());
        -: 4930:
    #####: 4931:    if (!jcontext_has_pending_abort ())
        -: 4932:    {
    #####: 4933:      switch (vm_stack_find_finally (frame_ctx_p,
        -: 4934:                                     stack_top_p,
        -: 4935:                                     VM_CONTEXT_FINALLY_THROW,
        -: 4936:                                     0))
        -: 4937:      {
    #####: 4938:        case VM_CONTEXT_FOUND_FINALLY:
        -: 4939:        {
    #####: 4940:          stack_top_p = frame_ctx_p->stack_top_p;
    #####: 4941:          byte_code_p = frame_ctx_p->byte_code_p;
        -: 4942:
    #####: 4943:          JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
    #####: 4944:          JERRY_ASSERT (!(stack_top_p[-1] & VM_CONTEXT_HAS_LEX_ENV));
        -: 4945:
        -: 4946:#if JERRY_DEBUGGER
        -: 4947:          JERRY_DEBUGGER_CLEAR_FLAGS (JERRY_DEBUGGER_VM_EXCEPTION_THROWN);
        -: 4948:#endif /* JERRY_DEBUGGER */
        -: 4949:
    #####: 4950:          result = jcontext_take_exception ();
        -: 4951:
    #####: 4952:          if (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW)
        -: 4953:          {
    #####: 4954:            stack_top_p[-2] = result;
    #####: 4955:            continue;
        -: 4956:          }
        -: 4957:
    #####: 4958:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (stack_top_p[-1]) == VM_CONTEXT_CATCH);
        -: 4959:
    #####: 4960:          *stack_top_p++ = result;
    #####: 4961:          continue;
        -: 4962:        }
        -: 4963:#if JERRY_ESNEXT
    #####: 4964:        case VM_CONTEXT_FOUND_AWAIT:
        -: 4965:        {
    #####: 4966:          JERRY_ASSERT (VM_GET_CONTEXT_TYPE (frame_ctx_p->stack_top_p[-1]) == VM_CONTEXT_FINALLY_THROW);
    #####: 4967:          return ECMA_VALUE_UNDEFINED;
        -: 4968:        }
        -: 4969:#endif /* JERRY_ESNEXT */
    #####: 4970:        default:
        -: 4971:        {
    #####: 4972:          break;
        -: 4973:        }
        -: 4974:      }
        -: 4975:    }
        -: 4976:    else
        -: 4977:    {
        -: 4978:      do
        -: 4979:      {
    #####: 4980:        JERRY_ASSERT (VM_GET_REGISTERS (frame_ctx_p) + register_end + frame_ctx_p->context_depth == stack_top_p);
        -: 4981:
    #####: 4982:        stack_top_p = vm_stack_context_abort (frame_ctx_p, stack_top_p);
        -: 4983:      }
    #####: 4984:      while (frame_ctx_p->context_depth > 0);
        -: 4985:    }
        -: 4986:
    #####: 4987:finish:
    #####: 4988:    ecma_free_value (frame_ctx_p->block_result);
    #####: 4989:    frame_ctx_p->call_operation = VM_NO_EXEC_OP;
    #####: 4990:    return result;
        -: 4991:  }
        -: 4992:} /* vm_loop */
        -: 4993:
        -: 4994:#if JERRY_MODULE_SYSTEM
        -: 4995:
        -: 4996:/**
        -: 4997: * Create and initialize module scope with all data properties
        -: 4998: *
        -: 4999: * @return ECMA_VALUE_EMPTY on success,
        -: 5000: *         ECMA_VALUE_ERROR on failure
        -: 5001: */
        -: 5002:ecma_value_t
    #####: 5003:vm_init_module_scope (ecma_module_t *module_p) /**< module without scope */
        -: 5004:{
        -: 5005:  ecma_object_t *global_object_p;
        -: 5006:#if JERRY_BUILTIN_REALMS
    #####: 5007:  global_object_p = (ecma_object_t *) ecma_op_function_get_realm (module_p->u.compiled_code_p);
        -: 5008:#else /* !JERRY_BUILTIN_REALMS */
        -: 5009:  global_object_p = ecma_builtin_get_global ();
        -: 5010:#endif /* JERRY_BUILTIN_REALMS */
        -: 5011:
    #####: 5012:  ecma_object_t *scope_p = ecma_create_lex_env_class (ecma_get_global_environment (global_object_p),
        -: 5013:                                                      sizeof (ecma_lexical_environment_class_t));
    #####: 5014:  const ecma_compiled_code_t *compiled_code_p = module_p->u.compiled_code_p;
        -: 5015:  ecma_value_t *literal_start_p;
        -: 5016:  uint8_t *byte_code_p;
        -: 5017:  uint16_t encoding_limit;
        -: 5018:  uint16_t encoding_delta;
        -: 5019:
    #####: 5020:  ((ecma_lexical_environment_class_t *) scope_p)->module_p = (ecma_object_t *) module_p;
        -: 5021:
    #####: 5022:  module_p->scope_p = scope_p;
    #####: 5023:  ecma_deref_object (scope_p);
        -: 5024:
    #####: 5025:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5026:  {
    #####: 5027:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -: 5028:
    #####: 5029:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5030:    literal_start_p -= args_p->register_end;
    #####: 5031:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5032:  }
        -: 5033:  else
        -: 5034:  {
    #####: 5035:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 5036:
    #####: 5037:    literal_start_p = (ecma_value_t *) (args_p + 1);
    #####: 5038:    literal_start_p -= args_p->register_end;
    #####: 5039:    byte_code_p = (uint8_t *) (literal_start_p + args_p->literal_end);
        -: 5040:  }
        -: 5041:
        -: 5042:  /* Prepare for byte code execution. */
    #####: 5043:  if (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -: 5044:  {
    #####: 5045:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
    #####: 5046:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 5047:  }
        -: 5048:  else
        -: 5049:  {
    #####: 5050:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 5051:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 5052:  }
        -: 5053:
    #####: 5054:  JERRY_ASSERT (*byte_code_p >= CBC_JUMP_FORWARD && *byte_code_p <= CBC_JUMP_FORWARD_3);
        -: 5055:
    #####: 5056:  byte_code_p += 1 + CBC_BRANCH_OFFSET_LENGTH (*byte_code_p);
        -: 5057:
        -: 5058:  while (true)
    #####: 5059:  {
    #####: 5060:    uint8_t opcode = *byte_code_p++;
        -: 5061:
    #####: 5062:    switch (opcode)
        -: 5063:    {
    #####: 5064:      case CBC_CREATE_VAR:
        -: 5065:      case CBC_CREATE_LET:
        -: 5066:      case CBC_CREATE_CONST:
        -: 5067:      {
        -: 5068:        uint32_t literal_index;
        -: 5069:
    #####: 5070:        READ_LITERAL_INDEX (literal_index);
        -: 5071:
    #####: 5072:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5073:
    #####: 5074:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5075:
    #####: 5076:        uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -: 5077:
    #####: 5078:        if (opcode == CBC_CREATE_LET)
        -: 5079:        {
    #####: 5080:          prop_attributes = ECMA_PROPERTY_ENUMERABLE_WRITABLE;
        -: 5081:        }
    #####: 5082:        else if (opcode == CBC_CREATE_CONST)
        -: 5083:        {
    #####: 5084:          prop_attributes = ECMA_PROPERTY_FLAG_ENUMERABLE;
        -: 5085:        }
        -: 5086:
        -: 5087:        ecma_property_value_t *property_value_p;
    #####: 5088:        property_value_p = ecma_create_named_data_property (scope_p, name_p, prop_attributes, NULL);
        -: 5089:
    #####: 5090:        if (opcode != CBC_CREATE_VAR)
        -: 5091:        {
    #####: 5092:          property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        -: 5093:        }
    #####: 5094:        break;
        -: 5095:      }
    #####: 5096:      case CBC_INIT_ARG_OR_FUNC:
        -: 5097:      {
        -: 5098:        uint32_t literal_index;
        -: 5099:
    #####: 5100:        READ_LITERAL_INDEX (literal_index);
        -: 5101:
        -: 5102:        ecma_compiled_code_t *function_bytecode_p;
        -: 5103:#if JERRY_SNAPSHOT_EXEC
    #####: 5104:        if (JERRY_LIKELY (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 5105:        {
        -: 5106:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 5107:          function_bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 5108:                                                                 literal_start_p[literal_index]);
        -: 5109:#if JERRY_SNAPSHOT_EXEC
        -: 5110:        }
        -: 5111:        else
        -: 5112:        {
    #####: 5113:          uint8_t *byte_p = ((uint8_t *) compiled_code_p) + literal_start_p[literal_index];
    #####: 5114:          function_bytecode_p = (ecma_compiled_code_t *) byte_p;
        -: 5115:        }
        -: 5116:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 5117:
    #####: 5118:        JERRY_ASSERT (CBC_IS_FUNCTION (function_bytecode_p->status_flags));
        -: 5119:
        -: 5120:        ecma_object_t *function_obj_p;
        -: 5121:
    #####: 5122:        if (JERRY_UNLIKELY (CBC_FUNCTION_IS_ARROW (function_bytecode_p->status_flags)))
        -: 5123:        {
    #####: 5124:          function_obj_p = ecma_op_create_arrow_function_object (scope_p,
        -: 5125:                                                                 function_bytecode_p,
        -: 5126:                                                                 ECMA_VALUE_UNDEFINED);
        -: 5127:        }
        -: 5128:        else
        -: 5129:        {
    #####: 5130:          function_obj_p = ecma_op_create_any_function_object (scope_p, function_bytecode_p);
        -: 5131:        }
        -: 5132:
    #####: 5133:        READ_LITERAL_INDEX (literal_index);
    #####: 5134:        ecma_string_t *name_p = ecma_get_string_from_value (literal_start_p[literal_index]);
        -: 5135:
    #####: 5136:        JERRY_ASSERT (ecma_find_named_property (scope_p, name_p) == NULL);
        -: 5137:
        -: 5138:        ecma_property_value_t *property_value_p;
    #####: 5139:        property_value_p = ecma_create_named_data_property (scope_p,
        -: 5140:                                                            name_p,
        -: 5141:                                                            ECMA_PROPERTY_FLAG_WRITABLE,
        -: 5142:                                                            NULL);
        -: 5143:
    #####: 5144:        JERRY_ASSERT (property_value_p->value == ECMA_VALUE_UNDEFINED);
    #####: 5145:        property_value_p->value = ecma_make_object_value (function_obj_p);
    #####: 5146:        ecma_deref_object (function_obj_p);
    #####: 5147:        break;
        -: 5148:      }
    #####: 5149:      default:
        -: 5150:      {
    #####: 5151:        JERRY_ASSERT (opcode == CBC_RETURN_WITH_BLOCK);
    #####: 5152:        return ECMA_VALUE_EMPTY;
        -: 5153:      }
        -: 5154:    }
        -: 5155:  }
        -: 5156:} /* vm_init_module_scope */
        -: 5157:
        -: 5158:#endif /* JERRY_MODULE_SYSTEM */
        -: 5159:
        -: 5160:#undef READ_LITERAL
        -: 5161:#undef READ_LITERAL_INDEX
        -: 5162:
        -: 5163:JERRY_STATIC_ASSERT ((int) VM_FRAME_CTX_SHARED_DIRECT_EVAL == (int) VM_FRAME_CTX_DIRECT_EVAL,
        -: 5164:                     vm_frame_ctx_shared_direct_eval_must_be_equal_to_frame_ctx_direct_eval);
        -: 5165:
        -: 5166:JERRY_STATIC_ASSERT ((int) CBC_CODE_FLAGS_STRICT_MODE == (int) VM_FRAME_CTX_IS_STRICT,
        -: 5167:                     cbc_code_flags_strict_mode_must_be_equal_to_vm_frame_ctx_is_strict);
        -: 5168:
        -: 5169:/**
        -: 5170: * Initialize code block execution
        -: 5171: *
        -: 5172: * @return ECMA_VALUE_ERROR - if the initialization fails
        -: 5173: *         ECMA_VALUE_EMPTY - otherwise
        -: 5174: */
        -: 5175:static void JERRY_ATTR_NOINLINE
        2: 5176:vm_init_exec (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5177:{
        2: 5178:  vm_frame_ctx_shared_t *shared_p = frame_ctx_p->shared_p;
        2: 5179:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5180:
        2: 5181:  frame_ctx_p->prev_context_p = JERRY_CONTEXT (vm_top_context_p);
        2: 5182:  frame_ctx_p->block_result = ECMA_VALUE_UNDEFINED;
        2: 5183:  frame_ctx_p->context_depth = 0;
        4: 5184:  frame_ctx_p->status_flags = (uint8_t) ((shared_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL)
        2: 5185:                                         | (bytecode_header_p->status_flags & VM_FRAME_CTX_IS_STRICT));
        -: 5186:
        -: 5187:  uint16_t argument_end, register_end;
        -: 5188:  ecma_value_t *literal_p;
        -: 5189:
        2: 5190:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5191:  {
    #####: 5192:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -: 5193:
    #####: 5194:    argument_end = args_p->argument_end;
    #####: 5195:    register_end = args_p->register_end;
        -: 5196:
    #####: 5197:    literal_p = (ecma_value_t *) (args_p + 1);
    #####: 5198:    literal_p -= register_end;
    #####: 5199:    frame_ctx_p->literal_start_p = literal_p;
    #####: 5200:    literal_p += args_p->literal_end;
        -: 5201:  }
        -: 5202:  else
        -: 5203:  {
        2: 5204:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -: 5205:
        2: 5206:    argument_end = args_p->argument_end;
        2: 5207:    register_end = args_p->register_end;
        -: 5208:
        2: 5209:    literal_p = (ecma_value_t *) (args_p + 1);
        2: 5210:    literal_p -= register_end;
        2: 5211:    frame_ctx_p->literal_start_p = literal_p;
        2: 5212:    literal_p += args_p->literal_end;
        -: 5213:  }
        -: 5214:
        2: 5215:  frame_ctx_p->byte_code_p = (uint8_t *) literal_p;
        2: 5216:  frame_ctx_p->byte_code_start_p = (uint8_t *) literal_p;
        2: 5217:  frame_ctx_p->stack_top_p = VM_GET_REGISTERS (frame_ctx_p) + register_end;
        -: 5218:
        2: 5219:  uint32_t arg_list_len = 0;
        -: 5220:
        2: 5221:  if (argument_end > 0)
        -: 5222:  {
    #####: 5223:    JERRY_ASSERT (shared_p->status_flags & VM_FRAME_CTX_SHARED_HAS_ARG_LIST);
        -: 5224:
    #####: 5225:    const ecma_value_t *arg_list_p = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_p;
    #####: 5226:    arg_list_len = ((vm_frame_ctx_shared_args_t *) shared_p)->arg_list_len;
        -: 5227:
    #####: 5228:    if (arg_list_len > argument_end)
        -: 5229:    {
    #####: 5230:      arg_list_len = argument_end;
        -: 5231:    }
        -: 5232:
    #####: 5233:    for (uint32_t i = 0; i < arg_list_len; i++)
        -: 5234:    {
    #####: 5235:      VM_GET_REGISTER (frame_ctx_p, i) = ecma_fast_copy_value (arg_list_p[i]);
        -: 5236:    }
        -: 5237:  }
        -: 5238:
        -: 5239:  /* The arg_list_len contains the end of the copied arguments.
        -: 5240:   * Fill everything else with undefined. */
        2: 5241:  if (register_end > arg_list_len)
        -: 5242:  {
    #####: 5243:    ecma_value_t *stack_p = VM_GET_REGISTERS (frame_ctx_p) + arg_list_len;
        -: 5244:
    #####: 5245:    for (uint32_t i = arg_list_len; i < register_end; i++)
        -: 5246:    {
    #####: 5247:      *stack_p++ = ECMA_VALUE_UNDEFINED;
        -: 5248:    }
        -: 5249:  }
        -: 5250:
        2: 5251:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_DIRECT_EVAL;
        2: 5252:  JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p;
        2: 5253:} /* vm_init_exec */
        -: 5254:
        -: 5255:/**
        -: 5256: * Resume execution of a code block.
        -: 5257: *
        -: 5258: * @return ecma value
        -: 5259: */
        -: 5260:ecma_value_t JERRY_ATTR_NOINLINE
      102: 5261:vm_execute (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 5262:{
        -: 5263:  while (true)
      100: 5264:  {
      102: 5265:    ecma_value_t completion_value = vm_loop (frame_ctx_p);
        -: 5266:
      102: 5267:    switch (frame_ctx_p->call_operation)
        -: 5268:    {
      101: 5269:      case VM_EXEC_CALL:
        -: 5270:      {
      101: 5271:        opfunc_call (frame_ctx_p);
      100: 5272:        break;
        -: 5273:      }
        -: 5274:#if JERRY_ESNEXT
    #####: 5275:      case VM_EXEC_SUPER_CALL:
        -: 5276:      {
    #####: 5277:        vm_super_call (frame_ctx_p);
    #####: 5278:        break;
        -: 5279:      }
    #####: 5280:      case VM_EXEC_SPREAD_OP:
        -: 5281:      {
    #####: 5282:        vm_spread_operation (frame_ctx_p);
    #####: 5283:        break;
        -: 5284:      }
    #####: 5285:      case VM_EXEC_RETURN:
        -: 5286:      {
    #####: 5287:        return completion_value;
        -: 5288:      }
        -: 5289:#endif /* JERRY_ESNEXT */
    #####: 5290:      case VM_EXEC_CONSTRUCT:
        -: 5291:      {
    #####: 5292:        opfunc_construct (frame_ctx_p);
    #####: 5293:        break;
        -: 5294:      }
        1: 5295:      default:
        -: 5296:      {
        1: 5297:        JERRY_ASSERT (frame_ctx_p->call_operation == VM_NO_EXEC_OP);
        -: 5298:
        1: 5299:        const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -: 5300:        uint32_t register_end;
        -: 5301:
        1: 5302:        if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5303:        {
    #####: 5304:          register_end = ((cbc_uint16_arguments_t *) bytecode_header_p)->register_end;
        -: 5305:        }
        -: 5306:        else
        -: 5307:        {
        1: 5308:          register_end = ((cbc_uint8_arguments_t *) bytecode_header_p)->register_end;
        -: 5309:        }
        -: 5310:
        -: 5311:        /* Free arguments and registers */
        1: 5312:        ecma_value_t *registers_p = VM_GET_REGISTERS (frame_ctx_p);
        1: 5313:        for (uint32_t i = 0; i < register_end; i++)
        -: 5314:        {
    #####: 5315:          ecma_fast_free_value (registers_p[i]);
        -: 5316:        }
        -: 5317:
        -: 5318:#if JERRY_DEBUGGER
        -: 5319:        if (JERRY_CONTEXT (debugger_stop_context) == JERRY_CONTEXT (vm_top_context_p))
        -: 5320:        {
        -: 5321:          /* The engine will stop when the next breakpoint is reached. */
        -: 5322:          JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_VM_STOP);
        -: 5323:          JERRY_CONTEXT (debugger_stop_context) = NULL;
        -: 5324:        }
        -: 5325:#endif /* JERRY_DEBUGGER */
        -: 5326:
        1: 5327:        JERRY_CONTEXT (vm_top_context_p) = frame_ctx_p->prev_context_p;
        1: 5328:        return completion_value;
        -: 5329:      }
        -: 5330:    }
        -: 5331:  }
        -: 5332:} /* vm_execute */
        -: 5333:
        -: 5334:/**
        -: 5335: * Run the code.
        -: 5336: *
        -: 5337: * @return ecma value
        -: 5338: */
        -: 5339:ecma_value_t
        2: 5340:vm_run (vm_frame_ctx_shared_t *shared_p, /**< shared data */
        -: 5341:        ecma_value_t this_binding_value, /**< value of 'ThisBinding' */
        -: 5342:        ecma_object_t *lex_env_p) /**< lexical environment to use */
        2: 5343:{
        2: 5344:  const ecma_compiled_code_t *bytecode_header_p = shared_p->bytecode_header_p;
        -: 5345:  vm_frame_ctx_t *frame_ctx_p;
        -: 5346:  size_t frame_size;
        -: 5347:
        2: 5348:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 5349:  {
    #####: 5350:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####: 5351:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5352:  }
        -: 5353:  else
        -: 5354:  {
        2: 5355:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        2: 5356:    frame_size = (size_t) (args_p->register_end + args_p->stack_limit);
        -: 5357:  }
        -: 5358:
        2: 5359:  frame_size = frame_size * sizeof (ecma_value_t) + sizeof (vm_frame_ctx_t);
        2: 5360:  frame_size = (frame_size + sizeof (uintptr_t) - 1) / sizeof (uintptr_t);
        -: 5361:
        -: 5362:  /* Use JERRY_MAX() to avoid array declaration with size 0. */
        2: 5363:  JERRY_VLA (uintptr_t, stack, frame_size);
        -: 5364:
        2: 5365:  frame_ctx_p = (vm_frame_ctx_t *) stack;
        -: 5366:
        2: 5367:  frame_ctx_p->shared_p = shared_p;
        2: 5368:  frame_ctx_p->lex_env_p = lex_env_p;
        2: 5369:  frame_ctx_p->this_binding = this_binding_value;
        -: 5370:
        2: 5371:  vm_init_exec (frame_ctx_p);
        2: 5372:  return vm_execute (frame_ctx_p);
        -: 5373:} /* vm_run */
        -: 5374:
        -: 5375:/**
        -: 5376: * @}
        -: 5377: * @}
        -: 5378: */
