        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-objects.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-array-object.h"
        -:   17:#include "ecma-builtins.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-gc.h"
        -:   21:#include "ecma-globals.h"
        -:   22:#include "ecma-helpers.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-lex-env.h"
        -:   25:#include "ecma-lcache.h"
        -:   26:#include "ecma-string-object.h"
        -:   27:#include "ecma-arguments-object.h"
        -:   28:#include "ecma-objects-general.h"
        -:   29:#include "ecma-objects.h"
        -:   30:#include "ecma-proxy-object.h"
        -:   31:#include "ecma-bigint.h"
        -:   32:#include "jcontext.h"
        -:   33:
        -:   34:#if JERRY_BUILTIN_TYPEDARRAY
        -:   35:#include "ecma-typedarray-object.h"
        -:   36:#include "ecma-arraybuffer-object.h"
        -:   37:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:   38:
        -:   39:/** \addtogroup ecma ECMA
        -:   40: * @{
        -:   41: *
        -:   42: * \addtogroup ecmaobjectsinternalops ECMA objects' operations
        -:   43: * @{
        -:   44: */
        -:   45:
        -:   46:/**
        -:   47: * Hash bitmap size for ecma objects
        -:   48: */
        -:   49:#define ECMA_OBJECT_HASH_BITMAP_SIZE 256
        -:   50:
        -:   51:/**
        -:   52: * Assert that specified object type value is valid
        -:   53: *
        -:   54: * @param type object's implementation-defined type
        -:   55: */
        -:   56:#ifndef JERRY_NDEBUG
        -:   57:#define JERRY_ASSERT_OBJECT_TYPE_IS_VALID(type) \
        -:   58:  JERRY_ASSERT (type < ECMA_OBJECT_TYPE__MAX);
        -:   59:#else /* JERRY_NDEBUG */
        -:   60:#define JERRY_ASSERT_OBJECT_TYPE_IS_VALID(type)
        -:   61:#endif /* !JERRY_NDEBUG */
        -:   62:
        -:   63:/**
        -:   64: * [[GetOwnProperty]] ecma object's operation
        -:   65: *
        -:   66: * See also:
        -:   67: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:   68: *
        -:   69: * @return pointer to a property - if it exists,
        -:   70: *         NULL (i.e. ecma-undefined) - otherwise.
        -:   71: */
        -:   72:ecma_property_t
      121:   73:ecma_op_object_get_own_property (ecma_object_t *object_p, /**< the object */
        -:   74:                                 ecma_string_t *property_name_p, /**< property name */
        -:   75:                                 ecma_property_ref_t *property_ref_p, /**< property reference */
        -:   76:                                 uint32_t options) /**< option bits */
        -:   77:{
      121:   78:  JERRY_ASSERT (object_p != NULL
        -:   79:                && !ecma_is_lexical_environment (object_p));
        -:   80:#if JERRY_BUILTIN_PROXY
      121:   81:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -:   82:#endif /* JERRY_BUILTIN_PROXY */
      121:   83:  JERRY_ASSERT (property_name_p != NULL);
      121:   84:  JERRY_ASSERT (options == ECMA_PROPERTY_GET_NO_OPTIONS
        -:   85:                || property_ref_p != NULL);
        -:   86:
      121:   87:  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);
        -:   88:
      121:   89:  switch (base_type)
        -:   90:  {
    #####:   91:    case ECMA_OBJECT_BASE_TYPE_CLASS:
        -:   92:    {
    #####:   93:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:   94:
    #####:   95:      switch (ext_object_p->u.cls.type)
        -:   96:      {
    #####:   97:        case ECMA_OBJECT_CLASS_STRING:
        -:   98:        {
    #####:   99:          if (ecma_string_is_length (property_name_p))
        -:  100:          {
    #####:  101:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  102:            {
    #####:  103:              ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
    #####:  104:              ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  105:
    #####:  106:              lit_utf8_size_t length = ecma_string_get_length (prim_value_str_p);
    #####:  107:              property_ref_p->virtual_value = ecma_make_uint32_value (length);
        -:  108:            }
        -:  109:
    #####:  110:            return ECMA_PROPERTY_VIRTUAL;
        -:  111:          }
        -:  112:
    #####:  113:          uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  114:
    #####:  115:          if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  116:          {
    #####:  117:            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
    #####:  118:            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  119:
    #####:  120:            if (index < ecma_string_get_length (prim_value_str_p))
        -:  121:            {
    #####:  122:              if (options & ECMA_PROPERTY_GET_VALUE)
        -:  123:              {
    #####:  124:                ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);
    #####:  125:                ecma_string_t *char_str_p = ecma_new_ecma_string_from_code_unit (char_at_idx);
    #####:  126:                property_ref_p->virtual_value = ecma_make_string_value (char_str_p);
        -:  127:              }
        -:  128:
    #####:  129:              return ECMA_PROPERTY_FLAG_ENUMERABLE | ECMA_PROPERTY_VIRTUAL;
        -:  130:            }
        -:  131:          }
    #####:  132:          break;
        -:  133:        }
        -:  134:#if JERRY_BUILTIN_TYPEDARRAY
        -:  135:        /* ES2015 9.4.5.1 */
    #####:  136:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -:  137:        {
    #####:  138:          if (ecma_prop_name_is_symbol (property_name_p))
        -:  139:          {
    #####:  140:            break;
        -:  141:          }
    #####:  142:          ecma_number_t num = ecma_string_to_number (property_name_p);
        -:  143:          bool is_same;
    #####:  144:          if (num <= 0)
        -:  145:          {
    #####:  146:            is_same = true;
        -:  147:          }
        -:  148:          else
        -:  149:          {
    #####:  150:            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####:  151:            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
    #####:  152:            ecma_deref_ecma_string (num_to_str);
        -:  153:          }
        -:  154:
    #####:  155:          if (is_same)
        -:  156:          {
    #####:  157:            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
    #####:  158:            ecma_value_t value = ecma_get_typedarray_element (&info, num);
        -:  159:
    #####:  160:            if (ECMA_IS_VALUE_ERROR (value))
        -:  161:            {
    #####:  162:              property_ref_p->virtual_value = value;
    #####:  163:              return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  164:            }
        -:  165:
    #####:  166:            if (!ecma_is_value_undefined (value))
        -:  167:            {
    #####:  168:              if (options & ECMA_PROPERTY_GET_VALUE)
        -:  169:              {
    #####:  170:                property_ref_p->virtual_value = value;
        -:  171:              }
        -:  172:              else
        -:  173:              {
    #####:  174:                ecma_fast_free_value (value);
        -:  175:              }
        -:  176:
    #####:  177:              return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:  178:            }
        -:  179:            else
        -:  180:            {
    #####:  181:              return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  182:            }
        -:  183:          }
    #####:  184:          break;
        -:  185:        }
        -:  186:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:  187:#if JERRY_MODULE_SYSTEM
    #####:  188:        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:
        -:  189:        {
    #####:  190:          if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))
        -:  191:          {
    #####:  192:            if (!ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG))
        -:  193:            {
    #####:  194:              return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -:  195:            }
        -:  196:
        -:  197:            /* ECMA-262 v11, 26.3.1 */
    #####:  198:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  199:            {
    #####:  200:              property_ref_p->virtual_value = ecma_make_magic_string_value (LIT_MAGIC_STRING_MODULE_UL);
        -:  201:            }
        -:  202:
    #####:  203:            return ECMA_PROPERTY_VIRTUAL;
        -:  204:          }
        -:  205:
    #####:  206:          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -:  207:
    #####:  208:          if (property_p == NULL)
        -:  209:          {
    #####:  210:            return ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -:  211:          }
        -:  212:
    #####:  213:          JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  214:
    #####:  215:          if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  216:          {
    #####:  217:            if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)
        -:  218:            {
    #####:  219:              ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;
        -:  220:            }
        -:  221:
    #####:  222:            if (property_ref_p != NULL)
        -:  223:            {
    #####:  224:              property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  225:            }
        -:  226:
    #####:  227:            return *property_p;
        -:  228:          }
        -:  229:
    #####:  230:          if (options & ECMA_PROPERTY_GET_VALUE)
        -:  231:          {
    #####:  232:            ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  233:            prop_value_p = ecma_get_property_value_from_named_reference (prop_value_p);
    #####:  234:            property_ref_p->virtual_value = ecma_fast_copy_value (prop_value_p->value);
        -:  235:          }
        -:  236:
    #####:  237:          return ECMA_PROPERTY_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:  238:        }
        -:  239:#endif /* JERRY_MODULE_SYSTEM */
        -:  240:      }
    #####:  241:      break;
        -:  242:    }
    #####:  243:    case ECMA_OBJECT_BASE_TYPE_ARRAY:
        -:  244:    {
    #####:  245:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  246:
    #####:  247:      if (ecma_string_is_length (property_name_p))
        -:  248:      {
    #####:  249:        if (options & ECMA_PROPERTY_GET_VALUE)
        -:  250:        {
    #####:  251:          property_ref_p->virtual_value = ecma_make_uint32_value (ext_object_p->u.array.length);
        -:  252:        }
        -:  253:
    #####:  254:        uint32_t length_prop = ext_object_p->u.array.length_prop_and_hole_count;
    #####:  255:        return length_prop & (ECMA_PROPERTY_FLAG_WRITABLE | ECMA_PROPERTY_VIRTUAL);
        -:  256:      }
        -:  257:
    #####:  258:      if (ecma_op_array_is_fast_array (ext_object_p))
        -:  259:      {
    #####:  260:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  261:
    #####:  262:        if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  263:        {
    #####:  264:          if (JERRY_LIKELY (index < ext_object_p->u.array.length))
        -:  265:          {
    #####:  266:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  267:
    #####:  268:            if (ecma_is_value_array_hole (values_p[index]))
        -:  269:            {
    #####:  270:              return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  271:            }
        -:  272:
    #####:  273:            if (options & ECMA_PROPERTY_GET_VALUE)
        -:  274:            {
    #####:  275:              property_ref_p->virtual_value = ecma_fast_copy_value (values_p[index]);
        -:  276:            }
        -:  277:
    #####:  278:            return ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | ECMA_PROPERTY_VIRTUAL;
        -:  279:          }
        -:  280:        }
        -:  281:
    #####:  282:        return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  283:      }
        -:  284:
    #####:  285:      break;
        -:  286:    }
      121:  287:    default:
        -:  288:    {
      121:  289:      break;
        -:  290:    }
        -:  291:  }
        -:  292:
      121:  293:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
      121:  294:  ecma_object_type_t type = ecma_get_object_type (object_p);
        -:  295:
      121:  296:  if (property_p == NULL)
        -:  297:  {
       19:  298:    switch (type)
        -:  299:    {
    #####:  300:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -:  301:      {
    #####:  302:        if (ecma_builtin_function_is_routine (object_p))
        -:  303:        {
    #####:  304:          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
    #####:  305:          break;
        -:  306:        }
        -:  307:        /* FALLTHRU */
        -:  308:      }
        -:  309:      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -:  310:      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -:  311:      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -:  312:      {
       19:  313:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
       19:  314:        break;
        -:  315:      }
    #####:  316:      case ECMA_OBJECT_TYPE_CLASS:
        -:  317:      {
    #####:  318:        if (((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS)
        -:  319:        {
    #####:  320:          property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  321:        }
    #####:  322:        break;
        -:  323:      }
    #####:  324:      case ECMA_OBJECT_TYPE_FUNCTION:
        -:  325:      {
        -:  326:#if !JERRY_ESNEXT
    #####:  327:        if (ecma_string_is_length (property_name_p))
        -:  328:        {
    #####:  329:          if (options & ECMA_PROPERTY_GET_VALUE)
        -:  330:          {
        -:  331:            /* Get length virtual property. */
    #####:  332:            ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
    #####:  333:            const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);
        -:  334:
        -:  335:            uint32_t len;
    #####:  336:            if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  337:            {
    #####:  338:              cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;
    #####:  339:              len = args_p->argument_end;
        -:  340:            }
        -:  341:            else
        -:  342:            {
    #####:  343:              cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;
    #####:  344:              len = args_p->argument_end;
        -:  345:            }
        -:  346:
    #####:  347:            property_ref_p->virtual_value = ecma_make_uint32_value (len);
        -:  348:          }
        -:  349:
        -:  350:          return ECMA_PROPERTY_VIRTUAL;
        -:  351:        }
        -:  352:#endif /* !JERRY_ESNEXT */
        -:  353:
        -:  354:        /* Get prototype physical property. */
    #####:  355:        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  356:        break;
        -:  357:      }
    #####:  358:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -:  359:      {
    #####:  360:        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  361:        break;
        -:  362:      }
    #####:  363:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -:  364:      {
    #####:  365:        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  366:        break;
        -:  367:      }
    #####:  368:      default:
        -:  369:      {
    #####:  370:        break;
        -:  371:      }
        -:  372:    }
        -:  373:
       19:  374:    if (property_p == NULL)
        -:  375:    {
       19:  376:      return ECMA_PROPERTY_TYPE_NOT_FOUND;
        -:  377:    }
        -:  378:  }
      102:  379:  else if (type == ECMA_OBJECT_TYPE_CLASS
    #####:  380:           && ((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS
    #####:  381:           && (((ecma_extended_object_t *) object_p)->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -:  382:  {
    #####:  383:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  384:
    #####:  385:    uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  386:
    #####:  387:    if (index < ext_object_p->u.cls.u2.formal_params_number)
        -:  388:    {
    #####:  389:      ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;
        -:  390:
    #####:  391:      ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -:  392:
    #####:  393:      if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)
        -:  394:      {
        -:  395:#if JERRY_LCACHE
        -:  396:        /* Mapped arguments initialized properties MUST not be lcached */
    #####:  397:        if (ecma_is_property_lcached (property_p))
        -:  398:        {
        -:  399:          jmem_cpointer_t prop_name_cp;
        -:  400:
    #####:  401:          if (JERRY_UNLIKELY (ECMA_IS_DIRECT_STRING (property_name_p)))
        -:  402:          {
    #####:  403:            prop_name_cp = (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (property_name_p);
        -:  404:          }
        -:  405:          else
        -:  406:          {
    #####:  407:            ECMA_SET_NON_NULL_POINTER (prop_name_cp, property_name_p);
        -:  408:          }
    #####:  409:          ecma_lcache_invalidate (object_p, prop_name_cp, property_p);
        -:  410:        }
        -:  411:#endif /* JERRY_LCACHE */
    #####:  412:        ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);
    #####:  413:        ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);
        -:  414:
    #####:  415:        ecma_value_t binding_value = ecma_op_get_binding_value (lex_env_p, name_p, true);
        -:  416:
    #####:  417:        ecma_named_data_property_assign_value (object_p,
    #####:  418:                                               ECMA_PROPERTY_VALUE_PTR (property_p),
        -:  419:                                               binding_value);
    #####:  420:        ecma_free_value (binding_value);
        -:  421:      }
        -:  422:    }
        -:  423:  }
        -:  424:
      102:  425:  if (options & ECMA_PROPERTY_GET_EXT_REFERENCE)
        -:  426:  {
    #####:  427:    ((ecma_extended_property_ref_t *) property_ref_p)->property_p = property_p;
        -:  428:  }
        -:  429:
      102:  430:  if (property_ref_p != NULL)
        -:  431:  {
    #####:  432:    property_ref_p->value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  433:  }
        -:  434:
      102:  435:  return *property_p;
        -:  436:} /* ecma_op_object_get_own_property */
        -:  437:
        -:  438:/**
        -:  439: * Generic [[HasProperty]] operation
        -:  440: *
        -:  441: * See also:
        -:  442: *          ECMAScript v6, 9.1.7.1
        -:  443: *
        -:  444: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  445: *         ECMA_VALUE_{TRUE_FALSE} - whether the property is found
        -:  446: */
        -:  447:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
      108:  448:ecma_op_object_has_property (ecma_object_t *object_p, /**< the object */
        -:  449:                             ecma_string_t *property_name_p) /**< property name */
        -:  450:{
        -:  451:  while (true)
        3:  452:  {
        -:  453:#if JERRY_BUILTIN_PROXY
      108:  454:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  455:    {
    #####:  456:      return ecma_proxy_object_has (object_p, property_name_p);
        -:  457:    }
        -:  458:#endif /* JERRY_BUILTIN_PROXY */
        -:  459:
        -:  460:#if JERRY_BUILTIN_TYPEDARRAY
      108:  461:    if (ecma_object_is_typedarray (object_p) && !ecma_prop_name_is_symbol (property_name_p))
        -:  462:    {
    #####:  463:      ecma_number_t num = ecma_string_to_number (property_name_p);
        -:  464:      bool is_same;
    #####:  465:      if (num <= 0)
        -:  466:      {
    #####:  467:        is_same = true;
        -:  468:      }
        -:  469:      else
        -:  470:      {
    #####:  471:        ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####:  472:        is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
    #####:  473:        ecma_deref_ecma_string (num_to_str);
        -:  474:      }
        -:  475:
    #####:  476:      if (is_same)
        -:  477:      {
    #####:  478:        ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
        -:  479:
    #####:  480:        if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -:  481:        {
    #####:  482:          return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  483:        }
        -:  484:
    #####:  485:        if (!ecma_op_is_integer (num)
    #####:  486:            || num >= info.length
    #####:  487:            || num < 0
    #####:  488:            || (ecma_number_is_negative (num) && ecma_number_is_zero (num)))
        -:  489:        {
    #####:  490:          return ECMA_VALUE_FALSE;
        -:  491:        }
        -:  492:
    #####:  493:        return ECMA_VALUE_TRUE;
        -:  494:      }
        -:  495:    }
        -:  496:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:  497:
        -:  498:    /* 2 - 3. */
      108:  499:    if (ecma_op_ordinary_object_has_own_property (object_p, property_name_p))
        -:  500:    {
      102:  501:      return ECMA_VALUE_TRUE;
        -:  502:    }
        -:  503:
        6:  504:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);
        -:  505:
        -:  506:    /* 7. */
        6:  507:    if (proto_cp == JMEM_CP_NULL)
        -:  508:    {
        3:  509:      return ECMA_VALUE_FALSE;
        -:  510:    }
        -:  511:
        3:  512:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
        -:  513:  }
        -:  514:} /* ecma_op_object_has_property */
        -:  515:
        -:  516:/**
        -:  517: * Search the value corresponding to a property name
        -:  518: *
        -:  519: * Note: search includes prototypes
        -:  520: *
        -:  521: * @return ecma value if property is found
        -:  522: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  523: *         Returned value must be freed with ecma_free_value
        -:  524: */
        -:  525:ecma_value_t
      209:  526:ecma_op_object_find_own (ecma_value_t base_value, /**< base value */
        -:  527:                         ecma_object_t *object_p, /**< target object */
        -:  528:                         ecma_string_t *property_name_p) /**< property name */
        -:  529:{
      209:  530:  JERRY_ASSERT (object_p != NULL
        -:  531:                && !ecma_is_lexical_environment (object_p));
      209:  532:  JERRY_ASSERT (property_name_p != NULL);
      209:  533:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -:  534:
      209:  535:  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);
        -:  536:
      209:  537:  switch (base_type)
        -:  538:  {
    #####:  539:    case ECMA_OBJECT_BASE_TYPE_CLASS:
        -:  540:    {
    #####:  541:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  542:
    #####:  543:      switch (ext_object_p->u.cls.type)
        -:  544:      {
    #####:  545:        case ECMA_OBJECT_CLASS_STRING:
        -:  546:        {
    #####:  547:          if (ecma_string_is_length (property_name_p))
        -:  548:          {
    #####:  549:            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
        -:  550:
    #####:  551:            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
    #####:  552:            lit_utf8_size_t length = ecma_string_get_length (prim_value_str_p);
        -:  553:
    #####:  554:            return ecma_make_uint32_value (length);
        -:  555:          }
        -:  556:
    #####:  557:          uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  558:
    #####:  559:          if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  560:          {
    #####:  561:            ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
        -:  562:
    #####:  563:            ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -:  564:
    #####:  565:            if (index < ecma_string_get_length (prim_value_str_p))
        -:  566:            {
    #####:  567:              ecma_char_t char_at_idx = ecma_string_get_char_at_pos (prim_value_str_p, index);
    #####:  568:              return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (char_at_idx));
        -:  569:            }
        -:  570:          }
    #####:  571:          break;
        -:  572:        }
    #####:  573:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -:  574:        {
    #####:  575:          if (!(ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -:  576:          {
    #####:  577:            break;
        -:  578:          }
        -:  579:
    #####:  580:          uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  581:
    #####:  582:          if (index < ext_object_p->u.cls.u2.formal_params_number)
        -:  583:          {
    #####:  584:            ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;
        -:  585:
    #####:  586:            ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -:  587:
    #####:  588:            if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)
        -:  589:            {
    #####:  590:              ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);
    #####:  591:              ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);
        -:  592:
    #####:  593:              return ecma_op_get_binding_value (lex_env_p, name_p, true);
        -:  594:            }
        -:  595:          }
    #####:  596:          break;
        -:  597:        }
        -:  598:#if JERRY_BUILTIN_TYPEDARRAY
        -:  599:        /* ES2015 9.4.5.4 */
    #####:  600:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -:  601:        {
    #####:  602:          if (ecma_prop_name_is_symbol (property_name_p))
        -:  603:          {
    #####:  604:            break;
        -:  605:          }
        -:  606:
    #####:  607:          ecma_number_t num = ecma_string_to_number (property_name_p);
        -:  608:          bool is_same;
    #####:  609:          if (num <= 0)
        -:  610:          {
    #####:  611:            is_same = true;
        -:  612:          }
        -:  613:          else
        -:  614:          {
    #####:  615:            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####:  616:            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
    #####:  617:            ecma_deref_ecma_string (num_to_str);
        -:  618:          }
        -:  619:
    #####:  620:          if (is_same)
        -:  621:          {
    #####:  622:            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
    #####:  623:            return ecma_get_typedarray_element (&info, num);
        -:  624:          }
        -:  625:
    #####:  626:          break;
        -:  627:        }
        -:  628:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:  629:#if JERRY_MODULE_SYSTEM
    #####:  630:        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:
        -:  631:        {
    #####:  632:          if (JERRY_UNLIKELY (ecma_prop_name_is_symbol (property_name_p)))
        -:  633:          {
        -:  634:            /* ECMA-262 v11, 26.3.1 */
    #####:  635:            if (ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG))
        -:  636:            {
    #####:  637:              return ecma_make_magic_string_value (LIT_MAGIC_STRING_MODULE_UL);
        -:  638:            }
        -:  639:
    #####:  640:            return ECMA_VALUE_NOT_FOUND;
        -:  641:          }
        -:  642:
    #####:  643:          ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -:  644:
    #####:  645:          if (property_p == NULL)
        -:  646:          {
    #####:  647:            return ECMA_VALUE_NOT_FOUND;
        -:  648:          }
        -:  649:
    #####:  650:          JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  651:
    #####:  652:          ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  653:
    #####:  654:          if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  655:          {
    #####:  656:            prop_value_p = ecma_get_property_value_from_named_reference (prop_value_p);
        -:  657:
    #####:  658:            if (JERRY_UNLIKELY (prop_value_p->value == ECMA_VALUE_UNINITIALIZED))
        -:  659:            {
    #####:  660:              return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -:  661:            }
        -:  662:          }
        -:  663:
    #####:  664:          return ecma_fast_copy_value (prop_value_p->value);
        -:  665:        }
        -:  666:#endif /* JERRY_MODULE_SYSTEM */
        -:  667:      }
    #####:  668:      break;
        -:  669:    }
      204:  670:    case ECMA_OBJECT_BASE_TYPE_ARRAY:
        -:  671:    {
      204:  672:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  673:
      204:  674:      if (ecma_string_is_length (property_name_p))
        -:  675:      {
    #####:  676:        return ecma_make_uint32_value (ext_object_p->u.array.length);
        -:  677:      }
        -:  678:
      204:  679:      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))
        -:  680:      {
      102:  681:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  682:
      102:  683:        if (JERRY_LIKELY (index != ECMA_STRING_NOT_ARRAY_INDEX))
        -:  684:        {
    #####:  685:          if (JERRY_LIKELY (index < ext_object_p->u.array.length))
        -:  686:          {
    #####:  687:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -:  688:
    #####:  689:            return (ecma_is_value_array_hole (values_p[index]) ? ECMA_VALUE_NOT_FOUND
    #####:  690:                                                               : ecma_fast_copy_value (values_p[index]));
        -:  691:          }
        -:  692:        }
      102:  693:        return ECMA_VALUE_NOT_FOUND;
        -:  694:      }
        -:  695:
      102:  696:      break;
        -:  697:    }
        5:  698:    default:
        -:  699:    {
        5:  700:      break;
        -:  701:    }
        -:  702:  }
        -:  703:
      107:  704:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -:  705:
      107:  706:  if (property_p == NULL)
        -:  707:  {
        7:  708:    switch (ecma_get_object_type (object_p))
        -:  709:    {
        2:  710:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -:  711:      {
        2:  712:        if (ecma_builtin_function_is_routine (object_p))
        -:  713:        {
    #####:  714:          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
    #####:  715:          break;
        -:  716:        }
        -:  717:        /* FALLTHRU */
        -:  718:      }
        -:  719:      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -:  720:      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -:  721:      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -:  722:      {
        6:  723:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
        6:  724:        break;
        -:  725:      }
    #####:  726:      case ECMA_OBJECT_TYPE_CLASS:
        -:  727:      {
    #####:  728:        if (((ecma_extended_object_t *) object_p)->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS)
        -:  729:        {
    #####:  730:          property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);
        -:  731:        }
    #####:  732:        break;
        -:  733:      }
    #####:  734:      case ECMA_OBJECT_TYPE_FUNCTION:
        -:  735:      {
        -:  736:#if !JERRY_ESNEXT
    #####:  737:        if (ecma_string_is_length (property_name_p))
        -:  738:        {
        -:  739:          /* Get length virtual property. */
    #####:  740:          ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
    #####:  741:          const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_func_p);
        -:  742:
        -:  743:          uint32_t len;
    #####:  744:          if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  745:          {
    #####:  746:            cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_data_p;
    #####:  747:            len = args_p->argument_end;
        -:  748:          }
        -:  749:          else
        -:  750:          {
    #####:  751:            cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_data_p;
    #####:  752:            len = args_p->argument_end;
        -:  753:          }
        -:  754:
    #####:  755:          return ecma_make_uint32_value (len);
        -:  756:        }
        -:  757:#endif /* !JERRY_ESNEXT */
        -:  758:
        -:  759:        /* Get prototype physical property. */
    #####:  760:        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  761:        break;
        -:  762:      }
    #####:  763:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -:  764:      {
    #####:  765:        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  766:        break;
        -:  767:      }
    #####:  768:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -:  769:      {
    #####:  770:        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####:  771:        break;
        -:  772:      }
        1:  773:      default:
        -:  774:      {
        1:  775:        break;
        -:  776:      }
        -:  777:    }
        -:  778:
        7:  779:    if (property_p == NULL)
        -:  780:    {
        2:  781:      return ECMA_VALUE_NOT_FOUND;
        -:  782:    }
        -:  783:  }
        -:  784:
      105:  785:  JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  786:
      105:  787:  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  788:
      105:  789:  if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  790:  {
      104:  791:    return ecma_fast_copy_value (prop_value_p->value);
        -:  792:  }
        -:  793:
        1:  794:  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);
        -:  795:
        1:  796:  if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -:  797:  {
    #####:  798:    return ECMA_VALUE_UNDEFINED;
        -:  799:  }
        -:  800:
        1:  801:  ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
        -:  802:
        1:  803:  return ecma_op_function_call (getter_p, base_value, NULL, 0);
        -:  804:} /* ecma_op_object_find_own */
        -:  805:
        -:  806:/**
        -:  807: * Search the value corresponding to a property index
        -:  808: *
        -:  809: * Note: this method falls back to the general ecma_op_object_find
        -:  810: *
        -:  811: * @return ecma value if property is found
        -:  812: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  813: *         Returned value must be freed with ecma_free_value
        -:  814: */
        -:  815:ecma_value_t
    #####:  816:ecma_op_object_find_by_index (ecma_object_t *object_p, /**< the object */
        -:  817:                              ecma_length_t index) /**< property index */
        -:  818:{
    #####:  819:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  820:  {
    #####:  821:    return ecma_op_object_find (object_p, ECMA_CREATE_DIRECT_UINT32_STRING (index));
        -:  822:  }
        -:  823:
    #####:  824:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####:  825:  ecma_value_t ret_value = ecma_op_object_find (object_p, index_str_p);
    #####:  826:  ecma_deref_ecma_string (index_str_p);
        -:  827:
    #####:  828:  return ret_value;
        -:  829:} /* ecma_op_object_find_by_index */
        -:  830:
        -:  831:/**
        -:  832: * Search the value corresponding to a property name
        -:  833: *
        -:  834: * Note: search includes prototypes
        -:  835: *
        -:  836: * @return ecma value if property is found
        -:  837: *         ECMA_VALUE_NOT_FOUND if property is not found
        -:  838: *         Returned value must be freed with ecma_free_value
        -:  839: */
        -:  840:ecma_value_t
    #####:  841:ecma_op_object_find (ecma_object_t *object_p, /**< the object */
        -:  842:                     ecma_string_t *property_name_p) /**< property name */
        -:  843:{
    #####:  844:  ecma_value_t base_value = ecma_make_object_value (object_p);
        -:  845:
        -:  846:  while (true)
    #####:  847:  {
        -:  848:#if JERRY_BUILTIN_PROXY
    #####:  849:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  850:    {
    #####:  851:      return ecma_proxy_object_find (object_p, property_name_p);
        -:  852:    }
        -:  853:#endif /* JERRY_BUILTIN_PROXY */
        -:  854:
    #####:  855:    ecma_value_t value = ecma_op_object_find_own (base_value, object_p, property_name_p);
        -:  856:
    #####:  857:    if (ecma_is_value_found (value))
        -:  858:    {
    #####:  859:      return value;
        -:  860:    }
        -:  861:
    #####:  862:    if (object_p->u2.prototype_cp == JMEM_CP_NULL)
        -:  863:    {
    #####:  864:      break;
        -:  865:    }
        -:  866:
    #####:  867:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, object_p->u2.prototype_cp);
        -:  868:  }
        -:  869:
    #####:  870:  return ECMA_VALUE_NOT_FOUND;
        -:  871:} /* ecma_op_object_find */
        -:  872:
        -:  873:/**
        -:  874: * [[Get]] operation of ecma object
        -:  875: *
        -:  876: * This function returns the value of a named property, or undefined
        -:  877: * if the property is not found in the prototype chain. If the property
        -:  878: * is an accessor, it calls the "get" callback function and returns
        -:  879: * with its result (including error throws).
        -:  880: *
        -:  881: * See also:
        -:  882: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  883: *
        -:  884: * @return ecma value
        -:  885: *         Returned value must be freed with ecma_free_value
        -:  886: */
        -:  887:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
      101:  888:ecma_op_object_get (ecma_object_t *object_p, /**< the object */
        -:  889:                    ecma_string_t *property_name_p) /**< property name */
        -:  890:{
      106:  891:  return ecma_op_object_get_with_receiver (object_p, property_name_p, ecma_make_object_value (object_p));
        -:  892:} /* ecma_op_object_get */
        -:  893:
        -:  894:/**
        -:  895: * [[Get]] operation of ecma object with the specified receiver
        -:  896: *
        -:  897: * This function returns the value of a named property, or undefined
        -:  898: * if the property is not found in the prototype chain. If the property
        -:  899: * is an accessor, it calls the "get" callback function and returns
        -:  900: * with its result (including error throws).
        -:  901: *
        -:  902: * See also:
        -:  903: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  904: *
        -:  905: * @return ecma value
        -:  906: *         Returned value must be freed with ecma_free_value
        -:  907: */
        -:  908:ecma_value_t
      209:  909:ecma_op_object_get_with_receiver (ecma_object_t *object_p, /**< the object */
        -:  910:                                  ecma_string_t *property_name_p, /**< property name */
        -:  911:                                  ecma_value_t receiver) /**< receiver to invoke getter function */
        -:  912:{
        -:  913:  while (true)
      103:  914:  {
        -:  915:#if JERRY_BUILTIN_PROXY
      209:  916:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -:  917:    {
    #####:  918:      return ecma_proxy_object_get (object_p, property_name_p, receiver);
        -:  919:    }
        -:  920:#endif /* JERRY_BUILTIN_PROXY */
        -:  921:
      209:  922:    ecma_value_t value = ecma_op_object_find_own (receiver, object_p, property_name_p);
        -:  923:
      209:  924:    if (ecma_is_value_found (value))
        -:  925:    {
      105:  926:      return value;
        -:  927:    }
        -:  928:
      104:  929:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (object_p);
        -:  930:
      104:  931:    if (proto_cp == JMEM_CP_NULL)
        -:  932:    {
        1:  933:      break;
        -:  934:    }
        -:  935:
      103:  936:    object_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
        -:  937:  }
        -:  938:
        1:  939:  return ECMA_VALUE_UNDEFINED;
        -:  940:} /* ecma_op_object_get_with_receiver */
        -:  941:
        -:  942:/**
        -:  943: * [[Get]] operation of ecma object specified for property index
        -:  944: *
        -:  945: * @return ecma value
        -:  946: *         Returned value must be freed with ecma_free_value
        -:  947: */
        -:  948:ecma_value_t
    #####:  949:ecma_op_object_get_by_index (ecma_object_t *object_p, /**< the object */
        -:  950:                             ecma_length_t index) /**< property index */
        -:  951:{
    #####:  952:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  953:  {
    #####:  954:    return ecma_op_object_get (object_p, ECMA_CREATE_DIRECT_UINT32_STRING (index));
        -:  955:  }
        -:  956:
    #####:  957:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####:  958:  ecma_value_t ret_value = ecma_op_object_get (object_p, index_str_p);
    #####:  959:  ecma_deref_ecma_string (index_str_p);
        -:  960:
    #####:  961:  return ret_value;
        -:  962:} /* ecma_op_object_get_by_index */
        -:  963:
        -:  964:/**
        -:  965: * Perform ToLength(O.[[Get]]("length")) operation
        -:  966: *
        -:  967: * The property is converted to uint32 during the operation
        -:  968: *
        -:  969: * @return ECMA_VALUE_ERROR - if there was any error during the operation
        -:  970: *         ECMA_VALUE_EMPTY - otherwise
        -:  971: */
        -:  972:ecma_value_t
      101:  973:ecma_op_object_get_length (ecma_object_t *object_p, /**< the object */
        -:  974:                           ecma_length_t *length_p) /**< [out] length value converted to uint32 */
        -:  975:{
      101:  976:  if (JERRY_LIKELY (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY))
        -:  977:  {
      101:  978:    *length_p = (ecma_length_t) ecma_array_get_length (object_p);
      101:  979:    return ECMA_VALUE_EMPTY;
        -:  980:  }
        -:  981:
    #####:  982:  ecma_value_t len_value = ecma_op_object_get_by_magic_id (object_p, LIT_MAGIC_STRING_LENGTH);
    #####:  983:  ecma_value_t len_number = ecma_op_to_length (len_value, length_p);
    #####:  984:  ecma_free_value (len_value);
        -:  985:
    #####:  986:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (len_number) || ecma_is_value_empty (len_number));
        -:  987:
    #####:  988:  return len_number;
        -:  989:} /* ecma_op_object_get_length */
        -:  990:
        -:  991:/**
        -:  992: * [[Get]] operation of ecma object where the property name is a magic string
        -:  993: *
        -:  994: * This function returns the value of a named property, or undefined
        -:  995: * if the property is not found in the prototype chain. If the property
        -:  996: * is an accessor, it calls the "get" callback function and returns
        -:  997: * with its result (including error throws).
        -:  998: *
        -:  999: * See also:
        -: 1000: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1001: *
        -: 1002: * @return ecma value
        -: 1003: *         Returned value must be freed with ecma_free_value
        -: 1004: */
        -: 1005:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
        3: 1006:ecma_op_object_get_by_magic_id (ecma_object_t *object_p, /**< the object */
        -: 1007:                                lit_magic_string_id_t property_id) /**< property magic string id */
        -: 1008:{
        6: 1009:  return ecma_op_object_get (object_p, ecma_get_magic_string (property_id));
        -: 1010:} /* ecma_op_object_get_by_magic_id */
        -: 1011:
        -: 1012:#if JERRY_ESNEXT
        -: 1013:
        -: 1014:/**
        -: 1015: * Descriptor string for each global symbol
        -: 1016: */
        -: 1017:static const uint16_t ecma_global_symbol_descriptions[] =
        -: 1018:{
        -: 1019:  LIT_MAGIC_STRING_ASYNC_ITERATOR,
        -: 1020:  LIT_MAGIC_STRING_HAS_INSTANCE,
        -: 1021:  LIT_MAGIC_STRING_IS_CONCAT_SPREADABLE,
        -: 1022:  LIT_MAGIC_STRING_ITERATOR,
        -: 1023:  LIT_MAGIC_STRING_MATCH,
        -: 1024:  LIT_MAGIC_STRING_REPLACE,
        -: 1025:  LIT_MAGIC_STRING_SEARCH,
        -: 1026:  LIT_MAGIC_STRING_SPECIES,
        -: 1027:  LIT_MAGIC_STRING_SPLIT,
        -: 1028:  LIT_MAGIC_STRING_TO_PRIMITIVE,
        -: 1029:  LIT_MAGIC_STRING_TO_STRING_TAG,
        -: 1030:  LIT_MAGIC_STRING_UNSCOPABLES,
        -: 1031:  LIT_MAGIC_STRING_MATCH_ALL,
        -: 1032:};
        -: 1033:
        -: 1034:JERRY_STATIC_ASSERT (sizeof (ecma_global_symbol_descriptions) / sizeof (uint16_t) == ECMA_BUILTIN_GLOBAL_SYMBOL_COUNT,
        -: 1035:                     ecma_global_symbol_descriptions_must_have_global_symbol_count_elements);
        -: 1036:
        -: 1037:/**
        -: 1038: * [[Get]] a well-known symbol by the given property id
        -: 1039: *
        -: 1040: * @return pointer to the requested well-known symbol
        -: 1041: */
        -: 1042:ecma_string_t *
        2: 1043:ecma_op_get_global_symbol (lit_magic_string_id_t property_id) /**< property symbol id */
        -: 1044:{
        2: 1045:  JERRY_ASSERT (LIT_IS_GLOBAL_SYMBOL (property_id));
        -: 1046:
        2: 1047:  uint32_t symbol_index = (uint32_t) property_id - (uint32_t) LIT_GLOBAL_SYMBOL__FIRST;
        2: 1048:  jmem_cpointer_t symbol_cp = JERRY_CONTEXT (global_symbols_cp)[symbol_index];
        -: 1049:
        2: 1050:  if (symbol_cp != JMEM_CP_NULL)
        -: 1051:  {
    #####: 1052:    ecma_string_t *symbol_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, symbol_cp);
    #####: 1053:    ecma_ref_ecma_string (symbol_p);
    #####: 1054:    return symbol_p;
        -: 1055:  }
        -: 1056:
        2: 1057:  ecma_string_t *symbol_dot_p = ecma_get_magic_string (LIT_MAGIC_STRING_SYMBOL_DOT_UL);
        2: 1058:  uint16_t description = ecma_global_symbol_descriptions[symbol_index];
        2: 1059:  ecma_string_t *name_p = ecma_get_magic_string ((lit_magic_string_id_t) description);
        2: 1060:  ecma_string_t *descriptor_p = ecma_concat_ecma_strings (symbol_dot_p, name_p);
        -: 1061:
        2: 1062:  ecma_string_t *symbol_p = ecma_new_symbol_from_descriptor_string (ecma_make_string_value (descriptor_p));
        2: 1063:  symbol_p->u.hash = (uint16_t) ((property_id << ECMA_GLOBAL_SYMBOL_SHIFT) | ECMA_GLOBAL_SYMBOL_FLAG);
        -: 1064:
        2: 1065:  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (global_symbols_cp)[symbol_index], symbol_p);
        -: 1066:
        2: 1067:  ecma_ref_ecma_string (symbol_p);
        2: 1068:  return symbol_p;
        -: 1069:} /* ecma_op_get_global_symbol */
        -: 1070:
        -: 1071:/**
        -: 1072: * Checks whether the string equals to the global symbol.
        -: 1073: *
        -: 1074: * @return true - if the string equals to the global symbol
        -: 1075: *         false - otherwise
        -: 1076: */
        -: 1077:bool
    #####: 1078:ecma_op_compare_string_to_global_symbol (ecma_string_t *string_p, /**< string to compare */
        -: 1079:                                         lit_magic_string_id_t property_id) /**< property symbol id */
        -: 1080:{
    #####: 1081:  JERRY_ASSERT (LIT_IS_GLOBAL_SYMBOL (property_id));
        -: 1082:
    #####: 1083:  uint32_t symbol_index = (uint32_t) property_id - (uint32_t) LIT_GLOBAL_SYMBOL__FIRST;
    #####: 1084:  jmem_cpointer_t symbol_cp = JERRY_CONTEXT (global_symbols_cp)[symbol_index];
        -: 1085:
        -: 1086:  return (symbol_cp != JMEM_CP_NULL
    #####: 1087:          && string_p == ECMA_GET_NON_NULL_POINTER (ecma_string_t, symbol_cp));
        -: 1088:} /* ecma_op_compare_string_to_global_symbol */
        -: 1089:
        -: 1090:/**
        -: 1091: * [[Get]] operation of ecma object where the property is a well-known symbol
        -: 1092: *
        -: 1093: * @return ecma value
        -: 1094: *         Returned value must be freed with ecma_free_value
        -: 1095: */
        -: 1096:ecma_value_t
        1: 1097:ecma_op_object_get_by_symbol_id (ecma_object_t *object_p, /**< the object */
        -: 1098:                                 lit_magic_string_id_t property_id) /**< property symbol id */
        -: 1099:{
        1: 1100:  ecma_string_t *symbol_p = ecma_op_get_global_symbol (property_id);
        1: 1101:  ecma_value_t ret_value = ecma_op_object_get (object_p, symbol_p);
        1: 1102:  ecma_deref_ecma_string (symbol_p);
        -: 1103:
        1: 1104:  return ret_value;
        -: 1105:} /* ecma_op_object_get_by_symbol_id */
        -: 1106:
        -: 1107:/**
        -: 1108: * GetMethod operation
        -: 1109: *
        -: 1110: * See also: ECMA-262 v6, 7.3.9
        -: 1111: *
        -: 1112: * Note:
        -: 1113: *      Returned value must be freed with ecma_free_value.
        -: 1114: *
        -: 1115: * @return iterator function object - if success
        -: 1116: *         raised error - otherwise
        -: 1117: */
        -: 1118:static ecma_value_t
        1: 1119:ecma_op_get_method (ecma_value_t value, /**< ecma value */
        -: 1120:                    ecma_string_t *prop_name_p) /** property name */
        -: 1121:{
        -: 1122:  /* 2. */
        1: 1123:  ecma_value_t obj_value = ecma_op_to_object (value);
        -: 1124:
        1: 1125:  if (ECMA_IS_VALUE_ERROR (obj_value))
        -: 1126:  {
    #####: 1127:    return obj_value;
        -: 1128:  }
        -: 1129:
        1: 1130:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
        -: 1131:  ecma_value_t func;
        -: 1132:
        1: 1133:  func = ecma_op_object_get (obj_p, prop_name_p);
        1: 1134:  ecma_deref_object (obj_p);
        -: 1135:
        -: 1136:  /* 3. */
        1: 1137:  if (ECMA_IS_VALUE_ERROR (func))
        -: 1138:  {
    #####: 1139:    return func;
        -: 1140:  }
        -: 1141:
        -: 1142:  /* 4. */
        1: 1143:  if (ecma_is_value_undefined (func) || ecma_is_value_null (func))
        -: 1144:  {
        1: 1145:    return ECMA_VALUE_UNDEFINED;
        -: 1146:  }
        -: 1147:
        -: 1148:  /* 5. */
    #####: 1149:  if (!ecma_op_is_callable (func))
        -: 1150:  {
    #####: 1151:    ecma_free_value (func);
    #####: 1152:    return ecma_raise_type_error (ECMA_ERR_MSG ("Iterator is not callable"));
        -: 1153:  }
        -: 1154:
        -: 1155:  /* 6. */
    #####: 1156:  return func;
        -: 1157:} /* ecma_op_get_method */
        -: 1158:
        -: 1159:/**
        -: 1160: * GetMethod operation when the property is a well-known symbol
        -: 1161: *
        -: 1162: * See also: ECMA-262 v6, 7.3.9
        -: 1163: *
        -: 1164: * Note:
        -: 1165: *      Returned value must be freed with ecma_free_value.
        -: 1166: *
        -: 1167: * @return iterator function object - if success
        -: 1168: *         raised error - otherwise
        -: 1169: */
        -: 1170:ecma_value_t
        1: 1171:ecma_op_get_method_by_symbol_id (ecma_value_t value, /**< ecma value */
        -: 1172:                                 lit_magic_string_id_t symbol_id) /**< property symbol id */
        -: 1173:{
        1: 1174:  ecma_string_t *prop_name_p = ecma_op_get_global_symbol (symbol_id);
        1: 1175:  ecma_value_t ret_value = ecma_op_get_method (value, prop_name_p);
        1: 1176:  ecma_deref_ecma_string (prop_name_p);
        -: 1177:
        1: 1178:  return ret_value;
        -: 1179:} /* ecma_op_get_method_by_symbol_id */
        -: 1180:
        -: 1181:/**
        -: 1182: * GetMethod operation when the property is a magic string
        -: 1183: *
        -: 1184: * See also: ECMA-262 v6, 7.3.9
        -: 1185: *
        -: 1186: * Note:
        -: 1187: *      Returned value must be freed with ecma_free_value.
        -: 1188: *
        -: 1189: * @return iterator function object - if success
        -: 1190: *         raised error - otherwise
        -: 1191: */
        -: 1192:ecma_value_t
    #####: 1193:ecma_op_get_method_by_magic_id (ecma_value_t value, /**< ecma value */
        -: 1194:                                lit_magic_string_id_t magic_id) /**< property magic id */
        -: 1195:{
    #####: 1196:  return ecma_op_get_method (value, ecma_get_magic_string (magic_id));
        -: 1197:} /* ecma_op_get_method_by_magic_id */
        -: 1198:#endif /* JERRY_ESNEXT */
        -: 1199:
        -: 1200:/**
        -: 1201: * [[Put]] ecma general object's operation specialized for property index
        -: 1202: *
        -: 1203: * Note: This function falls back to the general ecma_op_object_put
        -: 1204: *
        -: 1205: * @return ecma value
        -: 1206: *         The returned value must be freed with ecma_free_value.
        -: 1207: */
        -: 1208:ecma_value_t
    #####: 1209:ecma_op_object_put_by_index (ecma_object_t *object_p, /**< the object */
        -: 1210:                             ecma_length_t index, /**< property index */
        -: 1211:                             ecma_value_t value, /**< ecma value */
        -: 1212:                             bool is_throw) /**< flag that controls failure handling */
        -: 1213:{
    #####: 1214:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -: 1215:  {
    #####: 1216:    return ecma_op_object_put (object_p,
    #####: 1217:                               ECMA_CREATE_DIRECT_UINT32_STRING (index),
        -: 1218:                               value,
        -: 1219:                               is_throw);
        -: 1220:  }
        -: 1221:
    #####: 1222:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####: 1223:  ecma_value_t ret_value = ecma_op_object_put (object_p, index_str_p, value, is_throw);
    #####: 1224:  ecma_deref_ecma_string (index_str_p);
        -: 1225:
    #####: 1226:  return ret_value;
        -: 1227:} /* ecma_op_object_put_by_index */
        -: 1228:
        -: 1229:/**
        -: 1230: * [[Put]] ecma general object's operation
        -: 1231: *
        -: 1232: * See also:
        -: 1233: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1234: *          ECMA-262 v5, 8.12.5
        -: 1235: *          Also incorporates [[CanPut]] ECMA-262 v5, 8.12.4
        -: 1236: *
        -: 1237: * @return ecma value
        -: 1238: *         The returned value must be freed with ecma_free_value.
        -: 1239: *
        -: 1240: *         Returns with ECMA_VALUE_TRUE if the operation is
        -: 1241: *         successful. Otherwise it returns with an error object
        -: 1242: *         or ECMA_VALUE_FALSE.
        -: 1243: *
        -: 1244: *         Note: even if is_throw is false, the setter can throw an
        -: 1245: *         error, and this function returns with that error.
        -: 1246: */
        -: 1247:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
      107: 1248:ecma_op_object_put (ecma_object_t *object_p, /**< the object */
        -: 1249:                    ecma_string_t *property_name_p, /**< property name */
        -: 1250:                    ecma_value_t value, /**< ecma value */
        -: 1251:                    bool is_throw) /**< flag that controls failure handling */
        -: 1252:{
      107: 1253:  return ecma_op_object_put_with_receiver (object_p,
        -: 1254:                                           property_name_p,
        -: 1255:                                           value,
        -: 1256:                                           ecma_make_object_value (object_p),
        -: 1257:                                           is_throw);
        -: 1258:} /* ecma_op_object_put */
        -: 1259:
        -: 1260:#if JERRY_ESNEXT
        -: 1261:/**
        -: 1262: * [[Set]] ( P, V, Receiver) operation part for ordinary objects
        -: 1263: *
        -: 1264: * See also: ECMAScript v6, 9.19.9
        -: 1265: *
        -: 1266: * @return ecma value
        -: 1267: *         The returned value must be freed with ecma_free_value.
        -: 1268: */
        -: 1269:static ecma_value_t
        5: 1270:ecma_op_object_put_apply_receiver (ecma_value_t receiver, /**< receiver */
        -: 1271:                                   ecma_string_t *property_name_p, /**< property name */
        -: 1272:                                   ecma_value_t value, /**< value to set */
        -: 1273:                                   bool is_throw) /**< flag that controls failure handling */
        -: 1274:{
        -: 1275:  /* 5.b */
        5: 1276:  if (!ecma_is_value_object (receiver))
        -: 1277:  {
    #####: 1278:    return ECMA_REJECT (is_throw, "Receiver must be an object");
        -: 1279:  }
        -: 1280:
        5: 1281:  ecma_object_t *receiver_obj_p = ecma_get_object_from_value (receiver);
        -: 1282:
        5: 1283:  ecma_property_descriptor_t prop_desc;
        -: 1284:  /* 5.c */
        5: 1285:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (receiver_obj_p,
        -: 1286:                                                                    property_name_p,
        -: 1287:                                                                    &prop_desc);
        -: 1288:
        -: 1289:  /* 5.d */
        5: 1290:  if (ECMA_IS_VALUE_ERROR (status))
        -: 1291:  {
    #####: 1292:    return status;
        -: 1293:  }
        -: 1294:
        -: 1295:  /* 5.e */
        5: 1296:  if (ecma_is_value_true (status))
        -: 1297:  {
        -: 1298:    ecma_value_t result;
        -: 1299:
        -: 1300:    /* 5.e.i - 5.e.ii */
    #####: 1301:    if (prop_desc.flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)
    #####: 1302:        || !(prop_desc.flags & JERRY_PROP_IS_WRITABLE))
        -: 1303:    {
    #####: 1304:      result = ecma_raise_property_redefinition (property_name_p, prop_desc.flags);
        -: 1305:    }
        -: 1306:    else
        -: 1307:    {
        -: 1308:      /* 5.e.iii */
    #####: 1309:      JERRY_ASSERT (prop_desc.flags & JERRY_PROP_IS_VALUE_DEFINED);
    #####: 1310:      ecma_free_value (prop_desc.value);
    #####: 1311:      prop_desc.value = ecma_copy_value (value);
        -: 1312:
        -: 1313:      /* 5.e.iv */
    #####: 1314:      result = ecma_op_object_define_own_property (receiver_obj_p, property_name_p, &prop_desc);
        -: 1315:
    #####: 1316:      if (JERRY_UNLIKELY (ecma_is_value_false (result)))
        -: 1317:      {
    #####: 1318:        result = ECMA_REJECT (is_throw, "Proxy trap returned falsish");
        -: 1319:      }
        -: 1320:    }
        -: 1321:
    #####: 1322:    ecma_free_property_descriptor (&prop_desc);
        -: 1323:
    #####: 1324:    return result;
        -: 1325:  }
        -: 1326:
        -: 1327:#if JERRY_BUILTIN_PROXY
        5: 1328:  if (ECMA_OBJECT_IS_PROXY (receiver_obj_p))
        -: 1329:  {
    #####: 1330:    ecma_property_descriptor_t desc;
        -: 1331:    /* Based on: ES6 9.1.9 [[Set]] 4.d.i. / ES11 9.1.9.2 OrdinarySetWithOwnDescriptor 2.c.i. */
    #####: 1332:    desc.flags = (JERRY_PROP_IS_CONFIGURABLE
        -: 1333:                  | JERRY_PROP_IS_CONFIGURABLE_DEFINED
        -: 1334:                  | JERRY_PROP_IS_ENUMERABLE
        -: 1335:                  | JERRY_PROP_IS_ENUMERABLE_DEFINED
        -: 1336:                  | JERRY_PROP_IS_WRITABLE
        -: 1337:                  | JERRY_PROP_IS_WRITABLE_DEFINED
        -: 1338:                  | JERRY_PROP_IS_VALUE_DEFINED);
    #####: 1339:    desc.value = value;
    #####: 1340:    ecma_value_t ret_value = ecma_proxy_object_define_own_property (receiver_obj_p, property_name_p, &desc);
        -: 1341:
    #####: 1342:    if (JERRY_UNLIKELY (ecma_is_value_false (ret_value)))
        -: 1343:    {
    #####: 1344:      ret_value = ECMA_REJECT (is_throw, "Proxy trap returned falsish");
        -: 1345:    }
        -: 1346:
    #####: 1347:    return ret_value;
        -: 1348:  }
        -: 1349:#endif /* JERRY_BUILTIN_PROXY */
        -: 1350:
        5: 1351:  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (receiver_obj_p)))
        -: 1352:  {
    #####: 1353:    ecma_fast_array_convert_to_normal (receiver_obj_p);
        -: 1354:  }
        -: 1355:
        -: 1356:  /* 5.f.i */
        -: 1357:  ecma_property_value_t *new_prop_value_p;
        5: 1358:  new_prop_value_p = ecma_create_named_data_property (receiver_obj_p,
        -: 1359:                                                      property_name_p,
        -: 1360:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 1361:                                                      NULL);
        5: 1362:  JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));
        5: 1363:  new_prop_value_p->value = ecma_copy_value_if_not_object (value);
        -: 1364:
        5: 1365:  return ECMA_VALUE_TRUE;
        -: 1366:} /* ecma_op_object_put_apply_receiver */
        -: 1367:#endif /* JERRY_ESNEXT */
        -: 1368:
        -: 1369:/**
        -: 1370: * [[Put]] ecma general object's operation with given receiver
        -: 1371: *
        -: 1372: * See also:
        -: 1373: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1374: *          ECMA-262 v5, 8.12.5
        -: 1375: *          ECMA-262 v6, 9.1.9
        -: 1376: *          Also incorporates [[CanPut]] ECMA-262 v5, 8.12.4
        -: 1377: *
        -: 1378: * @return ecma value
        -: 1379: *         The returned value must be freed with ecma_free_value.
        -: 1380: *
        -: 1381: *         Returns with ECMA_VALUE_TRUE if the operation is
        -: 1382: *         successful. Otherwise it returns with an error object
        -: 1383: *         or ECMA_VALUE_FALSE.
        -: 1384: *
        -: 1385: *         Note: even if is_throw is false, the setter can throw an
        -: 1386: *         error, and this function returns with that error.
        -: 1387: */
        -: 1388:ecma_value_t
      108: 1389:ecma_op_object_put_with_receiver (ecma_object_t *object_p, /**< the object */
        -: 1390:                                  ecma_string_t *property_name_p, /**< property name */
        -: 1391:                                  ecma_value_t value, /**< ecma value */
        -: 1392:                                  ecma_value_t receiver, /**< receiver */
        -: 1393:                                  bool is_throw) /**< flag that controls failure handling */
        -: 1394:{
      108: 1395:  JERRY_ASSERT (object_p != NULL
        -: 1396:                && !ecma_is_lexical_environment (object_p));
      108: 1397:  JERRY_ASSERT (property_name_p != NULL);
        -: 1398:
        -: 1399:#if JERRY_BUILTIN_PROXY
      108: 1400:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 1401:  {
    #####: 1402:    return ecma_proxy_object_set (object_p, property_name_p, value, receiver, is_throw);
        -: 1403:  }
        -: 1404:#endif /* JERRY_BUILTIN_PROXY */
        -: 1405:
      108: 1406:  ecma_object_base_type_t base_type = ecma_get_object_base_type (object_p);
        -: 1407:
      108: 1408:  switch (base_type)
        -: 1409:  {
    #####: 1410:    case ECMA_OBJECT_BASE_TYPE_CLASS:
        -: 1411:    {
    #####: 1412:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1413:
    #####: 1414:      switch (ext_object_p->u.cls.type)
        -: 1415:      {
    #####: 1416:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 1417:        {
    #####: 1418:          if (!(ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -: 1419:          {
    #####: 1420:            break;
        -: 1421:          }
        -: 1422:
    #####: 1423:          uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1424:
    #####: 1425:          if (index < ext_object_p->u.cls.u2.formal_params_number)
        -: 1426:          {
    #####: 1427:            ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;
        -: 1428:
    #####: 1429:            ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -: 1430:
    #####: 1431:            if (!ecma_is_value_empty (argv_p[index]) && argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK)
        -: 1432:            {
    #####: 1433:              ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);
    #####: 1434:              ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);
    #####: 1435:              ecma_op_set_mutable_binding (lex_env_p, name_p, value, true);
    #####: 1436:              return ECMA_VALUE_TRUE;
        -: 1437:            }
        -: 1438:          }
    #####: 1439:          break;
        -: 1440:        }
        -: 1441:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1442:        /* ES2015 9.4.5.5 */
    #####: 1443:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 1444:        {
    #####: 1445:          if (ecma_prop_name_is_symbol (property_name_p))
        -: 1446:          {
    #####: 1447:            break;
        -: 1448:          }
        -: 1449:
    #####: 1450:          ecma_number_t num = ecma_string_to_number (property_name_p);
        -: 1451:          bool is_same;
    #####: 1452:          if (num <= 0)
        -: 1453:          {
    #####: 1454:            is_same = true;
        -: 1455:          }
        -: 1456:          else
        -: 1457:          {
    #####: 1458:            ecma_string_t *num_to_str = ecma_new_ecma_string_from_number (num);
    #####: 1459:            is_same = ecma_compare_ecma_strings (property_name_p, num_to_str);
    #####: 1460:            ecma_deref_ecma_string (num_to_str);
        -: 1461:          }
        -: 1462:
    #####: 1463:          if (is_same)
        -: 1464:          {
    #####: 1465:            ecma_typedarray_info_t info = ecma_typedarray_get_info (object_p);
    #####: 1466:            return ecma_set_typedarray_element (&info, value, num);
        -: 1467:          }
    #####: 1468:          break;
        -: 1469:        }
        -: 1470:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1471:#if JERRY_MODULE_SYSTEM
    #####: 1472:        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:
        -: 1473:        {
    #####: 1474:          return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1475:        }
        -: 1476:#endif /* JERRY_MODULE_SYSTEM */
        -: 1477:      }
    #####: 1478:      break;
        -: 1479:    }
        1: 1480:    case ECMA_OBJECT_BASE_TYPE_ARRAY:
        -: 1481:    {
        1: 1482:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1483:
        1: 1484:      if (ecma_string_is_length (property_name_p))
        -: 1485:      {
        1: 1486:        if (ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1487:        {
        1: 1488:          return ecma_op_array_object_set_length (object_p, value, 0);
        -: 1489:        }
        -: 1490:
    #####: 1491:        return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1492:      }
        -: 1493:
    #####: 1494:      if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_object_p)))
        -: 1495:      {
    #####: 1496:        uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1497:
    #####: 1498:        if (JERRY_UNLIKELY (index == ECMA_STRING_NOT_ARRAY_INDEX))
        -: 1499:        {
    #####: 1500:          ecma_fast_array_convert_to_normal (object_p);
        -: 1501:        }
    #####: 1502:        else if (ecma_fast_array_set_property (object_p, index, value))
        -: 1503:        {
    #####: 1504:          return ECMA_VALUE_TRUE;
        -: 1505:        }
        -: 1506:      }
        -: 1507:
    #####: 1508:      JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
    #####: 1509:      break;
        -: 1510:    }
      107: 1511:    default:
        -: 1512:    {
      107: 1513:      break;
        -: 1514:    }
        -: 1515:  }
        -: 1516:
      107: 1517:  ecma_property_t *property_p = ecma_find_named_property (object_p, property_name_p);
        -: 1518:
      107: 1519:  if (property_p == NULL)
        -: 1520:  {
        5: 1521:    switch (ecma_get_object_type (object_p))
        -: 1522:    {
    #####: 1523:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1524:      {
    #####: 1525:        if (ecma_builtin_function_is_routine (object_p))
        -: 1526:        {
    #####: 1527:          property_p = ecma_builtin_routine_try_to_instantiate_property (object_p, property_name_p);
    #####: 1528:          break;
        -: 1529:        }
        -: 1530:        /* FALLTHRU */
        -: 1531:      }
        -: 1532:      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 1533:      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 1534:      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1535:      {
        5: 1536:        property_p = ecma_builtin_try_to_instantiate_property (object_p, property_name_p);
        5: 1537:        break;
        -: 1538:      }
    #####: 1539:      case ECMA_OBJECT_TYPE_CLASS:
        -: 1540:      {
    #####: 1541:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1542:
    #####: 1543:        switch (ext_object_p->u.cls.type)
        -: 1544:        {
    #####: 1545:          case ECMA_OBJECT_CLASS_STRING:
        -: 1546:          {
    #####: 1547:            uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1548:
    #####: 1549:            if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1550:            {
    #####: 1551:              ecma_value_t prim_value_p = ext_object_p->u.cls.u3.value;
    #####: 1552:              ecma_string_t *prim_value_str_p = ecma_get_string_from_value (prim_value_p);
        -: 1553:
    #####: 1554:              if (index < ecma_string_get_length (prim_value_str_p))
        -: 1555:              {
    #####: 1556:                return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1557:              }
        -: 1558:            }
    #####: 1559:            break;
        -: 1560:          }
    #####: 1561:          case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 1562:          {
    #####: 1563:            property_p = ecma_op_arguments_object_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####: 1564:            break;
        -: 1565:          }
        -: 1566:        }
    #####: 1567:        break;
        -: 1568:      }
    #####: 1569:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1570:      {
    #####: 1571:        if (ecma_string_is_length (property_name_p))
        -: 1572:        {
        -: 1573:          /* Uninitialized 'length' property is non-writable (ECMA-262 v6, 19.2.4.1) */
        -: 1574:#if JERRY_ESNEXT
    #####: 1575:          if (!ECMA_GET_FIRST_BIT_FROM_POINTER_TAG (((ecma_extended_object_t *) object_p)->u.function.scope_cp))
        -: 1576:#endif /* JERRY_ESNEXT */
        -: 1577:          {
    #####: 1578:            return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1579:          }
        -: 1580:        }
        -: 1581:
        -: 1582:        /* Get prototype physical property. */
    #####: 1583:        property_p = ecma_op_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####: 1584:        break;
        -: 1585:      }
    #####: 1586:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1587:      {
    #####: 1588:        property_p = ecma_op_external_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####: 1589:        break;
        -: 1590:      }
    #####: 1591:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1592:      {
    #####: 1593:        property_p = ecma_op_bound_function_try_to_lazy_instantiate_property (object_p, property_name_p);
    #####: 1594:        break;
        -: 1595:      }
    #####: 1596:      default:
        -: 1597:      {
    #####: 1598:        break;
        -: 1599:      }
        -: 1600:    }
      102: 1601:  }
        -: 1602:
      107: 1603:  jmem_cpointer_t setter_cp = JMEM_CP_NULL;
        -: 1604:
      107: 1605:  if (property_p != NULL)
        -: 1606:  {
      102: 1607:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -: 1608:
      102: 1609:    if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -: 1610:    {
      102: 1611:      if (ecma_is_property_writable (*property_p))
        -: 1612:      {
        -: 1613:#if JERRY_ESNEXT
      102: 1614:        if (ecma_make_object_value (object_p) != receiver)
        -: 1615:        {
    #####: 1616:          return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);
        -: 1617:        }
        -: 1618:#endif /* JERRY_ESNEXT */
        -: 1619:
        -: 1620:        /* There is no need for special casing arrays here because changing the
        -: 1621:         * value of an existing property never changes the length of an array. */
      204: 1622:        ecma_named_data_property_assign_value (object_p,
      102: 1623:                                               ECMA_PROPERTY_VALUE_PTR (property_p),
        -: 1624:                                               value);
      102: 1625:        return ECMA_VALUE_TRUE;
        -: 1626:      }
        -: 1627:    }
        -: 1628:    else
        -: 1629:    {
        -: 1630:      ecma_getter_setter_pointers_t *get_set_pair_p;
    #####: 1631:      get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (property_p));
    #####: 1632:      setter_cp = get_set_pair_p->setter_cp;
        -: 1633:    }
        -: 1634:  }
        -: 1635:  else
        -: 1636:  {
        5: 1637:    bool create_new_property = true;
        -: 1638:
        -: 1639:    jmem_cpointer_t obj_cp;
        5: 1640:    ECMA_SET_NON_NULL_POINTER (obj_cp, object_p);
        5: 1641:    ecma_object_t *proto_p = object_p;
        -: 1642:
        -: 1643:    while (true)
        5: 1644:    {
       10: 1645:      obj_cp = ecma_op_ordinary_object_get_prototype_of (proto_p);
        -: 1646:
       10: 1647:      if (obj_cp == JMEM_CP_NULL)
        -: 1648:      {
        5: 1649:        break;
        -: 1650:      }
        -: 1651:
        5: 1652:      ecma_property_ref_t property_ref = { NULL };
        5: 1653:      proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_cp);
        -: 1654:
        -: 1655:#if JERRY_BUILTIN_PROXY
        5: 1656:      if (ECMA_OBJECT_IS_PROXY (proto_p))
        -: 1657:      {
    #####: 1658:        return ecma_op_object_put_with_receiver (proto_p,
        -: 1659:                                                 property_name_p,
        -: 1660:                                                 value,
        -: 1661:                                                 receiver,
        -: 1662:                                                 is_throw);
        -: 1663:      }
        -: 1664:#endif /* JERRY_BUILTIN_PROXY */
        -: 1665:
        5: 1666:      ecma_property_t inherited_property = ecma_op_object_get_own_property (proto_p,
        -: 1667:                                                                            property_name_p,
        -: 1668:                                                                            &property_ref,
        -: 1669:                                                                            ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 1670:
        5: 1671:      if (inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND
    #####: 1672:          && inherited_property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)
        -: 1673:      {
    #####: 1674:        JERRY_ASSERT (ECMA_PROPERTY_IS_NAMED_PROPERTY (inherited_property));
        -: 1675:
    #####: 1676:        if (!(inherited_property & ECMA_PROPERTY_FLAG_DATA))
        -: 1677:        {
    #####: 1678:          setter_cp = ecma_get_named_accessor_property (property_ref.value_p)->setter_cp;
    #####: 1679:          create_new_property = false;
    #####: 1680:          break;
        -: 1681:        }
        -: 1682:
    #####: 1683:        create_new_property = ecma_is_property_writable (inherited_property);
    #####: 1684:        break;
        -: 1685:      }
        -: 1686:    }
        -: 1687:
        -: 1688:#if JERRY_BUILTIN_PROXY
        5: 1689:    if (create_new_property
        5: 1690:        && ecma_is_value_object (receiver)
        5: 1691:        && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (receiver)))
        -: 1692:    {
    #####: 1693:      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);
        -: 1694:    }
        -: 1695:#endif /* JERRY_BUILTIN_PROXY */
        -: 1696:
        5: 1697:    if (create_new_property
        5: 1698:        && ecma_op_ordinary_object_is_extensible (object_p))
        -: 1699:    {
        5: 1700:      const ecma_object_base_type_t obj_base_type = ecma_get_object_base_type (object_p);
        -: 1701:
        5: 1702:      if (obj_base_type == ECMA_OBJECT_BASE_TYPE_CLASS)
        -: 1703:      {
    #####: 1704:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1705:
    #####: 1706:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_ARGUMENTS
    #####: 1707:            && ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -: 1708:        {
    #####: 1709:          const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
    #####: 1710:          return ecma_builtin_helper_def_prop (object_p, property_name_p, value, flags);
        -: 1711:        }
        -: 1712:      }
        -: 1713:
        5: 1714:      uint32_t index = ecma_string_get_array_index (property_name_p);
        -: 1715:
        5: 1716:      if (obj_base_type == ECMA_OBJECT_BASE_TYPE_ARRAY
    #####: 1717:          && index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 1718:      {
    #####: 1719:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1720:
    #####: 1721:        if (index < UINT32_MAX
    #####: 1722:            && index >= ext_object_p->u.array.length)
        -: 1723:        {
    #####: 1724:          if (!ecma_is_property_writable ((ecma_property_t) ext_object_p->u.array.length_prop_and_hole_count))
        -: 1725:          {
    #####: 1726:            return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1727:          }
        -: 1728:
    #####: 1729:          ext_object_p->u.array.length = index + 1;
        -: 1730:        }
        -: 1731:      }
        -: 1732:
        -: 1733:#if JERRY_ESNEXT
        5: 1734:      return ecma_op_object_put_apply_receiver (receiver, property_name_p, value, is_throw);
        -: 1735:#endif /* JERRY_ESNEXT */
        -: 1736:
        -: 1737:      ecma_property_value_t *new_prop_value_p;
    #####: 1738:      new_prop_value_p = ecma_create_named_data_property (object_p,
        -: 1739:                                                          property_name_p,
        -: 1740:                                                          ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 1741:                                                          NULL);
        -: 1742:
        -: 1743:      JERRY_ASSERT (ecma_is_value_undefined (new_prop_value_p->value));
    #####: 1744:      new_prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####: 1745:      return ECMA_VALUE_TRUE;
        -: 1746:    }
        -: 1747:  }
        -: 1748:
    #####: 1749:  if (setter_cp == JMEM_CP_NULL)
        -: 1750:  {
    #####: 1751:    return ecma_raise_readonly_assignment (property_name_p, is_throw);
        -: 1752:  }
        -: 1753:
    #####: 1754:  ecma_value_t ret_value = ecma_op_function_call (ECMA_GET_NON_NULL_POINTER (ecma_object_t, setter_cp),
        -: 1755:                                                  receiver,
        -: 1756:                                                  &value,
        -: 1757:                                                  1);
        -: 1758:
    #####: 1759:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -: 1760:  {
    #####: 1761:    ecma_fast_free_value (ret_value);
    #####: 1762:    ret_value = ECMA_VALUE_TRUE;
        -: 1763:  }
        -: 1764:
    #####: 1765:  return ret_value;
        -: 1766:} /* ecma_op_object_put_with_receiver */
        -: 1767:
        -: 1768:/**
        -: 1769: * [[Delete]] ecma object's operation specialized for property index
        -: 1770: *
        -: 1771: * Note:
        -: 1772: *      This method falls back to the general ecma_op_object_delete
        -: 1773: *
        -: 1774: * @return true - if deleted successfully
        -: 1775: *         false - or type error otherwise (based in 'is_throw')
        -: 1776: */
        -: 1777:ecma_value_t
    #####: 1778:ecma_op_object_delete_by_index (ecma_object_t *obj_p, /**< the object */
        -: 1779:                                ecma_length_t index, /**< property index */
        -: 1780:                                bool is_throw) /**< flag that controls failure handling */
        -: 1781:{
    #####: 1782:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -: 1783:  {
    #####: 1784:    return ecma_op_object_delete (obj_p, ECMA_CREATE_DIRECT_UINT32_STRING (index), is_throw);;
        -: 1785:  }
        -: 1786:
    #####: 1787:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####: 1788:  ecma_value_t ret_value = ecma_op_object_delete (obj_p, index_str_p, is_throw);
    #####: 1789:  ecma_deref_ecma_string (index_str_p);
        -: 1790:
    #####: 1791:  return ret_value;
        -: 1792:} /* ecma_op_object_delete_by_index */
        -: 1793:
        -: 1794:/**
        -: 1795: * [[Delete]] ecma object's operation
        -: 1796: *
        -: 1797: * See also:
        -: 1798: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1799: *
        -: 1800: * Note:
        -: 1801: *      returned value must be freed with ecma_free_value
        -: 1802: *
        -: 1803: * @return true - if deleted successfully
        -: 1804: *         false - or type error otherwise (based in 'is_throw')
        -: 1805: */
        -: 1806:ecma_value_t
    #####: 1807:ecma_op_object_delete (ecma_object_t *obj_p, /**< the object */
        -: 1808:                       ecma_string_t *property_name_p, /**< property name */
        -: 1809:                       bool is_strict) /**< flag that controls failure handling */
        -: 1810:{
    #####: 1811:  JERRY_ASSERT (obj_p != NULL
        -: 1812:                && !ecma_is_lexical_environment (obj_p));
    #####: 1813:  JERRY_ASSERT (property_name_p != NULL);
        -: 1814:
        -: 1815:#if JERRY_BUILTIN_PROXY
    #####: 1816:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 1817:  {
    #####: 1818:    return ecma_proxy_object_delete_property (obj_p, property_name_p, is_strict);
        -: 1819:  }
        -: 1820:#endif /* JERRY_BUILTIN_PROXY */
        -: 1821:
    #####: 1822:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 1823:
    #####: 1824:  return ecma_op_general_object_delete (obj_p,
        -: 1825:                                        property_name_p,
        -: 1826:                                        is_strict);
        -: 1827:} /* ecma_op_object_delete */
        -: 1828:
        -: 1829:/**
        -: 1830: * [[DefaultValue]] ecma object's operation
        -: 1831: *
        -: 1832: * See also:
        -: 1833: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1834: *
        -: 1835: * @return ecma value
        -: 1836: *         Returned value must be freed with ecma_free_value
        -: 1837: */
        -: 1838:ecma_value_t
        1: 1839:ecma_op_object_default_value (ecma_object_t *obj_p, /**< the object */
        -: 1840:                              ecma_preferred_type_hint_t hint) /**< hint on preferred result type */
        -: 1841:{
        1: 1842:  JERRY_ASSERT (obj_p != NULL
        -: 1843:                && !ecma_is_lexical_environment (obj_p));
        -: 1844:
        1: 1845:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 1846:
        -: 1847:  /*
        -: 1848:   * typedef ecma_property_t * (*default_value_ptr_t) (ecma_object_t *, ecma_string_t *);
        -: 1849:   * static const default_value_ptr_t default_value [ECMA_OBJECT_TYPE__COUNT] =
        -: 1850:   * {
        -: 1851:   *   [ECMA_OBJECT_TYPE_GENERAL]           = &ecma_op_general_object_default_value,
        -: 1852:   *   [ECMA_OBJECT_TYPE_CLASS]             = &ecma_op_general_object_default_value,
        -: 1853:   *   [ECMA_OBJECT_TYPE_FUNCTION]          = &ecma_op_general_object_default_value,
        -: 1854:   *   [ECMA_OBJECT_TYPE_NATIVE_FUNCTION]   = &ecma_op_general_object_default_value,
        -: 1855:   *   [ECMA_OBJECT_TYPE_ARRAY]             = &ecma_op_general_object_default_value,
        -: 1856:   *   [ECMA_OBJECT_TYPE_BOUND_FUNCTION]    = &ecma_op_general_object_default_value,
        -: 1857:   *   [ECMA_OBJECT_TYPE_PSEUDO_ARRAY]      = &ecma_op_general_object_default_value
        -: 1858:   * };
        -: 1859:   *
        -: 1860:   * return default_value[type] (obj_p, property_name_p);
        -: 1861:   */
        -: 1862:
        1: 1863:  return ecma_op_general_object_default_value (obj_p, hint);
        -: 1864:} /* ecma_op_object_default_value */
        -: 1865:
        -: 1866:/**
        -: 1867: * [[DefineOwnProperty]] ecma object's operation
        -: 1868: *
        -: 1869: * See also:
        -: 1870: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -: 1871: *
        -: 1872: * @return ecma value
        -: 1873: *         Returned value must be freed with ecma_free_value
        -: 1874: */
        -: 1875:ecma_value_t
        3: 1876:ecma_op_object_define_own_property (ecma_object_t *obj_p, /**< the object */
        -: 1877:                                    ecma_string_t *property_name_p, /**< property name */
        -: 1878:                                    const ecma_property_descriptor_t *property_desc_p) /**< property
        -: 1879:                                                                                        *   descriptor */
        -: 1880:{
        3: 1881:  JERRY_ASSERT (obj_p != NULL
        -: 1882:                && !ecma_is_lexical_environment (obj_p));
        3: 1883:  JERRY_ASSERT (property_name_p != NULL);
        -: 1884:
        3: 1885:  const ecma_object_type_t type = ecma_get_object_type (obj_p);
        -: 1886:
        3: 1887:  switch (type)
        -: 1888:  {
    #####: 1889:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1890:    {
    #####: 1891:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 1892:
    #####: 1893:      switch (ext_object_p->u.cls.type)
        -: 1894:      {
    #####: 1895:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 1896:        {
    #####: 1897:          return ecma_op_arguments_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1898:        }
        -: 1899:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1900:        /* ES2015 9.4.5.1 */
    #####: 1901:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 1902:        {
    #####: 1903:          return ecma_op_typedarray_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1904:        }
        -: 1905:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1906:      }
    #####: 1907:      break;
        -: 1908:    }
    #####: 1909:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1910:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1911:    {
    #####: 1912:      return ecma_op_array_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1913:    }
        -: 1914:#if JERRY_BUILTIN_PROXY
    #####: 1915:    case ECMA_OBJECT_TYPE_PROXY:
        -: 1916:    {
    #####: 1917:      return ecma_proxy_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1918:    }
        -: 1919:#endif /* JERRY_BUILTIN_PROXY */
        3: 1920:    default:
        -: 1921:    {
        3: 1922:      break;
        -: 1923:    }
        -: 1924:  }
        -: 1925:
        3: 1926:  return ecma_op_general_object_define_own_property (obj_p, property_name_p, property_desc_p);
        -: 1927:} /* ecma_op_object_define_own_property */
        -: 1928:
        -: 1929:/**
        -: 1930: * Get property descriptor from specified property
        -: 1931: *
        -: 1932: * depending on the property type the following fields are set:
        -: 1933: *   - for named data properties: { [Value], [Writable], [Enumerable], [Configurable] };
        -: 1934: *   - for named accessor properties: { [Get] - if defined,
        -: 1935: *                                      [Set] - if defined,
        -: 1936: *                                      [Enumerable], [Configurable]
        -: 1937: *                                    }.
        -: 1938: *
        -: 1939: * The output property descriptor will always be initialized to an empty descriptor.
        -: 1940: *
        -: 1941: * @return ECMA_VALUE_ERROR - if the Proxy.[[GetOwnProperty]] operation raises error
        -: 1942: *         ECMA_VALUE_{TRUE, FALSE} - if property found or not
        -: 1943: */
        -: 1944:ecma_value_t
        5: 1945:ecma_op_object_get_own_property_descriptor (ecma_object_t *object_p, /**< the object */
        -: 1946:                                            ecma_string_t *property_name_p, /**< property name */
        -: 1947:                                            ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 1948:{
        5: 1949:  *prop_desc_p = ecma_make_empty_property_descriptor ();
        -: 1950:
        -: 1951:#if JERRY_BUILTIN_PROXY
        5: 1952:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 1953:  {
    #####: 1954:    return ecma_proxy_object_get_own_property_descriptor (object_p, property_name_p, prop_desc_p);
        -: 1955:  }
        -: 1956:#endif /* JERRY_BUILTIN_PROXY */
        -: 1957:
        5: 1958:  ecma_property_ref_t property_ref;
        5: 1959:  property_ref.virtual_value = ECMA_VALUE_EMPTY;
        5: 1960:  ecma_property_t property = ecma_op_object_get_own_property (object_p,
        -: 1961:                                                              property_name_p,
        -: 1962:                                                              &property_ref,
        -: 1963:                                                              ECMA_PROPERTY_GET_VALUE);
        -: 1964:
        5: 1965:  if (ECMA_IS_VALUE_ERROR (property_ref.virtual_value))
        -: 1966:  {
    #####: 1967:    return property_ref.virtual_value;
        -: 1968:  }
        -: 1969:
        5: 1970:  if (property == ECMA_PROPERTY_TYPE_NOT_FOUND || property == ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP)
        -: 1971:  {
        5: 1972:    return ECMA_VALUE_FALSE;
        -: 1973:  }
        -: 1974:
    #####: 1975:  uint32_t flags = ecma_is_property_enumerable (property) ? JERRY_PROP_IS_ENUMERABLE : JERRY_PROP_NO_OPTS;
    #####: 1976:  flags |= ecma_is_property_configurable (property) ? JERRY_PROP_IS_CONFIGURABLE: JERRY_PROP_NO_OPTS;
        -: 1977:
    #####: 1978:  prop_desc_p->flags = (uint16_t) (JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE_DEFINED | flags);
        -: 1979:
    #####: 1980:  if (property & ECMA_PROPERTY_FLAG_DATA)
        -: 1981:  {
    #####: 1982:    if (!ECMA_PROPERTY_IS_VIRTUAL (property))
        -: 1983:    {
    #####: 1984:      prop_desc_p->value = ecma_copy_value (property_ref.value_p->value);
        -: 1985:    }
        -: 1986:    else
        -: 1987:    {
        -: 1988:#if JERRY_MODULE_SYSTEM
    #####: 1989:      if (JERRY_UNLIKELY (property_ref.virtual_value == ECMA_VALUE_UNINITIALIZED))
        -: 1990:      {
    #####: 1991:        return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -: 1992:      }
        -: 1993:#endif /* JERRY_MODULE_SYSTEM */
    #####: 1994:      prop_desc_p->value = property_ref.virtual_value;
        -: 1995:    }
        -: 1996:
    #####: 1997:    prop_desc_p->flags |= (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED);
    #####: 1998:    prop_desc_p->flags = (uint16_t) (prop_desc_p->flags | (ecma_is_property_writable (property) ? JERRY_PROP_IS_WRITABLE
        -: 1999:                                                                                                : JERRY_PROP_NO_OPTS));
        -: 2000:  }
        -: 2001:  else
        -: 2002:  {
    #####: 2003:    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (property_ref.value_p);
    #####: 2004:    prop_desc_p->flags |= (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED);
        -: 2005:
    #####: 2006:    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -: 2007:    {
    #####: 2008:      prop_desc_p->get_p = NULL;
        -: 2009:    }
        -: 2010:    else
        -: 2011:    {
    #####: 2012:      prop_desc_p->get_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
    #####: 2013:      ecma_ref_object (prop_desc_p->get_p);
        -: 2014:    }
        -: 2015:
    #####: 2016:    if (get_set_pair_p->setter_cp == JMEM_CP_NULL)
        -: 2017:    {
    #####: 2018:      prop_desc_p->set_p = NULL;
        -: 2019:    }
        -: 2020:    else
        -: 2021:    {
    #####: 2022:      prop_desc_p->set_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);
    #####: 2023:      ecma_ref_object (prop_desc_p->set_p);
        -: 2024:    }
        -: 2025:  }
        -: 2026:
    #####: 2027:  return ECMA_VALUE_TRUE;
        -: 2028:} /* ecma_op_object_get_own_property_descriptor */
        -: 2029:
        -: 2030:#if JERRY_BUILTIN_PROXY
        -: 2031:/**
        -: 2032: * Get property descriptor from a target value for a specified property.
        -: 2033: *
        -: 2034: * For more details see ecma_op_object_get_own_property_descriptor
        -: 2035: *
        -: 2036: * @return ECMA_VALUE_ERROR - if the Proxy.[[GetOwnProperty]] operation raises error
        -: 2037: *         ECMA_VALUE_{TRUE, FALSE} - if property found or not
        -: 2038: */
        -: 2039:ecma_value_t
    #####: 2040:ecma_op_get_own_property_descriptor (ecma_value_t target, /**< target value */
        -: 2041:                                     ecma_string_t *property_name_p, /**< property name */
        -: 2042:                                     ecma_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 2043:{
    #####: 2044:  if (!ecma_is_value_object (target))
        -: 2045:  {
    #####: 2046:    return ECMA_VALUE_FALSE;
        -: 2047:  }
        -: 2048:
    #####: 2049:  return ecma_op_object_get_own_property_descriptor (ecma_get_object_from_value (target), property_name_p, prop_desc_p);
        -: 2050:} /* ecma_op_get_own_property_descriptor */
        -: 2051:#endif /* JERRY_BUILTIN_PROXY */
        -: 2052:
        -: 2053:/**
        -: 2054: * [[HasInstance]] ecma object's operation
        -: 2055: *
        -: 2056: * See also:
        -: 2057: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 9
        -: 2058: *
        -: 2059: * @return ecma value containing a boolean value or an error
        -: 2060: *         Returned value must be freed with ecma_free_value
        -: 2061: */
        -: 2062:ecma_value_t
    #####: 2063:ecma_op_object_has_instance (ecma_object_t *obj_p, /**< the object */
        -: 2064:                             ecma_value_t value) /**< argument 'V' */
        -: 2065:{
    #####: 2066:  JERRY_ASSERT (obj_p != NULL
        -: 2067:                && !ecma_is_lexical_environment (obj_p));
        -: 2068:
    #####: 2069:  JERRY_ASSERT_OBJECT_TYPE_IS_VALID (ecma_get_object_type (obj_p));
        -: 2070:
    #####: 2071:  if (ecma_op_object_is_callable (obj_p))
        -: 2072:  {
    #####: 2073:    return ecma_op_function_has_instance (obj_p, value);
        -: 2074:  }
        -: 2075:
    #####: 2076:  return ecma_raise_type_error (ECMA_ERR_MSG ("Expected a function object"));
        -: 2077:} /* ecma_op_object_has_instance */
        -: 2078:
        -: 2079:/**
        -: 2080: * General [[GetPrototypeOf]] abstract operation
        -: 2081: *
        -: 2082: * Note: returned valid object must be freed.
        -: 2083: *
        -: 2084: * @return ecma_object_t * - prototype of the input object.
        -: 2085: *         ECMA_OBJECT_POINTER_ERROR - error reported during Proxy resolve.
        -: 2086: *         NULL - the input object does not have a prototype.
        -: 2087: */
        -: 2088:ecma_object_t *
    #####: 2089:ecma_op_object_get_prototype_of (ecma_object_t *obj_p) /**< input object */
        -: 2090:{
    #####: 2091:  JERRY_ASSERT (obj_p != NULL);
        -: 2092:
        -: 2093:#if JERRY_BUILTIN_PROXY
    #####: 2094:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 2095:  {
    #####: 2096:    ecma_value_t proto = ecma_proxy_object_get_prototype_of (obj_p);
        -: 2097:
    #####: 2098:    if (ECMA_IS_VALUE_ERROR (proto))
        -: 2099:    {
    #####: 2100:      return ECMA_OBJECT_POINTER_ERROR;
        -: 2101:    }
    #####: 2102:    if (ecma_is_value_null (proto))
        -: 2103:    {
    #####: 2104:      return NULL;
        -: 2105:    }
        -: 2106:
    #####: 2107:    JERRY_ASSERT (ecma_is_value_object (proto));
        -: 2108:
    #####: 2109:    return ecma_get_object_from_value (proto);
        -: 2110:  }
        -: 2111:  else
        -: 2112:#endif /* JERRY_BUILTIN_PROXY */
        -: 2113:  {
    #####: 2114:    jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (obj_p);
        -: 2115:
    #####: 2116:    if (proto_cp == JMEM_CP_NULL)
        -: 2117:    {
    #####: 2118:      return NULL;
        -: 2119:    }
        -: 2120:
    #####: 2121:    ecma_object_t *proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
    #####: 2122:    ecma_ref_object (proto_p);
        -: 2123:
    #####: 2124:    return proto_p;
        -: 2125:  }
        -: 2126:} /* ecma_op_object_get_prototype_of */
        -: 2127:
        -: 2128:/**
        -: 2129: * Object's isPrototypeOf operation
        -: 2130: *
        -: 2131: * See also:
        -: 2132: *          ECMA-262 v5, 15.2.4.6; 3
        -: 2133: *
        -: 2134: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2135: *         ECMA_VALUE_TRUE - if the target object is prototype of the base object
        -: 2136: *         ECMA_VALUE_FALSE - if the target object is not prototype of the base object
        -: 2137: */
        -: 2138:ecma_value_t
    #####: 2139:ecma_op_object_is_prototype_of (ecma_object_t *base_p, /**< base object */
        -: 2140:                                ecma_object_t *target_p) /**< target object */
        -: 2141:{
    #####: 2142:  ecma_ref_object (target_p);
        -: 2143:
        -: 2144:  do
    #####: 2145:  {
    #####: 2146:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (target_p);
    #####: 2147:    ecma_deref_object (target_p);
        -: 2148:
    #####: 2149:    if (proto_p == NULL)
        -: 2150:    {
    #####: 2151:      return ECMA_VALUE_FALSE;
        -: 2152:    }
    #####: 2153:    else if (proto_p == ECMA_OBJECT_POINTER_ERROR)
        -: 2154:    {
    #####: 2155:      return ECMA_VALUE_ERROR;
        -: 2156:    }
    #####: 2157:    else if (proto_p == base_p)
        -: 2158:    {
    #####: 2159:      ecma_deref_object (proto_p);
    #####: 2160:      return ECMA_VALUE_TRUE;
        -: 2161:    }
        -: 2162:
        -: 2163:    /* Advance up on prototype chain. */
    #####: 2164:    target_p = proto_p;
        -: 2165:  }
        -: 2166:  while (true);
        -: 2167:} /* ecma_op_object_is_prototype_of */
        -: 2168:
        -: 2169:/**
        -: 2170: * Object's EnumerableOwnPropertyNames operation
        -: 2171: *
        -: 2172: * See also:
        -: 2173: *          ECMA-262 v11, 7.3.23
        -: 2174: *
        -: 2175: * @return NULL - if operation fails
        -: 2176: *         collection of property names / values / name-value pairs - otherwise
        -: 2177: */
        -: 2178:ecma_collection_t *
    #####: 2179:ecma_op_object_get_enumerable_property_names (ecma_object_t *obj_p, /**< routine's first argument */
        -: 2180:                                              ecma_enumerable_property_names_options_t option) /**< listing option */
        -: 2181:{
        -: 2182:  /* 2. */
    #####: 2183:  ecma_collection_t *prop_names_p = ecma_op_object_own_property_keys (obj_p, JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS);
        -: 2184:
        -: 2185:#if JERRY_BUILTIN_PROXY
    #####: 2186:  if (JERRY_UNLIKELY (prop_names_p == NULL))
        -: 2187:  {
    #####: 2188:    return prop_names_p;
        -: 2189:  }
        -: 2190:#endif /* JERRY_BUILTIN_PROXY */
        -: 2191:
    #####: 2192:  ecma_value_t *names_buffer_p = prop_names_p->buffer_p;
        -: 2193:  /* 3. */
    #####: 2194:  ecma_collection_t *properties_p = ecma_new_collection ();
        -: 2195:
        -: 2196:  /* 4. */
    #####: 2197:  for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 2198:  {
        -: 2199:    /* 4.a */
    #####: 2200:    if (ecma_is_value_string (names_buffer_p[i]))
        -: 2201:    {
    #####: 2202:      ecma_string_t *key_p = ecma_get_string_from_value (names_buffer_p[i]);
        -: 2203:
        -: 2204:      /* 4.a.i */
    #####: 2205:      ecma_property_descriptor_t prop_desc;
    #####: 2206:      ecma_value_t status = ecma_op_object_get_own_property_descriptor (obj_p, key_p, &prop_desc);
        -: 2207:
    #####: 2208:      if (ECMA_IS_VALUE_ERROR (status))
        -: 2209:      {
    #####: 2210:        ecma_collection_free (prop_names_p);
    #####: 2211:        ecma_collection_free (properties_p);
        -: 2212:
    #####: 2213:        return NULL;
        -: 2214:      }
        -: 2215:
    #####: 2216:      const bool is_enumerable = (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE) != 0;
    #####: 2217:      ecma_free_property_descriptor (&prop_desc);
        -: 2218:      /* 4.a.ii */
    #####: 2219:      if (is_enumerable)
        -: 2220:      {
        -: 2221:        /* 4.a.ii.1 */
    #####: 2222:        if (option == ECMA_ENUMERABLE_PROPERTY_KEYS)
        -: 2223:        {
    #####: 2224:          ecma_collection_push_back (properties_p, ecma_copy_value (names_buffer_p[i]));
        -: 2225:        }
        -: 2226:        else
        -: 2227:        {
        -: 2228:          /* 4.a.ii.2.a */
    #####: 2229:          ecma_value_t value = ecma_op_object_get (obj_p, key_p);
        -: 2230:
    #####: 2231:          if (ECMA_IS_VALUE_ERROR (value))
        -: 2232:          {
    #####: 2233:            ecma_collection_free (prop_names_p);
    #####: 2234:            ecma_collection_free (properties_p);
        -: 2235:
    #####: 2236:            return NULL;
        -: 2237:          }
        -: 2238:
        -: 2239:          /* 4.a.ii.2.b */
    #####: 2240:          if (option == ECMA_ENUMERABLE_PROPERTY_VALUES)
        -: 2241:          {
    #####: 2242:            ecma_collection_push_back (properties_p, value);
        -: 2243:          }
        -: 2244:          else
        -: 2245:          {
        -: 2246:            /* 4.a.ii.2.c.i */
    #####: 2247:            JERRY_ASSERT (option == ECMA_ENUMERABLE_PROPERTY_ENTRIES);
        -: 2248:
        -: 2249:            /* 4.a.ii.2.c.ii */
    #####: 2250:            ecma_object_t *entry_p = ecma_op_new_array_object (2);
        -: 2251:
    #####: 2252:            ecma_builtin_helper_def_prop_by_index (entry_p,
        -: 2253:                                                   0,
    #####: 2254:                                                   names_buffer_p[i],
        -: 2255:                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2256:            ecma_builtin_helper_def_prop_by_index (entry_p,
        -: 2257:                                                   1,
        -: 2258:                                                   value,
        -: 2259:                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2260:            ecma_free_value (value);
        -: 2261:
        -: 2262:            /* 4.a.ii.2.c.iii */
    #####: 2263:            ecma_collection_push_back (properties_p, ecma_make_object_value (entry_p));
        -: 2264:          }
        -: 2265:        }
        -: 2266:      }
        -: 2267:    }
        -: 2268:  }
        -: 2269:
    #####: 2270:  ecma_collection_free (prop_names_p);
        -: 2271:
    #####: 2272:  return properties_p;
        -: 2273:} /* ecma_op_object_get_enumerable_property_names */
        -: 2274:
        -: 2275:/**
        -: 2276: * Helper method for getting lazy instantiated properties for [[OwnPropertyKeys]]
        -: 2277: */
        -: 2278:static void
    #####: 2279:ecma_object_list_lazy_property_names (ecma_object_t *obj_p, /**< object */
        -: 2280:                                      ecma_collection_t *prop_names_p, /**< prop name collection */
        -: 2281:                                      ecma_property_counter_t *prop_counter_p, /**< property counters */
        -: 2282:                                      jerry_property_filter_t filter) /**< property name filter options */
        -: 2283:{
    #####: 2284:  switch (ecma_get_object_type (obj_p))
        -: 2285:  {
    #####: 2286:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 2287:    {
    #####: 2288:      if (ecma_builtin_function_is_routine (obj_p))
        -: 2289:      {
    #####: 2290:        ecma_builtin_routine_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2291:        break;
        -: 2292:      }
        -: 2293:      /* FALLTHRU */
        -: 2294:    }
        -: 2295:    case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 2296:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 2297:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 2298:    {
    #####: 2299:      ecma_builtin_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2300:      break;
        -: 2301:    }
    #####: 2302:    case ECMA_OBJECT_TYPE_CLASS:
        -: 2303:    {
    #####: 2304:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 2305:
    #####: 2306:      switch (ext_object_p->u.cls.type)
        -: 2307:      {
    #####: 2308:        case ECMA_OBJECT_CLASS_STRING:
        -: 2309:        {
    #####: 2310:          ecma_op_string_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2311:          break;
        -: 2312:        }
    #####: 2313:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 2314:        {
    #####: 2315:          ecma_op_arguments_object_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2316:          break;
        -: 2317:        }
        -: 2318:#if JERRY_BUILTIN_TYPEDARRAY
        -: 2319:        /* ES2015 9.4.5.1 */
    #####: 2320:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 2321:        {
    #####: 2322:          ecma_op_typedarray_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2323:          break;
        -: 2324:        }
        -: 2325:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 2326:      }
    #####: 2327:      break;
        -: 2328:    }
    #####: 2329:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 2330:    {
    #####: 2331:      ecma_op_function_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2332:      break;
        -: 2333:    }
    #####: 2334:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 2335:    {
    #####: 2336:      ecma_op_external_function_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2337:      break;
        -: 2338:    }
    #####: 2339:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 2340:    {
    #####: 2341:      ecma_op_bound_function_list_lazy_property_names (obj_p, prop_names_p, prop_counter_p, filter);
    #####: 2342:      break;
        -: 2343:    }
    #####: 2344:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 2345:    {
    #####: 2346:      if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS))
        -: 2347:      {
    #####: 2348:        ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
    #####: 2349:        prop_counter_p->string_named_props++;
        -: 2350:      }
    #####: 2351:      break;
        -: 2352:    }
    #####: 2353:    default:
        -: 2354:    {
    #####: 2355:      JERRY_ASSERT (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_GENERAL
        -: 2356:                    || ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION);
    #####: 2357:      break;
        -: 2358:    }
        -: 2359:  }
    #####: 2360:} /* ecma_object_list_lazy_property_names */
        -: 2361:
        -: 2362:/**
        -: 2363: * Helper routine for heapsort algorithm.
        -: 2364: */
        -: 2365:static void
    #####: 2366:ecma_op_object_heap_sort_shift_down (ecma_value_t *buffer_p, /**< array of items */
        -: 2367:                                     uint32_t item_count, /**< number of items */
        -: 2368:                                     uint32_t item_index) /**< index of updated item */
        -: 2369:{
        -: 2370:  while (true)
    #####: 2371:  {
    #####: 2372:    uint32_t highest_index = item_index;
    #####: 2373:    uint32_t current_index = (item_index << 1) + 1;
        -: 2374:
    #####: 2375:    if (current_index >= item_count)
        -: 2376:    {
    #####: 2377:      return;
        -: 2378:    }
        -: 2379:
    #####: 2380:    uint32_t value = ecma_string_get_array_index (ecma_get_string_from_value (buffer_p[highest_index]));
    #####: 2381:    uint32_t left_value = ecma_string_get_array_index (ecma_get_string_from_value (buffer_p[current_index]));
        -: 2382:
    #####: 2383:    if (value < left_value)
        -: 2384:    {
    #####: 2385:      highest_index = current_index;
    #####: 2386:      value = left_value;
        -: 2387:    }
        -: 2388:
    #####: 2389:    current_index++;
        -: 2390:
    #####: 2391:    if (current_index < item_count
    #####: 2392:        && value < ecma_string_get_array_index (ecma_get_string_from_value (buffer_p[current_index])))
        -: 2393:    {
    #####: 2394:      highest_index = current_index;
        -: 2395:    }
        -: 2396:
    #####: 2397:    if (highest_index == item_index)
        -: 2398:    {
    #####: 2399:      return;
        -: 2400:    }
        -: 2401:
    #####: 2402:    ecma_value_t tmp = buffer_p[highest_index];
    #####: 2403:    buffer_p[highest_index] = buffer_p[item_index];
    #####: 2404:    buffer_p[item_index] = tmp;
        -: 2405:
    #####: 2406:    item_index = highest_index;
        -: 2407:  }
        -: 2408:} /* ecma_op_object_heap_sort_shift_down */
        -: 2409:
        -: 2410:/**
        -: 2411: * Object's [[OwnPropertyKeys]] internal method
        -: 2412: *
        -: 2413: * Order of names in the collection:
        -: 2414: *  - integer indices in ascending order
        -: 2415: *  - other indices in creation order (for built-ins: the order of the properties are listed in specification).
        -: 2416: *
        -: 2417: * Note:
        -: 2418: *      Implementation of the routine assumes that new properties are appended to beginning of corresponding object's
        -: 2419: *      property list, and the list is not reordered (in other words, properties are stored in order that is reversed
        -: 2420: *      to the properties' addition order).
        -: 2421: *
        -: 2422: * @return NULL - if the Proxy.[[OwnPropertyKeys]] operation raises error
        -: 2423: *         collection of property names - otherwise
        -: 2424: */
        -: 2425:ecma_collection_t *
    #####: 2426:ecma_op_object_own_property_keys (ecma_object_t *obj_p, /**< object */
        -: 2427:                                  jerry_property_filter_t filter) /**< name filters */
        -: 2428:{
        -: 2429:#if JERRY_BUILTIN_PROXY
    #####: 2430:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 2431:  {
    #####: 2432:    return ecma_proxy_object_own_property_keys (obj_p);
        -: 2433:  }
        -: 2434:#endif /* JERRY_BUILTIN_PROXY */
        -: 2435:
    #####: 2436:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2437:  {
    #####: 2438:    return ecma_fast_array_object_own_property_keys (obj_p, filter);
        -: 2439:  }
        -: 2440:
    #####: 2441:  ecma_collection_t *prop_names_p = ecma_new_collection ();
    #####: 2442:  ecma_property_counter_t prop_counter = {0, 0, 0};
        -: 2443:
    #####: 2444:  ecma_object_list_lazy_property_names (obj_p, prop_names_p, &prop_counter, filter);
        -: 2445:
    #####: 2446:  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -: 2447:
        -: 2448:#if JERRY_PROPERTY_HASHMAP
    #####: 2449:  if (prop_iter_cp != JMEM_CP_NULL)
        -: 2450:  {
    #####: 2451:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -: 2452:
    #####: 2453:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 2454:    {
    #####: 2455:      prop_iter_cp = prop_iter_p->next_property_cp;
        -: 2456:    }
        -: 2457:  }
        -: 2458:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 2459:
    #####: 2460:  jmem_cpointer_t counter_prop_iter_cp = prop_iter_cp;
        -: 2461:
    #####: 2462:  uint32_t array_index_named_props = 0;
    #####: 2463:  uint32_t string_named_props = 0;
        -: 2464:#if JERRY_ESNEXT
    #####: 2465:  uint32_t symbol_named_props = 0;
        -: 2466:#endif /* JERRY_ESNEXT */
        -: 2467:
    #####: 2468:  while (counter_prop_iter_cp != JMEM_CP_NULL)
        -: 2469:  {
    #####: 2470:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, counter_prop_iter_cp);
    #####: 2471:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 2472:
    #####: 2473:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -: 2474:    {
    #####: 2475:      ecma_property_t *property_p = prop_iter_p->types + i;
        -: 2476:
    #####: 2477:      if (!ECMA_PROPERTY_IS_RAW (*property_p)
    #####: 2478:          || (*property_p & ECMA_PROPERTY_FLAG_BUILT_IN))
        -: 2479:      {
    #####: 2480:        continue;
        -: 2481:      }
        -: 2482:
    #####: 2483:      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 2484:
    #####: 2485:      if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC
    #####: 2486:          && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT
    #####: 2487:          && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)
        -: 2488:      {
    #####: 2489:        continue;
        -: 2490:      }
        -: 2491:
    #####: 2492:      ecma_string_t *name_p = ecma_string_from_property_name (*property_p,
    #####: 2493:                                                              prop_pair_p->names_cp[i]);
        -: 2494:
    #####: 2495:      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 2496:      {
    #####: 2497:        array_index_named_props++;
        -: 2498:      }
        -: 2499:#if JERRY_ESNEXT
    #####: 2500:      else if (ecma_prop_name_is_symbol (name_p))
        -: 2501:      {
    #####: 2502:        symbol_named_props++;
        -: 2503:      }
        -: 2504:#endif /* JERRY_ESNEXT */
        -: 2505:      else
        -: 2506:      {
    #####: 2507:        string_named_props++;
        -: 2508:      }
        -: 2509:
    #####: 2510:      ecma_deref_ecma_string (name_p);
        -: 2511:    }
        -: 2512:
    #####: 2513:    counter_prop_iter_cp = prop_iter_p->next_property_cp;
        -: 2514:  }
        -: 2515:
    #####: 2516:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES)
        -: 2517:  {
    #####: 2518:    JERRY_ASSERT (prop_counter.array_index_named_props == 0);
    #####: 2519:    array_index_named_props = 0;
        -: 2520:  }
        -: 2521:
    #####: 2522:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
        -: 2523:  {
    #####: 2524:    JERRY_ASSERT (prop_counter.string_named_props == 0);
    #####: 2525:    string_named_props = 0;
        -: 2526:  }
        -: 2527:
        -: 2528:#if JERRY_ESNEXT
    #####: 2529:  if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS)
        -: 2530:  {
    #####: 2531:    JERRY_ASSERT (prop_counter.symbol_named_props == 0);
    #####: 2532:    symbol_named_props = 0;
        -: 2533:  }
        -: 2534:
    #####: 2535:  uint32_t total = array_index_named_props + string_named_props + symbol_named_props;
        -: 2536:#else /* !JERRY_ESNEXT */
    #####: 2537:  uint32_t total = array_index_named_props + string_named_props;
        -: 2538:#endif /* JERRY_ESNEXT */
        -: 2539:
    #####: 2540:  if (total == 0)
        -: 2541:  {
    #####: 2542:    return prop_names_p;
        -: 2543:  }
        -: 2544:
    #####: 2545:  ecma_collection_reserve (prop_names_p, total);
    #####: 2546:  prop_names_p->item_count += total;
        -: 2547:
    #####: 2548:  ecma_value_t *buffer_p = prop_names_p->buffer_p;
    #####: 2549:  ecma_value_t *array_index_current_p = buffer_p + array_index_named_props + prop_counter.array_index_named_props;
    #####: 2550:  ecma_value_t *string_current_p = array_index_current_p + string_named_props + prop_counter.string_named_props;
        -: 2551:
        -: 2552:#if JERRY_ESNEXT
    #####: 2553:  ecma_value_t *symbol_current_p = string_current_p + symbol_named_props + prop_counter.symbol_named_props;
        -: 2554:
    #####: 2555:  if (prop_counter.symbol_named_props > 0
    #####: 2556:      && (array_index_named_props + string_named_props) > 0)
        -: 2557:  {
    #####: 2558:    memmove ((void *) string_current_p,
    #####: 2559:             (void *) (buffer_p + prop_counter.array_index_named_props + prop_counter.string_named_props),
    #####: 2560:             prop_counter.symbol_named_props * sizeof (ecma_value_t));
        -: 2561:  }
        -: 2562:#endif /* JERRY_ESNEXT */
        -: 2563:
    #####: 2564:  if (prop_counter.string_named_props > 0
    #####: 2565:      && array_index_named_props > 0)
        -: 2566:  {
    #####: 2567:    memmove ((void *) array_index_current_p,
    #####: 2568:             (void *) (buffer_p + prop_counter.array_index_named_props),
    #####: 2569:             prop_counter.string_named_props * sizeof (ecma_value_t));
        -: 2570:  }
        -: 2571:
    #####: 2572:  while (prop_iter_cp != JMEM_CP_NULL)
        -: 2573:  {
    #####: 2574:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####: 2575:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 2576:
    #####: 2577:    for (int i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -: 2578:    {
    #####: 2579:      ecma_property_t *property_p = prop_iter_p->types + i;
        -: 2580:
    #####: 2581:      if (!ECMA_PROPERTY_IS_RAW (*property_p)
    #####: 2582:          || (*property_p & ECMA_PROPERTY_FLAG_BUILT_IN))
        -: 2583:      {
    #####: 2584:        continue;
        -: 2585:      }
        -: 2586:
    #####: 2587:      ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 2588:
    #####: 2589:      if (ECMA_PROPERTY_GET_NAME_TYPE (*property_p) == ECMA_DIRECT_STRING_MAGIC
    #####: 2590:          && prop_pair_p->names_cp[i] >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT
    #####: 2591:          && prop_pair_p->names_cp[i] < LIT_MAGIC_STRING__COUNT)
        -: 2592:      {
    #####: 2593:        continue;
        -: 2594:      }
        -: 2595:
    #####: 2596:      ecma_string_t *name_p = ecma_string_from_property_name (*property_p,
    #####: 2597:                                                              prop_pair_p->names_cp[i]);
        -: 2598:
    #####: 2599:      if (ecma_string_get_array_index (name_p) != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 2600:      {
    #####: 2601:        if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES))
        -: 2602:        {
    #####: 2603:          *(--array_index_current_p) = ecma_make_string_value (name_p);
    #####: 2604:          continue;
        -: 2605:        }
        -: 2606:      }
        -: 2607:#if JERRY_ESNEXT
    #####: 2608:      else if (ecma_prop_name_is_symbol (name_p))
        -: 2609:      {
    #####: 2610:        if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS))
        -: 2611:        {
    #####: 2612:          *(--symbol_current_p) = ecma_make_symbol_value (name_p);
    #####: 2613:          continue;
        -: 2614:        }
        -: 2615:      }
        -: 2616:#endif /* JERRY_ESNEXT */
        -: 2617:      else
        -: 2618:      {
    #####: 2619:        if (!(filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS))
        -: 2620:        {
    #####: 2621:          *(--string_current_p) = ecma_make_string_value (name_p);
    #####: 2622:          continue;
        -: 2623:        }
        -: 2624:      }
        -: 2625:
    #####: 2626:      ecma_deref_ecma_string (name_p);
        -: 2627:    }
        -: 2628:
    #####: 2629:    prop_iter_cp = prop_iter_p->next_property_cp;
        -: 2630:  }
        -: 2631:
    #####: 2632:  if (array_index_named_props > 1
    #####: 2633:      || (array_index_named_props == 1 && prop_counter.array_index_named_props > 0))
        -: 2634:  {
    #####: 2635:    uint32_t prev_value = 0;
    #####: 2636:    ecma_value_t *array_index_p = buffer_p + prop_counter.array_index_named_props;
    #####: 2637:    ecma_value_t *array_index_end_p = array_index_p + array_index_named_props;
        -: 2638:
    #####: 2639:    if (prop_counter.array_index_named_props > 0)
        -: 2640:    {
    #####: 2641:      prev_value = ecma_string_get_array_index (ecma_get_string_from_value (array_index_p[-1]));
        -: 2642:    }
        -: 2643:
        -: 2644:    do
        -: 2645:    {
    #####: 2646:      uint32_t value = ecma_string_get_array_index (ecma_get_string_from_value (*array_index_p++));
        -: 2647:
    #####: 2648:      if (value < prev_value)
        -: 2649:      {
    #####: 2650:        uint32_t array_props = prop_counter.array_index_named_props + array_index_named_props;
    #####: 2651:        uint32_t i = (array_props >> 1) - 1;
        -: 2652:
        -: 2653:        do
        -: 2654:        {
    #####: 2655:          ecma_op_object_heap_sort_shift_down (buffer_p, array_props, i);
        -: 2656:        }
    #####: 2657:        while (i-- > 0);
        -: 2658:
    #####: 2659:        i = array_props - 1;
        -: 2660:
        -: 2661:        do
        -: 2662:        {
    #####: 2663:          ecma_value_t tmp = buffer_p[i];
    #####: 2664:          buffer_p[i] = buffer_p[0];
    #####: 2665:          buffer_p[0] = tmp;
        -: 2666:
    #####: 2667:          ecma_op_object_heap_sort_shift_down (buffer_p, i, 0);
        -: 2668:        }
    #####: 2669:        while (--i > 0);
        -: 2670:
    #####: 2671:        break;
        -: 2672:      }
        -: 2673:
    #####: 2674:      prev_value = value;
        -: 2675:    }
    #####: 2676:    while (array_index_p < array_index_end_p);
        -: 2677:  }
        -: 2678:
    #####: 2679:  return prop_names_p;
        -: 2680:} /* ecma_op_object_own_property_keys */
        -: 2681:
        -: 2682:/**
        -: 2683: * EnumerateObjectProperties abstract method
        -: 2684: *
        -: 2685: * See also:
        -: 2686: *          ECMA-262 v11, 13.7.5.15
        -: 2687: *
        -: 2688: * @return NULL - if the Proxy.[[OwnPropertyKeys]] operation raises error
        -: 2689: *         collection of enumerable property names - otherwise
        -: 2690: */
        -: 2691:ecma_collection_t *
    #####: 2692:ecma_op_object_enumerate (ecma_object_t *obj_p) /**< object */
        -: 2693:{
    #####: 2694:  ecma_collection_t *visited_names_p = ecma_new_collection ();
    #####: 2695:  ecma_collection_t *return_names_p = ecma_new_collection ();
        -: 2696:
    #####: 2697:  ecma_ref_object (obj_p);
        -: 2698:
        -: 2699:  while (true)
    #####: 2700:  {
    #####: 2701:    ecma_collection_t *keys = ecma_op_object_own_property_keys (obj_p, JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS);
        -: 2702:
        -: 2703:#if JERRY_ESNEXT
    #####: 2704:    if (JERRY_UNLIKELY (keys == NULL))
        -: 2705:    {
    #####: 2706:      ecma_collection_free (return_names_p);
    #####: 2707:      ecma_collection_free (visited_names_p);
    #####: 2708:      ecma_deref_object (obj_p);
    #####: 2709:      return keys;
        -: 2710:    }
        -: 2711:#endif /* JERRY_ESNEXT */
        -: 2712:
    #####: 2713:    for (uint32_t i = 0; i < keys->item_count; i++)
        -: 2714:    {
    #####: 2715:      ecma_value_t prop_name = keys->buffer_p[i];
    #####: 2716:      ecma_string_t *name_p = ecma_get_prop_name_from_value (prop_name);
        -: 2717:
        -: 2718:#if JERRY_ESNEXT
    #####: 2719:      if (ecma_prop_name_is_symbol (name_p))
        -: 2720:      {
    #####: 2721:        continue;
        -: 2722:      }
        -: 2723:#endif /* JERRY_ESNEXT */
        -: 2724:
    #####: 2725:      ecma_property_descriptor_t prop_desc;
    #####: 2726:      ecma_value_t get_desc = ecma_op_object_get_own_property_descriptor (obj_p, name_p, &prop_desc);
        -: 2727:
    #####: 2728:      if (ECMA_IS_VALUE_ERROR (get_desc))
        -: 2729:      {
    #####: 2730:        ecma_collection_free (keys);
    #####: 2731:        ecma_collection_free (return_names_p);
    #####: 2732:        ecma_collection_free (visited_names_p);
    #####: 2733:        ecma_deref_object (obj_p);
    #####: 2734:        return NULL;
        -: 2735:      }
        -: 2736:
    #####: 2737:      if (ecma_is_value_true (get_desc))
        -: 2738:      {
    #####: 2739:        bool is_enumerable = (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE) != 0;
    #####: 2740:        ecma_free_property_descriptor (&prop_desc);
        -: 2741:
    #####: 2742:        if (ecma_collection_has_string_value (visited_names_p, name_p)
    #####: 2743:            || ecma_collection_has_string_value (return_names_p, name_p))
        -: 2744:        {
    #####: 2745:          continue;
        -: 2746:        }
        -: 2747:
    #####: 2748:        ecma_ref_ecma_string (name_p);
        -: 2749:
    #####: 2750:        if (is_enumerable)
        -: 2751:        {
    #####: 2752:          ecma_collection_push_back (return_names_p, prop_name);
        -: 2753:        }
        -: 2754:        else
        -: 2755:        {
    #####: 2756:          ecma_collection_push_back (visited_names_p, prop_name);
        -: 2757:        }
        -: 2758:      }
        -: 2759:    }
        -: 2760:
    #####: 2761:    ecma_collection_free (keys);
        -: 2762:
        -: 2763:    /* Query the prototype. */
    #####: 2764:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (obj_p);
    #####: 2765:    ecma_deref_object (obj_p);
        -: 2766:
    #####: 2767:    if (proto_p == NULL)
        -: 2768:    {
    #####: 2769:      break;
        -: 2770:    }
    #####: 2771:    else if (JERRY_UNLIKELY (proto_p == ECMA_OBJECT_POINTER_ERROR))
        -: 2772:    {
    #####: 2773:      ecma_collection_free (return_names_p);
    #####: 2774:      ecma_collection_free (visited_names_p);
    #####: 2775:      return NULL;
        -: 2776:    }
        -: 2777:
        -: 2778:    /* Advance up on prototype chain. */
    #####: 2779:    obj_p = proto_p;
        -: 2780:  }
        -: 2781:
    #####: 2782:  ecma_collection_free (visited_names_p);
        -: 2783:
    #####: 2784:  return return_names_p;
        -: 2785:} /* ecma_op_object_enumerate */
        -: 2786:
        -: 2787:#ifndef JERRY_NDEBUG
        -: 2788:
        -: 2789:/**
        -: 2790: * Check if passed object is the instance of specified built-in.
        -: 2791: *
        -: 2792: * @return true  - if the object is instance of the specified built-in
        -: 2793: *         false - otherwise
        -: 2794: */
        -: 2795:static bool
    #####: 2796:ecma_builtin_is (ecma_object_t *object_p, /**< pointer to an object */
        -: 2797:                 ecma_builtin_id_t builtin_id) /**< id of built-in to check on */
        -: 2798:{
    #####: 2799:  JERRY_ASSERT (object_p != NULL && !ecma_is_lexical_environment (object_p));
    #####: 2800:  JERRY_ASSERT (builtin_id < ECMA_BUILTIN_ID__COUNT);
        -: 2801:
    #####: 2802:  ecma_object_type_t type = ecma_get_object_type (object_p);
        -: 2803:
    #####: 2804:  switch (type)
        -: 2805:  {
    #####: 2806:    case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 2807:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 2808:    {
    #####: 2809:      ecma_extended_object_t *built_in_object_p = (ecma_extended_object_t *) object_p;
        -: 2810:
    #####: 2811:      return (built_in_object_p->u.built_in.id == builtin_id
    #####: 2812:              && built_in_object_p->u.built_in.routine_id == 0);
        -: 2813:    }
    #####: 2814:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 2815:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 2816:    {
    #####: 2817:      ecma_extended_built_in_object_t *extended_built_in_object_p = (ecma_extended_built_in_object_t *) object_p;
        -: 2818:
    #####: 2819:      return (extended_built_in_object_p->built_in.id == builtin_id
    #####: 2820:              && extended_built_in_object_p->built_in.routine_id == 0);
        -: 2821:    }
    #####: 2822:    default:
        -: 2823:    {
    #####: 2824:      return false;
        -: 2825:    }
        -: 2826:  }
        -: 2827:} /* ecma_builtin_is */
        -: 2828:
        -: 2829:#endif /* !JERRY_NDEBUG */
        -: 2830:
        -: 2831:/**
        -: 2832: * The function is used in the assert of ecma_object_get_class_name
        -: 2833: *
        -: 2834: * @return true  - if class name is an object
        -: 2835: *         false - otherwise
        -: 2836: */
        -: 2837:static inline bool
    #####: 2838:ecma_object_check_class_name_is_object (ecma_object_t *obj_p) /**< object */
        -: 2839:{
        -: 2840:#ifndef JERRY_NDEBUG
    #####: 2841:  return (ecma_builtin_is_global (obj_p)
        -: 2842:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 2843:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE)
        -: 2844:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
    #####: 2845:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SHARED_ARRAYBUFFER_PROTOTYPE)
        -: 2846:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
    #####: 2847:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPEDARRAY_PROTOTYPE)
    #####: 2848:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT8ARRAY_PROTOTYPE)
    #####: 2849:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8ARRAY_PROTOTYPE)
    #####: 2850:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT16ARRAY_PROTOTYPE)
    #####: 2851:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT16ARRAY_PROTOTYPE)
    #####: 2852:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_INT32ARRAY_PROTOTYPE)
    #####: 2853:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT32ARRAY_PROTOTYPE)
    #####: 2854:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT32ARRAY_PROTOTYPE)
    #####: 2855:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_UINT8CLAMPEDARRAY_PROTOTYPE)
        -: 2856:#if JERRY_NUMBER_TYPE_FLOAT64
    #####: 2857:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_FLOAT64ARRAY_PROTOTYPE)
        -: 2858:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -: 2859:#if JERRY_BUILTIN_BIGINT
    #####: 2860:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGINT64ARRAY_PROTOTYPE)
    #####: 2861:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_BIGUINT64ARRAY_PROTOTYPE)
        -: 2862:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2863:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 2864:#if JERRY_ESNEXT
    #####: 2865:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_PROTOTYPE_UNSCOPABLES)
    #####: 2866:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ARRAY_ITERATOR_PROTOTYPE)
    #####: 2867:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ITERATOR_PROTOTYPE)
    #####: 2868:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_STRING_ITERATOR_PROTOTYPE)
    #####: 2869:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_STRING_ITERATOR_PROTOTYPE)
    #####: 2870:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE)
    #####: 2871:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE)
    #####: 2872:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE)
    #####: 2873:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE)
    #####: 2874:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE)
    #####: 2875:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE)
    #####: 2876:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_AGGREGATE_ERROR_PROTOTYPE)
    #####: 2877:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE)
    #####: 2878:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ERROR_PROTOTYPE)
    #####: 2879:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATE_PROTOTYPE)
    #####: 2880:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_REGEXP_PROTOTYPE)
    #####: 2881:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE)
    #####: 2882:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_ASYNC_FUNCTION_PROTOTYPE)
    #####: 2883:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_PROMISE_PROTOTYPE)
        -: 2884:#endif /* JERRY_ESNEXT */
        -: 2885:#if JERRY_BUILTIN_CONTAINER
    #####: 2886:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_PROTOTYPE)
    #####: 2887:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_PROTOTYPE)
    #####: 2888:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE)
    #####: 2889:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE)
        -: 2890:#if JERRY_ESNEXT
    #####: 2891:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_MAP_ITERATOR_PROTOTYPE)
    #####: 2892:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_SET_ITERATOR_PROTOTYPE)
        -: 2893:#endif /* JERRY_ESNEXT */
        -: 2894:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 2895:#if JERRY_BUILTIN_WEAKREF
    #####: 2896:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_WEAKREF_PROTOTYPE)
        -: 2897:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 2898:#if JERRY_BUILTIN_DATAVIEW
    #####: 2899:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_DATAVIEW_PROTOTYPE)
        -: 2900:#endif /* JERRY_BUILTIN_DATAVIEW */
    #####: 2901:          || ecma_builtin_is (obj_p, ECMA_BUILTIN_ID_OBJECT_PROTOTYPE));
        -: 2902:#else /* JERRY_NDEBUG */
        -: 2903:  JERRY_UNUSED (obj_p);
        -: 2904:  return true;
        -: 2905:#endif /* !JERRY_NDEBUG */
        -: 2906:} /* ecma_object_check_class_name_is_object */
        -: 2907:
        -: 2908:/**
        -: 2909: * Used by ecma_object_get_class_name to get the magic string id of class objects
        -: 2910: */
        -: 2911:static const uint16_t ecma_class_object_magic_string_id[] =
        -: 2912:{
        -: 2913:  /* These objects require custom property resolving. */
        -: 2914:  LIT_MAGIC_STRING_STRING_UL, /**< magic string id of ECMA_OBJECT_CLASS_STRING */
        -: 2915:  LIT_MAGIC_STRING_ARGUMENTS_UL, /**< magic string id of ECMA_OBJECT_CLASS_ARGUMENTS */
        -: 2916:#if JERRY_BUILTIN_TYPEDARRAY
        -: 2917:  LIT_MAGIC_STRING__EMPTY, /**< ECMA_OBJECT_CLASS_TYPEDARRAY needs special resolver */
        -: 2918:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 2919:#if JERRY_MODULE_SYSTEM
        -: 2920:  LIT_MAGIC_STRING_MODULE_UL, /**< magic string id of ECMA_OBJECT_CLASS_MODULE_NAMESPACE */
        -: 2921:#endif
        -: 2922:
        -: 2923:  /* These objects are marked by Garbage Collector. */
        -: 2924:#if JERRY_ESNEXT
        -: 2925:  LIT_MAGIC_STRING_GENERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_GENERATOR */
        -: 2926:  LIT_MAGIC_STRING_ASYNC_GENERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_ASYNC_GENERATOR */
        -: 2927:  LIT_MAGIC_STRING_ARRAY_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_ARRAY_ITERATOR */
        -: 2928:  LIT_MAGIC_STRING_SET_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_SET_ITERATOR */
        -: 2929:  LIT_MAGIC_STRING_MAP_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_MAP_ITERATOR */
        -: 2930:#if JERRY_BUILTIN_REGEXP
        -: 2931:  LIT_MAGIC_STRING_REGEXP_STRING_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR */
        -: 2932:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2933:#endif /* JERRY_ESNEXT */
        -: 2934:#if JERRY_MODULE_SYSTEM
        -: 2935:  LIT_MAGIC_STRING_MODULE_UL, /**< magic string id of ECMA_OBJECT_CLASS_MODULE */
        -: 2936:#endif
        -: 2937:#if JERRY_ESNEXT
        -: 2938:  LIT_MAGIC_STRING_PROMISE_UL, /**< magic string id of ECMA_OBJECT_CLASS_PROMISE */
        -: 2939:  LIT_MAGIC_STRING_OBJECT_UL, /**< magic string id of ECMA_OBJECT_CLASS_PROMISE_CAPABILITY */
        -: 2940:#endif /* JERRY_ESNEXT */
        -: 2941:#if JERRY_BUILTIN_DATAVIEW
        -: 2942:  LIT_MAGIC_STRING_DATAVIEW_UL, /**< magic string id of ECMA_OBJECT_CLASS_DATAVIEW */
        -: 2943:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 2944:#if JERRY_BUILTIN_CONTAINER
        -: 2945:  LIT_MAGIC_STRING__EMPTY, /**< magic string id of ECMA_OBJECT_CLASS_CONTAINER needs special resolver */
        -: 2946:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 2947:
        -: 2948:  /* Normal objects. */
        -: 2949:  LIT_MAGIC_STRING_BOOLEAN_UL, /**< magic string id of ECMA_OBJECT_CLASS_BOOLEAN */
        -: 2950:  LIT_MAGIC_STRING_NUMBER_UL, /**< magic string id of ECMA_OBJECT_CLASS_NUMBER */
        -: 2951:  LIT_MAGIC_STRING_ERROR_UL, /**< magic string id of ECMA_OBJECT_CLASS_ERROR */
        -: 2952:  LIT_MAGIC_STRING_OBJECT_UL, /**< magic string id of ECMA_OBJECT_CLASS_INTERNAL_OBJECT */
        -: 2953:#if JERRY_PARSER
        -: 2954:  LIT_MAGIC_STRING_SCRIPT_UL, /**< magic string id of ECMA_OBJECT_CLASS_SCRIPT */
        -: 2955:#endif /* JERRY_PARSER */
        -: 2956:#if JERRY_BUILTIN_DATE
        -: 2957:  LIT_MAGIC_STRING_DATE_UL, /**< magic string id of ECMA_OBJECT_CLASS_DATE */
        -: 2958:#endif /* JERRY_BUILTIN_DATE */
        -: 2959:#if JERRY_BUILTIN_REGEXP
        -: 2960:  LIT_MAGIC_STRING_REGEXP_UL, /**< magic string id of ECMA_OBJECT_CLASS_REGEXP */
        -: 2961:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2962:#if JERRY_ESNEXT
        -: 2963:  LIT_MAGIC_STRING_SYMBOL_UL, /**< magic string id of ECMA_OBJECT_CLASS_SYMBOL */
        -: 2964:  LIT_MAGIC_STRING_STRING_ITERATOR_UL, /**< magic string id of ECMA_OBJECT_CLASS_STRING_ITERATOR */
        -: 2965:#endif /* JERRY_ESNEXT */
        -: 2966:#if JERRY_BUILTIN_TYPEDARRAY
        -: 2967:  LIT_MAGIC_STRING_ARRAY_BUFFER_UL, /**< magic string id of ECMA_OBJECT_CLASS_ARRAY_BUFFER */
        -: 2968:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 2969:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 2970:  LIT_MAGIC_STRING_SHARED_ARRAY_BUFFER_UL, /**< magic string id of ECMA_OBJECT_CLASS_SHAREDARRAY_BUFFER */
        -: 2971:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 2972:#if JERRY_BUILTIN_BIGINT
        -: 2973:  LIT_MAGIC_STRING_BIGINT_UL, /**< magic string id of ECMA_OBJECT_CLASS_BIGINT */
        -: 2974:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2975:#if JERRY_BUILTIN_WEAKREF
        -: 2976:  LIT_MAGIC_STRING_WEAKREF_UL, /**< magic string id of ECMA_OBJECT_CLASS_WEAKREF */
        -: 2977:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 2978:};
        -: 2979:
        -: 2980:JERRY_STATIC_ASSERT (sizeof (ecma_class_object_magic_string_id) == ECMA_OBJECT_CLASS__MAX * sizeof (uint16_t),
        -: 2981:                     ecma_class_object_magic_string_id_must_have_object_class_max_elements);
        -: 2982:
        -: 2983:/**
        -: 2984: * Get [[Class]] string of specified object
        -: 2985: *
        -: 2986: * @return class name magic string
        -: 2987: */
        -: 2988:lit_magic_string_id_t
    #####: 2989:ecma_object_get_class_name (ecma_object_t *obj_p) /**< object */
        -: 2990:{
    #####: 2991:  ecma_object_type_t type = ecma_get_object_type (obj_p);
        -: 2992:
    #####: 2993:  switch (type)
        -: 2994:  {
    #####: 2995:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 2996:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 2997:    {
    #####: 2998:      return LIT_MAGIC_STRING_ARRAY_UL;
        -: 2999:    }
    #####: 3000:    case ECMA_OBJECT_TYPE_CLASS:
        -: 3001:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 3002:    {
    #####: 3003:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) obj_p;
        -: 3004:
    #####: 3005:      switch (ext_object_p->u.cls.type)
        -: 3006:      {
        -: 3007:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 3008:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 3009:        {
    #####: 3010:          return ecma_get_typedarray_magic_string_id (ext_object_p->u.cls.u1.typedarray_type);
        -: 3011:        }
        -: 3012:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 3013:#if JERRY_BUILTIN_CONTAINER
    #####: 3014:        case ECMA_OBJECT_CLASS_CONTAINER:
        -: 3015:        {
    #####: 3016:          return (lit_magic_string_id_t) ext_object_p->u.cls.u2.container_id;
        -: 3017:        }
        -: 3018:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 3019:        default:
        -: 3020:        {
    #####: 3021:          break;
        -: 3022:        }
        -: 3023:      }
        -: 3024:
    #####: 3025:      JERRY_ASSERT (ext_object_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
    #####: 3026:      JERRY_ASSERT (ecma_class_object_magic_string_id[ext_object_p->u.cls.type] != LIT_MAGIC_STRING__EMPTY);
        -: 3027:
    #####: 3028:      return (lit_magic_string_id_t) ecma_class_object_magic_string_id[ext_object_p->u.cls.type];
        -: 3029:    }
    #####: 3030:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 3031:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 3032:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 3033:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 3034:    {
    #####: 3035:      return LIT_MAGIC_STRING_FUNCTION_UL;
        -: 3036:    }
        -: 3037:#if JERRY_BUILTIN_PROXY
    #####: 3038:    case ECMA_OBJECT_TYPE_PROXY:
        -: 3039:    {
    #####: 3040:      ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p;
        -: 3041:
    #####: 3042:      if (!ecma_is_value_null (proxy_obj_p->target) && ecma_is_value_object (proxy_obj_p->target))
        -: 3043:      {
    #####: 3044:        ecma_object_t *target_obj_p = ecma_get_object_from_value (proxy_obj_p->target);
    #####: 3045:        return ecma_object_get_class_name (target_obj_p);
        -: 3046:      }
    #####: 3047:      return LIT_MAGIC_STRING_OBJECT_UL;
        -: 3048:    }
        -: 3049:#endif /* JERRY_BUILTIN_PROXY */
    #####: 3050:    case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 3051:    {
    #####: 3052:      ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 3053:
    #####: 3054:      switch (ext_obj_p->u.built_in.id)
        -: 3055:      {
        -: 3056:#if JERRY_BUILTIN_MATH
    #####: 3057:        case ECMA_BUILTIN_ID_MATH:
        -: 3058:        {
    #####: 3059:          return LIT_MAGIC_STRING_MATH_UL;
        -: 3060:        }
        -: 3061:#endif /* JERRY_BUILTIN_MATH */
        -: 3062:#if JERRY_BUILTIN_REFLECT
    #####: 3063:        case ECMA_BUILTIN_ID_REFLECT:
        -: 3064:        {
    #####: 3065:          return LIT_MAGIC_STRING_REFLECT_UL;
        -: 3066:        }
        -: 3067:#endif /* JERRY_BUILTIN_REFLECT */
        -: 3068:#if JERRY_ESNEXT
    #####: 3069:        case ECMA_BUILTIN_ID_GENERATOR:
        -: 3070:        {
    #####: 3071:          return LIT_MAGIC_STRING_GENERATOR_UL;
        -: 3072:        }
    #####: 3073:        case ECMA_BUILTIN_ID_ASYNC_GENERATOR:
        -: 3074:        {
    #####: 3075:          return LIT_MAGIC_STRING_ASYNC_GENERATOR_UL;
        -: 3076:        }
        -: 3077:#endif /* JERRY_ESNEXT */
        -: 3078:#if JERRY_BUILTIN_JSON
    #####: 3079:        case ECMA_BUILTIN_ID_JSON:
        -: 3080:        {
    #####: 3081:          return LIT_MAGIC_STRING_JSON_U;
        -: 3082:        }
        -: 3083:#endif /* JERRY_BUILTIN_JSON */
        -: 3084:#if !JERRY_ESNEXT
        -: 3085:#if JERRY_BUILTIN_ERRORS
        -: 3086:        case ECMA_BUILTIN_ID_EVAL_ERROR_PROTOTYPE:
        -: 3087:        case ECMA_BUILTIN_ID_RANGE_ERROR_PROTOTYPE:
        -: 3088:        case ECMA_BUILTIN_ID_REFERENCE_ERROR_PROTOTYPE:
        -: 3089:        case ECMA_BUILTIN_ID_SYNTAX_ERROR_PROTOTYPE:
        -: 3090:        case ECMA_BUILTIN_ID_TYPE_ERROR_PROTOTYPE:
        -: 3091:        case ECMA_BUILTIN_ID_URI_ERROR_PROTOTYPE:
        -: 3092:#endif /* JERRY_BUILTIN_ERRORS */
        -: 3093:        case ECMA_BUILTIN_ID_ERROR_PROTOTYPE:
        -: 3094:        {
        -: 3095:          return LIT_MAGIC_STRING_ERROR_UL;
        -: 3096:        }
        -: 3097:#endif /* !JERRY_ESNEXT */
    #####: 3098:        default:
        -: 3099:        {
    #####: 3100:          break;
        -: 3101:        }
        -: 3102:      }
        -: 3103:
    #####: 3104:      JERRY_ASSERT (ecma_object_check_class_name_is_object (obj_p));
    #####: 3105:      return LIT_MAGIC_STRING_OBJECT_UL;
        -: 3106:    }
    #####: 3107:    default:
        -: 3108:    {
    #####: 3109:      JERRY_ASSERT (type == ECMA_OBJECT_TYPE_GENERAL
        -: 3110:                    || type == ECMA_OBJECT_TYPE_PROXY);
        -: 3111:
    #####: 3112:      return LIT_MAGIC_STRING_OBJECT_UL;
        -: 3113:    }
        -: 3114:  }
        -: 3115:} /* ecma_object_get_class_name */
        -: 3116:
        -: 3117:#if JERRY_BUILTIN_REGEXP
        -: 3118:/**
        -: 3119: * Checks if the given argument has [[RegExpMatcher]] internal slot
        -: 3120: *
        -: 3121: * @return true - if the given argument is a regexp
        -: 3122: *         false - otherwise
        -: 3123: */
        -: 3124:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 3125:ecma_object_is_regexp_object (ecma_value_t arg) /**< argument */
        -: 3126:{
    #####: 3127:  return (ecma_is_value_object (arg)
    #####: 3128:          && ecma_object_class_is (ecma_get_object_from_value (arg), ECMA_OBJECT_CLASS_REGEXP));
        -: 3129:} /* ecma_object_is_regexp_object */
        -: 3130:#endif /* JERRY_BUILTIN_REGEXP */
        -: 3131:
        -: 3132:#if JERRY_ESNEXT
        -: 3133:/**
        -: 3134: * Object's IsConcatSpreadable operation, used for Array.prototype.concat
        -: 3135: * It checks the argument's [Symbol.isConcatSpreadable] property value
        -: 3136: *
        -: 3137: * See also:
        -: 3138: *          ECMA-262 v6, 22.1.3.1.1;
        -: 3139: *
        -: 3140: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 3141: *         ECMA_VALUE_TRUE - if the argument is concatSpreadable
        -: 3142: *         ECMA_VALUE_FALSE - otherwise
        -: 3143: */
        -: 3144:ecma_value_t
    #####: 3145:ecma_op_is_concat_spreadable (ecma_value_t arg) /**< argument */
        -: 3146:{
    #####: 3147:  if (!ecma_is_value_object (arg))
        -: 3148:  {
    #####: 3149:    return ECMA_VALUE_FALSE;
        -: 3150:  }
        -: 3151:
    #####: 3152:  ecma_value_t spreadable = ecma_op_object_get_by_symbol_id (ecma_get_object_from_value (arg),
        -: 3153:                                                             LIT_GLOBAL_SYMBOL_IS_CONCAT_SPREADABLE);
        -: 3154:
    #####: 3155:  if (ECMA_IS_VALUE_ERROR (spreadable))
        -: 3156:  {
    #####: 3157:    return spreadable;
        -: 3158:  }
        -: 3159:
    #####: 3160:  if (!ecma_is_value_undefined (spreadable))
        -: 3161:  {
    #####: 3162:    const bool to_bool = ecma_op_to_boolean (spreadable);
    #####: 3163:    ecma_free_value (spreadable);
    #####: 3164:    return ecma_make_boolean_value (to_bool);
        -: 3165:  }
        -: 3166:
    #####: 3167:  return ecma_is_value_array (arg);
        -: 3168:} /* ecma_op_is_concat_spreadable */
        -: 3169:
        -: 3170:/**
        -: 3171: * IsRegExp operation
        -: 3172: *
        -: 3173: * See also:
        -: 3174: *          ECMA-262 v6, 22.1.3.1.1;
        -: 3175: *
        -: 3176: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 3177: *         ECMA_VALUE_TRUE - if the argument is regexp
        -: 3178: *         ECMA_VALUE_FALSE - otherwise
        -: 3179: */
        -: 3180:ecma_value_t
    #####: 3181:ecma_op_is_regexp (ecma_value_t arg) /**< argument */
        -: 3182:{
    #####: 3183:  if (!ecma_is_value_object (arg))
        -: 3184:  {
    #####: 3185:    return ECMA_VALUE_FALSE;
        -: 3186:  }
        -: 3187:
    #####: 3188:  ecma_value_t is_regexp = ecma_op_object_get_by_symbol_id (ecma_get_object_from_value (arg),
        -: 3189:                                                            LIT_GLOBAL_SYMBOL_MATCH);
        -: 3190:
    #####: 3191:  if (ECMA_IS_VALUE_ERROR (is_regexp))
        -: 3192:  {
    #####: 3193:    return is_regexp;
        -: 3194:  }
        -: 3195:
    #####: 3196:  if (!ecma_is_value_undefined (is_regexp))
        -: 3197:  {
    #####: 3198:    const bool to_bool = ecma_op_to_boolean (is_regexp);
    #####: 3199:    ecma_free_value (is_regexp);
    #####: 3200:    return ecma_make_boolean_value (to_bool);
        -: 3201:  }
        -: 3202:
    #####: 3203:  return ecma_make_boolean_value (ecma_object_is_regexp_object (arg));
        -: 3204:} /* ecma_op_is_regexp */
        -: 3205:
        -: 3206:/**
        -: 3207: * SpeciesConstructor operation
        -: 3208: * See also:
        -: 3209: *          ECMA-262 v6, 7.3.20;
        -: 3210: *
        -: 3211: * @return ecma_value
        -: 3212: *         returned value must be freed with ecma_free_value
        -: 3213: */
        -: 3214:ecma_value_t
    #####: 3215:ecma_op_species_constructor (ecma_object_t *this_value, /**< This Value */
        -: 3216:                             ecma_builtin_id_t default_constructor_id) /**< Builtin ID of default constructor */
        -: 3217:{
    #####: 3218:  ecma_object_t *default_constructor_p = ecma_builtin_get (default_constructor_id);
    #####: 3219:  ecma_value_t constructor = ecma_op_object_get_by_magic_id (this_value, LIT_MAGIC_STRING_CONSTRUCTOR);
    #####: 3220:  if (ECMA_IS_VALUE_ERROR (constructor))
        -: 3221:  {
    #####: 3222:    return constructor;
        -: 3223:  }
        -: 3224:
    #####: 3225:  if (ecma_is_value_undefined (constructor))
        -: 3226:  {
    #####: 3227:    ecma_ref_object (default_constructor_p);
    #####: 3228:    return ecma_make_object_value (default_constructor_p);
        -: 3229:  }
        -: 3230:
    #####: 3231:  if (!ecma_is_value_object (constructor))
        -: 3232:  {
    #####: 3233:    ecma_free_value (constructor);
    #####: 3234:    return ecma_raise_type_error (ECMA_ERR_MSG ("Constructor must be an object"));
        -: 3235:  }
        -: 3236:
    #####: 3237:  ecma_object_t *ctor_object_p = ecma_get_object_from_value (constructor);
    #####: 3238:  ecma_value_t species = ecma_op_object_get_by_symbol_id (ctor_object_p, LIT_GLOBAL_SYMBOL_SPECIES);
    #####: 3239:  ecma_deref_object (ctor_object_p);
        -: 3240:
    #####: 3241:  if (ECMA_IS_VALUE_ERROR (species))
        -: 3242:  {
    #####: 3243:    return species;
        -: 3244:  }
        -: 3245:
    #####: 3246:  if (ecma_is_value_undefined (species) || ecma_is_value_null (species))
        -: 3247:  {
    #####: 3248:    ecma_ref_object (default_constructor_p);
    #####: 3249:    return ecma_make_object_value (default_constructor_p);
        -: 3250:  }
        -: 3251:
    #####: 3252:  if (!ecma_is_constructor (species))
        -: 3253:  {
    #####: 3254:    ecma_free_value (species);
    #####: 3255:    return ecma_raise_type_error (ECMA_ERR_MSG ("Species must be a constructor"));
        -: 3256:  }
        -: 3257:
    #####: 3258:  return species;
        -: 3259:} /* ecma_op_species_constructor */
        -: 3260:
        -: 3261:/**
        -: 3262: * 7.3.18 Abstract operation Invoke when property name is a magic string
        -: 3263: *
        -: 3264: * @return ecma_value result of the invoked function or raised error
        -: 3265: *         note: returned value must be freed with ecma_free_value
        -: 3266: */
        -: 3267:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3268:ecma_op_invoke_by_symbol_id (ecma_value_t object, /**< Object value */
        -: 3269:                             lit_magic_string_id_t symbol_id, /**< Symbol ID */
        -: 3270:                             ecma_value_t *args_p, /**< Argument list */
        -: 3271:                             uint32_t args_len) /**< Argument list length */
        -: 3272:{
    #####: 3273:  ecma_string_t *symbol_p = ecma_op_get_global_symbol (symbol_id);
    #####: 3274:  ecma_value_t ret_value = ecma_op_invoke (object, symbol_p, args_p, args_len);
    #####: 3275:  ecma_deref_ecma_string (symbol_p);
        -: 3276:
    #####: 3277:  return ret_value;
        -: 3278:} /* ecma_op_invoke_by_symbol_id */
        -: 3279:#endif /* JERRY_ESNEXT */
        -: 3280:
        -: 3281:/**
        -: 3282: * 7.3.18 Abstract operation Invoke when property name is a magic string
        -: 3283: *
        -: 3284: * @return ecma_value result of the invoked function or raised error
        -: 3285: *         note: returned value must be freed with ecma_free_value
        -: 3286: */
        -: 3287:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3288:ecma_op_invoke_by_magic_id (ecma_value_t object, /**< Object value */
        -: 3289:                            lit_magic_string_id_t magic_string_id, /**< Magic string ID */
        -: 3290:                            ecma_value_t *args_p, /**< Argument list */
        -: 3291:                            uint32_t args_len) /**< Argument list length */
        -: 3292:{
    #####: 3293:  return ecma_op_invoke (object, ecma_get_magic_string (magic_string_id), args_p, args_len);
        -: 3294:} /* ecma_op_invoke_by_magic_id */
        -: 3295:
        -: 3296:/**
        -: 3297: * 7.3.18 Abstract operation Invoke
        -: 3298: *
        -: 3299: * @return ecma_value result of the invoked function or raised error
        -: 3300: *         note: returned value must be freed with ecma_free_value
        -: 3301: */
        -: 3302:ecma_value_t
    #####: 3303:ecma_op_invoke (ecma_value_t object, /**< Object value */
        -: 3304:                ecma_string_t *property_name_p, /**< Property name */
        -: 3305:                ecma_value_t *args_p, /**< Argument list */
        -: 3306:                uint32_t args_len) /**< Argument list length */
        -: 3307:{
        -: 3308:  /* 3. */
    #####: 3309:  ecma_value_t object_value = ecma_op_to_object (object);
    #####: 3310:  if (ECMA_IS_VALUE_ERROR (object_value))
        -: 3311:  {
    #####: 3312:    return object_value;
        -: 3313:  }
        -: 3314:
    #####: 3315:  ecma_object_t *object_p = ecma_get_object_from_value (object_value);
        -: 3316:
        -: 3317:#if JERRY_ESNEXT
    #####: 3318:  ecma_value_t this_arg = object;
        -: 3319:#else /* !JERRY_ESNEXT */
    #####: 3320:  ecma_value_t this_arg = object_value;
        -: 3321:#endif /* JERRY_ESNEXT */
        -: 3322:
    #####: 3323:  ecma_value_t func = ecma_op_object_get_with_receiver (object_p, property_name_p, this_arg);
        -: 3324:
    #####: 3325:  if (ECMA_IS_VALUE_ERROR (func))
        -: 3326:  {
    #####: 3327:    ecma_deref_object (object_p);
    #####: 3328:    return func;
        -: 3329:  }
        -: 3330:
        -: 3331:  /* 4. */
    #####: 3332:  if (!ecma_op_is_callable (func))
        -: 3333:  {
    #####: 3334:    ecma_free_value (func);
    #####: 3335:    ecma_deref_object (object_p);
    #####: 3336:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument is not callable"));
        -: 3337:  }
        -: 3338:
    #####: 3339:  ecma_object_t *func_obj_p = ecma_get_object_from_value (func);
    #####: 3340:  ecma_value_t call_result = ecma_op_function_call (func_obj_p, this_arg, args_p, args_len);
        -: 3341:
    #####: 3342:  ecma_deref_object (object_p);
    #####: 3343:  ecma_deref_object (func_obj_p);
        -: 3344:
    #####: 3345:  return call_result;
        -: 3346:} /* ecma_op_invoke */
        -: 3347:
        -: 3348:/**
        -: 3349: * Ordinary object [[GetPrototypeOf]] operation
        -: 3350: *
        -: 3351: * See also:
        -: 3352: *          ECMAScript v6, 9.1.1
        -: 3353: *
        -: 3354: * @return the value of the [[Prototype]] internal slot of the given object.
        -: 3355: */
        -: 3356:extern inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3357:ecma_op_ordinary_object_get_prototype_of (ecma_object_t *obj_p) /**< object */
        -: 3358:{
      120: 3359:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
      120: 3360:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (obj_p));
        -: 3361:
      120: 3362:  return obj_p->u2.prototype_cp;
        -: 3363:} /* ecma_op_ordinary_object_get_prototype_of */
        -: 3364:
        -: 3365:/**
        -: 3366: * Ordinary object [[SetPrototypeOf]] operation
        -: 3367: *
        -: 3368: * See also:
        -: 3369: *          ECMAScript v6, 9.1.2
        -: 3370: *
        -: 3371: * @return ECMA_VALUE_FALSE - if the operation fails
        -: 3372: *         ECMA_VALUE_TRUE - otherwise
        -: 3373: */
        -: 3374:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####: 3375:ecma_op_ordinary_object_set_prototype_of (ecma_object_t *obj_p, /**< base object */
        -: 3376:                                          ecma_value_t proto) /**< prototype object */
        -: 3377:{
    #####: 3378:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
    #####: 3379:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (obj_p));
        -: 3380:
        -: 3381:  /* 1. */
    #####: 3382:  JERRY_ASSERT (ecma_is_value_object (proto) || ecma_is_value_null (proto));
        -: 3383:
        -: 3384:  /* 3. */
    #####: 3385:  ecma_object_t *current_proto_p = ECMA_GET_POINTER (ecma_object_t, ecma_op_ordinary_object_get_prototype_of (obj_p));
    #####: 3386:  ecma_object_t *new_proto_p = ecma_is_value_null (proto) ? NULL : ecma_get_object_from_value (proto);
        -: 3387:
        -: 3388:  /* 4. */
    #####: 3389:  if (new_proto_p == current_proto_p)
        -: 3390:  {
    #####: 3391:    return ECMA_VALUE_TRUE;
        -: 3392:  }
        -: 3393:
        -: 3394:  /* 2 - 5. */
    #####: 3395:  if (!ecma_op_ordinary_object_is_extensible (obj_p))
        -: 3396:  {
    #####: 3397:    return ECMA_VALUE_FALSE;
        -: 3398:  }
        -: 3399:
        -: 3400:  /**
        -: 3401:   * When the prototype of a fast array changes, it is required to convert the
        -: 3402:   * array to a "normal" array. This ensures that all [[Get]]/[[Set]]/etc.
        -: 3403:   * calls works as expected.
        -: 3404:   */
    #####: 3405:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3406:  {
    #####: 3407:    ecma_fast_array_convert_to_normal (obj_p);
        -: 3408:  }
        -: 3409:
        -: 3410:  /* 6. */
    #####: 3411:  ecma_object_t *iter_p = new_proto_p;
        -: 3412:
        -: 3413:  /* 7 - 8. */
        -: 3414:  while (true)
        -: 3415:  {
        -: 3416:    /* 8.a */
    #####: 3417:    if (iter_p == NULL)
        -: 3418:    {
    #####: 3419:      break;
        -: 3420:    }
        -: 3421:
        -: 3422:    /* 8.b */
    #####: 3423:    if (obj_p == iter_p)
        -: 3424:    {
    #####: 3425:      return ECMA_VALUE_FALSE;
        -: 3426:    }
        -: 3427:
        -: 3428:    /* 8.c.i */
        -: 3429:#if JERRY_BUILTIN_PROXY
    #####: 3430:    if (ECMA_OBJECT_IS_PROXY (iter_p))
        -: 3431:    {
    #####: 3432:      break;
        -: 3433:    }
        -: 3434:#endif /* JERRY_BUILTIN_PROXY */
        -: 3435:
        -: 3436:    /* 8.c.ii */
    #####: 3437:    iter_p = ECMA_GET_POINTER (ecma_object_t, ecma_op_ordinary_object_get_prototype_of (iter_p));
        -: 3438:  }
        -: 3439:
        -: 3440:  /* 9. */
    #####: 3441:  ECMA_SET_POINTER (obj_p->u2.prototype_cp, new_proto_p);
        -: 3442:
        -: 3443:  /* 10. */
    #####: 3444:  return ECMA_VALUE_TRUE;
        -: 3445:} /* ecma_op_ordinary_object_set_prototype_of */
        -: 3446:
        -: 3447:/**
        -: 3448: * [[IsExtensible]] operation for Ordinary object.
        -: 3449: *
        -: 3450: * See also:
        -: 3451: *          ECMAScript v6, 9.1.2
        -: 3452: *
        -: 3453: * @return true  - if object is extensible
        -: 3454: *         false - otherwise
        -: 3455: */
        -: 3456:extern inline bool JERRY_ATTR_PURE
       11: 3457:ecma_op_ordinary_object_is_extensible (ecma_object_t *object_p) /**< object */
        -: 3458:{
       11: 3459:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3460:
       11: 3461:  bool is_extensible = (object_p->type_flags_refs & ECMA_OBJECT_FLAG_EXTENSIBLE) != 0;
        -: 3462:
       11: 3463:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p) || is_extensible);
        -: 3464:
       11: 3465:  return is_extensible;
        -: 3466:} /* ecma_op_ordinary_object_is_extensible */
        -: 3467:
        -: 3468:/**
        -: 3469: * Set value of [[Extensible]] object's internal property.
        -: 3470: */
        -: 3471:void JERRY_ATTR_NOINLINE
    #####: 3472:ecma_op_ordinary_object_prevent_extensions (ecma_object_t *object_p) /**< object */
        -: 3473:{
    #####: 3474:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3475:
    #####: 3476:  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (object_p)))
        -: 3477:  {
    #####: 3478:    ecma_fast_array_convert_to_normal (object_p);
        -: 3479:  }
        -: 3480:
    #####: 3481:  object_p->type_flags_refs &= (ecma_object_descriptor_t) ~ECMA_OBJECT_FLAG_EXTENSIBLE;
    #####: 3482:} /* ecma_op_ordinary_object_prevent_extensions */
        -: 3483:
        -: 3484:/**
        -: 3485: * Checks whether an object (excluding prototypes) has a named property
        -: 3486: *
        -: 3487: * @return true - if property is found
        -: 3488: *         false - otherwise
        -: 3489: */
        -: 3490:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 3491:ecma_op_ordinary_object_has_own_property (ecma_object_t *object_p, /**< the object */
        -: 3492:                                          ecma_string_t *property_name_p) /**< property name */
        -: 3493:{
      108: 3494:  JERRY_ASSERT (!ECMA_OBJECT_IS_PROXY (object_p));
        -: 3495:
      108: 3496:  ecma_property_t property = ecma_op_object_get_own_property (object_p,
        -: 3497:                                                              property_name_p,
        -: 3498:                                                              NULL,
        -: 3499:                                                              ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 3500:
      108: 3501:  return property != ECMA_PROPERTY_TYPE_NOT_FOUND && property != ECMA_PROPERTY_TYPE_NOT_FOUND_AND_STOP;
        -: 3502:} /* ecma_op_ordinary_object_has_own_property */
        -: 3503:
        -: 3504:#if JERRY_BUILTIN_WEAKREF || JERRY_BUILTIN_CONTAINER
        -: 3505:
        -: 3506:/**
        -: 3507: * Set a weak reference from a container or WeakRefObject to a key object
        -: 3508: */
        -: 3509:void
    #####: 3510:ecma_op_object_set_weak (ecma_object_t *object_p, /**< key object */
        -: 3511:                         ecma_object_t *target_p) /**< target object */
        -: 3512:{
    #####: 3513:  if (JERRY_UNLIKELY (ecma_op_object_is_fast_array (object_p)))
        -: 3514:  {
    #####: 3515:    ecma_fast_array_convert_to_normal (object_p);
        -: 3516:  }
        -: 3517:
    #####: 3518:  ecma_string_t *weak_refs_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);
    #####: 3519:  ecma_property_t *property_p = ecma_find_named_property (object_p, weak_refs_string_p);
        -: 3520:  ecma_collection_t *refs_p;
        -: 3521:
    #####: 3522:  if (property_p == NULL)
        -: 3523:  {
    #####: 3524:    refs_p = ecma_new_collection ();
        -: 3525:
        -: 3526:    ecma_property_value_t *value_p;
    #####: 3527:    ECMA_CREATE_INTERNAL_PROPERTY (object_p, weak_refs_string_p, property_p, value_p);
    #####: 3528:    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, refs_p);
        -: 3529:  }
        -: 3530:  else
        -: 3531:  {
    #####: 3532:    refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -: 3533:  }
        -: 3534:
    #####: 3535:  const ecma_value_t target_value = ecma_make_object_value ((ecma_object_t *) target_p);
    #####: 3536:  for (uint32_t i = 0; i < refs_p->item_count; i++)
        -: 3537:  {
    #####: 3538:    if (ecma_is_value_empty (refs_p->buffer_p[i]))
        -: 3539:    {
    #####: 3540:      refs_p->buffer_p[i] = target_value;
    #####: 3541:      return;
        -: 3542:    }
        -: 3543:  }
        -: 3544:
    #####: 3545:  ecma_collection_push_back (refs_p, target_value);
        -: 3546:} /* ecma_op_object_set_weak */
        -: 3547:
        -: 3548:/**
        -: 3549: * Helper function to remove a weak reference to an object.
        -: 3550: *
        -: 3551: * @return ecma value
        -: 3552: *         Returned value must be freed with ecma_free_value.
        -: 3553: */
        -: 3554:void
    #####: 3555:ecma_op_object_unref_weak (ecma_object_t *object_p, /**< this argument */
        -: 3556:                           ecma_value_t ref_holder) /**< key argument */
        -: 3557:{
    #####: 3558:  ecma_string_t *weak_refs_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_WEAK_REFS);
        -: 3559:
    #####: 3560:  ecma_property_t *property_p = ecma_find_named_property (object_p, weak_refs_string_p);
    #####: 3561:  JERRY_ASSERT (property_p != NULL);
        -: 3562:
    #####: 3563:  ecma_collection_t *refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -: 3564:                                                               ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3565:  ecma_value_t *buffer_p = refs_p->buffer_p;
        -: 3566:
        -: 3567:  while (true)
        -: 3568:  {
    #####: 3569:    if (*buffer_p == ref_holder)
        -: 3570:    {
    #####: 3571:      *buffer_p = ECMA_VALUE_EMPTY;
    #####: 3572:      return;
        -: 3573:    }
    #####: 3574:    JERRY_ASSERT (buffer_p < refs_p->buffer_p + refs_p->item_count);
    #####: 3575:    buffer_p++;
        -: 3576:  }
        -: 3577:} /* ecma_op_object_unref_weak */
        -: 3578:
        -: 3579:#endif /* JERRY_BUILTIN_WEAKREF || JERRY_BUILTIN_CONTAINER */
        -: 3580:/**
        -: 3581: * Raise property redefinition error
        -: 3582: *
        -: 3583: * @return ECMA_VALUE_FALSE - if JERRY_PROP_SHOULD_THROW is not set
        -: 3584: *         raised TypeError - otherwise
        -: 3585: */
        -: 3586:ecma_value_t
    #####: 3587:ecma_raise_property_redefinition (ecma_string_t *property_name_p, /**< property name */
        -: 3588:                                  uint16_t flags) /**< property descriptor flags */
        -: 3589:{
        -: 3590:  JERRY_UNUSED (property_name_p);
        -: 3591:
    #####: 3592:  return ECMA_REJECT_WITH_FORMAT (flags & JERRY_PROP_SHOULD_THROW,
        -: 3593:                                  "Cannot redefine property: %",
        -: 3594:                                  ecma_make_prop_name_value (property_name_p));
        -: 3595:} /* ecma_raise_property_redefinition */
        -: 3596:
        -: 3597:/**
        -: 3598: * Raise readonly assignment error
        -: 3599: *
        -: 3600: * @return ECMA_VALUE_FALSE - if is_throw is true
        -: 3601: *         raised TypeError - otherwise
        -: 3602: */
        -: 3603:ecma_value_t
    #####: 3604:ecma_raise_readonly_assignment (ecma_string_t *property_name_p, /**< property name */
        -: 3605:                                bool is_throw) /**< is throw flag */
        -: 3606:{
        -: 3607:  JERRY_UNUSED (property_name_p);
        -: 3608:
    #####: 3609:  return ECMA_REJECT_WITH_FORMAT (is_throw,
        -: 3610:                                  "Cannot assign to read only property '%'",
        -: 3611:                                  ecma_make_prop_name_value (property_name_p));
        -: 3612:} /* ecma_raise_readonly_assignment */
        -: 3613:
        -: 3614:/**
        -: 3615: * @}
        -: 3616: * @}
        -: 3617: */
