        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/typedarray/ecma-builtin-typedarray-prototype.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-arraybuffer-object.h"
        -:   19:#include "ecma-bigint.h"
        -:   20:#include "ecma-builtin-helpers.h"
        -:   21:#include "ecma-builtin-typedarray-helpers.h"
        -:   22:#include "ecma-builtins.h"
        -:   23:#include "ecma-comparison.h"
        -:   24:#include "ecma-conversion.h"
        -:   25:#include "ecma-exceptions.h"
        -:   26:#include "ecma-function-object.h"
        -:   27:#include "ecma-gc.h"
        -:   28:#include "ecma-globals.h"
        -:   29:#include "ecma-helpers.h"
        -:   30:#include "ecma-iterator-object.h"
        -:   31:#include "ecma-number-object.h"
        -:   32:#include "ecma-objects.h"
        -:   33:#include "ecma-typedarray-object.h"
        -:   34:#include "jcontext.h"
        -:   35:#include "jmem.h"
        -:   36:#include "jrt-libc-includes.h"
        -:   37:#include "jrt.h"
        -:   38:#include "lit-char-helpers.h"
        -:   39:
        -:   40:#if JERRY_BUILTIN_TYPEDARRAY
        -:   41:
        -:   42:#define ECMA_BUILTINS_INTERNAL
        -:   43:#include "ecma-builtins-internal.h"
        -:   44:
        -:   45:/**
        -:   46: * This object has a custom dispatch function.
        -:   47: */
        -:   48:#define BUILTIN_CUSTOM_DISPATCH
        -:   49:
        -:   50:/**
        -:   51: * List of built-in routine identifiers.
        -:   52: */
        -:   53:enum
        -:   54:{
        -:   55:  /* These routines must be in this order */
        -:   56:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_START = 0,
        -:   57:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_MAP,
        -:   58:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE,
        -:   59:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT,
        -:   60:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY,
        -:   61:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SOME,
        -:   62:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FOR_EACH,
        -:   63:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILTER,
        -:   64:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND,
        -:   65:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND_INDEX,
        -:   66:
        -:   67:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF,
        -:   68:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_AT,
        -:   69:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LAST_INDEX_OF,
        -:   70:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INCLUDES,
        -:   71:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILL,
        -:   72:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SORT,
        -:   73:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REVERSE,
        -:   74:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_COPY_WITHIN,
        -:   75:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SLICE,
        -:   76:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY,
        -:   77:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_LOCALE_STRING,
        -:   78:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_JOIN,
        -:   79:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS,
        -:   80:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_ENTRIES,
        -:   81:
        -:   82:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER,
        -:   83:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTELENGTH_GETTER,
        -:   84:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTEOFFSET_GETTER,
        -:   85:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LENGTH_GETTER,
        -:   86:
        -:   87:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SET,
        -:   88:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER,
        -:   89:};
        -:   90:
        -:   91:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-typedarray-prototype.inc.h"
        -:   92:#define BUILTIN_UNDERSCORED_ID typedarray_prototype
        -:   93:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   94:
        -:   95:/** \addtogroup ecma ECMA
        -:   96: * @{
        -:   97: *
        -:   98: * \addtogroup ecmabuiltins
        -:   99: * @{
        -:  100: *
        -:  101: * \addtogroup typedarrayprototype ECMA %TypedArray%.prototype object built-in
        -:  102: * @{
        -:  103: */
        -:  104:
        -:  105:/**
        -:  106: * Type of routine.
        -:  107: */
        -:  108:typedef enum
        -:  109:{
        -:  110:  TYPEDARRAY_ROUTINE_EVERY, /**< routine: every ES2015, 22.2.3.7 */
        -:  111:  TYPEDARRAY_ROUTINE_SOME, /**< routine: some ES2015, 22.2.3.9 */
        -:  112:  TYPEDARRAY_ROUTINE_FOREACH, /**< routine: forEach ES2015, 15.4.4.18 */
        -:  113:  TYPEDARRAY_ROUTINE__COUNT /**< count of the modes */
        -:  114:} typedarray_routine_mode;
        -:  115:
        -:  116:/**
        -:  117: * The common function for 'every', 'some' and 'forEach'
        -:  118: * because they have a similar structure.
        -:  119: *
        -:  120: * @return ecma value
        -:  121: *         Returned value must be freed with ecma_free_value.
        -:  122: */
        -:  123:static ecma_value_t
    #####:  124:ecma_builtin_typedarray_prototype_exec_routine (ecma_value_t this_arg, /**< this argument */
        -:  125:                                                ecma_typedarray_info_t *info_p, /**< object info */
        -:  126:                                                ecma_value_t cb_func_val, /**< callback function */
        -:  127:                                                ecma_value_t cb_this_arg, /**< 'this' of the callback function */
        -:  128:                                                typedarray_routine_mode mode) /**< mode: which routine */
        -:  129:{
    #####:  130:  JERRY_ASSERT (mode < TYPEDARRAY_ROUTINE__COUNT);
        -:  131:
    #####:  132:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -:  133:
    #####:  134:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
    #####:  135:  uint32_t byte_pos = 0;
    #####:  136:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  137:
    #####:  138:  for (uint32_t index = 0; index < info_p->length && ecma_is_value_empty (ret_value); index++)
        -:  139:  {
    #####:  140:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  141:    ecma_value_t element = typedarray_getter_cb (info_p->buffer_p + byte_pos);
        -:  142:
    #####:  143:    ecma_value_t call_args[] = { element, current_index, this_arg };
        -:  144:
    #####:  145:    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  146:
    #####:  147:    ecma_fast_free_value (current_index);
    #####:  148:    ecma_fast_free_value (element);
        -:  149:
    #####:  150:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  151:    {
    #####:  152:      return call_value;
        -:  153:    }
        -:  154:
    #####:  155:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  156:    {
    #####:  157:      ecma_free_value (call_value);
    #####:  158:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  159:    }
        -:  160:
    #####:  161:    bool to_bool_result = ecma_op_to_boolean (call_value);
    #####:  162:    ecma_free_value (call_value);
        -:  163:
    #####:  164:    if (mode == TYPEDARRAY_ROUTINE_EVERY)
        -:  165:    {
    #####:  166:      if (!to_bool_result)
        -:  167:      {
    #####:  168:        return ECMA_VALUE_FALSE;
        -:  169:      }
        -:  170:    }
    #####:  171:    else if (mode == TYPEDARRAY_ROUTINE_SOME
    #####:  172:             && to_bool_result)
        -:  173:    {
    #####:  174:      return ECMA_VALUE_TRUE;
        -:  175:    }
        -:  176:
    #####:  177:    byte_pos += info_p->element_size;
        -:  178:  }
        -:  179:
    #####:  180:  if (mode == TYPEDARRAY_ROUTINE_EVERY)
        -:  181:  {
    #####:  182:    ret_value = ECMA_VALUE_TRUE;
        -:  183:  }
    #####:  184:  else if (mode == TYPEDARRAY_ROUTINE_SOME)
        -:  185:  {
    #####:  186:    ret_value = ECMA_VALUE_FALSE;
        -:  187:  }
        -:  188:  else
        -:  189:  {
    #####:  190:    ret_value = ECMA_VALUE_UNDEFINED;
        -:  191:  }
        -:  192:
    #####:  193:  return ret_value;
        -:  194:} /* ecma_builtin_typedarray_prototype_exec_routine */
        -:  195:
        -:  196:/**
        -:  197: * The %TypedArray%.prototype object's 'map' routine
        -:  198: *
        -:  199: * See also:
        -:  200: *          ES2015, 22.2.3.8
        -:  201: *
        -:  202: * @return ecma value
        -:  203: *         Returned value must be freed with ecma_free_value.
        -:  204: */
        -:  205:static ecma_value_t
    #####:  206:ecma_builtin_typedarray_prototype_map (ecma_value_t this_arg, /**< this object */
        -:  207:                                       ecma_typedarray_info_t *src_info_p, /**< object info */
        -:  208:                                       ecma_value_t cb_func_val, /**< callback function */
        -:  209:                                       ecma_value_t cb_this_arg) /**< this' of the callback function */
        -:  210:{
    #####:  211:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
        -:  212:
        -:  213:  // TODO: 22.2.3.18, 7-8.
    #####:  214:  ecma_value_t len = ecma_make_number_value (src_info_p->length);
    #####:  215:  ecma_value_t new_typedarray = ecma_typedarray_species_create (this_arg, &len, 1);
    #####:  216:  ecma_free_value (len);
        -:  217:
    #####:  218:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  219:  {
    #####:  220:    return new_typedarray;
        -:  221:  }
        -:  222:
    #####:  223:  ecma_object_t *target_obj_p = ecma_get_object_from_value (new_typedarray);
    #####:  224:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (target_obj_p);
        -:  225:
    #####:  226:  ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_info_p->id);
    #####:  227:  ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  228:
    #####:  229:  uint32_t src_byte_pos = 0;
        -:  230:
    #####:  231:  for (uint32_t index = 0; index < src_info_p->length; index++)
        -:  232:  {
    #####:  233:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  234:    ecma_value_t element = src_typedarray_getter_cb (src_info_p->buffer_p + src_byte_pos);
        -:  235:
    #####:  236:    ecma_value_t call_args[] = { element, current_index, this_arg };
    #####:  237:    ecma_value_t mapped_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  238:
    #####:  239:    ecma_free_value (current_index);
    #####:  240:    ecma_free_value (element);
        -:  241:
    #####:  242:    if (ECMA_IS_VALUE_ERROR (mapped_value))
        -:  243:    {
    #####:  244:      ecma_free_value (new_typedarray);
    #####:  245:      return mapped_value;
        -:  246:    }
        -:  247:
    #####:  248:    if (ecma_arraybuffer_is_detached (src_info_p->array_buffer_p))
        -:  249:    {
    #####:  250:      ecma_free_value (mapped_value);
    #####:  251:      ecma_free_value (new_typedarray);
    #####:  252:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  253:    }
        -:  254:
    #####:  255:    uint32_t target_byte_pos = index << target_info.shift;
    #####:  256:    ecma_value_t set_element = target_typedarray_setter_cb (target_info.buffer_p + target_byte_pos, mapped_value);
    #####:  257:    ecma_free_value (mapped_value);
        -:  258:
    #####:  259:    if (ECMA_IS_VALUE_ERROR (set_element))
        -:  260:    {
    #####:  261:      ecma_free_value (new_typedarray);
    #####:  262:      return set_element;
        -:  263:    }
        -:  264:
    #####:  265:    src_byte_pos += src_info_p->element_size;
        -:  266:  }
        -:  267:
    #####:  268:  return new_typedarray;
        -:  269:} /* ecma_builtin_typedarray_prototype_map */
        -:  270:
        -:  271:/**
        -:  272: * Reduce and reduceRight routines share a similar structure.
        -:  273: * And we use 'is_right' to distinguish between them.
        -:  274: *
        -:  275: * @return ecma value
        -:  276: *         Returned value must be freed with ecma_free_value.
        -:  277: */
        -:  278:static ecma_value_t
    #####:  279:ecma_builtin_typedarray_prototype_reduce_with_direction (ecma_value_t this_arg, /**< this object */
        -:  280:                                                         ecma_typedarray_info_t *info_p, /**< object info */
        -:  281:                                                         const ecma_value_t arguments_list_p[], /**arg_list*/
        -:  282:                                                         uint32_t arguments_number, /**< length of arguments' list*/
        -:  283:                                                         bool is_right) /**< choose order, true is reduceRight */
        -:  284:{
    #####:  285:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -:  286:  uint32_t byte_pos;
        -:  287:
    #####:  288:  if (info_p->length == 0)
        -:  289:  {
    #####:  290:    if (arguments_number < 2)
        -:  291:    {
    #####:  292:      return ecma_raise_type_error (ECMA_ERR_MSG ("Initial value cannot be undefined"));
        -:  293:    }
        -:  294:
    #####:  295:    return ecma_copy_value (arguments_list_p[1]);
        -:  296:  }
        -:  297:
    #####:  298:  JERRY_ASSERT (info_p->length > 0);
        -:  299:
    #####:  300:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
    #####:  301:  uint32_t index = is_right ? (info_p->length - 1) : 0;
        -:  302:
    #####:  303:  if (ecma_is_value_undefined (arguments_list_p[1]))
        -:  304:  {
    #####:  305:    byte_pos = index << info_p->shift;
    #####:  306:    accumulator = getter_cb (info_p->buffer_p + byte_pos);
        -:  307:
    #####:  308:    if (is_right)
        -:  309:    {
    #####:  310:      if (index == 0)
        -:  311:      {
    #####:  312:        return accumulator;
        -:  313:      }
        -:  314:
    #####:  315:      index--;
        -:  316:    }
        -:  317:    else
        -:  318:    {
    #####:  319:      index++;
        -:  320:
    #####:  321:      if (index == info_p->length)
        -:  322:      {
    #####:  323:        return accumulator;
        -:  324:      }
        -:  325:    }
        -:  326:  }
        -:  327:  else
        -:  328:  {
    #####:  329:    accumulator = ecma_copy_value (arguments_list_p[1]);
        -:  330:  }
        -:  331:
    #####:  332:  ecma_object_t *func_object_p = ecma_get_object_from_value (arguments_list_p[0]);
        -:  333:
        -:  334:  while (true)
    #####:  335:  {
    #####:  336:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  337:    byte_pos = index << info_p->shift;
    #####:  338:    ecma_value_t get_value = getter_cb (info_p->buffer_p + byte_pos);
        -:  339:
    #####:  340:    ecma_value_t call_args[] = { accumulator, get_value, current_index, this_arg };
        -:  341:
    #####:  342:    JERRY_ASSERT (ecma_is_value_number (get_value) || ecma_is_value_bigint (get_value));
        -:  343:
    #####:  344:    ecma_value_t call_value = ecma_op_function_call (func_object_p,
        -:  345:                                                     ECMA_VALUE_UNDEFINED,
        -:  346:                                                     call_args,
        -:  347:                                                     4);
        -:  348:
    #####:  349:    ecma_fast_free_value (accumulator);
    #####:  350:    ecma_fast_free_value (get_value);
    #####:  351:    ecma_fast_free_value (current_index);
        -:  352:
    #####:  353:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  354:    {
    #####:  355:      return call_value;
        -:  356:    }
        -:  357:
    #####:  358:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  359:    {
    #####:  360:      ecma_free_value (call_value);
    #####:  361:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  362:    }
        -:  363:
    #####:  364:    accumulator = call_value;
        -:  365:
    #####:  366:    if (is_right)
        -:  367:    {
    #####:  368:      if (index == 0)
        -:  369:      {
    #####:  370:        break;
        -:  371:      }
        -:  372:
    #####:  373:      index--;
        -:  374:    }
        -:  375:    else
        -:  376:    {
    #####:  377:      index++;
        -:  378:
    #####:  379:      if (index == info_p->length)
        -:  380:      {
    #####:  381:        break;
        -:  382:      }
        -:  383:    }
        -:  384:  }
        -:  385:
    #####:  386:  return accumulator;
        -:  387:} /* ecma_builtin_typedarray_prototype_reduce_with_direction */
        -:  388:
        -:  389:/**
        -:  390: * The %TypedArray%.prototype object's 'filter' routine
        -:  391: *
        -:  392: * See also:
        -:  393: *          ES2015, 22.2.3.9
        -:  394: *
        -:  395: * @return ecma value
        -:  396: *         Returned value must be freed with ecma_free_value.
        -:  397: */
        -:  398:static ecma_value_t
    #####:  399:ecma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, /**< this object */
        -:  400:                                          ecma_typedarray_info_t *info_p, /**< object info */
        -:  401:                                          ecma_value_t cb_func_val, /**< callback function */
        -:  402:                                          ecma_value_t cb_this_arg) /**< 'this' of the callback function */
        -:  403:{
    #####:  404:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -:  405:
    #####:  406:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
    #####:  407:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  408:
        -:  409:  // TODO: 22.2.3.9, 7-8.
    #####:  410:  if (info_p->length == 0)
        -:  411:  {
    #####:  412:    return ecma_op_create_typedarray_with_type_and_length (info_p->id, 0);
        -:  413:  }
        -:  414:
    #####:  415:  JMEM_DEFINE_LOCAL_ARRAY (pass_value_list_p, info_p->length * info_p->element_size, lit_utf8_byte_t);
        -:  416:
    #####:  417:  lit_utf8_byte_t *pass_value_p = pass_value_list_p;
    #####:  418:  uint32_t byte_pos = 0;
        -:  419:
    #####:  420:  for (uint32_t index = 0; index < info_p->length; index++)
        -:  421:  {
    #####:  422:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  423:    ecma_value_t get_value = getter_cb (info_p->buffer_p + byte_pos);
        -:  424:
    #####:  425:    JERRY_ASSERT (ecma_is_value_number (get_value) || ecma_is_value_bigint (get_value));
        -:  426:
    #####:  427:    ecma_value_t call_args[] = { get_value, current_index, this_arg };
        -:  428:
    #####:  429:    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  430:
    #####:  431:    ecma_fast_free_value (current_index);
    #####:  432:    ecma_fast_free_value (get_value);
        -:  433:
    #####:  434:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  435:    {
    #####:  436:      goto cleanup;
        -:  437:    }
        -:  438:
    #####:  439:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  440:    {
    #####:  441:      ecma_free_value (call_value);
    #####:  442:      ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
    #####:  443:      goto cleanup;
        -:  444:    }
        -:  445:
    #####:  446:    if (ecma_op_to_boolean (call_value))
        -:  447:    {
    #####:  448:      memcpy (pass_value_p, info_p->buffer_p + byte_pos, info_p->element_size);
    #####:  449:      pass_value_p += info_p->element_size;
        -:  450:    }
        -:  451:
    #####:  452:    byte_pos += info_p->element_size;
        -:  453:
    #####:  454:    ecma_free_value (call_value);
        -:  455:  }
        -:  456:
    #####:  457:  uint32_t pass_num = (uint32_t) ((pass_value_p - pass_value_list_p) >> info_p->shift);
        -:  458:
    #####:  459:  ecma_value_t collected = ecma_make_number_value (pass_num);
    #####:  460:  ret_value = ecma_typedarray_species_create (this_arg, &collected, 1);
    #####:  461:  ecma_free_value (collected);
        -:  462:
    #####:  463:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -:  464:  {
    #####:  465:    ecma_object_t *obj_p = ecma_get_object_from_value (ret_value);
        -:  466:
    #####:  467:    JERRY_ASSERT (ecma_typedarray_get_offset (obj_p) == 0);
        -:  468:
    #####:  469:    memcpy (ecma_typedarray_get_buffer (obj_p),
        -:  470:            pass_value_list_p,
    #####:  471:            (size_t) (pass_value_p - pass_value_list_p));
        -:  472:  }
        -:  473:
    #####:  474:cleanup:
    #####:  475:  JMEM_FINALIZE_LOCAL_ARRAY (pass_value_list_p);
        -:  476:
    #####:  477:  return ret_value;
        -:  478:} /* ecma_builtin_typedarray_prototype_filter */
        -:  479:
        -:  480:/**
        -:  481: * The %TypedArray%.prototype object's 'reverse' routine
        -:  482: *
        -:  483: * See also:
        -:  484: *          ES2015, 22.2.3.21
        -:  485: *
        -:  486: * @return ecma value
        -:  487: *         Returned value must be freed with ecma_free_value.
        -:  488: */
        -:  489:static ecma_value_t
    #####:  490:ecma_builtin_typedarray_prototype_reverse (ecma_value_t this_arg, /**< this argument */
        -:  491:                                           ecma_typedarray_info_t *info_p) /**< object info */
        -:  492:{
    #####:  493:  uint32_t middle = (info_p->length / 2) << info_p->shift;
    #####:  494:  uint32_t buffer_last = (info_p->length << info_p->shift) - info_p->element_size;
        -:  495:
    #####:  496:  for (uint32_t lower = 0; lower < middle; lower += info_p->element_size)
        -:  497:  {
    #####:  498:    uint32_t upper = buffer_last - lower;
    #####:  499:    lit_utf8_byte_t *lower_p = info_p->buffer_p + lower;
    #####:  500:    lit_utf8_byte_t *upper_p = info_p->buffer_p + upper;
        -:  501:
    #####:  502:    lit_utf8_byte_t tmp[8];
    #####:  503:    memcpy (&tmp[0], lower_p, info_p->element_size);
    #####:  504:    memcpy (lower_p, upper_p, info_p->element_size);
    #####:  505:    memcpy (upper_p, &tmp[0], info_p->element_size);
        -:  506:  }
        -:  507:
    #####:  508:  return ecma_copy_value (this_arg);
        -:  509:} /* ecma_builtin_typedarray_prototype_reverse */
        -:  510:
        -:  511:/**
        -:  512: * The %TypedArray%.prototype object's 'set' routine for a typedArray source
        -:  513: *
        -:  514: * See also:
        -:  515: *          ES2015, 22.2.3.22, 22.2.3.22.2
        -:  516: *
        -:  517: * @return ecma value of undefined if success, error otherwise.
        -:  518: *         Returned value must be freed with ecma_free_value.
        -:  519: */
        -:  520:static ecma_value_t
    #####:  521:ecma_op_typedarray_set_with_typedarray (ecma_value_t this_arg, /**< this argument */
        -:  522:                                        ecma_value_t arr_val, /**< typedarray object */
        -:  523:                                        ecma_value_t offset_val) /**< offset value */
        -:  524:{
        -:  525:  /* 6.~ 8. targetOffset */
    #####:  526:  ecma_number_t target_offset_num;
    #####:  527:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (offset_val, &target_offset_num)))
        -:  528:  {
    #####:  529:    return ECMA_VALUE_ERROR;
        -:  530:  }
        -:  531:
    #####:  532:  if (target_offset_num <= -1.0 || target_offset_num >= (ecma_number_t) UINT32_MAX + 0.5)
        -:  533:  {
    #####:  534:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset"));
        -:  535:  }
        -:  536:
    #####:  537:  ecma_object_t *target_typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  538:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (target_typedarray_p);
    #####:  539:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  540:  {
    #####:  541:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  542:  }
        -:  543:
    #####:  544:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (target_typedarray_p);
        -:  545:
    #####:  546:  ecma_object_t *src_typedarray_p = ecma_get_object_from_value (arr_val);
    #####:  547:  ecma_object_t *src_arraybuffer_p = ecma_typedarray_get_arraybuffer (src_typedarray_p);
    #####:  548:  if (ecma_arraybuffer_is_detached (src_arraybuffer_p))
        -:  549:  {
    #####:  550:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  551:  }
        -:  552:
    #####:  553:  ecma_typedarray_info_t src_info = ecma_typedarray_get_info (src_typedarray_p);
        -:  554:
    #####:  555:  uint32_t target_offset_uint32 = ecma_number_to_uint32 (target_offset_num);
        -:  556:
    #####:  557:  if ((int64_t) src_info.length + target_offset_uint32 > target_info.length)
        -:  558:  {
    #####:  559:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid range of index"));
        -:  560:  }
        -:  561:
        -:  562:  /* Fast path first. If the source and target arrays are the same we do not need to copy anything. */
    #####:  563:  if (this_arg == arr_val)
        -:  564:  {
    #####:  565:    return ECMA_VALUE_UNDEFINED;
        -:  566:  }
        -:  567:
        -:  568:  /* 26. targetByteIndex */
    #####:  569:  uint32_t target_byte_index = target_offset_uint32 * target_info.element_size;
        -:  570:
        -:  571:  /* 27. limit */
    #####:  572:  uint32_t limit = target_byte_index + target_info.element_size * src_info.length;
        -:  573:
    #####:  574:  if (src_info.id == target_info.id)
        -:  575:  {
    #####:  576:    memmove (target_info.buffer_p + target_byte_index, src_info.buffer_p,
    #####:  577:             target_info.element_size * src_info.length);
        -:  578:  }
        -:  579:  else
        -:  580:  {
    #####:  581:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_info.id);
    #####:  582:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  583:
    #####:  584:    uint32_t src_byte_index = 0;
    #####:  585:    while (target_byte_index < limit)
        -:  586:    {
    #####:  587:      ecma_value_t element = src_typedarray_getter_cb (src_info.buffer_p + src_byte_index);
    #####:  588:      ecma_value_t set_element = target_typedarray_setter_cb (target_info.buffer_p + target_byte_index, element);
    #####:  589:      ecma_free_value (element);
        -:  590:
    #####:  591:      if (ECMA_IS_VALUE_ERROR (set_element))
        -:  592:      {
    #####:  593:        return set_element;
        -:  594:      }
        -:  595:
    #####:  596:      src_byte_index += src_info.element_size;
    #####:  597:      target_byte_index += target_info.element_size;
        -:  598:    }
        -:  599:  }
        -:  600:
    #####:  601:  return ECMA_VALUE_UNDEFINED;
        -:  602:} /* ecma_op_typedarray_set_with_typedarray */
        -:  603:
        -:  604:/**
        -:  605: * The %TypedArray%.prototype object's 'set' routine
        -:  606: *
        -:  607: * See also:
        -:  608: *          ES2015, 22.2.3.22, 22.2.3.22.1
        -:  609: *
        -:  610: * @return ecma value of undefined if success, error otherwise.
        -:  611: *         Returned value must be freed with ecma_free_value.
        -:  612: */
        -:  613:static ecma_value_t
    #####:  614:ecma_builtin_typedarray_prototype_set (ecma_value_t this_arg, /**< this argument */
        -:  615:                                       ecma_value_t arr_val, /**< array object */
        -:  616:                                       ecma_value_t offset_val) /**< offset value */
        -:  617:{
        -:  618:  /* 1. */
    #####:  619:  if (ecma_is_typedarray (arr_val))
        -:  620:  {
        -:  621:    /* 22.2.3.22.2 */
    #####:  622:    return ecma_op_typedarray_set_with_typedarray (this_arg, arr_val, offset_val);
        -:  623:  }
        -:  624:
        -:  625:  /* 6.~ 8. targetOffset */
    #####:  626:  ecma_number_t target_offset_num;
        -:  627:
    #####:  628:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (offset_val, &target_offset_num)))
        -:  629:  {
    #####:  630:    return ECMA_VALUE_ERROR;
        -:  631:  }
        -:  632:
    #####:  633:  if (target_offset_num <= -1.0 || target_offset_num >= (ecma_number_t) UINT32_MAX + 0.5)
        -:  634:  {
    #####:  635:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid offset"));
        -:  636:  }
    #####:  637:  uint32_t target_offset_uint32 = ecma_number_to_uint32 (target_offset_num);
        -:  638:
        -:  639:  /* 11. ~ 15. */
    #####:  640:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  641:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####:  642:  if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  643:  {
    #####:  644:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  645:  }
        -:  646:
    #####:  647:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (typedarray_p);
        -:  648:
        -:  649:  /* 16.~ 17. */
    #####:  650:  ecma_value_t source_obj = ecma_op_to_object (arr_val);
        -:  651:
    #####:  652:  if (ECMA_IS_VALUE_ERROR (source_obj))
        -:  653:  {
    #####:  654:    return source_obj;
        -:  655:  }
        -:  656:
        -:  657:  /* 18.~ 19. */
    #####:  658:  ecma_object_t *source_obj_p = ecma_get_object_from_value (source_obj);
        -:  659:
    #####:  660:  ecma_length_t source_length;
        -:  661:
    #####:  662:  if (ECMA_IS_VALUE_ERROR (ecma_op_object_get_length (source_obj_p, &source_length)))
        -:  663:  {
    #####:  664:    ecma_deref_object (source_obj_p);
    #####:  665:    return ECMA_VALUE_ERROR;
        -:  666:  }
        -:  667:
        -:  668:  /* 20. if srcLength + targetOffset > targetLength, throw a RangeError */
    #####:  669:  if ((int64_t) source_length + target_offset_uint32 > target_info.length)
        -:  670:  {
    #####:  671:    ecma_deref_object (source_obj_p);
    #####:  672:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid range of index"));
        -:  673:  }
    #####:  674:  JERRY_ASSERT (source_length <= UINT32_MAX);
    #####:  675:  uint32_t source_length_uint32 = (uint32_t) source_length;
        -:  676:
        -:  677:  /* 21.~ 25. */
    #####:  678:  uint32_t target_byte_index = target_offset_uint32 * target_info.element_size;
    #####:  679:  uint32_t k = 0;
        -:  680:
    #####:  681:  ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  682:
    #####:  683:  while (k < source_length_uint32)
        -:  684:  {
    #####:  685:    ecma_value_t elem = ecma_op_object_get_by_index (source_obj_p, k);
        -:  686:
    #####:  687:    if (ECMA_IS_VALUE_ERROR (elem))
        -:  688:    {
    #####:  689:      ecma_deref_object (source_obj_p);
    #####:  690:      return elem;
        -:  691:    }
        -:  692:
        -:  693:    ecma_value_t value_to_set;
        -:  694:
        -:  695:#if JERRY_BUILTIN_BIGINT
    #####:  696:    if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (target_info.id))
        -:  697:    {
    #####:  698:      value_to_set = ecma_bigint_to_bigint (elem, false);
        -:  699:
    #####:  700:      if (ECMA_IS_VALUE_ERROR (value_to_set))
        -:  701:      {
    #####:  702:        ecma_deref_object (source_obj_p);
    #####:  703:        ecma_free_value (elem);
    #####:  704:        return value_to_set;
        -:  705:      }
        -:  706:    }
        -:  707:    else
        -:  708:#endif /* JERRY_BUILTIN_BIGINT */
        -:  709:    {
    #####:  710:      ecma_number_t elem_num;
    #####:  711:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_numeric (elem, &elem_num, ECMA_TO_NUMERIC_NO_OPTS)))
        -:  712:      {
    #####:  713:        ecma_free_value (elem);
    #####:  714:        ecma_deref_object (source_obj_p);
    #####:  715:        return ECMA_VALUE_ERROR;
        -:  716:      }
        -:  717:
    #####:  718:      value_to_set = ecma_make_number_value (elem_num);
        -:  719:    }
        -:  720:
    #####:  721:    ecma_free_value (elem);
        -:  722:
    #####:  723:    if (ecma_arraybuffer_is_detached (arraybuffer_p))
        -:  724:    {
    #####:  725:      ecma_deref_object (source_obj_p);
    #####:  726:      ecma_free_value (value_to_set);
    #####:  727:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  728:    }
        -:  729:
    #####:  730:    ecma_value_t set_element = target_typedarray_setter_cb (target_info.buffer_p + target_byte_index, value_to_set);
        -:  731:
    #####:  732:    ecma_free_value (value_to_set);
        -:  733:
    #####:  734:    if (ECMA_IS_VALUE_ERROR (set_element))
        -:  735:    {
    #####:  736:      ecma_deref_object (source_obj_p);
    #####:  737:      return set_element;
        -:  738:    }
        -:  739:
    #####:  740:    k++;
    #####:  741:    target_byte_index += target_info.element_size;
        -:  742:  }
        -:  743:
    #####:  744:  ecma_deref_object (source_obj_p);
        -:  745:
    #####:  746:  return ECMA_VALUE_UNDEFINED;
        -:  747:} /* ecma_builtin_typedarray_prototype_set */
        -:  748:
        -:  749:/**
        -:  750: * TypedArray.prototype's 'toString' single element operation routine based
        -:  751: * on the Array.prototype's 'toString' single element operation routine
        -:  752: *
        -:  753: * See also:
        -:  754: *          ECMA-262 v5.1, 15.4.4.2
        -:  755: *
        -:  756: * @return NULL - if the converison fails
        -:  757: *         ecma_string_t * - otherwise
        -:  758: */
        -:  759:static ecma_string_t *
    #####:  760:ecma_op_typedarray_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  761:                                           uint32_t index) /**< array index */
        -:  762:{
    #####:  763:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  764:
    #####:  765:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  766:  {
    #####:  767:    return NULL;
        -:  768:  }
        -:  769:
    #####:  770:  if (ecma_is_value_undefined (index_value)
    #####:  771:      || ecma_is_value_null (index_value))
        -:  772:  {
    #####:  773:    ecma_free_value (index_value);
    #####:  774:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  775:  }
        -:  776:
    #####:  777:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -:  778:
    #####:  779:  ecma_free_value (index_value);
        -:  780:
    #####:  781:  return ret_str_p;
        -:  782:} /* ecma_op_typedarray_get_to_string_at_index */
        -:  783:
        -:  784:/**
        -:  785: * The TypedArray.prototype.toString's separator creation routine based on
        -:  786: * the Array.prototype.toString's separator routine
        -:  787: *
        -:  788: * See also:
        -:  789: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -:  790: *
        -:  791: * @return NULL - if the conversion fails
        -:  792: *         ecma_string_t * - otherwise
        -:  793: */
        -:  794:static ecma_string_t *
    #####:  795:ecma_op_typedarray_get_separator_string (ecma_value_t separator) /**< possible separator */
        -:  796:{
    #####:  797:  if (ecma_is_value_undefined (separator))
        -:  798:  {
    #####:  799:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -:  800:  }
        -:  801:
    #####:  802:  return ecma_op_to_string (separator);
        -:  803:} /* ecma_op_typedarray_get_separator_string */
        -:  804:
        -:  805:/**
        -:  806: * The TypedArray.prototype object's 'join' routine basen on
        -:  807: * the Array.porottype object's 'join'
        -:  808: *
        -:  809: * See also:
        -:  810: *          ECMA-262 v5, 15.4.4.5
        -:  811: *
        -:  812: * @return ecma value
        -:  813: *         Returned value must be freed with ecma_free_value.
        -:  814: */
        -:  815:static ecma_value_t
    #####:  816:ecma_builtin_typedarray_prototype_join (ecma_object_t *obj_p, /**< this object */
        -:  817:                                        ecma_value_t separator_arg) /**< separator argument */
        -:  818:{
        -:  819:  /* 2. */
    #####:  820:  uint32_t length = ecma_typedarray_get_length (obj_p);
    #####:  821:  ecma_string_t *separator_string_p = ecma_op_typedarray_get_separator_string (separator_arg);
        -:  822:
    #####:  823:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  824:  if (JERRY_UNLIKELY (separator_string_p == NULL))
        -:  825:  {
    #####:  826:    return ret_value;
        -:  827:  }
        -:  828:
        -:  829:  /* 7-8. */
    #####:  830:  ecma_string_t *first_string_p = ecma_op_typedarray_get_to_string_at_index (obj_p, 0);
        -:  831:
    #####:  832:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  833:  {
    #####:  834:    ecma_deref_ecma_string (separator_string_p);
    #####:  835:    return ret_value;
        -:  836:  }
        -:  837:
    #####:  838:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
        -:  839:
    #####:  840:  ecma_deref_ecma_string (first_string_p);
        -:  841:
        -:  842:  /* 9-10. */
    #####:  843:  for (uint32_t k = 1; k < length; k++)
        -:  844:  {
        -:  845:    /* 10.a */
    #####:  846:    ecma_stringbuilder_append (&builder, separator_string_p);
        -:  847:
        -:  848:    /* 10.d */
    #####:  849:    ecma_string_t *next_string_p = ecma_op_typedarray_get_to_string_at_index (obj_p, k);
        -:  850:
    #####:  851:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  852:    {
    #####:  853:      ecma_stringbuilder_destroy (&builder);
    #####:  854:      ecma_deref_ecma_string (separator_string_p);
    #####:  855:      return ret_value;
        -:  856:    }
        -:  857:
    #####:  858:    ecma_stringbuilder_append (&builder, next_string_p);
        -:  859:
    #####:  860:    ecma_deref_ecma_string (next_string_p);
        -:  861:  }
        -:  862:
    #####:  863:  ecma_deref_ecma_string (separator_string_p);
    #####:  864:  ret_value = ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  865:
    #####:  866:  return ret_value;
        -:  867:} /* ecma_builtin_typedarray_prototype_join */
        -:  868:
        -:  869:/**
        -:  870: * The %TypedArray%.prototype object's 'subarray' routine.
        -:  871: *
        -:  872: * See also:
        -:  873: *          ES2015, 22.2.3.26
        -:  874: *
        -:  875: * @return ecma value
        -:  876: *         Returned value must be freed with ecma_free_value.
        -:  877: */
        -:  878:static ecma_value_t
    #####:  879:ecma_builtin_typedarray_prototype_subarray (ecma_value_t this_arg, /**< this object */
        -:  880:                                            ecma_typedarray_info_t *info_p, /**< object info */
        -:  881:                                            ecma_value_t begin, /**< begin */
        -:  882:                                            ecma_value_t end) /**< end */
        -:  883:{
    #####:  884:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  885:
        -:  886:  /* 9. beginIndex, 12. endIndex */
    #####:  887:  uint32_t begin_index_uint32 = 0, end_index_uint32 = 0;
        -:  888:
        -:  889:  /* 7. relativeBegin */
    #####:  890:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (begin,
        -:  891:                                                                       info_p->length,
        -:  892:                                                                       &begin_index_uint32)))
        -:  893:  {
    #####:  894:    return ECMA_VALUE_ERROR;
        -:  895:  }
        -:  896:
    #####:  897:  if (ecma_is_value_undefined (end))
        -:  898:  {
    #####:  899:    end_index_uint32 = (uint32_t) info_p->length;
        -:  900:  }
        -:  901:  else
        -:  902:  {
        -:  903:    /* 10. relativeEnd */
    #####:  904:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (end,
        -:  905:                                                                         info_p->length,
        -:  906:                                                                         &end_index_uint32)))
        -:  907:    {
    #####:  908:      return ECMA_VALUE_ERROR;
        -:  909:    }
        -:  910:  }
        -:  911:
        -:  912:  /* 13. newLength */
    #####:  913:  uint32_t subarray_length = 0;
        -:  914:
    #####:  915:  if (end_index_uint32 > begin_index_uint32)
        -:  916:  {
    #####:  917:    subarray_length = end_index_uint32 - begin_index_uint32;
        -:  918:  }
        -:  919:
        -:  920:  /* 17. beginByteOffset */
    #####:  921:  uint32_t begin_byte_offset = info_p->offset + begin_index_uint32 * info_p->element_size;
        -:  922:
    #####:  923:  ecma_value_t arguments_p[3] =
        -:  924:  {
    #####:  925:    ecma_make_object_value (info_p->array_buffer_p),
    #####:  926:    ecma_make_uint32_value (begin_byte_offset),
    #####:  927:    ecma_make_uint32_value (subarray_length)
        -:  928:  };
        -:  929:
    #####:  930:  ret_value = ecma_typedarray_species_create (this_arg, arguments_p, 3);
        -:  931:
    #####:  932:  ecma_free_value (arguments_p[1]);
    #####:  933:  ecma_free_value (arguments_p[2]);
    #####:  934:  return ret_value;
        -:  935:} /* ecma_builtin_typedarray_prototype_subarray */
        -:  936:
        -:  937:/**
        -:  938: * The %TypedArray%.prototype object's 'fill' routine.
        -:  939: *
        -:  940: * See also:
        -:  941: *          ES2015, 22.2.3.8, 22.1.3.6
        -:  942: *
        -:  943: * @return ecma value
        -:  944: *         Returned value must be freed with ecma_free_value.
        -:  945: */
        -:  946:static ecma_value_t
    #####:  947:ecma_builtin_typedarray_prototype_fill (ecma_value_t this_arg, /**< this object */
        -:  948:                                        ecma_typedarray_info_t *info_p, /**< object info */
        -:  949:                                        ecma_value_t value, /**< value */
        -:  950:                                        ecma_value_t begin, /**< begin */
        -:  951:                                        ecma_value_t end) /**< end */
        -:  952:{
        -:  953:  ecma_value_t value_to_set;
        -:  954:
        -:  955:#if JERRY_BUILTIN_BIGINT
    #####:  956:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id))
        -:  957:  {
    #####:  958:    value_to_set = ecma_bigint_to_bigint (value, true);
        -:  959:
    #####:  960:    if (ECMA_IS_VALUE_ERROR (value_to_set))
        -:  961:    {
    #####:  962:      return value_to_set;
        -:  963:    }
        -:  964:  }
        -:  965:  else
        -:  966:#endif /* JERRY_BUILTIN_BIGINT */
        -:  967:  {
    #####:  968:    ecma_number_t value_num;
    #####:  969:    ecma_value_t ret_value = ecma_op_to_numeric (value, &value_num, ECMA_TO_NUMERIC_NO_OPTS);
        -:  970:
    #####:  971:    if (!ecma_is_value_empty (ret_value))
        -:  972:    {
    #####:  973:      return ret_value;
        -:  974:    }
        -:  975:
    #####:  976:    value_to_set = ecma_make_number_value (value_num);
        -:  977:  }
        -:  978:
    #####:  979:  uint32_t begin_index_uint32 = 0, end_index_uint32 = 0;
        -:  980:
    #####:  981:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (begin,
        -:  982:                                                                       info_p->length,
        -:  983:                                                                       &begin_index_uint32)))
        -:  984:  {
    #####:  985:    ecma_free_value (value_to_set);
    #####:  986:    return ECMA_VALUE_ERROR;
        -:  987:  }
        -:  988:
    #####:  989:  if (ecma_is_value_undefined (end))
        -:  990:  {
    #####:  991:    end_index_uint32 = (uint32_t) info_p->length;
        -:  992:  }
        -:  993:  else
        -:  994:  {
    #####:  995:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (end,
        -:  996:                                                                         info_p->length,
        -:  997:                                                                         &end_index_uint32)))
        -:  998:    {
    #####:  999:      ecma_free_value (value_to_set);
    #####: 1000:      return ECMA_VALUE_ERROR;
        -: 1001:    }
        -: 1002:  }
        -: 1003:
    #####: 1004:  uint32_t subarray_length = 0;
        -: 1005:
    #####: 1006:  if (end_index_uint32 > begin_index_uint32)
        -: 1007:  {
    #####: 1008:    subarray_length = end_index_uint32 - begin_index_uint32;
        -: 1009:  }
        -: 1010:
    #####: 1011:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info_p->id);
    #####: 1012:  uint32_t byte_index = begin_index_uint32 * info_p->element_size;
    #####: 1013:  uint32_t limit = byte_index + subarray_length * info_p->element_size;
        -: 1014:
    #####: 1015:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1016:  {
    #####: 1017:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1018:  }
        -: 1019:
    #####: 1020:  while (byte_index < limit)
        -: 1021:  {
    #####: 1022:    ecma_value_t set_element = typedarray_setter_cb (info_p->buffer_p + byte_index, value_to_set);
        -: 1023:
    #####: 1024:    if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1025:    {
    #####: 1026:      ecma_free_value (value_to_set);
    #####: 1027:      return set_element;
        -: 1028:    }
        -: 1029:
    #####: 1030:    byte_index += info_p->element_size;
        -: 1031:  }
        -: 1032:
    #####: 1033:  ecma_free_value (value_to_set);
        -: 1034:
    #####: 1035:  return ecma_copy_value (this_arg);
        -: 1036:} /* ecma_builtin_typedarray_prototype_fill */
        -: 1037:
        -: 1038:/**
        -: 1039: * SortCompare abstract method
        -: 1040: *
        -: 1041: * See also:
        -: 1042: *          ECMA-262 v5, 15.4.4.11
        -: 1043: *
        -: 1044: * @return ecma value
        -: 1045: *         Returned value must be freed with ecma_free_value.
        -: 1046: */
        -: 1047:static ecma_value_t
    #####: 1048:ecma_builtin_typedarray_prototype_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -: 1049:                                                       ecma_value_t rhs, /**< right value */
        -: 1050:                                                       ecma_value_t compare_func, /**< compare function */
        -: 1051:                                                       ecma_object_t *array_buffer_p) /**< array buffer */
        -: 1052:{
    #####: 1053:  if (ecma_is_value_undefined (compare_func))
        -: 1054:  {
        -: 1055:    /* Default comparison when no comparefn is passed. */
        -: 1056:#if JERRY_BUILTIN_BIGINT
    #####: 1057:    if (ecma_is_value_bigint (lhs) && ecma_is_value_bigint (rhs))
        -: 1058:    {
    #####: 1059:      return ecma_make_number_value (ecma_bigint_compare_to_bigint (lhs, rhs));
        -: 1060:    }
        -: 1061:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1062:
    #####: 1063:    ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1064:
    #####: 1065:    double lhs_value = (double) ecma_get_number_from_value (lhs);
    #####: 1066:    double rhs_value = (double) ecma_get_number_from_value (rhs);
        -: 1067:
    #####: 1068:    if (ecma_number_is_nan (lhs_value))
        -: 1069:    {
        -: 1070:      // Keep NaNs at the end of the array.
    #####: 1071:      result = ECMA_NUMBER_ONE;
        -: 1072:    }
    #####: 1073:    else if (ecma_number_is_nan (rhs_value))
        -: 1074:    {
        -: 1075:      // Keep NaNs at the end of the array.
    #####: 1076:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1077:    }
    #####: 1078:    else if (lhs_value < rhs_value)
        -: 1079:    {
    #####: 1080:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1081:    }
    #####: 1082:    else if (lhs_value > rhs_value || (ecma_number_is_zero (rhs_value) && ecma_number_is_negative (rhs_value)))
        -: 1083:    {
    #####: 1084:      result = ECMA_NUMBER_ONE;
        -: 1085:    }
        -: 1086:    else
        -: 1087:    {
    #####: 1088:      result = ECMA_NUMBER_ZERO;
        -: 1089:    }
        -: 1090:
    #####: 1091:    return ecma_make_number_value (result);
        -: 1092:  }
        -: 1093:
        -: 1094:  /*
        -: 1095:   * compare_func, if not undefined, will always contain a callable function object.
        -: 1096:   * We checked this previously, before this function was called.
        -: 1097:   */
    #####: 1098:  JERRY_ASSERT (ecma_op_is_callable (compare_func));
    #####: 1099:  ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1100:
    #####: 1101:  ecma_value_t compare_args[] = { lhs, rhs };
        -: 1102:
    #####: 1103:  ecma_value_t call_value = ecma_op_function_call (comparefn_obj_p,
        -: 1104:                                                   ECMA_VALUE_UNDEFINED,
        -: 1105:                                                   compare_args,
        -: 1106:                                                   2);
        -: 1107:
    #####: 1108:  if (ECMA_IS_VALUE_ERROR (call_value) || ecma_is_value_number (call_value))
        -: 1109:  {
    #####: 1110:    return call_value;
        -: 1111:  }
        -: 1112:
    #####: 1113:  ecma_number_t ret_num;
    #####: 1114:  ecma_value_t number_result = ecma_op_to_number (call_value, &ret_num);
        -: 1115:
    #####: 1116:  ecma_free_value (call_value);
        -: 1117:
    #####: 1118:  if (ECMA_IS_VALUE_ERROR (number_result))
        -: 1119:  {
    #####: 1120:    return number_result;
        -: 1121:  }
        -: 1122:
    #####: 1123:  if (ecma_arraybuffer_is_detached (array_buffer_p))
        -: 1124:  {
    #####: 1125:    ecma_free_value (number_result);
    #####: 1126:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1127:  }
        -: 1128:
        -: 1129:  // If the coerced value can't be represented as a Number, compare them as equals.
    #####: 1130:  if (ecma_number_is_nan (ret_num))
        -: 1131:  {
    #####: 1132:    return ecma_make_number_value (ECMA_NUMBER_ZERO);
        -: 1133:  }
        -: 1134:
    #####: 1135:  return ecma_make_number_value (ret_num);
        -: 1136:} /* ecma_builtin_typedarray_prototype_sort_compare_helper */
        -: 1137:
        -: 1138:/**
        -: 1139: * The %TypedArray%.prototype object's 'sort' routine.
        -: 1140: *
        -: 1141: * See also:
        -: 1142: *          ES2015, 22.2.3.25, 22.1.3.24
        -: 1143: *
        -: 1144: * @return ecma value
        -: 1145: *         Returned value must be freed with ecma_free_value.
        -: 1146: */
        -: 1147:static ecma_value_t
    #####: 1148:ecma_builtin_typedarray_prototype_sort (ecma_value_t this_arg, /**< this argument */
        -: 1149:                                        ecma_typedarray_info_t *info_p, /**< object info */
        -: 1150:                                        ecma_value_t compare_func) /**< comparator fn */
        -: 1151:{
    #####: 1152:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
    #####: 1153:  JERRY_ASSERT (ecma_is_value_undefined (compare_func) || ecma_op_is_callable (compare_func));
        -: 1154:
    #####: 1155:  if (!info_p->length)
        -: 1156:  {
    #####: 1157:    return ecma_copy_value (this_arg);
        -: 1158:  }
        -: 1159:
    #####: 1160:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####: 1161:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, info_p->length, ecma_value_t);
        -: 1162:
    #####: 1163:  uint32_t byte_index = 0, buffer_index = 0;
    #####: 1164:  uint32_t limit = info_p->length * info_p->element_size;
        -: 1165:
    #####: 1166:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -: 1167:  /* Copy unsorted array into a native c array. */
    #####: 1168:  while (byte_index < limit)
        -: 1169:  {
    #####: 1170:    JERRY_ASSERT (buffer_index < info_p->length);
    #####: 1171:    ecma_value_t element_value = typedarray_getter_cb (info_p->buffer_p + byte_index);
    #####: 1172:    values_buffer[buffer_index++] = element_value;
    #####: 1173:    byte_index += info_p->element_size;
        -: 1174:  }
        -: 1175:
    #####: 1176:  JERRY_ASSERT (buffer_index == info_p->length);
        -: 1177:
    #####: 1178:  const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_typedarray_prototype_sort_compare_helper;
        -: 1179:
    #####: 1180:  ecma_value_t sort_value = ecma_builtin_helper_array_merge_sort_helper (values_buffer,
    #####: 1181:                                                                         (uint32_t) (info_p->length),
        -: 1182:                                                                         compare_func,
        -: 1183:                                                                         sort_cb,
        -: 1184:                                                                         info_p->array_buffer_p);
        -: 1185:
    #####: 1186:  if (ECMA_IS_VALUE_ERROR (sort_value))
        -: 1187:  {
    #####: 1188:    ret_value = sort_value;
    #####: 1189:    goto free_values;
        -: 1190:  }
        -: 1191:
    #####: 1192:  JERRY_ASSERT (sort_value == ECMA_VALUE_EMPTY);
        -: 1193:
    #####: 1194:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1195:  {
    #####: 1196:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1197:  }
        -: 1198:
    #####: 1199:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info_p->id);
        -: 1200:
    #####: 1201:  byte_index = 0;
    #####: 1202:  buffer_index = 0;
    #####: 1203:  limit = info_p->length * info_p->element_size;
        -: 1204:  /* Put sorted values from the native array back into the typedarray buffer. */
    #####: 1205:  while (byte_index < limit)
        -: 1206:  {
    #####: 1207:    JERRY_ASSERT (buffer_index < info_p->length);
    #####: 1208:    ecma_value_t element_value = values_buffer[buffer_index++];
    #####: 1209:    ecma_value_t set_element = typedarray_setter_cb (info_p->buffer_p + byte_index, element_value);
        -: 1210:
    #####: 1211:    if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1212:    {
    #####: 1213:      ret_value = set_element;
    #####: 1214:      goto free_values;
        -: 1215:    }
        -: 1216:
    #####: 1217:    byte_index += info_p->element_size;
        -: 1218:  }
        -: 1219:
    #####: 1220:  JERRY_ASSERT (buffer_index == info_p->length);
        -: 1221:
    #####: 1222:  ret_value = ecma_copy_value (this_arg);
        -: 1223:
    #####: 1224:free_values:
        -: 1225:  /* Free values that were copied to the local array. */
    #####: 1226:  for (uint32_t index = 0; index < info_p->length; index++)
        -: 1227:  {
    #####: 1228:    ecma_free_value (values_buffer[index]);
        -: 1229:  }
        -: 1230:
    #####: 1231:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1232:
    #####: 1233:  return ret_value;
        -: 1234:} /* ecma_builtin_typedarray_prototype_sort */
        -: 1235:
        -: 1236:/**
        -: 1237: * The %TypedArray%.prototype object's 'find' and 'findIndex' routine helper
        -: 1238: *
        -: 1239: * @return ecma value
        -: 1240: *         Returned value must be freed with ecma_free_value.
        -: 1241: */
        -: 1242:static ecma_value_t
    #####: 1243:ecma_builtin_typedarray_prototype_find_helper (ecma_value_t this_arg, /**< this argument */
        -: 1244:                                               ecma_typedarray_info_t *info_p, /**< object info */
        -: 1245:                                               ecma_value_t predicate, /**< callback function */
        -: 1246:                                               ecma_value_t predicate_this_arg, /**< this argument for
        -: 1247:                                                                                 *   invoke predicate */
        -: 1248:                                               bool is_find) /**< true - find routine
        -: 1249:                                                              *   false - findIndex routine */
        -: 1250:{
    #####: 1251:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 1252:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
        -: 1253:
    #####: 1254:  uint32_t buffer_index = 0;
    #####: 1255:  uint32_t limit = info_p->length * info_p->element_size;
        -: 1256:
    #####: 1257:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -: 1258:
    #####: 1259:  for (uint32_t byte_index = 0; byte_index < limit; byte_index += info_p->element_size)
        -: 1260:  {
    #####: 1261:    JERRY_ASSERT (buffer_index < info_p->length);
    #####: 1262:    ecma_value_t element_value = typedarray_getter_cb (info_p->buffer_p + byte_index);
        -: 1263:
    #####: 1264:    ecma_value_t call_args[] = { element_value, ecma_make_uint32_value (buffer_index), this_arg };
    #####: 1265:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 1266:
    #####: 1267:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1268:    {
    #####: 1269:      ecma_free_value (element_value);
    #####: 1270:      return call_value;
        -: 1271:    }
        -: 1272:
    #####: 1273:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1274:    {
    #####: 1275:      ecma_free_value (element_value);
    #####: 1276:      ecma_free_value (call_value);
    #####: 1277:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1278:    }
        -: 1279:
    #####: 1280:    bool call_result = ecma_op_to_boolean (call_value);
    #####: 1281:    ecma_free_value (call_value);
        -: 1282:
    #####: 1283:    if (call_result)
        -: 1284:    {
    #####: 1285:      if (is_find)
        -: 1286:      {
    #####: 1287:        return element_value;
        -: 1288:      }
        -: 1289:
    #####: 1290:      ecma_free_value (element_value);
    #####: 1291:      return ecma_make_uint32_value (buffer_index);
        -: 1292:    }
        -: 1293:
    #####: 1294:    buffer_index++;
    #####: 1295:    ecma_free_value (element_value);
        -: 1296:  }
        -: 1297:
    #####: 1298:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 1299:} /* ecma_builtin_typedarray_prototype_find_helper */
        -: 1300:
        -: 1301:/**
        -: 1302: * The %TypedArray%.prototype object's 'at' routine
        -: 1303: *
        -: 1304: * See also:
        -: 1305: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -: 1306: *          from: https://tc39.es/proposal-relative-indexing-method
        -: 1307: *
        -: 1308: * @return ecma value
        -: 1309: *         Returned value must be freed with ecma_free_value.
        -: 1310: */
        -: 1311:static ecma_value_t
    #####: 1312:ecma_builtin_typedarray_prototype_at (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1313:                                      const ecma_value_t index) /**< index argument */
        -: 1314:{
    #####: 1315:  ecma_length_t len = (ecma_length_t) info_p->length;
    #####: 1316:  ecma_length_t res_index;
    #####: 1317:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -: 1318:
    #####: 1319:  if (return_value != ECMA_VALUE_EMPTY)
        -: 1320:  {
    #####: 1321:    return return_value;
        -: 1322:  }
        -: 1323:
    #####: 1324:  return ecma_get_typedarray_element (info_p, (ecma_number_t) res_index);
        -: 1325:} /* ecma_builtin_typedarray_prototype_at */
        -: 1326:
        -: 1327:/**
        -: 1328: * The %TypedArray%.prototype object's 'indexOf' routine
        -: 1329: *
        -: 1330: * See also:
        -: 1331: *         ECMA-262 v6, 22.2.3.13
        -: 1332: *
        -: 1333: * @return ecma value
        -: 1334: *         Returned value must be freed with ecma_free_value.
        -: 1335: */
        -: 1336:static ecma_value_t
    #####: 1337:ecma_builtin_typedarray_prototype_index_of (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1338:                                            const ecma_value_t args[], /**< arguments list */
        -: 1339:                                            uint32_t args_number) /**< number of arguments */
        -: 1340:{
        -: 1341:#if JERRY_BUILTIN_BIGINT
    #####: 1342:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1343:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1344:  bool is_bigint = false;
        -: 1345:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1346:
    #####: 1347:  uint32_t limit = info_p->length * info_p->element_size;
    #####: 1348:  uint32_t from_index;
        -: 1349:
        -: 1350:   /* 5. */
    #####: 1351:  if (args_number == 0
    #####: 1352:      || (!ecma_is_value_number (args[0]) && !is_bigint)
    #####: 1353:      || info_p->length == 0)
        -: 1354:  {
    #####: 1355:    return ecma_make_integer_value (-1);
        -: 1356:  }
    #####: 1357:  if (args_number == 1)
        -: 1358:  {
    #####: 1359:    from_index = 0;
        -: 1360:  }
        -: 1361:  else
        -: 1362:  {
    #####: 1363:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1],
        -: 1364:                                                                         info_p->length,
        -: 1365:                                                                         &from_index)))
        -: 1366:    {
    #####: 1367:      return ECMA_VALUE_ERROR;
        -: 1368:    }
        -: 1369:
        -: 1370:  }
        -: 1371:
    #####: 1372:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -: 1373:
        -: 1374:  /* 11. */
    #####: 1375:  for (uint32_t position = from_index * info_p->element_size;
        -: 1376:       position < limit;
    #####: 1377:       position += info_p->element_size)
        -: 1378:  {
    #####: 1379:    ecma_value_t element = getter_cb (info_p->buffer_p + position);
        -: 1380:
    #####: 1381:    if (ecma_op_same_value_zero (args[0], element, true))
        -: 1382:    {
    #####: 1383:      ecma_free_value (element);
    #####: 1384:      return ecma_make_number_value ((ecma_number_t) position / info_p->element_size);
        -: 1385:    }
        -: 1386:
    #####: 1387:    ecma_free_value (element);
        -: 1388:  }
        -: 1389:
        -: 1390:  /* 12. */
    #####: 1391:  return ecma_make_integer_value (-1);
        -: 1392:} /* ecma_builtin_typedarray_prototype_index_of */
        -: 1393:
        -: 1394:/**
        -: 1395: * The %TypedArray%.prototype object's 'lastIndexOf' routine
        -: 1396: *
        -: 1397: * See also:
        -: 1398: *          ECMA-262 v6, 22.2.3.16
        -: 1399: *
        -: 1400: * @return ecma value
        -: 1401: *         Returned value must be freed with ecma_free_value.
        -: 1402: */
        -: 1403:static ecma_value_t
    #####: 1404:ecma_builtin_typedarray_prototype_last_index_of (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1405:                                                const ecma_value_t args[], /**< arguments list */
        -: 1406:                                                uint32_t args_number) /**< number of arguments */
        -: 1407:{
        -: 1408:#if JERRY_BUILTIN_BIGINT
    #####: 1409:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1410:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1411:  bool is_bigint = false;
        -: 1412:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1413:
    #####: 1414:  uint32_t from_index;
        -: 1415:
        -: 1416:  /* 5. */
    #####: 1417:  if (args_number == 0
    #####: 1418:      || (!ecma_is_value_number (args[0]) && !is_bigint)
    #####: 1419:      || info_p->length == 0)
        -: 1420:  {
    #####: 1421:    return ecma_make_integer_value (-1);
        -: 1422:  }
        -: 1423:
    #####: 1424:  if (args_number == 1)
        -: 1425:  {
    #####: 1426:    from_index = info_p->length - 1;
        -: 1427:  }
        -: 1428:  else
        -: 1429:  {
    #####: 1430:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1],
        -: 1431:                                                                         info_p->length,
        -: 1432:                                                                         &from_index)))
        -: 1433:    {
    #####: 1434:      return ECMA_VALUE_ERROR;
        -: 1435:    }
        -: 1436:
    #####: 1437:    ecma_number_t to_int;
        -: 1438:
    #####: 1439:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &to_int)))
        -: 1440:    {
    #####: 1441:      return ECMA_VALUE_ERROR;
        -: 1442:    }
        -: 1443:
    #####: 1444:    if (info_p->length + to_int < 0)
        -: 1445:    {
    #####: 1446:      return ecma_make_integer_value (-1);
        -: 1447:    }
        -: 1448:
    #####: 1449:    from_index = JERRY_MIN (from_index, info_p->length - 1);
        -: 1450:  }
        -: 1451:
    #####: 1452:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1453:  uint8_t *current_element_p = info_p->buffer_p + from_index * info_p->element_size;
        -: 1454:
        -: 1455:  /* 10. */
    #####: 1456:  while (current_element_p >= info_p->buffer_p)
        -: 1457:  {
    #####: 1458:    ecma_value_t element = getter_cb (info_p->buffer_p + from_index * info_p->element_size);
        -: 1459:
    #####: 1460:    if (ecma_op_same_value_zero (args[0], element, true))
        -: 1461:    {
    #####: 1462:      ecma_free_value (element);
    #####: 1463:      return ecma_make_number_value ((ecma_number_t) from_index * info_p->element_size / info_p->element_size);
        -: 1464:    }
        -: 1465:
    #####: 1466:    ecma_free_value (element);
    #####: 1467:    current_element_p -= info_p->element_size;
    #####: 1468:    from_index--;
        -: 1469:  }
        -: 1470:
        -: 1471:  /* 11. */
    #####: 1472:  return ecma_make_integer_value (-1);
        -: 1473:} /* ecma_builtin_typedarray_prototype_last_index_of */
        -: 1474:
        -: 1475:/**
        -: 1476: * The %TypedArray%.prototype object's 'copyWithin' routine
        -: 1477: *
        -: 1478: * See also:
        -: 1479: *          ECMA-262 v6, 22.2.3.5
        -: 1480: *
        -: 1481: * @return ecma value
        -: 1482: *         Returned value must be freed with ecma_free_value.
        -: 1483: */
        -: 1484:static ecma_value_t
    #####: 1485:ecma_builtin_typedarray_prototype_copy_within (ecma_value_t this_arg, /**< this argument */
        -: 1486:                                               ecma_typedarray_info_t *info_p, /**< object info */
        -: 1487:                                               const ecma_value_t args[], /**< arguments list */
        -: 1488:                                               uint32_t args_number) /**< number of arguments */
        -: 1489:{
    #####: 1490:  uint32_t relative_target = 0;
    #####: 1491:  uint32_t relative_start = 0;
    #####: 1492:  uint32_t relative_end = info_p->length;
        -: 1493:
    #####: 1494:  if (args_number > 0)
        -: 1495:  {
    #####: 1496:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[0],
        -: 1497:                                                                         info_p->length,
        -: 1498:                                                                         &relative_target)))
        -: 1499:    {
    #####: 1500:      return ECMA_VALUE_ERROR;
        -: 1501:    }
        -: 1502:
    #####: 1503:    if (args_number > 1)
        -: 1504:    {
    #####: 1505:      if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1],
        -: 1506:                                                                           info_p->length,
        -: 1507:                                                                           &relative_start)))
        -: 1508:      {
    #####: 1509:        return ECMA_VALUE_ERROR;
        -: 1510:      }
        -: 1511:
    #####: 1512:      if (args_number > 2 && args[2] != ECMA_VALUE_UNDEFINED)
        -: 1513:      {
    #####: 1514:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[2],
        -: 1515:                                                                             info_p->length,
        -: 1516:                                                                             &relative_end)))
        -: 1517:        {
    #####: 1518:          return ECMA_VALUE_ERROR;
        -: 1519:        }
        -: 1520:      }
        -: 1521:    }
        -: 1522:  }
        -: 1523:
    #####: 1524:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1525:  {
    #####: 1526:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1527:  }
        -: 1528:
    #####: 1529:  if (relative_target >= info_p->length || relative_start >= relative_end || relative_end == 0)
        -: 1530:  {
    #####: 1531:    return ecma_copy_value (this_arg);
        -: 1532:  }
        -: 1533:  else
        -: 1534:  {
    #####: 1535:    uint32_t distance = relative_end - relative_start;
    #####: 1536:    uint32_t offset = info_p->length - relative_target;
    #####: 1537:    uint32_t count = JERRY_MIN (distance, offset);
        -: 1538:
    #####: 1539:    memmove (info_p->buffer_p + (relative_target * info_p->element_size),
    #####: 1540:             info_p->buffer_p + (relative_start * info_p->element_size),
    #####: 1541:             (size_t) (count * info_p->element_size));
        -: 1542:  }
        -: 1543:
    #####: 1544:  return ecma_copy_value (this_arg);
        -: 1545:} /* ecma_builtin_typedarray_prototype_copy_within */
        -: 1546:
        -: 1547:/**
        -: 1548: * The %TypedArray%.prototype object's 'slice' routine
        -: 1549: *
        -: 1550: * See also:
        -: 1551: *          ECMA-262 v6, 22.2.3.23
        -: 1552: *
        -: 1553: * @return ecma value
        -: 1554: *         Returned value must be freed with ecma_free_value.
        -: 1555: */
        -: 1556:static ecma_value_t
    #####: 1557:ecma_builtin_typedarray_prototype_slice (ecma_value_t this_arg, /**< this argument */
        -: 1558:                                         ecma_typedarray_info_t *info_p, /**< object info */
        -: 1559:                                         const ecma_value_t args[], /**< arguments list */
        -: 1560:                                         uint32_t args_number) /**< number of arguments */
        -: 1561:{
    #####: 1562:  uint32_t relative_start = 0;
    #####: 1563:  uint32_t relative_end = info_p->length;
        -: 1564:
    #####: 1565:  if (args_number > 0)
        -: 1566:  {
    #####: 1567:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[0],
        -: 1568:                                                                         info_p->length,
        -: 1569:                                                                         &relative_start)))
        -: 1570:    {
    #####: 1571:      return ECMA_VALUE_ERROR;
        -: 1572:    }
        -: 1573:
    #####: 1574:    if (args_number > 1
    #####: 1575:        && args[1] != ECMA_VALUE_UNDEFINED
    #####: 1576:        && ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1],
        -: 1577:                                                                            info_p->length,
        -: 1578:                                                                            &relative_end)))
        -: 1579:    {
    #####: 1580:      return ECMA_VALUE_ERROR;
        -: 1581:    }
        -: 1582:  }
        -: 1583:
    #####: 1584:  int32_t distance = (int32_t) (relative_end - relative_start);
    #####: 1585:  uint32_t count = distance > 0 ? (uint32_t) distance : 0;
        -: 1586:
    #####: 1587:  ecma_value_t len = ecma_make_number_value (count);
        -: 1588:  // TODO: 22.2.3.23, 12-13.
    #####: 1589:  ecma_value_t new_typedarray = ecma_typedarray_species_create (this_arg, &len, 1);
    #####: 1590:  ecma_free_value (len);
        -: 1591:
    #####: 1592:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -: 1593:  {
    #####: 1594:    return new_typedarray;
        -: 1595:  }
        -: 1596:
    #####: 1597:  if (count > 0)
        -: 1598:  {
    #####: 1599:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
        -: 1600:
    #####: 1601:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1602:    {
    #####: 1603:      ecma_deref_object (new_typedarray_p);
    #####: 1604:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1605:    }
        -: 1606:
    #####: 1607:    lit_utf8_byte_t *new_typedarray_buffer_p = ecma_typedarray_get_buffer (new_typedarray_p);
    #####: 1608:    uint32_t src_byte_index = (relative_start * info_p->element_size);
        -: 1609:
    #####: 1610:    memcpy (new_typedarray_buffer_p,
    #####: 1611:            info_p->buffer_p + src_byte_index,
    #####: 1612:            count * info_p->element_size);
        -: 1613:  }
        -: 1614:
    #####: 1615:  return new_typedarray;
        -: 1616:} /* ecma_builtin_typedarray_prototype_slice */
        -: 1617:
        -: 1618:/**
        -: 1619: * The TypedArray.prototype's 'toLocaleString' single element operation routine.
        -: 1620: *
        -: 1621: * See also:
        -: 1622: *          ECMA-262 v6, 22.1.3.26 steps 7-10 and 12.b-e
        -: 1623: *
        -: 1624: * @return ecma value
        -: 1625: *         Returned value must be freed with ecma_free_value.
        -: 1626:*/
        -: 1627:static ecma_value_t
    #####: 1628:ecma_builtin_typedarray_prototype_to_locale_string_helper (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1629:                                                           uint32_t index) /** array index */
        -: 1630:{
    #####: 1631:  ecma_value_t element_value = ecma_get_typedarray_element (info_p, index);
        -: 1632:
    #####: 1633:  ecma_value_t call_value = ecma_op_invoke_by_magic_id (element_value, LIT_MAGIC_STRING_TO_LOCALE_STRING_UL, NULL, 0);
        -: 1634:
    #####: 1635:  ecma_free_value (element_value);
        -: 1636:
    #####: 1637:  if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1638:  {
    #####: 1639:    return call_value;
        -: 1640:  }
        -: 1641:
    #####: 1642:  ecma_string_t *str_p = ecma_op_to_string (call_value);
        -: 1643:
    #####: 1644:  ecma_free_value (call_value);
        -: 1645:
    #####: 1646:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 1647:  {
    #####: 1648:    return ECMA_VALUE_ERROR;
        -: 1649:  }
        -: 1650:
    #####: 1651:  return ecma_make_string_value (str_p);
        -: 1652:} /* ecma_builtin_typedarray_prototype_to_locale_string_helper */
        -: 1653:
        -: 1654:/**
        -: 1655: * The %TypedArray%.prototype object's 'toLocaleString' routine
        -: 1656: *
        -: 1657: * See also:
        -: 1658: *          ECMA-262 v6, 22.2.3.27
        -: 1659: *
        -: 1660: * @return ecma value
        -: 1661: *         Returned value must be freed with ecma_free_value.
        -: 1662: */
        -: 1663:static ecma_value_t
    #####: 1664:ecma_builtin_typedarray_prototype_to_locale_string (ecma_typedarray_info_t *info_p) /**< object info */
        -: 1665:{
    #####: 1666:  if (info_p->length == 0)
        -: 1667:  {
    #####: 1668:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1669:  }
        -: 1670:
    #####: 1671:  ecma_value_t first_element = ecma_builtin_typedarray_prototype_to_locale_string_helper (info_p, 0);
        -: 1672:
    #####: 1673:  if (ECMA_IS_VALUE_ERROR (first_element))
        -: 1674:  {
    #####: 1675:    return first_element;
        -: 1676:  }
        -: 1677:
    #####: 1678:  ecma_string_t *return_string_p = ecma_get_string_from_value (first_element);
    #####: 1679:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (return_string_p);
    #####: 1680:  ecma_deref_ecma_string (return_string_p);
        -: 1681:
    #####: 1682:  for (uint32_t k = 1; k < info_p->length; k++)
        -: 1683:  {
    #####: 1684:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
    #####: 1685:    ecma_value_t next_element = ecma_builtin_typedarray_prototype_to_locale_string_helper (info_p, k);
        -: 1686:
    #####: 1687:    if (ECMA_IS_VALUE_ERROR (next_element))
        -: 1688:    {
    #####: 1689:      ecma_stringbuilder_destroy (&builder);
    #####: 1690:      return next_element;
        -: 1691:    }
        -: 1692:
    #####: 1693:    ecma_string_t *next_element_p = ecma_get_string_from_value (next_element);
    #####: 1694:    ecma_stringbuilder_append (&builder, next_element_p);
    #####: 1695:    ecma_deref_ecma_string (next_element_p);
        -: 1696:  }
        -: 1697:
    #####: 1698:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 1699:} /* ecma_builtin_typedarray_prototype_to_locale_string */
        -: 1700:
        -: 1701:/**
        -: 1702: * The %TypedArray%.prototype object's 'includes' routine
        -: 1703: *
        -: 1704: * See also:
        -: 1705: *          ECMA-262 v11, 22.2.3.13.
        -: 1706: */
        -: 1707:static ecma_value_t
    #####: 1708:ecma_builtin_typedarray_prototype_includes (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1709:                                            const ecma_value_t args[], /**< arguments list */
        -: 1710:                                            uint32_t args_number) /**< number of arguments */
        -: 1711:{
    #####: 1712:  uint32_t limit = info_p->length * info_p->element_size;
        -: 1713:
        -: 1714:#if JERRY_BUILTIN_BIGINT
    #####: 1715:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1716:#else /* !JERRRY_BUILTIN_BIGINT */
        -: 1717:  bool is_bigint = false;
        -: 1718:#endif /* JERRRY_BUILTIN_BIGINT */
        -: 1719:
    #####: 1720:  if (args_number == 0
    #####: 1721:      || (!ecma_is_value_number (args[0]) && !is_bigint)
    #####: 1722:      || info_p->length == 0)
        -: 1723:  {
    #####: 1724:    return ECMA_VALUE_FALSE;
        -: 1725:  }
        -: 1726:
    #####: 1727:  uint32_t from_index = 0;
        -: 1728:
    #####: 1729:  if (args_number > 1)
        -: 1730:  {
    #####: 1731:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1], info_p->length, &from_index)))
        -: 1732:    {
    #####: 1733:      return ECMA_VALUE_ERROR;
        -: 1734:    }
        -: 1735:  }
        -: 1736:
    #####: 1737:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -: 1738:
    #####: 1739:  uint32_t search_pos = (uint32_t) from_index * info_p->element_size;
        -: 1740:
    #####: 1741:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1742:  {
    #####: 1743:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1744:  }
        -: 1745:
    #####: 1746:  while (search_pos < limit)
        -: 1747:  {
    #####: 1748:    ecma_value_t element = getter_cb (info_p->buffer_p + search_pos);
        -: 1749:
    #####: 1750:    if (ecma_op_same_value_zero (args[0], element, false))
        -: 1751:    {
    #####: 1752:      ecma_free_value (element);
    #####: 1753:      return ECMA_VALUE_TRUE;
        -: 1754:    }
        -: 1755:
    #####: 1756:    ecma_free_value (element);
    #####: 1757:    search_pos += info_p->element_size;
        -: 1758:  }
        -: 1759:
    #####: 1760:  return ECMA_VALUE_FALSE;
        -: 1761:} /* ecma_builtin_typedarray_prototype_includes */
        -: 1762:
        -: 1763:/**
        -: 1764: *
        -: 1765: * @return ecma value
        -: 1766: *         Returned value must be freed with ecma_free_value.
        -: 1767: */
        -: 1768:ecma_value_t
    #####: 1769:ecma_builtin_typedarray_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide
        -: 1770:                                                                                 *   routine identifier */
        -: 1771:                                                    ecma_value_t this_arg, /**< 'this' argument value */
        -: 1772:                                                    const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1773:                                                                                            *   passed to routine */
        -: 1774:                                                    uint32_t arguments_number) /**< length of arguments' list */
        -: 1775:{
    #####: 1776:  if (!ecma_is_typedarray (this_arg))
        -: 1777:  {
    #####: 1778:    if (builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER)
        -: 1779:    {
    #####: 1780:      return ECMA_VALUE_UNDEFINED;
        -: 1781:    }
        -: 1782:
    #####: 1783:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a TypedArray"));
        -: 1784:  }
        -: 1785:
    #####: 1786:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1787:  ecma_typedarray_info_t info = { 0 };
        -: 1788:
    #####: 1789:  if (builtin_routine_id < ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER)
        -: 1790:  {
    #####: 1791:    info = ecma_typedarray_get_info (typedarray_p);
        -: 1792:
    #####: 1793:    if (ecma_arraybuffer_is_detached (info.array_buffer_p)
    #####: 1794:        && builtin_routine_id != ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY)
        -: 1795:    {
    #####: 1796:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -: 1797:    }
        -: 1798:  }
        -: 1799:
    #####: 1800:  if (builtin_routine_id < ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF && !ecma_op_is_callable (arguments_list_p[0]))
        -: 1801:  {
    #####: 1802:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1803:  }
        -: 1804:
    #####: 1805:  switch (builtin_routine_id)
        -: 1806:  {
    #####: 1807:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INCLUDES:
        -: 1808:    {
    #####: 1809:      return ecma_builtin_typedarray_prototype_includes (&info, arguments_list_p, arguments_number);
        -: 1810:    }
    #####: 1811:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_JOIN:
        -: 1812:    {
    #####: 1813:      return ecma_builtin_typedarray_prototype_join (typedarray_p, arguments_list_p[0]);
        -: 1814:    }
    #####: 1815:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY:
        -: 1816:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SOME:
        -: 1817:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FOR_EACH:
        -: 1818:    {
    #####: 1819:      uint8_t offset = (uint8_t) (builtin_routine_id - ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY);
        -: 1820:
    #####: 1821:      return ecma_builtin_typedarray_prototype_exec_routine (this_arg,
        -: 1822:                                                             &info,
        -: 1823:                                                             arguments_list_p[0],
    #####: 1824:                                                             arguments_list_p[1],
        -: 1825:                                                             offset);
        -: 1826:    }
    #####: 1827:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_MAP:
        -: 1828:    {
    #####: 1829:      return ecma_builtin_typedarray_prototype_map (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1830:    }
    #####: 1831:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE:
        -: 1832:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT:
        -: 1833:    {
    #####: 1834:      bool is_reduce =  builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT;
    #####: 1835:      return ecma_builtin_typedarray_prototype_reduce_with_direction (this_arg,
        -: 1836:                                                                      &info,
        -: 1837:                                                                      arguments_list_p,
        -: 1838:                                                                      arguments_number,
        -: 1839:                                                                      is_reduce);
        -: 1840:    }
    #####: 1841:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILTER:
        -: 1842:    {
    #####: 1843:      return ecma_builtin_typedarray_prototype_filter (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1844:    }
    #####: 1845:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REVERSE:
        -: 1846:    {
    #####: 1847:      return ecma_builtin_typedarray_prototype_reverse (this_arg, &info);
        -: 1848:    }
    #####: 1849:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SET:
        -: 1850:    {
    #####: 1851:      return ecma_builtin_typedarray_prototype_set (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -: 1852:    }
    #####: 1853:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY:
        -: 1854:    {
    #####: 1855:      return ecma_builtin_typedarray_prototype_subarray (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1856:    }
    #####: 1857:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILL:
        -: 1858:    {
    #####: 1859:      return ecma_builtin_typedarray_prototype_fill (this_arg,
        -: 1860:                                                     &info,
        -: 1861:                                                     arguments_list_p[0],
    #####: 1862:                                                     arguments_list_p[1],
    #####: 1863:                                                     arguments_list_p[2]);
        -: 1864:    }
    #####: 1865:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SORT:
        -: 1866:    {
    #####: 1867:      if (!ecma_is_value_undefined (arguments_list_p[0]) && !ecma_op_is_callable (arguments_list_p[0]))
        -: 1868:      {
    #####: 1869:        return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1870:      }
        -: 1871:
    #####: 1872:      return ecma_builtin_typedarray_prototype_sort (this_arg, &info, arguments_list_p[0]);
        -: 1873:
        -: 1874:    }
    #####: 1875:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND:
        -: 1876:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND_INDEX:
        -: 1877:    {
    #####: 1878:      bool is_find = builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND;
    #####: 1879:      return ecma_builtin_typedarray_prototype_find_helper (this_arg,
        -: 1880:                                                            &info,
        -: 1881:                                                            arguments_list_p[0],
    #####: 1882:                                                            arguments_list_p[1],
        -: 1883:                                                            is_find);
        -: 1884:    }
    #####: 1885:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_AT:
        -: 1886:    {
    #####: 1887:      return ecma_builtin_typedarray_prototype_at (&info, arguments_list_p[0]);
        -: 1888:    }
    #####: 1889:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF:
        -: 1890:    {
    #####: 1891:      return ecma_builtin_typedarray_prototype_index_of (&info, arguments_list_p, arguments_number);
        -: 1892:    }
    #####: 1893:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LAST_INDEX_OF:
        -: 1894:    {
    #####: 1895:      return ecma_builtin_typedarray_prototype_last_index_of (&info, arguments_list_p, arguments_number);
        -: 1896:    }
    #####: 1897:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_COPY_WITHIN:
        -: 1898:    {
    #####: 1899:      return ecma_builtin_typedarray_prototype_copy_within (this_arg, &info, arguments_list_p, arguments_number);
        -: 1900:    }
    #####: 1901:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SLICE:
        -: 1902:    {
    #####: 1903:      return ecma_builtin_typedarray_prototype_slice (this_arg, &info, arguments_list_p, arguments_number);
        -: 1904:    }
    #####: 1905:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_LOCALE_STRING:
        -: 1906:    {
    #####: 1907:      return ecma_builtin_typedarray_prototype_to_locale_string (&info);
        -: 1908:    }
    #####: 1909:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS:
        -: 1910:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_ENTRIES:
        -: 1911:    {
    #####: 1912:      ecma_iterator_kind_t iter_id = (builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS)
    #####: 1913:      ? ECMA_ITERATOR_KEYS : ECMA_ITERATOR_ENTRIES;
        -: 1914:
    #####: 1915:      return ecma_typedarray_iterators_helper (this_arg, iter_id);
        -: 1916:    }
    #####: 1917:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER:
        -: 1918:    {
    #####: 1919:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 1920:      ecma_ref_object (buffer_p);
        -: 1921:
    #####: 1922:      return ecma_make_object_value (buffer_p);
        -: 1923:    }
    #####: 1924:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTELENGTH_GETTER:
        -: 1925:    {
    #####: 1926:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 1927:
    #####: 1928:      if (ecma_arraybuffer_is_detached (buffer_p))
        -: 1929:      {
    #####: 1930:        return ecma_make_uint32_value (0);
        -: 1931:      }
        -: 1932:
    #####: 1933:      uint32_t length = ecma_typedarray_get_length (typedarray_p);
    #####: 1934:      uint8_t shift = ecma_typedarray_get_element_size_shift (typedarray_p);
    #####: 1935:      return ecma_make_uint32_value (length << shift);
        -: 1936:    }
    #####: 1937:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTEOFFSET_GETTER:
        -: 1938:    {
    #####: 1939:      return ecma_make_uint32_value (ecma_typedarray_get_offset (typedarray_p));
        -: 1940:    }
    #####: 1941:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LENGTH_GETTER:
        -: 1942:    {
    #####: 1943:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 1944:
    #####: 1945:      if (ecma_arraybuffer_is_detached (buffer_p))
        -: 1946:      {
    #####: 1947:        return ecma_make_uint32_value (0);
        -: 1948:      }
        -: 1949:
    #####: 1950:      return ecma_make_uint32_value (ecma_typedarray_get_length (typedarray_p));
        -: 1951:    }
    #####: 1952:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER:
        -: 1953:    {
    #####: 1954:      ecma_extended_object_t *object_p = (ecma_extended_object_t *) typedarray_p;
    #####: 1955:      return ecma_make_magic_string_value (ecma_get_typedarray_magic_string_id (object_p->u.cls.u1.typedarray_type));
        -: 1956:    }
    #####: 1957:    default:
        -: 1958:    {
    #####: 1959:      JERRY_UNREACHABLE ();
        -: 1960:    }
        -: 1961:  }
        -: 1962:} /* ecma_builtin_typedarray_prototype_dispatch_routine */
        -: 1963:
        -: 1964:/**
        -: 1965: * @}
        -: 1966: * @}
        -: 1967: * @}
        -: 1968: */
        -: 1969:
        -: 1970:#endif /* JERRY_BUILTIN_TYPEDARRAY */
