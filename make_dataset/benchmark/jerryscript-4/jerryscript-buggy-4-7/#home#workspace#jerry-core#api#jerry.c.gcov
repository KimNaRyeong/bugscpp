        -:    0:Source:/home/workspace/jerry-core/api/jerry.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <stdio.h>
        -:   17:#include <math.h>
        -:   18:
        -:   19:#include "debugger.h"
        -:   20:#include "ecma-alloc.h"
        -:   21:#include "ecma-array-object.h"
        -:   22:#include "ecma-arraybuffer-object.h"
        -:   23:#include "ecma-bigint.h"
        -:   24:#include "ecma-builtin-helpers.h"
        -:   25:#include "ecma-builtins.h"
        -:   26:#include "ecma-comparison.h"
        -:   27:#include "ecma-container-object.h"
        -:   28:#include "ecma-dataview-object.h"
        -:   29:#include "ecma-eval.h"
        -:   30:#include "ecma-exceptions.h"
        -:   31:#include "ecma-extended-info.h"
        -:   32:#include "ecma-function-object.h"
        -:   33:#include "ecma-gc.h"
        -:   34:#include "ecma-helpers.h"
        -:   35:#include "ecma-init-finalize.h"
        -:   36:#include "ecma-iterator-object.h"
        -:   37:#include "ecma-lex-env.h"
        -:   38:#include "ecma-line-info.h"
        -:   39:#include "ecma-literal-storage.h"
        -:   40:#include "ecma-objects.h"
        -:   41:#include "ecma-objects-general.h"
        -:   42:#include "ecma-regexp-object.h"
        -:   43:#include "ecma-promise-object.h"
        -:   44:#include "ecma-proxy-object.h"
        -:   45:#include "ecma-shared-arraybuffer-object.h"
        -:   46:#include "ecma-symbol-object.h"
        -:   47:#include "ecma-typedarray-object.h"
        -:   48:#include "jcontext.h"
        -:   49:#include "jerryscript.h"
        -:   50:#include "jerryscript-debugger-transport.h"
        -:   51:#include "jmem.h"
        -:   52:#include "js-parser.h"
        -:   53:#include "lit-char-helpers.h"
        -:   54:#include "opcodes.h"
        -:   55:#include "re-compiler.h"
        -:   56:
        -:   57:JERRY_STATIC_ASSERT (sizeof (jerry_value_t) == sizeof (ecma_value_t),
        -:   58:                     size_of_jerry_value_t_must_be_equal_to_size_of_ecma_value_t);
        -:   59:
        -:   60:#if JERRY_BUILTIN_REGEXP
        -:   61:JERRY_STATIC_ASSERT ((int) RE_FLAG_GLOBAL == (int) JERRY_REGEXP_FLAG_GLOBAL
        -:   62:                     && (int) RE_FLAG_MULTILINE == (int) JERRY_REGEXP_FLAG_MULTILINE
        -:   63:                     && (int) RE_FLAG_IGNORE_CASE == (int) JERRY_REGEXP_FLAG_IGNORE_CASE
        -:   64:                     && (int) RE_FLAG_STICKY== (int) JERRY_REGEXP_FLAG_STICKY
        -:   65:                     && (int) RE_FLAG_UNICODE == (int) JERRY_REGEXP_FLAG_UNICODE
        -:   66:                     && (int) RE_FLAG_DOTALL == (int) JERRY_REGEXP_FLAG_DOTALL,
        -:   67:                     re_flags_t_must_be_equal_to_jerry_regexp_flags_t);
        -:   68:#endif /* JERRY_BUILTIN_REGEXP */
        -:   69:
        -:   70:#if JERRY_ESNEXT
        -:   71:/* The internal ECMA_PROMISE_STATE_* values are "one byte away" from the API values */
        -:   72:JERRY_STATIC_ASSERT ((int) ECMA_PROMISE_IS_PENDING == (int) JERRY_PROMISE_STATE_PENDING
        -:   73:                     && (int) ECMA_PROMISE_IS_FULFILLED == (int) JERRY_PROMISE_STATE_FULFILLED,
        -:   74:                     promise_internal_state_matches_external);
        -:   75:#endif /* JERRY_ESNEXT */
        -:   76:
        -:   77:/**
        -:   78: * Offset between internal and external arithmetic operator types
        -:   79: */
        -:   80:#define ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET (JERRY_BIN_OP_SUB - NUMBER_ARITHMETIC_SUBTRACTION)
        -:   81:
        -:   82:JERRY_STATIC_ASSERT (((NUMBER_ARITHMETIC_SUBTRACTION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_SUB)
        -:   83:                     && ((NUMBER_ARITHMETIC_MULTIPLICATION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_MUL)
        -:   84:                     && ((NUMBER_ARITHMETIC_DIVISION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_DIV)
        -:   85:                     && ((NUMBER_ARITHMETIC_REMAINDER + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_REM),
        -:   86:                     number_arithmetics_operation_type_matches_external);
        -:   87:
        -:   88:#if !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC
        -:   89:#error "JERRY_SNAPSHOT_EXEC must be enabled if JERRY_PARSER is disabled!"
        -:   90:#endif /* !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC */
        -:   91:
        -:   92:/** \addtogroup jerry Jerry engine interface
        -:   93: * @{
        -:   94: */
        -:   95:
        -:   96:/**
        -:   97: * Assert that it is correct to call API in current state.
        -:   98: *
        -:   99: * Note:
        -:  100: *         By convention, there are some states when API could not be invoked.
        -:  101: *
        -:  102: *         The API can be and only be invoked when the ECMA_STATUS_API_AVAILABLE
        -:  103: *         flag is set.
        -:  104: *
        -:  105: *         This procedure checks whether the API is available, and terminates
        -:  106: *         the engine if it is unavailable. Otherwise it is a no-op.
        -:  107: *
        -:  108: * Note:
        -:  109: *         The API could not be invoked in the following cases:
        -:  110: *           - before jerry_init and after jerry_cleanup
        -:  111: *           - between enter to and return from a native free callback
        -:  112: */
        -:  113:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  114:jerry_assert_api_available (void)
        -:  115:{
       51:  116:  JERRY_ASSERT (JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE);
        -:  117:} /* jerry_assert_api_available */
        -:  118:
        -:  119:/**
        -:  120: * Turn on API availability
        -:  121: */
        -:  122:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  123:jerry_make_api_available (void)
        -:  124:{
        1:  125:  JERRY_CONTEXT (status_flags) |= ECMA_STATUS_API_AVAILABLE;
        -:  126:} /* jerry_make_api_available */
        -:  127:
        -:  128:/**
        -:  129: * Turn off API availability
        -:  130: */
        -:  131:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  132:jerry_make_api_unavailable (void)
        -:  133:{
    #####:  134:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_API_AVAILABLE;
        -:  135:} /* jerry_make_api_unavailable */
        -:  136:
        -:  137:/**
        -:  138: * Create an API compatible return value.
        -:  139: *
        -:  140: * @return return value for Jerry API functions
        -:  141: */
        -:  142:static jerry_value_t
        5:  143:jerry_return (jerry_value_t value) /**< return value */
        -:  144:{
        5:  145:  if (ECMA_IS_VALUE_ERROR (value))
        -:  146:  {
    #####:  147:    value = ecma_create_error_reference_from_context ();
        -:  148:  }
        -:  149:
        5:  150:  return value;
        -:  151:} /* jerry_return */
        -:  152:
        -:  153:/**
        -:  154: * Throw an API compatible return value.
        -:  155: *
        -:  156: * @return return value for Jerry API functions
        -:  157: */
        -:  158:static inline jerry_value_t JERRY_ATTR_ALWAYS_INLINE
        -:  159:jerry_throw (jerry_value_t value) /**< return value */
        -:  160:{
    #####:  161:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (value));
    #####:  162:  return ecma_create_error_reference_from_context ();
        -:  163:} /* jerry_throw */
        -:  164:
        -:  165:/**
        -:  166: * Jerry engine initialization
        -:  167: */
        -:  168:void
        1:  169:jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  170:{
        -:  171:  /* This function cannot be called twice unless jerry_cleanup is called. */
        1:  172:  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_AVAILABLE));
        -:  173:
        -:  174:  /* Zero out all non-external members. */
        1:  175:  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER), 0,
        -:  176:          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));
        -:  177:
        1:  178:  JERRY_CONTEXT (jerry_init_flags) = flags;
        -:  179:
        -:  180:  jerry_make_api_available ();
        -:  181:
        1:  182:  jmem_init ();
        1:  183:  ecma_init ();
        1:  184:} /* jerry_init */
        -:  185:
        -:  186:/**
        -:  187: * Terminate Jerry engine
        -:  188: */
        -:  189:void
    #####:  190:jerry_cleanup (void)
        -:  191:{
        -:  192:  jerry_assert_api_available ();
        -:  193:
        -:  194:#if JERRY_DEBUGGER
        -:  195:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  196:  {
        -:  197:    jerry_debugger_send_type (JERRY_DEBUGGER_CLOSE_CONNECTION);
        -:  198:
        -:  199:    jerry_debugger_transport_close ();
        -:  200:  }
        -:  201:#endif /* JERRY_DEBUGGER */
        -:  202:
    #####:  203:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p);
        -:  204:       this_p != NULL;
    #####:  205:       this_p = this_p->next_p)
        -:  206:  {
    #####:  207:    if (this_p->manager_p->deinit_cb)
        -:  208:    {
    #####:  209:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  210:      this_p->manager_p->deinit_cb (data);
        -:  211:    }
        -:  212:  }
        -:  213:
        -:  214:#if JERRY_ESNEXT
    #####:  215:  ecma_free_all_enqueued_jobs ();
        -:  216:#endif /* JERRY_ESNEXT */
    #####:  217:  ecma_finalize ();
        -:  218:  jerry_make_api_unavailable ();
        -:  219:
    #####:  220:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p), *next_p = NULL;
        -:  221:       this_p != NULL;
    #####:  222:       this_p = next_p)
        -:  223:  {
    #####:  224:    next_p = this_p->next_p;
    #####:  225:    if (this_p->manager_p->finalize_cb)
        -:  226:    {
    #####:  227:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  228:      this_p->manager_p->finalize_cb (data);
        -:  229:    }
    #####:  230:    jmem_heap_free_block (this_p, sizeof (jerry_context_data_header_t) + this_p->manager_p->bytes_needed);
        -:  231:  }
        -:  232:
    #####:  233:  jmem_finalize ();
    #####:  234:} /* jerry_cleanup */
        -:  235:
        -:  236:/**
        -:  237: * Retrieve a context data item, or create a new one.
        -:  238: *
        -:  239: * @param manager_p pointer to the manager whose context data item should be returned.
        -:  240: *
        -:  241: * @return a pointer to the user-provided context-specific data item for the given manager, creating such a pointer if
        -:  242: * none was found.
        -:  243: */
        -:  244:void *
    #####:  245:jerry_get_context_data (const jerry_context_data_manager_t *manager_p)
        -:  246:{
    #####:  247:  void *ret = NULL;
        -:  248:  jerry_context_data_header_t *item_p;
        -:  249:
    #####:  250:  for (item_p = JERRY_CONTEXT (context_data_p); item_p != NULL; item_p = item_p->next_p)
        -:  251:  {
    #####:  252:    if (item_p->manager_p == manager_p)
        -:  253:    {
    #####:  254:      return (manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p) : NULL;
        -:  255:    }
        -:  256:  }
        -:  257:
    #####:  258:  item_p = jmem_heap_alloc_block (sizeof (jerry_context_data_header_t) + manager_p->bytes_needed);
    #####:  259:  item_p->manager_p = manager_p;
    #####:  260:  item_p->next_p = JERRY_CONTEXT (context_data_p);
    #####:  261:  JERRY_CONTEXT (context_data_p) = item_p;
        -:  262:
    #####:  263:  if (manager_p->bytes_needed > 0)
        -:  264:  {
    #####:  265:    ret = JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p);
    #####:  266:    memset (ret, 0, manager_p->bytes_needed);
        -:  267:  }
        -:  268:
    #####:  269:  if (manager_p->init_cb)
        -:  270:  {
    #####:  271:    manager_p->init_cb (ret);
        -:  272:  }
        -:  273:
    #####:  274:  return ret;
        -:  275:} /* jerry_get_context_data */
        -:  276:
        -:  277:/**
        -:  278: * Register external magic string array
        -:  279: */
        -:  280:void
    #####:  281:jerry_register_magic_strings (const jerry_char_t * const *ex_str_items_p, /**< character arrays, representing
        -:  282:                                                                           *   external magic strings' contents */
        -:  283:                              uint32_t count, /**< number of the strings */
        -:  284:                              const jerry_length_t *str_lengths_p) /**< lengths of all strings */
        -:  285:{
        -:  286:  jerry_assert_api_available ();
        -:  287:
    #####:  288:  lit_magic_strings_ex_set ((const lit_utf8_byte_t * const *) ex_str_items_p,
        -:  289:                            count,
        -:  290:                            (const lit_utf8_size_t *) str_lengths_p);
    #####:  291:} /* jerry_register_magic_strings */
        -:  292:
        -:  293:/**
        -:  294: * Run garbage collection
        -:  295: */
        -:  296:void
    #####:  297:jerry_gc (jerry_gc_mode_t mode) /**< operational mode */
        -:  298:{
        -:  299:  jerry_assert_api_available ();
        -:  300:
    #####:  301:  if (mode == JERRY_GC_PRESSURE_LOW)
        -:  302:  {
        -:  303:    /* Call GC directly, because 'ecma_free_unused_memory' might decide it's not yet worth it. */
    #####:  304:    ecma_gc_run ();
    #####:  305:    return;
        -:  306:  }
        -:  307:
    #####:  308:  ecma_free_unused_memory (JMEM_PRESSURE_HIGH);
        -:  309:} /* jerry_gc */
        -:  310:
        -:  311:/**
        -:  312: * Get heap memory stats.
        -:  313: *
        -:  314: * @return true - get the heap stats successful
        -:  315: *         false - otherwise. Usually it is because the MEM_STATS feature is not enabled.
        -:  316: */
        -:  317:bool
    #####:  318:jerry_get_memory_stats (jerry_heap_stats_t *out_stats_p) /**< [out] heap memory stats */
        -:  319:{
        -:  320:#if JERRY_MEM_STATS
    #####:  321:  if (out_stats_p == NULL)
        -:  322:  {
        -:  323:    return false;
        -:  324:  }
        -:  325:
        -:  326:  jmem_heap_stats_t jmem_heap_stats;
    #####:  327:  memset (&jmem_heap_stats, 0, sizeof (jmem_heap_stats));
    #####:  328:  jmem_heap_get_stats (&jmem_heap_stats);
        -:  329:
    #####:  330:  *out_stats_p = (jerry_heap_stats_t)
        -:  331:  {
        -:  332:    .version = 1,
    #####:  333:    .size = jmem_heap_stats.size,
    #####:  334:    .allocated_bytes = jmem_heap_stats.allocated_bytes,
    #####:  335:    .peak_allocated_bytes = jmem_heap_stats.peak_allocated_bytes
        -:  336:  };
        -:  337:
    #####:  338:  return true;
        -:  339:#else /* !JERRY_MEM_STATS */
        -:  340:  JERRY_UNUSED (out_stats_p);
    #####:  341:  return false;
        -:  342:#endif /* JERRY_MEM_STATS */
        -:  343:} /* jerry_get_memory_stats */
        -:  344:
        -:  345:/**
        -:  346: * Simple Jerry runner
        -:  347: *
        -:  348: * @return true  - if run was successful
        -:  349: *         false - otherwise
        -:  350: */
        -:  351:bool
    #####:  352:jerry_run_simple (const jerry_char_t *script_source_p, /**< script source */
        -:  353:                  size_t script_source_size, /**< script source size */
        -:  354:                  jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  355:{
    #####:  356:  bool result = false;
        -:  357:
    #####:  358:  jerry_init (flags);
        -:  359:
    #####:  360:  jerry_value_t parse_ret_val = jerry_parse (script_source_p, script_source_size, NULL);
        -:  361:
    #####:  362:  if (!ecma_is_value_error_reference (parse_ret_val))
        -:  363:  {
    #####:  364:    jerry_value_t run_ret_val = jerry_run (parse_ret_val);
        -:  365:
    #####:  366:    if (!ecma_is_value_error_reference (run_ret_val))
        -:  367:    {
    #####:  368:      result = true;
        -:  369:    }
        -:  370:
    #####:  371:    jerry_release_value (run_ret_val);
        -:  372:  }
        -:  373:
    #####:  374:  jerry_release_value (parse_ret_val);
    #####:  375:  jerry_cleanup ();
        -:  376:
    #####:  377:  return result;
        -:  378:} /* jerry_run_simple */
        -:  379:
        -:  380:#if JERRY_PARSER
        -:  381:
        -:  382:/**
        -:  383: * Common code for parsing a script, module, or function.
        -:  384: *
        -:  385: * @return function object value - if script was parsed successfully,
        -:  386: *         thrown error - otherwise
        -:  387: */
        -:  388:static jerry_value_t
        1:  389:jerry_parse_common (void *source_p, /**< script source */
        -:  390:                    const jerry_parse_options_t *options_p, /**< parsing options, can be NULL if not used */
        -:  391:                    uint32_t parse_opts) /**< internal parsing options */
        -:  392:{
        -:  393:  jerry_assert_api_available ();
        -:  394:
        1:  395:  if (options_p != NULL)
        -:  396:  {
        1:  397:    const uint32_t allowed_options = (JERRY_PARSE_STRICT_MODE
        -:  398:                                      | JERRY_PARSE_MODULE
        -:  399:                                      | JERRY_PARSE_HAS_ARGUMENT_LIST
        -:  400:                                      | JERRY_PARSE_HAS_RESOURCE
        -:  401:                                      | JERRY_PARSE_HAS_START
        -:  402:                                      | JERRY_PARSE_HAS_USER_VALUE);
        1:  403:    uint32_t options = options_p->options;
        -:  404:
        1:  405:    if ((options & ~allowed_options) != 0
        1:  406:        || ((options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)
    #####:  407:            && ((options_p->options & JERRY_PARSE_MODULE)
    #####:  408:                || !ecma_is_value_string (options_p->argument_list)))
        1:  409:        || ((options_p->options & JERRY_PARSE_HAS_RESOURCE)
        1:  410:            && !ecma_is_value_string (options_p->resource_name)))
        -:  411:    {
    #####:  412:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  413:    }
        -:  414:  }
        -:  415:
        -:  416:#if JERRY_DEBUGGER
        -:  417:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  418:      && options_p != NULL
        -:  419:      && (options_p->options & JERRY_PARSE_HAS_RESOURCE)
        -:  420:      && ecma_is_value_string (options_p->resource_name))
        -:  421:  {
        -:  422:    ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (options_p->resource_name),
        -:  423:                                resource_name_start_p,
        -:  424:                                resource_name_size);
        -:  425:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,
        -:  426:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  427:                                resource_name_start_p,
        -:  428:                                resource_name_size);
        -:  429:    ECMA_FINALIZE_UTF8_STRING (resource_name_start_p, resource_name_size);
        -:  430:  }
        -:  431:#endif /* JERRY_DEBUGGER */
        -:  432:
        1:  433:  if (options_p != NULL)
        -:  434:  {
        1:  435:    parse_opts |= options_p->options & (JERRY_PARSE_STRICT_MODE | JERRY_PARSE_MODULE);
        -:  436:  }
        -:  437:
        1:  438:  if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  439:  {
        -:  440:#if JERRY_MODULE_SYSTEM
    #####:  441:    JERRY_CONTEXT (module_current_p) = ecma_module_create ();
        -:  442:#else /* !JERRY_MODULE_SYSTEM */
    #####:  443:    return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  444:#endif /* JERRY_MODULE_SYSTEM */
        -:  445:  }
        -:  446:
        -:  447:  ecma_compiled_code_t *bytecode_data_p;
        1:  448:  bytecode_data_p = parser_parse_script (source_p, parse_opts, options_p);
        -:  449:
        1:  450:  if (JERRY_UNLIKELY (bytecode_data_p == NULL))
        -:  451:  {
        -:  452:#if JERRY_MODULE_SYSTEM
    #####:  453:    if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  454:    {
    #####:  455:      ecma_module_cleanup_context ();
        -:  456:    }
        -:  457:#endif /* JERRY_MODULE_SYSTEM */
        -:  458:
    #####:  459:    return ecma_create_error_reference_from_context ();
        -:  460:  }
        -:  461:
        -:  462:#if JERRY_MODULE_SYSTEM
        1:  463:  if (JERRY_UNLIKELY (parse_opts & JERRY_PARSE_MODULE))
        -:  464:  {
    #####:  465:    ecma_module_t *module_p = JERRY_CONTEXT (module_current_p);
    #####:  466:    module_p->u.compiled_code_p = bytecode_data_p;
        -:  467:
    #####:  468:    JERRY_CONTEXT (module_current_p) = NULL;
        -:  469:
    #####:  470:    return ecma_make_object_value ((ecma_object_t *) module_p);
        -:  471:  }
        -:  472:#endif /* JERRY_MODULE_SYSTEM */
        -:  473:
        1:  474:  if (JERRY_UNLIKELY (options_p != NULL
        -:  475:                      && (options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)))
        -:  476:  {
    #####:  477:    ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -:  478:
        -:  479:#if JERRY_BUILTIN_REALMS
    #####:  480:    JERRY_ASSERT (global_object_p == (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p));
        -:  481:#endif /* JERRY_BUILTIN_REALMS */
        -:  482:
    #####:  483:    ecma_object_t *lex_env_p = ecma_get_global_environment (global_object_p);
    #####:  484:    ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);
    #####:  485:    ecma_bytecode_deref (bytecode_data_p);
        -:  486:
    #####:  487:    return ecma_make_object_value (func_obj_p);
        -:  488:  }
        -:  489:
        1:  490:  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  491:
        1:  492:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        1:  493:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_SCRIPT;
        1:  494:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bytecode_data_p);
        -:  495:
        1:  496:  return ecma_make_object_value (object_p);
        -:  497:} /* jerry_parse_common */
        -:  498:
        -:  499:#endif /* JERRY_PARSER */
        -:  500:
        -:  501:/**
        -:  502: * Parse a script, module, or function and create a compiled code using a character string
        -:  503: *
        -:  504: * @return function object value - if script was parsed successfully,
        -:  505: *         thrown error - otherwise
        -:  506: */
        -:  507:jerry_value_t
        1:  508:jerry_parse (const jerry_char_t *source_p, /**< script source */
        -:  509:             size_t source_size, /**< script source size */
        -:  510:             const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  511:{
        -:  512:#if JERRY_PARSER
        1:  513:  parser_source_char_t source_char;
        1:  514:  source_char.source_p = source_p;
        1:  515:  source_char.source_size = source_size;
        -:  516:
        1:  517:  return jerry_parse_common ((void *) &source_char, options_p, JERRY_PARSE_NO_OPTS);
        -:  518:#else /* !JERRY_PARSER */
        -:  519:  JERRY_UNUSED (source_p);
        -:  520:  JERRY_UNUSED (source_size);
        -:  521:  JERRY_UNUSED (options_p);
        -:  522:
        -:  523:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_parser_not_supported_p)));
        -:  524:#endif /* JERRY_PARSER */
        -:  525:} /* jerry_parse */
        -:  526:
        -:  527:/**
        -:  528: * Parse a script, module, or function and create a compiled code using a string value
        -:  529: *
        -:  530: * @return function object value - if script was parsed successfully,
        -:  531: *         thrown error - otherwise
        -:  532: */
        -:  533:jerry_value_t
    #####:  534:jerry_parse_value (const jerry_value_t source_value, /**< script source */
        -:  535:                   const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  536:{
        -:  537:#if JERRY_PARSER
    #####:  538:  if (!ecma_is_value_string (source_value))
        -:  539:  {
    #####:  540:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  541:  }
        -:  542:
    #####:  543:  ecma_value_t source[1];
    #####:  544:  source[0] = source_value;
        -:  545:
    #####:  546:  return jerry_parse_common ((void *) source, options_p, ECMA_PARSE_HAS_SOURCE_VALUE);
        -:  547:#else /* !JERRY_PARSER */
        -:  548:  JERRY_UNUSED (source_value);
        -:  549:  JERRY_UNUSED (options_p);
        -:  550:
        -:  551:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_parser_not_supported_p)));
        -:  552:#endif /* JERRY_PARSER */
        -:  553:} /* jerry_parse_value */
        -:  554:
        -:  555:/**
        -:  556: * Run a Script or Module created by jerry_parse.
        -:  557: *
        -:  558: * Note:
        -:  559: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  560: *
        -:  561: * @return result of bytecode - if run was successful
        -:  562: *         thrown error - otherwise
        -:  563: */
        -:  564:jerry_value_t
        1:  565:jerry_run (const jerry_value_t func_val) /**< function to run */
        -:  566:{
        -:  567:  jerry_assert_api_available ();
        -:  568:
        1:  569:  if (!ecma_is_value_object (func_val))
        -:  570:  {
    #####:  571:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  572:  }
        -:  573:
        1:  574:  ecma_object_t *object_p = ecma_get_object_from_value (func_val);
        -:  575:
        1:  576:  if (!ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_SCRIPT))
        -:  577:  {
    #####:  578:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  579:  }
        -:  580:
        1:  581:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  582:
        -:  583:  const ecma_compiled_code_t *bytecode_data_p;
        1:  584:  bytecode_data_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
        -:  585:
        1:  586:  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_SCRIPT);
        -:  587:
        1:  588:  return jerry_return (vm_run_global (bytecode_data_p, object_p));
        -:  589:} /* jerry_run */
        -:  590:
        -:  591:/**
        -:  592: * Perform eval
        -:  593: *
        -:  594: * Note:
        -:  595: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  596: *
        -:  597: * @return result of eval, may be error value.
        -:  598: */
        -:  599:jerry_value_t
    #####:  600:jerry_eval (const jerry_char_t *source_p, /**< source code */
        -:  601:            size_t source_size, /**< length of source code */
        -:  602:            uint32_t parse_opts) /**< jerry_parse_opts_t option bits */
        -:  603:{
        -:  604:  jerry_assert_api_available ();
        -:  605:
    #####:  606:  uint32_t allowed_parse_options = JERRY_PARSE_STRICT_MODE;
        -:  607:
    #####:  608:  if ((parse_opts & ~allowed_parse_options) != 0)
        -:  609:  {
    #####:  610:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -:  611:  }
        -:  612:
    #####:  613:  parser_source_char_t source_char;
    #####:  614:  source_char.source_p = source_p;
    #####:  615:  source_char.source_size = source_size;
        -:  616:
    #####:  617:  return jerry_return (ecma_op_eval_chars_buffer ((void *) &source_char, parse_opts));
        -:  618:} /* jerry_eval */
        -:  619:
        -:  620:/**
        -:  621: * Link modules to their dependencies. The dependencies are resolved by a user callback.
        -:  622: *
        -:  623: * Note:
        -:  624: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  625: *
        -:  626: * @return true - if linking is successful, error - otherwise
        -:  627: */
        -:  628:jerry_value_t
    #####:  629:jerry_module_link (const jerry_value_t module_val, /**< root module */
        -:  630:                   jerry_module_resolve_callback_t callback, /**< resolve module callback, uses
        -:  631:                                                              *   jerry_port_module_resolve when NULL is passed */
        -:  632:                   void *user_p) /**< pointer passed to the resolve callback */
        -:  633:{
        -:  634:  jerry_assert_api_available ();
        -:  635:
        -:  636:#if JERRY_MODULE_SYSTEM
    #####:  637:  if (callback == NULL)
        -:  638:  {
    #####:  639:    callback = jerry_port_module_resolve;
        -:  640:  }
        -:  641:
    #####:  642:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  643:
    #####:  644:  if (module_p == NULL)
        -:  645:  {
    #####:  646:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  647:  }
        -:  648:
    #####:  649:  return jerry_return (ecma_module_link (module_p, callback, user_p));
        -:  650:#else /* !JERRY_MODULE_SYSTEM */
        -:  651:  JERRY_UNUSED (module_val);
        -:  652:  JERRY_UNUSED (callback);
        -:  653:  JERRY_UNUSED (user_p);
        -:  654:
    #####:  655:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  656:#endif /* JERRY_MODULE_SYSTEM */
        -:  657:} /* jerry_module_link */
        -:  658:
        -:  659:/**
        -:  660: * Evaluate a module and its dependencies. The module must be in linked state.
        -:  661: *
        -:  662: * Note:
        -:  663: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  664: *
        -:  665: * @return result of module bytecode execution - if evaluation was successful
        -:  666: *         error - otherwise
        -:  667: */
        -:  668:jerry_value_t
    #####:  669:jerry_module_evaluate (const jerry_value_t module_val) /**< root module */
        -:  670:{
        -:  671:  jerry_assert_api_available ();
        -:  672:
        -:  673:#if JERRY_MODULE_SYSTEM
    #####:  674:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  675:
    #####:  676:  if (module_p == NULL)
        -:  677:  {
    #####:  678:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  679:  }
        -:  680:
    #####:  681:  if (module_p->header.u.cls.u1.module_state != JERRY_MODULE_STATE_LINKED)
        -:  682:  {
    #####:  683:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module must be in linked state")));
        -:  684:  }
        -:  685:
    #####:  686:  return jerry_return (ecma_module_evaluate (module_p));
        -:  687:#else /* !JERRY_MODULE_SYSTEM */
        -:  688:  JERRY_UNUSED (module_val);
        -:  689:
    #####:  690:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  691:#endif /* JERRY_MODULE_SYSTEM */
        -:  692:} /* jerry_module_evaluate */
        -:  693:
        -:  694:/**
        -:  695: * Returns the current status of a module
        -:  696: *
        -:  697: * @return current status - if module_val is a module,
        -:  698: *         JERRY_MODULE_STATE_INVALID - otherwise
        -:  699: */
        -:  700:jerry_module_state_t
    #####:  701:jerry_module_get_state (const jerry_value_t module_val) /**< module object */
        -:  702:{
        -:  703:  jerry_assert_api_available ();
        -:  704:
        -:  705:#if JERRY_MODULE_SYSTEM
    #####:  706:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  707:
    #####:  708:  if (module_p == NULL)
        -:  709:  {
    #####:  710:    return JERRY_MODULE_STATE_INVALID;
        -:  711:  }
        -:  712:
    #####:  713:  return (jerry_module_state_t) module_p->header.u.cls.u1.module_state;
        -:  714:#else /* !JERRY_MODULE_SYSTEM */
        -:  715:  JERRY_UNUSED (module_val);
        -:  716:
    #####:  717:  return JERRY_MODULE_STATE_INVALID;
        -:  718:#endif /* JERRY_MODULE_SYSTEM */
        -:  719:} /* jerry_module_get_state */
        -:  720:
        -:  721:/**
        -:  722: * Sets a callback which is called after a module state is changed to linked, evaluated, or error.
        -:  723: */
        -:  724:void
    #####:  725:jerry_module_set_state_changed_callback (jerry_module_state_changed_callback_t callback, /**< callback */
        -:  726:                                         void *user_p) /**< pointer passed to the callback */
        -:  727:{
        -:  728:  jerry_assert_api_available ();
        -:  729:
        -:  730:#if JERRY_MODULE_SYSTEM
    #####:  731:  JERRY_CONTEXT (module_state_changed_callback_p) = callback;
    #####:  732:  JERRY_CONTEXT (module_state_changed_callback_user_p) = user_p;
        -:  733:#else /* !JERRY_MODULE_SYSTEM */
        -:  734:  JERRY_UNUSED (callback);
        -:  735:  JERRY_UNUSED (user_p);
        -:  736:#endif /* JERRY_MODULE_SYSTEM */
    #####:  737:} /* jerry_module_set_state_changed_callback */
        -:  738:
        -:  739:/**
        -:  740: * Sets a callback which is called when an import.meta expression of a module is evaluated the first time.
        -:  741: */
        -:  742:void
    #####:  743:jerry_module_set_import_meta_callback (jerry_module_import_meta_callback_t callback, /**< callback */
        -:  744:                                       void *user_p) /**< pointer passed to the callback */
        -:  745:{
        -:  746:  jerry_assert_api_available ();
        -:  747:
        -:  748:#if JERRY_MODULE_SYSTEM
    #####:  749:  JERRY_CONTEXT (module_import_meta_callback_p) = callback;
    #####:  750:  JERRY_CONTEXT (module_import_meta_callback_user_p) = user_p;
        -:  751:#else /* !JERRY_MODULE_SYSTEM */
        -:  752:  JERRY_UNUSED (callback);
        -:  753:  JERRY_UNUSED (user_p);
        -:  754:#endif /* JERRY_MODULE_SYSTEM */
    #####:  755:} /* jerry_module_set_import_meta_callback */
        -:  756:
        -:  757:/**
        -:  758: * Returns the number of import/export requests of a module
        -:  759: *
        -:  760: * @return number of import/export requests of a module
        -:  761: */
        -:  762:size_t
    #####:  763:jerry_module_get_number_of_requests (const jerry_value_t module_val) /**< module */
        -:  764:{
        -:  765:  jerry_assert_api_available ();
        -:  766:
        -:  767:#if JERRY_MODULE_SYSTEM
    #####:  768:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  769:
    #####:  770:  if (module_p == NULL)
        -:  771:  {
    #####:  772:    return 0;
        -:  773:  }
        -:  774:
    #####:  775:  size_t number_of_requests = 0;
        -:  776:
    #####:  777:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  778:
    #####:  779:  while (node_p != NULL)
        -:  780:  {
    #####:  781:    number_of_requests++;
    #####:  782:    node_p = node_p->next_p;
        -:  783:  }
        -:  784:
    #####:  785:  return number_of_requests;
        -:  786:#else /* !JERRY_MODULE_SYSTEM */
        -:  787:  JERRY_UNUSED (module_val);
        -:  788:
    #####:  789:  return 0;
        -:  790:#endif /* JERRY_MODULE_SYSTEM */
        -:  791:} /* jerry_module_get_number_of_requests */
        -:  792:
        -:  793:/**
        -:  794: * Returns the module request specified by the request_index argument
        -:  795: *
        -:  796: * Note:
        -:  797: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  798: *
        -:  799: * @return string - if the request has not been resolved yet,
        -:  800: *         module object - if the request has been resolved successfully,
        -:  801: *         error - otherwise
        -:  802: */
        -:  803:jerry_value_t
    #####:  804:jerry_module_get_request (const jerry_value_t module_val, /**< module */
        -:  805:                          size_t request_index) /**< request index */
        -:  806:{
        -:  807:  jerry_assert_api_available ();
        -:  808:
        -:  809:#if JERRY_MODULE_SYSTEM
    #####:  810:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  811:
    #####:  812:  if (module_p == NULL)
        -:  813:  {
    #####:  814:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  815:  }
        -:  816:
    #####:  817:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  818:
    #####:  819:  while (node_p != NULL)
        -:  820:  {
    #####:  821:    if (request_index == 0)
        -:  822:    {
    #####:  823:      return ecma_copy_value (node_p->u.path_or_module);
        -:  824:    }
        -:  825:
    #####:  826:    --request_index;
    #####:  827:    node_p = node_p->next_p;
        -:  828:  }
        -:  829:
    #####:  830:  return jerry_throw (ecma_raise_range_error (ECMA_ERR_MSG ("Request is not available")));
        -:  831:#else /* !JERRY_MODULE_SYSTEM */
        -:  832:  JERRY_UNUSED (module_val);
        -:  833:  JERRY_UNUSED (request_index);
        -:  834:
    #####:  835:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  836:#endif /* JERRY_MODULE_SYSTEM */
        -:  837:} /* jerry_module_get_request */
        -:  838:
        -:  839:/**
        -:  840: * Returns the namespace object of a module
        -:  841: *
        -:  842: * Note:
        -:  843: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  844: *
        -:  845: * @return object - if namespace object is available,
        -:  846: *         error - otherwise
        -:  847: */
        -:  848:jerry_value_t
    #####:  849:jerry_module_get_namespace (const jerry_value_t module_val) /**< module */
        -:  850:{
        -:  851:  jerry_assert_api_available ();
        -:  852:
        -:  853:#if JERRY_MODULE_SYSTEM
    #####:  854:  ecma_module_t *module_p = ecma_module_get_resolved_module (module_val);
        -:  855:
    #####:  856:  if (module_p == NULL)
        -:  857:  {
    #####:  858:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -:  859:  }
        -:  860:
    #####:  861:  if (module_p->header.u.cls.u1.module_state < JERRY_MODULE_STATE_LINKED
    #####:  862:      || module_p->header.u.cls.u1.module_state > JERRY_MODULE_STATE_EVALUATED)
        -:  863:  {
    #####:  864:    return jerry_throw (ecma_raise_range_error (ECMA_ERR_MSG ("Namespace object is not available")));
        -:  865:  }
        -:  866:
    #####:  867:  JERRY_ASSERT (module_p->namespace_object_p != NULL);
        -:  868:
    #####:  869:  ecma_ref_object (module_p->namespace_object_p);
    #####:  870:  return ecma_make_object_value (module_p->namespace_object_p);
        -:  871:#else /* !JERRY_MODULE_SYSTEM */
        -:  872:  JERRY_UNUSED (module_val);
        -:  873:
    #####:  874:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -:  875:#endif /* JERRY_MODULE_SYSTEM */
        -:  876:} /* jerry_module_get_namespace */
        -:  877:
        -:  878:/**
        -:  879: * Sets the callback which is called when dynamic imports are resolved
        -:  880: */
        -:  881:void
    #####:  882:jerry_module_set_import_callback (jerry_module_import_callback_t callback_p, /**< callback which handles
        -:  883:                                                                              *   dynamic import calls */
        -:  884:                                  void *user_p) /**< user pointer passed to the callback */
        -:  885:{
        -:  886:  jerry_assert_api_available ();
        -:  887:
        -:  888:#if JERRY_MODULE_SYSTEM
    #####:  889:  JERRY_CONTEXT (module_import_callback_p) = callback_p;
    #####:  890:  JERRY_CONTEXT (module_import_callback_user_p) = user_p;
        -:  891:#else /* !JERRY_MODULE_SYSTEM */
        -:  892:  JERRY_UNUSED (callback_p);
        -:  893:  JERRY_UNUSED (user_p);
        -:  894:#endif /* JERRY_MODULE_SYSTEM */
    #####:  895:} /* jerry_module_set_import_callback */
        -:  896:
        -:  897:/**
        -:  898: * Creates a native module with a list of exports. The initial state of the module is linked.
        -:  899: *
        -:  900: * Note:
        -:  901: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -:  902: *
        -:  903: * @return native module - if the module is successfully created,
        -:  904: *         error - otherwise
        -:  905: */
        -:  906:jerry_value_t
    #####:  907:jerry_native_module_create (jerry_native_module_evaluate_callback_t callback, /**< evaluation callback for
        -:  908:                                                                               *   native modules */
        -:  909:                            const jerry_value_t * const exports_p, /**< list of the exported bindings of the module,
        -:  910:                                                                    *   must be valid string identifiers */
        -:  911:                            size_t number_of_exports) /**< number of exports in the exports_p list */
        -:  912:{
        -:  913:  jerry_assert_api_available ();
        -:  914:
        -:  915:#if JERRY_MODULE_SYSTEM
    #####:  916:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
    #####:  917:  ecma_object_t *scope_p = ecma_create_decl_lex_env (ecma_get_global_environment (global_object_p));
    #####:  918:  ecma_module_names_t *local_exports_p = NULL;
        -:  919:
    #####:  920:  for (size_t i = 0; i < number_of_exports; i++)
        -:  921:  {
    #####:  922:    if (!ecma_is_value_string (exports_p[i]))
        -:  923:    {
    #####:  924:      ecma_deref_object (scope_p);
    #####:  925:      ecma_module_release_module_names (local_exports_p);
    #####:  926:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module exports must be string values")));
        -:  927:    }
        -:  928:
    #####:  929:    ecma_string_t *name_str_p = ecma_get_string_from_value (exports_p[i]);
        -:  930:
    #####:  931:    bool valid_identifier = false;
        -:  932:
    #####:  933:    ECMA_STRING_TO_UTF8_STRING (name_str_p, name_start_p, name_size);
        -:  934:
    #####:  935:    if (name_size > 0)
        -:  936:    {
    #####:  937:      const lit_utf8_byte_t *name_p = name_start_p;
    #####:  938:      const lit_utf8_byte_t *name_end_p = name_start_p + name_size;
    #####:  939:      lit_code_point_t code_point;
        -:  940:
    #####:  941:      lit_utf8_size_t size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  942:
    #####:  943:      if (lit_code_point_is_identifier_start (code_point))
        -:  944:      {
    #####:  945:        name_p += size;
        -:  946:
    #####:  947:        valid_identifier = true;
        -:  948:
    #####:  949:        while (name_p < name_end_p)
        -:  950:        {
    #####:  951:          size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  952:
    #####:  953:          if (!lit_code_point_is_identifier_part (code_point))
        -:  954:          {
    #####:  955:            valid_identifier = false;
    #####:  956:            break;
        -:  957:          }
        -:  958:
    #####:  959:          name_p += size;
        -:  960:        }
        -:  961:      }
        -:  962:    }
        -:  963:
    #####:  964:    ECMA_FINALIZE_UTF8_STRING (name_start_p, name_size);
        -:  965:
    #####:  966:    if (!valid_identifier)
        -:  967:    {
    #####:  968:      ecma_deref_object (scope_p);
    #####:  969:      ecma_module_release_module_names (local_exports_p);
    #####:  970:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Module exports must be valid identifiers")));
        -:  971:    }
        -:  972:
    #####:  973:    if (ecma_find_named_property (scope_p, name_str_p) != NULL)
        -:  974:    {
    #####:  975:      continue;
        -:  976:    }
        -:  977:
    #####:  978:    ecma_create_named_data_property (scope_p, name_str_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -:  979:
        -:  980:    ecma_module_names_t *new_export_p;
    #####:  981:    new_export_p = (ecma_module_names_t *) jmem_heap_alloc_block (sizeof (ecma_module_names_t));
        -:  982:
    #####:  983:    new_export_p->next_p = local_exports_p;
    #####:  984:    local_exports_p = new_export_p;
        -:  985:
    #####:  986:    ecma_ref_ecma_string (name_str_p);
    #####:  987:    new_export_p->imex_name_p = name_str_p;
        -:  988:
    #####:  989:    ecma_ref_ecma_string (name_str_p);
    #####:  990:    new_export_p->local_name_p = name_str_p;
        -:  991:  }
        -:  992:
    #####:  993:  ecma_module_t *module_p = ecma_module_create ();
        -:  994:
    #####:  995:  module_p->header.u.cls.u2.module_flags |= ECMA_MODULE_IS_NATIVE;
    #####:  996:  module_p->scope_p = scope_p;
    #####:  997:  module_p->local_exports_p = local_exports_p;
    #####:  998:  module_p->u.callback = callback;
        -:  999:
    #####: 1000:  ecma_deref_object (scope_p);
        -: 1001:
    #####: 1002:  return ecma_make_object_value (&module_p->header.object);
        -: 1003:
        -: 1004:#else /* !JERRY_MODULE_SYSTEM */
        -: 1005:  JERRY_UNUSED (callback);
        -: 1006:  JERRY_UNUSED (exports_p);
        -: 1007:  JERRY_UNUSED (number_of_exports);
        -: 1008:
    #####: 1009:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1010:#endif /* JERRY_MODULE_SYSTEM */
        -: 1011:} /* jerry_native_module_create */
        -: 1012:
        -: 1013:/**
        -: 1014: * Gets the value of an export which belongs to a native module.
        -: 1015: *
        -: 1016: * Note:
        -: 1017: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1018: *
        -: 1019: * @return value of the export - if success
        -: 1020: *         error - otherwise
        -: 1021: */
        -: 1022:jerry_value_t
    #####: 1023:jerry_native_module_get_export (const jerry_value_t native_module_val, /**< a native module object */
        -: 1024:                                const jerry_value_t export_name_val) /**< string identifier of the export */
        -: 1025:{
        -: 1026:  jerry_assert_api_available ();
        -: 1027:
        -: 1028:#if JERRY_MODULE_SYSTEM
    #####: 1029:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module_val);
        -: 1030:
    #####: 1031:  if (module_p == NULL)
        -: 1032:  {
    #####: 1033:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -: 1034:  }
        -: 1035:
    #####: 1036:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE)
    #####: 1037:      || !ecma_is_value_string (export_name_val))
        -: 1038:  {
    #####: 1039:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1040:  }
        -: 1041:
    #####: 1042:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p,
        -: 1043:                                                          ecma_get_string_from_value (export_name_val));
        -: 1044:
    #####: 1045:  if (property_p == NULL)
        -: 1046:  {
    #####: 1047:    return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_unknown_export_p)));
        -: 1048:  }
        -: 1049:
    #####: 1050:  return ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 1051:#else /* !JERRY_MODULE_SYSTEM */
        -: 1052:  JERRY_UNUSED (native_module_val);
        -: 1053:  JERRY_UNUSED (export_name_val);
        -: 1054:
    #####: 1055:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1056:#endif /* JERRY_MODULE_SYSTEM */
        -: 1057:} /* jerry_native_module_get_export */
        -: 1058:
        -: 1059:/**
        -: 1060: * Sets the value of an export which belongs to a native module.
        -: 1061: *
        -: 1062: * Note:
        -: 1063: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1064: *
        -: 1065: * @return true value - if the operation was successful
        -: 1066: *         error - otherwise
        -: 1067: */
        -: 1068:jerry_value_t
    #####: 1069:jerry_native_module_set_export (const jerry_value_t native_module_val, /**< a native module object */
        -: 1070:                                const jerry_value_t export_name_val, /**< string identifier of the export */
        -: 1071:                                const jerry_value_t value_to_set) /**< new value of the export */
        -: 1072:{
        -: 1073:  jerry_assert_api_available ();
        -: 1074:
        -: 1075:#if JERRY_MODULE_SYSTEM
    #####: 1076:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module_val);
        -: 1077:
    #####: 1078:  if (module_p == NULL)
        -: 1079:  {
    #####: 1080:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_not_module_p)));
        -: 1081:  }
        -: 1082:
    #####: 1083:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE)
    #####: 1084:      || !ecma_is_value_string (export_name_val)
    #####: 1085:      || ecma_is_value_error_reference (value_to_set))
        -: 1086:  {
    #####: 1087:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1088:  }
        -: 1089:
    #####: 1090:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p,
        -: 1091:                                                          ecma_get_string_from_value (export_name_val));
        -: 1092:
    #####: 1093:  if (property_p == NULL)
        -: 1094:  {
    #####: 1095:    return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_unknown_export_p)));
        -: 1096:  }
        -: 1097:
    #####: 1098:  ecma_named_data_property_assign_value (module_p->scope_p,
    #####: 1099:                                         ECMA_PROPERTY_VALUE_PTR (property_p),
        -: 1100:                                         value_to_set);
    #####: 1101:  return ECMA_VALUE_TRUE;
        -: 1102:#else /* !JERRY_MODULE_SYSTEM */
        -: 1103:  JERRY_UNUSED (native_module_val);
        -: 1104:  JERRY_UNUSED (export_name_val);
        -: 1105:  JERRY_UNUSED (value_to_set);
        -: 1106:
    #####: 1107:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_module_not_supported_p)));
        -: 1108:#endif /* JERRY_MODULE_SYSTEM */
        -: 1109:} /* jerry_native_module_set_export */
        -: 1110:
        -: 1111:/**
        -: 1112: * Run enqueued Promise jobs until the first thrown error or until all get executed.
        -: 1113: *
        -: 1114: * Note:
        -: 1115: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1116: *
        -: 1117: * @return result of last executed job, may be error value.
        -: 1118: */
        -: 1119:jerry_value_t
    #####: 1120:jerry_run_all_enqueued_jobs (void)
        -: 1121:{
        -: 1122:  jerry_assert_api_available ();
        -: 1123:
        -: 1124:#if JERRY_ESNEXT
    #####: 1125:  return ecma_process_all_enqueued_jobs ();
        -: 1126:#else /* !JERRY_ESNEXT */
    #####: 1127:  return ECMA_VALUE_UNDEFINED;
        -: 1128:#endif /* JERRY_ESNEXT */
        -: 1129:} /* jerry_run_all_enqueued_jobs */
        -: 1130:
        -: 1131:/**
        -: 1132: * Get global object
        -: 1133: *
        -: 1134: * Note:
        -: 1135: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 1136: *
        -: 1137: * @return api value of global object
        -: 1138: */
        -: 1139:jerry_value_t
        5: 1140:jerry_get_global_object (void)
        -: 1141:{
        -: 1142:  jerry_assert_api_available ();
        5: 1143:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        5: 1144:  ecma_ref_object (global_obj_p);
        5: 1145:  return ecma_make_object_value (global_obj_p);
        -: 1146:} /* jerry_get_global_object */
        -: 1147:
        -: 1148:/**
        -: 1149: * Check if the specified value is an abort value.
        -: 1150: *
        -: 1151: * @return true  - if both the error and abort values are set,
        -: 1152: *         false - otherwise
        -: 1153: */
        -: 1154:bool
    #####: 1155:jerry_value_is_abort (const jerry_value_t value) /**< api value */
        -: 1156:{
        -: 1157:  jerry_assert_api_available ();
        -: 1158:
    #####: 1159:  if (!ecma_is_value_error_reference (value))
        -: 1160:  {
    #####: 1161:    return false;
        -: 1162:  }
        -: 1163:
    #####: 1164:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 1165:
    #####: 1166:  return (error_ref_p->refs_and_type & ECMA_ERROR_API_ABORT) != 0;
        -: 1167:} /* jerry_value_is_abort */
        -: 1168:
        -: 1169:/**
        -: 1170: * Check if the specified value is an array object value.
        -: 1171: *
        -: 1172: * @return true  - if the specified value is an array object,
        -: 1173: *         false - otherwise
        -: 1174: */
        -: 1175:bool
    #####: 1176:jerry_value_is_array (const jerry_value_t value) /**< jerry api value */
        -: 1177:{
        -: 1178:  jerry_assert_api_available ();
        -: 1179:
    #####: 1180:  return (ecma_is_value_object (value)
    #####: 1181:          && ecma_get_object_base_type (ecma_get_object_from_value (value)) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -: 1182:} /* jerry_value_is_array */
        -: 1183:
        -: 1184:/**
        -: 1185: * Check if the specified value is boolean.
        -: 1186: *
        -: 1187: * @return true  - if the specified value is boolean,
        -: 1188: *         false - otherwise
        -: 1189: */
        -: 1190:bool
    #####: 1191:jerry_value_is_boolean (const jerry_value_t value) /**< api value */
        -: 1192:{
        -: 1193:  jerry_assert_api_available ();
        -: 1194:
    #####: 1195:  return ecma_is_value_boolean (value);
        -: 1196:} /* jerry_value_is_boolean */
        -: 1197:
        -: 1198:/**
        -: 1199: * Check if the specified value is true.
        -: 1200: *
        -: 1201: * @return true  - if the specified value is true
        -: 1202: *         false - otherwise
        -: 1203: */
        -: 1204:bool
    #####: 1205:jerry_value_is_true (const jerry_value_t value) /**< api value */
        -: 1206:{
        -: 1207:  jerry_assert_api_available ();
        -: 1208:
    #####: 1209:  return ecma_is_value_true (value);
        -: 1210:} /* jerry_value_is_true */
        -: 1211:
        -: 1212:/**
        -: 1213: * Check if the specified value is false.
        -: 1214: *
        -: 1215: * @return true  - if the specified value is false
        -: 1216: *         false - otherwise
        -: 1217: */
        -: 1218:bool
    #####: 1219:jerry_value_is_false (const jerry_value_t value) /**< api value */
        -: 1220:{
        -: 1221:  jerry_assert_api_available ();
        -: 1222:
    #####: 1223:  return ecma_is_value_false (value);
        -: 1224:} /* jerry_value_is_false */
        -: 1225:
        -: 1226:/**
        -: 1227: * Check if the specified value is a constructor function object value.
        -: 1228: *
        -: 1229: * @return true - if the specified value is a function value that implements [[Construct]],
        -: 1230: *         false - otherwise
        -: 1231: */
        -: 1232:bool
    #####: 1233:jerry_value_is_constructor (const jerry_value_t value) /**< jerry api value */
        -: 1234:{
        -: 1235:  jerry_assert_api_available ();
        -: 1236:
    #####: 1237:  return ecma_is_constructor (value);
        -: 1238:} /* jerry_value_is_constructor */
        -: 1239:
        -: 1240:/**
        -: 1241: * Check if the specified value is an error or abort value.
        -: 1242: *
        -: 1243: * @return true  - if the specified value is an error value,
        -: 1244: *         false - otherwise
        -: 1245: */
        -: 1246:bool
        6: 1247:jerry_value_is_error (const jerry_value_t value) /**< api value */
        -: 1248:{
        -: 1249:  jerry_assert_api_available ();
        -: 1250:
        6: 1251:  return ecma_is_value_error_reference (value);
        -: 1252:} /* jerry_value_is_error */
        -: 1253:
        -: 1254:/**
        -: 1255: * Check if the specified value is a function object value.
        -: 1256: *
        -: 1257: * @return true - if the specified value is callable,
        -: 1258: *         false - otherwise
        -: 1259: */
        -: 1260:bool
    #####: 1261:jerry_value_is_function (const jerry_value_t value) /**< api value */
        -: 1262:{
        -: 1263:  jerry_assert_api_available ();
        -: 1264:
    #####: 1265:  return ecma_op_is_callable (value);
        -: 1266:} /* jerry_value_is_function */
        -: 1267:
        -: 1268:/**
        -: 1269: * Check if the specified value is an async function object value.
        -: 1270: *
        -: 1271: * @return true - if the specified value is an async function,
        -: 1272: *         false - otherwise
        -: 1273: */
        -: 1274:bool
    #####: 1275:jerry_value_is_async_function (const jerry_value_t value) /**< api value */
        -: 1276:{
        -: 1277:  jerry_assert_api_available ();
        -: 1278:
        -: 1279:#if JERRY_ESNEXT
    #####: 1280:  if (ecma_is_value_object (value))
        -: 1281:  {
    #####: 1282:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1283:
    #####: 1284:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1285:    {
        -: 1286:      const ecma_compiled_code_t *bytecode_data_p;
    #####: 1287:      bytecode_data_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) obj_p);
    #####: 1288:      uint16_t type = CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags);
        -: 1289:
    #####: 1290:      return (type == CBC_FUNCTION_ASYNC
    #####: 1291:              || type == CBC_FUNCTION_ASYNC_ARROW
    #####: 1292:              || type == CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1293:    }
        -: 1294:  }
        -: 1295:#else /* !JERRY_ESNEXT */
        -: 1296:  JERRY_UNUSED (value);
        -: 1297:#endif /* JERRY_ESNEXT */
        -: 1298:
    #####: 1299:  return false;
        -: 1300:} /* jerry_value_is_async_function */
        -: 1301:
        -: 1302:/**
        -: 1303: * Check if the specified value is number.
        -: 1304: *
        -: 1305: * @return true  - if the specified value is number,
        -: 1306: *         false - otherwise
        -: 1307: */
        -: 1308:bool
    #####: 1309:jerry_value_is_number (const jerry_value_t value) /**< api value */
        -: 1310:{
        -: 1311:  jerry_assert_api_available ();
        -: 1312:
    #####: 1313:  return ecma_is_value_number (value);
        -: 1314:} /* jerry_value_is_number */
        -: 1315:
        -: 1316:/**
        -: 1317: * Check if the specified value is null.
        -: 1318: *
        -: 1319: * @return true  - if the specified value is null,
        -: 1320: *         false - otherwise
        -: 1321: */
        -: 1322:bool
    #####: 1323:jerry_value_is_null (const jerry_value_t value) /**< api value */
        -: 1324:{
        -: 1325:  jerry_assert_api_available ();
        -: 1326:
    #####: 1327:  return ecma_is_value_null (value);
        -: 1328:} /* jerry_value_is_null */
        -: 1329:
        -: 1330:/**
        -: 1331: * Check if the specified value is object.
        -: 1332: *
        -: 1333: * @return true  - if the specified value is object,
        -: 1334: *         false - otherwise
        -: 1335: */
        -: 1336:bool
    #####: 1337:jerry_value_is_object (const jerry_value_t value) /**< api value */
        -: 1338:{
        -: 1339:  jerry_assert_api_available ();
        -: 1340:
    #####: 1341:  return ecma_is_value_object (value);
        -: 1342:} /* jerry_value_is_object */
        -: 1343:
        -: 1344:/**
        -: 1345: * Check if the specified value is promise.
        -: 1346: *
        -: 1347: * @return true  - if the specified value is promise,
        -: 1348: *         false - otherwise
        -: 1349: */
        -: 1350:bool
    #####: 1351:jerry_value_is_promise (const jerry_value_t value) /**< api value */
        -: 1352:{
        -: 1353:  jerry_assert_api_available ();
        -: 1354:#if JERRY_ESNEXT
    #####: 1355:  return (ecma_is_value_object (value)
    #####: 1356:          && ecma_is_promise (ecma_get_object_from_value (value)));
        -: 1357:#else /* !JERRY_ESNEXT */
        -: 1358:  JERRY_UNUSED (value);
    #####: 1359:  return false;
        -: 1360:#endif /* JERRY_ESNEXT */
        -: 1361:} /* jerry_value_is_promise */
        -: 1362:
        -: 1363:/**
        -: 1364: * Check if the specified value is a proxy object.
        -: 1365: *
        -: 1366: * @return true  - if the specified value is a proxy object,
        -: 1367: *         false - otherwise
        -: 1368: */
        -: 1369:bool
    #####: 1370:jerry_value_is_proxy (const jerry_value_t value) /**< api value */
        -: 1371:{
        -: 1372:  jerry_assert_api_available ();
        -: 1373:#if JERRY_BUILTIN_PROXY
    #####: 1374:  return (ecma_is_value_object (value)
    #####: 1375:          && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (value)));
        -: 1376:#else /* !JERRY_BUILTIN_PROXY */
        -: 1377:  JERRY_UNUSED (value);
    #####: 1378:  return false;
        -: 1379:#endif /* JERRY_BUILTIN_PROXY */
        -: 1380:} /* jerry_value_is_proxy */
        -: 1381:
        -: 1382:/**
        -: 1383: * Check if the specified value is string.
        -: 1384: *
        -: 1385: * @return true  - if the specified value is string,
        -: 1386: *         false - otherwise
        -: 1387: */
        -: 1388:bool
    #####: 1389:jerry_value_is_string (const jerry_value_t value) /**< api value */
        -: 1390:{
        -: 1391:  jerry_assert_api_available ();
        -: 1392:
    #####: 1393:  return ecma_is_value_string (value);
        -: 1394:} /* jerry_value_is_string */
        -: 1395:
        -: 1396:/**
        -: 1397: * Check if the specified value is symbol.
        -: 1398: *
        -: 1399: * @return true  - if the specified value is symbol,
        -: 1400: *         false - otherwise
        -: 1401: */
        -: 1402:bool
    #####: 1403:jerry_value_is_symbol (const jerry_value_t value) /**< api value */
        -: 1404:{
        -: 1405:  jerry_assert_api_available ();
        -: 1406:
        -: 1407:#if JERRY_ESNEXT
    #####: 1408:  return ecma_is_value_symbol (value);
        -: 1409:#else /* !JERRY_ESNEXT */
        -: 1410:  JERRY_UNUSED (value);
    #####: 1411:  return false;
        -: 1412:#endif /* JERRY_ESNEXT */
        -: 1413:} /* jerry_value_is_symbol */
        -: 1414:
        -: 1415:/**
        -: 1416: * Check if the specified value is BigInt.
        -: 1417: *
        -: 1418: * @return true  - if the specified value is BigInt,
        -: 1419: *         false - otherwise
        -: 1420: */
        -: 1421:bool
    #####: 1422:jerry_value_is_bigint (const jerry_value_t value) /**< api value */
        -: 1423:{
        -: 1424:  jerry_assert_api_available ();
        -: 1425:
        -: 1426:#if JERRY_BUILTIN_BIGINT
    #####: 1427:  return ecma_is_value_bigint (value);
        -: 1428:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1429:  JERRY_UNUSED (value);
    #####: 1430:  return false;
        -: 1431:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1432:} /* jerry_value_is_bigint */
        -: 1433:
        -: 1434:/**
        -: 1435: * Check if the specified value is undefined.
        -: 1436: *
        -: 1437: * @return true  - if the specified value is undefined,
        -: 1438: *         false - otherwise
        -: 1439: */
        -: 1440:bool
    #####: 1441:jerry_value_is_undefined (const jerry_value_t value) /**< api value */
        -: 1442:{
        -: 1443:  jerry_assert_api_available ();
        -: 1444:
    #####: 1445:  return ecma_is_value_undefined (value);
        -: 1446:} /* jerry_value_is_undefined */
        -: 1447:
        -: 1448:/**
        -: 1449: * Perform the base type of the JavaScript value.
        -: 1450: *
        -: 1451: * @return jerry_type_t value
        -: 1452: */
        -: 1453:jerry_type_t
    #####: 1454:jerry_value_get_type (const jerry_value_t value) /**< input value to check */
        -: 1455:{
        -: 1456:  jerry_assert_api_available ();
        -: 1457:
    #####: 1458:  if (ecma_is_value_error_reference (value))
        -: 1459:  {
    #####: 1460:    return JERRY_TYPE_ERROR;
        -: 1461:  }
        -: 1462:
    #####: 1463:  lit_magic_string_id_t lit_id = ecma_get_typeof_lit_id (value);
        -: 1464:
    #####: 1465:  JERRY_ASSERT (lit_id != LIT_MAGIC_STRING__EMPTY);
        -: 1466:
    #####: 1467:  switch (lit_id)
        -: 1468:  {
    #####: 1469:    case LIT_MAGIC_STRING_UNDEFINED:
        -: 1470:    {
    #####: 1471:      return JERRY_TYPE_UNDEFINED;
        -: 1472:    }
    #####: 1473:    case LIT_MAGIC_STRING_BOOLEAN:
        -: 1474:    {
    #####: 1475:      return JERRY_TYPE_BOOLEAN;
        -: 1476:    }
    #####: 1477:    case LIT_MAGIC_STRING_NUMBER:
        -: 1478:    {
    #####: 1479:      return JERRY_TYPE_NUMBER;
        -: 1480:    }
    #####: 1481:    case LIT_MAGIC_STRING_STRING:
        -: 1482:    {
    #####: 1483:      return JERRY_TYPE_STRING;
        -: 1484:    }
        -: 1485:#if JERRY_ESNEXT
    #####: 1486:    case LIT_MAGIC_STRING_SYMBOL:
        -: 1487:    {
    #####: 1488:      return JERRY_TYPE_SYMBOL;
        -: 1489:    }
        -: 1490:#endif /* JERRY_ESNEXT */
    #####: 1491:    case LIT_MAGIC_STRING_FUNCTION:
        -: 1492:    {
    #####: 1493:      return JERRY_TYPE_FUNCTION;
        -: 1494:    }
        -: 1495:#if JERRY_BUILTIN_BIGINT
    #####: 1496:    case LIT_MAGIC_STRING_BIGINT:
        -: 1497:    {
    #####: 1498:      return JERRY_TYPE_BIGINT;
        -: 1499:    }
        -: 1500:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 1501:    default:
        -: 1502:    {
    #####: 1503:      JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_OBJECT);
        -: 1504:
        -: 1505:      /* Based on the ECMA 262 5.1 standard the 'null' value is an object.
        -: 1506:       * Thus we'll do an extra check for 'null' here.
        -: 1507:       */
    #####: 1508:      return ecma_is_value_null (value) ? JERRY_TYPE_NULL : JERRY_TYPE_OBJECT;
        -: 1509:    }
        -: 1510:  }
        -: 1511:} /* jerry_value_get_type */
        -: 1512:
        -: 1513:/**
        -: 1514: * Used by jerry_object_get_type to get the type of class objects
        -: 1515: */
        -: 1516:static const uint8_t jerry_class_object_type[] =
        -: 1517:{
        -: 1518:  /* These objects require custom property resolving. */
        -: 1519:  JERRY_OBJECT_TYPE_STRING, /**< type of ECMA_OBJECT_CLASS_STRING */
        -: 1520:  JERRY_OBJECT_TYPE_ARGUMENTS, /**< type of ECMA_OBJECT_CLASS_ARGUMENTS */
        -: 1521:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1522:  JERRY_OBJECT_TYPE_TYPEDARRAY, /**< type of ECMA_OBJECT_CLASS_TYPEDARRAY */
        -: 1523:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1524:#if JERRY_MODULE_SYSTEM
        -: 1525:  JERRY_OBJECT_TYPE_MODULE_NAMESPACE, /**< type of ECMA_OBJECT_CLASS_MODULE_NAMESPACE */
        -: 1526:#endif
        -: 1527:
        -: 1528:  /* These objects are marked by Garbage Collector. */
        -: 1529:#if JERRY_ESNEXT
        -: 1530:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_GENERATOR */
        -: 1531:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_ASYNC_GENERATOR */
        -: 1532:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_ARRAY_ITERATOR */
        -: 1533:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_SET_ITERATOR */
        -: 1534:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_MAP_ITERATOR */
        -: 1535:#if JERRY_BUILTIN_REGEXP
        -: 1536:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR */
        -: 1537:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1538:#endif /* JERRY_ESNEXT */
        -: 1539:#if JERRY_MODULE_SYSTEM
        -: 1540:  JERRY_OBJECT_TYPE_MODULE, /**< type of ECMA_OBJECT_CLASS_MODULE */
        -: 1541:#endif
        -: 1542:#if JERRY_ESNEXT
        -: 1543:  JERRY_OBJECT_TYPE_PROMISE, /**< type of ECMA_OBJECT_CLASS_PROMISE */
        -: 1544:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_PROMISE_CAPABILITY */
        -: 1545:#endif /* JERRY_ESNEXT */
        -: 1546:#if JERRY_BUILTIN_DATAVIEW
        -: 1547:  JERRY_OBJECT_TYPE_DATAVIEW, /**< type of ECMA_OBJECT_CLASS_DATAVIEW */
        -: 1548:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1549:#if JERRY_BUILTIN_CONTAINER
        -: 1550:  JERRY_OBJECT_TYPE_CONTAINER, /**< type of ECMA_OBJECT_CLASS_CONTAINER */
        -: 1551:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1552:
        -: 1553:  /* Normal objects. */
        -: 1554:  JERRY_OBJECT_TYPE_BOOLEAN, /**< type of ECMA_OBJECT_CLASS_BOOLEAN */
        -: 1555:  JERRY_OBJECT_TYPE_NUMBER, /**< type of ECMA_OBJECT_CLASS_NUMBER */
        -: 1556:  JERRY_OBJECT_TYPE_ERROR, /**< type of ECMA_OBJECT_CLASS_ERROR */
        -: 1557:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_INTERNAL_OBJECT */
        -: 1558:#if JERRY_PARSER
        -: 1559:  JERRY_OBJECT_TYPE_SCRIPT, /**< type of ECMA_OBJECT_CLASS_SCRIPT */
        -: 1560:#endif /* JERRY_PARSER */
        -: 1561:#if JERRY_BUILTIN_DATE
        -: 1562:  JERRY_OBJECT_TYPE_DATE, /**< type of ECMA_OBJECT_CLASS_DATE */
        -: 1563:#endif /* JERRY_BUILTIN_DATE */
        -: 1564:#if JERRY_BUILTIN_REGEXP
        -: 1565:  JERRY_OBJECT_TYPE_REGEXP, /**< type of ECMA_OBJECT_CLASS_REGEXP */
        -: 1566:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1567:#if JERRY_ESNEXT
        -: 1568:  JERRY_OBJECT_TYPE_SYMBOL, /**< type of ECMA_OBJECT_CLASS_SYMBOL */
        -: 1569:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_STRING_ITERATOR */
        -: 1570:#endif /* JERRY_ESNEXT */
        -: 1571:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1572:  JERRY_OBJECT_TYPE_ARRAYBUFFER, /**< type of ECMA_OBJECT_CLASS_ARRAY_BUFFER */
        -: 1573:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 1574:  JERRY_OBJECT_TYPE_SHARED_ARRAY_BUFFER, /**< type of ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER */
        -: 1575:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 1576:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1577:#if JERRY_BUILTIN_BIGINT
        -: 1578:  JERRY_OBJECT_TYPE_BIGINT, /**< type of ECMA_OBJECT_CLASS_BIGINT */
        -: 1579:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1580:#if JERRY_BUILTIN_WEAKREF
        -: 1581:  JERRY_OBJECT_TYPE_WEAKREF, /**< type of ECMA_OBJECT_CLASS_WEAKREF */
        -: 1582:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1583:};
        -: 1584:
        -: 1585:JERRY_STATIC_ASSERT (sizeof (jerry_class_object_type) == ECMA_OBJECT_CLASS__MAX,
        -: 1586:                     jerry_class_object_type_must_have_object_class_max_elements);
        -: 1587:
        -: 1588:/**
        -: 1589: * Get the object type of the given value
        -: 1590: *
        -: 1591: * @return JERRY_OBJECT_TYPE_NONE - if the given value is not an object
        -: 1592: *         jerry_object_type_t value - otherwise
        -: 1593: */
        -: 1594:jerry_object_type_t
    #####: 1595:jerry_object_get_type (const jerry_value_t value) /**< input value to check */
        -: 1596:{
        -: 1597:  jerry_assert_api_available ();
        -: 1598:
    #####: 1599:  if (!ecma_is_value_object (value))
        -: 1600:  {
    #####: 1601:    return JERRY_OBJECT_TYPE_NONE;
        -: 1602:  }
        -: 1603:
    #####: 1604:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1605:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1606:
    #####: 1607:  switch (ecma_get_object_type (obj_p))
        -: 1608:  {
    #####: 1609:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1610:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 1611:    {
    #####: 1612:      JERRY_ASSERT (ext_obj_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
    #####: 1613:      return jerry_class_object_type[ext_obj_p->u.cls.type];
        -: 1614:    }
    #####: 1615:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1616:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1617:    {
    #####: 1618:      return JERRY_OBJECT_TYPE_ARRAY;
        -: 1619:    }
        -: 1620:#if JERRY_ESNEXT
    #####: 1621:    case ECMA_OBJECT_TYPE_PROXY:
        -: 1622:    {
    #####: 1623:      return JERRY_OBJECT_TYPE_PROXY;
        -: 1624:    }
        -: 1625:#endif /* JERRY_ESNEXT */
    #####: 1626:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1627:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1628:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1629:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1630:    {
    #####: 1631:      return JERRY_OBJECT_TYPE_FUNCTION;
        -: 1632:    }
    #####: 1633:    default:
        -: 1634:    {
    #####: 1635:      break;
        -: 1636:    }
        -: 1637:  }
        -: 1638:
    #####: 1639:  return JERRY_OBJECT_TYPE_GENERIC;
        -: 1640:} /* jerry_object_get_type */
        -: 1641:
        -: 1642:/**
        -: 1643: * Get the function type of the given value
        -: 1644: *
        -: 1645: * @return JERRY_FUNCTION_TYPE_NONE - if the given value is not a function object
        -: 1646: *         jerry_function_type_t value - otherwise
        -: 1647: */
        -: 1648:jerry_function_type_t
    #####: 1649:jerry_function_get_type (const jerry_value_t value) /**< input value to check */
        -: 1650:{
        -: 1651:  jerry_assert_api_available ();
        -: 1652:
    #####: 1653:  if (ecma_is_value_object (value))
        -: 1654:  {
    #####: 1655:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1656:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1657:
    #####: 1658:    switch (ecma_get_object_type (obj_p))
        -: 1659:    {
    #####: 1660:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1661:      {
    #####: 1662:        return JERRY_FUNCTION_TYPE_BOUND;
        -: 1663:      }
    #####: 1664:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1665:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1666:      {
    #####: 1667:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1668:      }
    #####: 1669:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1670:      {
    #####: 1671:        const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_obj_p);
        -: 1672:
    #####: 1673:        switch (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags))
        -: 1674:        {
        -: 1675:#if JERRY_ESNEXT
    #####: 1676:          case CBC_FUNCTION_ARROW:
        -: 1677:          case CBC_FUNCTION_ASYNC_ARROW:
        -: 1678:          {
    #####: 1679:            return JERRY_FUNCTION_TYPE_ARROW;
        -: 1680:          }
    #####: 1681:          case CBC_FUNCTION_GENERATOR:
        -: 1682:          case CBC_FUNCTION_ASYNC_GENERATOR:
        -: 1683:          {
    #####: 1684:            return JERRY_FUNCTION_TYPE_GENERATOR;
        -: 1685:          }
        -: 1686:#endif /* JERRY_ESNEXT */
    #####: 1687:          case CBC_FUNCTION_ACCESSOR:
        -: 1688:          {
    #####: 1689:            return JERRY_FUNCTION_TYPE_ACCESSOR;
        -: 1690:          }
    #####: 1691:          default:
        -: 1692:          {
    #####: 1693:            break;
        -: 1694:          }
        -: 1695:        }
    #####: 1696:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1697:      }
    #####: 1698:      default:
        -: 1699:      {
    #####: 1700:        break;
        -: 1701:      }
        -: 1702:    }
    #####: 1703:  }
        -: 1704:
    #####: 1705:  return JERRY_FUNCTION_TYPE_NONE;
        -: 1706:} /* jerry_function_get_type */
        -: 1707:
        -: 1708:/**
        -: 1709: * Get the itearator type of the given value
        -: 1710: *
        -: 1711: * @return JERRY_ITERATOR_TYPE_NONE - if the given value is not an iterator object
        -: 1712: *         jerry_iterator_type_t value - otherwise
        -: 1713: */
        -: 1714:jerry_iterator_type_t
    #####: 1715:jerry_iterator_get_type (const jerry_value_t value) /**< input value to check */
        -: 1716:{
        -: 1717:  jerry_assert_api_available ();
        -: 1718:
        -: 1719:#if JERRY_ESNEXT
    #####: 1720:  if (ecma_is_value_object (value))
        -: 1721:  {
    #####: 1722:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1723:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1724:
    #####: 1725:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_CLASS)
        -: 1726:    {
    #####: 1727:      switch (ext_obj_p->u.cls.type)
        -: 1728:      {
    #####: 1729:        case ECMA_OBJECT_CLASS_ARRAY_ITERATOR:
        -: 1730:        {
    #####: 1731:          return JERRY_ITERATOR_TYPE_ARRAY;
        -: 1732:        }
        -: 1733:#if JERRY_BUILTIN_CONTAINER
    #####: 1734:        case ECMA_OBJECT_CLASS_SET_ITERATOR:
        -: 1735:        {
    #####: 1736:          return JERRY_ITERATOR_TYPE_SET;
        -: 1737:        }
    #####: 1738:        case ECMA_OBJECT_CLASS_MAP_ITERATOR:
        -: 1739:        {
    #####: 1740:          return JERRY_ITERATOR_TYPE_MAP;
        -: 1741:        }
        -: 1742:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 1743:        case ECMA_OBJECT_CLASS_STRING_ITERATOR:
        -: 1744:        {
    #####: 1745:          return JERRY_ITERATOR_TYPE_STRING;
        -: 1746:        }
    #####: 1747:        default:
        -: 1748:        {
    #####: 1749:          break;
        -: 1750:        }
        -: 1751:      }
    #####: 1752:    }
        -: 1753:  }
        -: 1754:#else /* !JERRY_ESNEXT */
        -: 1755:  JERRY_UNUSED (value);
        -: 1756:#endif /* JERRY_ESNEXT */
        -: 1757:
    #####: 1758:  return JERRY_ITERATOR_TYPE_NONE;
        -: 1759:} /* jerry_iterator_get_type */
        -: 1760:
        -: 1761:/**
        -: 1762: * Check if the specified feature is enabled.
        -: 1763: *
        -: 1764: * @return true  - if the specified feature is enabled,
        -: 1765: *         false - otherwise
        -: 1766: */
        -: 1767:bool
    #####: 1768:jerry_is_feature_enabled (const jerry_feature_t feature) /**< feature to check */
        -: 1769:{
    #####: 1770:  JERRY_ASSERT (feature < JERRY_FEATURE__COUNT);
        -: 1771:
        -: 1772:  return (false
        -: 1773:#if JERRY_CPOINTER_32_BIT
        -: 1774:          || feature == JERRY_FEATURE_CPOINTER_32_BIT
        -: 1775:#endif /* JERRY_CPOINTER_32_BIT */
        -: 1776:#if JERRY_ERROR_MESSAGES
    #####: 1777:          || feature == JERRY_FEATURE_ERROR_MESSAGES
        -: 1778:#endif /* JERRY_ERROR_MESSAGES */
        -: 1779:#if JERRY_PARSER
    #####: 1780:          || feature == JERRY_FEATURE_JS_PARSER
        -: 1781:#endif /* JERRY_PARSER */
        -: 1782:#if JERRY_MEM_STATS
    #####: 1783:          || feature == JERRY_FEATURE_MEM_STATS
        -: 1784:#endif /* JERRY_MEM_STATS */
        -: 1785:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1786:          || feature == JERRY_FEATURE_PARSER_DUMP
        -: 1787:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1788:#if JERRY_REGEXP_DUMP_BYTE_CODE
        -: 1789:          || feature == JERRY_FEATURE_REGEXP_DUMP
        -: 1790:#endif /* JERRY_REGEXP_DUMP_BYTE_CODE */
        -: 1791:#if JERRY_SNAPSHOT_SAVE
    #####: 1792:          || feature == JERRY_FEATURE_SNAPSHOT_SAVE
        -: 1793:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1794:#if JERRY_SNAPSHOT_EXEC
    #####: 1795:          || feature == JERRY_FEATURE_SNAPSHOT_EXEC
        -: 1796:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1797:#if JERRY_DEBUGGER
        -: 1798:          || feature == JERRY_FEATURE_DEBUGGER
        -: 1799:#endif /* JERRY_DEBUGGER */
        -: 1800:#if JERRY_VM_EXEC_STOP
    #####: 1801:          || feature == JERRY_FEATURE_VM_EXEC_STOP
        -: 1802:#endif /* JERRY_VM_EXEC_STOP */
        -: 1803:#if JERRY_VM_THROW
        -: 1804:          || feature == JERRY_FEATURE_VM_THROW
        -: 1805:#endif /* JERRY_VM_THROW */
        -: 1806:#if JERRY_BUILTIN_JSON
    #####: 1807:          || feature == JERRY_FEATURE_JSON
        -: 1808:#endif /* JERRY_BUILTIN_JSON */
        -: 1809:#if JERRY_ESNEXT
    #####: 1810:          || feature == JERRY_FEATURE_PROMISE
    #####: 1811:          || feature == JERRY_FEATURE_SYMBOL
        -: 1812:#endif /* JERRY_ESNEXT */
        -: 1813:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 1814:          || feature == JERRY_FEATURE_TYPEDARRAY
        -: 1815:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1816:#if JERRY_BUILTIN_DATAVIEW
    #####: 1817:          || feature == JERRY_FEATURE_DATAVIEW
        -: 1818:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1819:#if JERRY_BUILTIN_PROXY
    #####: 1820:          || feature == JERRY_FEATURE_PROXY
        -: 1821:#endif /* JERRY_BUILTIN_PROXY */
        -: 1822:#if JERRY_BUILTIN_DATE
    #####: 1823:          || feature == JERRY_FEATURE_DATE
        -: 1824:#endif /* JERRY_BUILTIN_DATE */
        -: 1825:#if JERRY_BUILTIN_REGEXP
    #####: 1826:          || feature == JERRY_FEATURE_REGEXP
        -: 1827:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1828:#if JERRY_LINE_INFO
    #####: 1829:          || feature == JERRY_FEATURE_LINE_INFO
        -: 1830:#endif /* JERRY_LINE_INFO */
        -: 1831:#if JERRY_LOGGING
    #####: 1832:          || feature == JERRY_FEATURE_LOGGING
        -: 1833:#endif /* JERRY_LOGGING */
        -: 1834:#if JERRY_BUILTIN_GLOBAL_THIS
    #####: 1835:          || feature == JERRY_FEATURE_GLOBAL_THIS
        -: 1836:#endif /* JERRY_BUILTIN_GLOBAL_THIS */
        -: 1837:#if JERRY_BUILTIN_CONTAINER
    #####: 1838:          || feature == JERRY_FEATURE_MAP
    #####: 1839:          || feature == JERRY_FEATURE_SET
    #####: 1840:          || feature == JERRY_FEATURE_WEAKMAP
    #####: 1841:          || feature == JERRY_FEATURE_WEAKSET
        -: 1842:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1843:#if JERRY_BUILTIN_WEAKREF
    #####: 1844:          || feature == JERRY_FEATURE_WEAKREF
        -: 1845:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1846:#if JERRY_BUILTIN_BIGINT
    #####: 1847:          || feature == JERRY_FEATURE_BIGINT
        -: 1848:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1849:#if JERRY_BUILTIN_REALMS
    #####: 1850:          || feature == JERRY_FEATURE_REALM
        -: 1851:#endif /* JERRY_BUILTIN_REALMS */
        -: 1852:#if JERRY_PROMISE_CALLBACK
    #####: 1853:          || feature == JERRY_FEATURE_PROMISE_CALLBACK
        -: 1854:#endif /* JERRY_PROMISE_CALLBACK */
        -: 1855:#if JERRY_MODULE_SYSTEM
    #####: 1856:          || feature == JERRY_FEATURE_MODULE
        -: 1857:#endif /* JERRY_MODULE_SYSTEM */
        -: 1858:#if JERRY_FUNCTION_TO_STRING
    #####: 1859:          || feature == JERRY_FEATURE_FUNCTION_TO_STRING
        -: 1860:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1861:          );
        -: 1862:} /* jerry_is_feature_enabled */
        -: 1863:
        -: 1864:/**
        -: 1865: * Perform binary operation on the given operands (==, ===, <, >, etc.).
        -: 1866: *
        -: 1867: * @return error - if argument has an error flag or operation is unsuccessful or unsupported
        -: 1868: *         true/false - the result of the binary operation on the given operands otherwise
        -: 1869: */
        -: 1870:jerry_value_t
    #####: 1871:jerry_binary_operation (jerry_binary_operation_t op, /**< operation */
        -: 1872:                        const jerry_value_t lhs, /**< first operand */
        -: 1873:                        const jerry_value_t rhs) /**< second operand */
        -: 1874:{
        -: 1875:  jerry_assert_api_available ();
        -: 1876:
    #####: 1877:  if (ecma_is_value_error_reference (lhs) || ecma_is_value_error_reference (rhs))
        -: 1878:  {
    #####: 1879:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 1880:  }
        -: 1881:
    #####: 1882:  switch (op)
        -: 1883:  {
    #####: 1884:    case JERRY_BIN_OP_EQUAL:
        -: 1885:    {
    #####: 1886:      return jerry_return (ecma_op_abstract_equality_compare (lhs, rhs));
        -: 1887:    }
    #####: 1888:    case JERRY_BIN_OP_STRICT_EQUAL:
        -: 1889:    {
    #####: 1890:      return ecma_make_boolean_value (ecma_op_strict_equality_compare (lhs, rhs));
        -: 1891:    }
    #####: 1892:    case JERRY_BIN_OP_LESS:
        -: 1893:    {
    #####: 1894:      return jerry_return (opfunc_relation (lhs, rhs, true, false));
        -: 1895:    }
    #####: 1896:    case JERRY_BIN_OP_LESS_EQUAL:
        -: 1897:    {
    #####: 1898:      return jerry_return (opfunc_relation (lhs, rhs, false, true));
        -: 1899:    }
    #####: 1900:    case JERRY_BIN_OP_GREATER:
        -: 1901:    {
    #####: 1902:      return jerry_return (opfunc_relation (lhs, rhs, false, false));
        -: 1903:    }
    #####: 1904:    case JERRY_BIN_OP_GREATER_EQUAL:
        -: 1905:    {
    #####: 1906:      return jerry_return (opfunc_relation (lhs, rhs, true, true));
        -: 1907:    }
    #####: 1908:    case JERRY_BIN_OP_INSTANCEOF:
        -: 1909:    {
    #####: 1910:      if (!ecma_is_value_object (lhs)
    #####: 1911:          || !ecma_op_is_callable (rhs))
        -: 1912:      {
    #####: 1913:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 1914:      }
        -: 1915:
    #####: 1916:      ecma_object_t *proto_obj_p = ecma_get_object_from_value (rhs);
    #####: 1917:      return jerry_return (ecma_op_object_has_instance (proto_obj_p, lhs));
        -: 1918:    }
    #####: 1919:    case JERRY_BIN_OP_ADD:
        -: 1920:    {
    #####: 1921:      return jerry_return (opfunc_addition (lhs, rhs));
        -: 1922:    }
    #####: 1923:    case JERRY_BIN_OP_SUB:
        -: 1924:    case JERRY_BIN_OP_MUL:
        -: 1925:    case JERRY_BIN_OP_DIV:
        -: 1926:    case JERRY_BIN_OP_REM:
        -: 1927:    {
    #####: 1928:      return jerry_return (do_number_arithmetic (op - ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET, lhs, rhs));
        -: 1929:    }
    #####: 1930:    default:
        -: 1931:    {
    #####: 1932:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Unsupported binary operation")));
        -: 1933:    }
        -: 1934:  }
        -: 1935:} /* jerry_binary_operation */
        -: 1936:
        -: 1937:/**
        -: 1938: * Create abort from an api value.
        -: 1939: *
        -: 1940: * Create abort value from an api value. If the second argument is true
        -: 1941: * it will release the input api value.
        -: 1942: *
        -: 1943: * @return api abort value
        -: 1944: */
        -: 1945:jerry_value_t
    #####: 1946:jerry_create_abort_from_value (jerry_value_t value, /**< api value */
        -: 1947:                               bool release) /**< release api value */
        -: 1948:{
        -: 1949:  jerry_assert_api_available ();
        -: 1950:
    #####: 1951:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1952:  {
        -: 1953:    /* This is a rare case so it is optimized for
        -: 1954:     * binary size rather than performance. */
    #####: 1955:    if (jerry_value_is_abort (value))
        -: 1956:    {
    #####: 1957:      return release ? value : jerry_acquire_value (value);
        -: 1958:    }
        -: 1959:
    #####: 1960:    value = jerry_get_value_from_error (value, release);
    #####: 1961:    release = true;
        -: 1962:  }
        -: 1963:
    #####: 1964:  if (!release)
        -: 1965:  {
    #####: 1966:    value = ecma_copy_value (value);
        -: 1967:  }
        -: 1968:
    #####: 1969:  return ecma_create_error_reference (value, ECMA_ERROR_API_ABORT);
        -: 1970:} /* jerry_create_abort_from_value */
        -: 1971:
        -: 1972:/**
        -: 1973: * Create error from an api value.
        -: 1974: *
        -: 1975: * Create error value from an api value. If the second argument is true
        -: 1976: * it will release the input api value.
        -: 1977: *
        -: 1978: * @return api error value
        -: 1979: */
        -: 1980:jerry_value_t
    #####: 1981:jerry_create_error_from_value (jerry_value_t value, /**< api value */
        -: 1982:                               bool release) /**< release api value */
        -: 1983:{
        -: 1984:  jerry_assert_api_available ();
        -: 1985:
    #####: 1986:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 1987:  {
        -: 1988:    /* This is a rare case so it is optimized for
        -: 1989:     * binary size rather than performance. */
    #####: 1990:    if (!jerry_value_is_abort (value))
        -: 1991:    {
    #####: 1992:      return release ? value : jerry_acquire_value (value);
        -: 1993:    }
        -: 1994:
    #####: 1995:    value = jerry_get_value_from_error (value, release);
    #####: 1996:    release = true;
        -: 1997:  }
        -: 1998:
    #####: 1999:  if (!release)
        -: 2000:  {
    #####: 2001:    value = ecma_copy_value (value);
        -: 2002:  }
        -: 2003:
    #####: 2004:  return ecma_create_error_reference (value, 0);
        -: 2005:} /* jerry_create_error_from_value */
        -: 2006:
        -: 2007:/**
        -: 2008: * Get the value from an error value.
        -: 2009: *
        -: 2010: * Extract the api value from an error. If the second argument is true
        -: 2011: * it will release the input error value.
        -: 2012: *
        -: 2013: * Note:
        -: 2014: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2015: *
        -: 2016: * @return jerry_value_t value
        -: 2017: */
        -: 2018:jerry_value_t
    #####: 2019:jerry_get_value_from_error (jerry_value_t value, /**< api value */
        -: 2020:                            bool release) /**< release api value */
        -: 2021:{
        -: 2022:  jerry_assert_api_available ();
        -: 2023:
    #####: 2024:  if (!ecma_is_value_error_reference (value))
        -: 2025:  {
    #####: 2026:    return release ? value : ecma_copy_value (value);
        -: 2027:  }
        -: 2028:
    #####: 2029:  jerry_value_t ret_val = jerry_acquire_value (ecma_get_extended_primitive_from_value (value)->u.value);
        -: 2030:
    #####: 2031:  if (release)
        -: 2032:  {
    #####: 2033:    jerry_release_value (value);
        -: 2034:  }
    #####: 2035:  return ret_val;
        -: 2036:} /* jerry_get_value_from_error */
        -: 2037:
        -: 2038:/**
        -: 2039: * Set new decorator callback for Error objects. The decorator can
        -: 2040: * create or update any properties of the newly created Error object.
        -: 2041: */
        -: 2042:void
    #####: 2043:jerry_set_error_object_created_callback (jerry_error_object_created_callback_t callback, /**< new callback */
        -: 2044:                                         void *user_p) /**< user pointer passed to the callback */
        -: 2045:{
        -: 2046:  jerry_assert_api_available ();
        -: 2047:
    #####: 2048:  JERRY_CONTEXT (error_object_created_callback_p) = callback;
    #####: 2049:  JERRY_CONTEXT (error_object_created_callback_user_p) = user_p;
    #####: 2050:} /* jerry_set_error_object_created_callback */
        -: 2051:
        -: 2052:/**
        -: 2053: * When JERRY_VM_THROW is enabled, the callback passed to this
        -: 2054: * function is called when an error is thrown in ECMAScript code.
        -: 2055: */
    #####: 2056:void jerry_set_vm_throw_callback (jerry_vm_throw_callback_t throw_cb, /**< callback which is called on throws */
        -: 2057:                                  void *user_p) /**< pointer passed to the function */
        -: 2058:{
        -: 2059:#if JERRY_VM_THROW
    #####: 2060:  JERRY_CONTEXT (vm_throw_callback_p) = throw_cb;
    #####: 2061:  JERRY_CONTEXT (vm_throw_callback_user_p) = user_p;
        -: 2062:#else /* !JERRY_VM_THROW */
        -: 2063:  JERRY_UNUSED (throw_cb);
        -: 2064:  JERRY_UNUSED (user_p);
        -: 2065:#endif /* JERRY_VM_THROW */
    #####: 2066:} /* jerry_set_vm_throw_callback */
        -: 2067:
        -: 2068:/**
        -: 2069: * Checks whether the callback set by jerry_set_vm_throw_callback captured the error
        -: 2070: *
        -: 2071: * @return true, if the vm throw callback captured the error
        -: 2072: *         false, otherwise
        -: 2073: */
        -: 2074:bool
    #####: 2075:jerry_error_is_throw_captured (jerry_value_t value) /**< api value */
        -: 2076:{
        -: 2077:  jerry_assert_api_available ();
        -: 2078:
        -: 2079:#if JERRY_VM_THROW
    #####: 2080:  if (!ecma_is_value_error_reference (value))
        -: 2081:  {
        -: 2082:    return false;
        -: 2083:  }
        -: 2084:
    #####: 2085:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 2086:
    #####: 2087:  return (error_ref_p->refs_and_type & ECMA_ERROR_API_THROW_CAPTURED) != 0;
        -: 2088:#else /* !JERRY_VM_THROW */
        -: 2089:  JERRY_UNUSED (value);
    #####: 2090:  return false;
        -: 2091:#endif /* JERRY_VM_THROW */
        -: 2092:} /* jerry_error_is_throw_captured */
        -: 2093:
        -: 2094:/**
        -: 2095: * Sets whether the callback set by jerry_set_vm_throw_callback should capture the error or not
        -: 2096: */
        -: 2097:void
    #####: 2098:jerry_error_set_throw_capture (jerry_value_t value, /**< api value */
        -: 2099:                               bool should_capture) /**< callback should capture this error */
        -: 2100:{
        -: 2101:  jerry_assert_api_available ();
        -: 2102:
        -: 2103:#if JERRY_VM_THROW
    #####: 2104:  if (!ecma_is_value_error_reference (value))
        -: 2105:  {
        -: 2106:    return;
        -: 2107:  }
        -: 2108:
    #####: 2109:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 2110:
    #####: 2111:  if (should_capture)
        -: 2112:  {
    #####: 2113:    error_ref_p->refs_and_type &= ~(uint32_t) ECMA_ERROR_API_THROW_CAPTURED;
    #####: 2114:    return;
        -: 2115:  }
        -: 2116:
    #####: 2117:  error_ref_p->refs_and_type |= ECMA_ERROR_API_THROW_CAPTURED;
        -: 2118:#else /* !JERRY_VM_THROW */
        -: 2119:  JERRY_UNUSED (value);
        -: 2120:  JERRY_UNUSED (should_capture);
        -: 2121:#endif /* JERRY_VM_THROW */
    #####: 2122:} /* jerry_error_set_throw_capture */
        -: 2123:
        -: 2124:/**
        -: 2125: * Return the type of the Error object if possible.
        -: 2126: *
        -: 2127: * @return one of the jerry_error_t value as the type of the Error object
        -: 2128: *         JERRY_ERROR_NONE - if the input value is not an Error object
        -: 2129: */
        -: 2130:jerry_error_t
    #####: 2131:jerry_get_error_type (jerry_value_t value) /**< api value */
        -: 2132:{
    #####: 2133:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2134:  {
    #####: 2135:    value = ecma_get_extended_primitive_from_value (value)->u.value;
        -: 2136:  }
        -: 2137:
    #####: 2138:  if (!ecma_is_value_object (value))
        -: 2139:  {
    #####: 2140:    return JERRY_ERROR_NONE;
        -: 2141:  }
        -: 2142:
    #####: 2143:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 2144:  jerry_error_t error_type = ecma_get_error_type (object_p);
        -: 2145:
    #####: 2146:  return (jerry_error_t) error_type;
        -: 2147:} /* jerry_get_error_type */
        -: 2148:
        -: 2149:/**
        -: 2150: * Get number from the specified value as a double.
        -: 2151: *
        -: 2152: * @return stored number as double
        -: 2153: */
        -: 2154:double
    #####: 2155:jerry_get_number_value (const jerry_value_t value) /**< api value */
        -: 2156:{
        -: 2157:  jerry_assert_api_available ();
        -: 2158:
    #####: 2159:  if (!ecma_is_value_number (value))
        -: 2160:  {
    #####: 2161:    return 0;
        -: 2162:  }
        -: 2163:
    #####: 2164:  return (double) ecma_get_number_from_value (value);
        -: 2165:} /* jerry_get_number_value */
        -: 2166:
        -: 2167:/**
        -: 2168: * Call ToBoolean operation on the api value.
        -: 2169: *
        -: 2170: * @return true  - if the logical value is true
        -: 2171: *         false - otherwise
        -: 2172: */
        -: 2173:bool
    #####: 2174:jerry_value_to_boolean (const jerry_value_t value) /**< input value */
        -: 2175:{
        -: 2176:  jerry_assert_api_available ();
        -: 2177:
    #####: 2178:  if (ecma_is_value_error_reference (value))
        -: 2179:  {
    #####: 2180:    return false;
        -: 2181:  }
        -: 2182:
    #####: 2183:  return ecma_op_to_boolean (value);
        -: 2184:} /* jerry_value_to_boolean */
        -: 2185:
        -: 2186:/**
        -: 2187: * Call ToNumber operation on the api value.
        -: 2188: *
        -: 2189: * Note:
        -: 2190: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2191: *
        -: 2192: * @return converted number value - if success
        -: 2193: *         thrown error - otherwise
        -: 2194: */
        -: 2195:jerry_value_t
    #####: 2196:jerry_value_to_number (const jerry_value_t value) /**< input value */
        -: 2197:{
        -: 2198:  jerry_assert_api_available ();
        -: 2199:
    #####: 2200:  if (ecma_is_value_error_reference (value))
        -: 2201:  {
    #####: 2202:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2203:  }
        -: 2204:
    #####: 2205:  ecma_number_t num;
    #####: 2206:  ecma_value_t ret_value = ecma_op_to_number (value, &num);
        -: 2207:
    #####: 2208:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 2209:  {
    #####: 2210:    return ecma_create_error_reference_from_context ();
        -: 2211:  }
        -: 2212:
    #####: 2213:  return ecma_make_number_value (num);
        -: 2214:} /* jerry_value_to_number */
        -: 2215:
        -: 2216:/**
        -: 2217: * Call ToObject operation on the api value.
        -: 2218: *
        -: 2219: * Note:
        -: 2220: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2221: *
        -: 2222: * @return converted object value - if success
        -: 2223: *         thrown error - otherwise
        -: 2224: */
        -: 2225:jerry_value_t
    #####: 2226:jerry_value_to_object (const jerry_value_t value) /**< input value */
        -: 2227:{
        -: 2228:  jerry_assert_api_available ();
        -: 2229:
    #####: 2230:  if (ecma_is_value_error_reference (value))
        -: 2231:  {
    #####: 2232:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2233:  }
        -: 2234:
    #####: 2235:  return jerry_return (ecma_op_to_object (value));
        -: 2236:} /* jerry_value_to_object */
        -: 2237:
        -: 2238:/**
        -: 2239: * Call ToPrimitive operation on the api value.
        -: 2240: *
        -: 2241: * Note:
        -: 2242: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2243: *
        -: 2244: * @return converted primitive value - if success
        -: 2245: *         thrown error - otherwise
        -: 2246: */
        -: 2247:jerry_value_t
    #####: 2248:jerry_value_to_primitive (const jerry_value_t value) /**< input value */
        -: 2249:{
        -: 2250:  jerry_assert_api_available ();
        -: 2251:
    #####: 2252:  if (ecma_is_value_error_reference (value))
        -: 2253:  {
    #####: 2254:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2255:  }
        -: 2256:
    #####: 2257:  return jerry_return (ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_NO));
        -: 2258:} /* jerry_value_to_primitive */
        -: 2259:
        -: 2260:/**
        -: 2261: * Call the ToString ecma builtin operation on the api value.
        -: 2262: *
        -: 2263: * Note:
        -: 2264: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2265: *
        -: 2266: * @return converted string value - if success
        -: 2267: *         thrown error - otherwise
        -: 2268: */
        -: 2269:jerry_value_t
    #####: 2270:jerry_value_to_string (const jerry_value_t value) /**< input value */
        -: 2271:{
        -: 2272:
        -: 2273:  jerry_assert_api_available ();
        -: 2274:
    #####: 2275:  if (ecma_is_value_error_reference (value))
        -: 2276:  {
    #####: 2277:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2278:  }
        -: 2279:
    #####: 2280:  ecma_string_t *str_p = ecma_op_to_string (value);
    #####: 2281:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 2282:  {
    #####: 2283:    return ecma_create_error_reference_from_context ();
        -: 2284:  }
        -: 2285:
    #####: 2286:  return ecma_make_string_value (str_p);
        -: 2287:} /* jerry_value_to_string */
        -: 2288:
        -: 2289:/**
        -: 2290: * Call the BigInt constructor ecma builtin operation on the api value.
        -: 2291: *
        -: 2292: * Note:
        -: 2293: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2294: *
        -: 2295: * @return BigInt value - if success
        -: 2296: *         thrown error - otherwise
        -: 2297: */
        -: 2298:jerry_value_t
    #####: 2299:jerry_value_to_bigint (const jerry_value_t value) /**< input value */
        -: 2300:{
        -: 2301:  jerry_assert_api_available ();
        -: 2302:
        -: 2303:#if JERRY_BUILTIN_BIGINT
    #####: 2304:  if (ecma_is_value_error_reference (value))
        -: 2305:  {
    #####: 2306:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 2307:  }
        -: 2308:
    #####: 2309:  return jerry_return (ecma_bigint_to_bigint (value, true));
        -: 2310:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2311:  JERRY_UNUSED (value);
    #####: 2312:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_bigint_not_supported_p)));
        -: 2313:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2314:} /* jerry_value_to_bigint */
        -: 2315:
        -: 2316:/**
        -: 2317: * Convert any number to integer number.
        -: 2318: *
        -: 2319: * Note:
        -: 2320: *      For non-number values 0 is returned.
        -: 2321: *
        -: 2322: * @return integer representation of the number.
        -: 2323: */
        -: 2324:double
    #####: 2325:jerry_value_as_integer (const jerry_value_t value) /**< input value */
        -: 2326:{
        -: 2327:  jerry_assert_api_available ();
        -: 2328:
    #####: 2329:  if (!ecma_is_value_number (value))
        -: 2330:  {
    #####: 2331:    return 0;
        -: 2332:  }
        -: 2333:
    #####: 2334:  double number = ecma_get_number_from_value (value);
        -: 2335:
    #####: 2336:  if (ecma_number_is_nan (number))
        -: 2337:  {
    #####: 2338:    return ECMA_NUMBER_ZERO;
        -: 2339:  }
        -: 2340:
    #####: 2341:  if (ecma_number_is_zero (number) || ecma_number_is_infinity (number))
        -: 2342:  {
    #####: 2343:    return number;
        -: 2344:  }
        -: 2345:
    #####: 2346:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number));
        -: 2347:
    #####: 2348:  return ecma_number_is_negative (number) ? -floor_fabs : floor_fabs;
        -: 2349:} /* jerry_value_as_integer */
        -: 2350:
        -: 2351:/**
        -: 2352: * Convert any number to int32 number.
        -: 2353: *
        -: 2354: * Note:
        -: 2355: *      For non-number values 0 is returned.
        -: 2356: *
        -: 2357: * @return int32 representation of the number.
        -: 2358: */
        -: 2359:int32_t
    #####: 2360:jerry_value_as_int32 (const jerry_value_t value) /**< input value */
        -: 2361:{
        -: 2362:  jerry_assert_api_available ();
        -: 2363:
    #####: 2364:  if (!ecma_is_value_number (value))
        -: 2365:  {
    #####: 2366:    return 0;
        -: 2367:  }
        -: 2368:
    #####: 2369:  return ecma_number_to_int32 (ecma_get_number_from_value (value));
        -: 2370:} /* jerry_value_as_int32 */
        -: 2371:
        -: 2372:/**
        -: 2373: * Convert any number to uint32 number.
        -: 2374: *
        -: 2375: * Note:
        -: 2376: *      For non-number values 0 is returned.
        -: 2377: *
        -: 2378: * @return uint32 representation of the number.
        -: 2379: */
        -: 2380:uint32_t
    #####: 2381:jerry_value_as_uint32 (const jerry_value_t value) /**< input value */
        -: 2382:{
        -: 2383:  jerry_assert_api_available ();
        -: 2384:
    #####: 2385:  if (!ecma_is_value_number (value))
        -: 2386:  {
    #####: 2387:    return 0;
        -: 2388:  }
        -: 2389:
    #####: 2390:  return ecma_number_to_uint32 (ecma_get_number_from_value (value));
        -: 2391:} /* jerry_value_as_uint32 */
        -: 2392:
        -: 2393:/**
        -: 2394: * Acquire specified Jerry API value.
        -: 2395: *
        -: 2396: * Note:
        -: 2397: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2398: *
        -: 2399: * @return acquired api value
        -: 2400: */
        -: 2401:jerry_value_t
    #####: 2402:jerry_acquire_value (jerry_value_t value) /**< API value */
        -: 2403:{
        -: 2404:  jerry_assert_api_available ();
        -: 2405:
    #####: 2406:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2407:  {
    #####: 2408:    ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
    #####: 2409:    return value;
        -: 2410:  }
        -: 2411:
    #####: 2412:  return ecma_copy_value (value);
        -: 2413:} /* jerry_acquire_value */
        -: 2414:
        -: 2415:/**
        -: 2416: * Release specified Jerry API value
        -: 2417: */
        -: 2418:void
       21: 2419:jerry_release_value (jerry_value_t value) /**< API value */
        -: 2420:{
        -: 2421:  jerry_assert_api_available ();
        -: 2422:
       21: 2423:  if (JERRY_UNLIKELY (ecma_is_value_error_reference (value)))
        -: 2424:  {
    #####: 2425:    ecma_deref_error_reference (ecma_get_extended_primitive_from_value (value));
    #####: 2426:    return;
        -: 2427:  }
        -: 2428:
       21: 2429:  ecma_free_value (value);
        -: 2430:} /* jerry_release_value */
        -: 2431:
        -: 2432:/**
        -: 2433: * Create an array object value
        -: 2434: *
        -: 2435: * Note:
        -: 2436: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2437: *
        -: 2438: * @return value of the constructed array object
        -: 2439: */
        -: 2440:jerry_value_t
    #####: 2441:jerry_create_array (uint32_t size) /**< size of array */
        -: 2442:{
        -: 2443:  jerry_assert_api_available ();
        -: 2444:
    #####: 2445:  ecma_object_t *array_p = ecma_op_new_array_object (size);
    #####: 2446:  return ecma_make_object_value (array_p);
        -: 2447:} /* jerry_create_array */
        -: 2448:
        -: 2449:/**
        -: 2450: * Create a jerry_value_t representing a boolean value from the given boolean parameter.
        -: 2451: *
        -: 2452: * @return value of the created boolean
        -: 2453: */
        -: 2454:jerry_value_t
    #####: 2455:jerry_create_boolean (bool value) /**< bool value from which a jerry_value_t will be created */
        -: 2456:{
        -: 2457:  jerry_assert_api_available ();
        -: 2458:
    #####: 2459:  return jerry_return (ecma_make_boolean_value (value));
        -: 2460:} /* jerry_create_boolean */
        -: 2461:
        -: 2462:/**
        -: 2463: * Create an error object
        -: 2464: *
        -: 2465: * Note:
        -: 2466: *      - returned value must be freed with jerry_release_value, when it is no longer needed
        -: 2467: *      - the error flag is set for the returned value
        -: 2468: *
        -: 2469: * @return value of the constructed error object
        -: 2470: */
        -: 2471:jerry_value_t
    #####: 2472:jerry_create_error (jerry_error_t error_type, /**< type of error */
        -: 2473:                    const jerry_char_t *message_p) /**< value of 'message' property
        -: 2474:                                                    *   of constructed error object */
        -: 2475:{
    #####: 2476:  return jerry_create_error_sz (error_type,
        -: 2477:                                (lit_utf8_byte_t *) message_p,
        -: 2478:                                lit_zt_utf8_string_size (message_p));
        -: 2479:} /* jerry_create_error */
        -: 2480:
        -: 2481:/**
        -: 2482: * Create an error object
        -: 2483: *
        -: 2484: * Note:
        -: 2485: *      - returned value must be freed with jerry_release_value, when it is no longer needed
        -: 2486: *      - the error flag is set for the returned value
        -: 2487: *
        -: 2488: * @return value of the constructed error object
        -: 2489: */
        -: 2490:jerry_value_t
    #####: 2491:jerry_create_error_sz (jerry_error_t error_type, /**< type of error */
        -: 2492:                       const jerry_char_t *message_p, /**< value of 'message' property
        -: 2493:                                                       *   of constructed error object */
        -: 2494:                       jerry_size_t message_size) /**< size of the message in bytes */
        -: 2495:{
        -: 2496:  jerry_assert_api_available ();
        -: 2497:
    #####: 2498:  if (message_p == NULL || message_size == 0)
        -: 2499:  {
    #####: 2500:    return ecma_create_error_object_reference (ecma_new_standard_error ((jerry_error_t) error_type, NULL));
        -: 2501:  }
        -: 2502:  else
        -: 2503:  {
    #####: 2504:    ecma_string_t *message_string_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) message_p,
        -: 2505:                                                                      (lit_utf8_size_t) message_size);
        -: 2506:
    #####: 2507:    ecma_object_t *error_object_p = ecma_new_standard_error ((jerry_error_t) error_type,
        -: 2508:                                                             message_string_p);
        -: 2509:
    #####: 2510:    ecma_deref_ecma_string (message_string_p);
        -: 2511:
    #####: 2512:    return ecma_create_error_object_reference (error_object_p);
        -: 2513:  }
        -: 2514:} /* jerry_create_error_sz */
        -: 2515:
        -: 2516:/**
        -: 2517: * Create an external function object
        -: 2518: *
        -: 2519: * Note:
        -: 2520: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2521: *
        -: 2522: * @return value of the constructed function object
        -: 2523: */
        -: 2524:jerry_value_t
        5: 2525:jerry_create_external_function (jerry_external_handler_t handler_p) /**< pointer to native handler
        -: 2526:                                                                     *   for the function */
        -: 2527:{
        -: 2528:  jerry_assert_api_available ();
        -: 2529:
        5: 2530:  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler_p);
        5: 2531:  return ecma_make_object_value (func_obj_p);
        -: 2532:} /* jerry_create_external_function */
        -: 2533:
        -: 2534:/**
        -: 2535: * Creates a jerry_value_t representing a number value.
        -: 2536: *
        -: 2537: * Note:
        -: 2538: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2539: *
        -: 2540: * @return jerry_value_t created from the given double argument.
        -: 2541: */
        -: 2542:jerry_value_t
    #####: 2543:jerry_create_number (double value) /**< double value from which a jerry_value_t will be created */
        -: 2544:{
        -: 2545:  jerry_assert_api_available ();
        -: 2546:
    #####: 2547:  return ecma_make_number_value ((ecma_number_t) value);
        -: 2548:} /* jerry_create_number */
        -: 2549:
        -: 2550:/**
        -: 2551: * Creates a jerry_value_t representing a positive or negative infinity value.
        -: 2552: *
        -: 2553: * Note:
        -: 2554: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2555: *
        -: 2556: * @return jerry_value_t representing an infinity value.
        -: 2557: */
        -: 2558:jerry_value_t
    #####: 2559:jerry_create_number_infinity (bool sign) /**< true for negative Infinity
        -: 2560:                                          *   false for positive Infinity */
        -: 2561:{
        -: 2562:  jerry_assert_api_available ();
        -: 2563:
    #####: 2564:  return ecma_make_number_value (ecma_number_make_infinity (sign));
        -: 2565:} /* jerry_create_number_infinity */
        -: 2566:
        -: 2567:/**
        -: 2568: * Creates a jerry_value_t representing a not-a-number value.
        -: 2569: *
        -: 2570: * Note:
        -: 2571: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2572: *
        -: 2573: * @return jerry_value_t representing a not-a-number value.
        -: 2574: */
        -: 2575:jerry_value_t
    #####: 2576:jerry_create_number_nan (void)
        -: 2577:{
        -: 2578:  jerry_assert_api_available ();
        -: 2579:
    #####: 2580:  return ecma_make_nan_value ();
        -: 2581:} /* jerry_create_number_nan */
        -: 2582:
        -: 2583:/**
        -: 2584: * Creates a jerry_value_t representing an undefined value.
        -: 2585: *
        -: 2586: * @return value of undefined
        -: 2587: */
        -: 2588:jerry_value_t
    #####: 2589:jerry_create_undefined (void)
        -: 2590:{
        -: 2591:  jerry_assert_api_available ();
        -: 2592:
    #####: 2593:  return ECMA_VALUE_UNDEFINED;
        -: 2594:} /* jerry_create_undefined */
        -: 2595:
        -: 2596:/**
        -: 2597: * Creates and returns a jerry_value_t with type null object.
        -: 2598: *
        -: 2599: * @return jerry_value_t representing null
        -: 2600: */
        -: 2601:jerry_value_t
    #####: 2602:jerry_create_null (void)
        -: 2603:{
        -: 2604:  jerry_assert_api_available ();
        -: 2605:
    #####: 2606:  return ECMA_VALUE_NULL;
        -: 2607:} /* jerry_create_null */
        -: 2608:
        -: 2609:/**
        -: 2610: * Create new JavaScript object, like with new Object().
        -: 2611: *
        -: 2612: * Note:
        -: 2613: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2614: *
        -: 2615: * @return value of the created object
        -: 2616: */
        -: 2617:jerry_value_t
    #####: 2618:jerry_create_object (void)
        -: 2619:{
        -: 2620:  jerry_assert_api_available ();
        -: 2621:
    #####: 2622:  return ecma_make_object_value (ecma_op_create_object_object_noarg ());
        -: 2623:} /* jerry_create_object */
        -: 2624:
        -: 2625:/**
        -: 2626: * Create an empty Promise object which can be resolve/reject later
        -: 2627: * by calling jerry_resolve_or_reject_promise.
        -: 2628: *
        -: 2629: * Note:
        -: 2630: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2631: *
        -: 2632: * @return value of the created object
        -: 2633: */
        -: 2634:jerry_value_t
    #####: 2635:jerry_create_promise (void)
        -: 2636:{
        -: 2637:  jerry_assert_api_available ();
        -: 2638:
        -: 2639:#if JERRY_ESNEXT
    #####: 2640:  ecma_value_t promise_value = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL);
        -: 2641:
    #####: 2642:  return promise_value;
        -: 2643:#else /* !JERRY_ESNEXT */
    #####: 2644:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 2645:#endif /* JERRY_ESNEXT */
        -: 2646:} /* jerry_create_promise */
        -: 2647:
        -: 2648:/**
        -: 2649: * Create a new Proxy object with the given target and handler
        -: 2650: *
        -: 2651: * Note:
        -: 2652: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2653: *
        -: 2654: * @return value of the created Proxy object
        -: 2655: */
        -: 2656:jerry_value_t
    #####: 2657:jerry_create_proxy (const jerry_value_t target, /**< target argument */
        -: 2658:                    const jerry_value_t handler) /**< handler argument */
        -: 2659:{
        -: 2660:  jerry_assert_api_available ();
        -: 2661:
    #####: 2662:  if (ecma_is_value_error_reference (target)
    #####: 2663:      || ecma_is_value_error_reference (handler))
        -: 2664:  {
    #####: 2665:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2666:  }
        -: 2667:
        -: 2668:#if JERRY_BUILTIN_PROXY
    #####: 2669:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, 0);
    #####: 2670:  return jerry_return (proxy_p == NULL ? ECMA_VALUE_ERROR : ecma_make_object_value (proxy_p));
        -: 2671:#else /* !JERRY_BUILTIN_PROXY */
    #####: 2672:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Proxy is not supported")));
        -: 2673:#endif /* JERRY_BUILTIN_PROXY */
        -: 2674:} /* jerry_create_proxy */
        -: 2675:
        -: 2676:#if JERRY_BUILTIN_PROXY
        -: 2677:
        -: 2678:JERRY_STATIC_ASSERT ((int) JERRY_PROXY_SKIP_RESULT_VALIDATION == (int) ECMA_PROXY_SKIP_RESULT_VALIDATION,
        -: 2679:                     jerry_and_ecma_proxy_skip_result_validation_must_be_equal);
        -: 2680:
        -: 2681:#endif /* JERRY_BUILTIN_PROXY */
        -: 2682:
        -: 2683:/**
        -: 2684: * Create a new Proxy object with the given target, handler, and special options
        -: 2685: *
        -: 2686: * Note:
        -: 2687: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2688: *
        -: 2689: * @return value of the created Proxy object
        -: 2690: */
        -: 2691:jerry_value_t
    #####: 2692:jerry_create_special_proxy (const jerry_value_t target, /**< target argument */
        -: 2693:                            const jerry_value_t handler, /**< handler argument */
        -: 2694:                            uint32_t options) /**< jerry_proxy_object_options_t option bits */
        -: 2695:{
        -: 2696:  jerry_assert_api_available ();
        -: 2697:
    #####: 2698:  if (ecma_is_value_error_reference (target)
    #####: 2699:      || ecma_is_value_error_reference (handler))
        -: 2700:  {
    #####: 2701:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2702:  }
        -: 2703:
        -: 2704:#if JERRY_BUILTIN_PROXY
    #####: 2705:  options &= JERRY_PROXY_SKIP_RESULT_VALIDATION;
        -: 2706:
    #####: 2707:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, options);
    #####: 2708:  return jerry_return (proxy_p == NULL ? ECMA_VALUE_ERROR : ecma_make_object_value (proxy_p));
        -: 2709:#else /* !JERRY_BUILTIN_PROXY */
        -: 2710:  JERRY_UNUSED (options);
    #####: 2711:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Proxy is not supported")));
        -: 2712:#endif /* JERRY_BUILTIN_PROXY */
        -: 2713:} /* jerry_create_special_proxy */
        -: 2714:
        -: 2715:/**
        -: 2716: * Create string from a valid UTF-8 string
        -: 2717: *
        -: 2718: * Note:
        -: 2719: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2720: *
        -: 2721: * @return value of the created string
        -: 2722: */
        -: 2723:jerry_value_t
    #####: 2724:jerry_create_string_from_utf8 (const jerry_char_t *str_p) /**< pointer to string */
        -: 2725:{
    #####: 2726:  return jerry_create_string_sz_from_utf8 (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));
        -: 2727:} /* jerry_create_string_from_utf8 */
        -: 2728:
        -: 2729:/**
        -: 2730: * Create string from a valid UTF-8 string
        -: 2731: *
        -: 2732: * Note:
        -: 2733: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2734: *
        -: 2735: * @return value of the created string
        -: 2736: */
        -: 2737:jerry_value_t
    #####: 2738:jerry_create_string_sz_from_utf8 (const jerry_char_t *str_p, /**< pointer to string */
        -: 2739:                                  jerry_size_t str_size) /**< string size */
        -: 2740:{
        -: 2741:  jerry_assert_api_available ();
        -: 2742:
    #####: 2743:  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 ((lit_utf8_byte_t *) str_p,
        -: 2744:                                                                                 (lit_utf8_size_t) str_size);
        -: 2745:
    #####: 2746:  return ecma_make_string_value (ecma_str_p);
        -: 2747:} /* jerry_create_string_sz_from_utf8 */
        -: 2748:
        -: 2749:/**
        -: 2750: * Create string from a valid CESU-8 string
        -: 2751: *
        -: 2752: * Note:
        -: 2753: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2754: *
        -: 2755: * @return value of the created string
        -: 2756: */
        -: 2757:jerry_value_t
        5: 2758:jerry_create_string (const jerry_char_t *str_p) /**< pointer to string */
        -: 2759:{
        5: 2760:  return jerry_create_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p));
        -: 2761:} /* jerry_create_string */
        -: 2762:
        -: 2763:/**
        -: 2764: * Create string from a valid CESU-8 string
        -: 2765: *
        -: 2766: * Note:
        -: 2767: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2768: *
        -: 2769: * @return value of the created string
        -: 2770: */
        -: 2771:jerry_value_t
        6: 2772:jerry_create_string_sz (const jerry_char_t *str_p, /**< pointer to string */
        -: 2773:                        jerry_size_t str_size) /**< string size */
        -: 2774:{
        -: 2775:  jerry_assert_api_available ();
        -: 2776:
        6: 2777:  ecma_string_t *ecma_str_p = ecma_new_ecma_string_from_utf8 ((lit_utf8_byte_t *) str_p,
        -: 2778:                                                              (lit_utf8_size_t) str_size);
        6: 2779:  return ecma_make_string_value (ecma_str_p);
        -: 2780:} /* jerry_create_string_sz */
        -: 2781:
        -: 2782:/**
        -: 2783: * Create external string from a valid CESU-8 string
        -: 2784: *
        -: 2785: * Note:
        -: 2786: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 2787: *
        -: 2788: * @return value of the created external string
        -: 2789: */
        -: 2790:jerry_value_t
    #####: 2791:jerry_create_external_string (const jerry_char_t *str_p, /**< pointer to string */
        -: 2792:                              void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2793:{
    #####: 2794:  return jerry_create_external_string_sz (str_p, lit_zt_utf8_string_size ((lit_utf8_byte_t *) str_p), user_p);
        -: 2795:} /* jerry_create_external_string */
        -: 2796:
        -: 2797:/**
        -: 2798: * Create external string from a valid CESU-8 string
        -: 2799: *
        -: 2800: * Note:
        -: 2801: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2802: *
        -: 2803: * @return value of the created external string
        -: 2804: */
        -: 2805:jerry_value_t
    #####: 2806:jerry_create_external_string_sz (const jerry_char_t *str_p, /**< pointer to string */
        -: 2807:                                 jerry_size_t str_size, /**< string size */
        -: 2808:                                 void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2809:{
        -: 2810:  jerry_assert_api_available ();
        -: 2811:
    #####: 2812:  ecma_string_t *ecma_str_p = ecma_new_ecma_external_string_from_cesu8 ((lit_utf8_byte_t *) str_p,
        -: 2813:                                                                        (lit_utf8_size_t) str_size,
        -: 2814:                                                                        user_p);
    #####: 2815:  return ecma_make_string_value (ecma_str_p);
        -: 2816:} /* jerry_create_external_string_sz */
        -: 2817:
        -: 2818:/**
        -: 2819: * Create symbol from an api value
        -: 2820: *
        -: 2821: * Note:
        -: 2822: *      The given argument is converted to string. This operation can throw an error.
        -: 2823: *      returned value must be freed with jerry_release_value when it is no longer needed.
        -: 2824: *
        -: 2825: * @return value of the created symbol, if success
        -: 2826: *         thrown error, otherwise
        -: 2827: */
        -: 2828:jerry_value_t
    #####: 2829:jerry_create_symbol (const jerry_value_t value) /**< api value */
        -: 2830:{
        -: 2831:  jerry_assert_api_available ();
        -: 2832:
    #####: 2833:  if (ecma_is_value_error_reference (value))
        -: 2834:  {
    #####: 2835:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 2836:  }
        -: 2837:
        -: 2838:#if JERRY_ESNEXT
    #####: 2839:  return jerry_return (ecma_op_create_symbol (&value, 1));
        -: 2840:#else /* !JERRY_ESNEXT */
    #####: 2841:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 2842:#endif /* JERRY_ESNEXT */
        -: 2843:} /* jerry_create_symbol */
        -: 2844:
        -: 2845:/**
        -: 2846: * Create BigInt from a sequence of uint64 digits
        -: 2847: *
        -: 2848: * @return value of the created bigint, if success
        -: 2849: *         thrown error, otherwise
        -: 2850: */
        -: 2851:jerry_value_t
    #####: 2852:jerry_create_bigint (const uint64_t *digits_p, /**< BigInt digits (lowest digit first) */
        -: 2853:                     uint32_t size, /**< number of BigInt digits */
        -: 2854:                     bool sign) /**< sign bit, true if the result should be negative */
        -: 2855:{
        -: 2856:  jerry_assert_api_available ();
        -: 2857:
        -: 2858:#if JERRY_BUILTIN_BIGINT
    #####: 2859:  return jerry_return (ecma_bigint_create_from_digits (digits_p, size, sign));
        -: 2860:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2861:  JERRY_UNUSED (digits_p);
        -: 2862:  JERRY_UNUSED (size);
        -: 2863:  JERRY_UNUSED (sign);
    #####: 2864:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_bigint_not_supported_p)));
        -: 2865:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2866:} /* jerry_create_bigint */
        -: 2867:
        -: 2868:/**
        -: 2869: * Calculates the size of the given pattern and creates a RegExp object.
        -: 2870: *
        -: 2871: * @return value of the constructed RegExp object.
        -: 2872: */
        -: 2873:jerry_value_t
    #####: 2874:jerry_create_regexp (const jerry_char_t *pattern_p, /**< zero-terminated UTF-8 string as RegExp pattern */
        -: 2875:                     uint16_t flags) /**< optional RegExp flags */
        -: 2876:{
    #####: 2877:  return jerry_create_regexp_sz (pattern_p, lit_zt_utf8_string_size (pattern_p), flags);
        -: 2878:} /* jerry_create_regexp */
        -: 2879:
        -: 2880:/**
        -: 2881: * Creates a RegExp object with the given pattern and flags.
        -: 2882: *
        -: 2883: * @return value of the constructed RegExp object.
        -: 2884: */
        -: 2885:jerry_value_t
    #####: 2886:jerry_create_regexp_sz (const jerry_char_t *pattern_p, /**< zero-terminated UTF-8 string as RegExp pattern */
        -: 2887:                        jerry_size_t pattern_size, /**< length of the pattern */
        -: 2888:                        uint16_t flags) /**< optional RegExp flags */
        -: 2889:{
        -: 2890:  jerry_assert_api_available ();
        -: 2891:
        -: 2892:#if JERRY_BUILTIN_REGEXP
    #####: 2893:  if (!lit_is_valid_utf8_string (pattern_p, pattern_size, true))
        -: 2894:  {
    #####: 2895:    return jerry_throw (ecma_raise_common_error (ECMA_ERR_MSG ("Input must be a valid utf8 string")));
        -: 2896:  }
        -: 2897:
    #####: 2898:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -: 2899:
    #####: 2900:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -: 2901:  {
    #####: 2902:    return ECMA_VALUE_ERROR;
        -: 2903:  }
        -: 2904:
    #####: 2905:  ecma_string_t *ecma_pattern = ecma_new_ecma_string_from_utf8 (pattern_p, pattern_size);
        -: 2906:
    #####: 2907:  jerry_value_t ret_val = ecma_op_create_regexp_with_flags (regexp_obj_p,
        -: 2908:                                                            ecma_make_string_value (ecma_pattern),
        -: 2909:                                                            flags);
    #####: 2910:  ecma_deref_ecma_string (ecma_pattern);
        -: 2911:
    #####: 2912:  return ret_val;
        -: 2913:
        -: 2914:#else /* !JERRY_BUILTIN_REGEXP */
        -: 2915:  JERRY_UNUSED (pattern_p);
        -: 2916:  JERRY_UNUSED (pattern_size);
        -: 2917:  JERRY_UNUSED (flags);
        -: 2918:
        -: 2919:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("RegExp is not supported")));
        -: 2920:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2921:} /* jerry_create_regexp_sz */
        -: 2922:
        -: 2923:/**
        -: 2924: * Creates a new realm (global object).
        -: 2925: *
        -: 2926: * @return new realm object
        -: 2927: */
        -: 2928:jerry_value_t
    #####: 2929:jerry_create_realm (void)
        -: 2930:{
        -: 2931:  jerry_assert_api_available ();
        -: 2932:
        -: 2933:#if JERRY_BUILTIN_REALMS
    #####: 2934:  ecma_global_object_t *global_object_p = ecma_builtin_create_global_object ();
    #####: 2935:  return ecma_make_object_value ((ecma_object_t *) global_object_p);
        -: 2936:#else /* !JERRY_BUILTIN_REALMS */
    #####: 2937:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Realms are disabled")));
        -: 2938:#endif /* JERRY_BUILTIN_REALMS */
        -: 2939:} /* jerry_create_realm */
        -: 2940:
        -: 2941:/**
        -: 2942: * Get length of an array object
        -: 2943: *
        -: 2944: * Note:
        -: 2945: *      Returns 0, if the value parameter is not an array object.
        -: 2946: *
        -: 2947: * @return length of the given array
        -: 2948: */
        -: 2949:uint32_t
    #####: 2950:jerry_get_array_length (const jerry_value_t value) /**< api value */
        -: 2951:{
        -: 2952:  jerry_assert_api_available ();
        -: 2953:
    #####: 2954:  if (!jerry_value_is_object (value))
        -: 2955:  {
    #####: 2956:    return 0;
        -: 2957:  }
        -: 2958:
    #####: 2959:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 2960:
    #####: 2961:  if (JERRY_LIKELY (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY))
        -: 2962:  {
    #####: 2963:    return ecma_array_get_length (object_p);
        -: 2964:  }
        -: 2965:
    #####: 2966:  return 0;
        -: 2967:} /* jerry_get_array_length */
        -: 2968:
        -: 2969:/**
        -: 2970: * Get size of Jerry string
        -: 2971: *
        -: 2972: * Note:
        -: 2973: *      Returns 0, if the value parameter is not a string.
        -: 2974: *
        -: 2975: * @return number of bytes in the buffer needed to represent the string
        -: 2976: */
        -: 2977:jerry_size_t
    #####: 2978:jerry_get_string_size (const jerry_value_t value) /**< input string */
        -: 2979:{
        -: 2980:  jerry_assert_api_available ();
        -: 2981:
    #####: 2982:  if (!ecma_is_value_string (value))
        -: 2983:  {
    #####: 2984:    return 0;
        -: 2985:  }
        -: 2986:
    #####: 2987:  return ecma_string_get_size (ecma_get_string_from_value (value));
        -: 2988:} /* jerry_get_string_size */
        -: 2989:
        -: 2990:/**
        -: 2991: * Get UTF-8 encoded string size from Jerry string
        -: 2992: *
        -: 2993: * Note:
        -: 2994: *      Returns 0, if the value parameter is not a string.
        -: 2995: *
        -: 2996: * @return number of bytes in the buffer needed to represent the UTF-8 encoded string
        -: 2997: */
        -: 2998:jerry_size_t
    #####: 2999:jerry_get_utf8_string_size (const jerry_value_t value) /**< input string */
        -: 3000:{
        -: 3001:  jerry_assert_api_available ();
        -: 3002:
    #####: 3003:  if (!ecma_is_value_string (value))
        -: 3004:  {
    #####: 3005:    return 0;
        -: 3006:  }
        -: 3007:
    #####: 3008:  return ecma_string_get_utf8_size (ecma_get_string_from_value (value));
        -: 3009:} /* jerry_get_utf8_string_size */
        -: 3010:
        -: 3011:/**
        -: 3012: * Get length of Jerry string
        -: 3013: *
        -: 3014: * Note:
        -: 3015: *      Returns 0, if the value parameter is not a string.
        -: 3016: *
        -: 3017: * @return number of characters in the string
        -: 3018: */
        -: 3019:jerry_length_t
    #####: 3020:jerry_get_string_length (const jerry_value_t value) /**< input string */
        -: 3021:{
        -: 3022:  jerry_assert_api_available ();
        -: 3023:
    #####: 3024:  if (!ecma_is_value_string (value))
        -: 3025:  {
    #####: 3026:    return 0;
        -: 3027:  }
        -: 3028:
    #####: 3029:  return ecma_string_get_length (ecma_get_string_from_value (value));
        -: 3030:} /* jerry_get_string_length */
        -: 3031:
        -: 3032:/**
        -: 3033: * Get UTF-8 string length from Jerry string
        -: 3034: *
        -: 3035: * Note:
        -: 3036: *      Returns 0, if the value parameter is not a string.
        -: 3037: *
        -: 3038: * @return number of characters in the string
        -: 3039: */
        -: 3040:jerry_length_t
    #####: 3041:jerry_get_utf8_string_length (const jerry_value_t value) /**< input string */
        -: 3042:{
        -: 3043:  jerry_assert_api_available ();
        -: 3044:
    #####: 3045:  if (!ecma_is_value_string (value))
        -: 3046:  {
    #####: 3047:    return 0;
        -: 3048:  }
        -: 3049:
    #####: 3050:  return ecma_string_get_utf8_length (ecma_get_string_from_value (value));
        -: 3051:} /* jerry_get_utf8_string_length */
        -: 3052:
        -: 3053:/**
        -: 3054: * Copy the characters of a string into a specified buffer.
        -: 3055: *
        -: 3056: * Note:
        -: 3057: *      The '\0' character could occur in character buffer.
        -: 3058: *      Returns 0, if the value parameter is not a string or
        -: 3059: *      the buffer is not large enough for the whole string.
        -: 3060: *
        -: 3061: * Note:
        -: 3062: *      If the size of the string in jerry value is larger than the size of the
        -: 3063: *      target buffer, the copy will fail.
        -: 3064: *      To copy substring use jerry_substring_to_char_buffer() instead.
        -: 3065: *
        -: 3066: * @return number of bytes, actually copied to the buffer.
        -: 3067: */
        -: 3068:jerry_size_t
    #####: 3069:jerry_string_to_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3070:                             jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3071:                             jerry_size_t buffer_size) /**< size of output buffer */
        -: 3072:{
        -: 3073:  jerry_assert_api_available ();
        -: 3074:
    #####: 3075:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3076:  {
    #####: 3077:    return 0;
        -: 3078:  }
        -: 3079:
    #####: 3080:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3081:
    #####: 3082:  if (ecma_string_get_size (str_p) > buffer_size)
        -: 3083:  {
    #####: 3084:    return 0;
        -: 3085:  }
        -: 3086:
    #####: 3087:  return ecma_string_copy_to_cesu8_buffer (str_p,
        -: 3088:                                           (lit_utf8_byte_t *) buffer_p,
        -: 3089:                                           buffer_size);
        -: 3090:} /* jerry_string_to_char_buffer */
        -: 3091:
        -: 3092:/**
        -: 3093: * Copy the characters of an utf-8 encoded string into a specified buffer.
        -: 3094: *
        -: 3095: * Note:
        -: 3096: *      The '\0' character could occur anywhere in the returned string
        -: 3097: *      Returns 0, if the value parameter is not a string or the buffer
        -: 3098: *      is not large enough for the whole string.
        -: 3099: *
        -: 3100: * Note:
        -: 3101: *      If the size of the string in jerry value is larger than the size of the
        -: 3102: *      target buffer, the copy will fail.
        -: 3103: *      To copy a substring use jerry_substring_to_utf8_char_buffer() instead.
        -: 3104: *
        -: 3105: * @return number of bytes copied to the buffer.
        -: 3106: */
        -: 3107:jerry_size_t
    #####: 3108:jerry_string_to_utf8_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3109:                                  jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3110:                                  jerry_size_t buffer_size) /**< size of output buffer */
        -: 3111:{
        -: 3112:  jerry_assert_api_available ();
        -: 3113:
    #####: 3114:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3115:  {
    #####: 3116:    return 0;
        -: 3117:  }
        -: 3118:
    #####: 3119:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3120:
    #####: 3121:  if (ecma_string_get_utf8_size (str_p) > buffer_size)
        -: 3122:  {
    #####: 3123:    return 0;
        -: 3124:  }
        -: 3125:
    #####: 3126:  return ecma_string_copy_to_utf8_buffer (str_p,
        -: 3127:                                          (lit_utf8_byte_t *) buffer_p,
        -: 3128:                                          buffer_size);
        -: 3129:} /* jerry_string_to_utf8_char_buffer */
        -: 3130:
        -: 3131:/**
        -: 3132: * Copy the characters of an cesu-8 encoded substring into a specified buffer.
        -: 3133: *
        -: 3134: * Note:
        -: 3135: *      The '\0' character could occur anywhere in the returned string
        -: 3136: *      Returns 0, if the value parameter is not a string.
        -: 3137: *      It will extract the substring beetween the specified start position
        -: 3138: *      and the end position (or the end of the string, whichever comes first).
        -: 3139: *
        -: 3140: * @return number of bytes copied to the buffer.
        -: 3141: */
        -: 3142:jerry_size_t
    #####: 3143:jerry_substring_to_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3144:                                jerry_length_t start_pos, /**< position of the first character */
        -: 3145:                                jerry_length_t end_pos, /**< position of the last character */
        -: 3146:                                jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3147:                                jerry_size_t buffer_size) /**< size of output buffer */
        -: 3148:{
        -: 3149:  jerry_assert_api_available ();
        -: 3150:
    #####: 3151:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3152:  {
    #####: 3153:    return 0;
        -: 3154:  }
        -: 3155:
    #####: 3156:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3157:
    #####: 3158:  return ecma_substring_copy_to_cesu8_buffer (str_p,
        -: 3159:                                              start_pos,
        -: 3160:                                              end_pos,
        -: 3161:                                              (lit_utf8_byte_t *) buffer_p,
        -: 3162:                                              buffer_size);
        -: 3163:} /* jerry_substring_to_char_buffer */
        -: 3164:
        -: 3165:/**
        -: 3166: * Copy the characters of an utf-8 encoded substring into a specified buffer.
        -: 3167: *
        -: 3168: * Note:
        -: 3169: *      The '\0' character could occur anywhere in the returned string
        -: 3170: *      Returns 0, if the value parameter is not a string.
        -: 3171: *      It will extract the substring beetween the specified start position
        -: 3172: *      and the end position (or the end of the string, whichever comes first).
        -: 3173: *
        -: 3174: * @return number of bytes copied to the buffer.
        -: 3175: */
        -: 3176:jerry_size_t
    #####: 3177:jerry_substring_to_utf8_char_buffer (const jerry_value_t value, /**< input string value */
        -: 3178:                                     jerry_length_t start_pos, /**< position of the first character */
        -: 3179:                                     jerry_length_t end_pos, /**< position of the last character */
        -: 3180:                                     jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 3181:                                     jerry_size_t buffer_size) /**< size of output buffer */
        -: 3182:{
        -: 3183:  jerry_assert_api_available ();
        -: 3184:
    #####: 3185:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 3186:  {
    #####: 3187:    return 0;
        -: 3188:  }
        -: 3189:
    #####: 3190:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 3191:
    #####: 3192:  return ecma_substring_copy_to_utf8_buffer (str_p,
        -: 3193:                                             start_pos,
        -: 3194:                                             end_pos,
        -: 3195:                                             (lit_utf8_byte_t *) buffer_p,
        -: 3196:                                             buffer_size);
        -: 3197:} /* jerry_substring_to_utf8_char_buffer */
        -: 3198:
        -: 3199:/**
        -: 3200: * Sets the global callback which is called when an external string is freed.
        -: 3201: */
        -: 3202:void
    #####: 3203:jerry_string_set_external_free_callback (jerry_external_string_free_callback_t callback_p) /**< free callback */
        -: 3204:{
    #####: 3205:  JERRY_CONTEXT (external_string_free_callback_p) = callback_p;
    #####: 3206:} /* jerry_string_set_external_free_callback */
        -: 3207:
        -: 3208:/**
        -: 3209: * Returns the user pointer assigned to an external string.
        -: 3210: *
        -: 3211: * @return user pointer, if value is an external string
        -: 3212: *         NULL, otherwise
        -: 3213: */
        -: 3214:void *
    #####: 3215:jerry_string_get_external_user_pointer (const jerry_value_t value, /**< string value */
        -: 3216:                                        bool *is_external) /**< [out] true - if value is an external string,
        -: 3217:                                                            *         false - otherwise */
        -: 3218:{
    #####: 3219:  if (is_external != NULL)
        -: 3220:  {
    #####: 3221:    *is_external = false;
        -: 3222:  }
        -: 3223:
    #####: 3224:  if (!ecma_is_value_string (value))
        -: 3225:  {
    #####: 3226:    return NULL;
        -: 3227:  }
        -: 3228:
    #####: 3229:  ecma_string_t *string_p = ecma_get_string_from_value (value);
        -: 3230:
    #####: 3231:  if (ECMA_IS_DIRECT_STRING (string_p)
    #####: 3232:      || ECMA_STRING_GET_CONTAINER (string_p) != ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 3233:  {
    #####: 3234:    return NULL;
        -: 3235:  }
        -: 3236:
    #####: 3237:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -: 3238:
    #####: 3239:  if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))
        -: 3240:  {
    #####: 3241:    return NULL;
        -: 3242:  }
        -: 3243:
    #####: 3244:  if (is_external != NULL)
        -: 3245:  {
    #####: 3246:    *is_external = true;
        -: 3247:  }
        -: 3248:
    #####: 3249:  return ((ecma_external_string_t *) string_p)->user_p;
        -: 3250:} /* jerry_string_get_external_user_pointer */
        -: 3251:
        -: 3252:/**
        -: 3253: * Checks whether the object or it's prototype objects have the given property.
        -: 3254: *
        -: 3255: * @return raised error - if the operation fail
        -: 3256: *         true/false API value  - depend on whether the property exists
        -: 3257: */
        -: 3258:jerry_value_t
    #####: 3259:jerry_has_property (const jerry_value_t obj_val, /**< object value */
        -: 3260:                    const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3261:{
        -: 3262:  jerry_assert_api_available ();
        -: 3263:
    #####: 3264:  if (!ecma_is_value_object (obj_val)
    #####: 3265:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3266:  {
    #####: 3267:    return ECMA_VALUE_FALSE;
        -: 3268:  }
        -: 3269:
    #####: 3270:  return jerry_return (ecma_op_object_has_property (ecma_get_object_from_value (obj_val),
        -: 3271:                                                    ecma_get_prop_name_from_value (prop_name_val)));
        -: 3272:} /* jerry_has_property */
        -: 3273:
        -: 3274:/**
        -: 3275: * Checks whether the object has the given property.
        -: 3276: *
        -: 3277: * @return ECMA_VALUE_ERROR - if the operation raises error
        -: 3278: *         ECMA_VALUE_{TRUE, FALSE} - based on whether the property exists
        -: 3279: */
        -: 3280:jerry_value_t
    #####: 3281:jerry_has_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3282:                        const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3283:{
        -: 3284:  jerry_assert_api_available ();
        -: 3285:
    #####: 3286:  if (!ecma_is_value_object (obj_val)
    #####: 3287:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3288:  {
    #####: 3289:    return ECMA_VALUE_FALSE;
        -: 3290:  }
        -: 3291:
    #####: 3292:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
    #####: 3293:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (prop_name_val);
        -: 3294:
        -: 3295:#if JERRY_BUILTIN_PROXY
    #####: 3296:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 3297:  {
    #####: 3298:    ecma_property_descriptor_t prop_desc;
        -: 3299:
    #####: 3300:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 3301:
    #####: 3302:    if (ecma_is_value_true (status))
        -: 3303:    {
    #####: 3304:      ecma_free_property_descriptor (&prop_desc);
        -: 3305:    }
        -: 3306:
    #####: 3307:    return jerry_return (status);
        -: 3308:  }
        -: 3309:#endif /* JERRY_BUILTIN_PROXY */
        -: 3310:
    #####: 3311:  return ecma_make_boolean_value (ecma_op_ordinary_object_has_own_property (obj_p, prop_name_p));
        -: 3312:} /* jerry_has_own_property */
        -: 3313:
        -: 3314:/**
        -: 3315: * Checks whether the object has the given internal property.
        -: 3316: *
        -: 3317: * @return true  - if the internal property exists
        -: 3318: *         false - otherwise
        -: 3319: */
        -: 3320:bool
    #####: 3321:jerry_has_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3322:                             const jerry_value_t prop_name_val) /**< property name value */
        -: 3323:{
        -: 3324:  jerry_assert_api_available ();
        -: 3325:
    #####: 3326:  if (!ecma_is_value_object (obj_val)
    #####: 3327:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3328:  {
    #####: 3329:    return false;
        -: 3330:  }
        -: 3331:
    #####: 3332:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3333:
    #####: 3334:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3335:
    #####: 3336:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3337:  {
    #####: 3338:    return false;
        -: 3339:  }
        -: 3340:
    #####: 3341:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3342:
    #####: 3343:  if (property_p == NULL)
        -: 3344:  {
    #####: 3345:    return false;
        -: 3346:  }
        -: 3347:
    #####: 3348:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3349:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3350:
    #####: 3351:  return property_p != NULL;
        -: 3352:} /* jerry_has_internal_property */
        -: 3353:
        -: 3354:/**
        -: 3355: * Delete a property from an object.
        -: 3356: *
        -: 3357: * @return true  - if property was deleted successfully
        -: 3358: *         false - otherwise
        -: 3359: */
        -: 3360:bool
    #####: 3361:jerry_delete_property (const jerry_value_t obj_val, /**< object value */
        -: 3362:                       const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3363:{
        -: 3364:  jerry_assert_api_available ();
        -: 3365:
    #####: 3366:  if (!ecma_is_value_object (obj_val)
    #####: 3367:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3368:  {
    #####: 3369:    return false;
        -: 3370:  }
        -: 3371:
    #####: 3372:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (obj_val),
        -: 3373:                                                  ecma_get_prop_name_from_value (prop_name_val),
        -: 3374:                                                  false);
        -: 3375:
        -: 3376:#if JERRY_BUILTIN_PROXY
    #####: 3377:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 3378:  {
        -: 3379:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 3380:    jcontext_release_exception ();
        -: 3381:  }
        -: 3382:#endif /* JERRY_BUILTIN_PROXY */
        -: 3383:
    #####: 3384:  return ecma_is_value_true (ret_value);
        -: 3385:} /* jerry_delete_property */
        -: 3386:
        -: 3387:/**
        -: 3388: * Delete indexed property from the specified object.
        -: 3389: *
        -: 3390: * @return true  - if property was deleted successfully
        -: 3391: *         false - otherwise
        -: 3392: */
        -: 3393:bool
    #####: 3394:jerry_delete_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3395:                                uint32_t index) /**< index to be written */
        -: 3396:{
        -: 3397:  jerry_assert_api_available ();
        -: 3398:
    #####: 3399:  if (!ecma_is_value_object (obj_val))
        -: 3400:  {
    #####: 3401:    return false;
        -: 3402:  }
        -: 3403:
    #####: 3404:  ecma_string_t *str_idx_p = ecma_new_ecma_string_from_uint32 (index);
    #####: 3405:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (obj_val),
        -: 3406:                                                  str_idx_p,
        -: 3407:                                                  false);
    #####: 3408:  ecma_deref_ecma_string (str_idx_p);
        -: 3409:
        -: 3410:#if JERRY_BUILTIN_PROXY
    #####: 3411:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 3412:  {
        -: 3413:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 3414:    jcontext_release_exception ();
        -: 3415:  }
        -: 3416:#endif /* JERRY_BUILTIN_PROXY */
        -: 3417:
    #####: 3418:  return ecma_is_value_true (ret_value);
        -: 3419:} /* jerry_delete_property_by_index */
        -: 3420:
        -: 3421:/**
        -: 3422: * Delete an internal property from an object.
        -: 3423: *
        -: 3424: * @return true  - if property was deleted successfully
        -: 3425: *         false - otherwise
        -: 3426: */
        -: 3427:bool
    #####: 3428:jerry_delete_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3429:                                const jerry_value_t prop_name_val) /**< property name value */
        -: 3430:{
        -: 3431:  jerry_assert_api_available ();
        -: 3432:
    #####: 3433:  if (!ecma_is_value_object (obj_val)
    #####: 3434:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3435:  {
    #####: 3436:    return false;
        -: 3437:  }
        -: 3438:
    #####: 3439:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3440:
    #####: 3441:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3442:
    #####: 3443:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3444:  {
    #####: 3445:    return true;
        -: 3446:  }
        -: 3447:
    #####: 3448:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3449:
    #####: 3450:  if (property_p == NULL)
        -: 3451:  {
    #####: 3452:    return true;
        -: 3453:  }
        -: 3454:
    #####: 3455:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3456:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3457:
    #####: 3458:  if (property_p == NULL)
        -: 3459:  {
    #####: 3460:    return true;
        -: 3461:  }
        -: 3462:
    #####: 3463:  ecma_delete_property (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p));
        -: 3464:
    #####: 3465:  return true;
        -: 3466:} /* jerry_delete_internal_property */
        -: 3467:
        -: 3468:/**
        -: 3469: * Get value of a property to the specified object with the given name.
        -: 3470: *
        -: 3471: * Note:
        -: 3472: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3473: *
        -: 3474: * @return value of the property - if success
        -: 3475: *         value marked with error flag - otherwise
        -: 3476: */
        -: 3477:jerry_value_t
    #####: 3478:jerry_get_property (const jerry_value_t obj_val, /**< object value */
        -: 3479:                    const jerry_value_t prop_name_val) /**< property name (string value) */
        -: 3480:{
        -: 3481:  jerry_assert_api_available ();
        -: 3482:
    #####: 3483:  if (!ecma_is_value_object (obj_val)
    #####: 3484:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3485:  {
    #####: 3486:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3487:  }
        -: 3488:
    #####: 3489:  jerry_value_t ret_value = ecma_op_object_get (ecma_get_object_from_value (obj_val),
        -: 3490:                                                ecma_get_prop_name_from_value (prop_name_val));
    #####: 3491:  return jerry_return (ret_value);
        -: 3492:} /* jerry_get_property */
        -: 3493:
        -: 3494:/**
        -: 3495: * Get value by an index from the specified object.
        -: 3496: *
        -: 3497: * Note:
        -: 3498: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3499: *
        -: 3500: * @return value of the property specified by the index - if success
        -: 3501: *         value marked with error flag - otherwise
        -: 3502: */
        -: 3503:jerry_value_t
    #####: 3504:jerry_get_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3505:                             uint32_t index) /**< index to be written */
        -: 3506:{
        -: 3507:  jerry_assert_api_available ();
        -: 3508:
    #####: 3509:  if (!ecma_is_value_object (obj_val))
        -: 3510:  {
    #####: 3511:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3512:  }
        -: 3513:
    #####: 3514:  ecma_value_t ret_value = ecma_op_object_get_by_index (ecma_get_object_from_value (obj_val), index);
        -: 3515:
    #####: 3516:  return jerry_return (ret_value);
        -: 3517:} /* jerry_get_property_by_index */
        -: 3518:
        -: 3519:/**
        -: 3520: * Get the own property value of an object with the given name.
        -: 3521: *
        -: 3522: * Note:
        -: 3523: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3524: *
        -: 3525: * @return value of the property - if success
        -: 3526: *         value marked with error flag - otherwise
        -: 3527: */
        -: 3528:jerry_value_t
    #####: 3529:jerry_get_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3530:                        const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3531:                        const jerry_value_t receiver_val, /**< receiver object value */
        -: 3532:                        bool *found_p) /**< [out] true, if the property is found
        -: 3533:                                        *   or obj_val is a Proxy object, false otherwise */
        -: 3534:{
        -: 3535:  jerry_assert_api_available ();
        -: 3536:
    #####: 3537:  if (found_p != NULL)
        -: 3538:  {
    #####: 3539:    *found_p = false;
        -: 3540:  }
        -: 3541:
    #####: 3542:  if (!ecma_is_value_object (obj_val)
    #####: 3543:      || !ecma_is_value_prop_name (prop_name_val)
    #####: 3544:      || !ecma_is_value_object (receiver_val))
        -: 3545:  {
    #####: 3546:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3547:  }
        -: 3548:
    #####: 3549:  ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
    #####: 3550:  ecma_string_t *property_name_p = ecma_get_prop_name_from_value (prop_name_val);
        -: 3551:
        -: 3552:#if JERRY_BUILTIN_PROXY
    #####: 3553:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 3554:  {
    #####: 3555:    if (found_p != NULL)
        -: 3556:    {
    #####: 3557:      *found_p = true;
        -: 3558:    }
        -: 3559:
    #####: 3560:    return jerry_return (ecma_proxy_object_get (object_p, property_name_p, receiver_val));
        -: 3561:  }
        -: 3562:#endif /* JERRY_BUILTIN_PROXY */
        -: 3563:
    #####: 3564:  ecma_value_t ret_value = ecma_op_object_find_own (receiver_val, object_p, property_name_p);
        -: 3565:
    #####: 3566:  if (ecma_is_value_found (ret_value))
        -: 3567:  {
    #####: 3568:    if (found_p != NULL)
        -: 3569:    {
    #####: 3570:      *found_p = true;
        -: 3571:    }
        -: 3572:
    #####: 3573:    return jerry_return (ret_value);
        -: 3574:  }
        -: 3575:
    #####: 3576:  return ECMA_VALUE_UNDEFINED;
        -: 3577:} /* jerry_get_own_property */
        -: 3578:
        -: 3579:/**
        -: 3580: * Get value of an internal property to the specified object with the given name.
        -: 3581: *
        -: 3582: * Note:
        -: 3583: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3584: *
        -: 3585: * @return value of the internal property - if the internal property exists
        -: 3586: *         undefined value - if the internal does not property exists
        -: 3587: *         value marked with error flag - otherwise
        -: 3588: */
        -: 3589:jerry_value_t
    #####: 3590:jerry_get_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3591:                             const jerry_value_t prop_name_val) /**< property name value */
        -: 3592:{
        -: 3593:  jerry_assert_api_available ();
        -: 3594:
    #####: 3595:  if (!ecma_is_value_object (obj_val)
    #####: 3596:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3597:  {
    #####: 3598:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3599:  }
        -: 3600:
    #####: 3601:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3602:
    #####: 3603:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3604:
    #####: 3605:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3606:  {
    #####: 3607:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3608:  }
        -: 3609:
    #####: 3610:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3611:
    #####: 3612:  if (property_p == NULL)
        -: 3613:  {
    #####: 3614:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3615:  }
        -: 3616:
    #####: 3617:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3618:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (prop_name_val));
        -: 3619:
    #####: 3620:  if (property_p == NULL)
        -: 3621:  {
    #####: 3622:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3623:  }
        -: 3624:
    #####: 3625:  return jerry_return (ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -: 3626:} /* jerry_get_internal_property */
        -: 3627:
        -: 3628:/**
        -: 3629: * Set a property to the specified object with the given name.
        -: 3630: *
        -: 3631: * Note:
        -: 3632: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3633: *
        -: 3634: * @return true value - if the operation was successful
        -: 3635: *         value marked with error flag - otherwise
        -: 3636: */
        -: 3637:jerry_value_t
        5: 3638:jerry_set_property (const jerry_value_t obj_val, /**< object value */
        -: 3639:                    const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3640:                    const jerry_value_t value_to_set) /**< value to set */
        -: 3641:{
        -: 3642:  jerry_assert_api_available ();
        -: 3643:
        5: 3644:  if (ecma_is_value_error_reference (value_to_set)
        5: 3645:      || !ecma_is_value_object (obj_val)
        5: 3646:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3647:  {
    #####: 3648:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3649:  }
        -: 3650:
        5: 3651:  return jerry_return (ecma_op_object_put (ecma_get_object_from_value (obj_val),
        -: 3652:                                           ecma_get_prop_name_from_value (prop_name_val),
        -: 3653:                                           value_to_set,
        -: 3654:                                           true));
        -: 3655:} /* jerry_set_property */
        -: 3656:
        -: 3657:/**
        -: 3658: * Set indexed value in the specified object
        -: 3659: *
        -: 3660: * Note:
        -: 3661: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3662: *
        -: 3663: * @return true value - if the operation was successful
        -: 3664: *         value marked with error flag - otherwise
        -: 3665: */
        -: 3666:jerry_value_t
    #####: 3667:jerry_set_property_by_index (const jerry_value_t obj_val, /**< object value */
        -: 3668:                             uint32_t index, /**< index to be written */
        -: 3669:                             const jerry_value_t value_to_set) /**< value to set */
        -: 3670:{
        -: 3671:  jerry_assert_api_available ();
        -: 3672:
    #####: 3673:  if (ecma_is_value_error_reference (value_to_set)
    #####: 3674:      || !ecma_is_value_object (obj_val))
        -: 3675:  {
    #####: 3676:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 3677:  }
        -: 3678:
    #####: 3679:  ecma_value_t ret_value = ecma_op_object_put_by_index (ecma_get_object_from_value (obj_val),
        -: 3680:                                                        index,
        -: 3681:                                                        value_to_set,
        -: 3682:                                                        true);
        -: 3683:
    #####: 3684:  return jerry_return (ret_value);
        -: 3685:} /* jerry_set_property_by_index */
        -: 3686:
        -: 3687:/**
        -: 3688: * Set an internal property to the specified object with the given name.
        -: 3689: *
        -: 3690: * Note:
        -: 3691: *      - the property cannot be accessed from the JavaScript context, only from the public API
        -: 3692: *      - returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3693: *
        -: 3694: * @return true value - if the operation was successful
        -: 3695: *         value marked with error flag - otherwise
        -: 3696: */
        -: 3697:bool
    #####: 3698:jerry_set_internal_property (const jerry_value_t obj_val, /**< object value */
        -: 3699:                             const jerry_value_t prop_name_val, /**< property name value */
        -: 3700:                             const jerry_value_t value_to_set) /**< value to set */
        -: 3701:{
        -: 3702:  jerry_assert_api_available ();
        -: 3703:
    #####: 3704:  if (ecma_is_value_error_reference (value_to_set)
    #####: 3705:      || !ecma_is_value_object (obj_val)
    #####: 3706:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3707:  {
    #####: 3708:    return false;
        -: 3709:  }
        -: 3710:
    #####: 3711:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 3712:
    #####: 3713:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3714:
    #####: 3715:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3716:  {
    #####: 3717:    ecma_fast_array_convert_to_normal (obj_p);
        -: 3718:  }
        -: 3719:
    #####: 3720:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3721:  ecma_object_t *internal_object_p;
        -: 3722:
    #####: 3723:  if (property_p == NULL)
        -: 3724:  {
    #####: 3725:    ecma_property_value_t *value_p = ecma_create_named_data_property (obj_p,
        -: 3726:                                                                      internal_string_p,
        -: 3727:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 3728:                                                                      NULL);
        -: 3729:
    #####: 3730:    internal_object_p = ecma_create_object (NULL,
        -: 3731:                                            sizeof (ecma_extended_object_t),
        -: 3732:                                            ECMA_OBJECT_TYPE_CLASS);
        -: 3733:    {
    #####: 3734:      ecma_extended_object_t *container_p = (ecma_extended_object_t *) internal_object_p;
    #####: 3735:      container_p->u.cls.type = ECMA_OBJECT_CLASS_INTERNAL_OBJECT;
        -: 3736:    }
        -: 3737:
    #####: 3738:    value_p->value = ecma_make_object_value (internal_object_p);
    #####: 3739:    ecma_deref_object (internal_object_p);
        -: 3740:  }
        -: 3741:  else
        -: 3742:  {
    #####: 3743:    internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 3744:  }
        -: 3745:
    #####: 3746:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (prop_name_val);
    #####: 3747:  property_p = ecma_find_named_property (internal_object_p, prop_name_p);
        -: 3748:
    #####: 3749:  if (property_p == NULL)
        -: 3750:  {
    #####: 3751:    ecma_property_value_t *value_p = ecma_create_named_data_property (internal_object_p,
        -: 3752:                                                                      prop_name_p,
        -: 3753:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 3754:                                                                      NULL);
        -: 3755:
    #####: 3756:    value_p->value = ecma_copy_value_if_not_object (value_to_set);
        -: 3757:  }
        -: 3758:  else
        -: 3759:  {
    #####: 3760:    ecma_named_data_property_assign_value (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p), value_to_set);
        -: 3761:  }
        -: 3762:
    #####: 3763:  return true;
        -: 3764:} /* jerry_set_internal_property */
        -: 3765:
        -: 3766:/**
        -: 3767: * Construct empty property descriptor, i.e.:
        -: 3768: *  property descriptor with all is_defined flags set to false and the rest - to default value.
        -: 3769: *
        -: 3770: * @return empty property descriptor
        -: 3771: */
        -: 3772:jerry_property_descriptor_t
    #####: 3773:jerry_property_descriptor_create (void)
        -: 3774:{
        -: 3775:  jerry_property_descriptor_t prop_desc;
        -: 3776:
    #####: 3777:  prop_desc.flags = JERRY_PROP_NO_OPTS;
    #####: 3778:  prop_desc.value = ECMA_VALUE_UNDEFINED;
    #####: 3779:  prop_desc.getter = ECMA_VALUE_UNDEFINED;
    #####: 3780:  prop_desc.setter = ECMA_VALUE_UNDEFINED;
        -: 3781:
    #####: 3782:  return prop_desc;
        -: 3783:} /* jerry_property_descriptor_create */
        -: 3784:
        -: 3785:/**
        -: 3786: * Convert a ecma_property_descriptor_t to a jerry_property_descriptor_t
        -: 3787: *
        -: 3788: * if error occurs the property descriptor's value field is filled with ECMA_VALUE_ERROR
        -: 3789: *
        -: 3790: * @return jerry_property_descriptor_t
        -: 3791: */
        -: 3792:static jerry_property_descriptor_t
    #####: 3793:jerry_property_descriptor_from_ecma (const ecma_property_descriptor_t *prop_desc_p) /**<[out] property_descriptor */
        -: 3794:{
    #####: 3795:  jerry_property_descriptor_t prop_desc = jerry_property_descriptor_create ();
        -: 3796:
    #####: 3797:  prop_desc.flags = prop_desc_p->flags;
        -: 3798:
    #####: 3799:  if (prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED))
        -: 3800:  {
    #####: 3801:    prop_desc.value = prop_desc_p->value;
        -: 3802:  }
        -: 3803:
    #####: 3804:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3805:  {
    #####: 3806:    prop_desc.getter = ECMA_VALUE_NULL;
        -: 3807:
    #####: 3808:    if (prop_desc_p->get_p != NULL)
        -: 3809:    {
    #####: 3810:      prop_desc.getter = ecma_make_object_value (prop_desc_p->get_p);
    #####: 3811:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.getter));
        -: 3812:    }
        -: 3813:  }
        -: 3814:
    #####: 3815:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3816:  {
    #####: 3817:    prop_desc.setter = ECMA_VALUE_NULL;
        -: 3818:
    #####: 3819:    if (prop_desc_p->set_p != NULL)
        -: 3820:    {
    #####: 3821:      prop_desc.setter = ecma_make_object_value (prop_desc_p->set_p);
    #####: 3822:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.setter));
        -: 3823:    }
        -: 3824:  }
        -: 3825:
    #####: 3826:  return prop_desc;
        -: 3827:} /* jerry_property_descriptor_from_ecma */
        -: 3828:
        -: 3829:/**
        -: 3830: * Convert a jerry_property_descriptor_t to a ecma_property_descriptor_t
        -: 3831: *
        -: 3832: * Note:
        -: 3833: *     if error occurs the property descriptor's value field
        -: 3834: *     is set to ECMA_VALUE_ERROR, but no error is thrown
        -: 3835: *
        -: 3836: * @return ecma_property_descriptor_t
        -: 3837: */
        -: 3838:static ecma_property_descriptor_t
    #####: 3839:jerry_property_descriptor_to_ecma (const jerry_property_descriptor_t *prop_desc_p) /**< input property_descriptor */
        -: 3840:{
    #####: 3841:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -: 3842:
    #####: 3843:  prop_desc.flags = prop_desc_p->flags;
        -: 3844:
        -: 3845:  /* Copy data property info. */
    #####: 3846:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3847:  {
    #####: 3848:    if (ecma_is_value_error_reference (prop_desc_p->value)
    #####: 3849:        || (prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)))
        -: 3850:    {
    #####: 3851:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3852:      return prop_desc;
        -: 3853:    }
        -: 3854:
    #####: 3855:    prop_desc.value = prop_desc_p->value;
        -: 3856:  }
        -: 3857:
        -: 3858:  /* Copy accessor property info. */
    #####: 3859:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3860:  {
    #####: 3861:    ecma_value_t getter = prop_desc_p->getter;
        -: 3862:
    #####: 3863:    if (ecma_is_value_error_reference (getter))
        -: 3864:    {
    #####: 3865:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3866:      return prop_desc;
        -: 3867:    }
        -: 3868:
    #####: 3869:    if (ecma_op_is_callable (getter))
        -: 3870:    {
    #####: 3871:      prop_desc.get_p = ecma_get_object_from_value (getter);
        -: 3872:    }
    #####: 3873:    else if (!ecma_is_value_null (getter))
        -: 3874:    {
    #####: 3875:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3876:      return prop_desc;
        -: 3877:    }
        -: 3878:  }
        -: 3879:
    #####: 3880:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3881:  {
    #####: 3882:    ecma_value_t setter = prop_desc_p->setter;
        -: 3883:
    #####: 3884:    if (ecma_is_value_error_reference (setter))
        -: 3885:    {
    #####: 3886:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3887:      return prop_desc;
        -: 3888:    }
        -: 3889:
    #####: 3890:    if (ecma_op_is_callable (setter))
        -: 3891:    {
    #####: 3892:      prop_desc.set_p = ecma_get_object_from_value (setter);
        -: 3893:    }
    #####: 3894:    else if (!ecma_is_value_null (setter))
        -: 3895:    {
    #####: 3896:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3897:      return prop_desc;
        -: 3898:    }
        -: 3899:  }
        -: 3900:
    #####: 3901:  const uint16_t configurable_mask = JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_CONFIGURABLE_DEFINED;
    #####: 3902:  const uint16_t enumerable_mask = JERRY_PROP_IS_ENUMERABLE | JERRY_PROP_IS_ENUMERABLE_DEFINED;
    #####: 3903:  const uint16_t writable_mask = JERRY_PROP_IS_WRITABLE | JERRY_PROP_IS_WRITABLE_DEFINED;
        -: 3904:
    #####: 3905:  if ((prop_desc_p->flags & configurable_mask) == JERRY_PROP_IS_CONFIGURABLE
    #####: 3906:      || (prop_desc_p->flags & enumerable_mask) == JERRY_PROP_IS_ENUMERABLE
    #####: 3907:      || (prop_desc_p->flags & writable_mask) == JERRY_PROP_IS_WRITABLE)
        -: 3908:  {
    #####: 3909:    prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3910:    return prop_desc;
        -: 3911:  }
        -: 3912:
    #####: 3913:  prop_desc.flags |= (uint16_t) (prop_desc_p->flags | JERRY_PROP_SHOULD_THROW);
        -: 3914:
    #####: 3915:  return prop_desc;
        -: 3916:} /* jerry_property_descriptor_to_ecma */
        -: 3917:
        -: 3918:/** Helper function to return false value or error depending on the given flag.
        -: 3919: *
        -: 3920: * @return value marked with error flag - if is_throw is true
        -: 3921: *         false value - otherwise
        -: 3922: */
        -: 3923:static jerry_value_t
    #####: 3924:jerry_type_error_or_false (const char *msg_p, /**< message */
        -: 3925:                           uint16_t flags) /**< property descriptor flags */
        -: 3926:{
    #####: 3927:  if (!(flags & JERRY_PROP_SHOULD_THROW))
        -: 3928:  {
    #####: 3929:    return ECMA_VALUE_FALSE;
        -: 3930:  }
        -: 3931:
    #####: 3932:  return jerry_throw (ecma_raise_type_error (msg_p));
        -: 3933:} /* jerry_type_error_or_false */
        -: 3934:
        -: 3935:/**
        -: 3936: * Define a property to the specified object with the given name.
        -: 3937: *
        -: 3938: * Note:
        -: 3939: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 3940: *
        -: 3941: * @return true value - if the operation was successful
        -: 3942: *         false value - if the property cannot be defined and JERRY_PROP_SHOULD_THROW is not set
        -: 3943: *         value marked with error flag - otherwise
        -: 3944: */
        -: 3945:jerry_value_t
    #####: 3946:jerry_define_own_property (const jerry_value_t obj_val, /**< object value */
        -: 3947:                           const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3948:                           const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3949:{
        -: 3950:  jerry_assert_api_available ();
        -: 3951:
    #####: 3952:  if (!ecma_is_value_object (obj_val)
    #####: 3953:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3954:  {
    #####: 3955:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3956:  }
        -: 3957:
    #####: 3958:  if (prop_desc_p->flags & (JERRY_PROP_IS_WRITABLE_DEFINED | JERRY_PROP_IS_VALUE_DEFINED)
    #####: 3959:      && prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -: 3960:  {
    #####: 3961:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3962:  }
        -: 3963:
    #####: 3964:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (prop_desc_p);
        -: 3965:
    #####: 3966:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 3967:  {
    #####: 3968:    return jerry_type_error_or_false (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p), prop_desc_p->flags);
        -: 3969:  }
        -: 3970:
    #####: 3971:  return jerry_return (ecma_op_object_define_own_property (ecma_get_object_from_value (obj_val),
        -: 3972:                                                           ecma_get_prop_name_from_value (prop_name_val),
        -: 3973:                                                           &prop_desc));
        -: 3974:} /* jerry_define_own_property */
        -: 3975:
        -: 3976:/**
        -: 3977: * Construct property descriptor from specified property.
        -: 3978: *
        -: 3979: * @return true - if success, the prop_desc_p fields contains the property info
        -: 3980: *         false - otherwise, the prop_desc_p is unchanged
        -: 3981: */
        -: 3982:jerry_value_t
    #####: 3983:jerry_get_own_property_descriptor (const jerry_value_t  obj_val, /**< object value */
        -: 3984:                                   const jerry_value_t prop_name_val, /**< property name (string value) */
        -: 3985:                                   jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3986:{
        -: 3987:  jerry_assert_api_available ();
        -: 3988:
    #####: 3989:  if (!ecma_is_value_object (obj_val)
    #####: 3990:      || !ecma_is_value_prop_name (prop_name_val))
        -: 3991:  {
    #####: 3992:    return ECMA_VALUE_FALSE;
        -: 3993:  }
        -: 3994:
    #####: 3995:  ecma_property_descriptor_t prop_desc;
        -: 3996:
    #####: 3997:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (ecma_get_object_from_value (obj_val),
        -: 3998:                                                                    ecma_get_prop_name_from_value (prop_name_val),
        -: 3999:                                                                    &prop_desc);
        -: 4000:
        -: 4001:#if JERRY_BUILTIN_PROXY
    #####: 4002:  if (ECMA_IS_VALUE_ERROR (status))
        -: 4003:  {
    #####: 4004:    return jerry_throw (status);
        -: 4005:  }
        -: 4006:#endif /* JERRY_BUILTIN_PROXY */
        -: 4007:
    #####: 4008:  if (!ecma_is_value_true (status))
        -: 4009:  {
    #####: 4010:    return ECMA_VALUE_FALSE;
        -: 4011:  }
        -: 4012:
        -: 4013:  /* The flags are always filled in the returned descriptor. */
    #####: 4014:  JERRY_ASSERT ((prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED)
        -: 4015:                && (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
        -: 4016:                && ((prop_desc.flags & JERRY_PROP_IS_WRITABLE_DEFINED)
        -: 4017:                    || !(prop_desc.flags & JERRY_PROP_IS_VALUE_DEFINED)));
        -: 4018:
    #####: 4019:  prop_desc_p->flags = prop_desc.flags;
    #####: 4020:  prop_desc_p->value = ECMA_VALUE_UNDEFINED;
    #####: 4021:  prop_desc_p->getter = ECMA_VALUE_UNDEFINED;
    #####: 4022:  prop_desc_p->setter = ECMA_VALUE_UNDEFINED;
        -: 4023:
    #####: 4024:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 4025:  {
    #####: 4026:    prop_desc_p->value = prop_desc.value;
        -: 4027:  }
        -: 4028:
    #####: 4029:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 4030:  {
    #####: 4031:    if (prop_desc.get_p != NULL)
        -: 4032:    {
    #####: 4033:      prop_desc_p->getter = ecma_make_object_value (prop_desc.get_p);
        -: 4034:    }
        -: 4035:    else
        -: 4036:    {
    #####: 4037:      prop_desc_p->getter = ECMA_VALUE_NULL;
        -: 4038:    }
        -: 4039:  }
        -: 4040:
    #####: 4041:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 4042:  {
    #####: 4043:    if (prop_desc.set_p != NULL)
        -: 4044:    {
    #####: 4045:      prop_desc_p->setter = ecma_make_object_value (prop_desc.set_p);
        -: 4046:    }
        -: 4047:    else
        -: 4048:    {
    #####: 4049:      prop_desc_p->setter = ECMA_VALUE_NULL;
        -: 4050:    }
        -: 4051:  }
        -: 4052:
    #####: 4053:  return ECMA_VALUE_TRUE;
        -: 4054:} /* jerry_get_own_property_descriptor */
        -: 4055:
        -: 4056:/**
        -: 4057: * Free fields of property descriptor (setter, getter and value).
        -: 4058: */
        -: 4059:void
    #####: 4060:jerry_property_descriptor_free (const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 4061:{
    #####: 4062:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 4063:  {
    #####: 4064:    jerry_release_value (prop_desc_p->value);
        -: 4065:  }
        -: 4066:
    #####: 4067:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 4068:  {
    #####: 4069:    jerry_release_value (prop_desc_p->getter);
        -: 4070:  }
        -: 4071:
    #####: 4072:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 4073:  {
    #####: 4074:    jerry_release_value (prop_desc_p->setter);
        -: 4075:  }
    #####: 4076:} /* jerry_property_descriptor_free */
        -: 4077:
        -: 4078:/**
        -: 4079: * Invoke function specified by a function value
        -: 4080: *
        -: 4081: * Note:
        -: 4082: *      - returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4083: *      - If function is invoked as constructor, it should support [[Construct]] method,
        -: 4084: *        otherwise, if function is simply called - it should support [[Call]] method.
        -: 4085: *
        -: 4086: * @return returned jerry value of the invoked function
        -: 4087: */
        -: 4088:static jerry_value_t
    #####: 4089:jerry_invoke_function (bool is_invoke_as_constructor, /**< true - invoke function as constructor
        -: 4090:                                                       *          (this_arg_p should be NULL, as it is ignored),
        -: 4091:                                                       *   false - perform function call */
        -: 4092:                       const jerry_value_t func_obj_val, /**< function object to call */
        -: 4093:                       const jerry_value_t this_val, /**< object value of 'this' binding */
        -: 4094:                       const jerry_value_t args_p[], /**< function's call arguments */
        -: 4095:                       const jerry_size_t args_count) /**< number of the arguments */
        -: 4096:{
    #####: 4097:  JERRY_ASSERT (args_count == 0 || args_p != NULL);
        -: 4098:
    #####: 4099:  if (ecma_is_value_error_reference (func_obj_val)
    #####: 4100:      || ecma_is_value_error_reference (this_val))
        -: 4101:  {
    #####: 4102:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4103:  }
        -: 4104:
    #####: 4105:  for (uint32_t i = 0; i < args_count; i++)
        -: 4106:  {
    #####: 4107:    if (ecma_is_value_error_reference (args_p[i]))
        -: 4108:    {
    #####: 4109:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4110:    }
        -: 4111:  }
        -: 4112:
    #####: 4113:  if (is_invoke_as_constructor)
        -: 4114:  {
    #####: 4115:    JERRY_ASSERT (jerry_value_is_constructor (func_obj_val));
        -: 4116:
    #####: 4117:    return jerry_return (ecma_op_function_construct (ecma_get_object_from_value (func_obj_val),
        -: 4118:                                                     ecma_get_object_from_value (func_obj_val),
        -: 4119:                                                     args_p,
        -: 4120:                                                     args_count));
        -: 4121:  }
        -: 4122:  else
        -: 4123:  {
    #####: 4124:    JERRY_ASSERT (jerry_value_is_function (func_obj_val));
        -: 4125:
    #####: 4126:    return jerry_return (ecma_op_function_call (ecma_get_object_from_value (func_obj_val),
        -: 4127:                                                this_val,
        -: 4128:                                                args_p,
        -: 4129:                                                args_count));
        -: 4130:  }
        -: 4131:} /* jerry_invoke_function */
        -: 4132:
        -: 4133:/**
        -: 4134: * Call function specified by a function value
        -: 4135: *
        -: 4136: * Note:
        -: 4137: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4138: *      error flag must not be set for any arguments of this function.
        -: 4139: *
        -: 4140: * @return returned jerry value of the called function
        -: 4141: */
        -: 4142:jerry_value_t
    #####: 4143:jerry_call_function (const jerry_value_t func_obj_val, /**< function object to call */
        -: 4144:                     const jerry_value_t this_val, /**< object for 'this' binding */
        -: 4145:                     const jerry_value_t args_p[], /**< function's call arguments */
        -: 4146:                     jerry_size_t args_count) /**< number of the arguments */
        -: 4147:{
        -: 4148:  jerry_assert_api_available ();
        -: 4149:
    #####: 4150:  if (jerry_value_is_function (func_obj_val) && !ecma_is_value_error_reference (this_val))
        -: 4151:  {
    #####: 4152:    for (jerry_size_t i = 0; i < args_count; i++)
        -: 4153:    {
    #####: 4154:      if (ecma_is_value_error_reference (args_p[i]))
        -: 4155:      {
    #####: 4156:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4157:      }
        -: 4158:    }
        -: 4159:
    #####: 4160:    return jerry_invoke_function (false, func_obj_val, this_val, args_p, args_count);
        -: 4161:  }
        -: 4162:
    #####: 4163:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4164:} /* jerry_call_function */
        -: 4165:
        -: 4166:/**
        -: 4167: * Construct object value invoking specified function value as a constructor
        -: 4168: *
        -: 4169: * Note:
        -: 4170: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4171: *      error flag must not be set for any arguments of this function.
        -: 4172: *
        -: 4173: * @return returned jerry value of the invoked constructor
        -: 4174: */
        -: 4175:jerry_value_t
    #####: 4176:jerry_construct_object (const jerry_value_t func_obj_val, /**< function object to call */
        -: 4177:                        const jerry_value_t args_p[], /**< function's call arguments
        -: 4178:                                                       *   (NULL if arguments number is zero) */
        -: 4179:                        jerry_size_t args_count) /**< number of the arguments */
        -: 4180:{
        -: 4181:  jerry_assert_api_available ();
        -: 4182:
    #####: 4183:  if (jerry_value_is_constructor (func_obj_val))
        -: 4184:  {
    #####: 4185:    for (jerry_size_t i = 0; i < args_count; i++)
        -: 4186:    {
    #####: 4187:      if (ecma_is_value_error_reference (args_p[i]))
        -: 4188:      {
    #####: 4189:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4190:      }
        -: 4191:    }
        -: 4192:
    #####: 4193:    ecma_value_t this_val = ECMA_VALUE_UNDEFINED;
    #####: 4194:    return jerry_invoke_function (true, func_obj_val, this_val, args_p, args_count);
        -: 4195:  }
        -: 4196:
    #####: 4197:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4198:} /* jerry_construct_object */
        -: 4199:
        -: 4200:/**
        -: 4201: * Get keys of the specified object value
        -: 4202: *
        -: 4203: * Note:
        -: 4204: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4205: *
        -: 4206: * @return array object value - if success
        -: 4207: *         value marked with error flag - otherwise
        -: 4208: */
        -: 4209:jerry_value_t
    #####: 4210:jerry_get_object_keys (const jerry_value_t obj_val) /**< object value */
        -: 4211:{
        -: 4212:  jerry_assert_api_available ();
        -: 4213:
    #####: 4214:  if (!ecma_is_value_object (obj_val))
        -: 4215:  {
    #####: 4216:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4217:  }
        -: 4218:
    #####: 4219:  ecma_collection_t *prop_names = ecma_op_object_get_enumerable_property_names (ecma_get_object_from_value (obj_val),
        -: 4220:                                                                                ECMA_ENUMERABLE_PROPERTY_KEYS);
        -: 4221:
        -: 4222:#if JERRY_BUILTIN_PROXY
    #####: 4223:  if (JERRY_UNLIKELY (prop_names == NULL))
        -: 4224:  {
    #####: 4225:    return ECMA_VALUE_ERROR;
        -: 4226:  }
        -: 4227:#endif /* JERRY_BUILTIN_PROXY */
        -: 4228:
    #####: 4229:  return ecma_op_new_array_object_from_collection (prop_names, false);
        -: 4230:} /* jerry_get_object_keys */
        -: 4231:
        -: 4232:/**
        -: 4233: * Get the prototype of the specified object
        -: 4234: *
        -: 4235: * Note:
        -: 4236: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 4237: *
        -: 4238: * @return prototype object or null value - if success
        -: 4239: *         value marked with error flag - otherwise
        -: 4240: */
        -: 4241:jerry_value_t
    #####: 4242:jerry_get_prototype (const jerry_value_t obj_val) /**< object value */
        -: 4243:{
        -: 4244:  jerry_assert_api_available ();
        -: 4245:
    #####: 4246:  if (!ecma_is_value_object (obj_val))
        -: 4247:  {
    #####: 4248:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4249:  }
        -: 4250:
    #####: 4251:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 4252:
        -: 4253:#if JERRY_BUILTIN_PROXY
    #####: 4254:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4255:  {
    #####: 4256:    return jerry_return (ecma_proxy_object_get_prototype_of (obj_p));
        -: 4257:  }
        -: 4258:#endif /* JERRY_BUILTIN_PROXY */
        -: 4259:
    #####: 4260:  if (obj_p->u2.prototype_cp == JMEM_CP_NULL)
        -: 4261:  {
    #####: 4262:    return ECMA_VALUE_NULL;
        -: 4263:  }
        -: 4264:
    #####: 4265:  ecma_object_t *proto_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);
    #####: 4266:  ecma_ref_object (proto_obj_p);
        -: 4267:
    #####: 4268:  return ecma_make_object_value (proto_obj_p);
        -: 4269:} /* jerry_get_prototype */
        -: 4270:
        -: 4271:/**
        -: 4272: * Set the prototype of the specified object
        -: 4273: *
        -: 4274: * @return true value - if success
        -: 4275: *         value marked with error flag - otherwise
        -: 4276: */
        -: 4277:jerry_value_t
    #####: 4278:jerry_set_prototype (const jerry_value_t obj_val, /**< object value */
        -: 4279:                     const jerry_value_t proto_obj_val) /**< prototype object value */
        -: 4280:{
        -: 4281:  jerry_assert_api_available ();
        -: 4282:
    #####: 4283:  if (!ecma_is_value_object (obj_val)
    #####: 4284:      || ecma_is_value_error_reference (proto_obj_val)
    #####: 4285:      || (!ecma_is_value_object (proto_obj_val) && !ecma_is_value_null (proto_obj_val)))
        -: 4286:  {
    #####: 4287:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4288:  }
    #####: 4289:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
        -: 4290:
        -: 4291:#if JERRY_BUILTIN_PROXY
    #####: 4292:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4293:  {
    #####: 4294:    return jerry_return (ecma_proxy_object_set_prototype_of (obj_p, proto_obj_val));
        -: 4295:  }
        -: 4296:#endif /* JERRY_BUILTIN_PROXY */
        -: 4297:
    #####: 4298:  return ecma_op_ordinary_object_set_prototype_of (obj_p, proto_obj_val);
        -: 4299:} /* jerry_set_prototype */
        -: 4300:
        -: 4301:/**
        -: 4302: * Utility to check if a given object can be used for the foreach api calls.
        -: 4303: *
        -: 4304: * Some objects/classes uses extra internal objects to correctly store data.
        -: 4305: * These extre object should never be exposed externally to the API user.
        -: 4306: *
        -: 4307: * @returns true - if the user can access the object in the callback.
        -: 4308: *          false - if the object is an internal object which should no be accessed by the user.
        -: 4309: */
        -: 4310:static
    #####: 4311:bool jerry_object_is_valid_foreach (ecma_object_t *object_p) /**< object to test */
        -: 4312:{
    #####: 4313:  if (ecma_is_lexical_environment (object_p))
        -: 4314:  {
    #####: 4315:    return false;
        -: 4316:  }
        -: 4317:
    #####: 4318:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 4319:
    #####: 4320:  if (object_type == ECMA_OBJECT_TYPE_CLASS)
        -: 4321:  {
    #####: 4322:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 4323:    switch (ext_object_p->u.cls.type)
        -: 4324:    {
        -: 4325:      /* An object's internal property object should not be iterable by foreach. */
    #####: 4326:      case ECMA_OBJECT_CLASS_INTERNAL_OBJECT:
        -: 4327:      {
    #####: 4328:        return false;
        -: 4329:      }
        -: 4330:    }
        -: 4331:  }
        -: 4332:
    #####: 4333:  return true;
        -: 4334:} /* jerry_object_is_valid_foreach */
        -: 4335:
        -: 4336:/**
        -: 4337: * Traverse objects.
        -: 4338: *
        -: 4339: * @return true - traversal was interrupted by the callback.
        -: 4340: *         false - otherwise - traversal visited all objects.
        -: 4341: */
        -: 4342:bool
    #####: 4343:jerry_objects_foreach (jerry_objects_foreach_t foreach_p, /**< function pointer of the iterator function */
        -: 4344:                       void *user_data_p) /**< pointer to user data */
        -: 4345:{
        -: 4346:  jerry_assert_api_available ();
        -: 4347:
    #####: 4348:  JERRY_ASSERT (foreach_p != NULL);
        -: 4349:
    #####: 4350:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4351:
    #####: 4352:  while (iter_cp != JMEM_CP_NULL)
        -: 4353:  {
    #####: 4354:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4355:
    #####: 4356:    if (jerry_object_is_valid_foreach (iter_p)
    #####: 4357:        && !foreach_p (ecma_make_object_value (iter_p), user_data_p))
        -: 4358:    {
    #####: 4359:      return true;
        -: 4360:    }
        -: 4361:
    #####: 4362:    iter_cp = iter_p->gc_next_cp;
        -: 4363:  }
        -: 4364:
    #####: 4365:  return false;
        -: 4366:} /* jerry_objects_foreach */
        -: 4367:
        -: 4368:/**
        -: 4369: * Traverse objects having a given native type info.
        -: 4370: *
        -: 4371: * @return true - traversal was interrupted by the callback.
        -: 4372: *         false - otherwise - traversal visited all objects.
        -: 4373: */
        -: 4374:bool
    #####: 4375:jerry_objects_foreach_by_native_info (const jerry_object_native_info_t *native_info_p, /**< the type info
        -: 4376:                                                                                        *   of the native pointer */
        -: 4377:                                      jerry_objects_foreach_by_native_info_t foreach_p, /**< function to apply for
        -: 4378:                                                                                         *   each matching object */
        -: 4379:                                      void *user_data_p) /**< pointer to user data */
        -: 4380:{
        -: 4381:  jerry_assert_api_available ();
        -: 4382:
    #####: 4383:  JERRY_ASSERT (native_info_p != NULL);
    #####: 4384:  JERRY_ASSERT (foreach_p != NULL);
        -: 4385:
        -: 4386:  ecma_native_pointer_t *native_pointer_p;
        -: 4387:
    #####: 4388:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4389:
    #####: 4390:  while (iter_cp != JMEM_CP_NULL)
        -: 4391:  {
    #####: 4392:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4393:
    #####: 4394:    if (jerry_object_is_valid_foreach (iter_p))
        -: 4395:    {
    #####: 4396:      native_pointer_p = ecma_get_native_pointer_value (iter_p, (void *) native_info_p);
    #####: 4397:      if (native_pointer_p
    #####: 4398:          && !foreach_p (ecma_make_object_value (iter_p), native_pointer_p->native_p, user_data_p))
        -: 4399:      {
    #####: 4400:        return true;
        -: 4401:      }
        -: 4402:    }
        -: 4403:
    #####: 4404:    iter_cp = iter_p->gc_next_cp;
        -: 4405:  }
        -: 4406:
    #####: 4407:  return false;
        -: 4408:} /* jerry_objects_foreach_by_native_info */
        -: 4409:
        -: 4410:/**
        -: 4411: * Get native pointer and its type information, associated with the given native type info.
        -: 4412: *
        -: 4413: * Note:
        -: 4414: *  If native pointer is present, its type information is returned in out_native_pointer_p
        -: 4415: *
        -: 4416: * @return true - if there is an associated pointer,
        -: 4417: *         false - otherwise
        -: 4418: */
        -: 4419:bool
    #####: 4420:jerry_get_object_native_pointer (const jerry_value_t obj_val, /**< object to get native pointer from */
        -: 4421:                                 void **out_native_pointer_p, /**< [out] native pointer */
        -: 4422:                                 const jerry_object_native_info_t *native_info_p) /**< the type info
        -: 4423:                                                                                   *   of the native pointer */
        -: 4424:{
        -: 4425:  jerry_assert_api_available ();
        -: 4426:
    #####: 4427:  if (!ecma_is_value_object (obj_val))
        -: 4428:  {
    #####: 4429:    return false;
        -: 4430:  }
        -: 4431:
        -: 4432:  ecma_native_pointer_t *native_pointer_p;
    #####: 4433:  native_pointer_p = ecma_get_native_pointer_value (ecma_get_object_from_value (obj_val), (void *) native_info_p);
        -: 4434:
    #####: 4435:  if (native_pointer_p == NULL)
        -: 4436:  {
    #####: 4437:    return false;
        -: 4438:  }
        -: 4439:
    #####: 4440:  if (out_native_pointer_p != NULL)
        -: 4441:  {
    #####: 4442:    *out_native_pointer_p = native_pointer_p->native_p;
        -: 4443:  }
        -: 4444:
    #####: 4445:  return true;
        -: 4446:} /* jerry_get_object_native_pointer */
        -: 4447:
        -: 4448:/**
        -: 4449: * Set native pointer and an optional type info for the specified object.
        -: 4450: *
        -: 4451: *
        -: 4452: * Note:
        -: 4453: *      If native pointer was already set for the object, its value is updated.
        -: 4454: *
        -: 4455: * Note:
        -: 4456: *      If a non-NULL free callback is specified in the native type info,
        -: 4457: *      it will be called by the garbage collector when the object is freed.
        -: 4458: *      Referred values by this method must have at least 1 reference. (Correct API usage satisfies this condition)
        -: 4459: *      The type info always overwrites the previous value, so passing
        -: 4460: *      a NULL value deletes the current type info.
        -: 4461: */
        -: 4462:void
    #####: 4463:jerry_set_object_native_pointer (const jerry_value_t obj_val, /**< object to set native pointer in */
        -: 4464:                                 void *native_pointer_p, /**< native pointer */
        -: 4465:                                 const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4466:{
        -: 4467:  jerry_assert_api_available ();
        -: 4468:
    #####: 4469:  if (ecma_is_value_object (obj_val))
        -: 4470:  {
    #####: 4471:    ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
        -: 4472:
    #####: 4473:    ecma_create_native_pointer_property (object_p, native_pointer_p, native_info_p);
        -: 4474:  }
    #####: 4475:} /* jerry_set_object_native_pointer */
        -: 4476:
        -: 4477:/**
        -: 4478: * Delete the previously set native pointer by the native type info from the specified object.
        -: 4479: *
        -: 4480: * Note:
        -: 4481: *      If the specified object has no matching native pointer for the given native type info
        -: 4482: *      the function has no effect.
        -: 4483: *
        -: 4484: * Note:
        -: 4485: *      This operation cannot throw an exception.
        -: 4486: *
        -: 4487: * @return true - if the native pointer has been deleted succesfully
        -: 4488: *         false - otherwise
        -: 4489: */
        -: 4490:bool
    #####: 4491:jerry_delete_object_native_pointer (const jerry_value_t obj_val, /**< object to delete native pointer from */
        -: 4492:                                    const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4493:{
        -: 4494:  jerry_assert_api_available ();
        -: 4495:
    #####: 4496:  if (ecma_is_value_object (obj_val))
        -: 4497:  {
    #####: 4498:    ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
        -: 4499:
    #####: 4500:    return ecma_delete_native_pointer_property (object_p, (void *) native_info_p);
        -: 4501:  }
        -: 4502:
    #####: 4503:  return false;
        -: 4504:} /* jerry_delete_object_native_pointer */
        -: 4505:
        -: 4506:/**
        -: 4507: * Initialize the references stored in a buffer pointed by a native pointer.
        -: 4508: * The references are initialized to undefined.
        -: 4509: */
        -: 4510:void
    #####: 4511:jerry_native_pointer_init_references (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4512:                                      const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4513:                                                                                        *   the native pointer */
        -: 4514:{
        -: 4515:  jerry_assert_api_available ();
        -: 4516:
    #####: 4517:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4518:  {
    #####: 4519:    return;
        -: 4520:  }
        -: 4521:
    #####: 4522:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4523:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4524:
    #####: 4525:  while (value_p < end_p)
        -: 4526:  {
    #####: 4527:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4528:  }
        -: 4529:} /* jerry_native_pointer_init_references */
        -: 4530:
        -: 4531:/**
        -: 4532: * Release the value references after a buffer pointed by a native pointer
        -: 4533: * is not attached to an object anymore. All references are set to undefined
        -: 4534: * similar to jerry_native_pointer_init_references.
        -: 4535: */
        -: 4536:void
    #####: 4537:jerry_native_pointer_release_references (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4538:                                         const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4539:                                                                                           *   the native pointer */
        -: 4540:{
        -: 4541:  jerry_assert_api_available ();
        -: 4542:
    #####: 4543:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4544:  {
    #####: 4545:    return;
        -: 4546:  }
        -: 4547:
    #####: 4548:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4549:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4550:
    #####: 4551:  while (value_p < end_p)
        -: 4552:  {
    #####: 4553:    ecma_free_value_if_not_object (*value_p);
    #####: 4554:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4555:  }
        -: 4556:} /* jerry_native_pointer_release_references */
        -: 4557:
        -: 4558:/**
        -: 4559: * Updates a value reference inside the area specified by the number_of_references and
        -: 4560: * offset_of_references fields in its corresponding jerry_object_native_info_t data.
        -: 4561: * The area must be part of a buffer which is currently assigned to an object.
        -: 4562: *
        -: 4563: * Note:
        -: 4564: *      Error references are not supported, they are replaced by undefined values.
        -: 4565: */
        -: 4566:void
    #####: 4567:jerry_native_pointer_set_reference (jerry_value_t *reference_p, /**< a valid non-NULL pointer to
        -: 4568:                                                                 *   a reference in a native buffer. */
        -: 4569:                                    jerry_value_t value) /**< new value of the reference */
        -: 4570:{
        -: 4571:  jerry_assert_api_available ();
        -: 4572:
    #####: 4573:  if (reference_p == NULL)
        -: 4574:  {
    #####: 4575:    return;
        -: 4576:  }
        -: 4577:
    #####: 4578:  if (ecma_is_value_error_reference (value))
        -: 4579:  {
    #####: 4580:    value = ECMA_VALUE_UNDEFINED;
        -: 4581:  }
        -: 4582:
    #####: 4583:  ecma_free_value_if_not_object (*reference_p);
    #####: 4584:  *reference_p = ecma_copy_value_if_not_object (value);
        -: 4585:} /* jerry_native_pointer_set_reference */
        -: 4586:
        -: 4587:/**
        -: 4588: * Applies the given function to the every property in the object.
        -: 4589: *
        -: 4590: * @return true - if object fields traversal was performed successfully, i.e.:
        -: 4591: *                - no unhandled exceptions were thrown in object fields traversal;
        -: 4592: *                - object fields traversal was stopped on callback that returned false;
        -: 4593: *         false - otherwise,
        -: 4594: *                 if getter of field threw a exception or unhandled exceptions were thrown during traversal;
        -: 4595: */
        -: 4596:bool
    #####: 4597:jerry_foreach_object_property (const jerry_value_t obj_val, /**< object value */
        -: 4598:                               jerry_object_property_foreach_t foreach_p, /**< foreach function */
        -: 4599:                               void *user_data_p) /**< user data for foreach function */
        -: 4600:{
        -: 4601:  jerry_assert_api_available ();
        -: 4602:
    #####: 4603:  if (!ecma_is_value_object (obj_val))
        -: 4604:  {
    #####: 4605:    return false;
        -: 4606:  }
        -: 4607:
    #####: 4608:  ecma_object_t *object_p = ecma_get_object_from_value (obj_val);
    #####: 4609:  ecma_collection_t *names_p = ecma_op_object_enumerate (object_p);
        -: 4610:
        -: 4611:#if JERRY_BUILTIN_PROXY
    #####: 4612:  if (names_p == NULL)
        -: 4613:  {
        -: 4614:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 4615:    jcontext_release_exception ();
    #####: 4616:    return false;
        -: 4617:  }
        -: 4618:#endif /* JERRY_BUILTIN_PROXY */
        -: 4619:
    #####: 4620:  ecma_value_t *buffer_p = names_p->buffer_p;
        -: 4621:
    #####: 4622:  ecma_value_t property_value = ECMA_VALUE_EMPTY;
        -: 4623:
    #####: 4624:  bool continuous = true;
        -: 4625:
    #####: 4626:  for (uint32_t i = 0; continuous && (i < names_p->item_count); i++)
        -: 4627:  {
    #####: 4628:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 4629:
    #####: 4630:    property_value = ecma_op_object_get (object_p, property_name_p);
        -: 4631:
    #####: 4632:    if (ECMA_IS_VALUE_ERROR (property_value))
        -: 4633:    {
    #####: 4634:      break;
        -: 4635:    }
        -: 4636:
    #####: 4637:    continuous = foreach_p (buffer_p[i], property_value, user_data_p);
    #####: 4638:    ecma_free_value (property_value);
        -: 4639:  }
        -: 4640:
    #####: 4641:  ecma_collection_free (names_p);
        -: 4642:
    #####: 4643:  if (!ECMA_IS_VALUE_ERROR (property_value))
        -: 4644:  {
    #####: 4645:    return true;
        -: 4646:  }
        -: 4647:
    #####: 4648:  jcontext_release_exception ();
    #####: 4649:  return false;
        -: 4650:} /* jerry_foreach_object_property */
        -: 4651:
        -: 4652:/**
        -: 4653: * Gets the property keys for the given object using the selected filters.
        -: 4654: *
        -: 4655: * @return array containing the filtered property keys in successful operation
        -: 4656: *         value marked with error flag - otherwise
        -: 4657: */
        -: 4658:jerry_value_t
    #####: 4659:jerry_object_get_property_names (const jerry_value_t obj_val, /**< object */
        -: 4660:                                 jerry_property_filter_t filter) /**< property filter options */
        -: 4661:{
        -: 4662:  jerry_assert_api_available ();
        -: 4663:
    #####: 4664:  if (!ecma_is_value_object (obj_val))
        -: 4665:  {
    #####: 4666:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4667:  }
        -: 4668:
    #####: 4669:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_val);
    #####: 4670:  ecma_object_t *obj_iter_p = obj_p;
    #####: 4671:  ecma_collection_t *result_p = ecma_new_collection ();
        -: 4672:
    #####: 4673:  ecma_ref_object (obj_iter_p);
        -: 4674:
        -: 4675:  while (true)
    #####: 4676:  {
        -: 4677:    /* Step 1. Get Object.[[OwnKeys]] */
    #####: 4678:    ecma_collection_t *prop_names_p = ecma_op_object_own_property_keys (obj_iter_p, filter);
        -: 4679:
        -: 4680:#if JERRY_BUILTIN_PROXY
    #####: 4681:    if (prop_names_p == NULL)
        -: 4682:    {
    #####: 4683:      ecma_deref_object (obj_iter_p);
    #####: 4684:      return jerry_throw (ECMA_VALUE_ERROR);
        -: 4685:    }
        -: 4686:#endif /* JERRY_BUILTIN_PROXY */
        -: 4687:
    #####: 4688:    for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 4689:    {
    #####: 4690:      ecma_value_t key = prop_names_p->buffer_p[i];
    #####: 4691:      ecma_string_t *key_p = ecma_get_prop_name_from_value (key);
    #####: 4692:      uint32_t index = ecma_string_get_array_index (key_p);
        -: 4693:
        -: 4694:      /* Step 2. Filter by key type */
    #####: 4695:      if (filter & (JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS
        -: 4696:                    | JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS
        -: 4697:                    | JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES))
        -: 4698:      {
    #####: 4699:        if (ecma_is_value_symbol (key))
        -: 4700:        {
    #####: 4701:          if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_SYMBOLS)
        -: 4702:          {
    #####: 4703:            continue;
        -: 4704:          }
        -: 4705:        }
    #####: 4706:        else if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 4707:        {
    #####: 4708:          if ((filter & JERRY_PROPERTY_FILTER_EXLCUDE_INTEGER_INDICES)
    #####: 4709:              || ((filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
    #####: 4710:                  && !(filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER)))
        -: 4711:          {
    #####: 4712:            continue;
        -: 4713:          }
        -: 4714:        }
    #####: 4715:        else if (filter & JERRY_PROPERTY_FILTER_EXLCUDE_STRINGS)
        -: 4716:        {
    #####: 4717:          continue;
        -: 4718:        }
        -: 4719:      }
        -: 4720:
        -: 4721:      /* Step 3. Filter property attributes */
    #####: 4722:      if (filter & (JERRY_PROPERTY_FILTER_EXLCUDE_NON_CONFIGURABLE
        -: 4723:                    | JERRY_PROPERTY_FILTER_EXLCUDE_NON_ENUMERABLE
        -: 4724:                    | JERRY_PROPERTY_FILTER_EXLCUDE_NON_WRITABLE))
        -: 4725:      {
    #####: 4726:        ecma_property_descriptor_t prop_desc;
    #####: 4727:        ecma_value_t status = ecma_op_object_get_own_property_descriptor (obj_iter_p, key_p, &prop_desc);
        -: 4728:
        -: 4729:#if JERRY_BUILTIN_PROXY
    #####: 4730:        if (ECMA_IS_VALUE_ERROR (status))
        -: 4731:        {
    #####: 4732:          ecma_collection_free (prop_names_p);
    #####: 4733:          ecma_collection_free (result_p);
    #####: 4734:          ecma_deref_object (obj_iter_p);
    #####: 4735:          return jerry_throw (ECMA_VALUE_ERROR);
        -: 4736:        }
        -: 4737:#endif /* JERRY_BUILTIN_PROXY */
        -: 4738:
    #####: 4739:        JERRY_ASSERT (ecma_is_value_true (status));
    #####: 4740:        uint16_t flags = prop_desc.flags;
    #####: 4741:        ecma_free_property_descriptor (&prop_desc);
        -: 4742:
    #####: 4743:        if ((!(flags & JERRY_PROP_IS_CONFIGURABLE)
    #####: 4744:             && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_CONFIGURABLE))
    #####: 4745:            || (!(flags & JERRY_PROP_IS_ENUMERABLE)
    #####: 4746:                && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_ENUMERABLE))
    #####: 4747:            || (!(flags & JERRY_PROP_IS_WRITABLE)
    #####: 4748:                && (filter & JERRY_PROPERTY_FILTER_EXLCUDE_NON_WRITABLE)))
        -: 4749:        {
    #####: 4750:          continue;
        -: 4751:        }
        -: 4752:      }
        -: 4753:
    #####: 4754:      if (index != ECMA_STRING_NOT_ARRAY_INDEX
    #####: 4755:          && (filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER))
        -: 4756:      {
    #####: 4757:        ecma_deref_ecma_string (key_p);
    #####: 4758:        key = ecma_make_uint32_value (index);
        -: 4759:      }
        -: 4760:      else
        -: 4761:      {
    #####: 4762:        ecma_ref_ecma_string (key_p);
        -: 4763:      }
        -: 4764:
    #####: 4765:      if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) && obj_iter_p != obj_p)
    #####: 4766:      {
    #####: 4767:        uint32_t duplicate_idx = 0;
    #####: 4768:        while (duplicate_idx < result_p->item_count)
        -: 4769:        {
    #####: 4770:          ecma_value_t value = result_p->buffer_p[duplicate_idx];
    #####: 4771:          JERRY_ASSERT (ecma_is_value_prop_name (value) || ecma_is_value_number (value));
    #####: 4772:          if (JERRY_UNLIKELY (ecma_is_value_number (value)))
        -: 4773:          {
    #####: 4774:            if (ecma_get_number_from_value (value) == ecma_get_number_from_value (key))
        -: 4775:            {
    #####: 4776:              break;
        -: 4777:            }
        -: 4778:          }
    #####: 4779:          else if (ecma_compare_ecma_strings (ecma_get_prop_name_from_value (value), key_p))
        -: 4780:          {
    #####: 4781:            break;
        -: 4782:          }
        -: 4783:
    #####: 4784:          duplicate_idx++;
        -: 4785:        }
        -: 4786:
    #####: 4787:        if (duplicate_idx == result_p->item_count)
        -: 4788:        {
    #####: 4789:          ecma_collection_push_back (result_p, key);
        -: 4790:        }
        -: 4791:      }
        -: 4792:      else
        -: 4793:      {
    #####: 4794:        ecma_collection_push_back (result_p, key);
        -: 4795:      }
        -: 4796:    }
        -: 4797:
    #####: 4798:    ecma_collection_free (prop_names_p);
        -: 4799:
        -: 4800:    /* Step 4: Traverse prototype chain */
        -: 4801:
    #####: 4802:    if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) != JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN)
        -: 4803:    {
    #####: 4804:      break;
        -: 4805:    }
        -: 4806:
    #####: 4807:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (obj_iter_p);
        -: 4808:
    #####: 4809:    if (proto_p == NULL)
        -: 4810:    {
    #####: 4811:      break;
        -: 4812:    }
        -: 4813:
    #####: 4814:    ecma_deref_object (obj_iter_p);
        -: 4815:
    #####: 4816:    if (JERRY_UNLIKELY (proto_p == ECMA_OBJECT_POINTER_ERROR))
        -: 4817:    {
    #####: 4818:      ecma_collection_free (result_p);
    #####: 4819:      return jerry_throw (ECMA_VALUE_ERROR);
        -: 4820:    }
        -: 4821:
    #####: 4822:    obj_iter_p = proto_p;
        -: 4823:  }
        -: 4824:
    #####: 4825:  ecma_deref_object (obj_iter_p);
        -: 4826:
    #####: 4827:  return ecma_op_new_array_object_from_collection (result_p, false);
        -: 4828:} /* jerry_object_get_property_names */
        -: 4829:
        -: 4830:/**
        -: 4831: * FromPropertyDescriptor abstract operation.
        -: 4832: *
        -: 4833: * @return new jerry_value_t - if success
        -: 4834: *         value marked with error flag - otherwise
        -: 4835: */
        -: 4836:jerry_value_t
    #####: 4837:jerry_from_property_descriptor (const jerry_property_descriptor_t *src_prop_desc_p) /**< property descriptor */
        -: 4838:{
        -: 4839:  jerry_assert_api_available ();
        -: 4840:
    #####: 4841:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (src_prop_desc_p);
        -: 4842:
    #####: 4843:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 4844:  {
    #####: 4845:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4846:  }
        -: 4847:
    #####: 4848:  ecma_object_t *desc_obj_p = ecma_op_from_property_descriptor (&prop_desc);
        -: 4849:
    #####: 4850:  return ecma_make_object_value (desc_obj_p);
        -: 4851:} /* jerry_from_property_descriptor */
        -: 4852:
        -: 4853:/**
        -: 4854: * ToPropertyDescriptor abstract operation.
        -: 4855: *
        -: 4856: * @return true - if the conversion is successful
        -: 4857: *         thrown error - otherwise
        -: 4858: */
        -: 4859:jerry_value_t
    #####: 4860:jerry_to_property_descriptor (jerry_value_t obj_value, /**< object value */
        -: 4861:                              jerry_property_descriptor_t *out_prop_desc_p) /**< [out] filled property descriptor
        -: 4862:                                                                             *   if return value is true,
        -: 4863:                                                                             *   unmodified otherwise */
        -: 4864:{
        -: 4865:  jerry_assert_api_available ();
        -: 4866:
    #####: 4867:  ecma_property_descriptor_t prop_desc;
    #####: 4868:  jerry_value_t result = ecma_op_to_property_descriptor (obj_value, &prop_desc);
        -: 4869:
    #####: 4870:  if (ECMA_IS_VALUE_ERROR (result))
        -: 4871:  {
    #####: 4872:    return jerry_throw (result);
        -: 4873:  }
        -: 4874:
    #####: 4875:  JERRY_ASSERT (result == ECMA_VALUE_EMPTY);
        -: 4876:
    #####: 4877:  *out_prop_desc_p = jerry_property_descriptor_from_ecma (&prop_desc);
    #####: 4878:  return ECMA_VALUE_TRUE;
        -: 4879:} /* jerry_to_property_descriptor */
        -: 4880:
        -: 4881:/**
        -: 4882: * Resolve or reject the promise with an argument.
        -: 4883: *
        -: 4884: * @return undefined value - if success
        -: 4885: *         value marked with error flag - otherwise
        -: 4886: */
        -: 4887:jerry_value_t
    #####: 4888:jerry_resolve_or_reject_promise (jerry_value_t promise, /**< the promise value */
        -: 4889:                                 jerry_value_t argument, /**< the argument */
        -: 4890:                                 bool is_resolve) /**< whether the promise should be resolved or rejected */
        -: 4891:{
        -: 4892:  jerry_assert_api_available ();
        -: 4893:
        -: 4894:#if JERRY_ESNEXT
    #####: 4895:  if (!ecma_is_value_object (promise) || !ecma_is_promise (ecma_get_object_from_value (promise)))
        -: 4896:  {
    #####: 4897:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4898:  }
        -: 4899:
    #####: 4900:  if (ecma_is_value_error_reference (argument))
        -: 4901:  {
    #####: 4902:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 4903:  }
        -: 4904:
    #####: 4905:  if (is_resolve)
        -: 4906:  {
    #####: 4907:    return ecma_fulfill_promise_with_checks (promise, argument);
        -: 4908:  }
        -: 4909:
    #####: 4910:  return ecma_reject_promise_with_checks (promise, argument);
        -: 4911:#else /* !JERRY_ESNEXT */
        -: 4912:  JERRY_UNUSED (promise);
        -: 4913:  JERRY_UNUSED (argument);
        -: 4914:  JERRY_UNUSED (is_resolve);
        -: 4915:
    #####: 4916:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 4917:#endif /* JERRY_ESNEXT */
        -: 4918:} /* jerry_resolve_or_reject_promise */
        -: 4919:
        -: 4920:/**
        -: 4921: * Get the result of a promise.
        -: 4922: *
        -: 4923: * @return - Promise result
        -: 4924: *         - Type error if the promise support was not enabled or the input was not a promise object
        -: 4925: */
        -: 4926:jerry_value_t
    #####: 4927:jerry_get_promise_result (const jerry_value_t promise) /**< promise object to get the result from */
        -: 4928:{
        -: 4929:  jerry_assert_api_available ();
        -: 4930:
        -: 4931:#if JERRY_ESNEXT
    #####: 4932:  if (!jerry_value_is_promise (promise))
        -: 4933:  {
    #####: 4934:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 4935:  }
        -: 4936:
    #####: 4937:  return ecma_promise_get_result (ecma_get_object_from_value (promise));
        -: 4938:#else /* !JERRY_ESNEXT */
        -: 4939:  JERRY_UNUSED (promise);
    #####: 4940:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_promise_not_supported_p)));
        -: 4941:#endif /* JERRY_ESNEXT */
        -: 4942:} /* jerry_get_promise_result */
        -: 4943:
        -: 4944:/**
        -: 4945: * Get the state of a promise object.
        -: 4946: *
        -: 4947: * @return - the state of the promise (one of the jerry_promise_state_t enum values)
        -: 4948: *         - JERRY_PROMISE_STATE_NONE is only returned if the input is not a promise object
        -: 4949: *           or the promise support was not enabled.
        -: 4950: */
        -: 4951:jerry_promise_state_t
    #####: 4952:jerry_get_promise_state (const jerry_value_t promise) /**< promise object to get the state from */
        -: 4953:{
        -: 4954:  jerry_assert_api_available ();
        -: 4955:
        -: 4956:#if JERRY_ESNEXT
    #####: 4957:  if (!jerry_value_is_promise (promise))
        -: 4958:  {
    #####: 4959:    return JERRY_PROMISE_STATE_NONE;
        -: 4960:  }
        -: 4961:
    #####: 4962:  uint16_t flags = ecma_promise_get_flags (ecma_get_object_from_value (promise));
    #####: 4963:  flags &= (ECMA_PROMISE_IS_PENDING | ECMA_PROMISE_IS_FULFILLED);
        -: 4964:
    #####: 4965:  return (flags ? flags : JERRY_PROMISE_STATE_REJECTED);
        -: 4966:#else /* !JERRY_ESNEXT */
        -: 4967:  JERRY_UNUSED (promise);
    #####: 4968:  return JERRY_PROMISE_STATE_NONE;
        -: 4969:#endif /* JERRY_ESNEXT */
        -: 4970:} /* jerry_get_promise_state */
        -: 4971:
        -: 4972:/**
        -: 4973: * Sets a callback for tracking Promise and async operations.
        -: 4974: *
        -: 4975: * Note:
        -: 4976: *     the previous callback is overwritten
        -: 4977: */
        1: 4978:void jerry_promise_set_callback (jerry_promise_event_filter_t filters, /**< combination of event filters */
        -: 4979:                                 jerry_promise_callback_t callback, /**< notification callback */
        -: 4980:                                 void *user_p) /**< user pointer passed to the callback */
        -: 4981:{
        -: 4982:  jerry_assert_api_available ();
        -: 4983:
        -: 4984:#if JERRY_ESNEXT && JERRY_PROMISE_CALLBACK
    #####: 4985:  if (filters == JERRY_PROMISE_EVENT_FILTER_DISABLE || callback == NULL)
        -: 4986:  {
    #####: 4987:    JERRY_CONTEXT (promise_callback_filters) = JERRY_PROMISE_EVENT_FILTER_DISABLE;
    #####: 4988:    return;
        -: 4989:  }
        -: 4990:
    #####: 4991:  JERRY_CONTEXT (promise_callback_filters) = (uint32_t) filters;
    #####: 4992:  JERRY_CONTEXT (promise_callback) = callback;
    #####: 4993:  JERRY_CONTEXT (promise_callback_user_p) = user_p;
        -: 4994:#else /* !JERRY_ESNEXT && !JERRY_PROMISE_CALLBACK */
        -: 4995:  JERRY_UNUSED (filters);
        -: 4996:  JERRY_UNUSED (callback);
        -: 4997:  JERRY_UNUSED (user_p);
        -: 4998:#endif /* JERRY_ESNEXT && JERRY_PROMISE_CALLBACK */
        1: 4999:} /* jerry_promise_set_callback */
        -: 5000:
        -: 5001:/**
        -: 5002: * Get the well-knwon symbol represented by the given `symbol` enum value.
        -: 5003: *
        -: 5004: * Note:
        -: 5005: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5006: *
        -: 5007: * @return undefined value - if invalid well-known symbol was requested
        -: 5008: *         well-known symbol value - otherwise
        -: 5009: */
        -: 5010:jerry_value_t
    #####: 5011:jerry_get_well_known_symbol (jerry_well_known_symbol_t symbol) /**< jerry_well_known_symbol_t enum value */
        -: 5012:{
        -: 5013:  jerry_assert_api_available ();
        -: 5014:
        -: 5015:#if JERRY_ESNEXT
    #####: 5016:  lit_magic_string_id_t id = (lit_magic_string_id_t) (LIT_GLOBAL_SYMBOL__FIRST + symbol);
        -: 5017:
    #####: 5018:  if (!LIT_IS_GLOBAL_SYMBOL (id))
        -: 5019:  {
    #####: 5020:    return ECMA_VALUE_UNDEFINED;
        -: 5021:  }
        -: 5022:
    #####: 5023:  return ecma_make_symbol_value (ecma_op_get_global_symbol (id));
        -: 5024:#else /* !JERRY_ESNEXT */
        -: 5025:  JERRY_UNUSED (symbol);
        -: 5026:
    #####: 5027:  return ECMA_VALUE_UNDEFINED;
        -: 5028:#endif /* JERRY_ESNEXT */
        -: 5029:} /** jerry_get_well_known_symbol */
        -: 5030:
        -: 5031:/**
        -: 5032: * Returns the description internal property of a symbol.
        -: 5033: *
        -: 5034: * Note:
        -: 5035: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5036: *
        -: 5037: * @return string or undefined value containing the symbol's description - if success
        -: 5038: *         thrown error - otherwise
        -: 5039: */
        -: 5040:jerry_value_t
    #####: 5041:jerry_get_symbol_description (const jerry_value_t symbol) /**< symbol value */
        -: 5042:{
        -: 5043:  jerry_assert_api_available ();
        -: 5044:
        -: 5045:#if JERRY_ESNEXT
    #####: 5046:  if (!ecma_is_value_symbol (symbol))
        -: 5047:  {
    #####: 5048:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 5049:  }
        -: 5050:
        -: 5051:  /* Note: This operation cannot throw an error */
    #####: 5052:  return ecma_copy_value (ecma_get_symbol_description (ecma_get_symbol_from_value (symbol)));
        -: 5053:#else /* !JERRY_ESNEXT */
        -: 5054:  JERRY_UNUSED (symbol);
        -: 5055:
    #####: 5056:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 5057:#endif /* JERRY_ESNEXT */
        -: 5058:} /* jerry_get_symbol_description */
        -: 5059:
        -: 5060:/**
        -: 5061: * Call the SymbolDescriptiveString ecma builtin operation on the symbol value.
        -: 5062: *
        -: 5063: * Note:
        -: 5064: *      returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5065: *
        -: 5066: * @return string value containing the symbol's descriptive string - if success
        -: 5067: *         thrown error - otherwise
        -: 5068: */
        -: 5069:jerry_value_t
    #####: 5070:jerry_get_symbol_descriptive_string (const jerry_value_t symbol) /**< symbol value */
        -: 5071:{
        -: 5072:  jerry_assert_api_available ();
        -: 5073:
        -: 5074:#if JERRY_ESNEXT
    #####: 5075:  if (!ecma_is_value_symbol (symbol))
        -: 5076:  {
    #####: 5077:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 5078:  }
        -: 5079:
        -: 5080:  /* Note: This operation cannot throw an error */
    #####: 5081:  return ecma_get_symbol_descriptive_string (symbol);
        -: 5082:#else /* !JERRY_ESNEXT */
        -: 5083:  JERRY_UNUSED (symbol);
        -: 5084:
    #####: 5085:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_symbol_not_supported_p)));
        -: 5086:#endif /* JERRY_ESNEXT */
        -: 5087:} /** jerry_get_symbol_descriptive_string */
        -: 5088:
        -: 5089:/**
        -: 5090: * Get the number of uint64 digits of a BigInt value
        -: 5091: *
        -: 5092: * @return number of uint64 digits
        -: 5093: */
        -: 5094:uint32_t
    #####: 5095:jerry_get_bigint_size_in_digits (jerry_value_t value) /**< BigInt value */
        -: 5096:{
        -: 5097:  jerry_assert_api_available ();
        -: 5098:
        -: 5099:#if JERRY_BUILTIN_BIGINT
    #####: 5100:  if (!ecma_is_value_bigint (value))
        -: 5101:  {
    #####: 5102:    return 0;
        -: 5103:  }
        -: 5104:
    #####: 5105:  return ecma_bigint_get_size_in_digits (value);
        -: 5106:#else /* !JERRY_BUILTIN_BIGINT */
        -: 5107:  JERRY_UNUSED (value);
    #####: 5108:  return 0;
        -: 5109:#endif /* JERRY_BUILTIN_BIGINT */
        -: 5110:} /* jerry_get_bigint_size_in_digits */
        -: 5111:
        -: 5112:/**
        -: 5113: * Get the uint64 digits of a BigInt value (lowest digit first)
        -: 5114: */
        -: 5115:void
    #####: 5116:jerry_get_bigint_digits (jerry_value_t value, /**< BigInt value */
        -: 5117:                         uint64_t *digits_p, /**< [out] buffer for digits */
        -: 5118:                         uint32_t size, /**< buffer size in digits */
        -: 5119:                         bool *sign_p) /**< [out] sign of BigInt */
        -: 5120:{
        -: 5121:#if JERRY_BUILTIN_BIGINT
    #####: 5122:  if (!ecma_is_value_bigint (value))
        -: 5123:  {
    #####: 5124:    if (sign_p != NULL)
        -: 5125:    {
    #####: 5126:      *sign_p = false;
        -: 5127:    }
    #####: 5128:    memset (digits_p, 0, size * sizeof (uint64_t));
        -: 5129:  }
        -: 5130:
    #####: 5131:  ecma_bigint_get_digits_and_sign (value, digits_p, size, sign_p);
        -: 5132:#else /* !JERRY_BUILTIN_BIGINT */
        -: 5133:  JERRY_UNUSED (value);
        -: 5134:
    #####: 5135:  if (sign_p != NULL)
        -: 5136:  {
    #####: 5137:    *sign_p = false;
        -: 5138:  }
    #####: 5139:  memset (digits_p, 0, size * sizeof (uint64_t));
        -: 5140:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 5141:} /* jerry_get_bigint_digits */
        -: 5142:
        -: 5143:/**
        -: 5144: * Get the target object of a Proxy object
        -: 5145: *
        -: 5146: * @return type error - if proxy_value is not a Proxy object
        -: 5147: *         target object - otherwise
        -: 5148: */
        -: 5149:jerry_value_t
    #####: 5150:jerry_get_proxy_target (jerry_value_t proxy_value) /**< proxy value */
        -: 5151:{
        -: 5152:  jerry_assert_api_available ();
        -: 5153:
        -: 5154:#if JERRY_BUILTIN_PROXY
    #####: 5155:  if (ecma_is_value_object (proxy_value))
        -: 5156:  {
    #####: 5157:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5158:
    #####: 5159:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5160:    {
    #####: 5161:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5162:
    #####: 5163:      if (!ecma_is_value_null (proxy_object_p->target))
        -: 5164:      {
    #####: 5165:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->target));
        -: 5166:      }
    #####: 5167:      return proxy_object_p->target;
        -: 5168:    }
        -: 5169:  }
        -: 5170:#else /* !JERRY_BUILTIN_PROXY */
        -: 5171:  JERRY_UNUSED (proxy_value);
        -: 5172:#endif /* JERRY_BUILTIN_PROXY */
        -: 5173:
    #####: 5174:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_a_proxy)));
        -: 5175:} /* jerry_get_proxy_target */
        -: 5176:
        -: 5177:/**
        -: 5178: * Get the handler object of a Proxy object
        -: 5179: *
        -: 5180: * @return type error - if proxy_value is not a Proxy object
        -: 5181: *         handler object - otherwise
        -: 5182: */
        -: 5183:jerry_value_t
    #####: 5184:jerry_get_proxy_handler (jerry_value_t proxy_value) /**< proxy value */
        -: 5185:{
        -: 5186:  jerry_assert_api_available ();
        -: 5187:
        -: 5188:#if JERRY_BUILTIN_PROXY
    #####: 5189:  if (ecma_is_value_object (proxy_value))
        -: 5190:  {
    #####: 5191:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5192:
    #####: 5193:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5194:    {
    #####: 5195:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5196:
    #####: 5197:      if (!ecma_is_value_null (proxy_object_p->handler))
        -: 5198:      {
    #####: 5199:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->handler));
        -: 5200:      }
    #####: 5201:      return proxy_object_p->handler;
        -: 5202:    }
        -: 5203:  }
        -: 5204:#else /* !JERRY_BUILTIN_PROXY */
        -: 5205:  JERRY_UNUSED (proxy_value);
        -: 5206:#endif /* JERRY_BUILTIN_PROXY */
        -: 5207:
    #####: 5208:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_a_proxy)));
        -: 5209:} /* jerry_get_proxy_handler */
        -: 5210:
        -: 5211:/**
        -: 5212: * Validate UTF-8 string
        -: 5213: *
        -: 5214: * @return true - if UTF-8 string is well-formed
        -: 5215: *         false - otherwise
        -: 5216: */
        -: 5217:bool
        1: 5218:jerry_is_valid_utf8_string (const jerry_char_t *utf8_buf_p, /**< UTF-8 string */
        -: 5219:                            jerry_size_t buf_size) /**< string size */
        -: 5220:{
        1: 5221:  return lit_is_valid_utf8_string ((lit_utf8_byte_t *) utf8_buf_p,
        -: 5222:                                   (lit_utf8_size_t) buf_size,
        -: 5223:                                   true);
        -: 5224:} /* jerry_is_valid_utf8_string */
        -: 5225:
        -: 5226:/**
        -: 5227: * Validate CESU-8 string
        -: 5228: *
        -: 5229: * @return true - if CESU-8 string is well-formed
        -: 5230: *         false - otherwise
        -: 5231: */
        -: 5232:bool
    #####: 5233:jerry_is_valid_cesu8_string (const jerry_char_t *cesu8_buf_p, /**< CESU-8 string */
        -: 5234:                             jerry_size_t buf_size) /**< string size */
        -: 5235:{
    #####: 5236:  return lit_is_valid_cesu8_string ((lit_utf8_byte_t *) cesu8_buf_p,
        -: 5237:                                    (lit_utf8_size_t) buf_size);
        -: 5238:} /* jerry_is_valid_cesu8_string */
        -: 5239:
        -: 5240:/**
        -: 5241: * Allocate memory on the engine's heap.
        -: 5242: *
        -: 5243: * Note:
        -: 5244: *      This function may take away memory from the executed JavaScript code.
        -: 5245: *      If any other dynamic memory allocation API is available (e.g., libc
        -: 5246: *      malloc), it should be used instead.
        -: 5247: *
        -: 5248: * @return allocated memory on success
        -: 5249: *         NULL otherwise
        -: 5250: */
        -: 5251:void *
    #####: 5252:jerry_heap_alloc (size_t size) /**< size of the memory block */
        -: 5253:{
        -: 5254:  jerry_assert_api_available ();
        -: 5255:
    #####: 5256:  return jmem_heap_alloc_block_null_on_error (size);
        -: 5257:} /* jerry_heap_alloc */
        -: 5258:
        -: 5259:/**
        -: 5260: * Free memory allocated on the engine's heap.
        -: 5261: */
        -: 5262:void
    #####: 5263:jerry_heap_free (void *mem_p, /**< value returned by jerry_heap_alloc */
        -: 5264:                 size_t size) /**< same size as passed to jerry_heap_alloc */
        -: 5265:{
        -: 5266:  jerry_assert_api_available ();
        -: 5267:
    #####: 5268:  jmem_heap_free_block (mem_p, size);
    #####: 5269:} /* jerry_heap_free */
        -: 5270:
        -: 5271:/**
        -: 5272: * Create an external engine context.
        -: 5273: *
        -: 5274: * @return the pointer to the context.
        -: 5275: */
        -: 5276:jerry_context_t *
    #####: 5277:jerry_create_context (uint32_t heap_size, /**< the size of heap */
        -: 5278:                      jerry_context_alloc_t alloc, /**< the alloc function */
        -: 5279:                      void *cb_data_p) /**< the cb_data for alloc function */
        -: 5280:{
        -: 5281:  JERRY_UNUSED (heap_size);
        -: 5282:
        -: 5283:#if JERRY_EXTERNAL_CONTEXT
        -: 5284:
        -: 5285:  size_t total_size = sizeof (jerry_context_t) + JMEM_ALIGNMENT;
        -: 5286:
        -: 5287:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5288:  heap_size = JERRY_ALIGNUP (heap_size, JMEM_ALIGNMENT);
        -: 5289:
        -: 5290:  /* Minimum heap size is 1Kbyte. */
        -: 5291:  if (heap_size < 1024)
        -: 5292:  {
        -: 5293:    return NULL;
        -: 5294:  }
        -: 5295:
        -: 5296:  total_size += heap_size;
        -: 5297:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5298:
        -: 5299:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -: 5300:
        -: 5301:  jerry_context_t *context_p = (jerry_context_t *) alloc (total_size, cb_data_p);
        -: 5302:
        -: 5303:  if (context_p == NULL)
        -: 5304:  {
        -: 5305:    return NULL;
        -: 5306:  }
        -: 5307:
        -: 5308:  memset (context_p, 0, total_size);
        -: 5309:
        -: 5310:  uintptr_t context_ptr = ((uintptr_t) context_p) + sizeof (jerry_context_t);
        -: 5311:  context_ptr = JERRY_ALIGNUP (context_ptr, (uintptr_t) JMEM_ALIGNMENT);
        -: 5312:
        -: 5313:  uint8_t *byte_p = (uint8_t *) context_ptr;
        -: 5314:
        -: 5315:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5316:  context_p->heap_p = (jmem_heap_t *) byte_p;
        -: 5317:  context_p->heap_size = heap_size;
        -: 5318:  byte_p += heap_size;
        -: 5319:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5320:
        -: 5321:  JERRY_ASSERT (byte_p <= ((uint8_t *) context_p) + total_size);
        -: 5322:
        -: 5323:  JERRY_UNUSED (byte_p);
        -: 5324:  return context_p;
        -: 5325:
        -: 5326:#else /* !JERRY_EXTERNAL_CONTEXT */
        -: 5327:
        -: 5328:  JERRY_UNUSED (alloc);
        -: 5329:  JERRY_UNUSED (cb_data_p);
        -: 5330:
    #####: 5331:  return NULL;
        -: 5332:
        -: 5333:#endif /* JERRY_EXTERNAL_CONTEXT */
        -: 5334:} /* jerry_create_context */
        -: 5335:
        -: 5336:/**
        -: 5337: * When JERRY_VM_EXEC_STOP is enabled, the callback passed to this function
        -: 5338: * is periodically called with the user_p argument. If frequency is greater
        -: 5339: * than 1, the callback is only called at every frequency ticks.
        -: 5340: */
        -: 5341:void
    #####: 5342:jerry_set_vm_exec_stop_callback (jerry_vm_exec_stop_callback_t stop_cb, /**< periodically called user function */
        -: 5343:                                 void *user_p, /**< pointer passed to the function */
        -: 5344:                                 uint32_t frequency) /**< frequency of the function call */
        -: 5345:{
        -: 5346:#if JERRY_VM_EXEC_STOP
    #####: 5347:  if (frequency == 0)
        -: 5348:  {
    #####: 5349:    frequency = 1;
        -: 5350:  }
        -: 5351:
    #####: 5352:  JERRY_CONTEXT (vm_exec_stop_frequency) = frequency;
    #####: 5353:  JERRY_CONTEXT (vm_exec_stop_counter) = frequency;
    #####: 5354:  JERRY_CONTEXT (vm_exec_stop_cb) = stop_cb;
    #####: 5355:  JERRY_CONTEXT (vm_exec_stop_user_p) = user_p;
        -: 5356:#else /* !JERRY_VM_EXEC_STOP */
        -: 5357:  JERRY_UNUSED (stop_cb);
        -: 5358:  JERRY_UNUSED (user_p);
        -: 5359:  JERRY_UNUSED (frequency);
        -: 5360:#endif /* JERRY_VM_EXEC_STOP */
    #####: 5361:} /* jerry_set_vm_exec_stop_callback */
        -: 5362:
        -: 5363:/**
        -: 5364: * Get backtrace. The backtrace is an array of strings where
        -: 5365: * each string contains the position of the corresponding frame.
        -: 5366: * The array length is zero if the backtrace is not available.
        -: 5367: *
        -: 5368: * @return array value
        -: 5369: */
        -: 5370:jerry_value_t
    #####: 5371:jerry_get_backtrace (uint32_t max_depth) /**< depth limit of the backtrace */
        -: 5372:{
    #####: 5373:  return vm_get_backtrace (max_depth);
        -: 5374:} /* jerry_get_backtrace */
        -: 5375:
        -: 5376:/**
        -: 5377: * Low-level function to capture each backtrace frame.
        -: 5378: * The captured frame data is passed to a callback function.
        -: 5379: */
        -: 5380:void
    #####: 5381:jerry_backtrace_capture (jerry_backtrace_callback_t callback, /**< callback function */
        -: 5382:                         void *user_p) /**< user pointer passed to the callback function */
        -: 5383:{
    #####: 5384:  jerry_backtrace_frame_t frame;
    #####: 5385:  vm_frame_ctx_t *context_p = JERRY_CONTEXT (vm_top_context_p);
        -: 5386:
    #####: 5387:  while (context_p != NULL)
        -: 5388:  {
    #####: 5389:    frame.context_p = context_p;
    #####: 5390:    frame.frame_type = JERRY_BACKTRACE_FRAME_JS;
        -: 5391:
    #####: 5392:    if (!callback (&frame, user_p))
        -: 5393:    {
    #####: 5394:      return;
        -: 5395:    }
        -: 5396:
    #####: 5397:    context_p = context_p->prev_context_p;
        -: 5398:  }
        -: 5399:} /* jerry_backtrace_capture */
        -: 5400:
        -: 5401:/**
        -: 5402: * Returns with the type of the backtrace frame.
        -: 5403: *
        -: 5404: * @return frame type listed in jerry_backtrace_frame_types_t
        -: 5405: */
        -: 5406:jerry_backtrace_frame_types_t
    #####: 5407:jerry_backtrace_get_frame_type (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5408:{
    #####: 5409:  return (jerry_backtrace_frame_types_t) frame_p->frame_type;
        -: 5410:} /* jerry_backtrace_get_frame_type */
        -: 5411:
        -: 5412:/**
        -: 5413: * Initialize and return with the location private field of a backtrace frame.
        -: 5414: *
        -: 5415: * @return pointer to the location private field - if the location is available,
        -: 5416: *         NULL - otherwise
        -: 5417: */
        -: 5418:const jerry_backtrace_location_t *
    #####: 5419:jerry_backtrace_get_location (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5420:{
        -: 5421:  JERRY_UNUSED (frame_p);
        -: 5422:
        -: 5423:#if JERRY_LINE_INFO
    #####: 5424:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5425:  {
    #####: 5426:    vm_frame_ctx_t *context_p = frame_p->context_p;
    #####: 5427:    const ecma_compiled_code_t *bytecode_header_p = context_p->shared_p->bytecode_header_p;
        -: 5428:
    #####: 5429:    if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_HAS_LINE_INFO))
        -: 5430:    {
        -: 5431:      return NULL;
        -: 5432:    }
        -: 5433:
    #####: 5434:    frame_p->location.resource_name = ecma_get_resource_name (bytecode_header_p);
        -: 5435:
    #####: 5436:    ecma_line_info_get (ecma_compiled_code_get_line_info (bytecode_header_p),
    #####: 5437:                        (uint32_t) (context_p->byte_code_p - context_p->byte_code_start_p),
        -: 5438:                        &frame_p->location);
        -: 5439:
    #####: 5440:    return &frame_p->location;
        -: 5441:  }
        -: 5442:#endif /* JERRY_LINE_INFO */
        -: 5443:
    #####: 5444:  return NULL;
        -: 5445:} /* jerry_backtrace_get_location */
        -: 5446:
        -: 5447:/**
        -: 5448: * Initialize and return with the called function private field of a backtrace frame.
        -: 5449: * The backtrace frame is created for running the code bound to this function.
        -: 5450: *
        -: 5451: * @return pointer to the called function - if the function is available,
        -: 5452: *         NULL - otherwise
        -: 5453: */
        -: 5454:const jerry_value_t *
    #####: 5455:jerry_backtrace_get_function (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5456:{
    #####: 5457:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5458:  {
    #####: 5459:    vm_frame_ctx_t *context_p = frame_p->context_p;
        -: 5460:
    #####: 5461:    if (context_p->shared_p->function_object_p != NULL)
        -: 5462:    {
    #####: 5463:      frame_p->function = ecma_make_object_value (context_p->shared_p->function_object_p);
    #####: 5464:      return &frame_p->function;
        -: 5465:    }
        -: 5466:  }
        -: 5467:
    #####: 5468:  return NULL;
        -: 5469:} /* jerry_backtrace_get_function */
        -: 5470:
        -: 5471:/**
        -: 5472: * Initialize and return with the 'this' binding private field of a backtrace frame.
        -: 5473: * The 'this' binding is a hidden value passed to the called function. As for arrow
        -: 5474: * functions, the 'this' binding is assigned at function creation.
        -: 5475: *
        -: 5476: * @return pointer to the 'this' binding - if the binding is available,
        -: 5477: *         NULL - otherwise
        -: 5478: */
        -: 5479:const jerry_value_t *
    #####: 5480:jerry_backtrace_get_this (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5481:{
    #####: 5482:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5483:  {
    #####: 5484:    frame_p->this_binding = frame_p->context_p->this_binding;
    #####: 5485:    return &frame_p->this_binding;
        -: 5486:  }
        -: 5487:
    #####: 5488:  return NULL;
        -: 5489:} /* jerry_backtrace_get_this */
        -: 5490:
        -: 5491:/**
        -: 5492: * Returns true, if the code bound to the backtrace frame is strict mode code.
        -: 5493: *
        -: 5494: * @return true - if strict mode code is bound to the frame,
        -: 5495: *         false - otherwise
        -: 5496: */
        -: 5497:bool
    #####: 5498:jerry_backtrace_is_strict (jerry_backtrace_frame_t *frame_p) /**< frame pointer */
        -: 5499:{
    #####: 5500:  return (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS
    #####: 5501:          && (frame_p->context_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0);
        -: 5502:} /* jerry_backtrace_is_strict */
        -: 5503:
        -: 5504:/**
        -: 5505: * Get the resource name (usually a file name) of the currently executed script or the given function object
        -: 5506: *
        -: 5507: * Note: returned value must be freed with jerry_release_value, when it is no longer needed
        -: 5508: *
        -: 5509: * @return JS string constructed from
        -: 5510: *         - the currently executed function object's resource name, if the given value is undefined
        -: 5511: *         - resource name of the function object, if the given value is a function object
        -: 5512: *         - "<anonymous>", otherwise
        -: 5513: */
        -: 5514:jerry_value_t
    #####: 5515:jerry_get_resource_name (const jerry_value_t value) /**< jerry api value */
        -: 5516:{
        -: 5517:#if JERRY_RESOURCE_NAME
    #####: 5518:  if (ecma_is_value_undefined (value) && JERRY_CONTEXT (vm_top_context_p) != NULL)
        -: 5519:  {
    #####: 5520:    return ecma_copy_value (ecma_get_resource_name (JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p));
        -: 5521:  }
        -: 5522:
    #####: 5523:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5524:
    #####: 5525:  if (script_value == JMEM_CP_NULL)
        -: 5526:  {
    #####: 5527:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -: 5528:  }
        -: 5529:
    #####: 5530:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5531:
    #####: 5532:  return ecma_copy_value (script_p->resource_name);
        -: 5533:#else /* !JERRY_RESOURCE_NAME */
        -: 5534:  JERRY_UNUSED (value);
        -: 5535:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_RESOURCE_ANON);
        -: 5536:#endif /* JERRY_RESOURCE_NAME */
        -: 5537:} /* jerry_get_resource_name */
        -: 5538:
        -: 5539:/**
        -: 5540: * Returns the user value assigned to a script / module / function.
        -: 5541: *
        -: 5542: * Note:
        -: 5543: *    This value is usually set by the parser when
        -: 5544: *    the JERRY_PARSE_HAS_USER_VALUE flag is passed.
        -: 5545: *
        -: 5546: * @return user value
        -: 5547: */
        -: 5548:jerry_value_t
    #####: 5549:jerry_get_user_value (const jerry_value_t value) /**< jerry api value */
        -: 5550:{
    #####: 5551:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5552:
    #####: 5553:  if (script_value == JMEM_CP_NULL)
        -: 5554:  {
    #####: 5555:    return ECMA_VALUE_UNDEFINED;
        -: 5556:  }
        -: 5557:
    #####: 5558:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5559:
    #####: 5560:  if (!(script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE))
        -: 5561:  {
    #####: 5562:    return ECMA_VALUE_UNDEFINED;
        -: 5563:  }
        -: 5564:
    #####: 5565:  return ecma_copy_value (CBC_SCRIPT_GET_USER_VALUE (script_p));
        -: 5566:} /* jerry_get_user_value */
        -: 5567:
        -: 5568:/**
        -: 5569: * Checks whether an ECMAScript code is compiled by eval
        -: 5570: * like (eval, new Function, jerry_eval, etc.) command.
        -: 5571: *
        -: 5572: * @return true, if code is compiled by eval like command
        -: 5573: *         false, otherwise
        -: 5574: */
        -: 5575:bool
    #####: 5576:jerry_is_eval_code (const jerry_value_t value) /**< jerry api value */
        -: 5577:{
    #####: 5578:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5579:
    #####: 5580:  if (script_value == JMEM_CP_NULL)
        -: 5581:  {
    #####: 5582:    return false;
        -: 5583:  }
        -: 5584:
    #####: 5585:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5586:
    #####: 5587:  return (script_p->refs_and_type & CBC_SCRIPT_IS_EVAL_CODE) != 0;
        -: 5588:} /* jerry_is_eval_code */
        -: 5589:
        -: 5590:/**
        -: 5591: * Returns a newly created source info structure corresponding to the passed script/module/function.
        -: 5592: *
        -: 5593: * @return a newly created source info, if at least one field is available, NULL otherwise
        -: 5594: */
        -: 5595:jerry_source_info_t *
    #####: 5596:jerry_get_source_info (const jerry_value_t value) /**< jerry api value */
        -: 5597:{
        -: 5598:  jerry_assert_api_available ();
        -: 5599:
        -: 5600:#if JERRY_FUNCTION_TO_STRING
    #####: 5601:  if (!ecma_is_value_object (value))
        -: 5602:  {
        -: 5603:    return NULL;
        -: 5604:  }
        -: 5605:
        -: 5606:  jerry_source_info_t source_info;
        -: 5607:
    #####: 5608:  source_info.enabled_fields = 0;
    #####: 5609:  source_info.source_code = ECMA_VALUE_UNDEFINED;
    #####: 5610:  source_info.function_arguments = ECMA_VALUE_UNDEFINED;
    #####: 5611:  source_info.source_range_start = 0;
    #####: 5612:  source_info.source_range_length = 0;
        -: 5613:
    #####: 5614:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 5615:  cbc_script_t *script_p = NULL;
        -: 5616:
        -: 5617:  while (true)
        -: 5618:  {
    #####: 5619:    switch (ecma_get_object_type (object_p))
        -: 5620:    {
    #####: 5621:      case ECMA_OBJECT_TYPE_CLASS:
        -: 5622:      {
    #####: 5623:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 5624:        const ecma_compiled_code_t *bytecode_p = NULL;
        -: 5625:
    #####: 5626:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_SCRIPT)
        -: 5627:        {
    #####: 5628:          bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 5629:                                                        ext_object_p->u.cls.u3.value);
        -: 5630:        }
        -: 5631:#if JERRY_MODULE_SYSTEM
    #####: 5632:        else if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_MODULE)
        -: 5633:        {
    #####: 5634:          ecma_module_t *module_p = (ecma_module_t *) object_p;
        -: 5635:
    #####: 5636:          if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE))
        -: 5637:          {
    #####: 5638:            bytecode_p = module_p->u.compiled_code_p;
        -: 5639:          }
        -: 5640:        }
        -: 5641:#endif /* JERRY_MODULE_SYSTEM */
        -: 5642:
    #####: 5643:        if (bytecode_p == NULL)
        -: 5644:        {
        -: 5645:          return NULL;
        -: 5646:        }
        -: 5647:
    #####: 5648:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5649:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5650:        break;
        -: 5651:      }
    #####: 5652:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 5653:      {
        -: 5654:        const ecma_compiled_code_t *bytecode_p;
    #####: 5655:        bytecode_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);
        -: 5656:
    #####: 5657:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5658:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5659:
    #####: 5660:        if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_EXTENDED_INFO)
        -: 5661:        {
    #####: 5662:          uint8_t *extended_info_p = ecma_compiled_code_resolve_extended_info (bytecode_p);
    #####: 5663:          uint8_t extended_info = *extended_info_p;
        -: 5664:
        -: 5665:#if JERRY_ESNEXT
    #####: 5666:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH)
        -: 5667:          {
    #####: 5668:            ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5669:          }
        -: 5670:#endif /* JERRY_ESNEXT */
        -: 5671:
    #####: 5672:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 5673:          {
    #####: 5674:            ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5675:
    #####: 5676:            ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5677:
    #####: 5678:            source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5679:            source_info.source_code = function_arguments;
    #####: 5680:            script_p = NULL;
        -: 5681:          }
        -: 5682:
    #####: 5683:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_RANGE;
    #####: 5684:          source_info.source_range_start = ecma_extended_info_decode_vlq (&extended_info_p);
    #####: 5685:          source_info.source_range_length = ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5686:        }
        -: 5687:
        -: 5688:        JERRY_ASSERT (script_p != NULL || (source_info.enabled_fields & JERRY_SOURCE_INFO_HAS_SOURCE_CODE));
        -: 5689:
    #####: 5690:        if (source_info.enabled_fields == 0 && (script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS))
        -: 5691:        {
    #####: 5692:          ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5693:
    #####: 5694:          ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5695:
    #####: 5696:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_FUNCTION_ARGUMENTS;
    #####: 5697:          source_info.function_arguments = function_arguments;
        -: 5698:        }
        -: 5699:        break;
        -: 5700:      }
    #####: 5701:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 5702:      {
    #####: 5703:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 5704:
    #####: 5705:        object_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -: 5706:                                                               ext_object_p->u.bound_function.target_function);
    #####: 5707:        continue;
        -: 5708:      }
        -: 5709:#if JERRY_ESNEXT
    #####: 5710:      case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
        -: 5711:      {
    #####: 5712:        ecma_value_t script_value = ((ecma_extended_object_t *) object_p)->u.constructor_function.script_value;
    #####: 5713:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5714:        break;
        -: 5715:      }
        -: 5716:#endif /* JERRY_ESNEXT */
        -: 5717:      default:
        -: 5718:      {
        -: 5719:        return NULL;
        -: 5720:      }
        -: 5721:    }
        -: 5722:
        -: 5723:    break;
        -: 5724:  }
        -: 5725:
    #####: 5726:  jerry_source_info_t *source_info_p = jmem_heap_alloc_block_null_on_error (sizeof (jerry_source_info_t));
        -: 5727:
    #####: 5728:  if (source_info_p == NULL)
        -: 5729:  {
        -: 5730:    return NULL;
        -: 5731:  }
        -: 5732:
    #####: 5733:  if (script_p != NULL)
        -: 5734:  {
    #####: 5735:    ecma_ref_ecma_string (ecma_get_string_from_value (script_p->source_code));
        -: 5736:
    #####: 5737:    source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5738:    source_info.source_code = script_p->source_code;
        -: 5739:  }
        -: 5740:
        -: 5741:  JERRY_ASSERT (source_info.enabled_fields != 0);
        -: 5742:
    #####: 5743:  *source_info_p = source_info;
    #####: 5744:  return source_info_p;
        -: 5745:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5746:  JERRY_UNUSED (value);
    #####: 5747:  return NULL;
        -: 5748:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 5749:} /* jerry_get_source_info */
        -: 5750:
        -: 5751:/**
        -: 5752: * Frees the the source info structure returned by jerry_get_source_info.
        -: 5753: */
        -: 5754:void
    #####: 5755:jerry_free_source_info (jerry_source_info_t *source_info_p) /**< source info block */
        -: 5756:{
        -: 5757:  jerry_assert_api_available ();
        -: 5758:
        -: 5759:#if JERRY_FUNCTION_TO_STRING
    #####: 5760:  if (source_info_p != NULL)
        -: 5761:  {
    #####: 5762:    ecma_free_value (source_info_p->source_code);
    #####: 5763:    ecma_free_value (source_info_p->function_arguments);
    #####: 5764:    jmem_heap_free_block (source_info_p, sizeof (jerry_source_info_t));
        -: 5765:  }
        -: 5766:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5767:  JERRY_UNUSED (source_info_p);
        -: 5768:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 5769:} /* jerry_free_source_info */
        -: 5770:
        -: 5771:/**
        -: 5772: * Replaces the currently active realm with another realm.
        -: 5773: *
        -: 5774: * The replacement should be temporary, and the original realm must be
        -: 5775: * restored after the tasks are completed. During the replacement, the
        -: 5776: * realm must be referenced by the application (i.e. the gc must not
        -: 5777: * reclaim it). This is also true to the returned previously active
        -: 5778: * realm, so there is no need to free the value after the restoration.
        -: 5779: *
        -: 5780: * @return previous realm value - if the passed value is a realm
        -: 5781: *         exception - otherwise
        -: 5782: */
        -: 5783:jerry_value_t
    #####: 5784:jerry_set_realm (jerry_value_t realm_value) /**< jerry api value */
        -: 5785:{
        -: 5786:  jerry_assert_api_available ();
        -: 5787:
        -: 5788:#if JERRY_BUILTIN_REALMS
    #####: 5789:  if (ecma_is_value_object (realm_value))
        -: 5790:  {
    #####: 5791:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5792:
    #####: 5793:    if (ecma_builtin_is_global (object_p))
        -: 5794:    {
    #####: 5795:      ecma_global_object_t *previous_global_object_p = JERRY_CONTEXT (global_object_p);
    #####: 5796:      JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) object_p;
    #####: 5797:      return ecma_make_object_value ((ecma_object_t *) previous_global_object_p);
        -: 5798:    }
        -: 5799:  }
        -: 5800:
    #####: 5801:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Passed argument is not a realm")));
        -: 5802:#else /* !JERRY_BUILTIN_REALMS */
        -: 5803:  JERRY_UNUSED (realm_value);
    #####: 5804:  return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG ("Realm is not available")));
        -: 5805:#endif /* JERRY_BUILTIN_REALMS */
        -: 5806:} /* jerry_set_realm */
        -: 5807:
        -: 5808:/**
        -: 5809: * Gets the 'this' binding of a realm
        -: 5810: *
        -: 5811: * @return type error - if realm_value is not a realm
        -: 5812: *         this value - otherwise
        -: 5813: */
        -: 5814:jerry_value_t
    #####: 5815:jerry_realm_get_this (jerry_value_t realm_value) /**< realm value */
        -: 5816:{
        -: 5817:  jerry_assert_api_available ();
        -: 5818:
        -: 5819:#if JERRY_BUILTIN_REALMS
    #####: 5820:  if (ecma_is_value_object (realm_value))
        -: 5821:  {
    #####: 5822:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5823:
    #####: 5824:    if (ecma_builtin_is_global (object_p))
        -: 5825:    {
    #####: 5826:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
        -: 5827:
    #####: 5828:      ecma_ref_object (ecma_get_object_from_value (global_object_p->this_binding));
    #####: 5829:      return global_object_p->this_binding;
        -: 5830:    }
        -: 5831:  }
        -: 5832:
        -: 5833:#else /* !JERRY_BUILTIN_REALMS */
    #####: 5834:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -: 5835:
    #####: 5836:  if (realm_value == ecma_make_object_value (global_object_p))
        -: 5837:  {
    #####: 5838:    ecma_ref_object (global_object_p);
    #####: 5839:    return realm_value;
        -: 5840:  }
        -: 5841:#endif /* JERRY_BUILTIN_REALMS */
        -: 5842:
    #####: 5843:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Passed argument is not a realm")));
        -: 5844:} /* jerry_realm_get_this */
        -: 5845:
        -: 5846:/**
        -: 5847: * Sets the 'this' binding of a realm
        -: 5848: *
        -: 5849: * This function must be called before executing any script on the realm.
        -: 5850: * Otherwise the operation is undefined.
        -: 5851: *
        -: 5852: * @return type error - if realm_value is not a realm or this_value is not object
        -: 5853: *         true - otherwise
        -: 5854: */
        -: 5855:jerry_value_t
    #####: 5856:jerry_realm_set_this (jerry_value_t realm_value, /**< realm value */
        -: 5857:                      jerry_value_t this_value) /**< this value */
        -: 5858:{
        -: 5859:  jerry_assert_api_available ();
        -: 5860:
        -: 5861:#if JERRY_BUILTIN_REALMS
    #####: 5862:  if (!ecma_is_value_object (this_value))
        -: 5863:  {
    #####: 5864:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Second argument must be an object")));
        -: 5865:  }
        -: 5866:
    #####: 5867:  if (ecma_is_value_object (realm_value))
        -: 5868:  {
    #####: 5869:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5870:
    #####: 5871:    if (ecma_builtin_is_global (object_p))
        -: 5872:    {
    #####: 5873:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
    #####: 5874:      global_object_p->this_binding = this_value;
        -: 5875:
    #####: 5876:      ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL, ecma_get_object_from_value (this_value));
        -: 5877:
    #####: 5878:      ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, global_lex_env_p);
        -: 5879:#if JERRY_ESNEXT
    #####: 5880:      global_object_p->global_scope_cp = global_object_p->global_env_cp;
        -: 5881:#endif /* JERRY_ESNEXT */
    #####: 5882:      ecma_deref_object (global_lex_env_p);
    #####: 5883:      return ECMA_VALUE_TRUE;
        -: 5884:    }
        -: 5885:  }
        -: 5886:
    #####: 5887:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("First argument is not a realm")));
        -: 5888:#else /* !JERRY_BUILTIN_REALMS */
        -: 5889:  JERRY_UNUSED (realm_value);
        -: 5890:  JERRY_UNUSED (this_value);
    #####: 5891:  return jerry_throw (ecma_raise_reference_error (ECMA_ERR_MSG ("Realm is not available")));
        -: 5892:#endif /* JERRY_BUILTIN_REALMS */
        -: 5893:} /* jerry_realm_set_this */
        -: 5894:
        -: 5895:/**
        -: 5896: * Check if the given value is an ArrayBuffer object.
        -: 5897: *
        -: 5898: * @return true - if it is an ArrayBuffer object
        -: 5899: *         false - otherwise
        -: 5900: */
        -: 5901:bool
    #####: 5902:jerry_value_is_arraybuffer (const jerry_value_t value) /**< value to check if it is an ArrayBuffer */
        -: 5903:{
        -: 5904:  jerry_assert_api_available ();
        -: 5905:
        -: 5906:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5907:  return ecma_is_arraybuffer (value);
        -: 5908:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5909:  JERRY_UNUSED (value);
    #####: 5910:  return false;
        -: 5911:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5912:} /* jerry_value_is_arraybuffer */
        -: 5913:
        -: 5914:/**
        -: 5915: * Creates an ArrayBuffer object with the given length (size).
        -: 5916: *
        -: 5917: * Notes:
        -: 5918: *      * the length is specified in bytes.
        -: 5919: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5920: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5921: *
        -: 5922: * @return value of the constructed ArrayBuffer object
        -: 5923: */
        -: 5924:jerry_value_t
    #####: 5925:jerry_create_arraybuffer (const jerry_length_t size) /**< size of the ArrayBuffer to create */
        -: 5926:{
        -: 5927:  jerry_assert_api_available ();
        -: 5928:
        -: 5929:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5930:  return jerry_return (ecma_make_object_value (ecma_arraybuffer_new_object (size)));
        -: 5931:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5932:  JERRY_UNUSED (size);
    #####: 5933:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 5934:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5935:} /* jerry_create_arraybuffer */
        -: 5936:
        -: 5937:/**
        -: 5938: * Creates an ArrayBuffer object with user specified buffer.
        -: 5939: *
        -: 5940: * Notes:
        -: 5941: *     * the size is specified in bytes.
        -: 5942: *     * the buffer passed should be at least the specified bytes big.
        -: 5943: *     * if the typed arrays are disabled this will return a TypeError.
        -: 5944: *     * if the size is zero or buffer_p is a null pointer this will return an empty ArrayBuffer.
        -: 5945: *
        -: 5946: * @return value of the construced ArrayBuffer object
        -: 5947: */
        -: 5948:jerry_value_t
    #####: 5949:jerry_create_arraybuffer_external (const jerry_length_t size, /**< size of the buffer to used */
        -: 5950:                                   uint8_t *buffer_p, /**< buffer to use as the ArrayBuffer's backing */
        -: 5951:                                   jerry_value_free_callback_t free_cb) /**< buffer free callback */
        -: 5952:{
        -: 5953:  jerry_assert_api_available ();
        -: 5954:
        -: 5955:#if JERRY_BUILTIN_TYPEDARRAY
        -: 5956:  ecma_object_t *arraybuffer;
        -: 5957:
    #####: 5958:  if (JERRY_UNLIKELY (size == 0 || buffer_p == NULL))
        -: 5959:  {
    #####: 5960:    arraybuffer = ecma_arraybuffer_new_object (0);
        -: 5961:  }
        -: 5962:  else
        -: 5963:  {
    #####: 5964:    arraybuffer = ecma_arraybuffer_new_object_external (size, buffer_p, free_cb);
        -: 5965:  }
        -: 5966:
    #####: 5967:  return jerry_return (ecma_make_object_value (arraybuffer));
        -: 5968:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5969:  JERRY_UNUSED (size);
        -: 5970:  JERRY_UNUSED (buffer_p);
        -: 5971:  JERRY_UNUSED (free_cb);
    #####: 5972:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 5973:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5974:} /* jerry_create_arraybuffer_external */
        -: 5975:
        -: 5976:/**
        -: 5977: * Check if the given value is a SharedArrayBuffer object.
        -: 5978: *
        -: 5979: * @return true - if it is a SharedArrayBuffer object
        -: 5980: *         false - otherwise
        -: 5981: */
        -: 5982:bool
    #####: 5983:jerry_value_is_shared_arraybuffer (const jerry_value_t value) /**< value to check if it is a SharedArrayBuffer */
        -: 5984:{
        -: 5985:  jerry_assert_api_available ();
        -: 5986:
    #####: 5987:  return ecma_is_shared_arraybuffer (value);
        -: 5988:} /* jerry_value_is_shared_arraybuffer */
        -: 5989:
        -: 5990:/**
        -: 5991: * Creates a SharedArrayBuffer object with the given length (size).
        -: 5992: *
        -: 5993: * Notes:
        -: 5994: *      * the length is specified in bytes.
        -: 5995: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 5996: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5997: *
        -: 5998: * @return value of the constructed SharedArrayBuffer object
        -: 5999: */
        -: 6000:jerry_value_t
    #####: 6001:jerry_create_shared_arraybuffer (const jerry_length_t size) /**< size of the SharedArrayBuffer to create */
        -: 6002:{
        -: 6003:  jerry_assert_api_available ();
        -: 6004:
        -: 6005:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
    #####: 6006:  return jerry_return (ecma_make_object_value (ecma_shared_arraybuffer_new_object (size)));
        -: 6007:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 6008:  JERRY_UNUSED (size);
    #####: 6009:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_shared_arraybuffer_not_supported_p)));
        -: 6010:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 6011:} /* jerry_create_shared_arraybuffer */
        -: 6012:
        -: 6013:/**
        -: 6014: * Creates a SharedArrayBuffer object with user specified buffer.
        -: 6015: *
        -: 6016: * Notes:
        -: 6017: *     * the size is specified in bytes.
        -: 6018: *     * the buffer passed should be at least the specified bytes big.
        -: 6019: *     * if the typed arrays are disabled this will return a TypeError.
        -: 6020: *     * if the size is zero or buffer_p is a null pointer this will return an empty SharedArrayBuffer.
        -: 6021: *
        -: 6022: * @return value of the construced SharedArrayBuffer object
        -: 6023: */
        -: 6024:jerry_value_t
    #####: 6025:jerry_create_shared_arraybuffer_external (const jerry_length_t size, /**< size of the buffer to used */
        -: 6026:                                          uint8_t *buffer_p, /**< buffer to use as the SharedArrayBuffer's backing */
        -: 6027:                                          jerry_value_free_callback_t free_cb) /**< buffer free callback */
        -: 6028:{
        -: 6029:  jerry_assert_api_available ();
        -: 6030:
        -: 6031:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 6032:  ecma_object_t *shared_arraybuffer;
        -: 6033:
    #####: 6034:  if (JERRY_UNLIKELY (size == 0 || buffer_p == NULL))
        -: 6035:  {
    #####: 6036:    shared_arraybuffer = ecma_shared_arraybuffer_new_object (0);
        -: 6037:  }
        -: 6038:  else
        -: 6039:  {
    #####: 6040:    shared_arraybuffer = ecma_shared_arraybuffer_new_object_external (size, buffer_p, free_cb);
        -: 6041:  }
        -: 6042:
    #####: 6043:  return jerry_return (ecma_make_object_value (shared_arraybuffer));
        -: 6044:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 6045:  JERRY_UNUSED (size);
        -: 6046:  JERRY_UNUSED (buffer_p);
        -: 6047:  JERRY_UNUSED (free_cb);
    #####: 6048:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_shared_arraybuffer_not_supported_p)));
        -: 6049:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 6050:} /* jerry_create_shared_arraybuffer_external */
        -: 6051:
        -: 6052:/**
        -: 6053: * Copy bytes into the ArrayBuffer or SharedArrayBuffer from a buffer.
        -: 6054: *
        -: 6055: * Note:
        -: 6056: *     * returns 0, if the passed object is not an ArrayBuffer or SharedArrayBuffer
        -: 6057: *
        -: 6058: * @return number of bytes copied into the ArrayBuffer or SharedArrayBuffer.
        -: 6059: */
        -: 6060:jerry_length_t
    #####: 6061:jerry_arraybuffer_write (const jerry_value_t value, /**< target ArrayBuffer or SharedArrayBuffer */
        -: 6062:                         jerry_length_t offset, /**< start offset of the ArrayBuffer */
        -: 6063:                         const uint8_t *buf_p, /**< buffer to copy from */
        -: 6064:                         jerry_length_t buf_size) /**< number of bytes to copy from the buffer */
        -: 6065:{
        -: 6066:  jerry_assert_api_available ();
        -: 6067:
        -: 6068:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6069:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 6070:  {
    #####: 6071:    return 0;
        -: 6072:  }
        -: 6073:
    #####: 6074:  ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6075:  jerry_length_t length = ecma_arraybuffer_get_length (buffer_p);
        -: 6076:
    #####: 6077:  if (offset >= length)
        -: 6078:  {
    #####: 6079:    return 0;
        -: 6080:  }
        -: 6081:
    #####: 6082:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 6083:
    #####: 6084:  if (copy_count > 0)
        -: 6085:  {
    #####: 6086:    lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
        -: 6087:
    #####: 6088:    memcpy ((void *) (mem_buffer_p + offset), (void *) buf_p, copy_count);
        -: 6089:  }
        -: 6090:
    #####: 6091:  return copy_count;
        -: 6092:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6093:  JERRY_UNUSED (value);
        -: 6094:  JERRY_UNUSED (offset);
        -: 6095:  JERRY_UNUSED (buf_p);
        -: 6096:  JERRY_UNUSED (buf_size);
    #####: 6097:  return 0;
        -: 6098:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6099:} /* jerry_arraybuffer_write */
        -: 6100:
        -: 6101:/**
        -: 6102: * Copy bytes from a buffer into an ArrayBuffer or SharedArrayBuffer.
        -: 6103: *
        -: 6104: * Note:
        -: 6105: *     * if the object passed is not an ArrayBuffer or SharedArrayBuffer will return 0.
        -: 6106: *
        -: 6107: * @return number of bytes read from the ArrayBuffer.
        -: 6108: */
        -: 6109:jerry_length_t
    #####: 6110:jerry_arraybuffer_read (const jerry_value_t value, /**< ArrayBuffer or SharedArrayBuffer to read from */
        -: 6111:                        jerry_length_t offset, /**< start offset of the ArrayBuffer or SharedArrayBuffer */
        -: 6112:                        uint8_t *buf_p, /**< destination buffer to copy to */
        -: 6113:                        jerry_length_t buf_size) /**< number of bytes to copy into the buffer */
        -: 6114:{
        -: 6115:  jerry_assert_api_available ();
        -: 6116:
        -: 6117:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6118:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 6119:  {
    #####: 6120:    return 0;
        -: 6121:  }
        -: 6122:
    #####: 6123:  ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6124:  jerry_length_t length = ecma_arraybuffer_get_length (buffer_p);
        -: 6125:
    #####: 6126:  if (offset >= length)
        -: 6127:  {
    #####: 6128:    return 0;
        -: 6129:  }
        -: 6130:
    #####: 6131:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 6132:
    #####: 6133:  if (copy_count > 0)
        -: 6134:  {
    #####: 6135:    lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
        -: 6136:
    #####: 6137:    memcpy ((void *) buf_p, (void *) (mem_buffer_p + offset), copy_count);
        -: 6138:  }
        -: 6139:
    #####: 6140:  return copy_count;
        -: 6141:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6142:  JERRY_UNUSED (value);
        -: 6143:  JERRY_UNUSED (offset);
        -: 6144:  JERRY_UNUSED (buf_p);
        -: 6145:  JERRY_UNUSED (buf_size);
    #####: 6146:  return 0;
        -: 6147:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6148:} /* jerry_arraybuffer_read */
        -: 6149:
        -: 6150:/**
        -: 6151: * Get the length (size) of the ArrayBuffer or SharedArrayBuffer in bytes.
        -: 6152: *
        -: 6153: * Note:
        -: 6154: *     This is the 'byteLength' property of an ArrayBuffer or SharedArrayBuffer.
        -: 6155: *
        -: 6156: * @return the length of the ArrayBuffer in bytes.
        -: 6157: */
        -: 6158:jerry_length_t
    #####: 6159:jerry_get_arraybuffer_byte_length (const jerry_value_t value) /**< ArrayBuffer or SharedArrayBuffer */
        -: 6160:{
        -: 6161:  jerry_assert_api_available ();
        -: 6162:
        -: 6163:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6164:  if (ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value))
        -: 6165:  {
    #####: 6166:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6167:    return ecma_arraybuffer_get_length (buffer_p);
        -: 6168:  }
        -: 6169:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6170:  JERRY_UNUSED (value);
        -: 6171:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6172:  return 0;
        -: 6173:} /* jerry_get_arraybuffer_byte_length */
        -: 6174:
        -: 6175:/**
        -: 6176: * Get a pointer for the start of the ArrayBuffer.
        -: 6177: *
        -: 6178: * Note:
        -: 6179: *    * This is a high-risk operation as the bounds are not checked
        -: 6180: *      when accessing the pointer elements.
        -: 6181: *
        -: 6182: * @return pointer to the back-buffer of the ArrayBuffer.
        -: 6183: *         pointer is NULL if:
        -: 6184: *            - the parameter is not an ArrayBuffer
        -: 6185: *            - an external ArrayBuffer has been detached
        -: 6186: */
        -: 6187:uint8_t *
    #####: 6188:jerry_get_arraybuffer_pointer (const jerry_value_t array_buffer) /**< Array Buffer to use */
        -: 6189:{
        -: 6190:  jerry_assert_api_available ();
        -: 6191:
        -: 6192:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6193:  if (ecma_is_value_error_reference (array_buffer)
    #####: 6194:      || !(ecma_is_arraybuffer (array_buffer) || ecma_is_shared_arraybuffer (array_buffer)))
        -: 6195:  {
    #####: 6196:    return NULL;
        -: 6197:  }
        -: 6198:
    #####: 6199:  ecma_object_t *buffer_p = ecma_get_object_from_value (array_buffer);
    #####: 6200:  lit_utf8_byte_t *mem_buffer_p = ecma_arraybuffer_get_buffer (buffer_p);
    #####: 6201:  return (uint8_t *const) mem_buffer_p;
        -: 6202:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6203:  JERRY_UNUSED (array_buffer);
        -: 6204:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6205:
    #####: 6206:  return NULL;
        -: 6207:} /* jerry_get_arraybuffer_pointer */
        -: 6208:
        -: 6209:/**
        -: 6210: * Get if the ArrayBuffer is detachable.
        -: 6211: *
        -: 6212: * @return boolean value - if success
        -: 6213: *         value marked with error flag - otherwise
        -: 6214: */
        -: 6215:jerry_value_t
    #####: 6216:jerry_is_arraybuffer_detachable (const jerry_value_t value) /**< ArrayBuffer */
        -: 6217:{
        -: 6218:  jerry_assert_api_available ();
        -: 6219:
        -: 6220:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6221:  if (ecma_is_arraybuffer (value))
        -: 6222:  {
    #####: 6223:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6224:    return ecma_arraybuffer_is_detached (buffer_p) ? ECMA_VALUE_FALSE : ECMA_VALUE_TRUE;
        -: 6225:  }
        -: 6226:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6227:  JERRY_UNUSED (value);
        -: 6228:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6229:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expected an ArrayBuffer")));
        -: 6230:} /* jerry_is_arraybuffer_detachable */
        -: 6231:
        -: 6232:/**
        -: 6233: * Detach the underlying data block from ArrayBuffer and set its bytelength to 0.
        -: 6234: *
        -: 6235: * Note: If the ArrayBuffer has been created with `jerry_create_arraybuffer_external`
        -: 6236: *       the optional free callback is called on a successful detach operation
        -: 6237: *
        -: 6238: * @return null value - if success
        -: 6239: *         value marked with error flag - otherwise
        -: 6240: */
        -: 6241:jerry_value_t
    #####: 6242:jerry_detach_arraybuffer (const jerry_value_t value) /**< ArrayBuffer */
        -: 6243:{
        -: 6244:  jerry_assert_api_available ();
        -: 6245:
        -: 6246:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6247:  if (ecma_is_arraybuffer (value))
        -: 6248:  {
    #####: 6249:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6250:    if (ecma_arraybuffer_detach (buffer_p))
        -: 6251:    {
    #####: 6252:      return ECMA_VALUE_NULL;
        -: 6253:    }
    #####: 6254:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer has already been detached")));
        -: 6255:  }
        -: 6256:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6257:  JERRY_UNUSED (value);
        -: 6258:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6259:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Expected an ArrayBuffer")));
        -: 6260:} /* jerry_detach_arraybuffer */
        -: 6261:
        -: 6262:/**
        -: 6263: * DataView related functions
        -: 6264: */
        -: 6265:
        -: 6266:/**
        -: 6267: * Creates a DataView object with the given ArrayBuffer, ByteOffset and ByteLength arguments.
        -: 6268: *
        -: 6269: * Notes:
        -: 6270: *      * returned value must be freed with jerry_release_value, when it is no longer needed.
        -: 6271: *      * if the DataView bulitin is disabled this will return a TypeError.
        -: 6272: *
        -: 6273: * @return value of the constructed DataView object - if success
        -: 6274: *         created error - otherwise
        -: 6275: */
        -: 6276:jerry_value_t
    #####: 6277:jerry_create_dataview (const jerry_value_t array_buffer, /**< arraybuffer to create DataView from */
        -: 6278:                       const jerry_length_t byte_offset, /**< offset in bytes, to the first byte in the buffer */
        -: 6279:                       const jerry_length_t byte_length) /**< number of elements in the byte array */
        -: 6280:{
        -: 6281:  jerry_assert_api_available ();
        -: 6282:
        -: 6283:#if JERRY_BUILTIN_DATAVIEW
    #####: 6284:  if (ecma_is_value_error_reference (array_buffer))
        -: 6285:  {
    #####: 6286:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 6287:  }
        -: 6288:
    #####: 6289:  ecma_value_t arguments_p[3] =
        -: 6290:  {
        -: 6291:    array_buffer,
    #####: 6292:    ecma_make_uint32_value (byte_offset),
    #####: 6293:    ecma_make_uint32_value (byte_length)
        -: 6294:  };
    #####: 6295:  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);
    #####: 6296:  if (old_new_target_p == NULL)
        -: 6297:  {
    #####: 6298:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ECMA_BUILTIN_ID_DATAVIEW);
        -: 6299:  }
        -: 6300:
    #####: 6301:  ecma_value_t dataview_value = ecma_op_dataview_create (arguments_p, 3);
    #####: 6302:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6303:  return jerry_return (dataview_value);
        -: 6304:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6305:  JERRY_UNUSED (array_buffer);
        -: 6306:  JERRY_UNUSED (byte_offset);
        -: 6307:  JERRY_UNUSED (byte_length);
    #####: 6308:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_data_view_not_supported_p)));
        -: 6309:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6310:} /* jerry_create_dataview */
        -: 6311:
        -: 6312:/**
        -: 6313: * Check if the given value is a DataView object.
        -: 6314: *
        -: 6315: * @return true - if it is a DataView object
        -: 6316: *         false - otherwise
        -: 6317: */
        -: 6318:bool
    #####: 6319:jerry_value_is_dataview (const jerry_value_t value) /**< value to check if it is a DataView object */
        -: 6320:{
        -: 6321:  jerry_assert_api_available ();
        -: 6322:
        -: 6323:#if JERRY_BUILTIN_DATAVIEW
    #####: 6324:  return ecma_is_dataview (value);
        -: 6325:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6326:  JERRY_UNUSED (value);
    #####: 6327:  return false;
        -: 6328:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6329:} /* jerry_value_is_dataview */
        -: 6330:
        -: 6331:/**
        -: 6332: * Get the underlying ArrayBuffer from a DataView.
        -: 6333: *
        -: 6334: * Additionally the byteLength and byteOffset properties are also returned
        -: 6335: * which were specified when the DataView was created.
        -: 6336: *
        -: 6337: * Note:
        -: 6338: *     the returned value must be freed with a jerry_release_value call
        -: 6339: *
        -: 6340: * @return ArrayBuffer of a DataView
        -: 6341: *         TypeError if the object is not a DataView.
        -: 6342: */
        -: 6343:jerry_value_t
    #####: 6344:jerry_get_dataview_buffer (const jerry_value_t value, /**< DataView to get the arraybuffer from */
        -: 6345:                           jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6346:                           jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6347:{
        -: 6348:  jerry_assert_api_available ();
        -: 6349:
        -: 6350:#if JERRY_BUILTIN_DATAVIEW
    #####: 6351:  if (ecma_is_value_error_reference (value))
        -: 6352:  {
    #####: 6353:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 6354:  }
        -: 6355:
    #####: 6356:  ecma_dataview_object_t *dataview_p = ecma_op_dataview_get_object (value);
        -: 6357:
    #####: 6358:  if (JERRY_UNLIKELY (dataview_p == NULL))
        -: 6359:  {
    #####: 6360:    return ecma_create_error_reference_from_context ();
        -: 6361:  }
        -: 6362:
    #####: 6363:  if (byte_offset != NULL)
        -: 6364:  {
    #####: 6365:    *byte_offset = dataview_p->byte_offset;
        -: 6366:  }
        -: 6367:
    #####: 6368:  if (byte_length != NULL)
        -: 6369:  {
    #####: 6370:    *byte_length = dataview_p->header.u.cls.u3.length;
        -: 6371:  }
        -: 6372:
    #####: 6373:  ecma_object_t *arraybuffer_p = dataview_p->buffer_p;
    #####: 6374:  ecma_ref_object (arraybuffer_p);
        -: 6375:
    #####: 6376:  return ecma_make_object_value (arraybuffer_p);
        -: 6377:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6378:  JERRY_UNUSED (value);
        -: 6379:  JERRY_UNUSED (byte_offset);
        -: 6380:  JERRY_UNUSED (byte_length);
    #####: 6381:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_data_view_not_supported_p)));
        -: 6382:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6383:} /* jerry_get_dataview_buffer */
        -: 6384:
        -: 6385:/**
        -: 6386: * TypedArray related functions
        -: 6387: */
        -: 6388:
        -: 6389:/**
        -: 6390: * Check if the given value is a TypedArray object.
        -: 6391: *
        -: 6392: * @return true - if it is a TypedArray object
        -: 6393: *         false - otherwise
        -: 6394: */
        -: 6395:bool
    #####: 6396:jerry_value_is_typedarray (jerry_value_t value) /**< value to check if it is a TypedArray */
        -: 6397:{
        -: 6398:  jerry_assert_api_available ();
        -: 6399:
        -: 6400:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6401:  return ecma_is_typedarray (value);
        -: 6402:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6403:  JERRY_UNUSED (value);
    #####: 6404:  return false;
        -: 6405:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6406:} /* jerry_value_is_typedarray */
        -: 6407:
        -: 6408:#if JERRY_BUILTIN_TYPEDARRAY
        -: 6409:/**
        -: 6410: * TypedArray mapping type
        -: 6411: */
        -: 6412:typedef struct
        -: 6413:{
        -: 6414:  jerry_typedarray_type_t api_type; /**< api type */
        -: 6415:  ecma_builtin_id_t prototype_id; /**< prototype ID */
        -: 6416:  ecma_typedarray_type_t id; /**< typedArray ID */
        -: 6417:  uint8_t element_size_shift; /**< element size shift */
        -: 6418:} jerry_typedarray_mapping_t;
        -: 6419:
        -: 6420:/**
        -: 6421: * List of TypedArray mappings
        -: 6422: */
        -: 6423:static jerry_typedarray_mapping_t jerry_typedarray_mappings[] =
        -: 6424:{
        -: 6425:#define TYPEDARRAY_ENTRY(NAME, LIT_NAME, SIZE_SHIFT) \
        -: 6426:  { JERRY_TYPEDARRAY_ ## NAME, ECMA_BUILTIN_ID_ ## NAME ## ARRAY_PROTOTYPE, \
        -: 6427:    ECMA_ ## LIT_NAME ## _ARRAY, SIZE_SHIFT }
        -: 6428:
        -: 6429:  TYPEDARRAY_ENTRY (UINT8, UINT8, 0),
        -: 6430:  TYPEDARRAY_ENTRY (UINT8CLAMPED, UINT8_CLAMPED, 0),
        -: 6431:  TYPEDARRAY_ENTRY (INT8, INT8, 0),
        -: 6432:  TYPEDARRAY_ENTRY (UINT16, UINT16, 1),
        -: 6433:  TYPEDARRAY_ENTRY (INT16, INT16, 1),
        -: 6434:  TYPEDARRAY_ENTRY (UINT32, UINT32, 2),
        -: 6435:  TYPEDARRAY_ENTRY (INT32, INT32, 2),
        -: 6436:  TYPEDARRAY_ENTRY (FLOAT32, FLOAT32, 2),
        -: 6437:#if JERRY_NUMBER_TYPE_FLOAT64
        -: 6438:  TYPEDARRAY_ENTRY (FLOAT64, FLOAT64, 3),
        -: 6439:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -: 6440:#if JERRY_BUILTIN_BIGINT
        -: 6441:  TYPEDARRAY_ENTRY (BIGINT64, BIGINT64, 3),
        -: 6442:  TYPEDARRAY_ENTRY (BIGUINT64, BIGUINT64, 3),
        -: 6443:#endif /* JERRY_BUILTIN_BIGINT */
        -: 6444:#undef TYPEDARRAY_ENTRY
        -: 6445:};
        -: 6446:
        -: 6447:/**
        -: 6448: * Helper function to get the TypedArray prototype, typedArray id, and element size shift
        -: 6449: * information.
        -: 6450: *
        -: 6451: * @return true - if the TypedArray information was found
        -: 6452: *         false - if there is no such TypedArray type
        -: 6453: */
        -: 6454:static bool
    #####: 6455:jerry_typedarray_find_by_type (jerry_typedarray_type_t type_name, /**< type of the TypedArray */
        -: 6456:                               ecma_builtin_id_t *prototype_id, /**< [out] found prototype object id */
        -: 6457:                               ecma_typedarray_type_t *id, /**< [out] found typedArray id */
        -: 6458:                               uint8_t *element_size_shift) /**< [out] found element size shift value */
        -: 6459:{
    #####: 6460:  JERRY_ASSERT (prototype_id != NULL);
    #####: 6461:  JERRY_ASSERT (id != NULL);
    #####: 6462:  JERRY_ASSERT (element_size_shift != NULL);
        -: 6463:
    #####: 6464:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6465:  {
    #####: 6466:    if (type_name == jerry_typedarray_mappings[i].api_type)
        -: 6467:    {
    #####: 6468:      *prototype_id = jerry_typedarray_mappings[i].prototype_id;
    #####: 6469:      *id = jerry_typedarray_mappings[i].id;
    #####: 6470:      *element_size_shift = jerry_typedarray_mappings[i].element_size_shift;
    #####: 6471:      return true;
        -: 6472:    }
        -: 6473:  }
        -: 6474:
    #####: 6475:  return false;
        -: 6476:} /* jerry_typedarray_find_by_type */
        -: 6477:
        -: 6478:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6479:
        -: 6480:/**
        -: 6481: * Create a TypedArray object with a given type and length.
        -: 6482: *
        -: 6483: * Notes:
        -: 6484: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6485: *      * byteOffset property will be set to 0.
        -: 6486: *      * byteLength property will be a multiple of the length parameter (based on the type).
        -: 6487: *
        -: 6488: * @return - new TypedArray object
        -: 6489: */
        -: 6490:jerry_value_t
    #####: 6491:jerry_create_typedarray (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6492:                         jerry_length_t length) /**< element count of the new TypedArray */
        -: 6493:{
        -: 6494:  jerry_assert_api_available ();
        -: 6495:
        -: 6496:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6497:  ecma_builtin_id_t prototype_id = 0;
    #####: 6498:  ecma_typedarray_type_t id = 0;
    #####: 6499:  uint8_t element_size_shift = 0;
        -: 6500:
    #####: 6501:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 6502:  {
    #####: 6503:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Incorrect type for TypedArray")));
        -: 6504:  }
        -: 6505:
    #####: 6506:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
        -: 6507:
    #####: 6508:  ecma_value_t array_value = ecma_typedarray_create_object_with_length (length,
        -: 6509:                                                                        NULL,
        -: 6510:                                                                        prototype_obj_p,
        -: 6511:                                                                        element_size_shift,
        -: 6512:                                                                        id);
        -: 6513:
    #####: 6514:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (array_value));
        -: 6515:
    #####: 6516:  return array_value;
        -: 6517:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6518:  JERRY_UNUSED (type_name);
        -: 6519:  JERRY_UNUSED (length);
    #####: 6520:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6521:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6522:} /* jerry_create_typedarray */
        -: 6523:
        -: 6524:/**
        -: 6525: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6526: *
        -: 6527: * Notes:
        -: 6528: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6529: *      * this is the 'new %TypedArray%(arraybuffer, byteOffset, length)' equivalent call.
        -: 6530: *
        -: 6531: * @return - new TypedArray object
        -: 6532: */
        -: 6533:jerry_value_t
    #####: 6534:jerry_create_typedarray_for_arraybuffer_sz (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6535:                                            const jerry_value_t arraybuffer, /**< ArrayBuffer to use */
        -: 6536:                                            jerry_length_t byte_offset, /**< offset for the ArrayBuffer */
        -: 6537:                                            jerry_length_t length) /**< number of elements to use from ArrayBuffer */
        -: 6538:{
        -: 6539:  jerry_assert_api_available ();
        -: 6540:
        -: 6541:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6542:  if (ecma_is_value_error_reference (arraybuffer))
        -: 6543:  {
    #####: 6544:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6545:  }
        -: 6546:
    #####: 6547:  ecma_builtin_id_t prototype_id = 0;
    #####: 6548:  ecma_typedarray_type_t id = 0;
    #####: 6549:  uint8_t element_size_shift = 0;
        -: 6550:
    #####: 6551:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 6552:  {
    #####: 6553:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Incorrect type for TypedArray")));
        -: 6554:  }
        -: 6555:
    #####: 6556:  if (!ecma_is_arraybuffer (arraybuffer))
        -: 6557:  {
    #####: 6558:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Argument is not an ArrayBuffer")));
        -: 6559:  }
        -: 6560:
    #####: 6561:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
    #####: 6562:  ecma_value_t arguments_p[3] =
        -: 6563:  {
        -: 6564:    arraybuffer,
    #####: 6565:    ecma_make_uint32_value (byte_offset),
    #####: 6566:    ecma_make_uint32_value (length)
        -: 6567:  };
        -: 6568:
    #####: 6569:  ecma_value_t array_value = ecma_op_create_typedarray (arguments_p, 3, prototype_obj_p, element_size_shift, id);
    #####: 6570:  ecma_free_value (arguments_p[1]);
    #####: 6571:  ecma_free_value (arguments_p[2]);
        -: 6572:
    #####: 6573:  return jerry_return (array_value);
        -: 6574:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6575:  JERRY_UNUSED (type_name);
        -: 6576:  JERRY_UNUSED (arraybuffer);
        -: 6577:  JERRY_UNUSED (byte_offset);
        -: 6578:  JERRY_UNUSED (length);
    #####: 6579:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6580:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6581:} /* jerry_create_typedarray_for_arraybuffer_sz */
        -: 6582:
        -: 6583:/**
        -: 6584: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6585: *
        -: 6586: * Notes:
        -: 6587: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6588: *      * this is the 'new %TypedArray%(arraybuffer)' equivalent call.
        -: 6589: *
        -: 6590: * @return - new TypedArray object
        -: 6591: */
        -: 6592:jerry_value_t
    #####: 6593:jerry_create_typedarray_for_arraybuffer (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6594:                                         const jerry_value_t arraybuffer) /**< ArrayBuffer to use */
        -: 6595:{
        -: 6596:  jerry_assert_api_available ();
        -: 6597:
        -: 6598:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6599:  if (ecma_is_value_error_reference (arraybuffer))
        -: 6600:  {
    #####: 6601:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6602:  }
        -: 6603:
    #####: 6604:  jerry_length_t byteLength = jerry_get_arraybuffer_byte_length (arraybuffer);
    #####: 6605:  return jerry_create_typedarray_for_arraybuffer_sz (type_name, arraybuffer, 0, byteLength);
        -: 6606:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6607:  JERRY_UNUSED (type_name);
        -: 6608:  JERRY_UNUSED (arraybuffer);
    #####: 6609:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6610:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6611:} /* jerry_create_typedarray_for_arraybuffer */
        -: 6612:
        -: 6613:/**
        -: 6614: * Get the type of the TypedArray.
        -: 6615: *
        -: 6616: * @return - type of the TypedArray
        -: 6617: *         - JERRY_TYPEDARRAY_INVALID if the argument is not a TypedArray
        -: 6618: */
        -: 6619:jerry_typedarray_type_t
    #####: 6620:jerry_get_typedarray_type (jerry_value_t value) /**< object to get the TypedArray type */
        -: 6621:{
        -: 6622:  jerry_assert_api_available ();
        -: 6623:
        -: 6624:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6625:  if (!ecma_is_typedarray (value))
        -: 6626:  {
    #####: 6627:    return JERRY_TYPEDARRAY_INVALID;
        -: 6628:  }
        -: 6629:
    #####: 6630:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6631:  ecma_typedarray_type_t class_type = ecma_get_typedarray_id (array_p);
        -: 6632:
    #####: 6633:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6634:  {
    #####: 6635:    if (class_type == jerry_typedarray_mappings[i].id)
        -: 6636:    {
    #####: 6637:      return jerry_typedarray_mappings[i].api_type;
        -: 6638:    }
        -: 6639:  }
        -: 6640:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6641:  JERRY_UNUSED (value);
        -: 6642:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6643:
    #####: 6644:  return JERRY_TYPEDARRAY_INVALID;
        -: 6645:} /* jerry_get_typedarray_type */
        -: 6646:
        -: 6647:/**
        -: 6648: * Get the element count of the TypedArray.
        -: 6649: *
        -: 6650: * @return length of the TypedArray.
        -: 6651: */
        -: 6652:jerry_length_t
    #####: 6653:jerry_get_typedarray_length (jerry_value_t value) /**< TypedArray to query */
        -: 6654:{
        -: 6655:  jerry_assert_api_available ();
        -: 6656:
        -: 6657:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6658:  if (ecma_is_typedarray (value))
        -: 6659:  {
    #####: 6660:    ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6661:    return ecma_typedarray_get_length (array_p);
        -: 6662:  }
        -: 6663:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6664:  JERRY_UNUSED (value);
        -: 6665:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6666:
    #####: 6667:  return 0;
        -: 6668:} /* jerry_get_typedarray_length */
        -: 6669:
        -: 6670:/**
        -: 6671: * Get the underlying ArrayBuffer from a TypedArray.
        -: 6672: *
        -: 6673: * Additionally the byteLength and byteOffset properties are also returned
        -: 6674: * which were specified when the TypedArray was created.
        -: 6675: *
        -: 6676: * Note:
        -: 6677: *     the returned value must be freed with a jerry_release_value call
        -: 6678: *
        -: 6679: * @return ArrayBuffer of a TypedArray
        -: 6680: *         TypeError if the object is not a TypedArray.
        -: 6681: */
        -: 6682:jerry_value_t
    #####: 6683:jerry_get_typedarray_buffer (jerry_value_t value, /**< TypedArray to get the arraybuffer from */
        -: 6684:                             jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6685:                             jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6686:{
        -: 6687:  jerry_assert_api_available ();
        -: 6688:
        -: 6689:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6690:  if (!ecma_is_typedarray (value))
        -: 6691:  {
    #####: 6692:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Object is not a TypedArray")));
        -: 6693:  }
        -: 6694:
    #####: 6695:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6696:  uint8_t shift = ecma_typedarray_get_element_size_shift (array_p);
        -: 6697:
    #####: 6698:  if (byte_length != NULL)
        -: 6699:  {
    #####: 6700:    *byte_length = (jerry_length_t) (ecma_typedarray_get_length (array_p) << shift);
        -: 6701:  }
        -: 6702:
    #####: 6703:  if (byte_offset != NULL)
        -: 6704:  {
    #####: 6705:    *byte_offset = (jerry_length_t) ecma_typedarray_get_offset (array_p);
        -: 6706:  }
        -: 6707:
    #####: 6708:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (array_p);
    #####: 6709:  ecma_ref_object (arraybuffer_p);
    #####: 6710:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 6711:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6712:  JERRY_UNUSED (value);
        -: 6713:  JERRY_UNUSED (byte_length);
        -: 6714:  JERRY_UNUSED (byte_offset);
    #####: 6715:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_typed_array_not_supported_p)));
        -: 6716:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6717:} /* jerry_get_typedarray_buffer */
        -: 6718:
        -: 6719:/**
        -: 6720: * Parse the given JSON string to create a jerry_value_t.
        -: 6721: *
        -: 6722: * The behaviour is equivalent with the "JSON.parse(string)" JS call.
        -: 6723: *
        -: 6724: * Note:
        -: 6725: *      The returned value must be freed with jerry_release_value.
        -: 6726: *
        -: 6727: * @return - jerry_value_t containing a JavaScript value.
        -: 6728: *         - Error value if there was problems during the parse.
        -: 6729: */
        -: 6730:jerry_value_t
    #####: 6731:jerry_json_parse (const jerry_char_t *string_p, /**< json string */
        -: 6732:                  jerry_size_t string_size) /**< json string size */
        -: 6733:{
        -: 6734:  jerry_assert_api_available ();
        -: 6735:
        -: 6736:#if JERRY_BUILTIN_JSON
    #####: 6737:  ecma_value_t ret_value = ecma_builtin_json_parse_buffer (string_p, string_size);
        -: 6738:
    #####: 6739:  if (ecma_is_value_undefined (ret_value))
        -: 6740:  {
    #####: 6741:    ret_value = jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("JSON string parse error")));
        -: 6742:  }
        -: 6743:
    #####: 6744:  return jerry_return (ret_value);
        -: 6745:#else /* !JERRY_BUILTIN_JSON */
        -: 6746:  JERRY_UNUSED (string_p);
        -: 6747:  JERRY_UNUSED (string_size);
        -: 6748:
        -: 6749:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_json_not_supported_p)));
        -: 6750:#endif /* JERRY_BUILTIN_JSON */
        -: 6751:} /* jerry_json_parse */
        -: 6752:
        -: 6753:/**
        -: 6754: * Create a JSON string from a JavaScript value.
        -: 6755: *
        -: 6756: * The behaviour is equivalent with the "JSON.stringify(input_value)" JS call.
        -: 6757: *
        -: 6758: * Note:
        -: 6759: *      The returned value must be freed with jerry_release_value,
        -: 6760: *
        -: 6761: * @return - jerry_value_t containing a JSON string.
        -: 6762: *         - Error value if there was a problem during the stringification.
        -: 6763: */
        -: 6764:jerry_value_t
    #####: 6765:jerry_json_stringify (const jerry_value_t input_value) /**< a value to stringify */
        -: 6766:{
        -: 6767:  jerry_assert_api_available ();
        -: 6768:#if JERRY_BUILTIN_JSON
    #####: 6769:  if (ecma_is_value_error_reference (input_value))
        -: 6770:  {
    #####: 6771:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6772:  }
        -: 6773:
    #####: 6774:  ecma_value_t ret_value = ecma_builtin_json_stringify_no_opts (input_value);
        -: 6775:
    #####: 6776:  if (ecma_is_value_undefined (ret_value))
        -: 6777:  {
    #####: 6778:    ret_value = jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG ("JSON stringify error")));
        -: 6779:  }
        -: 6780:
    #####: 6781:  return jerry_return (ret_value);
        -: 6782:#else /* JERRY_BUILTIN_JSON */
        -: 6783:  JERRY_UNUSED (input_value);
        -: 6784:
        -: 6785:  return jerry_throw (ecma_raise_syntax_error (ECMA_ERR_MSG (ecma_error_json_not_supported_p)));
        -: 6786:#endif /* JERRY_BUILTIN_JSON */
        -: 6787:} /* jerry_json_stringify */
        -: 6788:
        -: 6789:/**
        -: 6790: * Create a container type specified in jerry_container_type_t.
        -: 6791: * The container can be created with a list of arguments, which will be passed to the container constructor to be
        -: 6792: * inserted to the container.
        -: 6793: *
        -: 6794: * Note:
        -: 6795: *      The returned value must be freed with jerry_release_value
        -: 6796: * @return jerry_value_t representing a container with the given type.
        -: 6797: */
        -: 6798:jerry_value_t
    #####: 6799:jerry_create_container (jerry_container_type_t container_type, /**< Type of the container */
        -: 6800:                        const jerry_value_t *arguments_list_p, /**< arguments list */
        -: 6801:                        jerry_length_t arguments_list_len) /**< Length of arguments list */
        -: 6802:{
        -: 6803:  jerry_assert_api_available ();
        -: 6804:
        -: 6805:#if JERRY_BUILTIN_CONTAINER
    #####: 6806:  for (jerry_length_t i = 0; i < arguments_list_len; i++)
        -: 6807:  {
    #####: 6808:    if (ecma_is_value_error_reference (arguments_list_p[i]))
        -: 6809:    {
    #####: 6810:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_value_msg_p)));
        -: 6811:    }
        -: 6812:  }
        -: 6813:
        -: 6814:  lit_magic_string_id_t lit_id;
        -: 6815:  ecma_builtin_id_t proto_id;
        -: 6816:  ecma_builtin_id_t ctor_id;
        -: 6817:
    #####: 6818:  switch (container_type)
        -: 6819:  {
    #####: 6820:    case JERRY_CONTAINER_TYPE_MAP:
        -: 6821:    {
    #####: 6822:      lit_id = LIT_MAGIC_STRING_MAP_UL;
    #####: 6823:      proto_id = ECMA_BUILTIN_ID_MAP_PROTOTYPE;
    #####: 6824:      ctor_id = ECMA_BUILTIN_ID_MAP;
    #####: 6825:      break;
        -: 6826:    }
    #####: 6827:    case JERRY_CONTAINER_TYPE_SET:
        -: 6828:    {
    #####: 6829:      lit_id = LIT_MAGIC_STRING_SET_UL;
    #####: 6830:      proto_id = ECMA_BUILTIN_ID_SET_PROTOTYPE;
    #####: 6831:      ctor_id = ECMA_BUILTIN_ID_SET;
    #####: 6832:      break;
        -: 6833:    }
    #####: 6834:    case JERRY_CONTAINER_TYPE_WEAKMAP:
        -: 6835:    {
    #####: 6836:      lit_id = LIT_MAGIC_STRING_WEAKMAP_UL;
    #####: 6837:      proto_id = ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE;
    #####: 6838:      ctor_id = ECMA_BUILTIN_ID_WEAKMAP;
    #####: 6839:      break;
        -: 6840:    }
    #####: 6841:    case JERRY_CONTAINER_TYPE_WEAKSET:
        -: 6842:    {
    #####: 6843:      lit_id = LIT_MAGIC_STRING_WEAKSET_UL;
    #####: 6844:      proto_id = ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE;
    #####: 6845:      ctor_id = ECMA_BUILTIN_ID_WEAKSET;
    #####: 6846:      break;
        -: 6847:    }
    #####: 6848:    default:
        -: 6849:    {
    #####: 6850:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Invalid container type")));
        -: 6851:    }
        -: 6852:  }
    #####: 6853:  ecma_object_t * old_new_target_p = JERRY_CONTEXT (current_new_target_p);
        -: 6854:
    #####: 6855:  if (old_new_target_p == NULL)
        -: 6856:  {
    #####: 6857:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ctor_id);
        -: 6858:  }
        -: 6859:
    #####: 6860:  ecma_value_t container_value = ecma_op_container_create (arguments_list_p,
        -: 6861:                                                           arguments_list_len,
        -: 6862:                                                           lit_id,
        -: 6863:                                                           proto_id);
        -: 6864:
    #####: 6865:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6866:  return container_value;
        -: 6867:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6868:  JERRY_UNUSED (arguments_list_p);
        -: 6869:  JERRY_UNUSED (arguments_list_len);
        -: 6870:  JERRY_UNUSED (container_type);
    #####: 6871:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 6872:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 6873:} /* jerry_create_container */
        -: 6874:
        -: 6875:/**
        -: 6876: * Get the type of the given container object.
        -: 6877: *
        -: 6878: * @return Corresponding type to the given container object.
        -: 6879: */
        -: 6880:jerry_container_type_t
    #####: 6881:jerry_get_container_type (const jerry_value_t value) /**< the container object */
        -: 6882:{
        -: 6883:  jerry_assert_api_available ();
        -: 6884:
        -: 6885:#if JERRY_BUILTIN_CONTAINER
    #####: 6886:  if (ecma_is_value_object (value))
        -: 6887:  {
    #####: 6888:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 6889:
    #####: 6890:    if (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_CONTAINER))
        -: 6891:    {
    #####: 6892:      switch (((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id)
        -: 6893:      {
    #####: 6894:        case LIT_MAGIC_STRING_MAP_UL:
        -: 6895:        {
    #####: 6896:          return JERRY_CONTAINER_TYPE_MAP;
        -: 6897:        }
    #####: 6898:        case LIT_MAGIC_STRING_SET_UL:
        -: 6899:        {
    #####: 6900:          return JERRY_CONTAINER_TYPE_SET;
        -: 6901:        }
    #####: 6902:        case LIT_MAGIC_STRING_WEAKMAP_UL:
        -: 6903:        {
    #####: 6904:          return JERRY_CONTAINER_TYPE_WEAKMAP;
        -: 6905:        }
    #####: 6906:        case LIT_MAGIC_STRING_WEAKSET_UL:
        -: 6907:        {
    #####: 6908:          return JERRY_CONTAINER_TYPE_WEAKSET;
        -: 6909:        }
    #####: 6910:        default:
        -: 6911:        {
    #####: 6912:          return JERRY_CONTAINER_TYPE_INVALID;
        -: 6913:        }
        -: 6914:      }
        -: 6915:    }
        -: 6916:  }
        -: 6917:
        -: 6918:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6919:  JERRY_UNUSED (value);
        -: 6920:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 6921:  return JERRY_CONTAINER_TYPE_INVALID;
        -: 6922:} /* jerry_get_container_type */
        -: 6923:
        -: 6924:/**
        -: 6925: * Return a new array containing elements from a Container or a Container Iterator.
        -: 6926: * Sets the boolean input value to `true` if the container object has key/value pairs.
        -: 6927: *
        -: 6928: * Note:
        -: 6929: *     the returned value must be freed with a jerry_release_value call
        -: 6930: *
        -: 6931: * @return an array of items for maps/sets or their iterators, error otherwise
        -: 6932: */
        -: 6933:jerry_value_t
    #####: 6934:jerry_get_array_from_container (jerry_value_t value, /**< the container or iterator object */
        -: 6935:                                bool *is_key_value_p) /**< [out] is key-value structure */
        -: 6936:{
        -: 6937:  jerry_assert_api_available ();
        -: 6938:
        -: 6939:#if JERRY_BUILTIN_CONTAINER
    #####: 6940:  const char *container_needed = ECMA_ERR_MSG ("Value is not a Container or Iterator");
        -: 6941:
    #####: 6942:  if (!ecma_is_value_object (value))
        -: 6943:  {
    #####: 6944:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 6945:  }
        -: 6946:
    #####: 6947:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 6948:
    #####: 6949:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 6950:  {
    #####: 6951:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 6952:  }
        -: 6953:
    #####: 6954:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 6955:
        -: 6956:  uint32_t entry_count;
        -: 6957:  uint8_t entry_size;
        -: 6958:
    #####: 6959:  uint32_t index = 0;
    #####: 6960:  uint8_t iterator_kind = ECMA_ITERATOR__COUNT;
        -: 6961:  ecma_value_t *start_p;
        -: 6962:
    #####: 6963:  *is_key_value_p = false;
        -: 6964:
    #####: 6965:  if (ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_MAP_ITERATOR
    #####: 6966:      || ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_SET_ITERATOR)
    #####: 6967:  {
    #####: 6968:    ecma_value_t iterated_value = ext_obj_p->u.cls.u3.iterated_value;
        -: 6969:
    #####: 6970:    if (ecma_is_value_empty (iterated_value))
        -: 6971:    {
    #####: 6972:      return ecma_op_new_array_object_from_collection (ecma_new_collection (), false);
        -: 6973:    }
        -: 6974:
    #####: 6975:    ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));
        -: 6976:
    #####: 6977:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
    #####: 6978:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 6979:    index = ext_obj_p->u.cls.u2.iterator_index;
        -: 6980:
    #####: 6981:    entry_size = ecma_op_container_entry_size (map_object_p->u.cls.u2.container_id);
    #####: 6982:    start_p = ECMA_CONTAINER_START (container_p);
        -: 6983:
    #####: 6984:    iterator_kind = ext_obj_p->u.cls.u1.iterator_kind;
        -: 6985:  }
    #####: 6986:  else if (jerry_get_container_type (value) != JERRY_CONTAINER_TYPE_INVALID)
        -: 6987:  {
    #####: 6988:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, ext_obj_p->u.cls.u3.value);
    #####: 6989:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 6990:    entry_size = ecma_op_container_entry_size (ext_obj_p->u.cls.u2.container_id);
        -: 6991:
    #####: 6992:    index = 0;
    #####: 6993:    iterator_kind = ECMA_ITERATOR_KEYS;
    #####: 6994:    start_p = ECMA_CONTAINER_START (container_p);
        -: 6995:
    #####: 6996:    if (ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_MAP_UL
    #####: 6997:        || ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 6998:    {
    #####: 6999:      iterator_kind = ECMA_ITERATOR_ENTRIES;
        -: 7000:    }
        -: 7001:  }
        -: 7002:  else
        -: 7003:  {
    #####: 7004:    return jerry_throw (ecma_raise_type_error (container_needed));
        -: 7005:  }
        -: 7006:
    #####: 7007:  *is_key_value_p = (iterator_kind == ECMA_ITERATOR_ENTRIES);
    #####: 7008:  ecma_collection_t *collection_buffer = ecma_new_collection ();
        -: 7009:
    #####: 7010:  for (uint32_t i = index; i < entry_count; i += entry_size)
        -: 7011:  {
    #####: 7012:    ecma_value_t *entry_p = start_p + i;
        -: 7013:
    #####: 7014:    if (ecma_is_value_empty (*entry_p))
        -: 7015:    {
    #####: 7016:      continue;
        -: 7017:    }
        -: 7018:
    #####: 7019:    if (iterator_kind != ECMA_ITERATOR_VALUES)
        -: 7020:    {
    #####: 7021:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[0]));
        -: 7022:    }
        -: 7023:
    #####: 7024:    if (iterator_kind != ECMA_ITERATOR_KEYS)
        -: 7025:    {
    #####: 7026:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[1]));
        -: 7027:    }
        -: 7028:  }
    #####: 7029:  return ecma_op_new_array_object_from_collection (collection_buffer, false);
        -: 7030:#else /* JERRY_BUILTIN_CONTAINER */
        -: 7031:  JERRY_UNUSED (value);
        -: 7032:  JERRY_UNUSED (is_key_value_p);
    #####: 7033:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 7034:#endif
        -: 7035:} /* jerry_get_array_from_container */
        -: 7036:
        -: 7037:/**
        -: 7038: * Perform container operation on the given operands (add, get, set, has, delete, size, clear).
        -: 7039: *
        -: 7040: * @return error - if argument is invalid or operation is unsuccessful or unsupported
        -: 7041: *                 result of the container operation - otherwise.
        -: 7042: */
        -: 7043:jerry_value_t
    #####: 7044:jerry_container_operation (jerry_container_operation_t operation, /**< container operation */
        -: 7045:                           jerry_value_t container, /**< container */
        -: 7046:                           jerry_value_t *arguments, /**< list of arguments */
        -: 7047:                           uint32_t arguments_number) /**< number of arguments */
        -: 7048:{
        -: 7049:  jerry_assert_api_available ();
        -: 7050:#if JERRY_BUILTIN_CONTAINER
    #####: 7051:  if (!ecma_is_value_object (container))
        -: 7052:  {
    #####: 7053:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Container is not an object.")));
        -: 7054:  }
        -: 7055:
    #####: 7056:  ecma_object_t *obj_p = ecma_get_object_from_value (container);
        -: 7057:
    #####: 7058:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 7059:  {
    #####: 7060:    return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Container is not a container object.")));
        -: 7061:  }
    #####: 7062:  uint16_t type = ((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id;
    #####: 7063:  ecma_extended_object_t *container_object_p = ecma_op_container_get_object (container, type);
        -: 7064:
    #####: 7065:  if (container_object_p == NULL)
        -: 7066:  {
    #####: 7067:    return ecma_create_error_reference_from_context ();
        -: 7068:  }
        -: 7069:
    #####: 7070:  switch (operation)
        -: 7071:  {
    #####: 7072:    case JERRY_CONTAINER_OP_ADD:
        -: 7073:    case JERRY_CONTAINER_OP_DELETE:
        -: 7074:    case JERRY_CONTAINER_OP_GET:
        -: 7075:    case JERRY_CONTAINER_OP_HAS:
        -: 7076:    {
    #####: 7077:      if (arguments_number != 1 || ecma_is_value_error_reference (arguments[0]))
        -: 7078:      {
    #####: 7079:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7080:      }
    #####: 7081:      break;
        -: 7082:    }
    #####: 7083:    case JERRY_CONTAINER_OP_SET:
        -: 7084:    {
    #####: 7085:      if (arguments_number != 2
    #####: 7086:          || ecma_is_value_error_reference (arguments[0])
    #####: 7087:          || ecma_is_value_error_reference (arguments[1]))
        -: 7088:      {
    #####: 7089:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7090:      }
    #####: 7091:      break;
        -: 7092:    }
    #####: 7093:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7094:    case JERRY_CONTAINER_OP_SIZE:
        -: 7095:    {
    #####: 7096:      if (arguments_number != 0)
        -: 7097:      {
    #####: 7098:        return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7099:      }
    #####: 7100:      break;
        -: 7101:    }
    #####: 7102:    default:
        -: 7103:    {
    #####: 7104:      return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_wrong_args_msg_p)));
        -: 7105:    }
        -: 7106:  }
        -: 7107:
        -: 7108:  jerry_value_t result;
    #####: 7109:  const char *incorrect_type_call = ECMA_ERR_MSG ("Operator called on incorrect container type");
        -: 7110:
    #####: 7111:  switch (operation)
        -: 7112:  {
    #####: 7113:    case JERRY_CONTAINER_OP_ADD:
        -: 7114:    {
    #####: 7115:      if (type == LIT_MAGIC_STRING_MAP_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7116:      {
    #####: 7117:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7118:      }
    #####: 7119:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[0], type);
    #####: 7120:      break;
        -: 7121:    }
    #####: 7122:    case JERRY_CONTAINER_OP_GET:
        -: 7123:    {
    #####: 7124:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7125:      {
    #####: 7126:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7127:      }
    #####: 7128:      result = ecma_op_container_get (container_object_p, arguments[0], type);
    #####: 7129:      break;
        -: 7130:    }
    #####: 7131:    case JERRY_CONTAINER_OP_SET:
        -: 7132:    {
    #####: 7133:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7134:      {
    #####: 7135:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7136:      }
    #####: 7137:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[1], type);
    #####: 7138:      break;
        -: 7139:    }
    #####: 7140:    case JERRY_CONTAINER_OP_HAS:
        -: 7141:    {
    #####: 7142:      result = ecma_op_container_has (container_object_p, arguments[0], type);
    #####: 7143:      break;
        -: 7144:    }
    #####: 7145:    case JERRY_CONTAINER_OP_DELETE:
        -: 7146:    {
    #####: 7147:      if (type == LIT_MAGIC_STRING_WEAKMAP_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7148:      {
    #####: 7149:        result = ecma_op_container_delete_weak (container_object_p, arguments[0], type);
    #####: 7150:        break;
        -: 7151:      }
    #####: 7152:      result = ecma_op_container_delete (container_object_p, arguments[0], type);
    #####: 7153:      break;
        -: 7154:    }
    #####: 7155:    case JERRY_CONTAINER_OP_SIZE:
        -: 7156:    {
    #####: 7157:      result = ecma_op_container_size (container_object_p);
    #####: 7158:      break;
        -: 7159:    }
    #####: 7160:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7161:    {
    #####: 7162:      if (type == LIT_MAGIC_STRING_WEAKSET_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7163:      {
    #####: 7164:        return jerry_throw (ecma_raise_type_error (incorrect_type_call));
        -: 7165:      }
    #####: 7166:      result = ecma_op_container_clear (container_object_p);
    #####: 7167:      break;
        -: 7168:    }
    #####: 7169:    default:
        -: 7170:    {
    #####: 7171:      result = jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG ("Unsupported container operation")));
    #####: 7172:      break;
        -: 7173:    }
        -: 7174:  }
    #####: 7175:  return jerry_return (result);
        -: 7176:#else /* JERRY_BUILTIN_CONTAINER */
        -: 7177:  JERRY_UNUSED (operation);
        -: 7178:  JERRY_UNUSED (container);
        -: 7179:  JERRY_UNUSED (arguments);
        -: 7180:  JERRY_UNUSED (arguments_number);
    #####: 7181:  return jerry_throw (ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_container_not_supported_p)));
        -: 7182:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 7183:} /* jerry_container_operation */
        -: 7184:
        -: 7185:/**
        -: 7186: * @}
        -: 7187: */
