        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-reference.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-exceptions.h"
        -:   17:#include "ecma-function-object.h"
        -:   18:#include "ecma-gc.h"
        -:   19:#include "ecma-globals.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:#include "ecma-lcache.h"
        -:   22:#include "ecma-lex-env.h"
        -:   23:#include "ecma-objects.h"
        -:   24:#include "ecma-proxy-object.h"
        -:   25:#include "ecma-reference.h"
        -:   26:#include "jrt.h"
        -:   27:
        -:   28:/** \addtogroup ecma ECMA
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup references ECMA-Reference
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:/**
        -:   36: * Resolve syntactic reference.
        -:   37: *
        -:   38: * @return ECMA_OBJECT_POINTER_ERROR - if the operation fails
        -:   39: *         pointer to lexical environment - if the reference's base is resolved sucessfully,
        -:   40: *         NULL - otherwise.
        -:   41: */
        -:   42:ecma_object_t *
    #####:   43:ecma_op_resolve_reference_base (ecma_object_t *lex_env_p, /**< starting lexical environment */
        -:   44:                                ecma_string_t *name_p) /**< identifier's name */
        -:   45:{
    #####:   46:  JERRY_ASSERT (lex_env_p != NULL);
        -:   47:
        -:   48:  while (true)
    #####:   49:  {
    #####:   50:    ecma_value_t has_binding = ecma_op_has_binding (lex_env_p, name_p);
        -:   51:
        -:   52:#if JERRY_BUILTIN_PROXY
    #####:   53:    if (ECMA_IS_VALUE_ERROR (has_binding))
        -:   54:    {
    #####:   55:      return ECMA_OBJECT_POINTER_ERROR;
        -:   56:    }
        -:   57:#endif /* JERRY_BUILTIN_PROXY */
        -:   58:
    #####:   59:    if (ecma_is_value_true (has_binding))
        -:   60:    {
    #####:   61:      return lex_env_p;
        -:   62:    }
        -:   63:
    #####:   64:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -:   65:    {
    #####:   66:      return NULL;
        -:   67:    }
        -:   68:
    #####:   69:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:   70:  }
        -:   71:} /* ecma_op_resolve_reference_base */
        -:   72:
        -:   73:#if JERRY_ESNEXT
        -:   74:
        -:   75:/**
        -:   76: * Check if the passed lexical environment is a global lexical environment
        -:   77: *
        -:   78: * @return true  - if the lexical environment is a global lexical environment
        -:   79: *         false - otherwise
        -:   80: */
        -:   81:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:   82:ecma_op_is_global_environment (ecma_object_t *lex_env_p) /**< lexical environment */
        -:   83:{
      403:   84:  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:   85:#if JERRY_BUILTIN_REALMS
      403:   86:  JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL
        -:   87:                || (ecma_make_object_value (ecma_get_lex_env_binding_object (lex_env_p))
        -:   88:                    == ((ecma_global_object_t *) ecma_builtin_get_global ())->this_binding));
        -:   89:#else /* !JERRY_BUILTIN_REALMS */
        -:   90:  JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL
        -:   91:                || ecma_get_lex_env_binding_object (lex_env_p) == ecma_builtin_get_global ());
        -:   92:#endif /* JERRY_BUILTIN_REALMS */
        -:   93:
      403:   94:  return lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL;
        -:   95:} /* ecma_op_is_global_environment */
        -:   96:
        -:   97:/**
        -:   98: * Perform GetThisEnvironment and GetSuperBase operations
        -:   99: *
        -:  100: * See also: ECMAScript v6, 8.1.1.3.5
        -:  101: *
        -:  102: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  103: *         ECMA_VALUE_UNDEFINED - if the home object is null
        -:  104: *         value of the [[HomeObject]].[[Prototype]] internal slot - otherwise
        -:  105: */
        -:  106:ecma_value_t
    #####:  107:ecma_op_resolve_super_base (ecma_object_t *lex_env_p) /**< starting lexical environment */
        -:  108:{
        -:  109:  while (true)
        -:  110:  {
    #####:  111:    JERRY_ASSERT (lex_env_p != NULL);
        -:  112:
    #####:  113:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
    #####:  114:        && (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) == 0)
        -:  115:    {
    #####:  116:      ecma_object_t *home_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u1.home_object_cp);
        -:  117:
        -:  118:#if JERRY_BUILTIN_PROXY
    #####:  119:      if (ECMA_OBJECT_IS_PROXY (home_p))
        -:  120:      {
    #####:  121:        return ecma_proxy_object_get_prototype_of (home_p);
        -:  122:      }
        -:  123:#endif /* JERRY_BUILTIN_PROXY */
        -:  124:
    #####:  125:      jmem_cpointer_t proto_cp = ecma_op_ordinary_object_get_prototype_of (home_p);
        -:  126:
    #####:  127:      if (proto_cp == JMEM_CP_NULL)
        -:  128:      {
    #####:  129:        return ECMA_VALUE_NULL;
        -:  130:      }
        -:  131:
    #####:  132:      ecma_object_t *proto_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp);
    #####:  133:      ecma_ref_object (proto_p);
        -:  134:
    #####:  135:      return ecma_make_object_value (proto_p);
        -:  136:    }
        -:  137:
    #####:  138:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -:  139:    {
    #####:  140:      break;
        -:  141:    }
        -:  142:
    #####:  143:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  144:  }
        -:  145:
    #####:  146:  return ECMA_VALUE_UNDEFINED;
        -:  147:} /* ecma_op_resolve_super_base */
        -:  148:
        -:  149:/**
        -:  150: * Helper method for HasBindig operation
        -:  151: *
        -:  152: * See also:
        -:  153: *         ECMA-262 v6, 8.1.1.2.1 steps 7-9;
        -:  154: *
        -:  155: * @return ECMA_VALUE_TRUE - if the property is unscopable
        -:  156: *         ECMA_VALUE_FALSE - if a the property is not unscopable
        -:  157: *         ECMA_VALUE_ERROR - otherwise
        -:  158: */
        -:  159:static ecma_value_t
    #####:  160:ecma_op_is_prop_unscopable (ecma_object_t *binding_obj_p, /**< binding object */
        -:  161:                            ecma_string_t *prop_name_p) /**< property's name */
        -:  162:{
    #####:  163:  ecma_value_t unscopables = ecma_op_object_get_by_symbol_id (binding_obj_p, LIT_GLOBAL_SYMBOL_UNSCOPABLES);
        -:  164:
    #####:  165:  if (ECMA_IS_VALUE_ERROR (unscopables))
        -:  166:  {
    #####:  167:    return unscopables;
        -:  168:  }
        -:  169:
    #####:  170:  if (ecma_is_value_object (unscopables))
        -:  171:  {
    #####:  172:    ecma_object_t *unscopables_obj_p = ecma_get_object_from_value (unscopables);
    #####:  173:    ecma_value_t get_unscopables_value = ecma_op_object_get (unscopables_obj_p, prop_name_p);
    #####:  174:    ecma_deref_object (unscopables_obj_p);
        -:  175:
    #####:  176:    if (ECMA_IS_VALUE_ERROR (get_unscopables_value))
        -:  177:    {
    #####:  178:      return get_unscopables_value;
        -:  179:    }
        -:  180:
    #####:  181:    bool is_blocked = ecma_op_to_boolean (get_unscopables_value);
        -:  182:
    #####:  183:    ecma_free_value (get_unscopables_value);
        -:  184:
    #####:  185:    return ecma_make_boolean_value (is_blocked);
        -:  186:  }
        -:  187:
    #####:  188:  ecma_free_value (unscopables);
        -:  189:
    #####:  190:  return ECMA_VALUE_FALSE;
        -:  191:} /* ecma_op_is_prop_unscopable */
        -:  192:
        -:  193:#endif /* JERRY_ESNEXT */
        -:  194:
        -:  195:/**
        -:  196: * Helper method for HasBindig operation
        -:  197: *
        -:  198: * See also:
        -:  199: *         ECMA-262 v6, 8.1.1.2.1 steps 7-9;
        -:  200: *
        -:  201: * @return ECMA_VALUE_TRUE - if the property is unscopable
        -:  202: *         ECMA_VALUE_FALSE - if a the property is not unscopable
        -:  203: *         ECMA_VALUE_ERROR - otherwise
        -:  204: */
        -:  205:
        -:  206:/**
        -:  207: * Resolve value corresponding to the given object environment reference.
        -:  208: *
        -:  209: * Note: the steps are already include the HasBindig operation steps
        -:  210: *
        -:  211: *  See also:
        -:  212: *         ECMA-262 v6, 8.1.1.2.1
        -:  213: *
        -:  214: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  215: *         ECMA_VALUE_NOT_FOUND - if the binding not exists or blocked via @@unscopables
        -:  216: *         result of the binding - otherwise
        -:  217: */
        -:  218:ecma_value_t
    #####:  219:ecma_op_object_bound_environment_resolve_reference_value (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  220:                                                          ecma_string_t *name_p) /**< variable name */
        -:  221:{
    #####:  222:  ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  223:  ecma_value_t found_binding;
        -:  224:
        -:  225:#if JERRY_BUILTIN_PROXY
    #####:  226:  if (ECMA_OBJECT_IS_PROXY (binding_obj_p))
        -:  227:  {
    #####:  228:    found_binding = ecma_proxy_object_has (binding_obj_p, name_p);
        -:  229:
    #####:  230:    if (!ecma_is_value_true (found_binding))
        -:  231:    {
    #####:  232:      return ECMA_IS_VALUE_ERROR (found_binding) ? found_binding : ECMA_VALUE_NOT_FOUND;
        -:  233:    }
        -:  234:  }
        -:  235:  else
        -:  236:  {
        -:  237:#endif /* JERRY_BUILTIN_PROXY */
    #####:  238:    found_binding = ecma_op_object_find (binding_obj_p, name_p);
        -:  239:
    #####:  240:    if (ECMA_IS_VALUE_ERROR (found_binding) || !ecma_is_value_found (found_binding))
        -:  241:    {
    #####:  242:      return found_binding;
        -:  243:    }
        -:  244:
        -:  245:#if JERRY_ESNEXT
    #####:  246:    if (JERRY_LIKELY (ecma_op_is_global_environment (lex_env_p)))
        -:  247:#endif /* JERRY_ESNEXT */
        -:  248:    {
    #####:  249:      return found_binding;
        -:  250:    }
        -:  251:#if JERRY_BUILTIN_PROXY
        -:  252:  }
        -:  253:#endif /* JERRY_BUILTIN_PROXY */
        -:  254:
        -:  255:#if JERRY_ESNEXT
    #####:  256:  ecma_value_t blocked = ecma_op_is_prop_unscopable (binding_obj_p, name_p);
        -:  257:
    #####:  258:  if (ecma_is_value_false (blocked))
        -:  259:  {
        -:  260:#if JERRY_BUILTIN_PROXY
    #####:  261:    if (ECMA_OBJECT_IS_PROXY (binding_obj_p))
        -:  262:    {
    #####:  263:      return ecma_proxy_object_get (binding_obj_p, name_p, ecma_make_object_value (binding_obj_p));
        -:  264:    }
        -:  265:#endif /* JERRY_BUILTIN_PROXY */
    #####:  266:    return found_binding;
        -:  267:  }
        -:  268:
        -:  269:#if JERRY_BUILTIN_PROXY
    #####:  270:  if (!ECMA_OBJECT_IS_PROXY (binding_obj_p))
        -:  271:  {
    #####:  272:    ecma_free_value (found_binding);
        -:  273:  }
        -:  274:#endif /* JERRY_BUILTIN_PROXY */
        -:  275:
    #####:  276:  return ECMA_IS_VALUE_ERROR (blocked) ? blocked : ECMA_VALUE_NOT_FOUND;
        -:  277:#endif /* JERRY_ESNEXT */
        -:  278:} /* ecma_op_object_bound_environment_resolve_reference_value */
        -:  279:
        -:  280:/**
        -:  281: * Resolve value corresponding to reference.
        -:  282: *
        -:  283: * @return value of the reference
        -:  284: */
        -:  285:ecma_value_t
      403:  286:ecma_op_resolve_reference_value (ecma_object_t *lex_env_p, /**< starting lexical environment */
        -:  287:                                 ecma_string_t *name_p) /**< identifier's name */
        -:  288:{
      403:  289:  JERRY_ASSERT (lex_env_p != NULL);
        -:  290:
        -:  291:  while (true)
        -:  292:  {
      403:  293:    switch (ecma_get_lex_env_type (lex_env_p))
        -:  294:    {
    #####:  295:      case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:
        -:  296:      {
    #####:  297:        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  298:
    #####:  299:        if (property_p == NULL)
        -:  300:        {
    #####:  301:          break;
        -:  302:        }
        -:  303:
    #####:  304:        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  305:
        -:  306:#if JERRY_ESNEXT
    #####:  307:        if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))
        -:  308:        {
    #####:  309:          return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -:  310:        }
        -:  311:#endif /* JERRY_ESNEXT */
        -:  312:
    #####:  313:        return ecma_fast_copy_value (property_value_p->value);
        -:  314:      }
        -:  315:#if JERRY_ESNEXT
    #####:  316:      case ECMA_LEXICAL_ENVIRONMENT_CLASS:
        -:  317:      {
        -:  318:#if JERRY_MODULE_SYSTEM
    #####:  319:        if (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)
        -:  320:        {
    #####:  321:          ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  322:
    #####:  323:          if (property_p == NULL)
        -:  324:          {
    #####:  325:            break;
        -:  326:          }
        -:  327:
    #####:  328:          ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  329:
    #####:  330:          if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:  331:          {
    #####:  332:            property_value_p = ecma_get_property_value_from_named_reference (property_value_p);
        -:  333:          }
        -:  334:
    #####:  335:          if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))
        -:  336:          {
    #####:  337:            return ecma_raise_reference_error (ECMA_ERR_MSG (ecma_error_let_const_not_initialized));
        -:  338:          }
        -:  339:
    #####:  340:          return ecma_fast_copy_value (property_value_p->value);
        -:  341:        }
        -:  342:#endif /* JERRY_MODULE_SYSTEM */
    #####:  343:        break;
        -:  344:      }
        -:  345:#endif /* JERRY_ESNEXT */
      403:  346:      default:
        -:  347:      {
      403:  348:        JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  349:#if JERRY_ESNEXT
      403:  350:        bool lcache_lookup_allowed = ecma_op_is_global_environment (lex_env_p);
        -:  351:#else /* !JERRY_ESNEXT*/
    #####:  352:        bool lcache_lookup_allowed = true;
        -:  353:#endif /* JERRY_ESNEXT */
        -:  354:
      403:  355:        if (lcache_lookup_allowed)
        -:  356:        {
        -:  357:#if JERRY_LCACHE
      403:  358:          ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
      403:  359:          ecma_property_t *property_p = ecma_lcache_lookup (binding_obj_p, name_p);
        -:  360:
      403:  361:          if (property_p != NULL)
        -:  362:          {
      403:  363:            JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  364:
      403:  365:            ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  366:
      403:  367:            if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  368:            {
      403:  369:              return ecma_fast_copy_value (prop_value_p->value);
        -:  370:            }
        -:  371:
    #####:  372:            ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (prop_value_p);
        -:  373:
    #####:  374:            if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -:  375:            {
    #####:  376:              return ECMA_VALUE_UNDEFINED;
        -:  377:            }
        -:  378:
    #####:  379:            ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
        -:  380:
    #####:  381:            ecma_value_t base_value = ecma_make_object_value (binding_obj_p);
    #####:  382:            return ecma_op_function_call (getter_p, base_value, NULL, 0);
        -:  383:          }
        -:  384:#endif /* JERRY_LCACHE */
        -:  385:        }
        -:  386:
    #####:  387:        ecma_value_t result = ecma_op_object_bound_environment_resolve_reference_value (lex_env_p, name_p);
        -:  388:
    #####:  389:        if (ecma_is_value_found (result))
        -:  390:        {
        -:  391:          /* Note: the result may contains ECMA_VALUE_ERROR */
    #####:  392:          return result;
        -:  393:        }
    #####:  394:        break;
        -:  395:      }
        -:  396:    }
        -:  397:
    #####:  398:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -:  399:    {
    #####:  400:      break;
        -:  401:    }
        -:  402:
    #####:  403:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  404:  }
        -:  405:
        -:  406:#if JERRY_ERROR_MESSAGES
    #####:  407:  ecma_value_t name_val = ecma_make_string_value (name_p);
    #####:  408:  ecma_value_t error_value = ecma_raise_standard_error_with_format (JERRY_ERROR_REFERENCE,
        -:  409:                                                                    "% is not defined",
        -:  410:                                                                    name_val);
        -:  411:#else /* JERRY_ERROR_MESSAGES */
        -:  412:  ecma_value_t error_value = ecma_raise_reference_error (NULL);
        -:  413:#endif /* !JERRY_ERROR_MESSAGES */
    #####:  414:  return error_value;
        -:  415:} /* ecma_op_resolve_reference_value */
        -:  416:
        -:  417:/**
        -:  418: * @}
        -:  419: * @}
        -:  420: */
