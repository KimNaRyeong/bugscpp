        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-conversion.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-globals.h"
        -:   19:#include "ecma-helpers.h"
        -:   20:#include "jrt-libc-includes.h"
        -:   21:#include "lit-char-helpers.h"
        -:   22:#include "lit-magic-strings.h"
        -:   23:
        -:   24:/** \addtogroup ecma ECMA
        -:   25: * @{
        -:   26: *
        -:   27: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   28: * @{
        -:   29: */
        -:   30:
        -:   31:#if JERRY_NUMBER_TYPE_FLOAT64
        -:   32:
        -:   33:/**
        -:   34: * \addtogroup ecmahelpersbigintegers Helpers for operations intermediate 128-bit integers
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:/**
        -:   39: * 128-bit integer type
        -:   40: */
        -:   41:typedef struct
        -:   42:{
        -:   43:  uint64_t lo; /**< low 64 bits */
        -:   44:  uint64_t hi; /**< high 64 bits */
        -:   45:} ecma_uint128_t;
        -:   46:
        -:   47:/**
        -:   48: * Round high part of 128-bit integer to uint64_t
        -:   49: *
        -:   50: * @return rounded high to uint64_t
        -:   51: */
        -:   52:static uint64_t
        3:   53:ecma_round_high_to_uint64 (ecma_uint128_t *num_p)
        -:   54:{
        3:   55:  uint64_t masked_lo = num_p->lo & ~(1ULL << 63u);
        3:   56:  uint64_t masked_hi = num_p->hi & 0x1;
        -:   57:
        3:   58:  if ((num_p->lo >> 63u != 0)
    #####:   59:      && (masked_lo > 0 || masked_hi != 0))
        -:   60:  {
    #####:   61:    return (num_p->hi + 1);
        -:   62:  }
        3:   63:  return num_p->hi;
        -:   64:} /* ecma_round_high_to_uint64 */
        -:   65:
        -:   66:/**
        -:   67: * Check if 128-bit integer is zero
        -:   68: */
        -:   69:#define ECMA_UINT128_IS_ZERO(name) \
        -:   70:  (name.hi == 0 && name.lo == 0)
        -:   71:
        -:   72:/**
        -:   73: * Left shift 128-bit integer by max 63 bits
        -:   74: */
        -:   75:#define ECMA_UINT128_LEFT_SHIFT_MAX63(name, shift) \
        -:   76:{ \
        -:   77:  name.hi = (name.hi << (shift)) | (name.lo >> (64 - (shift))); \
        -:   78:  name.lo <<= (shift); \
        -:   79:}
        -:   80:
        -:   81:/**
        -:   82: * Right shift 128-bit integer by max 63 bits
        -:   83: */
        -:   84:#define ECMA_UINT128_RIGHT_SHIFT_MAX63(name, shift) \
        -:   85:{ \
        -:   86:  name.lo = (name.lo >> (shift)) | (name.hi << (64 - (shift))); \
        -:   87:  name.hi >>= (shift); \
        -:   88:}
        -:   89:
        -:   90:/**
        -:   91: * Add 128-bit integer
        -:   92: */
        -:   93:#define ECMA_UINT128_ADD(name_add_to, name_to_add) \
        -:   94:{ \
        -:   95:  name_add_to.hi += name_to_add.hi; \
        -:   96:  name_add_to.lo += name_to_add.lo; \
        -:   97:  if (name_add_to.lo < name_to_add.lo) \
        -:   98:  { \
        -:   99:    name_add_to.hi++; \
        -:  100:  } \
        -:  101:}
        -:  102:
        -:  103:/**
        -:  104: * Multiply 128-bit integer by 10
        -:  105: */
        -:  106:#define ECMA_UINT128_MUL10(name) \
        -:  107:{ \
        -:  108:  ECMA_UINT128_LEFT_SHIFT_MAX63 (name, 1u); \
        -:  109:  \
        -:  110:  ecma_uint128_t name ## _tmp = name; \
        -:  111:  \
        -:  112:  ECMA_UINT128_LEFT_SHIFT_MAX63 (name ## _tmp, 2u); \
        -:  113:  \
        -:  114:  ECMA_UINT128_ADD (name, name ## _tmp); \
        -:  115:}
        -:  116:
        -:  117:/**
        -:  118: * Divide 128-bit integer by 10
        -:  119: *
        -:  120: * N = N3 *2^96  + N2 *2^64  + N1 *2^32  + N0 *2^0     // 128-bit dividend
        -:  121: * T = T3 *2^-32 + T2 *2^-64 + T1 *2^-96 + T0 *2^-128  // 128-bit divisor reciprocal, 1/10 * 2^-128
        -:  122: *
        -:  123: * N * T    = N3*T3 *2^64 + N2*T3 *2^32 + N1*T3 *2^0 + N0*T3 *2^-32
        -:  124: *          +               N3*T2 *2^32 + N2*T2 *2^0 + N1*T2 *2^-32 + N0*T2 *2^-64
        -:  125: *          +                             N3*T1 *2^0 + N2*T1 *2^-32 + N1*T1 *2^-64 + N0*T1 *2^-96
        -:  126: *          +                                          N3*T0 *2^-32 + N2*T0 *2^-64 + N1*T0 *2^-96 + N0*T0 *2^-128
        -:  127: *
        -:  128: *  Q3=carry  Q2=^+carry    Q1=^+carry    Q0=^+carry   fraction=^...
        -:  129: *
        -:  130: * Q = Q3 *2^96  + Q2 *2^64  + Q1 *2^32  + Q0 *2^0     // 128-bit quotient
        -:  131: */
        -:  132:#define ECMA_UINT128_DIV10(name) \
        -:  133:{ \
        -:  134:  /* estimation of reciprocal of 10, 128 bits right of the binary point (T1 == T2) */ \
        -:  135:  const uint64_t tenth_l = 0x9999999aul; \
        -:  136:  const uint64_t tenth_m = 0x99999999ul; \
        -:  137:  const uint64_t tenth_h = 0x19999999ul; \
        -:  138:  \
        -:  139:  uint64_t l0 = ((uint32_t) name.lo) * tenth_l; \
        -:  140:  uint64_t l1 = (name.lo >> 32u) * tenth_l; \
        -:  141:  uint64_t l2 = ((uint32_t) name.hi) * tenth_l; \
        -:  142:  uint64_t l3 = (name.hi >> 32u) * tenth_l; \
        -:  143:  uint64_t m0 = ((uint32_t) name.lo) * tenth_m; \
        -:  144:  uint64_t m1 = (name.lo >> 32u) * tenth_m; \
        -:  145:  uint64_t m2 = ((uint32_t) name.hi) * tenth_m; \
        -:  146:  uint64_t m3 = (name.hi >> 32u) * tenth_m; \
        -:  147:  uint64_t h0 = ((uint32_t) name.lo) * tenth_h; \
        -:  148:  uint64_t h1 = (name.lo >> 32u) * tenth_h; \
        -:  149:  uint64_t h2 = ((uint32_t) name.hi) * tenth_h; \
        -:  150:  uint64_t h3 = (name.hi >> 32u) * tenth_h; \
        -:  151:  \
        -:  152:  uint64_t q0 = l0 >> 32u; \
        -:  153:  q0 += (uint32_t) l1; \
        -:  154:  q0 += (uint32_t) m0; \
        -:  155:  \
        -:  156:  q0 >>= 32u; \
        -:  157:  q0 += l1 >> 32u; \
        -:  158:  q0 += m0 >> 32u; \
        -:  159:  q0 += (uint32_t) l2; \
        -:  160:  q0 += (uint32_t) m1; \
        -:  161:  q0 += (uint32_t) m0; \
        -:  162:  \
        -:  163:  q0 >>= 32u; \
        -:  164:  q0 += l2 >> 32u; \
        -:  165:  q0 += m1 >> 32u; \
        -:  166:  q0 += m0 >> 32u; \
        -:  167:  q0 += (uint32_t) l3; \
        -:  168:  q0 += (uint32_t) m2; \
        -:  169:  q0 += (uint32_t) m1; \
        -:  170:  q0 += (uint32_t) h0; \
        -:  171:  \
        -:  172:  q0 >>=32u; \
        -:  173:  q0 += l3 >> 32u; \
        -:  174:  q0 += m2 >> 32u; \
        -:  175:  q0 += m1 >> 32u; \
        -:  176:  q0 += h0 >> 32u; \
        -:  177:  q0 += (uint32_t) m3; \
        -:  178:  q0 += (uint32_t) m2; \
        -:  179:  q0 += (uint32_t) h1; \
        -:  180:  \
        -:  181:  uint64_t q1 = q0 >> 32u; \
        -:  182:  q1 += m3 >> 32u; \
        -:  183:  q1 += m2 >> 32u; \
        -:  184:  q1 += h1 >> 32u; \
        -:  185:  q1 += (uint32_t) m3; \
        -:  186:  q1 += (uint32_t) h2; \
        -:  187:  \
        -:  188:  uint64_t q32 = q1 >> 32u; \
        -:  189:  q32 += m3 >> 32u; \
        -:  190:  q32 += h2 >> 32u; \
        -:  191:  q32 += h3; \
        -:  192:  \
        -:  193:  name.lo = (q1 << 32u) | ((uint32_t) q0); \
        -:  194:  name.hi = q32; \
        -:  195:}
        -:  196:
        -:  197:#if defined (__GNUC__) || defined (__clang__)
        -:  198:
        -:  199:/**
        -:  200: * Count leading zeros in the topmost 64 bits of a 128-bit integer.
        -:  201: */
        -:  202:#define ECMA_UINT128_CLZ_MAX63(name) \
        -:  203:  __builtin_clzll (name.hi)
        -:  204:
        -:  205:/**
        -:  206: * Count leading zeros in the topmost 4 bits of a 128-bit integer.
        -:  207: */
        -:  208:#define ECMA_UINT128_CLZ_MAX4(name) \
        -:  209:  __builtin_clzll (name.hi)
        -:  210:
        -:  211:#else /* !__GNUC__ && !__clang__ */
        -:  212:
        -:  213:/**
        -:  214: * Count leading zeros in a 64-bit integer. The behaviour is undefined for 0.
        -:  215: *
        -:  216: * @return number of leading zeros.
        -:  217: */
        -:  218:static inline int JERRY_ATTR_ALWAYS_INLINE
        -:  219:ecma_uint64_clz (uint64_t n) /**< integer to count leading zeros in */
        -:  220:{
        -:  221:  JERRY_ASSERT (n != 0);
        -:  222:
        -:  223:  int cnt = 0;
        -:  224:  uint64_t one = 0x8000000000000000ull;
        -:  225:  while ((n & one) == 0)
        -:  226:  {
        -:  227:    cnt++;
        -:  228:    one >>= 1;
        -:  229:  }
        -:  230:  return cnt;
        -:  231:} /* ecma_uint64_clz */
        -:  232:
        -:  233:/**
        -:  234: * Number of leading zeros in 4-bit integers.
        -:  235: */
        -:  236:static const uint8_t ecma_uint4_clz[] = { 4, 3, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0 };
        -:  237:
        -:  238:/**
        -:  239: * Count leading zeros in the topmost 64 bits of a 128-bit integer.
        -:  240: */
        -:  241:#define ECMA_UINT128_CLZ_MAX63(name) \
        -:  242:  ecma_uint64_clz (name.hi)
        -:  243:
        -:  244:/**
        -:  245: * Count leading zeros in the topmost 4 bits of a 128-bit integer.
        -:  246: */
        -:  247:#define ECMA_UINT128_CLZ_MAX4(name) \
        -:  248:  ecma_uint4_clz[name.hi >> 60]
        -:  249:
        -:  250:#endif /* __GNUC__ || __clang__ */
        -:  251:
        -:  252:/**
        -:  253: * @}
        -:  254: */
        -:  255:
        -:  256:/**
        -:  257: * Number.MAX_VALUE exponent part when using 64 bit float representation.
        -:  258: */
        -:  259:#define NUMBER_MAX_DECIMAL_EXPONENT 308
        -:  260:/**
        -:  261: * Number.MIN_VALUE exponent part when using 64 bit float representation.
        -:  262: */
        -:  263:#define NUMBER_MIN_DECIMAL_EXPONENT -324
        -:  264:
        -:  265:#elif !JERRY_NUMBER_TYPE_FLOAT64
        -:  266:
        -:  267:/**
        -:  268: * Number.MAX_VALUE exponent part when using 32 bit float representation.
        -:  269: */
        -:  270:#define NUMBER_MAX_DECIMAL_EXPONENT 38
        -:  271:/**
        -:  272: * Number.MIN_VALUE exponent part when using 32 bit float representation.
        -:  273: */
        -:  274:#define NUMBER_MIN_DECIMAL_EXPONENT -45
        -:  275:
        -:  276:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  277:
        -:  278:/**
        -:  279: * Value of epsilon
        -:  280: */
        -:  281:#define EPSILON 0.0000001
        -:  282:
        -:  283:/**
        -:  284: * ECMA-defined conversion from string to number for different radixes (2, 8, 16).
        -:  285: *
        -:  286: * See also:
        -:  287: *          ECMA-262 v5 9.3.1
        -:  288: *          ECMA-262 v6 7.1.3.1
        -:  289: *
        -:  290: * @return NaN - if the conversion fails
        -:  291: *         converted number - otherwise
        -:  292: */
        -:  293:static ecma_number_t
    #####:  294:ecma_utf8_string_to_number_by_radix (const lit_utf8_byte_t *str_p, /**< utf-8 string */
        -:  295:                                     const lit_utf8_byte_t *end_p, /**< end of utf-8 string  */
        -:  296:                                     uint32_t radix) /**< radix */
        -:  297:{
        -:  298:#if JERRY_ESNEXT
    #####:  299:  bool allow_underscore = (radix & ECMA_CONVERSION_ALLOW_UNDERSCORE);
    #####:  300:  radix &= (uint32_t) ~ECMA_CONVERSION_ALLOW_UNDERSCORE;
        -:  301:#endif /* JERRY_ESNEXT */
    #####:  302:  JERRY_ASSERT (radix == 2 || radix == 8 || radix == 16);
        -:  303:
    #####:  304:  ecma_number_t num = ECMA_NUMBER_ZERO;
        -:  305:
        -:  306:#if JERRY_ESNEXT
    #####:  307:  if (radix <= 8)
        -:  308:  {
    #####:  309:    lit_code_point_t upper_limit = LIT_CHAR_0 + radix;
        -:  310:
    #####:  311:    for (const lit_utf8_byte_t * iter_p = str_p;  iter_p <= end_p; iter_p++)
        -:  312:    {
        -:  313:      int32_t digit_value;
        -:  314:
    #####:  315:      if (*iter_p >= LIT_CHAR_0 && *iter_p < upper_limit)
        -:  316:      {
    #####:  317:        digit_value = (*iter_p - LIT_CHAR_0);
        -:  318:      }
        -:  319:      else
        -:  320:      {
    #####:  321:        return ecma_number_make_nan ();
        -:  322:      }
        -:  323:
    #####:  324:      num = num * radix + (ecma_number_t) digit_value;
        -:  325:    }
        -:  326:
    #####:  327:    return num;
        -:  328:  }
        -:  329:#endif /* JERRY_ESNEXT */
        -:  330:
    #####:  331:  for (const lit_utf8_byte_t * iter_p = str_p; iter_p <= end_p; iter_p++)
        -:  332:  {
        -:  333:    int32_t digit_value;
        -:  334:
    #####:  335:    if (*iter_p >= LIT_CHAR_0
    #####:  336:        && *iter_p <= LIT_CHAR_9)
        -:  337:    {
    #####:  338:      digit_value = (*iter_p - LIT_CHAR_0);
        -:  339:    }
    #####:  340:    else if (*iter_p >= LIT_CHAR_LOWERCASE_A
    #####:  341:            && *iter_p <= LIT_CHAR_LOWERCASE_F)
        -:  342:    {
    #####:  343:      digit_value = 10 + (*iter_p - LIT_CHAR_LOWERCASE_A);
        -:  344:    }
    #####:  345:    else if (*iter_p >= LIT_CHAR_UPPERCASE_A
    #####:  346:            && *iter_p <= LIT_CHAR_UPPERCASE_F)
        -:  347:    {
    #####:  348:      digit_value = 10 + (*iter_p - LIT_CHAR_UPPERCASE_A);
        -:  349:    }
        -:  350:#if JERRY_ESNEXT
    #####:  351:    else if (*iter_p == LIT_CHAR_UNDERSCORE && allow_underscore)
        -:  352:    {
    #####:  353:      continue;
        -:  354:    }
        -:  355:#endif /* JERRY_ESNEXT */
        -:  356:    else
        -:  357:    {
    #####:  358:      return ecma_number_make_nan ();
        -:  359:    }
        -:  360:
    #####:  361:    num = num * (ecma_number_t) radix + (ecma_number_t) digit_value;
        -:  362:  }
        -:  363:
    #####:  364:  return num;
        -:  365:} /* ecma_utf8_string_to_number_by_radix */
        -:  366:
        -:  367:/**
        -:  368: * ECMA-defined conversion of string to Number.
        -:  369: *
        -:  370: * See also:
        -:  371: *          ECMA-262 v5, 9.3.1
        -:  372: *
        -:  373: * @return NaN - if the conversion fails
        -:  374: *         converted number - otherwise
        -:  375: */
        -:  376:ecma_number_t
        5:  377:ecma_utf8_string_to_number (const lit_utf8_byte_t *str_p, /**< utf-8 string */
        -:  378:                            lit_utf8_size_t str_size, /**< string size */
        -:  379:                            uint32_t options) /**< allowing underscore option bit */
        -:  380:{
        -:  381:  /* TODO: Check license issues */
        -:  382:
        5:  383:  if (str_size == 0)
        -:  384:  {
    #####:  385:    return ECMA_NUMBER_ZERO;
        -:  386:  }
        -:  387:
        5:  388:  ecma_string_trim_helper (&str_p, &str_size);
        5:  389:  const lit_utf8_byte_t *end_p = str_p + (str_size - 1);
        -:  390:
        5:  391:  if (str_size < 1)
        -:  392:  {
    #####:  393:    return ECMA_NUMBER_ZERO;
        -:  394:  }
        -:  395:
        5:  396:  if (end_p >= str_p + 2
        2:  397:      && str_p[0] == LIT_CHAR_0)
        -:  398:  {
        1:  399:    switch (LEXER_TO_ASCII_LOWERCASE (str_p[1]))
        -:  400:    {
    #####:  401:      case LIT_CHAR_LOWERCASE_X :
        -:  402:      {
    #####:  403:        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 16 | options);
        -:  404:      }
    #####:  405:      case LIT_CHAR_LOWERCASE_O :
        -:  406:      {
    #####:  407:        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 8 | options);
        -:  408:      }
    #####:  409:      case LIT_CHAR_LOWERCASE_B :
        -:  410:      {
    #####:  411:        return ecma_utf8_string_to_number_by_radix (str_p + 2, end_p, 2 | options);
        -:  412:      }
        1:  413:      default:
        -:  414:      {
        1:  415:        break;
        -:  416:      }
        -:  417:    }
        4:  418:  }
        -:  419:
        5:  420:  bool sign = false; /* positive */
        -:  421:
        5:  422:  if (*str_p == LIT_CHAR_PLUS)
        -:  423:  {
    #####:  424:    str_p++;
        -:  425:  }
        5:  426:  else if (*str_p == LIT_CHAR_MINUS)
        -:  427:  {
    #####:  428:    sign = true; /* negative */
        -:  429:
    #####:  430:    str_p++;
        -:  431:  }
        -:  432:
        5:  433:  if (str_p > end_p)
        -:  434:  {
    #####:  435:    return ecma_number_make_nan ();
        -:  436:  }
        -:  437:
        -:  438:  /* Checking if significant part of parse string is equal to "Infinity" */
        5:  439:  const lit_utf8_byte_t *infinity_zt_str_p = lit_get_magic_string_utf8 (LIT_MAGIC_STRING_INFINITY_UL);
        -:  440:
        5:  441:  JERRY_ASSERT (strlen ((const char *) infinity_zt_str_p) == 8);
        -:  442:
        5:  443:  if ((end_p - str_p) == (8 - 1) && memcmp (infinity_zt_str_p, str_p, 8) == 0)
        -:  444:  {
    #####:  445:    return ecma_number_make_infinity (sign);
        -:  446:  }
        -:  447:
        5:  448:  uint64_t fraction_uint64 = 0;
        5:  449:  uint32_t digits = 0;
        5:  450:  int32_t e = 0;
        5:  451:  bool digit_seen = false;
        -:  452:
        -:  453:  /* Parsing digits before dot (or before end of digits part if there is no dot in number) */
       18:  454:  while (str_p <= end_p)
        -:  455:  {
        -:  456:    int32_t digit_value;
        -:  457:
        9:  458:    if (*str_p >= LIT_CHAR_0
        8:  459:        && *str_p <= LIT_CHAR_9)
        -:  460:    {
        8:  461:      digit_seen = true;
        8:  462:      digit_value = (*str_p - LIT_CHAR_0);
        -:  463:    }
        -:  464:#if JERRY_ESNEXT
        1:  465:    else if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))
        -:  466:    {
    #####:  467:      str_p++;
    #####:  468:      continue;
        -:  469:    }
        -:  470:#endif /* JERRY_ESNEXT */
        -:  471:    else
        -:  472:    {
        -:  473:      break;
        -:  474:    }
        -:  475:
       13:  476:    if (digits != 0 || digit_value != 0)
        -:  477:    {
        5:  478:      if (digits < ECMA_NUMBER_MAX_DIGITS)
        -:  479:      {
        5:  480:        fraction_uint64 = fraction_uint64 * 10 + (uint32_t) digit_value;
        5:  481:        digits++;
        -:  482:      }
        -:  483:      else
        -:  484:      {
    #####:  485:        e++;
        -:  486:      }
        -:  487:    }
        -:  488:
        8:  489:    str_p++;
        -:  490:  }
        -:  491:
        5:  492:  if (str_p <= end_p
        1:  493:      && *str_p == LIT_CHAR_DOT)
        -:  494:  {
        1:  495:    str_p++;
        -:  496:
        1:  497:    if (!digit_seen && str_p > end_p)
        -:  498:    {
    #####:  499:      return ecma_number_make_nan ();
        -:  500:    }
        -:  501:
        -:  502:    /* Parsing number's part that is placed after dot */
        5:  503:    while (str_p <= end_p)
        -:  504:    {
        -:  505:      int32_t digit_value;
        -:  506:
        3:  507:      if (*str_p >= LIT_CHAR_0
        3:  508:          && *str_p <= LIT_CHAR_9)
        -:  509:      {
        3:  510:        digit_seen = true;
        3:  511:        digit_value = (*str_p - LIT_CHAR_0);
        -:  512:      }
    #####:  513:      else if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))
        -:  514:      {
    #####:  515:        str_p++;
    #####:  516:        continue;
        -:  517:      }
        -:  518:      else
        -:  519:      {
        -:  520:        break;
        -:  521:      }
        -:  522:
        3:  523:      if (digits < ECMA_NUMBER_MAX_DIGITS)
        -:  524:      {
        3:  525:        if (digits != 0 || digit_value != 0)
        -:  526:        {
        3:  527:          fraction_uint64 = fraction_uint64 * 10 + (uint32_t) digit_value;
        3:  528:          digits++;
        -:  529:        }
        -:  530:
        3:  531:        e--;
        -:  532:      }
        -:  533:
        3:  534:      str_p++;
        -:  535:    }
        -:  536:  }
        -:  537:
        -:  538:  /* Parsing exponent literal */
        5:  539:  int32_t e_in_lit = 0;
        5:  540:  bool e_in_lit_sign = false;
        -:  541:
        5:  542:  if (str_p <= end_p
    #####:  543:      && (*str_p == LIT_CHAR_LOWERCASE_E
    #####:  544:          || *str_p == LIT_CHAR_UPPERCASE_E))
        -:  545:  {
    #####:  546:    str_p++;
        -:  547:
    #####:  548:    if (!digit_seen || str_p > end_p)
        -:  549:    {
    #####:  550:      return ecma_number_make_nan ();
        -:  551:    }
        -:  552:
    #####:  553:    if (*str_p == LIT_CHAR_PLUS)
        -:  554:    {
    #####:  555:      str_p++;
        -:  556:    }
    #####:  557:    else if (*str_p == LIT_CHAR_MINUS)
        -:  558:    {
    #####:  559:      e_in_lit_sign = true;
    #####:  560:      str_p++;
        -:  561:    }
        -:  562:
    #####:  563:    if (str_p > end_p)
        -:  564:    {
    #####:  565:      return ecma_number_make_nan ();
        -:  566:    }
        -:  567:
    #####:  568:    while (str_p <= end_p)
        -:  569:    {
        -:  570:      int32_t digit_value;
        -:  571:
    #####:  572:      if (*str_p >= LIT_CHAR_0
    #####:  573:          && *str_p <= LIT_CHAR_9)
        -:  574:      {
    #####:  575:        digit_value = (*str_p - LIT_CHAR_0);
        -:  576:      }
        -:  577:#if JERRY_ESNEXT
    #####:  578:      else if (*str_p == LIT_CHAR_UNDERSCORE && (options & ECMA_CONVERSION_ALLOW_UNDERSCORE))
        -:  579:      {
    #####:  580:        str_p++;
    #####:  581:        continue;
        -:  582:      }
        -:  583:#endif /* JERRY_ESNEXT */
        -:  584:      else
        -:  585:      {
    #####:  586:        return ecma_number_make_nan ();
        -:  587:      }
        -:  588:
    #####:  589:      e_in_lit = e_in_lit * 10 + digit_value;
    #####:  590:      int32_t e_check = e + (int32_t) digits - 1  + (e_in_lit_sign ? -e_in_lit : e_in_lit);
        -:  591:
    #####:  592:      if (e_check > NUMBER_MAX_DECIMAL_EXPONENT)
        -:  593:      {
    #####:  594:        return ecma_number_make_infinity (sign);
        -:  595:      }
    #####:  596:      else if (e_check < NUMBER_MIN_DECIMAL_EXPONENT)
        -:  597:      {
    #####:  598:        return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;
        -:  599:      }
        -:  600:
    #####:  601:      str_p++;
        -:  602:    }
        -:  603:  }
        -:  604:
        -:  605:  /* Adding value of exponent literal to exponent value */
        5:  606:  if (e_in_lit_sign)
        -:  607:  {
    #####:  608:    e -= e_in_lit;
        -:  609:  }
        -:  610:  else
        -:  611:  {
        5:  612:    e += e_in_lit;
        -:  613:  }
        -:  614:
        -:  615:  bool e_sign;
        -:  616:
        5:  617:  if (e < 0)
        -:  618:  {
        1:  619:    e_sign = true;
        1:  620:    e = -e;
        -:  621:  }
        -:  622:  else
        -:  623:  {
        4:  624:    e_sign = false;
        -:  625:  }
        -:  626:
        5:  627:  if (str_p <= end_p)
        -:  628:  {
    #####:  629:    return ecma_number_make_nan ();
        -:  630:  }
        -:  631:
        5:  632:  JERRY_ASSERT (str_p == end_p + 1);
        -:  633:
        5:  634:  if (fraction_uint64 == 0)
        -:  635:  {
        2:  636:    return sign ? -ECMA_NUMBER_ZERO : ECMA_NUMBER_ZERO;
        -:  637:  }
        -:  638:
        -:  639:#if JERRY_NUMBER_TYPE_FLOAT64
        -:  640:  /*
        -:  641:   * 128-bit mantissa storage
        -:  642:   *
        -:  643:   * Normalized: |4 bits zero|124-bit mantissa with highest bit set to 1|
        -:  644:   */
        3:  645:  ecma_uint128_t fraction_uint128 = { 0, fraction_uint64 };
        -:  646:
        -:  647:  /* Normalizing mantissa */
        3:  648:  int shift = 4 - ECMA_UINT128_CLZ_MAX63 (fraction_uint128);
        3:  649:  if (shift < 0)
        -:  650:  {
        3:  651:    ECMA_UINT128_LEFT_SHIFT_MAX63 (fraction_uint128, -shift);
        -:  652:  }
        -:  653:  else
        -:  654:  {
    #####:  655:    ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);
        -:  656:  }
        3:  657:  int32_t binary_exponent = 1 + shift;
        -:  658:
        3:  659:  if (!e_sign)
        -:  660:  {
        -:  661:    /* positive or zero decimal exponent */
        2:  662:    JERRY_ASSERT (e >= 0);
        -:  663:
        4:  664:    while (e > 0)
        -:  665:    {
    #####:  666:      JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);
        -:  667:
    #####:  668:      ECMA_UINT128_MUL10 (fraction_uint128);
        -:  669:
    #####:  670:      e--;
        -:  671:
        -:  672:      /* Normalizing mantissa */
    #####:  673:      shift = 4 - ECMA_UINT128_CLZ_MAX4 (fraction_uint128);
    #####:  674:      JERRY_ASSERT (shift >= 0);
    #####:  675:      ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);
    #####:  676:      binary_exponent += shift;
        -:  677:    }
        -:  678:  }
        -:  679:  else
        -:  680:  {
        -:  681:    /* negative decimal exponent */
        1:  682:    JERRY_ASSERT (e != 0);
        -:  683:
        5:  684:    while (e > 0)
        -:  685:    {
        -:  686:      /* Denormalizing mantissa, moving highest 1 to bit 127 */
        3:  687:      shift = ECMA_UINT128_CLZ_MAX4 (fraction_uint128);
        3:  688:      JERRY_ASSERT (shift <= 4);
        3:  689:      ECMA_UINT128_LEFT_SHIFT_MAX63 (fraction_uint128, shift);
        3:  690:      binary_exponent -= shift;
        -:  691:
        3:  692:      JERRY_ASSERT (!ECMA_UINT128_IS_ZERO (fraction_uint128));
        -:  693:
        3:  694:      ECMA_UINT128_DIV10 (fraction_uint128);
        -:  695:
        3:  696:      e--;
        -:  697:    }
        -:  698:
        -:  699:    /* Normalizing mantissa */
        1:  700:    shift = 4 - ECMA_UINT128_CLZ_MAX4 (fraction_uint128);
        1:  701:    JERRY_ASSERT (shift >= 0);
        1:  702:    ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, shift);
        1:  703:    binary_exponent += shift;
        -:  704:
        1:  705:    JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);
        -:  706:  }
        -:  707:
        3:  708:  JERRY_ASSERT (!ECMA_UINT128_IS_ZERO (fraction_uint128));
        3:  709:  JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 4);
        -:  710:
        -:  711:  /*
        -:  712:   * Preparing mantissa for conversion to 52-bit representation, converting it to:
        -:  713:   *
        -:  714:   * |11 zero bits|1|116 mantissa bits|
        -:  715:   */
        3:  716:  ECMA_UINT128_RIGHT_SHIFT_MAX63 (fraction_uint128, 7u);
        3:  717:  binary_exponent += 7;
        -:  718:
        3:  719:  JERRY_ASSERT (ECMA_UINT128_CLZ_MAX63 (fraction_uint128) == 11);
        -:  720:
        3:  721:  fraction_uint64 = ecma_round_high_to_uint64 (&fraction_uint128);
        -:  722:
        3:  723:  return ecma_number_make_from_sign_mantissa_and_exponent (sign, fraction_uint64, binary_exponent);
        -:  724:#elif !JERRY_NUMBER_TYPE_FLOAT64
        -:  725:  /* Less precise conversion */
        -:  726:  ecma_number_t num = (ecma_number_t) (uint32_t) fraction_uint64;
        -:  727:
        -:  728:  ecma_number_t m = e_sign ? (ecma_number_t) 0.1 : (ecma_number_t) 10.0;
        -:  729:
        -:  730:  while (e)
        -:  731:  {
        -:  732:    if (e % 2)
        -:  733:    {
        -:  734:      num *= m;
        -:  735:    }
        -:  736:
        -:  737:    m *= m;
        -:  738:    e /= 2;
        -:  739:  }
        -:  740:
        -:  741:  return num;
        -:  742:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -:  743:} /* ecma_utf8_string_to_number */
        -:  744:
        -:  745:/**
        -:  746: * ECMA-defined conversion of UInt32 to String (zero-terminated).
        -:  747: *
        -:  748: * See also:
        -:  749: *          ECMA-262 v5, 9.8.1
        -:  750: *
        -:  751: * @return number of bytes copied to buffer
        -:  752: */
        -:  753:lit_utf8_size_t
    #####:  754:ecma_uint32_to_utf8_string (uint32_t value, /**< value to convert */
        -:  755:                            lit_utf8_byte_t *out_buffer_p, /**< buffer for string */
        -:  756:                            lit_utf8_size_t buffer_size) /**< size of buffer */
        -:  757:{
    #####:  758:  lit_utf8_byte_t *buf_p = out_buffer_p + buffer_size;
        -:  759:
        -:  760:  do
        -:  761:  {
    #####:  762:    JERRY_ASSERT (buf_p >= out_buffer_p);
        -:  763:
    #####:  764:    buf_p--;
    #####:  765:    *buf_p = (lit_utf8_byte_t) ((value % 10) + LIT_CHAR_0);
    #####:  766:    value /= 10;
        -:  767:  }
    #####:  768:  while (value != 0);
        -:  769:
    #####:  770:  JERRY_ASSERT (buf_p >= out_buffer_p);
        -:  771:
    #####:  772:  lit_utf8_size_t bytes_copied = (lit_utf8_size_t) (out_buffer_p + buffer_size - buf_p);
        -:  773:
    #####:  774:  if (JERRY_LIKELY (buf_p != out_buffer_p))
        -:  775:  {
    #####:  776:    memmove (out_buffer_p, buf_p, bytes_copied);
        -:  777:  }
        -:  778:
    #####:  779:  return bytes_copied;
        -:  780:} /* ecma_uint32_to_utf8_string */
        -:  781:
        -:  782:/**
        -:  783: * ECMA-defined conversion of Number value to UInt32 value
        -:  784: *
        -:  785: * See also:
        -:  786: *          ECMA-262 v5, 9.6
        -:  787: *
        -:  788: * @return 32-bit unsigned integer - result of conversion.
        -:  789: */
        -:  790:uint32_t
        2:  791:ecma_number_to_uint32 (ecma_number_t num) /**< ecma-number */
        -:  792:{
        2:  793:  if (JERRY_UNLIKELY (ecma_number_is_zero (num) || !ecma_number_is_finite (num)))
        -:  794:  {
    #####:  795:    return 0;
        -:  796:  }
        -:  797:
        2:  798:  const bool sign = ecma_number_is_negative (num);
        2:  799:  const ecma_number_t abs_num = sign ? -num : num;
        -:  800:
        -:  801:  /* 2 ^ 32 */
        2:  802:  const uint64_t uint64_2_pow_32 = (1ull << 32);
        -:  803:
        2:  804:  const ecma_number_t num_2_pow_32 = (float) uint64_2_pow_32;
        -:  805:
        -:  806:  ecma_number_t num_in_uint32_range;
        -:  807:
        2:  808:  if (abs_num >= num_2_pow_32)
        -:  809:  {
    #####:  810:    num_in_uint32_range = ecma_number_calc_remainder (abs_num,
        -:  811:                                                      num_2_pow_32);
        -:  812:  }
        -:  813:  else
        -:  814:  {
        2:  815:    num_in_uint32_range = abs_num;
        -:  816:  }
        -:  817:
        -:  818:  /* Check that the floating point value can be represented with uint32_t. */
        2:  819:  JERRY_ASSERT (num_in_uint32_range < uint64_2_pow_32);
        2:  820:  uint32_t uint32_num = (uint32_t) num_in_uint32_range;
        -:  821:
        2:  822:  const uint32_t ret = sign ? -uint32_num : uint32_num;
        -:  823:
        -:  824:#ifndef JERRY_NDEBUG
        2:  825:  if (sign
    #####:  826:      && uint32_num != 0)
        -:  827:  {
    #####:  828:    JERRY_ASSERT (ret == uint64_2_pow_32 - uint32_num);
        -:  829:  }
        -:  830:  else
        -:  831:  {
        2:  832:    JERRY_ASSERT (ret == uint32_num);
        -:  833:  }
        -:  834:#endif /* !JERRY_NDEBUG */
        -:  835:
        2:  836:  return ret;
        -:  837:} /* ecma_number_to_uint32 */
        -:  838:
        -:  839:/**
        -:  840: * ECMA-defined conversion of Number value to Int32 value
        -:  841: *
        -:  842: * See also:
        -:  843: *          ECMA-262 v5, 9.5
        -:  844: *
        -:  845: * @return 32-bit signed integer - result of conversion.
        -:  846: */
        -:  847:int32_t
    #####:  848:ecma_number_to_int32 (ecma_number_t num) /**< ecma-number */
        -:  849:{
    #####:  850:  uint32_t uint32_num = ecma_number_to_uint32 (num);
        -:  851:
        -:  852:  /* 2 ^ 32 */
    #####:  853:  const int64_t int64_2_pow_32 = (1ll << 32);
        -:  854:
        -:  855:  /* 2 ^ 31 */
    #####:  856:  const uint32_t uint32_2_pow_31 = (1ull << 31);
        -:  857:
        -:  858:  int32_t ret;
        -:  859:
    #####:  860:  if (uint32_num >= uint32_2_pow_31)
        -:  861:  {
    #####:  862:    ret = (int32_t) (uint32_num - int64_2_pow_32);
        -:  863:  }
        -:  864:  else
        -:  865:  {
    #####:  866:    ret = (int32_t) uint32_num;
        -:  867:  }
        -:  868:
        -:  869:#ifndef JERRY_NDEBUG
    #####:  870:  int64_t int64_num = uint32_num;
        -:  871:
    #####:  872:  JERRY_ASSERT (int64_num >= 0);
        -:  873:
    #####:  874:  if (int64_num >= uint32_2_pow_31)
        -:  875:  {
    #####:  876:    JERRY_ASSERT (ret == int64_num - int64_2_pow_32);
        -:  877:  }
        -:  878:  else
        -:  879:  {
    #####:  880:    JERRY_ASSERT (ret == int64_num);
        -:  881:  }
        -:  882:#endif /* !JERRY_NDEBUG */
        -:  883:
    #####:  884:  return ret;
        -:  885:} /* ecma_number_to_int32 */
        -:  886:
        -:  887:/**
        -:  888:  * Perform conversion of ecma-number to decimal representation with decimal exponent.
        -:  889:  *
        -:  890:  * Note:
        -:  891:  *      The calculated values correspond to s, n, k parameters in ECMA-262 v5, 9.8.1, item 5:
        -:  892:  *         - parameter out_digits_p corresponds to s, the digits of the number;
        -:  893:  *         - parameter out_decimal_exp_p corresponds to n, the decimal exponent;
        -:  894:  *         - return value corresponds to k, the number of digits.
        -:  895:  *
        -:  896:  * @return the number of digits
        -:  897:  */
        -:  898:lit_utf8_size_t
    #####:  899:ecma_number_to_decimal (ecma_number_t num, /**< ecma-number */
        -:  900:                        lit_utf8_byte_t *out_digits_p, /**< [out] buffer to fill with digits */
        -:  901:                        int32_t *out_decimal_exp_p) /**< [out] decimal exponent */
        -:  902:{
    #####:  903:  JERRY_ASSERT (!ecma_number_is_nan (num));
    #####:  904:  JERRY_ASSERT (!ecma_number_is_zero (num));
    #####:  905:  JERRY_ASSERT (!ecma_number_is_infinity (num));
    #####:  906:  JERRY_ASSERT (!ecma_number_is_negative (num));
        -:  907:
    #####:  908:  return ecma_errol0_dtoa ((double) num, out_digits_p, out_decimal_exp_p);
        -:  909:} /* ecma_number_to_decimal */
        -:  910:
        -:  911:/**
        -:  912: * Convert ecma-number to zero-terminated string
        -:  913: *
        -:  914: * See also:
        -:  915: *          ECMA-262 v5, 9.8.1
        -:  916: *
        -:  917: *
        -:  918: * @return size of utf-8 string
        -:  919: */
        -:  920:lit_utf8_size_t
    #####:  921:ecma_number_to_utf8_string (ecma_number_t num, /**< ecma-number */
        -:  922:                            lit_utf8_byte_t *buffer_p, /**< buffer for utf-8 string */
        -:  923:                            lit_utf8_size_t buffer_size) /**< size of buffer */
        -:  924:{
        -:  925:  lit_utf8_byte_t *dst_p;
        -:  926:
    #####:  927:  if (ecma_number_is_nan (num))
        -:  928:  {
        -:  929:    /* 1. */
    #####:  930:    dst_p = lit_copy_magic_string_to_buffer (LIT_MAGIC_STRING_NAN, buffer_p, buffer_size);
    #####:  931:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  932:  }
        -:  933:
    #####:  934:  if (ecma_number_is_zero (num))
        -:  935:  {
        -:  936:    /* 2. */
    #####:  937:    *buffer_p = LIT_CHAR_0;
    #####:  938:    JERRY_ASSERT (1 <= buffer_size);
    #####:  939:    return 1;
        -:  940:  }
        -:  941:
    #####:  942:  dst_p = buffer_p;
        -:  943:
    #####:  944:  if (ecma_number_is_negative (num))
        -:  945:  {
        -:  946:    /* 3. */
    #####:  947:    *dst_p++ = LIT_CHAR_MINUS;
    #####:  948:    num = -num;
        -:  949:  }
        -:  950:
    #####:  951:  if (ecma_number_is_infinity (num))
        -:  952:  {
        -:  953:    /* 4. */
    #####:  954:    dst_p = lit_copy_magic_string_to_buffer (LIT_MAGIC_STRING_INFINITY_UL, dst_p,
    #####:  955:                                             (lit_utf8_size_t) (buffer_p + buffer_size - dst_p));
    #####:  956:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  957:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  958:  }
        -:  959:
    #####:  960:  JERRY_ASSERT (ecma_number_get_next (ecma_number_get_prev (num)) == num);
        -:  961:
        -:  962:  /* 5. */
    #####:  963:  uint32_t num_uint32 = ecma_number_to_uint32 (num);
        -:  964:
    #####:  965:  if (((ecma_number_t) num_uint32) == num)
        -:  966:  {
    #####:  967:    dst_p += ecma_uint32_to_utf8_string (num_uint32, dst_p, (lit_utf8_size_t) (buffer_p + buffer_size - dst_p));
    #####:  968:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  969:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  970:  }
        -:  971:
        -:  972:  /* decimal exponent */
    #####:  973:  int32_t n;
        -:  974:  /* number of digits in mantissa */
        -:  975:  int32_t k;
        -:  976:
    #####:  977:  k = (int32_t) ecma_number_to_decimal (num, dst_p, &n);
        -:  978:
    #####:  979:  if (k <= n && n <= 21)
        -:  980:  {
        -:  981:    /* 6. */
    #####:  982:    dst_p += k;
        -:  983:
    #####:  984:    memset (dst_p, LIT_CHAR_0, (size_t) (n - k));
    #####:  985:    dst_p += n - k;
        -:  986:
    #####:  987:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  988:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -:  989:  }
        -:  990:
    #####:  991:  if (0 < n && n <= 21)
        -:  992:  {
        -:  993:    /* 7. */
    #####:  994:    memmove (dst_p + n + 1, dst_p + n, (size_t) (k - n));
    #####:  995:    *(dst_p + n) = LIT_CHAR_DOT;
    #####:  996:    dst_p += k + 1;
        -:  997:
    #####:  998:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####:  999:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -: 1000:  }
        -: 1001:
    #####: 1002:  if (-6 < n && n <= 0)
        -: 1003:  {
        -: 1004:    /* 8. */
    #####: 1005:    memmove (dst_p + 2 - n, dst_p, (size_t) k);
    #####: 1006:    memset (dst_p + 2, LIT_CHAR_0, (size_t) -n);
    #####: 1007:    *dst_p = LIT_CHAR_0;
    #####: 1008:    *(dst_p + 1) = LIT_CHAR_DOT;
    #####: 1009:    dst_p += k - n + 2;
        -: 1010:
    #####: 1011:    JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
    #####: 1012:    return (lit_utf8_size_t) (dst_p - buffer_p);
        -: 1013:  }
        -: 1014:
    #####: 1015:  if (k == 1)
        -: 1016:  {
        -: 1017:    /* 9. */
    #####: 1018:    dst_p++;
        -: 1019:  }
        -: 1020:  else
        -: 1021:  {
        -: 1022:    /* 10. */
    #####: 1023:    memmove (dst_p + 2, dst_p + 1, (size_t) (k - 1));
    #####: 1024:    *(dst_p + 1) = LIT_CHAR_DOT;
    #####: 1025:    dst_p += k + 1;
        -: 1026:  }
        -: 1027:
        -: 1028:  /* 9., 10. */
    #####: 1029:  *dst_p++ = LIT_CHAR_LOWERCASE_E;
    #####: 1030:  *dst_p++ = (n >= 1) ? LIT_CHAR_PLUS : LIT_CHAR_MINUS;
    #####: 1031:  uint32_t t = (uint32_t) (n >= 1 ? (n - 1) : -(n - 1));
        -: 1032:
    #####: 1033:  dst_p += ecma_uint32_to_utf8_string (t, dst_p, (lit_utf8_size_t) (buffer_p + buffer_size - dst_p));
        -: 1034:
    #####: 1035:  JERRY_ASSERT (dst_p <= buffer_p + buffer_size);
        -: 1036:
    #####: 1037:  return (lit_utf8_size_t) (dst_p - buffer_p);
        -: 1038:} /* ecma_number_to_utf8_string */
        -: 1039:
        -: 1040:/**
        -: 1041: * @}
        -: 1042: * @}
        -: 1043: */
