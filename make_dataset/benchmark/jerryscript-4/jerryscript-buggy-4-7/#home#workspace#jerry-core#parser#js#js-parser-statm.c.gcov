        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-statm.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:
        -:   18:#if JERRY_PARSER
        -:   19:#include "jcontext.h"
        -:   20:
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "lit-char-helpers.h"
        -:   23:
        -:   24:/** \addtogroup parser Parser
        -:   25: * @{
        -:   26: *
        -:   27: * \addtogroup jsparser JavaScript
        -:   28: * @{
        -:   29: *
        -:   30: * \addtogroup jsparser_stmt Statement parser
        -:   31: * @{
        -:   32: */
        -:   33:
        -:   34:/**
        -:   35: * Parser statement types.
        -:   36: *
        -:   37: * When a new statement is added, the following
        -:   38: * arrays must be updated as well:
        -:   39: *  - statement_lengths[]
        -:   40: *  - parser_statement_flags[]
        -:   41: */
        -:   42:typedef enum
        -:   43:{
        -:   44:  PARSER_STATEMENT_START,
        -:   45:  PARSER_STATEMENT_BLOCK,
        -:   46:#if JERRY_ESNEXT
        -:   47:  PARSER_STATEMENT_BLOCK_SCOPE,
        -:   48:  PARSER_STATEMENT_PRIVATE_SCOPE,
        -:   49:  PARSER_STATEMENT_BLOCK_CONTEXT,
        -:   50:  PARSER_STATEMENT_PRIVATE_CONTEXT,
        -:   51:#endif /* JERRY_ESNEXT */
        -:   52:  PARSER_STATEMENT_LABEL,
        -:   53:  PARSER_STATEMENT_IF,
        -:   54:  PARSER_STATEMENT_ELSE,
        -:   55:  PARSER_STATEMENT_SWITCH,
        -:   56:  PARSER_STATEMENT_SWITCH_NO_DEFAULT,
        -:   57:  PARSER_STATEMENT_DO_WHILE,
        -:   58:  PARSER_STATEMENT_WHILE,
        -:   59:  PARSER_STATEMENT_FOR,
        -:   60:  PARSER_STATEMENT_FOR_IN,
        -:   61:#if JERRY_ESNEXT
        -:   62:  PARSER_STATEMENT_FOR_OF,
        -:   63:  PARSER_STATEMENT_FOR_AWAIT_OF,
        -:   64:#endif /* JERRY_ESNEXT */
        -:   65:  PARSER_STATEMENT_WITH,
        -:   66:  PARSER_STATEMENT_TRY,
        -:   67:} parser_statement_type_t;
        -:   68:
        -:   69:/**
        -:   70: * Parser statement type flags.
        -:   71: */
        -:   72:typedef enum
        -:   73:{
        -:   74:  PARSER_STATM_NO_OPTS = 0, /**< no options */
        -:   75:  PARSER_STATM_SINGLE_STATM = (1 << 0), /**< statment can form single statement context */
        -:   76:  PARSER_STATM_HAS_BLOCK = (1 << 1), /**< statement always has a code block */
        -:   77:  PARSER_STATM_BREAK_TARGET = (1 << 2), /**< break target statement */
        -:   78:  PARSER_STATM_CONTINUE_TARGET = (1 << 3), /**< continue target statement */
        -:   79:  PARSER_STATM_CONTEXT_BREAK = (1 << 4), /**< uses another instruction form when crosses their borders */
        -:   80:} parser_statement_flags_t;
        -:   81:
        -:   82:/**
        -:   83: * Parser statement attributes.
        -:   84: * Note: the order of the attributes must be keep in sync with parser_statement_type_t
        -:   85: */
        -:   86:static const uint8_t parser_statement_flags[] =
        -:   87:{
        -:   88:  /* PARSER_STATEMENT_START */
        -:   89:  PARSER_STATM_HAS_BLOCK,
        -:   90:  /* PARSER_STATEMENT_BLOCK, */
        -:   91:  PARSER_STATM_HAS_BLOCK,
        -:   92:#if JERRY_ESNEXT
        -:   93:  /* PARSER_STATEMENT_BLOCK_SCOPE, */
        -:   94:  PARSER_STATM_HAS_BLOCK,
        -:   95:  /* PARSER_STATEMENT_PRIVATE_SCOPE, */
        -:   96:  PARSER_STATM_NO_OPTS,
        -:   97:  /* PARSER_STATEMENT_BLOCK_CONTEXT, */
        -:   98:  PARSER_STATM_HAS_BLOCK | PARSER_STATM_CONTEXT_BREAK,
        -:   99:  /* PARSER_STATEMENT_PRIVATE_CONTEXT, */
        -:  100:  PARSER_STATM_CONTEXT_BREAK,
        -:  101:#endif /* JERRY_ESNEXT */
        -:  102:  /* PARSER_STATEMENT_LABEL */
        -:  103:  PARSER_STATM_SINGLE_STATM,
        -:  104:  /* PARSER_STATEMENT_IF */
        -:  105:  PARSER_STATM_SINGLE_STATM,
        -:  106:  /* PARSER_STATEMENT_ELSE */
        -:  107:  PARSER_STATM_SINGLE_STATM,
        -:  108:  /* PARSER_STATEMENT_SWITCH */
        -:  109:  PARSER_STATM_HAS_BLOCK | PARSER_STATM_BREAK_TARGET,
        -:  110:  /* PARSER_STATEMENT_SWITCH_NO_DEFAULT */
        -:  111:  PARSER_STATM_HAS_BLOCK | PARSER_STATM_BREAK_TARGET,
        -:  112:  /* PARSER_STATEMENT_DO_WHILE */
        -:  113:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM,
        -:  114:  /* PARSER_STATEMENT_WHILE */
        -:  115:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM,
        -:  116:  /* PARSER_STATEMENT_FOR */
        -:  117:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM,
        -:  118:  /* PARSER_STATEMENT_FOR_IN */
        -:  119:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM | PARSER_STATM_CONTEXT_BREAK,
        -:  120:#if JERRY_ESNEXT
        -:  121:  /* PARSER_STATEMENT_FOR_OF */
        -:  122:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM | PARSER_STATM_CONTEXT_BREAK,
        -:  123:  /* PARSER_STATEMENT_FOR_AWAIT_OF */
        -:  124:  PARSER_STATM_BREAK_TARGET | PARSER_STATM_CONTINUE_TARGET | PARSER_STATM_SINGLE_STATM | PARSER_STATM_CONTEXT_BREAK,
        -:  125:#endif /* JERRY_ESNEXT */
        -:  126:  /* PARSER_STATEMENT_WITH */
        -:  127:  PARSER_STATM_CONTEXT_BREAK | PARSER_STATM_SINGLE_STATM,
        -:  128:  /* PARSER_STATEMENT_TRY */
        -:  129:  PARSER_STATM_HAS_BLOCK | PARSER_STATM_CONTEXT_BREAK
        -:  130:};
        -:  131:
        -:  132:#if JERRY_ESNEXT
        -:  133:/**
        -:  134: * Block statement.
        -:  135: */
        -:  136:typedef struct
        -:  137:{
        -:  138:  uint16_t scope_stack_top;               /**< preserved top of scope stack */
        -:  139:  uint16_t scope_stack_reg_top;           /**< preserved top register of scope stack */
        -:  140:} parser_block_statement_t;
        -:  141:
        -:  142:/**
        -:  143: * Context of block statement.
        -:  144: */
        -:  145:typedef struct
        -:  146:{
        -:  147:  parser_branch_t branch;                 /**< branch to the end */
        -:  148:} parser_block_context_t;
        -:  149:
        -:  150:#endif /* !JERRY_ESNEXT */
        -:  151:
        -:  152:/**
        -:  153: * Loop statement.
        -:  154: */
        -:  155:typedef struct
        -:  156:{
        -:  157:  parser_branch_node_t *branch_list_p;    /**< list of breaks and continues targeting this statement */
        -:  158:} parser_loop_statement_t;
        -:  159:
        -:  160:/**
        -:  161: * Label statement.
        -:  162: */
        -:  163:typedef struct
        -:  164:{
        -:  165:  lexer_lit_location_t label_ident;       /**< name of the label */
        -:  166:  parser_branch_node_t *break_list_p;     /**< list of breaks targeting this label */
        -:  167:} parser_label_statement_t;
        -:  168:
        -:  169:/**
        -:  170: * If/else statement.
        -:  171: */
        -:  172:typedef struct
        -:  173:{
        -:  174:  parser_branch_t branch;                 /**< branch to the end */
        -:  175:} parser_if_else_statement_t;
        -:  176:
        -:  177:/**
        -:  178: * Switch statement.
        -:  179: */
        -:  180:typedef struct
        -:  181:{
        -:  182:  parser_branch_t default_branch;         /**< branch to the default case */
        -:  183:  parser_branch_node_t *branch_list_p;    /**< branches of case statements */
        -:  184:} parser_switch_statement_t;
        -:  185:
        -:  186:/**
        -:  187: * Do-while statement.
        -:  188: */
        -:  189:typedef struct
        -:  190:{
        -:  191:  uint32_t start_offset;                  /**< start byte code offset */
        -:  192:} parser_do_while_statement_t;
        -:  193:
        -:  194:/**
        -:  195: * While statement.
        -:  196: */
        -:  197:typedef struct
        -:  198:{
        -:  199:  parser_branch_t branch;                 /**< branch to the end */
        -:  200:  scanner_location_t condition_location;  /**< condition part */
        -:  201:  uint32_t start_offset;                  /**< start byte code offset */
        -:  202:} parser_while_statement_t;
        -:  203:
        -:  204:/**
        -:  205: * For statement.
        -:  206: */
        -:  207:typedef struct
        -:  208:{
        -:  209:  parser_branch_t branch;                 /**< branch to the end */
        -:  210:  scanner_location_t condition_location;  /**< condition part */
        -:  211:  scanner_location_t expression_location; /**< expression part */
        -:  212:  uint32_t start_offset;                  /**< start byte code offset */
        -:  213:} parser_for_statement_t;
        -:  214:
        -:  215:/**
        -:  216: * For-in statement.
        -:  217: */
        -:  218:typedef struct
        -:  219:{
        -:  220:  parser_branch_t branch;                 /**< branch to the end */
        -:  221:  uint32_t start_offset;                  /**< start byte code offset */
        -:  222:} parser_for_in_of_statement_t;
        -:  223:
        -:  224:/**
        -:  225: * With statement.
        -:  226: */
        -:  227:typedef struct
        -:  228:{
        -:  229:  parser_branch_t branch;                 /**< branch to the end */
        -:  230:} parser_with_statement_t;
        -:  231:
        -:  232:/**
        -:  233: * Lexer token types.
        -:  234: */
        -:  235:typedef enum
        -:  236:{
        -:  237:  parser_try_block,                       /**< try block */
        -:  238:  parser_catch_block,                     /**< catch block */
        -:  239:  parser_finally_block,                   /**< finally block */
        -:  240:} parser_try_block_type_t;
        -:  241:
        -:  242:/**
        -:  243: * Try statement.
        -:  244: */
        -:  245:typedef struct
        -:  246:{
        -:  247:  parser_try_block_type_t type;           /**< current block type */
        -:  248:  uint16_t scope_stack_top;               /**< current top of scope stack */
        -:  249:  uint16_t scope_stack_reg_top;           /**< current top register of scope stack */
        -:  250:  parser_branch_t branch;                 /**< branch to the end of the current block */
        -:  251:} parser_try_statement_t;
        -:  252:
        -:  253:/**
        -:  254: * Returns the data consumed by a statement. It can be used
        -:  255: * to skip undesired frames on the stack during frame search.
        -:  256: *
        -:  257: * @return size consumed by a statement.
        -:  258: */
        -:  259:static inline size_t
    #####:  260:parser_statement_length (uint8_t type) /**< type of statement */
        -:  261:{
        -:  262:  static const uint8_t statement_lengths[] =
        -:  263:  {
        -:  264:    /* PARSER_STATEMENT_BLOCK */
        -:  265:    1,
        -:  266:#if JERRY_ESNEXT
        -:  267:    /* PARSER_STATEMENT_BLOCK_SCOPE */
        -:  268:    (uint8_t) (sizeof (parser_block_statement_t) + 1),
        -:  269:    /* PARSER_STATEMENT_PRIVATE_SCOPE */
        -:  270:    (uint8_t) (sizeof (parser_block_statement_t) + 1),
        -:  271:    /* PARSER_STATEMENT_BLOCK_CONTEXT */
        -:  272:    (uint8_t) (sizeof (parser_block_statement_t) + sizeof (parser_block_context_t) + 1),
        -:  273:    /* PARSER_STATEMENT_PRIVATE_CONTEXT */
        -:  274:    (uint8_t) (sizeof (parser_block_statement_t) + sizeof (parser_block_context_t) + 1),
        -:  275:#endif /* JERRY_ESNEXT */
        -:  276:    /* PARSER_STATEMENT_LABEL */
        -:  277:    (uint8_t) (sizeof (parser_label_statement_t) + 1),
        -:  278:    /* PARSER_STATEMENT_IF */
        -:  279:    (uint8_t) (sizeof (parser_if_else_statement_t) + 1),
        -:  280:    /* PARSER_STATEMENT_ELSE */
        -:  281:    (uint8_t) (sizeof (parser_if_else_statement_t) + 1),
        -:  282:    /* PARSER_STATEMENT_SWITCH */
        -:  283:    (uint8_t) (sizeof (parser_switch_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  284:    /* PARSER_STATEMENT_SWITCH_NO_DEFAULT */
        -:  285:    (uint8_t) (sizeof (parser_switch_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  286:    /* PARSER_STATEMENT_DO_WHILE */
        -:  287:    (uint8_t) (sizeof (parser_do_while_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  288:    /* PARSER_STATEMENT_WHILE */
        -:  289:    (uint8_t) (sizeof (parser_while_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  290:    /* PARSER_STATEMENT_FOR */
        -:  291:    (uint8_t) (sizeof (parser_for_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  292:    /* PARSER_STATEMENT_FOR_IN */
        -:  293:    (uint8_t) (sizeof (parser_for_in_of_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  294:#if JERRY_ESNEXT
        -:  295:    /* PARSER_STATEMENT_FOR_OF */
        -:  296:    (uint8_t) (sizeof (parser_for_in_of_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  297:    /* PARSER_STATEMENT_FOR_AWAIT_OF */
        -:  298:    (uint8_t) (sizeof (parser_for_in_of_statement_t) + sizeof (parser_loop_statement_t) + 1),
        -:  299:#endif /* JERRY_ESNEXT */
        -:  300:    /* PARSER_STATEMENT_WITH */
        -:  301:    (uint8_t) (sizeof (parser_with_statement_t) + 1 + 1),
        -:  302:    /* PARSER_STATEMENT_TRY */
        -:  303:    (uint8_t) (sizeof (parser_try_statement_t) + 1),
        -:  304:  };
        -:  305:
    #####:  306:  JERRY_ASSERT (type >= PARSER_STATEMENT_BLOCK && type <= PARSER_STATEMENT_TRY);
        -:  307:
    #####:  308:  return statement_lengths[type - PARSER_STATEMENT_BLOCK];
        -:  309:} /* parser_statement_length */
        -:  310:/**
        -:  311: * Parse expression enclosed in parens.
        -:  312: */
        -:  313:static inline void
    #####:  314:parser_parse_enclosed_expr (parser_context_t *context_p) /**< context */
        -:  315:{
    #####:  316:  lexer_next_token (context_p);
        -:  317:
    #####:  318:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -:  319:  {
    #####:  320:    parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -:  321:  }
        -:  322:
    #####:  323:  lexer_next_token (context_p);
    #####:  324:  parser_parse_expression (context_p, PARSE_EXPR);
        -:  325:
    #####:  326:  if (context_p->token.type != LEXER_RIGHT_PAREN)
        -:  327:  {
    #####:  328:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -:  329:  }
    #####:  330:  lexer_next_token (context_p);
    #####:  331:} /* parser_parse_enclosed_expr */
        -:  332:
        -:  333:#if JERRY_ESNEXT
        -:  334:
        -:  335:/**
        -:  336: * Create a block context.
        -:  337: *
        -:  338: * @return true - when a context is created, false - otherwise
        -:  339: */
        -:  340:static bool
    #####:  341:parser_push_block_context (parser_context_t *context_p, /**< context */
        -:  342:                           bool is_private) /**< is private (bound to a statement) context */
        -:  343:{
    #####:  344:  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        -:  345:
    #####:  346:  parser_block_statement_t block_statement;
    #####:  347:  block_statement.scope_stack_top = context_p->scope_stack_top;
    #####:  348:  block_statement.scope_stack_reg_top = context_p->scope_stack_reg_top;
        -:  349:
    #####:  350:  bool is_context_needed = false;
        -:  351:
    #####:  352:  if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))
        -:  353:  {
    #####:  354:    parser_block_context_t block_context;
        -:  355:
        -:  356:#ifndef JERRY_NDEBUG
    #####:  357:    PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  358:#endif /* !JERRY_NDEBUG */
        -:  359:
    #####:  360:    parser_emit_cbc_forward_branch (context_p,
        -:  361:                                    CBC_BLOCK_CREATE_CONTEXT,
        -:  362:                                    &block_context.branch);
    #####:  363:    parser_stack_push (context_p, &block_context, sizeof (parser_block_context_t));
    #####:  364:    is_context_needed = true;
        -:  365:  }
        -:  366:
    #####:  367:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
    #####:  368:  parser_stack_push (context_p, &block_statement, sizeof (parser_block_statement_t));
        -:  369:
        -:  370:  uint8_t statement_type;
        -:  371:
    #####:  372:  if (is_private)
        -:  373:  {
    #####:  374:    statement_type = (is_context_needed ? PARSER_STATEMENT_PRIVATE_CONTEXT : PARSER_STATEMENT_PRIVATE_SCOPE);
        -:  375:  }
        -:  376:  else
        -:  377:  {
    #####:  378:    statement_type = (is_context_needed ? PARSER_STATEMENT_BLOCK_CONTEXT : PARSER_STATEMENT_BLOCK_SCOPE);
        -:  379:  }
        -:  380:
    #####:  381:  parser_stack_push_uint8 (context_p, statement_type);
        -:  382:
    #####:  383:  return is_context_needed;
        -:  384:} /* parser_push_block_context */
        -:  385:
        -:  386:/**
        -:  387: * Pop block context.
        -:  388: */
        -:  389:static void
    #####:  390:parser_pop_block_context (parser_context_t *context_p) /**< context */
        -:  391:{
    #####:  392:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_SCOPE
        -:  393:                || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
        -:  394:                || context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_CONTEXT
        -:  395:                || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT);
        -:  396:
    #####:  397:  uint8_t type = context_p->stack_top_uint8;
        -:  398:
    #####:  399:  parser_block_statement_t block_statement;
        -:  400:
    #####:  401:  parser_stack_pop_uint8 (context_p);
    #####:  402:  parser_stack_pop (context_p, &block_statement, sizeof (parser_block_statement_t));
        -:  403:
    #####:  404:  context_p->scope_stack_top = block_statement.scope_stack_top;
    #####:  405:  context_p->scope_stack_reg_top = block_statement.scope_stack_reg_top;
        -:  406:
    #####:  407:  if (type == PARSER_STATEMENT_BLOCK_CONTEXT || type == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -:  408:  {
    #####:  409:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  410:#ifndef JERRY_NDEBUG
    #####:  411:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  412:#endif /* !JERRY_NDEBUG */
        -:  413:
    #####:  414:    parser_block_context_t block_context;
    #####:  415:    parser_stack_pop (context_p, &block_context, sizeof (parser_block_context_t));
        -:  416:
    #####:  417:    parser_emit_cbc (context_p, CBC_CONTEXT_END);
    #####:  418:    parser_set_branch_to_current_position (context_p, &block_context.branch);
        -:  419:  }
        -:  420:
    #####:  421:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####:  422:} /* parser_pop_block_context */
        -:  423:
        -:  424:/**
        -:  425: * Validate lexical context for a declaration.
        -:  426: */
        -:  427:static void
    #####:  428:parser_validate_lexical_context (parser_context_t *context_p) /**< context */
        -:  429:{
    #####:  430:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_LET
        -:  431:                || context_p->token.type == LEXER_KEYW_CONST
        -:  432:                || context_p->token.type == LEXER_KEYW_CLASS);
        -:  433:
    #####:  434:  if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)
        -:  435:  {
    #####:  436:    parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);
        -:  437:  }
    #####:  438:} /* parser_validate_lexical_context */
        -:  439:#endif /* JERRY_ESNEXT */
        -:  440:
        -:  441:/**
        -:  442: * Parse var statement.
        -:  443: */
        -:  444:static void
        3:  445:parser_parse_var_statement (parser_context_t *context_p) /**< context */
        -:  446:{
        3:  447:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_VAR
        -:  448:                || context_p->token.type == LEXER_KEYW_LET
        -:  449:                || context_p->token.type == LEXER_KEYW_CONST);
        -:  450:
        -:  451:#if JERRY_ESNEXT
        3:  452:  uint8_t declaration_type = context_p->token.type;
        -:  453:
        3:  454:  if (declaration_type != LEXER_KEYW_VAR)
        -:  455:  {
    #####:  456:    parser_validate_lexical_context (context_p);
        -:  457:  }
        -:  458:#endif /* JERRY_ESNEXT */
        -:  459:
        -:  460:  while (true)
        -:  461:  {
        -:  462:#if JERRY_ESNEXT
        3:  463:    if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))
        -:  464:    {
    #####:  465:      parser_pattern_flags_t flags = PARSER_PATTERN_BINDING;
        -:  466:
    #####:  467:      if (declaration_type == LEXER_KEYW_LET)
        -:  468:      {
    #####:  469:        flags |= PARSER_PATTERN_LET;
        -:  470:      }
    #####:  471:      else if (declaration_type == LEXER_KEYW_CONST)
        -:  472:      {
    #####:  473:        flags |= PARSER_PATTERN_CONST;
        -:  474:      }
        -:  475:
    #####:  476:      parser_parse_initializer_by_next_char (context_p, flags);
        -:  477:    }
        -:  478:    else
        -:  479:    {
        -:  480:#endif /* JERRY_ESNEXT */
        3:  481:      lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
        3:  482:      JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -:  483:                    && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -:  484:
        -:  485:#if JERRY_DEBUGGER || JERRY_LINE_INFO
    #####:  486:      parser_line_counter_t ident_line_counter = context_p->token.line;
        -:  487:#endif /* JERRY_DEBUGGER || JERRY_LINE_INFO */
        -:  488:#if JERRY_LINE_INFO
    #####:  489:      parser_line_counter_t ident_column_counter = context_p->token.column;
        -:  490:#endif /* JERRY_LINE_INFO */
        -:  491:
        -:  492:#if JERRY_MODULE_SYSTEM
        3:  493:      parser_module_append_export_name (context_p);
        -:  494:#endif /* JERRY_MODULE_SYSTEM */
        -:  495:
        -:  496:#if JERRY_ESNEXT
        3:  497:      if (declaration_type != LEXER_KEYW_VAR
    #####:  498:          && context_p->token.keyword_type == LEXER_KEYW_LET)
        -:  499:      {
    #####:  500:        parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);
        -:  501:      }
        -:  502:
        3:  503:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -:  504:      {
    #####:  505:        JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED);
    #####:  506:        parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -:  507:      }
        -:  508:#endif /* JERRY_ESNEXT */
        -:  509:
        3:  510:      lexer_next_token (context_p);
        -:  511:
        3:  512:      if (context_p->token.type == LEXER_ASSIGN)
        -:  513:      {
        -:  514:#if JERRY_DEBUGGER
        -:  515:        if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  516:            && ident_line_counter != context_p->last_breakpoint_line)
        -:  517:        {
        -:  518:          parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -:  519:          parser_flush_cbc (context_p);
        -:  520:
        -:  521:          parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, ident_line_counter);
        -:  522:
        -:  523:          context_p->last_breakpoint_line = ident_line_counter;
        -:  524:        }
        -:  525:#endif /* JERRY_DEBUGGER */
        -:  526:
        -:  527:#if JERRY_LINE_INFO
    #####:  528:        parser_line_info_append (context_p, ident_line_counter, ident_column_counter);
        -:  529:#endif /* JERRY_LINE_INFO */
        -:  530:
        3:  531:        uint16_t index = context_p->lit_object.index;
        -:  532:
        3:  533:        lexer_next_token (context_p);
        3:  534:        parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -:  535:
        3:  536:        cbc_opcode_t opcode = CBC_ASSIGN_SET_IDENT;
        -:  537:
        -:  538:#if JERRY_ESNEXT
        3:  539:        uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -:  540:
        3:  541:        if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -:  542:        {
    #####:  543:          uint16_t name_index = scanner_save_literal (context_p, index);
    #####:  544:          parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, name_index);
        -:  545:        }
        3:  546:        else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -:  547:        {
    #####:  548:          parser_set_function_name (context_p, function_literal_index, index, 0);
        -:  549:        }
        -:  550:
        3:  551:        if (declaration_type != LEXER_KEYW_VAR
    #####:  552:            && (index < PARSER_REGISTER_START))
        -:  553:        {
    #####:  554:          opcode = CBC_INIT_LET;
        -:  555:
    #####:  556:          if (scanner_literal_is_created (context_p, index))
        -:  557:          {
    #####:  558:            opcode = CBC_ASSIGN_LET_CONST;
        -:  559:          }
    #####:  560:          else if (declaration_type == LEXER_KEYW_CONST)
        -:  561:          {
    #####:  562:            opcode = CBC_INIT_CONST;
        -:  563:          }
        -:  564:        }
        -:  565:#endif /* JERRY_ESNEXT */
        -:  566:
        3:  567:        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);
        -:  568:      }
        -:  569:#if JERRY_ESNEXT
    #####:  570:      else if (declaration_type == LEXER_KEYW_LET)
        -:  571:      {
    #####:  572:        parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -:  573:
    #####:  574:        uint16_t index = context_p->lit_object.index;
    #####:  575:        cbc_opcode_t opcode = CBC_MOV_IDENT;
        -:  576:
    #####:  577:        if (index < PARSER_REGISTER_START)
        -:  578:        {
    #####:  579:          opcode = (scanner_literal_is_created (context_p, index) ? CBC_ASSIGN_LET_CONST
    #####:  580:                                                                  : CBC_INIT_LET);
        -:  581:        }
        -:  582:
    #####:  583:        parser_emit_cbc_literal (context_p, (uint16_t) opcode, index);
        -:  584:      }
    #####:  585:      else if (declaration_type == LEXER_KEYW_CONST)
        -:  586:      {
    #####:  587:        parser_raise_error (context_p, PARSER_ERR_MISSING_ASSIGN_AFTER_CONST);
        -:  588:      }
        -:  589:    }
        -:  590:#endif /* JERRY_ESNEXT */
        -:  591:
        3:  592:    if (context_p->token.type != LEXER_COMMA)
        -:  593:    {
        3:  594:      break;
        -:  595:    }
        -:  596:  }
        -:  597:
        -:  598:#if JERRY_MODULE_SYSTEM
        3:  599:  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);
        -:  600:#endif /* JERRY_MODULE_SYSTEM */
        3:  601:} /* parser_parse_var_statement */
        -:  602:
        -:  603:/**
        -:  604: * Parse function statement.
        -:  605: */
        -:  606:static void
    #####:  607:parser_parse_function_statement (parser_context_t *context_p) /**< context */
        -:  608:{
    #####:  609:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION);
        -:  610:
        -:  611:#if JERRY_ESNEXT
    #####:  612:  if (JERRY_UNLIKELY (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM))
        -:  613:  {
    #####:  614:    if (context_p->status_flags & PARSER_IS_STRICT)
        -:  615:    {
    #####:  616:      parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);
        -:  617:    }
        -:  618:
    #####:  619:    if (context_p->stack_top_uint8 == PARSER_STATEMENT_IF
    #####:  620:        || context_p->stack_top_uint8 == PARSER_STATEMENT_ELSE)
        -:  621:    {
        -:  622:      /* There must be a parser error later if this check fails. */
    #####:  623:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -:  624:      {
    #####:  625:        parser_push_block_context (context_p, true);
        -:  626:      }
        -:  627:    }
    #####:  628:    else if (context_p->stack_top_uint8 == PARSER_STATEMENT_LABEL)
        -:  629:    {
    #####:  630:      parser_stack_iterator_t iterator;
    #####:  631:      parser_stack_iterator_init (context_p, &iterator);
    #####:  632:      parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1);
        -:  633:
        -:  634:      while (true)
    #####:  635:      {
    #####:  636:        uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
        -:  637:
    #####:  638:        if (type == PARSER_STATEMENT_LABEL)
        -:  639:        {
    #####:  640:          parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1);
    #####:  641:          continue;
        -:  642:        }
        -:  643:
    #####:  644:        if (parser_statement_flags[type] & PARSER_STATM_HAS_BLOCK)
        -:  645:        {
    #####:  646:          break;
        -:  647:        }
        -:  648:
    #####:  649:        parser_raise_error (context_p, PARSER_ERR_LABELLED_FUNC_NOT_IN_BLOCK);
        -:  650:      }
        -:  651:    }
        -:  652:    else
        -:  653:    {
    #####:  654:      parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);
        -:  655:    }
        -:  656:  }
        -:  657:#endif /* JERRY_ESNEXT */
        -:  658:
        -:  659:#if JERRY_FUNCTION_TO_STRING
        -:  660:#if JERRY_ESNEXT
    #####:  661:  if (!(context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC))
        -:  662:  {
    #####:  663:    context_p->function_start_p = context_p->token.lit_location.char_p;
        -:  664:  }
        -:  665:#else /* !JERRY_ESNEXT */
        -:  666:  context_p->function_start_p = context_p->token.lit_location.char_p;
        -:  667:#endif /* JERRY_ESNEXT */
        -:  668:#endif /* JERRY_FUNCTION_TO_STRING */
        -:  669:
        -:  670:#if JERRY_DEBUGGER
        -:  671:  parser_line_counter_t debugger_line = context_p->token.line;
        -:  672:  parser_line_counter_t debugger_column = context_p->token.column;
        -:  673:#endif /* JERRY_DEBUGGER */
        -:  674:
        -:  675:#if JERRY_ESNEXT
    #####:  676:  bool is_generator_function = false;
        -:  677:
    #####:  678:  if (lexer_consume_generator (context_p))
        -:  679:  {
    #####:  680:    is_generator_function = true;
        -:  681:  }
        -:  682:#endif /* JERRY_ESNEXT */
        -:  683:
    #####:  684:  lexer_expect_identifier (context_p, LEXER_NEW_IDENT_LITERAL);
    #####:  685:  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -:  686:                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -:  687:
        -:  688:#if JERRY_ESNEXT
    #####:  689:  if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####:  690:      && context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED)
        -:  691:  {
    #####:  692:    parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED);
        -:  693:  }
        -:  694:
    #####:  695:  uint16_t function_name_index = context_p->lit_object.index;
        -:  696:#endif /* JERRY_ESNEXT */
        -:  697:
        -:  698:#if JERRY_MODULE_SYSTEM
    #####:  699:  parser_module_append_export_name (context_p);
    #####:  700:  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT);
        -:  701:#endif /* JERRY_MODULE_SYSTEM */
        -:  702:
    #####:  703:  uint32_t status_flags = PARSER_FUNCTION_CLOSURE;
        -:  704:
    #####:  705:  if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -:  706:  {
    #####:  707:    status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -:  708:  }
        -:  709:
        -:  710:#if JERRY_ESNEXT
    #####:  711:  if (is_generator_function)
        -:  712:  {
    #####:  713:    status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  714:  }
        -:  715:
    #####:  716:  if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC)
        -:  717:  {
    #####:  718:    status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD;
        -:  719:  }
        -:  720:#endif /* JERRY_ESNEXT */
        -:  721:
        -:  722:#if JERRY_DEBUGGER
        -:  723:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  724:  {
        -:  725:    lexer_literal_t *name_p = context_p->lit_object.literal_p;
        -:  726:    jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME,
        -:  727:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  728:                                name_p->u.char_p,
        -:  729:                                name_p->prop.length);
        -:  730:
        -:  731:    /* Reset token position for the function. */
        -:  732:    context_p->token.line = debugger_line;
        -:  733:    context_p->token.column = debugger_column;
        -:  734:  }
        -:  735:#endif /* JERRY_DEBUGGER */
        -:  736:
    #####:  737:  JERRY_ASSERT (context_p->scope_stack_top >= 2);
    #####:  738:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top - 2;
        -:  739:
    #####:  740:  uint16_t literal_index = context_p->lit_object.index;
        -:  741:
    #####:  742:  while (literal_index != scope_stack_p->map_from)
        -:  743:  {
    #####:  744:    scope_stack_p--;
        -:  745:
    #####:  746:    JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p);
        -:  747:  }
        -:  748:
    #####:  749:  JERRY_ASSERT (scope_stack_p[1].map_from == PARSER_SCOPE_STACK_FUNC);
        -:  750:
        -:  751:#if JERRY_ESNEXT
    #####:  752:  if (!(context_p->status_flags & PARSER_IS_STRICT)
    #####:  753:      && (scope_stack_p >= context_p->scope_stack_p + context_p->scope_stack_global_end))
        -:  754:  {
    #####:  755:    bool copy_value = true;
        -:  756:
    #####:  757:    parser_scope_stack_t *stack_p = context_p->scope_stack_p;
        -:  758:
    #####:  759:    while (stack_p < scope_stack_p)
        -:  760:    {
    #####:  761:      if (literal_index == stack_p->map_from
    #####:  762:          && (stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY))
        -:  763:      {
    #####:  764:        copy_value = false;
    #####:  765:        break;
        -:  766:      }
    #####:  767:      stack_p++;
        -:  768:    }
        -:  769:
    #####:  770:    if (copy_value)
        -:  771:    {
    #####:  772:      stack_p = context_p->scope_stack_p;
        -:  773:
    #####:  774:      while (stack_p < scope_stack_p)
        -:  775:      {
    #####:  776:        if (literal_index == stack_p->map_from)
        -:  777:        {
    #####:  778:          JERRY_ASSERT (!(stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY));
        -:  779:
    #####:  780:          uint16_t map_to = scanner_decode_map_to (stack_p);
    #####:  781:          uint16_t opcode = ((map_to >= PARSER_REGISTER_START) ? CBC_ASSIGN_LITERAL_SET_IDENT
        -:  782:                                                               : CBC_COPY_TO_GLOBAL);
        -:  783:
    #####:  784:          parser_emit_cbc_literal_value (context_p,
        -:  785:                                         opcode,
    #####:  786:                                         scanner_decode_map_to (scope_stack_p),
        -:  787:                                         map_to);
    #####:  788:          break;
        -:  789:        }
    #####:  790:        stack_p++;
        -:  791:      }
        -:  792:
    #####:  793:      parser_flush_cbc (context_p);
        -:  794:    }
        -:  795:
    #####:  796:    if (JERRY_UNLIKELY (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
        -:  797:                        || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT))
        -:  798:    {
    #####:  799:      parser_pop_block_context (context_p);
        -:  800:    }
        -:  801:  }
        -:  802:#endif /* JERRY_ESNEXT */
        -:  803:
    #####:  804:  lexer_literal_t *literal_p = PARSER_GET_LITERAL ((size_t) scope_stack_p[1].map_to);
        -:  805:
    #####:  806:  JERRY_ASSERT ((literal_p->type == LEXER_UNUSED_LITERAL || literal_p->type == LEXER_FUNCTION_LITERAL)
        -:  807:                && literal_p->status_flags == 0);
        -:  808:
    #####:  809:  ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, status_flags);
        -:  810:
    #####:  811:  if (literal_p->type == LEXER_FUNCTION_LITERAL)
        -:  812:  {
    #####:  813:    ecma_bytecode_deref (literal_p->u.bytecode_p);
        -:  814:  }
        -:  815:
    #####:  816:  literal_p->u.bytecode_p = compiled_code_p;
    #####:  817:  literal_p->type = LEXER_FUNCTION_LITERAL;
        -:  818:
        -:  819:#if JERRY_ESNEXT
    #####:  820:  parser_compiled_code_set_function_name (context_p, compiled_code_p, function_name_index, 0);
        -:  821:#endif /* JERRY_ESNEXT */
        -:  822:
    #####:  823:  lexer_next_token (context_p);
    #####:  824:} /* parser_parse_function_statement */
        -:  825:
        -:  826:/**
        -:  827: * Parse if statement (starting part).
        -:  828: */
        -:  829:static void
    #####:  830:parser_parse_if_statement_start (parser_context_t *context_p) /**< context */
        -:  831:{
    #####:  832:  parser_if_else_statement_t if_statement;
        -:  833:
    #####:  834:  parser_parse_enclosed_expr (context_p);
        -:  835:
    #####:  836:  parser_emit_cbc_forward_branch (context_p,
        -:  837:                                  CBC_BRANCH_IF_FALSE_FORWARD,
        -:  838:                                  &if_statement.branch);
        -:  839:
    #####:  840:  parser_stack_push (context_p, &if_statement, sizeof (parser_if_else_statement_t));
    #####:  841:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_IF);
    #####:  842:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####:  843:} /* parser_parse_if_statement_start */
        -:  844:
        -:  845:/**
        -:  846: * Parse if statement (ending part).
        -:  847: *
        -:  848: * @return true  - if parsing an 'else' statement
        -:  849: *         false - otherwise
        -:  850: */
        -:  851:static bool
    #####:  852:parser_parse_if_statement_end (parser_context_t *context_p) /**< context */
        -:  853:{
    #####:  854:  parser_if_else_statement_t if_statement;
    #####:  855:  parser_if_else_statement_t else_statement;
    #####:  856:  parser_stack_iterator_t iterator;
        -:  857:
    #####:  858:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_IF);
        -:  859:
    #####:  860:  if (context_p->token.type != LEXER_KEYW_ELSE)
        -:  861:  {
    #####:  862:    parser_stack_pop_uint8 (context_p);
    #####:  863:    parser_stack_pop (context_p, &if_statement, sizeof (parser_if_else_statement_t));
    #####:  864:    parser_stack_iterator_init (context_p, &context_p->last_statement);
        -:  865:
    #####:  866:    parser_set_branch_to_current_position (context_p, &if_statement.branch);
        -:  867:
    #####:  868:    return false;
        -:  869:  }
        -:  870:
    #####:  871:  parser_stack_change_last_uint8 (context_p, PARSER_STATEMENT_ELSE);
    #####:  872:  parser_stack_iterator_init (context_p, &iterator);
    #####:  873:  parser_stack_iterator_skip (&iterator, 1);
    #####:  874:  parser_stack_iterator_read (&iterator, &if_statement, sizeof (parser_if_else_statement_t));
        -:  875:
    #####:  876:  parser_emit_cbc_forward_branch (context_p,
        -:  877:                                  CBC_JUMP_FORWARD,
        -:  878:                                  &else_statement.branch);
        -:  879:
    #####:  880:  parser_set_branch_to_current_position (context_p, &if_statement.branch);
        -:  881:
    #####:  882:  parser_stack_iterator_write (&iterator, &else_statement, sizeof (parser_if_else_statement_t));
        -:  883:
    #####:  884:  lexer_next_token (context_p);
    #####:  885:  return true;
        -:  886:} /* parser_parse_if_statement_end */
        -:  887:
        -:  888:/**
        -:  889: * Parse with statement (starting part).
        -:  890: */
        -:  891:static void
    #####:  892:parser_parse_with_statement_start (parser_context_t *context_p) /**< context */
        -:  893:{
    #####:  894:  parser_with_statement_t with_statement;
        -:  895:
    #####:  896:  if (context_p->status_flags & PARSER_IS_STRICT)
        -:  897:  {
    #####:  898:    parser_raise_error (context_p, PARSER_ERR_WITH_NOT_ALLOWED);
        -:  899:  }
        -:  900:
    #####:  901:  parser_parse_enclosed_expr (context_p);
        -:  902:
        -:  903:#ifndef JERRY_NDEBUG
    #####:  904:  PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
        -:  905:#endif /* !JERRY_NDEBUG */
        -:  906:
    #####:  907:  uint8_t inside_with = (context_p->status_flags & PARSER_INSIDE_WITH) != 0;
        -:  908:
    #####:  909:  context_p->status_flags |= PARSER_INSIDE_WITH;
    #####:  910:  parser_emit_cbc_ext_forward_branch (context_p,
        -:  911:                                      CBC_EXT_WITH_CREATE_CONTEXT,
        -:  912:                                      &with_statement.branch);
        -:  913:
    #####:  914:  parser_stack_push (context_p, &with_statement, sizeof (parser_with_statement_t));
    #####:  915:  parser_stack_push_uint8 (context_p, inside_with);
    #####:  916:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_WITH);
    #####:  917:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####:  918:} /* parser_parse_with_statement_start */
        -:  919:
        -:  920:/**
        -:  921: * Parse with statement (ending part).
        -:  922: */
        -:  923:static void
    #####:  924:parser_parse_with_statement_end (parser_context_t *context_p) /**< context */
        -:  925:{
    #####:  926:  parser_with_statement_t with_statement;
        -:  927:
    #####:  928:  JERRY_ASSERT (context_p->status_flags & PARSER_INSIDE_WITH);
        -:  929:
    #####:  930:  parser_stack_pop_uint8 (context_p);
        -:  931:
    #####:  932:  if (!context_p->stack_top_uint8)
        -:  933:  {
    #####:  934:    context_p->status_flags &= (uint32_t) ~PARSER_INSIDE_WITH;
        -:  935:  }
        -:  936:
    #####:  937:  parser_stack_pop_uint8 (context_p);
    #####:  938:  parser_stack_pop (context_p, &with_statement, sizeof (parser_with_statement_t));
    #####:  939:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -:  940:
    #####:  941:  parser_flush_cbc (context_p);
    #####:  942:  PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
        -:  943:#ifndef JERRY_NDEBUG
    #####:  944:  PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_WITH_CONTEXT_STACK_ALLOCATION);
        -:  945:#endif /* !JERRY_NDEBUG */
        -:  946:
    #####:  947:  parser_emit_cbc (context_p, CBC_CONTEXT_END);
    #####:  948:  parser_set_branch_to_current_position (context_p, &with_statement.branch);
    #####:  949:} /* parser_parse_with_statement_end */
        -:  950:
        -:  951:/**
        -:  952: * Parse do-while statement (ending part).
        -:  953: */
        -:  954:static void
    #####:  955:parser_parse_do_while_statement_end (parser_context_t *context_p) /**< context */
        -:  956:{
    #####:  957:  parser_loop_statement_t loop;
        -:  958:
    #####:  959:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_DO_WHILE);
        -:  960:
    #####:  961:  if (context_p->token.type != LEXER_KEYW_WHILE)
        -:  962:  {
    #####:  963:    parser_raise_error (context_p, PARSER_ERR_WHILE_EXPECTED);
        -:  964:  }
        -:  965:
    #####:  966:  parser_stack_iterator_t iterator;
    #####:  967:  parser_stack_iterator_init (context_p, &iterator);
        -:  968:
    #####:  969:  parser_stack_iterator_skip (&iterator, 1);
    #####:  970:  parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
        -:  971:
    #####:  972:  parser_set_continues_to_current_position (context_p, loop.branch_list_p);
        -:  973:
    #####:  974:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p);
        -:  975:
    #####:  976:  parser_parse_enclosed_expr (context_p);
        -:  977:
    #####:  978:  if (context_p->last_cbc_opcode != CBC_PUSH_FALSE)
        -:  979:  {
    #####:  980:    cbc_opcode_t opcode = CBC_BRANCH_IF_TRUE_BACKWARD;
    #####:  981:    if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -:  982:    {
    #####:  983:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####:  984:      opcode = CBC_BRANCH_IF_FALSE_BACKWARD;
        -:  985:    }
    #####:  986:    else if (context_p->last_cbc_opcode == CBC_PUSH_TRUE)
        -:  987:    {
    #####:  988:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####:  989:      opcode = CBC_JUMP_BACKWARD;
        -:  990:    }
        -:  991:
    #####:  992:    parser_do_while_statement_t do_while_statement;
    #####:  993:    parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));
    #####:  994:    parser_stack_iterator_read (&iterator, &do_while_statement, sizeof (parser_do_while_statement_t));
        -:  995:
    #####:  996:    parser_emit_cbc_backward_branch (context_p, (uint16_t) opcode, do_while_statement.start_offset);
        -:  997:  }
        -:  998:  else
        -:  999:  {
    #####: 1000:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 1001:  }
        -: 1002:
    #####: 1003:  parser_stack_pop (context_p, NULL, 1 + sizeof (parser_loop_statement_t) + sizeof (parser_do_while_statement_t));
    #####: 1004:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1005:
    #####: 1006:  parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
    #####: 1007:} /* parser_parse_do_while_statement_end */
        -: 1008:
        -: 1009:/**
        -: 1010: * Parse while statement (starting part).
        -: 1011: */
        -: 1012:static void
    #####: 1013:parser_parse_while_statement_start (parser_context_t *context_p) /**< context */
        -: 1014:{
    #####: 1015:  parser_while_statement_t while_statement;
    #####: 1016:  parser_loop_statement_t loop;
        -: 1017:
    #####: 1018:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_WHILE);
    #####: 1019:  lexer_next_token (context_p);
        -: 1020:
    #####: 1021:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1022:  {
    #####: 1023:    parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 1024:  }
        -: 1025:
    #####: 1026:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p
        -: 1027:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_WHILE);
        -: 1028:
    #####: 1029:  if (context_p->next_scanner_info_p->source_p != context_p->source_p)
        -: 1030:  {
        -: 1031:    /* The prescanner couldn't find the end of the while condition. */
    #####: 1032:    lexer_next_token (context_p);
    #####: 1033:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1034:
    #####: 1035:    JERRY_ASSERT (context_p->token.type != LEXER_RIGHT_PAREN);
    #####: 1036:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1037:  }
        -: 1038:
    #####: 1039:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &while_statement.branch);
        -: 1040:
    #####: 1041:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 1042:
    #####: 1043:  while_statement.start_offset = context_p->byte_code_size;
    #####: 1044:  scanner_get_location (&while_statement.condition_location, context_p);
        -: 1045:
    #####: 1046:  scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 1047:  scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####: 1048:  scanner_seek (context_p);
    #####: 1049:  lexer_next_token (context_p);
        -: 1050:
    #####: 1051:  loop.branch_list_p = NULL;
        -: 1052:
    #####: 1053:  parser_stack_push (context_p, &while_statement, sizeof (parser_while_statement_t));
    #####: 1054:  parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 1055:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_WHILE);
    #####: 1056:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 1057:} /* parser_parse_while_statement_start */
        -: 1058:
        -: 1059:/**
        -: 1060: * Parse while statement (ending part).
        -: 1061: */
        -: 1062:static void JERRY_ATTR_NOINLINE
    #####: 1063:parser_parse_while_statement_end (parser_context_t *context_p) /**< context */
        -: 1064:{
    #####: 1065:  parser_while_statement_t while_statement;
    #####: 1066:  parser_loop_statement_t loop;
        -: 1067:  lexer_token_t current_token;
    #####: 1068:  scanner_location_t location;
        -: 1069:  cbc_opcode_t opcode;
        -: 1070:
    #####: 1071:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_WHILE);
        -: 1072:
    #####: 1073:  parser_stack_iterator_t iterator;
    #####: 1074:  parser_stack_iterator_init (context_p, &iterator);
        -: 1075:
    #####: 1076:  parser_stack_iterator_skip (&iterator, 1);
    #####: 1077:  parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 1078:  parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));
    #####: 1079:  parser_stack_iterator_read (&iterator, &while_statement, sizeof (parser_while_statement_t));
        -: 1080:
    #####: 1081:  scanner_get_location (&location, context_p);
    #####: 1082:  current_token = context_p->token;
        -: 1083:
    #####: 1084:  parser_set_branch_to_current_position (context_p, &while_statement.branch);
    #####: 1085:  parser_set_continues_to_current_position (context_p, loop.branch_list_p);
        -: 1086:
    #####: 1087:  scanner_set_location (context_p, &while_statement.condition_location);
    #####: 1088:  scanner_seek (context_p);
    #####: 1089:  lexer_next_token (context_p);
        -: 1090:
    #####: 1091:  parser_parse_expression (context_p, PARSE_EXPR);
    #####: 1092:  if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 1093:  {
    #####: 1094:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1095:  }
        -: 1096:
    #####: 1097:  opcode = CBC_BRANCH_IF_TRUE_BACKWARD;
    #####: 1098:  if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -: 1099:  {
    #####: 1100:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1101:    opcode = CBC_BRANCH_IF_FALSE_BACKWARD;
        -: 1102:  }
    #####: 1103:  else if (context_p->last_cbc_opcode == CBC_PUSH_TRUE)
        -: 1104:  {
    #####: 1105:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1106:    opcode = CBC_JUMP_BACKWARD;
        -: 1107:  }
        -: 1108:
    #####: 1109:  parser_stack_pop (context_p, NULL, 1 + sizeof (parser_loop_statement_t) + sizeof (parser_while_statement_t));
    #####: 1110:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1111:
    #####: 1112:  parser_emit_cbc_backward_branch (context_p, (uint16_t) opcode, while_statement.start_offset);
    #####: 1113:  parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
        -: 1114:
        -: 1115:  /* Calling scanner_seek is unnecessary because all
        -: 1116:   * info blocks inside the while statement should be processed. */
    #####: 1117:  scanner_set_location (context_p, &location);
    #####: 1118:  context_p->token = current_token;
    #####: 1119:} /* parser_parse_while_statement_end */
        -: 1120:
        -: 1121:/**
        -: 1122: * Check whether the opcode is a valid LeftHandSide expression
        -: 1123: * and convert it back to an assignment.
        -: 1124: *
        -: 1125: * @return the compatible assignment opcode
        -: 1126: */
        -: 1127:static uint16_t
    #####: 1128:parser_check_left_hand_side_expression (parser_context_t *context_p, /**< context */
        -: 1129:                                        uint16_t opcode) /**< opcode to check */
        -: 1130:{
    #####: 1131:  if (opcode == CBC_PUSH_LITERAL
    #####: 1132:      && context_p->last_cbc.literal_type == LEXER_IDENT_LITERAL)
        -: 1133:  {
    #####: 1134:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1135:    return CBC_ASSIGN_SET_IDENT;
        -: 1136:  }
    #####: 1137:  else if (opcode == CBC_PUSH_PROP)
        -: 1138:  {
    #####: 1139:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1140:    return CBC_ASSIGN;
        -: 1141:  }
    #####: 1142:  else if (opcode == CBC_PUSH_PROP_LITERAL)
        -: 1143:  {
    #####: 1144:    context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1145:    return CBC_ASSIGN_PROP_LITERAL;
        -: 1146:  }
    #####: 1147:  else if (opcode == CBC_PUSH_PROP_LITERAL_LITERAL)
        -: 1148:  {
    #####: 1149:    context_p->last_cbc_opcode = CBC_PUSH_TWO_LITERALS;
    #####: 1150:    return CBC_ASSIGN;
        -: 1151:  }
    #####: 1152:  else if (opcode == CBC_PUSH_PROP_THIS_LITERAL)
        -: 1153:  {
    #####: 1154:    context_p->last_cbc_opcode = CBC_PUSH_THIS_LITERAL;
    #####: 1155:    return CBC_ASSIGN;
        -: 1156:  }
        -: 1157:  else
        -: 1158:  {
        -: 1159:    /* Invalid LeftHandSide expression. */
        -: 1160:#if JERRY_ESNEXT
    #####: 1161:    parser_raise_error (context_p, PARSER_ERR_INVALID_LHS_FOR_LOOP);
        -: 1162:#else /* !JERRY_ESNEXT */
    #####: 1163:    parser_emit_cbc_ext (context_p, CBC_EXT_THROW_REFERENCE_ERROR);
        -: 1164:#endif /* JERRY_ESNEXT */
        -: 1165:
    #####: 1166:    return CBC_ASSIGN;
        -: 1167:  }
        -: 1168:
        -: 1169:  return opcode;
        -: 1170:} /* parser_check_left_hand_side_expression */
        -: 1171:
        -: 1172:/**
        -: 1173: * Parse for statement (starting part).
        -: 1174: */
        -: 1175:static void
        1: 1176:parser_parse_for_statement_start (parser_context_t *context_p) /**< context */
        -: 1177:{
        1: 1178:  parser_loop_statement_t loop;
        -: 1179:
        1: 1180:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FOR);
        1: 1181:  lexer_next_token (context_p);
        -: 1182:
        -: 1183:#if JERRY_ESNEXT
        1: 1184:  bool is_for_await = false;
        -: 1185:
        1: 1186:  if (context_p->token.type == LEXER_KEYW_AWAIT)
        -: 1187:  {
    #####: 1188:    if (JERRY_UNLIKELY (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 1189:    {
    #####: 1190:      parser_raise_error (context_p, PARSER_ERR_INVALID_KEYWORD);
        -: 1191:    }
    #####: 1192:    lexer_next_token (context_p);
    #####: 1193:    is_for_await = true;
        -: 1194:  }
        -: 1195:#endif /* JERRY_ESNEXT */
        -: 1196:
        1: 1197:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 1198:  {
        -: 1199:#if JERRY_ESNEXT
    #####: 1200:    if (context_p->token.type == LEXER_LITERAL
    #####: 1201:        && context_p->token.keyword_type == LEXER_KEYW_AWAIT
    #####: 1202:        && !(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -: 1203:    {
    #####: 1204:      parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_ASYNC);
        -: 1205:    }
        -: 1206:#endif /* JERRY_ESNEXT */
    #####: 1207:    parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 1208:  }
        -: 1209:
        1: 1210:  if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1211:  {
    #####: 1212:    parser_for_in_of_statement_t for_in_of_statement;
    #####: 1213:    scanner_location_t start_location, end_location;
        -: 1214:
        -: 1215:#if JERRY_ESNEXT
    #####: 1216:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN
        -: 1217:                  || context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_OF);
        -: 1218:
    #####: 1219:    bool is_for_in = (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN);
    #####: 1220:    end_location = ((scanner_location_info_t *) context_p->next_scanner_info_p)->location;
        -: 1221:
    #####: 1222:    scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 1223:
    #####: 1224:    scanner_get_location (&start_location, context_p);
    #####: 1225:    lexer_next_token (context_p);
        -: 1226:
    #####: 1227:    uint8_t token_type = LEXER_EOS;
    #####: 1228:    bool has_context = false;
        -: 1229:
    #####: 1230:    if (context_p->token.type == LEXER_KEYW_VAR
    #####: 1231:        || context_p->token.type == LEXER_KEYW_LET
    #####: 1232:        || context_p->token.type == LEXER_KEYW_CONST)
        -: 1233:    {
    #####: 1234:      token_type = context_p->token.type;
    #####: 1235:      has_context = context_p->next_scanner_info_p->source_p == context_p->source_p;
    #####: 1236:      JERRY_ASSERT (!has_context || context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
    #####: 1237:      scanner_get_location (&start_location, context_p);
        -: 1238:
        -: 1239:      /* TODO: remove this after the pre-scanner supports strict mode detection. */
    #####: 1240:      if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 1241:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)
        -: 1242:      {
    #####: 1243:        scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1244:      }
        -: 1245:    }
    #####: 1246:    else if (context_p->token.type == LEXER_LITERAL && lexer_token_is_let (context_p))
        -: 1247:    {
    #####: 1248:      if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 1249:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)
        -: 1250:      {
    #####: 1251:        scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1252:      }
        -: 1253:      else
        -: 1254:      {
    #####: 1255:        token_type = LEXER_KEYW_LET;
    #####: 1256:        has_context = (context_p->next_scanner_info_p->source_p == context_p->source_p);
    #####: 1257:        scanner_get_location (&start_location, context_p);
        -: 1258:      }
        -: 1259:    }
        -: 1260:
    #####: 1261:    if (has_context)
        -: 1262:    {
    #####: 1263:      has_context = parser_push_block_context (context_p, true);
        -: 1264:    }
        -: 1265:
    #####: 1266:    scanner_set_location (context_p, &end_location);
        -: 1267:#else /* !JERRY_ESNEXT */
        -: 1268:    JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR_IN);
        -: 1269:
    #####: 1270:    bool is_for_in = true;
    #####: 1271:    scanner_get_location (&start_location, context_p);
        -: 1272:
    #####: 1273:    scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 1274:    scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 1275:#endif /* JERRY_ESNEXT */
        -: 1276:
        -: 1277:    /* The length of both 'in' and 'of' is two. */
    #####: 1278:    const uint8_t *source_end_p = context_p->source_p - 2;
        -: 1279:
    #####: 1280:    scanner_seek (context_p);
        -: 1281:
        -: 1282:#if JERRY_ESNEXT
    #####: 1283:    if (is_for_in && is_for_await)
        -: 1284:    {
    #####: 1285:      context_p->token.line = context_p->line;
    #####: 1286:      context_p->token.column = context_p->column - 2;
    #####: 1287:      parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_OF);
        -: 1288:    }
        -: 1289:#endif /* JERRY_ESNEXT */
        -: 1290:
    #####: 1291:    lexer_next_token (context_p);
    #####: 1292:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1293:
    #####: 1294:    if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 1295:    {
    #####: 1296:      parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1297:    }
        -: 1298:
        -: 1299:#ifndef JERRY_NDEBUG
    #####: 1300:    PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth,
        -: 1301:                           is_for_in ? PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION
        -: 1302:                                     : PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION);
        -: 1303:#endif /* !JERRY_NDEBUG */
        -: 1304:
    #####: 1305:    cbc_ext_opcode_t init_opcode = CBC_EXT_FOR_IN_INIT;
        -: 1306:
        -: 1307:#if JERRY_ESNEXT
    #####: 1308:    if (!is_for_in)
        -: 1309:    {
    #####: 1310:      init_opcode = is_for_await ? CBC_EXT_FOR_AWAIT_OF_INIT : CBC_EXT_FOR_OF_INIT;
        -: 1311:    }
        -: 1312:#endif /* JERRY_ESNEXT */
        -: 1313:
    #####: 1314:    parser_emit_cbc_ext_forward_branch (context_p, init_opcode, &for_in_of_statement.branch);
        -: 1315:
    #####: 1316:    JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
    #####: 1317:    for_in_of_statement.start_offset = context_p->byte_code_size;
        -: 1318:
        -: 1319:#if JERRY_ESNEXT
    #####: 1320:    if (has_context)
        -: 1321:    {
    #####: 1322:      parser_emit_cbc_ext (context_p, CBC_EXT_CLONE_CONTEXT);
        -: 1323:    }
        -: 1324:#endif /* JERRY_ESNEXT */
        -: 1325:
        -: 1326:    /* The expression parser must not read the 'in' or 'of' tokens. */
    #####: 1327:    scanner_get_location (&end_location, context_p);
    #####: 1328:    scanner_set_location (context_p, &start_location);
        -: 1329:
    #####: 1330:    const uint8_t *original_source_end_p = context_p->source_end_p;
    #####: 1331:    context_p->source_end_p = source_end_p;
    #####: 1332:    scanner_seek (context_p);
        -: 1333:
        -: 1334:#if JERRY_ESNEXT
    #####: 1335:    if (token_type == LEXER_EOS)
        -: 1336:    {
    #####: 1337:      lexer_next_token (context_p);
        -: 1338:
    #####: 1339:      if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 1340:      {
    #####: 1341:        token_type = context_p->token.type;
        -: 1342:      }
        -: 1343:    }
        -: 1344:#else /* !JERRY_ESNEXT */
    #####: 1345:    lexer_next_token (context_p);
        -: 1346:
    #####: 1347:    uint8_t token_type = context_p->token.type;
        -: 1348:#endif /* JERRY_ESNEXT */
        -: 1349:
    #####: 1350:    switch (token_type)
        -: 1351:    {
        -: 1352:#if JERRY_ESNEXT
    #####: 1353:      case LEXER_KEYW_LET:
        -: 1354:      case LEXER_KEYW_CONST:
        -: 1355:#endif /* JERRY_ESNEXT */
    #####: 1356:      case LEXER_KEYW_VAR:
        -: 1357:      {
        -: 1358:#if JERRY_ESNEXT
    #####: 1359:        if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))
        -: 1360:        {
    #####: 1361:          parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT
        -: 1362:                                                    : CBC_EXT_FOR_OF_GET_NEXT);
        -: 1363:
    #####: 1364:          parser_pattern_flags_t flags = (PARSER_PATTERN_BINDING | PARSER_PATTERN_TARGET_ON_STACK);
        -: 1365:
    #####: 1366:          if (context_p->next_scanner_info_p->source_p == (context_p->source_p + 1))
        -: 1367:          {
    #####: 1368:            if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 1369:            {
    #####: 1370:              scanner_release_next (context_p, sizeof (scanner_location_info_t));
        -: 1371:            }
        -: 1372:            else
        -: 1373:            {
    #####: 1374:              JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS);
    #####: 1375:              if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1376:              {
    #####: 1377:                flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1378:              }
        -: 1379:
    #####: 1380:              scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1381:            }
        -: 1382:          }
        -: 1383:
    #####: 1384:          if (token_type == LEXER_KEYW_LET)
        -: 1385:          {
    #####: 1386:            flags |= PARSER_PATTERN_LET;
        -: 1387:          }
    #####: 1388:          else if (token_type == LEXER_KEYW_CONST)
        -: 1389:          {
    #####: 1390:            flags |= PARSER_PATTERN_CONST;
        -: 1391:          }
        -: 1392:
    #####: 1393:          parser_parse_initializer_by_next_char (context_p, flags);
    #####: 1394:          break;
        -: 1395:        }
        -: 1396:#endif /* JERRY_ESNEXT */
        -: 1397:
    #####: 1398:        lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
        -: 1399:
        -: 1400:#if JERRY_ESNEXT
    #####: 1401:        if (context_p->token.keyword_type == LEXER_KEYW_LET
    #####: 1402:            && token_type != LEXER_KEYW_VAR)
        -: 1403:        {
    #####: 1404:          parser_raise_error (context_p, PARSER_ERR_LEXICAL_LET_BINDING);
        -: 1405:        }
        -: 1406:#endif /* JERRY_ESNEXT */
        -: 1407:
    #####: 1408:        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -: 1409:                      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1410:
    #####: 1411:        uint16_t literal_index = context_p->lit_object.index;
    #####: 1412:        lexer_next_token (context_p);
        -: 1413:
    #####: 1414:        if (context_p->token.type == LEXER_ASSIGN)
        -: 1415:        {
        -: 1416:#if JERRY_ESNEXT
    #####: 1417:          if (context_p->status_flags & PARSER_IS_STRICT)
        -: 1418:          {
    #####: 1419:            parser_raise_error (context_p, PARSER_ERR_FOR_IN_OF_DECLARATION);
        -: 1420:          }
        -: 1421:#endif /* JERRY_ESNEXT */
    #####: 1422:          parser_branch_t branch;
        -: 1423:
        -: 1424:          /* Initialiser is never executed. */
    #####: 1425:          parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &branch);
    #####: 1426:          lexer_next_token (context_p);
    #####: 1427:          parser_parse_expression_statement (context_p, PARSE_EXPR_NO_COMMA);
    #####: 1428:          parser_set_branch_to_current_position (context_p, &branch);
        -: 1429:        }
        -: 1430:
    #####: 1431:        parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT
        -: 1432:                                                  : CBC_EXT_FOR_OF_GET_NEXT);
        -: 1433:#if JERRY_ESNEXT
        -: 1434:#ifndef JERRY_NDEBUG
    #####: 1435:        if (literal_index < PARSER_REGISTER_START
    #####: 1436:            && has_context
    #####: 1437:            && !scanner_literal_is_created (context_p, literal_index))
        -: 1438:        {
    #####: 1439:          context_p->global_status_flags |= ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR;
        -: 1440:        }
        -: 1441:#endif /* !JERRY_NDEBUG */
        -: 1442:
    #####: 1443:        uint16_t opcode = (has_context ? CBC_ASSIGN_LET_CONST : CBC_ASSIGN_SET_IDENT);
    #####: 1444:        parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1445:#else /* !JERRY_ESNEXT */
    #####: 1446:        parser_emit_cbc_literal (context_p, CBC_ASSIGN_SET_IDENT, literal_index);
        -: 1447:#endif /* JERRY_ESNEXT */
    #####: 1448:        break;
        -: 1449:      }
        -: 1450:#if JERRY_ESNEXT
    #####: 1451:      case LEXER_LEFT_BRACE:
        -: 1452:      case LEXER_LEFT_SQUARE:
        -: 1453:      {
    #####: 1454:        if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 1455:            && context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS
    #####: 1456:            && (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_DESTRUCTURING_FOR))
        -: 1457:        {
    #####: 1458:          parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT
        -: 1459:                                                    : CBC_EXT_FOR_OF_GET_NEXT);
        -: 1460:
    #####: 1461:          uint32_t flags = PARSER_PATTERN_TARGET_ON_STACK;
        -: 1462:
    #####: 1463:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1464:          {
    #####: 1465:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1466:          }
        -: 1467:
    #####: 1468:          scanner_release_next (context_p, sizeof (scanner_info_t));
    #####: 1469:          parser_parse_initializer (context_p, flags);
        -: 1470:          /* Pop the value returned by GET_NEXT. */
    #####: 1471:          parser_emit_cbc (context_p, CBC_POP);
    #####: 1472:          break;
        -: 1473:        }
        -: 1474:        /* FALLTHRU */
        -: 1475:      }
        -: 1476:#endif /* JERRY_ESNEXT */
    #####: 1477:      default:
        -: 1478:      {
        -: 1479:        uint16_t opcode;
        -: 1480:
    #####: 1481:        parser_parse_expression (context_p, PARSE_EXPR_LEFT_HAND_SIDE);
        -: 1482:
    #####: 1483:        opcode = context_p->last_cbc_opcode;
        -: 1484:
        -: 1485:        /* The CBC_EXT_FOR_IN_CREATE_CONTEXT flushed the opcode combiner. */
    #####: 1486:        JERRY_ASSERT (opcode != CBC_PUSH_TWO_LITERALS
        -: 1487:                      && opcode != CBC_PUSH_THREE_LITERALS);
        -: 1488:
    #####: 1489:        opcode = parser_check_left_hand_side_expression (context_p, opcode);
        -: 1490:
    #####: 1491:        parser_emit_cbc_ext (context_p, is_for_in ? CBC_EXT_FOR_IN_GET_NEXT
        -: 1492:                                                  : CBC_EXT_FOR_OF_GET_NEXT);
    #####: 1493:        parser_flush_cbc (context_p);
        -: 1494:
    #####: 1495:        context_p->last_cbc_opcode = opcode;
    #####: 1496:        break;
        -: 1497:      }
        -: 1498:    }
        -: 1499:
    #####: 1500:    if (context_p->token.type != LEXER_EOS)
        -: 1501:    {
        -: 1502:#if JERRY_ESNEXT
    #####: 1503:      parser_raise_error (context_p, is_for_in ? PARSER_ERR_IN_EXPECTED : PARSER_ERR_OF_EXPECTED);
        -: 1504:#else /* !JERRY_ESNEXT */
    #####: 1505:      parser_raise_error (context_p, PARSER_ERR_IN_EXPECTED);
        -: 1506:#endif /* JERRY_ESNEXT */
        -: 1507:    }
        -: 1508:
    #####: 1509:    parser_flush_cbc (context_p);
    #####: 1510:    scanner_set_location (context_p, &end_location);
    #####: 1511:    context_p->source_end_p = original_source_end_p;
    #####: 1512:    lexer_next_token (context_p);
        -: 1513:
    #####: 1514:    loop.branch_list_p = NULL;
        -: 1515:
    #####: 1516:    parser_stack_push (context_p, &for_in_of_statement, sizeof (parser_for_in_of_statement_t));
    #####: 1517:    parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
        -: 1518:
    #####: 1519:    uint8_t for_type = PARSER_STATEMENT_FOR_IN;
        -: 1520:
        -: 1521:#if JERRY_ESNEXT
    #####: 1522:    if (!is_for_in)
        -: 1523:    {
    #####: 1524:      for_type = is_for_await ? PARSER_STATEMENT_FOR_AWAIT_OF : PARSER_STATEMENT_FOR_OF;
        -: 1525:    }
        -: 1526:#endif /* JERRY_ESNEXT */
        -: 1527:
    #####: 1528:    parser_stack_push_uint8 (context_p, for_type);
    #####: 1529:    parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 1530:    return;
        -: 1531:  }
        -: 1532:
        1: 1533:  lexer_next_token (context_p);
        -: 1534:
        1: 1535:  if (context_p->token.type != LEXER_SEMICOLON)
        -: 1536:  {
        -: 1537:#if JERRY_ESNEXT
        1: 1538:    const uint8_t *source_p = context_p->source_p;
        -: 1539:#endif /* JERRY_ESNEXT */
        -: 1540:
        1: 1541:    switch (context_p->token.type)
        -: 1542:    {
        -: 1543:#if JERRY_ESNEXT
    #####: 1544:      case LEXER_LITERAL:
        -: 1545:      {
    #####: 1546:        if (!lexer_token_is_let (context_p))
        -: 1547:        {
    #####: 1548:          parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 1549:          break;
        -: 1550:        }
        -: 1551:
    #####: 1552:        if (context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 1553:            && context_p->next_scanner_info_p->type != SCANNER_TYPE_BLOCK)
        -: 1554:        {
    #####: 1555:          if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)
        -: 1556:          {
    #####: 1557:            scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1558:          }
        -: 1559:
    #####: 1560:          parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 1561:          break;
        -: 1562:        }
        -: 1563:
    #####: 1564:        context_p->token.type = LEXER_KEYW_LET;
        -: 1565:        /* FALLTHRU */
        -: 1566:      }
    #####: 1567:      case LEXER_KEYW_LET:
        -: 1568:      case LEXER_KEYW_CONST:
        -: 1569:      {
    #####: 1570:        if (context_p->next_scanner_info_p->source_p == source_p)
        -: 1571:        {
    #####: 1572:          parser_push_block_context (context_p, true);
        -: 1573:        }
        -: 1574:        /* FALLTHRU */
        -: 1575:      }
        -: 1576:#endif /* JERRY_ESNEXT */
    #####: 1577:      case LEXER_KEYW_VAR:
        -: 1578:      {
        1: 1579:        parser_parse_var_statement (context_p);
        1: 1580:        break;
        -: 1581:      }
    #####: 1582:      default:
        -: 1583:      {
    #####: 1584:        parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 1585:        break;
        -: 1586:      }
        -: 1587:    }
        -: 1588:
        1: 1589:    if (context_p->token.type != LEXER_SEMICOLON)
        -: 1590:    {
    #####: 1591:      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 1592:    }
        -: 1593:  }
        -: 1594:
        -: 1595:#if JERRY_ESNEXT
        1: 1596:  if (is_for_await)
        -: 1597:  {
    #####: 1598:    parser_raise_error (context_p, PARSER_ERR_FOR_AWAIT_NO_OF);
        -: 1599:  }
        -: 1600:#endif /* JERRY_ESNEXT */
        -: 1601:
        1: 1602:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p != context_p->source_p
        -: 1603:                || context_p->next_scanner_info_p->type == SCANNER_TYPE_FOR);
        -: 1604:
        1: 1605:  if (context_p->next_scanner_info_p->source_p != context_p->source_p
        1: 1606:      || ((scanner_for_info_t *) context_p->next_scanner_info_p)->end_location.source_p == NULL)
        -: 1607:  {
    #####: 1608:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1609:    {
        -: 1610:      /* Even though the scanning is failed, there might be valid statements
        -: 1611:       * inside the for statement which depend on scanner info blocks. */
    #####: 1612:      scanner_release_next (context_p, sizeof (scanner_for_info_t));
        -: 1613:    }
        -: 1614:
        -: 1615:    /* The prescanner couldn't find the second semicolon or the closing paranthesis. */
    #####: 1616:    lexer_next_token (context_p);
    #####: 1617:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1618:
    #####: 1619:    if (context_p->token.type != LEXER_SEMICOLON)
        -: 1620:    {
    #####: 1621:      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 1622:    }
        -: 1623:
    #####: 1624:    lexer_next_token (context_p);
    #####: 1625:    parser_parse_expression_statement (context_p, PARSE_EXPR);
        -: 1626:
    #####: 1627:    JERRY_ASSERT (context_p->token.type != LEXER_RIGHT_PAREN);
    #####: 1628:    parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1629:  }
        -: 1630:
        1: 1631:  parser_for_statement_t for_statement;
        1: 1632:  scanner_for_info_t *for_info_p = (scanner_for_info_t *) context_p->next_scanner_info_p;
        -: 1633:
        1: 1634:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &for_statement.branch);
        -: 1635:
        1: 1636:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 1637:
        1: 1638:  for_statement.start_offset = context_p->byte_code_size;
        1: 1639:  scanner_get_location (&for_statement.condition_location, context_p);
        1: 1640:  for_statement.expression_location = for_info_p->expression_location;
        -: 1641:
        1: 1642:  scanner_set_location (context_p, &for_info_p->end_location);
        1: 1643:  scanner_release_next (context_p, sizeof (scanner_for_info_t));
        1: 1644:  scanner_seek (context_p);
        1: 1645:  lexer_next_token (context_p);
        -: 1646:
        1: 1647:  loop.branch_list_p = NULL;
        -: 1648:
        1: 1649:  parser_stack_push (context_p, &for_statement, sizeof (parser_for_statement_t));
        1: 1650:  parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
        1: 1651:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_FOR);
        1: 1652:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1653:} /* parser_parse_for_statement_start */
        -: 1654:
        -: 1655:/**
        -: 1656: * Parse for statement (ending part).
        -: 1657: */
        -: 1658:static void JERRY_ATTR_NOINLINE
        1: 1659:parser_parse_for_statement_end (parser_context_t *context_p) /**< context */
        -: 1660:{
        1: 1661:  parser_for_statement_t for_statement;
        1: 1662:  parser_loop_statement_t loop;
        -: 1663:  lexer_token_t current_token;
        1: 1664:  scanner_location_t location;
        -: 1665:  cbc_opcode_t opcode;
        -: 1666:
        1: 1667:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_FOR);
        -: 1668:
        1: 1669:  parser_stack_iterator_t iterator;
        1: 1670:  parser_stack_iterator_init (context_p, &iterator);
        -: 1671:
        1: 1672:  parser_stack_iterator_skip (&iterator, 1);
        1: 1673:  parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
        1: 1674:  parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));
        1: 1675:  parser_stack_iterator_read (&iterator, &for_statement, sizeof (parser_for_statement_t));
        -: 1676:
        -: 1677:#if JERRY_ESNEXT
        1: 1678:  bool has_block_context = false;
        1: 1679:  uint8_t next_statement_type;
        -: 1680:
        1: 1681:  parser_stack_iterator_skip (&iterator, sizeof (parser_for_statement_t));
        1: 1682:  parser_stack_iterator_read (&iterator, &next_statement_type, 1);
        -: 1683:
        1: 1684:  if (next_statement_type == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -: 1685:  {
    #####: 1686:    has_block_context = true;
        -: 1687:  }
        -: 1688:#endif
        -: 1689:
        1: 1690:  scanner_get_location (&location, context_p);
        1: 1691:  current_token = context_p->token;
        -: 1692:
        1: 1693:  scanner_set_location (context_p, &for_statement.expression_location);
        1: 1694:  scanner_seek (context_p);
        1: 1695:  lexer_next_token (context_p);
        -: 1696:
        1: 1697:  parser_set_continues_to_current_position (context_p, loop.branch_list_p);
        -: 1698:
        -: 1699:#if JERRY_ESNEXT
        1: 1700:  if (has_block_context)
        -: 1701:  {
    #####: 1702:    parser_emit_cbc_ext (context_p, CBC_EXT_CLONE_FULL_CONTEXT);
        -: 1703:  }
        -: 1704:#endif
        -: 1705:
        1: 1706:  if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 1707:  {
        1: 1708:    parser_parse_expression_statement (context_p, PARSE_EXPR);
        -: 1709:
        1: 1710:    if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 1711:    {
    #####: 1712:      parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 1713:    }
        -: 1714:  }
        -: 1715:
        1: 1716:  parser_set_branch_to_current_position (context_p, &for_statement.branch);
        -: 1717:
        1: 1718:  scanner_set_location (context_p, &for_statement.condition_location);
        1: 1719:  scanner_seek (context_p);
        1: 1720:  lexer_next_token (context_p);
        -: 1721:
        1: 1722:  if (context_p->token.type != LEXER_SEMICOLON)
        -: 1723:  {
        1: 1724:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1725:
        1: 1726:    if (context_p->token.type != LEXER_SEMICOLON)
        -: 1727:    {
    #####: 1728:      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 1729:    }
        -: 1730:
        1: 1731:    opcode = CBC_BRANCH_IF_TRUE_BACKWARD;
        1: 1732:    if (context_p->last_cbc_opcode == CBC_LOGICAL_NOT)
        -: 1733:    {
    #####: 1734:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1735:      opcode = CBC_BRANCH_IF_FALSE_BACKWARD;
        -: 1736:    }
        1: 1737:    else if (context_p->last_cbc_opcode == CBC_PUSH_TRUE)
        -: 1738:    {
    #####: 1739:      context_p->last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
    #####: 1740:      opcode = CBC_JUMP_BACKWARD;
        -: 1741:    }
        -: 1742:  }
        -: 1743:  else
        -: 1744:  {
    #####: 1745:    opcode = CBC_JUMP_BACKWARD;
        -: 1746:  }
        -: 1747:
        1: 1748:  parser_stack_pop (context_p, NULL, 1 + sizeof (parser_loop_statement_t) + sizeof (parser_for_statement_t));
        1: 1749:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1750:
        1: 1751:  parser_emit_cbc_backward_branch (context_p, (uint16_t) opcode, for_statement.start_offset);
        1: 1752:  parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
        -: 1753:
        -: 1754:#if JERRY_ESNEXT
        1: 1755:  if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
        1: 1756:      || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -: 1757:  {
    #####: 1758:    parser_pop_block_context (context_p);
        -: 1759:  }
        -: 1760:#endif
        -: 1761:
        -: 1762:  /* Calling scanner_seek is unnecessary because all
        -: 1763:   * info blocks inside the for statement should be processed. */
        1: 1764:  scanner_set_location (context_p, &location);
        1: 1765:  context_p->token = current_token;
        1: 1766:} /* parser_parse_for_statement_end */
        -: 1767:
        -: 1768:/**
        -: 1769: * Parse switch statement (starting part).
        -: 1770: */
        -: 1771:static void JERRY_ATTR_NOINLINE
    #####: 1772:parser_parse_switch_statement_start (parser_context_t *context_p) /**< context */
        -: 1773:{
    #####: 1774:  parser_switch_statement_t switch_statement;
    #####: 1775:  parser_loop_statement_t loop;
    #####: 1776:  parser_stack_iterator_t iterator;
    #####: 1777:  scanner_location_t start_location;
        -: 1778:  bool switch_case_was_found;
        -: 1779:  bool default_case_was_found;
    #####: 1780:  parser_branch_node_t *case_branches_p = NULL;
        -: 1781:
    #####: 1782:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_SWITCH);
        -: 1783:
    #####: 1784:  parser_parse_enclosed_expr (context_p);
        -: 1785:
    #####: 1786:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 1787:  {
    #####: 1788:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 1789:  }
        -: 1790:
        -: 1791:#if JERRY_ESNEXT
    #####: 1792:  if (context_p->next_scanner_info_p->source_p == context_p->source_p - 1)
        -: 1793:  {
    #####: 1794:    parser_push_block_context (context_p, true);
        -: 1795:  }
        -: 1796:#endif /* JERRY_ESNEXT */
        -: 1797:
    #####: 1798:  JERRY_ASSERT (context_p->next_scanner_info_p->source_p == context_p->source_p
        -: 1799:                && context_p->next_scanner_info_p->type == SCANNER_TYPE_SWITCH);
        -: 1800:
    #####: 1801:  scanner_case_info_t *case_info_p = ((scanner_switch_info_t *) context_p->next_scanner_info_p)->case_p;
    #####: 1802:  scanner_set_active (context_p);
        -: 1803:
    #####: 1804:  if (case_info_p == NULL)
        -: 1805:  {
    #####: 1806:    lexer_next_token (context_p);
        -: 1807:
    #####: 1808:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 1809:    {
    #####: 1810:      scanner_release_active (context_p, sizeof (scanner_switch_info_t));
        -: 1811:
    #####: 1812:      parser_emit_cbc (context_p, CBC_POP);
    #####: 1813:      parser_flush_cbc (context_p);
        -: 1814:
    #####: 1815:      parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);
    #####: 1816:      parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 1817:      return;
        -: 1818:    }
        -: 1819:
    #####: 1820:    parser_raise_error (context_p, PARSER_ERR_INVALID_SWITCH);
        -: 1821:  }
        -: 1822:
    #####: 1823:  scanner_get_location (&start_location, context_p);
        -: 1824:
        -: 1825:  /* The reason of using an iterator is error management. If an error
        -: 1826:   * occures, parser_free_jumps() free all data. However, the branches
        -: 1827:   * created by parser_emit_cbc_forward_branch_item() would not be freed.
        -: 1828:   * To free these branches, the current switch data is always stored
        -: 1829:   * on the stack. If any change happens, this data is updated. Updates
        -: 1830:   * are done using the iterator. */
        -: 1831:
    #####: 1832:  switch_statement.branch_list_p = NULL;
    #####: 1833:  loop.branch_list_p = NULL;
        -: 1834:
    #####: 1835:  parser_stack_push (context_p, &switch_statement, sizeof (parser_switch_statement_t));
    #####: 1836:  parser_stack_iterator_init (context_p, &iterator);
    #####: 1837:  parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 1838:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_SWITCH);
    #####: 1839:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 1840:
    #####: 1841:  switch_case_was_found = false;
    #####: 1842:  default_case_was_found = false;
        -: 1843:
        -: 1844:  do
        -: 1845:  {
    #####: 1846:    scanner_set_location (context_p, &case_info_p->location);
    #####: 1847:    scanner_seek (context_p);
    #####: 1848:    case_info_p = case_info_p->next_p;
        -: 1849:
        -: 1850:    /* The last letter of case and default is 'e' and 't' respectively.  */
    #####: 1851:    JERRY_ASSERT (context_p->source_p[-1] == LIT_CHAR_LOWERCASE_E
        -: 1852:                  || context_p->source_p[-1] == LIT_CHAR_LOWERCASE_T);
        -: 1853:
    #####: 1854:    bool is_default = context_p->source_p[-1] == LIT_CHAR_LOWERCASE_T;
    #####: 1855:    lexer_next_token (context_p);
        -: 1856:
    #####: 1857:    if (is_default)
        -: 1858:    {
    #####: 1859:      if (default_case_was_found)
        -: 1860:      {
    #####: 1861:        parser_raise_error (context_p, PARSER_ERR_MULTIPLE_DEFAULTS_NOT_ALLOWED);
        -: 1862:      }
        -: 1863:
    #####: 1864:      if (context_p->token.type != LEXER_COLON)
        -: 1865:      {
    #####: 1866:        parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1867:      }
        -: 1868:
    #####: 1869:      default_case_was_found = true;
    #####: 1870:      continue;
        -: 1871:    }
        -: 1872:
    #####: 1873:    switch_case_was_found = true;
        -: 1874:
        -: 1875:#if JERRY_LINE_INFO
    #####: 1876:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 1877:#endif /* JERRY_LINE_INFO */
        -: 1878:
    #####: 1879:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 1880:
    #####: 1881:    if (context_p->token.type != LEXER_COLON)
        -: 1882:    {
    #####: 1883:      parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 1884:    }
        -: 1885:
    #####: 1886:    uint16_t opcode = CBC_BRANCH_IF_STRICT_EQUAL;
        -: 1887:
    #####: 1888:    if (case_info_p == NULL
    #####: 1889:        || (case_info_p->next_p == NULL && case_info_p->location.source_p[-1] == LIT_CHAR_LOWERCASE_T))
        -: 1890:    {
        -: 1891:      /* There are no more 'case' statements in the switch. */
    #####: 1892:      parser_emit_cbc (context_p, CBC_STRICT_EQUAL);
    #####: 1893:      opcode = CBC_BRANCH_IF_TRUE_FORWARD;
        -: 1894:    }
        -: 1895:
    #####: 1896:    parser_branch_node_t *new_case_p = parser_emit_cbc_forward_branch_item (context_p, opcode, NULL);
        -: 1897:
    #####: 1898:    if (case_branches_p == NULL)
        -: 1899:    {
    #####: 1900:      switch_statement.branch_list_p = new_case_p;
    #####: 1901:      parser_stack_iterator_write (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 1902:    }
        -: 1903:    else
        -: 1904:    {
    #####: 1905:      case_branches_p->next_p = new_case_p;
        -: 1906:    }
        -: 1907:
    #####: 1908:    case_branches_p = new_case_p;
        -: 1909:  }
    #####: 1910:  while (case_info_p != NULL);
        -: 1911:
    #####: 1912:  JERRY_ASSERT (switch_case_was_found || default_case_was_found);
        -: 1913:
    #####: 1914:  if (!switch_case_was_found)
        -: 1915:  {
        -: 1916:    /* There was no case statement, so the expression result
        -: 1917:     * of the switch must be popped from the stack */
    #####: 1918:    parser_emit_cbc (context_p, CBC_POP);
        -: 1919:  }
        -: 1920:
    #####: 1921:  parser_emit_cbc_forward_branch (context_p, CBC_JUMP_FORWARD, &switch_statement.default_branch);
    #####: 1922:  parser_stack_iterator_write (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 1923:
    #####: 1924:  if (!default_case_was_found)
        -: 1925:  {
    #####: 1926:    parser_stack_change_last_uint8 (context_p, PARSER_STATEMENT_SWITCH_NO_DEFAULT);
        -: 1927:  }
        -: 1928:
    #####: 1929:  scanner_release_switch_cases (((scanner_switch_info_t *) context_p->active_scanner_info_p)->case_p);
    #####: 1930:  scanner_release_active (context_p, sizeof (scanner_switch_info_t));
        -: 1931:
    #####: 1932:  scanner_set_location (context_p, &start_location);
    #####: 1933:  scanner_seek (context_p);
    #####: 1934:  lexer_next_token (context_p);
        -: 1935:} /* parser_parse_switch_statement_start */
        -: 1936:
        -: 1937:/**
        -: 1938: * Parse try statement (ending part).
        -: 1939: */
        -: 1940:static void
    #####: 1941:parser_parse_try_statement_end (parser_context_t *context_p) /**< context */
        -: 1942:{
    #####: 1943:  parser_try_statement_t try_statement;
    #####: 1944:  parser_stack_iterator_t iterator;
        -: 1945:
    #####: 1946:  JERRY_ASSERT (context_p->stack_top_uint8 == PARSER_STATEMENT_TRY);
        -: 1947:
    #####: 1948:  parser_stack_iterator_init (context_p, &iterator);
    #####: 1949:  parser_stack_iterator_skip (&iterator, 1);
    #####: 1950:  parser_stack_iterator_read (&iterator, &try_statement, sizeof (parser_try_statement_t));
        -: 1951:
        -: 1952:#if JERRY_ESNEXT
    #####: 1953:  context_p->scope_stack_top = try_statement.scope_stack_top;
    #####: 1954:  context_p->scope_stack_reg_top = try_statement.scope_stack_reg_top;
        -: 1955:#endif /* JERRY_ESNEXT */
        -: 1956:
    #####: 1957:  lexer_next_token (context_p);
        -: 1958:
    #####: 1959:  if (try_statement.type == parser_finally_block)
        -: 1960:  {
    #####: 1961:    parser_flush_cbc (context_p);
    #####: 1962:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
        -: 1963:#ifndef JERRY_NDEBUG
    #####: 1964:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_FINALLY_CONTEXT_STACK_ALLOCATION);
        -: 1965:#endif /* !JERRY_NDEBUG */
        -: 1966:
    #####: 1967:    parser_emit_cbc (context_p, CBC_CONTEXT_END);
    #####: 1968:    parser_set_branch_to_current_position (context_p, &try_statement.branch);
        -: 1969:  }
        -: 1970:  else
        -: 1971:  {
    #####: 1972:    parser_set_branch_to_current_position (context_p, &try_statement.branch);
        -: 1973:
    #####: 1974:    if (try_statement.type == parser_catch_block)
        -: 1975:    {
        -: 1976:#if !JERRY_ESNEXT
    #####: 1977:      context_p->scope_stack_top = try_statement.scope_stack_top;
    #####: 1978:      context_p->scope_stack_reg_top = try_statement.scope_stack_reg_top;
        -: 1979:#endif /* !JERRY_ESNEXT */
        -: 1980:
    #####: 1981:      if (context_p->token.type != LEXER_KEYW_FINALLY)
        -: 1982:      {
    #####: 1983:        parser_flush_cbc (context_p);
    #####: 1984:        PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -: 1985:#ifndef JERRY_NDEBUG
    #####: 1986:        PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -: 1987:#endif /* !JERRY_NDEBUG */
        -: 1988:
    #####: 1989:        parser_emit_cbc (context_p, CBC_CONTEXT_END);
    #####: 1990:        parser_flush_cbc (context_p);
        -: 1991:
    #####: 1992:        try_statement.type = parser_finally_block;
        -: 1993:      }
        -: 1994:    }
        -: 1995:    else
        -: 1996:    {
    #####: 1997:      JERRY_ASSERT (try_statement.type == parser_try_block);
        -: 1998:
    #####: 1999:      if (context_p->token.type != LEXER_KEYW_CATCH
    #####: 2000:          && context_p->token.type != LEXER_KEYW_FINALLY)
        -: 2001:      {
    #####: 2002:        parser_raise_error (context_p, PARSER_ERR_CATCH_FINALLY_EXPECTED);
        -: 2003:      }
        -: 2004:    }
        -: 2005:  }
        -: 2006:
    #####: 2007:  if (try_statement.type == parser_finally_block)
        -: 2008:  {
    #####: 2009:    parser_stack_pop (context_p, NULL, (uint32_t) (sizeof (parser_try_statement_t) + 1));
    #####: 2010:    parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 2011:    return;
        -: 2012:  }
        -: 2013:
    #####: 2014:  if (context_p->token.type == LEXER_KEYW_CATCH)
        -: 2015:  {
    #####: 2016:    lexer_next_token (context_p);
        -: 2017:
    #####: 2018:    try_statement.type = parser_catch_block;
    #####: 2019:    parser_emit_cbc_ext_forward_branch (context_p,
        -: 2020:                                        CBC_EXT_CATCH,
        -: 2021:                                        &try_statement.branch);
        -: 2022:
    #####: 2023:    try_statement.scope_stack_top = context_p->scope_stack_top;
    #####: 2024:    try_statement.scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2025:
        -: 2026:#ifndef JERRY_NDEBUG
    #####: 2027:    bool block_found = false;
        -: 2028:#endif /* !JERRY_NDEBUG */
        -: 2029:
    #####: 2030:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2031:    {
    #####: 2032:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        -: 2033:#ifndef JERRY_NDEBUG
    #####: 2034:      block_found = true;
        -: 2035:#endif /* !JERRY_NDEBUG */
        -: 2036:
    #####: 2037:      if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))
        -: 2038:      {
    #####: 2039:        parser_emit_cbc_ext (context_p, CBC_EXT_TRY_CREATE_ENV);
        -: 2040:      }
        -: 2041:
    #####: 2042:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        -: 2043:    }
        -: 2044:
    #####: 2045:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2046:    {
        -: 2047:#if JERRY_ESNEXT
    #####: 2048:      if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_SQUARE, LIT_CHAR_LEFT_BRACE))
        -: 2049:      {
    #####: 2050:        parser_pattern_flags_t flags = (PARSER_PATTERN_BINDING
        -: 2051:                                        | PARSER_PATTERN_TARGET_ON_STACK
        -: 2052:                                        | PARSER_PATTERN_LET);
        -: 2053:
    #####: 2054:        parser_parse_initializer_by_next_char (context_p, flags);
        -: 2055:      }
        -: 2056:      else
        -: 2057:      {
        -: 2058:#endif /* JERRY_ESNEXT */
    #####: 2059:        lexer_expect_identifier (context_p, LEXER_IDENT_LITERAL);
    #####: 2060:        JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
        -: 2061:                      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 2062:
        -: 2063:#if JERRY_ESNEXT
    #####: 2064:        uint16_t literal_index = context_p->lit_object.index;
    #####: 2065:        parser_emit_cbc_literal (context_p,
    #####: 2066:                                 (literal_index >= PARSER_REGISTER_START) ? CBC_ASSIGN_SET_IDENT : CBC_ASSIGN_LET_CONST,
        -: 2067:                                 literal_index);
        -: 2068:#else /* !JERRY_ESNEXT */
    #####: 2069:        parser_emit_cbc_literal (context_p, CBC_ASSIGN_SET_IDENT, context_p->lit_object.index);
        -: 2070:#endif /* JERRY_ESNEXT */
        -: 2071:
    #####: 2072:        lexer_next_token (context_p);
        -: 2073:
        -: 2074:#ifndef JERRY_NDEBUG
    #####: 2075:        JERRY_ASSERT (block_found);
        -: 2076:#endif /* !JERRY_NDEBUG */
        -: 2077:#if JERRY_ESNEXT
        -: 2078:      }
        -: 2079:#endif /* JERRY_ESNEXT */
        -: 2080:
    #####: 2081:      if (context_p->token.type != LEXER_RIGHT_PAREN)
        -: 2082:      {
    #####: 2083:        parser_raise_error (context_p, PARSER_ERR_RIGHT_PAREN_EXPECTED);
        -: 2084:      }
        -: 2085:
    #####: 2086:      lexer_next_token (context_p);
        -: 2087:
    #####: 2088:      if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2089:      {
    #####: 2090:        parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 2091:      }
        -: 2092:    }
        -: 2093:#if JERRY_ESNEXT
    #####: 2094:    else if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2095:    {
    #####: 2096:      parser_emit_cbc (context_p, CBC_POP);
        -: 2097:    }
        -: 2098:#endif /* JERRY_ESNEXT */
        -: 2099:    else
        -: 2100:    {
    #####: 2101:      parser_raise_error (context_p, PARSER_ERR_LEFT_PAREN_EXPECTED);
        -: 2102:    }
        -: 2103:
    #####: 2104:    parser_flush_cbc (context_p);
        -: 2105:  }
        -: 2106:  else
        -: 2107:  {
    #####: 2108:    JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FINALLY);
        -: 2109:
    #####: 2110:    lexer_next_token (context_p);
        -: 2111:
    #####: 2112:    if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2113:    {
    #####: 2114:      parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 2115:    }
        -: 2116:
        -: 2117:#ifndef JERRY_NDEBUG
    #####: 2118:    PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_FINALLY_CONTEXT_EXTRA_STACK_ALLOCATION);
        -: 2119:#endif /* !JERRY_NDEBUG */
        -: 2120:
    #####: 2121:    try_statement.type = parser_finally_block;
    #####: 2122:    parser_emit_cbc_ext_forward_branch (context_p,
        -: 2123:                                        CBC_EXT_FINALLY,
        -: 2124:                                        &try_statement.branch);
        -: 2125:
        -: 2126:#if JERRY_ESNEXT
    #####: 2127:    if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2128:    {
    #####: 2129:      JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        -: 2130:
    #####: 2131:      if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))
        -: 2132:      {
    #####: 2133:        parser_emit_cbc_ext (context_p, CBC_EXT_TRY_CREATE_ENV);
        -: 2134:      }
        -: 2135:
    #####: 2136:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        -: 2137:    }
        -: 2138:#endif /* JERRY_ESNEXT */
        -: 2139:  }
        -: 2140:
    #####: 2141:  lexer_next_token (context_p);
    #####: 2142:  parser_stack_iterator_write (&iterator, &try_statement, sizeof (parser_try_statement_t));
        -: 2143:} /* parser_parse_try_statement_end */
        -: 2144:
        -: 2145:/**
        -: 2146: * Parse default statement.
        -: 2147: */
        -: 2148:static void
    #####: 2149:parser_parse_default_statement (parser_context_t *context_p) /**< context */
        -: 2150:{
    #####: 2151:  parser_stack_iterator_t iterator;
    #####: 2152:  parser_switch_statement_t switch_statement;
        -: 2153:
    #####: 2154:  if (context_p->stack_top_uint8 != PARSER_STATEMENT_SWITCH
    #####: 2155:      && context_p->stack_top_uint8 != PARSER_STATEMENT_SWITCH_NO_DEFAULT)
        -: 2156:  {
    #####: 2157:    parser_raise_error (context_p, PARSER_ERR_DEFAULT_NOT_IN_SWITCH);
        -: 2158:  }
        -: 2159:
    #####: 2160:  lexer_next_token (context_p);
        -: 2161:  /* Already checked in parser_parse_switch_statement_start. */
    #####: 2162:  JERRY_ASSERT (context_p->token.type == LEXER_COLON);
    #####: 2163:  lexer_next_token (context_p);
        -: 2164:
    #####: 2165:  parser_stack_iterator_init (context_p, &iterator);
    #####: 2166:  parser_stack_iterator_skip (&iterator, 1 + sizeof (parser_loop_statement_t));
    #####: 2167:  parser_stack_iterator_read (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 2168:
    #####: 2169:  parser_set_branch_to_current_position (context_p, &switch_statement.default_branch);
    #####: 2170:} /* parser_parse_default_statement */
        -: 2171:
        -: 2172:/**
        -: 2173: * Parse case statement.
        -: 2174: */
        -: 2175:static void
    #####: 2176:parser_parse_case_statement (parser_context_t *context_p) /**< context */
        -: 2177:{
    #####: 2178:  parser_stack_iterator_t iterator;
    #####: 2179:  parser_switch_statement_t switch_statement;
        -: 2180:  parser_branch_node_t *branch_p;
        -: 2181:
    #####: 2182:  if (context_p->stack_top_uint8 != PARSER_STATEMENT_SWITCH
    #####: 2183:      && context_p->stack_top_uint8 != PARSER_STATEMENT_SWITCH_NO_DEFAULT)
        -: 2184:  {
    #####: 2185:    parser_raise_error (context_p, PARSER_ERR_CASE_NOT_IN_SWITCH);
        -: 2186:  }
        -: 2187:
    #####: 2188:  if (context_p->next_scanner_info_p->source_p != context_p->source_p)
        -: 2189:  {
    #####: 2190:    lexer_next_token (context_p);
        -: 2191:
    #####: 2192:    parser_parse_expression (context_p, PARSE_EXPR);
        -: 2193:
    #####: 2194:    JERRY_ASSERT (context_p->token.type != LEXER_COLON);
    #####: 2195:    parser_raise_error (context_p, PARSER_ERR_COLON_EXPECTED);
        -: 2196:  }
        -: 2197:
    #####: 2198:  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_CASE);
        -: 2199:
    #####: 2200:  scanner_set_location (context_p, &((scanner_location_info_t *) context_p->next_scanner_info_p)->location);
    #####: 2201:  scanner_release_next (context_p, sizeof (scanner_location_info_t));
    #####: 2202:  scanner_seek (context_p);
    #####: 2203:  lexer_next_token (context_p);
        -: 2204:
    #####: 2205:  parser_stack_iterator_init (context_p, &iterator);
    #####: 2206:  parser_stack_iterator_skip (&iterator, 1 + sizeof (parser_loop_statement_t));
    #####: 2207:  parser_stack_iterator_read (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 2208:
        -: 2209:  /* Free memory after the case statement is found. */
        -: 2210:
    #####: 2211:  branch_p = switch_statement.branch_list_p;
    #####: 2212:  JERRY_ASSERT (branch_p != NULL);
    #####: 2213:  switch_statement.branch_list_p = branch_p->next_p;
    #####: 2214:  parser_stack_iterator_write (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
        -: 2215:
    #####: 2216:  parser_set_branch_to_current_position (context_p, &branch_p->branch);
    #####: 2217:  parser_free (branch_p, sizeof (parser_branch_node_t));
    #####: 2218:} /* parser_parse_case_statement */
        -: 2219:
        -: 2220:/**
        -: 2221: * Parse break statement.
        -: 2222: */
        -: 2223:static void
    #####: 2224:parser_parse_break_statement (parser_context_t *context_p) /**< context */
        -: 2225:{
    #####: 2226:  parser_stack_iterator_t iterator;
    #####: 2227:  cbc_opcode_t opcode = CBC_JUMP_FORWARD;
        -: 2228:
    #####: 2229:  lexer_next_token (context_p);
    #####: 2230:  parser_stack_iterator_init (context_p, &iterator);
        -: 2231:
    #####: 2232:  if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####: 2233:      && context_p->token.type == LEXER_LITERAL
    #####: 2234:      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 2235:  {
        -: 2236:    /* The label with the same name is searched on the stack. */
        -: 2237:    while (true)
    #####: 2238:    {
    #####: 2239:      uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 2240:      if (type == PARSER_STATEMENT_START)
        -: 2241:      {
    #####: 2242:        parser_raise_error (context_p, PARSER_ERR_INVALID_BREAK_LABEL);
        -: 2243:      }
        -: 2244:
    #####: 2245:      if (parser_statement_flags[type] & PARSER_STATM_CONTEXT_BREAK)
        -: 2246:      {
    #####: 2247:        opcode = CBC_JUMP_FORWARD_EXIT_CONTEXT;
        -: 2248:      }
        -: 2249:
    #####: 2250:      if (type == PARSER_STATEMENT_LABEL)
        -: 2251:      {
    #####: 2252:        parser_label_statement_t label_statement;
        -: 2253:
    #####: 2254:        parser_stack_iterator_skip (&iterator, 1);
    #####: 2255:        parser_stack_iterator_read (&iterator, &label_statement, sizeof (parser_label_statement_t));
        -: 2256:
    #####: 2257:        if (lexer_current_is_literal (context_p, &label_statement.label_ident))
        -: 2258:        {
    #####: 2259:          label_statement.break_list_p = parser_emit_cbc_forward_branch_item (context_p,
    #####: 2260:                                                                              (uint16_t) opcode,
        -: 2261:                                                                              label_statement.break_list_p);
    #####: 2262:          parser_stack_iterator_write (&iterator, &label_statement, sizeof (parser_label_statement_t));
    #####: 2263:          lexer_next_token (context_p);
    #####: 2264:          return;
        -: 2265:        }
    #####: 2266:        parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));
        -: 2267:      }
        -: 2268:      else
        -: 2269:      {
    #####: 2270:        parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2271:      }
        -: 2272:    }
        -: 2273:  }
        -: 2274:
        -: 2275:  /* The first switch or loop statement is searched. */
        -: 2276:  while (true)
    #####: 2277:  {
    #####: 2278:    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 2279:    if (type == PARSER_STATEMENT_START)
        -: 2280:    {
    #####: 2281:      parser_raise_error (context_p, PARSER_ERR_INVALID_BREAK);
        -: 2282:    }
        -: 2283:
    #####: 2284:    if (parser_statement_flags[type] & PARSER_STATM_CONTEXT_BREAK)
        -: 2285:    {
    #####: 2286:      opcode = CBC_JUMP_FORWARD_EXIT_CONTEXT;
        -: 2287:    }
        -: 2288:
    #####: 2289:    if (parser_statement_flags[type] & PARSER_STATM_BREAK_TARGET)
        -: 2290:    {
    #####: 2291:      parser_loop_statement_t loop;
        -: 2292:
    #####: 2293:      parser_stack_iterator_skip (&iterator, 1);
    #####: 2294:      parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2295:      loop.branch_list_p = parser_emit_cbc_forward_branch_item (context_p,
    #####: 2296:                                                                (uint16_t) opcode,
        -: 2297:                                                                loop.branch_list_p);
    #####: 2298:      parser_stack_iterator_write (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2299:      return;
        -: 2300:    }
        -: 2301:
    #####: 2302:    parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2303:  }
        -: 2304:} /* parser_parse_break_statement */
        -: 2305:
        -: 2306:/**
        -: 2307: * Parse continue statement.
        -: 2308: */
        -: 2309:static void
    #####: 2310:parser_parse_continue_statement (parser_context_t *context_p) /**< context */
        -: 2311:{
    #####: 2312:  parser_stack_iterator_t iterator;
    #####: 2313:  cbc_opcode_t opcode = CBC_JUMP_FORWARD;
        -: 2314:
    #####: 2315:  lexer_next_token (context_p);
    #####: 2316:  parser_stack_iterator_init (context_p, &iterator);
        -: 2317:
    #####: 2318:  if (!(context_p->token.flags & LEXER_WAS_NEWLINE)
    #####: 2319:      && context_p->token.type == LEXER_LITERAL
    #####: 2320:      && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 2321:  {
    #####: 2322:    parser_stack_iterator_t loop_iterator;
        -: 2323:
    #####: 2324:    loop_iterator.current_p = NULL;
        -: 2325:
        -: 2326:    /* The label with the same name is searched on the stack. */
        -: 2327:    while (true)
    #####: 2328:    {
    #####: 2329:      uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
        -: 2330:
    #####: 2331:      if (type == PARSER_STATEMENT_START)
        -: 2332:      {
    #####: 2333:        parser_raise_error (context_p, PARSER_ERR_INVALID_CONTINUE_LABEL);
        -: 2334:      }
        -: 2335:
        -: 2336:      /* Only those labels are checked, whose are label of a loop. */
    #####: 2337:      if (loop_iterator.current_p != NULL && type == PARSER_STATEMENT_LABEL)
        -: 2338:      {
    #####: 2339:        parser_label_statement_t label_statement;
        -: 2340:
    #####: 2341:        parser_stack_iterator_skip (&iterator, 1);
    #####: 2342:        parser_stack_iterator_read (&iterator, &label_statement, sizeof (parser_label_statement_t));
        -: 2343:
    #####: 2344:        if (lexer_current_is_literal (context_p, &label_statement.label_ident))
        -: 2345:        {
    #####: 2346:          parser_loop_statement_t loop;
        -: 2347:
    #####: 2348:          parser_stack_iterator_skip (&loop_iterator, 1);
    #####: 2349:          parser_stack_iterator_read (&loop_iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2350:          loop.branch_list_p = parser_emit_cbc_forward_branch_item (context_p,
    #####: 2351:                                                                    (uint16_t) opcode,
        -: 2352:                                                                    loop.branch_list_p);
    #####: 2353:          loop.branch_list_p->branch.offset |= CBC_HIGHEST_BIT_MASK;
    #####: 2354:          parser_stack_iterator_write (&loop_iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2355:          lexer_next_token (context_p);
    #####: 2356:          return;
        -: 2357:        }
    #####: 2358:        parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));
    #####: 2359:        continue;
        -: 2360:      }
        -: 2361:
    #####: 2362:      if (parser_statement_flags[type] & PARSER_STATM_CONTEXT_BREAK)
        -: 2363:      {
    #####: 2364:        opcode = CBC_JUMP_FORWARD_EXIT_CONTEXT;
        -: 2365:      }
        -: 2366:
        -: 2367:#if JERRY_ESNEXT
    #####: 2368:      const bool is_private_scope = (type == PARSER_STATEMENT_PRIVATE_SCOPE
    #####: 2369:                                     || type == PARSER_STATEMENT_PRIVATE_CONTEXT);
        -: 2370:#else /* !JERRY_ESNEXT */
    #####: 2371:      const bool is_private_scope = false;
        -: 2372:#endif /* !JERRY_ESNEXT */
        -: 2373:
    #####: 2374:      if (parser_statement_flags[type] & PARSER_STATM_CONTINUE_TARGET)
        -: 2375:      {
    #####: 2376:        loop_iterator = iterator;
        -: 2377:      }
    #####: 2378:      else if (!is_private_scope)
        -: 2379:      {
    #####: 2380:        loop_iterator.current_p = NULL;
        -: 2381:      }
        -: 2382:
    #####: 2383:      parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2384:    }
        -: 2385:  }
        -: 2386:
        -: 2387:  /* The first loop statement is searched. */
        -: 2388:  while (true)
    #####: 2389:  {
    #####: 2390:    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 2391:    if (type == PARSER_STATEMENT_START)
        -: 2392:    {
    #####: 2393:      parser_raise_error (context_p, PARSER_ERR_INVALID_CONTINUE);
        -: 2394:    }
        -: 2395:
    #####: 2396:    if (parser_statement_flags[type] & PARSER_STATM_CONTINUE_TARGET)
        -: 2397:    {
    #####: 2398:      parser_loop_statement_t loop;
        -: 2399:
    #####: 2400:      parser_stack_iterator_skip (&iterator, 1);
    #####: 2401:      parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2402:      loop.branch_list_p = parser_emit_cbc_forward_branch_item (context_p,
    #####: 2403:                                                                (uint16_t) opcode,
        -: 2404:                                                                loop.branch_list_p);
    #####: 2405:      loop.branch_list_p->branch.offset |= CBC_HIGHEST_BIT_MASK;
    #####: 2406:      parser_stack_iterator_write (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 2407:      return;
        -: 2408:    }
        -: 2409:
    #####: 2410:    if (parser_statement_flags[type] & PARSER_STATM_CONTEXT_BREAK)
        -: 2411:    {
    #####: 2412:      opcode = CBC_JUMP_FORWARD_EXIT_CONTEXT;
        -: 2413:    }
        -: 2414:
    #####: 2415:    parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2416:  }
        -: 2417:} /* parser_parse_continue_statement */
        -: 2418:
        -: 2419:#if JERRY_MODULE_SYSTEM
        -: 2420:/**
        -: 2421: * Parse import statement.
        -: 2422: * Note: See 15.2.2
        -: 2423: */
        -: 2424:static void
    #####: 2425:parser_parse_import_statement (parser_context_t *context_p) /**< parser context */
        -: 2426:{
    #####: 2427:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_IMPORT);
    #####: 2428:  JERRY_ASSERT (context_p->module_names_p == NULL);
        -: 2429:
    #####: 2430:  if (lexer_check_next_characters (context_p, LIT_CHAR_LEFT_PAREN, LIT_CHAR_DOT))
        -: 2431:  {
    #####: 2432:    if (context_p->status_flags & PARSER_IS_FUNCTION)
        -: 2433:    {
    #####: 2434:      parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 2435:      return;
        -: 2436:    }
        -: 2437:
    #####: 2438:    parser_parse_block_expression (context_p, PARSE_EXPR);
    #####: 2439:    return;
        -: 2440:  }
        -: 2441:
    #####: 2442:  parser_module_check_request_place (context_p);
    #####: 2443:  lexer_next_token (context_p);
        -: 2444:
        -: 2445:  /* Check for a ModuleSpecifier*/
    #####: 2446:  if (context_p->token.type != LEXER_LITERAL
    #####: 2447:      || context_p->token.lit_location.type != LEXER_STRING_LITERAL)
        -: 2448:  {
    #####: 2449:    if (!(context_p->token.type == LEXER_LEFT_BRACE
    #####: 2450:          || context_p->token.type == LEXER_MULTIPLY
    #####: 2451:          || (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)))
        -: 2452:    {
    #####: 2453:      parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_MULTIPLY_LITERAL_EXPECTED);
        -: 2454:    }
        -: 2455:
    #####: 2456:    if (context_p->token.type == LEXER_LITERAL)
        -: 2457:    {
        -: 2458:      /* Handle ImportedDefaultBinding */
    #####: 2459:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 2460:
    #####: 2461:      ecma_string_t *local_name_p = parser_new_ecma_string_from_literal (context_p->lit_object.literal_p);
        -: 2462:
    #####: 2463:      if (parser_module_check_duplicate_import (context_p, local_name_p))
        -: 2464:      {
    #####: 2465:        ecma_deref_ecma_string (local_name_p);
    #####: 2466:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_IMPORT_BINDING);
        -: 2467:      }
        -: 2468:
    #####: 2469:      ecma_string_t *import_name_p = ecma_get_magic_string (LIT_MAGIC_STRING_DEFAULT);
    #####: 2470:      parser_module_add_names_to_node (context_p, import_name_p, local_name_p);
        -: 2471:
    #####: 2472:      ecma_deref_ecma_string (local_name_p);
    #####: 2473:      ecma_deref_ecma_string (import_name_p);
        -: 2474:
    #####: 2475:      lexer_next_token (context_p);
        -: 2476:
    #####: 2477:      if (context_p->token.type == LEXER_COMMA)
        -: 2478:      {
    #####: 2479:        lexer_next_token (context_p);
    #####: 2480:        if (context_p->token.type != LEXER_MULTIPLY
    #####: 2481:            && context_p->token.type != LEXER_LEFT_BRACE)
        -: 2482:        {
    #####: 2483:          parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_MULTIPLY_EXPECTED);
        -: 2484:        }
        -: 2485:      }
    #####: 2486:      else if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 2487:      {
    #####: 2488:        parser_raise_error (context_p, PARSER_ERR_FROM_COMMA_EXPECTED);
        -: 2489:      }
        -: 2490:    }
        -: 2491:
    #####: 2492:    if (context_p->token.type == LEXER_MULTIPLY)
        -: 2493:    {
        -: 2494:      /* NameSpaceImport */
    #####: 2495:      lexer_next_token (context_p);
    #####: 2496:      if (!lexer_token_is_identifier (context_p, "as", 2))
        -: 2497:      {
    #####: 2498:        parser_raise_error (context_p, PARSER_ERR_AS_EXPECTED);
        -: 2499:      }
        -: 2500:
    #####: 2501:      lexer_next_token (context_p);
    #####: 2502:      if (context_p->token.type != LEXER_LITERAL)
        -: 2503:      {
    #####: 2504:        parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 2505:      }
        -: 2506:
    #####: 2507:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 2508:
    #####: 2509:      ecma_string_t *local_name_p = parser_new_ecma_string_from_literal (context_p->lit_object.literal_p);
        -: 2510:
    #####: 2511:      if (parser_module_check_duplicate_import (context_p, local_name_p))
        -: 2512:      {
    #####: 2513:        ecma_deref_ecma_string (local_name_p);
    #####: 2514:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_IMPORT_BINDING);
        -: 2515:      }
        -: 2516:
    #####: 2517:      ecma_string_t *import_name_p = ecma_get_magic_string (LIT_MAGIC_STRING_ASTERIX_CHAR);
        -: 2518:
    #####: 2519:      parser_module_add_names_to_node (context_p, import_name_p, local_name_p);
    #####: 2520:      ecma_deref_ecma_string (local_name_p);
    #####: 2521:      ecma_deref_ecma_string (import_name_p);
        -: 2522:
    #####: 2523:      lexer_next_token (context_p);
        -: 2524:    }
    #####: 2525:    else if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2526:    {
        -: 2527:      /* Handle NamedImports */
    #####: 2528:      parser_module_parse_import_clause (context_p);
        -: 2529:    }
        -: 2530:
    #####: 2531:    if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 2532:    {
    #####: 2533:      parser_raise_error (context_p, PARSER_ERR_FROM_EXPECTED);
        -: 2534:    }
    #####: 2535:    lexer_next_token (context_p);
        -: 2536:  }
        -: 2537:
    #####: 2538:  parser_module_handle_module_specifier (context_p, NULL);
        -: 2539:} /* parser_parse_import_statement */
        -: 2540:
        -: 2541:/**
        -: 2542: * Parse export statement.
        -: 2543: *
        -: 2544: * @return true - if function of class statement was found
        -: 2545: *         false - otherwise
        -: 2546: */
        -: 2547:static bool
    #####: 2548:parser_parse_export_statement (parser_context_t *context_p) /**< context */
        -: 2549:{
    #####: 2550:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_EXPORT);
    #####: 2551:  JERRY_ASSERT (context_p->module_names_p == NULL);
        -: 2552:
    #####: 2553:  parser_module_check_request_place (context_p);
        -: 2554:
    #####: 2555:  bool consume_last_statement = false;
        -: 2556:
    #####: 2557:  lexer_next_token (context_p);
    #####: 2558:  switch (context_p->token.type)
        -: 2559:  {
    #####: 2560:    case LEXER_KEYW_DEFAULT:
        -: 2561:    {
    #####: 2562:      scanner_location_t location;
    #####: 2563:      scanner_get_location (&location, context_p);
        -: 2564:
    #####: 2565:      context_p->status_flags |= PARSER_MODULE_STORE_IDENT;
        -: 2566:
    #####: 2567:      lexer_next_token (context_p);
        -: 2568:
    #####: 2569:      if (context_p->token.type == LEXER_LITERAL
    #####: 2570:          && lexer_token_is_async (context_p)
    #####: 2571:          && context_p->next_scanner_info_p->source_p == context_p->source_p
    #####: 2572:          && context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION)
        -: 2573:      {
        -: 2574:#if JERRY_FUNCTION_TO_STRING
    #####: 2575:        context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 2576:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 2577:        lexer_next_token (context_p);
        -: 2578:      }
        -: 2579:
    #####: 2580:      if (context_p->token.type == LEXER_KEYW_CLASS)
        -: 2581:      {
    #####: 2582:        context_p->status_flags |= PARSER_MODULE_DEFAULT_CLASS_OR_FUNC;
    #####: 2583:        parser_parse_class (context_p, true);
    #####: 2584:        consume_last_statement = true;
        -: 2585:      }
    #####: 2586:      else if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -: 2587:      {
    #####: 2588:        context_p->status_flags |= PARSER_MODULE_DEFAULT_CLASS_OR_FUNC;
    #####: 2589:        parser_parse_function_statement (context_p);
    #####: 2590:        consume_last_statement = true;
        -: 2591:      }
        -: 2592:      else
        -: 2593:      {
        -: 2594:        /* Assignment expression */
    #####: 2595:        scanner_set_location (context_p, &location);
        -: 2596:
        -: 2597:        /* 15.2.3.5 Use the synthetic name '*default*' as the identifier. */
    #####: 2598:        lexer_construct_literal_object (context_p, &lexer_default_literal, lexer_default_literal.type);
        -: 2599:
    #####: 2600:        context_p->token.lit_location.type = LEXER_IDENT_LITERAL;
    #####: 2601:        parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 2602:
        -: 2603:        /* Do not overwrite this identifier. */
    #####: 2604:        context_p->status_flags &= (uint32_t) ~PARSER_MODULE_STORE_IDENT;
    #####: 2605:        context_p->module_identifier_lit_p = context_p->lit_object.literal_p;
        -: 2606:
        -: 2607:        /* Fake an assignment to the default identifier */
    #####: 2608:        context_p->token.type = LEXER_ASSIGN;
        -: 2609:
    #####: 2610:        parser_parse_expression_statement (context_p, PARSE_EXPR_NO_COMMA | PARSE_EXPR_HAS_LITERAL);
        -: 2611:      }
        -: 2612:
    #####: 2613:      ecma_string_t *name_p = parser_new_ecma_string_from_literal (context_p->module_identifier_lit_p);
        -: 2614:
    #####: 2615:      ecma_string_t *export_name_p = ecma_get_magic_string (LIT_MAGIC_STRING_DEFAULT);
        -: 2616:
    #####: 2617:      if (parser_module_check_duplicate_export (context_p, export_name_p))
        -: 2618:      {
    #####: 2619:        ecma_deref_ecma_string (name_p);
    #####: 2620:        ecma_deref_ecma_string (export_name_p);
    #####: 2621:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_EXPORT_IDENTIFIER);
        -: 2622:      }
        -: 2623:
    #####: 2624:      parser_module_add_names_to_node (context_p,
        -: 2625:                                       export_name_p,
        -: 2626:                                       name_p);
    #####: 2627:      ecma_deref_ecma_string (name_p);
    #####: 2628:      ecma_deref_ecma_string (export_name_p);
    #####: 2629:      break;
        -: 2630:    }
    #####: 2631:    case LEXER_MULTIPLY:
        -: 2632:    {
    #####: 2633:      lexer_next_token (context_p);
        -: 2634:
    #####: 2635:      ecma_module_node_t **target_node_list_p = &(JERRY_CONTEXT (module_current_p)->star_exports_p);
        -: 2636:
    #####: 2637:      if (lexer_token_is_identifier (context_p, "as", 2))
        -: 2638:      {
    #####: 2639:        target_node_list_p = &(JERRY_CONTEXT (module_current_p)->indirect_exports_p);
        -: 2640:
    #####: 2641:        lexer_next_token (context_p);
        -: 2642:
    #####: 2643:        if (context_p->token.type != LEXER_LITERAL
    #####: 2644:            || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 2645:        {
    #####: 2646:          parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 2647:        }
        -: 2648:
    #####: 2649:        lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_NEW_IDENT_LITERAL);
        -: 2650:
    #####: 2651:        lexer_literal_t *literal_p = PARSER_GET_LITERAL (context_p->lit_object.index);
    #####: 2652:        ecma_string_t *export_name_p = parser_new_ecma_string_from_literal (literal_p);
        -: 2653:
    #####: 2654:        if (parser_module_check_duplicate_export (context_p, export_name_p))
        -: 2655:        {
    #####: 2656:          ecma_deref_ecma_string (export_name_p);
    #####: 2657:          parser_raise_error (context_p, PARSER_ERR_DUPLICATED_EXPORT_IDENTIFIER);
        -: 2658:        }
        -: 2659:
    #####: 2660:        ecma_string_t *local_name_p = ecma_get_magic_string (LIT_MAGIC_STRING_ASTERIX_CHAR);
    #####: 2661:        parser_module_add_names_to_node (context_p, export_name_p, local_name_p);
    #####: 2662:        ecma_deref_ecma_string (export_name_p);
        -: 2663:
    #####: 2664:        lexer_next_token (context_p);
        -: 2665:      }
        -: 2666:
    #####: 2667:      if (!lexer_token_is_identifier (context_p, "from", 4))
        -: 2668:      {
    #####: 2669:        parser_raise_error (context_p, PARSER_ERR_FROM_EXPECTED);
        -: 2670:      }
        -: 2671:
    #####: 2672:      lexer_next_token (context_p);
    #####: 2673:      parser_module_handle_module_specifier (context_p, target_node_list_p);
    #####: 2674:      return false;
        -: 2675:    }
    #####: 2676:    case LEXER_KEYW_VAR:
        -: 2677:    case LEXER_KEYW_LET:
        -: 2678:    case LEXER_KEYW_CONST:
        -: 2679:    {
    #####: 2680:      context_p->status_flags |= PARSER_MODULE_STORE_IDENT;
    #####: 2681:      parser_parse_var_statement (context_p);
    #####: 2682:      break;
        -: 2683:    }
    #####: 2684:    case LEXER_KEYW_CLASS:
        -: 2685:    {
    #####: 2686:      context_p->status_flags |= PARSER_MODULE_STORE_IDENT;
    #####: 2687:      parser_parse_class (context_p, true);
    #####: 2688:      consume_last_statement = true;
    #####: 2689:      break;
        -: 2690:    }
    #####: 2691:    case LEXER_KEYW_FUNCTION:
        -: 2692:    {
    #####: 2693:      context_p->status_flags |= PARSER_MODULE_STORE_IDENT;
    #####: 2694:      parser_parse_function_statement (context_p);
    #####: 2695:      consume_last_statement = true;
    #####: 2696:      break;
        -: 2697:    }
    #####: 2698:    case LEXER_LEFT_BRACE:
        -: 2699:    {
    #####: 2700:      parser_module_parse_export_clause (context_p);
        -: 2701:
    #####: 2702:      if (lexer_token_is_identifier (context_p, "from", 4))
        -: 2703:      {
    #####: 2704:        lexer_next_token (context_p);
    #####: 2705:        parser_module_handle_module_specifier (context_p, &(JERRY_CONTEXT (module_current_p)->indirect_exports_p));
    #####: 2706:        return false;
        -: 2707:      }
    #####: 2708:      break;
        -: 2709:    }
    #####: 2710:    default:
        -: 2711:    {
    #####: 2712:      parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_MULTIPLY_LITERAL_EXPECTED);
    #####: 2713:      break;
        -: 2714:    }
        -: 2715:  }
        -: 2716:
    #####: 2717:  context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_DEFAULT_CLASS_OR_FUNC | PARSER_MODULE_STORE_IDENT);
    #####: 2718:  parser_module_append_names (context_p, &(JERRY_CONTEXT (module_current_p)->local_exports_p));
        -: 2719:
    #####: 2720:  return consume_last_statement;
        -: 2721:} /* parser_parse_export_statement */
        -: 2722:#endif /* JERRY_MODULE_SYSTEM */
        -: 2723:
        -: 2724:/**
        -: 2725: * Parse label statement.
        -: 2726: */
        -: 2727:static void
    #####: 2728:parser_parse_label (parser_context_t *context_p) /**< context */
        -: 2729:{
    #####: 2730:  parser_stack_iterator_t iterator;
    #####: 2731:  parser_label_statement_t label_statement;
        -: 2732:
    #####: 2733:  parser_stack_iterator_init (context_p, &iterator);
        -: 2734:
        -: 2735:  while (true)
    #####: 2736:  {
    #####: 2737:    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 2738:    if (type == PARSER_STATEMENT_START)
        -: 2739:    {
    #####: 2740:      break;
        -: 2741:    }
        -: 2742:
    #####: 2743:    if (type == PARSER_STATEMENT_LABEL)
        -: 2744:    {
    #####: 2745:      parser_stack_iterator_skip (&iterator, 1);
    #####: 2746:      parser_stack_iterator_read (&iterator, &label_statement, sizeof (parser_label_statement_t));
    #####: 2747:      parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));
        -: 2748:
    #####: 2749:      if (lexer_current_is_literal (context_p, &label_statement.label_ident))
        -: 2750:      {
    #####: 2751:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_LABEL);
        -: 2752:      }
        -: 2753:    }
        -: 2754:    else
        -: 2755:    {
    #####: 2756:      parser_stack_iterator_skip (&iterator, parser_statement_length (type));
        -: 2757:    }
        -: 2758:  }
        -: 2759:
    #####: 2760:  label_statement.label_ident = context_p->token.lit_location;
    #####: 2761:  label_statement.break_list_p = NULL;
    #####: 2762:  parser_stack_push (context_p, &label_statement, sizeof (parser_label_statement_t));
    #####: 2763:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_LABEL);
    #####: 2764:  parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 2765:} /* parser_parse_label */
        -: 2766:
        -: 2767:/**
        -: 2768: * Strict mode types for statement parsing.
        -: 2769: */
        -: 2770:typedef enum
        -: 2771:{
        -: 2772:  PARSER_USE_STRICT_NOT_FOUND = 0, /**< 'use strict' directive is not found */
        -: 2773:  PARSER_USE_STRICT_FOUND = 1, /**< 'use strict' directive is found but strict mode has already been enabled */
        -: 2774:  PARSER_USE_STRICT_SET = 2, /**< strict mode is enabled after 'use strict' directive is found */
        -: 2775:} parser_strict_mode_type_t;
        -: 2776:
        -: 2777:/**
        -: 2778: * Parse statements.
        -: 2779: */
        -: 2780:void
        2: 2781:parser_parse_statements (parser_context_t *context_p) /**< context */
        -: 2782:{
        -: 2783:  /* Statement parsing cannot be nested. */
        2: 2784:  JERRY_ASSERT (context_p->last_statement.current_p == NULL);
        2: 2785:  parser_stack_push_uint8 (context_p, PARSER_STATEMENT_START);
        2: 2786:  parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 2787:
        -: 2788:#if JERRY_DEBUGGER
        -: 2789:  /* Set lexical enviroment for the debugger. */
        -: 2790:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2791:  {
        -: 2792:    context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2793:    context_p->last_breakpoint_line = 0;
        -: 2794:  }
        -: 2795:#endif /* JERRY_DEBUGGER */
        -: 2796:
        4: 2797:  while (context_p->token.type == LEXER_LITERAL
        1: 2798:         && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -: 2799:  {
    #####: 2800:    lexer_lit_location_t lit_location;
    #####: 2801:    parser_strict_mode_type_t strict_mode = PARSER_USE_STRICT_NOT_FOUND;
        -: 2802:
    #####: 2803:    JERRY_ASSERT (context_p->stack_depth <= 1);
        -: 2804:#ifndef JERRY_NDEBUG
    #####: 2805:    JERRY_ASSERT (context_p->context_stack_depth == context_p->stack_depth);
        -: 2806:#endif /* !JERRY_NDEBUG */
        -: 2807:
    #####: 2808:    if (lexer_string_is_use_strict (context_p))
        -: 2809:    {
    #####: 2810:      strict_mode = PARSER_USE_STRICT_FOUND;
        -: 2811:
    #####: 2812:      if (!(context_p->status_flags & PARSER_IS_STRICT))
        -: 2813:      {
        -: 2814:        /* The next token should be parsed in strict mode. */
    #####: 2815:        context_p->status_flags |= PARSER_IS_STRICT;
    #####: 2816:        strict_mode = PARSER_USE_STRICT_SET;
        -: 2817:      }
        -: 2818:    }
        -: 2819:
    #####: 2820:    lit_location = context_p->token.lit_location;
    #####: 2821:    lexer_next_token (context_p);
        -: 2822:
    #####: 2823:    if (!lexer_string_is_directive (context_p))
        -: 2824:    {
        -: 2825:      /* The string is part of an expression statement. */
    #####: 2826:      if (strict_mode == PARSER_USE_STRICT_SET)
        -: 2827:      {
    #####: 2828:        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -: 2829:      }
        -: 2830:
        -: 2831:#if JERRY_DEBUGGER
        -: 2832:      if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2833:      {
        -: 2834:        JERRY_ASSERT (context_p->last_breakpoint_line == 0);
        -: 2835:
        -: 2836:        parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -: 2837:        parser_flush_cbc (context_p);
        -: 2838:
        -: 2839:        parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);
        -: 2840:
        -: 2841:        context_p->last_breakpoint_line = context_p->token.line;
        -: 2842:      }
        -: 2843:#endif /* JERRY_DEBUGGER */
        -: 2844:#if JERRY_LINE_INFO
    #####: 2845:      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2846:#endif /* JERRY_LINE_INFO */
        -: 2847:
    #####: 2848:      lexer_construct_literal_object (context_p, &lit_location, LEXER_STRING_LITERAL);
    #####: 2849:      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
        -: 2850:      /* The extra_value is used for saving the token. */
    #####: 2851:      context_p->token.extra_value = context_p->token.type;
    #####: 2852:      context_p->token.type = LEXER_EXPRESSION_START;
    #####: 2853:      break;
        -: 2854:    }
        -: 2855:
        -: 2856:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2857:    if (strict_mode == PARSER_USE_STRICT_SET && context_p->is_show_opcodes)
        -: 2858:    {
        -: 2859:      JERRY_DEBUG_MSG ("  Note: switch to strict mode\n\n");
        -: 2860:    }
        -: 2861:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2862:
        -: 2863:#if JERRY_ESNEXT
    #####: 2864:    if (strict_mode != PARSER_USE_STRICT_NOT_FOUND
    #####: 2865:        && (context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT))
        -: 2866:    {
    #####: 2867:      parser_raise_error (context_p, PARSER_ERR_USE_STRICT_NOT_ALLOWED);
        -: 2868:    }
        -: 2869:#endif /* JERRY_ESNEXT */
        -: 2870:
    #####: 2871:    if (context_p->token.type == LEXER_SEMICOLON)
        -: 2872:    {
    #####: 2873:      lexer_next_token (context_p);
        -: 2874:    }
        -: 2875:
        -: 2876:    /* The last directive prologue can be the result of the script. */
    #####: 2877:    if (!(context_p->status_flags & PARSER_IS_FUNCTION)
    #####: 2878:        && (context_p->token.type != LEXER_LITERAL
    #####: 2879:            || context_p->token.lit_location.type != LEXER_STRING_LITERAL))
        -: 2880:    {
    #####: 2881:      lexer_construct_literal_object (context_p, &lit_location, LEXER_STRING_LITERAL);
    #####: 2882:      parser_emit_cbc_literal_from_token (context_p, CBC_PUSH_LITERAL);
    #####: 2883:      parser_emit_cbc (context_p, CBC_POP_BLOCK);
    #####: 2884:      parser_flush_cbc (context_p);
    #####: 2885:      break;
        -: 2886:    }
        -: 2887:  }
        -: 2888:
        2: 2889:  if (context_p->status_flags & PARSER_IS_STRICT
    #####: 2890:      && context_p->status_flags & PARSER_HAS_NON_STRICT_ARG)
        -: 2891:  {
    #####: 2892:    parser_raise_error (context_p, PARSER_ERR_NON_STRICT_ARG_DEFINITION);
        -: 2893:  }
        -: 2894:
       10: 2895:  while (context_p->token.type != LEXER_EOS
        1: 2896:         || context_p->stack_top_uint8 != PARSER_STATEMENT_START)
        -: 2897:  {
        -: 2898:#ifndef JERRY_NDEBUG
        7: 2899:    JERRY_ASSERT (context_p->stack_depth == context_p->context_stack_depth);
        -: 2900:#endif /* !JERRY_NDEBUG */
        -: 2901:
        -: 2902:#if JERRY_ESNEXT
        7: 2903:    JERRY_ASSERT (context_p->stack_top_uint8 != PARSER_STATEMENT_PRIVATE_SCOPE
        -: 2904:                  && context_p->stack_top_uint8 != PARSER_STATEMENT_PRIVATE_CONTEXT);
        -: 2905:#endif /* JERRY_ESNEXT */
        -: 2906:
        -: 2907:#if JERRY_DEBUGGER
        -: 2908:    if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED
        -: 2909:        && context_p->token.line != context_p->last_breakpoint_line
        -: 2910:        && context_p->token.type != LEXER_SEMICOLON
        -: 2911:        && context_p->token.type != LEXER_LEFT_BRACE
        -: 2912:        && context_p->token.type != LEXER_RIGHT_BRACE
        -: 2913:        && context_p->token.type != LEXER_KEYW_VAR
        -: 2914:        && context_p->token.type != LEXER_KEYW_LET
        -: 2915:        && context_p->token.type != LEXER_KEYW_CONST
        -: 2916:        && context_p->token.type != LEXER_KEYW_FUNCTION
        -: 2917:        && context_p->token.type != LEXER_KEYW_CASE
        -: 2918:        && context_p->token.type != LEXER_KEYW_DEFAULT)
        -: 2919:    {
        -: 2920:      parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -: 2921:      parser_flush_cbc (context_p);
        -: 2922:
        -: 2923:      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);
        -: 2924:
        -: 2925:      context_p->last_breakpoint_line = context_p->token.line;
        -: 2926:    }
        -: 2927:#endif /* JERRY_DEBUGGER */
        -: 2928:
        -: 2929:#if JERRY_LINE_INFO
    #####: 2930:    if (context_p->token.type != LEXER_SEMICOLON
    #####: 2931:        && context_p->token.type != LEXER_LEFT_BRACE
    #####: 2932:        && context_p->token.type != LEXER_RIGHT_BRACE
    #####: 2933:        && context_p->token.type != LEXER_KEYW_VAR
    #####: 2934:        && context_p->token.type != LEXER_KEYW_LET
    #####: 2935:        && context_p->token.type != LEXER_KEYW_CONST
    #####: 2936:        && context_p->token.type != LEXER_KEYW_FUNCTION
    #####: 2937:        && context_p->token.type != LEXER_KEYW_CASE
    #####: 2938:        && context_p->token.type != LEXER_KEYW_DEFAULT)
        -: 2939:    {
    #####: 2940:      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2941:    }
        -: 2942:#endif /* JERRY_LINE_INFO */
        -: 2943:
        7: 2944:    switch (context_p->token.type)
        -: 2945:    {
    #####: 2946:      case LEXER_SEMICOLON:
        -: 2947:      {
    #####: 2948:        break;
        -: 2949:      }
        -: 2950:
        1: 2951:      case LEXER_RIGHT_BRACE:
        -: 2952:      {
        1: 2953:        if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)
        -: 2954:        {
    #####: 2955:          parser_raise_error (context_p, PARSER_ERR_STATEMENT_EXPECTED);
        -: 2956:        }
        1: 2957:        break;
        -: 2958:      }
        -: 2959:
    #####: 2960:      case LEXER_LEFT_BRACE:
        -: 2961:      {
        -: 2962:#if JERRY_ESNEXT
    #####: 2963:        if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 2964:        {
    #####: 2965:          parser_push_block_context (context_p, false);
        -: 2966:        }
        -: 2967:        else
        -: 2968:        {
    #####: 2969:          parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);
        -: 2970:        }
        -: 2971:#else /* !JERRY_ESNEXT */
    #####: 2972:        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_BLOCK);
        -: 2973:#endif /* JERRY_ESNEXT */
        -: 2974:
    #####: 2975:        parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 2976:        lexer_next_token (context_p);
    #####: 2977:        continue;
        -: 2978:      }
        -: 2979:
        2: 2980:      case LEXER_KEYW_VAR:
        -: 2981:#if JERRY_ESNEXT
        -: 2982:      case LEXER_KEYW_LET:
        -: 2983:      case LEXER_KEYW_CONST:
        -: 2984:#endif /* JERRY_ESNEXT */
        -: 2985:      {
        2: 2986:        parser_parse_var_statement (context_p);
        2: 2987:        break;
        -: 2988:      }
        -: 2989:
        -: 2990:#if JERRY_ESNEXT
    #####: 2991:      case LEXER_KEYW_CLASS:
        -: 2992:      {
    #####: 2993:        parser_validate_lexical_context (context_p);
    #####: 2994:        parser_parse_class (context_p, true);
    #####: 2995:        goto consume_last_statement;
        -: 2996:      }
        -: 2997:#endif /* JERRY_ESNEXT */
        -: 2998:
        -: 2999:#if JERRY_MODULE_SYSTEM
    #####: 3000:      case LEXER_KEYW_IMPORT:
        -: 3001:      {
    #####: 3002:        parser_parse_import_statement (context_p);
    #####: 3003:        break;
        -: 3004:      }
        -: 3005:
    #####: 3006:      case LEXER_KEYW_EXPORT:
        -: 3007:      {
    #####: 3008:        if (parser_parse_export_statement (context_p))
        -: 3009:        {
    #####: 3010:          goto consume_last_statement;
        -: 3011:        }
    #####: 3012:        break;
        -: 3013:      }
        -: 3014:#endif /* JERRY_MODULE_SYSTEM */
        -: 3015:
    #####: 3016:      case LEXER_KEYW_FUNCTION:
        -: 3017:      {
    #####: 3018:        parser_parse_function_statement (context_p);
    #####: 3019:        goto consume_last_statement;
        -: 3020:      }
        -: 3021:
    #####: 3022:      case LEXER_KEYW_IF:
        -: 3023:      {
    #####: 3024:        parser_parse_if_statement_start (context_p);
    #####: 3025:        continue;
        -: 3026:      }
        -: 3027:
    #####: 3028:      case LEXER_KEYW_SWITCH:
        -: 3029:      {
    #####: 3030:        parser_parse_switch_statement_start (context_p);
    #####: 3031:        continue;
        -: 3032:      }
        -: 3033:
    #####: 3034:      case LEXER_KEYW_DO:
        -: 3035:      {
    #####: 3036:        parser_do_while_statement_t do_while_statement;
    #####: 3037:        parser_loop_statement_t loop;
        -: 3038:
    #####: 3039:        JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 3040:
    #####: 3041:        do_while_statement.start_offset = context_p->byte_code_size;
    #####: 3042:        loop.branch_list_p = NULL;
        -: 3043:
    #####: 3044:        parser_stack_push (context_p, &do_while_statement, sizeof (parser_do_while_statement_t));
    #####: 3045:        parser_stack_push (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 3046:        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_DO_WHILE);
    #####: 3047:        parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 3048:        lexer_next_token (context_p);
    #####: 3049:        continue;
        -: 3050:      }
        -: 3051:
    #####: 3052:      case LEXER_KEYW_WHILE:
        -: 3053:      {
    #####: 3054:        parser_parse_while_statement_start (context_p);
    #####: 3055:        continue;
        -: 3056:      }
        -: 3057:
        1: 3058:      case LEXER_KEYW_FOR:
        -: 3059:      {
        1: 3060:        parser_parse_for_statement_start (context_p);
        1: 3061:        continue;
        -: 3062:      }
        -: 3063:
    #####: 3064:      case LEXER_KEYW_WITH:
        -: 3065:      {
    #####: 3066:        parser_parse_with_statement_start (context_p);
    #####: 3067:        continue;
        -: 3068:      }
        -: 3069:
    #####: 3070:      case LEXER_KEYW_TRY:
        -: 3071:      {
    #####: 3072:        parser_try_statement_t try_statement;
        -: 3073:
    #####: 3074:        lexer_next_token (context_p);
        -: 3075:
    #####: 3076:        if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 3077:        {
    #####: 3078:          parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 3079:        }
        -: 3080:
        -: 3081:#ifndef JERRY_NDEBUG
    #####: 3082:        PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -: 3083:#endif /* !JERRY_NDEBUG */
        -: 3084:
    #####: 3085:        try_statement.type = parser_try_block;
    #####: 3086:        parser_emit_cbc_ext_forward_branch (context_p,
        -: 3087:                                            CBC_EXT_TRY_CREATE_CONTEXT,
        -: 3088:                                            &try_statement.branch);
        -: 3089:
        -: 3090:#if JERRY_ESNEXT
    #####: 3091:        try_statement.scope_stack_top = context_p->scope_stack_top;
    #####: 3092:        try_statement.scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 3093:
    #####: 3094:        if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3095:        {
    #####: 3096:          JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_BLOCK);
        -: 3097:
    #####: 3098:          if (scanner_is_context_needed (context_p, PARSER_CHECK_BLOCK_CONTEXT))
        -: 3099:          {
    #####: 3100:            parser_emit_cbc_ext (context_p, CBC_EXT_TRY_CREATE_ENV);
        -: 3101:          }
        -: 3102:
    #####: 3103:          scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        -: 3104:        }
        -: 3105:#endif /* JERRY_ESNEXT */
        -: 3106:
    #####: 3107:        parser_stack_push (context_p, &try_statement, sizeof (parser_try_statement_t));
    #####: 3108:        parser_stack_push_uint8 (context_p, PARSER_STATEMENT_TRY);
    #####: 3109:        parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 3110:        lexer_next_token (context_p);
    #####: 3111:        continue;
        -: 3112:      }
        -: 3113:
    #####: 3114:      case LEXER_KEYW_DEFAULT:
        -: 3115:      {
    #####: 3116:        parser_parse_default_statement (context_p);
    #####: 3117:        continue;
        -: 3118:      }
        -: 3119:
    #####: 3120:      case LEXER_KEYW_CASE:
        -: 3121:      {
    #####: 3122:        parser_parse_case_statement (context_p);
    #####: 3123:        continue;
        -: 3124:      }
        -: 3125:
    #####: 3126:      case LEXER_KEYW_BREAK:
        -: 3127:      {
    #####: 3128:        parser_parse_break_statement (context_p);
    #####: 3129:        break;
        -: 3130:      }
        -: 3131:
    #####: 3132:      case LEXER_KEYW_CONTINUE:
        -: 3133:      {
    #####: 3134:        parser_parse_continue_statement (context_p);
    #####: 3135:        break;
        -: 3136:      }
        -: 3137:
    #####: 3138:      case LEXER_KEYW_THROW:
        -: 3139:      {
    #####: 3140:        lexer_next_token (context_p);
    #####: 3141:        if (context_p->token.flags & LEXER_WAS_NEWLINE)
        -: 3142:        {
    #####: 3143:          parser_raise_error (context_p, PARSER_ERR_EXPRESSION_EXPECTED);
        -: 3144:        }
    #####: 3145:        parser_parse_expression (context_p, PARSE_EXPR);
    #####: 3146:        parser_emit_cbc (context_p, CBC_THROW);
    #####: 3147:        break;
        -: 3148:      }
        -: 3149:
        1: 3150:      case LEXER_KEYW_RETURN:
        -: 3151:      {
        1: 3152:        if (!(context_p->status_flags & PARSER_IS_FUNCTION))
        -: 3153:        {
    #####: 3154:          parser_raise_error (context_p, PARSER_ERR_INVALID_RETURN);
        -: 3155:        }
        -: 3156:
        1: 3157:        lexer_next_token (context_p);
        -: 3158:
        1: 3159:        if ((context_p->token.flags & LEXER_WAS_NEWLINE)
        1: 3160:            || context_p->token.type == LEXER_SEMICOLON
        1: 3161:            || context_p->token.type == LEXER_EOS
        1: 3162:            || context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3163:        {
        -: 3164:#if JERRY_ESNEXT
    #####: 3165:          if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 3166:          {
    #####: 3167:            parser_emit_cbc_ext (context_p, CBC_EXT_RETURN_UNDEFINED);
    #####: 3168:            break;
        -: 3169:          }
        -: 3170:#endif /* JERRY_ESNEXT */
        -: 3171:
    #####: 3172:          parser_emit_cbc (context_p, CBC_RETURN_WITH_BLOCK);
    #####: 3173:          break;
        -: 3174:        }
        -: 3175:
        1: 3176:        parser_parse_expression (context_p, PARSE_EXPR);
        -: 3177:
        1: 3178:        if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3179:        {
    #####: 3180:          context_p->last_cbc_opcode = CBC_RETURN_WITH_LITERAL;
    #####: 3181:          break;
        -: 3182:        }
        -: 3183:
        1: 3184:        parser_emit_cbc (context_p, CBC_RETURN);
        1: 3185:        break;
        -: 3186:      }
        -: 3187:
    #####: 3188:      case LEXER_KEYW_DEBUGGER:
        -: 3189:      {
        -: 3190:#if JERRY_DEBUGGER
        -: 3191:        /* This breakpoint location is not reported to the
        -: 3192:         * debugger, so it is impossible to disable it. */
        -: 3193:        if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 3194:        {
        -: 3195:          parser_emit_cbc (context_p, CBC_BREAKPOINT_ENABLED);
        -: 3196:        }
        -: 3197:#endif /* JERRY_DEBUGGER */
    #####: 3198:        lexer_next_token (context_p);
    #####: 3199:        break;
        -: 3200:      }
        -: 3201:
        2: 3202:      case LEXER_LITERAL:
        -: 3203:      {
        2: 3204:        if (context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -: 3205:        {
        2: 3206:          if (JERRY_UNLIKELY (lexer_check_next_character (context_p, LIT_CHAR_COLON)))
        -: 3207:          {
    #####: 3208:            parser_parse_label (context_p);
    #####: 3209:            lexer_consume_next_character (context_p);
    #####: 3210:            lexer_next_token (context_p);
    #####: 3211:            continue;
        -: 3212:          }
        -: 3213:#if JERRY_ESNEXT
        2: 3214:          if (JERRY_UNLIKELY (lexer_token_is_let (context_p)))
        -: 3215:          {
    #####: 3216:            if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3217:            {
    #####: 3218:              if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION)
        -: 3219:              {
    #####: 3220:                scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 3221:              }
        -: 3222:
    #####: 3223:              if (context_p->status_flags & PARSER_IS_FUNCTION)
        -: 3224:              {
    #####: 3225:                parser_parse_expression_statement (context_p, PARSE_EXPR);
    #####: 3226:                break;
        -: 3227:              }
        -: 3228:
    #####: 3229:              parser_parse_block_expression (context_p, PARSE_EXPR);
    #####: 3230:              break;
        -: 3231:            }
        -: 3232:
    #####: 3233:            context_p->token.type = LEXER_KEYW_LET;
    #####: 3234:            parser_parse_var_statement (context_p);
    #####: 3235:            break;
        -: 3236:          }
        -: 3237:
        2: 3238:          if (JERRY_UNLIKELY (lexer_token_is_async (context_p))
    #####: 3239:              && context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 3240:          {
    #####: 3241:            bool is_statement = true;
        -: 3242:
    #####: 3243:            if (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION)
        -: 3244:            {
    #####: 3245:              is_statement = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_STATEMENT) != 0;
        -: 3246:
    #####: 3247:              JERRY_ASSERT (!is_statement || (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC));
        -: 3248:            }
        -: 3249:            else
        -: 3250:            {
    #####: 3251:              JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION);
        -: 3252:
    #####: 3253:              scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 3254:            }
        -: 3255:
    #####: 3256:            if (is_statement)
        -: 3257:            {
    #####: 3258:              if (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)
        -: 3259:              {
    #####: 3260:                parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT);
        -: 3261:              }
        -: 3262:
        -: 3263:#if JERRY_FUNCTION_TO_STRING
    #####: 3264:              context_p->function_start_p = context_p->token.lit_location.char_p;
        -: 3265:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 3266:              lexer_next_token (context_p);
    #####: 3267:              JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION);
    #####: 3268:              continue;
        -: 3269:            }
        -: 3270:          }
        -: 3271:#endif /* JERRY_ESNEXT */
        -: 3272:        }
        -: 3273:        /* FALLTHRU */
        -: 3274:      }
        -: 3275:
        -: 3276:      default:
        -: 3277:      {
        2: 3278:        int options = PARSE_EXPR;
        -: 3279:
        2: 3280:        if (context_p->token.type == LEXER_EXPRESSION_START)
        -: 3281:        {
        -: 3282:          /* Restore the token type form the extra_value. */
    #####: 3283:          context_p->token.type = context_p->token.extra_value;
    #####: 3284:          options |= PARSE_EXPR_HAS_LITERAL;
        -: 3285:        }
        -: 3286:
        2: 3287:        if (context_p->status_flags & PARSER_IS_FUNCTION)
        -: 3288:        {
        1: 3289:          parser_parse_expression_statement (context_p, options);
        -: 3290:        }
        -: 3291:        else
        -: 3292:        {
        1: 3293:          parser_parse_block_expression (context_p, options);
        -: 3294:        }
        -: 3295:
        2: 3296:        break;
        -: 3297:      }
        -: 3298:    }
        -: 3299:
        6: 3300:    parser_flush_cbc (context_p);
        -: 3301:
        6: 3302:    if (context_p->token.type == LEXER_RIGHT_BRACE)
        -: 3303:    {
        1: 3304:      if (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK)
        -: 3305:      {
    #####: 3306:        parser_stack_pop_uint8 (context_p);
    #####: 3307:        parser_stack_iterator_init (context_p, &context_p->last_statement);
    #####: 3308:        lexer_next_token (context_p);
        -: 3309:      }
        -: 3310:#if JERRY_ESNEXT
        1: 3311:      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_SCOPE
        1: 3312:               || context_p->stack_top_uint8 == PARSER_STATEMENT_BLOCK_CONTEXT)
        -: 3313:      {
    #####: 3314:        parser_pop_block_context (context_p);
    #####: 3315:        lexer_next_token (context_p);
        -: 3316:      }
        -: 3317:#endif /* JERRY_ESNEXT */
        1: 3318:      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH
        1: 3319:               || context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH_NO_DEFAULT)
        -: 3320:      {
    #####: 3321:        int has_default = (context_p->stack_top_uint8 == PARSER_STATEMENT_SWITCH);
    #####: 3322:        parser_loop_statement_t loop;
    #####: 3323:        parser_switch_statement_t switch_statement;
        -: 3324:
    #####: 3325:        parser_stack_pop_uint8 (context_p);
    #####: 3326:        parser_stack_pop (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 3327:        parser_stack_pop (context_p, &switch_statement, sizeof (parser_switch_statement_t));
    #####: 3328:        parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 3329:
    #####: 3330:        JERRY_ASSERT (switch_statement.branch_list_p == NULL);
        -: 3331:
    #####: 3332:        if (!has_default)
        -: 3333:        {
    #####: 3334:          parser_set_branch_to_current_position (context_p, &switch_statement.default_branch);
        -: 3335:        }
        -: 3336:
    #####: 3337:        parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
    #####: 3338:        lexer_next_token (context_p);
        -: 3339:
        -: 3340:#if JERRY_ESNEXT
    #####: 3341:        if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
    #####: 3342:            || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -: 3343:        {
    #####: 3344:          parser_pop_block_context (context_p);
        -: 3345:        }
        -: 3346:#endif /* JERRY_ESNEXT */
        -: 3347:      }
        1: 3348:      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_TRY)
        -: 3349:      {
    #####: 3350:        parser_parse_try_statement_end (context_p);
        -: 3351:      }
        1: 3352:      else if (context_p->stack_top_uint8 == PARSER_STATEMENT_START)
        -: 3353:      {
        1: 3354:        if (context_p->status_flags & PARSER_IS_CLOSURE)
        -: 3355:        {
        -: 3356:#if JERRY_LINE_INFO
    #####: 3357:          if (context_p->line_info_p == NULL)
        -: 3358:          {
    #####: 3359:            parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3360:          }
        -: 3361:#endif /* JERRY_LINE_INFO */
        -: 3362:
        -: 3363:#if JERRY_FUNCTION_TO_STRING
    #####: 3364:          context_p->function_end_p = context_p->source_p;
        -: 3365:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 3366:
        1: 3367:          parser_stack_pop_uint8 (context_p);
        1: 3368:          context_p->last_statement.current_p = NULL;
        -: 3369:          /* There is no lexer_next_token here, since the
        -: 3370:           * next token belongs to the parent context. */
        1: 3371:          return;
        -: 3372:        }
    #####: 3373:        parser_raise_error (context_p, PARSER_ERR_INVALID_RIGHT_SQUARE);
        -: 3374:      }
        -: 3375:    }
        5: 3376:    else if (context_p->token.type == LEXER_SEMICOLON)
        -: 3377:    {
        5: 3378:      lexer_next_token (context_p);
        -: 3379:    }
    #####: 3380:    else if (context_p->token.type != LEXER_EOS
    #####: 3381:             && !(context_p->token.flags & LEXER_WAS_NEWLINE))
        -: 3382:    {
    #####: 3383:      parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 3384:    }
        -: 3385:
        5: 3386:consume_last_statement:
        -: 3387:    while (true)
        -: 3388:    {
        7: 3389:      switch (context_p->stack_top_uint8)
        -: 3390:      {
    #####: 3391:        case PARSER_STATEMENT_LABEL:
        -: 3392:        {
    #####: 3393:          parser_label_statement_t label;
        -: 3394:
    #####: 3395:          parser_stack_pop_uint8 (context_p);
    #####: 3396:          parser_stack_pop (context_p, &label, sizeof (parser_label_statement_t));
    #####: 3397:          parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 3398:
    #####: 3399:          parser_set_breaks_to_current_position (context_p, label.break_list_p);
    #####: 3400:          continue;
        -: 3401:        }
        -: 3402:
    #####: 3403:        case PARSER_STATEMENT_IF:
        -: 3404:        {
    #####: 3405:          if (parser_parse_if_statement_end (context_p))
        -: 3406:          {
    #####: 3407:            break;
        -: 3408:          }
    #####: 3409:          continue;
        -: 3410:        }
        -: 3411:
    #####: 3412:        case PARSER_STATEMENT_ELSE:
        -: 3413:        {
    #####: 3414:          parser_if_else_statement_t else_statement;
        -: 3415:
    #####: 3416:          parser_stack_pop_uint8 (context_p);
    #####: 3417:          parser_stack_pop (context_p, &else_statement, sizeof (parser_if_else_statement_t));
    #####: 3418:          parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 3419:
    #####: 3420:          parser_set_branch_to_current_position (context_p, &else_statement.branch);
    #####: 3421:          continue;
        -: 3422:        }
        -: 3423:
    #####: 3424:        case PARSER_STATEMENT_DO_WHILE:
        -: 3425:        {
    #####: 3426:          parser_parse_do_while_statement_end (context_p);
    #####: 3427:          if (context_p->token.type == LEXER_SEMICOLON)
        -: 3428:          {
    #####: 3429:            lexer_next_token (context_p);
        -: 3430:          }
    #####: 3431:          continue;
        -: 3432:        }
        -: 3433:
    #####: 3434:        case PARSER_STATEMENT_WHILE:
        -: 3435:        {
    #####: 3436:          parser_parse_while_statement_end (context_p);
    #####: 3437:          continue;
        -: 3438:        }
        -: 3439:
        1: 3440:        case PARSER_STATEMENT_FOR:
        -: 3441:        {
        1: 3442:          parser_parse_for_statement_end (context_p);
        1: 3443:          continue;
        -: 3444:        }
        -: 3445:
    #####: 3446:        case PARSER_STATEMENT_FOR_IN:
        -: 3447:#if JERRY_ESNEXT
        -: 3448:        case PARSER_STATEMENT_FOR_OF:
        -: 3449:        case PARSER_STATEMENT_FOR_AWAIT_OF:
        -: 3450:#endif /* JERRY_ESNEXT */
        -: 3451:        {
    #####: 3452:          parser_for_in_of_statement_t for_in_of_statement;
    #####: 3453:          parser_loop_statement_t loop;
        -: 3454:
        -: 3455:#if JERRY_ESNEXT
    #####: 3456:          uint8_t for_type = context_p->stack_top_uint8;
        -: 3457:#endif /* JERRY_ESNEXT */
        -: 3458:
    #####: 3459:          parser_stack_pop_uint8 (context_p);
    #####: 3460:          parser_stack_pop (context_p, &loop, sizeof (parser_loop_statement_t));
    #####: 3461:          parser_stack_pop (context_p, &for_in_of_statement, sizeof (parser_for_in_of_statement_t));
    #####: 3462:          parser_stack_iterator_init (context_p, &context_p->last_statement);
        -: 3463:
    #####: 3464:          parser_set_continues_to_current_position (context_p, loop.branch_list_p);
        -: 3465:
    #####: 3466:          parser_flush_cbc (context_p);
        -: 3467:
    #####: 3468:          uint16_t stack_allocation = PARSER_FOR_IN_CONTEXT_STACK_ALLOCATION;
        -: 3469:#if JERRY_ESNEXT
    #####: 3470:          if (for_type != PARSER_STATEMENT_FOR_IN)
        -: 3471:          {
    #####: 3472:            stack_allocation = (for_type == PARSER_STATEMENT_FOR_OF ? PARSER_FOR_OF_CONTEXT_STACK_ALLOCATION
        -: 3473:                                                                    : PARSER_FOR_AWAIT_OF_CONTEXT_STACK_ALLOCATION);
        -: 3474:          }
        -: 3475:#endif /* JERRY_ESNEXT */
        -: 3476:
    #####: 3477:          PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, stack_allocation);
        -: 3478:#ifndef JERRY_NDEBUG
    #####: 3479:          PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, stack_allocation);
        -: 3480:#endif /* !JERRY_NDEBUG */
        -: 3481:
    #####: 3482:          cbc_ext_opcode_t opcode = CBC_EXT_BRANCH_IF_FOR_IN_HAS_NEXT;
        -: 3483:
        -: 3484:#if JERRY_ESNEXT
    #####: 3485:          if (for_type != PARSER_STATEMENT_FOR_IN)
        -: 3486:          {
    #####: 3487:            opcode = (for_type == PARSER_STATEMENT_FOR_OF ? CBC_EXT_BRANCH_IF_FOR_OF_HAS_NEXT
    #####: 3488:                                                          : CBC_EXT_BRANCH_IF_FOR_AWAIT_OF_HAS_NEXT);
        -: 3489:          }
        -: 3490:#endif /* JERRY_ESNEXT */
        -: 3491:
    #####: 3492:          parser_emit_cbc_ext_backward_branch (context_p, opcode, for_in_of_statement.start_offset);
        -: 3493:
    #####: 3494:          parser_set_breaks_to_current_position (context_p, loop.branch_list_p);
    #####: 3495:          parser_set_branch_to_current_position (context_p, &for_in_of_statement.branch);
        -: 3496:
        -: 3497:#if JERRY_ESNEXT
    #####: 3498:          if (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE
    #####: 3499:              || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)
        -: 3500:          {
    #####: 3501:            parser_pop_block_context (context_p);
        -: 3502:          }
        -: 3503:#endif /* JERRY_ESNEXT */
    #####: 3504:          continue;
        -: 3505:        }
        -: 3506:
    #####: 3507:        case PARSER_STATEMENT_WITH:
        -: 3508:        {
    #####: 3509:          parser_parse_with_statement_end (context_p);
    #####: 3510:          continue;
        -: 3511:        }
        -: 3512:
        5: 3513:        default:
        -: 3514:        {
        5: 3515:          break;
        -: 3516:        }
        -: 3517:      }
        5: 3518:      break;
        -: 3519:    }
        -: 3520:  }
        -: 3521:
        1: 3522:  parser_stack_pop_uint8 (context_p);
        1: 3523:  context_p->last_statement.current_p = NULL;
        -: 3524:
        1: 3525:  if (context_p->status_flags & PARSER_IS_CLOSURE)
        -: 3526:  {
    #####: 3527:    parser_raise_error (context_p, PARSER_ERR_STATEMENT_EXPECTED);
        -: 3528:  }
        -: 3529:
        -: 3530:#if JERRY_LINE_INFO
    #####: 3531:  if (context_p->line_info_p == NULL)
        -: 3532:  {
    #####: 3533:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3534:  }
        -: 3535:#endif /* JERRY_LINE_INFO */
        -: 3536:} /* parser_parse_statements */
        -: 3537:
        -: 3538:/**
        -: 3539: * Free jumps stored on the stack if a parse error is occured.
        -: 3540: */
        -: 3541:void JERRY_ATTR_NOINLINE
    #####: 3542:parser_free_jumps (parser_stack_iterator_t iterator) /**< iterator position */
        -: 3543:{
        -: 3544:  while (true)
    #####: 3545:  {
    #####: 3546:    uint8_t type = parser_stack_iterator_read_uint8 (&iterator);
    #####: 3547:    parser_branch_node_t *branch_list_p = NULL;
        -: 3548:
    #####: 3549:    switch (type)
        -: 3550:    {
    #####: 3551:      case PARSER_STATEMENT_START:
        -: 3552:      {
    #####: 3553:        return;
        -: 3554:      }
        -: 3555:
    #####: 3556:      case PARSER_STATEMENT_LABEL:
        -: 3557:      {
    #####: 3558:        parser_label_statement_t label;
        -: 3559:
    #####: 3560:        parser_stack_iterator_skip (&iterator, 1);
    #####: 3561:        parser_stack_iterator_read (&iterator, &label, sizeof (parser_label_statement_t));
    #####: 3562:        parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t));
    #####: 3563:        branch_list_p = label.break_list_p;
    #####: 3564:        break;
        -: 3565:      }
        -: 3566:
    #####: 3567:      case PARSER_STATEMENT_SWITCH:
        -: 3568:      case PARSER_STATEMENT_SWITCH_NO_DEFAULT:
        -: 3569:      {
    #####: 3570:        parser_switch_statement_t switch_statement;
    #####: 3571:        parser_loop_statement_t loop;
        -: 3572:
    #####: 3573:        parser_stack_iterator_skip (&iterator, 1);
    #####: 3574:        parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 3575:        parser_stack_iterator_skip (&iterator, sizeof (parser_loop_statement_t));
    #####: 3576:        parser_stack_iterator_read (&iterator, &switch_statement, sizeof (parser_switch_statement_t));
    #####: 3577:        parser_stack_iterator_skip (&iterator, sizeof (parser_switch_statement_t));
        -: 3578:
    #####: 3579:        branch_list_p = switch_statement.branch_list_p;
    #####: 3580:        while (branch_list_p != NULL)
        -: 3581:        {
    #####: 3582:          parser_branch_node_t *next_p = branch_list_p->next_p;
    #####: 3583:          parser_free (branch_list_p, sizeof (parser_branch_node_t));
    #####: 3584:          branch_list_p = next_p;
        -: 3585:        }
    #####: 3586:        branch_list_p = loop.branch_list_p;
    #####: 3587:        break;
        -: 3588:      }
        -: 3589:
    #####: 3590:      case PARSER_STATEMENT_DO_WHILE:
        -: 3591:      case PARSER_STATEMENT_WHILE:
        -: 3592:      case PARSER_STATEMENT_FOR:
        -: 3593:      case PARSER_STATEMENT_FOR_IN:
        -: 3594:#if JERRY_ESNEXT
        -: 3595:      case PARSER_STATEMENT_FOR_OF:
        -: 3596:#endif /* JERRY_ESNEXT */
        -: 3597:      {
    #####: 3598:        parser_loop_statement_t loop;
        -: 3599:
    #####: 3600:        parser_stack_iterator_skip (&iterator, 1);
    #####: 3601:        parser_stack_iterator_read (&iterator, &loop, sizeof (parser_loop_statement_t));
    #####: 3602:        parser_stack_iterator_skip (&iterator, parser_statement_length (type) - 1);
    #####: 3603:        branch_list_p = loop.branch_list_p;
    #####: 3604:        break;
        -: 3605:      }
        -: 3606:
    #####: 3607:      default:
        -: 3608:      {
    #####: 3609:        parser_stack_iterator_skip (&iterator, parser_statement_length (type));
    #####: 3610:        continue;
        -: 3611:      }
        -: 3612:    }
        -: 3613:
    #####: 3614:    while (branch_list_p != NULL)
        -: 3615:    {
    #####: 3616:      parser_branch_node_t *next_p = branch_list_p->next_p;
    #####: 3617:      parser_free (branch_list_p, sizeof (parser_branch_node_t));
    #####: 3618:      branch_list_p = next_p;
        -: 3619:    }
        -: 3620:  }
        -: 3621:} /* parser_free_jumps */
        -: 3622:
        -: 3623:/**
        -: 3624: * @}
        -: 3625: * @}
        -: 3626: * @}
        -: 3627: */
        -: 3628:
        -: 3629:#endif /* JERRY_PARSER */
