        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-dataview-object.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jcontext.h"
        -:   17:#include "ecma-function-object.h"
        -:   18:#include "ecma-arraybuffer-object.h"
        -:   19:#include "ecma-shared-arraybuffer-object.h"
        -:   20:#include "ecma-bigint.h"
        -:   21:#include "ecma-builtins.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-helpers.h"
        -:   25:#include "ecma-dataview-object.h"
        -:   26:#include "ecma-typedarray-object.h"
        -:   27:#include "ecma-objects.h"
        -:   28:
        -:   29:#if JERRY_BUILTIN_DATAVIEW
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup ecmadataviewobject ECMA builtin DataView helper functions
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:/**
        -:   39: * Handle calling [[Construct]] of built-in DataView like objects
        -:   40: *
        -:   41: * See also:
        -:   42: *          ECMA-262 v11, 24.3.2.1
        -:   43: *
        -:   44: * @return created DataView object as an ecma-value - if success
        -:   45: *         raised error - otherwise
        -:   46: */
        -:   47:ecma_value_t
    #####:   48:ecma_op_dataview_create (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:   49:                         uint32_t arguments_list_len) /**< number of arguments */
        -:   50:{
    #####:   51:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
    #####:   52:  JERRY_ASSERT (JERRY_CONTEXT (current_new_target_p));
        -:   53:
    #####:   54:  ecma_value_t buffer = arguments_list_len > 0 ? arguments_list_p[0] : ECMA_VALUE_UNDEFINED;
        -:   55:
        -:   56:  /* 2. */
    #####:   57:  if (!ecma_is_value_object (buffer))
        -:   58:  {
    #####:   59:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'buffer' is not an object"));
        -:   60:  }
        -:   61:
    #####:   62:  ecma_object_t *buffer_p = ecma_get_object_from_value (buffer);
        -:   63:
    #####:   64:  if (!(ecma_object_class_is (buffer_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
    #####:   65:        || ecma_object_is_shared_arraybuffer (buffer_p)))
        -:   66:  {
    #####:   67:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'buffer' is not an ArrayBuffer or SharedArrayBuffer"));
        -:   68:  }
        -:   69:
        -:   70:  /* 3. */
    #####:   71:  ecma_number_t offset = 0;
        -:   72:
    #####:   73:  if (arguments_list_len > 1)
        -:   74:  {
    #####:   75:    ecma_value_t offset_value = ecma_op_to_index (arguments_list_p[1], &offset);
    #####:   76:    if (ECMA_IS_VALUE_ERROR (offset_value))
        -:   77:    {
    #####:   78:      return offset_value;
        -:   79:    }
        -:   80:  }
        -:   81:
        -:   82:  /* 4. */
    #####:   83:  if (ecma_arraybuffer_is_detached (buffer_p))
        -:   84:  {
    #####:   85:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:   86:  }
        -:   87:
        -:   88:  /* 5. */
    #####:   89:  ecma_number_t buffer_byte_length = ecma_arraybuffer_get_length (buffer_p);
        -:   90:
        -:   91:  /* 6. */
    #####:   92:  if (offset > buffer_byte_length)
        -:   93:  {
    #####:   94:    return ecma_raise_range_error (ECMA_ERR_MSG ("Start offset is outside the bounds of the buffer"));
        -:   95:  }
        -:   96:
        -:   97:  /* 7. */
        -:   98:  uint32_t view_byte_length;
    #####:   99:  if (arguments_list_len > 2 && !ecma_is_value_undefined (arguments_list_p[2]))
    #####:  100:  {
        -:  101:    /* 8.a */
    #####:  102:    ecma_number_t byte_length_to_index;
    #####:  103:    ecma_value_t byte_length_value = ecma_op_to_index (arguments_list_p[2], &byte_length_to_index);
        -:  104:
    #####:  105:    if (ECMA_IS_VALUE_ERROR (byte_length_value))
        -:  106:    {
    #####:  107:      return byte_length_value;
        -:  108:    }
        -:  109:
        -:  110:    /* 8.b */
    #####:  111:    if (offset + byte_length_to_index > buffer_byte_length)
        -:  112:    {
    #####:  113:      return ecma_raise_range_error (ECMA_ERR_MSG ("Start offset is outside the bounds of the buffer"));
        -:  114:    }
        -:  115:
    #####:  116:    JERRY_ASSERT (byte_length_to_index <= UINT32_MAX);
    #####:  117:    view_byte_length = (uint32_t) byte_length_to_index;
        -:  118:  }
        -:  119:  else
        -:  120:  {
        -:  121:    /* 7.a */
    #####:  122:    view_byte_length = (uint32_t) (buffer_byte_length - offset);
        -:  123:  }
        -:  124:
        -:  125:  /* 9. */
    #####:  126:  ecma_object_t *prototype_obj_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p),
        -:  127:                                                                           ECMA_BUILTIN_ID_DATAVIEW_PROTOTYPE);
    #####:  128:  if (JERRY_UNLIKELY (prototype_obj_p == NULL))
        -:  129:  {
    #####:  130:    return ECMA_VALUE_ERROR;
        -:  131:  }
        -:  132:
        -:  133:  /* 10. */
    #####:  134:  if (ecma_arraybuffer_is_detached (buffer_p))
        -:  135:  {
    #####:  136:    ecma_deref_object (prototype_obj_p);
    #####:  137:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  138:  }
        -:  139:
        -:  140:  /* 9. */
        -:  141:  /* It must happen after 10., because uninitialized object can't be destroyed properly. */
    #####:  142:  ecma_object_t *object_p = ecma_create_object (prototype_obj_p,
        -:  143:                                                sizeof (ecma_dataview_object_t),
        -:  144:                                                ECMA_OBJECT_TYPE_CLASS);
        -:  145:
    #####:  146:  ecma_deref_object (prototype_obj_p);
        -:  147:
        -:  148:  /* 11 - 14. */
    #####:  149:  ecma_dataview_object_t *dataview_obj_p = (ecma_dataview_object_t *) object_p;
    #####:  150:  dataview_obj_p->header.u.cls.type = ECMA_OBJECT_CLASS_DATAVIEW;
    #####:  151:  dataview_obj_p->header.u.cls.u3.length = view_byte_length;
    #####:  152:  dataview_obj_p->buffer_p = buffer_p;
    #####:  153:  dataview_obj_p->byte_offset = (uint32_t) offset;
        -:  154:
    #####:  155:  return ecma_make_object_value (object_p);
        -:  156:} /* ecma_op_dataview_create */
        -:  157:
        -:  158:/**
        -:  159: * Get the DataView object pointer
        -:  160: *
        -:  161: * Note:
        -:  162: *   If the function returns with NULL, the error object has
        -:  163: *   already set, and the caller must return with ECMA_VALUE_ERROR
        -:  164: *
        -:  165: * @return pointer to the dataView if this_arg is a valid dataView object
        -:  166: *         NULL otherwise
        -:  167: */
        -:  168:ecma_dataview_object_t *
    #####:  169:ecma_op_dataview_get_object (ecma_value_t this_arg) /**< this argument */
        -:  170:{
    #####:  171:  if (ecma_is_value_object (this_arg))
        -:  172:  {
    #####:  173:    ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  174:
    #####:  175:    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_DATAVIEW))
        -:  176:    {
    #####:  177:      return (ecma_dataview_object_t *) object_p;
        -:  178:    }
        -:  179:  }
        -:  180:
    #####:  181:  ecma_raise_type_error (ECMA_ERR_MSG ("Expected a DataView object"));
    #####:  182:  return NULL;
        -:  183:} /* ecma_op_dataview_get_object */
        -:  184:
        -:  185:/**
        -:  186: * Helper union to specify the system's endiannes
        -:  187: */
        -:  188:typedef union
        -:  189:{
        -:  190:  uint32_t number; /**< for write numeric data */
        -:  191:  char data[sizeof (uint32_t)]; /**< for read numeric data */
        -:  192:} ecma_dataview_endiannes_check_t;
        -:  193:
        -:  194:/**
        -:  195: * Helper function to check the current system endiannes
        -:  196: *
        -:  197: * @return true - if the current system has little endian byteorder
        -:  198: *         false - otherwise
        -:  199: */
        -:  200:static bool
    #####:  201:ecma_dataview_check_little_endian (void)
        -:  202:{
        -:  203:  ecma_dataview_endiannes_check_t checker;
    #####:  204:  checker.number = 0x01;
        -:  205:
    #####:  206:  return checker.data[0] == 0x01;
        -:  207:} /* ecma_dataview_check_little_endian */
        -:  208:
        -:  209:/**
        -:  210: * Helper function for swap bytes if the system's endiannes
        -:  211: * does not match with the requested endiannes.
        -:  212: */
        -:  213:static void
    #####:  214:ecma_dataview_swap_order (bool system_is_little_endian, /**< true - if the system has little endian byteorder
        -:  215:                                                         *   false - otherwise */
        -:  216:                          bool is_little_endian, /**< true - if little endian byteorder is requested
        -:  217:                                                  *   false - otherwise */
        -:  218:                          uint32_t element_size, /**< element size byte according to the Table 49.*/
        -:  219:                          lit_utf8_byte_t *block_p) /**< data block */
        -:  220:{
    #####:  221:  if (system_is_little_endian ^ is_little_endian)
        -:  222:  {
    #####:  223:    for (uint32_t i = 0; i < element_size / 2; i++)
        -:  224:    {
    #####:  225:      lit_utf8_byte_t tmp = block_p[i];
    #####:  226:      block_p[i] = block_p[element_size - i -  1];
    #####:  227:      block_p[element_size - i - 1] = tmp;
        -:  228:    }
        -:  229:  }
    #####:  230:} /* ecma_dataview_swap_order */
        -:  231:
        -:  232:/**
        -:  233: * GetViewValue and SetViewValue abstact operation
        -:  234: *
        -:  235: * See also:
        -:  236: *          ECMA-262 v11, 24.3.1.1
        -:  237: *          ECMA-262 v11, 24.3.1.2
        -:  238: *
        -:  239: * @return ecma value
        -:  240: */
        -:  241:ecma_value_t
    #####:  242:ecma_op_dataview_get_set_view_value (ecma_value_t view, /**< the operation's 'view' argument */
        -:  243:                                     ecma_value_t request_index, /**< the operation's 'requestIndex' argument */
        -:  244:                                     ecma_value_t is_little_endian_value, /**< the operation's
        -:  245:                                                                           *   'isLittleEndian' argument */
        -:  246:                                     ecma_value_t value_to_set, /**< the operation's 'value' argument */
        -:  247:                                     ecma_typedarray_type_t id) /**< the operation's 'type' argument */
        -:  248:{
        -:  249:  /* 1 - 2. */
    #####:  250:  ecma_dataview_object_t *view_p = ecma_op_dataview_get_object (view);
        -:  251:
    #####:  252:  if (JERRY_UNLIKELY (view_p == NULL))
        -:  253:  {
    #####:  254:    return ECMA_VALUE_ERROR;
        -:  255:  }
        -:  256:
    #####:  257:  ecma_object_t *buffer_p = view_p->buffer_p;
    #####:  258:  JERRY_ASSERT (ecma_object_class_is (buffer_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
        -:  259:                || ecma_object_is_shared_arraybuffer (buffer_p));
        -:  260:
        -:  261:  /* 3. */
    #####:  262:  ecma_number_t get_index;
    #####:  263:  ecma_value_t number_index_value = ecma_op_to_index (request_index, &get_index);
        -:  264:
    #####:  265:  if (ECMA_IS_VALUE_ERROR (number_index_value))
        -:  266:  {
    #####:  267:    return number_index_value;
        -:  268:  }
        -:  269:
        -:  270:  /* SetViewValue 4 - 5. */
    #####:  271:  if (!ecma_is_value_empty (value_to_set))
        -:  272:  {
        -:  273:#if JERRY_BUILTIN_BIGINT
    #####:  274:    if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (id))
        -:  275:    {
    #####:  276:      value_to_set = ecma_bigint_to_bigint (value_to_set, true);
        -:  277:
    #####:  278:      if (ECMA_IS_VALUE_ERROR (value_to_set))
        -:  279:      {
    #####:  280:        return value_to_set;
        -:  281:      }
        -:  282:    }
        -:  283:    else
        -:  284:#endif /* JERRY_BUILTIN_BIGINT */
        -:  285:    {
    #####:  286:      ecma_number_t value_to_set_number;
    #####:  287:      ecma_value_t value = ecma_op_to_number (value_to_set, &value_to_set_number);
        -:  288:
    #####:  289:      if (ECMA_IS_VALUE_ERROR (value))
        -:  290:      {
    #####:  291:        return value;
        -:  292:      }
        -:  293:
    #####:  294:      value_to_set = ecma_make_number_value (value_to_set_number);
        -:  295:    }
        -:  296:  }
        -:  297:
        -:  298:  /* GetViewValue 4., SetViewValue 6. */
    #####:  299:  bool is_little_endian = ecma_op_to_boolean (is_little_endian_value);
        -:  300:
    #####:  301:  if (ecma_arraybuffer_is_detached (buffer_p))
        -:  302:  {
    #####:  303:    ecma_free_value (value_to_set);
    #####:  304:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  305:  }
        -:  306:
        -:  307:  /* GetViewValue 7., SetViewValue 9. */
    #####:  308:  uint32_t view_offset = view_p->byte_offset;
        -:  309:
        -:  310:  /* GetViewValue 8., SetViewValue 10. */
    #####:  311:  uint32_t view_size = view_p->header.u.cls.u3.length;
        -:  312:
        -:  313:  /* GetViewValue 9., SetViewValue 11. */
    #####:  314:  uint8_t element_size = (uint8_t) (1 << (ecma_typedarray_helper_get_shift_size (id)));
        -:  315:
        -:  316:  /* GetViewValue 10., SetViewValue 12. */
    #####:  317:  if (get_index + element_size > (ecma_number_t) view_size)
        -:  318:  {
    #####:  319:    ecma_free_value (value_to_set);
    #####:  320:    return ecma_raise_range_error (ECMA_ERR_MSG ("Start offset is outside the bounds of the buffer"));
        -:  321:  }
        -:  322:
        -:  323:  /* GetViewValue 11., SetViewValue 13. */
    #####:  324:  uint32_t buffer_index = (uint32_t) get_index + view_offset;
    #####:  325:  lit_utf8_byte_t *block_p = ecma_arraybuffer_get_buffer (buffer_p) + buffer_index;
        -:  326:
    #####:  327:  bool system_is_little_endian = ecma_dataview_check_little_endian ();
        -:  328:
    #####:  329:  ecma_typedarray_info_t info;
    #####:  330:  info.id = id;
    #####:  331:  info.length = view_size;
    #####:  332:  info.shift = ecma_typedarray_helper_get_shift_size (id);
    #####:  333:  info.element_size = element_size;
    #####:  334:  info.offset = view_p->byte_offset;
    #####:  335:  info.array_buffer_p = buffer_p;
        -:  336:
        -:  337:  /* GetViewValue 12. */
    #####:  338:  if (ecma_is_value_empty (value_to_set))
    #####:  339:  {
    #####:  340:    JERRY_VLA (lit_utf8_byte_t, swap_block_p, element_size);
    #####:  341:    memcpy (swap_block_p, block_p, element_size * sizeof (lit_utf8_byte_t));
    #####:  342:    ecma_dataview_swap_order (system_is_little_endian, is_little_endian, element_size, swap_block_p);
    #####:  343:    info.buffer_p = swap_block_p;
    #####:  344:    return ecma_get_typedarray_element (&info, 0);
        -:  345:  }
    #####:  346:  if (!ecma_number_is_nan (get_index) && get_index <= 0)
        -:  347:  {
    #####:  348:    get_index = 0;
        -:  349:  }
        -:  350:  /* SetViewValue 14. */
    #####:  351:  info.buffer_p = block_p;
    #####:  352:  ecma_value_t set_element = ecma_set_typedarray_element (&info, value_to_set, 0);
    #####:  353:  ecma_free_value (value_to_set);
        -:  354:
    #####:  355:  if (ECMA_IS_VALUE_ERROR (set_element))
        -:  356:  {
    #####:  357:    return set_element;
        -:  358:  }
        -:  359:
    #####:  360:  ecma_dataview_swap_order (system_is_little_endian, is_little_endian, element_size, block_p);
        -:  361:
    #####:  362:  return ECMA_VALUE_UNDEFINED;
        -:  363:} /* ecma_op_dataview_get_set_view_value */
        -:  364:
        -:  365:/**
        -:  366: * Check if the value is dataview
        -:  367: *
        -:  368: * @return true - if value is a DataView object
        -:  369: *         false - otherwise
        -:  370: */
        -:  371:bool
    #####:  372:ecma_is_dataview (ecma_value_t value) /**< the target need to be checked */
        -:  373:{
    #####:  374:  if (!ecma_is_value_object (value))
        -:  375:  {
    #####:  376:    return false;
        -:  377:  }
        -:  378:
    #####:  379:  return ecma_object_class_is (ecma_get_object_from_value (value), ECMA_OBJECT_CLASS_DATAVIEW);
        -:  380:} /* ecma_is_dataview */
        -:  381:
        -:  382:/**
        -:  383: * @}
        -:  384: * @}
        -:  385: */
        -:  386:
        -:  387:#endif /* JERRY_BUILTIN_DATAVIEW */
