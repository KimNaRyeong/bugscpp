        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-number-prototype.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-globals.h"
        -:   24:#include "ecma-helpers.h"
        -:   25:#include "ecma-objects.h"
        -:   26:#include "ecma-string-object.h"
        -:   27:#include "jrt.h"
        -:   28:#include "jrt-libc-includes.h"
        -:   29:#include "lit-char-helpers.h"
        -:   30:
        -:   31:#if JERRY_BUILTIN_NUMBER
        -:   32:
        -:   33:#define ECMA_BUILTINS_INTERNAL
        -:   34:#include "ecma-builtins-internal.h"
        -:   35:
        -:   36:/**
        -:   37: * This object has a custom dispatch function.
        -:   38: */
        -:   39:#define BUILTIN_CUSTOM_DISPATCH
        -:   40:
        -:   41:/**
        -:   42: * List of built-in routine identifiers.
        -:   43: */
        -:   44:enum
        -:   45:{
        -:   46:  ECMA_NUMBER_PROTOTYPE_ROUTINE_START = 0,
        -:   47:  ECMA_NUMBER_PROTOTYPE_VALUE_OF,
        -:   48:  ECMA_NUMBER_PROTOTYPE_TO_STRING,
        -:   49:  ECMA_NUMBER_PROTOTYPE_TO_LOCALE_STRING,
        -:   50:  ECMA_NUMBER_PROTOTYPE_TO_FIXED,
        -:   51:  ECMA_NUMBER_PROTOTYPE_TO_EXPONENTIAL,
        -:   52:  ECMA_NUMBER_PROTOTYPE_TO_PRECISION,
        -:   53:};
        -:   54:
        -:   55:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-number-prototype.inc.h"
        -:   56:#define BUILTIN_UNDERSCORED_ID number_prototype
        -:   57:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   58:
        -:   59:/** \addtogroup ecma ECMA
        -:   60: * @{
        -:   61: *
        -:   62: * \addtogroup ecmabuiltins
        -:   63: * @{
        -:   64: *
        -:   65: * \addtogroup numberprototype ECMA Number.prototype object built-in
        -:   66: * @{
        -:   67: */
        -:   68:
        -:   69:/**
        -:   70: * Helper for rounding numbers
        -:   71: *
        -:   72: * @return rounded number
        -:   73: */
        -:   74:static inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
        -:   75:ecma_builtin_number_prototype_helper_round (lit_utf8_byte_t *digits_p, /**< [in,out] number as a string in decimal
        -:   76:                                                                        *   form */
        -:   77:                                            lit_utf8_size_t num_digits, /**< length of the string representation */
        -:   78:                                            int32_t round_num, /**< number of digits to keep */
        -:   79:                                            int32_t *exponent_p, /**< [in, out] decimal exponent */
        -:   80:                                            bool zero) /**< true if digits_p represents zero */
        -:   81:{
    #####:   82:  if (round_num == 0 && *exponent_p == 0)
        -:   83:  {
    #####:   84:    if (digits_p[0] >= 5)
        -:   85:    {
    #####:   86:      digits_p[0] = '1';
        -:   87:    }
        -:   88:    else
        -:   89:    {
    #####:   90:      digits_p[0] = '0';
        -:   91:    }
        -:   92:
    #####:   93:    return 1;
        -:   94:  }
        -:   95:
    #####:   96:  if (round_num < 1)
        -:   97:  {
    #####:   98:    return 0;
        -:   99:  }
        -:  100:
    #####:  101:  if ((lit_utf8_size_t) round_num >= num_digits || zero)
        -:  102:  {
    #####:  103:    return num_digits;
        -:  104:  }
        -:  105:
    #####:  106:  if (digits_p[round_num] >= '5')
        -:  107:  {
    #####:  108:    digits_p[round_num] = '0';
        -:  109:
    #####:  110:    int i = 1;
        -:  111:
        -:  112:    /* Handle carry number. */
    #####:  113:    for (; i <= round_num; i++)
        -:  114:    {
    #####:  115:      if (++digits_p[round_num - i] <= '9')
        -:  116:      {
        -:  117:        break;
        -:  118:      }
    #####:  119:      digits_p[round_num - i] = '0';
        -:  120:    }
        -:  121:
        -:  122:    /* Prepend highest digit */
    #####:  123:    if (i > round_num)
        -:  124:    {
    #####:  125:      memmove (digits_p + 1, digits_p, num_digits);
    #####:  126:      digits_p[0] = '1';
    #####:  127:      *exponent_p += 1;
        -:  128:    }
        -:  129:  }
        -:  130:
    #####:  131:  return (lit_utf8_size_t) round_num;
        -:  132:} /* ecma_builtin_number_prototype_helper_round */
        -:  133:
        -:  134:/**
        -:  135: * The Number.prototype object's 'toString' and 'toLocaleString' routines
        -:  136: *
        -:  137: * See also:
        -:  138: *          ECMA-262 v5, 15.7.4.2
        -:  139: *          ECMA-262 v5, 15.7.4.7
        -:  140: *
        -:  141: * @return ecma value
        -:  142: *         Returned value must be freed with ecma_free_value.
        -:  143: */
        -:  144:static ecma_value_t
    #####:  145:ecma_builtin_number_prototype_object_to_string (ecma_number_t this_arg_number, /**< this argument number */
        -:  146:                                                const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  147:                                                uint32_t arguments_list_len) /**< number of arguments */
        -:  148:{
        -:  149:  static const lit_utf8_byte_t digit_chars[36] =
        -:  150:  {
        -:  151:    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        -:  152:    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
        -:  153:    'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
        -:  154:    'u', 'v', 'w', 'x', 'y', 'z'
        -:  155:  };
        -:  156:
    #####:  157:  uint32_t radix = 10;
    #####:  158:  if (arguments_list_len > 0 && !ecma_is_value_undefined (arguments_list_p[0]))
        -:  159:  {
    #####:  160:    ecma_number_t arg_num;
        -:  161:
    #####:  162:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arguments_list_p[0], &arg_num)))
        -:  163:    {
    #####:  164:      return ECMA_VALUE_ERROR;
        -:  165:    }
        -:  166:
    #####:  167:    radix = ecma_number_to_uint32 (arg_num);
        -:  168:
    #####:  169:    if (radix < 2 || radix > 36)
        -:  170:    {
    #####:  171:      return ecma_raise_range_error (ECMA_ERR_MSG ("Radix must be between 2 and 36"));
        -:  172:    }
        -:  173:  }
        -:  174:
    #####:  175:  if (ecma_number_is_nan (this_arg_number)
    #####:  176:      || ecma_number_is_infinity (this_arg_number)
    #####:  177:      || ecma_number_is_zero (this_arg_number)
    #####:  178:      || radix == 10)
        -:  179:  {
    #####:  180:    ecma_string_t *ret_str_p = ecma_new_ecma_string_from_number (this_arg_number);
    #####:  181:    return ecma_make_string_value (ret_str_p);
        -:  182:  }
        -:  183:
    #####:  184:  int buff_size = 0;
        -:  185:
    #####:  186:  bool is_number_negative = false;
    #####:  187:  if (ecma_number_is_negative (this_arg_number))
        -:  188:  {
        -:  189:    /* ecma_number_to_decimal can't handle negative numbers, so we get rid of the sign. */
    #####:  190:    this_arg_number = -this_arg_number;
    #####:  191:    is_number_negative = true;
        -:  192:
        -:  193:    /* Add space for the sign in the result. */
    #####:  194:    buff_size += 1;
        -:  195:  }
        -:  196:
        -:  197:  /* Decompose the number. */
    #####:  198:  lit_utf8_byte_t digits[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
    #####:  199:  int32_t exponent;
    #####:  200:  lit_utf8_size_t digit_count = ecma_number_to_decimal (this_arg_number, digits, &exponent);
        -:  201:
        -:  202:  /*
        -:  203:   * The 'exponent' given by 'ecma_number_to_decimal' specifies where the decimal point is located
        -:  204:   * compared to the first digit in 'digits'.
        -:  205:   * For example: 120 -> '12', exp: 3 and 0.012 -> '12', exp: -1
        -:  206:   * We convert it to be location of the decimal point compared to the last digit of 'digits':
        -:  207:   * 120 -> 12 * 10^1 and 0.012 -> 12 * 10^-3
        -:  208:   */
    #####:  209:  exponent = exponent - (int32_t) digit_count;
        -:  210:
        -:  211:  /* 'magnitude' will be the magnitude of the number in the specific radix. */
        -:  212:  int magnitude;
        -:  213:  int required_digits;
    #####:  214:  if (exponent >= 0)
        -:  215:  {
        -:  216:    /*
        -:  217:     * If the exponent is non-negative that means we won't have a fractional part, and can calculate
        -:  218:     * exactly how many digits we will have. This could be done via a mathematic formula, but in rare
        -:  219:     * cases that can cause incorrect results due to precision issues, so we use a loop instead.
        -:  220:     */
    #####:  221:    magnitude = 0;
    #####:  222:    ecma_number_t counter = this_arg_number;
    #####:  223:    while (counter >= radix)
        -:  224:    {
    #####:  225:      counter /= radix;
    #####:  226:      magnitude++;
        -:  227:    }
        -:  228:
        -:  229:    /*
        -:  230:     * The magnitude will only tell us how many digits we have after the first one, so we add one extra.
        -:  231:     * In this case we won't be needing a radix point, so we don't need to worry about space for it.
        -:  232:     */
    #####:  233:    required_digits = magnitude + 1;
        -:  234:  }
        -:  235:  else
        -:  236:  {
        -:  237:    /*
        -:  238:     * We can't know exactly how many digits we will need, since the number may be non-terminating in the
        -:  239:     * new radix, so we will have to estimate it. We do this by first calculating how many zeros we will
        -:  240:     * need in the specific radix before we hit a significant digit. This is calculated from the decimal
        -:  241:     * exponent, which we negate so that we get a positive number in the end.
        -:  242:     */
    #####:  243:    magnitude = (int) floor ((log (10) / log (radix)) * -exponent);
        -:  244:
        -:  245:    /*
        -:  246:     * We also need to add space for significant digits. The worst case is radix == 2, since this will
        -:  247:     * require the most digits. In this case, the upper limit to the number of significant digits we can have is
        -:  248:     * ECMA_NUMBER_FRACTION_WIDTH + 1. This should be sufficient for any number.
        -:  249:     */
    #####:  250:    required_digits = magnitude + ECMA_NUMBER_FRACTION_WIDTH + 1;
        -:  251:
        -:  252:    /*
        -:  253:     * We add an exta slot for the radix point. It is also likely that we will need extra space for a
        -:  254:     * leading zero before the radix point. It's better to add space for that here as well, even if we may not
        -:  255:     * need it, since later we won't be able to do so.
        -:  256:     */
    #####:  257:    buff_size += 2;
        -:  258:  }
        -:  259:
        -:  260:  /*
        -:  261:   * Here we normalize the number so that it is as close to 0 as possible, which will prevent us from losing
        -:  262:   * precision in case of extreme numbers when we later split the number into integer and fractional parts.
        -:  263:   * This has to be done in the specific radix, otherwise it messes up the result, so we use magnitude instead.
        -:  264:   */
    #####:  265:  if (exponent > 0)
        -:  266:  {
    #####:  267:    for (int i = 0; i < magnitude; i++)
        -:  268:    {
    #####:  269:      this_arg_number /= radix;
        -:  270:    }
        -:  271:  }
    #####:  272:  else if (exponent < 0)
        -:  273:  {
    #####:  274:    for (int i = 0; i < magnitude; i++)
        -:  275:    {
    #####:  276:      this_arg_number *= radix;
        -:  277:    }
        -:  278:  }
        -:  279:
        -:  280:  /* Split the number into an integer and a fractional part, since we have to handle them separately. */
    #####:  281:  uint64_t whole = (uint64_t) this_arg_number;
    #####:  282:  ecma_number_t fraction = this_arg_number - (ecma_number_t) whole;
        -:  283:
    #####:  284:  bool should_round = false;
    #####:  285:  if (!ecma_number_is_zero (fraction) && exponent >= 0)
        -:  286:  {
        -:  287:    /*
        -:  288:     * If the exponent is non-negative, and we get a non-zero fractional part, that means
        -:  289:     * the normalization might have introduced a small error, in which case we have to correct it by rounding.
        -:  290:     * We'll add one extra significant digit which we will later use to round.
        -:  291:     */
    #####:  292:    required_digits += 1;
    #####:  293:    should_round = true;
        -:  294:  }
        -:  295:
        -:  296:  /* Get the total required buffer size and allocate the buffer. */
    #####:  297:  buff_size += required_digits;
        -:  298:  ecma_value_t ret_value;
    #####:  299:  JMEM_DEFINE_LOCAL_ARRAY (buff, buff_size, lit_utf8_byte_t);
    #####:  300:  int buff_index = 0;
        -:  301:
        -:  302:  /* Calculate digits for whole part. */
    #####:  303:  while (whole > 0)
        -:  304:  {
    #####:  305:    JERRY_ASSERT (buff_index < buff_size && buff_index < required_digits);
    #####:  306:    buff[buff_index++] = (lit_utf8_byte_t) (whole % radix);
    #####:  307:    whole /= radix;
        -:  308:  }
        -:  309:
        -:  310:  /* The digits are backwards, we need to reverse them. */
    #####:  311:  for (int i = 0; i < buff_index / 2; i++)
        -:  312:  {
    #####:  313:    lit_utf8_byte_t swap = buff[i];
    #####:  314:    buff[i] = buff[buff_index - i - 1];
    #####:  315:    buff[buff_index - i - 1] = swap;
        -:  316:  }
        -:  317:
        -:  318:  /*
        -:  319:   * Calculate where we have to put the radix point relative to the beginning of
        -:  320:   * the new digits. If the exponent is non-negative this will be right after the number.
        -:  321:   */
    #####:  322:  int point = exponent >= 0 ? magnitude + 1: buff_index - magnitude;
        -:  323:
    #####:  324:  if (point < 0)
        -:  325:  {
        -:  326:    /*
        -:  327:     * In this case the radix point will be before the first digit,
        -:  328:     * so we need to leave space for leading zeros.
        -:  329:     */
    #####:  330:    JERRY_ASSERT (exponent < 0);
    #####:  331:    required_digits += point;
        -:  332:  }
        -:  333:
    #####:  334:  JERRY_ASSERT (required_digits <= buff_size);
        -:  335:
        -:  336:  /* Calculate digits for fractional part. */
    #####:  337:  while (buff_index < required_digits)
        -:  338:  {
    #####:  339:    fraction *= radix;
    #####:  340:    lit_utf8_byte_t digit = (lit_utf8_byte_t) floor (fraction);
        -:  341:
    #####:  342:    buff[buff_index++] = digit;
    #####:  343:    fraction -= (ecma_number_t) floor (fraction);
        -:  344:  }
        -:  345:
    #####:  346:  if (should_round)
        -:  347:  {
        -:  348:    /* Consume last digit for rounding. */
    #####:  349:    buff_index--;
    #####:  350:    if (buff[buff_index] > radix / 2)
        -:  351:    {
        -:  352:      /* We should be rounding up. */
    #####:  353:      buff[buff_index - 1]++;
        -:  354:
        -:  355:      /* Propagate carry forward in the digits. */
    #####:  356:      for (int i = buff_index - 1; i > 0 && buff[i] >= radix; i--)
        -:  357:      {
    #####:  358:        buff[i] = (lit_utf8_byte_t) (buff[i] - radix);
    #####:  359:        buff[i - 1]++;
        -:  360:      }
        -:  361:
    #####:  362:      if (buff[0] >= radix)
        -:  363:      {
        -:  364:        /*
        -:  365:         * Carry propagated over the whole number, we need to add a new leading digit.
        -:  366:         * We can use the place of the original rounded digit, we just need to shift everything
        -:  367:         * right by one.
        -:  368:         */
    #####:  369:        memmove (buff + 1, buff, (size_t) buff_index);
    #####:  370:        buff_index++;
    #####:  371:        buff[0] = 1;
        -:  372:      }
        -:  373:    }
        -:  374:  }
        -:  375:
        -:  376:  /* Remove trailing zeros. */
    #####:  377:  while (buff_index - 1 > point && buff[buff_index - 1] == 0)
        -:  378:  {
    #####:  379:    buff_index--;
        -:  380:  }
        -:  381:
        -:  382:  /* Add leading zeros in case place of radix point is negative. */
    #####:  383:  if (point <= 0)
        -:  384:  {
        -:  385:    /* We will have 'point' amount of zeros after the radix point, and +1 before. */
    #####:  386:    int zero_count = -point + 1;
    #####:  387:    memmove (buff + zero_count, buff, (size_t) buff_index);
    #####:  388:    buff_index += zero_count;
        -:  389:
    #####:  390:    for (int i = 0; i < zero_count; i++)
        -:  391:    {
    #####:  392:      buff[i] = 0;
        -:  393:    }
        -:  394:
        -:  395:    /* We now need to place the radix point after the first zero. */
    #####:  396:    point = 1;
        -:  397:  }
        -:  398:
        -:  399:  /* Convert digits to characters. */
    #####:  400:  for (int i = 0; i < buff_index; i++)
        -:  401:  {
    #####:  402:    buff[i] = digit_chars[buff[i]];
        -:  403:  }
        -:  404:
        -:  405:  /* Place radix point to the required position. */
    #####:  406:  if (point < buff_index)
        -:  407:  {
    #####:  408:    memmove (buff + point + 1, buff + point, (size_t) (buff_index - point));
    #####:  409:    buff[point] = '.';
    #####:  410:    buff_index++;
        -:  411:  }
        -:  412:
        -:  413:  /* Add negative sign if necessary. */
    #####:  414:  if (is_number_negative)
        -:  415:  {
    #####:  416:    memmove (buff + 1, buff, (size_t) buff_index);
    #####:  417:    buff[0] = '-';
    #####:  418:    buff_index++;
        -:  419:  }
        -:  420:
    #####:  421:  JERRY_ASSERT (buff_index <= buff_size);
    #####:  422:  ecma_string_t *str_p = ecma_new_ecma_string_from_utf8 (buff, (lit_utf8_size_t) buff_index);
    #####:  423:  ret_value = ecma_make_string_value (str_p);
    #####:  424:  JMEM_FINALIZE_LOCAL_ARRAY (buff);
        -:  425:
    #####:  426:  return ret_value;
        -:  427:} /* ecma_builtin_number_prototype_object_to_string */
        -:  428:
        -:  429:/**
        -:  430: * The Number.prototype object's 'valueOf' routine
        -:  431: *
        -:  432: * See also:
        -:  433: *          ECMA-262 v5, 15.7.4.4
        -:  434: *
        -:  435: * @return ecma value
        -:  436: *         Returned value must be freed with ecma_free_value.
        -:  437: */
        -:  438:static ecma_value_t
    #####:  439:ecma_builtin_number_prototype_object_value_of (ecma_value_t this_arg) /**< this argument */
        -:  440:{
    #####:  441:  if (ecma_is_value_number (this_arg))
        -:  442:  {
    #####:  443:    return this_arg;
        -:  444:  }
    #####:  445:  else if (ecma_is_value_object (this_arg))
        -:  446:  {
    #####:  447:    ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  448:
    #####:  449:    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_NUMBER))
        -:  450:    {
    #####:  451:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  452:
    #####:  453:      JERRY_ASSERT (ecma_is_value_number (ext_object_p->u.cls.u3.value));
        -:  454:
    #####:  455:      return ext_object_p->u.cls.u3.value;
        -:  456:    }
        -:  457:  }
        -:  458:
    #####:  459:  return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a number or a Number object"));
        -:  460:} /* ecma_builtin_number_prototype_object_value_of */
        -:  461:
        -:  462:/**
        -:  463: * Type of number routine
        -:  464: */
        -:  465:typedef enum
        -:  466:{
        -:  467:  NUMBER_ROUTINE_TO_FIXED,       /**< Number.prototype.toFixed: ECMA-262 v11, 20.1.3.3 */
        -:  468:  NUMBER_ROUTINE_TO_EXPONENTIAL, /**< Number.prototype.toExponential: ECMA-262 v11, 20.1.3.2 */
        -:  469:  NUMBER_ROUTINE_TO_PRECISION,   /**< Number.prototype.toPrecision: ECMA-262 v11, 20.1.3.5 */
        -:  470:  NUMBER_ROUTINE__COUNT,         /**< count of the modes */
        -:  471:} number_routine_mode_t;
        -:  472:
        -:  473:/**
        -:  474: * Helper method to convert a number based on the given routine.
        -:  475: */
        -:  476:static ecma_value_t
    #####:  477:ecma_builtin_number_prototype_object_to_number_convert (ecma_number_t this_num, /**< this argument number */
        -:  478:                                                        ecma_value_t arg, /**< routine's argument */
        -:  479:                                                        number_routine_mode_t mode) /**< number routine mode */
        -:  480:{
    #####:  481:  if (ecma_is_value_undefined (arg)
    #####:  482:      && mode == NUMBER_ROUTINE_TO_PRECISION)
        -:  483:  {
    #####:  484:    return ecma_builtin_number_prototype_object_to_string (this_num, NULL, 0);
        -:  485:  }
        -:  486:
    #####:  487:  ecma_number_t arg_num;
    #####:  488:  ecma_value_t to_integer = ecma_op_to_integer (arg, &arg_num);
        -:  489:
    #####:  490:  if (ECMA_IS_VALUE_ERROR (to_integer))
        -:  491:  {
    #####:  492:    return to_integer;
        -:  493:  }
        -:  494:
        -:  495:  /* Argument boundary check for toFixed method */
    #####:  496:  if (mode == NUMBER_ROUTINE_TO_FIXED
    #####:  497:      && (arg_num <= -1 || arg_num >= 101))
        -:  498:  {
    #####:  499:    return ecma_raise_range_error (ECMA_ERR_MSG ("Fraction digits must be between 0 and 100"));
        -:  500:  }
        -:  501:
        -:  502:  /* Handle NaN separately */
    #####:  503:  if (ecma_number_is_nan (this_num))
        -:  504:  {
    #####:  505:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_NAN);
        -:  506:  }
        -:  507:
        -:  508:  /* Get the parameters of the number */
    #####:  509:  lit_utf8_byte_t digits[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
        -:  510:  lit_utf8_size_t num_of_digits;
    #####:  511:  int32_t exponent;
    #####:  512:  int32_t arg_int = ecma_number_to_int32 (arg_num);
    #####:  513:  bool is_zero = ecma_number_is_zero (this_num);
    #####:  514:  bool is_negative = ecma_number_is_negative (this_num);
        -:  515:
    #####:  516:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  517:
    #####:  518:  if (is_negative)
        -:  519:  {
    #####:  520:    if (!is_zero)
        -:  521:    {
    #####:  522:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_MINUS);
        -:  523:    }
        -:  524:
    #####:  525:    this_num *= -1;
        -:  526:  }
        -:  527:
        -:  528:  /* Handle zero separately */
    #####:  529:  if (is_zero)
        -:  530:  {
    #####:  531:    if (mode == NUMBER_ROUTINE_TO_PRECISION)
        -:  532:    {
    #####:  533:      arg_int--;
        -:  534:    }
        -:  535:
    #####:  536:    ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
        -:  537:
    #####:  538:    if (arg_int > 0)
        -:  539:    {
    #####:  540:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_DOT);
        -:  541:    }
        -:  542:
    #####:  543:    for (int32_t i = 0; i < arg_int; i++)
        -:  544:    {
    #####:  545:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
        -:  546:    }
        -:  547:
    #####:  548:    if (mode == NUMBER_ROUTINE_TO_EXPONENTIAL)
        -:  549:    {
    #####:  550:      ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "e+0", 3);
        -:  551:    }
        -:  552:
    #####:  553:    return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  554:  }
        -:  555:
        -:  556:  /* Handle infinity separately */
    #####:  557:  if (ecma_number_is_infinity (this_num))
        -:  558:  {
    #####:  559:    ecma_stringbuilder_append_magic (&builder, LIT_MAGIC_STRING_INFINITY_UL);
    #####:  560:    return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  561:  }
        -:  562:
        -:  563:  /* Argument boundary check for toExponential and toPrecision methods */
    #####:  564:  if (mode == NUMBER_ROUTINE_TO_EXPONENTIAL
    #####:  565:      && (arg_num <= -1 || arg_num >= 101))
        -:  566:  {
    #####:  567:    ecma_stringbuilder_destroy (&builder);
    #####:  568:    return ecma_raise_range_error (ECMA_ERR_MSG ("Fraction digits must be between 0 and 100"));
        -:  569:  }
    #####:  570:  else if (mode == NUMBER_ROUTINE_TO_PRECISION
    #####:  571:          && (arg_num < 1 || arg_num > 100))
        -:  572:  {
    #####:  573:    ecma_stringbuilder_destroy (&builder);
    #####:  574:    return ecma_raise_range_error (ECMA_ERR_MSG ("Precision digits must be between 1 and 100"));
        -:  575:  }
        -:  576:
    #####:  577:  num_of_digits = ecma_number_to_decimal (this_num, digits, &exponent);
        -:  578:
        -:  579:  /* Handle undefined argument */
    #####:  580:  if (ecma_is_value_undefined (arg) && mode == NUMBER_ROUTINE_TO_EXPONENTIAL)
        -:  581:  {
    #####:  582:    arg_int = (int32_t) num_of_digits - 1;
        -:  583:  }
        -:  584:
    #####:  585:  if (mode == NUMBER_ROUTINE_TO_FIXED
    #####:  586:      && exponent > 21)
        -:  587:  {
    #####:  588:    ecma_stringbuilder_destroy (&builder);
        -:  589:
    #####:  590:    if (is_negative)
        -:  591:    {
    #####:  592:      this_num *= -1;
        -:  593:    }
        -:  594:
    #####:  595:    return ecma_builtin_number_prototype_object_to_string (this_num, NULL, 0);
        -:  596:  }
        -:  597:
    #####:  598:  int32_t digits_to_keep = arg_int;
        -:  599:
    #####:  600:  if (mode == NUMBER_ROUTINE_TO_FIXED)
        -:  601:  {
    #####:  602:    digits_to_keep += exponent;
        -:  603:  }
    #####:  604:  else if (mode == NUMBER_ROUTINE_TO_EXPONENTIAL)
        -:  605:  {
    #####:  606:    digits_to_keep += 1;
        -:  607:  }
        -:  608:
    #####:  609:  num_of_digits = ecma_builtin_number_prototype_helper_round (digits,
        -:  610:                                                              num_of_digits,
        -:  611:                                                              digits_to_keep,
        -:  612:                                                              &exponent,
        -:  613:                                                              false);
        -:  614:
        -:  615:  /* toExponent routine and toPrecision cases where the exponent > precision or exponent < -5 */
    #####:  616:  if (mode == NUMBER_ROUTINE_TO_EXPONENTIAL
    #####:  617:      || (mode == NUMBER_ROUTINE_TO_PRECISION
    #####:  618:          && (exponent < -5 || exponent > arg_int)))
        -:  619:  {
        -:  620:    /* Append first digit */
    #####:  621:    ecma_stringbuilder_append_byte (&builder, *digits);
        -:  622:
    #####:  623:    if (mode == NUMBER_ROUTINE_TO_PRECISION)
        -:  624:    {
    #####:  625:      arg_int--;
        -:  626:    }
        -:  627:
    #####:  628:    if (arg_int > 0)
        -:  629:    {
    #####:  630:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_DOT);
        -:  631:    }
        -:  632:
        -:  633:    /* Append significant fraction digits */
    #####:  634:    ecma_stringbuilder_append_raw (&builder, digits + 1, num_of_digits - 1);
        -:  635:
        -:  636:    /* Append leading zeros */
    #####:  637:    for (int32_t i = (int32_t) (num_of_digits); i < arg_int + 1; i++)
        -:  638:    {
    #####:  639:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
        -:  640:    }
        -:  641:
    #####:  642:    ecma_stringbuilder_append_char (&builder, LIT_CHAR_LOWERCASE_E);
        -:  643:
    #####:  644:    if (exponent <= 0)
        -:  645:    {
    #####:  646:      exponent = (-exponent) + 1;
    #####:  647:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_MINUS);
        -:  648:    }
        -:  649:    else
        -:  650:    {
    #####:  651:      exponent -= 1;
    #####:  652:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_PLUS);
        -:  653:    }
        -:  654:
        -:  655:    /* Append exponent part */
    #####:  656:    lit_utf8_size_t exp_size = ecma_uint32_to_utf8_string ((uint32_t) exponent, digits, 3);
    #####:  657:    ecma_stringbuilder_append_raw (&builder, digits, exp_size);
        -:  658:
    #####:  659:    return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  660:  }
        -:  661:
        -:  662:  /* toFixed routine and toPrecision cases where the exponent <= precision and exponent >= -5 */
        -:  663:  lit_utf8_size_t result_digits;
        -:  664:
    #####:  665:  if (mode == NUMBER_ROUTINE_TO_FIXED)
        -:  666:  {
    #####:  667:    result_digits = ((exponent > 0) ? (lit_utf8_size_t) (exponent + arg_int)
    #####:  668:                                    : (lit_utf8_size_t) (arg_int + 1));
        -:  669:  }
        -:  670:  else
        -:  671:  {
    #####:  672:    result_digits = ((exponent <= 0) ? (lit_utf8_size_t) (1 - exponent + arg_int)
    #####:  673:                                     : (lit_utf8_size_t) arg_int);
        -:  674:  }
        -:  675:
        -:  676:  /* Number of digits we copied from digits array */
    #####:  677:  lit_utf8_size_t copied_digits = 0;
        -:  678:
    #####:  679:  if (exponent == 0 && digits_to_keep == 0)
        -:  680:  {
    #####:  681:    ecma_stringbuilder_append_char (&builder, *digits);
    #####:  682:    return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  683:  }
        -:  684:
    #####:  685:  if (exponent <= 0)
        -:  686:  {
    #####:  687:    ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
    #####:  688:    result_digits--;
        -:  689:
    #####:  690:    if (result_digits > 0)
        -:  691:    {
    #####:  692:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_DOT);
        -:  693:
        -:  694:      /* Append leading zeros to the fraction part */
    #####:  695:      for (int32_t i = 0; i < -exponent && result_digits > 0; i++)
        -:  696:      {
    #####:  697:        ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
    #####:  698:        result_digits--;
        -:  699:      }
        -:  700:    }
        -:  701:  }
        -:  702:  else
        -:  703:  {
        -:  704:    /* Append significant digits of integer part */
    #####:  705:    copied_digits = JERRY_MIN (JERRY_MIN (num_of_digits, result_digits), (lit_utf8_size_t) exponent);
    #####:  706:    ecma_stringbuilder_append_raw (&builder, digits, copied_digits);
        -:  707:
    #####:  708:    result_digits -= copied_digits;
    #####:  709:    num_of_digits -= copied_digits;
    #####:  710:    exponent -= (int32_t) copied_digits;
        -:  711:
        -:  712:    /* Append zeros before decimal point */
    #####:  713:    while (exponent > 0 && result_digits > 0)
        -:  714:    {
    #####:  715:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
    #####:  716:      result_digits--;
    #####:  717:      exponent--;
        -:  718:    }
        -:  719:
    #####:  720:    if (result_digits > 0)
        -:  721:    {
    #####:  722:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_DOT);
        -:  723:    }
        -:  724:  }
        -:  725:
    #####:  726:  if (result_digits > 0)
        -:  727:  {
        -:  728:    /* Append significant digits to the fraction part */
    #####:  729:    lit_utf8_size_t to_copy = JERRY_MIN (num_of_digits, result_digits);
    #####:  730:    ecma_stringbuilder_append_raw (&builder, digits + copied_digits, to_copy);
    #####:  731:    result_digits -= to_copy;
        -:  732:
        -:  733:    /* Append leading zeros */
    #####:  734:    while (result_digits > 0)
        -:  735:    {
    #####:  736:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
    #####:  737:      result_digits--;
        -:  738:    }
        -:  739:  }
        -:  740:
    #####:  741:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  742:} /* ecma_builtin_number_prototype_object_to_number_convert */
        -:  743:
        -:  744:/**
        -:  745: * Dispatcher of the built-in's routines
        -:  746: *
        -:  747: * @return ecma value
        -:  748: *         Returned value must be freed with ecma_free_value.
        -:  749: */
        -:  750:ecma_value_t
    #####:  751:ecma_builtin_number_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  752:                                                ecma_value_t this_arg, /**< 'this' argument value */
        -:  753:                                                const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  754:                                                                                        *   passed to routine */
        -:  755:                                                uint32_t arguments_number) /**< length of arguments' list */
        -:  756:{
    #####:  757:  ecma_value_t this_value = ecma_builtin_number_prototype_object_value_of (this_arg);
        -:  758:
    #####:  759:  if (ECMA_IS_VALUE_ERROR (this_value))
        -:  760:  {
    #####:  761:    return this_value;
        -:  762:  }
        -:  763:
    #####:  764:  if (builtin_routine_id == ECMA_NUMBER_PROTOTYPE_VALUE_OF)
        -:  765:  {
    #####:  766:    return ecma_copy_value (this_value);
        -:  767:  }
        -:  768:
    #####:  769:  ecma_number_t this_arg_number = ecma_get_number_from_value (this_value);
        -:  770:
    #####:  771:  switch (builtin_routine_id)
        -:  772:  {
    #####:  773:    case ECMA_NUMBER_PROTOTYPE_TO_STRING:
        -:  774:    {
    #####:  775:      return ecma_builtin_number_prototype_object_to_string (this_arg_number, arguments_list_p, arguments_number);
        -:  776:    }
    #####:  777:    case ECMA_NUMBER_PROTOTYPE_TO_LOCALE_STRING:
        -:  778:    {
    #####:  779:      return ecma_builtin_number_prototype_object_to_string (this_arg_number, NULL, 0);
        -:  780:    }
    #####:  781:    case ECMA_NUMBER_PROTOTYPE_TO_FIXED:
        -:  782:    case ECMA_NUMBER_PROTOTYPE_TO_EXPONENTIAL:
        -:  783:    case ECMA_NUMBER_PROTOTYPE_TO_PRECISION:
        -:  784:    {
    #####:  785:      const int option = NUMBER_ROUTINE_TO_FIXED + (builtin_routine_id - ECMA_NUMBER_PROTOTYPE_TO_FIXED);
    #####:  786:      return ecma_builtin_number_prototype_object_to_number_convert (this_arg_number,
        -:  787:                                                                     arguments_list_p[0],
        -:  788:                                                                     (number_routine_mode_t) option);
        -:  789:    }
    #####:  790:    default:
        -:  791:    {
    #####:  792:      JERRY_UNREACHABLE ();
        -:  793:    }
        -:  794:  }
        -:  795:} /* ecma_builtin_number_prototype_dispatch_routine */
        -:  796:
        -:  797:/**
        -:  798: * @}
        -:  799: * @}
        -:  800: * @}
        -:  801: */
        -:  802:
        -:  803:#endif /* JERRY_BUILTIN_NUMBER */
