        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-line-info-create.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-line-info.h"
        -:   17:#include "js-parser-internal.h"
        -:   18:
        -:   19:#if JERRY_PARSER
        -:   20:
        -:   21:#if JERRY_LINE_INFO
        -:   22:
        -:   23:/* \addtogroup parser Parser
        -:   24: * @{
        -:   25: *
        -:   26: * \addtogroup jsparser JavaScript
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup jsparser_line_info_create Create line info data
        -:   30: * @{
        -:   31: */
        -:   32:
        -:   33:/*
        -:   34: * The line-info data structure uses two number encodings:
        -:   35: *
        -:   36: * Vlq (variable length quantity):
        -:   37: *    Each byte has 7 bit data and the highest bit is set for continuation.
        -:   38: *    The format is big endian.
        -:   39: *
        -:   40: * Small:
        -:   41: *    One byte can encode signed values between 127 and -126.
        -:   42: *    Two byte can encode signed values between 319 and -318.
        -:   43: *    Large values are encoded with vlq with a prefix byte.
        -:   44: *
        -:   45: * The line-info data structure is a sequence of chunks:
        -:   46: *
        -:   47: *  +------+--------------+------------+----------------+
        -:   48: *  | Line | StreamLength | StreamData | [ByteCodeSize] |
        -:   49: *  +------+--------------+------------+----------------+
        -:   50: *
        -:   51: *  Line [Vlq encoding]:
        -:   52: *      Specifies the start line of this chunk, relative to its previous value.
        -:   53: *      The starting column is always ECMA_LINE_INFO_COLUMN_DEFAULT
        -:   54: *
        -:   55: *  StreamLength [uint8_t]:
        -:   56: *      Length of the StreamData in bytes minus ECMA_LINE_INFO_STREAM_SIZE_MIN.
        -:   57: *      The 0 value represents the last chunk, which size is not specified
        -:   58: *      (Can be less than ECMA_LINE_INFO_STREAM_SIZE_MIN).
        -:   59: *
        -:   60: *  StreamData [sequence of bytes]:
        -:   61: *      Sequence of the following items:
        -:   62: *
        -:   63: *      +-----------+--------+--------+
        -:   64: *      | EndOffset | [Line] | Column |
        -:   65: *      +-----------+--------+--------+
        -:   66: *
        -:   67: *      EndOffset [Small encoding]:
        -:   68: *          Specifies the EndOffset in the byte code, relative to the previous EndOffset.
        -:   69: *          The range of byte codes corresponding to the line/column position of this item
        -:   70: *          is between the EndOffset of the previous item (inclusive) and the EndOffset
        -:   71: *          of this item (exclusive). The last end offset of a stream is always 0, which
        -:   72: *          represents an unterminated range.
        -:   73: *
        -:   74: *      Line [Small encoding] [Optional]:
        -:   75: *          If bit 1 of end offset is set, this specifies the line position of this item,
        -:   76: *          relative to the previous line position, and the column position is set to
        -:   77: *          ECMA_LINE_INFO_COLUMN_DEFAULT.
        -:   78: *
        -:   79: *      Column [Small encoding]:
        -:   80: *          Specifies the current column position relative to the previous column position.
        -:   81: *
        -:   82: *  ByteCodeSize [Vlq encoding] [Optional]:
        -:   83: *      If StreamLength is not 0, this specifies the byte code size of the whole range.
        -:   84: *      This value can be used to skip the byte codes which line info is stored
        -:   85: *      in this chunk. This information is not available for the last chunk.
        -:   86: */
        -:   87:
        -:   88:/**
        -:   89: * Maximum number of bytes requires to encode a number.
        -:   90: */
        -:   91:#define PARSER_LINE_INFO_BUFFER_MAX_SIZE 6
        -:   92:
        -:   93:/**
        -:   94: * Stream generation ends after this size is reached,
        -:   95: * since there might be not enough place for the next item.
        -:   96: */
        -:   97:#define PARSER_LINE_INFO_STREAM_SIZE_LIMIT \
        -:   98:  (ECMA_LINE_INFO_STREAM_SIZE_MIN + UINT8_MAX - ((2 * PARSER_LINE_INFO_BUFFER_MAX_SIZE) + 1))
        -:   99:
        -:  100:/**
        -:  101: * Page size of line info pages excluding the first one.
        -:  102: */
        -:  103:#define PARSER_LINE_INFO_PAGE_SIZE \
        -:  104:  (sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE)
        -:  105:
        -:  106:/**
        -:  107: * Page size of the first line info page.
        -:  108: */
        -:  109:#define PARSER_LINE_INFO_FIRST_PAGE_SIZE \
        -:  110:  (sizeof (parser_line_info_data_t) + PARSER_LINE_INFO_PAGE_SIZE)
        -:  111:
        -:  112:/**
        -:  113: * Get memory data of the first page.
        -:  114: */
        -:  115:#define PARSER_LINE_INFO_GET_FIRST_PAGE(line_info_p) \
        -:  116:  (((parser_mem_page_t *) ((line_info_p) + 1)))
        -:  117:
        -:  118:/**
        -:  119: * Free line info temporary data collected during parsing.
        -:  120: */
        -:  121:void
    #####:  122:parser_line_info_free (parser_line_info_data_t *line_info_p)
        -:  123:{
    #####:  124:  if (line_info_p == NULL)
        -:  125:  {
        -:  126:    return;
        -:  127:  }
        -:  128:
    #####:  129:  parser_mem_page_t *current_page_p = PARSER_LINE_INFO_GET_FIRST_PAGE (line_info_p)->next_p;
    #####:  130:  parser_free (line_info_p, PARSER_LINE_INFO_FIRST_PAGE_SIZE);
        -:  131:
    #####:  132:  while (current_page_p != NULL)
        -:  133:  {
    #####:  134:    parser_mem_page_t *next_p = current_page_p->next_p;
        -:  135:
    #####:  136:    parser_free (current_page_p, PARSER_LINE_INFO_PAGE_SIZE);
    #####:  137:    current_page_p = next_p;
        -:  138:  }
        -:  139:} /* parser_line_info_free */
        -:  140:
        -:  141:/**
        -:  142: * Encodes an uint32_t number into a buffer. Numbers expected to be larger values.
        -:  143: *
        -:  144: * @return the number of bytes written to the buffer
        -:  145: */
        -:  146:static uint32_t
    #####:  147:parser_line_info_encode_vlq (uint8_t *buffer_p, /**< target buffer */
        -:  148:                             uint32_t value) /**< encoded value */
        -:  149:{
    #####:  150:  if (value <= ECMA_LINE_INFO_VLQ_MASK)
        -:  151:  {
    #####:  152:    *buffer_p = (uint8_t) value;
    #####:  153:    return 1;
        -:  154:  }
        -:  155:
        -:  156:  uint32_t length = 0;
        -:  157:  uint32_t current_value = value;
        -:  158:
        -:  159:  do
        -:  160:  {
    #####:  161:    current_value >>= ECMA_LINE_INFO_VLQ_SHIFT;
    #####:  162:    length++;
        -:  163:  }
    #####:  164:  while (current_value > 0);
        -:  165:
    #####:  166:  buffer_p += length;
        -:  167:
        -:  168:  do
        -:  169:  {
    #####:  170:    *(--buffer_p) = (uint8_t) (value | ECMA_LINE_INFO_VLQ_CONTINUE);
    #####:  171:    value >>= ECMA_LINE_INFO_VLQ_SHIFT;
        -:  172:  }
    #####:  173:  while (value > 0);
        -:  174:
    #####:  175:  buffer_p[length - 1] &= ECMA_LINE_INFO_VLQ_MASK;
    #####:  176:  return length;
        -:  177:} /* parser_line_info_encode_vlq */
        -:  178:
        -:  179:/**
        -:  180: * Encodes an uint32_t number into a buffer. Numbers expected to be smaller values.
        -:  181: *
        -:  182: * @return the number of bytes written to the buffer
        -:  183: */
        -:  184:static uint32_t
    #####:  185:parser_line_info_encode_small (uint8_t *buffer_p, /**< target buffer */
        -:  186:                               uint32_t value) /**< encoded value */
        -:  187:{
    #####:  188:  if (JERRY_LIKELY (value < ECMA_LINE_INFO_ENCODE_TWO_BYTE_MIN))
        -:  189:  {
    #####:  190:    buffer_p[0] = (uint8_t) value;
    #####:  191:    return 1;
        -:  192:  }
        -:  193:
    #####:  194:  if (JERRY_LIKELY (value < ECMA_LINE_INFO_ENCODE_VLQ_MIN))
        -:  195:  {
    #####:  196:    buffer_p[0] = ECMA_LINE_INFO_ENCODE_TWO_BYTE;
    #####:  197:    buffer_p[1] = (uint8_t) (value - ECMA_LINE_INFO_ENCODE_TWO_BYTE_MIN);
    #####:  198:    return 2;
        -:  199:  }
        -:  200:
    #####:  201:  *buffer_p++ = ECMA_LINE_INFO_ENCODE_VLQ;
    #####:  202:  return parser_line_info_encode_vlq (buffer_p, value - ECMA_LINE_INFO_ENCODE_VLQ_MIN) + 1;
        -:  203:} /* parser_line_info_encode_small */
        -:  204:
        -:  205:/**
        -:  206: * Encodes the difference between two values.
        -:  207: *
        -:  208: * @return encoded difference
        -:  209: */
        -:  210:static inline uint32_t JERRY_ATTR_ALWAYS_INLINE
        -:  211:parser_line_info_difference_get (uint32_t current_value, /**< current value */
        -:  212:                                 uint32_t prev_value) /**< previous value */
        -:  213:{
    #####:  214:  uint32_t result = current_value - prev_value - 1;
        -:  215:
    #####:  216:  if (result <= (UINT32_MAX >> 1))
        -:  217:  {
    #####:  218:    return (result << 1) | ECMA_LINE_INFO_INCREASE;
        -:  219:  }
        -:  220:
    #####:  221:  return ((UINT32_MAX - result) << 1) | ECMA_LINE_INFO_DECREASE;
        -:  222:} /* parser_line_info_difference_get */
        -:  223:
        -:  224:/**
        -:  225: * Appends a value at the end of the line info stream.
        -:  226: */
        -:  227:static void
    #####:  228:parser_line_info_append_number (parser_context_t *context_p, /**< context */
        -:  229:                                uint32_t value) /**< value to be encoded */
        -:  230:{
    #####:  231:  parser_line_info_data_t *line_info_p = context_p->line_info_p;
        -:  232:  uint8_t buffer[PARSER_LINE_INFO_BUFFER_MAX_SIZE];
        -:  233:
        -:  234:  JERRY_ASSERT (line_info_p != NULL);
        -:  235:
    #####:  236:  uint32_t length = parser_line_info_encode_vlq (buffer, value);
    #####:  237:  uint8_t offset = line_info_p->last_page_p->bytes[0];
        -:  238:
    #####:  239:  if (offset + length <= PARSER_STACK_PAGE_SIZE)
        -:  240:  {
    #####:  241:    memcpy (line_info_p->last_page_p->bytes + offset, buffer, length);
        -:  242:
    #####:  243:    line_info_p->last_page_p->bytes[0] = (uint8_t) (length + offset);
    #####:  244:    return;
        -:  245:  }
        -:  246:
        -:  247:  parser_mem_page_t *new_page_p;
    #####:  248:  new_page_p = (parser_mem_page_t *) parser_malloc (context_p, PARSER_LINE_INFO_PAGE_SIZE);
        -:  249:
    #####:  250:  new_page_p->next_p = NULL;
        -:  251:
    #####:  252:  line_info_p->last_page_p->next_p = new_page_p;
    #####:  253:  line_info_p->last_page_p = new_page_p;
        -:  254:
    #####:  255:  new_page_p->bytes[0] = (uint8_t) (length + 1);
    #####:  256:  memcpy (new_page_p->bytes + 1, buffer, length);
        -:  257:} /* parser_line_info_append_number */
        -:  258:
        -:  259:/**
        -:  260: * Updates the current line information data.
        -:  261: */
        -:  262:void
    #####:  263:parser_line_info_append (parser_context_t *context_p, /**< context */
        -:  264:                         parser_line_counter_t line, /**< line */
        -:  265:                         parser_line_counter_t column) /**< column */
        -:  266:{
    #####:  267:  parser_line_info_data_t *line_info_p = context_p->line_info_p;
        -:  268:  uint32_t value;
        -:  269:
    #####:  270:  if (line_info_p != NULL)
        -:  271:  {
    #####:  272:    if (line_info_p->byte_code_position == context_p->byte_code_size
    #####:  273:        || (line_info_p->line == line && line_info_p->column == column))
        -:  274:    {
        -:  275:      return;
        -:  276:    }
        -:  277:
        -:  278:    /* Sets ECMA_LINE_INFO_HAS_LINE bit. */
    #####:  279:    value = (uint32_t) (line != line_info_p->line);
        -:  280:  }
        -:  281:  else
        -:  282:  {
    #####:  283:    line_info_p = (parser_line_info_data_t *) parser_malloc (context_p, PARSER_LINE_INFO_FIRST_PAGE_SIZE);
    #####:  284:    context_p->line_info_p = line_info_p;
        -:  285:
    #####:  286:    parser_mem_page_t *page_p = PARSER_LINE_INFO_GET_FIRST_PAGE (line_info_p);
    #####:  287:    page_p->next_p = NULL;
    #####:  288:    page_p->bytes[0] = 1;
        -:  289:
    #####:  290:    line_info_p->last_page_p = page_p;
    #####:  291:    line_info_p->byte_code_position = 0;
    #####:  292:    line_info_p->line = 1;
    #####:  293:    line_info_p->column = 1;
        -:  294:
        -:  295:    /* Sets ECMA_LINE_INFO_HAS_LINE bit. */
    #####:  296:    value = (uint32_t) (line != 1);
        -:  297:  }
        -:  298:
    #####:  299:  value |= ((context_p->byte_code_size - line_info_p->byte_code_position) << 1);
        -:  300:
    #####:  301:  parser_line_info_append_number (context_p, value);
    #####:  302:  line_info_p->byte_code_position = context_p->byte_code_size;
        -:  303:
    #####:  304:  if (value & ECMA_LINE_INFO_HAS_LINE)
        -:  305:  {
    #####:  306:    value = parser_line_info_difference_get (line, line_info_p->line);
    #####:  307:    parser_line_info_append_number (context_p, value);
    #####:  308:    line_info_p->line = line;
        -:  309:  }
        -:  310:
    #####:  311:  value = parser_line_info_difference_get (column, line_info_p->column);
    #####:  312:  parser_line_info_append_number (context_p, value);
    #####:  313:  line_info_p->column = column;
        -:  314:} /* parser_line_info_append */
        -:  315:
        -:  316:/**
        -:  317: * Line info iterator structure
        -:  318: */
        -:  319:typedef struct
        -:  320:{
        -:  321:  parser_mem_page_t *current_page_p; /**< current page */
        -:  322:  uint32_t offset; /**< current offset */
        -:  323:} parser_line_info_iterator_t;
        -:  324:
        -:  325:/**
        -:  326: * Decodes the next value from the iterator stream
        -:  327: */
        -:  328:static uint32_t
    #####:  329:parser_line_info_iterator_get (parser_line_info_iterator_t *iterator_p) /**< iterator */
        -:  330:{
    #####:  331:  uint8_t *source_p = iterator_p->current_page_p->bytes + iterator_p->offset;
    #####:  332:  uint32_t result = ecma_line_info_decode_vlq (&source_p);
        -:  333:
    #####:  334:  iterator_p->offset = (uint32_t) (source_p - iterator_p->current_page_p->bytes);
        -:  335:
        -:  336:  JERRY_ASSERT (iterator_p->offset <= iterator_p->current_page_p->bytes[0]);
        -:  337:
    #####:  338:  if (iterator_p->offset < iterator_p->current_page_p->bytes[0])
        -:  339:  {
        -:  340:    return result;
        -:  341:  }
        -:  342:
    #####:  343:  iterator_p->current_page_p = iterator_p->current_page_p->next_p;
    #####:  344:  iterator_p->offset = 1;
    #####:  345:  return result;
        -:  346:} /* parser_line_info_iterator_get */
        -:  347:
        -:  348:/**
        -:  349: * Generate line info data
        -:  350: *
        -:  351: * @return generated line info data
        -:  352: */
        -:  353:uint8_t *
    #####:  354:parser_line_info_generate (parser_context_t *context_p) /**< context */
        -:  355:{
        -:  356:  parser_line_info_iterator_t iterator;
    #####:  357:  uint8_t *line_info_p = NULL;
    #####:  358:  uint8_t *dst_p = NULL;
    #####:  359:  uint32_t total_length = 0;
    #####:  360:  uint32_t total_length_size = 0;
        -:  361:
        -:  362:  while (true)
    #####:  363:  {
        -:  364:    /* The following code runs twice: first the size of the data,
        -:  365:     * is computed and the data is generated during the second run.
        -:  366:     * Note: line_info_p is NULL during the first run. */
    #####:  367:    parser_mem_page_t *iterator_byte_code_page_p = context_p->byte_code.first_p;
    #####:  368:    uint32_t iterator_byte_code_page_offset = 0;
    #####:  369:    uint32_t iterator_byte_code_base = 0;
    #####:  370:    uint32_t iterator_last_byte_code_offset = UINT32_MAX;
    #####:  371:    uint32_t iterator_prev_line = 0;
    #####:  372:    uint32_t iterator_prev_column = 0;
    #####:  373:    uint32_t iterator_line = 1;
    #####:  374:    uint32_t iterator_column = 1;
        -:  375:    uint8_t block_buffer[PARSER_LINE_INFO_BUFFER_MAX_SIZE];
        -:  376:    uint8_t line_column_buffer[PARSER_LINE_INFO_BUFFER_MAX_SIZE * 2];
    #####:  377:    uint8_t *block_size_p = NULL;
    #####:  378:    uint32_t block_byte_code_offset = 0;
    #####:  379:    uint32_t block_prev_line = 1;
    #####:  380:    uint32_t stream_byte_code_offset = 0;
    #####:  381:    uint32_t stream_current_line = 1;
    #####:  382:    uint32_t stream_current_column = ECMA_LINE_INFO_COLUMN_DEFAULT;
    #####:  383:    uint32_t stream_prev_line = 1;
    #####:  384:    uint32_t stream_prev_column = ECMA_LINE_INFO_COLUMN_DEFAULT;
    #####:  385:    uint32_t stream_size = 0;
    #####:  386:    uint32_t stream_value_count = 0;
        -:  387:    uint32_t value;
        -:  388:
    #####:  389:    iterator.current_page_p = PARSER_LINE_INFO_GET_FIRST_PAGE (context_p->line_info_p);
    #####:  390:    iterator.offset = 1;
        -:  391:
        -:  392:    do
        -:  393:    {
        -:  394:      /* Decode line information generated during parsing. */
    #####:  395:      value = parser_line_info_iterator_get (&iterator);
    #####:  396:      iterator_byte_code_page_offset += (value >> 1);
        -:  397:
    #####:  398:      if (value & 0x1)
        -:  399:      {
    #####:  400:        value = parser_line_info_iterator_get (&iterator);
        -:  401:        JERRY_ASSERT (value != ((0 << 1) | ECMA_LINE_INFO_DECREASE));
    #####:  402:        iterator_line = ecma_line_info_difference_update (iterator_line, value);
        -:  403:      }
        -:  404:
    #####:  405:      value = parser_line_info_iterator_get (&iterator);
    #####:  406:      iterator_column = ecma_line_info_difference_update (iterator_column, value);
        -:  407:
    #####:  408:      while (iterator_byte_code_page_offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  409:      {
    #####:  410:        uint8_t relative_offset = iterator_byte_code_page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1];
    #####:  411:        iterator_byte_code_base += relative_offset & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  412:        iterator_byte_code_page_offset -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  413:        iterator_byte_code_page_p = iterator_byte_code_page_p->next_p;
        -:  414:      }
        -:  415:
    #####:  416:      uint32_t iterator_byte_code_offset = iterator_byte_code_base;
        -:  417:
    #####:  418:      if (iterator_byte_code_page_offset > 0)
        -:  419:      {
    #####:  420:        uint8_t relative_offset = iterator_byte_code_page_p->bytes[iterator_byte_code_page_offset - 1];
    #####:  421:        iterator_byte_code_offset += relative_offset & CBC_LOWER_SEVEN_BIT_MASK;
        -:  422:      }
        -:  423:
        -:  424:      /* Skip those line/column pairs which byte code was discarded during post processing
        -:  425:       * or does not change line/column (this is possible when multiple skips occures). */
    #####:  426:      if (iterator_byte_code_offset == iterator_last_byte_code_offset
    #####:  427:          || (iterator_line == iterator_prev_line && iterator_column == iterator_prev_column))
        -:  428:      {
    #####:  429:        continue;
        -:  430:      }
        -:  431:
    #####:  432:      iterator_prev_line = iterator_line;
    #####:  433:      iterator_prev_column = iterator_column;
    #####:  434:      iterator_last_byte_code_offset = iterator_byte_code_offset;
        -:  435:
    #####:  436:      if (block_size_p != NULL)
        -:  437:      {
        -:  438:        /* Sets ECMA_LINE_INFO_HAS_LINE bit. */
    #####:  439:        value = (((iterator_byte_code_offset - stream_byte_code_offset) << 1)
    #####:  440:                 | (uint32_t) (stream_prev_line != stream_current_line));
        -:  441:
    #####:  442:        uint32_t line_column_size = 0;
    #####:  443:        uint32_t offset_size = parser_line_info_encode_small (block_buffer, value);
    #####:  444:        stream_byte_code_offset = iterator_byte_code_offset;
        -:  445:
    #####:  446:        if (value & ECMA_LINE_INFO_HAS_LINE)
        -:  447:        {
    #####:  448:          value = parser_line_info_difference_get (stream_current_line, stream_prev_line);
    #####:  449:          line_column_size = parser_line_info_encode_small (line_column_buffer, value);
    #####:  450:          stream_prev_line = stream_current_line;
    #####:  451:          stream_prev_column = ECMA_LINE_INFO_COLUMN_DEFAULT;
        -:  452:        }
        -:  453:
    #####:  454:        value = parser_line_info_difference_get (stream_current_column, stream_prev_column);
    #####:  455:        line_column_size += parser_line_info_encode_small (line_column_buffer + line_column_size, value);
        -:  456:
    #####:  457:        stream_prev_column = stream_current_column;
    #####:  458:        stream_current_line = iterator_line;
    #####:  459:        stream_current_column = iterator_column;
        -:  460:
    #####:  461:        stream_value_count++;
        -:  462:
    #####:  463:        if (stream_value_count < ECMA_LINE_INFO_STREAM_VALUE_COUNT_MAX
    #####:  464:            && (stream_size + offset_size + line_column_size <= PARSER_LINE_INFO_STREAM_SIZE_LIMIT))
        -:  465:        {
    #####:  466:          stream_size += offset_size + line_column_size;
        -:  467:
    #####:  468:          if (line_info_p != NULL)
        -:  469:          {
    #####:  470:            memcpy (dst_p, block_buffer, offset_size);
    #####:  471:            dst_p += offset_size;
    #####:  472:            memcpy (dst_p, line_column_buffer, line_column_size);
    #####:  473:            dst_p += line_column_size;
        -:  474:          }
    #####:  475:          continue;
        -:  476:        }
        -:  477:
        -:  478:        /* Finalize the current chunk. The size of EndOffset is always 1. */
    #####:  479:        stream_size += 1 + line_column_size;
        -:  480:
        -:  481:        JERRY_ASSERT (stream_size > ECMA_LINE_INFO_STREAM_SIZE_MIN
        -:  482:                      && (stream_size - ECMA_LINE_INFO_STREAM_SIZE_MIN) <= UINT8_MAX);
        -:  483:
    #####:  484:        if (line_info_p != NULL)
        -:  485:        {
    #####:  486:          *block_size_p = (uint8_t) (stream_size - ECMA_LINE_INFO_STREAM_SIZE_MIN);
        -:  487:          /* Set EndOffset to 0 and copy the has_line bit. */
    #####:  488:          *dst_p++ = (uint8_t) (block_buffer[0] & ECMA_LINE_INFO_HAS_LINE);
    #####:  489:          memcpy (dst_p, line_column_buffer, line_column_size);
    #####:  490:          dst_p += line_column_size;
        -:  491:        }
        -:  492:        else
        -:  493:        {
    #####:  494:          total_length += stream_size;
    #####:  495:          dst_p = block_buffer;
        -:  496:        }
        -:  497:
    #####:  498:        uint32_t byte_code_diff = iterator_last_byte_code_offset - block_byte_code_offset;
    #####:  499:        dst_p += parser_line_info_encode_vlq (dst_p, byte_code_diff);
    #####:  500:        block_byte_code_offset = iterator_last_byte_code_offset;
        -:  501:
    #####:  502:        if (line_info_p == NULL)
        -:  503:        {
    #####:  504:          total_length += (uint32_t) (dst_p - block_buffer);
        -:  505:        }
        -:  506:      }
        -:  507:
        -:  508:      /* Start a new chunk. */
    #####:  509:      if (line_info_p == NULL)
        -:  510:      {
    #####:  511:        dst_p = block_buffer;
        -:  512:      }
        -:  513:
    #####:  514:      value = parser_line_info_difference_get (iterator_line, block_prev_line);
        -:  515:
    #####:  516:      dst_p += parser_line_info_encode_vlq (dst_p, value);
    #####:  517:      block_size_p = dst_p;
    #####:  518:      dst_p++;
        -:  519:
    #####:  520:      if (line_info_p == NULL)
        -:  521:      {
    #####:  522:        total_length += (uint32_t) (dst_p - block_buffer);
        -:  523:      }
        -:  524:
        -:  525:      block_prev_line = iterator_line;
        -:  526:      stream_current_line = iterator_line;
        -:  527:      stream_current_column = iterator_column;
        -:  528:      stream_prev_line = iterator_line;
        -:  529:      stream_prev_column = ECMA_LINE_INFO_COLUMN_DEFAULT;
        -:  530:      stream_size = 0;
        -:  531:      stream_value_count = 0;
        -:  532:    }
    #####:  533:    while (iterator.current_page_p != NULL);
        -:  534:
    #####:  535:    value = (stream_prev_line != stream_current_line);
        -:  536:
        -:  537:    /* Finalize the last stream */
    #####:  538:    if (line_info_p == NULL)
        -:  539:    {
    #####:  540:      dst_p = line_column_buffer;
    #####:  541:      total_length += stream_size + 1;
        -:  542:    }
        -:  543:    else
        -:  544:    {
    #####:  545:      *block_size_p = 0;
        -:  546:      /* Small encoded value of has_line bit. */
    #####:  547:      *dst_p++ = (uint8_t) value;
        -:  548:    }
        -:  549:
    #####:  550:    if (value)
        -:  551:    {
    #####:  552:      value = parser_line_info_difference_get (stream_current_line, stream_prev_line);
    #####:  553:      dst_p += parser_line_info_encode_small (dst_p, value);
    #####:  554:      stream_prev_column = ECMA_LINE_INFO_COLUMN_DEFAULT;
        -:  555:    }
        -:  556:
    #####:  557:    value = parser_line_info_difference_get (stream_current_column, stream_prev_column);
    #####:  558:    dst_p += parser_line_info_encode_small (dst_p, value);
        -:  559:
    #####:  560:    if (line_info_p == NULL)
        -:  561:    {
    #####:  562:      total_length += (uint32_t) (dst_p - line_column_buffer);
        -:  563:    }
        -:  564:
    #####:  565:    if (line_info_p != NULL)
        -:  566:    {
        -:  567:      break;
        -:  568:    }
        -:  569:
    #####:  570:    total_length_size = parser_line_info_encode_vlq (block_buffer, total_length);
        -:  571:
        -:  572:    /* TODO: Support allocation fail. */
    #####:  573:    line_info_p = (uint8_t *) jmem_heap_alloc_block (total_length + total_length_size);
    #####:  574:    dst_p = line_info_p + parser_line_info_encode_vlq (line_info_p, total_length);
        -:  575:  }
        -:  576:
        -:  577:  JERRY_ASSERT (line_info_p + total_length_size + total_length == dst_p);
        -:  578:
        -:  579:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:  580:  if (context_p->is_show_opcodes)
        -:  581:  {
        -:  582:    ecma_line_info_dump (line_info_p);
        -:  583:  }
        -:  584:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  585:
    #####:  586:  return line_info_p;
        -:  587:} /* parser_line_info_generate */
        -:  588:
        -:  589:#endif /* JERRY_LINE_INFO */
        -:  590:
        -:  591:#endif /* JERRY_PARSER */
        -:  592:
        -:  593:/**
        -:  594: * @}
        -:  595: * @}
        -:  596: * @}
        -:  597: */
