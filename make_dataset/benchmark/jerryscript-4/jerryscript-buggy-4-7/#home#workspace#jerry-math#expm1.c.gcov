        -:    0:Source:/home/workspace/jerry-math/expm1.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: *
        -:   15: * This file is based on work under the following copyright and permission
        -:   16: * notice:
        -:   17: *
        -:   18: *     Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
        -:   19: *
        -:   20: *     Permission to use, copy, modify, and distribute this
        -:   21: *     software is freely granted, provided that this notice
        -:   22: *     is preserved.
        -:   23: *
        -:   24: *     @(#)s_expm1.c 5.1 93/09/24
        -:   25: */
        -:   26:
        -:   27:#include "jerry-math-internal.h"
        -:   28:
        -:   29:/* expm1(x)
        -:   30: * Returns exp(x)-1, the exponential of x minus 1.
        -:   31: *
        -:   32: * Method
        -:   33: *   1. Argument reduction:
        -:   34: *  Given x, find r and integer k such that
        -:   35: *
        -:   36: *               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658
        -:   37: *
        -:   38: *      Here a correction term c will be computed to compensate
        -:   39: *  the error in r when rounded to a floating-point number.
        -:   40: *
        -:   41: *   2. Approximating expm1(r) by a special rational function on
        -:   42: *  the interval [0,0.34658]:
        -:   43: *  Since
        -:   44: *      r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 - r^4/360 + ...
        -:   45: *  we define R1(r*r) by
        -:   46: *      r*(exp(r)+1)/(exp(r)-1) = 2+ r^2/6 * R1(r*r)
        -:   47: *  That is,
        -:   48: *      R1(r**2) = 6/r *((exp(r)+1)/(exp(r)-1) - 2/r)
        -:   49: *         = 6/r * ( 1 + 2.0*(1/(exp(r)-1) - 1/r))
        -:   50: *         = 1 - r^2/60 + r^4/2520 - r^6/100800 + ...
        -:   51: *      We use a special Reme algorithm on [0,0.347] to generate
        -:   52: *   a polynomial of degree 5 in r*r to approximate R1. The
        -:   53: *  maximum error of this polynomial approximation is bounded
        -:   54: *  by 2**-61. In other words,
        -:   55: *      R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5
        -:   56: *  where   Q1  =  -1.6666666666666567384E-2,
        -:   57: *     Q2  =   3.9682539681370365873E-4,
        -:   58: *     Q3  =  -9.9206344733435987357E-6,
        -:   59: *     Q4  =   2.5051361420808517002E-7,
        -:   60: *     Q5  =  -6.2843505682382617102E-9;
        -:   61: *    z   =  r*r,
        -:   62: *  with error bounded by
        -:   63: *      |                  5           |     -61
        -:   64: *      | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2
        -:   65: *      |                              |
        -:   66: *
        -:   67: *  expm1(r) = exp(r)-1 is then computed by the following
        -:   68: *   specific way which minimize the accumulation rounding error:
        -:   69: *                        2     3
        -:   70: *                        r     r    [ 3 - (R1 + R1*r/2)  ]
        -:   71: *        expm1(r) = r + --- + --- * [--------------------]
        -:   72: *                        2     2    [ 6 - r*(3 - R1*r/2) ]
        -:   73: *
        -:   74: *  To compensate the error in the argument reduction, we use
        -:   75: *    expm1(r+c) = expm1(r) + c + expm1(r)*c
        -:   76: *         ~ expm1(r) + c + r*c
        -:   77: *  Thus c+r*c will be added in as the correction terms for
        -:   78: *  expm1(r+c). Now rearrange the term to avoid optimization
        -:   79: *   screw up:
        -:   80: *                  (      2                                    2 )
        -:   81: *                  ({  ( r    [ R1 -  (3 - R1*r/2) ]  )  }    r  )
        -:   82: *   expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )
        -:   83: *                  ({  ( 2    [ 6 - r*(3 - R1*r/2) ]  )  }    2  )
        -:   84: *                  (                                             )
        -:   85: *
        -:   86: *       = r - E
        -:   87: *   3. Scale back to obtain expm1(x):
        -:   88: *  From step 1, we have
        -:   89: *     expm1(x) = either 2^k*[expm1(r)+1] - 1
        -:   90: *              = or     2^k*[expm1(r) + (1-2^-k)]
        -:   91: *   4. Implementation notes:
        -:   92: *  (A). To save one multiplication, we scale the coefficient Qi
        -:   93: *       to Qi*2^i, and replace z by (x^2)/2.
        -:   94: *  (B). To achieve maximum accuracy, we compute expm1(x) by
        -:   95: *    (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)
        -:   96: *    (ii)  if k=0, return r-E
        -:   97: *    (iii) if k=-1, return 0.5*(r-E)-0.5
        -:   98: *    (iv)  if k=1 if r < -0.25, return 2*((r+0.5)- E)
        -:   99: *                  else       return  1.0+2.0*(r-E);
        -:  100: *    (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)
        -:  101: *    (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else
        -:  102: *    (vii) return 2^k(1-((E+2^-k)-r))
        -:  103: *
        -:  104: * Special cases:
        -:  105: *  expm1(INF) is INF, expm1(NaN) is NaN;
        -:  106: *  expm1(-INF) is -1, and
        -:  107: *  for finite argument, only expm1(0)=0 is exact.
        -:  108: *
        -:  109: * Accuracy:
        -:  110: *  according to an error analysis, the error is always less than
        -:  111: *  1 ulp (unit in the last place).
        -:  112: *
        -:  113: * Misc. info.
        -:  114: *  For IEEE double
        -:  115: *      if x >  7.09782712893383973096e+02 then expm1(x) overflow
        -:  116: *
        -:  117: * Constants:
        -:  118: * The hexadecimal values are the intended ones for the following
        -:  119: * constants. The decimal values may be used, provided that the
        -:  120: * compiler will convert from decimal to binary accurately enough
        -:  121: * to produce the hexadecimal values shown.
        -:  122: */
        -:  123:
        -:  124:#define one 1.0
        -:  125:#define huge 1.0e+300
        -:  126:#define tiny 1.0e-300
        -:  127:#define o_threshold 7.09782712893383973096e+02 /* 0x40862E42, 0xFEFA39EF */
        -:  128:#define ln2_hi 6.93147180369123816490e-01      /* 0x3fe62e42, 0xfee00000 */
        -:  129:#define ln2_lo 1.90821492927058770002e-10      /* 0x3dea39ef, 0x35793c76 */
        -:  130:#define invln2 1.44269504088896338700e+00      /* 0x3ff71547, 0x652b82fe */
        -:  131:
        -:  132:/* Scaled Q's: Qn_here = 2**n * Qn_above, for R(2*z) where z = hxs = x*x/2: */
        -:  133:#define Q1 -3.33333333333331316428e-02 /* BFA11111 111110F4 */
        -:  134:#define Q2 1.58730158725481460165e-03  /* 3F5A01A0 19FE5585 */
        -:  135:#define Q3 -7.93650757867487942473e-05 /* BF14CE19 9EAADBB7 */
        -:  136:#define Q4 4.00821782732936239552e-06  /* 3ED0CFCA 86E65239 */
        -:  137:#define Q5 -2.01099218183624371326e-07 /* BE8AFDB7 6E09C32D */
        -:  138:
        -:  139:double
    #####:  140:expm1 (double x)
        -:  141:{
        -:  142:  double y, hi, lo, c, e, hxs, hfx, r1;
        -:  143:  double_accessor t, twopk;
        -:  144:  int k, xsb;
        -:  145:  unsigned int hx;
        -:  146:
    #####:  147:  hx = __HI (x);
    #####:  148:  xsb = hx & 0x80000000; /* sign bit of x */
    #####:  149:  hx &= 0x7fffffff;      /* high word of |x| */
        -:  150:
        -:  151:  /* filter out huge and non-finite argument */
    #####:  152:  if (hx >= 0x4043687A)
        -:  153:  {
        -:  154:    /* if |x|>=56*ln2 */
    #####:  155:    if (hx >= 0x40862E42)
        -:  156:    {
        -:  157:      /* if |x|>=709.78... */
    #####:  158:      if (hx >= 0x7ff00000)
        -:  159:      {
        -:  160:        unsigned int low;
    #####:  161:        low = __LO (x);
    #####:  162:        if (((hx & 0xfffff) | low) != 0)
        -:  163:        {
        -:  164:          /* NaN */
    #####:  165:          return x + x;
        -:  166:        }
        -:  167:        else
        -:  168:        {
        -:  169:          /* exp(+-inf)-1={inf,-1} */
    #####:  170:          return (xsb == 0) ? x : -1.0;
        -:  171:        }
        -:  172:      }
    #####:  173:      if (x > o_threshold)
        -:  174:      {
        -:  175:        /* overflow */
    #####:  176:        return huge * huge;
        -:  177:      }
        -:  178:    }
    #####:  179:    if (xsb != 0)
        -:  180:    {
        -:  181:      /* x < -56*ln2, return -1.0 with inexact */
    #####:  182:      if (x + tiny < 0.0) /* raise inexact */
        -:  183:      {
        -:  184:        /* return -1 */
        -:  185:        return tiny - one;
        -:  186:      }
        -:  187:    }
        -:  188:  }
        -:  189:
        -:  190:  /* argument reduction */
    #####:  191:  if (hx > 0x3fd62e42)
        -:  192:  {
        -:  193:    /* if  |x| > 0.5 ln2 */
    #####:  194:    if (hx < 0x3FF0A2B2)
        -:  195:    {
        -:  196:      /* and |x| < 1.5 ln2 */
    #####:  197:      if (xsb == 0)
        -:  198:      {
    #####:  199:        hi = x - ln2_hi;
    #####:  200:        lo = ln2_lo;
    #####:  201:        k = 1;
        -:  202:      }
        -:  203:      else
        -:  204:      {
    #####:  205:        hi = x + ln2_hi;
    #####:  206:        lo = -ln2_lo;
    #####:  207:        k = -1;
        -:  208:      }
        -:  209:    }
        -:  210:    else
        -:  211:    {
    #####:  212:      k = (int) (invln2 * x + ((xsb == 0) ? 0.5 : -0.5));
    #####:  213:      t.dbl = k;
    #####:  214:      hi = x - t.dbl * ln2_hi; /* t*ln2_hi is exact here */
    #####:  215:      lo = t.dbl * ln2_lo;
        -:  216:    }
    #####:  217:    x = hi - lo;
    #####:  218:    c = (hi - x) - lo;
        -:  219:  }
    #####:  220:  else if (hx < 0x3c900000)
        -:  221:  {
        -:  222:    /* when |x|<2**-54, return x */
        -:  223:    return x;
        -:  224:  }
        -:  225:  else
        -:  226:  {
        -:  227:    k = 0;
        -:  228:  }
        -:  229:
        -:  230:  /* x is now in primary range */
    #####:  231:  hfx = 0.5 * x;
    #####:  232:  hxs = x * hfx;
    #####:  233:  r1 = one + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));
    #####:  234:  t.dbl = 3.0 - r1 * hfx;
    #####:  235:  e = hxs * ((r1 - t.dbl) / (6.0 - x * t.dbl));
    #####:  236:  if (k == 0)
        -:  237:  {
        -:  238:    /* c is 0 */
    #####:  239:    return x - (x * e - hxs);
        -:  240:  }
        -:  241:  else
        -:  242:  {
    #####:  243:    twopk.as_int.hi = 0x3ff00000 + ((unsigned int) k << 20); /* 2^k */
    #####:  244:    twopk.as_int.lo = 0;
    #####:  245:    e = (x * (e - c) - c);
    #####:  246:    e -= hxs;
    #####:  247:    if (k == -1)
        -:  248:    {
    #####:  249:      return 0.5 * (x - e) - 0.5;
        -:  250:    }
    #####:  251:    if (k == 1)
        -:  252:    {
    #####:  253:      if (x < -0.25)
        -:  254:      {
    #####:  255:        return -2.0 * (e - (x + 0.5));
        -:  256:      }
        -:  257:      else
        -:  258:      {
    #####:  259:        return one + 2.0 * (x - e);
        -:  260:      }
        -:  261:    }
    #####:  262:    if ((k <= -2) || (k > 56))
        -:  263:    {
        -:  264:      /* suffice to return exp(x)-1 */
    #####:  265:      y = one - (e - x);
    #####:  266:      if (k == 1024)
        -:  267:      {
    #####:  268:        const double twop1023 = ((double_accessor)
    #####:  269:          {
        -:  270:            .as_int = { .hi = 0x7fe00000, .lo = 0 }
        -:  271:          }
        -:  272:        ).dbl; /* 0x1p1023 */
    #####:  273:        y = y * 2.0 * twop1023;
        -:  274:      }
        -:  275:      else
        -:  276:      {
    #####:  277:        y = y * twopk.dbl;
        -:  278:      }
    #####:  279:      return y - one;
        -:  280:    }
    #####:  281:    t.dbl = one;
    #####:  282:    if (k < 20)
        -:  283:    {
    #####:  284:      t.as_int.hi = (0x3ff00000 - (0x200000 >> k)); /* t=1-2^-k */
    #####:  285:      y = t.dbl - (e - x);
    #####:  286:      y = y * twopk.dbl;
        -:  287:    }
        -:  288:    else
        -:  289:    {
    #####:  290:      t.as_int.hi = ((0x3ff - k) << 20); /* 2^-k */
    #####:  291:      y = x - (e + t.dbl);
    #####:  292:      y += one;
    #####:  293:      y = y * twopk.dbl;
        -:  294:    }
        -:  295:  }
        -:  296:  return y;
        -:  297:} /* expm1 */
        -:  298:
        -:  299:#undef one
        -:  300:#undef huge
        -:  301:#undef tiny
        -:  302:#undef o_threshold
        -:  303:#undef ln2_hi
        -:  304:#undef ln2_lo
        -:  305:#undef invln2
        -:  306:#undef Q1
        -:  307:#undef Q2
        -:  308:#undef Q3
        -:  309:#undef Q4
        -:  310:#undef Q5
