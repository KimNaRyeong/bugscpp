        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-string.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-conversion.h"
        -:   18:#include "ecma-exceptions.h"
        -:   19:#include "ecma-gc.h"
        -:   20:#include "ecma-globals.h"
        -:   21:#include "ecma-helpers.h"
        -:   22:#include "jcontext.h"
        -:   23:#include "jrt.h"
        -:   24:#include "jrt-libc-includes.h"
        -:   25:#include "lit-char-helpers.h"
        -:   26:#include "lit-magic-strings.h"
        -:   27:
        -:   28:/** \addtogroup ecma ECMA
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:JERRY_STATIC_ASSERT (ECMA_STRING_CONTAINER_MASK >= ECMA_STRING_CONTAINER__MAX,
        -:   36:                     ecma_string_container_types_must_be_lower_than_the_container_mask);
        -:   37:
        -:   38:JERRY_STATIC_ASSERT ((ECMA_STRING_MAX_REF | ECMA_STRING_CONTAINER_MASK | ECMA_STATIC_STRING_FLAG) == UINT32_MAX,
        -:   39:                     ecma_string_ref_and_container_fields_should_fill_the_32_bit_field);
        -:   40:
        -:   41:JERRY_STATIC_ASSERT (ECMA_STRING_NOT_ARRAY_INDEX == UINT32_MAX,
        -:   42:                     ecma_string_not_array_index_must_be_equal_to_uint32_max);
        -:   43:
        -:   44:JERRY_STATIC_ASSERT ((ECMA_TYPE_DIRECT_STRING & 0x1) != 0,
        -:   45:                     ecma_type_direct_string_must_be_odd_number);
        -:   46:
        -:   47:JERRY_STATIC_ASSERT (LIT_MAGIC_STRING__COUNT <= ECMA_DIRECT_STRING_MAX_IMM,
        -:   48:                     all_magic_strings_must_be_encoded_as_direct_string);
        -:   49:
        -:   50:JERRY_STATIC_ASSERT ((int) ECMA_DIRECT_STRING_UINT == (int) ECMA_STRING_CONTAINER_UINT32_IN_DESC,
        -:   51:                     ecma_direct_and_container_types_must_match);
        -:   52:
        -:   53:JERRY_STATIC_ASSERT (ECMA_PROPERTY_NAME_TYPE_SHIFT > ECMA_VALUE_SHIFT,
        -:   54:                     ecma_property_name_type_shift_must_be_greater_than_ecma_value_shift);
        -:   55:
        -:   56:JERRY_STATIC_ASSERT (sizeof (ecma_stringbuilder_header_t) <= ECMA_ASCII_STRING_HEADER_SIZE,
        -:   57:                     ecma_stringbuilder_header_must_not_be_larger_than_ecma_ascii_string);
        -:   58:
        -:   59:/**
        -:   60: * Convert a string to an unsigned 32 bit value if possible
        -:   61: *
        -:   62: * @return true if the conversion is successful
        -:   63: *         false otherwise
        -:   64: */
        -:   65:static bool
        1:   66:ecma_string_to_array_index (const lit_utf8_byte_t *string_p, /**< utf-8 string */
        -:   67:                            lit_utf8_size_t string_size, /**< string size */
        -:   68:                            uint32_t *result_p) /**< [out] converted value */
        -:   69:{
        1:   70:  JERRY_ASSERT (string_size > 0 && *string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9);
        -:   71:
        1:   72:  if (*string_p == LIT_CHAR_0)
        -:   73:  {
    #####:   74:    *result_p = 0;
    #####:   75:    return (string_size == 1);
        -:   76:  }
        -:   77:
        1:   78:  if (string_size > ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)
        -:   79:  {
    #####:   80:    return false;
        -:   81:  }
        -:   82:
        1:   83:  uint32_t index = 0;
        1:   84:  const lit_utf8_byte_t *string_end_p = string_p + string_size;
        -:   85:
        1:   86:  if (string_size == ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)
        -:   87:  {
    #####:   88:    string_end_p--;
        -:   89:  }
        -:   90:
        -:   91:  do
        -:   92:  {
        1:   93:    if (*string_p > LIT_CHAR_9 || *string_p < LIT_CHAR_0)
        -:   94:    {
    #####:   95:      return false;
        -:   96:    }
        -:   97:
        1:   98:    index = (index * 10) + (uint32_t) (*string_p++ - LIT_CHAR_0);
        -:   99:  }
        1:  100:  while (string_p < string_end_p);
        -:  101:
        1:  102:  if (string_size < ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)
        -:  103:  {
        1:  104:    *result_p = index;
        1:  105:    return true;
        -:  106:  }
        -:  107:
        -:  108:  /* Overflow must be checked as well when size is
        -:  109:   * equal to ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32. */
    #####:  110:  if (*string_p > LIT_CHAR_9
    #####:  111:      || *string_p < LIT_CHAR_0
    #####:  112:      || index > (UINT32_MAX / 10)
    #####:  113:      || (index == (UINT32_MAX / 10) && *string_p > LIT_CHAR_5))
        -:  114:  {
    #####:  115:    return false;
        -:  116:  }
        -:  117:
    #####:  118:  *result_p = (index * 10) + (uint32_t) (*string_p - LIT_CHAR_0);
    #####:  119:  return true;
        -:  120:} /* ecma_string_to_array_index */
        -:  121:
        -:  122:/**
        -:  123: * Returns the characters and size of a string.
        -:  124: *
        -:  125: * Note:
        -:  126: *   UINT type is not supported
        -:  127: *
        -:  128: * @return byte array start - if the byte array of a string is available
        -:  129: *         NULL - otherwise
        -:  130: */
        -:  131:static const lit_utf8_byte_t *
    #####:  132:ecma_string_get_chars_fast (const ecma_string_t *string_p, /**< ecma-string */
        -:  133:                            lit_utf8_size_t *size_p) /**< [out] size of the ecma string */
        -:  134:{
    #####:  135:  if (ECMA_IS_DIRECT_STRING (string_p))
        -:  136:  {
    #####:  137:    if (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC)
        -:  138:    {
    #####:  139:      uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -:  140:
    #####:  141:      if (id >= LIT_MAGIC_STRING__COUNT)
        -:  142:      {
    #####:  143:        id -= LIT_MAGIC_STRING__COUNT;
        -:  144:
    #####:  145:        *size_p = lit_get_magic_string_ex_size (id);
    #####:  146:        return lit_get_magic_string_ex_utf8 (id);
        -:  147:      }
        -:  148:
    #####:  149:      *size_p = lit_get_magic_string_size (id);
    #####:  150:      return lit_get_magic_string_utf8 (id);
        -:  151:    }
        -:  152:  }
        -:  153:
    #####:  154:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -:  155:
    #####:  156:  switch (ECMA_STRING_GET_CONTAINER (string_p))
        -:  157:  {
    #####:  158:    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -:  159:    {
    #####:  160:      *size_p = ((ecma_short_string_t *) string_p)->size;
    #####:  161:      return ECMA_SHORT_STRING_GET_BUFFER (string_p);
        -:  162:    }
    #####:  163:    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -:  164:    {
    #####:  165:      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
    #####:  166:      *size_p = long_string_p->size;
    #####:  167:      return long_string_p->string_p;
        -:  168:    }
    #####:  169:    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -:  170:    {
    #####:  171:      *size_p = ECMA_ASCII_STRING_GET_SIZE (string_p);
    #####:  172:      return ECMA_ASCII_STRING_GET_BUFFER (string_p);
        -:  173:    }
    #####:  174:    default:
        -:  175:    {
    #####:  176:      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -:  177:
    #####:  178:      lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
    #####:  179:      *size_p = lit_get_magic_string_ex_size (id);
    #####:  180:      return lit_get_magic_string_ex_utf8 (id);
        -:  181:    }
        -:  182:  }
        -:  183:} /* ecma_string_get_chars_fast */
        -:  184:
        -:  185:/**
        -:  186: * Allocate new ecma-string and fill it with reference to ECMA magic string
        -:  187: *
        -:  188: * @return pointer to ecma-string descriptor
        -:  189: */
        -:  190:static ecma_string_t *
    #####:  191:ecma_new_ecma_string_from_magic_string_ex_id (lit_magic_string_ex_id_t id) /**< identifier of externl magic string */
        -:  192:{
    #####:  193:  JERRY_ASSERT (id < lit_get_magic_string_ex_count ());
        -:  194:
    #####:  195:  uintptr_t string_id = (uintptr_t) (id + LIT_MAGIC_STRING__COUNT);
        -:  196:
    #####:  197:  if (JERRY_LIKELY (string_id <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  198:  {
    #####:  199:    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, string_id);
        -:  200:  }
        -:  201:
    #####:  202:  ecma_string_t *string_desc_p = ecma_alloc_string ();
        -:  203:
    #####:  204:  string_desc_p->refs_and_container = ECMA_STRING_CONTAINER_MAGIC_STRING_EX | ECMA_STRING_REF_ONE;
    #####:  205:  string_desc_p->u.magic_string_ex_id = id + LIT_MAGIC_STRING__COUNT;
        -:  206:
    #####:  207:  return string_desc_p;
        -:  208:} /* ecma_new_ecma_string_from_magic_string_ex_id */
        -:  209:
        -:  210:#if JERRY_ESNEXT
        -:  211:/**
        -:  212: * Allocate new ecma-string and fill it with reference to the symbol descriptor
        -:  213: *
        -:  214: * Note:
        -:  215: *     Takes the reference to the string_desc
        -:  216: *
        -:  217: * @return pointer to ecma-string descriptor
        -:  218: */
        -:  219:ecma_string_t *
        2:  220:ecma_new_symbol_from_descriptor_string (ecma_value_t string_desc) /**< ecma-string */
        -:  221:{
        2:  222:  JERRY_ASSERT (!ecma_is_value_symbol (string_desc));
        -:  223:
        2:  224:  ecma_extended_string_t *symbol_p = ecma_alloc_extended_string ();
        2:  225:  symbol_p->header.refs_and_container = ECMA_STRING_REF_ONE | ECMA_STRING_CONTAINER_SYMBOL;
        2:  226:  symbol_p->u.symbol_descriptor = string_desc;
        2:  227:  symbol_p->header.u.hash = (lit_string_hash_t) (((uintptr_t) symbol_p) >> ECMA_SYMBOL_HASH_SHIFT);
        2:  228:  JERRY_ASSERT ((symbol_p->header.u.hash & ECMA_GLOBAL_SYMBOL_FLAG) == 0);
        -:  229:
        2:  230:  return (ecma_string_t *) symbol_p;
        -:  231:} /* ecma_new_symbol_from_descriptor_string */
        -:  232:
        -:  233:/**
        -:  234: * Check whether an ecma-string contains an ecma-symbol
        -:  235: *
        -:  236: * @return true - if the ecma-string contains an ecma-symbol
        -:  237: *         false - otherwise
        -:  238: */
        -:  239:bool
       48:  240:ecma_prop_name_is_symbol (ecma_string_t *string_p) /**< ecma-string */
        -:  241:{
       48:  242:  JERRY_ASSERT (string_p != NULL);
        -:  243:
       48:  244:  return (!ECMA_IS_DIRECT_STRING (string_p)
       48:  245:          && ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_SYMBOL);
        -:  246:} /* ecma_prop_name_is_symbol */
        -:  247:#endif /* JERRY_ESNEXT */
        -:  248:
        -:  249:/**
        -:  250: * Allocate new UTF8 ecma-string and fill it with characters from the given utf8 buffer
        -:  251: *
        -:  252: * @return pointer to ecma-string descriptor
        -:  253: */
        -:  254:static inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE
        -:  255:ecma_new_ecma_string_from_utf8_buffer (lit_utf8_size_t length, /**< length of the buffer */
        -:  256:                                       lit_utf8_size_t size, /**< size of the buffer */
        -:  257:                                       lit_utf8_byte_t **data_p) /**< [out] pointer to the start of the string buffer */
        -:  258:{
       12:  259:  if (JERRY_LIKELY (size <= UINT16_MAX))
        -:  260:  {
       12:  261:    if (JERRY_LIKELY (length == size) && size <= (UINT8_MAX + 1))
        -:  262:    {
        -:  263:      ecma_string_t *string_desc_p;
       12:  264:      string_desc_p = (ecma_string_t *) ecma_alloc_string_buffer (size + ECMA_ASCII_STRING_HEADER_SIZE);
       12:  265:      string_desc_p->refs_and_container = ECMA_STRING_CONTAINER_HEAP_ASCII_STRING | ECMA_STRING_REF_ONE;
       12:  266:      ECMA_ASCII_STRING_SET_SIZE (string_desc_p, size);
        -:  267:
       12:  268:      *data_p = ECMA_ASCII_STRING_GET_BUFFER (string_desc_p);
       12:  269:      return (ecma_string_t *) string_desc_p;
        -:  270:    }
        -:  271:
        -:  272:    ecma_short_string_t *string_desc_p;
    #####:  273:    string_desc_p = (ecma_short_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_short_string_t));
    #####:  274:    string_desc_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_UTF8_STRING | ECMA_STRING_REF_ONE;
    #####:  275:    string_desc_p->size = (uint16_t) size;
    #####:  276:    string_desc_p->length = (uint16_t) length;
        -:  277:
    #####:  278:    *data_p = ECMA_SHORT_STRING_GET_BUFFER (string_desc_p);
    #####:  279:    return (ecma_string_t *) string_desc_p;
        -:  280:  }
        -:  281:
        -:  282:  ecma_long_string_t *long_string_p;
    #####:  283:  long_string_p = (ecma_long_string_t *) ecma_alloc_string_buffer (size + sizeof (ecma_long_string_t));
    #####:  284:  long_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING | ECMA_STRING_REF_ONE;
    #####:  285:  long_string_p->string_p = ECMA_LONG_STRING_BUFFER_START (long_string_p);
    #####:  286:  long_string_p->size = size;
    #####:  287:  long_string_p->length = length;
        -:  288:
    #####:  289:  *data_p = ECMA_LONG_STRING_BUFFER_START (long_string_p);
    #####:  290:  return (ecma_string_t *) long_string_p;
        -:  291:} /* ecma_new_ecma_string_from_utf8_buffer */
        -:  292:
        -:  293:/**
        -:  294: * Checks whether a string has a special representation, that is, the string is either a magic string,
        -:  295: * an external magic string, or an uint32 number, and creates an ecma string using the special representation,
        -:  296: * if available.
        -:  297: *
        -:  298: * @return pointer to ecma string with the special representation
        -:  299: *         NULL, if there is no special representation for the string
        -:  300: */
        -:  301:static ecma_string_t *
       16:  302:ecma_find_special_string (const lit_utf8_byte_t *string_p, /**< utf8 string */
        -:  303:                          lit_utf8_size_t string_size) /**< string size */
        -:  304:{
       16:  305:  JERRY_ASSERT (string_p != NULL || string_size == 0);
       16:  306:  lit_magic_string_id_t magic_string_id = lit_is_utf8_string_magic (string_p, string_size);
        -:  307:
       16:  308:  if (magic_string_id != LIT_MAGIC_STRING__COUNT)
        -:  309:  {
        5:  310:    return ecma_get_magic_string (magic_string_id);
        -:  311:  }
        -:  312:
       11:  313:  JERRY_ASSERT (string_size > 0);
        -:  314:
       11:  315:  if (*string_p >= LIT_CHAR_0 && *string_p <= LIT_CHAR_9)
        -:  316:  {
        1:  317:    uint32_t array_index;
        -:  318:
        1:  319:    if (ecma_string_to_array_index (string_p, string_size, &array_index))
        -:  320:    {
        1:  321:      return ecma_new_ecma_string_from_uint32 (array_index);
        -:  322:    }
        -:  323:  }
        -:  324:
       10:  325:  if (lit_get_magic_string_ex_count () > 0)
        -:  326:  {
    #####:  327:    lit_magic_string_ex_id_t magic_string_ex_id = lit_is_ex_utf8_string_magic (string_p, string_size);
        -:  328:
    #####:  329:    if (magic_string_ex_id < lit_get_magic_string_ex_count ())
        -:  330:    {
    #####:  331:      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);
        -:  332:    }
        -:  333:  }
        -:  334:
       10:  335:  return NULL;
        -:  336:} /* ecma_find_special_string */
        -:  337:
        -:  338:/**
        -:  339: * Allocate new ecma-string and fill it with characters from ascii characters
        -:  340: *
        -:  341: * @return pointer to ecma-string descriptor
        -:  342: */
        -:  343:ecma_string_t *
    #####:  344:ecma_new_ecma_string_from_ascii (const lit_utf8_byte_t *string_p, /**< ascii string */
        -:  345:                                 lit_utf8_size_t string_size) /**< string size */
        -:  346:{
    #####:  347:  JERRY_ASSERT (string_p != NULL || string_size == 0);
        -:  348:
    #####:  349:  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);
        -:  350:
    #####:  351:  if (string_desc_p != NULL)
        -:  352:  {
    #####:  353:    return string_desc_p;
        -:  354:  }
        -:  355:
    #####:  356:  lit_utf8_byte_t *data_p;
    #####:  357:  string_desc_p = ecma_new_ecma_string_from_utf8_buffer (string_size, string_size, &data_p);
        -:  358:
    #####:  359:  string_desc_p->u.hash = lit_utf8_string_calc_hash (string_p, string_size);
    #####:  360:  memcpy (data_p, string_p, string_size);
        -:  361:
    #####:  362:  return string_desc_p;
        -:  363:} /* ecma_new_ecma_string_from_ascii */
        -:  364:
        -:  365:/**
        -:  366: * Allocate new ecma-string and fill it with characters from the utf8 string
        -:  367: *
        -:  368: * @return pointer to ecma-string descriptor
        -:  369: */
        -:  370:ecma_string_t *
       16:  371:ecma_new_ecma_string_from_utf8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */
        -:  372:                                lit_utf8_size_t string_size) /**< string size */
        -:  373:{
       16:  374:  JERRY_ASSERT (string_p != NULL || string_size == 0);
       16:  375:  JERRY_ASSERT (lit_is_valid_cesu8_string (string_p, string_size));
        -:  376:
       16:  377:  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);
        -:  378:
       16:  379:  if (string_desc_p != NULL)
        -:  380:  {
        6:  381:    return string_desc_p;
        -:  382:  }
        -:  383:
       10:  384:  lit_utf8_byte_t *data_p;
       20:  385:  string_desc_p = ecma_new_ecma_string_from_utf8_buffer (lit_utf8_string_length (string_p, string_size),
        -:  386:                                                         string_size,
        -:  387:                                                         &data_p);
        -:  388:
       10:  389:  string_desc_p->u.hash = lit_utf8_string_calc_hash (string_p, string_size);
       10:  390:  memcpy (data_p, string_p, string_size);
        -:  391:
       10:  392:  return string_desc_p;
        -:  393:} /* ecma_new_ecma_string_from_utf8 */
        -:  394:
        -:  395:/**
        -:  396: * Allocate a new ecma-string and initialize it from the utf8 string argument.
        -:  397: * All 4-bytes long unicode sequences are converted into two 3-bytes long sequences.
        -:  398: *
        -:  399: * @return pointer to ecma-string descriptor
        -:  400: */
        -:  401:ecma_string_t *
    #####:  402:ecma_new_ecma_string_from_utf8_converted_to_cesu8 (const lit_utf8_byte_t *string_p, /**< utf-8 string */
        -:  403:                                                   lit_utf8_size_t string_size) /**< utf-8 string size */
        -:  404:{
    #####:  405:  JERRY_ASSERT (string_p != NULL || string_size == 0);
        -:  406:
    #####:  407:  lit_utf8_size_t converted_string_length = 0;
    #####:  408:  lit_utf8_size_t converted_string_size = 0;
    #####:  409:  lit_utf8_size_t pos = 0;
        -:  410:
        -:  411:  /* Calculate the required length and size information of the converted cesu-8 encoded string */
    #####:  412:  while (pos < string_size)
        -:  413:  {
    #####:  414:    if ((string_p[pos] & LIT_UTF8_1_BYTE_MASK) == LIT_UTF8_1_BYTE_MARKER)
        -:  415:    {
    #####:  416:      pos++;
        -:  417:    }
    #####:  418:    else if ((string_p[pos] & LIT_UTF8_2_BYTE_MASK) == LIT_UTF8_2_BYTE_MARKER)
        -:  419:    {
    #####:  420:      pos += 2;
        -:  421:    }
    #####:  422:    else if ((string_p[pos] & LIT_UTF8_3_BYTE_MASK) == LIT_UTF8_3_BYTE_MARKER)
        -:  423:    {
    #####:  424:      pos += 3;
        -:  425:    }
        -:  426:    else
        -:  427:    {
    #####:  428:      JERRY_ASSERT ((string_p[pos] & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER);
    #####:  429:      pos += 4;
    #####:  430:      converted_string_size += 2;
    #####:  431:      converted_string_length++;
        -:  432:    }
        -:  433:
    #####:  434:    converted_string_length++;
        -:  435:  }
        -:  436:
    #####:  437:  JERRY_ASSERT (pos == string_size);
        -:  438:
    #####:  439:  if (converted_string_size == 0)
        -:  440:  {
    #####:  441:    return ecma_new_ecma_string_from_utf8 (string_p, string_size);
        -:  442:  }
        -:  443:
    #####:  444:  converted_string_size += string_size;
        -:  445:
    #####:  446:  JERRY_ASSERT (lit_is_valid_utf8_string (string_p, string_size, false));
        -:  447:
    #####:  448:  lit_utf8_byte_t *data_p;
    #####:  449:  ecma_string_t *string_desc_p = ecma_new_ecma_string_from_utf8_buffer (converted_string_length,
        -:  450:                                                                        converted_string_size,
        -:  451:                                                                        &data_p);
        -:  452:
    #####:  453:  const lit_utf8_byte_t *const begin_data_p = data_p;
    #####:  454:  pos = 0;
        -:  455:
    #####:  456:  while (pos < string_size)
        -:  457:  {
    #####:  458:    if ((string_p[pos] & LIT_UTF8_4_BYTE_MASK) == LIT_UTF8_4_BYTE_MARKER)
        -:  459:    {
        -:  460:      /* Processing 4 byte unicode sequence. Always converted to two 3 byte long sequence. */
    #####:  461:      lit_four_byte_utf8_char_to_cesu8 (data_p, string_p + pos);
    #####:  462:      data_p += 3 * 2;
    #####:  463:      pos += 4;
        -:  464:    }
        -:  465:    else
        -:  466:    {
    #####:  467:      *data_p++ = string_p[pos++];
        -:  468:    }
        -:  469:  }
        -:  470:
    #####:  471:  JERRY_ASSERT (pos == string_size);
        -:  472:
    #####:  473:  string_desc_p->u.hash = lit_utf8_string_calc_hash (begin_data_p, converted_string_size);
        -:  474:
    #####:  475:  return (ecma_string_t *) string_desc_p;
        -:  476:} /* ecma_new_ecma_string_from_utf8_converted_to_cesu8 */
        -:  477:
        -:  478:/**
        -:  479: * Allocate new ecma-external-string and fill it with characters from the cesu8 string
        -:  480: *
        -:  481: * @return pointer to ecma-string descriptor
        -:  482: */
        -:  483:ecma_string_t *
    #####:  484:ecma_new_ecma_external_string_from_cesu8 (const lit_utf8_byte_t *string_p, /**< cesu-8 string */
        -:  485:                                          lit_utf8_size_t string_size, /**< string size */
        -:  486:                                          void *user_p) /**< user pointer passed to the callback
        -:  487:                                                         *   when the string is freed */
        -:  488:{
    #####:  489:  JERRY_ASSERT (string_p != NULL || string_size == 0);
    #####:  490:  JERRY_ASSERT (lit_is_valid_cesu8_string (string_p, string_size));
        -:  491:
    #####:  492:  if (string_size < (sizeof (ecma_external_string_t) - sizeof (ecma_short_string_t)))
        -:  493:  {
        -:  494:    /* Normal strings are created for short strings. */
    #####:  495:    ecma_string_t *string_desc_p = ecma_new_ecma_string_from_utf8 (string_p, string_size);
        -:  496:
    #####:  497:    jerry_external_string_free_callback_t free_cb = JERRY_CONTEXT (external_string_free_callback_p);
        -:  498:
    #####:  499:    if (free_cb != NULL)
        -:  500:    {
    #####:  501:      free_cb ((lit_utf8_byte_t *) string_p, string_size, user_p);
        -:  502:    }
    #####:  503:    return string_desc_p;
        -:  504:  }
        -:  505:
    #####:  506:  ecma_string_t *string_desc_p = ecma_find_special_string (string_p, string_size);
        -:  507:
    #####:  508:  if (string_desc_p != NULL)
        -:  509:  {
    #####:  510:    jerry_external_string_free_callback_t free_cb = JERRY_CONTEXT (external_string_free_callback_p);
        -:  511:
    #####:  512:    if (free_cb != NULL)
        -:  513:    {
    #####:  514:      free_cb ((lit_utf8_byte_t *) string_p, string_size, user_p);
        -:  515:    }
    #####:  516:    return string_desc_p;
        -:  517:  }
        -:  518:
    #####:  519:  ecma_external_string_t *external_string_p = ecma_alloc_external_string ();
    #####:  520:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) external_string_p;
        -:  521:
    #####:  522:  long_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING | ECMA_STRING_REF_ONE;
    #####:  523:  long_string_p->header.u.hash = lit_utf8_string_calc_hash (string_p, string_size);
    #####:  524:  long_string_p->string_p = string_p;
    #####:  525:  long_string_p->size = string_size;
    #####:  526:  long_string_p->length = lit_utf8_string_length (string_p, string_size);
    #####:  527:  external_string_p->user_p = user_p;
        -:  528:
    #####:  529:  return (ecma_string_t *) external_string_p;
        -:  530:} /* ecma_new_ecma_external_string_from_cesu8 */
        -:  531:
        -:  532:/**
        -:  533: * Allocate new ecma-string and fill it with cesu-8 character which represents specified code unit
        -:  534: *
        -:  535: * @return pointer to ecma-string descriptor
        -:  536: */
        -:  537:ecma_string_t *
    #####:  538:ecma_new_ecma_string_from_code_unit (ecma_char_t code_unit) /**< code unit */
        -:  539:{
    #####:  540:  lit_utf8_byte_t lit_utf8_bytes[LIT_UTF8_MAX_BYTES_IN_CODE_UNIT];
    #####:  541:  lit_utf8_size_t bytes_size = lit_code_unit_to_utf8 (code_unit, lit_utf8_bytes);
        -:  542:
    #####:  543:  return ecma_new_ecma_string_from_utf8 (lit_utf8_bytes, bytes_size);
        -:  544:} /* ecma_new_ecma_string_from_code_unit */
        -:  545:
        -:  546:#if JERRY_ESNEXT
        -:  547:
        -:  548:/**
        -:  549: * Allocate new ecma-string and fill it with cesu-8 character which represents specified code units
        -:  550: *
        -:  551: * @return pointer to ecma-string descriptor
        -:  552: */
        -:  553:ecma_string_t *
    #####:  554:ecma_new_ecma_string_from_code_units (ecma_char_t first_code_unit, /**< code unit */
        -:  555:                                      ecma_char_t second_code_unit) /**< code unit */
        -:  556:{
    #####:  557:  lit_utf8_byte_t lit_utf8_bytes[2 * LIT_UTF8_MAX_BYTES_IN_CODE_UNIT];
    #####:  558:  lit_utf8_size_t bytes_size = lit_code_unit_to_utf8 (first_code_unit, lit_utf8_bytes);
    #####:  559:  bytes_size += lit_code_unit_to_utf8 (second_code_unit, lit_utf8_bytes + bytes_size);
        -:  560:
    #####:  561:  return ecma_new_ecma_string_from_utf8 (lit_utf8_bytes, bytes_size);
        -:  562:} /* ecma_new_ecma_string_from_code_units */
        -:  563:
        -:  564:#endif /* JERRY_ESNEXT */
        -:  565:
        -:  566:/**
        -:  567: * Allocate new ecma-string and fill it with ecma-number
        -:  568: *
        -:  569: * Note: the number cannot be represented as direct string
        -:  570: *
        -:  571: * @return pointer to ecma-string descriptor
        -:  572: */
        -:  573:ecma_string_t *
    #####:  574:ecma_new_non_direct_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */
        -:  575:{
    #####:  576:  JERRY_ASSERT (uint32_number > ECMA_DIRECT_STRING_MAX_IMM);
        -:  577:
    #####:  578:  ecma_string_t *string_p = ecma_alloc_string ();
        -:  579:
    #####:  580:  string_p->refs_and_container = ECMA_STRING_CONTAINER_UINT32_IN_DESC | ECMA_STRING_REF_ONE;
    #####:  581:  string_p->u.uint32_number = uint32_number;
        -:  582:
    #####:  583:  return string_p;
        -:  584:} /* ecma_new_non_direct_string_from_uint32 */
        -:  585:
        -:  586:/**
        -:  587: * Allocate new ecma-string and fill it with property length number
        -:  588: *
        -:  589: * @return pointer to ecma-string descriptor
        -:  590: */
        -:  591:ecma_string_t *
    #####:  592:ecma_new_ecma_string_from_length (ecma_length_t number) /**< property length */
        -:  593:{
    #####:  594:  if (JERRY_LIKELY (number <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  595:  {
    #####:  596:    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) number);
        -:  597:  }
        -:  598:
        -:  599:#if JERRY_ESNEXT
    #####:  600:  JERRY_ASSERT ((ecma_number_t) number <= ECMA_NUMBER_MAX_SAFE_INTEGER);
        -:  601:
    #####:  602:  if (JERRY_UNLIKELY (number > UINT32_MAX))
        -:  603:  {
    #####:  604:    return ecma_new_ecma_string_from_number ((ecma_number_t) number);
        -:  605:  }
        -:  606:#endif /* JERRY_ESNEXT */
        -:  607:
    #####:  608:  return ecma_new_non_direct_string_from_uint32 ((uint32_t) number);
        -:  609:} /* ecma_new_ecma_string_from_length */
        -:  610:
        -:  611:/**
        -:  612: * Allocate new ecma-string and fill it with uint32 number
        -:  613: *
        -:  614: * @return pointer to ecma-string descriptor
        -:  615: */
        -:  616:ecma_string_t *
        1:  617:ecma_new_ecma_string_from_uint32 (uint32_t uint32_number) /**< uint32 value of the string */
        -:  618:{
        1:  619:  if (JERRY_LIKELY (uint32_number <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  620:  {
        1:  621:    return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) uint32_number);
        -:  622:  }
        -:  623:
    #####:  624:  return ecma_new_non_direct_string_from_uint32 (uint32_number);
        -:  625:} /* ecma_new_ecma_string_from_uint32 */
        -:  626:
        -:  627:/**
        -:  628: * Returns the constant assigned to the uint32 number.
        -:  629: *
        -:  630: * Note:
        -:  631: *   Calling ecma_deref_ecma_string on the returned pointer is optional.
        -:  632: *
        -:  633: * @return pointer to ecma-string descriptor
        -:  634: */
        -:  635:ecma_string_t *
    #####:  636:ecma_get_ecma_string_from_uint32 (uint32_t uint32_number) /**< input number */
        -:  637:{
    #####:  638:  JERRY_ASSERT (uint32_number <= ECMA_DIRECT_STRING_MAX_IMM);
        -:  639:
    #####:  640:  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_UINT, (uintptr_t) uint32_number);
        -:  641:} /* ecma_get_ecma_string_from_uint32 */
        -:  642:
        -:  643:/**
        -:  644: * Allocate new ecma-string and fill it with ecma-number
        -:  645: *
        -:  646: * @return pointer to ecma-string descriptor
        -:  647: */
        -:  648:ecma_string_t *
    #####:  649:ecma_new_ecma_string_from_number (ecma_number_t num) /**< ecma-number */
        -:  650:{
    #####:  651:  uint32_t uint32_num = ecma_number_to_uint32 (num);
    #####:  652:  if (num == ((ecma_number_t) uint32_num))
        -:  653:  {
    #####:  654:    return ecma_new_ecma_string_from_uint32 (uint32_num);
        -:  655:  }
        -:  656:
    #####:  657:  if (ecma_number_is_nan (num))
        -:  658:  {
    #####:  659:    return ecma_get_magic_string (LIT_MAGIC_STRING_NAN);
        -:  660:  }
        -:  661:
    #####:  662:  if (ecma_number_is_infinity (num))
        -:  663:  {
    #####:  664:    lit_magic_string_id_t id = (ecma_number_is_negative (num) ? LIT_MAGIC_STRING_NEGATIVE_INFINITY_UL
    #####:  665:                                                              : LIT_MAGIC_STRING_INFINITY_UL);
    #####:  666:    return ecma_get_magic_string (id);
        -:  667:  }
        -:  668:
    #####:  669:  lit_utf8_byte_t str_buf[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
    #####:  670:  lit_utf8_size_t str_size = ecma_number_to_utf8_string (num, str_buf, sizeof (str_buf));
        -:  671:
    #####:  672:  JERRY_ASSERT (str_size > 0);
        -:  673:#ifndef JERRY_NDEBUG
    #####:  674:  JERRY_ASSERT (lit_is_utf8_string_magic (str_buf, str_size) == LIT_MAGIC_STRING__COUNT
        -:  675:                && lit_is_ex_utf8_string_magic (str_buf, str_size) == lit_get_magic_string_ex_count ());
        -:  676:#endif /* !JERRY_NDEBUG */
        -:  677:
    #####:  678:  lit_utf8_byte_t *data_p;
    #####:  679:  ecma_string_t *string_desc_p = ecma_new_ecma_string_from_utf8_buffer (lit_utf8_string_length (str_buf, str_size),
        -:  680:                                                                        str_size,
        -:  681:                                                                        &data_p);
        -:  682:
    #####:  683:  string_desc_p->u.hash = lit_utf8_string_calc_hash (str_buf, str_size);
    #####:  684:  memcpy (data_p, str_buf, str_size);
        -:  685:
    #####:  686:  return string_desc_p;
        -:  687:} /* ecma_new_ecma_string_from_number */
        -:  688:
        -:  689:/**
        -:  690: * Returns the constant assigned to the magic string id.
        -:  691: *
        -:  692: * Note:
        -:  693: *   Calling ecma_deref_ecma_string on the returned pointer is optional.
        -:  694: *
        -:  695: * @return pointer to ecma-string descriptor
        -:  696: */
        -:  697:extern inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE
        7:  698:ecma_get_magic_string (lit_magic_string_id_t id) /**< identifier of magic string */
        -:  699:{
      224:  700:  JERRY_ASSERT (id < LIT_MAGIC_STRING__COUNT);
      224:  701:  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_MAGIC, (uintptr_t) id);
        -:  702:} /* ecma_get_magic_string */
        -:  703:
        -:  704:/**
        -:  705: * Returns the constant assigned to the internal magic string id.
        -:  706: *
        -:  707: * Note:
        -:  708: *   Calling ecma_deref_ecma_string on the returned pointer is optional.
        -:  709: *
        -:  710: * @return pointer to ecma-string descriptor
        -:  711: */
        -:  712:extern inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE
    #####:  713:ecma_get_internal_string (lit_magic_string_id_t id) /**< identifier of magic string */
        -:  714:{
    #####:  715:  JERRY_ASSERT (id >= LIT_NON_INTERNAL_MAGIC_STRING__COUNT && id < LIT_MAGIC_STRING__COUNT);
    #####:  716:  return (ecma_string_t *) ECMA_CREATE_DIRECT_STRING (ECMA_DIRECT_STRING_SPECIAL, (uintptr_t) id);
        -:  717:} /* ecma_get_internal_string */
        -:  718:
        -:  719:/**
        -:  720: * Append a cesu8 string after an ecma-string
        -:  721: *
        -:  722: * Note:
        -:  723: *   The string1_p argument is freed. If it needs to be preserved,
        -:  724: *   call ecma_ref_ecma_string with string1_p before the call.
        -:  725: *
        -:  726: * @return concatenation of an ecma-string and a cesu8 string
        -:  727: */
        -:  728:ecma_string_t *
        2:  729:ecma_append_chars_to_string (ecma_string_t *string1_p, /**< base ecma-string */
        -:  730:                             const lit_utf8_byte_t *cesu8_string2_p, /**< characters to be appended */
        -:  731:                             lit_utf8_size_t cesu8_string2_size, /**< byte size of cesu8_string2_p */
        -:  732:                             lit_utf8_size_t cesu8_string2_length) /**< character length of cesu8_string2_p */
        -:  733:{
        2:  734:  JERRY_ASSERT (string1_p != NULL && cesu8_string2_size > 0 && cesu8_string2_length > 0);
        -:  735:
        2:  736:  if (JERRY_UNLIKELY (ecma_string_is_empty (string1_p)))
        -:  737:  {
    #####:  738:    return ecma_new_ecma_string_from_utf8 (cesu8_string2_p, cesu8_string2_size);
        -:  739:  }
        -:  740:
        2:  741:  lit_utf8_size_t cesu8_string1_size;
        2:  742:  lit_utf8_size_t cesu8_string1_length;
        2:  743:  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;
        2:  744:  lit_utf8_byte_t uint32_to_string_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
        -:  745:
        2:  746:  const lit_utf8_byte_t *cesu8_string1_p = ecma_string_get_chars (string1_p,
        -:  747:                                                                  &cesu8_string1_size,
        -:  748:                                                                  &cesu8_string1_length,
        -:  749:                                                                  uint32_to_string_buffer,
        -:  750:                                                                  &flags);
        -:  751:
        2:  752:  JERRY_ASSERT (!(flags & ECMA_STRING_FLAG_MUST_BE_FREED));
        2:  753:  JERRY_ASSERT (cesu8_string1_length > 0);
        2:  754:  JERRY_ASSERT (cesu8_string1_length <= cesu8_string1_size);
        -:  755:
        2:  756:  lit_utf8_size_t new_size = cesu8_string1_size + cesu8_string2_size;
        -:  757:
        -:  758:  /* Poor man's carry flag check: it is impossible to allocate this large string. */
        2:  759:  if (new_size < (cesu8_string1_size | cesu8_string2_size))
        -:  760:  {
    #####:  761:    jerry_fatal (ERR_OUT_OF_MEMORY);
        -:  762:  }
        -:  763:
        -:  764:  lit_magic_string_id_t magic_string_id;
        2:  765:  magic_string_id = lit_is_utf8_string_pair_magic (cesu8_string1_p,
        -:  766:                                                   cesu8_string1_size,
        -:  767:                                                   cesu8_string2_p,
        -:  768:                                                   cesu8_string2_size);
        -:  769:
        2:  770:  if (magic_string_id != LIT_MAGIC_STRING__COUNT)
        -:  771:  {
    #####:  772:    ecma_deref_ecma_string (string1_p);
    #####:  773:    return ecma_get_magic_string (magic_string_id);
        -:  774:  }
        -:  775:
        2:  776:  if ((flags & ECMA_STRING_FLAG_IS_UINT32) && new_size <= ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32)
        -:  777:  {
    #####:  778:    memcpy (uint32_to_string_buffer + cesu8_string1_size, cesu8_string2_p, cesu8_string2_size);
        -:  779:
    #####:  780:    uint32_t array_index;
        -:  781:
    #####:  782:    if (ecma_string_to_array_index (uint32_to_string_buffer, new_size, &array_index))
        -:  783:    {
    #####:  784:      ecma_deref_ecma_string (string1_p);
    #####:  785:      return ecma_new_ecma_string_from_uint32 (array_index);
        -:  786:    }
        -:  787:  }
        -:  788:
        2:  789:  if (lit_get_magic_string_ex_count () > 0)
        -:  790:  {
        -:  791:    lit_magic_string_ex_id_t magic_string_ex_id;
    #####:  792:    magic_string_ex_id = lit_is_ex_utf8_string_pair_magic (cesu8_string1_p,
        -:  793:                                                           cesu8_string1_size,
        -:  794:                                                           cesu8_string2_p,
        -:  795:                                                           cesu8_string2_size);
        -:  796:
    #####:  797:    if (magic_string_ex_id < lit_get_magic_string_ex_count ())
        -:  798:    {
    #####:  799:      ecma_deref_ecma_string (string1_p);
    #####:  800:      return ecma_new_ecma_string_from_magic_string_ex_id (magic_string_ex_id);
        -:  801:    }
        -:  802:  }
        -:  803:
        2:  804:  lit_utf8_byte_t *data_p;
        4:  805:  ecma_string_t *string_desc_p = ecma_new_ecma_string_from_utf8_buffer (cesu8_string1_length + cesu8_string2_length,
        -:  806:                                                                        new_size,
        -:  807:                                                                        &data_p);
        -:  808:
        -:  809:  lit_string_hash_t hash_start;
        -:  810:
        2:  811:  if (JERRY_UNLIKELY (flags & ECMA_STRING_FLAG_REHASH_NEEDED))
        -:  812:  {
        2:  813:    hash_start = lit_utf8_string_calc_hash (cesu8_string1_p, cesu8_string1_size);
        -:  814:  }
        -:  815:  else
        -:  816:  {
    #####:  817:    JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string1_p));
    #####:  818:    hash_start = string1_p->u.hash;
        -:  819:  }
        -:  820:
        2:  821:  string_desc_p->u.hash = lit_utf8_string_hash_combine (hash_start, cesu8_string2_p, cesu8_string2_size);
        -:  822:
        2:  823:  memcpy (data_p, cesu8_string1_p, cesu8_string1_size);
        2:  824:  memcpy (data_p + cesu8_string1_size, cesu8_string2_p, cesu8_string2_size);
        -:  825:
        2:  826:  ecma_deref_ecma_string (string1_p);
        2:  827:  return (ecma_string_t *) string_desc_p;
        -:  828:} /* ecma_append_chars_to_string */
        -:  829:
        -:  830:/**
        -:  831: * Concatenate ecma-strings
        -:  832: *
        -:  833: * Note:
        -:  834: *   The string1_p argument is freed. If it needs to be preserved,
        -:  835: *   call ecma_ref_ecma_string with string1_p before the call.
        -:  836: *
        -:  837: * @return concatenation of two ecma-strings
        -:  838: */
        -:  839:ecma_string_t *
        2:  840:ecma_concat_ecma_strings (ecma_string_t *string1_p, /**< first ecma-string */
        -:  841:                          ecma_string_t *string2_p) /**< second ecma-string */
        -:  842:{
        2:  843:  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);
        -:  844:
        2:  845:  if (JERRY_UNLIKELY (ecma_string_is_empty (string1_p)))
        -:  846:  {
    #####:  847:    ecma_ref_ecma_string (string2_p);
    #####:  848:    return string2_p;
        -:  849:  }
        2:  850:  else if (JERRY_UNLIKELY (ecma_string_is_empty (string2_p)))
        -:  851:  {
    #####:  852:    return string1_p;
        -:  853:  }
        -:  854:
        2:  855:  lit_utf8_size_t cesu8_string2_size;
        2:  856:  lit_utf8_size_t cesu8_string2_length;
        2:  857:  lit_utf8_byte_t uint32_to_string_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
        2:  858:  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;
        -:  859:
        2:  860:  const lit_utf8_byte_t *cesu8_string2_p = ecma_string_get_chars (string2_p,
        -:  861:                                                                  &cesu8_string2_size,
        -:  862:                                                                  &cesu8_string2_length,
        -:  863:                                                                  uint32_to_string_buffer,
        -:  864:                                                                  &flags);
        -:  865:
        2:  866:  JERRY_ASSERT (cesu8_string2_p != NULL);
        -:  867:
        2:  868:  ecma_string_t *result_p = ecma_append_chars_to_string (string1_p,
        -:  869:                                                         cesu8_string2_p,
        -:  870:                                                         cesu8_string2_size,
        -:  871:                                                         cesu8_string2_length);
        -:  872:
        2:  873:  JERRY_ASSERT (!(flags & ECMA_STRING_FLAG_MUST_BE_FREED));
        -:  874:
        2:  875:  return result_p;
        -:  876:} /* ecma_concat_ecma_strings */
        -:  877:
        -:  878:/**
        -:  879: * Increase reference counter of non-direct ecma-string.
        -:  880: */
        -:  881:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  882:ecma_ref_ecma_string_non_direct (ecma_string_t *string_p) /**< string descriptor */
        -:  883:{
       12:  884:  JERRY_ASSERT (string_p != NULL);
       12:  885:  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));
        -:  886:
        -:  887:#ifdef JERRY_NDEBUG
    #####:  888:  if (ECMA_STRING_IS_STATIC (string_p))
        -:  889:  {
        -:  890:    return;
        -:  891:  }
        -:  892:#endif /* JERRY_NDEBUG */
        -:  893:
       12:  894:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -:  895:
       12:  896:  if (JERRY_LIKELY (string_p->refs_and_container < ECMA_STRING_MAX_REF))
        -:  897:  {
        -:  898:    /* Increase reference counter. */
       12:  899:    string_p->refs_and_container += ECMA_STRING_REF_ONE;
        -:  900:  }
        -:  901:  else
        -:  902:  {
    #####:  903:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -:  904:  }
    #####:  905:} /* ecma_ref_ecma_string_non_direct */
        -:  906:
        -:  907:/**
        -:  908: * Increase reference counter of ecma-string.
        -:  909: */
        -:  910:void
       13:  911:ecma_ref_ecma_string (ecma_string_t *string_p) /**< string descriptor */
        -:  912:{
       13:  913:  JERRY_ASSERT (string_p != NULL);
        -:  914:
       13:  915:  if (ECMA_IS_DIRECT_STRING (string_p))
        -:  916:  {
        1:  917:    return;
        -:  918:  }
        -:  919:
        -:  920:  ecma_ref_ecma_string_non_direct (string_p);
        -:  921:} /* ecma_ref_ecma_string */
        -:  922:
        -:  923:/**
        -:  924: * Decrease reference counter and deallocate a non-direct ecma-string
        -:  925: * if the counter becomes zero.
        -:  926: */
        -:  927:extern inline void JERRY_ATTR_ALWAYS_INLINE
        6:  928:ecma_deref_ecma_string_non_direct (ecma_string_t *string_p) /**< ecma-string */
        -:  929:{
        9:  930:  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));
        -:  931:
        -:  932:#ifdef JERRY_NDEBUG
    #####:  933:  if (ECMA_STRING_IS_STATIC (string_p))
        -:  934:  {
        -:  935:    return;
        -:  936:  }
        -:  937:#endif /* JERRY_NDEBUG */
        -:  938:
        9:  939:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -:  940:
        -:  941:  /* Decrease reference counter. */
        9:  942:  string_p->refs_and_container -= ECMA_STRING_REF_ONE;
        -:  943:
        9:  944:  if (string_p->refs_and_container >= ECMA_STRING_REF_ONE)
        -:  945:  {
        6:  946:    return;
        -:  947:  }
        -:  948:
        1:  949:  ecma_destroy_ecma_string (string_p);
        -:  950:} /* ecma_deref_ecma_string_non_direct */
        -:  951:
        -:  952:/**
        -:  953: * Decrease reference counter and deallocate ecma-string
        -:  954: * if the counter becomes zero.
        -:  955: */
        -:  956:void
        7:  957:ecma_deref_ecma_string (ecma_string_t *string_p) /**< ecma-string */
        -:  958:{
        7:  959:  JERRY_ASSERT (string_p != NULL);
        -:  960:
        7:  961:  if (ECMA_IS_DIRECT_STRING (string_p))
        -:  962:  {
        4:  963:    return;
        -:  964:  }
        -:  965:
        -:  966:  ecma_deref_ecma_string_non_direct (string_p);
        -:  967:} /* ecma_deref_ecma_string */
        -:  968:
        -:  969:/**
        -:  970: * Deallocate an ecma-string
        -:  971: */
        -:  972:void
        1:  973:ecma_destroy_ecma_string (ecma_string_t *string_p) /**< ecma-string */
        -:  974:{
        1:  975:  JERRY_ASSERT (string_p != NULL);
        1:  976:  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string_p));
        1:  977:  JERRY_ASSERT ((string_p->refs_and_container < ECMA_STRING_REF_ONE) || ECMA_STRING_IS_STATIC (string_p));
        -:  978:
        1:  979:  switch (ECMA_STRING_GET_CONTAINER (string_p))
        -:  980:  {
    #####:  981:    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -:  982:    {
    #####:  983:      ecma_dealloc_string_buffer (string_p, ((ecma_short_string_t *) string_p)->size + sizeof (ecma_short_string_t));
    #####:  984:      return;
        -:  985:    }
    #####:  986:    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -:  987:    {
    #####:  988:      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -:  989:
    #####:  990:      if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))
        -:  991:      {
    #####:  992:        ecma_dealloc_string_buffer (string_p, long_string_p->size + sizeof (ecma_long_string_t));
    #####:  993:        return;
        -:  994:      }
        -:  995:
    #####:  996:      ecma_external_string_t *external_string_p = (ecma_external_string_t *) string_p;
    #####:  997:      jerry_external_string_free_callback_t free_cb = JERRY_CONTEXT (external_string_free_callback_p);
        -:  998:
    #####:  999:      if (free_cb != NULL)
        -: 1000:      {
    #####: 1001:        free_cb ((lit_utf8_byte_t *) external_string_p->header.string_p,
        -: 1002:                 external_string_p->header.size,
        -: 1003:                 external_string_p->user_p);
        -: 1004:      }
        -: 1005:
    #####: 1006:      ecma_dealloc_external_string (external_string_p);
    #####: 1007:      return;
        -: 1008:    }
        1: 1009:    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -: 1010:    {
        1: 1011:      ecma_dealloc_string_buffer (string_p, ECMA_ASCII_STRING_GET_SIZE (string_p) + ECMA_ASCII_STRING_HEADER_SIZE);
        1: 1012:      return;
        -: 1013:    }
        -: 1014:#if JERRY_ESNEXT
    #####: 1015:    case ECMA_STRING_CONTAINER_SYMBOL:
        -: 1016:    {
    #####: 1017:      ecma_extended_string_t *symbol_p = (ecma_extended_string_t *) string_p;
    #####: 1018:      ecma_free_value (symbol_p->u.symbol_descriptor);
    #####: 1019:      ecma_dealloc_extended_string (symbol_p);
    #####: 1020:      return;
        -: 1021:    }
        -: 1022:#endif /* JERRY_ESNEXT */
    #####: 1023:    default:
        -: 1024:    {
    #####: 1025:      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC
        -: 1026:                    || ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 1027:
        -: 1028:      /* only the string descriptor itself should be freed */
    #####: 1029:      ecma_dealloc_string (string_p);
        -: 1030:    }
        -: 1031:  }
        -: 1032:} /* ecma_destroy_ecma_string */
        -: 1033:
        -: 1034:/**
        -: 1035: * Convert ecma-string to number
        -: 1036: *
        -: 1037: * @return converted ecma-number
        -: 1038: */
        -: 1039:ecma_number_t
        1: 1040:ecma_string_to_number (const ecma_string_t *string_p) /**< ecma-string */
        -: 1041:{
        1: 1042:  JERRY_ASSERT (string_p != NULL);
        -: 1043:
        1: 1044:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1045:  {
        1: 1046:    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_UINT))
        -: 1047:    {
        1: 1048:      return (ecma_number_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 1049:    }
        -: 1050:  }
    #####: 1051:  else if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1052:  {
    #####: 1053:    return ((ecma_number_t) string_p->u.uint32_number);
        -: 1054:  }
        -: 1055:
    #####: 1056:  lit_utf8_size_t size;
    #####: 1057:  const lit_utf8_byte_t *chars_p = ecma_string_get_chars_fast (string_p, &size);
        -: 1058:
    #####: 1059:  JERRY_ASSERT (chars_p != NULL);
        -: 1060:
    #####: 1061:  if (size == 0)
        -: 1062:  {
    #####: 1063:    return ECMA_NUMBER_ZERO;
        -: 1064:  }
        -: 1065:
    #####: 1066:  return ecma_utf8_string_to_number (chars_p, size, 0);
        -: 1067:} /* ecma_string_to_number */
        -: 1068:
        -: 1069:/**
        -: 1070: * Check if string is array index.
        -: 1071: *
        -: 1072: * @return ECMA_STRING_NOT_ARRAY_INDEX if string is not array index
        -: 1073: *         the array index otherwise
        -: 1074: */
        -: 1075:extern inline uint32_t JERRY_ATTR_ALWAYS_INLINE
      107: 1076:ecma_string_get_array_index (const ecma_string_t *str_p) /**< ecma-string */
        -: 1077:{
      107: 1078:  if (ECMA_IS_DIRECT_STRING (str_p))
        -: 1079:  {
      102: 1080:    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (str_p, ECMA_DIRECT_STRING_UINT))
        -: 1081:    {
        -: 1082:      /* Value cannot be equal to the maximum value of a 32 bit unsigned number. */
    #####: 1083:      return (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (str_p);
        -: 1084:    }
        -: 1085:
      102: 1086:    return ECMA_STRING_NOT_ARRAY_INDEX;
        -: 1087:  }
        -: 1088:
        5: 1089:  if (ECMA_STRING_GET_CONTAINER (str_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1090:  {
        -: 1091:    /* When the uint32_number is equal to the maximum value of 32 bit unsigned integer number,
        -: 1092:     * it is also an invalid array index. The comparison to ECMA_STRING_NOT_ARRAY_INDEX will
        -: 1093:     * be true in this case. */
    #####: 1094:    return str_p->u.uint32_number;
        -: 1095:  }
        -: 1096:
        5: 1097:  return ECMA_STRING_NOT_ARRAY_INDEX;
        -: 1098:} /* ecma_string_get_array_index */
        -: 1099:
        -: 1100:/**
        -: 1101: * Convert ecma-string's contents to a cesu-8 string and put it to the buffer.
        -: 1102: * It is the caller's responsibility to make sure that the string fits in the buffer.
        -: 1103: *
        -: 1104: * @return number of bytes, actually copied to the buffer.
        -: 1105: */
        -: 1106:lit_utf8_size_t JERRY_ATTR_WARN_UNUSED_RESULT
    #####: 1107:ecma_string_copy_to_cesu8_buffer (const ecma_string_t *string_p, /**< ecma-string descriptor */
        -: 1108:                                  lit_utf8_byte_t *buffer_p, /**< destination buffer pointer
        -: 1109:                                                              * (can be NULL if buffer_size == 0) */
        -: 1110:                                  lit_utf8_size_t buffer_size) /**< size of buffer */
        -: 1111:{
    #####: 1112:  JERRY_ASSERT (string_p != NULL);
    #####: 1113:  JERRY_ASSERT (buffer_p != NULL || buffer_size == 0);
    #####: 1114:  JERRY_ASSERT (ecma_string_get_size (string_p) <= buffer_size);
        -: 1115:
    #####: 1116:  lit_utf8_size_t size;
        -: 1117:
    #####: 1118:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1119:  {
    #####: 1120:    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_UINT))
        -: 1121:    {
    #####: 1122:      uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
    #####: 1123:      size = ecma_uint32_to_utf8_string (uint32_number, buffer_p, buffer_size);
    #####: 1124:      JERRY_ASSERT (size <= buffer_size);
    #####: 1125:      return size;
        -: 1126:    }
        -: 1127:  }
        -: 1128:  else
        -: 1129:  {
    #####: 1130:    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1131:
    #####: 1132:    if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1133:    {
    #####: 1134:      uint32_t uint32_number = string_p->u.uint32_number;
    #####: 1135:      size = ecma_uint32_to_utf8_string (uint32_number, buffer_p, buffer_size);
    #####: 1136:      JERRY_ASSERT (size <= buffer_size);
    #####: 1137:      return size;
        -: 1138:    }
        -: 1139:  }
        -: 1140:
    #####: 1141:  const lit_utf8_byte_t *chars_p = ecma_string_get_chars_fast (string_p, &size);
        -: 1142:
    #####: 1143:  JERRY_ASSERT (chars_p != NULL);
    #####: 1144:  JERRY_ASSERT (size <= buffer_size);
        -: 1145:
    #####: 1146:  memcpy (buffer_p, chars_p, size);
    #####: 1147:  return size;
        -: 1148:} /* ecma_string_copy_to_cesu8_buffer */
        -: 1149:
        -: 1150:/**
        -: 1151: * Convert ecma-string's contents to an utf-8 string and put it to the buffer.
        -: 1152: * It is the caller's responsibility to make sure that the string fits in the buffer.
        -: 1153: *
        -: 1154: * @return number of bytes, actually copied to the buffer.
        -: 1155: */
        -: 1156:lit_utf8_size_t JERRY_ATTR_WARN_UNUSED_RESULT
    #####: 1157:ecma_string_copy_to_utf8_buffer (const ecma_string_t *string_p, /**< ecma-string descriptor */
        -: 1158:                                 lit_utf8_byte_t *buffer_p, /**< destination buffer pointer
        -: 1159:                                                             * (can be NULL if buffer_size == 0) */
        -: 1160:                                 lit_utf8_size_t buffer_size) /**< size of buffer */
        -: 1161:{
    #####: 1162:  JERRY_ASSERT (string_p != NULL);
    #####: 1163:  JERRY_ASSERT (buffer_p != NULL || buffer_size == 0);
    #####: 1164:  JERRY_ASSERT (ecma_string_get_utf8_size (string_p) <= buffer_size);
        -: 1165:
    #####: 1166:  lit_utf8_size_t size;
        -: 1167:
    #####: 1168:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1169:  {
    #####: 1170:    if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_UINT))
        -: 1171:    {
    #####: 1172:      uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
    #####: 1173:      size = ecma_uint32_to_utf8_string (uint32_number, buffer_p, buffer_size);
    #####: 1174:      JERRY_ASSERT (size <= buffer_size);
    #####: 1175:      return size;
        -: 1176:    }
        -: 1177:  }
        -: 1178:  else
        -: 1179:  {
    #####: 1180:    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1181:
    #####: 1182:    if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1183:    {
    #####: 1184:      uint32_t uint32_number = string_p->u.uint32_number;
    #####: 1185:      size = ecma_uint32_to_utf8_string (uint32_number, buffer_p, buffer_size);
    #####: 1186:      JERRY_ASSERT (size <= buffer_size);
    #####: 1187:      return size;
        -: 1188:    }
        -: 1189:  }
        -: 1190:
    #####: 1191:  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 1192:  const lit_utf8_byte_t *chars_p = ecma_string_get_chars (string_p, &size, NULL, NULL, &flags);
        -: 1193:
    #####: 1194:  JERRY_ASSERT (chars_p != NULL);
        -: 1195:
    #####: 1196:  if (flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 1197:  {
    #####: 1198:    JERRY_ASSERT (size <= buffer_size);
    #####: 1199:    memcpy (buffer_p, chars_p, size);
    #####: 1200:    return size;
        -: 1201:  }
        -: 1202:
    #####: 1203:  size = lit_convert_cesu8_string_to_utf8_string (chars_p,
        -: 1204:                                                  size,
        -: 1205:                                                  buffer_p,
        -: 1206:                                                  buffer_size);
        -: 1207:
    #####: 1208:  if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1209:  {
    #####: 1210:    jmem_heap_free_block ((void *) chars_p, size);
        -: 1211:  }
        -: 1212:
    #####: 1213:  JERRY_ASSERT (size <= buffer_size);
    #####: 1214:  return size;
        -: 1215:} /* ecma_string_copy_to_utf8_buffer */
        -: 1216:
        -: 1217:/**
        -: 1218: * Convert ecma-string's contents to a cesu-8 string, extract the parts of the converted string between the specified
        -: 1219: * start position and the end position (or the end of the string, whichever comes first), and copy these characters
        -: 1220: * into the buffer.
        -: 1221: *
        -: 1222: * @return number of bytes, actually copied to the buffer.
        -: 1223: */
        -: 1224:lit_utf8_size_t
    #####: 1225:ecma_substring_copy_to_cesu8_buffer (const ecma_string_t *string_desc_p, /**< ecma-string descriptor */
        -: 1226:                                     lit_utf8_size_t start_pos, /**< position of the first character */
        -: 1227:                                     lit_utf8_size_t end_pos, /**< position of the last character */
        -: 1228:                                     lit_utf8_byte_t *buffer_p, /**< destination buffer pointer
        -: 1229:                                                                 * (can be NULL if buffer_size == 0) */
        -: 1230:                                     lit_utf8_size_t buffer_size) /**< size of buffer */
        -: 1231:{
    #####: 1232:  JERRY_ASSERT (string_desc_p != NULL);
    #####: 1233:  JERRY_ASSERT (buffer_p != NULL || buffer_size == 0);
        -: 1234:
    #####: 1235:  lit_utf8_size_t string_length = ecma_string_get_length (string_desc_p);
    #####: 1236:  lit_utf8_size_t size = 0;
        -: 1237:
    #####: 1238:  if (start_pos >= string_length || start_pos >= end_pos)
        -: 1239:  {
    #####: 1240:    return 0;
        -: 1241:  }
        -: 1242:
    #####: 1243:  if (end_pos > string_length)
        -: 1244:  {
    #####: 1245:    end_pos = string_length;
        -: 1246:  }
        -: 1247:
    #####: 1248:  ECMA_STRING_TO_UTF8_STRING (string_desc_p, utf8_str_p, utf8_str_size);
        -: 1249:
    #####: 1250:  const lit_utf8_byte_t *start_p = utf8_str_p;
        -: 1251:
    #####: 1252:  if (string_length == utf8_str_size)
        -: 1253:  {
    #####: 1254:    start_p += start_pos;
    #####: 1255:    size = end_pos - start_pos;
        -: 1256:
    #####: 1257:    if (size > buffer_size)
        -: 1258:    {
    #####: 1259:      size = buffer_size;
        -: 1260:    }
        -: 1261:
    #####: 1262:    memcpy (buffer_p, start_p, size);
        -: 1263:  }
        -: 1264:  else
        -: 1265:  {
    #####: 1266:    end_pos -= start_pos;
    #####: 1267:    while (start_pos--)
        -: 1268:    {
    #####: 1269:      start_p += lit_get_unicode_char_size_by_utf8_first_byte (*start_p);
        -: 1270:    }
        -: 1271:
    #####: 1272:    const lit_utf8_byte_t *end_p = start_p;
        -: 1273:
    #####: 1274:    while (end_pos--)
        -: 1275:    {
    #####: 1276:      lit_utf8_size_t code_unit_size = lit_get_unicode_char_size_by_utf8_first_byte (*end_p);
        -: 1277:
    #####: 1278:      if ((size + code_unit_size) > buffer_size)
        -: 1279:      {
    #####: 1280:        break;
        -: 1281:      }
        -: 1282:
    #####: 1283:      end_p += code_unit_size;
    #####: 1284:      size += code_unit_size;
        -: 1285:    }
        -: 1286:
    #####: 1287:    memcpy (buffer_p, start_p, size);
        -: 1288:  }
        -: 1289:
    #####: 1290:  ECMA_FINALIZE_UTF8_STRING (utf8_str_p, utf8_str_size);
        -: 1291:
    #####: 1292:  JERRY_ASSERT (size <= buffer_size);
    #####: 1293:  return size;
        -: 1294:} /* ecma_substring_copy_to_cesu8_buffer */
        -: 1295:
        -: 1296:/**
        -: 1297: * Convert ecma-string's contents to an utf-8 string, extract the parts of the converted string between the specified
        -: 1298: * start position and the end position (or the end of the string, whichever comes first), and copy these characters
        -: 1299: * into the buffer.
        -: 1300: *
        -: 1301: * @return number of bytes, actually copied to the buffer.
        -: 1302: */
        -: 1303:lit_utf8_size_t
    #####: 1304:ecma_substring_copy_to_utf8_buffer (const ecma_string_t *string_desc_p, /**< ecma-string descriptor */
        -: 1305:                                    lit_utf8_size_t start_pos, /**< position of the first character */
        -: 1306:                                    lit_utf8_size_t end_pos, /**< position of the last character */
        -: 1307:                                    lit_utf8_byte_t *buffer_p, /**< destination buffer pointer
        -: 1308:                                                                * (can be NULL if buffer_size == 0) */
        -: 1309:                                    lit_utf8_size_t buffer_size) /**< size of buffer */
        -: 1310:{
    #####: 1311:  JERRY_ASSERT (string_desc_p != NULL);
    #####: 1312:  JERRY_ASSERT (ECMA_IS_DIRECT_STRING (string_desc_p) || string_desc_p->refs_and_container >= ECMA_STRING_REF_ONE);
    #####: 1313:  JERRY_ASSERT (buffer_p != NULL || buffer_size == 0);
        -: 1314:
    #####: 1315:  lit_utf8_size_t size = 0;
        -: 1316:
    #####: 1317:  lit_utf8_size_t utf8_str_length = ecma_string_get_utf8_length (string_desc_p);
        -: 1318:
    #####: 1319:  if (start_pos >= utf8_str_length || start_pos >= end_pos)
        -: 1320:  {
    #####: 1321:    return 0;
        -: 1322:  }
        -: 1323:
    #####: 1324:  if (end_pos > utf8_str_length)
        -: 1325:  {
    #####: 1326:    end_pos = utf8_str_length;
        -: 1327:  }
        -: 1328:
    #####: 1329:  ECMA_STRING_TO_UTF8_STRING (string_desc_p, cesu8_str_p, cesu8_str_size);
    #####: 1330:  lit_utf8_size_t cesu8_str_length = ecma_string_get_length (string_desc_p);
        -: 1331:
    #####: 1332:  if (cesu8_str_length == cesu8_str_size)
        -: 1333:  {
    #####: 1334:    cesu8_str_p += start_pos;
    #####: 1335:    size = end_pos - start_pos;
        -: 1336:
    #####: 1337:    if (size > buffer_size)
        -: 1338:    {
    #####: 1339:      size = buffer_size;
        -: 1340:    }
        -: 1341:
    #####: 1342:    memcpy (buffer_p, cesu8_str_p, size);
        -: 1343:  }
        -: 1344:  else
        -: 1345:  {
    #####: 1346:    const lit_utf8_byte_t *cesu8_end_pos = cesu8_str_p + cesu8_str_size;
    #####: 1347:    end_pos -= start_pos;
        -: 1348:
    #####: 1349:    while (start_pos--)
        -: 1350:    {
    #####: 1351:      ecma_char_t ch;
    #####: 1352:      lit_utf8_size_t code_unit_size = lit_read_code_unit_from_cesu8 (cesu8_str_p, &ch);
        -: 1353:
    #####: 1354:      cesu8_str_p += code_unit_size;
    #####: 1355:      if ((cesu8_str_p != cesu8_end_pos) && lit_is_code_point_utf16_high_surrogate (ch))
        -: 1356:      {
    #####: 1357:        ecma_char_t next_ch;
    #####: 1358:        lit_utf8_size_t next_ch_size = lit_read_code_unit_from_cesu8 (cesu8_str_p, &next_ch);
    #####: 1359:        if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -: 1360:        {
    #####: 1361:          JERRY_ASSERT (code_unit_size == next_ch_size);
    #####: 1362:          cesu8_str_p += code_unit_size;
        -: 1363:        }
        -: 1364:      }
        -: 1365:    }
        -: 1366:
    #####: 1367:    const lit_utf8_byte_t *cesu8_pos = cesu8_str_p;
        -: 1368:
    #####: 1369:    lit_utf8_byte_t *utf8_pos = buffer_p;
    #####: 1370:    lit_utf8_byte_t *utf8_end_pos = buffer_p + buffer_size;
        -: 1371:
    #####: 1372:    while (end_pos--)
        -: 1373:    {
    #####: 1374:      ecma_char_t ch;
    #####: 1375:      lit_utf8_size_t code_unit_size = lit_read_code_unit_from_cesu8 (cesu8_pos, &ch);
        -: 1376:
    #####: 1377:      if ((size + code_unit_size) > buffer_size)
        -: 1378:      {
    #####: 1379:        break;
        -: 1380:      }
        -: 1381:
    #####: 1382:      if (((cesu8_pos + code_unit_size) != cesu8_end_pos) && lit_is_code_point_utf16_high_surrogate (ch))
    #####: 1383:      {
    #####: 1384:        ecma_char_t next_ch;
    #####: 1385:        lit_utf8_size_t next_ch_size = lit_read_code_unit_from_cesu8 (cesu8_pos + code_unit_size, &next_ch);
        -: 1386:
    #####: 1387:        if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -: 1388:        {
    #####: 1389:          JERRY_ASSERT (code_unit_size == next_ch_size);
        -: 1390:
    #####: 1391:          if ((size + code_unit_size + 1) > buffer_size)
        -: 1392:          {
    #####: 1393:            break;
        -: 1394:          }
        -: 1395:
    #####: 1396:          cesu8_pos += next_ch_size;
        -: 1397:
    #####: 1398:          lit_code_point_t code_point = lit_convert_surrogate_pair_to_code_point (ch, next_ch);
    #####: 1399:          lit_code_point_to_utf8 (code_point, utf8_pos);
    #####: 1400:          size += (code_unit_size + 1);
        -: 1401:        }
        -: 1402:        else
        -: 1403:        {
    #####: 1404:          memcpy (utf8_pos, cesu8_pos, code_unit_size);
    #####: 1405:          size += code_unit_size;
        -: 1406:        }
        -: 1407:      }
        -: 1408:      else
        -: 1409:      {
    #####: 1410:        memcpy (utf8_pos, cesu8_pos, code_unit_size);
    #####: 1411:        size += code_unit_size;
        -: 1412:      }
        -: 1413:
    #####: 1414:      utf8_pos = buffer_p + size;
    #####: 1415:      cesu8_pos += code_unit_size;
        -: 1416:    }
        -: 1417:
    #####: 1418:    JERRY_ASSERT (utf8_pos <= utf8_end_pos);
        -: 1419:  }
        -: 1420:
    #####: 1421:  ECMA_FINALIZE_UTF8_STRING (cesu8_str_p, cesu8_str_size);
    #####: 1422:  JERRY_ASSERT (size <= buffer_size);
        -: 1423:
    #####: 1424:  return size;
        -: 1425:} /* ecma_substring_copy_to_utf8_buffer */
        -: 1426:
        -: 1427:/**
        -: 1428: * Convert ecma-string's contents to a cesu-8 string and put it to the buffer.
        -: 1429: * It is the caller's responsibility to make sure that the string fits in the buffer.
        -: 1430: * Check if the size of the string is equal with the size of the buffer.
        -: 1431: */
        -: 1432:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1433:ecma_string_to_utf8_bytes (const ecma_string_t *string_desc_p, /**< ecma-string descriptor */
        -: 1434:                           lit_utf8_byte_t *buffer_p, /**< destination buffer pointer
        -: 1435:                                                       * (can be NULL if buffer_size == 0) */
        -: 1436:                           lit_utf8_size_t buffer_size) /**< size of buffer */
        -: 1437:{
    #####: 1438:  const lit_utf8_size_t size = ecma_string_copy_to_cesu8_buffer (string_desc_p, buffer_p, buffer_size);
    #####: 1439:  JERRY_ASSERT (size == buffer_size);
    #####: 1440:} /* ecma_string_to_utf8_bytes */
        -: 1441:
        -: 1442:/**
        -: 1443: * Get size of the uint32 number stored locally in the string's descriptor
        -: 1444: *
        -: 1445: * Note: the represented number size and length are equal
        -: 1446: *
        -: 1447: * @return size in bytes
        -: 1448: */
        -: 1449:static inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
        -: 1450:ecma_string_get_uint32_size (const uint32_t uint32_number) /**< number in the string-descriptor */
        -: 1451:{
    #####: 1452:  uint32_t prev_number = 1;
    #####: 1453:  uint32_t next_number = 100;
    #####: 1454:  lit_utf8_size_t size = 1;
        -: 1455:
    #####: 1456:  const uint32_t max_size = 9;
        -: 1457:
    #####: 1458:  while (size < max_size && uint32_number >= next_number)
        -: 1459:  {
    #####: 1460:    prev_number = next_number;
    #####: 1461:    next_number *= 100;
    #####: 1462:    size += 2;
        -: 1463:  }
        -: 1464:
    #####: 1465:  if (uint32_number >= prev_number * 10)
        -: 1466:  {
    #####: 1467:    size++;
        -: 1468:  }
        -: 1469:
    #####: 1470:  return size;
        -: 1471:} /* ecma_string_get_uint32_size */
        -: 1472:
        -: 1473:/**
        -: 1474: * Checks whether the given string is a sequence of ascii characters.
        -: 1475: */
        -: 1476:#define ECMA_STRING_IS_ASCII(char_p, size) ((size) == lit_utf8_string_length ((char_p), (size)))
        -: 1477:
        -: 1478:/**
        -: 1479: * Returns with the cesu8 character array of a string.
        -: 1480: *
        -: 1481: * Note:
        -: 1482: *   - This function returns with a newly allocated buffer for uint32 strings,
        -: 1483: *     which must be freed if the optional uint32_buff_p parameter is NULL.
        -: 1484: *   - The ASCII check only happens if the flags parameter gets
        -: 1485: *     'ECMA_STRING_FLAG_IS_ASCII' as an input.
        -: 1486: *
        -: 1487: * @return start of cesu8 characters
        -: 1488: */
        -: 1489:const lit_utf8_byte_t *
        4: 1490:ecma_string_get_chars (const ecma_string_t *string_p, /**< ecma-string */
        -: 1491:                       lit_utf8_size_t *size_p, /**< [out] size of the ecma string */
        -: 1492:                       lit_utf8_size_t *length_p, /**< [out] optional argument. If the pointer is not NULL the pointed
        -: 1493:                                                   *    memory area is filled with the length of the ecma string */
        -: 1494:                       lit_utf8_byte_t *uint32_buff_p, /**< [out] optional argument. If the pointer is not NULL the
        -: 1495:                                                        *    pointed memory area is filled with the string converted
        -: 1496:                                                        *    uint32 string descriptor */
        -: 1497:                       uint8_t *flags_p) /**< [in,out] any combination of ecma_string_flag_t bits */
        -: 1498:{
        -: 1499:  lit_utf8_size_t length;
        -: 1500:  lit_utf8_size_t size;
        -: 1501:  const lit_utf8_byte_t *result_p;
        -: 1502:
        4: 1503:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1504:  {
        4: 1505:    *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;
        -: 1506:
        4: 1507:    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))
        -: 1508:    {
        4: 1509:      case ECMA_DIRECT_STRING_MAGIC:
        -: 1510:      {
        4: 1511:        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 1512:
        4: 1513:        if (id >= LIT_MAGIC_STRING__COUNT)
        -: 1514:        {
    #####: 1515:          id -= LIT_MAGIC_STRING__COUNT;
    #####: 1516:          size = lit_get_magic_string_ex_size (id);
    #####: 1517:          result_p = lit_get_magic_string_ex_utf8 (id);
    #####: 1518:          length = 0;
        -: 1519:
    #####: 1520:          if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))
        -: 1521:          {
    #####: 1522:            length = lit_utf8_string_length (result_p, size);
        -: 1523:          }
        -: 1524:        }
        -: 1525:        else
        -: 1526:        {
        4: 1527:          size = lit_get_magic_string_size (id);
        4: 1528:          length = size;
        -: 1529:
        4: 1530:          result_p = lit_get_magic_string_utf8 (id);
        -: 1531:
        -: 1532:          /* All magic strings must be ascii strings. */
        4: 1533:          JERRY_ASSERT (ECMA_STRING_IS_ASCII (result_p, size));
        -: 1534:        }
        4: 1535:        break;
        -: 1536:      }
    #####: 1537:      default:
        -: 1538:      {
    #####: 1539:        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);
    #####: 1540:        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
    #####: 1541:        size = (lit_utf8_size_t) ecma_string_get_uint32_size (uint32_number);
        -: 1542:
    #####: 1543:        if (uint32_buff_p != NULL)
        -: 1544:        {
    #####: 1545:          result_p = uint32_buff_p;
        -: 1546:        }
        -: 1547:        else
        -: 1548:        {
    #####: 1549:          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);
    #####: 1550:          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;
        -: 1551:        }
        -: 1552:
    #####: 1553:        length = ecma_uint32_to_utf8_string (uint32_number, (lit_utf8_byte_t *) result_p, size);
        -: 1554:
    #####: 1555:        JERRY_ASSERT (length == size);
    #####: 1556:        *flags_p |= ECMA_STRING_FLAG_IS_UINT32;
    #####: 1557:        break;
        -: 1558:      }
        -: 1559:    }
        -: 1560:  }
        -: 1561:  else
        -: 1562:  {
    #####: 1563:    JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1564:
    #####: 1565:    switch (ECMA_STRING_GET_CONTAINER (string_p))
        -: 1566:    {
    #####: 1567:      case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -: 1568:      {
    #####: 1569:        ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 1570:        size = short_string_p->size;
    #####: 1571:        length = short_string_p->length;
    #####: 1572:        result_p = ECMA_SHORT_STRING_GET_BUFFER (short_string_p);
    #####: 1573:        break;
        -: 1574:      }
    #####: 1575:      case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -: 1576:      {
    #####: 1577:        ecma_long_string_t *long_string_desc_p = (ecma_long_string_t *) string_p;
    #####: 1578:        size = long_string_desc_p->size;
    #####: 1579:        length = long_string_desc_p->length;
    #####: 1580:        result_p = long_string_desc_p->string_p;
    #####: 1581:        break;
        -: 1582:      }
    #####: 1583:      case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -: 1584:      {
    #####: 1585:        size = ECMA_ASCII_STRING_GET_SIZE (string_p);
    #####: 1586:        length = size;
    #####: 1587:        result_p = ECMA_ASCII_STRING_GET_BUFFER (string_p);
    #####: 1588:        break;
        -: 1589:      }
    #####: 1590:      case ECMA_STRING_CONTAINER_UINT32_IN_DESC:
        -: 1591:      {
    #####: 1592:        size = (lit_utf8_size_t) ecma_string_get_uint32_size (string_p->u.uint32_number);
        -: 1593:
    #####: 1594:        if (uint32_buff_p != NULL)
        -: 1595:        {
    #####: 1596:          result_p = uint32_buff_p;
        -: 1597:        }
        -: 1598:        else
        -: 1599:        {
    #####: 1600:          result_p = (const lit_utf8_byte_t *) jmem_heap_alloc_block (size);
    #####: 1601:          *flags_p |= ECMA_STRING_FLAG_MUST_BE_FREED;
        -: 1602:        }
        -: 1603:
    #####: 1604:        length = ecma_uint32_to_utf8_string (string_p->u.uint32_number, (lit_utf8_byte_t *) result_p, size);
        -: 1605:
    #####: 1606:        JERRY_ASSERT (length == size);
    #####: 1607:        *flags_p |= ECMA_STRING_FLAG_IS_UINT32 | ECMA_STRING_FLAG_REHASH_NEEDED;
    #####: 1608:        break;
        -: 1609:
        -: 1610:      }
    #####: 1611:      default:
        -: 1612:      {
    #####: 1613:        JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 1614:
    #####: 1615:        lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
    #####: 1616:        size = lit_get_magic_string_ex_size (id);
    #####: 1617:        length = 0;
        -: 1618:
    #####: 1619:        if (JERRY_UNLIKELY (*flags_p & ECMA_STRING_FLAG_IS_ASCII))
        -: 1620:        {
    #####: 1621:          length = lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id), size);
        -: 1622:        }
        -: 1623:
    #####: 1624:        result_p = lit_get_magic_string_ex_utf8 (id);
    #####: 1625:        *flags_p |= ECMA_STRING_FLAG_REHASH_NEEDED;
    #####: 1626:        break;
        -: 1627:      }
        -: 1628:    }
        -: 1629:  }
        -: 1630:
        4: 1631:  *size_p = size;
        4: 1632:  if (length_p != NULL)
        -: 1633:  {
        4: 1634:    *length_p = length;
        -: 1635:  }
        -: 1636:
        4: 1637:  if ((*flags_p & ECMA_STRING_FLAG_IS_ASCII)
        4: 1638:      && length != size)
        -: 1639:  {
    #####: 1640:    *flags_p = (uint8_t) (*flags_p & (uint8_t) ~ECMA_STRING_FLAG_IS_ASCII);
        -: 1641:  }
        -: 1642:
        4: 1643:  return result_p;
        -: 1644:} /* ecma_string_get_chars */
        -: 1645:
        -: 1646:/**
        -: 1647: * Checks whether the string equals to the magic string id.
        -: 1648: *
        -: 1649: * @return true - if the string equals to the magic string id
        -: 1650: *         false - otherwise
        -: 1651: */
        -: 1652:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        1: 1653:ecma_compare_ecma_string_to_magic_id (const ecma_string_t *string_p, /**< property name */
        -: 1654:                                      lit_magic_string_id_t id) /**< magic string id */
        -: 1655:{
      212: 1656:  return (string_p == ecma_get_magic_string (id));
        -: 1657:} /* ecma_compare_ecma_string_to_magic_id */
        -: 1658:
        -: 1659:/**
        -: 1660: * Checks whether ecma string is empty or not
        -: 1661: *
        -: 1662: * @return true - if the string is an empty string
        -: 1663: *         false - otherwise
        -: 1664: */
        -: 1665:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1666:ecma_string_is_empty (const ecma_string_t *string_p) /**< ecma-string */
        -: 1667:{
        6: 1668:  return ecma_compare_ecma_string_to_magic_id (string_p, LIT_MAGIC_STRING__EMPTY);
        -: 1669:} /* ecma_string_is_empty */
        -: 1670:
        -: 1671:/**
        -: 1672: * Checks whether the string equals to "length".
        -: 1673: *
        -: 1674: * @return true - if the string equals to "length"
        -: 1675: *         false - otherwise
        -: 1676: */
        -: 1677:extern inline bool JERRY_ATTR_ALWAYS_INLINE
      205: 1678:ecma_string_is_length (const ecma_string_t *string_p) /**< property name */
        -: 1679:{
      205: 1680:  return ecma_compare_ecma_string_to_magic_id (string_p, LIT_MAGIC_STRING_LENGTH);
        -: 1681:} /* ecma_string_is_length */
        -: 1682:
        -: 1683:/**
        -: 1684: * Converts a property name into a string
        -: 1685: *
        -: 1686: * @return pointer to the converted ecma string
        -: 1687: */
        -: 1688:static inline ecma_string_t * JERRY_ATTR_ALWAYS_INLINE
        -: 1689:ecma_property_to_string (ecma_property_t property, /**< property name type */
        -: 1690:                         jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */
        -: 1691:{
    #####: 1692:  uintptr_t property_string = ((uintptr_t) (property)) & (0x3 << ECMA_PROPERTY_NAME_TYPE_SHIFT);
    #####: 1693:  property_string = (property_string >> ECMA_STRING_TYPE_CONVERSION_SHIFT) | ECMA_TYPE_DIRECT_STRING;
    #####: 1694:  return (ecma_string_t *) (property_string | (((uintptr_t) prop_name_cp) << ECMA_DIRECT_STRING_SHIFT));
        -: 1695:} /* ecma_property_to_string */
        -: 1696:
        -: 1697:/**
        -: 1698: * Converts a string into a property name
        -: 1699: *
        -: 1700: * @return the compressed pointer part of the name
        -: 1701: */
        -: 1702:extern inline jmem_cpointer_t JERRY_ATTR_ALWAYS_INLINE
       14: 1703:ecma_string_to_property_name (ecma_string_t *prop_name_p, /**< property name */
        -: 1704:                              ecma_property_t *name_type_p) /**< [out] property name type */
        -: 1705:{
       14: 1706:  if (ECMA_IS_DIRECT_STRING (prop_name_p))
        -: 1707:  {
        5: 1708:    *name_type_p = (ecma_property_t) ECMA_DIRECT_STRING_TYPE_TO_PROP_NAME_TYPE (prop_name_p);
        5: 1709:    return (jmem_cpointer_t) ECMA_GET_DIRECT_STRING_VALUE (prop_name_p);
        -: 1710:  }
        -: 1711:
        9: 1712:  *name_type_p = ECMA_DIRECT_STRING_PTR << ECMA_PROPERTY_NAME_TYPE_SHIFT;
        -: 1713:
        9: 1714:  ecma_ref_ecma_string (prop_name_p);
        -: 1715:
        -: 1716:  jmem_cpointer_t prop_name_cp;
        9: 1717:  ECMA_SET_NON_NULL_POINTER (prop_name_cp, prop_name_p);
        9: 1718:  return prop_name_cp;
        -: 1719:} /* ecma_string_to_property_name */
        -: 1720:
        -: 1721:/**
        -: 1722: * Converts a property name into a string
        -: 1723: *
        -: 1724: * @return the string pointer
        -: 1725: *         string must be released with ecma_deref_ecma_string
        -: 1726: */
        -: 1727:ecma_string_t *
    #####: 1728:ecma_string_from_property_name (ecma_property_t property, /**< property name type */
        -: 1729:                                jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */
        -: 1730:{
    #####: 1731:  if (ECMA_PROPERTY_GET_NAME_TYPE (property) != ECMA_DIRECT_STRING_PTR)
        -: 1732:  {
    #####: 1733:    return ecma_property_to_string (property, prop_name_cp);
        -: 1734:  }
        -: 1735:
    #####: 1736:  ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);
    #####: 1737:  ecma_ref_ecma_string (prop_name_p);
    #####: 1738:  return prop_name_p;
        -: 1739:} /* ecma_string_from_property_name */
        -: 1740:
        -: 1741:/**
        -: 1742: * Get hash code of property name
        -: 1743: *
        -: 1744: * @return hash code of property name
        -: 1745: */
        -: 1746:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
    #####: 1747:ecma_string_get_property_name_hash (ecma_property_t property, /**< property name type */
        -: 1748:                                    jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */
        -: 1749:{
    #####: 1750:  if (ECMA_PROPERTY_GET_NAME_TYPE (property) == ECMA_DIRECT_STRING_PTR)
        -: 1751:  {
    #####: 1752:    ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);
    #####: 1753:    return prop_name_p->u.hash;
        -: 1754:  }
        -: 1755:
    #####: 1756:  return (lit_string_hash_t) prop_name_cp;
        -: 1757:} /* ecma_string_get_property_name_hash */
        -: 1758:
        -: 1759:/**
        -: 1760: * Check if property name is array index.
        -: 1761: *
        -: 1762: * @return ECMA_STRING_NOT_ARRAY_INDEX if string is not array index
        -: 1763: *         the array index otherwise
        -: 1764: */
        -: 1765:uint32_t
    #####: 1766:ecma_string_get_property_index (ecma_property_t property, /**< property name type */
        -: 1767:                                jmem_cpointer_t prop_name_cp) /**< property name compressed pointer */
        -: 1768:{
    #####: 1769:  switch (ECMA_PROPERTY_GET_NAME_TYPE (property))
        -: 1770:  {
    #####: 1771:    case ECMA_DIRECT_STRING_UINT:
        -: 1772:    {
    #####: 1773:      return (uint32_t) prop_name_cp;
        -: 1774:    }
    #####: 1775:    case ECMA_DIRECT_STRING_PTR:
        -: 1776:    {
    #####: 1777:      ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);
    #####: 1778:      return ecma_string_get_array_index (prop_name_p);
        -: 1779:    }
    #####: 1780:    default:
        -: 1781:    {
    #####: 1782:      return ECMA_STRING_NOT_ARRAY_INDEX;
        -: 1783:    }
        -: 1784:  }
        -: 1785:} /* ecma_string_get_property_index */
        -: 1786:
        -: 1787:/**
        -: 1788: * Compare a property name to a string
        -: 1789: *
        -: 1790: * @return true if they are equals
        -: 1791: *         false otherwise
        -: 1792: */
        -: 1793:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####: 1794:ecma_string_compare_to_property_name (ecma_property_t property, /**< property name type */
        -: 1795:                                      jmem_cpointer_t prop_name_cp, /**< property name compressed pointer */
        -: 1796:                                      const ecma_string_t *string_p) /**< other string */
        -: 1797:{
    #####: 1798:  if (ECMA_PROPERTY_GET_NAME_TYPE (property) != ECMA_DIRECT_STRING_PTR)
        -: 1799:  {
    #####: 1800:    return ecma_property_to_string (property, prop_name_cp) == string_p;
        -: 1801:  }
        -: 1802:
    #####: 1803:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 1804:  {
    #####: 1805:    return false;
        -: 1806:  }
        -: 1807:
    #####: 1808:  ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, prop_name_cp);
    #####: 1809:  return ecma_compare_ecma_non_direct_strings (prop_name_p, string_p);
        -: 1810:} /* ecma_string_compare_to_property_name */
        -: 1811:
        -: 1812:/**
        -: 1813: * Helper for ecma_compare_ecma_strings_longpath to get string data
        -: 1814: *
        -: 1815: * @return string characters
        -: 1816: */
        -: 1817:static const lit_utf8_byte_t *
        2: 1818:ecma_compare_get_string_chars (const ecma_string_t *string_p, /**< ecma-string */
        -: 1819:                               lit_utf8_size_t *size_and_length_p) /**< [out] size and length */
        -: 1820:{
        2: 1821:  switch (ECMA_STRING_GET_CONTAINER (string_p))
        -: 1822:  {
    #####: 1823:    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -: 1824:    {
    #####: 1825:      ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 1826:      size_and_length_p[0] = short_string_p->size;
    #####: 1827:      size_and_length_p[1] = short_string_p->length;
    #####: 1828:      return ECMA_SHORT_STRING_GET_BUFFER (string_p);
        -: 1829:    }
    #####: 1830:    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -: 1831:    {
    #####: 1832:      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
    #####: 1833:      size_and_length_p[0] = long_string_p->size;
    #####: 1834:      size_and_length_p[1] = long_string_p->length;
    #####: 1835:      return long_string_p->string_p;
        -: 1836:    }
        2: 1837:    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -: 1838:    {
        2: 1839:      size_and_length_p[0] = ECMA_ASCII_STRING_GET_SIZE (string_p);
        2: 1840:      size_and_length_p[1] = size_and_length_p[0];
        2: 1841:      return ECMA_ASCII_STRING_GET_BUFFER (string_p);
        -: 1842:    }
    #####: 1843:    default:
        -: 1844:    {
    #####: 1845:      return NULL;
        -: 1846:    }
        -: 1847:  }
        -: 1848:} /* ecma_compare_get_string_chars */
        -: 1849:
        -: 1850:/**
        -: 1851: * Long path part of ecma-string to ecma-string comparison routine
        -: 1852: *
        -: 1853: * See also:
        -: 1854: *          ecma_compare_ecma_strings
        -: 1855: *
        -: 1856: * @return true - if strings are equal;
        -: 1857: *         false - otherwise
        -: 1858: */
        -: 1859:static bool JERRY_ATTR_NOINLINE
        1: 1860:ecma_compare_ecma_strings_longpath (const ecma_string_t *string1_p, /**< ecma-string */
        -: 1861:                                    const ecma_string_t *string2_p) /**< ecma-string */
        -: 1862:{
        -: 1863:  const lit_utf8_byte_t *utf8_string1_p, *utf8_string2_p;
        1: 1864:  lit_utf8_size_t string1_size_and_length[2], string2_size_and_length[2];
        -: 1865:
        1: 1866:  utf8_string1_p = ecma_compare_get_string_chars (string1_p, string1_size_and_length);
        1: 1867:  utf8_string2_p = ecma_compare_get_string_chars (string2_p, string2_size_and_length);
        -: 1868:
        1: 1869:  if (utf8_string1_p == NULL || utf8_string2_p == NULL)
        -: 1870:  {
    #####: 1871:    return false;
        -: 1872:  }
        -: 1873:
        1: 1874:  if (string1_size_and_length[0] != string2_size_and_length[0]
        1: 1875:      || string1_size_and_length[1] != string2_size_and_length[1])
        -: 1876:  {
    #####: 1877:    return false;
        -: 1878:  }
        -: 1879:
        1: 1880:  return !memcmp ((char *) utf8_string1_p, (char *) utf8_string2_p, string1_size_and_length[0]);
        -: 1881:} /* ecma_compare_ecma_strings_longpath */
        -: 1882:
        -: 1883:/**
        -: 1884: * Compare two ecma-strings
        -: 1885: *
        -: 1886: * @return true - if strings are equal;
        -: 1887: *         false - otherwise
        -: 1888: */
        -: 1889:extern inline bool JERRY_ATTR_ALWAYS_INLINE
        4: 1890:ecma_compare_ecma_strings (const ecma_string_t *string1_p, /**< ecma-string */
        -: 1891:                           const ecma_string_t *string2_p) /**< ecma-string */
        -: 1892:{
        4: 1893:  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);
        -: 1894:
        -: 1895:  /* Fast paths first. */
        4: 1896:  if (string1_p == string2_p)
        -: 1897:  {
    #####: 1898:    return true;
        -: 1899:  }
        -: 1900:
        -: 1901:  /* Either string is direct, return with false. */
        4: 1902:  if (ECMA_IS_DIRECT_STRING (((uintptr_t) string1_p) | ((uintptr_t) string2_p)))
        -: 1903:  {
    #####: 1904:    return false;
        -: 1905:  }
        -: 1906:
        -: 1907:  /* Also compares uint32 values in descriptor. */
        4: 1908:  if (string1_p->u.hash != string2_p->u.hash)
        -: 1909:  {
        3: 1910:    return false;
        -: 1911:  }
        -: 1912:
        1: 1913:  if (ECMA_STRING_GET_CONTAINER (string1_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1914:  {
    #####: 1915:    return ECMA_STRING_GET_CONTAINER (string2_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC;
        -: 1916:  }
        -: 1917:
        1: 1918:  return ecma_compare_ecma_strings_longpath (string1_p, string2_p);
        -: 1919:} /* ecma_compare_ecma_strings */
        -: 1920:
        -: 1921:/**
        -: 1922: * Compare two non-direct ecma-strings
        -: 1923: *
        -: 1924: * @return true - if strings are equal;
        -: 1925: *         false - otherwise
        -: 1926: */
        -: 1927:extern inline bool JERRY_ATTR_ALWAYS_INLINE
       89: 1928:ecma_compare_ecma_non_direct_strings (const ecma_string_t *string1_p, /**< ecma-string */
        -: 1929:                                      const ecma_string_t *string2_p) /**< ecma-string */
        -: 1930:{
       89: 1931:  JERRY_ASSERT (string1_p != NULL && string2_p != NULL);
       89: 1932:  JERRY_ASSERT (!ECMA_IS_DIRECT_STRING (string1_p) && !ECMA_IS_DIRECT_STRING (string2_p));
        -: 1933:
        -: 1934:  /* Fast paths first. */
       89: 1935:  if (string1_p == string2_p)
        -: 1936:  {
        2: 1937:    return true;
        -: 1938:  }
        -: 1939:
       87: 1940:  if (string1_p->u.hash != string2_p->u.hash)
        -: 1941:  {
       87: 1942:    return false;
        -: 1943:  }
        -: 1944:
    #####: 1945:  if (ECMA_STRING_GET_CONTAINER (string1_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1946:  {
    #####: 1947:    return ECMA_STRING_GET_CONTAINER (string2_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC;
        -: 1948:  }
        -: 1949:
    #####: 1950:  return ecma_compare_ecma_strings_longpath (string1_p, string2_p);
        -: 1951:} /* ecma_compare_ecma_non_direct_strings */
        -: 1952:
        -: 1953:/**
        -: 1954: * Relational compare of ecma-strings.
        -: 1955: *
        -: 1956: * First string is less than second string if:
        -: 1957: *  - strings are not equal;
        -: 1958: *  - first string is prefix of second or is lexicographically less than second.
        -: 1959: *
        -: 1960: * @return true - if first string is less than second string,
        -: 1961: *         false - otherwise
        -: 1962: */
        -: 1963:bool
    #####: 1964:ecma_compare_ecma_strings_relational (const ecma_string_t *string1_p, /**< ecma-string */
        -: 1965:                                      const ecma_string_t *string2_p) /**< ecma-string */
        -: 1966:{
    #####: 1967:  if (ecma_compare_ecma_strings (string1_p,
        -: 1968:                                 string2_p))
        -: 1969:  {
    #####: 1970:    return false;
        -: 1971:  }
        -: 1972:
        -: 1973:  const lit_utf8_byte_t *utf8_string1_p, *utf8_string2_p;
    #####: 1974:  lit_utf8_size_t utf8_string1_size, utf8_string2_size;
        -: 1975:
    #####: 1976:  lit_utf8_byte_t uint32_to_string_buffer1[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
    #####: 1977:  lit_utf8_byte_t uint32_to_string_buffer2[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
        -: 1978:
    #####: 1979:  if (ECMA_IS_DIRECT_STRING (string1_p))
        -: 1980:  {
    #####: 1981:    if (ECMA_GET_DIRECT_STRING_TYPE (string1_p) != ECMA_DIRECT_STRING_UINT)
        -: 1982:    {
    #####: 1983:      utf8_string1_p = ecma_string_get_chars_fast (string1_p, &utf8_string1_size);
        -: 1984:    }
        -: 1985:    else
        -: 1986:    {
    #####: 1987:      utf8_string1_size = ecma_uint32_to_utf8_string ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string1_p),
        -: 1988:                                                      uint32_to_string_buffer1,
        -: 1989:                                                      ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
    #####: 1990:      utf8_string1_p = uint32_to_string_buffer1;
        -: 1991:    }
        -: 1992:  }
        -: 1993:  else
        -: 1994:  {
    #####: 1995:    JERRY_ASSERT (string1_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 1996:
    #####: 1997:    if (ECMA_STRING_GET_CONTAINER (string1_p) != ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 1998:    {
    #####: 1999:      utf8_string1_p = ecma_string_get_chars_fast (string1_p, &utf8_string1_size);
        -: 2000:    }
        -: 2001:    else
        -: 2002:    {
    #####: 2003:      utf8_string1_size = ecma_uint32_to_utf8_string (string1_p->u.uint32_number,
        -: 2004:                                                      uint32_to_string_buffer1,
        -: 2005:                                                      ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
    #####: 2006:      utf8_string1_p = uint32_to_string_buffer1;
        -: 2007:    }
        -: 2008:  }
        -: 2009:
    #####: 2010:  if (ECMA_IS_DIRECT_STRING (string2_p))
        -: 2011:  {
    #####: 2012:    if (ECMA_GET_DIRECT_STRING_TYPE (string2_p) != ECMA_DIRECT_STRING_UINT)
        -: 2013:    {
    #####: 2014:      utf8_string2_p = ecma_string_get_chars_fast (string2_p, &utf8_string2_size);
        -: 2015:    }
        -: 2016:    else
        -: 2017:    {
    #####: 2018:      utf8_string2_size = ecma_uint32_to_utf8_string ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string2_p),
        -: 2019:                                                      uint32_to_string_buffer2,
        -: 2020:                                                      ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
    #####: 2021:      utf8_string2_p = uint32_to_string_buffer2;
        -: 2022:    }
        -: 2023:  }
        -: 2024:  else
        -: 2025:  {
    #####: 2026:    JERRY_ASSERT (string2_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 2027:
    #####: 2028:    if (ECMA_STRING_GET_CONTAINER (string2_p) != ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 2029:    {
    #####: 2030:      utf8_string2_p = ecma_string_get_chars_fast (string2_p, &utf8_string2_size);
        -: 2031:    }
        -: 2032:    else
        -: 2033:    {
    #####: 2034:      utf8_string2_size = ecma_uint32_to_utf8_string (string2_p->u.uint32_number,
        -: 2035:                                                      uint32_to_string_buffer2,
        -: 2036:                                                      ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
    #####: 2037:      utf8_string2_p = uint32_to_string_buffer2;
        -: 2038:    }
        -: 2039:  }
        -: 2040:
    #####: 2041:  return lit_compare_utf8_strings_relational (utf8_string1_p,
        -: 2042:                                              utf8_string1_size,
        -: 2043:                                              utf8_string2_p,
        -: 2044:                                              utf8_string2_size);
        -: 2045:} /* ecma_compare_ecma_strings_relational */
        -: 2046:
        -: 2047:/**
        -: 2048: * Special value to represent that no size is available.
        -: 2049: */
        -: 2050:#define ECMA_STRING_NO_ASCII_SIZE 0xffffffff
        -: 2051:
        -: 2052:/**
        -: 2053: * Return the size of uint32 and magic strings.
        -: 2054: * The length of these strings are equal to their size.
        -: 2055: *
        -: 2056: * @return number of characters in the string
        -: 2057: */
        -: 2058:static lit_utf8_size_t
    #####: 2059:ecma_string_get_ascii_size (const ecma_string_t *string_p) /**< ecma-string */
        -: 2060:{
    #####: 2061:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2062:  {
    #####: 2063:    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))
        -: 2064:    {
    #####: 2065:      case ECMA_DIRECT_STRING_MAGIC:
        -: 2066:      {
    #####: 2067:        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2068:
    #####: 2069:        if (id >= LIT_MAGIC_STRING__COUNT)
        -: 2070:        {
    #####: 2071:          return ECMA_STRING_NO_ASCII_SIZE;
        -: 2072:        }
        -: 2073:
    #####: 2074:        JERRY_ASSERT (ECMA_STRING_IS_ASCII (lit_get_magic_string_utf8 (id),
        -: 2075:                                            lit_get_magic_string_size (id)));
        -: 2076:
    #####: 2077:        return lit_get_magic_string_size (id);
        -: 2078:      }
    #####: 2079:      default:
        -: 2080:      {
    #####: 2081:        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);
    #####: 2082:        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
    #####: 2083:        return ecma_string_get_uint32_size (uint32_number);
        -: 2084:      }
        -: 2085:    }
        -: 2086:  }
        -: 2087:
    #####: 2088:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 2089:
    #####: 2090:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_UINT32_IN_DESC)
        -: 2091:  {
    #####: 2092:    return ecma_string_get_uint32_size (string_p->u.uint32_number);
        -: 2093:  }
    #####: 2094:  else if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_ASCII_STRING)
        -: 2095:  {
    #####: 2096:    return ECMA_ASCII_STRING_GET_SIZE (string_p);
        -: 2097:  }
        -: 2098:
    #####: 2099:  return ECMA_STRING_NO_ASCII_SIZE;
        -: 2100:} /* ecma_string_get_ascii_size */
        -: 2101:
        -: 2102:/**
        -: 2103: * Get length of ecma-string
        -: 2104: *
        -: 2105: * @return number of characters in the string
        -: 2106: */
        -: 2107:lit_utf8_size_t
    #####: 2108:ecma_string_get_length (const ecma_string_t *string_p) /**< ecma-string */
        -: 2109:{
    #####: 2110:  lit_utf8_size_t length = ecma_string_get_ascii_size (string_p);
        -: 2111:
    #####: 2112:  if (length != ECMA_STRING_NO_ASCII_SIZE)
        -: 2113:  {
    #####: 2114:    return length;
        -: 2115:  }
        -: 2116:
    #####: 2117:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2118:  {
    #####: 2119:    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);
    #####: 2120:    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);
        -: 2121:
    #####: 2122:    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT;
    #####: 2123:    return lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id),
        -: 2124:                                   lit_get_magic_string_ex_size (id));
        -: 2125:  }
        -: 2126:
    #####: 2127:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)
        -: 2128:  {
    #####: 2129:    return ((ecma_short_string_t *) string_p)->length;
        -: 2130:  }
        -: 2131:
    #####: 2132:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 2133:  {
    #####: 2134:    return ((ecma_long_string_t *) string_p)->length;
        -: 2135:  }
        -: 2136:
    #####: 2137:  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 2138:
    #####: 2139:  lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
    #####: 2140:  return lit_utf8_string_length (lit_get_magic_string_ex_utf8 (id),
        -: 2141:                                 lit_get_magic_string_ex_size (id));
        -: 2142:} /* ecma_string_get_length */
        -: 2143:
        -: 2144:/**
        -: 2145: * Get length of UTF-8 encoded string length from ecma-string
        -: 2146: *
        -: 2147: * @return number of characters in the UTF-8 encoded string
        -: 2148: */
        -: 2149:lit_utf8_size_t
    #####: 2150:ecma_string_get_utf8_length (const ecma_string_t *string_p) /**< ecma-string */
        -: 2151:{
    #####: 2152:  lit_utf8_size_t length = ecma_string_get_ascii_size (string_p);
        -: 2153:
    #####: 2154:  if (length != ECMA_STRING_NO_ASCII_SIZE)
        -: 2155:  {
    #####: 2156:    return length;
        -: 2157:  }
        -: 2158:
    #####: 2159:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2160:  {
    #####: 2161:    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);
    #####: 2162:    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);
        -: 2163:
    #####: 2164:    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT;
    #####: 2165:    return lit_get_utf8_length_of_cesu8_string (lit_get_magic_string_ex_utf8 (id),
        -: 2166:                                                lit_get_magic_string_ex_size (id));
        -: 2167:  }
        -: 2168:
    #####: 2169:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)
        -: 2170:  {
    #####: 2171:    ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 2172:    lit_utf8_size_t size = short_string_p->size;
        -: 2173:
    #####: 2174:    if (size == short_string_p->length)
        -: 2175:    {
    #####: 2176:      return size;
        -: 2177:    }
        -: 2178:
    #####: 2179:    return lit_get_utf8_length_of_cesu8_string (ECMA_SHORT_STRING_GET_BUFFER (string_p), size);
        -: 2180:  }
        -: 2181:
    #####: 2182:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 2183:  {
    #####: 2184:    ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
    #####: 2185:    lit_utf8_size_t size = long_string_p->size;
        -: 2186:
    #####: 2187:    if (size == long_string_p->length)
        -: 2188:    {
    #####: 2189:      return size;
        -: 2190:    }
        -: 2191:
    #####: 2192:    return lit_get_utf8_length_of_cesu8_string (long_string_p->string_p, size);
        -: 2193:  }
        -: 2194:
    #####: 2195:  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 2196:
    #####: 2197:  lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
        -: 2198:
    #####: 2199:  return lit_get_utf8_length_of_cesu8_string (lit_get_magic_string_ex_utf8 (id),
        -: 2200:                                              lit_get_magic_string_ex_size (id));
        -: 2201:} /* ecma_string_get_utf8_length */
        -: 2202:
        -: 2203:/**
        -: 2204: * Get size of ecma-string
        -: 2205: *
        -: 2206: * @return number of bytes in the buffer needed to represent the string
        -: 2207: */
        -: 2208:lit_utf8_size_t
    #####: 2209:ecma_string_get_size (const ecma_string_t *string_p) /**< ecma-string */
        -: 2210:{
    #####: 2211:  lit_utf8_size_t length = ecma_string_get_ascii_size (string_p);
        -: 2212:
    #####: 2213:  if (length != ECMA_STRING_NO_ASCII_SIZE)
        -: 2214:  {
    #####: 2215:    return length;
        -: 2216:  }
        -: 2217:
    #####: 2218:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2219:  {
    #####: 2220:    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);
    #####: 2221:    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);
        -: 2222:
    #####: 2223:    return lit_get_magic_string_ex_size ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT);
        -: 2224:  }
        -: 2225:
    #####: 2226:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)
        -: 2227:  {
    #####: 2228:    return ((ecma_short_string_t *) string_p)->size;
        -: 2229:  }
        -: 2230:
    #####: 2231:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 2232:  {
    #####: 2233:    return ((ecma_long_string_t *) string_p)->size;
        -: 2234:  }
        -: 2235:
    #####: 2236:  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 2237:
    #####: 2238:  return lit_get_magic_string_ex_size (LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id);
        -: 2239:} /* ecma_string_get_size */
        -: 2240:
        -: 2241:/**
        -: 2242: * Get the UTF-8 encoded string size from ecma-string
        -: 2243: *
        -: 2244: * @return number of bytes in the buffer needed to represent an UTF-8 encoded string
        -: 2245: */
        -: 2246:lit_utf8_size_t
    #####: 2247:ecma_string_get_utf8_size (const ecma_string_t *string_p) /**< ecma-string */
        -: 2248:{
    #####: 2249:  lit_utf8_size_t length = ecma_string_get_ascii_size (string_p);
        -: 2250:
    #####: 2251:  if (length != ECMA_STRING_NO_ASCII_SIZE)
        -: 2252:  {
    #####: 2253:    return length;
        -: 2254:  }
        -: 2255:
    #####: 2256:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2257:  {
    #####: 2258:    JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_MAGIC);
    #####: 2259:    JERRY_ASSERT ((uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) >= LIT_MAGIC_STRING__COUNT);
        -: 2260:
    #####: 2261:    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p) - LIT_MAGIC_STRING__COUNT;
    #####: 2262:    return lit_get_utf8_size_of_cesu8_string (lit_get_magic_string_ex_utf8 (id),
        -: 2263:                                              lit_get_magic_string_ex_size (id));
        -: 2264:  }
        -: 2265:
    #####: 2266:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_HEAP_UTF8_STRING)
        -: 2267:  {
    #####: 2268:    ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 2269:    lit_utf8_size_t size = short_string_p->size;
        -: 2270:
    #####: 2271:    if (size == short_string_p->length)
        -: 2272:    {
    #####: 2273:      return size;
        -: 2274:    }
        -: 2275:
    #####: 2276:    return lit_get_utf8_size_of_cesu8_string (ECMA_SHORT_STRING_GET_BUFFER (string_p), size);
        -: 2277:  }
        -: 2278:
    #####: 2279:  if (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 2280:  {
    #####: 2281:    ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -: 2282:
    #####: 2283:    if (long_string_p->size == long_string_p->length)
        -: 2284:    {
    #####: 2285:      return long_string_p->size;
        -: 2286:    }
        -: 2287:
    #####: 2288:    return lit_get_utf8_size_of_cesu8_string (long_string_p->string_p, long_string_p->size);
        -: 2289:  }
        -: 2290:
    #####: 2291:  JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
        -: 2292:
    #####: 2293:  lit_magic_string_ex_id_t id = LIT_MAGIC_STRING__COUNT - string_p->u.magic_string_ex_id;
    #####: 2294:  return lit_get_utf8_size_of_cesu8_string (lit_get_magic_string_ex_utf8 (id),
        -: 2295:                                            lit_get_magic_string_ex_size (id));
        -: 2296:} /* ecma_string_get_utf8_size */
        -: 2297:
        -: 2298:/**
        -: 2299: * Get character from specified position in an external ecma-string.
        -: 2300: *
        -: 2301: * @return character value
        -: 2302: */
        -: 2303:static ecma_char_t JERRY_ATTR_NOINLINE
    #####: 2304:ecma_external_string_get_char_at_pos (lit_utf8_size_t id, /**< id of the external magic string */
        -: 2305:                                      lit_utf8_size_t index) /**< index of character */
        -: 2306:{
    #####: 2307:  id -= LIT_MAGIC_STRING__COUNT;
    #####: 2308:  const lit_utf8_byte_t *data_p = lit_get_magic_string_ex_utf8 (id);
    #####: 2309:  lit_utf8_size_t size = lit_get_magic_string_ex_size (id);
    #####: 2310:  lit_utf8_size_t length = lit_utf8_string_length (data_p, size);
        -: 2311:
    #####: 2312:  if (JERRY_LIKELY (size == length))
        -: 2313:  {
    #####: 2314:    return (ecma_char_t) data_p[index];
        -: 2315:  }
        -: 2316:
    #####: 2317:  return lit_utf8_string_code_unit_at (data_p, size, index);
        -: 2318:} /* ecma_external_string_get_char_at_pos */
        -: 2319:
        -: 2320:/**
        -: 2321: * Get character from specified position in the ecma-string.
        -: 2322: *
        -: 2323: * @return character value
        -: 2324: */
        -: 2325:ecma_char_t
    #####: 2326:ecma_string_get_char_at_pos (const ecma_string_t *string_p, /**< ecma-string */
        -: 2327:                             lit_utf8_size_t index) /**< index of character */
        -: 2328:{
    #####: 2329:  JERRY_ASSERT (index < ecma_string_get_length (string_p));
        -: 2330:
    #####: 2331:  lit_utf8_byte_t uint32_to_string_buffer[ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32];
        -: 2332:
    #####: 2333:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2334:  {
    #####: 2335:    switch (ECMA_GET_DIRECT_STRING_TYPE (string_p))
        -: 2336:    {
    #####: 2337:      case ECMA_DIRECT_STRING_MAGIC:
        -: 2338:      {
    #####: 2339:        uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2340:
    #####: 2341:        if (JERRY_LIKELY (id < LIT_MAGIC_STRING__COUNT))
        -: 2342:        {
        -: 2343:          /* All magic strings must be ascii strings. */
    #####: 2344:          const lit_utf8_byte_t *data_p = lit_get_magic_string_utf8 (id);
        -: 2345:
    #####: 2346:          return (ecma_char_t) data_p[index];
        -: 2347:        }
        -: 2348:
    #####: 2349:        return ecma_external_string_get_char_at_pos (id, index);
        -: 2350:      }
    #####: 2351:      default:
        -: 2352:      {
    #####: 2353:        JERRY_ASSERT (ECMA_GET_DIRECT_STRING_TYPE (string_p) == ECMA_DIRECT_STRING_UINT);
    #####: 2354:        uint32_t uint32_number = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2355:
    #####: 2356:        ecma_uint32_to_utf8_string (uint32_number, uint32_to_string_buffer, ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
        -: 2357:
    #####: 2358:        return (ecma_char_t) uint32_to_string_buffer[index];
        -: 2359:      }
        -: 2360:    }
        -: 2361:  }
        -: 2362:
    #####: 2363:  JERRY_ASSERT (string_p->refs_and_container >= ECMA_STRING_REF_ONE);
        -: 2364:
    #####: 2365:  switch (ECMA_STRING_GET_CONTAINER (string_p))
        -: 2366:  {
    #####: 2367:    case ECMA_STRING_CONTAINER_HEAP_UTF8_STRING:
        -: 2368:    {
    #####: 2369:      ecma_short_string_t *short_string_p = (ecma_short_string_t *) string_p;
    #####: 2370:      lit_utf8_size_t size = short_string_p->size;
    #####: 2371:      const lit_utf8_byte_t *data_p = ECMA_SHORT_STRING_GET_BUFFER (string_p);
        -: 2372:
    #####: 2373:      if (JERRY_LIKELY (size == short_string_p->length))
        -: 2374:      {
    #####: 2375:        return (ecma_char_t) data_p[index];
        -: 2376:      }
        -: 2377:
    #####: 2378:      return lit_utf8_string_code_unit_at (data_p, size, index);
        -: 2379:    }
    #####: 2380:    case ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING:
        -: 2381:    {
    #####: 2382:      ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
    #####: 2383:      lit_utf8_size_t size = long_string_p->size;
    #####: 2384:      const lit_utf8_byte_t *data_p = long_string_p->string_p;
        -: 2385:
    #####: 2386:      if (JERRY_LIKELY (size == long_string_p->length))
        -: 2387:      {
    #####: 2388:        return (ecma_char_t) data_p[index];
        -: 2389:      }
        -: 2390:
    #####: 2391:      return lit_utf8_string_code_unit_at (data_p, size, index);
        -: 2392:    }
    #####: 2393:    case ECMA_STRING_CONTAINER_HEAP_ASCII_STRING:
        -: 2394:    {
    #####: 2395:      const lit_utf8_byte_t *data_p = ECMA_ASCII_STRING_GET_BUFFER (string_p);
    #####: 2396:      return (ecma_char_t) data_p[index];
        -: 2397:    }
    #####: 2398:    case ECMA_STRING_CONTAINER_UINT32_IN_DESC:
        -: 2399:    {
    #####: 2400:      ecma_uint32_to_utf8_string (string_p->u.uint32_number,
        -: 2401:                                  uint32_to_string_buffer,
        -: 2402:                                  ECMA_MAX_CHARS_IN_STRINGIFIED_UINT32);
        -: 2403:
    #####: 2404:      return (ecma_char_t) uint32_to_string_buffer[index];
        -: 2405:    }
    #####: 2406:    default:
        -: 2407:    {
    #####: 2408:      JERRY_ASSERT (ECMA_STRING_GET_CONTAINER (string_p) == ECMA_STRING_CONTAINER_MAGIC_STRING_EX);
    #####: 2409:      return ecma_external_string_get_char_at_pos (string_p->u.magic_string_ex_id, index);
        -: 2410:    }
        -: 2411:  }
        -: 2412:} /* ecma_string_get_char_at_pos */
        -: 2413:
        -: 2414:/**
        -: 2415: * Check if passed string equals to one of magic strings
        -: 2416: * and if equal magic string was found, return it's id in 'out_id_p' argument.
        -: 2417: *
        -: 2418: * @return id - if magic string equal to passed string was found,
        -: 2419: *         LIT_MAGIC_STRING__COUNT - otherwise.
        -: 2420: */
        -: 2421:lit_magic_string_id_t
       30: 2422:ecma_get_string_magic (const ecma_string_t *string_p) /**< ecma-string */
        -: 2423:{
       30: 2424:  if (ECMA_IS_DIRECT_STRING_WITH_TYPE (string_p, ECMA_DIRECT_STRING_MAGIC))
        -: 2425:  {
        4: 2426:    uint32_t id = (uint32_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2427:
        4: 2428:    if (id < LIT_MAGIC_STRING__COUNT)
        -: 2429:    {
        4: 2430:      return (lit_magic_string_id_t) id;
        -: 2431:    }
        -: 2432:  }
        -: 2433:
       26: 2434:  return LIT_MAGIC_STRING__COUNT;
        -: 2435:} /* ecma_get_string_magic */
        -: 2436:
        -: 2437:/**
        -: 2438: * Try to calculate hash of the ecma-string
        -: 2439: *
        -: 2440: * @return calculated hash
        -: 2441: */
        -: 2442:extern inline lit_string_hash_t JERRY_ATTR_ALWAYS_INLINE
    #####: 2443:ecma_string_hash (const ecma_string_t *string_p) /**< ecma-string to calculate hash for */
        -: 2444:{
    #####: 2445:  if (ECMA_IS_DIRECT_STRING (string_p))
        -: 2446:  {
    #####: 2447:    return (lit_string_hash_t) ECMA_GET_DIRECT_STRING_VALUE (string_p);
        -: 2448:  }
        -: 2449:
    #####: 2450:  return (lit_string_hash_t) string_p->u.hash;
        -: 2451:} /* ecma_string_hash */
        -: 2452:
        -: 2453:/**
        -: 2454: * Create a substring from an ecma string
        -: 2455: *
        -: 2456: * @return a newly consturcted ecma string with its value initialized to a copy of a substring of the first argument
        -: 2457: */
        -: 2458:ecma_string_t *
    #####: 2459:ecma_string_substr (const ecma_string_t *string_p, /**< pointer to an ecma string */
        -: 2460:                    lit_utf8_size_t start_pos, /**< start position, should be less or equal than string length */
        -: 2461:                    lit_utf8_size_t end_pos) /**< end position, should be less or equal than string length */
        -: 2462:{
    #####: 2463:  const lit_utf8_size_t string_length = ecma_string_get_length (string_p);
    #####: 2464:  JERRY_ASSERT (start_pos <= string_length);
    #####: 2465:  JERRY_ASSERT (end_pos <= string_length);
        -: 2466:
    #####: 2467:  if (start_pos >= end_pos)
        -: 2468:  {
    #####: 2469:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 2470:  }
        -: 2471:
    #####: 2472:  ecma_string_t *ecma_string_p = NULL;
    #####: 2473:  end_pos -= start_pos;
        -: 2474:
    #####: 2475:  ECMA_STRING_TO_UTF8_STRING (string_p, start_p, buffer_size);
        -: 2476:
    #####: 2477:  if (string_length == buffer_size)
        -: 2478:  {
    #####: 2479:    ecma_string_p = ecma_new_ecma_string_from_utf8 (start_p + start_pos, (lit_utf8_size_t) end_pos);
        -: 2480:  }
        -: 2481:  else
        -: 2482:  {
    #####: 2483:    while (start_pos--)
        -: 2484:    {
    #####: 2485:      start_p += lit_get_unicode_char_size_by_utf8_first_byte (*start_p);
        -: 2486:    }
        -: 2487:
    #####: 2488:    const lit_utf8_byte_t *end_p = start_p;
    #####: 2489:    while (end_pos--)
        -: 2490:    {
    #####: 2491:      end_p += lit_get_unicode_char_size_by_utf8_first_byte (*end_p);
        -: 2492:    }
        -: 2493:
    #####: 2494:    ecma_string_p = ecma_new_ecma_string_from_utf8 (start_p, (lit_utf8_size_t) (end_p - start_p));
        -: 2495:  }
        -: 2496:
    #####: 2497:  ECMA_FINALIZE_UTF8_STRING (start_p, buffer_size);
        -: 2498:
    #####: 2499:  return ecma_string_p;
        -: 2500:} /* ecma_string_substr */
        -: 2501:
        -: 2502:/**
        -: 2503: * Helper function for trimming.
        -: 2504: *
        -: 2505: * Used by:
        -: 2506: *        - ecma_string_trim_helper
        -: 2507: *        - ecma_builtin_global_object_parse_int
        -: 2508: *        - ecma_builtin_global_object_parse_float
        -: 2509: *
        -: 2510: * @return position of the first non whitespace character.
        -: 2511: */
        -: 2512:const lit_utf8_byte_t *
        5: 2513:ecma_string_trim_front (const lit_utf8_byte_t *start_p, /**< current string's start position */
        -: 2514:                        const lit_utf8_byte_t *end_p)  /**< current string's end position */
        -: 2515:{
        5: 2516:  ecma_char_t ch;
        -: 2517:
       10: 2518:  while (start_p < end_p)
        -: 2519:  {
        5: 2520:    lit_utf8_size_t read_size = lit_read_code_unit_from_cesu8 (start_p, &ch);
        -: 2521:
        5: 2522:    if (!lit_char_is_white_space (ch))
        -: 2523:    {
        5: 2524:      break;
        -: 2525:    }
        -: 2526:
    #####: 2527:    start_p += read_size;
        -: 2528:  }
        -: 2529:
        5: 2530:  return start_p;
        -: 2531:} /* ecma_string_trim_front */
        -: 2532:
        -: 2533:/**
        -: 2534: * Helper function for trimming.
        -: 2535: *
        -: 2536: * Used by:
        -: 2537: *        - ecma_string_trim_helper
        -: 2538: *
        -: 2539: * @return position of the last non whitespace character.
        -: 2540: */
        -: 2541:const lit_utf8_byte_t *
        5: 2542:ecma_string_trim_back (const lit_utf8_byte_t *start_p, /**< current string's start position */
        -: 2543:                       const lit_utf8_byte_t *end_p)  /**< current string's end position */
        -: 2544:{
        5: 2545:  ecma_char_t ch;
        -: 2546:
       10: 2547:  while (end_p > start_p)
        -: 2548:  {
        5: 2549:    lit_utf8_size_t read_size = lit_read_prev_code_unit_from_utf8 (end_p, &ch);
        -: 2550:
        5: 2551:    if (!lit_char_is_white_space (ch))
        -: 2552:    {
        5: 2553:      break;
        -: 2554:    }
        -: 2555:
    #####: 2556:    end_p -= read_size;
        -: 2557:  }
        -: 2558:
        5: 2559:  return end_p;
        -: 2560:} /* ecma_string_trim_back */
        -: 2561:
        -: 2562:/**
        -: 2563: * Helper function for trimming.
        -: 2564: *
        -: 2565: * Used by:
        -: 2566: *        - ecma_string_trim
        -: 2567: *        - ecma_utf8_string_to_number
        -: 2568: */
        -: 2569:extern inline void JERRY_ATTR_ALWAYS_INLINE
        5: 2570:ecma_string_trim_helper (const lit_utf8_byte_t **utf8_str_p, /**< [in, out] current string position */
        -: 2571:                         lit_utf8_size_t *utf8_str_size)  /**< [in, out] size of the given string */
        -: 2572:{
        5: 2573:  const lit_utf8_byte_t *end_p = *utf8_str_p + *utf8_str_size;
        5: 2574:  const lit_utf8_byte_t *start_p = *utf8_str_p;
        -: 2575:
        5: 2576:  const lit_utf8_byte_t *new_start_p = ecma_string_trim_front (start_p, end_p);
        5: 2577:  const lit_utf8_byte_t *new_end_p = ecma_string_trim_back (new_start_p, end_p);
        -: 2578:
        5: 2579:  *utf8_str_size = (lit_utf8_size_t) (new_end_p - new_start_p);
        5: 2580:  *utf8_str_p = new_start_p;
        5: 2581:} /* ecma_string_trim_helper */
        -: 2582:
        -: 2583:/**
        -: 2584: * Trim leading and trailing whitespace characters from string.
        -: 2585: *
        -: 2586: * @return trimmed ecma string
        -: 2587: */
        -: 2588:ecma_string_t *
    #####: 2589:ecma_string_trim (const ecma_string_t *string_p) /**< pointer to an ecma string */
        -: 2590:{
        -: 2591:  ecma_string_t *ret_string_p;
        -: 2592:
    #####: 2593:  lit_utf8_size_t utf8_str_size;
    #####: 2594:  uint8_t flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 2595:  const lit_utf8_byte_t *utf8_str_p = ecma_string_get_chars (string_p, &utf8_str_size, NULL, NULL, &flags);
        -: 2596:
    #####: 2597:  if (utf8_str_size > 0)
        -: 2598:  {
    #####: 2599:    ecma_string_trim_helper (&utf8_str_p, &utf8_str_size);
    #####: 2600:    ret_string_p = ecma_new_ecma_string_from_utf8 (utf8_str_p, utf8_str_size);
        -: 2601:  }
        -: 2602:  else
        -: 2603:  {
    #####: 2604:    ret_string_p = ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -: 2605:  }
        -: 2606:
    #####: 2607:  if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2608:  {
    #####: 2609:    jmem_heap_free_block ((void *) utf8_str_p, utf8_str_size);
        -: 2610:  }
        -: 2611:
    #####: 2612:  return ret_string_p;
        -: 2613:} /* ecma_string_trim */
        -: 2614:
        -: 2615:#if JERRY_ESNEXT
        -: 2616:
        -: 2617:/**
        -: 2618: * Pad the beginning or the end of string with parameter given in fill_string to the length of max_length.
        -: 2619: *
        -: 2620: * @return new string from original, padded with given parameters
        -: 2621: */
        -: 2622:ecma_value_t
    #####: 2623:ecma_string_pad (ecma_value_t original_string_p, /**< Input ecma string */
        -: 2624:                 ecma_value_t max_length, /**< Length to pad to, including original length */
        -: 2625:                 ecma_value_t fill_string,  /**< The string to pad with */
        -: 2626:                 bool pad_on_start) /**< true - if we are padding to the start, calling with padStart
        -: 2627:                                         false - if we are padding to the end, calling with padEnd */
        -: 2628:{
        -: 2629:
        -: 2630:  /* 3 */
    #####: 2631:  ecma_length_t int_max_length;
    #####: 2632:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_length (max_length, &int_max_length)))
        -: 2633:  {
    #####: 2634:    return ECMA_VALUE_ERROR;
        -: 2635:  }
        -: 2636:  /* 4 */
    #####: 2637:  ecma_string_t *original_str_val_p = ecma_get_string_from_value (original_string_p);
    #####: 2638:  const uint32_t string_length = ecma_string_get_length (original_str_val_p);
        -: 2639:  /* 5 */
    #####: 2640:  if (int_max_length <= string_length)
        -: 2641:  {
    #####: 2642:    ecma_ref_ecma_string (original_str_val_p);
    #####: 2643:    return original_string_p;
        -: 2644:  }
        -: 2645:
    #####: 2646:  ecma_string_t *filler_p = ecma_get_magic_string (LIT_MAGIC_STRING_SPACE_CHAR);
        -: 2647:  /* 6 - 7 */
    #####: 2648:  if (!ecma_is_value_undefined (fill_string))
        -: 2649:  {
    #####: 2650:    filler_p = ecma_op_to_string (fill_string);
    #####: 2651:    if (filler_p == NULL)
        -: 2652:    {
    #####: 2653:      return ECMA_VALUE_ERROR;
        -: 2654:    }
    #####: 2655:    if (ecma_string_is_empty (filler_p))
        -: 2656:    {
    #####: 2657:      ecma_ref_ecma_string (original_str_val_p);
    #####: 2658:      return original_string_p;
        -: 2659:    }
        -: 2660:  }
        -: 2661:
    #####: 2662:  if (int_max_length >= UINT32_MAX)
        -: 2663:  {
    #####: 2664:    ecma_deref_ecma_string (filler_p);
    #####: 2665:    return ecma_raise_range_error (ECMA_ERR_MSG ("Maximum string length is reached"));
        -: 2666:  }
        -: 2667:
        -: 2668:  /* 9 */
    #####: 2669:  uint32_t fill_len = (uint32_t) int_max_length - string_length;
        -: 2670:
        -: 2671:  /* 10 */
    #####: 2672:  uint32_t filler_length = ecma_string_get_length (filler_p);
    #####: 2673:  uint32_t prepend_count = fill_len / filler_length;
    #####: 2674:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -: 2675:
    #####: 2676:  if (!pad_on_start)
        -: 2677:  {
    #####: 2678:    ecma_stringbuilder_append (&builder, original_str_val_p);
        -: 2679:  }
        -: 2680:
    #####: 2681:  for (uint32_t i = 0; i < prepend_count; i++)
        -: 2682:  {
    #####: 2683:    ecma_stringbuilder_append (&builder, filler_p);
        -: 2684:  }
        -: 2685:
    #####: 2686:  uint32_t remaining = fill_len - (prepend_count * filler_length);
        -: 2687:
    #####: 2688:  ECMA_STRING_TO_UTF8_STRING (filler_p, start_p, utf8_str_size);
    #####: 2689:  const lit_utf8_byte_t *temp_start_p = start_p;
    #####: 2690:  while (remaining > 0)
        -: 2691:  {
    #####: 2692:    ecma_char_t ch;
    #####: 2693:    lit_utf8_size_t read_size = lit_read_code_unit_from_cesu8 (temp_start_p, &ch);
    #####: 2694:    ecma_stringbuilder_append_char (&builder, ch);
    #####: 2695:    temp_start_p += read_size;
    #####: 2696:    remaining--;
        -: 2697:  }
    #####: 2698:  ECMA_FINALIZE_UTF8_STRING (start_p, utf8_str_size);
    #####: 2699:  ecma_deref_ecma_string (filler_p);
        -: 2700:
        -: 2701:  /* 11 - 12 */
    #####: 2702:  if (pad_on_start)
        -: 2703:  {
    #####: 2704:    ecma_stringbuilder_append (&builder, original_str_val_p);
        -: 2705:  }
        -: 2706:
    #####: 2707:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 2708:} /* ecma_string_pad */
        -: 2709:#endif /* JERRY_ESNEXT */
        -: 2710:
        -: 2711:/**
        -: 2712: * Create an empty string builder
        -: 2713: *
        -: 2714: * @return new string builder
        -: 2715: */
        -: 2716:ecma_stringbuilder_t
    #####: 2717:ecma_stringbuilder_create (void)
        -: 2718:{
    #####: 2719:  const lit_utf8_size_t initial_size = ECMA_ASCII_STRING_HEADER_SIZE;
    #####: 2720:  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);
    #####: 2721:  header_p->current_size = initial_size;
        -: 2722:#if JERRY_MEM_STATS
    #####: 2723:  jmem_stats_allocate_string_bytes (initial_size);
        -: 2724:#endif /* JERRY_MEM_STATS */
        -: 2725:
    #####: 2726:  ecma_stringbuilder_t ret = {.header_p = header_p};
    #####: 2727:  return ret;
        -: 2728:} /* ecma_stringbuilder_create */
        -: 2729:
        -: 2730:/**
        -: 2731: * Create a string builder from an ecma string
        -: 2732: *
        -: 2733: * @return new string builder
        -: 2734: */
        -: 2735:ecma_stringbuilder_t
    #####: 2736:ecma_stringbuilder_create_from (ecma_string_t *string_p) /**< ecma string */
        -: 2737:{
    #####: 2738:  const lit_utf8_size_t string_size = ecma_string_get_size (string_p);
    #####: 2739:  const lit_utf8_size_t initial_size = string_size + ECMA_ASCII_STRING_HEADER_SIZE;
        -: 2740:
    #####: 2741:  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);
    #####: 2742:  header_p->current_size = initial_size;
        -: 2743:#if JERRY_MEM_STATS
    #####: 2744:  jmem_stats_allocate_string_bytes (initial_size);
        -: 2745:#endif /* JERRY_MEM_STATS */
        -: 2746:
    #####: 2747:  size_t copied_size = ecma_string_copy_to_cesu8_buffer (string_p,
        -: 2748:                                                         ECMA_STRINGBUILDER_STRING_PTR (header_p),
        -: 2749:                                                         string_size);
    #####: 2750:  JERRY_ASSERT (copied_size == string_size);
        -: 2751:
    #####: 2752:  ecma_stringbuilder_t ret = {.header_p = header_p};
    #####: 2753:  return ret;
        -: 2754:} /* ecma_stringbuilder_create_from */
        -: 2755:
        -: 2756:/**
        -: 2757: * Create a string builder from a raw string
        -: 2758: *
        -: 2759: * @return new string builder
        -: 2760: */
        -: 2761:ecma_stringbuilder_t
    #####: 2762:ecma_stringbuilder_create_raw (const lit_utf8_byte_t *data_p, /**< pointer to data */
        -: 2763:                               const lit_utf8_size_t data_size) /**< size of the data */
        -: 2764:{
    #####: 2765:  const lit_utf8_size_t initial_size = data_size + ECMA_ASCII_STRING_HEADER_SIZE;
        -: 2766:
    #####: 2767:  ecma_stringbuilder_header_t *header_p = (ecma_stringbuilder_header_t *) jmem_heap_alloc_block (initial_size);
    #####: 2768:  header_p->current_size = initial_size;
        -: 2769:#if JERRY_MEM_STATS
    #####: 2770:  jmem_stats_allocate_string_bytes (initial_size);
        -: 2771:#endif /* JERRY_MEM_STATS */
        -: 2772:
    #####: 2773:  memcpy (ECMA_STRINGBUILDER_STRING_PTR (header_p), data_p, data_size);
        -: 2774:
    #####: 2775:  ecma_stringbuilder_t ret = {.header_p = header_p};
    #####: 2776:  return ret;
        -: 2777:} /* ecma_stringbuilder_create_raw */
        -: 2778:
        -: 2779:/**
        -: 2780: * Grow the underlying buffer of a string builder
        -: 2781: *
        -: 2782: * @return pointer to the end of the data in the underlying buffer
        -: 2783: */
        -: 2784:static lit_utf8_byte_t *
    #####: 2785:ecma_stringbuilder_grow (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2786:                         lit_utf8_size_t required_size) /**< required size */
        -: 2787:{
    #####: 2788:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2789:  JERRY_ASSERT (header_p != NULL);
        -: 2790:
    #####: 2791:  const lit_utf8_size_t new_size = header_p->current_size + required_size;
    #####: 2792:  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, new_size);
    #####: 2793:  header_p->current_size = new_size;
    #####: 2794:  builder_p->header_p = header_p;
        -: 2795:
        -: 2796:#if JERRY_MEM_STATS
    #####: 2797:  jmem_stats_allocate_string_bytes (required_size);
        -: 2798:#endif /* JERRY_MEM_STATS */
        -: 2799:
    #####: 2800:  return ((lit_utf8_byte_t *)  header_p) + header_p->current_size - required_size;
        -: 2801:} /* ecma_stringbuilder_grow */
        -: 2802:
        -: 2803:/**
        -: 2804: * Get the current size of the string in a string builder
        -: 2805: *
        -: 2806: * @return the size of the string data
        -: 2807: */
        -: 2808:lit_utf8_size_t
    #####: 2809:ecma_stringbuilder_get_size (ecma_stringbuilder_t *builder_p) /**< string builder */
        -: 2810:{
    #####: 2811:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2812:  JERRY_ASSERT (header_p != NULL);
        -: 2813:
    #####: 2814:  return ECMA_STRINGBUILDER_STRING_SIZE (header_p);
        -: 2815:} /* ecma_stringbuilder_get_size */
        -: 2816:
        -: 2817:/**
        -: 2818: * Get pointer to the raw string data in a string builder
        -: 2819: *
        -: 2820: * @return pointer to the string data
        -: 2821: */
        -: 2822:lit_utf8_byte_t *
    #####: 2823:ecma_stringbuilder_get_data (ecma_stringbuilder_t *builder_p) /**< string builder */
        -: 2824:{
    #####: 2825:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2826:  JERRY_ASSERT (header_p != NULL);
        -: 2827:
    #####: 2828:  return ECMA_STRINGBUILDER_STRING_PTR (header_p);
        -: 2829:} /* ecma_stringbuilder_get_data */
        -: 2830:
        -: 2831:/**
        -: 2832: * Revert the string builder to a smaller size
        -: 2833: */
        -: 2834:void
    #####: 2835:ecma_stringbuilder_revert (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2836:                           const lit_utf8_size_t size) /**< new size */
        -: 2837:{
    #####: 2838:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2839:  JERRY_ASSERT (header_p != NULL);
        -: 2840:
    #####: 2841:  const lit_utf8_size_t new_size = size + ECMA_ASCII_STRING_HEADER_SIZE;
    #####: 2842:  JERRY_ASSERT (new_size <= header_p->current_size);
        -: 2843:
        -: 2844:#if JERRY_MEM_STATS
    #####: 2845:  jmem_stats_free_string_bytes (header_p->current_size - new_size);
        -: 2846:#endif /* JERRY_MEM_STATS */
        -: 2847:
    #####: 2848:  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, new_size);
    #####: 2849:  header_p->current_size = new_size;
    #####: 2850:  builder_p->header_p = header_p;
    #####: 2851:} /* ecma_stringbuilder_revert */
        -: 2852:
        -: 2853:/**
        -: 2854: * Append an ecma_string_t to a string builder
        -: 2855: */
        -: 2856:void
    #####: 2857:ecma_stringbuilder_append (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2858:                           const ecma_string_t *string_p) /**< ecma string */
        -: 2859:{
    #####: 2860:  const lit_utf8_size_t string_size = ecma_string_get_size (string_p);
    #####: 2861:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, string_size);
        -: 2862:
    #####: 2863:  size_t copied_size = ecma_string_copy_to_cesu8_buffer (string_p,
        -: 2864:                                                         dest_p,
        -: 2865:                                                         string_size);
    #####: 2866:  JERRY_ASSERT (copied_size == string_size);
    #####: 2867:} /* ecma_stringbuilder_append */
        -: 2868:
        -: 2869:/**
        -: 2870: * Append a magic string to a string builder
        -: 2871: */
        -: 2872:void
    #####: 2873:ecma_stringbuilder_append_magic (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2874:                                 const lit_magic_string_id_t id) /**< magic string id */
        -: 2875:{
    #####: 2876:  const lit_utf8_size_t string_size = lit_get_magic_string_size (id);
    #####: 2877:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, string_size);
        -: 2878:
    #####: 2879:  const lit_utf8_byte_t *string_data_p = lit_get_magic_string_utf8 (id);
    #####: 2880:  memcpy (dest_p, string_data_p, string_size);
    #####: 2881:} /* ecma_stringbuilder_append_magic */
        -: 2882:
        -: 2883:/**
        -: 2884: * Append raw string data to a string builder
        -: 2885: */
        -: 2886:void
    #####: 2887:ecma_stringbuilder_append_raw (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2888:                               const lit_utf8_byte_t *data_p, /**< pointer to data */
        -: 2889:                               const lit_utf8_size_t data_size) /**< size of the data */
        -: 2890:{
    #####: 2891:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, data_size);
    #####: 2892:  memcpy (dest_p, data_p, data_size);
    #####: 2893:} /* ecma_stringbuilder_append_raw */
        -: 2894:
        -: 2895:/**
        -: 2896: * Append a codepoint to a string builder
        -: 2897: */
        -: 2898:void
    #####: 2899:ecma_stringbuilder_append_codepoint (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2900:                                     lit_code_point_t cp) /**< code point */
        -: 2901:{
    #####: 2902:  const lit_utf8_size_t size = (lit_utf8_size_t) lit_code_point_get_cesu8_length (cp);
    #####: 2903:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, size);
        -: 2904:
    #####: 2905:  lit_code_point_to_cesu8_bytes (dest_p, cp);
    #####: 2906:} /* ecma_stringbuilder_append_codepoint */
        -: 2907:
        -: 2908:/**
        -: 2909: * Append an ecma_char_t to a string builder
        -: 2910: */
        -: 2911:void
    #####: 2912:ecma_stringbuilder_append_char (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2913:                                const ecma_char_t c) /**< ecma char */
        -: 2914:{
    #####: 2915:  ecma_stringbuilder_append_codepoint (builder_p, c);
    #####: 2916:} /* ecma_stringbuilder_append_char */
        -: 2917:
        -: 2918:/**
        -: 2919: * Append a single byte to a string builder
        -: 2920: */
        -: 2921:void
    #####: 2922:ecma_stringbuilder_append_byte (ecma_stringbuilder_t *builder_p, /**< string builder */
        -: 2923:                                const lit_utf8_byte_t byte) /**< byte */
        -: 2924:{
    #####: 2925:  lit_utf8_byte_t *dest_p = ecma_stringbuilder_grow (builder_p, 1);
    #####: 2926:  *dest_p = byte;
    #####: 2927:} /* ecma_stringbuilder_append_byte */
        -: 2928:
        -: 2929:/**
        -: 2930: * Finalize a string builder, returning the created string, and releasing the underlying buffer.
        -: 2931: *
        -: 2932: * Note:
        -: 2933: *      The builder should no longer be used.
        -: 2934: *
        -: 2935: * @return the created string
        -: 2936: */
        -: 2937:ecma_string_t *
    #####: 2938:ecma_stringbuilder_finalize (ecma_stringbuilder_t *builder_p) /**< string builder */
        -: 2939:{
    #####: 2940:  ecma_stringbuilder_header_t *header_p = builder_p->header_p;
    #####: 2941:  JERRY_ASSERT (header_p != NULL);
        -: 2942:
    #####: 2943:  const lit_utf8_size_t string_size = ECMA_STRINGBUILDER_STRING_SIZE (header_p);
    #####: 2944:  lit_utf8_byte_t *string_begin_p = ECMA_STRINGBUILDER_STRING_PTR (header_p);
        -: 2945:
    #####: 2946:  ecma_string_t *string_p = ecma_find_special_string (string_begin_p, string_size);
        -: 2947:
    #####: 2948:  if (JERRY_UNLIKELY (string_p != NULL))
        -: 2949:  {
    #####: 2950:    ecma_stringbuilder_destroy (builder_p);
    #####: 2951:    return string_p;
        -: 2952:  }
        -: 2953:
        -: 2954:#ifndef JERRY_NDEBUG
    #####: 2955:  builder_p->header_p = NULL;
        -: 2956:#endif
        -: 2957:
    #####: 2958:  size_t container_size = sizeof (ecma_short_string_t);
    #####: 2959:  const lit_string_hash_t hash = lit_utf8_string_calc_hash (string_begin_p, string_size);
    #####: 2960:  const lit_utf8_size_t length = lit_utf8_string_length (string_begin_p, string_size);
        -: 2961:
    #####: 2962:  if (JERRY_LIKELY (string_size <= UINT16_MAX))
        -: 2963:  {
    #####: 2964:    if (JERRY_LIKELY (length == string_size) && string_size <= (UINT8_MAX + 1))
        -: 2965:    {
    #####: 2966:      string_p = (ecma_string_t *) header_p;
    #####: 2967:      string_p->refs_and_container = ECMA_STRING_CONTAINER_HEAP_ASCII_STRING | ECMA_STRING_REF_ONE;
    #####: 2968:      string_p->u.hash = hash;
    #####: 2969:      ECMA_ASCII_STRING_SET_SIZE (string_p, string_size);
        -: 2970:
    #####: 2971:      return (ecma_string_t *) string_p;
        -: 2972:    }
        -: 2973:  }
        -: 2974:  else
        -: 2975:  {
    #####: 2976:    container_size = sizeof (ecma_long_string_t);
        -: 2977:  }
        -: 2978:
    #####: 2979:  const size_t utf8_string_size = string_size + container_size;
    #####: 2980:  header_p = jmem_heap_realloc_block (header_p, header_p->current_size, utf8_string_size);
    #####: 2981:  memmove (((lit_utf8_byte_t *) header_p + container_size),
        -: 2982:           ECMA_STRINGBUILDER_STRING_PTR (header_p),
        -: 2983:           string_size);
        -: 2984:
        -: 2985:#if JERRY_MEM_STATS
    #####: 2986:  jmem_stats_allocate_string_bytes (container_size - ECMA_ASCII_STRING_HEADER_SIZE);
        -: 2987:#endif /* JERRY_MEM_STATS */
        -: 2988:
    #####: 2989:  if (JERRY_LIKELY (string_size <= UINT16_MAX))
        -: 2990:  {
    #####: 2991:    ecma_short_string_t *short_string_p = (ecma_short_string_t *) header_p;
        -: 2992:
    #####: 2993:    short_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_HEAP_UTF8_STRING | ECMA_STRING_REF_ONE;
    #####: 2994:    short_string_p->header.u.hash = hash;
    #####: 2995:    short_string_p->size = (uint16_t) string_size;
    #####: 2996:    short_string_p->length = (uint16_t) length;
        -: 2997:
    #####: 2998:    return (ecma_string_t *) short_string_p;
        -: 2999:  }
        -: 3000:
    #####: 3001:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) header_p;
        -: 3002:
    #####: 3003:  long_string_p->header.refs_and_container = ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING | ECMA_STRING_REF_ONE;
    #####: 3004:  long_string_p->header.u.hash = hash;
    #####: 3005:  long_string_p->string_p = ECMA_LONG_STRING_BUFFER_START (long_string_p);
    #####: 3006:  long_string_p->size = string_size;
    #####: 3007:  long_string_p->length = length;
        -: 3008:
    #####: 3009:  return (ecma_string_t *) long_string_p;
        -: 3010:} /* ecma_stringbuilder_finalize */
        -: 3011:
        -: 3012:/**
        -: 3013: * Destroy a string builder that is no longer needed without creating a string from the contents.
        -: 3014: */
        -: 3015:void
    #####: 3016:ecma_stringbuilder_destroy (ecma_stringbuilder_t *builder_p) /**< string builder */
        -: 3017:{
    #####: 3018:  JERRY_ASSERT (builder_p->header_p != NULL);
    #####: 3019:  const lit_utf8_size_t size = builder_p->header_p->current_size;
    #####: 3020:  jmem_heap_free_block (builder_p->header_p, size);
        -: 3021:
        -: 3022:#ifndef JERRY_NDEBUG
    #####: 3023:  builder_p->header_p = NULL;
        -: 3024:#endif
        -: 3025:
        -: 3026:#if JERRY_MEM_STATS
    #####: 3027:  jmem_stats_free_string_bytes (size);
        -: 3028:#endif /* JERRY_MEM_STATS */
    #####: 3029:} /* ecma_stringbuilder_destroy */
        -: 3030:
        -: 3031:#if JERRY_ESNEXT
        -: 3032:/**
        -: 3033: * AdvanceStringIndex operation
        -: 3034: *
        -: 3035: * See also:
        -: 3036: *          ECMA-262 v6.0, 21.2.5.2.3
        -: 3037: *
        -: 3038: * @return uint32_t - the proper character index based on the operation
        -: 3039: */
        -: 3040:ecma_length_t
    #####: 3041:ecma_op_advance_string_index (ecma_string_t *str_p, /**< input string */
        -: 3042:                              ecma_length_t index, /**< given character index */
        -: 3043:                              bool is_unicode) /**< true - if regexp object's "unicode" flag is set
        -: 3044:                                                    false - otherwise */
        -: 3045:{
    #####: 3046:  JERRY_ASSERT ((ecma_number_t) index <= ECMA_NUMBER_MAX_SAFE_INTEGER);
    #####: 3047:  ecma_length_t next_index = index + 1;
        -: 3048:
    #####: 3049:  if (!is_unicode)
        -: 3050:  {
    #####: 3051:    return next_index;
        -: 3052:  }
        -: 3053:
    #####: 3054:  lit_utf8_size_t str_len = ecma_string_get_length (str_p);
        -: 3055:
    #####: 3056:  if (next_index >= str_len)
        -: 3057:  {
    #####: 3058:    return next_index;
        -: 3059:  }
        -: 3060:
    #####: 3061:  JERRY_ASSERT (index < UINT32_MAX);
    #####: 3062:  ecma_char_t first = ecma_string_get_char_at_pos (str_p, (lit_utf8_size_t) index);
        -: 3063:
    #####: 3064:  if (!lit_is_code_point_utf16_high_surrogate (first))
        -: 3065:  {
    #####: 3066:    return next_index;
        -: 3067:  }
        -: 3068:
    #####: 3069:  ecma_char_t second = ecma_string_get_char_at_pos (str_p, (lit_utf8_size_t) next_index);
        -: 3070:
    #####: 3071:  if (!lit_is_code_point_utf16_low_surrogate (second))
        -: 3072:  {
    #####: 3073:    return next_index;
        -: 3074:  }
        -: 3075:
    #####: 3076:  return next_index + 1;
        -: 3077:} /* ecma_op_advance_string_index */
        -: 3078:#endif /* JERRY_ESNEXT */
        -: 3079:
        -: 3080:/**
        -: 3081: * @}
        -: 3082: * @}
        -: 3083: */
