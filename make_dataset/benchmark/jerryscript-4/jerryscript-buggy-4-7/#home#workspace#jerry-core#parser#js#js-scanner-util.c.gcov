        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner-util.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-helpers.h"
        -:   17:#include "ecma-lex-env.h"
        -:   18:#include "jcontext.h"
        -:   19:#include "js-parser-internal.h"
        -:   20:#include "js-scanner-internal.h"
        -:   21:#include "lit-char-helpers.h"
        -:   22:
        -:   23:#if JERRY_PARSER
        -:   24:
        -:   25:/** \addtogroup parser Parser
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser JavaScript
        -:   29: * @{
        -:   30: *
        -:   31: * \addtogroup jsparser_scanner Scanner
        -:   32: * @{
        -:   33: */
        -:   34:
        -:   35:JERRY_STATIC_ASSERT (PARSER_MAXIMUM_NUMBER_OF_LITERALS + PARSER_MAXIMUM_NUMBER_OF_REGISTERS < PARSER_REGISTER_START,
        -:   36:                     maximum_number_of_literals_plus_registers_must_be_less_than_register_start);
        -:   37:
        -:   38:#if JERRY_ESNEXT
        -:   39:
        -:   40:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG & SCANNER_LITERAL_IS_LOCAL) == 0,
        -:   41:                     is_arrow_arg_binding_flag_must_not_use_local_flags);
        -:   42:
        -:   43:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_LET & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   44:                     is_let_flag_must_use_local_flags);
        -:   45:
        -:   46:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_CONST & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   47:                     is_const_flag_must_use_local_flags);
        -:   48:
        -:   49:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_FUNC_DECLARATION & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   50:                     is_func_declaration_flag_must_use_local_flags);
        -:   51:
        -:   52:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_DESTRUCTURED_ARG & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   53:                     is_arg_binding_flag_must_use_local_flags);
        -:   54:
        -:   55:JERRY_STATIC_ASSERT (SCANNER_LITERAL_IS_FUNC_DECLARATION != SCANNER_LITERAL_IS_DESTRUCTURED_ARG,
        -:   56:                     is_func_declaration_must_be_different_from_is_arg_binding);
        -:   57:
        -:   58:JERRY_STATIC_ASSERT (PARSER_SCOPE_STACK_IS_CONST_REG == PARSER_SCOPE_STACK_IS_LOCAL_CREATED,
        -:   59:                     scope_stack_is_const_reg_and_scope_stack_is_local_created_must_be_the_same);
        -:   60:
        -:   61:#endif /* JERRY_ESNEXT */
        -:   62:
        -:   63:/**
        -:   64: * Raise a scanner error.
        -:   65: */
        -:   66:void
    #####:   67:scanner_raise_error (parser_context_t *context_p) /**< context */
        -:   68:{
    #####:   69:  PARSER_THROW (context_p->try_buffer);
        -:   70:  /* Should never been reached. */
        -:   71:  JERRY_ASSERT (0);
        -:   72:} /* scanner_raise_error */
        -:   73:
        -:   74:#if JERRY_ESNEXT
        -:   75:
        -:   76:/**
        -:   77: * Raise a variable redeclaration error.
        -:   78: */
        -:   79:void
    #####:   80:scanner_raise_redeclaration_error (parser_context_t *context_p) /**< context */
        -:   81:{
    #####:   82:  scanner_info_t *info_p = scanner_insert_info (context_p, context_p->source_p, sizeof (scanner_info_t));
    #####:   83:  info_p->type = SCANNER_TYPE_ERR_REDECLARED;
        -:   84:
    #####:   85:  scanner_raise_error (context_p);
    #####:   86:} /* scanner_raise_redeclaration_error */
        -:   87:
        -:   88:#endif /* JERRY_ESNEXT */
        -:   89:
        -:   90:/**
        -:   91: * Allocate memory for scanner.
        -:   92: *
        -:   93: * @return allocated memory
        -:   94: */
        -:   95:void *
        5:   96:scanner_malloc (parser_context_t *context_p, /**< context */
        -:   97:                size_t size) /**< size of the memory block */
        -:   98:{
        -:   99:  void *result;
        -:  100:
        5:  101:  JERRY_ASSERT (size > 0);
        5:  102:  result = jmem_heap_alloc_block_null_on_error (size);
        -:  103:
        5:  104:  if (result == NULL)
        -:  105:  {
    #####:  106:    scanner_cleanup (context_p);
        -:  107:
        -:  108:    /* This is the only error which specify its reason. */
    #####:  109:    context_p->error = PARSER_ERR_OUT_OF_MEMORY;
    #####:  110:    PARSER_THROW (context_p->try_buffer);
        -:  111:  }
        5:  112:  return result;
        -:  113:} /* scanner_malloc */
        -:  114:
        -:  115:/**
        -:  116: * Free memory allocated by scanner_malloc.
        -:  117: */
        -:  118:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  119:scanner_free (void *ptr, /**< pointer to free */
        -:  120:              size_t size) /**< size of the memory block */
        -:  121:{
        2:  122:  jmem_heap_free_block (ptr, size);
    #####:  123:} /* scanner_free */
        -:  124:
        -:  125:/**
        -:  126: * Count the size of a stream after an info block.
        -:  127: *
        -:  128: * @return the size in bytes
        -:  129: */
        -:  130:size_t
    #####:  131:scanner_get_stream_size (scanner_info_t *info_p, /**< scanner info block */
        -:  132:                         size_t size) /**< size excluding the stream */
        -:  133:{
    #####:  134:  const uint8_t *data_p = ((const uint8_t *) info_p) + size;
    #####:  135:  const uint8_t *data_p_start = data_p;
        -:  136:
    #####:  137:  while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -:  138:  {
    #####:  139:    switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)
        -:  140:    {
    #####:  141:      case SCANNER_STREAM_TYPE_VAR:
        -:  142:#if JERRY_ESNEXT
        -:  143:      case SCANNER_STREAM_TYPE_LET:
        -:  144:      case SCANNER_STREAM_TYPE_CONST:
        -:  145:      case SCANNER_STREAM_TYPE_LOCAL:
        -:  146:#endif /* JERRY_ESNEXT */
        -:  147:#if JERRY_MODULE_SYSTEM
        -:  148:      case SCANNER_STREAM_TYPE_IMPORT:
        -:  149:#endif /* JERRY_MODULE_SYSTEM */
        -:  150:      case SCANNER_STREAM_TYPE_ARG:
        -:  151:#if JERRY_ESNEXT
        -:  152:      case SCANNER_STREAM_TYPE_ARG_VAR:
        -:  153:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -:  154:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -:  155:#endif /* JERRY_MODULE_SYSTEM */
        -:  156:      case SCANNER_STREAM_TYPE_ARG_FUNC:
        -:  157:#if JERRY_ESNEXT
        -:  158:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -:  159:#endif /* JERRY_ESNEXT */
        -:  160:      case SCANNER_STREAM_TYPE_FUNC:
        -:  161:      {
    #####:  162:        break;
        -:  163:      }
    #####:  164:      default:
        -:  165:      {
    #####:  166:        JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE
        -:  167:                      || SCANNER_STREAM_TYPE_IS_ARGUMENTS (data_p[0] & SCANNER_STREAM_TYPE_MASK));
    #####:  168:        data_p++;
    #####:  169:        continue;
        -:  170:      }
        -:  171:    }
        -:  172:
    #####:  173:    data_p += 3;
        -:  174:
    #####:  175:    if (data_p[-3] & SCANNER_STREAM_UINT16_DIFF)
        -:  176:    {
    #####:  177:      data_p++;
        -:  178:    }
    #####:  179:    else if (data_p[-1] == 0)
        -:  180:    {
    #####:  181:      data_p += sizeof (const uint8_t *);
        -:  182:    }
        -:  183:  }
        -:  184:
    #####:  185:  return size + 1 + (size_t) (data_p - data_p_start);
        -:  186:} /* scanner_get_stream_size */
        -:  187:
        -:  188:/**
        -:  189: * Insert a scanner info block into the scanner info chain.
        -:  190: *
        -:  191: * @return newly allocated scanner info
        -:  192: */
        -:  193:scanner_info_t *
        3:  194:scanner_insert_info (parser_context_t *context_p, /**< context */
        -:  195:                     const uint8_t *source_p, /**< triggering position */
        -:  196:                     size_t size) /**< size of the memory block */
        -:  197:{
        3:  198:  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);
        3:  199:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        3:  200:  scanner_info_t *prev_scanner_info_p = NULL;
        -:  201:
        3:  202:  JERRY_ASSERT (scanner_info_p != NULL);
        3:  203:  JERRY_ASSERT (source_p != NULL);
        -:  204:
        3:  205:  new_scanner_info_p->source_p = source_p;
        -:  206:
        8:  207:  while (source_p < scanner_info_p->source_p)
        -:  208:  {
        2:  209:    prev_scanner_info_p = scanner_info_p;
        2:  210:    scanner_info_p = scanner_info_p->next_p;
        -:  211:
        2:  212:    JERRY_ASSERT (scanner_info_p != NULL);
        -:  213:  }
        -:  214:
        -:  215:  /* Multiple scanner info blocks cannot be assigned to the same position. */
        3:  216:  JERRY_ASSERT (source_p != scanner_info_p->source_p);
        -:  217:
        3:  218:  new_scanner_info_p->next_p = scanner_info_p;
        -:  219:
        3:  220:  if (JERRY_LIKELY (prev_scanner_info_p == NULL))
        -:  221:  {
        2:  222:    context_p->next_scanner_info_p = new_scanner_info_p;
        -:  223:  }
        -:  224:  else
        -:  225:  {
        1:  226:    prev_scanner_info_p->next_p = new_scanner_info_p;
        -:  227:  }
        -:  228:
        3:  229:  return new_scanner_info_p;
        -:  230:} /* scanner_insert_info */
        -:  231:
        -:  232:/**
        -:  233: * Insert a scanner info block into the scanner info chain before a given info block.
        -:  234: *
        -:  235: * @return newly allocated scanner info
        -:  236: */
        -:  237:scanner_info_t *
    #####:  238:scanner_insert_info_before (parser_context_t *context_p, /**< context */
        -:  239:                            const uint8_t *source_p, /**< triggering position */
        -:  240:                            scanner_info_t *start_info_p, /**< first info position */
        -:  241:                            size_t size) /**< size of the memory block */
        -:  242:{
    #####:  243:  JERRY_ASSERT (start_info_p != NULL);
        -:  244:
    #####:  245:  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);
    #####:  246:  scanner_info_t *scanner_info_p = start_info_p->next_p;
    #####:  247:  scanner_info_t *prev_scanner_info_p = start_info_p;
        -:  248:
    #####:  249:  new_scanner_info_p->source_p = source_p;
        -:  250:
    #####:  251:  while (source_p < scanner_info_p->source_p)
        -:  252:  {
    #####:  253:    prev_scanner_info_p = scanner_info_p;
    #####:  254:    scanner_info_p = scanner_info_p->next_p;
        -:  255:
    #####:  256:    JERRY_ASSERT (scanner_info_p != NULL);
        -:  257:  }
        -:  258:
        -:  259:  /* Multiple scanner info blocks cannot be assigned to the same position. */
    #####:  260:  JERRY_ASSERT (source_p != scanner_info_p->source_p);
        -:  261:
    #####:  262:  new_scanner_info_p->next_p = scanner_info_p;
        -:  263:
    #####:  264:  prev_scanner_info_p->next_p = new_scanner_info_p;
    #####:  265:  return new_scanner_info_p;
        -:  266:} /* scanner_insert_info_before */
        -:  267:
        -:  268:/**
        -:  269: * Release the next scanner info.
        -:  270: */
        -:  271:extern inline void JERRY_ATTR_ALWAYS_INLINE
        1:  272:scanner_release_next (parser_context_t *context_p, /**< context */
        -:  273:                      size_t size) /**< size of the memory block */
        -:  274:{
        3:  275:  scanner_info_t *next_p = context_p->next_scanner_info_p->next_p;
        -:  276:
        3:  277:  jmem_heap_free_block (context_p->next_scanner_info_p, size);
        3:  278:  context_p->next_scanner_info_p = next_p;
        1:  279:} /* scanner_release_next */
        -:  280:
        -:  281:/**
        -:  282: * Set the active scanner info to the next scanner info.
        -:  283: */
        -:  284:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  285:scanner_set_active (parser_context_t *context_p) /**< context */
        -:  286:{
    #####:  287:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -:  288:
    #####:  289:  context_p->next_scanner_info_p = scanner_info_p->next_p;
    #####:  290:  scanner_info_p->next_p = context_p->active_scanner_info_p;
    #####:  291:  context_p->active_scanner_info_p = scanner_info_p;
    #####:  292:} /* scanner_set_active */
        -:  293:
        -:  294:/**
        -:  295: * Set the next scanner info to the active scanner info.
        -:  296: */
        -:  297:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  298:scanner_revert_active (parser_context_t *context_p) /**< context */
        -:  299:{
    #####:  300:  scanner_info_t *scanner_info_p = context_p->active_scanner_info_p;
        -:  301:
    #####:  302:  context_p->active_scanner_info_p = scanner_info_p->next_p;
    #####:  303:  scanner_info_p->next_p = context_p->next_scanner_info_p;
    #####:  304:  context_p->next_scanner_info_p = scanner_info_p;
    #####:  305:} /* scanner_revert_active */
        -:  306:
        -:  307:/**
        -:  308: * Release the active scanner info.
        -:  309: */
        -:  310:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  311:scanner_release_active (parser_context_t *context_p, /**< context */
        -:  312:                        size_t size) /**< size of the memory block */
        -:  313:{
    #####:  314:  scanner_info_t *next_p = context_p->active_scanner_info_p->next_p;
        -:  315:
    #####:  316:  jmem_heap_free_block (context_p->active_scanner_info_p, size);
    #####:  317:  context_p->active_scanner_info_p = next_p;
    #####:  318:} /* scanner_release_active */
        -:  319:
        -:  320:/**
        -:  321: * Release switch cases.
        -:  322: */
        -:  323:void
    #####:  324:scanner_release_switch_cases (scanner_case_info_t *case_p) /**< case list */
        -:  325:{
    #####:  326:  while (case_p != NULL)
        -:  327:  {
    #####:  328:    scanner_case_info_t *next_p = case_p->next_p;
        -:  329:
    #####:  330:    jmem_heap_free_block (case_p, sizeof (scanner_case_info_t));
    #####:  331:    case_p = next_p;
        -:  332:  }
    #####:  333:} /* scanner_release_switch_cases */
        -:  334:
        -:  335:/**
        -:  336: * Seek to correct position in the scanner info list.
        -:  337: */
        -:  338:void
        3:  339:scanner_seek (parser_context_t *context_p) /**< context */
        -:  340:{
        3:  341:  const uint8_t *source_p = context_p->source_p;
        -:  342:  scanner_info_t *prev_p;
        -:  343:
        3:  344:  if (context_p->skipped_scanner_info_p != NULL)
        -:  345:  {
    #####:  346:    JERRY_ASSERT (context_p->skipped_scanner_info_p->source_p != NULL);
        -:  347:
    #####:  348:    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;
        -:  349:
    #####:  350:    if (context_p->skipped_scanner_info_end_p->source_p <= source_p)
        -:  351:    {
    #####:  352:      prev_p = context_p->skipped_scanner_info_end_p;
        -:  353:    }
        -:  354:    else
        -:  355:    {
    #####:  356:      prev_p = context_p->skipped_scanner_info_p;
        -:  357:
    #####:  358:      if (prev_p->source_p > source_p)
        -:  359:      {
    #####:  360:        context_p->next_scanner_info_p = prev_p;
    #####:  361:        context_p->skipped_scanner_info_p = NULL;
    #####:  362:        return;
        -:  363:      }
        -:  364:
    #####:  365:      context_p->skipped_scanner_info_p = prev_p;
        -:  366:    }
        -:  367:  }
        -:  368:  else
        -:  369:  {
        3:  370:    prev_p = context_p->next_scanner_info_p;
        -:  371:
        3:  372:    if (prev_p->source_p == NULL || prev_p->source_p > source_p)
        -:  373:    {
        3:  374:      return;
        -:  375:    }
        -:  376:
    #####:  377:    context_p->skipped_scanner_info_p = prev_p;
        -:  378:  }
        -:  379:
    #####:  380:  while (prev_p->next_p->source_p != NULL && prev_p->next_p->source_p <= source_p)
        -:  381:  {
    #####:  382:    prev_p = prev_p->next_p;
        -:  383:  }
        -:  384:
    #####:  385:  context_p->skipped_scanner_info_end_p = prev_p;
    #####:  386:  context_p->next_scanner_info_p = prev_p->next_p;
        -:  387:} /* scanner_seek */
        -:  388:
        -:  389:#if JERRY_ESNEXT
        -:  390:
        -:  391:/**
        -:  392: * Find any let/const declaration of a given literal.
        -:  393: *
        -:  394: * @return true - if the literal is found, false - otherwise
        -:  395: */
        -:  396:static bool
        3:  397:scanner_scope_find_lexical_declaration (parser_context_t *context_p, /**< context */
        -:  398:                                        lexer_lit_location_t *literal_p) /**< literal */
        -:  399:{
        -:  400:  ecma_string_t *name_p;
        3:  401:  uint32_t flags = context_p->global_status_flags;
        -:  402:
        3:  403:  if (!(flags & ECMA_PARSE_EVAL)
    #####:  404:      || (!(flags & ECMA_PARSE_DIRECT_EVAL) && (context_p->status_flags & PARSER_IS_STRICT)))
        -:  405:  {
        3:  406:    return false;
        -:  407:  }
        -:  408:
    #####:  409:  if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -:  410:  {
    #####:  411:    name_p = parser_new_ecma_string_from_literal ((lexer_literal_t *) literal_p);
        -:  412:  }
        -:  413:  else
        -:  414:  {
    #####:  415:    uint8_t *destination_p = (uint8_t *) scanner_malloc (context_p, literal_p->length);
        -:  416:
    #####:  417:    lexer_convert_ident_to_cesu8 (destination_p, literal_p->char_p, literal_p->length);
        -:  418:
    #####:  419:    name_p = parser_new_ecma_string_from_literal ((lexer_literal_t *) literal_p);
        -:  420:
    #####:  421:    scanner_free (destination_p, literal_p->length);
        -:  422:  }
        -:  423:
        -:  424:  ecma_object_t *lex_env_p;
        -:  425:
    #####:  426:  if (flags & ECMA_PARSE_DIRECT_EVAL)
        -:  427:  {
    #####:  428:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  429:
    #####:  430:    while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -:  431:    {
    #####:  432:      if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  433:      {
    #####:  434:        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  435:
    #####:  436:        if (property_p != NULL && ecma_is_property_enumerable (*property_p))
        -:  437:        {
    #####:  438:          ecma_deref_ecma_string (name_p);
    #####:  439:          return true;
        -:  440:        }
        -:  441:      }
        -:  442:
    #####:  443:      JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####:  444:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  445:    }
        -:  446:  }
        -:  447:  else
        -:  448:  {
    #####:  449:    lex_env_p = ecma_get_global_scope (ecma_builtin_get_global ());
        -:  450:  }
        -:  451:
    #####:  452:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  453:  {
    #####:  454:    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  455:
    #####:  456:    if (property_p != NULL && ecma_is_property_enumerable (*property_p))
        -:  457:    {
    #####:  458:      ecma_deref_ecma_string (name_p);
    #####:  459:      return true;
        -:  460:    }
        -:  461:  }
        -:  462:
    #####:  463:  ecma_deref_ecma_string (name_p);
    #####:  464:  return false;
        -:  465:} /* scanner_scope_find_lexical_declaration */
        -:  466:
        -:  467:#endif /* JERRY_ESNEXT */
        -:  468:
        -:  469:/**
        -:  470: * Push a new literal pool.
        -:  471: *
        -:  472: * @return the newly created literal pool
        -:  473: */
        -:  474:scanner_literal_pool_t *
        2:  475:scanner_push_literal_pool (parser_context_t *context_p, /**< context */
        -:  476:                           scanner_context_t *scanner_context_p, /**< scanner context */
        -:  477:                           uint16_t status_flags) /**< combination of scanner_literal_pool_flags_t flags */
        -:  478:{
        2:  479:  scanner_literal_pool_t *prev_literal_pool_p = scanner_context_p->active_literal_pool_p;
        -:  480:  scanner_literal_pool_t *literal_pool_p;
        -:  481:
        2:  482:  literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
        -:  483:
        2:  484:  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION))
        -:  485:  {
    #####:  486:    JERRY_ASSERT (prev_literal_pool_p != NULL);
    #####:  487:    status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  488:
        -:  489:#if JERRY_ESNEXT
    #####:  490:    const uint16_t copied_flags = (SCANNER_LITERAL_POOL_IN_WITH
        -:  491:                                   | SCANNER_LITERAL_POOL_GENERATOR
        -:  492:                                   | SCANNER_LITERAL_POOL_ASYNC);
        -:  493:#else /* !JERRY_ESNEXT */
    #####:  494:    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IN_WITH;
        -:  495:#endif /* JERRY_ESNEXT */
        -:  496:
    #####:  497:    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);
        -:  498:  }
        -:  499:#if JERRY_ESNEXT
        -:  500:  else
        -:  501:  {
        2:  502:    context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  503:
        2:  504:    if (status_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -:  505:    {
    #####:  506:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -:  507:    }
        -:  508:
        2:  509:    if (status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -:  510:    {
    #####:  511:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  512:    }
        -:  513:  }
        -:  514:#endif /* JERRY_ESNEXT */
        -:  515:
        2:  516:  if (prev_literal_pool_p != NULL)
        -:  517:  {
        1:  518:    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IS_STRICT;
        1:  519:    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);
        -:  520:
        -:  521:    /* The logical value of these flags must be the same. */
        1:  522:    JERRY_ASSERT (!(status_flags & SCANNER_LITERAL_POOL_IS_STRICT) == !(context_p->status_flags & PARSER_IS_STRICT));
        -:  523:  }
        -:  524:
        2:  525:  parser_list_init (&literal_pool_p->literal_pool,
        -:  526:                    sizeof (lexer_lit_location_t),
        -:  527:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
        2:  528:  literal_pool_p->source_p = NULL;
        2:  529:  literal_pool_p->status_flags = status_flags;
        2:  530:  literal_pool_p->no_declarations = 0;
        -:  531:
        2:  532:  literal_pool_p->prev_p = prev_literal_pool_p;
        2:  533:  scanner_context_p->active_literal_pool_p = literal_pool_p;
        -:  534:
        2:  535:  return literal_pool_p;
        -:  536:} /* scanner_push_literal_pool */
        -:  537:
        -:  538:JERRY_STATIC_ASSERT (PARSER_MAXIMUM_IDENT_LENGTH <= UINT8_MAX,
        -:  539:                     maximum_ident_length_must_fit_in_a_byte);
        -:  540:
        -:  541:/**
        -:  542: * Checks whether a literal is equal to "arguments".
        -:  543: */
        -:  544:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  545:scanner_literal_is_arguments (lexer_lit_location_t *literal_p) /**< literal */
        -:  546:{
        1:  547:  return lexer_compare_identifier_to_string (literal_p, (const uint8_t *) "arguments", 9);
        -:  548:} /* scanner_literal_is_arguments */
        -:  549:
        -:  550:/**
        -:  551: * Current status of arguments.
        -:  552: */
        -:  553:typedef enum
        -:  554:{
        -:  555:  SCANNER_ARGUMENTS_NOT_PRESENT, /**< arguments object must not be created */
        -:  556:  SCANNER_ARGUMENTS_MAY_PRESENT, /**< arguments object can be created */
        -:  557:  SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL, /**< arguments object must be present unless otherwise declared */
        -:  558:  SCANNER_ARGUMENTS_PRESENT, /**< arguments object must be created */
        -:  559:  SCANNER_ARGUMENTS_PRESENT_NO_REG, /**< arguments object must be created and cannot be stored in registers */
        -:  560:} scanner_arguments_type_t;
        -:  561:
        -:  562:/**
        -:  563: * Pop the last literal pool from the end.
        -:  564: */
        -:  565:void
        2:  566:scanner_pop_literal_pool (parser_context_t *context_p, /**< context */
        -:  567:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:  568:{
        2:  569:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        2:  570:  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
        -:  571:
        -:  572:#if JERRY_ESNEXT
        2:  573:  const uint32_t arrow_super_flags = (SCANNER_LITERAL_POOL_ARROW | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);
        2:  574:  if ((literal_pool_p->status_flags & arrow_super_flags) == arrow_super_flags)
        -:  575:  {
    #####:  576:    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE;
        -:  577:  }
        -:  578:#endif /* JERRY_ESNEXT */
        -:  579:
        2:  580:  if (JERRY_UNLIKELY (literal_pool_p->source_p == NULL))
        -:  581:  {
    #####:  582:    JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION);
    #####:  583:    JERRY_ASSERT (literal_pool_p->literal_pool.data.first_p == NULL
        -:  584:                  && literal_pool_p->literal_pool.data.last_p == NULL);
        -:  585:
    #####:  586:    scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;
    #####:  587:    scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
    #####:  588:    return;
        -:  589:  }
        -:  590:
        2:  591:  uint16_t status_flags = literal_pool_p->status_flags;
        2:  592:  scanner_arguments_type_t arguments_type = SCANNER_ARGUMENTS_MAY_PRESENT;
        -:  593:
        2:  594:  if (status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS)
        -:  595:  {
        1:  596:    arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  597:  }
        1:  598:  else if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)
        -:  599:  {
    #####:  600:    arguments_type = SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL;
        -:  601:  }
        -:  602:
        -:  603:#if JERRY_ESNEXT
        2:  604:  if (status_flags & SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS)
        -:  605:  {
    #####:  606:    arguments_type = SCANNER_ARGUMENTS_PRESENT;
        -:  607:
    #####:  608:    if (status_flags & (SCANNER_LITERAL_POOL_NO_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL))
        -:  609:    {
    #####:  610:      arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
    #####:  611:      status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  612:    }
        -:  613:  }
        -:  614:#endif /* JERRY_ESNEXT */
        -:  615:
        2:  616:  uint8_t can_eval_types = 0;
        -:  617:#if JERRY_ESNEXT
        2:  618:  if (prev_literal_pool_p == NULL && !(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
        -:  619:  {
        1:  620:    can_eval_types |= SCANNER_LITERAL_IS_FUNC;
        -:  621:  }
        -:  622:#endif /* JERRY_ESNEXT */
        -:  623:
        2:  624:  if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && prev_literal_pool_p != NULL)
        -:  625:  {
    #####:  626:    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  627:  }
        -:  628:
        -:  629:#if JERRY_DEBUGGER
        -:  630:  if (scanner_context_p->status_flags & SCANNER_CONTEXT_DEBUGGER_ENABLED)
        -:  631:  {
        -:  632:    /* When debugger is enabled, identifiers are not stored in registers. However,
        -:  633:     * this does not affect 'eval' detection, so 'arguments' object is not created. */
        -:  634:    status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  635:  }
        -:  636:#endif /* JERRY_DEBUGGER */
        -:  637:
        2:  638:  parser_list_iterator_t literal_iterator;
        -:  639:  lexer_lit_location_t *literal_p;
        2:  640:  int32_t no_declarations = literal_pool_p->no_declarations;
        -:  641:
        2:  642:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -:  643:
        2:  644:  uint8_t arguments_stream_type = SCANNER_STREAM_TYPE_ARGUMENTS;
        2:  645:  const uint8_t *prev_source_p = literal_pool_p->source_p - 1;
        2:  646:  lexer_lit_location_t *last_argument_p = NULL;
        2:  647:  size_t compressed_size = 1;
        -:  648:
        8:  649:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -:  650:  {
        4:  651:    uint8_t type = literal_p->type;
        -:  652:
        4:  653:    if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK))
        -:  654:    {
    #####:  655:      continue;
        -:  656:    }
        -:  657:
        5:  658:    if (!(status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) && scanner_literal_is_arguments (literal_p))
        -:  659:    {
        -:  660:#if JERRY_ESNEXT
    #####:  661:      JERRY_ASSERT (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT);
        -:  662:#else /* !JERRY_ESNEXT */
        -:  663:      JERRY_ASSERT (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT
        -:  664:                    || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL);
        -:  665:#endif /* JERRY_ESNEXT */
        -:  666:
    #####:  667:      status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  668:
    #####:  669:      if (type & SCANNER_LITERAL_IS_ARG)
        -:  670:      {
    #####:  671:        JERRY_ASSERT (arguments_type != SCANNER_ARGUMENTS_PRESENT
        -:  672:                      && arguments_type != SCANNER_ARGUMENTS_PRESENT_NO_REG);
    #####:  673:        arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
    #####:  674:        last_argument_p = literal_p;
        -:  675:      }
        -:  676:#if JERRY_ESNEXT
    #####:  677:      else if (type & SCANNER_LITERAL_IS_LOCAL)
        -:  678:      {
    #####:  679:        if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -:  680:        {
    #####:  681:          arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  682:        }
        -:  683:        else
        -:  684:        {
    #####:  685:          if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -:  686:          {
    #####:  687:            type |= SCANNER_LITERAL_NO_REG;
        -:  688:          }
    #####:  689:          else if (type & (SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE))
        -:  690:          {
    #####:  691:            arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  692:          }
        -:  693:
    #####:  694:          if ((type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_LOCAL_FUNC)
        -:  695:          {
    #####:  696:            type |= SCANNER_LITERAL_IS_ARG;
    #####:  697:            literal_p->type = type;
    #####:  698:            no_declarations--;
    #####:  699:            arguments_stream_type = SCANNER_STREAM_TYPE_ARGUMENTS_FUNC;
        -:  700:          }
        -:  701:          else
        -:  702:          {
    #####:  703:            arguments_stream_type |= SCANNER_STREAM_LOCAL_ARGUMENTS;
        -:  704:          }
        -:  705:        }
        -:  706:      }
        -:  707:#else /* !JERRY_ESNEXT */
    #####:  708:      else if (type & SCANNER_LITERAL_IS_FUNC)
        -:  709:      {
        -:  710:        arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  711:      }
        -:  712:#endif /* JERRY_ESNEXT */
        -:  713:      else
        -:  714:      {
        -:  715:#if JERRY_ESNEXT
    #####:  716:        if ((type & SCANNER_LITERAL_IS_VAR)
    #####:  717:            && (arguments_type == SCANNER_ARGUMENTS_PRESENT || arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG))
        -:  718:        {
    #####:  719:          if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -:  720:          {
    #####:  721:            type |= SCANNER_LITERAL_NO_REG;
        -:  722:          }
    #####:  723:          else if (type & (SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE))
        -:  724:          {
    #####:  725:            arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  726:          }
        -:  727:
    #####:  728:          type |= SCANNER_LITERAL_IS_ARG;
    #####:  729:          literal_p->type = type;
    #####:  730:          no_declarations--;
        -:  731:        }
        -:  732:#endif /* JERRY_ESNEXT */
        -:  733:
    #####:  734:        if ((type & SCANNER_LITERAL_NO_REG) || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -:  735:        {
    #####:  736:          arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  737:        }
    #####:  738:        else if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT)
        -:  739:        {
    #####:  740:          arguments_type = SCANNER_ARGUMENTS_PRESENT;
        -:  741:        }
        -:  742:
        -:  743:#if JERRY_ESNEXT
        -:  744:        /* The SCANNER_LITERAL_IS_ARG may be set above. */
    #####:  745:        if (!(type & SCANNER_LITERAL_IS_ARG))
        -:  746:        {
    #####:  747:          literal_p->type = 0;
    #####:  748:          continue;
        -:  749:        }
        -:  750:#else /* !JERRY_ESNEXT */
    #####:  751:        literal_p->type = 0;
    #####:  752:        continue;
        -:  753:#endif /* JERRY_ESNEXT */
        -:  754:      }
        -:  755:    }
        4:  756:    else if (type & SCANNER_LITERAL_IS_ARG)
        -:  757:    {
    #####:  758:      last_argument_p = literal_p;
        -:  759:    }
        -:  760:
        -:  761:#if JERRY_ESNEXT
        4:  762:    if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        4:  763:        && (type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_FUNC)
        -:  764:    {
    #####:  765:      if (prev_literal_pool_p == NULL && scanner_scope_find_lexical_declaration (context_p, literal_p))
        -:  766:      {
    #####:  767:        literal_p->type = 0;
    #####:  768:        continue;
        -:  769:      }
        -:  770:
    #####:  771:      if (!(type & SCANNER_LITERAL_IS_ARG))
        -:  772:      {
    #####:  773:        type |= SCANNER_LITERAL_IS_VAR;
        -:  774:      }
        -:  775:
    #####:  776:      type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
    #####:  777:      literal_p->type = type;
        -:  778:    }
        -:  779:#endif /* JERRY_ESNEXT */
        -:  780:
        4:  781:    if ((type & SCANNER_LITERAL_IS_LOCAL)
        4:  782:        || ((type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))
        3:  783:            && (status_flags & SCANNER_LITERAL_POOL_FUNCTION)))
        -:  784:    {
        3:  785:      JERRY_ASSERT ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  786:                    || !(literal_p->type & SCANNER_LITERAL_IS_ARG));
        -:  787:
        3:  788:      if (literal_p->length == 0)
        -:  789:      {
    #####:  790:        compressed_size += 1;
    #####:  791:        continue;
        -:  792:      }
        -:  793:
        3:  794:      no_declarations++;
        -:  795:
        3:  796:      if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) || (type & can_eval_types))
        -:  797:      {
        3:  798:        type |= SCANNER_LITERAL_NO_REG;
        3:  799:        literal_p->type = type;
        -:  800:      }
        -:  801:
        3:  802:      if (type & SCANNER_LITERAL_IS_FUNC)
        -:  803:      {
    #####:  804:        no_declarations++;
        -:  805:
        -:  806:#if JERRY_ESNEXT
    #####:  807:        if ((type & (SCANNER_LITERAL_IS_CONST | SCANNER_LITERAL_IS_ARG)) == SCANNER_LITERAL_IS_CONST)
        -:  808:        {
    #####:  809:          JERRY_ASSERT (type & SCANNER_LITERAL_IS_LET);
        -:  810:
        -:  811:          /* Catch parameters cannot be functions. */
    #####:  812:          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);
    #####:  813:          no_declarations--;
        -:  814:        }
        -:  815:#else /* !JERRY_ESNEXT */
    #####:  816:        if (type & SCANNER_LITERAL_IS_LOCAL)
        -:  817:        {
        -:  818:          /* Catch parameters cannot be functions. */
    #####:  819:          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);
    #####:  820:          no_declarations--;
        -:  821:        }
        -:  822:#endif /* JERRY_ESNEXT */
        -:  823:      }
        -:  824:
        3:  825:      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);
        -:  826:
        3:  827:      if (diff >= 1 && diff <= (intptr_t) UINT8_MAX)
        -:  828:      {
        3:  829:        compressed_size += 2 + 1;
        -:  830:      }
    #####:  831:      else if (diff >= -(intptr_t) UINT8_MAX && diff <= (intptr_t) UINT16_MAX)
        -:  832:      {
    #####:  833:        compressed_size += 2 + 2;
        -:  834:      }
        -:  835:      else
        -:  836:      {
    #####:  837:        compressed_size += 2 + 1 + sizeof (const uint8_t *);
        -:  838:      }
        -:  839:
        3:  840:      prev_source_p = literal_p->char_p + literal_p->length;
        -:  841:
        3:  842:      if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  843:#if JERRY_ESNEXT
    #####:  844:          || ((type & SCANNER_LITERAL_IS_FUNC) && (status_flags & SCANNER_LITERAL_POOL_IS_STRICT))
        -:  845:#endif /* JERRY_ESNEXT */
    #####:  846:          || !(type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC)))
        -:  847:      {
        3:  848:        continue;
        -:  849:      }
        -:  850:    }
        -:  851:
        1:  852:    if (prev_literal_pool_p != NULL && literal_p->length > 0)
        -:  853:    {
        -:  854:      /* Propagate literal to upper level. */
        1:  855:      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p,
        -:  856:                                                                             prev_literal_pool_p,
        -:  857:                                                                             literal_p);
        1:  858:      uint8_t extended_type = literal_location_p->type;
        -:  859:
        -:  860:#if JERRY_ESNEXT
        1:  861:      const uint16_t no_reg_flags = (SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_CLASS_FIELD);
        -:  862:#else /* !JERRY_ESNEXT */
    #####:  863:      const uint16_t no_reg_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -:  864:#endif /* JERRY_ESNEXT */
        -:  865:
        1:  866:      if ((status_flags & no_reg_flags) || (type & SCANNER_LITERAL_NO_REG))
        -:  867:      {
        1:  868:        extended_type |= SCANNER_LITERAL_NO_REG;
        -:  869:      }
        -:  870:
        -:  871:#if JERRY_ESNEXT
        1:  872:      extended_type |= SCANNER_LITERAL_IS_USED;
        -:  873:
        1:  874:      if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)
        -:  875:      {
    #####:  876:        extended_type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  877:      }
        -:  878:
        1:  879:      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_LOCAL);
        -:  880:
        1:  881:      if ((type & SCANNER_LITERAL_IS_ARG)
        1:  882:          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_LET
        1:  883:          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_CONST)
        -:  884:      {
        -:  885:        /* Clears the SCANNER_LITERAL_IS_VAR and SCANNER_LITERAL_IS_FUNC flags
        -:  886:         * for speculative arrow parameters and local (non-var) functions. */
    #####:  887:        type = 0;
        -:  888:      }
        -:  889:#endif /* JERRY_ESNEXT */
        -:  890:
        1:  891:      type = (uint8_t) (type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC));
        1:  892:      JERRY_ASSERT (type == 0 || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION));
        -:  893:
        1:  894:      literal_location_p->type = (uint8_t) (extended_type | type);
        -:  895:    }
        -:  896:  }
        -:  897:
        2:  898:  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || (compressed_size > 1))
        -:  899:  {
        2:  900:    if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT)
        -:  901:    {
        1:  902:      arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  903:    }
        1:  904:    else if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -:  905:    {
    #####:  906:      arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  907:    }
        -:  908:
        2:  909:    if (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT)
        -:  910:    {
    #####:  911:      compressed_size++;
        -:  912:    }
        -:  913:
        2:  914:    compressed_size += sizeof (scanner_info_t);
        -:  915:
        -:  916:    scanner_info_t *info_p;
        -:  917:
        2:  918:    if (prev_literal_pool_p != NULL || scanner_context_p->end_arguments_p == NULL)
        -:  919:    {
        2:  920:      info_p = scanner_insert_info (context_p, literal_pool_p->source_p, compressed_size);
        -:  921:    }
        -:  922:    else
        -:  923:    {
    #####:  924:      scanner_info_t *start_info_p = scanner_context_p->end_arguments_p;
    #####:  925:      info_p = scanner_insert_info_before (context_p, literal_pool_p->source_p, start_info_p, compressed_size);
        -:  926:    }
        -:  927:
        2:  928:    if (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        -:  929:    {
    #####:  930:      no_declarations = PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK;
        -:  931:    }
        -:  932:
        2:  933:    uint8_t *data_p = (uint8_t *) (info_p + 1);
        2:  934:    bool mapped_arguments = false;
        -:  935:
        2:  936:    if (status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  937:    {
        2:  938:      info_p->type = SCANNER_TYPE_FUNCTION;
        -:  939:
        2:  940:      uint8_t u8_arg = 0;
        -:  941:
        2:  942:      if (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT)
        -:  943:      {
    #####:  944:        u8_arg |= SCANNER_FUNCTION_ARGUMENTS_NEEDED;
        -:  945:
    #####:  946:        if (no_declarations < PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        -:  947:        {
    #####:  948:          no_declarations++;
        -:  949:        }
        -:  950:
        -:  951:#if JERRY_ESNEXT
    #####:  952:        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT | SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
        -:  953:#else /* !JERRY_ESNEXT */
    #####:  954:        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT;
        -:  955:#endif /* JERRY_ESNEXT */
        -:  956:
    #####:  957:        if (!(status_flags & is_unmapped))
        -:  958:        {
    #####:  959:          mapped_arguments = true;
        -:  960:        }
        -:  961:
    #####:  962:        if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -:  963:        {
    #####:  964:          arguments_stream_type |= SCANNER_STREAM_NO_REG;
        -:  965:        }
        -:  966:
    #####:  967:        if (last_argument_p == NULL)
        -:  968:        {
    #####:  969:          *data_p++ = arguments_stream_type;
        -:  970:        }
        -:  971:      }
        -:  972:      else
        -:  973:      {
        2:  974:        last_argument_p = NULL;
        -:  975:      }
        -:  976:
        -:  977:#if JERRY_ESNEXT
        2:  978:      if (status_flags & (SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT | SCANNER_LITERAL_POOL_ARROW))
        -:  979:      {
    #####:  980:        u8_arg |= SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -:  981:      }
        -:  982:
        2:  983:      if (status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -:  984:      {
    #####:  985:        u8_arg |= SCANNER_FUNCTION_ASYNC;
        -:  986:
    #####:  987:        if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)
        -:  988:        {
    #####:  989:          u8_arg |= SCANNER_FUNCTION_STATEMENT;
        -:  990:        }
        -:  991:      }
        -:  992:
        2:  993:      if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)
        -:  994:      {
        1:  995:        u8_arg |= SCANNER_FUNCTION_LEXICAL_ENV_NEEDED;
        -:  996:      }
        -:  997:
        2:  998:      if (status_flags & SCANNER_LITERAL_POOL_IS_STRICT)
        -:  999:      {
    #####: 1000:        u8_arg |= SCANNER_FUNCTION_IS_STRICT;
        -: 1001:      }
        -: 1002:#endif /* JERRY_ESNEXT */
        -: 1003:
        2: 1004:      info_p->u8_arg = u8_arg;
        2: 1005:      info_p->u16_arg = (uint16_t) no_declarations;
        -: 1006:    }
        -: 1007:    else
        -: 1008:    {
    #####: 1009:      info_p->type = SCANNER_TYPE_BLOCK;
        -: 1010:
    #####: 1011:      JERRY_ASSERT (prev_literal_pool_p != NULL);
        -: 1012:    }
        -: 1013:
        2: 1014:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        2: 1015:    prev_source_p = literal_pool_p->source_p - 1;
        2: 1016:    no_declarations = literal_pool_p->no_declarations;
        -: 1017:
        8: 1018:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1019:    {
        4: 1020:      if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        4: 1021:          || (!(literal_p->type & SCANNER_LITERAL_IS_LOCAL)
        4: 1022:              && (!(literal_p->type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))
        3: 1023:                  || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION))))
        -: 1024:      {
        1: 1025:        continue;
        -: 1026:      }
        -: 1027:
        3: 1028:      if (literal_p->length == 0)
        -: 1029:      {
    #####: 1030:        *data_p++ = SCANNER_STREAM_TYPE_HOLE;
        -: 1031:
    #####: 1032:        if (literal_p == last_argument_p)
        -: 1033:        {
    #####: 1034:          *data_p++ = arguments_stream_type;
        -: 1035:        }
    #####: 1036:        continue;
        -: 1037:      }
        -: 1038:
        3: 1039:      no_declarations++;
        -: 1040:
        3: 1041:      uint8_t type = SCANNER_STREAM_TYPE_VAR;
        -: 1042:
        3: 1043:      if (literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1044:      {
    #####: 1045:        no_declarations++;
    #####: 1046:        type = SCANNER_STREAM_TYPE_FUNC;
        -: 1047:
    #####: 1048:        if (literal_p->type & SCANNER_LITERAL_IS_ARG)
        -: 1049:        {
    #####: 1050:          type = SCANNER_STREAM_TYPE_ARG_FUNC;
        -: 1051:
        -: 1052:#if JERRY_ESNEXT
    #####: 1053:          if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1054:          {
    #####: 1055:            type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC;
        -: 1056:          }
        -: 1057:#endif /* JERRY_ESNEXT */
        -: 1058:        }
        -: 1059:      }
        3: 1060:      else if (literal_p->type & SCANNER_LITERAL_IS_ARG)
        -: 1061:      {
    #####: 1062:        type = SCANNER_STREAM_TYPE_ARG;
        -: 1063:
        -: 1064:#if JERRY_ESNEXT
    #####: 1065:        if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1066:        {
    #####: 1067:          type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG;
        -: 1068:        }
        -: 1069:
    #####: 1070:        if (literal_p->type & SCANNER_LITERAL_IS_VAR)
        -: 1071:        {
    #####: 1072:          type = (uint8_t) (type + 1);
        -: 1073:
    #####: 1074:          JERRY_ASSERT (type == SCANNER_STREAM_TYPE_ARG_VAR
        -: 1075:                        || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR);
        -: 1076:        }
        -: 1077:#endif /* JERRY_ESNEXT */
        -: 1078:      }
        -: 1079:#if JERRY_ESNEXT
        3: 1080:      else if (literal_p->type & SCANNER_LITERAL_IS_LET)
        -: 1081:      {
    #####: 1082:        if (!(literal_p->type & SCANNER_LITERAL_IS_CONST))
        -: 1083:        {
    #####: 1084:          type = SCANNER_STREAM_TYPE_LET;
        -: 1085:
    #####: 1086:          if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))
        -: 1087:          {
    #####: 1088:            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1089:          }
        -: 1090:        }
        -: 1091:#if JERRY_MODULE_SYSTEM
    #####: 1092:        else if (prev_literal_pool_p == NULL)
        -: 1093:        {
    #####: 1094:          type = SCANNER_STREAM_TYPE_IMPORT;
        -: 1095:        }
        -: 1096:#endif /* JERRY_MODULE_SYSTEM */
        -: 1097:        else
        -: 1098:        {
    #####: 1099:          type = SCANNER_STREAM_TYPE_LOCAL;
        -: 1100:        }
        -: 1101:      }
        3: 1102:      else if (literal_p->type & SCANNER_LITERAL_IS_CONST)
        -: 1103:      {
    #####: 1104:        type = SCANNER_STREAM_TYPE_CONST;
        -: 1105:
    #####: 1106:        if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))
        -: 1107:        {
    #####: 1108:          literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1109:        }
        -: 1110:      }
        -: 1111:
        3: 1112:      if (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)
        -: 1113:      {
    #####: 1114:        type |= SCANNER_STREAM_NO_REG | SCANNER_STREAM_EARLY_CREATE;
        -: 1115:      }
        -: 1116:#endif /* JERRY_ESNEXT */
        -: 1117:
        3: 1118:      if (literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)
        -: 1119:      {
    #####: 1120:        type |= SCANNER_STREAM_HAS_ESCAPE;
        -: 1121:      }
        -: 1122:
        3: 1123:      if ((literal_p->type & SCANNER_LITERAL_NO_REG)
    #####: 1124:          || (mapped_arguments && (literal_p->type & SCANNER_LITERAL_IS_ARG)))
        -: 1125:      {
        3: 1126:        type |= SCANNER_STREAM_NO_REG;
        -: 1127:      }
        -: 1128:
        3: 1129:      data_p[0] = type;
        3: 1130:      data_p[1] = (uint8_t) literal_p->length;
        3: 1131:      data_p += 3;
        -: 1132:
        3: 1133:      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);
        -: 1134:
        3: 1135:      if (diff >= 1 && diff <= (intptr_t) UINT8_MAX)
        -: 1136:      {
        3: 1137:        data_p[-1] = (uint8_t) diff;
        -: 1138:      }
    #####: 1139:      else if (diff >= -(intptr_t) UINT8_MAX && diff <= (intptr_t) UINT16_MAX)
        -: 1140:      {
    #####: 1141:        if (diff < 0)
        -: 1142:        {
    #####: 1143:          diff = -diff;
        -: 1144:        }
        -: 1145:
    #####: 1146:        data_p[-3] |= SCANNER_STREAM_UINT16_DIFF;
    #####: 1147:        data_p[-1] = (uint8_t) diff;
    #####: 1148:        data_p[0] = (uint8_t) (diff >> 8);
    #####: 1149:        data_p += 1;
        -: 1150:      }
        -: 1151:      else
        -: 1152:      {
    #####: 1153:        data_p[-1] = 0;
    #####: 1154:        memcpy (data_p, &literal_p->char_p, sizeof (uintptr_t));
    #####: 1155:        data_p += sizeof (uintptr_t);
        -: 1156:      }
        -: 1157:
        3: 1158:      if (literal_p == last_argument_p)
        -: 1159:      {
    #####: 1160:        *data_p++ = arguments_stream_type;
        -: 1161:      }
        -: 1162:
        3: 1163:      prev_source_p = literal_p->char_p + literal_p->length;
        -: 1164:    }
        -: 1165:
        2: 1166:    data_p[0] = SCANNER_STREAM_TYPE_END;
        -: 1167:
        2: 1168:    JERRY_ASSERT (((uint8_t *) info_p) + compressed_size == data_p + 1);
        -: 1169:  }
        -: 1170:
        2: 1171:  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION)
    #####: 1172:      && (int32_t) prev_literal_pool_p->no_declarations < no_declarations)
        -: 1173:  {
    #####: 1174:    prev_literal_pool_p->no_declarations = (uint16_t) no_declarations;
        -: 1175:  }
        -: 1176:
        2: 1177:  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) && prev_literal_pool_p != NULL)
        -: 1178:  {
        1: 1179:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IS_STRICT)
        -: 1180:    {
    #####: 1181:      context_p->status_flags |= PARSER_IS_STRICT;
        -: 1182:    }
        -: 1183:    else
        -: 1184:    {
        1: 1185:      context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -: 1186:    }
        -: 1187:
        -: 1188:#if JERRY_ESNEXT
        1: 1189:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -: 1190:    {
    #####: 1191:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 1192:    }
        -: 1193:    else
        -: 1194:    {
        1: 1195:      context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;
        -: 1196:    }
        -: 1197:
        1: 1198:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -: 1199:    {
    #####: 1200:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -: 1201:    }
        -: 1202:    else
        -: 1203:    {
        1: 1204:      context_p->status_flags &= (uint32_t) ~PARSER_IS_ASYNC_FUNCTION;
        -: 1205:    }
        -: 1206:#endif /* JERRY_ESNEXT */
        -: 1207:  }
        -: 1208:
        2: 1209:  scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;
        -: 1210:
        2: 1211:  parser_list_free (&literal_pool_p->literal_pool);
    #####: 1212:  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 1213:} /* scanner_pop_literal_pool */
        -: 1214:
        -: 1215:#if JERRY_ESNEXT
        -: 1216:
        -: 1217:/**
        -: 1218: * Filter out the arguments from a literal pool.
        -: 1219: */
        -: 1220:void
        1: 1221:scanner_filter_arguments (parser_context_t *context_p, /**< context */
        -: 1222:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1223:{
        -: 1224:  /* Fast case: check whether all literals are arguments. */
        1: 1225:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        1: 1226:  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
        1: 1227:  parser_list_iterator_t literal_iterator;
        -: 1228:  lexer_lit_location_t *literal_p;
        1: 1229:  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;
        1: 1230:  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;
        -: 1231:
        1: 1232:  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));
        -: 1233:
        1: 1234:  if (can_eval)
        -: 1235:  {
    #####: 1236:    if (prev_literal_pool_p != NULL)
        -: 1237:    {
    #####: 1238:      prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1239:    }
        -: 1240:
    #####: 1241:    if (has_arguments)
        -: 1242:    {
    #####: 1243:      literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);
        -: 1244:    }
        -: 1245:  }
        -: 1246:
        1: 1247:  literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1248:
        1: 1249:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1250:
        -: 1251:  while (true)
    #####: 1252:  {
        1: 1253:    literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);
        -: 1254:
        1: 1255:    if (literal_p == NULL)
        -: 1256:    {
        1: 1257:      return;
        -: 1258:    }
        -: 1259:
    #####: 1260:    if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
        -: 1261:    {
    #####: 1262:      literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
        -: 1263:    }
        -: 1264:
    #####: 1265:    uint8_t type = literal_p->type;
    #####: 1266:    const uint8_t mask = (SCANNER_LITERAL_IS_ARG
        -: 1267:                          | SCANNER_LITERAL_IS_DESTRUCTURED_ARG
        -: 1268:                          | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);
        -: 1269:
    #####: 1270:    if ((type & mask) != SCANNER_LITERAL_IS_ARG)
        -: 1271:    {
    #####: 1272:      break;
        -: 1273:    }
        -: 1274:  }
        -: 1275:
        -: 1276:  /* Destructured args are placed after the other arguments because of register assignments. */
    #####: 1277:  bool has_destructured_arg = false;
        -: 1278:  scanner_literal_pool_t *new_literal_pool_p;
        -: 1279:
    #####: 1280:  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
        -: 1281:
    #####: 1282:  new_literal_pool_p->prev_p = literal_pool_p;
    #####: 1283:  scanner_context_p->active_literal_pool_p = new_literal_pool_p;
        -: 1284:
    #####: 1285:  *new_literal_pool_p = *literal_pool_p;
    #####: 1286:  parser_list_init (&new_literal_pool_p->literal_pool,
        -: 1287:                    sizeof (lexer_lit_location_t),
        -: 1288:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
        -: 1289:
    #####: 1290:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1291:
    #####: 1292:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1293:  {
    #####: 1294:    uint8_t type = literal_p->type;
        -: 1295:
    #####: 1296:    if (type & SCANNER_LITERAL_IS_ARG)
        -: 1297:    {
    #####: 1298:      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
        -: 1299:      {
    #####: 1300:        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
    #####: 1301:        literal_p->type = type;
        -: 1302:      }
        -: 1303:
    #####: 1304:      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))
        -: 1305:      {
    #####: 1306:        has_destructured_arg = true;
        -: 1307:
    #####: 1308:        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1309:        {
    #####: 1310:          continue;
        -: 1311:        }
        -: 1312:
    #####: 1313:        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
    #####: 1314:        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
        -: 1315:
    #####: 1316:        literal_p->type = type;
    #####: 1317:        continue;
        -: 1318:      }
        -: 1319:
        -: 1320:      lexer_lit_location_t *new_literal_p;
    #####: 1321:      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
    #####: 1322:      *new_literal_p = *literal_p;
        -: 1323:    }
    #####: 1324:    else if (has_arguments && scanner_literal_is_arguments (literal_p))
        -: 1325:    {
    #####: 1326:      new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;
        -: 1327:
    #####: 1328:      if (type & SCANNER_LITERAL_NO_REG)
        -: 1329:      {
    #####: 1330:        new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -: 1331:      }
        -: 1332:    }
    #####: 1333:    else if (prev_literal_pool_p != NULL)
        -: 1334:    {
        -: 1335:      /* Propagate literal to upper level. */
    #####: 1336:      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p,
        -: 1337:                                                                             prev_literal_pool_p,
        -: 1338:                                                                             literal_p);
    #####: 1339:      type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED;
    #####: 1340:      literal_location_p->type |= type;
        -: 1341:    }
        -: 1342:  }
        -: 1343:
    #####: 1344:  if (has_destructured_arg)
        -: 1345:  {
    #####: 1346:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1347:
    #####: 1348:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1349:    {
    #####: 1350:      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
        -: 1351:
    #####: 1352:      if ((literal_p->type & expected_flags) == expected_flags)
        -: 1353:      {
        -: 1354:        lexer_lit_location_t *new_literal_p;
    #####: 1355:        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
    #####: 1356:        *new_literal_p = *literal_p;
        -: 1357:      }
        -: 1358:    }
        -: 1359:  }
        -: 1360:
    #####: 1361:  new_literal_pool_p->prev_p = prev_literal_pool_p;
        -: 1362:
    #####: 1363:  parser_list_free (&literal_pool_p->literal_pool);
    #####: 1364:  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 1365:} /* scanner_filter_arguments */
        -: 1366:
        -: 1367:#endif /* JERRY_ESNEXT */
        -: 1368:
        -: 1369:/**
        -: 1370: * Add any literal to the specified literal pool.
        -: 1371: *
        -: 1372: * @return pointer to the literal
        -: 1373: */
        -: 1374:lexer_lit_location_t *
       10: 1375:scanner_add_custom_literal (parser_context_t *context_p, /**< context */
        -: 1376:                            scanner_literal_pool_t *literal_pool_p, /**< literal pool */
        -: 1377:                            const lexer_lit_location_t *literal_location_p) /**< literal */
        -: 1378:{
        -: 1379:  while (true)
    #####: 1380:  {
       10: 1381:    parser_list_iterator_t literal_iterator;
       10: 1382:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1383:    lexer_lit_location_t *literal_p;
        -: 1384:
       10: 1385:    const uint8_t *char_p = literal_location_p->char_p;
       10: 1386:    prop_length_t length = literal_location_p->length;
        -: 1387:
       10: 1388:    if (JERRY_LIKELY (!(literal_location_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1389:    {
       26: 1390:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1391:      {
       12: 1392:        if (literal_p->length == length)
        -: 1393:        {
       12: 1394:          if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1395:          {
       12: 1396:            if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1397:            {
        6: 1398:              return literal_p;
        -: 1399:            }
        -: 1400:          }
    #####: 1401:          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1402:          {
        -: 1403:            /* The non-escaped version is preferred. */
    #####: 1404:            literal_p->char_p = char_p;
    #####: 1405:            literal_p->status_flags = LEXER_LIT_LOCATION_NO_OPTS;
    #####: 1406:            return literal_p;
        -: 1407:          }
        -: 1408:        }
        -: 1409:      }
        -: 1410:    }
        -: 1411:    else
        -: 1412:    {
    #####: 1413:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1414:      {
    #####: 1415:        if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))
        -: 1416:        {
    #####: 1417:          return literal_p;
        -: 1418:        }
        -: 1419:      }
        -: 1420:    }
        -: 1421:
        -: 1422:#if JERRY_ESNEXT
        4: 1423:    if (JERRY_UNLIKELY (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME))
        -: 1424:    {
    #####: 1425:      literal_pool_p = literal_pool_p->prev_p;
    #####: 1426:      continue;
        -: 1427:    }
        -: 1428:#endif /* JERRY_ESNEXT */
        -: 1429:
        4: 1430:    literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        4: 1431:    *literal_p = *literal_location_p;
        -: 1432:
        4: 1433:    literal_p->type = 0;
        -: 1434:
        4: 1435:    return literal_p;
        -: 1436:  }
        -: 1437:} /* scanner_add_custom_literal */
        -: 1438:
        -: 1439:/**
        -: 1440: * Add the current literal token to the current literal pool.
        -: 1441: *
        -: 1442: * @return pointer to the literal
        -: 1443: */
        -: 1444:extern inline lexer_lit_location_t * JERRY_ATTR_ALWAYS_INLINE
        3: 1445:scanner_add_literal (parser_context_t *context_p, /**< context */
        -: 1446:                     scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1447:{
        3: 1448:  return scanner_add_custom_literal (context_p,
        -: 1449:                                     scanner_context_p->active_literal_pool_p,
        3: 1450:                                     &context_p->token.lit_location);
        -: 1451:} /* scanner_add_literal */
        -: 1452:
        -: 1453:/**
        -: 1454: * Add the current literal token to the current literal pool and
        -: 1455: * set SCANNER_LITERAL_NO_REG if it is inside a with statement.
        -: 1456: *
        -: 1457: * @return pointer to the literal
        -: 1458: */
        -: 1459:extern inline void JERRY_ATTR_ALWAYS_INLINE
        6: 1460:scanner_add_reference (parser_context_t *context_p, /**< context */
        -: 1461:                       scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1462:{
        6: 1463:  lexer_lit_location_t *lit_location_p = scanner_add_custom_literal (context_p,
        -: 1464:                                                                     scanner_context_p->active_literal_pool_p,
        6: 1465:                                                                     &context_p->token.lit_location);
        -: 1466:#if JERRY_ESNEXT
        6: 1467:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -: 1468:#endif /* JERRY_ESNEXT */
        -: 1469:
        6: 1470:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 1471:  {
    #####: 1472:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -: 1473:  }
        -: 1474:
        6: 1475:  scanner_detect_eval_call (context_p, scanner_context_p);
        6: 1476:} /* scanner_add_reference */
        -: 1477:
        -: 1478:/**
        -: 1479: * Append an argument to the literal pool. If the argument is already present, make it a "hole".
        -: 1480: *
        -: 1481: * @return newly created literal
        -: 1482: */
        -: 1483:lexer_lit_location_t *
    #####: 1484:scanner_append_argument (parser_context_t *context_p, /**< context */
        -: 1485:                         scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1486:{
    #####: 1487:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
    #####: 1488:  parser_list_iterator_t literal_iterator;
    #####: 1489:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
    #####: 1490:  lexer_lit_location_t *literal_location_p = &context_p->token.lit_location;
        -: 1491:  lexer_lit_location_t *literal_p;
        -: 1492:
    #####: 1493:  const uint8_t *char_p = literal_location_p->char_p;
    #####: 1494:  prop_length_t length = literal_location_p->length;
        -: 1495:
    #####: 1496:  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));
        -: 1497:
    #####: 1498:  if (JERRY_LIKELY (!(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1499:  {
    #####: 1500:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1501:    {
    #####: 1502:      if (literal_p->length == length)
        -: 1503:      {
    #####: 1504:        if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1505:        {
    #####: 1506:          if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1507:          {
    #####: 1508:            break;
        -: 1509:          }
        -: 1510:        }
    #####: 1511:        else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1512:        {
    #####: 1513:          break;
        -: 1514:        }
        -: 1515:      }
        -: 1516:    }
        -: 1517:  }
        -: 1518:  else
        -: 1519:  {
    #####: 1520:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1521:    {
    #####: 1522:      if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))
        -: 1523:      {
    #####: 1524:        break;
        -: 1525:      }
        -: 1526:    }
        -: 1527:  }
        -: 1528:
    #####: 1529:  uint8_t literal_type = SCANNER_LITERAL_IS_ARG;
        -: 1530:
    #####: 1531:  if (literal_p != NULL)
        -: 1532:  {
    #####: 1533:    literal_p->length = 0;
        -: 1534:
        -: 1535:#if JERRY_ESNEXT
    #####: 1536:    if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1537:    {
    #####: 1538:      literal_type = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_EARLY_CREATE;
        -: 1539:    }
        -: 1540:#endif /* JERRY_ESNEXT */
        -: 1541:  }
        -: 1542:
    #####: 1543:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        -: 1544:
    #####: 1545:  *literal_p = context_p->token.lit_location;
    #####: 1546:  literal_p->type = literal_type;
        -: 1547:
    #####: 1548:  return literal_p;
        -: 1549:} /* scanner_append_argument */
        -: 1550:
        -: 1551:/**
        -: 1552: * Check whether an eval call is performed and update the status flags accordingly.
        -: 1553: */
        -: 1554:void
        6: 1555:scanner_detect_eval_call (parser_context_t *context_p, /**< context */
        -: 1556:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1557:{
        6: 1558:  if (context_p->token.keyword_type == LEXER_KEYW_EVAL
    #####: 1559:      && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 1560:  {
        -: 1561:#if JERRY_ESNEXT
    #####: 1562:    const uint16_t flags = (uint16_t) (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);
        -: 1563:#else /* !JERRY_ESNEXT */
    #####: 1564:    const uint16_t flags = SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1565:#endif /* JERRY_ESNEXT */
        -: 1566:
    #####: 1567:    scanner_context_p->active_literal_pool_p->status_flags |= flags;
        -: 1568:  }
        6: 1569:} /* scanner_detect_eval_call */
        -: 1570:
        -: 1571:#if JERRY_ESNEXT
        -: 1572:
        -: 1573:/**
        -: 1574: * Throws an error for invalid var statements.
        -: 1575: */
        -: 1576:void
        3: 1577:scanner_detect_invalid_var (parser_context_t *context_p, /**< context */
        -: 1578:                            scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1579:                            lexer_lit_location_t *var_literal_p) /**< var literal */
        -: 1580:{
        3: 1581:  if (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL
    #####: 1582:      && !(var_literal_p->type & (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_ARG))
    #####: 1583:      && (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL)
        -: 1584:  {
    #####: 1585:    scanner_raise_redeclaration_error (context_p);
        -: 1586:  }
        -: 1587:
        3: 1588:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1589:
        3: 1590:  if (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION)
    #####: 1591:      && ((var_literal_p->type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_LOCAL_FUNC))
        -: 1592:  {
    #####: 1593:    scanner_raise_redeclaration_error (context_p);
        -: 1594:  }
        -: 1595:
        3: 1596:  const uint8_t *char_p = var_literal_p->char_p;
        3: 1597:  prop_length_t length = var_literal_p->length;
        -: 1598:
        6: 1599:  while (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
        -: 1600:  {
    #####: 1601:    literal_pool_p = literal_pool_p->prev_p;
        -: 1602:
    #####: 1603:    parser_list_iterator_t literal_iterator;
    #####: 1604:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1605:    lexer_lit_location_t *literal_p;
        -: 1606:
    #####: 1607:    if (JERRY_LIKELY (!(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1608:    {
    #####: 1609:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1610:      {
    #####: 1611:        if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)
    #####: 1612:            && !(literal_p->type & SCANNER_LITERAL_IS_ARG)
    #####: 1613:            && !((literal_p->type & SCANNER_LITERAL_IS_FUNC)
    #####: 1614:                 && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
    #####: 1615:            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL
    #####: 1616:            && literal_p->length == length)
        -: 1617:        {
    #####: 1618:          if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1619:          {
    #####: 1620:            if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1621:            {
    #####: 1622:              scanner_raise_redeclaration_error (context_p);
    #####: 1623:              return;
        -: 1624:            }
        -: 1625:          }
    #####: 1626:          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1627:          {
    #####: 1628:            scanner_raise_redeclaration_error (context_p);
    #####: 1629:            return;
        -: 1630:          }
        -: 1631:        }
        -: 1632:      }
        -: 1633:    }
        -: 1634:    else
        -: 1635:    {
    #####: 1636:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1637:      {
    #####: 1638:        if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL)
    #####: 1639:            && !(literal_p->type & SCANNER_LITERAL_IS_ARG)
    #####: 1640:            && !((literal_p->type & SCANNER_LITERAL_IS_FUNC)
    #####: 1641:                 && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
    #####: 1642:            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL
    #####: 1643:            && lexer_compare_identifiers (context_p, literal_p, var_literal_p))
        -: 1644:        {
    #####: 1645:          scanner_raise_redeclaration_error (context_p);
    #####: 1646:          return;
        -: 1647:        }
        -: 1648:      }
        -: 1649:    }
        -: 1650:  }
        -: 1651:
        3: 1652:  if (scanner_scope_find_lexical_declaration (context_p, var_literal_p))
        -: 1653:  {
    #####: 1654:    scanner_raise_redeclaration_error (context_p);
        -: 1655:  }
        -: 1656:} /* scanner_detect_invalid_var */
        -: 1657:
        -: 1658:/**
        -: 1659: * Throws an error for invalid let statements.
        -: 1660: */
        -: 1661:void
    #####: 1662:scanner_detect_invalid_let (parser_context_t *context_p, /**< context */
        -: 1663:                            lexer_lit_location_t *let_literal_p) /**< let literal */
        -: 1664:{
    #####: 1665:  if (let_literal_p->type & (SCANNER_LITERAL_IS_ARG
        -: 1666:                             | SCANNER_LITERAL_IS_VAR
        -: 1667:                             | SCANNER_LITERAL_IS_LOCAL))
        -: 1668:  {
    #####: 1669:    scanner_raise_redeclaration_error (context_p);
        -: 1670:  }
        -: 1671:
    #####: 1672:  if (let_literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1673:  {
    #####: 1674:    let_literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
        -: 1675:  }
    #####: 1676:} /* scanner_detect_invalid_let */
        -: 1677:
        -: 1678:/**
        -: 1679: * Push the values required for class declaration parsing.
        -: 1680: *
        -: 1681: * @return literal reference created for class statements, NULL otherwise
        -: 1682: */
        -: 1683:lexer_lit_location_t *
    #####: 1684:scanner_push_class_declaration (parser_context_t *context_p, /**< context */
        -: 1685:                                scanner_context_t *scanner_context_p, /* scanner context */
        -: 1686:                                uint8_t stack_mode) /**< stack mode */
        -: 1687:{
    #####: 1688:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_CLASS);
        -: 1689:
    #####: 1690:  const uint8_t *source_p = context_p->source_p;
    #####: 1691:  lexer_lit_location_t *literal_p = NULL;
        -: 1692:
        -: 1693:#if JERRY_MODULE_SYSTEM
    #####: 1694:  bool is_export_default = context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT;
    #####: 1695:  JERRY_ASSERT (!is_export_default || stack_mode == SCAN_STACK_CLASS_EXPRESSION);
        -: 1696:#endif /* JERRY_MODULE_SYSTEM */
        -: 1697:
    #####: 1698:  parser_stack_push_uint8 (context_p, stack_mode);
    #####: 1699:  lexer_next_token (context_p);
        -: 1700:
    #####: 1701:  bool class_has_name = (context_p->token.type == LEXER_LITERAL
    #####: 1702:                         && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1703:
    #####: 1704:  if (class_has_name)
        -: 1705:  {
    #####: 1706:    if (stack_mode == SCAN_STACK_CLASS_STATEMENT)
        -: 1707:    {
    #####: 1708:      literal_p = scanner_add_literal (context_p, scanner_context_p);
    #####: 1709:      scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1710:    }
        -: 1711:#if JERRY_MODULE_SYSTEM
    #####: 1712:    else if (is_export_default)
        -: 1713:    {
    #####: 1714:      literal_p = scanner_add_literal (context_p, scanner_context_p);
    #####: 1715:      scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1716:
    #####: 1717:      scanner_detect_invalid_let (context_p, literal_p);
        -: 1718:
    #####: 1719:      if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1720:      {
    #####: 1721:        literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1722:      }
        -: 1723:
    #####: 1724:      literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;
        -: 1725:    }
        -: 1726:#endif /* JERRY_MODULE_SYSTEM */
        -: 1727:  }
        -: 1728:
    #####: 1729:  scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        -: 1730:
    #####: 1731:  if (class_has_name)
        -: 1732:  {
    #####: 1733:    scanner_add_literal (context_p, scanner_context_p);
    #####: 1734:    scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1735:  }
        -: 1736:#if JERRY_MODULE_SYSTEM
    #####: 1737:  else if (is_export_default)
        -: 1738:  {
        -: 1739:    lexer_lit_location_t *name_literal_p;
    #####: 1740:    name_literal_p = scanner_add_custom_literal (context_p,
    #####: 1741:                                                 scanner_context_p->active_literal_pool_p->prev_p,
        -: 1742:                                                 &lexer_default_literal);
        -: 1743:
    #####: 1744:    name_literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;
    #####: 1745:    scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1746:  }
        -: 1747:#endif /* JERRY_MODULE_SYSTEM */
        -: 1748:
    #####: 1749:  literal_pool_p->source_p = source_p;
    #####: 1750:  literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CLASS_NAME;
        -: 1751:
    #####: 1752:  parser_stack_push_uint8 (context_p, SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR);
    #####: 1753:  scanner_context_p->mode = SCAN_MODE_CLASS_DECLARATION;
        -: 1754:
    #####: 1755:  return literal_p;
        -: 1756:} /* scanner_push_class_declaration */
        -: 1757:
        -: 1758:/**
        -: 1759: * Push the start of a class field initializer.
        -: 1760: */
        -: 1761:void
    #####: 1762:scanner_push_class_field_initializer (parser_context_t *context_p, /**< context */
        -: 1763:                                      scanner_context_t *scanner_context_p) /* scanner context */
        -: 1764:{
    #####: 1765:  scanner_source_start_t source_start;
    #####: 1766:  source_start.source_p = context_p->source_p;
        -: 1767:
    #####: 1768:  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1769:  parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_FIELD_INITIALIZER);
        -: 1770:
        -: 1771:  scanner_literal_pool_t *literal_pool_p;
    #####: 1772:  literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_CLASS_FIELD);
    #####: 1773:  literal_pool_p->source_p = context_p->source_p;
        -: 1774:
    #####: 1775:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1776:} /* scanner_push_class_field_initializer */
        -: 1777:
        -: 1778:/**
        -: 1779: * Push the values required for destructuring assignment or binding parsing.
        -: 1780: */
        -: 1781:void
        2: 1782:scanner_push_destructuring_pattern (parser_context_t *context_p, /**< context */
        -: 1783:                                    scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1784:                                    uint8_t binding_type, /**< type of destructuring binding pattern */
        -: 1785:                                    bool is_nested) /**< nested declaration */
        -: 1786:{
        2: 1787:  JERRY_ASSERT (binding_type != SCANNER_BINDING_NONE || !is_nested);
        -: 1788:
        2: 1789:  scanner_source_start_t source_start;
        2: 1790:  source_start.source_p = context_p->source_p;
        -: 1791:
        2: 1792:  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
        2: 1793:  parser_stack_push_uint8 (context_p, scanner_context_p->binding_type);
        2: 1794:  scanner_context_p->binding_type = binding_type;
        -: 1795:
        2: 1796:  if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -: 1797:  {
        -: 1798:    scanner_binding_list_t *binding_list_p;
    #####: 1799:    binding_list_p = (scanner_binding_list_t *) scanner_malloc (context_p, sizeof (scanner_binding_list_t));
        -: 1800:
    #####: 1801:    binding_list_p->prev_p = scanner_context_p->active_binding_list_p;
    #####: 1802:    binding_list_p->items_p = NULL;
    #####: 1803:    binding_list_p->is_nested = is_nested;
        -: 1804:
    #####: 1805:    scanner_context_p->active_binding_list_p = binding_list_p;
        -: 1806:  }
        2: 1807:} /* scanner_push_destructuring_pattern */
        -: 1808:
        -: 1809:/**
        -: 1810: * Pop binding list.
        -: 1811: */
        -: 1812:void
    #####: 1813:scanner_pop_binding_list (scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1814:{
    #####: 1815:  scanner_binding_list_t *binding_list_p = scanner_context_p->active_binding_list_p;
    #####: 1816:  JERRY_ASSERT (binding_list_p != NULL);
        -: 1817:
    #####: 1818:  scanner_binding_item_t *item_p = binding_list_p->items_p;
    #####: 1819:  scanner_binding_list_t *prev_binding_list_p = binding_list_p->prev_p;
    #####: 1820:  bool is_nested = binding_list_p->is_nested;
        -: 1821:
    #####: 1822:  scanner_free (binding_list_p, sizeof (scanner_binding_list_t));
    #####: 1823:  scanner_context_p->active_binding_list_p = prev_binding_list_p;
        -: 1824:
    #####: 1825:  if (!is_nested)
        -: 1826:  {
    #####: 1827:    while (item_p != NULL)
        -: 1828:    {
    #####: 1829:      scanner_binding_item_t *next_p = item_p->next_p;
        -: 1830:
    #####: 1831:      JERRY_ASSERT (item_p->literal_p->type & (SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_IS_ARG));
        -: 1832:
    #####: 1833:      scanner_free (item_p, sizeof (scanner_binding_item_t));
    #####: 1834:      item_p = next_p;
        -: 1835:    }
    #####: 1836:    return;
        -: 1837:  }
        -: 1838:
    #####: 1839:  JERRY_ASSERT (prev_binding_list_p != NULL);
        -: 1840:
    #####: 1841:  while (item_p != NULL)
        -: 1842:  {
    #####: 1843:    scanner_binding_item_t *next_p = item_p->next_p;
        -: 1844:
    #####: 1845:    item_p->next_p = prev_binding_list_p->items_p;
    #####: 1846:    prev_binding_list_p->items_p = item_p;
        -: 1847:
    #####: 1848:    item_p = next_p;
        -: 1849:  }
        -: 1850:} /* scanner_pop_binding_list */
        -: 1851:
        -: 1852:/**
        -: 1853: * Append a hole into the literal pool.
        -: 1854: */
        -: 1855:void
    #####: 1856:scanner_append_hole (parser_context_t *context_p, scanner_context_t *scanner_context_p)
        -: 1857:{
    #####: 1858:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1859:
        -: 1860:  lexer_lit_location_t *literal_p;
    #####: 1861:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        -: 1862:
    #####: 1863:  literal_p->char_p = NULL;
    #####: 1864:  literal_p->length = 0;
    #####: 1865:  literal_p->type = SCANNER_LITERAL_IS_ARG;
    #####: 1866:  literal_p->status_flags = LEXER_LIT_LOCATION_NO_OPTS;
    #####: 1867:} /* scanner_append_hole */
        -: 1868:
        -: 1869:#endif /* JERRY_ESNEXT */
        -: 1870:
        -: 1871:/**
        -: 1872: * Reverse the scanner info chain after the scanning is completed.
        -: 1873: */
        -: 1874:void
        1: 1875:scanner_reverse_info_list (parser_context_t *context_p) /**< context */
        -: 1876:{
        1: 1877:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        1: 1878:  scanner_info_t *last_scanner_info_p = NULL;
        -: 1879:
        1: 1880:  if (scanner_info_p->type == SCANNER_TYPE_END)
        -: 1881:  {
    #####: 1882:    return;
        -: 1883:  }
        -: 1884:
        -: 1885:  do
        -: 1886:  {
        3: 1887:    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;
        3: 1888:    scanner_info_p->next_p = last_scanner_info_p;
        -: 1889:
        3: 1890:    last_scanner_info_p = scanner_info_p;
        3: 1891:    scanner_info_p = next_scanner_info_p;
        -: 1892:  }
        3: 1893:  while (scanner_info_p->type != SCANNER_TYPE_END);
        -: 1894:
        1: 1895:  context_p->next_scanner_info_p->next_p = scanner_info_p;
        1: 1896:  context_p->next_scanner_info_p = last_scanner_info_p;
        -: 1897:} /* scanner_reverse_info_list */
        -: 1898:
        -: 1899:/**
        -: 1900: * Release unused scanner info blocks.
        -: 1901: * This should happen only if an error is occured.
        -: 1902: */
        -: 1903:void
    #####: 1904:scanner_cleanup (parser_context_t *context_p) /**< context */
        -: 1905:{
    #####: 1906:  if (context_p->skipped_scanner_info_p != NULL)
        -: 1907:  {
    #####: 1908:    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;
    #####: 1909:    context_p->next_scanner_info_p = context_p->skipped_scanner_info_p;
    #####: 1910:    context_p->skipped_scanner_info_p = NULL;
        -: 1911:  }
        -: 1912:
    #####: 1913:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -: 1914:
    #####: 1915:  while (scanner_info_p != NULL)
        -: 1916:  {
    #####: 1917:    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;
        -: 1918:
    #####: 1919:    size_t size = sizeof (scanner_info_t);
        -: 1920:
    #####: 1921:    switch (scanner_info_p->type)
        -: 1922:    {
    #####: 1923:      case SCANNER_TYPE_END:
        -: 1924:      {
    #####: 1925:        scanner_info_p = context_p->active_scanner_info_p;
    #####: 1926:        continue;
        -: 1927:      }
    #####: 1928:      case SCANNER_TYPE_FUNCTION:
        -: 1929:      case SCANNER_TYPE_BLOCK:
        -: 1930:      {
    #####: 1931:        size = scanner_get_stream_size (scanner_info_p, sizeof (scanner_info_t));
    #####: 1932:        break;
        -: 1933:      }
    #####: 1934:      case SCANNER_TYPE_WHILE:
        -: 1935:      case SCANNER_TYPE_FOR_IN:
        -: 1936:#if JERRY_ESNEXT
        -: 1937:      case SCANNER_TYPE_FOR_OF:
        -: 1938:#endif /* JERRY_ESNEXT */
        -: 1939:      case SCANNER_TYPE_CASE:
        -: 1940:#if JERRY_ESNEXT
        -: 1941:      case SCANNER_TYPE_INITIALIZER:
        -: 1942:      case SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END:
        -: 1943:#endif /* JERRY_ESNEXT */
        -: 1944:      {
    #####: 1945:        size = sizeof (scanner_location_info_t);
    #####: 1946:        break;
        -: 1947:      }
    #####: 1948:      case SCANNER_TYPE_FOR:
        -: 1949:      {
    #####: 1950:        size = sizeof (scanner_for_info_t);
    #####: 1951:        break;
        -: 1952:      }
    #####: 1953:      case SCANNER_TYPE_SWITCH:
        -: 1954:      {
    #####: 1955:        scanner_release_switch_cases (((scanner_switch_info_t *) scanner_info_p)->case_p);
    #####: 1956:        size = sizeof (scanner_switch_info_t);
    #####: 1957:        break;
        -: 1958:      }
    #####: 1959:      default:
        -: 1960:      {
        -: 1961:#if JERRY_ESNEXT
    #####: 1962:        JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS
        -: 1963:                      || scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS
        -: 1964:                      || scanner_info_p->type == SCANNER_TYPE_CLASS_CONSTRUCTOR
        -: 1965:                      || scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION
        -: 1966:                      || scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED
        -: 1967:                      || scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION
        -: 1968:                      || scanner_info_p->type == SCANNER_TYPE_EXPORT_MODULE_SPECIFIER);
        -: 1969:#else /* !JERRY_ESNEXT */
        -: 1970:        JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);
        -: 1971:#endif /* JERRY_ESNEXT */
    #####: 1972:        break;
        -: 1973:      }
        -: 1974:    }
        -: 1975:
    #####: 1976:    scanner_free (scanner_info_p, size);
    #####: 1977:    scanner_info_p = next_scanner_info_p;
        -: 1978:  }
        -: 1979:
    #####: 1980:  context_p->next_scanner_info_p = NULL;
    #####: 1981:  context_p->active_scanner_info_p = NULL;
    #####: 1982:} /* scanner_cleanup */
        -: 1983:
        -: 1984:/**
        -: 1985: * Checks whether a context needs to be created for a block.
        -: 1986: *
        -: 1987: * @return true - if context is needed,
        -: 1988: *         false - otherwise
        -: 1989: */
        -: 1990:bool
        1: 1991:scanner_is_context_needed (parser_context_t *context_p, /**< context */
        -: 1992:                           parser_check_context_type_t check_type) /**< context type */
        -: 1993:{
        1: 1994:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        1: 1995:  const uint8_t *data_p = (const uint8_t *) (info_p + 1);
        -: 1996:
        -: 1997:  JERRY_UNUSED (check_type);
        -: 1998:
        -: 1999:#if JERRY_ESNEXT
        1: 2000:  JERRY_ASSERT ((check_type == PARSER_CHECK_BLOCK_CONTEXT ? info_p->type == SCANNER_TYPE_BLOCK
        -: 2001:                                                          : info_p->type == SCANNER_TYPE_FUNCTION));
        -: 2002:
        1: 2003:  uint32_t scope_stack_reg_top = (check_type != PARSER_CHECK_GLOBAL_CONTEXT ? context_p->scope_stack_reg_top
        1: 2004:                                                                            : 0);
        -: 2005:#else /* !JERRY_ESNEXT */
        -: 2006:  JERRY_ASSERT (check_type == PARSER_CHECK_BLOCK_CONTEXT);
        -: 2007:  JERRY_ASSERT (info_p->type == SCANNER_TYPE_BLOCK);
        -: 2008:
    #####: 2009:  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2010:#endif /* !JERRY_NDEBUG */
        -: 2011:
        5: 2012:  while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2013:  {
        3: 2014:    uint8_t data = data_p[0];
        -: 2015:
        -: 2016:#if JERRY_ESNEXT
        3: 2017:    uint32_t type = data & SCANNER_STREAM_TYPE_MASK;
        -: 2018:
        3: 2019:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))
        -: 2020:    {
    #####: 2021:      if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))
        -: 2022:      {
    #####: 2023:        data_p++;
    #####: 2024:        continue;
        -: 2025:      }
        -: 2026:
    #####: 2027:      if (JERRY_UNLIKELY (SCANNER_STREAM_TYPE_IS_ARGUMENTS (type)))
        -: 2028:      {
    #####: 2029:        if ((data & SCANNER_STREAM_NO_REG)
    #####: 2030:            || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2031:        {
    #####: 2032:          return true;
        -: 2033:        }
        -: 2034:
    #####: 2035:        scope_stack_reg_top++;
    #####: 2036:        data_p++;
    #####: 2037:        continue;
        -: 2038:      }
        -: 2039:    }
        -: 2040:
        -: 2041:#ifndef JERRY_NDEBUG
        3: 2042:    if (check_type == PARSER_CHECK_BLOCK_CONTEXT)
        -: 2043:    {
    #####: 2044:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR
        -: 2045:                    || type == SCANNER_STREAM_TYPE_LET
        -: 2046:                    || type == SCANNER_STREAM_TYPE_CONST
        -: 2047:                    || type == SCANNER_STREAM_TYPE_LOCAL
        -: 2048:                    || type == SCANNER_STREAM_TYPE_FUNC);
        -: 2049:    }
        3: 2050:    else if (check_type == PARSER_CHECK_GLOBAL_CONTEXT)
        -: 2051:    {
        -: 2052:#if JERRY_MODULE_SYSTEM
        3: 2053:      const bool is_import = (type == SCANNER_STREAM_TYPE_IMPORT);
        -: 2054:#else
        -: 2055:      const bool is_import = true;
        -: 2056:#endif /* JERRY_MODULE_SYSTEM */
        -: 2057:
        -: 2058:      /* FIXME: a private declarative lexical environment should always be present
        -: 2059:       * for modules. Remove SCANNER_STREAM_TYPE_IMPORT after it is implemented. */
        3: 2060:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR
        -: 2061:                    || type == SCANNER_STREAM_TYPE_LET
        -: 2062:                    || type == SCANNER_STREAM_TYPE_CONST
        -: 2063:                    || type == SCANNER_STREAM_TYPE_FUNC
        -: 2064:                    || is_import);
        -: 2065:
        -: 2066:      /* Only let/const can be stored in registers */
        3: 2067:      JERRY_ASSERT ((data & SCANNER_STREAM_NO_REG)
        -: 2068:                    || (type == SCANNER_STREAM_TYPE_FUNC && (context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
        -: 2069:                    || type == SCANNER_STREAM_TYPE_LET
        -: 2070:                    || type == SCANNER_STREAM_TYPE_CONST);
        -: 2071:    }
        -: 2072:    else
        -: 2073:    {
    #####: 2074:      JERRY_ASSERT (check_type == PARSER_CHECK_FUNCTION_CONTEXT);
        -: 2075:
    #####: 2076:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR
        -: 2077:                    || type == SCANNER_STREAM_TYPE_LET
        -: 2078:                    || type == SCANNER_STREAM_TYPE_CONST
        -: 2079:                    || type == SCANNER_STREAM_TYPE_LOCAL
        -: 2080:                    || type == SCANNER_STREAM_TYPE_ARG
        -: 2081:                    || type == SCANNER_STREAM_TYPE_ARG_VAR
        -: 2082:                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG
        -: 2083:                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR
        -: 2084:                    || type == SCANNER_STREAM_TYPE_ARG_FUNC
        -: 2085:                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC
        -: 2086:                    || type == SCANNER_STREAM_TYPE_FUNC);
        -: 2087:    }
        -: 2088:#endif /* !JERRY_NDEBUG */
        -: 2089:
        -: 2090:#else /* !JERRY_ESNEXT */
        -: 2091:    JERRY_ASSERT ((data & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_VAR);
        -: 2092:#endif /* JERRY_ESNEXT */
        -: 2093:
        3: 2094:    if (!(data & SCANNER_STREAM_UINT16_DIFF))
        -: 2095:    {
        3: 2096:      if (data_p[2] != 0)
        -: 2097:      {
        3: 2098:        data_p += 2 + 1;
        -: 2099:      }
        -: 2100:      else
        -: 2101:      {
    #####: 2102:        data_p += 2 + 1 + sizeof (const uint8_t *);
        -: 2103:      }
        -: 2104:    }
        -: 2105:    else
        -: 2106:    {
    #####: 2107:      data_p += 2 + 2;
        -: 2108:    }
        -: 2109:
        -: 2110:#if JERRY_ESNEXT
        -: 2111:#if JERRY_MODULE_SYSTEM
        3: 2112:    const bool is_import = (type == SCANNER_STREAM_TYPE_IMPORT);
        -: 2113:#else /* !JERRY_MODULE_SYSTEM */
        -: 2114:    const bool is_import = false;
        -: 2115:#endif /* JERRY_MODULE_SYSTEM */
        -: 2116:
        3: 2117:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_GLOBAL_CONTEXT)
        3: 2118:        && (type == SCANNER_STREAM_TYPE_VAR
    #####: 2119:            || (type == SCANNER_STREAM_TYPE_FUNC && !(context_p->global_status_flags & ECMA_PARSE_EVAL))
    #####: 2120:            || is_import))
        -: 2121:    {
        3: 2122:      continue;
        -: 2123:    }
        -: 2124:
    #####: 2125:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))
        -: 2126:    {
    #####: 2127:      if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type)
    #####: 2128:          || type == SCANNER_STREAM_TYPE_ARG_VAR
    #####: 2129:          || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR)
        -: 2130:      {
        -: 2131:        /* The return value is true, if the variable is stored in the lexical environment
        -: 2132:         * or all registers have already been used for function arguments. This can be
        -: 2133:         * inprecise in the latter case, but this is a very rare corner case. A more
        -: 2134:         * sophisticated check would require to decode the literal. */
    #####: 2135:        if ((data & SCANNER_STREAM_NO_REG)
    #####: 2136:            || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2137:        {
    #####: 2138:          return true;
        -: 2139:        }
    #####: 2140:        continue;
        -: 2141:      }
        -: 2142:
    #####: 2143:      if (SCANNER_STREAM_TYPE_IS_ARG (type))
        -: 2144:      {
    #####: 2145:        continue;
        -: 2146:      }
        -: 2147:    }
        -: 2148:#endif /* JERRY_ESNEXT */
        -: 2149:
    #####: 2150:    if ((data & SCANNER_STREAM_NO_REG)
    #####: 2151:        || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2152:    {
    #####: 2153:      return true;
        -: 2154:    }
        -: 2155:
    #####: 2156:    scope_stack_reg_top++;
        -: 2157:  }
        -: 2158:
        1: 2159:  return false;
        -: 2160:} /* scanner_is_context_needed */
        -: 2161:
        -: 2162:#if JERRY_ESNEXT
        -: 2163:
        -: 2164:/**
        -: 2165: * Try to scan/parse the ".target" part in the "new.target" expression.
        -: 2166: *
        -: 2167: * Upon exiting with "true" the current token will point to the "target"
        -: 2168: * literal.
        -: 2169: *
        -: 2170: * If the "target" literal is not after the "new." then a scanner/parser
        -: 2171: * error will be raised.
        -: 2172: *
        -: 2173: * @returns true if the ".target" part was found
        -: 2174: *          false if there is no "." after the new.
        -: 2175: */
        -: 2176:bool
    #####: 2177:scanner_try_scan_new_target (parser_context_t *context_p) /**< parser/scanner context */
        -: 2178:{
    #####: 2179:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_NEW);
        -: 2180:
    #####: 2181:  if (lexer_check_next_character (context_p, LIT_CHAR_DOT))
        -: 2182:  {
    #####: 2183:    lexer_next_token (context_p);
    #####: 2184:    if (context_p->token.type != LEXER_DOT)
        -: 2185:    {
    #####: 2186:      parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);
        -: 2187:    }
        -: 2188:
    #####: 2189:    lexer_next_token (context_p);
    #####: 2190:    if (!lexer_token_is_identifier (context_p, "target", 6))
        -: 2191:    {
    #####: 2192:      parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_EXPECTED);
        -: 2193:    }
        -: 2194:
    #####: 2195:    return true;
        -: 2196:  }
    #####: 2197:  return false;
        -: 2198:} /* scanner_try_scan_new_target */
        -: 2199:
        -: 2200:#endif /* JERRY_ESNEXT */
        -: 2201:
        -: 2202:/**
        -: 2203: * Description of "arguments" literal string.
        -: 2204: */
        -: 2205:const lexer_lit_location_t lexer_arguments_literal =
        -: 2206:{
        -: 2207:  (const uint8_t *) "arguments", 9, LEXER_IDENT_LITERAL, LEXER_LIT_LOCATION_IS_ASCII
        -: 2208:};
        -: 2209:
        -: 2210:/**
        -: 2211: * Create an unused literal.
        -: 2212: */
        -: 2213:static void
    #####: 2214:scanner_create_unused_literal (parser_context_t *context_p, /**< context */
        -: 2215:                               uint8_t status_flags) /**< initial status flags */
        -: 2216:{
    #####: 2217:  if (JERRY_UNLIKELY (context_p->literal_count >= PARSER_MAXIMUM_NUMBER_OF_LITERALS))
        -: 2218:  {
    #####: 2219:    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
        -: 2220:  }
        -: 2221:
    #####: 2222:  lexer_literal_t *literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
        -: 2223:
    #####: 2224:  literal_p->type = LEXER_UNUSED_LITERAL;
    #####: 2225:  literal_p->status_flags = status_flags;
        -: 2226:
    #####: 2227:  context_p->literal_count++;
    #####: 2228:} /* scanner_create_unused_literal */
        -: 2229:
        -: 2230:#if JERRY_ESNEXT
        -: 2231:/**
        -: 2232: * Emit checks for redeclared bindings in the global lexical scope.
        -: 2233: */
        -: 2234:void
        1: 2235:scanner_check_variables (parser_context_t *context_p) /**< context */
        -: 2236:{
        1: 2237:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        1: 2238:  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);
        1: 2239:  lexer_lit_location_t literal;
        -: 2240:
        1: 2241:  JERRY_ASSERT (info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2242:
        1: 2243:  literal.char_p = info_p->source_p - 1;
        -: 2244:
        5: 2245:  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2246:  {
        3: 2247:    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;
        3: 2248:    const uint8_t *data_p = next_data_p;
        -: 2249:
        3: 2250:    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_HOLE
        -: 2251:                  && !SCANNER_STREAM_TYPE_IS_ARG (type)
        -: 2252:                  && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type));
        3: 2253:    JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);
        -: 2254:
        3: 2255:    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 2256:    {
        3: 2257:      if (data_p[2] != 0)
        -: 2258:      {
        3: 2259:        literal.char_p += data_p[2];
        3: 2260:        next_data_p += 2 + 1;
        -: 2261:      }
        -: 2262:      else
        -: 2263:      {
    #####: 2264:        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (uintptr_t));
    #####: 2265:        next_data_p += 2 + 1 + sizeof (uintptr_t);
        -: 2266:      }
        -: 2267:    }
        -: 2268:    else
        -: 2269:    {
    #####: 2270:      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 2271:
    #####: 2272:      if (diff <= (intptr_t) UINT8_MAX)
        -: 2273:      {
    #####: 2274:        diff = -diff;
        -: 2275:      }
        -: 2276:
    #####: 2277:      literal.char_p += diff;
    #####: 2278:      next_data_p += 2 + 2;
        -: 2279:    }
        -: 2280:
        3: 2281:    literal.length = data_p[1];
        3: 2282:    literal.type = LEXER_IDENT_LITERAL;
        6: 2283:    literal.status_flags = ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE
        3: 2284:                                                                    : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2285:
        3: 2286:    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);
        3: 2287:    literal.char_p += data_p[1];
        -: 2288:
        -: 2289:#if JERRY_MODULE_SYSTEM
        3: 2290:    if (type == SCANNER_STREAM_TYPE_IMPORT)
        -: 2291:    {
    #####: 2292:      continue;
        -: 2293:    }
        -: 2294:#endif /* JERRY_MODULE_SYSTEM */
        -: 2295:
        3: 2296:    context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
        -: 2297:
        -: 2298:    uint16_t opcode;
        3: 2299:    if (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_FUNC)
        -: 2300:    {
        3: 2301:      opcode = CBC_CHECK_VAR;
        -: 2302:    }
        -: 2303:    else
        -: 2304:    {
    #####: 2305:      opcode = CBC_CHECK_LET;
        -: 2306:    }
        -: 2307:
        3: 2308:    parser_emit_cbc_literal (context_p, opcode, context_p->lit_object.index);
        -: 2309:  }
        -: 2310:
        1: 2311:  parser_flush_cbc (context_p);
        1: 2312:} /* scanner_check_variables */
        -: 2313:#endif /* JERRY_ESNEXT */
        -: 2314:
        -: 2315:/**
        -: 2316: * Create and/or initialize var/let/const/function/etc. variables.
        -: 2317: */
        -: 2318:void
        2: 2319:scanner_create_variables (parser_context_t *context_p, /**< context */
        -: 2320:                          uint32_t option_flags) /**< combination of scanner_create_variables_flags_t bits */
        -: 2321:{
        2: 2322:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        2: 2323:  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);
        2: 2324:  uint8_t info_type = info_p->type;
        2: 2325:  uint8_t info_u8_arg = info_p->u8_arg;
        2: 2326:  lexer_lit_location_t literal;
        -: 2327:  parser_scope_stack_t *scope_stack_p;
        -: 2328:  parser_scope_stack_t *scope_stack_end_p;
        -: 2329:
        2: 2330:  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION || info_type == SCANNER_TYPE_BLOCK);
        2: 2331:  JERRY_ASSERT (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
        -: 2332:                || !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY));
        2: 2333:  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION
        -: 2334:                || !(option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_ARGS | SCANNER_CREATE_VARS_IS_FUNCTION_BODY)));
        -: 2335:
        2: 2336:  if (info_type == SCANNER_TYPE_FUNCTION && !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))
        2: 2337:  {
        2: 2338:    JERRY_ASSERT (context_p->scope_stack_p == NULL);
        -: 2339:
        2: 2340:    size_t stack_size = info_p->u16_arg * sizeof (parser_scope_stack_t);
        2: 2341:    context_p->scope_stack_size = info_p->u16_arg;
        -: 2342:
        2: 2343:    scope_stack_p = NULL;
        -: 2344:
        2: 2345:    if (stack_size > 0)
        -: 2346:    {
        1: 2347:      scope_stack_p = (parser_scope_stack_t *) parser_malloc (context_p, stack_size);
        -: 2348:    }
        -: 2349:
        2: 2350:    context_p->scope_stack_p = scope_stack_p;
        2: 2351:    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;
        -: 2352:  }
        -: 2353:  else
        -: 2354:  {
    #####: 2355:    JERRY_ASSERT (context_p->scope_stack_p != NULL || context_p->scope_stack_size == 0);
        -: 2356:
    #####: 2357:    scope_stack_p = context_p->scope_stack_p;
    #####: 2358:    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;
    #####: 2359:    scope_stack_p += context_p->scope_stack_top;
        -: 2360:  }
        -: 2361:
        2: 2362:  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2363:
        2: 2364:  literal.char_p = info_p->source_p - 1;
        -: 2365:
        7: 2366:  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2367:  {
        3: 2368:    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;
        3: 2369:    const uint8_t *data_p = next_data_p;
        -: 2370:
        3: 2371:    JERRY_ASSERT ((option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_BODY | SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))
        -: 2372:                  || (type != SCANNER_STREAM_TYPE_HOLE
        -: 2373:                      && !SCANNER_STREAM_TYPE_IS_ARG (type)
        -: 2374:                      && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type)));
        -: 2375:
        -: 2376:#if JERRY_MODULE_SYSTEM
        3: 2377:    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_IMPORT || (data_p[0] & SCANNER_STREAM_NO_REG));
        -: 2378:#endif /* JERRY_MODULE_SYSTEM */
        -: 2379:
        3: 2380:    if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))
        -: 2381:    {
    #####: 2382:      JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);
    #####: 2383:      next_data_p++;
        -: 2384:
    #####: 2385:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2386:      {
    #####: 2387:        continue;
        -: 2388:      }
        -: 2389:
    #####: 2390:      uint8_t mask = SCANNER_FUNCTION_ARGUMENTS_NEEDED | SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 2391:
    #####: 2392:      if (!(context_p->status_flags & PARSER_IS_STRICT)
    #####: 2393:          && (info_u8_arg & mask) == SCANNER_FUNCTION_ARGUMENTS_NEEDED)
        -: 2394:      {
    #####: 2395:        scanner_create_unused_literal (context_p, LEXER_FLAG_FUNCTION_ARGUMENT);
        -: 2396:      }
        -: 2397:
    #####: 2398:      if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2399:      {
    #####: 2400:        scope_stack_reg_top++;
        -: 2401:      }
    #####: 2402:      continue;
        -: 2403:    }
        -: 2404:
        3: 2405:    if (JERRY_UNLIKELY (SCANNER_STREAM_TYPE_IS_ARGUMENTS (type)))
        -: 2406:    {
    #####: 2407:      JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);
    #####: 2408:      next_data_p++;
        -: 2409:
    #####: 2410:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2411:      {
    #####: 2412:        continue;
        -: 2413:      }
        -: 2414:
    #####: 2415:      context_p->status_flags |= PARSER_ARGUMENTS_NEEDED;
        -: 2416:
    #####: 2417:      if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2418:      {
    #####: 2419:        JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2420:        parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2421:      }
        -: 2422:
    #####: 2423:      lexer_construct_literal_object (context_p, &lexer_arguments_literal, LEXER_NEW_IDENT_LITERAL);
    #####: 2424:      scope_stack_p->map_from = context_p->lit_object.index;
        -: 2425:
        -: 2426:      uint16_t map_to;
        -: 2427:
    #####: 2428:      if (!(data_p[0] & SCANNER_STREAM_NO_REG)
    #####: 2429:          && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2430:      {
    #####: 2431:        map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);
        -: 2432:
        -: 2433:#if JERRY_ESNEXT
    #####: 2434:        scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);
        -: 2435:#endif /* JERRY_ESNEXT */
        -: 2436:
    #####: 2437:        scope_stack_reg_top++;
        -: 2438:      }
        -: 2439:      else
        -: 2440:      {
    #####: 2441:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
    #####: 2442:        map_to = context_p->lit_object.index;
        -: 2443:
    #####: 2444:        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2445:
        -: 2446:#if JERRY_ESNEXT
    #####: 2447:        if (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS)
        -: 2448:        {
    #####: 2449:          context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2450:        }
        -: 2451:
    #####: 2452:        scope_stack_p->map_to = 0;
        -: 2453:#endif /* JERRY_ESNEXT */
        -: 2454:      }
        -: 2455:
        -: 2456:#if !JERRY_ESNEXT
    #####: 2457:      scope_stack_p->map_to = map_to;
        -: 2458:#endif /* !JERRY_ESNEXT */
    #####: 2459:      scope_stack_p++;
        -: 2460:
        -: 2461:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2462:      context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2463:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2464:
    #####: 2465:      parser_emit_cbc_ext_literal (context_p, CBC_EXT_CREATE_ARGUMENTS, map_to);
        -: 2466:
        -: 2467:#if JERRY_ESNEXT
    #####: 2468:      if (type == SCANNER_STREAM_TYPE_ARGUMENTS_FUNC)
        -: 2469:      {
    #####: 2470:        if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2471:        {
    #####: 2472:          JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2473:          parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2474:        }
        -: 2475:
    #####: 2476:        scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;
    #####: 2477:        scope_stack_p->map_to = context_p->literal_count;
    #####: 2478:        scope_stack_p++;
        -: 2479:
    #####: 2480:        scanner_create_unused_literal (context_p, 0);
        -: 2481:      }
        -: 2482:#endif /* JERRY_ESNEXT */
        -: 2483:
    #####: 2484:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
        -: 2485:      {
    #####: 2486:        break;
        -: 2487:      }
    #####: 2488:      continue;
        -: 2489:    }
        -: 2490:
        3: 2491:    JERRY_ASSERT (context_p->scope_stack_size != 0);
        -: 2492:
        3: 2493:    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 2494:    {
        3: 2495:      if (data_p[2] != 0)
        -: 2496:      {
        3: 2497:        literal.char_p += data_p[2];
        3: 2498:        next_data_p += 2 + 1;
        -: 2499:      }
        -: 2500:      else
        -: 2501:      {
    #####: 2502:        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (uintptr_t));
    #####: 2503:        next_data_p += 2 + 1 + sizeof (uintptr_t);
        -: 2504:      }
        -: 2505:    }
        -: 2506:    else
        -: 2507:    {
    #####: 2508:      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 2509:
    #####: 2510:      if (diff <= (intptr_t) UINT8_MAX)
        -: 2511:      {
    #####: 2512:        diff = -diff;
        -: 2513:      }
        -: 2514:
    #####: 2515:      literal.char_p += diff;
    #####: 2516:      next_data_p += 2 + 2;
        -: 2517:    }
        -: 2518:
        3: 2519:    if (SCANNER_STREAM_TYPE_IS_ARG (type))
        -: 2520:    {
    #####: 2521:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2522:      {
        -: 2523:#if JERRY_ESNEXT
    #####: 2524:        if ((context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
    #####: 2525:            && (type == SCANNER_STREAM_TYPE_ARG_VAR || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR))
        -: 2526:        {
    #####: 2527:          literal.length = data_p[1];
    #####: 2528:          literal.type = LEXER_IDENT_LITERAL;
    #####: 2529:          literal.status_flags = ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE
    #####: 2530:                                                                          : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2531:
        -: 2532:          /* Literal must be exists. */
    #####: 2533:          lexer_construct_literal_object (context_p, &literal, LEXER_IDENT_LITERAL);
        -: 2534:
    #####: 2535:          if (context_p->lit_object.index < PARSER_REGISTER_START)
        -: 2536:          {
    #####: 2537:            parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_COPY_FROM_ARG);
        -: 2538:          }
        -: 2539:        }
        -: 2540:#endif /* JERRY_ESNEXT */
        -: 2541:
    #####: 2542:        literal.char_p += data_p[1];
    #####: 2543:        continue;
        -: 2544:      }
        -: 2545:    }
        3: 2546:    else if ((option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
    #####: 2547:             && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 2548:    {
        -: 2549:      /* Function arguments must come first. */
    #####: 2550:      break;
        -: 2551:    }
        -: 2552:
        3: 2553:    literal.length = data_p[1];
        3: 2554:    literal.type = LEXER_IDENT_LITERAL;
        6: 2555:    literal.status_flags = ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE
        3: 2556:                                                                    : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2557:
        3: 2558:    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);
        3: 2559:    literal.char_p += data_p[1];
        -: 2560:
        3: 2561:    if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type) && (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))
        -: 2562:    {
    #####: 2563:      JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p + 2);
    #####: 2564:      JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);
        -: 2565:#if JERRY_ESNEXT
    #####: 2566:      JERRY_ASSERT (!(context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS));
        -: 2567:#endif /* JERRY_ESNEXT */
        -: 2568:
    #####: 2569:      parser_scope_stack_t *function_map_p = scope_stack_p - 2;
    #####: 2570:      uint16_t literal_index = context_p->lit_object.index;
        -: 2571:
    #####: 2572:      while (literal_index != function_map_p->map_from)
        -: 2573:      {
    #####: 2574:        function_map_p--;
        -: 2575:
    #####: 2576:        JERRY_ASSERT (function_map_p >= context_p->scope_stack_p);
        -: 2577:      }
        -: 2578:
    #####: 2579:      JERRY_ASSERT (function_map_p[1].map_from == PARSER_SCOPE_STACK_FUNC);
        -: 2580:
    #####: 2581:      cbc_opcode_t opcode = CBC_SET_VAR_FUNC;
        -: 2582:
        -: 2583:#if JERRY_ESNEXT
    #####: 2584:      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
    #####: 2585:          && (function_map_p[0].map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0)
        -: 2586:      {
    #####: 2587:        opcode = CBC_INIT_ARG_OR_FUNC;
        -: 2588:      }
        -: 2589:#endif /* JERRY_ESNEXT */
        -: 2590:
    #####: 2591:      parser_emit_cbc_literal_value (context_p,
    #####: 2592:                                     (uint16_t) opcode,
    #####: 2593:                                     function_map_p[1].map_to,
    #####: 2594:                                     scanner_decode_map_to (function_map_p));
    #####: 2595:      continue;
        -: 2596:    }
        -: 2597:
        3: 2598:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2599:    {
    #####: 2600:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2601:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2602:    }
        -: 2603:
        3: 2604:    scope_stack_p->map_from = context_p->lit_object.index;
        -: 2605:
        -: 2606:#if JERRY_ESNEXT
        3: 2607:    if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2608:    {
        3: 2609:      if (type != SCANNER_STREAM_TYPE_LET
        -: 2610:#if JERRY_MODULE_SYSTEM
        3: 2611:          && type != SCANNER_STREAM_TYPE_IMPORT
        -: 2612:#endif /* JERRY_MODULE_SYSTEM */
        3: 2613:          && type != SCANNER_STREAM_TYPE_CONST)
        -: 2614:      {
        3: 2615:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_GLOBAL;
        -: 2616:      }
        -: 2617:    }
        -: 2618:#endif /* JERRY_ESNEXT */
        -: 2619:
        -: 2620:    uint16_t map_to;
        3: 2621:    uint16_t func_init_opcode = CBC_INIT_ARG_OR_FUNC;
        -: 2622:
        3: 2623:    if (!(data_p[0] & SCANNER_STREAM_NO_REG)
    #####: 2624:        && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2625:    {
    #####: 2626:      map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);
        -: 2627:
        -: 2628:#if JERRY_ESNEXT
    #####: 2629:      scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);
        -: 2630:#else /* !JERRY_ESNEXT */
    #####: 2631:      scope_stack_p->map_to = map_to;
        -: 2632:#endif /* JERRY_ESNEXT */
        -: 2633:
    #####: 2634:      scope_stack_reg_top++;
        -: 2635:#if JERRY_ESNEXT
    #####: 2636:      switch (type)
        -: 2637:      {
    #####: 2638:        case SCANNER_STREAM_TYPE_CONST:
        -: 2639:        {
    #####: 2640:          scope_stack_p->map_to |= PARSER_SCOPE_STACK_IS_CONST_REG;
        -: 2641:          /* FALLTHRU */
        -: 2642:        }
    #####: 2643:        case SCANNER_STREAM_TYPE_LET:
        -: 2644:        case SCANNER_STREAM_TYPE_ARG:
        -: 2645:        case SCANNER_STREAM_TYPE_ARG_VAR:
        -: 2646:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2647:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -: 2648:        case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 2649:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2650:        {
    #####: 2651:          scope_stack_p->map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
    #####: 2652:          break;
        -: 2653:        }
        -: 2654:      }
        -: 2655:
    #####: 2656:      func_init_opcode = CBC_SET_VAR_FUNC;
        -: 2657:#endif /* JERRY_ESNEXT */
        -: 2658:    }
        -: 2659:    else
        -: 2660:    {
        3: 2661:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
        3: 2662:      map_to = context_p->lit_object.index;
        -: 2663:
        -: 2664:#if JERRY_ESNEXT
        3: 2665:      uint16_t scope_stack_map_to = 0;
        -: 2666:#else /* !JERRY_ESNEXT */
    #####: 2667:      scope_stack_p->map_to = map_to;
        -: 2668:#endif /* JERRY_ESNEXT */
        -: 2669:
        3: 2670:      if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2671:      {
        3: 2672:        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2673:      }
        -: 2674:
        3: 2675:      switch (type)
        -: 2676:      {
        -: 2677:#if JERRY_ESNEXT
    #####: 2678:        case SCANNER_STREAM_TYPE_LET:
        -: 2679:        case SCANNER_STREAM_TYPE_CONST:
        -: 2680:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2681:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -: 2682:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2683:        {
    #####: 2684:          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        -: 2685:
    #####: 2686:          if (!(data_p[0] & SCANNER_STREAM_EARLY_CREATE))
        -: 2687:          {
    #####: 2688:            break;
        -: 2689:          }
    #####: 2690:          scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;
        -: 2691:          /* FALLTHRU */
        -: 2692:        }
        3: 2693:        case SCANNER_STREAM_TYPE_LOCAL:
        -: 2694:#endif /* JERRY_ESNEXT */
    #####: 2695:        case SCANNER_STREAM_TYPE_VAR:
        -: 2696:        {
        -: 2697:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2698:          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2699:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2700:
        -: 2701:#if JERRY_ESNEXT
        -: 2702:          uint16_t opcode;
        -: 2703:
        3: 2704:          switch (type)
        -: 2705:          {
    #####: 2706:            case SCANNER_STREAM_TYPE_LET:
        -: 2707:            {
    #####: 2708:              opcode = CBC_CREATE_LET;
    #####: 2709:              break;
        -: 2710:            }
    #####: 2711:            case SCANNER_STREAM_TYPE_CONST:
        -: 2712:            {
    #####: 2713:              opcode = CBC_CREATE_CONST;
    #####: 2714:              break;
        -: 2715:            }
        3: 2716:            case SCANNER_STREAM_TYPE_VAR:
        -: 2717:            {
        3: 2718:              opcode = CBC_CREATE_VAR;
        -: 2719:
        3: 2720:              if (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT)
        -: 2721:              {
        3: 2722:                opcode = CBC_CREATE_VAR_EVAL;
        -: 2723:
        3: 2724:                if ((context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
    #####: 2725:                    && !(context_p->status_flags & PARSER_IS_STRICT))
        -: 2726:                {
    #####: 2727:                  opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_CREATE_VAR_EVAL);
        -: 2728:                }
        -: 2729:              }
        3: 2730:              break;
        -: 2731:            }
    #####: 2732:            default:
        -: 2733:            {
    #####: 2734:              JERRY_ASSERT (type == SCANNER_STREAM_TYPE_LOCAL
        -: 2735:                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG
        -: 2736:                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR
        -: 2737:                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC);
        -: 2738:
    #####: 2739:              opcode = CBC_CREATE_LOCAL;
    #####: 2740:              break;
        -: 2741:            }
        -: 2742:          }
        -: 2743:#else /* !JERRY_ESNEXT */
    #####: 2744:          uint16_t opcode = ((option_flags & SCANNER_CREATE_VARS_IS_SCRIPT) ? CBC_CREATE_VAR_EVAL
        -: 2745:                                                                            : CBC_CREATE_VAR);
        -: 2746:#endif /* JERRY_ESNEXT */
        -: 2747:
        3: 2748:          parser_emit_cbc_literal (context_p, opcode, map_to);
        3: 2749:          break;
        -: 2750:        }
    #####: 2751:        case SCANNER_STREAM_TYPE_ARG:
        -: 2752:#if JERRY_ESNEXT
        -: 2753:        case SCANNER_STREAM_TYPE_ARG_VAR:
        -: 2754:#endif /* JERRY_ESNEXT */
        -: 2755:        case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 2756:        {
        -: 2757:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2758:          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2759:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2760:
        -: 2761:#if JERRY_ESNEXT
    #####: 2762:          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        -: 2763:
        -: 2764:          /* Argument initializers of functions with simple arguments (e.g. function f(a,b,a) {}) are
        -: 2765:           * generated here. The other initializers are handled by parser_parse_function_arguments(). */
    #####: 2766:          if (!(info_u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT))
        -: 2767:          {
        -: 2768:#endif /* JERRY_ESNEXT */
    #####: 2769:            parser_emit_cbc_literal_value (context_p,
        -: 2770:                                           CBC_INIT_ARG_OR_FUNC,
    #####: 2771:                                           (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top),
        -: 2772:                                           map_to);
        -: 2773:#if JERRY_ESNEXT
        -: 2774:          }
    #####: 2775:          else if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)
        -: 2776:          {
    #####: 2777:            parser_emit_cbc_literal (context_p, CBC_CREATE_LOCAL, map_to);
    #####: 2778:            scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;
        -: 2779:          }
        -: 2780:#endif /* JERRY_ESNEXT */
        -: 2781:
    #####: 2782:          if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2783:          {
    #####: 2784:            scope_stack_reg_top++;
        -: 2785:          }
    #####: 2786:          break;
        -: 2787:        }
        -: 2788:      }
        -: 2789:
        -: 2790:#if JERRY_ESNEXT
        3: 2791:      scope_stack_p->map_to = scope_stack_map_to;
        -: 2792:#endif /* JERRY_ESNEXT */
        -: 2793:    }
        -: 2794:
        3: 2795:    scope_stack_p++;
        -: 2796:
        3: 2797:    if (!SCANNER_STREAM_TYPE_IS_FUNCTION (type))
        -: 2798:    {
        3: 2799:      continue;
        -: 2800:    }
        -: 2801:
    #####: 2802:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2803:    {
    #####: 2804:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2805:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2806:    }
        -: 2807:
        -: 2808:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2809:    context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2810:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2811:
    #####: 2812:    if (!SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 2813:    {
    #####: 2814:      if (func_init_opcode == CBC_INIT_ARG_OR_FUNC && (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT))
        -: 2815:      {
        -: 2816:#if JERRY_ESNEXT
    #####: 2817:        literal.char_p -= data_p[1];
        -: 2818:
    #####: 2819:        if (!scanner_scope_find_lexical_declaration (context_p, &literal))
        -: 2820:        {
    #####: 2821:          func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;
        -: 2822:
    #####: 2823:          if (context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
        -: 2824:          {
    #####: 2825:            func_init_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_CREATE_VAR_FUNC_EVAL);
        -: 2826:          }
        -: 2827:        }
    #####: 2828:        literal.char_p += data_p[1];
        -: 2829:#else /* !JERRY_ESNEXT */
    #####: 2830:        func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;
        -: 2831:#endif /* JERRY_ESNEXT */
        -: 2832:      }
        -: 2833:
    #####: 2834:      parser_emit_cbc_literal_value (context_p, func_init_opcode, context_p->literal_count, map_to);
        -: 2835:    }
        -: 2836:
    #####: 2837:    scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;
    #####: 2838:    scope_stack_p->map_to = context_p->literal_count;
    #####: 2839:    scope_stack_p++;
        -: 2840:
    #####: 2841:    scanner_create_unused_literal (context_p, 0);
        -: 2842:  }
        -: 2843:
        2: 2844:  context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        2: 2845:  context_p->scope_stack_reg_top = (uint16_t) scope_stack_reg_top;
        -: 2846:
        -: 2847:#if JERRY_ESNEXT
        2: 2848:  if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2849:  {
        2: 2850:    context_p->scope_stack_global_end = context_p->scope_stack_top;
        -: 2851:  }
        -: 2852:#endif /* JERRY_ESNEXT */
        -: 2853:
        2: 2854:  if (context_p->register_count < scope_stack_reg_top)
        -: 2855:  {
    #####: 2856:    context_p->register_count = (uint16_t) scope_stack_reg_top;
        -: 2857:  }
        -: 2858:
        2: 2859:  if (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))
        -: 2860:  {
        2: 2861:    scanner_release_next (context_p, (size_t) (next_data_p + 1 - ((const uint8_t *) info_p)));
        -: 2862:  }
        2: 2863:  parser_flush_cbc (context_p);
        2: 2864:} /* scanner_create_variables */
        -: 2865:
        -: 2866:/**
        -: 2867: * Get location from context.
        -: 2868: */
        -: 2869:extern inline void JERRY_ATTR_ALWAYS_INLINE
        4: 2870:scanner_get_location (scanner_location_t *location_p, /**< location */
        -: 2871:                      parser_context_t *context_p) /**< context */
        -: 2872:{
        4: 2873:  location_p->source_p = context_p->source_p;
        4: 2874:  location_p->line = context_p->line;
        4: 2875:  location_p->column = context_p->column;
        4: 2876:} /* scanner_get_location */
        -: 2877:
        -: 2878:/**
        -: 2879: * Set context location.
        -: 2880: */
        -: 2881:extern inline void JERRY_ATTR_ALWAYS_INLINE
        4: 2882:scanner_set_location (parser_context_t *context_p, /**< context */
        -: 2883:                      scanner_location_t *location_p) /**< location */
        -: 2884:{
        4: 2885:  context_p->source_p = location_p->source_p;
        4: 2886:  context_p->line = location_p->line;
        4: 2887:  context_p->column = location_p->column;
        4: 2888:} /* scanner_set_location */
        -: 2889:
        -: 2890:/**
        -: 2891: * Get the real map_to value.
        -: 2892: */
        -: 2893:extern inline uint16_t JERRY_ATTR_ALWAYS_INLINE
       19: 2894:scanner_decode_map_to (parser_scope_stack_t *stack_item_p) /**< scope stack item */
        -: 2895:{
       19: 2896:  JERRY_ASSERT (stack_item_p->map_from != PARSER_SCOPE_STACK_FUNC);
        -: 2897:
        -: 2898:#if JERRY_ESNEXT
       19: 2899:  uint16_t value = (stack_item_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK);
       19: 2900:  return (value == 0) ? stack_item_p->map_from : (uint16_t) (value + (PARSER_REGISTER_START - 1));
        -: 2901:#else /* !JERRY_ESNEXT */
    #####: 2902:  return stack_item_p->map_to;
        -: 2903:#endif /* JERRY_ESNEXT */
        -: 2904:} /* scanner_decode_map_to */
        -: 2905:
        -: 2906:#if JERRY_ESNEXT
        -: 2907:
        -: 2908:/**
        -: 2909: * Find the given literal index in the scope stack
        -: 2910: * and save it the constant literal pool if the literal is register stored
        -: 2911: *
        -: 2912: * @return given literal index - if literal corresponds to this index is not register stored
        -: 2913: *         literal index on which literal index has been mapped - otherwise
        -: 2914: */
        -: 2915:uint16_t
    #####: 2916:scanner_save_literal (parser_context_t *context_p, /**< context */
        -: 2917:                      uint16_t literal_index) /**< literal index */
        -: 2918:{
    #####: 2919:  if (literal_index >= PARSER_REGISTER_START)
        -: 2920:  {
    #####: 2921:    literal_index = (uint16_t) (literal_index - (PARSER_REGISTER_START - 1));
        -: 2922:
    #####: 2923:    parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 2924:
        -: 2925:    do
        -: 2926:    {
        -: 2927:      /* Registers must be found in the scope stack. */
    #####: 2928:      JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
    #####: 2929:      scope_stack_p--;
        -: 2930:    }
    #####: 2931:    while (scope_stack_p->map_from == PARSER_SCOPE_STACK_FUNC
    #####: 2932:           || literal_index != (scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK));
        -: 2933:
    #####: 2934:    literal_index = scope_stack_p->map_from;
    #####: 2935:    PARSER_GET_LITERAL (literal_index)->status_flags |= LEXER_FLAG_USED;
        -: 2936:  }
        -: 2937:
    #####: 2938:  return literal_index;
        -: 2939:} /* scanner_save_literal */
        -: 2940:
        -: 2941:/**
        -: 2942: * Checks whether the literal is a const in the current scope.
        -: 2943: *
        -: 2944: * @return true if the literal is a const, false otherwise
        -: 2945: */
        -: 2946:bool
        1: 2947:scanner_literal_is_const_reg (parser_context_t *context_p, /**< context */
        -: 2948:                              uint16_t literal_index) /**< literal index */
        -: 2949:{
        1: 2950:  if (literal_index < PARSER_REGISTER_START)
        -: 2951:  {
        -: 2952:    /* Re-assignment of non-register const bindings are detected elsewhere. */
        1: 2953:    return false;
        -: 2954:  }
        -: 2955:
    #####: 2956:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 2957:
    #####: 2958:  literal_index = (uint16_t) (literal_index - (PARSER_REGISTER_START - 1));
        -: 2959:
        -: 2960:  do
        -: 2961:  {
        -: 2962:    /* Registers must be found in the scope stack. */
    #####: 2963:    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
    #####: 2964:    scope_stack_p--;
        -: 2965:  }
    #####: 2966:  while (scope_stack_p->map_from == PARSER_SCOPE_STACK_FUNC
    #####: 2967:         || literal_index != (scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK));
        -: 2968:
    #####: 2969:  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_CONST_REG) != 0;
        -: 2970:} /* scanner_literal_is_const_reg */
        -: 2971:
        -: 2972:/**
        -: 2973: * Checks whether the literal is created before.
        -: 2974: *
        -: 2975: * @return true if the literal is created before, false otherwise
        -: 2976: */
        -: 2977:bool
    #####: 2978:scanner_literal_is_created (parser_context_t *context_p, /**< context */
        -: 2979:                            uint16_t literal_index) /**< literal index */
        -: 2980:{
    #####: 2981:  JERRY_ASSERT (literal_index < PARSER_REGISTER_START);
        -: 2982:
    #####: 2983:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 2984:
        -: 2985:  do
        -: 2986:  {
        -: 2987:    /* These literals must be found in the scope stack. */
    #####: 2988:    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
    #####: 2989:    scope_stack_p--;
        -: 2990:  }
    #####: 2991:  while (literal_index != scope_stack_p->map_from);
        -: 2992:
    #####: 2993:  JERRY_ASSERT ((scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0);
        -: 2994:
    #####: 2995:  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_LOCAL_CREATED) != 0;
        -: 2996:} /* scanner_literal_is_created */
        -: 2997:
        -: 2998:/**
        -: 2999: * Checks whether the literal exists.
        -: 3000: *
        -: 3001: * @return true if the literal exists, false otherwise
        -: 3002: */
        -: 3003:bool
    #####: 3004:scanner_literal_exists (parser_context_t *context_p, /**< context */
        -: 3005:                        uint16_t literal_index) /**< literal index */
        -: 3006:{
    #####: 3007:  JERRY_ASSERT (literal_index < PARSER_REGISTER_START);
        -: 3008:
    #####: 3009:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 3010:
    #####: 3011:  while (scope_stack_p-- > context_p->scope_stack_p)
        -: 3012:  {
    #####: 3013:    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC
    #####: 3014:        && scanner_decode_map_to (scope_stack_p) == literal_index)
        -: 3015:    {
    #####: 3016:      return true;
        -: 3017:    }
        -: 3018:  }
        -: 3019:
    #####: 3020:  return false;
        -: 3021:} /* scanner_literal_exists */
        -: 3022:
        -: 3023:#endif /* JERRY_ESNEXT */
        -: 3024:
        -: 3025:/**
        -: 3026: * @}
        -: 3027: * @}
        -: 3028: * @}
        -: 3029: */
        -: 3030:
        -: 3031:#endif /* JERRY_PARSER */
