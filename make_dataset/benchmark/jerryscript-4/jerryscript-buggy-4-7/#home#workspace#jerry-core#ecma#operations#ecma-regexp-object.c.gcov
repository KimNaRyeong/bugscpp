        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-regexp-object.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-exceptions.h"
        -:   20:#include "ecma-gc.h"
        -:   21:#include "ecma-globals.h"
        -:   22:#include "ecma-objects.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-regexp-object.h"
        -:   25:#include "jcontext.h"
        -:   26:#include "jrt-libc-includes.h"
        -:   27:#include "lit-char-helpers.h"
        -:   28:#include "re-compiler.h"
        -:   29:
        -:   30:#if JERRY_BUILTIN_REGEXP
        -:   31:
        -:   32:#define ECMA_BUILTINS_INTERNAL
        -:   33:#include "ecma-builtins-internal.h"
        -:   34:
        -:   35:/** \addtogroup ecma ECMA
        -:   36: * @{
        -:   37: *
        -:   38: * \addtogroup ecmaregexpobject ECMA RegExp object related routines
        -:   39: * @{
        -:   40: */
        -:   41:
        -:   42:/**
        -:   43: * Index of the global capturing group
        -:   44: */
        -:   45:#define RE_GLOBAL_CAPTURE 0
        -:   46:
        -:   47:/**
        -:   48: * Parse RegExp flags (global, ignoreCase, multiline)
        -:   49: *
        -:   50: * See also: ECMA-262 v5, 15.10.4.1
        -:   51: *
        -:   52: * @return empty ecma value - if parsed successfully
        -:   53: *         error ecma value - otherwise
        -:   54: *
        -:   55: *         Returned value must be freed with ecma_free_value
        -:   56: */
        -:   57:ecma_value_t
    #####:   58:ecma_regexp_parse_flags (ecma_string_t *flags_str_p, /**< Input string with flags */
        -:   59:                         uint16_t *flags_p) /**< [out] parsed flag bits */
        -:   60:{
    #####:   61:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####:   62:  uint16_t result_flags = RE_FLAG_EMPTY;
        -:   63:
    #####:   64:  ECMA_STRING_TO_UTF8_STRING (flags_str_p, flags_start_p, flags_start_size);
        -:   65:
    #####:   66:  const lit_utf8_byte_t *flags_str_curr_p = flags_start_p;
    #####:   67:  const lit_utf8_byte_t *flags_str_end_p = flags_start_p + flags_start_size;
        -:   68:
    #####:   69:  while (flags_str_curr_p < flags_str_end_p)
        -:   70:  {
        -:   71:    ecma_regexp_flags_t flag;
    #####:   72:    switch (*flags_str_curr_p++)
        -:   73:    {
    #####:   74:      case 'g':
        -:   75:      {
    #####:   76:        flag = RE_FLAG_GLOBAL;
    #####:   77:        break;
        -:   78:      }
    #####:   79:      case 'i':
        -:   80:      {
    #####:   81:        flag = RE_FLAG_IGNORE_CASE;
    #####:   82:        break;
        -:   83:      }
    #####:   84:      case 'm':
        -:   85:      {
    #####:   86:        flag = RE_FLAG_MULTILINE;
    #####:   87:        break;
        -:   88:      }
    #####:   89:      case 'y':
        -:   90:      {
    #####:   91:        flag = RE_FLAG_STICKY;
    #####:   92:        break;
        -:   93:      }
    #####:   94:      case 'u':
        -:   95:      {
    #####:   96:        flag = RE_FLAG_UNICODE;
    #####:   97:        break;
        -:   98:      }
        -:   99:#if JERRY_ESNEXT
    #####:  100:      case 's':
        -:  101:      {
    #####:  102:        flag = RE_FLAG_DOTALL;
    #####:  103:        break;
        -:  104:      }
        -:  105:#endif /* JERRY_ESNEXT */
    #####:  106:      default:
        -:  107:      {
    #####:  108:        flag = RE_FLAG_EMPTY;
    #####:  109:        break;
        -:  110:      }
        -:  111:    }
        -:  112:
    #####:  113:    if (flag == RE_FLAG_EMPTY || (result_flags & flag) != 0)
        -:  114:    {
    #####:  115:      ret_value = ecma_raise_syntax_error (ECMA_ERR_MSG ("Invalid RegExp flags"));
    #####:  116:      break;
        -:  117:    }
        -:  118:
    #####:  119:    result_flags = (uint16_t) (result_flags | flag);
        -:  120:  }
        -:  121:
    #####:  122:  ECMA_FINALIZE_UTF8_STRING (flags_start_p, flags_start_size);
        -:  123:
    #####:  124:  *flags_p = result_flags;
    #####:  125:  return ret_value;
        -:  126:} /* ecma_regexp_parse_flags */
        -:  127:
        -:  128:#if !JERRY_ESNEXT
        -:  129:/*
        -:  130: * Create the properties of a RegExp instance.
        -:  131: */
        -:  132:static void
    #####:  133:ecma_regexp_create_props (ecma_object_t *re_object_p, /**< RegExp object */
        -:  134:                          ecma_string_t *source_p, /**< source string */
        -:  135:                          uint16_t flags) /**< flags */
        -:  136:{
        -:  137:  ecma_property_value_t *prop_value_p;
        -:  138:
    #####:  139:  prop_value_p = ecma_create_named_data_property (re_object_p,
        -:  140:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_SOURCE),
        -:  141:                                                  ECMA_PROPERTY_FIXED,
        -:  142:                                                  NULL);
        -:  143:
    #####:  144:  ecma_ref_ecma_string (source_p);
    #####:  145:  prop_value_p->value = ecma_make_string_value (source_p);
        -:  146:
    #####:  147:  prop_value_p = ecma_create_named_data_property (re_object_p,
        -:  148:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_GLOBAL),
        -:  149:                                                  ECMA_PROPERTY_FIXED,
        -:  150:                                                  NULL);
        -:  151:
    #####:  152:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_GLOBAL);
        -:  153:
    #####:  154:  prop_value_p = ecma_create_named_data_property (re_object_p,
        -:  155:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_IGNORECASE_UL),
        -:  156:                                                  ECMA_PROPERTY_FIXED,
        -:  157:                                                  NULL);
        -:  158:
    #####:  159:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_IGNORE_CASE);
        -:  160:
    #####:  161:  prop_value_p = ecma_create_named_data_property (re_object_p,
        -:  162:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_MULTILINE),
        -:  163:                                                  ECMA_PROPERTY_FIXED,
        -:  164:                                                  NULL);
        -:  165:
    #####:  166:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_MULTILINE);
    #####:  167:} /* ecma_regexp_create_props */
        -:  168:
        -:  169:/*
        -:  170: * Update the properties of a RegExp instance.
        -:  171: */
        -:  172:static void
    #####:  173:ecma_regexp_update_props (ecma_object_t *re_object_p, /**< RegExp object */
        -:  174:                          ecma_string_t *source_p, /**< source string */
        -:  175:                          uint16_t flags) /**< flags */
        -:  176:{
        -:  177:  ecma_property_t *prop_p;
        -:  178:
    #####:  179:  prop_p = ecma_find_named_property (re_object_p, ecma_get_magic_string (LIT_MAGIC_STRING_SOURCE));
        -:  180:  JERRY_ASSERT (prop_p != NULL);
    #####:  181:  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  182:  ecma_free_value (prop_value_p->value);
    #####:  183:  ecma_ref_ecma_string (source_p);
    #####:  184:  prop_value_p->value = ecma_make_string_value (source_p);
        -:  185:
    #####:  186:  prop_p = ecma_find_named_property (re_object_p, ecma_get_magic_string (LIT_MAGIC_STRING_GLOBAL));
        -:  187:  JERRY_ASSERT (prop_p != NULL);
    #####:  188:  prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  189:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_GLOBAL);
        -:  190:
    #####:  191:  prop_p = ecma_find_named_property (re_object_p, ecma_get_magic_string (LIT_MAGIC_STRING_IGNORECASE_UL));
        -:  192:  JERRY_ASSERT (prop_p != NULL);
    #####:  193:  prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  194:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_IGNORE_CASE);
        -:  195:
    #####:  196:  prop_p = ecma_find_named_property (re_object_p, ecma_get_magic_string (LIT_MAGIC_STRING_MULTILINE));
        -:  197:  JERRY_ASSERT (prop_p != NULL);
    #####:  198:  prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  199:  prop_value_p->value = ecma_make_boolean_value (flags & RE_FLAG_MULTILINE);
    #####:  200:} /* ecma_regexp_update_props */
        -:  201:#endif /* !JERRY_ESNEXT */
        -:  202:
        -:  203:/**
        -:  204: * RegExpAlloc method
        -:  205: *
        -:  206: * See also: ECMA-262 v5, 15.10.4.1
        -:  207: *           ECMA-262 v6, 21.2.3.2.1
        -:  208: *
        -:  209: * Note:
        -:  210: *      Returned value must be freed with ecma_free_value.
        -:  211: *
        -:  212: * @return ecma_object_t
        -:  213: */
        -:  214:ecma_object_t *
    #####:  215:ecma_op_regexp_alloc (ecma_object_t *ctr_obj_p) /**< constructor object pointer */
        -:  216:{
        -:  217:#if JERRY_ESNEXT
    #####:  218:  if (ctr_obj_p == NULL)
        -:  219:  {
    #####:  220:    ctr_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP);
        -:  221:  }
        -:  222:
    #####:  223:  ecma_object_t *proto_obj_p = ecma_op_get_prototype_from_constructor (ctr_obj_p,
        -:  224:                                                                       ECMA_BUILTIN_ID_REGEXP_PROTOTYPE);
        -:  225:
    #####:  226:  if (JERRY_UNLIKELY (proto_obj_p == NULL))
        -:  227:  {
    #####:  228:    return proto_obj_p;
        -:  229:  }
        -:  230:
        -:  231:#else /* !JERRY_ESNEXT */
        -:  232:  JERRY_UNUSED (ctr_obj_p);
    #####:  233:  ecma_object_t *proto_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE);
        -:  234:#endif /* JERRY_ESNEXT */
        -:  235:
    #####:  236:  ecma_object_t *new_object_p = ecma_create_object (proto_obj_p,
        -:  237:                                                    sizeof (ecma_extended_object_t),
        -:  238:                                                    ECMA_OBJECT_TYPE_CLASS);
        -:  239:
        -:  240:#if JERRY_ESNEXT
    #####:  241:  ecma_deref_object (proto_obj_p);
        -:  242:#endif /* JERRY_ESNEXT */
        -:  243:
    #####:  244:  ecma_extended_object_t *regexp_obj_p = (ecma_extended_object_t *) new_object_p;
        -:  245:
        -:  246:  /* Class id will be initialized after the bytecode is compiled. */
    #####:  247:  regexp_obj_p->u.cls.type = ECMA_OBJECT_CLASS__MAX;
        -:  248:
    #####:  249:  ecma_value_t status = ecma_builtin_helper_def_prop (new_object_p,
        -:  250:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -:  251:                                                      ecma_make_uint32_value (0),
        -:  252:                                                      ECMA_PROPERTY_FLAG_WRITABLE | JERRY_PROP_SHOULD_THROW);
        -:  253:
    #####:  254:  JERRY_ASSERT (ecma_is_value_true (status));
        -:  255:
    #####:  256:  return new_object_p;
        -:  257:} /* ecma_op_regexp_alloc */
        -:  258:
        -:  259:/**
        -:  260: * Helper method for initializing an aready existing RegExp object.
        -:  261: */
        -:  262:static void
    #####:  263:ecma_op_regexp_initialize (ecma_object_t *regexp_obj_p, /**< RegExp object */
        -:  264:                           const re_compiled_code_t *bc_p, /**< bytecode */
        -:  265:                           ecma_string_t *pattern_str_p, /**< pattern */
        -:  266:                           uint16_t flags) /**< flags */
        -:  267:{
    #####:  268:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) regexp_obj_p;
        -:  269:
        -:  270:#if !JERRY_ESNEXT
    #####:  271:  if (ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS__MAX)
        -:  272:  {
        -:  273:    /* This instance has not been initialized before. */
    #####:  274:    ecma_regexp_create_props (regexp_obj_p, pattern_str_p, flags);
        -:  275:  }
        -:  276:  else
        -:  277:  {
    #####:  278:    ecma_regexp_update_props (regexp_obj_p, pattern_str_p, flags);
        -:  279:  }
        -:  280:#endif /* !JERRY_ESNEXT */
        -:  281:
        -:  282:#if JERRY_ESNEXT
        -:  283:  JERRY_UNUSED (pattern_str_p);
        -:  284:  JERRY_UNUSED (flags);
        -:  285:#endif /* JERRY_ESNEXT */
        -:  286:
    #####:  287:  ext_obj_p->u.cls.type = ECMA_OBJECT_CLASS_REGEXP;
    #####:  288:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_obj_p->u.cls.u3.value, bc_p);
    #####:  289:} /* ecma_op_regexp_initialize */
        -:  290:
        -:  291:/**
        -:  292: * Method for creating a RegExp object from pattern.
        -:  293: *
        -:  294: * Note:
        -:  295: *      Allocation have to happen before invoking this function using ecma_op_regexp_alloc.
        -:  296: *
        -:  297: * @return ecma_value_t
        -:  298: */
        -:  299:ecma_value_t
    #####:  300:ecma_op_create_regexp_from_pattern (ecma_object_t *regexp_obj_p, /**< RegExp object */
        -:  301:                                    ecma_value_t pattern_value, /**< pattern */
        -:  302:                                    ecma_value_t flags_value) /**< flags */
        -:  303:{
    #####:  304:  ecma_string_t *pattern_str_p = ecma_regexp_read_pattern_str_helper (pattern_value);
    #####:  305:  uint16_t flags = 0;
        -:  306:
    #####:  307:  if (JERRY_UNLIKELY (pattern_str_p == NULL))
        -:  308:  {
    #####:  309:    return ECMA_VALUE_ERROR;
        -:  310:  }
        -:  311:
    #####:  312:  if (!ecma_is_value_undefined (flags_value))
        -:  313:  {
    #####:  314:    ecma_string_t *flags_str_p = ecma_op_to_string (flags_value);
        -:  315:
    #####:  316:    if (JERRY_UNLIKELY (flags_str_p == NULL))
        -:  317:    {
    #####:  318:      ecma_deref_ecma_string (pattern_str_p);
    #####:  319:      return ECMA_VALUE_ERROR;
        -:  320:    }
        -:  321:
    #####:  322:    ecma_value_t parse_flags_value = ecma_regexp_parse_flags (flags_str_p, &flags);
    #####:  323:    ecma_deref_ecma_string (flags_str_p);
        -:  324:
    #####:  325:    if (ECMA_IS_VALUE_ERROR (parse_flags_value))
        -:  326:    {
    #####:  327:      ecma_deref_ecma_string (pattern_str_p);
    #####:  328:      return parse_flags_value;
        -:  329:    }
        -:  330:
    #####:  331:    JERRY_ASSERT (ecma_is_value_empty (parse_flags_value));
        -:  332:  }
        -:  333:
    #####:  334:  re_compiled_code_t *bc_p = re_compile_bytecode (pattern_str_p, flags);
        -:  335:
    #####:  336:  if (JERRY_UNLIKELY (bc_p == NULL))
        -:  337:  {
    #####:  338:    ecma_deref_ecma_string (pattern_str_p);
    #####:  339:    return ECMA_VALUE_ERROR;
        -:  340:  }
        -:  341:
    #####:  342:  ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
    #####:  343:  ecma_deref_ecma_string (pattern_str_p);
        -:  344:
    #####:  345:  return ecma_make_object_value (regexp_obj_p);
        -:  346:} /* ecma_op_create_regexp_from_pattern */
        -:  347:
        -:  348:/**
        -:  349: * Method for creating a RegExp object from bytecode.
        -:  350: *
        -:  351: * Note:
        -:  352: *      Allocation have to happen before invoking this function using ecma_op_regexp_alloc.
        -:  353: *
        -:  354: * @return ecma_value_t
        -:  355: */
        -:  356:ecma_value_t
    #####:  357:ecma_op_create_regexp_from_bytecode (ecma_object_t *regexp_obj_p, /**< RegExp object */
        -:  358:                                     re_compiled_code_t *bc_p) /**< bytecode */
        -:  359:{
    #####:  360:  ecma_bytecode_ref ((ecma_compiled_code_t *) bc_p);
    #####:  361:  ecma_string_t *pattern_str_p = ecma_get_string_from_value (bc_p->source);
    #####:  362:  uint16_t flags = bc_p->header.status_flags;
        -:  363:
    #####:  364:  ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
        -:  365:
    #####:  366:  return ecma_make_object_value (regexp_obj_p);
        -:  367:} /* ecma_op_create_regexp_from_bytecode */
        -:  368:
        -:  369:/**
        -:  370: * Method for creating a RegExp object from pattern with already parsed flags.
        -:  371: *
        -:  372: * Note:
        -:  373: *      Allocation have to happen before invoking this function using ecma_op_regexp_alloc.
        -:  374: *
        -:  375: * @return ecma_value_t
        -:  376: */
        -:  377:ecma_value_t
    #####:  378:ecma_op_create_regexp_with_flags (ecma_object_t *regexp_obj_p, /**< RegExp object */
        -:  379:                                  ecma_value_t pattern_value, /**< pattern */
        -:  380:                                  uint16_t flags) /**< flags */
        -:  381:{
    #####:  382:  ecma_string_t *pattern_str_p = ecma_regexp_read_pattern_str_helper (pattern_value);
        -:  383:
    #####:  384:  if (JERRY_UNLIKELY (pattern_str_p == NULL))
        -:  385:  {
    #####:  386:    return ECMA_VALUE_ERROR;
        -:  387:  }
        -:  388:
    #####:  389:  re_compiled_code_t *bc_p = re_compile_bytecode (pattern_str_p, flags);
    #####:  390:  ecma_deref_ecma_string (pattern_str_p);
        -:  391:
    #####:  392:  if (JERRY_UNLIKELY (bc_p == NULL))
        -:  393:  {
    #####:  394:    return ECMA_VALUE_ERROR;
        -:  395:  }
        -:  396:
    #####:  397:  ecma_op_regexp_initialize (regexp_obj_p, bc_p, pattern_str_p, flags);
        -:  398:
    #####:  399:  return ecma_make_object_value (regexp_obj_p);
        -:  400:} /* ecma_op_create_regexp_with_flags */
        -:  401:
        -:  402:/**
        -:  403: * Canonicalize a character
        -:  404: *
        -:  405: * @return ecma_char_t canonicalized character
        -:  406: */
        -:  407:lit_code_point_t
    #####:  408:ecma_regexp_canonicalize_char (lit_code_point_t ch, /**< character */
        -:  409:                               bool unicode) /**< unicode */
        -:  410:{
        -:  411:#if JERRY_ESNEXT
    #####:  412:  if (unicode)
        -:  413:  {
        -:  414:    /* In unicode mode the mappings contained in the CaseFolding.txt file should be used to canonicalize the character.
        -:  415:     * These mappings generally correspond to the lowercase variant of the character, however there are some
        -:  416:     * differences. In some cases the uppercase variant is used, in others the lowercase of the uppercase character is
        -:  417:     * used, and there are also cases where the character has no case folding mapping even though it has upper/lower
        -:  418:     * variants. Since lowercasing is the most common this is used as the default behaviour, and characters with
        -:  419:     * differing behaviours are encoded in lookup tables. */
        -:  420:
    #####:  421:    if (lit_char_fold_to_upper (ch))
        -:  422:    {
    #####:  423:      ch = lit_char_to_upper_case (ch, NULL);
    #####:  424:      JERRY_ASSERT (ch != LIT_MULTIPLE_CU);
        -:  425:    }
        -:  426:
    #####:  427:    if (lit_char_fold_to_lower (ch))
        -:  428:    {
    #####:  429:      ch = lit_char_to_lower_case (ch, NULL);
    #####:  430:      JERRY_ASSERT (ch != LIT_MULTIPLE_CU);
        -:  431:    }
        -:  432:
    #####:  433:    return ch;
        -:  434:  }
        -:  435:#endif /* !JERRY_ESNEXT */
        -:  436:
        -:  437:  JERRY_UNUSED (unicode);
    #####:  438:  lit_code_point_t cu = lit_char_to_upper_case (ch, NULL);
        -:  439:
    #####:  440:  if (ch <= LIT_UTF8_1_BYTE_CODE_POINT_MAX
    #####:  441:      || (cu > LIT_UTF8_1_BYTE_CODE_POINT_MAX
    #####:  442:          && cu != LIT_MULTIPLE_CU))
        -:  443:  {
    #####:  444:    return cu;
        -:  445:  }
        -:  446:
    #####:  447:  return ch;
        -:  448:} /* ecma_regexp_canonicalize_char */
        -:  449:
        -:  450:/**
        -:  451: * RegExp Canonicalize abstract operation
        -:  452: *
        -:  453: * See also: ECMA-262 v5, 15.10.2.8
        -:  454: *
        -:  455: * @return ecma_char_t canonicalized character
        -:  456: */
        -:  457:static inline lit_code_point_t JERRY_ATTR_ALWAYS_INLINE
        -:  458:ecma_regexp_canonicalize (lit_code_point_t ch, /**< character */
        -:  459:                          uint16_t flags) /**< flags */
        -:  460:{
    #####:  461:  if (flags & RE_FLAG_IGNORE_CASE)
        -:  462:  {
    #####:  463:    return ecma_regexp_canonicalize_char (ch, flags & RE_FLAG_UNICODE);
        -:  464:  }
        -:  465:
    #####:  466:  return ch;
        -:  467:} /* ecma_regexp_canonicalize */
        -:  468:
        -:  469:/**
        -:  470: * Check if a code point is matched by a class escape.
        -:  471: *
        -:  472: * @return true, if code point matches escape
        -:  473: *         false, otherwise
        -:  474: */
        -:  475:static bool
    #####:  476:ecma_regexp_check_class_escape (lit_code_point_t cp, /**< char */
        -:  477:                                ecma_class_escape_t escape) /**< escape */
        -:  478:{
    #####:  479:  switch (escape)
        -:  480:  {
    #####:  481:    case RE_ESCAPE_DIGIT:
        -:  482:    {
    #####:  483:      return (cp >= LIT_CHAR_0 && cp <= LIT_CHAR_9);
        -:  484:    }
    #####:  485:    case RE_ESCAPE_NOT_DIGIT:
        -:  486:    {
    #####:  487:      return (cp < LIT_CHAR_0 || cp > LIT_CHAR_9);
        -:  488:    }
    #####:  489:    case RE_ESCAPE_WORD_CHAR:
        -:  490:    {
    #####:  491:      return lit_char_is_word_char (cp);
        -:  492:    }
    #####:  493:    case RE_ESCAPE_NOT_WORD_CHAR:
        -:  494:    {
    #####:  495:      return !lit_char_is_word_char (cp);
        -:  496:    }
    #####:  497:    case RE_ESCAPE_WHITESPACE:
        -:  498:    {
    #####:  499:      return lit_char_is_white_space ((ecma_char_t) cp);
        -:  500:    }
    #####:  501:    case RE_ESCAPE_NOT_WHITESPACE:
        -:  502:    {
    #####:  503:      return !lit_char_is_white_space ((ecma_char_t) cp);
        -:  504:    }
    #####:  505:    default:
        -:  506:    {
    #####:  507:      JERRY_UNREACHABLE ();
        -:  508:    }
        -:  509:  }
        -:  510:} /* ecma_regexp_check_class_escape */
        -:  511:
        -:  512:/**
        -:  513: * Helper function to get current code point or code unit depending on execution mode,
        -:  514: * and advance the string pointer.
        -:  515: *
        -:  516: * @return lit_code_point_t current code point
        -:  517: */
        -:  518:static lit_code_point_t
    #####:  519:ecma_regexp_advance (ecma_regexp_ctx_t *re_ctx_p, /**< regexp context */
        -:  520:                     const lit_utf8_byte_t **str_p) /**< reference to string pointer */
        -:  521:{
    #####:  522:  JERRY_ASSERT (str_p != NULL);
    #####:  523:  lit_code_point_t cp = lit_cesu8_read_next (str_p);
        -:  524:
        -:  525:#if JERRY_ESNEXT
    #####:  526:  if (JERRY_UNLIKELY (re_ctx_p->flags & RE_FLAG_UNICODE)
    #####:  527:      && lit_is_code_point_utf16_high_surrogate ((ecma_char_t) cp)
    #####:  528:      && *str_p < re_ctx_p->input_end_p)
        -:  529:  {
    #####:  530:    const ecma_char_t next_ch = lit_cesu8_peek_next (*str_p);
    #####:  531:    if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -:  532:    {
    #####:  533:      cp = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) cp, next_ch);
    #####:  534:      *str_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  535:    }
        -:  536:  }
        -:  537:#endif /* JERRY_ESNEXT */
        -:  538:
    #####:  539:  return ecma_regexp_canonicalize (cp, re_ctx_p->flags);
        -:  540:} /* ecma_regexp_advance */
        -:  541:
        -:  542:#if JERRY_ESNEXT
        -:  543:/**
        -:  544: * Helper function to get current full unicode code point and advance the string pointer.
        -:  545: *
        -:  546: * @return lit_code_point_t current code point
        -:  547: */
        -:  548:lit_code_point_t
    #####:  549:ecma_regexp_unicode_advance (const lit_utf8_byte_t **str_p, /**< reference to string pointer */
        -:  550:                             const lit_utf8_byte_t *end_p) /**< string end pointer */
        -:  551:{
    #####:  552:  JERRY_ASSERT (str_p != NULL);
    #####:  553:  const lit_utf8_byte_t *current_p = *str_p;
        -:  554:
    #####:  555:  lit_code_point_t ch = lit_cesu8_read_next (&current_p);
    #####:  556:  if (lit_is_code_point_utf16_high_surrogate ((ecma_char_t) ch)
    #####:  557:      && current_p < end_p)
        -:  558:  {
    #####:  559:    const ecma_char_t next_ch = lit_cesu8_peek_next (current_p);
    #####:  560:    if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -:  561:    {
    #####:  562:      ch = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) ch, next_ch);
    #####:  563:      current_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  564:    }
        -:  565:  }
        -:  566:
    #####:  567:  *str_p = current_p;
    #####:  568:  return ch;
        -:  569:} /* ecma_regexp_unicode_advance */
        -:  570:#endif /* JERRY_ESNEXT */
        -:  571:
        -:  572:/**
        -:  573: * Helper function to revert the string pointer to the previous code point.
        -:  574: *
        -:  575: * @return pointer to previous code point
        -:  576: */
        -:  577:static JERRY_ATTR_NOINLINE const lit_utf8_byte_t *
    #####:  578:ecma_regexp_step_back (ecma_regexp_ctx_t *re_ctx_p, /**< regexp context */
        -:  579:                       const lit_utf8_byte_t *str_p) /**< reference to string pointer */
        -:  580:{
    #####:  581:  JERRY_ASSERT (str_p != NULL);
        -:  582:#if JERRY_ESNEXT
    #####:  583:  lit_code_point_t ch = lit_cesu8_read_prev (&str_p);
    #####:  584:  if (JERRY_UNLIKELY (re_ctx_p->flags & RE_FLAG_UNICODE)
    #####:  585:      && lit_is_code_point_utf16_low_surrogate (ch)
    #####:  586:      && lit_is_code_point_utf16_high_surrogate (lit_cesu8_peek_prev (str_p)))
        -:  587:  {
    #####:  588:    str_p -= LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -:  589:  }
        -:  590:#else /* !JERRY_ESNEXT */
        -:  591:  JERRY_UNUSED (re_ctx_p);
    #####:  592:  lit_utf8_decr (&str_p);
        -:  593:#endif /* !JERRY_ESNEXT */
    #####:  594:  return str_p;
        -:  595:} /* ecma_regexp_step_back */
        -:  596:
        -:  597:/**
        -:  598: * Check if the current poisition is on a word boundary.
        -:  599: *
        -:  600: * @return true, if on a word boundary
        -:  601: *         false - otherwise
        -:  602: */
        -:  603:static bool
    #####:  604:ecma_regexp_is_word_boundary (ecma_regexp_ctx_t *re_ctx_p, /**< regexp context */
        -:  605:                              const lit_utf8_byte_t *str_p) /**< string pointer */
        -:  606:{
        -:  607:  lit_code_point_t left_cp;
        -:  608:  lit_code_point_t right_cp;
        -:  609:
    #####:  610:  if (JERRY_UNLIKELY (str_p <= re_ctx_p->input_start_p))
        -:  611:  {
    #####:  612:    left_cp = LIT_INVALID_CP;
        -:  613:  }
        -:  614:#if JERRY_ESNEXT
    #####:  615:  else if (JERRY_UNLIKELY ((re_ctx_p->flags & (RE_FLAG_UNICODE | RE_FLAG_IGNORE_CASE))
        -:  616:                           == (RE_FLAG_UNICODE | RE_FLAG_IGNORE_CASE)))
        -:  617:  {
    #####:  618:    const lit_utf8_byte_t *prev_p = ecma_regexp_step_back (re_ctx_p, str_p);
    #####:  619:    left_cp = ecma_regexp_advance (re_ctx_p, &prev_p);
    #####:  620:    JERRY_ASSERT (prev_p == str_p);
        -:  621:  }
        -:  622:#endif /* JERRY_ESNEXT */
        -:  623:  else
        -:  624:  {
    #####:  625:    left_cp = str_p[-1];
        -:  626:  }
        -:  627:
    #####:  628:  if (JERRY_UNLIKELY (str_p >= re_ctx_p->input_end_p))
        -:  629:  {
    #####:  630:    right_cp = LIT_INVALID_CP;
        -:  631:  }
        -:  632:#if JERRY_ESNEXT
    #####:  633:  else if (JERRY_UNLIKELY ((re_ctx_p->flags & (RE_FLAG_UNICODE | RE_FLAG_IGNORE_CASE))
        -:  634:                           == (RE_FLAG_UNICODE | RE_FLAG_IGNORE_CASE)))
        -:  635:  {
    #####:  636:    right_cp = ecma_regexp_advance (re_ctx_p, &str_p);
        -:  637:  }
        -:  638:#endif /* JERRY_ESNEXT */
        -:  639:  else
        -:  640:  {
    #####:  641:    right_cp = str_p[0];
        -:  642:  }
        -:  643:
    #####:  644:  return lit_char_is_word_char (left_cp) != lit_char_is_word_char (right_cp);
        -:  645:} /* ecma_regexp_is_word_boundary */
        -:  646:
        -:  647:/**
        -:  648: * Recursive function for executing RegExp bytecode.
        -:  649: *
        -:  650: * See also:
        -:  651: *          ECMA-262 v5, 15.10.2.1
        -:  652: *
        -:  653: * @return pointer to the end of the currently matched substring
        -:  654: *         NULL, if pattern did not match
        -:  655: */
        -:  656:static const lit_utf8_byte_t *
    #####:  657:ecma_regexp_run (ecma_regexp_ctx_t *re_ctx_p, /**< RegExp matcher context */
        -:  658:                 const uint8_t *bc_p, /**< pointer to the current RegExp bytecode */
        -:  659:                 const lit_utf8_byte_t *str_curr_p) /**< input string pointer */
        -:  660:{
        -:  661:#if (JERRY_STACK_LIMIT != 0)
        -:  662:  if (JERRY_UNLIKELY (ecma_get_current_stack_usage () > CONFIG_MEM_STACK_LIMIT))
        -:  663:  {
        -:  664:    return ECMA_RE_OUT_OF_STACK;
        -:  665:  }
        -:  666:#endif /* JERRY_STACK_LIMIT != 0 */
        -:  667:
    #####:  668:  const lit_utf8_byte_t *str_start_p = str_curr_p;
    #####:  669:  const uint8_t *next_alternative_p = NULL;
        -:  670:
        -:  671:  while (true)
    #####:  672:  {
    #####:  673:    const re_opcode_t op = re_get_opcode (&bc_p);
        -:  674:
    #####:  675:    switch (op)
        -:  676:    {
    #####:  677:      case RE_OP_EOF:
        -:  678:      {
    #####:  679:        re_ctx_p->captures_p[RE_GLOBAL_CAPTURE].end_p = str_curr_p;
        -:  680:        /* FALLTHRU */
        -:  681:      }
    #####:  682:      case RE_OP_ASSERT_END:
        -:  683:      case RE_OP_ITERATOR_END:
        -:  684:      {
    #####:  685:        return str_curr_p;
        -:  686:      }
    #####:  687:      case RE_OP_ALTERNATIVE_START:
        -:  688:      {
    #####:  689:        const uint32_t offset = re_get_value (&bc_p);
    #####:  690:        next_alternative_p = bc_p + offset;
    #####:  691:        continue;
        -:  692:      }
    #####:  693:      case RE_OP_ALTERNATIVE_NEXT:
        -:  694:      {
        -:  695:        while (true)
    #####:  696:        {
    #####:  697:          const uint32_t offset = re_get_value (&bc_p);
    #####:  698:          bc_p += offset;
        -:  699:
    #####:  700:          if (*bc_p != RE_OP_ALTERNATIVE_NEXT)
        -:  701:          {
    #####:  702:            break;
        -:  703:          }
        -:  704:
    #####:  705:          bc_p++;
        -:  706:        }
        -:  707:
    #####:  708:        continue;
        -:  709:      }
    #####:  710:      case RE_OP_NO_ALTERNATIVE:
        -:  711:      {
    #####:  712:        return NULL;
        -:  713:      }
    #####:  714:      case RE_OP_CAPTURING_GROUP_START:
        -:  715:      {
    #####:  716:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  717:        ecma_regexp_capture_t *const group_p = re_ctx_p->captures_p + group_idx;
    #####:  718:        group_p->subcapture_count = re_get_value (&bc_p);
        -:  719:
    #####:  720:        const lit_utf8_byte_t *const saved_begin_p = group_p->begin_p;
    #####:  721:        const lit_utf8_byte_t *const saved_end_p = group_p->end_p;
    #####:  722:        const uint32_t saved_iterator = group_p->iterator;
        -:  723:
    #####:  724:        const uint32_t qmin = re_get_value (&bc_p);
    #####:  725:        group_p->end_p = NULL;
        -:  726:
        -:  727:        /* If zero iterations are allowed, then execute the end opcode which will handle further iterations,
        -:  728:         * otherwise run the 1st iteration immediately by executing group bytecode. */
    #####:  729:        if (qmin == 0)
        -:  730:        {
    #####:  731:          group_p->iterator = 0;
    #####:  732:          group_p->begin_p = NULL;
    #####:  733:          const uint32_t end_offset = re_get_value (&bc_p);
    #####:  734:          group_p->bc_p = bc_p;
        -:  735:
    #####:  736:          bc_p += end_offset;
        -:  737:        }
        -:  738:        else
        -:  739:        {
    #####:  740:          group_p->iterator = 1;
    #####:  741:          group_p->begin_p = str_curr_p;
    #####:  742:          group_p->bc_p = bc_p;
        -:  743:        }
        -:  744:
    #####:  745:        const lit_utf8_byte_t *matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
    #####:  746:        group_p->iterator = saved_iterator;
        -:  747:
    #####:  748:        if (matched_p == NULL)
        -:  749:        {
    #####:  750:          group_p->begin_p = saved_begin_p;
    #####:  751:          group_p->end_p = saved_end_p;
    #####:  752:          goto fail;
        -:  753:        }
        -:  754:
    #####:  755:        return matched_p;
        -:  756:      }
    #####:  757:      case RE_OP_NON_CAPTURING_GROUP_START:
        -:  758:      {
    #####:  759:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  760:        ecma_regexp_non_capture_t *const group_p = re_ctx_p->non_captures_p + group_idx;
        -:  761:
    #####:  762:        group_p->subcapture_start = re_get_value (&bc_p);
    #####:  763:        group_p->subcapture_count = re_get_value (&bc_p);
        -:  764:
    #####:  765:        const lit_utf8_byte_t *const saved_begin_p = group_p->begin_p;
    #####:  766:        const uint32_t saved_iterator = group_p->iterator;
    #####:  767:        const uint32_t qmin = re_get_value (&bc_p);
        -:  768:
        -:  769:        /* If zero iterations are allowed, then execute the end opcode which will handle further iterations,
        -:  770:         * otherwise run the 1st iteration immediately by executing group bytecode. */
    #####:  771:        if (qmin == 0)
        -:  772:        {
    #####:  773:          group_p->iterator = 0;
    #####:  774:          group_p->begin_p = NULL;
    #####:  775:          const uint32_t end_offset = re_get_value (&bc_p);
    #####:  776:          group_p->bc_p = bc_p;
        -:  777:
    #####:  778:          bc_p += end_offset;
        -:  779:        }
        -:  780:        else
        -:  781:        {
    #####:  782:          group_p->iterator = 1;
    #####:  783:          group_p->begin_p = str_curr_p;
    #####:  784:          group_p->bc_p = bc_p;
        -:  785:        }
        -:  786:
    #####:  787:        const lit_utf8_byte_t *matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
    #####:  788:        group_p->iterator = saved_iterator;
        -:  789:
    #####:  790:        if (matched_p == NULL)
        -:  791:        {
    #####:  792:          group_p->begin_p = saved_begin_p;
    #####:  793:          goto fail;
        -:  794:        }
        -:  795:
    #####:  796:        return matched_p;
        -:  797:      }
    #####:  798:      case RE_OP_GREEDY_CAPTURING_GROUP_END:
        -:  799:      {
    #####:  800:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  801:        ecma_regexp_capture_t *const group_p = re_ctx_p->captures_p + group_idx;
    #####:  802:        const uint32_t qmin = re_get_value (&bc_p);
        -:  803:
    #####:  804:        if (group_p->iterator < qmin)
        -:  805:        {
        -:  806:          /* No need to save begin_p since we don't have to backtrack beyond the minimum iteration count, but we have
        -:  807:           * to clear nested capturing groups. */
    #####:  808:          group_p->begin_p = str_curr_p;
    #####:  809:          for (uint32_t i = 1; i < group_p->subcapture_count; ++i)
        -:  810:          {
    #####:  811:            group_p[i].begin_p = NULL;
        -:  812:          }
        -:  813:
    #####:  814:          group_p->iterator++;
    #####:  815:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  816:
    #####:  817:          if (matched_p != NULL)
        -:  818:          {
    #####:  819:            return matched_p;
        -:  820:          }
        -:  821:
    #####:  822:          group_p->iterator--;
    #####:  823:          goto fail;
        -:  824:        }
        -:  825:
        -:  826:        /* Empty matches are not allowed after reaching the minimum number of iterations. */
    #####:  827:        if (JERRY_UNLIKELY (group_p->begin_p >= str_curr_p) && (group_p->iterator > qmin))
        -:  828:        {
    #####:  829:          goto fail;
        -:  830:        }
        -:  831:
    #####:  832:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####:  833:        if (JERRY_UNLIKELY (group_p->iterator >= qmax))
        -:  834:        {
        -:  835:          /* Reached maximum number of iterations, try to match tail bytecode. */
    #####:  836:          group_p->end_p = str_curr_p;
    #####:  837:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -:  838:
    #####:  839:          if (matched_p != NULL)
        -:  840:          {
    #####:  841:            return matched_p;
        -:  842:          }
        -:  843:
    #####:  844:          goto fail;
        -:  845:        }
        -:  846:
    #####:  847:        {
        -:  848:          /* Save and clear all nested capturing groups, and try to iterate. */
    #####:  849:          JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, group_p->subcapture_count);
    #####:  850:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  851:          {
    #####:  852:            saved_captures_p[i] = group_p[i].begin_p;
    #####:  853:            group_p[i].begin_p = NULL;
        -:  854:          }
        -:  855:
    #####:  856:          group_p->iterator++;
    #####:  857:          group_p->begin_p = str_curr_p;
        -:  858:
    #####:  859:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  860:
    #####:  861:          if (matched_p != NULL)
        -:  862:          {
    #####:  863:            return matched_p;
        -:  864:          }
        -:  865:
        -:  866:          /* Failed to iterate again, backtrack to current match, and try to run tail bytecode. */
    #####:  867:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  868:          {
    #####:  869:            group_p[i].begin_p = saved_captures_p[i];
        -:  870:          }
        -:  871:
    #####:  872:          group_p->iterator--;
    #####:  873:          group_p->end_p = str_curr_p;
        -:  874:        }
        -:  875:
    #####:  876:        const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -:  877:
    #####:  878:        if (tail_match_p != NULL)
        -:  879:        {
    #####:  880:          return tail_match_p;
        -:  881:        }
        -:  882:
    #####:  883:        goto fail;
        -:  884:      }
    #####:  885:      case RE_OP_GREEDY_NON_CAPTURING_GROUP_END:
        -:  886:      {
    #####:  887:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  888:        ecma_regexp_non_capture_t *const group_p = re_ctx_p->non_captures_p + group_idx;
    #####:  889:        const uint32_t qmin = re_get_value (&bc_p);
        -:  890:
    #####:  891:        if (group_p->iterator < qmin)
        -:  892:        {
        -:  893:          /* No need to save begin_p but we have to clear nested capturing groups. */
    #####:  894:          group_p->begin_p = str_curr_p;
        -:  895:
    #####:  896:          ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start;
    #####:  897:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  898:          {
    #####:  899:            capture_p[i].begin_p = NULL;
        -:  900:          }
        -:  901:
    #####:  902:          group_p->iterator++;
    #####:  903:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  904:
    #####:  905:          if (matched_p != NULL)
        -:  906:          {
    #####:  907:            return matched_p;
        -:  908:          }
        -:  909:
    #####:  910:          group_p->iterator--;
    #####:  911:          goto fail;
        -:  912:        }
        -:  913:
        -:  914:        /* Empty matches are not allowed after reaching the minimum number of iterations. */
    #####:  915:        if (JERRY_UNLIKELY (group_p->begin_p >= str_curr_p) && (group_p->iterator > qmin))
        -:  916:        {
    #####:  917:          goto fail;
        -:  918:        }
        -:  919:
    #####:  920:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####:  921:        if (JERRY_UNLIKELY (group_p->iterator >= qmax))
        -:  922:        {
        -:  923:          /* Reached maximum number of iterations, try to match tail bytecode. */
    #####:  924:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -:  925:
    #####:  926:          if (matched_p != NULL)
        -:  927:          {
    #####:  928:            return matched_p;
        -:  929:          }
        -:  930:
    #####:  931:          goto fail;
        -:  932:        }
        -:  933:
    #####:  934:        {
        -:  935:          /* Save and clear all nested capturing groups, and try to iterate. */
    #####:  936:          JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, group_p->subcapture_count);
    #####:  937:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  938:          {
    #####:  939:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start + i;
    #####:  940:            saved_captures_p[i] = capture_p->begin_p;
    #####:  941:            capture_p->begin_p = NULL;
        -:  942:          }
        -:  943:
    #####:  944:          group_p->iterator++;
    #####:  945:          const lit_utf8_byte_t *const saved_begin_p = group_p->begin_p;
    #####:  946:          group_p->begin_p = str_curr_p;
        -:  947:
    #####:  948:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  949:
    #####:  950:          if (matched_p != NULL)
        -:  951:          {
    #####:  952:            return matched_p;
        -:  953:          }
        -:  954:
        -:  955:          /* Failed to iterate again, backtrack to current match, and try to run tail bytecode. */
    #####:  956:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -:  957:          {
    #####:  958:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start + i;
    #####:  959:            capture_p->begin_p = saved_captures_p[i];
        -:  960:          }
        -:  961:
    #####:  962:          group_p->iterator--;
    #####:  963:          group_p->begin_p = saved_begin_p;
        -:  964:        }
        -:  965:
    #####:  966:        const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -:  967:
    #####:  968:        if (tail_match_p != NULL)
        -:  969:        {
    #####:  970:          return tail_match_p;
        -:  971:        }
        -:  972:
    #####:  973:        goto fail;
        -:  974:      }
    #####:  975:      case RE_OP_LAZY_CAPTURING_GROUP_END:
        -:  976:      {
    #####:  977:        const uint32_t group_idx = re_get_value (&bc_p);
    #####:  978:        ecma_regexp_capture_t *const group_p = re_ctx_p->captures_p + group_idx;
    #####:  979:        const uint32_t qmin = re_get_value (&bc_p);
        -:  980:
    #####:  981:        if (group_p->iterator < qmin)
        -:  982:        {
        -:  983:          /* No need to save begin_p but we have to clear nested capturing groups. */
    #####:  984:          group_p->begin_p = str_curr_p;
    #####:  985:          for (uint32_t i = 1; i < group_p->subcapture_count; ++i)
        -:  986:          {
    #####:  987:            group_p[i].begin_p = NULL;
        -:  988:          }
        -:  989:
    #####:  990:          group_p->iterator++;
    #####:  991:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -:  992:
    #####:  993:          if (matched_p != NULL)
        -:  994:          {
    #####:  995:            return matched_p;
        -:  996:          }
        -:  997:
    #####:  998:          group_p->iterator--;
    #####:  999:          goto fail;
        -: 1000:        }
        -: 1001:
        -: 1002:        /* Empty matches are not allowed after reaching the minimum number of iterations. */
    #####: 1003:        if (JERRY_UNLIKELY (group_p->begin_p >= str_curr_p) && (group_p->iterator > qmin))
        -: 1004:        {
    #####: 1005:          goto fail;
        -: 1006:        }
        -: 1007:
    #####: 1008:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####: 1009:        group_p->end_p = str_curr_p;
        -: 1010:
        -: 1011:        /* Try to match tail bytecode. */
    #####: 1012:        const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1013:
    #####: 1014:        if (tail_match_p != NULL)
        -: 1015:        {
    #####: 1016:          return tail_match_p;
        -: 1017:        }
        -: 1018:
    #####: 1019:        if (JERRY_UNLIKELY (group_p->iterator >= qmax))
        -: 1020:        {
        -: 1021:          /* Reached maximum number of iterations and tail bytecode did not match. */
    #####: 1022:          goto fail;
        -: 1023:        }
        -: 1024:
    #####: 1025:        {
        -: 1026:          /* Save and clear all nested capturing groups, and try to iterate. */
    #####: 1027:          JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, group_p->subcapture_count);
    #####: 1028:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1029:          {
    #####: 1030:            saved_captures_p[i] = group_p[i].begin_p;
    #####: 1031:            group_p[i].begin_p = NULL;
        -: 1032:          }
        -: 1033:
    #####: 1034:          group_p->iterator++;
    #####: 1035:          group_p->begin_p = str_curr_p;
        -: 1036:
    #####: 1037:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -: 1038:
    #####: 1039:          if (matched_p != NULL)
        -: 1040:          {
    #####: 1041:            return matched_p;
        -: 1042:          }
        -: 1043:
        -: 1044:          /* Backtrack to current match. */
    #####: 1045:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1046:          {
    #####: 1047:            group_p[i].begin_p = saved_captures_p[i];
        -: 1048:          }
        -: 1049:
    #####: 1050:          group_p->iterator--;
        -: 1051:        }
        -: 1052:
    #####: 1053:        goto fail;
        -: 1054:      }
    #####: 1055:      case RE_OP_LAZY_NON_CAPTURING_GROUP_END:
        -: 1056:      {
    #####: 1057:        const uint32_t group_idx = re_get_value (&bc_p);
    #####: 1058:        ecma_regexp_non_capture_t *const group_p = re_ctx_p->non_captures_p + group_idx;
    #####: 1059:        const uint32_t qmin = re_get_value (&bc_p);
        -: 1060:
    #####: 1061:        if (group_p->iterator < qmin)
        -: 1062:        {
        -: 1063:          /* Clear nested captures. */
    #####: 1064:          ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start;
    #####: 1065:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1066:          {
    #####: 1067:            capture_p[i].begin_p = NULL;
        -: 1068:          }
        -: 1069:
    #####: 1070:          group_p->iterator++;
    #####: 1071:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -: 1072:
    #####: 1073:          if (matched_p != NULL)
        -: 1074:          {
    #####: 1075:            return matched_p;
        -: 1076:          }
        -: 1077:
    #####: 1078:          group_p->iterator--;
    #####: 1079:          goto fail;
        -: 1080:        }
        -: 1081:
        -: 1082:        /* Empty matches are not allowed after reaching the minimum number of iterations. */
    #####: 1083:        if (JERRY_UNLIKELY (group_p->begin_p >= str_curr_p) && (group_p->iterator > qmin))
        -: 1084:        {
    #####: 1085:          goto fail;
        -: 1086:        }
        -: 1087:
    #####: 1088:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
        -: 1089:
        -: 1090:        /* Try to match tail bytecode. */
    #####: 1091:        const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1092:
    #####: 1093:        if (tail_match_p != NULL)
        -: 1094:        {
    #####: 1095:          return tail_match_p;
        -: 1096:        }
        -: 1097:
    #####: 1098:        if (JERRY_UNLIKELY (group_p->iterator >= qmax))
        -: 1099:        {
        -: 1100:          /* Reached maximum number of iterations and tail bytecode did not match. */
    #####: 1101:          goto fail;
        -: 1102:        }
        -: 1103:
    #####: 1104:        {
        -: 1105:          /* Save and clear all nested capturing groups, and try to iterate. */
    #####: 1106:          JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, group_p->subcapture_count);
    #####: 1107:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1108:          {
    #####: 1109:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start + i;
    #####: 1110:            saved_captures_p[i] = capture_p->begin_p;
    #####: 1111:            capture_p->begin_p = NULL;
        -: 1112:          }
        -: 1113:
    #####: 1114:          group_p->iterator++;
    #####: 1115:          const lit_utf8_byte_t *const saved_begin_p = group_p->begin_p;
    #####: 1116:          group_p->begin_p = str_curr_p;
        -: 1117:
    #####: 1118:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, group_p->bc_p, str_curr_p);
        -: 1119:
    #####: 1120:          if (matched_p != NULL)
        -: 1121:          {
    #####: 1122:            return matched_p;
        -: 1123:          }
        -: 1124:
        -: 1125:          /* Backtrack to current match. */
    #####: 1126:          for (uint32_t i = 0; i < group_p->subcapture_count; ++i)
        -: 1127:          {
    #####: 1128:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + group_p->subcapture_start + i;
    #####: 1129:            capture_p->begin_p = saved_captures_p[i];
        -: 1130:          }
        -: 1131:
    #####: 1132:          group_p->iterator--;
    #####: 1133:          group_p->begin_p = saved_begin_p;
        -: 1134:        }
        -: 1135:
    #####: 1136:        goto fail;
        -: 1137:      }
    #####: 1138:      case RE_OP_GREEDY_ITERATOR:
        -: 1139:      {
    #####: 1140:        const uint32_t qmin = re_get_value (&bc_p);
    #####: 1141:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####: 1142:        const uint32_t end_offset = re_get_value (&bc_p);
        -: 1143:
    #####: 1144:        uint32_t iterator = 0;
    #####: 1145:        while (iterator < qmin)
        -: 1146:        {
    #####: 1147:          str_curr_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1148:
    #####: 1149:          if (str_curr_p == NULL)
        -: 1150:          {
    #####: 1151:            goto fail;
        -: 1152:          }
        -: 1153:
        -: 1154:          if (ECMA_RE_STACK_LIMIT_REACHED (str_curr_p))
        -: 1155:          {
        -: 1156:            return str_curr_p;
        -: 1157:          }
        -: 1158:
    #####: 1159:          iterator++;
        -: 1160:        }
        -: 1161:
    #####: 1162:        while (iterator < qmax)
        -: 1163:        {
    #####: 1164:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1165:
    #####: 1166:          if (matched_p == NULL)
        -: 1167:          {
    #####: 1168:            break;
        -: 1169:          }
        -: 1170:
        -: 1171:          if (ECMA_RE_STACK_LIMIT_REACHED (str_curr_p))
        -: 1172:          {
        -: 1173:            return str_curr_p;
        -: 1174:          }
        -: 1175:
    #####: 1176:          str_curr_p = matched_p;
    #####: 1177:          iterator++;
        -: 1178:        }
        -: 1179:
    #####: 1180:        const uint8_t *const tail_bc_p = bc_p + end_offset;
        -: 1181:        while (true)
    #####: 1182:        {
    #####: 1183:          const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, tail_bc_p, str_curr_p);
        -: 1184:
    #####: 1185:          if (tail_match_p != NULL)
        -: 1186:          {
    #####: 1187:            return tail_match_p;
        -: 1188:          }
        -: 1189:
    #####: 1190:          if (JERRY_UNLIKELY (iterator <= qmin))
        -: 1191:          {
    #####: 1192:            goto fail;
        -: 1193:          }
        -: 1194:
    #####: 1195:          iterator--;
    #####: 1196:          JERRY_ASSERT (str_curr_p > re_ctx_p->input_start_p);
    #####: 1197:          str_curr_p = ecma_regexp_step_back (re_ctx_p, str_curr_p);
        -: 1198:        }
        -: 1199:
        -: 1200:        JERRY_UNREACHABLE ();
        -: 1201:      }
    #####: 1202:      case RE_OP_LAZY_ITERATOR:
        -: 1203:      {
    #####: 1204:        const uint32_t qmin = re_get_value (&bc_p);
    #####: 1205:        const uint32_t qmax = re_get_value (&bc_p) - RE_QMAX_OFFSET;
    #####: 1206:        const uint32_t end_offset = re_get_value (&bc_p);
        -: 1207:
    #####: 1208:        uint32_t iterator = 0;
    #####: 1209:        while (iterator < qmin)
        -: 1210:        {
    #####: 1211:          str_curr_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1212:
    #####: 1213:          if (str_curr_p == NULL)
        -: 1214:          {
    #####: 1215:            goto fail;
        -: 1216:          }
        -: 1217:
        -: 1218:          if (ECMA_RE_STACK_LIMIT_REACHED (str_curr_p))
        -: 1219:          {
        -: 1220:            return str_curr_p;
        -: 1221:          }
        -: 1222:
    #####: 1223:          iterator++;
        -: 1224:        }
        -: 1225:
    #####: 1226:        const uint8_t *const tail_bc_p = bc_p + end_offset;
        -: 1227:        while (true)
    #####: 1228:        {
    #####: 1229:          const lit_utf8_byte_t *const tail_match_p = ecma_regexp_run (re_ctx_p, tail_bc_p, str_curr_p);
        -: 1230:
    #####: 1231:          if (tail_match_p != NULL)
        -: 1232:          {
    #####: 1233:            return tail_match_p;
        -: 1234:          }
        -: 1235:
    #####: 1236:          if (JERRY_UNLIKELY (iterator >= qmax))
        -: 1237:          {
    #####: 1238:            goto fail;
        -: 1239:          }
        -: 1240:
    #####: 1241:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1242:
    #####: 1243:          if (matched_p == NULL)
        -: 1244:          {
    #####: 1245:            goto fail;
        -: 1246:          }
        -: 1247:
        -: 1248:          if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 1249:          {
        -: 1250:            return matched_p;
        -: 1251:          }
        -: 1252:
    #####: 1253:          iterator++;
    #####: 1254:          str_curr_p = matched_p;
        -: 1255:        }
        -: 1256:
        -: 1257:        JERRY_UNREACHABLE ();
        -: 1258:      }
    #####: 1259:      case RE_OP_BACKREFERENCE:
        -: 1260:      {
    #####: 1261:        const uint32_t backref_idx = re_get_value (&bc_p);
    #####: 1262:        JERRY_ASSERT (backref_idx >= 1 && backref_idx < re_ctx_p->captures_count);
    #####: 1263:        const ecma_regexp_capture_t *capture_p = re_ctx_p->captures_p + backref_idx;
        -: 1264:
    #####: 1265:        if (!ECMA_RE_IS_CAPTURE_DEFINED (capture_p) || capture_p->end_p <= capture_p->begin_p)
        -: 1266:        {
        -: 1267:          /* Undefined or zero length captures always match. */
    #####: 1268:          continue;
        -: 1269:        }
        -: 1270:
    #####: 1271:        const lit_utf8_size_t capture_size = (lit_utf8_size_t) (capture_p->end_p - capture_p->begin_p);
        -: 1272:
    #####: 1273:        if (str_curr_p + capture_size > re_ctx_p->input_end_p
    #####: 1274:            || memcmp (str_curr_p, capture_p->begin_p, capture_size))
        -: 1275:        {
        -: 1276:          goto fail;
        -: 1277:        }
        -: 1278:
    #####: 1279:        str_curr_p += capture_size;
    #####: 1280:        continue;
        -: 1281:      }
    #####: 1282:      case RE_OP_ASSERT_LINE_START:
        -: 1283:      {
    #####: 1284:        if (str_curr_p <= re_ctx_p->input_start_p)
        -: 1285:        {
    #####: 1286:          continue;
        -: 1287:        }
        -: 1288:
    #####: 1289:        if (!(re_ctx_p->flags & RE_FLAG_MULTILINE) || !lit_char_is_line_terminator (lit_cesu8_peek_prev (str_curr_p)))
        -: 1290:        {
        -: 1291:          goto fail;
        -: 1292:        }
        -: 1293:
    #####: 1294:        continue;
        -: 1295:      }
    #####: 1296:      case RE_OP_ASSERT_LINE_END:
        -: 1297:      {
    #####: 1298:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1299:        {
    #####: 1300:          continue;
        -: 1301:        }
        -: 1302:
    #####: 1303:        if (!(re_ctx_p->flags & RE_FLAG_MULTILINE) || !lit_char_is_line_terminator (lit_cesu8_peek_next (str_curr_p)))
        -: 1304:        {
        -: 1305:          goto fail;
        -: 1306:        }
        -: 1307:
    #####: 1308:        continue;
        -: 1309:      }
    #####: 1310:      case RE_OP_ASSERT_WORD_BOUNDARY:
        -: 1311:      {
    #####: 1312:        if (!ecma_regexp_is_word_boundary (re_ctx_p, str_curr_p))
        -: 1313:        {
    #####: 1314:          goto fail;
        -: 1315:        }
        -: 1316:
    #####: 1317:        continue;
        -: 1318:      }
    #####: 1319:      case RE_OP_ASSERT_NOT_WORD_BOUNDARY:
        -: 1320:      {
    #####: 1321:        if (ecma_regexp_is_word_boundary (re_ctx_p, str_curr_p))
        -: 1322:        {
    #####: 1323:          goto fail;
        -: 1324:        }
        -: 1325:
    #####: 1326:        continue;
        -: 1327:      }
    #####: 1328:      case RE_OP_ASSERT_LOOKAHEAD_POS:
    #####: 1329:      {
    #####: 1330:        const uint8_t qmin = re_get_byte (&bc_p);
    #####: 1331:        const uint32_t capture_start = re_get_value (&bc_p);
    #####: 1332:        const uint32_t capture_count = re_get_value (&bc_p);
    #####: 1333:        const uint32_t end_offset = re_get_value (&bc_p);
        -: 1334:
        -: 1335:        /* If qmin is zero, the assertion implicitly matches. */
    #####: 1336:        if (qmin == 0)
        -: 1337:        {
    #####: 1338:          bc_p += end_offset;
    #####: 1339:          continue;
        -: 1340:        }
        -: 1341:
        -: 1342:        /* Capture end pointers might get clobbered and need to be restored after a tail match fail. */
    #####: 1343:        JERRY_VLA (const lit_utf8_byte_t *, saved_captures_p, capture_count);
    #####: 1344:        for (uint32_t i = 0; i < capture_count; ++i)
        -: 1345:        {
    #####: 1346:          ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + capture_start + i;
    #####: 1347:          saved_captures_p[i] = capture_p->end_p;
        -: 1348:        }
        -: 1349:
        -: 1350:        /* The first iteration will decide whether the assertion matches depending on whether
        -: 1351:         * the iteration matched or not. */
    #####: 1352:        const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1353:
        -: 1354:        if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 1355:        {
        -: 1356:          return matched_p;
        -: 1357:        }
        -: 1358:
    #####: 1359:        if (matched_p == NULL)
        -: 1360:        {
    #####: 1361:          goto fail;
        -: 1362:        }
        -: 1363:
    #####: 1364:        const lit_utf8_byte_t *tail_match_p = ecma_regexp_run (re_ctx_p, bc_p + end_offset, str_curr_p);
        -: 1365:
    #####: 1366:        if (tail_match_p == NULL)
        -: 1367:        {
    #####: 1368:          for (uint32_t i = 0; i < capture_count; ++i)
        -: 1369:          {
    #####: 1370:            ecma_regexp_capture_t *const capture_p = re_ctx_p->captures_p + capture_start + i;
    #####: 1371:            capture_p->begin_p = NULL;
    #####: 1372:            capture_p->end_p = saved_captures_p[i];
        -: 1373:          }
        -: 1374:
    #####: 1375:          goto fail;
        -: 1376:        }
        -: 1377:
    #####: 1378:        return tail_match_p;
        -: 1379:      }
    #####: 1380:      case RE_OP_ASSERT_LOOKAHEAD_NEG:
        -: 1381:      {
    #####: 1382:        const uint8_t qmin = re_get_byte (&bc_p);
    #####: 1383:        uint32_t capture_idx = re_get_value (&bc_p);
    #####: 1384:        const uint32_t capture_count = re_get_value (&bc_p);
    #####: 1385:        const uint32_t end_offset = re_get_value (&bc_p);
        -: 1386:
        -: 1387:        /* If qmin is zero, the assertion implicitly matches. */
    #####: 1388:        if (qmin > 0)
        -: 1389:        {
        -: 1390:          /* The first iteration will decide whether the assertion matches depending on whether
        -: 1391:           * the iteration matched or not. */
    #####: 1392:          const lit_utf8_byte_t *const matched_p = ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1393:
        -: 1394:          if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 1395:          {
        -: 1396:            return matched_p;
        -: 1397:          }
        -: 1398:
    #####: 1399:          if (matched_p != NULL)
        -: 1400:          {
        -: 1401:            /* Nested capturing groups inside a negative lookahead can never capture, so we clear their results. */
    #####: 1402:            const uint32_t capture_end = capture_idx + capture_count;
    #####: 1403:            while (capture_idx < capture_end)
        -: 1404:            {
    #####: 1405:              re_ctx_p->captures_p[capture_idx++].begin_p = NULL;
        -: 1406:            }
        -: 1407:
    #####: 1408:            goto fail;
        -: 1409:          }
        -: 1410:        }
        -: 1411:
    #####: 1412:        bc_p += end_offset;
    #####: 1413:        continue;
        -: 1414:      }
    #####: 1415:      case RE_OP_CLASS_ESCAPE:
        -: 1416:      {
    #####: 1417:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1418:        {
    #####: 1419:          goto fail;
        -: 1420:        }
        -: 1421:
    #####: 1422:        const lit_code_point_t cp = ecma_regexp_advance (re_ctx_p, &str_curr_p);
        -: 1423:
    #####: 1424:        const ecma_class_escape_t escape = (ecma_class_escape_t) re_get_byte (&bc_p);
    #####: 1425:        if (!ecma_regexp_check_class_escape (cp, escape))
        -: 1426:        {
    #####: 1427:          goto fail;
        -: 1428:        }
        -: 1429:
    #####: 1430:        continue;
        -: 1431:      }
    #####: 1432:      case RE_OP_CHAR_CLASS:
        -: 1433:      {
    #####: 1434:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1435:        {
    #####: 1436:          goto fail;
        -: 1437:        }
        -: 1438:
    #####: 1439:        uint8_t flags = re_get_byte (&bc_p);
    #####: 1440:        uint32_t char_count = (flags & RE_CLASS_HAS_CHARS) ? re_get_value (&bc_p) : 0;
    #####: 1441:        uint32_t range_count = (flags & RE_CLASS_HAS_RANGES) ? re_get_value (&bc_p) : 0;
        -: 1442:
    #####: 1443:        const lit_code_point_t cp = ecma_regexp_advance (re_ctx_p, &str_curr_p);
        -: 1444:
    #####: 1445:        uint8_t escape_count = flags & RE_CLASS_ESCAPE_COUNT_MASK;
    #####: 1446:        while (escape_count > 0)
        -: 1447:        {
    #####: 1448:          escape_count--;
    #####: 1449:          const ecma_class_escape_t escape = re_get_byte (&bc_p);
    #####: 1450:          if (ecma_regexp_check_class_escape (cp, escape))
        -: 1451:          {
    #####: 1452:            goto class_found;
        -: 1453:          }
        -: 1454:        }
        -: 1455:
    #####: 1456:        while (char_count > 0)
        -: 1457:        {
    #####: 1458:          char_count--;
    #####: 1459:          const lit_code_point_t curr = re_get_char (&bc_p, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####: 1460:          if (cp == curr)
        -: 1461:          {
    #####: 1462:            goto class_found;
        -: 1463:          }
        -: 1464:        }
        -: 1465:
    #####: 1466:        while (range_count > 0)
        -: 1467:        {
    #####: 1468:          range_count--;
    #####: 1469:          const lit_code_point_t begin = re_get_char (&bc_p, re_ctx_p->flags & RE_FLAG_UNICODE);
        -: 1470:
    #####: 1471:          if (cp < begin)
        -: 1472:          {
    #####: 1473:            bc_p += re_ctx_p->char_size;
    #####: 1474:            continue;
        -: 1475:          }
        -: 1476:
    #####: 1477:          const lit_code_point_t end = re_get_char (&bc_p, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####: 1478:          if (cp <= end)
        -: 1479:          {
    #####: 1480:            goto class_found;
        -: 1481:          }
        -: 1482:        }
        -: 1483:
        -: 1484:        /* Not found */
    #####: 1485:        if (flags & RE_CLASS_INVERT)
        -: 1486:        {
    #####: 1487:          continue;
        -: 1488:        }
        -: 1489:
    #####: 1490:        goto fail;
        -: 1491:
    #####: 1492:class_found:
    #####: 1493:        if (flags & RE_CLASS_INVERT)
        -: 1494:        {
    #####: 1495:          goto fail;
        -: 1496:        }
        -: 1497:
    #####: 1498:        const uint32_t chars_size = char_count * re_ctx_p->char_size;
    #####: 1499:        const uint32_t ranges_size = range_count * re_ctx_p->char_size * 2;
    #####: 1500:        bc_p = bc_p + escape_count + chars_size + ranges_size;
    #####: 1501:        continue;
        -: 1502:      }
        -: 1503:#if JERRY_ESNEXT
    #####: 1504:      case RE_OP_UNICODE_PERIOD:
        -: 1505:      {
    #####: 1506:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1507:        {
    #####: 1508:          goto fail;
        -: 1509:        }
        -: 1510:
    #####: 1511:        const lit_code_point_t cp = ecma_regexp_unicode_advance (&str_curr_p, re_ctx_p->input_end_p);
        -: 1512:
    #####: 1513:        if (!(re_ctx_p->flags & RE_FLAG_DOTALL)
    #####: 1514:            && JERRY_UNLIKELY (cp <= LIT_UTF16_CODE_UNIT_MAX
        -: 1515:                               && lit_char_is_line_terminator ((ecma_char_t) cp)))
        -: 1516:        {
    #####: 1517:          goto fail;
        -: 1518:        }
        -: 1519:
    #####: 1520:        continue;
        -: 1521:      }
        -: 1522:#endif /* JERRY_ESNEXT */
    #####: 1523:      case RE_OP_PERIOD:
        -: 1524:      {
    #####: 1525:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1526:        {
    #####: 1527:          goto fail;
        -: 1528:        }
        -: 1529:
    #####: 1530:        const ecma_char_t ch = lit_cesu8_read_next (&str_curr_p);
        -: 1531:#if !JERRY_ESNEXT
    #####: 1532:        bool has_dot_all_flag = false;
        -: 1533:#else /* JERRY_ESNEXT */
    #####: 1534:        bool has_dot_all_flag = (re_ctx_p->flags & RE_FLAG_DOTALL) != 0;
        -: 1535:#endif /* !JERRY_ESNEXT */
        -: 1536:
    #####: 1537:        if (!has_dot_all_flag && lit_char_is_line_terminator (ch))
        -: 1538:        {
    #####: 1539:          goto fail;
        -: 1540:        }
        -: 1541:
    #####: 1542:        continue;
        -: 1543:      }
    #####: 1544:      case RE_OP_CHAR:
        -: 1545:      {
    #####: 1546:        if (str_curr_p >= re_ctx_p->input_end_p)
        -: 1547:        {
    #####: 1548:          goto fail;
        -: 1549:        }
        -: 1550:
    #####: 1551:        const lit_code_point_t ch1 = re_get_char (&bc_p, re_ctx_p->flags & RE_FLAG_UNICODE);
    #####: 1552:        const lit_code_point_t ch2 = ecma_regexp_advance (re_ctx_p, &str_curr_p);
        -: 1553:
    #####: 1554:        if (ch1 != ch2)
        -: 1555:        {
    #####: 1556:          goto fail;
        -: 1557:        }
        -: 1558:
    #####: 1559:        continue;
        -: 1560:      }
    #####: 1561:      default:
        -: 1562:      {
    #####: 1563:        JERRY_ASSERT (op == RE_OP_BYTE);
        -: 1564:
    #####: 1565:        if (str_curr_p >= re_ctx_p->input_end_p
    #####: 1566:            || *bc_p++ != *str_curr_p++)
        -: 1567:        {
        -: 1568:          goto fail;
        -: 1569:        }
        -: 1570:
    #####: 1571:        continue;
        -: 1572:      }
        -: 1573:    }
        -: 1574:
        -: 1575:    JERRY_UNREACHABLE ();
    #####: 1576:fail:
    #####: 1577:    bc_p = next_alternative_p;
        -: 1578:
    #####: 1579:    if (bc_p == NULL || *bc_p++ != RE_OP_ALTERNATIVE_NEXT)
        -: 1580:    {
        -: 1581:      /* None of the alternatives matched. */
    #####: 1582:      return NULL;
        -: 1583:    }
        -: 1584:
        -: 1585:    /* Get the end of the new alternative and continue execution. */
    #####: 1586:    str_curr_p = str_start_p;
    #####: 1587:    const uint32_t offset = re_get_value (&bc_p);
    #####: 1588:    next_alternative_p = bc_p + offset;
        -: 1589:  }
        -: 1590:} /* ecma_regexp_run */
        -: 1591:
        -: 1592:/**
        -: 1593: * Match a RegExp at a specific position in the input string.
        -: 1594: *
        -: 1595: * @return pointer to the end of the matched sub-string
        -: 1596: *         NULL, if pattern did not match
        -: 1597: */
        -: 1598:static const lit_utf8_byte_t *
    #####: 1599:ecma_regexp_match (ecma_regexp_ctx_t *re_ctx_p, /**< RegExp matcher context */
        -: 1600:                   const uint8_t *bc_p, /**< pointer to the current RegExp bytecode */
        -: 1601:                   const lit_utf8_byte_t *str_curr_p) /**< input string pointer */
        -: 1602:{
    #####: 1603:  re_ctx_p->captures_p[RE_GLOBAL_CAPTURE].begin_p = str_curr_p;
        -: 1604:
    #####: 1605:  for (uint32_t i = 1; i < re_ctx_p->captures_count; ++i)
        -: 1606:  {
    #####: 1607:    re_ctx_p->captures_p[i].begin_p = NULL;
        -: 1608:  }
        -: 1609:
    #####: 1610:  return ecma_regexp_run (re_ctx_p, bc_p, str_curr_p);
        -: 1611:} /* ecma_regexp_match */
        -: 1612:
        -: 1613:/*
        -: 1614: * Helper function to get the result of a capture
        -: 1615: *
        -: 1616: * @return string value, if capture is defined
        -: 1617: *         undefined, otherwise
        -: 1618: */
        -: 1619:ecma_value_t
    #####: 1620:ecma_regexp_get_capture_value (const ecma_regexp_capture_t *const capture_p) /**< capture */
        -: 1621:{
    #####: 1622:  if (ECMA_RE_IS_CAPTURE_DEFINED (capture_p))
        -: 1623:  {
    #####: 1624:    JERRY_ASSERT (capture_p->end_p >= capture_p->begin_p);
    #####: 1625:    const lit_utf8_size_t capture_size = (lit_utf8_size_t) (capture_p->end_p - capture_p->begin_p);
    #####: 1626:    ecma_string_t *const capture_str_p = ecma_new_ecma_string_from_utf8 (capture_p->begin_p, capture_size);
    #####: 1627:    return ecma_make_string_value (capture_str_p);
        -: 1628:  }
        -: 1629:
    #####: 1630:  return ECMA_VALUE_UNDEFINED;
        -: 1631:} /* ecma_regexp_get_capture_value */
        -: 1632:
        -: 1633:/**
        -: 1634: * Helper function to create a result array from the captures in a regexp context
        -: 1635: *
        -: 1636: * @return ecma value containing the created array object
        -: 1637: */
        -: 1638:static ecma_value_t
    #####: 1639:ecma_regexp_create_result_object (ecma_regexp_ctx_t *re_ctx_p, /**< regexp context */
        -: 1640:                                  ecma_string_t *input_string_p, /**< input ecma string */
        -: 1641:                                  uint32_t index) /**< match index */
        -: 1642:{
    #####: 1643:  ecma_object_t *result_p = ecma_op_new_array_object (0);
        -: 1644:
    #####: 1645:  for (uint32_t i = 0; i < re_ctx_p->captures_count; i++)
        -: 1646:  {
    #####: 1647:    ecma_value_t capture_value = ecma_regexp_get_capture_value (re_ctx_p->captures_p + i);
    #####: 1648:    ecma_builtin_helper_def_prop_by_index (result_p,
        -: 1649:                                           i,
        -: 1650:                                           capture_value,
        -: 1651:                                           ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1652:    ecma_free_value (capture_value);
        -: 1653:  }
        -: 1654:
    #####: 1655:  ecma_builtin_helper_def_prop (result_p,
        -: 1656:                                ecma_get_magic_string (LIT_MAGIC_STRING_INDEX),
        -: 1657:                                ecma_make_uint32_value (index),
        -: 1658:                                ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 1659:
    #####: 1660:  ecma_builtin_helper_def_prop (result_p,
        -: 1661:                                ecma_get_magic_string (LIT_MAGIC_STRING_INPUT),
        -: 1662:                                ecma_make_string_value (input_string_p),
        -: 1663:                                ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 1664:
    #####: 1665:  return ecma_make_object_value (result_p);
        -: 1666:} /* ecma_regexp_create_result_object */
        -: 1667:
        -: 1668:/**
        -: 1669: * Helper function to initialize a regexp match context
        -: 1670: */
        -: 1671:static void
    #####: 1672:ecma_regexp_initialize_context (ecma_regexp_ctx_t *ctx_p, /**< regexp context */
        -: 1673:                                const re_compiled_code_t *bc_p, /**< regexp bytecode */
        -: 1674:                                const lit_utf8_byte_t *input_start_p, /**< pointer to input string */
        -: 1675:                                const lit_utf8_byte_t *input_end_p) /**< pointer to end of input string */
        -: 1676:{
    #####: 1677:  JERRY_ASSERT (ctx_p != NULL);
    #####: 1678:  JERRY_ASSERT (bc_p != NULL);
    #####: 1679:  JERRY_ASSERT (input_start_p != NULL);
    #####: 1680:  JERRY_ASSERT (input_end_p >= input_start_p);
        -: 1681:
    #####: 1682:  ctx_p->flags = bc_p->header.status_flags;
    #####: 1683:  ctx_p->char_size = (ctx_p->flags & RE_FLAG_UNICODE) ? sizeof (lit_code_point_t) : sizeof (ecma_char_t);
        -: 1684:
    #####: 1685:  ctx_p->input_start_p = input_start_p;
    #####: 1686:  ctx_p->input_end_p = input_end_p;
        -: 1687:
    #####: 1688:  ctx_p->captures_count = bc_p->captures_count;
    #####: 1689:  ctx_p->non_captures_count = bc_p->non_captures_count;
        -: 1690:
    #####: 1691:  ctx_p->captures_p = jmem_heap_alloc_block (ctx_p->captures_count * sizeof (ecma_regexp_capture_t));
        -: 1692:
    #####: 1693:  if (ctx_p->non_captures_count > 0)
        -: 1694:  {
    #####: 1695:    ctx_p->non_captures_p = jmem_heap_alloc_block (ctx_p->non_captures_count * sizeof (ecma_regexp_non_capture_t));
        -: 1696:  }
    #####: 1697:} /* ecma_regexp_initialize_context */
        -: 1698:
        -: 1699:/**
        -: 1700: * Helper function to clean up a regexp context
        -: 1701: */
        -: 1702:static void
    #####: 1703:ecma_regexp_cleanup_context (ecma_regexp_ctx_t *ctx_p) /**< regexp context */
        -: 1704:{
    #####: 1705:  JERRY_ASSERT (ctx_p != NULL);
    #####: 1706:  jmem_heap_free_block (ctx_p->captures_p, ctx_p->captures_count * sizeof (ecma_regexp_capture_t));
        -: 1707:
    #####: 1708:  if (ctx_p->non_captures_count > 0)
        -: 1709:  {
    #####: 1710:    jmem_heap_free_block (ctx_p->non_captures_p, ctx_p->non_captures_count * sizeof (ecma_regexp_non_capture_t));
        -: 1711:  }
    #####: 1712:} /* ecma_regexp_cleanup_context */
        -: 1713:
        -: 1714:/**
        -: 1715: * RegExp helper function to start the recursive matching algorithm
        -: 1716: * and create the result Array object
        -: 1717: *
        -: 1718: * See also:
        -: 1719: *          ECMA-262 v5, 15.10.6.2
        -: 1720: *          ECMA-262 v11, 21.2.5.2.2
        -: 1721: *
        -: 1722: * @return array object - if matched
        -: 1723: *         null         - otherwise
        -: 1724: *
        -: 1725: *         May raise error.
        -: 1726: *         Returned value must be freed with ecma_free_value
        -: 1727: */
        -: 1728:ecma_value_t
    #####: 1729:ecma_regexp_exec_helper (ecma_object_t *regexp_object_p, /**< RegExp object */
        -: 1730:                         ecma_string_t *input_string_p) /**< input string */
        -: 1731:{
    #####: 1732:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1733:
        -: 1734:  /* 1. */
    #####: 1735:  JERRY_ASSERT (ecma_object_is_regexp_object (ecma_make_object_value (regexp_object_p)));
        -: 1736:
        -: 1737:  /* 9. */
    #####: 1738:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) regexp_object_p;
    #####: 1739:  re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, ext_object_p->u.cls.u3.value);
        -: 1740:
        -: 1741:  /* 3. */
    #####: 1742:  lit_utf8_size_t input_size;
    #####: 1743:  lit_utf8_size_t input_length;
    #####: 1744:  uint8_t input_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 1745:  const lit_utf8_byte_t *input_buffer_p = ecma_string_get_chars (input_string_p,
        -: 1746:                                                                 &input_size,
        -: 1747:                                                                 &input_length,
        -: 1748:                                                                 NULL,
        -: 1749:                                                                 &input_flags);
        -: 1750:
    #####: 1751:  const lit_utf8_byte_t *input_curr_p = input_buffer_p;
    #####: 1752:  const lit_utf8_byte_t *input_end_p = input_buffer_p + input_size;
        -: 1753:
    #####: 1754:  ecma_regexp_ctx_t re_ctx;
    #####: 1755:  ecma_regexp_initialize_context (&re_ctx,
        -: 1756:                                  bc_p,
        -: 1757:                                  input_buffer_p,
        -: 1758:                                  input_end_p);
        -: 1759:
        -: 1760:  /* 4. */
    #####: 1761:  ecma_length_t index = 0;
    #####: 1762:  ecma_value_t lastindex_value = ecma_op_object_get_by_magic_id (regexp_object_p, LIT_MAGIC_STRING_LASTINDEX_UL);
        -: 1763:
        -: 1764:#if JERRY_ESNEXT
    #####: 1765:  ret_value = ecma_op_to_length (lastindex_value, &index);
    #####: 1766:  ecma_free_value (lastindex_value);
        -: 1767:#else /* !JERRY_ESNEXT */
    #####: 1768:  ecma_number_t lastindex_num = 0.0f;
    #####: 1769:  ret_value = ecma_op_to_integer (lastindex_value, &lastindex_num);
    #####: 1770:  ecma_free_value (lastindex_value);
        -: 1771:
        -: 1772:  /* The ToInteger operation might have thrown an error, however in that case lastindex_num will still be zero,
        -: 1773:   * and the error will be handled later after the uint32 coercion. */
    #####: 1774:  if ((re_ctx.flags & RE_FLAG_GLOBAL) && lastindex_num < 0.0f)
        -: 1775:  {
        -: 1776:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (ret_value));
        -: 1777:    goto fail_put_lastindex;
        -: 1778:  }
        -: 1779:
    #####: 1780:  index = ecma_number_to_uint32 (lastindex_num);
        -: 1781:#endif /* JERRY_ESNEXT */
        -: 1782:
    #####: 1783:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1784:  {
    #####: 1785:    goto cleanup_context;
        -: 1786:  }
        -: 1787:
    #####: 1788:  if (re_ctx.flags & (RE_FLAG_GLOBAL | RE_FLAG_STICKY))
        -: 1789:  {
        -: 1790:    /* 12.a */
    #####: 1791:    if (index > input_length)
        -: 1792:    {
    #####: 1793:      goto fail_put_lastindex;
        -: 1794:    }
        -: 1795:
    #####: 1796:    if (index > 0)
        -: 1797:    {
    #####: 1798:      if (input_flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 1799:      {
    #####: 1800:        input_curr_p += index;
        -: 1801:      }
        -: 1802:      else
        -: 1803:      {
    #####: 1804:        for (uint32_t i = 0; i < index; i++)
        -: 1805:        {
    #####: 1806:          lit_utf8_incr (&input_curr_p);
        -: 1807:        }
        -: 1808:      }
        -: 1809:    }
        -: 1810:  }
        -: 1811:  /* 8. */
        -: 1812:  else
        -: 1813:  {
    #####: 1814:    index = 0;
        -: 1815:  }
        -: 1816:
        -: 1817:  /* 9. */
    #####: 1818:  uint8_t *bc_start_p = (uint8_t *) (bc_p + 1);
        -: 1819:
        -: 1820:  /* 11. */
    #####: 1821:  const lit_utf8_byte_t *matched_p = NULL;
        -: 1822:
        -: 1823:  /* 12. */
    #####: 1824:  JERRY_ASSERT (index <= input_length);
        -: 1825:  while (true)
        -: 1826:  {
    #####: 1827:    matched_p = ecma_regexp_match (&re_ctx, bc_start_p, input_curr_p);
        -: 1828:
    #####: 1829:    if (matched_p != NULL)
        -: 1830:    {
    #####: 1831:      goto match_found;
        -: 1832:    }
        -: 1833:
        -: 1834:#if JERRY_ESNEXT
        -: 1835:    /* 12.c.i */
    #####: 1836:    if (re_ctx.flags & RE_FLAG_STICKY)
        -: 1837:    {
    #####: 1838:      goto fail_put_lastindex;
        -: 1839:    }
        -: 1840:#endif /* JERRY_ESNEXT */
        -: 1841:
        -: 1842:    /* 12.a */
    #####: 1843:    if (input_curr_p >= input_end_p)
        -: 1844:    {
    #####: 1845:      if (re_ctx.flags & RE_FLAG_GLOBAL)
        -: 1846:      {
    #####: 1847:        goto fail_put_lastindex;
        -: 1848:      }
        -: 1849:
    #####: 1850:      goto match_failed;
        -: 1851:    }
        -: 1852:
    #####: 1853:    JERRY_ASSERT (input_curr_p < input_end_p);
        -: 1854:
        -: 1855:    /* 12.c.ii */
    #####: 1856:    index++;
        -: 1857:
        -: 1858:#if JERRY_ESNEXT
    #####: 1859:    if (re_ctx.flags & RE_FLAG_UNICODE)
        -: 1860:    {
    #####: 1861:      const lit_code_point_t cp = ecma_regexp_unicode_advance (&input_curr_p, input_end_p);
        -: 1862:
    #####: 1863:      if (cp > LIT_UTF16_CODE_UNIT_MAX)
        -: 1864:      {
    #####: 1865:        index++;
        -: 1866:      }
        -: 1867:
    #####: 1868:      continue;
        -: 1869:    }
        -: 1870:#endif /* JERRY_ESNEXT */
        -: 1871:
    #####: 1872:    lit_utf8_incr (&input_curr_p);
        -: 1873:  }
        -: 1874:
        -: 1875:  JERRY_UNREACHABLE ();
        -: 1876:
    #####: 1877:fail_put_lastindex:
        -: 1878:  /* We should only get here if the regexp is global or sticky */
    #####: 1879:  JERRY_ASSERT ((re_ctx.flags & (RE_FLAG_GLOBAL | RE_FLAG_STICKY)) != 0);
        -: 1880:
    #####: 1881:  ret_value = ecma_op_object_put (regexp_object_p,
        -: 1882:                                  ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 1883:                                  ecma_make_integer_value (0),
        -: 1884:                                  true);
        -: 1885:
    #####: 1886:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1887:  {
    #####: 1888:    goto cleanup_context;
        -: 1889:  }
        -: 1890:
    #####: 1891:  JERRY_ASSERT (ecma_is_value_boolean (ret_value));
        -: 1892:
    #####: 1893:match_failed:
        -: 1894:  /* 12.a.ii */
    #####: 1895:  ret_value = ECMA_VALUE_NULL;
    #####: 1896:  goto cleanup_context;
        -: 1897:
    #####: 1898:match_found:
    #####: 1899:  JERRY_ASSERT (matched_p != NULL);
        -: 1900:
        -: 1901:  if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 1902:  {
        -: 1903:    ret_value = ecma_raise_range_error (ECMA_ERR_MSG ("Stack limit exceeded"));
        -: 1904:    goto cleanup_context;
        -: 1905:  }
        -: 1906:
    #####: 1907:  JERRY_ASSERT (index <= input_length);
        -: 1908:
        -: 1909:  /* 15. */
    #####: 1910:  if (re_ctx.flags & (RE_FLAG_GLOBAL | RE_FLAG_STICKY))
        -: 1911:  {
        -: 1912:    /* 13-14. */
        -: 1913:    lit_utf8_size_t match_length;
    #####: 1914:    const lit_utf8_byte_t *match_begin_p = re_ctx.captures_p[0].begin_p;
    #####: 1915:    const lit_utf8_byte_t *match_end_p = re_ctx.captures_p[0].end_p;
        -: 1916:
    #####: 1917:    if (input_flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 1918:    {
    #####: 1919:      match_length = (lit_utf8_size_t) (match_end_p - match_begin_p);
        -: 1920:    }
        -: 1921:    else
        -: 1922:    {
    #####: 1923:      match_length = lit_utf8_string_length (match_begin_p,
    #####: 1924:                                             (lit_utf8_size_t) (match_end_p - match_begin_p));
        -: 1925:    }
        -: 1926:
    #####: 1927:    ret_value = ecma_op_object_put (regexp_object_p,
        -: 1928:                                    ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
    #####: 1929:                                    ecma_make_uint32_value ((uint32_t) index + match_length),
        -: 1930:                                    true);
        -: 1931:
    #####: 1932:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1933:    {
    #####: 1934:      goto cleanup_context;
        -: 1935:    }
        -: 1936:
    #####: 1937:    JERRY_ASSERT (ecma_is_value_boolean (ret_value));
        -: 1938:  }
        -: 1939:
        -: 1940:  /* 16-27. */
    #####: 1941:  ret_value = ecma_regexp_create_result_object (&re_ctx, input_string_p, (uint32_t) index);
        -: 1942:
    #####: 1943:cleanup_context:
    #####: 1944:  ecma_regexp_cleanup_context (&re_ctx);
        -: 1945:
    #####: 1946:  if (input_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1947:  {
    #####: 1948:    jmem_heap_free_block ((void *) input_buffer_p, input_size);
        -: 1949:  }
        -: 1950:
    #####: 1951:  return ret_value;
        -: 1952:} /* ecma_regexp_exec_helper */
        -: 1953:
        -: 1954:/**
        -: 1955: * Helper function for converting a RegExp pattern parameter to string.
        -: 1956: *
        -: 1957: * See also:
        -: 1958: *         RegExp.compile
        -: 1959: *         RegExp dispatch call
        -: 1960: *
        -: 1961: * @return empty value if success, error value otherwise
        -: 1962: *         Returned value must be freed with ecma_free_value.
        -: 1963: */
        -: 1964:ecma_string_t *
    #####: 1965:ecma_regexp_read_pattern_str_helper (ecma_value_t pattern_arg) /**< the RegExp pattern */
        -: 1966:{
    #####: 1967:  if (!ecma_is_value_undefined (pattern_arg))
        -: 1968:  {
    #####: 1969:    ecma_string_t *pattern_string_p = ecma_op_to_string (pattern_arg);
    #####: 1970:    if (JERRY_UNLIKELY (pattern_string_p == NULL) || !ecma_string_is_empty (pattern_string_p))
        -: 1971:    {
    #####: 1972:      return pattern_string_p;
        -: 1973:    }
        -: 1974:  }
        -: 1975:
    #####: 1976:  return ecma_get_magic_string (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP);
        -: 1977:} /* ecma_regexp_read_pattern_str_helper */
        -: 1978:
        -: 1979:/**
        -: 1980: * Helper function for RegExp based string searches
        -: 1981: *
        -: 1982: * See also:
        -: 1983: *          ECMA-262 v6, 21.2.5.9
        -: 1984: *
        -: 1985: * @return index of the match
        -: 1986: */
        -: 1987:ecma_value_t
    #####: 1988:ecma_regexp_search_helper (ecma_value_t regexp_arg, /**< regexp argument */
        -: 1989:                           ecma_value_t string_arg) /**< string argument */
        -: 1990:{
        -: 1991:  /* 2. */
    #####: 1992:  if (!ecma_is_value_object (regexp_arg))
        -: 1993:  {
    #####: 1994:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an object"));
        -: 1995:  }
        -: 1996:
    #####: 1997:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 1998:
        -: 1999:  /* 3. */
    #####: 2000:  ecma_string_t *const string_p = ecma_op_to_string (string_arg);
    #####: 2001:  if (string_p == NULL)
        -: 2002:  {
    #####: 2003:    return result;
        -: 2004:  }
        -: 2005:
    #####: 2006:  ecma_object_t *const regexp_object_p = ecma_get_object_from_value (regexp_arg);
        -: 2007:
        -: 2008:  /* 4. */
    #####: 2009:  ecma_string_t *const last_index_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL);
    #####: 2010:  const ecma_value_t prev_last_index = ecma_op_object_get (regexp_object_p, last_index_str_p);
    #####: 2011:  if (ECMA_IS_VALUE_ERROR (prev_last_index))
        -: 2012:  {
    #####: 2013:    goto cleanup_string;
        -: 2014:  }
        -: 2015:
        -: 2016:  /* 5. */
    #####: 2017:  if (prev_last_index != ecma_make_uint32_value (0))
        -: 2018:  {
    #####: 2019:    const ecma_value_t status = ecma_op_object_put (regexp_object_p,
        -: 2020:                                                    last_index_str_p,
        -: 2021:                                                    ecma_make_uint32_value (0),
        -: 2022:                                                    true);
        -: 2023:
    #####: 2024:    if (ECMA_IS_VALUE_ERROR (status))
        -: 2025:    {
    #####: 2026:      goto cleanup_prev_last_index;
        -: 2027:    }
        -: 2028:
    #####: 2029:    JERRY_ASSERT (ecma_is_value_boolean (status));
        -: 2030:  }
        -: 2031:
        -: 2032:  /* 6. */
    #####: 2033:  const ecma_value_t match = ecma_op_regexp_exec (regexp_arg, string_p);
    #####: 2034:  if (ECMA_IS_VALUE_ERROR (match))
        -: 2035:  {
    #####: 2036:    goto cleanup_prev_last_index;
        -: 2037:  }
        -: 2038:
        -: 2039:  /* 7. */
    #####: 2040:  const ecma_value_t current_last_index = ecma_op_object_get (regexp_object_p, last_index_str_p);
    #####: 2041:  if (ECMA_IS_VALUE_ERROR (current_last_index))
        -: 2042:  {
    #####: 2043:    ecma_free_value (match);
    #####: 2044:    goto cleanup_prev_last_index;
        -: 2045:  }
        -: 2046:
    #####: 2047:  const bool same_value = ecma_op_same_value (prev_last_index, current_last_index);
        -: 2048:
    #####: 2049:  ecma_free_value (current_last_index);
        -: 2050:
        -: 2051:  /* 8. */
    #####: 2052:  if (!same_value)
        -: 2053:  {
    #####: 2054:    result = ecma_op_object_put (regexp_object_p, last_index_str_p, prev_last_index, true);
        -: 2055:
    #####: 2056:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2057:    {
    #####: 2058:      ecma_free_value (match);
    #####: 2059:      goto cleanup_prev_last_index;
        -: 2060:    }
        -: 2061:
    #####: 2062:    JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 2063:  }
        -: 2064:
        -: 2065:  /* 9-10. */
    #####: 2066:  if (ecma_is_value_null (match))
        -: 2067:  {
    #####: 2068:    result = ecma_make_int32_value (-1);
        -: 2069:  }
        -: 2070:  else
        -: 2071:  {
    #####: 2072:    ecma_object_t *const match_p = ecma_get_object_from_value (match);
    #####: 2073:    result = ecma_op_object_get_by_magic_id (match_p, LIT_MAGIC_STRING_INDEX);
    #####: 2074:    ecma_deref_object (match_p);
        -: 2075:  }
        -: 2076:
    #####: 2077:cleanup_prev_last_index:
    #####: 2078:  ecma_free_value (prev_last_index);
        -: 2079:
    #####: 2080:cleanup_string:
    #####: 2081:  ecma_deref_ecma_string (string_p);
    #####: 2082:  return result;
        -: 2083:} /* ecma_regexp_search_helper */
        -: 2084:
        -: 2085:/**
        -: 2086: * Helper function for RegExp based string split operation
        -: 2087: *
        -: 2088: * See also:
        -: 2089: *          ECMA-262 v6, 21.2.5.11
        -: 2090: *
        -: 2091: * @return array of split and captured strings
        -: 2092: */
        -: 2093:ecma_value_t
    #####: 2094:ecma_regexp_split_helper (ecma_value_t this_arg, /**< this value */
        -: 2095:                          ecma_value_t string_arg, /**< string value */
        -: 2096:                          ecma_value_t limit_arg) /**< limit value */
        -: 2097:{
        -: 2098:#if JERRY_ESNEXT
        -: 2099:  /* 2. */
    #####: 2100:  if (!ecma_is_value_object (this_arg))
        -: 2101:  {
    #####: 2102:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an object"));
        -: 2103:  }
        -: 2104:
    #####: 2105:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 2106:
        -: 2107:  /* 3-4. */
    #####: 2108:  ecma_string_t *const string_p = ecma_op_to_string (string_arg);
    #####: 2109:  if (string_p == NULL)
        -: 2110:  {
    #####: 2111:    return result;
        -: 2112:  }
        -: 2113:
        -: 2114:  /* 5-6. */
    #####: 2115:  ecma_object_t *const regexp_obj_p = ecma_get_object_from_value (this_arg);
    #####: 2116:  ecma_value_t constructor = ecma_op_species_constructor (regexp_obj_p, ECMA_BUILTIN_ID_REGEXP);
    #####: 2117:  if (ECMA_IS_VALUE_ERROR (constructor))
        -: 2118:  {
    #####: 2119:    goto cleanup_string;
        -: 2120:  }
        -: 2121:
    #####: 2122:  ecma_object_t *const constructor_obj_p = ecma_get_object_from_value (constructor);
        -: 2123:
        -: 2124:  /* 7-8. */
    #####: 2125:  ecma_value_t flags = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_FLAGS);
    #####: 2126:  if (ECMA_IS_VALUE_ERROR (flags))
        -: 2127:  {
    #####: 2128:    ecma_deref_object (constructor_obj_p);
    #####: 2129:    goto cleanup_string;
        -: 2130:  }
        -: 2131:
    #####: 2132:  ecma_string_t *flags_str_p = ecma_op_to_string (flags);
    #####: 2133:  ecma_free_value (flags);
        -: 2134:
    #####: 2135:  if (JERRY_UNLIKELY (flags_str_p == NULL))
        -: 2136:  {
    #####: 2137:    ecma_deref_object (constructor_obj_p);
    #####: 2138:    goto cleanup_string;
        -: 2139:  }
        -: 2140:
    #####: 2141:  lit_utf8_size_t flags_size;
    #####: 2142:  uint8_t flags_str_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 2143:  const lit_utf8_byte_t *flags_buffer_p = ecma_string_get_chars (flags_str_p,
        -: 2144:                                                                 &flags_size,
        -: 2145:                                                                 NULL,
        -: 2146:                                                                 NULL,
        -: 2147:                                                                 &flags_str_flags);
        -: 2148:
    #####: 2149:  bool unicode = false;
    #####: 2150:  bool sticky = false;
        -: 2151:
        -: 2152:  /* 9-11. */
    #####: 2153:  const lit_utf8_byte_t *const flags_end_p = flags_buffer_p + flags_size;
    #####: 2154:  for (const lit_utf8_byte_t *current_p = flags_buffer_p; current_p < flags_end_p; ++current_p)
        -: 2155:  {
    #####: 2156:    switch (*current_p)
        -: 2157:    {
    #####: 2158:      case LIT_CHAR_LOWERCASE_U:
        -: 2159:      {
    #####: 2160:        unicode = true;
    #####: 2161:        break;
        -: 2162:      }
    #####: 2163:      case LIT_CHAR_LOWERCASE_Y:
        -: 2164:      {
    #####: 2165:        sticky = true;
    #####: 2166:        break;
        -: 2167:      }
        -: 2168:    }
        -: 2169:  }
        -: 2170:
    #####: 2171:  if (flags_str_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2172:  {
    #####: 2173:    jmem_heap_free_block ((void *) flags_buffer_p, flags_size);
        -: 2174:  }
        -: 2175:
        -: 2176:  /* 12. */
    #####: 2177:  if (!sticky)
        -: 2178:  {
    #####: 2179:    ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (flags_str_p);
    #####: 2180:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_LOWERCASE_Y);
        -: 2181:
    #####: 2182:    ecma_deref_ecma_string (flags_str_p);
    #####: 2183:    flags_str_p = ecma_stringbuilder_finalize (&builder);
        -: 2184:  }
        -: 2185:
        -: 2186:  /* 13-14. */
    #####: 2187:  ecma_value_t arguments[] = { this_arg, ecma_make_string_value (flags_str_p) };
    #####: 2188:  ecma_value_t splitter = ecma_op_function_construct (constructor_obj_p, constructor_obj_p, arguments, 2);
        -: 2189:
    #####: 2190:  ecma_deref_ecma_string (flags_str_p);
    #####: 2191:  ecma_deref_object (constructor_obj_p);
        -: 2192:
    #####: 2193:  if (ECMA_IS_VALUE_ERROR (splitter))
        -: 2194:  {
    #####: 2195:    goto cleanup_string;
        -: 2196:  }
        -: 2197:
    #####: 2198:  ecma_object_t *const splitter_obj_p = ecma_get_object_from_value (splitter);
        -: 2199:
        -: 2200:  /* 17. */
    #####: 2201:  uint32_t limit = UINT32_MAX - 1;
    #####: 2202:  if (!ecma_is_value_undefined (limit_arg))
        -: 2203:  {
        -: 2204:    /* ECMA-262 v11, 21.2.5.13 13 */
    #####: 2205:    ecma_number_t num;
    #####: 2206:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (limit_arg, &num)))
        -: 2207:    {
    #####: 2208:      goto cleanup_splitter;
        -: 2209:    }
    #####: 2210:    limit = ecma_number_to_uint32 (num);
        -: 2211:  }
        -: 2212:
        -: 2213:  /* 15. */
    #####: 2214:  ecma_object_t *const array_p = ecma_op_new_array_object (0);
    #####: 2215:  ecma_value_t array = ecma_make_object_value (array_p);
        -: 2216:
        -: 2217:  /* 21. */
    #####: 2218:  if (limit == 0)
        -: 2219:  {
    #####: 2220:    result = array;
    #####: 2221:    goto cleanup_splitter;
        -: 2222:  }
        -: 2223:
    #####: 2224:  const lit_utf8_size_t string_length = ecma_string_get_length (string_p);
        -: 2225:
    #####: 2226:  uint32_t array_length = 0;
        -: 2227:
        -: 2228:  /* 22. */
    #####: 2229:  if (string_length == 0)
        -: 2230:  {
    #####: 2231:    const ecma_value_t match = ecma_op_regexp_exec (splitter, string_p);
        -: 2232:
    #####: 2233:    if (ECMA_IS_VALUE_ERROR (match))
        -: 2234:    {
    #####: 2235:      goto cleanup_array;
        -: 2236:    }
        -: 2237:
    #####: 2238:    if (ecma_is_value_null (match))
        -: 2239:    {
    #####: 2240:      result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2241:                                                      array_length,
        -: 2242:                                                      ecma_make_string_value (string_p),
        -: 2243:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2244:      JERRY_ASSERT (ecma_is_value_true (result));
        -: 2245:    }
        -: 2246:
    #####: 2247:    ecma_free_value (match);
    #####: 2248:    result = array;
    #####: 2249:    goto cleanup_splitter;
        -: 2250:  }
        -: 2251:
        -: 2252:  /* 23. */
    #####: 2253:  ecma_length_t current_index = 0;
    #####: 2254:  ecma_length_t previous_index = 0;
        -: 2255:
    #####: 2256:  ecma_string_t *const lastindex_str_p = ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL);
        -: 2257:
        -: 2258:  /* 24. */
    #####: 2259:  while (current_index < string_length)
        -: 2260:  {
        -: 2261:    /* 24.a-b. */
    #####: 2262:    ecma_value_t index_value = ecma_make_length_value (current_index);
    #####: 2263:    result = ecma_op_object_put (splitter_obj_p,
        -: 2264:                                 lastindex_str_p,
        -: 2265:                                 index_value,
        -: 2266:                                 true);
        -: 2267:
    #####: 2268:    ecma_free_value (index_value);
        -: 2269:
    #####: 2270:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2271:    {
    #####: 2272:      goto cleanup_array;
        -: 2273:    }
        -: 2274:
    #####: 2275:    JERRY_ASSERT (ecma_is_value_true (result));
        -: 2276:
        -: 2277:    /* 24.c-d. */
    #####: 2278:    result = ecma_op_regexp_exec (splitter, string_p);
    #####: 2279:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2280:    {
    #####: 2281:      goto cleanup_array;
        -: 2282:    }
        -: 2283:
        -: 2284:    /* 24.e. */
    #####: 2285:    if (ecma_is_value_null (result))
        -: 2286:    {
    #####: 2287:      current_index = ecma_op_advance_string_index (string_p, current_index, unicode);
    #####: 2288:      continue;
        -: 2289:    }
        -: 2290:
    #####: 2291:    ecma_object_t *const match_array_p = ecma_get_object_from_value (result);
        -: 2292:
        -: 2293:    /* 24.f.i. */
    #####: 2294:    result = ecma_op_object_get (splitter_obj_p, lastindex_str_p);
    #####: 2295:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2296:    {
    #####: 2297:      ecma_deref_object (match_array_p);
    #####: 2298:      goto cleanup_array;
        -: 2299:    }
        -: 2300:
    #####: 2301:    ecma_length_t end_index;
    #####: 2302:    const ecma_value_t length_value = ecma_op_to_length (result, &end_index);
    #####: 2303:    ecma_free_value (result);
        -: 2304:
    #####: 2305:    if (ECMA_IS_VALUE_ERROR (length_value))
        -: 2306:    {
    #####: 2307:      result = ECMA_VALUE_ERROR;
    #####: 2308:      ecma_deref_object (match_array_p);
    #####: 2309:      goto cleanup_array;
        -: 2310:    }
        -: 2311:
        -: 2312:    /* ECMA-262 v11, 21.2.5.11 19.d.ii */
    #####: 2313:    if (end_index > string_length)
        -: 2314:    {
    #####: 2315:      end_index = string_length;
        -: 2316:    }
        -: 2317:
        -: 2318:    /* 24.f.iii. */
    #####: 2319:    if (previous_index == end_index)
        -: 2320:    {
    #####: 2321:      ecma_deref_object (match_array_p);
    #####: 2322:      current_index = ecma_op_advance_string_index (string_p, current_index, unicode);
    #####: 2323:      continue;
        -: 2324:    }
        -: 2325:
        -: 2326:    /* 24.f.iv.1-4. */
    #####: 2327:    JERRY_ASSERT (previous_index <= string_length && current_index <= string_length);
    #####: 2328:    ecma_string_t *const split_str_p = ecma_string_substr (string_p,
        -: 2329:                                                           (lit_utf8_size_t) previous_index,
        -: 2330:                                                           (lit_utf8_size_t) current_index);
        -: 2331:
    #####: 2332:    result = ecma_builtin_helper_def_prop_by_index (array_p,
    #####: 2333:                                                    array_length++,
        -: 2334:                                                    ecma_make_string_value (split_str_p),
        -: 2335:                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2336:    JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2337:    ecma_deref_ecma_string (split_str_p);
        -: 2338:
        -: 2339:    /* 24.f.iv.5. */
    #####: 2340:    if (array_length == limit)
        -: 2341:    {
    #####: 2342:      ecma_deref_object (match_array_p);
    #####: 2343:      result = array;
    #####: 2344:      goto cleanup_splitter;
        -: 2345:    }
        -: 2346:
        -: 2347:    /* 24.f.iv.6. */
    #####: 2348:    previous_index = end_index;
        -: 2349:
        -: 2350:    /* 24.f.iv.7-8. */
    #####: 2351:    ecma_length_t match_length;
    #####: 2352:    result = ecma_op_object_get_length (match_array_p, &match_length);
    #####: 2353:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2354:    {
    #####: 2355:      ecma_deref_object (match_array_p);
    #####: 2356:      goto cleanup_array;
        -: 2357:    }
        -: 2358:
        -: 2359:    /* 24.f.iv.9. */
    #####: 2360:    match_length = (match_length > 0) ? match_length - 1 : match_length;
        -: 2361:
    #####: 2362:    ecma_length_t match_index = 1;
    #####: 2363:    while (match_index <= match_length)
        -: 2364:    {
        -: 2365:      /* 24.f.iv.11.a-b. */
    #####: 2366:      result = ecma_op_object_get_by_index (match_array_p, match_index++);
    #####: 2367:      if (ECMA_IS_VALUE_ERROR (result))
        -: 2368:      {
    #####: 2369:        ecma_deref_object (match_array_p);
    #####: 2370:        goto cleanup_array;
        -: 2371:      }
        -: 2372:
    #####: 2373:      const ecma_value_t capture = result;
        -: 2374:
        -: 2375:      /* 24.f.iv.11.c. */
    #####: 2376:      result = ecma_builtin_helper_def_prop_by_index (array_p,
    #####: 2377:                                                      array_length++,
        -: 2378:                                                      capture,
        -: 2379:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2380:      JERRY_ASSERT (ecma_is_value_true (result));
        -: 2381:
    #####: 2382:      ecma_free_value (capture);
        -: 2383:
    #####: 2384:      if (array_length == limit)
        -: 2385:      {
    #####: 2386:        ecma_deref_object (match_array_p);
    #####: 2387:        result = array;
    #####: 2388:        goto cleanup_splitter;
        -: 2389:      }
        -: 2390:    }
        -: 2391:
        -: 2392:    /* 24.f.iv.12. */
    #####: 2393:    JERRY_ASSERT (end_index <= UINT32_MAX);
    #####: 2394:    current_index = (uint32_t) end_index;
        -: 2395:
    #####: 2396:    ecma_deref_object (match_array_p);
        -: 2397:  }
        -: 2398:
    #####: 2399:  JERRY_ASSERT (previous_index <= string_length);
    #####: 2400:  ecma_string_t *const end_str_p = ecma_string_substr (string_p, (lit_utf8_size_t) previous_index, string_length);
    #####: 2401:  result = ecma_builtin_helper_def_prop_by_index (array_p,
    #####: 2402:                                                  array_length++,
        -: 2403:                                                  ecma_make_string_value (end_str_p),
        -: 2404:                                                  ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 2405:  JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2406:  ecma_deref_ecma_string (end_str_p);
        -: 2407:
    #####: 2408:  result = array;
    #####: 2409:  goto cleanup_splitter;
        -: 2410:
    #####: 2411:cleanup_array:
    #####: 2412:  ecma_deref_object (array_p);
    #####: 2413:cleanup_splitter:
    #####: 2414:  ecma_deref_object (splitter_obj_p);
    #####: 2415:cleanup_string:
    #####: 2416:  ecma_deref_ecma_string (string_p);
        -: 2417:
    #####: 2418:  return result;
        -: 2419:#else /* !JERRY_ESNEXT */
    #####: 2420:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 2421:
        -: 2422:  /* 2. */
    #####: 2423:  ecma_string_t *string_p = ecma_op_to_string (string_arg);
    #####: 2424:  if (JERRY_UNLIKELY (string_p == NULL))
        -: 2425:  {
        -: 2426:    return result;
        -: 2427:  }
        -: 2428:
        -: 2429:  /* 5. */
    #####: 2430:  uint32_t limit = UINT32_MAX;
    #####: 2431:  if (!ecma_is_value_undefined (limit_arg))
        -: 2432:  {
    #####: 2433:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_length (limit_arg, &limit)))
        -: 2434:    {
        -: 2435:      goto cleanup_string;
        -: 2436:    }
        -: 2437:  }
        -: 2438:
        -: 2439:  /* 15. */
    #####: 2440:  ecma_object_t *const array_p = ecma_op_new_array_object (0);
    #####: 2441:  ecma_value_t array = ecma_make_object_value (array_p);
        -: 2442:
        -: 2443:  /* 21. */
    #####: 2444:  if (limit == 0)
        -: 2445:  {
        -: 2446:    result = array;
        -: 2447:    goto cleanup_string;
        -: 2448:  }
        -: 2449:
    #####: 2450:  uint32_t array_length = 0;
        -: 2451:
    #####: 2452:  ecma_object_t *const regexp_p = ecma_get_object_from_value (this_arg);
    #####: 2453:  ecma_extended_object_t *const ext_object_p = (ecma_extended_object_t *) regexp_p;
    #####: 2454:  re_compiled_code_t *const bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, ext_object_p->u.cls.u3.value);
        -: 2455:
        -: 2456:  lit_utf8_size_t string_size;
        -: 2457:  lit_utf8_size_t string_length;
    #####: 2458:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 2459:  const lit_utf8_byte_t *string_buffer_p = ecma_string_get_chars (string_p,
        -: 2460:                                                                  &string_size,
        -: 2461:                                                                  &string_length,
        -: 2462:                                                                  NULL,
        -: 2463:                                                                  &string_flags);
        -: 2464:
    #####: 2465:  const lit_utf8_byte_t *current_str_p = string_buffer_p;
    #####: 2466:  const lit_utf8_byte_t *previous_str_p = string_buffer_p;
    #####: 2467:  const lit_utf8_byte_t *const string_end_p = string_buffer_p + string_size;
        -: 2468:
        -: 2469:  ecma_regexp_ctx_t re_ctx;
    #####: 2470:  ecma_regexp_initialize_context (&re_ctx,
        -: 2471:                                  bc_p,
        -: 2472:                                  string_buffer_p,
        -: 2473:                                  string_buffer_p + string_size);
        -: 2474:
    #####: 2475:  uint8_t *const bc_start_p = (uint8_t *) (bc_p + 1);
        -: 2476:
    #####: 2477:  if (string_length == 0)
        -: 2478:  {
    #####: 2479:    const lit_utf8_byte_t *const matched_p = ecma_regexp_match (&re_ctx, bc_start_p, current_str_p);
        -: 2480:
        -: 2481:    if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 2482:    {
        -: 2483:      result = ecma_raise_range_error (ECMA_ERR_MSG ("Stack limit exceeded"));
        -: 2484:      goto cleanup_array;
        -: 2485:    }
        -: 2486:
    #####: 2487:    if (matched_p == NULL)
        -: 2488:    {
    #####: 2489:      result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2490:                                                      array_length,
        -: 2491:                                                      ecma_make_string_value (string_p),
        -: 2492:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2493:      JERRY_ASSERT (ecma_is_value_true (result));
        -: 2494:    }
        -: 2495:
        -: 2496:    result = array;
        -: 2497:    goto cleanup_context;
        -: 2498:  }
        -: 2499:
        -: 2500:  /* 13. */
    #####: 2501:  while (current_str_p < string_end_p)
        -: 2502:  {
        -: 2503:    /* 13.a. */
    #####: 2504:    const lit_utf8_byte_t *const matched_p = ecma_regexp_match (&re_ctx, bc_start_p, current_str_p);
        -: 2505:
        -: 2506:    if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 2507:    {
        -: 2508:      result = ecma_raise_range_error (ECMA_ERR_MSG ("Stack limit exceeded"));
        -: 2509:      goto cleanup_array;
        -: 2510:    }
        -: 2511:
    #####: 2512:    if (matched_p == NULL || matched_p == previous_str_p)
        -: 2513:    {
    #####: 2514:      lit_utf8_incr (&current_str_p);
    #####: 2515:      continue;
        -: 2516:    }
        -: 2517:
        -: 2518:    /* 13.c.iii.1. */
    #####: 2519:    ecma_string_t *const str_p = ecma_new_ecma_string_from_utf8 (previous_str_p,
    #####: 2520:                                                                 (lit_utf8_size_t) (current_str_p - previous_str_p));
        -: 2521:
    #####: 2522:    result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2523:                                                    array_length++,
        -: 2524:                                                    ecma_make_string_value (str_p),
        -: 2525:                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2526:    JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2527:    ecma_deref_ecma_string (str_p);
        -: 2528:
    #####: 2529:    if (array_length == limit)
        -: 2530:    {
        -: 2531:      result = array;
        -: 2532:      goto cleanup_context;
        -: 2533:    }
        -: 2534:
        -: 2535:    /* 13.c.iii.5. */
        -: 2536:    previous_str_p = matched_p;
        -: 2537:
        -: 2538:    uint32_t index = 1;
    #####: 2539:    while (index < re_ctx.captures_count)
        -: 2540:    {
    #####: 2541:      const ecma_value_t capture = ecma_regexp_get_capture_value (re_ctx.captures_p + index);
    #####: 2542:      result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2543:                                                      array_length++,
        -: 2544:                                                      capture,
        -: 2545:                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2546:      JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2547:      ecma_free_value (capture);
        -: 2548:
    #####: 2549:      if (array_length == limit)
        -: 2550:      {
        -: 2551:        result = array;
        -: 2552:        goto cleanup_context;
        -: 2553:      }
        -: 2554:
    #####: 2555:      index++;
        -: 2556:    }
        -: 2557:
        -: 2558:    /* 13.c.iii.8. */
    #####: 2559:    current_str_p = matched_p;
        -: 2560:  }
        -: 2561:
    #####: 2562:  ecma_string_t *const str_p = ecma_new_ecma_string_from_utf8 (previous_str_p,
    #####: 2563:                                                               (lit_utf8_size_t) (string_end_p - previous_str_p));
        -: 2564:
    #####: 2565:  result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 2566:                                                  array_length++,
        -: 2567:                                                  ecma_make_string_value (str_p),
        -: 2568:                                                  ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 2569:  JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2570:  ecma_deref_ecma_string (str_p);
        -: 2571:
    #####: 2572:  result = array;
    #####: 2573:  goto cleanup_context;
        -: 2574:
        -: 2575:cleanup_array:
        -: 2576:  ecma_deref_object (array_p);
    #####: 2577:cleanup_context:
    #####: 2578:  ecma_regexp_cleanup_context (&re_ctx);
    #####: 2579:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2580:  {
    #####: 2581:    jmem_heap_free_block ((void *) string_buffer_p, string_size);
        -: 2582:  }
    #####: 2583:cleanup_string:
    #####: 2584:  ecma_deref_ecma_string (string_p);
        -: 2585:
    #####: 2586:  return result;
        -: 2587:#endif /* JERRY_ESNEXT */
        -: 2588:} /* ecma_regexp_split_helper */
        -: 2589:
        -: 2590:/**
        -: 2591: * Fast path for RegExp based replace operation
        -: 2592: *
        -: 2593: * This method assumes the following:
        -: 2594: *   - The RegExp object is a built-in RegExp
        -: 2595: *   - The 'exec' method of the RegExp object is the built-in 'exec' method
        -: 2596: *   - The 'lastIndex' property is writable
        -: 2597: *
        -: 2598: * The standard would normally require us to first execute the regexp and collect the results,
        -: 2599: * and after that iterate over the collected results and replace them.
        -: 2600: * The assumptions above guarantee that during the matching phase there will be no exceptions thrown,
        -: 2601: * which means we can do the match/replace in a single loop, without collecting the results.
        -: 2602: *
        -: 2603: * @return string value if successful
        -: 2604: *         thrown value otherwise
        -: 2605: */
        -: 2606:static ecma_value_t
    #####: 2607:ecma_regexp_replace_helper_fast (ecma_replace_context_t *ctx_p, /**<replace context */
        -: 2608:                                 ecma_extended_object_t *re_obj_p, /**< regexp object */
        -: 2609:                                 ecma_string_t *string_p, /**< source string */
        -: 2610:                                 ecma_value_t replace_arg) /**< replace argument */
        -: 2611:{
    #####: 2612:  const re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
    #####: 2613:  ecma_bytecode_ref ((ecma_compiled_code_t *) bc_p);
        -: 2614:
    #####: 2615:  JERRY_ASSERT (bc_p != NULL);
        -: 2616:
    #####: 2617:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 2618:  lit_utf8_size_t string_length;
    #####: 2619:  ctx_p->string_p = ecma_string_get_chars (string_p,
        -: 2620:                                           &(ctx_p->string_size),
        -: 2621:                                           &string_length,
        -: 2622:                                           NULL,
        -: 2623:                                           &string_flags);
        -: 2624:
    #####: 2625:  const lit_utf8_byte_t *const string_end_p = ctx_p->string_p + ctx_p->string_size;
    #####: 2626:  const uint8_t *const bc_start_p = (const uint8_t *) (bc_p + 1);
    #####: 2627:  const lit_utf8_byte_t *matched_p = NULL;
    #####: 2628:  const lit_utf8_byte_t *current_p = ctx_p->string_p;
    #####: 2629:  const lit_utf8_byte_t *last_append_p = current_p;
    #####: 2630:  ecma_length_t index;
        -: 2631:
    #####: 2632:  ecma_regexp_ctx_t re_ctx;
    #####: 2633:  ecma_regexp_initialize_context (&re_ctx,
        -: 2634:                                  bc_p,
        -: 2635:                                  ctx_p->string_p,
        -: 2636:                                  string_end_p);
        -: 2637:
        -: 2638:  /* lastIndex must be accessed to remain consistent with the standard, even though we may not need the value. */
    #####: 2639:  ecma_value_t lastindex_value = ecma_op_object_get_by_magic_id ((ecma_object_t *) re_obj_p,
        -: 2640:                                                                 LIT_MAGIC_STRING_LASTINDEX_UL);
    #####: 2641:  ecma_value_t result = ecma_op_to_length (lastindex_value, &index);
    #####: 2642:  ecma_free_value (lastindex_value);
        -: 2643:
    #####: 2644:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2645:  {
    #####: 2646:    goto cleanup_context;
        -: 2647:  }
        -: 2648:
        -: 2649:#if JERRY_ESNEXT
        -: 2650:  /* Only non-global sticky matches use the lastIndex value, otherwise the starting index is 0. */
    #####: 2651:  if (JERRY_UNLIKELY ((ctx_p->flags & RE_FLAG_GLOBAL) == 0 && (re_ctx.flags & RE_FLAG_STICKY) != 0))
        -: 2652:  {
    #####: 2653:    if (index > string_length)
        -: 2654:    {
    #####: 2655:      result = ecma_op_object_put ((ecma_object_t *) re_obj_p,
        -: 2656:                                   ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 2657:                                   ecma_make_uint32_value (0),
        -: 2658:                                   true);
        -: 2659:
    #####: 2660:      if (!ECMA_IS_VALUE_ERROR (result))
        -: 2661:      {
    #####: 2662:        JERRY_ASSERT (ecma_is_value_true (result));
    #####: 2663:        ecma_ref_ecma_string (string_p);
    #####: 2664:        result = ecma_make_string_value (string_p);
        -: 2665:      }
        -: 2666:
    #####: 2667:      goto cleanup_context;
        -: 2668:    }
        -: 2669:
    #####: 2670:    if (string_flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 2671:    {
    #####: 2672:      current_p += index;
        -: 2673:    }
        -: 2674:    else
        -: 2675:    {
    #####: 2676:      ecma_length_t counter = index;
    #####: 2677:      while (counter--)
        -: 2678:      {
    #####: 2679:        lit_utf8_incr (&current_p);
        -: 2680:      }
        -: 2681:    }
        -: 2682:  }
        -: 2683:  else
        -: 2684:#endif /* JERRY_ESNEXT */
        -: 2685:  {
    #####: 2686:    index = 0;
        -: 2687:  }
        -: 2688:
    #####: 2689:  ctx_p->builder = ecma_stringbuilder_create ();
    #####: 2690:  ctx_p->capture_count = re_ctx.captures_count;
    #####: 2691:  ctx_p->u.captures_p = re_ctx.captures_p;
        -: 2692:
        -: 2693:  while (true)
        -: 2694:  {
    #####: 2695:    matched_p = ecma_regexp_match (&re_ctx, bc_start_p, current_p);
        -: 2696:
    #####: 2697:    if (matched_p != NULL)
        -: 2698:    {
        -: 2699:      if (ECMA_RE_STACK_LIMIT_REACHED (matched_p))
        -: 2700:      {
        -: 2701:        result = ecma_raise_range_error (ECMA_ERR_MSG ("Stack limit exceeded"));
        -: 2702:        goto cleanup_builder;
        -: 2703:      }
        -: 2704:
    #####: 2705:      const lit_utf8_size_t remaining_size = (lit_utf8_size_t) (current_p - last_append_p);
    #####: 2706:      ecma_stringbuilder_append_raw (&(ctx_p->builder), last_append_p, remaining_size);
        -: 2707:
    #####: 2708:      if (ctx_p->replace_str_p != NULL)
        -: 2709:      {
    #####: 2710:        ctx_p->matched_p = current_p;
    #####: 2711:        const ecma_regexp_capture_t *const global_capture_p = re_ctx.captures_p;
    #####: 2712:        ctx_p->matched_size = (lit_utf8_size_t) (global_capture_p->end_p - global_capture_p->begin_p);
    #####: 2713:        ctx_p->match_byte_pos = (lit_utf8_size_t) (current_p - re_ctx.input_start_p);
        -: 2714:
    #####: 2715:        ecma_builtin_replace_substitute (ctx_p);
        -: 2716:      }
        -: 2717:      else
        -: 2718:      {
    #####: 2719:        ecma_collection_t *arguments_p = ecma_new_collection ();
        -: 2720:
    #####: 2721:        for (uint32_t i = 0; i < re_ctx.captures_count; i++)
        -: 2722:        {
    #####: 2723:          ecma_value_t capture = ecma_regexp_get_capture_value (re_ctx.captures_p + i);
    #####: 2724:          ecma_collection_push_back (arguments_p, capture);
        -: 2725:        }
        -: 2726:
    #####: 2727:        ecma_collection_push_back (arguments_p, ecma_make_length_value (index));
    #####: 2728:        ecma_ref_ecma_string (string_p);
    #####: 2729:        ecma_collection_push_back (arguments_p, ecma_make_string_value (string_p));
    #####: 2730:        ecma_object_t *function_p = ecma_get_object_from_value (replace_arg);
        -: 2731:
    #####: 2732:        result = ecma_op_function_call (function_p,
        -: 2733:                                        ECMA_VALUE_UNDEFINED,
    #####: 2734:                                        arguments_p->buffer_p,
        -: 2735:                                        arguments_p->item_count);
        -: 2736:
    #####: 2737:        ecma_collection_free (arguments_p);
        -: 2738:
    #####: 2739:        if (ECMA_IS_VALUE_ERROR (result))
        -: 2740:        {
    #####: 2741:          goto cleanup_builder;
        -: 2742:        }
        -: 2743:
        -: 2744:        /* 16.m.v */
    #####: 2745:        ecma_string_t *const replace_result_p = ecma_op_to_string (result);
    #####: 2746:        ecma_free_value (result);
        -: 2747:
    #####: 2748:        if (replace_result_p == NULL)
        -: 2749:        {
    #####: 2750:          result = ECMA_VALUE_ERROR;
    #####: 2751:          goto cleanup_builder;
        -: 2752:        }
        -: 2753:
    #####: 2754:        ecma_stringbuilder_append (&(ctx_p->builder), replace_result_p);
    #####: 2755:        ecma_deref_ecma_string (replace_result_p);
        -: 2756:      }
        -: 2757:
    #####: 2758:      const ecma_regexp_capture_t *global_capture_p = re_ctx.captures_p;
    #####: 2759:      last_append_p = global_capture_p->end_p;
        -: 2760:
    #####: 2761:      const lit_utf8_size_t matched_size = (lit_utf8_size_t) (global_capture_p->end_p - global_capture_p->begin_p);
        -: 2762:
    #####: 2763:      const bool is_ascii = (string_flags & ECMA_STRING_FLAG_IS_ASCII) != 0;
    #####: 2764:      index += is_ascii ? matched_size : lit_utf8_string_length (current_p, matched_size);
        -: 2765:
    #####: 2766:      if (!(ctx_p->flags & RE_FLAG_GLOBAL))
        -: 2767:      {
        -: 2768:#if JERRY_ESNEXT
    #####: 2769:        if (JERRY_UNLIKELY ((re_ctx.flags & RE_FLAG_STICKY) != 0))
        -: 2770:        {
    #####: 2771:          ecma_value_t index_value = ecma_make_length_value (index);
    #####: 2772:          result = ecma_op_object_put ((ecma_object_t *) re_obj_p,
        -: 2773:                                       ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 2774:                                       index_value,
        -: 2775:                                       true);
        -: 2776:
    #####: 2777:          ecma_free_value (index_value);
        -: 2778:
    #####: 2779:          if (ECMA_IS_VALUE_ERROR (result))
        -: 2780:          {
    #####: 2781:            goto cleanup_builder;
        -: 2782:          }
        -: 2783:        }
        -: 2784:#endif /* JERRY_ESNEXT */
        -: 2785:
    #####: 2786:        break;
        -: 2787:      }
        -: 2788:
    #####: 2789:      if (matched_size > 0)
        -: 2790:      {
    #####: 2791:        current_p = last_append_p;
    #####: 2792:        continue;
        -: 2793:      }
        -: 2794:    }
        -: 2795:#if JERRY_ESNEXT
    #####: 2796:    else if (JERRY_UNLIKELY ((re_ctx.flags & RE_FLAG_STICKY) != 0))
        -: 2797:    {
    #####: 2798:      result = ecma_op_object_put ((ecma_object_t *) re_obj_p,
        -: 2799:                                   ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 2800:                                   ecma_make_uint32_value (0),
        -: 2801:                                   true);
        -: 2802:
    #####: 2803:      if (ECMA_IS_VALUE_ERROR (result))
        -: 2804:      {
    #####: 2805:        goto cleanup_builder;
        -: 2806:      }
        -: 2807:
    #####: 2808:      break;
        -: 2809:    }
        -: 2810:#endif /* JERRY_ESNEXT */
        -: 2811:
    #####: 2812:    if (current_p >= string_end_p)
        -: 2813:    {
    #####: 2814:      break;
        -: 2815:    }
        -: 2816:
        -: 2817:#if JERRY_ESNEXT
    #####: 2818:    if ((ctx_p->flags & RE_FLAG_UNICODE) != 0)
        -: 2819:    {
    #####: 2820:      index++;
    #####: 2821:      const lit_code_point_t cp = ecma_regexp_unicode_advance (&current_p,
        -: 2822:                                                               string_end_p);
        -: 2823:
    #####: 2824:      if (cp > LIT_UTF16_CODE_UNIT_MAX)
        -: 2825:      {
    #####: 2826:        index++;
        -: 2827:      }
        -: 2828:
    #####: 2829:      continue;
        -: 2830:    }
        -: 2831:#endif /* JERRY_ESNEXT */
        -: 2832:
    #####: 2833:    index++;
    #####: 2834:    lit_utf8_incr (&current_p);
        -: 2835:  }
        -: 2836:
    #####: 2837:  const lit_utf8_size_t trailing_size = (lit_utf8_size_t) (string_end_p - last_append_p);
    #####: 2838:  ecma_stringbuilder_append_raw (&(ctx_p->builder), last_append_p, trailing_size);
        -: 2839:
    #####: 2840:  result = ecma_make_string_value (ecma_stringbuilder_finalize (&(ctx_p->builder)));
    #####: 2841:  goto cleanup_context;
        -: 2842:
    #####: 2843:cleanup_builder:
    #####: 2844:  ecma_stringbuilder_destroy (&(ctx_p->builder));
        -: 2845:
    #####: 2846:cleanup_context:
    #####: 2847:  ecma_regexp_cleanup_context (&re_ctx);
    #####: 2848:  ecma_bytecode_deref ((ecma_compiled_code_t *) bc_p);
        -: 2849:
    #####: 2850:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2851:  {
    #####: 2852:    jmem_heap_free_block ((void *) ctx_p->string_p, ctx_p->string_size);
        -: 2853:  }
        -: 2854:
    #####: 2855:  return result;
        -: 2856:} /* ecma_regexp_replace_helper_fast */
        -: 2857:
        -: 2858:/**
        -: 2859: * Helper function for RegExp based replacing
        -: 2860: *
        -: 2861: * See also:
        -: 2862: *          String.prototype.replace
        -: 2863: *          RegExp.prototype[@@replace]
        -: 2864: *
        -: 2865: * @return result string of the replacement, if successful
        -: 2866: *         error value, otherwise
        -: 2867: */
        -: 2868:ecma_value_t
    #####: 2869:ecma_regexp_replace_helper (ecma_value_t this_arg, /**< this argument */
        -: 2870:                            ecma_value_t string_arg, /**< source string */
        -: 2871:                            ecma_value_t replace_arg) /**< replace string */
        -: 2872:{
        -: 2873:  /* 2. */
    #####: 2874:  if (!ecma_is_value_object (this_arg))
        -: 2875:  {
    #####: 2876:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an object"));
        -: 2877:  }
        -: 2878:
    #####: 2879:  ecma_object_t *this_obj_p = ecma_get_object_from_value (this_arg);
        -: 2880:
    #####: 2881:  ecma_replace_context_t replace_ctx;
    #####: 2882:  replace_ctx.flags = RE_FLAG_EMPTY;
        -: 2883:
        -: 2884:  /* 3. */
    #####: 2885:  ecma_string_t *string_p = ecma_op_to_string (string_arg);
    #####: 2886:  if (string_p == NULL)
        -: 2887:  {
    #####: 2888:    return ECMA_VALUE_ERROR;
        -: 2889:  }
        -: 2890:
    #####: 2891:  ecma_value_t result = ECMA_VALUE_ERROR;
        -: 2892:
        -: 2893:  /* 6. */
    #####: 2894:  replace_ctx.replace_str_p = NULL;
    #####: 2895:  if (!ecma_op_is_callable (replace_arg))
        -: 2896:  {
    #####: 2897:    replace_ctx.replace_str_p = ecma_op_to_string (replace_arg);
        -: 2898:
    #####: 2899:    if (replace_ctx.replace_str_p == NULL)
        -: 2900:    {
    #####: 2901:      goto cleanup_string;
        -: 2902:    }
        -: 2903:  }
        -: 2904:
        -: 2905:  /* 8 */
    #####: 2906:  result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_GLOBAL);
    #####: 2907:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2908:  {
    #####: 2909:    goto cleanup_replace;
        -: 2910:  }
        -: 2911:
    #####: 2912:  if (ecma_op_to_boolean (result))
        -: 2913:  {
    #####: 2914:    replace_ctx.flags |= RE_FLAG_GLOBAL;
        -: 2915:  }
        -: 2916:
    #####: 2917:  ecma_free_value (result);
        -: 2918:
        -: 2919:#if JERRY_ESNEXT
    #####: 2920:  const lit_utf8_size_t string_length = ecma_string_get_length (string_p);
        -: 2921:#endif /* JERRY_ESNEXT */
        -: 2922:
        -: 2923:  /* 10. */
    #####: 2924:  if (replace_ctx.flags & RE_FLAG_GLOBAL)
        -: 2925:  {
        -: 2926:#if JERRY_ESNEXT
    #####: 2927:    result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_UNICODE);
    #####: 2928:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2929:    {
    #####: 2930:      goto cleanup_replace;
        -: 2931:    }
        -: 2932:
    #####: 2933:    if (ecma_op_to_boolean (result))
        -: 2934:    {
    #####: 2935:      replace_ctx.flags |= RE_FLAG_UNICODE;
        -: 2936:    }
        -: 2937:
    #####: 2938:    ecma_free_value (result);
        -: 2939:#endif /* JERRY_ESNEXT */
        -: 2940:
    #####: 2941:    result = ecma_op_object_put (this_obj_p,
        -: 2942:                                 ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 2943:                                 ecma_make_uint32_value (0),
        -: 2944:                                 true);
    #####: 2945:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2946:    {
    #####: 2947:      goto cleanup_replace;
        -: 2948:    }
        -: 2949:
    #####: 2950:    JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 2951:  }
        -: 2952:
        -: 2953:#if !JERRY_ESNEXT
    #####: 2954:  result = ecma_regexp_replace_helper_fast (&replace_ctx,
        -: 2955:                                            (ecma_extended_object_t *) this_obj_p,
        -: 2956:                                            string_p,
        -: 2957:                                            replace_arg);
        -: 2958:
    #####: 2959:  goto cleanup_replace;
        -: 2960:#else /* JERRY_ESNEXT */
    #####: 2961:  result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_EXEC);
        -: 2962:
    #####: 2963:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2964:  {
    #####: 2965:    goto cleanup_replace;
        -: 2966:  }
        -: 2967:
        -: 2968:  /* Check for fast path. */
    #####: 2969:  if (ecma_op_is_callable (result))
        -: 2970:  {
    #####: 2971:    ecma_extended_object_t *function_p = (ecma_extended_object_t *) ecma_get_object_from_value (result);
    #####: 2972:    if (ecma_object_class_is (this_obj_p, ECMA_OBJECT_CLASS_REGEXP)
    #####: 2973:        && ecma_builtin_is_regexp_exec (function_p))
        -: 2974:    {
    #####: 2975:      ecma_deref_object ((ecma_object_t *) function_p);
        -: 2976:
    #####: 2977:      result = ecma_regexp_replace_helper_fast (&replace_ctx,
        -: 2978:                                                (ecma_extended_object_t *) this_obj_p,
        -: 2979:                                                string_p,
        -: 2980:                                                replace_arg);
        -: 2981:
    #####: 2982:      goto cleanup_replace;
        -: 2983:    }
        -: 2984:  }
        -: 2985:
    #####: 2986:  ecma_collection_t *results_p = ecma_new_collection ();
        -: 2987:
        -: 2988:  while (true)
    #####: 2989:  {
        -: 2990:    /* 13.a */
    #####: 2991:    if (ecma_op_is_callable (result))
        -: 2992:    {
    #####: 2993:      ecma_object_t *const function_p = ecma_get_object_from_value (result);
        -: 2994:
    #####: 2995:      ecma_value_t arguments[] = { ecma_make_string_value (string_p) };
    #####: 2996:      result = ecma_op_function_call (function_p, this_arg, arguments, 1);
        -: 2997:
    #####: 2998:      ecma_deref_object (function_p);
        -: 2999:
    #####: 3000:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3001:      {
    #####: 3002:        goto cleanup_results;
        -: 3003:      }
        -: 3004:
    #####: 3005:      if (!ecma_is_value_object (result) && !ecma_is_value_null (result))
        -: 3006:      {
    #####: 3007:        ecma_free_value (result);
    #####: 3008:        result = ecma_raise_type_error (ECMA_ERR_MSG ("Return value of 'exec' must be an object or null"));
    #####: 3009:        goto cleanup_results;
        -: 3010:      }
        -: 3011:    }
        -: 3012:    else
        -: 3013:    {
    #####: 3014:      ecma_free_value (result);
        -: 3015:
    #####: 3016:      if (!ecma_object_class_is (this_obj_p, ECMA_OBJECT_CLASS_REGEXP))
        -: 3017:      {
    #####: 3018:        result = ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a valid RegExp object"));
    #####: 3019:        goto cleanup_results;
        -: 3020:      }
        -: 3021:
    #####: 3022:      result = ecma_regexp_exec_helper (this_obj_p, string_p);
        -: 3023:    }
        -: 3024:
        -: 3025:    /* 13.c */
    #####: 3026:    if (ecma_is_value_null (result))
        -: 3027:    {
    #####: 3028:      break;
        -: 3029:    }
        -: 3030:
        -: 3031:    /* 13.d.i */
    #####: 3032:    ecma_collection_push_back (results_p, result);
        -: 3033:
    #####: 3034:    if ((replace_ctx.flags & RE_FLAG_GLOBAL) == 0)
        -: 3035:    {
    #####: 3036:      break;
        -: 3037:    }
        -: 3038:
        -: 3039:    /* 13.d.iii.1 */
    #####: 3040:    result = ecma_op_object_get_by_index (ecma_get_object_from_value (result), 0);
    #####: 3041:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3042:    {
    #####: 3043:      goto cleanup_results;
        -: 3044:    }
        -: 3045:
    #####: 3046:    ecma_string_t *match_str_p = ecma_op_to_string (result);
    #####: 3047:    ecma_free_value (result);
        -: 3048:
    #####: 3049:    if (match_str_p == NULL)
        -: 3050:    {
    #####: 3051:      result = ECMA_VALUE_ERROR;
    #####: 3052:      goto cleanup_results;
        -: 3053:    }
        -: 3054:
    #####: 3055:    const bool is_empty = ecma_string_is_empty (match_str_p);
    #####: 3056:    ecma_deref_ecma_string (match_str_p);
        -: 3057:
        -: 3058:    /* 13.d.iii.3 */
    #####: 3059:    if (is_empty)
        -: 3060:    {
    #####: 3061:      result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);
    #####: 3062:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3063:      {
    #####: 3064:        goto cleanup_results;
        -: 3065:      }
        -: 3066:
    #####: 3067:      ecma_value_t last_index = result;
        -: 3068:
    #####: 3069:      ecma_length_t index;
    #####: 3070:      result = ecma_op_to_length (last_index, &index);
    #####: 3071:      ecma_free_value (last_index);
        -: 3072:
    #####: 3073:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3074:      {
    #####: 3075:        goto cleanup_results;
        -: 3076:      }
        -: 3077:
    #####: 3078:      index = ecma_op_advance_string_index (string_p, index, (replace_ctx.flags & RE_FLAG_UNICODE) != 0);
    #####: 3079:      last_index = ecma_make_length_value (index);
        -: 3080:
        -: 3081:      /* 10.d.iii.3.c */
    #####: 3082:      result = ecma_op_object_put (this_obj_p,
        -: 3083:                                   ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 3084:                                   last_index,
        -: 3085:                                   true);
        -: 3086:
    #####: 3087:      ecma_free_value (last_index);
        -: 3088:
    #####: 3089:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3090:      {
    #####: 3091:        goto cleanup_results;
        -: 3092:      }
        -: 3093:
    #####: 3094:      JERRY_ASSERT (ecma_is_value_boolean (result));
        -: 3095:    }
        -: 3096:
    #####: 3097:    result = ecma_op_object_get_by_magic_id (this_obj_p, LIT_MAGIC_STRING_EXEC);
        -: 3098:
    #####: 3099:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3100:    {
    #####: 3101:      goto cleanup_results;
        -: 3102:    }
        -: 3103:  }
        -: 3104:
    #####: 3105:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 3106:  replace_ctx.string_p = ecma_string_get_chars (string_p,
        -: 3107:                                                &(replace_ctx.string_size),
        -: 3108:                                                NULL,
        -: 3109:                                                NULL,
        -: 3110:                                                &string_flags);
        -: 3111:
        -: 3112:  /* 14. */
    #####: 3113:  replace_ctx.builder = ecma_stringbuilder_create ();
    #####: 3114:  replace_ctx.matched_p = NULL;
    #####: 3115:  replace_ctx.capture_count = 0;
    #####: 3116:  lit_utf8_size_t index = 0;
        -: 3117:
        -: 3118:  /* 15. */
    #####: 3119:  const lit_utf8_byte_t *source_position_p = replace_ctx.string_p;
    #####: 3120:  const lit_utf8_byte_t *const string_end_p = replace_ctx.string_p + replace_ctx.string_size;
        -: 3121:
        -: 3122:  /* 16. */
    #####: 3123:  for (ecma_value_t *current_p = results_p->buffer_p;
    #####: 3124:       current_p < results_p->buffer_p + results_p->item_count;
    #####: 3125:       current_p++)
        -: 3126:  {
        -: 3127:    /* 16.a */
    #####: 3128:    ecma_object_t *current_object_p = ecma_get_object_from_value (*current_p);
        -: 3129:
    #####: 3130:    ecma_length_t capture_count;
    #####: 3131:    result = ecma_op_object_get_length (current_object_p, &capture_count);
    #####: 3132:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3133:    {
    #####: 3134:      goto cleanup_builder;
        -: 3135:    }
        -: 3136:
        -: 3137:    /* 16.c */
    #####: 3138:    capture_count = (capture_count > 0) ? capture_count - 1 : capture_count;
        -: 3139:
        -: 3140:    /* 16.d */
    #####: 3141:    result = ecma_op_object_get_by_index (current_object_p, 0);
    #####: 3142:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3143:    {
    #####: 3144:      goto cleanup_builder;
        -: 3145:    }
        -: 3146:
    #####: 3147:    ecma_string_t *matched_str_p = ecma_op_to_string (result);
    #####: 3148:    ecma_free_value (result);
        -: 3149:
        -: 3150:    /* 16.e */
    #####: 3151:    if (matched_str_p == NULL)
        -: 3152:    {
    #####: 3153:      result = ECMA_VALUE_ERROR;
    #####: 3154:      goto cleanup_builder;
        -: 3155:    }
        -: 3156:
        -: 3157:    /* 16.g */
    #####: 3158:    result = ecma_op_object_get_by_magic_id (current_object_p, LIT_MAGIC_STRING_INDEX);
    #####: 3159:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3160:    {
    #####: 3161:      ecma_deref_ecma_string (matched_str_p);
    #####: 3162:      goto cleanup_builder;
        -: 3163:    }
        -: 3164:
    #####: 3165:    const ecma_value_t index_value = result;
        -: 3166:
    #####: 3167:    ecma_number_t position_num;
    #####: 3168:    result = ecma_op_to_integer (index_value, &position_num);
    #####: 3169:    ecma_free_value (index_value);
        -: 3170:
    #####: 3171:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3172:    {
    #####: 3173:      ecma_deref_ecma_string (matched_str_p);
    #####: 3174:      goto cleanup_builder;
        -: 3175:    }
        -: 3176:
        -: 3177:    /* 16.i */
    #####: 3178:    lit_utf8_size_t position = JERRY_MIN ((lit_utf8_size_t) JERRY_MAX (position_num, 0.0f), string_length);
        -: 3179:
        -: 3180:    /* 16.k */
    #####: 3181:    ecma_collection_t *arguments_p = ecma_new_collection ();
    #####: 3182:    ecma_collection_push_back (arguments_p, ecma_make_string_value (matched_str_p));
        -: 3183:
        -: 3184:    /* 16.j, l */
    #####: 3185:    ecma_length_t n = 1;
    #####: 3186:    while (n <= capture_count)
        -: 3187:    {
    #####: 3188:      result = ecma_op_object_get_by_index (current_object_p, n);
    #####: 3189:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3190:      {
    #####: 3191:        ecma_collection_free (arguments_p);
    #####: 3192:        goto cleanup_builder;
        -: 3193:      }
        -: 3194:
        -: 3195:      /* 16.l.iii */
    #####: 3196:      if (!ecma_is_value_undefined (result))
        -: 3197:      {
    #####: 3198:        ecma_string_t *capture_str_p = ecma_op_to_string (result);
    #####: 3199:        ecma_free_value (result);
        -: 3200:
    #####: 3201:        if (capture_str_p == NULL)
        -: 3202:        {
    #####: 3203:          ecma_collection_free (arguments_p);
    #####: 3204:          result = ECMA_VALUE_ERROR;
    #####: 3205:          goto cleanup_builder;
        -: 3206:        }
        -: 3207:
    #####: 3208:        result = ecma_make_string_value (capture_str_p);
        -: 3209:      }
        -: 3210:
        -: 3211:      /* 16.l.iv */
    #####: 3212:      ecma_collection_push_back (arguments_p, result);
    #####: 3213:      n++;
        -: 3214:    }
        -: 3215:
    #####: 3216:    const bool should_replace = (position >= index);
        -: 3217:    /* 16.p */
    #####: 3218:    if (should_replace)
        -: 3219:    {
    #####: 3220:      const lit_utf8_byte_t *match_position_p;
    #####: 3221:      const lit_utf8_size_t matched_str_size = ecma_string_get_size (matched_str_p);
    #####: 3222:      const lit_utf8_size_t matched_str_length = ecma_string_get_length (matched_str_p);
        -: 3223:
    #####: 3224:      if (string_flags & ECMA_STRING_FLAG_IS_ASCII)
        -: 3225:      {
    #####: 3226:        match_position_p = replace_ctx.string_p + position;
        -: 3227:      }
        -: 3228:      else
        -: 3229:      {
    #####: 3230:        match_position_p = source_position_p;
    #####: 3231:        lit_utf8_size_t distance = position - index;
    #####: 3232:        while (distance--)
        -: 3233:        {
    #####: 3234:          lit_utf8_incr (&match_position_p);
        -: 3235:        }
        -: 3236:      }
        -: 3237:
    #####: 3238:      ecma_stringbuilder_append_raw (&replace_ctx.builder,
        -: 3239:                                    source_position_p,
    #####: 3240:                                    (lit_utf8_size_t) (match_position_p - source_position_p));
    #####: 3241:      replace_ctx.match_byte_pos = (lit_utf8_size_t) (match_position_p - replace_ctx.string_p);
        -: 3242:
    #####: 3243:      if ((string_flags & ECMA_STRING_FLAG_IS_ASCII) && matched_str_size == matched_str_length)
        -: 3244:      {
    #####: 3245:        source_position_p = JERRY_MIN (match_position_p + matched_str_size, string_end_p);
        -: 3246:      }
        -: 3247:      else
        -: 3248:      {
    #####: 3249:        lit_utf8_size_t code_unit_count = matched_str_length;
        -: 3250:
    #####: 3251:        while (code_unit_count-- > 0 && JERRY_LIKELY (match_position_p < string_end_p))
        -: 3252:        {
    #####: 3253:          lit_utf8_incr (&match_position_p);
        -: 3254:        }
        -: 3255:
    #####: 3256:        source_position_p = match_position_p;
        -: 3257:      }
        -: 3258:
    #####: 3259:      index = JERRY_MIN (position + matched_str_length, string_length);
        -: 3260:    }
        -: 3261:
        -: 3262:    /* 16.m */
    #####: 3263:    if (replace_ctx.replace_str_p == NULL)
        -: 3264:    {
        -: 3265:      /* 16.m.i-ii.
        -: 3266:       * arguments_p already contains <<Matched, cap1, cap2, ..., capN>> */
        -: 3267:
        -: 3268:      /* 16.m.iii */
    #####: 3269:      ecma_collection_push_back (arguments_p, ecma_make_uint32_value (position));
    #####: 3270:      ecma_ref_ecma_string (string_p);
    #####: 3271:      ecma_collection_push_back (arguments_p, ecma_make_string_value (string_p));
        -: 3272:
    #####: 3273:      result = ecma_op_function_call (ecma_get_object_from_value (replace_arg),
        -: 3274:                                      ECMA_VALUE_UNDEFINED,
    #####: 3275:                                      arguments_p->buffer_p,
        -: 3276:                                      arguments_p->item_count);
        -: 3277:
    #####: 3278:      ecma_collection_free (arguments_p);
        -: 3279:
    #####: 3280:      if (ECMA_IS_VALUE_ERROR (result))
        -: 3281:      {
    #####: 3282:        goto cleanup_builder;
        -: 3283:      }
        -: 3284:
        -: 3285:      /* 16.m.v */
    #####: 3286:      ecma_string_t *const replace_result_p = ecma_op_to_string (result);
    #####: 3287:      ecma_free_value (result);
        -: 3288:
    #####: 3289:      if (replace_result_p == NULL)
        -: 3290:      {
    #####: 3291:        result = ECMA_VALUE_ERROR;
    #####: 3292:        goto cleanup_builder;
        -: 3293:      }
        -: 3294:
        -: 3295:      /* 16.m/p */
    #####: 3296:      if (should_replace)
        -: 3297:      {
    #####: 3298:        ecma_stringbuilder_append (&replace_ctx.builder, replace_result_p);
        -: 3299:      }
        -: 3300:
    #####: 3301:      ecma_deref_ecma_string (replace_result_p);
        -: 3302:    }
        -: 3303:    else
        -: 3304:    {
        -: 3305:      /* 16.n/p */
    #####: 3306:      if (should_replace)
        -: 3307:      {
    #####: 3308:        replace_ctx.u.collection_p = arguments_p;
    #####: 3309:        ecma_builtin_replace_substitute (&replace_ctx);
        -: 3310:      }
        -: 3311:
    #####: 3312:      ecma_collection_free (arguments_p);
        -: 3313:    }
        -: 3314:  }
        -: 3315:
        -: 3316:  /* 18. */
    #####: 3317:  JERRY_ASSERT (index <= string_length);
    #####: 3318:  ecma_stringbuilder_append_raw (&(replace_ctx.builder),
        -: 3319:                                 source_position_p,
    #####: 3320:                                 (lit_utf8_size_t) (string_end_p - source_position_p));
        -: 3321:
    #####: 3322:  result = ecma_make_string_value (ecma_stringbuilder_finalize (&replace_ctx.builder));
    #####: 3323:  goto cleanup_chars;
        -: 3324:
    #####: 3325:cleanup_builder:
    #####: 3326:  ecma_stringbuilder_destroy (&replace_ctx.builder);
        -: 3327:
    #####: 3328:cleanup_chars:
    #####: 3329:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 3330:  {
    #####: 3331:    jmem_heap_free_block ((void *) replace_ctx.string_p, replace_ctx.string_size);
        -: 3332:  }
        -: 3333:
    #####: 3334:cleanup_results:
    #####: 3335:  ecma_collection_free (results_p);
        -: 3336:#endif /* !JERRY_ESNEXT */
        -: 3337:
    #####: 3338:cleanup_replace:
    #####: 3339:  if (replace_ctx.replace_str_p != NULL)
        -: 3340:  {
    #####: 3341:    ecma_deref_ecma_string (replace_ctx.replace_str_p);
        -: 3342:  }
        -: 3343:
    #####: 3344:cleanup_string:
    #####: 3345:  ecma_deref_ecma_string (string_p);
        -: 3346:
    #####: 3347:  return result;
        -: 3348:} /* ecma_regexp_replace_helper */
        -: 3349:
        -: 3350:/**
        -: 3351: * Helper function for RegExp based matching
        -: 3352: *
        -: 3353: * See also:
        -: 3354: *          String.prototype.match
        -: 3355: *          RegExp.prototype[@@match]
        -: 3356: *
        -: 3357: * @return ecma_value_t
        -: 3358: */
        -: 3359:ecma_value_t
    #####: 3360:ecma_regexp_match_helper (ecma_value_t this_arg, /**< this argument */
        -: 3361:                          ecma_value_t string_arg) /**< source string */
        -: 3362:{
    #####: 3363:  if (!ecma_is_value_object (this_arg))
        -: 3364:  {
    #####: 3365:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an object"));
        -: 3366:  }
        -: 3367:
    #####: 3368:  ecma_string_t *str_p = ecma_op_to_string (string_arg);
        -: 3369:
    #####: 3370:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 3371:  {
    #####: 3372:    return ECMA_VALUE_ERROR;
        -: 3373:  }
        -: 3374:
    #####: 3375:  ecma_object_t *obj_p = ecma_get_object_from_value (this_arg);
        -: 3376:
    #####: 3377:  ecma_value_t global_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_GLOBAL);
        -: 3378:
    #####: 3379:  if (ECMA_IS_VALUE_ERROR (global_value))
        -: 3380:  {
    #####: 3381:    ecma_deref_ecma_string (str_p);
    #####: 3382:    return global_value;
        -: 3383:  }
        -: 3384:
    #####: 3385:  bool global = ecma_op_to_boolean (global_value);
        -: 3386:
    #####: 3387:  ecma_free_value (global_value);
        -: 3388:
    #####: 3389:  if (!global)
        -: 3390:  {
    #####: 3391:    ecma_value_t result = ecma_op_regexp_exec (this_arg, str_p);
    #####: 3392:    ecma_deref_ecma_string (str_p);
    #####: 3393:    return result;
        -: 3394:  }
        -: 3395:
        -: 3396:#if JERRY_ESNEXT
    #####: 3397:  ecma_value_t full_unicode_value = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_UNICODE);
        -: 3398:
    #####: 3399:  if (ECMA_IS_VALUE_ERROR (full_unicode_value))
        -: 3400:  {
    #####: 3401:    ecma_deref_ecma_string (str_p);
    #####: 3402:    return full_unicode_value;
        -: 3403:  }
        -: 3404:
    #####: 3405:  bool full_unicode = ecma_op_to_boolean (full_unicode_value);
        -: 3406:
    #####: 3407:  ecma_free_value (full_unicode_value);
        -: 3408:#endif /* JERRY_ESNEXT */
        -: 3409:
    #####: 3410:  ecma_value_t set_status = ecma_op_object_put (obj_p,
        -: 3411:                                                ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 3412:                                                ecma_make_uint32_value (0),
        -: 3413:                                                true);
        -: 3414:
    #####: 3415:  if (ECMA_IS_VALUE_ERROR (set_status))
        -: 3416:  {
    #####: 3417:    ecma_deref_ecma_string (str_p);
    #####: 3418:    return set_status;
        -: 3419:  }
        -: 3420:
    #####: 3421:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####: 3422:  ecma_object_t *result_array_p = ecma_op_new_array_object (0);
    #####: 3423:  uint32_t n = 0;
        -: 3424:
        -: 3425:  while (true)
    #####: 3426:  {
    #####: 3427:    ecma_value_t result_value = ecma_op_regexp_exec (this_arg, str_p);
        -: 3428:
    #####: 3429:    if (ECMA_IS_VALUE_ERROR (result_value))
        -: 3430:    {
    #####: 3431:      goto result_cleanup;
        -: 3432:    }
        -: 3433:
    #####: 3434:    if (ecma_is_value_null (result_value))
        -: 3435:    {
    #####: 3436:      if (n == 0)
        -: 3437:      {
    #####: 3438:        ret_value = ECMA_VALUE_NULL;
    #####: 3439:        goto result_cleanup;
        -: 3440:      }
        -: 3441:
    #####: 3442:      ecma_deref_ecma_string (str_p);
    #####: 3443:      return ecma_make_object_value (result_array_p);
        -: 3444:    }
        -: 3445:
    #####: 3446:    ecma_object_t *result_value_p = ecma_get_object_from_value (result_value);
    #####: 3447:    ecma_value_t match_value = ecma_op_object_get_by_index (result_value_p, 0);
        -: 3448:
    #####: 3449:    ecma_deref_object (result_value_p);
        -: 3450:
    #####: 3451:    if (ECMA_IS_VALUE_ERROR (match_value))
        -: 3452:    {
    #####: 3453:      goto result_cleanup;
        -: 3454:    }
        -: 3455:
    #####: 3456:    ecma_string_t *match_str_p = ecma_op_to_string (match_value);
    #####: 3457:    ecma_free_value (match_value);
        -: 3458:
    #####: 3459:    if (JERRY_UNLIKELY (match_str_p == NULL))
        -: 3460:    {
    #####: 3461:      goto result_cleanup;
        -: 3462:    }
        -: 3463:
    #####: 3464:    ecma_value_t new_prop = ecma_builtin_helper_def_prop_by_index (result_array_p,
        -: 3465:                                                                   n,
        -: 3466:                                                                   ecma_make_string_value (match_str_p),
        -: 3467:                                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -: 3468:
    #####: 3469:    JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (new_prop));
        -: 3470:
    #####: 3471:    const bool is_match_empty = ecma_string_is_empty (match_str_p);
    #####: 3472:    ecma_deref_ecma_string (match_str_p);
        -: 3473:
    #####: 3474:    if (is_match_empty)
        -: 3475:    {
    #####: 3476:      ecma_value_t last_index = ecma_op_object_get_by_magic_id (obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);
        -: 3477:
    #####: 3478:      if (ECMA_IS_VALUE_ERROR (last_index))
        -: 3479:      {
    #####: 3480:        goto result_cleanup;
        -: 3481:      }
        -: 3482:
        -: 3483:#if JERRY_ESNEXT
    #####: 3484:      ecma_length_t index;
    #####: 3485:      ecma_value_t length_value = ecma_op_to_length (last_index, &index);
        -: 3486:
    #####: 3487:      ecma_free_value (last_index);
        -: 3488:
    #####: 3489:      if (ECMA_IS_VALUE_ERROR (length_value))
        -: 3490:      {
    #####: 3491:        goto result_cleanup;
        -: 3492:      }
        -: 3493:
    #####: 3494:      index = ecma_op_advance_string_index (str_p, index, full_unicode);
        -: 3495:
    #####: 3496:      last_index = ecma_make_length_value (index);
    #####: 3497:      ecma_value_t next_set_status = ecma_op_object_put (obj_p,
        -: 3498:                                                         ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 3499:                                                         last_index,
        -: 3500:                                                         true);
        -: 3501:#else /* !JERRY_ESNEXT */
    #####: 3502:      ecma_number_t index = ecma_get_number_from_value (last_index);
    #####: 3503:      ecma_free_value (last_index);
        -: 3504:
    #####: 3505:      last_index = ecma_make_number_value (index + 1);
    #####: 3506:      ecma_value_t next_set_status = ecma_op_object_put (obj_p,
        -: 3507:                                                         ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -: 3508:                                                         last_index,
        -: 3509:                                                         true);
        -: 3510:
        -: 3511:#endif /* JERRY_ESNEXT */
    #####: 3512:      ecma_free_value (last_index);
        -: 3513:
    #####: 3514:      if (ECMA_IS_VALUE_ERROR (next_set_status))
        -: 3515:      {
    #####: 3516:        goto result_cleanup;
        -: 3517:      }
        -: 3518:    }
        -: 3519:
    #####: 3520:    n++;
        -: 3521:  }
        -: 3522:
    #####: 3523:result_cleanup:
    #####: 3524:  ecma_deref_ecma_string (str_p);
    #####: 3525:  ecma_deref_object (result_array_p);
    #####: 3526:  return ret_value;
        -: 3527:} /* ecma_regexp_match_helper */
        -: 3528:
        -: 3529:/**
        -: 3530: * RegExpExec operation
        -: 3531: *
        -: 3532: * See also:
        -: 3533: *          ECMA-262 v6.0, 21.2.5.2.1
        -: 3534: *
        -: 3535: * @return ecma value
        -: 3536: *         Returned value must be freed with ecma_free_value.
        -: 3537: */
        -: 3538:ecma_value_t
    #####: 3539:ecma_op_regexp_exec (ecma_value_t this_arg, /**< this argument */
        -: 3540:                     ecma_string_t *str_p) /**< input string */
        -: 3541:{
    #####: 3542:  ecma_object_t *arg_obj_p = ecma_get_object_from_value (this_arg);
        -: 3543:
        -: 3544:#if JERRY_ESNEXT
    #####: 3545:  ecma_value_t exec = ecma_op_object_get_by_magic_id (arg_obj_p, LIT_MAGIC_STRING_EXEC);
        -: 3546:
    #####: 3547:  if (ECMA_IS_VALUE_ERROR (exec))
        -: 3548:  {
    #####: 3549:    return exec;
        -: 3550:  }
        -: 3551:
    #####: 3552:  if (ecma_op_is_callable (exec))
        -: 3553:  {
    #####: 3554:    ecma_object_t *function_p = ecma_get_object_from_value (exec);
    #####: 3555:    ecma_value_t arguments[] = { ecma_make_string_value (str_p) };
        -: 3556:
    #####: 3557:    ecma_value_t result = ecma_op_function_call (function_p, this_arg, arguments, 1);
        -: 3558:
    #####: 3559:    ecma_deref_object (function_p);
        -: 3560:
    #####: 3561:    if (ECMA_IS_VALUE_ERROR (result))
        -: 3562:    {
    #####: 3563:      return result;
        -: 3564:    }
        -: 3565:
    #####: 3566:    if (!ecma_is_value_object (result) && !ecma_is_value_null (result))
        -: 3567:    {
    #####: 3568:      ecma_free_value (result);
    #####: 3569:      return ecma_raise_type_error (ECMA_ERR_MSG ("Return value of 'exec' must be an object or null"));
        -: 3570:    }
        -: 3571:
    #####: 3572:    return result;
        -: 3573:  }
        -: 3574:  else
        -: 3575:  {
    #####: 3576:    ecma_free_value (exec);
        -: 3577:  }
        -: 3578:#endif /* JERRY_ESNEXT */
        -: 3579:
    #####: 3580:  if (!ecma_object_is_regexp_object (this_arg))
        -: 3581:  {
    #####: 3582:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not a valid RegExp"));
        -: 3583:  }
        -: 3584:
    #####: 3585:  return ecma_regexp_exec_helper (arg_obj_p, str_p);
        -: 3586:} /* ecma_op_regexp_exec */
        -: 3587:
        -: 3588:/**
        -: 3589: * @}
        -: 3590: * @}
        -: 3591: */
        -: 3592:
        -: 3593:#endif /* JERRY_BUILTIN_REGEXP */
