        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-array-prototype.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-comparison.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "ecma-objects.h"
        -:   28:#include "ecma-string-object.h"
        -:   29:#include "lit-char-helpers.h"
        -:   30:#include "jrt.h"
        -:   31:
        -:   32:#if JERRY_BUILTIN_ARRAY
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/**
        -:   38: * This object has a custom dispatch function.
        -:   39: */
        -:   40:#define BUILTIN_CUSTOM_DISPATCH
        -:   41:
        -:   42:/**
        -:   43: * List of built-in routine identifiers.
        -:   44: */
        -:   45:enum
        -:   46:{
        -:   47:  ECMA_ARRAY_PROTOTYPE_ROUTINE_START = 0,
        -:   48:  /* Note: these 2 routine ids must be in this order */
        -:   49:#if !JERRY_ESNEXT
        -:   50:  ECMA_ARRAY_PROTOTYPE_TO_STRING,
        -:   51:#endif /* !JERRY_ESNEXT */
        -:   52:  ECMA_ARRAY_PROTOTYPE_SORT,
        -:   53:  ECMA_ARRAY_PROTOTYPE_CONCAT,
        -:   54:  ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING,
        -:   55:  ECMA_ARRAY_PROTOTYPE_JOIN,
        -:   56:  ECMA_ARRAY_PROTOTYPE_POP,
        -:   57:  ECMA_ARRAY_PROTOTYPE_PUSH,
        -:   58:  ECMA_ARRAY_PROTOTYPE_REVERSE,
        -:   59:  ECMA_ARRAY_PROTOTYPE_SHIFT,
        -:   60:  ECMA_ARRAY_PROTOTYPE_SLICE,
        -:   61:  ECMA_ARRAY_PROTOTYPE_SPLICE,
        -:   62:  ECMA_ARRAY_PROTOTYPE_UNSHIFT,
        -:   63:  ECMA_ARRAY_PROTOTYPE_AT,
        -:   64:  ECMA_ARRAY_PROTOTYPE_INDEX_OF,
        -:   65:  ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF,
        -:   66:  /* Note these 3 routines must be in this order */
        -:   67:  ECMA_ARRAY_PROTOTYPE_EVERY,
        -:   68:  ECMA_ARRAY_PROTOTYPE_SOME,
        -:   69:  ECMA_ARRAY_PROTOTYPE_FOR_EACH,
        -:   70:  ECMA_ARRAY_PROTOTYPE_MAP,
        -:   71:  ECMA_ARRAY_PROTOTYPE_FILTER,
        -:   72:  /* Note these 2 routines must be in this order */
        -:   73:  ECMA_ARRAY_PROTOTYPE_REDUCE,
        -:   74:  ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT,
        -:   75:  ECMA_ARRAY_PROTOTYPE_FIND,
        -:   76:  ECMA_ARRAY_PROTOTYPE_FIND_INDEX,
        -:   77:  ECMA_ARRAY_PROTOTYPE_ENTRIES,
        -:   78:  ECMA_ARRAY_PROTOTYPE_KEYS,
        -:   79:  ECMA_ARRAY_PROTOTYPE_SYMBOL_ITERATOR,
        -:   80:  ECMA_ARRAY_PROTOTYPE_FILL,
        -:   81:  ECMA_ARRAY_PROTOTYPE_COPY_WITHIN,
        -:   82:  ECMA_ARRAY_PROTOTYPE_INCLUDES,
        -:   83:  ECMA_ARRAY_PROTOTYPE_FLAT,
        -:   84:  ECMA_ARRAY_PROTOTYPE_FLATMAP,
        -:   85:};
        -:   86:
        -:   87:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-array-prototype.inc.h"
        -:   88:#define BUILTIN_UNDERSCORED_ID array_prototype
        -:   89:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   90:
        -:   91:/** \addtogroup ecma ECMA
        -:   92: * @{
        -:   93: *
        -:   94: * \addtogroup ecmabuiltins
        -:   95: * @{
        -:   96: *
        -:   97: * \addtogroup arrayprototype ECMA Array.prototype object built-in
        -:   98: * @{
        -:   99: */
        -:  100:
        -:  101:/**
        -:  102: * Helper function to set an object's length property
        -:  103: *
        -:  104: * @return ecma value (return value of the [[Put]] method)
        -:  105: *         Calling ecma_free_value on the returned value is optional if it is not abrupt completion.
        -:  106: */
        -:  107:static ecma_value_t
    #####:  108:ecma_builtin_array_prototype_helper_set_length (ecma_object_t *object, /**< object*/
        -:  109:                                                ecma_number_t length) /**< new length */
        -:  110:{
    #####:  111:  ecma_value_t length_value = ecma_make_number_value (length);
    #####:  112:  ecma_value_t ret_value = ecma_op_object_put (object,
        -:  113:                                               ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -:  114:                                               length_value,
        -:  115:                                               true);
        -:  116:
    #####:  117:  ecma_free_value (length_value);
        -:  118:
    #####:  119:  JERRY_ASSERT (ecma_is_value_boolean (ret_value)
        -:  120:                || ecma_is_value_empty (ret_value)
        -:  121:                || ECMA_IS_VALUE_ERROR (ret_value));
    #####:  122:  return ret_value;
        -:  123:} /* ecma_builtin_array_prototype_helper_set_length */
        -:  124:
        -:  125:/**
        -:  126: * The Array.prototype object's 'toLocaleString' routine
        -:  127: *
        -:  128: * See also:
        -:  129: *          ECMA-262 v5, 15.4.4.3
        -:  130: *
        -:  131: * @return ecma value
        -:  132: *         Returned value must be freed with ecma_free_value.
        -:  133: */
        -:  134:static ecma_value_t
    #####:  135:ecma_builtin_array_prototype_object_to_locale_string (ecma_object_t *obj_p, /**< object */
        -:  136:                                                      ecma_length_t length) /**< object's length */
        -:  137:{
        -:  138:  /* 5. */
    #####:  139:  if (length == 0)
        -:  140:  {
    #####:  141:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  142:  }
        -:  143:
        -:  144:  /* 7-8. */
    #####:  145:  ecma_string_t *first_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, 0);
        -:  146:
    #####:  147:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  148:  {
    #####:  149:    return ECMA_VALUE_ERROR;
        -:  150:  }
        -:  151:
    #####:  152:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  153:  ecma_deref_ecma_string (first_string_p);
        -:  154:
        -:  155:  /* 9-10. */
    #####:  156:  for (ecma_length_t k = 1; k < length; k++)
        -:  157:  {
        -:  158:    /* 4. Implementation-defined: set the separator to a single comma character. */
    #####:  159:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
        -:  160:
    #####:  161:    ecma_string_t *next_string_p = ecma_builtin_helper_get_to_locale_string_at_index (obj_p, k);
        -:  162:
    #####:  163:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  164:    {
    #####:  165:      ecma_stringbuilder_destroy (&builder);
    #####:  166:      return ECMA_VALUE_ERROR;
        -:  167:    }
        -:  168:
    #####:  169:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  170:    ecma_deref_ecma_string (next_string_p);
        -:  171:  }
        -:  172:
    #####:  173:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  174:} /* ecma_builtin_array_prototype_object_to_locale_string */
        -:  175:
        -:  176:/**
        -:  177: * The Array.prototype object's 'concat' routine
        -:  178: *
        -:  179: * See also:
        -:  180: *          ECMA-262 v5, 15.4.4.4
        -:  181: *
        -:  182: * @return ecma value
        -:  183: *         Returned value must be freed with ecma_free_value.
        -:  184: */
        -:  185:static ecma_value_t
    #####:  186:ecma_builtin_array_prototype_object_concat (const ecma_value_t args[], /**< arguments list */
        -:  187:                                            uint32_t args_number, /**< number of arguments */
        -:  188:                                            ecma_object_t *obj_p) /**< array object */
        -:  189:{
        -:  190:  /* 2. */
        -:  191:#if JERRY_ESNEXT
    #####:  192:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -:  193:
    #####:  194:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -:  195:  {
    #####:  196:    return ECMA_VALUE_ERROR;
        -:  197:  }
        -:  198:#else /* !JERRY_ESNEXT */
    #####:  199:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -:  200:#endif /* JERRY_ESNEXT */
        -:  201:
    #####:  202:  ecma_length_t new_length = 0;
        -:  203:
        -:  204:  /* 5.b - 5.c for this_arg */
    #####:  205:  ecma_value_t concat_this_value = ecma_builtin_helper_array_concat_value (new_array_p,
        -:  206:                                                                           &new_length,
        -:  207:                                                                           ecma_make_object_value (obj_p));
    #####:  208:  if (ECMA_IS_VALUE_ERROR (concat_this_value))
        -:  209:  {
    #####:  210:    ecma_deref_object (new_array_p);
    #####:  211:    return concat_this_value;
        -:  212:  }
        -:  213:
    #####:  214:  JERRY_ASSERT (ecma_is_value_empty (concat_this_value));
        -:  215:
        -:  216:  /* 5. */
    #####:  217:  for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -:  218:  {
    #####:  219:    ecma_value_t concat_value = ecma_builtin_helper_array_concat_value (new_array_p, &new_length, args[arg_index]);
        -:  220:
    #####:  221:    if (ECMA_IS_VALUE_ERROR (concat_value))
        -:  222:    {
    #####:  223:      ecma_deref_object (new_array_p);
    #####:  224:      return concat_value;
        -:  225:    }
        -:  226:
    #####:  227:    JERRY_ASSERT (ecma_is_value_empty (concat_value));
        -:  228:  }
        -:  229:
    #####:  230:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p,
        -:  231:                                                                                  ((ecma_number_t) new_length));
    #####:  232:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  233:  {
    #####:  234:    ecma_deref_object (new_array_p);
    #####:  235:    return set_length_value;
        -:  236:  }
        -:  237:
    #####:  238:  return ecma_make_object_value (new_array_p);
        -:  239:} /* ecma_builtin_array_prototype_object_concat */
        -:  240:
        -:  241:/**
        -:  242: * The Array.prototype.toString's separator creation routine
        -:  243: *
        -:  244: * See also:
        -:  245: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -:  246: *
        -:  247: * @return NULL - if the conversion fails
        -:  248: *         ecma_string_t * - otherwise
        -:  249: */
        -:  250:
        -:  251:static ecma_string_t *
    #####:  252:ecma_op_array_get_separator_string (ecma_value_t separator) /**< possible separator */
        -:  253:{
    #####:  254:  if (ecma_is_value_undefined (separator))
        -:  255:  {
    #####:  256:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -:  257:  }
        -:  258:
    #####:  259:  return ecma_op_to_string (separator);
        -:  260:} /* ecma_op_array_get_separator_string */
        -:  261:
        -:  262:/**
        -:  263: * The Array.prototype's 'toString' single element operation routine
        -:  264: *
        -:  265: * See also:
        -:  266: *          ECMA-262 v5.1, 15.4.4.2
        -:  267: *
        -:  268: * @return NULL - if the conversion fails
        -:  269: *         ecma_string_t * - otherwise
        -:  270: */
        -:  271:static ecma_string_t *
    #####:  272:ecma_op_array_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  273:                                      ecma_length_t index) /**< array index */
        -:  274:{
    #####:  275:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  276:
    #####:  277:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  278:  {
    #####:  279:    return NULL;
        -:  280:  }
        -:  281:
    #####:  282:  if (ecma_is_value_undefined (index_value)
    #####:  283:      || ecma_is_value_null (index_value))
        -:  284:  {
    #####:  285:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  286:  }
        -:  287:
    #####:  288:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -:  289:
    #####:  290:  ecma_free_value (index_value);
        -:  291:
    #####:  292:  return ret_str_p;
        -:  293:} /* ecma_op_array_get_to_string_at_index */
        -:  294:
        -:  295:/**
        -:  296: * The Array.prototype object's 'join' routine
        -:  297: *
        -:  298: * See also:
        -:  299: *          ECMA-262 v5, 15.4.4.5
        -:  300: *
        -:  301: * @return ecma value
        -:  302: *         Returned value must be freed with ecma_free_value.
        -:  303: */
        -:  304:static ecma_value_t
    #####:  305:ecma_builtin_array_prototype_join (ecma_value_t separator_arg, /**< separator argument */
        -:  306:                                   ecma_object_t *obj_p, /**< object */
        -:  307:                                   ecma_length_t length) /**< object's length */
        -:  308:{
        -:  309:  /* 4-5. */
    #####:  310:  ecma_string_t *separator_string_p = ecma_op_array_get_separator_string (separator_arg);
        -:  311:
    #####:  312:  if (JERRY_UNLIKELY (separator_string_p == NULL))
        -:  313:  {
    #####:  314:    return ECMA_VALUE_ERROR;
        -:  315:  }
        -:  316:
    #####:  317:  if (length == 0)
        -:  318:  {
        -:  319:    /* 6. */
    #####:  320:    ecma_deref_ecma_string (separator_string_p);
    #####:  321:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -:  322:  }
        -:  323:
        -:  324:  /* 7-8. */
    #####:  325:  ecma_string_t *first_string_p = ecma_op_array_get_to_string_at_index (obj_p, 0);
        -:  326:
    #####:  327:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  328:  {
    #####:  329:    ecma_deref_ecma_string (separator_string_p);
    #####:  330:    return ECMA_VALUE_ERROR;
        -:  331:  }
        -:  332:
    #####:  333:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
    #####:  334:  ecma_deref_ecma_string (first_string_p);
        -:  335:
        -:  336:  /* 9-10. */
    #####:  337:  for (ecma_length_t k = 1; k < length; k++)
        -:  338:  {
        -:  339:    /* 10.a */
    #####:  340:    ecma_stringbuilder_append (&builder, separator_string_p);
        -:  341:
        -:  342:    /* 10.d */
    #####:  343:    ecma_string_t *next_string_p = ecma_op_array_get_to_string_at_index (obj_p, k);
        -:  344:
    #####:  345:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  346:    {
    #####:  347:      ecma_deref_ecma_string (separator_string_p);
    #####:  348:      ecma_stringbuilder_destroy (&builder);
    #####:  349:      return ECMA_VALUE_ERROR;
        -:  350:    }
        -:  351:
    #####:  352:    ecma_stringbuilder_append (&builder, next_string_p);
    #####:  353:    ecma_deref_ecma_string (next_string_p);
        -:  354:  }
        -:  355:
    #####:  356:  ecma_deref_ecma_string (separator_string_p);
    #####:  357:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  358:} /* ecma_builtin_array_prototype_join */
        -:  359:
        -:  360:/**
        -:  361: * The Array.prototype object's 'pop' routine
        -:  362: *
        -:  363: * See also:
        -:  364: *          ECMA-262 v5, 15.4.4.6
        -:  365: *
        -:  366: * @return ecma value
        -:  367: *         Returned value must be freed with ecma_free_value.
        -:  368: */
        -:  369:static ecma_value_t
    #####:  370:ecma_builtin_array_prototype_object_pop (ecma_object_t *obj_p, /**< object */
        -:  371:                                         ecma_length_t len) /**< object's length */
        -:  372:{
        -:  373:   /* 4. */
    #####:  374:  if (len == 0)
        -:  375:  {
        -:  376:    /* 4.a */
    #####:  377:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  378:
        -:  379:    /* 4.b */
    #####:  380:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  381:  }
        -:  382:
        -:  383:  /* 5.b */
    #####:  384:  len--;
    #####:  385:  ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, len);
        -:  386:
    #####:  387:  if (ECMA_IS_VALUE_ERROR (get_value))
        -:  388:  {
    #####:  389:    return get_value;
        -:  390:  }
        -:  391:
    #####:  392:  if (ecma_op_object_is_fast_array (obj_p))
        -:  393:  {
    #####:  394:    ecma_delete_fast_array_properties (obj_p, (uint32_t) len);
        -:  395:
    #####:  396:    return get_value;
        -:  397:  }
        -:  398:
        -:  399:  /* 5.c */
    #####:  400:  ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, len, true);
        -:  401:
    #####:  402:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  403:  {
    #####:  404:    ecma_free_value (get_value);
    #####:  405:    return del_value;
        -:  406:  }
        -:  407:
    #####:  408:  ecma_free_value (del_value);
        -:  409:
        -:  410:  /* 5.d */
    #####:  411:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  412:
    #####:  413:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  414:  {
    #####:  415:    ecma_free_value (get_value);
    #####:  416:    return set_length_value;
        -:  417:  }
        -:  418:
    #####:  419:  return get_value;
        -:  420:} /* ecma_builtin_array_prototype_object_pop */
        -:  421:
        -:  422:/**
        -:  423: * The Array.prototype object's 'push' routine
        -:  424: *
        -:  425: * See also:
        -:  426: *          ECMA-262 v5, 15.4.4.7
        -:  427: *
        -:  428: * @return ecma value
        -:  429: *         Returned value must be freed with ecma_free_value.
        -:  430: */
        -:  431:static ecma_value_t
      200:  432:ecma_builtin_array_prototype_object_push (const ecma_value_t *argument_list_p, /**< arguments list */
        -:  433:                                          uint32_t arguments_number, /**< number of arguments */
        -:  434:                                          ecma_object_t *obj_p, /**< object */
        -:  435:                                          ecma_length_t length) /**< object's length */
        -:  436:{
      200:  437:  if (ecma_op_object_is_fast_array (obj_p))
        -:  438:  {
      200:  439:    if ((ecma_number_t) (length + arguments_number) > UINT32_MAX)
        -:  440:    {
    #####:  441:      return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
        -:  442:    }
        -:  443:
      200:  444:    if (arguments_number == 0)
        -:  445:    {
    #####:  446:      return ecma_make_uint32_value ((uint32_t) length);
        -:  447:    }
        -:  448:
      200:  449:    uint32_t new_length = ((uint32_t) length) + arguments_number;
      200:  450:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
      200:  451:    ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length) + length;
        -:  452:
      400:  453:    for (uint32_t index = 0; index < arguments_number; index++)
        -:  454:    {
      200:  455:      buffer_p[index] = ecma_copy_value_if_not_object (argument_list_p[index]);
        -:  456:    }
        -:  457:
      200:  458:    ext_obj_p->u.array.length_prop_and_hole_count -= ECMA_FAST_ARRAY_HOLE_ONE * arguments_number;
        -:  459:
      200:  460:    return ecma_make_uint32_value (new_length);
        -:  461:  }
        -:  462:
        -:  463:#if JERRY_ESNEXT
        -:  464:  /* 5. */
    #####:  465:  if ((ecma_number_t) (length + arguments_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -:  466:  {
    #####:  467:    return ecma_raise_type_error (ECMA_ERR_MSG ("Pushing element over 2**53-1 length is disallowed"));
        -:  468:  }
        -:  469:
        -:  470:  /* 6. */
    #####:  471:  for (ecma_length_t index = 0; index < arguments_number; index++, length++)
        -:  472:  {
        -:  473:    /* 6.b */
    #####:  474:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, length, argument_list_p[index], true);
        -:  475:
    #####:  476:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  477:    {
    #####:  478:      return put_value;
        -:  479:    }
        -:  480:  }
        -:  481:
    #####:  482:  ecma_number_t n = (ecma_number_t) length;
        -:  483:#else /* JERRY_ESNEXT */
    #####:  484:  ecma_number_t n = (ecma_number_t) length;
        -:  485:
        -:  486:  /* 5. */
    #####:  487:  for (ecma_length_t index = 0; index < arguments_number; index++, n++)
        -:  488:  {
        -:  489:    /* 5.b */
    #####:  490:    ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (n);
    #####:  491:    ecma_value_t put_value = ecma_op_object_put (obj_p, index_str_p, argument_list_p[index], true);
    #####:  492:    ecma_deref_ecma_string (index_str_p);
        -:  493:
    #####:  494:    if (ECMA_IS_VALUE_ERROR (put_value))
        -:  495:    {
        -:  496:      return put_value;
        -:  497:    }
        -:  498:  }
        -:  499:
        -:  500:#endif /* JERRY_ESNEXT */
        -:  501:  /* 6 - 7. */
    #####:  502:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, n);
        -:  503:
    #####:  504:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  505:  {
    #####:  506:    return set_length_value;
        -:  507:  }
        -:  508:
    #####:  509:  return ecma_make_number_value (n);
        -:  510:} /* ecma_builtin_array_prototype_object_push */
        -:  511:
        -:  512:/**
        -:  513: * The Array.prototype object's 'reverse' routine
        -:  514: *
        -:  515: * See also:
        -:  516: *          ECMA-262 v5, 15.4.4.8
        -:  517: *
        -:  518: * @return ecma value
        -:  519: *         Returned value must be freed with ecma_free_value.
        -:  520: */
        -:  521:static ecma_value_t
    #####:  522:ecma_builtin_array_prototype_object_reverse (ecma_value_t this_arg, /**< this argument */
        -:  523:                                             ecma_object_t *obj_p, /**< object */
        -:  524:                                             ecma_length_t len) /**< object's length */
        -:  525:{
        -:  526:
    #####:  527:  if (ecma_op_object_is_fast_array (obj_p))
        -:  528:  {
    #####:  529:    uint32_t middle = (uint32_t) len / 2;
    #####:  530:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  531:
    #####:  532:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####:  533:        && len != 0)
        -:  534:    {
    #####:  535:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  536:
    #####:  537:      for (uint32_t i = 0; i < middle; i++)
        -:  538:      {
    #####:  539:        ecma_value_t tmp = buffer_p[i];
    #####:  540:        buffer_p[i] = buffer_p[len - 1 - i];
    #####:  541:        buffer_p[len - 1 - i] = tmp;
        -:  542:      }
        -:  543:
    #####:  544:      return ecma_copy_value (this_arg);
        -:  545:    }
        -:  546:  }
        -:  547:
    #####:  548:  ecma_length_t middle = len / 2;
    #####:  549:  for (ecma_length_t lower = 0; lower < middle; lower++)
        -:  550:  {
    #####:  551:    ecma_length_t upper = len - lower - 1;
    #####:  552:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  553:
    #####:  554:    ecma_string_t *lower_str_p = ecma_new_ecma_string_from_length (lower);
    #####:  555:    ecma_string_t *upper_str_p = ecma_new_ecma_string_from_length (upper);
        -:  556:
        -:  557:#if JERRY_ESNEXT
    #####:  558:    ecma_value_t lower_value = ECMA_VALUE_EMPTY;
    #####:  559:    ecma_value_t upper_value = ECMA_VALUE_EMPTY;
        -:  560:
    #####:  561:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
        -:  562:
        -:  563:#if JERRY_BUILTIN_PROXY
    #####:  564:    if (ECMA_IS_VALUE_ERROR (has_lower))
        -:  565:    {
    #####:  566:      goto clean_up;
        -:  567:    }
        -:  568:#endif /* JERRY_BUILTIN_PROXY */
        -:  569:
    #####:  570:    bool lower_exist = ecma_is_value_true (has_lower);
        -:  571:
    #####:  572:    if (lower_exist)
        -:  573:    {
    #####:  574:      lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  575:
    #####:  576:      if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  577:      {
    #####:  578:        goto clean_up;
        -:  579:      }
        -:  580:    }
        -:  581:
    #####:  582:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  583:
        -:  584:#if JERRY_BUILTIN_PROXY
    #####:  585:    if (ECMA_IS_VALUE_ERROR (has_upper))
        -:  586:    {
    #####:  587:      goto clean_up;
        -:  588:    }
        -:  589:#endif /* JERRY_BUILTIN_PROXY */
        -:  590:
    #####:  591:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  592:
    #####:  593:    if (upper_exist)
        -:  594:    {
    #####:  595:      upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  596:
    #####:  597:      if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  598:      {
    #####:  599:        goto clean_up;
        -:  600:      }
        -:  601:    }
        -:  602:#else /* !JERRY_ESNEXT */
    #####:  603:    ecma_value_t lower_value = ecma_op_object_get (obj_p, lower_str_p);
        -:  604:
    #####:  605:    if (ECMA_IS_VALUE_ERROR (lower_value))
        -:  606:    {
    #####:  607:      ecma_deref_ecma_string (lower_str_p);
    #####:  608:      ecma_deref_ecma_string (upper_str_p);
    #####:  609:      return ret_value;
        -:  610:    }
        -:  611:
    #####:  612:    ecma_value_t upper_value = ecma_op_object_get (obj_p, upper_str_p);
        -:  613:
    #####:  614:    if (ECMA_IS_VALUE_ERROR (upper_value))
        -:  615:    {
        -:  616:      goto clean_up;
        -:  617:    }
        -:  618:
    #####:  619:    ecma_value_t has_lower = ecma_op_object_has_property (obj_p, lower_str_p);
    #####:  620:    ecma_value_t has_upper = ecma_op_object_has_property (obj_p, upper_str_p);
        -:  621:
    #####:  622:    bool lower_exist = ecma_is_value_true (has_lower);
    #####:  623:    bool upper_exist = ecma_is_value_true (has_upper);
        -:  624:#endif /* JERRY_ESNEXT */
        -:  625:
    #####:  626:    if (lower_exist && upper_exist)
    #####:  627:    {
    #####:  628:      ecma_value_t outer_put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  629:
    #####:  630:      if (ECMA_IS_VALUE_ERROR (outer_put_value))
        -:  631:      {
    #####:  632:        goto clean_up;
        -:  633:      }
        -:  634:
    #####:  635:      ecma_value_t inner_put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  636:
    #####:  637:      if (ECMA_IS_VALUE_ERROR (inner_put_value))
        -:  638:      {
    #####:  639:        goto clean_up;
        -:  640:      }
        -:  641:    }
    #####:  642:    else if (!lower_exist && upper_exist)
    #####:  643:    {
    #####:  644:      ecma_value_t put_value = ecma_op_object_put (obj_p, lower_str_p, upper_value, true);
        -:  645:
    #####:  646:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  647:      {
    #####:  648:        goto clean_up;
        -:  649:      }
        -:  650:
    #####:  651:      ecma_value_t del_value = ecma_op_object_delete (obj_p, upper_str_p, true);
        -:  652:
    #####:  653:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  654:      {
    #####:  655:        goto clean_up;
        -:  656:      }
        -:  657:    }
    #####:  658:    else if (lower_exist)
        -:  659:    {
    #####:  660:      ecma_value_t del_value = ecma_op_object_delete (obj_p, lower_str_p, true);
        -:  661:
    #####:  662:      if (ECMA_IS_VALUE_ERROR (del_value))
        -:  663:      {
    #####:  664:        goto clean_up;
        -:  665:      }
        -:  666:
    #####:  667:      ecma_value_t put_value = ecma_op_object_put (obj_p, upper_str_p, lower_value, true);
        -:  668:
    #####:  669:      if (ECMA_IS_VALUE_ERROR (put_value))
        -:  670:      {
    #####:  671:        goto clean_up;
        -:  672:      }
        -:  673:    }
        -:  674:
    #####:  675:    ret_value = ECMA_VALUE_EMPTY;
        -:  676:
    #####:  677:clean_up:
    #####:  678:    ecma_free_value (upper_value);
    #####:  679:    ecma_free_value (lower_value);
    #####:  680:    ecma_deref_ecma_string (lower_str_p);
    #####:  681:    ecma_deref_ecma_string (upper_str_p);
        -:  682:
    #####:  683:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  684:    {
    #####:  685:      return ret_value;
        -:  686:    }
        -:  687:  }
        -:  688:
    #####:  689:  return ecma_copy_value (this_arg);
        -:  690:} /* ecma_builtin_array_prototype_object_reverse */
        -:  691:
        -:  692:/**
        -:  693: * The Array.prototype object's 'shift' routine
        -:  694: *
        -:  695: * See also:
        -:  696: *          ECMA-262 v5, 15.4.4.9
        -:  697: *
        -:  698: * @return ecma value
        -:  699: *         Returned value must be freed with ecma_free_value.
        -:  700: */
        -:  701:static ecma_value_t
    #####:  702:ecma_builtin_array_prototype_object_shift (ecma_object_t *obj_p, /**< object */
        -:  703:                                           ecma_length_t len) /**< object's length */
        -:  704:{
        -:  705:  /* 4. */
    #####:  706:  if (len == 0)
        -:  707:  {
    #####:  708:    ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ECMA_NUMBER_ZERO);
        -:  709:
    #####:  710:    return ECMA_IS_VALUE_ERROR (set_length_value) ? set_length_value : ECMA_VALUE_UNDEFINED;
        -:  711:  }
        -:  712:
    #####:  713:  if (ecma_op_object_is_fast_array (obj_p))
        -:  714:  {
    #####:  715:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  716:
    #####:  717:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####:  718:        && len != 0)
        -:  719:    {
    #####:  720:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
    #####:  721:      ecma_value_t ret_value = buffer_p[0];
        -:  722:
    #####:  723:      if (ecma_is_value_object (ret_value))
        -:  724:      {
    #####:  725:        ecma_ref_object (ecma_get_object_from_value (ret_value));
        -:  726:      }
        -:  727:
    #####:  728:      memmove (buffer_p, buffer_p + 1, (size_t) (sizeof (ecma_value_t) * (len - 1)));
        -:  729:
    #####:  730:      buffer_p[len - 1] = ECMA_VALUE_UNDEFINED;
    #####:  731:      ecma_delete_fast_array_properties (obj_p, (uint32_t) (len - 1));
        -:  732:
    #####:  733:      return ret_value;
        -:  734:    }
        -:  735:  }
        -:  736:
        -:  737:  /* 5. */
    #####:  738:  ecma_value_t first_value = ecma_op_object_get_by_index (obj_p, 0);
        -:  739:
    #####:  740:  if (ECMA_IS_VALUE_ERROR (first_value))
        -:  741:  {
    #####:  742:    return first_value;
        -:  743:  }
        -:  744:
        -:  745:  /* 6. and 7. */
    #####:  746:  for (ecma_length_t k = 1; k < len; k++)
        -:  747:  {
        -:  748:    /* 7.a - 7.c */
    #####:  749:    ecma_value_t curr_value = ecma_op_object_find_by_index (obj_p, k);
        -:  750:
    #####:  751:    if (ECMA_IS_VALUE_ERROR (curr_value))
        -:  752:    {
    #####:  753:      ecma_free_value (first_value);
    #####:  754:      return curr_value;
        -:  755:    }
        -:  756:
        -:  757:    /* 7.b */
    #####:  758:    ecma_length_t to = k - 1;
        -:  759:    ecma_value_t operation_value;
        -:  760:
    #####:  761:    if (ecma_is_value_found (curr_value))
        -:  762:    {
        -:  763:      /* 7.d.i, 7.d.ii */
    #####:  764:      operation_value = ecma_op_object_put_by_index (obj_p, to, curr_value, true);
    #####:  765:      ecma_free_value (curr_value);
        -:  766:    }
        -:  767:    else
        -:  768:    {
        -:  769:      /* 7.e.i */
    #####:  770:      operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -:  771:    }
        -:  772:
    #####:  773:    if (ECMA_IS_VALUE_ERROR (operation_value))
        -:  774:    {
    #####:  775:      ecma_free_value (first_value);
    #####:  776:      return operation_value;
        -:  777:    }
        -:  778:  }
        -:  779:
        -:  780:  /* 8. */
    #####:  781:  ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, --len, true);
        -:  782:
    #####:  783:  if (ECMA_IS_VALUE_ERROR (del_value))
        -:  784:  {
    #####:  785:    ecma_free_value (first_value);
    #####:  786:    return del_value;
        -:  787:  }
        -:  788:
        -:  789:  /* 9. */
    #####:  790:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) len));
        -:  791:
    #####:  792:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  793:  {
    #####:  794:    ecma_free_value (first_value);
    #####:  795:    return set_length_value;
        -:  796:  }
        -:  797:
        -:  798:  /* 10. */
    #####:  799:  return first_value;
        -:  800:} /* ecma_builtin_array_prototype_object_shift */
        -:  801:
        -:  802:/**
        -:  803: * The Array.prototype object's 'slice' routine
        -:  804: *
        -:  805: * See also:
        -:  806: *          ECMA-262 v5, 15.4.4.10
        -:  807: *
        -:  808: * @return ecma value
        -:  809: *         Returned value must be freed with ecma_free_value.
        -:  810: */
        -:  811:static ecma_value_t
        2:  812:ecma_builtin_array_prototype_object_slice (ecma_value_t arg1, /**< start */
        -:  813:                                           ecma_value_t arg2, /**< end */
        -:  814:                                           ecma_object_t *obj_p, /**< object */
        -:  815:                                           ecma_length_t len) /**< object's length */
        -:  816:{
        2:  817:  ecma_length_t start = 0, end = len;
        -:  818:
        -:  819:  /* 5. 6.*/
        2:  820:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg1,
        -:  821:                                                                      len,
        -:  822:                                                                      &start)))
        -:  823:  {
    #####:  824:    return ECMA_VALUE_ERROR;
        -:  825:  }
        -:  826:
        -:  827:  /* 7. */
        2:  828:  if (ecma_is_value_undefined (arg2))
        -:  829:  {
    #####:  830:    end = len;
        -:  831:  }
        -:  832:  else
        -:  833:  {
        -:  834:    /* 7. part 2, 8.*/
        2:  835:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (arg2,
        -:  836:                                                                        len,
        -:  837:                                                                        &end)))
        -:  838:    {
    #####:  839:      return ECMA_VALUE_ERROR;
        -:  840:    }
        -:  841:  }
        -:  842:
        2:  843:  JERRY_ASSERT (start <= len && end <= len);
        -:  844:
        2:  845:  bool use_fast_path = ecma_op_object_is_fast_array (obj_p);
        2:  846:  ecma_length_t copied_length = (end > start) ? end - start : 0;
        -:  847:#if JERRY_ESNEXT
        2:  848:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, copied_length);
        -:  849:
        2:  850:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -:  851:  {
    #####:  852:    return ECMA_VALUE_ERROR;
        -:  853:  }
        -:  854:
        2:  855:  use_fast_path &= ecma_op_object_is_fast_array (new_array_p);
        -:  856:#else /* !JERRY_ESNEXT */
    #####:  857:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -:  858:#endif /* JERRY_ESNEXT */
        -:  859:
        2:  860:  if (use_fast_path && copied_length > 0)
        -:  861:  {
        2:  862:    ecma_extended_object_t *ext_from_obj_p = (ecma_extended_object_t *) obj_p;
        -:  863:
        2:  864:    if (ext_from_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -:  865:    {
        2:  866:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -:  867:      {
        -:  868:        /**
        -:  869:         * Very unlikely case: the buffer copied from is a fast buffer and the property list was deleted.
        -:  870:         * There is no need to do any copy.
        -:  871:         */
    #####:  872:        return ecma_make_object_value (new_array_p);
        -:  873:      }
        -:  874:
        -:  875:      /* Source array's length could be changed during the start/end normalization.
        -:  876:       * If the "end" value is greater than the current length, clamp the value to avoid buffer-overflow. */
        -:  877:
        2:  878:      ecma_extended_object_t *ext_to_obj_p = (ecma_extended_object_t *) new_array_p;
        -:  879:
        -:  880:#if JERRY_ESNEXT
        2:  881:      uint32_t target_length = ext_to_obj_p->u.array.length;
        -:  882:      ecma_value_t *to_buffer_p;
        2:  883:      JERRY_ASSERT (copied_length <= UINT32_MAX);
        -:  884:
        2:  885:      if (copied_length == target_length)
        -:  886:      {
        2:  887:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  888:      }
    #####:  889:      else if (copied_length > target_length)
        -:  890:      {
    #####:  891:        to_buffer_p = ecma_fast_array_extend (new_array_p, (uint32_t) copied_length);
        -:  892:      }
        -:  893:      else
        -:  894:      {
    #####:  895:        ecma_delete_fast_array_properties (new_array_p, (uint32_t) copied_length);
    #####:  896:        to_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, new_array_p->u1.property_list_cp);
        -:  897:      }
        -:  898:#else /* !JERRY_ESNEXT */
    #####:  899:      ecma_value_t *to_buffer_p = ecma_fast_array_extend (new_array_p, copied_length);
        -:  900:#endif /* JERRY_ESNEXT */
        -:  901:
        2:  902:      ecma_value_t *from_buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -:  903:
        -:  904:      /* 9. */
        2:  905:      uint32_t n = 0;
        -:  906:
       18:  907:      for (uint32_t k = (uint32_t) start; k < (uint32_t) end; k++, n++)
        -:  908:      {
        -:  909:#if JERRY_ESNEXT
       18:  910:        ecma_free_value_if_not_object (to_buffer_p[n]);
        -:  911:#endif /* JERRY_ESNEXT */
       18:  912:        to_buffer_p[n] = ecma_copy_value_if_not_object (from_buffer_p[k]);
        -:  913:      }
        -:  914:
    #####:  915:      ext_to_obj_p->u.array.length_prop_and_hole_count &= ECMA_FAST_ARRAY_HOLE_ONE - 1;
        -:  916:
    #####:  917:      return ecma_make_object_value (new_array_p);
        -:  918:    }
        -:  919:  }
        -:  920:
        -:  921:  /* 9. */
    #####:  922:  ecma_length_t n = 0;
        -:  923:
        -:  924:  /* 10. */
    #####:  925:  for (ecma_length_t k = start; k < end; k++, n++)
        -:  926:  {
        -:  927:    /* 10.c */
    #####:  928:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k);
        -:  929:
    #####:  930:    if (ECMA_IS_VALUE_ERROR (get_value))
        -:  931:    {
    #####:  932:      ecma_deref_object (new_array_p);
    #####:  933:      return get_value;
        -:  934:    }
        -:  935:
    #####:  936:    if (ecma_is_value_found (get_value))
        -:  937:    {
        -:  938:      /* 10.c.ii */
        -:  939:      ecma_value_t put_comp;
        -:  940:#if JERRY_ESNEXT
    #####:  941:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  942:#else /* !JERRY_ESNEXT */
    #####:  943:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -:  944:#endif /* JERRY_ESNEXT */
    #####:  945:      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -:  946:                                                        n,
        -:  947:                                                        get_value,
        -:  948:                                                        prop_flags);
    #####:  949:      ecma_free_value (get_value);
        -:  950:
        -:  951:#if JERRY_ESNEXT
    #####:  952:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  953:      {
    #####:  954:        ecma_deref_object (new_array_p);
    #####:  955:        return put_comp;
        -:  956:      }
        -:  957:#else /* !JERRY_ESNEXT */
        -:  958:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  959:#endif /* JERRY_ESNEXT */
        -:  960:    }
        -:  961:  }
        -:  962:
        -:  963:#if JERRY_ESNEXT
    #####:  964:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (new_array_p, ((ecma_number_t) n));
        -:  965:
    #####:  966:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -:  967:  {
    #####:  968:    ecma_deref_object (new_array_p);
    #####:  969:    return set_length_value;
        -:  970:  }
        -:  971:#endif /* JERRY_ESNEXT */
        -:  972:
    #####:  973:  return ecma_make_object_value (new_array_p);
        -:  974:} /* ecma_builtin_array_prototype_object_slice */
        -:  975:
        -:  976:/**
        -:  977: * SortCompare abstract method
        -:  978: *
        -:  979: * See also:
        -:  980: *          ECMA-262 v5, 15.4.4.11
        -:  981: *
        -:  982: * @return ecma value
        -:  983: *         Returned value must be freed with ecma_free_value.
        -:  984: */
        -:  985:static ecma_value_t
    #####:  986:ecma_builtin_array_prototype_object_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -:  987:                                                         ecma_value_t rhs, /**< right value */
        -:  988:                                                         ecma_value_t compare_func, /**< compare function */
        -:  989:                                                         ecma_object_t *array_buffer_p) /**< arrayBuffer */
        -:  990:{
        -:  991:  JERRY_UNUSED (array_buffer_p);
        -:  992:  /*
        -:  993:   * ECMA-262 v5, 15.4.4.11 NOTE1: Because non-existent property values always
        -:  994:   * compare greater than undefined property values, and undefined always
        -:  995:   * compares greater than any other value, undefined property values always
        -:  996:   * sort to the end of the result, followed by non-existent property values.
        -:  997:   */
    #####:  998:  bool lhs_is_undef = ecma_is_value_undefined (lhs);
    #####:  999:  bool rhs_is_undef = ecma_is_value_undefined (rhs);
        -: 1000:
    #####: 1001:  if (lhs_is_undef)
        -: 1002:  {
    #####: 1003:    return ecma_make_integer_value (rhs_is_undef ? 0 : 1);
        -: 1004:  }
        -: 1005:
    #####: 1006:  if (rhs_is_undef)
        -: 1007:  {
    #####: 1008:    return ecma_make_integer_value (-1);
        -: 1009:  }
        -: 1010:
    #####: 1011:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1012:
    #####: 1013:  if (ecma_is_value_undefined (compare_func))
        -: 1014:  {
        -: 1015:    /* Default comparison when no compare_func is passed. */
    #####: 1016:    ecma_string_t *lhs_str_p = ecma_op_to_string (lhs);
    #####: 1017:    if (JERRY_UNLIKELY (lhs_str_p == NULL))
        -: 1018:    {
    #####: 1019:      return ECMA_VALUE_ERROR;
        -: 1020:    }
        -: 1021:
    #####: 1022:    ecma_string_t *rhs_str_p = ecma_op_to_string (rhs);
    #####: 1023:    if (JERRY_UNLIKELY (rhs_str_p == NULL))
        -: 1024:    {
    #####: 1025:      ecma_deref_ecma_string (lhs_str_p);
    #####: 1026:      return ECMA_VALUE_ERROR;
        -: 1027:    }
        -: 1028:
    #####: 1029:    if (ecma_compare_ecma_strings_relational (lhs_str_p, rhs_str_p))
        -: 1030:    {
    #####: 1031:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1032:    }
    #####: 1033:    else if (!ecma_compare_ecma_strings (lhs_str_p, rhs_str_p))
        -: 1034:    {
    #####: 1035:      result = ECMA_NUMBER_ONE;
        -: 1036:    }
        -: 1037:    else
        -: 1038:    {
    #####: 1039:      result = ECMA_NUMBER_ZERO;
        -: 1040:    }
        -: 1041:
    #####: 1042:    ecma_deref_ecma_string (rhs_str_p);
    #####: 1043:    ecma_deref_ecma_string (lhs_str_p);
        -: 1044:  }
        -: 1045:  else
        -: 1046:  {
        -: 1047:    /*
        -: 1048:     * compare_func, if not undefined, will always contain a callable function object.
        -: 1049:     * We checked this previously, before this function was called.
        -: 1050:     */
    #####: 1051:    JERRY_ASSERT (ecma_op_is_callable (compare_func));
    #####: 1052:    ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1053:
    #####: 1054:    ecma_value_t compare_args[] = { lhs, rhs };
        -: 1055:
    #####: 1056:    ecma_value_t call_value = ecma_op_function_call (comparefn_obj_p,
        -: 1057:                                                     ECMA_VALUE_UNDEFINED,
        -: 1058:                                                     compare_args,
        -: 1059:                                                     2);
    #####: 1060:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1061:    {
    #####: 1062:      return call_value;
        -: 1063:    }
        -: 1064:
    #####: 1065:    if (!ecma_is_value_number (call_value))
        -: 1066:    {
    #####: 1067:      ecma_number_t ret_num;
        -: 1068:
    #####: 1069:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (call_value, &ret_num)))
        -: 1070:      {
    #####: 1071:        ecma_free_value (call_value);
    #####: 1072:        return ECMA_VALUE_ERROR;
        -: 1073:      }
        -: 1074:
    #####: 1075:      result = ret_num;
        -: 1076:    }
        -: 1077:    else
        -: 1078:    {
    #####: 1079:      result = ecma_get_number_from_value (call_value);
        -: 1080:    }
        -: 1081:
    #####: 1082:    ecma_free_value (call_value);
        -: 1083:  }
        -: 1084:
    #####: 1085:  return ecma_make_number_value (result);
        -: 1086:} /* ecma_builtin_array_prototype_object_sort_compare_helper */
        -: 1087:
        -: 1088:/**
        -: 1089: * The Array.prototype object's 'sort' routine
        -: 1090: *
        -: 1091: * See also:
        -: 1092: *          ECMA-262 v5, 15.4.4.11
        -: 1093: *
        -: 1094: * @return ecma value
        -: 1095: *         Returned value must be freed with ecma_free_value.
        -: 1096: */
        -: 1097:static ecma_value_t
    #####: 1098:ecma_builtin_array_prototype_object_sort (ecma_value_t this_arg, /**< this argument */
        -: 1099:                                          ecma_value_t arg1, /**< comparefn */
        -: 1100:                                          ecma_object_t *obj_p) /**< object */
        -: 1101:{
        -: 1102:  /* Check if the provided compare function is callable. */
    #####: 1103:  if (!ecma_is_value_undefined (arg1) && !ecma_op_is_callable (arg1))
        -: 1104:  {
    #####: 1105:    return ecma_raise_type_error (ECMA_ERR_MSG ("Compare function is not callable"));
        -: 1106:  }
        -: 1107:
    #####: 1108:  ecma_length_t len;
    #####: 1109:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &len);
        -: 1110:
    #####: 1111:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 1112:  {
    #####: 1113:    return len_value;
        -: 1114:  }
    #####: 1115:  ecma_collection_t *array_index_props_p = ecma_new_collection ();
        -: 1116:
    #####: 1117:  for (uint32_t i = 0; i < len; i++)
        -: 1118:  {
    #####: 1119:    ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -: 1120:
    #####: 1121:    ecma_property_descriptor_t prop_desc;
    #####: 1122:    ecma_value_t get_desc = ecma_op_object_get_own_property_descriptor (obj_p, prop_name_p, &prop_desc);
        -: 1123:
    #####: 1124:    if (ECMA_IS_VALUE_ERROR (get_desc))
        -: 1125:    {
    #####: 1126:      ecma_collection_free (array_index_props_p);
    #####: 1127:      ecma_deref_ecma_string (prop_name_p);
    #####: 1128:      return get_desc;
        -: 1129:    }
        -: 1130:
    #####: 1131:    if (ecma_is_value_true (get_desc))
        -: 1132:    {
    #####: 1133:      ecma_ref_ecma_string (prop_name_p);
    #####: 1134:      ecma_collection_push_back (array_index_props_p, ecma_make_string_value (prop_name_p));
    #####: 1135:      ecma_free_property_descriptor (&prop_desc);
    #####: 1136:      continue;
        -: 1137:    }
        -: 1138:  }
        -: 1139:
    #####: 1140:  uint32_t defined_prop_count = array_index_props_p->item_count;
        -: 1141:
    #####: 1142:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####: 1143:  uint32_t copied_num = 0;
    #####: 1144:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, defined_prop_count, ecma_value_t);
        -: 1145:
    #####: 1146:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1147:
        -: 1148:  /* Copy unsorted array into a native c array. */
    #####: 1149:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1150:  {
    #####: 1151:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1152:
    #####: 1153:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1154:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1155:
    #####: 1156:    if (index >= len)
        -: 1157:    {
    #####: 1158:      break;
        -: 1159:    }
        -: 1160:
    #####: 1161:    ecma_value_t index_value = ecma_op_object_get (obj_p, property_name_p);
        -: 1162:
    #####: 1163:    if (ECMA_IS_VALUE_ERROR (index_value))
        -: 1164:    {
    #####: 1165:      goto clean_up;
        -: 1166:    }
        -: 1167:
    #####: 1168:    values_buffer[copied_num++] = index_value;
        -: 1169:  }
        -: 1170:
    #####: 1171:  JERRY_ASSERT (copied_num == defined_prop_count);
        -: 1172:
        -: 1173:  /* Sorting. */
    #####: 1174:  if (copied_num > 1)
        -: 1175:  {
    #####: 1176:    const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_array_prototype_object_sort_compare_helper;
    #####: 1177:    ecma_value_t sort_value = ecma_builtin_helper_array_merge_sort_helper (values_buffer,
        -: 1178:                                                                           (uint32_t) (copied_num),
        -: 1179:                                                                           arg1,
        -: 1180:                                                                           sort_cb,
        -: 1181:                                                                           NULL);
    #####: 1182:    if (ECMA_IS_VALUE_ERROR (sort_value))
        -: 1183:    {
    #####: 1184:      goto clean_up;
        -: 1185:    }
        -: 1186:
    #####: 1187:    ecma_free_value (sort_value);
        -: 1188:  }
        -: 1189:
        -: 1190:  /* Put sorted values to the front of the array. */
    #####: 1191:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1192:  {
    #####: 1193:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, index, values_buffer[index], true);
        -: 1194:
    #####: 1195:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1196:    {
    #####: 1197:      goto clean_up;
        -: 1198:    }
        -: 1199:  }
        -: 1200:
    #####: 1201:  ret_value = ECMA_VALUE_EMPTY;
        -: 1202:
    #####: 1203:clean_up:
        -: 1204:  /* Free values that were copied to the local array. */
    #####: 1205:  for (uint32_t index = 0; index < copied_num; index++)
        -: 1206:  {
    #####: 1207:    ecma_free_value (values_buffer[index]);
        -: 1208:  }
        -: 1209:
    #####: 1210:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1211:
    #####: 1212:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 1213:  {
    #####: 1214:    ecma_collection_free (array_index_props_p);
    #####: 1215:    return ret_value;
        -: 1216:  }
        -: 1217:
    #####: 1218:  JERRY_ASSERT (ecma_is_value_empty (ret_value));
        -: 1219:
        -: 1220:  /* Undefined properties should be in the back of the array. */
    #####: 1221:  ecma_value_t *buffer_p = array_index_props_p->buffer_p;
        -: 1222:
    #####: 1223:  for (uint32_t i = 0; i < array_index_props_p->item_count; i++)
        -: 1224:  {
    #####: 1225:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 1226:
    #####: 1227:    uint32_t index = ecma_string_get_array_index (property_name_p);
    #####: 1228:    JERRY_ASSERT (index != ECMA_STRING_NOT_ARRAY_INDEX);
        -: 1229:
    #####: 1230:    if (index >= copied_num && index < len)
        -: 1231:    {
    #####: 1232:      ecma_value_t del_value = ecma_op_object_delete (obj_p, property_name_p, true);
        -: 1233:
    #####: 1234:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1235:      {
    #####: 1236:        ecma_collection_free (array_index_props_p);
    #####: 1237:        return del_value;
        -: 1238:      }
        -: 1239:    }
        -: 1240:  }
        -: 1241:
    #####: 1242:  ecma_collection_free (array_index_props_p);
        -: 1243:
    #####: 1244:  return ecma_copy_value (this_arg);
        -: 1245:} /* ecma_builtin_array_prototype_object_sort */
        -: 1246:
        -: 1247:/**
        -: 1248: * The Array.prototype object's 'splice' routine
        -: 1249: *
        -: 1250: * See also:
        -: 1251: *          ECMA-262 v11, 22.1.3.28
        -: 1252: *          ECMA-262 v5, 15.4.4.12
        -: 1253: *
        -: 1254: * @return ecma value
        -: 1255: *         Returned value must be freed with ecma_free_value.
        -: 1256: */
        -: 1257:static ecma_value_t
    #####: 1258:ecma_builtin_array_prototype_object_splice (const ecma_value_t args[], /**< arguments list */
        -: 1259:                                            uint32_t args_number, /**< number of arguments */
        -: 1260:                                            ecma_object_t *obj_p, /**< object */
        -: 1261:                                            ecma_length_t len) /**< object's length */
        -: 1262:{
    #####: 1263:  ecma_length_t actual_start = 0;
    #####: 1264:  ecma_length_t actual_delete_count = 0;
    #####: 1265:  ecma_length_t insert_count = 0;
        -: 1266:
    #####: 1267:  if (args_number > 0)
        -: 1268:  {
        -: 1269:    /* ES5.1: 6, ES11: 4. */
    #####: 1270:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0],
        -: 1271:                                                                        len,
        -: 1272:                                                                        &actual_start)))
        -: 1273:    {
    #####: 1274:      return ECMA_VALUE_ERROR;
        -: 1275:    }
        -: 1276:
        -: 1277:    /* ES11: 6. */
    #####: 1278:    if (args_number == 1)
        -: 1279:    {
    #####: 1280:      actual_delete_count = len - actual_start;
        -: 1281:    }
        -: 1282:    /* ES11: 7. */
        -: 1283:    else
        -: 1284:    {
    #####: 1285:      insert_count = args_number - 2;
        -: 1286:
    #####: 1287:      ecma_number_t delete_num;
    #####: 1288:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &delete_num)))
        -: 1289:      {
    #####: 1290:        return ECMA_VALUE_ERROR;
        -: 1291:      }
        -: 1292:
        -: 1293:      /* ES5.1: 7 */
    #####: 1294:      actual_delete_count = (ecma_length_t) (JERRY_MIN (JERRY_MAX (delete_num, 0),
        -: 1295:                                                        (ecma_number_t) (len - actual_start)));
        -: 1296:    }
        -: 1297:  }
        -: 1298:
    #####: 1299:  ecma_length_t new_length = len + insert_count - actual_delete_count;
        -: 1300:
        -: 1301:#if JERRY_ESNEXT
        -: 1302:  /* ES11: 8. */
    #####: 1303:  if ((ecma_number_t) new_length > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1304:  {
    #####: 1305:    return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid new Array length"));
        -: 1306:  }
        -: 1307:
        -: 1308:  /* ES11: 9. */
    #####: 1309:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, actual_delete_count);
        -: 1310:
    #####: 1311:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 1312:  {
    #####: 1313:    return ECMA_VALUE_ERROR;
        -: 1314:  }
        -: 1315:#else /* !JERRY_ESNEXT */
        -: 1316:  /* ES5.1: 2. */
    #####: 1317:  ecma_object_t *new_array_p = ecma_op_new_array_object (actual_delete_count);
        -: 1318:#endif /* JERRY_ESNEXT */
        -: 1319:
        -: 1320:  /* ES5.1: 8, ES11: 10. */
    #####: 1321:  ecma_length_t k = 0;
        -: 1322:
        -: 1323:  /* ES5.1: 9, ES11: 11. */
    #####: 1324:  for (; k < actual_delete_count; k++)
        -: 1325:  {
    #####: 1326:    ecma_length_t from = actual_start + k;
    #####: 1327:    ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1328:
    #####: 1329:    if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1330:    {
    #####: 1331:      ecma_deref_object (new_array_p);
    #####: 1332:      return from_present;
        -: 1333:    }
        -: 1334:
    #####: 1335:    if (ecma_is_value_found (from_present))
        -: 1336:    {
        -: 1337:#if JERRY_ESNEXT
    #####: 1338:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 1339:#else /* !JERRY_ESNEXT */
    #####: 1340:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 1341:#endif /* JERRY_ESNEXT */
        -: 1342:
    #####: 1343:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 1344:                                                                     k,
        -: 1345:                                                                     from_present,
        -: 1346:                                                                     prop_flags);
    #####: 1347:      ecma_free_value (from_present);
        -: 1348:
        -: 1349:#if JERRY_ESNEXT
    #####: 1350:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 1351:      {
    #####: 1352:        ecma_deref_object (new_array_p);
    #####: 1353:        return put_comp;
        -: 1354:      }
        -: 1355:#else /* !JERRY_ESNEXT */
        -: 1356:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 1357:#endif /* JERRY_ESNEXT */
        -: 1358:    }
        -: 1359:  }
        -: 1360:
        -: 1361:#if JERRY_ESNEXT
        -: 1362:  /* ES11: 12. */
    #####: 1363:  ecma_value_t set_length = ecma_builtin_array_prototype_helper_set_length (new_array_p,
        -: 1364:                                                                            ((ecma_number_t) actual_delete_count));
        -: 1365:
    #####: 1366:  if (ECMA_IS_VALUE_ERROR (set_length))
        -: 1367:  {
    #####: 1368:    ecma_deref_object (new_array_p);
    #####: 1369:    return set_length;
        -: 1370:  }
        -: 1371:#endif /* JERRY_ESNEXT */
        -: 1372:
        -: 1373:  /* ES5.1: 12, ES11: 15. */
    #####: 1374:  if (insert_count < actual_delete_count)
        -: 1375:  {
    #####: 1376:    for (k = actual_start; k < len - actual_delete_count; k++)
        -: 1377:    {
    #####: 1378:      ecma_length_t from = k + actual_delete_count;
    #####: 1379:      ecma_length_t to = k + insert_count;
        -: 1380:
    #####: 1381:      ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1382:
    #####: 1383:      if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1384:      {
    #####: 1385:        ecma_deref_object (new_array_p);
    #####: 1386:        return from_present;
        -: 1387:      }
        -: 1388:
        -: 1389:      ecma_value_t operation_value;
        -: 1390:
    #####: 1391:      if (ecma_is_value_found (from_present))
        -: 1392:      {
    #####: 1393:        operation_value = ecma_op_object_put_by_index (obj_p, to, from_present, true);
    #####: 1394:        ecma_free_value (from_present);
        -: 1395:      }
        -: 1396:      else
        -: 1397:      {
    #####: 1398:        operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -: 1399:      }
        -: 1400:
    #####: 1401:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1402:      {
    #####: 1403:        ecma_deref_object (new_array_p);
    #####: 1404:        return operation_value;
        -: 1405:      }
        -: 1406:    }
        -: 1407:
    #####: 1408:    k = len;
        -: 1409:
    #####: 1410:    for (k = len; k > new_length; k--)
        -: 1411:    {
    #####: 1412:      ecma_value_t del_value = ecma_op_object_delete_by_index (obj_p, k - 1, true);
        -: 1413:
    #####: 1414:      if (ECMA_IS_VALUE_ERROR (del_value))
        -: 1415:      {
    #####: 1416:        ecma_deref_object (new_array_p);
    #####: 1417:        return del_value;
        -: 1418:      }
        -: 1419:    }
        -: 1420:  }
        -: 1421:  /* ES5.1: 13, ES11: 16. */
    #####: 1422:  else if (insert_count > actual_delete_count)
        -: 1423:  {
    #####: 1424:    for (k = len - actual_delete_count; k > actual_start; k--)
        -: 1425:    {
    #####: 1426:      ecma_length_t from = k + actual_delete_count - 1;
    #####: 1427:      ecma_length_t to = k + insert_count - 1;
        -: 1428:
    #####: 1429:      ecma_value_t from_present = ecma_op_object_find_by_index (obj_p, from);
        -: 1430:
    #####: 1431:      if (ECMA_IS_VALUE_ERROR (from_present))
        -: 1432:      {
    #####: 1433:        ecma_deref_object (new_array_p);
    #####: 1434:        return from_present;
        -: 1435:      }
        -: 1436:
        -: 1437:      ecma_value_t operation_value;
        -: 1438:
    #####: 1439:      if (ecma_is_value_found (from_present))
        -: 1440:      {
    #####: 1441:        operation_value = ecma_op_object_put_by_index (obj_p, to, from_present, true);
    #####: 1442:        ecma_free_value (from_present);
        -: 1443:      }
        -: 1444:      else
        -: 1445:      {
    #####: 1446:        operation_value = ecma_op_object_delete_by_index (obj_p, to, true);
        -: 1447:      }
        -: 1448:
    #####: 1449:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1450:      {
    #####: 1451:        ecma_deref_object (new_array_p);
    #####: 1452:        return operation_value;
        -: 1453:      }
        -: 1454:    }
        -: 1455:  }
        -: 1456:
        -: 1457:  /* ES5.1: 14, ES11: 17. */
    #####: 1458:  k = actual_start;
        -: 1459:
        -: 1460:  /* ES5.1: 15, ES11: 18. */
    #####: 1461:  uint32_t idx = 0;
    #####: 1462:  for (uint32_t arg_index = 2; arg_index < args_number; arg_index++, idx++)
        -: 1463:  {
    #####: 1464:    ecma_value_t put_value = ecma_op_object_put_by_index (obj_p,
        -: 1465:                                                          actual_start + idx,
    #####: 1466:                                                          args[arg_index],
        -: 1467:                                                          true);
        -: 1468:
    #####: 1469:    if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1470:    {
    #####: 1471:      ecma_deref_object (new_array_p);
    #####: 1472:      return put_value;
        -: 1473:    }
        -: 1474:  }
        -: 1475:
        -: 1476:  /* ES5.1: 16, ES11: 19. */
    #####: 1477:  ecma_value_t set_new_length = ecma_builtin_array_prototype_helper_set_length (obj_p, ((ecma_number_t) new_length));
        -: 1478:
    #####: 1479:  if (ECMA_IS_VALUE_ERROR (set_new_length))
        -: 1480:  {
    #####: 1481:    ecma_deref_object (new_array_p);
    #####: 1482:    return set_new_length;
        -: 1483:  }
        -: 1484:
        -: 1485:  /* ES5.1: 17, ES11: 20. */
    #####: 1486:  return ecma_make_object_value (new_array_p);
        -: 1487:} /* ecma_builtin_array_prototype_object_splice */
        -: 1488:
        -: 1489:/**
        -: 1490: * The Array.prototype object's 'unshift' routine
        -: 1491: *
        -: 1492: * See also:
        -: 1493: *          ECMA-262  v5, 15.4.4.13
        -: 1494: *          ECMA-262 v11, 22.1.3.31
        -: 1495: *
        -: 1496: * @return ecma value
        -: 1497: *         Returned value must be freed with ecma_free_value.
        -: 1498: */
        -: 1499:static ecma_value_t
    #####: 1500:ecma_builtin_array_prototype_object_unshift (const ecma_value_t args[], /**< arguments list */
        -: 1501:                                             uint32_t args_number, /**< number of arguments */
        -: 1502:                                             ecma_object_t *obj_p, /**< object */
        -: 1503:                                             ecma_length_t len) /**< object's length */
        -: 1504:{
        -: 1505:
    #####: 1506:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1507:  {
    #####: 1508:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1509:
    #####: 1510:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 1511:        && len != 0)
        -: 1512:    {
    #####: 1513:      if (args_number > UINT32_MAX - len)
        -: 1514:      {
    #####: 1515:        return ecma_raise_range_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
        -: 1516:      }
        -: 1517:
    #####: 1518:      if (args_number == 0)
        -: 1519:      {
    #####: 1520:        return ecma_make_uint32_value ((uint32_t) len);
        -: 1521:      }
        -: 1522:
    #####: 1523:      uint32_t new_length = ((uint32_t) len) + args_number;
    #####: 1524:      ecma_value_t *buffer_p = ecma_fast_array_extend (obj_p, new_length);
    #####: 1525:      memmove (buffer_p + args_number, buffer_p, (size_t) (sizeof (ecma_value_t) * len));
        -: 1526:
    #####: 1527:      uint32_t index = 0;
        -: 1528:
    #####: 1529:      while (index < args_number)
        -: 1530:      {
    #####: 1531:        buffer_p[index] = ecma_copy_value_if_not_object (args[index]);
    #####: 1532:        index++;
        -: 1533:      }
        -: 1534:
    #####: 1535:      ext_obj_p->u.array.length_prop_and_hole_count -= args_number * ECMA_FAST_ARRAY_HOLE_ONE;
        -: 1536:
    #####: 1537:      return ecma_make_uint32_value (new_length);
        -: 1538:    }
        -: 1539:  }
        -: 1540:
        -: 1541:#if JERRY_ESNEXT
    #####: 1542:  const bool should_iterate = args_number > 0;
        -: 1543:#else /* !JERRY_ESNEXT */
        -: 1544:  const bool should_iterate = true;
        -: 1545:#endif /* JERRY_ESNEXT */
    #####: 1546:  if (should_iterate)
        -: 1547:  {
        -: 1548:#if JERRY_ESNEXT
        -: 1549:    /* ES11:4.a. */
    #####: 1550:    if ((ecma_number_t) (len + args_number) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1551:    {
    #####: 1552:      return ecma_raise_type_error (ECMA_ERR_MSG ("Unshift elements over 2**53-1 length is disallowed"));
        -: 1553:    }
        -: 1554:#endif /* JERRY_ESNEXT */
        -: 1555:
        -: 1556:    /* ES5.1:5.,6. ES11: 4.b, 4.c */
    #####: 1557:    for (ecma_length_t k = len; k > 0; k--)
        -: 1558:    {
        -: 1559:      /* ES5.1:6.a, 6.c, ES11:4.c.i., 4.c.iii.  */
    #####: 1560:      ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, k - 1);
        -: 1561:
    #####: 1562:      if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1563:      {
    #####: 1564:        return get_value;
        -: 1565:      }
        -: 1566:
        -: 1567:      /* ES5.1:6.b, ES11:4.c.ii. */
    #####: 1568:      ecma_number_t new_idx = ((ecma_number_t) k) + ((ecma_number_t) args_number) - 1;
    #####: 1569:      ecma_string_t *index_str_p = ecma_new_ecma_string_from_number (new_idx);
        -: 1570:      ecma_value_t operation_value;
        -: 1571:
    #####: 1572:      if (ecma_is_value_found (get_value))
        -: 1573:      {
        -: 1574:        /* ES5.1:6.d.i, 6.d.ii, ES11:4.c.iv. */
    #####: 1575:        operation_value = ecma_op_object_put (obj_p, index_str_p, get_value, true);
    #####: 1576:        ecma_free_value (get_value);
        -: 1577:      }
        -: 1578:      else
        -: 1579:      {
        -: 1580:        /* ES5.1:6.e.i, ES11:4.c.v. */
    #####: 1581:        operation_value = ecma_op_object_delete (obj_p, index_str_p, true);
        -: 1582:      }
        -: 1583:
    #####: 1584:      ecma_deref_ecma_string (index_str_p);
        -: 1585:
    #####: 1586:      if (ECMA_IS_VALUE_ERROR (operation_value))
        -: 1587:      {
    #####: 1588:        return operation_value;
        -: 1589:      }
        -: 1590:    }
        -: 1591:
    #####: 1592:    for (uint32_t arg_index = 0; arg_index < args_number; arg_index++)
        -: 1593:    {
        -: 1594:      /* ES5.1:9.b, ES11:4.f.ii.  */
    #####: 1595:      ecma_value_t put_value = ecma_op_object_put_by_index (obj_p, arg_index, args[arg_index], true);
        -: 1596:
    #####: 1597:      if (ECMA_IS_VALUE_ERROR (put_value))
        -: 1598:      {
    #####: 1599:        return put_value;
        -: 1600:      }
        -: 1601:    }
        -: 1602:  }
        -: 1603:
        -: 1604:  /* ES5.1:10., ES11:5. */
    #####: 1605:  ecma_number_t new_len = ((ecma_number_t) len) + ((ecma_number_t) args_number);
    #####: 1606:  ecma_value_t set_length_value = ecma_builtin_array_prototype_helper_set_length (obj_p, new_len);
        -: 1607:
    #####: 1608:  if (ECMA_IS_VALUE_ERROR (set_length_value))
        -: 1609:  {
    #####: 1610:    return set_length_value;
        -: 1611:  }
        -: 1612:
    #####: 1613:  return ecma_make_number_value (new_len);
        -: 1614:} /* ecma_builtin_array_prototype_object_unshift */
        -: 1615:
        -: 1616:/**
        -: 1617: * The Array.prototype object's 'at' routine
        -: 1618: *
        -: 1619: * See also:
        -: 1620: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -: 1621: *          from: https://tc39.es/proposal-relative-indexing-method
        -: 1622: *
        -: 1623: * @return ecma value
        -: 1624: *         Returned value must be freed with ecma_free_value.
        -: 1625: */
        -: 1626:static ecma_value_t
    #####: 1627:ecma_builtin_array_prototype_object_at (const ecma_value_t index, /**< index argument */
        -: 1628:                                        ecma_object_t *obj_p, /**< object */
        -: 1629:                                        ecma_length_t len) /**< object's length */
        -: 1630:{
    #####: 1631:  ecma_length_t res_index;
    #####: 1632:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -: 1633:
    #####: 1634:  if (return_value != ECMA_VALUE_EMPTY)
        -: 1635:  {
    #####: 1636:    return return_value;
        -: 1637:  }
        -: 1638:
    #####: 1639:  return ecma_op_object_get_by_index (obj_p, res_index);
        -: 1640:} /* ecma_builtin_array_prototype_object_at */
        -: 1641:
        -: 1642:/**
        -: 1643: * The Array.prototype object's 'indexOf' routine
        -: 1644: *
        -: 1645: * See also:
        -: 1646: *          ECMA-262 v5, 15.4.4.14
        -: 1647: *
        -: 1648: * @return ecma value
        -: 1649: *         Returned value must be freed with ecma_free_value.
        -: 1650: */
        -: 1651:static ecma_value_t
    #####: 1652:ecma_builtin_array_prototype_object_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1653:                                              uint32_t args_number, /**< number of arguments */
        -: 1654:                                              ecma_object_t *obj_p, /**< object */
        -: 1655:                                              ecma_length_t len) /**< object's length */
        -: 1656:{
        -: 1657:  /* 4. */
    #####: 1658:  if (len == 0)
        -: 1659:  {
    #####: 1660:    return ecma_make_integer_value (-1);
        -: 1661:  }
        -: 1662:
        -: 1663:  /* 5. */
    #####: 1664:  ecma_number_t idx = 0;
    #####: 1665:  if (args_number > 1)
        -: 1666:  {
    #####: 1667:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1668:    {
    #####: 1669:      return ECMA_VALUE_ERROR;
        -: 1670:    }
        -: 1671:  }
        -: 1672:
        -: 1673:  /* 6. */
    #####: 1674:  if (idx >= (ecma_number_t) len)
        -: 1675:  {
    #####: 1676:    return ecma_make_number_value (-1);
        -: 1677:  }
        -: 1678:
        -: 1679:  /* 7. */
    #####: 1680:  ecma_length_t from_idx = (ecma_length_t) idx;
        -: 1681:
        -: 1682:  /* 8. */
    #####: 1683:  if (idx < 0)
        -: 1684:  {
    #####: 1685:    from_idx = (ecma_length_t) JERRY_MAX ((ecma_number_t) len + idx, 0);
        -: 1686:  }
        -: 1687:
    #####: 1688:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1689:  {
    #####: 1690:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1691:
    #####: 1692:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 1693:    {
    #####: 1694:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 1695:      {
    #####: 1696:        return ecma_make_integer_value (-1);
        -: 1697:      }
        -: 1698:
    #####: 1699:      len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 1700:
    #####: 1701:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1702:
    #####: 1703:      while (from_idx < len)
        -: 1704:      {
    #####: 1705:        if (ecma_op_strict_equality_compare (args[0], buffer_p[from_idx]))
        -: 1706:        {
    #####: 1707:          return ecma_make_uint32_value ((uint32_t) from_idx);
        -: 1708:        }
        -: 1709:
    #####: 1710:        from_idx++;
        -: 1711:      }
        -: 1712:
    #####: 1713:      return ecma_make_integer_value (-1);
        -: 1714:    }
        -: 1715:  }
        -: 1716:
        -: 1717:  /* 6. */
    #####: 1718:  while (from_idx < len)
        -: 1719:  {
        -: 1720:    /* 9.a */
    #####: 1721:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, from_idx);
        -: 1722:
    #####: 1723:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1724:    {
    #####: 1725:      return get_value;
        -: 1726:    }
        -: 1727:
        -: 1728:    /* 9.b.i, 9.b.ii */
    #####: 1729:    if (ecma_is_value_found (get_value)
    #####: 1730:        && ecma_op_strict_equality_compare (args[0], get_value))
        -: 1731:    {
    #####: 1732:      ecma_free_value (get_value);
    #####: 1733:      return ecma_make_length_value (from_idx);
        -: 1734:    }
        -: 1735:
    #####: 1736:    from_idx++;
        -: 1737:
    #####: 1738:    ecma_free_value (get_value);
        -: 1739:  }
        -: 1740:
    #####: 1741:  return ecma_make_integer_value (-1);
        -: 1742:} /* ecma_builtin_array_prototype_object_index_of */
        -: 1743:
        -: 1744:/**
        -: 1745: * The Array.prototype object's 'lastIndexOf' routine
        -: 1746: *
        -: 1747: * See also:
        -: 1748: *          ECMA-262 v5, 15.4.4.15
        -: 1749: *
        -: 1750: * @return ecma value
        -: 1751: *         Returned value must be freed with ecma_free_value.
        -: 1752: */
        -: 1753:static ecma_value_t
    #####: 1754:ecma_builtin_array_prototype_object_last_index_of (const ecma_value_t args[], /**< arguments list */
        -: 1755:                                                   uint32_t args_number, /**< number of arguments */
        -: 1756:                                                   ecma_object_t *obj_p, /**< object */
        -: 1757:                                                   ecma_length_t len) /**< object's length */
        -: 1758:{
        -: 1759:  /* 4. */
    #####: 1760:  if (len == 0)
        -: 1761:  {
    #####: 1762:    return ecma_make_integer_value (-1);
        -: 1763:  }
        -: 1764:
        -: 1765:  /* 5. */
    #####: 1766:  ecma_number_t idx = (ecma_number_t) len - 1;
    #####: 1767:  if (args_number > 1)
        -: 1768:  {
    #####: 1769:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &idx)))
        -: 1770:    {
    #####: 1771:      return ECMA_VALUE_ERROR;
        -: 1772:    }
        -: 1773:  }
        -: 1774:
        -: 1775:  ecma_length_t from_idx;
        -: 1776:
        -: 1777:  /* 6 */
    #####: 1778:  if (idx >= 0)
        -: 1779:  {
    #####: 1780:    from_idx = (ecma_length_t) (JERRY_MIN (idx, (ecma_number_t) (len - 1)));
        -: 1781:  }
        -: 1782:  else
        -: 1783:  {
    #####: 1784:    ecma_number_t k = (ecma_number_t) len + idx;
    #####: 1785:    if (k < 0)
        -: 1786:    {
    #####: 1787:      return ecma_make_integer_value (-1);
        -: 1788:    }
    #####: 1789:    from_idx = (ecma_length_t) k;
        -: 1790:  }
        -: 1791:
    #####: 1792:  ecma_value_t search_element = (args_number > 0) ? args[0] : ECMA_VALUE_UNDEFINED;
        -: 1793:
    #####: 1794:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1795:  {
    #####: 1796:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1797:
    #####: 1798:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 1799:    {
    #####: 1800:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 1801:      {
    #####: 1802:        return ecma_make_integer_value (-1);
        -: 1803:      }
        -: 1804:
    #####: 1805:      len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 1806:
    #####: 1807:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 1808:
    #####: 1809:      while (from_idx < len)
        -: 1810:      {
    #####: 1811:        if (ecma_op_strict_equality_compare (search_element, buffer_p[from_idx]))
        -: 1812:        {
    #####: 1813:          return ecma_make_uint32_value ((uint32_t) from_idx);
        -: 1814:        }
    #####: 1815:        from_idx--;
        -: 1816:      }
    #####: 1817:      return ecma_make_integer_value (-1);
        -: 1818:    }
        -: 1819:  }
        -: 1820:
        -: 1821:    /* 8. */
    #####: 1822:  while (from_idx < len)
        -: 1823:  {
        -: 1824:    /* 8.a */
    #####: 1825:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, from_idx);
        -: 1826:
    #####: 1827:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1828:    {
    #####: 1829:      return get_value;
        -: 1830:    }
        -: 1831:
        -: 1832:    /* 8.b.i, 8.b.ii */
    #####: 1833:    if (ecma_is_value_found (get_value)
    #####: 1834:        && ecma_op_strict_equality_compare (search_element, get_value))
        -: 1835:    {
    #####: 1836:      ecma_free_value (get_value);
    #####: 1837:      return ecma_make_length_value (from_idx);
        -: 1838:    }
        -: 1839:
    #####: 1840:    from_idx--;
        -: 1841:
    #####: 1842:    ecma_free_value (get_value);
        -: 1843:  }
        -: 1844:
    #####: 1845:  return ecma_make_integer_value (-1);
        -: 1846:} /* ecma_builtin_array_prototype_object_last_index_of */
        -: 1847:
        -: 1848:/**
        -: 1849: * Type of array routine.
        -: 1850: */
        -: 1851:typedef enum
        -: 1852:{
        -: 1853:  ARRAY_ROUTINE_EVERY, /**< Array.every: ECMA-262 v5, 15.4.4.16 */
        -: 1854:  ARRAY_ROUTINE_SOME, /**< Array.some: ECMA-262 v5, 15.4.4.17 */
        -: 1855:  ARRAY_ROUTINE_FOREACH, /**< Array.forEach: ECMA-262 v5, 15.4.4.18 */
        -: 1856:  ARRAY_ROUTINE__COUNT /**< count of the modes */
        -: 1857:} array_routine_mode;
        -: 1858:
        -: 1859:/**
        -: 1860: * Applies the provided function to each element of the array as long as
        -: 1861: * the return value stays empty. The common function for 'every', 'some'
        -: 1862: * and 'forEach' of the Array prototype.
        -: 1863: *
        -: 1864: * See also:
        -: 1865: *          ECMA-262 v5, 15.4.4.16
        -: 1866: *          ECMA-262 v5, 15.4.4.17
        -: 1867: *          ECMA-262 v5, 15.4.4.18
        -: 1868: *
        -: 1869: * @return ecma value
        -: 1870: *         Returned value must be freed with ecma_free_value.
        -: 1871: */
        -: 1872:static ecma_value_t
    #####: 1873:ecma_builtin_array_apply (ecma_value_t arg1, /**< callbackfn */
        -: 1874:                          ecma_value_t arg2, /**< thisArg */
        -: 1875:                          array_routine_mode mode, /**< array routine mode */
        -: 1876:                          ecma_object_t *obj_p, /**< object */
        -: 1877:                          ecma_length_t len) /**< object's length */
        -: 1878:
        -: 1879:{
    #####: 1880:  JERRY_ASSERT (mode < ARRAY_ROUTINE__COUNT);
        -: 1881:
        -: 1882:  /* 4. */
    #####: 1883:  if (!ecma_op_is_callable (arg1))
        -: 1884:  {
    #####: 1885:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1886:  }
        -: 1887:
        -: 1888:  /* We already checked that arg1 is callable */
    #####: 1889:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1890:  ecma_value_t current_index;
        -: 1891:
        -: 1892:  /* 7. */
    #####: 1893:  for (ecma_length_t index = 0; index < len; index++)
        -: 1894:  {
        -: 1895:    /* 7.a - 7.c */
    #####: 1896:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, index);
        -: 1897:
    #####: 1898:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 1899:    {
    #####: 1900:      return get_value;
        -: 1901:    }
        -: 1902:
    #####: 1903:    if (ecma_is_value_found (get_value))
        -: 1904:    {
        -: 1905:      /* 7.c.i */
    #####: 1906:      current_index = ecma_make_length_value (index);
        -: 1907:
    #####: 1908:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 1909:      /* 7.c.ii */
    #####: 1910:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 1911:
    #####: 1912:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1913:      {
    #####: 1914:        ecma_free_value (get_value);
    #####: 1915:        return call_value;
        -: 1916:      }
        -: 1917:
    #####: 1918:      bool to_boolean = ecma_op_to_boolean (call_value);
        -: 1919:
    #####: 1920:      ecma_free_value (call_value);
    #####: 1921:      ecma_free_value (get_value);
        -: 1922:
        -: 1923:      /* 7.c.iii */
    #####: 1924:      if (mode == ARRAY_ROUTINE_EVERY && !to_boolean)
        -: 1925:      {
    #####: 1926:        return ECMA_VALUE_FALSE;
        -: 1927:      }
    #####: 1928:      else if (mode == ARRAY_ROUTINE_SOME && to_boolean)
        -: 1929:      {
    #####: 1930:        return ECMA_VALUE_TRUE;
        -: 1931:      }
        -: 1932:    }
        -: 1933:  }
        -: 1934:
        -: 1935:  /* 8. */
        -: 1936:
    #####: 1937:  if (mode == ARRAY_ROUTINE_EVERY)
        -: 1938:  {
    #####: 1939:    return ECMA_VALUE_TRUE;
        -: 1940:  }
    #####: 1941:  else if (mode == ARRAY_ROUTINE_SOME)
        -: 1942:  {
    #####: 1943:    return ECMA_VALUE_FALSE;
        -: 1944:  }
        -: 1945:
    #####: 1946:  JERRY_ASSERT (mode == ARRAY_ROUTINE_FOREACH);
    #####: 1947:  return ECMA_VALUE_UNDEFINED;
        -: 1948:} /* ecma_builtin_array_apply */
        -: 1949:
        -: 1950:/**
        -: 1951: * The Array.prototype object's 'map' routine
        -: 1952: *
        -: 1953: * See also:
        -: 1954: *          ECMA-262 v5, 15.4.4.19
        -: 1955: *
        -: 1956: * @return ecma value
        -: 1957: *         Returned value must be freed with ecma_free_value.
        -: 1958: */
        -: 1959:static ecma_value_t
    #####: 1960:ecma_builtin_array_prototype_object_map (ecma_value_t arg1, /**< callbackfn */
        -: 1961:                                         ecma_value_t arg2, /**< thisArg */
        -: 1962:                                         ecma_object_t *obj_p, /**< object */
        -: 1963:                                         ecma_length_t len) /**< object's length */
        -: 1964:{
        -: 1965:  /* 4. */
    #####: 1966:  if (!ecma_op_is_callable (arg1))
        -: 1967:  {
    #####: 1968:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 1969:  }
        -: 1970:
        -: 1971:  /* 6. */
        -: 1972:#if JERRY_ESNEXT
    #####: 1973:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, len);
        -: 1974:
    #####: 1975:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 1976:  {
    #####: 1977:    return ECMA_VALUE_ERROR;
        -: 1978:  }
        -: 1979:#else /* !JERRY_ESNEXT */
    #####: 1980:  ecma_object_t *new_array_p = ecma_op_new_array_object (len);
        -: 1981:#endif /* JERRY_ESNEXT */
        -: 1982:
    #####: 1983:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 1984:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 1985:
        -: 1986:  /* 7-8. */
        -: 1987:  ecma_value_t current_index;
        -: 1988:
    #####: 1989:  for (ecma_length_t index = 0; index < len; index++)
        -: 1990:  {
        -: 1991:    /* 8.a - 8.b */
    #####: 1992:    ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, index);
        -: 1993:
    #####: 1994:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 1995:    {
    #####: 1996:      ecma_deref_object (new_array_p);
    #####: 1997:      return current_value;
        -: 1998:    }
        -: 1999:
    #####: 2000:    if (ecma_is_value_found (current_value))
        -: 2001:    {
        -: 2002:      /* 8.c.i, 8.c.ii */
    #####: 2003:      current_index = ecma_make_length_value (index);
    #####: 2004:      ecma_value_t call_args[] = { current_value, current_index, ecma_make_object_value (obj_p) };
        -: 2005:
    #####: 2006:      ecma_value_t mapped_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 2007:
    #####: 2008:      if (ECMA_IS_VALUE_ERROR (mapped_value))
        -: 2009:      {
    #####: 2010:        ecma_free_value (current_value);
    #####: 2011:        ecma_deref_object (new_array_p);
    #####: 2012:        return mapped_value;
        -: 2013:      }
        -: 2014:
        -: 2015:      /* 8.c.iii */
        -: 2016:      ecma_value_t put_comp;
        -: 2017:#if JERRY_ESNEXT
    #####: 2018:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 2019:#else /* !JERRY_ESNEXT */
    #####: 2020:      const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 2021:#endif /* JERRY_ESNEXT */
    #####: 2022:      put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 2023:                                                        index,
        -: 2024:                                                        mapped_value,
        -: 2025:                                                        prop_flags);
        -: 2026:
    #####: 2027:      ecma_free_value (mapped_value);
    #####: 2028:      ecma_free_value (current_value);
        -: 2029:#if JERRY_ESNEXT
    #####: 2030:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2031:      {
    #####: 2032:        ecma_deref_object (new_array_p);
    #####: 2033:        return put_comp;
        -: 2034:      }
        -: 2035:#else /* !JERRY_ESNEXT */
        -: 2036:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2037:#endif /* JERRY_ESNEXT */
        -: 2038:    }
        -: 2039:  }
        -: 2040:
    #####: 2041:  return ecma_make_object_value (new_array_p);
        -: 2042:} /* ecma_builtin_array_prototype_object_map */
        -: 2043:
        -: 2044:/**
        -: 2045: * The Array.prototype object's 'filter' routine
        -: 2046: *
        -: 2047: * See also:
        -: 2048: *          ECMA-262 v5, 15.4.4.20
        -: 2049: *
        -: 2050: * @return ecma value
        -: 2051: *         Returned value must be freed with ecma_free_value.
        -: 2052: */
        -: 2053:static ecma_value_t
    #####: 2054:ecma_builtin_array_prototype_object_filter (ecma_value_t arg1, /**< callbackfn */
        -: 2055:                                            ecma_value_t arg2, /**< thisArg */
        -: 2056:                                            ecma_object_t *obj_p, /**< object */
        -: 2057:                                            ecma_length_t len) /**< object's length */
        -: 2058:{
        -: 2059:  /* 4. */
    #####: 2060:  if (!ecma_op_is_callable (arg1))
        -: 2061:  {
    #####: 2062:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2063:  }
        -: 2064:
        -: 2065:  /* 6. */
        -: 2066:#if JERRY_ESNEXT
    #####: 2067:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2068:
    #####: 2069:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2070:  {
    #####: 2071:    return ECMA_VALUE_ERROR;
        -: 2072:  }
        -: 2073:
        -: 2074:  /* ES11: 22.1.3.7. 7.c.iii.1 */
    #####: 2075:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -: 2076:#else /* !JERRY_ESNEXT */
    #####: 2077:  ecma_object_t *new_array_p = ecma_op_new_array_object (0);
        -: 2078:
        -: 2079:  /* ES5.1: 15.4.4.20. 9.c.iii.1 */
    #####: 2080:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
        -: 2081:#endif /* JERRY_ESNEXT */
        -: 2082:
        -: 2083:  /* We already checked that arg1 is callable, so it will always be an object. */
    #####: 2084:  JERRY_ASSERT (ecma_is_value_object (arg1));
    #####: 2085:  ecma_object_t *func_object_p = ecma_get_object_from_value (arg1);
        -: 2086:
        -: 2087:  /* 8. */
    #####: 2088:  ecma_length_t new_array_index = 0;
        -: 2089:  ecma_value_t current_index;
        -: 2090:
        -: 2091:  /* 9. */
    #####: 2092:  for (ecma_length_t index = 0; index < len; index++)
        -: 2093:  {
        -: 2094:    /* 9.a - 9.c */
    #####: 2095:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, index);
        -: 2096:
    #####: 2097:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2098:    {
    #####: 2099:      ecma_deref_object (new_array_p);
    #####: 2100:      return get_value;
        -: 2101:    }
        -: 2102:
    #####: 2103:    if (ecma_is_value_found (get_value))
        -: 2104:    {
        -: 2105:      /* 9.c.i */
    #####: 2106:      current_index = ecma_make_length_value (index);
        -: 2107:
    #####: 2108:      ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2109:      /* 9.c.ii */
    #####: 2110:      ecma_value_t call_value = ecma_op_function_call (func_object_p, arg2, call_args, 3);
        -: 2111:
    #####: 2112:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2113:      {
    #####: 2114:        ecma_free_value (get_value);
    #####: 2115:        ecma_deref_object (new_array_p);
    #####: 2116:        return call_value;
        -: 2117:      }
        -: 2118:
        -: 2119:      /* 9.c.iii */
    #####: 2120:      if (ecma_op_to_boolean (call_value))
        -: 2121:      {
        -: 2122:        ecma_value_t put_comp;
    #####: 2123:        put_comp = ecma_builtin_helper_def_prop_by_index (new_array_p,
        -: 2124:                                                          new_array_index,
        -: 2125:                                                          get_value,
        -: 2126:                                                          prop_flags);
        -: 2127:#if JERRY_ESNEXT
    #####: 2128:        if (ECMA_IS_VALUE_ERROR (put_comp))
        -: 2129:        {
    #####: 2130:          ecma_free_value (call_value);
    #####: 2131:          ecma_free_value (get_value);
    #####: 2132:          ecma_deref_object (new_array_p);
        -: 2133:
    #####: 2134:          return put_comp;
        -: 2135:        }
        -: 2136:#else /* !JERRY_ESNEXT */
        -: 2137:        JERRY_ASSERT (ecma_is_value_true (put_comp));
        -: 2138:#endif /* JERRY_ESNEXT */
    #####: 2139:        new_array_index++;
        -: 2140:      }
        -: 2141:
    #####: 2142:      ecma_free_value (call_value);
    #####: 2143:      ecma_free_value (get_value);
        -: 2144:    }
        -: 2145:  }
        -: 2146:
    #####: 2147:  return ecma_make_object_value (new_array_p);
        -: 2148:} /* ecma_builtin_array_prototype_object_filter */
        -: 2149:
        -: 2150:/**
        -: 2151: * The Array.prototype object's 'reduce' and 'reduceRight' routine
        -: 2152: *
        -: 2153: * See also:
        -: 2154: *         ECMA-262 v5, 15.4.4.21
        -: 2155: *         ECMA-262 v5, 15.4.4.22
        -: 2156: *
        -: 2157: * @return ecma value
        -: 2158: *         Returned value must be freed with ecma_free_value.
        -: 2159: */
        -: 2160:static ecma_value_t
    #####: 2161:ecma_builtin_array_reduce_from (const ecma_value_t args_p[], /**< routine's arguments */
        -: 2162:                                uint32_t args_number, /**< arguments list length */
        -: 2163:                                bool start_from_left, /**< whether the reduce starts from left or right */
        -: 2164:                                ecma_object_t *obj_p, /**< object */
        -: 2165:                                ecma_length_t len) /**< object's length */
        -: 2166:{
        -: 2167:  /* 4. */
    #####: 2168:  if (!ecma_op_is_callable (args_p[0]))
        -: 2169:  {
    #####: 2170:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2171:  }
        -: 2172:
        -: 2173:  /* 5. */
    #####: 2174:  if (len == 0 && args_number == 1)
        -: 2175:  {
    #####: 2176:    return ecma_raise_type_error (ECMA_ERR_MSG ("Reduce of empty Array with no initial value"));
        -: 2177:  }
        -: 2178:
    #####: 2179:  JERRY_ASSERT (ecma_is_value_object (args_p[0]));
    #####: 2180:  ecma_object_t *func_object_p = ecma_get_object_from_value (args_p[0]);
        -: 2181:
    #####: 2182:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
        -: 2183:
        -: 2184:  /* 6. */
    #####: 2185:  ecma_length_t index = 0;
    #####: 2186:  const ecma_length_t last_index = len - 1;
        -: 2187:
        -: 2188:  /* 7.a */
    #####: 2189:  if (args_number > 1)
        -: 2190:  {
    #####: 2191:    accumulator = ecma_copy_value (args_p[1]);
        -: 2192:  }
        -: 2193:  else
        -: 2194:  {
        -: 2195:    /* 8.a */
    #####: 2196:    bool k_present = false;
        -: 2197:
        -: 2198:    /* 8.b */
    #####: 2199:    while (!k_present && index < len)
        -: 2200:    {
        -: 2201:      /* 8.b.i */
    #####: 2202:      k_present = true;
        -: 2203:
        -: 2204:      /* 8.b.ii-iii */
    #####: 2205:      ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, start_from_left ? index
        -: 2206:                                                                                                  : last_index - index);
        -: 2207:
    #####: 2208:      if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2209:      {
    #####: 2210:        return current_value;
        -: 2211:      }
        -: 2212:
    #####: 2213:      if (ecma_is_value_found (current_value))
        -: 2214:      {
    #####: 2215:        accumulator = current_value;
        -: 2216:      }
        -: 2217:      else
        -: 2218:      {
    #####: 2219:        k_present = false;
        -: 2220:      }
        -: 2221:
        -: 2222:      /* 8.b.iv */
    #####: 2223:      index++;
        -: 2224:    }
        -: 2225:
        -: 2226:    /* 8.c */
    #####: 2227:    if (!k_present)
        -: 2228:    {
    #####: 2229:      return ecma_raise_type_error (ECMA_ERR_MSG ("Missing Array element"));
        -: 2230:    }
        -: 2231:  }
        -: 2232:  /* 9. */
        -: 2233:  ecma_value_t current_index;
        -: 2234:
    #####: 2235:  for (; index < len; index++)
        -: 2236:  {
    #####: 2237:    const ecma_length_t corrected_index = start_from_left ? index : last_index - index;
        -: 2238:
        -: 2239:    /* 9.a - 9.b */
    #####: 2240:    ecma_value_t current_value = ecma_op_object_find_by_index (obj_p, corrected_index);
        -: 2241:
    #####: 2242:    if (ECMA_IS_VALUE_ERROR (current_value))
        -: 2243:    {
    #####: 2244:      ecma_free_value (accumulator);
    #####: 2245:      return current_value;
        -: 2246:    }
        -: 2247:
    #####: 2248:    if (ecma_is_value_found (current_value))
        -: 2249:    {
        -: 2250:      /* 9.c.i, 9.c.ii */
    #####: 2251:      current_index = ecma_make_length_value (corrected_index);
    #####: 2252:      ecma_value_t call_args[] = {accumulator, current_value, current_index, ecma_make_object_value (obj_p)};
        -: 2253:
    #####: 2254:      ecma_value_t call_value = ecma_op_function_call (func_object_p,
        -: 2255:                                                       ECMA_VALUE_UNDEFINED,
        -: 2256:                                                       call_args,
        -: 2257:                                                       4);
    #####: 2258:      ecma_free_value (current_index);
    #####: 2259:      ecma_free_value (accumulator);
    #####: 2260:      ecma_free_value (current_value);
        -: 2261:
    #####: 2262:      if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2263:      {
    #####: 2264:        return call_value;
        -: 2265:      }
        -: 2266:
    #####: 2267:      accumulator = call_value;
        -: 2268:    }
        -: 2269:  }
        -: 2270:
    #####: 2271:  return accumulator;
        -: 2272:} /* ecma_builtin_array_reduce_from */
        -: 2273:
        -: 2274:#if JERRY_ESNEXT
        -: 2275:
        -: 2276:/**
        -: 2277: * The Array.prototype object's 'fill' routine
        -: 2278: *
        -: 2279: * Note: this method only supports length up to uint32, instead of max_safe_integer
        -: 2280: *
        -: 2281: * See also:
        -: 2282: *          ECMA-262 v6, 22.1.3.6
        -: 2283: *
        -: 2284: * @return ecma value
        -: 2285: *         Returned value must be freed with ecma_free_value.
        -: 2286: */
        -: 2287:static ecma_value_t
    #####: 2288:ecma_builtin_array_prototype_fill (ecma_value_t value, /**< value */
        -: 2289:                                   ecma_value_t start_val, /**< start value */
        -: 2290:                                   ecma_value_t end_val, /**< end value */
        -: 2291:                                   ecma_object_t *obj_p, /**< object */
        -: 2292:                                   ecma_length_t len) /**< object's length */
        -: 2293:{
    #####: 2294:  ecma_length_t k, final;
        -: 2295:
        -: 2296:  /* 5. 6. 7. */
    #####: 2297:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (start_val,
        -: 2298:                                                                      len,
        -: 2299:                                                                      &k)))
        -: 2300:  {
    #####: 2301:    return ECMA_VALUE_ERROR;
        -: 2302:  }
        -: 2303:
        -: 2304:  /* 8. */
    #####: 2305:  if (ecma_is_value_undefined (end_val))
        -: 2306:  {
    #####: 2307:    final = len;
        -: 2308:  }
        -: 2309:  else
        -: 2310:  {
        -: 2311:    /* 8 part 2, 9, 10 */
    #####: 2312:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (end_val,
        -: 2313:                                                                        len,
        -: 2314:                                                                        &final)))
        -: 2315:    {
    #####: 2316:      return ECMA_VALUE_ERROR;
        -: 2317:    }
        -: 2318:  }
        -: 2319:
    #####: 2320:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2321:  {
    #####: 2322:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2323:
    #####: 2324:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2325:    {
    #####: 2326:      if (JERRY_UNLIKELY (obj_p->u1.property_list_cp == JMEM_CP_NULL))
        -: 2327:      {
    #####: 2328:        ecma_ref_object (obj_p);
    #####: 2329:        return ecma_make_object_value (obj_p);
        -: 2330:      }
        -: 2331:
    #####: 2332:      ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2333:
    #####: 2334:      while (k < final)
        -: 2335:      {
    #####: 2336:        ecma_free_value_if_not_object (buffer_p[k]);
    #####: 2337:        buffer_p[k] = ecma_copy_value_if_not_object (value);
    #####: 2338:        k++;
        -: 2339:      }
        -: 2340:
    #####: 2341:      ecma_ref_object (obj_p);
    #####: 2342:      return ecma_make_object_value (obj_p);
        -: 2343:    }
        -: 2344:  }
        -: 2345:
        -: 2346:  /* 11. */
    #####: 2347:  while (k < final)
        -: 2348:  {
        -: 2349:    /* 11.a - 11.b */
    #####: 2350:    ecma_value_t put_val = ecma_op_object_put_by_index (obj_p, k, value, true);
        -: 2351:
        -: 2352:    /* 11. c */
    #####: 2353:    if (ECMA_IS_VALUE_ERROR (put_val))
        -: 2354:    {
    #####: 2355:      return put_val;
        -: 2356:    }
        -: 2357:
        -: 2358:    /* 11.d */
    #####: 2359:    k++;
        -: 2360:  }
        -: 2361:
    #####: 2362:  ecma_ref_object (obj_p);
    #####: 2363:  return ecma_make_object_value (obj_p);
        -: 2364:} /* ecma_builtin_array_prototype_fill */
        -: 2365:
        -: 2366:/**
        -: 2367: * The Array.prototype object's 'find' and 'findIndex' routine
        -: 2368: *
        -: 2369: * See also:
        -: 2370: *          ECMA-262 v6, 22.1.3.8
        -: 2371: *          ECMA-262 v6, 22.1.3.9
        -: 2372: *
        -: 2373: * @return ecma value
        -: 2374: *         Returned value must be freed with ecma_free_value.
        -: 2375: */
        -: 2376:static ecma_value_t
    #####: 2377:ecma_builtin_array_prototype_object_find (ecma_value_t predicate, /**< callback function */
        -: 2378:                                          ecma_value_t predicate_this_arg, /**< this argument for
        -: 2379:                                                                            *   invoke predicate */
        -: 2380:                                          bool is_find, /**< true - find routine
        -: 2381:                                                         *   false - findIndex routine */
        -: 2382:                                          ecma_object_t *obj_p, /**< object */
        -: 2383:                                          ecma_length_t len) /**< object's length */
        -: 2384:{
        -: 2385:  /* 5. */
    #####: 2386:  if (!ecma_op_is_callable (predicate))
        -: 2387:  {
    #####: 2388:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2389:  }
        -: 2390:
        -: 2391:  /* We already checked that predicate is callable, so it will always be an object. */
    #####: 2392:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 2393:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
        -: 2394:
        -: 2395:  /* 7 - 8. */
    #####: 2396:  for (ecma_length_t index = 0; index < len; index++)
        -: 2397:  {
        -: 2398:    /* 8.a - 8.c */
    #####: 2399:    ecma_value_t get_value = ecma_op_object_get_by_index (obj_p, index);
        -: 2400:
    #####: 2401:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2402:    {
    #####: 2403:      return get_value;
        -: 2404:    }
        -: 2405:
        -: 2406:    /* 8.d - 8.e */
    #####: 2407:    ecma_value_t current_index = ecma_make_length_value (index);
        -: 2408:
    #####: 2409:    ecma_value_t call_args[] = { get_value, current_index, ecma_make_object_value (obj_p) };
        -: 2410:
    #####: 2411:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 2412:
    #####: 2413:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 2414:    {
    #####: 2415:      ecma_free_value (get_value);
    #####: 2416:      return call_value;
        -: 2417:    }
        -: 2418:
    #####: 2419:    bool call_value_to_bool = ecma_op_to_boolean (call_value);
        -: 2420:
    #####: 2421:    ecma_free_value (call_value);
        -: 2422:
    #####: 2423:    if (call_value_to_bool)
        -: 2424:    {
        -: 2425:      /* 8.f */
    #####: 2426:      if (is_find)
        -: 2427:      {
    #####: 2428:        ecma_free_value (current_index);
    #####: 2429:        return get_value;
        -: 2430:      }
        -: 2431:
    #####: 2432:      ecma_free_value (get_value);
    #####: 2433:      return current_index;
        -: 2434:    }
        -: 2435:
    #####: 2436:    ecma_free_value (get_value);
    #####: 2437:    ecma_free_value (current_index);
        -: 2438:  }
        -: 2439:
        -: 2440:  /* 9. */
    #####: 2441:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 2442:} /* ecma_builtin_array_prototype_object_find */
        -: 2443:
        -: 2444:/**
        -: 2445: * The Array.prototype object's 'copyWithin' routine
        -: 2446: *
        -: 2447: * See also:
        -: 2448: *          ECMA-262 v6, 22.1.3.3
        -: 2449: *
        -: 2450: * @return ecma value
        -: 2451: *         Returned value must be freed with ecma_free_value.
        -: 2452: */
        -: 2453:static ecma_value_t
    #####: 2454:ecma_builtin_array_prototype_object_copy_within (const ecma_value_t args[], /**< arguments list */
        -: 2455:                                                 uint32_t args_number, /**< number of arguments */
        -: 2456:                                                 ecma_object_t *obj_p, /**< object */
        -: 2457:                                                 ecma_length_t len) /**< object's length */
        -: 2458:{
    #####: 2459:  if (args_number == 0)
        -: 2460:  {
    #####: 2461:    return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2462:  }
        -: 2463:
        -: 2464:  /* 5 - 7 */
    #####: 2465:  ecma_length_t target;
        -: 2466:
    #####: 2467:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[0], len, &target)))
        -: 2468:  {
    #####: 2469:    return ECMA_VALUE_ERROR;
        -: 2470:  }
        -: 2471:
    #####: 2472:  ecma_length_t start = 0;
    #####: 2473:  ecma_length_t end = len;
        -: 2474:
    #####: 2475:  if (args_number > 1)
        -: 2476:  {
        -: 2477:    /* 8 - 10 */
    #####: 2478:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &start)))
        -: 2479:    {
    #####: 2480:      return ECMA_VALUE_ERROR;
        -: 2481:    }
        -: 2482:
    #####: 2483:    if (args_number > 2)
        -: 2484:    {
        -: 2485:      /* 11 */
    #####: 2486:      if (ecma_is_value_undefined (args[2]))
        -: 2487:      {
    #####: 2488:        end = len;
        -: 2489:      }
        -: 2490:      else
        -: 2491:      {
        -: 2492:        /* 11 part 2, 12, 13 */
    #####: 2493:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[2], len, &end)))
        -: 2494:        {
    #####: 2495:          return ECMA_VALUE_ERROR;
        -: 2496:        }
        -: 2497:      }
        -: 2498:    }
        -: 2499:  }
        -: 2500:
    #####: 2501:  ecma_length_t count = JERRY_MIN (end - start, len - target);
    #####: 2502:  if (end <= start || len <= target) /* count <= 0 check, but variables are unsigned */
        -: 2503:  {
    #####: 2504:    ecma_ref_object (obj_p);
    #####: 2505:    return ecma_make_object_value (obj_p);
        -: 2506:  }
        -: 2507:
    #####: 2508:  bool forward = true;
        -: 2509:
    #####: 2510:  if (start < target && target < start + count)
        -: 2511:  {
    #####: 2512:    start = start + count - 1;
    #####: 2513:    target = target + count - 1;
    #####: 2514:    forward = false;
        -: 2515:  }
        -: 2516:
    #####: 2517:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2518:  {
    #####: 2519:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####: 2520:    const uint32_t actual_length = ext_obj_p->u.array.length;
        -: 2521:
    #####: 2522:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE
    #####: 2523:        && ((forward && (target + count - 1 < actual_length)) || (!forward && (target < actual_length))))
        -: 2524:    {
    #####: 2525:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2526:      {
    #####: 2527:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2528:
    #####: 2529:        for (; count > 0; count--)
        -: 2530:        {
    #####: 2531:          ecma_value_t copy_value = ecma_copy_value_if_not_object (buffer_p[start]);
        -: 2532:
    #####: 2533:          ecma_free_value_if_not_object (buffer_p[target]);
        -: 2534:
    #####: 2535:          buffer_p[target] = copy_value;
        -: 2536:
    #####: 2537:          if (forward)
        -: 2538:          {
    #####: 2539:            start++;
    #####: 2540:            target++;
        -: 2541:          }
        -: 2542:          else
        -: 2543:          {
    #####: 2544:            start--;
    #####: 2545:            target--;
        -: 2546:          }
        -: 2547:        }
        -: 2548:      }
        -: 2549:
    #####: 2550:      ecma_ref_object (obj_p);
    #####: 2551:      return ecma_make_object_value (obj_p);
        -: 2552:    }
        -: 2553:  }
        -: 2554:
    #####: 2555:  while (count > 0)
        -: 2556:  {
    #####: 2557:    ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, start);
        -: 2558:
    #####: 2559:    if (ECMA_IS_VALUE_ERROR (get_value))
        -: 2560:    {
    #####: 2561:      return get_value;
        -: 2562:    }
        -: 2563:
        -: 2564:    ecma_value_t op_value;
        -: 2565:
    #####: 2566:    if (ecma_is_value_found (get_value))
        -: 2567:    {
    #####: 2568:      op_value = ecma_op_object_put_by_index (obj_p, target, get_value, true);
        -: 2569:    }
        -: 2570:    else
        -: 2571:    {
    #####: 2572:      op_value = ecma_op_object_delete_by_index (obj_p, target, true);
        -: 2573:    }
        -: 2574:
    #####: 2575:    ecma_free_value (get_value);
        -: 2576:
    #####: 2577:    if (ECMA_IS_VALUE_ERROR (op_value))
        -: 2578:    {
    #####: 2579:      return op_value;
        -: 2580:    }
        -: 2581:
    #####: 2582:    ecma_free_value (op_value);
        -: 2583:
    #####: 2584:    if (forward)
        -: 2585:    {
    #####: 2586:      start++;
    #####: 2587:      target++;
        -: 2588:    }
        -: 2589:    else
        -: 2590:    {
    #####: 2591:      start--;
    #####: 2592:      target--;
        -: 2593:    }
        -: 2594:
    #####: 2595:    count--;
        -: 2596:  }
        -: 2597:
    #####: 2598:  return ecma_copy_value (ecma_make_object_value (obj_p));
        -: 2599:} /* ecma_builtin_array_prototype_object_copy_within */
        -: 2600:
        -: 2601:/**
        -: 2602: * The Array.prototype object's 'includes' routine
        -: 2603: *
        -: 2604: * See also:
        -: 2605: *          ECMA-262 v11, 22.1.3.13
        -: 2606: *
        -: 2607: * @return ECMA_VALUE_ERROR -if the operation fails
        -: 2608: *         ECMA_VALUE_{TRUE/FALSE} - depends on whether the search element is in the array or not
        -: 2609: */
        -: 2610:static ecma_value_t
    #####: 2611:ecma_builtin_array_prototype_includes (const ecma_value_t args[], /**< arguments list */
        -: 2612:                                       uint32_t args_number, /**< number of arguments */
        -: 2613:                                       ecma_object_t *obj_p, /**< object */
        -: 2614:                                       ecma_length_t len) /**< object's length */
        -: 2615:{
        -: 2616:  /* 3. */
    #####: 2617:  if (len == 0)
        -: 2618:  {
    #####: 2619:    return ECMA_VALUE_FALSE;
        -: 2620:  }
        -: 2621:
    #####: 2622:  ecma_length_t from_index = 0;
        -: 2623:
        -: 2624:  /* 4-7. */
    #####: 2625:  if (args_number > 1)
        -: 2626:  {
    #####: 2627:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_array_index_normalize (args[1], len, &from_index)))
        -: 2628:    {
    #####: 2629:      return ECMA_VALUE_ERROR;
        -: 2630:    }
        -: 2631:  }
        -: 2632:
        -: 2633:  /* Fast array path */
    #####: 2634:  if (ecma_op_object_is_fast_array (obj_p))
        -: 2635:  {
    #####: 2636:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 2637:
    #####: 2638:    if (ext_obj_p->u.array.length_prop_and_hole_count < ECMA_FAST_ARRAY_HOLE_ONE)
        -: 2639:    {
    #####: 2640:      if (obj_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2641:      {
    #####: 2642:        len = JERRY_MIN (ext_obj_p->u.array.length, len);
        -: 2643:
    #####: 2644:        ecma_value_t *buffer_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, obj_p->u1.property_list_cp);
        -: 2645:
    #####: 2646:        while (from_index < len)
        -: 2647:        {
    #####: 2648:          if (ecma_op_same_value_zero (buffer_p[from_index], args[0], false))
        -: 2649:          {
    #####: 2650:            return ECMA_VALUE_TRUE;
        -: 2651:          }
        -: 2652:
    #####: 2653:          from_index++;
        -: 2654:        }
        -: 2655:      }
        -: 2656:
    #####: 2657:      return ECMA_VALUE_FALSE;
        -: 2658:    }
        -: 2659:  }
        -: 2660:
        -: 2661:  /* 8. */
    #####: 2662:  while (from_index < len)
        -: 2663:  {
    #####: 2664:    ecma_value_t element = ecma_op_object_get_by_index (obj_p, from_index);
        -: 2665:
    #####: 2666:    if (ECMA_IS_VALUE_ERROR (element))
        -: 2667:    {
    #####: 2668:      return element;
        -: 2669:    }
        -: 2670:
    #####: 2671:    if (ecma_op_same_value_zero (element, args[0], false))
        -: 2672:    {
    #####: 2673:      ecma_free_value (element);
    #####: 2674:      return ECMA_VALUE_TRUE;
        -: 2675:    }
        -: 2676:
    #####: 2677:    ecma_free_value (element);
    #####: 2678:    from_index++;
        -: 2679:  }
        -: 2680:
        -: 2681:  /* 9. */
    #####: 2682:  return ECMA_VALUE_FALSE;
        -: 2683:} /* ecma_builtin_array_prototype_includes */
        -: 2684:
        -: 2685:/**
        -: 2686: * Abstract operation: FlattenIntoArray
        -: 2687: *
        -: 2688: * See also:
        -: 2689: *          ECMA-262 v10, 22.1.3.10.1
        -: 2690: *
        -: 2691: * @return  ECMA_VALUE_ERROR -if the operation fails
        -: 2692: *          ecma value which contains target_index
        -: 2693: */
        -: 2694:static ecma_value_t
    #####: 2695:ecma_builtin_array_flatten_into_array (ecma_value_t target, /**< target will contains source's elements  */
        -: 2696:                                       ecma_object_t *source, /**< source object */
        -: 2697:                                       ecma_length_t source_len, /**< source object length */
        -: 2698:                                       ecma_length_t start, /**< remaining recursion depth */
        -: 2699:                                       ecma_number_t depth, /**< start index offset */
        -: 2700:                                       ecma_value_t mapped_value, /**< mapped value  */
        -: 2701:                                       ecma_value_t thisArg) /**< this arg */
        -: 2702:{
        -: 2703:  /* 7. */
    #####: 2704:  ecma_length_t target_index = start;
        -: 2705:
        -: 2706:  /* 9. */
    #####: 2707:  for (ecma_length_t source_index = 0; source_index < source_len; source_index++)
        -: 2708:  {
        -: 2709:    /* a. */
    #####: 2710:    ecma_value_t element = ecma_op_object_find_by_index (source, source_index);
        -: 2711:
    #####: 2712:    if (ECMA_IS_VALUE_ERROR (element))
        -: 2713:    {
    #####: 2714:      return element;
        -: 2715:    }
        -: 2716:
    #####: 2717:    if (!ecma_is_value_found (element))
        -: 2718:    {
    #####: 2719:      continue;
        -: 2720:    }
        -: 2721:
        -: 2722:    /* b-c. */
    #####: 2723:    if (!ecma_is_value_undefined (mapped_value))
        -: 2724:    {
        -: 2725:      /* i-ii. */
    #####: 2726:      ecma_value_t source_val = ecma_make_length_value (source_index);
    #####: 2727:      ecma_value_t args[] = {element, source_val, ecma_make_object_value (source)};
    #####: 2728:      ecma_value_t temp_element = ecma_op_function_call (ecma_get_object_from_value (mapped_value), thisArg, args, 3);
        -: 2729:
    #####: 2730:      ecma_free_value (element);
    #####: 2731:      ecma_free_value (source_val);
        -: 2732:
    #####: 2733:      if (ECMA_IS_VALUE_ERROR (temp_element))
        -: 2734:      {
    #####: 2735:        return temp_element;
        -: 2736:      }
        -: 2737:
    #####: 2738:      element = temp_element;
        -: 2739:    }
        -: 2740:
        -: 2741:    /* iv-v. */
    #####: 2742:    if (depth > 0)
        -: 2743:    {
    #####: 2744:      ecma_value_t is_array = ecma_is_value_array (element);
        -: 2745:
    #####: 2746:      if (ECMA_IS_VALUE_ERROR (is_array))
        -: 2747:      {
    #####: 2748:        ecma_free_value (element);
    #####: 2749:        return is_array;
        -: 2750:      }
        -: 2751:
    #####: 2752:      if (ecma_is_value_true (is_array))
        -: 2753:      {
    #####: 2754:        ecma_object_t *element_obj = ecma_get_object_from_value (element);
    #####: 2755:        ecma_length_t element_len;
    #####: 2756:        ecma_value_t len_value = ecma_op_object_get_length (element_obj, &element_len);
        -: 2757:
    #####: 2758:        if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2759:        {
    #####: 2760:          ecma_deref_object (element_obj);
    #####: 2761:          return len_value;
        -: 2762:        }
        -: 2763:
    #####: 2764:        ecma_value_t target_index_val = ecma_builtin_array_flatten_into_array (target,
        -: 2765:                                                                               element_obj,
        -: 2766:                                                                               element_len,
        -: 2767:                                                                               target_index,
    #####: 2768:                                                                               depth - 1,
        -: 2769:                                                                               ECMA_VALUE_UNDEFINED,
        -: 2770:                                                                               ECMA_VALUE_UNDEFINED);
        -: 2771:
    #####: 2772:        ecma_deref_object (element_obj);
        -: 2773:
    #####: 2774:        if (ECMA_IS_VALUE_ERROR (target_index_val))
        -: 2775:        {
    #####: 2776:          return target_index_val;
        -: 2777:        }
        -: 2778:
    #####: 2779:        target_index = (ecma_length_t) ecma_get_number_from_value (target_index_val);
    #####: 2780:        continue;
        -: 2781:      }
        -: 2782:    }
        -: 2783:
        -: 2784:    /* vi. */
    #####: 2785:    const uint32_t flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
    #####: 2786:    ecma_value_t element_temp = ecma_builtin_helper_def_prop_by_index (ecma_get_object_from_value (target),
        -: 2787:                                                                       target_index,
        -: 2788:                                                                       element,
        -: 2789:                                                                       flags);
        -: 2790:
    #####: 2791:    ecma_free_value (element);
        -: 2792:
    #####: 2793:    if (ECMA_IS_VALUE_ERROR (element_temp))
        -: 2794:    {
    #####: 2795:      return element_temp;
        -: 2796:    }
        -: 2797:
    #####: 2798:    target_index++;
        -: 2799:  }
        -: 2800:  /* 10. */
    #####: 2801:  return ecma_make_length_value (target_index);
        -: 2802:} /* ecma_builtin_array_flatten_into_array */
        -: 2803:
        -: 2804:/**
        -: 2805: * The Array.prototype object's 'flat' routine
        -: 2806: *
        -: 2807: * See also:
        -: 2808: *          ECMA-262 v10, 22.1.3.10
        -: 2809: *
        -: 2810: * @return ecma value
        -: 2811: *         Returned value must be freed with ecma_free_value.
        -: 2812: */
        -: 2813:static ecma_value_t
    #####: 2814:ecma_builtin_array_prototype_object_flat (const ecma_value_t args[], /**< arguments list */
        -: 2815:                                          uint32_t args_number, /**< number of arguments */
        -: 2816:                                          ecma_object_t *obj_p, /**< array object */
        -: 2817:                                          ecma_length_t len) /**< array object's length */
        -: 2818:{
        -: 2819:  /* 3. */
    #####: 2820:  ecma_number_t depth_num = 1;
        -: 2821:
        -: 2822:  /* 4. */
    #####: 2823:  if (args_number > 0 && ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[0], &depth_num)))
        -: 2824:  {
    #####: 2825:    return ECMA_VALUE_ERROR;
        -: 2826:  }
        -: 2827:
        -: 2828:  /* 5. */
    #####: 2829:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2830:
    #####: 2831:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2832:  {
    #####: 2833:    return ECMA_VALUE_ERROR;
        -: 2834:  }
        -: 2835:
        -: 2836:  /* 6. */
    #####: 2837:  ecma_value_t flatten_val = ecma_builtin_array_flatten_into_array (ecma_make_object_value (new_array_p),
        -: 2838:                                                                    obj_p,
        -: 2839:                                                                    len,
        -: 2840:                                                                    0,
        -: 2841:                                                                    depth_num,
        -: 2842:                                                                    ECMA_VALUE_UNDEFINED,
        -: 2843:                                                                    ECMA_VALUE_UNDEFINED);
        -: 2844:
    #####: 2845:  if (ECMA_IS_VALUE_ERROR (flatten_val))
        -: 2846:  {
    #####: 2847:    ecma_deref_object (new_array_p);
    #####: 2848:    return flatten_val;
        -: 2849:  }
        -: 2850:
        -: 2851:  /* 7. */
    #####: 2852:  return ecma_make_object_value (new_array_p);
        -: 2853:} /* ecma_builtin_array_prototype_object_flat */
        -: 2854:
        -: 2855:/**
        -: 2856: * The Array.prototype object's 'flatMap' routine
        -: 2857: *
        -: 2858: * See also:
        -: 2859: *          ECMA-262 v10, 22.1.3.11
        -: 2860: *
        -: 2861: * @return ecma value
        -: 2862: *         Returned value must be freed with ecma_free_value.
        -: 2863: */
        -: 2864:static ecma_value_t
    #####: 2865:ecma_builtin_array_prototype_object_flat_map (ecma_value_t callback, /**< callbackFn */
        -: 2866:                                              ecma_value_t this_arg, /**< thisArg */
        -: 2867:                                              ecma_object_t *obj_p, /**< array object */
        -: 2868:                                              ecma_length_t len) /**< array object's length */
        -: 2869:{
    #####: 2870:  if (!ecma_op_is_callable (callback))
        -: 2871:  {
    #####: 2872:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_callback_is_not_callable));
        -: 2873:  }
        -: 2874:
        -: 2875:  /* 4. */
    #####: 2876:  ecma_object_t *new_array_p = ecma_op_array_species_create (obj_p, 0);
        -: 2877:
    #####: 2878:  if (JERRY_UNLIKELY (new_array_p == NULL))
        -: 2879:  {
    #####: 2880:    return ECMA_VALUE_ERROR;
        -: 2881:  }
        -: 2882:
        -: 2883:  /* 5. */
    #####: 2884:  ecma_value_t flatten_val = ecma_builtin_array_flatten_into_array (ecma_make_object_value (new_array_p),
        -: 2885:                                                                    obj_p,
        -: 2886:                                                                    len,
        -: 2887:                                                                    0,
        -: 2888:                                                                    1,
        -: 2889:                                                                    callback,
        -: 2890:                                                                    this_arg);
    #####: 2891:  if (ECMA_IS_VALUE_ERROR (flatten_val))
        -: 2892:  {
    #####: 2893:    ecma_deref_object (new_array_p);
    #####: 2894:    return flatten_val;
        -: 2895:  }
        -: 2896:
        -: 2897:  /* 6. */
    #####: 2898:  return ecma_make_object_value (new_array_p);
        -: 2899:} /* ecma_builtin_array_prototype_object_flat_map */
        -: 2900:#endif /* JERRY_ESNEXT */
        -: 2901:
        -: 2902:/**
        -: 2903: * Dispatcher of the built-in's routines
        -: 2904: *
        -: 2905: * @return ecma value
        -: 2906: *         Returned value must be freed with ecma_free_value.
        -: 2907: */
        -: 2908:ecma_value_t
      202: 2909:ecma_builtin_array_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -: 2910:                                               ecma_value_t this_arg, /**< 'this' argument value */
        -: 2911:                                               const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 2912:                                                                                       *   passed to routine */
        -: 2913:                                               uint32_t arguments_number) /**< length of arguments' list */
        -: 2914:{
      202: 2915:  ecma_value_t obj_this = ecma_op_to_object (this_arg);
        -: 2916:
      202: 2917:  if (ECMA_IS_VALUE_ERROR (obj_this))
        -: 2918:  {
    #####: 2919:    return obj_this;
        -: 2920:  }
        -: 2921:
      202: 2922:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);
        -: 2923:
      202: 2924:  if (JERRY_UNLIKELY (builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_CONCAT))
        -: 2925:  {
    #####: 2926:    ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 2927:
        -: 2928:#if !JERRY_ESNEXT
    #####: 2929:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_TO_STRING)
        -: 2930:    {
    #####: 2931:      ret_value = ecma_array_object_to_string (obj_this);
        -: 2932:    }
        -: 2933:#endif /* !JERRY_ESNEXT */
    #####: 2934:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_SORT)
        -: 2935:    {
    #####: 2936:      ret_value = ecma_builtin_array_prototype_object_sort (this_arg,
        -: 2937:                                                            arguments_list_p[0],
        -: 2938:                                                            obj_p);
        -: 2939:
        -: 2940:    }
    #####: 2941:    else if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_CONCAT)
        -: 2942:    {
    #####: 2943:      ret_value = ecma_builtin_array_prototype_object_concat (arguments_list_p,
        -: 2944:                                                              arguments_number,
        -: 2945:                                                              obj_p);
        -: 2946:    }
        -: 2947:
    #####: 2948:    ecma_deref_object (obj_p);
    #####: 2949:    return ret_value;
        -: 2950:  }
        -: 2951:
        -: 2952:#if JERRY_ESNEXT
      202: 2953:  if (JERRY_UNLIKELY (builtin_routine_id >= ECMA_ARRAY_PROTOTYPE_ENTRIES
        -: 2954:                      && builtin_routine_id <= ECMA_ARRAY_PROTOTYPE_KEYS))
        -: 2955:  {
        -: 2956:    ecma_value_t ret_value;
        -: 2957:
    #####: 2958:    if (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_ENTRIES)
        -: 2959:    {
    #####: 2960:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_ENTRIES);
        -: 2961:    }
        -: 2962:    else
        -: 2963:    {
    #####: 2964:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_KEYS);
    #####: 2965:      ret_value = ecma_op_create_array_iterator (obj_p, ECMA_ITERATOR_KEYS);
        -: 2966:    }
        -: 2967:
    #####: 2968:    ecma_deref_object (obj_p);
    #####: 2969:    return ret_value;
        -: 2970:  }
        -: 2971:#endif /* JERRY_ESNEXT */
        -: 2972:
      202: 2973:  ecma_length_t length;
      202: 2974:  ecma_value_t len_value = ecma_op_object_get_length (obj_p, &length);
        -: 2975:
      202: 2976:  if (ECMA_IS_VALUE_ERROR (len_value))
        -: 2977:  {
    #####: 2978:    ecma_deref_object (obj_p);
    #####: 2979:    return len_value;
        -: 2980:  }
        -: 2981:
        -: 2982:  ecma_value_t ret_value;
        -: 2983:
      202: 2984:  switch (builtin_routine_id)
        -: 2985:  {
    #####: 2986:    case ECMA_ARRAY_PROTOTYPE_TO_LOCALE_STRING:
        -: 2987:    {
    #####: 2988:      ret_value = ecma_builtin_array_prototype_object_to_locale_string (obj_p, length);
    #####: 2989:      break;
        -: 2990:    }
    #####: 2991:    case ECMA_ARRAY_PROTOTYPE_JOIN:
        -: 2992:    {
    #####: 2993:      ret_value = ecma_builtin_array_prototype_join (arguments_list_p[0], obj_p, length);
    #####: 2994:      break;
        -: 2995:    }
    #####: 2996:    case ECMA_ARRAY_PROTOTYPE_POP:
        -: 2997:    {
    #####: 2998:      ret_value = ecma_builtin_array_prototype_object_pop (obj_p, length);
    #####: 2999:      break;
        -: 3000:    }
      200: 3001:    case ECMA_ARRAY_PROTOTYPE_PUSH:
        -: 3002:    {
      200: 3003:      ret_value = ecma_builtin_array_prototype_object_push (arguments_list_p,
        -: 3004:                                                            arguments_number,
        -: 3005:                                                            obj_p,
        -: 3006:                                                            length);
      200: 3007:      break;
        -: 3008:    }
    #####: 3009:    case ECMA_ARRAY_PROTOTYPE_REVERSE:
        -: 3010:    {
    #####: 3011:      ret_value = ecma_builtin_array_prototype_object_reverse (this_arg, obj_p, length);
    #####: 3012:      break;
        -: 3013:    }
    #####: 3014:    case ECMA_ARRAY_PROTOTYPE_SHIFT:
        -: 3015:    {
    #####: 3016:      ret_value = ecma_builtin_array_prototype_object_shift (obj_p, length);
    #####: 3017:      break;
        -: 3018:    }
        2: 3019:    case ECMA_ARRAY_PROTOTYPE_SLICE:
        -: 3020:    {
        4: 3021:      ret_value = ecma_builtin_array_prototype_object_slice (arguments_list_p[0],
        2: 3022:                                                             arguments_list_p[1],
        -: 3023:                                                             obj_p,
        -: 3024:                                                             length);
    #####: 3025:      break;
        -: 3026:    }
    #####: 3027:    case ECMA_ARRAY_PROTOTYPE_SPLICE:
        -: 3028:    {
    #####: 3029:      ret_value = ecma_builtin_array_prototype_object_splice (arguments_list_p,
        -: 3030:                                                              arguments_number,
        -: 3031:                                                              obj_p,
        -: 3032:                                                              length);
    #####: 3033:      break;
        -: 3034:    }
    #####: 3035:    case ECMA_ARRAY_PROTOTYPE_UNSHIFT:
        -: 3036:    {
    #####: 3037:      ret_value = ecma_builtin_array_prototype_object_unshift (arguments_list_p,
        -: 3038:                                                               arguments_number,
        -: 3039:                                                               obj_p,
        -: 3040:                                                               length);
    #####: 3041:      break;
        -: 3042:    }
    #####: 3043:    case ECMA_ARRAY_PROTOTYPE_AT:
        -: 3044:    {
    #####: 3045:      ret_value = ecma_builtin_array_prototype_object_at (arguments_list_p[0],
        -: 3046:                                                          obj_p,
        -: 3047:                                                          length);
    #####: 3048:      break;
        -: 3049:    }
    #####: 3050:    case ECMA_ARRAY_PROTOTYPE_INDEX_OF:
        -: 3051:    {
    #####: 3052:      ret_value = ecma_builtin_array_prototype_object_index_of (arguments_list_p,
        -: 3053:                                                                arguments_number,
        -: 3054:                                                                obj_p,
        -: 3055:                                                                length);
    #####: 3056:      break;
        -: 3057:    }
    #####: 3058:    case ECMA_ARRAY_PROTOTYPE_LAST_INDEX_OF:
        -: 3059:    {
    #####: 3060:      ret_value = ecma_builtin_array_prototype_object_last_index_of (arguments_list_p,
        -: 3061:                                                                     arguments_number,
        -: 3062:                                                                     obj_p,
        -: 3063:                                                                     length);
    #####: 3064:      break;
        -: 3065:    }
    #####: 3066:    case ECMA_ARRAY_PROTOTYPE_EVERY:
        -: 3067:    case ECMA_ARRAY_PROTOTYPE_SOME:
        -: 3068:    case ECMA_ARRAY_PROTOTYPE_FOR_EACH:
        -: 3069:    {
    #####: 3070:      ret_value = ecma_builtin_array_apply (arguments_list_p[0],
    #####: 3071:                                            arguments_list_p[1],
    #####: 3072:                                            (array_routine_mode) builtin_routine_id - ECMA_ARRAY_PROTOTYPE_EVERY,
        -: 3073:                                            obj_p,
        -: 3074:                                            length);
    #####: 3075:      break;
        -: 3076:    }
    #####: 3077:    case ECMA_ARRAY_PROTOTYPE_MAP:
        -: 3078:    {
    #####: 3079:      ret_value = ecma_builtin_array_prototype_object_map (arguments_list_p[0],
    #####: 3080:                                                           arguments_list_p[1],
        -: 3081:                                                           obj_p,
        -: 3082:                                                           length);
    #####: 3083:      break;
        -: 3084:    }
    #####: 3085:    case ECMA_ARRAY_PROTOTYPE_REDUCE:
        -: 3086:    case ECMA_ARRAY_PROTOTYPE_REDUCE_RIGHT:
        -: 3087:    {
    #####: 3088:      ret_value = ecma_builtin_array_reduce_from (arguments_list_p,
        -: 3089:                                                  arguments_number,
        -: 3090:                                                  builtin_routine_id == ECMA_ARRAY_PROTOTYPE_REDUCE,
        -: 3091:                                                  obj_p,
        -: 3092:                                                  length);
    #####: 3093:      break;
        -: 3094:    }
        -: 3095:#if JERRY_ESNEXT
    #####: 3096:    case ECMA_ARRAY_PROTOTYPE_COPY_WITHIN:
        -: 3097:    {
    #####: 3098:      ret_value = ecma_builtin_array_prototype_object_copy_within (arguments_list_p,
        -: 3099:                                                                   arguments_number,
        -: 3100:                                                                   obj_p,
        -: 3101:                                                                   length);
    #####: 3102:      break;
        -: 3103:    }
    #####: 3104:    case ECMA_ARRAY_PROTOTYPE_FIND:
        -: 3105:    case ECMA_ARRAY_PROTOTYPE_FIND_INDEX:
        -: 3106:    {
    #####: 3107:      ret_value = ecma_builtin_array_prototype_object_find (arguments_list_p[0],
    #####: 3108:                                                            arguments_list_p[1],
        -: 3109:                                                            builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FIND,
        -: 3110:                                                            obj_p,
        -: 3111:                                                            length);
    #####: 3112:      break;
        -: 3113:    }
    #####: 3114:    case ECMA_ARRAY_PROTOTYPE_FILL:
        -: 3115:    {
    #####: 3116:      ret_value = ecma_builtin_array_prototype_fill (arguments_list_p[0],
    #####: 3117:                                                     arguments_list_p[1],
    #####: 3118:                                                     arguments_list_p[2],
        -: 3119:                                                     obj_p,
        -: 3120:                                                     length);
    #####: 3121:      break;
        -: 3122:    }
    #####: 3123:    case ECMA_ARRAY_PROTOTYPE_INCLUDES:
        -: 3124:    {
    #####: 3125:      ret_value = ecma_builtin_array_prototype_includes (arguments_list_p,
        -: 3126:                                                         arguments_number,
        -: 3127:                                                         obj_p,
        -: 3128:                                                         length);
    #####: 3129:      break;
        -: 3130:    }
    #####: 3131:    case ECMA_ARRAY_PROTOTYPE_FLAT:
        -: 3132:    {
    #####: 3133:      ret_value = ecma_builtin_array_prototype_object_flat (arguments_list_p,
        -: 3134:                                                            arguments_number,
        -: 3135:                                                            obj_p,
        -: 3136:                                                            length);
    #####: 3137:      break;
        -: 3138:    }
    #####: 3139:    case ECMA_ARRAY_PROTOTYPE_FLATMAP:
        -: 3140:    {
    #####: 3141:      ret_value = ecma_builtin_array_prototype_object_flat_map (arguments_list_p[0],
    #####: 3142:                                                                arguments_list_p[1],
        -: 3143:                                                                obj_p,
        -: 3144:                                                                length);
    #####: 3145:      break;
        -: 3146:    }
        -: 3147:#endif /* JERRY_ESNEXT */
    #####: 3148:    default:
        -: 3149:    {
    #####: 3150:      JERRY_ASSERT (builtin_routine_id == ECMA_ARRAY_PROTOTYPE_FILTER);
        -: 3151:
    #####: 3152:      ret_value = ecma_builtin_array_prototype_object_filter (arguments_list_p[0],
    #####: 3153:                                                              arguments_list_p[1],
        -: 3154:                                                              obj_p,
        -: 3155:                                                              length);
    #####: 3156:      break;
        -: 3157:    }
        -: 3158:  }
        -: 3159:
      200: 3160:  ecma_free_value (len_value);
      200: 3161:  ecma_deref_object (obj_p);
        -: 3162:
      200: 3163:  return ret_value;
        -: 3164:} /* ecma_builtin_array_prototype_dispatch_routine */
        -: 3165:
        -: 3166:/**
        -: 3167: * @}
        -: 3168: * @}
        -: 3169: * @}
        -: 3170: */
        -: 3171:
        -: 3172:#endif /* JERRY_BUILTIN_ARRAY */
