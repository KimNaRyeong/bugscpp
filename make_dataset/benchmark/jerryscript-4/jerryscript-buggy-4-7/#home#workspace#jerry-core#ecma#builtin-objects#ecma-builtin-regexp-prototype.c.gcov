        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-regexp-prototype.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtins.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-globals.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-objects.h"
        -:   27:#include "ecma-regexp-object.h"
        -:   28:#include "lit-char-helpers.h"
        -:   29:
        -:   30:#if JERRY_BUILTIN_REGEXP
        -:   31:#include "ecma-regexp-object.h"
        -:   32:#include "re-compiler.h"
        -:   33:
        -:   34:#define ECMA_BUILTINS_INTERNAL
        -:   35:#include "ecma-builtins-internal.h"
        -:   36:
        -:   37:/**
        -:   38: * This object has a custom dispatch function.
        -:   39: */
        -:   40: #define BUILTIN_CUSTOM_DISPATCH
        -:   41:
        -:   42:/**
        -:   43: * List of built-in routine identifiers.
        -:   44: */
        -:   45:enum
        -:   46:{
        -:   47:  /** These routines must be in this order */
        -:   48:  ECMA_REGEXP_PROTOTYPE_ROUTINE_START = 0,
        -:   49:  ECMA_REGEXP_PROTOTYPE_ROUTINE_EXEC,
        -:   50:#if JERRY_BUILTIN_ANNEXB
        -:   51:  ECMA_REGEXP_PROTOTYPE_ROUTINE_COMPILE,
        -:   52:#endif /* JERRY_BUILTIN_ANNEXB */
        -:   53:
        -:   54:  ECMA_REGEXP_PROTOTYPE_ROUTINE_TEST,
        -:   55:  ECMA_REGEXP_PROTOTYPE_ROUTINE_TO_STRING,
        -:   56:#if JERRY_ESNEXT
        -:   57:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_SOURCE,
        -:   58:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_FLAGS,
        -:   59:
        -:   60:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_GLOBAL,
        -:   61:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_IGNORE_CASE,
        -:   62:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_MULTILINE,
        -:   63:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_STICKY,
        -:   64:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_UNICODE,
        -:   65:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_DOT_ALL,
        -:   66:
        -:   67:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_SEARCH,
        -:   68:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_MATCH,
        -:   69:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_REPLACE,
        -:   70:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_SPLIT,
        -:   71:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_MATCH_ALL,
        -:   72:#endif /* JERRY_ESNEXT */
        -:   73:};
        -:   74:
        -:   75:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-regexp-prototype.inc.h"
        -:   76:#define BUILTIN_UNDERSCORED_ID regexp_prototype
        -:   77:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   78:
        -:   79:/** \addtogroup ecma ECMA
        -:   80: * @{
        -:   81: *
        -:   82: * \addtogroup ecmabuiltins
        -:   83: * @{
        -:   84: *
        -:   85: * \addtogroup regexpprototype ECMA RegExp.prototype object built-in
        -:   86: * @{
        -:   87: */
        -:   88:
        -:   89:#if JERRY_ESNEXT
        -:   90:/**
        -:   91: * Helper function to retrieve the flags associated with a RegExp object
        -:   92: *
        -:   93: * @return ECMA_VALUE_{TRUE,FALSE} depends on whether the given flag is present.
        -:   94: */
        -:   95:static ecma_value_t
    #####:   96:ecma_builtin_regexp_prototype_flags_helper (ecma_extended_object_t *re_obj_p, /**< this object */
        -:   97:                                            uint16_t builtin_routine_id) /**< id of the flag */
        -:   98:{
    #####:   99:  re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
        -:  100:
    #####:  101:  uint16_t flags = bc_p->header.status_flags;
        -:  102:
        -:  103:  static const uint8_t re_flags[] =
        -:  104:  {
        -:  105:    RE_FLAG_GLOBAL,
        -:  106:    RE_FLAG_IGNORE_CASE,
        -:  107:    RE_FLAG_MULTILINE,
        -:  108:    RE_FLAG_STICKY,
        -:  109:    RE_FLAG_UNICODE,
        -:  110:    RE_FLAG_DOTALL,
        -:  111:  };
        -:  112:
    #####:  113:  uint16_t offset = (uint16_t) (builtin_routine_id - ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_GLOBAL);
    #####:  114:  return ecma_make_boolean_value ((flags & re_flags[offset]) != 0);
        -:  115:} /* ecma_builtin_regexp_prototype_flags_helper */
        -:  116:
        -:  117:/**
        -:  118: * The RegExp.prototype object's 'flags' accessor property
        -:  119: *
        -:  120: * See also:
        -:  121: *          ECMA-262 v6, 21.2.5.3
        -:  122: *
        -:  123: * @return ECMA_VALUE_ERROR - if 'this' is not a RegExp object
        -:  124: *         string value     - otherwise
        -:  125: *
        -:  126: *         Returned value must be freed with ecma_free_value.
        -:  127: */
        -:  128:static ecma_value_t
    #####:  129:ecma_builtin_regexp_prototype_get_flags (ecma_object_t *object_p) /**< this object */
        -:  130:{
        -:  131:  static const lit_magic_string_id_t flag_lit_ids[] =
        -:  132:  {
        -:  133:    LIT_MAGIC_STRING_GLOBAL,
        -:  134:    LIT_MAGIC_STRING_IGNORECASE_UL,
        -:  135:    LIT_MAGIC_STRING_MULTILINE,
        -:  136:    LIT_MAGIC_STRING_DOTALL,
        -:  137:    LIT_MAGIC_STRING_UNICODE,
        -:  138:    LIT_MAGIC_STRING_STICKY
        -:  139:  };
        -:  140:
        -:  141:  static const lit_utf8_byte_t flag_chars[] =
        -:  142:  {
        -:  143:    LIT_CHAR_LOWERCASE_G,
        -:  144:    LIT_CHAR_LOWERCASE_I,
        -:  145:    LIT_CHAR_LOWERCASE_M,
        -:  146:    LIT_CHAR_LOWERCASE_S,
        -:  147:    LIT_CHAR_LOWERCASE_U,
        -:  148:    LIT_CHAR_LOWERCASE_Y
        -:  149:  };
        -:  150:
    #####:  151:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
    #####:  152:  for (uint32_t i = 0; i < sizeof (flag_lit_ids) / sizeof (lit_magic_string_id_t); i++)
        -:  153:  {
    #####:  154:    ecma_value_t result = ecma_op_object_get_by_magic_id (object_p, flag_lit_ids[i]);
    #####:  155:    if (ECMA_IS_VALUE_ERROR (result))
        -:  156:    {
    #####:  157:      ecma_stringbuilder_destroy (&builder);
    #####:  158:      return result;
        -:  159:    }
        -:  160:
    #####:  161:    if (ecma_op_to_boolean (result))
        -:  162:    {
    #####:  163:      ecma_stringbuilder_append_byte (&builder, flag_chars[i]);
        -:  164:    }
        -:  165:
    #####:  166:    ecma_free_value (result);
        -:  167:  }
        -:  168:
    #####:  169:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  170:} /* ecma_builtin_regexp_prototype_get_flags */
        -:  171:
        -:  172:/**
        -:  173: * The EscapeRegExpPattern method.
        -:  174: *
        -:  175: * See also:
        -:  176: *          ECMA-262 v6, 21.2.3.2.4
        -:  177: *
        -:  178: * @return ecma_value_t
        -:  179: */
        -:  180:static ecma_value_t
    #####:  181:ecma_op_escape_regexp_pattern (ecma_string_t *pattern_str_p) /**< RegExp pattern */
        -:  182:{
    #####:  183:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  184:
    #####:  185:  ECMA_STRING_TO_UTF8_STRING (pattern_str_p, pattern_start_p, pattern_start_size);
        -:  186:
    #####:  187:  const lit_utf8_byte_t *pattern_str_curr_p = pattern_start_p;
    #####:  188:  const lit_utf8_byte_t *pattern_str_end_p = pattern_start_p + pattern_start_size;
        -:  189:
    #####:  190:  while (pattern_str_curr_p < pattern_str_end_p)
        -:  191:  {
    #####:  192:    ecma_char_t c = lit_cesu8_read_next (&pattern_str_curr_p);
        -:  193:
    #####:  194:    switch (c)
        -:  195:    {
    #####:  196:      case LIT_CHAR_SLASH:
        -:  197:      {
    #####:  198:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\/", 2);
    #####:  199:        break;
        -:  200:      }
    #####:  201:      case LIT_CHAR_LF:
        -:  202:      {
    #####:  203:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\n", 2);
    #####:  204:        break;
        -:  205:      }
    #####:  206:      case LIT_CHAR_CR:
        -:  207:      {
    #####:  208:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\r", 2);
    #####:  209:        break;
        -:  210:      }
    #####:  211:      case LIT_CHAR_LS:
        -:  212:      {
    #####:  213:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\u2028", 6);
    #####:  214:        break;
        -:  215:      }
    #####:  216:      case LIT_CHAR_PS:
        -:  217:      {
    #####:  218:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\u2029", 6);
    #####:  219:        break;
        -:  220:      }
    #####:  221:      case LIT_CHAR_BACKSLASH:
        -:  222:      {
    #####:  223:        JERRY_ASSERT (pattern_str_curr_p < pattern_str_end_p);
    #####:  224:        ecma_stringbuilder_append_char (&builder, LIT_CHAR_BACKSLASH);
    #####:  225:        ecma_stringbuilder_append_char (&builder, lit_cesu8_read_next (&pattern_str_curr_p));
    #####:  226:        break;
        -:  227:      }
    #####:  228:      default:
        -:  229:      {
    #####:  230:        ecma_stringbuilder_append_char (&builder, c);
    #####:  231:        break;
        -:  232:      }
        -:  233:    }
        -:  234:  }
        -:  235:
    #####:  236:  ECMA_FINALIZE_UTF8_STRING (pattern_start_p, pattern_start_size);
        -:  237:
    #####:  238:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  239:} /* ecma_op_escape_regexp_pattern */
        -:  240:
        -:  241:/**
        -:  242: * The RegExp.prototype object's 'source' accessor property
        -:  243: *
        -:  244: * See also:
        -:  245: *          ECMA-262 v6, 21.2.5.10
        -:  246: *
        -:  247: * @return ECMA_VALUE_ERROR - if 'this' is not a RegExp object
        -:  248: *         string value     - otherwise
        -:  249: *
        -:  250: *         Returned value must be freed with ecma_free_value.
        -:  251: */
        -:  252:static ecma_value_t
    #####:  253:ecma_builtin_regexp_prototype_get_source (ecma_extended_object_t *re_obj_p) /**< this argument */
        -:  254:{
    #####:  255:  re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
        -:  256:
    #####:  257:  return ecma_op_escape_regexp_pattern (ecma_get_string_from_value (bc_p->source));
        -:  258:} /* ecma_builtin_regexp_prototype_get_source */
        -:  259:#endif /* JERRY_ESNEXT */
        -:  260:
        -:  261:#if JERRY_BUILTIN_ANNEXB
        -:  262:/**
        -:  263: * The RegExp.prototype object's 'compile' routine
        -:  264: *
        -:  265: * See also:
        -:  266: *          ECMA-262 v11, B.2.5.1
        -:  267: *
        -:  268: * @return undefined        - if compiled successfully
        -:  269: *         error ecma value - otherwise
        -:  270: *
        -:  271: *         Returned value must be freed with ecma_free_value.
        -:  272: */
        -:  273:static ecma_value_t
    #####:  274:ecma_builtin_regexp_prototype_compile (ecma_value_t this_arg, /**< this */
        -:  275:                                       ecma_value_t pattern_arg, /**< pattern or RegExp object */
        -:  276:                                       ecma_value_t flags_arg) /**< flags */
        -:  277:{
        -:  278:#if !JERRY_ESNEXT
    #####:  279:  if (ecma_get_object_from_value (this_arg) == ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE))
        -:  280:  {
    #####:  281:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_an_regexp));
        -:  282:  }
        -:  283:#endif /* !JERRY_ESNEXT */
        -:  284:
    #####:  285:  ecma_object_t *this_obj_p = ecma_get_object_from_value (this_arg);
    #####:  286:  ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) this_obj_p;
    #####:  287:  re_compiled_code_t *old_bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
        -:  288:
        -:  289:  ecma_value_t ret_value;
        -:  290:
    #####:  291:  if (ecma_object_is_regexp_object (pattern_arg))
        -:  292:  {
    #####:  293:    if (!ecma_is_value_undefined (flags_arg))
        -:  294:    {
    #####:  295:      return ecma_raise_type_error (ECMA_ERR_MSG ("Invalid argument"));
        -:  296:    }
        -:  297:
    #####:  298:    ecma_extended_object_t *pattern_obj_p = (ecma_extended_object_t *) ecma_get_object_from_value (pattern_arg);
    #####:  299:    re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, pattern_obj_p->u.cls.u3.value);
        -:  300:
    #####:  301:    ret_value = ecma_op_create_regexp_from_bytecode (this_obj_p, bc_p);
        -:  302:  }
        -:  303:  else
        -:  304:  {
    #####:  305:    ret_value = ecma_op_create_regexp_from_pattern (this_obj_p, pattern_arg, flags_arg);
        -:  306:  }
        -:  307:
    #####:  308:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -:  309:  {
    #####:  310:    ecma_value_t status = ecma_builtin_helper_def_prop (this_obj_p,
        -:  311:                                                        ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -:  312:                                                        ecma_make_uint32_value (0),
        -:  313:                                                        ECMA_PROPERTY_FLAG_WRITABLE | JERRY_PROP_SHOULD_THROW);
        -:  314:
    #####:  315:    ecma_bytecode_deref ((ecma_compiled_code_t *) old_bc_p);
        -:  316:
    #####:  317:    if (ECMA_IS_VALUE_ERROR (status))
        -:  318:    {
    #####:  319:      return status;
        -:  320:    }
        -:  321:
    #####:  322:    ecma_ref_object (this_obj_p);
        -:  323:  }
        -:  324:
    #####:  325:  return ret_value;
        -:  326:} /* ecma_builtin_regexp_prototype_compile */
        -:  327:
        -:  328:#endif /* JERRY_BUILTIN_ANNEXB */
        -:  329:
        -:  330:/**
        -:  331: * The RegExp.prototype object's 'exec' routine
        -:  332: *
        -:  333: * See also:
        -:  334: *          ECMA-262 v5, 15.10.6.2
        -:  335: *
        -:  336: * @return array object containing the results - if the matched
        -:  337: *         null                                - otherwise
        -:  338: *
        -:  339: *         May raise error, so returned value must be freed with ecma_free_value.
        -:  340: */
        -:  341:static ecma_value_t
    #####:  342:ecma_builtin_regexp_prototype_exec (ecma_value_t this_arg, /**< this argument */
        -:  343:                                    ecma_value_t arg) /**< routine's argument */
        -:  344:{
    #####:  345:  ecma_value_t obj_this = ecma_op_to_object (this_arg);
    #####:  346:  if (ECMA_IS_VALUE_ERROR (obj_this))
        -:  347:  {
    #####:  348:    return obj_this;
        -:  349:  }
        -:  350:
    #####:  351:  ecma_string_t *input_str_p = ecma_op_to_string (arg);
    #####:  352:  if (JERRY_UNLIKELY (input_str_p == NULL))
        -:  353:  {
    #####:  354:    ecma_free_value (obj_this);
    #####:  355:    return ECMA_VALUE_ERROR;
        -:  356:  }
        -:  357:
    #####:  358:  ecma_value_t ret_value = ecma_regexp_exec_helper (ecma_get_object_from_value (obj_this), input_str_p);
        -:  359:
    #####:  360:  ecma_free_value (obj_this);
    #####:  361:  ecma_deref_ecma_string (input_str_p);
        -:  362:
    #####:  363:  return ret_value;
        -:  364:} /* ecma_builtin_regexp_prototype_exec */
        -:  365:
        -:  366:/**
        -:  367: * The RegExp.prototype object's 'test' routine
        -:  368: *
        -:  369: * See also:
        -:  370: *          ECMA-262 v5, 15.10.6.3
        -:  371: *          ECMA-262 v6, 21.2.5.13
        -:  372: *
        -:  373: * @return true  - if match is not null
        -:  374: *         false - otherwise
        -:  375: *
        -:  376: *         May raise error, so returned value must be freed with ecma_free_value.
        -:  377: */
        -:  378:static ecma_value_t
    #####:  379:ecma_builtin_regexp_prototype_test (ecma_value_t this_arg, /**< this argument */
        -:  380:                                    ecma_value_t arg) /**< routine's argument */
        -:  381:{
        -:  382:#if JERRY_ESNEXT
    #####:  383:  ecma_string_t *arg_str_p = ecma_op_to_string (arg);
        -:  384:
    #####:  385:  if (JERRY_UNLIKELY (arg_str_p == NULL))
        -:  386:  {
    #####:  387:    return ECMA_VALUE_ERROR;
        -:  388:  }
        -:  389:
    #####:  390:  ecma_value_t result = ecma_op_regexp_exec (this_arg, arg_str_p);
        -:  391:
    #####:  392:  ecma_deref_ecma_string (arg_str_p);
        -:  393:
    #####:  394:  if (ECMA_IS_VALUE_ERROR (result))
        -:  395:  {
    #####:  396:    return result;
        -:  397:  }
        -:  398:#else /* !JERRY_ESNEXT */
    #####:  399:  ecma_value_t result = ecma_builtin_regexp_prototype_exec (this_arg, arg);
        -:  400:
    #####:  401:  if (ECMA_IS_VALUE_ERROR (result))
        -:  402:  {
        -:  403:    return result;
        -:  404:  }
        -:  405:#endif /* JERRY_ESNEXT */
        -:  406:
    #####:  407:  ecma_value_t ret_value = ecma_make_boolean_value (!ecma_is_value_null (result));
    #####:  408:  ecma_free_value (result);
        -:  409:
    #####:  410:  return ret_value;
        -:  411:} /* ecma_builtin_regexp_prototype_test */
        -:  412:
        -:  413:/**
        -:  414: * The RegExp.prototype object's 'toString' routine
        -:  415: *
        -:  416: * See also:
        -:  417: *          ECMA-262 v5, 15.10.6.4
        -:  418: *
        -:  419: * @return ecma value
        -:  420: *         Returned value must be freed with ecma_free_value.
        -:  421: */
        -:  422:static ecma_value_t
    #####:  423:ecma_builtin_regexp_prototype_to_string (ecma_object_t *object_p) /**< this object */
        -:  424:{
        -:  425:#if JERRY_ESNEXT
    #####:  426:  ecma_value_t result = ecma_op_object_get_by_magic_id (object_p, LIT_MAGIC_STRING_SOURCE);
    #####:  427:  if (ECMA_IS_VALUE_ERROR (result))
        -:  428:  {
    #####:  429:    return result;
        -:  430:  }
        -:  431:
    #####:  432:  ecma_string_t *source_p = ecma_op_to_string (result);
    #####:  433:  ecma_free_value (result);
        -:  434:
    #####:  435:  if (source_p == NULL)
        -:  436:  {
    #####:  437:    return ECMA_VALUE_ERROR;
        -:  438:  }
        -:  439:
    #####:  440:  result = ecma_op_object_get_by_magic_id (object_p, LIT_MAGIC_STRING_FLAGS);
    #####:  441:  if (ECMA_IS_VALUE_ERROR (result))
        -:  442:  {
    #####:  443:    ecma_deref_ecma_string (source_p);
    #####:  444:    return result;
        -:  445:  }
        -:  446:
    #####:  447:  ecma_string_t *flags_p = ecma_op_to_string (result);
    #####:  448:  ecma_free_value (result);
        -:  449:
    #####:  450:  if (flags_p == NULL)
        -:  451:  {
    #####:  452:    ecma_deref_ecma_string (source_p);
    #####:  453:    return ECMA_VALUE_ERROR;
        -:  454:  }
        -:  455:
    #####:  456:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
    #####:  457:  ecma_stringbuilder_append_byte (&builder, LIT_CHAR_SLASH);
    #####:  458:  ecma_stringbuilder_append (&builder, source_p);
    #####:  459:  ecma_stringbuilder_append_byte (&builder, LIT_CHAR_SLASH);
    #####:  460:  ecma_stringbuilder_append (&builder, flags_p);
        -:  461:
    #####:  462:  ecma_deref_ecma_string (source_p);
    #####:  463:  ecma_deref_ecma_string (flags_p);
        -:  464:
    #####:  465:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  466:#else /* !JERRY_ESNEXT */
    #####:  467:  ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) object_p;
        -:  468:
    #####:  469:  re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t,
        -:  470:                                                              re_obj_p->u.cls.u3.value);
        -:  471:
    #####:  472:  ecma_string_t *source_p = ecma_get_string_from_value (bc_p->source);
    #####:  473:  uint16_t flags = bc_p->header.status_flags;
        -:  474:
    #####:  475:  ecma_stringbuilder_t result = ecma_stringbuilder_create ();
    #####:  476:  ecma_stringbuilder_append_byte (&result, LIT_CHAR_SLASH);
    #####:  477:  ecma_stringbuilder_append (&result, source_p);
    #####:  478:  ecma_stringbuilder_append_byte (&result, LIT_CHAR_SLASH);
        -:  479:
    #####:  480:  if (flags & RE_FLAG_GLOBAL)
        -:  481:  {
    #####:  482:    ecma_stringbuilder_append_byte (&result, LIT_CHAR_LOWERCASE_G);
        -:  483:  }
        -:  484:
    #####:  485:  if (flags & RE_FLAG_IGNORE_CASE)
        -:  486:  {
    #####:  487:    ecma_stringbuilder_append_byte (&result, LIT_CHAR_LOWERCASE_I);
        -:  488:  }
        -:  489:
    #####:  490:  if (flags & RE_FLAG_MULTILINE)
        -:  491:  {
    #####:  492:    ecma_stringbuilder_append_byte (&result, LIT_CHAR_LOWERCASE_M);
        -:  493:  }
        -:  494:
    #####:  495:  return ecma_make_string_value (ecma_stringbuilder_finalize (&result));
        -:  496:#endif /* JERRY_ESNEXT */
        -:  497:} /* ecma_builtin_regexp_prototype_to_string */
        -:  498:
        -:  499:#if JERRY_ESNEXT
        -:  500:/**
        -:  501: * Helper function to determine if method is the builtin exec method
        -:  502: *
        -:  503: * @return true, if function is the builtin exec method
        -:  504: *         false, otherwise
        -:  505: */
        -:  506:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####:  507:ecma_builtin_is_regexp_exec (ecma_extended_object_t *obj_p)
        -:  508:{
    #####:  509:  return (ecma_get_object_type (&obj_p->object) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION
    #####:  510:          && obj_p->u.built_in.routine_id == ECMA_REGEXP_PROTOTYPE_ROUTINE_EXEC);
        -:  511:} /* ecma_builtin_is_regexp_exec */
        -:  512:#endif /* JERRY_ESNEXT */
        -:  513:
        -:  514:#if JERRY_ESNEXT
        -:  515:/**
        -:  516: * The RegExp.prototype object's 'matchAll' routine
        -:  517: *
        -:  518: * See also:
        -:  519: *          ECMA-262 v11, 21.2.5.8
        -:  520: *
        -:  521: * @return ecma_value_t
        -:  522: */
        -:  523:static ecma_value_t
    #####:  524:ecma_builtin_regexp_prototype_match_all (ecma_object_t *regexp_obj_p, /**< this argument */
        -:  525:                                         ecma_value_t string_arg) /**< source string */
        -:  526:{
        -:  527:  /* 3. */
    #####:  528:  ecma_string_t *str_p = ecma_op_to_string (string_arg);
        -:  529:
    #####:  530:  if (JERRY_UNLIKELY (str_p == NULL))
        -:  531:  {
    #####:  532:    return ECMA_VALUE_ERROR;
        -:  533:  }
        -:  534:
        -:  535:  /* 4. */
    #####:  536:  ecma_value_t constructor = ecma_op_species_constructor (regexp_obj_p, ECMA_BUILTIN_ID_REGEXP);
        -:  537:
    #####:  538:  if (ECMA_IS_VALUE_ERROR (constructor))
        -:  539:  {
    #####:  540:    ecma_deref_ecma_string (str_p);
    #####:  541:    return constructor;
        -:  542:  }
        -:  543:
        -:  544:  /* 5. */
    #####:  545:  ecma_value_t get_flag = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_FLAGS);
        -:  546:
    #####:  547:  if (ECMA_IS_VALUE_ERROR (get_flag))
        -:  548:  {
    #####:  549:    ecma_deref_ecma_string (str_p);
    #####:  550:    ecma_free_value (constructor);
    #####:  551:    return get_flag;
        -:  552:  }
        -:  553:
    #####:  554:  ecma_string_t *flags = ecma_op_to_string (get_flag);
        -:  555:
    #####:  556:  ecma_free_value (get_flag);
        -:  557:
    #####:  558:  if (JERRY_UNLIKELY (flags == NULL))
        -:  559:  {
    #####:  560:    ecma_deref_ecma_string (str_p);
    #####:  561:    ecma_free_value (constructor);
    #####:  562:    return ECMA_VALUE_ERROR;
        -:  563:  }
        -:  564:
        -:  565:  /* 6. */
    #####:  566:  ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor);
    #####:  567:  ecma_value_t flags_value = ecma_make_string_value (flags);
    #####:  568:  ecma_value_t match_args[] = { ecma_make_object_value (regexp_obj_p), flags_value};
    #####:  569:  ecma_value_t matcher = ecma_op_function_construct (constructor_obj_p, constructor_obj_p, match_args, 2);
        -:  570:
    #####:  571:  ecma_deref_object (constructor_obj_p);
        -:  572:
    #####:  573:  if (ECMA_IS_VALUE_ERROR (matcher))
        -:  574:  {
    #####:  575:    ecma_deref_ecma_string (str_p);
    #####:  576:    ecma_deref_ecma_string (flags);
    #####:  577:    return matcher;
        -:  578:  }
        -:  579:
        -:  580:  /* 7. */
    #####:  581:  ecma_value_t get_last_index = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);
        -:  582:
    #####:  583:  if (ECMA_IS_VALUE_ERROR (get_last_index))
        -:  584:  {
    #####:  585:    ecma_deref_ecma_string (str_p);
    #####:  586:    ecma_deref_ecma_string (flags);
    #####:  587:    ecma_free_value (matcher);
    #####:  588:    return get_last_index;
        -:  589:  }
        -:  590:
    #####:  591:  ecma_length_t last_index;
    #####:  592:  ecma_value_t to_len = ecma_op_to_length (get_last_index, &last_index);
        -:  593:
    #####:  594:  ecma_free_value (get_last_index);
        -:  595:
    #####:  596:  if (ECMA_IS_VALUE_ERROR (to_len))
        -:  597:  {
    #####:  598:    ecma_deref_ecma_string (str_p);
    #####:  599:    ecma_deref_ecma_string (flags);
    #####:  600:    ecma_free_value (matcher);
    #####:  601:    return to_len;
        -:  602:  }
        -:  603:
        -:  604:  /* 8. */
    #####:  605:  ecma_object_t *matcher_obj_p = ecma_get_object_from_value (matcher);
    #####:  606:  ecma_value_t last_index_value = ecma_make_length_value (last_index);
    #####:  607:  ecma_value_t set = ecma_op_object_put (matcher_obj_p,
        -:  608:                                         ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -:  609:                                         last_index_value,
        -:  610:                                         true);
        -:  611:
    #####:  612:  ecma_free_value (last_index_value);
        -:  613:
    #####:  614:  if (ECMA_IS_VALUE_ERROR (set))
        -:  615:  {
    #####:  616:    ecma_deref_ecma_string (str_p);
    #####:  617:    ecma_deref_ecma_string (flags);
    #####:  618:    ecma_deref_object (matcher_obj_p);
        -:  619:  }
        -:  620:
    #####:  621:  uint16_t parsed_flag;
    #####:  622:  ecma_value_t flag_parse = ecma_regexp_parse_flags (flags, &parsed_flag);
        -:  623:
    #####:  624:  ecma_deref_ecma_string (flags);
        -:  625:
    #####:  626:  if (ECMA_IS_VALUE_ERROR (flag_parse))
        -:  627:  {
    #####:  628:    ecma_deref_ecma_string (str_p);
    #####:  629:    ecma_deref_object (matcher_obj_p);
    #####:  630:    return flag_parse;
        -:  631:  }
        -:  632:
        -:  633:  /* 13. */
        -:  634:  ecma_object_t *result_obj;
    #####:  635:  ecma_object_t *proto_p = ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_STRING_ITERATOR_PROTOTYPE);
    #####:  636:  result_obj = ecma_create_object (proto_p,
        -:  637:                                   sizeof (ecma_regexp_string_iterator_t),
        -:  638:                                   ECMA_OBJECT_TYPE_CLASS);
        -:  639:
    #####:  640:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) result_obj;
    #####:  641:  ext_obj_p->u.cls.type = ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR;
    #####:  642:  ext_obj_p->u.cls.u1.regexp_string_iterator_flags = (uint8_t) (parsed_flag & (RE_FLAG_GLOBAL | RE_FLAG_UNICODE));
        -:  643:
    #####:  644:  ecma_regexp_string_iterator_t *regexp_string_iterator_obj = (ecma_regexp_string_iterator_t *) result_obj;
        -:  645:
    #####:  646:  regexp_string_iterator_obj->iterating_regexp = matcher;
    #####:  647:  regexp_string_iterator_obj->iterated_string = ecma_make_string_value (str_p);
        -:  648:
    #####:  649:  ecma_deref_object (matcher_obj_p);
        -:  650:
    #####:  651:  return ecma_make_object_value (result_obj);
        -:  652:} /* ecma_builtin_regexp_prototype_match_all */
        -:  653:#endif /* JERRY_ESNEXT */
        -:  654:
        -:  655:/**
        -:  656: * Dispatcher of the Regexp built-in's routines
        -:  657: *
        -:  658: * @return ecma value
        -:  659: *         Returned value must be freed with ecma_free_value.
        -:  660: */
        -:  661:ecma_value_t
    #####:  662:ecma_builtin_regexp_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  663:                                                ecma_value_t this_arg, /**< 'this' argument value */
        -:  664:                                                const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  665:                                                                                        *   passed to routine */
        -:  666:                                                uint32_t arguments_number) /**< length of arguments' list */
        -:  667:{
        -:  668:  JERRY_UNUSED (arguments_number);
        -:  669:
        -:  670:#if !JERRY_ESNEXT
    #####:  671:  bool require_regexp = builtin_routine_id <= ECMA_REGEXP_PROTOTYPE_ROUTINE_TO_STRING;
        -:  672:#else /* JERRY_ESNEXT */
    #####:  673:  bool require_regexp = builtin_routine_id < ECMA_REGEXP_PROTOTYPE_ROUTINE_TEST;
        -:  674:#endif /* JERRY_ESNEXT */
        -:  675:
    #####:  676:  ecma_object_t *obj_p = NULL;
        -:  677:
        -:  678:  /* 1. && 2. */
    #####:  679:  if (ecma_is_value_object (this_arg))
        -:  680:  {
    #####:  681:    obj_p = ecma_get_object_from_value (this_arg);
        -:  682:
    #####:  683:    if (require_regexp && !ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_REGEXP))
        -:  684:    {
    #####:  685:      obj_p = NULL;
        -:  686:    }
        -:  687:  }
        -:  688:
    #####:  689:  if (obj_p == NULL)
        -:  690:  {
    #####:  691:    return ecma_raise_type_error (ECMA_ERR_MSG ("Argument 'this' is not an object"));
        -:  692:  }
        -:  693:
    #####:  694:  switch (builtin_routine_id)
        -:  695:  {
        -:  696:#if JERRY_BUILTIN_ANNEXB
    #####:  697:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_COMPILE:
        -:  698:    {
    #####:  699:      return ecma_builtin_regexp_prototype_compile (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -:  700:    }
        -:  701:#endif /* JERRY_BUILTIN_ANNEXB */
    #####:  702:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_TEST:
        -:  703:    {
    #####:  704:      return ecma_builtin_regexp_prototype_test (this_arg, arguments_list_p[0]);
        -:  705:    }
    #####:  706:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_EXEC:
        -:  707:    {
    #####:  708:      return ecma_builtin_regexp_prototype_exec (this_arg, arguments_list_p[0]);
        -:  709:    }
    #####:  710:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_TO_STRING:
        -:  711:    {
    #####:  712:      return ecma_builtin_regexp_prototype_to_string (obj_p);
        -:  713:    }
        -:  714:#if JERRY_ESNEXT
    #####:  715:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_SEARCH:
        -:  716:    {
    #####:  717:      return ecma_regexp_search_helper (this_arg, arguments_list_p[0]);
        -:  718:    }
    #####:  719:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_MATCH:
        -:  720:    {
    #####:  721:      return ecma_regexp_match_helper (this_arg, arguments_list_p[0]);
        -:  722:    }
    #####:  723:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_MATCH_ALL:
        -:  724:    {
    #####:  725:      return ecma_builtin_regexp_prototype_match_all (obj_p, arguments_list_p[0]);
        -:  726:    }
    #####:  727:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_REPLACE:
        -:  728:    {
    #####:  729:      return ecma_regexp_replace_helper (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -:  730:    }
    #####:  731:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_SPLIT:
        -:  732:    {
    #####:  733:      return ecma_regexp_split_helper (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -:  734:    }
    #####:  735:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_FLAGS:
        -:  736:    {
    #####:  737:      return ecma_builtin_regexp_prototype_get_flags (obj_p);
        -:  738:    }
    #####:  739:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_SOURCE:
        -:  740:    {
    #####:  741:      if (!ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_REGEXP))
        -:  742:      {
    #####:  743:        if (obj_p == ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE))
        -:  744:        {
    #####:  745:          return ecma_make_magic_string_value (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP);
        -:  746:        }
        -:  747:
    #####:  748:        return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_an_regexp));
        -:  749:      }
        -:  750:
    #####:  751:      ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) obj_p;
    #####:  752:      return ecma_builtin_regexp_prototype_get_source (re_obj_p);
        -:  753:    }
    #####:  754:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_GLOBAL:
        -:  755:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_IGNORE_CASE:
        -:  756:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_MULTILINE:
        -:  757:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_STICKY:
        -:  758:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_UNICODE:
        -:  759:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_DOT_ALL:
        -:  760:    {
    #####:  761:      if (!ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_REGEXP))
        -:  762:      {
    #####:  763:        if (obj_p == ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE))
        -:  764:        {
    #####:  765:          return ECMA_VALUE_UNDEFINED;
        -:  766:        }
        -:  767:
    #####:  768:        return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_an_regexp));
        -:  769:      }
        -:  770:
    #####:  771:      ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) obj_p;
    #####:  772:      return ecma_builtin_regexp_prototype_flags_helper (re_obj_p, builtin_routine_id);
        -:  773:    }
        -:  774:#endif /* JERRY_ESNEXT */
    #####:  775:    default:
        -:  776:    {
    #####:  777:      JERRY_UNREACHABLE ();
        -:  778:    }
        -:  779:  }
        -:  780:} /* ecma_builtin_regexp_prototype_dispatch_routine */
        -:  781:/**
        -:  782: * @}
        -:  783: * @}
        -:  784: * @}
        -:  785: */
        -:  786:
        -:  787:#endif /* JERRY_BUILTIN_REGEXP */
