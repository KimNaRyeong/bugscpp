        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-external-pointers.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-globals.h"
        -:   19:#include "ecma-objects.h"
        -:   20:#include "ecma-objects-general.h"
        -:   21:#include "ecma-helpers.h"
        -:   22:
        -:   23:/** \addtogroup ecma ECMA
        -:   24: * @{
        -:   25: *
        -:   26: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   27: * @{
        -:   28: */
        -:   29:
        -:   30:/**
        -:   31: * Create a native pointer property to store the native pointer and its type info.
        -:   32: *
        -:   33: * @return true - if property was just created with specified value,
        -:   34: *         false - otherwise, if property existed before the call, it's value was updated
        -:   35: */
        -:   36:bool
    #####:   37:ecma_create_native_pointer_property (ecma_object_t *obj_p, /**< object to create property in */
        -:   38:                                     void *native_p, /**< native pointer */
        -:   39:                                     const jerry_object_native_info_t *native_info_p) /**< native type info */
        -:   40:{
    #####:   41:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER);
        -:   42:
    #####:   43:  if (native_info_p != NULL && native_info_p->number_of_references > 0)
        -:   44:  {
    #####:   45:    name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES);
        -:   46:  }
        -:   47:
    #####:   48:  if (ecma_op_object_is_fast_array (obj_p))
        -:   49:  {
    #####:   50:    ecma_fast_array_convert_to_normal (obj_p);
        -:   51:  }
        -:   52:
    #####:   53:  ecma_property_t *property_p = ecma_find_named_property (obj_p, name_p);
        -:   54:
    #####:   55:  bool is_new = (property_p == NULL);
        -:   56:
        -:   57:  ecma_native_pointer_t *native_pointer_p;
        -:   58:
    #####:   59:  if (property_p == NULL)
        -:   60:  {
    #####:   61:    native_pointer_p = (ecma_native_pointer_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_t));
        -:   62:
        -:   63:    ecma_property_value_t *value_p;
    #####:   64:    ECMA_CREATE_INTERNAL_PROPERTY (obj_p, name_p, property_p, value_p);
        -:   65:
    #####:   66:    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, native_pointer_p);
    #####:   67:    *property_p |= ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
        -:   68:  }
    #####:   69:  else if (*property_p & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL)
        -:   70:  {
    #####:   71:    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:   72:
    #####:   73:    native_pointer_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t, value_p->value);
        -:   74:
    #####:   75:    if (native_pointer_p->native_info_p == native_info_p)
        -:   76:    {
    #####:   77:      native_pointer_p->native_p = native_p;
    #####:   78:      return false;
        -:   79:    }
        -:   80:
    #####:   81:    value_p->value = JMEM_CP_NULL;
        -:   82:    (void) value_p->value; /* Make cppcheck happy. */
    #####:   83:    *property_p &= (ecma_property_t) ~ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
        -:   84:
        -:   85:    ecma_native_pointer_chain_t *item_p;
    #####:   86:    item_p = (ecma_native_pointer_chain_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_chain_t));
    #####:   87:    item_p->data = *native_pointer_p;
        -:   88:
    #####:   89:    jmem_heap_free_block (native_pointer_p, sizeof (ecma_native_pointer_t));
        -:   90:
    #####:   91:    item_p->next_p = (ecma_native_pointer_chain_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_chain_t));
    #####:   92:    item_p->next_p->next_p = NULL;
        -:   93:
    #####:   94:    native_pointer_p = &item_p->next_p->data;
    #####:   95:    ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, item_p);
        -:   96:  }
        -:   97:  else
        -:   98:  {
    #####:   99:    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  100:
    #####:  101:    if (value_p->value == JMEM_CP_NULL)
        -:  102:    {
    #####:  103:      native_pointer_p = (ecma_native_pointer_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_t));
    #####:  104:      ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, native_pointer_p);
        -:  105:
    #####:  106:      *property_p |= ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
        -:  107:    }
        -:  108:    else
        -:  109:    {
        -:  110:      ecma_native_pointer_chain_t *item_p;
    #####:  111:      item_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_chain_t, value_p->value);
        -:  112:
        -:  113:      /* There should be at least 2 native pointers in the chain */
    #####:  114:      JERRY_ASSERT (item_p != NULL && item_p->next_p != NULL);
        -:  115:
        -:  116:      while (true)
        -:  117:      {
    #####:  118:        if (item_p->data.native_info_p == native_info_p)
        -:  119:        {
        -:  120:          /* The native info already exists -> update the corresponding data */
    #####:  121:          item_p->data.native_p = native_p;
    #####:  122:          return false;
        -:  123:        }
        -:  124:
    #####:  125:        if (item_p->next_p == NULL)
        -:  126:        {
        -:  127:          /* The native info does not exist -> append a new element to the chain */
    #####:  128:          break;
        -:  129:        }
        -:  130:
    #####:  131:        item_p = item_p->next_p;
        -:  132:      }
        -:  133:
        -:  134:      ecma_native_pointer_chain_t *new_item_p;
        -:  135:
    #####:  136:      new_item_p = (ecma_native_pointer_chain_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_chain_t));
    #####:  137:      item_p->next_p = new_item_p;
    #####:  138:      new_item_p->next_p = NULL;
        -:  139:
    #####:  140:      native_pointer_p = &new_item_p->data;
        -:  141:    }
        -:  142:  }
        -:  143:
    #####:  144:  native_pointer_p->native_p = native_p;
    #####:  145:  native_pointer_p->native_info_p = (jerry_object_native_info_t *) native_info_p;
        -:  146:
    #####:  147:  return is_new;
        -:  148:} /* ecma_create_native_pointer_property */
        -:  149:
        -:  150:/**
        -:  151: * Get value of native package stored in the object's property with specified identifier
        -:  152: *
        -:  153: * Note:
        -:  154: *      property identifier should be one of the following:
        -:  155: *        - LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER
        -:  156: *
        -:  157: * @return native pointer data if property exists
        -:  158: *         NULL otherwise
        -:  159: */
        -:  160:ecma_native_pointer_t *
    #####:  161:ecma_get_native_pointer_value (ecma_object_t *obj_p, /**< object to get property value from */
        -:  162:                               const jerry_object_native_info_t *native_info_p) /**< native type info */
        -:  163:{
    #####:  164:  if (ecma_op_object_is_fast_array (obj_p))
        -:  165:  {
        -:  166:    /* Fast access mode array can not have native pointer properties */
    #####:  167:    return NULL;
        -:  168:  }
        -:  169:
    #####:  170:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER);
        -:  171:
    #####:  172:  if (native_info_p != NULL && native_info_p->number_of_references > 0)
        -:  173:  {
    #####:  174:    name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES);
        -:  175:  }
        -:  176:
    #####:  177:  ecma_property_t *property_p = ecma_find_named_property (obj_p, name_p);
        -:  178:
    #####:  179:  if (property_p == NULL)
        -:  180:  {
    #####:  181:    return NULL;
        -:  182:  }
        -:  183:
    #####:  184:  ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  185:
    #####:  186:  if (JERRY_LIKELY (*property_p & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL))
        -:  187:  {
    #####:  188:    ecma_native_pointer_t *native_pointer_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t,
        -:  189:                                                                               value_p->value);
        -:  190:
    #####:  191:    if (native_pointer_p->native_info_p == native_info_p)
        -:  192:    {
    #####:  193:      return native_pointer_p;
        -:  194:    }
        -:  195:
    #####:  196:    return NULL;
        -:  197:  }
        -:  198:
    #####:  199:  if (value_p->value == JMEM_CP_NULL)
        -:  200:  {
    #####:  201:    return NULL;
        -:  202:  }
        -:  203:
        -:  204:  ecma_native_pointer_chain_t *item_p;
    #####:  205:  item_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_chain_t, value_p->value);
        -:  206:
        -:  207:  /* There should be at least 2 native pointers in the chain */
    #####:  208:  JERRY_ASSERT (item_p != NULL && item_p->next_p != NULL);
        -:  209:
        -:  210:  do
        -:  211:  {
    #####:  212:    if (item_p->data.native_info_p == native_info_p)
        -:  213:    {
    #####:  214:      return &item_p->data;
        -:  215:    }
        -:  216:
    #####:  217:    item_p = item_p->next_p;
        -:  218:  }
    #####:  219:  while (item_p != NULL);
        -:  220:
    #####:  221:  return NULL;
        -:  222:} /* ecma_get_native_pointer_value */
        -:  223:
        -:  224:/**
        -:  225: * Delete the previously set native pointer by the native type info from the specified object.
        -:  226: *
        -:  227: * Note:
        -:  228: *      If the specified object has no matching native pointer for the given native type info
        -:  229: *      the function has no effect.
        -:  230: *
        -:  231: * @return true - if the native pointer has been deleted succesfully
        -:  232: *         false - otherwise
        -:  233: */
        -:  234:bool
    #####:  235:ecma_delete_native_pointer_property (ecma_object_t *obj_p, /**< object to delete property from */
        -:  236:                                     const jerry_object_native_info_t *native_info_p) /**< native type info */
        -:  237:{
    #####:  238:  if (ecma_op_object_is_fast_array (obj_p))
        -:  239:  {
        -:  240:    /* Fast access mode array can not have native pointer properties */
    #####:  241:    return false;
        -:  242:  }
        -:  243:
    #####:  244:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER);
        -:  245:
    #####:  246:  if (native_info_p != NULL && native_info_p->number_of_references > 0)
        -:  247:  {
    #####:  248:    name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES);
        -:  249:  }
        -:  250:
    #####:  251:  ecma_property_t *property_p = ecma_find_named_property (obj_p, name_p);
        -:  252:
    #####:  253:  if (property_p == NULL)
        -:  254:  {
    #####:  255:    return false;
        -:  256:  }
        -:  257:
    #####:  258:  ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  259:
    #####:  260:  if (JERRY_LIKELY (*property_p & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL))
        -:  261:  {
    #####:  262:    ecma_native_pointer_t *native_pointer_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t,
        -:  263:                                                                               value_p->value);
        -:  264:
    #####:  265:    if (native_pointer_p->native_info_p != native_info_p)
        -:  266:    {
    #####:  267:      return false;
        -:  268:    }
        -:  269:
    #####:  270:    value_p->value = JMEM_CP_NULL;
    #####:  271:    *property_p &= (ecma_property_t) ~ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
    #####:  272:    jmem_heap_free_block (native_pointer_p, sizeof (ecma_native_pointer_t));
    #####:  273:    return true;
        -:  274:  }
        -:  275:
    #####:  276:  if (value_p->value == JMEM_CP_NULL)
        -:  277:  {
    #####:  278:    return false;
        -:  279:  }
        -:  280:
        -:  281:  ecma_native_pointer_chain_t *first_p;
    #####:  282:  first_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_chain_t, value_p->value);
        -:  283:
        -:  284:  /* There should be at least 2 native pointers in the chain */
    #####:  285:  JERRY_ASSERT (first_p != NULL && first_p->next_p != NULL);
        -:  286:
    #####:  287:  ecma_native_pointer_chain_t *item_p = first_p;
    #####:  288:  ecma_native_pointer_chain_t *prev_p = NULL;
        -:  289:
        -:  290:  do
        -:  291:  {
    #####:  292:    if (item_p->data.native_info_p == native_info_p)
        -:  293:    {
    #####:  294:      if (prev_p == NULL)
        -:  295:      {
        -:  296:        /* The first element is deleted from the chain: change the property value. */
    #####:  297:        first_p = item_p->next_p;
    #####:  298:        ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, first_p);
        -:  299:      }
        -:  300:      else
        -:  301:      {
        -:  302:        /* A non-first element is deleted from the chain: update the previous pointer. */
    #####:  303:        prev_p->next_p = item_p->next_p;
        -:  304:      }
        -:  305:
    #####:  306:      jmem_heap_free_block (item_p, sizeof (ecma_native_pointer_chain_t));
        -:  307:
    #####:  308:      if (first_p->next_p != NULL)
        -:  309:      {
    #####:  310:        return true;
        -:  311:      }
        -:  312:
        -:  313:      /* Only one item remained. The ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL flag is
        -:  314:       * set early to avoid using the chain if the allocation below triggers a GC. */
    #####:  315:      *property_p |= ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL;
        -:  316:
        -:  317:      ecma_native_pointer_t *native_pointer_p;
    #####:  318:      native_pointer_p = (ecma_native_pointer_t *) jmem_heap_alloc_block (sizeof (ecma_native_pointer_t));
    #####:  319:      *native_pointer_p = first_p->data;
        -:  320:
    #####:  321:      ECMA_SET_INTERNAL_VALUE_POINTER (value_p->value, native_pointer_p);
        -:  322:
    #####:  323:      jmem_heap_free_block (first_p, sizeof (ecma_native_pointer_chain_t));
    #####:  324:      return true;
        -:  325:    }
        -:  326:
    #####:  327:    prev_p = item_p;
    #####:  328:    item_p = item_p->next_p;
        -:  329:  }
    #####:  330:  while (item_p != NULL);
        -:  331:
    #####:  332:  return false;
        -:  333:} /* ecma_delete_native_pointer_property */
        -:  334:
        -:  335:/**
        -:  336: * @}
        -:  337: * @}
        -:  338: */
