        -:    0:Source:/home/workspace/md4c/md4c.c
        -:    0:Programs:5
        -:    1:/*
        -:    2: * MD4C: Markdown parser for C
        -:    3: * (http://github.com/mity/md4c)
        -:    4: *
        -:    5: * Copyright (c) 2016-2017 Martin Mitas
        -:    6: *
        -:    7: * Permission is hereby granted, free of charge, to any person obtaining a
        -:    8: * copy of this software and associated documentation files (the "Software"),
        -:    9: * to deal in the Software without restriction, including without limitation
        -:   10: * the rights to use, copy, modify, merge, publish, distribute, sublicense,
        -:   11: * and/or sell copies of the Software, and to permit persons to whom the
        -:   12: * Software is furnished to do so, subject to the following conditions:
        -:   13: *
        -:   14: * The above copyright notice and this permission notice shall be included in
        -:   15: * all copies or substantial portions of the Software.
        -:   16: *
        -:   17: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        -:   18: * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   19: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   20: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   21: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        -:   22: * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
        -:   23: * IN THE SOFTWARE.
        -:   24: */
        -:   25:
        -:   26:#include "md4c.h"
        -:   27:
        -:   28:#include <stdio.h>
        -:   29:#include <stdlib.h>
        -:   30:#include <string.h>
        -:   31:
        -:   32:
        -:   33:/*****************************
        -:   34: ***  Miscellaneous Stuff  ***
        -:   35: *****************************/
        -:   36:
        -:   37:#ifdef _MSC_VER
        -:   38:    /* MSVC does not understand "inline" when building as pure C (not C++).
        -:   39:     * However it understands "__inline" */
        -:   40:    #ifndef __cplusplus
        -:   41:        #define inline __inline
        -:   42:    #endif
        -:   43:#endif
        -:   44:
        -:   45:#ifdef _T
        -:   46:    #undef _T
        -:   47:#endif
        -:   48:#if defined MD4C_USE_UTF16
        -:   49:    #define _T(x)           L##x
        -:   50:#else
        -:   51:    #define _T(x)           x
        -:   52:#endif
        -:   53:
        -:   54:/* Misc. macros. */
        -:   55:#define SIZEOF_ARRAY(a)     (sizeof(a) / sizeof(a[0]))
        -:   56:
        -:   57:#define STRINGIZE_(x)       #x
        -:   58:#define STRINGIZE(x)        STRINGIZE_(x)
        -:   59:
        -:   60:#ifndef TRUE
        -:   61:    #define TRUE            1
        -:   62:    #define FALSE           0
        -:   63:#endif
        -:   64:
        -:   65:
        -:   66:/************************
        -:   67: ***  Internal Types  ***
        -:   68: ************************/
        -:   69:
        -:   70:/* These are omnipresent so lets save some typing. */
        -:   71:#define CHAR    MD_CHAR
        -:   72:#define SZ      MD_SIZE
        -:   73:#define OFF     MD_OFFSET
        -:   74:
        -:   75:typedef struct MD_MARK_tag MD_MARK;
        -:   76:typedef struct MD_BLOCK_tag MD_BLOCK;
        -:   77:typedef struct MD_CONTAINER_tag MD_CONTAINER;
        -:   78:typedef struct MD_REF_DEF_tag MD_REF_DEF;
        -:   79:
        -:   80:
        -:   81:/* During analyzes of inline marks, we need to manage some "mark chains",
        -:   82: * of (yet unresolved) openers. This structure holds start/end of the chain.
        -:   83: * The chain internals are then realized through MD_MARK::prev and ::next.
        -:   84: */
        -:   85:typedef struct MD_MARKCHAIN_tag MD_MARKCHAIN;
        -:   86:struct MD_MARKCHAIN_tag {
        -:   87:    int head;   /* Index of first mark in the chain, or -1 if empty. */
        -:   88:    int tail;   /* Index of last mark in the chain, or -1 if empty. */
        -:   89:};
        -:   90:
        -:   91:/* Context propagated through all the parsing. */
        -:   92:typedef struct MD_CTX_tag MD_CTX;
        -:   93:struct MD_CTX_tag {
        -:   94:    /* Immutable stuff (parameters of md_parse()). */
        -:   95:    const CHAR* text;
        -:   96:    SZ size;
        -:   97:    MD_RENDERER r;
        -:   98:    void* userdata;
        -:   99:
        -:  100:    /* Helper temporary growing buffer. */
        -:  101:    CHAR* buffer;
        -:  102:    unsigned alloc_buffer;
        -:  103:
        -:  104:    /* Reference definitions. */
        -:  105:    MD_REF_DEF* ref_defs;
        -:  106:    int n_ref_defs;
        -:  107:    int alloc_ref_defs;
        -:  108:    void** ref_def_hashtable;
        -:  109:    int ref_def_hashtable_size;
        -:  110:
        -:  111:    /* Stack of inline/span markers.
        -:  112:     * This is only used for parsing a single block contents but by storing it
        -:  113:     * here we may reuse the stack for subsequent blocks; i.e. we have fewer
        -:  114:     * (re)allocations. */
        -:  115:    MD_MARK* marks;
        -:  116:    int n_marks;
        -:  117:    int alloc_marks;
        -:  118:
        -:  119:#if defined MD4C_USE_UTF16
        -:  120:    char mark_char_map[128];
        -:  121:#else
        -:  122:    char mark_char_map[256];
        -:  123:#endif
        -:  124:
        -:  125:    /* For resolving of inline spans. */
        -:  126:    MD_MARKCHAIN mark_chains[8];
        -:  127:#define PTR_CHAIN               ctx->mark_chains[0]
        -:  128:#define BACKTICK_OPENERS        ctx->mark_chains[1]
        -:  129:#define LOWERTHEN_OPENERS       ctx->mark_chains[2]
        -:  130:#define ASTERISK_OPENERS        ctx->mark_chains[3]
        -:  131:#define UNDERSCORE_OPENERS      ctx->mark_chains[4]
        -:  132:#define TILDE_OPENERS           ctx->mark_chains[5]
        -:  133:#define BRACKET_OPENERS         ctx->mark_chains[6]
        -:  134:#define TABLECELLBOUNDARIES     ctx->mark_chains[7]
        -:  135:
        -:  136:    int n_table_cell_boundaries;
        -:  137:
        -:  138:    /* For resolving links. */
        -:  139:    int unresolved_link_head;
        -:  140:    int unresolved_link_tail;
        -:  141:
        -:  142:    /* For block analysis.
        -:  143:     * Notes:
        -:  144:     *   -- It holds MD_BLOCK as well as MD_LINE structures. After each
        -:  145:     *      MD_BLOCK, its (multiple) MD_LINE(s) follow.
        -:  146:     *   -- For MD_BLOCK_HTML and MD_BLOCK_CODE, MD_VERBATIMLINE(s) are used
        -:  147:     *      instead of MD_LINE(s).
        -:  148:     */
        -:  149:    void* block_bytes;
        -:  150:    MD_BLOCK* current_block;
        -:  151:    int n_block_bytes;
        -:  152:    int alloc_block_bytes;
        -:  153:
        -:  154:    /* For container block analysis. */
        -:  155:    MD_CONTAINER* containers;
        -:  156:    int n_containers;
        -:  157:    int alloc_containers;
        -:  158:
        -:  159:    int last_line_has_list_loosening_effect;
        -:  160:    int last_list_item_starts_with_two_blank_lines;
        -:  161:
        -:  162:    /* Minimal indentation to call the block "indented code block". */
        -:  163:    unsigned code_indent_offset;
        -:  164:
        -:  165:    /* Contextual info for line analysis. */
        -:  166:    SZ code_fence_length;   /* For checking closing fence length. */
        -:  167:    int html_block_type;    /* For checking closing raw HTML condition. */
        -:  168:};
        -:  169:
        -:  170:typedef enum MD_LINETYPE_tag MD_LINETYPE;
        -:  171:enum MD_LINETYPE_tag {
        -:  172:    MD_LINE_BLANK,
        -:  173:    MD_LINE_HR,
        -:  174:    MD_LINE_ATXHEADER,
        -:  175:    MD_LINE_SETEXTHEADER,
        -:  176:    MD_LINE_SETEXTUNDERLINE,
        -:  177:    MD_LINE_INDENTEDCODE,
        -:  178:    MD_LINE_FENCEDCODE,
        -:  179:    MD_LINE_HTML,
        -:  180:    MD_LINE_TEXT,
        -:  181:    MD_LINE_TABLE,
        -:  182:    MD_LINE_TABLEUNDERLINE
        -:  183:};
        -:  184:
        -:  185:typedef struct MD_LINE_ANALYSIS_tag MD_LINE_ANALYSIS;
        -:  186:struct MD_LINE_ANALYSIS_tag {
        -:  187:    MD_LINETYPE type    : 16;
        -:  188:    unsigned data       : 16;
        -:  189:    OFF beg;
        -:  190:    OFF end;
        -:  191:    unsigned indent;        /* Indentation level. */
        -:  192:};
        -:  193:
        -:  194:typedef struct MD_LINE_tag MD_LINE;
        -:  195:struct MD_LINE_tag {
        -:  196:    OFF beg;
        -:  197:    OFF end;
        -:  198:};
        -:  199:
        -:  200:typedef struct MD_VERBATIMLINE_tag MD_VERBATIMLINE;
        -:  201:struct MD_VERBATIMLINE_tag {
        -:  202:    OFF beg;
        -:  203:    OFF end;
        -:  204:    OFF indent;
        -:  205:};
        -:  206:
        -:  207:
        -:  208:/*******************
        -:  209: ***  Debugging  ***
        -:  210: *******************/
        -:  211:
        -:  212:#define MD_LOG(msg)                                                     \
        -:  213:    do {                                                                \
        -:  214:        if(ctx->r.debug_log != NULL)                                    \
        -:  215:            ctx->r.debug_log((msg), ctx->userdata);                     \
        -:  216:    } while(0)
        -:  217:
        -:  218:#ifdef DEBUG
        -:  219:    #define MD_ASSERT(cond)                                             \
        -:  220:            do {                                                        \
        -:  221:                if(!(cond)) {                                           \
        -:  222:                    MD_LOG(__FILE__ ":" STRINGIZE(__LINE__) ": "        \
        -:  223:                           "Assertion '" STRINGIZE(cond) "' failed.");  \
        -:  224:                    exit(1);                                            \
        -:  225:                }                                                       \
        -:  226:            } while(0)
        -:  227:
        -:  228:    #define MD_UNREACHABLE()        MD_ASSERT(1 == 0)
        -:  229:#else
        -:  230:    #ifdef __GNUC__
        -:  231:        #define MD_ASSERT(cond)     do { if(!(cond)) __builtin_unreachable(); } while(0)
        -:  232:        #define MD_UNREACHABLE()    do { __builtin_unreachable(); } while(0)
        -:  233:    #elif defined _MSC_VER  &&  _MSC_VER > 120
        -:  234:        #define MD_ASSERT(cond)     do { __assume(cond); } while(0)
        -:  235:        #define MD_UNREACHABLE()    do { __assume(0); } while(0)
        -:  236:    #else
        -:  237:        #define MD_ASSERT(cond)     do {} while(0)
        -:  238:        #define MD_UNREACHABLE()    do {} while(0)
        -:  239:    #endif
        -:  240:#endif
        -:  241:
        -:  242:
        -:  243:/*****************
        -:  244: ***  Helpers  ***
        -:  245: *****************/
        -:  246:
        -:  247:/* Character accessors. */
        -:  248:#define CH(off)                 (ctx->text[(off)])
        -:  249:#define STR(off)                (ctx->text + (off))
        -:  250:
        -:  251:/* Character classification.
        -:  252: * Note we assume ASCII compatibility of code points < 128 here. */
        -:  253:#define ISIN_(ch, ch_min, ch_max)       ((ch_min) <= (unsigned)(ch) && (unsigned)(ch) <= (ch_max))
        -:  254:#define ISANYOF_(ch, palette)           (md_strchr((palette), (ch)) != NULL)
        -:  255:#define ISANYOF2_(ch, ch1, ch2)         ((ch) == (ch1) || (ch) == (ch2))
        -:  256:#define ISANYOF3_(ch, ch1, ch2, ch3)    ((ch) == (ch1) || (ch) == (ch2) || (ch) == (ch3))
        -:  257:#define ISASCII_(ch)                    ((unsigned)(ch) <= 127)
        -:  258:#define ISBLANK_(ch)                    (ISANYOF2_((ch), _T(' '), _T('\t')))
        -:  259:#define ISNEWLINE_(ch)                  (ISANYOF2_((ch), _T('\r'), _T('\n')))
        -:  260:#define ISWHITESPACE_(ch)               (ISBLANK_(ch) || ISANYOF2_((ch), _T('\v'), _T('\f')))
        -:  261:#define ISCNTRL_(ch)                    ((unsigned)(ch) <= 31 || (unsigned)(ch) == 127)
        -:  262:#define ISPUNCT_(ch)                    (ISIN_(ch, 33, 47) || ISIN_(ch, 58, 64) || ISIN_(ch, 91, 96) || ISIN_(ch, 123, 126))
        -:  263:#define ISUPPER_(ch)                    (ISIN_(ch, _T('A'), _T('Z')))
        -:  264:#define ISLOWER_(ch)                    (ISIN_(ch, _T('a'), _T('z')))
        -:  265:#define ISALPHA_(ch)                    (ISUPPER_(ch) || ISLOWER_(ch))
        -:  266:#define ISDIGIT_(ch)                    (ISIN_(ch, _T('0'), _T('9')))
        -:  267:#define ISXDIGIT_(ch)                   (ISDIGIT_(ch) || ISIN_(ch, _T('A'), _T('F')) || ISIN_(ch, _T('a'), _T('f')))
        -:  268:#define ISALNUM_(ch)                    (ISALPHA_(ch) || ISDIGIT_(ch))
        -:  269:
        -:  270:#define ISANYOF(off, palette)           ISANYOF_(CH(off), (palette))
        -:  271:#define ISANYOF2(off, ch1, ch2)         ISANYOF2_(CH(off), (ch1), (ch2))
        -:  272:#define ISANYOF3(off, ch1, ch2, ch3)    ISANYOF3_(CH(off), (ch1), (ch2), (ch3))
        -:  273:#define ISASCII(off)                    ISASCII_(CH(off))
        -:  274:#define ISBLANK(off)                    ISBLANK_(CH(off))
        -:  275:#define ISNEWLINE(off)                  ISNEWLINE_(CH(off))
        -:  276:#define ISWHITESPACE(off)               ISWHITESPACE_(CH(off))
        -:  277:#define ISCNTRL(off)                    ISCNTRL_(CH(off))
        -:  278:#define ISPUNCT(off)                    ISPUNCT_(CH(off))
        -:  279:#define ISUPPER(off)                    ISUPPER_(CH(off))
        -:  280:#define ISLOWER(off)                    ISLOWER_(CH(off))
        -:  281:#define ISALPHA(off)                    ISALPHA_(CH(off))
        -:  282:#define ISDIGIT(off)                    ISDIGIT_(CH(off))
        -:  283:#define ISXDIGIT(off)                   ISXDIGIT_(CH(off))
        -:  284:#define ISALNUM(off)                    ISALNUM_(CH(off))
        -:  285:static inline const CHAR*
        -:  286:md_strchr(const CHAR* str, CHAR ch)
        -:  287:{
        -:  288:    OFF i;
       93:  289:    for(i = 0; str[i] != _T('\0'); i++) {
       76:  290:        if(ch == str[i])
        -:  291:            return (str + i);
        -:  292:    }
        -:  293:    return NULL;
        -:  294:}
        -:  295:
        -:  296:/* Case insensitive check of string equality. */
        -:  297:static inline int
        -:  298:md_ascii_case_eq(const CHAR* s1, const CHAR* s2, SZ n)
        -:  299:{
        -:  300:    OFF i;
    #####:  301:    for(i = 0; i < n; i++) {
    #####:  302:        CHAR ch1 = s1[i];
    #####:  303:        CHAR ch2 = s2[i];
        -:  304:
    #####:  305:        if(ISLOWER_(ch1))
    #####:  306:            ch1 += ('A'-'a');
    #####:  307:        if(ISLOWER_(ch2))
    #####:  308:            ch2 += ('A'-'a');
    #####:  309:        if(ch1 != ch2)
        -:  310:            return FALSE;
        -:  311:    }
        -:  312:    return TRUE;
        -:  313:}
        -:  314:
        -:  315:static inline int
        -:  316:md_ascii_eq(const CHAR* s1, const CHAR* s2, SZ n)
        -:  317:{
    #####:  318:    return memcmp(s1, s2, n * sizeof(CHAR)) == 0;
        -:  319:}
        -:  320:
        -:  321:static int
    #####:  322:md_text_with_null_replacement(MD_CTX* ctx, MD_TEXTTYPE type, const CHAR* str, SZ size)
        -:  323:{
    #####:  324:    OFF off = 0;
    #####:  325:    int ret = 0;
        -:  326:
        -:  327:    while(1) {
    #####:  328:        while(off < size  &&  str[off] != _T('\0'))
    #####:  329:            off++;
        -:  330:
    #####:  331:        if(off > 0) {
    #####:  332:            ret = ctx->r.text(type, str, off, ctx->userdata);
    #####:  333:            if(ret != 0)
        -:  334:                return ret;
        -:  335:
    #####:  336:            str += off;
    #####:  337:            size -= off;
    #####:  338:            off = 0;
        -:  339:        }
        -:  340:
    #####:  341:        if(off >= size)
        -:  342:            return 0;
        -:  343:
    #####:  344:        ret = ctx->r.text(MD_TEXT_NULLCHAR, _T(""), 1, ctx->userdata);
    #####:  345:        if(ret != 0)
        -:  346:            return ret;
    #####:  347:        off++;
        -:  348:    }
        -:  349:}
        -:  350:
        -:  351:
        -:  352:#define MD_CHECK(func)                                                  \
        -:  353:    do {                                                                \
        -:  354:        ret = (func);                                                   \
        -:  355:        if(ret < 0)                                                     \
        -:  356:            goto abort;                                                 \
        -:  357:    } while(0)
        -:  358:
        -:  359:
        -:  360:#define MD_TEMP_BUFFER(sz)                                              \
        -:  361:    do {                                                                \
        -:  362:        if(sz > ctx->alloc_buffer) {                                    \
        -:  363:            CHAR* new_buffer;                                           \
        -:  364:            SZ new_size = ((sz) + (sz) / 2 + 128) & ~127;               \
        -:  365:                                                                        \
        -:  366:            new_buffer = realloc(ctx->buffer, new_size);                \
        -:  367:            if(new_buffer == NULL) {                                    \
        -:  368:                MD_LOG("realloc() failed.");                            \
        -:  369:                ret = -1;                                               \
        -:  370:                goto abort;                                             \
        -:  371:            }                                                           \
        -:  372:                                                                        \
        -:  373:            ctx->buffer = new_buffer;                                   \
        -:  374:            ctx->alloc_buffer = new_size;                               \
        -:  375:        }                                                               \
        -:  376:    } while(0)
        -:  377:
        -:  378:
        -:  379:#define MD_ENTER_BLOCK(type, arg)                                       \
        -:  380:    do {                                                                \
        -:  381:        ret = ctx->r.enter_block((type), (arg), ctx->userdata);         \
        -:  382:        if(ret != 0) {                                                  \
        -:  383:            MD_LOG("Aborted from enter_block() callback.");             \
        -:  384:            goto abort;                                                 \
        -:  385:        }                                                               \
        -:  386:    } while(0)
        -:  387:
        -:  388:#define MD_LEAVE_BLOCK(type, arg)                                       \
        -:  389:    do {                                                                \
        -:  390:        ret = ctx->r.leave_block((type), (arg), ctx->userdata);         \
        -:  391:        if(ret != 0) {                                                  \
        -:  392:            MD_LOG("Aborted from leave_block() callback.");             \
        -:  393:            goto abort;                                                 \
        -:  394:        }                                                               \
        -:  395:    } while(0)
        -:  396:
        -:  397:#define MD_ENTER_SPAN(type, arg)                                        \
        -:  398:    do {                                                                \
        -:  399:        ret = ctx->r.enter_span((type), (arg), ctx->userdata);          \
        -:  400:        if(ret != 0) {                                                  \
        -:  401:            MD_LOG("Aborted from enter_span() callback.");              \
        -:  402:            goto abort;                                                 \
        -:  403:        }                                                               \
        -:  404:    } while(0)
        -:  405:
        -:  406:#define MD_LEAVE_SPAN(type, arg)                                        \
        -:  407:    do {                                                                \
        -:  408:        ret = ctx->r.leave_span((type), (arg), ctx->userdata);          \
        -:  409:        if(ret != 0) {                                                  \
        -:  410:            MD_LOG("Aborted from leave_span() callback.");              \
        -:  411:            goto abort;                                                 \
        -:  412:        }                                                               \
        -:  413:    } while(0)
        -:  414:
        -:  415:#define MD_TEXT(type, str, size)                                        \
        -:  416:    do {                                                                \
        -:  417:        if(size > 0) {                                                  \
        -:  418:            ret = ctx->r.text((type), (str), (size), ctx->userdata);    \
        -:  419:            if(ret != 0) {                                              \
        -:  420:                MD_LOG("Aborted from text() callback.");                \
        -:  421:                goto abort;                                             \
        -:  422:            }                                                           \
        -:  423:        }                                                               \
        -:  424:    } while(0)
        -:  425:
        -:  426:#define MD_TEXT_INSECURE(type, str, size)                               \
        -:  427:    do {                                                                \
        -:  428:        if(size > 0) {                                                  \
        -:  429:            ret = md_text_with_null_replacement(ctx, type, str, size);  \
        -:  430:            if(ret != 0) {                                              \
        -:  431:                MD_LOG("Aborted from text() callback.");                \
        -:  432:                goto abort;                                             \
        -:  433:            }                                                           \
        -:  434:        }                                                               \
        -:  435:    } while(0)
        -:  436:
        -:  437:
        -:  438:
        -:  439:/*************************
        -:  440: ***  Unicode Support  ***
        -:  441: *************************/
        -:  442:
        -:  443:typedef struct MD_UNICODE_FOLD_INFO_tag MD_UNICODE_FOLD_INFO;
        -:  444:struct MD_UNICODE_FOLD_INFO_tag {
        -:  445:    int codepoints[3];
        -:  446:    int n_codepoints;
        -:  447:};
        -:  448:
        -:  449:
        -:  450:#if defined MD4C_USE_UTF16 || defined MD4C_USE_UTF8
        -:  451:    static int
        6:  452:    md_is_unicode_whitespace__(int codepoint)
        -:  453:    {
        -:  454:        /* The ASCII ones are the most frequently used ones, so lets check them first. */
        6:  455:        if(codepoint <= 0x7f)
        6:  456:            return ISWHITESPACE_(codepoint);
        -:  457:
        -:  458:        /* Check for Unicode codepoints in Zs class above 127. */
    #####:  459:        if(codepoint == 0x00a0 || codepoint == 0x1680)
        -:  460:            return TRUE;
    #####:  461:        if(0x2000 <= codepoint && codepoint <= 0x200a)
        -:  462:            return TRUE;
    #####:  463:        if(codepoint == 0x202f || codepoint == 0x205f || codepoint == 0x3000)
        -:  464:            return TRUE;
        -:  465:
    #####:  466:        return FALSE;
        -:  467:    }
        -:  468:
        -:  469:    static int
        -:  470:    md_unicode_cmp__(const void* p_codepoint_a, const void* p_codepoint_b)
        -:  471:    {
    #####:  472:        return (*(const int*)p_codepoint_a - *(const int*)p_codepoint_b);
        -:  473:    }
        -:  474:
        -:  475:    static int
        4:  476:    md_is_unicode_punct__(int codepoint)
        -:  477:    {
        -:  478:        /* non-ASCII (above 127) Unicode punctuation codepoints (classes
        -:  479:         * Pc, Pd, Pe, Pf, Pi, Po, Ps).
        -:  480:         *
        -:  481:         * Warning: Keep the array sorted.
        -:  482:         */
        -:  483:        static const int punct_list[] = {
        -:  484:            0x00a1, 0x00a7, 0x00ab, 0x00b6, 0x00b7, 0x00bb, 0x00bf, 0x037e, 0x0387, 0x055a, 0x055b, 0x055c, 0x055d, 0x055e, 0x055f, 0x0589,
        -:  485:            0x058a, 0x05be, 0x05c0, 0x05c3, 0x05c6, 0x05f3, 0x05f4, 0x0609, 0x060a, 0x060c, 0x060d, 0x061b, 0x061e, 0x061f, 0x066a, 0x066b,
        -:  486:            0x066c, 0x066d, 0x06d4, 0x0700, 0x0701, 0x0702, 0x0703, 0x0704, 0x0705, 0x0706, 0x0707, 0x0708, 0x0709, 0x070a, 0x070b, 0x070c,
        -:  487:            0x070d, 0x07f7, 0x07f8, 0x07f9, 0x0830, 0x0831, 0x0832, 0x0833, 0x0834, 0x0835, 0x0836, 0x0837, 0x0838, 0x0839, 0x083a, 0x083b,
        -:  488:            0x083c, 0x083d, 0x083e, 0x085e, 0x0964, 0x0965, 0x0970, 0x0af0, 0x0df4, 0x0e4f, 0x0e5a, 0x0e5b, 0x0f04, 0x0f05, 0x0f06, 0x0f07,
        -:  489:            0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e, 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f14, 0x0f3a, 0x0f3b, 0x0f3c, 0x0f3d,
        -:  490:            0x0f85, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4, 0x0fd9, 0x0fda, 0x104a, 0x104b, 0x104c, 0x104d, 0x104e, 0x104f, 0x10fb, 0x1360,
        -:  491:            0x1361, 0x1362, 0x1363, 0x1364, 0x1365, 0x1366, 0x1367, 0x1368, 0x1400, 0x166d, 0x166e, 0x169b, 0x169c, 0x16eb, 0x16ec, 0x16ed,
        -:  492:            0x1735, 0x1736, 0x17d4, 0x17d5, 0x17d6, 0x17d8, 0x17d9, 0x17da, 0x1800, 0x1801, 0x1802, 0x1803, 0x1804, 0x1805, 0x1806, 0x1807,
        -:  493:            0x1808, 0x1809, 0x180a, 0x1944, 0x1945, 0x1a1e, 0x1a1f, 0x1aa0, 0x1aa1, 0x1aa2, 0x1aa3, 0x1aa4, 0x1aa5, 0x1aa6, 0x1aa8, 0x1aa9,
        -:  494:            0x1aaa, 0x1aab, 0x1aac, 0x1aad, 0x1b5a, 0x1b5b, 0x1b5c, 0x1b5d, 0x1b5e, 0x1b5f, 0x1b60, 0x1bfc, 0x1bfd, 0x1bfe, 0x1bff, 0x1c3b,
        -:  495:            0x1c3c, 0x1c3d, 0x1c3e, 0x1c3f, 0x1c7e, 0x1c7f, 0x1cc0, 0x1cc1, 0x1cc2, 0x1cc3, 0x1cc4, 0x1cc5, 0x1cc6, 0x1cc7, 0x1cd3, 0x2010,
        -:  496:            0x2011, 0x2012, 0x2013, 0x2014, 0x2015, 0x2016, 0x2017, 0x2018, 0x2019, 0x201a, 0x201b, 0x201c, 0x201d, 0x201e, 0x201f, 0x2020,
        -:  497:            0x2021, 0x2022, 0x2023, 0x2024, 0x2025, 0x2026, 0x2027, 0x2030, 0x2031, 0x2032, 0x2033, 0x2034, 0x2035, 0x2036, 0x2037, 0x2038,
        -:  498:            0x2039, 0x203a, 0x203b, 0x203c, 0x203d, 0x203e, 0x203f, 0x2040, 0x2041, 0x2042, 0x2043, 0x2045, 0x2046, 0x2047, 0x2048, 0x2049,
        -:  499:            0x204a, 0x204b, 0x204c, 0x204d, 0x204e, 0x204f, 0x2050, 0x2051, 0x2053, 0x2054, 0x2055, 0x2056, 0x2057, 0x2058, 0x2059, 0x205a,
        -:  500:            0x205b, 0x205c, 0x205d, 0x205e, 0x207d, 0x207e, 0x208d, 0x208e, 0x2308, 0x2309, 0x230a, 0x230b, 0x2329, 0x232a, 0x2768, 0x2769,
        -:  501:            0x276a, 0x276b, 0x276c, 0x276d, 0x276e, 0x276f, 0x2770, 0x2771, 0x2772, 0x2773, 0x2774, 0x2775, 0x27c5, 0x27c6, 0x27e6, 0x27e7,
        -:  502:            0x27e8, 0x27e9, 0x27ea, 0x27eb, 0x27ec, 0x27ed, 0x27ee, 0x27ef, 0x2983, 0x2984, 0x2985, 0x2986, 0x2987, 0x2988, 0x2989, 0x298a,
        -:  503:            0x298b, 0x298c, 0x298d, 0x298e, 0x298f, 0x2990, 0x2991, 0x2992, 0x2993, 0x2994, 0x2995, 0x2996, 0x2997, 0x2998, 0x29d8, 0x29d9,
        -:  504:            0x29da, 0x29db, 0x29fc, 0x29fd, 0x2cf9, 0x2cfa, 0x2cfb, 0x2cfc, 0x2cfe, 0x2cff, 0x2d70, 0x2e00, 0x2e01, 0x2e02, 0x2e03, 0x2e04,
        -:  505:            0x2e05, 0x2e06, 0x2e07, 0x2e08, 0x2e09, 0x2e0a, 0x2e0b, 0x2e0c, 0x2e0d, 0x2e0e, 0x2e0f, 0x2e10, 0x2e11, 0x2e12, 0x2e13, 0x2e14,
        -:  506:            0x2e15, 0x2e16, 0x2e17, 0x2e18, 0x2e19, 0x2e1a, 0x2e1b, 0x2e1c, 0x2e1d, 0x2e1e, 0x2e1f, 0x2e20, 0x2e21, 0x2e22, 0x2e23, 0x2e24,
        -:  507:            0x2e25, 0x2e26, 0x2e27, 0x2e28, 0x2e29, 0x2e2a, 0x2e2b, 0x2e2c, 0x2e2d, 0x2e2e, 0x2e30, 0x2e31, 0x2e32, 0x2e33, 0x2e34, 0x2e35,
        -:  508:            0x2e36, 0x2e37, 0x2e38, 0x2e39, 0x2e3a, 0x2e3b, 0x2e3c, 0x2e3d, 0x2e3e, 0x2e3f, 0x2e40, 0x2e41, 0x2e42, 0x2e43, 0x2e44, 0x3001,
        -:  509:            0x3002, 0x3003, 0x3008, 0x3009, 0x300a, 0x300b, 0x300c, 0x300d, 0x300e, 0x300f, 0x3010, 0x3011, 0x3014, 0x3015, 0x3016, 0x3017,
        -:  510:            0x3018, 0x3019, 0x301a, 0x301b, 0x301c, 0x301d, 0x301e, 0x301f, 0x3030, 0x303d, 0x30a0, 0x30fb, 0xa4fe, 0xa4ff, 0xa60d, 0xa60e,
        -:  511:            0xa60f, 0xa673, 0xa67e, 0xa6f2, 0xa6f3, 0xa6f4, 0xa6f5, 0xa6f6, 0xa6f7, 0xa874, 0xa875, 0xa876, 0xa877, 0xa8ce, 0xa8cf, 0xa8f8,
        -:  512:            0xa8f9, 0xa8fa, 0xa8fc, 0xa92e, 0xa92f, 0xa95f, 0xa9c1, 0xa9c2, 0xa9c3, 0xa9c4, 0xa9c5, 0xa9c6, 0xa9c7, 0xa9c8, 0xa9c9, 0xa9ca,
        -:  513:            0xa9cb, 0xa9cc, 0xa9cd, 0xa9de, 0xa9df, 0xaa5c, 0xaa5d, 0xaa5e, 0xaa5f, 0xaade, 0xaadf, 0xaaf0, 0xaaf1, 0xabeb, 0xfd3e, 0xfd3f,
        -:  514:            0xfe10, 0xfe11, 0xfe12, 0xfe13, 0xfe14, 0xfe15, 0xfe16, 0xfe17, 0xfe18, 0xfe19, 0xfe30, 0xfe31, 0xfe32, 0xfe33, 0xfe34, 0xfe35,
        -:  515:            0xfe36, 0xfe37, 0xfe38, 0xfe39, 0xfe3a, 0xfe3b, 0xfe3c, 0xfe3d, 0xfe3e, 0xfe3f, 0xfe40, 0xfe41, 0xfe42, 0xfe43, 0xfe44, 0xfe45,
        -:  516:            0xfe46, 0xfe47, 0xfe48, 0xfe49, 0xfe4a, 0xfe4b, 0xfe4c, 0xfe4d, 0xfe4e, 0xfe4f, 0xfe50, 0xfe51, 0xfe52, 0xfe54, 0xfe55, 0xfe56,
        -:  517:            0xfe57, 0xfe58, 0xfe59, 0xfe5a, 0xfe5b, 0xfe5c, 0xfe5d, 0xfe5e, 0xfe5f, 0xfe60, 0xfe61, 0xfe63, 0xfe68, 0xfe6a, 0xfe6b, 0xff01,
        -:  518:            0xff02, 0xff03, 0xff05, 0xff06, 0xff07, 0xff08, 0xff09, 0xff0a, 0xff0c, 0xff0d, 0xff0e, 0xff0f, 0xff1a, 0xff1b, 0xff1f, 0xff20,
        -:  519:            0xff3b, 0xff3c, 0xff3d, 0xff3f, 0xff5b, 0xff5d, 0xff5f, 0xff60, 0xff61, 0xff62, 0xff63, 0xff64, 0xff65, 0x10100, 0x10101, 0x10102,
        -:  520:            0x1039f, 0x103d0, 0x1056f, 0x10857, 0x1091f, 0x1093f, 0x10a50, 0x10a51, 0x10a52, 0x10a53, 0x10a54, 0x10a55, 0x10a56, 0x10a57, 0x10a58, 0x10a7f,
        -:  521:            0x10af0, 0x10af1, 0x10af2, 0x10af3, 0x10af4, 0x10af5, 0x10af6, 0x10b39, 0x10b3a, 0x10b3b, 0x10b3c, 0x10b3d, 0x10b3e, 0x10b3f, 0x10b99, 0x10b9a,
        -:  522:            0x10b9b, 0x10b9c, 0x11047, 0x11048, 0x11049, 0x1104a, 0x1104b, 0x1104c, 0x1104d, 0x110bb, 0x110bc, 0x110be, 0x110bf, 0x110c0, 0x110c1, 0x11140,
        -:  523:            0x11141, 0x11142, 0x11143, 0x11174, 0x11175, 0x111c5, 0x111c6, 0x111c7, 0x111c8, 0x111c9, 0x111cd, 0x111db, 0x111dd, 0x111de, 0x111df, 0x11238,
        -:  524:            0x11239, 0x1123a, 0x1123b, 0x1123c, 0x1123d, 0x112a9, 0x1144b, 0x1144c, 0x1144d, 0x1144e, 0x1144f, 0x1145b, 0x1145d, 0x114c6, 0x115c1, 0x115c2,
        -:  525:            0x115c3, 0x115c4, 0x115c5, 0x115c6, 0x115c7, 0x115c8, 0x115c9, 0x115ca, 0x115cb, 0x115cc, 0x115cd, 0x115ce, 0x115cf, 0x115d0, 0x115d1, 0x115d2,
        -:  526:            0x115d3, 0x115d4, 0x115d5, 0x115d6, 0x115d7, 0x11641, 0x11642, 0x11643, 0x11660, 0x11661, 0x11662, 0x11663, 0x11664, 0x11665, 0x11666, 0x11667,
        -:  527:            0x11668, 0x11669, 0x1166a, 0x1166b, 0x1166c, 0x1173c, 0x1173d, 0x1173e, 0x11c41, 0x11c42, 0x11c43, 0x11c44, 0x11c45, 0x11c70, 0x11c71, 0x12470,
        -:  528:            0x12471, 0x12472, 0x12473, 0x12474, 0x16a6e, 0x16a6f, 0x16af5, 0x16b37, 0x16b38, 0x16b39, 0x16b3a, 0x16b3b, 0x16b44, 0x1bc9f, 0x1da87, 0x1da88,
        -:  529:            0x1da89, 0x1da8a, 0x1da8b, 0x1e95e, 0x1e95f
        -:  530:        };
        -:  531:
        -:  532:        /* The ASCII ones are the most frequently used ones, so lets check them first. */
        4:  533:        if(codepoint <= 0x7f)
        4:  534:            return ISPUNCT_(codepoint);
        -:  535:
    #####:  536:        return (bsearch(&codepoint, punct_list, SIZEOF_ARRAY(punct_list), sizeof(int), md_unicode_cmp__) != NULL);
        -:  537:    }
        -:  538:
        -:  539:    static void
    #####:  540:    md_get_unicode_fold_info(int codepoint, MD_UNICODE_FOLD_INFO* info)
        -:  541:    {
        -:  542:        /* This maps single codepoint within a range to a single codepoint
        -:  543:         * within an offseted range. */
        -:  544:        static const struct {
        -:  545:            int min_codepoint;
        -:  546:            int max_codepoint;
        -:  547:            int offset;
        -:  548:        } range_map[] = {
        -:  549:            { 0x00c0, 0x00d6, 32 }, { 0x00d8, 0x00de, 32 }, { 0x0388, 0x038a, 37 }, { 0x0391, 0x03a1, 32 }, { 0x03a3, 0x03ab, 32 }, { 0x0400, 0x040f, 80 },
        -:  550:            { 0x0410, 0x042f, 32 }, { 0x0531, 0x0556, 48 }, { 0x1f08, 0x1f0f, -8 }, { 0x1f18, 0x1f1d, -8 }, { 0x1f28, 0x1f2f, -8 }, { 0x1f38, 0x1f3f, -8 },
        -:  551:            { 0x1f48, 0x1f4d, -8 }, { 0x1f68, 0x1f6f, -8 }, { 0x1fc8, 0x1fcb, -86 }, { 0x2160, 0x216f, 16 }, { 0x24b6, 0x24cf, 26 }, { 0xff21, 0xff3a, 32 },
        -:  552:            { 0x10400, 0x10425, 40 }
        -:  553:        };
        -:  554:
        -:  555:        /* This maps single codepoint to another single codepoint. */
        -:  556:        static const struct {
        -:  557:            int src_codepoint;
        -:  558:            int dest_codepoint;
        -:  559:        } single_map[] = {
        -:  560:            { 0x00b5, 0x03bc }, { 0x0100, 0x0101 }, { 0x0102, 0x0103 }, { 0x0104, 0x0105 }, { 0x0106, 0x0107 }, { 0x0108, 0x0109 }, { 0x010a, 0x010b }, { 0x010c, 0x010d },
        -:  561:            { 0x010e, 0x010f }, { 0x0110, 0x0111 }, { 0x0112, 0x0113 }, { 0x0114, 0x0115 }, { 0x0116, 0x0117 }, { 0x0118, 0x0119 }, { 0x011a, 0x011b }, { 0x011c, 0x011d },
        -:  562:            { 0x011e, 0x011f }, { 0x0120, 0x0121 }, { 0x0122, 0x0123 }, { 0x0124, 0x0125 }, { 0x0126, 0x0127 }, { 0x0128, 0x0129 }, { 0x012a, 0x012b }, { 0x012c, 0x012d },
        -:  563:            { 0x012e, 0x012f }, { 0x0132, 0x0133 }, { 0x0134, 0x0135 }, { 0x0136, 0x0137 }, { 0x0139, 0x013a }, { 0x013b, 0x013c }, { 0x013d, 0x013e }, { 0x013f, 0x0140 },
        -:  564:            { 0x0141, 0x0142 }, { 0x0143, 0x0144 }, { 0x0145, 0x0146 }, { 0x0147, 0x0148 }, { 0x014a, 0x014b }, { 0x014c, 0x014d }, { 0x014e, 0x014f }, { 0x0150, 0x0151 },
        -:  565:            { 0x0152, 0x0153 }, { 0x0154, 0x0155 }, { 0x0156, 0x0157 }, { 0x0158, 0x0159 }, { 0x015a, 0x015b }, { 0x015c, 0x015d }, { 0x015e, 0x015f }, { 0x0160, 0x0161 },
        -:  566:            { 0x0162, 0x0163 }, { 0x0164, 0x0165 }, { 0x0166, 0x0167 }, { 0x0168, 0x0169 }, { 0x016a, 0x016b }, { 0x016c, 0x016d }, { 0x016e, 0x016f }, { 0x0170, 0x0171 },
        -:  567:            { 0x0172, 0x0173 }, { 0x0174, 0x0175 }, { 0x0176, 0x0177 }, { 0x0178, 0x00ff }, { 0x0179, 0x017a }, { 0x017b, 0x017c }, { 0x017d, 0x017e }, { 0x017f, 0x0073 },
        -:  568:            { 0x0181, 0x0253 }, { 0x0182, 0x0183 }, { 0x0184, 0x0185 }, { 0x0186, 0x0254 }, { 0x0187, 0x0188 }, { 0x0189, 0x0256 }, { 0x018a, 0x0257 }, { 0x018b, 0x018c },
        -:  569:            { 0x018e, 0x01dd }, { 0x018f, 0x0259 }, { 0x0190, 0x025b }, { 0x0191, 0x0192 }, { 0x0193, 0x0260 }, { 0x0194, 0x0263 }, { 0x0196, 0x0269 }, { 0x0197, 0x0268 },
        -:  570:            { 0x0198, 0x0199 }, { 0x019c, 0x026f }, { 0x019d, 0x0272 }, { 0x019f, 0x0275 }, { 0x01a0, 0x01a1 }, { 0x01a2, 0x01a3 }, { 0x01a4, 0x01a5 }, { 0x01a6, 0x0280 },
        -:  571:            { 0x01a7, 0x01a8 }, { 0x01a9, 0x0283 }, { 0x01ac, 0x01ad }, { 0x01ae, 0x0288 }, { 0x01af, 0x01b0 }, { 0x01b1, 0x028a }, { 0x01b2, 0x028b }, { 0x01b3, 0x01b4 },
        -:  572:            { 0x01b5, 0x01b6 }, { 0x01b7, 0x0292 }, { 0x01b8, 0x01b9 }, { 0x01bc, 0x01bd }, { 0x01c4, 0x01c6 }, { 0x01c5, 0x01c6 }, { 0x01c7, 0x01c9 }, { 0x01c8, 0x01c9 },
        -:  573:            { 0x01ca, 0x01cc }, { 0x01cb, 0x01cc }, { 0x01cd, 0x01ce }, { 0x01cf, 0x01d0 }, { 0x01d1, 0x01d2 }, { 0x01d3, 0x01d4 }, { 0x01d5, 0x01d6 }, { 0x01d7, 0x01d8 },
        -:  574:            { 0x01d9, 0x01da }, { 0x01db, 0x01dc }, { 0x01de, 0x01df }, { 0x01e0, 0x01e1 }, { 0x01e2, 0x01e3 }, { 0x01e4, 0x01e5 }, { 0x01e6, 0x01e7 }, { 0x01e8, 0x01e9 },
        -:  575:            { 0x01ea, 0x01eb }, { 0x01ec, 0x01ed }, { 0x01ee, 0x01ef }, { 0x01f1, 0x01f3 }, { 0x01f2, 0x01f3 }, { 0x01f4, 0x01f5 }, { 0x01f6, 0x0195 }, { 0x01f7, 0x01bf },
        -:  576:            { 0x01f8, 0x01f9 }, { 0x01fa, 0x01fb }, { 0x01fc, 0x01fd }, { 0x01fe, 0x01ff }, { 0x0200, 0x0201 }, { 0x0202, 0x0203 }, { 0x0204, 0x0205 }, { 0x0206, 0x0207 },
        -:  577:            { 0x0208, 0x0209 }, { 0x020a, 0x020b }, { 0x020c, 0x020d }, { 0x020e, 0x020f }, { 0x0210, 0x0211 }, { 0x0212, 0x0213 }, { 0x0214, 0x0215 }, { 0x0216, 0x0217 },
        -:  578:            { 0x0218, 0x0219 }, { 0x021a, 0x021b }, { 0x021c, 0x021d }, { 0x021e, 0x021f }, { 0x0220, 0x019e }, { 0x0222, 0x0223 }, { 0x0224, 0x0225 }, { 0x0226, 0x0227 },
        -:  579:            { 0x0228, 0x0229 }, { 0x022a, 0x022b }, { 0x022c, 0x022d }, { 0x022e, 0x022f }, { 0x0230, 0x0231 }, { 0x0232, 0x0233 }, { 0x0345, 0x03b9 }, { 0x0386, 0x03ac },
        -:  580:            { 0x038c, 0x03cc }, { 0x038e, 0x03cd }, { 0x038f, 0x03ce }, { 0x03c2, 0x03c3 }, { 0x03d0, 0x03b2 }, { 0x03d1, 0x03b8 }, { 0x03d5, 0x03c6 }, { 0x03d6, 0x03c0 },
        -:  581:            { 0x03d8, 0x03d9 }, { 0x03da, 0x03db }, { 0x03dc, 0x03dd }, { 0x03de, 0x03df }, { 0x03e0, 0x03e1 }, { 0x03e2, 0x03e3 }, { 0x03e4, 0x03e5 }, { 0x03e6, 0x03e7 },
        -:  582:            { 0x03e8, 0x03e9 }, { 0x03ea, 0x03eb }, { 0x03ec, 0x03ed }, { 0x03ee, 0x03ef }, { 0x03f0, 0x03ba }, { 0x03f1, 0x03c1 }, { 0x03f2, 0x03c3 }, { 0x03f4, 0x03b8 },
        -:  583:            { 0x03f5, 0x03b5 }, { 0x0460, 0x0461 }, { 0x0462, 0x0463 }, { 0x0464, 0x0465 }, { 0x0466, 0x0467 }, { 0x0468, 0x0469 }, { 0x046a, 0x046b }, { 0x046c, 0x046d },
        -:  584:            { 0x046e, 0x046f }, { 0x0470, 0x0471 }, { 0x0472, 0x0473 }, { 0x0474, 0x0475 }, { 0x0476, 0x0477 }, { 0x0478, 0x0479 }, { 0x047a, 0x047b }, { 0x047c, 0x047d },
        -:  585:            { 0x047e, 0x047f }, { 0x0480, 0x0481 }, { 0x048a, 0x048b }, { 0x048c, 0x048d }, { 0x048e, 0x048f }, { 0x0490, 0x0491 }, { 0x0492, 0x0493 }, { 0x0494, 0x0495 },
        -:  586:            { 0x0496, 0x0497 }, { 0x0498, 0x0499 }, { 0x049a, 0x049b }, { 0x049c, 0x049d }, { 0x049e, 0x049f }, { 0x04a0, 0x04a1 }, { 0x04a2, 0x04a3 }, { 0x04a4, 0x04a5 },
        -:  587:            { 0x04a6, 0x04a7 }, { 0x04a8, 0x04a9 }, { 0x04aa, 0x04ab }, { 0x04ac, 0x04ad }, { 0x04ae, 0x04af }, { 0x04b0, 0x04b1 }, { 0x04b2, 0x04b3 }, { 0x04b4, 0x04b5 },
        -:  588:            { 0x04b6, 0x04b7 }, { 0x04b8, 0x04b9 }, { 0x04ba, 0x04bb }, { 0x04bc, 0x04bd }, { 0x04be, 0x04bf }, { 0x04c1, 0x04c2 }, { 0x04c3, 0x04c4 }, { 0x04c5, 0x04c6 },
        -:  589:            { 0x04c7, 0x04c8 }, { 0x04c9, 0x04ca }, { 0x04cb, 0x04cc }, { 0x04cd, 0x04ce }, { 0x04d0, 0x04d1 }, { 0x04d2, 0x04d3 }, { 0x04d4, 0x04d5 }, { 0x04d6, 0x04d7 },
        -:  590:            { 0x04d8, 0x04d9 }, { 0x04da, 0x04db }, { 0x04dc, 0x04dd }, { 0x04de, 0x04df }, { 0x04e0, 0x04e1 }, { 0x04e2, 0x04e3 }, { 0x04e4, 0x04e5 }, { 0x04e6, 0x04e7 },
        -:  591:            { 0x04e8, 0x04e9 }, { 0x04ea, 0x04eb }, { 0x04ec, 0x04ed }, { 0x04ee, 0x04ef }, { 0x04f0, 0x04f1 }, { 0x04f2, 0x04f3 }, { 0x04f4, 0x04f5 }, { 0x04f8, 0x04f9 },
        -:  592:            { 0x0500, 0x0501 }, { 0x0502, 0x0503 }, { 0x0504, 0x0505 }, { 0x0506, 0x0507 }, { 0x0508, 0x0509 }, { 0x050a, 0x050b }, { 0x050c, 0x050d }, { 0x050e, 0x050f },
        -:  593:            { 0x1e00, 0x1e01 }, { 0x1e02, 0x1e03 }, { 0x1e04, 0x1e05 }, { 0x1e06, 0x1e07 }, { 0x1e08, 0x1e09 }, { 0x1e0a, 0x1e0b }, { 0x1e0c, 0x1e0d }, { 0x1e0e, 0x1e0f },
        -:  594:            { 0x1e10, 0x1e11 }, { 0x1e12, 0x1e13 }, { 0x1e14, 0x1e15 }, { 0x1e16, 0x1e17 }, { 0x1e18, 0x1e19 }, { 0x1e1a, 0x1e1b }, { 0x1e1c, 0x1e1d }, { 0x1e1e, 0x1e1f },
        -:  595:            { 0x1e20, 0x1e21 }, { 0x1e22, 0x1e23 }, { 0x1e24, 0x1e25 }, { 0x1e26, 0x1e27 }, { 0x1e28, 0x1e29 }, { 0x1e2a, 0x1e2b }, { 0x1e2c, 0x1e2d }, { 0x1e2e, 0x1e2f },
        -:  596:            { 0x1e30, 0x1e31 }, { 0x1e32, 0x1e33 }, { 0x1e34, 0x1e35 }, { 0x1e36, 0x1e37 }, { 0x1e38, 0x1e39 }, { 0x1e3a, 0x1e3b }, { 0x1e3c, 0x1e3d }, { 0x1e3e, 0x1e3f },
        -:  597:            { 0x1e40, 0x1e41 }, { 0x1e42, 0x1e43 }, { 0x1e44, 0x1e45 }, { 0x1e46, 0x1e47 }, { 0x1e48, 0x1e49 }, { 0x1e4a, 0x1e4b }, { 0x1e4c, 0x1e4d }, { 0x1e4e, 0x1e4f },
        -:  598:            { 0x1e50, 0x1e51 }, { 0x1e52, 0x1e53 }, { 0x1e54, 0x1e55 }, { 0x1e56, 0x1e57 }, { 0x1e58, 0x1e59 }, { 0x1e5a, 0x1e5b }, { 0x1e5c, 0x1e5d }, { 0x1e5e, 0x1e5f },
        -:  599:            { 0x1e60, 0x1e61 }, { 0x1e62, 0x1e63 }, { 0x1e64, 0x1e65 }, { 0x1e66, 0x1e67 }, { 0x1e68, 0x1e69 }, { 0x1e6a, 0x1e6b }, { 0x1e6c, 0x1e6d }, { 0x1e6e, 0x1e6f },
        -:  600:            { 0x1e70, 0x1e71 }, { 0x1e72, 0x1e73 }, { 0x1e74, 0x1e75 }, { 0x1e76, 0x1e77 }, { 0x1e78, 0x1e79 }, { 0x1e7a, 0x1e7b }, { 0x1e7c, 0x1e7d }, { 0x1e7e, 0x1e7f },
        -:  601:            { 0x1e80, 0x1e81 }, { 0x1e82, 0x1e83 }, { 0x1e84, 0x1e85 }, { 0x1e86, 0x1e87 }, { 0x1e88, 0x1e89 }, { 0x1e8a, 0x1e8b }, { 0x1e8c, 0x1e8d }, { 0x1e8e, 0x1e8f },
        -:  602:            { 0x1e90, 0x1e91 }, { 0x1e92, 0x1e93 }, { 0x1e94, 0x1e95 }, { 0x1e9b, 0x1e61 }, { 0x1ea0, 0x1ea1 }, { 0x1ea2, 0x1ea3 }, { 0x1ea4, 0x1ea5 }, { 0x1ea6, 0x1ea7 },
        -:  603:            { 0x1ea8, 0x1ea9 }, { 0x1eaa, 0x1eab }, { 0x1eac, 0x1ead }, { 0x1eae, 0x1eaf }, { 0x1eb0, 0x1eb1 }, { 0x1eb2, 0x1eb3 }, { 0x1eb4, 0x1eb5 }, { 0x1eb6, 0x1eb7 },
        -:  604:            { 0x1eb8, 0x1eb9 }, { 0x1eba, 0x1ebb }, { 0x1ebc, 0x1ebd }, { 0x1ebe, 0x1ebf }, { 0x1ec0, 0x1ec1 }, { 0x1ec2, 0x1ec3 }, { 0x1ec4, 0x1ec5 }, { 0x1ec6, 0x1ec7 },
        -:  605:            { 0x1ec8, 0x1ec9 }, { 0x1eca, 0x1ecb }, { 0x1ecc, 0x1ecd }, { 0x1ece, 0x1ecf }, { 0x1ed0, 0x1ed1 }, { 0x1ed2, 0x1ed3 }, { 0x1ed4, 0x1ed5 }, { 0x1ed6, 0x1ed7 },
        -:  606:            { 0x1ed8, 0x1ed9 }, { 0x1eda, 0x1edb }, { 0x1edc, 0x1edd }, { 0x1ede, 0x1edf }, { 0x1ee0, 0x1ee1 }, { 0x1ee2, 0x1ee3 }, { 0x1ee4, 0x1ee5 }, { 0x1ee6, 0x1ee7 },
        -:  607:            { 0x1ee8, 0x1ee9 }, { 0x1eea, 0x1eeb }, { 0x1eec, 0x1eed }, { 0x1eee, 0x1eef }, { 0x1ef0, 0x1ef1 }, { 0x1ef2, 0x1ef3 }, { 0x1ef4, 0x1ef5 }, { 0x1ef6, 0x1ef7 },
        -:  608:            { 0x1ef8, 0x1ef9 }, { 0x1f59, 0x1f51 }, { 0x1f5b, 0x1f53 }, { 0x1f5d, 0x1f55 }, { 0x1f5f, 0x1f57 }, { 0x1fb8, 0x1fb0 }, { 0x1fb9, 0x1fb1 }, { 0x1fba, 0x1f70 },
        -:  609:            { 0x1fbb, 0x1f71 }, { 0x1fbe, 0x03b9 }, { 0x1fd8, 0x1fd0 }, { 0x1fd9, 0x1fd1 }, { 0x1fda, 0x1f76 }, { 0x1fdb, 0x1f77 }, { 0x1fe8, 0x1fe0 }, { 0x1fe9, 0x1fe1 },
        -:  610:            { 0x1fea, 0x1f7a }, { 0x1feb, 0x1f7b }, { 0x1fec, 0x1fe5 }, { 0x1ff8, 0x1f78 }, { 0x1ff9, 0x1f79 }, { 0x1ffa, 0x1f7c }, { 0x1ffb, 0x1f7d }, { 0x2126, 0x03c9 },
        -:  611:            { 0x212a, 0x006b }, { 0x212b, 0x00e5 },
        -:  612:        };
        -:  613:
        -:  614:        /* This maps single codepoint to two codepoints. */
        -:  615:        static const struct {
        -:  616:            int src_codepoint;
        -:  617:            int dest_codepoint0;
        -:  618:            int dest_codepoint1;
        -:  619:        } double_map[] = {
        -:  620:            { 0x00df, 0x0073, 0x0073 }, { 0x0130, 0x0069, 0x0307 }, { 0x0149, 0x02bc, 0x006e }, { 0x01f0, 0x006a, 0x030c }, { 0x0587, 0x0565, 0x0582 }, { 0x1e96, 0x0068, 0x0331 },
        -:  621:            { 0x1e97, 0x0074, 0x0308 }, { 0x1e98, 0x0077, 0x030a }, { 0x1e99, 0x0079, 0x030a }, { 0x1e9a, 0x0061, 0x02be }, { 0x1f50, 0x03c5, 0x0313 }, { 0x1f80, 0x1f00, 0x03b9 },
        -:  622:            { 0x1f81, 0x1f01, 0x03b9 }, { 0x1f82, 0x1f02, 0x03b9 }, { 0x1f83, 0x1f03, 0x03b9 }, { 0x1f84, 0x1f04, 0x03b9 }, { 0x1f85, 0x1f05, 0x03b9 }, { 0x1f86, 0x1f06, 0x03b9 },
        -:  623:            { 0x1f87, 0x1f07, 0x03b9 }, { 0x1f88, 0x1f00, 0x03b9 }, { 0x1f89, 0x1f01, 0x03b9 }, { 0x1f8a, 0x1f02, 0x03b9 }, { 0x1f8b, 0x1f03, 0x03b9 }, { 0x1f8c, 0x1f04, 0x03b9 },
        -:  624:            { 0x1f8d, 0x1f05, 0x03b9 }, { 0x1f8e, 0x1f06, 0x03b9 }, { 0x1f8f, 0x1f07, 0x03b9 }, { 0x1f90, 0x1f20, 0x03b9 }, { 0x1f91, 0x1f21, 0x03b9 }, { 0x1f92, 0x1f22, 0x03b9 },
        -:  625:            { 0x1f93, 0x1f23, 0x03b9 }, { 0x1f94, 0x1f24, 0x03b9 }, { 0x1f95, 0x1f25, 0x03b9 }, { 0x1f96, 0x1f26, 0x03b9 }, { 0x1f97, 0x1f27, 0x03b9 }, { 0x1f98, 0x1f20, 0x03b9 },
        -:  626:            { 0x1f99, 0x1f21, 0x03b9 }, { 0x1f9a, 0x1f22, 0x03b9 }, { 0x1f9b, 0x1f23, 0x03b9 }, { 0x1f9c, 0x1f24, 0x03b9 }, { 0x1f9d, 0x1f25, 0x03b9 }, { 0x1f9e, 0x1f26, 0x03b9 },
        -:  627:            { 0x1f9f, 0x1f27, 0x03b9 }, { 0x1fa0, 0x1f60, 0x03b9 }, { 0x1fa1, 0x1f61, 0x03b9 }, { 0x1fa2, 0x1f62, 0x03b9 }, { 0x1fa3, 0x1f63, 0x03b9 }, { 0x1fa4, 0x1f64, 0x03b9 },
        -:  628:            { 0x1fa5, 0x1f65, 0x03b9 }, { 0x1fa6, 0x1f66, 0x03b9 }, { 0x1fa7, 0x1f67, 0x03b9 }, { 0x1fa8, 0x1f60, 0x03b9 }, { 0x1fa9, 0x1f61, 0x03b9 }, { 0x1faa, 0x1f62, 0x03b9 },
        -:  629:            { 0x1fab, 0x1f63, 0x03b9 }, { 0x1fac, 0x1f64, 0x03b9 }, { 0x1fad, 0x1f65, 0x03b9 }, { 0x1fae, 0x1f66, 0x03b9 }, { 0x1faf, 0x1f67, 0x03b9 }, { 0x1fb2, 0x1f70, 0x03b9 },
        -:  630:            { 0x1fb3, 0x03b1, 0x03b9 }, { 0x1fb4, 0x03ac, 0x03b9 }, { 0x1fb6, 0x03b1, 0x0342 }, { 0x1fbc, 0x03b1, 0x03b9 }, { 0x1fc2, 0x1f74, 0x03b9 }, { 0x1fc3, 0x03b7, 0x03b9 },
        -:  631:            { 0x1fc4, 0x03ae, 0x03b9 }, { 0x1fc6, 0x03b7, 0x0342 }, { 0x1fcc, 0x03b7, 0x03b9 }, { 0x1fd6, 0x03b9, 0x0342 }, { 0x1fe4, 0x03c1, 0x0313 }, { 0x1fe6, 0x03c5, 0x0342 },
        -:  632:            { 0x1ff2, 0x1f7c, 0x03b9 }, { 0x1ff3, 0x03c9, 0x03b9 }, { 0x1ff4, 0x03ce, 0x03b9 }, { 0x1ff6, 0x03c9, 0x0342 }, { 0x1ffc, 0x03c9, 0x03b9 }, { 0xfb00, 0x0066, 0x0066 },
        -:  633:            { 0xfb01, 0x0066, 0x0069 }, { 0xfb02, 0x0066, 0x006c }, { 0xfb05, 0x0073, 0x0074 }, { 0xfb06, 0x0073, 0x0074 }, { 0xfb13, 0x0574, 0x0576 }, { 0xfb14, 0x0574, 0x0565 },
        -:  634:            { 0xfb15, 0x0574, 0x056b }, { 0xfb16, 0x057e, 0x0576 }, { 0xfb17, 0x0574, 0x056d }
        -:  635:        };
        -:  636:
        -:  637:        /* This maps single codepoint to three codepoints. */
        -:  638:        static const struct {
        -:  639:            int src_codepoint;
        -:  640:            int dest_codepoint0;
        -:  641:            int dest_codepoint1;
        -:  642:            int dest_codepoint2;
        -:  643:        } triple_map[] = {
        -:  644:            { 0x0390, 0x03b9, 0x0308, 0x0301 }, { 0x03b0, 0x03c5, 0x0308, 0x0301 }, { 0x1f52, 0x03c5, 0x0313, 0x0300 }, { 0x1f54, 0x03c5, 0x0313, 0x0301 },
        -:  645:            { 0x1f56, 0x03c5, 0x0313, 0x0342 }, { 0x1fb7, 0x03b1, 0x0342, 0x03b9 }, { 0x1fc7, 0x03b7, 0x0342, 0x03b9 }, { 0x1fd2, 0x03b9, 0x0308, 0x0300 },
        -:  646:            { 0x1fd3, 0x03b9, 0x0308, 0x0301 }, { 0x1fd7, 0x03b9, 0x0308, 0x0342 }, { 0x1fe2, 0x03c5, 0x0308, 0x0300 }, { 0x1fe3, 0x03c5, 0x0308, 0x0301 },
        -:  647:            { 0x1fe7, 0x03c5, 0x0308, 0x0342 }, { 0x1ff7, 0x03c9, 0x0342, 0x03b9 }, { 0xfb03, 0x0066, 0x0066, 0x0069 }, { 0xfb04, 0x0066, 0x0066, 0x006c }
        -:  648:        };
        -:  649:
        -:  650:        int i;
        -:  651:
        -:  652:        /* Fast path for ASCII characters. */
    #####:  653:        if(codepoint <= 0x7f) {
    #####:  654:            info->codepoints[0] = codepoint;
    #####:  655:            if(ISUPPER_(codepoint))
    #####:  656:                info->codepoints[0] += 'a' - 'A';
    #####:  657:            info->n_codepoints = 1;
    #####:  658:            return;
        -:  659:        }
        -:  660:
    #####:  661:        for(i = 0; i < SIZEOF_ARRAY(range_map); i++) {
    #####:  662:            if(range_map[i].min_codepoint <= codepoint && codepoint <= range_map[i].max_codepoint) {
    #####:  663:                info->codepoints[0] = codepoint + range_map[i].offset;
    #####:  664:                info->n_codepoints = 1;
    #####:  665:                return;
        -:  666:            }
        -:  667:        }
        -:  668:
    #####:  669:        for(i = 0; i < SIZEOF_ARRAY(single_map); i++) {
    #####:  670:            if(codepoint == single_map[i].src_codepoint) {
    #####:  671:                info->codepoints[0] = single_map[i].dest_codepoint;
    #####:  672:                info->n_codepoints = 1;
    #####:  673:                return;
        -:  674:            }
        -:  675:        }
        -:  676:
    #####:  677:        for(i = 0; i < SIZEOF_ARRAY(double_map); i++) {
    #####:  678:            if(codepoint == double_map[i].src_codepoint) {
    #####:  679:                info->codepoints[0] = double_map[i].dest_codepoint0;
    #####:  680:                info->codepoints[1] = double_map[i].dest_codepoint1;
    #####:  681:                info->n_codepoints = 2;
    #####:  682:                return;
        -:  683:            }
        -:  684:        }
        -:  685:
    #####:  686:        for(i = 0; i < SIZEOF_ARRAY(triple_map); i++) {
    #####:  687:            if(codepoint == triple_map[i].src_codepoint) {
    #####:  688:                info->codepoints[0] = triple_map[i].dest_codepoint0;
    #####:  689:                info->codepoints[1] = triple_map[i].dest_codepoint1;
    #####:  690:                info->codepoints[2] = triple_map[i].dest_codepoint2;
    #####:  691:                info->n_codepoints = 3;
    #####:  692:                return;
        -:  693:            }
        -:  694:        }
        -:  695:
    #####:  696:        info->codepoints[0] = codepoint;
    #####:  697:        info->n_codepoints = 1;
        -:  698:    }
        -:  699:#endif
        -:  700:
        -:  701:
        -:  702:#if defined MD4C_USE_UTF16
        -:  703:    #define IS_UTF16_SURROGATE_HI(word)     (((WORD)(word) & 0xfc00) == 0xd800)
        -:  704:    #define IS_UTF16_SURROGATE_LO(word)     (((WORD)(word) & 0xfc00) == 0xdc00)
        -:  705:    #define UTF16_DECODE_SURROGATE(hi, lo)  (0x10000 + ((((unsigned)(hi) & 0x3ff) << 10) | (((unsigned)(lo) & 0x3ff) << 0)))
        -:  706:
        -:  707:    static int
        -:  708:    md_decode_utf16le__(const CHAR* str, SZ str_size, SZ* p_size)
        -:  709:    {
        -:  710:        if(IS_UTF16_SURROGATE_HI(str[0])) {
        -:  711:            if(1 < str_size && IS_UTF16_SURROGATE_LO(str[1])) {
        -:  712:                if(p_size != NULL)
        -:  713:                    *p_size = 2;
        -:  714:                return UTF16_DECODE_SURROGATE(str[0], str[1]);
        -:  715:            }
        -:  716:        }
        -:  717:
        -:  718:        if(p_size != NULL)
        -:  719:            *p_size = 1;
        -:  720:        return str[0];
        -:  721:    }
        -:  722:
        -:  723:    static int
        -:  724:    md_decode_utf16le_before__(MD_CTX* ctx, OFF off)
        -:  725:    {
        -:  726:        if(off > 2 && IS_UTF16_SURROGATE_HI(CH(off-2)) && IS_UTF16_SURROGATE_LO(CH(off-1)))
        -:  727:            return UTF16_DECODE_SURROGATE(CH(off-2), CH(off-1));
        -:  728:
        -:  729:        return CH(off);
        -:  730:    }
        -:  731:
        -:  732:    /* No whitespace uses surrogates, so no decoding needed here. */
        -:  733:    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)
        -:  734:    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(CH(off))
        -:  735:    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(CH((off)-1))
        -:  736:
        -:  737:    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf16le__(STR(off), ctx->size - (off), NULL))
        -:  738:    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf16le_before__(ctx, off))
        -:  739:
        -:  740:    static inline int
        -:  741:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)
        -:  742:    {
        -:  743:        return md_decode_utf16le__(str+off, str_size-off, p_char_size);
        -:  744:    }
        -:  745:#elif defined MD4C_USE_UTF8
        -:  746:    #define IS_UTF8_LEAD1(byte)     ((unsigned char)(byte) <= 0x7f)
        -:  747:    #define IS_UTF8_LEAD2(byte)     (((unsigned char)(byte) & 0xe0) == 0xc0)
        -:  748:    #define IS_UTF8_LEAD3(byte)     (((unsigned char)(byte) & 0xf0) == 0xe0)
        -:  749:    #define IS_UTF8_LEAD4(byte)     (((unsigned char)(byte) & 0xf8) == 0xf0)
        -:  750:    #define IS_UTF8_TAIL(byte)      (((unsigned char)(byte) & 0xc0) == 0x80)
        -:  751:
        -:  752:    static int
        5:  753:    md_decode_utf8__(const CHAR* str, SZ str_size, SZ* p_size)
        -:  754:    {
        5:  755:        if(!IS_UTF8_LEAD1(str[0])) {
    #####:  756:            if(IS_UTF8_LEAD2(str[0])) {
    #####:  757:                if(1 < str_size && IS_UTF8_TAIL(str[1])) {
    #####:  758:                    if(p_size != NULL)
    #####:  759:                        *p_size = 2;
        -:  760:
    #####:  761:                    return (((unsigned int)str[0] & 0x1f) << 6) |
    #####:  762:                           (((unsigned int)str[1] & 0x3f) << 0);
        -:  763:                }
    #####:  764:            } else if(IS_UTF8_LEAD3(str[0])) {
    #####:  765:                if(2 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2])) {
    #####:  766:                    if(p_size != NULL)
    #####:  767:                        *p_size = 3;
        -:  768:
    #####:  769:                    return (((unsigned int)str[0] & 0x0f) << 12) |
    #####:  770:                           (((unsigned int)str[1] & 0x3f) << 6) |
    #####:  771:                           (((unsigned int)str[2] & 0x3f) << 0);
        -:  772:                }
    #####:  773:            } else if(IS_UTF8_LEAD4(str[0])) {
    #####:  774:                if(3 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2]) && IS_UTF8_TAIL(str[3])) {
    #####:  775:                    if(p_size != NULL)
    #####:  776:                        *p_size = 4;
        -:  777:
    #####:  778:                    return (((unsigned int)str[0] & 0x07) << 18) |
    #####:  779:                           (((unsigned int)str[1] & 0x3f) << 12) |
    #####:  780:                           (((unsigned int)str[2] & 0x3f) << 6) |
    #####:  781:                           (((unsigned int)str[3] & 0x3f) << 0);
        -:  782:                }
        -:  783:            }
        -:  784:        }
        -:  785:
        5:  786:        if(p_size != NULL)
    #####:  787:            *p_size = 1;
        5:  788:        return str[0];
        -:  789:    }
        -:  790:
        -:  791:    static int
        3:  792:    md_decode_utf8_before__(MD_CTX* ctx, OFF off)
        -:  793:    {
        3:  794:        if(!IS_UTF8_LEAD1(CH(off-1))) {
    #####:  795:            if(off > 1 && IS_UTF8_LEAD2(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  796:                return (((unsigned int)CH(off-2) & 0x1f) << 6) |
    #####:  797:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  798:
    #####:  799:            if(off > 2 && IS_UTF8_LEAD3(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  800:                return (((unsigned int)CH(off-3) & 0x0f) << 12) |
    #####:  801:                       (((unsigned int)CH(off-2) & 0x3f) << 6) |
    #####:  802:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  803:
    #####:  804:            if(off > 3 && IS_UTF8_LEAD4(CH(off-4)) && IS_UTF8_TAIL(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  805:                return (((unsigned int)CH(off-4) & 0x07) << 18) |
    #####:  806:                       (((unsigned int)CH(off-3) & 0x3f) << 12) |
    #####:  807:                       (((unsigned int)CH(off-2) & 0x3f) << 6) |
    #####:  808:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  809:        }
        -:  810:
        3:  811:        return CH(off-1);
        -:  812:    }
        -:  813:
        -:  814:    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)
        -:  815:    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))
        -:  816:    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(md_decode_utf8_before__(ctx, off))
        -:  817:
        -:  818:    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))
        -:  819:    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf8_before__(ctx, off))
        -:  820:
        -:  821:    static inline int
        -:  822:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)
        -:  823:    {
    #####:  824:        return md_decode_utf8__(str+off, str_size-off, p_char_size);
        -:  825:    }
        -:  826:#else
        -:  827:    #define ISUNICODEWHITESPACE_(codepoint) ISWHITESPACE_(codepoint)
        -:  828:    #define ISUNICODEWHITESPACE(off)        ISWHITESPACE(off)
        -:  829:    #define ISUNICODEWHITESPACEBEFORE(off)  ISWHITESPACE((off)-1)
        -:  830:
        -:  831:    #define ISUNICODEPUNCT(off)             ISPUNCT(off)
        -:  832:    #define ISUNICODEPUNCTBEFORE(off)       ISPUNCT((off)-1)
        -:  833:
        -:  834:    static inline void
        -:  835:    md_get_unicode_fold_info(int codepoint, MD_UNICODE_FOLD_INFO* info)
        -:  836:    {
        -:  837:        info->codepoints[0] = codepoint;
        -:  838:        if(ISUPPER_(codepoint))
        -:  839:            info->codepoints[0] += 'a' - 'A';
        -:  840:        info->n_codepoints = 1;
        -:  841:    }
        -:  842:
        -:  843:    static inline int
        -:  844:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_size)
        -:  845:    {
        -:  846:        *p_size = 1;
        -:  847:        return str[off];
        -:  848:    }
        -:  849:#endif
        -:  850:
        -:  851:
        -:  852:/*************************************
        -:  853: ***  Helper string manipulations  ***
        -:  854: *************************************/
        -:  855:
        -:  856:/* Fill buffer with copy of the string between 'beg' and 'end' but replace any
        -:  857: * line breaks with given replacement character.
        -:  858: *
        -:  859: * NOTE: Caller is responsible to make sure the buffer is large enough.
        -:  860: * (Given the output is always shorter then input, (end - beg) is good idea
        -:  861: * what the caller should allocate.)
        -:  862: */
        -:  863:static void
        -:  864:md_merge_lines(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,
        -:  865:               CHAR line_break_replacement_char, CHAR* buffer, SZ* p_size)
        -:  866:{
        -:  867:    CHAR* ptr = buffer;
        -:  868:    int line_index = 0;
        -:  869:    OFF off = beg;
        -:  870:
        -:  871:    while(1) {
    #####:  872:        const MD_LINE* line = &lines[line_index];
    #####:  873:        OFF line_end = line->end;
    #####:  874:        if(end < line_end)
    #####:  875:            line_end = end;
        -:  876:
    #####:  877:        while(off < line_end) {
    #####:  878:            *ptr = CH(off);
    #####:  879:            ptr++;
    #####:  880:            off++;
        -:  881:        }
        -:  882:
    #####:  883:        if(off >= end) {
    #####:  884:            *p_size = ptr - buffer;
        -:  885:            return;
        -:  886:        }
        -:  887:
    #####:  888:        *ptr = line_break_replacement_char;
    #####:  889:        ptr++;
        -:  890:
    #####:  891:        line_index++;
    #####:  892:        off = lines[line_index].beg;
        -:  893:    }
        -:  894:}
        -:  895:
        -:  896:/* Wrapper of md_merge_lines() which allocates new buffer for the output string.
        -:  897: */
        -:  898:static int
    #####:  899:md_merge_lines_alloc(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,
        -:  900:                    CHAR line_break_replacement_char, CHAR** p_str, SZ* p_size)
        -:  901:{
        -:  902:    CHAR* buffer;
        -:  903:
    #####:  904:    buffer = (CHAR*) malloc(sizeof(CHAR) * (end - beg));
    #####:  905:    if(buffer == NULL) {
    #####:  906:        MD_LOG("malloc() failed.");
        -:  907:        return -1;
        -:  908:    }
        -:  909:
    #####:  910:    md_merge_lines(ctx, beg, end, lines, n_lines,
        -:  911:                line_break_replacement_char, buffer, p_size);
        -:  912:
    #####:  913:    *p_str = buffer;
    #####:  914:    return 0;
        -:  915:}
        -:  916:
        -:  917:static OFF
    #####:  918:md_skip_unicode_whitespace(const CHAR* label, OFF off, SZ size)
        -:  919:{
    #####:  920:    SZ char_size;
        -:  921:    int codepoint;
        -:  922:
    #####:  923:    while(off < size) {
    #####:  924:        codepoint = md_decode_unicode(label, off, size, &char_size);
    #####:  925:        if(!ISUNICODEWHITESPACE_(codepoint)  &&  !ISNEWLINE_(label[off]))
        -:  926:            break;
    #####:  927:        off += char_size;
        -:  928:    }
        -:  929:
    #####:  930:    return off;
        -:  931:}
        -:  932:
        -:  933:
        -:  934:/******************************
        -:  935: ***  Recognizing raw HTML  ***
        -:  936: ******************************/
        -:  937:
        -:  938:/* md_is_html_tag() may be called when processing inlines (inline raw HTML)
        -:  939: * or when breaking document to blocks (checking for start of HTML block type 7).
        -:  940: *
        -:  941: * When breaking document to blocks, we do not yet know line boundaries, but
        -:  942: * in that case the whole tag has to live on a single line. We distinguish this
        -:  943: * by n_lines == 0.
        -:  944: */
        -:  945:static int
    #####:  946:md_is_html_tag(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -:  947:{
        -:  948:    int attr_state;
    #####:  949:    OFF off = beg;
    #####:  950:    OFF line_end = (n_lines > 0) ? lines[0].end : ctx->size;
    #####:  951:    int i = 0;
        -:  952:
    #####:  953:    MD_ASSERT(CH(beg) == _T('<'));
        -:  954:
    #####:  955:    if(off + 1 >= line_end)
        -:  956:        return FALSE;
    #####:  957:    off++;
        -:  958:
        -:  959:    /* For parsing attributes, we need a little state automaton below.
        -:  960:     * State -1: no attributes are allowed.
        -:  961:     * State 0: attribute could follow after some whitespace.
        -:  962:     * State 1: after a whitespace (attribute name may follow).
        -:  963:     * State 2: after attribute name ('=' MAY follow).
        -:  964:     * State 3: after '=' (value specification MUST follow).
        -:  965:     * State 41: in middle of unquoted attribute value.
        -:  966:     * State 42: in middle of single-quoted attribute value.
        -:  967:     * State 43: in middle of double-quoted attribute value.
        -:  968:     */
    #####:  969:    attr_state = 0;
        -:  970:
    #####:  971:    if(CH(off) == _T('/')) {
        -:  972:        /* Closer tag "</ ... >". No attributes may be present. */
    #####:  973:        attr_state = -1;
    #####:  974:        off++;
        -:  975:    }
        -:  976:
        -:  977:    /* Tag name */
    #####:  978:    if(off >= line_end  ||  !ISALPHA(off))
        -:  979:        return FALSE;
    #####:  980:    off++;
    #####:  981:    while(off < line_end  &&  (ISALNUM(off)  ||  CH(off) == _T('-')))
    #####:  982:        off++;
        -:  983:
        -:  984:    /* (Optional) attributes (if not closer), (optional) '/' (if not closer)
        -:  985:     * and final '>'. */
        -:  986:    while(1) {
    #####:  987:        while(off < line_end  &&  !ISNEWLINE(off)) {
    #####:  988:            if(attr_state > 40) {
    #####:  989:                if(attr_state == 41 && (ISBLANK(off) || ISANYOF(off, _T("\"'=<>`")))) {
    #####:  990:                    attr_state = 0;
    #####:  991:                    off--;  /* Put the char back for re-inspection in the new state. */
    #####:  992:                } else if(attr_state == 42 && CH(off) == _T('\'')) {
        -:  993:                    attr_state = 0;
    #####:  994:                } else if(attr_state == 43 && CH(off) == _T('"')) {
    #####:  995:                    attr_state = 0;
        -:  996:                }
    #####:  997:                off++;
    #####:  998:            } else if(ISWHITESPACE(off)) {
    #####:  999:                if(attr_state == 0)
    #####: 1000:                    attr_state = 1;
    #####: 1001:                off++;
    #####: 1002:            } else if(attr_state <= 2 && CH(off) == _T('>')) {
        -: 1003:                /* End. */
        -: 1004:                goto done;
    #####: 1005:            } else if(attr_state <= 2 && CH(off) == _T('/') && off+1 < line_end && CH(off+1) == _T('>')) {
        -: 1006:                /* End with digraph '/>' */
        -: 1007:                off++;
        -: 1008:                goto done;
    #####: 1009:            } else if((attr_state == 1 || attr_state == 2) && (ISALPHA(off) || CH(off) == _T('_') || CH(off) == _T(':'))) {
    #####: 1010:                off++;
        -: 1011:                /* Attribute name */
    #####: 1012:                while(off < line_end && (ISALNUM(off) || ISANYOF(off, _T("_.:-"))))
    #####: 1013:                    off++;
        -: 1014:                attr_state = 2;
    #####: 1015:            } else if(attr_state == 2 && CH(off) == _T('=')) {
        -: 1016:                /* Attribute assignment sign */
    #####: 1017:                off++;
    #####: 1018:                attr_state = 3;
    #####: 1019:            } else if(attr_state == 3) {
        -: 1020:                /* Expecting start of attribute value. */
    #####: 1021:                if(CH(off) == _T('"'))
        -: 1022:                    attr_state = 43;
    #####: 1023:                else if(CH(off) == _T('\''))
        -: 1024:                    attr_state = 42;
    #####: 1025:                else if(!ISANYOF(off, _T("\"'=<>`"))  &&  !ISNEWLINE(off))
        -: 1026:                    attr_state = 41;
        -: 1027:                else
        -: 1028:                    return FALSE;
    #####: 1029:                off++;
        -: 1030:            } else {
        -: 1031:                /* Anything unexpected. */
        -: 1032:                return FALSE;
        -: 1033:            }
        -: 1034:        }
        -: 1035:
        -: 1036:        /* We have to be on a single line. See definition of start condition
        -: 1037:         * of HTML block, type 7. */
    #####: 1038:        if(n_lines == 0)
        -: 1039:            return FALSE;
        -: 1040:
    #####: 1041:        i++;
    #####: 1042:        if(i >= n_lines)
        -: 1043:            return FALSE;
        -: 1044:
    #####: 1045:        off = lines[i].beg;
    #####: 1046:        line_end = lines[i].end;
        -: 1047:
    #####: 1048:        if(attr_state == 0  ||  attr_state == 41)
    #####: 1049:            attr_state = 1;
        -: 1050:
    #####: 1051:        if(off >= max_end)
        -: 1052:            return FALSE;
        -: 1053:    }
        -: 1054:
    #####: 1055:done:
    #####: 1056:    if(off >= max_end)
        -: 1057:        return FALSE;
        -: 1058:
    #####: 1059:    *p_end = off+1;
        -: 1060:    return TRUE;
        -: 1061:}
        -: 1062:
        -: 1063:static int
    #####: 1064:md_is_html_comment(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1065:{
    #####: 1066:    OFF off = beg;
    #####: 1067:    int i = 0;
        -: 1068:
    #####: 1069:    MD_ASSERT(CH(beg) == _T('<'));
        -: 1070:
    #####: 1071:    if(off + 4 >= lines[0].end)
        -: 1072:        return FALSE;
    #####: 1073:    if(CH(off+1) != _T('!')  ||  CH(off+2) != _T('-')  ||  CH(off+3) != _T('-'))
        -: 1074:        return FALSE;
    #####: 1075:    off += 4;
        -: 1076:
        -: 1077:    /* ">" and "->" must follow the opening. */
    #####: 1078:    if(off < lines[0].end  &&  CH(off) == _T('>'))
        -: 1079:        return FALSE;
    #####: 1080:    if(off+1 < lines[0].end  &&  CH(off) == _T('-')  &&  CH(off+1) == _T('>'))
        -: 1081:        return FALSE;
        -: 1082:
        -: 1083:    while(1) {
    #####: 1084:        while(off + 2 < lines[i].end) {
    #####: 1085:            if(CH(off) == _T('-')  &&  CH(off+1) == _T('-')) {
    #####: 1086:                if(CH(off+2) == _T('>')) {
        -: 1087:                    /* Success. */
    #####: 1088:                    off += 2;
        -: 1089:                    goto done;
        -: 1090:                } else {
        -: 1091:                    /* "--" is prohibited inside the comment. */
        -: 1092:                    return FALSE;
        -: 1093:                }
        -: 1094:            }
        -: 1095:
    #####: 1096:            off++;
        -: 1097:        }
        -: 1098:
    #####: 1099:        i++;
    #####: 1100:        if(i >= n_lines)
        -: 1101:            return FALSE;
        -: 1102:
    #####: 1103:        off = lines[i].beg;
        -: 1104:
    #####: 1105:        if(off >= max_end)
        -: 1106:            return FALSE;
        -: 1107:    }
        -: 1108:
    #####: 1109:done:
    #####: 1110:    if(off >= max_end)
        -: 1111:        return FALSE;
        -: 1112:
    #####: 1113:    *p_end = off+1;
        -: 1114:    return TRUE;
        -: 1115:}
        -: 1116:
        -: 1117:static int
    #####: 1118:md_is_html_processing_instruction(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1119:{
    #####: 1120:    OFF off = beg;
    #####: 1121:    int i = 0;
        -: 1122:
    #####: 1123:    MD_ASSERT(CH(beg) == _T('<'));
        -: 1124:
    #####: 1125:    if(off + 2 >= lines[0].end)
        -: 1126:        return FALSE;
    #####: 1127:    if(CH(off+1) != _T('?'))
        -: 1128:        return FALSE;
        -: 1129:    off += 2;
        -: 1130:
        -: 1131:    while(1) {
    #####: 1132:        while(off + 1 < lines[i].end) {
    #####: 1133:            if(CH(off) == _T('?')  &&  CH(off+1) == _T('>')) {
        -: 1134:                /* Success. */
    #####: 1135:                off++;
        -: 1136:                goto done;
        -: 1137:            }
        -: 1138:
        -: 1139:            off++;
        -: 1140:        }
        -: 1141:
    #####: 1142:        i++;
    #####: 1143:        if(i >= n_lines)
        -: 1144:            return FALSE;
        -: 1145:
    #####: 1146:        off = lines[i].beg;
    #####: 1147:        if(off >= max_end)
        -: 1148:            return FALSE;
        -: 1149:    }
        -: 1150:
    #####: 1151:done:
    #####: 1152:    if(off >= max_end)
        -: 1153:        return FALSE;
        -: 1154:
    #####: 1155:    *p_end = off+1;
        -: 1156:    return TRUE;
        -: 1157:}
        -: 1158:
        -: 1159:static int
    #####: 1160:md_is_html_declaration(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1161:{
    #####: 1162:    OFF off = beg;
    #####: 1163:    int i = 0;
        -: 1164:
    #####: 1165:    MD_ASSERT(CH(beg) == _T('<'));
        -: 1166:
    #####: 1167:    if(off + 2 >= lines[0].end)
        -: 1168:        return FALSE;
    #####: 1169:    if(CH(off+1) != _T('!'))
        -: 1170:        return FALSE;
    #####: 1171:    off += 2;
        -: 1172:
        -: 1173:    /* Declaration name. */
    #####: 1174:    if(off >= lines[0].end  ||  !ISALPHA(off))
        -: 1175:        return FALSE;
    #####: 1176:    off++;
    #####: 1177:    while(off < lines[0].end  &&  ISALPHA(off))
    #####: 1178:        off++;
    #####: 1179:    if(off < lines[0].end  &&  !ISWHITESPACE(off))
        -: 1180:        return FALSE;
        -: 1181:
        -: 1182:    while(1) {
    #####: 1183:        while(off < lines[i].end) {
    #####: 1184:            if(CH(off) == _T('>')) {
        -: 1185:                /* Success. */
        -: 1186:                goto done;
        -: 1187:            }
        -: 1188:
    #####: 1189:            off++;
        -: 1190:        }
        -: 1191:
    #####: 1192:        i++;
    #####: 1193:        if(i >= n_lines)
        -: 1194:            return FALSE;
        -: 1195:
    #####: 1196:        off = lines[i].beg;
    #####: 1197:        if(off >= max_end)
        -: 1198:            return FALSE;
        -: 1199:    }
        -: 1200:
    #####: 1201:done:
    #####: 1202:    if(off >= max_end)
        -: 1203:        return FALSE;
        -: 1204:
    #####: 1205:    *p_end = off+1;
        -: 1206:    return TRUE;
        -: 1207:}
        -: 1208:
        -: 1209:static int
    #####: 1210:md_is_html_cdata(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1211:{
        -: 1212:    static const CHAR open_str[] = _T("<![CDATA[");
        -: 1213:    static const SZ open_size = SIZEOF_ARRAY(open_str) - 1;
        -: 1214:
    #####: 1215:    OFF off = beg;
    #####: 1216:    int i = 0;
        -: 1217:
    #####: 1218:    if(off + open_size >= lines[0].end)
        -: 1219:        return FALSE;
    #####: 1220:    if(memcmp(STR(off), open_str, open_size) != 0)
        -: 1221:        return FALSE;
        -: 1222:    off += open_size;
        -: 1223:
        -: 1224:    while(1) {
    #####: 1225:        while(off + 2 < lines[i].end) {
    #####: 1226:            if(CH(off) == _T(']')  &&  CH(off+1) == _T(']')  &&  CH(off+2) == _T('>')) {
        -: 1227:                /* Success. */
    #####: 1228:                off += 2;
        -: 1229:                goto done;
        -: 1230:            }
        -: 1231:
    #####: 1232:            off++;
        -: 1233:        }
        -: 1234:
    #####: 1235:        i++;
    #####: 1236:        if(i >= n_lines)
        -: 1237:            return FALSE;
        -: 1238:
    #####: 1239:        off = lines[i].beg;
    #####: 1240:        if(off >= max_end)
        -: 1241:            return FALSE;
        -: 1242:    }
        -: 1243:
    #####: 1244:done:
    #####: 1245:    if(off >= max_end)
        -: 1246:        return FALSE;
        -: 1247:
    #####: 1248:    *p_end = off+1;
        -: 1249:    return TRUE;
        -: 1250:}
        -: 1251:
        -: 1252:static int
    #####: 1253:md_is_html_any(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1254:{
    #####: 1255:    if(md_is_html_tag(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1256:        return TRUE;
    #####: 1257:    if(md_is_html_comment(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1258:        return TRUE;
    #####: 1259:    if(md_is_html_processing_instruction(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1260:        return TRUE;
    #####: 1261:    if(md_is_html_declaration(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1262:        return TRUE;
    #####: 1263:    if(md_is_html_cdata(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1264:        return TRUE;
        -: 1265:
    #####: 1266:    return FALSE;
        -: 1267:}
        -: 1268:
        -: 1269:
        -: 1270:/****************************
        -: 1271: ***  Recognizing Entity  ***
        -: 1272: ****************************/
        -: 1273:
        -: 1274:static int
    #####: 1275:md_is_hex_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1276:{
    #####: 1277:    OFF off = beg;
        -: 1278:
    #####: 1279:    while(off < max_end  &&  ISXDIGIT_(text[off])  &&  off - beg <= 8)
    #####: 1280:        off++;
        -: 1281:
    #####: 1282:    if(1 <= off - beg  &&  off - beg <= 8) {
    #####: 1283:        *p_end = off;
        -: 1284:        return TRUE;
        -: 1285:    } else {
        -: 1286:        return FALSE;
        -: 1287:    }
        -: 1288:}
        -: 1289:
        -: 1290:static int
        -: 1291:md_is_dec_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1292:{
        -: 1293:    OFF off = beg;
        -: 1294:
    #####: 1295:    while(off < max_end  &&  ISDIGIT_(text[off])  &&  off - beg <= 8)
    #####: 1296:        off++;
        -: 1297:
    #####: 1298:    if(1 <= off - beg  &&  off - beg <= 8) {
    #####: 1299:        *p_end = off;
        -: 1300:        return TRUE;
        -: 1301:    } else {
        -: 1302:        return FALSE;
        -: 1303:    }
        -: 1304:}
        -: 1305:
        -: 1306:static int
    #####: 1307:md_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1308:{
    #####: 1309:    OFF off = beg;
        -: 1310:
    #####: 1311:    if(off <= max_end  &&  ISALPHA_(text[off]))
    #####: 1312:        off++;
        -: 1313:    else
        -: 1314:        return FALSE;
        -: 1315:
    #####: 1316:    while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48)
    #####: 1317:        off++;
        -: 1318:
    #####: 1319:    if(2 <= off - beg  &&  off - beg <= 48) {
    #####: 1320:        *p_end = off;
        -: 1321:        return TRUE;
        -: 1322:    } else {
        -: 1323:        return FALSE;
        -: 1324:    }
        -: 1325:}
        -: 1326:
        -: 1327:static int
    #####: 1328:md_is_entity_str(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1329:{
        -: 1330:    int is_contents;
    #####: 1331:    OFF off = beg;
        -: 1332:
    #####: 1333:    MD_ASSERT(text[off] == _T('&'));
    #####: 1334:    off++;
        -: 1335:
    #####: 1336:    if(off+1 < max_end  &&  text[off] == _T('#')  &&  (text[off+1] == _T('x') || text[off+1] == _T('X')))
    #####: 1337:        is_contents = md_is_hex_entity_contents(ctx, text, off+2, max_end, &off);
    #####: 1338:    else if(off < max_end  &&  CH(off) == _T('#'))
    #####: 1339:        is_contents = md_is_dec_entity_contents(ctx, text, off+1, max_end, &off);
        -: 1340:    else
    #####: 1341:        is_contents = md_is_named_entity_contents(ctx, text, off, max_end, &off);
        -: 1342:
    #####: 1343:    if(is_contents  &&  off < max_end  &&  text[off] == _T(';')) {
    #####: 1344:        *p_end = off+1;
        -: 1345:        return TRUE;
        -: 1346:    } else {
        -: 1347:        return FALSE;
        -: 1348:    }
        -: 1349:}
        -: 1350:
        -: 1351:static inline int
        -: 1352:md_is_entity(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)
        -: 1353:{
    #####: 1354:    return md_is_entity_str(ctx, ctx->text, beg, max_end, p_end);
        -: 1355:}
        -: 1356:
        -: 1357:
        -: 1358:/******************************
        -: 1359: ***  Attribute Management  ***
        -: 1360: ******************************/
        -: 1361:
        -: 1362:typedef struct MD_ATTRIBUTE_BUILD_tag MD_ATTRIBUTE_BUILD;
        -: 1363:struct MD_ATTRIBUTE_BUILD_tag {
        -: 1364:    CHAR* text;
        -: 1365:    MD_TEXTTYPE* substr_types;
        -: 1366:    OFF* substr_offsets;
        -: 1367:    int substr_count;
        -: 1368:    int substr_alloc;
        -: 1369:    MD_TEXTTYPE trivial_types[1];
        -: 1370:    OFF trivial_offsets[2];
        -: 1371:};
        -: 1372:
        -: 1373:
        -: 1374:#define MD_BUILD_ATTR_NO_ESCAPES    0x0001
        -: 1375:
        -: 1376:static int
    #####: 1377:md_build_attr_append_substr(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build,
        -: 1378:                            MD_TEXTTYPE type, OFF off)
        -: 1379:{
    #####: 1380:    if(build->substr_count >= build->substr_alloc) {
        -: 1381:        MD_TEXTTYPE* new_substr_types;
        -: 1382:        OFF* new_substr_offsets;
        -: 1383:
    #####: 1384:        build->substr_alloc = (build->substr_alloc == 0 ? 8 : build->substr_alloc * 2);
        -: 1385:
    #####: 1386:        new_substr_types = (MD_TEXTTYPE*) realloc(build->substr_types,
    #####: 1387:                                    build->substr_alloc * sizeof(MD_TEXTTYPE));
    #####: 1388:        if(new_substr_types == NULL) {
    #####: 1389:            MD_LOG("realloc() failed.");
        -: 1390:            return -1;
        -: 1391:        }
        -: 1392:        /* Note +1 to reserve space for final offset (== raw_size). */
    #####: 1393:        new_substr_offsets = (OFF*) realloc(build->substr_offsets,
    #####: 1394:                                    (build->substr_alloc+1) * sizeof(OFF));
    #####: 1395:        if(new_substr_offsets == NULL) {
    #####: 1396:            MD_LOG("realloc() failed.");
    #####: 1397:            free(new_substr_types);
        -: 1398:            return -1;
        -: 1399:        }
        -: 1400:
    #####: 1401:        build->substr_types = new_substr_types;
    #####: 1402:        build->substr_offsets = new_substr_offsets;
        -: 1403:    }
        -: 1404:
    #####: 1405:    build->substr_types[build->substr_count] = type;
    #####: 1406:    build->substr_offsets[build->substr_count] = off;
    #####: 1407:    build->substr_count++;
        -: 1408:    return 0;
        -: 1409:}
        -: 1410:
        -: 1411:static void
    #####: 1412:md_free_attribute(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build)
        -: 1413:{
    #####: 1414:    if(build->substr_alloc > 0) {
    #####: 1415:        free(build->text);
    #####: 1416:        free(build->substr_types);
    #####: 1417:        free(build->substr_offsets);
        -: 1418:    }
    #####: 1419:}
        -: 1420:
        -: 1421:static int
    #####: 1422:md_build_attribute(MD_CTX* ctx, const CHAR* raw_text, SZ raw_size,
        -: 1423:                   unsigned flags, MD_ATTRIBUTE* attr, MD_ATTRIBUTE_BUILD* build)
        -: 1424:{
        -: 1425:    OFF raw_off, off;
        -: 1426:    int is_trivial;
    #####: 1427:    int ret = 0;
        -: 1428:
    #####: 1429:    memset(build, 0, sizeof(MD_ATTRIBUTE_BUILD));
        -: 1430:
        -: 1431:    /* If there is no backslash and no ampersand, build trivial attribute
        -: 1432:     * without any malloc(). */
    #####: 1433:    is_trivial = TRUE;
    #####: 1434:    for(raw_off = 0; raw_off < raw_size; raw_off++) {
    #####: 1435:        if(ISANYOF3_(raw_text[raw_off], _T('\\'), _T('&'), _T('\0'))) {
        -: 1436:            is_trivial = FALSE;
        -: 1437:            break;
        -: 1438:        }
        -: 1439:    }
        -: 1440:
    #####: 1441:    if(is_trivial) {
    #####: 1442:        build->text = (CHAR*) (raw_size ? raw_text : NULL);
    #####: 1443:        build->substr_types = build->trivial_types;
    #####: 1444:        build->substr_offsets = build->trivial_offsets;
    #####: 1445:        build->substr_count = 1;
    #####: 1446:        build->substr_alloc = 0;
    #####: 1447:        build->trivial_types[0] = MD_TEXT_NORMAL;
    #####: 1448:        build->trivial_offsets[0] = 0;
    #####: 1449:        build->trivial_offsets[1] = raw_size;
    #####: 1450:        off = raw_size;
        -: 1451:    } else {
    #####: 1452:        build->text = (CHAR*) malloc(raw_size * sizeof(CHAR));
    #####: 1453:        if(build->text == NULL) {
    #####: 1454:            MD_LOG("malloc() failed.");
        -: 1455:            goto abort;
        -: 1456:        }
        -: 1457:
        -: 1458:        raw_off = 0;
        -: 1459:        off = 0;
        -: 1460:
    #####: 1461:        while(raw_off < raw_size) {
    #####: 1462:            if(raw_text[raw_off] == _T('\0')) {
    #####: 1463:                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NULLCHAR, off));
    #####: 1464:                memcpy(build->text + off, raw_text + raw_off, 1);
    #####: 1465:                off++;
    #####: 1466:                raw_off++;
    #####: 1467:                continue;
        -: 1468:            }
        -: 1469:
    #####: 1470:            if(raw_text[raw_off] == _T('&')) {
    #####: 1471:                OFF ent_end;
        -: 1472:
    #####: 1473:                if(md_is_entity_str(ctx, raw_text, raw_off, raw_size, &ent_end)) {
    #####: 1474:                    MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_ENTITY, off));
    #####: 1475:                    memcpy(build->text + off, raw_text + raw_off, ent_end - raw_off);
    #####: 1476:                    off += ent_end - raw_off;
    #####: 1477:                    raw_off = ent_end;
    #####: 1478:                    continue;
        -: 1479:                }
        -: 1480:            }
        -: 1481:
    #####: 1482:            if(build->substr_count == 0  ||  build->substr_types[build->substr_count-1] != MD_TEXT_NORMAL)
    #####: 1483:                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NORMAL, off));
        -: 1484:
    #####: 1485:            if(!(flags & MD_BUILD_ATTR_NO_ESCAPES)  &&
    #####: 1486:               raw_text[raw_off] == _T('\\')  &&  raw_off+1 < raw_size  &&
    #####: 1487:               (ISPUNCT_(raw_text[raw_off+1]) || ISNEWLINE_(raw_text[raw_off+1])))
    #####: 1488:                raw_off++;
        -: 1489:
    #####: 1490:            build->text[off++] = raw_text[raw_off++];
        -: 1491:        }
    #####: 1492:        build->substr_offsets[build->substr_count] = off;
        -: 1493:    }
        -: 1494:
    #####: 1495:    attr->text = build->text;
    #####: 1496:    attr->size = off;
    #####: 1497:    attr->substr_offsets = build->substr_offsets;
    #####: 1498:    attr->substr_types = build->substr_types;
    #####: 1499:    return 0;
        -: 1500:
    #####: 1501:abort:
    #####: 1502:    md_free_attribute(ctx, build);
    #####: 1503:    return -1;
        -: 1504:}
        -: 1505:
        -: 1506:
        -: 1507:/*********************************************
        -: 1508: ***  Dictionary of Reference Definitions  ***
        -: 1509: *********************************************/
        -: 1510:
        -: 1511:#define MD_FNV1A_BASE       2166136261
        -: 1512:#define MD_FNV1A_PRIME      16777619
        -: 1513:
        -: 1514:static inline unsigned
        -: 1515:md_fnv1a(unsigned base, const void* data, size_t n)
        -: 1516:{
    #####: 1517:    const unsigned char* buf = (const unsigned char*) data;
    #####: 1518:    unsigned hash = base;
        -: 1519:    size_t i;
        -: 1520:
    #####: 1521:    for(i = 0; i < n; i++) {
    #####: 1522:        hash ^= buf[i];
    #####: 1523:        hash *= MD_FNV1A_PRIME;
        -: 1524:    }
        -: 1525:
        -: 1526:    return hash;
        -: 1527:}
        -: 1528:
        -: 1529:
        -: 1530:struct MD_REF_DEF_tag {
        -: 1531:    CHAR* label;
        -: 1532:    CHAR* title;
        -: 1533:    unsigned hash;
        -: 1534:    SZ label_size                   : 24;
        -: 1535:    unsigned label_needs_free       :  1;
        -: 1536:    unsigned title_needs_free       :  1;
        -: 1537:    SZ title_size;
        -: 1538:    OFF dest_beg;
        -: 1539:    OFF dest_end;
        -: 1540:};
        -: 1541:
        -: 1542:/* Label equivalence is quite complicated with regards to whitespace and case
        -: 1543: * folding. This complicates computing a hash of it as well as direct comparison
        -: 1544: * of two labels. */
        -: 1545:
        -: 1546:static unsigned
    #####: 1547:md_link_label_hash(const CHAR* label, SZ size)
        -: 1548:{
    #####: 1549:    unsigned hash = MD_FNV1A_BASE;
        -: 1550:    OFF off;
    #####: 1551:    int codepoint;
    #####: 1552:    int is_whitespace = FALSE;
        -: 1553:
    #####: 1554:    off = md_skip_unicode_whitespace(label, 0, size);
    #####: 1555:    while(off < size) {
    #####: 1556:        SZ char_size;
        -: 1557:
    #####: 1558:        codepoint = md_decode_unicode(label, off, size, &char_size);
    #####: 1559:        is_whitespace = ISUNICODEWHITESPACE_(codepoint) || ISNEWLINE_(label[off]);
        -: 1560:
        -: 1561:        if(is_whitespace) {
    #####: 1562:            codepoint = ' ';
    #####: 1563:            hash = md_fnv1a(hash, &codepoint, 1 * sizeof(int));
        -: 1564:
    #####: 1565:            off = md_skip_unicode_whitespace(label, off, size);
        -: 1566:        } else {
    #####: 1567:            MD_UNICODE_FOLD_INFO fold_info;
        -: 1568:
    #####: 1569:            md_get_unicode_fold_info(codepoint, &fold_info);
    #####: 1570:            hash = md_fnv1a(hash, fold_info.codepoints, fold_info.n_codepoints * sizeof(int));
        -: 1571:
    #####: 1572:            off += char_size;
        -: 1573:        }
        -: 1574:    }
        -: 1575:
    #####: 1576:    if(!is_whitespace) {
    #####: 1577:        codepoint = ' ';
        -: 1578:        hash = md_fnv1a(hash, &codepoint, 1 * sizeof(int));
        -: 1579:    }
        -: 1580:
    #####: 1581:    return hash;
        -: 1582:}
        -: 1583:
        -: 1584:static int
    #####: 1585:md_link_label_cmp(const CHAR* a_label, SZ a_size, const CHAR* b_label, SZ b_size)
        -: 1586:{
        -: 1587:    OFF a_off;
        -: 1588:    OFF b_off;
        -: 1589:
        -: 1590:    /* The slow path, with Unicode case folding and Unicode whitespace collapsing. */
    #####: 1591:    a_off = md_skip_unicode_whitespace(a_label, 0, a_size);
    #####: 1592:    b_off = md_skip_unicode_whitespace(b_label, 0, b_size);
    #####: 1593:    while(a_off < a_size  ||  b_off < b_size) {
        -: 1594:        int a_codepoint, b_codepoint;
    #####: 1595:        SZ a_char_size, b_char_size;
        -: 1596:        int a_is_whitespace, b_is_whitespace;
        -: 1597:
    #####: 1598:        if(a_off < a_size) {
    #####: 1599:            a_codepoint = md_decode_unicode(a_label, a_off, a_size, &a_char_size);
    #####: 1600:            a_is_whitespace = ISUNICODEWHITESPACE_(a_codepoint) || ISNEWLINE_(a_label[a_off]);
        -: 1601:        } else {
        -: 1602:            /* Treat end of label as a whitespace. */
        -: 1603:            a_codepoint = -1;
        -: 1604:            a_is_whitespace = TRUE;
        -: 1605:        }
        -: 1606:
    #####: 1607:        if(b_off < b_size) {
    #####: 1608:            b_codepoint = md_decode_unicode(b_label, b_off, b_size, &b_char_size);
    #####: 1609:            b_is_whitespace = ISUNICODEWHITESPACE_(b_codepoint) || ISNEWLINE_(b_label[b_off]);
        -: 1610:        } else {
        -: 1611:            /* Treat end of label as a whitespace. */
        -: 1612:            b_codepoint = -1;
        -: 1613:            b_is_whitespace = TRUE;
        -: 1614:        }
        -: 1615:
    #####: 1616:        if(a_is_whitespace || b_is_whitespace) {
    #####: 1617:            if(!a_is_whitespace || !b_is_whitespace)
    #####: 1618:                return (a_is_whitespace ? -1 : +1);
        -: 1619:
    #####: 1620:            a_off = md_skip_unicode_whitespace(a_label, a_off, a_size);
    #####: 1621:            b_off = md_skip_unicode_whitespace(b_label, b_off, b_size);
        -: 1622:        } else {
    #####: 1623:            MD_UNICODE_FOLD_INFO a_fold_info, b_fold_info;
        -: 1624:            int cmp;
        -: 1625:
    #####: 1626:            md_get_unicode_fold_info(a_codepoint, &a_fold_info);
    #####: 1627:            md_get_unicode_fold_info(b_codepoint, &b_fold_info);
        -: 1628:
    #####: 1629:            if(a_fold_info.n_codepoints != b_fold_info.n_codepoints)
    #####: 1630:                return (a_fold_info.n_codepoints - b_fold_info.n_codepoints);
    #####: 1631:            cmp = memcmp(a_fold_info.codepoints, b_fold_info.codepoints, a_fold_info.n_codepoints * sizeof(int));
    #####: 1632:            if(cmp != 0)
        -: 1633:                return cmp;
        -: 1634:
    #####: 1635:            a_off += a_char_size;
    #####: 1636:            b_off += b_char_size;
        -: 1637:        }
        -: 1638:    }
        -: 1639:
        -: 1640:    return 0;
        -: 1641:}
        -: 1642:
        -: 1643:typedef struct MD_REF_DEF_LIST_tag MD_REF_DEF_LIST;
        -: 1644:struct MD_REF_DEF_LIST_tag {
        -: 1645:    int n_ref_defs;
        -: 1646:    int alloc_ref_defs;
        -: 1647:    MD_REF_DEF* ref_defs[];  /* Valid items always  point into ctx->ref_defs[] */
        -: 1648:};
        -: 1649:
        -: 1650:static int
    #####: 1651:md_ref_def_cmp(const void* a, const void* b)
        -: 1652:{
    #####: 1653:    const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;
    #####: 1654:    const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;
        -: 1655:
    #####: 1656:    if(a_ref->hash < b_ref->hash)
        -: 1657:        return -1;
    #####: 1658:    else if(a_ref->hash > b_ref->hash)
        -: 1659:        return +1;
        -: 1660:    else
    #####: 1661:        return md_link_label_cmp(a_ref->label, a_ref->label_size, b_ref->label, b_ref->label_size);
        -: 1662:}
        -: 1663:
        -: 1664:static int
    #####: 1665:md_ref_def_cmp_stable(const void* a, const void* b)
        -: 1666:{
        -: 1667:    int cmp;
        -: 1668:
    #####: 1669:    cmp = md_ref_def_cmp(a, b);
        -: 1670:
        -: 1671:    /* Ensure stability of the sorting. */
    #####: 1672:    if(cmp == 0) {
    #####: 1673:        const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;
    #####: 1674:        const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;
        -: 1675:
    #####: 1676:        if(a_ref < b_ref)
        -: 1677:            cmp = -1;
    #####: 1678:        else if(a_ref > b_ref)
        -: 1679:            cmp = +1;
        -: 1680:        else
    #####: 1681:            cmp = 0;
        -: 1682:    }
        -: 1683:
    #####: 1684:    return cmp;
        -: 1685:}
        -: 1686:
        -: 1687:static int
        1: 1688:md_build_ref_def_hashtable(MD_CTX* ctx)
        -: 1689:{
        -: 1690:    int i, j;
        -: 1691:
        1: 1692:    if(ctx->n_ref_defs == 0)
        -: 1693:        return 0;
        -: 1694:
    #####: 1695:    ctx->ref_def_hashtable_size = (ctx->n_ref_defs * 5) / 4;
    #####: 1696:    ctx->ref_def_hashtable = malloc(ctx->ref_def_hashtable_size * sizeof(void*));
    #####: 1697:    if(ctx->ref_def_hashtable == NULL) {
    #####: 1698:        MD_LOG("malloc() failed.");
        -: 1699:        goto abort;
        -: 1700:    }
    #####: 1701:    memset(ctx->ref_def_hashtable, 0, ctx->ref_def_hashtable_size * sizeof(void*));
        -: 1702:
        -: 1703:    /* Each member of ctx->ref_def_hashtable[] can be:
        -: 1704:     *  -- NULL,
        -: 1705:     *  -- pointer to the MD_REF_DEF in ctx->ref_defs[], or
        -: 1706:     *  -- pointer to a MD_REF_DEF_LIST, which holds multiple pointers to
        -: 1707:     *     such MD_REF_DEFs.
        -: 1708:     */
    #####: 1709:    for(i = 0; i < ctx->n_ref_defs; i++) {
    #####: 1710:        MD_REF_DEF* def = &ctx->ref_defs[i];
        -: 1711:        void* bucket;
        -: 1712:        MD_REF_DEF_LIST* list;
        -: 1713:
    #####: 1714:        def->hash = md_link_label_hash(def->label, def->label_size);
    #####: 1715:        bucket = ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size];
        -: 1716:
    #####: 1717:        if(bucket == NULL) {
    #####: 1718:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = def;
    #####: 1719:            continue;
        -: 1720:        }
        -: 1721:
    #####: 1722:        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {
        -: 1723:            /* The bucket already contains one ref. def. Lets see whether it
        -: 1724:             * is the same label (ref. def. duplicate) or different one
        -: 1725:             * (hash conflict). */
    #####: 1726:            MD_REF_DEF* old_def = (MD_REF_DEF*) bucket;
        -: 1727:
    #####: 1728:            if(md_link_label_cmp(def->label, def->label_size, old_def->label, old_def->label_size) == 0) {
        -: 1729:                /* Ignore this ref. def. */
    #####: 1730:                continue;
        -: 1731:            }
        -: 1732:
        -: 1733:            /* Make the bucket capable of holding more ref. defs. */
    #####: 1734:            list = (MD_REF_DEF_LIST*) malloc(sizeof(MD_REF_DEF_LIST) + 4 * sizeof(MD_REF_DEF));
    #####: 1735:            if(list == NULL) {
    #####: 1736:                MD_LOG("malloc() failed.");
        -: 1737:                goto abort;
        -: 1738:            }
    #####: 1739:            list->ref_defs[0] = old_def;
    #####: 1740:            list->ref_defs[1] = def;
    #####: 1741:            list->n_ref_defs = 2;
    #####: 1742:            list->alloc_ref_defs = 4;
    #####: 1743:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;
    #####: 1744:            continue;
        -: 1745:        }
        -: 1746:
        -: 1747:        /* Append the def to the bucket list. */
    #####: 1748:        list = (MD_REF_DEF_LIST*) bucket;
    #####: 1749:        if(list->n_ref_defs >= list->alloc_ref_defs) {
    #####: 1750:            MD_REF_DEF_LIST* list_tmp = (MD_REF_DEF_LIST*) realloc(list,
    #####: 1751:                        sizeof(MD_REF_DEF_LIST) + 2 * list->alloc_ref_defs * sizeof(MD_REF_DEF));
    #####: 1752:            if(list_tmp == NULL) {
    #####: 1753:                MD_LOG("realloc() failed.");
        -: 1754:                goto abort;
        -: 1755:            }
    #####: 1756:            list = list_tmp;
    #####: 1757:            list->alloc_ref_defs *= 2;
    #####: 1758:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;
        -: 1759:        }
        -: 1760:
    #####: 1761:        list->ref_defs[list->n_ref_defs] = def;
    #####: 1762:        list->n_ref_defs++;
        -: 1763:    }
        -: 1764:
        -: 1765:    /* Sort the complex buckets so we can use bsearch() with them. */
    #####: 1766:    for(i = 0; i < ctx->ref_def_hashtable_size; i++) {
    #####: 1767:        void* bucket = ctx->ref_def_hashtable[i];
        -: 1768:        MD_REF_DEF_LIST* list;
        -: 1769:
    #####: 1770:        if(bucket == NULL)
    #####: 1771:            continue;
    #####: 1772:        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)
    #####: 1773:            continue;
        -: 1774:
    #####: 1775:        list = (MD_REF_DEF_LIST*) bucket;
    #####: 1776:        qsort(list->ref_defs, list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp_stable);
        -: 1777:
        -: 1778:        /* Disable duplicates. */
    #####: 1779:        for(j = 1; j < list->n_ref_defs; j++) {
    #####: 1780:            if(md_ref_def_cmp(&list->ref_defs[j-1], &list->ref_defs[j]) == 0)
    #####: 1781:                list->ref_defs[j] = list->ref_defs[j-1];
        -: 1782:        }
        -: 1783:    }
        -: 1784:
        -: 1785:    return 0;
        -: 1786:
        -: 1787:abort:
        -: 1788:    return -1;
        -: 1789:}
        -: 1790:
        -: 1791:static void
    #####: 1792:md_free_ref_def_hashtable(MD_CTX* ctx)
        -: 1793:{
    #####: 1794:    if(ctx->ref_def_hashtable != NULL) {
        -: 1795:        int i;
        -: 1796:
    #####: 1797:        for(i = 0; i < ctx->ref_def_hashtable_size; i++) {
    #####: 1798:            void* bucket = ctx->ref_def_hashtable[i];
    #####: 1799:            if(bucket == NULL)
    #####: 1800:                continue;
    #####: 1801:            if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)
    #####: 1802:                continue;
    #####: 1803:            free(bucket);
        -: 1804:        }
        -: 1805:
    #####: 1806:        free(ctx->ref_def_hashtable);
        -: 1807:    }
    #####: 1808:}
        -: 1809:
        -: 1810:static const MD_REF_DEF*
    #####: 1811:md_lookup_ref_def(MD_CTX* ctx, const CHAR* label, SZ label_size)
        -: 1812:{
        -: 1813:    unsigned hash;
        -: 1814:    void* bucket;
        -: 1815:
    #####: 1816:    if(ctx->ref_def_hashtable_size == 0)
        -: 1817:        return NULL;
        -: 1818:
    #####: 1819:    hash = md_link_label_hash(label, label_size);
    #####: 1820:    bucket = ctx->ref_def_hashtable[hash % ctx->ref_def_hashtable_size];
        -: 1821:
    #####: 1822:    if(bucket == NULL) {
        -: 1823:        return NULL;
    #####: 1824:    } else if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {
    #####: 1825:        const MD_REF_DEF* def = (MD_REF_DEF*) bucket;
        -: 1826:
    #####: 1827:        if(md_link_label_cmp(def->label, def->label_size, label, label_size) == 0)
        -: 1828:            return def;
        -: 1829:        else
    #####: 1830:            return NULL;
        -: 1831:    } else {
    #####: 1832:        MD_REF_DEF_LIST* list = (MD_REF_DEF_LIST*) bucket;
    #####: 1833:        MD_REF_DEF key_buf;
    #####: 1834:        const MD_REF_DEF* key = &key_buf;
        -: 1835:        const MD_REF_DEF** ret;
        -: 1836:
    #####: 1837:        key_buf.label = (CHAR*) label;
    #####: 1838:        key_buf.label_size = label_size;
    #####: 1839:        key_buf.hash = md_link_label_hash(key_buf.label, key_buf.label_size);
        -: 1840:
    #####: 1841:        ret = (const MD_REF_DEF**) bsearch(&key, list->ref_defs,
    #####: 1842:                    list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp);
    #####: 1843:        if(ret != NULL)
    #####: 1844:            return *ret;
        -: 1845:        else
        -: 1846:            return NULL;
        -: 1847:    }
        -: 1848:}
        -: 1849:
        -: 1850:
        -: 1851:/***************************
        -: 1852: ***  Recognizing Links  ***
        -: 1853: ***************************/
        -: 1854:
        -: 1855:/* Note this code is partially shared between processing inlines and blocks
        -: 1856: * as reference definitions and links share some helper parser functions.
        -: 1857: */
        -: 1858:
        -: 1859:typedef struct MD_LINK_ATTR_tag MD_LINK_ATTR;
        -: 1860:struct MD_LINK_ATTR_tag {
        -: 1861:    OFF dest_beg;
        -: 1862:    OFF dest_end;
        -: 1863:
        -: 1864:    CHAR* title;
        -: 1865:    SZ title_size;
        -: 1866:    int title_needs_free;
        -: 1867:};
        -: 1868:
        -: 1869:
        -: 1870:static int
    #####: 1871:md_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,
        -: 1872:                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,
        -: 1873:                 OFF* p_contents_beg, OFF* p_contents_end)
        -: 1874:{
    #####: 1875:    OFF off = beg;
    #####: 1876:    OFF contents_beg = 0;
    #####: 1877:    OFF contents_end = 0;
    #####: 1878:    int line_index = 0;
    #####: 1879:    int len = 0;
        -: 1880:
    #####: 1881:    if(CH(off) != _T('['))
        -: 1882:        return FALSE;
    #####: 1883:    off++;
        -: 1884:
    #####: 1885:    while(line_index < n_lines) {
    #####: 1886:        OFF line_end = lines[line_index].end;
        -: 1887:
    #####: 1888:        while(off < line_end) {
    #####: 1889:            if(CH(off) == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
    #####: 1890:                if(contents_end == 0)
    #####: 1891:                    contents_beg = off;
    #####: 1892:                contents_end = off + 2;
    #####: 1893:                off += 2;
    #####: 1894:            } else if(CH(off) == _T('[')) {
        -: 1895:                return FALSE;
    #####: 1896:            } else if(CH(off) == _T(']')) {
    #####: 1897:                if(contents_beg < contents_end) {
        -: 1898:                    /* Success. */
    #####: 1899:                    *p_contents_beg = contents_beg;
    #####: 1900:                    *p_contents_end = contents_end;
    #####: 1901:                    *p_end = off+1;
    #####: 1902:                    *p_end_line_index = line_index;
        -: 1903:                    return TRUE;
        -: 1904:                } else {
        -: 1905:                    /* Link label must have some non-whitespace contents. */
        -: 1906:                    return FALSE;
        -: 1907:                }
        -: 1908:            } else {
        -: 1909:                int codepoint;
    #####: 1910:                SZ char_size;
        -: 1911:
    #####: 1912:                codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size);
    #####: 1913:                if(!ISUNICODEWHITESPACE_(codepoint)) {
    #####: 1914:                    if(contents_end == 0) {
    #####: 1915:                        contents_beg = off;
    #####: 1916:                        *p_beg_line_index = line_index;
        -: 1917:                    }
    #####: 1918:                    contents_end = off + char_size;
        -: 1919:                }
        -: 1920:
    #####: 1921:                off += char_size;
        -: 1922:            }
        -: 1923:
    #####: 1924:            len++;
    #####: 1925:            if(len > 999)
        -: 1926:                return FALSE;
        -: 1927:        }
        -: 1928:
    #####: 1929:        line_index++;
    #####: 1930:        len++;
    #####: 1931:        off = lines[line_index].beg;
        -: 1932:    }
        -: 1933:
        -: 1934:    return FALSE;
        -: 1935:}
        -: 1936:
        -: 1937:static int
    #####: 1938:md_is_link_destination_A(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,
        -: 1939:                         OFF* p_contents_beg, OFF* p_contents_end)
        -: 1940:{
    #####: 1941:    OFF off = beg;
        -: 1942:
    #####: 1943:    if(off >= max_end  ||  CH(off) != _T('<'))
        -: 1944:        return FALSE;
    #####: 1945:    off++;
        -: 1946:
    #####: 1947:    while(off < max_end) {
    #####: 1948:        if(CH(off) == _T('\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {
    #####: 1949:            off += 2;
    #####: 1950:            continue;
        -: 1951:        }
        -: 1952:
    #####: 1953:        if(ISWHITESPACE(off)  ||  CH(off) == _T('<'))
        -: 1954:            return FALSE;
        -: 1955:
    #####: 1956:        if(CH(off) == _T('>')) {
        -: 1957:            /* Success. */
    #####: 1958:            *p_contents_beg = beg+1;
    #####: 1959:            *p_contents_end = off;
    #####: 1960:            *p_end = off+1;
    #####: 1961:            return TRUE;
        -: 1962:        }
        -: 1963:
    #####: 1964:        off++;
        -: 1965:    }
        -: 1966:
        -: 1967:    return FALSE;
        -: 1968:}
        -: 1969:
        -: 1970:static int
    #####: 1971:md_is_link_destination_B(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,
        -: 1972:                         OFF* p_contents_beg, OFF* p_contents_end)
        -: 1973:{
    #####: 1974:    OFF off = beg;
    #####: 1975:    int parenthesis_level = 0;
        -: 1976:
    #####: 1977:    while(off < max_end) {
    #####: 1978:        if(CH(off) == _T('\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {
    #####: 1979:            off += 2;
    #####: 1980:            continue;
        -: 1981:        }
        -: 1982:
    #####: 1983:        if(ISWHITESPACE(off) || ISCNTRL(off))
        -: 1984:            break;
        -: 1985:
        -: 1986:        /* Link destination may include balanced pairs of unescaped '(' ')'.
        -: 1987:         * Note we limit the maximal nesting level by 32 to protect us from
        -: 1988:         * https://github.com/jgm/cmark/issues/214 */
    #####: 1989:        if(CH(off) == _T('(')) {
    #####: 1990:            parenthesis_level++;
    #####: 1991:            if(parenthesis_level > 32)
        -: 1992:                return FALSE;
    #####: 1993:        } else if(CH(off) == _T(')')) {
    #####: 1994:            if(parenthesis_level == 0)
        -: 1995:                break;
    #####: 1996:            parenthesis_level--;
        -: 1997:        }
        -: 1998:
    #####: 1999:        off++;
        -: 2000:    }
        -: 2001:
    #####: 2002:    if(parenthesis_level != 0  ||  off == beg)
        -: 2003:        return FALSE;
        -: 2004:
        -: 2005:    /* Success. */
    #####: 2006:    *p_contents_beg = beg;
    #####: 2007:    *p_contents_end = off;
    #####: 2008:    *p_end = off;
    #####: 2009:    return TRUE;
        -: 2010:}
        -: 2011:
        -: 2012:static int
    #####: 2013:md_is_link_title(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,
        -: 2014:                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,
        -: 2015:                 OFF* p_contents_beg, OFF* p_contents_end)
        -: 2016:{
    #####: 2017:    OFF off = beg;
        -: 2018:    CHAR closer_char;
    #####: 2019:    int line_index = 0;
        -: 2020:
        -: 2021:    /* Optional white space with up to one line break. */
    #####: 2022:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2023:        off++;
    #####: 2024:    if(off >= lines[line_index].end) {
    #####: 2025:        line_index++;
    #####: 2026:        if(line_index >= n_lines)
        -: 2027:            return FALSE;
    #####: 2028:        off = lines[line_index].beg;
        -: 2029:    }
        -: 2030:
    #####: 2031:    *p_beg_line_index = line_index;
        -: 2032:
        -: 2033:    /* First char determines how to detect end of it. */
    #####: 2034:    switch(CH(off)) {
        -: 2035:        case _T('"'):   closer_char = _T('"'); break;
    #####: 2036:        case _T('\''):  closer_char = _T('\''); break;
    #####: 2037:        case _T('('):   closer_char = _T(')'); break;
        -: 2038:        default:        return FALSE;
        -: 2039:    }
    #####: 2040:    off++;
        -: 2041:
    #####: 2042:    *p_contents_beg = off;
        -: 2043:
    #####: 2044:    while(line_index < n_lines) {
    #####: 2045:        OFF line_end = lines[line_index].end;
        -: 2046:
    #####: 2047:        while(off < line_end) {
    #####: 2048:            if(CH(off) == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
        -: 2049:                off++;
    #####: 2050:            } else if(CH(off) == closer_char) {
        -: 2051:                /* Success. */
    #####: 2052:                *p_contents_end = off;
    #####: 2053:                *p_end = off+1;
    #####: 2054:                *p_end_line_index = line_index;
        -: 2055:                return TRUE;
        -: 2056:            }
        -: 2057:
    #####: 2058:            off++;
        -: 2059:        }
        -: 2060:
    #####: 2061:        line_index++;
        -: 2062:    }
        -: 2063:
        -: 2064:    return FALSE;
        -: 2065:}
        -: 2066:
        -: 2067:/* Returns 0 if it is not a reference definition.
        -: 2068: *
        -: 2069: * Returns N > 0 if it is not a reference definition (then N corresponds
        -: 2070: * to the number of lines forming it). In this case the definition is stored
        -: 2071: * for resolving any links referring to it.
        -: 2072: *
        -: 2073: * If there is an error (cannot alloc memory for storing it), we return -1.
        -: 2074: */
        -: 2075:static int
    #####: 2076:md_is_link_reference_definition_helper(
        -: 2077:            MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2078:            int (*is_link_dest_fn)(MD_CTX*, OFF, OFF, OFF*, OFF*, OFF*))
        -: 2079:{
    #####: 2080:    OFF label_contents_beg;
    #####: 2081:    OFF label_contents_end;
    #####: 2082:    int label_contents_line_index = -1;
        -: 2083:    int label_is_multiline;
    #####: 2084:    CHAR* label;
    #####: 2085:    SZ label_size;
    #####: 2086:    int label_needs_free = FALSE;
    #####: 2087:    OFF dest_contents_beg;
    #####: 2088:    OFF dest_contents_end;
    #####: 2089:    OFF title_contents_beg;
    #####: 2090:    OFF title_contents_end;
    #####: 2091:    int title_contents_line_index;
        -: 2092:    int title_is_multiline;
    #####: 2093:    OFF off;
    #####: 2094:    int line_index = 0;
    #####: 2095:    int tmp_line_index;
        -: 2096:    MD_REF_DEF* def;
        -: 2097:    int ret;
        -: 2098:
        -: 2099:    /* Link label. */
    #####: 2100:    if(!md_is_link_label(ctx, lines, n_lines, lines[0].beg,
        -: 2101:                &off, &label_contents_line_index, &line_index,
        -: 2102:                &label_contents_beg, &label_contents_end))
        -: 2103:        return FALSE;
    #####: 2104:    label_is_multiline = (label_contents_line_index != line_index);
        -: 2105:
        -: 2106:    /* Colon. */
    #####: 2107:    if(off >= lines[line_index].end  ||  CH(off) != _T(':'))
        -: 2108:        return FALSE;
    #####: 2109:    off++;
        -: 2110:
        -: 2111:    /* Optional white space with up to one line break. */
    #####: 2112:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2113:        off++;
    #####: 2114:    if(off >= lines[line_index].end) {
    #####: 2115:        line_index++;
    #####: 2116:        if(line_index >= n_lines)
        -: 2117:            return FALSE;
    #####: 2118:        off = lines[line_index].beg;
        -: 2119:    }
        -: 2120:
        -: 2121:    /* Link destination. */
    #####: 2122:    if(!is_link_dest_fn(ctx, off, lines[line_index].end,
        -: 2123:                        &off, &dest_contents_beg, &dest_contents_end))
        -: 2124:        return FALSE;
        -: 2125:
        -: 2126:    /* (Optional) title. Note we interpret it as an title only if nothing
        -: 2127:     * more follows on its last line. */
    #####: 2128:    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,
        -: 2129:                &off, &title_contents_line_index, &tmp_line_index,
        -: 2130:                &title_contents_beg, &title_contents_end)
    #####: 2131:        &&  off >= lines[line_index + tmp_line_index].end)
        -: 2132:    {
    #####: 2133:        title_is_multiline = (tmp_line_index != title_contents_line_index);
    #####: 2134:        title_contents_line_index += line_index;
    #####: 2135:        line_index += tmp_line_index;
        -: 2136:    } else {
        -: 2137:        /* Not a title. */
    #####: 2138:        title_is_multiline = FALSE;
    #####: 2139:        title_contents_beg = off;
    #####: 2140:        title_contents_end = off;
    #####: 2141:        title_contents_line_index = 0;
        -: 2142:    }
        -: 2143:
        -: 2144:    /* Nothing more can follow on the last line. */
    #####: 2145:    if(off < lines[line_index].end)
        -: 2146:        return FALSE;
        -: 2147:
        -: 2148:    /* Construct label. */
    #####: 2149:    if(!label_is_multiline) {
    #####: 2150:        label = (CHAR*) STR(label_contents_beg);
    #####: 2151:        label_size = label_contents_end - label_contents_beg;
    #####: 2152:        label_needs_free = FALSE;
        -: 2153:    } else {
    #####: 2154:        MD_CHECK(md_merge_lines_alloc(ctx, label_contents_beg, label_contents_end,
        -: 2155:                    lines + label_contents_line_index, n_lines - label_contents_line_index,
        -: 2156:                    _T(' '), &label, &label_size));
        -: 2157:        label_needs_free = TRUE;
        -: 2158:    }
        -: 2159:
        -: 2160:    /* Store the reference definition. */
    #####: 2161:    if(ctx->n_ref_defs >= ctx->alloc_ref_defs) {
        -: 2162:        MD_REF_DEF* new_defs;
        -: 2163:
    #####: 2164:        ctx->alloc_ref_defs = (ctx->alloc_ref_defs > 0 ? ctx->alloc_ref_defs * 2 : 16);
    #####: 2165:        new_defs = (MD_REF_DEF*) realloc(ctx->ref_defs, ctx->alloc_ref_defs * sizeof(MD_REF_DEF));
    #####: 2166:        if(new_defs == NULL) {
    #####: 2167:            MD_LOG("realloc() failed.");
        -: 2168:            ret = -1;
        -: 2169:            goto abort;
        -: 2170:        }
        -: 2171:
    #####: 2172:        ctx->ref_defs = new_defs;
        -: 2173:    }
        -: 2174:
    #####: 2175:    def = &ctx->ref_defs[ctx->n_ref_defs];
    #####: 2176:    memset(def, 0, sizeof(MD_REF_DEF));
        -: 2177:
    #####: 2178:    def->label = label;
    #####: 2179:    def->label_size = label_size;
    #####: 2180:    def->label_needs_free = label_needs_free;
        -: 2181:
    #####: 2182:    def->dest_beg = dest_contents_beg;
    #####: 2183:    def->dest_end = dest_contents_end;
        -: 2184:
    #####: 2185:    if(title_contents_beg >= title_contents_end) {
    #####: 2186:        def->title = NULL;
    #####: 2187:        def->title_size = 0;
    #####: 2188:    } else if(!title_is_multiline) {
    #####: 2189:        def->title = (CHAR*) STR(title_contents_beg);
    #####: 2190:        def->title_size = title_contents_end - title_contents_beg;
        -: 2191:    } else {
    #####: 2192:        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,
        -: 2193:                    lines + title_contents_line_index, n_lines - title_contents_line_index,
        -: 2194:                    _T('\n'), &def->title, &def->title_size));
    #####: 2195:        def->title_needs_free = TRUE;
        -: 2196:    }
        -: 2197:
        -: 2198:    /* Success. */
    #####: 2199:    ctx->n_ref_defs++;
    #####: 2200:    return line_index + 1;
        -: 2201:
    #####: 2202:abort:
        -: 2203:    /* Failure. */
    #####: 2204:    if(label_needs_free)
    #####: 2205:        free(label);
        -: 2206:    return -1;
        -: 2207:}
        -: 2208:
        -: 2209:static inline int
    #####: 2210:md_is_link_reference_definition(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 2211:{
        -: 2212:    int ret;
    #####: 2213:    ret = md_is_link_reference_definition_helper(ctx, lines, n_lines, md_is_link_destination_A);
    #####: 2214:    if(ret == 0)
    #####: 2215:        ret = md_is_link_reference_definition_helper(ctx, lines, n_lines, md_is_link_destination_B);
    #####: 2216:    return ret;
        -: 2217:}
        -: 2218:
        -: 2219:static int
    #####: 2220:md_is_link_reference(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2221:                     OFF beg, OFF end, MD_LINK_ATTR* attr)
        -: 2222:{
        -: 2223:    const MD_REF_DEF* def;
        -: 2224:    const MD_LINE* beg_line;
        -: 2225:    const MD_LINE* end_line;
    #####: 2226:    CHAR* label;
    #####: 2227:    SZ label_size;
        -: 2228:    int ret;
        -: 2229:
    #####: 2230:    MD_ASSERT(CH(beg) == _T('[') || CH(beg) == _T('!'));
    #####: 2231:    MD_ASSERT(CH(end-1) == _T(']'));
        -: 2232:
    #####: 2233:    beg += (CH(beg) == _T('!') ? 2 : 1);
    #####: 2234:    end--;
        -: 2235:
        -: 2236:    /* Find lines corresponding to the beg and end positions. */
    #####: 2237:    MD_ASSERT(lines[0].beg <= beg);
        -: 2238:    beg_line = lines;
    #####: 2239:    while(beg >= beg_line->end)
    #####: 2240:        beg_line++;
        -: 2241:
    #####: 2242:    MD_ASSERT(end <= lines[n_lines-1].end);
        -: 2243:    end_line = beg_line;
    #####: 2244:    while(end >= end_line->end)
    #####: 2245:        end_line++;
        -: 2246:
    #####: 2247:    if(beg_line != end_line) {
    #####: 2248:        MD_CHECK(md_merge_lines_alloc(ctx, beg, end, beg_line,
        -: 2249:                 n_lines - (beg_line - lines), _T(' '), &label, &label_size));
        -: 2250:    } else {
    #####: 2251:        label = (CHAR*) STR(beg);
    #####: 2252:        label_size = end - beg;
        -: 2253:    }
        -: 2254:
    #####: 2255:    def = md_lookup_ref_def(ctx, label, label_size);
    #####: 2256:    if(def != NULL) {
    #####: 2257:        attr->dest_beg = def->dest_beg;
    #####: 2258:        attr->dest_end = def->dest_end;
    #####: 2259:        attr->title = def->title;
    #####: 2260:        attr->title_size = def->title_size;
    #####: 2261:        attr->title_needs_free = FALSE;
        -: 2262:    }
        -: 2263:
    #####: 2264:    if(beg_line != end_line)
    #####: 2265:        free(label);
        -: 2266:
    #####: 2267:    ret = (def != NULL);
        -: 2268:
    #####: 2269:abort:
    #####: 2270:    return ret;
        -: 2271:}
        -: 2272:
        -: 2273:static int
    #####: 2274:md_is_inline_link_spec_helper(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2275:                              OFF beg, OFF* p_end, MD_LINK_ATTR* attr,
        -: 2276:                              int (*is_link_dest_fn)(MD_CTX*, OFF, OFF, OFF*, OFF*, OFF*))
        -: 2277:{
    #####: 2278:    int line_index = 0;
    #####: 2279:    int tmp_line_index;
    #####: 2280:    OFF title_contents_beg;
    #####: 2281:    OFF title_contents_end;
    #####: 2282:    int title_contents_line_index;
        -: 2283:    int title_is_multiline;
    #####: 2284:    OFF off = beg;
    #####: 2285:    int ret = FALSE;
        -: 2286:
    #####: 2287:    while(off >= lines[line_index].end)
    #####: 2288:        line_index++;
        -: 2289:
    #####: 2290:    MD_ASSERT(CH(off) == _T('('));
    #####: 2291:    off++;
        -: 2292:
        -: 2293:    /* Optional white space with up to one line break. */
    #####: 2294:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2295:        off++;
    #####: 2296:    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {
    #####: 2297:        line_index++;
    #####: 2298:        if(line_index >= n_lines)
        -: 2299:            return FALSE;
    #####: 2300:        off = lines[line_index].beg;
        -: 2301:    }
        -: 2302:
        -: 2303:    /* (Optional) link destination. */
    #####: 2304:    if(!is_link_dest_fn(ctx, off, lines[line_index].end,
        -: 2305:                        &off, &attr->dest_beg, &attr->dest_end)) {
    #####: 2306:        if(is_link_dest_fn == md_is_link_destination_B) {
    #####: 2307:            attr->dest_beg = off;
    #####: 2308:            attr->dest_end = off;
        -: 2309:        } else {
        -: 2310:            return FALSE;
        -: 2311:        }
        -: 2312:    }
        -: 2313:
        -: 2314:    /* (Optional) title. */
    #####: 2315:    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,
        -: 2316:                &off, &title_contents_line_index, &tmp_line_index,
        -: 2317:                &title_contents_beg, &title_contents_end))
        -: 2318:    {
    #####: 2319:        title_is_multiline = (tmp_line_index != title_contents_line_index);
    #####: 2320:        title_contents_line_index += line_index;
    #####: 2321:        line_index += tmp_line_index;
        -: 2322:    } else {
        -: 2323:        /* Not a title. */
    #####: 2324:        title_is_multiline = FALSE;
    #####: 2325:        title_contents_beg = off;
    #####: 2326:        title_contents_end = off;
    #####: 2327:        title_contents_line_index = 0;
        -: 2328:    }
        -: 2329:
        -: 2330:    /* Optional whitespace followed with final ')'. */
    #####: 2331:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2332:        off++;
    #####: 2333:    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {
    #####: 2334:        line_index++;
    #####: 2335:        if(line_index >= n_lines)
        -: 2336:            return FALSE;
    #####: 2337:        off = lines[line_index].beg;
        -: 2338:    }
    #####: 2339:    if(CH(off) != _T(')'))
        -: 2340:        goto abort;
    #####: 2341:    off++;
        -: 2342:
    #####: 2343:    if(title_contents_beg >= title_contents_end) {
    #####: 2344:        attr->title = NULL;
    #####: 2345:        attr->title_size = 0;
    #####: 2346:        attr->title_needs_free = FALSE;
    #####: 2347:    } else if(!title_is_multiline) {
    #####: 2348:        attr->title = (CHAR*) STR(title_contents_beg);
    #####: 2349:        attr->title_size = title_contents_end - title_contents_beg;
    #####: 2350:        attr->title_needs_free = FALSE;
        -: 2351:    } else {
    #####: 2352:        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,
        -: 2353:                    lines + title_contents_line_index, n_lines - title_contents_line_index,
        -: 2354:                    _T('\n'), &attr->title, &attr->title_size));
    #####: 2355:        attr->title_needs_free = TRUE;
        -: 2356:    }
        -: 2357:
    #####: 2358:    *p_end = off;
    #####: 2359:    ret = TRUE;
        -: 2360:
    #####: 2361:abort:
    #####: 2362:    return ret;
        -: 2363:}
        -: 2364:
        -: 2365:static inline int
    #####: 2366:md_is_inline_link_spec(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2367:                       OFF beg, OFF* p_end, MD_LINK_ATTR* attr)
        -: 2368:{
    #####: 2369:    return md_is_inline_link_spec_helper(ctx, lines, n_lines, beg, p_end, attr, md_is_link_destination_A) ||
    #####: 2370:           md_is_inline_link_spec_helper(ctx, lines, n_lines, beg, p_end, attr, md_is_link_destination_B);
        -: 2371:}
        -: 2372:
        -: 2373:static void
    #####: 2374:md_free_ref_defs(MD_CTX* ctx)
        -: 2375:{
        -: 2376:    int i;
        -: 2377:
    #####: 2378:    for(i = 0; i < ctx->n_ref_defs; i++) {
    #####: 2379:        MD_REF_DEF* def = &ctx->ref_defs[i];
        -: 2380:
    #####: 2381:        if(def->label_needs_free)
    #####: 2382:            free(def->label);
    #####: 2383:        if(def->title_needs_free)
    #####: 2384:            free(def->title);
        -: 2385:    }
        -: 2386:
    #####: 2387:    free(ctx->ref_defs);
    #####: 2388:}
        -: 2389:
        -: 2390:
        -: 2391:/******************************************
        -: 2392: ***  Processing Inlines (a.k.a Spans)  ***
        -: 2393: ******************************************/
        -: 2394:
        -: 2395:/* We process inlines in few phases:
        -: 2396: *
        -: 2397: * (1) We go through the block text and collect all significant characters
        -: 2398: *     which may start/end a span or some other significant position into
        -: 2399: *     ctx->marks[]. Core of this is what md_collect_marks() does.
        -: 2400: *
        -: 2401: *     We also do some very brief preliminary context-less analysis, whether
        -: 2402: *     it might be opener or closer (e.g. of an emphasis span).
        -: 2403: *
        -: 2404: *     This speeds the other steps as we do not need to re-iterate over all
        -: 2405: *     characters anymore.
        -: 2406: *
        -: 2407: * (2) We analyze each potential mark types, in order by their precedence.
        -: 2408: *
        -: 2409: *     In each md_analyze_XXX() function, we re-iterate list of the marks,
        -: 2410: *     skipping already resolved regions (in preceding precedences) and try to
        -: 2411: *     resolve them.
        -: 2412: *
        -: 2413: * (2.1) For trivial marks, which are single (e.g. HTML entity), we just mark
        -: 2414: *       them as resolved.
        -: 2415: *
        -: 2416: * (2.2) For range-type marks, we analyze whether the mark could be closer
        -: 2417: *       and, if yes, whether there is some preceding opener it could satisfy.
        -: 2418: *
        -: 2419: *       If not we check whether it could be really an opener and if yes, we
        -: 2420: *       remember it so subsequent closers may resolve it.
        -: 2421: *
        -: 2422: * (3) Finally, when all marks were analyzed, we render the block contents
        -: 2423: *     by calling MD_RENDERER::text() callback, interrupting by ::enter_span()
        -: 2424: *     or ::close_span() whenever we reach a resolved mark.
        -: 2425: */
        -: 2426:
        -: 2427:
        -: 2428:/* The mark structure.
        -: 2429: *
        -: 2430: * '\\': Maybe escape sequence.
        -: 2431: * '\0': NULL char.
        -: 2432: *  '*': Maybe (strong) emphasis start/end.
        -: 2433: *  '_': Maybe (strong) emphasis start/end.
        -: 2434: *  '~': Maybe strikethrough start/end (needs MD_FLAG_STRIKETHROUGH).
        -: 2435: *  '`': Maybe code span start/end.
        -: 2436: *  '&': Maybe start of entity.
        -: 2437: *  ';': Maybe end of entity.
        -: 2438: *  '<': Maybe start of raw HTML or autolink.
        -: 2439: *  '>': Maybe end of raw HTML or autolink.
        -: 2440: *  '[': Maybe start of link label or link text.
        -: 2441: *  '!': Equivalent of '[' for image.
        -: 2442: *  ']': Maybe end of link label or link text.
        -: 2443: *  '@': Maybe permissive e-mail auto-link (needs MD_FLAG_PERMISSIVEEMAILAUTOLINKS).
        -: 2444: *  ':': Maybe permissive URL auto-link (needs MD_FLAG_PERMISSIVEURLAUTOLINKS).
        -: 2445: *  '.': Maybe permissive WWW auto-link (needs MD_FLAG_PERMISSIVEWWWAUTOLINKS).
        -: 2446: *  'D': Dummy mark, it reserves a space for splitting a previous mark
        -: 2447: *       (e.g. emphasis) or to make more space for storing some special data
        -: 2448: *       related to the preceding mark (e.g. link).
        -: 2449: *
        -: 2450: * Note that not all instances of these chars in the text imply creation of the
        -: 2451: * structure. Only those which have (or may have, after we see more context)
        -: 2452: * the special meaning.
        -: 2453: *
        -: 2454: * (Keep this struct as small as possible to fit as much of them into CPU
        -: 2455: * cache line.)
        -: 2456: */
        -: 2457:struct MD_MARK_tag {
        -: 2458:    OFF beg;
        -: 2459:    OFF end;
        -: 2460:
        -: 2461:    /* For unresolved openers, 'prev' and 'next' form the chain of open openers
        -: 2462:     * of given type 'ch'.
        -: 2463:     *
        -: 2464:     * During resolving, we disconnect from the chain and point to the
        -: 2465:     * corresponding counterpart so opener points to its closer and vice versa.
        -: 2466:     */
        -: 2467:    int prev;
        -: 2468:    int next;
        -: 2469:    CHAR ch;
        -: 2470:    unsigned char flags;
        -: 2471:};
        -: 2472:
        -: 2473:/* Mark flags (these apply to ALL mark types). */
        -: 2474:#define MD_MARK_POTENTIAL_OPENER            0x01  /* Maybe opener. */
        -: 2475:#define MD_MARK_POTENTIAL_CLOSER            0x02  /* Maybe closer. */
        -: 2476:#define MD_MARK_OPENER                      0x04  /* Definitely opener. */
        -: 2477:#define MD_MARK_CLOSER                      0x08  /* Definitely closer. */
        -: 2478:#define MD_MARK_RESOLVED                    0x10  /* Resolved in any definite way. */
        -: 2479:
        -: 2480:/* Mark flags specific for various mark types (so they can share bits). */
        -: 2481:#define MD_MARK_EMPH_INTRAWORD              0x20  /* Helper for the "rule of 3". */
        -: 2482:#define MD_MARK_EMPH_MODULO3_0              0x40
        -: 2483:#define MD_MARK_EMPH_MODULO3_1              0x80
        -: 2484:#define MD_MARK_EMPH_MODULO3_2              (0x40 | 0x80)
        -: 2485:#define MD_MARK_EMPH_MODULO3_MASK           (0x40 | 0x80)
        -: 2486:#define MD_MARK_AUTOLINK                    0x20  /* Distinguisher for '<', '>'. */
        -: 2487:
        -: 2488:
        -: 2489:static MD_MARK*
        8: 2490:md_push_mark(MD_CTX* ctx)
        -: 2491:{
        8: 2492:    if(ctx->n_marks >= ctx->alloc_marks) {
        -: 2493:        MD_MARK* new_marks;
        -: 2494:
        1: 2495:        ctx->alloc_marks = (ctx->alloc_marks > 0 ? ctx->alloc_marks * 2 : 64);
        1: 2496:        new_marks = realloc(ctx->marks, ctx->alloc_marks * sizeof(MD_MARK));
        1: 2497:        if(new_marks == NULL) {
    #####: 2498:            MD_LOG("realloc() failed.");
        -: 2499:            return NULL;
        -: 2500:        }
        -: 2501:
        1: 2502:        ctx->marks = new_marks;
        -: 2503:    }
        -: 2504:
        8: 2505:    return &ctx->marks[ctx->n_marks++];
        -: 2506:}
        -: 2507:
        -: 2508:#define PUSH_MARK_()                                                    \
        -: 2509:        do {                                                            \
        -: 2510:            mark = md_push_mark(ctx);                                   \
        -: 2511:            if(mark == NULL) {                                          \
        -: 2512:                ret = -1;                                               \
        -: 2513:                goto abort;                                             \
        -: 2514:            }                                                           \
        -: 2515:        } while(0)
        -: 2516:
        -: 2517:#define PUSH_MARK(ch_, beg_, end_, flags_)                              \
        -: 2518:        do {                                                            \
        -: 2519:            PUSH_MARK_();                                               \
        -: 2520:            mark->beg = (beg_);                                         \
        -: 2521:            mark->end = (end_);                                         \
        -: 2522:            mark->prev = -1;                                            \
        -: 2523:            mark->next = -1;                                            \
        -: 2524:            mark->ch = (char)(ch_);                                     \
        -: 2525:            mark->flags = (flags_);                                     \
        -: 2526:        } while(0)
        -: 2527:
        -: 2528:
        -: 2529:static void
        -: 2530:md_mark_chain_append(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index)
        -: 2531:{
        3: 2532:    if(chain->tail >= 0)
        2: 2533:        ctx->marks[chain->tail].next = mark_index;
        -: 2534:    else
        1: 2535:        chain->head = mark_index;
        -: 2536:
        3: 2537:    ctx->marks[mark_index].prev = chain->tail;
        3: 2538:    chain->tail = mark_index;
        -: 2539:}
        -: 2540:
        -: 2541:/* Sometimes, we need to store a pointer into the mark. It is quite rare
        -: 2542: * so we do not bother to make MD_MARK use union, and it can only happen
        -: 2543: * for dummy marks. */
        -: 2544:static inline void
        -: 2545:md_mark_store_ptr(MD_CTX* ctx, int mark_index, void* ptr)
        -: 2546:{
    #####: 2547:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2548:    MD_ASSERT(mark->ch == 'D');
        -: 2549:
        -: 2550:    /* Check only members beg and end are misused for this. */
        -: 2551:    MD_ASSERT(sizeof(void*) <= 2 * sizeof(OFF));
    #####: 2552:    memcpy(mark, &ptr, sizeof(void*));
        -: 2553:}
        -: 2554:
        -: 2555:static inline void*
        -: 2556:md_mark_get_ptr(MD_CTX* ctx, int mark_index)
        -: 2557:{
    #####: 2558:    void* ptr;
    #####: 2559:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2560:    MD_ASSERT(mark->ch == 'D');
    #####: 2561:    memcpy(&ptr, mark, sizeof(void*));
        -: 2562:    return ptr;
        -: 2563:}
        -: 2564:
        -: 2565:static void
        2: 2566:md_resolve_range(MD_CTX* ctx, MD_MARKCHAIN* chain, int opener_index, int closer_index)
        -: 2567:{
        2: 2568:    MD_MARK* opener = &ctx->marks[opener_index];
        2: 2569:    MD_MARK* closer = &ctx->marks[closer_index];
        -: 2570:
        -: 2571:    /* Remove opener from the list of openers. */
        2: 2572:    if(chain != NULL) {
        2: 2573:        if(opener->prev >= 0)
        2: 2574:            ctx->marks[opener->prev].next = opener->next;
        -: 2575:        else
    #####: 2576:            chain->head = opener->next;
        -: 2577:
        2: 2578:        if(opener->next >= 0)
    #####: 2579:            ctx->marks[opener->next].prev = opener->prev;
        -: 2580:        else
        2: 2581:            chain->tail = opener->prev;
        -: 2582:    }
        -: 2583:
        -: 2584:    /* Interconnect opener and closer and mark both as resolved. */
        2: 2585:    opener->next = closer_index;
        2: 2586:    opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;
        2: 2587:    closer->prev = opener_index;
        2: 2588:    closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;
        2: 2589:}
        -: 2590:
        -: 2591:
        -: 2592:#define MD_ROLLBACK_ALL         0
        -: 2593:#define MD_ROLLBACK_CROSSING    1
        -: 2594:
        -: 2595:/* In the range ctx->marks[opener_index] ... [closer_index], undo some or all
        -: 2596: * resolvings accordingly to these rules:
        -: 2597: *
        -: 2598: * (1) All openers BEFORE the range corresponding to any closer inside the
        -: 2599: *     range are un-resolved and they are re-added to their respective chains
        -: 2600: *     of unresolved openers. This ensures we can reuse the opener for closers
        -: 2601: *     AFTER the range.
        -: 2602: *
        -: 2603: * (2) If 'how' is MD_ROLLBACK_ALL, then ALL resolved marks inside the range
        -: 2604: *     are discarded.
        -: 2605: *
        -: 2606: * (3) If 'how' is MD_ROLLBACK_CROSSING, only closers with openers handled
        -: 2607: *     in (1) are discarded. I.e. pairs of openers and closers which are both
        -: 2608: *     inside the range are retained as well as any unpaired marks.
        -: 2609: */
        -: 2610:static void
        2: 2611:md_rollback(MD_CTX* ctx, int opener_index, int closer_index, int how)
        -: 2612:{
        -: 2613:    int i;
        -: 2614:    int mark_index;
        -: 2615:
        -: 2616:    /* Cut all unresolved openers at the mark index. 
        -: 2617:     * (start at 1 to not touch PTR_CHAIN.) */
       16: 2618:    for(i = 1; i < SIZEOF_ARRAY(ctx->mark_chains); i++) {
        -: 2619:        MD_MARKCHAIN* chain = &ctx->mark_chains[i];
        -: 2620:
       16: 2621:        while(chain->tail >= opener_index)
        2: 2622:            chain->tail = ctx->marks[chain->tail].prev;
        -: 2623:
       14: 2624:        if(chain->tail >= 0)
        2: 2625:            ctx->marks[chain->tail].next = -1;
        -: 2626:        else
       12: 2627:            chain->head = -1;
        -: 2628:    }
        -: 2629:
        -: 2630:    /* Go backwards so that un-resolved openers are re-added into their
        -: 2631:     * respective chains, in the right order. */
        2: 2632:    mark_index = closer_index - 1;
        4: 2633:    while(mark_index > opener_index) {
    #####: 2634:        MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2635:        int mark_flags = mark->flags;
    #####: 2636:        int discard_flag = (how == MD_ROLLBACK_ALL);
        -: 2637:
    #####: 2638:        if(mark->flags & MD_MARK_CLOSER) {
    #####: 2639:            int mark_opener_index = mark->prev;
        -: 2640:
        -: 2641:            /* Undo opener BEFORE the range. */
    #####: 2642:            if(mark_opener_index < opener_index) {
    #####: 2643:                MD_MARK* mark_opener = &ctx->marks[mark_opener_index];
        -: 2644:                MD_MARKCHAIN* chain;
        -: 2645:
    #####: 2646:                mark_opener->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);
        -: 2647:
    #####: 2648:                switch(mark_opener->ch) {
    #####: 2649:                    case '*':   chain = &ASTERISK_OPENERS; break;
    #####: 2650:                    case '_':   chain = &UNDERSCORE_OPENERS; break;
    #####: 2651:                    case '`':   chain = &BACKTICK_OPENERS; break;
    #####: 2652:                    case '<':   chain = &LOWERTHEN_OPENERS; break;
    #####: 2653:                    case '~':   chain = &TILDE_OPENERS; break;
    #####: 2654:                    default:    MD_UNREACHABLE(); break;
        -: 2655:                }
    #####: 2656:                md_mark_chain_append(ctx, chain, mark_opener_index);
        -: 2657:
    #####: 2658:                discard_flag = 1;
        -: 2659:            }
        -: 2660:        }
        -: 2661:
        -: 2662:        /* And reset our flags. */
    #####: 2663:        if(discard_flag)
    #####: 2664:            mark->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);
        -: 2665:
        -: 2666:        /* Jump as far as we can over unresolved or non-interesting marks. */
    #####: 2667:        switch(how) {
    #####: 2668:            case MD_ROLLBACK_CROSSING:
    #####: 2669:                if((mark_flags & MD_MARK_CLOSER)  &&  mark->prev > opener_index) {
        -: 2670:                    /* If we are closer with opener INSIDE the range, there may
        -: 2671:                     * not be any other crosser inside the subrange. */
        -: 2672:                    mark_index = mark->prev;
        -: 2673:                    break;
        -: 2674:                }
        -: 2675:                /* Pass through. */
        -: 2676:            default:
    #####: 2677:                mark_index--;
    #####: 2678:                break;
        -: 2679:        }
        -: 2680:    }
        2: 2681:}
        -: 2682:
        -: 2683:static void
        1: 2684:md_build_mark_char_map(MD_CTX* ctx)
        -: 2685:{
        2: 2686:    memset(ctx->mark_char_map, 0, sizeof(ctx->mark_char_map));
        -: 2687:
        1: 2688:    ctx->mark_char_map['\\'] = 1;
        1: 2689:    ctx->mark_char_map['*'] = 1;
        1: 2690:    ctx->mark_char_map['_'] = 1;
        1: 2691:    ctx->mark_char_map['`'] = 1;
        1: 2692:    ctx->mark_char_map['&'] = 1;
        1: 2693:    ctx->mark_char_map[';'] = 1;
        1: 2694:    ctx->mark_char_map['<'] = 1;
        1: 2695:    ctx->mark_char_map['>'] = 1;
        1: 2696:    ctx->mark_char_map['['] = 1;
        1: 2697:    ctx->mark_char_map['!'] = 1;
        1: 2698:    ctx->mark_char_map[']'] = 1;
        1: 2699:    ctx->mark_char_map['\0'] = 1;
        -: 2700:
        1: 2701:    if(ctx->r.flags & MD_FLAG_STRIKETHROUGH)
    #####: 2702:        ctx->mark_char_map['~'] = 1;
        -: 2703:
        1: 2704:    if(ctx->r.flags & MD_FLAG_PERMISSIVEEMAILAUTOLINKS)
    #####: 2705:        ctx->mark_char_map['@'] = 1;
        -: 2706:
        1: 2707:    if(ctx->r.flags & MD_FLAG_PERMISSIVEURLAUTOLINKS)
    #####: 2708:        ctx->mark_char_map[':'] = 1;
        -: 2709:
        1: 2710:    if(ctx->r.flags & MD_FLAG_PERMISSIVEWWWAUTOLINKS)
    #####: 2711:        ctx->mark_char_map['.'] = 1;
        -: 2712:
        1: 2713:    if(ctx->r.flags & MD_FLAG_TABLES)
    #####: 2714:        ctx->mark_char_map['|'] = 1;
        -: 2715:
        1: 2716:    if(ctx->r.flags & MD_FLAG_COLLAPSEWHITESPACE) {
        -: 2717:        int i;
        -: 2718:
    #####: 2719:        for(i = 0; i < sizeof(ctx->mark_char_map); i++) {
    #####: 2720:            if(ISWHITESPACE_(i))
    #####: 2721:                ctx->mark_char_map[i] = 1;
        -: 2722:        }
        -: 2723:    }
        1: 2724:}
        -: 2725:
        -: 2726:static int
        1: 2727:md_collect_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)
        -: 2728:{
        -: 2729:    int i;
        1: 2730:    int ret = 0;
        -: 2731:    MD_MARK* mark;
        -: 2732:
        2: 2733:    for(i = 0; i < n_lines; i++) {
        1: 2734:        const MD_LINE* line = &lines[i];
        1: 2735:        OFF off = line->beg;
        1: 2736:        OFF line_end = line->end;
        -: 2737:
        -: 2738:        while(TRUE) {
        -: 2739:            CHAR ch;
        -: 2740:
        -: 2741:#ifdef MD4C_USE_UTF16
        -: 2742:    /* For UTF-16, mark_char_map[] covers only ASCII. */
        -: 2743:    #define IS_MARK_CHAR(off)   ((CH(off) < SIZEOF_ARRAY(ctx->mark_char_map))  &&  \
        -: 2744:                                (ctx->mark_char_map[(unsigned char) CH(off)]))
        -: 2745:#else
        -: 2746:    /* For 8-bit encodings, mark_char_map[] covers all 256 elements. */
        -: 2747:    #define IS_MARK_CHAR(off)   (ctx->mark_char_map[(unsigned char) CH(off)])
        -: 2748:#endif
        -: 2749:
        -: 2750:            /* Optimization: Fast path (with some loop unrolling). */
        5: 2751:            while(off + 4 < line_end  &&  !IS_MARK_CHAR(off+0)  &&  !IS_MARK_CHAR(off+1)
    #####: 2752:                                      &&  !IS_MARK_CHAR(off+2)  &&  !IS_MARK_CHAR(off+3))
        -: 2753:                off += 4;
        8: 2754:            while(off < line_end  &&  !IS_MARK_CHAR(off+0))
        3: 2755:                off++;
        -: 2756:
        5: 2757:            if(off >= line_end)
        -: 2758:                break;
        -: 2759:
        4: 2760:            ch = CH(off);
        -: 2761:
        -: 2762:            /* A backslash escape.
        -: 2763:             * It can go beyond line->end as it may involve escaped new
        -: 2764:             * line to form a hard break. */
        4: 2765:            if(ch == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
        -: 2766:                /* Hard-break cannot be on the last line of the block. */
    #####: 2767:                if(!ISNEWLINE(off+1)  ||  i+1 < n_lines)
    #####: 2768:                    PUSH_MARK(ch, off, off+2, MD_MARK_RESOLVED);
        -: 2769:
        -: 2770:                /* If '`' or '>' follows, we need both marks as the backslash
        -: 2771:                 * may be inside a code span or an autolink where escaping is
        -: 2772:                 * disabled. */
    #####: 2773:                if(CH(off+1) == _T('`') || CH(off+1) == _T('>'))
        -: 2774:                    off++;
        -: 2775:                else
    #####: 2776:                    off += 2;
    #####: 2777:                continue;
        -: 2778:            }
        -: 2779:
        -: 2780:            /* A potential (string) emphasis start/end. */
        4: 2781:            if(ch == _T('*')  ||  ch == _T('_')) {
        4: 2782:                OFF tmp = off+1;
        -: 2783:                int left_level;     /* What precedes: 0 = whitespace; 1 = punctuation; 2 = other char. */
        -: 2784:                int right_level;    /* What follows: 0 = whitespace; 1 = punctuation; 2 = other char. */
        -: 2785:
       11: 2786:                while(tmp < line_end  &&  CH(tmp) == ch)
        3: 2787:                    tmp++;
        -: 2788:
        4: 2789:                if(off == line->beg  ||  ISUNICODEWHITESPACEBEFORE(off))
        -: 2790:                    left_level = 0;
        2: 2791:                else if(ISUNICODEPUNCTBEFORE(off))
        -: 2792:                    left_level = 1;
        -: 2793:                else
        2: 2794:                    left_level = 2;
        -: 2795:
        4: 2796:                if(tmp == line_end  ||  ISUNICODEWHITESPACE(tmp))
        -: 2797:                    right_level = 0;
        2: 2798:                else if(ISUNICODEPUNCT(tmp))
        -: 2799:                    right_level = 1;
        -: 2800:                else
        2: 2801:                    right_level = 2;
        -: 2802:
        -: 2803:                /* Intra-word underscore doesn't have special meaning. */
        4: 2804:                if(ch == _T('_')  &&  left_level == 2  &&  right_level == 2) {
    #####: 2805:                    left_level = 0;
    #####: 2806:                    right_level = 0;
        -: 2807:                }
        -: 2808:
        4: 2809:                if(left_level != 0  ||  right_level != 0) {
        4: 2810:                    unsigned flags = 0;
        -: 2811:
        4: 2812:                    if(left_level > 0  &&  left_level >= right_level)
        2: 2813:                        flags |= MD_MARK_POTENTIAL_CLOSER;
        4: 2814:                    if(right_level > 0  &&  right_level >= left_level)
        2: 2815:                        flags |= MD_MARK_POTENTIAL_OPENER;
        4: 2816:                    if(left_level == 2  &&  right_level == 2)
    #####: 2817:                        flags |= MD_MARK_EMPH_INTRAWORD;
        -: 2818:
        -: 2819:                    /* For "the rule of three" we need to remember the original
        -: 2820:                     * size of the mark (modulo three), before we potentially
        -: 2821:                     * split the mark when being later resolved partially by some
        -: 2822:                     * shorter closer. */
        4: 2823:                    switch((tmp - off) % 3) {
        1: 2824:                        case 0: flags |= MD_MARK_EMPH_MODULO3_0; break;
        2: 2825:                        case 1: flags |= MD_MARK_EMPH_MODULO3_1; break;
        1: 2826:                        case 2: flags |= MD_MARK_EMPH_MODULO3_2; break;
        -: 2827:                    }
        -: 2828:
        4: 2829:                    PUSH_MARK(ch, off, tmp, flags);
        -: 2830:
        -: 2831:                    /* During resolving, multiple asterisks may have to be
        -: 2832:                     * split into independent span start/ends. Consider e.g.
        -: 2833:                     * "**foo* bar*". Therefore we push also some empty dummy
        -: 2834:                     * marks to have enough space for that. */
        4: 2835:                    off++;
       11: 2836:                    while(off < tmp) {
        3: 2837:                        PUSH_MARK('D', off, off, 0);
        3: 2838:                        off++;
        -: 2839:                    }
        4: 2840:                    continue;
        -: 2841:                }
        -: 2842:
    #####: 2843:                off = tmp;
    #####: 2844:                continue;
        -: 2845:            }
        -: 2846:
        -: 2847:            /* A potential code span start/end. */
    #####: 2848:            if(ch == _T('`')) {
    #####: 2849:                OFF tmp = off+1;
        -: 2850:
    #####: 2851:                while(tmp < line_end  &&  CH(tmp) == _T('`'))
    #####: 2852:                    tmp++;
        -: 2853:
        -: 2854:                /* We limit code span marks to lower then 256 backticks. This
        -: 2855:                 * solves a pathologic case of too many openers, each of
        -: 2856:                 * different length: Their resolving is then O(n^2). */
    #####: 2857:                if(tmp - off < 256)
    #####: 2858:                    PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);
        -: 2859:
    #####: 2860:                off = tmp;
    #####: 2861:                continue;
        -: 2862:            }
        -: 2863:
        -: 2864:            /* A potential entity start. */
    #####: 2865:            if(ch == _T('&')) {
    #####: 2866:                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);
    #####: 2867:                off++;
    #####: 2868:                continue;
        -: 2869:            }
        -: 2870:
        -: 2871:            /* A potential entity end. */
    #####: 2872:            if(ch == _T(';')) {
        -: 2873:                /* We surely cannot be entity unless the previous mark is '&'. */
    #####: 2874:                if(ctx->n_marks > 0  &&  ctx->marks[ctx->n_marks-1].ch == _T('&'))
    #####: 2875:                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);
        -: 2876:
    #####: 2877:                off++;
    #####: 2878:                continue;
        -: 2879:            }
        -: 2880:
        -: 2881:            /* A potential autolink or raw HTML start/end. */
    #####: 2882:            if(ch == _T('<') || ch == _T('>')) {
    #####: 2883:                if(!(ctx->r.flags & MD_FLAG_NOHTMLSPANS))
    #####: 2884:                    PUSH_MARK(ch, off, off+1, (ch == _T('<') ? MD_MARK_POTENTIAL_OPENER : MD_MARK_POTENTIAL_CLOSER));
        -: 2885:
    #####: 2886:                off++;
    #####: 2887:                continue;
        -: 2888:            }
        -: 2889:
        -: 2890:            /* A potential link or its part. */
    #####: 2891:            if(ch == _T('[')  ||  (ch == _T('!') && off+1 < line_end && CH(off+1) == _T('['))) {
    #####: 2892:                OFF tmp = (ch == _T('[') ? off+1 : off+2);
    #####: 2893:                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER);
    #####: 2894:                off = tmp;
        -: 2895:                /* Two dummies to make enough place for data we need if it is
        -: 2896:                 * a link. */
    #####: 2897:                PUSH_MARK('D', off, off, 0);
    #####: 2898:                PUSH_MARK('D', off, off, 0);
    #####: 2899:                continue;
        -: 2900:            }
    #####: 2901:            if(ch == _T(']')) {
    #####: 2902:                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);
    #####: 2903:                off++;
    #####: 2904:                continue;
        -: 2905:            }
        -: 2906:
        -: 2907:            /* A potential permissive e-mail autolink. */
    #####: 2908:            if(ch == _T('@')) {
    #####: 2909:                if(line->beg + 1 <= off  &&  ISALNUM(off-1)  &&
    #####: 2910:                    off + 3 < line->end  &&  ISALNUM(off+1))
        -: 2911:                {
    #####: 2912:                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);
        -: 2913:                    /* Push a dummy as a reserve for a closer. */
    #####: 2914:                    PUSH_MARK('D', off, off, 0);
        -: 2915:                }
        -: 2916:
    #####: 2917:                off++;
    #####: 2918:                continue;
        -: 2919:            }
        -: 2920:
        -: 2921:            /* A potential permissive URL autolink. */
    #####: 2922:            if(ch == _T(':')) {
        -: 2923:                static struct {
        -: 2924:                    const CHAR* scheme;
        -: 2925:                    SZ scheme_size;
        -: 2926:                    const CHAR* suffix;
        -: 2927:                    SZ suffix_size;
        -: 2928:                } scheme_map[] = {
        -: 2929:                    /* In the order from the most frequently used, arguably. */
        -: 2930:                    { _T("http"), 4,    _T("//"), 2 },
        -: 2931:                    { _T("https"), 5,   _T("//"), 2 },
        -: 2932:                    { _T("ftp"), 3,     _T("//"), 2 }
        -: 2933:                };
        -: 2934:                int scheme_index;
        -: 2935:
    #####: 2936:                for(scheme_index = 0; scheme_index < SIZEOF_ARRAY(scheme_map); scheme_index++) {
    #####: 2937:                    const CHAR* scheme = scheme_map[scheme_index].scheme;
    #####: 2938:                    const SZ scheme_size = scheme_map[scheme_index].scheme_size;
    #####: 2939:                    const CHAR* suffix = scheme_map[scheme_index].suffix;
    #####: 2940:                    const SZ suffix_size = scheme_map[scheme_index].suffix_size;
        -: 2941:
    #####: 2942:                    if(line->beg + scheme_size <= off  &&  md_ascii_eq(STR(off-scheme_size), scheme, scheme_size)  &&
    #####: 2943:                        (line->beg + scheme_size == off || ISWHITESPACE(off-scheme_size-1) || ISANYOF(off-scheme_size-1, _T("*_~([")))  &&
    #####: 2944:                        off + 1 + suffix_size < line->end  &&  md_ascii_eq(STR(off+1), suffix, suffix_size))
        -: 2945:                    {
    #####: 2946:                        PUSH_MARK(ch, off-scheme_size, off+1+suffix_size, MD_MARK_POTENTIAL_OPENER);
        -: 2947:                        /* Push a dummy as a reserve for a closer. */
    #####: 2948:                        PUSH_MARK('D', off, off, 0);
    #####: 2949:                        off += 1 + suffix_size;
    #####: 2950:                        continue;
        -: 2951:                    }
        -: 2952:                }
        -: 2953:
    #####: 2954:                off++;
    #####: 2955:                continue;
        -: 2956:            }
        -: 2957:
        -: 2958:            /* A potential permissive WWW autolink. */
    #####: 2959:            if(ch == _T('.')) {
    #####: 2960:                if(line->beg + 3 <= off  &&  md_ascii_eq(STR(off-3), _T("www"), 3)  &&
    #####: 2961:                    (line->beg + 3 == off || ISWHITESPACE(off-4) || ISANYOF(off-4, _T("*_~([")))  &&
    #####: 2962:                    off + 1 < line_end)
        -: 2963:                {
    #####: 2964:                    PUSH_MARK(ch, off-3, off+1, MD_MARK_POTENTIAL_OPENER);
        -: 2965:                    /* Push a dummy as a reserve for a closer. */
    #####: 2966:                    PUSH_MARK('D', off, off, 0);
    #####: 2967:                    off++;
    #####: 2968:                    continue;
        -: 2969:                }
        -: 2970:
    #####: 2971:                off++;
    #####: 2972:                continue;
        -: 2973:            }
        -: 2974:
        -: 2975:            /* A potential table cell boundary. */
    #####: 2976:            if(table_mode  &&  ch == _T('|')) {
    #####: 2977:                PUSH_MARK(ch, off, off+1, 0);
    #####: 2978:                off++;
    #####: 2979:                continue;
        -: 2980:            }
        -: 2981:
        -: 2982:            /* A potential strikethrough start/end. */
    #####: 2983:            if(ch == _T('~')) {
    #####: 2984:                OFF tmp = off+1;
        -: 2985:
    #####: 2986:                while(tmp < line_end  &&  CH(tmp) == _T('~'))
    #####: 2987:                    tmp++;
        -: 2988:
    #####: 2989:                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);
    #####: 2990:                off = tmp;
        -: 2991:            }
        -: 2992:
        -: 2993:            /* Turn non-trivial whitespace into single space. */
    #####: 2994:            if(ISWHITESPACE_(ch)) {
    #####: 2995:                OFF tmp = off+1;
        -: 2996:
    #####: 2997:                while(tmp < line_end  &&  ISWHITESPACE(tmp))
    #####: 2998:                    tmp++;
        -: 2999:
    #####: 3000:                if(tmp - off > 1  ||  ch != _T(' '))
    #####: 3001:                    PUSH_MARK(ch, off, tmp, MD_MARK_RESOLVED);
        -: 3002:
    #####: 3003:                off = tmp;
    #####: 3004:                continue;
        -: 3005:            }
        -: 3006:
        -: 3007:            /* NULL character. */
    #####: 3008:            if(ch == _T('\0')) {
    #####: 3009:                PUSH_MARK(ch, off, off+1, MD_MARK_RESOLVED);
    #####: 3010:                off++;
    #####: 3011:                continue;
        -: 3012:            }
        -: 3013:
    #####: 3014:            off++;
        -: 3015:        }
        -: 3016:    }
        -: 3017:
        -: 3018:    /* Add a dummy mark after the end of processed block to simplify
        -: 3019:     * md_process_inlines(). */
        1: 3020:    PUSH_MARK(127, ctx->size+1, ctx->size+1, MD_MARK_RESOLVED);
        -: 3021:
        1: 3022:abort:
        1: 3023:    return ret;
        -: 3024:}
        -: 3025:
        -: 3026:
        -: 3027:/* Analyze whether the back-tick is really start/end mark of a code span.
        -: 3028: * If yes, reset all marks inside of it and setup flags of both marks. */
        -: 3029:static void
    #####: 3030:md_analyze_backtick(MD_CTX* ctx, int mark_index)
        -: 3031:{
    #####: 3032:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 3033:    int opener_index = BACKTICK_OPENERS.tail;
        -: 3034:
        -: 3035:    /* Try to find unresolved opener of the same length. If we find it,
        -: 3036:     * we form a code span. */
    #####: 3037:    while(opener_index >= 0) {
    #####: 3038:        MD_MARK* opener = &ctx->marks[opener_index];
        -: 3039:
    #####: 3040:        if(opener->end - opener->beg == mark->end - mark->beg) {
        -: 3041:            /* Rollback anything found inside it.
        -: 3042:             * (e.g. the code span contains some back-ticks or other special
        -: 3043:             * chars we misinterpreted.) */
    #####: 3044:            md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_ALL);
        -: 3045:
        -: 3046:            /* Resolve the span. */
    #####: 3047:            md_resolve_range(ctx, &BACKTICK_OPENERS, opener_index, mark_index);
        -: 3048:
        -: 3049:            /* Append any space or new line inside the span into the mark
        -: 3050:             * itself to swallow it. */
    #####: 3051:            while(CH(opener->end) == _T(' ')  ||  ISNEWLINE(opener->end))
    #####: 3052:                opener->end++;
    #####: 3053:            if(mark->beg > opener->end) {
    #####: 3054:                while(CH(mark->beg-1) == _T(' ')  ||  ISNEWLINE(mark->beg-1))
    #####: 3055:                    mark->beg--;
        -: 3056:            }
        -: 3057:
        -: 3058:            /* Done. */
        -: 3059:            return;
        -: 3060:        }
        -: 3061:
    #####: 3062:        opener_index = ctx->marks[opener_index].prev;
        -: 3063:    }
        -: 3064:
        -: 3065:    /* We didn't find any matching opener, so we ourselves may be the opener
        -: 3066:     * of some upcoming closer. We also have to handle specially if there is
        -: 3067:     * a backslash mark before it as that can cancel the first backtick. */
    #####: 3068:    if(mark_index > 0  &&  (mark-1)->beg == mark->beg - 1  &&  (mark-1)->ch == '\\') {
    #####: 3069:        if(mark->end - mark->beg == 1) {
        -: 3070:            /* Single escaped backtick. */
        -: 3071:            return;
        -: 3072:        }
        -: 3073:
        -: 3074:        /* Remove the escaped backtick from the opener. */
    #####: 3075:        mark->beg++;
        -: 3076:    }
        -: 3077:
    #####: 3078:    if(mark->flags & MD_MARK_POTENTIAL_OPENER)
    #####: 3079:        md_mark_chain_append(ctx, &BACKTICK_OPENERS, mark_index);
        -: 3080:}
        -: 3081:
        -: 3082:static int
    #####: 3083:md_is_autolink_uri(MD_CTX* ctx, OFF beg, OFF end)
        -: 3084:{
    #####: 3085:    OFF off = beg;
        -: 3086:
        -: 3087:    /* Check for scheme. */
    #####: 3088:    if(off >= end  ||  !ISASCII(off))
        -: 3089:        return FALSE;
    #####: 3090:    off++;
        -: 3091:    while(1) {
    #####: 3092:        if(off >= end)
        -: 3093:            return FALSE;
    #####: 3094:        if(off - beg > 32)
        -: 3095:            return FALSE;
    #####: 3096:        if(CH(off) == _T(':')  &&  off - beg >= 2)
        -: 3097:            break;
    #####: 3098:        if(!ISALNUM(off) && CH(off) != _T('+') && CH(off) != _T('-') && CH(off) != _T('.'))
        -: 3099:            return FALSE;
    #####: 3100:        off++;
        -: 3101:    }
        -: 3102:
        -: 3103:    /* Check the path after the scheme. */
    #####: 3104:    while(off < end) {
    #####: 3105:        if(ISWHITESPACE(off) || ISCNTRL(off) || CH(off) == _T('<') || CH(off) == _T('>'))
        -: 3106:            return FALSE;
    #####: 3107:        off++;
        -: 3108:    }
        -: 3109:
        -: 3110:    return TRUE;
        -: 3111:}
        -: 3112:
        -: 3113:static int
    #####: 3114:md_is_autolink_email(MD_CTX* ctx, OFF beg, OFF end)
        -: 3115:{
    #####: 3116:    OFF off = beg;
        -: 3117:    int label_len;
        -: 3118:
        -: 3119:    /* The code should correspond to this regexp:
        -: 3120:            /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+
        -: 3121:            @[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?
        -: 3122:            (?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
        -: 3123:     */
        -: 3124:
        -: 3125:    /* Username (before '@'). */
    #####: 3126:    while(off < end  &&  (ISALNUM(off) || ISANYOF(off, _T(".!#$%&'*+/=?^_`{|}~-"))))
    #####: 3127:        off++;
    #####: 3128:    if(off <= beg)
        -: 3129:        return FALSE;
        -: 3130:
        -: 3131:    /* '@' */
    #####: 3132:    if(off >= end  ||  CH(off) != _T('@'))
        -: 3133:        return FALSE;
    #####: 3134:    off++;
        -: 3135:
        -: 3136:    /* Labels delimited with '.'; each label is sequence of 1 - 62 alnum
        -: 3137:     * characters or '-', but '-' is not allowed as first or last char. */
    #####: 3138:    label_len = 0;
    #####: 3139:    while(off < end) {
    #####: 3140:        if(ISALNUM(off))
    #####: 3141:            label_len++;
    #####: 3142:        else if(CH(off) == _T('-')  &&  label_len > 0)
    #####: 3143:            label_len++;
    #####: 3144:        else if(CH(off) == _T('.')  &&  label_len > 0  &&  CH(off-1) != _T('-'))
        -: 3145:            label_len = 0;
        -: 3146:        else
        -: 3147:            return FALSE;
        -: 3148:
    #####: 3149:        if(label_len > 63)
        -: 3150:            return FALSE;
        -: 3151:
    #####: 3152:        off++;
        -: 3153:    }
        -: 3154:
    #####: 3155:    if(label_len <= 0  ||  CH(off-1) == _T('-'))
        -: 3156:        return FALSE;
        -: 3157:
        -: 3158:    return TRUE;
        -: 3159:}
        -: 3160:
        -: 3161:static int
    #####: 3162:md_is_autolink(MD_CTX* ctx, OFF beg, OFF end, int* p_missing_mailto)
        -: 3163:{
    #####: 3164:    MD_ASSERT(CH(beg) == _T('<'));
    #####: 3165:    MD_ASSERT(CH(end-1) == _T('>'));
        -: 3166:
    #####: 3167:    beg++;
    #####: 3168:    end--;
        -: 3169:
    #####: 3170:    if(md_is_autolink_uri(ctx, beg, end))
        -: 3171:        return TRUE;
        -: 3172:
    #####: 3173:    if(md_is_autolink_email(ctx, beg, end)) {
    #####: 3174:        *p_missing_mailto = 1;
    #####: 3175:        return TRUE;
        -: 3176:    }
        -: 3177:
        -: 3178:    return FALSE;
        -: 3179:}
        -: 3180:
        -: 3181:static void
    #####: 3182:md_analyze_lt_gt(MD_CTX* ctx, int mark_index, const MD_LINE* lines, int n_lines)
        -: 3183:{
    #####: 3184:    MD_MARK* mark = &ctx->marks[mark_index];
        -: 3185:    int opener_index;
        -: 3186:
        -: 3187:    /* If it is an opener ('<'), remember it. */
    #####: 3188:    if(mark->flags & MD_MARK_POTENTIAL_OPENER) {
    #####: 3189:        md_mark_chain_append(ctx, &LOWERTHEN_OPENERS, mark_index);
        -: 3190:        return;
        -: 3191:    }
        -: 3192:
        -: 3193:    /* Otherwise we are potential closer and we try to resolve with since all
        -: 3194:     * the chained unresolved openers. */
    #####: 3195:    opener_index = LOWERTHEN_OPENERS.head;
    #####: 3196:    while(opener_index >= 0) {
    #####: 3197:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3198:        OFF detected_end;
    #####: 3199:        int is_autolink = 0;
    #####: 3200:        int is_missing_mailto = 0;
    #####: 3201:        int is_raw_html = 0;
        -: 3202:
    #####: 3203:        is_autolink = (md_is_autolink(ctx, opener->beg, mark->end, &is_missing_mailto));
        -: 3204:
    #####: 3205:        if(is_autolink) {
    #####: 3206:            if(is_missing_mailto)
    #####: 3207:                opener->ch = _T('@');
        -: 3208:        } else {
        -: 3209:            /* Identify the line where the opening mark lives. */
        -: 3210:            int line_index = 0;
        -: 3211:            while(1) {
    #####: 3212:                if(opener->beg < lines[line_index].end)
        -: 3213:                    break;
    #####: 3214:                line_index++;
        -: 3215:            }
        -: 3216:
    #####: 3217:            is_raw_html = (md_is_html_any(ctx, lines + line_index,
        -: 3218:                    n_lines - line_index, opener->beg, mark->end, &detected_end));
        -: 3219:        }
        -: 3220:
        -: 3221:        /* Check whether the range forms a valid raw HTML. */
    #####: 3222:        if(is_autolink || is_raw_html) {
    #####: 3223:            md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_ALL);
    #####: 3224:            md_resolve_range(ctx, &LOWERTHEN_OPENERS, opener_index, mark_index);
        -: 3225:
    #####: 3226:            if(is_raw_html) {
        -: 3227:                /* If this fails, it means we have missed some earlier opportunity
        -: 3228:                 * to resolve the opener of raw HTML. */
    #####: 3229:                MD_ASSERT(detected_end == mark->end);
        -: 3230:
        -: 3231:                /* Make these marks zero width so the '<' and '>' are part of its
        -: 3232:                 * contents. */
    #####: 3233:                opener->end = opener->beg;
    #####: 3234:                mark->beg = mark->end;
        -: 3235:
    #####: 3236:                opener->flags &= ~MD_MARK_AUTOLINK;
    #####: 3237:                mark->flags &= ~MD_MARK_AUTOLINK;
        -: 3238:            } else {
    #####: 3239:                opener->flags |= MD_MARK_AUTOLINK;
    #####: 3240:                mark->flags |= MD_MARK_AUTOLINK;
        -: 3241:            }
        -: 3242:
        -: 3243:            /* And we are done. */
    #####: 3244:            return;
        -: 3245:        }
        -: 3246:
    #####: 3247:        opener_index = opener->next;
        -: 3248:    }
        -: 3249:}
        -: 3250:
        -: 3251:static void
    #####: 3252:md_analyze_bracket(MD_CTX* ctx, int mark_index)
        -: 3253:{
        -: 3254:    /* We cannot really resolve links here as for that we would need
        -: 3255:     * more context. E.g. a following pair of brackets (reference link),
        -: 3256:     * or enclosing pair of brackets (if the inner is the link, the outer
        -: 3257:     * one cannot be.)
        -: 3258:     *
        -: 3259:     * Therefore we here only construct a list of resolved '[' ']' pairs
        -: 3260:     * ordered by position of the closer. This allows ur to analyze what is
        -: 3261:     * or is not link in the right order, from inside to outside in case
        -: 3262:     * of nested brackets.
        -: 3263:     *
        -: 3264:     * The resolving itself is deferred into md_resolve_links().
        -: 3265:     */
        -: 3266:
    #####: 3267:    MD_MARK* mark = &ctx->marks[mark_index];
        -: 3268:
    #####: 3269:    if(mark->flags & MD_MARK_POTENTIAL_OPENER) {
    #####: 3270:        md_mark_chain_append(ctx, &BRACKET_OPENERS, mark_index);
        -: 3271:        return;
        -: 3272:    }
        -: 3273:
    #####: 3274:    if(BRACKET_OPENERS.tail >= 0) {
        -: 3275:        /* Pop the opener from the chain. */
    #####: 3276:        int opener_index = BRACKET_OPENERS.tail;
    #####: 3277:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3278:        if(opener->prev >= 0)
    #####: 3279:            ctx->marks[opener->prev].next = -1;
        -: 3280:        else
    #####: 3281:            BRACKET_OPENERS.head = -1;
    #####: 3282:        BRACKET_OPENERS.tail = opener->prev;
        -: 3283:
        -: 3284:        /* Interconnect the opener and closer. */
    #####: 3285:        opener->next = mark_index;
    #####: 3286:        mark->prev = opener_index;
        -: 3287:
        -: 3288:        /* Add the pair into chain of potential links for md_resolve_links().
        -: 3289:         * Note we misuse opener->prev for this as opener->next points to its
        -: 3290:         * closer. */
    #####: 3291:        if(ctx->unresolved_link_tail >= 0)
    #####: 3292:            ctx->marks[ctx->unresolved_link_tail].prev = opener_index;
        -: 3293:        else
    #####: 3294:            ctx->unresolved_link_head = opener_index;
    #####: 3295:        ctx->unresolved_link_tail = opener_index;
    #####: 3296:        opener->prev = -1;
        -: 3297:    }
        -: 3298:}
        -: 3299:
        -: 3300:/* Forward declaration. */
        -: 3301:static void md_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3302:                                     int mark_beg, int mark_end);
        -: 3303:
        -: 3304:static int
        1: 3305:md_resolve_links(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 3306:{
        1: 3307:    int opener_index = ctx->unresolved_link_head;
        1: 3308:    OFF last_link_beg = 0;
        1: 3309:    OFF last_link_end = 0;
        1: 3310:    OFF last_img_beg = 0;
        1: 3311:    OFF last_img_end = 0;
        -: 3312:
        2: 3313:    while(opener_index >= 0) {
    #####: 3314:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3315:        int closer_index = opener->next;
    #####: 3316:        MD_MARK* closer = &ctx->marks[closer_index];
    #####: 3317:        int next_index = opener->prev;
        -: 3318:        MD_MARK* next_opener;
        -: 3319:        MD_MARK* next_closer;
    #####: 3320:        MD_LINK_ATTR attr;
    #####: 3321:        int is_link = FALSE;
        -: 3322:
    #####: 3323:        if(next_index >= 0) {
    #####: 3324:            next_opener = &ctx->marks[next_index];
    #####: 3325:            next_closer = &ctx->marks[next_opener->next];
        -: 3326:        } else {
        -: 3327:            next_opener = NULL;
        -: 3328:            next_closer = NULL;
        -: 3329:        }
        -: 3330:
        -: 3331:        /* If nested ("[ [ ] ]"), we need to make sure that:
        -: 3332:         *   - The outer does not end inside of (...) belonging to the inner.
        -: 3333:         *   - The outer cannot be link if the inner is link (i.e. not image).
        -: 3334:         *
        -: 3335:         * (Note we here analyze from inner to outer as the marks are ordered
        -: 3336:         * by closer->beg.)
        -: 3337:         */
    #####: 3338:        if((opener->beg < last_link_beg  &&  closer->end < last_link_end)  ||
    #####: 3339:           (opener->beg < last_img_beg  &&  closer->end < last_img_end)  ||
    #####: 3340:           (opener->beg < last_link_end  &&  opener->ch == '['))
        -: 3341:        {
    #####: 3342:            opener_index = next_index;
    #####: 3343:            continue;
        -: 3344:        }
        -: 3345:
    #####: 3346:        if(next_opener != NULL  &&  next_opener->beg == closer->end) {
    #####: 3347:            if(next_closer->beg > closer->end + 1) {
        -: 3348:                /* Might be full reference link. */
    #####: 3349:                is_link = md_is_link_reference(ctx, lines, n_lines, next_opener->beg, next_closer->end, &attr);
        -: 3350:            } else {
        -: 3351:                /* Might be shortcut reference link. */
    #####: 3352:                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);
        -: 3353:            }
        -: 3354:
    #####: 3355:            if(is_link < 0)
    #####: 3356:                return -1;
        -: 3357:
    #####: 3358:            if(is_link) {
        -: 3359:                /* Eat the 2nd "[...]". */
    #####: 3360:                closer->end = next_closer->end;
        -: 3361:            }
        -: 3362:        } else {
    #####: 3363:            if(closer->end < ctx->size  &&  CH(closer->end) == _T('(')) {
        -: 3364:                /* Might be inline link. */
    #####: 3365:                OFF inline_link_end = -1;
        -: 3366:
    #####: 3367:                is_link = md_is_inline_link_spec(ctx, lines, n_lines, closer->end, &inline_link_end, &attr);
    #####: 3368:                if(is_link < 0)
    #####: 3369:                    return -1;
        -: 3370:
        -: 3371:                /* Check the closing ')' is not inside an already resolved range
        -: 3372:                 * (i.e. a range with a higher priority), e.g. a code span. */
    #####: 3373:                if(is_link) {
    #####: 3374:                    int i = closer_index + 1;
        -: 3375:
    #####: 3376:                    while(i < ctx->n_marks) {
    #####: 3377:                        MD_MARK* mark = &ctx->marks[i];
        -: 3378:
    #####: 3379:                        if(mark->beg >= inline_link_end)
        -: 3380:                            break;
    #####: 3381:                        if((mark->flags & (MD_MARK_OPENER | MD_MARK_RESOLVED)) == (MD_MARK_OPENER | MD_MARK_RESOLVED)) {
    #####: 3382:                            if(ctx->marks[mark->next].beg >= inline_link_end) {
        -: 3383:                                /* Cancel the link status. */
    #####: 3384:                                if(attr.title_needs_free)
    #####: 3385:                                    free(attr.title);
        -: 3386:                                is_link = FALSE;
        -: 3387:                                break;
        -: 3388:                            }
        -: 3389:
    #####: 3390:                            i = mark->next + 1;
        -: 3391:                        } else {
    #####: 3392:                            i++;
        -: 3393:                        }
        -: 3394:                    }
        -: 3395:                }
        -: 3396:
    #####: 3397:                if(is_link) {
        -: 3398:                    /* Eat the "(...)" */
    #####: 3399:                    closer->end = inline_link_end;
        -: 3400:                }
        -: 3401:            }
        -: 3402:
    #####: 3403:            if(!is_link) {
        -: 3404:                /* Might be collapsed reference link. */
    #####: 3405:                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);
    #####: 3406:                if(is_link < 0)
        -: 3407:                    return -1;
        -: 3408:            }
        -: 3409:        }
        -: 3410:
    #####: 3411:        if(is_link) {
        -: 3412:            /* Resolve the brackets as a link. */
    #####: 3413:            opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;
    #####: 3414:            closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;
        -: 3415:
        -: 3416:            /* If it is a link, we store the destination and title in the two
        -: 3417:             * dummy marks after the opener. */
    #####: 3418:            MD_ASSERT(ctx->marks[opener_index+1].ch == 'D');
    #####: 3419:            ctx->marks[opener_index+1].beg = attr.dest_beg;
    #####: 3420:            ctx->marks[opener_index+1].end = attr.dest_end;
        -: 3421:
    #####: 3422:            MD_ASSERT(ctx->marks[opener_index+2].ch == 'D');
    #####: 3423:            md_mark_store_ptr(ctx, opener_index+2, attr.title);
    #####: 3424:            if(attr.title_needs_free)
    #####: 3425:                md_mark_chain_append(ctx, &PTR_CHAIN, opener_index+2);
    #####: 3426:            ctx->marks[opener_index+2].prev = attr.title_size;
        -: 3427:
    #####: 3428:            if(opener->ch == '[') {
    #####: 3429:                last_link_beg = opener->beg;
    #####: 3430:                last_link_end = closer->end;
        -: 3431:            } else {
    #####: 3432:                last_img_beg = opener->beg;
    #####: 3433:                last_img_end = closer->end;
        -: 3434:            }
        -: 3435:
    #####: 3436:            md_analyze_link_contents(ctx, lines, n_lines, opener_index+1, closer_index);
        -: 3437:        }
        -: 3438:
    #####: 3439:        opener_index = next_index;
        -: 3440:    }
        -: 3441:
        -: 3442:    return 0;
        -: 3443:}
        -: 3444:
        -: 3445:/* Analyze whether the mark '&' starts a HTML entity.
        -: 3446: * If so, update its flags as well as flags of corresponding closer ';'. */
        -: 3447:static void
    #####: 3448:md_analyze_entity(MD_CTX* ctx, int mark_index)
        -: 3449:{
    #####: 3450:    MD_MARK* opener = &ctx->marks[mark_index];
        -: 3451:    MD_MARK* closer;
    #####: 3452:    OFF off;
        -: 3453:
        -: 3454:    /* Cannot be entity if there is no closer as the next mark.
        -: 3455:     * (Any other mark between would mean strange character which cannot be
        -: 3456:     * part of the entity.
        -: 3457:     *
        -: 3458:     * So we can do all the work on '&' and do not call this later for the
        -: 3459:     * closing mark ';'.
        -: 3460:     */
    #####: 3461:    if(mark_index + 1 >= ctx->n_marks)
    #####: 3462:        return;
    #####: 3463:    closer = &ctx->marks[mark_index+1];
    #####: 3464:    if(closer->ch != ';')
        -: 3465:        return;
        -: 3466:
    #####: 3467:    if(md_is_entity(ctx, opener->beg, closer->end, &off)) {
    #####: 3468:        MD_ASSERT(off == closer->end);
        -: 3469:
    #####: 3470:        md_resolve_range(ctx, NULL, mark_index, mark_index+1);
    #####: 3471:        opener->end = closer->end;
        -: 3472:    }
        -: 3473:}
        -: 3474:
        -: 3475:static void
        -: 3476:md_analyze_table_cell_boundary(MD_CTX* ctx, int mark_index)
        -: 3477:{
    #####: 3478:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 3479:    mark->flags |= MD_MARK_RESOLVED;
        -: 3480:
    #####: 3481:    md_mark_chain_append(ctx, &TABLECELLBOUNDARIES, mark_index);
    #####: 3482:    ctx->n_table_cell_boundaries++;
        -: 3483:}
        -: 3484:
        -: 3485:/* Split a longer mark into two. The new mark takes the given count of
        -: 3486: * characters. May only be called if an adequate number of dummy 'D' marks
        -: 3487: * follows.
        -: 3488: */
        -: 3489:static int
        3: 3490:md_split_simple_pairing_mark(MD_CTX* ctx, int mark_index, SZ n)
        -: 3491:{
        3: 3492:    MD_MARK* mark = &ctx->marks[mark_index];
        3: 3493:    int new_mark_index = mark_index + (mark->end - mark->beg - 1);
        3: 3494:    MD_MARK* dummy = &ctx->marks[new_mark_index];
        -: 3495:
        3: 3496:    MD_ASSERT(mark->end - mark->beg > n);
        3: 3497:    MD_ASSERT(dummy->ch == 'D');
        -: 3498:
        2: 3499:    memcpy(dummy, mark, sizeof(MD_MARK));
        2: 3500:    mark->end -= n;
        2: 3501:    dummy->beg = mark->end;
        -: 3502:
        2: 3503:    return new_mark_index;
        -: 3504:}
        -: 3505:
        -: 3506:static void
        5: 3507:md_analyze_simple_pairing_mark(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index,
        -: 3508:                               int apply_rule_of_three)
        -: 3509:{
        5: 3510:    MD_MARK* mark = &ctx->marks[mark_index];
        -: 3511:
        -: 3512:    /* If we can be a closer, try to resolve with the preceding opener. */
        5: 3513:    if((mark->flags & MD_MARK_POTENTIAL_CLOSER)  &&  chain->tail >= 0) {
        3: 3514:        int opener_index = chain->tail;
        3: 3515:        MD_MARK* opener = &ctx->marks[opener_index];
        3: 3516:        SZ opener_size = opener->end - opener->beg;
        3: 3517:        SZ closer_size = mark->end - mark->beg;
        -: 3518:
        -: 3519:        /* Apply the "rule of three". */
        3: 3520:        if(apply_rule_of_three) {
        3: 3521:            while((mark->flags & MD_MARK_EMPH_INTRAWORD) || (opener->flags & MD_MARK_EMPH_INTRAWORD)) {
        -: 3522:                SZ opener_orig_size_modulo3;
        -: 3523:
    #####: 3524:                switch(opener->flags & MD_MARK_EMPH_MODULO3_MASK) {
        -: 3525:                    case MD_MARK_EMPH_MODULO3_0:    opener_orig_size_modulo3 = 0; break;
    #####: 3526:                    case MD_MARK_EMPH_MODULO3_1:    opener_orig_size_modulo3 = 1; break;
    #####: 3527:                    case MD_MARK_EMPH_MODULO3_2:    opener_orig_size_modulo3 = 2; break;
    #####: 3528:                    default:                        MD_UNREACHABLE(); break;
        -: 3529:                }
        -: 3530:
    #####: 3531:                if((opener_orig_size_modulo3 + closer_size) % 3 != 0) {
        -: 3532:                    /* This opener is suitable. */
        -: 3533:                    break;
        -: 3534:                }
        -: 3535:
    #####: 3536:                if(opener->prev >= 0) {
        -: 3537:                    /* Try previous opener. */
    #####: 3538:                    opener_index = opener->prev;
    #####: 3539:                    opener = &ctx->marks[opener_index];
    #####: 3540:                    opener_size = opener->end - opener->beg;
    #####: 3541:                    closer_size = mark->end - mark->beg;
        -: 3542:                } else {
        -: 3543:                    /* No suitable opener found. */
        -: 3544:                    goto cannot_resolve;
        -: 3545:                }
        -: 3546:            }
        -: 3547:        }
        -: 3548:
        3: 3549:        if(opener_size > closer_size) {
        1: 3550:            opener_index = md_split_simple_pairing_mark(ctx, opener_index, closer_size);
        1: 3551:            md_mark_chain_append(ctx, chain, opener_index);
        2: 3552:        } else if(opener_size < closer_size) {
        2: 3553:            md_split_simple_pairing_mark(ctx, mark_index, closer_size - opener_size);
        -: 3554:        }
        -: 3555:
        2: 3556:        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);
        2: 3557:        md_resolve_range(ctx, chain, opener_index, mark_index);
        2: 3558:        return;
        -: 3559:    }
        -: 3560:
        2: 3561:cannot_resolve:
        -: 3562:    /* If not resolved, and we can be an opener, remember the mark for
        -: 3563:     * the future. */
        2: 3564:    if(mark->flags & MD_MARK_POTENTIAL_OPENER)
        2: 3565:        md_mark_chain_append(ctx, chain, mark_index);
        -: 3566:}
        -: 3567:
        -: 3568:static inline void
        -: 3569:md_analyze_asterisk(MD_CTX* ctx, int mark_index)
        -: 3570:{
    #####: 3571:    md_analyze_simple_pairing_mark(ctx, &ASTERISK_OPENERS, mark_index, 1);
        -: 3572:}
        -: 3573:
        -: 3574:static inline void
        -: 3575:md_analyze_underscore(MD_CTX* ctx, int mark_index)
        -: 3576:{
        5: 3577:    md_analyze_simple_pairing_mark(ctx, &UNDERSCORE_OPENERS, mark_index, 1);
        -: 3578:}
        -: 3579:
        -: 3580:static void
    #####: 3581:md_analyze_tilde(MD_CTX* ctx, int mark_index)
        -: 3582:{
        -: 3583:    /* We attempt to be Github Flavored Markdown compatible here. GFM says
        -: 3584:     * that length of the tilde sequence is not important at all. Note that
        -: 3585:     * implies the TILDE_OPENERS chain can have at most one item. */
        -: 3586:
    #####: 3587:    if(TILDE_OPENERS.head >= 0) {
        -: 3588:        /* The chain already contains an opener, so we may resolve the span. */
    #####: 3589:        int opener_index = TILDE_OPENERS.head;
        -: 3590:
    #####: 3591:        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);
    #####: 3592:        md_resolve_range(ctx, &TILDE_OPENERS, opener_index, mark_index);
        -: 3593:    } else {
        -: 3594:        /* We can only be opener. */
    #####: 3595:        md_mark_chain_append(ctx, &TILDE_OPENERS, mark_index);
        -: 3596:    }
    #####: 3597:}
        -: 3598:
        -: 3599:static void
    #####: 3600:md_analyze_permissive_url_autolink(MD_CTX* ctx, int mark_index)
        -: 3601:{
    #####: 3602:    MD_MARK* opener = &ctx->marks[mark_index];
    #####: 3603:    int closer_index = mark_index + 1;
    #####: 3604:    MD_MARK* closer = &ctx->marks[mark_index + 1];
        -: 3605:    MD_MARK* next_resolved_mark;
    #####: 3606:    OFF off = opener->end;
    #####: 3607:    int seen_dot = FALSE;
    #####: 3608:    int seen_underscore_or_hyphen[2] = { FALSE, FALSE };
        -: 3609:
        -: 3610:    /* Check for domain. */
    #####: 3611:    while(off < ctx->size) {
    #####: 3612:        if(ISALNUM(off)) {
    #####: 3613:            off++;
    #####: 3614:        } else if(CH(off) == _T('.')) {
    #####: 3615:            seen_dot = TRUE;
    #####: 3616:            seen_underscore_or_hyphen[0] = seen_underscore_or_hyphen[1];
    #####: 3617:            seen_underscore_or_hyphen[1] = FALSE;
    #####: 3618:            off++;
    #####: 3619:        } else if(ISANYOF2(off, _T('-'), _T('_'))) {
    #####: 3620:            seen_underscore_or_hyphen[1] = TRUE;
    #####: 3621:            off++;
        -: 3622:        } else {
        -: 3623:            break;
        -: 3624:        }
        -: 3625:    }
        -: 3626:
    #####: 3627:    if(off <= opener->end || !seen_dot || seen_underscore_or_hyphen[0] || seen_underscore_or_hyphen[1])
        -: 3628:        return;
        -: 3629:
        -: 3630:    /* Check for path. */
    #####: 3631:    next_resolved_mark = closer + 1;
    #####: 3632:    while(next_resolved_mark->ch == 'D' || !(next_resolved_mark->flags & MD_MARK_RESOLVED))
    #####: 3633:        next_resolved_mark++;
    #####: 3634:    while(off < next_resolved_mark->beg  &&  CH(off) != _T('<')  &&  !ISWHITESPACE(off)  &&  !ISNEWLINE(off))
    #####: 3635:        off++;
        -: 3636:
        -: 3637:    /* Path validation. */
    #####: 3638:    if(ISANYOF(off-1, _T("?!.,:*_~)"))) {
    #####: 3639:        if(CH(off-1) != _T(')')) {
        -: 3640:            off--;
        -: 3641:        } else {
        -: 3642:            int parenthesis_balance = 0;
        -: 3643:            OFF tmp;
        -: 3644:
    #####: 3645:            for(tmp = opener->end; tmp < off; tmp++) {
    #####: 3646:                if(CH(tmp) == _T('('))
    #####: 3647:                    parenthesis_balance++;
    #####: 3648:                else if(CH(tmp) == _T(')'))
    #####: 3649:                    parenthesis_balance--;
        -: 3650:            }
        -: 3651:
    #####: 3652:            if(parenthesis_balance < 0)
    #####: 3653:                off--;
        -: 3654:        }
        -: 3655:    }
        -: 3656:
        -: 3657:    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero
        -: 3658:     * length so all the contents becomes the link text. */
    #####: 3659:    MD_ASSERT(closer->ch == 'D');
    #####: 3660:    opener->end = opener->beg;
    #####: 3661:    closer->ch = opener->ch;
    #####: 3662:    closer->beg = off;
    #####: 3663:    closer->end = off;
    #####: 3664:    md_resolve_range(ctx, NULL, mark_index, closer_index);
        -: 3665:}
        -: 3666:
        -: 3667:/* The permissive autolinks do not have to be enclosed in '<' '>' but we
        -: 3668: * instead impose stricter rules what is understood as an e-mail address
        -: 3669: * here. Actually any non-alphanumeric characters with exception of '.'
        -: 3670: * are prohibited both in username and after '@'. */
        -: 3671:static void
    #####: 3672:md_analyze_permissive_email_autolink(MD_CTX* ctx, int mark_index)
        -: 3673:{
    #####: 3674:    MD_MARK* opener = &ctx->marks[mark_index];
        -: 3675:    int closer_index;
        -: 3676:    MD_MARK* closer;
    #####: 3677:    OFF beg = opener->beg;
    #####: 3678:    OFF end = opener->end;
    #####: 3679:    int dot_count = 0;
        -: 3680:
    #####: 3681:    MD_ASSERT(CH(beg) == _T('@'));
        -: 3682:
        -: 3683:    /* Scan for name before '@'. */
    #####: 3684:    while(beg > 0  &&  (ISALNUM(beg-1) || ISANYOF(beg-1, _T(".-_+"))))
        -: 3685:        beg--;
        -: 3686:
        -: 3687:    /* Scan for domain after '@'. */
    #####: 3688:    while(end < ctx->size  &&  (ISALNUM(end) || ISANYOF(end, _T(".-_")))) {
    #####: 3689:        if(CH(end) == _T('.'))
    #####: 3690:            dot_count++;
    #####: 3691:        end++;
        -: 3692:    }
    #####: 3693:    if(CH(end-1) == _T('.')) {  /* Final '.' not part of it. */
    #####: 3694:        dot_count--;
    #####: 3695:        end--;
        -: 3696:    }
    #####: 3697:    else if(ISANYOF2(end-1, _T('-'), _T('_'))) /* These are forbidden at the end. */
        -: 3698:        return;
    #####: 3699:    if(CH(end-1) == _T('@')  ||  dot_count == 0)
        -: 3700:        return;
        -: 3701:
        -: 3702:    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero
        -: 3703:     * length so all the contents becomes the link text. */
    #####: 3704:    closer_index = mark_index + 1;
    #####: 3705:    closer = &ctx->marks[closer_index];
    #####: 3706:    MD_ASSERT(closer->ch == 'D');
        -: 3707:
    #####: 3708:    opener->beg = beg;
    #####: 3709:    opener->end = beg;
    #####: 3710:    closer->ch = opener->ch;
    #####: 3711:    closer->beg = end;
    #####: 3712:    closer->end = end;
    #####: 3713:    md_resolve_range(ctx, NULL, mark_index, closer_index);
        -: 3714:}
        -: 3715:
        -: 3716:static inline void
        3: 3717:md_analyze_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3718:                 int mark_beg, int mark_end, const CHAR* mark_chars)
        -: 3719:{
        3: 3720:    int i = mark_beg;
        -: 3721:
       28: 3722:    while(i < mark_end) {
       23: 3723:        MD_MARK* mark = &ctx->marks[i];
        -: 3724:
        -: 3725:        /* Skip resolved spans. */
       23: 3726:        if(mark->flags & MD_MARK_RESOLVED) {
        2: 3727:            if(mark->flags & MD_MARK_OPENER) {
    #####: 3728:                MD_ASSERT(i < mark->next);
    #####: 3729:                i = mark->next + 1;
        -: 3730:            } else {
        2: 3731:                i++;
        -: 3732:            }
        2: 3733:            continue;
        -: 3734:        }
        -: 3735:
        -: 3736:        /* Skip marks we do not want to deal with. */
       42: 3737:        if(!ISANYOF_(mark->ch, mark_chars)) {
       16: 3738:            i++;
       16: 3739:            continue;
        -: 3740:        }
        -: 3741:
        -: 3742:        /* Analyze the mark. */
        5: 3743:        switch(mark->ch) {
    #####: 3744:            case '`':   md_analyze_backtick(ctx, i); break;
    #####: 3745:            case '<':   /* Pass through. */
    #####: 3746:            case '>':   md_analyze_lt_gt(ctx, i, lines, n_lines); break;
    #####: 3747:            case '[':   /* Pass through. */
        -: 3748:            case '!':   /* Pass through. */
    #####: 3749:            case ']':   md_analyze_bracket(ctx, i); break;
    #####: 3750:            case '&':   md_analyze_entity(ctx, i); break;
    #####: 3751:            case '|':   md_analyze_table_cell_boundary(ctx, i); break;
    #####: 3752:            case '*':   md_analyze_asterisk(ctx, i); break;
        5: 3753:            case '_':   md_analyze_underscore(ctx, i); break;
    #####: 3754:            case '~':   md_analyze_tilde(ctx, i); break;
    #####: 3755:            case '.':   /* Pass through. */
    #####: 3756:            case ':':   md_analyze_permissive_url_autolink(ctx, i); break;
    #####: 3757:            case '@':   md_analyze_permissive_email_autolink(ctx, i); break;
        -: 3758:        }
        -: 3759:
        4: 3760:        i++;
        -: 3761:    }
        2: 3762:}
        -: 3763:
        -: 3764:/* Analyze marks (build ctx->marks). */
        -: 3765:static int
        1: 3766:md_analyze_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)
        -: 3767:{
        -: 3768:    int ret;
        -: 3769:
        -: 3770:    /* Reset the previously collected stack of marks. */
        1: 3771:    ctx->n_marks = 0;
        -: 3772:
        -: 3773:    /* Collect all marks. */
        1: 3774:    if(md_collect_marks(ctx, lines, n_lines, table_mode) != 0)
        -: 3775:        return -1;
        -: 3776:
        -: 3777:    /* We analyze marks in few groups to handle their precedence. */
        -: 3778:    /* (1) Entities; code spans; autolinks; raw HTML. */
        1: 3779:    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("&`<>"));
        1: 3780:    BACKTICK_OPENERS.head = -1;
        1: 3781:    BACKTICK_OPENERS.tail = -1;
        1: 3782:    LOWERTHEN_OPENERS.head = -1;
        1: 3783:    LOWERTHEN_OPENERS.tail = -1;
        -: 3784:    /* (2) Links. */
        1: 3785:    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("[]!"));
        1: 3786:    MD_CHECK(md_resolve_links(ctx, lines, n_lines));
        1: 3787:    BRACKET_OPENERS.head = -1;
        1: 3788:    BRACKET_OPENERS.tail = -1;
        1: 3789:    ctx->unresolved_link_head = -1;
        1: 3790:    ctx->unresolved_link_tail = -1;
        1: 3791:    if(table_mode) {
        -: 3792:        /* (3a) Analyze table cell boundaries.
        -: 3793:         * Note we reset TABLECELLBOUNDARIES chain prior to the call md_analyze_marks(),
        -: 3794:         * not after, because caller may need it. */
    #####: 3795:        MD_ASSERT(n_lines == 1);
    #####: 3796:        TABLECELLBOUNDARIES.head = -1;
    #####: 3797:        TABLECELLBOUNDARIES.tail = -1;
    #####: 3798:        ctx->n_table_cell_boundaries = 0;
    #####: 3799:        md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("|"));
        -: 3800:    } else {
        -: 3801:        /* (3b) Emphasis and strong emphasis; permissive autolinks. */
        1: 3802:        md_analyze_link_contents(ctx, lines, n_lines, 0, ctx->n_marks);
        -: 3803:    }
        -: 3804:
    #####: 3805:abort:
        -: 3806:    return ret;
        -: 3807:}
        -: 3808:
        -: 3809:static void
        -: 3810:md_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3811:                         int mark_beg, int mark_end)
        -: 3812:{
        1: 3813:    md_analyze_marks(ctx, lines, n_lines, mark_beg, mark_end, _T("*_~@:."));
    #####: 3814:    ASTERISK_OPENERS.head = -1;
    #####: 3815:    ASTERISK_OPENERS.tail = -1;
    #####: 3816:    UNDERSCORE_OPENERS.head = -1;
    #####: 3817:    UNDERSCORE_OPENERS.tail = -1;
    #####: 3818:    TILDE_OPENERS.head = -1;
    #####: 3819:    TILDE_OPENERS.tail = -1;
        -: 3820:}
        -: 3821:
        -: 3822:static int
    #####: 3823:md_enter_leave_span_a(MD_CTX* ctx, int enter, MD_SPANTYPE type,
        -: 3824:                      const CHAR* dest, SZ dest_size, int prohibit_escapes_in_dest,
        -: 3825:                      const CHAR* title, SZ title_size)
        -: 3826:{
    #####: 3827:    MD_ATTRIBUTE_BUILD href_build;
    #####: 3828:    MD_ATTRIBUTE_BUILD title_build;
    #####: 3829:    MD_SPAN_A_DETAIL det;
    #####: 3830:    int ret = 0;
        -: 3831:
        -: 3832:    /* Note we here rely on fact that MD_SPAN_A_DETAIL and
        -: 3833:     * MD_SPAN_IMG_DETAIL are binary-compatible. */
    #####: 3834:    memset(&det, 0, sizeof(MD_SPAN_A_DETAIL));
    #####: 3835:    MD_CHECK(md_build_attribute(ctx, dest, dest_size,
        -: 3836:                    (prohibit_escapes_in_dest ? MD_BUILD_ATTR_NO_ESCAPES : 0),
        -: 3837:                    &det.href, &href_build));
    #####: 3838:    MD_CHECK(md_build_attribute(ctx, title, title_size, 0, &det.title, &title_build));
        -: 3839:
    #####: 3840:    if(enter)
    #####: 3841:        MD_ENTER_SPAN(type, &det);
        -: 3842:    else
    #####: 3843:        MD_LEAVE_SPAN(type, &det);
        -: 3844:
    #####: 3845:abort:
    #####: 3846:    md_free_attribute(ctx, &href_build);
    #####: 3847:    md_free_attribute(ctx, &title_build);
    #####: 3848:    return ret;
        -: 3849:}
        -: 3850:
        -: 3851:/* Render the output, accordingly to the analyzed ctx->marks. */
        -: 3852:static int
    #####: 3853:md_process_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 3854:{
        -: 3855:    MD_TEXTTYPE text_type;
    #####: 3856:    const MD_LINE* line = lines;
    #####: 3857:    MD_MARK* prev_mark = NULL;
        -: 3858:    MD_MARK* mark;
    #####: 3859:    OFF off = lines[0].beg;
    #####: 3860:    OFF end = lines[n_lines-1].end;
    #####: 3861:    int enforce_hardbreak = 0;
    #####: 3862:    int ret = 0;
        -: 3863:
        -: 3864:    /* Find first resolved mark. Note there is always at least one resolved
        -: 3865:     * mark,  the dummy last one after the end of the latest line we actually
        -: 3866:     * never really reach. This saves us of a lot of special checks and cases
        -: 3867:     * in this function. */
    #####: 3868:    mark = ctx->marks;
    #####: 3869:    while(!(mark->flags & MD_MARK_RESOLVED))
    #####: 3870:        mark++;
        -: 3871:
        -: 3872:    text_type = MD_TEXT_NORMAL;
        -: 3873:
        -: 3874:    while(1) {
        -: 3875:        /* Process the text up to the next mark or end-of-line. */
    #####: 3876:        OFF tmp = (line->end < mark->beg ? line->end : mark->beg);
    #####: 3877:        if(tmp > off) {
    #####: 3878:            MD_TEXT(text_type, STR(off), tmp - off);
        -: 3879:            off = tmp;
        -: 3880:        }
        -: 3881:
        -: 3882:        /* If reached the mark, process it and move to next one. */
    #####: 3883:        if(off >= mark->beg) {
    #####: 3884:            switch(mark->ch) {
    #####: 3885:                case '\\':      /* Backslash escape. */
    #####: 3886:                    if(ISNEWLINE(mark->beg+1))
        -: 3887:                        enforce_hardbreak = 1;
        -: 3888:                    else
    #####: 3889:                        MD_TEXT(text_type, STR(mark->beg+1), 1);
        -: 3890:                    break;
        -: 3891:
        -: 3892:                case ' ':       /* Non-trivial space. */
    #####: 3893:                    MD_TEXT(text_type, _T(" "), 1);
        -: 3894:                    break;
        -: 3895:
    #####: 3896:                case '`':       /* Code span. */
    #####: 3897:                    if(mark->flags & MD_MARK_OPENER) {
    #####: 3898:                        MD_ENTER_SPAN(MD_SPAN_CODE, NULL);
        -: 3899:                        text_type = MD_TEXT_CODE;
        -: 3900:                    } else {
    #####: 3901:                        MD_LEAVE_SPAN(MD_SPAN_CODE, NULL);
        -: 3902:                        text_type = MD_TEXT_NORMAL;
        -: 3903:                    }
        -: 3904:                    break;
        -: 3905:
    #####: 3906:                case '_':
        -: 3907:                case '*':       /* Emphasis, strong emphasis. */
    #####: 3908:                    if(mark->flags & MD_MARK_OPENER) {
    #####: 3909:                        if((mark->end - off) % 2) {
    #####: 3910:                            MD_ENTER_SPAN(MD_SPAN_EM, NULL);
    #####: 3911:                            off++;
        -: 3912:                        }
    #####: 3913:                        while(off + 1 < mark->end) {
    #####: 3914:                            MD_ENTER_SPAN(MD_SPAN_STRONG, NULL);
    #####: 3915:                            off += 2;
        -: 3916:                        }
        -: 3917:                    } else {
    #####: 3918:                        while(off + 1 < mark->end) {
    #####: 3919:                            MD_LEAVE_SPAN(MD_SPAN_STRONG, NULL);
    #####: 3920:                            off += 2;
        -: 3921:                        }
    #####: 3922:                        if((mark->end - off) % 2) {
    #####: 3923:                            MD_LEAVE_SPAN(MD_SPAN_EM, NULL);
        -: 3924:                            off++;
        -: 3925:                        }
        -: 3926:                    }
        -: 3927:                    break;
        -: 3928:
    #####: 3929:                case '~':
    #####: 3930:                    if(mark->flags & MD_MARK_OPENER)
    #####: 3931:                        MD_ENTER_SPAN(MD_SPAN_DEL, NULL);
        -: 3932:                    else
    #####: 3933:                        MD_LEAVE_SPAN(MD_SPAN_DEL, NULL);
        -: 3934:                    break;
        -: 3935:
    #####: 3936:                case '[':       /* Link, image. */
        -: 3937:                case '!':
        -: 3938:                case ']':
        -: 3939:                {
    #####: 3940:                    const MD_MARK* opener = (mark->ch != ']' ? mark : &ctx->marks[mark->prev]);
    #####: 3941:                    const MD_MARK* dest_mark = opener+1;
    #####: 3942:                    const MD_MARK* title_mark = opener+2;
        -: 3943:
    #####: 3944:                    MD_ASSERT(dest_mark->ch == 'D');
    #####: 3945:                    MD_ASSERT(title_mark->ch == 'D');
        -: 3946:
    #####: 3947:                    MD_CHECK(md_enter_leave_span_a(ctx, (mark->ch != ']'),
        -: 3948:                                (opener->ch == '!' ? MD_SPAN_IMG : MD_SPAN_A),
        -: 3949:                                STR(dest_mark->beg), dest_mark->end - dest_mark->beg, FALSE,
        -: 3950:                                md_mark_get_ptr(ctx, title_mark - ctx->marks), title_mark->prev));
        -: 3951:                    break;
        -: 3952:                }
        -: 3953:
    #####: 3954:                case '<':
        -: 3955:                case '>':       /* Autolink or raw HTML. */
    #####: 3956:                    if(!(mark->flags & MD_MARK_AUTOLINK)) {
        -: 3957:                        /* Raw HTML. */
    #####: 3958:                        if(mark->flags & MD_MARK_OPENER)
        -: 3959:                            text_type = MD_TEXT_HTML;
        -: 3960:                        else
    #####: 3961:                            text_type = MD_TEXT_NORMAL;
        -: 3962:                        break;
        -: 3963:                    }
        -: 3964:                    /* Pass through, if auto-link. */
        -: 3965:
        -: 3966:                case '@':       /* Permissive e-mail autolink. */
        -: 3967:                case ':':       /* Permissive URL autolink. */
        -: 3968:                case '.':       /* Permissive WWW autolink. */
        -: 3969:                {
    #####: 3970:                    const MD_MARK* opener = ((mark->flags & MD_MARK_OPENER) ? mark : &ctx->marks[mark->prev]);
    #####: 3971:                    const MD_MARK* closer = &ctx->marks[opener->next];
    #####: 3972:                    const CHAR* dest = STR(opener->end);
    #####: 3973:                    SZ dest_size = closer->beg - opener->end;
        -: 3974:
    #####: 3975:                    if(opener->ch == '@' || opener->ch == '.') {
    #####: 3976:                        dest_size += 7;
    #####: 3977:                        MD_TEMP_BUFFER(dest_size * sizeof(CHAR));
    #####: 3978:                        memcpy(ctx->buffer,
    #####: 3979:                                (opener->ch == '@' ? _T("mailto:") : _T("http://")),
        -: 3980:                                7 * sizeof(CHAR));
    #####: 3981:                        memcpy(ctx->buffer + 7, dest, (dest_size-7) * sizeof(CHAR));
    #####: 3982:                        dest = ctx->buffer;
        -: 3983:                    }
        -: 3984:
    #####: 3985:                    MD_CHECK(md_enter_leave_span_a(ctx, (mark->flags & MD_MARK_OPENER),
        -: 3986:                                MD_SPAN_A, dest, dest_size, TRUE, NULL, 0));
        -: 3987:                    break;
        -: 3988:                }
        -: 3989:
    #####: 3990:                case '&':       /* Entity. */
    #####: 3991:                    MD_TEXT(MD_TEXT_ENTITY, STR(mark->beg), mark->end - mark->beg);
        -: 3992:                    break;
        -: 3993:
        -: 3994:                case '\0':
    #####: 3995:                    MD_TEXT(MD_TEXT_NULLCHAR, _T(""), 1);
        -: 3996:                    break;
        -: 3997:            }
        -: 3998:
    #####: 3999:            off = mark->end;
        -: 4000:
        -: 4001:            /* Move to next resolved mark. */
    #####: 4002:            prev_mark = mark;
    #####: 4003:            mark++;
    #####: 4004:            while(!(mark->flags & MD_MARK_RESOLVED)  ||  mark->beg < off)
    #####: 4005:                mark++;
        -: 4006:        }
        -: 4007:
        -: 4008:        /* If reached end of line, move to next one. */
    #####: 4009:        if(off >= line->end) {
        -: 4010:            /* If it is the last line, we are done. */
    #####: 4011:            if(off >= end)
        -: 4012:                break;
        -: 4013:
    #####: 4014:            if(text_type == MD_TEXT_CODE) {
        -: 4015:                /* Inside code spans, new lines are transformed into single
        -: 4016:                 * spaces. */
    #####: 4017:                MD_ASSERT(prev_mark != NULL);
    #####: 4018:                MD_ASSERT(prev_mark->ch == '`'  &&  (prev_mark->flags & MD_MARK_OPENER));
    #####: 4019:                MD_ASSERT(mark->ch == '`'  &&  (mark->flags & MD_MARK_CLOSER));
        -: 4020:
    #####: 4021:                if(prev_mark->end < off  &&  off < mark->beg)
    #####: 4022:                    MD_TEXT(MD_TEXT_CODE, _T(" "), 1);
    #####: 4023:            } else if(text_type == MD_TEXT_HTML) {
        -: 4024:                /* Inside raw HTML, we output the new line verbatim, including
        -: 4025:                 * any trailing spaces. */
        -: 4026:                OFF tmp = off;
        -: 4027:
    #####: 4028:                while(tmp < end  &&  ISBLANK(tmp))
    #####: 4029:                    tmp++;
    #####: 4030:                if(tmp > off)
    #####: 4031:                    MD_TEXT(MD_TEXT_HTML, STR(off), tmp - off);
    #####: 4032:                MD_TEXT(MD_TEXT_HTML, _T("\n"), 1);
        -: 4033:            } else {
        -: 4034:                /* Output soft or hard line break. */
    #####: 4035:                MD_TEXTTYPE break_type = MD_TEXT_SOFTBR;
        -: 4036:
    #####: 4037:                if(text_type == MD_TEXT_NORMAL) {
    #####: 4038:                    if(enforce_hardbreak)
        -: 4039:                        break_type = MD_TEXT_BR;
    #####: 4040:                    else if((CH(line->end) == _T(' ') && CH(line->end+1) == _T(' ')))
    #####: 4041:                        break_type = MD_TEXT_BR;
        -: 4042:                }
        -: 4043:
    #####: 4044:                MD_TEXT(break_type, _T("\n"), 1);
        -: 4045:            }
        -: 4046:
        -: 4047:            /* Switch to the following line. */
    #####: 4048:            line++;
    #####: 4049:            off = line->beg;
        -: 4050:
    #####: 4051:            enforce_hardbreak = 0;
        -: 4052:        }
        -: 4053:    }
        -: 4054:
    #####: 4055:abort:
    #####: 4056:    return ret;
        -: 4057:}
        -: 4058:
        -: 4059:
        -: 4060:/***************************
        -: 4061: ***  Processing Tables  ***
        -: 4062: ***************************/
        -: 4063:
        -: 4064:static void
    #####: 4065:md_analyze_table_alignment(MD_CTX* ctx, OFF beg, OFF end, MD_ALIGN* align, int n_align)
        -: 4066:{
        -: 4067:    static const MD_ALIGN align_map[] = { MD_ALIGN_DEFAULT, MD_ALIGN_LEFT, MD_ALIGN_RIGHT, MD_ALIGN_CENTER };
    #####: 4068:    OFF off = beg;
        -: 4069:
    #####: 4070:    while(n_align > 0) {
        -: 4071:        int index = 0;  /* index into align_map[] */
        -: 4072:
    #####: 4073:        while(CH(off) != _T('-'))
    #####: 4074:            off++;
    #####: 4075:        if(off > beg  &&  CH(off-1) == _T(':'))
    #####: 4076:            index |= 1;
    #####: 4077:        while(off < end  &&  CH(off) == _T('-'))
    #####: 4078:            off++;
    #####: 4079:        if(off < end  &&  CH(off) == _T(':'))
    #####: 4080:            index |= 2;
        -: 4081:
    #####: 4082:        *align = align_map[index];
    #####: 4083:        align++;
    #####: 4084:        n_align--;
        -: 4085:    }
        -: 4086:
    #####: 4087:}
        -: 4088:
        -: 4089:/* Forward declaration. */
        -: 4090:static int md_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines);
        -: 4091:
        -: 4092:static int
    #####: 4093:md_process_table_cell(MD_CTX* ctx, MD_BLOCKTYPE cell_type, MD_ALIGN align, OFF beg, OFF end)
        -: 4094:{
    #####: 4095:    MD_LINE line;
    #####: 4096:    MD_BLOCK_TD_DETAIL det;
    #####: 4097:    int ret = 0;
        -: 4098:
    #####: 4099:    while(beg < end  &&  ISWHITESPACE(beg))
    #####: 4100:        beg++;
    #####: 4101:    while(end > beg  &&  ISWHITESPACE(end-1))
        -: 4102:        end--;
        -: 4103:
    #####: 4104:    det.align = align;
    #####: 4105:    line.beg = beg;
    #####: 4106:    line.end = end;
        -: 4107:
    #####: 4108:    MD_ENTER_BLOCK(cell_type, &det);
    #####: 4109:    MD_CHECK(md_process_normal_block_contents(ctx, &line, 1));
    #####: 4110:    MD_LEAVE_BLOCK(cell_type, &det);
        -: 4111:
    #####: 4112:abort:
    #####: 4113:    return ret;
        -: 4114:}
        -: 4115:
        -: 4116:static int
    #####: 4117:md_process_table_row(MD_CTX* ctx, MD_BLOCKTYPE cell_type, OFF beg, OFF end,
        -: 4118:                     const MD_ALIGN* align, int n_align)
        -: 4119:{
    #####: 4120:    MD_LINE line = { beg, end };
    #####: 4121:    OFF* pipe_offs = NULL;
        -: 4122:    int i, j, n;
    #####: 4123:    int ret = 0;
        -: 4124:
        -: 4125:    /* Break the line into table cells by identifying pipe characters who
        -: 4126:     * form the cell boundary. */
    #####: 4127:    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));
        -: 4128:
        -: 4129:    /* We have to remember the cell boundaries in local buffer because
        -: 4130:     * ctx->marks[] shall be reused during cell contents processing. */
    #####: 4131:    n = ctx->n_table_cell_boundaries;
    #####: 4132:    pipe_offs = (OFF*) malloc(n * sizeof(OFF));
    #####: 4133:    if(pipe_offs == NULL) {
    #####: 4134:        MD_LOG("malloc() failed.");
        -: 4135:        ret = -1;
        -: 4136:        goto abort;
        -: 4137:    }
    #####: 4138:    for(i = TABLECELLBOUNDARIES.head, j = 0; i >= 0; i = ctx->marks[i].next) {
    #####: 4139:        MD_MARK* mark = &ctx->marks[i];
    #####: 4140:        pipe_offs[j++] = mark->beg;
        -: 4141:    }
        -: 4142:
        -: 4143:    /* Process cells. */
    #####: 4144:    MD_ENTER_BLOCK(MD_BLOCK_TR, NULL);
    #####: 4145:    j = 0;
    #####: 4146:    if(beg < pipe_offs[0]) {
    #####: 4147:        MD_CHECK(md_process_table_cell(ctx, cell_type,
        -: 4148:                    (j < n_align ? align[j++] : MD_ALIGN_DEFAULT),
        -: 4149:                    beg, pipe_offs[0]));
        -: 4150:    }
    #####: 4151:    for(i = 0; i < n-1; i++) {
    #####: 4152:        MD_CHECK(md_process_table_cell(ctx, cell_type,
        -: 4153:                    (j < n_align ? align[j++] : MD_ALIGN_DEFAULT),
        -: 4154:                    pipe_offs[i]+1, pipe_offs[i+1]));
        -: 4155:    }
    #####: 4156:    if(pipe_offs[n-1] < end-1) {
    #####: 4157:        MD_CHECK(md_process_table_cell(ctx, cell_type,
        -: 4158:                    (j < n_align ? align[j++] : MD_ALIGN_DEFAULT),
        -: 4159:                    pipe_offs[n-1]+1, end));
        -: 4160:    }
    #####: 4161:    MD_LEAVE_BLOCK(MD_BLOCK_TR, NULL);
        -: 4162:
    #####: 4163:abort:
    #####: 4164:    free(pipe_offs);
        -: 4165:
        -: 4166:    /* Free any temporary memory blocks stored within some dummy marks. */
    #####: 4167:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4168:        free(md_mark_get_ptr(ctx, i));
    #####: 4169:    PTR_CHAIN.head = -1;
    #####: 4170:    PTR_CHAIN.tail = -1;
        -: 4171:
    #####: 4172:    return ret;
        -: 4173:}
        -: 4174:
        -: 4175:static int
    #####: 4176:md_process_table_block_contents(MD_CTX* ctx, int col_count, const MD_LINE* lines, int n_lines)
        -: 4177:{
        -: 4178:    MD_ALIGN* align;
        -: 4179:    int i;
    #####: 4180:    int ret = 0;
        -: 4181:
        -: 4182:    /* At least the line with column names and the table underline have to
        -: 4183:     * be present. */
    #####: 4184:    MD_ASSERT(n_lines >= 2);
        -: 4185:
    #####: 4186:    align = malloc(col_count * sizeof(MD_ALIGN));
    #####: 4187:    if(align == NULL) {
    #####: 4188:        MD_LOG("malloc() failed.");
        -: 4189:        ret = -1;
        -: 4190:        goto abort;
        -: 4191:    }
        -: 4192:
    #####: 4193:    md_analyze_table_alignment(ctx, lines[1].beg, lines[1].end, align, col_count);
        -: 4194:
    #####: 4195:    MD_ENTER_BLOCK(MD_BLOCK_THEAD, NULL);
    #####: 4196:    MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TH,
        -: 4197:                        lines[0].beg, lines[0].end, align, col_count));
    #####: 4198:    MD_LEAVE_BLOCK(MD_BLOCK_THEAD, NULL);
        -: 4199:
    #####: 4200:    MD_ENTER_BLOCK(MD_BLOCK_TBODY, NULL);
    #####: 4201:    for(i = 2; i < n_lines; i++) {
    #####: 4202:        MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TD,
        -: 4203:                        lines[i].beg, lines[i].end, align, col_count));
        -: 4204:    }
    #####: 4205:    MD_LEAVE_BLOCK(MD_BLOCK_TBODY, NULL);
        -: 4206:
    #####: 4207:abort:
    #####: 4208:    free(align);
    #####: 4209:    return ret;
        -: 4210:}
        -: 4211:
        -: 4212:static int
    #####: 4213:md_is_table_row(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 4214:{
    #####: 4215:    MD_LINE line = { beg, beg };
        -: 4216:    int i;
    #####: 4217:    int ret = FALSE;
        -: 4218:
        -: 4219:    /* Find end of line. */
    #####: 4220:    while(line.end < ctx->size  &&  !ISNEWLINE(line.end))
    #####: 4221:        line.end++;
        -: 4222:
    #####: 4223:    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));
        -: 4224:
    #####: 4225:    if(TABLECELLBOUNDARIES.head >= 0) {
    #####: 4226:        if(p_end != NULL)
    #####: 4227:            *p_end = line.end;
        -: 4228:        ret = TRUE;
        -: 4229:    }
        -: 4230:
    #####: 4231:abort:
        -: 4232:    /* Free any temporary memory blocks stored within some dummy marks. */
    #####: 4233:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4234:        free(md_mark_get_ptr(ctx, i));
    #####: 4235:    PTR_CHAIN.head = -1;
    #####: 4236:    PTR_CHAIN.tail = -1;
        -: 4237:
    #####: 4238:    return ret;
        -: 4239:}
        -: 4240:
        -: 4241:
        -: 4242:/**************************
        -: 4243: ***  Processing Block  ***
        -: 4244: **************************/
        -: 4245:
        -: 4246:#define MD_BLOCK_CONTAINER_OPENER   0x01
        -: 4247:#define MD_BLOCK_CONTAINER_CLOSER   0x02
        -: 4248:#define MD_BLOCK_CONTAINER          (MD_BLOCK_CONTAINER_OPENER | MD_BLOCK_CONTAINER_CLOSER)
        -: 4249:#define MD_BLOCK_LOOSE_LIST         0x04
        -: 4250:
        -: 4251:struct MD_BLOCK_tag {
        -: 4252:    MD_BLOCKTYPE type  :  8;
        -: 4253:    unsigned flags     :  8;
        -: 4254:
        -: 4255:    /* MD_BLOCK_H:      Header level (1 - 6)
        -: 4256:     * MD_BLOCK_CODE:   Non-zero if fenced, zero if indented.
        -: 4257:     * MD_BLOCK_TABLE:  Column count (as determined by the table underline)
        -: 4258:     */
        -: 4259:    unsigned data      : 16;
        -: 4260:
        -: 4261:    /* Leaf blocks:     Count of lines (MD_LINE or MD_VERBATIMLINE) on the block.
        -: 4262:     * MD_BLOCK_OL:     Start item number.
        -: 4263:     */
        -: 4264:    unsigned n_lines;
        -: 4265:};
        -: 4266:
        -: 4267:struct MD_CONTAINER_tag {
        -: 4268:    CHAR ch;
        -: 4269:    unsigned is_loose    : 8;
        -: 4270:    unsigned start;
        -: 4271:    unsigned mark_indent;
        -: 4272:    unsigned contents_indent;
        -: 4273:    OFF block_byte_off;
        -: 4274:};
        -: 4275:
        -: 4276:
        -: 4277:static int
        1: 4278:md_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 4279:{
        -: 4280:    int i;
        -: 4281:    int ret;
        -: 4282:
        1: 4283:    MD_CHECK(md_analyze_inlines(ctx, lines, n_lines, FALSE));
    #####: 4284:    MD_CHECK(md_process_inlines(ctx, lines, n_lines));
        -: 4285:
    #####: 4286:abort:
        -: 4287:    /* Free any temporary memory blocks stored within some dummy marks. */
    #####: 4288:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4289:        free(md_mark_get_ptr(ctx, i));
    #####: 4290:    PTR_CHAIN.head = -1;
    #####: 4291:    PTR_CHAIN.tail = -1;
        -: 4292:
    #####: 4293:    return ret;
        -: 4294:}
        -: 4295:
        -: 4296:static int
    #####: 4297:md_process_verbatim_block_contents(MD_CTX* ctx, MD_TEXTTYPE text_type, const MD_VERBATIMLINE* lines, int n_lines)
        -: 4298:{
        -: 4299:    static const CHAR indent_chunk_str[] = _T("                ");
        -: 4300:    static const SZ indent_chunk_size = SIZEOF_ARRAY(indent_chunk_str) - 1;
        -: 4301:
        -: 4302:    int i;
    #####: 4303:    int ret = 0;
        -: 4304:
    #####: 4305:    for(i = 0; i < n_lines; i++) {
    #####: 4306:        const MD_VERBATIMLINE* line = &lines[i];
    #####: 4307:        int indent = line->indent;
        -: 4308:
    #####: 4309:        MD_ASSERT(indent >= 0);
        -: 4310:
        -: 4311:        /* Output code indentation. */
    #####: 4312:        while(indent > SIZEOF_ARRAY(indent_chunk_str)) {
    #####: 4313:            MD_TEXT(text_type, indent_chunk_str, indent_chunk_size);
    #####: 4314:            indent -= SIZEOF_ARRAY(indent_chunk_str);
        -: 4315:        }
    #####: 4316:        if(indent > 0)
    #####: 4317:            MD_TEXT(text_type, indent_chunk_str, indent);
        -: 4318:
        -: 4319:        /* Output the code line itself. */
    #####: 4320:        MD_TEXT_INSECURE(text_type, STR(line->beg), line->end - line->beg);
        -: 4321:
        -: 4322:        /* Enforce end-of-line. */
    #####: 4323:        MD_TEXT(text_type, _T("\n"), 1);
        -: 4324:    }
        -: 4325:
    #####: 4326:abort:
    #####: 4327:    return ret;
        -: 4328:}
        -: 4329:
        -: 4330:static int
    #####: 4331:md_process_code_block_contents(MD_CTX* ctx, int is_fenced, const MD_VERBATIMLINE* lines, int n_lines)
        -: 4332:{
    #####: 4333:    if(is_fenced) {
        -: 4334:        /* Skip the first line in case of fenced code: It is the fence.
        -: 4335:         * (Only the starting fence is present due to logic in md_analyze_line().) */
    #####: 4336:        lines++;
    #####: 4337:        n_lines--;
        -: 4338:    } else {
        -: 4339:        /* Ignore blank lines at start/end of indented code block. */
    #####: 4340:        while(n_lines > 0  &&  lines[0].beg == lines[0].end) {
    #####: 4341:            lines++;
    #####: 4342:            n_lines--;
        -: 4343:        }
    #####: 4344:        while(n_lines > 0  &&  lines[n_lines-1].beg == lines[n_lines-1].end) {
    #####: 4345:            n_lines--;
        -: 4346:        }
        -: 4347:    }
        -: 4348:
    #####: 4349:    if(n_lines == 0)
        -: 4350:        return 0;
        -: 4351:
    #####: 4352:    return md_process_verbatim_block_contents(ctx, MD_TEXT_CODE, lines, n_lines);
        -: 4353:}
        -: 4354:
        -: 4355:static int
    #####: 4356:md_setup_fenced_code_detail(MD_CTX* ctx, const MD_BLOCK* block, MD_BLOCK_CODE_DETAIL* det,
        -: 4357:                            MD_ATTRIBUTE_BUILD* info_build, MD_ATTRIBUTE_BUILD* lang_build)
        -: 4358:{
    #####: 4359:    const MD_VERBATIMLINE* fence_line = (const MD_VERBATIMLINE*)(block + 1);
    #####: 4360:    OFF beg = fence_line->beg;
    #####: 4361:    OFF end = fence_line->end;
        -: 4362:    OFF lang_end;
    #####: 4363:    CHAR fence_ch = CH(fence_line->beg);
    #####: 4364:    int ret = 0;
        -: 4365:
        -: 4366:    /* Skip the fence itself. */
    #####: 4367:    while(beg < ctx->size  &&  CH(beg) == fence_ch)
    #####: 4368:        beg++;
        -: 4369:    /* Trim initial spaces. */
    #####: 4370:    while(beg < ctx->size  &&  CH(beg) == _T(' '))
    #####: 4371:        beg++;
        -: 4372:
        -: 4373:    /* Trim trailing spaces. */
    #####: 4374:    while(end > beg  &&  CH(end-1) == _T(' '))
        -: 4375:        end--;
        -: 4376:
        -: 4377:    /* Build info string attribute. */
    #####: 4378:    MD_CHECK(md_build_attribute(ctx, STR(beg), end - beg, 0, &det->info, info_build));
        -: 4379:
        -: 4380:    /* Build info string attribute. */
        -: 4381:    lang_end = beg;
    #####: 4382:    while(lang_end < end  &&  !ISWHITESPACE(lang_end))
    #####: 4383:        lang_end++;
    #####: 4384:    MD_CHECK(md_build_attribute(ctx, STR(beg), lang_end - beg, 0, &det->lang, lang_build));
        -: 4385:
    #####: 4386:abort:
    #####: 4387:    return ret;
        -: 4388:}
        -: 4389:
        -: 4390:static int
        1: 4391:md_process_leaf_block(MD_CTX* ctx, const MD_BLOCK* block)
        -: 4392:{
        -: 4393:    union {
        -: 4394:        MD_BLOCK_H_DETAIL header;
        -: 4395:        MD_BLOCK_CODE_DETAIL code;
        1: 4396:    } det;
        1: 4397:    MD_ATTRIBUTE_BUILD info_build;
        1: 4398:    MD_ATTRIBUTE_BUILD lang_build;
        -: 4399:    int is_in_tight_list;
        1: 4400:    int clean_fence_code_detail = FALSE;
        1: 4401:    int ret = 0;
        -: 4402:
        1: 4403:    memset(&det, 0, sizeof(det));
        -: 4404:
        1: 4405:    if(ctx->n_containers == 0)
        -: 4406:        is_in_tight_list = FALSE;
        -: 4407:    else
    #####: 4408:        is_in_tight_list = !ctx->containers[ctx->n_containers-1].is_loose;
        -: 4409:
        1: 4410:    switch(block->type) {
    #####: 4411:        case MD_BLOCK_H:
    #####: 4412:            det.header.level = block->data;
    #####: 4413:            break;
        -: 4414:
    #####: 4415:        case MD_BLOCK_CODE:
        -: 4416:            /* For fenced code block, we may need to set the info string. */
    #####: 4417:            if(block->data != 0) {
    #####: 4418:                memset(&det.code, 0, sizeof(MD_BLOCK_CODE_DETAIL));
    #####: 4419:                clean_fence_code_detail = TRUE;
    #####: 4420:                MD_CHECK(md_setup_fenced_code_detail(ctx, block, &det.code, &info_build, &lang_build));
        -: 4421:            }
        -: 4422:            break;
        -: 4423:
        -: 4424:        default:
        -: 4425:            /* Noop. */
        -: 4426:            break;
        -: 4427:    }
        -: 4428:
        1: 4429:    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)
        1: 4430:        MD_ENTER_BLOCK(block->type, (void*) &det);
        -: 4431:
        -: 4432:    /* Process the block contents accordingly to is type. */
        1: 4433:    switch(block->type) {
        -: 4434:        case MD_BLOCK_HR:
        -: 4435:            /* noop */
        -: 4436:            break;
        -: 4437:
    #####: 4438:        case MD_BLOCK_CODE:
    #####: 4439:            MD_CHECK(md_process_code_block_contents(ctx, (block->data != 0),
        -: 4440:                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));
        -: 4441:            break;
        -: 4442:
    #####: 4443:        case MD_BLOCK_HTML:
    #####: 4444:            MD_CHECK(md_process_verbatim_block_contents(ctx, MD_TEXT_HTML,
        -: 4445:                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));
        -: 4446:            break;
        -: 4447:
    #####: 4448:        case MD_BLOCK_TABLE:
    #####: 4449:            MD_CHECK(md_process_table_block_contents(ctx, block->data,
        -: 4450:                            (const MD_LINE*)(block + 1), block->n_lines));
        -: 4451:            break;
        -: 4452:
        1: 4453:        default:
        1: 4454:            MD_CHECK(md_process_normal_block_contents(ctx,
        -: 4455:                            (const MD_LINE*)(block + 1), block->n_lines));
        -: 4456:            break;
        -: 4457:    }
        -: 4458:
    #####: 4459:    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)
    #####: 4460:        MD_LEAVE_BLOCK(block->type, (void*) &det);
        -: 4461:
    #####: 4462:abort:
    #####: 4463:    if(clean_fence_code_detail) {
    #####: 4464:        md_free_attribute(ctx, &info_build);
    #####: 4465:        md_free_attribute(ctx, &lang_build);
        -: 4466:    }
    #####: 4467:    return ret;
        -: 4468:}
        -: 4469:
        -: 4470:static int
        1: 4471:md_process_all_blocks(MD_CTX* ctx)
        -: 4472:{
        1: 4473:    int byte_off = 0;
        1: 4474:    int ret = 0;
        -: 4475:
        -: 4476:    /* ctx->containers now is not needed for detection of lists and list items
        -: 4477:     * so we reuse it for tracking what lists are loose or tight. We rely
        -: 4478:     * on the fact the vector is large enough to hold the deepest nesting
        -: 4479:     * level of lists. */
        1: 4480:    ctx->n_containers = 0;
        -: 4481:
        2: 4482:    while(byte_off < ctx->n_block_bytes) {
        1: 4483:        MD_BLOCK* block = (MD_BLOCK*)((char*)ctx->block_bytes + byte_off);
        -: 4484:        union {
        -: 4485:            MD_BLOCK_UL_DETAIL ul;
        -: 4486:            MD_BLOCK_OL_DETAIL ol;
        1: 4487:        } det;
        -: 4488:
        1: 4489:        switch(block->type) {
    #####: 4490:            case MD_BLOCK_UL:
    #####: 4491:                det.ul.is_tight = (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;
    #####: 4492:                det.ul.mark = (CHAR) block->data;
    #####: 4493:                break;
        -: 4494:
    #####: 4495:            case MD_BLOCK_OL:
    #####: 4496:                det.ol.start = block->n_lines;
    #####: 4497:                det.ol.is_tight =  (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;
    #####: 4498:                det.ol.mark_delimiter = (CHAR) block->data;
    #####: 4499:                break;
        -: 4500:
        -: 4501:            default:
        -: 4502:                /* noop */
        -: 4503:                break;
        -: 4504:        }
        -: 4505:
        1: 4506:        if(block->flags & MD_BLOCK_CONTAINER) {
    #####: 4507:            if(block->flags & MD_BLOCK_CONTAINER_CLOSER) {
    #####: 4508:                MD_LEAVE_BLOCK(block->type, &det);
        -: 4509:
    #####: 4510:                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL || block->type == MD_BLOCK_QUOTE)
    #####: 4511:                    ctx->n_containers--;
        -: 4512:            }
        -: 4513:
    #####: 4514:            if(block->flags & MD_BLOCK_CONTAINER_OPENER) {
    #####: 4515:                MD_ENTER_BLOCK(block->type, &det);
        -: 4516:
    #####: 4517:                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL) {
    #####: 4518:                    ctx->containers[ctx->n_containers].is_loose = (block->flags & MD_BLOCK_LOOSE_LIST);
    #####: 4519:                    ctx->n_containers++;
    #####: 4520:                } else if(block->type == MD_BLOCK_QUOTE) {
        -: 4521:                    /* This causes that any text in a block quote, even if
        -: 4522:                     * nested inside a tight list item, is wrapped with
        -: 4523:                     * <p>...</p>. */
    #####: 4524:                    ctx->containers[ctx->n_containers].is_loose = TRUE;
    #####: 4525:                    ctx->n_containers++;
        -: 4526:                }
        -: 4527:            }
        -: 4528:        } else {
        1: 4529:            MD_CHECK(md_process_leaf_block(ctx, block));
        -: 4530:
    #####: 4531:            if(block->type == MD_BLOCK_CODE || block->type == MD_BLOCK_HTML)
    #####: 4532:                byte_off += block->n_lines * sizeof(MD_VERBATIMLINE);
        -: 4533:            else
    #####: 4534:                byte_off += block->n_lines * sizeof(MD_LINE);
        -: 4535:        }
        -: 4536:
    #####: 4537:        byte_off += sizeof(MD_BLOCK);
        -: 4538:    }
        -: 4539:
    #####: 4540:    ctx->n_block_bytes = 0;
        -: 4541:
    #####: 4542:abort:
    #####: 4543:    return ret;
        -: 4544:}
        -: 4545:
        -: 4546:
        -: 4547:/************************************
        -: 4548: ***  Grouping Lines into Blocks  ***
        -: 4549: ************************************/
        -: 4550:
        -: 4551:static void*
        2: 4552:md_push_block_bytes(MD_CTX* ctx, int n_bytes)
        -: 4553:{
        -: 4554:    void* ptr;
        -: 4555:
        2: 4556:    if(ctx->n_block_bytes + n_bytes > ctx->alloc_block_bytes) {
        -: 4557:        void* new_block_bytes;
        -: 4558:
        1: 4559:        ctx->alloc_block_bytes = (ctx->alloc_block_bytes > 0 ? ctx->alloc_block_bytes * 2 : 512);
        1: 4560:        new_block_bytes = realloc(ctx->block_bytes, ctx->alloc_block_bytes);
        1: 4561:        if(new_block_bytes == NULL) {
    #####: 4562:            MD_LOG("realloc() failed.");
        -: 4563:            return NULL;
        -: 4564:        }
        -: 4565:
        -: 4566:        /* Fix the ->current_block after the reallocation. */
        1: 4567:        if(ctx->current_block != NULL) {
    #####: 4568:            OFF off_current_block = (char*) ctx->current_block - (char*) ctx->block_bytes;
    #####: 4569:            ctx->current_block = (MD_BLOCK*) ((char*) new_block_bytes + off_current_block);
        -: 4570:        }
        -: 4571:
        1: 4572:        ctx->block_bytes = new_block_bytes;
        -: 4573:    }
        -: 4574:
        2: 4575:    ptr = (char*)ctx->block_bytes + ctx->n_block_bytes;
        2: 4576:    ctx->n_block_bytes += n_bytes;
        2: 4577:    return ptr;
        -: 4578:}
        -: 4579:
        -: 4580:static int
        1: 4581:md_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)
        -: 4582:{
        -: 4583:    MD_BLOCK* block;
        -: 4584:
        1: 4585:    MD_ASSERT(ctx->current_block == NULL);
        -: 4586:
        1: 4587:    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));
        1: 4588:    if(block == NULL)
        -: 4589:        return -1;
        -: 4590:
        1: 4591:    switch(line->type) {
    #####: 4592:        case MD_LINE_HR:
    #####: 4593:            block->type = MD_BLOCK_HR;
    #####: 4594:            break;
        -: 4595:
    #####: 4596:        case MD_LINE_ATXHEADER:
        -: 4597:        case MD_LINE_SETEXTHEADER:
    #####: 4598:            block->type = MD_BLOCK_H;
    #####: 4599:            break;
        -: 4600:
    #####: 4601:        case MD_LINE_FENCEDCODE:
        -: 4602:        case MD_LINE_INDENTEDCODE:
    #####: 4603:            block->type = MD_BLOCK_CODE;
    #####: 4604:            break;
        -: 4605:
        1: 4606:        case MD_LINE_TEXT:
        1: 4607:            block->type = MD_BLOCK_P;
        1: 4608:            break;
        -: 4609:
    #####: 4610:        case MD_LINE_HTML:
    #####: 4611:            block->type = MD_BLOCK_HTML;
    #####: 4612:            break;
        -: 4613:
    #####: 4614:        case MD_LINE_BLANK:
        -: 4615:        case MD_LINE_SETEXTUNDERLINE:
        -: 4616:        case MD_LINE_TABLEUNDERLINE:
        -: 4617:        default:
    #####: 4618:            MD_UNREACHABLE();
        -: 4619:            break;
        -: 4620:    }
        -: 4621:
        1: 4622:    block->flags = 0;
        1: 4623:    block->data = line->data;
        1: 4624:    block->n_lines = 0;
        -: 4625:
        1: 4626:    ctx->current_block = block;
        1: 4627:    return 0;
        -: 4628:}
        -: 4629:
        -: 4630:/* Eat from start of current (textual) block any reference definitions and
        -: 4631: * remember them so we can resolve any links referring to them.
        -: 4632: *
        -: 4633: * (Reference definitions can only be at start of it as they cannot break
        -: 4634: * a paragraph.)
        -: 4635: */
        -: 4636:static int
    #####: 4637:md_consume_link_reference_definitions(MD_CTX* ctx)
        -: 4638:{
    #####: 4639:    MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);
    #####: 4640:    int n_lines = ctx->current_block->n_lines;
    #####: 4641:    int n = 0;
        -: 4642:
        -: 4643:    /* Compute how many lines at the start of the block form one or more
        -: 4644:     * reference definitions. */
    #####: 4645:    while(n < n_lines) {
        -: 4646:        int n_link_ref_lines;
        -: 4647:
    #####: 4648:        n_link_ref_lines = md_is_link_reference_definition(ctx,
    #####: 4649:                                    lines + n, n_lines - n);
        -: 4650:        /* Not a reference definition? */
    #####: 4651:        if(n_link_ref_lines == 0)
        -: 4652:            break;
        -: 4653:
        -: 4654:        /* We fail if it is the ref. def. but it could not be stored due
        -: 4655:         * a memory allocation error. */
    #####: 4656:        if(n_link_ref_lines < 0)
        -: 4657:            return -1;
        -: 4658:
    #####: 4659:        n += n_link_ref_lines;
        -: 4660:    }
        -: 4661:
        -: 4662:    /* If there was at least one reference definition, we need to remove
        -: 4663:     * its lines from the block, or perhaps even the whole block. */
    #####: 4664:    if(n > 0) {
    #####: 4665:        if(n == n_lines) {
        -: 4666:            /* Remove complete block. */
    #####: 4667:            ctx->n_block_bytes -= n * sizeof(MD_LINE);
    #####: 4668:            ctx->n_block_bytes -= sizeof(MD_BLOCK);
        -: 4669:        } else {
        -: 4670:            /* Remove just some initial lines from the block. */
    #####: 4671:            memmove(lines, lines + n, (n_lines - n) * sizeof(MD_LINE));
    #####: 4672:            ctx->current_block->n_lines -= n;
    #####: 4673:            ctx->n_block_bytes -= n * sizeof(MD_LINE);
        -: 4674:        }
        -: 4675:    }
        -: 4676:
        -: 4677:    return 0;
        -: 4678:}
        -: 4679:
        -: 4680:static int
        2: 4681:md_end_current_block(MD_CTX* ctx)
        -: 4682:{
        2: 4683:    int ret = 0;
        -: 4684:
        2: 4685:    if(ctx->current_block == NULL)
        -: 4686:        return ret;
        -: 4687:
        -: 4688:    /* Check whether there is a reference definition. (We do this here instead
        -: 4689:     * of in md_analyze_line() because reference definition can take multiple
        -: 4690:     * lines.) */
        1: 4691:    if(ctx->current_block->type == MD_BLOCK_P) {
        1: 4692:        MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);
        1: 4693:        if(CH(lines[0].beg) == _T('['))
    #####: 4694:            MD_CHECK(md_consume_link_reference_definitions(ctx));
        -: 4695:    }
        -: 4696:
        -: 4697:    /* Mark we are not building any block anymore. */
        1: 4698:    ctx->current_block = NULL;
        -: 4699:
    #####: 4700:abort:
        -: 4701:    return ret;
        -: 4702:}
        -: 4703:
        -: 4704:static int
        1: 4705:md_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)
        -: 4706:{
        1: 4707:    MD_ASSERT(ctx->current_block != NULL);
        -: 4708:
        1: 4709:    if(ctx->current_block->type == MD_BLOCK_CODE || ctx->current_block->type == MD_BLOCK_HTML) {
        -: 4710:        MD_VERBATIMLINE* line;
        -: 4711:
    #####: 4712:        line = (MD_VERBATIMLINE*) md_push_block_bytes(ctx, sizeof(MD_VERBATIMLINE));
    #####: 4713:        if(line == NULL)
        -: 4714:            return -1;
        -: 4715:
    #####: 4716:        line->indent = analysis->indent;
    #####: 4717:        line->beg = analysis->beg;
    #####: 4718:        line->end = analysis->end;
        -: 4719:    } else {
        -: 4720:        MD_LINE* line;
        -: 4721:
        1: 4722:        line = (MD_LINE*) md_push_block_bytes(ctx, sizeof(MD_LINE));
        1: 4723:        if(line == NULL)
        -: 4724:            return -1;
        -: 4725:
        1: 4726:        line->beg = analysis->beg;
        1: 4727:        line->end = analysis->end;
        -: 4728:    }
        1: 4729:    ctx->current_block->n_lines++;
        -: 4730:
        1: 4731:    return 0;
        -: 4732:}
        -: 4733:
        -: 4734:static int
    #####: 4735:md_push_container_bytes(MD_CTX* ctx, MD_BLOCKTYPE type, unsigned start,
        -: 4736:                        unsigned data, unsigned flags)
        -: 4737:{
        -: 4738:    MD_BLOCK* block;
    #####: 4739:    int ret = 0;
        -: 4740:
    #####: 4741:    MD_CHECK(md_end_current_block(ctx));
        -: 4742:
    #####: 4743:    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));
    #####: 4744:    if(block == NULL)
        -: 4745:        return -1;
        -: 4746:
    #####: 4747:    block->type = type;
    #####: 4748:    block->flags = flags;
    #####: 4749:    block->data = data;
    #####: 4750:    block->n_lines = start;
        -: 4751:
    #####: 4752:abort:
        -: 4753:    return ret;
        -: 4754:}
        -: 4755:
        -: 4756:
        -: 4757:
        -: 4758:/***********************
        -: 4759: ***  Line Analysis  ***
        -: 4760: ***********************/
        -: 4761:
        -: 4762:static int
        1: 4763:md_is_hr_line(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 4764:{
        1: 4765:    OFF off = beg + 1;
        1: 4766:    int n = 1;
        -: 4767:
        2: 4768:    while(off < ctx->size  &&  (CH(off) == CH(beg) || CH(off) == _T(' ') || CH(off) == _T('\t'))) {
        1: 4769:        if(CH(off) == CH(beg))
        1: 4770:            n++;
        1: 4771:        off++;
        -: 4772:    }
        -: 4773:
        1: 4774:    if(n < 3)
        -: 4775:        return FALSE;
        -: 4776:
        -: 4777:    /* Nothing else can be present on the line. */
    #####: 4778:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4779:        return FALSE;
        -: 4780:
    #####: 4781:    *p_end = off;
        -: 4782:    return TRUE;
        -: 4783:}
        -: 4784:
        -: 4785:static int
    #####: 4786:md_is_atxheader_line(MD_CTX* ctx, OFF beg, OFF* p_beg, OFF* p_end, unsigned* p_level)
        -: 4787:{
        -: 4788:    int n;
    #####: 4789:    OFF off = beg + 1;
        -: 4790:
    #####: 4791:    while(off < ctx->size  &&  CH(off) == _T('#')  &&  off - beg < 7)
    #####: 4792:        off++;
    #####: 4793:    n = off - beg;
        -: 4794:
    #####: 4795:    if(n > 6)
        -: 4796:        return FALSE;
    #####: 4797:    *p_level = n;
        -: 4798:
    #####: 4799:    if(!(ctx->r.flags & MD_FLAG_PERMISSIVEATXHEADERS)  &&  off < ctx->size  &&
    #####: 4800:       CH(off) != _T(' ')  &&  CH(off) != _T('\t')  &&  !ISNEWLINE(off))
        -: 4801:        return FALSE;
        -: 4802:
    #####: 4803:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4804:        off++;
    #####: 4805:    *p_beg = off;
    #####: 4806:    *p_end = off;
    #####: 4807:    return TRUE;
        -: 4808:}
        -: 4809:
        -: 4810:static int
    #####: 4811:md_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)
        -: 4812:{
    #####: 4813:    OFF off = beg + 1;
        -: 4814:
    #####: 4815:    while(off < ctx->size  &&  CH(off) == CH(beg))
    #####: 4816:        off++;
        -: 4817:
    #####: 4818:    while(off < ctx->size  && CH(off) == _T(' '))
    #####: 4819:        off++;
        -: 4820:
        -: 4821:    /* Optionally, space(s) can follow. */
    #####: 4822:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4823:        off++;
        -: 4824:
        -: 4825:    /* But nothing more is allowed on the line. */
    #####: 4826:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4827:        return FALSE;
        -: 4828:
    #####: 4829:    *p_level = (CH(beg) == _T('=') ? 1 : 2);
    #####: 4830:    *p_end = off;
        -: 4831:    return TRUE;
        -: 4832:}
        -: 4833:
        -: 4834:static int
    #####: 4835:md_is_table_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_col_count)
        -: 4836:{
    #####: 4837:    OFF off = beg;
    #####: 4838:    int found_pipe = FALSE;
    #####: 4839:    unsigned col_count = 0;
        -: 4840:
    #####: 4841:    if(off < ctx->size  &&  CH(off) == _T('|')) {
    #####: 4842:        found_pipe = TRUE;
    #####: 4843:        off++;
    #####: 4844:        while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4845:            off++;
        -: 4846:    }
        -: 4847:
        -: 4848:    while(1) {
        -: 4849:        OFF cell_beg;
    #####: 4850:        int delimited = FALSE;
        -: 4851:
        -: 4852:        /* Cell underline ("-----", ":----", "----:" or ":----:") */
    #####: 4853:        cell_beg = off;
    #####: 4854:        if(off < ctx->size  &&  CH(off) == _T(':'))
    #####: 4855:            off++;
    #####: 4856:        while(off < ctx->size  &&  CH(off) == _T('-'))
    #####: 4857:            off++;
    #####: 4858:        if(off < ctx->size  &&  CH(off) == _T(':'))
    #####: 4859:            off++;
    #####: 4860:        if(off - cell_beg < 3)
        -: 4861:            return FALSE;
        -: 4862:
    #####: 4863:        col_count++;
        -: 4864:
        -: 4865:        /* Pipe delimiter (optional at the end of line). */
    #####: 4866:        while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4867:            off++;
    #####: 4868:        if(off < ctx->size  &&  CH(off) == _T('|')) {
    #####: 4869:            delimited = TRUE;
    #####: 4870:            found_pipe =  TRUE;
    #####: 4871:            off++;
    #####: 4872:            while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4873:                off++;
        -: 4874:        }
        -: 4875:
        -: 4876:        /* Success, if we reach end of line. */
    #####: 4877:        if(off >= ctx->size  ||  ISNEWLINE(off))
        -: 4878:            break;
        -: 4879:
    #####: 4880:        if(!delimited)
        -: 4881:            return FALSE;
        -: 4882:    }
        -: 4883:
    #####: 4884:    if(!found_pipe)
        -: 4885:        return FALSE;
        -: 4886:
    #####: 4887:    *p_end = off;
    #####: 4888:    *p_col_count = col_count;
        -: 4889:    return TRUE;
        -: 4890:}
        -: 4891:
        -: 4892:static int
    #####: 4893:md_is_opening_code_fence(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 4894:{
    #####: 4895:    OFF off = beg;
        -: 4896:
    #####: 4897:    while(off < ctx->size && CH(off) == CH(beg))
    #####: 4898:        off++;
        -: 4899:
        -: 4900:    /* Fence must have at least three characters. */
    #####: 4901:    if(off - beg < 3)
        -: 4902:        return FALSE;
        -: 4903:
    #####: 4904:    ctx->code_fence_length = off - beg;
        -: 4905:
        -: 4906:    /* Optionally, space(s) can follow. */
    #####: 4907:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4908:        off++;
        -: 4909:
        -: 4910:    /* Optionally, an info string can follow. It must not contain '`'. */
    #####: 4911:    while(off < ctx->size  &&  CH(off) != _T('`')  &&  !ISNEWLINE(off))
    #####: 4912:        off++;
    #####: 4913:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4914:        return FALSE;
        -: 4915:
    #####: 4916:    *p_end = off;
    #####: 4917:    return TRUE;
        -: 4918:}
        -: 4919:
        -: 4920:static int
    #####: 4921:md_is_closing_code_fence(MD_CTX* ctx, CHAR ch, OFF beg, OFF* p_end)
        -: 4922:{
    #####: 4923:    OFF off = beg;
    #####: 4924:    int ret = FALSE;
        -: 4925:
        -: 4926:    /* Closing fence must have at least the same length and use same char as
        -: 4927:     * opening one. */
    #####: 4928:    while(off < ctx->size  &&  CH(off) == ch)
    #####: 4929:        off++;
    #####: 4930:    if(off - beg < ctx->code_fence_length)
        -: 4931:        goto out;
        -: 4932:
        -: 4933:    /* Optionally, space(s) can follow */
    #####: 4934:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4935:        off++;
        -: 4936:
        -: 4937:    /* But nothing more is allowed on the line. */
    #####: 4938:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4939:        goto out;
        -: 4940:
    #####: 4941:    ret = TRUE;
        -: 4942:
    #####: 4943:out:
        -: 4944:    /* Note we set *p_end even on failure: If we are not closing fence, caller
        -: 4945:     * would eat the line anyway without any parsing. */
    #####: 4946:    *p_end = off;
    #####: 4947:    return ret;
        -: 4948:}
        -: 4949:
        -: 4950:/* Returns type of the raw HTML block, or FALSE if it is not HTML block.
        -: 4951: * (Refer to CommonMark specification for details about the types.)
        -: 4952: */
        -: 4953:static int
    #####: 4954:md_is_html_block_start_condition(MD_CTX* ctx, OFF beg)
        -: 4955:{
        -: 4956:    typedef struct TAG_tag TAG;
        -: 4957:    struct TAG_tag {
        -: 4958:        const CHAR* name;
        -: 4959:        unsigned len    : 8;
        -: 4960:    };
        -: 4961:
        -: 4962:    /* Type 6 is started by a long list of allowed tags. We use two-level
        -: 4963:     * tree to speed-up the search. */
        -: 4964:#ifdef X
        -: 4965:    #undef X
        -: 4966:#endif
        -: 4967:#define X(name)     { _T(name), sizeof(name)-1 }
        -: 4968:#define Xend        { NULL, 0 }
        -: 4969:    static const TAG t1[] = { X("script"), X("pre"), X("style"), Xend };
        -: 4970:
        -: 4971:    static const TAG a6[] = { X("address"), X("article"), X("aside"), Xend };
        -: 4972:    static const TAG b6[] = { X("base"), X("basefont"), X("blockquote"), X("body"), Xend };
        -: 4973:    static const TAG c6[] = { X("caption"), X("center"), X("col"), X("colgroup"), Xend };
        -: 4974:    static const TAG d6[] = { X("dd"), X("details"), X("dialog"), X("dir"),
        -: 4975:                              X("div"), X("dl"), X("dt"), Xend };
        -: 4976:    static const TAG f6[] = { X("fieldset"), X("figcaption"), X("figure"), X("footer"),
        -: 4977:                              X("form"), X("frame"), X("frameset"), Xend };
        -: 4978:    static const TAG h6[] = { X("h1"), X("head"), X("header"), X("hr"), X("html"), Xend };
        -: 4979:    static const TAG i6[] = { X("iframe"), Xend };
        -: 4980:    static const TAG l6[] = { X("legend"), X("li"), X("link"), Xend };
        -: 4981:    static const TAG m6[] = { X("main"), X("menu"), X("menuitem"), X("meta"), Xend };
        -: 4982:    static const TAG n6[] = { X("nav"), X("noframes"), Xend };
        -: 4983:    static const TAG o6[] = { X("ol"), X("optgroup"), X("option"), Xend };
        -: 4984:    static const TAG p6[] = { X("p"), X("param"), Xend };
        -: 4985:    static const TAG s6[] = { X("section"), X("source"), X("summary"), Xend };
        -: 4986:    static const TAG t6[] = { X("table"), X("tbody"), X("td"), X("tfoot"), X("th"),
        -: 4987:                              X("thead"), X("title"), X("tr"), X("track"), Xend };
        -: 4988:    static const TAG u6[] = { X("ul"), Xend };
        -: 4989:    static const TAG xx[] = { Xend };
        -: 4990:#undef X
        -: 4991:
        -: 4992:    static const TAG* map6[26] = {
        -: 4993:        a6, b6, c6, d6, xx, f6, xx, h6, i6, xx, xx, l6, m6,
        -: 4994:        n6, o6, p6, xx, xx, s6, t6, u6, xx, xx, xx, xx, xx
        -: 4995:    };
    #####: 4996:    OFF off = beg + 1;
        -: 4997:    int i;
        -: 4998:
        -: 4999:    /* Check for type 1: <script, <pre, or <style */
    #####: 5000:    for(i = 0; t1[i].name != NULL; i++) {
    #####: 5001:        if(off + t1[i].len < ctx->size) {
    #####: 5002:            if(md_ascii_case_eq(STR(off), t1[i].name, t1[i].len))
        -: 5003:                return 1;
        -: 5004:        }
        -: 5005:    }
        -: 5006:
        -: 5007:    /* Check for type 2: <!-- */
    #####: 5008:    if(off + 3 < ctx->size  &&  CH(off) == _T('!')  &&  CH(off+1) == _T('-')  &&  CH(off+2) == _T('-'))
        -: 5009:        return 2;
        -: 5010:
        -: 5011:    /* Check for type 3: <? */
    #####: 5012:    if(off < ctx->size  &&  CH(off) == _T('?'))
        -: 5013:        return 3;
        -: 5014:
        -: 5015:    /* Check for type 4 or 5: <! */
    #####: 5016:    if(off < ctx->size  &&  CH(off) == _T('!')) {
        -: 5017:        /* Check for type 4: <! followed by uppercase letter. */
    #####: 5018:        if(off + 1 < ctx->size  &&  ISUPPER(off+1))
        -: 5019:            return 4;
        -: 5020:
        -: 5021:        /* Check for type 5: <![CDATA[ */
    #####: 5022:        if(off + 8 < ctx->size) {
    #####: 5023:            if(md_ascii_eq(STR(off), _T("![CDATA["), 8 * sizeof(CHAR)))
        -: 5024:                return 5;
        -: 5025:        }
        -: 5026:    }
        -: 5027:
        -: 5028:    /* Check for type 6: Many possible starting tags listed above. */
    #####: 5029:    if(off + 1 < ctx->size  &&  (ISALPHA(off) || (CH(off) == _T('/') && ISALPHA(off+1)))) {
        -: 5030:        int slot;
        -: 5031:        const TAG* tags;
        -: 5032:
    #####: 5033:        if(CH(off) == _T('/'))
    #####: 5034:            off++;
        -: 5035:
    #####: 5036:        slot = (ISUPPER(off) ? CH(off) - 'A' : CH(off) - 'a');
    #####: 5037:        tags = map6[slot];
        -: 5038:
    #####: 5039:        for(i = 0; tags[i].name != NULL; i++) {
    #####: 5040:            if(off + tags[i].len <= ctx->size) {
    #####: 5041:                if(md_ascii_case_eq(STR(off), tags[i].name, tags[i].len)) {
    #####: 5042:                    OFF tmp = off + tags[i].len;
    #####: 5043:                    if(tmp >= ctx->size)
        -: 5044:                        return 6;
    #####: 5045:                    if(ISBLANK(tmp) || ISNEWLINE(tmp) || CH(tmp) == _T('>'))
        -: 5046:                        return 6;
    #####: 5047:                    if(tmp+1 < ctx->size && CH(tmp) == _T('/') && CH(tmp+1) == _T('>'))
        -: 5048:                        return 6;
        -: 5049:                    break;
        -: 5050:                }
        -: 5051:            }
        -: 5052:        }
        -: 5053:    }
        -: 5054:
        -: 5055:    /* Check for type 7: any COMPLETE other opening or closing tag. */
    #####: 5056:    if(off + 1 < ctx->size) {
    #####: 5057:        OFF end;
        -: 5058:
    #####: 5059:        if(md_is_html_tag(ctx, NULL, 0, beg, ctx->size, &end)) {
        -: 5060:            /* Only optional whitespace and new line may follow. */
    #####: 5061:            while(end < ctx->size  &&  ISWHITESPACE(end))
    #####: 5062:                end++;
    #####: 5063:            if(end >= ctx->size  ||  ISNEWLINE(end))
    #####: 5064:                return 7;
        -: 5065:        }
        -: 5066:    }
        -: 5067:
        -: 5068:    return FALSE;
        -: 5069:}
        -: 5070:
        -: 5071:/* Case sensitive check whether there is a substring 'what' between 'beg'
        -: 5072: * and end of line. */
        -: 5073:static int
    #####: 5074:md_line_contains(MD_CTX* ctx, OFF beg, const CHAR* what, SZ what_len, OFF* p_end)
        -: 5075:{
        -: 5076:    OFF i;
    #####: 5077:    for(i = beg; i + what_len < ctx->size; i++) {
    #####: 5078:        if(ISNEWLINE(i))
        -: 5079:            break;
    #####: 5080:        if(memcmp(STR(i), what, what_len * sizeof(CHAR)) == 0) {
    #####: 5081:            *p_end = i + what_len;
        -: 5082:            return TRUE;
        -: 5083:        }
        -: 5084:    }
        -: 5085:
    #####: 5086:    *p_end = i;
        -: 5087:    return FALSE;
        -: 5088:}
        -: 5089:
        -: 5090:/* Returns type of HTML block end condition or FALSE if not an end condition.
        -: 5091: *
        -: 5092: * Note it fills p_end even when it is not end condition as the caller
        -: 5093: * does not need to analyze contents of a raw HTML block.
        -: 5094: */
        -: 5095:static int
    #####: 5096:md_is_html_block_end_condition(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 5097:{
    #####: 5098:    switch(ctx->html_block_type) {
        -: 5099:        case 1:
        -: 5100:        {
        -: 5101:            OFF off = beg;
        -: 5102:
    #####: 5103:            while(off < ctx->size  &&  !ISNEWLINE(off)) {
    #####: 5104:                if(CH(off) == _T('<')) {
    #####: 5105:                    if(md_ascii_case_eq(STR(off), _T("</script>"), 9)) {
    #####: 5106:                        *p_end = off + 9;
    #####: 5107:                        return TRUE;
        -: 5108:                    }
        -: 5109:
    #####: 5110:                    if(md_ascii_case_eq(STR(off), _T("</style>"), 8)) {
    #####: 5111:                        *p_end = off + 8;
    #####: 5112:                        return TRUE;
        -: 5113:                    }
        -: 5114:
    #####: 5115:                    if(md_ascii_case_eq(STR(off), _T("</pre>"), 6)) {
    #####: 5116:                        *p_end = off + 6;
    #####: 5117:                        return TRUE;
        -: 5118:                    }
        -: 5119:                }
        -: 5120:
    #####: 5121:                off++;
        -: 5122:            }
    #####: 5123:            *p_end = off;
    #####: 5124:            return FALSE;
        -: 5125:        }
        -: 5126:
    #####: 5127:        case 2:
    #####: 5128:            return (md_line_contains(ctx, beg, _T("-->"), 3, p_end) ? 2 : FALSE);
        -: 5129:
    #####: 5130:        case 3:
    #####: 5131:            return (md_line_contains(ctx, beg, _T("?>"), 2, p_end) ? 3 : FALSE);
        -: 5132:
    #####: 5133:        case 4:
    #####: 5134:            return (md_line_contains(ctx, beg, _T(">"), 1, p_end) ? 4 : FALSE);
        -: 5135:
    #####: 5136:        case 5:
    #####: 5137:            return (md_line_contains(ctx, beg, _T("]]>"), 3, p_end) ? 5 : FALSE);
        -: 5138:
    #####: 5139:        case 6:     /* Pass through */
        -: 5140:        case 7:
    #####: 5141:            *p_end = beg;
    #####: 5142:            return (ISNEWLINE(beg) ? ctx->html_block_type : FALSE);
        -: 5143:
    #####: 5144:        default:
    #####: 5145:            MD_UNREACHABLE();
        -: 5146:    }
        -: 5147:}
        -: 5148:
        -: 5149:
        -: 5150:static int
        -: 5151:md_is_container_compatible(const MD_CONTAINER* pivot, const MD_CONTAINER* container)
        -: 5152:{
        -: 5153:    /* Block quote has no "items" like lists. */
    #####: 5154:    if(container->ch == _T('>'))
        -: 5155:        return FALSE;
        -: 5156:
    #####: 5157:    if(container->ch != pivot->ch)
        -: 5158:        return FALSE;
    #####: 5159:    if(container->mark_indent > pivot->contents_indent)
        -: 5160:        return FALSE;
        -: 5161:
        -: 5162:    return TRUE;
        -: 5163:}
        -: 5164:
        -: 5165:static int
    #####: 5166:md_push_container(MD_CTX* ctx, const MD_CONTAINER* container)
        -: 5167:{
    #####: 5168:    if(ctx->n_containers >= ctx->alloc_containers) {
        -: 5169:        MD_CONTAINER* new_containers;
        -: 5170:
    #####: 5171:        ctx->alloc_containers = (ctx->alloc_containers > 0 ? ctx->alloc_containers * 2 : 16);
    #####: 5172:        new_containers = realloc(ctx->containers, ctx->alloc_containers * sizeof(MD_CONTAINER));
    #####: 5173:        if(new_containers == NULL) {
    #####: 5174:            MD_LOG("realloc() failed.");
        -: 5175:            return -1;
        -: 5176:        }
        -: 5177:
    #####: 5178:        ctx->containers = new_containers;
        -: 5179:    }
        -: 5180:
    #####: 5181:    memcpy(&ctx->containers[ctx->n_containers++], container, sizeof(MD_CONTAINER));
    #####: 5182:    return 0;
        -: 5183:}
        -: 5184:
        -: 5185:static int
    #####: 5186:md_enter_child_containers(MD_CTX* ctx, int n_children, unsigned data)
        -: 5187:{
        -: 5188:    int i;
    #####: 5189:    int ret = 0;
        -: 5190:
    #####: 5191:    for(i = ctx->n_containers - n_children; i < ctx->n_containers; i++) {
    #####: 5192:        MD_CONTAINER* c = &ctx->containers[i];
    #####: 5193:        int is_ordered_list = FALSE;
        -: 5194:
    #####: 5195:        switch(c->ch) {
        -: 5196:            case _T(')'):
        -: 5197:            case _T('.'):
        -: 5198:                is_ordered_list = TRUE;
        -: 5199:                /* Pass through */
        -: 5200:
    #####: 5201:            case _T('-'):
        -: 5202:            case _T('+'):
        -: 5203:            case _T('*'):
        -: 5204:                /* Remember offset in ctx->block_bytes so we can revisit the
        -: 5205:                 * block if we detect it is a loose list. */
    #####: 5206:                md_end_current_block(ctx);
    #####: 5207:                c->block_byte_off = ctx->n_block_bytes;
        -: 5208:
    #####: 5209:                MD_CHECK(md_push_container_bytes(ctx,
        -: 5210:                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL),
        -: 5211:                                c->start, data, MD_BLOCK_CONTAINER_OPENER));
    #####: 5212:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0, data, MD_BLOCK_CONTAINER_OPENER));
        -: 5213:                break;
        -: 5214:
    #####: 5215:            case _T('>'):
    #####: 5216:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0, data, MD_BLOCK_CONTAINER_OPENER));
        -: 5217:                break;
        -: 5218:
    #####: 5219:            default:
    #####: 5220:                MD_UNREACHABLE();
        -: 5221:                break;
        -: 5222:        }
        -: 5223:    }
        -: 5224:
    #####: 5225:abort:
    #####: 5226:    return ret;
        -: 5227:}
        -: 5228:
        -: 5229:static int
        1: 5230:md_leave_child_containers(MD_CTX* ctx, int n_keep)
        -: 5231:{
        1: 5232:    int ret = 0;
        -: 5233:
        2: 5234:    while(ctx->n_containers > n_keep) {
    #####: 5235:        MD_CONTAINER* c = &ctx->containers[ctx->n_containers-1];
    #####: 5236:        int is_ordered_list = FALSE;
        -: 5237:
    #####: 5238:        switch(c->ch) {
        -: 5239:            case _T(')'):
        -: 5240:            case _T('.'):
        -: 5241:                is_ordered_list = TRUE;
        -: 5242:                /* Pass through */
        -: 5243:
    #####: 5244:            case _T('-'):
        -: 5245:            case _T('+'):
        -: 5246:            case _T('*'):
    #####: 5247:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0,
        -: 5248:                                0, MD_BLOCK_CONTAINER_CLOSER));
    #####: 5249:                MD_CHECK(md_push_container_bytes(ctx,
        -: 5250:                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL), 0,
        -: 5251:                                c->ch, MD_BLOCK_CONTAINER_CLOSER));
        -: 5252:                break;
        -: 5253:
    #####: 5254:            case _T('>'):
    #####: 5255:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0,
        -: 5256:                                0, MD_BLOCK_CONTAINER_CLOSER));
        -: 5257:                break;
        -: 5258:
    #####: 5259:            default:
    #####: 5260:                MD_UNREACHABLE();
        -: 5261:                break;
        -: 5262:        }
        -: 5263:
    #####: 5264:        ctx->n_containers--;
        -: 5265:    }
        -: 5266:
        1: 5267:abort:
        1: 5268:    return ret;
        -: 5269:}
        -: 5270:
        -: 5271:static int
        1: 5272:md_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)
        -: 5273:{
        1: 5274:    OFF off = beg;
        -: 5275:    OFF max_end;
        -: 5276:
        -: 5277:    /* Check for block quote mark. */
        1: 5278:    if(off < ctx->size  &&  CH(off) == _T('>')) {
    #####: 5279:        off++;
    #####: 5280:        p_container->ch = _T('>');
    #####: 5281:        p_container->is_loose = FALSE;
    #####: 5282:        p_container->mark_indent = indent;
    #####: 5283:        p_container->contents_indent = indent + 1;
    #####: 5284:        *p_end = off;
        -: 5285:        return TRUE;
        -: 5286:    }
        -: 5287:
        -: 5288:    /* Check for list item bullet mark. */
        2: 5289:    if(off+1 < ctx->size  &&  ISANYOF(off, _T("-+*"))  &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {
    #####: 5290:        p_container->ch = CH(off);
    #####: 5291:        p_container->is_loose = FALSE;
    #####: 5292:        p_container->mark_indent = indent;
    #####: 5293:        p_container->contents_indent = indent + 1;
    #####: 5294:        *p_end = off+1;
        -: 5295:        return TRUE;
        -: 5296:    }
        -: 5297:
        -: 5298:    /* Check for ordered list item marks. */
        1: 5299:    max_end = off + 9;
        1: 5300:    if(max_end > ctx->size)
    #####: 5301:        max_end = ctx->size;
        1: 5302:    p_container->start = 0;
        1: 5303:    while(off < max_end  &&  ISDIGIT(off)) {
    #####: 5304:        p_container->start = p_container->start * 10 + CH(off) - _T('0');
    #####: 5305:        off++;
        -: 5306:    }
        1: 5307:    if(off+1 < ctx->size  &&  (CH(off) == _T('.') || CH(off) == _T(')'))   &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {
    #####: 5308:        p_container->ch = CH(off);
    #####: 5309:        p_container->is_loose = FALSE;
    #####: 5310:        p_container->mark_indent = indent;
    #####: 5311:        p_container->contents_indent = indent + off - beg + 1;
    #####: 5312:        *p_end = off+1;
        -: 5313:        return TRUE;
        -: 5314:    }
        -: 5315:
        -: 5316:    return FALSE;
        -: 5317:}
        -: 5318:
        -: 5319:static unsigned
        -: 5320:md_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)
        -: 5321:{
        -: 5322:    OFF off = beg;
        -: 5323:    unsigned indent = total_indent;
        -: 5324:
        1: 5325:    while(off < ctx->size  &&  ISBLANK(off)) {
    #####: 5326:        if(CH(off) == _T('\t'))
    #####: 5327:            indent = (indent + 4) & ~3;
        -: 5328:        else
    #####: 5329:            indent++;
    #####: 5330:        off++;
        -: 5331:    }
        -: 5332:
        1: 5333:    *p_end = off;
    #####: 5334:    return indent - total_indent;
        -: 5335:}
        -: 5336:
        -: 5337:static const MD_LINE_ANALYSIS md_dummy_blank_line = { MD_LINE_BLANK, 0 };
        -: 5338:
        -: 5339:/* Analyze type of the line and find some its properties. This serves as a
        -: 5340: * main input for determining type and boundaries of a block. */
        -: 5341:static int
        1: 5342:md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,
        -: 5343:                const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)
        -: 5344:{
        1: 5345:    unsigned total_indent = 0;
        1: 5346:    int n_parents = 0;
        1: 5347:    int n_brothers = 0;
        1: 5348:    int n_children = 0;
        1: 5349:    MD_CONTAINER container;
        1: 5350:    int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;
        1: 5351:    OFF off = beg;
        1: 5352:    int ret = 0;
        -: 5353:
        2: 5354:    line->indent = md_line_indentation(ctx, total_indent, off, &off);
        1: 5355:    total_indent += line->indent;
        1: 5356:    line->beg = off;
        -: 5357:
        -: 5358:    /* Given the indentation and block quote marks '>', determine how many of
        -: 5359:     * the current containers are our parents. */
        2: 5360:    while(n_parents < ctx->n_containers) {
    #####: 5361:        MD_CONTAINER* c = &ctx->containers[n_parents];
        -: 5362:
    #####: 5363:        if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&
    #####: 5364:            off < ctx->size  &&  CH(off) == _T('>'))
        -: 5365:        {
        -: 5366:            /* Block quote mark. */
    #####: 5367:            off++;
    #####: 5368:            total_indent++;
    #####: 5369:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
    #####: 5370:            total_indent += line->indent;
        -: 5371:
        -: 5372:            /* The optional 1st space after '>' is part of the block quote mark. */
    #####: 5373:            if(line->indent > 0)
    #####: 5374:                line->indent--;
        -: 5375:
    #####: 5376:            line->beg = off;
    #####: 5377:        } else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {
        -: 5378:            /* List. */
    #####: 5379:            line->indent -= c->contents_indent;
        -: 5380:        } else {
        -: 5381:            break;
        -: 5382:        }
        -: 5383:
    #####: 5384:        n_parents++;
        -: 5385:    }
        -: 5386:
        1: 5387:redo:
        -: 5388:    /* Check whether we are fenced code continuation. */
        1: 5389:    if(pivot_line->type == MD_LINE_FENCEDCODE) {
    #####: 5390:        line->beg = off;
        -: 5391:
        -: 5392:        /* We are another MD_LINE_FENCEDCODE unless we are closing fence
        -: 5393:         * which we transform into MD_LINE_BLANK. */
    #####: 5394:        if(line->indent < ctx->code_indent_offset) {
    #####: 5395:            if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {
    #####: 5396:                line->type = MD_LINE_BLANK;
    #####: 5397:                ctx->last_line_has_list_loosening_effect = FALSE;
    #####: 5398:                goto done;
        -: 5399:            }
        -: 5400:        }
        -: 5401:
    #####: 5402:        if(off >= ctx->size  ||  ISNEWLINE(off)) {
        -: 5403:            /* Blank line does not need any real indentation to be nested inside
        -: 5404:             * a list. */
    #####: 5405:            if(n_brothers + n_children == 0) {
    #####: 5406:                while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))
    #####: 5407:                    n_parents++;
        -: 5408:            }
        -: 5409:        }
        -: 5410:
        -: 5411:        /* Change indentation accordingly to the initial code fence. */
    #####: 5412:        if(n_parents == ctx->n_containers) {
    #####: 5413:            if(line->indent > pivot_line->indent)
    #####: 5414:                line->indent -= pivot_line->indent;
        -: 5415:            else
    #####: 5416:                line->indent = 0;
        -: 5417:
    #####: 5418:            line->type = MD_LINE_FENCEDCODE;
    #####: 5419:            goto done;
        -: 5420:        }
        -: 5421:    }
        -: 5422:
        -: 5423:    /* Check whether we are HTML block continuation. */
        1: 5424:    if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {
        -: 5425:        int html_block_type;
        -: 5426:
    #####: 5427:        html_block_type = md_is_html_block_end_condition(ctx, off, &off);
    #####: 5428:        if(html_block_type > 0) {
    #####: 5429:            MD_ASSERT(html_block_type == ctx->html_block_type);
        -: 5430:
        -: 5431:            /* Make sure this is the last line of the block. */
    #####: 5432:            ctx->html_block_type = 0;
        -: 5433:
        -: 5434:            /* Some end conditions serve as blank lines at the same time. */
    #####: 5435:            if(html_block_type == 6 || html_block_type == 7) {
    #####: 5436:                line->type = MD_LINE_BLANK;
    #####: 5437:                line->indent = 0;
    #####: 5438:                goto done;
        -: 5439:            }
        -: 5440:        }
        -: 5441:
    #####: 5442:        if(n_parents == ctx->n_containers) {
    #####: 5443:            line->type = MD_LINE_HTML;
    #####: 5444:            goto done;
        -: 5445:        }
        -: 5446:    }
        -: 5447:
        -: 5448:    /* Check for blank line. */
        1: 5449:    if(off >= ctx->size  ||  ISNEWLINE(off)) {
        -: 5450:        /* Blank line does not need any real indentation to be nested inside
        -: 5451:         * a list. */
    #####: 5452:        if(n_brothers + n_children == 0) {
    #####: 5453:            while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))
    #####: 5454:                n_parents++;
        -: 5455:        }
        -: 5456:
    #####: 5457:        if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {
    #####: 5458:            line->type = MD_LINE_INDENTEDCODE;
    #####: 5459:            if(line->indent > ctx->code_indent_offset)
    #####: 5460:                line->indent -= ctx->code_indent_offset;
        -: 5461:            else
    #####: 5462:                line->indent = 0;
    #####: 5463:            ctx->last_line_has_list_loosening_effect = FALSE;
        -: 5464:        } else {
    #####: 5465:            line->type = MD_LINE_BLANK;
    #####: 5466:            ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&
    #####: 5467:                    n_brothers + n_children == 0  &&
    #####: 5468:                    ctx->containers[n_parents-1].ch != _T('>'));
        -: 5469:
        -: 5470:#if 1
        -: 5471:            /* See https://github.com/mity/md4c/issues/6
        -: 5472:             *
        -: 5473:             * This ugly checking tests we are in (yet empty) list item but not
        -: 5474:             * its very first line (with the list item mark).
        -: 5475:             *
        -: 5476:             * If we are such blank line, then any following non-blank line
        -: 5477:             * which would be part of this list item actually ends the list
        -: 5478:             * because "a list item can begin with at most one blank line."
        -: 5479:             */
    #####: 5480:            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
    #####: 5481:               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
    #####: 5482:               ctx->n_block_bytes > sizeof(MD_BLOCK))
        -: 5483:            {
    #####: 5484:                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
    #####: 5485:                if(top_block->type == MD_BLOCK_LI)
    #####: 5486:                    ctx->last_list_item_starts_with_two_blank_lines = TRUE;
        -: 5487:            }
        -: 5488:#endif
        -: 5489:        }
        -: 5490:        goto done_on_eol;
        -: 5491:    } else {
        -: 5492:#if 1
        -: 5493:        /* This is 2nd half of the hack. If the flag is set (that is there
        -: 5494:         * were 2nd blank line at the start of the list item) and we would also
        -: 5495:         * belonging to such list item, then interrupt the list. */
        1: 5496:        ctx->last_line_has_list_loosening_effect = FALSE;
        1: 5497:        if(ctx->last_list_item_starts_with_two_blank_lines) {
    #####: 5498:            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
    #####: 5499:               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
    #####: 5500:               ctx->n_block_bytes > sizeof(MD_BLOCK))
        -: 5501:            {
    #####: 5502:                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
    #####: 5503:                if(top_block->type == MD_BLOCK_LI)
    #####: 5504:                    n_parents--;
        -: 5505:            }
        -: 5506:
    #####: 5507:            ctx->last_list_item_starts_with_two_blank_lines = FALSE;
        -: 5508:        }
        -: 5509:#endif
        -: 5510:    }
        -: 5511:
        -: 5512:    /* Check whether we are Setext underline. */
        1: 5513:    if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT
    #####: 5514:        &&  (CH(off) == _T('=') || CH(off) == _T('-'))
    #####: 5515:        &&  (n_parents == ctx->n_containers))
        -: 5516:    {
    #####: 5517:        unsigned level;
        -: 5518:
    #####: 5519:        if(md_is_setext_underline(ctx, off, &off, &level)) {
    #####: 5520:            line->type = MD_LINE_SETEXTUNDERLINE;
    #####: 5521:            line->data = level;
    #####: 5522:            goto done;
        -: 5523:        }
        -: 5524:    }
        -: 5525:
        -: 5526:    /* Check for thematic break line. */
        2: 5527:    if(line->indent < ctx->code_indent_offset  &&  ISANYOF(off, _T("-_*"))) {
        1: 5528:        if(md_is_hr_line(ctx, off, &off)) {
    #####: 5529:            line->type = MD_LINE_HR;
    #####: 5530:            goto done;
        -: 5531:        }
        -: 5532:    }
        -: 5533:
        -: 5534:    /* Check whether we are table continuation. */
        1: 5535:    if(pivot_line->type == MD_LINE_TABLE  &&  md_is_table_row(ctx, off, &off)) {
    #####: 5536:        line->type = MD_LINE_TABLE;
    #####: 5537:        goto done;
        -: 5538:    }
        -: 5539:
        -: 5540:    /* Check for "brother" container. I.e. whether we are another list item
        -: 5541:     * in already started list. */
        1: 5542:    if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {
    #####: 5543:        OFF tmp;
        -: 5544:
    #####: 5545:        if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&
    #####: 5546:           md_is_container_compatible(&ctx->containers[n_parents], &container))
        -: 5547:        {
    #####: 5548:            pivot_line = &md_dummy_blank_line;
        -: 5549:
    #####: 5550:            off = tmp;
        -: 5551:
    #####: 5552:            total_indent += container.contents_indent - container.mark_indent;
    #####: 5553:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
    #####: 5554:            total_indent += line->indent;
    #####: 5555:            line->beg = off;
        -: 5556:
        -: 5557:            /* Some of the following whitespace actually still belongs to the mark. */
    #####: 5558:            if(off >= ctx->size || ISNEWLINE(off)) {
    #####: 5559:                container.contents_indent++;
    #####: 5560:            } else if(line->indent <= ctx->code_indent_offset) {
    #####: 5561:                container.contents_indent += line->indent;
    #####: 5562:                line->indent = 0;
        -: 5563:            } else {
    #####: 5564:                container.contents_indent += 1;
    #####: 5565:                line->indent--;
        -: 5566:            }
        -: 5567:
    #####: 5568:            ctx->containers[n_parents].mark_indent = container.mark_indent;
    #####: 5569:            ctx->containers[n_parents].contents_indent = container.contents_indent;
        -: 5570:
    #####: 5571:            n_brothers++;
    #####: 5572:            goto redo;
        -: 5573:        }
        -: 5574:    }
        -: 5575:
        -: 5576:    /* Check for indented code.
        -: 5577:     * Note indented code block cannot interrupt a paragraph. */
        1: 5578:    if(line->indent >= ctx->code_indent_offset  &&
    #####: 5579:        (pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))
        -: 5580:    {
    #####: 5581:        line->type = MD_LINE_INDENTEDCODE;
        -: 5582:        MD_ASSERT(line->indent >= ctx->code_indent_offset);
    #####: 5583:        line->indent -= ctx->code_indent_offset;
    #####: 5584:        line->data = 0;
    #####: 5585:        goto done;
        -: 5586:    }
        -: 5587:
        -: 5588:    /* Check for start of a new container block. */
        2: 5589:    if(line->indent < ctx->code_indent_offset  &&
        1: 5590:       md_is_container_mark(ctx, line->indent, off, &off, &container))
        -: 5591:    {
    #####: 5592:        if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
    #####: 5593:                    (off >= ctx->size || ISNEWLINE(off)))
        -: 5594:        {
        -: 5595:            /* Noop. List mark followed by a blank line cannot interrupt a paragraph. */
    #####: 5596:        } else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
    #####: 5597:                    (container.ch == _T('.') || container.ch == _T(')'))  &&  container.start != 1)
        -: 5598:        {
        -: 5599:            /* Noop. Ordered list cannot interrupt a paragraph unless the start index is 1. */
        -: 5600:        } else {
    #####: 5601:            total_indent += container.contents_indent - container.mark_indent;
    #####: 5602:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
    #####: 5603:            total_indent += line->indent;
        -: 5604:
    #####: 5605:            line->beg = off;
    #####: 5606:            line->data = container.ch;
        -: 5607:
        -: 5608:            /* Some of the following whitespace actually still belongs to the mark. */
    #####: 5609:            if(off >= ctx->size || ISNEWLINE(off)) {
    #####: 5610:                container.contents_indent++;
    #####: 5611:            } else if(line->indent <= ctx->code_indent_offset) {
    #####: 5612:                container.contents_indent += line->indent;
    #####: 5613:                line->indent = 0;
        -: 5614:            } else {
    #####: 5615:                container.contents_indent += 1;
    #####: 5616:                line->indent--;
        -: 5617:            }
        -: 5618:
    #####: 5619:            if(n_brothers + n_children == 0)
    #####: 5620:                pivot_line = &md_dummy_blank_line;
        -: 5621:
    #####: 5622:            if(n_children == 0)
    #####: 5623:                MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));
        -: 5624:
    #####: 5625:            n_children++;
    #####: 5626:            MD_CHECK(md_push_container(ctx, &container));
        -: 5627:            goto redo;
        -: 5628:        }
        -: 5629:    }
        -: 5630:
        -: 5631:    /* Check for ATX header. */
        1: 5632:    if(line->indent < ctx->code_indent_offset  &&  CH(off) == _T('#')) {
    #####: 5633:        unsigned level;
        -: 5634:
    #####: 5635:        if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {
    #####: 5636:            line->type = MD_LINE_ATXHEADER;
    #####: 5637:            line->data = level;
    #####: 5638:            goto done;
        -: 5639:        }
        -: 5640:    }
        -: 5641:
        -: 5642:    /* Check whether we are starting code fence. */
        1: 5643:    if(CH(off) == _T('`') || CH(off) == _T('~')) {
    #####: 5644:        if(md_is_opening_code_fence(ctx, off, &off)) {
    #####: 5645:            line->type = MD_LINE_FENCEDCODE;
    #####: 5646:            line->data = 1;
    #####: 5647:            goto done;
        -: 5648:        }
        -: 5649:    }
        -: 5650:
        -: 5651:    /* Check for start of raw HTML block. */
        1: 5652:    if(CH(off) == _T('<')  &&  !(ctx->r.flags & MD_FLAG_NOHTMLBLOCKS))
        -: 5653:    {
    #####: 5654:        ctx->html_block_type = md_is_html_block_start_condition(ctx, off);
        -: 5655:
        -: 5656:        /* HTML block type 7 cannot interrupt paragraph. */
    #####: 5657:        if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)
    #####: 5658:            ctx->html_block_type = 0;
        -: 5659:
    #####: 5660:        if(ctx->html_block_type > 0) {
        -: 5661:            /* The line itself also may immediately close the block. */
    #####: 5662:            if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {
        -: 5663:                /* Make sure this is the last line of the block. */
    #####: 5664:                ctx->html_block_type = 0;
        -: 5665:            }
        -: 5666:
    #####: 5667:            line->type = MD_LINE_HTML;
    #####: 5668:            goto done;
        -: 5669:        }
        -: 5670:    }
        -: 5671:
        -: 5672:    /* Check for table underline. */
        1: 5673:    if((ctx->r.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT  &&
    #####: 5674:       (CH(off) == _T('|') || CH(off) == _T('-') || CH(off) == _T(':')))
        -: 5675:    {
    #####: 5676:        unsigned col_count;
        -: 5677:
    #####: 5678:        if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&
    #####: 5679:            md_is_table_underline(ctx, off, &off, &col_count)  &&
    #####: 5680:            md_is_table_row(ctx, pivot_line->beg, NULL))
        -: 5681:        {
    #####: 5682:            line->data = col_count;
    #####: 5683:            line->type = MD_LINE_TABLEUNDERLINE;
    #####: 5684:            goto done;
        -: 5685:        }
        -: 5686:    }
        -: 5687:
        -: 5688:    /* By default, we are normal text line. */
        1: 5689:    line->type = MD_LINE_TEXT;
        1: 5690:    if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {
        -: 5691:        /* Lazy continuation. */
    #####: 5692:        n_parents = ctx->n_containers;
        -: 5693:    }
        -: 5694:
        2: 5695:done:
        -: 5696:    /* Scan for end of the line.
        -: 5697:     *
        -: 5698:     * Note this is bottleneck of this function as we itereate over (almost)
        -: 5699:     * all line contents after some initial line indentation. To optimize, we
        -: 5700:     * try to eat multiple chars in every loop iteration.
        -: 5701:     *
        -: 5702:     * (Measured ~6% performance boost of md2html with this optimization for
        -: 5703:     * normal kind of input.)
        -: 5704:     */
        4: 5705:    while(off + 4 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)
        2: 5706:                               &&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))
        2: 5707:        off += 4;
        6: 5708:    while(off < ctx->size  &&  !ISNEWLINE(off))
        2: 5709:        off++;
        -: 5710:
        1: 5711:done_on_eol:
        -: 5712:    /* Set end of the line. */
        1: 5713:    line->end = off;
        -: 5714:
        -: 5715:    /* But for ATX header, we should exclude the optional trailing mark. */
        1: 5716:    if(line->type == MD_LINE_ATXHEADER) {
        -: 5717:        OFF tmp = line->end;
    #####: 5718:        while(tmp > line->beg && CH(tmp-1) == _T(' '))
        -: 5719:            tmp--;
    #####: 5720:        while(tmp > line->beg && CH(tmp-1) == _T('#'))
        -: 5721:            tmp--;
    #####: 5722:        if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->r.flags & MD_FLAG_PERMISSIVEATXHEADERS))
    #####: 5723:            line->end = tmp;
        -: 5724:    }
        -: 5725:
        -: 5726:    /* Trim trailing spaces. */
        1: 5727:    if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {
        1: 5728:        while(line->end > line->beg && CH(line->end-1) == _T(' '))
    #####: 5729:            line->end--;
        -: 5730:    }
        -: 5731:
        -: 5732:    /* Eat also the new line. */
        1: 5733:    if(off < ctx->size && CH(off) == _T('\r'))
    #####: 5734:        off++;
        1: 5735:    if(off < ctx->size && CH(off) == _T('\n'))
        1: 5736:        off++;
        -: 5737:
        1: 5738:    *p_end = off;
        -: 5739:
        -: 5740:    /* If we belong to a list after seeing a blank line, the list is loose. */
        1: 5741:    if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {
    #####: 5742:        MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];
    #####: 5743:        if(c->ch != _T('>')) {
    #####: 5744:            MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);
    #####: 5745:            block->flags |= MD_BLOCK_LOOSE_LIST;
        -: 5746:        }
        -: 5747:    }
        -: 5748:
        -: 5749:    /* Leave any containers we are not part of anymore. */
        1: 5750:    if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)
    #####: 5751:        MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));
        -: 5752:
        -: 5753:    /* Enter any container we found a mark for. */
        1: 5754:    if(n_brothers > 0) {
    #####: 5755:        MD_ASSERT(n_brothers == 1);
    #####: 5756:        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0, 0,
        -: 5757:                MD_BLOCK_CONTAINER_CLOSER | MD_BLOCK_CONTAINER_OPENER));
        -: 5758:    }
        -: 5759:
        1: 5760:    if(n_children > 0)
    #####: 5761:        MD_CHECK(md_enter_child_containers(ctx, n_children, line->data));
        -: 5762:
        1: 5763:abort:
        1: 5764:    return ret;
        -: 5765:}
        -: 5766:
        -: 5767:static int
        1: 5768:md_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, const MD_LINE_ANALYSIS* line)
        -: 5769:{
        1: 5770:    const MD_LINE_ANALYSIS* pivot_line = *p_pivot_line;
        1: 5771:    int ret = 0;
        -: 5772:
        -: 5773:    /* Blank line ends current leaf block. */
        1: 5774:    if(line->type == MD_LINE_BLANK) {
    #####: 5775:        MD_CHECK(md_end_current_block(ctx));
    #####: 5776:        *p_pivot_line = &md_dummy_blank_line;
    #####: 5777:        return 0;
        -: 5778:    }
        -: 5779:
        -: 5780:    /* Some line types form block on their own. */
        1: 5781:    if(line->type == MD_LINE_HR || line->type == MD_LINE_ATXHEADER) {
    #####: 5782:        MD_CHECK(md_end_current_block(ctx));
        -: 5783:
        -: 5784:        /* Add our single-line block. */
    #####: 5785:        MD_CHECK(md_start_new_block(ctx, line));
    #####: 5786:        MD_CHECK(md_add_line_into_current_block(ctx, line));
    #####: 5787:        MD_CHECK(md_end_current_block(ctx));
    #####: 5788:        *p_pivot_line = &md_dummy_blank_line;
    #####: 5789:        return 0;
        -: 5790:    }
        -: 5791:
        -: 5792:    /* MD_LINE_SETEXTUNDERLINE changes meaning of the current block and ends it. */
        1: 5793:    if(line->type == MD_LINE_SETEXTUNDERLINE) {
    #####: 5794:        MD_ASSERT(ctx->current_block != NULL);
    #####: 5795:        ctx->current_block->type = MD_BLOCK_H;
    #####: 5796:        ctx->current_block->data = line->data;
    #####: 5797:        MD_CHECK(md_end_current_block(ctx));
    #####: 5798:        *p_pivot_line = &md_dummy_blank_line;
    #####: 5799:        return 0;
        -: 5800:    }
        -: 5801:
        -: 5802:    /* MD_LINE_TABLEUNDERLINE changes meaning of the current block. */
        1: 5803:    if(line->type == MD_LINE_TABLEUNDERLINE) {
    #####: 5804:        MD_ASSERT(ctx->current_block != NULL);
    #####: 5805:        MD_ASSERT(ctx->current_block->n_lines == 1);
    #####: 5806:        ctx->current_block->type = MD_BLOCK_TABLE;
    #####: 5807:        ctx->current_block->data = line->data;
    #####: 5808:        MD_ASSERT(pivot_line != &md_dummy_blank_line);
    #####: 5809:        ((MD_LINE_ANALYSIS*)pivot_line)->type = MD_LINE_TABLE;
    #####: 5810:        MD_CHECK(md_add_line_into_current_block(ctx, line));
        -: 5811:        return 0;
        -: 5812:    }
        -: 5813:
        -: 5814:    /* The current block also ends if the line has different type. */
        1: 5815:    if(line->type != pivot_line->type)
        1: 5816:        MD_CHECK(md_end_current_block(ctx));
        -: 5817:
        -: 5818:    /* The current line may start a new block. */
        1: 5819:    if(ctx->current_block == NULL) {
        1: 5820:        MD_CHECK(md_start_new_block(ctx, line));
        1: 5821:        *p_pivot_line = line;
        -: 5822:    }
        -: 5823:
        -: 5824:    /* In all other cases the line is just a continuation of the current block. */
        1: 5825:    MD_CHECK(md_add_line_into_current_block(ctx, line));
        -: 5826:
        1: 5827:abort:
        -: 5828:    return ret;
        -: 5829:}
        -: 5830:
        -: 5831:static int
        1: 5832:md_process_doc(MD_CTX *ctx)
        -: 5833:{
        1: 5834:    const MD_LINE_ANALYSIS* pivot_line = &md_dummy_blank_line;
        1: 5835:    MD_LINE_ANALYSIS line_buf[2];
        1: 5836:    MD_LINE_ANALYSIS* line = &line_buf[0];
        1: 5837:    OFF off = 0;
        1: 5838:    int ret = 0;
        -: 5839:
        1: 5840:    MD_ENTER_BLOCK(MD_BLOCK_DOC, NULL);
        -: 5841:
        2: 5842:    while(off < ctx->size) {
        1: 5843:        if(line == pivot_line)
    #####: 5844:            line = (line == &line_buf[0] ? &line_buf[1] : &line_buf[0]);
        -: 5845:
        1: 5846:        MD_CHECK(md_analyze_line(ctx, off, &off, pivot_line, line));
        1: 5847:        MD_CHECK(md_process_line(ctx, &pivot_line, line));
        -: 5848:    }
        -: 5849:
        1: 5850:    md_end_current_block(ctx);
        -: 5851:
        1: 5852:    MD_CHECK(md_build_ref_def_hashtable(ctx));
        -: 5853:
        -: 5854:    /* Process all blocks. */
        1: 5855:    MD_CHECK(md_leave_child_containers(ctx, 0));
        1: 5856:    MD_CHECK(md_process_all_blocks(ctx));
        -: 5857:
    #####: 5858:    MD_LEAVE_BLOCK(MD_BLOCK_DOC, NULL);
        -: 5859:
    #####: 5860:abort:
        -: 5861:
        -: 5862:#if 0
        -: 5863:    /* Output some memory consumption statistics. */
        -: 5864:    {
        -: 5865:        char buffer[256];
        -: 5866:        sprintf(buffer, "Alloced %u bytes for block buffer.",
        -: 5867:                    (unsigned)(ctx->alloc_block_bytes));
        -: 5868:        MD_LOG(buffer);
        -: 5869:
        -: 5870:        sprintf(buffer, "Alloced %u bytes for containers buffer.",
        -: 5871:                    (unsigned)(ctx->alloc_containers * sizeof(MD_CONTAINER)));
        -: 5872:        MD_LOG(buffer);
        -: 5873:
        -: 5874:        sprintf(buffer, "Alloced %u bytes for marks buffer.",
        -: 5875:                    (unsigned)(ctx->alloc_marks * sizeof(MD_MARK)));
        -: 5876:        MD_LOG(buffer);
        -: 5877:
        -: 5878:        sprintf(buffer, "Alloced %u bytes for aux. buffer.",
        -: 5879:                    (unsigned)(ctx->alloc_buffer * sizeof(MD_CHAR)));
        -: 5880:        MD_LOG(buffer);
        -: 5881:    }
        -: 5882:#endif
        -: 5883:
    #####: 5884:    return ret;
        -: 5885:}
        -: 5886:
        -: 5887:
        -: 5888:/********************
        -: 5889: ***  Public API  ***
        -: 5890: ********************/
        -: 5891:
        -: 5892:int
        1: 5893:md_parse(const MD_CHAR* text, MD_SIZE size, const MD_RENDERER* renderer, void* userdata)
        -: 5894:{
        1: 5895:    MD_CTX ctx;
        -: 5896:    int i;
        -: 5897:    int ret;
        -: 5898:
        -: 5899:    /* Setup context structure. */
        1: 5900:    memset(&ctx, 0, sizeof(MD_CTX));
        1: 5901:    ctx.text = text;
        1: 5902:    ctx.size = size;
        1: 5903:    memcpy(&ctx.r, renderer, sizeof(MD_RENDERER));
        1: 5904:    ctx.userdata = userdata;
        1: 5905:    ctx.code_indent_offset = (ctx.r.flags & MD_FLAG_NOINDENTEDCODEBLOCKS) ? (OFF)(-1) : 4;
        1: 5906:    md_build_mark_char_map(&ctx);
        -: 5907:
        -: 5908:    /* Reset all unresolved opener mark chains. */
        9: 5909:    for(i = 0; i < SIZEOF_ARRAY(ctx.mark_chains); i++) {
        8: 5910:        ctx.mark_chains[i].head = -1;
        8: 5911:        ctx.mark_chains[i].tail = -1;
        -: 5912:    }
        1: 5913:    ctx.unresolved_link_head = -1;
        1: 5914:    ctx.unresolved_link_tail = -1;
        -: 5915:
        -: 5916:    /* All the work. */
        1: 5917:    ret = md_process_doc(&ctx);
        -: 5918:
        -: 5919:    /* Clean-up. */
    #####: 5920:    md_free_ref_defs(&ctx);
    #####: 5921:    md_free_ref_def_hashtable(&ctx);
    #####: 5922:    free(ctx.buffer);
    #####: 5923:    free(ctx.marks);
    #####: 5924:    free(ctx.block_bytes);
    #####: 5925:    free(ctx.containers);
        -: 5926:
    #####: 5927:    return ret;
        -: 5928:}
