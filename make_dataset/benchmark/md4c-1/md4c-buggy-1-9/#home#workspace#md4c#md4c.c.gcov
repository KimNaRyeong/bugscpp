        -:    0:Source:/home/workspace/md4c/md4c.c
        -:    0:Programs:5
        -:    1:/*
        -:    2: * MD4C: Markdown parser for C
        -:    3: * (http://github.com/mity/md4c)
        -:    4: *
        -:    5: * Copyright (c) 2016-2017 Martin Mitas
        -:    6: *
        -:    7: * Permission is hereby granted, free of charge, to any person obtaining a
        -:    8: * copy of this software and associated documentation files (the "Software"),
        -:    9: * to deal in the Software without restriction, including without limitation
        -:   10: * the rights to use, copy, modify, merge, publish, distribute, sublicense,
        -:   11: * and/or sell copies of the Software, and to permit persons to whom the
        -:   12: * Software is furnished to do so, subject to the following conditions:
        -:   13: *
        -:   14: * The above copyright notice and this permission notice shall be included in
        -:   15: * all copies or substantial portions of the Software.
        -:   16: *
        -:   17: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        -:   18: * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   19: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   20: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   21: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        -:   22: * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
        -:   23: * IN THE SOFTWARE.
        -:   24: */
        -:   25:
        -:   26:#include "md4c.h"
        -:   27:
        -:   28:#include <stdio.h>
        -:   29:#include <stdlib.h>
        -:   30:#include <string.h>
        -:   31:
        -:   32:
        -:   33:/*****************************
        -:   34: ***  Miscellaneous Stuff  ***
        -:   35: *****************************/
        -:   36:
        -:   37:#ifdef _MSC_VER
        -:   38:    /* MSVC does not understand "inline" when building as pure C (not C++).
        -:   39:     * However it understands "__inline" */
        -:   40:    #ifndef __cplusplus
        -:   41:        #define inline __inline
        -:   42:    #endif
        -:   43:#endif
        -:   44:
        -:   45:#ifdef _T
        -:   46:    #undef _T
        -:   47:#endif
        -:   48:#if defined MD4C_USE_UTF16
        -:   49:    #define _T(x)           L##x
        -:   50:#else
        -:   51:    #define _T(x)           x
        -:   52:#endif
        -:   53:
        -:   54:/* Misc. macros. */
        -:   55:#define SIZEOF_ARRAY(a)     (sizeof(a) / sizeof(a[0]))
        -:   56:
        -:   57:#define STRINGIZE_(x)       #x
        -:   58:#define STRINGIZE(x)        STRINGIZE_(x)
        -:   59:
        -:   60:#ifndef TRUE
        -:   61:    #define TRUE            1
        -:   62:    #define FALSE           0
        -:   63:#endif
        -:   64:
        -:   65:
        -:   66:/************************
        -:   67: ***  Internal Types  ***
        -:   68: ************************/
        -:   69:
        -:   70:/* These are omnipresent so lets save some typing. */
        -:   71:#define CHAR    MD_CHAR
        -:   72:#define SZ      MD_SIZE
        -:   73:#define OFF     MD_OFFSET
        -:   74:
        -:   75:typedef struct MD_MARK_tag MD_MARK;
        -:   76:typedef struct MD_BLOCK_tag MD_BLOCK;
        -:   77:typedef struct MD_CONTAINER_tag MD_CONTAINER;
        -:   78:typedef struct MD_REF_DEF_tag MD_REF_DEF;
        -:   79:
        -:   80:
        -:   81:/* During analyzes of inline marks, we need to manage some "mark chains",
        -:   82: * of (yet unresolved) openers. This structure holds start/end of the chain.
        -:   83: * The chain internals are then realized through MD_MARK::prev and ::next.
        -:   84: */
        -:   85:typedef struct MD_MARKCHAIN_tag MD_MARKCHAIN;
        -:   86:struct MD_MARKCHAIN_tag {
        -:   87:    int head;   /* Index of first mark in the chain, or -1 if empty. */
        -:   88:    int tail;   /* Index of last mark in the chain, or -1 if empty. */
        -:   89:};
        -:   90:
        -:   91:/* Context propagated through all the parsing. */
        -:   92:typedef struct MD_CTX_tag MD_CTX;
        -:   93:struct MD_CTX_tag {
        -:   94:    /* Immutable stuff (parameters of md_parse()). */
        -:   95:    const CHAR* text;
        -:   96:    SZ size;
        -:   97:    MD_RENDERER r;
        -:   98:    void* userdata;
        -:   99:
        -:  100:    /* Helper temporary growing buffer. */
        -:  101:    CHAR* buffer;
        -:  102:    unsigned alloc_buffer;
        -:  103:
        -:  104:    /* Reference definitions. */
        -:  105:    MD_REF_DEF* ref_defs;
        -:  106:    int n_ref_defs;
        -:  107:    int alloc_ref_defs;
        -:  108:    void** ref_def_hashtable;
        -:  109:    int ref_def_hashtable_size;
        -:  110:
        -:  111:    /* Stack of inline/span markers.
        -:  112:     * This is only used for parsing a single block contents but by storing it
        -:  113:     * here we may reuse the stack for subsequent blocks; i.e. we have fewer
        -:  114:     * (re)allocations. */
        -:  115:    MD_MARK* marks;
        -:  116:    int n_marks;
        -:  117:    int alloc_marks;
        -:  118:
        -:  119:#if defined MD4C_USE_UTF16
        -:  120:    char mark_char_map[128];
        -:  121:#else
        -:  122:    char mark_char_map[256];
        -:  123:#endif
        -:  124:
        -:  125:    /* For resolving of inline spans. */
        -:  126:    MD_MARKCHAIN mark_chains[8];
        -:  127:#define PTR_CHAIN               ctx->mark_chains[0]
        -:  128:#define BACKTICK_OPENERS        ctx->mark_chains[1]
        -:  129:#define LOWERTHEN_OPENERS       ctx->mark_chains[2]
        -:  130:#define ASTERISK_OPENERS        ctx->mark_chains[3]
        -:  131:#define UNDERSCORE_OPENERS      ctx->mark_chains[4]
        -:  132:#define TILDE_OPENERS           ctx->mark_chains[5]
        -:  133:#define BRACKET_OPENERS         ctx->mark_chains[6]
        -:  134:#define TABLECELLBOUNDARIES     ctx->mark_chains[7]
        -:  135:
        -:  136:    int n_table_cell_boundaries;
        -:  137:
        -:  138:    /* For resolving links. */
        -:  139:    int unresolved_link_head;
        -:  140:    int unresolved_link_tail;
        -:  141:
        -:  142:    /* For block analysis.
        -:  143:     * Notes:
        -:  144:     *   -- It holds MD_BLOCK as well as MD_LINE structures. After each
        -:  145:     *      MD_BLOCK, its (multiple) MD_LINE(s) follow.
        -:  146:     *   -- For MD_BLOCK_HTML and MD_BLOCK_CODE, MD_VERBATIMLINE(s) are used
        -:  147:     *      instead of MD_LINE(s).
        -:  148:     */
        -:  149:    void* block_bytes;
        -:  150:    MD_BLOCK* current_block;
        -:  151:    int n_block_bytes;
        -:  152:    int alloc_block_bytes;
        -:  153:
        -:  154:    /* For container block analysis. */
        -:  155:    MD_CONTAINER* containers;
        -:  156:    int n_containers;
        -:  157:    int alloc_containers;
        -:  158:
        -:  159:    int last_line_has_list_loosening_effect;
        -:  160:    int last_list_item_starts_with_two_blank_lines;
        -:  161:
        -:  162:    /* Minimal indentation to call the block "indented code block". */
        -:  163:    unsigned code_indent_offset;
        -:  164:
        -:  165:    /* Contextual info for line analysis. */
        -:  166:    SZ code_fence_length;   /* For checking closing fence length. */
        -:  167:    int html_block_type;    /* For checking closing raw HTML condition. */
        -:  168:};
        -:  169:
        -:  170:typedef enum MD_LINETYPE_tag MD_LINETYPE;
        -:  171:enum MD_LINETYPE_tag {
        -:  172:    MD_LINE_BLANK,
        -:  173:    MD_LINE_HR,
        -:  174:    MD_LINE_ATXHEADER,
        -:  175:    MD_LINE_SETEXTHEADER,
        -:  176:    MD_LINE_SETEXTUNDERLINE,
        -:  177:    MD_LINE_INDENTEDCODE,
        -:  178:    MD_LINE_FENCEDCODE,
        -:  179:    MD_LINE_HTML,
        -:  180:    MD_LINE_TEXT,
        -:  181:    MD_LINE_TABLE,
        -:  182:    MD_LINE_TABLEUNDERLINE
        -:  183:};
        -:  184:
        -:  185:typedef struct MD_LINE_ANALYSIS_tag MD_LINE_ANALYSIS;
        -:  186:struct MD_LINE_ANALYSIS_tag {
        -:  187:    MD_LINETYPE type    : 16;
        -:  188:    unsigned data       : 16;
        -:  189:    OFF beg;
        -:  190:    OFF end;
        -:  191:    unsigned indent;        /* Indentation level. */
        -:  192:};
        -:  193:
        -:  194:typedef struct MD_LINE_tag MD_LINE;
        -:  195:struct MD_LINE_tag {
        -:  196:    OFF beg;
        -:  197:    OFF end;
        -:  198:};
        -:  199:
        -:  200:typedef struct MD_VERBATIMLINE_tag MD_VERBATIMLINE;
        -:  201:struct MD_VERBATIMLINE_tag {
        -:  202:    OFF beg;
        -:  203:    OFF end;
        -:  204:    OFF indent;
        -:  205:};
        -:  206:
        -:  207:
        -:  208:/*******************
        -:  209: ***  Debugging  ***
        -:  210: *******************/
        -:  211:
        -:  212:#define MD_LOG(msg)                                                     \
        -:  213:    do {                                                                \
        -:  214:        if(ctx->r.debug_log != NULL)                                    \
        -:  215:            ctx->r.debug_log((msg), ctx->userdata);                     \
        -:  216:    } while(0)
        -:  217:
        -:  218:#ifdef DEBUG
        -:  219:    #define MD_ASSERT(cond)                                             \
        -:  220:            do {                                                        \
        -:  221:                if(!(cond)) {                                           \
        -:  222:                    MD_LOG(__FILE__ ":" STRINGIZE(__LINE__) ": "        \
        -:  223:                           "Assertion '" STRINGIZE(cond) "' failed.");  \
        -:  224:                    exit(1);                                            \
        -:  225:                }                                                       \
        -:  226:            } while(0)
        -:  227:
        -:  228:    #define MD_UNREACHABLE()        MD_ASSERT(1 == 0)
        -:  229:#else
        -:  230:    #ifdef __GNUC__
        -:  231:        #define MD_ASSERT(cond)     do { if(!(cond)) __builtin_unreachable(); } while(0)
        -:  232:        #define MD_UNREACHABLE()    do { __builtin_unreachable(); } while(0)
        -:  233:    #elif defined _MSC_VER  &&  _MSC_VER > 120
        -:  234:        #define MD_ASSERT(cond)     do { __assume(cond); } while(0)
        -:  235:        #define MD_UNREACHABLE()    do { __assume(0); } while(0)
        -:  236:    #else
        -:  237:        #define MD_ASSERT(cond)     do {} while(0)
        -:  238:        #define MD_UNREACHABLE()    do {} while(0)
        -:  239:    #endif
        -:  240:#endif
        -:  241:
        -:  242:
        -:  243:/*****************
        -:  244: ***  Helpers  ***
        -:  245: *****************/
        -:  246:
        -:  247:/* Character accessors. */
        -:  248:#define CH(off)                 (ctx->text[(off)])
        -:  249:#define STR(off)                (ctx->text + (off))
        -:  250:
        -:  251:/* Character classification.
        -:  252: * Note we assume ASCII compatibility of code points < 128 here. */
        -:  253:#define ISIN_(ch, ch_min, ch_max)       ((ch_min) <= (unsigned)(ch) && (unsigned)(ch) <= (ch_max))
        -:  254:#define ISANYOF_(ch, palette)           (md_strchr((palette), (ch)) != NULL)
        -:  255:#define ISANYOF2_(ch, ch1, ch2)         ((ch) == (ch1) || (ch) == (ch2))
        -:  256:#define ISANYOF3_(ch, ch1, ch2, ch3)    ((ch) == (ch1) || (ch) == (ch2) || (ch) == (ch3))
        -:  257:#define ISASCII_(ch)                    ((unsigned)(ch) <= 127)
        -:  258:#define ISBLANK_(ch)                    (ISANYOF2_((ch), _T(' '), _T('\t')))
        -:  259:#define ISNEWLINE_(ch)                  (ISANYOF2_((ch), _T('\r'), _T('\n')))
        -:  260:#define ISWHITESPACE_(ch)               (ISBLANK_(ch) || ISANYOF2_((ch), _T('\v'), _T('\f')))
        -:  261:#define ISCNTRL_(ch)                    ((unsigned)(ch) <= 31 || (unsigned)(ch) == 127)
        -:  262:#define ISPUNCT_(ch)                    (ISIN_(ch, 33, 47) || ISIN_(ch, 58, 64) || ISIN_(ch, 91, 96) || ISIN_(ch, 123, 126))
        -:  263:#define ISUPPER_(ch)                    (ISIN_(ch, _T('A'), _T('Z')))
        -:  264:#define ISLOWER_(ch)                    (ISIN_(ch, _T('a'), _T('z')))
        -:  265:#define ISALPHA_(ch)                    (ISUPPER_(ch) || ISLOWER_(ch))
        -:  266:#define ISDIGIT_(ch)                    (ISIN_(ch, _T('0'), _T('9')))
        -:  267:#define ISXDIGIT_(ch)                   (ISDIGIT_(ch) || ISIN_(ch, _T('A'), _T('F')) || ISIN_(ch, _T('a'), _T('f')))
        -:  268:#define ISALNUM_(ch)                    (ISALPHA_(ch) || ISDIGIT_(ch))
        -:  269:
        -:  270:#define ISANYOF(off, palette)           ISANYOF_(CH(off), (palette))
        -:  271:#define ISANYOF2(off, ch1, ch2)         ISANYOF2_(CH(off), (ch1), (ch2))
        -:  272:#define ISANYOF3(off, ch1, ch2, ch3)    ISANYOF3_(CH(off), (ch1), (ch2), (ch3))
        -:  273:#define ISASCII(off)                    ISASCII_(CH(off))
        -:  274:#define ISBLANK(off)                    ISBLANK_(CH(off))
        -:  275:#define ISNEWLINE(off)                  ISNEWLINE_(CH(off))
        -:  276:#define ISWHITESPACE(off)               ISWHITESPACE_(CH(off))
        -:  277:#define ISCNTRL(off)                    ISCNTRL_(CH(off))
        -:  278:#define ISPUNCT(off)                    ISPUNCT_(CH(off))
        -:  279:#define ISUPPER(off)                    ISUPPER_(CH(off))
        -:  280:#define ISLOWER(off)                    ISLOWER_(CH(off))
        -:  281:#define ISALPHA(off)                    ISALPHA_(CH(off))
        -:  282:#define ISDIGIT(off)                    ISDIGIT_(CH(off))
        -:  283:#define ISXDIGIT(off)                   ISXDIGIT_(CH(off))
        -:  284:#define ISALNUM(off)                    ISALNUM_(CH(off))
        -:  285:static inline const CHAR*
        -:  286:md_strchr(const CHAR* str, CHAR ch)
        -:  287:{
        -:  288:    OFF i;
       48:  289:    for(i = 0; str[i] != _T('\0'); i++) {
       39:  290:        if(ch == str[i])
        -:  291:            return (str + i);
        -:  292:    }
        -:  293:    return NULL;
        -:  294:}
        -:  295:
        -:  296:/* Case insensitive check of string equality. */
        -:  297:static inline int
        -:  298:md_ascii_case_eq(const CHAR* s1, const CHAR* s2, SZ n)
        -:  299:{
        -:  300:    OFF i;
    #####:  301:    for(i = 0; i < n; i++) {
    #####:  302:        CHAR ch1 = s1[i];
    #####:  303:        CHAR ch2 = s2[i];
        -:  304:
    #####:  305:        if(ISLOWER_(ch1))
    #####:  306:            ch1 += ('A'-'a');
    #####:  307:        if(ISLOWER_(ch2))
    #####:  308:            ch2 += ('A'-'a');
    #####:  309:        if(ch1 != ch2)
        -:  310:            return FALSE;
        -:  311:    }
        -:  312:    return TRUE;
        -:  313:}
        -:  314:
        -:  315:static inline int
        -:  316:md_ascii_eq(const CHAR* s1, const CHAR* s2, SZ n)
        -:  317:{
    #####:  318:    return memcmp(s1, s2, n * sizeof(CHAR)) == 0;
        -:  319:}
        -:  320:
        -:  321:static int
    #####:  322:md_text_with_null_replacement(MD_CTX* ctx, MD_TEXTTYPE type, const CHAR* str, SZ size)
        -:  323:{
    #####:  324:    OFF off = 0;
    #####:  325:    int ret = 0;
        -:  326:
        -:  327:    while(1) {
    #####:  328:        while(off < size  &&  str[off] != _T('\0'))
    #####:  329:            off++;
        -:  330:
    #####:  331:        if(off > 0) {
    #####:  332:            ret = ctx->r.text(type, str, off, ctx->userdata);
    #####:  333:            if(ret != 0)
        -:  334:                return ret;
        -:  335:
    #####:  336:            str += off;
    #####:  337:            size -= off;
    #####:  338:            off = 0;
        -:  339:        }
        -:  340:
    #####:  341:        if(off >= size)
        -:  342:            return 0;
        -:  343:
    #####:  344:        ret = ctx->r.text(MD_TEXT_NULLCHAR, _T(""), 1, ctx->userdata);
    #####:  345:        if(ret != 0)
        -:  346:            return ret;
    #####:  347:        off++;
        -:  348:    }
        -:  349:}
        -:  350:
        -:  351:
        -:  352:#define MD_CHECK(func)                                                  \
        -:  353:    do {                                                                \
        -:  354:        ret = (func);                                                   \
        -:  355:        if(ret < 0)                                                     \
        -:  356:            goto abort;                                                 \
        -:  357:    } while(0)
        -:  358:
        -:  359:
        -:  360:#define MD_TEMP_BUFFER(sz)                                              \
        -:  361:    do {                                                                \
        -:  362:        if(sz > ctx->alloc_buffer) {                                    \
        -:  363:            CHAR* new_buffer;                                           \
        -:  364:            SZ new_size = ((sz) + (sz) / 2 + 128) & ~127;               \
        -:  365:                                                                        \
        -:  366:            new_buffer = realloc(ctx->buffer, new_size);                \
        -:  367:            if(new_buffer == NULL) {                                    \
        -:  368:                MD_LOG("realloc() failed.");                            \
        -:  369:                ret = -1;                                               \
        -:  370:                goto abort;                                             \
        -:  371:            }                                                           \
        -:  372:                                                                        \
        -:  373:            ctx->buffer = new_buffer;                                   \
        -:  374:            ctx->alloc_buffer = new_size;                               \
        -:  375:        }                                                               \
        -:  376:    } while(0)
        -:  377:
        -:  378:
        -:  379:#define MD_ENTER_BLOCK(type, arg)                                       \
        -:  380:    do {                                                                \
        -:  381:        ret = ctx->r.enter_block((type), (arg), ctx->userdata);         \
        -:  382:        if(ret != 0) {                                                  \
        -:  383:            MD_LOG("Aborted from enter_block() callback.");             \
        -:  384:            goto abort;                                                 \
        -:  385:        }                                                               \
        -:  386:    } while(0)
        -:  387:
        -:  388:#define MD_LEAVE_BLOCK(type, arg)                                       \
        -:  389:    do {                                                                \
        -:  390:        ret = ctx->r.leave_block((type), (arg), ctx->userdata);         \
        -:  391:        if(ret != 0) {                                                  \
        -:  392:            MD_LOG("Aborted from leave_block() callback.");             \
        -:  393:            goto abort;                                                 \
        -:  394:        }                                                               \
        -:  395:    } while(0)
        -:  396:
        -:  397:#define MD_ENTER_SPAN(type, arg)                                        \
        -:  398:    do {                                                                \
        -:  399:        ret = ctx->r.enter_span((type), (arg), ctx->userdata);          \
        -:  400:        if(ret != 0) {                                                  \
        -:  401:            MD_LOG("Aborted from enter_span() callback.");              \
        -:  402:            goto abort;                                                 \
        -:  403:        }                                                               \
        -:  404:    } while(0)
        -:  405:
        -:  406:#define MD_LEAVE_SPAN(type, arg)                                        \
        -:  407:    do {                                                                \
        -:  408:        ret = ctx->r.leave_span((type), (arg), ctx->userdata);          \
        -:  409:        if(ret != 0) {                                                  \
        -:  410:            MD_LOG("Aborted from leave_span() callback.");              \
        -:  411:            goto abort;                                                 \
        -:  412:        }                                                               \
        -:  413:    } while(0)
        -:  414:
        -:  415:#define MD_TEXT(type, str, size)                                        \
        -:  416:    do {                                                                \
        -:  417:        if(size > 0) {                                                  \
        -:  418:            ret = ctx->r.text((type), (str), (size), ctx->userdata);    \
        -:  419:            if(ret != 0) {                                              \
        -:  420:                MD_LOG("Aborted from text() callback.");                \
        -:  421:                goto abort;                                             \
        -:  422:            }                                                           \
        -:  423:        }                                                               \
        -:  424:    } while(0)
        -:  425:
        -:  426:#define MD_TEXT_INSECURE(type, str, size)                               \
        -:  427:    do {                                                                \
        -:  428:        if(size > 0) {                                                  \
        -:  429:            ret = md_text_with_null_replacement(ctx, type, str, size);  \
        -:  430:            if(ret != 0) {                                              \
        -:  431:                MD_LOG("Aborted from text() callback.");                \
        -:  432:                goto abort;                                             \
        -:  433:            }                                                           \
        -:  434:        }                                                               \
        -:  435:    } while(0)
        -:  436:
        -:  437:
        -:  438:
        -:  439:/*************************
        -:  440: ***  Unicode Support  ***
        -:  441: *************************/
        -:  442:
        -:  443:typedef struct MD_UNICODE_FOLD_INFO_tag MD_UNICODE_FOLD_INFO;
        -:  444:struct MD_UNICODE_FOLD_INFO_tag {
        -:  445:    int codepoints[3];
        -:  446:    int n_codepoints;
        -:  447:};
        -:  448:
        -:  449:
        -:  450:#if defined MD4C_USE_UTF16 || defined MD4C_USE_UTF8
        -:  451:    static int
    #####:  452:    md_is_unicode_whitespace__(int codepoint)
        -:  453:    {
        -:  454:        /* The ASCII ones are the most frequently used ones, so lets check them first. */
    #####:  455:        if(codepoint <= 0x7f)
    #####:  456:            return ISWHITESPACE_(codepoint);
        -:  457:
        -:  458:        /* Check for Unicode codepoints in Zs class above 127. */
    #####:  459:        if(codepoint == 0x00a0 || codepoint == 0x1680)
        -:  460:            return TRUE;
    #####:  461:        if(0x2000 <= codepoint && codepoint <= 0x200a)
        -:  462:            return TRUE;
    #####:  463:        if(codepoint == 0x202f || codepoint == 0x205f || codepoint == 0x3000)
        -:  464:            return TRUE;
        -:  465:
    #####:  466:        return FALSE;
        -:  467:    }
        -:  468:
        -:  469:    static int
        -:  470:    md_unicode_cmp__(const void* p_codepoint_a, const void* p_codepoint_b)
        -:  471:    {
    #####:  472:        return (*(const int*)p_codepoint_a - *(const int*)p_codepoint_b);
        -:  473:    }
        -:  474:
        -:  475:    static int
    #####:  476:    md_is_unicode_punct__(int codepoint)
        -:  477:    {
        -:  478:        /* non-ASCII (above 127) Unicode punctuation codepoints (classes
        -:  479:         * Pc, Pd, Pe, Pf, Pi, Po, Ps).
        -:  480:         *
        -:  481:         * Warning: Keep the array sorted.
        -:  482:         */
        -:  483:        static const int punct_list[] = {
        -:  484:            0x00a1, 0x00a7, 0x00ab, 0x00b6, 0x00b7, 0x00bb, 0x00bf, 0x037e, 0x0387, 0x055a, 0x055b, 0x055c, 0x055d, 0x055e, 0x055f, 0x0589,
        -:  485:            0x058a, 0x05be, 0x05c0, 0x05c3, 0x05c6, 0x05f3, 0x05f4, 0x0609, 0x060a, 0x060c, 0x060d, 0x061b, 0x061e, 0x061f, 0x066a, 0x066b,
        -:  486:            0x066c, 0x066d, 0x06d4, 0x0700, 0x0701, 0x0702, 0x0703, 0x0704, 0x0705, 0x0706, 0x0707, 0x0708, 0x0709, 0x070a, 0x070b, 0x070c,
        -:  487:            0x070d, 0x07f7, 0x07f8, 0x07f9, 0x0830, 0x0831, 0x0832, 0x0833, 0x0834, 0x0835, 0x0836, 0x0837, 0x0838, 0x0839, 0x083a, 0x083b,
        -:  488:            0x083c, 0x083d, 0x083e, 0x085e, 0x0964, 0x0965, 0x0970, 0x0af0, 0x0df4, 0x0e4f, 0x0e5a, 0x0e5b, 0x0f04, 0x0f05, 0x0f06, 0x0f07,
        -:  489:            0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e, 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f14, 0x0f3a, 0x0f3b, 0x0f3c, 0x0f3d,
        -:  490:            0x0f85, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4, 0x0fd9, 0x0fda, 0x104a, 0x104b, 0x104c, 0x104d, 0x104e, 0x104f, 0x10fb, 0x1360,
        -:  491:            0x1361, 0x1362, 0x1363, 0x1364, 0x1365, 0x1366, 0x1367, 0x1368, 0x1400, 0x166d, 0x166e, 0x169b, 0x169c, 0x16eb, 0x16ec, 0x16ed,
        -:  492:            0x1735, 0x1736, 0x17d4, 0x17d5, 0x17d6, 0x17d8, 0x17d9, 0x17da, 0x1800, 0x1801, 0x1802, 0x1803, 0x1804, 0x1805, 0x1806, 0x1807,
        -:  493:            0x1808, 0x1809, 0x180a, 0x1944, 0x1945, 0x1a1e, 0x1a1f, 0x1aa0, 0x1aa1, 0x1aa2, 0x1aa3, 0x1aa4, 0x1aa5, 0x1aa6, 0x1aa8, 0x1aa9,
        -:  494:            0x1aaa, 0x1aab, 0x1aac, 0x1aad, 0x1b5a, 0x1b5b, 0x1b5c, 0x1b5d, 0x1b5e, 0x1b5f, 0x1b60, 0x1bfc, 0x1bfd, 0x1bfe, 0x1bff, 0x1c3b,
        -:  495:            0x1c3c, 0x1c3d, 0x1c3e, 0x1c3f, 0x1c7e, 0x1c7f, 0x1cc0, 0x1cc1, 0x1cc2, 0x1cc3, 0x1cc4, 0x1cc5, 0x1cc6, 0x1cc7, 0x1cd3, 0x2010,
        -:  496:            0x2011, 0x2012, 0x2013, 0x2014, 0x2015, 0x2016, 0x2017, 0x2018, 0x2019, 0x201a, 0x201b, 0x201c, 0x201d, 0x201e, 0x201f, 0x2020,
        -:  497:            0x2021, 0x2022, 0x2023, 0x2024, 0x2025, 0x2026, 0x2027, 0x2030, 0x2031, 0x2032, 0x2033, 0x2034, 0x2035, 0x2036, 0x2037, 0x2038,
        -:  498:            0x2039, 0x203a, 0x203b, 0x203c, 0x203d, 0x203e, 0x203f, 0x2040, 0x2041, 0x2042, 0x2043, 0x2045, 0x2046, 0x2047, 0x2048, 0x2049,
        -:  499:            0x204a, 0x204b, 0x204c, 0x204d, 0x204e, 0x204f, 0x2050, 0x2051, 0x2053, 0x2054, 0x2055, 0x2056, 0x2057, 0x2058, 0x2059, 0x205a,
        -:  500:            0x205b, 0x205c, 0x205d, 0x205e, 0x207d, 0x207e, 0x208d, 0x208e, 0x2308, 0x2309, 0x230a, 0x230b, 0x2329, 0x232a, 0x2768, 0x2769,
        -:  501:            0x276a, 0x276b, 0x276c, 0x276d, 0x276e, 0x276f, 0x2770, 0x2771, 0x2772, 0x2773, 0x2774, 0x2775, 0x27c5, 0x27c6, 0x27e6, 0x27e7,
        -:  502:            0x27e8, 0x27e9, 0x27ea, 0x27eb, 0x27ec, 0x27ed, 0x27ee, 0x27ef, 0x2983, 0x2984, 0x2985, 0x2986, 0x2987, 0x2988, 0x2989, 0x298a,
        -:  503:            0x298b, 0x298c, 0x298d, 0x298e, 0x298f, 0x2990, 0x2991, 0x2992, 0x2993, 0x2994, 0x2995, 0x2996, 0x2997, 0x2998, 0x29d8, 0x29d9,
        -:  504:            0x29da, 0x29db, 0x29fc, 0x29fd, 0x2cf9, 0x2cfa, 0x2cfb, 0x2cfc, 0x2cfe, 0x2cff, 0x2d70, 0x2e00, 0x2e01, 0x2e02, 0x2e03, 0x2e04,
        -:  505:            0x2e05, 0x2e06, 0x2e07, 0x2e08, 0x2e09, 0x2e0a, 0x2e0b, 0x2e0c, 0x2e0d, 0x2e0e, 0x2e0f, 0x2e10, 0x2e11, 0x2e12, 0x2e13, 0x2e14,
        -:  506:            0x2e15, 0x2e16, 0x2e17, 0x2e18, 0x2e19, 0x2e1a, 0x2e1b, 0x2e1c, 0x2e1d, 0x2e1e, 0x2e1f, 0x2e20, 0x2e21, 0x2e22, 0x2e23, 0x2e24,
        -:  507:            0x2e25, 0x2e26, 0x2e27, 0x2e28, 0x2e29, 0x2e2a, 0x2e2b, 0x2e2c, 0x2e2d, 0x2e2e, 0x2e30, 0x2e31, 0x2e32, 0x2e33, 0x2e34, 0x2e35,
        -:  508:            0x2e36, 0x2e37, 0x2e38, 0x2e39, 0x2e3a, 0x2e3b, 0x2e3c, 0x2e3d, 0x2e3e, 0x2e3f, 0x2e40, 0x2e41, 0x2e42, 0x2e43, 0x2e44, 0x3001,
        -:  509:            0x3002, 0x3003, 0x3008, 0x3009, 0x300a, 0x300b, 0x300c, 0x300d, 0x300e, 0x300f, 0x3010, 0x3011, 0x3014, 0x3015, 0x3016, 0x3017,
        -:  510:            0x3018, 0x3019, 0x301a, 0x301b, 0x301c, 0x301d, 0x301e, 0x301f, 0x3030, 0x303d, 0x30a0, 0x30fb, 0xa4fe, 0xa4ff, 0xa60d, 0xa60e,
        -:  511:            0xa60f, 0xa673, 0xa67e, 0xa6f2, 0xa6f3, 0xa6f4, 0xa6f5, 0xa6f6, 0xa6f7, 0xa874, 0xa875, 0xa876, 0xa877, 0xa8ce, 0xa8cf, 0xa8f8,
        -:  512:            0xa8f9, 0xa8fa, 0xa8fc, 0xa92e, 0xa92f, 0xa95f, 0xa9c1, 0xa9c2, 0xa9c3, 0xa9c4, 0xa9c5, 0xa9c6, 0xa9c7, 0xa9c8, 0xa9c9, 0xa9ca,
        -:  513:            0xa9cb, 0xa9cc, 0xa9cd, 0xa9de, 0xa9df, 0xaa5c, 0xaa5d, 0xaa5e, 0xaa5f, 0xaade, 0xaadf, 0xaaf0, 0xaaf1, 0xabeb, 0xfd3e, 0xfd3f,
        -:  514:            0xfe10, 0xfe11, 0xfe12, 0xfe13, 0xfe14, 0xfe15, 0xfe16, 0xfe17, 0xfe18, 0xfe19, 0xfe30, 0xfe31, 0xfe32, 0xfe33, 0xfe34, 0xfe35,
        -:  515:            0xfe36, 0xfe37, 0xfe38, 0xfe39, 0xfe3a, 0xfe3b, 0xfe3c, 0xfe3d, 0xfe3e, 0xfe3f, 0xfe40, 0xfe41, 0xfe42, 0xfe43, 0xfe44, 0xfe45,
        -:  516:            0xfe46, 0xfe47, 0xfe48, 0xfe49, 0xfe4a, 0xfe4b, 0xfe4c, 0xfe4d, 0xfe4e, 0xfe4f, 0xfe50, 0xfe51, 0xfe52, 0xfe54, 0xfe55, 0xfe56,
        -:  517:            0xfe57, 0xfe58, 0xfe59, 0xfe5a, 0xfe5b, 0xfe5c, 0xfe5d, 0xfe5e, 0xfe5f, 0xfe60, 0xfe61, 0xfe63, 0xfe68, 0xfe6a, 0xfe6b, 0xff01,
        -:  518:            0xff02, 0xff03, 0xff05, 0xff06, 0xff07, 0xff08, 0xff09, 0xff0a, 0xff0c, 0xff0d, 0xff0e, 0xff0f, 0xff1a, 0xff1b, 0xff1f, 0xff20,
        -:  519:            0xff3b, 0xff3c, 0xff3d, 0xff3f, 0xff5b, 0xff5d, 0xff5f, 0xff60, 0xff61, 0xff62, 0xff63, 0xff64, 0xff65, 0x10100, 0x10101, 0x10102,
        -:  520:            0x1039f, 0x103d0, 0x1056f, 0x10857, 0x1091f, 0x1093f, 0x10a50, 0x10a51, 0x10a52, 0x10a53, 0x10a54, 0x10a55, 0x10a56, 0x10a57, 0x10a58, 0x10a7f,
        -:  521:            0x10af0, 0x10af1, 0x10af2, 0x10af3, 0x10af4, 0x10af5, 0x10af6, 0x10b39, 0x10b3a, 0x10b3b, 0x10b3c, 0x10b3d, 0x10b3e, 0x10b3f, 0x10b99, 0x10b9a,
        -:  522:            0x10b9b, 0x10b9c, 0x11047, 0x11048, 0x11049, 0x1104a, 0x1104b, 0x1104c, 0x1104d, 0x110bb, 0x110bc, 0x110be, 0x110bf, 0x110c0, 0x110c1, 0x11140,
        -:  523:            0x11141, 0x11142, 0x11143, 0x11174, 0x11175, 0x111c5, 0x111c6, 0x111c7, 0x111c8, 0x111c9, 0x111cd, 0x111db, 0x111dd, 0x111de, 0x111df, 0x11238,
        -:  524:            0x11239, 0x1123a, 0x1123b, 0x1123c, 0x1123d, 0x112a9, 0x1144b, 0x1144c, 0x1144d, 0x1144e, 0x1144f, 0x1145b, 0x1145d, 0x114c6, 0x115c1, 0x115c2,
        -:  525:            0x115c3, 0x115c4, 0x115c5, 0x115c6, 0x115c7, 0x115c8, 0x115c9, 0x115ca, 0x115cb, 0x115cc, 0x115cd, 0x115ce, 0x115cf, 0x115d0, 0x115d1, 0x115d2,
        -:  526:            0x115d3, 0x115d4, 0x115d5, 0x115d6, 0x115d7, 0x11641, 0x11642, 0x11643, 0x11660, 0x11661, 0x11662, 0x11663, 0x11664, 0x11665, 0x11666, 0x11667,
        -:  527:            0x11668, 0x11669, 0x1166a, 0x1166b, 0x1166c, 0x1173c, 0x1173d, 0x1173e, 0x11c41, 0x11c42, 0x11c43, 0x11c44, 0x11c45, 0x11c70, 0x11c71, 0x12470,
        -:  528:            0x12471, 0x12472, 0x12473, 0x12474, 0x16a6e, 0x16a6f, 0x16af5, 0x16b37, 0x16b38, 0x16b39, 0x16b3a, 0x16b3b, 0x16b44, 0x1bc9f, 0x1da87, 0x1da88,
        -:  529:            0x1da89, 0x1da8a, 0x1da8b, 0x1e95e, 0x1e95f
        -:  530:        };
        -:  531:
        -:  532:        /* The ASCII ones are the most frequently used ones, so lets check them first. */
    #####:  533:        if(codepoint <= 0x7f)
    #####:  534:            return ISPUNCT_(codepoint);
        -:  535:
    #####:  536:        return (bsearch(&codepoint, punct_list, SIZEOF_ARRAY(punct_list), sizeof(int), md_unicode_cmp__) != NULL);
        -:  537:    }
        -:  538:
        -:  539:    static void
    #####:  540:    md_get_unicode_fold_info(int codepoint, MD_UNICODE_FOLD_INFO* info)
        -:  541:    {
        -:  542:        /* This maps single codepoint within a range to a single codepoint
        -:  543:         * within an offseted range. */
        -:  544:        static const struct {
        -:  545:            int min_codepoint;
        -:  546:            int max_codepoint;
        -:  547:            int offset;
        -:  548:        } range_map[] = {
        -:  549:            { 0x00c0, 0x00d6, 32 }, { 0x00d8, 0x00de, 32 }, { 0x0388, 0x038a, 37 }, { 0x0391, 0x03a1, 32 }, { 0x03a3, 0x03ab, 32 }, { 0x0400, 0x040f, 80 },
        -:  550:            { 0x0410, 0x042f, 32 }, { 0x0531, 0x0556, 48 }, { 0x1f08, 0x1f0f, -8 }, { 0x1f18, 0x1f1d, -8 }, { 0x1f28, 0x1f2f, -8 }, { 0x1f38, 0x1f3f, -8 },
        -:  551:            { 0x1f48, 0x1f4d, -8 }, { 0x1f68, 0x1f6f, -8 }, { 0x1fc8, 0x1fcb, -86 }, { 0x2160, 0x216f, 16 }, { 0x24b6, 0x24cf, 26 }, { 0xff21, 0xff3a, 32 },
        -:  552:            { 0x10400, 0x10425, 40 }
        -:  553:        };
        -:  554:
        -:  555:        /* This maps single codepoint to another single codepoint. */
        -:  556:        static const struct {
        -:  557:            int src_codepoint;
        -:  558:            int dest_codepoint;
        -:  559:        } single_map[] = {
        -:  560:            { 0x00b5, 0x03bc }, { 0x0100, 0x0101 }, { 0x0102, 0x0103 }, { 0x0104, 0x0105 }, { 0x0106, 0x0107 }, { 0x0108, 0x0109 }, { 0x010a, 0x010b }, { 0x010c, 0x010d },
        -:  561:            { 0x010e, 0x010f }, { 0x0110, 0x0111 }, { 0x0112, 0x0113 }, { 0x0114, 0x0115 }, { 0x0116, 0x0117 }, { 0x0118, 0x0119 }, { 0x011a, 0x011b }, { 0x011c, 0x011d },
        -:  562:            { 0x011e, 0x011f }, { 0x0120, 0x0121 }, { 0x0122, 0x0123 }, { 0x0124, 0x0125 }, { 0x0126, 0x0127 }, { 0x0128, 0x0129 }, { 0x012a, 0x012b }, { 0x012c, 0x012d },
        -:  563:            { 0x012e, 0x012f }, { 0x0132, 0x0133 }, { 0x0134, 0x0135 }, { 0x0136, 0x0137 }, { 0x0139, 0x013a }, { 0x013b, 0x013c }, { 0x013d, 0x013e }, { 0x013f, 0x0140 },
        -:  564:            { 0x0141, 0x0142 }, { 0x0143, 0x0144 }, { 0x0145, 0x0146 }, { 0x0147, 0x0148 }, { 0x014a, 0x014b }, { 0x014c, 0x014d }, { 0x014e, 0x014f }, { 0x0150, 0x0151 },
        -:  565:            { 0x0152, 0x0153 }, { 0x0154, 0x0155 }, { 0x0156, 0x0157 }, { 0x0158, 0x0159 }, { 0x015a, 0x015b }, { 0x015c, 0x015d }, { 0x015e, 0x015f }, { 0x0160, 0x0161 },
        -:  566:            { 0x0162, 0x0163 }, { 0x0164, 0x0165 }, { 0x0166, 0x0167 }, { 0x0168, 0x0169 }, { 0x016a, 0x016b }, { 0x016c, 0x016d }, { 0x016e, 0x016f }, { 0x0170, 0x0171 },
        -:  567:            { 0x0172, 0x0173 }, { 0x0174, 0x0175 }, { 0x0176, 0x0177 }, { 0x0178, 0x00ff }, { 0x0179, 0x017a }, { 0x017b, 0x017c }, { 0x017d, 0x017e }, { 0x017f, 0x0073 },
        -:  568:            { 0x0181, 0x0253 }, { 0x0182, 0x0183 }, { 0x0184, 0x0185 }, { 0x0186, 0x0254 }, { 0x0187, 0x0188 }, { 0x0189, 0x0256 }, { 0x018a, 0x0257 }, { 0x018b, 0x018c },
        -:  569:            { 0x018e, 0x01dd }, { 0x018f, 0x0259 }, { 0x0190, 0x025b }, { 0x0191, 0x0192 }, { 0x0193, 0x0260 }, { 0x0194, 0x0263 }, { 0x0196, 0x0269 }, { 0x0197, 0x0268 },
        -:  570:            { 0x0198, 0x0199 }, { 0x019c, 0x026f }, { 0x019d, 0x0272 }, { 0x019f, 0x0275 }, { 0x01a0, 0x01a1 }, { 0x01a2, 0x01a3 }, { 0x01a4, 0x01a5 }, { 0x01a6, 0x0280 },
        -:  571:            { 0x01a7, 0x01a8 }, { 0x01a9, 0x0283 }, { 0x01ac, 0x01ad }, { 0x01ae, 0x0288 }, { 0x01af, 0x01b0 }, { 0x01b1, 0x028a }, { 0x01b2, 0x028b }, { 0x01b3, 0x01b4 },
        -:  572:            { 0x01b5, 0x01b6 }, { 0x01b7, 0x0292 }, { 0x01b8, 0x01b9 }, { 0x01bc, 0x01bd }, { 0x01c4, 0x01c6 }, { 0x01c5, 0x01c6 }, { 0x01c7, 0x01c9 }, { 0x01c8, 0x01c9 },
        -:  573:            { 0x01ca, 0x01cc }, { 0x01cb, 0x01cc }, { 0x01cd, 0x01ce }, { 0x01cf, 0x01d0 }, { 0x01d1, 0x01d2 }, { 0x01d3, 0x01d4 }, { 0x01d5, 0x01d6 }, { 0x01d7, 0x01d8 },
        -:  574:            { 0x01d9, 0x01da }, { 0x01db, 0x01dc }, { 0x01de, 0x01df }, { 0x01e0, 0x01e1 }, { 0x01e2, 0x01e3 }, { 0x01e4, 0x01e5 }, { 0x01e6, 0x01e7 }, { 0x01e8, 0x01e9 },
        -:  575:            { 0x01ea, 0x01eb }, { 0x01ec, 0x01ed }, { 0x01ee, 0x01ef }, { 0x01f1, 0x01f3 }, { 0x01f2, 0x01f3 }, { 0x01f4, 0x01f5 }, { 0x01f6, 0x0195 }, { 0x01f7, 0x01bf },
        -:  576:            { 0x01f8, 0x01f9 }, { 0x01fa, 0x01fb }, { 0x01fc, 0x01fd }, { 0x01fe, 0x01ff }, { 0x0200, 0x0201 }, { 0x0202, 0x0203 }, { 0x0204, 0x0205 }, { 0x0206, 0x0207 },
        -:  577:            { 0x0208, 0x0209 }, { 0x020a, 0x020b }, { 0x020c, 0x020d }, { 0x020e, 0x020f }, { 0x0210, 0x0211 }, { 0x0212, 0x0213 }, { 0x0214, 0x0215 }, { 0x0216, 0x0217 },
        -:  578:            { 0x0218, 0x0219 }, { 0x021a, 0x021b }, { 0x021c, 0x021d }, { 0x021e, 0x021f }, { 0x0220, 0x019e }, { 0x0222, 0x0223 }, { 0x0224, 0x0225 }, { 0x0226, 0x0227 },
        -:  579:            { 0x0228, 0x0229 }, { 0x022a, 0x022b }, { 0x022c, 0x022d }, { 0x022e, 0x022f }, { 0x0230, 0x0231 }, { 0x0232, 0x0233 }, { 0x0345, 0x03b9 }, { 0x0386, 0x03ac },
        -:  580:            { 0x038c, 0x03cc }, { 0x038e, 0x03cd }, { 0x038f, 0x03ce }, { 0x03c2, 0x03c3 }, { 0x03d0, 0x03b2 }, { 0x03d1, 0x03b8 }, { 0x03d5, 0x03c6 }, { 0x03d6, 0x03c0 },
        -:  581:            { 0x03d8, 0x03d9 }, { 0x03da, 0x03db }, { 0x03dc, 0x03dd }, { 0x03de, 0x03df }, { 0x03e0, 0x03e1 }, { 0x03e2, 0x03e3 }, { 0x03e4, 0x03e5 }, { 0x03e6, 0x03e7 },
        -:  582:            { 0x03e8, 0x03e9 }, { 0x03ea, 0x03eb }, { 0x03ec, 0x03ed }, { 0x03ee, 0x03ef }, { 0x03f0, 0x03ba }, { 0x03f1, 0x03c1 }, { 0x03f2, 0x03c3 }, { 0x03f4, 0x03b8 },
        -:  583:            { 0x03f5, 0x03b5 }, { 0x0460, 0x0461 }, { 0x0462, 0x0463 }, { 0x0464, 0x0465 }, { 0x0466, 0x0467 }, { 0x0468, 0x0469 }, { 0x046a, 0x046b }, { 0x046c, 0x046d },
        -:  584:            { 0x046e, 0x046f }, { 0x0470, 0x0471 }, { 0x0472, 0x0473 }, { 0x0474, 0x0475 }, { 0x0476, 0x0477 }, { 0x0478, 0x0479 }, { 0x047a, 0x047b }, { 0x047c, 0x047d },
        -:  585:            { 0x047e, 0x047f }, { 0x0480, 0x0481 }, { 0x048a, 0x048b }, { 0x048c, 0x048d }, { 0x048e, 0x048f }, { 0x0490, 0x0491 }, { 0x0492, 0x0493 }, { 0x0494, 0x0495 },
        -:  586:            { 0x0496, 0x0497 }, { 0x0498, 0x0499 }, { 0x049a, 0x049b }, { 0x049c, 0x049d }, { 0x049e, 0x049f }, { 0x04a0, 0x04a1 }, { 0x04a2, 0x04a3 }, { 0x04a4, 0x04a5 },
        -:  587:            { 0x04a6, 0x04a7 }, { 0x04a8, 0x04a9 }, { 0x04aa, 0x04ab }, { 0x04ac, 0x04ad }, { 0x04ae, 0x04af }, { 0x04b0, 0x04b1 }, { 0x04b2, 0x04b3 }, { 0x04b4, 0x04b5 },
        -:  588:            { 0x04b6, 0x04b7 }, { 0x04b8, 0x04b9 }, { 0x04ba, 0x04bb }, { 0x04bc, 0x04bd }, { 0x04be, 0x04bf }, { 0x04c1, 0x04c2 }, { 0x04c3, 0x04c4 }, { 0x04c5, 0x04c6 },
        -:  589:            { 0x04c7, 0x04c8 }, { 0x04c9, 0x04ca }, { 0x04cb, 0x04cc }, { 0x04cd, 0x04ce }, { 0x04d0, 0x04d1 }, { 0x04d2, 0x04d3 }, { 0x04d4, 0x04d5 }, { 0x04d6, 0x04d7 },
        -:  590:            { 0x04d8, 0x04d9 }, { 0x04da, 0x04db }, { 0x04dc, 0x04dd }, { 0x04de, 0x04df }, { 0x04e0, 0x04e1 }, { 0x04e2, 0x04e3 }, { 0x04e4, 0x04e5 }, { 0x04e6, 0x04e7 },
        -:  591:            { 0x04e8, 0x04e9 }, { 0x04ea, 0x04eb }, { 0x04ec, 0x04ed }, { 0x04ee, 0x04ef }, { 0x04f0, 0x04f1 }, { 0x04f2, 0x04f3 }, { 0x04f4, 0x04f5 }, { 0x04f8, 0x04f9 },
        -:  592:            { 0x0500, 0x0501 }, { 0x0502, 0x0503 }, { 0x0504, 0x0505 }, { 0x0506, 0x0507 }, { 0x0508, 0x0509 }, { 0x050a, 0x050b }, { 0x050c, 0x050d }, { 0x050e, 0x050f },
        -:  593:            { 0x1e00, 0x1e01 }, { 0x1e02, 0x1e03 }, { 0x1e04, 0x1e05 }, { 0x1e06, 0x1e07 }, { 0x1e08, 0x1e09 }, { 0x1e0a, 0x1e0b }, { 0x1e0c, 0x1e0d }, { 0x1e0e, 0x1e0f },
        -:  594:            { 0x1e10, 0x1e11 }, { 0x1e12, 0x1e13 }, { 0x1e14, 0x1e15 }, { 0x1e16, 0x1e17 }, { 0x1e18, 0x1e19 }, { 0x1e1a, 0x1e1b }, { 0x1e1c, 0x1e1d }, { 0x1e1e, 0x1e1f },
        -:  595:            { 0x1e20, 0x1e21 }, { 0x1e22, 0x1e23 }, { 0x1e24, 0x1e25 }, { 0x1e26, 0x1e27 }, { 0x1e28, 0x1e29 }, { 0x1e2a, 0x1e2b }, { 0x1e2c, 0x1e2d }, { 0x1e2e, 0x1e2f },
        -:  596:            { 0x1e30, 0x1e31 }, { 0x1e32, 0x1e33 }, { 0x1e34, 0x1e35 }, { 0x1e36, 0x1e37 }, { 0x1e38, 0x1e39 }, { 0x1e3a, 0x1e3b }, { 0x1e3c, 0x1e3d }, { 0x1e3e, 0x1e3f },
        -:  597:            { 0x1e40, 0x1e41 }, { 0x1e42, 0x1e43 }, { 0x1e44, 0x1e45 }, { 0x1e46, 0x1e47 }, { 0x1e48, 0x1e49 }, { 0x1e4a, 0x1e4b }, { 0x1e4c, 0x1e4d }, { 0x1e4e, 0x1e4f },
        -:  598:            { 0x1e50, 0x1e51 }, { 0x1e52, 0x1e53 }, { 0x1e54, 0x1e55 }, { 0x1e56, 0x1e57 }, { 0x1e58, 0x1e59 }, { 0x1e5a, 0x1e5b }, { 0x1e5c, 0x1e5d }, { 0x1e5e, 0x1e5f },
        -:  599:            { 0x1e60, 0x1e61 }, { 0x1e62, 0x1e63 }, { 0x1e64, 0x1e65 }, { 0x1e66, 0x1e67 }, { 0x1e68, 0x1e69 }, { 0x1e6a, 0x1e6b }, { 0x1e6c, 0x1e6d }, { 0x1e6e, 0x1e6f },
        -:  600:            { 0x1e70, 0x1e71 }, { 0x1e72, 0x1e73 }, { 0x1e74, 0x1e75 }, { 0x1e76, 0x1e77 }, { 0x1e78, 0x1e79 }, { 0x1e7a, 0x1e7b }, { 0x1e7c, 0x1e7d }, { 0x1e7e, 0x1e7f },
        -:  601:            { 0x1e80, 0x1e81 }, { 0x1e82, 0x1e83 }, { 0x1e84, 0x1e85 }, { 0x1e86, 0x1e87 }, { 0x1e88, 0x1e89 }, { 0x1e8a, 0x1e8b }, { 0x1e8c, 0x1e8d }, { 0x1e8e, 0x1e8f },
        -:  602:            { 0x1e90, 0x1e91 }, { 0x1e92, 0x1e93 }, { 0x1e94, 0x1e95 }, { 0x1e9b, 0x1e61 }, { 0x1ea0, 0x1ea1 }, { 0x1ea2, 0x1ea3 }, { 0x1ea4, 0x1ea5 }, { 0x1ea6, 0x1ea7 },
        -:  603:            { 0x1ea8, 0x1ea9 }, { 0x1eaa, 0x1eab }, { 0x1eac, 0x1ead }, { 0x1eae, 0x1eaf }, { 0x1eb0, 0x1eb1 }, { 0x1eb2, 0x1eb3 }, { 0x1eb4, 0x1eb5 }, { 0x1eb6, 0x1eb7 },
        -:  604:            { 0x1eb8, 0x1eb9 }, { 0x1eba, 0x1ebb }, { 0x1ebc, 0x1ebd }, { 0x1ebe, 0x1ebf }, { 0x1ec0, 0x1ec1 }, { 0x1ec2, 0x1ec3 }, { 0x1ec4, 0x1ec5 }, { 0x1ec6, 0x1ec7 },
        -:  605:            { 0x1ec8, 0x1ec9 }, { 0x1eca, 0x1ecb }, { 0x1ecc, 0x1ecd }, { 0x1ece, 0x1ecf }, { 0x1ed0, 0x1ed1 }, { 0x1ed2, 0x1ed3 }, { 0x1ed4, 0x1ed5 }, { 0x1ed6, 0x1ed7 },
        -:  606:            { 0x1ed8, 0x1ed9 }, { 0x1eda, 0x1edb }, { 0x1edc, 0x1edd }, { 0x1ede, 0x1edf }, { 0x1ee0, 0x1ee1 }, { 0x1ee2, 0x1ee3 }, { 0x1ee4, 0x1ee5 }, { 0x1ee6, 0x1ee7 },
        -:  607:            { 0x1ee8, 0x1ee9 }, { 0x1eea, 0x1eeb }, { 0x1eec, 0x1eed }, { 0x1eee, 0x1eef }, { 0x1ef0, 0x1ef1 }, { 0x1ef2, 0x1ef3 }, { 0x1ef4, 0x1ef5 }, { 0x1ef6, 0x1ef7 },
        -:  608:            { 0x1ef8, 0x1ef9 }, { 0x1f59, 0x1f51 }, { 0x1f5b, 0x1f53 }, { 0x1f5d, 0x1f55 }, { 0x1f5f, 0x1f57 }, { 0x1fb8, 0x1fb0 }, { 0x1fb9, 0x1fb1 }, { 0x1fba, 0x1f70 },
        -:  609:            { 0x1fbb, 0x1f71 }, { 0x1fbe, 0x03b9 }, { 0x1fd8, 0x1fd0 }, { 0x1fd9, 0x1fd1 }, { 0x1fda, 0x1f76 }, { 0x1fdb, 0x1f77 }, { 0x1fe8, 0x1fe0 }, { 0x1fe9, 0x1fe1 },
        -:  610:            { 0x1fea, 0x1f7a }, { 0x1feb, 0x1f7b }, { 0x1fec, 0x1fe5 }, { 0x1ff8, 0x1f78 }, { 0x1ff9, 0x1f79 }, { 0x1ffa, 0x1f7c }, { 0x1ffb, 0x1f7d }, { 0x2126, 0x03c9 },
        -:  611:            { 0x212a, 0x006b }, { 0x212b, 0x00e5 },
        -:  612:        };
        -:  613:
        -:  614:        /* This maps single codepoint to two codepoints. */
        -:  615:        static const struct {
        -:  616:            int src_codepoint;
        -:  617:            int dest_codepoint0;
        -:  618:            int dest_codepoint1;
        -:  619:        } double_map[] = {
        -:  620:            { 0x00df, 0x0073, 0x0073 }, { 0x0130, 0x0069, 0x0307 }, { 0x0149, 0x02bc, 0x006e }, { 0x01f0, 0x006a, 0x030c }, { 0x0587, 0x0565, 0x0582 }, { 0x1e96, 0x0068, 0x0331 },
        -:  621:            { 0x1e97, 0x0074, 0x0308 }, { 0x1e98, 0x0077, 0x030a }, { 0x1e99, 0x0079, 0x030a }, { 0x1e9a, 0x0061, 0x02be }, { 0x1f50, 0x03c5, 0x0313 }, { 0x1f80, 0x1f00, 0x03b9 },
        -:  622:            { 0x1f81, 0x1f01, 0x03b9 }, { 0x1f82, 0x1f02, 0x03b9 }, { 0x1f83, 0x1f03, 0x03b9 }, { 0x1f84, 0x1f04, 0x03b9 }, { 0x1f85, 0x1f05, 0x03b9 }, { 0x1f86, 0x1f06, 0x03b9 },
        -:  623:            { 0x1f87, 0x1f07, 0x03b9 }, { 0x1f88, 0x1f00, 0x03b9 }, { 0x1f89, 0x1f01, 0x03b9 }, { 0x1f8a, 0x1f02, 0x03b9 }, { 0x1f8b, 0x1f03, 0x03b9 }, { 0x1f8c, 0x1f04, 0x03b9 },
        -:  624:            { 0x1f8d, 0x1f05, 0x03b9 }, { 0x1f8e, 0x1f06, 0x03b9 }, { 0x1f8f, 0x1f07, 0x03b9 }, { 0x1f90, 0x1f20, 0x03b9 }, { 0x1f91, 0x1f21, 0x03b9 }, { 0x1f92, 0x1f22, 0x03b9 },
        -:  625:            { 0x1f93, 0x1f23, 0x03b9 }, { 0x1f94, 0x1f24, 0x03b9 }, { 0x1f95, 0x1f25, 0x03b9 }, { 0x1f96, 0x1f26, 0x03b9 }, { 0x1f97, 0x1f27, 0x03b9 }, { 0x1f98, 0x1f20, 0x03b9 },
        -:  626:            { 0x1f99, 0x1f21, 0x03b9 }, { 0x1f9a, 0x1f22, 0x03b9 }, { 0x1f9b, 0x1f23, 0x03b9 }, { 0x1f9c, 0x1f24, 0x03b9 }, { 0x1f9d, 0x1f25, 0x03b9 }, { 0x1f9e, 0x1f26, 0x03b9 },
        -:  627:            { 0x1f9f, 0x1f27, 0x03b9 }, { 0x1fa0, 0x1f60, 0x03b9 }, { 0x1fa1, 0x1f61, 0x03b9 }, { 0x1fa2, 0x1f62, 0x03b9 }, { 0x1fa3, 0x1f63, 0x03b9 }, { 0x1fa4, 0x1f64, 0x03b9 },
        -:  628:            { 0x1fa5, 0x1f65, 0x03b9 }, { 0x1fa6, 0x1f66, 0x03b9 }, { 0x1fa7, 0x1f67, 0x03b9 }, { 0x1fa8, 0x1f60, 0x03b9 }, { 0x1fa9, 0x1f61, 0x03b9 }, { 0x1faa, 0x1f62, 0x03b9 },
        -:  629:            { 0x1fab, 0x1f63, 0x03b9 }, { 0x1fac, 0x1f64, 0x03b9 }, { 0x1fad, 0x1f65, 0x03b9 }, { 0x1fae, 0x1f66, 0x03b9 }, { 0x1faf, 0x1f67, 0x03b9 }, { 0x1fb2, 0x1f70, 0x03b9 },
        -:  630:            { 0x1fb3, 0x03b1, 0x03b9 }, { 0x1fb4, 0x03ac, 0x03b9 }, { 0x1fb6, 0x03b1, 0x0342 }, { 0x1fbc, 0x03b1, 0x03b9 }, { 0x1fc2, 0x1f74, 0x03b9 }, { 0x1fc3, 0x03b7, 0x03b9 },
        -:  631:            { 0x1fc4, 0x03ae, 0x03b9 }, { 0x1fc6, 0x03b7, 0x0342 }, { 0x1fcc, 0x03b7, 0x03b9 }, { 0x1fd6, 0x03b9, 0x0342 }, { 0x1fe4, 0x03c1, 0x0313 }, { 0x1fe6, 0x03c5, 0x0342 },
        -:  632:            { 0x1ff2, 0x1f7c, 0x03b9 }, { 0x1ff3, 0x03c9, 0x03b9 }, { 0x1ff4, 0x03ce, 0x03b9 }, { 0x1ff6, 0x03c9, 0x0342 }, { 0x1ffc, 0x03c9, 0x03b9 }, { 0xfb00, 0x0066, 0x0066 },
        -:  633:            { 0xfb01, 0x0066, 0x0069 }, { 0xfb02, 0x0066, 0x006c }, { 0xfb05, 0x0073, 0x0074 }, { 0xfb06, 0x0073, 0x0074 }, { 0xfb13, 0x0574, 0x0576 }, { 0xfb14, 0x0574, 0x0565 },
        -:  634:            { 0xfb15, 0x0574, 0x056b }, { 0xfb16, 0x057e, 0x0576 }, { 0xfb17, 0x0574, 0x056d }
        -:  635:        };
        -:  636:
        -:  637:        /* This maps single codepoint to three codepoints. */
        -:  638:        static const struct {
        -:  639:            int src_codepoint;
        -:  640:            int dest_codepoint0;
        -:  641:            int dest_codepoint1;
        -:  642:            int dest_codepoint2;
        -:  643:        } triple_map[] = {
        -:  644:            { 0x0390, 0x03b9, 0x0308, 0x0301 }, { 0x03b0, 0x03c5, 0x0308, 0x0301 }, { 0x1f52, 0x03c5, 0x0313, 0x0300 }, { 0x1f54, 0x03c5, 0x0313, 0x0301 },
        -:  645:            { 0x1f56, 0x03c5, 0x0313, 0x0342 }, { 0x1fb7, 0x03b1, 0x0342, 0x03b9 }, { 0x1fc7, 0x03b7, 0x0342, 0x03b9 }, { 0x1fd2, 0x03b9, 0x0308, 0x0300 },
        -:  646:            { 0x1fd3, 0x03b9, 0x0308, 0x0301 }, { 0x1fd7, 0x03b9, 0x0308, 0x0342 }, { 0x1fe2, 0x03c5, 0x0308, 0x0300 }, { 0x1fe3, 0x03c5, 0x0308, 0x0301 },
        -:  647:            { 0x1fe7, 0x03c5, 0x0308, 0x0342 }, { 0x1ff7, 0x03c9, 0x0342, 0x03b9 }, { 0xfb03, 0x0066, 0x0066, 0x0069 }, { 0xfb04, 0x0066, 0x0066, 0x006c }
        -:  648:        };
        -:  649:
        -:  650:        int i;
        -:  651:
        -:  652:        /* Fast path for ASCII characters. */
    #####:  653:        if(codepoint <= 0x7f) {
    #####:  654:            info->codepoints[0] = codepoint;
    #####:  655:            if(ISUPPER_(codepoint))
    #####:  656:                info->codepoints[0] += 'a' - 'A';
    #####:  657:            info->n_codepoints = 1;
    #####:  658:            return;
        -:  659:        }
        -:  660:
    #####:  661:        for(i = 0; i < SIZEOF_ARRAY(range_map); i++) {
    #####:  662:            if(range_map[i].min_codepoint <= codepoint && codepoint <= range_map[i].max_codepoint) {
    #####:  663:                info->codepoints[0] = codepoint + range_map[i].offset;
    #####:  664:                info->n_codepoints = 1;
    #####:  665:                return;
        -:  666:            }
        -:  667:        }
        -:  668:
    #####:  669:        for(i = 0; i < SIZEOF_ARRAY(single_map); i++) {
    #####:  670:            if(codepoint == single_map[i].src_codepoint) {
    #####:  671:                info->codepoints[0] = single_map[i].dest_codepoint;
    #####:  672:                info->n_codepoints = 1;
    #####:  673:                return;
        -:  674:            }
        -:  675:        }
        -:  676:
    #####:  677:        for(i = 0; i < SIZEOF_ARRAY(double_map); i++) {
    #####:  678:            if(codepoint == double_map[i].src_codepoint) {
    #####:  679:                info->codepoints[0] = double_map[i].dest_codepoint0;
    #####:  680:                info->codepoints[1] = double_map[i].dest_codepoint1;
    #####:  681:                info->n_codepoints = 2;
    #####:  682:                return;
        -:  683:            }
        -:  684:        }
        -:  685:
    #####:  686:        for(i = 0; i < SIZEOF_ARRAY(triple_map); i++) {
    #####:  687:            if(codepoint == triple_map[i].src_codepoint) {
    #####:  688:                info->codepoints[0] = triple_map[i].dest_codepoint0;
    #####:  689:                info->codepoints[1] = triple_map[i].dest_codepoint1;
    #####:  690:                info->codepoints[2] = triple_map[i].dest_codepoint2;
    #####:  691:                info->n_codepoints = 3;
    #####:  692:                return;
        -:  693:            }
        -:  694:        }
        -:  695:
    #####:  696:        info->codepoints[0] = codepoint;
    #####:  697:        info->n_codepoints = 1;
        -:  698:    }
        -:  699:#endif
        -:  700:
        -:  701:
        -:  702:#if defined MD4C_USE_UTF16
        -:  703:    #define IS_UTF16_SURROGATE_HI(word)     (((WORD)(word) & 0xfc00) == 0xd800)
        -:  704:    #define IS_UTF16_SURROGATE_LO(word)     (((WORD)(word) & 0xfc00) == 0xdc00)
        -:  705:    #define UTF16_DECODE_SURROGATE(hi, lo)  (0x10000 + ((((unsigned)(hi) & 0x3ff) << 10) | (((unsigned)(lo) & 0x3ff) << 0)))
        -:  706:
        -:  707:    static int
        -:  708:    md_decode_utf16le__(const CHAR* str, SZ str_size, SZ* p_size)
        -:  709:    {
        -:  710:        if(IS_UTF16_SURROGATE_HI(str[0])) {
        -:  711:            if(1 < str_size && IS_UTF16_SURROGATE_LO(str[1])) {
        -:  712:                if(p_size != NULL)
        -:  713:                    *p_size = 2;
        -:  714:                return UTF16_DECODE_SURROGATE(str[0], str[1]);
        -:  715:            }
        -:  716:        }
        -:  717:
        -:  718:        if(p_size != NULL)
        -:  719:            *p_size = 1;
        -:  720:        return str[0];
        -:  721:    }
        -:  722:
        -:  723:    static int
        -:  724:    md_decode_utf16le_before__(MD_CTX* ctx, OFF off)
        -:  725:    {
        -:  726:        if(off > 2 && IS_UTF16_SURROGATE_HI(CH(off-2)) && IS_UTF16_SURROGATE_LO(CH(off-1)))
        -:  727:            return UTF16_DECODE_SURROGATE(CH(off-2), CH(off-1));
        -:  728:
        -:  729:        return CH(off);
        -:  730:    }
        -:  731:
        -:  732:    /* No whitespace uses surrogates, so no decoding needed here. */
        -:  733:    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)
        -:  734:    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(CH(off))
        -:  735:    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(CH((off)-1))
        -:  736:
        -:  737:    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf16le__(STR(off), ctx->size - (off), NULL))
        -:  738:    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf16le_before__(ctx, off))
        -:  739:
        -:  740:    static inline int
        -:  741:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)
        -:  742:    {
        -:  743:        return md_decode_utf16le__(str+off, str_size-off, p_char_size);
        -:  744:    }
        -:  745:#elif defined MD4C_USE_UTF8
        -:  746:    #define IS_UTF8_LEAD1(byte)     ((unsigned char)(byte) <= 0x7f)
        -:  747:    #define IS_UTF8_LEAD2(byte)     (((unsigned char)(byte) & 0xe0) == 0xc0)
        -:  748:    #define IS_UTF8_LEAD3(byte)     (((unsigned char)(byte) & 0xf0) == 0xe0)
        -:  749:    #define IS_UTF8_LEAD4(byte)     (((unsigned char)(byte) & 0xf8) == 0xf0)
        -:  750:    #define IS_UTF8_TAIL(byte)      (((unsigned char)(byte) & 0xc0) == 0x80)
        -:  751:
        -:  752:    static int
    #####:  753:    md_decode_utf8__(const CHAR* str, SZ str_size, SZ* p_size)
        -:  754:    {
    #####:  755:        if(!IS_UTF8_LEAD1(str[0])) {
    #####:  756:            if(IS_UTF8_LEAD2(str[0])) {
    #####:  757:                if(1 < str_size && IS_UTF8_TAIL(str[1])) {
    #####:  758:                    if(p_size != NULL)
    #####:  759:                        *p_size = 2;
        -:  760:
    #####:  761:                    return (((unsigned int)str[0] & 0x1f) << 6) |
    #####:  762:                           (((unsigned int)str[1] & 0x3f) << 0);
        -:  763:                }
    #####:  764:            } else if(IS_UTF8_LEAD3(str[0])) {
    #####:  765:                if(2 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2])) {
    #####:  766:                    if(p_size != NULL)
    #####:  767:                        *p_size = 3;
        -:  768:
    #####:  769:                    return (((unsigned int)str[0] & 0x0f) << 12) |
    #####:  770:                           (((unsigned int)str[1] & 0x3f) << 6) |
    #####:  771:                           (((unsigned int)str[2] & 0x3f) << 0);
        -:  772:                }
    #####:  773:            } else if(IS_UTF8_LEAD4(str[0])) {
    #####:  774:                if(3 < str_size && IS_UTF8_TAIL(str[1]) && IS_UTF8_TAIL(str[2]) && IS_UTF8_TAIL(str[3])) {
    #####:  775:                    if(p_size != NULL)
    #####:  776:                        *p_size = 4;
        -:  777:
    #####:  778:                    return (((unsigned int)str[0] & 0x07) << 18) |
    #####:  779:                           (((unsigned int)str[1] & 0x3f) << 12) |
    #####:  780:                           (((unsigned int)str[2] & 0x3f) << 6) |
    #####:  781:                           (((unsigned int)str[3] & 0x3f) << 0);
        -:  782:                }
        -:  783:            }
        -:  784:        }
        -:  785:
    #####:  786:        if(p_size != NULL)
    #####:  787:            *p_size = 1;
    #####:  788:        return str[0];
        -:  789:    }
        -:  790:
        -:  791:    static int
    #####:  792:    md_decode_utf8_before__(MD_CTX* ctx, OFF off)
        -:  793:    {
    #####:  794:        if(!IS_UTF8_LEAD1(CH(off-1))) {
    #####:  795:            if(off > 1 && IS_UTF8_LEAD2(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  796:                return (((unsigned int)CH(off-2) & 0x1f) << 6) |
    #####:  797:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  798:
    #####:  799:            if(off > 2 && IS_UTF8_LEAD3(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  800:                return (((unsigned int)CH(off-3) & 0x0f) << 12) |
    #####:  801:                       (((unsigned int)CH(off-2) & 0x3f) << 6) |
    #####:  802:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  803:
    #####:  804:            if(off > 3 && IS_UTF8_LEAD4(CH(off-4)) && IS_UTF8_TAIL(CH(off-3)) && IS_UTF8_TAIL(CH(off-2)) && IS_UTF8_TAIL(CH(off-1)))
    #####:  805:                return (((unsigned int)CH(off-4) & 0x07) << 18) |
    #####:  806:                       (((unsigned int)CH(off-3) & 0x3f) << 12) |
    #####:  807:                       (((unsigned int)CH(off-2) & 0x3f) << 6) |
    #####:  808:                       (((unsigned int)CH(off-1) & 0x3f) << 0);
        -:  809:        }
        -:  810:
    #####:  811:        return CH(off-1);
        -:  812:    }
        -:  813:
        -:  814:    #define ISUNICODEWHITESPACE_(codepoint) md_is_unicode_whitespace__(codepoint)
        -:  815:    #define ISUNICODEWHITESPACE(off)        md_is_unicode_whitespace__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))
        -:  816:    #define ISUNICODEWHITESPACEBEFORE(off)  md_is_unicode_whitespace__(md_decode_utf8_before__(ctx, off))
        -:  817:
        -:  818:    #define ISUNICODEPUNCT(off)             md_is_unicode_punct__(md_decode_utf8__(STR(off), ctx->size - (off), NULL))
        -:  819:    #define ISUNICODEPUNCTBEFORE(off)       md_is_unicode_punct__(md_decode_utf8_before__(ctx, off))
        -:  820:
        -:  821:    static inline int
        -:  822:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_char_size)
        -:  823:    {
    #####:  824:        return md_decode_utf8__(str+off, str_size-off, p_char_size);
        -:  825:    }
        -:  826:#else
        -:  827:    #define ISUNICODEWHITESPACE_(codepoint) ISWHITESPACE_(codepoint)
        -:  828:    #define ISUNICODEWHITESPACE(off)        ISWHITESPACE(off)
        -:  829:    #define ISUNICODEWHITESPACEBEFORE(off)  ISWHITESPACE((off)-1)
        -:  830:
        -:  831:    #define ISUNICODEPUNCT(off)             ISPUNCT(off)
        -:  832:    #define ISUNICODEPUNCTBEFORE(off)       ISPUNCT((off)-1)
        -:  833:
        -:  834:    static inline void
        -:  835:    md_get_unicode_fold_info(int codepoint, MD_UNICODE_FOLD_INFO* info)
        -:  836:    {
        -:  837:        info->codepoints[0] = codepoint;
        -:  838:        if(ISUPPER_(codepoint))
        -:  839:            info->codepoints[0] += 'a' - 'A';
        -:  840:        info->n_codepoints = 1;
        -:  841:    }
        -:  842:
        -:  843:    static inline int
        -:  844:    md_decode_unicode(const CHAR* str, OFF off, SZ str_size, SZ* p_size)
        -:  845:    {
        -:  846:        *p_size = 1;
        -:  847:        return str[off];
        -:  848:    }
        -:  849:#endif
        -:  850:
        -:  851:
        -:  852:/*************************************
        -:  853: ***  Helper string manipulations  ***
        -:  854: *************************************/
        -:  855:
        -:  856:/* Fill buffer with copy of the string between 'beg' and 'end' but replace any
        -:  857: * line breaks with given replacement character.
        -:  858: *
        -:  859: * NOTE: Caller is responsible to make sure the buffer is large enough.
        -:  860: * (Given the output is always shorter then input, (end - beg) is good idea
        -:  861: * what the caller should allocate.)
        -:  862: */
        -:  863:static void
        -:  864:md_merge_lines(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,
        -:  865:               CHAR line_break_replacement_char, CHAR* buffer, SZ* p_size)
        -:  866:{
        -:  867:    CHAR* ptr = buffer;
        -:  868:    int line_index = 0;
        -:  869:    OFF off = beg;
        -:  870:
        -:  871:    while(1) {
    #####:  872:        const MD_LINE* line = &lines[line_index];
    #####:  873:        OFF line_end = line->end;
    #####:  874:        if(end < line_end)
    #####:  875:            line_end = end;
        -:  876:
    #####:  877:        while(off < line_end) {
    #####:  878:            *ptr = CH(off);
    #####:  879:            ptr++;
    #####:  880:            off++;
        -:  881:        }
        -:  882:
    #####:  883:        if(off >= end) {
    #####:  884:            *p_size = ptr - buffer;
        -:  885:            return;
        -:  886:        }
        -:  887:
    #####:  888:        *ptr = line_break_replacement_char;
    #####:  889:        ptr++;
        -:  890:
    #####:  891:        line_index++;
    #####:  892:        off = lines[line_index].beg;
        -:  893:    }
        -:  894:}
        -:  895:
        -:  896:/* Wrapper of md_merge_lines() which allocates new buffer for the output string.
        -:  897: */
        -:  898:static int
    #####:  899:md_merge_lines_alloc(MD_CTX* ctx, OFF beg, OFF end, const MD_LINE* lines, int n_lines,
        -:  900:                    CHAR line_break_replacement_char, CHAR** p_str, SZ* p_size)
        -:  901:{
        -:  902:    CHAR* buffer;
        -:  903:
    #####:  904:    buffer = (CHAR*) malloc(sizeof(CHAR) * (end - beg));
    #####:  905:    if(buffer == NULL) {
    #####:  906:        MD_LOG("malloc() failed.");
        -:  907:        return -1;
        -:  908:    }
        -:  909:
    #####:  910:    md_merge_lines(ctx, beg, end, lines, n_lines,
        -:  911:                line_break_replacement_char, buffer, p_size);
        -:  912:
    #####:  913:    *p_str = buffer;
    #####:  914:    return 0;
        -:  915:}
        -:  916:
        -:  917:static OFF
    #####:  918:md_skip_unicode_whitespace(const CHAR* label, OFF off, SZ size)
        -:  919:{
    #####:  920:    SZ char_size;
        -:  921:    int codepoint;
        -:  922:
    #####:  923:    while(off < size) {
    #####:  924:        codepoint = md_decode_unicode(label, off, size, &char_size);
    #####:  925:        if(!ISUNICODEWHITESPACE_(codepoint)  &&  !ISNEWLINE_(label[off]))
        -:  926:            break;
    #####:  927:        off += char_size;
        -:  928:    }
        -:  929:
    #####:  930:    return off;
        -:  931:}
        -:  932:
        -:  933:
        -:  934:/******************************
        -:  935: ***  Recognizing raw HTML  ***
        -:  936: ******************************/
        -:  937:
        -:  938:/* md_is_html_tag() may be called when processing inlines (inline raw HTML)
        -:  939: * or when breaking document to blocks (checking for start of HTML block type 7).
        -:  940: *
        -:  941: * When breaking document to blocks, we do not yet know line boundaries, but
        -:  942: * in that case the whole tag has to live on a single line. We distinguish this
        -:  943: * by n_lines == 0.
        -:  944: */
        -:  945:static int
    #####:  946:md_is_html_tag(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -:  947:{
        -:  948:    int attr_state;
    #####:  949:    OFF off = beg;
    #####:  950:    OFF line_end = (n_lines > 0) ? lines[0].end : ctx->size;
    #####:  951:    int i = 0;
        -:  952:
    #####:  953:    MD_ASSERT(CH(beg) == _T('<'));
        -:  954:
    #####:  955:    if(off + 1 >= line_end)
        -:  956:        return FALSE;
    #####:  957:    off++;
        -:  958:
        -:  959:    /* For parsing attributes, we need a little state automaton below.
        -:  960:     * State -1: no attributes are allowed.
        -:  961:     * State 0: attribute could follow after some whitespace.
        -:  962:     * State 1: after a whitespace (attribute name may follow).
        -:  963:     * State 2: after attribute name ('=' MAY follow).
        -:  964:     * State 3: after '=' (value specification MUST follow).
        -:  965:     * State 41: in middle of unquoted attribute value.
        -:  966:     * State 42: in middle of single-quoted attribute value.
        -:  967:     * State 43: in middle of double-quoted attribute value.
        -:  968:     */
    #####:  969:    attr_state = 0;
        -:  970:
    #####:  971:    if(CH(off) == _T('/')) {
        -:  972:        /* Closer tag "</ ... >". No attributes may be present. */
    #####:  973:        attr_state = -1;
    #####:  974:        off++;
        -:  975:    }
        -:  976:
        -:  977:    /* Tag name */
    #####:  978:    if(off >= line_end  ||  !ISALPHA(off))
        -:  979:        return FALSE;
    #####:  980:    off++;
    #####:  981:    while(off < line_end  &&  (ISALNUM(off)  ||  CH(off) == _T('-')))
    #####:  982:        off++;
        -:  983:
        -:  984:    /* (Optional) attributes (if not closer), (optional) '/' (if not closer)
        -:  985:     * and final '>'. */
        -:  986:    while(1) {
    #####:  987:        while(off < line_end  &&  !ISNEWLINE(off)) {
    #####:  988:            if(attr_state > 40) {
    #####:  989:                if(attr_state == 41 && (ISBLANK(off) || ISANYOF(off, _T("\"'=<>`")))) {
    #####:  990:                    attr_state = 0;
    #####:  991:                    off--;  /* Put the char back for re-inspection in the new state. */
    #####:  992:                } else if(attr_state == 42 && CH(off) == _T('\'')) {
        -:  993:                    attr_state = 0;
    #####:  994:                } else if(attr_state == 43 && CH(off) == _T('"')) {
    #####:  995:                    attr_state = 0;
        -:  996:                }
    #####:  997:                off++;
    #####:  998:            } else if(ISWHITESPACE(off)) {
    #####:  999:                if(attr_state == 0)
    #####: 1000:                    attr_state = 1;
    #####: 1001:                off++;
    #####: 1002:            } else if(attr_state <= 2 && CH(off) == _T('>')) {
        -: 1003:                /* End. */
        -: 1004:                goto done;
    #####: 1005:            } else if(attr_state <= 2 && CH(off) == _T('/') && off+1 < line_end && CH(off+1) == _T('>')) {
        -: 1006:                /* End with digraph '/>' */
        -: 1007:                off++;
        -: 1008:                goto done;
    #####: 1009:            } else if((attr_state == 1 || attr_state == 2) && (ISALPHA(off) || CH(off) == _T('_') || CH(off) == _T(':'))) {
    #####: 1010:                off++;
        -: 1011:                /* Attribute name */
    #####: 1012:                while(off < line_end && (ISALNUM(off) || ISANYOF(off, _T("_.:-"))))
    #####: 1013:                    off++;
        -: 1014:                attr_state = 2;
    #####: 1015:            } else if(attr_state == 2 && CH(off) == _T('=')) {
        -: 1016:                /* Attribute assignment sign */
    #####: 1017:                off++;
    #####: 1018:                attr_state = 3;
    #####: 1019:            } else if(attr_state == 3) {
        -: 1020:                /* Expecting start of attribute value. */
    #####: 1021:                if(CH(off) == _T('"'))
        -: 1022:                    attr_state = 43;
    #####: 1023:                else if(CH(off) == _T('\''))
        -: 1024:                    attr_state = 42;
    #####: 1025:                else if(!ISANYOF(off, _T("\"'=<>`"))  &&  !ISNEWLINE(off))
        -: 1026:                    attr_state = 41;
        -: 1027:                else
        -: 1028:                    return FALSE;
    #####: 1029:                off++;
        -: 1030:            } else {
        -: 1031:                /* Anything unexpected. */
        -: 1032:                return FALSE;
        -: 1033:            }
        -: 1034:        }
        -: 1035:
        -: 1036:        /* We have to be on a single line. See definition of start condition
        -: 1037:         * of HTML block, type 7. */
    #####: 1038:        if(n_lines == 0)
        -: 1039:            return FALSE;
        -: 1040:
    #####: 1041:        i++;
    #####: 1042:        if(i >= n_lines)
        -: 1043:            return FALSE;
        -: 1044:
    #####: 1045:        off = lines[i].beg;
    #####: 1046:        line_end = lines[i].end;
        -: 1047:
    #####: 1048:        if(attr_state == 0  ||  attr_state == 41)
    #####: 1049:            attr_state = 1;
        -: 1050:
    #####: 1051:        if(off >= max_end)
        -: 1052:            return FALSE;
        -: 1053:    }
        -: 1054:
    #####: 1055:done:
    #####: 1056:    if(off >= max_end)
        -: 1057:        return FALSE;
        -: 1058:
    #####: 1059:    *p_end = off+1;
        -: 1060:    return TRUE;
        -: 1061:}
        -: 1062:
        -: 1063:static int
    #####: 1064:md_is_html_comment(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1065:{
    #####: 1066:    OFF off = beg;
    #####: 1067:    int i = 0;
        -: 1068:
    #####: 1069:    MD_ASSERT(CH(beg) == _T('<'));
        -: 1070:
    #####: 1071:    if(off + 4 >= lines[0].end)
        -: 1072:        return FALSE;
    #####: 1073:    if(CH(off+1) != _T('!')  ||  CH(off+2) != _T('-')  ||  CH(off+3) != _T('-'))
        -: 1074:        return FALSE;
    #####: 1075:    off += 4;
        -: 1076:
        -: 1077:    /* ">" and "->" must follow the opening. */
    #####: 1078:    if(off < lines[0].end  &&  CH(off) == _T('>'))
        -: 1079:        return FALSE;
    #####: 1080:    if(off+1 < lines[0].end  &&  CH(off) == _T('-')  &&  CH(off+1) == _T('>'))
        -: 1081:        return FALSE;
        -: 1082:
        -: 1083:    while(1) {
    #####: 1084:        while(off + 2 < lines[i].end) {
    #####: 1085:            if(CH(off) == _T('-')  &&  CH(off+1) == _T('-')) {
    #####: 1086:                if(CH(off+2) == _T('>')) {
        -: 1087:                    /* Success. */
    #####: 1088:                    off += 2;
        -: 1089:                    goto done;
        -: 1090:                } else {
        -: 1091:                    /* "--" is prohibited inside the comment. */
        -: 1092:                    return FALSE;
        -: 1093:                }
        -: 1094:            }
        -: 1095:
    #####: 1096:            off++;
        -: 1097:        }
        -: 1098:
    #####: 1099:        i++;
    #####: 1100:        if(i >= n_lines)
        -: 1101:            return FALSE;
        -: 1102:
    #####: 1103:        off = lines[i].beg;
        -: 1104:
    #####: 1105:        if(off >= max_end)
        -: 1106:            return FALSE;
        -: 1107:    }
        -: 1108:
    #####: 1109:done:
    #####: 1110:    if(off >= max_end)
        -: 1111:        return FALSE;
        -: 1112:
    #####: 1113:    *p_end = off+1;
        -: 1114:    return TRUE;
        -: 1115:}
        -: 1116:
        -: 1117:static int
    #####: 1118:md_is_html_processing_instruction(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1119:{
    #####: 1120:    OFF off = beg;
    #####: 1121:    int i = 0;
        -: 1122:
    #####: 1123:    MD_ASSERT(CH(beg) == _T('<'));
        -: 1124:
    #####: 1125:    if(off + 2 >= lines[0].end)
        -: 1126:        return FALSE;
    #####: 1127:    if(CH(off+1) != _T('?'))
        -: 1128:        return FALSE;
        -: 1129:    off += 2;
        -: 1130:
        -: 1131:    while(1) {
    #####: 1132:        while(off + 1 < lines[i].end) {
    #####: 1133:            if(CH(off) == _T('?')  &&  CH(off+1) == _T('>')) {
        -: 1134:                /* Success. */
    #####: 1135:                off++;
        -: 1136:                goto done;
        -: 1137:            }
        -: 1138:
        -: 1139:            off++;
        -: 1140:        }
        -: 1141:
    #####: 1142:        i++;
    #####: 1143:        if(i >= n_lines)
        -: 1144:            return FALSE;
        -: 1145:
    #####: 1146:        off = lines[i].beg;
    #####: 1147:        if(off >= max_end)
        -: 1148:            return FALSE;
        -: 1149:    }
        -: 1150:
    #####: 1151:done:
    #####: 1152:    if(off >= max_end)
        -: 1153:        return FALSE;
        -: 1154:
    #####: 1155:    *p_end = off+1;
        -: 1156:    return TRUE;
        -: 1157:}
        -: 1158:
        -: 1159:static int
    #####: 1160:md_is_html_declaration(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1161:{
    #####: 1162:    OFF off = beg;
    #####: 1163:    int i = 0;
        -: 1164:
    #####: 1165:    MD_ASSERT(CH(beg) == _T('<'));
        -: 1166:
    #####: 1167:    if(off + 2 >= lines[0].end)
        -: 1168:        return FALSE;
    #####: 1169:    if(CH(off+1) != _T('!'))
        -: 1170:        return FALSE;
    #####: 1171:    off += 2;
        -: 1172:
        -: 1173:    /* Declaration name. */
    #####: 1174:    if(off >= lines[0].end  ||  !ISALPHA(off))
        -: 1175:        return FALSE;
    #####: 1176:    off++;
    #####: 1177:    while(off < lines[0].end  &&  ISALPHA(off))
    #####: 1178:        off++;
    #####: 1179:    if(off < lines[0].end  &&  !ISWHITESPACE(off))
        -: 1180:        return FALSE;
        -: 1181:
        -: 1182:    while(1) {
    #####: 1183:        while(off < lines[i].end) {
    #####: 1184:            if(CH(off) == _T('>')) {
        -: 1185:                /* Success. */
        -: 1186:                goto done;
        -: 1187:            }
        -: 1188:
    #####: 1189:            off++;
        -: 1190:        }
        -: 1191:
    #####: 1192:        i++;
    #####: 1193:        if(i >= n_lines)
        -: 1194:            return FALSE;
        -: 1195:
    #####: 1196:        off = lines[i].beg;
    #####: 1197:        if(off >= max_end)
        -: 1198:            return FALSE;
        -: 1199:    }
        -: 1200:
    #####: 1201:done:
    #####: 1202:    if(off >= max_end)
        -: 1203:        return FALSE;
        -: 1204:
    #####: 1205:    *p_end = off+1;
        -: 1206:    return TRUE;
        -: 1207:}
        -: 1208:
        -: 1209:static int
    #####: 1210:md_is_html_cdata(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1211:{
        -: 1212:    static const CHAR open_str[] = _T("<![CDATA[");
        -: 1213:    static const SZ open_size = SIZEOF_ARRAY(open_str) - 1;
        -: 1214:
    #####: 1215:    OFF off = beg;
    #####: 1216:    int i = 0;
        -: 1217:
    #####: 1218:    if(off + open_size >= lines[0].end)
        -: 1219:        return FALSE;
    #####: 1220:    if(memcmp(STR(off), open_str, open_size) != 0)
        -: 1221:        return FALSE;
        -: 1222:    off += open_size;
        -: 1223:
        -: 1224:    while(1) {
    #####: 1225:        while(off + 2 < lines[i].end) {
    #####: 1226:            if(CH(off) == _T(']')  &&  CH(off+1) == _T(']')  &&  CH(off+2) == _T('>')) {
        -: 1227:                /* Success. */
    #####: 1228:                off += 2;
        -: 1229:                goto done;
        -: 1230:            }
        -: 1231:
    #####: 1232:            off++;
        -: 1233:        }
        -: 1234:
    #####: 1235:        i++;
    #####: 1236:        if(i >= n_lines)
        -: 1237:            return FALSE;
        -: 1238:
    #####: 1239:        off = lines[i].beg;
    #####: 1240:        if(off >= max_end)
        -: 1241:            return FALSE;
        -: 1242:    }
        -: 1243:
    #####: 1244:done:
    #####: 1245:    if(off >= max_end)
        -: 1246:        return FALSE;
        -: 1247:
    #####: 1248:    *p_end = off+1;
        -: 1249:    return TRUE;
        -: 1250:}
        -: 1251:
        -: 1252:static int
    #####: 1253:md_is_html_any(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF max_end, OFF* p_end)
        -: 1254:{
    #####: 1255:    if(md_is_html_tag(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1256:        return TRUE;
    #####: 1257:    if(md_is_html_comment(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1258:        return TRUE;
    #####: 1259:    if(md_is_html_processing_instruction(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1260:        return TRUE;
    #####: 1261:    if(md_is_html_declaration(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1262:        return TRUE;
    #####: 1263:    if(md_is_html_cdata(ctx, lines, n_lines, beg, max_end, p_end) == TRUE)
        -: 1264:        return TRUE;
        -: 1265:
    #####: 1266:    return FALSE;
        -: 1267:}
        -: 1268:
        -: 1269:
        -: 1270:/****************************
        -: 1271: ***  Recognizing Entity  ***
        -: 1272: ****************************/
        -: 1273:
        -: 1274:static int
    #####: 1275:md_is_hex_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1276:{
    #####: 1277:    OFF off = beg;
        -: 1278:
    #####: 1279:    while(off < max_end  &&  ISXDIGIT_(text[off])  &&  off - beg <= 8)
    #####: 1280:        off++;
        -: 1281:
    #####: 1282:    if(1 <= off - beg  &&  off - beg <= 8) {
    #####: 1283:        *p_end = off;
        -: 1284:        return TRUE;
        -: 1285:    } else {
        -: 1286:        return FALSE;
        -: 1287:    }
        -: 1288:}
        -: 1289:
        -: 1290:static int
        -: 1291:md_is_dec_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1292:{
        -: 1293:    OFF off = beg;
        -: 1294:
    #####: 1295:    while(off < max_end  &&  ISDIGIT_(text[off])  &&  off - beg <= 8)
    #####: 1296:        off++;
        -: 1297:
    #####: 1298:    if(1 <= off - beg  &&  off - beg <= 8) {
    #####: 1299:        *p_end = off;
        -: 1300:        return TRUE;
        -: 1301:    } else {
        -: 1302:        return FALSE;
        -: 1303:    }
        -: 1304:}
        -: 1305:
        -: 1306:static int
    #####: 1307:md_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1308:{
    #####: 1309:    OFF off = beg;
        -: 1310:
    #####: 1311:    if(off < max_end  &&  ISALPHA_(text[off]))
    #####: 1312:        off++;
        -: 1313:    else
        -: 1314:        return FALSE;
        -: 1315:
    #####: 1316:    while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48)
    #####: 1317:        off++;
        -: 1318:
    #####: 1319:    if(2 <= off - beg  &&  off - beg <= 48) {
    #####: 1320:        *p_end = off;
        -: 1321:        return TRUE;
        -: 1322:    } else {
        -: 1323:        return FALSE;
        -: 1324:    }
        -: 1325:}
        -: 1326:
        -: 1327:static int
    #####: 1328:md_is_entity_str(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end)
        -: 1329:{
        -: 1330:    int is_contents;
    #####: 1331:    OFF off = beg;
        -: 1332:
    #####: 1333:    MD_ASSERT(text[off] == _T('&'));
    #####: 1334:    off++;
        -: 1335:
    #####: 1336:    if(off+1 < max_end  &&  text[off] == _T('#')  &&  (text[off+1] == _T('x') || text[off+1] == _T('X')))
    #####: 1337:        is_contents = md_is_hex_entity_contents(ctx, text, off+2, max_end, &off);
    #####: 1338:    else if(off < max_end  &&  CH(off) == _T('#'))
    #####: 1339:        is_contents = md_is_dec_entity_contents(ctx, text, off+1, max_end, &off);
        -: 1340:    else
    #####: 1341:        is_contents = md_is_named_entity_contents(ctx, text, off, max_end, &off);
        -: 1342:
    #####: 1343:    if(is_contents  &&  off < max_end  &&  text[off] == _T(';')) {
    #####: 1344:        *p_end = off+1;
        -: 1345:        return TRUE;
        -: 1346:    } else {
        -: 1347:        return FALSE;
        -: 1348:    }
        -: 1349:}
        -: 1350:
        -: 1351:static inline int
        -: 1352:md_is_entity(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end)
        -: 1353:{
    #####: 1354:    return md_is_entity_str(ctx, ctx->text, beg, max_end, p_end);
        -: 1355:}
        -: 1356:
        -: 1357:
        -: 1358:/******************************
        -: 1359: ***  Attribute Management  ***
        -: 1360: ******************************/
        -: 1361:
        -: 1362:typedef struct MD_ATTRIBUTE_BUILD_tag MD_ATTRIBUTE_BUILD;
        -: 1363:struct MD_ATTRIBUTE_BUILD_tag {
        -: 1364:    CHAR* text;
        -: 1365:    MD_TEXTTYPE* substr_types;
        -: 1366:    OFF* substr_offsets;
        -: 1367:    int substr_count;
        -: 1368:    int substr_alloc;
        -: 1369:    MD_TEXTTYPE trivial_types[1];
        -: 1370:    OFF trivial_offsets[2];
        -: 1371:};
        -: 1372:
        -: 1373:
        -: 1374:#define MD_BUILD_ATTR_NO_ESCAPES    0x0001
        -: 1375:
        -: 1376:static int
    #####: 1377:md_build_attr_append_substr(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build,
        -: 1378:                            MD_TEXTTYPE type, OFF off)
        -: 1379:{
    #####: 1380:    if(build->substr_count >= build->substr_alloc) {
        -: 1381:        MD_TEXTTYPE* new_substr_types;
        -: 1382:        OFF* new_substr_offsets;
        -: 1383:
    #####: 1384:        build->substr_alloc = (build->substr_alloc == 0 ? 8 : build->substr_alloc * 2);
        -: 1385:
    #####: 1386:        new_substr_types = (MD_TEXTTYPE*) realloc(build->substr_types,
    #####: 1387:                                    build->substr_alloc * sizeof(MD_TEXTTYPE));
    #####: 1388:        if(new_substr_types == NULL) {
    #####: 1389:            MD_LOG("realloc() failed.");
        -: 1390:            return -1;
        -: 1391:        }
        -: 1392:        /* Note +1 to reserve space for final offset (== raw_size). */
    #####: 1393:        new_substr_offsets = (OFF*) realloc(build->substr_offsets,
    #####: 1394:                                    (build->substr_alloc+1) * sizeof(OFF));
    #####: 1395:        if(new_substr_offsets == NULL) {
    #####: 1396:            MD_LOG("realloc() failed.");
    #####: 1397:            free(new_substr_types);
        -: 1398:            return -1;
        -: 1399:        }
        -: 1400:
    #####: 1401:        build->substr_types = new_substr_types;
    #####: 1402:        build->substr_offsets = new_substr_offsets;
        -: 1403:    }
        -: 1404:
    #####: 1405:    build->substr_types[build->substr_count] = type;
    #####: 1406:    build->substr_offsets[build->substr_count] = off;
    #####: 1407:    build->substr_count++;
        -: 1408:    return 0;
        -: 1409:}
        -: 1410:
        -: 1411:static void
    #####: 1412:md_free_attribute(MD_CTX* ctx, MD_ATTRIBUTE_BUILD* build)
        -: 1413:{
    #####: 1414:    if(build->substr_alloc > 0) {
    #####: 1415:        free(build->text);
    #####: 1416:        free(build->substr_types);
    #####: 1417:        free(build->substr_offsets);
        -: 1418:    }
    #####: 1419:}
        -: 1420:
        -: 1421:static int
    #####: 1422:md_build_attribute(MD_CTX* ctx, const CHAR* raw_text, SZ raw_size,
        -: 1423:                   unsigned flags, MD_ATTRIBUTE* attr, MD_ATTRIBUTE_BUILD* build)
        -: 1424:{
        -: 1425:    OFF raw_off, off;
        -: 1426:    int is_trivial;
    #####: 1427:    int ret = 0;
        -: 1428:
    #####: 1429:    memset(build, 0, sizeof(MD_ATTRIBUTE_BUILD));
        -: 1430:
        -: 1431:    /* If there is no backslash and no ampersand, build trivial attribute
        -: 1432:     * without any malloc(). */
    #####: 1433:    is_trivial = TRUE;
    #####: 1434:    for(raw_off = 0; raw_off < raw_size; raw_off++) {
    #####: 1435:        if(ISANYOF3_(raw_text[raw_off], _T('\\'), _T('&'), _T('\0'))) {
        -: 1436:            is_trivial = FALSE;
        -: 1437:            break;
        -: 1438:        }
        -: 1439:    }
        -: 1440:
    #####: 1441:    if(is_trivial) {
    #####: 1442:        build->text = (CHAR*) (raw_size ? raw_text : NULL);
    #####: 1443:        build->substr_types = build->trivial_types;
    #####: 1444:        build->substr_offsets = build->trivial_offsets;
    #####: 1445:        build->substr_count = 1;
    #####: 1446:        build->substr_alloc = 0;
    #####: 1447:        build->trivial_types[0] = MD_TEXT_NORMAL;
    #####: 1448:        build->trivial_offsets[0] = 0;
    #####: 1449:        build->trivial_offsets[1] = raw_size;
    #####: 1450:        off = raw_size;
        -: 1451:    } else {
    #####: 1452:        build->text = (CHAR*) malloc(raw_size * sizeof(CHAR));
    #####: 1453:        if(build->text == NULL) {
    #####: 1454:            MD_LOG("malloc() failed.");
        -: 1455:            goto abort;
        -: 1456:        }
        -: 1457:
        -: 1458:        raw_off = 0;
        -: 1459:        off = 0;
        -: 1460:
    #####: 1461:        while(raw_off < raw_size) {
    #####: 1462:            if(raw_text[raw_off] == _T('\0')) {
    #####: 1463:                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NULLCHAR, off));
    #####: 1464:                memcpy(build->text + off, raw_text + raw_off, 1);
    #####: 1465:                off++;
    #####: 1466:                raw_off++;
    #####: 1467:                continue;
        -: 1468:            }
        -: 1469:
    #####: 1470:            if(raw_text[raw_off] == _T('&')) {
    #####: 1471:                OFF ent_end;
        -: 1472:
    #####: 1473:                if(md_is_entity_str(ctx, raw_text, raw_off, raw_size, &ent_end)) {
    #####: 1474:                    MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_ENTITY, off));
    #####: 1475:                    memcpy(build->text + off, raw_text + raw_off, ent_end - raw_off);
    #####: 1476:                    off += ent_end - raw_off;
    #####: 1477:                    raw_off = ent_end;
    #####: 1478:                    continue;
        -: 1479:                }
        -: 1480:            }
        -: 1481:
    #####: 1482:            if(build->substr_count == 0  ||  build->substr_types[build->substr_count-1] != MD_TEXT_NORMAL)
    #####: 1483:                MD_CHECK(md_build_attr_append_substr(ctx, build, MD_TEXT_NORMAL, off));
        -: 1484:
    #####: 1485:            if(!(flags & MD_BUILD_ATTR_NO_ESCAPES)  &&
    #####: 1486:               raw_text[raw_off] == _T('\\')  &&  raw_off+1 < raw_size  &&
    #####: 1487:               (ISPUNCT_(raw_text[raw_off+1]) || ISNEWLINE_(raw_text[raw_off+1])))
    #####: 1488:                raw_off++;
        -: 1489:
    #####: 1490:            build->text[off++] = raw_text[raw_off++];
        -: 1491:        }
    #####: 1492:        build->substr_offsets[build->substr_count] = off;
        -: 1493:    }
        -: 1494:
    #####: 1495:    attr->text = build->text;
    #####: 1496:    attr->size = off;
    #####: 1497:    attr->substr_offsets = build->substr_offsets;
    #####: 1498:    attr->substr_types = build->substr_types;
    #####: 1499:    return 0;
        -: 1500:
    #####: 1501:abort:
    #####: 1502:    md_free_attribute(ctx, build);
    #####: 1503:    return -1;
        -: 1504:}
        -: 1505:
        -: 1506:
        -: 1507:/*********************************************
        -: 1508: ***  Dictionary of Reference Definitions  ***
        -: 1509: *********************************************/
        -: 1510:
        -: 1511:#define MD_FNV1A_BASE       2166136261
        -: 1512:#define MD_FNV1A_PRIME      16777619
        -: 1513:
        -: 1514:static inline unsigned
        -: 1515:md_fnv1a(unsigned base, const void* data, size_t n)
        -: 1516:{
    #####: 1517:    const unsigned char* buf = (const unsigned char*) data;
    #####: 1518:    unsigned hash = base;
        -: 1519:    size_t i;
        -: 1520:
    #####: 1521:    for(i = 0; i < n; i++) {
    #####: 1522:        hash ^= buf[i];
    #####: 1523:        hash *= MD_FNV1A_PRIME;
        -: 1524:    }
        -: 1525:
        -: 1526:    return hash;
        -: 1527:}
        -: 1528:
        -: 1529:
        -: 1530:struct MD_REF_DEF_tag {
        -: 1531:    CHAR* label;
        -: 1532:    CHAR* title;
        -: 1533:    unsigned hash;
        -: 1534:    SZ label_size                   : 24;
        -: 1535:    unsigned label_needs_free       :  1;
        -: 1536:    unsigned title_needs_free       :  1;
        -: 1537:    SZ title_size;
        -: 1538:    OFF dest_beg;
        -: 1539:    OFF dest_end;
        -: 1540:};
        -: 1541:
        -: 1542:/* Label equivalence is quite complicated with regards to whitespace and case
        -: 1543: * folding. This complicates computing a hash of it as well as direct comparison
        -: 1544: * of two labels. */
        -: 1545:
        -: 1546:static unsigned
    #####: 1547:md_link_label_hash(const CHAR* label, SZ size)
        -: 1548:{
    #####: 1549:    unsigned hash = MD_FNV1A_BASE;
        -: 1550:    OFF off;
    #####: 1551:    int codepoint;
    #####: 1552:    int is_whitespace = FALSE;
        -: 1553:
    #####: 1554:    off = md_skip_unicode_whitespace(label, 0, size);
    #####: 1555:    while(off < size) {
    #####: 1556:        SZ char_size;
        -: 1557:
    #####: 1558:        codepoint = md_decode_unicode(label, off, size, &char_size);
    #####: 1559:        is_whitespace = ISUNICODEWHITESPACE_(codepoint) || ISNEWLINE_(label[off]);
        -: 1560:
        -: 1561:        if(is_whitespace) {
    #####: 1562:            codepoint = ' ';
    #####: 1563:            hash = md_fnv1a(hash, &codepoint, 1 * sizeof(int));
        -: 1564:
    #####: 1565:            off = md_skip_unicode_whitespace(label, off, size);
        -: 1566:        } else {
    #####: 1567:            MD_UNICODE_FOLD_INFO fold_info;
        -: 1568:
    #####: 1569:            md_get_unicode_fold_info(codepoint, &fold_info);
    #####: 1570:            hash = md_fnv1a(hash, fold_info.codepoints, fold_info.n_codepoints * sizeof(int));
        -: 1571:
    #####: 1572:            off += char_size;
        -: 1573:        }
        -: 1574:    }
        -: 1575:
    #####: 1576:    if(!is_whitespace) {
    #####: 1577:        codepoint = ' ';
        -: 1578:        hash = md_fnv1a(hash, &codepoint, 1 * sizeof(int));
        -: 1579:    }
        -: 1580:
    #####: 1581:    return hash;
        -: 1582:}
        -: 1583:
        -: 1584:static int
    #####: 1585:md_link_label_cmp(const CHAR* a_label, SZ a_size, const CHAR* b_label, SZ b_size)
        -: 1586:{
        -: 1587:    OFF a_off;
        -: 1588:    OFF b_off;
        -: 1589:
        -: 1590:    /* The slow path, with Unicode case folding and Unicode whitespace collapsing. */
    #####: 1591:    a_off = md_skip_unicode_whitespace(a_label, 0, a_size);
    #####: 1592:    b_off = md_skip_unicode_whitespace(b_label, 0, b_size);
    #####: 1593:    while(a_off < a_size  ||  b_off < b_size) {
        -: 1594:        int a_codepoint, b_codepoint;
    #####: 1595:        SZ a_char_size, b_char_size;
        -: 1596:        int a_is_whitespace, b_is_whitespace;
        -: 1597:
    #####: 1598:        if(a_off < a_size) {
    #####: 1599:            a_codepoint = md_decode_unicode(a_label, a_off, a_size, &a_char_size);
    #####: 1600:            a_is_whitespace = ISUNICODEWHITESPACE_(a_codepoint) || ISNEWLINE_(a_label[a_off]);
        -: 1601:        } else {
        -: 1602:            /* Treat end of label as a whitespace. */
        -: 1603:            a_codepoint = -1;
        -: 1604:            a_is_whitespace = TRUE;
        -: 1605:        }
        -: 1606:
    #####: 1607:        if(b_off < b_size) {
    #####: 1608:            b_codepoint = md_decode_unicode(b_label, b_off, b_size, &b_char_size);
    #####: 1609:            b_is_whitespace = ISUNICODEWHITESPACE_(b_codepoint) || ISNEWLINE_(b_label[b_off]);
        -: 1610:        } else {
        -: 1611:            /* Treat end of label as a whitespace. */
        -: 1612:            b_codepoint = -1;
        -: 1613:            b_is_whitespace = TRUE;
        -: 1614:        }
        -: 1615:
    #####: 1616:        if(a_is_whitespace || b_is_whitespace) {
    #####: 1617:            if(!a_is_whitespace || !b_is_whitespace)
    #####: 1618:                return (a_is_whitespace ? -1 : +1);
        -: 1619:
    #####: 1620:            a_off = md_skip_unicode_whitespace(a_label, a_off, a_size);
    #####: 1621:            b_off = md_skip_unicode_whitespace(b_label, b_off, b_size);
        -: 1622:        } else {
    #####: 1623:            MD_UNICODE_FOLD_INFO a_fold_info, b_fold_info;
        -: 1624:            int cmp;
        -: 1625:
    #####: 1626:            md_get_unicode_fold_info(a_codepoint, &a_fold_info);
    #####: 1627:            md_get_unicode_fold_info(b_codepoint, &b_fold_info);
        -: 1628:
    #####: 1629:            if(a_fold_info.n_codepoints != b_fold_info.n_codepoints)
    #####: 1630:                return (a_fold_info.n_codepoints - b_fold_info.n_codepoints);
    #####: 1631:            cmp = memcmp(a_fold_info.codepoints, b_fold_info.codepoints, a_fold_info.n_codepoints * sizeof(int));
    #####: 1632:            if(cmp != 0)
        -: 1633:                return cmp;
        -: 1634:
    #####: 1635:            a_off += a_char_size;
    #####: 1636:            b_off += b_char_size;
        -: 1637:        }
        -: 1638:    }
        -: 1639:
        -: 1640:    return 0;
        -: 1641:}
        -: 1642:
        -: 1643:typedef struct MD_REF_DEF_LIST_tag MD_REF_DEF_LIST;
        -: 1644:struct MD_REF_DEF_LIST_tag {
        -: 1645:    int n_ref_defs;
        -: 1646:    int alloc_ref_defs;
        -: 1647:    MD_REF_DEF* ref_defs[];  /* Valid items always  point into ctx->ref_defs[] */
        -: 1648:};
        -: 1649:
        -: 1650:static int
    #####: 1651:md_ref_def_cmp(const void* a, const void* b)
        -: 1652:{
    #####: 1653:    const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;
    #####: 1654:    const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;
        -: 1655:
    #####: 1656:    if(a_ref->hash < b_ref->hash)
        -: 1657:        return -1;
    #####: 1658:    else if(a_ref->hash > b_ref->hash)
        -: 1659:        return +1;
        -: 1660:    else
    #####: 1661:        return md_link_label_cmp(a_ref->label, a_ref->label_size, b_ref->label, b_ref->label_size);
        -: 1662:}
        -: 1663:
        -: 1664:static int
    #####: 1665:md_ref_def_cmp_stable(const void* a, const void* b)
        -: 1666:{
        -: 1667:    int cmp;
        -: 1668:
    #####: 1669:    cmp = md_ref_def_cmp(a, b);
        -: 1670:
        -: 1671:    /* Ensure stability of the sorting. */
    #####: 1672:    if(cmp == 0) {
    #####: 1673:        const MD_REF_DEF* a_ref = *(const MD_REF_DEF**)a;
    #####: 1674:        const MD_REF_DEF* b_ref = *(const MD_REF_DEF**)b;
        -: 1675:
    #####: 1676:        if(a_ref < b_ref)
        -: 1677:            cmp = -1;
    #####: 1678:        else if(a_ref > b_ref)
        -: 1679:            cmp = +1;
        -: 1680:        else
    #####: 1681:            cmp = 0;
        -: 1682:    }
        -: 1683:
    #####: 1684:    return cmp;
        -: 1685:}
        -: 1686:
        -: 1687:static int
    #####: 1688:md_build_ref_def_hashtable(MD_CTX* ctx)
        -: 1689:{
        -: 1690:    int i, j;
        -: 1691:
    #####: 1692:    if(ctx->n_ref_defs == 0)
        -: 1693:        return 0;
        -: 1694:
    #####: 1695:    ctx->ref_def_hashtable_size = (ctx->n_ref_defs * 5) / 4;
    #####: 1696:    ctx->ref_def_hashtable = malloc(ctx->ref_def_hashtable_size * sizeof(void*));
    #####: 1697:    if(ctx->ref_def_hashtable == NULL) {
    #####: 1698:        MD_LOG("malloc() failed.");
        -: 1699:        goto abort;
        -: 1700:    }
    #####: 1701:    memset(ctx->ref_def_hashtable, 0, ctx->ref_def_hashtable_size * sizeof(void*));
        -: 1702:
        -: 1703:    /* Each member of ctx->ref_def_hashtable[] can be:
        -: 1704:     *  -- NULL,
        -: 1705:     *  -- pointer to the MD_REF_DEF in ctx->ref_defs[], or
        -: 1706:     *  -- pointer to a MD_REF_DEF_LIST, which holds multiple pointers to
        -: 1707:     *     such MD_REF_DEFs.
        -: 1708:     */
    #####: 1709:    for(i = 0; i < ctx->n_ref_defs; i++) {
    #####: 1710:        MD_REF_DEF* def = &ctx->ref_defs[i];
        -: 1711:        void* bucket;
        -: 1712:        MD_REF_DEF_LIST* list;
        -: 1713:
    #####: 1714:        def->hash = md_link_label_hash(def->label, def->label_size);
    #####: 1715:        bucket = ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size];
        -: 1716:
    #####: 1717:        if(bucket == NULL) {
    #####: 1718:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = def;
    #####: 1719:            continue;
        -: 1720:        }
        -: 1721:
    #####: 1722:        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {
        -: 1723:            /* The bucket already contains one ref. def. Lets see whether it
        -: 1724:             * is the same label (ref. def. duplicate) or different one
        -: 1725:             * (hash conflict). */
    #####: 1726:            MD_REF_DEF* old_def = (MD_REF_DEF*) bucket;
        -: 1727:
    #####: 1728:            if(md_link_label_cmp(def->label, def->label_size, old_def->label, old_def->label_size) == 0) {
        -: 1729:                /* Ignore this ref. def. */
    #####: 1730:                continue;
        -: 1731:            }
        -: 1732:
        -: 1733:            /* Make the bucket capable of holding more ref. defs. */
    #####: 1734:            list = (MD_REF_DEF_LIST*) malloc(sizeof(MD_REF_DEF_LIST) + 4 * sizeof(MD_REF_DEF));
    #####: 1735:            if(list == NULL) {
    #####: 1736:                MD_LOG("malloc() failed.");
        -: 1737:                goto abort;
        -: 1738:            }
    #####: 1739:            list->ref_defs[0] = old_def;
    #####: 1740:            list->ref_defs[1] = def;
    #####: 1741:            list->n_ref_defs = 2;
    #####: 1742:            list->alloc_ref_defs = 4;
    #####: 1743:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;
    #####: 1744:            continue;
        -: 1745:        }
        -: 1746:
        -: 1747:        /* Append the def to the bucket list. */
    #####: 1748:        list = (MD_REF_DEF_LIST*) bucket;
    #####: 1749:        if(list->n_ref_defs >= list->alloc_ref_defs) {
    #####: 1750:            MD_REF_DEF_LIST* list_tmp = (MD_REF_DEF_LIST*) realloc(list,
    #####: 1751:                        sizeof(MD_REF_DEF_LIST) + 2 * list->alloc_ref_defs * sizeof(MD_REF_DEF));
    #####: 1752:            if(list_tmp == NULL) {
    #####: 1753:                MD_LOG("realloc() failed.");
        -: 1754:                goto abort;
        -: 1755:            }
    #####: 1756:            list = list_tmp;
    #####: 1757:            list->alloc_ref_defs *= 2;
    #####: 1758:            ctx->ref_def_hashtable[def->hash % ctx->ref_def_hashtable_size] = list;
        -: 1759:        }
        -: 1760:
    #####: 1761:        list->ref_defs[list->n_ref_defs] = def;
    #####: 1762:        list->n_ref_defs++;
        -: 1763:    }
        -: 1764:
        -: 1765:    /* Sort the complex buckets so we can use bsearch() with them. */
    #####: 1766:    for(i = 0; i < ctx->ref_def_hashtable_size; i++) {
    #####: 1767:        void* bucket = ctx->ref_def_hashtable[i];
        -: 1768:        MD_REF_DEF_LIST* list;
        -: 1769:
    #####: 1770:        if(bucket == NULL)
    #####: 1771:            continue;
    #####: 1772:        if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)
    #####: 1773:            continue;
        -: 1774:
    #####: 1775:        list = (MD_REF_DEF_LIST*) bucket;
    #####: 1776:        qsort(list->ref_defs, list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp_stable);
        -: 1777:
        -: 1778:        /* Disable duplicates. */
    #####: 1779:        for(j = 1; j < list->n_ref_defs; j++) {
    #####: 1780:            if(md_ref_def_cmp(&list->ref_defs[j-1], &list->ref_defs[j]) == 0)
    #####: 1781:                list->ref_defs[j] = list->ref_defs[j-1];
        -: 1782:        }
        -: 1783:    }
        -: 1784:
        -: 1785:    return 0;
        -: 1786:
        -: 1787:abort:
        -: 1788:    return -1;
        -: 1789:}
        -: 1790:
        -: 1791:static void
    #####: 1792:md_free_ref_def_hashtable(MD_CTX* ctx)
        -: 1793:{
    #####: 1794:    if(ctx->ref_def_hashtable != NULL) {
        -: 1795:        int i;
        -: 1796:
    #####: 1797:        for(i = 0; i < ctx->ref_def_hashtable_size; i++) {
    #####: 1798:            void* bucket = ctx->ref_def_hashtable[i];
    #####: 1799:            if(bucket == NULL)
    #####: 1800:                continue;
    #####: 1801:            if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs)
    #####: 1802:                continue;
    #####: 1803:            free(bucket);
        -: 1804:        }
        -: 1805:
    #####: 1806:        free(ctx->ref_def_hashtable);
        -: 1807:    }
    #####: 1808:}
        -: 1809:
        -: 1810:static const MD_REF_DEF*
    #####: 1811:md_lookup_ref_def(MD_CTX* ctx, const CHAR* label, SZ label_size)
        -: 1812:{
        -: 1813:    unsigned hash;
        -: 1814:    void* bucket;
        -: 1815:
    #####: 1816:    if(ctx->ref_def_hashtable_size == 0)
        -: 1817:        return NULL;
        -: 1818:
    #####: 1819:    hash = md_link_label_hash(label, label_size);
    #####: 1820:    bucket = ctx->ref_def_hashtable[hash % ctx->ref_def_hashtable_size];
        -: 1821:
    #####: 1822:    if(bucket == NULL) {
        -: 1823:        return NULL;
    #####: 1824:    } else if(ctx->ref_defs <= (MD_REF_DEF*) bucket  &&  (MD_REF_DEF*) bucket < ctx->ref_defs + ctx->n_ref_defs) {
    #####: 1825:        const MD_REF_DEF* def = (MD_REF_DEF*) bucket;
        -: 1826:
    #####: 1827:        if(md_link_label_cmp(def->label, def->label_size, label, label_size) == 0)
        -: 1828:            return def;
        -: 1829:        else
    #####: 1830:            return NULL;
        -: 1831:    } else {
    #####: 1832:        MD_REF_DEF_LIST* list = (MD_REF_DEF_LIST*) bucket;
    #####: 1833:        MD_REF_DEF key_buf;
    #####: 1834:        const MD_REF_DEF* key = &key_buf;
        -: 1835:        const MD_REF_DEF** ret;
        -: 1836:
    #####: 1837:        key_buf.label = (CHAR*) label;
    #####: 1838:        key_buf.label_size = label_size;
    #####: 1839:        key_buf.hash = md_link_label_hash(key_buf.label, key_buf.label_size);
        -: 1840:
    #####: 1841:        ret = (const MD_REF_DEF**) bsearch(&key, list->ref_defs,
    #####: 1842:                    list->n_ref_defs, sizeof(MD_REF_DEF*), md_ref_def_cmp);
    #####: 1843:        if(ret != NULL)
    #####: 1844:            return *ret;
        -: 1845:        else
        -: 1846:            return NULL;
        -: 1847:    }
        -: 1848:}
        -: 1849:
        -: 1850:
        -: 1851:/***************************
        -: 1852: ***  Recognizing Links  ***
        -: 1853: ***************************/
        -: 1854:
        -: 1855:/* Note this code is partially shared between processing inlines and blocks
        -: 1856: * as reference definitions and links share some helper parser functions.
        -: 1857: */
        -: 1858:
        -: 1859:typedef struct MD_LINK_ATTR_tag MD_LINK_ATTR;
        -: 1860:struct MD_LINK_ATTR_tag {
        -: 1861:    OFF dest_beg;
        -: 1862:    OFF dest_end;
        -: 1863:
        -: 1864:    CHAR* title;
        -: 1865:    SZ title_size;
        -: 1866:    int title_needs_free;
        -: 1867:};
        -: 1868:
        -: 1869:
        -: 1870:static int
    #####: 1871:md_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,
        -: 1872:                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,
        -: 1873:                 OFF* p_contents_beg, OFF* p_contents_end)
        -: 1874:{
    #####: 1875:    OFF off = beg;
    #####: 1876:    OFF contents_beg = 0;
    #####: 1877:    OFF contents_end = 0;
    #####: 1878:    int line_index = 0;
    #####: 1879:    int len = 0;
        -: 1880:
    #####: 1881:    if(CH(off) != _T('['))
        -: 1882:        return FALSE;
    #####: 1883:    off++;
        -: 1884:
        -: 1885:    while(1) {
    #####: 1886:        OFF line_end = lines[line_index].end;
        -: 1887:
    #####: 1888:        while(off < line_end) {
    #####: 1889:            if(CH(off) == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
    #####: 1890:                if(contents_end == 0) {
    #####: 1891:                    contents_beg = off;
    #####: 1892:                    *p_beg_line_index = line_index;
        -: 1893:                }
    #####: 1894:                contents_end = off + 2;
    #####: 1895:                off += 2;
    #####: 1896:            } else if(CH(off) == _T('[')) {
        -: 1897:                return FALSE;
    #####: 1898:            } else if(CH(off) == _T(']')) {
    #####: 1899:                if(contents_beg < contents_end) {
        -: 1900:                    /* Success. */
    #####: 1901:                    *p_contents_beg = contents_beg;
    #####: 1902:                    *p_contents_end = contents_end;
    #####: 1903:                    *p_end = off+1;
    #####: 1904:                    *p_end_line_index = line_index;
        -: 1905:                    return TRUE;
        -: 1906:                } else {
        -: 1907:                    /* Link label must have some non-whitespace contents. */
        -: 1908:                    return FALSE;
        -: 1909:                }
        -: 1910:            } else {
        -: 1911:                int codepoint;
    #####: 1912:                SZ char_size;
        -: 1913:
    #####: 1914:                codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size);
    #####: 1915:                if(!ISUNICODEWHITESPACE_(codepoint)) {
    #####: 1916:                    if(contents_end == 0) {
    #####: 1917:                        contents_beg = off;
    #####: 1918:                        *p_beg_line_index = line_index;
        -: 1919:                    }
    #####: 1920:                    contents_end = off + char_size;
        -: 1921:                }
        -: 1922:
    #####: 1923:                off += char_size;
        -: 1924:            }
        -: 1925:
    #####: 1926:            len++;
    #####: 1927:            if(len > 999)
        -: 1928:                return FALSE;
        -: 1929:        }
        -: 1930:
    #####: 1931:        line_index++;
    #####: 1932:        len++;
    #####: 1933:        if(line_index < n_lines)
    #####: 1934:            off = lines[line_index].beg;
        -: 1935:        else
        -: 1936:            break;
        -: 1937:    }
        -: 1938:
        -: 1939:    return FALSE;
        -: 1940:}
        -: 1941:
        -: 1942:static int
    #####: 1943:md_is_link_destination_A(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,
        -: 1944:                         OFF* p_contents_beg, OFF* p_contents_end)
        -: 1945:{
    #####: 1946:    OFF off = beg;
        -: 1947:
    #####: 1948:    if(off >= max_end  ||  CH(off) != _T('<'))
        -: 1949:        return FALSE;
    #####: 1950:    off++;
        -: 1951:
    #####: 1952:    while(off < max_end) {
    #####: 1953:        if(CH(off) == _T('\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {
    #####: 1954:            off += 2;
    #####: 1955:            continue;
        -: 1956:        }
        -: 1957:
    #####: 1958:        if(ISWHITESPACE(off)  ||  CH(off) == _T('<'))
        -: 1959:            return FALSE;
        -: 1960:
    #####: 1961:        if(CH(off) == _T('>')) {
        -: 1962:            /* Success. */
    #####: 1963:            *p_contents_beg = beg+1;
    #####: 1964:            *p_contents_end = off;
    #####: 1965:            *p_end = off+1;
    #####: 1966:            return TRUE;
        -: 1967:        }
        -: 1968:
    #####: 1969:        off++;
        -: 1970:    }
        -: 1971:
        -: 1972:    return FALSE;
        -: 1973:}
        -: 1974:
        -: 1975:static int
    #####: 1976:md_is_link_destination_B(MD_CTX* ctx, OFF beg, OFF max_end, OFF* p_end,
        -: 1977:                         OFF* p_contents_beg, OFF* p_contents_end)
        -: 1978:{
    #####: 1979:    OFF off = beg;
    #####: 1980:    int parenthesis_level = 0;
        -: 1981:
    #####: 1982:    while(off < max_end) {
    #####: 1983:        if(CH(off) == _T('\\')  &&  off+1 < max_end  &&  ISPUNCT(off+1)) {
    #####: 1984:            off += 2;
    #####: 1985:            continue;
        -: 1986:        }
        -: 1987:
    #####: 1988:        if(ISWHITESPACE(off) || ISCNTRL(off))
        -: 1989:            break;
        -: 1990:
        -: 1991:        /* Link destination may include balanced pairs of unescaped '(' ')'.
        -: 1992:         * Note we limit the maximal nesting level by 32 to protect us from
        -: 1993:         * https://github.com/jgm/cmark/issues/214 */
    #####: 1994:        if(CH(off) == _T('(')) {
    #####: 1995:            parenthesis_level++;
    #####: 1996:            if(parenthesis_level > 32)
        -: 1997:                return FALSE;
    #####: 1998:        } else if(CH(off) == _T(')')) {
    #####: 1999:            if(parenthesis_level == 0)
        -: 2000:                break;
    #####: 2001:            parenthesis_level--;
        -: 2002:        }
        -: 2003:
    #####: 2004:        off++;
        -: 2005:    }
        -: 2006:
    #####: 2007:    if(parenthesis_level != 0  ||  off == beg)
        -: 2008:        return FALSE;
        -: 2009:
        -: 2010:    /* Success. */
    #####: 2011:    *p_contents_beg = beg;
    #####: 2012:    *p_contents_end = off;
    #####: 2013:    *p_end = off;
    #####: 2014:    return TRUE;
        -: 2015:}
        -: 2016:
        -: 2017:static int
    #####: 2018:md_is_link_title(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg,
        -: 2019:                 OFF* p_end, int* p_beg_line_index, int* p_end_line_index,
        -: 2020:                 OFF* p_contents_beg, OFF* p_contents_end)
        -: 2021:{
    #####: 2022:    OFF off = beg;
        -: 2023:    CHAR closer_char;
    #####: 2024:    int line_index = 0;
        -: 2025:
        -: 2026:    /* Optional white space with up to one line break. */
    #####: 2027:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2028:        off++;
    #####: 2029:    if(off >= lines[line_index].end) {
    #####: 2030:        line_index++;
    #####: 2031:        if(line_index >= n_lines)
        -: 2032:            return FALSE;
    #####: 2033:        off = lines[line_index].beg;
        -: 2034:    }
        -: 2035:
    #####: 2036:    *p_beg_line_index = line_index;
        -: 2037:
        -: 2038:    /* First char determines how to detect end of it. */
    #####: 2039:    switch(CH(off)) {
        -: 2040:        case _T('"'):   closer_char = _T('"'); break;
    #####: 2041:        case _T('\''):  closer_char = _T('\''); break;
    #####: 2042:        case _T('('):   closer_char = _T(')'); break;
        -: 2043:        default:        return FALSE;
        -: 2044:    }
    #####: 2045:    off++;
        -: 2046:
    #####: 2047:    *p_contents_beg = off;
        -: 2048:
    #####: 2049:    while(line_index < n_lines) {
    #####: 2050:        OFF line_end = lines[line_index].end;
        -: 2051:
    #####: 2052:        while(off < line_end) {
    #####: 2053:            if(CH(off) == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
        -: 2054:                off++;
    #####: 2055:            } else if(CH(off) == closer_char) {
        -: 2056:                /* Success. */
    #####: 2057:                *p_contents_end = off;
    #####: 2058:                *p_end = off+1;
    #####: 2059:                *p_end_line_index = line_index;
        -: 2060:                return TRUE;
        -: 2061:            }
        -: 2062:
    #####: 2063:            off++;
        -: 2064:        }
        -: 2065:
    #####: 2066:        line_index++;
        -: 2067:    }
        -: 2068:
        -: 2069:    return FALSE;
        -: 2070:}
        -: 2071:
        -: 2072:/* Returns 0 if it is not a reference definition.
        -: 2073: *
        -: 2074: * Returns N > 0 if it is a reference definition. N then corresponds to the
        -: 2075: * number of lines forming it). In this case the definition is stored for
        -: 2076: * resolving any links referring to it.
        -: 2077: *
        -: 2078: * Returns -1 in case of an error (out of memory).
        -: 2079: */
        -: 2080:static int
    #####: 2081:md_is_link_reference_definition_helper(
        -: 2082:            MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2083:            int (*is_link_dest_fn)(MD_CTX*, OFF, OFF, OFF*, OFF*, OFF*))
        -: 2084:{
    #####: 2085:    OFF label_contents_beg;
    #####: 2086:    OFF label_contents_end;
    #####: 2087:    int label_contents_line_index = -1;
        -: 2088:    int label_is_multiline;
    #####: 2089:    CHAR* label;
    #####: 2090:    SZ label_size;
    #####: 2091:    int label_needs_free = FALSE;
    #####: 2092:    OFF dest_contents_beg;
    #####: 2093:    OFF dest_contents_end;
    #####: 2094:    OFF title_contents_beg;
    #####: 2095:    OFF title_contents_end;
    #####: 2096:    int title_contents_line_index;
        -: 2097:    int title_is_multiline;
    #####: 2098:    OFF off;
    #####: 2099:    int line_index = 0;
    #####: 2100:    int tmp_line_index;
        -: 2101:    MD_REF_DEF* def;
        -: 2102:    int ret;
        -: 2103:
        -: 2104:    /* Link label. */
    #####: 2105:    if(!md_is_link_label(ctx, lines, n_lines, lines[0].beg,
        -: 2106:                &off, &label_contents_line_index, &line_index,
        -: 2107:                &label_contents_beg, &label_contents_end))
        -: 2108:        return FALSE;
    #####: 2109:    label_is_multiline = (label_contents_line_index != line_index);
        -: 2110:
        -: 2111:    /* Colon. */
    #####: 2112:    if(off >= lines[line_index].end  ||  CH(off) != _T(':'))
        -: 2113:        return FALSE;
    #####: 2114:    off++;
        -: 2115:
        -: 2116:    /* Optional white space with up to one line break. */
    #####: 2117:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2118:        off++;
    #####: 2119:    if(off >= lines[line_index].end) {
    #####: 2120:        line_index++;
    #####: 2121:        if(line_index >= n_lines)
        -: 2122:            return FALSE;
    #####: 2123:        off = lines[line_index].beg;
        -: 2124:    }
        -: 2125:
        -: 2126:    /* Link destination. */
    #####: 2127:    if(!is_link_dest_fn(ctx, off, lines[line_index].end,
        -: 2128:                        &off, &dest_contents_beg, &dest_contents_end))
        -: 2129:        return FALSE;
        -: 2130:
        -: 2131:    /* (Optional) title. Note we interpret it as an title only if nothing
        -: 2132:     * more follows on its last line. */
    #####: 2133:    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,
        -: 2134:                &off, &title_contents_line_index, &tmp_line_index,
        -: 2135:                &title_contents_beg, &title_contents_end)
    #####: 2136:        &&  off >= lines[line_index + tmp_line_index].end)
        -: 2137:    {
    #####: 2138:        title_is_multiline = (tmp_line_index != title_contents_line_index);
    #####: 2139:        title_contents_line_index += line_index;
    #####: 2140:        line_index += tmp_line_index;
        -: 2141:    } else {
        -: 2142:        /* Not a title. */
    #####: 2143:        title_is_multiline = FALSE;
    #####: 2144:        title_contents_beg = off;
    #####: 2145:        title_contents_end = off;
    #####: 2146:        title_contents_line_index = 0;
        -: 2147:    }
        -: 2148:
        -: 2149:    /* Nothing more can follow on the last line. */
    #####: 2150:    if(off < lines[line_index].end)
        -: 2151:        return FALSE;
        -: 2152:
        -: 2153:    /* Construct label. */
    #####: 2154:    if(!label_is_multiline) {
    #####: 2155:        label = (CHAR*) STR(label_contents_beg);
    #####: 2156:        label_size = label_contents_end - label_contents_beg;
    #####: 2157:        label_needs_free = FALSE;
        -: 2158:    } else {
    #####: 2159:        MD_CHECK(md_merge_lines_alloc(ctx, label_contents_beg, label_contents_end,
        -: 2160:                    lines + label_contents_line_index, n_lines - label_contents_line_index,
        -: 2161:                    _T(' '), &label, &label_size));
        -: 2162:        label_needs_free = TRUE;
        -: 2163:    }
        -: 2164:
        -: 2165:    /* Store the reference definition. */
    #####: 2166:    if(ctx->n_ref_defs >= ctx->alloc_ref_defs) {
        -: 2167:        MD_REF_DEF* new_defs;
        -: 2168:
    #####: 2169:        ctx->alloc_ref_defs = (ctx->alloc_ref_defs > 0 ? ctx->alloc_ref_defs * 2 : 16);
    #####: 2170:        new_defs = (MD_REF_DEF*) realloc(ctx->ref_defs, ctx->alloc_ref_defs * sizeof(MD_REF_DEF));
    #####: 2171:        if(new_defs == NULL) {
    #####: 2172:            MD_LOG("realloc() failed.");
        -: 2173:            ret = -1;
        -: 2174:            goto abort;
        -: 2175:        }
        -: 2176:
    #####: 2177:        ctx->ref_defs = new_defs;
        -: 2178:    }
        -: 2179:
    #####: 2180:    def = &ctx->ref_defs[ctx->n_ref_defs];
    #####: 2181:    memset(def, 0, sizeof(MD_REF_DEF));
        -: 2182:
    #####: 2183:    def->label = label;
    #####: 2184:    def->label_size = label_size;
    #####: 2185:    def->label_needs_free = label_needs_free;
        -: 2186:
    #####: 2187:    def->dest_beg = dest_contents_beg;
    #####: 2188:    def->dest_end = dest_contents_end;
        -: 2189:
    #####: 2190:    if(title_contents_beg >= title_contents_end) {
    #####: 2191:        def->title = NULL;
    #####: 2192:        def->title_size = 0;
    #####: 2193:    } else if(!title_is_multiline) {
    #####: 2194:        def->title = (CHAR*) STR(title_contents_beg);
    #####: 2195:        def->title_size = title_contents_end - title_contents_beg;
        -: 2196:    } else {
    #####: 2197:        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,
        -: 2198:                    lines + title_contents_line_index, n_lines - title_contents_line_index,
        -: 2199:                    _T('\n'), &def->title, &def->title_size));
    #####: 2200:        def->title_needs_free = TRUE;
        -: 2201:    }
        -: 2202:
        -: 2203:    /* Success. */
    #####: 2204:    ctx->n_ref_defs++;
    #####: 2205:    return line_index + 1;
        -: 2206:
    #####: 2207:abort:
        -: 2208:    /* Failure. */
    #####: 2209:    if(label_needs_free)
    #####: 2210:        free(label);
        -: 2211:    return -1;
        -: 2212:}
        -: 2213:
        -: 2214:static inline int
    #####: 2215:md_is_link_reference_definition(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 2216:{
        -: 2217:    int ret;
    #####: 2218:    ret = md_is_link_reference_definition_helper(ctx, lines, n_lines, md_is_link_destination_A);
    #####: 2219:    if(ret == 0)
    #####: 2220:        ret = md_is_link_reference_definition_helper(ctx, lines, n_lines, md_is_link_destination_B);
    #####: 2221:    return ret;
        -: 2222:}
        -: 2223:
        -: 2224:static int
    #####: 2225:md_is_link_reference(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2226:                     OFF beg, OFF end, MD_LINK_ATTR* attr)
        -: 2227:{
        -: 2228:    const MD_REF_DEF* def;
        -: 2229:    const MD_LINE* beg_line;
        -: 2230:    const MD_LINE* end_line;
    #####: 2231:    CHAR* label;
    #####: 2232:    SZ label_size;
        -: 2233:    int ret;
        -: 2234:
    #####: 2235:    MD_ASSERT(CH(beg) == _T('[') || CH(beg) == _T('!'));
    #####: 2236:    MD_ASSERT(CH(end-1) == _T(']'));
        -: 2237:
    #####: 2238:    beg += (CH(beg) == _T('!') ? 2 : 1);
    #####: 2239:    end--;
        -: 2240:
        -: 2241:    /* Find lines corresponding to the beg and end positions. */
    #####: 2242:    MD_ASSERT(lines[0].beg <= beg);
        -: 2243:    beg_line = lines;
    #####: 2244:    while(beg >= beg_line->end)
    #####: 2245:        beg_line++;
        -: 2246:
    #####: 2247:    MD_ASSERT(end <= lines[n_lines-1].end);
        -: 2248:    end_line = beg_line;
    #####: 2249:    while(end >= end_line->end)
    #####: 2250:        end_line++;
        -: 2251:
    #####: 2252:    if(beg_line != end_line) {
    #####: 2253:        MD_CHECK(md_merge_lines_alloc(ctx, beg, end, beg_line,
        -: 2254:                 n_lines - (beg_line - lines), _T(' '), &label, &label_size));
        -: 2255:    } else {
    #####: 2256:        label = (CHAR*) STR(beg);
    #####: 2257:        label_size = end - beg;
        -: 2258:    }
        -: 2259:
    #####: 2260:    def = md_lookup_ref_def(ctx, label, label_size);
    #####: 2261:    if(def != NULL) {
    #####: 2262:        attr->dest_beg = def->dest_beg;
    #####: 2263:        attr->dest_end = def->dest_end;
    #####: 2264:        attr->title = def->title;
    #####: 2265:        attr->title_size = def->title_size;
    #####: 2266:        attr->title_needs_free = FALSE;
        -: 2267:    }
        -: 2268:
    #####: 2269:    if(beg_line != end_line)
    #####: 2270:        free(label);
        -: 2271:
    #####: 2272:    ret = (def != NULL);
        -: 2273:
    #####: 2274:abort:
    #####: 2275:    return ret;
        -: 2276:}
        -: 2277:
        -: 2278:static int
    #####: 2279:md_is_inline_link_spec_helper(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2280:                              OFF beg, OFF* p_end, MD_LINK_ATTR* attr,
        -: 2281:                              int (*is_link_dest_fn)(MD_CTX*, OFF, OFF, OFF*, OFF*, OFF*))
        -: 2282:{
    #####: 2283:    int line_index = 0;
    #####: 2284:    int tmp_line_index;
    #####: 2285:    OFF title_contents_beg;
    #####: 2286:    OFF title_contents_end;
    #####: 2287:    int title_contents_line_index;
        -: 2288:    int title_is_multiline;
    #####: 2289:    OFF off = beg;
    #####: 2290:    int ret = FALSE;
        -: 2291:
    #####: 2292:    while(off >= lines[line_index].end)
    #####: 2293:        line_index++;
        -: 2294:
    #####: 2295:    MD_ASSERT(CH(off) == _T('('));
    #####: 2296:    off++;
        -: 2297:
        -: 2298:    /* Optional white space with up to one line break. */
    #####: 2299:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2300:        off++;
    #####: 2301:    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {
    #####: 2302:        line_index++;
    #####: 2303:        if(line_index >= n_lines)
        -: 2304:            return FALSE;
    #####: 2305:        off = lines[line_index].beg;
        -: 2306:    }
        -: 2307:
        -: 2308:    /* Link destination may be omitted, but only when not also having a title. */
    #####: 2309:    if(off < ctx->size  &&  CH(off) == _T(')')) {
    #####: 2310:        attr->dest_beg = off;
    #####: 2311:        attr->dest_end = off;
    #####: 2312:        attr->title = NULL;
    #####: 2313:        attr->title_size = 0;
    #####: 2314:        attr->title_needs_free = FALSE;
    #####: 2315:        off++;
    #####: 2316:        *p_end = off;
    #####: 2317:        return TRUE;
        -: 2318:    }
        -: 2319:
        -: 2320:    /* Link destination. */
    #####: 2321:    if(!is_link_dest_fn(ctx, off, lines[line_index].end,
        -: 2322:                        &off, &attr->dest_beg, &attr->dest_end))
        -: 2323:        return FALSE;
        -: 2324:
        -: 2325:    /* (Optional) title. */
    #####: 2326:    if(md_is_link_title(ctx, lines + line_index, n_lines - line_index, off,
        -: 2327:                &off, &title_contents_line_index, &tmp_line_index,
        -: 2328:                &title_contents_beg, &title_contents_end))
        -: 2329:    {
    #####: 2330:        title_is_multiline = (tmp_line_index != title_contents_line_index);
    #####: 2331:        title_contents_line_index += line_index;
    #####: 2332:        line_index += tmp_line_index;
        -: 2333:    } else {
        -: 2334:        /* Not a title. */
    #####: 2335:        title_is_multiline = FALSE;
    #####: 2336:        title_contents_beg = off;
    #####: 2337:        title_contents_end = off;
    #####: 2338:        title_contents_line_index = 0;
        -: 2339:    }
        -: 2340:
        -: 2341:    /* Optional whitespace followed with final ')'. */
    #####: 2342:    while(off < lines[line_index].end  &&  ISWHITESPACE(off))
    #####: 2343:        off++;
    #####: 2344:    if(off >= lines[line_index].end  &&  ISNEWLINE(off)) {
    #####: 2345:        line_index++;
    #####: 2346:        if(line_index >= n_lines)
        -: 2347:            return FALSE;
    #####: 2348:        off = lines[line_index].beg;
        -: 2349:    }
    #####: 2350:    if(CH(off) != _T(')'))
        -: 2351:        goto abort;
    #####: 2352:    off++;
        -: 2353:
    #####: 2354:    if(title_contents_beg >= title_contents_end) {
    #####: 2355:        attr->title = NULL;
    #####: 2356:        attr->title_size = 0;
    #####: 2357:        attr->title_needs_free = FALSE;
    #####: 2358:    } else if(!title_is_multiline) {
    #####: 2359:        attr->title = (CHAR*) STR(title_contents_beg);
    #####: 2360:        attr->title_size = title_contents_end - title_contents_beg;
    #####: 2361:        attr->title_needs_free = FALSE;
        -: 2362:    } else {
    #####: 2363:        MD_CHECK(md_merge_lines_alloc(ctx, title_contents_beg, title_contents_end,
        -: 2364:                    lines + title_contents_line_index, n_lines - title_contents_line_index,
        -: 2365:                    _T('\n'), &attr->title, &attr->title_size));
    #####: 2366:        attr->title_needs_free = TRUE;
        -: 2367:    }
        -: 2368:
    #####: 2369:    *p_end = off;
    #####: 2370:    ret = TRUE;
        -: 2371:
    #####: 2372:abort:
    #####: 2373:    return ret;
        -: 2374:}
        -: 2375:
        -: 2376:static inline int
    #####: 2377:md_is_inline_link_spec(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 2378:                       OFF beg, OFF* p_end, MD_LINK_ATTR* attr)
        -: 2379:{
    #####: 2380:    return md_is_inline_link_spec_helper(ctx, lines, n_lines, beg, p_end, attr, md_is_link_destination_A) ||
    #####: 2381:           md_is_inline_link_spec_helper(ctx, lines, n_lines, beg, p_end, attr, md_is_link_destination_B);
        -: 2382:}
        -: 2383:
        -: 2384:static void
    #####: 2385:md_free_ref_defs(MD_CTX* ctx)
        -: 2386:{
        -: 2387:    int i;
        -: 2388:
    #####: 2389:    for(i = 0; i < ctx->n_ref_defs; i++) {
    #####: 2390:        MD_REF_DEF* def = &ctx->ref_defs[i];
        -: 2391:
    #####: 2392:        if(def->label_needs_free)
    #####: 2393:            free(def->label);
    #####: 2394:        if(def->title_needs_free)
    #####: 2395:            free(def->title);
        -: 2396:    }
        -: 2397:
    #####: 2398:    free(ctx->ref_defs);
    #####: 2399:}
        -: 2400:
        -: 2401:
        -: 2402:/******************************************
        -: 2403: ***  Processing Inlines (a.k.a Spans)  ***
        -: 2404: ******************************************/
        -: 2405:
        -: 2406:/* We process inlines in few phases:
        -: 2407: *
        -: 2408: * (1) We go through the block text and collect all significant characters
        -: 2409: *     which may start/end a span or some other significant position into
        -: 2410: *     ctx->marks[]. Core of this is what md_collect_marks() does.
        -: 2411: *
        -: 2412: *     We also do some very brief preliminary context-less analysis, whether
        -: 2413: *     it might be opener or closer (e.g. of an emphasis span).
        -: 2414: *
        -: 2415: *     This speeds the other steps as we do not need to re-iterate over all
        -: 2416: *     characters anymore.
        -: 2417: *
        -: 2418: * (2) We analyze each potential mark types, in order by their precedence.
        -: 2419: *
        -: 2420: *     In each md_analyze_XXX() function, we re-iterate list of the marks,
        -: 2421: *     skipping already resolved regions (in preceding precedences) and try to
        -: 2422: *     resolve them.
        -: 2423: *
        -: 2424: * (2.1) For trivial marks, which are single (e.g. HTML entity), we just mark
        -: 2425: *       them as resolved.
        -: 2426: *
        -: 2427: * (2.2) For range-type marks, we analyze whether the mark could be closer
        -: 2428: *       and, if yes, whether there is some preceding opener it could satisfy.
        -: 2429: *
        -: 2430: *       If not we check whether it could be really an opener and if yes, we
        -: 2431: *       remember it so subsequent closers may resolve it.
        -: 2432: *
        -: 2433: * (3) Finally, when all marks were analyzed, we render the block contents
        -: 2434: *     by calling MD_RENDERER::text() callback, interrupting by ::enter_span()
        -: 2435: *     or ::close_span() whenever we reach a resolved mark.
        -: 2436: */
        -: 2437:
        -: 2438:
        -: 2439:/* The mark structure.
        -: 2440: *
        -: 2441: * '\\': Maybe escape sequence.
        -: 2442: * '\0': NULL char.
        -: 2443: *  '*': Maybe (strong) emphasis start/end.
        -: 2444: *  '_': Maybe (strong) emphasis start/end.
        -: 2445: *  '~': Maybe strikethrough start/end (needs MD_FLAG_STRIKETHROUGH).
        -: 2446: *  '`': Maybe code span start/end.
        -: 2447: *  '&': Maybe start of entity.
        -: 2448: *  ';': Maybe end of entity.
        -: 2449: *  '<': Maybe start of raw HTML or autolink.
        -: 2450: *  '>': Maybe end of raw HTML or autolink.
        -: 2451: *  '[': Maybe start of link label or link text.
        -: 2452: *  '!': Equivalent of '[' for image.
        -: 2453: *  ']': Maybe end of link label or link text.
        -: 2454: *  '@': Maybe permissive e-mail auto-link (needs MD_FLAG_PERMISSIVEEMAILAUTOLINKS).
        -: 2455: *  ':': Maybe permissive URL auto-link (needs MD_FLAG_PERMISSIVEURLAUTOLINKS).
        -: 2456: *  '.': Maybe permissive WWW auto-link (needs MD_FLAG_PERMISSIVEWWWAUTOLINKS).
        -: 2457: *  'D': Dummy mark, it reserves a space for splitting a previous mark
        -: 2458: *       (e.g. emphasis) or to make more space for storing some special data
        -: 2459: *       related to the preceding mark (e.g. link).
        -: 2460: *
        -: 2461: * Note that not all instances of these chars in the text imply creation of the
        -: 2462: * structure. Only those which have (or may have, after we see more context)
        -: 2463: * the special meaning.
        -: 2464: *
        -: 2465: * (Keep this struct as small as possible to fit as much of them into CPU
        -: 2466: * cache line.)
        -: 2467: */
        -: 2468:struct MD_MARK_tag {
        -: 2469:    OFF beg;
        -: 2470:    OFF end;
        -: 2471:
        -: 2472:    /* For unresolved openers, 'prev' and 'next' form the chain of open openers
        -: 2473:     * of given type 'ch'.
        -: 2474:     *
        -: 2475:     * During resolving, we disconnect from the chain and point to the
        -: 2476:     * corresponding counterpart so opener points to its closer and vice versa.
        -: 2477:     */
        -: 2478:    int prev;
        -: 2479:    int next;
        -: 2480:    CHAR ch;
        -: 2481:    unsigned char flags;
        -: 2482:};
        -: 2483:
        -: 2484:/* Mark flags (these apply to ALL mark types). */
        -: 2485:#define MD_MARK_POTENTIAL_OPENER            0x01  /* Maybe opener. */
        -: 2486:#define MD_MARK_POTENTIAL_CLOSER            0x02  /* Maybe closer. */
        -: 2487:#define MD_MARK_OPENER                      0x04  /* Definitely opener. */
        -: 2488:#define MD_MARK_CLOSER                      0x08  /* Definitely closer. */
        -: 2489:#define MD_MARK_RESOLVED                    0x10  /* Resolved in any definite way. */
        -: 2490:
        -: 2491:/* Mark flags specific for various mark types (so they can share bits). */
        -: 2492:#define MD_MARK_EMPH_INTRAWORD              0x20  /* Helper for the "rule of 3". */
        -: 2493:#define MD_MARK_EMPH_MODULO3_0              0x40
        -: 2494:#define MD_MARK_EMPH_MODULO3_1              0x80
        -: 2495:#define MD_MARK_EMPH_MODULO3_2              (0x40 | 0x80)
        -: 2496:#define MD_MARK_EMPH_MODULO3_MASK           (0x40 | 0x80)
        -: 2497:#define MD_MARK_AUTOLINK                    0x20  /* Distinguisher for '<', '>'. */
        -: 2498:
        -: 2499:
        -: 2500:static MD_MARK*
        4: 2501:md_push_mark(MD_CTX* ctx)
        -: 2502:{
        4: 2503:    if(ctx->n_marks >= ctx->alloc_marks) {
        -: 2504:        MD_MARK* new_marks;
        -: 2505:
        1: 2506:        ctx->alloc_marks = (ctx->alloc_marks > 0 ? ctx->alloc_marks * 2 : 64);
        1: 2507:        new_marks = realloc(ctx->marks, ctx->alloc_marks * sizeof(MD_MARK));
        1: 2508:        if(new_marks == NULL) {
    #####: 2509:            MD_LOG("realloc() failed.");
        -: 2510:            return NULL;
        -: 2511:        }
        -: 2512:
        1: 2513:        ctx->marks = new_marks;
        -: 2514:    }
        -: 2515:
        4: 2516:    return &ctx->marks[ctx->n_marks++];
        -: 2517:}
        -: 2518:
        -: 2519:#define PUSH_MARK_()                                                    \
        -: 2520:        do {                                                            \
        -: 2521:            mark = md_push_mark(ctx);                                   \
        -: 2522:            if(mark == NULL) {                                          \
        -: 2523:                ret = -1;                                               \
        -: 2524:                goto abort;                                             \
        -: 2525:            }                                                           \
        -: 2526:        } while(0)
        -: 2527:
        -: 2528:#define PUSH_MARK(ch_, beg_, end_, flags_)                              \
        -: 2529:        do {                                                            \
        -: 2530:            PUSH_MARK_();                                               \
        -: 2531:            mark->beg = (beg_);                                         \
        -: 2532:            mark->end = (end_);                                         \
        -: 2533:            mark->prev = -1;                                            \
        -: 2534:            mark->next = -1;                                            \
        -: 2535:            mark->ch = (char)(ch_);                                     \
        -: 2536:            mark->flags = (flags_);                                     \
        -: 2537:        } while(0)
        -: 2538:
        -: 2539:
        -: 2540:static void
        -: 2541:md_mark_chain_append(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index)
        -: 2542:{
        2: 2543:    if(chain->tail >= 0)
    #####: 2544:        ctx->marks[chain->tail].next = mark_index;
        -: 2545:    else
        2: 2546:        chain->head = mark_index;
        -: 2547:
        2: 2548:    ctx->marks[mark_index].prev = chain->tail;
        2: 2549:    chain->tail = mark_index;
        -: 2550:}
        -: 2551:
        -: 2552:/* Sometimes, we need to store a pointer into the mark. It is quite rare
        -: 2553: * so we do not bother to make MD_MARK use union, and it can only happen
        -: 2554: * for dummy marks. */
        -: 2555:static inline void
        -: 2556:md_mark_store_ptr(MD_CTX* ctx, int mark_index, void* ptr)
        -: 2557:{
    #####: 2558:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2559:    MD_ASSERT(mark->ch == 'D');
        -: 2560:
        -: 2561:    /* Check only members beg and end are misused for this. */
        -: 2562:    MD_ASSERT(sizeof(void*) <= 2 * sizeof(OFF));
    #####: 2563:    memcpy(mark, &ptr, sizeof(void*));
        -: 2564:}
        -: 2565:
        -: 2566:static inline void*
        -: 2567:md_mark_get_ptr(MD_CTX* ctx, int mark_index)
        -: 2568:{
    #####: 2569:    void* ptr;
    #####: 2570:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2571:    MD_ASSERT(mark->ch == 'D');
    #####: 2572:    memcpy(&ptr, mark, sizeof(void*));
        -: 2573:    return ptr;
        -: 2574:}
        -: 2575:
        -: 2576:static void
    #####: 2577:md_resolve_range(MD_CTX* ctx, MD_MARKCHAIN* chain, int opener_index, int closer_index)
        -: 2578:{
    #####: 2579:    MD_MARK* opener = &ctx->marks[opener_index];
    #####: 2580:    MD_MARK* closer = &ctx->marks[closer_index];
        -: 2581:
        -: 2582:    /* Remove opener from the list of openers. */
    #####: 2583:    if(chain != NULL) {
    #####: 2584:        if(opener->prev >= 0)
    #####: 2585:            ctx->marks[opener->prev].next = opener->next;
        -: 2586:        else
    #####: 2587:            chain->head = opener->next;
        -: 2588:
    #####: 2589:        if(opener->next >= 0)
    #####: 2590:            ctx->marks[opener->next].prev = opener->prev;
        -: 2591:        else
    #####: 2592:            chain->tail = opener->prev;
        -: 2593:    }
        -: 2594:
        -: 2595:    /* Interconnect opener and closer and mark both as resolved. */
    #####: 2596:    opener->next = closer_index;
    #####: 2597:    opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;
    #####: 2598:    closer->prev = opener_index;
    #####: 2599:    closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;
    #####: 2600:}
        -: 2601:
        -: 2602:
        -: 2603:#define MD_ROLLBACK_ALL         0
        -: 2604:#define MD_ROLLBACK_CROSSING    1
        -: 2605:
        -: 2606:/* In the range ctx->marks[opener_index] ... [closer_index], undo some or all
        -: 2607: * resolvings accordingly to these rules:
        -: 2608: *
        -: 2609: * (1) All openers BEFORE the range corresponding to any closer inside the
        -: 2610: *     range are un-resolved and they are re-added to their respective chains
        -: 2611: *     of unresolved openers. This ensures we can reuse the opener for closers
        -: 2612: *     AFTER the range.
        -: 2613: *
        -: 2614: * (2) If 'how' is MD_ROLLBACK_ALL, then ALL resolved marks inside the range
        -: 2615: *     are discarded.
        -: 2616: *
        -: 2617: * (3) If 'how' is MD_ROLLBACK_CROSSING, only closers with openers handled
        -: 2618: *     in (1) are discarded. I.e. pairs of openers and closers which are both
        -: 2619: *     inside the range are retained as well as any unpaired marks.
        -: 2620: */
        -: 2621:static void
    #####: 2622:md_rollback(MD_CTX* ctx, int opener_index, int closer_index, int how)
        -: 2623:{
        -: 2624:    int i;
        -: 2625:    int mark_index;
        -: 2626:
        -: 2627:    /* Cut all unresolved openers at the mark index. 
        -: 2628:     * (start at 1 to not touch PTR_CHAIN.) */
    #####: 2629:    for(i = 1; i < SIZEOF_ARRAY(ctx->mark_chains); i++) {
        -: 2630:        MD_MARKCHAIN* chain = &ctx->mark_chains[i];
        -: 2631:
    #####: 2632:        while(chain->tail >= opener_index)
    #####: 2633:            chain->tail = ctx->marks[chain->tail].prev;
        -: 2634:
    #####: 2635:        if(chain->tail >= 0)
    #####: 2636:            ctx->marks[chain->tail].next = -1;
        -: 2637:        else
    #####: 2638:            chain->head = -1;
        -: 2639:    }
        -: 2640:
        -: 2641:    /* Go backwards so that un-resolved openers are re-added into their
        -: 2642:     * respective chains, in the right order. */
    #####: 2643:    mark_index = closer_index - 1;
    #####: 2644:    while(mark_index > opener_index) {
    #####: 2645:        MD_MARK* mark = &ctx->marks[mark_index];
    #####: 2646:        int mark_flags = mark->flags;
    #####: 2647:        int discard_flag = (how == MD_ROLLBACK_ALL);
        -: 2648:
    #####: 2649:        if(mark->flags & MD_MARK_CLOSER) {
    #####: 2650:            int mark_opener_index = mark->prev;
        -: 2651:
        -: 2652:            /* Undo opener BEFORE the range. */
    #####: 2653:            if(mark_opener_index < opener_index) {
    #####: 2654:                MD_MARK* mark_opener = &ctx->marks[mark_opener_index];
        -: 2655:                MD_MARKCHAIN* chain;
        -: 2656:
    #####: 2657:                mark_opener->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);
        -: 2658:
    #####: 2659:                switch(mark_opener->ch) {
    #####: 2660:                    case '*':   chain = &ASTERISK_OPENERS; break;
    #####: 2661:                    case '_':   chain = &UNDERSCORE_OPENERS; break;
    #####: 2662:                    case '`':   chain = &BACKTICK_OPENERS; break;
    #####: 2663:                    case '<':   chain = &LOWERTHEN_OPENERS; break;
    #####: 2664:                    case '~':   chain = &TILDE_OPENERS; break;
    #####: 2665:                    default:    MD_UNREACHABLE(); break;
        -: 2666:                }
    #####: 2667:                md_mark_chain_append(ctx, chain, mark_opener_index);
        -: 2668:
    #####: 2669:                discard_flag = 1;
        -: 2670:            }
        -: 2671:        }
        -: 2672:
        -: 2673:        /* And reset our flags. */
    #####: 2674:        if(discard_flag)
    #####: 2675:            mark->flags &= ~(MD_MARK_OPENER | MD_MARK_CLOSER | MD_MARK_RESOLVED);
        -: 2676:
        -: 2677:        /* Jump as far as we can over unresolved or non-interesting marks. */
    #####: 2678:        switch(how) {
    #####: 2679:            case MD_ROLLBACK_CROSSING:
    #####: 2680:                if((mark_flags & MD_MARK_CLOSER)  &&  mark->prev > opener_index) {
        -: 2681:                    /* If we are closer with opener INSIDE the range, there may
        -: 2682:                     * not be any other crosser inside the subrange. */
        -: 2683:                    mark_index = mark->prev;
        -: 2684:                    break;
        -: 2685:                }
        -: 2686:                /* Pass through. */
        -: 2687:            default:
    #####: 2688:                mark_index--;
    #####: 2689:                break;
        -: 2690:        }
        -: 2691:    }
    #####: 2692:}
        -: 2693:
        -: 2694:static void
        1: 2695:md_build_mark_char_map(MD_CTX* ctx)
        -: 2696:{
        2: 2697:    memset(ctx->mark_char_map, 0, sizeof(ctx->mark_char_map));
        -: 2698:
        1: 2699:    ctx->mark_char_map['\\'] = 1;
        1: 2700:    ctx->mark_char_map['*'] = 1;
        1: 2701:    ctx->mark_char_map['_'] = 1;
        1: 2702:    ctx->mark_char_map['`'] = 1;
        1: 2703:    ctx->mark_char_map['&'] = 1;
        1: 2704:    ctx->mark_char_map[';'] = 1;
        1: 2705:    ctx->mark_char_map['<'] = 1;
        1: 2706:    ctx->mark_char_map['>'] = 1;
        1: 2707:    ctx->mark_char_map['['] = 1;
        1: 2708:    ctx->mark_char_map['!'] = 1;
        1: 2709:    ctx->mark_char_map[']'] = 1;
        1: 2710:    ctx->mark_char_map['\0'] = 1;
        -: 2711:
        1: 2712:    if(ctx->r.flags & MD_FLAG_STRIKETHROUGH)
    #####: 2713:        ctx->mark_char_map['~'] = 1;
        -: 2714:
        1: 2715:    if(ctx->r.flags & MD_FLAG_PERMISSIVEEMAILAUTOLINKS)
    #####: 2716:        ctx->mark_char_map['@'] = 1;
        -: 2717:
        1: 2718:    if(ctx->r.flags & MD_FLAG_PERMISSIVEURLAUTOLINKS)
    #####: 2719:        ctx->mark_char_map[':'] = 1;
        -: 2720:
        1: 2721:    if(ctx->r.flags & MD_FLAG_PERMISSIVEWWWAUTOLINKS)
    #####: 2722:        ctx->mark_char_map['.'] = 1;
        -: 2723:
        1: 2724:    if(ctx->r.flags & MD_FLAG_TABLES)
        1: 2725:        ctx->mark_char_map['|'] = 1;
        -: 2726:
        1: 2727:    if(ctx->r.flags & MD_FLAG_COLLAPSEWHITESPACE) {
        -: 2728:        int i;
        -: 2729:
    #####: 2730:        for(i = 0; i < sizeof(ctx->mark_char_map); i++) {
    #####: 2731:            if(ISWHITESPACE_(i))
    #####: 2732:                ctx->mark_char_map[i] = 1;
        -: 2733:        }
        -: 2734:    }
        1: 2735:}
        -: 2736:
        -: 2737:static int
        2: 2738:md_collect_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)
        -: 2739:{
        -: 2740:    int i;
        2: 2741:    int ret = 0;
        -: 2742:    MD_MARK* mark;
        -: 2743:
        4: 2744:    for(i = 0; i < n_lines; i++) {
        2: 2745:        const MD_LINE* line = &lines[i];
        2: 2746:        OFF off = line->beg;
        2: 2747:        OFF line_end = line->end;
        -: 2748:
        -: 2749:        while(TRUE) {
        -: 2750:            CHAR ch;
        -: 2751:
        -: 2752:#ifdef MD4C_USE_UTF16
        -: 2753:    /* For UTF-16, mark_char_map[] covers only ASCII. */
        -: 2754:    #define IS_MARK_CHAR(off)   ((CH(off) < SIZEOF_ARRAY(ctx->mark_char_map))  &&  \
        -: 2755:                                (ctx->mark_char_map[(unsigned char) CH(off)]))
        -: 2756:#else
        -: 2757:    /* For 8-bit encodings, mark_char_map[] covers all 256 elements. */
        -: 2758:    #define IS_MARK_CHAR(off)   (ctx->mark_char_map[(unsigned char) CH(off)])
        -: 2759:#endif
        -: 2760:
        -: 2761:            /* Optimization: Fast path (with some loop unrolling). */
        4: 2762:            while(off + 4 < line_end  &&  !IS_MARK_CHAR(off+0)  &&  !IS_MARK_CHAR(off+1)
    #####: 2763:                                      &&  !IS_MARK_CHAR(off+2)  &&  !IS_MARK_CHAR(off+3))
        -: 2764:                off += 4;
        8: 2765:            while(off < line_end  &&  !IS_MARK_CHAR(off+0))
        4: 2766:                off++;
        -: 2767:
        4: 2768:            if(off >= line_end)
        -: 2769:                break;
        -: 2770:
        2: 2771:            ch = CH(off);
        -: 2772:
        -: 2773:            /* A backslash escape.
        -: 2774:             * It can go beyond line->end as it may involve escaped new
        -: 2775:             * line to form a hard break. */
        2: 2776:            if(ch == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) {
        -: 2777:                /* Hard-break cannot be on the last line of the block. */
    #####: 2778:                if(!ISNEWLINE(off+1)  ||  i+1 < n_lines)
    #####: 2779:                    PUSH_MARK(ch, off, off+2, MD_MARK_RESOLVED);
        -: 2780:
        -: 2781:                /* If '`' or '>' follows, we need both marks as the backslash
        -: 2782:                 * may be inside a code span or an autolink where escaping is
        -: 2783:                 * disabled. */
    #####: 2784:                if(CH(off+1) == _T('`') || CH(off+1) == _T('>'))
        -: 2785:                    off++;
        -: 2786:                else
    #####: 2787:                    off += 2;
    #####: 2788:                continue;
        -: 2789:            }
        -: 2790:
        -: 2791:            /* A potential (string) emphasis start/end. */
        2: 2792:            if(ch == _T('*')  ||  ch == _T('_')) {
    #####: 2793:                OFF tmp = off+1;
        -: 2794:                int left_level;     /* What precedes: 0 = whitespace; 1 = punctuation; 2 = other char. */
        -: 2795:                int right_level;    /* What follows: 0 = whitespace; 1 = punctuation; 2 = other char. */
        -: 2796:
    #####: 2797:                while(tmp < line_end  &&  CH(tmp) == ch)
    #####: 2798:                    tmp++;
        -: 2799:
    #####: 2800:                if(off == line->beg  ||  ISUNICODEWHITESPACEBEFORE(off))
        -: 2801:                    left_level = 0;
    #####: 2802:                else if(ISUNICODEPUNCTBEFORE(off))
        -: 2803:                    left_level = 1;
        -: 2804:                else
    #####: 2805:                    left_level = 2;
        -: 2806:
    #####: 2807:                if(tmp == line_end  ||  ISUNICODEWHITESPACE(tmp))
        -: 2808:                    right_level = 0;
    #####: 2809:                else if(ISUNICODEPUNCT(tmp))
        -: 2810:                    right_level = 1;
        -: 2811:                else
    #####: 2812:                    right_level = 2;
        -: 2813:
        -: 2814:                /* Intra-word underscore doesn't have special meaning. */
    #####: 2815:                if(ch == _T('_')  &&  left_level == 2  &&  right_level == 2) {
    #####: 2816:                    left_level = 0;
    #####: 2817:                    right_level = 0;
        -: 2818:                }
        -: 2819:
    #####: 2820:                if(left_level != 0  ||  right_level != 0) {
    #####: 2821:                    unsigned flags = 0;
        -: 2822:
    #####: 2823:                    if(left_level > 0  &&  left_level >= right_level)
    #####: 2824:                        flags |= MD_MARK_POTENTIAL_CLOSER;
    #####: 2825:                    if(right_level > 0  &&  right_level >= left_level)
    #####: 2826:                        flags |= MD_MARK_POTENTIAL_OPENER;
    #####: 2827:                    if(left_level == 2  &&  right_level == 2)
    #####: 2828:                        flags |= MD_MARK_EMPH_INTRAWORD;
        -: 2829:
        -: 2830:                    /* For "the rule of three" we need to remember the original
        -: 2831:                     * size of the mark (modulo three), before we potentially
        -: 2832:                     * split the mark when being later resolved partially by some
        -: 2833:                     * shorter closer. */
    #####: 2834:                    switch((tmp - off) % 3) {
    #####: 2835:                        case 0: flags |= MD_MARK_EMPH_MODULO3_0; break;
    #####: 2836:                        case 1: flags |= MD_MARK_EMPH_MODULO3_1; break;
    #####: 2837:                        case 2: flags |= MD_MARK_EMPH_MODULO3_2; break;
        -: 2838:                    }
        -: 2839:
    #####: 2840:                    PUSH_MARK(ch, off, tmp, flags);
        -: 2841:
        -: 2842:                    /* During resolving, multiple asterisks may have to be
        -: 2843:                     * split into independent span start/ends. Consider e.g.
        -: 2844:                     * "**foo* bar*". Therefore we push also some empty dummy
        -: 2845:                     * marks to have enough space for that. */
    #####: 2846:                    off++;
    #####: 2847:                    while(off < tmp) {
    #####: 2848:                        PUSH_MARK('D', off, off, 0);
    #####: 2849:                        off++;
        -: 2850:                    }
    #####: 2851:                    continue;
        -: 2852:                }
        -: 2853:
    #####: 2854:                off = tmp;
    #####: 2855:                continue;
        -: 2856:            }
        -: 2857:
        -: 2858:            /* A potential code span start/end. */
        2: 2859:            if(ch == _T('`')) {
    #####: 2860:                OFF tmp = off+1;
        -: 2861:
    #####: 2862:                while(tmp < line_end  &&  CH(tmp) == _T('`'))
    #####: 2863:                    tmp++;
        -: 2864:
        -: 2865:                /* We limit code span marks to lower then 256 backticks. This
        -: 2866:                 * solves a pathologic case of too many openers, each of
        -: 2867:                 * different length: Their resolving is then O(n^2). */
    #####: 2868:                if(tmp - off < 256)
    #####: 2869:                    PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);
        -: 2870:
    #####: 2871:                off = tmp;
    #####: 2872:                continue;
        -: 2873:            }
        -: 2874:
        -: 2875:            /* A potential entity start. */
        2: 2876:            if(ch == _T('&')) {
    #####: 2877:                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);
    #####: 2878:                off++;
    #####: 2879:                continue;
        -: 2880:            }
        -: 2881:
        -: 2882:            /* A potential entity end. */
        2: 2883:            if(ch == _T(';')) {
        -: 2884:                /* We surely cannot be entity unless the previous mark is '&'. */
    #####: 2885:                if(ctx->n_marks > 0  &&  ctx->marks[ctx->n_marks-1].ch == _T('&'))
    #####: 2886:                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);
        -: 2887:
    #####: 2888:                off++;
    #####: 2889:                continue;
        -: 2890:            }
        -: 2891:
        -: 2892:            /* A potential autolink or raw HTML start/end. */
        2: 2893:            if(ch == _T('<') || ch == _T('>')) {
    #####: 2894:                if(!(ctx->r.flags & MD_FLAG_NOHTMLSPANS))
    #####: 2895:                    PUSH_MARK(ch, off, off+1, (ch == _T('<') ? MD_MARK_POTENTIAL_OPENER : MD_MARK_POTENTIAL_CLOSER));
        -: 2896:
    #####: 2897:                off++;
    #####: 2898:                continue;
        -: 2899:            }
        -: 2900:
        -: 2901:            /* A potential link or its part. */
        2: 2902:            if(ch == _T('[')  ||  (ch == _T('!') && off+1 < line_end && CH(off+1) == _T('['))) {
    #####: 2903:                OFF tmp = (ch == _T('[') ? off+1 : off+2);
    #####: 2904:                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER);
    #####: 2905:                off = tmp;
        -: 2906:                /* Two dummies to make enough place for data we need if it is
        -: 2907:                 * a link. */
    #####: 2908:                PUSH_MARK('D', off, off, 0);
    #####: 2909:                PUSH_MARK('D', off, off, 0);
    #####: 2910:                continue;
        -: 2911:            }
        2: 2912:            if(ch == _T(']')) {
    #####: 2913:                PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_CLOSER);
    #####: 2914:                off++;
    #####: 2915:                continue;
        -: 2916:            }
        -: 2917:
        -: 2918:            /* A potential permissive e-mail autolink. */
        2: 2919:            if(ch == _T('@')) {
    #####: 2920:                if(line->beg + 1 <= off  &&  ISALNUM(off-1)  &&
    #####: 2921:                    off + 3 < line->end  &&  ISALNUM(off+1))
        -: 2922:                {
    #####: 2923:                    PUSH_MARK(ch, off, off+1, MD_MARK_POTENTIAL_OPENER);
        -: 2924:                    /* Push a dummy as a reserve for a closer. */
    #####: 2925:                    PUSH_MARK('D', off, off, 0);
        -: 2926:                }
        -: 2927:
    #####: 2928:                off++;
    #####: 2929:                continue;
        -: 2930:            }
        -: 2931:
        -: 2932:            /* A potential permissive URL autolink. */
        2: 2933:            if(ch == _T(':')) {
        -: 2934:                static struct {
        -: 2935:                    const CHAR* scheme;
        -: 2936:                    SZ scheme_size;
        -: 2937:                    const CHAR* suffix;
        -: 2938:                    SZ suffix_size;
        -: 2939:                } scheme_map[] = {
        -: 2940:                    /* In the order from the most frequently used, arguably. */
        -: 2941:                    { _T("http"), 4,    _T("//"), 2 },
        -: 2942:                    { _T("https"), 5,   _T("//"), 2 },
        -: 2943:                    { _T("ftp"), 3,     _T("//"), 2 }
        -: 2944:                };
        -: 2945:                int scheme_index;
        -: 2946:
    #####: 2947:                for(scheme_index = 0; scheme_index < SIZEOF_ARRAY(scheme_map); scheme_index++) {
    #####: 2948:                    const CHAR* scheme = scheme_map[scheme_index].scheme;
    #####: 2949:                    const SZ scheme_size = scheme_map[scheme_index].scheme_size;
    #####: 2950:                    const CHAR* suffix = scheme_map[scheme_index].suffix;
    #####: 2951:                    const SZ suffix_size = scheme_map[scheme_index].suffix_size;
        -: 2952:
    #####: 2953:                    if(line->beg + scheme_size <= off  &&  md_ascii_eq(STR(off-scheme_size), scheme, scheme_size)  &&
    #####: 2954:                        (line->beg + scheme_size == off || ISWHITESPACE(off-scheme_size-1) || ISANYOF(off-scheme_size-1, _T("*_~([")))  &&
    #####: 2955:                        off + 1 + suffix_size < line->end  &&  md_ascii_eq(STR(off+1), suffix, suffix_size))
        -: 2956:                    {
    #####: 2957:                        PUSH_MARK(ch, off-scheme_size, off+1+suffix_size, MD_MARK_POTENTIAL_OPENER);
        -: 2958:                        /* Push a dummy as a reserve for a closer. */
    #####: 2959:                        PUSH_MARK('D', off, off, 0);
    #####: 2960:                        off += 1 + suffix_size;
    #####: 2961:                        continue;
        -: 2962:                    }
        -: 2963:                }
        -: 2964:
    #####: 2965:                off++;
    #####: 2966:                continue;
        -: 2967:            }
        -: 2968:
        -: 2969:            /* A potential permissive WWW autolink. */
        2: 2970:            if(ch == _T('.')) {
    #####: 2971:                if(line->beg + 3 <= off  &&  md_ascii_eq(STR(off-3), _T("www"), 3)  &&
    #####: 2972:                    (line->beg + 3 == off || ISWHITESPACE(off-4) || ISANYOF(off-4, _T("*_~([")))  &&
    #####: 2973:                    off + 1 < line_end)
        -: 2974:                {
    #####: 2975:                    PUSH_MARK(ch, off-3, off+1, MD_MARK_POTENTIAL_OPENER);
        -: 2976:                    /* Push a dummy as a reserve for a closer. */
    #####: 2977:                    PUSH_MARK('D', off, off, 0);
    #####: 2978:                    off++;
    #####: 2979:                    continue;
        -: 2980:                }
        -: 2981:
    #####: 2982:                off++;
    #####: 2983:                continue;
        -: 2984:            }
        -: 2985:
        -: 2986:            /* A potential table cell boundary. */
        2: 2987:            if(table_mode  &&  ch == _T('|')) {
        2: 2988:                PUSH_MARK(ch, off, off+1, 0);
        2: 2989:                off++;
        2: 2990:                continue;
        -: 2991:            }
        -: 2992:
        -: 2993:            /* A potential strikethrough start/end. */
    #####: 2994:            if(ch == _T('~')) {
    #####: 2995:                OFF tmp = off+1;
        -: 2996:
    #####: 2997:                while(tmp < line_end  &&  CH(tmp) == _T('~'))
    #####: 2998:                    tmp++;
        -: 2999:
    #####: 3000:                PUSH_MARK(ch, off, tmp, MD_MARK_POTENTIAL_OPENER | MD_MARK_POTENTIAL_CLOSER);
    #####: 3001:                off = tmp;
        -: 3002:            }
        -: 3003:
        -: 3004:            /* Turn non-trivial whitespace into single space. */
    #####: 3005:            if(ISWHITESPACE_(ch)) {
    #####: 3006:                OFF tmp = off+1;
        -: 3007:
    #####: 3008:                while(tmp < line_end  &&  ISWHITESPACE(tmp))
    #####: 3009:                    tmp++;
        -: 3010:
    #####: 3011:                if(tmp - off > 1  ||  ch != _T(' '))
    #####: 3012:                    PUSH_MARK(ch, off, tmp, MD_MARK_RESOLVED);
        -: 3013:
    #####: 3014:                off = tmp;
    #####: 3015:                continue;
        -: 3016:            }
        -: 3017:
        -: 3018:            /* NULL character. */
    #####: 3019:            if(ch == _T('\0')) {
    #####: 3020:                PUSH_MARK(ch, off, off+1, MD_MARK_RESOLVED);
    #####: 3021:                off++;
    #####: 3022:                continue;
        -: 3023:            }
        -: 3024:
    #####: 3025:            off++;
        -: 3026:        }
        -: 3027:    }
        -: 3028:
        -: 3029:    /* Add a dummy mark after the end of processed block to simplify
        -: 3030:     * md_process_inlines(). */
        2: 3031:    PUSH_MARK(127, ctx->size+1, ctx->size+1, MD_MARK_RESOLVED);
        -: 3032:
        2: 3033:abort:
        2: 3034:    return ret;
        -: 3035:}
        -: 3036:
        -: 3037:
        -: 3038:/* Analyze whether the back-tick is really start/end mark of a code span.
        -: 3039: * If yes, reset all marks inside of it and setup flags of both marks. */
        -: 3040:static void
    #####: 3041:md_analyze_backtick(MD_CTX* ctx, int mark_index)
        -: 3042:{
    #####: 3043:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 3044:    int opener_index = BACKTICK_OPENERS.tail;
        -: 3045:
        -: 3046:    /* Try to find unresolved opener of the same length. If we find it,
        -: 3047:     * we form a code span. */
    #####: 3048:    while(opener_index >= 0) {
    #####: 3049:        MD_MARK* opener = &ctx->marks[opener_index];
        -: 3050:
    #####: 3051:        if(opener->end - opener->beg == mark->end - mark->beg) {
        -: 3052:            /* Rollback anything found inside it.
        -: 3053:             * (e.g. the code span contains some back-ticks or other special
        -: 3054:             * chars we misinterpreted.) */
    #####: 3055:            md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_ALL);
        -: 3056:
        -: 3057:            /* Resolve the span. */
    #####: 3058:            md_resolve_range(ctx, &BACKTICK_OPENERS, opener_index, mark_index);
        -: 3059:
        -: 3060:            /* Append any space or new line inside the span into the mark
        -: 3061:             * itself to swallow it. */
    #####: 3062:            while(CH(opener->end) == _T(' ')  ||  ISNEWLINE(opener->end))
    #####: 3063:                opener->end++;
    #####: 3064:            if(mark->beg > opener->end) {
    #####: 3065:                while(CH(mark->beg-1) == _T(' ')  ||  ISNEWLINE(mark->beg-1))
    #####: 3066:                    mark->beg--;
        -: 3067:            }
        -: 3068:
        -: 3069:            /* Done. */
        -: 3070:            return;
        -: 3071:        }
        -: 3072:
    #####: 3073:        opener_index = ctx->marks[opener_index].prev;
        -: 3074:    }
        -: 3075:
        -: 3076:    /* We didn't find any matching opener, so we ourselves may be the opener
        -: 3077:     * of some upcoming closer. We also have to handle specially if there is
        -: 3078:     * a backslash mark before it as that can cancel the first backtick. */
    #####: 3079:    if(mark_index > 0  &&  (mark-1)->beg == mark->beg - 1  &&  (mark-1)->ch == '\\') {
    #####: 3080:        if(mark->end - mark->beg == 1) {
        -: 3081:            /* Single escaped backtick. */
        -: 3082:            return;
        -: 3083:        }
        -: 3084:
        -: 3085:        /* Remove the escaped backtick from the opener. */
    #####: 3086:        mark->beg++;
        -: 3087:    }
        -: 3088:
    #####: 3089:    if(mark->flags & MD_MARK_POTENTIAL_OPENER)
    #####: 3090:        md_mark_chain_append(ctx, &BACKTICK_OPENERS, mark_index);
        -: 3091:}
        -: 3092:
        -: 3093:static int
    #####: 3094:md_is_autolink_uri(MD_CTX* ctx, OFF beg, OFF end)
        -: 3095:{
    #####: 3096:    OFF off = beg;
        -: 3097:
        -: 3098:    /* Check for scheme. */
    #####: 3099:    if(off >= end  ||  !ISASCII(off))
        -: 3100:        return FALSE;
    #####: 3101:    off++;
        -: 3102:    while(1) {
    #####: 3103:        if(off >= end)
        -: 3104:            return FALSE;
    #####: 3105:        if(off - beg > 32)
        -: 3106:            return FALSE;
    #####: 3107:        if(CH(off) == _T(':')  &&  off - beg >= 2)
        -: 3108:            break;
    #####: 3109:        if(!ISALNUM(off) && CH(off) != _T('+') && CH(off) != _T('-') && CH(off) != _T('.'))
        -: 3110:            return FALSE;
    #####: 3111:        off++;
        -: 3112:    }
        -: 3113:
        -: 3114:    /* Check the path after the scheme. */
    #####: 3115:    while(off < end) {
    #####: 3116:        if(ISWHITESPACE(off) || ISCNTRL(off) || CH(off) == _T('<') || CH(off) == _T('>'))
        -: 3117:            return FALSE;
    #####: 3118:        off++;
        -: 3119:    }
        -: 3120:
        -: 3121:    return TRUE;
        -: 3122:}
        -: 3123:
        -: 3124:static int
    #####: 3125:md_is_autolink_email(MD_CTX* ctx, OFF beg, OFF end)
        -: 3126:{
    #####: 3127:    OFF off = beg;
        -: 3128:    int label_len;
        -: 3129:
        -: 3130:    /* The code should correspond to this regexp:
        -: 3131:            /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+
        -: 3132:            @[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?
        -: 3133:            (?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
        -: 3134:     */
        -: 3135:
        -: 3136:    /* Username (before '@'). */
    #####: 3137:    while(off < end  &&  (ISALNUM(off) || ISANYOF(off, _T(".!#$%&'*+/=?^_`{|}~-"))))
    #####: 3138:        off++;
    #####: 3139:    if(off <= beg)
        -: 3140:        return FALSE;
        -: 3141:
        -: 3142:    /* '@' */
    #####: 3143:    if(off >= end  ||  CH(off) != _T('@'))
        -: 3144:        return FALSE;
    #####: 3145:    off++;
        -: 3146:
        -: 3147:    /* Labels delimited with '.'; each label is sequence of 1 - 62 alnum
        -: 3148:     * characters or '-', but '-' is not allowed as first or last char. */
    #####: 3149:    label_len = 0;
    #####: 3150:    while(off < end) {
    #####: 3151:        if(ISALNUM(off))
    #####: 3152:            label_len++;
    #####: 3153:        else if(CH(off) == _T('-')  &&  label_len > 0)
    #####: 3154:            label_len++;
    #####: 3155:        else if(CH(off) == _T('.')  &&  label_len > 0  &&  CH(off-1) != _T('-'))
        -: 3156:            label_len = 0;
        -: 3157:        else
        -: 3158:            return FALSE;
        -: 3159:
    #####: 3160:        if(label_len > 63)
        -: 3161:            return FALSE;
        -: 3162:
    #####: 3163:        off++;
        -: 3164:    }
        -: 3165:
    #####: 3166:    if(label_len <= 0  ||  CH(off-1) == _T('-'))
        -: 3167:        return FALSE;
        -: 3168:
        -: 3169:    return TRUE;
        -: 3170:}
        -: 3171:
        -: 3172:static int
    #####: 3173:md_is_autolink(MD_CTX* ctx, OFF beg, OFF end, int* p_missing_mailto)
        -: 3174:{
    #####: 3175:    MD_ASSERT(CH(beg) == _T('<'));
    #####: 3176:    MD_ASSERT(CH(end-1) == _T('>'));
        -: 3177:
    #####: 3178:    beg++;
    #####: 3179:    end--;
        -: 3180:
    #####: 3181:    if(md_is_autolink_uri(ctx, beg, end))
        -: 3182:        return TRUE;
        -: 3183:
    #####: 3184:    if(md_is_autolink_email(ctx, beg, end)) {
    #####: 3185:        *p_missing_mailto = 1;
    #####: 3186:        return TRUE;
        -: 3187:    }
        -: 3188:
        -: 3189:    return FALSE;
        -: 3190:}
        -: 3191:
        -: 3192:static void
    #####: 3193:md_analyze_lt_gt(MD_CTX* ctx, int mark_index, const MD_LINE* lines, int n_lines)
        -: 3194:{
    #####: 3195:    MD_MARK* mark = &ctx->marks[mark_index];
        -: 3196:    int opener_index;
        -: 3197:
        -: 3198:    /* If it is an opener ('<'), remember it. */
    #####: 3199:    if(mark->flags & MD_MARK_POTENTIAL_OPENER) {
    #####: 3200:        md_mark_chain_append(ctx, &LOWERTHEN_OPENERS, mark_index);
        -: 3201:        return;
        -: 3202:    }
        -: 3203:
        -: 3204:    /* Otherwise we are potential closer and we try to resolve with since all
        -: 3205:     * the chained unresolved openers. */
    #####: 3206:    opener_index = LOWERTHEN_OPENERS.head;
    #####: 3207:    while(opener_index >= 0) {
    #####: 3208:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3209:        OFF detected_end;
    #####: 3210:        int is_autolink = 0;
    #####: 3211:        int is_missing_mailto = 0;
    #####: 3212:        int is_raw_html = 0;
        -: 3213:
    #####: 3214:        is_autolink = (md_is_autolink(ctx, opener->beg, mark->end, &is_missing_mailto));
        -: 3215:
    #####: 3216:        if(is_autolink) {
    #####: 3217:            if(is_missing_mailto)
    #####: 3218:                opener->ch = _T('@');
        -: 3219:        } else {
        -: 3220:            /* Identify the line where the opening mark lives. */
        -: 3221:            int line_index = 0;
        -: 3222:            while(1) {
    #####: 3223:                if(opener->beg < lines[line_index].end)
        -: 3224:                    break;
    #####: 3225:                line_index++;
        -: 3226:            }
        -: 3227:
    #####: 3228:            is_raw_html = (md_is_html_any(ctx, lines + line_index,
        -: 3229:                    n_lines - line_index, opener->beg, mark->end, &detected_end));
        -: 3230:        }
        -: 3231:
        -: 3232:        /* Check whether the range forms a valid raw HTML. */
    #####: 3233:        if(is_autolink || is_raw_html) {
    #####: 3234:            md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_ALL);
    #####: 3235:            md_resolve_range(ctx, &LOWERTHEN_OPENERS, opener_index, mark_index);
        -: 3236:
    #####: 3237:            if(is_raw_html) {
        -: 3238:                /* If this fails, it means we have missed some earlier opportunity
        -: 3239:                 * to resolve the opener of raw HTML. */
    #####: 3240:                MD_ASSERT(detected_end == mark->end);
        -: 3241:
        -: 3242:                /* Make these marks zero width so the '<' and '>' are part of its
        -: 3243:                 * contents. */
    #####: 3244:                opener->end = opener->beg;
    #####: 3245:                mark->beg = mark->end;
        -: 3246:
    #####: 3247:                opener->flags &= ~MD_MARK_AUTOLINK;
    #####: 3248:                mark->flags &= ~MD_MARK_AUTOLINK;
        -: 3249:            } else {
    #####: 3250:                opener->flags |= MD_MARK_AUTOLINK;
    #####: 3251:                mark->flags |= MD_MARK_AUTOLINK;
        -: 3252:            }
        -: 3253:
        -: 3254:            /* And we are done. */
    #####: 3255:            return;
        -: 3256:        }
        -: 3257:
    #####: 3258:        opener_index = opener->next;
        -: 3259:    }
        -: 3260:}
        -: 3261:
        -: 3262:static void
    #####: 3263:md_analyze_bracket(MD_CTX* ctx, int mark_index)
        -: 3264:{
        -: 3265:    /* We cannot really resolve links here as for that we would need
        -: 3266:     * more context. E.g. a following pair of brackets (reference link),
        -: 3267:     * or enclosing pair of brackets (if the inner is the link, the outer
        -: 3268:     * one cannot be.)
        -: 3269:     *
        -: 3270:     * Therefore we here only construct a list of resolved '[' ']' pairs
        -: 3271:     * ordered by position of the closer. This allows ur to analyze what is
        -: 3272:     * or is not link in the right order, from inside to outside in case
        -: 3273:     * of nested brackets.
        -: 3274:     *
        -: 3275:     * The resolving itself is deferred into md_resolve_links().
        -: 3276:     */
        -: 3277:
    #####: 3278:    MD_MARK* mark = &ctx->marks[mark_index];
        -: 3279:
    #####: 3280:    if(mark->flags & MD_MARK_POTENTIAL_OPENER) {
    #####: 3281:        md_mark_chain_append(ctx, &BRACKET_OPENERS, mark_index);
        -: 3282:        return;
        -: 3283:    }
        -: 3284:
    #####: 3285:    if(BRACKET_OPENERS.tail >= 0) {
        -: 3286:        /* Pop the opener from the chain. */
    #####: 3287:        int opener_index = BRACKET_OPENERS.tail;
    #####: 3288:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3289:        if(opener->prev >= 0)
    #####: 3290:            ctx->marks[opener->prev].next = -1;
        -: 3291:        else
    #####: 3292:            BRACKET_OPENERS.head = -1;
    #####: 3293:        BRACKET_OPENERS.tail = opener->prev;
        -: 3294:
        -: 3295:        /* Interconnect the opener and closer. */
    #####: 3296:        opener->next = mark_index;
    #####: 3297:        mark->prev = opener_index;
        -: 3298:
        -: 3299:        /* Add the pair into chain of potential links for md_resolve_links().
        -: 3300:         * Note we misuse opener->prev for this as opener->next points to its
        -: 3301:         * closer. */
    #####: 3302:        if(ctx->unresolved_link_tail >= 0)
    #####: 3303:            ctx->marks[ctx->unresolved_link_tail].prev = opener_index;
        -: 3304:        else
    #####: 3305:            ctx->unresolved_link_head = opener_index;
    #####: 3306:        ctx->unresolved_link_tail = opener_index;
    #####: 3307:        opener->prev = -1;
        -: 3308:    }
        -: 3309:}
        -: 3310:
        -: 3311:/* Forward declaration. */
        -: 3312:static void md_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3313:                                     int mark_beg, int mark_end);
        -: 3314:
        -: 3315:static int
        2: 3316:md_resolve_links(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 3317:{
        2: 3318:    int opener_index = ctx->unresolved_link_head;
        2: 3319:    OFF last_link_beg = 0;
        2: 3320:    OFF last_link_end = 0;
        2: 3321:    OFF last_img_beg = 0;
        2: 3322:    OFF last_img_end = 0;
        -: 3323:
        4: 3324:    while(opener_index >= 0) {
    #####: 3325:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3326:        int closer_index = opener->next;
    #####: 3327:        MD_MARK* closer = &ctx->marks[closer_index];
    #####: 3328:        int next_index = opener->prev;
        -: 3329:        MD_MARK* next_opener;
        -: 3330:        MD_MARK* next_closer;
    #####: 3331:        MD_LINK_ATTR attr;
    #####: 3332:        int is_link = FALSE;
        -: 3333:
    #####: 3334:        if(next_index >= 0) {
    #####: 3335:            next_opener = &ctx->marks[next_index];
    #####: 3336:            next_closer = &ctx->marks[next_opener->next];
        -: 3337:        } else {
        -: 3338:            next_opener = NULL;
        -: 3339:            next_closer = NULL;
        -: 3340:        }
        -: 3341:
        -: 3342:        /* If nested ("[ [ ] ]"), we need to make sure that:
        -: 3343:         *   - The outer does not end inside of (...) belonging to the inner.
        -: 3344:         *   - The outer cannot be link if the inner is link (i.e. not image).
        -: 3345:         *
        -: 3346:         * (Note we here analyze from inner to outer as the marks are ordered
        -: 3347:         * by closer->beg.)
        -: 3348:         */
    #####: 3349:        if((opener->beg < last_link_beg  &&  closer->end < last_link_end)  ||
    #####: 3350:           (opener->beg < last_img_beg  &&  closer->end < last_img_end)  ||
    #####: 3351:           (opener->beg < last_link_end  &&  opener->ch == '['))
        -: 3352:        {
    #####: 3353:            opener_index = next_index;
    #####: 3354:            continue;
        -: 3355:        }
        -: 3356:
    #####: 3357:        if(next_opener != NULL  &&  next_opener->beg == closer->end) {
    #####: 3358:            if(next_closer->beg > closer->end + 1) {
        -: 3359:                /* Might be full reference link. */
    #####: 3360:                is_link = md_is_link_reference(ctx, lines, n_lines, next_opener->beg, next_closer->end, &attr);
        -: 3361:            } else {
        -: 3362:                /* Might be shortcut reference link. */
    #####: 3363:                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);
        -: 3364:            }
        -: 3365:
    #####: 3366:            if(is_link < 0)
    #####: 3367:                return -1;
        -: 3368:
    #####: 3369:            if(is_link) {
        -: 3370:                /* Eat the 2nd "[...]". */
    #####: 3371:                closer->end = next_closer->end;
        -: 3372:            }
        -: 3373:        } else {
    #####: 3374:            if(closer->end < ctx->size  &&  CH(closer->end) == _T('(')) {
        -: 3375:                /* Might be inline link. */
    #####: 3376:                OFF inline_link_end = -1;
        -: 3377:
    #####: 3378:                is_link = md_is_inline_link_spec(ctx, lines, n_lines, closer->end, &inline_link_end, &attr);
    #####: 3379:                if(is_link < 0)
    #####: 3380:                    return -1;
        -: 3381:
        -: 3382:                /* Check the closing ')' is not inside an already resolved range
        -: 3383:                 * (i.e. a range with a higher priority), e.g. a code span. */
    #####: 3384:                if(is_link) {
    #####: 3385:                    int i = closer_index + 1;
        -: 3386:
    #####: 3387:                    while(i < ctx->n_marks) {
    #####: 3388:                        MD_MARK* mark = &ctx->marks[i];
        -: 3389:
    #####: 3390:                        if(mark->beg >= inline_link_end)
        -: 3391:                            break;
    #####: 3392:                        if((mark->flags & (MD_MARK_OPENER | MD_MARK_RESOLVED)) == (MD_MARK_OPENER | MD_MARK_RESOLVED)) {
    #####: 3393:                            if(ctx->marks[mark->next].beg >= inline_link_end) {
        -: 3394:                                /* Cancel the link status. */
    #####: 3395:                                if(attr.title_needs_free)
    #####: 3396:                                    free(attr.title);
        -: 3397:                                is_link = FALSE;
        -: 3398:                                break;
        -: 3399:                            }
        -: 3400:
    #####: 3401:                            i = mark->next + 1;
        -: 3402:                        } else {
    #####: 3403:                            i++;
        -: 3404:                        }
        -: 3405:                    }
        -: 3406:                }
        -: 3407:
    #####: 3408:                if(is_link) {
        -: 3409:                    /* Eat the "(...)" */
    #####: 3410:                    closer->end = inline_link_end;
        -: 3411:                }
        -: 3412:            }
        -: 3413:
    #####: 3414:            if(!is_link) {
        -: 3415:                /* Might be collapsed reference link. */
    #####: 3416:                is_link = md_is_link_reference(ctx, lines, n_lines, opener->beg, closer->end, &attr);
    #####: 3417:                if(is_link < 0)
        -: 3418:                    return -1;
        -: 3419:            }
        -: 3420:        }
        -: 3421:
    #####: 3422:        if(is_link) {
        -: 3423:            /* Resolve the brackets as a link. */
    #####: 3424:            opener->flags |= MD_MARK_OPENER | MD_MARK_RESOLVED;
    #####: 3425:            closer->flags |= MD_MARK_CLOSER | MD_MARK_RESOLVED;
        -: 3426:
        -: 3427:            /* If it is a link, we store the destination and title in the two
        -: 3428:             * dummy marks after the opener. */
    #####: 3429:            MD_ASSERT(ctx->marks[opener_index+1].ch == 'D');
    #####: 3430:            ctx->marks[opener_index+1].beg = attr.dest_beg;
    #####: 3431:            ctx->marks[opener_index+1].end = attr.dest_end;
        -: 3432:
    #####: 3433:            MD_ASSERT(ctx->marks[opener_index+2].ch == 'D');
    #####: 3434:            md_mark_store_ptr(ctx, opener_index+2, attr.title);
    #####: 3435:            if(attr.title_needs_free)
    #####: 3436:                md_mark_chain_append(ctx, &PTR_CHAIN, opener_index+2);
    #####: 3437:            ctx->marks[opener_index+2].prev = attr.title_size;
        -: 3438:
    #####: 3439:            if(opener->ch == '[') {
    #####: 3440:                last_link_beg = opener->beg;
    #####: 3441:                last_link_end = closer->end;
        -: 3442:            } else {
    #####: 3443:                last_img_beg = opener->beg;
    #####: 3444:                last_img_end = closer->end;
        -: 3445:            }
        -: 3446:
    #####: 3447:            md_analyze_link_contents(ctx, lines, n_lines, opener_index+1, closer_index);
        -: 3448:        }
        -: 3449:
    #####: 3450:        opener_index = next_index;
        -: 3451:    }
        -: 3452:
        -: 3453:    return 0;
        -: 3454:}
        -: 3455:
        -: 3456:/* Analyze whether the mark '&' starts a HTML entity.
        -: 3457: * If so, update its flags as well as flags of corresponding closer ';'. */
        -: 3458:static void
    #####: 3459:md_analyze_entity(MD_CTX* ctx, int mark_index)
        -: 3460:{
    #####: 3461:    MD_MARK* opener = &ctx->marks[mark_index];
        -: 3462:    MD_MARK* closer;
    #####: 3463:    OFF off;
        -: 3464:
        -: 3465:    /* Cannot be entity if there is no closer as the next mark.
        -: 3466:     * (Any other mark between would mean strange character which cannot be
        -: 3467:     * part of the entity.
        -: 3468:     *
        -: 3469:     * So we can do all the work on '&' and do not call this later for the
        -: 3470:     * closing mark ';'.
        -: 3471:     */
    #####: 3472:    if(mark_index + 1 >= ctx->n_marks)
    #####: 3473:        return;
    #####: 3474:    closer = &ctx->marks[mark_index+1];
    #####: 3475:    if(closer->ch != ';')
        -: 3476:        return;
        -: 3477:
    #####: 3478:    if(md_is_entity(ctx, opener->beg, closer->end, &off)) {
    #####: 3479:        MD_ASSERT(off == closer->end);
        -: 3480:
    #####: 3481:        md_resolve_range(ctx, NULL, mark_index, mark_index+1);
    #####: 3482:        opener->end = closer->end;
        -: 3483:    }
        -: 3484:}
        -: 3485:
        -: 3486:static void
        -: 3487:md_analyze_table_cell_boundary(MD_CTX* ctx, int mark_index)
        -: 3488:{
        2: 3489:    MD_MARK* mark = &ctx->marks[mark_index];
        2: 3490:    mark->flags |= MD_MARK_RESOLVED;
        -: 3491:
        4: 3492:    md_mark_chain_append(ctx, &TABLECELLBOUNDARIES, mark_index);
        2: 3493:    ctx->n_table_cell_boundaries++;
        -: 3494:}
        -: 3495:
        -: 3496:/* Split a longer mark into two. The new mark takes the given count of
        -: 3497: * characters. May only be called if an adequate number of dummy 'D' marks
        -: 3498: * follows.
        -: 3499: */
        -: 3500:static int
    #####: 3501:md_split_simple_pairing_mark(MD_CTX* ctx, int mark_index, SZ n)
        -: 3502:{
    #####: 3503:    MD_MARK* mark = &ctx->marks[mark_index];
    #####: 3504:    int new_mark_index = mark_index + (mark->end - mark->beg - n);
    #####: 3505:    MD_MARK* dummy = &ctx->marks[new_mark_index];
        -: 3506:
    #####: 3507:    MD_ASSERT(mark->end - mark->beg > n);
    #####: 3508:    MD_ASSERT(dummy->ch == 'D');
        -: 3509:
    #####: 3510:    memcpy(dummy, mark, sizeof(MD_MARK));
    #####: 3511:    mark->end -= n;
    #####: 3512:    dummy->beg = mark->end;
        -: 3513:
    #####: 3514:    return new_mark_index;
        -: 3515:}
        -: 3516:
        -: 3517:static void
    #####: 3518:md_analyze_simple_pairing_mark(MD_CTX* ctx, MD_MARKCHAIN* chain, int mark_index,
        -: 3519:                               int apply_rule_of_three)
        -: 3520:{
    #####: 3521:    MD_MARK* mark = &ctx->marks[mark_index];
        -: 3522:
        -: 3523:    /* If we can be a closer, try to resolve with the preceding opener. */
    #####: 3524:    if((mark->flags & MD_MARK_POTENTIAL_CLOSER)  &&  chain->tail >= 0) {
    #####: 3525:        int opener_index = chain->tail;
    #####: 3526:        MD_MARK* opener = &ctx->marks[opener_index];
    #####: 3527:        SZ opener_size = opener->end - opener->beg;
    #####: 3528:        SZ closer_size = mark->end - mark->beg;
        -: 3529:
        -: 3530:        /* Apply the "rule of three". */
    #####: 3531:        if(apply_rule_of_three) {
    #####: 3532:            while((mark->flags & MD_MARK_EMPH_INTRAWORD) || (opener->flags & MD_MARK_EMPH_INTRAWORD)) {
        -: 3533:                SZ opener_orig_size_modulo3;
        -: 3534:
    #####: 3535:                switch(opener->flags & MD_MARK_EMPH_MODULO3_MASK) {
        -: 3536:                    case MD_MARK_EMPH_MODULO3_0:    opener_orig_size_modulo3 = 0; break;
    #####: 3537:                    case MD_MARK_EMPH_MODULO3_1:    opener_orig_size_modulo3 = 1; break;
    #####: 3538:                    case MD_MARK_EMPH_MODULO3_2:    opener_orig_size_modulo3 = 2; break;
    #####: 3539:                    default:                        MD_UNREACHABLE(); break;
        -: 3540:                }
        -: 3541:
    #####: 3542:                if((opener_orig_size_modulo3 + closer_size) % 3 != 0) {
        -: 3543:                    /* This opener is suitable. */
        -: 3544:                    break;
        -: 3545:                }
        -: 3546:
    #####: 3547:                if(opener->prev >= 0) {
        -: 3548:                    /* Try previous opener. */
    #####: 3549:                    opener_index = opener->prev;
    #####: 3550:                    opener = &ctx->marks[opener_index];
    #####: 3551:                    opener_size = opener->end - opener->beg;
    #####: 3552:                    closer_size = mark->end - mark->beg;
        -: 3553:                } else {
        -: 3554:                    /* No suitable opener found. */
        -: 3555:                    goto cannot_resolve;
        -: 3556:                }
        -: 3557:            }
        -: 3558:        }
        -: 3559:
    #####: 3560:        if(opener_size > closer_size) {
    #####: 3561:            opener_index = md_split_simple_pairing_mark(ctx, opener_index, closer_size);
    #####: 3562:            md_mark_chain_append(ctx, chain, opener_index);
    #####: 3563:        } else if(opener_size < closer_size) {
    #####: 3564:            md_split_simple_pairing_mark(ctx, mark_index, closer_size - opener_size);
        -: 3565:        }
        -: 3566:
    #####: 3567:        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);
    #####: 3568:        md_resolve_range(ctx, chain, opener_index, mark_index);
    #####: 3569:        return;
        -: 3570:    }
        -: 3571:
    #####: 3572:cannot_resolve:
        -: 3573:    /* If not resolved, and we can be an opener, remember the mark for
        -: 3574:     * the future. */
    #####: 3575:    if(mark->flags & MD_MARK_POTENTIAL_OPENER)
    #####: 3576:        md_mark_chain_append(ctx, chain, mark_index);
        -: 3577:}
        -: 3578:
        -: 3579:static inline void
        -: 3580:md_analyze_asterisk(MD_CTX* ctx, int mark_index)
        -: 3581:{
    #####: 3582:    md_analyze_simple_pairing_mark(ctx, &ASTERISK_OPENERS, mark_index, 1);
        -: 3583:}
        -: 3584:
        -: 3585:static inline void
        -: 3586:md_analyze_underscore(MD_CTX* ctx, int mark_index)
        -: 3587:{
    #####: 3588:    md_analyze_simple_pairing_mark(ctx, &UNDERSCORE_OPENERS, mark_index, 1);
        -: 3589:}
        -: 3590:
        -: 3591:static void
    #####: 3592:md_analyze_tilde(MD_CTX* ctx, int mark_index)
        -: 3593:{
        -: 3594:    /* We attempt to be Github Flavored Markdown compatible here. GFM says
        -: 3595:     * that length of the tilde sequence is not important at all. Note that
        -: 3596:     * implies the TILDE_OPENERS chain can have at most one item. */
        -: 3597:
    #####: 3598:    if(TILDE_OPENERS.head >= 0) {
        -: 3599:        /* The chain already contains an opener, so we may resolve the span. */
    #####: 3600:        int opener_index = TILDE_OPENERS.head;
        -: 3601:
    #####: 3602:        md_rollback(ctx, opener_index, mark_index, MD_ROLLBACK_CROSSING);
    #####: 3603:        md_resolve_range(ctx, &TILDE_OPENERS, opener_index, mark_index);
        -: 3604:    } else {
        -: 3605:        /* We can only be opener. */
    #####: 3606:        md_mark_chain_append(ctx, &TILDE_OPENERS, mark_index);
        -: 3607:    }
    #####: 3608:}
        -: 3609:
        -: 3610:static void
    #####: 3611:md_analyze_permissive_url_autolink(MD_CTX* ctx, int mark_index)
        -: 3612:{
    #####: 3613:    MD_MARK* opener = &ctx->marks[mark_index];
    #####: 3614:    int closer_index = mark_index + 1;
    #####: 3615:    MD_MARK* closer = &ctx->marks[mark_index + 1];
        -: 3616:    MD_MARK* next_resolved_mark;
    #####: 3617:    OFF off = opener->end;
    #####: 3618:    int seen_dot = FALSE;
    #####: 3619:    int seen_underscore_or_hyphen[2] = { FALSE, FALSE };
        -: 3620:
        -: 3621:    /* Check for domain. */
    #####: 3622:    while(off < ctx->size) {
    #####: 3623:        if(ISALNUM(off)) {
    #####: 3624:            off++;
    #####: 3625:        } else if(CH(off) == _T('.')) {
    #####: 3626:            seen_dot = TRUE;
    #####: 3627:            seen_underscore_or_hyphen[0] = seen_underscore_or_hyphen[1];
    #####: 3628:            seen_underscore_or_hyphen[1] = FALSE;
    #####: 3629:            off++;
    #####: 3630:        } else if(ISANYOF2(off, _T('-'), _T('_'))) {
    #####: 3631:            seen_underscore_or_hyphen[1] = TRUE;
    #####: 3632:            off++;
        -: 3633:        } else {
        -: 3634:            break;
        -: 3635:        }
        -: 3636:    }
        -: 3637:
    #####: 3638:    if(off <= opener->end || !seen_dot || seen_underscore_or_hyphen[0] || seen_underscore_or_hyphen[1])
        -: 3639:        return;
        -: 3640:
        -: 3641:    /* Check for path. */
    #####: 3642:    next_resolved_mark = closer + 1;
    #####: 3643:    while(next_resolved_mark->ch == 'D' || !(next_resolved_mark->flags & MD_MARK_RESOLVED))
    #####: 3644:        next_resolved_mark++;
    #####: 3645:    while(off < next_resolved_mark->beg  &&  CH(off) != _T('<')  &&  !ISWHITESPACE(off)  &&  !ISNEWLINE(off))
    #####: 3646:        off++;
        -: 3647:
        -: 3648:    /* Path validation. */
    #####: 3649:    if(ISANYOF(off-1, _T("?!.,:*_~)"))) {
    #####: 3650:        if(CH(off-1) != _T(')')) {
        -: 3651:            off--;
        -: 3652:        } else {
        -: 3653:            int parenthesis_balance = 0;
        -: 3654:            OFF tmp;
        -: 3655:
    #####: 3656:            for(tmp = opener->end; tmp < off; tmp++) {
    #####: 3657:                if(CH(tmp) == _T('('))
    #####: 3658:                    parenthesis_balance++;
    #####: 3659:                else if(CH(tmp) == _T(')'))
    #####: 3660:                    parenthesis_balance--;
        -: 3661:            }
        -: 3662:
    #####: 3663:            if(parenthesis_balance < 0)
    #####: 3664:                off--;
        -: 3665:        }
        -: 3666:    }
        -: 3667:
        -: 3668:    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero
        -: 3669:     * length so all the contents becomes the link text. */
    #####: 3670:    MD_ASSERT(closer->ch == 'D');
    #####: 3671:    opener->end = opener->beg;
    #####: 3672:    closer->ch = opener->ch;
    #####: 3673:    closer->beg = off;
    #####: 3674:    closer->end = off;
    #####: 3675:    md_resolve_range(ctx, NULL, mark_index, closer_index);
        -: 3676:}
        -: 3677:
        -: 3678:/* The permissive autolinks do not have to be enclosed in '<' '>' but we
        -: 3679: * instead impose stricter rules what is understood as an e-mail address
        -: 3680: * here. Actually any non-alphanumeric characters with exception of '.'
        -: 3681: * are prohibited both in username and after '@'. */
        -: 3682:static void
    #####: 3683:md_analyze_permissive_email_autolink(MD_CTX* ctx, int mark_index)
        -: 3684:{
    #####: 3685:    MD_MARK* opener = &ctx->marks[mark_index];
        -: 3686:    int closer_index;
        -: 3687:    MD_MARK* closer;
    #####: 3688:    OFF beg = opener->beg;
    #####: 3689:    OFF end = opener->end;
    #####: 3690:    int dot_count = 0;
        -: 3691:
    #####: 3692:    MD_ASSERT(CH(beg) == _T('@'));
        -: 3693:
        -: 3694:    /* Scan for name before '@'. */
    #####: 3695:    while(beg > 0  &&  (ISALNUM(beg-1) || ISANYOF(beg-1, _T(".-_+"))))
        -: 3696:        beg--;
        -: 3697:
        -: 3698:    /* Scan for domain after '@'. */
    #####: 3699:    while(end < ctx->size  &&  (ISALNUM(end) || ISANYOF(end, _T(".-_")))) {
    #####: 3700:        if(CH(end) == _T('.'))
    #####: 3701:            dot_count++;
    #####: 3702:        end++;
        -: 3703:    }
    #####: 3704:    if(CH(end-1) == _T('.')) {  /* Final '.' not part of it. */
    #####: 3705:        dot_count--;
    #####: 3706:        end--;
        -: 3707:    }
    #####: 3708:    else if(ISANYOF2(end-1, _T('-'), _T('_'))) /* These are forbidden at the end. */
        -: 3709:        return;
    #####: 3710:    if(CH(end-1) == _T('@')  ||  dot_count == 0)
        -: 3711:        return;
        -: 3712:
        -: 3713:    /* Ok. Lets call it auto-link. Adapt opener and create closer to zero
        -: 3714:     * length so all the contents becomes the link text. */
    #####: 3715:    closer_index = mark_index + 1;
    #####: 3716:    closer = &ctx->marks[closer_index];
    #####: 3717:    MD_ASSERT(closer->ch == 'D');
        -: 3718:
    #####: 3719:    opener->beg = beg;
    #####: 3720:    opener->end = beg;
    #####: 3721:    closer->ch = opener->ch;
    #####: 3722:    closer->beg = end;
    #####: 3723:    closer->end = end;
    #####: 3724:    md_resolve_range(ctx, NULL, mark_index, closer_index);
        -: 3725:}
        -: 3726:
        -: 3727:static inline void
        6: 3728:md_analyze_marks(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3729:                 int mark_beg, int mark_end, const CHAR* mark_chars)
        -: 3730:{
        6: 3731:    int i = mark_beg;
        -: 3732:
       24: 3733:    while(i < mark_end) {
       12: 3734:        MD_MARK* mark = &ctx->marks[i];
        -: 3735:
        -: 3736:        /* Skip resolved spans. */
       12: 3737:        if(mark->flags & MD_MARK_RESOLVED) {
        6: 3738:            if(mark->flags & MD_MARK_OPENER) {
    #####: 3739:                MD_ASSERT(i < mark->next);
    #####: 3740:                i = mark->next + 1;
        -: 3741:            } else {
        6: 3742:                i++;
        -: 3743:            }
        6: 3744:            continue;
        -: 3745:        }
        -: 3746:
        -: 3747:        /* Skip marks we do not want to deal with. */
       12: 3748:        if(!ISANYOF_(mark->ch, mark_chars)) {
        4: 3749:            i++;
        4: 3750:            continue;
        -: 3751:        }
        -: 3752:
        -: 3753:        /* Analyze the mark. */
        2: 3754:        switch(mark->ch) {
    #####: 3755:            case '`':   md_analyze_backtick(ctx, i); break;
    #####: 3756:            case '<':   /* Pass through. */
    #####: 3757:            case '>':   md_analyze_lt_gt(ctx, i, lines, n_lines); break;
    #####: 3758:            case '[':   /* Pass through. */
        -: 3759:            case '!':   /* Pass through. */
    #####: 3760:            case ']':   md_analyze_bracket(ctx, i); break;
    #####: 3761:            case '&':   md_analyze_entity(ctx, i); break;
        2: 3762:            case '|':   md_analyze_table_cell_boundary(ctx, i); break;
    #####: 3763:            case '*':   md_analyze_asterisk(ctx, i); break;
    #####: 3764:            case '_':   md_analyze_underscore(ctx, i); break;
    #####: 3765:            case '~':   md_analyze_tilde(ctx, i); break;
    #####: 3766:            case '.':   /* Pass through. */
    #####: 3767:            case ':':   md_analyze_permissive_url_autolink(ctx, i); break;
    #####: 3768:            case '@':   md_analyze_permissive_email_autolink(ctx, i); break;
        -: 3769:        }
        -: 3770:
        2: 3771:        i++;
        -: 3772:    }
        6: 3773:}
        -: 3774:
        -: 3775:/* Analyze marks (build ctx->marks). */
        -: 3776:static int
        2: 3777:md_analyze_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines, int table_mode)
        -: 3778:{
        -: 3779:    int ret;
        -: 3780:
        -: 3781:    /* Reset the previously collected stack of marks. */
        2: 3782:    ctx->n_marks = 0;
        -: 3783:
        -: 3784:    /* Collect all marks. */
        2: 3785:    if(md_collect_marks(ctx, lines, n_lines, table_mode) != 0)
        -: 3786:        return -1;
        -: 3787:
        -: 3788:    /* We analyze marks in few groups to handle their precedence. */
        -: 3789:    /* (1) Entities; code spans; autolinks; raw HTML. */
        2: 3790:    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("&`<>"));
        2: 3791:    BACKTICK_OPENERS.head = -1;
        2: 3792:    BACKTICK_OPENERS.tail = -1;
        2: 3793:    LOWERTHEN_OPENERS.head = -1;
        2: 3794:    LOWERTHEN_OPENERS.tail = -1;
        -: 3795:    /* (2) Links. */
        2: 3796:    md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("[]!"));
        2: 3797:    MD_CHECK(md_resolve_links(ctx, lines, n_lines));
        2: 3798:    BRACKET_OPENERS.head = -1;
        2: 3799:    BRACKET_OPENERS.tail = -1;
        2: 3800:    ctx->unresolved_link_head = -1;
        2: 3801:    ctx->unresolved_link_tail = -1;
        2: 3802:    if(table_mode) {
        -: 3803:        /* (3a) Analyze table cell boundaries.
        -: 3804:         * Note we reset TABLECELLBOUNDARIES chain prior to the call md_analyze_marks(),
        -: 3805:         * not after, because caller may need it. */
        2: 3806:        MD_ASSERT(n_lines == 1);
        2: 3807:        TABLECELLBOUNDARIES.head = -1;
        2: 3808:        TABLECELLBOUNDARIES.tail = -1;
        2: 3809:        ctx->n_table_cell_boundaries = 0;
        2: 3810:        md_analyze_marks(ctx, lines, n_lines, 0, ctx->n_marks, _T("|"));
        -: 3811:    } else {
        -: 3812:        /* (3b) Emphasis and strong emphasis; permissive autolinks. */
    #####: 3813:        md_analyze_link_contents(ctx, lines, n_lines, 0, ctx->n_marks);
        -: 3814:    }
        -: 3815:
    #####: 3816:abort:
        -: 3817:    return ret;
        -: 3818:}
        -: 3819:
        -: 3820:static void
        -: 3821:md_analyze_link_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines,
        -: 3822:                         int mark_beg, int mark_end)
        -: 3823:{
    #####: 3824:    md_analyze_marks(ctx, lines, n_lines, mark_beg, mark_end, _T("*_~@:."));
    #####: 3825:    ASTERISK_OPENERS.head = -1;
    #####: 3826:    ASTERISK_OPENERS.tail = -1;
    #####: 3827:    UNDERSCORE_OPENERS.head = -1;
    #####: 3828:    UNDERSCORE_OPENERS.tail = -1;
    #####: 3829:    TILDE_OPENERS.head = -1;
    #####: 3830:    TILDE_OPENERS.tail = -1;
        -: 3831:}
        -: 3832:
        -: 3833:static int
    #####: 3834:md_enter_leave_span_a(MD_CTX* ctx, int enter, MD_SPANTYPE type,
        -: 3835:                      const CHAR* dest, SZ dest_size, int prohibit_escapes_in_dest,
        -: 3836:                      const CHAR* title, SZ title_size)
        -: 3837:{
    #####: 3838:    MD_ATTRIBUTE_BUILD href_build;
    #####: 3839:    MD_ATTRIBUTE_BUILD title_build;
    #####: 3840:    MD_SPAN_A_DETAIL det;
    #####: 3841:    int ret = 0;
        -: 3842:
        -: 3843:    /* Note we here rely on fact that MD_SPAN_A_DETAIL and
        -: 3844:     * MD_SPAN_IMG_DETAIL are binary-compatible. */
    #####: 3845:    memset(&det, 0, sizeof(MD_SPAN_A_DETAIL));
    #####: 3846:    MD_CHECK(md_build_attribute(ctx, dest, dest_size,
        -: 3847:                    (prohibit_escapes_in_dest ? MD_BUILD_ATTR_NO_ESCAPES : 0),
        -: 3848:                    &det.href, &href_build));
    #####: 3849:    MD_CHECK(md_build_attribute(ctx, title, title_size, 0, &det.title, &title_build));
        -: 3850:
    #####: 3851:    if(enter)
    #####: 3852:        MD_ENTER_SPAN(type, &det);
        -: 3853:    else
    #####: 3854:        MD_LEAVE_SPAN(type, &det);
        -: 3855:
    #####: 3856:abort:
    #####: 3857:    md_free_attribute(ctx, &href_build);
    #####: 3858:    md_free_attribute(ctx, &title_build);
    #####: 3859:    return ret;
        -: 3860:}
        -: 3861:
        -: 3862:/* Render the output, accordingly to the analyzed ctx->marks. */
        -: 3863:static int
    #####: 3864:md_process_inlines(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 3865:{
        -: 3866:    MD_TEXTTYPE text_type;
    #####: 3867:    const MD_LINE* line = lines;
    #####: 3868:    MD_MARK* prev_mark = NULL;
        -: 3869:    MD_MARK* mark;
    #####: 3870:    OFF off = lines[0].beg;
    #####: 3871:    OFF end = lines[n_lines-1].end;
    #####: 3872:    int enforce_hardbreak = 0;
    #####: 3873:    int ret = 0;
        -: 3874:
        -: 3875:    /* Find first resolved mark. Note there is always at least one resolved
        -: 3876:     * mark,  the dummy last one after the end of the latest line we actually
        -: 3877:     * never really reach. This saves us of a lot of special checks and cases
        -: 3878:     * in this function. */
    #####: 3879:    mark = ctx->marks;
    #####: 3880:    while(!(mark->flags & MD_MARK_RESOLVED))
    #####: 3881:        mark++;
        -: 3882:
        -: 3883:    text_type = MD_TEXT_NORMAL;
        -: 3884:
        -: 3885:    while(1) {
        -: 3886:        /* Process the text up to the next mark or end-of-line. */
    #####: 3887:        OFF tmp = (line->end < mark->beg ? line->end : mark->beg);
    #####: 3888:        if(tmp > off) {
    #####: 3889:            MD_TEXT(text_type, STR(off), tmp - off);
        -: 3890:            off = tmp;
        -: 3891:        }
        -: 3892:
        -: 3893:        /* If reached the mark, process it and move to next one. */
    #####: 3894:        if(off >= mark->beg) {
    #####: 3895:            switch(mark->ch) {
    #####: 3896:                case '\\':      /* Backslash escape. */
    #####: 3897:                    if(ISNEWLINE(mark->beg+1))
        -: 3898:                        enforce_hardbreak = 1;
        -: 3899:                    else
    #####: 3900:                        MD_TEXT(text_type, STR(mark->beg+1), 1);
        -: 3901:                    break;
        -: 3902:
        -: 3903:                case ' ':       /* Non-trivial space. */
    #####: 3904:                    MD_TEXT(text_type, _T(" "), 1);
        -: 3905:                    break;
        -: 3906:
    #####: 3907:                case '`':       /* Code span. */
    #####: 3908:                    if(mark->flags & MD_MARK_OPENER) {
    #####: 3909:                        MD_ENTER_SPAN(MD_SPAN_CODE, NULL);
        -: 3910:                        text_type = MD_TEXT_CODE;
        -: 3911:                    } else {
    #####: 3912:                        MD_LEAVE_SPAN(MD_SPAN_CODE, NULL);
        -: 3913:                        text_type = MD_TEXT_NORMAL;
        -: 3914:                    }
        -: 3915:                    break;
        -: 3916:
    #####: 3917:                case '_':
        -: 3918:                case '*':       /* Emphasis, strong emphasis. */
    #####: 3919:                    if(mark->flags & MD_MARK_OPENER) {
    #####: 3920:                        if((mark->end - off) % 2) {
    #####: 3921:                            MD_ENTER_SPAN(MD_SPAN_EM, NULL);
    #####: 3922:                            off++;
        -: 3923:                        }
    #####: 3924:                        while(off + 1 < mark->end) {
    #####: 3925:                            MD_ENTER_SPAN(MD_SPAN_STRONG, NULL);
    #####: 3926:                            off += 2;
        -: 3927:                        }
        -: 3928:                    } else {
    #####: 3929:                        while(off + 1 < mark->end) {
    #####: 3930:                            MD_LEAVE_SPAN(MD_SPAN_STRONG, NULL);
    #####: 3931:                            off += 2;
        -: 3932:                        }
    #####: 3933:                        if((mark->end - off) % 2) {
    #####: 3934:                            MD_LEAVE_SPAN(MD_SPAN_EM, NULL);
        -: 3935:                            off++;
        -: 3936:                        }
        -: 3937:                    }
        -: 3938:                    break;
        -: 3939:
    #####: 3940:                case '~':
    #####: 3941:                    if(mark->flags & MD_MARK_OPENER)
    #####: 3942:                        MD_ENTER_SPAN(MD_SPAN_DEL, NULL);
        -: 3943:                    else
    #####: 3944:                        MD_LEAVE_SPAN(MD_SPAN_DEL, NULL);
        -: 3945:                    break;
        -: 3946:
    #####: 3947:                case '[':       /* Link, image. */
        -: 3948:                case '!':
        -: 3949:                case ']':
        -: 3950:                {
    #####: 3951:                    const MD_MARK* opener = (mark->ch != ']' ? mark : &ctx->marks[mark->prev]);
    #####: 3952:                    const MD_MARK* dest_mark = opener+1;
    #####: 3953:                    const MD_MARK* title_mark = opener+2;
        -: 3954:
    #####: 3955:                    MD_ASSERT(dest_mark->ch == 'D');
    #####: 3956:                    MD_ASSERT(title_mark->ch == 'D');
        -: 3957:
    #####: 3958:                    MD_CHECK(md_enter_leave_span_a(ctx, (mark->ch != ']'),
        -: 3959:                                (opener->ch == '!' ? MD_SPAN_IMG : MD_SPAN_A),
        -: 3960:                                STR(dest_mark->beg), dest_mark->end - dest_mark->beg, FALSE,
        -: 3961:                                md_mark_get_ptr(ctx, title_mark - ctx->marks), title_mark->prev));
        -: 3962:
        -: 3963:                    /* link/image closer may span multiple lines. */
    #####: 3964:                    if(mark->ch == ']') {
    #####: 3965:                        while(mark->end > line->end)
    #####: 3966:                            line++;
        -: 3967:                    }
        -: 3968:
        -: 3969:                    break;
        -: 3970:                }
        -: 3971:
    #####: 3972:                case '<':
        -: 3973:                case '>':       /* Autolink or raw HTML. */
    #####: 3974:                    if(!(mark->flags & MD_MARK_AUTOLINK)) {
        -: 3975:                        /* Raw HTML. */
    #####: 3976:                        if(mark->flags & MD_MARK_OPENER)
        -: 3977:                            text_type = MD_TEXT_HTML;
        -: 3978:                        else
    #####: 3979:                            text_type = MD_TEXT_NORMAL;
        -: 3980:                        break;
        -: 3981:                    }
        -: 3982:                    /* Pass through, if auto-link. */
        -: 3983:
        -: 3984:                case '@':       /* Permissive e-mail autolink. */
        -: 3985:                case ':':       /* Permissive URL autolink. */
        -: 3986:                case '.':       /* Permissive WWW autolink. */
        -: 3987:                {
    #####: 3988:                    const MD_MARK* opener = ((mark->flags & MD_MARK_OPENER) ? mark : &ctx->marks[mark->prev]);
    #####: 3989:                    const MD_MARK* closer = &ctx->marks[opener->next];
    #####: 3990:                    const CHAR* dest = STR(opener->end);
    #####: 3991:                    SZ dest_size = closer->beg - opener->end;
        -: 3992:
    #####: 3993:                    if(opener->ch == '@' || opener->ch == '.') {
    #####: 3994:                        dest_size += 7;
    #####: 3995:                        MD_TEMP_BUFFER(dest_size * sizeof(CHAR));
    #####: 3996:                        memcpy(ctx->buffer,
    #####: 3997:                                (opener->ch == '@' ? _T("mailto:") : _T("http://")),
        -: 3998:                                7 * sizeof(CHAR));
    #####: 3999:                        memcpy(ctx->buffer + 7, dest, (dest_size-7) * sizeof(CHAR));
    #####: 4000:                        dest = ctx->buffer;
        -: 4001:                    }
        -: 4002:
    #####: 4003:                    MD_CHECK(md_enter_leave_span_a(ctx, (mark->flags & MD_MARK_OPENER),
        -: 4004:                                MD_SPAN_A, dest, dest_size, TRUE, NULL, 0));
        -: 4005:                    break;
        -: 4006:                }
        -: 4007:
    #####: 4008:                case '&':       /* Entity. */
    #####: 4009:                    MD_TEXT(MD_TEXT_ENTITY, STR(mark->beg), mark->end - mark->beg);
        -: 4010:                    break;
        -: 4011:
        -: 4012:                case '\0':
    #####: 4013:                    MD_TEXT(MD_TEXT_NULLCHAR, _T(""), 1);
        -: 4014:                    break;
        -: 4015:            }
        -: 4016:
    #####: 4017:            off = mark->end;
        -: 4018:
        -: 4019:            /* Move to next resolved mark. */
    #####: 4020:            prev_mark = mark;
    #####: 4021:            mark++;
    #####: 4022:            while(!(mark->flags & MD_MARK_RESOLVED)  ||  mark->beg < off)
    #####: 4023:                mark++;
        -: 4024:        }
        -: 4025:
        -: 4026:        /* If reached end of line, move to next one. */
    #####: 4027:        if(off >= line->end) {
        -: 4028:            /* If it is the last line, we are done. */
    #####: 4029:            if(off >= end)
        -: 4030:                break;
        -: 4031:
    #####: 4032:            if(text_type == MD_TEXT_CODE) {
        -: 4033:                /* Inside code spans, new lines are transformed into single
        -: 4034:                 * spaces. */
    #####: 4035:                MD_ASSERT(prev_mark != NULL);
    #####: 4036:                MD_ASSERT(prev_mark->ch == '`'  &&  (prev_mark->flags & MD_MARK_OPENER));
    #####: 4037:                MD_ASSERT(mark->ch == '`'  &&  (mark->flags & MD_MARK_CLOSER));
        -: 4038:
    #####: 4039:                if(prev_mark->end < off  &&  off < mark->beg)
    #####: 4040:                    MD_TEXT(MD_TEXT_CODE, _T(" "), 1);
    #####: 4041:            } else if(text_type == MD_TEXT_HTML) {
        -: 4042:                /* Inside raw HTML, we output the new line verbatim, including
        -: 4043:                 * any trailing spaces. */
        -: 4044:                OFF tmp = off;
        -: 4045:
    #####: 4046:                while(tmp < end  &&  ISBLANK(tmp))
    #####: 4047:                    tmp++;
    #####: 4048:                if(tmp > off)
    #####: 4049:                    MD_TEXT(MD_TEXT_HTML, STR(off), tmp - off);
    #####: 4050:                MD_TEXT(MD_TEXT_HTML, _T("\n"), 1);
        -: 4051:            } else {
        -: 4052:                /* Output soft or hard line break. */
    #####: 4053:                MD_TEXTTYPE break_type = MD_TEXT_SOFTBR;
        -: 4054:
    #####: 4055:                if(text_type == MD_TEXT_NORMAL) {
    #####: 4056:                    if(enforce_hardbreak)
        -: 4057:                        break_type = MD_TEXT_BR;
    #####: 4058:                    else if((CH(line->end) == _T(' ') && CH(line->end+1) == _T(' ')))
    #####: 4059:                        break_type = MD_TEXT_BR;
        -: 4060:                }
        -: 4061:
    #####: 4062:                MD_TEXT(break_type, _T("\n"), 1);
        -: 4063:            }
        -: 4064:
        -: 4065:            /* Move to the next line. */
    #####: 4066:            line++;
    #####: 4067:            off = line->beg;
        -: 4068:
    #####: 4069:            enforce_hardbreak = 0;
        -: 4070:        }
        -: 4071:    }
        -: 4072:
    #####: 4073:abort:
    #####: 4074:    return ret;
        -: 4075:}
        -: 4076:
        -: 4077:
        -: 4078:/***************************
        -: 4079: ***  Processing Tables  ***
        -: 4080: ***************************/
        -: 4081:
        -: 4082:static void
    #####: 4083:md_analyze_table_alignment(MD_CTX* ctx, OFF beg, OFF end, MD_ALIGN* align, int n_align)
        -: 4084:{
        -: 4085:    static const MD_ALIGN align_map[] = { MD_ALIGN_DEFAULT, MD_ALIGN_LEFT, MD_ALIGN_RIGHT, MD_ALIGN_CENTER };
    #####: 4086:    OFF off = beg;
        -: 4087:
    #####: 4088:    while(n_align > 0) {
        -: 4089:        int index = 0;  /* index into align_map[] */
        -: 4090:
    #####: 4091:        while(CH(off) != _T('-'))
    #####: 4092:            off++;
    #####: 4093:        if(off > beg  &&  CH(off-1) == _T(':'))
    #####: 4094:            index |= 1;
    #####: 4095:        while(off < end  &&  CH(off) == _T('-'))
    #####: 4096:            off++;
    #####: 4097:        if(off < end  &&  CH(off) == _T(':'))
    #####: 4098:            index |= 2;
        -: 4099:
    #####: 4100:        *align = align_map[index];
    #####: 4101:        align++;
    #####: 4102:        n_align--;
        -: 4103:    }
        -: 4104:
    #####: 4105:}
        -: 4106:
        -: 4107:/* Forward declaration. */
        -: 4108:static int md_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines);
        -: 4109:
        -: 4110:static int
    #####: 4111:md_process_table_cell(MD_CTX* ctx, MD_BLOCKTYPE cell_type, MD_ALIGN align, OFF beg, OFF end)
        -: 4112:{
    #####: 4113:    MD_LINE line;
    #####: 4114:    MD_BLOCK_TD_DETAIL det;
    #####: 4115:    int ret = 0;
        -: 4116:
    #####: 4117:    while(beg < end  &&  ISWHITESPACE(beg))
    #####: 4118:        beg++;
    #####: 4119:    while(end > beg  &&  ISWHITESPACE(end-1))
        -: 4120:        end--;
        -: 4121:
    #####: 4122:    det.align = align;
    #####: 4123:    line.beg = beg;
    #####: 4124:    line.end = end;
        -: 4125:
    #####: 4126:    MD_ENTER_BLOCK(cell_type, &det);
    #####: 4127:    MD_CHECK(md_process_normal_block_contents(ctx, &line, 1));
    #####: 4128:    MD_LEAVE_BLOCK(cell_type, &det);
        -: 4129:
    #####: 4130:abort:
    #####: 4131:    return ret;
        -: 4132:}
        -: 4133:
        -: 4134:static int
    #####: 4135:md_process_table_row(MD_CTX* ctx, MD_BLOCKTYPE cell_type, OFF beg, OFF end,
        -: 4136:                     const MD_ALIGN* align, int n_align)
        -: 4137:{
    #####: 4138:    MD_LINE line = { beg, end };
    #####: 4139:    OFF* pipe_offs = NULL;
        -: 4140:    int i, j, n;
    #####: 4141:    int ret = 0;
        -: 4142:
        -: 4143:    /* Break the line into table cells by identifying pipe characters who
        -: 4144:     * form the cell boundary. */
    #####: 4145:    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));
        -: 4146:
        -: 4147:    /* We have to remember the cell boundaries in local buffer because
        -: 4148:     * ctx->marks[] shall be reused during cell contents processing. */
    #####: 4149:    n = ctx->n_table_cell_boundaries;
    #####: 4150:    pipe_offs = (OFF*) malloc(n * sizeof(OFF));
    #####: 4151:    if(pipe_offs == NULL) {
    #####: 4152:        MD_LOG("malloc() failed.");
        -: 4153:        ret = -1;
        -: 4154:        goto abort;
        -: 4155:    }
    #####: 4156:    for(i = TABLECELLBOUNDARIES.head, j = 0; i >= 0; i = ctx->marks[i].next) {
    #####: 4157:        MD_MARK* mark = &ctx->marks[i];
    #####: 4158:        pipe_offs[j++] = mark->beg;
        -: 4159:    }
        -: 4160:
        -: 4161:    /* Process cells. */
    #####: 4162:    MD_ENTER_BLOCK(MD_BLOCK_TR, NULL);
    #####: 4163:    j = 0;
    #####: 4164:    if(beg < pipe_offs[0]) {
    #####: 4165:        MD_CHECK(md_process_table_cell(ctx, cell_type,
        -: 4166:                    (j < n_align ? align[j++] : MD_ALIGN_DEFAULT),
        -: 4167:                    beg, pipe_offs[0]));
        -: 4168:    }
    #####: 4169:    for(i = 0; i < n-1; i++) {
    #####: 4170:        MD_CHECK(md_process_table_cell(ctx, cell_type,
        -: 4171:                    (j < n_align ? align[j++] : MD_ALIGN_DEFAULT),
        -: 4172:                    pipe_offs[i]+1, pipe_offs[i+1]));
        -: 4173:    }
    #####: 4174:    if(pipe_offs[n-1] < end-1) {
    #####: 4175:        MD_CHECK(md_process_table_cell(ctx, cell_type,
        -: 4176:                    (j < n_align ? align[j++] : MD_ALIGN_DEFAULT),
        -: 4177:                    pipe_offs[n-1]+1, end));
        -: 4178:    }
    #####: 4179:    MD_LEAVE_BLOCK(MD_BLOCK_TR, NULL);
        -: 4180:
    #####: 4181:abort:
    #####: 4182:    free(pipe_offs);
        -: 4183:
        -: 4184:    /* Free any temporary memory blocks stored within some dummy marks. */
    #####: 4185:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4186:        free(md_mark_get_ptr(ctx, i));
    #####: 4187:    PTR_CHAIN.head = -1;
    #####: 4188:    PTR_CHAIN.tail = -1;
        -: 4189:
    #####: 4190:    return ret;
        -: 4191:}
        -: 4192:
        -: 4193:static int
    #####: 4194:md_process_table_block_contents(MD_CTX* ctx, int col_count, const MD_LINE* lines, int n_lines)
        -: 4195:{
        -: 4196:    MD_ALIGN* align;
        -: 4197:    int i;
    #####: 4198:    int ret = 0;
        -: 4199:
        -: 4200:    /* At least the line with column names and the table underline have to
        -: 4201:     * be present. */
    #####: 4202:    MD_ASSERT(n_lines >= 2);
        -: 4203:
    #####: 4204:    align = malloc(col_count * sizeof(MD_ALIGN));
    #####: 4205:    if(align == NULL) {
    #####: 4206:        MD_LOG("malloc() failed.");
        -: 4207:        ret = -1;
        -: 4208:        goto abort;
        -: 4209:    }
        -: 4210:
    #####: 4211:    md_analyze_table_alignment(ctx, lines[1].beg, lines[1].end, align, col_count);
        -: 4212:
    #####: 4213:    MD_ENTER_BLOCK(MD_BLOCK_THEAD, NULL);
    #####: 4214:    MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TH,
        -: 4215:                        lines[0].beg, lines[0].end, align, col_count));
    #####: 4216:    MD_LEAVE_BLOCK(MD_BLOCK_THEAD, NULL);
        -: 4217:
    #####: 4218:    MD_ENTER_BLOCK(MD_BLOCK_TBODY, NULL);
    #####: 4219:    for(i = 2; i < n_lines; i++) {
    #####: 4220:        MD_CHECK(md_process_table_row(ctx, MD_BLOCK_TD,
        -: 4221:                        lines[i].beg, lines[i].end, align, col_count));
        -: 4222:    }
    #####: 4223:    MD_LEAVE_BLOCK(MD_BLOCK_TBODY, NULL);
        -: 4224:
    #####: 4225:abort:
    #####: 4226:    free(align);
    #####: 4227:    return ret;
        -: 4228:}
        -: 4229:
        -: 4230:static int
        2: 4231:md_is_table_row(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 4232:{
        2: 4233:    MD_LINE line = { beg, beg };
        -: 4234:    int i;
        2: 4235:    int ret = FALSE;
        -: 4236:
        -: 4237:    /* Find end of line. */
       10: 4238:    while(line.end < ctx->size  &&  !ISNEWLINE(line.end))
        6: 4239:        line.end++;
        -: 4240:
        2: 4241:    MD_CHECK(md_analyze_inlines(ctx, &line, 1, TRUE));
        -: 4242:
        2: 4243:    if(TABLECELLBOUNDARIES.head >= 0) {
        2: 4244:        if(p_end != NULL)
        1: 4245:            *p_end = line.end;
        -: 4246:        ret = TRUE;
        -: 4247:    }
        -: 4248:
        2: 4249:abort:
        -: 4250:    /* Free any temporary memory blocks stored within some dummy marks. */
        2: 4251:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4252:        free(md_mark_get_ptr(ctx, i));
        2: 4253:    PTR_CHAIN.head = -1;
        2: 4254:    PTR_CHAIN.tail = -1;
        -: 4255:
        2: 4256:    return ret;
        -: 4257:}
        -: 4258:
        -: 4259:
        -: 4260:/**************************
        -: 4261: ***  Processing Block  ***
        -: 4262: **************************/
        -: 4263:
        -: 4264:#define MD_BLOCK_CONTAINER_OPENER   0x01
        -: 4265:#define MD_BLOCK_CONTAINER_CLOSER   0x02
        -: 4266:#define MD_BLOCK_CONTAINER          (MD_BLOCK_CONTAINER_OPENER | MD_BLOCK_CONTAINER_CLOSER)
        -: 4267:#define MD_BLOCK_LOOSE_LIST         0x04
        -: 4268:
        -: 4269:struct MD_BLOCK_tag {
        -: 4270:    MD_BLOCKTYPE type  :  8;
        -: 4271:    unsigned flags     :  8;
        -: 4272:
        -: 4273:    /* MD_BLOCK_H:      Header level (1 - 6)
        -: 4274:     * MD_BLOCK_CODE:   Non-zero if fenced, zero if indented.
        -: 4275:     * MD_BLOCK_TABLE:  Column count (as determined by the table underline)
        -: 4276:     */
        -: 4277:    unsigned data      : 16;
        -: 4278:
        -: 4279:    /* Leaf blocks:     Count of lines (MD_LINE or MD_VERBATIMLINE) on the block.
        -: 4280:     * MD_BLOCK_OL:     Start item number.
        -: 4281:     */
        -: 4282:    unsigned n_lines;
        -: 4283:};
        -: 4284:
        -: 4285:struct MD_CONTAINER_tag {
        -: 4286:    CHAR ch;
        -: 4287:    unsigned is_loose    : 8;
        -: 4288:    unsigned start;
        -: 4289:    unsigned mark_indent;
        -: 4290:    unsigned contents_indent;
        -: 4291:    OFF block_byte_off;
        -: 4292:};
        -: 4293:
        -: 4294:
        -: 4295:static int
    #####: 4296:md_process_normal_block_contents(MD_CTX* ctx, const MD_LINE* lines, int n_lines)
        -: 4297:{
        -: 4298:    int i;
        -: 4299:    int ret;
        -: 4300:
    #####: 4301:    MD_CHECK(md_analyze_inlines(ctx, lines, n_lines, FALSE));
    #####: 4302:    MD_CHECK(md_process_inlines(ctx, lines, n_lines));
        -: 4303:
    #####: 4304:abort:
        -: 4305:    /* Free any temporary memory blocks stored within some dummy marks. */
    #####: 4306:    for(i = PTR_CHAIN.head; i >= 0; i = ctx->marks[i].next)
    #####: 4307:        free(md_mark_get_ptr(ctx, i));
    #####: 4308:    PTR_CHAIN.head = -1;
    #####: 4309:    PTR_CHAIN.tail = -1;
        -: 4310:
    #####: 4311:    return ret;
        -: 4312:}
        -: 4313:
        -: 4314:static int
    #####: 4315:md_process_verbatim_block_contents(MD_CTX* ctx, MD_TEXTTYPE text_type, const MD_VERBATIMLINE* lines, int n_lines)
        -: 4316:{
        -: 4317:    static const CHAR indent_chunk_str[] = _T("                ");
        -: 4318:    static const SZ indent_chunk_size = SIZEOF_ARRAY(indent_chunk_str) - 1;
        -: 4319:
        -: 4320:    int i;
    #####: 4321:    int ret = 0;
        -: 4322:
    #####: 4323:    for(i = 0; i < n_lines; i++) {
    #####: 4324:        const MD_VERBATIMLINE* line = &lines[i];
    #####: 4325:        int indent = line->indent;
        -: 4326:
    #####: 4327:        MD_ASSERT(indent >= 0);
        -: 4328:
        -: 4329:        /* Output code indentation. */
    #####: 4330:        while(indent > SIZEOF_ARRAY(indent_chunk_str)) {
    #####: 4331:            MD_TEXT(text_type, indent_chunk_str, indent_chunk_size);
    #####: 4332:            indent -= SIZEOF_ARRAY(indent_chunk_str);
        -: 4333:        }
    #####: 4334:        if(indent > 0)
    #####: 4335:            MD_TEXT(text_type, indent_chunk_str, indent);
        -: 4336:
        -: 4337:        /* Output the code line itself. */
    #####: 4338:        MD_TEXT_INSECURE(text_type, STR(line->beg), line->end - line->beg);
        -: 4339:
        -: 4340:        /* Enforce end-of-line. */
    #####: 4341:        MD_TEXT(text_type, _T("\n"), 1);
        -: 4342:    }
        -: 4343:
    #####: 4344:abort:
    #####: 4345:    return ret;
        -: 4346:}
        -: 4347:
        -: 4348:static int
    #####: 4349:md_process_code_block_contents(MD_CTX* ctx, int is_fenced, const MD_VERBATIMLINE* lines, int n_lines)
        -: 4350:{
    #####: 4351:    if(is_fenced) {
        -: 4352:        /* Skip the first line in case of fenced code: It is the fence.
        -: 4353:         * (Only the starting fence is present due to logic in md_analyze_line().) */
    #####: 4354:        lines++;
    #####: 4355:        n_lines--;
        -: 4356:    } else {
        -: 4357:        /* Ignore blank lines at start/end of indented code block. */
    #####: 4358:        while(n_lines > 0  &&  lines[0].beg == lines[0].end) {
    #####: 4359:            lines++;
    #####: 4360:            n_lines--;
        -: 4361:        }
    #####: 4362:        while(n_lines > 0  &&  lines[n_lines-1].beg == lines[n_lines-1].end) {
    #####: 4363:            n_lines--;
        -: 4364:        }
        -: 4365:    }
        -: 4366:
    #####: 4367:    if(n_lines == 0)
        -: 4368:        return 0;
        -: 4369:
    #####: 4370:    return md_process_verbatim_block_contents(ctx, MD_TEXT_CODE, lines, n_lines);
        -: 4371:}
        -: 4372:
        -: 4373:static int
    #####: 4374:md_setup_fenced_code_detail(MD_CTX* ctx, const MD_BLOCK* block, MD_BLOCK_CODE_DETAIL* det,
        -: 4375:                            MD_ATTRIBUTE_BUILD* info_build, MD_ATTRIBUTE_BUILD* lang_build)
        -: 4376:{
    #####: 4377:    const MD_VERBATIMLINE* fence_line = (const MD_VERBATIMLINE*)(block + 1);
    #####: 4378:    OFF beg = fence_line->beg;
    #####: 4379:    OFF end = fence_line->end;
        -: 4380:    OFF lang_end;
    #####: 4381:    CHAR fence_ch = CH(fence_line->beg);
    #####: 4382:    int ret = 0;
        -: 4383:
        -: 4384:    /* Skip the fence itself. */
    #####: 4385:    while(beg < ctx->size  &&  CH(beg) == fence_ch)
    #####: 4386:        beg++;
        -: 4387:    /* Trim initial spaces. */
    #####: 4388:    while(beg < ctx->size  &&  CH(beg) == _T(' '))
    #####: 4389:        beg++;
        -: 4390:
        -: 4391:    /* Trim trailing spaces. */
    #####: 4392:    while(end > beg  &&  CH(end-1) == _T(' '))
        -: 4393:        end--;
        -: 4394:
        -: 4395:    /* Build info string attribute. */
    #####: 4396:    MD_CHECK(md_build_attribute(ctx, STR(beg), end - beg, 0, &det->info, info_build));
        -: 4397:
        -: 4398:    /* Build info string attribute. */
        -: 4399:    lang_end = beg;
    #####: 4400:    while(lang_end < end  &&  !ISWHITESPACE(lang_end))
    #####: 4401:        lang_end++;
    #####: 4402:    MD_CHECK(md_build_attribute(ctx, STR(beg), lang_end - beg, 0, &det->lang, lang_build));
        -: 4403:
    #####: 4404:abort:
    #####: 4405:    return ret;
        -: 4406:}
        -: 4407:
        -: 4408:static int
    #####: 4409:md_process_leaf_block(MD_CTX* ctx, const MD_BLOCK* block)
        -: 4410:{
        -: 4411:    union {
        -: 4412:        MD_BLOCK_H_DETAIL header;
        -: 4413:        MD_BLOCK_CODE_DETAIL code;
    #####: 4414:    } det;
    #####: 4415:    MD_ATTRIBUTE_BUILD info_build;
    #####: 4416:    MD_ATTRIBUTE_BUILD lang_build;
        -: 4417:    int is_in_tight_list;
    #####: 4418:    int clean_fence_code_detail = FALSE;
    #####: 4419:    int ret = 0;
        -: 4420:
    #####: 4421:    memset(&det, 0, sizeof(det));
        -: 4422:
    #####: 4423:    if(ctx->n_containers == 0)
        -: 4424:        is_in_tight_list = FALSE;
        -: 4425:    else
    #####: 4426:        is_in_tight_list = !ctx->containers[ctx->n_containers-1].is_loose;
        -: 4427:
    #####: 4428:    switch(block->type) {
    #####: 4429:        case MD_BLOCK_H:
    #####: 4430:            det.header.level = block->data;
    #####: 4431:            break;
        -: 4432:
    #####: 4433:        case MD_BLOCK_CODE:
        -: 4434:            /* For fenced code block, we may need to set the info string. */
    #####: 4435:            if(block->data != 0) {
    #####: 4436:                memset(&det.code, 0, sizeof(MD_BLOCK_CODE_DETAIL));
    #####: 4437:                clean_fence_code_detail = TRUE;
    #####: 4438:                MD_CHECK(md_setup_fenced_code_detail(ctx, block, &det.code, &info_build, &lang_build));
        -: 4439:            }
        -: 4440:            break;
        -: 4441:
        -: 4442:        default:
        -: 4443:            /* Noop. */
        -: 4444:            break;
        -: 4445:    }
        -: 4446:
    #####: 4447:    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)
    #####: 4448:        MD_ENTER_BLOCK(block->type, (void*) &det);
        -: 4449:
        -: 4450:    /* Process the block contents accordingly to is type. */
    #####: 4451:    switch(block->type) {
        -: 4452:        case MD_BLOCK_HR:
        -: 4453:            /* noop */
        -: 4454:            break;
        -: 4455:
    #####: 4456:        case MD_BLOCK_CODE:
    #####: 4457:            MD_CHECK(md_process_code_block_contents(ctx, (block->data != 0),
        -: 4458:                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));
        -: 4459:            break;
        -: 4460:
    #####: 4461:        case MD_BLOCK_HTML:
    #####: 4462:            MD_CHECK(md_process_verbatim_block_contents(ctx, MD_TEXT_HTML,
        -: 4463:                            (const MD_VERBATIMLINE*)(block + 1), block->n_lines));
        -: 4464:            break;
        -: 4465:
    #####: 4466:        case MD_BLOCK_TABLE:
    #####: 4467:            MD_CHECK(md_process_table_block_contents(ctx, block->data,
        -: 4468:                            (const MD_LINE*)(block + 1), block->n_lines));
        -: 4469:            break;
        -: 4470:
    #####: 4471:        default:
    #####: 4472:            MD_CHECK(md_process_normal_block_contents(ctx,
        -: 4473:                            (const MD_LINE*)(block + 1), block->n_lines));
        -: 4474:            break;
        -: 4475:    }
        -: 4476:
    #####: 4477:    if(!is_in_tight_list  ||  block->type != MD_BLOCK_P)
    #####: 4478:        MD_LEAVE_BLOCK(block->type, (void*) &det);
        -: 4479:
    #####: 4480:abort:
    #####: 4481:    if(clean_fence_code_detail) {
    #####: 4482:        md_free_attribute(ctx, &info_build);
    #####: 4483:        md_free_attribute(ctx, &lang_build);
        -: 4484:    }
    #####: 4485:    return ret;
        -: 4486:}
        -: 4487:
        -: 4488:static int
    #####: 4489:md_process_all_blocks(MD_CTX* ctx)
        -: 4490:{
    #####: 4491:    int byte_off = 0;
    #####: 4492:    int ret = 0;
        -: 4493:
        -: 4494:    /* ctx->containers now is not needed for detection of lists and list items
        -: 4495:     * so we reuse it for tracking what lists are loose or tight. We rely
        -: 4496:     * on the fact the vector is large enough to hold the deepest nesting
        -: 4497:     * level of lists. */
    #####: 4498:    ctx->n_containers = 0;
        -: 4499:
    #####: 4500:    while(byte_off < ctx->n_block_bytes) {
    #####: 4501:        MD_BLOCK* block = (MD_BLOCK*)((char*)ctx->block_bytes + byte_off);
        -: 4502:        union {
        -: 4503:            MD_BLOCK_UL_DETAIL ul;
        -: 4504:            MD_BLOCK_OL_DETAIL ol;
    #####: 4505:        } det;
        -: 4506:
    #####: 4507:        switch(block->type) {
    #####: 4508:            case MD_BLOCK_UL:
    #####: 4509:                det.ul.is_tight = (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;
    #####: 4510:                det.ul.mark = (CHAR) block->data;
    #####: 4511:                break;
        -: 4512:
    #####: 4513:            case MD_BLOCK_OL:
    #####: 4514:                det.ol.start = block->n_lines;
    #####: 4515:                det.ol.is_tight =  (block->flags & MD_BLOCK_LOOSE_LIST) ? FALSE : TRUE;
    #####: 4516:                det.ol.mark_delimiter = (CHAR) block->data;
    #####: 4517:                break;
        -: 4518:
        -: 4519:            default:
        -: 4520:                /* noop */
        -: 4521:                break;
        -: 4522:        }
        -: 4523:
    #####: 4524:        if(block->flags & MD_BLOCK_CONTAINER) {
    #####: 4525:            if(block->flags & MD_BLOCK_CONTAINER_CLOSER) {
    #####: 4526:                MD_LEAVE_BLOCK(block->type, &det);
        -: 4527:
    #####: 4528:                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL || block->type == MD_BLOCK_QUOTE)
    #####: 4529:                    ctx->n_containers--;
        -: 4530:            }
        -: 4531:
    #####: 4532:            if(block->flags & MD_BLOCK_CONTAINER_OPENER) {
    #####: 4533:                MD_ENTER_BLOCK(block->type, &det);
        -: 4534:
    #####: 4535:                if(block->type == MD_BLOCK_UL || block->type == MD_BLOCK_OL) {
    #####: 4536:                    ctx->containers[ctx->n_containers].is_loose = (block->flags & MD_BLOCK_LOOSE_LIST);
    #####: 4537:                    ctx->n_containers++;
    #####: 4538:                } else if(block->type == MD_BLOCK_QUOTE) {
        -: 4539:                    /* This causes that any text in a block quote, even if
        -: 4540:                     * nested inside a tight list item, is wrapped with
        -: 4541:                     * <p>...</p>. */
    #####: 4542:                    ctx->containers[ctx->n_containers].is_loose = TRUE;
    #####: 4543:                    ctx->n_containers++;
        -: 4544:                }
        -: 4545:            }
        -: 4546:        } else {
    #####: 4547:            MD_CHECK(md_process_leaf_block(ctx, block));
        -: 4548:
    #####: 4549:            if(block->type == MD_BLOCK_CODE || block->type == MD_BLOCK_HTML)
    #####: 4550:                byte_off += block->n_lines * sizeof(MD_VERBATIMLINE);
        -: 4551:            else
    #####: 4552:                byte_off += block->n_lines * sizeof(MD_LINE);
        -: 4553:        }
        -: 4554:
    #####: 4555:        byte_off += sizeof(MD_BLOCK);
        -: 4556:    }
        -: 4557:
    #####: 4558:    ctx->n_block_bytes = 0;
        -: 4559:
    #####: 4560:abort:
    #####: 4561:    return ret;
        -: 4562:}
        -: 4563:
        -: 4564:
        -: 4565:/************************************
        -: 4566: ***  Grouping Lines into Blocks  ***
        -: 4567: ************************************/
        -: 4568:
        -: 4569:static void*
        8: 4570:md_push_block_bytes(MD_CTX* ctx, int n_bytes)
        -: 4571:{
        -: 4572:    void* ptr;
        -: 4573:
        8: 4574:    if(ctx->n_block_bytes + n_bytes > ctx->alloc_block_bytes) {
        -: 4575:        void* new_block_bytes;
        -: 4576:
        1: 4577:        ctx->alloc_block_bytes = (ctx->alloc_block_bytes > 0 ? ctx->alloc_block_bytes * 2 : 512);
        1: 4578:        new_block_bytes = realloc(ctx->block_bytes, ctx->alloc_block_bytes);
        1: 4579:        if(new_block_bytes == NULL) {
    #####: 4580:            MD_LOG("realloc() failed.");
        -: 4581:            return NULL;
        -: 4582:        }
        -: 4583:
        -: 4584:        /* Fix the ->current_block after the reallocation. */
        1: 4585:        if(ctx->current_block != NULL) {
    #####: 4586:            OFF off_current_block = (char*) ctx->current_block - (char*) ctx->block_bytes;
    #####: 4587:            ctx->current_block = (MD_BLOCK*) ((char*) new_block_bytes + off_current_block);
        -: 4588:        }
        -: 4589:
        1: 4590:        ctx->block_bytes = new_block_bytes;
        -: 4591:    }
        -: 4592:
        8: 4593:    ptr = (char*)ctx->block_bytes + ctx->n_block_bytes;
        8: 4594:    ctx->n_block_bytes += n_bytes;
        8: 4595:    return ptr;
        -: 4596:}
        -: 4597:
        -: 4598:static int
        2: 4599:md_start_new_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* line)
        -: 4600:{
        -: 4601:    MD_BLOCK* block;
        -: 4602:
        2: 4603:    MD_ASSERT(ctx->current_block == NULL);
        -: 4604:
        2: 4605:    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));
        2: 4606:    if(block == NULL)
        -: 4607:        return -1;
        -: 4608:
        2: 4609:    switch(line->type) {
    #####: 4610:        case MD_LINE_HR:
    #####: 4611:            block->type = MD_BLOCK_HR;
    #####: 4612:            break;
        -: 4613:
    #####: 4614:        case MD_LINE_ATXHEADER:
        -: 4615:        case MD_LINE_SETEXTHEADER:
    #####: 4616:            block->type = MD_BLOCK_H;
    #####: 4617:            break;
        -: 4618:
    #####: 4619:        case MD_LINE_FENCEDCODE:
        -: 4620:        case MD_LINE_INDENTEDCODE:
    #####: 4621:            block->type = MD_BLOCK_CODE;
    #####: 4622:            break;
        -: 4623:
        1: 4624:        case MD_LINE_TEXT:
        1: 4625:            block->type = MD_BLOCK_P;
        1: 4626:            break;
        -: 4627:
    #####: 4628:        case MD_LINE_HTML:
    #####: 4629:            block->type = MD_BLOCK_HTML;
    #####: 4630:            break;
        -: 4631:
        1: 4632:        case MD_LINE_BLANK:
        -: 4633:        case MD_LINE_SETEXTUNDERLINE:
        -: 4634:        case MD_LINE_TABLEUNDERLINE:
        -: 4635:        default:
        1: 4636:            MD_UNREACHABLE();
        -: 4637:            break;
        -: 4638:    }
        -: 4639:
        1: 4640:    block->flags = 0;
        1: 4641:    block->data = line->data;
        1: 4642:    block->n_lines = 0;
        -: 4643:
        1: 4644:    ctx->current_block = block;
        1: 4645:    return 0;
        -: 4646:}
        -: 4647:
        -: 4648:/* Eat from start of current (textual) block any reference definitions and
        -: 4649: * remember them so we can resolve any links referring to them.
        -: 4650: *
        -: 4651: * (Reference definitions can only be at start of it as they cannot break
        -: 4652: * a paragraph.)
        -: 4653: */
        -: 4654:static int
    #####: 4655:md_consume_link_reference_definitions(MD_CTX* ctx)
        -: 4656:{
    #####: 4657:    MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);
    #####: 4658:    int n_lines = ctx->current_block->n_lines;
    #####: 4659:    int n = 0;
        -: 4660:
        -: 4661:    /* Compute how many lines at the start of the block form one or more
        -: 4662:     * reference definitions. */
    #####: 4663:    while(n < n_lines) {
        -: 4664:        int n_link_ref_lines;
        -: 4665:
    #####: 4666:        n_link_ref_lines = md_is_link_reference_definition(ctx,
    #####: 4667:                                    lines + n, n_lines - n);
        -: 4668:        /* Not a reference definition? */
    #####: 4669:        if(n_link_ref_lines == 0)
        -: 4670:            break;
        -: 4671:
        -: 4672:        /* We fail if it is the ref. def. but it could not be stored due
        -: 4673:         * a memory allocation error. */
    #####: 4674:        if(n_link_ref_lines < 0)
        -: 4675:            return -1;
        -: 4676:
    #####: 4677:        n += n_link_ref_lines;
        -: 4678:    }
        -: 4679:
        -: 4680:    /* If there was at least one reference definition, we need to remove
        -: 4681:     * its lines from the block, or perhaps even the whole block. */
    #####: 4682:    if(n > 0) {
    #####: 4683:        if(n == n_lines) {
        -: 4684:            /* Remove complete block. */
    #####: 4685:            ctx->n_block_bytes -= n * sizeof(MD_LINE);
    #####: 4686:            ctx->n_block_bytes -= sizeof(MD_BLOCK);
        -: 4687:        } else {
        -: 4688:            /* Remove just some initial lines from the block. */
    #####: 4689:            memmove(lines, lines + n, (n_lines - n) * sizeof(MD_LINE));
    #####: 4690:            ctx->current_block->n_lines -= n;
    #####: 4691:            ctx->n_block_bytes -= n * sizeof(MD_LINE);
        -: 4692:        }
        -: 4693:    }
        -: 4694:
        -: 4695:    return 0;
        -: 4696:}
        -: 4697:
        -: 4698:static int
        6: 4699:md_end_current_block(MD_CTX* ctx)
        -: 4700:{
        6: 4701:    int ret = 0;
        -: 4702:
        6: 4703:    if(ctx->current_block == NULL)
        -: 4704:        return ret;
        -: 4705:
        -: 4706:    /* Check whether there is a reference definition. (We do this here instead
        -: 4707:     * of in md_analyze_line() because reference definition can take multiple
        -: 4708:     * lines.) */
        1: 4709:    if(ctx->current_block->type == MD_BLOCK_P) {
    #####: 4710:        MD_LINE* lines = (MD_LINE*) (ctx->current_block + 1);
    #####: 4711:        if(CH(lines[0].beg) == _T('['))
    #####: 4712:            MD_CHECK(md_consume_link_reference_definitions(ctx));
        -: 4713:    }
        -: 4714:
        -: 4715:    /* Mark we are not building any block anymore. */
        1: 4716:    ctx->current_block = NULL;
        -: 4717:
    #####: 4718:abort:
        -: 4719:    return ret;
        -: 4720:}
        -: 4721:
        -: 4722:static int
        2: 4723:md_add_line_into_current_block(MD_CTX* ctx, const MD_LINE_ANALYSIS* analysis)
        -: 4724:{
        2: 4725:    MD_ASSERT(ctx->current_block != NULL);
        -: 4726:
        2: 4727:    if(ctx->current_block->type == MD_BLOCK_CODE || ctx->current_block->type == MD_BLOCK_HTML) {
        -: 4728:        MD_VERBATIMLINE* line;
        -: 4729:
    #####: 4730:        line = (MD_VERBATIMLINE*) md_push_block_bytes(ctx, sizeof(MD_VERBATIMLINE));
    #####: 4731:        if(line == NULL)
        -: 4732:            return -1;
        -: 4733:
    #####: 4734:        line->indent = analysis->indent;
    #####: 4735:        line->beg = analysis->beg;
    #####: 4736:        line->end = analysis->end;
        -: 4737:    } else {
        -: 4738:        MD_LINE* line;
        -: 4739:
        2: 4740:        line = (MD_LINE*) md_push_block_bytes(ctx, sizeof(MD_LINE));
        2: 4741:        if(line == NULL)
        -: 4742:            return -1;
        -: 4743:
        2: 4744:        line->beg = analysis->beg;
        2: 4745:        line->end = analysis->end;
        -: 4746:    }
        2: 4747:    ctx->current_block->n_lines++;
        -: 4748:
        2: 4749:    return 0;
        -: 4750:}
        -: 4751:
        -: 4752:static int
        4: 4753:md_push_container_bytes(MD_CTX* ctx, MD_BLOCKTYPE type, unsigned start,
        -: 4754:                        unsigned data, unsigned flags)
        -: 4755:{
        -: 4756:    MD_BLOCK* block;
        4: 4757:    int ret = 0;
        -: 4758:
        4: 4759:    MD_CHECK(md_end_current_block(ctx));
        -: 4760:
        4: 4761:    block = (MD_BLOCK*) md_push_block_bytes(ctx, sizeof(MD_BLOCK));
        4: 4762:    if(block == NULL)
        -: 4763:        return -1;
        -: 4764:
        4: 4765:    block->type = type;
        4: 4766:    block->flags = flags;
        4: 4767:    block->data = data;
        4: 4768:    block->n_lines = start;
        -: 4769:
    #####: 4770:abort:
        -: 4771:    return ret;
        -: 4772:}
        -: 4773:
        -: 4774:
        -: 4775:
        -: 4776:/***********************
        -: 4777: ***  Line Analysis  ***
        -: 4778: ***********************/
        -: 4779:
        -: 4780:static int
        2: 4781:md_is_hr_line(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 4782:{
        2: 4783:    OFF off = beg + 1;
        2: 4784:    int n = 1;
        -: 4785:
        5: 4786:    while(off < ctx->size  &&  (CH(off) == CH(beg) || CH(off) == _T(' ') || CH(off) == _T('\t'))) {
        3: 4787:        if(CH(off) == CH(beg))
        2: 4788:            n++;
        3: 4789:        off++;
        -: 4790:    }
        -: 4791:
        2: 4792:    if(n < 3)
        -: 4793:        return FALSE;
        -: 4794:
        -: 4795:    /* Nothing else can be present on the line. */
        1: 4796:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4797:        return FALSE;
        -: 4798:
    #####: 4799:    *p_end = off;
        -: 4800:    return TRUE;
        -: 4801:}
        -: 4802:
        -: 4803:static int
    #####: 4804:md_is_atxheader_line(MD_CTX* ctx, OFF beg, OFF* p_beg, OFF* p_end, unsigned* p_level)
        -: 4805:{
        -: 4806:    int n;
    #####: 4807:    OFF off = beg + 1;
        -: 4808:
    #####: 4809:    while(off < ctx->size  &&  CH(off) == _T('#')  &&  off - beg < 7)
    #####: 4810:        off++;
    #####: 4811:    n = off - beg;
        -: 4812:
    #####: 4813:    if(n > 6)
        -: 4814:        return FALSE;
    #####: 4815:    *p_level = n;
        -: 4816:
    #####: 4817:    if(!(ctx->r.flags & MD_FLAG_PERMISSIVEATXHEADERS)  &&  off < ctx->size  &&
    #####: 4818:       CH(off) != _T(' ')  &&  CH(off) != _T('\t')  &&  !ISNEWLINE(off))
        -: 4819:        return FALSE;
        -: 4820:
    #####: 4821:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4822:        off++;
    #####: 4823:    *p_beg = off;
    #####: 4824:    *p_end = off;
    #####: 4825:    return TRUE;
        -: 4826:}
        -: 4827:
        -: 4828:static int
        1: 4829:md_is_setext_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_level)
        -: 4830:{
        1: 4831:    OFF off = beg + 1;
        -: 4832:
        3: 4833:    while(off < ctx->size  &&  CH(off) == CH(beg))
        2: 4834:        off++;
        -: 4835:
        1: 4836:    while(off < ctx->size  && CH(off) == _T(' '))
    #####: 4837:        off++;
        -: 4838:
        -: 4839:    /* Optionally, space(s) can follow. */
        1: 4840:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4841:        off++;
        -: 4842:
        -: 4843:    /* But nothing more is allowed on the line. */
        1: 4844:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4845:        return FALSE;
        -: 4846:
    #####: 4847:    *p_level = (CH(beg) == _T('=') ? 1 : 2);
    #####: 4848:    *p_end = off;
        -: 4849:    return TRUE;
        -: 4850:}
        -: 4851:
        -: 4852:static int
        1: 4853:md_is_table_underline(MD_CTX* ctx, OFF beg, OFF* p_end, unsigned* p_col_count)
        -: 4854:{
        1: 4855:    OFF off = beg;
        1: 4856:    int found_pipe = FALSE;
        1: 4857:    unsigned col_count = 0;
        -: 4858:
        1: 4859:    if(off < ctx->size  &&  CH(off) == _T('|')) {
    #####: 4860:        found_pipe = TRUE;
    #####: 4861:        off++;
    #####: 4862:        while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4863:            off++;
        -: 4864:    }
        -: 4865:
        -: 4866:    while(1) {
        -: 4867:        OFF cell_beg;
        2: 4868:        int delimited = FALSE;
        -: 4869:
        -: 4870:        /* Cell underline ("-----", ":----", "----:" or ":----:") */
        2: 4871:        cell_beg = off;
        2: 4872:        if(off < ctx->size  &&  CH(off) == _T(':'))
    #####: 4873:            off++;
        8: 4874:        while(off < ctx->size  &&  CH(off) == _T('-'))
        6: 4875:            off++;
        2: 4876:        if(off < ctx->size  &&  CH(off) == _T(':'))
    #####: 4877:            off++;
        2: 4878:        if(off - cell_beg < 3)
        -: 4879:            return FALSE;
        -: 4880:
        2: 4881:        col_count++;
        -: 4882:
        -: 4883:        /* Pipe delimiter (optional at the end of line). */
        2: 4884:        while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4885:            off++;
        2: 4886:        if(off < ctx->size  &&  CH(off) == _T('|')) {
        1: 4887:            delimited = TRUE;
        1: 4888:            found_pipe =  TRUE;
        1: 4889:            off++;
        1: 4890:            while(off < ctx->size  &&  ISWHITESPACE(off))
    #####: 4891:                off++;
        -: 4892:        }
        -: 4893:
        -: 4894:        /* Success, if we reach end of line. */
        2: 4895:        if(off >= ctx->size  ||  ISNEWLINE(off))
        -: 4896:            break;
        -: 4897:
        1: 4898:        if(!delimited)
        -: 4899:            return FALSE;
        -: 4900:    }
        -: 4901:
        1: 4902:    if(!found_pipe)
        -: 4903:        return FALSE;
        -: 4904:
        1: 4905:    *p_end = off;
        1: 4906:    *p_col_count = col_count;
        -: 4907:    return TRUE;
        -: 4908:}
        -: 4909:
        -: 4910:static int
    #####: 4911:md_is_opening_code_fence(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 4912:{
    #####: 4913:    OFF off = beg;
        -: 4914:
    #####: 4915:    while(off < ctx->size && CH(off) == CH(beg))
    #####: 4916:        off++;
        -: 4917:
        -: 4918:    /* Fence must have at least three characters. */
    #####: 4919:    if(off - beg < 3)
        -: 4920:        return FALSE;
        -: 4921:
    #####: 4922:    ctx->code_fence_length = off - beg;
        -: 4923:
        -: 4924:    /* Optionally, space(s) can follow. */
    #####: 4925:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4926:        off++;
        -: 4927:
        -: 4928:    /* Optionally, an info string can follow. It must not contain '`'. */
    #####: 4929:    while(off < ctx->size  &&  CH(off) != _T('`')  &&  !ISNEWLINE(off))
    #####: 4930:        off++;
    #####: 4931:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4932:        return FALSE;
        -: 4933:
    #####: 4934:    *p_end = off;
    #####: 4935:    return TRUE;
        -: 4936:}
        -: 4937:
        -: 4938:static int
    #####: 4939:md_is_closing_code_fence(MD_CTX* ctx, CHAR ch, OFF beg, OFF* p_end)
        -: 4940:{
    #####: 4941:    OFF off = beg;
    #####: 4942:    int ret = FALSE;
        -: 4943:
        -: 4944:    /* Closing fence must have at least the same length and use same char as
        -: 4945:     * opening one. */
    #####: 4946:    while(off < ctx->size  &&  CH(off) == ch)
    #####: 4947:        off++;
    #####: 4948:    if(off - beg < ctx->code_fence_length)
        -: 4949:        goto out;
        -: 4950:
        -: 4951:    /* Optionally, space(s) can follow */
    #####: 4952:    while(off < ctx->size  &&  CH(off) == _T(' '))
    #####: 4953:        off++;
        -: 4954:
        -: 4955:    /* But nothing more is allowed on the line. */
    #####: 4956:    if(off < ctx->size  &&  !ISNEWLINE(off))
        -: 4957:        goto out;
        -: 4958:
    #####: 4959:    ret = TRUE;
        -: 4960:
    #####: 4961:out:
        -: 4962:    /* Note we set *p_end even on failure: If we are not closing fence, caller
        -: 4963:     * would eat the line anyway without any parsing. */
    #####: 4964:    *p_end = off;
    #####: 4965:    return ret;
        -: 4966:}
        -: 4967:
        -: 4968:/* Returns type of the raw HTML block, or FALSE if it is not HTML block.
        -: 4969: * (Refer to CommonMark specification for details about the types.)
        -: 4970: */
        -: 4971:static int
    #####: 4972:md_is_html_block_start_condition(MD_CTX* ctx, OFF beg)
        -: 4973:{
        -: 4974:    typedef struct TAG_tag TAG;
        -: 4975:    struct TAG_tag {
        -: 4976:        const CHAR* name;
        -: 4977:        unsigned len    : 8;
        -: 4978:    };
        -: 4979:
        -: 4980:    /* Type 6 is started by a long list of allowed tags. We use two-level
        -: 4981:     * tree to speed-up the search. */
        -: 4982:#ifdef X
        -: 4983:    #undef X
        -: 4984:#endif
        -: 4985:#define X(name)     { _T(name), sizeof(name)-1 }
        -: 4986:#define Xend        { NULL, 0 }
        -: 4987:    static const TAG t1[] = { X("script"), X("pre"), X("style"), Xend };
        -: 4988:
        -: 4989:    static const TAG a6[] = { X("address"), X("article"), X("aside"), Xend };
        -: 4990:    static const TAG b6[] = { X("base"), X("basefont"), X("blockquote"), X("body"), Xend };
        -: 4991:    static const TAG c6[] = { X("caption"), X("center"), X("col"), X("colgroup"), Xend };
        -: 4992:    static const TAG d6[] = { X("dd"), X("details"), X("dialog"), X("dir"),
        -: 4993:                              X("div"), X("dl"), X("dt"), Xend };
        -: 4994:    static const TAG f6[] = { X("fieldset"), X("figcaption"), X("figure"), X("footer"),
        -: 4995:                              X("form"), X("frame"), X("frameset"), Xend };
        -: 4996:    static const TAG h6[] = { X("h1"), X("head"), X("header"), X("hr"), X("html"), Xend };
        -: 4997:    static const TAG i6[] = { X("iframe"), Xend };
        -: 4998:    static const TAG l6[] = { X("legend"), X("li"), X("link"), Xend };
        -: 4999:    static const TAG m6[] = { X("main"), X("menu"), X("menuitem"), X("meta"), Xend };
        -: 5000:    static const TAG n6[] = { X("nav"), X("noframes"), Xend };
        -: 5001:    static const TAG o6[] = { X("ol"), X("optgroup"), X("option"), Xend };
        -: 5002:    static const TAG p6[] = { X("p"), X("param"), Xend };
        -: 5003:    static const TAG s6[] = { X("section"), X("source"), X("summary"), Xend };
        -: 5004:    static const TAG t6[] = { X("table"), X("tbody"), X("td"), X("tfoot"), X("th"),
        -: 5005:                              X("thead"), X("title"), X("tr"), X("track"), Xend };
        -: 5006:    static const TAG u6[] = { X("ul"), Xend };
        -: 5007:    static const TAG xx[] = { Xend };
        -: 5008:#undef X
        -: 5009:
        -: 5010:    static const TAG* map6[26] = {
        -: 5011:        a6, b6, c6, d6, xx, f6, xx, h6, i6, xx, xx, l6, m6,
        -: 5012:        n6, o6, p6, xx, xx, s6, t6, u6, xx, xx, xx, xx, xx
        -: 5013:    };
    #####: 5014:    OFF off = beg + 1;
        -: 5015:    int i;
        -: 5016:
        -: 5017:    /* Check for type 1: <script, <pre, or <style */
    #####: 5018:    for(i = 0; t1[i].name != NULL; i++) {
    #####: 5019:        if(off + t1[i].len < ctx->size) {
    #####: 5020:            if(md_ascii_case_eq(STR(off), t1[i].name, t1[i].len))
        -: 5021:                return 1;
        -: 5022:        }
        -: 5023:    }
        -: 5024:
        -: 5025:    /* Check for type 2: <!-- */
    #####: 5026:    if(off + 3 < ctx->size  &&  CH(off) == _T('!')  &&  CH(off+1) == _T('-')  &&  CH(off+2) == _T('-'))
        -: 5027:        return 2;
        -: 5028:
        -: 5029:    /* Check for type 3: <? */
    #####: 5030:    if(off < ctx->size  &&  CH(off) == _T('?'))
        -: 5031:        return 3;
        -: 5032:
        -: 5033:    /* Check for type 4 or 5: <! */
    #####: 5034:    if(off < ctx->size  &&  CH(off) == _T('!')) {
        -: 5035:        /* Check for type 4: <! followed by uppercase letter. */
    #####: 5036:        if(off + 1 < ctx->size  &&  ISUPPER(off+1))
        -: 5037:            return 4;
        -: 5038:
        -: 5039:        /* Check for type 5: <![CDATA[ */
    #####: 5040:        if(off + 8 < ctx->size) {
    #####: 5041:            if(md_ascii_eq(STR(off), _T("![CDATA["), 8 * sizeof(CHAR)))
        -: 5042:                return 5;
        -: 5043:        }
        -: 5044:    }
        -: 5045:
        -: 5046:    /* Check for type 6: Many possible starting tags listed above. */
    #####: 5047:    if(off + 1 < ctx->size  &&  (ISALPHA(off) || (CH(off) == _T('/') && ISALPHA(off+1)))) {
        -: 5048:        int slot;
        -: 5049:        const TAG* tags;
        -: 5050:
    #####: 5051:        if(CH(off) == _T('/'))
    #####: 5052:            off++;
        -: 5053:
    #####: 5054:        slot = (ISUPPER(off) ? CH(off) - 'A' : CH(off) - 'a');
    #####: 5055:        tags = map6[slot];
        -: 5056:
    #####: 5057:        for(i = 0; tags[i].name != NULL; i++) {
    #####: 5058:            if(off + tags[i].len <= ctx->size) {
    #####: 5059:                if(md_ascii_case_eq(STR(off), tags[i].name, tags[i].len)) {
    #####: 5060:                    OFF tmp = off + tags[i].len;
    #####: 5061:                    if(tmp >= ctx->size)
        -: 5062:                        return 6;
    #####: 5063:                    if(ISBLANK(tmp) || ISNEWLINE(tmp) || CH(tmp) == _T('>'))
        -: 5064:                        return 6;
    #####: 5065:                    if(tmp+1 < ctx->size && CH(tmp) == _T('/') && CH(tmp+1) == _T('>'))
        -: 5066:                        return 6;
        -: 5067:                    break;
        -: 5068:                }
        -: 5069:            }
        -: 5070:        }
        -: 5071:    }
        -: 5072:
        -: 5073:    /* Check for type 7: any COMPLETE other opening or closing tag. */
    #####: 5074:    if(off + 1 < ctx->size) {
    #####: 5075:        OFF end;
        -: 5076:
    #####: 5077:        if(md_is_html_tag(ctx, NULL, 0, beg, ctx->size, &end)) {
        -: 5078:            /* Only optional whitespace and new line may follow. */
    #####: 5079:            while(end < ctx->size  &&  ISWHITESPACE(end))
    #####: 5080:                end++;
    #####: 5081:            if(end >= ctx->size  ||  ISNEWLINE(end))
    #####: 5082:                return 7;
        -: 5083:        }
        -: 5084:    }
        -: 5085:
        -: 5086:    return FALSE;
        -: 5087:}
        -: 5088:
        -: 5089:/* Case sensitive check whether there is a substring 'what' between 'beg'
        -: 5090: * and end of line. */
        -: 5091:static int
    #####: 5092:md_line_contains(MD_CTX* ctx, OFF beg, const CHAR* what, SZ what_len, OFF* p_end)
        -: 5093:{
        -: 5094:    OFF i;
    #####: 5095:    for(i = beg; i + what_len < ctx->size; i++) {
    #####: 5096:        if(ISNEWLINE(i))
        -: 5097:            break;
    #####: 5098:        if(memcmp(STR(i), what, what_len * sizeof(CHAR)) == 0) {
    #####: 5099:            *p_end = i + what_len;
        -: 5100:            return TRUE;
        -: 5101:        }
        -: 5102:    }
        -: 5103:
    #####: 5104:    *p_end = i;
        -: 5105:    return FALSE;
        -: 5106:}
        -: 5107:
        -: 5108:/* Returns type of HTML block end condition or FALSE if not an end condition.
        -: 5109: *
        -: 5110: * Note it fills p_end even when it is not end condition as the caller
        -: 5111: * does not need to analyze contents of a raw HTML block.
        -: 5112: */
        -: 5113:static int
    #####: 5114:md_is_html_block_end_condition(MD_CTX* ctx, OFF beg, OFF* p_end)
        -: 5115:{
    #####: 5116:    switch(ctx->html_block_type) {
        -: 5117:        case 1:
        -: 5118:        {
        -: 5119:            OFF off = beg;
        -: 5120:
    #####: 5121:            while(off < ctx->size  &&  !ISNEWLINE(off)) {
    #####: 5122:                if(CH(off) == _T('<')) {
    #####: 5123:                    if(md_ascii_case_eq(STR(off), _T("</script>"), 9)) {
    #####: 5124:                        *p_end = off + 9;
    #####: 5125:                        return TRUE;
        -: 5126:                    }
        -: 5127:
    #####: 5128:                    if(md_ascii_case_eq(STR(off), _T("</style>"), 8)) {
    #####: 5129:                        *p_end = off + 8;
    #####: 5130:                        return TRUE;
        -: 5131:                    }
        -: 5132:
    #####: 5133:                    if(md_ascii_case_eq(STR(off), _T("</pre>"), 6)) {
    #####: 5134:                        *p_end = off + 6;
    #####: 5135:                        return TRUE;
        -: 5136:                    }
        -: 5137:                }
        -: 5138:
    #####: 5139:                off++;
        -: 5140:            }
    #####: 5141:            *p_end = off;
    #####: 5142:            return FALSE;
        -: 5143:        }
        -: 5144:
    #####: 5145:        case 2:
    #####: 5146:            return (md_line_contains(ctx, beg, _T("-->"), 3, p_end) ? 2 : FALSE);
        -: 5147:
    #####: 5148:        case 3:
    #####: 5149:            return (md_line_contains(ctx, beg, _T("?>"), 2, p_end) ? 3 : FALSE);
        -: 5150:
    #####: 5151:        case 4:
    #####: 5152:            return (md_line_contains(ctx, beg, _T(">"), 1, p_end) ? 4 : FALSE);
        -: 5153:
    #####: 5154:        case 5:
    #####: 5155:            return (md_line_contains(ctx, beg, _T("]]>"), 3, p_end) ? 5 : FALSE);
        -: 5156:
    #####: 5157:        case 6:     /* Pass through */
        -: 5158:        case 7:
    #####: 5159:            *p_end = beg;
    #####: 5160:            return (ISNEWLINE(beg) ? ctx->html_block_type : FALSE);
        -: 5161:
    #####: 5162:        default:
    #####: 5163:            MD_UNREACHABLE();
        -: 5164:    }
        -: 5165:}
        -: 5166:
        -: 5167:
        -: 5168:static int
        -: 5169:md_is_container_compatible(const MD_CONTAINER* pivot, const MD_CONTAINER* container)
        -: 5170:{
        -: 5171:    /* Block quote has no "items" like lists. */
    #####: 5172:    if(container->ch == _T('>'))
        -: 5173:        return FALSE;
        -: 5174:
    #####: 5175:    if(container->ch != pivot->ch)
        -: 5176:        return FALSE;
    #####: 5177:    if(container->mark_indent > pivot->contents_indent)
        -: 5178:        return FALSE;
        -: 5179:
        -: 5180:    return TRUE;
        -: 5181:}
        -: 5182:
        -: 5183:static int
        1: 5184:md_push_container(MD_CTX* ctx, const MD_CONTAINER* container)
        -: 5185:{
        1: 5186:    if(ctx->n_containers >= ctx->alloc_containers) {
        -: 5187:        MD_CONTAINER* new_containers;
        -: 5188:
        1: 5189:        ctx->alloc_containers = (ctx->alloc_containers > 0 ? ctx->alloc_containers * 2 : 16);
        1: 5190:        new_containers = realloc(ctx->containers, ctx->alloc_containers * sizeof(MD_CONTAINER));
        1: 5191:        if(new_containers == NULL) {
    #####: 5192:            MD_LOG("realloc() failed.");
        -: 5193:            return -1;
        -: 5194:        }
        -: 5195:
        1: 5196:        ctx->containers = new_containers;
        -: 5197:    }
        -: 5198:
        2: 5199:    memcpy(&ctx->containers[ctx->n_containers++], container, sizeof(MD_CONTAINER));
        1: 5200:    return 0;
        -: 5201:}
        -: 5202:
        -: 5203:static int
        1: 5204:md_enter_child_containers(MD_CTX* ctx, int n_children, unsigned data)
        -: 5205:{
        -: 5206:    int i;
        1: 5207:    int ret = 0;
        -: 5208:
        2: 5209:    for(i = ctx->n_containers - n_children; i < ctx->n_containers; i++) {
        1: 5210:        MD_CONTAINER* c = &ctx->containers[i];
        1: 5211:        int is_ordered_list = FALSE;
        -: 5212:
        1: 5213:        switch(c->ch) {
        -: 5214:            case _T(')'):
        -: 5215:            case _T('.'):
        -: 5216:                is_ordered_list = TRUE;
        -: 5217:                /* Pass through */
        -: 5218:
        1: 5219:            case _T('-'):
        -: 5220:            case _T('+'):
        -: 5221:            case _T('*'):
        -: 5222:                /* Remember offset in ctx->block_bytes so we can revisit the
        -: 5223:                 * block if we detect it is a loose list. */
        1: 5224:                md_end_current_block(ctx);
        1: 5225:                c->block_byte_off = ctx->n_block_bytes;
        -: 5226:
        1: 5227:                MD_CHECK(md_push_container_bytes(ctx,
        -: 5228:                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL),
        -: 5229:                                c->start, data, MD_BLOCK_CONTAINER_OPENER));
        1: 5230:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0, data, MD_BLOCK_CONTAINER_OPENER));
        -: 5231:                break;
        -: 5232:
    #####: 5233:            case _T('>'):
    #####: 5234:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0, data, MD_BLOCK_CONTAINER_OPENER));
        -: 5235:                break;
        -: 5236:
    #####: 5237:            default:
    #####: 5238:                MD_UNREACHABLE();
        -: 5239:                break;
        -: 5240:        }
        -: 5241:    }
        -: 5242:
        1: 5243:abort:
        1: 5244:    return ret;
        -: 5245:}
        -: 5246:
        -: 5247:static int
        2: 5248:md_leave_child_containers(MD_CTX* ctx, int n_keep)
        -: 5249:{
        2: 5250:    int ret = 0;
        -: 5251:
        5: 5252:    while(ctx->n_containers > n_keep) {
        1: 5253:        MD_CONTAINER* c = &ctx->containers[ctx->n_containers-1];
        1: 5254:        int is_ordered_list = FALSE;
        -: 5255:
        1: 5256:        switch(c->ch) {
        -: 5257:            case _T(')'):
        -: 5258:            case _T('.'):
        -: 5259:                is_ordered_list = TRUE;
        -: 5260:                /* Pass through */
        -: 5261:
        1: 5262:            case _T('-'):
        -: 5263:            case _T('+'):
        -: 5264:            case _T('*'):
        1: 5265:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0,
        -: 5266:                                0, MD_BLOCK_CONTAINER_CLOSER));
        1: 5267:                MD_CHECK(md_push_container_bytes(ctx,
        -: 5268:                                (is_ordered_list ? MD_BLOCK_OL : MD_BLOCK_UL), 0,
        -: 5269:                                c->ch, MD_BLOCK_CONTAINER_CLOSER));
        -: 5270:                break;
        -: 5271:
    #####: 5272:            case _T('>'):
    #####: 5273:                MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_QUOTE, 0,
        -: 5274:                                0, MD_BLOCK_CONTAINER_CLOSER));
        -: 5275:                break;
        -: 5276:
    #####: 5277:            default:
    #####: 5278:                MD_UNREACHABLE();
        -: 5279:                break;
        -: 5280:        }
        -: 5281:
        1: 5282:        ctx->n_containers--;
        -: 5283:    }
        -: 5284:
        2: 5285:abort:
        2: 5286:    return ret;
        -: 5287:}
        -: 5288:
        -: 5289:static int
        5: 5290:md_is_container_mark(MD_CTX* ctx, unsigned indent, OFF beg, OFF* p_end, MD_CONTAINER* p_container)
        -: 5291:{
        5: 5292:    OFF off = beg;
        -: 5293:    OFF max_end;
        -: 5294:
        -: 5295:    /* Check for block quote mark. */
        5: 5296:    if(off < ctx->size  &&  CH(off) == _T('>')) {
    #####: 5297:        off++;
    #####: 5298:        p_container->ch = _T('>');
    #####: 5299:        p_container->is_loose = FALSE;
    #####: 5300:        p_container->mark_indent = indent;
    #####: 5301:        p_container->contents_indent = indent + 1;
    #####: 5302:        *p_end = off;
        -: 5303:        return TRUE;
        -: 5304:    }
        -: 5305:
        -: 5306:    /* Check for list item bullet mark. */
       10: 5307:    if(off+1 < ctx->size  &&  ISANYOF(off, _T("-+*"))  &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {
        1: 5308:        p_container->ch = CH(off);
        1: 5309:        p_container->is_loose = FALSE;
        1: 5310:        p_container->mark_indent = indent;
        1: 5311:        p_container->contents_indent = indent + 1;
        1: 5312:        *p_end = off+1;
        -: 5313:        return TRUE;
        -: 5314:    }
        -: 5315:
        -: 5316:    /* Check for ordered list item marks. */
        4: 5317:    max_end = off + 9;
        4: 5318:    if(max_end > ctx->size)
        2: 5319:        max_end = ctx->size;
        4: 5320:    p_container->start = 0;
        4: 5321:    while(off < max_end  &&  ISDIGIT(off)) {
    #####: 5322:        p_container->start = p_container->start * 10 + CH(off) - _T('0');
    #####: 5323:        off++;
        -: 5324:    }
        4: 5325:    if(off+1 < ctx->size  &&  (CH(off) == _T('.') || CH(off) == _T(')'))   &&  (ISBLANK(off+1) || ISNEWLINE(off+1))) {
    #####: 5326:        p_container->ch = CH(off);
    #####: 5327:        p_container->is_loose = FALSE;
    #####: 5328:        p_container->mark_indent = indent;
    #####: 5329:        p_container->contents_indent = indent + off - beg + 1;
    #####: 5330:        *p_end = off+1;
        -: 5331:        return TRUE;
        -: 5332:    }
        -: 5333:
        -: 5334:    return FALSE;
        -: 5335:}
        -: 5336:
        -: 5337:static unsigned
        -: 5338:md_line_indentation(MD_CTX* ctx, unsigned total_indent, OFF beg, OFF* p_end)
        -: 5339:{
        -: 5340:    OFF off = beg;
        -: 5341:    unsigned indent = total_indent;
        -: 5342:
        7: 5343:    while(off < ctx->size  &&  ISBLANK(off)) {
        3: 5344:        if(CH(off) == _T('\t'))
    #####: 5345:            indent = (indent + 4) & ~3;
        -: 5346:        else
        3: 5347:            indent++;
        3: 5348:        off++;
        -: 5349:    }
        -: 5350:
        4: 5351:    *p_end = off;
        1: 5352:    return indent - total_indent;
        -: 5353:}
        -: 5354:
        -: 5355:static const MD_LINE_ANALYSIS md_dummy_blank_line = { MD_LINE_BLANK, 0 };
        -: 5356:
        -: 5357:/* Analyze type of the line and find some its properties. This serves as a
        -: 5358: * main input for determining type and boundaries of a block. */
        -: 5359:static int
        3: 5360:md_analyze_line(MD_CTX* ctx, OFF beg, OFF* p_end,
        -: 5361:                const MD_LINE_ANALYSIS* pivot_line, MD_LINE_ANALYSIS* line)
        -: 5362:{
        3: 5363:    unsigned total_indent = 0;
        3: 5364:    int n_parents = 0;
        3: 5365:    int n_brothers = 0;
        3: 5366:    int n_children = 0;
        3: 5367:    MD_CONTAINER container;
        3: 5368:    int prev_line_has_list_loosening_effect = ctx->last_line_has_list_loosening_effect;
        3: 5369:    OFF off = beg;
        3: 5370:    int ret = 0;
        -: 5371:
        6: 5372:    line->indent = md_line_indentation(ctx, total_indent, off, &off);
        3: 5373:    total_indent += line->indent;
        3: 5374:    line->beg = off;
        -: 5375:
        -: 5376:    /* Given the indentation and block quote marks '>', determine how many of
        -: 5377:     * the current containers are our parents. */
        7: 5378:    while(n_parents < ctx->n_containers) {
        2: 5379:        MD_CONTAINER* c = &ctx->containers[n_parents];
        -: 5380:
        2: 5381:        if(c->ch == _T('>')  &&  line->indent < ctx->code_indent_offset  &&
    #####: 5382:            off < ctx->size  &&  CH(off) == _T('>'))
        -: 5383:        {
        -: 5384:            /* Block quote mark. */
    #####: 5385:            off++;
    #####: 5386:            total_indent++;
    #####: 5387:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
    #####: 5388:            total_indent += line->indent;
        -: 5389:
        -: 5390:            /* The optional 1st space after '>' is part of the block quote mark. */
    #####: 5391:            if(line->indent > 0)
    #####: 5392:                line->indent--;
        -: 5393:
    #####: 5394:            line->beg = off;
        4: 5395:        } else if(c->ch != _T('>')  &&  line->indent >= c->contents_indent) {
        -: 5396:            /* List. */
        1: 5397:            line->indent -= c->contents_indent;
        -: 5398:        } else {
        -: 5399:            break;
        -: 5400:        }
        -: 5401:
        1: 5402:        n_parents++;
        -: 5403:    }
        -: 5404:
        3: 5405:redo:
        -: 5406:    /* Check whether we are fenced code continuation. */
        4: 5407:    if(pivot_line->type == MD_LINE_FENCEDCODE) {
    #####: 5408:        line->beg = off;
        -: 5409:
        -: 5410:        /* We are another MD_LINE_FENCEDCODE unless we are closing fence
        -: 5411:         * which we transform into MD_LINE_BLANK. */
    #####: 5412:        if(line->indent < ctx->code_indent_offset) {
    #####: 5413:            if(md_is_closing_code_fence(ctx, CH(pivot_line->beg), off, &off)) {
    #####: 5414:                line->type = MD_LINE_BLANK;
    #####: 5415:                ctx->last_line_has_list_loosening_effect = FALSE;
    #####: 5416:                goto done;
        -: 5417:            }
        -: 5418:        }
        -: 5419:
    #####: 5420:        if(off >= ctx->size  ||  ISNEWLINE(off)) {
        -: 5421:            /* Blank line does not need any real indentation to be nested inside
        -: 5422:             * a list. */
    #####: 5423:            if(n_brothers + n_children == 0) {
    #####: 5424:                while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))
    #####: 5425:                    n_parents++;
        -: 5426:            }
        -: 5427:        }
        -: 5428:
        -: 5429:        /* Change indentation accordingly to the initial code fence. */
    #####: 5430:        if(n_parents == ctx->n_containers) {
    #####: 5431:            if(line->indent > pivot_line->indent)
    #####: 5432:                line->indent -= pivot_line->indent;
        -: 5433:            else
    #####: 5434:                line->indent = 0;
        -: 5435:
    #####: 5436:            line->type = MD_LINE_FENCEDCODE;
    #####: 5437:            goto done;
        -: 5438:        }
        -: 5439:    }
        -: 5440:
        -: 5441:    /* Check whether we are HTML block continuation. */
        4: 5442:    if(pivot_line->type == MD_LINE_HTML  &&  ctx->html_block_type > 0) {
        -: 5443:        int html_block_type;
        -: 5444:
    #####: 5445:        html_block_type = md_is_html_block_end_condition(ctx, off, &off);
    #####: 5446:        if(html_block_type > 0) {
    #####: 5447:            MD_ASSERT(html_block_type == ctx->html_block_type);
        -: 5448:
        -: 5449:            /* Make sure this is the last line of the block. */
    #####: 5450:            ctx->html_block_type = 0;
        -: 5451:
        -: 5452:            /* Some end conditions serve as blank lines at the same time. */
    #####: 5453:            if(html_block_type == 6 || html_block_type == 7) {
    #####: 5454:                line->type = MD_LINE_BLANK;
    #####: 5455:                line->indent = 0;
    #####: 5456:                goto done;
        -: 5457:            }
        -: 5458:        }
        -: 5459:
    #####: 5460:        if(n_parents == ctx->n_containers) {
    #####: 5461:            line->type = MD_LINE_HTML;
    #####: 5462:            goto done;
        -: 5463:        }
        -: 5464:    }
        -: 5465:
        -: 5466:    /* Check for blank line. */
        4: 5467:    if(off >= ctx->size  ||  ISNEWLINE(off)) {
        -: 5468:        /* Blank line does not need any real indentation to be nested inside
        -: 5469:         * a list. */
    #####: 5470:        if(n_brothers + n_children == 0) {
    #####: 5471:            while(n_parents < ctx->n_containers  &&  ctx->containers[n_parents].ch != _T('>'))
    #####: 5472:                n_parents++;
        -: 5473:        }
        -: 5474:
    #####: 5475:        if(pivot_line->type == MD_LINE_INDENTEDCODE  &&  n_parents == ctx->n_containers) {
    #####: 5476:            line->type = MD_LINE_INDENTEDCODE;
    #####: 5477:            if(line->indent > ctx->code_indent_offset)
    #####: 5478:                line->indent -= ctx->code_indent_offset;
        -: 5479:            else
    #####: 5480:                line->indent = 0;
    #####: 5481:            ctx->last_line_has_list_loosening_effect = FALSE;
        -: 5482:        } else {
    #####: 5483:            line->type = MD_LINE_BLANK;
    #####: 5484:            ctx->last_line_has_list_loosening_effect = (n_parents > 0  &&
    #####: 5485:                    n_brothers + n_children == 0  &&
    #####: 5486:                    ctx->containers[n_parents-1].ch != _T('>'));
        -: 5487:
        -: 5488:#if 1
        -: 5489:            /* See https://github.com/mity/md4c/issues/6
        -: 5490:             *
        -: 5491:             * This ugly checking tests we are in (yet empty) list item but not
        -: 5492:             * its very first line (with the list item mark).
        -: 5493:             *
        -: 5494:             * If we are such blank line, then any following non-blank line
        -: 5495:             * which would be part of this list item actually ends the list
        -: 5496:             * because "a list item can begin with at most one blank line."
        -: 5497:             */
    #####: 5498:            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
    #####: 5499:               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
    #####: 5500:               ctx->n_block_bytes > sizeof(MD_BLOCK))
        -: 5501:            {
    #####: 5502:                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
    #####: 5503:                if(top_block->type == MD_BLOCK_LI)
    #####: 5504:                    ctx->last_list_item_starts_with_two_blank_lines = TRUE;
        -: 5505:            }
        -: 5506:#endif
        -: 5507:        }
        -: 5508:        goto done_on_eol;
        -: 5509:    } else {
        -: 5510:#if 1
        -: 5511:        /* This is 2nd half of the hack. If the flag is set (that is there
        -: 5512:         * were 2nd blank line at the start of the list item) and we would also
        -: 5513:         * belonging to such list item, then interrupt the list. */
        4: 5514:        ctx->last_line_has_list_loosening_effect = FALSE;
        4: 5515:        if(ctx->last_list_item_starts_with_two_blank_lines) {
    #####: 5516:            if(n_parents > 0  &&  ctx->containers[n_parents-1].ch != _T('>')  &&
    #####: 5517:               n_brothers + n_children == 0  &&  ctx->current_block == NULL  &&
    #####: 5518:               ctx->n_block_bytes > sizeof(MD_BLOCK))
        -: 5519:            {
    #####: 5520:                MD_BLOCK* top_block = (MD_BLOCK*) ((char*)ctx->block_bytes + ctx->n_block_bytes - sizeof(MD_BLOCK));
    #####: 5521:                if(top_block->type == MD_BLOCK_LI)
    #####: 5522:                    n_parents--;
        -: 5523:            }
        -: 5524:
    #####: 5525:            ctx->last_list_item_starts_with_two_blank_lines = FALSE;
        -: 5526:        }
        -: 5527:#endif
        -: 5528:    }
        -: 5529:
        -: 5530:    /* Check whether we are Setext underline. */
        4: 5531:    if(line->indent < ctx->code_indent_offset  &&  pivot_line->type == MD_LINE_TEXT
        1: 5532:        &&  (CH(off) == _T('=') || CH(off) == _T('-'))
        1: 5533:        &&  (n_parents == ctx->n_containers))
        -: 5534:    {
        1: 5535:        unsigned level;
        -: 5536:
        1: 5537:        if(md_is_setext_underline(ctx, off, &off, &level)) {
    #####: 5538:            line->type = MD_LINE_SETEXTUNDERLINE;
    #####: 5539:            line->data = level;
    #####: 5540:            goto done;
        -: 5541:        }
        -: 5542:    }
        -: 5543:
        -: 5544:    /* Check for thematic break line. */
        8: 5545:    if(line->indent < ctx->code_indent_offset  &&  ISANYOF(off, _T("-_*"))) {
        2: 5546:        if(md_is_hr_line(ctx, off, &off)) {
    #####: 5547:            line->type = MD_LINE_HR;
    #####: 5548:            goto done;
        -: 5549:        }
        -: 5550:    }
        -: 5551:
        -: 5552:    /* Check for "brother" container. I.e. whether we are another list item
        -: 5553:     * in already started list. */
        4: 5554:    if(n_parents < ctx->n_containers  &&  n_brothers + n_children == 0) {
        1: 5555:        OFF tmp;
        -: 5556:
        1: 5557:        if(md_is_container_mark(ctx, line->indent, off, &tmp, &container)  &&
    #####: 5558:           md_is_container_compatible(&ctx->containers[n_parents], &container))
        -: 5559:        {
    #####: 5560:            pivot_line = &md_dummy_blank_line;
        -: 5561:
    #####: 5562:            off = tmp;
        -: 5563:
    #####: 5564:            total_indent += container.contents_indent - container.mark_indent;
    #####: 5565:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
    #####: 5566:            total_indent += line->indent;
    #####: 5567:            line->beg = off;
        -: 5568:
        -: 5569:            /* Some of the following whitespace actually still belongs to the mark. */
    #####: 5570:            if(off >= ctx->size || ISNEWLINE(off)) {
    #####: 5571:                container.contents_indent++;
    #####: 5572:            } else if(line->indent <= ctx->code_indent_offset) {
    #####: 5573:                container.contents_indent += line->indent;
    #####: 5574:                line->indent = 0;
        -: 5575:            } else {
    #####: 5576:                container.contents_indent += 1;
    #####: 5577:                line->indent--;
        -: 5578:            }
        -: 5579:
    #####: 5580:            ctx->containers[n_parents].mark_indent = container.mark_indent;
    #####: 5581:            ctx->containers[n_parents].contents_indent = container.contents_indent;
        -: 5582:
    #####: 5583:            n_brothers++;
    #####: 5584:            goto redo;
        -: 5585:        }
        -: 5586:    }
        -: 5587:
        -: 5588:    /* Check for indented code.
        -: 5589:     * Note indented code block cannot interrupt a paragraph. */
        4: 5590:    if(line->indent >= ctx->code_indent_offset  &&
    #####: 5591:        (pivot_line->type == MD_LINE_BLANK || pivot_line->type == MD_LINE_INDENTEDCODE))
        -: 5592:    {
    #####: 5593:        line->type = MD_LINE_INDENTEDCODE;
        -: 5594:        MD_ASSERT(line->indent >= ctx->code_indent_offset);
    #####: 5595:        line->indent -= ctx->code_indent_offset;
    #####: 5596:        line->data = 0;
    #####: 5597:        goto done;
        -: 5598:    }
        -: 5599:
        -: 5600:    /* Check for start of a new container block. */
        8: 5601:    if(line->indent < ctx->code_indent_offset  &&
        4: 5602:       md_is_container_mark(ctx, line->indent, off, &off, &container))
        -: 5603:    {
        1: 5604:        if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
    #####: 5605:                    (off >= ctx->size || ISNEWLINE(off)))
        -: 5606:        {
        -: 5607:            /* Noop. List mark followed by a blank line cannot interrupt a paragraph. */
        1: 5608:        } else if(pivot_line->type == MD_LINE_TEXT  &&  n_parents == ctx->n_containers  &&
    #####: 5609:                    (container.ch == _T('.') || container.ch == _T(')'))  &&  container.start != 1)
        -: 5610:        {
        -: 5611:            /* Noop. Ordered list cannot interrupt a paragraph unless the start index is 1. */
        -: 5612:        } else {
        1: 5613:            total_indent += container.contents_indent - container.mark_indent;
        2: 5614:            line->indent = md_line_indentation(ctx, total_indent, off, &off);
        1: 5615:            total_indent += line->indent;
        -: 5616:
        1: 5617:            line->beg = off;
        1: 5618:            line->data = container.ch;
        -: 5619:
        -: 5620:            /* Some of the following whitespace actually still belongs to the mark. */
        1: 5621:            if(off >= ctx->size || ISNEWLINE(off)) {
    #####: 5622:                container.contents_indent++;
        1: 5623:            } else if(line->indent <= ctx->code_indent_offset) {
        1: 5624:                container.contents_indent += line->indent;
        1: 5625:                line->indent = 0;
        -: 5626:            } else {
    #####: 5627:                container.contents_indent += 1;
    #####: 5628:                line->indent--;
        -: 5629:            }
        -: 5630:
        1: 5631:            if(n_brothers + n_children == 0)
        1: 5632:                pivot_line = &md_dummy_blank_line;
        -: 5633:
        1: 5634:            if(n_children == 0)
        1: 5635:                MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));
        -: 5636:
        1: 5637:            n_children++;
        1: 5638:            MD_CHECK(md_push_container(ctx, &container));
        -: 5639:            goto redo;
        -: 5640:        }
        -: 5641:    }
        -: 5642:
        -: 5643:    /* Check whether we are table continuation. */
        3: 5644:    if(pivot_line->type == MD_LINE_TABLE  &&  md_is_table_row(ctx, off, &off))
        -: 5645:    {
        1: 5646:        line->type = MD_LINE_TABLE;
        1: 5647:        goto done;
        -: 5648:    }
        -: 5649:
        -: 5650:    /* Check for ATX header. */
        2: 5651:    if(line->indent < ctx->code_indent_offset  &&  CH(off) == _T('#')) {
    #####: 5652:        unsigned level;
        -: 5653:
    #####: 5654:        if(md_is_atxheader_line(ctx, off, &line->beg, &off, &level)) {
    #####: 5655:            line->type = MD_LINE_ATXHEADER;
    #####: 5656:            line->data = level;
    #####: 5657:            goto done;
        -: 5658:        }
        -: 5659:    }
        -: 5660:
        -: 5661:    /* Check whether we are starting code fence. */
        2: 5662:    if(CH(off) == _T('`') || CH(off) == _T('~')) {
    #####: 5663:        if(md_is_opening_code_fence(ctx, off, &off)) {
    #####: 5664:            line->type = MD_LINE_FENCEDCODE;
    #####: 5665:            line->data = 1;
    #####: 5666:            goto done;
        -: 5667:        }
        -: 5668:    }
        -: 5669:
        -: 5670:    /* Check for start of raw HTML block. */
        2: 5671:    if(CH(off) == _T('<')  &&  !(ctx->r.flags & MD_FLAG_NOHTMLBLOCKS))
        -: 5672:    {
    #####: 5673:        ctx->html_block_type = md_is_html_block_start_condition(ctx, off);
        -: 5674:
        -: 5675:        /* HTML block type 7 cannot interrupt paragraph. */
    #####: 5676:        if(ctx->html_block_type == 7  &&  pivot_line->type == MD_LINE_TEXT)
    #####: 5677:            ctx->html_block_type = 0;
        -: 5678:
    #####: 5679:        if(ctx->html_block_type > 0) {
        -: 5680:            /* The line itself also may immediately close the block. */
    #####: 5681:            if(md_is_html_block_end_condition(ctx, off, &off) == ctx->html_block_type) {
        -: 5682:                /* Make sure this is the last line of the block. */
    #####: 5683:                ctx->html_block_type = 0;
        -: 5684:            }
        -: 5685:
    #####: 5686:            line->type = MD_LINE_HTML;
    #####: 5687:            goto done;
        -: 5688:        }
        -: 5689:    }
        -: 5690:
        -: 5691:    /* Check for table underline. */
        3: 5692:    if((ctx->r.flags & MD_FLAG_TABLES)  &&  pivot_line->type == MD_LINE_TEXT  &&
        2: 5693:       (CH(off) == _T('|') || CH(off) == _T('-') || CH(off) == _T(':'))  &&
        1: 5694:       n_parents == ctx->n_containers)
        -: 5695:    {
        1: 5696:        unsigned col_count;
        -: 5697:
        2: 5698:        if(ctx->current_block != NULL  &&  ctx->current_block->n_lines == 1  &&
        2: 5699:            md_is_table_underline(ctx, off, &off, &col_count)  &&
        1: 5700:            md_is_table_row(ctx, pivot_line->beg, NULL))
        -: 5701:        {
        1: 5702:            line->data = col_count;
        1: 5703:            line->type = MD_LINE_TABLEUNDERLINE;
        1: 5704:            goto done;
        -: 5705:        }
        -: 5706:    }
        -: 5707:
        -: 5708:    /* By default, we are normal text line. */
        1: 5709:    line->type = MD_LINE_TEXT;
        1: 5710:    if(pivot_line->type == MD_LINE_TEXT  &&  n_brothers + n_children == 0) {
        -: 5711:        /* Lazy continuation. */
    #####: 5712:        n_parents = ctx->n_containers;
        -: 5713:    }
        -: 5714:
        4: 5715:done:
        -: 5716:    /* Scan for end of the line.
        -: 5717:     *
        -: 5718:     * Note this is bottleneck of this function as we itereate over (almost)
        -: 5719:     * all line contents after some initial line indentation. To optimize, we
        -: 5720:     * try to eat multiple chars in every loop iteration.
        -: 5721:     *
        -: 5722:     * (Measured ~6% performance boost of md2html with this optimization for
        -: 5723:     * normal kind of input.)
        -: 5724:     */
        6: 5725:    while(off + 4 < ctx->size  &&  !ISNEWLINE(off+0)  &&  !ISNEWLINE(off+1)
        1: 5726:                               &&  !ISNEWLINE(off+2)  &&  !ISNEWLINE(off+3))
    #####: 5727:        off += 4;
       12: 5728:    while(off < ctx->size  &&  !ISNEWLINE(off))
        3: 5729:        off++;
        -: 5730:
        3: 5731:done_on_eol:
        -: 5732:    /* Set end of the line. */
        3: 5733:    line->end = off;
        -: 5734:
        -: 5735:    /* But for ATX header, we should exclude the optional trailing mark. */
        3: 5736:    if(line->type == MD_LINE_ATXHEADER) {
        -: 5737:        OFF tmp = line->end;
    #####: 5738:        while(tmp > line->beg && CH(tmp-1) == _T(' '))
        -: 5739:            tmp--;
    #####: 5740:        while(tmp > line->beg && CH(tmp-1) == _T('#'))
        -: 5741:            tmp--;
    #####: 5742:        if(tmp == line->beg || CH(tmp-1) == _T(' ') || (ctx->r.flags & MD_FLAG_PERMISSIVEATXHEADERS))
    #####: 5743:            line->end = tmp;
        -: 5744:    }
        -: 5745:
        -: 5746:    /* Trim trailing spaces. */
        3: 5747:    if(line->type != MD_LINE_INDENTEDCODE  &&  line->type != MD_LINE_FENCEDCODE) {
        3: 5748:        while(line->end > line->beg && CH(line->end-1) == _T(' '))
    #####: 5749:            line->end--;
        -: 5750:    }
        -: 5751:
        -: 5752:    /* Eat also the new line. */
        3: 5753:    if(off < ctx->size && CH(off) == _T('\r'))
    #####: 5754:        off++;
        3: 5755:    if(off < ctx->size && CH(off) == _T('\n'))
        3: 5756:        off++;
        -: 5757:
        3: 5758:    *p_end = off;
        -: 5759:
        -: 5760:    /* If we belong to a list after seeing a blank line, the list is loose. */
        3: 5761:    if(prev_line_has_list_loosening_effect  &&  line->type != MD_LINE_BLANK  &&  n_parents + n_brothers > 0) {
    #####: 5762:        MD_CONTAINER* c = &ctx->containers[n_parents + n_brothers - 1];
    #####: 5763:        if(c->ch != _T('>')) {
    #####: 5764:            MD_BLOCK* block = (MD_BLOCK*) (((char*)ctx->block_bytes) + c->block_byte_off);
    #####: 5765:            block->flags |= MD_BLOCK_LOOSE_LIST;
        -: 5766:        }
        -: 5767:    }
        -: 5768:
        -: 5769:    /* Leave any containers we are not part of anymore. */
        3: 5770:    if(n_children == 0  &&  n_parents + n_brothers < ctx->n_containers)
        1: 5771:        MD_CHECK(md_leave_child_containers(ctx, n_parents + n_brothers));
        -: 5772:
        -: 5773:    /* Enter any container we found a mark for. */
        3: 5774:    if(n_brothers > 0) {
    #####: 5775:        MD_ASSERT(n_brothers == 1);
    #####: 5776:        MD_CHECK(md_push_container_bytes(ctx, MD_BLOCK_LI, 0, 0,
        -: 5777:                MD_BLOCK_CONTAINER_CLOSER | MD_BLOCK_CONTAINER_OPENER));
        -: 5778:    }
        -: 5779:
        3: 5780:    if(n_children > 0)
        1: 5781:        MD_CHECK(md_enter_child_containers(ctx, n_children, line->data));
        -: 5782:
        3: 5783:abort:
        3: 5784:    return ret;
        -: 5785:}
        -: 5786:
        -: 5787:static int
        3: 5788:md_process_line(MD_CTX* ctx, const MD_LINE_ANALYSIS** p_pivot_line, const MD_LINE_ANALYSIS* line)
        -: 5789:{
        3: 5790:    const MD_LINE_ANALYSIS* pivot_line = *p_pivot_line;
        3: 5791:    int ret = 0;
        -: 5792:
        -: 5793:    /* Blank line ends current leaf block. */
        3: 5794:    if(line->type == MD_LINE_BLANK) {
    #####: 5795:        MD_CHECK(md_end_current_block(ctx));
    #####: 5796:        *p_pivot_line = &md_dummy_blank_line;
    #####: 5797:        return 0;
        -: 5798:    }
        -: 5799:
        -: 5800:    /* Some line types form block on their own. */
        3: 5801:    if(line->type == MD_LINE_HR || line->type == MD_LINE_ATXHEADER) {
    #####: 5802:        MD_CHECK(md_end_current_block(ctx));
        -: 5803:
        -: 5804:        /* Add our single-line block. */
    #####: 5805:        MD_CHECK(md_start_new_block(ctx, line));
    #####: 5806:        MD_CHECK(md_add_line_into_current_block(ctx, line));
    #####: 5807:        MD_CHECK(md_end_current_block(ctx));
    #####: 5808:        *p_pivot_line = &md_dummy_blank_line;
    #####: 5809:        return 0;
        -: 5810:    }
        -: 5811:
        -: 5812:    /* MD_LINE_SETEXTUNDERLINE changes meaning of the current block and ends it. */
        3: 5813:    if(line->type == MD_LINE_SETEXTUNDERLINE) {
    #####: 5814:        MD_ASSERT(ctx->current_block != NULL);
    #####: 5815:        ctx->current_block->type = MD_BLOCK_H;
    #####: 5816:        ctx->current_block->data = line->data;
    #####: 5817:        MD_CHECK(md_end_current_block(ctx));
    #####: 5818:        *p_pivot_line = &md_dummy_blank_line;
    #####: 5819:        return 0;
        -: 5820:    }
        -: 5821:
        -: 5822:    /* MD_LINE_TABLEUNDERLINE changes meaning of the current block. */
        3: 5823:    if(line->type == MD_LINE_TABLEUNDERLINE) {
        1: 5824:        MD_ASSERT(ctx->current_block != NULL);
        1: 5825:        MD_ASSERT(ctx->current_block->n_lines == 1);
        1: 5826:        ctx->current_block->type = MD_BLOCK_TABLE;
        1: 5827:        ctx->current_block->data = line->data;
        1: 5828:        MD_ASSERT(pivot_line != &md_dummy_blank_line);
        1: 5829:        ((MD_LINE_ANALYSIS*)pivot_line)->type = MD_LINE_TABLE;
        1: 5830:        MD_CHECK(md_add_line_into_current_block(ctx, line));
        -: 5831:        return 0;
        -: 5832:    }
        -: 5833:
        -: 5834:    /* The current block also ends if the line has different type. */
        2: 5835:    if(line->type != pivot_line->type)
        1: 5836:        MD_CHECK(md_end_current_block(ctx));
        -: 5837:
        -: 5838:    /* The current line may start a new block. */
        2: 5839:    if(ctx->current_block == NULL) {
        2: 5840:        MD_CHECK(md_start_new_block(ctx, line));
        1: 5841:        *p_pivot_line = line;
        -: 5842:    }
        -: 5843:
        -: 5844:    /* In all other cases the line is just a continuation of the current block. */
        1: 5845:    MD_CHECK(md_add_line_into_current_block(ctx, line));
        -: 5846:
        1: 5847:abort:
        -: 5848:    return ret;
        -: 5849:}
        -: 5850:
        -: 5851:static int
        1: 5852:md_process_doc(MD_CTX *ctx)
        -: 5853:{
        1: 5854:    const MD_LINE_ANALYSIS* pivot_line = &md_dummy_blank_line;
        1: 5855:    MD_LINE_ANALYSIS line_buf[2];
        1: 5856:    MD_LINE_ANALYSIS* line = &line_buf[0];
        1: 5857:    OFF off = 0;
        1: 5858:    int ret = 0;
        -: 5859:
        1: 5860:    MD_ENTER_BLOCK(MD_BLOCK_DOC, NULL);
        -: 5861:
        3: 5862:    while(off < ctx->size) {
        3: 5863:        if(line == pivot_line)
        1: 5864:            line = (line == &line_buf[0] ? &line_buf[1] : &line_buf[0]);
        -: 5865:
        3: 5866:        MD_CHECK(md_analyze_line(ctx, off, &off, pivot_line, line));
        3: 5867:        MD_CHECK(md_process_line(ctx, &pivot_line, line));
        -: 5868:    }
        -: 5869:
    #####: 5870:    md_end_current_block(ctx);
        -: 5871:
    #####: 5872:    MD_CHECK(md_build_ref_def_hashtable(ctx));
        -: 5873:
        -: 5874:    /* Process all blocks. */
    #####: 5875:    MD_CHECK(md_leave_child_containers(ctx, 0));
    #####: 5876:    MD_CHECK(md_process_all_blocks(ctx));
        -: 5877:
    #####: 5878:    MD_LEAVE_BLOCK(MD_BLOCK_DOC, NULL);
        -: 5879:
    #####: 5880:abort:
        -: 5881:
        -: 5882:#if 0
        -: 5883:    /* Output some memory consumption statistics. */
        -: 5884:    {
        -: 5885:        char buffer[256];
        -: 5886:        sprintf(buffer, "Alloced %u bytes for block buffer.",
        -: 5887:                    (unsigned)(ctx->alloc_block_bytes));
        -: 5888:        MD_LOG(buffer);
        -: 5889:
        -: 5890:        sprintf(buffer, "Alloced %u bytes for containers buffer.",
        -: 5891:                    (unsigned)(ctx->alloc_containers * sizeof(MD_CONTAINER)));
        -: 5892:        MD_LOG(buffer);
        -: 5893:
        -: 5894:        sprintf(buffer, "Alloced %u bytes for marks buffer.",
        -: 5895:                    (unsigned)(ctx->alloc_marks * sizeof(MD_MARK)));
        -: 5896:        MD_LOG(buffer);
        -: 5897:
        -: 5898:        sprintf(buffer, "Alloced %u bytes for aux. buffer.",
        -: 5899:                    (unsigned)(ctx->alloc_buffer * sizeof(MD_CHAR)));
        -: 5900:        MD_LOG(buffer);
        -: 5901:    }
        -: 5902:#endif
        -: 5903:
    #####: 5904:    return ret;
        -: 5905:}
        -: 5906:
        -: 5907:
        -: 5908:/********************
        -: 5909: ***  Public API  ***
        -: 5910: ********************/
        -: 5911:
        -: 5912:int
        1: 5913:md_parse(const MD_CHAR* text, MD_SIZE size, const MD_RENDERER* renderer, void* userdata)
        -: 5914:{
        1: 5915:    MD_CTX ctx;
        -: 5916:    int i;
        -: 5917:    int ret;
        -: 5918:
        -: 5919:    /* Setup context structure. */
        1: 5920:    memset(&ctx, 0, sizeof(MD_CTX));
        1: 5921:    ctx.text = text;
        1: 5922:    ctx.size = size;
        1: 5923:    memcpy(&ctx.r, renderer, sizeof(MD_RENDERER));
        1: 5924:    ctx.userdata = userdata;
        1: 5925:    ctx.code_indent_offset = (ctx.r.flags & MD_FLAG_NOINDENTEDCODEBLOCKS) ? (OFF)(-1) : 4;
        1: 5926:    md_build_mark_char_map(&ctx);
        -: 5927:
        -: 5928:    /* Reset all unresolved opener mark chains. */
        9: 5929:    for(i = 0; i < SIZEOF_ARRAY(ctx.mark_chains); i++) {
        8: 5930:        ctx.mark_chains[i].head = -1;
        8: 5931:        ctx.mark_chains[i].tail = -1;
        -: 5932:    }
        1: 5933:    ctx.unresolved_link_head = -1;
        1: 5934:    ctx.unresolved_link_tail = -1;
        -: 5935:
        -: 5936:    /* All the work. */
        1: 5937:    ret = md_process_doc(&ctx);
        -: 5938:
        -: 5939:    /* Clean-up. */
    #####: 5940:    md_free_ref_defs(&ctx);
    #####: 5941:    md_free_ref_def_hashtable(&ctx);
    #####: 5942:    free(ctx.buffer);
    #####: 5943:    free(ctx.marks);
    #####: 5944:    free(ctx.block_bytes);
    #####: 5945:    free(ctx.containers);
        -: 5946:
    #####: 5947:    return ret;
        -: 5948:}
