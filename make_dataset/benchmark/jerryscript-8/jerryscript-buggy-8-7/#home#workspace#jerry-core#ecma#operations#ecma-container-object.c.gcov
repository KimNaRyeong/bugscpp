        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-container-object.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:#include "ecma-container-object.h"
        -:   16:
        -:   17:#include "ecma-alloc.h"
        -:   18:#include "ecma-array-object.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-helpers.h"
        -:   25:#include "ecma-iterator-object.h"
        -:   26:#include "ecma-objects.h"
        -:   27:#include "ecma-property-hashmap.h"
        -:   28:
        -:   29:#include "jcontext.h"
        -:   30:
        -:   31:#if JERRY_BUILTIN_CONTAINER
        -:   32:
        -:   33:/** \addtogroup ecma ECMA
        -:   34: * @{
        -:   35: *
        -:   36: * \addtogroup \addtogroup ecmamaphelpers ECMA builtin Map/Set helper functions
        -:   37: * @{
        -:   38: */
        -:   39:
        -:   40:/**
        -:   41: * Create a new internal buffer.
        -:   42: *
        -:   43: * Note:
        -:   44: *   The first element of the collection tracks the size of the buffer.
        -:   45: *   ECMA_VALUE_EMPTY values are not calculated into the size.
        -:   46: *
        -:   47: * @return pointer to the internal buffer
        -:   48: */
        -:   49:static inline ecma_collection_t *
    #####:   50:ecma_op_create_internal_buffer (void)
        -:   51:{
    #####:   52:  ecma_collection_t *collection_p = ecma_new_collection ();
    #####:   53:  ecma_collection_push_back (collection_p, (ecma_value_t) 0);
        -:   54:
    #####:   55:  return collection_p;
        -:   56:} /* ecma_op_create_internal_buffer */
        -:   57:
        -:   58:/**
        -:   59: * Append values to the internal buffer.
        -:   60: */
        -:   61:static void
    #####:   62:ecma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */
        -:   63:                                ecma_value_t key_arg, /**< key argument */
        -:   64:                                ecma_value_t value_arg, /**< value argument */
        -:   65:                                lit_magic_string_id_t lit_id) /**< class id */
        -:   66:{
    #####:   67:  JERRY_ASSERT (container_p != NULL);
        -:   68:
    #####:   69:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:   70:  {
    #####:   71:    ecma_value_t values[] = { ecma_copy_value_if_not_object (key_arg), ecma_copy_value_if_not_object (value_arg) };
    #####:   72:    ecma_collection_append (container_p, values, 2);
        -:   73:  }
        -:   74:  else
        -:   75:  {
    #####:   76:    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));
        -:   77:  }
        -:   78:
    #####:   79:  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);
    #####:   80:} /* ecma_op_internal_buffer_append */
        -:   81:
        -:   82:/**
        -:   83: * Update the value of a given entry.
        -:   84: */
        -:   85:static inline void
    #####:   86:ecma_op_internal_buffer_update (ecma_value_t *entry_p, /**< entry pointer */
        -:   87:                                ecma_value_t value_arg, /**< value argument */
        -:   88:                                lit_magic_string_id_t lit_id) /**< class id */
        -:   89:{
    #####:   90:  JERRY_ASSERT (entry_p != NULL);
        -:   91:
    #####:   92:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:   93:  {
    #####:   94:    ecma_free_value_if_not_object (((ecma_container_pair_t *) entry_p)->value);
        -:   95:
    #####:   96:    ((ecma_container_pair_t *) entry_p)->value = ecma_copy_value_if_not_object (value_arg);
        -:   97:  }
    #####:   98:} /* ecma_op_internal_buffer_update */
        -:   99:
        -:  100:/**
        -:  101: * Delete element from the internal buffer.
        -:  102: */
        -:  103:static void
    #####:  104:ecma_op_internal_buffer_delete (ecma_collection_t *container_p, /**< internal container pointer */
        -:  105:                                ecma_container_pair_t *entry_p, /**< entry pointer */
        -:  106:                                lit_magic_string_id_t lit_id) /**< class id */
        -:  107:{
    #####:  108:  JERRY_ASSERT (container_p != NULL);
    #####:  109:  JERRY_ASSERT (entry_p != NULL);
        -:  110:
    #####:  111:  ecma_free_value_if_not_object (entry_p->key);
    #####:  112:  entry_p->key = ECMA_VALUE_EMPTY;
        -:  113:
    #####:  114:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  115:  {
    #####:  116:    ecma_free_value_if_not_object (entry_p->value);
    #####:  117:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  118:  }
        -:  119:
    #####:  120:  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) - 1);
    #####:  121:} /* ecma_op_internal_buffer_delete */
        -:  122:
        -:  123:/**
        -:  124: * Find an entry in the collection.
        -:  125: *
        -:  126: * @return pointer to the appropriate entry.
        -:  127: */
        -:  128:static ecma_value_t *
    #####:  129:ecma_op_internal_buffer_find (ecma_collection_t *container_p, /**< internal container pointer */
        -:  130:                              ecma_value_t key_arg, /**< key argument */
        -:  131:                              lit_magic_string_id_t lit_id) /**< class id */
        -:  132:{
    #####:  133:  JERRY_ASSERT (container_p != NULL);
        -:  134:
    #####:  135:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
    #####:  136:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  137:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  138:
    #####:  139:  for (uint32_t i = 0; i < entry_count; i += entry_size)
        -:  140:  {
    #####:  141:    ecma_value_t *entry_p = start_p + i;
        -:  142:
    #####:  143:    if (ecma_op_same_value_zero (*entry_p, key_arg, false))
        -:  144:    {
    #####:  145:      return entry_p;
        -:  146:    }
        -:  147:  }
        -:  148:
    #####:  149:  return NULL;
        -:  150:} /* ecma_op_internal_buffer_find */
        -:  151:
        -:  152:/**
        -:  153: * Get the value that belongs to the key.
        -:  154: *
        -:  155: * Note: in case of Set containers, the values are the same as the keys.
        -:  156: *
        -:  157: * @return ecma value
        -:  158: */
        -:  159:static ecma_value_t
    #####:  160:ecma_op_container_get_value (ecma_value_t *entry_p, /**< entry (key) pointer */
        -:  161:                             lit_magic_string_id_t lit_id) /**< class id */
        -:  162:{
    #####:  163:  JERRY_ASSERT (entry_p != NULL);
        -:  164:
    #####:  165:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  166:  {
    #####:  167:    return ((ecma_container_pair_t *) entry_p)->value;
        -:  168:  }
        -:  169:
    #####:  170:  return *entry_p;
        -:  171:} /* ecma_op_container_get_value */
        -:  172:
        -:  173:/**
        -:  174: * Get the size (in ecma_value_t) of the stored entries.
        -:  175: *
        -:  176: * @return size of the entries.
        -:  177: */
        -:  178:uint8_t
    #####:  179:ecma_op_container_entry_size (lit_magic_string_id_t lit_id) /**< class id */
        -:  180:{
    #####:  181:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)
        -:  182:  {
    #####:  183:    return ECMA_CONTAINER_PAIR_SIZE;
        -:  184:  }
        -:  185:
    #####:  186:  return ECMA_CONTAINER_VALUE_SIZE;
        -:  187:} /* ecma_op_container_entry_size */
        -:  188:
        -:  189:/**
        -:  190: * Release the entries in the WeakSet container.
        -:  191: */
        -:  192:static void
    #####:  193:ecma_op_container_free_weakset_entries (ecma_object_t *object_p, /**< object pointer */
        -:  194:                                        ecma_collection_t *container_p) /** internal buffer pointer */
        -:  195:{
    #####:  196:  JERRY_ASSERT (object_p != NULL);
    #####:  197:  JERRY_ASSERT (container_p != NULL);
        -:  198:
    #####:  199:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  200:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  201:
    #####:  202:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)
        -:  203:  {
    #####:  204:    ecma_value_t *entry_p = start_p + i;
        -:  205:
    #####:  206:    if (ecma_is_value_empty (*entry_p))
        -:  207:    {
    #####:  208:      continue;
        -:  209:    }
        -:  210:
    #####:  211:    ecma_op_object_unref_weak (ecma_get_object_from_value (*entry_p), ecma_make_object_value (object_p));
    #####:  212:    ecma_op_container_remove_weak_entry (object_p, *entry_p);
        -:  213:
    #####:  214:    *entry_p = ECMA_VALUE_EMPTY;
        -:  215:  }
    #####:  216:} /* ecma_op_container_free_weakset_entries */
        -:  217:
        -:  218:/**
        -:  219: * Release the entries in the WeakMap container.
        -:  220: */
        -:  221:static void
    #####:  222:ecma_op_container_free_weakmap_entries (ecma_object_t *object_p, /**< object pointer */
        -:  223:                                        ecma_collection_t *container_p) /**< internal buffer pointer */
        -:  224:{
    #####:  225:  JERRY_ASSERT (object_p != NULL);
    #####:  226:  JERRY_ASSERT (container_p != NULL);
        -:  227:
    #####:  228:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  229:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  230:
    #####:  231:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)
        -:  232:  {
    #####:  233:    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);
        -:  234:
    #####:  235:    if (ecma_is_value_empty (entry_p->key))
        -:  236:    {
    #####:  237:      continue;
        -:  238:    }
        -:  239:
    #####:  240:    ecma_op_object_unref_weak (ecma_get_object_from_value (entry_p->key), ecma_make_object_value (object_p));
    #####:  241:    ecma_op_container_remove_weak_entry (object_p, entry_p->key);
        -:  242:
    #####:  243:    ecma_free_value_if_not_object (entry_p->value);
        -:  244:
    #####:  245:    entry_p->key = ECMA_VALUE_EMPTY;
    #####:  246:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  247:  }
    #####:  248:} /* ecma_op_container_free_weakmap_entries */
        -:  249:
        -:  250:/**
        -:  251: * Release the entries in the Set container.
        -:  252: */
        -:  253:static void
    #####:  254:ecma_op_container_free_set_entries (ecma_collection_t *container_p)
        -:  255:{
    #####:  256:  JERRY_ASSERT (container_p != NULL);
        -:  257:
    #####:  258:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  259:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  260:
    #####:  261:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_VALUE_SIZE)
        -:  262:  {
    #####:  263:    ecma_value_t *entry_p = start_p + i;
        -:  264:
    #####:  265:    if (ecma_is_value_empty (*entry_p))
        -:  266:    {
    #####:  267:      continue;
        -:  268:    }
        -:  269:
    #####:  270:    ecma_free_value_if_not_object (*entry_p);
    #####:  271:    *entry_p = ECMA_VALUE_EMPTY;
        -:  272:  }
    #####:  273:} /* ecma_op_container_free_set_entries */
        -:  274:
        -:  275:/**
        -:  276: * Release the entries in the Map container.
        -:  277: */
        -:  278:static void
    #####:  279:ecma_op_container_free_map_entries (ecma_collection_t *container_p)
        -:  280:{
    #####:  281:  JERRY_ASSERT (container_p != NULL);
        -:  282:
    #####:  283:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  284:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
        -:  285:
    #####:  286:  for (uint32_t i = 0; i < entry_count; i += ECMA_CONTAINER_PAIR_SIZE)
        -:  287:  {
    #####:  288:    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);
        -:  289:
    #####:  290:    if (ecma_is_value_empty (entry_p->key))
        -:  291:    {
    #####:  292:      continue;
        -:  293:    }
        -:  294:
    #####:  295:    ecma_free_value_if_not_object (entry_p->key);
    #####:  296:    ecma_free_value_if_not_object (entry_p->value);
        -:  297:
    #####:  298:    entry_p->key = ECMA_VALUE_EMPTY;
    #####:  299:    entry_p->value = ECMA_VALUE_EMPTY;
        -:  300:  }
    #####:  301:} /* ecma_op_container_free_map_entries */
        -:  302:
        -:  303:/**
        -:  304: * Release the internal buffer and the stored entries.
        -:  305: */
        -:  306:void
    #####:  307:ecma_op_container_free_entries (ecma_object_t *object_p) /**< collection object pointer */
        -:  308:{
    #####:  309:  JERRY_ASSERT (object_p != NULL);
        -:  310:
    #####:  311:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
    #####:  312:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  313:
    #####:  314:  switch (map_object_p->u.cls.u2.container_id)
        -:  315:  {
    #####:  316:    case LIT_MAGIC_STRING_WEAKSET_UL:
        -:  317:    {
    #####:  318:      ecma_op_container_free_weakset_entries (object_p, container_p);
    #####:  319:      break;
        -:  320:    }
    #####:  321:    case LIT_MAGIC_STRING_WEAKMAP_UL:
        -:  322:    {
    #####:  323:      ecma_op_container_free_weakmap_entries (object_p, container_p);
    #####:  324:      break;
        -:  325:    }
    #####:  326:    case LIT_MAGIC_STRING_SET_UL:
        -:  327:    {
    #####:  328:      ecma_op_container_free_set_entries (container_p);
    #####:  329:      break;
        -:  330:    }
    #####:  331:    case LIT_MAGIC_STRING_MAP_UL:
        -:  332:    {
    #####:  333:      ecma_op_container_free_map_entries (container_p);
    #####:  334:      break;
        -:  335:    }
    #####:  336:    default:
        -:  337:    {
    #####:  338:      break;
        -:  339:    }
        -:  340:  }
        -:  341:
    #####:  342:  ECMA_CONTAINER_SET_SIZE (container_p, 0);
    #####:  343:} /* ecma_op_container_free_entries */
        -:  344:
        -:  345:/**
        -:  346: * Handle calling [[Construct]] of built-in Map/Set like objects
        -:  347: *
        -:  348: * @return ecma value
        -:  349: */
        -:  350:ecma_value_t
    #####:  351:ecma_op_container_create (const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  352:                          uint32_t arguments_list_len, /**< number of arguments */
        -:  353:                          lit_magic_string_id_t lit_id, /**< internal class id */
        -:  354:                          ecma_builtin_id_t proto_id) /**< prototype builtin id */
        -:  355:{
    #####:  356:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
    #####:  357:  JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_MAP_UL || lit_id == LIT_MAGIC_STRING_SET_UL
        -:  358:                || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL);
    #####:  359:  JERRY_ASSERT (JERRY_CONTEXT (current_new_target_p) != NULL);
        -:  360:
    #####:  361:  ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p), proto_id);
        -:  362:
    #####:  363:  if (JERRY_UNLIKELY (proto_p == NULL))
        -:  364:  {
    #####:  365:    return ECMA_VALUE_ERROR;
        -:  366:  }
        -:  367:
    #####:  368:  ecma_collection_t *container_p = ecma_op_create_internal_buffer ();
    #####:  369:  ecma_object_t *object_p = ecma_create_object (proto_p, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
    #####:  370:  ecma_deref_object (proto_p);
    #####:  371:  ecma_extended_object_t *map_obj_p = (ecma_extended_object_t *) object_p;
    #####:  372:  map_obj_p->u.cls.type = ECMA_OBJECT_CLASS_CONTAINER;
    #####:  373:  map_obj_p->u.cls.u1.container_flags = ECMA_CONTAINER_FLAGS_EMPTY;
    #####:  374:  map_obj_p->u.cls.u2.container_id = (uint16_t) lit_id;
        -:  375:
    #####:  376:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)
        -:  377:  {
    #####:  378:    map_obj_p->u.cls.u1.container_flags |= ECMA_CONTAINER_FLAGS_WEAK;
        -:  379:  }
        -:  380:
    #####:  381:  ECMA_SET_INTERNAL_VALUE_POINTER (map_obj_p->u.cls.u3.value, container_p);
        -:  382:
    #####:  383:  ecma_value_t set_value = ecma_make_object_value (object_p);
    #####:  384:  ecma_value_t result = set_value;
        -:  385:
        -:  386:#if JERRY_ESNEXT
    #####:  387:  if (arguments_list_len == 0)
        -:  388:  {
    #####:  389:    return result;
        -:  390:  }
        -:  391:
    #####:  392:  ecma_value_t iterable = arguments_list_p[0];
        -:  393:
    #####:  394:  if (ecma_is_value_undefined (iterable) || ecma_is_value_null (iterable))
        -:  395:  {
    #####:  396:    return result;
        -:  397:  }
        -:  398:
        -:  399:  lit_magic_string_id_t adder_string_id;
    #####:  400:  if (lit_id == LIT_MAGIC_STRING_MAP_UL || lit_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -:  401:  {
    #####:  402:    adder_string_id = LIT_MAGIC_STRING_SET;
        -:  403:  }
        -:  404:  else
        -:  405:  {
    #####:  406:    adder_string_id = LIT_MAGIC_STRING_ADD;
        -:  407:  }
        -:  408:
    #####:  409:  result = ecma_op_object_get_by_magic_id (object_p, adder_string_id);
    #####:  410:  if (ECMA_IS_VALUE_ERROR (result))
        -:  411:  {
    #####:  412:    goto cleanup_object;
        -:  413:  }
        -:  414:
    #####:  415:  if (!ecma_op_is_callable (result))
        -:  416:  {
    #####:  417:    ecma_free_value (result);
    #####:  418:    result = ecma_raise_type_error (ECMA_ERR_FUNCTION_ADD_ORSET_IS_NOT_CALLABLE);
    #####:  419:    goto cleanup_object;
        -:  420:  }
        -:  421:
    #####:  422:  ecma_object_t *adder_func_p = ecma_get_object_from_value (result);
        -:  423:
    #####:  424:  ecma_value_t next_method;
    #####:  425:  result = ecma_op_get_iterator (iterable, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  426:
    #####:  427:  if (ECMA_IS_VALUE_ERROR (result))
        -:  428:  {
    #####:  429:    goto cleanup_adder;
        -:  430:  }
        -:  431:
    #####:  432:  const ecma_value_t iterator = result;
        -:  433:
        -:  434:  while (true)
    #####:  435:  {
    #####:  436:    result = ecma_op_iterator_step (iterator, next_method);
        -:  437:
    #####:  438:    if (ECMA_IS_VALUE_ERROR (result))
        -:  439:    {
    #####:  440:      goto cleanup_iterator;
        -:  441:    }
        -:  442:
    #####:  443:    if (ecma_is_value_false (result))
        -:  444:    {
    #####:  445:      break;
        -:  446:    }
        -:  447:
    #####:  448:    const ecma_value_t next = result;
    #####:  449:    result = ecma_op_iterator_value (next);
    #####:  450:    ecma_free_value (next);
        -:  451:
    #####:  452:    if (ECMA_IS_VALUE_ERROR (result))
        -:  453:    {
    #####:  454:      goto cleanup_iterator;
        -:  455:    }
        -:  456:
    #####:  457:    if (lit_id == LIT_MAGIC_STRING_SET_UL || lit_id == LIT_MAGIC_STRING_WEAKSET_UL)
        -:  458:    {
    #####:  459:      const ecma_value_t value = result;
        -:  460:
    #####:  461:      ecma_value_t arguments[] = { value };
    #####:  462:      result = ecma_op_function_call (adder_func_p, set_value, arguments, 1);
        -:  463:
    #####:  464:      ecma_free_value (value);
        -:  465:    }
        -:  466:    else
        -:  467:    {
    #####:  468:      if (!ecma_is_value_object (result))
        -:  469:      {
    #####:  470:        ecma_free_value (result);
    #####:  471:        ecma_raise_type_error (ECMA_ERR_ITERATOR_VALUE_IS_NOT_AN_OBJECT);
    #####:  472:        result = ecma_op_iterator_close (iterator);
    #####:  473:        JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result));
    #####:  474:        goto cleanup_iterator;
        -:  475:      }
        -:  476:
    #####:  477:      ecma_object_t *next_object_p = ecma_get_object_from_value (result);
        -:  478:
    #####:  479:      result = ecma_op_object_get_by_index (next_object_p, 0);
        -:  480:
    #####:  481:      if (ECMA_IS_VALUE_ERROR (result))
        -:  482:      {
    #####:  483:        ecma_deref_object (next_object_p);
    #####:  484:        ecma_op_iterator_close (iterator);
    #####:  485:        goto cleanup_iterator;
        -:  486:      }
        -:  487:
    #####:  488:      const ecma_value_t key = result;
        -:  489:
    #####:  490:      result = ecma_op_object_get_by_index (next_object_p, 1);
        -:  491:
    #####:  492:      if (ECMA_IS_VALUE_ERROR (result))
        -:  493:      {
    #####:  494:        ecma_deref_object (next_object_p);
    #####:  495:        ecma_free_value (key);
    #####:  496:        ecma_op_iterator_close (iterator);
    #####:  497:        goto cleanup_iterator;
        -:  498:      }
        -:  499:
    #####:  500:      const ecma_value_t value = result;
    #####:  501:      ecma_value_t arguments[] = { key, value };
    #####:  502:      result = ecma_op_function_call (adder_func_p, set_value, arguments, 2);
        -:  503:
    #####:  504:      ecma_free_value (key);
    #####:  505:      ecma_free_value (value);
    #####:  506:      ecma_deref_object (next_object_p);
        -:  507:    }
        -:  508:
    #####:  509:    if (ECMA_IS_VALUE_ERROR (result))
        -:  510:    {
    #####:  511:      ecma_op_iterator_close (iterator);
    #####:  512:      goto cleanup_iterator;
        -:  513:    }
        -:  514:
    #####:  515:    ecma_free_value (result);
        -:  516:  }
        -:  517:
    #####:  518:  ecma_ref_object (object_p);
    #####:  519:  result = ecma_make_object_value (object_p);
        -:  520:
    #####:  521:cleanup_iterator:
    #####:  522:  ecma_free_value (iterator);
    #####:  523:  ecma_free_value (next_method);
    #####:  524:cleanup_adder:
    #####:  525:  ecma_deref_object (adder_func_p);
    #####:  526:cleanup_object:
    #####:  527:  ecma_deref_object (object_p);
        -:  528:#endif /* JERRY_ESNEXT */
        -:  529:
    #####:  530:  return result;
        -:  531:} /* ecma_op_container_create */
        -:  532:
        -:  533:/**
        -:  534: * Get Map/Set object pointer
        -:  535: *
        -:  536: * Note:
        -:  537: *   If the function returns with NULL, the error object has
        -:  538: *   already set, and the caller must return with ECMA_VALUE_ERROR
        -:  539: *
        -:  540: * @return pointer to the Map/Set if this_arg is a valid Map/Set object
        -:  541: *         NULL otherwise
        -:  542: */
        -:  543:ecma_extended_object_t *
    #####:  544:ecma_op_container_get_object (ecma_value_t this_arg, /**< this argument */
        -:  545:                              lit_magic_string_id_t lit_id) /**< internal class id */
        -:  546:{
    #####:  547:  if (ecma_is_value_object (this_arg))
        -:  548:  {
    #####:  549:    ecma_object_t *map_object_p = ecma_get_object_from_value (this_arg);
        -:  550:
    #####:  551:    if (ecma_object_class_is (map_object_p, ECMA_OBJECT_CLASS_CONTAINER)
    #####:  552:        && ((ecma_extended_object_t *) map_object_p)->u.cls.u2.container_id == lit_id)
        -:  553:    {
    #####:  554:      return (ecma_extended_object_t *) map_object_p;
        -:  555:    }
        -:  556:  }
        -:  557:
        -:  558:#if JERRY_ERROR_MESSAGES
    #####:  559:  ecma_raise_standard_error_with_format (JERRY_ERROR_TYPE,
        -:  560:                                         "Expected a % object",
    #####:  561:                                         ecma_make_string_value (ecma_get_magic_string (lit_id)));
        -:  562:#else /* !JERRY_ERROR_MESSAGES */
        -:  563:  ecma_raise_type_error (ECMA_ERR_EMPTY);
        -:  564:#endif /* JERRY_ERROR_MESSAGES */
        -:  565:
    #####:  566:  return NULL;
        -:  567:} /* ecma_op_container_get_object */
        -:  568:
        -:  569:/**
        -:  570: * Returns with the size of the Map/Set object.
        -:  571: *
        -:  572: * @return size of the Map/Set object as ecma-value.
        -:  573: */
        -:  574:ecma_value_t
    #####:  575:ecma_op_container_size (ecma_extended_object_t *map_object_p) /**< internal class id */
        -:  576:{
    #####:  577:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  578:
    #####:  579:  return ecma_make_uint32_value (ECMA_CONTAINER_GET_SIZE (container_p));
        -:  580:} /* ecma_op_container_size */
        -:  581:
        -:  582:/**
        -:  583: * The generic Map/WeakMap prototype object's 'get' routine
        -:  584: *
        -:  585: * @return ecma value
        -:  586: *         Returned value must be freed with ecma_free_value.
        -:  587: */
        -:  588:ecma_value_t
    #####:  589:ecma_op_container_get (ecma_extended_object_t *map_object_p, /**< map object */
        -:  590:                       ecma_value_t key_arg, /**< key argument */
        -:  591:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  592:{
    #####:  593:  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL && !ecma_is_value_object (key_arg))
        -:  594:  {
    #####:  595:    return ECMA_VALUE_UNDEFINED;
        -:  596:  }
        -:  597:
    #####:  598:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  599:
    #####:  600:  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)
        -:  601:  {
    #####:  602:    return ECMA_VALUE_UNDEFINED;
        -:  603:  }
        -:  604:
    #####:  605:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  606:
    #####:  607:  if (entry_p == NULL)
        -:  608:  {
    #####:  609:    return ECMA_VALUE_UNDEFINED;
        -:  610:  }
        -:  611:
    #####:  612:  return ecma_copy_value (((ecma_container_pair_t *) entry_p)->value);
        -:  613:} /* ecma_op_container_get */
        -:  614:
        -:  615:/**
        -:  616: * The generic Map/Set prototype object's 'has' routine
        -:  617: *
        -:  618: * @return ecma value
        -:  619: *         Returned value must be freed with ecma_free_value.
        -:  620: */
        -:  621:ecma_value_t
    #####:  622:ecma_op_container_has (ecma_extended_object_t *map_object_p, /**< map object */
        -:  623:                       ecma_value_t key_arg, /**< key argument */
        -:  624:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  625:{
    #####:  626:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  627:
    #####:  628:  if ((map_object_p->u.cls.u1.container_flags & ECMA_CONTAINER_FLAGS_WEAK) != 0 && !ecma_is_value_object (key_arg))
        -:  629:  {
    #####:  630:    return ECMA_VALUE_FALSE;
        -:  631:  }
        -:  632:
    #####:  633:  if (ECMA_CONTAINER_GET_SIZE (container_p) == 0)
        -:  634:  {
    #####:  635:    return ECMA_VALUE_FALSE;
        -:  636:  }
        -:  637:
    #####:  638:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  639:
    #####:  640:  return ecma_make_boolean_value (entry_p != NULL);
        -:  641:} /* ecma_op_container_has */
        -:  642:
        -:  643:/**
        -:  644: * Helper method for the Map.prototype.set and Set.prototype.add methods to swap the sign of the given value if needed
        -:  645: *
        -:  646: * See also:
        -:  647: *          ECMA-262 v6, 23.2.3.1 step 6
        -:  648: *          ECMA-262 v6, 23.1.3.9 step 6
        -:  649: *
        -:  650: * @return ecma value
        -:  651: */
        -:  652:static ecma_value_t
    #####:  653:ecma_op_container_set_noramlize_zero (ecma_value_t this_arg) /*< this arg */
        -:  654:{
    #####:  655:  if (ecma_is_value_number (this_arg))
        -:  656:  {
    #####:  657:    ecma_number_t number_value = ecma_get_number_from_value (this_arg);
        -:  658:
    #####:  659:    if (JERRY_UNLIKELY (ecma_number_is_zero (number_value) && ecma_number_is_negative (number_value)))
        -:  660:    {
    #####:  661:      return ecma_make_integer_value (0);
        -:  662:    }
        -:  663:  }
        -:  664:
    #####:  665:  return this_arg;
        -:  666:} /* ecma_op_container_set_noramlize_zero */
        -:  667:
        -:  668:/**
        -:  669: * The generic Map prototype object's 'set' and Set prototype object's 'add' routine
        -:  670: *
        -:  671: * @return ecma value
        -:  672: *         Returned value must be freed with ecma_free_value.
        -:  673: */
        -:  674:ecma_value_t
    #####:  675:ecma_op_container_set (ecma_extended_object_t *map_object_p, /**< map object */
        -:  676:                       ecma_value_t key_arg, /**< key argument */
        -:  677:                       ecma_value_t value_arg, /**< value argument */
        -:  678:                       lit_magic_string_id_t lit_id) /**< internal class id */
        -:  679:{
    #####:  680:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  681:
    #####:  682:  if ((map_object_p->u.cls.u1.container_flags & ECMA_CONTAINER_FLAGS_WEAK) != 0 && !ecma_is_value_object (key_arg))
        -:  683:  {
    #####:  684:    return ecma_raise_type_error (ECMA_ERR_KEY_MUST_BE_AN_OBJECT);
        -:  685:  }
        -:  686:
    #####:  687:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  688:
    #####:  689:  if (entry_p == NULL)
        -:  690:  {
    #####:  691:    ecma_op_internal_buffer_append (container_p, ecma_op_container_set_noramlize_zero (key_arg), value_arg, lit_id);
        -:  692:
    #####:  693:    if ((map_object_p->u.cls.u1.container_flags & ECMA_CONTAINER_FLAGS_WEAK) != 0)
        -:  694:    {
    #####:  695:      ecma_object_t *key_p = ecma_get_object_from_value (key_arg);
    #####:  696:      ecma_op_object_set_weak (key_p, (ecma_object_t *) map_object_p);
        -:  697:    }
        -:  698:  }
        -:  699:  else
        -:  700:  {
    #####:  701:    ecma_op_internal_buffer_update (entry_p, ecma_op_container_set_noramlize_zero (value_arg), lit_id);
        -:  702:  }
        -:  703:
    #####:  704:  ecma_ref_object ((ecma_object_t *) map_object_p);
    #####:  705:  return ecma_make_object_value ((ecma_object_t *) map_object_p);
        -:  706:} /* ecma_op_container_set */
        -:  707:
        -:  708:/**
        -:  709: * The generic Map/Set prototype object's 'forEach' routine
        -:  710: *
        -:  711: * @return ecma value
        -:  712: *         Returned value must be freed with ecma_free_value.
        -:  713: */
        -:  714:ecma_value_t
    #####:  715:ecma_op_container_foreach (ecma_extended_object_t *map_object_p, /**< map object */
        -:  716:                           ecma_value_t predicate, /**< callback function */
        -:  717:                           ecma_value_t predicate_this_arg, /**< this argument for
        -:  718:                                                             *   invoke predicate */
        -:  719:                           lit_magic_string_id_t lit_id) /**< internal class id */
        -:  720:{
    #####:  721:  if (!ecma_op_is_callable (predicate))
        -:  722:  {
    #####:  723:    return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -:  724:  }
        -:  725:
    #####:  726:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####:  727:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
    #####:  728:  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;
        -:  729:
    #####:  730:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  731:
    #####:  732:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
        -:  733:
    #####:  734:  for (uint32_t i = 0; i < ECMA_CONTAINER_ENTRY_COUNT (container_p); i += entry_size)
        -:  735:  {
    #####:  736:    ecma_value_t *entry_p = ECMA_CONTAINER_START (container_p) + i;
        -:  737:
    #####:  738:    if (ecma_is_value_empty (*entry_p))
        -:  739:    {
    #####:  740:      continue;
        -:  741:    }
        -:  742:
    #####:  743:    ecma_value_t key_arg = *entry_p;
    #####:  744:    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);
        -:  745:
    #####:  746:    ecma_value_t this_arg = ecma_make_object_value ((ecma_object_t *) map_object_p);
    #####:  747:    ecma_value_t call_args[] = { value_arg, key_arg, this_arg };
    #####:  748:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -:  749:
    #####:  750:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  751:    {
    #####:  752:      ret_value = call_value;
    #####:  753:      break;
        -:  754:    }
        -:  755:
    #####:  756:    ecma_free_value (call_value);
        -:  757:  }
        -:  758:
    #####:  759:  return ret_value;
        -:  760:} /* ecma_op_container_foreach */
        -:  761:
        -:  762:/**
        -:  763: * The Map/Set prototype object's 'clear' routine
        -:  764: *
        -:  765: * @return ecma value
        -:  766: *         Returned value must be freed with ecma_free_value.
        -:  767: */
        -:  768:ecma_value_t
    #####:  769:ecma_op_container_clear (ecma_extended_object_t *map_object_p) /**< this argument */
        -:  770:{
    #####:  771:  ecma_op_container_free_entries ((ecma_object_t *) map_object_p);
        -:  772:
    #####:  773:  return ECMA_VALUE_UNDEFINED;
        -:  774:} /* ecma_op_container_clear */
        -:  775:
        -:  776:/**
        -:  777: * The generic Map/Set prototype object's 'delete' routine
        -:  778: *
        -:  779: * @return ecma value
        -:  780: *         Returned value must be freed with ecma_free_value.
        -:  781: */
        -:  782:ecma_value_t
    #####:  783:ecma_op_container_delete (ecma_extended_object_t *map_object_p, /**< map object */
        -:  784:                          ecma_value_t key_arg, /**< key argument */
        -:  785:                          lit_magic_string_id_t lit_id) /**< internal class id */
        -:  786:{
    #####:  787:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  788:
    #####:  789:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  790:
    #####:  791:  if (entry_p == NULL)
        -:  792:  {
    #####:  793:    return ECMA_VALUE_FALSE;
        -:  794:  }
        -:  795:
    #####:  796:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);
    #####:  797:  return ECMA_VALUE_TRUE;
        -:  798:} /* ecma_op_container_delete */
        -:  799:
        -:  800:/**
        -:  801: * The generic WeakMap/WeakSet prototype object's 'delete' routine
        -:  802: *
        -:  803: * @return ecma value
        -:  804: *         Returned value must be freed with ecma_free_value.
        -:  805: */
        -:  806:ecma_value_t
    #####:  807:ecma_op_container_delete_weak (ecma_extended_object_t *map_object_p, /**< map object */
        -:  808:                               ecma_value_t key_arg, /**< key argument */
        -:  809:                               lit_magic_string_id_t lit_id) /**< internal class id */
        -:  810:{
    #####:  811:  if (!ecma_is_value_object (key_arg))
        -:  812:  {
    #####:  813:    return ECMA_VALUE_FALSE;
        -:  814:  }
        -:  815:
    #####:  816:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  817:
    #####:  818:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, lit_id);
        -:  819:
    #####:  820:  if (entry_p == NULL)
        -:  821:  {
    #####:  822:    return ECMA_VALUE_FALSE;
        -:  823:  }
        -:  824:
    #####:  825:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, lit_id);
        -:  826:
    #####:  827:  ecma_object_t *key_object_p = ecma_get_object_from_value (key_arg);
    #####:  828:  ecma_op_object_unref_weak (key_object_p, ecma_make_object_value ((ecma_object_t *) map_object_p));
        -:  829:
    #####:  830:  return ECMA_VALUE_TRUE;
        -:  831:} /* ecma_op_container_delete_weak */
        -:  832:
        -:  833:/**
        -:  834: * Helper function to get the value from a weak container object
        -:  835: *
        -:  836: * @return value property
        -:  837: */
        -:  838:ecma_value_t
    #####:  839:ecma_op_container_find_weak_value (ecma_object_t *object_p, /**< internal container object */
        -:  840:                                   ecma_value_t key_arg) /**< key */
        -:  841:{
    #####:  842:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
        -:  843:
    #####:  844:  JERRY_ASSERT (map_object_p->u.cls.type == ECMA_OBJECT_CLASS_CONTAINER
        -:  845:                && map_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL);
        -:  846:
    #####:  847:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  848:
    #####:  849:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, map_object_p->u.cls.u2.container_id);
        -:  850:
    #####:  851:  JERRY_ASSERT (entry_p != NULL);
        -:  852:
    #####:  853:  return entry_p[1];
        -:  854:} /* ecma_op_container_find_weak_value */
        -:  855:
        -:  856:/**
        -:  857: * Helper function to remove a key/value pair from a weak container object
        -:  858: */
        -:  859:void
    #####:  860:ecma_op_container_remove_weak_entry (ecma_object_t *object_p, /**< internal container object */
        -:  861:                                     ecma_value_t key_arg) /**< key */
        -:  862:{
    #####:  863:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
        -:  864:
    #####:  865:  JERRY_ASSERT (map_object_p->u.cls.type == ECMA_OBJECT_CLASS_CONTAINER
        -:  866:                && (map_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKSET_UL
        -:  867:                    || map_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL));
        -:  868:
    #####:  869:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
        -:  870:
    #####:  871:  ecma_value_t *entry_p = ecma_op_internal_buffer_find (container_p, key_arg, map_object_p->u.cls.u2.container_id);
        -:  872:
    #####:  873:  JERRY_ASSERT (entry_p != NULL);
        -:  874:
    #####:  875:  ecma_op_internal_buffer_delete (container_p, (ecma_container_pair_t *) entry_p, map_object_p->u.cls.u2.container_id);
    #####:  876:} /* ecma_op_container_remove_weak_entry */
        -:  877:
        -:  878:#if JERRY_ESNEXT
        -:  879:
        -:  880:/**
        -:  881: * The Create{Set, Map}Iterator Abstract operation
        -:  882: *
        -:  883: * See also:
        -:  884: *          ECMA-262 v6, 23.1.5.1
        -:  885: *          ECMA-262 v6, 23.2.5.1
        -:  886: *
        -:  887: * Note:
        -:  888: *     Returned value must be freed with ecma_free_value.
        -:  889: *
        -:  890: * @return Map/Set iterator object, if success
        -:  891: *         error - otherwise
        -:  892: */
        -:  893:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  894:ecma_op_container_create_iterator (ecma_value_t this_arg, /**< this argument */
        -:  895:                                   ecma_builtin_id_t proto_id, /**< prototype builtin id */
        -:  896:                                   ecma_object_class_type_t iterator_type, /**< iterator type */
        -:  897:                                   ecma_iterator_kind_t kind) /**< iterator kind */
        -:  898:{
    #####:  899:  return ecma_op_create_iterator_object (this_arg, ecma_builtin_get (proto_id), iterator_type, kind);
        -:  900:} /* ecma_op_container_create_iterator */
        -:  901:
        -:  902:/**
        -:  903: * Get the index of the iterator object.
        -:  904: *
        -:  905: * @return index of the iterator.
        -:  906: */
        -:  907:static uint32_t
    #####:  908:ecma_op_iterator_get_index (ecma_object_t *iter_obj_p) /**< iterator object pointer */
        -:  909:{
    #####:  910:  uint32_t index = ((ecma_extended_object_t *) iter_obj_p)->u.cls.u2.iterator_index;
        -:  911:
    #####:  912:  if (JERRY_UNLIKELY (index == ECMA_ITERATOR_INDEX_LIMIT))
        -:  913:  {
    #####:  914:    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);
    #####:  915:    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);
    #####:  916:    ecma_property_value_t *value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  917:
    #####:  918:    return (uint32_t) (ecma_get_number_from_value (value_p->value));
        -:  919:  }
        -:  920:
    #####:  921:  return index;
        -:  922:} /* ecma_op_iterator_get_index */
        -:  923:
        -:  924:/**
        -:  925: * Set the index of the iterator object.
        -:  926: */
        -:  927:static void
    #####:  928:ecma_op_iterator_set_index (ecma_object_t *iter_obj_p, /**< iterator object pointer */
        -:  929:                            uint32_t index) /* iterator index to set */
        -:  930:{
    #####:  931:  if (JERRY_UNLIKELY (index >= ECMA_ITERATOR_INDEX_LIMIT))
        -:  932:  {
        -:  933:    /* After the ECMA_ITERATOR_INDEX_LIMIT limit is reached the [[%Iterator%NextIndex]]
        -:  934:       property is stored as an internal property */
    #####:  935:    ecma_string_t *prop_name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_ITERATOR_NEXT_INDEX);
    #####:  936:    ecma_property_t *property_p = ecma_find_named_property (iter_obj_p, prop_name_p);
        -:  937:    ecma_property_value_t *value_p;
        -:  938:
    #####:  939:    if (property_p == NULL)
        -:  940:    {
    #####:  941:      value_p = ecma_create_named_data_property (iter_obj_p, prop_name_p, ECMA_PROPERTY_FLAG_WRITABLE, &property_p);
    #####:  942:      value_p->value = ecma_make_uint32_value (index);
        -:  943:    }
        -:  944:    else
        -:  945:    {
    #####:  946:      value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  947:      value_p->value = ecma_make_uint32_value (index);
        -:  948:    }
        -:  949:  }
        -:  950:  else
        -:  951:  {
    #####:  952:    ((ecma_extended_object_t *) iter_obj_p)->u.cls.u2.iterator_index = (uint16_t) index;
        -:  953:  }
    #####:  954:} /* ecma_op_iterator_set_index */
        -:  955:
        -:  956:/**
        -:  957: * The %{Set, Map}IteratorPrototype% object's 'next' routine
        -:  958: *
        -:  959: * See also:
        -:  960: *          ECMA-262 v6, 23.1.5.2.1
        -:  961: *          ECMA-262 v6, 23.2.5.2.1
        -:  962: *
        -:  963: * Note:
        -:  964: *     Returned value must be freed with ecma_free_value.
        -:  965: *
        -:  966: * @return iterator result object, if success
        -:  967: *         error - otherwise
        -:  968: */
        -:  969:ecma_value_t
    #####:  970:ecma_op_container_iterator_next (ecma_value_t this_val, /**< this argument */
        -:  971:                                 ecma_object_class_type_t iterator_type) /**< type of the iterator */
        -:  972:{
    #####:  973:  if (!ecma_is_value_object (this_val))
        -:  974:  {
    #####:  975:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);
        -:  976:  }
        -:  977:
    #####:  978:  ecma_object_t *obj_p = ecma_get_object_from_value (this_val);
    #####:  979:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -:  980:
    #####:  981:  if (!ecma_object_class_is (obj_p, iterator_type))
        -:  982:  {
    #####:  983:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_ITERATOR);
        -:  984:  }
        -:  985:
    #####:  986:  ecma_value_t iterated_value = ext_obj_p->u.cls.u3.iterated_value;
        -:  987:
    #####:  988:  if (ecma_is_value_empty (iterated_value))
        -:  989:  {
    #####:  990:    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
        -:  991:  }
        -:  992:
    #####:  993:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));
    #####:  994:  lit_magic_string_id_t lit_id = map_object_p->u.cls.u2.container_id;
        -:  995:
    #####:  996:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
    #####:  997:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####:  998:  uint32_t index = ecma_op_iterator_get_index (obj_p);
        -:  999:
    #####: 1000:  if (index == entry_count)
        -: 1001:  {
    #####: 1002:    ext_obj_p->u.cls.u3.iterated_value = ECMA_VALUE_EMPTY;
        -: 1003:
    #####: 1004:    return ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
        -: 1005:  }
        -: 1006:
    #####: 1007:  uint8_t entry_size = ecma_op_container_entry_size (lit_id);
    #####: 1008:  uint8_t iterator_kind = ext_obj_p->u.cls.u1.iterator_kind;
    #####: 1009:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
    #####: 1010:  ecma_value_t ret_value = ECMA_VALUE_UNDEFINED;
        -: 1011:
    #####: 1012:  for (uint32_t i = index; i < entry_count; i += entry_size)
        -: 1013:  {
    #####: 1014:    ecma_value_t *entry_p = start_p + i;
        -: 1015:
    #####: 1016:    if (ecma_is_value_empty (*entry_p))
        -: 1017:    {
    #####: 1018:      if (i == (entry_count - entry_size))
        -: 1019:      {
    #####: 1020:        ret_value = ecma_create_iter_result_object (ECMA_VALUE_UNDEFINED, ECMA_VALUE_TRUE);
    #####: 1021:        break;
        -: 1022:      }
        -: 1023:
    #####: 1024:      continue;
        -: 1025:    }
        -: 1026:
    #####: 1027:    ecma_op_iterator_set_index (obj_p, i + entry_size);
        -: 1028:
    #####: 1029:    ecma_value_t key_arg = *entry_p;
    #####: 1030:    ecma_value_t value_arg = ecma_op_container_get_value (entry_p, lit_id);
        -: 1031:
    #####: 1032:    if (iterator_kind == ECMA_ITERATOR_KEYS)
        -: 1033:    {
    #####: 1034:      ret_value = ecma_create_iter_result_object (key_arg, ECMA_VALUE_FALSE);
        -: 1035:    }
    #####: 1036:    else if (iterator_kind == ECMA_ITERATOR_VALUES)
        -: 1037:    {
    #####: 1038:      ret_value = ecma_create_iter_result_object (value_arg, ECMA_VALUE_FALSE);
        -: 1039:    }
        -: 1040:    else
        -: 1041:    {
    #####: 1042:      JERRY_ASSERT (iterator_kind == ECMA_ITERATOR_ENTRIES);
        -: 1043:
        -: 1044:      ecma_value_t entry_array_value;
    #####: 1045:      entry_array_value = ecma_create_array_from_iter_element (value_arg, key_arg);
        -: 1046:
    #####: 1047:      ret_value = ecma_create_iter_result_object (entry_array_value, ECMA_VALUE_FALSE);
    #####: 1048:      ecma_free_value (entry_array_value);
        -: 1049:    }
        -: 1050:
    #####: 1051:    break;
        -: 1052:  }
        -: 1053:
    #####: 1054:  return ret_value;
        -: 1055:} /* ecma_op_container_iterator_next */
        -: 1056:
        -: 1057:/**
        -: 1058: * Dispatcher of builtin container routines.
        -: 1059: *
        -: 1060: * @return ecma value
        -: 1061: *         Returned value must be freed with ecma_free_value.
        -: 1062: */
        -: 1063:ecma_value_t
    #####: 1064:ecma_builtin_container_dispatch_routine (uint16_t builtin_routine_id, /**< built-in wide routine
        -: 1065:                                                                       *   identifier */
        -: 1066:                                         ecma_value_t this_arg, /**< 'this' argument value */
        -: 1067:                                         const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1068:                                                                                 *   passed to routine */
        -: 1069:                                         lit_magic_string_id_t lit_id) /**< internal class id */
        -: 1070:{
    #####: 1071:  ecma_extended_object_t *map_object_p = ecma_op_container_get_object (this_arg, lit_id);
        -: 1072:
    #####: 1073:  if (map_object_p == NULL)
        -: 1074:  {
    #####: 1075:    return ECMA_VALUE_ERROR;
        -: 1076:  }
        -: 1077:
    #####: 1078:  switch (builtin_routine_id)
        -: 1079:  {
    #####: 1080:    case ECMA_CONTAINER_ROUTINE_DELETE:
        -: 1081:    {
    #####: 1082:      return ecma_op_container_delete (map_object_p, arguments_list_p[0], lit_id);
        -: 1083:    }
    #####: 1084:    case ECMA_CONTAINER_ROUTINE_DELETE_WEAK:
        -: 1085:    {
    #####: 1086:      return ecma_op_container_delete_weak (map_object_p, arguments_list_p[0], lit_id);
        -: 1087:    }
    #####: 1088:    case ECMA_CONTAINER_ROUTINE_GET:
        -: 1089:    {
    #####: 1090:      return ecma_op_container_get (map_object_p, arguments_list_p[0], lit_id);
        -: 1091:    }
    #####: 1092:    case ECMA_CONTAINER_ROUTINE_SET:
        -: 1093:    {
    #####: 1094:      return ecma_op_container_set (map_object_p, arguments_list_p[0], arguments_list_p[1], lit_id);
        -: 1095:    }
    #####: 1096:    case ECMA_CONTAINER_ROUTINE_HAS:
        -: 1097:    {
    #####: 1098:      return ecma_op_container_has (map_object_p, arguments_list_p[0], lit_id);
        -: 1099:    }
    #####: 1100:    case ECMA_CONTAINER_ROUTINE_FOREACH:
        -: 1101:    {
    #####: 1102:      return ecma_op_container_foreach (map_object_p, arguments_list_p[0], arguments_list_p[1], lit_id);
        -: 1103:    }
    #####: 1104:    case ECMA_CONTAINER_ROUTINE_SIZE_GETTER:
        -: 1105:    {
    #####: 1106:      return ecma_op_container_size (map_object_p);
        -: 1107:    }
    #####: 1108:    case ECMA_CONTAINER_ROUTINE_ADD:
        -: 1109:    {
    #####: 1110:      return ecma_op_container_set (map_object_p, arguments_list_p[0], arguments_list_p[0], lit_id);
        -: 1111:    }
    #####: 1112:    case ECMA_CONTAINER_ROUTINE_CLEAR:
        -: 1113:    {
    #####: 1114:      return ecma_op_container_clear (map_object_p);
        -: 1115:    }
    #####: 1116:    case ECMA_CONTAINER_ROUTINE_KEYS:
        -: 1117:    case ECMA_CONTAINER_ROUTINE_VALUES:
        -: 1118:    case ECMA_CONTAINER_ROUTINE_ENTRIES:
        -: 1119:    {
    #####: 1120:      ecma_builtin_id_t builtin_iterator_prototype = ECMA_BUILTIN_ID_MAP_ITERATOR_PROTOTYPE;
    #####: 1121:      ecma_object_class_type_t iterator_type = ECMA_OBJECT_CLASS_MAP_ITERATOR;
        -: 1122:
    #####: 1123:      if (lit_id != LIT_MAGIC_STRING_MAP_UL)
        -: 1124:      {
    #####: 1125:        builtin_iterator_prototype = ECMA_BUILTIN_ID_SET_ITERATOR_PROTOTYPE;
    #####: 1126:        iterator_type = ECMA_OBJECT_CLASS_SET_ITERATOR;
        -: 1127:      }
        -: 1128:
    #####: 1129:      ecma_iterator_kind_t kind = (ecma_iterator_kind_t) (builtin_routine_id - ECMA_CONTAINER_ROUTINE_KEYS);
        -: 1130:
    #####: 1131:      return ecma_op_container_create_iterator (this_arg, builtin_iterator_prototype, iterator_type, kind);
        -: 1132:    }
    #####: 1133:    default:
        -: 1134:    {
    #####: 1135:      JERRY_UNREACHABLE ();
        -: 1136:    }
        -: 1137:  }
        -: 1138:} /* ecma_builtin_container_dispatch_routine */
        -: 1139:
        -: 1140:#endif /* JERRY_ESNEXT */
        -: 1141:
        -: 1142:/**
        -: 1143: * @}
        -: 1144: * @}
        -: 1145: */
        -: 1146:
        -: 1147:#endif /* JERRY_BUILTIN_CONTAINER */
