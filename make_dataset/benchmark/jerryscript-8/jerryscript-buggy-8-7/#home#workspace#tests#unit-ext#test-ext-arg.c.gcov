        -:    0:Source:/home/workspace/tests/unit-ext/test-ext-arg.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:/**
        -:   17: * Unit test for jerry-ext/args.
        -:   18: */
        -:   19:
        -:   20:#include <string.h>
        -:   21:
        -:   22:#include "jerryscript.h"
        -:   23:
        -:   24:#include "jerryscript-ext/arg.h"
        -:   25:#include "test-common.h"
        -:   26:
        -:   27:static const jerry_char_t test_source[] =
        -:   28:  TEST_STRING_LITERAL ("var arg1 = true;"
        -:   29:                       "var arg2 = 10.5;"
        -:   30:                       "var arg3 = 'abc';"
        -:   31:                       "var arg4 = function foo() {};"
        -:   32:                       "test_validator1(arg1, arg2, arg3, arg4);"
        -:   33:                       "arg1 = new Boolean(true);"
        -:   34:                       "arg3 = new String('abc');"
        -:   35:                       "test_validator1(arg1, arg2, arg3);"
        -:   36:                       "test_validator1(arg1, arg2, '');"
        -:   37:                       "arg2 = new Number(10.5);"
        -:   38:                       "test_validator1(arg1, arg2, arg3);"
        -:   39:                       "test_validator1(arg1, 10.5, 'abcdef');"
        -:   40:                       "test_validator3(arg1, arg1);"
        -:   41:                       "test_validator3(arg1);"
        -:   42:                       "test_validator3();"
        -:   43:                       "test_validator3(undefined, undefined);"
        -:   44:                       "var obj_a = new MyObjectA();"
        -:   45:                       "var obj_b = new MyObjectB();"
        -:   46:                       "test_validator2.call(obj_a, 5);"
        -:   47:                       "test_validator2.call(obj_b, 5);"
        -:   48:                       "test_validator2.call(obj_a, 1);"
        -:   49:                       "var obj1 = {prop1:true, prop2:'1.5'};"
        -:   50:                       "test_validator_prop1(obj1);"
        -:   51:                       "test_validator_prop2(obj1);"
        -:   52:                       "test_validator_prop2();"
        -:   53:                       "var obj2 = {prop1:true};"
        -:   54:                       "Object.defineProperty(obj2, 'prop2', {"
        -:   55:                       "  get: function() { throw new TypeError('prop2 error') }"
        -:   56:                       "});"
        -:   57:                       "test_validator_prop3(obj2);"
        -:   58:                       "test_validator_int1(-1000, 1000, 128, -1000, 1000, -127,"
        -:   59:                       "                    -1000, 4294967297, 65536, -2200000000, 4294967297, -2147483647);"
        -:   60:                       "test_validator_int2(-1.5, -1.5, -1.5, 1.5, 1.5, 1.5, Infinity, -Infinity, 300.5, 300.5);"
        -:   61:                       "test_validator_int3(NaN);"
        -:   62:                       "var arr = [1, 2];"
        -:   63:                       "test_validator_array1(arr);"
        -:   64:                       "test_validator_array1();"
        -:   65:                       "test_validator_array2(arr);"
        -:   66:                       "test_validator_restore(false, 3.0);"
        -:   67:                       "test_validator_restore(3.0, false);");
        -:   68:
        -:   69:static const jerry_object_native_info_t thing_a_info = {
        -:   70:  .free_cb = NULL,
        -:   71:  .number_of_references = 0,
        -:   72:  .offset_of_references = 0,
        -:   73:};
        -:   74:
        -:   75:static const jerry_object_native_info_t thing_b_info = {
        -:   76:  .free_cb = NULL,
        -:   77:  .number_of_references = 0,
        -:   78:  .offset_of_references = 0,
        -:   79:};
        -:   80:
        -:   81:typedef struct
        -:   82:{
        -:   83:  int x;
        -:   84:} my_type_a_t;
        -:   85:
        -:   86:typedef struct
        -:   87:{
        -:   88:  bool x;
        -:   89:} my_type_b_t;
        -:   90:
        -:   91:static my_type_a_t my_thing_a;
        -:   92:static my_type_b_t my_thing_b;
        -:   93:
        -:   94:static int validator1_count = 0;
        -:   95:static int validator2_count = 0;
        -:   96:static int validator3_count = 0;
        -:   97:static int validator_int_count = 0;
        -:   98:static int validator_prop_count = 0;
        -:   99:static int validator_array_count = 0;
        -:  100:static int validator_restore_count = 0;
        -:  101:
        -:  102:/**
        -:  103: * The handler should have following arguments:
        -:  104: *   this: Ignore.
        -:  105: *   arg1: Bool.
        -:  106: *   arg2: Number. It must be strict primitive number.
        -:  107: *   arg3: String.
        -:  108: *   arg4: function. It is an optional argument.
        -:  109: *
        -:  110: */
        -:  111:static jerry_value_t
    #####:  112:test_validator1_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  113:                         const jerry_value_t args_p[], /**< arguments list */
        -:  114:                         const jerry_length_t args_cnt) /**< arguments length */
        -:  115:{
        -:  116:  bool arg1;
    #####:  117:  double arg2 = 0.0;
    #####:  118:  char arg3[5] = "1234";
    #####:  119:  jerry_value_t arg4 = jerry_undefined ();
        -:  120:
    #####:  121:  jerryx_arg_t mapping[] = { /* ignore this */
        -:  122:                             jerryx_arg_ignore (),
        -:  123:                             /* 1st argument should be boolean */
        -:  124:                             jerryx_arg_boolean (&arg1, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  125:                             /* 2nd argument should be strict number */
        -:  126:                             jerryx_arg_number (&arg2, JERRYX_ARG_NO_COERCE, JERRYX_ARG_REQUIRED),
        -:  127:                             /* 3th argument should be string */
        -:  128:                             jerryx_arg_string (arg3, 5, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  129:                             /* 4th argument should be function, and it is optional */
        -:  130:                             jerryx_arg_function (&arg4, JERRYX_ARG_OPTIONAL)
        -:  131:  };
        -:  132:
    #####:  133:  jerry_value_t is_ok =
    #####:  134:    jerryx_arg_transform_this_and_args (call_info_p->this_value, args_p, args_cnt, mapping, ARRAY_SIZE (mapping));
        -:  135:
    #####:  136:  if (validator1_count == 0)
        -:  137:  {
    #####:  138:    TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  139:    TEST_ASSERT (arg1);
    #####:  140:    TEST_ASSERT (arg2 == 10.5);
    #####:  141:    TEST_ASSERT (strcmp (arg3, "abc") == 0);
    #####:  142:    TEST_ASSERT (jerry_value_is_function (arg4));
        -:  143:  }
    #####:  144:  else if (validator1_count == 1)
        -:  145:  {
    #####:  146:    TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  147:    TEST_ASSERT (arg1);
    #####:  148:    TEST_ASSERT (arg2 == 10.5);
    #####:  149:    TEST_ASSERT (strcmp (arg3, "abc") == 0);
    #####:  150:    TEST_ASSERT (jerry_value_is_undefined (arg4));
        -:  151:  }
    #####:  152:  else if (validator1_count == 2)
        -:  153:  {
    #####:  154:    TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  155:    TEST_ASSERT (arg1);
    #####:  156:    TEST_ASSERT (arg2 == 10.5);
    #####:  157:    TEST_ASSERT (strcmp (arg3, "") == 0);
    #####:  158:    TEST_ASSERT (jerry_value_is_undefined (arg4));
        -:  159:  }
        -:  160:  else
        -:  161:  {
    #####:  162:    TEST_ASSERT (jerry_value_is_exception (is_ok));
        -:  163:  }
        -:  164:
    #####:  165:  jerry_value_free (is_ok);
    #####:  166:  jerry_value_free (arg4);
    #####:  167:  validator1_count++;
        -:  168:
    #####:  169:  return jerry_undefined ();
        -:  170:} /* test_validator1_handler */
        -:  171:
        -:  172:/**
        -:  173: * The JS argument should be number, whose value is equal with the extra_info .
        -:  174: */
        -:  175:static jerry_value_t
    #####:  176:my_custom_transform (jerryx_arg_js_iterator_t *js_arg_iter_p, /**< available JS args */
        -:  177:                     const jerryx_arg_t *c_arg_p) /**< the native arg */
        -:  178:{
    #####:  179:  jerry_value_t js_arg = jerryx_arg_js_iterator_pop (js_arg_iter_p);
    #####:  180:  jerry_value_t to_number = jerry_value_to_number (js_arg);
        -:  181:
    #####:  182:  if (jerry_value_is_exception (to_number))
        -:  183:  {
    #####:  184:    jerry_value_free (to_number);
        -:  185:
    #####:  186:    return jerry_throw_sz (JERRY_ERROR_TYPE, "It can not be converted to a number.");
        -:  187:  }
        -:  188:
    #####:  189:  int expected_num = (int) c_arg_p->extra_info;
    #####:  190:  int get_num = (int) jerry_value_as_number (to_number);
        -:  191:
    #####:  192:  if (get_num != expected_num)
        -:  193:  {
    #####:  194:    return jerry_throw_sz (JERRY_ERROR_TYPE, "Number value is not expected.");
        -:  195:  }
        -:  196:
    #####:  197:  return jerry_undefined ();
        -:  198:} /* my_custom_transform */
        -:  199:
        -:  200:/**
        -:  201: * The handler should have following arguments:
        -:  202: *   this: with native pointer whose type is bind_a_info.
        -:  203: *   arg1: should pass the custom tranform function.
        -:  204: */
        -:  205:static jerry_value_t
    #####:  206:test_validator2_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  207:                         const jerry_value_t args_p[], /**< arguments list */
        -:  208:                         const jerry_length_t args_cnt) /**< arguments length */
        -:  209:{
        -:  210:  my_type_a_t *thing_p;
        -:  211:
    #####:  212:  jerryx_arg_t mapping[] = { /* this should has native pointer, whose type is thing_a_info */
        -:  213:                             jerryx_arg_native_pointer ((void **) &thing_p, &thing_a_info, JERRYX_ARG_REQUIRED),
        -:  214:                             /* custom tranform function */
        -:  215:                             jerryx_arg_custom (NULL, 5, my_custom_transform)
        -:  216:  };
        -:  217:
    #####:  218:  jerry_value_t is_ok =
    #####:  219:    jerryx_arg_transform_this_and_args (call_info_p->this_value, args_p, args_cnt, mapping, ARRAY_SIZE (mapping));
        -:  220:
    #####:  221:  if (validator2_count == 0)
        -:  222:  {
    #####:  223:    TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  224:    TEST_ASSERT (thing_p == &my_thing_a);
    #####:  225:    TEST_ASSERT (thing_p->x == 1);
        -:  226:  }
        -:  227:  else
        -:  228:  {
    #####:  229:    TEST_ASSERT (jerry_value_is_exception (is_ok));
        -:  230:  }
        -:  231:
    #####:  232:  jerry_value_free (is_ok);
    #####:  233:  validator2_count++;
        -:  234:
    #####:  235:  return jerry_undefined ();
        -:  236:} /* test_validator2_handler */
        -:  237:
        -:  238:/**
        -:  239: * The handler should have following arguments:
        -:  240: *   arg1: Bool. It is an optional argument.
        -:  241: *
        -:  242: */
        -:  243:static jerry_value_t
    #####:  244:test_validator3_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  245:                         const jerry_value_t args_p[], /**< arguments list */
        -:  246:                         const jerry_length_t args_cnt) /**< arguments length */
        -:  247:{
    #####:  248:  bool arg1 = false;
    #####:  249:  bool arg2 = false;
        -:  250:
    #####:  251:  jerryx_arg_t mapping[] = {
        -:  252:    /* ignore this */
        -:  253:    jerryx_arg_ignore (),
        -:  254:    /* 1th argument should be boolean, and it is optional */
        -:  255:    jerryx_arg_boolean (&arg1, JERRYX_ARG_COERCE, JERRYX_ARG_OPTIONAL),
        -:  256:    /* 2nd argument should be boolean, and it is optional */
        -:  257:    jerryx_arg_boolean (&arg2, JERRYX_ARG_COERCE, JERRYX_ARG_OPTIONAL),
        -:  258:  };
        -:  259:
    #####:  260:  jerry_value_t is_ok =
    #####:  261:    jerryx_arg_transform_this_and_args (call_info_p->this_value, args_p, args_cnt, mapping, ARRAY_SIZE (mapping));
        -:  262:
    #####:  263:  if (validator3_count == 0)
        -:  264:  {
    #####:  265:    TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  266:    TEST_ASSERT (arg1);
    #####:  267:    TEST_ASSERT (arg2);
        -:  268:  }
    #####:  269:  else if (validator3_count == 1)
        -:  270:  {
    #####:  271:    TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  272:    TEST_ASSERT (arg1);
        -:  273:    /* arg2 must be unchanged */
    #####:  274:    TEST_ASSERT (!arg2);
        -:  275:  }
    #####:  276:  else if (validator3_count == 2)
        -:  277:  {
    #####:  278:    TEST_ASSERT (!jerry_value_is_exception (is_ok));
        -:  279:    /* arg1 must be unchanged */
    #####:  280:    TEST_ASSERT (!arg1);
        -:  281:    /* arg2 must be unchanged */
    #####:  282:    TEST_ASSERT (!arg2);
        -:  283:  }
    #####:  284:  else if (validator3_count == 3)
        -:  285:  {
    #####:  286:    TEST_ASSERT (!jerry_value_is_exception (is_ok));
        -:  287:    /* arg1 must be unchanged */
    #####:  288:    TEST_ASSERT (!arg1);
        -:  289:    /* arg2 must be unchanged */
    #####:  290:    TEST_ASSERT (!arg2);
        -:  291:  }
        -:  292:
    #####:  293:  jerry_value_free (is_ok);
    #####:  294:  validator3_count++;
        -:  295:
    #####:  296:  return jerry_undefined ();
        -:  297:} /* test_validator3_handler */
        -:  298:
        -:  299:/**
        -:  300: * Calling jerryx_arg_transform_object_properties directly.
        -:  301: */
        -:  302:static jerry_value_t
    #####:  303:test_validator_prop1_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  304:                              const jerry_value_t args_p[], /**< arguments list */
        -:  305:                              const jerry_length_t args_cnt) /**< arguments length */
        -:  306:{
        -:  307:  JERRY_UNUSED (call_info_p);
        -:  308:  JERRY_UNUSED (args_cnt);
        -:  309:
    #####:  310:  bool native1 = false;
    #####:  311:  double native2 = 0;
    #####:  312:  double native3 = 3;
        -:  313:
    #####:  314:  const char *name_p[] = { "prop1", "prop2", "prop3" };
        -:  315:
    #####:  316:  jerryx_arg_t mapping[] = { jerryx_arg_boolean (&native1, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  317:                             jerryx_arg_number (&native2, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  318:                             jerryx_arg_number (&native3, JERRYX_ARG_COERCE, JERRYX_ARG_OPTIONAL) };
        -:  319:
    #####:  320:  jerry_value_t is_ok = jerryx_arg_transform_object_properties (args_p[0],
        -:  321:                                                                (const jerry_char_t **) name_p,
        -:  322:                                                                ARRAY_SIZE (name_p),
        -:  323:                                                                mapping,
        -:  324:                                                                ARRAY_SIZE (mapping));
        -:  325:
    #####:  326:  TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  327:  TEST_ASSERT (native1);
    #####:  328:  TEST_ASSERT (native2 == 1.5);
    #####:  329:  TEST_ASSERT (native3 == 3);
        -:  330:
    #####:  331:  validator_prop_count++;
        -:  332:
    #####:  333:  return jerry_undefined ();
        -:  334:} /* test_validator_prop1_handler */
        -:  335:
        -:  336:/**
        -:  337: * Calling jerryx_arg_transform_object_properties indirectly by
        -:  338: * using jerryx_arg_object_properties.
        -:  339: */
        -:  340:static jerry_value_t
    #####:  341:test_validator_prop2_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  342:                              const jerry_value_t args_p[], /**< arguments list */
        -:  343:                              const jerry_length_t args_cnt) /**< arguments length */
        -:  344:{
        -:  345:  JERRY_UNUSED (call_info_p);
        -:  346:
    #####:  347:  bool native1 = false;
    #####:  348:  double native2 = 0;
    #####:  349:  double native3 = 3;
        -:  350:
        -:  351:  jerryx_arg_object_props_t prop_info;
        -:  352:
    #####:  353:  const char *name_p[] = { "prop1", "prop2", "prop3" };
        -:  354:
    #####:  355:  jerryx_arg_t prop_mapping[] = { jerryx_arg_boolean (&native1, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  356:                                  jerryx_arg_number (&native2, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  357:                                  jerryx_arg_number (&native3, JERRYX_ARG_COERCE, JERRYX_ARG_OPTIONAL) };
        -:  358:
    #####:  359:  prop_info.name_p = (const jerry_char_t **) name_p;
    #####:  360:  prop_info.name_cnt = 3;
    #####:  361:  prop_info.c_arg_p = prop_mapping;
    #####:  362:  prop_info.c_arg_cnt = 3;
        -:  363:
        -:  364:  jerryx_arg_t mapping[] = {
        -:  365:    jerryx_arg_object_properties (&prop_info, JERRYX_ARG_OPTIONAL),
        -:  366:  };
        -:  367:
    #####:  368:  jerry_value_t is_ok = jerryx_arg_transform_args (args_p, args_cnt, mapping, ARRAY_SIZE (mapping));
        -:  369:
    #####:  370:  TEST_ASSERT (!jerry_value_is_exception (is_ok));
        -:  371:
    #####:  372:  if (validator_prop_count == 1)
        -:  373:  {
    #####:  374:    TEST_ASSERT (native1);
    #####:  375:    TEST_ASSERT (native2 == 1.5);
    #####:  376:    TEST_ASSERT (native3 == 3);
        -:  377:  }
        -:  378:
    #####:  379:  validator_prop_count++;
        -:  380:
    #####:  381:  return jerry_undefined ();
        -:  382:} /* test_validator_prop2_handler */
        -:  383:
        -:  384:static jerry_value_t
    #####:  385:test_validator_prop3_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  386:                              const jerry_value_t args_p[], /**< arguments list */
        -:  387:                              const jerry_length_t args_cnt) /**< arguments length */
        -:  388:{
        -:  389:  JERRY_UNUSED (call_info_p);
        -:  390:  JERRY_UNUSED (args_cnt);
        -:  391:
    #####:  392:  bool native1 = false;
    #####:  393:  bool native2 = true;
        -:  394:
    #####:  395:  const char *name_p[] = { "prop1", "prop2" };
        -:  396:
    #####:  397:  jerryx_arg_t mapping[] = {
        -:  398:    jerryx_arg_boolean (&native1, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  399:    jerryx_arg_boolean (&native2, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  400:  };
        -:  401:
    #####:  402:  jerry_value_t is_ok = jerryx_arg_transform_object_properties (args_p[0],
        -:  403:                                                                (const jerry_char_t **) name_p,
        -:  404:                                                                ARRAY_SIZE (name_p),
        -:  405:                                                                mapping,
        -:  406:                                                                ARRAY_SIZE (mapping));
        -:  407:
    #####:  408:  TEST_ASSERT (jerry_value_is_exception (is_ok));
    #####:  409:  TEST_ASSERT (!native1);
    #####:  410:  TEST_ASSERT (native2);
        -:  411:
    #####:  412:  validator_prop_count++;
    #####:  413:  jerry_value_free (is_ok);
        -:  414:
    #####:  415:  return jerry_undefined ();
        -:  416:} /* test_validator_prop3_handler */
        -:  417:
        -:  418:/*
        -:  419: * args_p[0-2] are uint8, args_p[3-5] are int8, args_p[6-8] are uint32, args_p[9-11] are int32.
        -:  420: */
        -:  421:static jerry_value_t
    #####:  422:test_validator_int1_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  423:                             const jerry_value_t args_p[], /**< arguments list */
        -:  424:                             const jerry_length_t args_cnt) /**< arguments length */
        -:  425:{
        -:  426:  JERRY_UNUSED (call_info_p);
        -:  427:
        -:  428:  uint8_t num0, num1, num2;
        -:  429:  int8_t num3, num4, num5;
        -:  430:  uint32_t num6, num7, num8;
        -:  431:  int32_t num9, num10, num11;
        -:  432:
    #####:  433:  jerryx_arg_t mapping[] = {
        -:  434:    jerryx_arg_uint8 (&num0, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  435:    jerryx_arg_uint8 (&num1, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  436:    jerryx_arg_uint8 (&num2, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  437:    jerryx_arg_int8 (&num3, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  438:    jerryx_arg_int8 (&num4, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  439:    jerryx_arg_int8 (&num5, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  440:    jerryx_arg_uint32 (&num6, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  441:    jerryx_arg_uint32 (&num7, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  442:    jerryx_arg_uint32 (&num8, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  443:    jerryx_arg_int32 (&num9, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  444:    jerryx_arg_int32 (&num10, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  445:    jerryx_arg_int32 (&num11, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED)
        -:  446:  };
        -:  447:
    #####:  448:  jerry_value_t is_ok = jerryx_arg_transform_args (args_p, args_cnt, mapping, ARRAY_SIZE (mapping));
        -:  449:
    #####:  450:  TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  451:  TEST_ASSERT (num0 == 0);
    #####:  452:  TEST_ASSERT (num1 == 255);
    #####:  453:  TEST_ASSERT (num2 == 128);
    #####:  454:  TEST_ASSERT (num3 == -128);
    #####:  455:  TEST_ASSERT (num4 == 127);
    #####:  456:  TEST_ASSERT (num5 == -127);
    #####:  457:  TEST_ASSERT (num6 == 0);
    #####:  458:  TEST_ASSERT (num7 == 4294967295);
    #####:  459:  TEST_ASSERT (num8 == 65536);
    #####:  460:  TEST_ASSERT (num9 == -2147483648);
    #####:  461:  TEST_ASSERT (num10 == 2147483647);
    #####:  462:  TEST_ASSERT (num11 == -2147483647);
        -:  463:
    #####:  464:  jerry_value_free (is_ok);
    #####:  465:  validator_int_count++;
        -:  466:
    #####:  467:  return jerry_undefined ();
        -:  468:} /* test_validator_int1_handler */
        -:  469:
        -:  470:static jerry_value_t
    #####:  471:test_validator_int2_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  472:                             const jerry_value_t args_p[], /**< arguments list */
        -:  473:                             const jerry_length_t args_cnt) /**< arguments length */
        -:  474:{
        -:  475:  JERRY_UNUSED (call_info_p);
        -:  476:
        -:  477:  int8_t num0, num1, num2, num3, num4, num5, num6, num7, num8, num9;
    #####:  478:  num8 = 123;
    #####:  479:  num9 = 123;
        -:  480:
    #####:  481:  jerryx_arg_t mapping[] = {
        -:  482:    jerryx_arg_int8 (&num0, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  483:    jerryx_arg_int8 (&num1, JERRYX_ARG_FLOOR, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  484:    jerryx_arg_int8 (&num2, JERRYX_ARG_CEIL, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  485:    jerryx_arg_int8 (&num3, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  486:    jerryx_arg_int8 (&num4, JERRYX_ARG_FLOOR, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  487:    jerryx_arg_int8 (&num5, JERRYX_ARG_CEIL, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  488:    jerryx_arg_int8 (&num6, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  489:    jerryx_arg_int8 (&num7, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  490:    jerryx_arg_int8 (&num8, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  491:    jerryx_arg_int8 (&num9, JERRYX_ARG_ROUND, JERRYX_ARG_NO_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  492:  };
        -:  493:
    #####:  494:  jerry_value_t is_ok = jerryx_arg_transform_args (args_p, args_cnt, mapping, ARRAY_SIZE (mapping));
        -:  495:
    #####:  496:  TEST_ASSERT (jerry_value_is_exception (is_ok));
    #####:  497:  TEST_ASSERT (num0 == -2);
    #####:  498:  TEST_ASSERT (num1 == -2);
    #####:  499:  TEST_ASSERT (num2 == -1);
    #####:  500:  TEST_ASSERT (num3 == 2);
    #####:  501:  TEST_ASSERT (num4 == 1);
    #####:  502:  TEST_ASSERT (num5 == 2);
    #####:  503:  TEST_ASSERT (num6 == 127);
    #####:  504:  TEST_ASSERT (num7 == -128);
    #####:  505:  TEST_ASSERT (num8 == 127);
    #####:  506:  TEST_ASSERT (num9 == 123);
        -:  507:
    #####:  508:  jerry_value_free (is_ok);
    #####:  509:  validator_int_count++;
        -:  510:
    #####:  511:  return jerry_undefined ();
        -:  512:} /* test_validator_int2_handler */
        -:  513:
        -:  514:static jerry_value_t
    #####:  515:test_validator_int3_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  516:                             const jerry_value_t args_p[], /**< arguments list */
        -:  517:                             const jerry_length_t args_cnt) /**< arguments length */
        -:  518:{
        -:  519:  JERRY_UNUSED (call_info_p);
        -:  520:
        -:  521:  int8_t num0;
        -:  522:
    #####:  523:  jerryx_arg_t mapping[] = {
        -:  524:    jerryx_arg_int8 (&num0, JERRYX_ARG_ROUND, JERRYX_ARG_CLAMP, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  525:  };
        -:  526:
    #####:  527:  jerry_value_t is_ok = jerryx_arg_transform_args (args_p, args_cnt, mapping, ARRAY_SIZE (mapping));
        -:  528:
    #####:  529:  TEST_ASSERT (jerry_value_is_exception (is_ok));
        -:  530:
    #####:  531:  jerry_value_free (is_ok);
    #####:  532:  validator_int_count++;
        -:  533:
    #####:  534:  return jerry_undefined ();
        -:  535:} /* test_validator_int3_handler */
        -:  536:
        -:  537:static jerry_value_t
    #####:  538:test_validator_array1_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  539:                               const jerry_value_t args_p[], /**< arguments list */
        -:  540:                               const jerry_length_t args_cnt) /**< arguments length */
        -:  541:{
        -:  542:  JERRY_UNUSED (call_info_p);
        -:  543:
    #####:  544:  double native1 = 0;
    #####:  545:  double native2 = 0;
    #####:  546:  double native3 = 0;
        -:  547:
        -:  548:  jerryx_arg_array_items_t arr_info;
        -:  549:
    #####:  550:  jerryx_arg_t item_mapping[] = { jerryx_arg_number (&native1, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  551:                                  jerryx_arg_number (&native2, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  552:                                  jerryx_arg_number (&native3, JERRYX_ARG_COERCE, JERRYX_ARG_OPTIONAL) };
        -:  553:
    #####:  554:  arr_info.c_arg_p = item_mapping;
    #####:  555:  arr_info.c_arg_cnt = 3;
        -:  556:
    #####:  557:  jerryx_arg_t mapping[] = {
        -:  558:    jerryx_arg_array (&arr_info, JERRYX_ARG_OPTIONAL),
        -:  559:  };
        -:  560:
    #####:  561:  jerry_value_t is_ok = jerryx_arg_transform_args (args_p, args_cnt, mapping, ARRAY_SIZE (mapping));
        -:  562:
    #####:  563:  TEST_ASSERT (!jerry_value_is_exception (is_ok));
        -:  564:
    #####:  565:  if (validator_array_count == 0)
        -:  566:  {
    #####:  567:    TEST_ASSERT (native1 == 1);
    #####:  568:    TEST_ASSERT (native2 == 2);
    #####:  569:    TEST_ASSERT (native3 == 0);
        -:  570:  }
        -:  571:
    #####:  572:  validator_array_count++;
        -:  573:
    #####:  574:  return jerry_undefined ();
        -:  575:} /* test_validator_array1_handler */
        -:  576:
        -:  577:static jerry_value_t
    #####:  578:test_validator_array2_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  579:                               const jerry_value_t args_p[], /**< arguments list */
        -:  580:                               const jerry_length_t args_cnt) /**< arguments length */
        -:  581:{
        -:  582:  JERRY_UNUSED (call_info_p);
        -:  583:  JERRY_UNUSED (args_cnt);
        -:  584:
    #####:  585:  double native1 = 0;
    #####:  586:  bool native2 = false;
        -:  587:
    #####:  588:  jerryx_arg_t item_mapping[] = { jerryx_arg_number (&native1, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  589:                                  jerryx_arg_boolean (&native2, JERRYX_ARG_NO_COERCE, JERRYX_ARG_REQUIRED) };
        -:  590:
    #####:  591:  jerry_value_t is_ok = jerryx_arg_transform_array (args_p[0], item_mapping, ARRAY_SIZE (item_mapping));
        -:  592:
    #####:  593:  TEST_ASSERT (jerry_value_is_exception (is_ok));
    #####:  594:  TEST_ASSERT (native1 == 1);
    #####:  595:  TEST_ASSERT (!native2);
        -:  596:
    #####:  597:  validator_array_count++;
    #####:  598:  jerry_value_free (is_ok);
        -:  599:
    #####:  600:  return jerry_undefined ();
        -:  601:} /* test_validator_array2_handler */
        -:  602:
        -:  603:/**
        -:  604: * This validator is designed to test the
        -:  605: * jerryx_arg_js_iterator_restore function.  We'll introduce a union
        -:  606: * type to hold a bool or double and a transform function that will
        -:  607: * look for this type.  Then, we'll call the handler with two
        -:  608: * parameters, one bool and one double and see if we correctly build
        -:  609: * the union types for each parameter.  To check that the code protects
        -:  610: * against backing up too far, when the check for the double fails,
        -:  611: * we'll "restore" the stack three times; this shouldn't break
        -:  612: * anything.
        -:  613: */
        -:  614:/*
        -:  615: * This enumeration type specifies the kind of thing held in the union.
        -:  616: */
        -:  617:typedef enum
        -:  618:{
        -:  619:  DOUBLE_VALUE,
        -:  620:  BOOL_VALUE
        -:  621:} union_type_t;
        -:  622:
        -:  623:/*
        -:  624: * This struct holds either a boolean or double in a union and has a
        -:  625: * second field that describes the type held in the union.
        -:  626: */
        -:  627:typedef struct
        -:  628:{
        -:  629:  union_type_t type_of_value;
        -:  630:  union
        -:  631:  {
        -:  632:    double double_field;
        -:  633:    bool bool_field;
        -:  634:  } value;
        -:  635:} double_or_bool_t;
        -:  636:
        -:  637:/**
        -:  638: * This creates a jerryx_arg_t that can be used like any
        -:  639: * of the installed functions, like jerryx_arg_bool().
        -:  640: */
        -:  641:#define jerryx_arg_double_or_bool_t(value_ptr, coerce_or_not, optional_or_not, last_parameter)                 \
        -:  642:  jerryx_arg_custom (                                                                                          \
        -:  643:    value_ptr,                                                                                                 \
        -:  644:    (uintptr_t)                                                                                                \
        -:  645:      & ((uintptr_t[]){ (uintptr_t) coerce_or_not, (uintptr_t) optional_or_not, (uintptr_t) last_parameter }), \
        -:  646:    jerry_arg_to_double_or_bool_t)
        -:  647:/*
        -:  648: * This function is the argument validator used in the above macro called
        -:  649: * jerryx_arg_double_or_bool. It calls jerryx_arg_js_iterator_restore()
        -:  650: * more times than it should to ensure that calling that function too
        -:  651: * often doesn't cause an error.
        -:  652: */
        -:  653:static jerry_value_t
    #####:  654:jerry_arg_to_double_or_bool_t (jerryx_arg_js_iterator_t *js_arg_iter_p, const jerryx_arg_t *c_arg_p)
        -:  655:{
        -:  656:  /* c_arg_p has two fields: dest, which is a pointer to the data that
        -:  657:   * gets filled in, and extra_info, which contains the flags used to
        -:  658:   * control coercion and optional-ness, respectively. For this test,
        -:  659:   * we added an extra flag that tells us that we're working on the
        -:  660:   * last parameter; when we know it's the last parameter, we'll "restore"
        -:  661:   * the stack more times than there are actual stack values to ensure
        -:  662:   * that the restore function doesn't produce an error. */
    #####:  663:  double_or_bool_t *destination = c_arg_p->dest;
    #####:  664:  uintptr_t *extra_info = (uintptr_t *) (c_arg_p->extra_info);
        -:  665:  jerryx_arg_t conversion_function;
        -:  666:  jerry_value_t conversion_result;
        -:  667:  jerry_value_t restore_result;
    #####:  668:  bool last_parameter = (extra_info[2] == 1);
        -:  669:
    #####:  670:  validator_restore_count++;
        -:  671:
    #####:  672:  conversion_function = jerryx_arg_number ((double *) (&(destination->value.double_field)),
    #####:  673:                                           (jerryx_arg_coerce_t) extra_info[0],
        -:  674:                                           JERRYX_ARG_OPTIONAL);
    #####:  675:  conversion_result = conversion_function.func (js_arg_iter_p, &conversion_function);
    #####:  676:  if (!jerry_value_is_exception (conversion_result))
        -:  677:  {
    #####:  678:    if (last_parameter)
        -:  679:    {
        -:  680:      /* The stack is only two parameters high, but we want to ensure that
        -:  681:       * excessive calls will not result in aberrant behavior... */
    #####:  682:      jerryx_arg_js_iterator_restore (js_arg_iter_p);
    #####:  683:      jerryx_arg_js_iterator_restore (js_arg_iter_p);
    #####:  684:      jerryx_arg_js_iterator_restore (js_arg_iter_p);
    #####:  685:      restore_result = jerryx_arg_js_iterator_restore (js_arg_iter_p);
    #####:  686:      TEST_ASSERT (jerry_value_is_undefined (restore_result));
        -:  687:    }
        -:  688:
    #####:  689:    destination->type_of_value = DOUBLE_VALUE;
    #####:  690:    return conversion_result;
        -:  691:  }
        -:  692:
    #####:  693:  jerryx_arg_js_iterator_restore (js_arg_iter_p);
        -:  694:
    #####:  695:  conversion_function = jerryx_arg_boolean ((bool *) (&(destination->value.bool_field)),
    #####:  696:                                            (jerryx_arg_coerce_t) extra_info[0],
    #####:  697:                                            (jerryx_arg_optional_t) extra_info[1]);
        -:  698:
    #####:  699:  jerry_value_free (conversion_result);
    #####:  700:  conversion_result = conversion_function.func (js_arg_iter_p, &conversion_function);
    #####:  701:  if (!jerry_value_is_exception (conversion_result))
        -:  702:  {
    #####:  703:    if (last_parameter)
        -:  704:    {
        -:  705:      /* The stack is only two parameters high, but we want to ensure that
        -:  706:       * excessive calls will not result in aberrant behavior... */
    #####:  707:      jerryx_arg_js_iterator_restore (js_arg_iter_p);
    #####:  708:      jerryx_arg_js_iterator_restore (js_arg_iter_p);
    #####:  709:      jerryx_arg_js_iterator_restore (js_arg_iter_p);
    #####:  710:      restore_result = jerryx_arg_js_iterator_restore (js_arg_iter_p);
    #####:  711:      TEST_ASSERT (jerry_value_is_undefined (restore_result));
        -:  712:    }
        -:  713:
    #####:  714:    destination->type_of_value = BOOL_VALUE;
    #####:  715:    return conversion_result;
        -:  716:  }
        -:  717:
        -:  718:  /* Fall through indicates that whatever they gave us, it wasn't
        -:  719:   * one of the types we were expecting... */
    #####:  720:  jerry_value_free (conversion_result);
    #####:  721:  return jerry_throw_sz (JERRY_ERROR_TYPE, "double_or_bool-type error.");
        -:  722:} /* jerry_arg_to_double_or_bool_t */
        -:  723:
        -:  724:/**
        -:  725: * This validator expects two parameters, one a bool and one a double -- the
        -:  726: * order doesn't matter (so we'll call it twice with the orders reversed).
        -:  727: */
        -:  728:static jerry_value_t
    #####:  729:test_validator_restore_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  730:                                const jerry_value_t args_p[], /**< arguments list */
        -:  731:                                const jerry_length_t args_cnt) /**< arguments length */
        -:  732:{
        -:  733:  JERRY_UNUSED (call_info_p);
        -:  734:
        -:  735:  double_or_bool_t arg1;
        -:  736:  double_or_bool_t arg2;
        -:  737:
    #####:  738:  jerryx_arg_t item_mapping[] = { jerryx_arg_double_or_bool_t (&arg1, JERRYX_ARG_NO_COERCE, JERRYX_ARG_REQUIRED, 0),
    #####:  739:                                  jerryx_arg_double_or_bool_t (&arg2, JERRYX_ARG_NO_COERCE, JERRYX_ARG_REQUIRED, 1) };
        -:  740:
    #####:  741:  jerry_value_t is_ok = jerryx_arg_transform_args (args_p, args_cnt, item_mapping, ARRAY_SIZE (item_mapping));
        -:  742:
    #####:  743:  TEST_ASSERT (!jerry_value_is_exception (is_ok));
        -:  744:
        -:  745:  /* We are going to call this with [false, 3.0] and [3.0, false] parameters... */
    #####:  746:  bool arg1_is_false = (arg1.type_of_value == BOOL_VALUE && arg1.value.bool_field == false);
    #####:  747:  bool arg1_is_three = (arg1.type_of_value == DOUBLE_VALUE && arg1.value.double_field == 3.0);
    #####:  748:  bool arg2_is_false = (arg2.type_of_value == BOOL_VALUE && arg2.value.bool_field == false);
    #####:  749:  bool arg2_is_three = (arg2.type_of_value == DOUBLE_VALUE && arg2.value.double_field == 3.0);
    #####:  750:  TEST_ASSERT ((arg1_is_false && arg2_is_three) || (arg1_is_three && arg2_is_false));
        -:  751:
    #####:  752:  jerry_value_free (is_ok);
        -:  753:
    #####:  754:  return jerry_undefined ();
        -:  755:} /* test_validator_restore_handler */
        -:  756:
        -:  757:static void
    #####:  758:test_utf8_string (void)
    #####:  759:{
        -:  760:  /* test string: 'str: {DESERET CAPITAL LETTER LONG I}' */
    #####:  761:  jerry_value_t str = jerry_string_sz ("\x73\x74\x72\x3a \xed\xa0\x81\xed\xb0\x80");
    #####:  762:  char expect_utf8_buf[] = "\x73\x74\x72\x3a \xf0\x90\x90\x80";
    #####:  763:  size_t buf_len = sizeof (expect_utf8_buf) - 1;
    #####:  764:  JERRY_VLA (char, buf, buf_len + 1);
        -:  765:
    #####:  766:  jerryx_arg_t mapping[] = {
    #####:  767:    jerryx_arg_utf8_string (buf, (uint32_t) buf_len + 1, JERRYX_ARG_COERCE, JERRYX_ARG_REQUIRED),
        -:  768:  };
        -:  769:
    #####:  770:  jerry_value_t is_ok = jerryx_arg_transform_args (&str, 1, mapping, ARRAY_SIZE (mapping));
        -:  771:
    #####:  772:  TEST_ASSERT (!jerry_value_is_exception (is_ok));
    #####:  773:  TEST_ASSERT (!strcmp (buf, expect_utf8_buf));
        -:  774:
    #####:  775:  jerry_value_free (str);
    #####:  776:} /* test_utf8_string */
        -:  777:
        -:  778:static jerry_value_t
    #####:  779:create_object_a_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  780:                         const jerry_value_t args_p[], /**< arguments list */
        -:  781:                         const jerry_length_t args_cnt) /**< arguments length */
        -:  782:{
        -:  783:  JERRY_UNUSED (args_p);
        -:  784:  JERRY_UNUSED (args_cnt);
        -:  785:
    #####:  786:  TEST_ASSERT (jerry_value_is_object (call_info_p->this_value));
        -:  787:
    #####:  788:  my_thing_a.x = 1;
    #####:  789:  jerry_object_set_native_ptr (call_info_p->this_value, &thing_a_info, &my_thing_a);
        -:  790:
    #####:  791:  return jerry_boolean (true);
        -:  792:} /* create_object_a_handler */
        -:  793:
        -:  794:static jerry_value_t
    #####:  795:create_object_b_handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:  796:                         const jerry_value_t args_p[], /**< arguments list */
        -:  797:                         const jerry_length_t args_cnt) /**< arguments length */
        -:  798:{
        -:  799:  JERRY_UNUSED (args_p);
        -:  800:  JERRY_UNUSED (args_cnt);
        -:  801:
    #####:  802:  TEST_ASSERT (jerry_value_is_object (call_info_p->this_value));
        -:  803:
    #####:  804:  my_thing_b.x = false;
    #####:  805:  jerry_object_set_native_ptr (call_info_p->this_value, &thing_b_info, &my_thing_b);
        -:  806:
    #####:  807:  return jerry_boolean (true);
        -:  808:} /* create_object_b_handler */
        -:  809:
        -:  810:/**
        -:  811: * Register a JavaScript function in the global object.
        -:  812: */
        -:  813:static void
    #####:  814:register_js_function (const char *name_p, /**< name of the function */
        -:  815:                      jerry_external_handler_t handler_p) /**< function callback */
        -:  816:{
    #####:  817:  jerry_value_t global_obj_val = jerry_current_realm ();
        -:  818:
    #####:  819:  jerry_value_t function_val = jerry_function_external (handler_p);
    #####:  820:  jerry_value_t function_name_val = jerry_string_sz (name_p);
    #####:  821:  jerry_value_t result_val = jerry_object_set (global_obj_val, function_name_val, function_val);
        -:  822:
    #####:  823:  jerry_value_free (function_name_val);
    #####:  824:  jerry_value_free (function_val);
    #####:  825:  jerry_value_free (global_obj_val);
        -:  826:
    #####:  827:  jerry_value_free (result_val);
    #####:  828:} /* register_js_function */
        -:  829:
        -:  830:int
    #####:  831:main (void)
        -:  832:{
    #####:  833:  jerry_init (JERRY_INIT_EMPTY);
        -:  834:
    #####:  835:  test_utf8_string ();
        -:  836:
    #####:  837:  register_js_function ("test_validator1", test_validator1_handler);
    #####:  838:  register_js_function ("test_validator2", test_validator2_handler);
    #####:  839:  register_js_function ("test_validator3", test_validator3_handler);
    #####:  840:  register_js_function ("test_validator_int1", test_validator_int1_handler);
    #####:  841:  register_js_function ("test_validator_int2", test_validator_int2_handler);
    #####:  842:  register_js_function ("test_validator_int3", test_validator_int3_handler);
    #####:  843:  register_js_function ("MyObjectA", create_object_a_handler);
    #####:  844:  register_js_function ("MyObjectB", create_object_b_handler);
    #####:  845:  register_js_function ("test_validator_prop1", test_validator_prop1_handler);
    #####:  846:  register_js_function ("test_validator_prop2", test_validator_prop2_handler);
    #####:  847:  register_js_function ("test_validator_prop3", test_validator_prop3_handler);
    #####:  848:  register_js_function ("test_validator_array1", test_validator_array1_handler);
    #####:  849:  register_js_function ("test_validator_array2", test_validator_array2_handler);
    #####:  850:  register_js_function ("test_validator_restore", test_validator_restore_handler);
        -:  851:
    #####:  852:  jerry_value_t parsed_code_val = jerry_parse (test_source, sizeof (test_source) - 1, NULL);
    #####:  853:  TEST_ASSERT (!jerry_value_is_exception (parsed_code_val));
        -:  854:
    #####:  855:  jerry_value_t res = jerry_run (parsed_code_val);
    #####:  856:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  857:  TEST_ASSERT (validator1_count == 5);
    #####:  858:  TEST_ASSERT (validator2_count == 3);
    #####:  859:  TEST_ASSERT (validator_prop_count == 4);
    #####:  860:  TEST_ASSERT (validator_int_count == 3);
    #####:  861:  TEST_ASSERT (validator_array_count == 3);
    #####:  862:  TEST_ASSERT (validator_restore_count == 4);
        -:  863:
    #####:  864:  jerry_value_free (res);
    #####:  865:  jerry_value_free (parsed_code_val);
        -:  866:
    #####:  867:  jerry_cleanup ();
        -:  868:} /* main */
