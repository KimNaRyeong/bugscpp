        -:    0:Source:/home/workspace/jerry-core/api/jerryscript.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript.h"
        -:   17:
        -:   18:#include <math.h>
        -:   19:#include <stdio.h>
        -:   20:
        -:   21:#include "jerryscript-debugger-transport.h"
        -:   22:
        -:   23:#include "ecma-alloc.h"
        -:   24:#include "ecma-array-object.h"
        -:   25:#include "ecma-arraybuffer-object.h"
        -:   26:#include "ecma-bigint.h"
        -:   27:#include "ecma-builtin-helpers.h"
        -:   28:#include "ecma-builtins.h"
        -:   29:#include "ecma-comparison.h"
        -:   30:#include "ecma-container-object.h"
        -:   31:#include "ecma-dataview-object.h"
        -:   32:#include "ecma-errors.h"
        -:   33:#include "ecma-eval.h"
        -:   34:#include "ecma-exceptions.h"
        -:   35:#include "ecma-extended-info.h"
        -:   36:#include "ecma-function-object.h"
        -:   37:#include "ecma-gc.h"
        -:   38:#include "ecma-globals.h"
        -:   39:#include "ecma-helpers.h"
        -:   40:#include "ecma-init-finalize.h"
        -:   41:#include "ecma-iterator-object.h"
        -:   42:#include "ecma-lex-env.h"
        -:   43:#include "ecma-line-info.h"
        -:   44:#include "ecma-literal-storage.h"
        -:   45:#include "ecma-objects-general.h"
        -:   46:#include "ecma-objects.h"
        -:   47:#include "ecma-promise-object.h"
        -:   48:#include "ecma-proxy-object.h"
        -:   49:#include "ecma-regexp-object.h"
        -:   50:#include "ecma-shared-arraybuffer-object.h"
        -:   51:#include "ecma-symbol-object.h"
        -:   52:#include "ecma-typedarray-object.h"
        -:   53:
        -:   54:#include "debugger.h"
        -:   55:#include "jcontext.h"
        -:   56:#include "jmem.h"
        -:   57:#include "js-parser.h"
        -:   58:#include "lit-char-helpers.h"
        -:   59:#include "opcodes.h"
        -:   60:#include "re-compiler.h"
        -:   61:
        -:   62:JERRY_STATIC_ASSERT (sizeof (jerry_value_t) == sizeof (ecma_value_t),
        -:   63:                     size_of_jerry_value_t_must_be_equal_to_size_of_ecma_value_t);
        -:   64:
        -:   65:#if JERRY_BUILTIN_REGEXP
        -:   66:JERRY_STATIC_ASSERT ((int) RE_FLAG_GLOBAL == (int) JERRY_REGEXP_FLAG_GLOBAL
        -:   67:                       && (int) RE_FLAG_MULTILINE == (int) JERRY_REGEXP_FLAG_MULTILINE
        -:   68:                       && (int) RE_FLAG_IGNORE_CASE == (int) JERRY_REGEXP_FLAG_IGNORE_CASE
        -:   69:                       && (int) RE_FLAG_STICKY == (int) JERRY_REGEXP_FLAG_STICKY
        -:   70:                       && (int) RE_FLAG_UNICODE == (int) JERRY_REGEXP_FLAG_UNICODE
        -:   71:                       && (int) RE_FLAG_DOTALL == (int) JERRY_REGEXP_FLAG_DOTALL,
        -:   72:                     re_flags_t_must_be_equal_to_jerry_regexp_flags_t);
        -:   73:#endif /* JERRY_BUILTIN_REGEXP */
        -:   74:
        -:   75:#if JERRY_ESNEXT
        -:   76:/* The internal ECMA_PROMISE_STATE_* values are "one byte away" from the API values */
        -:   77:JERRY_STATIC_ASSERT ((int) ECMA_PROMISE_IS_PENDING == (int) JERRY_PROMISE_STATE_PENDING
        -:   78:                       && (int) ECMA_PROMISE_IS_FULFILLED == (int) JERRY_PROMISE_STATE_FULFILLED,
        -:   79:                     promise_internal_state_matches_external);
        -:   80:#endif /* JERRY_ESNEXT */
        -:   81:
        -:   82:/**
        -:   83: * Offset between internal and external arithmetic operator types
        -:   84: */
        -:   85:#define ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET (JERRY_BIN_OP_SUB - NUMBER_ARITHMETIC_SUBTRACTION)
        -:   86:
        -:   87:JERRY_STATIC_ASSERT (((NUMBER_ARITHMETIC_SUBTRACTION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_SUB)
        -:   88:                       && ((NUMBER_ARITHMETIC_MULTIPLICATION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET)
        -:   89:                           == JERRY_BIN_OP_MUL)
        -:   90:                       && ((NUMBER_ARITHMETIC_DIVISION + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_DIV)
        -:   91:                       && ((NUMBER_ARITHMETIC_REMAINDER + ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET) == JERRY_BIN_OP_REM),
        -:   92:                     number_arithmetics_operation_type_matches_external);
        -:   93:
        -:   94:#if !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC
        -:   95:#error "JERRY_SNAPSHOT_EXEC must be enabled if JERRY_PARSER is disabled!"
        -:   96:#endif /* !JERRY_PARSER && !JERRY_SNAPSHOT_EXEC */
        -:   97:
        -:   98:/** \addtogroup jerry Jerry engine interface
        -:   99: * @{
        -:  100: */
        -:  101:
        -:  102:/**
        -:  103: * Assert that it is correct to call API in current state.
        -:  104: *
        -:  105: * Note:
        -:  106: *         By convention, there are some states when API could not be invoked.
        -:  107: *
        -:  108: *         The API can be and only be invoked when the ECMA_STATUS_API_ENABLED
        -:  109: *         flag is set.
        -:  110: *
        -:  111: *         This procedure checks whether the API is available, and terminates
        -:  112: *         the engine if it is unavailable. Otherwise it is a no-op.
        -:  113: *
        -:  114: * Note:
        -:  115: *         The API could not be invoked in the following cases:
        -:  116: *           - before jerry_init and after jerry_cleanup
        -:  117: *           - between enter to and return from a native free callback
        -:  118: */
        -:  119:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  120:jerry_assert_api_enabled (void)
        -:  121:{
       51:  122:  JERRY_ASSERT (JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_ENABLED);
        -:  123:} /* jerry_assert_api_enabled */
        -:  124:
        -:  125:/**
        -:  126: * Turn on API availability
        -:  127: */
        -:  128:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  129:jerry_api_enable (void)
        -:  130:{
        -:  131:#ifndef JERRY_NDEBUG
        1:  132:  JERRY_CONTEXT (status_flags) |= ECMA_STATUS_API_ENABLED;
        -:  133:#endif /* JERRY_NDEBUG */
        -:  134:} /* jerry_make_api_available */
        -:  135:
        -:  136:/**
        -:  137: * Turn off API availability
        -:  138: */
        -:  139:static inline void JERRY_ATTR_ALWAYS_INLINE
        -:  140:jerry_api_disable (void)
        -:  141:{
        -:  142:#ifndef JERRY_NDEBUG
    #####:  143:  JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_API_ENABLED;
        -:  144:#endif /* JERRY_NDEBUG */
        -:  145:} /* jerry_make_api_unavailable */
        -:  146:
        -:  147:/**
        -:  148: * Create an API compatible return value.
        -:  149: *
        -:  150: * @return return value for Jerry API functions
        -:  151: */
        -:  152:static jerry_value_t
        5:  153:jerry_return (const jerry_value_t value) /**< return value */
        -:  154:{
        5:  155:  if (ECMA_IS_VALUE_ERROR (value))
        -:  156:  {
    #####:  157:    return ecma_create_exception_from_context ();
        -:  158:  }
        -:  159:
        5:  160:  return value;
        -:  161:} /* jerry_return */
        -:  162:
        -:  163:/**
        -:  164: * Jerry engine initialization
        -:  165: */
        -:  166:void
        1:  167:jerry_init (jerry_init_flag_t flags) /**< combination of Jerry flags */
        -:  168:{
        -:  169:  /* This function cannot be called twice unless jerry_cleanup is called. */
        1:  170:  JERRY_ASSERT (!(JERRY_CONTEXT (status_flags) & ECMA_STATUS_API_ENABLED));
        -:  171:
        -:  172:  /* Zero out all non-external members. */
        1:  173:  memset ((char *) &JERRY_CONTEXT_STRUCT + offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER),
        -:  174:          0,
        -:  175:          sizeof (jerry_context_t) - offsetof (jerry_context_t, JERRY_CONTEXT_FIRST_MEMBER));
        -:  176:
        1:  177:  JERRY_CONTEXT (jerry_init_flags) = flags;
        -:  178:
        -:  179:  jerry_api_enable ();
        -:  180:
        1:  181:  jmem_init ();
        1:  182:  ecma_init ();
        1:  183:} /* jerry_init */
        -:  184:
        -:  185:/**
        -:  186: * Terminate Jerry engine
        -:  187: */
        -:  188:void
    #####:  189:jerry_cleanup (void)
        -:  190:{
        -:  191:  jerry_assert_api_enabled ();
        -:  192:
        -:  193:#if JERRY_DEBUGGER
        -:  194:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  195:  {
        -:  196:    jerry_debugger_send_type (JERRY_DEBUGGER_CLOSE_CONNECTION);
        -:  197:
        -:  198:    jerry_debugger_transport_close ();
        -:  199:  }
        -:  200:#endif /* JERRY_DEBUGGER */
        -:  201:
    #####:  202:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p); this_p != NULL; this_p = this_p->next_p)
        -:  203:  {
    #####:  204:    if (this_p->manager_p->deinit_cb)
        -:  205:    {
    #####:  206:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  207:      this_p->manager_p->deinit_cb (data);
        -:  208:    }
        -:  209:  }
        -:  210:
        -:  211:#if JERRY_ESNEXT
    #####:  212:  ecma_free_all_enqueued_jobs ();
        -:  213:#endif /* JERRY_ESNEXT */
    #####:  214:  ecma_finalize ();
        -:  215:  jerry_api_disable ();
        -:  216:
    #####:  217:  for (jerry_context_data_header_t *this_p = JERRY_CONTEXT (context_data_p), *next_p = NULL; this_p != NULL;
    #####:  218:       this_p = next_p)
        -:  219:  {
    #####:  220:    next_p = this_p->next_p;
    #####:  221:    if (this_p->manager_p->finalize_cb)
        -:  222:    {
    #####:  223:      void *data = (this_p->manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (this_p) : NULL;
    #####:  224:      this_p->manager_p->finalize_cb (data);
        -:  225:    }
    #####:  226:    jmem_heap_free_block (this_p, sizeof (jerry_context_data_header_t) + this_p->manager_p->bytes_needed);
        -:  227:  }
        -:  228:
    #####:  229:  jmem_finalize ();
    #####:  230:} /* jerry_cleanup */
        -:  231:
        -:  232:/**
        -:  233: * Retrieve a context data item, or create a new one.
        -:  234: *
        -:  235: * @param manager_p pointer to the manager whose context data item should be returned.
        -:  236: *
        -:  237: * @return a pointer to the user-provided context-specific data item for the given manager, creating such a pointer if
        -:  238: * none was found.
        -:  239: */
        -:  240:void *
    #####:  241:jerry_context_data (const jerry_context_data_manager_t *manager_p)
        -:  242:{
    #####:  243:  void *ret = NULL;
        -:  244:  jerry_context_data_header_t *item_p;
        -:  245:
    #####:  246:  for (item_p = JERRY_CONTEXT (context_data_p); item_p != NULL; item_p = item_p->next_p)
        -:  247:  {
    #####:  248:    if (item_p->manager_p == manager_p)
        -:  249:    {
    #####:  250:      return (manager_p->bytes_needed > 0) ? JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p) : NULL;
        -:  251:    }
        -:  252:  }
        -:  253:
    #####:  254:  item_p = jmem_heap_alloc_block (sizeof (jerry_context_data_header_t) + manager_p->bytes_needed);
    #####:  255:  item_p->manager_p = manager_p;
    #####:  256:  item_p->next_p = JERRY_CONTEXT (context_data_p);
    #####:  257:  JERRY_CONTEXT (context_data_p) = item_p;
        -:  258:
    #####:  259:  if (manager_p->bytes_needed > 0)
        -:  260:  {
    #####:  261:    ret = JERRY_CONTEXT_DATA_HEADER_USER_DATA (item_p);
    #####:  262:    memset (ret, 0, manager_p->bytes_needed);
        -:  263:  }
        -:  264:
    #####:  265:  if (manager_p->init_cb)
        -:  266:  {
    #####:  267:    manager_p->init_cb (ret);
        -:  268:  }
        -:  269:
    #####:  270:  return ret;
        -:  271:} /* jerry_context_data */
        -:  272:
        -:  273:/**
        -:  274: * Register external magic string array
        -:  275: */
        -:  276:void
    #####:  277:jerry_register_magic_strings (const jerry_char_t *const *ext_strings_p, /**< character arrays, representing
        -:  278:                                                                         *   external magic strings' contents */
        -:  279:                              uint32_t count, /**< number of the strings */
        -:  280:                              const jerry_length_t *str_lengths_p) /**< lengths of all strings */
        -:  281:{
        -:  282:  jerry_assert_api_enabled ();
        -:  283:
    #####:  284:  lit_magic_strings_ex_set ((const lit_utf8_byte_t *const *) ext_strings_p,
        -:  285:                            count,
        -:  286:                            (const lit_utf8_size_t *) str_lengths_p);
    #####:  287:} /* jerry_register_magic_strings */
        -:  288:
        -:  289:/**
        -:  290: * Run garbage collection
        -:  291: */
        -:  292:void
    #####:  293:jerry_heap_gc (jerry_gc_mode_t mode) /**< operational mode */
        -:  294:{
        -:  295:  jerry_assert_api_enabled ();
        -:  296:
    #####:  297:  if (mode == JERRY_GC_PRESSURE_LOW)
        -:  298:  {
        -:  299:    /* Call GC directly, because 'ecma_free_unused_memory' might decide it's not yet worth it. */
    #####:  300:    ecma_gc_run ();
    #####:  301:    return;
        -:  302:  }
        -:  303:
    #####:  304:  ecma_free_unused_memory (JMEM_PRESSURE_HIGH);
        -:  305:} /* jerry_heap_gc */
        -:  306:
        -:  307:/**
        -:  308: * Get heap memory stats.
        -:  309: *
        -:  310: * @return true - get the heap stats successful
        -:  311: *         false - otherwise. Usually it is because the MEM_STATS feature is not enabled.
        -:  312: */
        -:  313:bool
    #####:  314:jerry_heap_stats (jerry_heap_stats_t *out_stats_p) /**< [out] heap memory stats */
        -:  315:{
        -:  316:#if JERRY_MEM_STATS
    #####:  317:  if (out_stats_p == NULL)
        -:  318:  {
        -:  319:    return false;
        -:  320:  }
        -:  321:
        -:  322:  jmem_heap_stats_t jmem_heap_stats;
    #####:  323:  memset (&jmem_heap_stats, 0, sizeof (jmem_heap_stats));
    #####:  324:  jmem_heap_get_stats (&jmem_heap_stats);
        -:  325:
    #####:  326:  *out_stats_p = (jerry_heap_stats_t){ .version = 1,
    #####:  327:                                       .size = jmem_heap_stats.size,
    #####:  328:                                       .allocated_bytes = jmem_heap_stats.allocated_bytes,
    #####:  329:                                       .peak_allocated_bytes = jmem_heap_stats.peak_allocated_bytes };
        -:  330:
    #####:  331:  return true;
        -:  332:#else /* !JERRY_MEM_STATS */
        -:  333:  JERRY_UNUSED (out_stats_p);
    #####:  334:  return false;
        -:  335:#endif /* JERRY_MEM_STATS */
        -:  336:} /* jerry_heap_stats */
        -:  337:
        -:  338:#if JERRY_PARSER
        -:  339:/**
        -:  340: * Common code for parsing a script, module, or function.
        -:  341: *
        -:  342: * @return function object value - if script was parsed successfully,
        -:  343: *         thrown error - otherwise
        -:  344: */
        -:  345:static jerry_value_t
        1:  346:jerry_parse_common (void *source_p, /**< script source */
        -:  347:                    const jerry_parse_options_t *options_p, /**< parsing options, can be NULL if not used */
        -:  348:                    uint32_t parse_opts) /**< internal parsing options */
        -:  349:{
        -:  350:  jerry_assert_api_enabled ();
        -:  351:
        1:  352:  if (options_p != NULL)
        -:  353:  {
        1:  354:    const uint32_t allowed_options =
        -:  355:      (JERRY_PARSE_STRICT_MODE | JERRY_PARSE_MODULE | JERRY_PARSE_HAS_ARGUMENT_LIST | JERRY_PARSE_HAS_SOURCE_NAME
        -:  356:       | JERRY_PARSE_HAS_START | JERRY_PARSE_HAS_USER_VALUE);
        1:  357:    uint32_t options = options_p->options;
        -:  358:
        1:  359:    if ((options & ~allowed_options) != 0
        1:  360:        || ((options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)
    #####:  361:            && ((options_p->options & JERRY_PARSE_MODULE) || !ecma_is_value_string (options_p->argument_list)))
        1:  362:        || ((options_p->options & JERRY_PARSE_HAS_SOURCE_NAME) && !ecma_is_value_string (options_p->source_name)))
        -:  363:    {
    #####:  364:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  365:    }
        -:  366:  }
        -:  367:
        -:  368:#if JERRY_DEBUGGER
        -:  369:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && options_p != NULL
        -:  370:      && (options_p->options & JERRY_PARSE_HAS_SOURCE_NAME) && ecma_is_value_string (options_p->source_name))
        -:  371:  {
        -:  372:    ECMA_STRING_TO_UTF8_STRING (ecma_get_string_from_value (options_p->source_name),
        -:  373:                                source_name_start_p,
        -:  374:                                source_name_size);
        -:  375:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE_NAME,
        -:  376:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -:  377:                                source_name_start_p,
        -:  378:                                source_name_size);
        -:  379:    ECMA_FINALIZE_UTF8_STRING (source_name_start_p, source_name_size);
        -:  380:  }
        -:  381:#endif /* JERRY_DEBUGGER */
        -:  382:
        1:  383:  if (options_p != NULL)
        -:  384:  {
        1:  385:    parse_opts |= options_p->options & (JERRY_PARSE_STRICT_MODE | JERRY_PARSE_MODULE);
        -:  386:  }
        -:  387:
        1:  388:  if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  389:  {
        -:  390:#if JERRY_MODULE_SYSTEM
    #####:  391:    JERRY_CONTEXT (module_current_p) = ecma_module_create ();
        -:  392:#else /* !JERRY_MODULE_SYSTEM */
    #####:  393:    return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  394:#endif /* JERRY_MODULE_SYSTEM */
        -:  395:  }
        -:  396:
        -:  397:  ecma_compiled_code_t *bytecode_data_p;
        1:  398:  bytecode_data_p = parser_parse_script (source_p, parse_opts, options_p);
        -:  399:
        1:  400:  if (JERRY_UNLIKELY (bytecode_data_p == NULL))
        -:  401:  {
        -:  402:#if JERRY_MODULE_SYSTEM
    #####:  403:    if ((parse_opts & JERRY_PARSE_MODULE) != 0)
        -:  404:    {
    #####:  405:      ecma_module_cleanup_context ();
        -:  406:    }
        -:  407:#endif /* JERRY_MODULE_SYSTEM */
        -:  408:
    #####:  409:    return ecma_create_exception_from_context ();
        -:  410:  }
        -:  411:
        -:  412:#if JERRY_MODULE_SYSTEM
        1:  413:  if (JERRY_UNLIKELY (parse_opts & JERRY_PARSE_MODULE))
        -:  414:  {
    #####:  415:    ecma_module_t *module_p = JERRY_CONTEXT (module_current_p);
    #####:  416:    module_p->u.compiled_code_p = bytecode_data_p;
        -:  417:
    #####:  418:    JERRY_CONTEXT (module_current_p) = NULL;
        -:  419:
    #####:  420:    return ecma_make_object_value ((ecma_object_t *) module_p);
        -:  421:  }
        -:  422:#endif /* JERRY_MODULE_SYSTEM */
        -:  423:
        1:  424:  if (JERRY_UNLIKELY (options_p != NULL && (options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST)))
        -:  425:  {
    #####:  426:    ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -:  427:
        -:  428:#if JERRY_BUILTIN_REALMS
    #####:  429:    JERRY_ASSERT (global_object_p == (ecma_object_t *) ecma_op_function_get_realm (bytecode_data_p));
        -:  430:#endif /* JERRY_BUILTIN_REALMS */
        -:  431:
    #####:  432:    ecma_object_t *lex_env_p = ecma_get_global_environment (global_object_p);
    #####:  433:    ecma_object_t *func_obj_p = ecma_op_create_simple_function_object (lex_env_p, bytecode_data_p);
    #####:  434:    ecma_bytecode_deref (bytecode_data_p);
        -:  435:
    #####:  436:    return ecma_make_object_value (func_obj_p);
        -:  437:  }
        -:  438:
        1:  439:  ecma_object_t *object_p = ecma_create_object (NULL, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  440:
        1:  441:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        1:  442:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_SCRIPT;
        1:  443:  ECMA_SET_INTERNAL_VALUE_POINTER (ext_object_p->u.cls.u3.value, bytecode_data_p);
        -:  444:
        1:  445:  return ecma_make_object_value (object_p);
        -:  446:} /* jerry_parse_common */
        -:  447:
        -:  448:#endif /* JERRY_PARSER */
        -:  449:
        -:  450:/**
        -:  451: * Parse a script, module, or function and create a compiled code using a character string
        -:  452: *
        -:  453: * @return function object value - if script was parsed successfully,
        -:  454: *         thrown error - otherwise
        -:  455: */
        -:  456:jerry_value_t
        1:  457:jerry_parse (const jerry_char_t *source_p, /**< script source */
        -:  458:             size_t source_size, /**< script source size */
        -:  459:             const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  460:{
        -:  461:#if JERRY_PARSER
        1:  462:  parser_source_char_t source_char;
        1:  463:  source_char.source_p = source_p;
        1:  464:  source_char.source_size = source_size;
        -:  465:
        1:  466:  return jerry_parse_common ((void *) &source_char, options_p, JERRY_PARSE_NO_OPTS);
        -:  467:#else /* !JERRY_PARSER */
        -:  468:  JERRY_UNUSED (source_p);
        -:  469:  JERRY_UNUSED (source_size);
        -:  470:  JERRY_UNUSED (options_p);
        -:  471:
        -:  472:  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_PARSER_NOT_SUPPORTED));
        -:  473:#endif /* JERRY_PARSER */
        -:  474:} /* jerry_parse */
        -:  475:
        -:  476:/**
        -:  477: * Parse a script, module, or function and create a compiled code using a string value
        -:  478: *
        -:  479: * @return function object value - if script was parsed successfully,
        -:  480: *         thrown error - otherwise
        -:  481: */
        -:  482:jerry_value_t
    #####:  483:jerry_parse_value (const jerry_value_t source, /**< script source */
        -:  484:                   const jerry_parse_options_t *options_p) /**< parsing options, can be NULL if not used */
        -:  485:{
        -:  486:#if JERRY_PARSER
    #####:  487:  if (!ecma_is_value_string (source))
        -:  488:  {
    #####:  489:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  490:  }
        -:  491:
    #####:  492:  return jerry_parse_common ((void *) &source, options_p, ECMA_PARSE_HAS_SOURCE_VALUE);
        -:  493:#else /* !JERRY_PARSER */
        -:  494:  JERRY_UNUSED (source);
        -:  495:  JERRY_UNUSED (options_p);
        -:  496:
        -:  497:  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_PARSER_NOT_SUPPORTED));
        -:  498:#endif /* JERRY_PARSER */
        -:  499:} /* jerry_parse_value */
        -:  500:
        -:  501:/**
        -:  502: * Run a Script or Module created by jerry_parse.
        -:  503: *
        -:  504: * Note:
        -:  505: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  506: *
        -:  507: * @return result of bytecode - if run was successful
        -:  508: *         thrown error - otherwise
        -:  509: */
        -:  510:jerry_value_t
        1:  511:jerry_run (const jerry_value_t script) /**< script or module to run */
        -:  512:{
        -:  513:  jerry_assert_api_enabled ();
        -:  514:
        1:  515:  if (!ecma_is_value_object (script))
        -:  516:  {
    #####:  517:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  518:  }
        -:  519:
        1:  520:  ecma_object_t *object_p = ecma_get_object_from_value (script);
        -:  521:
        1:  522:  if (!ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_SCRIPT))
        -:  523:  {
    #####:  524:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  525:  }
        -:  526:
        1:  527:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  528:
        -:  529:  const ecma_compiled_code_t *bytecode_data_p;
        1:  530:  bytecode_data_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
        -:  531:
        1:  532:  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags) == CBC_FUNCTION_SCRIPT);
        -:  533:
        1:  534:  return jerry_return (vm_run_global (bytecode_data_p, object_p));
        -:  535:} /* jerry_run */
        -:  536:
        -:  537:/**
        -:  538: * Perform eval
        -:  539: *
        -:  540: * Note:
        -:  541: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  542: *
        -:  543: * @return result of eval, may be error value.
        -:  544: */
        -:  545:jerry_value_t
    #####:  546:jerry_eval (const jerry_char_t *source_p, /**< source code */
        -:  547:            size_t source_size, /**< length of source code */
        -:  548:            uint32_t flags) /**< jerry_parse_opts_t flags */
        -:  549:{
        -:  550:  jerry_assert_api_enabled ();
        -:  551:
    #####:  552:  uint32_t allowed_parse_options = JERRY_PARSE_STRICT_MODE;
        -:  553:
    #####:  554:  if ((flags & ~allowed_parse_options) != 0)
        -:  555:  {
    #####:  556:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  557:  }
        -:  558:
    #####:  559:  parser_source_char_t source_char;
    #####:  560:  source_char.source_p = source_p;
    #####:  561:  source_char.source_size = source_size;
        -:  562:
    #####:  563:  return jerry_return (ecma_op_eval_chars_buffer ((void *) &source_char, flags));
        -:  564:} /* jerry_eval */
        -:  565:
        -:  566:/**
        -:  567: * Link modules to their dependencies. The dependencies are resolved by a user callback.
        -:  568: *
        -:  569: * Note:
        -:  570: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  571: *
        -:  572: * @return true - if linking is successful, error - otherwise
        -:  573: */
        -:  574:jerry_value_t
    #####:  575:jerry_module_link (const jerry_value_t module, /**< root module */
        -:  576:                   jerry_module_resolve_cb_t callback, /**< resolve module callback, uses
        -:  577:                                                        *   jerry_port_module_resolve when NULL is passed */
        -:  578:                   void *user_p) /**< pointer passed to the resolve callback */
        -:  579:{
        -:  580:  jerry_assert_api_enabled ();
        -:  581:
        -:  582:#if JERRY_MODULE_SYSTEM
    #####:  583:  if (callback == NULL)
        -:  584:  {
    #####:  585:    callback = jerry_port_module_resolve;
        -:  586:  }
        -:  587:
    #####:  588:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  589:
    #####:  590:  if (module_p == NULL)
        -:  591:  {
    #####:  592:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  593:  }
        -:  594:
    #####:  595:  return jerry_return (ecma_module_link (module_p, callback, user_p));
        -:  596:#else /* !JERRY_MODULE_SYSTEM */
        -:  597:  JERRY_UNUSED (module);
        -:  598:  JERRY_UNUSED (callback);
        -:  599:  JERRY_UNUSED (user_p);
        -:  600:
    #####:  601:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  602:#endif /* JERRY_MODULE_SYSTEM */
        -:  603:} /* jerry_module_link */
        -:  604:
        -:  605:/**
        -:  606: * Evaluate a module and its dependencies. The module must be in linked state.
        -:  607: *
        -:  608: * Note:
        -:  609: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  610: *
        -:  611: * @return result of module bytecode execution - if evaluation was successful
        -:  612: *         error - otherwise
        -:  613: */
        -:  614:jerry_value_t
    #####:  615:jerry_module_evaluate (const jerry_value_t module) /**< root module */
        -:  616:{
        -:  617:  jerry_assert_api_enabled ();
        -:  618:
        -:  619:#if JERRY_MODULE_SYSTEM
    #####:  620:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  621:
    #####:  622:  if (module_p == NULL)
        -:  623:  {
    #####:  624:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  625:  }
        -:  626:
    #####:  627:  if (module_p->header.u.cls.u1.module_state != JERRY_MODULE_STATE_LINKED)
        -:  628:  {
    #####:  629:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_MUST_BE_IN_LINKED_STATE));
        -:  630:  }
        -:  631:
    #####:  632:  return jerry_return (ecma_module_evaluate (module_p));
        -:  633:#else /* !JERRY_MODULE_SYSTEM */
        -:  634:  JERRY_UNUSED (module);
        -:  635:
    #####:  636:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  637:#endif /* JERRY_MODULE_SYSTEM */
        -:  638:} /* jerry_module_evaluate */
        -:  639:
        -:  640:/**
        -:  641: * Returns the current status of a module
        -:  642: *
        -:  643: * @return current status - if module is a module,
        -:  644: *         JERRY_MODULE_STATE_INVALID - otherwise
        -:  645: */
        -:  646:jerry_module_state_t
    #####:  647:jerry_module_state (const jerry_value_t module) /**< module object */
        -:  648:{
        -:  649:  jerry_assert_api_enabled ();
        -:  650:
        -:  651:#if JERRY_MODULE_SYSTEM
    #####:  652:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  653:
    #####:  654:  if (module_p == NULL)
        -:  655:  {
    #####:  656:    return JERRY_MODULE_STATE_INVALID;
        -:  657:  }
        -:  658:
    #####:  659:  return (jerry_module_state_t) module_p->header.u.cls.u1.module_state;
        -:  660:#else /* !JERRY_MODULE_SYSTEM */
        -:  661:  JERRY_UNUSED (module);
        -:  662:
    #####:  663:  return JERRY_MODULE_STATE_INVALID;
        -:  664:#endif /* JERRY_MODULE_SYSTEM */
        -:  665:} /* jerry_module_state */
        -:  666:
        -:  667:/**
        -:  668: * Sets a callback which is called after a module state is changed to linked, evaluated, or error.
        -:  669: */
        -:  670:void
    #####:  671:jerry_module_on_state_changed (jerry_module_state_changed_cb_t callback, /**< callback */
        -:  672:                               void *user_p) /**< pointer passed to the callback */
        -:  673:{
        -:  674:  jerry_assert_api_enabled ();
        -:  675:
        -:  676:#if JERRY_MODULE_SYSTEM
    #####:  677:  JERRY_CONTEXT (module_state_changed_callback_p) = callback;
    #####:  678:  JERRY_CONTEXT (module_state_changed_callback_user_p) = user_p;
        -:  679:#else /* !JERRY_MODULE_SYSTEM */
        -:  680:  JERRY_UNUSED (callback);
        -:  681:  JERRY_UNUSED (user_p);
        -:  682:#endif /* JERRY_MODULE_SYSTEM */
    #####:  683:} /* jerry_module_on_state_changed */
        -:  684:
        -:  685:/**
        -:  686: * Sets a callback which is called when an import.meta expression of a module is evaluated the first time.
        -:  687: */
        -:  688:void
    #####:  689:jerry_module_on_import_meta (jerry_module_import_meta_cb_t callback, /**< callback */
        -:  690:                             void *user_p) /**< pointer passed to the callback */
        -:  691:{
        -:  692:  jerry_assert_api_enabled ();
        -:  693:
        -:  694:#if JERRY_MODULE_SYSTEM
    #####:  695:  JERRY_CONTEXT (module_import_meta_callback_p) = callback;
    #####:  696:  JERRY_CONTEXT (module_import_meta_callback_user_p) = user_p;
        -:  697:#else /* !JERRY_MODULE_SYSTEM */
        -:  698:  JERRY_UNUSED (callback);
        -:  699:  JERRY_UNUSED (user_p);
        -:  700:#endif /* JERRY_MODULE_SYSTEM */
    #####:  701:} /* jerry_module_on_import_meta */
        -:  702:
        -:  703:/**
        -:  704: * Returns the number of import/export requests of a module
        -:  705: *
        -:  706: * @return number of import/export requests of a module
        -:  707: */
        -:  708:size_t
    #####:  709:jerry_module_request_count (const jerry_value_t module) /**< module */
        -:  710:{
        -:  711:  jerry_assert_api_enabled ();
        -:  712:
        -:  713:#if JERRY_MODULE_SYSTEM
    #####:  714:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  715:
    #####:  716:  if (module_p == NULL)
        -:  717:  {
    #####:  718:    return 0;
        -:  719:  }
        -:  720:
    #####:  721:  size_t number_of_requests = 0;
        -:  722:
    #####:  723:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  724:
    #####:  725:  while (node_p != NULL)
        -:  726:  {
    #####:  727:    number_of_requests++;
    #####:  728:    node_p = node_p->next_p;
        -:  729:  }
        -:  730:
    #####:  731:  return number_of_requests;
        -:  732:#else /* !JERRY_MODULE_SYSTEM */
        -:  733:  JERRY_UNUSED (module);
        -:  734:
    #####:  735:  return 0;
        -:  736:#endif /* JERRY_MODULE_SYSTEM */
        -:  737:} /* jerry_module_request_count */
        -:  738:
        -:  739:/**
        -:  740: * Returns the module request specified by the request_index argument
        -:  741: *
        -:  742: * Note:
        -:  743: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  744: *
        -:  745: * @return string - if the request has not been resolved yet,
        -:  746: *         module object - if the request has been resolved successfully,
        -:  747: *         error - otherwise
        -:  748: */
        -:  749:jerry_value_t
    #####:  750:jerry_module_request (const jerry_value_t module, /**< module */
        -:  751:                      size_t request_index) /**< request index */
        -:  752:{
        -:  753:  jerry_assert_api_enabled ();
        -:  754:
        -:  755:#if JERRY_MODULE_SYSTEM
    #####:  756:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  757:
    #####:  758:  if (module_p == NULL)
        -:  759:  {
    #####:  760:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  761:  }
        -:  762:
    #####:  763:  ecma_module_node_t *node_p = module_p->imports_p;
        -:  764:
    #####:  765:  while (node_p != NULL)
        -:  766:  {
    #####:  767:    if (request_index == 0)
        -:  768:    {
    #####:  769:      return ecma_copy_value (node_p->u.path_or_module);
        -:  770:    }
        -:  771:
    #####:  772:    --request_index;
    #####:  773:    node_p = node_p->next_p;
        -:  774:  }
        -:  775:
    #####:  776:  return jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_REQUEST_IS_NOT_AVAILABLE));
        -:  777:#else /* !JERRY_MODULE_SYSTEM */
        -:  778:  JERRY_UNUSED (module);
        -:  779:  JERRY_UNUSED (request_index);
        -:  780:
    #####:  781:  return jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  782:#endif /* JERRY_MODULE_SYSTEM */
        -:  783:} /* jerry_module_request */
        -:  784:
        -:  785:/**
        -:  786: * Returns the namespace object of a module
        -:  787: *
        -:  788: * Note:
        -:  789: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  790: *
        -:  791: * @return object - if namespace object is available,
        -:  792: *         error - otherwise
        -:  793: */
        -:  794:jerry_value_t
    #####:  795:jerry_module_namespace (const jerry_value_t module) /**< module */
        -:  796:{
        -:  797:  jerry_assert_api_enabled ();
        -:  798:
        -:  799:#if JERRY_MODULE_SYSTEM
    #####:  800:  ecma_module_t *module_p = ecma_module_get_resolved_module (module);
        -:  801:
    #####:  802:  if (module_p == NULL)
        -:  803:  {
    #####:  804:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  805:  }
        -:  806:
    #####:  807:  if (module_p->header.u.cls.u1.module_state < JERRY_MODULE_STATE_LINKED
    #####:  808:      || module_p->header.u.cls.u1.module_state > JERRY_MODULE_STATE_EVALUATED)
        -:  809:  {
    #####:  810:    return jerry_throw_sz (JERRY_ERROR_RANGE, ecma_get_error_msg (ECMA_ERR_NAMESPACE_OBJECT_IS_NOT_AVAILABLE));
        -:  811:  }
        -:  812:
    #####:  813:  JERRY_ASSERT (module_p->namespace_object_p != NULL);
        -:  814:
    #####:  815:  ecma_ref_object (module_p->namespace_object_p);
    #####:  816:  return ecma_make_object_value (module_p->namespace_object_p);
        -:  817:#else /* !JERRY_MODULE_SYSTEM */
        -:  818:  JERRY_UNUSED (module);
        -:  819:
    #####:  820:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  821:#endif /* JERRY_MODULE_SYSTEM */
        -:  822:} /* jerry_module_namespace */
        -:  823:
        -:  824:/**
        -:  825: * Sets the callback which is called when dynamic imports are resolved
        -:  826: */
        -:  827:void
    #####:  828:jerry_module_on_import (jerry_module_import_cb_t callback_p, /**< callback which handles
        -:  829:                                                              *   dynamic import calls */
        -:  830:                        void *user_p) /**< user pointer passed to the callback */
        -:  831:{
        -:  832:  jerry_assert_api_enabled ();
        -:  833:
        -:  834:#if JERRY_MODULE_SYSTEM
    #####:  835:  JERRY_CONTEXT (module_import_callback_p) = callback_p;
    #####:  836:  JERRY_CONTEXT (module_import_callback_user_p) = user_p;
        -:  837:#else /* !JERRY_MODULE_SYSTEM */
        -:  838:  JERRY_UNUSED (callback_p);
        -:  839:  JERRY_UNUSED (user_p);
        -:  840:#endif /* JERRY_MODULE_SYSTEM */
    #####:  841:} /* jerry_module_on_import */
        -:  842:
        -:  843:/**
        -:  844: * Creates a native module with a list of exports. The initial state of the module is linked.
        -:  845: *
        -:  846: * Note:
        -:  847: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  848: *
        -:  849: * @return native module - if the module is successfully created,
        -:  850: *         error - otherwise
        -:  851: */
        -:  852:jerry_value_t
    #####:  853:jerry_native_module (jerry_native_module_evaluate_cb_t callback, /**< evaluation callback for
        -:  854:                                                                  *   native modules */
        -:  855:                     const jerry_value_t *const exports_p, /**< list of the exported bindings of the module,
        -:  856:                                                            *   must be valid string identifiers */
        -:  857:                     size_t export_count) /**< number of exports in the exports_p list */
        -:  858:{
        -:  859:  jerry_assert_api_enabled ();
        -:  860:
        -:  861:#if JERRY_MODULE_SYSTEM
    #####:  862:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
    #####:  863:  ecma_object_t *scope_p = ecma_create_decl_lex_env (ecma_get_global_environment (global_object_p));
    #####:  864:  ecma_module_names_t *local_exports_p = NULL;
        -:  865:
    #####:  866:  for (size_t i = 0; i < export_count; i++)
        -:  867:  {
    #####:  868:    if (!ecma_is_value_string (exports_p[i]))
        -:  869:    {
    #####:  870:      ecma_deref_object (scope_p);
    #####:  871:      ecma_module_release_module_names (local_exports_p);
    #####:  872:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_EXPORTS_MUST_BE_STRING_VALUES));
        -:  873:    }
        -:  874:
    #####:  875:    ecma_string_t *name_str_p = ecma_get_string_from_value (exports_p[i]);
        -:  876:
    #####:  877:    bool valid_identifier = false;
        -:  878:
    #####:  879:    ECMA_STRING_TO_UTF8_STRING (name_str_p, name_start_p, name_size);
        -:  880:
    #####:  881:    if (name_size > 0)
        -:  882:    {
    #####:  883:      const lit_utf8_byte_t *name_p = name_start_p;
    #####:  884:      const lit_utf8_byte_t *name_end_p = name_start_p + name_size;
    #####:  885:      lit_code_point_t code_point;
        -:  886:
    #####:  887:      lit_utf8_size_t size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  888:
    #####:  889:      if (lit_code_point_is_identifier_start (code_point))
        -:  890:      {
    #####:  891:        name_p += size;
        -:  892:
    #####:  893:        valid_identifier = true;
        -:  894:
    #####:  895:        while (name_p < name_end_p)
        -:  896:        {
    #####:  897:          size = lit_read_code_point_from_cesu8 (name_p, name_end_p, &code_point);
        -:  898:
    #####:  899:          if (!lit_code_point_is_identifier_part (code_point))
        -:  900:          {
    #####:  901:            valid_identifier = false;
    #####:  902:            break;
        -:  903:          }
        -:  904:
    #####:  905:          name_p += size;
        -:  906:        }
        -:  907:      }
        -:  908:    }
        -:  909:
    #####:  910:    ECMA_FINALIZE_UTF8_STRING (name_start_p, name_size);
        -:  911:
    #####:  912:    if (!valid_identifier)
        -:  913:    {
    #####:  914:      ecma_deref_object (scope_p);
    #####:  915:      ecma_module_release_module_names (local_exports_p);
    #####:  916:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_EXPORTS_MUST_BE_VALID_IDENTIFIERS));
        -:  917:    }
        -:  918:
    #####:  919:    if (ecma_find_named_property (scope_p, name_str_p) != NULL)
        -:  920:    {
    #####:  921:      continue;
        -:  922:    }
        -:  923:
    #####:  924:    ecma_create_named_data_property (scope_p, name_str_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -:  925:
        -:  926:    ecma_module_names_t *new_export_p;
    #####:  927:    new_export_p = (ecma_module_names_t *) jmem_heap_alloc_block (sizeof (ecma_module_names_t));
        -:  928:
    #####:  929:    new_export_p->next_p = local_exports_p;
    #####:  930:    local_exports_p = new_export_p;
        -:  931:
    #####:  932:    ecma_ref_ecma_string (name_str_p);
    #####:  933:    new_export_p->imex_name_p = name_str_p;
        -:  934:
    #####:  935:    ecma_ref_ecma_string (name_str_p);
    #####:  936:    new_export_p->local_name_p = name_str_p;
        -:  937:  }
        -:  938:
    #####:  939:  ecma_module_t *module_p = ecma_module_create ();
        -:  940:
    #####:  941:  module_p->header.u.cls.u2.module_flags |= ECMA_MODULE_IS_NATIVE;
    #####:  942:  module_p->scope_p = scope_p;
    #####:  943:  module_p->local_exports_p = local_exports_p;
    #####:  944:  module_p->u.callback = callback;
        -:  945:
    #####:  946:  ecma_deref_object (scope_p);
        -:  947:
    #####:  948:  return ecma_make_object_value (&module_p->header.object);
        -:  949:
        -:  950:#else /* !JERRY_MODULE_SYSTEM */
        -:  951:  JERRY_UNUSED (callback);
        -:  952:  JERRY_UNUSED (exports_p);
        -:  953:  JERRY_UNUSED (export_count);
        -:  954:
    #####:  955:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -:  956:#endif /* JERRY_MODULE_SYSTEM */
        -:  957:} /* jerry_native_module */
        -:  958:
        -:  959:/**
        -:  960: * Gets the value of an export which belongs to a native module.
        -:  961: *
        -:  962: * Note:
        -:  963: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -:  964: *
        -:  965: * @return value of the export - if success
        -:  966: *         error - otherwise
        -:  967: */
        -:  968:jerry_value_t
    #####:  969:jerry_native_module_get (const jerry_value_t native_module, /**< a native module object */
        -:  970:                         const jerry_value_t export_name) /**< string identifier of the export */
        -:  971:{
        -:  972:  jerry_assert_api_enabled ();
        -:  973:
        -:  974:#if JERRY_MODULE_SYSTEM
    #####:  975:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module);
        -:  976:
    #####:  977:  if (module_p == NULL)
        -:  978:  {
    #####:  979:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -:  980:  }
        -:  981:
    #####:  982:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE) || !ecma_is_value_string (export_name))
        -:  983:  {
    #####:  984:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -:  985:  }
        -:  986:
    #####:  987:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p, ecma_get_string_from_value (export_name));
        -:  988:
    #####:  989:  if (property_p == NULL)
        -:  990:  {
    #####:  991:    return jerry_throw_sz (JERRY_ERROR_REFERENCE, ecma_get_error_msg (ECMA_ERR_UNKNOWN_EXPORT));
        -:  992:  }
        -:  993:
    #####:  994:  return ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -:  995:#else /* !JERRY_MODULE_SYSTEM */
        -:  996:  JERRY_UNUSED (native_module);
        -:  997:  JERRY_UNUSED (export_name);
        -:  998:
    #####:  999:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -: 1000:#endif /* JERRY_MODULE_SYSTEM */
        -: 1001:} /* jerry_native_module_get */
        -: 1002:
        -: 1003:/**
        -: 1004: * Sets the value of an export which belongs to a native module.
        -: 1005: *
        -: 1006: * Note:
        -: 1007: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 1008: *
        -: 1009: * @return true value - if the operation was successful
        -: 1010: *         error - otherwise
        -: 1011: */
        -: 1012:jerry_value_t
    #####: 1013:jerry_native_module_set (jerry_value_t native_module, /**< a native module object */
        -: 1014:                         const jerry_value_t export_name, /**< string identifier of the export */
        -: 1015:                         const jerry_value_t value) /**< new value of the export */
        -: 1016:{
        -: 1017:  jerry_assert_api_enabled ();
        -: 1018:
        -: 1019:#if JERRY_MODULE_SYSTEM
    #####: 1020:  ecma_module_t *module_p = ecma_module_get_resolved_module (native_module);
        -: 1021:
    #####: 1022:  if (module_p == NULL)
        -: 1023:  {
    #####: 1024:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_NOT_MODULE));
        -: 1025:  }
        -: 1026:
    #####: 1027:  if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE) || !ecma_is_value_string (export_name)
    #####: 1028:      || ecma_is_value_exception (value))
        -: 1029:  {
    #####: 1030:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 1031:  }
        -: 1032:
    #####: 1033:  ecma_property_t *property_p = ecma_find_named_property (module_p->scope_p, ecma_get_string_from_value (export_name));
        -: 1034:
    #####: 1035:  if (property_p == NULL)
        -: 1036:  {
    #####: 1037:    return jerry_throw_sz (JERRY_ERROR_REFERENCE, ecma_get_error_msg (ECMA_ERR_UNKNOWN_EXPORT));
        -: 1038:  }
        -: 1039:
    #####: 1040:  ecma_named_data_property_assign_value (module_p->scope_p, ECMA_PROPERTY_VALUE_PTR (property_p), value);
    #####: 1041:  return ECMA_VALUE_TRUE;
        -: 1042:#else /* !JERRY_MODULE_SYSTEM */
        -: 1043:  JERRY_UNUSED (native_module);
        -: 1044:  JERRY_UNUSED (export_name);
        -: 1045:  JERRY_UNUSED (value);
        -: 1046:
    #####: 1047:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_MODULE_NOT_SUPPORTED));
        -: 1048:#endif /* JERRY_MODULE_SYSTEM */
        -: 1049:} /* jerry_native_module_set */
        -: 1050:
        -: 1051:/**
        -: 1052: * Run enqueued microtasks created by Promise or AsyncFunction objects.
        -: 1053: * Tasks are executed until an exception is thrown or all tasks are executed.
        -: 1054: *
        -: 1055: * Note: returned value must be freed with jerry_value_free
        -: 1056: *
        -: 1057: * @return result of last executed job, possibly an exception.
        -: 1058: */
        -: 1059:jerry_value_t
    #####: 1060:jerry_run_jobs (void)
        -: 1061:{
        -: 1062:  jerry_assert_api_enabled ();
        -: 1063:
        -: 1064:#if JERRY_ESNEXT
    #####: 1065:  return jerry_return (ecma_process_all_enqueued_jobs ());
        -: 1066:#else /* !JERRY_ESNEXT */
    #####: 1067:  return ECMA_VALUE_UNDEFINED;
        -: 1068:#endif /* JERRY_ESNEXT */
        -: 1069:} /* jerry_run_jobs */
        -: 1070:
        -: 1071:/**
        -: 1072: * Get global object
        -: 1073: *
        -: 1074: * Note:
        -: 1075: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 1076: *
        -: 1077: * @return api value of global object
        -: 1078: */
        -: 1079:jerry_value_t
        5: 1080:jerry_current_realm (void)
        -: 1081:{
        -: 1082:  jerry_assert_api_enabled ();
        5: 1083:  ecma_object_t *global_obj_p = ecma_builtin_get_global ();
        5: 1084:  ecma_ref_object (global_obj_p);
        5: 1085:  return ecma_make_object_value (global_obj_p);
        -: 1086:} /* jerry_current_realm */
        -: 1087:
        -: 1088:/**
        -: 1089: * Check if the specified value is an abort value.
        -: 1090: *
        -: 1091: * @return true  - if both the error and abort values are set,
        -: 1092: *         false - otherwise
        -: 1093: */
        -: 1094:bool
    #####: 1095:jerry_value_is_abort (const jerry_value_t value) /**< api value */
        -: 1096:{
        -: 1097:  jerry_assert_api_enabled ();
        -: 1098:
    #####: 1099:  if (!ecma_is_value_exception (value))
        -: 1100:  {
    #####: 1101:    return false;
        -: 1102:  }
        -: 1103:
    #####: 1104:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 1105:
    #####: 1106:  return (error_ref_p->refs_and_type & ECMA_ERROR_API_FLAG_ABORT) != 0;
        -: 1107:} /* jerry_value_is_abort */
        -: 1108:
        -: 1109:/**
        -: 1110: * Check if the specified value is an array object value.
        -: 1111: *
        -: 1112: * @return true  - if the specified value is an array object,
        -: 1113: *         false - otherwise
        -: 1114: */
        -: 1115:bool
    #####: 1116:jerry_value_is_array (const jerry_value_t value) /**< jerry api value */
        -: 1117:{
        -: 1118:  jerry_assert_api_enabled ();
        -: 1119:
    #####: 1120:  return (ecma_is_value_object (value)
    #####: 1121:          && ecma_get_object_base_type (ecma_get_object_from_value (value)) == ECMA_OBJECT_BASE_TYPE_ARRAY);
        -: 1122:} /* jerry_value_is_array */
        -: 1123:
        -: 1124:/**
        -: 1125: * Check if the specified value is boolean.
        -: 1126: *
        -: 1127: * @return true  - if the specified value is boolean,
        -: 1128: *         false - otherwise
        -: 1129: */
        -: 1130:bool
    #####: 1131:jerry_value_is_boolean (const jerry_value_t value) /**< api value */
        -: 1132:{
        -: 1133:  jerry_assert_api_enabled ();
        -: 1134:
    #####: 1135:  return ecma_is_value_boolean (value);
        -: 1136:} /* jerry_value_is_boolean */
        -: 1137:
        -: 1138:/**
        -: 1139: * Check if the specified value is true.
        -: 1140: *
        -: 1141: * @return true  - if the specified value is true
        -: 1142: *         false - otherwise
        -: 1143: */
        -: 1144:bool
    #####: 1145:jerry_value_is_true (const jerry_value_t value) /**< api value */
        -: 1146:{
        -: 1147:  jerry_assert_api_enabled ();
        -: 1148:
    #####: 1149:  return ecma_is_value_true (value);
        -: 1150:} /* jerry_value_is_true */
        -: 1151:
        -: 1152:/**
        -: 1153: * Check if the specified value is false.
        -: 1154: *
        -: 1155: * @return true  - if the specified value is false
        -: 1156: *         false - otherwise
        -: 1157: */
        -: 1158:bool
    #####: 1159:jerry_value_is_false (const jerry_value_t value) /**< api value */
        -: 1160:{
        -: 1161:  jerry_assert_api_enabled ();
        -: 1162:
    #####: 1163:  return ecma_is_value_false (value);
        -: 1164:} /* jerry_value_is_false */
        -: 1165:
        -: 1166:/**
        -: 1167: * Check if the specified value is a constructor function object value.
        -: 1168: *
        -: 1169: * @return true - if the specified value is a function value that implements [[Construct]],
        -: 1170: *         false - otherwise
        -: 1171: */
        -: 1172:bool
    #####: 1173:jerry_value_is_constructor (const jerry_value_t value) /**< jerry api value */
        -: 1174:{
        -: 1175:  jerry_assert_api_enabled ();
        -: 1176:
    #####: 1177:  return ecma_is_constructor (value);
        -: 1178:} /* jerry_value_is_constructor */
        -: 1179:
        -: 1180:/**
        -: 1181: * Check if the specified value is an error or abort value.
        -: 1182: *
        -: 1183: * @return true  - if the specified value is an error value,
        -: 1184: *         false - otherwise
        -: 1185: */
        -: 1186:bool
        6: 1187:jerry_value_is_exception (const jerry_value_t value) /**< api value */
        -: 1188:{
        -: 1189:  jerry_assert_api_enabled ();
        -: 1190:
        6: 1191:  return ecma_is_value_exception (value);
        -: 1192:} /* jerry_value_is_exception */
        -: 1193:
        -: 1194:/**
        -: 1195: * Check if the specified value is a function object value.
        -: 1196: *
        -: 1197: * @return true - if the specified value is callable,
        -: 1198: *         false - otherwise
        -: 1199: */
        -: 1200:bool
    #####: 1201:jerry_value_is_function (const jerry_value_t value) /**< api value */
        -: 1202:{
        -: 1203:  jerry_assert_api_enabled ();
        -: 1204:
    #####: 1205:  return ecma_op_is_callable (value);
        -: 1206:} /* jerry_value_is_function */
        -: 1207:
        -: 1208:/**
        -: 1209: * Check if the specified value is an async function object value.
        -: 1210: *
        -: 1211: * @return true - if the specified value is an async function,
        -: 1212: *         false - otherwise
        -: 1213: */
        -: 1214:bool
    #####: 1215:jerry_value_is_async_function (const jerry_value_t value) /**< api value */
        -: 1216:{
        -: 1217:  jerry_assert_api_enabled ();
        -: 1218:
        -: 1219:#if JERRY_ESNEXT
    #####: 1220:  if (ecma_is_value_object (value))
        -: 1221:  {
    #####: 1222:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 1223:
    #####: 1224:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1225:    {
        -: 1226:      const ecma_compiled_code_t *bytecode_data_p;
    #####: 1227:      bytecode_data_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) obj_p);
    #####: 1228:      uint16_t type = CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags);
        -: 1229:
    #####: 1230:      return (type == CBC_FUNCTION_ASYNC || type == CBC_FUNCTION_ASYNC_ARROW || type == CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1231:    }
        -: 1232:  }
        -: 1233:#else /* !JERRY_ESNEXT */
        -: 1234:  JERRY_UNUSED (value);
        -: 1235:#endif /* JERRY_ESNEXT */
        -: 1236:
    #####: 1237:  return false;
        -: 1238:} /* jerry_value_is_async_function */
        -: 1239:
        -: 1240:/**
        -: 1241: * Check if the specified value is number.
        -: 1242: *
        -: 1243: * @return true  - if the specified value is number,
        -: 1244: *         false - otherwise
        -: 1245: */
        -: 1246:bool
    #####: 1247:jerry_value_is_number (const jerry_value_t value) /**< api value */
        -: 1248:{
        -: 1249:  jerry_assert_api_enabled ();
        -: 1250:
    #####: 1251:  return ecma_is_value_number (value);
        -: 1252:} /* jerry_value_is_number */
        -: 1253:
        -: 1254:/**
        -: 1255: * Check if the specified value is null.
        -: 1256: *
        -: 1257: * @return true  - if the specified value is null,
        -: 1258: *         false - otherwise
        -: 1259: */
        -: 1260:bool
    #####: 1261:jerry_value_is_null (const jerry_value_t value) /**< api value */
        -: 1262:{
        -: 1263:  jerry_assert_api_enabled ();
        -: 1264:
    #####: 1265:  return ecma_is_value_null (value);
        -: 1266:} /* jerry_value_is_null */
        -: 1267:
        -: 1268:/**
        -: 1269: * Check if the specified value is object.
        -: 1270: *
        -: 1271: * @return true  - if the specified value is object,
        -: 1272: *         false - otherwise
        -: 1273: */
        -: 1274:bool
    #####: 1275:jerry_value_is_object (const jerry_value_t value) /**< api value */
        -: 1276:{
        -: 1277:  jerry_assert_api_enabled ();
        -: 1278:
    #####: 1279:  return ecma_is_value_object (value);
        -: 1280:} /* jerry_value_is_object */
        -: 1281:
        -: 1282:/**
        -: 1283: * Check if the specified value is promise.
        -: 1284: *
        -: 1285: * @return true  - if the specified value is promise,
        -: 1286: *         false - otherwise
        -: 1287: */
        -: 1288:bool
    #####: 1289:jerry_value_is_promise (const jerry_value_t value) /**< api value */
        -: 1290:{
        -: 1291:  jerry_assert_api_enabled ();
        -: 1292:#if JERRY_ESNEXT
    #####: 1293:  return (ecma_is_value_object (value) && ecma_is_promise (ecma_get_object_from_value (value)));
        -: 1294:#else /* !JERRY_ESNEXT */
        -: 1295:  JERRY_UNUSED (value);
    #####: 1296:  return false;
        -: 1297:#endif /* JERRY_ESNEXT */
        -: 1298:} /* jerry_value_is_promise */
        -: 1299:
        -: 1300:/**
        -: 1301: * Check if the specified value is a proxy object.
        -: 1302: *
        -: 1303: * @return true  - if the specified value is a proxy object,
        -: 1304: *         false - otherwise
        -: 1305: */
        -: 1306:bool
    #####: 1307:jerry_value_is_proxy (const jerry_value_t value) /**< api value */
        -: 1308:{
        -: 1309:  jerry_assert_api_enabled ();
        -: 1310:#if JERRY_BUILTIN_PROXY
    #####: 1311:  return (ecma_is_value_object (value) && ECMA_OBJECT_IS_PROXY (ecma_get_object_from_value (value)));
        -: 1312:#else /* !JERRY_BUILTIN_PROXY */
        -: 1313:  JERRY_UNUSED (value);
    #####: 1314:  return false;
        -: 1315:#endif /* JERRY_BUILTIN_PROXY */
        -: 1316:} /* jerry_value_is_proxy */
        -: 1317:
        -: 1318:/**
        -: 1319: * Check if the specified value is string.
        -: 1320: *
        -: 1321: * @return true  - if the specified value is string,
        -: 1322: *         false - otherwise
        -: 1323: */
        -: 1324:bool
    #####: 1325:jerry_value_is_string (const jerry_value_t value) /**< api value */
        -: 1326:{
        -: 1327:  jerry_assert_api_enabled ();
        -: 1328:
    #####: 1329:  return ecma_is_value_string (value);
        -: 1330:} /* jerry_value_is_string */
        -: 1331:
        -: 1332:/**
        -: 1333: * Check if the specified value is symbol.
        -: 1334: *
        -: 1335: * @return true  - if the specified value is symbol,
        -: 1336: *         false - otherwise
        -: 1337: */
        -: 1338:bool
    #####: 1339:jerry_value_is_symbol (const jerry_value_t value) /**< api value */
        -: 1340:{
        -: 1341:  jerry_assert_api_enabled ();
        -: 1342:
        -: 1343:#if JERRY_ESNEXT
    #####: 1344:  return ecma_is_value_symbol (value);
        -: 1345:#else /* !JERRY_ESNEXT */
        -: 1346:  JERRY_UNUSED (value);
    #####: 1347:  return false;
        -: 1348:#endif /* JERRY_ESNEXT */
        -: 1349:} /* jerry_value_is_symbol */
        -: 1350:
        -: 1351:/**
        -: 1352: * Check if the specified value is BigInt.
        -: 1353: *
        -: 1354: * @return true  - if the specified value is BigInt,
        -: 1355: *         false - otherwise
        -: 1356: */
        -: 1357:bool
    #####: 1358:jerry_value_is_bigint (const jerry_value_t value) /**< api value */
        -: 1359:{
        -: 1360:  jerry_assert_api_enabled ();
        -: 1361:
        -: 1362:#if JERRY_BUILTIN_BIGINT
    #####: 1363:  return ecma_is_value_bigint (value);
        -: 1364:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1365:  JERRY_UNUSED (value);
    #####: 1366:  return false;
        -: 1367:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1368:} /* jerry_value_is_bigint */
        -: 1369:
        -: 1370:/**
        -: 1371: * Check if the specified value is undefined.
        -: 1372: *
        -: 1373: * @return true  - if the specified value is undefined,
        -: 1374: *         false - otherwise
        -: 1375: */
        -: 1376:bool
    #####: 1377:jerry_value_is_undefined (const jerry_value_t value) /**< api value */
        -: 1378:{
        -: 1379:  jerry_assert_api_enabled ();
        -: 1380:
    #####: 1381:  return ecma_is_value_undefined (value);
        -: 1382:} /* jerry_value_is_undefined */
        -: 1383:
        -: 1384:/**
        -: 1385: * Perform the base type of the JavaScript value.
        -: 1386: *
        -: 1387: * @return jerry_type_t value
        -: 1388: */
        -: 1389:jerry_type_t
    #####: 1390:jerry_value_type (const jerry_value_t value) /**< input value to check */
        -: 1391:{
        -: 1392:  jerry_assert_api_enabled ();
        -: 1393:
    #####: 1394:  if (ecma_is_value_exception (value))
        -: 1395:  {
    #####: 1396:    return JERRY_TYPE_EXCEPTION;
        -: 1397:  }
        -: 1398:
    #####: 1399:  lit_magic_string_id_t lit_id = ecma_get_typeof_lit_id (value);
        -: 1400:
    #####: 1401:  JERRY_ASSERT (lit_id != LIT_MAGIC_STRING__EMPTY);
        -: 1402:
    #####: 1403:  switch (lit_id)
        -: 1404:  {
    #####: 1405:    case LIT_MAGIC_STRING_UNDEFINED:
        -: 1406:    {
    #####: 1407:      return JERRY_TYPE_UNDEFINED;
        -: 1408:    }
    #####: 1409:    case LIT_MAGIC_STRING_BOOLEAN:
        -: 1410:    {
    #####: 1411:      return JERRY_TYPE_BOOLEAN;
        -: 1412:    }
    #####: 1413:    case LIT_MAGIC_STRING_NUMBER:
        -: 1414:    {
    #####: 1415:      return JERRY_TYPE_NUMBER;
        -: 1416:    }
    #####: 1417:    case LIT_MAGIC_STRING_STRING:
        -: 1418:    {
    #####: 1419:      return JERRY_TYPE_STRING;
        -: 1420:    }
        -: 1421:#if JERRY_ESNEXT
    #####: 1422:    case LIT_MAGIC_STRING_SYMBOL:
        -: 1423:    {
    #####: 1424:      return JERRY_TYPE_SYMBOL;
        -: 1425:    }
        -: 1426:#endif /* JERRY_ESNEXT */
    #####: 1427:    case LIT_MAGIC_STRING_FUNCTION:
        -: 1428:    {
    #####: 1429:      return JERRY_TYPE_FUNCTION;
        -: 1430:    }
        -: 1431:#if JERRY_BUILTIN_BIGINT
    #####: 1432:    case LIT_MAGIC_STRING_BIGINT:
        -: 1433:    {
    #####: 1434:      return JERRY_TYPE_BIGINT;
        -: 1435:    }
        -: 1436:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 1437:    default:
        -: 1438:    {
    #####: 1439:      JERRY_ASSERT (lit_id == LIT_MAGIC_STRING_OBJECT);
        -: 1440:
        -: 1441:      /* Based on the ECMA 262 5.1 standard the 'null' value is an object.
        -: 1442:       * Thus we'll do an extra check for 'null' here.
        -: 1443:       */
    #####: 1444:      return ecma_is_value_null (value) ? JERRY_TYPE_NULL : JERRY_TYPE_OBJECT;
        -: 1445:    }
        -: 1446:  }
        -: 1447:} /* jerry_value_type */
        -: 1448:
        -: 1449:/**
        -: 1450: * Used by jerry_object_type to get the type of class objects
        -: 1451: */
        -: 1452:static const uint8_t jerry_class_object_type[] = {
        -: 1453:  /* These objects require custom property resolving. */
        -: 1454:  JERRY_OBJECT_TYPE_STRING, /**< type of ECMA_OBJECT_CLASS_STRING */
        -: 1455:  JERRY_OBJECT_TYPE_ARGUMENTS, /**< type of ECMA_OBJECT_CLASS_ARGUMENTS */
        -: 1456:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1457:  JERRY_OBJECT_TYPE_TYPEDARRAY, /**< type of ECMA_OBJECT_CLASS_TYPEDARRAY */
        -: 1458:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1459:#if JERRY_MODULE_SYSTEM
        -: 1460:  JERRY_OBJECT_TYPE_MODULE_NAMESPACE, /**< type of ECMA_OBJECT_CLASS_MODULE_NAMESPACE */
        -: 1461:#endif /* JERRY_MODULE_SYSTEM */
        -: 1462:
        -: 1463:/* These objects are marked by Garbage Collector. */
        -: 1464:#if JERRY_ESNEXT
        -: 1465:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_GENERATOR */
        -: 1466:  JERRY_OBJECT_TYPE_GENERATOR, /**< type of ECMA_OBJECT_CLASS_ASYNC_GENERATOR */
        -: 1467:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_ARRAY_ITERATOR */
        -: 1468:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_SET_ITERATOR */
        -: 1469:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_MAP_ITERATOR */
        -: 1470:#if JERRY_BUILTIN_REGEXP
        -: 1471:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR */
        -: 1472:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1473:#endif /* JERRY_ESNEXT */
        -: 1474:#if JERRY_MODULE_SYSTEM
        -: 1475:  JERRY_OBJECT_TYPE_MODULE, /**< type of ECMA_OBJECT_CLASS_MODULE */
        -: 1476:#endif /* JERRY_MODULE_SYSTEM */
        -: 1477:#if JERRY_ESNEXT
        -: 1478:  JERRY_OBJECT_TYPE_PROMISE, /**< type of ECMA_OBJECT_CLASS_PROMISE */
        -: 1479:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_PROMISE_CAPABILITY */
        -: 1480:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_ASYNC_FROM_SYNC_ITERATOR */
        -: 1481:#endif /* JERRY_ESNEXT */
        -: 1482:#if JERRY_BUILTIN_DATAVIEW
        -: 1483:  JERRY_OBJECT_TYPE_DATAVIEW, /**< type of ECMA_OBJECT_CLASS_DATAVIEW */
        -: 1484:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1485:#if JERRY_BUILTIN_CONTAINER
        -: 1486:  JERRY_OBJECT_TYPE_CONTAINER, /**< type of ECMA_OBJECT_CLASS_CONTAINER */
        -: 1487:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1488:
        -: 1489:  /* Normal objects. */
        -: 1490:  JERRY_OBJECT_TYPE_BOOLEAN, /**< type of ECMA_OBJECT_CLASS_BOOLEAN */
        -: 1491:  JERRY_OBJECT_TYPE_NUMBER, /**< type of ECMA_OBJECT_CLASS_NUMBER */
        -: 1492:  JERRY_OBJECT_TYPE_ERROR, /**< type of ECMA_OBJECT_CLASS_ERROR */
        -: 1493:  JERRY_OBJECT_TYPE_GENERIC, /**< type of ECMA_OBJECT_CLASS_INTERNAL_OBJECT */
        -: 1494:#if JERRY_PARSER
        -: 1495:  JERRY_OBJECT_TYPE_SCRIPT, /**< type of ECMA_OBJECT_CLASS_SCRIPT */
        -: 1496:#endif /* JERRY_PARSER */
        -: 1497:#if JERRY_BUILTIN_DATE
        -: 1498:  JERRY_OBJECT_TYPE_DATE, /**< type of ECMA_OBJECT_CLASS_DATE */
        -: 1499:#endif /* JERRY_BUILTIN_DATE */
        -: 1500:#if JERRY_BUILTIN_REGEXP
        -: 1501:  JERRY_OBJECT_TYPE_REGEXP, /**< type of ECMA_OBJECT_CLASS_REGEXP */
        -: 1502:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1503:#if JERRY_ESNEXT
        -: 1504:  JERRY_OBJECT_TYPE_SYMBOL, /**< type of ECMA_OBJECT_CLASS_SYMBOL */
        -: 1505:  JERRY_OBJECT_TYPE_ITERATOR, /**< type of ECMA_OBJECT_CLASS_STRING_ITERATOR */
        -: 1506:#endif /* JERRY_ESNEXT */
        -: 1507:#if JERRY_BUILTIN_TYPEDARRAY
        -: 1508:  JERRY_OBJECT_TYPE_ARRAYBUFFER, /**< type of ECMA_OBJECT_CLASS_ARRAY_BUFFER */
        -: 1509:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 1510:  JERRY_OBJECT_TYPE_SHARED_ARRAY_BUFFER, /**< type of ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER */
        -: 1511:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 1512:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1513:#if JERRY_BUILTIN_BIGINT
        -: 1514:  JERRY_OBJECT_TYPE_BIGINT, /**< type of ECMA_OBJECT_CLASS_BIGINT */
        -: 1515:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1516:#if JERRY_BUILTIN_WEAKREF
        -: 1517:  JERRY_OBJECT_TYPE_WEAKREF, /**< type of ECMA_OBJECT_CLASS_WEAKREF */
        -: 1518:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1519:};
        -: 1520:
        -: 1521:JERRY_STATIC_ASSERT (sizeof (jerry_class_object_type) == ECMA_OBJECT_CLASS__MAX,
        -: 1522:                     jerry_class_object_type_must_have_object_class_max_elements);
        -: 1523:
        -: 1524:/**
        -: 1525: * Get the object type of the given value
        -: 1526: *
        -: 1527: * @return JERRY_OBJECT_TYPE_NONE - if the given value is not an object
        -: 1528: *         jerry_object_type_t value - otherwise
        -: 1529: */
        -: 1530:jerry_object_type_t
    #####: 1531:jerry_object_type (const jerry_value_t value) /**< input value to check */
        -: 1532:{
        -: 1533:  jerry_assert_api_enabled ();
        -: 1534:
    #####: 1535:  if (!ecma_is_value_object (value))
        -: 1536:  {
    #####: 1537:    return JERRY_OBJECT_TYPE_NONE;
        -: 1538:  }
        -: 1539:
    #####: 1540:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1541:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1542:
    #####: 1543:  switch (ecma_get_object_type (obj_p))
        -: 1544:  {
    #####: 1545:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1546:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 1547:    {
    #####: 1548:      JERRY_ASSERT (ext_obj_p->u.cls.type < ECMA_OBJECT_CLASS__MAX);
    #####: 1549:      return jerry_class_object_type[ext_obj_p->u.cls.type];
        -: 1550:    }
    #####: 1551:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1552:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1553:    {
    #####: 1554:      return JERRY_OBJECT_TYPE_ARRAY;
        -: 1555:    }
        -: 1556:#if JERRY_ESNEXT
    #####: 1557:    case ECMA_OBJECT_TYPE_PROXY:
        -: 1558:    {
    #####: 1559:      return JERRY_OBJECT_TYPE_PROXY;
        -: 1560:    }
        -: 1561:#endif /* JERRY_ESNEXT */
    #####: 1562:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1563:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1564:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1565:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1566:    {
    #####: 1567:      return JERRY_OBJECT_TYPE_FUNCTION;
        -: 1568:    }
    #####: 1569:    default:
        -: 1570:    {
    #####: 1571:      break;
        -: 1572:    }
        -: 1573:  }
        -: 1574:
    #####: 1575:  return JERRY_OBJECT_TYPE_GENERIC;
        -: 1576:} /* jerry_object_type */
        -: 1577:
        -: 1578:/**
        -: 1579: * Get the function type of the given value
        -: 1580: *
        -: 1581: * @return JERRY_FUNCTION_TYPE_NONE - if the given value is not a function object
        -: 1582: *         jerry_function_type_t value - otherwise
        -: 1583: */
        -: 1584:jerry_function_type_t
    #####: 1585:jerry_function_type (const jerry_value_t value) /**< input value to check */
        -: 1586:{
        -: 1587:  jerry_assert_api_enabled ();
        -: 1588:
    #####: 1589:  if (ecma_is_value_object (value))
        -: 1590:  {
    #####: 1591:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1592:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1593:
    #####: 1594:    switch (ecma_get_object_type (obj_p))
        -: 1595:    {
    #####: 1596:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1597:      {
    #####: 1598:        return JERRY_FUNCTION_TYPE_BOUND;
        -: 1599:      }
    #####: 1600:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1601:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1602:      {
    #####: 1603:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1604:      }
    #####: 1605:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1606:      {
    #####: 1607:        const ecma_compiled_code_t *bytecode_data_p = ecma_op_function_get_compiled_code (ext_obj_p);
        -: 1608:
    #####: 1609:        switch (CBC_FUNCTION_GET_TYPE (bytecode_data_p->status_flags))
        -: 1610:        {
        -: 1611:#if JERRY_ESNEXT
    #####: 1612:          case CBC_FUNCTION_ARROW:
        -: 1613:          case CBC_FUNCTION_ASYNC_ARROW:
        -: 1614:          {
    #####: 1615:            return JERRY_FUNCTION_TYPE_ARROW;
        -: 1616:          }
    #####: 1617:          case CBC_FUNCTION_GENERATOR:
        -: 1618:          case CBC_FUNCTION_ASYNC_GENERATOR:
        -: 1619:          {
    #####: 1620:            return JERRY_FUNCTION_TYPE_GENERATOR;
        -: 1621:          }
        -: 1622:#endif /* JERRY_ESNEXT */
    #####: 1623:          case CBC_FUNCTION_ACCESSOR:
        -: 1624:          {
    #####: 1625:            return JERRY_FUNCTION_TYPE_ACCESSOR;
        -: 1626:          }
    #####: 1627:          default:
        -: 1628:          {
    #####: 1629:            break;
        -: 1630:          }
        -: 1631:        }
    #####: 1632:        return JERRY_FUNCTION_TYPE_GENERIC;
        -: 1633:      }
    #####: 1634:      default:
        -: 1635:      {
    #####: 1636:        break;
        -: 1637:      }
        -: 1638:    }
    #####: 1639:  }
        -: 1640:
    #####: 1641:  return JERRY_FUNCTION_TYPE_NONE;
        -: 1642:} /* jerry_function_type */
        -: 1643:
        -: 1644:/**
        -: 1645: * Get the itearator type of the given value
        -: 1646: *
        -: 1647: * @return JERRY_ITERATOR_TYPE_NONE - if the given value is not an iterator object
        -: 1648: *         jerry_iterator_type_t value - otherwise
        -: 1649: */
        -: 1650:jerry_iterator_type_t
    #####: 1651:jerry_iterator_type (const jerry_value_t value) /**< input value to check */
        -: 1652:{
        -: 1653:  jerry_assert_api_enabled ();
        -: 1654:
        -: 1655:#if JERRY_ESNEXT
    #####: 1656:  if (ecma_is_value_object (value))
        -: 1657:  {
    #####: 1658:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
    #####: 1659:    ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 1660:
    #####: 1661:    if (ecma_get_object_type (obj_p) == ECMA_OBJECT_TYPE_CLASS)
        -: 1662:    {
    #####: 1663:      switch (ext_obj_p->u.cls.type)
        -: 1664:      {
    #####: 1665:        case ECMA_OBJECT_CLASS_ARRAY_ITERATOR:
        -: 1666:        {
    #####: 1667:          return JERRY_ITERATOR_TYPE_ARRAY;
        -: 1668:        }
        -: 1669:#if JERRY_BUILTIN_CONTAINER
    #####: 1670:        case ECMA_OBJECT_CLASS_SET_ITERATOR:
        -: 1671:        {
    #####: 1672:          return JERRY_ITERATOR_TYPE_SET;
        -: 1673:        }
    #####: 1674:        case ECMA_OBJECT_CLASS_MAP_ITERATOR:
        -: 1675:        {
    #####: 1676:          return JERRY_ITERATOR_TYPE_MAP;
        -: 1677:        }
        -: 1678:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 1679:        case ECMA_OBJECT_CLASS_STRING_ITERATOR:
        -: 1680:        {
    #####: 1681:          return JERRY_ITERATOR_TYPE_STRING;
        -: 1682:        }
    #####: 1683:        default:
        -: 1684:        {
    #####: 1685:          break;
        -: 1686:        }
        -: 1687:      }
    #####: 1688:    }
        -: 1689:  }
        -: 1690:#else /* !JERRY_ESNEXT */
        -: 1691:  JERRY_UNUSED (value);
        -: 1692:#endif /* JERRY_ESNEXT */
        -: 1693:
    #####: 1694:  return JERRY_ITERATOR_TYPE_NONE;
        -: 1695:} /* jerry_iterator_type */
        -: 1696:
        -: 1697:/**
        -: 1698: * Check if the specified feature is enabled.
        -: 1699: *
        -: 1700: * @return true  - if the specified feature is enabled,
        -: 1701: *         false - otherwise
        -: 1702: */
        -: 1703:bool
    #####: 1704:jerry_feature_enabled (const jerry_feature_t feature) /**< feature to check */
        -: 1705:{
    #####: 1706:  JERRY_ASSERT (feature < JERRY_FEATURE__COUNT);
        -: 1707:
        -: 1708:  return (false
        -: 1709:#if JERRY_CPOINTER_32_BIT
        -: 1710:          || feature == JERRY_FEATURE_CPOINTER_32_BIT
        -: 1711:#endif /* JERRY_CPOINTER_32_BIT */
        -: 1712:#if JERRY_ERROR_MESSAGES
    #####: 1713:          || feature == JERRY_FEATURE_ERROR_MESSAGES
        -: 1714:#endif /* JERRY_ERROR_MESSAGES */
        -: 1715:#if JERRY_PARSER
    #####: 1716:          || feature == JERRY_FEATURE_JS_PARSER
        -: 1717:#endif /* JERRY_PARSER */
        -: 1718:#if JERRY_MEM_STATS
    #####: 1719:          || feature == JERRY_FEATURE_HEAP_STATS
        -: 1720:#endif /* JERRY_MEM_STATS */
        -: 1721:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1722:          || feature == JERRY_FEATURE_PARSER_DUMP
        -: 1723:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1724:#if JERRY_REGEXP_DUMP_BYTE_CODE
        -: 1725:          || feature == JERRY_FEATURE_REGEXP_DUMP
        -: 1726:#endif /* JERRY_REGEXP_DUMP_BYTE_CODE */
        -: 1727:#if JERRY_SNAPSHOT_SAVE
    #####: 1728:          || feature == JERRY_FEATURE_SNAPSHOT_SAVE
        -: 1729:#endif /* JERRY_SNAPSHOT_SAVE */
        -: 1730:#if JERRY_SNAPSHOT_EXEC
    #####: 1731:          || feature == JERRY_FEATURE_SNAPSHOT_EXEC
        -: 1732:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1733:#if JERRY_DEBUGGER
        -: 1734:          || feature == JERRY_FEATURE_DEBUGGER
        -: 1735:#endif /* JERRY_DEBUGGER */
        -: 1736:#if JERRY_VM_HALT
    #####: 1737:          || feature == JERRY_FEATURE_VM_EXEC_STOP
        -: 1738:#endif /* JERRY_VM_HALT */
        -: 1739:#if JERRY_VM_THROW
        -: 1740:          || feature == JERRY_FEATURE_VM_THROW
        -: 1741:#endif /* JERRY_VM_THROW */
        -: 1742:#if JERRY_BUILTIN_JSON
    #####: 1743:          || feature == JERRY_FEATURE_JSON
        -: 1744:#endif /* JERRY_BUILTIN_JSON */
        -: 1745:#if JERRY_ESNEXT
    #####: 1746:          || feature == JERRY_FEATURE_PROMISE || feature == JERRY_FEATURE_SYMBOL
        -: 1747:#endif /* JERRY_ESNEXT */
        -: 1748:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 1749:          || feature == JERRY_FEATURE_TYPEDARRAY
        -: 1750:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1751:#if JERRY_BUILTIN_DATAVIEW
    #####: 1752:          || feature == JERRY_FEATURE_DATAVIEW
        -: 1753:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1754:#if JERRY_BUILTIN_PROXY
    #####: 1755:          || feature == JERRY_FEATURE_PROXY
        -: 1756:#endif /* JERRY_BUILTIN_PROXY */
        -: 1757:#if JERRY_BUILTIN_DATE
    #####: 1758:          || feature == JERRY_FEATURE_DATE
        -: 1759:#endif /* JERRY_BUILTIN_DATE */
        -: 1760:#if JERRY_BUILTIN_REGEXP
    #####: 1761:          || feature == JERRY_FEATURE_REGEXP
        -: 1762:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1763:#if JERRY_LINE_INFO
    #####: 1764:          || feature == JERRY_FEATURE_LINE_INFO
        -: 1765:#endif /* JERRY_LINE_INFO */
        -: 1766:#if JERRY_LOGGING
    #####: 1767:          || feature == JERRY_FEATURE_LOGGING
        -: 1768:#endif /* JERRY_LOGGING */
        -: 1769:#if JERRY_BUILTIN_GLOBAL_THIS
    #####: 1770:          || feature == JERRY_FEATURE_GLOBAL_THIS
        -: 1771:#endif /* JERRY_BUILTIN_GLOBAL_THIS */
        -: 1772:#if JERRY_BUILTIN_CONTAINER
    #####: 1773:          || feature == JERRY_FEATURE_MAP || feature == JERRY_FEATURE_SET || feature == JERRY_FEATURE_WEAKMAP
    #####: 1774:          || feature == JERRY_FEATURE_WEAKSET
        -: 1775:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1776:#if JERRY_BUILTIN_WEAKREF
    #####: 1777:          || feature == JERRY_FEATURE_WEAKREF
        -: 1778:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1779:#if JERRY_BUILTIN_BIGINT
    #####: 1780:          || feature == JERRY_FEATURE_BIGINT
        -: 1781:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1782:#if JERRY_BUILTIN_REALMS
    #####: 1783:          || feature == JERRY_FEATURE_REALM
        -: 1784:#endif /* JERRY_BUILTIN_REALMS */
        -: 1785:#if JERRY_PROMISE_CALLBACK
    #####: 1786:          || feature == JERRY_FEATURE_PROMISE_CALLBACK
        -: 1787:#endif /* JERRY_PROMISE_CALLBACK */
        -: 1788:#if JERRY_MODULE_SYSTEM
    #####: 1789:          || feature == JERRY_FEATURE_MODULE
        -: 1790:#endif /* JERRY_MODULE_SYSTEM */
        -: 1791:#if JERRY_FUNCTION_TO_STRING
    #####: 1792:          || feature == JERRY_FEATURE_FUNCTION_TO_STRING
        -: 1793:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1794:  );
        -: 1795:} /* jerry_feature_enabled */
        -: 1796:
        -: 1797:/**
        -: 1798: * Perform binary operation on the given operands (==, ===, <, >, etc.).
        -: 1799: *
        -: 1800: * @return error - if argument has an error flag or operation is unsuccessful or unsupported
        -: 1801: *         true/false - the result of the binary operation on the given operands otherwise
        -: 1802: */
        -: 1803:jerry_value_t
    #####: 1804:jerry_binary_op (jerry_binary_op_t operation, /**< operation */
        -: 1805:                 const jerry_value_t lhs, /**< first operand */
        -: 1806:                 const jerry_value_t rhs) /**< second operand */
        -: 1807:{
        -: 1808:  jerry_assert_api_enabled ();
        -: 1809:
    #####: 1810:  if (ecma_is_value_exception (lhs) || ecma_is_value_exception (rhs))
        -: 1811:  {
    #####: 1812:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 1813:  }
        -: 1814:
    #####: 1815:  switch (operation)
        -: 1816:  {
    #####: 1817:    case JERRY_BIN_OP_EQUAL:
        -: 1818:    {
    #####: 1819:      return jerry_return (ecma_op_abstract_equality_compare (lhs, rhs));
        -: 1820:    }
    #####: 1821:    case JERRY_BIN_OP_STRICT_EQUAL:
        -: 1822:    {
    #####: 1823:      return ecma_make_boolean_value (ecma_op_strict_equality_compare (lhs, rhs));
        -: 1824:    }
    #####: 1825:    case JERRY_BIN_OP_LESS:
        -: 1826:    {
    #####: 1827:      return jerry_return (opfunc_relation (lhs, rhs, true, false));
        -: 1828:    }
    #####: 1829:    case JERRY_BIN_OP_LESS_EQUAL:
        -: 1830:    {
    #####: 1831:      return jerry_return (opfunc_relation (lhs, rhs, false, true));
        -: 1832:    }
    #####: 1833:    case JERRY_BIN_OP_GREATER:
        -: 1834:    {
    #####: 1835:      return jerry_return (opfunc_relation (lhs, rhs, false, false));
        -: 1836:    }
    #####: 1837:    case JERRY_BIN_OP_GREATER_EQUAL:
        -: 1838:    {
    #####: 1839:      return jerry_return (opfunc_relation (lhs, rhs, true, true));
        -: 1840:    }
    #####: 1841:    case JERRY_BIN_OP_INSTANCEOF:
        -: 1842:    {
    #####: 1843:      if (!ecma_is_value_object (lhs) || !ecma_op_is_callable (rhs))
        -: 1844:      {
    #####: 1845:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 1846:      }
        -: 1847:
    #####: 1848:      ecma_object_t *proto_obj_p = ecma_get_object_from_value (rhs);
    #####: 1849:      return jerry_return (ecma_op_object_has_instance (proto_obj_p, lhs));
        -: 1850:    }
    #####: 1851:    case JERRY_BIN_OP_ADD:
        -: 1852:    {
    #####: 1853:      return jerry_return (opfunc_addition (lhs, rhs));
        -: 1854:    }
    #####: 1855:    case JERRY_BIN_OP_SUB:
        -: 1856:    case JERRY_BIN_OP_MUL:
        -: 1857:    case JERRY_BIN_OP_DIV:
        -: 1858:    case JERRY_BIN_OP_REM:
        -: 1859:    {
    #####: 1860:      return jerry_return (do_number_arithmetic (operation - ECMA_NUMBER_ARITHMETIC_OP_API_OFFSET, lhs, rhs));
        -: 1861:    }
    #####: 1862:    default:
        -: 1863:    {
    #####: 1864:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_UNSUPPORTED_BINARY_OPERATION));
        -: 1865:    }
        -: 1866:  }
        -: 1867:} /* jerry_binary_op */
        -: 1868:
        -: 1869:/**
        -: 1870: * Create an abort value containing the argument value. If the second argument is true
        -: 1871: * the function will take ownership ofthe input value, otherwise the value will be copied.
        -: 1872: *
        -: 1873: * @return api abort value
        -: 1874: */
        -: 1875:jerry_value_t
    #####: 1876:jerry_throw_abort (jerry_value_t value, /**< api value */
        -: 1877:                   bool take_ownership) /**< release api value */
        -: 1878:{
        -: 1879:  jerry_assert_api_enabled ();
        -: 1880:
    #####: 1881:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 1882:  {
        -: 1883:    /* This is a rare case so it is optimized for
        -: 1884:     * binary size rather than performance. */
    #####: 1885:    if (jerry_value_is_abort (value))
        -: 1886:    {
    #####: 1887:      return take_ownership ? value : jerry_value_copy (value);
        -: 1888:    }
        -: 1889:
    #####: 1890:    value = jerry_exception_value (value, take_ownership);
    #####: 1891:    take_ownership = true;
        -: 1892:  }
        -: 1893:
    #####: 1894:  if (!take_ownership)
        -: 1895:  {
    #####: 1896:    value = ecma_copy_value (value);
        -: 1897:  }
        -: 1898:
    #####: 1899:  return ecma_create_exception (value, ECMA_ERROR_API_FLAG_ABORT);
        -: 1900:} /* jerry_throw_abort */
        -: 1901:
        -: 1902:/**
        -: 1903: * Create an exception value containing the argument value. If the second argument is true
        -: 1904: * the function will take ownership ofthe input value, otherwise the value will be copied.
        -: 1905: *
        -: 1906: * @return exception value
        -: 1907: */
        -: 1908:jerry_value_t
    #####: 1909:jerry_throw_value (jerry_value_t value, /**< value */
        -: 1910:                   bool take_ownership) /**< take ownership of the value */
        -: 1911:{
        -: 1912:  jerry_assert_api_enabled ();
        -: 1913:
    #####: 1914:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 1915:  {
        -: 1916:    /* This is a rare case so it is optimized for
        -: 1917:     * binary size rather than performance. */
    #####: 1918:    if (!jerry_value_is_abort (value))
        -: 1919:    {
    #####: 1920:      return take_ownership ? value : jerry_value_copy (value);
        -: 1921:    }
        -: 1922:
    #####: 1923:    value = jerry_exception_value (value, take_ownership);
    #####: 1924:    take_ownership = true;
        -: 1925:  }
        -: 1926:
    #####: 1927:  if (!take_ownership)
        -: 1928:  {
    #####: 1929:    value = ecma_copy_value (value);
        -: 1930:  }
        -: 1931:
    #####: 1932:  return ecma_create_exception (value, ECMA_ERROR_API_FLAG_NONE);
        -: 1933:} /* jerry_throw_value */
        -: 1934:
        -: 1935:/**
        -: 1936: * Get the value contained in an exception. If the second argument is true
        -: 1937: * it will release the argument exception value in the process.
        -: 1938: *
        -: 1939: * @return value in exception
        -: 1940: */
        -: 1941:jerry_value_t
    #####: 1942:jerry_exception_value (jerry_value_t value, /**< api value */
        -: 1943:                       bool free_exception) /**< release api value */
        -: 1944:{
        -: 1945:  jerry_assert_api_enabled ();
        -: 1946:
    #####: 1947:  if (!ecma_is_value_exception (value))
        -: 1948:  {
    #####: 1949:    return free_exception ? value : ecma_copy_value (value);
        -: 1950:  }
        -: 1951:
    #####: 1952:  jerry_value_t ret_val = jerry_value_copy (ecma_get_extended_primitive_from_value (value)->u.value);
        -: 1953:
    #####: 1954:  if (free_exception)
        -: 1955:  {
    #####: 1956:    jerry_value_free (value);
        -: 1957:  }
    #####: 1958:  return ret_val;
        -: 1959:} /* jerry_exception_value */
        -: 1960:
        -: 1961:/**
        -: 1962: * Set new decorator callback for Error objects. The decorator can
        -: 1963: * create or update any properties of the newly created Error object.
        -: 1964: */
        -: 1965:void
    #####: 1966:jerry_error_on_created (jerry_error_object_created_cb_t callback, /**< new callback */
        -: 1967:                        void *user_p) /**< user pointer passed to the callback */
        -: 1968:{
        -: 1969:  jerry_assert_api_enabled ();
        -: 1970:
    #####: 1971:  JERRY_CONTEXT (error_object_created_callback_p) = callback;
    #####: 1972:  JERRY_CONTEXT (error_object_created_callback_user_p) = user_p;
    #####: 1973:} /* jerry_error_on_created */
        -: 1974:
        -: 1975:/**
        -: 1976: * When JERRY_VM_THROW is enabled, the callback passed to this
        -: 1977: * function is called when an error is thrown in ECMAScript code.
        -: 1978: */
        -: 1979:void
    #####: 1980:jerry_on_throw (jerry_throw_cb_t callback, /**< callback which is called on throws */
        -: 1981:                void *user_p) /**< pointer passed to the function */
        -: 1982:{
        -: 1983:#if JERRY_VM_THROW
    #####: 1984:  JERRY_CONTEXT (vm_throw_callback_p) = callback;
    #####: 1985:  JERRY_CONTEXT (vm_throw_callback_user_p) = user_p;
        -: 1986:#else /* !JERRY_VM_THROW */
        -: 1987:  JERRY_UNUSED (callback);
        -: 1988:  JERRY_UNUSED (user_p);
        -: 1989:#endif /* JERRY_VM_THROW */
    #####: 1990:} /* jerry_on_throw */
        -: 1991:
        -: 1992:/**
        -: 1993: * Checks whether the callback set by jerry_on_throw captured the error
        -: 1994: *
        -: 1995: * @return true, if the vm throw callback captured the error
        -: 1996: *         false, otherwise
        -: 1997: */
        -: 1998:bool
    #####: 1999:jerry_exception_is_captured (const jerry_value_t value) /**< exception value */
        -: 2000:{
        -: 2001:  jerry_assert_api_enabled ();
        -: 2002:
        -: 2003:#if JERRY_VM_THROW
    #####: 2004:  if (!ecma_is_value_exception (value))
        -: 2005:  {
        -: 2006:    return false;
        -: 2007:  }
        -: 2008:
    #####: 2009:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 2010:
    #####: 2011:  return (error_ref_p->refs_and_type & ECMA_ERROR_API_FLAG_THROW_CAPTURED) != 0;
        -: 2012:#else /* !JERRY_VM_THROW */
        -: 2013:  JERRY_UNUSED (value);
    #####: 2014:  return false;
        -: 2015:#endif /* JERRY_VM_THROW */
        -: 2016:} /* jerry_exception_is_captured */
        -: 2017:
        -: 2018:/**
        -: 2019: * Sets whether the callback set by jerry_on_throw should capture the exception or not
        -: 2020: */
        -: 2021:void
    #####: 2022:jerry_exception_allow_capture (jerry_value_t value, /**< exception value */
        -: 2023:                               bool should_capture) /**< callback should capture this error */
        -: 2024:{
        -: 2025:  jerry_assert_api_enabled ();
        -: 2026:
        -: 2027:#if JERRY_VM_THROW
    #####: 2028:  if (!ecma_is_value_exception (value))
        -: 2029:  {
        -: 2030:    return;
        -: 2031:  }
        -: 2032:
    #####: 2033:  ecma_extended_primitive_t *error_ref_p = ecma_get_extended_primitive_from_value (value);
        -: 2034:
    #####: 2035:  if (should_capture)
        -: 2036:  {
    #####: 2037:    error_ref_p->refs_and_type &= ~(uint32_t) ECMA_ERROR_API_FLAG_THROW_CAPTURED;
    #####: 2038:    return;
        -: 2039:  }
        -: 2040:
    #####: 2041:  error_ref_p->refs_and_type |= ECMA_ERROR_API_FLAG_THROW_CAPTURED;
        -: 2042:#else /* !JERRY_VM_THROW */
        -: 2043:  JERRY_UNUSED (value);
        -: 2044:  JERRY_UNUSED (should_capture);
        -: 2045:#endif /* JERRY_VM_THROW */
    #####: 2046:} /* jerry_exception_allow_capture */
        -: 2047:
        -: 2048:/**
        -: 2049: * Check if the given value is an Error object.
        -: 2050: *
        -: 2051: * @return true - if it is an Error object
        -: 2052: *         false - otherwise
        -: 2053: */
        -: 2054:bool
    #####: 2055:jerry_value_is_error (const jerry_value_t value) /**< api value */
        -: 2056:{
    #####: 2057:  return ecma_is_value_object (value)
    #####: 2058:         && ecma_object_class_is (ecma_get_object_from_value (value), ECMA_OBJECT_CLASS_ERROR);
        -: 2059:} /* jerry_value_is_error */
        -: 2060:
        -: 2061:/**
        -: 2062: * Return the type of the Error object if possible.
        -: 2063: *
        -: 2064: * @return one of the jerry_error_t value as the type of the Error object
        -: 2065: *         JERRY_ERROR_NONE - if the input value is not an Error object
        -: 2066: */
        -: 2067:jerry_error_t
    #####: 2068:jerry_error_type (jerry_value_t value) /**< api value */
        -: 2069:{
    #####: 2070:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 2071:  {
    #####: 2072:    value = ecma_get_extended_primitive_from_value (value)->u.value;
        -: 2073:  }
        -: 2074:
    #####: 2075:  if (!ecma_is_value_object (value))
        -: 2076:  {
    #####: 2077:    return JERRY_ERROR_NONE;
        -: 2078:  }
        -: 2079:
    #####: 2080:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 2081:  /* TODO(check if error object) */
    #####: 2082:  jerry_error_t error_type = ecma_get_error_type (object_p);
        -: 2083:
    #####: 2084:  return (jerry_error_t) error_type;
        -: 2085:} /* jerry_error_type */
        -: 2086:
        -: 2087:/**
        -: 2088: * Get number from the specified value as a double.
        -: 2089: *
        -: 2090: * @return stored number as double
        -: 2091: */
        -: 2092:double
    #####: 2093:jerry_value_as_number (const jerry_value_t value) /**< api value */
        -: 2094:{
        -: 2095:  jerry_assert_api_enabled ();
        -: 2096:
    #####: 2097:  if (!ecma_is_value_number (value))
        -: 2098:  {
    #####: 2099:    return 0;
        -: 2100:  }
        -: 2101:
    #####: 2102:  return (double) ecma_get_number_from_value (value);
        -: 2103:} /* jerry_value_as_number */
        -: 2104:
        -: 2105:/**
        -: 2106: * Call ToBoolean operation on the api value.
        -: 2107: *
        -: 2108: * @return true  - if the logical value is true
        -: 2109: *         false - otherwise
        -: 2110: */
        -: 2111:bool
    #####: 2112:jerry_value_to_boolean (const jerry_value_t value) /**< input value */
        -: 2113:{
        -: 2114:  jerry_assert_api_enabled ();
        -: 2115:
    #####: 2116:  if (ecma_is_value_exception (value))
        -: 2117:  {
    #####: 2118:    return false;
        -: 2119:  }
        -: 2120:
    #####: 2121:  return ecma_op_to_boolean (value);
        -: 2122:} /* jerry_value_to_boolean */
        -: 2123:
        -: 2124:/**
        -: 2125: * Call ToNumber operation on the api value.
        -: 2126: *
        -: 2127: * Note:
        -: 2128: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2129: *
        -: 2130: * @return converted number value - if success
        -: 2131: *         thrown error - otherwise
        -: 2132: */
        -: 2133:jerry_value_t
    #####: 2134:jerry_value_to_number (const jerry_value_t value) /**< input value */
        -: 2135:{
        -: 2136:  jerry_assert_api_enabled ();
        -: 2137:
    #####: 2138:  if (ecma_is_value_exception (value))
        -: 2139:  {
    #####: 2140:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2141:  }
        -: 2142:
    #####: 2143:  ecma_number_t num;
    #####: 2144:  ecma_value_t ret_value = ecma_op_to_number (value, &num);
        -: 2145:
    #####: 2146:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -: 2147:  {
    #####: 2148:    return ecma_create_exception_from_context ();
        -: 2149:  }
        -: 2150:
    #####: 2151:  return ecma_make_number_value (num);
        -: 2152:} /* jerry_value_to_number */
        -: 2153:
        -: 2154:/**
        -: 2155: * Call ToObject operation on the api value.
        -: 2156: *
        -: 2157: * Note:
        -: 2158: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2159: *
        -: 2160: * @return converted object value - if success
        -: 2161: *         thrown error - otherwise
        -: 2162: */
        -: 2163:jerry_value_t
    #####: 2164:jerry_value_to_object (const jerry_value_t value) /**< input value */
        -: 2165:{
        -: 2166:  jerry_assert_api_enabled ();
        -: 2167:
    #####: 2168:  if (ecma_is_value_exception (value))
        -: 2169:  {
    #####: 2170:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2171:  }
        -: 2172:
    #####: 2173:  return jerry_return (ecma_op_to_object (value));
        -: 2174:} /* jerry_value_to_object */
        -: 2175:
        -: 2176:/**
        -: 2177: * Call ToPrimitive operation on the api value.
        -: 2178: *
        -: 2179: * Note:
        -: 2180: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2181: *
        -: 2182: * @return converted primitive value - if success
        -: 2183: *         thrown error - otherwise
        -: 2184: */
        -: 2185:jerry_value_t
    #####: 2186:jerry_value_to_primitive (const jerry_value_t value) /**< input value */
        -: 2187:{
        -: 2188:  jerry_assert_api_enabled ();
        -: 2189:
    #####: 2190:  if (ecma_is_value_exception (value))
        -: 2191:  {
    #####: 2192:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2193:  }
        -: 2194:
    #####: 2195:  return jerry_return (ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_NO));
        -: 2196:} /* jerry_value_to_primitive */
        -: 2197:
        -: 2198:/**
        -: 2199: * Call the ToString ecma builtin operation on the api value.
        -: 2200: *
        -: 2201: * Note:
        -: 2202: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2203: *
        -: 2204: * @return converted string value - if success
        -: 2205: *         thrown error - otherwise
        -: 2206: */
        -: 2207:jerry_value_t
    #####: 2208:jerry_value_to_string (const jerry_value_t value) /**< input value */
        -: 2209:{
        -: 2210:  jerry_assert_api_enabled ();
        -: 2211:
    #####: 2212:  if (ecma_is_value_exception (value))
        -: 2213:  {
    #####: 2214:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2215:  }
        -: 2216:
    #####: 2217:  ecma_string_t *str_p = ecma_op_to_string (value);
    #####: 2218:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 2219:  {
    #####: 2220:    return ecma_create_exception_from_context ();
        -: 2221:  }
        -: 2222:
    #####: 2223:  return ecma_make_string_value (str_p);
        -: 2224:} /* jerry_value_to_string */
        -: 2225:
        -: 2226:/**
        -: 2227: * Call the BigInt constructor ecma builtin operation on the api value.
        -: 2228: *
        -: 2229: * Note:
        -: 2230: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2231: *
        -: 2232: * @return BigInt value - if success
        -: 2233: *         thrown error - otherwise
        -: 2234: */
        -: 2235:jerry_value_t
    #####: 2236:jerry_value_to_bigint (const jerry_value_t value) /**< input value */
        -: 2237:{
        -: 2238:  jerry_assert_api_enabled ();
        -: 2239:
        -: 2240:#if JERRY_BUILTIN_BIGINT
    #####: 2241:  if (ecma_is_value_exception (value))
        -: 2242:  {
    #####: 2243:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 2244:  }
        -: 2245:
    #####: 2246:  return jerry_return (ecma_bigint_to_bigint (value, true));
        -: 2247:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2248:  JERRY_UNUSED (value);
    #####: 2249:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_BIGINT_NOT_SUPPORTED));
        -: 2250:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2251:} /* jerry_value_to_bigint */
        -: 2252:
        -: 2253:/**
        -: 2254: * Convert any number to integer number.
        -: 2255: *
        -: 2256: * Note:
        -: 2257: *      For non-number values 0 is returned.
        -: 2258: *
        -: 2259: * @return integer representation of the number.
        -: 2260: */
        -: 2261:double
    #####: 2262:jerry_value_as_integer (const jerry_value_t value) /**< input value */
        -: 2263:{
        -: 2264:  jerry_assert_api_enabled ();
        -: 2265:
    #####: 2266:  if (!ecma_is_value_number (value))
        -: 2267:  {
    #####: 2268:    return 0;
        -: 2269:  }
        -: 2270:
    #####: 2271:  double number = ecma_get_number_from_value (value);
        -: 2272:
    #####: 2273:  if (ecma_number_is_nan (number))
        -: 2274:  {
    #####: 2275:    return ECMA_NUMBER_ZERO;
        -: 2276:  }
        -: 2277:
    #####: 2278:  if (ecma_number_is_zero (number) || ecma_number_is_infinity (number))
        -: 2279:  {
    #####: 2280:    return number;
        -: 2281:  }
        -: 2282:
    #####: 2283:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number));
        -: 2284:
    #####: 2285:  return ecma_number_is_negative (number) ? -floor_fabs : floor_fabs;
        -: 2286:} /* jerry_value_as_integer */
        -: 2287:
        -: 2288:/**
        -: 2289: * Convert any number to int32 number.
        -: 2290: *
        -: 2291: * Note:
        -: 2292: *      For non-number values 0 is returned.
        -: 2293: *
        -: 2294: * @return int32 representation of the number.
        -: 2295: */
        -: 2296:int32_t
    #####: 2297:jerry_value_as_int32 (const jerry_value_t value) /**< input value */
        -: 2298:{
        -: 2299:  jerry_assert_api_enabled ();
        -: 2300:
    #####: 2301:  if (!ecma_is_value_number (value))
        -: 2302:  {
    #####: 2303:    return 0;
        -: 2304:  }
        -: 2305:
    #####: 2306:  return ecma_number_to_int32 (ecma_get_number_from_value (value));
        -: 2307:} /* jerry_value_as_int32 */
        -: 2308:
        -: 2309:/**
        -: 2310: * Convert any number to uint32 number.
        -: 2311: *
        -: 2312: * Note:
        -: 2313: *      For non-number values 0 is returned.
        -: 2314: *
        -: 2315: * @return uint32 representation of the number.
        -: 2316: */
        -: 2317:uint32_t
    #####: 2318:jerry_value_as_uint32 (const jerry_value_t value) /**< input value */
        -: 2319:{
        -: 2320:  jerry_assert_api_enabled ();
        -: 2321:
    #####: 2322:  if (!ecma_is_value_number (value))
        -: 2323:  {
    #####: 2324:    return 0;
        -: 2325:  }
        -: 2326:
    #####: 2327:  return ecma_number_to_uint32 (ecma_get_number_from_value (value));
        -: 2328:} /* jerry_value_as_uint32 */
        -: 2329:
        -: 2330:/**
        -: 2331: * Take additional ownership over the argument value.
        -: 2332: * The value will be copied by reference when possible, changes made to the new value will be reflected
        -: 2333: * in the original.
        -: 2334: *
        -: 2335: * @return copied value
        -: 2336: */
        -: 2337:jerry_value_t
    #####: 2338:jerry_value_copy (const jerry_value_t value) /**< value */
        -: 2339:{
        -: 2340:  jerry_assert_api_enabled ();
        -: 2341:
    #####: 2342:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 2343:  {
    #####: 2344:    ecma_ref_extended_primitive (ecma_get_extended_primitive_from_value (value));
    #####: 2345:    return value;
        -: 2346:  }
        -: 2347:
    #####: 2348:  return ecma_copy_value (value);
        -: 2349:} /* jerry_value_copy */
        -: 2350:
        -: 2351:/**
        -: 2352: * Release ownership of the argument value
        -: 2353: */
        -: 2354:void
       21: 2355:jerry_value_free (jerry_value_t value) /**< value */
        -: 2356:{
        -: 2357:  jerry_assert_api_enabled ();
        -: 2358:
       21: 2359:  if (JERRY_UNLIKELY (ecma_is_value_exception (value)))
        -: 2360:  {
    #####: 2361:    ecma_deref_exception (ecma_get_extended_primitive_from_value (value));
    #####: 2362:    return;
        -: 2363:  }
        -: 2364:
       21: 2365:  ecma_free_value (value);
        -: 2366:} /* jerry_value_free */
        -: 2367:
        -: 2368:/**
        -: 2369: * Create an array object value
        -: 2370: *
        -: 2371: * Note:
        -: 2372: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2373: *
        -: 2374: * @return value of the constructed array object
        -: 2375: */
        -: 2376:jerry_value_t
    #####: 2377:jerry_array (jerry_length_t length) /**< length of array */
        -: 2378:{
        -: 2379:  jerry_assert_api_enabled ();
        -: 2380:
    #####: 2381:  ecma_object_t *array_p = ecma_op_new_array_object (length);
    #####: 2382:  return ecma_make_object_value (array_p);
        -: 2383:} /* jerry_array */
        -: 2384:
        -: 2385:/**
        -: 2386: * Create a jerry_value_t representing a boolean value from the given boolean parameter.
        -: 2387: *
        -: 2388: * @return value of the created boolean
        -: 2389: */
        -: 2390:jerry_value_t
    #####: 2391:jerry_boolean (bool value) /**< bool value from which a jerry_value_t will be created */
        -: 2392:{
        -: 2393:  jerry_assert_api_enabled ();
        -: 2394:
    #####: 2395:  return ecma_make_boolean_value (value);
        -: 2396:} /* jerry_boolean */
        -: 2397:
        -: 2398:/**
        -: 2399: * Create an Error object with the provided string value as the error message.
        -: 2400: * If the message value is not a string, the created error will not have a message property.
        -: 2401: *
        -: 2402: * @return Error object
        -: 2403: */
        -: 2404:jerry_value_t
    #####: 2405:jerry_error (jerry_error_t error_type, /**< type of error */
        -: 2406:             const jerry_value_t message) /**< message of the error */
        -: 2407:{
        -: 2408:  jerry_assert_api_enabled ();
        -: 2409:
    #####: 2410:  ecma_string_t *message_p = NULL;
    #####: 2411:  if (ecma_is_value_string (message))
        -: 2412:  {
    #####: 2413:    message_p = ecma_get_string_from_value (message);
        -: 2414:  }
        -: 2415:
    #####: 2416:  ecma_object_t *error_object_p = ecma_new_standard_error ((jerry_error_t) error_type, message_p);
        -: 2417:
    #####: 2418:  return ecma_make_object_value (error_object_p);
        -: 2419:} /* jerry_error */
        -: 2420:
        -: 2421:/**
        -: 2422: * Create an Error object with a zero-terminated string as a message. If the message string is NULL, the created error
        -: 2423: * will not have a message property.
        -: 2424: *
        -: 2425: * @return Error object
        -: 2426: */
        -: 2427:jerry_value_t
    #####: 2428:jerry_error_sz (jerry_error_t error_type, /**< type of error */
        -: 2429:                const char *message_p) /**< value of 'message' property
        -: 2430:                                        *   of constructed error object */
        -: 2431:{
    #####: 2432:  jerry_value_t message = ECMA_VALUE_UNDEFINED;
        -: 2433:
    #####: 2434:  if (message_p != NULL)
        -: 2435:  {
    #####: 2436:    message = jerry_string_sz (message_p);
        -: 2437:  }
        -: 2438:
    #####: 2439:  ecma_value_t error = jerry_error (error_type, message);
    #####: 2440:  ecma_free_value (message);
        -: 2441:
    #####: 2442:  return error;
        -: 2443:} /* jerry_error_sz */
        -: 2444:
        -: 2445:/**
        -: 2446: * Create an exception by constructing an Error object with the specified type and the provided string value as the
        -: 2447: * error message.  If the message value is not a string, the created error will not have a message property.
        -: 2448: *
        -: 2449: * @return exception value
        -: 2450: */
        -: 2451:jerry_value_t
    #####: 2452:jerry_throw (jerry_error_t error_type, /**< type of error */
        -: 2453:             const jerry_value_t message) /**< message value */
        -: 2454:{
    #####: 2455:  return jerry_throw_value (jerry_error (error_type, message), true);
        -: 2456:} /* jerry_throw */
        -: 2457:
        -: 2458:/**
        -: 2459: * Create an exception by constructing an Error object with the specified type and the provided zero-terminated ASCII
        -: 2460: * string as the error message.  If the message string is NULL, the created error will not have a message property.
        -: 2461: *
        -: 2462: * @return exception value
        -: 2463: */
        -: 2464:jerry_value_t
    #####: 2465:jerry_throw_sz (jerry_error_t error_type, /**< type of error */
        -: 2466:                const char *message_p) /**< value of 'message' property
        -: 2467:                                        *   of constructed error object */
        -: 2468:{
    #####: 2469:  return jerry_throw_value (jerry_error_sz (error_type, message_p), true);
        -: 2470:} /* jerry_throw_sz */
        -: 2471:
        -: 2472:/**
        -: 2473: * Create an external function object
        -: 2474: *
        -: 2475: * Note:
        -: 2476: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2477: *
        -: 2478: * @return value of the constructed function object
        -: 2479: */
        -: 2480:jerry_value_t
        5: 2481:jerry_function_external (jerry_external_handler_t handler) /**< native handler
        -: 2482:                                                            *   for the function */
        -: 2483:{
        -: 2484:  jerry_assert_api_enabled ();
        -: 2485:
        5: 2486:  ecma_object_t *func_obj_p = ecma_op_create_external_function_object (handler);
        5: 2487:  return ecma_make_object_value (func_obj_p);
        -: 2488:} /* jerry_function_external */
        -: 2489:
        -: 2490:/**
        -: 2491: * Creates a jerry_value_t representing a number value.
        -: 2492: *
        -: 2493: * Note:
        -: 2494: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2495: *
        -: 2496: * @return jerry_value_t created from the given double argument.
        -: 2497: */
        -: 2498:jerry_value_t
    #####: 2499:jerry_number (double value) /**< double value from which a jerry_value_t will be created */
        -: 2500:{
        -: 2501:  jerry_assert_api_enabled ();
        -: 2502:
    #####: 2503:  return ecma_make_number_value ((ecma_number_t) value);
        -: 2504:} /* jerry_number */
        -: 2505:
        -: 2506:/**
        -: 2507: * Creates a jerry_value_t representing a positive or negative infinity value.
        -: 2508: *
        -: 2509: * Note:
        -: 2510: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2511: *
        -: 2512: * @return jerry_value_t representing an infinity value.
        -: 2513: */
        -: 2514:jerry_value_t
    #####: 2515:jerry_infinity (bool sign) /**< true for negative Infinity
        -: 2516:                            *   false for positive Infinity */
        -: 2517:{
        -: 2518:  jerry_assert_api_enabled ();
        -: 2519:
    #####: 2520:  return ecma_make_number_value (ecma_number_make_infinity (sign));
        -: 2521:} /* jerry_infinity */
        -: 2522:
        -: 2523:/**
        -: 2524: * Creates a jerry_value_t representing a not-a-number value.
        -: 2525: *
        -: 2526: * Note:
        -: 2527: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2528: *
        -: 2529: * @return jerry_value_t representing a not-a-number value.
        -: 2530: */
        -: 2531:jerry_value_t
    #####: 2532:jerry_nan (void)
        -: 2533:{
        -: 2534:  jerry_assert_api_enabled ();
        -: 2535:
    #####: 2536:  return ecma_make_nan_value ();
        -: 2537:} /* jerry_nan */
        -: 2538:
        -: 2539:/**
        -: 2540: * Creates a jerry_value_t representing an undefined value.
        -: 2541: *
        -: 2542: * @return value of undefined
        -: 2543: */
        -: 2544:jerry_value_t
    #####: 2545:jerry_undefined (void)
        -: 2546:{
        -: 2547:  jerry_assert_api_enabled ();
        -: 2548:
    #####: 2549:  return ECMA_VALUE_UNDEFINED;
        -: 2550:} /* jerry_undefined */
        -: 2551:
        -: 2552:/**
        -: 2553: * Creates and returns a jerry_value_t with type null object.
        -: 2554: *
        -: 2555: * @return jerry_value_t representing null
        -: 2556: */
        -: 2557:jerry_value_t
    #####: 2558:jerry_null (void)
        -: 2559:{
        -: 2560:  jerry_assert_api_enabled ();
        -: 2561:
    #####: 2562:  return ECMA_VALUE_NULL;
        -: 2563:} /* jerry_null */
        -: 2564:
        -: 2565:/**
        -: 2566: * Create new JavaScript object, like with new Object().
        -: 2567: *
        -: 2568: * Note:
        -: 2569: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2570: *
        -: 2571: * @return value of the created object
        -: 2572: */
        -: 2573:jerry_value_t
    #####: 2574:jerry_object (void)
        -: 2575:{
        -: 2576:  jerry_assert_api_enabled ();
        -: 2577:
    #####: 2578:  return ecma_make_object_value (ecma_op_create_object_object_noarg ());
        -: 2579:} /* jerry_object */
        -: 2580:
        -: 2581:/**
        -: 2582: * Create an empty Promise object which can be resolved/rejected later
        -: 2583: * by calling jerry_promise_resolve or jerry_promise_reject.
        -: 2584: *
        -: 2585: * Note:
        -: 2586: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2587: *
        -: 2588: * @return value of the created object
        -: 2589: */
        -: 2590:jerry_value_t
    #####: 2591:jerry_promise (void)
        -: 2592:{
        -: 2593:  jerry_assert_api_enabled ();
        -: 2594:
        -: 2595:#if JERRY_ESNEXT
    #####: 2596:  return jerry_return (ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, NULL));
        -: 2597:#else /* !JERRY_ESNEXT */
    #####: 2598:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROMISE_NOT_SUPPORTED));
        -: 2599:#endif /* JERRY_ESNEXT */
        -: 2600:} /* jerry_promise */
        -: 2601:
        -: 2602:/**
        -: 2603: * Create a new Proxy object with the given target and handler
        -: 2604: *
        -: 2605: * Note:
        -: 2606: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2607: *
        -: 2608: * @return value of the created Proxy object
        -: 2609: */
        -: 2610:jerry_value_t
    #####: 2611:jerry_proxy (const jerry_value_t target, /**< target argument */
        -: 2612:             const jerry_value_t handler) /**< handler argument */
        -: 2613:{
        -: 2614:  jerry_assert_api_enabled ();
        -: 2615:
    #####: 2616:  if (ecma_is_value_exception (target) || ecma_is_value_exception (handler))
        -: 2617:  {
    #####: 2618:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 2619:  }
        -: 2620:
        -: 2621:#if JERRY_BUILTIN_PROXY
    #####: 2622:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, 0);
        -: 2623:
    #####: 2624:  if (proxy_p == NULL)
        -: 2625:  {
    #####: 2626:    return ecma_create_exception_from_context ();
        -: 2627:  }
        -: 2628:
    #####: 2629:  return ecma_make_object_value (proxy_p);
        -: 2630:#else /* !JERRY_BUILTIN_PROXY */
    #####: 2631:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROXY_IS_NOT_SUPPORTED));
        -: 2632:#endif /* JERRY_BUILTIN_PROXY */
        -: 2633:} /* jerry_proxy */
        -: 2634:
        -: 2635:#if JERRY_BUILTIN_PROXY
        -: 2636:
        -: 2637:JERRY_STATIC_ASSERT ((int) JERRY_PROXY_SKIP_RESULT_VALIDATION == (int) ECMA_PROXY_SKIP_RESULT_VALIDATION,
        -: 2638:                     jerry_and_ecma_proxy_skip_result_validation_must_be_equal);
        -: 2639:
        -: 2640:#endif /* JERRY_BUILTIN_PROXY */
        -: 2641:
        -: 2642:/**
        -: 2643: * Create a new Proxy object with the given target, handler, and special options
        -: 2644: *
        -: 2645: * Note:
        -: 2646: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 2647: *
        -: 2648: * @return value of the created Proxy object
        -: 2649: */
        -: 2650:jerry_value_t
    #####: 2651:jerry_proxy_custom (const jerry_value_t target, /**< target argument */
        -: 2652:                    const jerry_value_t handler, /**< handler argument */
        -: 2653:                    uint32_t flags) /**< jerry_proxy_custom_behavior_t option bits */
        -: 2654:{
        -: 2655:  jerry_assert_api_enabled ();
        -: 2656:
    #####: 2657:  if (ecma_is_value_exception (target) || ecma_is_value_exception (handler))
        -: 2658:  {
    #####: 2659:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 2660:  }
        -: 2661:
        -: 2662:#if JERRY_BUILTIN_PROXY
    #####: 2663:  flags &= JERRY_PROXY_SKIP_RESULT_VALIDATION;
        -: 2664:
    #####: 2665:  ecma_object_t *proxy_p = ecma_proxy_create (target, handler, flags);
        -: 2666:
    #####: 2667:  if (proxy_p == NULL)
        -: 2668:  {
    #####: 2669:    return ecma_create_exception_from_context ();
        -: 2670:  }
        -: 2671:
    #####: 2672:  return ecma_make_object_value (proxy_p);
        -: 2673:#else /* !JERRY_BUILTIN_PROXY */
        -: 2674:  JERRY_UNUSED (flags);
    #####: 2675:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROXY_IS_NOT_SUPPORTED));
        -: 2676:#endif /* JERRY_BUILTIN_PROXY */
        -: 2677:} /* jerry_proxy_custom */
        -: 2678:
        -: 2679:/**
        -: 2680: * Create string value from the input zero-terminated ASCII string.
        -: 2681: *
        -: 2682: * @return created string
        -: 2683: */
        -: 2684:jerry_value_t
        5: 2685:jerry_string_sz (const char *str_p) /**< pointer to string */
        -: 2686:{
        5: 2687:  const jerry_char_t *data_p = (const jerry_char_t *) str_p;
        5: 2688:  return jerry_string (data_p, lit_zt_utf8_string_size (data_p), JERRY_ENCODING_CESU8);
        -: 2689:} /* jerry_string_sz */
        -: 2690:
        -: 2691:/**
        -: 2692: * Create a string value from the input buffer using the specified encoding.
        -: 2693: * The content of the buffer is assumed to be valid in the specified encoding, it's the callers responsibility to
        -: 2694: * validate the input.
        -: 2695: *
        -: 2696: * See also: jerry_validate_string
        -: 2697: *
        -: 2698: * @return created string
        -: 2699: */
        -: 2700:jerry_value_t
        6: 2701:jerry_string (const jerry_char_t *buffer_p, /**< pointer to buffer */
        -: 2702:              jerry_size_t buffer_size, /**< buffer size */
        -: 2703:              jerry_encoding_t encoding) /**< buffer encoding */
        -: 2704:{
        -: 2705:  jerry_assert_api_enabled ();
        6: 2706:  ecma_string_t *ecma_str_p = NULL;
        6: 2707:  JERRY_ASSERT (jerry_validate_string (buffer_p, buffer_size, encoding));
        -: 2708:
        6: 2709:  switch (encoding)
        -: 2710:  {
        5: 2711:    case JERRY_ENCODING_CESU8:
        -: 2712:    {
        5: 2713:      ecma_str_p = ecma_new_ecma_string_from_utf8 (buffer_p, buffer_size);
        5: 2714:      break;
        -: 2715:    }
        1: 2716:    case JERRY_ENCODING_UTF8:
        -: 2717:    {
        1: 2718:      ecma_str_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 (buffer_p, buffer_size);
        1: 2719:      break;
        -: 2720:    }
    #####: 2721:    default:
        -: 2722:    {
    #####: 2723:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INVALID_ENCODING));
        -: 2724:    }
        -: 2725:  }
        -: 2726:
        6: 2727:  return ecma_make_string_value (ecma_str_p);
        -: 2728:} /* jerry_string */
        -: 2729:
        -: 2730:/**
        -: 2731: * Create external string from input zero-terminated ASCII string.
        -: 2732: *
        -: 2733: * @return created external string
        -: 2734: */
        -: 2735:jerry_value_t
    #####: 2736:jerry_string_external_sz (const char *str_p, /**< pointer to string */
        -: 2737:                          void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2738:{
    #####: 2739:  const jerry_char_t *data_p = (const jerry_char_t *) str_p;
    #####: 2740:  return jerry_string_external (data_p, lit_zt_utf8_string_size (data_p), user_p);
        -: 2741:} /* jerry_string_external_sz */
        -: 2742:
        -: 2743:/**
        -: 2744: * Create external string from a valid CESU-8 encoded string.
        -: 2745: * The content of the buffer is assumed be encoded correctly, it's the callers responsibility to
        -: 2746: * validate the input.
        -: 2747: *
        -: 2748: * See also: jerry_validate_string
        -: 2749: *
        -: 2750: * @return created external string
        -: 2751: */
        -: 2752:jerry_value_t
    #####: 2753:jerry_string_external (const jerry_char_t *buffer_p, /**< pointer to string */
        -: 2754:                       jerry_size_t buffer_size, /**< string size */
        -: 2755:                       void *user_p) /**< user pointer passed to the callback when the string is freed */
        -: 2756:{
        -: 2757:  jerry_assert_api_enabled ();
        -: 2758:
    #####: 2759:  JERRY_ASSERT (jerry_validate_string (buffer_p, buffer_size, JERRY_ENCODING_CESU8));
    #####: 2760:  ecma_string_t *ecma_str_p = ecma_new_ecma_external_string_from_cesu8 (buffer_p, buffer_size, user_p);
    #####: 2761:  return ecma_make_string_value (ecma_str_p);
        -: 2762:} /* jerry_string_external_sz_sz */
        -: 2763:
        -: 2764:/**
        -: 2765: * Create symbol with a description value
        -: 2766: *
        -: 2767: * Note: The given argument is converted to string. This operation can throw an exception.
        -: 2768: *
        -: 2769: * @return created symbol,
        -: 2770: *         or thrown exception
        -: 2771: */
        -: 2772:jerry_value_t
    #####: 2773:jerry_symbol_with_description (const jerry_value_t value) /**< api value */
        -: 2774:{
        -: 2775:  jerry_assert_api_enabled ();
        -: 2776:
    #####: 2777:  if (ecma_is_value_exception (value))
        -: 2778:  {
    #####: 2779:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 2780:  }
        -: 2781:
        -: 2782:#if JERRY_ESNEXT
    #####: 2783:  return jerry_return (ecma_op_create_symbol (&value, 1));
        -: 2784:#else /* !JERRY_ESNEXT */
    #####: 2785:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SYMBOL_NOT_SUPPORTED));
        -: 2786:#endif /* JERRY_ESNEXT */
        -: 2787:} /* jerry_symbol_with_description */
        -: 2788:
        -: 2789:/**
        -: 2790: * Create BigInt from a sequence of uint64 digits.
        -: 2791: *
        -: 2792: * Note: This operation can throw an exception.
        -: 2793: *
        -: 2794: * @return created bigint,
        -: 2795: *         or thrown exception
        -: 2796: */
        -: 2797:jerry_value_t
    #####: 2798:jerry_bigint (const uint64_t *digits_p, /**< BigInt digits (lowest digit first) */
        -: 2799:              uint32_t digit_count, /**< number of BigInt digits */
        -: 2800:              bool sign) /**< sign bit, true if the result should be negative */
        -: 2801:{
        -: 2802:  jerry_assert_api_enabled ();
        -: 2803:
        -: 2804:#if JERRY_BUILTIN_BIGINT
    #####: 2805:  return jerry_return (ecma_bigint_create_from_digits (digits_p, digit_count, sign));
        -: 2806:#else /* !JERRY_BUILTIN_BIGINT */
        -: 2807:  JERRY_UNUSED (digits_p);
        -: 2808:  JERRY_UNUSED (digit_count);
        -: 2809:  JERRY_UNUSED (sign);
    #####: 2810:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_BIGINT_NOT_SUPPORTED));
        -: 2811:#endif /* JERRY_BUILTIN_BIGINT */
        -: 2812:} /* jerry_bigint */
        -: 2813:
        -: 2814:/**
        -: 2815: * Creates a RegExp object with the given ASCII pattern and flags.
        -: 2816: *
        -: 2817: * @return value of the constructed RegExp object.
        -: 2818: */
        -: 2819:jerry_value_t
    #####: 2820:jerry_regexp_sz (const char *pattern_p, /**< RegExp pattern as zero-terminated ASCII string */
        -: 2821:                 uint16_t flags) /**< RegExp flags */
        -: 2822:{
        -: 2823:  jerry_assert_api_enabled ();
        -: 2824:
    #####: 2825:  jerry_value_t pattern = jerry_string_sz (pattern_p);
    #####: 2826:  jerry_value_t result = jerry_regexp (pattern, flags);
        -: 2827:
    #####: 2828:  jerry_value_free (pattern);
    #####: 2829:  return jerry_return (result);
        -: 2830:} /* jerry_regexp_sz */
        -: 2831:
        -: 2832:/**
        -: 2833: * Creates a RegExp object with the given pattern and flags.
        -: 2834: *
        -: 2835: * @return value of the constructed RegExp object.
        -: 2836: */
        -: 2837:jerry_value_t
    #####: 2838:jerry_regexp (const jerry_value_t pattern, /**< pattern string */
        -: 2839:              uint16_t flags) /**< RegExp flags */
        -: 2840:{
        -: 2841:  jerry_assert_api_enabled ();
        -: 2842:
        -: 2843:#if JERRY_BUILTIN_REGEXP
    #####: 2844:  if (!ecma_is_value_string (pattern))
        -: 2845:  {
    #####: 2846:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 2847:  }
        -: 2848:
    #####: 2849:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -: 2850:
    #####: 2851:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -: 2852:  {
    #####: 2853:    return ecma_create_exception_from_context ();
        -: 2854:  }
        -: 2855:
    #####: 2856:  jerry_value_t result = ecma_op_create_regexp_with_flags (regexp_obj_p, pattern, flags);
        -: 2857:
    #####: 2858:  return jerry_return (result);
        -: 2859:
        -: 2860:#else /* !JERRY_BUILTIN_REGEXP */
        -: 2861:  JERRY_UNUSED (pattern);
        -: 2862:  JERRY_UNUSED (flags);
        -: 2863:
        -: 2864:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_REGEXP_IS_NOT_SUPPORTED));
        -: 2865:#endif /* JERRY_BUILTIN_REGEXP */
        -: 2866:} /* jerry_regexp */
        -: 2867:
        -: 2868:/**
        -: 2869: * Creates a new realm (global object).
        -: 2870: *
        -: 2871: * @return new realm object
        -: 2872: */
        -: 2873:jerry_value_t
    #####: 2874:jerry_realm (void)
        -: 2875:{
        -: 2876:  jerry_assert_api_enabled ();
        -: 2877:
        -: 2878:#if JERRY_BUILTIN_REALMS
    #####: 2879:  ecma_global_object_t *global_object_p = ecma_builtin_create_global_object ();
    #####: 2880:  return ecma_make_object_value ((ecma_object_t *) global_object_p);
        -: 2881:#else /* !JERRY_BUILTIN_REALMS */
    #####: 2882:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_REALMS_ARE_DISABLED));
        -: 2883:#endif /* JERRY_BUILTIN_REALMS */
        -: 2884:} /* jerry_realm */
        -: 2885:
        -: 2886:/**
        -: 2887: * Get length of an array object
        -: 2888: *
        -: 2889: * Note:
        -: 2890: *      Returns 0, if the value parameter is not an array object.
        -: 2891: *
        -: 2892: * @return length of the given array
        -: 2893: */
        -: 2894:jerry_length_t
    #####: 2895:jerry_array_length (const jerry_value_t value) /**< api value */
        -: 2896:{
        -: 2897:  jerry_assert_api_enabled ();
        -: 2898:
    #####: 2899:  if (!jerry_value_is_object (value))
        -: 2900:  {
    #####: 2901:    return 0;
        -: 2902:  }
        -: 2903:
    #####: 2904:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 2905:
    #####: 2906:  if (JERRY_LIKELY (ecma_get_object_base_type (object_p) == ECMA_OBJECT_BASE_TYPE_ARRAY))
        -: 2907:  {
    #####: 2908:    return ecma_array_get_length (object_p);
        -: 2909:  }
        -: 2910:
    #####: 2911:  return 0;
        -: 2912:} /* jerry_array_length */
        -: 2913:
        -: 2914:/**
        -: 2915: * Get the size of a string value in the specified encoding.
        -: 2916: *
        -: 2917: * @return number of bytes required by the string,
        -: 2918: *         0 - if value is not a string
        -: 2919: */
        -: 2920:jerry_size_t
    #####: 2921:jerry_string_size (const jerry_value_t value, /**< input string */
        -: 2922:                   jerry_encoding_t encoding) /**< encoding */
        -: 2923:{
        -: 2924:  jerry_assert_api_enabled ();
        -: 2925:
    #####: 2926:  if (!ecma_is_value_string (value))
        -: 2927:  {
    #####: 2928:    return 0;
        -: 2929:  }
        -: 2930:
    #####: 2931:  switch (encoding)
        -: 2932:  {
    #####: 2933:    case JERRY_ENCODING_CESU8:
        -: 2934:    {
    #####: 2935:      return ecma_string_get_size (ecma_get_string_from_value (value));
        -: 2936:    }
    #####: 2937:    case JERRY_ENCODING_UTF8:
        -: 2938:    {
    #####: 2939:      return ecma_string_get_utf8_size (ecma_get_string_from_value (value));
        -: 2940:    }
    #####: 2941:    default:
        -: 2942:    {
    #####: 2943:      return 0;
        -: 2944:    }
        -: 2945:  }
        -: 2946:} /* jerry_string_size */
        -: 2947:
        -: 2948:/**
        -: 2949: * Get length of a string value
        -: 2950: *
        -: 2951: * @return number of characters in the string
        -: 2952: *         0 - if value is not a string
        -: 2953: */
        -: 2954:jerry_length_t
    #####: 2955:jerry_string_length (const jerry_value_t value) /**< input string */
        -: 2956:{
        -: 2957:  jerry_assert_api_enabled ();
        -: 2958:
    #####: 2959:  if (!ecma_is_value_string (value))
        -: 2960:  {
    #####: 2961:    return 0;
        -: 2962:  }
        -: 2963:
    #####: 2964:  return ecma_string_get_length (ecma_get_string_from_value (value));
        -: 2965:} /* jerry_string_length */
        -: 2966:
        -: 2967:/**
        -: 2968: * Copy the characters of a string into the specified buffer using the specified encoding.  The string is truncated to
        -: 2969: * fit the buffer. If the value is not a string, nothing will be copied to the buffer.
        -: 2970: *
        -: 2971: * @return number of bytes copied to the buffer
        -: 2972: */
        -: 2973:jerry_size_t
    #####: 2974:jerry_string_to_buffer (const jerry_value_t value, /**< input string value */
        -: 2975:                        jerry_encoding_t encoding, /**< output encoding */
        -: 2976:                        jerry_char_t *buffer_p, /**< [out] output characters buffer */
        -: 2977:                        jerry_size_t buffer_size) /**< size of output buffer */
        -: 2978:{
        -: 2979:  jerry_assert_api_enabled ();
        -: 2980:
    #####: 2981:  if (!ecma_is_value_string (value) || buffer_p == NULL)
        -: 2982:  {
    #####: 2983:    return 0;
        -: 2984:  }
        -: 2985:
    #####: 2986:  ecma_string_t *str_p = ecma_get_string_from_value (value);
        -: 2987:
    #####: 2988:  return ecma_string_copy_to_buffer (str_p, (lit_utf8_byte_t *) buffer_p, buffer_size, encoding);
        -: 2989:} /* jerry_string_to_char_buffer */
        -: 2990:
        -: 2991:/**
        -: 2992: * Create a substring of the input string value.
        -: 2993: * Return an empty string if input value is not a string.
        -: 2994: *
        -: 2995: * @param value  the input string value
        -: 2996: * @param start  start position of the substring
        -: 2997: * @param end    end position of the substring
        -: 2998: *
        -: 2999: * @return created string
        -: 3000: */
        -: 3001:jerry_value_t
    #####: 3002:jerry_string_substr (const jerry_value_t value, jerry_length_t start, jerry_length_t end)
        -: 3003:{
    #####: 3004:  if (!ecma_is_value_string (value))
        -: 3005:  {
    #####: 3006:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 3007:  }
        -: 3008:
    #####: 3009:  return ecma_make_string_value (ecma_string_substr (ecma_get_string_from_value (value), start, end));
        -: 3010:} /* jerry_string_substr */
        -: 3011:
        -: 3012:/**
        -: 3013: * Iterate over the input string value in the specified encoding, visiting each byte of the encoded string once. If
        -: 3014: * the input value is not a string, the function will do nothing.
        -: 3015: *
        -: 3016: * @param value     the input string value
        -: 3017: * @param callback  callback function called for each byte of the encoded string.
        -: 3018: * @param encoding  the requested encoding for the string
        -: 3019: * @param user_p    User pointer passed to the callback function
        -: 3020: */
        -: 3021:void
    #####: 3022:jerry_string_iterate (const jerry_value_t value,
        -: 3023:                      jerry_encoding_t encoding,
        -: 3024:                      jerry_string_iterate_cb_t callback,
        -: 3025:                      void *user_p)
        -: 3026:{
    #####: 3027:  if (!ecma_is_value_string (value))
        -: 3028:  {
    #####: 3029:    return;
        -: 3030:  }
        -: 3031:
    #####: 3032:  ecma_string_t *str_p = ecma_get_string_from_value (value);
    #####: 3033:  ECMA_STRING_TO_UTF8_STRING (str_p, buffer_p, buffer_size);
        -: 3034:
    #####: 3035:  const lit_utf8_byte_t *current_p = buffer_p;
    #####: 3036:  const lit_utf8_byte_t *end_p = buffer_p + buffer_size;
        -: 3037:
    #####: 3038:  switch (encoding)
        -: 3039:  {
    #####: 3040:    case JERRY_ENCODING_UTF8:
        -: 3041:    {
    #####: 3042:      while (current_p < end_p)
        -: 3043:      {
    #####: 3044:        if (JERRY_UNLIKELY (*current_p >= LIT_UTF8_3_BYTE_MARKER))
        -: 3045:        {
    #####: 3046:          lit_code_point_t cp;
    #####: 3047:          lit_utf8_size_t read_size = lit_read_code_point_from_cesu8 (current_p, end_p, &cp);
        -: 3048:
    #####: 3049:          lit_utf8_byte_t bytes[LIT_UTF8_MAX_BYTES_IN_CODE_POINT];
    #####: 3050:          lit_utf8_size_t encoded_size = lit_code_point_to_utf8 (cp, bytes);
        -: 3051:
    #####: 3052:          for (uint32_t i = 0; i < encoded_size; i++)
        -: 3053:          {
    #####: 3054:            callback (bytes[i], user_p);
        -: 3055:          }
        -: 3056:
    #####: 3057:          current_p += read_size;
    #####: 3058:          continue;
        -: 3059:        }
        -: 3060:
    #####: 3061:        callback (*current_p++, user_p);
        -: 3062:      }
        -: 3063:
    #####: 3064:      break;
        -: 3065:    }
    #####: 3066:    case JERRY_ENCODING_CESU8:
        -: 3067:    {
    #####: 3068:      while (current_p < end_p)
        -: 3069:      {
    #####: 3070:        callback (*current_p++, user_p);
        -: 3071:      }
        -: 3072:
    #####: 3073:      break;
        -: 3074:    }
    #####: 3075:    default:
        -: 3076:    {
    #####: 3077:      break;
        -: 3078:    }
        -: 3079:  }
    #####: 3080:  ECMA_FINALIZE_UTF8_STRING (buffer_p, buffer_size);
        -: 3081:} /* jerry_string_iterate */
        -: 3082:
        -: 3083:/**
        -: 3084: * Print char wrapper that casts the argument to an unsigned type
        -: 3085: *
        -: 3086: * @param byte    encoded byte value
        -: 3087: * @param user_p  user pointer
        -: 3088: */
        -: 3089:static void
    #####: 3090:jerry_print_char_wrapper (uint8_t byte, void *user_p)
        -: 3091:{
        -: 3092:  JERRY_UNUSED (user_p);
        -: 3093:  static const char *const null_str_p = "\\u0000";
        -: 3094:
    #####: 3095:  if (JERRY_UNLIKELY (byte == '\0'))
        -: 3096:  {
    #####: 3097:    const char *curr_p = null_str_p;
        -: 3098:
    #####: 3099:    while (*curr_p != '\0')
        -: 3100:    {
    #####: 3101:      jerry_port_print_char (*curr_p++);
        -: 3102:    }
        -: 3103:
    #####: 3104:    return;
        -: 3105:  }
        -: 3106:
    #####: 3107:  jerry_port_print_char ((char) byte);
        -: 3108:} /* jerry_print_char_wrapper */
        -: 3109:
        -: 3110:/**
        -: 3111: * Print the argument string in utf8 encoding using jerry_port_print_char.
        -: 3112: * If the argument is not a string, the function does nothing.
        -: 3113: *
        -: 3114: * @param value  the input string value
        -: 3115: */
        -: 3116:void
    #####: 3117:jerry_string_print (const jerry_value_t value)
        -: 3118:{
    #####: 3119:  jerry_string_iterate (value, JERRY_ENCODING_UTF8, &jerry_print_char_wrapper, NULL);
    #####: 3120:} /* jerry_string_print */
        -: 3121:
        -: 3122:/**
        -: 3123: * Sets the global callback which is called when an external string is freed.
        -: 3124: */
        -: 3125:void
    #####: 3126:jerry_string_external_on_free (jerry_external_string_free_cb_t callback) /**< free callback */
        -: 3127:{
    #####: 3128:  JERRY_CONTEXT (external_string_free_callback_p) = callback;
    #####: 3129:} /* jerry_string_external_on_free */
        -: 3130:
        -: 3131:/**
        -: 3132: * Returns the user pointer assigned to an external string.
        -: 3133: *
        -: 3134: * @return user pointer, if value is an external string
        -: 3135: *         NULL, otherwise
        -: 3136: */
        -: 3137:void *
    #####: 3138:jerry_string_user_ptr (const jerry_value_t value, /**< string value */
        -: 3139:                       bool *is_external) /**< [out] true - if value is an external string,
        -: 3140:                                           *         false - otherwise */
        -: 3141:{
    #####: 3142:  if (is_external != NULL)
        -: 3143:  {
    #####: 3144:    *is_external = false;
        -: 3145:  }
        -: 3146:
    #####: 3147:  if (!ecma_is_value_string (value))
        -: 3148:  {
    #####: 3149:    return NULL;
        -: 3150:  }
        -: 3151:
    #####: 3152:  ecma_string_t *string_p = ecma_get_string_from_value (value);
        -: 3153:
    #####: 3154:  if (ECMA_IS_DIRECT_STRING (string_p)
    #####: 3155:      || ECMA_STRING_GET_CONTAINER (string_p) != ECMA_STRING_CONTAINER_LONG_OR_EXTERNAL_STRING)
        -: 3156:  {
    #####: 3157:    return NULL;
        -: 3158:  }
        -: 3159:
    #####: 3160:  ecma_long_string_t *long_string_p = (ecma_long_string_t *) string_p;
        -: 3161:
    #####: 3162:  if (long_string_p->string_p == ECMA_LONG_STRING_BUFFER_START (long_string_p))
        -: 3163:  {
    #####: 3164:    return NULL;
        -: 3165:  }
        -: 3166:
    #####: 3167:  if (is_external != NULL)
        -: 3168:  {
    #####: 3169:    *is_external = true;
        -: 3170:  }
        -: 3171:
    #####: 3172:  return ((ecma_external_string_t *) string_p)->user_p;
        -: 3173:} /* jerry_string_user_ptr */
        -: 3174:
        -: 3175:/**
        -: 3176: * Checks whether the object or it's prototype objects have the given property.
        -: 3177: *
        -: 3178: * @return raised error - if the operation fail
        -: 3179: *         true/false API value  - depend on whether the property exists
        -: 3180: */
        -: 3181:jerry_value_t
    #####: 3182:jerry_object_has (const jerry_value_t object, /**< object value */
        -: 3183:                  const jerry_value_t key) /**< property name (string value) */
        -: 3184:{
        -: 3185:  jerry_assert_api_enabled ();
        -: 3186:
    #####: 3187:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3188:  {
    #####: 3189:    return ECMA_VALUE_FALSE;
        -: 3190:  }
        -: 3191:
    #####: 3192:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 3193:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (key);
        -: 3194:
    #####: 3195:  return jerry_return (ecma_op_object_has_property (obj_p, prop_name_p));
        -: 3196:} /* jerry_object_has */
        -: 3197:
        -: 3198:/**
        -: 3199: * Checks whether the object has the given property.
        -: 3200: *
        -: 3201: * @return ECMA_VALUE_ERROR - if the operation raises error
        -: 3202: *         ECMA_VALUE_{TRUE, FALSE} - based on whether the property exists
        -: 3203: */
        -: 3204:jerry_value_t
    #####: 3205:jerry_object_has_own (const jerry_value_t object, /**< object value */
        -: 3206:                      const jerry_value_t key) /**< property name (string value) */
        -: 3207:{
        -: 3208:  jerry_assert_api_enabled ();
        -: 3209:
    #####: 3210:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3211:  {
    #####: 3212:    return ECMA_VALUE_FALSE;
        -: 3213:  }
        -: 3214:
    #####: 3215:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 3216:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (key);
        -: 3217:
    #####: 3218:  return jerry_return (ecma_op_object_has_own_property (obj_p, prop_name_p));
        -: 3219:} /* jerry_has_own_property */
        -: 3220:
        -: 3221:/**
        -: 3222: * Checks whether the object has the given internal property.
        -: 3223: *
        -: 3224: * @return true  - if the internal property exists
        -: 3225: *         false - otherwise
        -: 3226: */
        -: 3227:bool
    #####: 3228:jerry_object_has_internal (const jerry_value_t object, /**< object value */
        -: 3229:                           const jerry_value_t key) /**< property name value */
        -: 3230:{
        -: 3231:  jerry_assert_api_enabled ();
        -: 3232:
    #####: 3233:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3234:  {
    #####: 3235:    return false;
        -: 3236:  }
        -: 3237:
    #####: 3238:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 3239:
    #####: 3240:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3241:
    #####: 3242:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3243:  {
    #####: 3244:    return false;
        -: 3245:  }
        -: 3246:
    #####: 3247:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3248:
    #####: 3249:  if (property_p == NULL)
        -: 3250:  {
    #####: 3251:    return false;
        -: 3252:  }
        -: 3253:
    #####: 3254:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3255:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (key));
        -: 3256:
    #####: 3257:  return property_p != NULL;
        -: 3258:} /* jerry_object_has_internal */
        -: 3259:
        -: 3260:/**
        -: 3261: * Delete a property from an object.
        -: 3262: *
        -: 3263: * @return boolean value - wether the property was deleted successfully
        -: 3264: *         exception - otherwise
        -: 3265: */
        -: 3266:jerry_value_t
    #####: 3267:jerry_object_delete (const jerry_value_t object, /**< object value */
        -: 3268:                     const jerry_value_t key) /**< property name (string value) */
        -: 3269:{
        -: 3270:  jerry_assert_api_enabled ();
        -: 3271:
    #####: 3272:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3273:  {
    #####: 3274:    return false;
        -: 3275:  }
        -: 3276:
    #####: 3277:  return ecma_op_object_delete (ecma_get_object_from_value (object), ecma_get_prop_name_from_value (key), false);
        -: 3278:} /* jerry_object_delete */
        -: 3279:
        -: 3280:/**
        -: 3281: * Delete indexed property from the specified object.
        -: 3282: *
        -: 3283: * @return boolean value - wether the property was deleted successfully
        -: 3284: *         false - otherwise
        -: 3285: */
        -: 3286:jerry_value_t
    #####: 3287:jerry_object_delete_index (const jerry_value_t object, /**< object value */
        -: 3288:                           uint32_t index) /**< index to be written */
        -: 3289:{
        -: 3290:  jerry_assert_api_enabled ();
        -: 3291:
    #####: 3292:  if (!ecma_is_value_object (object))
        -: 3293:  {
    #####: 3294:    return false;
        -: 3295:  }
        -: 3296:
    #####: 3297:  ecma_string_t *str_idx_p = ecma_new_ecma_string_from_uint32 (index);
    #####: 3298:  ecma_value_t ret_value = ecma_op_object_delete (ecma_get_object_from_value (object), str_idx_p, false);
    #####: 3299:  ecma_deref_ecma_string (str_idx_p);
        -: 3300:
    #####: 3301:  return ret_value;
        -: 3302:} /* jerry_object_delete_index */
        -: 3303:
        -: 3304:/**
        -: 3305: * Delete an internal property from an object.
        -: 3306: *
        -: 3307: * @return true  - if property was deleted successfully
        -: 3308: *         false - otherwise
        -: 3309: */
        -: 3310:bool
    #####: 3311:jerry_object_delete_internal (const jerry_value_t object, /**< object value */
        -: 3312:                              const jerry_value_t key) /**< property name value */
        -: 3313:{
        -: 3314:  jerry_assert_api_enabled ();
        -: 3315:
    #####: 3316:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3317:  {
    #####: 3318:    return false;
        -: 3319:  }
        -: 3320:
    #####: 3321:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 3322:
    #####: 3323:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3324:
    #####: 3325:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3326:  {
    #####: 3327:    return true;
        -: 3328:  }
        -: 3329:
    #####: 3330:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3331:
    #####: 3332:  if (property_p == NULL)
        -: 3333:  {
    #####: 3334:    return true;
        -: 3335:  }
        -: 3336:
    #####: 3337:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3338:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (key));
        -: 3339:
    #####: 3340:  if (property_p == NULL)
        -: 3341:  {
    #####: 3342:    return true;
        -: 3343:  }
        -: 3344:
    #####: 3345:  ecma_delete_property (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p));
        -: 3346:
    #####: 3347:  return true;
        -: 3348:} /* jerry_object_delete_internal */
        -: 3349:
        -: 3350:/**
        -: 3351: * Get value of a property to the specified object with the given name.
        -: 3352: *
        -: 3353: * Note:
        -: 3354: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3355: *
        -: 3356: * @return value of the property - if success
        -: 3357: *         value marked with error flag - otherwise
        -: 3358: */
        -: 3359:jerry_value_t
    #####: 3360:jerry_object_get (const jerry_value_t object, /**< object value */
        -: 3361:                  const jerry_value_t key) /**< property name (string value) */
        -: 3362:{
        -: 3363:  jerry_assert_api_enabled ();
        -: 3364:
    #####: 3365:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3366:  {
    #####: 3367:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3368:  }
        -: 3369:
    #####: 3370:  jerry_value_t ret_value =
    #####: 3371:    ecma_op_object_get (ecma_get_object_from_value (object), ecma_get_prop_name_from_value (key));
    #####: 3372:  return jerry_return (ret_value);
        -: 3373:} /* jerry_object_get */
        -: 3374:
        -: 3375:/**
        -: 3376: * Get value by an index from the specified object.
        -: 3377: *
        -: 3378: * Note:
        -: 3379: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3380: *
        -: 3381: * @return value of the property specified by the index - if success
        -: 3382: *         value marked with error flag - otherwise
        -: 3383: */
        -: 3384:jerry_value_t
    #####: 3385:jerry_object_get_index (const jerry_value_t object, /**< object value */
        -: 3386:                        uint32_t index) /**< index to be written */
        -: 3387:{
        -: 3388:  jerry_assert_api_enabled ();
        -: 3389:
    #####: 3390:  if (!ecma_is_value_object (object))
        -: 3391:  {
    #####: 3392:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3393:  }
        -: 3394:
    #####: 3395:  ecma_value_t ret_value = ecma_op_object_get_by_index (ecma_get_object_from_value (object), index);
        -: 3396:
    #####: 3397:  return jerry_return (ret_value);
        -: 3398:} /* jerry_object_get_index */
        -: 3399:
        -: 3400:/**
        -: 3401: * Get the own property value of an object with the given name.
        -: 3402: *
        -: 3403: * Note:
        -: 3404: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3405: *
        -: 3406: * @return value of the property - if success
        -: 3407: *         value marked with error flag - otherwise
        -: 3408: */
        -: 3409:jerry_value_t
    #####: 3410:jerry_object_find_own (const jerry_value_t object, /**< object value */
        -: 3411:                       const jerry_value_t key, /**< property name (string value) */
        -: 3412:                       const jerry_value_t receiver, /**< receiver object value */
        -: 3413:                       bool *found_p) /**< [out] true, if the property is found
        -: 3414:                                       *   or object is a Proxy object, false otherwise */
        -: 3415:{
        -: 3416:  jerry_assert_api_enabled ();
        -: 3417:
    #####: 3418:  if (found_p != NULL)
        -: 3419:  {
    #####: 3420:    *found_p = false;
        -: 3421:  }
        -: 3422:
    #####: 3423:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key) || !ecma_is_value_object (receiver))
        -: 3424:  {
    #####: 3425:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3426:  }
        -: 3427:
    #####: 3428:  ecma_object_t *object_p = ecma_get_object_from_value (object);
    #####: 3429:  ecma_string_t *property_name_p = ecma_get_prop_name_from_value (key);
        -: 3430:
        -: 3431:#if JERRY_BUILTIN_PROXY
    #####: 3432:  if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 3433:  {
    #####: 3434:    if (found_p != NULL)
        -: 3435:    {
    #####: 3436:      *found_p = true;
        -: 3437:    }
        -: 3438:
    #####: 3439:    return jerry_return (ecma_proxy_object_get (object_p, property_name_p, receiver));
        -: 3440:  }
        -: 3441:#endif /* JERRY_BUILTIN_PROXY */
        -: 3442:
    #####: 3443:  ecma_value_t ret_value = ecma_op_object_find_own (receiver, object_p, property_name_p);
        -: 3444:
    #####: 3445:  if (ecma_is_value_found (ret_value))
        -: 3446:  {
    #####: 3447:    if (found_p != NULL)
        -: 3448:    {
    #####: 3449:      *found_p = true;
        -: 3450:    }
        -: 3451:
    #####: 3452:    return jerry_return (ret_value);
        -: 3453:  }
        -: 3454:
    #####: 3455:  return ECMA_VALUE_UNDEFINED;
        -: 3456:} /* jerry_object_find_own */
        -: 3457:
        -: 3458:/**
        -: 3459: * Get value of an internal property to the specified object with the given name.
        -: 3460: *
        -: 3461: * Note:
        -: 3462: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3463: *
        -: 3464: * @return value of the internal property - if the internal property exists
        -: 3465: *         undefined value - if the internal does not property exists
        -: 3466: *         value marked with error flag - otherwise
        -: 3467: */
        -: 3468:jerry_value_t
    #####: 3469:jerry_object_get_internal (const jerry_value_t object, /**< object value */
        -: 3470:                           const jerry_value_t key) /**< property name value */
        -: 3471:{
        -: 3472:  jerry_assert_api_enabled ();
        -: 3473:
    #####: 3474:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3475:  {
    #####: 3476:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3477:  }
        -: 3478:
    #####: 3479:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 3480:
    #####: 3481:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3482:
    #####: 3483:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3484:  {
    #####: 3485:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3486:  }
        -: 3487:
    #####: 3488:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3489:
    #####: 3490:  if (property_p == NULL)
        -: 3491:  {
    #####: 3492:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3493:  }
        -: 3494:
    #####: 3495:  ecma_object_t *internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
    #####: 3496:  property_p = ecma_find_named_property (internal_object_p, ecma_get_prop_name_from_value (key));
        -: 3497:
    #####: 3498:  if (property_p == NULL)
        -: 3499:  {
    #####: 3500:    return jerry_return (ECMA_VALUE_UNDEFINED);
        -: 3501:  }
        -: 3502:
    #####: 3503:  return jerry_return (ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value));
        -: 3504:} /* jerry_object_get_internal */
        -: 3505:
        -: 3506:/**
        -: 3507: * Set a property to the specified object with the given name.
        -: 3508: *
        -: 3509: * Note:
        -: 3510: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3511: *
        -: 3512: * @return true value - if the operation was successful
        -: 3513: *         value marked with error flag - otherwise
        -: 3514: */
        -: 3515:jerry_value_t
        5: 3516:jerry_object_set (const jerry_value_t object, /**< object value */
        -: 3517:                  const jerry_value_t key, /**< property name (string value) */
        -: 3518:                  const jerry_value_t value) /**< value to set */
        -: 3519:{
        -: 3520:  jerry_assert_api_enabled ();
        -: 3521:
        5: 3522:  if (ecma_is_value_exception (value) || !ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3523:  {
    #####: 3524:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3525:  }
        -: 3526:
        5: 3527:  return jerry_return (
        -: 3528:    ecma_op_object_put (ecma_get_object_from_value (object), ecma_get_prop_name_from_value (key), value, true));
        -: 3529:} /* jerry_object_set */
        -: 3530:
        -: 3531:/**
        -: 3532: * Set indexed value in the specified object
        -: 3533: *
        -: 3534: * Note:
        -: 3535: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3536: *
        -: 3537: * @return true value - if the operation was successful
        -: 3538: *         value marked with error flag - otherwise
        -: 3539: */
        -: 3540:jerry_value_t
    #####: 3541:jerry_object_set_index (const jerry_value_t object, /**< object value */
        -: 3542:                        uint32_t index, /**< index to be written */
        -: 3543:                        const jerry_value_t value) /**< value to set */
        -: 3544:{
        -: 3545:  jerry_assert_api_enabled ();
        -: 3546:
    #####: 3547:  if (ecma_is_value_exception (value) || !ecma_is_value_object (object))
        -: 3548:  {
    #####: 3549:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3550:  }
        -: 3551:
    #####: 3552:  ecma_value_t ret_value = ecma_op_object_put_by_index (ecma_get_object_from_value (object), index, value, true);
        -: 3553:
    #####: 3554:  return jerry_return (ret_value);
        -: 3555:} /* jerry_object_set_index */
        -: 3556:
        -: 3557:/**
        -: 3558: * Set an internal property to the specified object with the given name.
        -: 3559: *
        -: 3560: * Note:
        -: 3561: *      - the property cannot be accessed from the JavaScript context, only from the public API
        -: 3562: *      - returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3563: *
        -: 3564: * @return true value - if the operation was successful
        -: 3565: *         value marked with error flag - otherwise
        -: 3566: */
        -: 3567:bool
    #####: 3568:jerry_object_set_internal (const jerry_value_t object, /**< object value */
        -: 3569:                           const jerry_value_t key, /**< property name value */
        -: 3570:                           const jerry_value_t value) /**< value to set */
        -: 3571:{
        -: 3572:  jerry_assert_api_enabled ();
        -: 3573:
    #####: 3574:  if (ecma_is_value_exception (value) || !ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3575:  {
    #####: 3576:    return false;
        -: 3577:  }
        -: 3578:
    #####: 3579:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 3580:
    #####: 3581:  ecma_string_t *internal_string_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_API_INTERNAL);
        -: 3582:
    #####: 3583:  if (ecma_op_object_is_fast_array (obj_p))
        -: 3584:  {
    #####: 3585:    ecma_fast_array_convert_to_normal (obj_p);
        -: 3586:  }
        -: 3587:
    #####: 3588:  ecma_property_t *property_p = ecma_find_named_property (obj_p, internal_string_p);
        -: 3589:  ecma_object_t *internal_object_p;
        -: 3590:
    #####: 3591:  if (property_p == NULL)
        -: 3592:  {
    #####: 3593:    ecma_property_value_t *value_p =
        -: 3594:      ecma_create_named_data_property (obj_p, internal_string_p, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE, NULL);
        -: 3595:
    #####: 3596:    internal_object_p = ecma_create_object (NULL, sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -: 3597:    {
    #####: 3598:      ecma_extended_object_t *container_p = (ecma_extended_object_t *) internal_object_p;
    #####: 3599:      container_p->u.cls.type = ECMA_OBJECT_CLASS_INTERNAL_OBJECT;
        -: 3600:    }
        -: 3601:
    #####: 3602:    value_p->value = ecma_make_object_value (internal_object_p);
    #####: 3603:    ecma_deref_object (internal_object_p);
        -: 3604:  }
        -: 3605:  else
        -: 3606:  {
    #####: 3607:    internal_object_p = ecma_get_object_from_value (ECMA_PROPERTY_VALUE_PTR (property_p)->value);
        -: 3608:  }
        -: 3609:
    #####: 3610:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (key);
    #####: 3611:  property_p = ecma_find_named_property (internal_object_p, prop_name_p);
        -: 3612:
    #####: 3613:  if (property_p == NULL)
        -: 3614:  {
    #####: 3615:    ecma_property_value_t *value_p = ecma_create_named_data_property (internal_object_p,
        -: 3616:                                                                      prop_name_p,
        -: 3617:                                                                      ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -: 3618:                                                                      NULL);
        -: 3619:
    #####: 3620:    value_p->value = ecma_copy_value_if_not_object (value);
        -: 3621:  }
        -: 3622:  else
        -: 3623:  {
    #####: 3624:    ecma_named_data_property_assign_value (internal_object_p, ECMA_PROPERTY_VALUE_PTR (property_p), value);
        -: 3625:  }
        -: 3626:
    #####: 3627:  return true;
        -: 3628:} /* jerry_object_set_internal */
        -: 3629:
        -: 3630:/**
        -: 3631: * Construct empty property descriptor, i.e.:
        -: 3632: *  property descriptor with all is_defined flags set to false and the rest - to default value.
        -: 3633: *
        -: 3634: * @return empty property descriptor
        -: 3635: */
        -: 3636:jerry_property_descriptor_t
    #####: 3637:jerry_property_descriptor (void)
        -: 3638:{
        -: 3639:  jerry_property_descriptor_t prop_desc;
        -: 3640:
    #####: 3641:  prop_desc.flags = JERRY_PROP_NO_OPTS;
    #####: 3642:  prop_desc.value = ECMA_VALUE_UNDEFINED;
    #####: 3643:  prop_desc.getter = ECMA_VALUE_UNDEFINED;
    #####: 3644:  prop_desc.setter = ECMA_VALUE_UNDEFINED;
        -: 3645:
    #####: 3646:  return prop_desc;
        -: 3647:} /* jerry_property_descriptor */
        -: 3648:
        -: 3649:/**
        -: 3650: * Convert a ecma_property_descriptor_t to a jerry_property_descriptor_t
        -: 3651: *
        -: 3652: * if error occurs the property descriptor's value field is filled with ECMA_VALUE_ERROR
        -: 3653: *
        -: 3654: * @return jerry_property_descriptor_t
        -: 3655: */
        -: 3656:static jerry_property_descriptor_t
    #####: 3657:jerry_property_descriptor_from_ecma (const ecma_property_descriptor_t *prop_desc_p) /**<[out] property_descriptor */
        -: 3658:{
    #####: 3659:  jerry_property_descriptor_t prop_desc = jerry_property_descriptor ();
        -: 3660:
    #####: 3661:  prop_desc.flags = prop_desc_p->flags;
        -: 3662:
    #####: 3663:  if (prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED))
        -: 3664:  {
    #####: 3665:    prop_desc.value = prop_desc_p->value;
        -: 3666:  }
        -: 3667:
    #####: 3668:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3669:  {
    #####: 3670:    prop_desc.getter = ECMA_VALUE_NULL;
        -: 3671:
    #####: 3672:    if (prop_desc_p->get_p != NULL)
        -: 3673:    {
    #####: 3674:      prop_desc.getter = ecma_make_object_value (prop_desc_p->get_p);
    #####: 3675:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.getter));
        -: 3676:    }
        -: 3677:  }
        -: 3678:
    #####: 3679:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3680:  {
    #####: 3681:    prop_desc.setter = ECMA_VALUE_NULL;
        -: 3682:
    #####: 3683:    if (prop_desc_p->set_p != NULL)
        -: 3684:    {
    #####: 3685:      prop_desc.setter = ecma_make_object_value (prop_desc_p->set_p);
    #####: 3686:      JERRY_ASSERT (ecma_op_is_callable (prop_desc.setter));
        -: 3687:    }
        -: 3688:  }
        -: 3689:
    #####: 3690:  return prop_desc;
        -: 3691:} /* jerry_property_descriptor_from_ecma */
        -: 3692:
        -: 3693:/**
        -: 3694: * Convert a jerry_property_descriptor_t to a ecma_property_descriptor_t
        -: 3695: *
        -: 3696: * Note:
        -: 3697: *     if error occurs the property descriptor's value field
        -: 3698: *     is set to ECMA_VALUE_ERROR, but no error is thrown
        -: 3699: *
        -: 3700: * @return ecma_property_descriptor_t
        -: 3701: */
        -: 3702:static ecma_property_descriptor_t
    #####: 3703:jerry_property_descriptor_to_ecma (const jerry_property_descriptor_t *prop_desc_p) /**< input property_descriptor */
        -: 3704:{
    #####: 3705:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -: 3706:
    #####: 3707:  prop_desc.flags = prop_desc_p->flags;
        -: 3708:
        -: 3709:  /* Copy data property info. */
    #####: 3710:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3711:  {
    #####: 3712:    if (ecma_is_value_exception (prop_desc_p->value)
    #####: 3713:        || (prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)))
        -: 3714:    {
    #####: 3715:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3716:      return prop_desc;
        -: 3717:    }
        -: 3718:
    #####: 3719:    prop_desc.value = prop_desc_p->value;
        -: 3720:  }
        -: 3721:
        -: 3722:  /* Copy accessor property info. */
    #####: 3723:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3724:  {
    #####: 3725:    ecma_value_t getter = prop_desc_p->getter;
        -: 3726:
    #####: 3727:    if (ecma_is_value_exception (getter))
        -: 3728:    {
    #####: 3729:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3730:      return prop_desc;
        -: 3731:    }
        -: 3732:
    #####: 3733:    if (ecma_op_is_callable (getter))
        -: 3734:    {
    #####: 3735:      prop_desc.get_p = ecma_get_object_from_value (getter);
        -: 3736:    }
    #####: 3737:    else if (!ecma_is_value_null (getter))
        -: 3738:    {
    #####: 3739:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3740:      return prop_desc;
        -: 3741:    }
        -: 3742:  }
        -: 3743:
    #####: 3744:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3745:  {
    #####: 3746:    ecma_value_t setter = prop_desc_p->setter;
        -: 3747:
    #####: 3748:    if (ecma_is_value_exception (setter))
        -: 3749:    {
    #####: 3750:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3751:      return prop_desc;
        -: 3752:    }
        -: 3753:
    #####: 3754:    if (ecma_op_is_callable (setter))
        -: 3755:    {
    #####: 3756:      prop_desc.set_p = ecma_get_object_from_value (setter);
        -: 3757:    }
    #####: 3758:    else if (!ecma_is_value_null (setter))
        -: 3759:    {
    #####: 3760:      prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3761:      return prop_desc;
        -: 3762:    }
        -: 3763:  }
        -: 3764:
    #####: 3765:  const uint16_t configurable_mask = JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_CONFIGURABLE_DEFINED;
    #####: 3766:  const uint16_t enumerable_mask = JERRY_PROP_IS_ENUMERABLE | JERRY_PROP_IS_ENUMERABLE_DEFINED;
    #####: 3767:  const uint16_t writable_mask = JERRY_PROP_IS_WRITABLE | JERRY_PROP_IS_WRITABLE_DEFINED;
        -: 3768:
    #####: 3769:  if ((prop_desc_p->flags & configurable_mask) == JERRY_PROP_IS_CONFIGURABLE
    #####: 3770:      || (prop_desc_p->flags & enumerable_mask) == JERRY_PROP_IS_ENUMERABLE
    #####: 3771:      || (prop_desc_p->flags & writable_mask) == JERRY_PROP_IS_WRITABLE)
        -: 3772:  {
    #####: 3773:    prop_desc.value = ECMA_VALUE_ERROR;
    #####: 3774:    return prop_desc;
        -: 3775:  }
        -: 3776:
    #####: 3777:  prop_desc.flags |= (uint16_t) (prop_desc_p->flags | JERRY_PROP_SHOULD_THROW);
        -: 3778:
    #####: 3779:  return prop_desc;
        -: 3780:} /* jerry_property_descriptor_to_ecma */
        -: 3781:
        -: 3782:/** Helper function to return false value or error depending on the given flag.
        -: 3783: *
        -: 3784: * @return value marked with error flag - if is_throw is true
        -: 3785: *         false value - otherwise
        -: 3786: */
        -: 3787:static jerry_value_t
    #####: 3788:jerry_type_error_or_false (ecma_error_msg_t msg, /**< message */
        -: 3789:                           uint16_t flags) /**< property descriptor flags */
        -: 3790:{
    #####: 3791:  if (!(flags & JERRY_PROP_SHOULD_THROW))
        -: 3792:  {
    #####: 3793:    return ECMA_VALUE_FALSE;
        -: 3794:  }
        -: 3795:
    #####: 3796:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (msg));
        -: 3797:} /* jerry_type_error_or_false */
        -: 3798:
        -: 3799:/**
        -: 3800: * Define a property to the specified object with the given name.
        -: 3801: *
        -: 3802: * Note:
        -: 3803: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3804: *
        -: 3805: * @return true value - if the operation was successful
        -: 3806: *         false value - if the property cannot be defined and JERRY_PROP_SHOULD_THROW is not set
        -: 3807: *         value marked with error flag - otherwise
        -: 3808: */
        -: 3809:jerry_value_t
    #####: 3810:jerry_object_define_own_prop (const jerry_value_t object, /**< object value */
        -: 3811:                              const jerry_value_t key, /**< property name (string value) */
        -: 3812:                              const jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3813:{
        -: 3814:  jerry_assert_api_enabled ();
        -: 3815:
    #####: 3816:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3817:  {
    #####: 3818:    return jerry_type_error_or_false (ECMA_ERR_WRONG_ARGS_MSG, prop_desc_p->flags);
        -: 3819:  }
        -: 3820:
    #####: 3821:  if (prop_desc_p->flags & (JERRY_PROP_IS_WRITABLE_DEFINED | JERRY_PROP_IS_VALUE_DEFINED)
    #####: 3822:      && prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -: 3823:  {
    #####: 3824:    return jerry_type_error_or_false (ECMA_ERR_WRONG_ARGS_MSG, prop_desc_p->flags);
        -: 3825:  }
        -: 3826:
    #####: 3827:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (prop_desc_p);
        -: 3828:
    #####: 3829:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 3830:  {
    #####: 3831:    return jerry_type_error_or_false (ECMA_ERR_WRONG_ARGS_MSG, prop_desc_p->flags);
        -: 3832:  }
        -: 3833:
    #####: 3834:  return jerry_return (ecma_op_object_define_own_property (ecma_get_object_from_value (object),
        -: 3835:                                                           ecma_get_prop_name_from_value (key),
        -: 3836:                                                           &prop_desc));
        -: 3837:} /* jerry_object_define_own_prop */
        -: 3838:
        -: 3839:/**
        -: 3840: * Construct property descriptor from specified property.
        -: 3841: *
        -: 3842: * @return true - if success, the prop_desc_p fields contains the property info
        -: 3843: *         false - otherwise, the prop_desc_p is unchanged
        -: 3844: */
        -: 3845:jerry_value_t
    #####: 3846:jerry_object_get_own_prop (const jerry_value_t object, /**< object value */
        -: 3847:                           const jerry_value_t key, /**< property name (string value) */
        -: 3848:                           jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3849:{
        -: 3850:  jerry_assert_api_enabled ();
        -: 3851:
    #####: 3852:  if (!ecma_is_value_object (object) || !ecma_is_value_prop_name (key))
        -: 3853:  {
    #####: 3854:    return ECMA_VALUE_FALSE;
        -: 3855:  }
        -: 3856:
    #####: 3857:  ecma_property_descriptor_t prop_desc;
        -: 3858:
    #####: 3859:  ecma_value_t status = ecma_op_object_get_own_property_descriptor (ecma_get_object_from_value (object),
        -: 3860:                                                                    ecma_get_prop_name_from_value (key),
        -: 3861:                                                                    &prop_desc);
        -: 3862:
        -: 3863:#if JERRY_BUILTIN_PROXY
    #####: 3864:  if (ECMA_IS_VALUE_ERROR (status))
        -: 3865:  {
    #####: 3866:    return ecma_create_exception_from_context ();
        -: 3867:  }
        -: 3868:#endif /* JERRY_BUILTIN_PROXY */
        -: 3869:
    #####: 3870:  if (!ecma_is_value_true (status))
        -: 3871:  {
    #####: 3872:    return ECMA_VALUE_FALSE;
        -: 3873:  }
        -: 3874:
        -: 3875:  /* The flags are always filled in the returned descriptor. */
    #####: 3876:  JERRY_ASSERT (
        -: 3877:    (prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE_DEFINED) && (prop_desc.flags & JERRY_PROP_IS_ENUMERABLE_DEFINED)
        -: 3878:    && ((prop_desc.flags & JERRY_PROP_IS_WRITABLE_DEFINED) || !(prop_desc.flags & JERRY_PROP_IS_VALUE_DEFINED)));
        -: 3879:
    #####: 3880:  prop_desc_p->flags = prop_desc.flags;
    #####: 3881:  prop_desc_p->value = ECMA_VALUE_UNDEFINED;
    #####: 3882:  prop_desc_p->getter = ECMA_VALUE_UNDEFINED;
    #####: 3883:  prop_desc_p->setter = ECMA_VALUE_UNDEFINED;
        -: 3884:
    #####: 3885:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3886:  {
    #####: 3887:    prop_desc_p->value = prop_desc.value;
        -: 3888:  }
        -: 3889:
    #####: 3890:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3891:  {
    #####: 3892:    if (prop_desc.get_p != NULL)
        -: 3893:    {
    #####: 3894:      prop_desc_p->getter = ecma_make_object_value (prop_desc.get_p);
        -: 3895:    }
        -: 3896:    else
        -: 3897:    {
    #####: 3898:      prop_desc_p->getter = ECMA_VALUE_NULL;
        -: 3899:    }
        -: 3900:  }
        -: 3901:
    #####: 3902:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3903:  {
    #####: 3904:    if (prop_desc.set_p != NULL)
        -: 3905:    {
    #####: 3906:      prop_desc_p->setter = ecma_make_object_value (prop_desc.set_p);
        -: 3907:    }
        -: 3908:    else
        -: 3909:    {
    #####: 3910:      prop_desc_p->setter = ECMA_VALUE_NULL;
        -: 3911:    }
        -: 3912:  }
        -: 3913:
    #####: 3914:  return ECMA_VALUE_TRUE;
        -: 3915:} /* jerry_object_get_own_prop */
        -: 3916:
        -: 3917:/**
        -: 3918: * Free fields of property descriptor (setter, getter and value).
        -: 3919: */
        -: 3920:void
    #####: 3921:jerry_property_descriptor_free (jerry_property_descriptor_t *prop_desc_p) /**< property descriptor */
        -: 3922:{
    #####: 3923:  if (prop_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -: 3924:  {
    #####: 3925:    jerry_value_free (prop_desc_p->value);
        -: 3926:  }
        -: 3927:
    #####: 3928:  if (prop_desc_p->flags & JERRY_PROP_IS_GET_DEFINED)
        -: 3929:  {
    #####: 3930:    jerry_value_free (prop_desc_p->getter);
        -: 3931:  }
        -: 3932:
    #####: 3933:  if (prop_desc_p->flags & JERRY_PROP_IS_SET_DEFINED)
        -: 3934:  {
    #####: 3935:    jerry_value_free (prop_desc_p->setter);
        -: 3936:  }
    #####: 3937:} /* jerry_property_descriptor_free */
        -: 3938:
        -: 3939:/**
        -: 3940: * Call function specified by a function value
        -: 3941: *
        -: 3942: * Note:
        -: 3943: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3944: *      error flag must not be set for any arguments of this function.
        -: 3945: *
        -: 3946: * @return returned jerry value of the called function
        -: 3947: */
        -: 3948:jerry_value_t
    #####: 3949:jerry_call (const jerry_value_t func_object, /**< function object to call */
        -: 3950:            const jerry_value_t this_value, /**< object for 'this' binding */
        -: 3951:            const jerry_value_t *args_p, /**< function's call arguments */
        -: 3952:            jerry_size_t args_count) /**< number of the arguments */
        -: 3953:{
        -: 3954:  jerry_assert_api_enabled ();
        -: 3955:
    #####: 3956:  if (ecma_is_value_exception (this_value))
        -: 3957:  {
    #####: 3958:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3959:  }
        -: 3960:
    #####: 3961:  for (jerry_size_t i = 0; i < args_count; i++)
        -: 3962:  {
    #####: 3963:    if (ecma_is_value_exception (args_p[i]))
        -: 3964:    {
    #####: 3965:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 3966:    }
        -: 3967:  }
        -: 3968:
    #####: 3969:  return jerry_return (ecma_op_function_validated_call (func_object, this_value, args_p, args_count));
        -: 3970:} /* jerry_call */
        -: 3971:
        -: 3972:/**
        -: 3973: * Construct object value invoking specified function value as a constructor
        -: 3974: *
        -: 3975: * Note:
        -: 3976: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 3977: *      error flag must not be set for any arguments of this function.
        -: 3978: *
        -: 3979: * @return returned jerry value of the invoked constructor
        -: 3980: */
        -: 3981:jerry_value_t
    #####: 3982:jerry_construct (const jerry_value_t func_object, /**< function object to call */
        -: 3983:                 const jerry_value_t *args_p, /**< function's call arguments
        -: 3984:                                               *   (NULL if arguments number is zero) */
        -: 3985:                 jerry_size_t args_count) /**< number of the arguments */
        -: 3986:{
        -: 3987:  jerry_assert_api_enabled ();
        -: 3988:
    #####: 3989:  if (!jerry_value_is_constructor (func_object))
        -: 3990:  {
    #####: 3991:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 3992:  }
        -: 3993:
    #####: 3994:  for (jerry_size_t i = 0; i < args_count; i++)
        -: 3995:  {
    #####: 3996:    if (ecma_is_value_exception (args_p[i]))
        -: 3997:    {
    #####: 3998:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 3999:    }
        -: 4000:  }
        -: 4001:
    #####: 4002:  return jerry_return (ecma_op_function_construct (ecma_get_object_from_value (func_object),
        -: 4003:                                                   ecma_get_object_from_value (func_object),
        -: 4004:                                                   args_p,
        -: 4005:                                                   args_count));
        -: 4006:} /* jerry_construct */
        -: 4007:
        -: 4008:/**
        -: 4009: * Get keys of the specified object value
        -: 4010: *
        -: 4011: * Note:
        -: 4012: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4013: *
        -: 4014: * @return array object value - if success
        -: 4015: *         value marked with error flag - otherwise
        -: 4016: */
        -: 4017:jerry_value_t
    #####: 4018:jerry_object_keys (const jerry_value_t object) /**< object value */
        -: 4019:{
        -: 4020:  jerry_assert_api_enabled ();
        -: 4021:
    #####: 4022:  if (!ecma_is_value_object (object))
        -: 4023:  {
    #####: 4024:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4025:  }
        -: 4026:
    #####: 4027:  ecma_collection_t *prop_names =
    #####: 4028:    ecma_op_object_get_enumerable_property_names (ecma_get_object_from_value (object), ECMA_ENUMERABLE_PROPERTY_KEYS);
        -: 4029:
        -: 4030:#if JERRY_BUILTIN_PROXY
    #####: 4031:  if (JERRY_UNLIKELY (prop_names == NULL))
        -: 4032:  {
    #####: 4033:    return ecma_create_exception_from_context ();
        -: 4034:  }
        -: 4035:#endif /* JERRY_BUILTIN_PROXY */
        -: 4036:
    #####: 4037:  return ecma_op_new_array_object_from_collection (prop_names, false);
        -: 4038:} /* jerry_object_keys */
        -: 4039:
        -: 4040:/**
        -: 4041: * Get the prototype of the specified object
        -: 4042: *
        -: 4043: * Note:
        -: 4044: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4045: *
        -: 4046: * @return prototype object or null value - if success
        -: 4047: *         value marked with error flag - otherwise
        -: 4048: */
        -: 4049:jerry_value_t
    #####: 4050:jerry_object_proto (const jerry_value_t object) /**< object value */
        -: 4051:{
        -: 4052:  jerry_assert_api_enabled ();
        -: 4053:
    #####: 4054:  if (!ecma_is_value_object (object))
        -: 4055:  {
    #####: 4056:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4057:  }
        -: 4058:
    #####: 4059:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 4060:
        -: 4061:#if JERRY_BUILTIN_PROXY
    #####: 4062:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4063:  {
    #####: 4064:    return jerry_return (ecma_proxy_object_get_prototype_of (obj_p));
        -: 4065:  }
        -: 4066:#endif /* JERRY_BUILTIN_PROXY */
        -: 4067:
    #####: 4068:  if (obj_p->u2.prototype_cp == JMEM_CP_NULL)
        -: 4069:  {
    #####: 4070:    return ECMA_VALUE_NULL;
        -: 4071:  }
        -: 4072:
    #####: 4073:  ecma_object_t *proto_obj_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_p->u2.prototype_cp);
    #####: 4074:  ecma_ref_object (proto_obj_p);
        -: 4075:
    #####: 4076:  return ecma_make_object_value (proto_obj_p);
        -: 4077:} /* jerry_object_proto */
        -: 4078:
        -: 4079:/**
        -: 4080: * Set the prototype of the specified object
        -: 4081: *
        -: 4082: * @return true value - if success
        -: 4083: *         value marked with error flag - otherwise
        -: 4084: */
        -: 4085:jerry_value_t
    #####: 4086:jerry_object_set_proto (const jerry_value_t object, /**< object value */
        -: 4087:                        const jerry_value_t proto) /**< prototype object value */
        -: 4088:{
        -: 4089:  jerry_assert_api_enabled ();
        -: 4090:
    #####: 4091:  if (!ecma_is_value_object (object) || ecma_is_value_exception (proto)
    #####: 4092:      || (!ecma_is_value_object (proto) && !ecma_is_value_null (proto)))
        -: 4093:  {
    #####: 4094:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4095:  }
    #####: 4096:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
        -: 4097:
        -: 4098:#if JERRY_BUILTIN_PROXY
    #####: 4099:  if (ECMA_OBJECT_IS_PROXY (obj_p))
        -: 4100:  {
    #####: 4101:    return jerry_return (ecma_proxy_object_set_prototype_of (obj_p, proto));
        -: 4102:  }
        -: 4103:#endif /* JERRY_BUILTIN_PROXY */
        -: 4104:
    #####: 4105:  return ecma_op_ordinary_object_set_prototype_of (obj_p, proto);
        -: 4106:} /* jerry_object_set_proto */
        -: 4107:
        -: 4108:/**
        -: 4109: * Utility to check if a given object can be used for the foreach api calls.
        -: 4110: *
        -: 4111: * Some objects/classes uses extra internal objects to correctly store data.
        -: 4112: * These extre object should never be exposed externally to the API user.
        -: 4113: *
        -: 4114: * @returns true - if the user can access the object in the callback.
        -: 4115: *          false - if the object is an internal object which should no be accessed by the user.
        -: 4116: */
        -: 4117:static bool
    #####: 4118:jerry_object_is_valid_foreach (ecma_object_t *object_p) /**< object to test */
        -: 4119:{
    #####: 4120:  if (ecma_is_lexical_environment (object_p))
        -: 4121:  {
    #####: 4122:    return false;
        -: 4123:  }
        -: 4124:
    #####: 4125:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 4126:
    #####: 4127:  if (object_type == ECMA_OBJECT_TYPE_CLASS)
        -: 4128:  {
    #####: 4129:    ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 4130:    switch (ext_object_p->u.cls.type)
        -: 4131:    {
        -: 4132:      /* An object's internal property object should not be iterable by foreach. */
    #####: 4133:      case ECMA_OBJECT_CLASS_INTERNAL_OBJECT:
        -: 4134:      {
    #####: 4135:        return false;
        -: 4136:      }
        -: 4137:    }
        -: 4138:  }
        -: 4139:
    #####: 4140:  return true;
        -: 4141:} /* jerry_object_is_valid_foreach */
        -: 4142:
        -: 4143:/**
        -: 4144: * Traverse objects.
        -: 4145: *
        -: 4146: * @return true - traversal was interrupted by the callback.
        -: 4147: *         false - otherwise - traversal visited all objects.
        -: 4148: */
        -: 4149:bool
    #####: 4150:jerry_foreach_live_object (jerry_foreach_live_object_cb_t callback, /**< function pointer of the iterator function */
        -: 4151:                           void *user_data_p) /**< pointer to user data */
        -: 4152:{
        -: 4153:  jerry_assert_api_enabled ();
        -: 4154:
    #####: 4155:  JERRY_ASSERT (callback != NULL);
        -: 4156:
    #####: 4157:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4158:
    #####: 4159:  while (iter_cp != JMEM_CP_NULL)
        -: 4160:  {
    #####: 4161:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4162:
    #####: 4163:    if (jerry_object_is_valid_foreach (iter_p) && !callback (ecma_make_object_value (iter_p), user_data_p))
        -: 4164:    {
    #####: 4165:      return true;
        -: 4166:    }
        -: 4167:
    #####: 4168:    iter_cp = iter_p->gc_next_cp;
        -: 4169:  }
        -: 4170:
    #####: 4171:  return false;
        -: 4172:} /* jerry_foreach_live_object */
        -: 4173:
        -: 4174:/**
        -: 4175: * Traverse objects having a given native type info.
        -: 4176: *
        -: 4177: * @return true - traversal was interrupted by the callback.
        -: 4178: *         false - otherwise - traversal visited all objects.
        -: 4179: */
        -: 4180:bool
    #####: 4181:jerry_foreach_live_object_with_info (const jerry_object_native_info_t *native_info_p, /**< the type info
        -: 4182:                                                                                       *   of the native pointer */
        -: 4183:                                     jerry_foreach_live_object_with_info_cb_t callback, /**< function to apply for
        -: 4184:                                                                                         *   each matching object */
        -: 4185:                                     void *user_data_p) /**< pointer to user data */
        -: 4186:{
        -: 4187:  jerry_assert_api_enabled ();
        -: 4188:
    #####: 4189:  JERRY_ASSERT (native_info_p != NULL);
    #####: 4190:  JERRY_ASSERT (callback != NULL);
        -: 4191:
        -: 4192:  ecma_native_pointer_t *native_pointer_p;
        -: 4193:
    #####: 4194:  jmem_cpointer_t iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 4195:
    #####: 4196:  while (iter_cp != JMEM_CP_NULL)
        -: 4197:  {
    #####: 4198:    ecma_object_t *iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, iter_cp);
        -: 4199:
    #####: 4200:    if (jerry_object_is_valid_foreach (iter_p))
        -: 4201:    {
    #####: 4202:      native_pointer_p = ecma_get_native_pointer_value (iter_p, (void *) native_info_p);
    #####: 4203:      if (native_pointer_p && !callback (ecma_make_object_value (iter_p), native_pointer_p->native_p, user_data_p))
        -: 4204:      {
    #####: 4205:        return true;
        -: 4206:      }
        -: 4207:    }
        -: 4208:
    #####: 4209:    iter_cp = iter_p->gc_next_cp;
        -: 4210:  }
        -: 4211:
    #####: 4212:  return false;
        -: 4213:} /* jerry_foreach_live_object_with_info */
        -: 4214:
        -: 4215:/**
        -: 4216: * Get native pointer and its type information, associated with the given native type info.
        -: 4217: *
        -: 4218: * Note:
        -: 4219: *  If native pointer is present, its type information is returned in out_native_pointer_p
        -: 4220: *
        -: 4221: * @return found native pointer,
        -: 4222: *         or NULL
        -: 4223: */
        -: 4224:void *
    #####: 4225:jerry_object_get_native_ptr (const jerry_value_t object, /**< object to get native pointer from */
        -: 4226:                             const jerry_object_native_info_t *native_info_p) /**< the type info
        -: 4227:                                                                               *   of the native pointer */
        -: 4228:{
        -: 4229:  jerry_assert_api_enabled ();
        -: 4230:
    #####: 4231:  if (!ecma_is_value_object (object))
        -: 4232:  {
    #####: 4233:    return NULL;
        -: 4234:  }
        -: 4235:
    #####: 4236:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 4237:  ecma_native_pointer_t *native_pointer_p = ecma_get_native_pointer_value (obj_p, (void *) native_info_p);
        -: 4238:
    #####: 4239:  if (native_pointer_p == NULL)
        -: 4240:  {
    #####: 4241:    return NULL;
        -: 4242:  }
        -: 4243:
    #####: 4244:  return native_pointer_p->native_p;
        -: 4245:} /* jerry_object_get_native_ptr */
        -: 4246:
        -: 4247:/**
        -: 4248: * Set native pointer and an optional type info for the specified object.
        -: 4249: *
        -: 4250: *
        -: 4251: * Note:
        -: 4252: *      If native pointer was already set for the object, its value is updated.
        -: 4253: *
        -: 4254: * Note:
        -: 4255: *      If a non-NULL free callback is specified in the native type info,
        -: 4256: *      it will be called by the garbage collector when the object is freed.
        -: 4257: *      Referred values by this method must have at least 1 reference. (Correct API usage satisfies this condition)
        -: 4258: *      The type info always overwrites the previous value, so passing
        -: 4259: *      a NULL value deletes the current type info.
        -: 4260: */
        -: 4261:void
    #####: 4262:jerry_object_set_native_ptr (const jerry_value_t object, /**< object to set native pointer in */
        -: 4263:                             const jerry_object_native_info_t *native_info_p, /**< object's native type info */
        -: 4264:                             void *native_pointer_p) /**< native pointer */
        -: 4265:{
        -: 4266:  jerry_assert_api_enabled ();
        -: 4267:
    #####: 4268:  if (ecma_is_value_object (object))
        -: 4269:  {
    #####: 4270:    ecma_object_t *object_p = ecma_get_object_from_value (object);
        -: 4271:
    #####: 4272:    ecma_create_native_pointer_property (object_p, native_pointer_p, native_info_p);
        -: 4273:  }
    #####: 4274:} /* jerry_object_set_native_ptr */
        -: 4275:
        -: 4276:/**
        -: 4277: * Checks wether the argument object has a native poitner set for the specified native type info.
        -: 4278: *
        -: 4279: * @return true if the native pointer has been set,
        -: 4280: *         false otherwise
        -: 4281: */
        -: 4282:bool
    #####: 4283:jerry_object_has_native_ptr (const jerry_value_t object, /**< object to set native pointer in */
        -: 4284:                             const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4285:{
        -: 4286:  jerry_assert_api_enabled ();
        -: 4287:
    #####: 4288:  if (!ecma_is_value_object (object))
        -: 4289:  {
    #####: 4290:    return false;
        -: 4291:  }
        -: 4292:
    #####: 4293:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 4294:  ecma_native_pointer_t *native_pointer_p = ecma_get_native_pointer_value (obj_p, (void *) native_info_p);
        -: 4295:
    #####: 4296:  return native_pointer_p != NULL;
        -: 4297:} /* jerry_object_has_native_ptr */
        -: 4298:
        -: 4299:/**
        -: 4300: * Delete the previously set native pointer by the native type info from the specified object.
        -: 4301: *
        -: 4302: * Note:
        -: 4303: *      If the specified object has no matching native pointer for the given native type info
        -: 4304: *      the function has no effect.
        -: 4305: *
        -: 4306: * Note:
        -: 4307: *      This operation cannot throw an exception.
        -: 4308: *
        -: 4309: * @return true - if the native pointer has been deleted succesfully
        -: 4310: *         false - otherwise
        -: 4311: */
        -: 4312:bool
    #####: 4313:jerry_object_delete_native_ptr (const jerry_value_t object, /**< object to delete native pointer from */
        -: 4314:                                const jerry_object_native_info_t *native_info_p) /**< object's native type info */
        -: 4315:{
        -: 4316:  jerry_assert_api_enabled ();
        -: 4317:
    #####: 4318:  if (ecma_is_value_object (object))
        -: 4319:  {
    #####: 4320:    ecma_object_t *object_p = ecma_get_object_from_value (object);
        -: 4321:
    #####: 4322:    return ecma_delete_native_pointer_property (object_p, (void *) native_info_p);
        -: 4323:  }
        -: 4324:
    #####: 4325:  return false;
        -: 4326:} /* jerry_object_delete_native_ptr */
        -: 4327:
        -: 4328:/**
        -: 4329: * Initialize the references stored in a buffer pointed by a native pointer.
        -: 4330: * The references are initialized to undefined.
        -: 4331: */
        -: 4332:void
    #####: 4333:jerry_native_ptr_init (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4334:                       const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4335:                                                                         *   the native pointer */
        -: 4336:{
        -: 4337:  jerry_assert_api_enabled ();
        -: 4338:
    #####: 4339:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4340:  {
    #####: 4341:    return;
        -: 4342:  }
        -: 4343:
    #####: 4344:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4345:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4346:
    #####: 4347:  while (value_p < end_p)
        -: 4348:  {
    #####: 4349:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4350:  }
        -: 4351:} /* jerry_native_ptr_init */
        -: 4352:
        -: 4353:/**
        -: 4354: * Release the value references after a buffer pointed by a native pointer
        -: 4355: * is not attached to an object anymore. All references are set to undefined
        -: 4356: * similar to jerry_native_ptr_init.
        -: 4357: */
        -: 4358:void
    #####: 4359:jerry_native_ptr_free (void *native_pointer_p, /**< a valid non-NULL pointer to a native buffer */
        -: 4360:                       const jerry_object_native_info_t *native_info_p) /**< the type info of
        -: 4361:                                                                         *   the native pointer */
        -: 4362:{
        -: 4363:  jerry_assert_api_enabled ();
        -: 4364:
    #####: 4365:  if (native_pointer_p == NULL || native_info_p == NULL)
        -: 4366:  {
    #####: 4367:    return;
        -: 4368:  }
        -: 4369:
    #####: 4370:  ecma_value_t *value_p = (ecma_value_t *) (((uint8_t *) native_pointer_p) + native_info_p->offset_of_references);
    #####: 4371:  ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -: 4372:
    #####: 4373:  while (value_p < end_p)
        -: 4374:  {
    #####: 4375:    ecma_free_value_if_not_object (*value_p);
    #####: 4376:    *value_p++ = ECMA_VALUE_UNDEFINED;
        -: 4377:  }
        -: 4378:} /* jerry_native_ptr_free */
        -: 4379:
        -: 4380:/**
        -: 4381: * Updates a value reference inside the area specified by the number_of_references and
        -: 4382: * offset_of_references fields in its corresponding jerry_object_native_info_t data.
        -: 4383: * The area must be part of a buffer which is currently assigned to an object.
        -: 4384: *
        -: 4385: * Note:
        -: 4386: *      Error references are not supported, they are replaced by undefined values.
        -: 4387: */
        -: 4388:void
    #####: 4389:jerry_native_ptr_set (jerry_value_t *reference_p, /**< a valid non-NULL pointer to
        -: 4390:                                                   *   a reference in a native buffer. */
        -: 4391:                      jerry_value_t value) /**< new value of the reference */
        -: 4392:{
        -: 4393:  jerry_assert_api_enabled ();
        -: 4394:
    #####: 4395:  if (reference_p == NULL)
        -: 4396:  {
    #####: 4397:    return;
        -: 4398:  }
        -: 4399:
    #####: 4400:  if (ecma_is_value_exception (value))
        -: 4401:  {
    #####: 4402:    value = ECMA_VALUE_UNDEFINED;
        -: 4403:  }
        -: 4404:
    #####: 4405:  ecma_free_value_if_not_object (*reference_p);
    #####: 4406:  *reference_p = ecma_copy_value_if_not_object (value);
        -: 4407:} /* jerry_native_ptr_set */
        -: 4408:
        -: 4409:/**
        -: 4410: * Applies the given function to the every property in the object.
        -: 4411: *
        -: 4412: * @return true - if object fields traversal was performed successfully, i.e.:
        -: 4413: *                - no unhandled exceptions were thrown in object fields traversal;
        -: 4414: *                - object fields traversal was stopped on callback that returned false;
        -: 4415: *         false - otherwise,
        -: 4416: *                 if getter of field threw a exception or unhandled exceptions were thrown during traversal;
        -: 4417: */
        -: 4418:bool
    #####: 4419:jerry_object_foreach (const jerry_value_t object, /**< object value */
        -: 4420:                      jerry_object_property_foreach_cb_t foreach_p, /**< foreach function */
        -: 4421:                      void *user_data_p) /**< user data for foreach function */
        -: 4422:{
        -: 4423:  jerry_assert_api_enabled ();
        -: 4424:
    #####: 4425:  if (!ecma_is_value_object (object))
        -: 4426:  {
    #####: 4427:    return false;
        -: 4428:  }
        -: 4429:
    #####: 4430:  ecma_object_t *object_p = ecma_get_object_from_value (object);
    #####: 4431:  ecma_collection_t *names_p = ecma_op_object_enumerate (object_p);
        -: 4432:
        -: 4433:#if JERRY_BUILTIN_PROXY
    #####: 4434:  if (names_p == NULL)
        -: 4435:  {
        -: 4436:    // TODO: Due to Proxies the return value must be changed to jerry_value_t on next release
    #####: 4437:    jcontext_release_exception ();
    #####: 4438:    return false;
        -: 4439:  }
        -: 4440:#endif /* JERRY_BUILTIN_PROXY */
        -: 4441:
    #####: 4442:  ecma_value_t *buffer_p = names_p->buffer_p;
        -: 4443:
    #####: 4444:  ecma_value_t property_value = ECMA_VALUE_EMPTY;
        -: 4445:
    #####: 4446:  bool continuous = true;
        -: 4447:
    #####: 4448:  for (uint32_t i = 0; continuous && (i < names_p->item_count); i++)
        -: 4449:  {
    #####: 4450:    ecma_string_t *property_name_p = ecma_get_string_from_value (buffer_p[i]);
        -: 4451:
    #####: 4452:    property_value = ecma_op_object_get (object_p, property_name_p);
        -: 4453:
    #####: 4454:    if (ECMA_IS_VALUE_ERROR (property_value))
        -: 4455:    {
    #####: 4456:      break;
        -: 4457:    }
        -: 4458:
    #####: 4459:    continuous = foreach_p (buffer_p[i], property_value, user_data_p);
    #####: 4460:    ecma_free_value (property_value);
        -: 4461:  }
        -: 4462:
    #####: 4463:  ecma_collection_free (names_p);
        -: 4464:
    #####: 4465:  if (!ECMA_IS_VALUE_ERROR (property_value))
        -: 4466:  {
    #####: 4467:    return true;
        -: 4468:  }
        -: 4469:
    #####: 4470:  jcontext_release_exception ();
    #####: 4471:  return false;
        -: 4472:} /* jerry_object_foreach */
        -: 4473:
        -: 4474:/**
        -: 4475: * Gets the property keys for the given object using the selected filters.
        -: 4476: *
        -: 4477: * @return array containing the filtered property keys in successful operation
        -: 4478: *         value marked with error flag - otherwise
        -: 4479: */
        -: 4480:jerry_value_t
    #####: 4481:jerry_object_property_names (const jerry_value_t object, /**< object */
        -: 4482:                             jerry_property_filter_t filter) /**< property filter options */
        -: 4483:{
        -: 4484:  jerry_assert_api_enabled ();
        -: 4485:
    #####: 4486:  if (!ecma_is_value_object (object))
        -: 4487:  {
    #####: 4488:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4489:  }
        -: 4490:
    #####: 4491:  ecma_object_t *obj_p = ecma_get_object_from_value (object);
    #####: 4492:  ecma_object_t *obj_iter_p = obj_p;
    #####: 4493:  ecma_collection_t *result_p = ecma_new_collection ();
        -: 4494:
    #####: 4495:  ecma_ref_object (obj_iter_p);
        -: 4496:
        -: 4497:  while (true)
    #####: 4498:  {
        -: 4499:    /* Step 1. Get Object.[[OwnKeys]] */
    #####: 4500:    ecma_collection_t *prop_names_p = ecma_op_object_own_property_keys (obj_iter_p, filter);
        -: 4501:
        -: 4502:#if JERRY_BUILTIN_PROXY
    #####: 4503:    if (prop_names_p == NULL)
        -: 4504:    {
    #####: 4505:      ecma_deref_object (obj_iter_p);
    #####: 4506:      return ecma_create_exception_from_context ();
        -: 4507:    }
        -: 4508:#endif /* JERRY_BUILTIN_PROXY */
        -: 4509:
    #####: 4510:    for (uint32_t i = 0; i < prop_names_p->item_count; i++)
        -: 4511:    {
    #####: 4512:      ecma_value_t key = prop_names_p->buffer_p[i];
    #####: 4513:      ecma_string_t *key_p = ecma_get_prop_name_from_value (key);
    #####: 4514:      uint32_t index = ecma_string_get_array_index (key_p);
        -: 4515:
        -: 4516:      /* Step 2. Filter by key type */
    #####: 4517:      if (filter
    #####: 4518:          & (JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS | JERRY_PROPERTY_FILTER_EXCLUDE_SYMBOLS
        -: 4519:             | JERRY_PROPERTY_FILTER_EXCLUDE_INTEGER_INDICES))
        -: 4520:      {
    #####: 4521:        if (ecma_is_value_symbol (key))
        -: 4522:        {
    #####: 4523:          if (filter & JERRY_PROPERTY_FILTER_EXCLUDE_SYMBOLS)
        -: 4524:          {
    #####: 4525:            continue;
        -: 4526:          }
        -: 4527:        }
    #####: 4528:        else if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -: 4529:        {
    #####: 4530:          if ((filter & JERRY_PROPERTY_FILTER_EXCLUDE_INTEGER_INDICES)
    #####: 4531:              || ((filter & JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS)
    #####: 4532:                  && !(filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER)))
        -: 4533:          {
    #####: 4534:            continue;
        -: 4535:          }
        -: 4536:        }
    #####: 4537:        else if (filter & JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS)
        -: 4538:        {
    #####: 4539:          continue;
        -: 4540:        }
        -: 4541:      }
        -: 4542:
        -: 4543:      /* Step 3. Filter property attributes */
    #####: 4544:      if (filter
    #####: 4545:          & (JERRY_PROPERTY_FILTER_EXCLUDE_NON_CONFIGURABLE | JERRY_PROPERTY_FILTER_EXCLUDE_NON_ENUMERABLE
        -: 4546:             | JERRY_PROPERTY_FILTER_EXCLUDE_NON_WRITABLE))
        -: 4547:      {
    #####: 4548:        ecma_property_descriptor_t prop_desc;
    #####: 4549:        ecma_value_t status = ecma_op_object_get_own_property_descriptor (obj_iter_p, key_p, &prop_desc);
        -: 4550:
        -: 4551:#if JERRY_BUILTIN_PROXY
    #####: 4552:        if (ECMA_IS_VALUE_ERROR (status))
        -: 4553:        {
    #####: 4554:          ecma_collection_free (prop_names_p);
    #####: 4555:          ecma_collection_free (result_p);
    #####: 4556:          ecma_deref_object (obj_iter_p);
    #####: 4557:          return ecma_create_exception_from_context ();
        -: 4558:        }
        -: 4559:#endif /* JERRY_BUILTIN_PROXY */
        -: 4560:
    #####: 4561:        JERRY_ASSERT (ecma_is_value_true (status));
    #####: 4562:        uint16_t flags = prop_desc.flags;
    #####: 4563:        ecma_free_property_descriptor (&prop_desc);
        -: 4564:
    #####: 4565:        if ((!(flags & JERRY_PROP_IS_CONFIGURABLE) && (filter & JERRY_PROPERTY_FILTER_EXCLUDE_NON_CONFIGURABLE))
    #####: 4566:            || (!(flags & JERRY_PROP_IS_ENUMERABLE) && (filter & JERRY_PROPERTY_FILTER_EXCLUDE_NON_ENUMERABLE))
    #####: 4567:            || (!(flags & JERRY_PROP_IS_WRITABLE) && (filter & JERRY_PROPERTY_FILTER_EXCLUDE_NON_WRITABLE)))
        -: 4568:        {
    #####: 4569:          continue;
        -: 4570:        }
        -: 4571:      }
        -: 4572:
    #####: 4573:      if (index != ECMA_STRING_NOT_ARRAY_INDEX && (filter & JERRY_PROPERTY_FILTER_INTEGER_INDICES_AS_NUMBER))
        -: 4574:      {
    #####: 4575:        ecma_deref_ecma_string (key_p);
    #####: 4576:        key = ecma_make_uint32_value (index);
        -: 4577:      }
        -: 4578:      else
        -: 4579:      {
    #####: 4580:        ecma_ref_ecma_string (key_p);
        -: 4581:      }
        -: 4582:
    #####: 4583:      if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) && obj_iter_p != obj_p)
    #####: 4584:      {
    #####: 4585:        uint32_t duplicate_idx = 0;
    #####: 4586:        while (duplicate_idx < result_p->item_count)
        -: 4587:        {
    #####: 4588:          ecma_value_t value = result_p->buffer_p[duplicate_idx];
    #####: 4589:          JERRY_ASSERT (ecma_is_value_prop_name (value) || ecma_is_value_number (value));
    #####: 4590:          if (JERRY_UNLIKELY (ecma_is_value_number (value)))
        -: 4591:          {
    #####: 4592:            if (ecma_get_number_from_value (value) == ecma_get_number_from_value (key))
        -: 4593:            {
    #####: 4594:              break;
        -: 4595:            }
        -: 4596:          }
    #####: 4597:          else if (ecma_compare_ecma_strings (ecma_get_prop_name_from_value (value), key_p))
        -: 4598:          {
    #####: 4599:            break;
        -: 4600:          }
        -: 4601:
    #####: 4602:          duplicate_idx++;
        -: 4603:        }
        -: 4604:
    #####: 4605:        if (duplicate_idx == result_p->item_count)
        -: 4606:        {
    #####: 4607:          ecma_collection_push_back (result_p, key);
        -: 4608:        }
        -: 4609:      }
        -: 4610:      else
        -: 4611:      {
    #####: 4612:        ecma_collection_push_back (result_p, key);
        -: 4613:      }
        -: 4614:    }
        -: 4615:
    #####: 4616:    ecma_collection_free (prop_names_p);
        -: 4617:
        -: 4618:    /* Step 4: Traverse prototype chain */
        -: 4619:
    #####: 4620:    if ((filter & JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN) != JERRY_PROPERTY_FILTER_TRAVERSE_PROTOTYPE_CHAIN)
        -: 4621:    {
    #####: 4622:      break;
        -: 4623:    }
        -: 4624:
    #####: 4625:    ecma_object_t *proto_p = ecma_op_object_get_prototype_of (obj_iter_p);
        -: 4626:
    #####: 4627:    if (proto_p == NULL)
        -: 4628:    {
    #####: 4629:      break;
        -: 4630:    }
        -: 4631:
    #####: 4632:    ecma_deref_object (obj_iter_p);
        -: 4633:
    #####: 4634:    if (JERRY_UNLIKELY (proto_p == ECMA_OBJECT_POINTER_ERROR))
        -: 4635:    {
    #####: 4636:      ecma_collection_free (result_p);
    #####: 4637:      return ecma_create_exception_from_context ();
        -: 4638:    }
        -: 4639:
    #####: 4640:    obj_iter_p = proto_p;
        -: 4641:  }
        -: 4642:
    #####: 4643:  ecma_deref_object (obj_iter_p);
        -: 4644:
    #####: 4645:  return ecma_op_new_array_object_from_collection (result_p, false);
        -: 4646:} /* jerry_object_property_names */
        -: 4647:
        -: 4648:/**
        -: 4649: * FromPropertyDescriptor abstract operation.
        -: 4650: *
        -: 4651: * @return new jerry_value_t - if success
        -: 4652: *         value marked with error flag - otherwise
        -: 4653: */
        -: 4654:jerry_value_t
    #####: 4655:jerry_property_descriptor_to_object (const jerry_property_descriptor_t *src_prop_desc_p) /**< property descriptor */
        -: 4656:{
        -: 4657:  jerry_assert_api_enabled ();
        -: 4658:
    #####: 4659:  ecma_property_descriptor_t prop_desc = jerry_property_descriptor_to_ecma (src_prop_desc_p);
        -: 4660:
    #####: 4661:  if (ECMA_IS_VALUE_ERROR (prop_desc.value))
        -: 4662:  {
    #####: 4663:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4664:  }
        -: 4665:
    #####: 4666:  ecma_object_t *desc_obj_p = ecma_op_from_property_descriptor (&prop_desc);
        -: 4667:
    #####: 4668:  return ecma_make_object_value (desc_obj_p);
        -: 4669:} /* jerry_property_descriptor_to_object */
        -: 4670:
        -: 4671:/**
        -: 4672: * ToPropertyDescriptor abstract operation.
        -: 4673: *
        -: 4674: * @return true - if the conversion is successful
        -: 4675: *         thrown error - otherwise
        -: 4676: */
        -: 4677:jerry_value_t
    #####: 4678:jerry_property_descriptor_from_object (const jerry_value_t object, /**< object value */
        -: 4679:                                       jerry_property_descriptor_t *out_prop_desc_p) /**< [out] filled property
        -: 4680:                                                                                      * descriptor if return value is
        -: 4681:                                                                                      * true, unmodified otherwise */
        -: 4682:{
        -: 4683:  jerry_assert_api_enabled ();
        -: 4684:
    #####: 4685:  ecma_property_descriptor_t prop_desc;
    #####: 4686:  jerry_value_t result = ecma_op_to_property_descriptor (object, &prop_desc);
        -: 4687:
    #####: 4688:  if (ECMA_IS_VALUE_ERROR (result))
        -: 4689:  {
    #####: 4690:    return ecma_create_exception_from_context ();
        -: 4691:  }
        -: 4692:
    #####: 4693:  JERRY_ASSERT (result == ECMA_VALUE_EMPTY);
        -: 4694:
    #####: 4695:  *out_prop_desc_p = jerry_property_descriptor_from_ecma (&prop_desc);
    #####: 4696:  return ECMA_VALUE_TRUE;
        -: 4697:} /* jerry_property_descriptor_from_object */
        -: 4698:
        -: 4699:/**
        -: 4700: * Resolve a promise value with an argument.
        -: 4701: *
        -: 4702: * @return undefined - if success,
        -: 4703: *         exception - otherwise
        -: 4704: */
        -: 4705:jerry_value_t
    #####: 4706:jerry_promise_resolve (jerry_value_t promise, /**< the promise value */
        -: 4707:                       const jerry_value_t argument) /**< the argument */
        -: 4708:{
        -: 4709:  jerry_assert_api_enabled ();
        -: 4710:
        -: 4711:#if JERRY_ESNEXT
    #####: 4712:  if (!jerry_value_is_promise (promise))
        -: 4713:  {
    #####: 4714:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4715:  }
        -: 4716:
    #####: 4717:  if (ecma_is_value_exception (argument))
        -: 4718:  {
    #####: 4719:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 4720:  }
        -: 4721:
    #####: 4722:  return ecma_fulfill_promise_with_checks (promise, argument);
        -: 4723:#else /* !JERRY_ESNEXT */
        -: 4724:  JERRY_UNUSED (promise);
        -: 4725:  JERRY_UNUSED (argument);
        -: 4726:
    #####: 4727:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROMISE_NOT_SUPPORTED));
        -: 4728:#endif /* JERRY_ESNEXT */
        -: 4729:} /* jerry_promise_resolve */
        -: 4730:
        -: 4731:/**
        -: 4732: * Reject a promise value with an argument.
        -: 4733: *
        -: 4734: * @return undefined - if success,
        -: 4735: *         exception - otherwise
        -: 4736: */
        -: 4737:jerry_value_t
    #####: 4738:jerry_promise_reject (jerry_value_t promise, /**< the promise value */
        -: 4739:                      const jerry_value_t argument) /**< the argument */
        -: 4740:{
        -: 4741:  jerry_assert_api_enabled ();
        -: 4742:
        -: 4743:#if JERRY_ESNEXT
    #####: 4744:  if (!jerry_value_is_promise (promise))
        -: 4745:  {
    #####: 4746:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4747:  }
        -: 4748:
    #####: 4749:  if (ecma_is_value_exception (argument))
        -: 4750:  {
    #####: 4751:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 4752:  }
        -: 4753:
    #####: 4754:  return ecma_reject_promise_with_checks (promise, argument);
        -: 4755:#else /* !JERRY_ESNEXT */
        -: 4756:  JERRY_UNUSED (promise);
        -: 4757:  JERRY_UNUSED (argument);
        -: 4758:
    #####: 4759:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROMISE_NOT_SUPPORTED));
        -: 4760:#endif /* JERRY_ESNEXT */
        -: 4761:} /* jerry_promise_reject */
        -: 4762:
        -: 4763:/**
        -: 4764: * Get the result of a promise.
        -: 4765: *
        -: 4766: * @return - Promise result
        -: 4767: *         - Type error if the promise support was not enabled or the input was not a promise object
        -: 4768: */
        -: 4769:jerry_value_t
    #####: 4770:jerry_promise_result (const jerry_value_t promise) /**< promise object to get the result from */
        -: 4771:{
        -: 4772:  jerry_assert_api_enabled ();
        -: 4773:
        -: 4774:#if JERRY_ESNEXT
    #####: 4775:  if (!jerry_value_is_promise (promise))
        -: 4776:  {
    #####: 4777:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4778:  }
        -: 4779:
    #####: 4780:  return ecma_promise_get_result (ecma_get_object_from_value (promise));
        -: 4781:#else /* !JERRY_ESNEXT */
        -: 4782:  JERRY_UNUSED (promise);
    #####: 4783:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PROMISE_NOT_SUPPORTED));
        -: 4784:#endif /* JERRY_ESNEXT */
        -: 4785:} /* jerry_promise_result */
        -: 4786:
        -: 4787:/**
        -: 4788: * Get the state of a promise object.
        -: 4789: *
        -: 4790: * @return - the state of the promise (one of the jerry_promise_state_t enum values)
        -: 4791: *         - JERRY_PROMISE_STATE_NONE is only returned if the input is not a promise object
        -: 4792: *           or the promise support was not enabled.
        -: 4793: */
        -: 4794:jerry_promise_state_t
    #####: 4795:jerry_promise_state (const jerry_value_t promise) /**< promise object to get the state from */
        -: 4796:{
        -: 4797:  jerry_assert_api_enabled ();
        -: 4798:
        -: 4799:#if JERRY_ESNEXT
    #####: 4800:  if (!jerry_value_is_promise (promise))
        -: 4801:  {
    #####: 4802:    return JERRY_PROMISE_STATE_NONE;
        -: 4803:  }
        -: 4804:
    #####: 4805:  uint16_t flags = ecma_promise_get_flags (ecma_get_object_from_value (promise));
    #####: 4806:  flags &= (ECMA_PROMISE_IS_PENDING | ECMA_PROMISE_IS_FULFILLED);
        -: 4807:
    #####: 4808:  return (flags ? flags : JERRY_PROMISE_STATE_REJECTED);
        -: 4809:#else /* !JERRY_ESNEXT */
        -: 4810:  JERRY_UNUSED (promise);
    #####: 4811:  return JERRY_PROMISE_STATE_NONE;
        -: 4812:#endif /* JERRY_ESNEXT */
        -: 4813:} /* jerry_promise_state */
        -: 4814:
        -: 4815:/**
        -: 4816: * Sets a callback for tracking Promise and async operations.
        -: 4817: *
        -: 4818: * Note:
        -: 4819: *     the previous callback is overwritten
        -: 4820: */
        -: 4821:void
        1: 4822:jerry_promise_on_event (jerry_promise_event_filter_t filters, /**< combination of event filters */
        -: 4823:                        jerry_promise_event_cb_t callback, /**< notification callback */
        -: 4824:                        void *user_p) /**< user pointer passed to the callback */
        -: 4825:{
        -: 4826:  jerry_assert_api_enabled ();
        -: 4827:
        -: 4828:#if JERRY_ESNEXT && JERRY_PROMISE_CALLBACK
    #####: 4829:  if (filters == JERRY_PROMISE_EVENT_FILTER_DISABLE || callback == NULL)
        -: 4830:  {
    #####: 4831:    JERRY_CONTEXT (promise_callback_filters) = JERRY_PROMISE_EVENT_FILTER_DISABLE;
    #####: 4832:    return;
        -: 4833:  }
        -: 4834:
    #####: 4835:  JERRY_CONTEXT (promise_callback_filters) = (uint32_t) filters;
    #####: 4836:  JERRY_CONTEXT (promise_callback) = callback;
    #####: 4837:  JERRY_CONTEXT (promise_callback_user_p) = user_p;
        -: 4838:#else /* !JERRY_ESNEXT && !JERRY_PROMISE_CALLBACK */
        -: 4839:  JERRY_UNUSED (filters);
        -: 4840:  JERRY_UNUSED (callback);
        -: 4841:  JERRY_UNUSED (user_p);
        -: 4842:#endif /* JERRY_ESNEXT && JERRY_PROMISE_CALLBACK */
        1: 4843:} /* jerry_promise_on_event */
        -: 4844:
        -: 4845:/**
        -: 4846: * Get the well-knwon symbol represented by the given `symbol` enum value.
        -: 4847: *
        -: 4848: * Note:
        -: 4849: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4850: *
        -: 4851: * @return undefined value - if invalid well-known symbol was requested
        -: 4852: *         well-known symbol value - otherwise
        -: 4853: */
        -: 4854:jerry_value_t
    #####: 4855:jerry_symbol (jerry_well_known_symbol_t symbol) /**< jerry_well_known_symbol_t enum value */
        -: 4856:{
        -: 4857:  jerry_assert_api_enabled ();
        -: 4858:
        -: 4859:#if JERRY_ESNEXT
    #####: 4860:  lit_magic_string_id_t id = (lit_magic_string_id_t) (LIT_GLOBAL_SYMBOL__FIRST + symbol);
        -: 4861:
    #####: 4862:  if (!LIT_IS_GLOBAL_SYMBOL (id))
        -: 4863:  {
    #####: 4864:    return ECMA_VALUE_UNDEFINED;
        -: 4865:  }
        -: 4866:
    #####: 4867:  return ecma_make_symbol_value (ecma_op_get_global_symbol (id));
        -: 4868:#else /* !JERRY_ESNEXT */
        -: 4869:  JERRY_UNUSED (symbol);
        -: 4870:
    #####: 4871:  return ECMA_VALUE_UNDEFINED;
        -: 4872:#endif /* JERRY_ESNEXT */
        -: 4873:} /* jerry_symbol */
        -: 4874:
        -: 4875:/**
        -: 4876: * Returns the description internal property of a symbol.
        -: 4877: *
        -: 4878: * Note:
        -: 4879: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4880: *
        -: 4881: * @return string or undefined value containing the symbol's description - if success
        -: 4882: *         thrown error - otherwise
        -: 4883: */
        -: 4884:jerry_value_t
    #####: 4885:jerry_symbol_description (const jerry_value_t symbol) /**< symbol value */
        -: 4886:{
        -: 4887:  jerry_assert_api_enabled ();
        -: 4888:
        -: 4889:#if JERRY_ESNEXT
    #####: 4890:  if (!ecma_is_value_symbol (symbol))
        -: 4891:  {
    #####: 4892:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4893:  }
        -: 4894:
        -: 4895:  /* Note: This operation cannot throw an error */
    #####: 4896:  return ecma_copy_value (ecma_get_symbol_description (ecma_get_symbol_from_value (symbol)));
        -: 4897:#else /* !JERRY_ESNEXT */
        -: 4898:  JERRY_UNUSED (symbol);
        -: 4899:
    #####: 4900:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SYMBOL_NOT_SUPPORTED));
        -: 4901:#endif /* JERRY_ESNEXT */
        -: 4902:} /* jerry_symbol_description */
        -: 4903:
        -: 4904:/**
        -: 4905: * Call the SymbolDescriptiveString ecma builtin operation on the symbol value.
        -: 4906: *
        -: 4907: * Note:
        -: 4908: *      returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 4909: *
        -: 4910: * @return string value containing the symbol's descriptive string - if success
        -: 4911: *         thrown error - otherwise
        -: 4912: */
        -: 4913:jerry_value_t
    #####: 4914:jerry_symbol_descriptive_string (const jerry_value_t symbol) /**< symbol value */
        -: 4915:{
        -: 4916:  jerry_assert_api_enabled ();
        -: 4917:
        -: 4918:#if JERRY_ESNEXT
    #####: 4919:  if (!ecma_is_value_symbol (symbol))
        -: 4920:  {
    #####: 4921:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 4922:  }
        -: 4923:
        -: 4924:  /* Note: This operation cannot throw an error */
    #####: 4925:  return ecma_get_symbol_descriptive_string (symbol);
        -: 4926:#else /* !JERRY_ESNEXT */
        -: 4927:  JERRY_UNUSED (symbol);
        -: 4928:
    #####: 4929:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SYMBOL_NOT_SUPPORTED));
        -: 4930:#endif /* JERRY_ESNEXT */
        -: 4931:} /* jerry_symbol_descriptive_string */
        -: 4932:
        -: 4933:/**
        -: 4934: * Get the number of uint64 digits of a BigInt value
        -: 4935: *
        -: 4936: * @return number of uint64 digits
        -: 4937: */
        -: 4938:uint32_t
    #####: 4939:jerry_bigint_digit_count (const jerry_value_t value) /**< BigInt value */
        -: 4940:{
        -: 4941:  jerry_assert_api_enabled ();
        -: 4942:
        -: 4943:#if JERRY_BUILTIN_BIGINT
    #####: 4944:  if (!ecma_is_value_bigint (value))
        -: 4945:  {
    #####: 4946:    return 0;
        -: 4947:  }
        -: 4948:
    #####: 4949:  return ecma_bigint_get_size_in_digits (value);
        -: 4950:#else /* !JERRY_BUILTIN_BIGINT */
        -: 4951:  JERRY_UNUSED (value);
    #####: 4952:  return 0;
        -: 4953:#endif /* JERRY_BUILTIN_BIGINT */
        -: 4954:} /* jerry_bigint_digit_count */
        -: 4955:
        -: 4956:/**
        -: 4957: * Get the uint64 digits of a BigInt value (lowest digit first)
        -: 4958: */
        -: 4959:void
    #####: 4960:jerry_bigint_to_digits (jerry_value_t value, /**< BigInt value */
        -: 4961:                        uint64_t *digits_p, /**< [out] buffer for digits */
        -: 4962:                        uint32_t digit_count, /**< buffer size in digits */
        -: 4963:                        bool *sign_p) /**< [out] sign of BigInt */
        -: 4964:{
        -: 4965:#if JERRY_BUILTIN_BIGINT
    #####: 4966:  if (!ecma_is_value_bigint (value))
        -: 4967:  {
    #####: 4968:    if (sign_p != NULL)
        -: 4969:    {
    #####: 4970:      *sign_p = false;
        -: 4971:    }
    #####: 4972:    memset (digits_p, 0, digit_count * sizeof (uint64_t));
        -: 4973:  }
        -: 4974:
    #####: 4975:  ecma_bigint_get_digits_and_sign (value, digits_p, digit_count, sign_p);
        -: 4976:#else /* !JERRY_BUILTIN_BIGINT */
        -: 4977:  JERRY_UNUSED (value);
        -: 4978:
    #####: 4979:  if (sign_p != NULL)
        -: 4980:  {
    #####: 4981:    *sign_p = false;
        -: 4982:  }
    #####: 4983:  memset (digits_p, 0, digit_count * sizeof (uint64_t));
        -: 4984:#endif /* JERRY_BUILTIN_BIGINT */
    #####: 4985:} /* jerry_bigint_to_digits */
        -: 4986:
        -: 4987:/**
        -: 4988: * Get the target object of a Proxy object
        -: 4989: *
        -: 4990: * @return type error - if proxy_value is not a Proxy object
        -: 4991: *         target object - otherwise
        -: 4992: */
        -: 4993:jerry_value_t
    #####: 4994:jerry_proxy_target (const jerry_value_t proxy_value) /**< proxy value */
        -: 4995:{
        -: 4996:  jerry_assert_api_enabled ();
        -: 4997:
        -: 4998:#if JERRY_BUILTIN_PROXY
    #####: 4999:  if (ecma_is_value_object (proxy_value))
        -: 5000:  {
    #####: 5001:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5002:
    #####: 5003:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5004:    {
    #####: 5005:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5006:
    #####: 5007:      if (!ecma_is_value_null (proxy_object_p->target))
        -: 5008:      {
    #####: 5009:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->target));
        -: 5010:      }
    #####: 5011:      return proxy_object_p->target;
        -: 5012:    }
        -: 5013:  }
        -: 5014:#else /* !JERRY_BUILTIN_PROXY */
        -: 5015:  JERRY_UNUSED (proxy_value);
        -: 5016:#endif /* JERRY_BUILTIN_PROXY */
        -: 5017:
    #####: 5018:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_ARGUMENT_IS_NOT_A_PROXY));
        -: 5019:} /* jerry_proxy_target */
        -: 5020:
        -: 5021:/**
        -: 5022: * Get the handler object of a Proxy object
        -: 5023: *
        -: 5024: * @return type error - if proxy_value is not a Proxy object
        -: 5025: *         handler object - otherwise
        -: 5026: */
        -: 5027:jerry_value_t
    #####: 5028:jerry_proxy_handler (const jerry_value_t proxy_value) /**< proxy value */
        -: 5029:{
        -: 5030:  jerry_assert_api_enabled ();
        -: 5031:
        -: 5032:#if JERRY_BUILTIN_PROXY
    #####: 5033:  if (ecma_is_value_object (proxy_value))
        -: 5034:  {
    #####: 5035:    ecma_object_t *object_p = ecma_get_object_from_value (proxy_value);
        -: 5036:
    #####: 5037:    if (ECMA_OBJECT_IS_PROXY (object_p))
        -: 5038:    {
    #####: 5039:      ecma_proxy_object_t *proxy_object_p = (ecma_proxy_object_t *) object_p;
        -: 5040:
    #####: 5041:      if (!ecma_is_value_null (proxy_object_p->handler))
        -: 5042:      {
    #####: 5043:        ecma_ref_object (ecma_get_object_from_value (proxy_object_p->handler));
        -: 5044:      }
    #####: 5045:      return proxy_object_p->handler;
        -: 5046:    }
        -: 5047:  }
        -: 5048:#else /* !JERRY_BUILTIN_PROXY */
        -: 5049:  JERRY_UNUSED (proxy_value);
        -: 5050:#endif /* JERRY_BUILTIN_PROXY */
        -: 5051:
    #####: 5052:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_ARGUMENT_IS_NOT_A_PROXY));
        -: 5053:} /* jerry_proxy_handler */
        -: 5054:
        -: 5055:/**
        -: 5056: * Validate string buffer for the specified encoding
        -: 5057: *
        -: 5058: * @return true - if string is well-formed
        -: 5059: *         false - otherwise
        -: 5060: */
        -: 5061:bool
        7: 5062:jerry_validate_string (const jerry_char_t *buffer_p, /**< string buffer */
        -: 5063:                       jerry_size_t buffer_size, /**< buffer size */
        -: 5064:                       jerry_encoding_t encoding) /**< buffer encoding */
        -: 5065:{
        7: 5066:  switch (encoding)
        -: 5067:  {
        5: 5068:    case JERRY_ENCODING_CESU8:
        -: 5069:    {
        5: 5070:      return lit_is_valid_cesu8_string (buffer_p, buffer_size);
        -: 5071:    }
        2: 5072:    case JERRY_ENCODING_UTF8:
        -: 5073:    {
        2: 5074:      return lit_is_valid_utf8_string (buffer_p, buffer_size, true);
        -: 5075:    }
    #####: 5076:    default:
        -: 5077:    {
    #####: 5078:      return false;
        -: 5079:    }
        -: 5080:  }
        -: 5081:} /* jerry_validate_string */
        -: 5082:
        -: 5083:/**
        -: 5084: * Allocate memory on the engine's heap.
        -: 5085: *
        -: 5086: * Note:
        -: 5087: *      This function may take away memory from the executed JavaScript code.
        -: 5088: *      If any other dynamic memory allocation API is available (e.g., libc
        -: 5089: *      malloc), it should be used instead.
        -: 5090: *
        -: 5091: * @return allocated memory on success
        -: 5092: *         NULL otherwise
        -: 5093: */
        -: 5094:void *
    #####: 5095:jerry_heap_alloc (jerry_size_t size) /**< size of the memory block */
        -: 5096:{
        -: 5097:  jerry_assert_api_enabled ();
        -: 5098:
    #####: 5099:  return jmem_heap_alloc_block_null_on_error (size);
        -: 5100:} /* jerry_heap_alloc */
        -: 5101:
        -: 5102:/**
        -: 5103: * Free memory allocated on the engine's heap.
        -: 5104: */
        -: 5105:void
    #####: 5106:jerry_heap_free (void *mem_p, /**< value returned by jerry_heap_alloc */
        -: 5107:                 jerry_size_t size) /**< same size as passed to jerry_heap_alloc */
        -: 5108:{
        -: 5109:  jerry_assert_api_enabled ();
        -: 5110:
    #####: 5111:  jmem_heap_free_block (mem_p, size);
    #####: 5112:} /* jerry_heap_free */
        -: 5113:
        -: 5114:/**
        -: 5115: * Create an external engine context.
        -: 5116: *
        -: 5117: * @return the pointer to the context.
        -: 5118: */
        -: 5119:jerry_context_t *
    #####: 5120:jerry_context_alloc (jerry_size_t heap_size, /**< the size of heap */
        -: 5121:                     jerry_context_alloc_cb_t alloc, /**< the alloc function */
        -: 5122:                     void *cb_data_p) /**< the cb_data for alloc function */
        -: 5123:{
        -: 5124:  JERRY_UNUSED (heap_size);
        -: 5125:
        -: 5126:#if JERRY_EXTERNAL_CONTEXT
        -: 5127:
        -: 5128:  size_t total_size = sizeof (jerry_context_t) + JMEM_ALIGNMENT;
        -: 5129:
        -: 5130:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5131:  heap_size = JERRY_ALIGNUP (heap_size, JMEM_ALIGNMENT);
        -: 5132:
        -: 5133:  /* Minimum heap size is 1Kbyte. */
        -: 5134:  if (heap_size < 1024)
        -: 5135:  {
        -: 5136:    return NULL;
        -: 5137:  }
        -: 5138:
        -: 5139:  total_size += heap_size;
        -: 5140:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5141:
        -: 5142:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -: 5143:
        -: 5144:  jerry_context_t *context_p = (jerry_context_t *) alloc (total_size, cb_data_p);
        -: 5145:
        -: 5146:  if (context_p == NULL)
        -: 5147:  {
        -: 5148:    return NULL;
        -: 5149:  }
        -: 5150:
        -: 5151:  memset (context_p, 0, total_size);
        -: 5152:
        -: 5153:  uintptr_t context_ptr = ((uintptr_t) context_p) + sizeof (jerry_context_t);
        -: 5154:  context_ptr = JERRY_ALIGNUP (context_ptr, (uintptr_t) JMEM_ALIGNMENT);
        -: 5155:
        -: 5156:  uint8_t *byte_p = (uint8_t *) context_ptr;
        -: 5157:
        -: 5158:#if !JERRY_SYSTEM_ALLOCATOR
        -: 5159:  context_p->heap_p = (jmem_heap_t *) byte_p;
        -: 5160:  context_p->heap_size = heap_size;
        -: 5161:  byte_p += heap_size;
        -: 5162:#endif /* !JERRY_SYSTEM_ALLOCATOR */
        -: 5163:
        -: 5164:  JERRY_ASSERT (byte_p <= ((uint8_t *) context_p) + total_size);
        -: 5165:
        -: 5166:  JERRY_UNUSED (byte_p);
        -: 5167:  return context_p;
        -: 5168:
        -: 5169:#else /* !JERRY_EXTERNAL_CONTEXT */
        -: 5170:
        -: 5171:  JERRY_UNUSED (alloc);
        -: 5172:  JERRY_UNUSED (cb_data_p);
        -: 5173:
    #####: 5174:  return NULL;
        -: 5175:
        -: 5176:#endif /* JERRY_EXTERNAL_CONTEXT */
        -: 5177:} /* jerry_context_alloc */
        -: 5178:
        -: 5179:/**
        -: 5180: * When JERRY_VM_HALT is enabled, the callback passed to this function
        -: 5181: * is periodically called with the user_p argument. If interval is greater
        -: 5182: * than 1, the callback is only called at every interval ticks.
        -: 5183: */
        -: 5184:void
    #####: 5185:jerry_halt_handler (uint32_t interval, /**< interval of the function call */
        -: 5186:                    jerry_halt_cb_t callback, /**< periodically called user function */
        -: 5187:                    void *user_p) /**< pointer passed to the function */
        -: 5188:{
        -: 5189:#if JERRY_VM_HALT
    #####: 5190:  if (interval == 0)
        -: 5191:  {
    #####: 5192:    interval = 1;
        -: 5193:  }
        -: 5194:
    #####: 5195:  JERRY_CONTEXT (vm_exec_stop_frequency) = interval;
    #####: 5196:  JERRY_CONTEXT (vm_exec_stop_counter) = interval;
    #####: 5197:  JERRY_CONTEXT (vm_exec_stop_cb) = callback;
    #####: 5198:  JERRY_CONTEXT (vm_exec_stop_user_p) = user_p;
        -: 5199:#else /* !JERRY_VM_HALT */
        -: 5200:  JERRY_UNUSED (interval);
        -: 5201:  JERRY_UNUSED (callback);
        -: 5202:  JERRY_UNUSED (user_p);
        -: 5203:#endif /* JERRY_VM_HALT */
    #####: 5204:} /* jerry_halt_handler */
        -: 5205:
        -: 5206:/**
        -: 5207: * Get backtrace. The backtrace is an array of strings where
        -: 5208: * each string contains the position of the corresponding frame.
        -: 5209: * The array length is zero if the backtrace is not available.
        -: 5210: *
        -: 5211: * @return array value
        -: 5212: */
        -: 5213:jerry_value_t
    #####: 5214:jerry_backtrace (uint32_t max_depth) /**< depth limit of the backtrace */
        -: 5215:{
    #####: 5216:  return vm_get_backtrace (max_depth);
        -: 5217:} /* jerry_backtrace */
        -: 5218:
        -: 5219:/**
        -: 5220: * Low-level function to capture each backtrace frame.
        -: 5221: * The captured frame data is passed to a callback function.
        -: 5222: */
        -: 5223:void
    #####: 5224:jerry_backtrace_capture (jerry_backtrace_cb_t callback, /**< callback function */
        -: 5225:                         void *user_p) /**< user pointer passed to the callback function */
        -: 5226:{
    #####: 5227:  jerry_frame_t frame;
    #####: 5228:  vm_frame_ctx_t *context_p = JERRY_CONTEXT (vm_top_context_p);
        -: 5229:
    #####: 5230:  while (context_p != NULL)
        -: 5231:  {
    #####: 5232:    frame.context_p = context_p;
    #####: 5233:    frame.frame_type = JERRY_BACKTRACE_FRAME_JS;
        -: 5234:
    #####: 5235:    if (!callback (&frame, user_p))
        -: 5236:    {
    #####: 5237:      return;
        -: 5238:    }
        -: 5239:
    #####: 5240:    context_p = context_p->prev_context_p;
        -: 5241:  }
        -: 5242:} /* jerry_backtrace */
        -: 5243:
        -: 5244:/**
        -: 5245: * Returns with the type of the backtrace frame.
        -: 5246: *
        -: 5247: * @return frame type listed in jerry_frame_type_t
        -: 5248: */
        -: 5249:jerry_frame_type_t
    #####: 5250:jerry_frame_type (const jerry_frame_t *frame_p) /**< frame pointer */
        -: 5251:{
    #####: 5252:  return (jerry_frame_type_t) frame_p->frame_type;
        -: 5253:} /* jerry_frame_type */
        -: 5254:
        -: 5255:/**
        -: 5256: * Initialize and return with the location private field of a backtrace frame.
        -: 5257: *
        -: 5258: * @return pointer to the location private field - if the location is available,
        -: 5259: *         NULL - otherwise
        -: 5260: */
        -: 5261:const jerry_frame_location_t *
    #####: 5262:jerry_frame_location (jerry_frame_t *frame_p) /**< frame pointer */
        -: 5263:{
        -: 5264:  JERRY_UNUSED (frame_p);
        -: 5265:
        -: 5266:#if JERRY_LINE_INFO
    #####: 5267:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5268:  {
    #####: 5269:    vm_frame_ctx_t *context_p = frame_p->context_p;
    #####: 5270:    const ecma_compiled_code_t *bytecode_header_p = context_p->shared_p->bytecode_header_p;
        -: 5271:
    #####: 5272:    if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_HAS_LINE_INFO))
        -: 5273:    {
    #####: 5274:      return NULL;
        -: 5275:    }
        -: 5276:
    #####: 5277:    frame_p->location.source_name = ecma_get_source_name (bytecode_header_p);
        -: 5278:
    #####: 5279:    ecma_line_info_get (ecma_compiled_code_get_line_info (bytecode_header_p),
    #####: 5280:                        (uint32_t) (context_p->byte_code_p - context_p->byte_code_start_p),
        -: 5281:                        &frame_p->location);
        -: 5282:
    #####: 5283:    return &frame_p->location;
        -: 5284:  }
        -: 5285:#endif /* JERRY_LINE_INFO */
        -: 5286:
    #####: 5287:  return NULL;
        -: 5288:} /* jerry_frame_location */
        -: 5289:
        -: 5290:/**
        -: 5291: * Initialize and return with the called function private field of a backtrace frame.
        -: 5292: * The backtrace frame is created for running the code bound to this function.
        -: 5293: *
        -: 5294: * @return pointer to the called function - if the function is available,
        -: 5295: *         NULL - otherwise
        -: 5296: */
        -: 5297:const jerry_value_t *
    #####: 5298:jerry_frame_callee (jerry_frame_t *frame_p) /**< frame pointer */
        -: 5299:{
    #####: 5300:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5301:  {
    #####: 5302:    vm_frame_ctx_t *context_p = frame_p->context_p;
        -: 5303:
    #####: 5304:    if (context_p->shared_p->function_object_p != NULL)
        -: 5305:    {
    #####: 5306:      frame_p->function = ecma_make_object_value (context_p->shared_p->function_object_p);
    #####: 5307:      return &frame_p->function;
        -: 5308:    }
        -: 5309:  }
        -: 5310:
    #####: 5311:  return NULL;
        -: 5312:} /* jerry_frame_callee */
        -: 5313:
        -: 5314:/**
        -: 5315: * Initialize and return with the 'this' binding private field of a backtrace frame.
        -: 5316: * The 'this' binding is a hidden value passed to the called function. As for arrow
        -: 5317: * functions, the 'this' binding is assigned at function creation.
        -: 5318: *
        -: 5319: * @return pointer to the 'this' binding - if the binding is available,
        -: 5320: *         NULL - otherwise
        -: 5321: */
        -: 5322:const jerry_value_t *
    #####: 5323:jerry_frame_this (jerry_frame_t *frame_p) /**< frame pointer */
        -: 5324:{
    #####: 5325:  if (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS)
        -: 5326:  {
    #####: 5327:    frame_p->this_binding = frame_p->context_p->this_binding;
    #####: 5328:    return &frame_p->this_binding;
        -: 5329:  }
        -: 5330:
    #####: 5331:  return NULL;
        -: 5332:} /* jerry_frame_this */
        -: 5333:
        -: 5334:/**
        -: 5335: * Returns true, if the code bound to the backtrace frame is strict mode code.
        -: 5336: *
        -: 5337: * @return true - if strict mode code is bound to the frame,
        -: 5338: *         false - otherwise
        -: 5339: */
        -: 5340:bool
    #####: 5341:jerry_frame_is_strict (jerry_frame_t *frame_p) /**< frame pointer */
        -: 5342:{
    #####: 5343:  return (frame_p->frame_type == JERRY_BACKTRACE_FRAME_JS
    #####: 5344:          && (frame_p->context_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0);
        -: 5345:} /* jerry_frame_is_strict */
        -: 5346:
        -: 5347:/**
        -: 5348: * Get the source name (usually a file name) of the currently executed script or the given function object
        -: 5349: *
        -: 5350: * Note: returned value must be freed with jerry_value_free, when it is no longer needed
        -: 5351: *
        -: 5352: * @return JS string constructed from
        -: 5353: *         - the currently executed function object's source name, if the given value is undefined
        -: 5354: *         - source name of the function object, if the given value is a function object
        -: 5355: *         - "<anonymous>", otherwise
        -: 5356: */
        -: 5357:jerry_value_t
    #####: 5358:jerry_source_name (const jerry_value_t value) /**< jerry api value */
        -: 5359:{
        -: 5360:#if JERRY_SOURCE_NAME
    #####: 5361:  if (ecma_is_value_undefined (value) && JERRY_CONTEXT (vm_top_context_p) != NULL)
        -: 5362:  {
    #####: 5363:    return ecma_copy_value (ecma_get_source_name (JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p));
        -: 5364:  }
        -: 5365:
    #####: 5366:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5367:
    #####: 5368:  if (script_value == JMEM_CP_NULL)
        -: 5369:  {
    #####: 5370:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 5371:  }
        -: 5372:
    #####: 5373:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5374:
    #####: 5375:  return ecma_copy_value (script_p->source_name);
        -: 5376:#else /* !JERRY_SOURCE_NAME */
        -: 5377:  JERRY_UNUSED (value);
        -: 5378:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 5379:#endif /* JERRY_SOURCE_NAME */
        -: 5380:} /* jerry_source_name */
        -: 5381:
        -: 5382:/**
        -: 5383: * Returns the user value assigned to a script / module / function.
        -: 5384: *
        -: 5385: * Note:
        -: 5386: *    This value is usually set by the parser when
        -: 5387: *    the JERRY_PARSE_HAS_USER_VALUE flag is passed.
        -: 5388: *
        -: 5389: * @return user value
        -: 5390: */
        -: 5391:jerry_value_t
    #####: 5392:jerry_source_user_value (const jerry_value_t value) /**< jerry api value */
        -: 5393:{
    #####: 5394:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5395:
    #####: 5396:  if (script_value == JMEM_CP_NULL)
        -: 5397:  {
    #####: 5398:    return ECMA_VALUE_UNDEFINED;
        -: 5399:  }
        -: 5400:
    #####: 5401:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5402:
    #####: 5403:  if (!(script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE))
        -: 5404:  {
    #####: 5405:    return ECMA_VALUE_UNDEFINED;
        -: 5406:  }
        -: 5407:
    #####: 5408:  return ecma_copy_value (CBC_SCRIPT_GET_USER_VALUE (script_p));
        -: 5409:} /* jerry_source_user_value */
        -: 5410:
        -: 5411:/**
        -: 5412: * Checks whether an ECMAScript code is compiled by eval
        -: 5413: * like (eval, new Function, jerry_eval, etc.) command.
        -: 5414: *
        -: 5415: * @return true, if code is compiled by eval like command
        -: 5416: *         false, otherwise
        -: 5417: */
        -: 5418:bool
    #####: 5419:jerry_function_is_dynamic (const jerry_value_t value) /**< jerry api value */
        -: 5420:{
    #####: 5421:  ecma_value_t script_value = ecma_script_get_from_value (value);
        -: 5422:
    #####: 5423:  if (script_value == JMEM_CP_NULL)
        -: 5424:  {
    #####: 5425:    return false;
        -: 5426:  }
        -: 5427:
    #####: 5428:  const cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5429:
    #####: 5430:  return (script_p->refs_and_type & CBC_SCRIPT_IS_EVAL_CODE) != 0;
        -: 5431:} /* jerry_function_is_dynamic */
        -: 5432:
        -: 5433:/**
        -: 5434: * Returns a newly created source info structure corresponding to the passed script/module/function.
        -: 5435: *
        -: 5436: * @return a newly created source info, if at least one field is available, NULL otherwise
        -: 5437: */
        -: 5438:jerry_source_info_t *
    #####: 5439:jerry_source_info (const jerry_value_t value) /**< jerry api value */
        -: 5440:{
        -: 5441:  jerry_assert_api_enabled ();
        -: 5442:
        -: 5443:#if JERRY_FUNCTION_TO_STRING
    #####: 5444:  if (!ecma_is_value_object (value))
        -: 5445:  {
        -: 5446:    return NULL;
        -: 5447:  }
        -: 5448:
        -: 5449:  jerry_source_info_t source_info;
        -: 5450:
    #####: 5451:  source_info.enabled_fields = 0;
    #####: 5452:  source_info.source_code = ECMA_VALUE_UNDEFINED;
    #####: 5453:  source_info.function_arguments = ECMA_VALUE_UNDEFINED;
    #####: 5454:  source_info.source_range_start = 0;
    #####: 5455:  source_info.source_range_length = 0;
        -: 5456:
    #####: 5457:  ecma_object_t *object_p = ecma_get_object_from_value (value);
    #####: 5458:  cbc_script_t *script_p = NULL;
        -: 5459:
        -: 5460:  while (true)
        -: 5461:  {
    #####: 5462:    switch (ecma_get_object_type (object_p))
        -: 5463:    {
    #####: 5464:      case ECMA_OBJECT_TYPE_CLASS:
        -: 5465:      {
    #####: 5466:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####: 5467:        const ecma_compiled_code_t *bytecode_p = NULL;
        -: 5468:
    #####: 5469:        if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_SCRIPT)
        -: 5470:        {
    #####: 5471:          bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, ext_object_p->u.cls.u3.value);
        -: 5472:        }
        -: 5473:#if JERRY_MODULE_SYSTEM
    #####: 5474:        else if (ext_object_p->u.cls.type == ECMA_OBJECT_CLASS_MODULE)
        -: 5475:        {
    #####: 5476:          ecma_module_t *module_p = (ecma_module_t *) object_p;
        -: 5477:
    #####: 5478:          if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE))
        -: 5479:          {
    #####: 5480:            bytecode_p = module_p->u.compiled_code_p;
        -: 5481:          }
        -: 5482:        }
        -: 5483:#endif /* JERRY_MODULE_SYSTEM */
        -: 5484:
    #####: 5485:        if (bytecode_p == NULL)
        -: 5486:        {
        -: 5487:          return NULL;
        -: 5488:        }
        -: 5489:
    #####: 5490:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5491:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5492:        break;
        -: 5493:      }
    #####: 5494:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 5495:      {
        -: 5496:        const ecma_compiled_code_t *bytecode_p;
    #####: 5497:        bytecode_p = ecma_op_function_get_compiled_code ((ecma_extended_object_t *) object_p);
        -: 5498:
    #####: 5499:        ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 5500:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 5501:
    #####: 5502:        if (bytecode_p->status_flags & CBC_CODE_FLAGS_HAS_EXTENDED_INFO)
        -: 5503:        {
    #####: 5504:          uint8_t *extended_info_p = ecma_compiled_code_resolve_extended_info (bytecode_p);
    #####: 5505:          uint8_t extended_info = *extended_info_p;
        -: 5506:
        -: 5507:#if JERRY_ESNEXT
    #####: 5508:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH)
        -: 5509:          {
    #####: 5510:            ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5511:          }
        -: 5512:#endif /* JERRY_ESNEXT */
        -: 5513:
    #####: 5514:          if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 5515:          {
    #####: 5516:            ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5517:
    #####: 5518:            ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5519:
    #####: 5520:            source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5521:            source_info.source_code = function_arguments;
    #####: 5522:            script_p = NULL;
        -: 5523:          }
        -: 5524:
    #####: 5525:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_RANGE;
    #####: 5526:          source_info.source_range_start = ecma_extended_info_decode_vlq (&extended_info_p);
    #####: 5527:          source_info.source_range_length = ecma_extended_info_decode_vlq (&extended_info_p);
        -: 5528:        }
        -: 5529:
        -: 5530:        JERRY_ASSERT (script_p != NULL || (source_info.enabled_fields & JERRY_SOURCE_INFO_HAS_SOURCE_CODE));
        -: 5531:
    #####: 5532:        if (source_info.enabled_fields == 0 && (script_p->refs_and_type & CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS))
        -: 5533:        {
    #####: 5534:          ecma_value_t function_arguments = CBC_SCRIPT_GET_FUNCTION_ARGUMENTS (script_p, script_p->refs_and_type);
        -: 5535:
    #####: 5536:          ecma_ref_ecma_string (ecma_get_string_from_value (function_arguments));
        -: 5537:
    #####: 5538:          source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_FUNCTION_ARGUMENTS;
    #####: 5539:          source_info.function_arguments = function_arguments;
        -: 5540:        }
        -: 5541:        break;
        -: 5542:      }
    #####: 5543:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 5544:      {
    #####: 5545:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 5546:
    #####: 5547:        object_p =
    #####: 5548:          ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_object_p->u.bound_function.target_function);
    #####: 5549:        continue;
        -: 5550:      }
        -: 5551:#if JERRY_ESNEXT
    #####: 5552:      case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
        -: 5553:      {
    #####: 5554:        ecma_value_t script_value = ((ecma_extended_object_t *) object_p)->u.constructor_function.script_value;
    #####: 5555:        script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
    #####: 5556:        break;
        -: 5557:      }
        -: 5558:#endif /* JERRY_ESNEXT */
        -: 5559:      default:
        -: 5560:      {
        -: 5561:        return NULL;
        -: 5562:      }
        -: 5563:    }
        -: 5564:
        -: 5565:    break;
        -: 5566:  }
        -: 5567:
    #####: 5568:  jerry_source_info_t *source_info_p = jmem_heap_alloc_block_null_on_error (sizeof (jerry_source_info_t));
        -: 5569:
    #####: 5570:  if (source_info_p == NULL)
        -: 5571:  {
        -: 5572:    return NULL;
        -: 5573:  }
        -: 5574:
    #####: 5575:  if (script_p != NULL)
        -: 5576:  {
    #####: 5577:    ecma_ref_ecma_string (ecma_get_string_from_value (script_p->source_code));
        -: 5578:
    #####: 5579:    source_info.enabled_fields |= JERRY_SOURCE_INFO_HAS_SOURCE_CODE;
    #####: 5580:    source_info.source_code = script_p->source_code;
        -: 5581:  }
        -: 5582:
        -: 5583:  JERRY_ASSERT (source_info.enabled_fields != 0);
        -: 5584:
    #####: 5585:  *source_info_p = source_info;
    #####: 5586:  return source_info_p;
        -: 5587:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5588:  JERRY_UNUSED (value);
    #####: 5589:  return NULL;
        -: 5590:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 5591:} /* jerry_source_info */
        -: 5592:
        -: 5593:/**
        -: 5594: * Frees the the source info structure returned by jerry_source_info.
        -: 5595: */
        -: 5596:void
    #####: 5597:jerry_source_info_free (jerry_source_info_t *source_info_p) /**< source info block */
        -: 5598:{
        -: 5599:  jerry_assert_api_enabled ();
        -: 5600:
        -: 5601:#if JERRY_FUNCTION_TO_STRING
    #####: 5602:  if (source_info_p != NULL)
        -: 5603:  {
    #####: 5604:    ecma_free_value (source_info_p->source_code);
    #####: 5605:    ecma_free_value (source_info_p->function_arguments);
    #####: 5606:    jmem_heap_free_block (source_info_p, sizeof (jerry_source_info_t));
        -: 5607:  }
        -: 5608:#else /* !JERRY_FUNCTION_TO_STRING */
        -: 5609:  JERRY_UNUSED (source_info_p);
        -: 5610:#endif /* JERRY_FUNCTION_TO_STRING */
    #####: 5611:} /* jerry_source_info_free */
        -: 5612:
        -: 5613:/**
        -: 5614: * Replaces the currently active realm with another realm.
        -: 5615: *
        -: 5616: * The replacement should be temporary, and the original realm must be
        -: 5617: * restored after the tasks are completed. During the replacement, the
        -: 5618: * realm must be referenced by the application (i.e. the gc must not
        -: 5619: * reclaim it). This is also true to the returned previously active
        -: 5620: * realm, so there is no need to free the value after the restoration.
        -: 5621: *
        -: 5622: * @return previous realm value - if the passed value is a realm
        -: 5623: *         exception - otherwise
        -: 5624: */
        -: 5625:jerry_value_t
    #####: 5626:jerry_set_realm (jerry_value_t realm_value) /**< jerry api value */
        -: 5627:{
        -: 5628:  jerry_assert_api_enabled ();
        -: 5629:
        -: 5630:#if JERRY_BUILTIN_REALMS
    #####: 5631:  if (ecma_is_value_object (realm_value))
        -: 5632:  {
    #####: 5633:    ecma_object_t *object_p = ecma_get_object_from_value (realm_value);
        -: 5634:
    #####: 5635:    if (ecma_builtin_is_global (object_p))
        -: 5636:    {
    #####: 5637:      ecma_global_object_t *previous_global_object_p = JERRY_CONTEXT (global_object_p);
    #####: 5638:      JERRY_CONTEXT (global_object_p) = (ecma_global_object_t *) object_p;
    #####: 5639:      return ecma_make_object_value ((ecma_object_t *) previous_global_object_p);
        -: 5640:    }
        -: 5641:  }
        -: 5642:
    #####: 5643:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PASSED_ARGUMENT_IS_NOT_A_REALM));
        -: 5644:#else /* !JERRY_BUILTIN_REALMS */
        -: 5645:  JERRY_UNUSED (realm_value);
    #####: 5646:  return jerry_throw_sz (JERRY_ERROR_REFERENCE, ecma_get_error_msg (ECMA_ERR_REALM_IS_NOT_AVAILABLE));
        -: 5647:#endif /* JERRY_BUILTIN_REALMS */
        -: 5648:} /* jerry_set_realm */
        -: 5649:
        -: 5650:/**
        -: 5651: * Gets the 'this' binding of a realm
        -: 5652: *
        -: 5653: * @return type error - if realm_value is not a realm
        -: 5654: *         this value - otherwise
        -: 5655: */
        -: 5656:jerry_value_t
    #####: 5657:jerry_realm_this (jerry_value_t realm) /**< realm value */
        -: 5658:{
        -: 5659:  jerry_assert_api_enabled ();
        -: 5660:
        -: 5661:#if JERRY_BUILTIN_REALMS
    #####: 5662:  if (ecma_is_value_object (realm))
        -: 5663:  {
    #####: 5664:    ecma_object_t *object_p = ecma_get_object_from_value (realm);
        -: 5665:
    #####: 5666:    if (ecma_builtin_is_global (object_p))
        -: 5667:    {
    #####: 5668:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
        -: 5669:
    #####: 5670:      ecma_ref_object (ecma_get_object_from_value (global_object_p->this_binding));
    #####: 5671:      return global_object_p->this_binding;
        -: 5672:    }
        -: 5673:  }
        -: 5674:
        -: 5675:#else /* !JERRY_BUILTIN_REALMS */
    #####: 5676:  ecma_object_t *global_object_p = ecma_builtin_get_global ();
        -: 5677:
    #####: 5678:  if (realm == ecma_make_object_value (global_object_p))
        -: 5679:  {
    #####: 5680:    ecma_ref_object (global_object_p);
    #####: 5681:    return realm;
        -: 5682:  }
        -: 5683:#endif /* JERRY_BUILTIN_REALMS */
        -: 5684:
    #####: 5685:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_PASSED_ARGUMENT_IS_NOT_A_REALM));
        -: 5686:} /* jerry_realm_this */
        -: 5687:
        -: 5688:/**
        -: 5689: * Sets the 'this' binding of a realm
        -: 5690: *
        -: 5691: * This function must be called before executing any script on the realm.
        -: 5692: * Otherwise the operation is undefined.
        -: 5693: *
        -: 5694: * @return type error - if realm_value is not a realm or this_value is not object
        -: 5695: *         true - otherwise
        -: 5696: */
        -: 5697:jerry_value_t
    #####: 5698:jerry_realm_set_this (jerry_value_t realm, /**< realm value */
        -: 5699:                      jerry_value_t this_value) /**< this value */
        -: 5700:{
        -: 5701:  jerry_assert_api_enabled ();
        -: 5702:
        -: 5703:#if JERRY_BUILTIN_REALMS
    #####: 5704:  if (!ecma_is_value_object (this_value))
        -: 5705:  {
    #####: 5706:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SECOND_ARGUMENT_MUST_BE_AN_OBJECT));
        -: 5707:  }
        -: 5708:
    #####: 5709:  if (ecma_is_value_object (realm))
        -: 5710:  {
    #####: 5711:    ecma_object_t *object_p = ecma_get_object_from_value (realm);
        -: 5712:
    #####: 5713:    if (ecma_builtin_is_global (object_p))
        -: 5714:    {
    #####: 5715:      ecma_global_object_t *global_object_p = (ecma_global_object_t *) object_p;
    #####: 5716:      global_object_p->this_binding = this_value;
        -: 5717:
    #####: 5718:      ecma_object_t *global_lex_env_p = ecma_create_object_lex_env (NULL, ecma_get_object_from_value (this_value));
        -: 5719:
    #####: 5720:      ECMA_SET_NON_NULL_POINTER (global_object_p->global_env_cp, global_lex_env_p);
        -: 5721:#if JERRY_ESNEXT
    #####: 5722:      global_object_p->global_scope_cp = global_object_p->global_env_cp;
        -: 5723:#endif /* JERRY_ESNEXT */
    #####: 5724:      ecma_deref_object (global_lex_env_p);
    #####: 5725:      return ECMA_VALUE_TRUE;
        -: 5726:    }
        -: 5727:  }
        -: 5728:
    #####: 5729:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_FIRST_ARGUMENT_IS_NOT_A_REALM));
        -: 5730:#else /* !JERRY_BUILTIN_REALMS */
        -: 5731:  JERRY_UNUSED (realm);
        -: 5732:  JERRY_UNUSED (this_value);
    #####: 5733:  return jerry_throw_sz (JERRY_ERROR_REFERENCE, ecma_get_error_msg (ECMA_ERR_REALM_IS_NOT_AVAILABLE));
        -: 5734:#endif /* JERRY_BUILTIN_REALMS */
        -: 5735:} /* jerry_realm_set_this */
        -: 5736:
        -: 5737:/**
        -: 5738: * Check if the given value is an ArrayBuffer object.
        -: 5739: *
        -: 5740: * @return true - if it is an ArrayBuffer object
        -: 5741: *         false - otherwise
        -: 5742: */
        -: 5743:bool
    #####: 5744:jerry_value_is_arraybuffer (const jerry_value_t value) /**< value to check if it is an ArrayBuffer */
        -: 5745:{
        -: 5746:  jerry_assert_api_enabled ();
        -: 5747:
        -: 5748:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5749:  return ecma_is_arraybuffer (value);
        -: 5750:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5751:  JERRY_UNUSED (value);
    #####: 5752:  return false;
        -: 5753:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5754:} /* jerry_value_is_arraybuffer */
        -: 5755:
        -: 5756:/**
        -: 5757: * Creates an ArrayBuffer object with the given length (size).
        -: 5758: *
        -: 5759: * Notes:
        -: 5760: *      * the length is specified in bytes.
        -: 5761: *      * returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 5762: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5763: *
        -: 5764: * @return value of the constructed ArrayBuffer object
        -: 5765: */
        -: 5766:jerry_value_t
    #####: 5767:jerry_arraybuffer (const jerry_length_t size) /**< size of the backing store allocated
        -: 5768:                                               *   for the array buffer in bytes */
        -: 5769:{
        -: 5770:  jerry_assert_api_enabled ();
        -: 5771:
        -: 5772:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5773:  return jerry_return (ecma_make_object_value (ecma_arraybuffer_new_object (size)));
        -: 5774:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5775:  JERRY_UNUSED (size);
    #####: 5776:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 5777:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5778:} /* jerry_arraybuffer */
        -: 5779:
        -: 5780:/**
        -: 5781: * Creates an ArrayBuffer object with user specified buffer.
        -: 5782: *
        -: 5783: * Notes:
        -: 5784: *     * the size is specified in bytes.
        -: 5785: *     * the buffer passed should be at least the specified bytes big.
        -: 5786: *     * if the typed arrays are disabled this will return a TypeError.
        -: 5787: *     * if the size is zero or buffer_p is a null pointer this will return an empty ArrayBuffer.
        -: 5788: *
        -: 5789: * @return value of the newly constructed array buffer object
        -: 5790: */
        -: 5791:jerry_value_t
    #####: 5792:jerry_arraybuffer_external (uint8_t *buffer_p, /**< the backing store used by the array buffer object */
        -: 5793:                            const jerry_length_t size, /**< size of the buffer in bytes */
        -: 5794:                            void *user_p) /**< user pointer assigned to the array buffer object */
        -: 5795:{
        -: 5796:  jerry_assert_api_enabled ();
        -: 5797:
        -: 5798:#if JERRY_BUILTIN_TYPEDARRAY
        -: 5799:  ecma_object_t *arraybuffer_p;
        -: 5800:
    #####: 5801:  if (JERRY_UNLIKELY (size == 0))
        -: 5802:  {
    #####: 5803:    arraybuffer_p = ecma_arraybuffer_new_object (0);
        -: 5804:  }
        -: 5805:  else
        -: 5806:  {
    #####: 5807:    arraybuffer_p = ecma_arraybuffer_create_object_with_buffer (ECMA_OBJECT_CLASS_ARRAY_BUFFER, size);
        -: 5808:
    #####: 5809:    ecma_arraybuffer_pointer_t *arraybuffer_pointer_p = (ecma_arraybuffer_pointer_t *) arraybuffer_p;
    #####: 5810:    arraybuffer_pointer_p->arraybuffer_user_p = user_p;
        -: 5811:
    #####: 5812:    if (buffer_p != NULL)
        -: 5813:    {
    #####: 5814:      arraybuffer_pointer_p->extended_object.u.cls.u1.array_buffer_flags |= ECMA_ARRAYBUFFER_ALLOCATED;
    #####: 5815:      arraybuffer_pointer_p->buffer_p = buffer_p;
        -: 5816:    }
        -: 5817:  }
        -: 5818:
    #####: 5819:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 5820:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5821:  JERRY_UNUSED (size);
        -: 5822:  JERRY_UNUSED (buffer_p);
        -: 5823:  JERRY_UNUSED (user_p);
    #####: 5824:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 5825:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5826:} /* jerry_arraybuffer_external */
        -: 5827:
        -: 5828:/**
        -: 5829: * Check if the given value is a SharedArrayBuffer object.
        -: 5830: *
        -: 5831: * @return true - if it is a SharedArrayBuffer object
        -: 5832: *         false - otherwise
        -: 5833: */
        -: 5834:bool
    #####: 5835:jerry_value_is_shared_arraybuffer (const jerry_value_t value) /**< value to check if it is a SharedArrayBuffer */
        -: 5836:{
        -: 5837:  jerry_assert_api_enabled ();
        -: 5838:
    #####: 5839:  return ecma_is_shared_arraybuffer (value);
        -: 5840:} /* jerry_value_is_shared_arraybuffer */
        -: 5841:
        -: 5842:/**
        -: 5843: * Creates a SharedArrayBuffer object with the given length (size).
        -: 5844: *
        -: 5845: * Notes:
        -: 5846: *      * the length is specified in bytes.
        -: 5847: *      * returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 5848: *      * if the typed arrays are disabled this will return a TypeError.
        -: 5849: *
        -: 5850: * @return value of the constructed SharedArrayBuffer object
        -: 5851: */
        -: 5852:jerry_value_t
    #####: 5853:jerry_shared_arraybuffer (const jerry_length_t size) /**< size of the backing store allocated
        -: 5854:                                                      *   for the shared array buffer in bytes */
        -: 5855:{
        -: 5856:  jerry_assert_api_enabled ();
        -: 5857:
        -: 5858:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
    #####: 5859:  return jerry_return (ecma_make_object_value (ecma_shared_arraybuffer_new_object (size)));
        -: 5860:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5861:  JERRY_UNUSED (size);
    #####: 5862:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SHARED_ARRAYBUFFER_NOT_SUPPORTED));
        -: 5863:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5864:} /* jerry_shared_arraybuffer */
        -: 5865:
        -: 5866:/**
        -: 5867: * Creates a SharedArrayBuffer object with user specified buffer.
        -: 5868: *
        -: 5869: * Notes:
        -: 5870: *     * the size is specified in bytes.
        -: 5871: *     * the buffer passed should be at least the specified bytes big.
        -: 5872: *     * if the typed arrays are disabled this will return a TypeError.
        -: 5873: *     * if the size is zero or buffer_p is a null pointer this will return an empty SharedArrayBuffer.
        -: 5874: *
        -: 5875: * @return value of the newly constructed shared array buffer object
        -: 5876: */
        -: 5877:jerry_value_t
    #####: 5878:jerry_shared_arraybuffer_external (uint8_t *buffer_p, /**< the backing store used by the
        -: 5879:                                                       *   shared array buffer object */
        -: 5880:                                   const jerry_length_t size, /**< size of the buffer in bytes */
        -: 5881:                                   void *user_p) /**< user pointer assigned to the
        -: 5882:                                                  *   shared array buffer object */
        -: 5883:{
        -: 5884:  jerry_assert_api_enabled ();
        -: 5885:
        -: 5886:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 5887:  ecma_object_t *shared_arraybuffer_p;
        -: 5888:
    #####: 5889:  if (JERRY_UNLIKELY (size == 0))
        -: 5890:  {
    #####: 5891:    shared_arraybuffer_p = ecma_shared_arraybuffer_new_object (0);
        -: 5892:  }
        -: 5893:  else
        -: 5894:  {
    #####: 5895:    shared_arraybuffer_p = ecma_arraybuffer_create_object_with_buffer (ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER, size);
        -: 5896:
    #####: 5897:    ecma_arraybuffer_pointer_t *shared_arraybuffer_pointer_p = (ecma_arraybuffer_pointer_t *) shared_arraybuffer_p;
    #####: 5898:    shared_arraybuffer_pointer_p->arraybuffer_user_p = user_p;
        -: 5899:
    #####: 5900:    if (buffer_p != NULL)
        -: 5901:    {
    #####: 5902:      shared_arraybuffer_pointer_p->extended_object.u.cls.u1.array_buffer_flags |= ECMA_ARRAYBUFFER_ALLOCATED;
    #####: 5903:      shared_arraybuffer_pointer_p->buffer_p = buffer_p;
        -: 5904:    }
        -: 5905:  }
        -: 5906:
    #####: 5907:  return ecma_make_object_value (shared_arraybuffer_p);
        -: 5908:#else /* !JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5909:  JERRY_UNUSED (size);
        -: 5910:  JERRY_UNUSED (buffer_p);
        -: 5911:  JERRY_UNUSED (user_p);
    #####: 5912:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_SHARED_ARRAYBUFFER_NOT_SUPPORTED));
        -: 5913:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 5914:} /* jerry_shared_arraybuffer_external */
        -: 5915:
        -: 5916:#if JERRY_BUILTIN_TYPEDARRAY
        -: 5917:
        -: 5918:/**
        -: 5919: * Allocate a backing store for an array buffer, ignores allocation fails.
        -: 5920: *
        -: 5921: * @return true on success,
        -: 5922: *         false otherwise
        -: 5923: */
        -: 5924:static bool
    #####: 5925:jerry_arraybuffer_allocate_buffer_no_throw (ecma_object_t *arraybuffer_p) /**< ArrayBuffer object */
        -: 5926:{
    #####: 5927:  JERRY_ASSERT (!(ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_ALLOCATED));
        -: 5928:
    #####: 5929:  if (ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_DETACHED)
        -: 5930:  {
    #####: 5931:    return false;
        -: 5932:  }
        -: 5933:
    #####: 5934:  return ecma_arraybuffer_allocate_buffer (arraybuffer_p) != ECMA_VALUE_ERROR;
        -: 5935:} /* jerry_arraybuffer_allocate_buffer_no_throw */
        -: 5936:
        -: 5937:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5938:
        -: 5939:/**
        -: 5940: * Copy bytes into the ArrayBuffer or SharedArrayBuffer from a buffer.
        -: 5941: *
        -: 5942: * Note:
        -: 5943: *     * returns 0, if the passed object is not an ArrayBuffer or SharedArrayBuffer
        -: 5944: *
        -: 5945: * @return number of bytes copied into the ArrayBuffer or SharedArrayBuffer.
        -: 5946: */
        -: 5947:jerry_length_t
    #####: 5948:jerry_arraybuffer_write (const jerry_value_t value, /**< target ArrayBuffer or SharedArrayBuffer */
        -: 5949:                         jerry_length_t offset, /**< start offset of the ArrayBuffer */
        -: 5950:                         const uint8_t *buf_p, /**< buffer to copy from */
        -: 5951:                         jerry_length_t buf_size) /**< number of bytes to copy from the buffer */
        -: 5952:{
        -: 5953:  jerry_assert_api_enabled ();
        -: 5954:
        -: 5955:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 5956:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 5957:  {
    #####: 5958:    return 0;
        -: 5959:  }
        -: 5960:
    #####: 5961:  ecma_object_t *arraybuffer_p = ecma_get_object_from_value (value);
        -: 5962:
    #####: 5963:  if (!(ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_ALLOCATED)
    #####: 5964:      && !jerry_arraybuffer_allocate_buffer_no_throw (arraybuffer_p))
        -: 5965:  {
    #####: 5966:    return 0;
        -: 5967:  }
        -: 5968:
    #####: 5969:  jerry_length_t length = ecma_arraybuffer_get_length (arraybuffer_p);
        -: 5970:
    #####: 5971:  if (offset >= length)
        -: 5972:  {
    #####: 5973:    return 0;
        -: 5974:  }
        -: 5975:
    #####: 5976:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 5977:
    #####: 5978:  if (copy_count > 0)
        -: 5979:  {
    #####: 5980:    lit_utf8_byte_t *buffer_p = ecma_arraybuffer_get_buffer (arraybuffer_p);
        -: 5981:
    #####: 5982:    memcpy ((void *) (buffer_p + offset), (void *) buf_p, copy_count);
        -: 5983:  }
        -: 5984:
    #####: 5985:  return copy_count;
        -: 5986:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 5987:  JERRY_UNUSED (value);
        -: 5988:  JERRY_UNUSED (offset);
        -: 5989:  JERRY_UNUSED (buf_p);
        -: 5990:  JERRY_UNUSED (buf_size);
    #####: 5991:  return 0;
        -: 5992:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 5993:} /* jerry_arraybuffer_write */
        -: 5994:
        -: 5995:/**
        -: 5996: * Copy bytes from a buffer into an ArrayBuffer or SharedArrayBuffer.
        -: 5997: *
        -: 5998: * Note:
        -: 5999: *     * if the object passed is not an ArrayBuffer or SharedArrayBuffer will return 0.
        -: 6000: *
        -: 6001: * @return number of bytes read from the ArrayBuffer.
        -: 6002: */
        -: 6003:jerry_length_t
    #####: 6004:jerry_arraybuffer_read (const jerry_value_t value, /**< ArrayBuffer or SharedArrayBuffer to read from */
        -: 6005:                        jerry_length_t offset, /**< start offset of the ArrayBuffer or SharedArrayBuffer */
        -: 6006:                        uint8_t *buf_p, /**< destination buffer to copy to */
        -: 6007:                        jerry_length_t buf_size) /**< number of bytes to copy into the buffer */
        -: 6008:{
        -: 6009:  jerry_assert_api_enabled ();
        -: 6010:
        -: 6011:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6012:  if (!(ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value)))
        -: 6013:  {
    #####: 6014:    return 0;
        -: 6015:  }
        -: 6016:
    #####: 6017:  ecma_object_t *arraybuffer_p = ecma_get_object_from_value (value);
        -: 6018:
    #####: 6019:  if (!(ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_ALLOCATED)
    #####: 6020:      && !jerry_arraybuffer_allocate_buffer_no_throw (arraybuffer_p))
        -: 6021:  {
    #####: 6022:    return 0;
        -: 6023:  }
        -: 6024:
    #####: 6025:  jerry_length_t length = ecma_arraybuffer_get_length (arraybuffer_p);
        -: 6026:
    #####: 6027:  if (offset >= length)
        -: 6028:  {
    #####: 6029:    return 0;
        -: 6030:  }
        -: 6031:
    #####: 6032:  jerry_length_t copy_count = JERRY_MIN (length - offset, buf_size);
        -: 6033:
    #####: 6034:  if (copy_count > 0)
        -: 6035:  {
    #####: 6036:    lit_utf8_byte_t *buffer_p = ecma_arraybuffer_get_buffer (arraybuffer_p);
        -: 6037:
    #####: 6038:    memcpy ((void *) buf_p, (void *) (buffer_p + offset), copy_count);
        -: 6039:  }
        -: 6040:
    #####: 6041:  return copy_count;
        -: 6042:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6043:  JERRY_UNUSED (value);
        -: 6044:  JERRY_UNUSED (offset);
        -: 6045:  JERRY_UNUSED (buf_p);
        -: 6046:  JERRY_UNUSED (buf_size);
    #####: 6047:  return 0;
        -: 6048:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6049:} /* jerry_arraybuffer_read */
        -: 6050:
        -: 6051:/**
        -: 6052: * Get the length (size) of the ArrayBuffer or SharedArrayBuffer in bytes.
        -: 6053: *
        -: 6054: * Note:
        -: 6055: *     This is the 'byteLength' property of an ArrayBuffer or SharedArrayBuffer.
        -: 6056: *
        -: 6057: * @return the length of the ArrayBuffer in bytes.
        -: 6058: */
        -: 6059:jerry_length_t
    #####: 6060:jerry_arraybuffer_size (const jerry_value_t value) /**< ArrayBuffer or SharedArrayBuffer */
        -: 6061:{
        -: 6062:  jerry_assert_api_enabled ();
        -: 6063:
        -: 6064:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6065:  if (ecma_is_arraybuffer (value) || ecma_is_shared_arraybuffer (value))
        -: 6066:  {
    #####: 6067:    ecma_object_t *arraybuffer_p = ecma_get_object_from_value (value);
    #####: 6068:    return ecma_arraybuffer_get_length (arraybuffer_p);
        -: 6069:  }
        -: 6070:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6071:  JERRY_UNUSED (value);
        -: 6072:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6073:  return 0;
        -: 6074:} /* jerry_arraybuffer_size */
        -: 6075:
        -: 6076:/**
        -: 6077: * Get a pointer for the start of the ArrayBuffer.
        -: 6078: *
        -: 6079: * Note:
        -: 6080: *    * This is a high-risk operation as the bounds are not checked
        -: 6081: *      when accessing the pointer elements.
        -: 6082: *
        -: 6083: * @return pointer to the back-buffer of the ArrayBuffer.
        -: 6084: *         pointer is NULL if:
        -: 6085: *            - the parameter is not an ArrayBuffer
        -: 6086: *            - an external ArrayBuffer has been detached
        -: 6087: */
        -: 6088:uint8_t *
    #####: 6089:jerry_arraybuffer_data (const jerry_value_t array_buffer) /**< Array Buffer to use */
        -: 6090:{
        -: 6091:  jerry_assert_api_enabled ();
        -: 6092:
        -: 6093:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6094:  if (!(ecma_is_arraybuffer (array_buffer) || ecma_is_shared_arraybuffer (array_buffer)))
        -: 6095:  {
    #####: 6096:    return NULL;
        -: 6097:  }
        -: 6098:
    #####: 6099:  ecma_object_t *arraybuffer_p = ecma_get_object_from_value (array_buffer);
        -: 6100:
    #####: 6101:  if (!(ECMA_ARRAYBUFFER_GET_FLAGS (arraybuffer_p) & ECMA_ARRAYBUFFER_ALLOCATED)
    #####: 6102:      && !jerry_arraybuffer_allocate_buffer_no_throw (arraybuffer_p))
        -: 6103:  {
    #####: 6104:    return NULL;
        -: 6105:  }
        -: 6106:
    #####: 6107:  return (uint8_t *) ecma_arraybuffer_get_buffer (arraybuffer_p);
        -: 6108:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6109:  JERRY_UNUSED (array_buffer);
        -: 6110:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6111:
    #####: 6112:  return NULL;
        -: 6113:} /* jerry_arraybuffer_data */
        -: 6114:
        -: 6115:/**
        -: 6116: * Get if the ArrayBuffer is detachable.
        -: 6117: *
        -: 6118: * @return boolean value - if success
        -: 6119: *         value marked with error flag - otherwise
        -: 6120: */
        -: 6121:bool
    #####: 6122:jerry_arraybuffer_is_detachable (const jerry_value_t value) /**< ArrayBuffer */
        -: 6123:{
        -: 6124:  jerry_assert_api_enabled ();
        -: 6125:
        -: 6126:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6127:  if (ecma_is_arraybuffer (value))
        -: 6128:  {
    #####: 6129:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6130:    return !ecma_arraybuffer_is_detached (buffer_p);
        -: 6131:  }
        -: 6132:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6133:  JERRY_UNUSED (value);
        -: 6134:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6135:  return false;
        -: 6136:} /* jerry_arraybuffer_is_detachable */
        -: 6137:
        -: 6138:/**
        -: 6139: * Detach the underlying data block from ArrayBuffer and set its bytelength to 0.
        -: 6140: *
        -: 6141: * Note: if the ArrayBuffer has a separate data buffer, the free callback set by
        -: 6142: *       jerry_arraybuffer_set_allocation_callbacks is called for this buffer
        -: 6143: *
        -: 6144: * @return null value - if success
        -: 6145: *         value marked with error flag - otherwise
        -: 6146: */
        -: 6147:jerry_value_t
    #####: 6148:jerry_arraybuffer_detach (const jerry_value_t value) /**< ArrayBuffer */
        -: 6149:{
        -: 6150:  jerry_assert_api_enabled ();
        -: 6151:
        -: 6152:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6153:  if (ecma_is_arraybuffer (value))
        -: 6154:  {
    #####: 6155:    ecma_object_t *buffer_p = ecma_get_object_from_value (value);
    #####: 6156:    if (ecma_arraybuffer_detach (buffer_p))
        -: 6157:    {
    #####: 6158:      return ECMA_VALUE_NULL;
        -: 6159:    }
    #####: 6160:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_ARRAY_BUFFER_DETACHED));
        -: 6161:  }
        -: 6162:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6163:  JERRY_UNUSED (value);
        -: 6164:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6165:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_EXPECTED_AN_ARRAYBUFFER));
        -: 6166:} /* jerry_arraybuffer_detach */
        -: 6167:
        -: 6168:/**
        -: 6169: * Checks whether a buffer is currently allocated for an array buffer or typed array.
        -: 6170: *
        -: 6171: * @return true, if a buffer is allocated for an array buffer or typed array
        -: 6172: *         false, otherwise
        -: 6173: */
        -: 6174:bool
    #####: 6175:jerry_arraybuffer_has_buffer (const jerry_value_t value) /**< array buffer or typed array value */
        -: 6176:{
        -: 6177:  jerry_assert_api_enabled ();
        -: 6178:
        -: 6179:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6180:  if (!ecma_is_value_object (value))
        -: 6181:  {
    #####: 6182:    return false;
        -: 6183:  }
        -: 6184:
    #####: 6185:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -: 6186:
    #####: 6187:  if (ecma_object_is_typedarray (object_p))
        -: 6188:  {
    #####: 6189:    object_p = ecma_typedarray_get_arraybuffer (object_p);
        -: 6190:  }
    #####: 6191:  else if (!(ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
    #####: 6192:             || ecma_object_is_shared_arraybuffer (object_p)))
        -: 6193:  {
    #####: 6194:    return false;
        -: 6195:  }
        -: 6196:
    #####: 6197:  return (ECMA_ARRAYBUFFER_GET_FLAGS (object_p) & ECMA_ARRAYBUFFER_ALLOCATED) != 0;
        -: 6198:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6199:  JERRY_UNUSED (value);
    #####: 6200:  return false;
        -: 6201:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6202:} /* jerry_arraybuffer_has_buffer */
        -: 6203:
        -: 6204:/**
        -: 6205: * Array buffers which size is less or equal than the limit passed to this function are allocated in
        -: 6206: * a single memory block. The allocator callbacks set by jerry_arraybuffer_set_allocation_callbacks
        -: 6207: * are not called for these array buffers. The default limit is 256 bytes.
        -: 6208: */
        -: 6209:void
    #####: 6210:jerry_arraybuffer_heap_allocation_limit (const jerry_length_t allocation_limit) /**< maximum size of
        -: 6211:                                                                                 *   compact allocation */
        -: 6212:{
        -: 6213:  jerry_assert_api_enabled ();
        -: 6214:
        -: 6215:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6216:  JERRY_CONTEXT (arraybuffer_compact_allocation_limit) = allocation_limit;
        -: 6217:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6218:  JERRY_UNUSED (allocation_limit);
        -: 6219:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6220:} /* jerry_arraybuffer_heap_allocation_limit */
        -: 6221:
        -: 6222:/**
        -: 6223: * Set callbacks for allocating and freeing backing stores for array buffer objects.
        -: 6224: */
        -: 6225:void
    #####: 6226:jerry_arraybuffer_allocator (jerry_arraybuffer_allocate_cb_t allocate_callback, /**< callback for allocating
        -: 6227:                                                                                 *   array buffer memory */
        -: 6228:                             jerry_arraybuffer_free_cb_t free_callback, /**< callback for freeing
        -: 6229:                                                                         *   array buffer memory */
        -: 6230:                             void *user_p) /**< user pointer passed to the callbacks */
        -: 6231:{
        -: 6232:  jerry_assert_api_enabled ();
        -: 6233:
        -: 6234:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6235:  JERRY_CONTEXT (arraybuffer_allocate_callback) = allocate_callback;
    #####: 6236:  JERRY_CONTEXT (arraybuffer_free_callback) = free_callback;
    #####: 6237:  JERRY_CONTEXT (arraybuffer_allocate_callback_user_p) = user_p;
        -: 6238:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6239:  JERRY_UNUSED (allocate_callback);
        -: 6240:  JERRY_UNUSED (free_callback);
        -: 6241:  JERRY_UNUSED (user_p);
        -: 6242:#endif /* JERRY_BUILTIN_TYPEDARRAY */
    #####: 6243:} /* jerry_arraybuffer_allocator */
        -: 6244:
        -: 6245:/**
        -: 6246: * DataView related functions
        -: 6247: */
        -: 6248:
        -: 6249:/**
        -: 6250: * Creates a DataView object with the given ArrayBuffer, ByteOffset and ByteLength arguments.
        -: 6251: *
        -: 6252: * Notes:
        -: 6253: *      * returned value must be freed with jerry_value_free, when it is no longer needed.
        -: 6254: *      * if the DataView bulitin is disabled this will return a TypeError.
        -: 6255: *
        -: 6256: * @return value of the constructed DataView object - if success
        -: 6257: *         created error - otherwise
        -: 6258: */
        -: 6259:jerry_value_t
    #####: 6260:jerry_dataview (const jerry_value_t array_buffer, /**< arraybuffer to create DataView from */
        -: 6261:                const jerry_length_t byte_offset, /**< offset in bytes, to the first byte in the buffer */
        -: 6262:                const jerry_length_t byte_length) /**< number of elements in the byte array */
        -: 6263:{
        -: 6264:  jerry_assert_api_enabled ();
        -: 6265:
        -: 6266:#if JERRY_BUILTIN_DATAVIEW
    #####: 6267:  if (ecma_is_value_exception (array_buffer))
        -: 6268:  {
    #####: 6269:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 6270:  }
        -: 6271:
    #####: 6272:  ecma_value_t arguments_p[3] = { array_buffer,
    #####: 6273:                                  ecma_make_uint32_value (byte_offset),
    #####: 6274:                                  ecma_make_uint32_value (byte_length) };
    #####: 6275:  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);
    #####: 6276:  if (old_new_target_p == NULL)
        -: 6277:  {
    #####: 6278:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ECMA_BUILTIN_ID_DATAVIEW);
        -: 6279:  }
        -: 6280:
    #####: 6281:  ecma_value_t dataview_value = ecma_op_dataview_create (arguments_p, 3);
    #####: 6282:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6283:  return jerry_return (dataview_value);
        -: 6284:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6285:  JERRY_UNUSED (array_buffer);
        -: 6286:  JERRY_UNUSED (byte_offset);
        -: 6287:  JERRY_UNUSED (byte_length);
    #####: 6288:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_DATA_VIEW_NOT_SUPPORTED));
        -: 6289:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6290:} /* jerry_dataview */
        -: 6291:
        -: 6292:/**
        -: 6293: * Check if the given value is a DataView object.
        -: 6294: *
        -: 6295: * @return true - if it is a DataView object
        -: 6296: *         false - otherwise
        -: 6297: */
        -: 6298:bool
    #####: 6299:jerry_value_is_dataview (const jerry_value_t value) /**< value to check if it is a DataView object */
        -: 6300:{
        -: 6301:  jerry_assert_api_enabled ();
        -: 6302:
        -: 6303:#if JERRY_BUILTIN_DATAVIEW
    #####: 6304:  return ecma_is_dataview (value);
        -: 6305:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6306:  JERRY_UNUSED (value);
    #####: 6307:  return false;
        -: 6308:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6309:} /* jerry_value_is_dataview */
        -: 6310:
        -: 6311:/**
        -: 6312: * Get the underlying ArrayBuffer from a DataView.
        -: 6313: *
        -: 6314: * Additionally the byteLength and byteOffset properties are also returned
        -: 6315: * which were specified when the DataView was created.
        -: 6316: *
        -: 6317: * Note:
        -: 6318: *     the returned value must be freed with a jerry_value_free call
        -: 6319: *
        -: 6320: * @return ArrayBuffer of a DataView
        -: 6321: *         TypeError if the object is not a DataView.
        -: 6322: */
        -: 6323:jerry_value_t
    #####: 6324:jerry_dataview_buffer (const jerry_value_t value, /**< DataView to get the arraybuffer from */
        -: 6325:                       jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6326:                       jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6327:{
        -: 6328:  jerry_assert_api_enabled ();
        -: 6329:
        -: 6330:#if JERRY_BUILTIN_DATAVIEW
    #####: 6331:  if (ecma_is_value_exception (value))
        -: 6332:  {
    #####: 6333:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 6334:  }
        -: 6335:
    #####: 6336:  ecma_dataview_object_t *dataview_p = ecma_op_dataview_get_object (value);
        -: 6337:
    #####: 6338:  if (JERRY_UNLIKELY (dataview_p == NULL))
        -: 6339:  {
    #####: 6340:    return ecma_create_exception_from_context ();
        -: 6341:  }
        -: 6342:
    #####: 6343:  if (byte_offset != NULL)
        -: 6344:  {
    #####: 6345:    *byte_offset = dataview_p->byte_offset;
        -: 6346:  }
        -: 6347:
    #####: 6348:  if (byte_length != NULL)
        -: 6349:  {
    #####: 6350:    *byte_length = dataview_p->header.u.cls.u3.length;
        -: 6351:  }
        -: 6352:
    #####: 6353:  ecma_object_t *arraybuffer_p = dataview_p->buffer_p;
    #####: 6354:  ecma_ref_object (arraybuffer_p);
        -: 6355:
    #####: 6356:  return ecma_make_object_value (arraybuffer_p);
        -: 6357:#else /* !JERRY_BUILTIN_DATAVIEW */
        -: 6358:  JERRY_UNUSED (value);
        -: 6359:  JERRY_UNUSED (byte_offset);
        -: 6360:  JERRY_UNUSED (byte_length);
    #####: 6361:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_DATA_VIEW_NOT_SUPPORTED));
        -: 6362:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 6363:} /* jerry_dataview_buffer */
        -: 6364:
        -: 6365:/**
        -: 6366: * TypedArray related functions
        -: 6367: */
        -: 6368:
        -: 6369:/**
        -: 6370: * Check if the given value is a TypedArray object.
        -: 6371: *
        -: 6372: * @return true - if it is a TypedArray object
        -: 6373: *         false - otherwise
        -: 6374: */
        -: 6375:bool
    #####: 6376:jerry_value_is_typedarray (jerry_value_t value) /**< value to check if it is a TypedArray */
        -: 6377:{
        -: 6378:  jerry_assert_api_enabled ();
        -: 6379:
        -: 6380:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6381:  return ecma_is_typedarray (value);
        -: 6382:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6383:  JERRY_UNUSED (value);
    #####: 6384:  return false;
        -: 6385:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6386:} /* jerry_value_is_typedarray */
        -: 6387:
        -: 6388:#if JERRY_BUILTIN_TYPEDARRAY
        -: 6389:/**
        -: 6390: * TypedArray mapping type
        -: 6391: */
        -: 6392:typedef struct
        -: 6393:{
        -: 6394:  jerry_typedarray_type_t api_type; /**< api type */
        -: 6395:  ecma_builtin_id_t prototype_id; /**< prototype ID */
        -: 6396:  ecma_typedarray_type_t id; /**< typedArray ID */
        -: 6397:  uint8_t element_size_shift; /**< element size shift */
        -: 6398:} jerry_typedarray_mapping_t;
        -: 6399:
        -: 6400:/**
        -: 6401: * List of TypedArray mappings
        -: 6402: */
        -: 6403:static jerry_typedarray_mapping_t jerry_typedarray_mappings[] = {
        -: 6404:#define TYPEDARRAY_ENTRY(NAME, LIT_NAME, SIZE_SHIFT)                                                      \
        -: 6405:  {                                                                                                       \
        -: 6406:    JERRY_TYPEDARRAY_##NAME, ECMA_BUILTIN_ID_##NAME##ARRAY_PROTOTYPE, ECMA_##LIT_NAME##_ARRAY, SIZE_SHIFT \
        -: 6407:  }
        -: 6408:
        -: 6409:  TYPEDARRAY_ENTRY (UINT8, UINT8, 0),       TYPEDARRAY_ENTRY (UINT8CLAMPED, UINT8_CLAMPED, 0),
        -: 6410:  TYPEDARRAY_ENTRY (INT8, INT8, 0),         TYPEDARRAY_ENTRY (UINT16, UINT16, 1),
        -: 6411:  TYPEDARRAY_ENTRY (INT16, INT16, 1),       TYPEDARRAY_ENTRY (UINT32, UINT32, 2),
        -: 6412:  TYPEDARRAY_ENTRY (INT32, INT32, 2),       TYPEDARRAY_ENTRY (FLOAT32, FLOAT32, 2),
        -: 6413:#if JERRY_NUMBER_TYPE_FLOAT64
        -: 6414:  TYPEDARRAY_ENTRY (FLOAT64, FLOAT64, 3),
        -: 6415:#endif /* JERRY_NUMBER_TYPE_FLOAT64 */
        -: 6416:#if JERRY_BUILTIN_BIGINT
        -: 6417:  TYPEDARRAY_ENTRY (BIGINT64, BIGINT64, 3), TYPEDARRAY_ENTRY (BIGUINT64, BIGUINT64, 3),
        -: 6418:#endif /* JERRY_BUILTIN_BIGINT */
        -: 6419:#undef TYPEDARRAY_ENTRY
        -: 6420:};
        -: 6421:
        -: 6422:/**
        -: 6423: * Helper function to get the TypedArray prototype, typedArray id, and element size shift
        -: 6424: * information.
        -: 6425: *
        -: 6426: * @return true - if the TypedArray information was found
        -: 6427: *         false - if there is no such TypedArray type
        -: 6428: */
        -: 6429:static bool
    #####: 6430:jerry_typedarray_find_by_type (jerry_typedarray_type_t type_name, /**< type of the TypedArray */
        -: 6431:                               ecma_builtin_id_t *prototype_id, /**< [out] found prototype object id */
        -: 6432:                               ecma_typedarray_type_t *id, /**< [out] found typedArray id */
        -: 6433:                               uint8_t *element_size_shift) /**< [out] found element size shift value */
        -: 6434:{
    #####: 6435:  JERRY_ASSERT (prototype_id != NULL);
    #####: 6436:  JERRY_ASSERT (id != NULL);
    #####: 6437:  JERRY_ASSERT (element_size_shift != NULL);
        -: 6438:
    #####: 6439:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6440:  {
    #####: 6441:    if (type_name == jerry_typedarray_mappings[i].api_type)
        -: 6442:    {
    #####: 6443:      *prototype_id = jerry_typedarray_mappings[i].prototype_id;
    #####: 6444:      *id = jerry_typedarray_mappings[i].id;
    #####: 6445:      *element_size_shift = jerry_typedarray_mappings[i].element_size_shift;
    #####: 6446:      return true;
        -: 6447:    }
        -: 6448:  }
        -: 6449:
    #####: 6450:  return false;
        -: 6451:} /* jerry_typedarray_find_by_type */
        -: 6452:
        -: 6453:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6454:
        -: 6455:/**
        -: 6456: * Create a TypedArray object with a given type and length.
        -: 6457: *
        -: 6458: * Notes:
        -: 6459: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6460: *      * byteOffset property will be set to 0.
        -: 6461: *      * byteLength property will be a multiple of the length parameter (based on the type).
        -: 6462: *
        -: 6463: * @return - new TypedArray object
        -: 6464: */
        -: 6465:jerry_value_t
    #####: 6466:jerry_typedarray (jerry_typedarray_type_t type_name, /**< type of TypedArray to create */
        -: 6467:                  jerry_length_t length) /**< element count of the new TypedArray */
        -: 6468:{
        -: 6469:  jerry_assert_api_enabled ();
        -: 6470:
        -: 6471:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6472:  ecma_builtin_id_t prototype_id = 0;
    #####: 6473:  ecma_typedarray_type_t id = 0;
    #####: 6474:  uint8_t element_size_shift = 0;
        -: 6475:
    #####: 6476:  if (!jerry_typedarray_find_by_type (type_name, &prototype_id, &id, &element_size_shift))
        -: 6477:  {
    #####: 6478:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_FOR_TYPEDARRAY));
        -: 6479:  }
        -: 6480:
    #####: 6481:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
        -: 6482:
    #####: 6483:  ecma_value_t array_value =
    #####: 6484:    ecma_typedarray_create_object_with_length (length, NULL, prototype_obj_p, element_size_shift, id);
        -: 6485:
    #####: 6486:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (array_value));
        -: 6487:
    #####: 6488:  return array_value;
        -: 6489:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6490:  JERRY_UNUSED (type_name);
        -: 6491:  JERRY_UNUSED (length);
    #####: 6492:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 6493:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6494:} /* jerry_typedarray */
        -: 6495:
        -: 6496:/**
        -: 6497: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6498: *
        -: 6499: * Notes:
        -: 6500: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6501: *      * this is the 'new %TypedArray%(arraybuffer, byteOffset, length)' equivalent call.
        -: 6502: *
        -: 6503: * @return - new TypedArray object
        -: 6504: */
        -: 6505:jerry_value_t
    #####: 6506:jerry_typedarray_with_buffer_span (jerry_typedarray_type_t type, /**< type of TypedArray to create */
        -: 6507:                                   const jerry_value_t arraybuffer, /**< ArrayBuffer to use */
        -: 6508:                                   jerry_length_t byte_offset, /**< offset for the ArrayBuffer */
        -: 6509:                                   jerry_length_t length) /**< number of elements to use from ArrayBuffer */
        -: 6510:{
        -: 6511:  jerry_assert_api_enabled ();
        -: 6512:
        -: 6513:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6514:  if (ecma_is_value_exception (arraybuffer))
        -: 6515:  {
    #####: 6516:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 6517:  }
        -: 6518:
    #####: 6519:  ecma_builtin_id_t prototype_id = 0;
    #####: 6520:  ecma_typedarray_type_t id = 0;
    #####: 6521:  uint8_t element_size_shift = 0;
        -: 6522:
    #####: 6523:  if (!jerry_typedarray_find_by_type (type, &prototype_id, &id, &element_size_shift))
        -: 6524:  {
    #####: 6525:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_FOR_TYPEDARRAY));
        -: 6526:  }
        -: 6527:
    #####: 6528:  if (!ecma_is_arraybuffer (arraybuffer))
        -: 6529:  {
    #####: 6530:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_ARGUMENT_NOT_ARRAY_BUFFER));
        -: 6531:  }
        -: 6532:
    #####: 6533:  ecma_object_t *prototype_obj_p = ecma_builtin_get (prototype_id);
    #####: 6534:  ecma_value_t arguments_p[3] = { arraybuffer, ecma_make_uint32_value (byte_offset), ecma_make_uint32_value (length) };
        -: 6535:
    #####: 6536:  ecma_value_t array_value = ecma_op_create_typedarray (arguments_p, 3, prototype_obj_p, element_size_shift, id);
    #####: 6537:  ecma_free_value (arguments_p[1]);
    #####: 6538:  ecma_free_value (arguments_p[2]);
        -: 6539:
    #####: 6540:  return jerry_return (array_value);
        -: 6541:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6542:  JERRY_UNUSED (type);
        -: 6543:  JERRY_UNUSED (arraybuffer);
        -: 6544:  JERRY_UNUSED (byte_offset);
        -: 6545:  JERRY_UNUSED (length);
    #####: 6546:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 6547:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6548:} /* jerry_typedarray_with_buffer_span */
        -: 6549:
        -: 6550:/**
        -: 6551: * Create a TypedArray object using the given arraybuffer and size information.
        -: 6552: *
        -: 6553: * Notes:
        -: 6554: *      * returns TypeError if an incorrect type (type_name) is specified.
        -: 6555: *      * this is the 'new %TypedArray%(arraybuffer)' equivalent call.
        -: 6556: *
        -: 6557: * @return - new TypedArray object
        -: 6558: */
        -: 6559:jerry_value_t
    #####: 6560:jerry_typedarray_with_buffer (jerry_typedarray_type_t type, /**< type of TypedArray to create */
        -: 6561:                              const jerry_value_t arraybuffer) /**< ArrayBuffer to use */
        -: 6562:{
        -: 6563:  jerry_assert_api_enabled ();
        -: 6564:
        -: 6565:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6566:  if (ecma_is_value_exception (arraybuffer))
        -: 6567:  {
    #####: 6568:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 6569:  }
        -: 6570:
    #####: 6571:  jerry_length_t byte_length = jerry_arraybuffer_size (arraybuffer);
    #####: 6572:  return jerry_typedarray_with_buffer_span (type, arraybuffer, 0, byte_length);
        -: 6573:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6574:  JERRY_UNUSED (type);
        -: 6575:  JERRY_UNUSED (arraybuffer);
    #####: 6576:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 6577:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6578:} /* jerry_typedarray_with_buffer */
        -: 6579:
        -: 6580:/**
        -: 6581: * Get the type of the TypedArray.
        -: 6582: *
        -: 6583: * @return - type of the TypedArray
        -: 6584: *         - JERRY_TYPEDARRAY_INVALID if the argument is not a TypedArray
        -: 6585: */
        -: 6586:jerry_typedarray_type_t
    #####: 6587:jerry_typedarray_type (jerry_value_t value) /**< object to get the TypedArray type */
        -: 6588:{
        -: 6589:  jerry_assert_api_enabled ();
        -: 6590:
        -: 6591:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6592:  if (!ecma_is_typedarray (value))
        -: 6593:  {
    #####: 6594:    return JERRY_TYPEDARRAY_INVALID;
        -: 6595:  }
        -: 6596:
    #####: 6597:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6598:  ecma_typedarray_type_t class_type = ecma_get_typedarray_id (array_p);
        -: 6599:
    #####: 6600:  for (uint32_t i = 0; i < sizeof (jerry_typedarray_mappings) / sizeof (jerry_typedarray_mappings[0]); i++)
        -: 6601:  {
    #####: 6602:    if (class_type == jerry_typedarray_mappings[i].id)
        -: 6603:    {
    #####: 6604:      return jerry_typedarray_mappings[i].api_type;
        -: 6605:    }
        -: 6606:  }
        -: 6607:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6608:  JERRY_UNUSED (value);
        -: 6609:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6610:
    #####: 6611:  return JERRY_TYPEDARRAY_INVALID;
        -: 6612:} /* jerry_typedarray_type */
        -: 6613:
        -: 6614:/**
        -: 6615: * Get the element count of the TypedArray.
        -: 6616: *
        -: 6617: * @return length of the TypedArray.
        -: 6618: */
        -: 6619:jerry_length_t
    #####: 6620:jerry_typedarray_length (jerry_value_t value) /**< TypedArray to query */
        -: 6621:{
        -: 6622:  jerry_assert_api_enabled ();
        -: 6623:
        -: 6624:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6625:  if (ecma_is_typedarray (value))
        -: 6626:  {
    #####: 6627:    ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6628:    return ecma_typedarray_get_length (array_p);
        -: 6629:  }
        -: 6630:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6631:  JERRY_UNUSED (value);
        -: 6632:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6633:
    #####: 6634:  return 0;
        -: 6635:} /* jerry_typedarray_length */
        -: 6636:
        -: 6637:/**
        -: 6638: * Get the underlying ArrayBuffer from a TypedArray.
        -: 6639: *
        -: 6640: * Additionally the byteLength and byteOffset properties are also returned
        -: 6641: * which were specified when the TypedArray was created.
        -: 6642: *
        -: 6643: * Note:
        -: 6644: *     the returned value must be freed with a jerry_value_free call
        -: 6645: *
        -: 6646: * @return ArrayBuffer of a TypedArray
        -: 6647: *         TypeError if the object is not a TypedArray.
        -: 6648: */
        -: 6649:jerry_value_t
    #####: 6650:jerry_typedarray_buffer (jerry_value_t value, /**< TypedArray to get the arraybuffer from */
        -: 6651:                         jerry_length_t *byte_offset, /**< [out] byteOffset property */
        -: 6652:                         jerry_length_t *byte_length) /**< [out] byteLength property */
        -: 6653:{
        -: 6654:  jerry_assert_api_enabled ();
        -: 6655:
        -: 6656:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 6657:  if (!ecma_is_typedarray (value))
        -: 6658:  {
    #####: 6659:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_OBJECT_IS_NOT_A_TYPEDARRAY));
        -: 6660:  }
        -: 6661:
    #####: 6662:  ecma_object_t *array_p = ecma_get_object_from_value (value);
    #####: 6663:  uint8_t shift = ecma_typedarray_get_element_size_shift (array_p);
        -: 6664:
    #####: 6665:  if (byte_length != NULL)
        -: 6666:  {
    #####: 6667:    *byte_length = (jerry_length_t) (ecma_typedarray_get_length (array_p) << shift);
        -: 6668:  }
        -: 6669:
    #####: 6670:  if (byte_offset != NULL)
        -: 6671:  {
    #####: 6672:    *byte_offset = (jerry_length_t) ecma_typedarray_get_offset (array_p);
        -: 6673:  }
        -: 6674:
    #####: 6675:  ecma_object_t *arraybuffer_p = ecma_typedarray_get_arraybuffer (array_p);
    #####: 6676:  ecma_ref_object (arraybuffer_p);
    #####: 6677:  return jerry_return (ecma_make_object_value (arraybuffer_p));
        -: 6678:#else /* !JERRY_BUILTIN_TYPEDARRAY */
        -: 6679:  JERRY_UNUSED (value);
        -: 6680:  JERRY_UNUSED (byte_length);
        -: 6681:  JERRY_UNUSED (byte_offset);
    #####: 6682:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_TYPED_ARRAY_NOT_SUPPORTED));
        -: 6683:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 6684:} /* jerry_typedarray_buffer */
        -: 6685:
        -: 6686:/**
        -: 6687: * Parse the given input buffer as a JSON string. The behaviour is equivalent with the "JSON.parse(string)" JS
        -: 6688: * call. The input buffer can be encoded as either cesu-8 or utf-8, but it is the callers responsibility to make sure
        -: 6689: * the encoding is valid.
        -: 6690: *
        -: 6691: *
        -: 6692: * @return object value, or exception
        -: 6693: */
        -: 6694:jerry_value_t
    #####: 6695:jerry_json_parse (const jerry_char_t *string_p, /**< json string */
        -: 6696:                  jerry_size_t string_size) /**< json string size */
        -: 6697:{
        -: 6698:  jerry_assert_api_enabled ();
        -: 6699:
        -: 6700:#if JERRY_BUILTIN_JSON
    #####: 6701:  ecma_value_t ret_value = ecma_builtin_json_parse_buffer (string_p, string_size);
        -: 6702:
    #####: 6703:  if (ecma_is_value_undefined (ret_value))
        -: 6704:  {
    #####: 6705:    ret_value = jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_JSON_STRING_PARSE_ERROR));
        -: 6706:  }
        -: 6707:
    #####: 6708:  return jerry_return (ret_value);
        -: 6709:#else /* !JERRY_BUILTIN_JSON */
        -: 6710:  JERRY_UNUSED (string_p);
        -: 6711:  JERRY_UNUSED (string_size);
        -: 6712:
        -: 6713:  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_JSON_NOT_SUPPORTED));
        -: 6714:#endif /* JERRY_BUILTIN_JSON */
        -: 6715:} /* jerry_json_parse */
        -: 6716:
        -: 6717:/**
        -: 6718: * Create a JSON string from a JavaScript value.
        -: 6719: *
        -: 6720: * The behaviour is equivalent with the "JSON.stringify(input_value)" JS call.
        -: 6721: *
        -: 6722: * Note:
        -: 6723: *      The returned value must be freed with jerry_value_free,
        -: 6724: *
        -: 6725: * @return - jerry_value_t containing a JSON string.
        -: 6726: *         - Error value if there was a problem during the stringification.
        -: 6727: */
        -: 6728:jerry_value_t
    #####: 6729:jerry_json_stringify (const jerry_value_t input_value) /**< a value to stringify */
        -: 6730:{
        -: 6731:  jerry_assert_api_enabled ();
        -: 6732:#if JERRY_BUILTIN_JSON
    #####: 6733:  if (ecma_is_value_exception (input_value))
        -: 6734:  {
    #####: 6735:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 6736:  }
        -: 6737:
    #####: 6738:  ecma_value_t ret_value = ecma_builtin_json_stringify_no_opts (input_value);
        -: 6739:
    #####: 6740:  if (ecma_is_value_undefined (ret_value))
        -: 6741:  {
    #####: 6742:    ret_value = jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_JSON_STRINGIFY_ERROR));
        -: 6743:  }
        -: 6744:
    #####: 6745:  return jerry_return (ret_value);
        -: 6746:#else /* JERRY_BUILTIN_JSON */
        -: 6747:  JERRY_UNUSED (input_value);
        -: 6748:
        -: 6749:  return jerry_throw_sz (JERRY_ERROR_SYNTAX, ecma_get_error_msg (ECMA_ERR_JSON_NOT_SUPPORTED));
        -: 6750:#endif /* JERRY_BUILTIN_JSON */
        -: 6751:} /* jerry_json_stringify */
        -: 6752:
        -: 6753:/**
        -: 6754: * Create a container type specified in jerry_container_type_t.
        -: 6755: * The container can be created with a list of arguments, which will be passed to the container constructor to be
        -: 6756: * inserted to the container.
        -: 6757: *
        -: 6758: * Note:
        -: 6759: *      The returned value must be freed with jerry_value_free
        -: 6760: * @return jerry_value_t representing a container with the given type.
        -: 6761: */
        -: 6762:jerry_value_t
    #####: 6763:jerry_container (jerry_container_type_t container_type, /**< Type of the container */
        -: 6764:                 const jerry_value_t *arguments_list_p, /**< arguments list */
        -: 6765:                 jerry_length_t arguments_list_len) /**< Length of arguments list */
        -: 6766:{
        -: 6767:  jerry_assert_api_enabled ();
        -: 6768:
        -: 6769:#if JERRY_BUILTIN_CONTAINER
    #####: 6770:  for (jerry_length_t i = 0; i < arguments_list_len; i++)
        -: 6771:  {
    #####: 6772:    if (ecma_is_value_exception (arguments_list_p[i]))
        -: 6773:    {
    #####: 6774:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_VALUE_MSG));
        -: 6775:    }
        -: 6776:  }
        -: 6777:
        -: 6778:  lit_magic_string_id_t lit_id;
        -: 6779:  ecma_builtin_id_t proto_id;
        -: 6780:  ecma_builtin_id_t ctor_id;
        -: 6781:
    #####: 6782:  switch (container_type)
        -: 6783:  {
    #####: 6784:    case JERRY_CONTAINER_TYPE_MAP:
        -: 6785:    {
    #####: 6786:      lit_id = LIT_MAGIC_STRING_MAP_UL;
    #####: 6787:      proto_id = ECMA_BUILTIN_ID_MAP_PROTOTYPE;
    #####: 6788:      ctor_id = ECMA_BUILTIN_ID_MAP;
    #####: 6789:      break;
        -: 6790:    }
    #####: 6791:    case JERRY_CONTAINER_TYPE_SET:
        -: 6792:    {
    #####: 6793:      lit_id = LIT_MAGIC_STRING_SET_UL;
    #####: 6794:      proto_id = ECMA_BUILTIN_ID_SET_PROTOTYPE;
    #####: 6795:      ctor_id = ECMA_BUILTIN_ID_SET;
    #####: 6796:      break;
        -: 6797:    }
    #####: 6798:    case JERRY_CONTAINER_TYPE_WEAKMAP:
        -: 6799:    {
    #####: 6800:      lit_id = LIT_MAGIC_STRING_WEAKMAP_UL;
    #####: 6801:      proto_id = ECMA_BUILTIN_ID_WEAKMAP_PROTOTYPE;
    #####: 6802:      ctor_id = ECMA_BUILTIN_ID_WEAKMAP;
    #####: 6803:      break;
        -: 6804:    }
    #####: 6805:    case JERRY_CONTAINER_TYPE_WEAKSET:
        -: 6806:    {
    #####: 6807:      lit_id = LIT_MAGIC_STRING_WEAKSET_UL;
    #####: 6808:      proto_id = ECMA_BUILTIN_ID_WEAKSET_PROTOTYPE;
    #####: 6809:      ctor_id = ECMA_BUILTIN_ID_WEAKSET;
    #####: 6810:      break;
        -: 6811:    }
    #####: 6812:    default:
        -: 6813:    {
    #####: 6814:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INVALID_CONTAINER_TYPE));
        -: 6815:    }
        -: 6816:  }
    #####: 6817:  ecma_object_t *old_new_target_p = JERRY_CONTEXT (current_new_target_p);
        -: 6818:
    #####: 6819:  if (old_new_target_p == NULL)
        -: 6820:  {
    #####: 6821:    JERRY_CONTEXT (current_new_target_p) = ecma_builtin_get (ctor_id);
        -: 6822:  }
        -: 6823:
    #####: 6824:  ecma_value_t container_value = ecma_op_container_create (arguments_list_p, arguments_list_len, lit_id, proto_id);
        -: 6825:
    #####: 6826:  JERRY_CONTEXT (current_new_target_p) = old_new_target_p;
    #####: 6827:  return jerry_return (container_value);
        -: 6828:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6829:  JERRY_UNUSED (arguments_list_p);
        -: 6830:  JERRY_UNUSED (arguments_list_len);
        -: 6831:  JERRY_UNUSED (container_type);
    #####: 6832:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NOT_SUPPORTED));
        -: 6833:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 6834:} /* jerry_container */
        -: 6835:
        -: 6836:/**
        -: 6837: * Get the type of the given container object.
        -: 6838: *
        -: 6839: * @return Corresponding type to the given container object.
        -: 6840: */
        -: 6841:jerry_container_type_t
    #####: 6842:jerry_container_type (const jerry_value_t value) /**< the container object */
        -: 6843:{
        -: 6844:  jerry_assert_api_enabled ();
        -: 6845:
        -: 6846:#if JERRY_BUILTIN_CONTAINER
    #####: 6847:  if (ecma_is_value_object (value))
        -: 6848:  {
    #####: 6849:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 6850:
    #####: 6851:    if (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_CONTAINER))
        -: 6852:    {
    #####: 6853:      switch (((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id)
        -: 6854:      {
    #####: 6855:        case LIT_MAGIC_STRING_MAP_UL:
        -: 6856:        {
    #####: 6857:          return JERRY_CONTAINER_TYPE_MAP;
        -: 6858:        }
    #####: 6859:        case LIT_MAGIC_STRING_SET_UL:
        -: 6860:        {
    #####: 6861:          return JERRY_CONTAINER_TYPE_SET;
        -: 6862:        }
    #####: 6863:        case LIT_MAGIC_STRING_WEAKMAP_UL:
        -: 6864:        {
    #####: 6865:          return JERRY_CONTAINER_TYPE_WEAKMAP;
        -: 6866:        }
    #####: 6867:        case LIT_MAGIC_STRING_WEAKSET_UL:
        -: 6868:        {
    #####: 6869:          return JERRY_CONTAINER_TYPE_WEAKSET;
        -: 6870:        }
    #####: 6871:        default:
        -: 6872:        {
    #####: 6873:          return JERRY_CONTAINER_TYPE_INVALID;
        -: 6874:        }
        -: 6875:      }
        -: 6876:    }
        -: 6877:  }
        -: 6878:
        -: 6879:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6880:  JERRY_UNUSED (value);
        -: 6881:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 6882:  return JERRY_CONTAINER_TYPE_INVALID;
        -: 6883:} /* jerry_container_type */
        -: 6884:
        -: 6885:/**
        -: 6886: * Return a new array containing elements from a Container or a Container Iterator.
        -: 6887: * Sets the boolean input value to `true` if the container object has key/value pairs.
        -: 6888: *
        -: 6889: * Note:
        -: 6890: *     the returned value must be freed with a jerry_value_free call
        -: 6891: *
        -: 6892: * @return an array of items for maps/sets or their iterators, error otherwise
        -: 6893: */
        -: 6894:jerry_value_t
    #####: 6895:jerry_container_to_array (jerry_value_t value, /**< the container or iterator object */
        -: 6896:                          bool *is_key_value_p) /**< [out] is key-value structure */
        -: 6897:{
        -: 6898:  jerry_assert_api_enabled ();
        -: 6899:
        -: 6900:#if JERRY_BUILTIN_CONTAINER
    #####: 6901:  if (!ecma_is_value_object (value))
        -: 6902:  {
    #####: 6903:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NEEDED));
        -: 6904:  }
        -: 6905:
    #####: 6906:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -: 6907:
    #####: 6908:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 6909:  {
    #####: 6910:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NEEDED));
        -: 6911:  }
        -: 6912:
    #####: 6913:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
        -: 6914:
        -: 6915:  uint32_t entry_count;
        -: 6916:  uint8_t entry_size;
        -: 6917:
    #####: 6918:  uint32_t index = 0;
    #####: 6919:  uint8_t iterator_kind = ECMA_ITERATOR__COUNT;
        -: 6920:  ecma_value_t *start_p;
        -: 6921:
    #####: 6922:  *is_key_value_p = false;
        -: 6923:
    #####: 6924:  if (ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_MAP_ITERATOR
    #####: 6925:      || ext_obj_p->u.cls.type == ECMA_OBJECT_CLASS_SET_ITERATOR)
    #####: 6926:  {
    #####: 6927:    ecma_value_t iterated_value = ext_obj_p->u.cls.u3.iterated_value;
        -: 6928:
    #####: 6929:    if (ecma_is_value_empty (iterated_value))
        -: 6930:    {
    #####: 6931:      return ecma_op_new_array_object_from_collection (ecma_new_collection (), false);
        -: 6932:    }
        -: 6933:
    #####: 6934:    ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) (ecma_get_object_from_value (iterated_value));
        -: 6935:
    #####: 6936:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, map_object_p->u.cls.u3.value);
    #####: 6937:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 6938:    index = ext_obj_p->u.cls.u2.iterator_index;
        -: 6939:
    #####: 6940:    entry_size = ecma_op_container_entry_size (map_object_p->u.cls.u2.container_id);
    #####: 6941:    start_p = ECMA_CONTAINER_START (container_p);
        -: 6942:
    #####: 6943:    iterator_kind = ext_obj_p->u.cls.u1.iterator_kind;
        -: 6944:  }
    #####: 6945:  else if (jerry_container_type (value) != JERRY_CONTAINER_TYPE_INVALID)
        -: 6946:  {
    #####: 6947:    ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, ext_obj_p->u.cls.u3.value);
    #####: 6948:    entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
    #####: 6949:    entry_size = ecma_op_container_entry_size (ext_obj_p->u.cls.u2.container_id);
        -: 6950:
    #####: 6951:    index = 0;
    #####: 6952:    iterator_kind = ECMA_ITERATOR_KEYS;
    #####: 6953:    start_p = ECMA_CONTAINER_START (container_p);
        -: 6954:
    #####: 6955:    if (ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_MAP_UL
    #####: 6956:        || ext_obj_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 6957:    {
    #####: 6958:      iterator_kind = ECMA_ITERATOR_ENTRIES;
        -: 6959:    }
        -: 6960:  }
        -: 6961:  else
        -: 6962:  {
    #####: 6963:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NEEDED));
        -: 6964:  }
        -: 6965:
    #####: 6966:  *is_key_value_p = (iterator_kind == ECMA_ITERATOR_ENTRIES);
    #####: 6967:  ecma_collection_t *collection_buffer = ecma_new_collection ();
        -: 6968:
    #####: 6969:  for (uint32_t i = index; i < entry_count; i += entry_size)
        -: 6970:  {
    #####: 6971:    ecma_value_t *entry_p = start_p + i;
        -: 6972:
    #####: 6973:    if (ecma_is_value_empty (*entry_p))
        -: 6974:    {
    #####: 6975:      continue;
        -: 6976:    }
        -: 6977:
    #####: 6978:    if (iterator_kind != ECMA_ITERATOR_VALUES)
        -: 6979:    {
    #####: 6980:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[0]));
        -: 6981:    }
        -: 6982:
    #####: 6983:    if (iterator_kind != ECMA_ITERATOR_KEYS)
        -: 6984:    {
    #####: 6985:      ecma_collection_push_back (collection_buffer, ecma_copy_value_if_not_object (entry_p[1]));
        -: 6986:    }
        -: 6987:  }
    #####: 6988:  return ecma_op_new_array_object_from_collection (collection_buffer, false);
        -: 6989:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 6990:  JERRY_UNUSED (value);
        -: 6991:  JERRY_UNUSED (is_key_value_p);
    #####: 6992:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NOT_SUPPORTED));
        -: 6993:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 6994:} /* jerry_container_to_array */
        -: 6995:
        -: 6996:/**
        -: 6997: * Perform container operation on the given operands (add, get, set, has, delete, size, clear).
        -: 6998: *
        -: 6999: * @return error - if argument is invalid or operation is unsuccessful or unsupported
        -: 7000: *                 result of the container operation - otherwise.
        -: 7001: */
        -: 7002:jerry_value_t
    #####: 7003:jerry_container_op (jerry_container_op_t operation, /**< container operation */
        -: 7004:                    jerry_value_t container, /**< container */
        -: 7005:                    const jerry_value_t *arguments, /**< list of arguments */
        -: 7006:                    uint32_t arguments_number) /**< number of arguments */
        -: 7007:{
        -: 7008:  jerry_assert_api_enabled ();
        -: 7009:#if JERRY_BUILTIN_CONTAINER
    #####: 7010:  if (!ecma_is_value_object (container))
        -: 7011:  {
    #####: 7012:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_IS_NOT_AN_OBJECT));
        -: 7013:  }
        -: 7014:
    #####: 7015:  ecma_object_t *obj_p = ecma_get_object_from_value (container);
        -: 7016:
    #####: 7017:  if (ecma_get_object_type (obj_p) != ECMA_OBJECT_TYPE_CLASS)
        -: 7018:  {
    #####: 7019:    return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_IS_NOT_A_CONTAINER_OBJECT));
        -: 7020:  }
    #####: 7021:  uint16_t type = ((ecma_extended_object_t *) obj_p)->u.cls.u2.container_id;
    #####: 7022:  ecma_extended_object_t *container_object_p = ecma_op_container_get_object (container, type);
        -: 7023:
    #####: 7024:  if (container_object_p == NULL)
        -: 7025:  {
    #####: 7026:    return ecma_create_exception_from_context ();
        -: 7027:  }
        -: 7028:
    #####: 7029:  switch (operation)
        -: 7030:  {
    #####: 7031:    case JERRY_CONTAINER_OP_ADD:
        -: 7032:    case JERRY_CONTAINER_OP_DELETE:
        -: 7033:    case JERRY_CONTAINER_OP_GET:
        -: 7034:    case JERRY_CONTAINER_OP_HAS:
        -: 7035:    {
    #####: 7036:      if (arguments_number != 1 || ecma_is_value_exception (arguments[0]))
        -: 7037:      {
    #####: 7038:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 7039:      }
    #####: 7040:      break;
        -: 7041:    }
    #####: 7042:    case JERRY_CONTAINER_OP_SET:
        -: 7043:    {
    #####: 7044:      if (arguments_number != 2 || ecma_is_value_exception (arguments[0]) || ecma_is_value_exception (arguments[1]))
        -: 7045:      {
    #####: 7046:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 7047:      }
    #####: 7048:      break;
        -: 7049:    }
    #####: 7050:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7051:    case JERRY_CONTAINER_OP_SIZE:
        -: 7052:    {
    #####: 7053:      if (arguments_number != 0)
        -: 7054:      {
    #####: 7055:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 7056:      }
    #####: 7057:      break;
        -: 7058:    }
    #####: 7059:    default:
        -: 7060:    {
    #####: 7061:      return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_WRONG_ARGS_MSG));
        -: 7062:    }
        -: 7063:  }
        -: 7064:
        -: 7065:  jerry_value_t result;
        -: 7066:
    #####: 7067:  switch (operation)
        -: 7068:  {
    #####: 7069:    case JERRY_CONTAINER_OP_ADD:
        -: 7070:    {
    #####: 7071:      if (type == LIT_MAGIC_STRING_MAP_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7072:      {
    #####: 7073:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_CALL));
        -: 7074:      }
    #####: 7075:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[0], type);
    #####: 7076:      break;
        -: 7077:    }
    #####: 7078:    case JERRY_CONTAINER_OP_GET:
        -: 7079:    {
    #####: 7080:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7081:      {
    #####: 7082:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_CALL));
        -: 7083:      }
    #####: 7084:      result = ecma_op_container_get (container_object_p, arguments[0], type);
    #####: 7085:      break;
        -: 7086:    }
    #####: 7087:    case JERRY_CONTAINER_OP_SET:
        -: 7088:    {
    #####: 7089:      if (type == LIT_MAGIC_STRING_SET_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7090:      {
    #####: 7091:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_CALL));
        -: 7092:      }
    #####: 7093:      result = ecma_op_container_set (container_object_p, arguments[0], arguments[1], type);
    #####: 7094:      break;
        -: 7095:    }
    #####: 7096:    case JERRY_CONTAINER_OP_HAS:
        -: 7097:    {
    #####: 7098:      result = ecma_op_container_has (container_object_p, arguments[0], type);
    #####: 7099:      break;
        -: 7100:    }
    #####: 7101:    case JERRY_CONTAINER_OP_DELETE:
        -: 7102:    {
    #####: 7103:      if (type == LIT_MAGIC_STRING_WEAKMAP_UL || type == LIT_MAGIC_STRING_WEAKSET_UL)
        -: 7104:      {
    #####: 7105:        result = ecma_op_container_delete_weak (container_object_p, arguments[0], type);
    #####: 7106:        break;
        -: 7107:      }
    #####: 7108:      result = ecma_op_container_delete (container_object_p, arguments[0], type);
    #####: 7109:      break;
        -: 7110:    }
    #####: 7111:    case JERRY_CONTAINER_OP_SIZE:
        -: 7112:    {
    #####: 7113:      result = ecma_op_container_size (container_object_p);
    #####: 7114:      break;
        -: 7115:    }
    #####: 7116:    case JERRY_CONTAINER_OP_CLEAR:
        -: 7117:    {
    #####: 7118:      if (type == LIT_MAGIC_STRING_WEAKSET_UL || type == LIT_MAGIC_STRING_WEAKMAP_UL)
        -: 7119:      {
    #####: 7120:        return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_INCORRECT_TYPE_CALL));
        -: 7121:      }
    #####: 7122:      result = ecma_op_container_clear (container_object_p);
    #####: 7123:      break;
        -: 7124:    }
    #####: 7125:    default:
        -: 7126:    {
    #####: 7127:      result = jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_UNSUPPORTED_CONTAINER_OPERATION));
    #####: 7128:      break;
        -: 7129:    }
        -: 7130:  }
    #####: 7131:  return jerry_return (result);
        -: 7132:#else /* !JERRY_BUILTIN_CONTAINER */
        -: 7133:  JERRY_UNUSED (operation);
        -: 7134:  JERRY_UNUSED (container);
        -: 7135:  JERRY_UNUSED (arguments);
        -: 7136:  JERRY_UNUSED (arguments_number);
    #####: 7137:  return jerry_throw_sz (JERRY_ERROR_TYPE, ecma_get_error_msg (ECMA_ERR_CONTAINER_NOT_SUPPORTED));
        -: 7138:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 7139:} /* jerry_container_op */
        -: 7140:
        -: 7141:/**
        -: 7142: * @}
        -: 7143: */
