        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-helpers-collection.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-conversion.h"
        -:   18:#include "ecma-gc.h"
        -:   19:#include "ecma-globals.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:
        -:   22:#include "jrt.h"
        -:   23:
        -:   24:/** \addtogroup ecma ECMA
        -:   25: * @{
        -:   26: *
        -:   27: * \addtogroup ecmahelpers Helpers for operations with ECMA data types
        -:   28: * @{
        -:   29: */
        -:   30:
        -:   31:/**
        -:   32: * Allocate a collection of ecma values.
        -:   33: *
        -:   34: * @return pointer to the collection
        -:   35: */
        -:   36:ecma_collection_t *
    #####:   37:ecma_new_collection (void)
        -:   38:{
        -:   39:  ecma_collection_t *collection_p;
    #####:   40:  collection_p = (ecma_collection_t *) jmem_heap_alloc_block (sizeof (ecma_collection_t));
        -:   41:
    #####:   42:  collection_p->item_count = 0;
    #####:   43:  collection_p->capacity = ECMA_COLLECTION_INITIAL_CAPACITY;
    #####:   44:  const uint32_t size = ECMA_COLLECTION_ALLOCATED_SIZE (ECMA_COLLECTION_INITIAL_CAPACITY);
    #####:   45:  collection_p->buffer_p = (ecma_value_t *) jmem_heap_alloc_block (size);
        -:   46:
    #####:   47:  return collection_p;
        -:   48:} /* ecma_new_collection */
        -:   49:
        -:   50:/**
        -:   51: * Deallocate a collection of ecma values without freeing it's values
        -:   52: */
        -:   53:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:   54:ecma_collection_destroy (ecma_collection_t *collection_p) /**< value collection */
        -:   55:{
    #####:   56:  JERRY_ASSERT (collection_p != NULL);
        -:   57:
    #####:   58:  jmem_heap_free_block (collection_p->buffer_p, ECMA_COLLECTION_ALLOCATED_SIZE (collection_p->capacity));
    #####:   59:  jmem_heap_free_block (collection_p, sizeof (ecma_collection_t));
    #####:   60:} /* ecma_collection_destroy */
        -:   61:
        -:   62:/**
        -:   63: * Free the object collection elements and deallocate the collection
        -:   64: */
        -:   65:void
    #####:   66:ecma_collection_free_objects (ecma_collection_t *collection_p) /**< value collection */
        -:   67:{
    #####:   68:  JERRY_ASSERT (collection_p != NULL);
        -:   69:
    #####:   70:  ecma_value_t *buffer_p = collection_p->buffer_p;
        -:   71:
    #####:   72:  for (uint32_t i = 0; i < collection_p->item_count; i++)
        -:   73:  {
    #####:   74:    if (ecma_is_value_object (buffer_p[i]))
        -:   75:    {
    #####:   76:      ecma_deref_object (ecma_get_object_from_value (buffer_p[i]));
        -:   77:    }
        -:   78:  }
        -:   79:
    #####:   80:  ecma_collection_destroy (collection_p);
    #####:   81:} /* ecma_collection_free_objects */
        -:   82:
        -:   83:#if JERRY_ESNEXT
        -:   84:
        -:   85:/**
        -:   86: * Free the template literal objects and deallocate the collection
        -:   87: */
        -:   88:void
    #####:   89:ecma_collection_free_template_literal (ecma_collection_t *collection_p) /**< value collection */
        -:   90:{
    #####:   91:  for (uint32_t i = 0; i < collection_p->item_count; i++)
        -:   92:  {
    #####:   93:    ecma_object_t *object_p = ecma_get_object_from_value (collection_p->buffer_p[i]);
        -:   94:
    #####:   95:    JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:   96:
    #####:   97:    ecma_extended_object_t *array_object_p = (ecma_extended_object_t *) object_p;
        -:   98:
    #####:   99:    JERRY_ASSERT (array_object_p->u.array.length_prop_and_hole_count & ECMA_ARRAY_TEMPLATE_LITERAL);
    #####:  100:    array_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_ARRAY_TEMPLATE_LITERAL;
        -:  101:
        -:  102:    ecma_property_value_t *property_value_p;
        -:  103:
    #####:  104:    property_value_p = ecma_get_named_data_property (object_p, ecma_get_magic_string (LIT_MAGIC_STRING_RAW));
    #####:  105:    ecma_object_t *raw_object_p = ecma_get_object_from_value (property_value_p->value);
        -:  106:
    #####:  107:    JERRY_ASSERT (ecma_get_object_type (raw_object_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  108:
    #####:  109:    array_object_p = (ecma_extended_object_t *) raw_object_p;
        -:  110:
    #####:  111:    JERRY_ASSERT (array_object_p->u.array.length_prop_and_hole_count & ECMA_ARRAY_TEMPLATE_LITERAL);
    #####:  112:    array_object_p->u.array.length_prop_and_hole_count &= (uint32_t) ~ECMA_ARRAY_TEMPLATE_LITERAL;
        -:  113:
    #####:  114:    ecma_deref_object (raw_object_p);
    #####:  115:    ecma_deref_object (object_p);
        -:  116:  }
        -:  117:
    #####:  118:  ecma_collection_destroy (collection_p);
    #####:  119:} /* ecma_collection_free_template_literal */
        -:  120:
        -:  121:#endif /* JERRY_ESNEXT */
        -:  122:
        -:  123:/**
        -:  124: * Free the non-object collection elements and deallocate the collection
        -:  125: */
        -:  126:void
    #####:  127:ecma_collection_free_if_not_object (ecma_collection_t *collection_p) /**< value collection */
        -:  128:{
    #####:  129:  JERRY_ASSERT (collection_p != NULL);
        -:  130:
    #####:  131:  ecma_value_t *buffer_p = collection_p->buffer_p;
        -:  132:
    #####:  133:  for (uint32_t i = 0; i < collection_p->item_count; i++)
        -:  134:  {
    #####:  135:    ecma_free_value_if_not_object (buffer_p[i]);
        -:  136:  }
        -:  137:
    #####:  138:  ecma_collection_destroy (collection_p);
    #####:  139:} /* ecma_collection_free_if_not_object */
        -:  140:
        -:  141:/**
        -:  142: * Free the collection elements and deallocate the collection
        -:  143: */
        -:  144:void
    #####:  145:ecma_collection_free (ecma_collection_t *collection_p) /**< value collection */
        -:  146:{
    #####:  147:  JERRY_ASSERT (collection_p != NULL);
        -:  148:
    #####:  149:  ecma_value_t *buffer_p = collection_p->buffer_p;
        -:  150:
    #####:  151:  for (uint32_t i = 0; i < collection_p->item_count; i++)
        -:  152:  {
    #####:  153:    ecma_free_value (buffer_p[i]);
        -:  154:  }
        -:  155:
    #####:  156:  ecma_collection_destroy (collection_p);
    #####:  157:} /* ecma_collection_free */
        -:  158:
        -:  159:/**
        -:  160: * Append new value to ecma values collection
        -:  161: *
        -:  162: * Note: The reference count of the values are not increased
        -:  163: */
        -:  164:void
    #####:  165:ecma_collection_push_back (ecma_collection_t *collection_p, /**< value collection */
        -:  166:                           ecma_value_t value) /**< ecma value to append */
        -:  167:{
    #####:  168:  JERRY_ASSERT (collection_p != NULL);
        -:  169:
    #####:  170:  ecma_value_t *buffer_p = collection_p->buffer_p;
        -:  171:
    #####:  172:  if (JERRY_LIKELY (collection_p->item_count < collection_p->capacity))
        -:  173:  {
    #####:  174:    buffer_p[collection_p->item_count++] = value;
    #####:  175:    return;
        -:  176:  }
        -:  177:
    #####:  178:  const uint32_t new_capacity = collection_p->capacity + ECMA_COLLECTION_GROW_FACTOR;
    #####:  179:  const uint32_t old_size = ECMA_COLLECTION_ALLOCATED_SIZE (collection_p->capacity);
    #####:  180:  const uint32_t new_size = ECMA_COLLECTION_ALLOCATED_SIZE (new_capacity);
        -:  181:
    #####:  182:  buffer_p = jmem_heap_realloc_block (buffer_p, old_size, new_size);
    #####:  183:  buffer_p[collection_p->item_count++] = value;
    #####:  184:  collection_p->capacity = new_capacity;
        -:  185:
    #####:  186:  collection_p->buffer_p = buffer_p;
        -:  187:} /* ecma_collection_push_back */
        -:  188:
        -:  189:/**
        -:  190: * Reserve space for the given amount of ecma_values in the collection
        -:  191: */
        -:  192:void
    #####:  193:ecma_collection_reserve (ecma_collection_t *collection_p, /**< value collection */
        -:  194:                         uint32_t count) /**< number of ecma values to reserve */
        -:  195:{
    #####:  196:  JERRY_ASSERT (collection_p != NULL);
    #####:  197:  JERRY_ASSERT (UINT32_MAX - count > collection_p->capacity);
        -:  198:
    #####:  199:  const uint32_t new_capacity = collection_p->capacity + count;
    #####:  200:  const uint32_t old_size = ECMA_COLLECTION_ALLOCATED_SIZE (collection_p->capacity);
    #####:  201:  const uint32_t new_size = ECMA_COLLECTION_ALLOCATED_SIZE (new_capacity);
        -:  202:
    #####:  203:  ecma_value_t *buffer_p = collection_p->buffer_p;
    #####:  204:  buffer_p = jmem_heap_realloc_block (buffer_p, old_size, new_size);
        -:  205:
    #####:  206:  collection_p->capacity = new_capacity;
    #####:  207:  collection_p->buffer_p = buffer_p;
    #####:  208:} /* ecma_collection_reserve */
        -:  209:
        -:  210:/**
        -:  211: * Append a list of values to the end of the collection
        -:  212: */
        -:  213:void
    #####:  214:ecma_collection_append (ecma_collection_t *collection_p, /**< value collection */
        -:  215:                        const ecma_value_t *buffer_p, /**< values to append */
        -:  216:                        uint32_t count) /**< number of ecma values to append */
        -:  217:{
    #####:  218:  JERRY_ASSERT (collection_p != NULL);
    #####:  219:  JERRY_ASSERT (collection_p->capacity >= collection_p->item_count);
        -:  220:
    #####:  221:  uint32_t free_count = collection_p->capacity - collection_p->item_count;
        -:  222:
    #####:  223:  if (free_count < count)
        -:  224:  {
    #####:  225:    ecma_collection_reserve (collection_p, count - free_count);
        -:  226:  }
        -:  227:
    #####:  228:  memcpy (collection_p->buffer_p + collection_p->item_count, buffer_p, count * sizeof (ecma_value_t));
    #####:  229:  collection_p->item_count += count;
    #####:  230:} /* ecma_collection_append */
        -:  231:
        -:  232:/**
        -:  233: * Helper function to check if a given collection have duplicated properties or not
        -:  234: *
        -:  235: * @return true - if there are duplicated properties in the collection
        -:  236: *         false - otherwise
        -:  237: */
        -:  238:bool
    #####:  239:ecma_collection_check_duplicated_entries (ecma_collection_t *collection_p) /**< prop name collection */
        -:  240:{
    #####:  241:  if (collection_p->item_count == 0)
        -:  242:  {
    #####:  243:    return false;
        -:  244:  }
        -:  245:
    #####:  246:  ecma_value_t *buffer_p = collection_p->buffer_p;
        -:  247:
    #####:  248:  for (uint32_t i = 0; i < collection_p->item_count - 1; i++)
        -:  249:  {
    #####:  250:    ecma_string_t *current_name_p = ecma_get_prop_name_from_value (buffer_p[i]);
        -:  251:
    #####:  252:    for (uint32_t j = i + 1; j < collection_p->item_count; j++)
        -:  253:    {
    #####:  254:      if (ecma_compare_ecma_strings (current_name_p, ecma_get_prop_name_from_value (buffer_p[j])))
        -:  255:      {
    #####:  256:        return true;
        -:  257:      }
        -:  258:    }
        -:  259:  }
        -:  260:
    #####:  261:  return false;
        -:  262:} /* ecma_collection_check_duplicated_entries */
        -:  263:
        -:  264:/**
        -:  265: * Check the string value existance in the collection.
        -:  266: *
        -:  267: * Used by:
        -:  268: *         - ecma_builtin_json_stringify step 4.b.ii.5
        -:  269: *         - ecma_op_object_enumerate
        -:  270: *
        -:  271: * @return true, if the string is already in the collection.
        -:  272: */
        -:  273:bool
    #####:  274:ecma_collection_has_string_value (ecma_collection_t *collection_p, /**< collection */
        -:  275:                                  ecma_string_t *string_p) /**< string */
        -:  276:{
    #####:  277:  ecma_value_t *buffer_p = collection_p->buffer_p;
        -:  278:
    #####:  279:  for (uint32_t i = 0; i < collection_p->item_count; i++)
        -:  280:  {
    #####:  281:    ecma_string_t *current_p = ecma_get_string_from_value (buffer_p[i]);
        -:  282:
    #####:  283:    if (ecma_compare_ecma_strings (current_p, string_p))
        -:  284:    {
    #####:  285:      return true;
        -:  286:    }
        -:  287:  }
        -:  288:
    #####:  289:  return false;
        -:  290:} /* ecma_collection_has_string_value */
        -:  291:
        -:  292:/**
        -:  293: * Initial capacity of an ecma-collection
        -:  294: */
        -:  295:#define ECMA_COMPACT_COLLECTION_GROWTH 8
        -:  296:
        -:  297:/**
        -:  298: * Set the size of the compact collection
        -:  299: */
        -:  300:#define ECMA_COMPACT_COLLECTION_SET_SIZE(compact_collection_p, item_count, unused_items) \
        -:  301:  ((compact_collection_p)[0] = (((item_count) << ECMA_COMPACT_COLLECTION_SIZE_SHIFT) | (unused_items)))
        -:  302:
        -:  303:/**
        -:  304: * Set the size of the compact collection
        -:  305: */
        -:  306:#define ECMA_COMPACT_COLLECTION_GET_UNUSED_ITEM_COUNT(compact_collection_p) \
        -:  307:  ((compact_collection_p)[0] & ((1 << ECMA_COMPACT_COLLECTION_SIZE_SHIFT) - 1))
        -:  308:
        -:  309:/**
        -:  310: * Allocate a compact collection of ecma values
        -:  311: *
        -:  312: * @return pointer to the compact collection
        -:  313: */
        -:  314:ecma_value_t *
        1:  315:ecma_new_compact_collection (void)
        -:  316:{
        1:  317:  size_t size = (ECMA_COMPACT_COLLECTION_GROWTH / 2) * sizeof (ecma_value_t);
        1:  318:  ecma_value_t *compact_collection_p = (ecma_value_t *) jmem_heap_alloc_block (size);
        -:  319:
        1:  320:  ECMA_COMPACT_COLLECTION_SET_SIZE (compact_collection_p,
        -:  321:                                    ECMA_COMPACT_COLLECTION_GROWTH / 2,
        -:  322:                                    (ECMA_COMPACT_COLLECTION_GROWTH / 2) - 1);
        1:  323:  return compact_collection_p;
        -:  324:} /* ecma_new_compact_collection */
        -:  325:
        -:  326:/**
        -:  327: * Append a value to the compact collection
        -:  328: *
        -:  329: * @return updated pointer to the compact collection
        -:  330: */
        -:  331:ecma_value_t *
        3:  332:ecma_compact_collection_push_back (ecma_value_t *compact_collection_p, /**< compact collection */
        -:  333:                                   ecma_value_t value) /**< ecma value to append */
        -:  334:{
        3:  335:  ecma_value_t size = ECMA_COMPACT_COLLECTION_GET_SIZE (compact_collection_p);
        3:  336:  ecma_value_t unused_items = ECMA_COMPACT_COLLECTION_GET_UNUSED_ITEM_COUNT (compact_collection_p);
        -:  337:
        3:  338:  if (unused_items > 0)
        -:  339:  {
        3:  340:    compact_collection_p[size - unused_items] = value;
        3:  341:    (*compact_collection_p)--;
        3:  342:    return compact_collection_p;
        -:  343:  }
        -:  344:
    #####:  345:  if (size == ECMA_COMPACT_COLLECTION_GROWTH / 2)
        -:  346:  {
    #####:  347:    size_t old_size = (ECMA_COMPACT_COLLECTION_GROWTH / 2) * sizeof (ecma_value_t);
    #####:  348:    size_t new_size = ECMA_COMPACT_COLLECTION_GROWTH * sizeof (ecma_value_t);
    #####:  349:    compact_collection_p = jmem_heap_realloc_block (compact_collection_p, old_size, new_size);
        -:  350:
    #####:  351:    compact_collection_p[ECMA_COMPACT_COLLECTION_GROWTH / 2] = value;
        -:  352:
    #####:  353:    ECMA_COMPACT_COLLECTION_SET_SIZE (compact_collection_p,
        -:  354:                                      ECMA_COMPACT_COLLECTION_GROWTH,
        -:  355:                                      (ECMA_COMPACT_COLLECTION_GROWTH / 2) - 1);
    #####:  356:    return compact_collection_p;
        -:  357:  }
        -:  358:
    #####:  359:  size_t old_size = size * sizeof (ecma_value_t);
    #####:  360:  size_t new_size = old_size + (ECMA_COMPACT_COLLECTION_GROWTH * sizeof (ecma_value_t));
        -:  361:
    #####:  362:  compact_collection_p = jmem_heap_realloc_block (compact_collection_p, old_size, new_size);
    #####:  363:  compact_collection_p[size] = value;
        -:  364:
    #####:  365:  ECMA_COMPACT_COLLECTION_SET_SIZE (compact_collection_p,
        -:  366:                                    size + ECMA_COMPACT_COLLECTION_GROWTH,
        -:  367:                                    ECMA_COMPACT_COLLECTION_GROWTH - 1);
    #####:  368:  return compact_collection_p;
        -:  369:} /* ecma_compact_collection_push_back */
        -:  370:
        -:  371:/**
        -:  372: * Discard the unused elements of a compact collection
        -:  373: *
        -:  374: * Note:
        -:  375: *     further items should not be added after this call
        -:  376: *
        -:  377: * @return updated pointer to the compact collection
        -:  378: */
        -:  379:ecma_value_t *
    #####:  380:ecma_compact_collection_shrink (ecma_value_t *compact_collection_p) /**< compact collection */
        -:  381:{
    #####:  382:  ecma_value_t unused_items = ECMA_COMPACT_COLLECTION_GET_UNUSED_ITEM_COUNT (compact_collection_p);
        -:  383:
    #####:  384:  if (unused_items == 0)
        -:  385:  {
    #####:  386:    return compact_collection_p;
        -:  387:  }
        -:  388:
    #####:  389:  ecma_value_t size = ECMA_COMPACT_COLLECTION_GET_SIZE (compact_collection_p);
        -:  390:
    #####:  391:  size_t old_size = size * sizeof (ecma_value_t);
    #####:  392:  size_t new_size = (size - unused_items) * sizeof (ecma_value_t);
        -:  393:
    #####:  394:  compact_collection_p = jmem_heap_realloc_block (compact_collection_p, old_size, new_size);
        -:  395:
    #####:  396:  ECMA_COMPACT_COLLECTION_SET_SIZE (compact_collection_p, size - unused_items, 0);
    #####:  397:  return compact_collection_p;
        -:  398:} /* ecma_compact_collection_shrink */
        -:  399:
        -:  400:/**
        -:  401: * Free a compact collection
        -:  402: */
        -:  403:void
    #####:  404:ecma_compact_collection_free (ecma_value_t *compact_collection_p) /**< compact collection */
        -:  405:{
    #####:  406:  ecma_value_t size = ECMA_COMPACT_COLLECTION_GET_SIZE (compact_collection_p);
    #####:  407:  ecma_value_t unused_items = ECMA_COMPACT_COLLECTION_GET_UNUSED_ITEM_COUNT (compact_collection_p);
        -:  408:
    #####:  409:  ecma_value_t *end_p = compact_collection_p + size - unused_items;
    #####:  410:  ecma_value_t *current_p = compact_collection_p + 1;
        -:  411:
    #####:  412:  while (current_p < end_p)
        -:  413:  {
    #####:  414:    ecma_free_value (*current_p++);
        -:  415:  }
        -:  416:
    #####:  417:  jmem_heap_free_block (compact_collection_p, size * sizeof (ecma_value_t));
    #####:  418:} /* ecma_compact_collection_free */
        -:  419:
        -:  420:/**
        -:  421: * Get the end of a compact collection
        -:  422: *
        -:  423: * @return pointer to the compact collection end
        -:  424: */
        -:  425:ecma_value_t *
        5:  426:ecma_compact_collection_end (ecma_value_t *compact_collection_p) /**< compact collection */
        -:  427:{
        5:  428:  ecma_value_t size = ECMA_COMPACT_COLLECTION_GET_SIZE (compact_collection_p);
        5:  429:  ecma_value_t unused_items = ECMA_COMPACT_COLLECTION_GET_UNUSED_ITEM_COUNT (compact_collection_p);
        -:  430:
        5:  431:  return compact_collection_p + size - unused_items;
        -:  432:} /* ecma_compact_collection_end */
        -:  433:
        -:  434:/**
        -:  435: * Destroy a compact collection
        -:  436: */
        -:  437:void
    #####:  438:ecma_compact_collection_destroy (ecma_value_t *compact_collection_p) /**< compact collection */
        -:  439:{
    #####:  440:  ecma_value_t size = ECMA_COMPACT_COLLECTION_GET_SIZE (compact_collection_p);
        -:  441:
    #####:  442:  jmem_heap_free_block (compact_collection_p, size * sizeof (ecma_value_t));
    #####:  443:} /* ecma_compact_collection_destroy */
        -:  444:
        -:  445:/**
        -:  446: * @}
        -:  447: * @}
        -:  448: */
