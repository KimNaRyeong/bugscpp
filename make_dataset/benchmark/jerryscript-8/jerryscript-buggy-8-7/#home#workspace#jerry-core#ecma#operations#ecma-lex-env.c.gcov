        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-lex-env.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-lex-env.h"
        -:   17:
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-exceptions.h"
        -:   21:#include "ecma-gc.h"
        -:   22:#include "ecma-globals.h"
        -:   23:#include "ecma-helpers.h"
        -:   24:#include "ecma-objects.h"
        -:   25:#include "ecma-proxy-object.h"
        -:   26:
        -:   27:#include "jcontext.h"
        -:   28:
        -:   29:/** \addtogroup ecma ECMA
        -:   30: * @{
        -:   31: *
        -:   32: * \addtogroup lexicalenvironment Lexical environment
        -:   33: * @{
        -:   34: *
        -:   35: * \addtogroup globallexicalenvironment Global lexical environment
        -:   36: * @{
        -:   37: */
        -:   38:
        -:   39:/**
        -:   40: * Initialize Global environment
        -:   41: */
        -:   42:void
        1:   43:ecma_init_global_environment (void)
        -:   44:{
        1:   45:  JERRY_CONTEXT (global_object_p) = ecma_builtin_create_global_object ();
        1:   46:} /* ecma_init_global_environment */
        -:   47:
        -:   48:/**
        -:   49: * Finalize Global environment
        -:   50: */
        -:   51:void
    #####:   52:ecma_finalize_global_environment (void)
        -:   53:{
        -:   54:  /* After this point the gc can free the global object, but the global_object_p pointer
        -:   55:   * is not set to NULL because the global object might still be used before the free. */
    #####:   56:  ecma_deref_object ((ecma_object_t *) JERRY_CONTEXT (global_object_p));
    #####:   57:} /* ecma_finalize_global_environment */
        -:   58:
        -:   59:/**
        -:   60: * Get reference to Global lexical environment
        -:   61: * without increasing its reference count.
        -:   62: *
        -:   63: * @return pointer to the object's instance
        -:   64: */
        -:   65:ecma_object_t *
        1:   66:ecma_get_global_environment (ecma_object_t *global_object_p) /**< global object */
        -:   67:{
        1:   68:  JERRY_ASSERT (global_object_p != NULL && ecma_builtin_is_global (global_object_p));
        1:   69:  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, ((ecma_global_object_t *) global_object_p)->global_env_cp);
        -:   70:} /* ecma_get_global_environment */
        -:   71:
        -:   72:#if JERRY_ESNEXT
        -:   73:/**
        -:   74: * Create the global lexical block on top of the global environment.
        -:   75: */
        -:   76:void
        1:   77:ecma_create_global_lexical_block (ecma_object_t *global_object_p) /**< global object */
        -:   78:{
        1:   79:  JERRY_ASSERT (global_object_p != NULL && ecma_builtin_is_global (global_object_p));
        -:   80:
        1:   81:  ecma_global_object_t *real_global_object_p = (ecma_global_object_t *) global_object_p;
        -:   82:
        1:   83:  if (real_global_object_p->global_scope_cp == real_global_object_p->global_env_cp)
        -:   84:  {
        1:   85:    ecma_object_t *global_scope_p = ecma_create_decl_lex_env (ecma_get_global_environment (global_object_p));
        1:   86:    global_scope_p->type_flags_refs |= ECMA_OBJECT_FLAG_BLOCK;
        1:   87:    ECMA_SET_NON_NULL_POINTER (real_global_object_p->global_scope_cp, global_scope_p);
        1:   88:    ecma_deref_object (global_scope_p);
        -:   89:  }
        1:   90:} /* ecma_create_global_lexical_block */
        -:   91:#endif /* JERRY_ESNEXT */
        -:   92:
        -:   93:/**
        -:   94: * Raise the appropriate error when setting a binding is failed
        -:   95: *
        -:   96: * @return ECMA_VALUE_EMPTY or ECMA_VALUE_ERROR
        -:   97: */
        -:   98:ecma_value_t
    #####:   99:ecma_op_raise_set_binding_error (ecma_property_t *property_p, /**< property */
        -:  100:                                 bool is_strict) /**< flag indicating strict mode */
        -:  101:{
        -:  102:  JERRY_UNUSED (property_p);
        -:  103:
        -:  104:#if JERRY_ESNEXT
    #####:  105:  const ecma_property_t expected_bits = (ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_ENUMERABLE);
        -:  106:
    #####:  107:  if ((*property_p & expected_bits) == expected_bits)
        -:  108:  {
    #####:  109:    ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  110:
    #####:  111:    if (JERRY_UNLIKELY (property_value_p->value == ECMA_VALUE_UNINITIALIZED))
        -:  112:    {
    #####:  113:      return ecma_raise_reference_error (ECMA_ERR_LET_CONST_NOT_INITIALIZED);
        -:  114:    }
        -:  115:
    #####:  116:    JERRY_ASSERT (!ecma_is_property_writable (*property_p));
        -:  117:
    #####:  118:    return ecma_raise_type_error (ECMA_ERR_CONSTANT_BINDINGS_CANNOT_BE_REASSIGNED);
        -:  119:  }
        -:  120:#endif /* JERRY_ESNEXT */
        -:  121:
    #####:  122:  if (is_strict)
        -:  123:  {
    #####:  124:    return ecma_raise_type_error (ECMA_ERR_BINDING_CANNOT_SET);
        -:  125:  }
    #####:  126:  return ECMA_VALUE_EMPTY;
        -:  127:} /* ecma_op_raise_set_binding_error */
        -:  128:
        -:  129:/**
        -:  130: * Get reference to Global lexical scope
        -:  131: * without increasing its reference count.
        -:  132: *
        -:  133: * @return pointer to the object's instance
        -:  134: */
        -:  135:ecma_object_t *
        4:  136:ecma_get_global_scope (ecma_object_t *global_object_p) /**< global object */
        -:  137:{
        -:  138:#if JERRY_ESNEXT
        4:  139:  JERRY_ASSERT (global_object_p != NULL && ecma_builtin_is_global (global_object_p));
        4:  140:  return ECMA_GET_NON_NULL_POINTER (ecma_object_t, ((ecma_global_object_t *) global_object_p)->global_scope_cp);
        -:  141:#else /* !JERRY_ESNEXT */
    #####:  142:  return ecma_get_global_environment (global_object_p);
        -:  143:#endif /* !JERRY_ESNEXT */
        -:  144:} /* ecma_get_global_scope */
        -:  145:
        -:  146:/**
        -:  147: * @}
        -:  148: */
        -:  149:
        -:  150:/**
        -:  151: * HasBinding operation.
        -:  152: *
        -:  153: * See also: ECMA-262 v5, 10.2.1
        -:  154: *
        -:  155: * @return true / false
        -:  156: */
        -:  157:ecma_value_t
    #####:  158:ecma_op_has_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  159:                     ecma_string_t *name_p) /**< argument N */
        -:  160:{
    #####:  161:  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));
        -:  162:
    #####:  163:  ecma_lexical_environment_type_t lex_env_type = ecma_get_lex_env_type (lex_env_p);
        -:  164:
    #####:  165:  switch (lex_env_type)
        -:  166:  {
        -:  167:#if JERRY_ESNEXT
    #####:  168:    case ECMA_LEXICAL_ENVIRONMENT_CLASS:
        -:  169:    {
    #####:  170:      if (!ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))
        -:  171:      {
    #####:  172:        return ECMA_VALUE_FALSE;
        -:  173:      }
        -:  174:      /* FALLTHRU */
        -:  175:    }
        -:  176:#endif /* JERRY_ESNEXT */
    #####:  177:    case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:
        -:  178:    {
    #####:  179:      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  180:
    #####:  181:      return ecma_make_boolean_value (property_p != NULL);
        -:  182:    }
    #####:  183:    default:
        -:  184:    {
    #####:  185:      JERRY_ASSERT (lex_env_type == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  186:
    #####:  187:      ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  188:
    #####:  189:      return ecma_op_object_has_property (binding_obj_p, name_p);
        -:  190:    }
        -:  191:  }
        -:  192:} /* ecma_op_has_binding */
        -:  193:
        -:  194:/**
        -:  195: * CreateMutableBinding operation.
        -:  196: *
        -:  197: * See also: ECMA-262 v5, 10.2.1
        -:  198: *
        -:  199: * @return ECMA_PROPERTY_POINTER_ERROR - if the operation raises error
        -:  200: *         pointer to the created property - if the binding was created into a declerative environment
        -:  201: *         NULL - otherwise
        -:  202: */
        -:  203:ecma_property_t *
    #####:  204:ecma_op_create_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  205:                                ecma_string_t *name_p, /**< argument N */
        -:  206:                                bool is_deletable) /**< argument D */
        -:  207:{
    #####:  208:  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));
    #####:  209:  JERRY_ASSERT (name_p != NULL);
        -:  210:
    #####:  211:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  212:  {
    #####:  213:    uint8_t prop_attributes = ECMA_PROPERTY_FLAG_WRITABLE;
        -:  214:
    #####:  215:    if (is_deletable)
        -:  216:    {
    #####:  217:      prop_attributes = (uint8_t) (prop_attributes | ECMA_PROPERTY_FLAG_CONFIGURABLE);
        -:  218:    }
        -:  219:
    #####:  220:    ecma_property_t *prop_p;
        -:  221:
    #####:  222:    ecma_create_named_data_property (lex_env_p, name_p, prop_attributes, &prop_p);
    #####:  223:    return prop_p;
        -:  224:  }
        -:  225:  else
        -:  226:  {
    #####:  227:    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  228:
    #####:  229:    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  230:
        -:  231:#if JERRY_BUILTIN_PROXY && JERRY_BUILTIN_REALMS
    #####:  232:    if (ECMA_OBJECT_IS_PROXY (binding_obj_p))
        -:  233:    {
    #####:  234:      ecma_value_t result = ecma_proxy_object_is_extensible (binding_obj_p);
        -:  235:
    #####:  236:      if (ECMA_IS_VALUE_ERROR (result))
        -:  237:      {
    #####:  238:        return ECMA_PROPERTY_POINTER_ERROR;
        -:  239:      }
        -:  240:
    #####:  241:      if (result == ECMA_VALUE_FALSE)
        -:  242:      {
    #####:  243:        return NULL;
        -:  244:      }
        -:  245:    }
    #####:  246:    else if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))
        -:  247:    {
    #####:  248:      return NULL;
        -:  249:    }
        -:  250:#else /* !JERRY_BUILTIN_PROXY || !JERRY_BUILTIN_REALMS */
    #####:  251:    if (!ecma_op_ordinary_object_is_extensible (binding_obj_p))
        -:  252:    {
        -:  253:      return NULL;
        -:  254:    }
        -:  255:#endif /* JERRY_BUILTIN_PROXY && JERRY_BUILTIN_REALMS */
        -:  256:
    #####:  257:    const uint32_t flags = ECMA_PROPERTY_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  258:
    #####:  259:    ecma_value_t completion =
    #####:  260:      ecma_builtin_helper_def_prop (binding_obj_p,
        -:  261:                                    name_p,
        -:  262:                                    ECMA_VALUE_UNDEFINED,
        -:  263:                                    is_deletable ? flags | ECMA_PROPERTY_FLAG_CONFIGURABLE : flags);
        -:  264:
    #####:  265:    if (ECMA_IS_VALUE_ERROR (completion))
        -:  266:    {
    #####:  267:      return ECMA_PROPERTY_POINTER_ERROR;
        -:  268:    }
        -:  269:    else
        -:  270:    {
    #####:  271:      JERRY_ASSERT (ecma_is_value_boolean (completion));
        -:  272:    }
        -:  273:  }
        -:  274:
    #####:  275:  return NULL;
        -:  276:} /* ecma_op_create_mutable_binding */
        -:  277:
        -:  278:/**
        -:  279: * SetMutableBinding operation.
        -:  280: *
        -:  281: * See also: ECMA-262 v5, 10.2.1
        -:  282: *
        -:  283: * @return ecma value
        -:  284: *         Returned value must be freed with ecma_free_value.
        -:  285: */
        -:  286:ecma_value_t
    #####:  287:ecma_op_set_mutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  288:                             ecma_string_t *name_p, /**< argument N */
        -:  289:                             ecma_value_t value, /**< argument V */
        -:  290:                             bool is_strict) /**< argument S */
        -:  291:{
    #####:  292:  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));
    #####:  293:  JERRY_ASSERT (name_p != NULL);
        -:  294:
    #####:  295:  switch (ecma_get_lex_env_type (lex_env_p))
        -:  296:  {
        -:  297:#if JERRY_ESNEXT
    #####:  298:    case ECMA_LEXICAL_ENVIRONMENT_CLASS:
        -:  299:    {
    #####:  300:      if (!ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))
        -:  301:      {
    #####:  302:        return ECMA_VALUE_EMPTY;
        -:  303:      }
        -:  304:      /* FALLTHRU */
        -:  305:    }
        -:  306:#endif /* JERRY_ESNEXT */
    #####:  307:    case ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE:
        -:  308:    {
    #####:  309:      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  310:
    #####:  311:      if (JERRY_UNLIKELY (property_p == NULL))
        -:  312:      {
    #####:  313:        property_p = ecma_op_create_mutable_binding (lex_env_p, name_p, is_strict);
    #####:  314:        JERRY_ASSERT (property_p != ECMA_PROPERTY_POINTER_ERROR);
        -:  315:      }
        -:  316:
    #####:  317:      JERRY_ASSERT (property_p != NULL && ECMA_PROPERTY_IS_RAW_DATA (*property_p));
    #####:  318:      JERRY_ASSERT (!(*property_p & ECMA_PROPERTY_FLAG_WRITABLE) || (*property_p & ECMA_PROPERTY_FLAG_DATA));
        -:  319:
    #####:  320:      if ((*property_p & ECMA_PROPERTY_FLAG_WRITABLE))
        -:  321:      {
    #####:  322:        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  323:
    #####:  324:        JERRY_ASSERT (property_value_p->value != ECMA_VALUE_UNINITIALIZED);
        -:  325:
    #####:  326:        ecma_named_data_property_assign_value (lex_env_p, property_value_p, value);
    #####:  327:        return ECMA_VALUE_EMPTY;
        -:  328:      }
        -:  329:
    #####:  330:      return ecma_op_raise_set_binding_error (property_p, is_strict);
        -:  331:    }
    #####:  332:    default:
        -:  333:    {
    #####:  334:      JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  335:
    #####:  336:      ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  337:
    #####:  338:      ecma_value_t completion = ecma_op_object_put (binding_obj_p, name_p, value, is_strict);
        -:  339:
    #####:  340:      if (ECMA_IS_VALUE_ERROR (completion))
        -:  341:      {
    #####:  342:        return completion;
        -:  343:      }
        -:  344:
    #####:  345:      JERRY_ASSERT (ecma_is_value_boolean (completion));
    #####:  346:      return ECMA_VALUE_EMPTY;
        -:  347:    }
        -:  348:  }
        -:  349:} /* ecma_op_set_mutable_binding */
        -:  350:
        -:  351:/**
        -:  352: * GetBindingValue operation.
        -:  353: *
        -:  354: * See also: ECMA-262 v5, 10.2.1
        -:  355: *
        -:  356: * @return ecma value
        -:  357: *         Returned value must be freed with ecma_free_value.
        -:  358: */
        -:  359:ecma_value_t
    #####:  360:ecma_op_get_binding_value (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  361:                           ecma_string_t *name_p, /**< argument N */
        -:  362:                           bool is_strict) /**< argument S */
        -:  363:{
    #####:  364:  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));
    #####:  365:  JERRY_ASSERT (name_p != NULL);
        -:  366:
    #####:  367:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  368:  {
    #####:  369:    ecma_property_value_t *prop_value_p = ecma_get_named_data_property (lex_env_p, name_p);
        -:  370:
    #####:  371:    return ecma_copy_value (prop_value_p->value);
        -:  372:  }
        -:  373:  else
        -:  374:  {
    #####:  375:    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  376:
    #####:  377:    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  378:
    #####:  379:    ecma_value_t result = ecma_op_object_find (binding_obj_p, name_p);
        -:  380:
    #####:  381:    if (ECMA_IS_VALUE_ERROR (result))
        -:  382:    {
    #####:  383:      return result;
        -:  384:    }
        -:  385:
    #####:  386:    if (!ecma_is_value_found (result))
        -:  387:    {
    #####:  388:      if (is_strict)
        -:  389:      {
    #####:  390:        result = ecma_raise_reference_error (ECMA_ERR_BINDING_NOT_EXIST_OR_UNINITIALIZED);
        -:  391:      }
        -:  392:      else
        -:  393:      {
    #####:  394:        result = ECMA_VALUE_UNDEFINED;
        -:  395:      }
        -:  396:    }
        -:  397:
    #####:  398:    return result;
        -:  399:  }
        -:  400:} /* ecma_op_get_binding_value */
        -:  401:
        -:  402:/**
        -:  403: * DeleteBinding operation.
        -:  404: *
        -:  405: * See also: ECMA-262 v5, 10.2.1
        -:  406: *
        -:  407: * @return ecma value
        -:  408: *         Return ECMA_VALUE_ERROR - if the operation fails
        -:  409: *         ECMA_VALUE_{TRUE/FALSE} - depends on whether the binding can be deleted
        -:  410: */
        -:  411:ecma_value_t
    #####:  412:ecma_op_delete_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  413:                        ecma_string_t *name_p) /**< argument N */
        -:  414:{
    #####:  415:  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));
    #####:  416:  JERRY_ASSERT (name_p != NULL);
        -:  417:
    #####:  418:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  419:  {
    #####:  420:    ecma_property_t *prop_p = ecma_find_named_property (lex_env_p, name_p);
        -:  421:    ecma_value_t ret_val;
        -:  422:
    #####:  423:    if (prop_p == NULL)
        -:  424:    {
    #####:  425:      ret_val = ECMA_VALUE_TRUE;
        -:  426:    }
        -:  427:    else
        -:  428:    {
    #####:  429:      JERRY_ASSERT (ECMA_PROPERTY_IS_RAW_DATA (*prop_p));
        -:  430:
    #####:  431:      if (!ecma_is_property_configurable (*prop_p))
        -:  432:      {
    #####:  433:        ret_val = ECMA_VALUE_FALSE;
        -:  434:      }
        -:  435:      else
        -:  436:      {
    #####:  437:        ecma_delete_property (lex_env_p, ECMA_PROPERTY_VALUE_PTR (prop_p));
        -:  438:
    #####:  439:        ret_val = ECMA_VALUE_TRUE;
        -:  440:      }
        -:  441:    }
        -:  442:
    #####:  443:    return ret_val;
        -:  444:  }
        -:  445:  else
        -:  446:  {
    #####:  447:    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  448:
    #####:  449:    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
        -:  450:
    #####:  451:    return ecma_op_object_delete (binding_obj_p, name_p, false);
        -:  452:  }
        -:  453:} /* ecma_op_delete_binding */
        -:  454:
        -:  455:/**
        -:  456: * ImplicitThisValue operation.
        -:  457: *
        -:  458: * See also: ECMA-262 v5, 10.2.1
        -:  459: *
        -:  460: * @return ecma value
        -:  461: *         Returned value must be freed with ecma_free_value.
        -:  462: */
        -:  463:ecma_value_t
    #####:  464:ecma_op_implicit_this_value (ecma_object_t *lex_env_p) /**< lexical environment */
        -:  465:{
    #####:  466:  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));
        -:  467:
    #####:  468:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  469:  {
    #####:  470:    return ECMA_VALUE_UNDEFINED;
        -:  471:  }
        -:  472:  else
        -:  473:  {
    #####:  474:    JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND);
        -:  475:
    #####:  476:    ecma_object_t *binding_obj_p = ecma_get_lex_env_binding_object (lex_env_p);
    #####:  477:    ecma_ref_object (binding_obj_p);
        -:  478:
    #####:  479:    return ecma_make_object_value (binding_obj_p);
        -:  480:  }
        -:  481:} /* ecma_op_implicit_this_value */
        -:  482:
        -:  483:/**
        -:  484: * CreateImmutableBinding operation.
        -:  485: *
        -:  486: * See also: ECMA-262 v5, 10.2.1
        -:  487: */
        -:  488:void
    #####:  489:ecma_op_create_immutable_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  490:                                  ecma_string_t *name_p, /**< argument N */
        -:  491:                                  ecma_value_t value) /**< argument V */
        -:  492:{
    #####:  493:  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));
    #####:  494:  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -:  495:
        -:  496:  /*
        -:  497:   * Warning:
        -:  498:   *         Whether immutable bindings are deletable seems not to be defined by ECMA v5.
        -:  499:   */
    #####:  500:  ecma_property_value_t *prop_value_p = ecma_create_named_data_property (lex_env_p, name_p, ECMA_PROPERTY_FIXED, NULL);
        -:  501:
    #####:  502:  prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####:  503:} /* ecma_op_create_immutable_binding */
        -:  504:
        -:  505:#if JERRY_ESNEXT
        -:  506:/**
        -:  507: * InitializeBinding operation.
        -:  508: *
        -:  509: * See also: ECMA-262 v6, 8.1.1.1.4
        -:  510: */
        -:  511:void
        1:  512:ecma_op_initialize_binding (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  513:                            ecma_string_t *name_p, /**< argument N */
        -:  514:                            ecma_value_t value) /**< argument V */
        -:  515:{
        1:  516:  JERRY_ASSERT (lex_env_p != NULL && ecma_is_lexical_environment (lex_env_p));
        1:  517:  JERRY_ASSERT (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -:  518:
        1:  519:  ecma_property_t *prop_p = ecma_find_named_property (lex_env_p, name_p);
        1:  520:  JERRY_ASSERT (prop_p != NULL && ECMA_PROPERTY_IS_RAW_DATA (*prop_p));
        -:  521:
        1:  522:  ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
        1:  523:  JERRY_ASSERT (prop_value_p->value == ECMA_VALUE_UNINITIALIZED);
        -:  524:
        1:  525:  prop_value_p->value = ecma_copy_value_if_not_object (value);
        1:  526:} /* ecma_op_initialize_binding */
        -:  527:
        -:  528:/**
        -:  529: * BindThisValue operation for an empty lexical environment
        -:  530: *
        -:  531: * See also: ECMA-262 v6, 8.1.1.3.1
        -:  532: */
        -:  533:void
    #####:  534:ecma_op_create_environment_record (ecma_object_t *lex_env_p, /**< lexical environment */
        -:  535:                                   ecma_value_t this_binding, /**< this binding value */
        -:  536:                                   ecma_object_t *func_obj_p) /**< function object */
        -:  537:{
    #####:  538:  JERRY_ASSERT (lex_env_p != NULL);
    #####:  539:  JERRY_ASSERT (ecma_is_value_object (this_binding) || this_binding == ECMA_VALUE_UNINITIALIZED);
        -:  540:
        -:  541:  ecma_environment_record_t *environment_record_p;
    #####:  542:  environment_record_p = (ecma_environment_record_t *) jmem_heap_alloc_block (sizeof (ecma_environment_record_t));
        -:  543:
    #####:  544:  environment_record_p->this_binding = this_binding;
    #####:  545:  environment_record_p->function_object = ecma_make_object_value (func_obj_p);
        -:  546:
    #####:  547:  ecma_string_t *property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_ENVIRONMENT_RECORD);
        -:  548:
    #####:  549:  ecma_property_t *property_p;
        -:  550:  ecma_property_value_t *prop_value_p;
    #####:  551:  ECMA_CREATE_INTERNAL_PROPERTY (lex_env_p, property_name_p, property_p, prop_value_p);
        -:  552:
    #####:  553:  ECMA_SET_INTERNAL_VALUE_POINTER (prop_value_p->value, environment_record_p);
    #####:  554:} /* ecma_op_create_environment_record */
        -:  555:
        -:  556:/**
        -:  557: * GetThisEnvironment operation.
        -:  558: *
        -:  559: * See also: ECMA-262 v6, 8.3.2
        -:  560: *
        -:  561: * @return property pointer for the internal [[ThisBindingValue]] property
        -:  562: */
        -:  563:ecma_environment_record_t *
    #####:  564:ecma_op_get_environment_record (ecma_object_t *lex_env_p) /**< lexical environment */
        -:  565:{
    #####:  566:  JERRY_ASSERT (lex_env_p != NULL);
        -:  567:
    #####:  568:  ecma_string_t *property_name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_ENVIRONMENT_RECORD);
        -:  569:  while (true)
        -:  570:  {
    #####:  571:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  572:    {
    #####:  573:      ecma_property_t *property_p = ecma_find_named_property (lex_env_p, property_name_p);
        -:  574:
    #####:  575:      if (property_p != NULL)
        -:  576:      {
    #####:  577:        ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  578:        return ECMA_GET_INTERNAL_VALUE_POINTER (ecma_environment_record_t, property_value_p->value);
        -:  579:      }
        -:  580:    }
        -:  581:
    #####:  582:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -:  583:    {
    #####:  584:      break;
        -:  585:    }
        -:  586:
    #####:  587:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  588:  }
        -:  589:
    #####:  590:  return NULL;
        -:  591:} /* ecma_op_get_environment_record */
        -:  592:
        -:  593:/**
        -:  594: * Get the environment record [[ThisBindingStatus]] internal property.
        -:  595: *
        -:  596: * See also: ECMA-262 v6, 8.1.1.3
        -:  597: *
        -:  598: * @return true - if the status is "initialzed"
        -:  599: *         false - otherwise
        -:  600: */
        -:  601:bool
    #####:  602:ecma_op_this_binding_is_initialized (ecma_environment_record_t *environment_record_p) /**< environment record */
        -:  603:{
    #####:  604:  JERRY_ASSERT (environment_record_p != NULL);
        -:  605:
    #####:  606:  return environment_record_p->this_binding != ECMA_VALUE_UNINITIALIZED;
        -:  607:} /* ecma_op_this_binding_is_initialized */
        -:  608:
        -:  609:/**
        -:  610: * BindThisValue operation.
        -:  611: *
        -:  612: * See also: ECMA-262 v6, 8.1.1.3.1
        -:  613: */
        -:  614:void
    #####:  615:ecma_op_bind_this_value (ecma_environment_record_t *environment_record_p, /**< environment record */
        -:  616:                         ecma_value_t this_binding) /**< this binding value */
        -:  617:{
    #####:  618:  JERRY_ASSERT (environment_record_p != NULL);
    #####:  619:  JERRY_ASSERT (ecma_is_value_object (this_binding));
    #####:  620:  JERRY_ASSERT (!ecma_op_this_binding_is_initialized (environment_record_p));
        -:  621:
    #####:  622:  environment_record_p->this_binding = this_binding;
    #####:  623:} /* ecma_op_bind_this_value */
        -:  624:
        -:  625:/**
        -:  626: * GetThisBinding operation.
        -:  627: *
        -:  628: * See also: ECMA-262 v6, 8.1.1.3.4
        -:  629: *
        -:  630: * @return ECMA_VALUE_ERROR - if the operation fails
        -:  631: *         ecma-object - otherwise
        -:  632: */
        -:  633:ecma_value_t
    #####:  634:ecma_op_get_this_binding (ecma_object_t *lex_env_p) /**< lexical environment */
        -:  635:{
    #####:  636:  JERRY_ASSERT (lex_env_p != NULL);
        -:  637:
    #####:  638:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (lex_env_p);
    #####:  639:  JERRY_ASSERT (environment_record_p != NULL);
        -:  640:
    #####:  641:  ecma_value_t this_value = environment_record_p->this_binding;
        -:  642:
    #####:  643:  if (this_value == ECMA_VALUE_UNINITIALIZED)
        -:  644:  {
    #####:  645:    return ecma_raise_reference_error (ECMA_ERR_CALL_SUPER_CONSTRUCTOR_DERIVED_CLASS_BEFORE_THIS);
        -:  646:  }
        -:  647:
    #####:  648:  ecma_ref_object (ecma_get_object_from_value (this_value));
        -:  649:
    #####:  650:  return this_value;
        -:  651:} /* ecma_op_get_this_binding */
        -:  652:
        -:  653:#endif /* JERRY_ESNEXT */
        -:  654:
        -:  655:/**
        -:  656: * @}
        -:  657: * @}
        -:  658: */
