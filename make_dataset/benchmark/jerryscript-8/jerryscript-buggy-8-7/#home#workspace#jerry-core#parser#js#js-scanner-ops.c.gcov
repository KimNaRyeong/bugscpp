        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner-ops.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:#include "js-scanner-internal.h"
        -:   18:#include "lit-char-helpers.h"
        -:   19:
        -:   20:#if JERRY_PARSER
        -:   21:
        -:   22:/** \addtogroup parser Parser
        -:   23: * @{
        -:   24: *
        -:   25: * \addtogroup jsparser JavaScript
        -:   26: * @{
        -:   27: *
        -:   28: * \addtogroup jsparser_scanner Scanner
        -:   29: * @{
        -:   30: */
        -:   31:
        -:   32:#if JERRY_ESNEXT
        -:   33:
        -:   34:/**
        -:   35: * Add the "async" literal to the literal pool.
        -:   36: */
        -:   37:void
    #####:   38:scanner_add_async_literal (parser_context_t *context_p, /**< context */
        -:   39:                           scanner_context_t *scanner_context_p) /**< scanner context */
        -:   40:{
    #####:   41:  lexer_lit_location_t async_literal;
        -:   42:
    #####:   43:  JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC);
        -:   44:
    #####:   45:  parser_stack_pop_uint8 (context_p);
    #####:   46:  parser_stack_pop (context_p, &async_literal, sizeof (lexer_lit_location_t));
        -:   47:
    #####:   48:  lexer_lit_location_t *lit_location_p =
    #####:   49:    scanner_add_custom_literal (context_p, scanner_context_p->active_literal_pool_p, &async_literal);
        -:   50:
    #####:   51:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -:   52:
    #####:   53:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -:   54:  {
    #####:   55:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -:   56:  }
    #####:   57:} /* scanner_add_async_literal */
        -:   58:
        -:   59:/**
        -:   60: * Init scanning the body of an arrow function.
        -:   61: */
        -:   62:static void
    #####:   63:scanner_check_arrow_body (parser_context_t *context_p, /**< context */
        -:   64:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:   65:{
    #####:   66:  lexer_next_token (context_p);
        -:   67:
    #####:   68:  scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARROW;
        -:   69:
    #####:   70:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -:   71:  {
    #####:   72:    scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####:   73:    parser_stack_push_uint8 (context_p, SCAN_STACK_ARROW_EXPRESSION);
    #####:   74:    return;
        -:   75:  }
        -:   76:
    #####:   77:  lexer_next_token (context_p);
    #####:   78:  parser_stack_push_uint8 (context_p, SCAN_STACK_FUNCTION_ARROW);
    #####:   79:  scanner_check_directives (context_p, scanner_context_p);
        -:   80:} /* scanner_check_arrow_body */
        -:   81:
        -:   82:/**
        -:   83: * Process arrow function with argument list.
        -:   84: */
        -:   85:void
    #####:   86:scanner_check_arrow (parser_context_t *context_p, /**< context */
        -:   87:                     scanner_context_t *scanner_context_p) /**< scanner context */
        -:   88:{
    #####:   89:  parser_stack_pop_uint8 (context_p);
        -:   90:
    #####:   91:  lexer_next_token (context_p);
        -:   92:
    #####:   93:  if (context_p->token.type != LEXER_ARROW || (context_p->token.flags & LEXER_WAS_NEWLINE))
        -:   94:  {
    #####:   95:    if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:   96:    {
    #####:   97:      scanner_add_async_literal (context_p, scanner_context_p);
        -:   98:    }
        -:   99:
    #####:  100:    scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  101:    scanner_pop_literal_pool (context_p, scanner_context_p);
    #####:  102:    return;
        -:  103:  }
        -:  104:
    #####:  105:  if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  106:  {
    #####:  107:    parser_stack_pop (context_p, NULL, sizeof (lexer_lit_location_t) + 1);
        -:  108:  }
        -:  109:
    #####:  110:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
    #####:  111:  uint16_t status_flags = literal_pool_p->status_flags;
        -:  112:
    #####:  113:  bool is_async_arrow = (status_flags & SCANNER_LITERAL_POOL_MAY_ASYNC_ARROW) != 0;
        -:  114:
    #####:  115:  status_flags |= SCANNER_LITERAL_POOL_ARROW_FLAGS;
    #####:  116:  status_flags &=
        -:  117:    (uint16_t) ~(SCANNER_LITERAL_POOL_IN_WITH | SCANNER_LITERAL_POOL_GENERATOR | SCANNER_LITERAL_POOL_ASYNC);
        -:  118:
    #####:  119:  context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  120:
    #####:  121:  if (is_async_arrow)
        -:  122:  {
    #####:  123:    status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####:  124:    context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  125:  }
        -:  126:
    #####:  127:  literal_pool_p->status_flags = status_flags;
        -:  128:
    #####:  129:  scanner_filter_arguments (context_p, scanner_context_p);
    #####:  130:  scanner_check_arrow_body (context_p, scanner_context_p);
        -:  131:} /* scanner_check_arrow */
        -:  132:
        -:  133:/**
        -:  134: * Process arrow function with a single argument.
        -:  135: */
        -:  136:void
    #####:  137:scanner_scan_simple_arrow (parser_context_t *context_p, /**< context */
        -:  138:                           scanner_context_t *scanner_context_p, /**< scanner context */
        -:  139:                           const uint8_t *source_p) /**< identifier end position */
        -:  140:{
    #####:  141:  uint16_t status_flags = SCANNER_LITERAL_POOL_ARROW_FLAGS;
        -:  142:
    #####:  143:  context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  144:
    #####:  145:  if (scanner_context_p->async_source_p != NULL)
        -:  146:  {
    #####:  147:    JERRY_ASSERT (scanner_context_p->async_source_p == source_p);
        -:  148:
    #####:  149:    status_flags |= SCANNER_LITERAL_POOL_ASYNC;
    #####:  150:    context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  151:  }
        -:  152:
    #####:  153:  scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
    #####:  154:  literal_pool_p->source_p = source_p;
        -:  155:
    #####:  156:  lexer_lit_location_t *location_p = scanner_add_literal (context_p, scanner_context_p);
    #####:  157:  location_p->type |= SCANNER_LITERAL_IS_ARG;
        -:  158:
        -:  159:  /* Skip the => token, which size is two. */
    #####:  160:  context_p->source_p += 2;
    #####:  161:  PARSER_PLUS_EQUAL_LC (context_p->column, 2);
    #####:  162:  context_p->token.flags = (uint8_t) (context_p->token.flags & ~LEXER_NO_SKIP_SPACES);
        -:  163:
    #####:  164:  scanner_check_arrow_body (context_p, scanner_context_p);
    #####:  165:} /* scanner_scan_simple_arrow */
        -:  166:
        -:  167:/**
        -:  168: * Process the next argument of a might-be arrow function.
        -:  169: */
        -:  170:void
    #####:  171:scanner_check_arrow_arg (parser_context_t *context_p, /**< context */
        -:  172:                         scanner_context_t *scanner_context_p) /**< scanner context */
        -:  173:{
    #####:  174:  JERRY_ASSERT (context_p->stack_top_uint8 == SCAN_STACK_ARROW_ARGUMENTS);
        -:  175:
    #####:  176:  const uint8_t *source_p = context_p->source_p;
    #####:  177:  bool process_arrow = false;
        -:  178:
    #####:  179:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  180:
    #####:  181:  if (context_p->token.type == LEXER_THREE_DOTS)
        -:  182:  {
    #####:  183:    lexer_next_token (context_p);
        -:  184:  }
        -:  185:
    #####:  186:  switch (context_p->token.type)
        -:  187:  {
    #####:  188:    case LEXER_RIGHT_PAREN:
        -:  189:    {
    #####:  190:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
    #####:  191:      return;
        -:  192:    }
    #####:  193:    case LEXER_LITERAL:
        -:  194:    {
    #####:  195:      if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  196:      {
    #####:  197:        break;
        -:  198:      }
        -:  199:
    #####:  200:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
        -:  201:
    #####:  202:      if (lexer_check_arrow (context_p))
        -:  203:      {
    #####:  204:        process_arrow = true;
    #####:  205:        break;
        -:  206:      }
        -:  207:
    #####:  208:      lexer_lit_location_t *argument_literal_p = scanner_append_argument (context_p, scanner_context_p);
        -:  209:
    #####:  210:      scanner_detect_eval_call (context_p, scanner_context_p);
        -:  211:
    #####:  212:      lexer_next_token (context_p);
        -:  213:
    #####:  214:      if (context_p->token.type == LEXER_COMMA || context_p->token.type == LEXER_RIGHT_PAREN)
        -:  215:      {
    #####:  216:        return;
        -:  217:      }
        -:  218:
    #####:  219:      if (context_p->token.type != LEXER_ASSIGN)
        -:  220:      {
    #####:  221:        break;
        -:  222:      }
        -:  223:
    #####:  224:      if (argument_literal_p->type & SCANNER_LITERAL_IS_USED)
        -:  225:      {
    #####:  226:        JERRY_ASSERT (argument_literal_p->type & SCANNER_LITERAL_EARLY_CREATE);
    #####:  227:        return;
        -:  228:      }
        -:  229:
    #####:  230:      scanner_binding_literal_t binding_literal;
    #####:  231:      binding_literal.literal_p = argument_literal_p;
        -:  232:
    #####:  233:      parser_stack_push (context_p, &binding_literal, sizeof (scanner_binding_literal_t));
    #####:  234:      parser_stack_push_uint8 (context_p, SCAN_STACK_BINDING_INIT);
    #####:  235:      return;
        -:  236:    }
    #####:  237:    case LEXER_LEFT_SQUARE:
        -:  238:    case LEXER_LEFT_BRACE:
        -:  239:    {
    #####:  240:      scanner_append_hole (context_p, scanner_context_p);
    #####:  241:      scanner_push_destructuring_pattern (context_p, scanner_context_p, SCANNER_BINDING_ARROW_ARG, false);
        -:  242:
    #####:  243:      if (context_p->token.type == LEXER_LEFT_BRACE)
        -:  244:      {
        -:  245:#if JERRY_ESNEXT
    #####:  246:        parser_stack_push_uint8 (context_p, 0);
        -:  247:#endif /* JERRY_ESNEXT */
    #####:  248:        parser_stack_push_uint8 (context_p, SCAN_STACK_OBJECT_LITERAL);
    #####:  249:        scanner_context_p->mode = SCAN_MODE_PROPERTY_NAME;
    #####:  250:        return;
        -:  251:      }
        -:  252:
    #####:  253:      parser_stack_push_uint8 (context_p, SCAN_STACK_ARRAY_LITERAL);
    #####:  254:      scanner_context_p->mode = SCAN_MODE_BINDING;
    #####:  255:      lexer_next_token (context_p);
    #####:  256:      return;
        -:  257:    }
        -:  258:  }
        -:  259:
    #####:  260:  scanner_pop_literal_pool (context_p, scanner_context_p);
    #####:  261:  parser_stack_pop_uint8 (context_p);
        -:  262:
    #####:  263:  if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  264:  {
    #####:  265:    scanner_add_async_literal (context_p, scanner_context_p);
        -:  266:  }
        -:  267:
    #####:  268:  parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
        -:  269:
    #####:  270:  if (process_arrow)
        -:  271:  {
    #####:  272:    scanner_scan_simple_arrow (context_p, scanner_context_p, source_p);
        -:  273:  }
        -:  274:} /* scanner_check_arrow_arg */
        -:  275:
        -:  276:/**
        -:  277: * Detect async functions.
        -:  278: *
        -:  279: * @return true, if async is followed by a function keyword, false otherwise
        -:  280: */
        -:  281:bool
    #####:  282:scanner_check_async_function (parser_context_t *context_p, /**< context */
        -:  283:                              scanner_context_t *scanner_context_p) /**< scanner context */
        -:  284:{
    #####:  285:  JERRY_ASSERT (lexer_token_is_async (context_p));
    #####:  286:  JERRY_ASSERT (scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION
        -:  287:                || scanner_context_p->mode == SCAN_MODE_PRIMARY_EXPRESSION_AFTER_NEW);
    #####:  288:  JERRY_ASSERT (scanner_context_p->async_source_p != NULL);
        -:  289:
    #####:  290:  lexer_lit_location_t async_literal = context_p->token.lit_location;
        -:  291:
    #####:  292:  lexer_next_token (context_p);
        -:  293:
    #####:  294:  if (!(context_p->token.flags & LEXER_WAS_NEWLINE))
        -:  295:  {
    #####:  296:    if (context_p->token.type == LEXER_KEYW_FUNCTION)
        -:  297:    {
    #####:  298:      return true;
        -:  299:    }
        -:  300:
    #####:  301:    if (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL)
        -:  302:    {
    #####:  303:      if (!lexer_check_arrow (context_p))
        -:  304:      {
    #####:  305:        scanner_raise_error (context_p);
        -:  306:      }
        -:  307:
    #####:  308:      scanner_scan_simple_arrow (context_p, scanner_context_p, scanner_context_p->async_source_p);
    #####:  309:      scanner_context_p->async_source_p = NULL;
    #####:  310:      return false;
        -:  311:    }
        -:  312:
    #####:  313:    if (context_p->token.type == LEXER_LEFT_PAREN)
        -:  314:    {
    #####:  315:      parser_stack_push (context_p, &async_literal, sizeof (lexer_lit_location_t));
    #####:  316:      parser_stack_push_uint8 (context_p, SCAN_STACK_USE_ASYNC);
    #####:  317:      return false;
        -:  318:    }
        -:  319:  }
        -:  320:
    #####:  321:  lexer_lit_location_t *lit_location_p =
    #####:  322:    scanner_add_custom_literal (context_p, scanner_context_p->active_literal_pool_p, &async_literal);
    #####:  323:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -:  324:
    #####:  325:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -:  326:  {
    #####:  327:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -:  328:  }
        -:  329:
    #####:  330:  scanner_context_p->async_source_p = NULL;
    #####:  331:  scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  332:  return false;
        -:  333:} /* scanner_check_async_function */
        -:  334:
        -:  335:/**
        -:  336: * Check whether the statement of an if/else construct is a function statement.
        -:  337: */
        -:  338:void
    #####:  339:scanner_check_function_after_if (parser_context_t *context_p, /**< context */
        -:  340:                                 scanner_context_t *scanner_context_p) /**< scanner context */
        -:  341:{
    #####:  342:  lexer_next_token (context_p);
    #####:  343:  scanner_context_p->mode = SCAN_MODE_STATEMENT;
        -:  344:
    #####:  345:  if (JERRY_UNLIKELY (context_p->token.type == LEXER_KEYW_FUNCTION))
        -:  346:  {
        -:  347:    scanner_literal_pool_t *literal_pool_p;
    #####:  348:    literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        -:  349:
    #####:  350:    literal_pool_p->source_p = context_p->source_p;
    #####:  351:    parser_stack_push_uint8 (context_p, SCAN_STACK_PRIVATE_BLOCK);
        -:  352:  }
    #####:  353:} /* scanner_check_function_after_if */
        -:  354:
        -:  355:#endif /* JERRY_ESNEXT */
        -:  356:
        -:  357:#if JERRY_MODULE_SYSTEM
        -:  358:
        -:  359:/**
        -:  360: * Check whether the next token is meta.
        -:  361: */
        -:  362:void
    #####:  363:scanner_check_import_meta (parser_context_t *context_p) /**< context */
        -:  364:{
    #####:  365:  lexer_next_token (context_p);
        -:  366:
    #####:  367:  if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL
    #####:  368:      || context_p->token.keyword_type != LEXER_KEYW_META
    #####:  369:      || (context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE))
        -:  370:  {
    #####:  371:    scanner_raise_error (context_p);
        -:  372:  }
        -:  373:
    #####:  374:  lexer_next_token (context_p);
        -:  375:
    #####:  376:  context_p->global_status_flags |= ECMA_PARSE_INTERNAL_HAS_IMPORT_META;
    #####:  377:} /* scanner_check_import_meta */
        -:  378:
        -:  379:#endif /* JERRY_MODULE_SYSTEM */
        -:  380:
        -:  381:#if JERRY_ESNEXT
        -:  382:
        -:  383:/**
        -:  384: * Arrow types for scanner_scan_bracket() function.
        -:  385: */
        -:  386:typedef enum
        -:  387:{
        -:  388:  SCANNER_SCAN_BRACKET_NO_ARROW, /**< not an arrow function */
        -:  389:  SCANNER_SCAN_BRACKET_SIMPLE_ARROW, /**< simple arrow function */
        -:  390:  SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG, /**< arrow function with one argument */
        -:  391:} scanner_scan_bracket_arrow_type_t;
        -:  392:
        -:  393:#endif /* JERRY_ESNEXT */
        -:  394:
        -:  395:/**
        -:  396: * Scan bracketed expressions.
        -:  397: */
        -:  398:void
    #####:  399:scanner_scan_bracket (parser_context_t *context_p, /**< context */
        -:  400:                      scanner_context_t *scanner_context_p) /**< scanner context */
        -:  401:{
    #####:  402:  size_t depth = 0;
        -:  403:#if JERRY_ESNEXT
        -:  404:  const uint8_t *arrow_source_p;
    #####:  405:  const uint8_t *async_source_p = NULL;
    #####:  406:  scanner_scan_bracket_arrow_type_t arrow_type = SCANNER_SCAN_BRACKET_NO_ARROW;
        -:  407:#endif /* JERRY_ESNEXT */
        -:  408:
    #####:  409:  JERRY_ASSERT (context_p->token.type == LEXER_LEFT_PAREN);
        -:  410:
        -:  411:  do
        -:  412:  {
        -:  413:#if JERRY_ESNEXT
    #####:  414:    arrow_source_p = context_p->source_p;
        -:  415:#endif /* JERRY_ESNEXT */
    #####:  416:    depth++;
    #####:  417:    lexer_next_token (context_p);
    #####:  418:  } while (context_p->token.type == LEXER_LEFT_PAREN);
        -:  419:
    #####:  420:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
        -:  421:
    #####:  422:  switch (context_p->token.type)
        -:  423:  {
    #####:  424:    case LEXER_LITERAL:
        -:  425:    {
    #####:  426:      if (context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -:  427:      {
        -:  428:#if JERRY_ESNEXT
    #####:  429:        arrow_source_p = NULL;
        -:  430:#endif /* JERRY_ESNEXT */
    #####:  431:        break;
        -:  432:      }
        -:  433:
        -:  434:#if JERRY_ESNEXT
    #####:  435:      const uint8_t *source_p = context_p->source_p;
        -:  436:
    #####:  437:      if (lexer_check_arrow (context_p))
        -:  438:      {
    #####:  439:        arrow_source_p = source_p;
    #####:  440:        arrow_type = SCANNER_SCAN_BRACKET_SIMPLE_ARROW;
    #####:  441:        break;
        -:  442:      }
        -:  443:
    #####:  444:      size_t total_depth = depth;
        -:  445:#endif /* JERRY_ESNEXT */
        -:  446:
    #####:  447:      while (depth > 0 && lexer_check_next_character (context_p, LIT_CHAR_RIGHT_PAREN))
        -:  448:      {
    #####:  449:        lexer_consume_next_character (context_p);
    #####:  450:        depth--;
        -:  451:      }
        -:  452:
    #####:  453:      if (context_p->token.keyword_type == LEXER_KEYW_EVAL
    #####:  454:          && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -:  455:      {
        -:  456:#if JERRY_ESNEXT
        -:  457:        /* A function call cannot be an eval function. */
    #####:  458:        arrow_source_p = NULL;
    #####:  459:        const uint16_t flags = (uint16_t) (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);
        -:  460:#else /* !JERRY_ESNEXT */
    #####:  461:        const uint16_t flags = SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  462:#endif /* JERRY_ESNEXT */
        -:  463:
    #####:  464:        scanner_context_p->active_literal_pool_p->status_flags |= flags;
    #####:  465:        break;
        -:  466:      }
        -:  467:
        -:  468:#if JERRY_ESNEXT
    #####:  469:      if (total_depth == depth)
        -:  470:      {
    #####:  471:        if (lexer_check_arrow_param (context_p))
        -:  472:        {
    #####:  473:          JERRY_ASSERT (depth > 0);
    #####:  474:          depth--;
    #####:  475:          break;
        -:  476:        }
        -:  477:
    #####:  478:        if (JERRY_UNLIKELY (lexer_token_is_async (context_p)))
        -:  479:        {
    #####:  480:          async_source_p = source_p;
        -:  481:        }
        -:  482:      }
        -:  483:
    #####:  484:      if (depth == total_depth - 1 && lexer_check_arrow (context_p))
        -:  485:      {
    #####:  486:        arrow_type = SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG;
    #####:  487:        break;
        -:  488:      }
        -:  489:
    #####:  490:      if (context_p->stack_top_uint8 == SCAN_STACK_USE_ASYNC)
        -:  491:      {
    #####:  492:        scanner_add_async_literal (context_p, scanner_context_p);
        -:  493:      }
        -:  494:
    #####:  495:      arrow_source_p = NULL;
        -:  496:#endif /* JERRY_ESNEXT */
    #####:  497:      break;
        -:  498:    }
        -:  499:#if JERRY_ESNEXT
    #####:  500:    case LEXER_THREE_DOTS:
        -:  501:    case LEXER_LEFT_SQUARE:
        -:  502:    case LEXER_LEFT_BRACE:
        -:  503:    case LEXER_RIGHT_PAREN:
        -:  504:    {
    #####:  505:      JERRY_ASSERT (depth > 0);
    #####:  506:      depth--;
    #####:  507:      break;
        -:  508:    }
        -:  509:#endif /* JERRY_ESNEXT */
    #####:  510:    default:
        -:  511:    {
        -:  512:#if JERRY_ESNEXT
    #####:  513:      arrow_source_p = NULL;
        -:  514:#endif /* JERRY_ESNEXT */
    #####:  515:      break;
        -:  516:    }
        -:  517:  }
        -:  518:
        -:  519:#if JERRY_ESNEXT
    #####:  520:  if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL) && (arrow_source_p == NULL || depth > 0))
        -:  521:  {
    #####:  522:    scanner_context_p->async_source_p = NULL;
        -:  523:  }
        -:  524:#endif /* JERRY_ESNEXT */
        -:  525:
    #####:  526:  while (depth > 0)
        -:  527:  {
    #####:  528:    parser_stack_push_uint8 (context_p, SCAN_STACK_PAREN_EXPRESSION);
    #####:  529:    depth--;
        -:  530:  }
        -:  531:
        -:  532:#if JERRY_ESNEXT
    #####:  533:  if (arrow_source_p != NULL)
        -:  534:  {
    #####:  535:    JERRY_ASSERT (async_source_p == NULL);
        -:  536:
    #####:  537:    if (arrow_type == SCANNER_SCAN_BRACKET_SIMPLE_ARROW)
        -:  538:    {
    #####:  539:      scanner_scan_simple_arrow (context_p, scanner_context_p, arrow_source_p);
    #####:  540:      return;
        -:  541:    }
        -:  542:
    #####:  543:    parser_stack_push_uint8 (context_p, SCAN_STACK_ARROW_ARGUMENTS);
        -:  544:
    #####:  545:    uint16_t status_flags = 0;
        -:  546:
    #####:  547:    if (JERRY_UNLIKELY (scanner_context_p->async_source_p != NULL))
        -:  548:    {
    #####:  549:      status_flags |= SCANNER_LITERAL_POOL_MAY_ASYNC_ARROW;
    #####:  550:      arrow_source_p = scanner_context_p->async_source_p;
    #####:  551:      scanner_context_p->async_source_p = NULL;
        -:  552:    }
        -:  553:
        -:  554:    scanner_literal_pool_t *literal_pool_p;
    #####:  555:    literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, status_flags);
    #####:  556:    literal_pool_p->source_p = arrow_source_p;
        -:  557:
    #####:  558:    if (arrow_type == SCANNER_SCAN_BRACKET_ARROW_WITH_ONE_ARG)
        -:  559:    {
    #####:  560:      scanner_append_argument (context_p, scanner_context_p);
    #####:  561:      scanner_detect_eval_call (context_p, scanner_context_p);
        -:  562:
    #####:  563:      context_p->token.type = LEXER_RIGHT_PAREN;
    #####:  564:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  565:    }
    #####:  566:    else if (context_p->token.type == LEXER_RIGHT_PAREN)
        -:  567:    {
    #####:  568:      scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION_END;
        -:  569:    }
        -:  570:    else
        -:  571:    {
    #####:  572:      scanner_check_arrow_arg (context_p, scanner_context_p);
        -:  573:    }
        -:  574:  }
    #####:  575:  else if (JERRY_UNLIKELY (async_source_p != NULL))
        -:  576:  {
    #####:  577:    scanner_context_p->async_source_p = async_source_p;
    #####:  578:    scanner_check_async_function (context_p, scanner_context_p);
        -:  579:  }
        -:  580:#endif /* JERRY_ESNEXT */
    #####:  581:} /* scanner_scan_bracket */
        -:  582:
        -:  583:/**
        -:  584: * Check directives before a source block.
        -:  585: */
        -:  586:void
        5:  587:scanner_check_directives (parser_context_t *context_p, /**< context */
        -:  588:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:  589:{
        5:  590:  scanner_context_p->mode = SCAN_MODE_STATEMENT_OR_TERMINATOR;
        -:  591:
       10:  592:  while (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_STRING_LITERAL)
        -:  593:  {
    #####:  594:    bool is_use_strict = false;
        -:  595:
    #####:  596:    if (lexer_string_is_use_strict (context_p) && !(context_p->status_flags & PARSER_IS_STRICT))
        -:  597:    {
    #####:  598:      is_use_strict = true;
    #####:  599:      context_p->status_flags |= PARSER_IS_STRICT;
        -:  600:    }
        -:  601:
    #####:  602:    lexer_next_token (context_p);
        -:  603:
    #####:  604:    if (!lexer_string_is_directive (context_p))
        -:  605:    {
    #####:  606:      if (is_use_strict)
        -:  607:      {
    #####:  608:        context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -:  609:      }
        -:  610:
        -:  611:      /* The string is part of an expression statement. */
    #####:  612:      scanner_context_p->mode = SCAN_MODE_POST_PRIMARY_EXPRESSION;
    #####:  613:      break;
        -:  614:    }
        -:  615:
    #####:  616:    if (is_use_strict)
        -:  617:    {
    #####:  618:      scanner_context_p->active_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_IS_STRICT;
        -:  619:    }
        -:  620:
    #####:  621:    if (context_p->token.type == LEXER_SEMICOLON)
        -:  622:    {
    #####:  623:      lexer_next_token (context_p);
        -:  624:    }
        -:  625:  }
        5:  626:} /* scanner_check_directives */
        -:  627:
        -:  628:/**
        -:  629: * @}
        -:  630: * @}
        -:  631: * @}
        -:  632: */
        -:  633:
        -:  634:#endif /* JERRY_PARSER */
