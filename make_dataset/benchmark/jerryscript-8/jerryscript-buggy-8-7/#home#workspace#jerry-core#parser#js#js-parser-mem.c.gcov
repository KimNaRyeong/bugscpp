        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser-mem.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "js-parser-internal.h"
        -:   17:
        -:   18:#if JERRY_PARSER
        -:   19:
        -:   20:/** \addtogroup mem Memory allocation
        -:   21: * @{
        -:   22: *
        -:   23: * \addtogroup mem_parser Parser memory manager
        -:   24: * @{
        -:   25: */
        -:   26:
        -:   27:/**********************************************************************/
        -:   28:/* Memory allocation                                                  */
        -:   29:/**********************************************************************/
        -:   30:
        -:   31:/**
        -:   32: * Allocate memory.
        -:   33: *
        -:   34: * @return allocated memory.
        -:   35: */
        -:   36:void *
       35:   37:parser_malloc (parser_context_t *context_p, /**< context */
        -:   38:               size_t size) /**< size of the memory block */
        -:   39:{
        -:   40:  void *result;
        -:   41:
       35:   42:  JERRY_ASSERT (size > 0);
       35:   43:  result = jmem_heap_alloc_block_null_on_error (size);
        -:   44:
       35:   45:  if (result == NULL)
        -:   46:  {
    #####:   47:    parser_raise_error (context_p, PARSER_ERR_OUT_OF_MEMORY);
        -:   48:  }
       35:   49:  return result;
        -:   50:} /* parser_malloc */
        -:   51:
        -:   52:/**
        -:   53: * Free memory allocated by parser_malloc.
        -:   54: */
        -:   55:extern inline void JERRY_ATTR_ALWAYS_INLINE
        9:   56:parser_free (void *ptr, /**< pointer to free */
        -:   57:             size_t size) /**< size of the memory block */
        -:   58:{
       29:   59:  jmem_heap_free_block (ptr, size);
        9:   60:} /* parser_free */
        -:   61:
        -:   62:/**
        -:   63: * Allocate local memory for short term use.
        -:   64: *
        -:   65: * @return allocated memory.
        -:   66: */
        -:   67:void *
    #####:   68:parser_malloc_local (parser_context_t *context_p, /**< context */
        -:   69:                     size_t size) /**< size of the memory */
        -:   70:{
        -:   71:  void *result;
        -:   72:
    #####:   73:  JERRY_ASSERT (size > 0);
    #####:   74:  result = jmem_heap_alloc_block (size);
    #####:   75:  if (result == 0)
        -:   76:  {
    #####:   77:    parser_raise_error (context_p, PARSER_ERR_OUT_OF_MEMORY);
        -:   78:  }
    #####:   79:  return result;
        -:   80:} /* parser_malloc_local */
        -:   81:
        -:   82:/**
        -:   83: * Free memory allocated by parser_malloc_local.
        -:   84: */
        -:   85:void
    #####:   86:parser_free_local (void *ptr, /**< pointer to free */
        -:   87:                   size_t size) /**< size of the memory */
        -:   88:{
    #####:   89:  jmem_heap_free_block (ptr, size);
    #####:   90:} /* parser_free_local */
        -:   91:
        -:   92:/**
        -:   93: * Free the dynamically allocated buffer stored in the context
        -:   94: */
        -:   95:extern inline void JERRY_ATTR_ALWAYS_INLINE
       17:   96:parser_free_allocated_buffer (parser_context_t *context_p) /**< context */
        -:   97:{
       17:   98:  if (context_p->u.allocated_buffer_p != NULL)
        -:   99:  {
    #####:  100:    parser_free_local (context_p->u.allocated_buffer_p, context_p->allocated_buffer_size);
    #####:  101:    context_p->u.allocated_buffer_p = NULL;
        -:  102:  }
       17:  103:} /* parser_free_allocated_buffer */
        -:  104:
        -:  105:/**********************************************************************/
        -:  106:/* Parser data management functions                                   */
        -:  107:/**********************************************************************/
        -:  108:
        -:  109:/**
        -:  110: * Initialize parse data.
        -:  111: */
        -:  112:static void
       18:  113:parser_data_init (parser_mem_data_t *data_p, /**< memory manager */
        -:  114:                  uint32_t page_size) /**< size of each page */
        -:  115:{
       18:  116:  data_p->first_p = NULL;
       18:  117:  data_p->last_p = NULL;
       18:  118:  data_p->last_position = page_size;
       18:  119:} /* parser_data_init */
        -:  120:
        -:  121:/**
        -:  122: * Free parse data.
        -:  123: */
        -:  124:static void
       18:  125:parser_data_free (parser_mem_data_t *data_p, /**< memory manager */
        -:  126:                  uint32_t page_size) /**< size of each page */
        -:  127:{
       18:  128:  parser_mem_page_t *page_p = data_p->first_p;
        -:  129:
       56:  130:  while (page_p != NULL)
        -:  131:  {
       20:  132:    parser_mem_page_t *next_p = page_p->next_p;
        -:  133:
    #####:  134:    parser_free (page_p, page_size);
       20:  135:    page_p = next_p;
        -:  136:  }
       18:  137:} /* parser_data_free */
        -:  138:
        -:  139:/**********************************************************************/
        -:  140:/* Parser byte stream management functions                            */
        -:  141:/**********************************************************************/
        -:  142:
        -:  143:/**
        -:  144: * Initialize byte stream.
        -:  145: */
        -:  146:void
        5:  147:parser_cbc_stream_init (parser_mem_data_t *data_p) /**< memory manager */
        -:  148:{
        5:  149:  parser_data_init (data_p, PARSER_CBC_STREAM_PAGE_SIZE);
        5:  150:} /* parser_cbc_stream_init */
        -:  151:
        -:  152:/**
        -:  153: * Free byte stream.
        -:  154: */
        -:  155:void
        5:  156:parser_cbc_stream_free (parser_mem_data_t *data_p) /**< memory manager */
        -:  157:{
        5:  158:  parser_data_free (data_p, sizeof (parser_mem_page_t *) + PARSER_CBC_STREAM_PAGE_SIZE);
        5:  159:} /* parser_cbc_stream_free */
        -:  160:
        -:  161:/**
        -:  162: * Appends a byte at the end of the byte stream.
        -:  163: */
        -:  164:void
        6:  165:parser_cbc_stream_alloc_page (parser_context_t *context_p, /**< context */
        -:  166:                              parser_mem_data_t *data_p) /**< memory manager */
        -:  167:{
        6:  168:  size_t size = sizeof (parser_mem_page_t *) + PARSER_CBC_STREAM_PAGE_SIZE;
        6:  169:  parser_mem_page_t *page_p = (parser_mem_page_t *) parser_malloc (context_p, size);
        -:  170:
        6:  171:  page_p->next_p = NULL;
        6:  172:  data_p->last_position = 0;
        -:  173:
        6:  174:  if (data_p->last_p != NULL)
        -:  175:  {
        1:  176:    data_p->last_p->next_p = page_p;
        -:  177:  }
        -:  178:  else
        -:  179:  {
        5:  180:    data_p->first_p = page_p;
        -:  181:  }
        6:  182:  data_p->last_p = page_p;
        6:  183:} /* parser_cbc_stream_alloc_page */
        -:  184:
        -:  185:/**********************************************************************/
        -:  186:/* Parser list management functions                                   */
        -:  187:/**********************************************************************/
        -:  188:
        -:  189:/**
        -:  190: * Initialize parser list.
        -:  191: */
        -:  192:void
        7:  193:parser_list_init (parser_list_t *list_p, /**< parser list */
        -:  194:                  uint32_t item_size, /**< size for each page */
        -:  195:                  uint32_t item_count) /**< number of items on each page */
        -:  196:{
        -:  197:  /* Align to pointer size. */
        7:  198:  item_size = (uint32_t) (((item_size) + sizeof (void *) - 1) & ~(sizeof (void *) - 1));
        7:  199:  parser_data_init (&list_p->data, item_size * item_count);
        7:  200:  list_p->page_size = item_size * item_count;
        7:  201:  list_p->item_size = item_size;
        7:  202:  list_p->item_count = item_count;
        7:  203:} /* parser_list_init */
        -:  204:
        -:  205:/**
        -:  206: * Free parser list.
        -:  207: */
        -:  208:void
       11:  209:parser_list_free (parser_list_t *list_p) /**< parser list */
        -:  210:{
       11:  211:  parser_data_free (&list_p->data, (uint32_t) (sizeof (parser_mem_page_t *) + list_p->page_size));
       11:  212:} /* parser_list_free */
        -:  213:
        -:  214:/**
        -:  215: * Reset parser list.
        -:  216: */
        -:  217:void
        4:  218:parser_list_reset (parser_list_t *list_p) /**< parser list */
        -:  219:{
        4:  220:  parser_data_init (&list_p->data, list_p->page_size);
        4:  221:} /* parser_list_reset */
        -:  222:
        -:  223:/**
        -:  224: * Allocate space for the next item.
        -:  225: *
        -:  226: * @return pointer to the appended item.
        -:  227: */
        -:  228:void *
       39:  229:parser_list_append (parser_context_t *context_p, /**< context */
        -:  230:                    parser_list_t *list_p) /**< parser list */
        -:  231:{
       39:  232:  parser_mem_page_t *page_p = list_p->data.last_p;
        -:  233:  void *result;
        -:  234:
       39:  235:  if (list_p->data.last_position + list_p->item_size > list_p->page_size)
        -:  236:  {
       12:  237:    size_t size = sizeof (parser_mem_page_t *) + list_p->page_size;
        -:  238:
       12:  239:    page_p = (parser_mem_page_t *) parser_malloc (context_p, size);
        -:  240:
       12:  241:    page_p->next_p = NULL;
       12:  242:    list_p->data.last_position = 0;
        -:  243:
       12:  244:    if (list_p->data.last_p != NULL)
        -:  245:    {
        1:  246:      list_p->data.last_p->next_p = page_p;
        -:  247:    }
        -:  248:    else
        -:  249:    {
       11:  250:      list_p->data.first_p = page_p;
        -:  251:    }
       12:  252:    list_p->data.last_p = page_p;
        -:  253:  }
        -:  254:
       39:  255:  result = page_p->bytes + list_p->data.last_position;
       39:  256:  list_p->data.last_position += list_p->item_size;
       39:  257:  return result;
        -:  258:} /* parser_list_append */
        -:  259:
        -:  260:/**
        -:  261: * Return the nth item of the list.
        -:  262: *
        -:  263: * @return pointer to the item.
        -:  264: */
        -:  265:void *
       46:  266:parser_list_get (parser_list_t *list_p, /**< parser list */
        -:  267:                 size_t index) /**< item index */
        -:  268:{
       46:  269:  size_t item_count = list_p->item_count;
       46:  270:  parser_mem_page_t *page_p = list_p->data.first_p;
        -:  271:
       97:  272:  while (index >= item_count)
        -:  273:  {
        5:  274:    JERRY_ASSERT (page_p != NULL);
        5:  275:    page_p = page_p->next_p;
        5:  276:    index -= item_count;
        -:  277:  }
        -:  278:
       46:  279:  JERRY_ASSERT (page_p != NULL);
       46:  280:  JERRY_ASSERT (page_p != list_p->data.last_p || (index * list_p->item_size < list_p->data.last_position));
       46:  281:  return page_p->bytes + (index * list_p->item_size);
        -:  282:} /* parser_list_get */
        -:  283:
        -:  284:/**
        -:  285: * Initialize a parser list iterator.
        -:  286: */
        -:  287:void
       97:  288:parser_list_iterator_init (parser_list_t *list_p, /**< parser list */
        -:  289:                           parser_list_iterator_t *iterator_p) /**< iterator */
        -:  290:{
       97:  291:  iterator_p->list_p = list_p;
       97:  292:  iterator_p->current_p = list_p->data.first_p;
       97:  293:  iterator_p->current_position = 0;
       97:  294:} /* parser_list_iterator_init */
        -:  295:
        -:  296:/**
        -:  297: * Next iterator step.
        -:  298: *
        -:  299: * @return the address of the current item, or NULL at the end.
        -:  300: */
        -:  301:void *
      365:  302:parser_list_iterator_next (parser_list_iterator_t *iterator_p) /**< iterator */
        -:  303:{
        -:  304:  void *result;
        -:  305:
      365:  306:  if (iterator_p->current_p == NULL)
        -:  307:  {
       70:  308:    return NULL;
        -:  309:  }
        -:  310:
      295:  311:  result = iterator_p->current_p->bytes + iterator_p->current_position;
      295:  312:  iterator_p->current_position += iterator_p->list_p->item_size;
        -:  313:
      295:  314:  if (iterator_p->current_p->next_p == NULL)
        -:  315:  {
      214:  316:    if (iterator_p->current_position >= iterator_p->list_p->data.last_position)
        -:  317:    {
       62:  318:      iterator_p->current_p = NULL;
       62:  319:      iterator_p->current_position = 0;
        -:  320:    }
        -:  321:  }
       81:  322:  else if (iterator_p->current_position >= iterator_p->list_p->page_size)
        -:  323:  {
        7:  324:    iterator_p->current_p = iterator_p->current_p->next_p;
        7:  325:    iterator_p->current_position = 0;
        -:  326:  }
      295:  327:  return result;
        -:  328:} /* parser_list_iterator_next */
        -:  329:
        -:  330:/**********************************************************************/
        -:  331:/* Parser stack management functions                                  */
        -:  332:/**********************************************************************/
        -:  333:
        -:  334:/* Stack is a reversed storage. */
        -:  335:
        -:  336:/**
        -:  337: * Initialize parser stack.
        -:  338: */
        -:  339:void
        2:  340:parser_stack_init (parser_context_t *context_p) /**< context */
        -:  341:{
        2:  342:  parser_data_init (&context_p->stack, PARSER_STACK_PAGE_SIZE);
        2:  343:  context_p->free_page_p = NULL;
        2:  344:} /* parser_stack_init */
        -:  345:
        -:  346:/**
        -:  347: * Free parser stack.
        -:  348: */
        -:  349:void
        2:  350:parser_stack_free (parser_context_t *context_p) /**< context */
        -:  351:{
        2:  352:  parser_data_free (&context_p->stack, sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);
        -:  353:
        2:  354:  if (context_p->free_page_p != NULL)
        -:  355:  {
    #####:  356:    parser_free (context_p->free_page_p, sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);
        -:  357:  }
        2:  358:} /* parser_stack_free */
        -:  359:
        -:  360:/**
        -:  361: * Pushes an uint8_t value onto the stack.
        -:  362: */
        -:  363:void
       52:  364:parser_stack_push_uint8 (parser_context_t *context_p, /**< context */
        -:  365:                         uint8_t uint8_value) /**< value pushed onto the stack */
        -:  366:{
       52:  367:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  368:
        -:  369:  /* This assert might trigger false positive valgrind errors, when
        -:  370:   * parser_stack_push() pushes not fully initialized structures.
        -:  371:   * More precisely when the last byte of the structure is uninitialized. */
       52:  372:  JERRY_ASSERT (page_p == NULL || context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  373:
       52:  374:  if (context_p->stack.last_position >= PARSER_STACK_PAGE_SIZE)
        -:  375:  {
        2:  376:    if (context_p->free_page_p != NULL)
        -:  377:    {
    #####:  378:      page_p = context_p->free_page_p;
    #####:  379:      context_p->free_page_p = NULL;
        -:  380:    }
        -:  381:    else
        -:  382:    {
        2:  383:      size_t size = sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE;
        2:  384:      page_p = (parser_mem_page_t *) parser_malloc (context_p, size);
        -:  385:    }
        -:  386:
        2:  387:    page_p->next_p = context_p->stack.first_p;
        2:  388:    context_p->stack.last_position = 0;
        2:  389:    context_p->stack.first_p = page_p;
        -:  390:  }
        -:  391:
       52:  392:  page_p->bytes[context_p->stack.last_position++] = uint8_value;
       52:  393:  context_p->stack_top_uint8 = uint8_value;
       52:  394:} /* parser_stack_push_uint8 */
        -:  395:
        -:  396:/**
        -:  397: * Pops the last uint8_t value from the stack.
        -:  398: */
        -:  399:void
       50:  400:parser_stack_pop_uint8 (parser_context_t *context_p) /**< context */
        -:  401:{
       50:  402:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  403:
       50:  404:  JERRY_ASSERT (page_p != NULL && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  405:
       50:  406:  context_p->stack.last_position--;
        -:  407:
       50:  408:  if (context_p->stack.last_position == 0)
        -:  409:  {
    #####:  410:    context_p->stack.first_p = page_p->next_p;
    #####:  411:    context_p->stack.last_position = PARSER_STACK_PAGE_SIZE;
        -:  412:
    #####:  413:    if (context_p->free_page_p == NULL)
        -:  414:    {
    #####:  415:      context_p->free_page_p = page_p;
        -:  416:    }
        -:  417:    else
        -:  418:    {
        -:  419:      parser_free (page_p, sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);
        -:  420:    }
        -:  421:
    #####:  422:    page_p = context_p->stack.first_p;
        -:  423:
    #####:  424:    JERRY_ASSERT (page_p != NULL);
        -:  425:  }
        -:  426:
       50:  427:  context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 1];
       50:  428:} /* parser_stack_pop_uint8 */
        -:  429:
        -:  430:/**
        -:  431: * Change last byte of the stack.
        -:  432: */
        -:  433:void
    #####:  434:parser_stack_change_last_uint8 (parser_context_t *context_p, /**< context */
        -:  435:                                uint8_t new_value) /**< new value */
        -:  436:{
    #####:  437:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  438:
    #####:  439:  JERRY_ASSERT (page_p != NULL && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  440:
    #####:  441:  page_p->bytes[context_p->stack.last_position - 1] = new_value;
    #####:  442:  context_p->stack_top_uint8 = new_value;
    #####:  443:} /* parser_stack_change_last_uint8 */
        -:  444:
        -:  445:/**
        -:  446: * Get the uint8 value before the top of the stack.
        -:  447: *
        -:  448: * Pointer to the uint8 value
        -:  449: */
        -:  450:uint8_t *
    #####:  451:parser_stack_get_prev_uint8 (parser_context_t *context_p) /**< context */
        -:  452:{
    #####:  453:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  454:
    #####:  455:  JERRY_ASSERT (page_p != NULL && (context_p->stack.last_position >= 2 || page_p->next_p != NULL));
        -:  456:
    #####:  457:  if (context_p->stack.last_position >= 2)
        -:  458:  {
    #####:  459:    return page_p->bytes + (context_p->stack.last_position - 2);
        -:  460:  }
        -:  461:
    #####:  462:  return page_p->next_p->bytes + (PARSER_STACK_PAGE_SIZE - 1);
        -:  463:} /* parser_stack_get_prev_uint8 */
        -:  464:
        -:  465:/**
        -:  466: * Pushes an uint16_t value onto the stack.
        -:  467: */
        -:  468:void
        1:  469:parser_stack_push_uint16 (parser_context_t *context_p, /**< context */
        -:  470:                          uint16_t uint16_value) /**< value pushed onto the stack */
        -:  471:{
        1:  472:  if (context_p->stack.last_position + 2 <= PARSER_STACK_PAGE_SIZE)
        -:  473:  {
        1:  474:    parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  475:
        1:  476:    JERRY_ASSERT (page_p != NULL && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  477:
        1:  478:    page_p->bytes[context_p->stack.last_position++] = (uint8_t) (uint16_value >> 8);
        1:  479:    page_p->bytes[context_p->stack.last_position++] = (uint8_t) uint16_value;
        1:  480:    context_p->stack_top_uint8 = (uint8_t) uint16_value;
        -:  481:  }
        -:  482:  else
        -:  483:  {
    #####:  484:    parser_stack_push_uint8 (context_p, (uint8_t) (uint16_value >> 8));
    #####:  485:    parser_stack_push_uint8 (context_p, (uint8_t) uint16_value);
        -:  486:  }
        1:  487:} /* parser_stack_push_uint16 */
        -:  488:
        -:  489:/**
        -:  490: * Pops the last uint16_t value from the stack.
        -:  491: *
        -:  492: * @return the value popped from the stack.
        -:  493: */
        -:  494:uint16_t
        1:  495:parser_stack_pop_uint16 (parser_context_t *context_p) /**< context */
        -:  496:{
        1:  497:  uint32_t value = context_p->stack_top_uint8;
        -:  498:
        1:  499:  if (context_p->stack.last_position >= 3)
        -:  500:  {
        1:  501:    parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  502:
        1:  503:    JERRY_ASSERT (page_p != NULL && context_p->stack_top_uint8 == page_p->bytes[context_p->stack.last_position - 1]);
        -:  504:
        1:  505:    value |= ((uint32_t) page_p->bytes[context_p->stack.last_position - 2]) << 8;
        1:  506:    context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 3];
        1:  507:    context_p->stack.last_position -= 2;
        -:  508:  }
        -:  509:  else
        -:  510:  {
    #####:  511:    parser_stack_pop_uint8 (context_p);
    #####:  512:    value |= ((uint32_t) context_p->stack_top_uint8) << 8;
    #####:  513:    parser_stack_pop_uint8 (context_p);
        -:  514:  }
        1:  515:  return (uint16_t) value;
        -:  516:} /* parser_stack_pop_uint16 */
        -:  517:
        -:  518:/**
        -:  519: * Pushes a data onto the stack.
        -:  520: */
        -:  521:void
        6:  522:parser_stack_push (parser_context_t *context_p, /**< context */
        -:  523:                   const void *data_p, /**< data pushed onto the stack */
        -:  524:                   uint32_t length) /**< length of the data */
        -:  525:{
        6:  526:  uint32_t fragment_length = PARSER_STACK_PAGE_SIZE - context_p->stack.last_position;
        6:  527:  const uint8_t *bytes_p = (const uint8_t *) data_p;
        -:  528:  parser_mem_page_t *page_p;
        -:  529:
        6:  530:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  531:
        6:  532:  context_p->stack_top_uint8 = bytes_p[length - 1];
        -:  533:
        6:  534:  if (fragment_length > 0)
        -:  535:  {
        -:  536:    /* Fill the remaining bytes. */
        6:  537:    if (fragment_length > length)
        -:  538:    {
        6:  539:      fragment_length = length;
        -:  540:    }
        -:  541:
        6:  542:    memcpy (context_p->stack.first_p->bytes + context_p->stack.last_position, bytes_p, fragment_length);
        -:  543:
        6:  544:    if (fragment_length == length)
        -:  545:    {
        6:  546:      context_p->stack.last_position += length;
        6:  547:      return;
        -:  548:    }
        -:  549:
    #####:  550:    bytes_p += fragment_length;
    #####:  551:    length -= fragment_length;
        -:  552:  }
        -:  553:
    #####:  554:  if (context_p->free_page_p != NULL)
        -:  555:  {
    #####:  556:    page_p = context_p->free_page_p;
    #####:  557:    context_p->free_page_p = NULL;
        -:  558:  }
        -:  559:  else
        -:  560:  {
    #####:  561:    size_t size = sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE;
        -:  562:
    #####:  563:    page_p = (parser_mem_page_t *) parser_malloc (context_p, size);
        -:  564:  }
        -:  565:
    #####:  566:  page_p->next_p = context_p->stack.first_p;
        -:  567:
    #####:  568:  context_p->stack.first_p = page_p;
        -:  569:
    #####:  570:  memcpy (page_p->bytes, bytes_p, length);
    #####:  571:  context_p->stack.last_position = length;
        -:  572:} /* parser_stack_push */
        -:  573:
        -:  574:/**
        -:  575: * Pop bytes from the top of the stack.
        -:  576: */
        -:  577:void
        6:  578:parser_stack_pop (parser_context_t *context_p, /**< context */
        -:  579:                  void *data_p, /**< destination buffer, can be NULL */
        -:  580:                  uint32_t length) /**< length of the data */
        -:  581:{
        6:  582:  uint8_t *bytes_p = (uint8_t *) data_p;
        6:  583:  parser_mem_page_t *page_p = context_p->stack.first_p;
        -:  584:
        6:  585:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  586:
        6:  587:  if (context_p->stack.last_position > length)
        -:  588:  {
        6:  589:    context_p->stack.last_position -= length;
        6:  590:    context_p->stack_top_uint8 = page_p->bytes[context_p->stack.last_position - 1];
        -:  591:
        6:  592:    if (bytes_p != NULL)
        -:  593:    {
        6:  594:      memcpy (bytes_p, context_p->stack.first_p->bytes + context_p->stack.last_position, length);
        -:  595:    }
        6:  596:    return;
        -:  597:  }
        -:  598:
    #####:  599:  JERRY_ASSERT (page_p->next_p != NULL);
        -:  600:
    #####:  601:  length -= context_p->stack.last_position;
        -:  602:
    #####:  603:  if (bytes_p != NULL)
        -:  604:  {
    #####:  605:    memcpy (bytes_p + length, page_p->bytes, context_p->stack.last_position);
        -:  606:  }
        -:  607:
    #####:  608:  context_p->stack.first_p = page_p->next_p;
    #####:  609:  context_p->stack.last_position = PARSER_STACK_PAGE_SIZE - length;
    #####:  610:  context_p->stack_top_uint8 = page_p->next_p->bytes[context_p->stack.last_position - 1];
        -:  611:
    #####:  612:  if (bytes_p != NULL && length > 0)
        -:  613:  {
    #####:  614:    memcpy (bytes_p, page_p->next_p->bytes + context_p->stack.last_position, length);
        -:  615:  }
        -:  616:
    #####:  617:  JERRY_ASSERT (context_p->stack.last_position > 0);
        -:  618:
    #####:  619:  if (context_p->free_page_p == NULL)
        -:  620:  {
    #####:  621:    context_p->free_page_p = page_p;
        -:  622:  }
        -:  623:  else
        -:  624:  {
        -:  625:    parser_free (page_p, sizeof (parser_mem_page_t *) + PARSER_STACK_PAGE_SIZE);
        -:  626:  }
        -:  627:} /* parser_stack_pop */
        -:  628:
        -:  629:/**
        -:  630: * Initialize stack iterator.
        -:  631: */
        -:  632:extern inline void
        5:  633:parser_stack_iterator_init (parser_context_t *context_p, /**< context */
        -:  634:                            parser_stack_iterator_t *iterator) /**< iterator */
        -:  635:{
        5:  636:  iterator->current_p = context_p->stack.first_p;
        5:  637:  iterator->current_position = context_p->stack.last_position;
        5:  638:} /* parser_stack_iterator_init */
        -:  639:
        -:  640:/**
        -:  641: * Read the next byte from the stack.
        -:  642: *
        -:  643: * @return byte
        -:  644: */
        -:  645:extern inline uint8_t
    #####:  646:parser_stack_iterator_read_uint8 (parser_stack_iterator_t *iterator) /**< iterator */
        -:  647:{
    #####:  648:  JERRY_ASSERT (iterator->current_position > 0 && iterator->current_position <= PARSER_STACK_PAGE_SIZE);
    #####:  649:  return iterator->current_p->bytes[iterator->current_position - 1];
        -:  650:} /* parser_stack_iterator_read_uint8 */
        -:  651:
        -:  652:/**
        -:  653: * Skip the next n bytes of the stack.
        -:  654: */
        -:  655:void
    #####:  656:parser_stack_iterator_skip (parser_stack_iterator_t *iterator, /**< iterator */
        -:  657:                            size_t length) /**< number of skipped bytes */
        -:  658:{
    #####:  659:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  660:
    #####:  661:  if (length < iterator->current_position)
        -:  662:  {
    #####:  663:    iterator->current_position -= length;
        -:  664:  }
        -:  665:  else
        -:  666:  {
    #####:  667:    iterator->current_position = PARSER_STACK_PAGE_SIZE - (length - iterator->current_position);
    #####:  668:    iterator->current_p = iterator->current_p->next_p;
        -:  669:  }
    #####:  670:} /* parser_stack_iterator_skip */
        -:  671:
        -:  672:/**
        -:  673: * Read bytes from the stack.
        -:  674: */
        -:  675:void
    #####:  676:parser_stack_iterator_read (parser_stack_iterator_t *iterator, /**< iterator */
        -:  677:                            void *data_p, /**< destination buffer */
        -:  678:                            size_t length) /**< length of the data */
        -:  679:{
    #####:  680:  uint8_t *bytes_p = (uint8_t *) data_p;
        -:  681:
    #####:  682:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  683:
    #####:  684:  if (length <= iterator->current_position)
        -:  685:  {
    #####:  686:    memcpy (bytes_p, iterator->current_p->bytes + iterator->current_position - length, length);
        -:  687:  }
        -:  688:  else
        -:  689:  {
    #####:  690:    JERRY_ASSERT (iterator->current_p->next_p != NULL);
        -:  691:
    #####:  692:    length -= iterator->current_position;
    #####:  693:    memcpy (bytes_p + length, iterator->current_p->bytes, iterator->current_position);
    #####:  694:    memcpy (bytes_p, iterator->current_p->next_p->bytes + PARSER_STACK_PAGE_SIZE - length, length);
        -:  695:  }
    #####:  696:} /* parser_stack_iterator_read */
        -:  697:
        -:  698:/**
        -:  699: * Write bytes onto the stack.
        -:  700: */
        -:  701:void
    #####:  702:parser_stack_iterator_write (parser_stack_iterator_t *iterator, /**< iterator */
        -:  703:                             const void *data_p, /**< destination buffer */
        -:  704:                             size_t length) /**< length of the data */
        -:  705:{
    #####:  706:  const uint8_t *bytes_p = (const uint8_t *) data_p;
        -:  707:
    #####:  708:  JERRY_ASSERT (length < PARSER_STACK_PAGE_SIZE && length > 0);
        -:  709:
    #####:  710:  if (length <= iterator->current_position)
        -:  711:  {
    #####:  712:    memcpy (iterator->current_p->bytes + iterator->current_position - length, bytes_p, length);
        -:  713:  }
        -:  714:  else
        -:  715:  {
    #####:  716:    JERRY_ASSERT (iterator->current_p->next_p != NULL);
        -:  717:
    #####:  718:    length -= iterator->current_position;
    #####:  719:    memcpy (iterator->current_p->bytes, bytes_p + length, iterator->current_position);
    #####:  720:    memcpy (iterator->current_p->next_p->bytes + PARSER_STACK_PAGE_SIZE - length, bytes_p, length);
        -:  721:  }
    #####:  722:} /* parser_stack_iterator_write */
        -:  723:
        -:  724:/**
        -:  725: * @}
        -:  726: * @}
        -:  727: */
        -:  728:
        -:  729:#endif /* JERRY_PARSER */
