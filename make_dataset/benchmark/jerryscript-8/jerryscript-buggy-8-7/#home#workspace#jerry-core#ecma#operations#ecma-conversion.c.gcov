        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-conversion.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:/**
        -:   17: * Implementation of ECMA-defined conversion routines
        -:   18: */
        -:   19:
        -:   20:#include "ecma-conversion.h"
        -:   21:
        -:   22:#include <math.h>
        -:   23:
        -:   24:#include "ecma-alloc.h"
        -:   25:#include "ecma-bigint-object.h"
        -:   26:#include "ecma-bigint.h"
        -:   27:#include "ecma-boolean-object.h"
        -:   28:#include "ecma-exceptions.h"
        -:   29:#include "ecma-function-object.h"
        -:   30:#include "ecma-gc.h"
        -:   31:#include "ecma-globals.h"
        -:   32:#include "ecma-helpers-number.h"
        -:   33:#include "ecma-helpers.h"
        -:   34:#include "ecma-number-object.h"
        -:   35:#include "ecma-objects-general.h"
        -:   36:#include "ecma-objects.h"
        -:   37:#include "ecma-string-object.h"
        -:   38:#include "ecma-symbol-object.h"
        -:   39:
        -:   40:#include "jrt-libc-includes.h"
        -:   41:
        -:   42:/** \addtogroup ecma ECMA
        -:   43: * @{
        -:   44: *
        -:   45: * \addtogroup ecmaconversion ECMA conversion routines
        -:   46: * @{
        -:   47: */
        -:   48:
        -:   49:/**
        -:   50: * RequireObjectCoercible operation.
        -:   51: *
        -:   52: * See also:
        -:   53: *          ECMA-262 v11, 7.2.1
        -:   54: *
        -:   55: * @return true - if the value can be coerced to object without any exceptions
        -:   56: *         false - otherwise
        -:   57: */
        -:   58:bool
    #####:   59:ecma_op_require_object_coercible (ecma_value_t value) /**< ecma value */
        -:   60:{
    #####:   61:  ecma_check_value_type_is_spec_defined (value);
        -:   62:
    #####:   63:  if (ecma_is_value_undefined (value) || ecma_is_value_null (value))
        -:   64:  {
    #####:   65:    ecma_raise_type_error (ECMA_ERR_ARGUMENT_CANNOT_CONVERT_TO_OBJECT);
    #####:   66:    return false;
        -:   67:  }
        -:   68:
    #####:   69:  return true;
        -:   70:} /* ecma_op_require_object_coercible */
        -:   71:
        -:   72:/**
        -:   73: * SameValue operation.
        -:   74: *
        -:   75: * See also:
        -:   76: *          ECMA-262 v5, 9.12
        -:   77: *
        -:   78: * @return true - if the value are same according to ECMA-defined SameValue algorithm,
        -:   79: *         false - otherwise
        -:   80: */
        -:   81:bool
    #####:   82:ecma_op_same_value (ecma_value_t x, /**< ecma value */
        -:   83:                    ecma_value_t y) /**< ecma value */
        -:   84:{
    #####:   85:  if (x == y)
        -:   86:  {
    #####:   87:    return true;
        -:   88:  }
        -:   89:
    #####:   90:  ecma_type_t type_of_x = ecma_get_value_type_field (x);
        -:   91:
    #####:   92:  if (type_of_x != ecma_get_value_type_field (y) || type_of_x == ECMA_TYPE_DIRECT)
        -:   93:  {
    #####:   94:    return false;
        -:   95:  }
        -:   96:
    #####:   97:  if (ecma_is_value_number (x))
        -:   98:  {
    #####:   99:    ecma_number_t x_num = ecma_get_number_from_value (x);
    #####:  100:    ecma_number_t y_num = ecma_get_number_from_value (y);
        -:  101:
    #####:  102:    bool is_x_nan = ecma_number_is_nan (x_num);
    #####:  103:    bool is_y_nan = ecma_number_is_nan (y_num);
        -:  104:
    #####:  105:    if (is_x_nan || is_y_nan)
        -:  106:    {
    #####:  107:      return is_x_nan && is_y_nan;
        -:  108:    }
        -:  109:
    #####:  110:    if (ecma_number_is_zero (x_num) && ecma_number_is_zero (y_num)
    #####:  111:        && ecma_number_is_negative (x_num) != ecma_number_is_negative (y_num))
        -:  112:    {
    #####:  113:      return false;
        -:  114:    }
        -:  115:
    #####:  116:    return (x_num == y_num);
        -:  117:  }
        -:  118:
    #####:  119:  if (ecma_is_value_string (x))
        -:  120:  {
    #####:  121:    ecma_string_t *x_str_p = ecma_get_string_from_value (x);
    #####:  122:    ecma_string_t *y_str_p = ecma_get_string_from_value (y);
        -:  123:
    #####:  124:    return ecma_compare_ecma_strings (x_str_p, y_str_p);
        -:  125:  }
        -:  126:
        -:  127:#if JERRY_BUILTIN_BIGINT
    #####:  128:  if (ecma_is_value_bigint (x))
        -:  129:  {
    #####:  130:    return (ecma_is_value_bigint (y) && ecma_bigint_compare_to_bigint (x, y) == 0);
        -:  131:  }
        -:  132:#endif /* JERRY_BUILTIN_BIGINT */
        -:  133:
    #####:  134:  JERRY_ASSERT (ecma_is_value_object (x) || ecma_is_value_symbol (x));
        -:  135:
    #####:  136:  return false;
        -:  137:} /* ecma_op_same_value */
        -:  138:
        -:  139:#if JERRY_BUILTIN_CONTAINER
        -:  140:/**
        -:  141: * SameValueZero operation.
        -:  142: *
        -:  143: * See also:
        -:  144: *          ECMA-262 v6, 7.2.10
        -:  145: *
        -:  146: * @return true - if the value are same according to ECMA-defined SameValueZero algorithm,
        -:  147: *         false - otherwise
        -:  148: */
        -:  149:bool
    #####:  150:ecma_op_same_value_zero (ecma_value_t x, /**< ecma value */
        -:  151:                         ecma_value_t y, /**< ecma value */
        -:  152:                         bool strict_equality) /**< strict equality */
        -:  153:{
    #####:  154:  if (ecma_is_value_number (x) && ecma_is_value_number (y))
        -:  155:  {
    #####:  156:    ecma_number_t x_num = ecma_get_number_from_value (x);
    #####:  157:    ecma_number_t y_num = ecma_get_number_from_value (y);
        -:  158:
    #####:  159:    bool is_x_nan = ecma_number_is_nan (x_num);
    #####:  160:    bool is_y_nan = ecma_number_is_nan (y_num);
        -:  161:
    #####:  162:    if (strict_equality && is_x_nan && is_y_nan)
        -:  163:    {
    #####:  164:      return false;
        -:  165:    }
        -:  166:
    #####:  167:    if (is_x_nan || is_y_nan)
        -:  168:    {
    #####:  169:      return (is_x_nan && is_y_nan);
        -:  170:    }
        -:  171:
    #####:  172:    if (ecma_number_is_zero (x_num) && ecma_number_is_zero (y_num)
    #####:  173:        && ecma_number_is_negative (x_num) != ecma_number_is_negative (y_num))
        -:  174:    {
    #####:  175:      return true;
        -:  176:    }
        -:  177:
    #####:  178:    return (x_num == y_num);
        -:  179:  }
        -:  180:
    #####:  181:  return ecma_op_same_value (x, y);
        -:  182:} /* ecma_op_same_value_zero */
        -:  183:#endif /* JERRY_BUILTIN_CONTAINER */
        -:  184:
        -:  185:/**
        -:  186: * ToPrimitive operation.
        -:  187: *
        -:  188: * See also:
        -:  189: *          ECMA-262 v5, 9.1
        -:  190: *
        -:  191: * @return ecma value
        -:  192: *         Returned value must be freed with ecma_free_value
        -:  193: */
        -:  194:ecma_value_t
    #####:  195:ecma_op_to_primitive (ecma_value_t value, /**< ecma value */
        -:  196:                      ecma_preferred_type_hint_t preferred_type) /**< preferred type hint */
        -:  197:{
    #####:  198:  ecma_check_value_type_is_spec_defined (value);
        -:  199:
    #####:  200:  if (ecma_is_value_object (value))
        -:  201:  {
    #####:  202:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -:  203:
    #####:  204:    return ecma_op_object_default_value (obj_p, preferred_type);
        -:  205:  }
        -:  206:  else
        -:  207:  {
    #####:  208:    return ecma_copy_value (value);
        -:  209:  }
        -:  210:} /* ecma_op_to_primitive */
        -:  211:
        -:  212:/**
        -:  213: * ToBoolean operation. Cannot throw an exception.
        -:  214: *
        -:  215: * See also:
        -:  216: *          ECMA-262 v5, 9.2
        -:  217: *
        -:  218: * @return true - if the logical value is true
        -:  219: *         false - otherwise
        -:  220: */
        -:  221:bool
        1:  222:ecma_op_to_boolean (ecma_value_t value) /**< ecma value */
        -:  223:{
        1:  224:  ecma_check_value_type_is_spec_defined (value);
        -:  225:
        1:  226:  if (ecma_is_value_simple (value))
        -:  227:  {
    #####:  228:    JERRY_ASSERT (ecma_is_value_boolean (value) || ecma_is_value_undefined (value) || ecma_is_value_null (value));
        -:  229:
    #####:  230:    return ecma_is_value_true (value);
        -:  231:  }
        -:  232:
        1:  233:  if (ecma_is_value_integer_number (value))
        -:  234:  {
    #####:  235:    return (value != ecma_make_integer_value (0));
        -:  236:  }
        -:  237:
        1:  238:  if (ecma_is_value_float_number (value))
        -:  239:  {
    #####:  240:    ecma_number_t num = ecma_get_float_from_value (value);
        -:  241:
    #####:  242:    return (!ecma_number_is_nan (num) && !ecma_number_is_zero (num));
        -:  243:  }
        -:  244:
        1:  245:  if (ecma_is_value_string (value))
        -:  246:  {
    #####:  247:    ecma_string_t *str_p = ecma_get_string_from_value (value);
        -:  248:
    #####:  249:    return !ecma_string_is_empty (str_p);
        -:  250:  }
        -:  251:
        -:  252:#if JERRY_BUILTIN_BIGINT
        1:  253:  if (ecma_is_value_bigint (value))
        -:  254:  {
    #####:  255:    return value != ECMA_BIGINT_ZERO;
        -:  256:  }
        -:  257:#endif /* JERRY_BUILTIN_BIGINT */
        -:  258:
        1:  259:  JERRY_ASSERT (ecma_is_value_object (value) || ecma_is_value_symbol (value));
        -:  260:
        1:  261:  return true;
        -:  262:} /* ecma_op_to_boolean */
        -:  263:
        -:  264:/**
        -:  265: * ToNumber operation.
        -:  266: *
        -:  267: * See also:
        -:  268: *          ECMA-262 v5, 9.3
        -:  269: *
        -:  270: * @return ecma value
        -:  271: *         Returned value must be freed with ecma_free_value
        -:  272: */
        -:  273:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  274:ecma_op_to_number (ecma_value_t value, /**< ecma value */
        -:  275:                   ecma_number_t *number_p) /**< [out] ecma number */
        -:  276:{
    #####:  277:  return ecma_op_to_numeric (value, number_p, ECMA_TO_NUMERIC_NO_OPTS);
        -:  278:} /* ecma_op_to_number */
        -:  279:
        -:  280:/**
        -:  281: * Helper to get the numeric value of an ecma value
        -:  282: *
        -:  283: * See also:
        -:  284: *          ECMA-262 v11, 7.1.3
        -:  285: *
        -:  286: * @return ECMA_VALUE_EMPTY if converted to number, BigInt if
        -:  287: *         converted to BigInt, and conversion error otherwise
        -:  288: *         Returned value must be freed with ecma_free_value
        -:  289: */
        -:  290:ecma_value_t
    #####:  291:ecma_op_to_numeric (ecma_value_t value, /**< ecma value */
        -:  292:                    ecma_number_t *number_p, /**< [out] ecma number */
        -:  293:                    ecma_to_numeric_options_t options) /**< option bits */
        -:  294:{
        -:  295:  JERRY_UNUSED (options);
        -:  296:
    #####:  297:  if (ecma_is_value_integer_number (value))
        -:  298:  {
    #####:  299:    *number_p = (ecma_number_t) ecma_get_integer_from_value (value);
    #####:  300:    return ECMA_VALUE_EMPTY;
        -:  301:  }
        -:  302:
    #####:  303:  if (ecma_is_value_float_number (value))
        -:  304:  {
    #####:  305:    *number_p = ecma_get_float_from_value (value);
    #####:  306:    return ECMA_VALUE_EMPTY;
        -:  307:  }
        -:  308:
    #####:  309:  if (ecma_is_value_string (value))
        -:  310:  {
    #####:  311:    ecma_string_t *str_p = ecma_get_string_from_value (value);
    #####:  312:    *number_p = ecma_string_to_number (str_p);
    #####:  313:    return ECMA_VALUE_EMPTY;
        -:  314:  }
        -:  315:
    #####:  316:  if (ecma_is_value_undefined (value))
        -:  317:  {
    #####:  318:    *number_p = ecma_number_make_nan ();
    #####:  319:    return ECMA_VALUE_EMPTY;
        -:  320:  }
        -:  321:
    #####:  322:  if (ecma_is_value_null (value))
        -:  323:  {
    #####:  324:    *number_p = 0;
    #####:  325:    return ECMA_VALUE_EMPTY;
        -:  326:  }
        -:  327:
    #####:  328:  if (ecma_is_value_true (value))
        -:  329:  {
    #####:  330:    *number_p = 1;
    #####:  331:    return ECMA_VALUE_EMPTY;
        -:  332:  }
        -:  333:
    #####:  334:  if (ecma_is_value_false (value))
        -:  335:  {
    #####:  336:    *number_p = 0;
    #####:  337:    return ECMA_VALUE_EMPTY;
        -:  338:  }
        -:  339:
        -:  340:#if JERRY_ESNEXT
    #####:  341:  if (ecma_is_value_symbol (value))
        -:  342:  {
    #####:  343:    return ecma_raise_type_error (ECMA_ERR_CONVERT_SYMBOL_TO_NUMBER);
        -:  344:  }
        -:  345:#endif /* JERRY_ESNEXT */
        -:  346:
        -:  347:#if JERRY_BUILTIN_BIGINT
    #####:  348:  if (ecma_is_value_bigint (value))
        -:  349:  {
    #####:  350:    if (options & ECMA_TO_NUMERIC_ALLOW_BIGINT)
        -:  351:    {
    #####:  352:      return ecma_copy_value (value);
        -:  353:    }
    #####:  354:    return ecma_raise_type_error (ECMA_ERR_CONVERT_BIGINT_TO_NUMBER);
        -:  355:  }
        -:  356:#endif /* JERRY_BUILTIN_BIGINT */
        -:  357:
    #####:  358:  JERRY_ASSERT (ecma_is_value_object (value));
        -:  359:
    #####:  360:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -:  361:
    #####:  362:  ecma_value_t def_value = ecma_op_object_default_value (object_p, ECMA_PREFERRED_TYPE_NUMBER);
        -:  363:
    #####:  364:  if (ECMA_IS_VALUE_ERROR (def_value))
        -:  365:  {
    #####:  366:    return def_value;
        -:  367:  }
        -:  368:
    #####:  369:  ecma_value_t ret_value = ecma_op_to_numeric (def_value, number_p, options);
        -:  370:
    #####:  371:  ecma_fast_free_value (def_value);
        -:  372:
    #####:  373:  return ret_value;
        -:  374:} /* ecma_op_to_numeric */
        -:  375:
        -:  376:/**
        -:  377: * ToString operation.
        -:  378: *
        -:  379: * See also:
        -:  380: *          ECMA-262 v5, 9.8
        -:  381: *
        -:  382: * @return NULL - if the conversion fails
        -:  383: *         pointer to the string descriptor - otherwise
        -:  384: */
        -:  385:ecma_string_t *
    #####:  386:ecma_op_to_string (ecma_value_t value) /**< ecma value */
        -:  387:{
    #####:  388:  ecma_check_value_type_is_spec_defined (value);
        -:  389:
    #####:  390:  if (ecma_is_value_string (value))
        -:  391:  {
    #####:  392:    ecma_string_t *res_p = ecma_get_string_from_value (value);
    #####:  393:    ecma_ref_ecma_string (res_p);
    #####:  394:    return res_p;
        -:  395:  }
        -:  396:
    #####:  397:  if (ecma_is_value_integer_number (value))
        -:  398:  {
    #####:  399:    ecma_integer_value_t num = ecma_get_integer_from_value (value);
        -:  400:
    #####:  401:    if (num < 0)
        -:  402:    {
    #####:  403:      return ecma_new_ecma_string_from_number ((ecma_number_t) num);
        -:  404:    }
        -:  405:    else
        -:  406:    {
    #####:  407:      return ecma_new_ecma_string_from_uint32 ((uint32_t) num);
        -:  408:    }
        -:  409:  }
        -:  410:
    #####:  411:  if (ecma_is_value_float_number (value))
        -:  412:  {
    #####:  413:    ecma_number_t num = ecma_get_float_from_value (value);
    #####:  414:    return ecma_new_ecma_string_from_number (num);
        -:  415:  }
        -:  416:
    #####:  417:  if (ecma_is_value_undefined (value))
        -:  418:  {
    #####:  419:    return ecma_get_magic_string (LIT_MAGIC_STRING_UNDEFINED);
        -:  420:  }
        -:  421:
    #####:  422:  if (ecma_is_value_null (value))
        -:  423:  {
    #####:  424:    return ecma_get_magic_string (LIT_MAGIC_STRING_NULL);
        -:  425:  }
        -:  426:
    #####:  427:  if (ecma_is_value_true (value))
        -:  428:  {
    #####:  429:    return ecma_get_magic_string (LIT_MAGIC_STRING_TRUE);
        -:  430:  }
        -:  431:
    #####:  432:  if (ecma_is_value_false (value))
        -:  433:  {
    #####:  434:    return ecma_get_magic_string (LIT_MAGIC_STRING_FALSE);
        -:  435:  }
        -:  436:
        -:  437:#if JERRY_ESNEXT
    #####:  438:  if (ecma_is_value_symbol (value))
        -:  439:  {
    #####:  440:    ecma_raise_type_error (ECMA_ERR_CONVERT_SYMBOL_TO_STRING);
    #####:  441:    return NULL;
        -:  442:  }
        -:  443:#endif /* JERRY_ESNEXT */
        -:  444:
        -:  445:#if JERRY_BUILTIN_BIGINT
    #####:  446:  if (ecma_is_value_bigint (value))
        -:  447:  {
    #####:  448:    return ecma_bigint_to_string (value, 10);
        -:  449:  }
        -:  450:#endif /* JERRY_BUILTIN_BIGINT */
        -:  451:
    #####:  452:  JERRY_ASSERT (ecma_is_value_object (value));
        -:  453:
    #####:  454:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -:  455:
    #####:  456:  ecma_value_t def_value = ecma_op_object_default_value (obj_p, ECMA_PREFERRED_TYPE_STRING);
        -:  457:
    #####:  458:  if (ECMA_IS_VALUE_ERROR (def_value))
        -:  459:  {
    #####:  460:    return NULL;
        -:  461:  }
        -:  462:
    #####:  463:  ecma_string_t *ret_string_p = ecma_op_to_string (def_value);
        -:  464:
    #####:  465:  ecma_free_value (def_value);
        -:  466:
    #####:  467:  return ret_string_p;
        -:  468:} /* ecma_op_to_string */
        -:  469:
        -:  470:/**
        -:  471: * ToPropertyKey operation.
        -:  472: *
        -:  473: * See also:
        -:  474: *   ECMA 262 v6, 7.1.14
        -:  475: *   ECMA 262 v10, 7.1.14
        -:  476: *   ECMA 262 v11, 7.1.19
        -:  477: *
        -:  478: * @return NULL - if the conversion fails
        -:  479: *         ecma-string - otherwise
        -:  480: */
        -:  481:ecma_string_t *
        2:  482:ecma_op_to_property_key (ecma_value_t value) /**< ecma value */
        -:  483:{
        -:  484:  /* Fast path for strings and symbols */
        2:  485:  if (JERRY_LIKELY (ecma_is_value_prop_name (value)))
        -:  486:  {
        2:  487:    ecma_string_t *key_p = ecma_get_prop_name_from_value (value);
        2:  488:    ecma_ref_ecma_string (key_p);
        2:  489:    return key_p;
        -:  490:  }
        -:  491:
        -:  492:#if JERRY_ESNEXT
    #####:  493:  ecma_value_t key = ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_STRING);
        -:  494:
    #####:  495:  if (ECMA_IS_VALUE_ERROR (key))
        -:  496:  {
    #####:  497:    return NULL;
        -:  498:  }
        -:  499:
    #####:  500:  if (ecma_is_value_symbol (key))
        -:  501:  {
    #####:  502:    ecma_string_t *symbol_p = ecma_get_symbol_from_value (key);
    #####:  503:    return symbol_p;
        -:  504:  }
        -:  505:
    #####:  506:  ecma_string_t *result = ecma_op_to_string (key);
    #####:  507:  ecma_free_value (key);
        -:  508:
    #####:  509:  return result;
        -:  510:#else /* !JERRY_ESNEXT */
    #####:  511:  ecma_check_value_type_is_spec_defined (value);
        -:  512:
    #####:  513:  return ecma_op_to_string (value);
        -:  514:#endif /* JERRY_ESNEXT */
        -:  515:} /* ecma_op_to_property_key */
        -:  516:
        -:  517:/**
        -:  518: * ToObject operation.
        -:  519: *
        -:  520: * See also:
        -:  521: *          ECMA-262 v5, 9.9
        -:  522: *
        -:  523: * @return ecma value
        -:  524: *         Returned value must be freed with ecma_free_value
        -:  525: */
        -:  526:ecma_value_t
    #####:  527:ecma_op_to_object (ecma_value_t value) /**< ecma value */
        -:  528:{
    #####:  529:  ecma_check_value_type_is_spec_defined (value);
    #####:  530:  ecma_builtin_id_t proto_id = ECMA_BUILTIN_ID_OBJECT_PROTOTYPE;
        -:  531:  uint8_t class_type;
        -:  532:
    #####:  533:  if (ecma_is_value_number (value))
        -:  534:  {
        -:  535:#if JERRY_BUILTIN_NUMBER
    #####:  536:    proto_id = ECMA_BUILTIN_ID_NUMBER_PROTOTYPE;
        -:  537:#endif /* JERRY_BUILTIN_NUMBER */
    #####:  538:    class_type = ECMA_OBJECT_CLASS_NUMBER;
        -:  539:  }
    #####:  540:  else if (ecma_is_value_string (value))
        -:  541:  {
        -:  542:#if JERRY_BUILTIN_STRING
    #####:  543:    proto_id = ECMA_BUILTIN_ID_STRING_PROTOTYPE;
        -:  544:#endif /* JERRY_BUILTIN_STRING */
    #####:  545:    class_type = ECMA_OBJECT_CLASS_STRING;
        -:  546:  }
    #####:  547:  else if (ecma_is_value_object (value))
        -:  548:  {
    #####:  549:    return ecma_copy_value (value);
        -:  550:  }
        -:  551:#if JERRY_ESNEXT
    #####:  552:  else if (ecma_is_value_symbol (value))
        -:  553:  {
    #####:  554:    proto_id = ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE;
    #####:  555:    class_type = ECMA_OBJECT_CLASS_SYMBOL;
        -:  556:  }
        -:  557:#endif /* JERRY_ESNEXT */
        -:  558:#if JERRY_BUILTIN_BIGINT
    #####:  559:  else if (ecma_is_value_bigint (value))
        -:  560:  {
    #####:  561:    return ecma_op_create_bigint_object (value);
        -:  562:  }
        -:  563:#endif /* JERRY_BUILTIN_BIGINT */
        -:  564:  else
        -:  565:  {
    #####:  566:    if (ecma_is_value_undefined (value) || ecma_is_value_null (value))
        -:  567:    {
    #####:  568:      return ecma_raise_type_error (ECMA_ERR_ARGUMENT_CANNOT_CONVERT_TO_OBJECT);
        -:  569:    }
        -:  570:    else
        -:  571:    {
    #####:  572:      JERRY_ASSERT (ecma_is_value_boolean (value));
        -:  573:#if JERRY_BUILTIN_BOOLEAN
    #####:  574:      proto_id = ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE;
        -:  575:#endif /* JERRY_BUILTIN_BOOLEAN */
    #####:  576:      class_type = ECMA_OBJECT_CLASS_BOOLEAN;
        -:  577:    }
        -:  578:  }
        -:  579:
    #####:  580:  ecma_object_t *object_p =
    #####:  581:    ecma_create_object (ecma_builtin_get (proto_id), sizeof (ecma_extended_object_t), ECMA_OBJECT_TYPE_CLASS);
        -:  582:
    #####:  583:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  584:  ext_object_p->u.cls.type = class_type;
    #####:  585:  ext_object_p->u.cls.u3.value = ecma_copy_value_if_not_object (value);
        -:  586:
    #####:  587:  return ecma_make_object_value (object_p);
        -:  588:} /* ecma_op_to_object */
        -:  589:
        -:  590:/**
        -:  591: * FromPropertyDescriptor operation.
        -:  592: *
        -:  593: * See also:
        -:  594: *          ECMA-262 v5, 8.10.4
        -:  595: *
        -:  596: * @return constructed object
        -:  597: */
        -:  598:ecma_object_t *
    #####:  599:ecma_op_from_property_descriptor (const ecma_property_descriptor_t *src_prop_desc_p) /**< property descriptor */
        -:  600:{
        -:  601:  /* 2. */
    #####:  602:  ecma_object_t *obj_p = ecma_op_create_object_object_noarg ();
        -:  603:
        -:  604:  ecma_value_t completion;
    #####:  605:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -:  606:  {
    #####:  607:    prop_desc.flags = (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED | JERRY_PROP_IS_WRITABLE
        -:  608:                       | JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_ENUMERABLE
        -:  609:                       | JERRY_PROP_IS_CONFIGURABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE);
        -:  610:  }
        -:  611:
        -:  612:  /* 3. */
    #####:  613:  if (src_prop_desc_p->flags & (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED))
        -:  614:  {
    #####:  615:    JERRY_ASSERT ((prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED))
        -:  616:                  == (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED));
        -:  617:
        -:  618:    /* a. */
    #####:  619:    prop_desc.value = src_prop_desc_p->value;
        -:  620:
    #####:  621:    completion = ecma_op_object_define_own_property (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_VALUE), &prop_desc);
    #####:  622:    JERRY_ASSERT (ecma_is_value_true (completion));
        -:  623:
        -:  624:    /* b. */
    #####:  625:    prop_desc.value = ecma_make_boolean_value (src_prop_desc_p->flags & JERRY_PROP_IS_WRITABLE);
        -:  626:
    #####:  627:    completion =
    #####:  628:      ecma_op_object_define_own_property (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_WRITABLE), &prop_desc);
    #####:  629:    JERRY_ASSERT (ecma_is_value_true (completion));
        -:  630:  }
        -:  631:  else
        -:  632:  {
        -:  633:#if !JERRY_ESNEXT
        -:  634:    JERRY_ASSERT (src_prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED));
        -:  635:#else /* JERRY_ESNEXT */
    #####:  636:    if (src_prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -:  637:#endif /* JERRY_ESNEXT */
        -:  638:    {
        -:  639:      /* a. */
    #####:  640:      if (src_prop_desc_p->get_p == NULL)
        -:  641:      {
    #####:  642:        prop_desc.value = ECMA_VALUE_UNDEFINED;
        -:  643:      }
        -:  644:      else
        -:  645:      {
    #####:  646:        prop_desc.value = ecma_make_object_value (src_prop_desc_p->get_p);
        -:  647:      }
        -:  648:
    #####:  649:      completion = ecma_op_object_define_own_property (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_GET), &prop_desc);
    #####:  650:      JERRY_ASSERT (ecma_is_value_true (completion));
        -:  651:
        -:  652:      /* b. */
    #####:  653:      if (src_prop_desc_p->set_p == NULL)
        -:  654:      {
    #####:  655:        prop_desc.value = ECMA_VALUE_UNDEFINED;
        -:  656:      }
        -:  657:      else
        -:  658:      {
    #####:  659:        prop_desc.value = ecma_make_object_value (src_prop_desc_p->set_p);
        -:  660:      }
        -:  661:
    #####:  662:      completion = ecma_op_object_define_own_property (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_SET), &prop_desc);
    #####:  663:      JERRY_ASSERT (ecma_is_value_true (completion));
        -:  664:    }
        -:  665:  }
        -:  666:
    #####:  667:  prop_desc.value = ecma_make_boolean_value (src_prop_desc_p->flags & JERRY_PROP_IS_ENUMERABLE);
        -:  668:
    #####:  669:  completion =
    #####:  670:    ecma_op_object_define_own_property (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_ENUMERABLE), &prop_desc);
    #####:  671:  JERRY_ASSERT (ecma_is_value_true (completion));
        -:  672:
    #####:  673:  prop_desc.value = ecma_make_boolean_value (src_prop_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE);
        -:  674:
    #####:  675:  completion =
    #####:  676:    ecma_op_object_define_own_property (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_CONFIGURABLE), &prop_desc);
    #####:  677:  JERRY_ASSERT (ecma_is_value_true (completion));
        -:  678:
    #####:  679:  return obj_p;
        -:  680:} /* ecma_op_from_property_descriptor */
        -:  681:
        -:  682:/**
        -:  683: * ToPropertyDescriptor operation.
        -:  684: *
        -:  685: * See also:
        -:  686: *          ECMA-262 v5, 8.10.5
        -:  687: *
        -:  688: * @return ECMA_VALUE_EMPTY if successful, ECMA_VALUE_ERROR otherwise
        -:  689: */
        -:  690:ecma_value_t
    #####:  691:ecma_op_to_property_descriptor (ecma_value_t obj_value, /**< object value */
        -:  692:                                ecma_property_descriptor_t *out_prop_desc_p) /**< [out] filled property descriptor
        -:  693:                                                                              *   if the operation is successful,
        -:  694:                                                                              *   unmodified otherwise */
        -:  695:{
        -:  696:  /* 1. */
    #####:  697:  if (!ecma_is_value_object (obj_value))
        -:  698:  {
    #####:  699:    return ecma_raise_type_error (ECMA_ERR_EXPECTED_AN_OBJECT);
        -:  700:  }
        -:  701:
    #####:  702:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
    #####:  703:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  704:
        -:  705:  /* 3. */
    #####:  706:  ecma_value_t enumerable_prop_value = ecma_op_object_find (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_ENUMERABLE));
        -:  707:
    #####:  708:  if (ECMA_IS_VALUE_ERROR (enumerable_prop_value))
        -:  709:  {
    #####:  710:    return enumerable_prop_value;
        -:  711:  }
        -:  712:
        -:  713:  /* 2. */
    #####:  714:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -:  715:
    #####:  716:  if (ecma_is_value_found (enumerable_prop_value))
        -:  717:  {
    #####:  718:    uint32_t is_enumerable =
    #####:  719:      (ecma_op_to_boolean (enumerable_prop_value) ? JERRY_PROP_IS_ENUMERABLE : JERRY_PROP_NO_OPTS);
        -:  720:
    #####:  721:    prop_desc.flags |= (uint16_t) (JERRY_PROP_IS_ENUMERABLE_DEFINED | is_enumerable);
        -:  722:
    #####:  723:    ecma_free_value (enumerable_prop_value);
        -:  724:  }
        -:  725:
        -:  726:  /* 4. */
    #####:  727:  ecma_value_t configurable_prop_value =
    #####:  728:    ecma_op_object_find (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_CONFIGURABLE));
        -:  729:
    #####:  730:  if (ECMA_IS_VALUE_ERROR (configurable_prop_value))
        -:  731:  {
    #####:  732:    goto free_desc;
        -:  733:  }
        -:  734:
    #####:  735:  if (ecma_is_value_found (configurable_prop_value))
        -:  736:  {
    #####:  737:    uint32_t is_configurable =
    #####:  738:      (ecma_op_to_boolean (configurable_prop_value) ? JERRY_PROP_IS_CONFIGURABLE : JERRY_PROP_NO_OPTS);
        -:  739:
    #####:  740:    prop_desc.flags |= (uint16_t) (JERRY_PROP_IS_CONFIGURABLE_DEFINED | is_configurable);
        -:  741:
    #####:  742:    ecma_free_value (configurable_prop_value);
        -:  743:  }
        -:  744:
        -:  745:  /* 5. */
    #####:  746:  ecma_value_t value_prop_value = ecma_op_object_find (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_VALUE));
        -:  747:
    #####:  748:  if (ECMA_IS_VALUE_ERROR (value_prop_value))
        -:  749:  {
    #####:  750:    goto free_desc;
        -:  751:  }
        -:  752:
    #####:  753:  if (ecma_is_value_found (value_prop_value))
        -:  754:  {
    #####:  755:    prop_desc.flags |= JERRY_PROP_IS_VALUE_DEFINED;
    #####:  756:    prop_desc.value = ecma_copy_value (value_prop_value);
    #####:  757:    ecma_free_value (value_prop_value);
        -:  758:  }
        -:  759:
        -:  760:  /* 6. */
    #####:  761:  ecma_value_t writable_prop_value = ecma_op_object_find (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_WRITABLE));
        -:  762:
    #####:  763:  if (ECMA_IS_VALUE_ERROR (writable_prop_value))
        -:  764:  {
    #####:  765:    goto free_desc;
        -:  766:  }
        -:  767:
    #####:  768:  if (ecma_is_value_found (writable_prop_value))
        -:  769:  {
    #####:  770:    uint32_t is_writable = (ecma_op_to_boolean (writable_prop_value) ? JERRY_PROP_IS_WRITABLE : JERRY_PROP_NO_OPTS);
        -:  771:
    #####:  772:    prop_desc.flags |= (uint16_t) (JERRY_PROP_IS_WRITABLE_DEFINED | is_writable);
        -:  773:
    #####:  774:    ecma_free_value (writable_prop_value);
        -:  775:  }
        -:  776:
        -:  777:  /* 7. */
    #####:  778:  ecma_value_t get_prop_value = ecma_op_object_find (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_GET));
        -:  779:
    #####:  780:  if (ECMA_IS_VALUE_ERROR (get_prop_value))
        -:  781:  {
    #####:  782:    goto free_desc;
        -:  783:  }
        -:  784:
    #####:  785:  if (ecma_is_value_found (get_prop_value))
        -:  786:  {
    #####:  787:    if (!ecma_op_is_callable (get_prop_value) && !ecma_is_value_undefined (get_prop_value))
        -:  788:    {
    #####:  789:      ecma_free_value (get_prop_value);
    #####:  790:      ret_value = ecma_raise_type_error (ECMA_ERR_EXPECTED_A_FUNCTION);
    #####:  791:      goto free_desc;
        -:  792:    }
        -:  793:
    #####:  794:    prop_desc.flags |= JERRY_PROP_IS_GET_DEFINED;
        -:  795:
    #####:  796:    if (ecma_is_value_undefined (get_prop_value))
        -:  797:    {
    #####:  798:      prop_desc.get_p = NULL;
        -:  799:    }
        -:  800:    else
        -:  801:    {
    #####:  802:      JERRY_ASSERT (ecma_is_value_object (get_prop_value));
        -:  803:
    #####:  804:      ecma_object_t *get_p = ecma_get_object_from_value (get_prop_value);
    #####:  805:      ecma_ref_object (get_p);
        -:  806:
    #####:  807:      prop_desc.get_p = get_p;
        -:  808:    }
        -:  809:
    #####:  810:    ecma_free_value (get_prop_value);
        -:  811:  }
        -:  812:
        -:  813:  /* 8. */
    #####:  814:  ecma_value_t set_prop_value = ecma_op_object_find (obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_SET));
        -:  815:
    #####:  816:  if (ECMA_IS_VALUE_ERROR (set_prop_value))
        -:  817:  {
    #####:  818:    goto free_desc;
        -:  819:  }
        -:  820:
    #####:  821:  if (ecma_is_value_found (set_prop_value))
        -:  822:  {
    #####:  823:    if (!ecma_op_is_callable (set_prop_value) && !ecma_is_value_undefined (set_prop_value))
        -:  824:    {
    #####:  825:      ecma_free_value (set_prop_value);
    #####:  826:      ret_value = ecma_raise_type_error (ECMA_ERR_EXPECTED_A_FUNCTION);
    #####:  827:      goto free_desc;
        -:  828:    }
        -:  829:
    #####:  830:    prop_desc.flags |= JERRY_PROP_IS_SET_DEFINED;
        -:  831:
    #####:  832:    if (ecma_is_value_undefined (set_prop_value))
        -:  833:    {
    #####:  834:      prop_desc.set_p = NULL;
        -:  835:    }
        -:  836:    else
        -:  837:    {
    #####:  838:      JERRY_ASSERT (ecma_is_value_object (set_prop_value));
        -:  839:
    #####:  840:      ecma_object_t *set_p = ecma_get_object_from_value (set_prop_value);
    #####:  841:      ecma_ref_object (set_p);
        -:  842:
    #####:  843:      prop_desc.set_p = set_p;
        -:  844:    }
        -:  845:
    #####:  846:    ecma_free_value (set_prop_value);
        -:  847:  }
        -:  848:
        -:  849:  /* 9. */
    #####:  850:  if ((prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED))
    #####:  851:      && (prop_desc.flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)))
        -:  852:  {
    #####:  853:    ret_value = ecma_raise_type_error (ECMA_ERR_ACCESSOR_WRITABLE);
        -:  854:  }
        -:  855:  else
        -:  856:  {
    #####:  857:    *out_prop_desc_p = prop_desc;
    #####:  858:    ret_value = ECMA_VALUE_EMPTY;
        -:  859:  }
        -:  860:
    #####:  861:free_desc:
    #####:  862:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  863:  {
    #####:  864:    ecma_free_property_descriptor (&prop_desc);
        -:  865:  }
        -:  866:
    #####:  867:  return ret_value;
        -:  868:} /* ecma_op_to_property_descriptor */
        -:  869:
        -:  870:/**
        -:  871: * IsInteger operation.
        -:  872: *
        -:  873: * See also:
        -:  874: *          ECMA-262 v5, 9.4
        -:  875: *          ECMA-262 v6, 7.1.4
        -:  876: *
        -:  877: * @return true - if the argument is integer
        -:  878: *              false - otherwise
        -:  879: */
        -:  880:bool
    #####:  881:ecma_op_is_integer (ecma_number_t num) /**< ecma number */
        -:  882:{
    #####:  883:  if (ecma_number_is_nan (num) || ecma_number_is_infinity (num))
        -:  884:  {
    #####:  885:    return false;
        -:  886:  }
        -:  887:
    #####:  888:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (num));
    #####:  889:  ecma_number_t fabs_value = (ecma_number_t) fabs (num);
        -:  890:
    #####:  891:  return (floor_fabs == fabs_value);
        -:  892:} /* ecma_op_is_integer */
        -:  893:
        -:  894:/**
        -:  895: * ToInteger operation.
        -:  896: *
        -:  897: * See also:
        -:  898: *          ECMA-262 v5, 9.4
        -:  899: *          ECMA-262 v6, 7.1.4
        -:  900: *
        -:  901: * @return ECMA_VALUE_EMPTY if successful
        -:  902: *         conversion error otherwise
        -:  903: */
        -:  904:ecma_value_t
    #####:  905:ecma_op_to_integer (ecma_value_t value, /**< ecma value */
        -:  906:                    ecma_number_t *number_p) /**< [out] ecma number */
        -:  907:{
    #####:  908:  if (ECMA_IS_VALUE_ERROR (value))
        -:  909:  {
    #####:  910:    return value;
        -:  911:  }
        -:  912:
        -:  913:  /* 1 */
    #####:  914:  ecma_value_t to_number = ecma_op_to_number (value, number_p);
        -:  915:
        -:  916:  /* 2 */
    #####:  917:  if (ECMA_IS_VALUE_ERROR (to_number))
        -:  918:  {
    #####:  919:    return to_number;
        -:  920:  }
        -:  921:
    #####:  922:  ecma_number_t number = *number_p;
        -:  923:
        -:  924:  /* 3 */
    #####:  925:  if (ecma_number_is_nan (number))
        -:  926:  {
    #####:  927:    *number_p = ECMA_NUMBER_ZERO;
    #####:  928:    return ECMA_VALUE_EMPTY;
        -:  929:  }
        -:  930:
        -:  931:  /* 4 */
    #####:  932:  if (ecma_number_is_zero (number) || ecma_number_is_infinity (number))
        -:  933:  {
    #####:  934:    return ECMA_VALUE_EMPTY;
        -:  935:  }
        -:  936:
    #####:  937:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number));
        -:  938:  /* 5 */
    #####:  939:  *number_p = ecma_number_is_negative (number) ? -floor_fabs : floor_fabs;
    #####:  940:  return ECMA_VALUE_EMPTY;
        -:  941:} /* ecma_op_to_integer */
        -:  942:
        -:  943:/**
        -:  944: * ToLength operation.
        -:  945: *
        -:  946: * See also:
        -:  947: *          ECMA-262 v6, 7.1.15
        -:  948: *
        -:  949: * @return ECMA_VALUE_EMPTY if successful
        -:  950: *         conversion error otherwise
        -:  951: */
        -:  952:ecma_value_t
    #####:  953:ecma_op_to_length (ecma_value_t value, /**< ecma value */
        -:  954:                   ecma_length_t *length) /**< [out] ecma number */
        -:  955:{
        -:  956:  /* 1 */
    #####:  957:  if (ECMA_IS_VALUE_ERROR (value))
        -:  958:  {
    #####:  959:    return value;
        -:  960:  }
        -:  961:
        -:  962:#if JERRY_ESNEXT
        -:  963:  /* 2 */
    #####:  964:  ecma_number_t num;
    #####:  965:  ecma_value_t length_num = ecma_op_to_integer (value, &num);
        -:  966:
        -:  967:  /* 3 */
    #####:  968:  if (ECMA_IS_VALUE_ERROR (length_num))
        -:  969:  {
    #####:  970:    return length_num;
        -:  971:  }
        -:  972:
        -:  973:  /* 4 */
    #####:  974:  if (num <= 0.0f)
        -:  975:  {
    #####:  976:    *length = 0;
    #####:  977:    return ECMA_VALUE_EMPTY;
        -:  978:  }
        -:  979:
        -:  980:  /* 5 */
    #####:  981:  if (num >= ECMA_NUMBER_MAX_SAFE_INTEGER)
        -:  982:  {
    #####:  983:    *length = (ecma_length_t) ECMA_NUMBER_MAX_SAFE_INTEGER;
    #####:  984:    return ECMA_VALUE_EMPTY;
        -:  985:  }
        -:  986:
        -:  987:  /* 6 */
    #####:  988:  *length = (ecma_length_t) num;
    #####:  989:  return ECMA_VALUE_EMPTY;
        -:  990:#else /* !JERRY_ESNEXT */
        -:  991:  /* In the case of ES5, ToLength(ES6) operation is the same as ToUint32(ES5) */
        -:  992:  ecma_number_t num;
    #####:  993:  ecma_value_t to_number = ecma_op_to_number (value, &num);
        -:  994:
        -:  995:  /* 2 */
    #####:  996:  if (ECMA_IS_VALUE_ERROR (to_number))
        -:  997:  {
        -:  998:    return to_number;
        -:  999:  }
        -: 1000:
    #####: 1001:  *length = ecma_number_to_uint32 (num);
    #####: 1002:  return ECMA_VALUE_EMPTY;
        -: 1003:#endif /* JERRY_ESNEXT */
        -: 1004:} /* ecma_op_to_length */
        -: 1005:
        -: 1006:#if JERRY_ESNEXT
        -: 1007:/**
        -: 1008: * ToIndex operation.
        -: 1009: *
        -: 1010: * See also:
        -: 1011: *          ECMA-262 v11, 7.1.22
        -: 1012: *
        -: 1013: * @return ECMA_VALUE_EMPTY if successful
        -: 1014: *         conversion error otherwise
        -: 1015: */
        -: 1016:ecma_value_t
    #####: 1017:ecma_op_to_index (ecma_value_t value, /**< ecma value */
        -: 1018:                  ecma_number_t *index) /**< [out] ecma number */
        -: 1019:{
        -: 1020:  /* 1. */
    #####: 1021:  if (ecma_is_value_undefined (value))
        -: 1022:  {
    #####: 1023:    *index = 0;
    #####: 1024:    return ECMA_VALUE_EMPTY;
        -: 1025:  }
        -: 1026:
        -: 1027:  /* 2.a */
    #####: 1028:  ecma_number_t integer_index;
    #####: 1029:  ecma_value_t index_value = ecma_op_to_integer (value, &integer_index);
        -: 1030:
    #####: 1031:  if (ECMA_IS_VALUE_ERROR (index_value))
        -: 1032:  {
    #####: 1033:    return index_value;
        -: 1034:  }
        -: 1035:
        -: 1036:  /* 2.b - 2.d */
    #####: 1037:  if (integer_index < 0.0f || integer_index > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1038:  {
    #####: 1039:    return ecma_raise_range_error (ECMA_ERR_INVALID_OR_OUT_OF_RANGE_INDEX);
        -: 1040:  }
        -: 1041:
        -: 1042:  /* 3. */
    #####: 1043:  *index = integer_index;
    #####: 1044:  return ECMA_VALUE_EMPTY;
        -: 1045:} /* ecma_op_to_index */
        -: 1046:
        -: 1047:/**
        -: 1048: * CreateListFromArrayLike operation.
        -: 1049: * Different types are not handled yet.
        -: 1050: *
        -: 1051: * See also:
        -: 1052: *          ECMA-262 v6, 7.3.17
        -: 1053: *
        -: 1054: * @return ecma_collection_t if successful
        -: 1055: *         NULL otherwise
        -: 1056: */
        -: 1057:ecma_collection_t *
    #####: 1058:ecma_op_create_list_from_array_like (ecma_value_t arr, /**< array value */
        -: 1059:                                     bool prop_names_only) /**< true - accept only property names
        -: 1060:                                                                false - otherwise */
        -: 1061:{
        -: 1062:  /* 1. */
    #####: 1063:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (arr));
        -: 1064:
        -: 1065:  /* 3. */
    #####: 1066:  if (!ecma_is_value_object (arr))
        -: 1067:  {
    #####: 1068:    ecma_raise_type_error (ECMA_ERR_ARGUMENT_IS_NOT_AN_OBJECT);
    #####: 1069:    return NULL;
        -: 1070:  }
    #####: 1071:  ecma_object_t *obj_p = ecma_get_object_from_value (arr);
        -: 1072:
        -: 1073:  /* 4. 5. */
    #####: 1074:  ecma_length_t len;
    #####: 1075:  if (ECMA_IS_VALUE_ERROR (ecma_op_object_get_length (obj_p, &len)))
        -: 1076:  {
    #####: 1077:    return NULL;
        -: 1078:  }
        -: 1079:
        -: 1080:  /* 6. */
    #####: 1081:  ecma_collection_t *list_ptr = ecma_new_collection ();
        -: 1082:
        -: 1083:  /* 7. 8. */
    #####: 1084:  for (ecma_length_t idx = 0; idx < len; idx++)
        -: 1085:  {
    #####: 1086:    ecma_value_t next = ecma_op_object_get_by_index (obj_p, idx);
    #####: 1087:    if (ECMA_IS_VALUE_ERROR (next))
        -: 1088:    {
    #####: 1089:      ecma_collection_free (list_ptr);
    #####: 1090:      return NULL;
        -: 1091:    }
        -: 1092:
    #####: 1093:    if (prop_names_only && !ecma_is_value_prop_name (next))
        -: 1094:    {
    #####: 1095:      ecma_free_value (next);
    #####: 1096:      ecma_collection_free (list_ptr);
    #####: 1097:      ecma_raise_type_error (ECMA_ERR_PROPERTY_NAME_IS_NEITHER_SYMBOL_NOR_STRING);
    #####: 1098:      return NULL;
        -: 1099:    }
        -: 1100:
    #####: 1101:    ecma_collection_push_back (list_ptr, next);
        -: 1102:  }
        -: 1103:
        -: 1104:  /* 9. */
    #####: 1105:  return list_ptr;
        -: 1106:} /* ecma_op_create_list_from_array_like */
        -: 1107:#endif /* JERRY_ESNEXT */
        -: 1108:
        -: 1109:/**
        -: 1110: * @}
        -: 1111: * @}
        -: 1112: */
