        -:    0:Source:/home/workspace/jerry-core/parser/js/js-scanner-util.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-helpers.h"
        -:   17:#include "ecma-lex-env.h"
        -:   18:
        -:   19:#include "jcontext.h"
        -:   20:#include "js-parser-internal.h"
        -:   21:#include "js-scanner-internal.h"
        -:   22:#include "lit-char-helpers.h"
        -:   23:
        -:   24:#if JERRY_PARSER
        -:   25:
        -:   26:/** \addtogroup parser Parser
        -:   27: * @{
        -:   28: *
        -:   29: * \addtogroup jsparser JavaScript
        -:   30: * @{
        -:   31: *
        -:   32: * \addtogroup jsparser_scanner Scanner
        -:   33: * @{
        -:   34: */
        -:   35:
        -:   36:JERRY_STATIC_ASSERT (PARSER_MAXIMUM_NUMBER_OF_LITERALS + PARSER_MAXIMUM_NUMBER_OF_REGISTERS < PARSER_REGISTER_START,
        -:   37:                     maximum_number_of_literals_plus_registers_must_be_less_than_register_start);
        -:   38:
        -:   39:#if JERRY_ESNEXT
        -:   40:
        -:   41:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG & SCANNER_LITERAL_IS_LOCAL) == 0,
        -:   42:                     is_arrow_arg_binding_flag_must_not_use_local_flags);
        -:   43:
        -:   44:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_LET & SCANNER_LITERAL_IS_LOCAL) != 0, is_let_flag_must_use_local_flags);
        -:   45:
        -:   46:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_CONST & SCANNER_LITERAL_IS_LOCAL) != 0, is_const_flag_must_use_local_flags);
        -:   47:
        -:   48:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_FUNC_DECLARATION & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   49:                     is_func_declaration_flag_must_use_local_flags);
        -:   50:
        -:   51:JERRY_STATIC_ASSERT ((SCANNER_LITERAL_IS_DESTRUCTURED_ARG & SCANNER_LITERAL_IS_LOCAL) != 0,
        -:   52:                     is_arg_binding_flag_must_use_local_flags);
        -:   53:
        -:   54:JERRY_STATIC_ASSERT (SCANNER_LITERAL_IS_FUNC_DECLARATION != SCANNER_LITERAL_IS_DESTRUCTURED_ARG,
        -:   55:                     is_func_declaration_must_be_different_from_is_arg_binding);
        -:   56:
        -:   57:JERRY_STATIC_ASSERT (PARSER_SCOPE_STACK_IS_CONST_REG == PARSER_SCOPE_STACK_IS_LOCAL_CREATED,
        -:   58:                     scope_stack_is_const_reg_and_scope_stack_is_local_created_must_be_the_same);
        -:   59:
        -:   60:#endif /* JERRY_ESNEXT */
        -:   61:
        -:   62:/**
        -:   63: * Raise a scanner error.
        -:   64: */
        -:   65:void
    #####:   66:scanner_raise_error (parser_context_t *context_p) /**< context */
        -:   67:{
    #####:   68:  PARSER_THROW (context_p->try_buffer);
        -:   69:  /* Should never been reached. */
        -:   70:  JERRY_ASSERT (0);
        -:   71:} /* scanner_raise_error */
        -:   72:
        -:   73:#if JERRY_ESNEXT
        -:   74:
        -:   75:/**
        -:   76: * Raise a variable redeclaration error.
        -:   77: */
        -:   78:void
    #####:   79:scanner_raise_redeclaration_error (parser_context_t *context_p) /**< context */
        -:   80:{
    #####:   81:  scanner_info_t *info_p = scanner_insert_info (context_p, context_p->source_p, sizeof (scanner_info_t));
    #####:   82:  info_p->type = SCANNER_TYPE_ERR_REDECLARED;
        -:   83:
    #####:   84:  scanner_raise_error (context_p);
    #####:   85:} /* scanner_raise_redeclaration_error */
        -:   86:
        -:   87:#endif /* JERRY_ESNEXT */
        -:   88:
        -:   89:/**
        -:   90: * Allocate memory for scanner.
        -:   91: *
        -:   92: * @return allocated memory
        -:   93: */
        -:   94:void *
       13:   95:scanner_malloc (parser_context_t *context_p, /**< context */
        -:   96:                size_t size) /**< size of the memory block */
        -:   97:{
        -:   98:  void *result;
        -:   99:
       13:  100:  JERRY_ASSERT (size > 0);
       13:  101:  result = jmem_heap_alloc_block_null_on_error (size);
        -:  102:
       13:  103:  if (result == NULL)
        -:  104:  {
    #####:  105:    scanner_cleanup (context_p);
        -:  106:
        -:  107:    /* This is the only error which specify its reason. */
    #####:  108:    context_p->error = PARSER_ERR_OUT_OF_MEMORY;
    #####:  109:    PARSER_THROW (context_p->try_buffer);
        -:  110:  }
       13:  111:  return result;
        -:  112:} /* scanner_malloc */
        -:  113:
        -:  114:/**
        -:  115: * Free memory allocated by scanner_malloc.
        -:  116: */
        -:  117:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  118:scanner_free (void *ptr, /**< pointer to free */
        -:  119:              size_t size) /**< size of the memory block */
        -:  120:{
        6:  121:  jmem_heap_free_block (ptr, size);
    #####:  122:} /* scanner_free */
        -:  123:
        -:  124:/**
        -:  125: * Count the size of a stream after an info block.
        -:  126: *
        -:  127: * @return the size in bytes
        -:  128: */
        -:  129:size_t
    #####:  130:scanner_get_stream_size (scanner_info_t *info_p, /**< scanner info block */
        -:  131:                         size_t size) /**< size excluding the stream */
        -:  132:{
    #####:  133:  const uint8_t *data_p = ((const uint8_t *) info_p) + size;
    #####:  134:  const uint8_t *data_p_start = data_p;
        -:  135:
    #####:  136:  while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -:  137:  {
    #####:  138:    switch (data_p[0] & SCANNER_STREAM_TYPE_MASK)
        -:  139:    {
    #####:  140:      case SCANNER_STREAM_TYPE_VAR:
        -:  141:#if JERRY_ESNEXT
        -:  142:      case SCANNER_STREAM_TYPE_LET:
        -:  143:      case SCANNER_STREAM_TYPE_CONST:
        -:  144:      case SCANNER_STREAM_TYPE_LOCAL:
        -:  145:#endif /* JERRY_ESNEXT */
        -:  146:#if JERRY_MODULE_SYSTEM
        -:  147:      case SCANNER_STREAM_TYPE_IMPORT:
        -:  148:#endif /* JERRY_MODULE_SYSTEM */
        -:  149:      case SCANNER_STREAM_TYPE_ARG:
        -:  150:#if JERRY_ESNEXT
        -:  151:      case SCANNER_STREAM_TYPE_ARG_VAR:
        -:  152:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -:  153:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -:  154:#endif /* JERRY_MODULE_SYSTEM */
        -:  155:      case SCANNER_STREAM_TYPE_ARG_FUNC:
        -:  156:#if JERRY_ESNEXT
        -:  157:      case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -:  158:#endif /* JERRY_ESNEXT */
        -:  159:      case SCANNER_STREAM_TYPE_FUNC:
        -:  160:      {
    #####:  161:        break;
        -:  162:      }
    #####:  163:      default:
        -:  164:      {
    #####:  165:        JERRY_ASSERT ((data_p[0] & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_HOLE
        -:  166:                      || SCANNER_STREAM_TYPE_IS_ARGUMENTS (data_p[0] & SCANNER_STREAM_TYPE_MASK));
    #####:  167:        data_p++;
    #####:  168:        continue;
        -:  169:      }
        -:  170:    }
        -:  171:
    #####:  172:    data_p += 3;
        -:  173:
    #####:  174:    if (data_p[-3] & SCANNER_STREAM_UINT16_DIFF)
        -:  175:    {
    #####:  176:      data_p++;
        -:  177:    }
    #####:  178:    else if (data_p[-1] == 0)
        -:  179:    {
    #####:  180:      data_p += sizeof (const uint8_t *);
        -:  181:    }
        -:  182:  }
        -:  183:
    #####:  184:  return size + 1 + (size_t) (data_p - data_p_start);
        -:  185:} /* scanner_get_stream_size */
        -:  186:
        -:  187:/**
        -:  188: * Insert a scanner info block into the scanner info chain.
        -:  189: *
        -:  190: * @return newly allocated scanner info
        -:  191: */
        -:  192:scanner_info_t *
        6:  193:scanner_insert_info (parser_context_t *context_p, /**< context */
        -:  194:                     const uint8_t *source_p, /**< triggering position */
        -:  195:                     size_t size) /**< size of the memory block */
        -:  196:{
        6:  197:  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);
        6:  198:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        6:  199:  scanner_info_t *prev_scanner_info_p = NULL;
        -:  200:
        6:  201:  JERRY_ASSERT (scanner_info_p != NULL);
        6:  202:  JERRY_ASSERT (source_p != NULL);
        -:  203:
        6:  204:  new_scanner_info_p->source_p = source_p;
        -:  205:
       18:  206:  while (source_p < scanner_info_p->source_p)
        -:  207:  {
        6:  208:    prev_scanner_info_p = scanner_info_p;
        6:  209:    scanner_info_p = scanner_info_p->next_p;
        -:  210:
        6:  211:    JERRY_ASSERT (scanner_info_p != NULL);
        -:  212:  }
        -:  213:
        -:  214:  /* Multiple scanner info blocks cannot be assigned to the same position. */
        6:  215:  JERRY_ASSERT (source_p != scanner_info_p->source_p);
        -:  216:
        6:  217:  new_scanner_info_p->next_p = scanner_info_p;
        -:  218:
        6:  219:  if (JERRY_LIKELY (prev_scanner_info_p == NULL))
        -:  220:  {
        4:  221:    context_p->next_scanner_info_p = new_scanner_info_p;
        -:  222:  }
        -:  223:  else
        -:  224:  {
        2:  225:    prev_scanner_info_p->next_p = new_scanner_info_p;
        -:  226:  }
        -:  227:
        6:  228:  return new_scanner_info_p;
        -:  229:} /* scanner_insert_info */
        -:  230:
        -:  231:/**
        -:  232: * Insert a scanner info block into the scanner info chain before a given info block.
        -:  233: *
        -:  234: * @return newly allocated scanner info
        -:  235: */
        -:  236:scanner_info_t *
    #####:  237:scanner_insert_info_before (parser_context_t *context_p, /**< context */
        -:  238:                            const uint8_t *source_p, /**< triggering position */
        -:  239:                            scanner_info_t *start_info_p, /**< first info position */
        -:  240:                            size_t size) /**< size of the memory block */
        -:  241:{
    #####:  242:  JERRY_ASSERT (start_info_p != NULL);
        -:  243:
    #####:  244:  scanner_info_t *new_scanner_info_p = (scanner_info_t *) scanner_malloc (context_p, size);
    #####:  245:  scanner_info_t *scanner_info_p = start_info_p->next_p;
    #####:  246:  scanner_info_t *prev_scanner_info_p = start_info_p;
        -:  247:
    #####:  248:  new_scanner_info_p->source_p = source_p;
        -:  249:
    #####:  250:  while (source_p < scanner_info_p->source_p)
        -:  251:  {
    #####:  252:    prev_scanner_info_p = scanner_info_p;
    #####:  253:    scanner_info_p = scanner_info_p->next_p;
        -:  254:
    #####:  255:    JERRY_ASSERT (scanner_info_p != NULL);
        -:  256:  }
        -:  257:
        -:  258:  /* Multiple scanner info blocks cannot be assigned to the same position. */
    #####:  259:  JERRY_ASSERT (source_p != scanner_info_p->source_p);
        -:  260:
    #####:  261:  new_scanner_info_p->next_p = scanner_info_p;
        -:  262:
    #####:  263:  prev_scanner_info_p->next_p = new_scanner_info_p;
    #####:  264:  return new_scanner_info_p;
        -:  265:} /* scanner_insert_info_before */
        -:  266:
        -:  267:/**
        -:  268: * Release the next scanner info.
        -:  269: */
        -:  270:extern inline void JERRY_ATTR_ALWAYS_INLINE
        1:  271:scanner_release_next (parser_context_t *context_p, /**< context */
        -:  272:                      size_t size) /**< size of the memory block */
        -:  273:{
        6:  274:  scanner_info_t *next_p = context_p->next_scanner_info_p->next_p;
        -:  275:
        6:  276:  jmem_heap_free_block (context_p->next_scanner_info_p, size);
        6:  277:  context_p->next_scanner_info_p = next_p;
        1:  278:} /* scanner_release_next */
        -:  279:
        -:  280:/**
        -:  281: * Set the active scanner info to the next scanner info.
        -:  282: */
        -:  283:extern inline void JERRY_ATTR_ALWAYS_INLINE
        1:  284:scanner_set_active (parser_context_t *context_p) /**< context */
        -:  285:{
        1:  286:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -:  287:
        1:  288:  context_p->next_scanner_info_p = scanner_info_p->next_p;
        1:  289:  scanner_info_p->next_p = context_p->active_scanner_info_p;
        1:  290:  context_p->active_scanner_info_p = scanner_info_p;
        1:  291:} /* scanner_set_active */
        -:  292:
        -:  293:/**
        -:  294: * Set the next scanner info to the active scanner info.
        -:  295: */
        -:  296:extern inline void JERRY_ATTR_ALWAYS_INLINE
        1:  297:scanner_revert_active (parser_context_t *context_p) /**< context */
        -:  298:{
        1:  299:  scanner_info_t *scanner_info_p = context_p->active_scanner_info_p;
        -:  300:
        1:  301:  context_p->active_scanner_info_p = scanner_info_p->next_p;
        1:  302:  scanner_info_p->next_p = context_p->next_scanner_info_p;
        1:  303:  context_p->next_scanner_info_p = scanner_info_p;
        1:  304:} /* scanner_revert_active */
        -:  305:
        -:  306:/**
        -:  307: * Release the active scanner info.
        -:  308: */
        -:  309:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####:  310:scanner_release_active (parser_context_t *context_p, /**< context */
        -:  311:                        size_t size) /**< size of the memory block */
        -:  312:{
    #####:  313:  scanner_info_t *next_p = context_p->active_scanner_info_p->next_p;
        -:  314:
    #####:  315:  jmem_heap_free_block (context_p->active_scanner_info_p, size);
    #####:  316:  context_p->active_scanner_info_p = next_p;
    #####:  317:} /* scanner_release_active */
        -:  318:
        -:  319:/**
        -:  320: * Release switch cases.
        -:  321: */
        -:  322:void
    #####:  323:scanner_release_switch_cases (scanner_case_info_t *case_p) /**< case list */
        -:  324:{
    #####:  325:  while (case_p != NULL)
        -:  326:  {
    #####:  327:    scanner_case_info_t *next_p = case_p->next_p;
        -:  328:
    #####:  329:    jmem_heap_free_block (case_p, sizeof (scanner_case_info_t));
    #####:  330:    case_p = next_p;
        -:  331:  }
    #####:  332:} /* scanner_release_switch_cases */
        -:  333:
        -:  334:/**
        -:  335: * Release private fields.
        -:  336: */
        -:  337:void
        1:  338:scanner_release_private_fields (scanner_class_private_member_t *member_p) /**< private member list */
        -:  339:{
        3:  340:  while (member_p != NULL)
        -:  341:  {
        1:  342:    scanner_class_private_member_t *prev_p = member_p->prev_p;
        -:  343:
        1:  344:    jmem_heap_free_block (member_p, sizeof (scanner_class_private_member_t));
        1:  345:    member_p = prev_p;
        -:  346:  }
        1:  347:} /* scanner_release_private_fields */
        -:  348:
        -:  349:/**
        -:  350: * Seek to correct position in the scanner info list.
        -:  351: */
        -:  352:void
    #####:  353:scanner_seek (parser_context_t *context_p) /**< context */
        -:  354:{
    #####:  355:  const uint8_t *source_p = context_p->source_p;
        -:  356:  scanner_info_t *prev_p;
        -:  357:
    #####:  358:  if (context_p->skipped_scanner_info_p != NULL)
        -:  359:  {
    #####:  360:    JERRY_ASSERT (context_p->skipped_scanner_info_p->source_p != NULL);
        -:  361:
    #####:  362:    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;
        -:  363:
    #####:  364:    if (context_p->skipped_scanner_info_end_p->source_p <= source_p)
        -:  365:    {
    #####:  366:      prev_p = context_p->skipped_scanner_info_end_p;
        -:  367:    }
        -:  368:    else
        -:  369:    {
    #####:  370:      prev_p = context_p->skipped_scanner_info_p;
        -:  371:
    #####:  372:      if (prev_p->source_p > source_p)
        -:  373:      {
    #####:  374:        context_p->next_scanner_info_p = prev_p;
    #####:  375:        context_p->skipped_scanner_info_p = NULL;
    #####:  376:        return;
        -:  377:      }
        -:  378:
    #####:  379:      context_p->skipped_scanner_info_p = prev_p;
        -:  380:    }
        -:  381:  }
        -:  382:  else
        -:  383:  {
    #####:  384:    prev_p = context_p->next_scanner_info_p;
        -:  385:
    #####:  386:    if (prev_p->source_p == NULL || prev_p->source_p > source_p)
        -:  387:    {
    #####:  388:      return;
        -:  389:    }
        -:  390:
    #####:  391:    context_p->skipped_scanner_info_p = prev_p;
        -:  392:  }
        -:  393:
    #####:  394:  while (prev_p->next_p->source_p != NULL && prev_p->next_p->source_p <= source_p)
        -:  395:  {
    #####:  396:    prev_p = prev_p->next_p;
        -:  397:  }
        -:  398:
    #####:  399:  context_p->skipped_scanner_info_end_p = prev_p;
    #####:  400:  context_p->next_scanner_info_p = prev_p->next_p;
        -:  401:} /* scanner_seek */
        -:  402:
        -:  403:/**
        -:  404: * Checks whether a literal is equal to "arguments".
        -:  405: */
        -:  406:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:  407:scanner_literal_is_arguments (lexer_lit_location_t *literal_p) /**< literal */
        -:  408:{
        6:  409:  return lexer_compare_identifier_to_string (literal_p, (const uint8_t *) "arguments", 9);
        -:  410:} /* scanner_literal_is_arguments */
        -:  411:
        -:  412:#if JERRY_ESNEXT
        -:  413:
        -:  414:/**
        -:  415: * Find if there is a duplicated argument in the given context
        -:  416: *
        -:  417: * @return true - if there are duplicates, false - otherwise
        -:  418: */
        -:  419:static bool
    #####:  420:scanner_find_duplicated_arg (parser_context_t *context_p, lexer_lit_location_t *lit_loc_p)
        -:  421:{
    #####:  422:  if (!(context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS))
        -:  423:  {
    #####:  424:    return false;
        -:  425:  }
        -:  426:
    #####:  427:  if (scanner_literal_is_arguments (lit_loc_p))
        -:  428:  {
    #####:  429:    return true;
        -:  430:  }
        -:  431:
        -:  432:  uint16_t register_end, encoding_limit, encoding_delta;
        -:  433:  ecma_value_t *literal_p;
        -:  434:  ecma_value_t *literal_start_p;
        -:  435:
    #####:  436:  const ecma_compiled_code_t *bytecode_header_p = JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p;
        -:  437:
    #####:  438:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  439:  {
    #####:  440:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -:  441:
    #####:  442:    register_end = args_p->register_end;
        -:  443:
    #####:  444:    literal_p = (ecma_value_t *) (args_p + 1);
    #####:  445:    literal_p -= register_end;
    #####:  446:    literal_start_p = literal_p;
    #####:  447:    literal_p += args_p->literal_end;
        -:  448:  }
        -:  449:  else
        -:  450:  {
    #####:  451:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -:  452:
    #####:  453:    register_end = args_p->register_end;
        -:  454:
    #####:  455:    literal_p = (ecma_value_t *) (args_p + 1);
    #####:  456:    literal_p -= register_end;
    #####:  457:    literal_start_p = literal_p;
    #####:  458:    literal_p += args_p->literal_end;
        -:  459:  }
        -:  460:
    #####:  461:  if (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -:  462:  {
    #####:  463:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
    #####:  464:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -:  465:  }
        -:  466:  else
        -:  467:  {
    #####:  468:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####:  469:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -:  470:  }
        -:  471:
    #####:  472:  uint8_t *byte_code_p = (uint8_t *) literal_p;
        -:  473:
    #####:  474:  bool found_duplicate = false;
        -:  475:
    #####:  476:  while (*byte_code_p == CBC_CREATE_LOCAL)
        -:  477:  {
    #####:  478:    byte_code_p++;
    #####:  479:    uint16_t literal_index = *byte_code_p++;
        -:  480:
    #####:  481:    if (literal_index >= encoding_limit)
        -:  482:    {
    #####:  483:      literal_index = (uint16_t) (((literal_index << 8) | *byte_code_p++) - encoding_delta);
        -:  484:    }
        -:  485:
    #####:  486:    ecma_string_t *arg_string = ecma_get_string_from_value (literal_start_p[literal_index]);
    #####:  487:    uint8_t *destination_p = (uint8_t *) parser_malloc (context_p, lit_loc_p->length);
    #####:  488:    lexer_convert_ident_to_cesu8 (destination_p, lit_loc_p->char_p, lit_loc_p->length);
    #####:  489:    ecma_string_t *search_key_p = ecma_new_ecma_string_from_utf8 (destination_p, lit_loc_p->length);
    #####:  490:    scanner_free (destination_p, lit_loc_p->length);
        -:  491:
    #####:  492:    found_duplicate = ecma_compare_ecma_strings (arg_string, search_key_p);
    #####:  493:    ecma_deref_ecma_string (search_key_p);
        -:  494:
    #####:  495:    if (found_duplicate)
        -:  496:    {
    #####:  497:      break;
        -:  498:    }
        -:  499:  }
        -:  500:
    #####:  501:  return found_duplicate;
        -:  502:} /* scanner_find_duplicated_arg */
        -:  503:
        -:  504:/**
        -:  505: * Find any let/const declaration of a given literal.
        -:  506: *
        -:  507: * @return true - if the literal is found, false - otherwise
        -:  508: */
        -:  509:static bool
    #####:  510:scanner_scope_find_lexical_declaration (parser_context_t *context_p, /**< context */
        -:  511:                                        lexer_lit_location_t *literal_p) /**< literal */
        -:  512:{
        -:  513:  ecma_string_t *name_p;
    #####:  514:  uint32_t flags = context_p->global_status_flags;
        -:  515:
    #####:  516:  if (!(flags & ECMA_PARSE_EVAL) || (!(flags & ECMA_PARSE_DIRECT_EVAL) && (context_p->status_flags & PARSER_IS_STRICT)))
        -:  517:  {
    #####:  518:    return false;
        -:  519:  }
        -:  520:
    #####:  521:  if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -:  522:  {
    #####:  523:    name_p = ecma_new_ecma_string_from_utf8 (literal_p->char_p, literal_p->length);
        -:  524:  }
        -:  525:  else
        -:  526:  {
    #####:  527:    uint8_t *destination_p = (uint8_t *) scanner_malloc (context_p, literal_p->length);
        -:  528:
    #####:  529:    lexer_convert_ident_to_cesu8 (destination_p, literal_p->char_p, literal_p->length);
        -:  530:
    #####:  531:    name_p = ecma_new_ecma_string_from_utf8 (destination_p, literal_p->length);
        -:  532:
    #####:  533:    scanner_free (destination_p, literal_p->length);
        -:  534:  }
        -:  535:
        -:  536:  ecma_object_t *lex_env_p;
        -:  537:
    #####:  538:  if (flags & ECMA_PARSE_DIRECT_EVAL)
        -:  539:  {
    #####:  540:    lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -:  541:
    #####:  542:    while (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_BLOCK)
        -:  543:    {
    #####:  544:      if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  545:      {
    #####:  546:        ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  547:
    #####:  548:        if (property_p != NULL && ecma_is_property_enumerable (*property_p))
        -:  549:        {
    #####:  550:          ecma_deref_ecma_string (name_p);
    #####:  551:          return true;
        -:  552:        }
        -:  553:      }
        -:  554:
    #####:  555:      JERRY_ASSERT (lex_env_p->u2.outer_reference_cp != JMEM_CP_NULL);
    #####:  556:      lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -:  557:    }
        -:  558:  }
        -:  559:  else
        -:  560:  {
    #####:  561:    lex_env_p = ecma_get_global_scope (ecma_builtin_get_global ());
        -:  562:  }
        -:  563:
    #####:  564:  if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -:  565:  {
    #####:  566:    ecma_property_t *property_p = ecma_find_named_property (lex_env_p, name_p);
        -:  567:
    #####:  568:    if (property_p != NULL
    #####:  569:        && (ecma_is_property_enumerable (*property_p) || scanner_find_duplicated_arg (context_p, literal_p)))
        -:  570:    {
    #####:  571:      ecma_deref_ecma_string (name_p);
    #####:  572:      return true;
        -:  573:    }
        -:  574:  }
        -:  575:
    #####:  576:  ecma_deref_ecma_string (name_p);
    #####:  577:  return false;
        -:  578:} /* scanner_scope_find_lexical_declaration */
        -:  579:
        -:  580:#endif /* JERRY_ESNEXT */
        -:  581:
        -:  582:/**
        -:  583: * Push a new literal pool.
        -:  584: *
        -:  585: * @return the newly created literal pool
        -:  586: */
        -:  587:scanner_literal_pool_t *
        6:  588:scanner_push_literal_pool (parser_context_t *context_p, /**< context */
        -:  589:                           scanner_context_t *scanner_context_p, /**< scanner context */
        -:  590:                           uint16_t status_flags) /**< combination of scanner_literal_pool_flags_t flags */
        -:  591:{
        6:  592:  scanner_literal_pool_t *prev_literal_pool_p = scanner_context_p->active_literal_pool_p;
        -:  593:  scanner_literal_pool_t *literal_pool_p;
        -:  594:
        6:  595:  literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
        -:  596:
        6:  597:  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION))
        -:  598:  {
        1:  599:    JERRY_ASSERT (prev_literal_pool_p != NULL);
        1:  600:    status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  601:
        -:  602:#if JERRY_ESNEXT
        1:  603:    const uint16_t copied_flags =
        -:  604:      (SCANNER_LITERAL_POOL_IN_WITH | SCANNER_LITERAL_POOL_GENERATOR | SCANNER_LITERAL_POOL_ASYNC);
        -:  605:#else /* !JERRY_ESNEXT */
    #####:  606:    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IN_WITH;
        -:  607:#endif /* JERRY_ESNEXT */
        -:  608:
        1:  609:    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);
        -:  610:  }
        -:  611:#if JERRY_ESNEXT
        -:  612:  else
        -:  613:  {
        5:  614:    context_p->status_flags &= (uint32_t) ~(PARSER_IS_GENERATOR_FUNCTION | PARSER_IS_ASYNC_FUNCTION);
        -:  615:
        5:  616:    if (status_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -:  617:    {
    #####:  618:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -:  619:    }
        -:  620:
        5:  621:    if (status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -:  622:    {
    #####:  623:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -:  624:    }
        -:  625:  }
        -:  626:#endif /* JERRY_ESNEXT */
        -:  627:
        6:  628:  if (prev_literal_pool_p != NULL)
        -:  629:  {
        5:  630:    const uint16_t copied_flags = SCANNER_LITERAL_POOL_IS_STRICT;
        5:  631:    status_flags |= (uint16_t) (prev_literal_pool_p->status_flags & copied_flags);
        -:  632:
        -:  633:    /* The logical value of these flags must be the same. */
        5:  634:    JERRY_ASSERT (!(status_flags & SCANNER_LITERAL_POOL_IS_STRICT) == !(context_p->status_flags & PARSER_IS_STRICT));
        -:  635:  }
        -:  636:
        6:  637:  parser_list_init (&literal_pool_p->literal_pool,
        -:  638:                    sizeof (lexer_lit_location_t),
        -:  639:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
        6:  640:  literal_pool_p->source_p = NULL;
        6:  641:  literal_pool_p->status_flags = status_flags;
        6:  642:  literal_pool_p->no_declarations = 0;
        -:  643:
        6:  644:  literal_pool_p->prev_p = prev_literal_pool_p;
        6:  645:  scanner_context_p->active_literal_pool_p = literal_pool_p;
        -:  646:
        6:  647:  return literal_pool_p;
        -:  648:} /* scanner_push_literal_pool */
        -:  649:
        -:  650:JERRY_STATIC_ASSERT (PARSER_MAXIMUM_IDENT_LENGTH <= UINT8_MAX, maximum_ident_length_must_fit_in_a_byte);
        -:  651:
        -:  652:/**
        -:  653: * Current status of arguments.
        -:  654: */
        -:  655:typedef enum
        -:  656:{
        -:  657:  SCANNER_ARGUMENTS_NOT_PRESENT, /**< arguments object must not be created */
        -:  658:  SCANNER_ARGUMENTS_MAY_PRESENT, /**< arguments object can be created */
        -:  659:  SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL, /**< arguments object must be present unless otherwise declared */
        -:  660:  SCANNER_ARGUMENTS_PRESENT, /**< arguments object must be created */
        -:  661:  SCANNER_ARGUMENTS_PRESENT_NO_REG, /**< arguments object must be created and cannot be stored in registers */
        -:  662:} scanner_arguments_type_t;
        -:  663:
        -:  664:/**
        -:  665: * Pop the last literal pool from the end.
        -:  666: */
        -:  667:void
        6:  668:scanner_pop_literal_pool (parser_context_t *context_p, /**< context */
        -:  669:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -:  670:{
        6:  671:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        6:  672:  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
        -:  673:
        -:  674:#if JERRY_ESNEXT
        6:  675:  const uint32_t arrow_super_flags = (SCANNER_LITERAL_POOL_ARROW | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);
        6:  676:  if ((literal_pool_p->status_flags & arrow_super_flags) == arrow_super_flags)
        -:  677:  {
    #####:  678:    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE;
        -:  679:  }
        -:  680:#endif /* JERRY_ESNEXT */
        -:  681:
        6:  682:  if (JERRY_UNLIKELY (literal_pool_p->source_p == NULL))
        -:  683:  {
    #####:  684:    JERRY_ASSERT (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION);
    #####:  685:    JERRY_ASSERT (literal_pool_p->literal_pool.data.first_p == NULL
        -:  686:                  && literal_pool_p->literal_pool.data.last_p == NULL);
        -:  687:
    #####:  688:    scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;
    #####:  689:    scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
    #####:  690:    return;
        -:  691:  }
        -:  692:
        6:  693:  uint16_t status_flags = literal_pool_p->status_flags;
        6:  694:  scanner_arguments_type_t arguments_type = SCANNER_ARGUMENTS_MAY_PRESENT;
        -:  695:
        6:  696:  if (status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS)
        -:  697:  {
        2:  698:    arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  699:  }
        4:  700:  else if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)
        -:  701:  {
    #####:  702:    arguments_type = SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL;
        -:  703:  }
        -:  704:
        -:  705:#if JERRY_ESNEXT
        6:  706:  if (status_flags & SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS)
        -:  707:  {
    #####:  708:    arguments_type = SCANNER_ARGUMENTS_PRESENT;
        -:  709:
    #####:  710:    if (status_flags & (SCANNER_LITERAL_POOL_NO_ARGUMENTS | SCANNER_LITERAL_POOL_CAN_EVAL))
        -:  711:    {
    #####:  712:      arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
    #####:  713:      status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  714:    }
        -:  715:  }
        -:  716:#endif /* JERRY_ESNEXT */
        -:  717:
        6:  718:  uint8_t can_eval_types = 0;
        -:  719:#if JERRY_ESNEXT
        6:  720:  if (prev_literal_pool_p == NULL && !(context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
        -:  721:  {
        1:  722:    can_eval_types |= SCANNER_LITERAL_IS_FUNC;
        -:  723:  }
        -:  724:#endif /* JERRY_ESNEXT */
        -:  725:
        6:  726:  if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && prev_literal_pool_p != NULL)
        -:  727:  {
    #####:  728:    prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  729:  }
        -:  730:
        -:  731:#if JERRY_DEBUGGER
        -:  732:  if (scanner_context_p->status_flags & SCANNER_CONTEXT_DEBUGGER_ENABLED)
        -:  733:  {
        -:  734:    /* When debugger is enabled, identifiers are not stored in registers. However,
        -:  735:     * this does not affect 'eval' detection, so 'arguments' object is not created. */
        -:  736:    status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -:  737:  }
        -:  738:#endif /* JERRY_DEBUGGER */
        -:  739:
        6:  740:  parser_list_iterator_t literal_iterator;
        -:  741:  lexer_lit_location_t *literal_p;
        6:  742:  int32_t no_declarations = literal_pool_p->no_declarations;
        -:  743:
        6:  744:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -:  745:
        6:  746:  uint8_t arguments_stream_type = SCANNER_STREAM_TYPE_ARGUMENTS;
        6:  747:  const uint8_t *prev_source_p = literal_pool_p->source_p - 1;
        6:  748:  lexer_lit_location_t *last_argument_p = NULL;
        6:  749:  size_t compressed_size = 1;
        -:  750:
       24:  751:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -:  752:  {
       12:  753:    uint8_t type = literal_p->type;
        -:  754:
       12:  755:    if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK))
        -:  756:    {
    #####:  757:      continue;
        -:  758:    }
        -:  759:
       18:  760:    if (!(status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) && scanner_literal_is_arguments (literal_p))
        -:  761:    {
        -:  762:#if JERRY_ESNEXT
    #####:  763:      JERRY_ASSERT (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT);
        -:  764:#else /* !JERRY_ESNEXT */
        -:  765:      JERRY_ASSERT (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT
        -:  766:                    || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL);
        -:  767:#endif /* JERRY_ESNEXT */
        -:  768:
    #####:  769:      status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -:  770:
    #####:  771:      if (type & SCANNER_LITERAL_IS_ARG)
        -:  772:      {
    #####:  773:        JERRY_ASSERT (arguments_type != SCANNER_ARGUMENTS_PRESENT
        -:  774:                      && arguments_type != SCANNER_ARGUMENTS_PRESENT_NO_REG);
    #####:  775:        arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
    #####:  776:        last_argument_p = literal_p;
        -:  777:      }
        -:  778:#if JERRY_ESNEXT
    #####:  779:      else if (type & SCANNER_LITERAL_IS_LOCAL)
        -:  780:      {
    #####:  781:        if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -:  782:        {
    #####:  783:          arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  784:        }
        -:  785:        else
        -:  786:        {
    #####:  787:          if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -:  788:          {
    #####:  789:            type |= SCANNER_LITERAL_NO_REG;
        -:  790:          }
    #####:  791:          else if (type & (SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE))
        -:  792:          {
    #####:  793:            arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  794:          }
        -:  795:
    #####:  796:          if ((type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_LOCAL_FUNC)
        -:  797:          {
    #####:  798:            type |= SCANNER_LITERAL_IS_ARG;
    #####:  799:            literal_p->type = type;
    #####:  800:            no_declarations--;
    #####:  801:            arguments_stream_type = SCANNER_STREAM_TYPE_ARGUMENTS_FUNC;
        -:  802:          }
        -:  803:          else
        -:  804:          {
    #####:  805:            arguments_stream_type |= SCANNER_STREAM_LOCAL_ARGUMENTS;
        -:  806:          }
        -:  807:        }
        -:  808:      }
        -:  809:#else /* !JERRY_ESNEXT */
    #####:  810:      else if (type & SCANNER_LITERAL_IS_FUNC)
        -:  811:      {
        -:  812:        arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -:  813:      }
        -:  814:#endif /* JERRY_ESNEXT */
        -:  815:      else
        -:  816:      {
        -:  817:#if JERRY_ESNEXT
    #####:  818:        if ((type & SCANNER_LITERAL_IS_VAR)
    #####:  819:            && (arguments_type == SCANNER_ARGUMENTS_PRESENT || arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG))
        -:  820:        {
    #####:  821:          if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -:  822:          {
    #####:  823:            type |= SCANNER_LITERAL_NO_REG;
        -:  824:          }
    #####:  825:          else if (type & (SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE))
        -:  826:          {
    #####:  827:            arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  828:          }
        -:  829:
    #####:  830:          type |= SCANNER_LITERAL_IS_ARG;
    #####:  831:          literal_p->type = type;
    #####:  832:          no_declarations--;
        -:  833:        }
        -:  834:#endif /* JERRY_ESNEXT */
        -:  835:
    #####:  836:        if ((type & SCANNER_LITERAL_NO_REG) || arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -:  837:        {
    #####:  838:          arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -:  839:        }
    #####:  840:        else if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT)
        -:  841:        {
    #####:  842:          arguments_type = SCANNER_ARGUMENTS_PRESENT;
        -:  843:        }
        -:  844:
        -:  845:#if JERRY_ESNEXT
        -:  846:        /* The SCANNER_LITERAL_IS_ARG may be set above. */
    #####:  847:        if (!(type & SCANNER_LITERAL_IS_ARG))
        -:  848:        {
    #####:  849:          literal_p->type = 0;
    #####:  850:          continue;
        -:  851:        }
        -:  852:#else /* !JERRY_ESNEXT */
    #####:  853:        literal_p->type = 0;
    #####:  854:        continue;
        -:  855:#endif /* JERRY_ESNEXT */
        -:  856:      }
        -:  857:    }
       12:  858:    else if (type & SCANNER_LITERAL_IS_ARG)
        -:  859:    {
        1:  860:      last_argument_p = literal_p;
        -:  861:    }
        -:  862:
        -:  863:#if JERRY_ESNEXT
       12:  864:    if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
       11:  865:        && (type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_FUNC)
        -:  866:    {
    #####:  867:      if (prev_literal_pool_p == NULL && scanner_scope_find_lexical_declaration (context_p, literal_p))
        -:  868:      {
    #####:  869:        literal_p->type = 0;
    #####:  870:        continue;
        -:  871:      }
        -:  872:
    #####:  873:      if (!(type & SCANNER_LITERAL_IS_ARG))
        -:  874:      {
    #####:  875:        type |= SCANNER_LITERAL_IS_VAR;
        -:  876:      }
        -:  877:
    #####:  878:      type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
    #####:  879:      literal_p->type = type;
        -:  880:    }
        -:  881:#endif /* JERRY_ESNEXT */
        -:  882:
       12:  883:    if ((type & SCANNER_LITERAL_IS_LOCAL)
        7:  884:        || ((type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))
        1:  885:            && (status_flags & SCANNER_LITERAL_POOL_FUNCTION)))
        -:  886:    {
        6:  887:      JERRY_ASSERT ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || !(literal_p->type & SCANNER_LITERAL_IS_ARG));
        -:  888:
        6:  889:      if (literal_p->length == 0)
        -:  890:      {
    #####:  891:        compressed_size += 1;
    #####:  892:        continue;
        -:  893:      }
        -:  894:
        6:  895:      no_declarations++;
        -:  896:
        6:  897:      if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) || (type & can_eval_types))
        -:  898:      {
        3:  899:        type |= SCANNER_LITERAL_NO_REG;
        3:  900:        literal_p->type = type;
        -:  901:      }
        -:  902:
        6:  903:      if (type & SCANNER_LITERAL_IS_FUNC)
        -:  904:      {
        1:  905:        no_declarations++;
        -:  906:
        -:  907:#if JERRY_ESNEXT
        1:  908:        if ((type & (SCANNER_LITERAL_IS_CONST | SCANNER_LITERAL_IS_ARG)) == SCANNER_LITERAL_IS_CONST)
        -:  909:        {
    #####:  910:          JERRY_ASSERT (type & SCANNER_LITERAL_IS_LET);
        -:  911:
        -:  912:          /* Catch parameters cannot be functions. */
    #####:  913:          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);
    #####:  914:          no_declarations--;
        -:  915:        }
        -:  916:#else /* !JERRY_ESNEXT */
    #####:  917:        if (type & SCANNER_LITERAL_IS_LOCAL)
        -:  918:        {
        -:  919:          /* Catch parameters cannot be functions. */
    #####:  920:          literal_p->type = (uint8_t) (type & ~SCANNER_LITERAL_IS_FUNC);
    #####:  921:          no_declarations--;
        -:  922:        }
        -:  923:#endif /* JERRY_ESNEXT */
        -:  924:      }
        -:  925:
        6:  926:      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);
        -:  927:
        6:  928:      if (diff >= 1 && diff <= (intptr_t) UINT8_MAX)
        -:  929:      {
        6:  930:        compressed_size += 2 + 1;
        -:  931:      }
    #####:  932:      else if (diff >= -(intptr_t) UINT8_MAX && diff <= (intptr_t) UINT16_MAX)
        -:  933:      {
    #####:  934:        compressed_size += 2 + 2;
        -:  935:      }
        -:  936:      else
        -:  937:      {
    #####:  938:        compressed_size += 2 + 1 + sizeof (const uint8_t *);
        -:  939:      }
        -:  940:
        6:  941:      prev_source_p = literal_p->char_p + literal_p->length;
        -:  942:
        6:  943:      if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -:  944:#if JERRY_ESNEXT
    #####:  945:          || ((type & SCANNER_LITERAL_IS_FUNC) && (status_flags & SCANNER_LITERAL_POOL_IS_STRICT))
        -:  946:#endif /* JERRY_ESNEXT */
    #####:  947:          || !(type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC)))
        -:  948:      {
        6:  949:        continue;
        -:  950:      }
        -:  951:    }
        -:  952:
        6:  953:    if (prev_literal_pool_p != NULL && literal_p->length > 0)
        -:  954:    {
        -:  955:      /* Propagate literal to upper level. */
        4:  956:      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p);
        4:  957:      uint8_t extended_type = literal_location_p->type;
        -:  958:
        -:  959:#if JERRY_ESNEXT
        4:  960:      const uint16_t no_reg_flags = (SCANNER_LITERAL_POOL_FUNCTION | SCANNER_LITERAL_POOL_CLASS_FIELD);
        -:  961:#else /* !JERRY_ESNEXT */
    #####:  962:      const uint16_t no_reg_flags = SCANNER_LITERAL_POOL_FUNCTION;
        -:  963:#endif /* JERRY_ESNEXT */
        -:  964:
        4:  965:      if ((status_flags & no_reg_flags) || (type & SCANNER_LITERAL_NO_REG))
        -:  966:      {
        3:  967:        extended_type |= SCANNER_LITERAL_NO_REG;
        -:  968:      }
        -:  969:
        -:  970:#if JERRY_ESNEXT
        4:  971:      extended_type |= SCANNER_LITERAL_IS_USED;
        -:  972:
        4:  973:      if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)
        -:  974:      {
        1:  975:        extended_type |= SCANNER_LITERAL_EARLY_CREATE;
        -:  976:      }
        -:  977:
        4:  978:      const uint8_t mask = (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_LOCAL);
        -:  979:
        4:  980:      if ((type & SCANNER_LITERAL_IS_ARG) || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_LET
    #####:  981:          || (literal_location_p->type & mask) == SCANNER_LITERAL_IS_CONST)
        -:  982:      {
        -:  983:        /* Clears the SCANNER_LITERAL_IS_VAR and SCANNER_LITERAL_IS_FUNC flags
        -:  984:         * for speculative arrow parameters and local (non-var) functions. */
        4:  985:        type = 0;
        -:  986:      }
        -:  987:#endif /* JERRY_ESNEXT */
        -:  988:
        4:  989:      type = (uint8_t) (type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_FUNC));
        4:  990:      JERRY_ASSERT (type == 0 || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION));
        -:  991:
        4:  992:      literal_location_p->type = (uint8_t) (extended_type | type);
        -:  993:    }
        -:  994:  }
        -:  995:
        6:  996:  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) || (compressed_size > 1))
        -:  997:  {
        5:  998:    if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT)
        -:  999:    {
        4: 1000:      arguments_type = SCANNER_ARGUMENTS_NOT_PRESENT;
        -: 1001:    }
        1: 1002:    else if (arguments_type == SCANNER_ARGUMENTS_MAY_PRESENT_IN_EVAL)
        -: 1003:    {
    #####: 1004:      arguments_type = SCANNER_ARGUMENTS_PRESENT_NO_REG;
        -: 1005:    }
        -: 1006:
        5: 1007:    if (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT)
        -: 1008:    {
    #####: 1009:      compressed_size++;
        -: 1010:    }
        -: 1011:
        5: 1012:    compressed_size += sizeof (scanner_info_t);
        -: 1013:
        -: 1014:    scanner_info_t *info_p;
        -: 1015:
        5: 1016:    if (prev_literal_pool_p != NULL || scanner_context_p->end_arguments_p == NULL)
        -: 1017:    {
        5: 1018:      info_p = scanner_insert_info (context_p, literal_pool_p->source_p, compressed_size);
        -: 1019:    }
        -: 1020:    else
        -: 1021:    {
    #####: 1022:      scanner_info_t *start_info_p = scanner_context_p->end_arguments_p;
    #####: 1023:      info_p = scanner_insert_info_before (context_p, literal_pool_p->source_p, start_info_p, compressed_size);
        -: 1024:    }
        -: 1025:
        5: 1026:    if (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        -: 1027:    {
    #####: 1028:      no_declarations = PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK;
        -: 1029:    }
        -: 1030:
        5: 1031:    uint8_t *data_p = (uint8_t *) (info_p + 1);
        5: 1032:    bool mapped_arguments = false;
        -: 1033:
        5: 1034:    if (status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        -: 1035:    {
        5: 1036:      info_p->type = SCANNER_TYPE_FUNCTION;
        -: 1037:
        5: 1038:      uint8_t u8_arg = 0;
        -: 1039:
        5: 1040:      if (arguments_type != SCANNER_ARGUMENTS_NOT_PRESENT)
        -: 1041:      {
    #####: 1042:        u8_arg |= SCANNER_FUNCTION_ARGUMENTS_NEEDED;
        -: 1043:
    #####: 1044:        if (no_declarations < PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
        -: 1045:        {
    #####: 1046:          no_declarations++;
        -: 1047:        }
        -: 1048:
        -: 1049:#if JERRY_ESNEXT
    #####: 1050:        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT | SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT;
        -: 1051:#else /* !JERRY_ESNEXT */
    #####: 1052:        const uint16_t is_unmapped = SCANNER_LITERAL_POOL_IS_STRICT;
        -: 1053:#endif /* JERRY_ESNEXT */
        -: 1054:
    #####: 1055:        if (!(status_flags & is_unmapped))
        -: 1056:        {
    #####: 1057:          mapped_arguments = true;
        -: 1058:        }
        -: 1059:
    #####: 1060:        if (arguments_type == SCANNER_ARGUMENTS_PRESENT_NO_REG)
        -: 1061:        {
    #####: 1062:          arguments_stream_type |= SCANNER_STREAM_NO_REG;
        -: 1063:        }
        -: 1064:
    #####: 1065:        if (last_argument_p == NULL)
        -: 1066:        {
    #####: 1067:          *data_p++ = arguments_stream_type;
        -: 1068:        }
        -: 1069:      }
        -: 1070:      else
        -: 1071:      {
        5: 1072:        last_argument_p = NULL;
        -: 1073:      }
        -: 1074:
        -: 1075:#if JERRY_ESNEXT
        5: 1076:      if (status_flags & (SCANNER_LITERAL_POOL_HAS_COMPLEX_ARGUMENT | SCANNER_LITERAL_POOL_ARROW))
        -: 1077:      {
    #####: 1078:        u8_arg |= SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1079:      }
        -: 1080:
        5: 1081:      if (status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -: 1082:      {
    #####: 1083:        u8_arg |= SCANNER_FUNCTION_ASYNC;
        -: 1084:
    #####: 1085:        if (status_flags & SCANNER_LITERAL_POOL_FUNCTION_STATEMENT)
        -: 1086:        {
    #####: 1087:          u8_arg |= SCANNER_FUNCTION_STATEMENT;
        -: 1088:        }
        -: 1089:      }
        -: 1090:
        5: 1091:      if (status_flags & SCANNER_LITERAL_POOL_CAN_EVAL)
        -: 1092:      {
        1: 1093:        u8_arg |= SCANNER_FUNCTION_LEXICAL_ENV_NEEDED;
        -: 1094:      }
        -: 1095:
        5: 1096:      if (status_flags & SCANNER_LITERAL_POOL_IS_STRICT)
        -: 1097:      {
    #####: 1098:        u8_arg |= SCANNER_FUNCTION_IS_STRICT;
        -: 1099:      }
        -: 1100:#endif /* JERRY_ESNEXT */
        -: 1101:
        5: 1102:      info_p->u8_arg = u8_arg;
        5: 1103:      info_p->u16_arg = (uint16_t) no_declarations;
        -: 1104:    }
        -: 1105:    else
        -: 1106:    {
    #####: 1107:      info_p->type = SCANNER_TYPE_BLOCK;
        -: 1108:
    #####: 1109:      JERRY_ASSERT (prev_literal_pool_p != NULL);
        -: 1110:    }
        -: 1111:
        5: 1112:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        5: 1113:    prev_source_p = literal_pool_p->source_p - 1;
        5: 1114:    no_declarations = literal_pool_p->no_declarations;
        -: 1115:
       21: 1116:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1117:    {
       11: 1118:      if (JERRY_UNLIKELY (no_declarations > PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK)
       11: 1119:          || (!(literal_p->type & SCANNER_LITERAL_IS_LOCAL)
        6: 1120:              && (!(literal_p->type & (SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_ARG))
        1: 1121:                  || !(status_flags & SCANNER_LITERAL_POOL_FUNCTION))))
        -: 1122:      {
        5: 1123:        continue;
        -: 1124:      }
        -: 1125:
        6: 1126:      if (literal_p->length == 0)
        -: 1127:      {
    #####: 1128:        *data_p++ = SCANNER_STREAM_TYPE_HOLE;
        -: 1129:
    #####: 1130:        if (literal_p == last_argument_p)
        -: 1131:        {
    #####: 1132:          *data_p++ = arguments_stream_type;
        -: 1133:        }
    #####: 1134:        continue;
        -: 1135:      }
        -: 1136:
        6: 1137:      no_declarations++;
        -: 1138:
        6: 1139:      uint8_t type = SCANNER_STREAM_TYPE_VAR;
        -: 1140:
        6: 1141:      if (literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1142:      {
        1: 1143:        no_declarations++;
        1: 1144:        type = SCANNER_STREAM_TYPE_FUNC;
        -: 1145:
        1: 1146:        if (literal_p->type & SCANNER_LITERAL_IS_ARG)
        -: 1147:        {
    #####: 1148:          type = SCANNER_STREAM_TYPE_ARG_FUNC;
        -: 1149:
        -: 1150:#if JERRY_ESNEXT
    #####: 1151:          if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1152:          {
    #####: 1153:            type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC;
        -: 1154:          }
        -: 1155:#endif /* JERRY_ESNEXT */
        -: 1156:        }
        -: 1157:      }
        5: 1158:      else if (literal_p->type & SCANNER_LITERAL_IS_ARG)
        -: 1159:      {
        1: 1160:        type = SCANNER_STREAM_TYPE_ARG;
        -: 1161:
        -: 1162:#if JERRY_ESNEXT
        1: 1163:        if (literal_p->type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1164:        {
    #####: 1165:          type = SCANNER_STREAM_TYPE_DESTRUCTURED_ARG;
        -: 1166:        }
        -: 1167:
        1: 1168:        if (literal_p->type & SCANNER_LITERAL_IS_VAR)
        -: 1169:        {
    #####: 1170:          type = (uint8_t) (type + 1);
        -: 1171:
    #####: 1172:          JERRY_ASSERT (type == SCANNER_STREAM_TYPE_ARG_VAR || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR);
        -: 1173:        }
        -: 1174:#endif /* JERRY_ESNEXT */
        -: 1175:      }
        -: 1176:#if JERRY_ESNEXT
        4: 1177:      else if (literal_p->type & SCANNER_LITERAL_IS_LET)
        -: 1178:      {
        4: 1179:        if (!(literal_p->type & SCANNER_LITERAL_IS_CONST))
        -: 1180:        {
        4: 1181:          type = SCANNER_STREAM_TYPE_LET;
        -: 1182:
        4: 1183:          if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))
        -: 1184:          {
        3: 1185:            literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1186:          }
        -: 1187:        }
        -: 1188:#if JERRY_MODULE_SYSTEM
    #####: 1189:        else if (prev_literal_pool_p == NULL)
        -: 1190:        {
    #####: 1191:          type = SCANNER_STREAM_TYPE_IMPORT;
        -: 1192:        }
        -: 1193:#endif /* JERRY_MODULE_SYSTEM */
        -: 1194:        else
        -: 1195:        {
    #####: 1196:          type = SCANNER_STREAM_TYPE_LOCAL;
        -: 1197:        }
        -: 1198:      }
    #####: 1199:      else if (literal_p->type & SCANNER_LITERAL_IS_CONST)
        -: 1200:      {
    #####: 1201:        type = SCANNER_STREAM_TYPE_CONST;
        -: 1202:
    #####: 1203:        if ((status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) && (literal_p->type & SCANNER_LITERAL_NO_REG))
        -: 1204:        {
    #####: 1205:          literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1206:        }
        -: 1207:      }
        -: 1208:
        6: 1209:      if (literal_p->type & SCANNER_LITERAL_EARLY_CREATE)
        -: 1210:      {
        4: 1211:        type |= SCANNER_STREAM_NO_REG | SCANNER_STREAM_EARLY_CREATE;
        -: 1212:      }
        -: 1213:#endif /* JERRY_ESNEXT */
        -: 1214:
        6: 1215:      if (literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)
        -: 1216:      {
    #####: 1217:        type |= SCANNER_STREAM_HAS_ESCAPE;
        -: 1218:      }
        -: 1219:
        6: 1220:      if ((literal_p->type & SCANNER_LITERAL_NO_REG)
        2: 1221:          || (mapped_arguments && (literal_p->type & SCANNER_LITERAL_IS_ARG)))
        -: 1222:      {
        4: 1223:        type |= SCANNER_STREAM_NO_REG;
        -: 1224:      }
        -: 1225:
        6: 1226:      data_p[0] = type;
        6: 1227:      data_p[1] = (uint8_t) literal_p->length;
        6: 1228:      data_p += 3;
        -: 1229:
        6: 1230:      intptr_t diff = (intptr_t) (literal_p->char_p - prev_source_p);
        -: 1231:
        6: 1232:      if (diff >= 1 && diff <= (intptr_t) UINT8_MAX)
        -: 1233:      {
        6: 1234:        data_p[-1] = (uint8_t) diff;
        -: 1235:      }
    #####: 1236:      else if (diff >= -(intptr_t) UINT8_MAX && diff <= (intptr_t) UINT16_MAX)
        -: 1237:      {
    #####: 1238:        if (diff < 0)
        -: 1239:        {
    #####: 1240:          diff = -diff;
        -: 1241:        }
        -: 1242:
    #####: 1243:        data_p[-3] |= SCANNER_STREAM_UINT16_DIFF;
    #####: 1244:        data_p[-1] = (uint8_t) diff;
    #####: 1245:        data_p[0] = (uint8_t) (diff >> 8);
    #####: 1246:        data_p += 1;
        -: 1247:      }
        -: 1248:      else
        -: 1249:      {
    #####: 1250:        data_p[-1] = 0;
    #####: 1251:        memcpy (data_p, &literal_p->char_p, sizeof (uintptr_t));
    #####: 1252:        data_p += sizeof (uintptr_t);
        -: 1253:      }
        -: 1254:
        6: 1255:      if (literal_p == last_argument_p)
        -: 1256:      {
    #####: 1257:        *data_p++ = arguments_stream_type;
        -: 1258:      }
        -: 1259:
        6: 1260:      prev_source_p = literal_p->char_p + literal_p->length;
        -: 1261:    }
        -: 1262:
        5: 1263:    data_p[0] = SCANNER_STREAM_TYPE_END;
        -: 1264:
        5: 1265:    JERRY_ASSERT (((uint8_t *) info_p) + compressed_size == data_p + 1);
        -: 1266:  }
        -: 1267:
        6: 1268:  if (!(status_flags & SCANNER_LITERAL_POOL_FUNCTION)
        1: 1269:      && (int32_t) prev_literal_pool_p->no_declarations < no_declarations)
        -: 1270:  {
    #####: 1271:    prev_literal_pool_p->no_declarations = (uint16_t) no_declarations;
        -: 1272:  }
        -: 1273:
        6: 1274:  if ((status_flags & SCANNER_LITERAL_POOL_FUNCTION) && prev_literal_pool_p != NULL)
        -: 1275:  {
        4: 1276:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IS_STRICT)
        -: 1277:    {
    #####: 1278:      context_p->status_flags |= PARSER_IS_STRICT;
        -: 1279:    }
        -: 1280:    else
        -: 1281:    {
        4: 1282:      context_p->status_flags &= (uint32_t) ~PARSER_IS_STRICT;
        -: 1283:    }
        -: 1284:
        -: 1285:#if JERRY_ESNEXT
        4: 1286:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_GENERATOR)
        -: 1287:    {
    #####: 1288:      context_p->status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 1289:    }
        -: 1290:    else
        -: 1291:    {
        4: 1292:      context_p->status_flags &= (uint32_t) ~PARSER_IS_GENERATOR_FUNCTION;
        -: 1293:    }
        -: 1294:
        4: 1295:    if (prev_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_ASYNC)
        -: 1296:    {
    #####: 1297:      context_p->status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -: 1298:    }
        -: 1299:    else
        -: 1300:    {
        4: 1301:      context_p->status_flags &= (uint32_t) ~PARSER_IS_ASYNC_FUNCTION;
        -: 1302:    }
        -: 1303:#endif /* JERRY_ESNEXT */
        -: 1304:  }
        -: 1305:
        6: 1306:  scanner_context_p->active_literal_pool_p = literal_pool_p->prev_p;
        -: 1307:
        6: 1308:  parser_list_free (&literal_pool_p->literal_pool);
    #####: 1309:  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 1310:} /* scanner_pop_literal_pool */
        -: 1311:
        -: 1312:#if JERRY_ESNEXT
        -: 1313:
        -: 1314:/**
        -: 1315: * Filter out the arguments from a literal pool.
        -: 1316: */
        -: 1317:void
        4: 1318:scanner_filter_arguments (parser_context_t *context_p, /**< context */
        -: 1319:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1320:{
        -: 1321:  /* Fast case: check whether all literals are arguments. */
        4: 1322:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        4: 1323:  scanner_literal_pool_t *prev_literal_pool_p = literal_pool_p->prev_p;
        4: 1324:  parser_list_iterator_t literal_iterator;
        -: 1325:  lexer_lit_location_t *literal_p;
        4: 1326:  bool can_eval = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CAN_EVAL) != 0;
        4: 1327:  bool has_arguments = (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_NO_ARGUMENTS) == 0;
        -: 1328:
        4: 1329:  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));
        -: 1330:
        4: 1331:  if (JERRY_UNLIKELY (can_eval))
        -: 1332:  {
    #####: 1333:    if (prev_literal_pool_p != NULL)
        -: 1334:    {
    #####: 1335:      prev_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1336:    }
        -: 1337:
    #####: 1338:    literal_pool_p->status_flags &= (uint16_t) ~SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1339:  }
        -: 1340:  else
        -: 1341:  {
        4: 1342:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1343:
        -: 1344:    while (true)
        1: 1345:    {
        5: 1346:      literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator);
        -: 1347:
        5: 1348:      if (literal_p == NULL)
        -: 1349:      {
        4: 1350:        return;
        -: 1351:      }
        -: 1352:
        1: 1353:      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
        -: 1354:      {
    #####: 1355:        literal_p->type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
        -: 1356:      }
        -: 1357:
        1: 1358:      uint8_t type = literal_p->type;
        1: 1359:      const uint8_t mask =
        -: 1360:        (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG);
        -: 1361:
        1: 1362:      if ((type & mask) != SCANNER_LITERAL_IS_ARG)
        -: 1363:      {
    #####: 1364:        break;
        -: 1365:      }
        -: 1366:    }
        -: 1367:  }
        -: 1368:
        -: 1369:  /* Destructured args are placed after the other arguments because of register assignments. */
    #####: 1370:  bool has_destructured_arg = false;
        -: 1371:  scanner_literal_pool_t *new_literal_pool_p;
        -: 1372:
    #####: 1373:  new_literal_pool_p = (scanner_literal_pool_t *) scanner_malloc (context_p, sizeof (scanner_literal_pool_t));
        -: 1374:
    #####: 1375:  new_literal_pool_p->prev_p = literal_pool_p;
    #####: 1376:  scanner_context_p->active_literal_pool_p = new_literal_pool_p;
        -: 1377:
    #####: 1378:  *new_literal_pool_p = *literal_pool_p;
    #####: 1379:  parser_list_init (&new_literal_pool_p->literal_pool,
        -: 1380:                    sizeof (lexer_lit_location_t),
        -: 1381:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_lit_location_t)));
        -: 1382:
    #####: 1383:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1384:
    #####: 1385:  while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1386:  {
    #####: 1387:    uint8_t type = literal_p->type;
        -: 1388:
    #####: 1389:    if (type & SCANNER_LITERAL_IS_ARG)
        -: 1390:    {
    #####: 1391:      if (can_eval || (literal_p->type & SCANNER_LITERAL_EARLY_CREATE))
        -: 1392:      {
    #####: 1393:        type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_EARLY_CREATE;
    #####: 1394:        literal_p->type = type;
        -: 1395:      }
        -: 1396:
    #####: 1397:      if (has_arguments && scanner_literal_is_arguments (literal_p))
        -: 1398:      {
    #####: 1399:        has_arguments = false;
        -: 1400:      }
        -: 1401:
    #####: 1402:      if (type & (SCANNER_LITERAL_IS_DESTRUCTURED_ARG | SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG))
        -: 1403:      {
    #####: 1404:        has_destructured_arg = true;
        -: 1405:
    #####: 1406:        if (type & SCANNER_LITERAL_IS_DESTRUCTURED_ARG)
        -: 1407:        {
    #####: 1408:          continue;
        -: 1409:        }
        -: 1410:
    #####: 1411:        type &= (uint8_t) ~SCANNER_LITERAL_IS_ARROW_DESTRUCTURED_ARG;
    #####: 1412:        type |= SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
        -: 1413:
    #####: 1414:        literal_p->type = type;
    #####: 1415:        continue;
        -: 1416:      }
        -: 1417:
        -: 1418:      lexer_lit_location_t *new_literal_p;
    #####: 1419:      new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
    #####: 1420:      *new_literal_p = *literal_p;
        -: 1421:    }
    #####: 1422:    else if (has_arguments && scanner_literal_is_arguments (literal_p))
        -: 1423:    {
        -: 1424:      /* Arguments object is directly referenced from the function arguments */
    #####: 1425:      new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS;
        -: 1426:
    #####: 1427:      if (type & SCANNER_LITERAL_NO_REG)
        -: 1428:      {
    #####: 1429:        new_literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_NO_ARGUMENTS;
        -: 1430:      }
        -: 1431:    }
    #####: 1432:    else if (prev_literal_pool_p != NULL)
        -: 1433:    {
        -: 1434:      /* Propagate literal to upper level. */
    #####: 1435:      lexer_lit_location_t *literal_location_p = scanner_add_custom_literal (context_p, prev_literal_pool_p, literal_p);
    #####: 1436:      type |= SCANNER_LITERAL_NO_REG | SCANNER_LITERAL_IS_USED;
    #####: 1437:      literal_location_p->type |= type;
        -: 1438:    }
        -: 1439:  }
        -: 1440:
    #####: 1441:  if (has_destructured_arg)
        -: 1442:  {
    #####: 1443:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1444:
    #####: 1445:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1446:    {
    #####: 1447:      const uint8_t expected_flags = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_DESTRUCTURED_ARG;
        -: 1448:
    #####: 1449:      if ((literal_p->type & expected_flags) == expected_flags)
        -: 1450:      {
        -: 1451:        lexer_lit_location_t *new_literal_p;
    #####: 1452:        new_literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &new_literal_pool_p->literal_pool);
    #####: 1453:        *new_literal_p = *literal_p;
        -: 1454:      }
        -: 1455:    }
        -: 1456:  }
        -: 1457:
    #####: 1458:  if (has_arguments)
        -: 1459:  {
        -: 1460:    /* Force the lexically stored arguments object creation */
    #####: 1461:    new_literal_pool_p->status_flags |= (SCANNER_LITERAL_POOL_ARGUMENTS_IN_ARGS | SCANNER_LITERAL_POOL_NO_ARGUMENTS);
        -: 1462:  }
        -: 1463:
    #####: 1464:  new_literal_pool_p->prev_p = prev_literal_pool_p;
        -: 1465:
    #####: 1466:  parser_list_free (&literal_pool_p->literal_pool);
    #####: 1467:  scanner_free (literal_pool_p, sizeof (scanner_literal_pool_t));
        -: 1468:} /* scanner_filter_arguments */
        -: 1469:
        -: 1470:#endif /* JERRY_ESNEXT */
        -: 1471:
        -: 1472:/**
        -: 1473: * Add any literal to the specified literal pool.
        -: 1474: *
        -: 1475: * @return pointer to the literal
        -: 1476: */
        -: 1477:lexer_lit_location_t *
       21: 1478:scanner_add_custom_literal (parser_context_t *context_p, /**< context */
        -: 1479:                            scanner_literal_pool_t *literal_pool_p, /**< literal pool */
        -: 1480:                            const lexer_lit_location_t *literal_location_p) /**< literal */
        -: 1481:{
        -: 1482:  while (true)
    #####: 1483:  {
       21: 1484:    parser_list_iterator_t literal_iterator;
       21: 1485:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1486:    lexer_lit_location_t *literal_p;
        -: 1487:
       21: 1488:    const uint8_t *char_p = literal_location_p->char_p;
       21: 1489:    prop_length_t length = literal_location_p->length;
        -: 1490:
       21: 1491:    if (JERRY_LIKELY (!(literal_location_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1492:    {
       63: 1493:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1494:      {
       31: 1495:        if (literal_p->length == length)
        -: 1496:        {
       13: 1497:          if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1498:          {
       13: 1499:            if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1500:            {
       10: 1501:              return literal_p;
        -: 1502:            }
        -: 1503:          }
    #####: 1504:          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1505:          {
        -: 1506:            /* The non-escaped version is preferred. */
    #####: 1507:            literal_p->char_p = char_p;
    #####: 1508:            literal_p->status_flags = LEXER_LIT_LOCATION_NO_OPTS;
    #####: 1509:            return literal_p;
        -: 1510:          }
        -: 1511:        }
        -: 1512:      }
        -: 1513:    }
        -: 1514:    else
        -: 1515:    {
    #####: 1516:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1517:      {
    #####: 1518:        if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))
        -: 1519:        {
    #####: 1520:          return literal_p;
        -: 1521:        }
        -: 1522:      }
        -: 1523:    }
        -: 1524:
        -: 1525:#if JERRY_ESNEXT
       11: 1526:    if (JERRY_UNLIKELY (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_CLASS_NAME))
        -: 1527:    {
    #####: 1528:      literal_pool_p = literal_pool_p->prev_p;
    #####: 1529:      continue;
        -: 1530:    }
        -: 1531:#endif /* JERRY_ESNEXT */
        -: 1532:
       11: 1533:    literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
       11: 1534:    *literal_p = *literal_location_p;
        -: 1535:
       11: 1536:    literal_p->type = 0;
        -: 1537:
       11: 1538:    return literal_p;
        -: 1539:  }
        -: 1540:} /* scanner_add_custom_literal */
        -: 1541:
        -: 1542:/**
        -: 1543: * Add the current literal token to the current literal pool.
        -: 1544: *
        -: 1545: * @return pointer to the literal
        -: 1546: */
        -: 1547:extern inline lexer_lit_location_t *JERRY_ATTR_ALWAYS_INLINE
        4: 1548:scanner_add_literal (parser_context_t *context_p, /**< context */
        -: 1549:                     scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1550:{
        6: 1551:  return scanner_add_custom_literal (context_p,
        -: 1552:                                     scanner_context_p->active_literal_pool_p,
        6: 1553:                                     &context_p->token.lit_location);
        -: 1554:} /* scanner_add_literal */
        -: 1555:
        -: 1556:/**
        -: 1557: * Add the current literal token to the current literal pool and
        -: 1558: * set SCANNER_LITERAL_NO_REG if it is inside a with statement.
        -: 1559: *
        -: 1560: * @return pointer to the literal
        -: 1561: */
        -: 1562:extern inline void JERRY_ATTR_ALWAYS_INLINE
       11: 1563:scanner_add_reference (parser_context_t *context_p, /**< context */
        -: 1564:                       scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1565:{
       11: 1566:  lexer_lit_location_t *lit_location_p =
       11: 1567:    scanner_add_custom_literal (context_p, scanner_context_p->active_literal_pool_p, &context_p->token.lit_location);
        -: 1568:#if JERRY_ESNEXT
       11: 1569:  lit_location_p->type |= SCANNER_LITERAL_IS_USED;
        -: 1570:#endif /* JERRY_ESNEXT */
        -: 1571:
       11: 1572:  if (scanner_context_p->active_literal_pool_p->status_flags & SCANNER_LITERAL_POOL_IN_WITH)
        -: 1573:  {
    #####: 1574:    lit_location_p->type |= SCANNER_LITERAL_NO_REG;
        -: 1575:  }
        -: 1576:
       11: 1577:  scanner_detect_eval_call (context_p, scanner_context_p);
       11: 1578:} /* scanner_add_reference */
        -: 1579:
        -: 1580:/**
        -: 1581: * Append an argument to the literal pool. If the argument is already present, make it a "hole".
        -: 1582: *
        -: 1583: * @return newly created literal
        -: 1584: */
        -: 1585:lexer_lit_location_t *
        1: 1586:scanner_append_argument (parser_context_t *context_p, /**< context */
        -: 1587:                         scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1588:{
        1: 1589:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        1: 1590:  parser_list_iterator_t literal_iterator;
        1: 1591:  parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        1: 1592:  lexer_lit_location_t *literal_location_p = &context_p->token.lit_location;
        -: 1593:  lexer_lit_location_t *literal_p;
        -: 1594:
        1: 1595:  const uint8_t *char_p = literal_location_p->char_p;
        1: 1596:  prop_length_t length = literal_location_p->length;
        -: 1597:
        1: 1598:  JERRY_ASSERT (SCANNER_LITERAL_POOL_MAY_HAVE_ARGUMENTS (literal_pool_p->status_flags));
        -: 1599:
        1: 1600:  if (JERRY_LIKELY (!(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1601:  {
        2: 1602:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1603:    {
    #####: 1604:      if (literal_p->length == length)
        -: 1605:      {
    #####: 1606:        if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1607:        {
    #####: 1608:          if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1609:          {
    #####: 1610:            break;
        -: 1611:          }
        -: 1612:        }
    #####: 1613:        else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1614:        {
    #####: 1615:          break;
        -: 1616:        }
        -: 1617:      }
        -: 1618:    }
        -: 1619:  }
        -: 1620:  else
        -: 1621:  {
    #####: 1622:    while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1623:    {
    #####: 1624:      if (lexer_compare_identifiers (context_p, literal_p, literal_location_p))
        -: 1625:      {
    #####: 1626:        break;
        -: 1627:      }
        -: 1628:    }
        -: 1629:  }
        -: 1630:
        1: 1631:  uint8_t literal_type = SCANNER_LITERAL_IS_ARG;
        -: 1632:
        1: 1633:  if (literal_p != NULL)
        -: 1634:  {
    #####: 1635:    literal_p->length = 0;
        -: 1636:
        -: 1637:#if JERRY_ESNEXT
    #####: 1638:    if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1639:    {
    #####: 1640:      literal_type = SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_EARLY_CREATE;
        -: 1641:    }
        -: 1642:#endif /* JERRY_ESNEXT */
        -: 1643:  }
        -: 1644:
        1: 1645:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        -: 1646:
        1: 1647:  *literal_p = context_p->token.lit_location;
        1: 1648:  literal_p->type = literal_type;
        -: 1649:
        1: 1650:  return literal_p;
        -: 1651:} /* scanner_append_argument */
        -: 1652:
        -: 1653:/**
        -: 1654: * Add private identifiers to private ident pool
        -: 1655: */
        -: 1656:void
        1: 1657:scanner_add_private_identifier (parser_context_t *context_p, /**< context  */
        -: 1658:                                scanner_private_field_flags_t opts) /**< options */
        -: 1659:{
        1: 1660:  scan_stack_modes_t stack_top = (scan_stack_modes_t) context_p->stack_top_uint8;
        1: 1661:  parser_stack_pop_uint8 (context_p);
        1: 1662:  scanner_class_info_t *class_info_p;
        1: 1663:  parser_stack_pop (context_p, &class_info_p, sizeof (scanner_class_info_t *));
        -: 1664:
        1: 1665:  scanner_class_private_member_t *iter = class_info_p->members;
        -: 1666:
        1: 1667:  scanner_private_field_flags_t search_flag =
        1: 1668:    ((opts & SCANNER_PRIVATE_FIELD_PROPERTY) ? SCANNER_PRIVATE_FIELD_PROPERTY_GETTER_SETTER
        1: 1669:                                             : (opts & SCANNER_PRIVATE_FIELD_GETTER_SETTER));
        -: 1670:
        2: 1671:  while (iter != NULL)
        -: 1672:  {
    #####: 1673:    if (lexer_compare_identifiers (context_p, &context_p->token.lit_location, &iter->loc)
    #####: 1674:        && (iter->u8_arg & search_flag))
        -: 1675:    {
    #####: 1676:      scanner_raise_error (context_p);
        -: 1677:    }
        -: 1678:
    #####: 1679:    iter = iter->prev_p;
        -: 1680:  }
        -: 1681:
        -: 1682:  scanner_class_private_member_t *p_member;
        1: 1683:  p_member = (scanner_class_private_member_t *) scanner_malloc (context_p, sizeof (scanner_class_private_member_t));
        1: 1684:  p_member->loc = context_p->token.lit_location;
        1: 1685:  p_member->u8_arg = (uint8_t) opts;
        1: 1686:  p_member->prev_p = class_info_p->members;
        1: 1687:  class_info_p->members = p_member;
        -: 1688:
        1: 1689:  parser_stack_push (context_p, &class_info_p, sizeof (scanner_class_info_t *));
        1: 1690:  parser_stack_push_uint8 (context_p, (uint8_t) stack_top);
        1: 1691:} /* scanner_add_private_identifier */
        -: 1692:
        -: 1693:/**
        -: 1694: * Check whether an eval call is performed and update the status flags accordingly.
        -: 1695: */
        -: 1696:void
       11: 1697:scanner_detect_eval_call (parser_context_t *context_p, /**< context */
        -: 1698:                          scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1699:{
       11: 1700:  if (context_p->token.keyword_type == LEXER_KEYW_EVAL && lexer_check_next_character (context_p, LIT_CHAR_LEFT_PAREN))
        -: 1701:  {
        -: 1702:#if JERRY_ESNEXT
    #####: 1703:    const uint16_t flags = (uint16_t) (SCANNER_LITERAL_POOL_CAN_EVAL | SCANNER_LITERAL_POOL_HAS_SUPER_REFERENCE);
        -: 1704:#else /* !JERRY_ESNEXT */
    #####: 1705:    const uint16_t flags = SCANNER_LITERAL_POOL_CAN_EVAL;
        -: 1706:#endif /* JERRY_ESNEXT */
        -: 1707:
    #####: 1708:    scanner_context_p->active_literal_pool_p->status_flags |= flags;
        -: 1709:  }
       11: 1710:} /* scanner_detect_eval_call */
        -: 1711:
        -: 1712:#if JERRY_ESNEXT
        -: 1713:
        -: 1714:/**
        -: 1715: * Throws an error for invalid var statements.
        -: 1716: */
        -: 1717:void
    #####: 1718:scanner_detect_invalid_var (parser_context_t *context_p, /**< context */
        -: 1719:                            scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1720:                            lexer_lit_location_t *var_literal_p) /**< var literal */
        -: 1721:{
    #####: 1722:  if (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL
    #####: 1723:      && !(var_literal_p->type & (SCANNER_LITERAL_IS_FUNC | SCANNER_LITERAL_IS_ARG))
    #####: 1724:      && (var_literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL)
        -: 1725:  {
    #####: 1726:    scanner_raise_redeclaration_error (context_p);
        -: 1727:  }
        -: 1728:
    #####: 1729:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1730:
    #####: 1731:  if (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION)
    #####: 1732:      && ((var_literal_p->type & SCANNER_LITERAL_IS_LOCAL_FUNC) == SCANNER_LITERAL_IS_LOCAL_FUNC))
        -: 1733:  {
    #####: 1734:    scanner_raise_redeclaration_error (context_p);
        -: 1735:  }
        -: 1736:
    #####: 1737:  const uint8_t *char_p = var_literal_p->char_p;
    #####: 1738:  prop_length_t length = var_literal_p->length;
        -: 1739:
    #####: 1740:  while (!(literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
        -: 1741:  {
    #####: 1742:    literal_pool_p = literal_pool_p->prev_p;
        -: 1743:
    #####: 1744:    parser_list_iterator_t literal_iterator;
    #####: 1745:    parser_list_iterator_init (&literal_pool_p->literal_pool, &literal_iterator);
        -: 1746:    lexer_lit_location_t *literal_p;
        -: 1747:
    #####: 1748:    if (JERRY_LIKELY (!(context_p->token.lit_location.status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1749:    {
    #####: 1750:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1751:      {
    #####: 1752:        if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL) && !(literal_p->type & SCANNER_LITERAL_IS_ARG)
    #####: 1753:            && !((literal_p->type & SCANNER_LITERAL_IS_FUNC)
    #####: 1754:                 && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
    #####: 1755:            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL && literal_p->length == length)
        -: 1756:        {
    #####: 1757:          if (JERRY_LIKELY (!(literal_p->status_flags & LEXER_LIT_LOCATION_HAS_ESCAPE)))
        -: 1758:          {
    #####: 1759:            if (memcmp (literal_p->char_p, char_p, length) == 0)
        -: 1760:            {
    #####: 1761:              scanner_raise_redeclaration_error (context_p);
    #####: 1762:              return;
        -: 1763:            }
        -: 1764:          }
    #####: 1765:          else if (lexer_compare_identifier_to_string (literal_p, char_p, length))
        -: 1766:          {
    #####: 1767:            scanner_raise_redeclaration_error (context_p);
    #####: 1768:            return;
        -: 1769:          }
        -: 1770:        }
        -: 1771:      }
        -: 1772:    }
        -: 1773:    else
        -: 1774:    {
    #####: 1775:      while ((literal_p = (lexer_lit_location_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1776:      {
    #####: 1777:        if ((literal_p->type & SCANNER_LITERAL_IS_LOCAL) && !(literal_p->type & SCANNER_LITERAL_IS_ARG)
    #####: 1778:            && !((literal_p->type & SCANNER_LITERAL_IS_FUNC)
    #####: 1779:                 && (literal_pool_p->status_flags & SCANNER_LITERAL_POOL_FUNCTION))
    #####: 1780:            && (literal_p->type & SCANNER_LITERAL_IS_LOCAL) != SCANNER_LITERAL_IS_LOCAL
    #####: 1781:            && lexer_compare_identifiers (context_p, literal_p, var_literal_p))
        -: 1782:        {
    #####: 1783:          scanner_raise_redeclaration_error (context_p);
    #####: 1784:          return;
        -: 1785:        }
        -: 1786:      }
        -: 1787:    }
        -: 1788:  }
        -: 1789:
    #####: 1790:  if (scanner_scope_find_lexical_declaration (context_p, var_literal_p))
        -: 1791:  {
    #####: 1792:    scanner_raise_redeclaration_error (context_p);
        -: 1793:  }
        -: 1794:} /* scanner_detect_invalid_var */
        -: 1795:
        -: 1796:/**
        -: 1797: * Throws an error for invalid let statements.
        -: 1798: */
        -: 1799:void
        4: 1800:scanner_detect_invalid_let (parser_context_t *context_p, /**< context */
        -: 1801:                            lexer_lit_location_t *let_literal_p) /**< let literal */
        -: 1802:{
        4: 1803:  if (let_literal_p->type & (SCANNER_LITERAL_IS_ARG | SCANNER_LITERAL_IS_VAR | SCANNER_LITERAL_IS_LOCAL))
        -: 1804:  {
    #####: 1805:    scanner_raise_redeclaration_error (context_p);
        -: 1806:  }
        -: 1807:
        4: 1808:  if (let_literal_p->type & SCANNER_LITERAL_IS_FUNC)
        -: 1809:  {
    #####: 1810:    let_literal_p->type &= (uint8_t) ~SCANNER_LITERAL_IS_FUNC;
        -: 1811:  }
        4: 1812:} /* scanner_detect_invalid_let */
        -: 1813:
        -: 1814:/**
        -: 1815: * Push the values required for class declaration parsing.
        -: 1816: *
        -: 1817: * @return literal reference created for class statements, NULL otherwise
        -: 1818: */
        -: 1819:lexer_lit_location_t *
        1: 1820:scanner_push_class_declaration (parser_context_t *context_p, /**< context */
        -: 1821:                                scanner_context_t *scanner_context_p, /* scanner context */
        -: 1822:                                uint8_t stack_mode) /**< stack mode */
        -: 1823:{
        1: 1824:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_CLASS);
        -: 1825:
        1: 1826:  const uint8_t *source_p = context_p->source_p;
        1: 1827:  lexer_lit_location_t *literal_p = NULL;
        -: 1828:
        -: 1829:#if JERRY_MODULE_SYSTEM
        1: 1830:  bool is_export_default = context_p->stack_top_uint8 == SCAN_STACK_EXPORT_DEFAULT;
        1: 1831:  JERRY_ASSERT (!is_export_default || stack_mode == SCAN_STACK_CLASS_EXPRESSION);
        -: 1832:#endif /* JERRY_MODULE_SYSTEM */
        -: 1833:
        1: 1834:  parser_stack_push_uint8 (context_p, stack_mode);
        1: 1835:  lexer_next_token (context_p);
        -: 1836:
        1: 1837:  bool class_has_name =
        1: 1838:    (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
        -: 1839:
        1: 1840:  if (class_has_name)
        -: 1841:  {
        1: 1842:    literal_p = scanner_add_literal (context_p, scanner_context_p);
        1: 1843:    scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1844:
        -: 1845:#if JERRY_MODULE_SYSTEM
        1: 1846:    if (is_export_default)
        -: 1847:    {
    #####: 1848:      scanner_detect_invalid_let (context_p, literal_p);
        -: 1849:
    #####: 1850:      if (literal_p->type & SCANNER_LITERAL_IS_USED)
        -: 1851:      {
    #####: 1852:        literal_p->type |= SCANNER_LITERAL_EARLY_CREATE;
        -: 1853:      }
        -: 1854:
    #####: 1855:      literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;
        -: 1856:    }
        -: 1857:#endif /* JERRY_MODULE_SYSTEM */
        -: 1858:  }
        -: 1859:
        1: 1860:  scanner_literal_pool_t *literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, 0);
        -: 1861:
        1: 1862:  if (class_has_name)
        -: 1863:  {
    #####: 1864:    scanner_add_literal (context_p, scanner_context_p);
        1: 1865:    scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1866:  }
        -: 1867:#if JERRY_MODULE_SYSTEM
    #####: 1868:  else if (is_export_default)
        -: 1869:  {
        -: 1870:    lexer_lit_location_t *name_literal_p;
    #####: 1871:    name_literal_p =
    #####: 1872:      scanner_add_custom_literal (context_p, scanner_context_p->active_literal_pool_p->prev_p, &lexer_default_literal);
        -: 1873:
    #####: 1874:    name_literal_p->type |= SCANNER_LITERAL_IS_LET | SCANNER_LITERAL_NO_REG;
    #####: 1875:    scanner_context_p->active_literal_pool_p->no_declarations++;
        -: 1876:  }
        -: 1877:#endif /* JERRY_MODULE_SYSTEM */
        -: 1878:
        1: 1879:  literal_pool_p->source_p = source_p;
        1: 1880:  literal_pool_p->status_flags |= SCANNER_LITERAL_POOL_CLASS_NAME;
        -: 1881:
        1: 1882:  const uint8_t *class_source_p = scanner_context_p->active_literal_pool_p->source_p;
        2: 1883:  scanner_class_info_t *class_info_p =
        1: 1884:    (scanner_class_info_t *) scanner_insert_info (context_p, class_source_p, sizeof (scanner_class_info_t));
        -: 1885:
        1: 1886:  class_info_p->info.type = SCANNER_TYPE_CLASS_CONSTRUCTOR;
        1: 1887:  class_info_p->members = NULL;
        1: 1888:  class_info_p->info.u8_arg = SCANNER_CONSTRUCTOR_IMPLICIT;
        -: 1889:
        1: 1890:  parser_stack_push (context_p, &class_info_p, sizeof (scanner_class_info_t *));
        1: 1891:  parser_stack_push_uint8 (context_p, SCAN_STACK_IMPLICIT_CLASS_CONSTRUCTOR);
        1: 1892:  scanner_context_p->mode = SCAN_MODE_CLASS_DECLARATION;
        -: 1893:
        1: 1894:  return literal_p;
        -: 1895:} /* scanner_push_class_declaration */
        -: 1896:
        -: 1897:/**
        -: 1898: * Push the start of a class field initializer.
        -: 1899: */
        -: 1900:void
    #####: 1901:scanner_push_class_field_initializer (parser_context_t *context_p, /**< context */
        -: 1902:                                      scanner_context_t *scanner_context_p) /* scanner context */
        -: 1903:{
    #####: 1904:  scanner_source_start_t source_start;
    #####: 1905:  source_start.source_p = context_p->source_p;
        -: 1906:
    #####: 1907:  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
    #####: 1908:  parser_stack_push_uint8 (context_p, SCAN_STACK_CLASS_FIELD_INITIALIZER);
        -: 1909:
        -: 1910:  scanner_literal_pool_t *literal_pool_p;
    #####: 1911:  literal_pool_p = scanner_push_literal_pool (context_p, scanner_context_p, SCANNER_LITERAL_POOL_CLASS_FIELD);
    #####: 1912:  literal_pool_p->source_p = context_p->source_p;
        -: 1913:
    #####: 1914:  scanner_context_p->mode = SCAN_MODE_PRIMARY_EXPRESSION;
    #####: 1915:} /* scanner_push_class_field_initializer */
        -: 1916:
        -: 1917:/**
        -: 1918: * Push the values required for destructuring assignment or binding parsing.
        -: 1919: */
        -: 1920:void
        1: 1921:scanner_push_destructuring_pattern (parser_context_t *context_p, /**< context */
        -: 1922:                                    scanner_context_t *scanner_context_p, /**< scanner context */
        -: 1923:                                    uint8_t binding_type, /**< type of destructuring binding pattern */
        -: 1924:                                    bool is_nested) /**< nested declaration */
        -: 1925:{
        1: 1926:  JERRY_ASSERT (binding_type != SCANNER_BINDING_NONE || !is_nested);
        -: 1927:
        1: 1928:  scanner_source_start_t source_start;
        1: 1929:  source_start.source_p = context_p->source_p;
        -: 1930:
        1: 1931:  parser_stack_push (context_p, &source_start, sizeof (scanner_source_start_t));
        1: 1932:  parser_stack_push_uint8 (context_p, scanner_context_p->binding_type);
        1: 1933:  scanner_context_p->binding_type = binding_type;
        -: 1934:
        1: 1935:  if (SCANNER_NEEDS_BINDING_LIST (binding_type))
        -: 1936:  {
        -: 1937:    scanner_binding_list_t *binding_list_p;
    #####: 1938:    binding_list_p = (scanner_binding_list_t *) scanner_malloc (context_p, sizeof (scanner_binding_list_t));
        -: 1939:
    #####: 1940:    binding_list_p->prev_p = scanner_context_p->active_binding_list_p;
    #####: 1941:    binding_list_p->items_p = NULL;
    #####: 1942:    binding_list_p->is_nested = is_nested;
        -: 1943:
    #####: 1944:    scanner_context_p->active_binding_list_p = binding_list_p;
        -: 1945:  }
        1: 1946:} /* scanner_push_destructuring_pattern */
        -: 1947:
        -: 1948:/**
        -: 1949: * Pop binding list.
        -: 1950: */
        -: 1951:void
    #####: 1952:scanner_pop_binding_list (scanner_context_t *scanner_context_p) /**< scanner context */
        -: 1953:{
    #####: 1954:  scanner_binding_list_t *binding_list_p = scanner_context_p->active_binding_list_p;
    #####: 1955:  JERRY_ASSERT (binding_list_p != NULL);
        -: 1956:
    #####: 1957:  scanner_binding_item_t *item_p = binding_list_p->items_p;
    #####: 1958:  scanner_binding_list_t *prev_binding_list_p = binding_list_p->prev_p;
    #####: 1959:  bool is_nested = binding_list_p->is_nested;
        -: 1960:
    #####: 1961:  scanner_free (binding_list_p, sizeof (scanner_binding_list_t));
    #####: 1962:  scanner_context_p->active_binding_list_p = prev_binding_list_p;
        -: 1963:
    #####: 1964:  if (!is_nested)
        -: 1965:  {
    #####: 1966:    while (item_p != NULL)
        -: 1967:    {
    #####: 1968:      scanner_binding_item_t *next_p = item_p->next_p;
        -: 1969:
    #####: 1970:      JERRY_ASSERT (item_p->literal_p->type & (SCANNER_LITERAL_IS_LOCAL | SCANNER_LITERAL_IS_ARG));
        -: 1971:
    #####: 1972:      scanner_free (item_p, sizeof (scanner_binding_item_t));
    #####: 1973:      item_p = next_p;
        -: 1974:    }
    #####: 1975:    return;
        -: 1976:  }
        -: 1977:
    #####: 1978:  JERRY_ASSERT (prev_binding_list_p != NULL);
        -: 1979:
    #####: 1980:  while (item_p != NULL)
        -: 1981:  {
    #####: 1982:    scanner_binding_item_t *next_p = item_p->next_p;
        -: 1983:
    #####: 1984:    item_p->next_p = prev_binding_list_p->items_p;
    #####: 1985:    prev_binding_list_p->items_p = item_p;
        -: 1986:
    #####: 1987:    item_p = next_p;
        -: 1988:  }
        -: 1989:} /* scanner_pop_binding_list */
        -: 1990:
        -: 1991:/**
        -: 1992: * Append a hole into the literal pool.
        -: 1993: */
        -: 1994:void
    #####: 1995:scanner_append_hole (parser_context_t *context_p, scanner_context_t *scanner_context_p)
        -: 1996:{
    #####: 1997:  scanner_literal_pool_t *literal_pool_p = scanner_context_p->active_literal_pool_p;
        -: 1998:
        -: 1999:  lexer_lit_location_t *literal_p;
    #####: 2000:  literal_p = (lexer_lit_location_t *) parser_list_append (context_p, &literal_pool_p->literal_pool);
        -: 2001:
    #####: 2002:  literal_p->char_p = NULL;
    #####: 2003:  literal_p->length = 0;
    #####: 2004:  literal_p->type = SCANNER_LITERAL_IS_ARG;
    #####: 2005:  literal_p->status_flags = LEXER_LIT_LOCATION_NO_OPTS;
    #####: 2006:} /* scanner_append_hole */
        -: 2007:
        -: 2008:#endif /* JERRY_ESNEXT */
        -: 2009:
        -: 2010:/**
        -: 2011: * Reverse the scanner info chain after the scanning is completed.
        -: 2012: */
        -: 2013:void
        1: 2014:scanner_reverse_info_list (parser_context_t *context_p) /**< context */
        -: 2015:{
        1: 2016:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        1: 2017:  scanner_info_t *last_scanner_info_p = NULL;
        -: 2018:
        1: 2019:  if (scanner_info_p->type == SCANNER_TYPE_END)
        -: 2020:  {
    #####: 2021:    return;
        -: 2022:  }
        -: 2023:
        -: 2024:  do
        -: 2025:  {
        6: 2026:    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;
        6: 2027:    scanner_info_p->next_p = last_scanner_info_p;
        -: 2028:
        6: 2029:    last_scanner_info_p = scanner_info_p;
        6: 2030:    scanner_info_p = next_scanner_info_p;
        6: 2031:  } while (scanner_info_p->type != SCANNER_TYPE_END);
        -: 2032:
        1: 2033:  context_p->next_scanner_info_p->next_p = scanner_info_p;
        1: 2034:  context_p->next_scanner_info_p = last_scanner_info_p;
        -: 2035:} /* scanner_reverse_info_list */
        -: 2036:
        -: 2037:/**
        -: 2038: * Release unused scanner info blocks.
        -: 2039: * This should happen only if an error is occurred.
        -: 2040: */
        -: 2041:void
    #####: 2042:scanner_cleanup (parser_context_t *context_p) /**< context */
        -: 2043:{
    #####: 2044:  if (context_p->skipped_scanner_info_p != NULL)
        -: 2045:  {
    #####: 2046:    context_p->skipped_scanner_info_end_p->next_p = context_p->next_scanner_info_p;
    #####: 2047:    context_p->next_scanner_info_p = context_p->skipped_scanner_info_p;
    #####: 2048:    context_p->skipped_scanner_info_p = NULL;
        -: 2049:  }
        -: 2050:
    #####: 2051:  scanner_info_t *scanner_info_p = context_p->next_scanner_info_p;
        -: 2052:
    #####: 2053:  while (scanner_info_p != NULL)
        -: 2054:  {
    #####: 2055:    scanner_info_t *next_scanner_info_p = scanner_info_p->next_p;
        -: 2056:
    #####: 2057:    size_t size = sizeof (scanner_info_t);
        -: 2058:
    #####: 2059:    switch (scanner_info_p->type)
        -: 2060:    {
    #####: 2061:      case SCANNER_TYPE_END:
        -: 2062:      {
    #####: 2063:        scanner_info_p = context_p->active_scanner_info_p;
    #####: 2064:        continue;
        -: 2065:      }
    #####: 2066:      case SCANNER_TYPE_FUNCTION:
        -: 2067:      case SCANNER_TYPE_BLOCK:
        -: 2068:      {
    #####: 2069:        size = scanner_get_stream_size (scanner_info_p, sizeof (scanner_info_t));
    #####: 2070:        break;
        -: 2071:      }
    #####: 2072:      case SCANNER_TYPE_WHILE:
        -: 2073:      case SCANNER_TYPE_FOR_IN:
        -: 2074:#if JERRY_ESNEXT
        -: 2075:      case SCANNER_TYPE_FOR_OF:
        -: 2076:#endif /* JERRY_ESNEXT */
        -: 2077:      case SCANNER_TYPE_CASE:
        -: 2078:#if JERRY_ESNEXT
        -: 2079:      case SCANNER_TYPE_INITIALIZER:
        -: 2080:      case SCANNER_TYPE_CLASS_FIELD_INITIALIZER_END:
        -: 2081:      case SCANNER_TYPE_CLASS_STATIC_BLOCK_END:
        -: 2082:#endif /* JERRY_ESNEXT */
        -: 2083:      {
    #####: 2084:        size = sizeof (scanner_location_info_t);
    #####: 2085:        break;
        -: 2086:      }
    #####: 2087:      case SCANNER_TYPE_FOR:
        -: 2088:      {
    #####: 2089:        size = sizeof (scanner_for_info_t);
    #####: 2090:        break;
        -: 2091:      }
    #####: 2092:      case SCANNER_TYPE_SWITCH:
        -: 2093:      {
    #####: 2094:        scanner_release_switch_cases (((scanner_switch_info_t *) scanner_info_p)->case_p);
    #####: 2095:        size = sizeof (scanner_switch_info_t);
    #####: 2096:        break;
        -: 2097:      }
        -: 2098:#if JERRY_ESNEXT
    #####: 2099:      case SCANNER_TYPE_CLASS_CONSTRUCTOR:
        -: 2100:      {
    #####: 2101:        scanner_release_private_fields (((scanner_class_info_t *) scanner_info_p)->members);
    #####: 2102:        size = sizeof (scanner_class_info_t);
    #####: 2103:        break;
        -: 2104:      }
        -: 2105:#endif /* JERRY_ESNEXT */
    #####: 2106:      default:
        -: 2107:      {
        -: 2108:#if JERRY_ESNEXT
    #####: 2109:        JERRY_ASSERT (
        -: 2110:          scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS || scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS
        -: 2111:          || scanner_info_p->type == SCANNER_TYPE_LET_EXPRESSION || scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED
        -: 2112:          || scanner_info_p->type == SCANNER_TYPE_ERR_ASYNC_FUNCTION
        -: 2113:          || scanner_info_p->type == SCANNER_TYPE_EXPORT_MODULE_SPECIFIER);
        -: 2114:#else /* !JERRY_ESNEXT */
        -: 2115:        JERRY_ASSERT (scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);
        -: 2116:#endif /* JERRY_ESNEXT */
    #####: 2117:        break;
        -: 2118:      }
        -: 2119:    }
        -: 2120:
    #####: 2121:    scanner_free (scanner_info_p, size);
    #####: 2122:    scanner_info_p = next_scanner_info_p;
        -: 2123:  }
        -: 2124:
    #####: 2125:  context_p->next_scanner_info_p = NULL;
    #####: 2126:  context_p->active_scanner_info_p = NULL;
    #####: 2127:} /* scanner_cleanup */
        -: 2128:
        -: 2129:/**
        -: 2130: * Checks whether a context needs to be created for a block.
        -: 2131: *
        -: 2132: * @return true - if context is needed,
        -: 2133: *         false - otherwise
        -: 2134: */
        -: 2135:bool
        1: 2136:scanner_is_context_needed (parser_context_t *context_p, /**< context */
        -: 2137:                           parser_check_context_type_t check_type) /**< context type */
        -: 2138:{
        1: 2139:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        1: 2140:  const uint8_t *data_p = (const uint8_t *) (info_p + 1);
        -: 2141:
        -: 2142:  JERRY_UNUSED (check_type);
        -: 2143:
        -: 2144:#if JERRY_ESNEXT
        1: 2145:  JERRY_ASSERT ((check_type == PARSER_CHECK_BLOCK_CONTEXT ? info_p->type == SCANNER_TYPE_BLOCK
        -: 2146:                                                          : info_p->type == SCANNER_TYPE_FUNCTION));
        -: 2147:
        1: 2148:  uint32_t scope_stack_reg_top =
        1: 2149:    (check_type != PARSER_CHECK_GLOBAL_CONTEXT ? context_p->scope_stack_reg_top : 1); /* block result */
        -: 2150:#else /* !JERRY_ESNEXT */
        -: 2151:  JERRY_ASSERT (check_type == PARSER_CHECK_BLOCK_CONTEXT);
        -: 2152:  JERRY_ASSERT (info_p->type == SCANNER_TYPE_BLOCK);
        -: 2153:
    #####: 2154:  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2155:#endif /* !JERRY_NDEBUG */
        -: 2156:
        2: 2157:  while (data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2158:  {
        1: 2159:    uint8_t data = data_p[0];
        -: 2160:
        -: 2161:#if JERRY_ESNEXT
        1: 2162:    uint32_t type = data & SCANNER_STREAM_TYPE_MASK;
        -: 2163:
        1: 2164:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))
        -: 2165:    {
    #####: 2166:      if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))
        -: 2167:      {
    #####: 2168:        data_p++;
    #####: 2169:        continue;
        -: 2170:      }
        -: 2171:
    #####: 2172:      if (JERRY_UNLIKELY (SCANNER_STREAM_TYPE_IS_ARGUMENTS (type)))
        -: 2173:      {
    #####: 2174:        if ((data & SCANNER_STREAM_NO_REG) || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2175:        {
    #####: 2176:          return true;
        -: 2177:        }
        -: 2178:
    #####: 2179:        scope_stack_reg_top++;
    #####: 2180:        data_p++;
    #####: 2181:        continue;
        -: 2182:      }
        -: 2183:    }
        -: 2184:
        -: 2185:#ifndef JERRY_NDEBUG
        1: 2186:    if (check_type == PARSER_CHECK_BLOCK_CONTEXT)
        -: 2187:    {
    #####: 2188:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_LET
        -: 2189:                    || type == SCANNER_STREAM_TYPE_CONST || type == SCANNER_STREAM_TYPE_LOCAL
        -: 2190:                    || type == SCANNER_STREAM_TYPE_FUNC);
        -: 2191:    }
        1: 2192:    else if (check_type == PARSER_CHECK_GLOBAL_CONTEXT)
        -: 2193:    {
        -: 2194:#if JERRY_MODULE_SYSTEM
        1: 2195:      const bool is_import = (type == SCANNER_STREAM_TYPE_IMPORT);
        -: 2196:#else /* !JERRY_MODULE_SYSTEM */
        -: 2197:      const bool is_import = true;
        -: 2198:#endif /* JERRY_MODULE_SYSTEM */
        -: 2199:
        -: 2200:      /* FIXME: a private declarative lexical environment should always be present
        -: 2201:       * for modules. Remove SCANNER_STREAM_TYPE_IMPORT after it is implemented. */
        1: 2202:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_LET
        -: 2203:                    || type == SCANNER_STREAM_TYPE_CONST || type == SCANNER_STREAM_TYPE_FUNC || is_import);
        -: 2204:
        -: 2205:      /* Only let/const can be stored in registers */
        1: 2206:      JERRY_ASSERT ((data & SCANNER_STREAM_NO_REG)
        -: 2207:                    || (type == SCANNER_STREAM_TYPE_FUNC && (context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL))
        -: 2208:                    || type == SCANNER_STREAM_TYPE_LET || type == SCANNER_STREAM_TYPE_CONST);
        -: 2209:    }
        -: 2210:    else
        -: 2211:    {
    #####: 2212:      JERRY_ASSERT (check_type == PARSER_CHECK_FUNCTION_CONTEXT);
        -: 2213:
    #####: 2214:      JERRY_ASSERT (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_LET
        -: 2215:                    || type == SCANNER_STREAM_TYPE_CONST || type == SCANNER_STREAM_TYPE_LOCAL
        -: 2216:                    || type == SCANNER_STREAM_TYPE_ARG || type == SCANNER_STREAM_TYPE_ARG_VAR
        -: 2217:                    || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR
        -: 2218:                    || type == SCANNER_STREAM_TYPE_ARG_FUNC || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC
        -: 2219:                    || type == SCANNER_STREAM_TYPE_FUNC);
        -: 2220:    }
        -: 2221:#endif /* !JERRY_NDEBUG */
        -: 2222:
        -: 2223:#else /* !JERRY_ESNEXT */
        -: 2224:    JERRY_ASSERT ((data & SCANNER_STREAM_TYPE_MASK) == SCANNER_STREAM_TYPE_VAR);
        -: 2225:#endif /* JERRY_ESNEXT */
        -: 2226:
        1: 2227:    if (!(data & SCANNER_STREAM_UINT16_DIFF))
        -: 2228:    {
        1: 2229:      if (data_p[2] != 0)
        -: 2230:      {
        1: 2231:        data_p += 2 + 1;
        -: 2232:      }
        -: 2233:      else
        -: 2234:      {
    #####: 2235:        data_p += 2 + 1 + sizeof (const uint8_t *);
        -: 2236:      }
        -: 2237:    }
        -: 2238:    else
        -: 2239:    {
    #####: 2240:      data_p += 2 + 2;
        -: 2241:    }
        -: 2242:
        -: 2243:#if JERRY_ESNEXT
        -: 2244:#if JERRY_MODULE_SYSTEM
        1: 2245:    const bool is_import = (type == SCANNER_STREAM_TYPE_IMPORT);
        -: 2246:#else /* !JERRY_MODULE_SYSTEM */
        -: 2247:    const bool is_import = false;
        -: 2248:#endif /* JERRY_MODULE_SYSTEM */
        -: 2249:
        1: 2250:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_GLOBAL_CONTEXT)
        1: 2251:        && (type == SCANNER_STREAM_TYPE_VAR
        1: 2252:            || (type == SCANNER_STREAM_TYPE_FUNC && !(context_p->global_status_flags & ECMA_PARSE_EVAL)) || is_import))
        -: 2253:    {
    #####: 2254:      continue;
        -: 2255:    }
        -: 2256:
        1: 2257:    if (JERRY_UNLIKELY (check_type == PARSER_CHECK_FUNCTION_CONTEXT))
        -: 2258:    {
    #####: 2259:      if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type) || type == SCANNER_STREAM_TYPE_ARG_VAR
    #####: 2260:          || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR)
        -: 2261:      {
        -: 2262:        /* The return value is true, if the variable is stored in the lexical environment
        -: 2263:         * or all registers have already been used for function arguments. This can be
        -: 2264:         * inprecise in the latter case, but this is a very rare corner case. A more
        -: 2265:         * sophisticated check would require to decode the literal. */
    #####: 2266:        if ((data & SCANNER_STREAM_NO_REG) || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2267:        {
    #####: 2268:          return true;
        -: 2269:        }
    #####: 2270:        continue;
        -: 2271:      }
        -: 2272:
    #####: 2273:      if (SCANNER_STREAM_TYPE_IS_ARG (type))
        -: 2274:      {
    #####: 2275:        continue;
        -: 2276:      }
        -: 2277:    }
        -: 2278:#endif /* JERRY_ESNEXT */
        -: 2279:
        1: 2280:    if ((data & SCANNER_STREAM_NO_REG) || scope_stack_reg_top >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2281:    {
        1: 2282:      return true;
        -: 2283:    }
        -: 2284:
    #####: 2285:    scope_stack_reg_top++;
        -: 2286:  }
        -: 2287:
    #####: 2288:  return false;
        -: 2289:} /* scanner_is_context_needed */
        -: 2290:
        -: 2291:#if JERRY_ESNEXT
        -: 2292:
        -: 2293:/**
        -: 2294: * Try to scan/parse the ".target" part in the "new.target" expression.
        -: 2295: *
        -: 2296: * Upon exiting with "true" the current token will point to the "target"
        -: 2297: * literal.
        -: 2298: *
        -: 2299: * If the "target" literal is not after the "new." then a scanner/parser
        -: 2300: * error will be raised.
        -: 2301: *
        -: 2302: * @returns true if the ".target" part was found
        -: 2303: *          false if there is no "." after the new.
        -: 2304: */
        -: 2305:bool
        2: 2306:scanner_try_scan_new_target (parser_context_t *context_p) /**< parser/scanner context */
        -: 2307:{
        2: 2308:  JERRY_ASSERT (context_p->token.type == LEXER_KEYW_NEW);
        -: 2309:
        2: 2310:  if (lexer_check_next_character (context_p, LIT_CHAR_DOT))
        -: 2311:  {
    #####: 2312:    lexer_next_token (context_p);
    #####: 2313:    if (context_p->token.type != LEXER_DOT)
        -: 2314:    {
    #####: 2315:      parser_raise_error (context_p, PARSER_ERR_INVALID_CHARACTER);
        -: 2316:    }
        -: 2317:
    #####: 2318:    lexer_next_token (context_p);
    #####: 2319:    if (!lexer_token_is_identifier (context_p, "target", 6))
        -: 2320:    {
    #####: 2321:      parser_raise_error (context_p, PARSER_ERR_NEW_TARGET_EXPECTED);
        -: 2322:    }
        -: 2323:
    #####: 2324:    return true;
        -: 2325:  }
        2: 2326:  return false;
        -: 2327:} /* scanner_try_scan_new_target */
        -: 2328:
        -: 2329:#endif /* JERRY_ESNEXT */
        -: 2330:
        -: 2331:/**
        -: 2332: * Description of "arguments" literal string.
        -: 2333: */
        -: 2334:const lexer_lit_location_t lexer_arguments_literal = { (const uint8_t *) "arguments",
        -: 2335:                                                       9,
        -: 2336:                                                       LEXER_IDENT_LITERAL,
        -: 2337:                                                       LEXER_LIT_LOCATION_IS_ASCII };
        -: 2338:
        -: 2339:/**
        -: 2340: * Create an unused literal.
        -: 2341: */
        -: 2342:static void
        1: 2343:scanner_create_unused_literal (parser_context_t *context_p, /**< context */
        -: 2344:                               uint8_t status_flags) /**< initial status flags */
        -: 2345:{
        1: 2346:  if (JERRY_UNLIKELY (context_p->literal_count >= PARSER_MAXIMUM_NUMBER_OF_LITERALS))
        -: 2347:  {
    #####: 2348:    parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED);
        -: 2349:  }
        -: 2350:
        1: 2351:  lexer_literal_t *literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool);
        -: 2352:
        1: 2353:  literal_p->type = LEXER_UNUSED_LITERAL;
        1: 2354:  literal_p->status_flags = status_flags;
        -: 2355:
        1: 2356:  context_p->literal_count++;
        1: 2357:} /* scanner_create_unused_literal */
        -: 2358:
        -: 2359:#if JERRY_ESNEXT
        -: 2360:/**
        -: 2361: * Emit checks for redeclared bindings in the global lexical scope.
        -: 2362: */
        -: 2363:void
        1: 2364:scanner_check_variables (parser_context_t *context_p) /**< context */
        -: 2365:{
        1: 2366:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        1: 2367:  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);
        1: 2368:  lexer_lit_location_t literal;
        -: 2369:
        1: 2370:  JERRY_ASSERT (info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2371:
        1: 2372:  literal.char_p = info_p->source_p - 1;
        -: 2373:
        5: 2374:  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2375:  {
        3: 2376:    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;
        3: 2377:    const uint8_t *data_p = next_data_p;
        -: 2378:
        3: 2379:    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_HOLE && !SCANNER_STREAM_TYPE_IS_ARG (type)
        -: 2380:                  && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type));
        3: 2381:    JERRY_ASSERT (data_p[0] & SCANNER_STREAM_NO_REG);
        -: 2382:
        3: 2383:    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 2384:    {
        3: 2385:      if (data_p[2] != 0)
        -: 2386:      {
        3: 2387:        literal.char_p += data_p[2];
        3: 2388:        next_data_p += 2 + 1;
        -: 2389:      }
        -: 2390:      else
        -: 2391:      {
    #####: 2392:        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (uintptr_t));
    #####: 2393:        next_data_p += 2 + 1 + sizeof (uintptr_t);
        -: 2394:      }
        -: 2395:    }
        -: 2396:    else
        -: 2397:    {
    #####: 2398:      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 2399:
    #####: 2400:      if (diff <= (intptr_t) UINT8_MAX)
        -: 2401:      {
    #####: 2402:        diff = -diff;
        -: 2403:      }
        -: 2404:
    #####: 2405:      literal.char_p += diff;
    #####: 2406:      next_data_p += 2 + 2;
        -: 2407:    }
        -: 2408:
        3: 2409:    literal.length = data_p[1];
        3: 2410:    literal.type = LEXER_IDENT_LITERAL;
        3: 2411:    literal.status_flags =
        3: 2412:      ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2413:
        3: 2414:    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);
        3: 2415:    literal.char_p += data_p[1];
        -: 2416:
        -: 2417:#if JERRY_MODULE_SYSTEM
        3: 2418:    if (type == SCANNER_STREAM_TYPE_IMPORT)
        -: 2419:    {
    #####: 2420:      continue;
        -: 2421:    }
        -: 2422:#endif /* JERRY_MODULE_SYSTEM */
        -: 2423:
        3: 2424:    context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
        -: 2425:
        -: 2426:    uint16_t opcode;
        3: 2427:    if (type == SCANNER_STREAM_TYPE_VAR || type == SCANNER_STREAM_TYPE_FUNC)
        -: 2428:    {
    #####: 2429:      opcode = CBC_CHECK_VAR;
        -: 2430:    }
        -: 2431:    else
        -: 2432:    {
        3: 2433:      opcode = CBC_CHECK_LET;
        -: 2434:    }
        -: 2435:
        3: 2436:    parser_emit_cbc_literal (context_p, opcode, context_p->lit_object.index);
        -: 2437:  }
        -: 2438:
        1: 2439:  parser_flush_cbc (context_p);
        1: 2440:} /* scanner_check_variables */
        -: 2441:#endif /* JERRY_ESNEXT */
        -: 2442:
        -: 2443:/**
        -: 2444: * Create and/or initialize var/let/const/function/etc. variables.
        -: 2445: */
        -: 2446:void
        6: 2447:scanner_create_variables (parser_context_t *context_p, /**< context */
        -: 2448:                          uint32_t option_flags) /**< combination of scanner_create_variables_flags_t bits */
        -: 2449:{
        6: 2450:  scanner_info_t *info_p = context_p->next_scanner_info_p;
        6: 2451:  const uint8_t *next_data_p = (const uint8_t *) (info_p + 1);
        6: 2452:  uint8_t info_type = info_p->type;
        6: 2453:  uint8_t info_u8_arg = info_p->u8_arg;
        6: 2454:  lexer_lit_location_t literal;
        -: 2455:  parser_scope_stack_t *scope_stack_p;
        -: 2456:  parser_scope_stack_t *scope_stack_end_p;
        -: 2457:
        6: 2458:  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION || info_type == SCANNER_TYPE_BLOCK);
        6: 2459:  JERRY_ASSERT (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
        -: 2460:                || !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY));
        6: 2461:  JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION
        -: 2462:                || !(option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_ARGS | SCANNER_CREATE_VARS_IS_FUNCTION_BODY)));
        -: 2463:
        6: 2464:  uint32_t scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2465:
        6: 2466:  if (info_type == SCANNER_TYPE_FUNCTION && !(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))
        5: 2467:  {
        5: 2468:    JERRY_ASSERT (context_p->scope_stack_p == NULL);
        -: 2469:
        5: 2470:    size_t stack_size = info_p->u16_arg * sizeof (parser_scope_stack_t);
        5: 2471:    context_p->scope_stack_size = info_p->u16_arg;
        -: 2472:
        5: 2473:    scope_stack_p = NULL;
        -: 2474:
        5: 2475:    if (stack_size > 0)
        -: 2476:    {
        3: 2477:      scope_stack_p = (parser_scope_stack_t *) parser_malloc (context_p, stack_size);
        -: 2478:    }
        -: 2479:
        5: 2480:    context_p->scope_stack_p = scope_stack_p;
        5: 2481:    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;
        -: 2482:
        5: 2483:    if (option_flags & (SCANNER_CREATE_VARS_IS_SCRIPT | SCANNER_CREATE_VARS_IS_MODULE))
        -: 2484:    {
        1: 2485:      scope_stack_reg_top++; /* block result */
        -: 2486:    }
        -: 2487:  }
        -: 2488:  else
        -: 2489:  {
        1: 2490:    JERRY_ASSERT (context_p->scope_stack_p != NULL || context_p->scope_stack_size == 0);
        -: 2491:
        1: 2492:    scope_stack_p = context_p->scope_stack_p;
        1: 2493:    scope_stack_end_p = scope_stack_p + context_p->scope_stack_size;
        1: 2494:    scope_stack_p += context_p->scope_stack_top;
        -: 2495:  }
        -: 2496:
        6: 2497:  literal.char_p = info_p->source_p - 1;
        -: 2498:
       19: 2499:  while (next_data_p[0] != SCANNER_STREAM_TYPE_END)
        -: 2500:  {
        7: 2501:    uint32_t type = next_data_p[0] & SCANNER_STREAM_TYPE_MASK;
        7: 2502:    const uint8_t *data_p = next_data_p;
        -: 2503:
        7: 2504:    JERRY_ASSERT ((option_flags & (SCANNER_CREATE_VARS_IS_FUNCTION_BODY | SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))
        -: 2505:                  || (type != SCANNER_STREAM_TYPE_HOLE && !SCANNER_STREAM_TYPE_IS_ARG (type)
        -: 2506:                      && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type)));
        -: 2507:
        -: 2508:#if JERRY_MODULE_SYSTEM
        7: 2509:    JERRY_ASSERT (type != SCANNER_STREAM_TYPE_IMPORT || (data_p[0] & SCANNER_STREAM_NO_REG));
        -: 2510:#endif /* JERRY_MODULE_SYSTEM */
        -: 2511:
        7: 2512:    if (JERRY_UNLIKELY (type == SCANNER_STREAM_TYPE_HOLE))
        -: 2513:    {
    #####: 2514:      JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);
    #####: 2515:      next_data_p++;
        -: 2516:
    #####: 2517:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2518:      {
    #####: 2519:        continue;
        -: 2520:      }
        -: 2521:
    #####: 2522:      uint8_t mask = SCANNER_FUNCTION_ARGUMENTS_NEEDED | SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 2523:
    #####: 2524:      if (!(context_p->status_flags & PARSER_IS_STRICT) && (info_u8_arg & mask) == SCANNER_FUNCTION_ARGUMENTS_NEEDED)
        -: 2525:      {
    #####: 2526:        scanner_create_unused_literal (context_p, LEXER_FLAG_FUNCTION_ARGUMENT);
        -: 2527:      }
        -: 2528:
    #####: 2529:      if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2530:      {
    #####: 2531:        scope_stack_reg_top++;
        -: 2532:      }
    #####: 2533:      continue;
        -: 2534:    }
        -: 2535:
        7: 2536:    if (JERRY_UNLIKELY (SCANNER_STREAM_TYPE_IS_ARGUMENTS (type)))
        -: 2537:    {
    #####: 2538:      JERRY_ASSERT (info_type == SCANNER_TYPE_FUNCTION);
    #####: 2539:      next_data_p++;
        -: 2540:
    #####: 2541:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2542:      {
    #####: 2543:        continue;
        -: 2544:      }
        -: 2545:
    #####: 2546:      context_p->status_flags |= PARSER_ARGUMENTS_NEEDED;
        -: 2547:
    #####: 2548:      if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2549:      {
    #####: 2550:        JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2551:        parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2552:      }
        -: 2553:
    #####: 2554:      lexer_construct_literal_object (context_p, &lexer_arguments_literal, LEXER_NEW_IDENT_LITERAL);
    #####: 2555:      scope_stack_p->map_from = context_p->lit_object.index;
        -: 2556:
        -: 2557:      uint16_t map_to;
        -: 2558:
    #####: 2559:      if (!(data_p[0] & SCANNER_STREAM_NO_REG) && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2560:      {
    #####: 2561:        map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);
        -: 2562:
        -: 2563:#if JERRY_ESNEXT
    #####: 2564:        scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);
        -: 2565:#endif /* JERRY_ESNEXT */
        -: 2566:
    #####: 2567:        scope_stack_reg_top++;
        -: 2568:      }
        -: 2569:      else
        -: 2570:      {
    #####: 2571:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
    #####: 2572:        map_to = context_p->lit_object.index;
        -: 2573:
    #####: 2574:        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2575:
        -: 2576:#if JERRY_ESNEXT
    #####: 2577:        if (data_p[0] & SCANNER_STREAM_LOCAL_ARGUMENTS)
        -: 2578:        {
    #####: 2579:          context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2580:        }
        -: 2581:
    #####: 2582:        scope_stack_p->map_to = 0;
        -: 2583:#endif /* JERRY_ESNEXT */
        -: 2584:      }
        -: 2585:
        -: 2586:#if !JERRY_ESNEXT
    #####: 2587:      scope_stack_p->map_to = map_to;
        -: 2588:#endif /* !JERRY_ESNEXT */
    #####: 2589:      scope_stack_p++;
        -: 2590:
        -: 2591:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2592:      context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2593:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2594:
    #####: 2595:      parser_emit_cbc_ext_literal (context_p, CBC_EXT_CREATE_ARGUMENTS, map_to);
        -: 2596:
        -: 2597:#if JERRY_ESNEXT
    #####: 2598:      if (type == SCANNER_STREAM_TYPE_ARGUMENTS_FUNC)
        -: 2599:      {
    #####: 2600:        if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2601:        {
    #####: 2602:          JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2603:          parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2604:        }
        -: 2605:
    #####: 2606:        scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;
    #####: 2607:        scope_stack_p->map_to = context_p->literal_count;
    #####: 2608:        scope_stack_p++;
        -: 2609:
    #####: 2610:        scanner_create_unused_literal (context_p, 0);
        -: 2611:      }
        -: 2612:#endif /* JERRY_ESNEXT */
        -: 2613:
    #####: 2614:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS)
        -: 2615:      {
    #####: 2616:        break;
        -: 2617:      }
    #####: 2618:      continue;
        -: 2619:    }
        -: 2620:
        7: 2621:    JERRY_ASSERT (context_p->scope_stack_size != 0);
        -: 2622:
        7: 2623:    if (!(data_p[0] & SCANNER_STREAM_UINT16_DIFF))
        -: 2624:    {
        7: 2625:      if (data_p[2] != 0)
        -: 2626:      {
        7: 2627:        literal.char_p += data_p[2];
        7: 2628:        next_data_p += 2 + 1;
        -: 2629:      }
        -: 2630:      else
        -: 2631:      {
    #####: 2632:        memcpy (&literal.char_p, data_p + 2 + 1, sizeof (uintptr_t));
    #####: 2633:        next_data_p += 2 + 1 + sizeof (uintptr_t);
        -: 2634:      }
        -: 2635:    }
        -: 2636:    else
        -: 2637:    {
    #####: 2638:      int32_t diff = ((int32_t) data_p[2]) | ((int32_t) data_p[3]) << 8;
        -: 2639:
    #####: 2640:      if (diff <= (intptr_t) UINT8_MAX)
        -: 2641:      {
    #####: 2642:        diff = -diff;
        -: 2643:      }
        -: 2644:
    #####: 2645:      literal.char_p += diff;
    #####: 2646:      next_data_p += 2 + 2;
        -: 2647:    }
        -: 2648:
        7: 2649:    if (SCANNER_STREAM_TYPE_IS_ARG (type))
        -: 2650:    {
        3: 2651:      if (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY)
        -: 2652:      {
        -: 2653:#if JERRY_ESNEXT
        1: 2654:        if ((context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
    #####: 2655:            && (type == SCANNER_STREAM_TYPE_ARG_VAR || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR))
        -: 2656:        {
    #####: 2657:          literal.length = data_p[1];
    #####: 2658:          literal.type = LEXER_IDENT_LITERAL;
    #####: 2659:          literal.status_flags =
    #####: 2660:            ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2661:
        -: 2662:          /* Literal must be exists. */
    #####: 2663:          lexer_construct_literal_object (context_p, &literal, LEXER_IDENT_LITERAL);
        -: 2664:
    #####: 2665:          if (context_p->lit_object.index < PARSER_REGISTER_START)
        -: 2666:          {
    #####: 2667:            parser_emit_cbc_ext_literal_from_token (context_p, CBC_EXT_COPY_FROM_ARG);
        -: 2668:          }
        -: 2669:        }
        -: 2670:#endif /* JERRY_ESNEXT */
        -: 2671:
        1: 2672:        literal.char_p += data_p[1];
        1: 2673:        continue;
        -: 2674:      }
        -: 2675:    }
        5: 2676:    else if ((option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS) && !SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 2677:    {
        -: 2678:      /* Function arguments must come first. */
    #####: 2679:      break;
        -: 2680:    }
        -: 2681:
        6: 2682:    literal.length = data_p[1];
        6: 2683:    literal.type = LEXER_IDENT_LITERAL;
        6: 2684:    literal.status_flags =
        6: 2685:      ((data_p[0] & SCANNER_STREAM_HAS_ESCAPE) ? LEXER_LIT_LOCATION_HAS_ESCAPE : LEXER_LIT_LOCATION_NO_OPTS);
        -: 2686:
        6: 2687:    lexer_construct_literal_object (context_p, &literal, LEXER_NEW_IDENT_LITERAL);
        6: 2688:    literal.char_p += data_p[1];
        -: 2689:
        6: 2690:    if (SCANNER_STREAM_TYPE_IS_ARG_FUNC (type) && (option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_BODY))
        -: 2691:    {
    #####: 2692:      JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p + 2);
    #####: 2693:      JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);
        -: 2694:#if JERRY_ESNEXT
    #####: 2695:      JERRY_ASSERT (!(context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS));
        -: 2696:#endif /* JERRY_ESNEXT */
        -: 2697:
    #####: 2698:      parser_scope_stack_t *function_map_p = scope_stack_p - 2;
    #####: 2699:      uint16_t literal_index = context_p->lit_object.index;
        -: 2700:
    #####: 2701:      while (literal_index != function_map_p->map_from)
        -: 2702:      {
    #####: 2703:        function_map_p--;
        -: 2704:
    #####: 2705:        JERRY_ASSERT (function_map_p >= context_p->scope_stack_p);
        -: 2706:      }
        -: 2707:
    #####: 2708:      JERRY_ASSERT (function_map_p[1].map_from == PARSER_SCOPE_STACK_FUNC);
        -: 2709:
    #####: 2710:      cbc_opcode_t opcode = CBC_SET_VAR_FUNC;
        -: 2711:
        -: 2712:#if JERRY_ESNEXT
    #####: 2713:      if (JERRY_UNLIKELY (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
    #####: 2714:          && (function_map_p[0].map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0)
        -: 2715:      {
    #####: 2716:        opcode = CBC_INIT_ARG_OR_FUNC;
        -: 2717:      }
        -: 2718:#endif /* JERRY_ESNEXT */
        -: 2719:
    #####: 2720:      parser_emit_cbc_literal_value (context_p,
    #####: 2721:                                     (uint16_t) opcode,
    #####: 2722:                                     function_map_p[1].map_to,
    #####: 2723:                                     scanner_decode_map_to (function_map_p));
    #####: 2724:      continue;
        -: 2725:    }
        -: 2726:
        6: 2727:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2728:    {
    #####: 2729:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2730:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2731:    }
        -: 2732:
        6: 2733:    scope_stack_p->map_from = context_p->lit_object.index;
        -: 2734:
        -: 2735:#if JERRY_ESNEXT
        6: 2736:    if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2737:    {
        6: 2738:      if (type != SCANNER_STREAM_TYPE_LET
        -: 2739:#if JERRY_MODULE_SYSTEM
        2: 2740:          && type != SCANNER_STREAM_TYPE_IMPORT
        -: 2741:#endif /* JERRY_MODULE_SYSTEM */
        2: 2742:          && type != SCANNER_STREAM_TYPE_CONST)
        -: 2743:      {
        2: 2744:        context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_GLOBAL;
        -: 2745:      }
        -: 2746:    }
        -: 2747:#endif /* JERRY_ESNEXT */
        -: 2748:
        -: 2749:    uint16_t map_to;
        6: 2750:    uint16_t func_init_opcode = CBC_INIT_ARG_OR_FUNC;
        -: 2751:
        6: 2752:    if (!(data_p[0] & SCANNER_STREAM_NO_REG) && scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2753:    {
        2: 2754:      map_to = (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top);
        -: 2755:
        -: 2756:#if JERRY_ESNEXT
        2: 2757:      scope_stack_p->map_to = (uint16_t) (scope_stack_reg_top + 1);
        -: 2758:#else /* !JERRY_ESNEXT */
    #####: 2759:      scope_stack_p->map_to = map_to;
        -: 2760:#endif /* JERRY_ESNEXT */
        -: 2761:
        2: 2762:      scope_stack_reg_top++;
        -: 2763:#if JERRY_ESNEXT
        2: 2764:      switch (type)
        -: 2765:      {
    #####: 2766:        case SCANNER_STREAM_TYPE_CONST:
        -: 2767:        {
    #####: 2768:          scope_stack_p->map_to |= PARSER_SCOPE_STACK_IS_CONST_REG;
        -: 2769:          /* FALLTHRU */
        -: 2770:        }
        1: 2771:        case SCANNER_STREAM_TYPE_LET:
        -: 2772:        case SCANNER_STREAM_TYPE_ARG:
        -: 2773:        case SCANNER_STREAM_TYPE_ARG_VAR:
        -: 2774:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2775:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -: 2776:        case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 2777:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2778:        {
        1: 2779:          scope_stack_p->map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        1: 2780:          break;
        -: 2781:        }
        -: 2782:      }
        -: 2783:
        2: 2784:      func_init_opcode = CBC_SET_VAR_FUNC;
        -: 2785:#endif /* JERRY_ESNEXT */
        -: 2786:    }
        -: 2787:    else
        -: 2788:    {
        4: 2789:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_USED;
        4: 2790:      map_to = context_p->lit_object.index;
        -: 2791:
        -: 2792:#if JERRY_ESNEXT
        4: 2793:      uint16_t scope_stack_map_to = 0;
        -: 2794:#else /* !JERRY_ESNEXT */
    #####: 2795:      scope_stack_p->map_to = map_to;
        -: 2796:#endif /* JERRY_ESNEXT */
        -: 2797:
        4: 2798:      if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2799:      {
        4: 2800:        context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 2801:      }
        -: 2802:
        4: 2803:      switch (type)
        -: 2804:      {
        -: 2805:#if JERRY_ESNEXT
        4: 2806:        case SCANNER_STREAM_TYPE_LET:
        -: 2807:        case SCANNER_STREAM_TYPE_CONST:
        -: 2808:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG:
        -: 2809:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR:
        -: 2810:        case SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC:
        -: 2811:        {
        4: 2812:          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        -: 2813:
        4: 2814:          if (!(data_p[0] & SCANNER_STREAM_EARLY_CREATE))
        -: 2815:          {
    #####: 2816:            break;
        -: 2817:          }
        4: 2818:          scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;
        -: 2819:          /* FALLTHRU */
        -: 2820:        }
        4: 2821:        case SCANNER_STREAM_TYPE_LOCAL:
        -: 2822:#endif /* JERRY_ESNEXT */
    #####: 2823:        case SCANNER_STREAM_TYPE_VAR:
        -: 2824:        {
        -: 2825:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2826:          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2827:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2828:
        -: 2829:#if JERRY_ESNEXT
        -: 2830:          uint16_t opcode;
        -: 2831:
        4: 2832:          switch (type)
        -: 2833:          {
        4: 2834:            case SCANNER_STREAM_TYPE_LET:
        -: 2835:            {
        4: 2836:              opcode = CBC_CREATE_LET;
        4: 2837:              break;
        -: 2838:            }
    #####: 2839:            case SCANNER_STREAM_TYPE_CONST:
        -: 2840:            {
    #####: 2841:              opcode = CBC_CREATE_CONST;
    #####: 2842:              break;
        -: 2843:            }
    #####: 2844:            case SCANNER_STREAM_TYPE_VAR:
        -: 2845:            {
    #####: 2846:              opcode = CBC_CREATE_VAR;
        -: 2847:
    #####: 2848:              if (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT)
        -: 2849:              {
    #####: 2850:                opcode = CBC_CREATE_VAR_EVAL;
        -: 2851:
    #####: 2852:                if ((context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
    #####: 2853:                    && !(context_p->status_flags & PARSER_IS_STRICT))
        -: 2854:                {
    #####: 2855:                  opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_CREATE_VAR_EVAL);
        -: 2856:                }
        -: 2857:              }
    #####: 2858:              break;
        -: 2859:            }
    #####: 2860:            default:
        -: 2861:            {
    #####: 2862:              JERRY_ASSERT (type == SCANNER_STREAM_TYPE_LOCAL || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG
        -: 2863:                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_VAR
        -: 2864:                            || type == SCANNER_STREAM_TYPE_DESTRUCTURED_ARG_FUNC);
        -: 2865:
    #####: 2866:              opcode = CBC_CREATE_LOCAL;
    #####: 2867:              break;
        -: 2868:            }
        -: 2869:          }
        -: 2870:#else /* !JERRY_ESNEXT */
    #####: 2871:          uint16_t opcode = ((option_flags & SCANNER_CREATE_VARS_IS_SCRIPT) ? CBC_CREATE_VAR_EVAL : CBC_CREATE_VAR);
        -: 2872:#endif /* JERRY_ESNEXT */
        -: 2873:
        4: 2874:          parser_emit_cbc_literal (context_p, opcode, map_to);
        4: 2875:          break;
        -: 2876:        }
    #####: 2877:        case SCANNER_STREAM_TYPE_ARG:
        -: 2878:#if JERRY_ESNEXT
        -: 2879:        case SCANNER_STREAM_TYPE_ARG_VAR:
        -: 2880:#endif /* JERRY_ESNEXT */
        -: 2881:        case SCANNER_STREAM_TYPE_ARG_FUNC:
        -: 2882:        {
        -: 2883:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2884:          context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2885:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2886:
        -: 2887:#if JERRY_ESNEXT
    #####: 2888:          scope_stack_map_to |= PARSER_SCOPE_STACK_NO_FUNCTION_COPY;
        -: 2889:
        -: 2890:          /* Argument initializers of functions with simple arguments (e.g. function f(a,b,a) {}) are
        -: 2891:           * generated here. The other initializers are handled by parser_parse_function_arguments(). */
    #####: 2892:          if (!(info_u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT))
        -: 2893:          {
        -: 2894:#endif /* JERRY_ESNEXT */
    #####: 2895:            parser_emit_cbc_literal_value (context_p,
        -: 2896:                                           CBC_INIT_ARG_OR_FUNC,
    #####: 2897:                                           (uint16_t) (PARSER_REGISTER_START + scope_stack_reg_top),
        -: 2898:                                           map_to);
        -: 2899:#if JERRY_ESNEXT
        -: 2900:          }
    #####: 2901:          else if (data_p[0] & SCANNER_STREAM_EARLY_CREATE)
        -: 2902:          {
    #####: 2903:            parser_emit_cbc_literal (context_p, CBC_CREATE_LOCAL, map_to);
    #####: 2904:            scope_stack_map_to |= PARSER_SCOPE_STACK_IS_LOCAL_CREATED;
        -: 2905:          }
        -: 2906:#endif /* JERRY_ESNEXT */
        -: 2907:
    #####: 2908:          if (scope_stack_reg_top < PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 2909:          {
    #####: 2910:            scope_stack_reg_top++;
        -: 2911:          }
    #####: 2912:          break;
        -: 2913:        }
        -: 2914:      }
        -: 2915:
        -: 2916:#if JERRY_ESNEXT
        4: 2917:      scope_stack_p->map_to = scope_stack_map_to;
        -: 2918:#endif /* JERRY_ESNEXT */
        -: 2919:    }
        -: 2920:
        6: 2921:    scope_stack_p++;
        -: 2922:
        6: 2923:    if (!SCANNER_STREAM_TYPE_IS_FUNCTION (type))
        -: 2924:    {
        5: 2925:      continue;
        -: 2926:    }
        -: 2927:
        1: 2928:    if (JERRY_UNLIKELY (scope_stack_p >= scope_stack_end_p))
        -: 2929:    {
    #####: 2930:      JERRY_ASSERT (context_p->scope_stack_size == PARSER_MAXIMUM_DEPTH_OF_SCOPE_STACK);
    #####: 2931:      parser_raise_error (context_p, PARSER_ERR_SCOPE_STACK_LIMIT_REACHED);
        -: 2932:    }
        -: 2933:
        -: 2934:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2935:    context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        -: 2936:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2937:
        1: 2938:    if (!SCANNER_STREAM_TYPE_IS_ARG_FUNC (type))
        -: 2939:    {
        1: 2940:      if (func_init_opcode == CBC_INIT_ARG_OR_FUNC && (option_flags & SCANNER_CREATE_VARS_IS_SCRIPT))
        -: 2941:      {
        -: 2942:#if JERRY_ESNEXT
    #####: 2943:        literal.char_p -= data_p[1];
        -: 2944:
    #####: 2945:        if (!scanner_scope_find_lexical_declaration (context_p, &literal))
        -: 2946:        {
    #####: 2947:          func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;
        -: 2948:
    #####: 2949:          if (context_p->global_status_flags & ECMA_PARSE_FUNCTION_CONTEXT)
        -: 2950:          {
    #####: 2951:            func_init_opcode = PARSER_TO_EXT_OPCODE (CBC_EXT_CREATE_VAR_FUNC_EVAL);
        -: 2952:          }
        -: 2953:        }
    #####: 2954:        literal.char_p += data_p[1];
        -: 2955:#else /* !JERRY_ESNEXT */
    #####: 2956:        func_init_opcode = CBC_CREATE_VAR_FUNC_EVAL;
        -: 2957:#endif /* JERRY_ESNEXT */
        -: 2958:      }
        -: 2959:
        1: 2960:      parser_emit_cbc_literal_value (context_p, func_init_opcode, context_p->literal_count, map_to);
        -: 2961:    }
        -: 2962:
        1: 2963:    scope_stack_p->map_from = PARSER_SCOPE_STACK_FUNC;
        1: 2964:    scope_stack_p->map_to = context_p->literal_count;
        1: 2965:    scope_stack_p++;
        -: 2966:
        1: 2967:    scanner_create_unused_literal (context_p, 0);
        -: 2968:  }
        -: 2969:
        6: 2970:  context_p->scope_stack_top = (uint16_t) (scope_stack_p - context_p->scope_stack_p);
        6: 2971:  context_p->scope_stack_reg_top = (uint16_t) scope_stack_reg_top;
        -: 2972:
        -: 2973:#if JERRY_ESNEXT
        6: 2974:  if (info_type == SCANNER_TYPE_FUNCTION)
        -: 2975:  {
        6: 2976:    context_p->scope_stack_global_end = context_p->scope_stack_top;
        -: 2977:  }
        -: 2978:#endif /* JERRY_ESNEXT */
        -: 2979:
        6: 2980:  if (context_p->register_count < scope_stack_reg_top)
        -: 2981:  {
        3: 2982:    context_p->register_count = (uint16_t) scope_stack_reg_top;
        -: 2983:  }
        -: 2984:
        6: 2985:  if (!(option_flags & SCANNER_CREATE_VARS_IS_FUNCTION_ARGS))
        -: 2986:  {
        5: 2987:    scanner_release_next (context_p, (size_t) (next_data_p + 1 - ((const uint8_t *) info_p)));
        -: 2988:  }
        6: 2989:  parser_flush_cbc (context_p);
        6: 2990:} /* scanner_create_variables */
        -: 2991:
        -: 2992:/**
        -: 2993: * Get location from context.
        -: 2994: */
        -: 2995:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 2996:scanner_get_location (scanner_location_t *location_p, /**< location */
        -: 2997:                      parser_context_t *context_p) /**< context */
        -: 2998:{
    #####: 2999:  location_p->source_p = context_p->source_p;
    #####: 3000:  location_p->line = context_p->line;
    #####: 3001:  location_p->column = context_p->column;
    #####: 3002:} /* scanner_get_location */
        -: 3003:
        -: 3004:/**
        -: 3005: * Set context location.
        -: 3006: */
        -: 3007:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 3008:scanner_set_location (parser_context_t *context_p, /**< context */
        -: 3009:                      scanner_location_t *location_p) /**< location */
        -: 3010:{
    #####: 3011:  context_p->source_p = location_p->source_p;
    #####: 3012:  context_p->line = location_p->line;
    #####: 3013:  context_p->column = location_p->column;
    #####: 3014:} /* scanner_set_location */
        -: 3015:
        -: 3016:/**
        -: 3017: * Get the real map_to value.
        -: 3018: */
        -: 3019:extern inline uint16_t JERRY_ATTR_ALWAYS_INLINE
       30: 3020:scanner_decode_map_to (parser_scope_stack_t *stack_item_p) /**< scope stack item */
        -: 3021:{
       30: 3022:  JERRY_ASSERT (stack_item_p->map_from != PARSER_SCOPE_STACK_FUNC);
        -: 3023:
        -: 3024:#if JERRY_ESNEXT
       30: 3025:  uint16_t value = (stack_item_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK);
       30: 3026:  return (value == 0) ? stack_item_p->map_from : (uint16_t) (value + (PARSER_REGISTER_START - 1));
        -: 3027:#else /* !JERRY_ESNEXT */
    #####: 3028:  return stack_item_p->map_to;
        -: 3029:#endif /* JERRY_ESNEXT */
        -: 3030:} /* scanner_decode_map_to */
        -: 3031:
        -: 3032:#if JERRY_ESNEXT
        -: 3033:
        -: 3034:/**
        -: 3035: * Find the given literal index in the scope stack
        -: 3036: * and save it the constant literal pool if the literal is register stored
        -: 3037: *
        -: 3038: * @return given literal index - if literal corresponds to this index is not register stored
        -: 3039: *         literal index on which literal index has been mapped - otherwise
        -: 3040: */
        -: 3041:uint16_t
    #####: 3042:scanner_save_literal (parser_context_t *context_p, /**< context */
        -: 3043:                      uint16_t literal_index) /**< literal index */
        -: 3044:{
    #####: 3045:  if (literal_index >= PARSER_REGISTER_START)
        -: 3046:  {
    #####: 3047:    literal_index = (uint16_t) (literal_index - (PARSER_REGISTER_START - 1));
        -: 3048:
    #####: 3049:    parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 3050:
        -: 3051:    do
        -: 3052:    {
        -: 3053:      /* Registers must be found in the scope stack. */
    #####: 3054:      JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
    #####: 3055:      scope_stack_p--;
    #####: 3056:    } while (scope_stack_p->map_from == PARSER_SCOPE_STACK_FUNC
    #####: 3057:             || literal_index != (scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK));
        -: 3058:
    #####: 3059:    literal_index = scope_stack_p->map_from;
    #####: 3060:    PARSER_GET_LITERAL (literal_index)->status_flags |= LEXER_FLAG_USED;
        -: 3061:  }
        -: 3062:
    #####: 3063:  return literal_index;
        -: 3064:} /* scanner_save_literal */
        -: 3065:
        -: 3066:/**
        -: 3067: * Checks whether the literal is a const in the current scope.
        -: 3068: *
        -: 3069: * @return true if the literal is a const, false otherwise
        -: 3070: */
        -: 3071:bool
    #####: 3072:scanner_literal_is_const_reg (parser_context_t *context_p, /**< context */
        -: 3073:                              uint16_t literal_index) /**< literal index */
        -: 3074:{
    #####: 3075:  if (literal_index < PARSER_REGISTER_START)
        -: 3076:  {
        -: 3077:    /* Re-assignment of non-register const bindings are detected elsewhere. */
    #####: 3078:    return false;
        -: 3079:  }
        -: 3080:
    #####: 3081:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 3082:
    #####: 3083:  literal_index = (uint16_t) (literal_index - (PARSER_REGISTER_START - 1));
        -: 3084:
        -: 3085:  do
        -: 3086:  {
        -: 3087:    /* Registers must be found in the scope stack. */
    #####: 3088:    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
    #####: 3089:    scope_stack_p--;
    #####: 3090:  } while (scope_stack_p->map_from == PARSER_SCOPE_STACK_FUNC
    #####: 3091:           || literal_index != (scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK));
        -: 3092:
    #####: 3093:  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_CONST_REG) != 0;
        -: 3094:} /* scanner_literal_is_const_reg */
        -: 3095:
        -: 3096:/**
        -: 3097: * Checks whether the literal is created before.
        -: 3098: *
        -: 3099: * @return true if the literal is created before, false otherwise
        -: 3100: */
        -: 3101:bool
        4: 3102:scanner_literal_is_created (parser_context_t *context_p, /**< context */
        -: 3103:                            uint16_t literal_index) /**< literal index */
        -: 3104:{
        4: 3105:  JERRY_ASSERT (literal_index < PARSER_REGISTER_START);
        -: 3106:
        4: 3107:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 3108:
        -: 3109:  do
        -: 3110:  {
        -: 3111:    /* These literals must be found in the scope stack. */
        9: 3112:    JERRY_ASSERT (scope_stack_p > context_p->scope_stack_p);
        9: 3113:    scope_stack_p--;
        9: 3114:  } while (literal_index != scope_stack_p->map_from);
        -: 3115:
        4: 3116:  JERRY_ASSERT ((scope_stack_p->map_to & PARSER_SCOPE_STACK_REGISTER_MASK) == 0);
        -: 3117:
        4: 3118:  return (scope_stack_p->map_to & PARSER_SCOPE_STACK_IS_LOCAL_CREATED) != 0;
        -: 3119:} /* scanner_literal_is_created */
        -: 3120:
        -: 3121:/**
        -: 3122: * Checks whether the literal exists.
        -: 3123: *
        -: 3124: * @return true if the literal exists, false otherwise
        -: 3125: */
        -: 3126:bool
    #####: 3127:scanner_literal_exists (parser_context_t *context_p, /**< context */
        -: 3128:                        uint16_t literal_index) /**< literal index */
        -: 3129:{
    #####: 3130:  JERRY_ASSERT (literal_index < PARSER_REGISTER_START);
        -: 3131:
    #####: 3132:  parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top;
        -: 3133:
    #####: 3134:  while (scope_stack_p-- > context_p->scope_stack_p)
        -: 3135:  {
    #####: 3136:    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC && scanner_decode_map_to (scope_stack_p) == literal_index)
        -: 3137:    {
    #####: 3138:      return true;
        -: 3139:    }
        -: 3140:  }
        -: 3141:
    #####: 3142:  return false;
        -: 3143:} /* scanner_literal_exists */
        -: 3144:
        -: 3145:#endif /* JERRY_ESNEXT */
        -: 3146:
        -: 3147:/**
        -: 3148: * @}
        -: 3149: * @}
        -: 3150: * @}
        -: 3151: */
        -: 3152:
        -: 3153:#endif /* JERRY_PARSER */
