        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-arguments-object.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-arguments-object.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-function-object.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-globals.h"
        -:   24:#include "ecma-helpers.h"
        -:   25:#include "ecma-lex-env.h"
        -:   26:#include "ecma-objects-general.h"
        -:   27:#include "ecma-objects.h"
        -:   28:
        -:   29:#include "jrt.h"
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup ecmaargumentsobject ECMA arguments object related routines
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:/**
        -:   39: * Arguments object creation operation.
        -:   40: *
        -:   41: * See also: ECMA-262 v5, 10.6
        -:   42: *
        -:   43: * @return ecma value of arguments object
        -:   44: *         Returned value must be freed with ecma_free_value
        -:   45: */
        -:   46:ecma_value_t
    #####:   47:ecma_op_create_arguments_object (vm_frame_ctx_shared_args_t *shared_p, /**< shared context data */
        -:   48:                                 ecma_object_t *lex_env_p) /**< lexical environment the Arguments
        -:   49:                                                            *   object is created for */
        -:   50:{
    #####:   51:  ecma_object_t *func_obj_p = shared_p->header.function_object_p;
    #####:   52:  const ecma_compiled_code_t *bytecode_data_p = shared_p->header.bytecode_header_p;
        -:   53:  uint16_t formal_params_number;
        -:   54:
    #####:   55:  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:   56:  {
    #####:   57:    formal_params_number = ((cbc_uint16_arguments_t *) bytecode_data_p)->argument_end;
        -:   58:  }
        -:   59:  else
        -:   60:  {
    #####:   61:    formal_params_number = ((cbc_uint8_arguments_t *) bytecode_data_p)->argument_end;
        -:   62:  }
        -:   63:
    #####:   64:  uint32_t object_size = sizeof (ecma_unmapped_arguments_t);
    #####:   65:  uint32_t saved_arg_count = JERRY_MAX (shared_p->arg_list_len, formal_params_number);
        -:   66:
    #####:   67:  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)
        -:   68:  {
    #####:   69:    object_size = sizeof (ecma_mapped_arguments_t);
        -:   70:  }
        -:   71:
    #####:   72:  ecma_object_t *obj_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE),
    #####:   73:                                             object_size + (saved_arg_count * sizeof (ecma_value_t)),
        -:   74:                                             ECMA_OBJECT_TYPE_CLASS);
        -:   75:
    #####:   76:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) obj_p;
        -:   77:
    #####:   78:  arguments_p->header.u.cls.type = ECMA_OBJECT_CLASS_ARGUMENTS;
    #####:   79:  arguments_p->header.u.cls.u1.arguments_flags = ECMA_ARGUMENTS_OBJECT_NO_FLAGS;
    #####:   80:  arguments_p->header.u.cls.u2.formal_params_number = formal_params_number;
    #####:   81:  arguments_p->header.u.cls.u3.arguments_number = 0;
    #####:   82:  arguments_p->callee = ecma_make_object_value (func_obj_p);
        -:   83:
    #####:   84:  ecma_value_t *argv_p = (ecma_value_t *) (((uint8_t *) obj_p) + object_size);
        -:   85:
    #####:   86:  for (uint32_t i = 0; i < shared_p->arg_list_len; i++)
        -:   87:  {
    #####:   88:    argv_p[i] = ecma_copy_value_if_not_object (shared_p->arg_list_p[i]);
        -:   89:  }
        -:   90:
    #####:   91:  for (uint32_t i = shared_p->arg_list_len; i < saved_arg_count; i++)
        -:   92:  {
    #####:   93:    argv_p[i] = ECMA_VALUE_UNDEFINED;
        -:   94:  }
        -:   95:
    #####:   96:  arguments_p->header.u.cls.u3.arguments_number = shared_p->arg_list_len;
        -:   97:
    #####:   98:  if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)
        -:   99:  {
    #####:  100:    ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) obj_p;
        -:  101:
    #####:  102:    ECMA_SET_INTERNAL_VALUE_POINTER (mapped_arguments_p->lex_env, lex_env_p);
    #####:  103:    arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_MAPPED;
        -:  104:
        -:  105:#if JERRY_SNAPSHOT_EXEC
    #####:  106:    if (bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)
        -:  107:    {
    #####:  108:      arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_STATIC_BYTECODE;
    #####:  109:      mapped_arguments_p->u.byte_code_p = (ecma_compiled_code_t *) bytecode_data_p;
        -:  110:    }
        -:  111:    else
        -:  112:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  113:    {
    #####:  114:      ECMA_SET_INTERNAL_VALUE_POINTER (mapped_arguments_p->u.byte_code, bytecode_data_p);
        -:  115:    }
        -:  116:
        -:  117:    /* Static snapshots are not ref counted. */
    #####:  118:    if ((bytecode_data_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION) == 0)
        -:  119:    {
    #####:  120:      ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_data_p);
        -:  121:    }
        -:  122:
        -:  123:    ecma_value_t *formal_parameter_start_p;
    #####:  124:    formal_parameter_start_p = ecma_compiled_code_resolve_arguments_start ((ecma_compiled_code_t *) bytecode_data_p);
        -:  125:
    #####:  126:    for (uint32_t i = 0; i < formal_params_number; i++)
        -:  127:    {
        -:  128:      /* For legacy (non-strict) argument definition the trailing duplicated arguments cannot be lazy instantiated
        -:  129:         E.g: function f (a,a,a,a) {} */
    #####:  130:      if (JERRY_UNLIKELY (ecma_is_value_empty (formal_parameter_start_p[i])))
        -:  131:      {
        -:  132:        ecma_property_value_t *prop_value_p;
    #####:  133:        ecma_string_t *prop_name_p = ecma_new_ecma_string_from_uint32 (i);
        -:  134:
    #####:  135:        prop_value_p =
        -:  136:          ecma_create_named_data_property (obj_p, prop_name_p, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE, NULL);
        -:  137:
    #####:  138:        ecma_deref_ecma_string (prop_name_p);
        -:  139:
    #####:  140:        prop_value_p->value = argv_p[i];
    #####:  141:        argv_p[i] = ECMA_VALUE_EMPTY;
        -:  142:      }
        -:  143:    }
        -:  144:  }
        -:  145:
    #####:  146:  return ecma_make_object_value (obj_p);
        -:  147:} /* ecma_op_create_arguments_object */
        -:  148:
        -:  149:/**
        -:  150: * [[DefineOwnProperty]] ecma Arguments object's operation
        -:  151: *
        -:  152: * See also:
        -:  153: *          ECMA-262 v5, 8.6.2; ECMA-262 v5, Table 8
        -:  154: *          ECMA-262 v5, 10.6
        -:  155: *
        -:  156: * @return ecma value
        -:  157: *         Returned value must be freed with ecma_free_value
        -:  158: */
        -:  159:ecma_value_t
    #####:  160:ecma_op_arguments_object_define_own_property (ecma_object_t *object_p, /**< the object */
        -:  161:                                              ecma_string_t *property_name_p, /**< property name */
        -:  162:                                              const ecma_property_descriptor_t *property_desc_p) /**< property
        -:  163:                                                                                                  *   descriptor */
        -:  164:{
        -:  165:  /* 3. */
    #####:  166:  ecma_value_t ret_value = ecma_op_general_object_define_own_property (object_p, property_name_p, property_desc_p);
        -:  167:
    #####:  168:  if (ECMA_IS_VALUE_ERROR (ret_value)
    #####:  169:      || !(((ecma_extended_object_t *) object_p)->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -:  170:  {
    #####:  171:    return ret_value;
        -:  172:  }
        -:  173:
    #####:  174:  ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) object_p;
    #####:  175:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  176:
    #####:  177:  if (index >= mapped_arguments_p->unmapped.header.u.cls.u2.formal_params_number)
        -:  178:  {
    #####:  179:    return ret_value;
        -:  180:  }
        -:  181:
    #####:  182:  ecma_value_t *argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -:  183:
    #####:  184:  if (ecma_is_value_empty (argv_p[index]) || argv_p[index] == ECMA_VALUE_ARGUMENT_NO_TRACK)
        -:  185:  {
    #####:  186:    return ret_value;
        -:  187:  }
        -:  188:
    #####:  189:  if (property_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -:  190:  {
    #####:  191:    ecma_free_value_if_not_object (argv_p[index]);
    #####:  192:    argv_p[index] = ECMA_VALUE_ARGUMENT_NO_TRACK;
    #####:  193:    return ret_value;
        -:  194:  }
        -:  195:
    #####:  196:  if (property_desc_p->flags & JERRY_PROP_IS_VALUE_DEFINED)
        -:  197:  {
    #####:  198:    ecma_string_t *name_p = ecma_op_arguments_object_get_formal_parameter (mapped_arguments_p, index);
    #####:  199:    ecma_object_t *lex_env_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env);
        -:  200:
    #####:  201:    ecma_value_t completion = ecma_op_set_mutable_binding (lex_env_p, name_p, property_desc_p->value, true);
        -:  202:
    #####:  203:    JERRY_ASSERT (ecma_is_value_empty (completion));
        -:  204:  }
        -:  205:
    #####:  206:  if ((property_desc_p->flags & JERRY_PROP_IS_WRITABLE_DEFINED) && !(property_desc_p->flags & JERRY_PROP_IS_WRITABLE))
        -:  207:  {
    #####:  208:    ecma_free_value_if_not_object (argv_p[index]);
    #####:  209:    argv_p[index] = ECMA_VALUE_ARGUMENT_NO_TRACK;
        -:  210:  }
        -:  211:
    #####:  212:  return ret_value;
        -:  213:} /* ecma_op_arguments_object_define_own_property */
        -:  214:
        -:  215:/**
        -:  216: * Try to lazy instantiate the given property of a mapped/unmapped arguments object
        -:  217: *
        -:  218: * @return pointer property, if one was instantiated,
        -:  219: *         NULL - otherwise.
        -:  220: */
        -:  221:ecma_property_t *
    #####:  222:ecma_op_arguments_object_try_to_lazy_instantiate_property (ecma_object_t *object_p, /**< object */
        -:  223:                                                           ecma_string_t *property_name_p) /**< property's name */
        -:  224:{
    #####:  225:  JERRY_ASSERT (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARGUMENTS));
        -:  226:
    #####:  227:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) object_p;
    #####:  228:  ecma_value_t *argv_p = (ecma_value_t *) (arguments_p + 1);
        -:  229:  ecma_property_value_t *prop_value_p;
    #####:  230:  ecma_property_t *prop_p;
    #####:  231:  uint32_t arguments_number = arguments_p->header.u.cls.u3.arguments_number;
    #####:  232:  uint8_t flags = arguments_p->header.u.cls.u1.arguments_flags;
        -:  233:
    #####:  234:  if (flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  235:  {
    #####:  236:    argv_p = (ecma_value_t *) (((ecma_mapped_arguments_t *) object_p) + 1);
        -:  237:  }
        -:  238:
    #####:  239:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  240:
    #####:  241:  if (index != ECMA_STRING_NOT_ARRAY_INDEX)
        -:  242:  {
    #####:  243:    if (index >= arguments_number || ecma_is_value_empty (argv_p[index]))
        -:  244:    {
    #####:  245:      return NULL;
        -:  246:    }
        -:  247:
    #####:  248:    JERRY_ASSERT (argv_p[index] != ECMA_VALUE_ARGUMENT_NO_TRACK);
        -:  249:
    #####:  250:    prop_value_p = ecma_create_named_data_property (object_p,
        -:  251:                                                    property_name_p,
        -:  252:                                                    ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  253:                                                    &prop_p);
        -:  254:
        -:  255:    /* Passing the reference */
    #####:  256:    prop_value_p->value = argv_p[index];
        -:  257:
    #####:  258:    argv_p[index] = ECMA_VALUE_UNDEFINED;
    #####:  259:    return prop_p;
        -:  260:  }
        -:  261:
    #####:  262:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_LENGTH)
    #####:  263:      && !(flags & ECMA_ARGUMENTS_OBJECT_LENGTH_INITIALIZED))
        -:  264:  {
    #####:  265:    prop_value_p = ecma_create_named_data_property (object_p,
        -:  266:                                                    ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -:  267:                                                    ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_WRITABLE,
        -:  268:                                                    &prop_p);
        -:  269:
    #####:  270:    prop_value_p->value = ecma_make_uint32_value (arguments_number);
    #####:  271:    return prop_p;
        -:  272:  }
        -:  273:
    #####:  274:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_CALLEE)
    #####:  275:      && !(flags & ECMA_ARGUMENTS_OBJECT_CALLEE_INITIALIZED))
        -:  276:  {
    #####:  277:    if (flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  278:    {
    #####:  279:      prop_value_p = ecma_create_named_data_property (object_p,
        -:  280:                                                      property_name_p,
        -:  281:                                                      ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_WRITABLE,
        -:  282:                                                      &prop_p);
        -:  283:
    #####:  284:      prop_value_p->value = arguments_p->callee;
        -:  285:    }
        -:  286:    else
        -:  287:    {
    #####:  288:      ecma_object_t *thrower_p = ecma_builtin_get (ECMA_BUILTIN_ID_TYPE_ERROR_THROWER);
        -:  289:
    #####:  290:      ecma_create_named_accessor_property (object_p,
        -:  291:                                           ecma_get_magic_string (LIT_MAGIC_STRING_CALLEE),
        -:  292:                                           thrower_p,
        -:  293:                                           thrower_p,
        -:  294:                                           ECMA_PROPERTY_BUILT_IN_FIXED,
        -:  295:                                           &prop_p);
        -:  296:    }
    #####:  297:    return prop_p;
        -:  298:  }
        -:  299:
        -:  300:#if !JERRY_ESNEXT
    #####:  301:  if (property_name_p == ecma_get_magic_string (LIT_MAGIC_STRING_CALLER))
        -:  302:  {
    #####:  303:    if (arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  304:    {
        -:  305:      return NULL;
        -:  306:    }
        -:  307:
    #####:  308:    ecma_object_t *thrower_p = ecma_builtin_get (ECMA_BUILTIN_ID_TYPE_ERROR_THROWER);
        -:  309:
    #####:  310:    ecma_create_named_accessor_property (object_p,
        -:  311:                                         ecma_get_magic_string (LIT_MAGIC_STRING_CALLER),
        -:  312:                                         thrower_p,
        -:  313:                                         thrower_p,
        -:  314:                                         ECMA_PROPERTY_BUILT_IN_FIXED,
        -:  315:                                         &prop_p);
    #####:  316:    return prop_p;
        -:  317:  }
        -:  318:#else /* JERRY_ESNEXT */
    #####:  319:  if (ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_ITERATOR)
    #####:  320:      && !(flags & ECMA_ARGUMENTS_OBJECT_ITERATOR_INITIALIZED))
        -:  321:  {
    #####:  322:    prop_value_p = ecma_create_named_data_property (object_p,
        -:  323:                                                    property_name_p,
        -:  324:                                                    ECMA_PROPERTY_BUILT_IN_CONFIGURABLE_WRITABLE,
        -:  325:                                                    &prop_p);
        -:  326:
    #####:  327:    prop_value_p->value = ecma_op_object_get_by_magic_id (ecma_builtin_get (ECMA_BUILTIN_ID_INTRINSIC_OBJECT),
        -:  328:                                                          LIT_INTERNAL_MAGIC_STRING_ARRAY_PROTOTYPE_VALUES);
        -:  329:
    #####:  330:    JERRY_ASSERT (ecma_is_value_object (prop_value_p->value));
    #####:  331:    ecma_deref_object (ecma_get_object_from_value (prop_value_p->value));
    #####:  332:    return prop_p;
        -:  333:  }
        -:  334:#endif /* !JERRY_ESNEXT */
        -:  335:
    #####:  336:  return NULL;
        -:  337:} /* ecma_op_arguments_object_try_to_lazy_instantiate_property */
        -:  338:
        -:  339:/**
        -:  340: * Delete configurable properties of arguments object
        -:  341: */
        -:  342:void
    #####:  343:ecma_op_arguments_delete_built_in_property (ecma_object_t *object_p, /**< the object */
        -:  344:                                            ecma_string_t *property_name_p) /**< property name */
        -:  345:{
    #####:  346:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) object_p;
        -:  347:
    #####:  348:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_LENGTH))
        -:  349:  {
    #####:  350:    JERRY_ASSERT (!(arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_LENGTH_INITIALIZED));
        -:  351:
    #####:  352:    arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_LENGTH_INITIALIZED;
    #####:  353:    return;
        -:  354:  }
        -:  355:
    #####:  356:  if (ecma_compare_ecma_string_to_magic_id (property_name_p, LIT_MAGIC_STRING_CALLEE))
        -:  357:  {
    #####:  358:    JERRY_ASSERT (!(arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_CALLEE_INITIALIZED));
    #####:  359:    JERRY_ASSERT (arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED);
        -:  360:
    #####:  361:    arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_CALLEE_INITIALIZED;
    #####:  362:    return;
        -:  363:  }
        -:  364:
        -:  365:#if JERRY_ESNEXT
    #####:  366:  if (ecma_prop_name_is_symbol (property_name_p))
        -:  367:  {
    #####:  368:    JERRY_ASSERT (!(arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_ITERATOR_INITIALIZED));
    #####:  369:    JERRY_ASSERT (ecma_op_compare_string_to_global_symbol (property_name_p, LIT_GLOBAL_SYMBOL_ITERATOR));
        -:  370:
    #####:  371:    arguments_p->header.u.cls.u1.arguments_flags |= ECMA_ARGUMENTS_OBJECT_ITERATOR_INITIALIZED;
    #####:  372:    return;
        -:  373:  }
        -:  374:#endif /* JERRY_ESNEXT */
        -:  375:
    #####:  376:  uint32_t index = ecma_string_get_array_index (property_name_p);
        -:  377:
    #####:  378:  ecma_value_t *argv_p = (ecma_value_t *) (arguments_p + 1);
        -:  379:
    #####:  380:  if (arguments_p->header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  381:  {
    #####:  382:    argv_p = (ecma_value_t *) (((ecma_mapped_arguments_t *) object_p) + 1);
        -:  383:  }
        -:  384:
    #####:  385:  JERRY_ASSERT (argv_p[index] == ECMA_VALUE_UNDEFINED || argv_p[index] == ECMA_VALUE_ARGUMENT_NO_TRACK);
        -:  386:
    #####:  387:  argv_p[index] = ECMA_VALUE_EMPTY;
        -:  388:} /* ecma_op_arguments_delete_built_in_property */
        -:  389:
        -:  390:/**
        -:  391: * List names of an arguments object's lazy instantiated properties
        -:  392: */
        -:  393:void
    #####:  394:ecma_op_arguments_object_list_lazy_property_names (ecma_object_t *obj_p, /**< arguments object */
        -:  395:                                                   ecma_collection_t *prop_names_p, /**< prop name collection */
        -:  396:                                                   ecma_property_counter_t *prop_counter_p, /**< property counters */
        -:  397:                                                   jerry_property_filter_t filter) /**< property name filter options */
        -:  398:{
    #####:  399:  JERRY_ASSERT (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_ARGUMENTS));
        -:  400:
    #####:  401:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) obj_p;
        -:  402:
    #####:  403:  uint32_t arguments_number = arguments_p->header.u.cls.u3.arguments_number;
    #####:  404:  uint8_t flags = arguments_p->header.u.cls.u1.arguments_flags;
        -:  405:
    #####:  406:  if (!(filter & JERRY_PROPERTY_FILTER_EXCLUDE_INTEGER_INDICES))
        -:  407:  {
    #####:  408:    ecma_value_t *argv_p = (ecma_value_t *) (arguments_p + 1);
        -:  409:
    #####:  410:    if (flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  411:    {
    #####:  412:      argv_p = (ecma_value_t *) (((ecma_mapped_arguments_t *) obj_p) + 1);
        -:  413:    }
        -:  414:
    #####:  415:    for (uint32_t index = 0; index < arguments_number; index++)
        -:  416:    {
    #####:  417:      if (!ecma_is_value_empty (argv_p[index]))
        -:  418:      {
    #####:  419:        ecma_string_t *index_string_p = ecma_new_ecma_string_from_uint32 (index);
    #####:  420:        ecma_collection_push_back (prop_names_p, ecma_make_string_value (index_string_p));
    #####:  421:        prop_counter_p->array_index_named_props++;
        -:  422:      }
        -:  423:    }
        -:  424:  }
        -:  425:
    #####:  426:  if (!(filter & JERRY_PROPERTY_FILTER_EXCLUDE_STRINGS))
        -:  427:  {
    #####:  428:    if (!(flags & ECMA_ARGUMENTS_OBJECT_LENGTH_INITIALIZED))
        -:  429:    {
    #####:  430:      ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_LENGTH));
    #####:  431:      prop_counter_p->string_named_props++;
        -:  432:    }
        -:  433:
    #####:  434:    if (!(flags & ECMA_ARGUMENTS_OBJECT_CALLEE_INITIALIZED))
        -:  435:    {
    #####:  436:      ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_CALLEE));
    #####:  437:      prop_counter_p->string_named_props++;
        -:  438:    }
        -:  439:
        -:  440:#if !JERRY_ESNEXT
    #####:  441:    if (!(flags & ECMA_ARGUMENTS_OBJECT_MAPPED))
        -:  442:    {
    #####:  443:      ecma_collection_push_back (prop_names_p, ecma_make_magic_string_value (LIT_MAGIC_STRING_CALLER));
    #####:  444:      prop_counter_p->string_named_props++;
        -:  445:    }
        -:  446:#endif /* !JERRY_ESNEXT */
        -:  447:  }
        -:  448:
        -:  449:#if JERRY_ESNEXT
    #####:  450:  if (!(filter & JERRY_PROPERTY_FILTER_EXCLUDE_SYMBOLS) && !(flags & ECMA_ARGUMENTS_OBJECT_ITERATOR_INITIALIZED))
        -:  451:  {
    #####:  452:    ecma_string_t *symbol_p = ecma_op_get_global_symbol (LIT_GLOBAL_SYMBOL_ITERATOR);
    #####:  453:    ecma_collection_push_back (prop_names_p, ecma_make_symbol_value (symbol_p));
    #####:  454:    prop_counter_p->symbol_named_props++;
        -:  455:  }
        -:  456:#endif /* JERRY_ESNEXT */
    #####:  457:} /* ecma_op_arguments_object_list_lazy_property_names */
        -:  458:
        -:  459:/**
        -:  460: * Get the formal parameter name corresponding to the given property index
        -:  461: *
        -:  462: * @return pointer to the formal parameter name
        -:  463: */
        -:  464:ecma_string_t *
    #####:  465:ecma_op_arguments_object_get_formal_parameter (ecma_mapped_arguments_t *mapped_arguments_p, /**< mapped arguments
        -:  466:                                                                                             *   object */
        -:  467:                                               uint32_t index) /**< formal parameter index */
        -:  468:{
    #####:  469:  JERRY_ASSERT (mapped_arguments_p->unmapped.header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED);
    #####:  470:  JERRY_ASSERT (index < mapped_arguments_p->unmapped.header.u.cls.u2.formal_params_number);
        -:  471:
        -:  472:  ecma_compiled_code_t *byte_code_p;
        -:  473:
        -:  474:#if JERRY_SNAPSHOT_EXEC
    #####:  475:  if (mapped_arguments_p->unmapped.header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_STATIC_BYTECODE)
        -:  476:  {
    #####:  477:    byte_code_p = mapped_arguments_p->u.byte_code_p;
        -:  478:  }
        -:  479:  else
        -:  480:#endif /* JERRY_SNAPSHOT_EXEC */
        -:  481:  {
    #####:  482:    byte_code_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t, mapped_arguments_p->u.byte_code);
        -:  483:  }
        -:  484:
    #####:  485:  ecma_value_t *formal_param_names_p = ecma_compiled_code_resolve_arguments_start (byte_code_p);
        -:  486:
    #####:  487:  return ecma_get_string_from_value (formal_param_names_p[index]);
        -:  488:} /* ecma_op_arguments_object_get_formal_parameter */
        -:  489:
        -:  490:/**
        -:  491: * @}
        -:  492: * @}
        -:  493: */
