        -:    0:Source:/home/workspace/jerry-main/main-utils.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "main-utils.h"
        -:   17:
        -:   18:#include <assert.h>
        -:   19:#include <stdio.h>
        -:   20:#include <stdlib.h>
        -:   21:#include <string.h>
        -:   22:
        -:   23:#include "jerryscript-port-default.h"
        -:   24:#include "jerryscript-port.h"
        -:   25:#include "jerryscript.h"
        -:   26:
        -:   27:#include "jerryscript-ext/debugger.h"
        -:   28:#include "jerryscript-ext/handler.h"
        -:   29:#include "main-options.h"
        -:   30:
        -:   31:/**
        -:   32: * Max line size that will be printed on a Syntax Error
        -:   33: */
        -:   34:#define SYNTAX_ERROR_MAX_LINE_LENGTH 256
        -:   35:
        -:   36:/**
        -:   37: * Register a JavaScript function in the global object.
        -:   38: */
        -:   39:static void
        5:   40:main_register_global_function (const char *name_p, /**< name of the function */
        -:   41:                               jerry_external_handler_t handler_p) /**< function callback */
        -:   42:{
        5:   43:  jerry_value_t result_val = jerryx_handler_register_global (name_p, handler_p);
        5:   44:  assert (!jerry_value_is_exception (result_val));
        5:   45:  jerry_value_free (result_val);
        5:   46:} /* main_register_global_function */
        -:   47:
        -:   48:static jerry_value_t
    #####:   49:main_create_realm (const jerry_call_info_t *call_info_p, /**< call information */
        -:   50:                   const jerry_value_t args_p[], /**< function arguments */
        -:   51:                   const jerry_length_t args_cnt) /**< number of function arguments */
        -:   52:{
        -:   53:  (void) call_info_p; /* unused */
        -:   54:  (void) args_p; /* unused */
        -:   55:  (void) args_cnt; /* unused */
    #####:   56:  return jerry_realm ();
        -:   57:} /* main_create_realm */
        -:   58:
        -:   59:/**
        -:   60: * Register a method for the $262 object.
        -:   61: */
        -:   62:static void
    #####:   63:test262_register_function (jerry_value_t test262_obj, /** $262 object */
        -:   64:                           const char *name_p, /**< name of the function */
        -:   65:                           jerry_external_handler_t handler_p) /**< function callback */
        -:   66:{
    #####:   67:  jerry_value_t function_name_val = jerry_string_sz (name_p);
    #####:   68:  jerry_value_t function_val = jerry_function_external (handler_p);
        -:   69:
    #####:   70:  jerry_value_t result_val = jerry_object_set (test262_obj, function_name_val, function_val);
        -:   71:
    #####:   72:  jerry_value_free (function_val);
    #####:   73:  jerry_value_free (function_name_val);
        -:   74:
    #####:   75:  assert (!jerry_value_is_exception (result_val));
    #####:   76:  jerry_value_free (result_val);
    #####:   77:} /* test262_register_function */
        -:   78:
        -:   79:/**
        -:   80: * $262.detachArrayBuffer
        -:   81: *
        -:   82: * A function which implements the DetachArrayBuffer abstract operation
        -:   83: *
        -:   84: * @return null value - if success
        -:   85: *         value marked with error flag - otherwise
        -:   86: */
        -:   87:static jerry_value_t
    #####:   88:test262_detach_array_buffer (const jerry_call_info_t *call_info_p, /**< call information */
        -:   89:                             const jerry_value_t args_p[], /**< function arguments */
        -:   90:                             const jerry_length_t args_cnt) /**< number of function arguments */
        -:   91:{
        -:   92:  (void) call_info_p; /* unused */
        -:   93:
    #####:   94:  if (args_cnt < 1 || !jerry_value_is_arraybuffer (args_p[0]))
        -:   95:  {
    #####:   96:    return jerry_throw_sz (JERRY_ERROR_TYPE, "Expected an ArrayBuffer object");
        -:   97:  }
        -:   98:
        -:   99:  /* TODO: support the optional 'key' argument */
        -:  100:
    #####:  101:  return jerry_arraybuffer_detach (args_p[0]);
        -:  102:} /* test262_detach_array_buffer */
        -:  103:
        -:  104:/**
        -:  105: * $262.evalScript
        -:  106: *
        -:  107: * A function which accepts a string value as its first argument and executes it
        -:  108: *
        -:  109: * @return completion of the script parsing and execution.
        -:  110: */
        -:  111:static jerry_value_t
    #####:  112:test262_eval_script (const jerry_call_info_t *call_info_p, /**< call information */
        -:  113:                     const jerry_value_t args_p[], /**< function arguments */
        -:  114:                     const jerry_length_t args_cnt) /**< number of function arguments */
        -:  115:{
        -:  116:  (void) call_info_p; /* unused */
        -:  117:
    #####:  118:  if (args_cnt < 1 || !jerry_value_is_string (args_p[0]))
        -:  119:  {
    #####:  120:    return jerry_throw_sz (JERRY_ERROR_TYPE, "Expected a string");
        -:  121:  }
        -:  122:
    #####:  123:  jerry_size_t str_size = jerry_string_size (args_p[0], JERRY_ENCODING_UTF8);
    #####:  124:  jerry_char_t *str_buf_p = malloc (str_size * sizeof (jerry_char_t));
        -:  125:
    #####:  126:  if (str_buf_p == NULL)
        -:  127:  {
    #####:  128:    return jerry_throw_sz (JERRY_ERROR_RANGE, "Internal allocation error");
        -:  129:  }
        -:  130:
    #####:  131:  jerry_string_to_buffer (args_p[0], JERRY_ENCODING_UTF8, str_buf_p, str_size);
        -:  132:
    #####:  133:  jerry_value_t ret_value = jerry_parse (str_buf_p, str_size, NULL);
        -:  134:
    #####:  135:  if (!jerry_value_is_exception (ret_value))
        -:  136:  {
    #####:  137:    jerry_value_t func_val = ret_value;
    #####:  138:    ret_value = jerry_run (func_val);
    #####:  139:    jerry_value_free (func_val);
        -:  140:  }
        -:  141:
    #####:  142:  free (str_buf_p);
        -:  143:
    #####:  144:  return ret_value;
        -:  145:} /* test262_eval_script */
        -:  146:
        -:  147:static jerry_value_t create_test262 (jerry_value_t global_obj);
        -:  148:
        -:  149:/**
        -:  150: * $262.createRealm
        -:  151: *
        -:  152: * A function which creates a new realm object, and returns a newly created $262 object
        -:  153: *
        -:  154: * @return a new $262 object
        -:  155: */
        -:  156:static jerry_value_t
    #####:  157:test262_create_realm (const jerry_call_info_t *call_info_p, /**< call information */
        -:  158:                      const jerry_value_t args_p[], /**< function arguments */
        -:  159:                      const jerry_length_t args_cnt) /**< number of function arguments */
        -:  160:{
        -:  161:  (void) call_info_p; /* unused */
        -:  162:  (void) args_p; /* unused */
        -:  163:  (void) args_cnt; /* unused */
        -:  164:
    #####:  165:  jerry_value_t realm_object = jerry_realm ();
    #####:  166:  jerry_value_t previous_realm = jerry_set_realm (realm_object);
    #####:  167:  assert (!jerry_value_is_exception (previous_realm));
    #####:  168:  jerry_value_t test262_object = create_test262 (realm_object);
    #####:  169:  jerry_set_realm (previous_realm);
    #####:  170:  jerry_value_free (realm_object);
        -:  171:
    #####:  172:  return test262_object;
        -:  173:} /* test262_create_realm */
        -:  174:
        -:  175:/**
        -:  176: * Create a new $262 object
        -:  177: *
        -:  178: * @return a new $262 object
        -:  179: */
        -:  180:static jerry_value_t
    #####:  181:create_test262 (jerry_value_t global_obj) /**< global object */
        -:  182:{
    #####:  183:  jerry_value_t test262_object = jerry_object ();
        -:  184:
    #####:  185:  test262_register_function (test262_object, "detachArrayBuffer", test262_detach_array_buffer);
    #####:  186:  test262_register_function (test262_object, "evalScript", test262_eval_script);
    #####:  187:  test262_register_function (test262_object, "createRealm", test262_create_realm);
    #####:  188:  test262_register_function (test262_object, "gc", jerryx_handler_gc);
        -:  189:
    #####:  190:  jerry_value_t prop_name = jerry_string_sz ("global");
    #####:  191:  jerry_value_t result = jerry_object_set (test262_object, prop_name, global_obj);
    #####:  192:  assert (!jerry_value_is_exception (result));
        -:  193:
    #####:  194:  jerry_value_free (prop_name);
    #####:  195:  jerry_value_free (result);
        -:  196:
    #####:  197:  prop_name = jerry_string_sz ("$262");
    #####:  198:  result = jerry_object_set (global_obj, prop_name, test262_object);
    #####:  199:  assert (!jerry_value_is_exception (result));
        -:  200:
    #####:  201:  jerry_value_free (prop_name);
    #####:  202:  jerry_value_free (result);
        -:  203:
    #####:  204:  return test262_object;
        -:  205:} /* create_test262 */
        -:  206:
        -:  207:static void
    #####:  208:promise_callback (jerry_promise_event_type_t event_type, /**< event type */
        -:  209:                  const jerry_value_t object, /**< target object */
        -:  210:                  const jerry_value_t value, /**< optional argument */
        -:  211:                  void *user_p) /**< user pointer passed to the callback */
        -:  212:{
        -:  213:  (void) value; /* unused */
        -:  214:  (void) user_p; /* unused */
    #####:  215:  const jerry_size_t max_allowed_size = 5 * 1024 - 1;
        -:  216:
    #####:  217:  if (event_type != JERRY_PROMISE_EVENT_REJECT_WITHOUT_HANDLER)
        -:  218:  {
    #####:  219:    return;
        -:  220:  }
        -:  221:
    #####:  222:  jerry_value_t reason = jerry_promise_result (object);
    #####:  223:  jerry_value_t reason_to_string = jerry_value_to_string (reason);
        -:  224:
    #####:  225:  if (!jerry_value_is_exception (reason_to_string))
    #####:  226:  {
    #####:  227:    jerry_size_t buffer_size = jerry_string_size (reason_to_string, JERRY_ENCODING_UTF8);
        -:  228:
    #####:  229:    if (buffer_size > max_allowed_size)
        -:  230:    {
    #####:  231:      buffer_size = max_allowed_size;
        -:  232:    }
        -:  233:
    #####:  234:    JERRY_VLA (jerry_char_t, str_buf_p, buffer_size + 1);
    #####:  235:    jerry_string_to_buffer (reason_to_string, JERRY_ENCODING_UTF8, str_buf_p, buffer_size);
    #####:  236:    str_buf_p[buffer_size] = '\0';
        -:  237:
    #####:  238:    jerry_port_log (JERRY_LOG_LEVEL_WARNING, "Uncaught Promise rejection: %s\n", str_buf_p);
        -:  239:  }
        -:  240:  else
        -:  241:  {
    #####:  242:    jerry_port_log (JERRY_LOG_LEVEL_WARNING, "Uncaught Promise rejection (reason cannot be converted to string)\n");
        -:  243:  }
        -:  244:
    #####:  245:  jerry_value_free (reason_to_string);
    #####:  246:  jerry_value_free (reason);
        -:  247:} /* promise_callback */
        -:  248:
        -:  249:/**
        -:  250: * Inits the engine and the debugger
        -:  251: */
        -:  252:void
        1:  253:main_init_engine (main_args_t *arguments_p) /**< main arguments */
        -:  254:{
        1:  255:  jerry_init (arguments_p->init_flags);
        -:  256:
        1:  257:  jerry_promise_on_event (JERRY_PROMISE_EVENT_FILTER_ERROR, promise_callback, NULL);
        -:  258:
        1:  259:  if (arguments_p->option_flags & OPT_FLAG_DEBUG_SERVER)
        -:  260:  {
    #####:  261:    bool protocol = false;
        -:  262:
    #####:  263:    if (!strcmp (arguments_p->debug_protocol, "tcp"))
        -:  264:    {
    #####:  265:      protocol = jerryx_debugger_tcp_create (arguments_p->debug_port);
        -:  266:    }
        -:  267:    else
        -:  268:    {
    #####:  269:      assert (!strcmp (arguments_p->debug_protocol, "serial"));
    #####:  270:      protocol = jerryx_debugger_serial_create (arguments_p->debug_serial_config);
        -:  271:    }
        -:  272:
    #####:  273:    if (!strcmp (arguments_p->debug_channel, "rawpacket"))
        -:  274:    {
    #####:  275:      jerryx_debugger_after_connect (protocol && jerryx_debugger_rp_create ());
        -:  276:    }
        -:  277:    else
        -:  278:    {
    #####:  279:      assert (!strcmp (arguments_p->debug_channel, "websocket"));
    #####:  280:      jerryx_debugger_after_connect (protocol && jerryx_debugger_ws_create ());
        -:  281:    }
        -:  282:  }
        1:  283:  if (arguments_p->option_flags & OPT_FLAG_TEST262_OBJECT)
        -:  284:  {
    #####:  285:    jerry_value_t global_obj = jerry_current_realm ();
    #####:  286:    jerry_value_t test262_object = create_test262 (global_obj);
    #####:  287:    jerry_value_free (test262_object);
    #####:  288:    jerry_value_free (global_obj);
        -:  289:  }
        1:  290:  main_register_global_function ("assert", jerryx_handler_assert);
        1:  291:  main_register_global_function ("gc", jerryx_handler_gc);
        1:  292:  main_register_global_function ("print", jerryx_handler_print);
        1:  293:  main_register_global_function ("sourceName", jerryx_handler_source_name);
        1:  294:  main_register_global_function ("createRealm", main_create_realm);
        1:  295:} /* main_init_engine */
        -:  296:
        -:  297:/**
        -:  298: * Print an error value.
        -:  299: *
        -:  300: * Note: the error value will be released.
        -:  301: */
        -:  302:void
    #####:  303:main_print_unhandled_exception (jerry_value_t error_value) /**< error value */
        -:  304:{
    #####:  305:  assert (jerry_value_is_exception (error_value));
    #####:  306:  error_value = jerry_exception_value (error_value, true);
        -:  307:
    #####:  308:  jerry_char_t err_str_buf[256];
        -:  309:
    #####:  310:  jerry_value_t err_str_val = jerry_value_to_string (error_value);
        -:  311:
    #####:  312:  jerry_size_t string_end =
        -:  313:    jerry_string_to_buffer (err_str_val, JERRY_ENCODING_UTF8, err_str_buf, sizeof (err_str_buf) - 1);
    #####:  314:  err_str_buf[string_end] = '\0';
        -:  315:
    #####:  316:  if (jerry_feature_enabled (JERRY_FEATURE_ERROR_MESSAGES) && jerry_error_type (error_value) == JERRY_ERROR_SYNTAX)
        -:  317:  {
    #####:  318:    jerry_char_t *string_end_p = err_str_buf + string_end;
    #####:  319:    unsigned int err_line = 0;
    #####:  320:    unsigned int err_col = 0;
    #####:  321:    char *path_str_p = NULL;
    #####:  322:    char *path_str_end_p = NULL;
        -:  323:
        -:  324:    /* 1. parse column and line information */
    #####:  325:    for (jerry_char_t *current_p = err_str_buf; current_p < string_end_p; current_p++)
        -:  326:    {
    #####:  327:      if (*current_p == '[')
        -:  328:      {
    #####:  329:        current_p++;
        -:  330:
    #####:  331:        if (*current_p == '<')
        -:  332:        {
    #####:  333:          break;
        -:  334:        }
        -:  335:
    #####:  336:        path_str_p = (char *) current_p;
    #####:  337:        while (current_p < string_end_p && *current_p != ':')
        -:  338:        {
    #####:  339:          current_p++;
        -:  340:        }
        -:  341:
    #####:  342:        path_str_end_p = (char *) current_p++;
        -:  343:
    #####:  344:        err_line = (unsigned int) strtol ((char *) current_p, (char **) &current_p, 10);
        -:  345:
    #####:  346:        current_p++;
        -:  347:
    #####:  348:        err_col = (unsigned int) strtol ((char *) current_p, NULL, 10);
    #####:  349:        break;
        -:  350:      }
        -:  351:    } /* for */
        -:  352:
    #####:  353:    if (err_line != 0 && err_col > 0 && err_col < SYNTAX_ERROR_MAX_LINE_LENGTH)
        -:  354:    {
        -:  355:      /* Temporarily modify the error message, so we can use the path. */
    #####:  356:      *path_str_end_p = '\0';
        -:  357:
    #####:  358:      size_t source_size;
    #####:  359:      uint8_t *source_p = jerry_port_read_source (path_str_p, &source_size);
        -:  360:
        -:  361:      /* Revert the error message. */
    #####:  362:      *path_str_end_p = ':';
        -:  363:
    #####:  364:      if (source_p != NULL)
        -:  365:      {
    #####:  366:        uint32_t curr_line = 1;
    #####:  367:        uint32_t pos = 0;
        -:  368:
        -:  369:        /* 2. seek and print */
    #####:  370:        while (pos < source_size && curr_line < err_line)
        -:  371:        {
    #####:  372:          if (source_p[pos] == '\n')
        -:  373:          {
    #####:  374:            curr_line++;
        -:  375:          }
        -:  376:
    #####:  377:          pos++;
        -:  378:        }
        -:  379:
        -:  380:        /* Print character if:
        -:  381:         * - The max line length is not reached.
        -:  382:         * - The current position is valid (it is not the end of the source).
        -:  383:         * - The current character is not a newline.
        -:  384:         **/
    #####:  385:        for (uint32_t char_count = 0;
    #####:  386:             (char_count < SYNTAX_ERROR_MAX_LINE_LENGTH) && (pos < source_size) && (source_p[pos] != '\n');
    #####:  387:             char_count++, pos++)
        -:  388:        {
    #####:  389:          jerry_port_log (JERRY_LOG_LEVEL_ERROR, "%c", source_p[pos]);
        -:  390:        }
    #####:  391:        jerry_port_log (JERRY_LOG_LEVEL_ERROR, "\n");
        -:  392:
    #####:  393:        jerry_port_release_source (source_p);
        -:  394:
    #####:  395:        while (--err_col)
        -:  396:        {
    #####:  397:          jerry_port_log (JERRY_LOG_LEVEL_ERROR, "~");
        -:  398:        }
        -:  399:
    #####:  400:        jerry_port_log (JERRY_LOG_LEVEL_ERROR, "^\n\n");
        -:  401:      }
        -:  402:    }
        -:  403:  }
        -:  404:
    #####:  405:  jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Unhandled exception: %s\n", err_str_buf);
    #####:  406:  jerry_value_free (err_str_val);
        -:  407:
    #####:  408:  if (jerry_value_is_object (error_value))
        -:  409:  {
    #####:  410:    jerry_value_t stack_str = jerry_string_sz ("stack");
    #####:  411:    jerry_value_t backtrace_val = jerry_object_get (error_value, stack_str);
    #####:  412:    jerry_value_free (stack_str);
        -:  413:
    #####:  414:    if (jerry_value_is_array (backtrace_val))
        -:  415:    {
    #####:  416:      uint32_t length = jerry_array_length (backtrace_val);
        -:  417:
        -:  418:      /* This length should be enough. */
    #####:  419:      if (length > 32)
        -:  420:      {
    #####:  421:        length = 32;
        -:  422:      }
        -:  423:
    #####:  424:      for (uint32_t i = 0; i < length; i++)
        -:  425:      {
    #####:  426:        jerry_value_t item_val = jerry_object_get_index (backtrace_val, i);
        -:  427:
    #####:  428:        if (jerry_value_is_string (item_val))
        -:  429:        {
    #####:  430:          string_end = jerry_string_to_buffer (item_val, JERRY_ENCODING_UTF8, err_str_buf, sizeof (err_str_buf) - 1);
    #####:  431:          err_str_buf[string_end] = '\0';
        -:  432:
    #####:  433:          printf ("%6u: %s\n", i, err_str_buf);
        -:  434:        }
        -:  435:
    #####:  436:        jerry_value_free (item_val);
        -:  437:      }
        -:  438:    }
        -:  439:
    #####:  440:    jerry_value_free (backtrace_val);
        -:  441:  }
        -:  442:
    #####:  443:  jerry_value_free (error_value);
    #####:  444:} /* main_print_unhandled_exception */
        -:  445:
        -:  446:/**
        -:  447: * Runs the source code received by jerry_debugger_wait_for_client_source.
        -:  448: *
        -:  449: * @return result fo the source code execution
        -:  450: */
        -:  451:jerry_value_t
    #####:  452:main_wait_for_source_callback (const jerry_char_t *source_name_p, /**< source name */
        -:  453:                               size_t source_name_size, /**< size of source name */
        -:  454:                               const jerry_char_t *source_p, /**< source code */
        -:  455:                               size_t source_size, /**< source code size */
        -:  456:                               void *user_p) /**< user pointer */
        -:  457:{
        -:  458:  (void) user_p; /* unused */
        -:  459:
    #####:  460:  jerry_parse_options_t parse_options;
    #####:  461:  parse_options.options = JERRY_PARSE_HAS_SOURCE_NAME;
    #####:  462:  parse_options.source_name = jerry_string (source_name_p, (jerry_size_t) source_name_size, JERRY_ENCODING_UTF8);
        -:  463:
    #####:  464:  jerry_value_t ret_val = jerry_parse (source_p, source_size, &parse_options);
        -:  465:
    #####:  466:  jerry_value_free (parse_options.source_name);
        -:  467:
    #####:  468:  if (!jerry_value_is_exception (ret_val))
        -:  469:  {
    #####:  470:    jerry_value_t func_val = ret_val;
    #####:  471:    ret_val = jerry_run (func_val);
    #####:  472:    jerry_value_free (func_val);
        -:  473:  }
        -:  474:
    #####:  475:  return ret_val;
        -:  476:} /* main_wait_for_source_callback */
        -:  477:
        -:  478:/**
        -:  479: * Check that value contains the reset abort value.
        -:  480: *
        -:  481: * Note: if the value is the reset abort value, the value is release.
        -:  482: *
        -:  483: * return true, if reset abort
        -:  484: *        false, otherwise
        -:  485: */
        -:  486:bool
    #####:  487:main_is_value_reset (jerry_value_t value) /**< jerry value */
        -:  488:{
    #####:  489:  if (!jerry_value_is_abort (value))
        -:  490:  {
    #####:  491:    return false;
        -:  492:  }
        -:  493:
    #####:  494:  jerry_value_t abort_value = jerry_exception_value (value, false);
        -:  495:
    #####:  496:  if (!jerry_value_is_string (abort_value))
        -:  497:  {
    #####:  498:    jerry_value_free (abort_value);
    #####:  499:    return false;
        -:  500:  }
        -:  501:
        -:  502:  static const char restart_str[] = "r353t";
        -:  503:
    #####:  504:  jerry_size_t str_size = jerry_string_size (abort_value, JERRY_ENCODING_CESU8);
    #####:  505:  bool is_reset = false;
        -:  506:
    #####:  507:  if (str_size == sizeof (restart_str) - 1)
    #####:  508:  {
    #####:  509:    JERRY_VLA (jerry_char_t, str_buf, str_size);
    #####:  510:    jerry_string_to_buffer (abort_value, JERRY_ENCODING_CESU8, str_buf, str_size);
        -:  511:
    #####:  512:    is_reset = memcmp (restart_str, (char *) (str_buf), str_size) == 0;
        -:  513:
    #####:  514:    if (is_reset)
        -:  515:    {
    #####:  516:      jerry_value_free (value);
        -:  517:    }
        -:  518:  }
        -:  519:
    #####:  520:  jerry_value_free (abort_value);
    #####:  521:  return is_reset;
        -:  522:} /* main_is_value_reset */
