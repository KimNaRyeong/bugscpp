        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/typedarray/ecma-builtin-typedarray-prototype.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-arraybuffer-object.h"
        -:   19:#include "ecma-bigint.h"
        -:   20:#include "ecma-builtin-helpers.h"
        -:   21:#include "ecma-builtin-typedarray-helpers.h"
        -:   22:#include "ecma-builtins.h"
        -:   23:#include "ecma-comparison.h"
        -:   24:#include "ecma-conversion.h"
        -:   25:#include "ecma-exceptions.h"
        -:   26:#include "ecma-function-object.h"
        -:   27:#include "ecma-gc.h"
        -:   28:#include "ecma-globals.h"
        -:   29:#include "ecma-helpers.h"
        -:   30:#include "ecma-iterator-object.h"
        -:   31:#include "ecma-number-object.h"
        -:   32:#include "ecma-objects.h"
        -:   33:#include "ecma-typedarray-object.h"
        -:   34:
        -:   35:#include "jcontext.h"
        -:   36:#include "jmem.h"
        -:   37:#include "jrt-libc-includes.h"
        -:   38:#include "jrt.h"
        -:   39:#include "lit-char-helpers.h"
        -:   40:
        -:   41:#if JERRY_BUILTIN_TYPEDARRAY
        -:   42:
        -:   43:#define ECMA_BUILTINS_INTERNAL
        -:   44:#include "ecma-builtins-internal.h"
        -:   45:
        -:   46:/**
        -:   47: * This object has a custom dispatch function.
        -:   48: */
        -:   49:#define BUILTIN_CUSTOM_DISPATCH
        -:   50:
        -:   51:/**
        -:   52: * List of built-in routine identifiers.
        -:   53: */
        -:   54:enum
        -:   55:{
        -:   56:  /* These routines must be in this order */
        -:   57:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_START = 0,
        -:   58:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_MAP,
        -:   59:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE,
        -:   60:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT,
        -:   61:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY,
        -:   62:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SOME,
        -:   63:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FOR_EACH,
        -:   64:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILTER,
        -:   65:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND,
        -:   66:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND_INDEX,
        -:   67:
        -:   68:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF,
        -:   69:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_AT,
        -:   70:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LAST_INDEX_OF,
        -:   71:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INCLUDES,
        -:   72:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILL,
        -:   73:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SORT,
        -:   74:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REVERSE,
        -:   75:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_COPY_WITHIN,
        -:   76:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SLICE,
        -:   77:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY,
        -:   78:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_LOCALE_STRING,
        -:   79:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_JOIN,
        -:   80:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS,
        -:   81:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_ENTRIES,
        -:   82:
        -:   83:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER,
        -:   84:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTELENGTH_GETTER,
        -:   85:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTEOFFSET_GETTER,
        -:   86:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LENGTH_GETTER,
        -:   87:
        -:   88:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SET,
        -:   89:  ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER,
        -:   90:};
        -:   91:
        -:   92:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-typedarray-prototype.inc.h"
        -:   93:#define BUILTIN_UNDERSCORED_ID  typedarray_prototype
        -:   94:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   95:
        -:   96:/** \addtogroup ecma ECMA
        -:   97: * @{
        -:   98: *
        -:   99: * \addtogroup ecmabuiltins
        -:  100: * @{
        -:  101: *
        -:  102: * \addtogroup typedarrayprototype ECMA %TypedArray%.prototype object built-in
        -:  103: * @{
        -:  104: */
        -:  105:
        -:  106:/**
        -:  107: * Type of routine.
        -:  108: */
        -:  109:typedef enum
        -:  110:{
        -:  111:  TYPEDARRAY_ROUTINE_EVERY, /**< routine: every ES2015, 22.2.3.7 */
        -:  112:  TYPEDARRAY_ROUTINE_SOME, /**< routine: some ES2015, 22.2.3.9 */
        -:  113:  TYPEDARRAY_ROUTINE_FOREACH, /**< routine: forEach ES2015, 15.4.4.18 */
        -:  114:  TYPEDARRAY_ROUTINE__COUNT /**< count of the modes */
        -:  115:} typedarray_routine_mode;
        -:  116:
        -:  117:/**
        -:  118: * The common function for 'every', 'some' and 'forEach'
        -:  119: * because they have a similar structure.
        -:  120: *
        -:  121: * @return ecma value
        -:  122: *         Returned value must be freed with ecma_free_value.
        -:  123: */
        -:  124:static ecma_value_t
    #####:  125:ecma_builtin_typedarray_prototype_exec_routine (ecma_value_t this_arg, /**< this argument */
        -:  126:                                                ecma_typedarray_info_t *info_p, /**< object info */
        -:  127:                                                ecma_value_t cb_func_val, /**< callback function */
        -:  128:                                                ecma_value_t cb_this_arg, /**< 'this' of the callback function */
        -:  129:                                                typedarray_routine_mode mode) /**< mode: which routine */
        -:  130:{
    #####:  131:  JERRY_ASSERT (mode < TYPEDARRAY_ROUTINE__COUNT);
        -:  132:
    #####:  133:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  134:  ecma_typedarray_info_t info = ecma_typedarray_get_info (typedarray_p);
        -:  135:
    #####:  136:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (info.array_buffer_p))
        -:  137:  {
    #####:  138:    return ECMA_VALUE_ERROR;
        -:  139:  }
        -:  140:
    #####:  141:  if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -:  142:  {
    #####:  143:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  144:  }
        -:  145:
    #####:  146:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####:  147:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
    #####:  148:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####:  149:  uint32_t byte_pos = 0;
    #####:  150:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  151:
    #####:  152:  for (uint32_t index = 0; index < info_p->length && ecma_is_value_empty (ret_value); index++)
        -:  153:  {
    #####:  154:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  155:    ecma_value_t element = typedarray_getter_cb (buffer_p + byte_pos);
        -:  156:
    #####:  157:    ecma_value_t call_args[] = { element, current_index, this_arg };
        -:  158:
    #####:  159:    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  160:
    #####:  161:    ecma_fast_free_value (current_index);
    #####:  162:    ecma_fast_free_value (element);
        -:  163:
    #####:  164:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  165:    {
    #####:  166:      return call_value;
        -:  167:    }
        -:  168:
    #####:  169:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  170:    {
    #####:  171:      ecma_free_value (call_value);
    #####:  172:      return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  173:    }
        -:  174:
    #####:  175:    bool to_bool_result = ecma_op_to_boolean (call_value);
    #####:  176:    ecma_free_value (call_value);
        -:  177:
    #####:  178:    if (mode == TYPEDARRAY_ROUTINE_EVERY)
        -:  179:    {
    #####:  180:      if (!to_bool_result)
        -:  181:      {
    #####:  182:        return ECMA_VALUE_FALSE;
        -:  183:      }
        -:  184:    }
    #####:  185:    else if (mode == TYPEDARRAY_ROUTINE_SOME && to_bool_result)
        -:  186:    {
    #####:  187:      return ECMA_VALUE_TRUE;
        -:  188:    }
        -:  189:
    #####:  190:    byte_pos += info_p->element_size;
        -:  191:  }
        -:  192:
    #####:  193:  if (mode == TYPEDARRAY_ROUTINE_EVERY)
        -:  194:  {
    #####:  195:    ret_value = ECMA_VALUE_TRUE;
        -:  196:  }
    #####:  197:  else if (mode == TYPEDARRAY_ROUTINE_SOME)
        -:  198:  {
    #####:  199:    ret_value = ECMA_VALUE_FALSE;
        -:  200:  }
        -:  201:  else
        -:  202:  {
    #####:  203:    ret_value = ECMA_VALUE_UNDEFINED;
        -:  204:  }
        -:  205:
    #####:  206:  return ret_value;
        -:  207:} /* ecma_builtin_typedarray_prototype_exec_routine */
        -:  208:
        -:  209:/**
        -:  210: * The %TypedArray%.prototype object's 'map' routine
        -:  211: *
        -:  212: * See also:
        -:  213: *          ES2015, 22.2.3.8
        -:  214: *
        -:  215: * @return ecma value
        -:  216: *         Returned value must be freed with ecma_free_value.
        -:  217: */
        -:  218:static ecma_value_t
    #####:  219:ecma_builtin_typedarray_prototype_map (ecma_value_t this_arg, /**< this object */
        -:  220:                                       ecma_typedarray_info_t *src_info_p, /**< object info */
        -:  221:                                       ecma_value_t cb_func_val, /**< callback function */
        -:  222:                                       ecma_value_t cb_this_arg) /**< this' of the callback function */
        -:  223:{
    #####:  224:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
        -:  225:
    #####:  226:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (src_info_p->array_buffer_p))
        -:  227:  {
    #####:  228:    return ECMA_VALUE_ERROR;
        -:  229:  }
        -:  230:
    #####:  231:  if (ecma_arraybuffer_is_detached (src_info_p->array_buffer_p))
        -:  232:  {
    #####:  233:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  234:  }
        -:  235:
        -:  236:  // TODO: 22.2.3.18, 7-8.
    #####:  237:  ecma_value_t len = ecma_make_number_value (src_info_p->length);
    #####:  238:  ecma_value_t new_typedarray = ecma_typedarray_species_create (this_arg, &len, 1);
    #####:  239:  ecma_free_value (len);
        -:  240:
    #####:  241:  if (ECMA_IS_VALUE_ERROR (new_typedarray))
        -:  242:  {
    #####:  243:    return new_typedarray;
        -:  244:  }
        -:  245:
    #####:  246:  ecma_object_t *target_obj_p = ecma_get_object_from_value (new_typedarray);
        -:  247:
    #####:  248:  uint8_t *src_buffer_p = ecma_typedarray_get_buffer (src_info_p);
        -:  249:
    #####:  250:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (target_obj_p);
        -:  251:
    #####:  252:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (target_info.array_buffer_p))
        -:  253:  {
    #####:  254:    ecma_deref_object (target_obj_p);
    #####:  255:    return ECMA_VALUE_ERROR;
        -:  256:  }
        -:  257:
    #####:  258:  if (ecma_arraybuffer_is_detached (target_info.array_buffer_p))
        -:  259:  {
    #####:  260:    ecma_deref_object (target_obj_p);
    #####:  261:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  262:  }
        -:  263:
    #####:  264:  uint8_t *target_buffer_p = ecma_typedarray_get_buffer (&target_info);
        -:  265:
    #####:  266:  ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_info_p->id);
    #####:  267:  ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  268:
    #####:  269:  for (uint32_t index = 0; index < src_info_p->length; index++)
        -:  270:  {
    #####:  271:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  272:    ecma_value_t element = src_typedarray_getter_cb (src_buffer_p);
    #####:  273:    src_buffer_p += src_info_p->element_size;
        -:  274:
    #####:  275:    ecma_value_t call_args[] = { element, current_index, this_arg };
    #####:  276:    ecma_value_t mapped_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  277:
    #####:  278:    ecma_free_value (current_index);
    #####:  279:    ecma_free_value (element);
        -:  280:
    #####:  281:    if (ECMA_IS_VALUE_ERROR (mapped_value))
        -:  282:    {
    #####:  283:      ecma_free_value (new_typedarray);
    #####:  284:      return mapped_value;
        -:  285:    }
        -:  286:
    #####:  287:    if (ecma_arraybuffer_is_detached (src_info_p->array_buffer_p))
        -:  288:    {
    #####:  289:      ecma_free_value (mapped_value);
    #####:  290:      ecma_free_value (new_typedarray);
    #####:  291:      return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  292:    }
        -:  293:
    #####:  294:    ecma_value_t set_element = target_typedarray_setter_cb (target_buffer_p, mapped_value);
    #####:  295:    target_buffer_p += target_info.element_size;
    #####:  296:    ecma_free_value (mapped_value);
        -:  297:
    #####:  298:    if (ECMA_IS_VALUE_ERROR (set_element))
        -:  299:    {
    #####:  300:      ecma_free_value (new_typedarray);
    #####:  301:      return set_element;
        -:  302:    }
        -:  303:  }
        -:  304:
    #####:  305:  return new_typedarray;
        -:  306:} /* ecma_builtin_typedarray_prototype_map */
        -:  307:
        -:  308:/**
        -:  309: * Reduce and reduceRight routines share a similar structure.
        -:  310: * And we use 'is_right' to distinguish between them.
        -:  311: *
        -:  312: * @return ecma value
        -:  313: *         Returned value must be freed with ecma_free_value.
        -:  314: */
        -:  315:static ecma_value_t
    #####:  316:ecma_builtin_typedarray_prototype_reduce_with_direction (ecma_value_t this_arg, /**< this object */
        -:  317:                                                         ecma_typedarray_info_t *info_p, /**< object info */
        -:  318:                                                         const ecma_value_t arguments_list_p[], /**arg_list*/
        -:  319:                                                         uint32_t arguments_number, /**< length of arguments' list*/
        -:  320:                                                         bool is_right) /**< choose order, true is reduceRight */
        -:  321:{
    #####:  322:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  323:  {
    #####:  324:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  325:  }
        -:  326:
    #####:  327:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -:  328:  uint32_t byte_pos;
        -:  329:
    #####:  330:  if (info_p->length == 0)
        -:  331:  {
    #####:  332:    if (arguments_number < 2)
        -:  333:    {
    #####:  334:      return ecma_raise_type_error (ECMA_ERR_INITIAL_VALUE_CANNOT_BE_UNDEFINED);
        -:  335:    }
        -:  336:
    #####:  337:    return ecma_copy_value (arguments_list_p[1]);
        -:  338:  }
        -:  339:
    #####:  340:  JERRY_ASSERT (info_p->length > 0);
        -:  341:
    #####:  342:  ecma_value_t accumulator = ECMA_VALUE_UNDEFINED;
    #####:  343:  uint32_t index = is_right ? (info_p->length - 1) : 0;
    #####:  344:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
        -:  345:
    #####:  346:  if (ecma_is_value_undefined (arguments_list_p[1]))
        -:  347:  {
    #####:  348:    byte_pos = index << info_p->shift;
    #####:  349:    accumulator = getter_cb (buffer_p + byte_pos);
        -:  350:
    #####:  351:    if (is_right)
        -:  352:    {
    #####:  353:      if (index == 0)
        -:  354:      {
    #####:  355:        return accumulator;
        -:  356:      }
        -:  357:
    #####:  358:      index--;
        -:  359:    }
        -:  360:    else
        -:  361:    {
    #####:  362:      index++;
        -:  363:
    #####:  364:      if (index == info_p->length)
        -:  365:      {
    #####:  366:        return accumulator;
        -:  367:      }
        -:  368:    }
        -:  369:  }
        -:  370:  else
        -:  371:  {
    #####:  372:    accumulator = ecma_copy_value (arguments_list_p[1]);
        -:  373:  }
        -:  374:
    #####:  375:  ecma_object_t *func_object_p = ecma_get_object_from_value (arguments_list_p[0]);
        -:  376:
        -:  377:  while (true)
    #####:  378:  {
    #####:  379:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  380:    byte_pos = index << info_p->shift;
    #####:  381:    ecma_value_t get_value = getter_cb (buffer_p + byte_pos);
        -:  382:
    #####:  383:    ecma_value_t call_args[] = { accumulator, get_value, current_index, this_arg };
        -:  384:
    #####:  385:    JERRY_ASSERT (ecma_is_value_number (get_value) || ecma_is_value_bigint (get_value));
        -:  386:
    #####:  387:    ecma_value_t call_value = ecma_op_function_call (func_object_p, ECMA_VALUE_UNDEFINED, call_args, 4);
        -:  388:
    #####:  389:    ecma_fast_free_value (accumulator);
    #####:  390:    ecma_fast_free_value (get_value);
    #####:  391:    ecma_fast_free_value (current_index);
        -:  392:
    #####:  393:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  394:    {
    #####:  395:      return call_value;
        -:  396:    }
        -:  397:
    #####:  398:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  399:    {
    #####:  400:      ecma_free_value (call_value);
    #####:  401:      return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  402:    }
        -:  403:
    #####:  404:    accumulator = call_value;
        -:  405:
    #####:  406:    if (is_right)
        -:  407:    {
    #####:  408:      if (index == 0)
        -:  409:      {
    #####:  410:        break;
        -:  411:      }
        -:  412:
    #####:  413:      index--;
        -:  414:    }
        -:  415:    else
        -:  416:    {
    #####:  417:      index++;
        -:  418:
    #####:  419:      if (index == info_p->length)
        -:  420:      {
    #####:  421:        break;
        -:  422:      }
        -:  423:    }
        -:  424:  }
        -:  425:
    #####:  426:  return accumulator;
        -:  427:} /* ecma_builtin_typedarray_prototype_reduce_with_direction */
        -:  428:
        -:  429:/**
        -:  430: * The %TypedArray%.prototype object's 'filter' routine
        -:  431: *
        -:  432: * See also:
        -:  433: *          ES2015, 22.2.3.9
        -:  434: *
        -:  435: * @return ecma value
        -:  436: *         Returned value must be freed with ecma_free_value.
        -:  437: */
        -:  438:static ecma_value_t
    #####:  439:ecma_builtin_typedarray_prototype_filter (ecma_value_t this_arg, /**< this object */
        -:  440:                                          ecma_typedarray_info_t *info_p, /**< object info */
        -:  441:                                          ecma_value_t cb_func_val, /**< callback function */
        -:  442:                                          ecma_value_t cb_this_arg) /**< 'this' of the callback function */
        -:  443:{
    #####:  444:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  445:  {
    #####:  446:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  447:  }
        -:  448:
    #####:  449:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -:  450:
    #####:  451:  ecma_object_t *func_object_p = ecma_get_object_from_value (cb_func_val);
    #####:  452:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  453:
        -:  454:  // TODO: 22.2.3.9, 7-8.
    #####:  455:  if (info_p->length == 0)
        -:  456:  {
    #####:  457:    return ecma_op_create_typedarray_with_type_and_length (info_p->id, 0);
        -:  458:  }
        -:  459:
    #####:  460:  ecma_collection_t *collected_p = ecma_new_collection ();
    #####:  461:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
        -:  462:
    #####:  463:  for (uint32_t index = 0; index < info_p->length; index++)
        -:  464:  {
    #####:  465:    ecma_value_t current_index = ecma_make_uint32_value (index);
    #####:  466:    ecma_value_t get_value = getter_cb (buffer_p);
        -:  467:
    #####:  468:    JERRY_ASSERT (ecma_is_value_number (get_value) || ecma_is_value_bigint (get_value));
        -:  469:
    #####:  470:    ecma_value_t call_args[] = { get_value, current_index, this_arg };
        -:  471:
    #####:  472:    ecma_value_t call_value = ecma_op_function_call (func_object_p, cb_this_arg, call_args, 3);
        -:  473:
    #####:  474:    ecma_fast_free_value (current_index);
        -:  475:
    #####:  476:    if (ECMA_IS_VALUE_ERROR (call_value))
        -:  477:    {
    #####:  478:      ecma_fast_free_value (get_value);
    #####:  479:      goto cleanup;
        -:  480:    }
        -:  481:
    #####:  482:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  483:    {
    #####:  484:      ecma_free_value (call_value);
    #####:  485:      ecma_fast_free_value (get_value);
    #####:  486:      ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
    #####:  487:      goto cleanup;
        -:  488:    }
        -:  489:
    #####:  490:    if (ecma_op_to_boolean (call_value))
        -:  491:    {
    #####:  492:      ecma_collection_push_back (collected_p, get_value);
        -:  493:    }
        -:  494:    else
        -:  495:    {
    #####:  496:      ecma_fast_free_value (get_value);
        -:  497:    }
        -:  498:
    #####:  499:    buffer_p += info_p->element_size;
    #####:  500:    ecma_fast_free_value (call_value);
        -:  501:  }
        -:  502:
    #####:  503:  ecma_value_t collected = ecma_make_number_value (collected_p->item_count);
    #####:  504:  ret_value = ecma_typedarray_species_create (this_arg, &collected, 1);
    #####:  505:  ecma_free_value (collected);
        -:  506:
    #####:  507:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -:  508:  {
    #####:  509:    ecma_object_t *new_typedarray_p = ecma_get_object_from_value (ret_value);
    #####:  510:    ecma_typedarray_info_t target_info = ecma_typedarray_get_info (new_typedarray_p);
        -:  511:
    #####:  512:    JERRY_ASSERT (target_info.offset == 0);
        -:  513:
    #####:  514:    uint8_t *target_buffer_p = ecma_typedarray_get_buffer (&target_info);
        -:  515:
    #####:  516:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  517:
    #####:  518:    for (uint32_t idx = 0; idx < collected_p->item_count; idx++)
        -:  519:    {
    #####:  520:      ecma_value_t set_element = target_typedarray_setter_cb (target_buffer_p, collected_p->buffer_p[idx]);
        -:  521:
    #####:  522:      if (ECMA_IS_VALUE_ERROR (set_element))
        -:  523:      {
    #####:  524:        ecma_deref_object (new_typedarray_p);
    #####:  525:        ret_value = ECMA_VALUE_ERROR;
    #####:  526:        goto cleanup;
        -:  527:      }
        -:  528:
    #####:  529:      target_buffer_p += target_info.element_size;
        -:  530:    }
        -:  531:  }
        -:  532:
    #####:  533:cleanup:
    #####:  534:  ecma_collection_free (collected_p);
        -:  535:
    #####:  536:  return ret_value;
        -:  537:} /* ecma_builtin_typedarray_prototype_filter */
        -:  538:
        -:  539:/**
        -:  540: * The %TypedArray%.prototype object's 'reverse' routine
        -:  541: *
        -:  542: * See also:
        -:  543: *          ES2015, 22.2.3.21
        -:  544: *
        -:  545: * @return ecma value
        -:  546: *         Returned value must be freed with ecma_free_value.
        -:  547: */
        -:  548:static ecma_value_t
    #####:  549:ecma_builtin_typedarray_prototype_reverse (ecma_value_t this_arg, /**< this argument */
        -:  550:                                           ecma_typedarray_info_t *info_p) /**< object info */
        -:  551:{
    #####:  552:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -:  553:  {
    #####:  554:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  555:  }
        -:  556:
    #####:  557:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####:  558:  uint32_t middle = (info_p->length / 2) << info_p->shift;
    #####:  559:  uint32_t buffer_last = (info_p->length << info_p->shift) - info_p->element_size;
        -:  560:
    #####:  561:  for (uint32_t lower = 0; lower < middle; lower += info_p->element_size)
        -:  562:  {
    #####:  563:    uint32_t upper = buffer_last - lower;
    #####:  564:    uint8_t *lower_p = buffer_p + lower;
    #####:  565:    uint8_t *upper_p = buffer_p + upper;
        -:  566:
    #####:  567:    uint8_t tmp[8];
    #####:  568:    memcpy (&tmp[0], lower_p, info_p->element_size);
    #####:  569:    memcpy (lower_p, upper_p, info_p->element_size);
    #####:  570:    memcpy (upper_p, &tmp[0], info_p->element_size);
        -:  571:  }
        -:  572:
    #####:  573:  return ecma_copy_value (this_arg);
        -:  574:} /* ecma_builtin_typedarray_prototype_reverse */
        -:  575:
        -:  576:/**
        -:  577: * The %TypedArray%.prototype object's 'set' routine for a typedArray source
        -:  578: *
        -:  579: * See also:
        -:  580: *          ES2015, 22.2.3.22, 22.2.3.22.2
        -:  581: *
        -:  582: * @return ecma value of undefined if success, error otherwise.
        -:  583: *         Returned value must be freed with ecma_free_value.
        -:  584: */
        -:  585:static ecma_value_t
    #####:  586:ecma_op_typedarray_set_with_typedarray (ecma_value_t this_arg, /**< this argument */
        -:  587:                                        ecma_value_t arr_val, /**< typedarray object */
        -:  588:                                        ecma_value_t offset_val) /**< offset value */
        -:  589:{
        -:  590:  /* 6.~ 8. targetOffset */
    #####:  591:  ecma_number_t target_offset_num;
    #####:  592:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (offset_val, &target_offset_num)))
        -:  593:  {
    #####:  594:    return ECMA_VALUE_ERROR;
        -:  595:  }
        -:  596:
    #####:  597:  if (target_offset_num <= -1.0 || target_offset_num >= (ecma_number_t) UINT32_MAX + 0.5)
        -:  598:  {
    #####:  599:    return ecma_raise_range_error (ECMA_ERR_INVALID_OFFSET);
        -:  600:  }
        -:  601:
    #####:  602:  ecma_object_t *target_typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  603:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (target_typedarray_p);
        -:  604:
    #####:  605:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (target_info.array_buffer_p))
        -:  606:  {
    #####:  607:    return ECMA_VALUE_ERROR;
        -:  608:  }
        -:  609:
    #####:  610:  if (ecma_arraybuffer_is_detached (target_info.array_buffer_p))
        -:  611:  {
    #####:  612:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  613:  }
        -:  614:
    #####:  615:  uint8_t *target_buffer_p = ecma_typedarray_get_buffer (&target_info);
        -:  616:
    #####:  617:  ecma_object_t *src_typedarray_p = ecma_get_object_from_value (arr_val);
    #####:  618:  ecma_typedarray_info_t src_info = ecma_typedarray_get_info (src_typedarray_p);
        -:  619:
    #####:  620:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (src_info.array_buffer_p))
        -:  621:  {
    #####:  622:    return ECMA_VALUE_ERROR;
        -:  623:  }
        -:  624:
    #####:  625:  if (ecma_arraybuffer_is_detached (src_info.array_buffer_p))
        -:  626:  {
    #####:  627:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  628:  }
        -:  629:
    #####:  630:  uint8_t *src_buffer_p = ecma_typedarray_get_buffer (&src_info);
        -:  631:
    #####:  632:  uint32_t target_offset_uint32 = ecma_number_to_uint32 (target_offset_num);
        -:  633:
    #####:  634:  if ((int64_t) src_info.length + target_offset_uint32 > target_info.length)
        -:  635:  {
    #####:  636:    return ecma_raise_range_error (ECMA_ERR_INVALID_RANGE_OF_INDEX);
        -:  637:  }
        -:  638:
        -:  639:  /* Fast path first. If the source and target arrays are the same we do not need to copy anything. */
    #####:  640:  if (this_arg == arr_val)
        -:  641:  {
    #####:  642:    return ECMA_VALUE_UNDEFINED;
        -:  643:  }
        -:  644:
        -:  645:  /* 26. targetByteIndex */
    #####:  646:  target_buffer_p += target_offset_uint32 << target_info.shift;
        -:  647:
        -:  648:  /* 27. limit */
    #####:  649:  uint32_t limit = src_info.length << target_info.shift;
        -:  650:
    #####:  651:  if (src_info.id == target_info.id)
        -:  652:  {
    #####:  653:    memmove (target_buffer_p, src_buffer_p, limit);
        -:  654:  }
        -:  655:  else
        -:  656:  {
    #####:  657:    uint8_t *target_limit_p = target_buffer_p + limit;
    #####:  658:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (src_info.id);
    #####:  659:    ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
        -:  660:
    #####:  661:    while (target_buffer_p < target_limit_p)
        -:  662:    {
    #####:  663:      ecma_value_t element = src_typedarray_getter_cb (src_buffer_p);
    #####:  664:      ecma_value_t set_element = target_typedarray_setter_cb (target_buffer_p, element);
    #####:  665:      ecma_free_value (element);
        -:  666:
    #####:  667:      if (ECMA_IS_VALUE_ERROR (set_element))
        -:  668:      {
    #####:  669:        return set_element;
        -:  670:      }
        -:  671:
    #####:  672:      src_buffer_p += src_info.element_size;
    #####:  673:      target_buffer_p += target_info.element_size;
        -:  674:    }
        -:  675:  }
        -:  676:
    #####:  677:  return ECMA_VALUE_UNDEFINED;
        -:  678:} /* ecma_op_typedarray_set_with_typedarray */
        -:  679:
        -:  680:/**
        -:  681: * The %TypedArray%.prototype object's 'set' routine
        -:  682: *
        -:  683: * See also:
        -:  684: *          ES2015, 22.2.3.22, 22.2.3.22.1
        -:  685: *
        -:  686: * @return ecma value of undefined if success, error otherwise.
        -:  687: *         Returned value must be freed with ecma_free_value.
        -:  688: */
        -:  689:static ecma_value_t
    #####:  690:ecma_builtin_typedarray_prototype_set (ecma_value_t this_arg, /**< this argument */
        -:  691:                                       ecma_value_t arr_val, /**< array object */
        -:  692:                                       ecma_value_t offset_val) /**< offset value */
        -:  693:{
        -:  694:  /* 1. */
    #####:  695:  if (ecma_is_typedarray (arr_val))
        -:  696:  {
        -:  697:    /* 22.2.3.22.2 */
    #####:  698:    return ecma_op_typedarray_set_with_typedarray (this_arg, arr_val, offset_val);
        -:  699:  }
        -:  700:
        -:  701:  /* 6.~ 8. targetOffset */
    #####:  702:  ecma_number_t target_offset_num;
        -:  703:
    #####:  704:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (offset_val, &target_offset_num)))
        -:  705:  {
    #####:  706:    return ECMA_VALUE_ERROR;
        -:  707:  }
        -:  708:
    #####:  709:  if (target_offset_num <= -1.0 || target_offset_num >= (ecma_number_t) UINT32_MAX + 0.5)
        -:  710:  {
    #####:  711:    return ecma_raise_range_error (ECMA_ERR_INVALID_OFFSET);
        -:  712:  }
    #####:  713:  uint32_t target_offset_uint32 = ecma_number_to_uint32 (target_offset_num);
        -:  714:
        -:  715:  /* 11. ~ 15. */
    #####:  716:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####:  717:  ecma_typedarray_info_t target_info = ecma_typedarray_get_info (typedarray_p);
        -:  718:
    #####:  719:  if (ECMA_ARRAYBUFFER_LAZY_ALLOC (target_info.array_buffer_p))
        -:  720:  {
    #####:  721:    return ECMA_VALUE_ERROR;
        -:  722:  }
        -:  723:
    #####:  724:  if (ecma_arraybuffer_is_detached (target_info.array_buffer_p))
        -:  725:  {
    #####:  726:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  727:  }
        -:  728:
    #####:  729:  uint8_t *target_buffer_p = ecma_typedarray_get_buffer (&target_info);
        -:  730:
        -:  731:  /* 16.~ 17. */
    #####:  732:  ecma_value_t source_obj = ecma_op_to_object (arr_val);
        -:  733:
    #####:  734:  if (ECMA_IS_VALUE_ERROR (source_obj))
        -:  735:  {
    #####:  736:    return source_obj;
        -:  737:  }
        -:  738:
        -:  739:  /* 18.~ 19. */
    #####:  740:  ecma_object_t *source_obj_p = ecma_get_object_from_value (source_obj);
        -:  741:
    #####:  742:  ecma_length_t source_length;
        -:  743:
    #####:  744:  if (ECMA_IS_VALUE_ERROR (ecma_op_object_get_length (source_obj_p, &source_length)))
        -:  745:  {
    #####:  746:    ecma_deref_object (source_obj_p);
    #####:  747:    return ECMA_VALUE_ERROR;
        -:  748:  }
        -:  749:
        -:  750:  /* 20. if srcLength + targetOffset > targetLength, throw a RangeError */
    #####:  751:  if ((int64_t) source_length + target_offset_uint32 > target_info.length)
        -:  752:  {
    #####:  753:    ecma_deref_object (source_obj_p);
    #####:  754:    return ecma_raise_range_error (ECMA_ERR_INVALID_RANGE_OF_INDEX);
        -:  755:  }
    #####:  756:  JERRY_ASSERT (source_length <= UINT32_MAX);
    #####:  757:  uint32_t source_length_uint32 = (uint32_t) source_length;
        -:  758:
        -:  759:  /* 21.~ 25. */
    #####:  760:  target_buffer_p += target_offset_uint32 << target_info.shift;
        -:  761:
    #####:  762:  ecma_typedarray_setter_fn_t target_typedarray_setter_cb = ecma_get_typedarray_setter_fn (target_info.id);
    #####:  763:  uint32_t k = 0;
        -:  764:
    #####:  765:  while (k < source_length_uint32)
        -:  766:  {
    #####:  767:    ecma_value_t elem = ecma_op_object_get_by_index (source_obj_p, k);
        -:  768:
    #####:  769:    if (ECMA_IS_VALUE_ERROR (elem))
        -:  770:    {
    #####:  771:      ecma_deref_object (source_obj_p);
    #####:  772:      return elem;
        -:  773:    }
        -:  774:
        -:  775:    ecma_value_t value_to_set;
        -:  776:
        -:  777:#if JERRY_BUILTIN_BIGINT
    #####:  778:    if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (target_info.id))
        -:  779:    {
    #####:  780:      value_to_set = ecma_bigint_to_bigint (elem, false);
        -:  781:
    #####:  782:      if (ECMA_IS_VALUE_ERROR (value_to_set))
        -:  783:      {
    #####:  784:        ecma_deref_object (source_obj_p);
    #####:  785:        ecma_free_value (elem);
    #####:  786:        return value_to_set;
        -:  787:      }
        -:  788:    }
        -:  789:    else
        -:  790:#endif /* JERRY_BUILTIN_BIGINT */
        -:  791:    {
    #####:  792:      ecma_number_t elem_num;
    #####:  793:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_numeric (elem, &elem_num, ECMA_TO_NUMERIC_NO_OPTS)))
        -:  794:      {
    #####:  795:        ecma_free_value (elem);
    #####:  796:        ecma_deref_object (source_obj_p);
    #####:  797:        return ECMA_VALUE_ERROR;
        -:  798:      }
        -:  799:
    #####:  800:      value_to_set = ecma_make_number_value (elem_num);
        -:  801:    }
        -:  802:
    #####:  803:    ecma_free_value (elem);
        -:  804:
    #####:  805:    if (ecma_arraybuffer_is_detached (target_info.array_buffer_p))
        -:  806:    {
    #####:  807:      ecma_deref_object (source_obj_p);
    #####:  808:      ecma_free_value (value_to_set);
    #####:  809:      return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  810:    }
        -:  811:
    #####:  812:    ecma_value_t set_element = target_typedarray_setter_cb (target_buffer_p, value_to_set);
        -:  813:
    #####:  814:    ecma_free_value (value_to_set);
        -:  815:
    #####:  816:    if (ECMA_IS_VALUE_ERROR (set_element))
        -:  817:    {
    #####:  818:      ecma_deref_object (source_obj_p);
    #####:  819:      return set_element;
        -:  820:    }
        -:  821:
    #####:  822:    k++;
    #####:  823:    target_buffer_p += target_info.element_size;
        -:  824:  }
        -:  825:
    #####:  826:  ecma_deref_object (source_obj_p);
        -:  827:
    #####:  828:  return ECMA_VALUE_UNDEFINED;
        -:  829:} /* ecma_builtin_typedarray_prototype_set */
        -:  830:
        -:  831:/**
        -:  832: * TypedArray.prototype's 'toString' single element operation routine based
        -:  833: * on the Array.prototype's 'toString' single element operation routine
        -:  834: *
        -:  835: * See also:
        -:  836: *          ECMA-262 v5.1, 15.4.4.2
        -:  837: *
        -:  838: * @return NULL - if the converison fails
        -:  839: *         ecma_string_t * - otherwise
        -:  840: */
        -:  841:static ecma_string_t *
    #####:  842:ecma_op_typedarray_get_to_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  843:                                           uint32_t index) /**< array index */
        -:  844:{
    #####:  845:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  846:
    #####:  847:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  848:  {
    #####:  849:    return NULL;
        -:  850:  }
        -:  851:
    #####:  852:  if (ecma_is_value_undefined (index_value) || ecma_is_value_null (index_value))
        -:  853:  {
    #####:  854:    ecma_free_value (index_value);
    #####:  855:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  856:  }
        -:  857:
    #####:  858:  ecma_string_t *ret_str_p = ecma_op_to_string (index_value);
        -:  859:
    #####:  860:  ecma_free_value (index_value);
        -:  861:
    #####:  862:  return ret_str_p;
        -:  863:} /* ecma_op_typedarray_get_to_string_at_index */
        -:  864:
        -:  865:/**
        -:  866: * The TypedArray.prototype.toString's separator creation routine based on
        -:  867: * the Array.prototype.toString's separator routine
        -:  868: *
        -:  869: * See also:
        -:  870: *          ECMA-262 v5.1, 15.4.4.2 4th step
        -:  871: *
        -:  872: * @return NULL - if the conversion fails
        -:  873: *         ecma_string_t * - otherwise
        -:  874: */
        -:  875:static ecma_string_t *
    #####:  876:ecma_op_typedarray_get_separator_string (ecma_value_t separator) /**< possible separator */
        -:  877:{
    #####:  878:  if (ecma_is_value_undefined (separator))
        -:  879:  {
    #####:  880:    return ecma_get_magic_string (LIT_MAGIC_STRING_COMMA_CHAR);
        -:  881:  }
        -:  882:
    #####:  883:  return ecma_op_to_string (separator);
        -:  884:} /* ecma_op_typedarray_get_separator_string */
        -:  885:
        -:  886:/**
        -:  887: * The TypedArray.prototype object's 'join' routine basen on
        -:  888: * the Array.porottype object's 'join'
        -:  889: *
        -:  890: * See also:
        -:  891: *          ECMA-262 v5, 15.4.4.5
        -:  892: *
        -:  893: * @return ecma value
        -:  894: *         Returned value must be freed with ecma_free_value.
        -:  895: */
        -:  896:static ecma_value_t
    #####:  897:ecma_builtin_typedarray_prototype_join (ecma_object_t *obj_p, /**< this object */
        -:  898:                                        ecma_value_t separator_arg) /**< separator argument */
        -:  899:{
    #####:  900:  ecma_typedarray_info_t info = ecma_typedarray_get_info (obj_p);
        -:  901:
    #####:  902:  if (ecma_arraybuffer_is_detached (info.array_buffer_p))
        -:  903:  {
    #####:  904:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -:  905:  }
        -:  906:
        -:  907:  /* 2. */
    #####:  908:  uint32_t length = ecma_typedarray_get_length (obj_p);
    #####:  909:  ecma_string_t *separator_string_p = ecma_op_typedarray_get_separator_string (separator_arg);
        -:  910:
    #####:  911:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  912:  if (JERRY_UNLIKELY (separator_string_p == NULL))
        -:  913:  {
    #####:  914:    return ret_value;
        -:  915:  }
        -:  916:
        -:  917:  /* 7-8. */
    #####:  918:  ecma_string_t *first_string_p = ecma_op_typedarray_get_to_string_at_index (obj_p, 0);
        -:  919:
    #####:  920:  if (JERRY_UNLIKELY (first_string_p == NULL))
        -:  921:  {
    #####:  922:    ecma_deref_ecma_string (separator_string_p);
    #####:  923:    return ret_value;
        -:  924:  }
        -:  925:
    #####:  926:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (first_string_p);
        -:  927:
    #####:  928:  ecma_deref_ecma_string (first_string_p);
        -:  929:
        -:  930:  /* 9-10. */
    #####:  931:  for (uint32_t k = 1; k < length; k++)
        -:  932:  {
        -:  933:    /* 10.a */
    #####:  934:    ecma_stringbuilder_append (&builder, separator_string_p);
        -:  935:
        -:  936:    /* 10.d */
    #####:  937:    ecma_string_t *next_string_p = ecma_op_typedarray_get_to_string_at_index (obj_p, k);
        -:  938:
    #####:  939:    if (JERRY_UNLIKELY (next_string_p == NULL))
        -:  940:    {
    #####:  941:      ecma_stringbuilder_destroy (&builder);
    #####:  942:      ecma_deref_ecma_string (separator_string_p);
    #####:  943:      return ret_value;
        -:  944:    }
        -:  945:
    #####:  946:    ecma_stringbuilder_append (&builder, next_string_p);
        -:  947:
    #####:  948:    ecma_deref_ecma_string (next_string_p);
        -:  949:  }
        -:  950:
    #####:  951:  ecma_deref_ecma_string (separator_string_p);
    #####:  952:  ret_value = ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  953:
    #####:  954:  return ret_value;
        -:  955:} /* ecma_builtin_typedarray_prototype_join */
        -:  956:
        -:  957:/**
        -:  958: * The %TypedArray%.prototype object's 'subarray' routine.
        -:  959: *
        -:  960: * See also:
        -:  961: *          ES2015, 22.2.3.26
        -:  962: *
        -:  963: * @return ecma value
        -:  964: *         Returned value must be freed with ecma_free_value.
        -:  965: */
        -:  966:static ecma_value_t
    #####:  967:ecma_builtin_typedarray_prototype_subarray (ecma_value_t this_arg, /**< this object */
        -:  968:                                            ecma_typedarray_info_t *info_p, /**< object info */
        -:  969:                                            ecma_value_t begin, /**< begin */
        -:  970:                                            ecma_value_t end) /**< end */
        -:  971:{
    #####:  972:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  973:
        -:  974:  /* 9. beginIndex, 12. endIndex */
    #####:  975:  uint32_t begin_index_uint32 = 0, end_index_uint32 = 0;
        -:  976:
        -:  977:  /* 7. relativeBegin */
    #####:  978:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (begin, info_p->length, &begin_index_uint32)))
        -:  979:  {
    #####:  980:    return ECMA_VALUE_ERROR;
        -:  981:  }
        -:  982:
    #####:  983:  if (ecma_is_value_undefined (end))
        -:  984:  {
    #####:  985:    end_index_uint32 = (uint32_t) info_p->length;
        -:  986:  }
        -:  987:  else
        -:  988:  {
        -:  989:    /* 10. relativeEnd */
    #####:  990:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (end, info_p->length, &end_index_uint32)))
        -:  991:    {
    #####:  992:      return ECMA_VALUE_ERROR;
        -:  993:    }
        -:  994:  }
        -:  995:
        -:  996:  /* 13. newLength */
    #####:  997:  uint32_t subarray_length = 0;
        -:  998:
    #####:  999:  if (end_index_uint32 > begin_index_uint32)
        -: 1000:  {
    #####: 1001:    subarray_length = end_index_uint32 - begin_index_uint32;
        -: 1002:  }
        -: 1003:
        -: 1004:  /* 17. beginByteOffset */
    #####: 1005:  uint32_t begin_byte_offset = info_p->offset + (begin_index_uint32 << info_p->shift);
        -: 1006:
    #####: 1007:  ecma_value_t arguments_p[3] = { ecma_make_object_value (info_p->array_buffer_p),
    #####: 1008:                                  ecma_make_uint32_value (begin_byte_offset),
    #####: 1009:                                  ecma_make_uint32_value (subarray_length) };
        -: 1010:
    #####: 1011:  ret_value = ecma_typedarray_species_create (this_arg, arguments_p, 3);
        -: 1012:
    #####: 1013:  ecma_free_value (arguments_p[1]);
    #####: 1014:  ecma_free_value (arguments_p[2]);
    #####: 1015:  return ret_value;
        -: 1016:} /* ecma_builtin_typedarray_prototype_subarray */
        -: 1017:
        -: 1018:/**
        -: 1019: * The %TypedArray%.prototype object's 'fill' routine.
        -: 1020: *
        -: 1021: * See also:
        -: 1022: *          ES2015, 22.2.3.8, 22.1.3.6
        -: 1023: *
        -: 1024: * @return ecma value
        -: 1025: *         Returned value must be freed with ecma_free_value.
        -: 1026: */
        -: 1027:static ecma_value_t
    #####: 1028:ecma_builtin_typedarray_prototype_fill (ecma_value_t this_arg, /**< this object */
        -: 1029:                                        ecma_typedarray_info_t *info_p, /**< object info */
        -: 1030:                                        ecma_value_t value, /**< value */
        -: 1031:                                        ecma_value_t begin, /**< begin */
        -: 1032:                                        ecma_value_t end) /**< end */
        -: 1033:{
        -: 1034:  ecma_value_t value_to_set;
        -: 1035:
    #####: 1036:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1037:  {
    #####: 1038:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1039:  }
        -: 1040:
        -: 1041:#if JERRY_BUILTIN_BIGINT
    #####: 1042:  if (ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id))
        -: 1043:  {
    #####: 1044:    value_to_set = ecma_bigint_to_bigint (value, true);
        -: 1045:
    #####: 1046:    if (ECMA_IS_VALUE_ERROR (value_to_set))
        -: 1047:    {
    #####: 1048:      return value_to_set;
        -: 1049:    }
        -: 1050:  }
        -: 1051:  else
        -: 1052:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1053:  {
    #####: 1054:    ecma_number_t value_num;
    #####: 1055:    ecma_value_t ret_value = ecma_op_to_numeric (value, &value_num, ECMA_TO_NUMERIC_NO_OPTS);
        -: 1056:
    #####: 1057:    if (!ecma_is_value_empty (ret_value))
        -: 1058:    {
    #####: 1059:      return ret_value;
        -: 1060:    }
        -: 1061:
    #####: 1062:    value_to_set = ecma_make_number_value (value_num);
        -: 1063:  }
        -: 1064:
    #####: 1065:  uint32_t begin_index_uint32 = 0, end_index_uint32 = 0;
        -: 1066:
    #####: 1067:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (begin, info_p->length, &begin_index_uint32)))
        -: 1068:  {
    #####: 1069:    ecma_free_value (value_to_set);
    #####: 1070:    return ECMA_VALUE_ERROR;
        -: 1071:  }
        -: 1072:
    #####: 1073:  if (ecma_is_value_undefined (end))
        -: 1074:  {
    #####: 1075:    end_index_uint32 = (uint32_t) info_p->length;
        -: 1076:  }
        -: 1077:  else
        -: 1078:  {
    #####: 1079:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (end, info_p->length, &end_index_uint32)))
        -: 1080:    {
    #####: 1081:      ecma_free_value (value_to_set);
    #####: 1082:      return ECMA_VALUE_ERROR;
        -: 1083:    }
        -: 1084:  }
        -: 1085:
    #####: 1086:  uint32_t subarray_length = 0;
        -: 1087:
    #####: 1088:  if (end_index_uint32 > begin_index_uint32)
        -: 1089:  {
    #####: 1090:    subarray_length = end_index_uint32 - begin_index_uint32;
        -: 1091:  }
        -: 1092:
    #####: 1093:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1094:  {
    #####: 1095:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1096:  }
        -: 1097:
    #####: 1098:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1099:
    #####: 1100:  buffer_p += begin_index_uint32 << info_p->shift;
        -: 1101:
    #####: 1102:  uint8_t *limit_p = buffer_p + (subarray_length << info_p->shift);
    #####: 1103:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info_p->id);
        -: 1104:
    #####: 1105:  while (buffer_p < limit_p)
        -: 1106:  {
    #####: 1107:    ecma_value_t set_element = typedarray_setter_cb (buffer_p, value_to_set);
        -: 1108:
    #####: 1109:    if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1110:    {
    #####: 1111:      ecma_free_value (value_to_set);
    #####: 1112:      return set_element;
        -: 1113:    }
        -: 1114:
    #####: 1115:    buffer_p += info_p->element_size;
        -: 1116:  }
        -: 1117:
    #####: 1118:  ecma_free_value (value_to_set);
        -: 1119:
    #####: 1120:  return ecma_copy_value (this_arg);
        -: 1121:} /* ecma_builtin_typedarray_prototype_fill */
        -: 1122:
        -: 1123:/**
        -: 1124: * SortCompare abstract method
        -: 1125: *
        -: 1126: * See also:
        -: 1127: *          ECMA-262 v5, 15.4.4.11
        -: 1128: *
        -: 1129: * @return ecma value
        -: 1130: *         Returned value must be freed with ecma_free_value.
        -: 1131: */
        -: 1132:static ecma_value_t
    #####: 1133:ecma_builtin_typedarray_prototype_sort_compare_helper (ecma_value_t lhs, /**< left value */
        -: 1134:                                                       ecma_value_t rhs, /**< right value */
        -: 1135:                                                       ecma_value_t compare_func, /**< compare function */
        -: 1136:                                                       ecma_object_t *array_buffer_p) /**< array buffer */
        -: 1137:{
    #####: 1138:  if (ecma_is_value_undefined (compare_func))
        -: 1139:  {
        -: 1140:    /* Default comparison when no comparefn is passed. */
        -: 1141:#if JERRY_BUILTIN_BIGINT
    #####: 1142:    if (ecma_is_value_bigint (lhs) && ecma_is_value_bigint (rhs))
        -: 1143:    {
    #####: 1144:      return ecma_make_number_value (ecma_bigint_compare_to_bigint (lhs, rhs));
        -: 1145:    }
        -: 1146:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1147:
    #####: 1148:    ecma_number_t result = ECMA_NUMBER_ZERO;
        -: 1149:
    #####: 1150:    double lhs_value = (double) ecma_get_number_from_value (lhs);
    #####: 1151:    double rhs_value = (double) ecma_get_number_from_value (rhs);
        -: 1152:
    #####: 1153:    if (ecma_number_is_nan (lhs_value))
        -: 1154:    {
        -: 1155:      // Keep NaNs at the end of the array.
    #####: 1156:      result = ECMA_NUMBER_ONE;
        -: 1157:    }
    #####: 1158:    else if (ecma_number_is_nan (rhs_value))
        -: 1159:    {
        -: 1160:      // Keep NaNs at the end of the array.
    #####: 1161:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1162:    }
    #####: 1163:    else if (lhs_value < rhs_value)
        -: 1164:    {
    #####: 1165:      result = ECMA_NUMBER_MINUS_ONE;
        -: 1166:    }
    #####: 1167:    else if (lhs_value > rhs_value || (ecma_number_is_zero (rhs_value) && ecma_number_is_negative (rhs_value)))
        -: 1168:    {
    #####: 1169:      result = ECMA_NUMBER_ONE;
        -: 1170:    }
        -: 1171:    else
        -: 1172:    {
    #####: 1173:      result = ECMA_NUMBER_ZERO;
        -: 1174:    }
        -: 1175:
    #####: 1176:    return ecma_make_number_value (result);
        -: 1177:  }
        -: 1178:
        -: 1179:  /*
        -: 1180:   * compare_func, if not undefined, will always contain a callable function object.
        -: 1181:   * We checked this previously, before this function was called.
        -: 1182:   */
    #####: 1183:  JERRY_ASSERT (ecma_op_is_callable (compare_func));
    #####: 1184:  ecma_object_t *comparefn_obj_p = ecma_get_object_from_value (compare_func);
        -: 1185:
    #####: 1186:  ecma_value_t compare_args[] = { lhs, rhs };
        -: 1187:
    #####: 1188:  ecma_value_t call_value = ecma_op_function_call (comparefn_obj_p, ECMA_VALUE_UNDEFINED, compare_args, 2);
        -: 1189:
    #####: 1190:  if (ECMA_IS_VALUE_ERROR (call_value) || ecma_is_value_number (call_value))
        -: 1191:  {
    #####: 1192:    return call_value;
        -: 1193:  }
        -: 1194:
    #####: 1195:  ecma_number_t ret_num;
    #####: 1196:  ecma_value_t number_result = ecma_op_to_number (call_value, &ret_num);
        -: 1197:
    #####: 1198:  ecma_free_value (call_value);
        -: 1199:
    #####: 1200:  if (ECMA_IS_VALUE_ERROR (number_result))
        -: 1201:  {
    #####: 1202:    return number_result;
        -: 1203:  }
        -: 1204:
    #####: 1205:  if (ecma_arraybuffer_is_detached (array_buffer_p))
        -: 1206:  {
    #####: 1207:    ecma_free_value (number_result);
    #####: 1208:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1209:  }
        -: 1210:
        -: 1211:  // If the coerced value can't be represented as a Number, compare them as equals.
    #####: 1212:  if (ecma_number_is_nan (ret_num))
        -: 1213:  {
    #####: 1214:    return ecma_make_number_value (ECMA_NUMBER_ZERO);
        -: 1215:  }
        -: 1216:
    #####: 1217:  return ecma_make_number_value (ret_num);
        -: 1218:} /* ecma_builtin_typedarray_prototype_sort_compare_helper */
        -: 1219:
        -: 1220:/**
        -: 1221: * The %TypedArray%.prototype object's 'sort' routine.
        -: 1222: *
        -: 1223: * See also:
        -: 1224: *          ES2015, 22.2.3.25, 22.1.3.24
        -: 1225: *
        -: 1226: * @return ecma value
        -: 1227: *         Returned value must be freed with ecma_free_value.
        -: 1228: */
        -: 1229:static ecma_value_t
    #####: 1230:ecma_builtin_typedarray_prototype_sort (ecma_value_t this_arg, /**< this argument */
        -: 1231:                                        ecma_typedarray_info_t *info_p, /**< object info */
        -: 1232:                                        ecma_value_t compare_func) /**< comparator fn */
        -: 1233:{
    #####: 1234:  JERRY_ASSERT (ecma_is_typedarray (this_arg));
    #####: 1235:  JERRY_ASSERT (ecma_is_value_undefined (compare_func) || ecma_op_is_callable (compare_func));
        -: 1236:
    #####: 1237:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1238:  {
    #####: 1239:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1240:  }
        -: 1241:
    #####: 1242:  if (!info_p->length)
        -: 1243:  {
    #####: 1244:    return ecma_copy_value (this_arg);
        -: 1245:  }
        -: 1246:
    #####: 1247:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
    #####: 1248:  JMEM_DEFINE_LOCAL_ARRAY (values_buffer, info_p->length, ecma_value_t);
        -: 1249:
    #####: 1250:  uint32_t buffer_index = 0;
        -: 1251:
    #####: 1252:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1253:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####: 1254:  uint8_t *limit_p = buffer_p + (info_p->length << info_p->shift);
        -: 1255:
        -: 1256:  /* Copy unsorted array into a native c array. */
    #####: 1257:  while (buffer_p < limit_p)
        -: 1258:  {
    #####: 1259:    JERRY_ASSERT (buffer_index < info_p->length);
    #####: 1260:    ecma_value_t element_value = typedarray_getter_cb (buffer_p);
    #####: 1261:    values_buffer[buffer_index++] = element_value;
    #####: 1262:    buffer_p += info_p->element_size;
        -: 1263:  }
        -: 1264:
    #####: 1265:  JERRY_ASSERT (buffer_index == info_p->length);
        -: 1266:
    #####: 1267:  const ecma_builtin_helper_sort_compare_fn_t sort_cb = &ecma_builtin_typedarray_prototype_sort_compare_helper;
        -: 1268:
    #####: 1269:  ecma_value_t sort_value = ecma_builtin_helper_array_merge_sort_helper (values_buffer,
    #####: 1270:                                                                         (uint32_t) (info_p->length),
        -: 1271:                                                                         compare_func,
        -: 1272:                                                                         sort_cb,
        -: 1273:                                                                         info_p->array_buffer_p);
        -: 1274:
    #####: 1275:  if (ECMA_IS_VALUE_ERROR (sort_value))
        -: 1276:  {
    #####: 1277:    ret_value = sort_value;
    #####: 1278:    goto free_values;
        -: 1279:  }
        -: 1280:
    #####: 1281:  JERRY_ASSERT (sort_value == ECMA_VALUE_EMPTY);
        -: 1282:
    #####: 1283:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1284:  {
    #####: 1285:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1286:  }
        -: 1287:
    #####: 1288:  ecma_typedarray_setter_fn_t typedarray_setter_cb = ecma_get_typedarray_setter_fn (info_p->id);
        -: 1289:
    #####: 1290:  buffer_p = limit_p - (info_p->length << info_p->shift);
    #####: 1291:  buffer_index = 0;
        -: 1292:
        -: 1293:  /* Put sorted values from the native array back into the typedarray buffer. */
    #####: 1294:  while (buffer_p < limit_p)
        -: 1295:  {
    #####: 1296:    JERRY_ASSERT (buffer_index < info_p->length);
    #####: 1297:    ecma_value_t element_value = values_buffer[buffer_index++];
    #####: 1298:    ecma_value_t set_element = typedarray_setter_cb (buffer_p, element_value);
        -: 1299:
    #####: 1300:    if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1301:    {
    #####: 1302:      ret_value = set_element;
    #####: 1303:      goto free_values;
        -: 1304:    }
        -: 1305:
    #####: 1306:    buffer_p += info_p->element_size;
        -: 1307:  }
        -: 1308:
    #####: 1309:  JERRY_ASSERT (buffer_index == info_p->length);
        -: 1310:
    #####: 1311:  ret_value = ecma_copy_value (this_arg);
        -: 1312:
    #####: 1313:free_values:
        -: 1314:  /* Free values that were copied to the local array. */
    #####: 1315:  for (uint32_t index = 0; index < info_p->length; index++)
        -: 1316:  {
    #####: 1317:    ecma_free_value (values_buffer[index]);
        -: 1318:  }
        -: 1319:
    #####: 1320:  JMEM_FINALIZE_LOCAL_ARRAY (values_buffer);
        -: 1321:
    #####: 1322:  return ret_value;
        -: 1323:} /* ecma_builtin_typedarray_prototype_sort */
        -: 1324:
        -: 1325:/**
        -: 1326: * The %TypedArray%.prototype object's 'find' and 'findIndex' routine helper
        -: 1327: *
        -: 1328: * @return ecma value
        -: 1329: *         Returned value must be freed with ecma_free_value.
        -: 1330: */
        -: 1331:static ecma_value_t
    #####: 1332:ecma_builtin_typedarray_prototype_find_helper (ecma_value_t this_arg, /**< this argument */
        -: 1333:                                               ecma_typedarray_info_t *info_p, /**< object info */
        -: 1334:                                               ecma_value_t predicate, /**< callback function */
        -: 1335:                                               ecma_value_t predicate_this_arg, /**< this argument for
        -: 1336:                                                                                 *   invoke predicate */
        -: 1337:                                               bool is_find) /**< true - find routine
        -: 1338:                                                              *   false - findIndex routine */
        -: 1339:{
    #####: 1340:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1341:  {
    #####: 1342:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1343:  }
        -: 1344:
    #####: 1345:  JERRY_ASSERT (ecma_is_value_object (predicate));
    #####: 1346:  ecma_object_t *func_object_p = ecma_get_object_from_value (predicate);
    #####: 1347:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####: 1348:  uint8_t *limit_p = buffer_p + (info_p->length << info_p->shift);
    #####: 1349:  ecma_typedarray_getter_fn_t typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1350:  uint32_t buffer_index = 0;
        -: 1351:
    #####: 1352:  while (buffer_p < limit_p)
        -: 1353:  {
    #####: 1354:    JERRY_ASSERT (buffer_index < info_p->length);
    #####: 1355:    ecma_value_t element_value = typedarray_getter_cb (buffer_p);
    #####: 1356:    buffer_p += info_p->element_size;
        -: 1357:
    #####: 1358:    ecma_value_t call_args[] = { element_value, ecma_make_uint32_value (buffer_index), this_arg };
    #####: 1359:    ecma_value_t call_value = ecma_op_function_call (func_object_p, predicate_this_arg, call_args, 3);
        -: 1360:
    #####: 1361:    if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1362:    {
    #####: 1363:      ecma_free_value (element_value);
    #####: 1364:      return call_value;
        -: 1365:    }
        -: 1366:
    #####: 1367:    if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1368:    {
    #####: 1369:      ecma_free_value (element_value);
    #####: 1370:      ecma_free_value (call_value);
    #####: 1371:      return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1372:    }
        -: 1373:
    #####: 1374:    bool call_result = ecma_op_to_boolean (call_value);
    #####: 1375:    ecma_free_value (call_value);
        -: 1376:
    #####: 1377:    if (call_result)
        -: 1378:    {
    #####: 1379:      if (is_find)
        -: 1380:      {
    #####: 1381:        return element_value;
        -: 1382:      }
        -: 1383:
    #####: 1384:      ecma_free_value (element_value);
    #####: 1385:      return ecma_make_uint32_value (buffer_index);
        -: 1386:    }
        -: 1387:
    #####: 1388:    buffer_index++;
    #####: 1389:    ecma_free_value (element_value);
        -: 1390:  }
        -: 1391:
    #####: 1392:  return is_find ? ECMA_VALUE_UNDEFINED : ecma_make_integer_value (-1);
        -: 1393:} /* ecma_builtin_typedarray_prototype_find_helper */
        -: 1394:
        -: 1395:/**
        -: 1396: * The %TypedArray%.prototype object's 'at' routine
        -: 1397: *
        -: 1398: * See also:
        -: 1399: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -: 1400: *          from: https://tc39.es/proposal-relative-indexing-method
        -: 1401: *
        -: 1402: * @return ecma value
        -: 1403: *         Returned value must be freed with ecma_free_value.
        -: 1404: */
        -: 1405:static ecma_value_t
    #####: 1406:ecma_builtin_typedarray_prototype_at (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1407:                                      const ecma_value_t index) /**< index argument */
        -: 1408:{
    #####: 1409:  ecma_length_t len = info_p->length;
    #####: 1410:  ecma_length_t res_index;
    #####: 1411:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -: 1412:
    #####: 1413:  if (return_value != ECMA_VALUE_EMPTY)
        -: 1414:  {
    #####: 1415:    return return_value;
        -: 1416:  }
        -: 1417:
    #####: 1418:  if (res_index >= UINT32_MAX)
        -: 1419:  {
    #####: 1420:    return ECMA_VALUE_UNDEFINED;
        -: 1421:  }
        -: 1422:
    #####: 1423:  return ecma_get_typedarray_element (info_p, (uint32_t) res_index);
        -: 1424:} /* ecma_builtin_typedarray_prototype_at */
        -: 1425:
        -: 1426:/**
        -: 1427: * The %TypedArray%.prototype object's 'indexOf' routine
        -: 1428: *
        -: 1429: * See also:
        -: 1430: *         ECMA-262 v6, 22.2.3.13
        -: 1431: *
        -: 1432: * @return ecma value
        -: 1433: *         Returned value must be freed with ecma_free_value.
        -: 1434: */
        -: 1435:static ecma_value_t
    #####: 1436:ecma_builtin_typedarray_prototype_index_of (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1437:                                            const ecma_value_t args[], /**< arguments list */
        -: 1438:                                            uint32_t args_number) /**< number of arguments */
        -: 1439:{
    #####: 1440:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1441:  {
    #####: 1442:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1443:  }
        -: 1444:
        -: 1445:#if JERRY_BUILTIN_BIGINT
    #####: 1446:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1447:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1448:  bool is_bigint = false;
        -: 1449:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1450:
    #####: 1451:  uint32_t from_index;
        -: 1452:
        -: 1453:  /* 5. */
    #####: 1454:  if (args_number == 0 || (!ecma_is_value_number (args[0]) && !is_bigint) || info_p->length == 0)
        -: 1455:  {
    #####: 1456:    return ecma_make_integer_value (-1);
        -: 1457:  }
    #####: 1458:  if (args_number == 1)
        -: 1459:  {
    #####: 1460:    from_index = 0;
        -: 1461:  }
        -: 1462:  else
        -: 1463:  {
    #####: 1464:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1], info_p->length, &from_index)))
        -: 1465:    {
    #####: 1466:      return ECMA_VALUE_ERROR;
        -: 1467:    }
        -: 1468:  }
        -: 1469:
    #####: 1470:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1471:
    #####: 1472:  uint8_t *limit_p = buffer_p + (info_p->length << info_p->shift);
    #####: 1473:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
        -: 1474:
    #####: 1475:  buffer_p += from_index << info_p->shift;
        -: 1476:
        -: 1477:  /* 11. */
    #####: 1478:  while (buffer_p < limit_p)
        -: 1479:  {
    #####: 1480:    ecma_value_t element = getter_cb (buffer_p);
        -: 1481:
    #####: 1482:    if (ecma_op_same_value_zero (args[0], element, true))
        -: 1483:    {
    #####: 1484:      ecma_free_value (element);
    #####: 1485:      return ecma_make_number_value (from_index);
        -: 1486:    }
        -: 1487:
    #####: 1488:    ecma_free_value (element);
    #####: 1489:    buffer_p += info_p->element_size;
    #####: 1490:    from_index++;
        -: 1491:  }
        -: 1492:
        -: 1493:  /* 12. */
    #####: 1494:  return ecma_make_integer_value (-1);
        -: 1495:} /* ecma_builtin_typedarray_prototype_index_of */
        -: 1496:
        -: 1497:/**
        -: 1498: * The %TypedArray%.prototype object's 'lastIndexOf' routine
        -: 1499: *
        -: 1500: * See also:
        -: 1501: *          ECMA-262 v6, 22.2.3.16
        -: 1502: *
        -: 1503: * @return ecma value
        -: 1504: *         Returned value must be freed with ecma_free_value.
        -: 1505: */
        -: 1506:static ecma_value_t
    #####: 1507:ecma_builtin_typedarray_prototype_last_index_of (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1508:                                                 const ecma_value_t args[], /**< arguments list */
        -: 1509:                                                 uint32_t args_number) /**< number of arguments */
        -: 1510:{
    #####: 1511:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1512:  {
    #####: 1513:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1514:  }
        -: 1515:
        -: 1516:#if JERRY_BUILTIN_BIGINT
    #####: 1517:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1518:#else /* !JERRY_BUILTIN_BIGINT */
        -: 1519:  bool is_bigint = false;
        -: 1520:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1521:
    #####: 1522:  uint32_t from_index;
        -: 1523:
        -: 1524:  /* 5. */
    #####: 1525:  if (args_number == 0 || (!ecma_is_value_number (args[0]) && !is_bigint) || info_p->length == 0)
        -: 1526:  {
    #####: 1527:    return ecma_make_integer_value (-1);
        -: 1528:  }
        -: 1529:
    #####: 1530:  if (args_number == 1)
        -: 1531:  {
    #####: 1532:    from_index = info_p->length - 1;
        -: 1533:  }
        -: 1534:  else
        -: 1535:  {
    #####: 1536:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1], info_p->length, &from_index)))
        -: 1537:    {
    #####: 1538:      return ECMA_VALUE_ERROR;
        -: 1539:    }
        -: 1540:
    #####: 1541:    ecma_number_t to_int;
        -: 1542:
    #####: 1543:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (args[1], &to_int)))
        -: 1544:    {
    #####: 1545:      return ECMA_VALUE_ERROR;
        -: 1546:    }
        -: 1547:
    #####: 1548:    if (info_p->length + to_int < 0)
        -: 1549:    {
    #####: 1550:      return ecma_make_integer_value (-1);
        -: 1551:    }
        -: 1552:
    #####: 1553:    from_index = JERRY_MIN (from_index, info_p->length - 1);
        -: 1554:  }
        -: 1555:
    #####: 1556:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1557:  uint8_t *buffer_p = ecma_arraybuffer_get_buffer (info_p->array_buffer_p) + info_p->offset;
    #####: 1558:  uint8_t *current_element_p = buffer_p + (from_index << info_p->shift);
        -: 1559:
        -: 1560:  /* 10. */
    #####: 1561:  while (current_element_p >= buffer_p)
        -: 1562:  {
    #####: 1563:    ecma_value_t element = getter_cb (current_element_p);
        -: 1564:
    #####: 1565:    if (ecma_op_same_value_zero (args[0], element, true))
        -: 1566:    {
    #####: 1567:      ecma_free_value (element);
    #####: 1568:      return ecma_make_number_value ((ecma_number_t) from_index);
        -: 1569:    }
        -: 1570:
    #####: 1571:    ecma_free_value (element);
    #####: 1572:    current_element_p -= info_p->element_size;
    #####: 1573:    from_index--;
        -: 1574:  }
        -: 1575:
        -: 1576:  /* 11. */
    #####: 1577:  return ecma_make_integer_value (-1);
        -: 1578:} /* ecma_builtin_typedarray_prototype_last_index_of */
        -: 1579:
        -: 1580:/**
        -: 1581: * The %TypedArray%.prototype object's 'copyWithin' routine
        -: 1582: *
        -: 1583: * See also:
        -: 1584: *          ECMA-262 v6, 22.2.3.5
        -: 1585: *
        -: 1586: * @return ecma value
        -: 1587: *         Returned value must be freed with ecma_free_value.
        -: 1588: */
        -: 1589:static ecma_value_t
    #####: 1590:ecma_builtin_typedarray_prototype_copy_within (ecma_value_t this_arg, /**< this argument */
        -: 1591:                                               ecma_typedarray_info_t *info_p, /**< object info */
        -: 1592:                                               const ecma_value_t args[], /**< arguments list */
        -: 1593:                                               uint32_t args_number) /**< number of arguments */
        -: 1594:{
    #####: 1595:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1596:  {
    #####: 1597:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1598:  }
        -: 1599:
    #####: 1600:  uint32_t relative_target = 0;
    #####: 1601:  uint32_t relative_start = 0;
    #####: 1602:  uint32_t relative_end = info_p->length;
        -: 1603:
    #####: 1604:  if (args_number > 0)
        -: 1605:  {
    #####: 1606:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[0], info_p->length, &relative_target)))
        -: 1607:    {
    #####: 1608:      return ECMA_VALUE_ERROR;
        -: 1609:    }
        -: 1610:
    #####: 1611:    if (args_number > 1)
        -: 1612:    {
    #####: 1613:      if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1], info_p->length, &relative_start)))
        -: 1614:      {
    #####: 1615:        return ECMA_VALUE_ERROR;
        -: 1616:      }
        -: 1617:
    #####: 1618:      if (args_number > 2 && args[2] != ECMA_VALUE_UNDEFINED)
        -: 1619:      {
    #####: 1620:        if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[2], info_p->length, &relative_end)))
        -: 1621:        {
    #####: 1622:          return ECMA_VALUE_ERROR;
        -: 1623:        }
        -: 1624:      }
        -: 1625:    }
        -: 1626:  }
        -: 1627:
    #####: 1628:  if (relative_target >= info_p->length || relative_start >= relative_end || relative_end == 0)
        -: 1629:  {
    #####: 1630:    return ecma_copy_value (this_arg);
        -: 1631:  }
        -: 1632:
    #####: 1633:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1634:  {
    #####: 1635:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1636:  }
        -: 1637:
    #####: 1638:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1639:
    #####: 1640:  uint32_t distance = relative_end - relative_start;
    #####: 1641:  uint32_t offset = info_p->length - relative_target;
    #####: 1642:  uint32_t count = JERRY_MIN (distance, offset);
        -: 1643:
    #####: 1644:  memmove (buffer_p + (relative_target << info_p->shift),
    #####: 1645:           buffer_p + (relative_start << info_p->shift),
    #####: 1646:           (size_t) (count << info_p->shift));
        -: 1647:
    #####: 1648:  return ecma_copy_value (this_arg);
        -: 1649:} /* ecma_builtin_typedarray_prototype_copy_within */
        -: 1650:
        -: 1651:/**
        -: 1652: * The %TypedArray%.prototype object's 'slice' routine
        -: 1653: *
        -: 1654: * See also:
        -: 1655: *          ECMA-262 v6, 22.2.3.23
        -: 1656: *
        -: 1657: * @return ecma value
        -: 1658: *         Returned value must be freed with ecma_free_value.
        -: 1659: */
        -: 1660:static ecma_value_t
    #####: 1661:ecma_builtin_typedarray_prototype_slice (ecma_value_t this_arg, /**< this argument */
        -: 1662:                                         ecma_typedarray_info_t *info_p, /**< object info */
        -: 1663:                                         const ecma_value_t args[], /**< arguments list */
        -: 1664:                                         uint32_t args_number) /**< number of arguments */
        -: 1665:{
    #####: 1666:  uint32_t relative_start = 0;
    #####: 1667:  uint32_t relative_end = info_p->length;
        -: 1668:
    #####: 1669:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1670:  {
    #####: 1671:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1672:  }
        -: 1673:
    #####: 1674:  if (args_number > 0)
        -: 1675:  {
    #####: 1676:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[0], info_p->length, &relative_start)))
        -: 1677:    {
    #####: 1678:      return ECMA_VALUE_ERROR;
        -: 1679:    }
        -: 1680:
    #####: 1681:    if (args_number > 1 && args[1] != ECMA_VALUE_UNDEFINED
    #####: 1682:        && ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1], info_p->length, &relative_end)))
        -: 1683:    {
    #####: 1684:      return ECMA_VALUE_ERROR;
        -: 1685:    }
        -: 1686:  }
        -: 1687:
    #####: 1688:  uint8_t *src_buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1689:
    #####: 1690:  int32_t distance = (int32_t) (relative_end - relative_start);
    #####: 1691:  uint32_t count = distance > 0 ? (uint32_t) distance : 0;
        -: 1692:
    #####: 1693:  ecma_value_t len = ecma_make_number_value (count);
        -: 1694:  // TODO: 22.2.3.23, 12-13.
    #####: 1695:  ecma_value_t new_typedarray = ecma_typedarray_species_create (this_arg, &len, 1);
    #####: 1696:  ecma_free_value (len);
        -: 1697:
    #####: 1698:  if (ECMA_IS_VALUE_ERROR (new_typedarray) || count == 0)
        -: 1699:  {
    #####: 1700:    return new_typedarray;
        -: 1701:  }
        -: 1702:
    #####: 1703:  ecma_object_t *new_typedarray_p = ecma_get_object_from_value (new_typedarray);
    #####: 1704:  ecma_typedarray_info_t new_typedarray_info = ecma_typedarray_get_info (new_typedarray_p);
        -: 1705:
    #####: 1706:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1707:  {
    #####: 1708:    ecma_deref_object (new_typedarray_p);
    #####: 1709:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1710:  }
        -: 1711:
    #####: 1712:  uint8_t *dst_buffer_p = ecma_typedarray_get_buffer (&new_typedarray_info);
        -: 1713:
    #####: 1714:  JERRY_ASSERT (new_typedarray_info.offset == 0);
        -: 1715:
    #####: 1716:  src_buffer_p += relative_start << info_p->shift;
        -: 1717:
    #####: 1718:  if (info_p->id == new_typedarray_info.id)
        -: 1719:  {
        -: 1720:    // 22.2.3.23. Step 22. h-i.
    #####: 1721:    memcpy (dst_buffer_p, src_buffer_p, count << info_p->shift);
        -: 1722:  }
        -: 1723:  else
        -: 1724:  {
        -: 1725:    // 22.2.3.23. Step 21. b.
    #####: 1726:    ecma_typedarray_getter_fn_t src_typedarray_getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1727:    ecma_typedarray_setter_fn_t new_typedarray_setter_cb = ecma_get_typedarray_setter_fn (new_typedarray_info.id);
        -: 1728:
    #####: 1729:    for (uint32_t idx = 0; idx < count; idx++)
        -: 1730:    {
    #####: 1731:      ecma_value_t element = src_typedarray_getter_cb (src_buffer_p);
    #####: 1732:      ecma_value_t set_element = new_typedarray_setter_cb (dst_buffer_p, element);
    #####: 1733:      ecma_free_value (element);
        -: 1734:
    #####: 1735:      if (ECMA_IS_VALUE_ERROR (set_element))
        -: 1736:      {
    #####: 1737:        ecma_deref_object (new_typedarray_p);
    #####: 1738:        return set_element;
        -: 1739:      }
        -: 1740:
    #####: 1741:      src_buffer_p += info_p->element_size;
    #####: 1742:      dst_buffer_p += new_typedarray_info.element_size;
        -: 1743:    }
        -: 1744:  }
        -: 1745:
    #####: 1746:  return new_typedarray;
        -: 1747:} /* ecma_builtin_typedarray_prototype_slice */
        -: 1748:
        -: 1749:/**
        -: 1750: * The TypedArray.prototype's 'toLocaleString' single element operation routine.
        -: 1751: *
        -: 1752: * See also:
        -: 1753: *          ECMA-262 v6, 22.1.3.26 steps 7-10 and 12.b-e
        -: 1754: *
        -: 1755: * @return ecma value
        -: 1756: *         Returned value must be freed with ecma_free_value.
        -: 1757: */
        -: 1758:static ecma_value_t
    #####: 1759:ecma_builtin_typedarray_prototype_to_locale_string_helper (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1760:                                                           uint32_t index) /** array index */
        -: 1761:{
    #####: 1762:  ecma_value_t element_value = ecma_get_typedarray_element (info_p, index);
        -: 1763:
    #####: 1764:  if (ECMA_IS_VALUE_ERROR (element_value))
        -: 1765:  {
    #####: 1766:    return element_value;
        -: 1767:  }
        -: 1768:
    #####: 1769:  ecma_value_t call_value = ecma_op_invoke_by_magic_id (element_value, LIT_MAGIC_STRING_TO_LOCALE_STRING_UL, NULL, 0);
        -: 1770:
    #####: 1771:  ecma_free_value (element_value);
        -: 1772:
    #####: 1773:  if (ECMA_IS_VALUE_ERROR (call_value))
        -: 1774:  {
    #####: 1775:    return call_value;
        -: 1776:  }
        -: 1777:
    #####: 1778:  ecma_string_t *str_p = ecma_op_to_string (call_value);
        -: 1779:
    #####: 1780:  ecma_free_value (call_value);
        -: 1781:
    #####: 1782:  if (JERRY_UNLIKELY (str_p == NULL))
        -: 1783:  {
    #####: 1784:    return ECMA_VALUE_ERROR;
        -: 1785:  }
        -: 1786:
    #####: 1787:  return ecma_make_string_value (str_p);
        -: 1788:} /* ecma_builtin_typedarray_prototype_to_locale_string_helper */
        -: 1789:
        -: 1790:/**
        -: 1791: * The %TypedArray%.prototype object's 'toLocaleString' routine
        -: 1792: *
        -: 1793: * See also:
        -: 1794: *          ECMA-262 v6, 22.2.3.27
        -: 1795: *
        -: 1796: * @return ecma value
        -: 1797: *         Returned value must be freed with ecma_free_value.
        -: 1798: */
        -: 1799:static ecma_value_t
    #####: 1800:ecma_builtin_typedarray_prototype_to_locale_string (ecma_typedarray_info_t *info_p) /**< object info */
        -: 1801:{
    #####: 1802:  if (info_p->length == 0)
        -: 1803:  {
    #####: 1804:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1805:  }
        -: 1806:
    #####: 1807:  ecma_value_t first_element = ecma_builtin_typedarray_prototype_to_locale_string_helper (info_p, 0);
        -: 1808:
    #####: 1809:  if (ECMA_IS_VALUE_ERROR (first_element))
        -: 1810:  {
    #####: 1811:    return first_element;
        -: 1812:  }
        -: 1813:
    #####: 1814:  ecma_string_t *return_string_p = ecma_get_string_from_value (first_element);
    #####: 1815:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (return_string_p);
    #####: 1816:  ecma_deref_ecma_string (return_string_p);
        -: 1817:
    #####: 1818:  for (uint32_t k = 1; k < info_p->length; k++)
        -: 1819:  {
    #####: 1820:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_COMMA);
    #####: 1821:    ecma_value_t next_element = ecma_builtin_typedarray_prototype_to_locale_string_helper (info_p, k);
        -: 1822:
    #####: 1823:    if (ECMA_IS_VALUE_ERROR (next_element))
        -: 1824:    {
    #####: 1825:      ecma_stringbuilder_destroy (&builder);
    #####: 1826:      return next_element;
        -: 1827:    }
        -: 1828:
    #####: 1829:    ecma_string_t *next_element_p = ecma_get_string_from_value (next_element);
    #####: 1830:    ecma_stringbuilder_append (&builder, next_element_p);
    #####: 1831:    ecma_deref_ecma_string (next_element_p);
        -: 1832:  }
        -: 1833:
    #####: 1834:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 1835:} /* ecma_builtin_typedarray_prototype_to_locale_string */
        -: 1836:
        -: 1837:/**
        -: 1838: * The %TypedArray%.prototype object's 'includes' routine
        -: 1839: *
        -: 1840: * See also:
        -: 1841: *          ECMA-262 v11, 22.2.3.13.
        -: 1842: */
        -: 1843:static ecma_value_t
    #####: 1844:ecma_builtin_typedarray_prototype_includes (ecma_typedarray_info_t *info_p, /**< object info */
        -: 1845:                                            const ecma_value_t args[], /**< arguments list */
        -: 1846:                                            uint32_t args_number) /**< number of arguments */
        -: 1847:{
        -: 1848:#if JERRY_BUILTIN_BIGINT
    #####: 1849:  bool is_bigint = ECMA_TYPEDARRAY_IS_BIGINT_TYPE (info_p->id);
        -: 1850:#else /* !JERRRY_BUILTIN_BIGINT */
        -: 1851:  bool is_bigint = false;
        -: 1852:#endif /* JERRRY_BUILTIN_BIGINT */
        -: 1853:
    #####: 1854:  if (ecma_arraybuffer_is_detached (info_p->array_buffer_p))
        -: 1855:  {
    #####: 1856:    return ecma_raise_type_error (ECMA_ERR_ARRAYBUFFER_IS_DETACHED);
        -: 1857:  }
        -: 1858:
    #####: 1859:  if (args_number == 0 || (!ecma_is_value_number (args[0]) && !is_bigint) || info_p->length == 0)
        -: 1860:  {
    #####: 1861:    return ECMA_VALUE_FALSE;
        -: 1862:  }
        -: 1863:
    #####: 1864:  uint32_t from_index = 0;
        -: 1865:
    #####: 1866:  if (args_number > 1)
        -: 1867:  {
    #####: 1868:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (args[1], info_p->length, &from_index)))
        -: 1869:    {
    #####: 1870:      return ECMA_VALUE_ERROR;
        -: 1871:    }
        -: 1872:  }
        -: 1873:
    #####: 1874:  uint8_t *buffer_p = ecma_typedarray_get_buffer (info_p);
        -: 1875:
    #####: 1876:  ecma_typedarray_getter_fn_t getter_cb = ecma_get_typedarray_getter_fn (info_p->id);
    #####: 1877:  uint8_t *limit_p = buffer_p + (info_p->length << info_p->shift);
        -: 1878:
    #####: 1879:  buffer_p += from_index << info_p->shift;
        -: 1880:
    #####: 1881:  while (buffer_p < limit_p)
        -: 1882:  {
    #####: 1883:    ecma_value_t element = getter_cb (buffer_p);
        -: 1884:
    #####: 1885:    if (ecma_op_same_value_zero (args[0], element, false))
        -: 1886:    {
    #####: 1887:      ecma_free_value (element);
    #####: 1888:      return ECMA_VALUE_TRUE;
        -: 1889:    }
        -: 1890:
    #####: 1891:    ecma_free_value (element);
    #####: 1892:    buffer_p += info_p->element_size;
        -: 1893:  }
        -: 1894:
    #####: 1895:  return ECMA_VALUE_FALSE;
        -: 1896:} /* ecma_builtin_typedarray_prototype_includes */
        -: 1897:
        -: 1898:/**
        -: 1899: *
        -: 1900: * @return ecma value
        -: 1901: *         Returned value must be freed with ecma_free_value.
        -: 1902: */
        -: 1903:ecma_value_t
    #####: 1904:ecma_builtin_typedarray_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide
        -: 1905:                                                                                 *   routine identifier */
        -: 1906:                                                    ecma_value_t this_arg, /**< 'this' argument value */
        -: 1907:                                                    const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1908:                                                                                            *   passed to routine */
        -: 1909:                                                    uint32_t arguments_number) /**< length of arguments' list */
        -: 1910:{
    #####: 1911:  if (!ecma_is_typedarray (this_arg))
        -: 1912:  {
    #####: 1913:    if (builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER)
        -: 1914:    {
    #####: 1915:      return ECMA_VALUE_UNDEFINED;
        -: 1916:    }
        -: 1917:
    #####: 1918:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_TYPED_ARRAY);
        -: 1919:  }
        -: 1920:
    #####: 1921:  ecma_object_t *typedarray_p = ecma_get_object_from_value (this_arg);
    #####: 1922:  ecma_typedarray_info_t info = { 0 };
        -: 1923:
    #####: 1924:  if (builtin_routine_id < ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER)
        -: 1925:  {
    #####: 1926:    info = ecma_typedarray_get_info (typedarray_p);
        -: 1927:
    #####: 1928:    if (builtin_routine_id != ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY
    #####: 1929:        && ECMA_ARRAYBUFFER_LAZY_ALLOC (info.array_buffer_p))
        -: 1930:    {
    #####: 1931:      return ECMA_VALUE_ERROR;
        -: 1932:    }
        -: 1933:  }
        -: 1934:
    #####: 1935:  if (builtin_routine_id < ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF && !ecma_op_is_callable (arguments_list_p[0]))
        -: 1936:  {
    #####: 1937:    return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -: 1938:  }
        -: 1939:
    #####: 1940:  switch (builtin_routine_id)
        -: 1941:  {
    #####: 1942:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INCLUDES:
        -: 1943:    {
    #####: 1944:      return ecma_builtin_typedarray_prototype_includes (&info, arguments_list_p, arguments_number);
        -: 1945:    }
    #####: 1946:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_JOIN:
        -: 1947:    {
    #####: 1948:      return ecma_builtin_typedarray_prototype_join (typedarray_p, arguments_list_p[0]);
        -: 1949:    }
    #####: 1950:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY:
        -: 1951:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SOME:
        -: 1952:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FOR_EACH:
        -: 1953:    {
    #####: 1954:      uint8_t offset = (uint8_t) (builtin_routine_id - ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_EVERY);
        -: 1955:
    #####: 1956:      return ecma_builtin_typedarray_prototype_exec_routine (this_arg,
        -: 1957:                                                             &info,
        -: 1958:                                                             arguments_list_p[0],
    #####: 1959:                                                             arguments_list_p[1],
        -: 1960:                                                             offset);
        -: 1961:    }
    #####: 1962:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_MAP:
        -: 1963:    {
    #####: 1964:      return ecma_builtin_typedarray_prototype_map (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1965:    }
    #####: 1966:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE:
        -: 1967:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT:
        -: 1968:    {
    #####: 1969:      bool is_reduce = builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REDUCE_RIGHT;
    #####: 1970:      return ecma_builtin_typedarray_prototype_reduce_with_direction (this_arg,
        -: 1971:                                                                      &info,
        -: 1972:                                                                      arguments_list_p,
        -: 1973:                                                                      arguments_number,
        -: 1974:                                                                      is_reduce);
        -: 1975:    }
    #####: 1976:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILTER:
        -: 1977:    {
    #####: 1978:      return ecma_builtin_typedarray_prototype_filter (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1979:    }
    #####: 1980:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_REVERSE:
        -: 1981:    {
    #####: 1982:      return ecma_builtin_typedarray_prototype_reverse (this_arg, &info);
        -: 1983:    }
    #####: 1984:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SET:
        -: 1985:    {
    #####: 1986:      return ecma_builtin_typedarray_prototype_set (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -: 1987:    }
    #####: 1988:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SUBARRAY:
        -: 1989:    {
    #####: 1990:      return ecma_builtin_typedarray_prototype_subarray (this_arg, &info, arguments_list_p[0], arguments_list_p[1]);
        -: 1991:    }
    #####: 1992:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FILL:
        -: 1993:    {
    #####: 1994:      return ecma_builtin_typedarray_prototype_fill (this_arg,
        -: 1995:                                                     &info,
        -: 1996:                                                     arguments_list_p[0],
    #####: 1997:                                                     arguments_list_p[1],
    #####: 1998:                                                     arguments_list_p[2]);
        -: 1999:    }
    #####: 2000:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SORT:
        -: 2001:    {
    #####: 2002:      if (!ecma_is_value_undefined (arguments_list_p[0]) && !ecma_op_is_callable (arguments_list_p[0]))
        -: 2003:      {
    #####: 2004:        return ecma_raise_type_error (ECMA_ERR_CALLBACK_IS_NOT_CALLABLE);
        -: 2005:      }
        -: 2006:
    #####: 2007:      return ecma_builtin_typedarray_prototype_sort (this_arg, &info, arguments_list_p[0]);
        -: 2008:    }
    #####: 2009:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND:
        -: 2010:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND_INDEX:
        -: 2011:    {
    #####: 2012:      bool is_find = builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_FIND;
    #####: 2013:      return ecma_builtin_typedarray_prototype_find_helper (this_arg,
        -: 2014:                                                            &info,
        -: 2015:                                                            arguments_list_p[0],
    #####: 2016:                                                            arguments_list_p[1],
        -: 2017:                                                            is_find);
        -: 2018:    }
    #####: 2019:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_AT:
        -: 2020:    {
    #####: 2021:      return ecma_builtin_typedarray_prototype_at (&info, arguments_list_p[0]);
        -: 2022:    }
    #####: 2023:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_INDEX_OF:
        -: 2024:    {
    #####: 2025:      return ecma_builtin_typedarray_prototype_index_of (&info, arguments_list_p, arguments_number);
        -: 2026:    }
    #####: 2027:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LAST_INDEX_OF:
        -: 2028:    {
    #####: 2029:      return ecma_builtin_typedarray_prototype_last_index_of (&info, arguments_list_p, arguments_number);
        -: 2030:    }
    #####: 2031:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_COPY_WITHIN:
        -: 2032:    {
    #####: 2033:      return ecma_builtin_typedarray_prototype_copy_within (this_arg, &info, arguments_list_p, arguments_number);
        -: 2034:    }
    #####: 2035:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_SLICE:
        -: 2036:    {
    #####: 2037:      return ecma_builtin_typedarray_prototype_slice (this_arg, &info, arguments_list_p, arguments_number);
        -: 2038:    }
    #####: 2039:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_LOCALE_STRING:
        -: 2040:    {
    #####: 2041:      return ecma_builtin_typedarray_prototype_to_locale_string (&info);
        -: 2042:    }
    #####: 2043:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS:
        -: 2044:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_ENTRIES:
        -: 2045:    {
    #####: 2046:      ecma_iterator_kind_t iter_id =
    #####: 2047:        (builtin_routine_id == ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_KEYS) ? ECMA_ITERATOR_KEYS : ECMA_ITERATOR_ENTRIES;
        -: 2048:
    #####: 2049:      return ecma_typedarray_iterators_helper (this_arg, iter_id);
        -: 2050:    }
    #####: 2051:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BUFFER_GETTER:
        -: 2052:    {
    #####: 2053:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
    #####: 2054:      ecma_ref_object (buffer_p);
        -: 2055:
    #####: 2056:      return ecma_make_object_value (buffer_p);
        -: 2057:    }
    #####: 2058:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTELENGTH_GETTER:
        -: 2059:    {
    #####: 2060:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 2061:
    #####: 2062:      if (ecma_arraybuffer_is_detached (buffer_p))
        -: 2063:      {
    #####: 2064:        return ecma_make_uint32_value (0);
        -: 2065:      }
        -: 2066:
    #####: 2067:      uint32_t length = ecma_typedarray_get_length (typedarray_p);
    #####: 2068:      uint8_t shift = ecma_typedarray_get_element_size_shift (typedarray_p);
    #####: 2069:      return ecma_make_uint32_value (length << shift);
        -: 2070:    }
    #####: 2071:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_BYTEOFFSET_GETTER:
        -: 2072:    {
    #####: 2073:      return ecma_make_uint32_value (ecma_typedarray_get_offset (typedarray_p));
        -: 2074:    }
    #####: 2075:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_LENGTH_GETTER:
        -: 2076:    {
    #####: 2077:      ecma_object_t *buffer_p = ecma_typedarray_get_arraybuffer (typedarray_p);
        -: 2078:
    #####: 2079:      if (ecma_arraybuffer_is_detached (buffer_p))
        -: 2080:      {
    #####: 2081:        return ecma_make_uint32_value (0);
        -: 2082:      }
        -: 2083:
    #####: 2084:      return ecma_make_uint32_value (ecma_typedarray_get_length (typedarray_p));
        -: 2085:    }
    #####: 2086:    case ECMA_TYPEDARRAY_PROTOTYPE_ROUTINE_TO_STRING_TAG_GETTER:
        -: 2087:    {
    #####: 2088:      ecma_extended_object_t *object_p = (ecma_extended_object_t *) typedarray_p;
    #####: 2089:      return ecma_make_magic_string_value (ecma_get_typedarray_magic_string_id (object_p->u.cls.u1.typedarray_type));
        -: 2090:    }
    #####: 2091:    default:
        -: 2092:    {
    #####: 2093:      JERRY_UNREACHABLE ();
        -: 2094:    }
        -: 2095:  }
        -: 2096:} /* ecma_builtin_typedarray_prototype_dispatch_routine */
        -: 2097:
        -: 2098:/**
        -: 2099: * @}
        -: 2100: * @}
        -: 2101: * @}
        -: 2102: */
        -: 2103:
        -: 2104:#endif /* JERRY_BUILTIN_TYPEDARRAY */
