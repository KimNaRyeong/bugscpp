        -:    0:Source:/home/workspace/tests/unit-core/test-api.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "jerryscript.h"
        -:   17:
        -:   18:#include "config.h"
        -:   19:#include "test-common.h"
        -:   20:
        -:   21:const jerry_char_t test_source[] =
        -:   22:  TEST_STRING_LITERAL ("function assert (arg) { "
        -:   23:                       "  if (!arg) { "
        -:   24:                       "    throw Error('Assert failed');"
        -:   25:                       "  } "
        -:   26:                       "} "
        -:   27:                       "this.t = 1; "
        -:   28:                       "function f () { "
        -:   29:                       "return this.t; "
        -:   30:                       "} "
        -:   31:                       "this.foo = f; "
        -:   32:                       "this.bar = function (a) { "
        -:   33:                       "return a + t; "
        -:   34:                       "}; "
        -:   35:                       "function A () { "
        -:   36:                       "this.t = 12; "
        -:   37:                       "} "
        -:   38:                       "this.A = A; "
        -:   39:                       "this.a = new A (); "
        -:   40:                       "function call_external () { "
        -:   41:                       "  return this.external ('1', true); "
        -:   42:                       "} "
        -:   43:                       "function call_throw_test() { "
        -:   44:                       "  var catched = false; "
        -:   45:                       "  try { "
        -:   46:                       "    this.throw_test(); "
        -:   47:                       "  } catch (e) { "
        -:   48:                       "    catched = true; "
        -:   49:                       "    assert(e.name == 'TypeError'); "
        -:   50:                       "    assert(e.message == 'error'); "
        -:   51:                       "  } "
        -:   52:                       "  assert(catched); "
        -:   53:                       "} "
        -:   54:                       "function throw_reference_error() { "
        -:   55:                       " throw new ReferenceError ();"
        -:   56:                       "} "
        -:   57:                       "p = {'alpha':32, 'bravo':false, 'charlie':{}, 'delta':123.45, 'echo':'foobar'};"
        -:   58:                       "np = {}; Object.defineProperty (np, 'foxtrot', { "
        -:   59:                       "get: function() { throw 'error'; }, enumerable: true }) ");
        -:   60:
        -:   61:bool test_api_is_free_callback_was_called = false;
        -:   62:
        -:   63:static jerry_value_t
    #####:   64:handler (const jerry_call_info_t *call_info_p, /**< call information */
        -:   65:         const jerry_value_t args_p[], /**< arguments list */
        -:   66:         const jerry_length_t args_cnt) /**< arguments length */
        -:   67:{
        -:   68:  char buffer[32];
        -:   69:  jerry_size_t sz;
        -:   70:
    #####:   71:  printf ("ok %u %u %p %u\n",
    #####:   72:          (unsigned int) call_info_p->function,
    #####:   73:          (unsigned int) call_info_p->this_value,
        -:   74:          (void *) args_p,
        -:   75:          (unsigned int) args_cnt);
        -:   76:
    #####:   77:  TEST_ASSERT (args_cnt == 2);
        -:   78:
    #####:   79:  TEST_ASSERT (jerry_value_is_string (args_p[0]));
    #####:   80:  sz = jerry_string_size (args_p[0], JERRY_ENCODING_CESU8);
    #####:   81:  TEST_ASSERT (sz == 1);
    #####:   82:  sz = jerry_string_to_buffer (args_p[0], JERRY_ENCODING_CESU8, (jerry_char_t *) buffer, sz);
    #####:   83:  TEST_ASSERT (sz == 1);
    #####:   84:  TEST_ASSERT (!strncmp (buffer, "1", (size_t) sz));
        -:   85:
    #####:   86:  TEST_ASSERT (jerry_value_is_boolean (args_p[1]));
        -:   87:
    #####:   88:  return jerry_string_sz ("string from handler");
        -:   89:} /* handler */
        -:   90:
        -:   91:static jerry_value_t
    #####:   92:handler_throw_test (const jerry_call_info_t *call_info_p, /**< call information */
        -:   93:                    const jerry_value_t args_p[], /**< arguments list */
        -:   94:                    const jerry_length_t args_cnt) /**< arguments length */
        -:   95:{
    #####:   96:  printf ("ok %u %u %p %u\n",
    #####:   97:          (unsigned int) call_info_p->function,
    #####:   98:          (unsigned int) call_info_p->this_value,
        -:   99:          (void *) args_p,
        -:  100:          (unsigned int) args_cnt);
        -:  101:
    #####:  102:  return jerry_throw_sz (JERRY_ERROR_TYPE, "error");
        -:  103:} /* handler_throw_test */
        -:  104:
        -:  105:static void
    #####:  106:handler_construct_1_freecb (void *native_p, /**< native pointer */
        -:  107:                            jerry_object_native_info_t *info_p) /**< native info */
        -:  108:{
    #####:  109:  TEST_ASSERT ((uintptr_t) native_p == (uintptr_t) 0x0000000000000000ull);
    #####:  110:  TEST_ASSERT (info_p->free_cb == handler_construct_1_freecb);
    #####:  111:  printf ("ok object free callback\n");
        -:  112:
    #####:  113:  test_api_is_free_callback_was_called = true;
    #####:  114:} /* handler_construct_1_freecb */
        -:  115:
        -:  116:static void
    #####:  117:handler_construct_2_freecb (void *native_p, /**< native pointer */
        -:  118:                            jerry_object_native_info_t *info_p) /**< native info */
        -:  119:{
    #####:  120:  TEST_ASSERT ((uintptr_t) native_p == (uintptr_t) 0x0012345678abcdefull);
    #####:  121:  TEST_ASSERT (info_p->free_cb == handler_construct_2_freecb);
    #####:  122:  printf ("ok object free callback\n");
        -:  123:
    #####:  124:  test_api_is_free_callback_was_called = true;
    #####:  125:} /* handler_construct_2_freecb */
        -:  126:
        -:  127:/**
        -:  128: * The name of the jerry_object_native_info_t struct.
        -:  129: */
        -:  130:#define JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE(c_type) _jerry_object_native_info_##c_type
        -:  131:
        -:  132:/**
        -:  133: * Define a native pointer's type based on the C type and free callback.
        -:  134: */
        -:  135:#define JERRY_DEFINE_NATIVE_HANDLE_INFO(c_type, native_free_cb)                           \
        -:  136:  static const jerry_object_native_info_t JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (c_type) = { \
        -:  137:    .free_cb = (jerry_object_native_free_cb_t) native_free_cb,                            \
        -:  138:    .number_of_references = 0,                                                            \
        -:  139:    .offset_of_references = 0,                                                            \
        -:  140:  }
        -:  141:
        -:  142:JERRY_DEFINE_NATIVE_HANDLE_INFO (bind1, handler_construct_1_freecb);
        -:  143:JERRY_DEFINE_NATIVE_HANDLE_INFO (bind2, handler_construct_2_freecb);
        -:  144:JERRY_DEFINE_NATIVE_HANDLE_INFO (bind3, NULL);
        -:  145:
        -:  146:static jerry_value_t
    #####:  147:handler_construct (const jerry_call_info_t *call_info_p, /**< call information */
        -:  148:                   const jerry_value_t args_p[], /**< arguments list */
        -:  149:                   const jerry_length_t args_cnt) /**< arguments length */
        -:  150:{
    #####:  151:  printf ("ok construct %u %u %p %u\n",
    #####:  152:          (unsigned int) call_info_p->function,
    #####:  153:          (unsigned int) call_info_p->this_value,
        -:  154:          (void *) args_p,
        -:  155:          (unsigned int) args_cnt);
        -:  156:
    #####:  157:  TEST_ASSERT (jerry_value_is_object (call_info_p->this_value));
        -:  158:
    #####:  159:  TEST_ASSERT (args_cnt == 1);
    #####:  160:  TEST_ASSERT (jerry_value_is_boolean (args_p[0]));
    #####:  161:  TEST_ASSERT (jerry_value_is_true (args_p[0]));
        -:  162:
    #####:  163:  jerry_value_t this_value = call_info_p->this_value;
    #####:  164:  jerry_value_t field_name = jerry_string_sz ("value_field");
    #####:  165:  jerry_value_t res = jerry_object_set (this_value, field_name, args_p[0]);
    #####:  166:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  167:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  168:  jerry_value_free (res);
    #####:  169:  jerry_value_free (field_name);
        -:  170:
        -:  171:  /* Set a native pointer. */
    #####:  172:  jerry_object_set_native_ptr (this_value, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind1), NULL);
        -:  173:
        -:  174:  /* Check that the native pointer was set. */
    #####:  175:  TEST_ASSERT (jerry_object_has_native_ptr (this_value, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind1)));
    #####:  176:  void *ptr = jerry_object_get_native_ptr (this_value, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind1));
    #####:  177:  TEST_ASSERT (ptr == NULL);
        -:  178:
        -:  179:  /* Set a second native pointer. */
    #####:  180:  jerry_object_set_native_ptr (this_value, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind2), (void *) 0x0012345678abcdefull);
        -:  181:
        -:  182:  /* Check that a second native pointer was set. */
    #####:  183:  TEST_ASSERT (jerry_object_has_native_ptr (this_value, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind2)));
    #####:  184:  ptr = jerry_object_get_native_ptr (this_value, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind2));
    #####:  185:  TEST_ASSERT ((uintptr_t) ptr == (uintptr_t) 0x0012345678abcdefull);
        -:  186:
        -:  187:  /* Check that the first native pointer is still set. */
    #####:  188:  TEST_ASSERT (jerry_object_has_native_ptr (this_value, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind1)));
    #####:  189:  ptr = jerry_object_get_native_ptr (this_value, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind1));
    #####:  190:  TEST_ASSERT (ptr == NULL);
    #####:  191:  return jerry_boolean (true);
        -:  192:} /* handler_construct */
        -:  193:
        -:  194:/**
        -:  195: * Extended Magic Strings
        -:  196: */
        -:  197:#define JERRY_MAGIC_STRING_ITEMS                                     \
        -:  198:  JERRY_MAGIC_STRING_DEF (GLOBAL, global)                            \
        -:  199:  JERRY_MAGIC_STRING_DEF (GREEK_ZERO_SIGN, \xed\xa0\x80\xed\xb6\x8a) \
        -:  200:  JERRY_MAGIC_STRING_DEF (CONSOLE, console)
        -:  201:
        -:  202:#define JERRY_MAGIC_STRING_DEF(NAME, STRING) static const char jerry_magic_string_ex_##NAME[] = #STRING;
        -:  203:
        -:  204:JERRY_MAGIC_STRING_ITEMS
        -:  205:
        -:  206:#undef JERRY_MAGIC_STRING_DEF
        -:  207:
        -:  208:const jerry_length_t magic_string_lengths[] = {
        -:  209:#define JERRY_MAGIC_STRING_DEF(NAME, STRING) (jerry_length_t) (sizeof (jerry_magic_string_ex_##NAME) - 1u),
        -:  210:
        -:  211:  JERRY_MAGIC_STRING_ITEMS
        -:  212:
        -:  213:#undef JERRY_MAGIC_STRING_DEF
        -:  214:};
        -:  215:
        -:  216:const jerry_char_t *magic_string_items[] = {
        -:  217:#define JERRY_MAGIC_STRING_DEF(NAME, STRING) (const jerry_char_t *) jerry_magic_string_ex_##NAME,
        -:  218:
        -:  219:  JERRY_MAGIC_STRING_ITEMS
        -:  220:
        -:  221:#undef JERRY_MAGIC_STRING_DEF
        -:  222:};
        -:  223:
    #####:  224:static bool foreach (const jerry_value_t name, /**< field name */
        -:  225:                     const jerry_value_t value, /**< field value */
        -:  226:                     void *user_data) /**< user data */
        -:  227:{
        -:  228:  char str_buf_p[128];
    #####:  229:  jerry_size_t sz =
        -:  230:    jerry_string_to_buffer (name, JERRY_ENCODING_CESU8, (jerry_char_t *) str_buf_p, sizeof (str_buf_p) - 1);
    #####:  231:  str_buf_p[sz] = '\0';
        -:  232:
    #####:  233:  TEST_ASSERT (!strncmp ((const char *) user_data, "user_data", 9));
    #####:  234:  TEST_ASSERT (sz > 0);
        -:  235:
    #####:  236:  if (!strncmp (str_buf_p, "alpha", (size_t) sz))
        -:  237:  {
    #####:  238:    TEST_ASSERT (jerry_value_is_number (value));
    #####:  239:    TEST_ASSERT (jerry_value_as_number (value) == 32.0);
        -:  240:    return true;
        -:  241:  }
    #####:  242:  else if (!strncmp (str_buf_p, "bravo", (size_t) sz))
        -:  243:  {
    #####:  244:    TEST_ASSERT (jerry_value_is_boolean (value));
    #####:  245:    TEST_ASSERT (jerry_value_is_true (value) == false);
    #####:  246:    TEST_ASSERT (jerry_value_is_false (value));
        -:  247:    return true;
        -:  248:  }
    #####:  249:  else if (!strncmp (str_buf_p, "charlie", (size_t) sz))
        -:  250:  {
    #####:  251:    TEST_ASSERT (jerry_value_is_object (value));
        -:  252:    return true;
        -:  253:  }
    #####:  254:  else if (!strncmp (str_buf_p, "delta", (size_t) sz))
        -:  255:  {
    #####:  256:    TEST_ASSERT (jerry_value_is_number (value));
    #####:  257:    TEST_ASSERT (jerry_value_as_number (value) == 123.45);
        -:  258:    return true;
        -:  259:  }
    #####:  260:  else if (!strncmp (str_buf_p, "echo", (size_t) sz))
        -:  261:  {
    #####:  262:    TEST_ASSERT (jerry_value_is_string (value));
    #####:  263:    jerry_size_t echo_sz =
        -:  264:      jerry_string_to_buffer (value, JERRY_ENCODING_CESU8, (jerry_char_t *) str_buf_p, sizeof (str_buf_p) - 1);
    #####:  265:    str_buf_p[echo_sz] = '\0';
    #####:  266:    TEST_ASSERT (!strncmp (str_buf_p, "foobar", (size_t) echo_sz));
        -:  267:    return true;
        -:  268:  }
        -:  269:
    #####:  270:  TEST_ASSERT (false);
        -:  271:  return false;
        -:  272:} /* foreach */
        -:  273:
        -:  274:static bool
    #####:  275:foreach_exception (const jerry_value_t name, /**< field name */
        -:  276:                   const jerry_value_t value, /**< field value */
        -:  277:                   void *user_data) /**< user data */
        -:  278:{
        -:  279:  JERRY_UNUSED (value);
        -:  280:  JERRY_UNUSED (user_data);
        -:  281:  char str_buf_p[128];
    #####:  282:  jerry_size_t sz =
        -:  283:    jerry_string_to_buffer (name, JERRY_ENCODING_CESU8, (jerry_char_t *) str_buf_p, sizeof (str_buf_p) - 1);
    #####:  284:  str_buf_p[sz] = '\0';
        -:  285:
    #####:  286:  if (!strncmp (str_buf_p, "foxtrot", (size_t) sz))
        -:  287:  {
    #####:  288:    TEST_ASSERT (false);
        -:  289:  }
        -:  290:
    #####:  291:  return true;
        -:  292:} /* foreach_exception */
        -:  293:
        -:  294:static bool
    #####:  295:foreach_subset (const jerry_value_t name, /**< field name */
        -:  296:                const jerry_value_t value, /**< field value */
        -:  297:                void *user_data) /**< user data */
        -:  298:{
        -:  299:  JERRY_UNUSED (name);
        -:  300:  JERRY_UNUSED (value);
    #####:  301:  int *count_p = (int *) (user_data);
        -:  302:
    #####:  303:  if (*count_p == 3)
        -:  304:  {
        -:  305:    return false;
        -:  306:  }
    #####:  307:  (*count_p)++;
    #####:  308:  return true;
        -:  309:} /* foreach_subset */
        -:  310:
        -:  311:static jerry_value_t
    #####:  312:get_property (const jerry_value_t obj_val, /**< object value */
        -:  313:              const char *str_p) /**< property name */
        -:  314:{
    #####:  315:  jerry_value_t prop_name_val = jerry_string_sz (str_p);
    #####:  316:  jerry_value_t ret_val = jerry_object_get (obj_val, prop_name_val);
    #####:  317:  jerry_value_free (prop_name_val);
    #####:  318:  return ret_val;
        -:  319:} /* get_property */
        -:  320:
        -:  321:static jerry_value_t
    #####:  322:set_property (const jerry_value_t obj_val, /**< object value */
        -:  323:              const char *str_p, /**< property name */
        -:  324:              const jerry_value_t val) /**< value to set */
        -:  325:{
    #####:  326:  jerry_value_t prop_name_val = jerry_string_sz (str_p);
    #####:  327:  jerry_value_t ret_val = jerry_object_set (obj_val, prop_name_val, val);
    #####:  328:  jerry_value_free (prop_name_val);
    #####:  329:  return ret_val;
        -:  330:} /* set_property */
        -:  331:
        -:  332:static void
    #####:  333:test_syntax_error (const char *script_p, /**< source code to run */
        -:  334:                   const jerry_parse_options_t *options_p, /**< additional parsing options */
        -:  335:                   const char *error_message_p, /**< error message */
        -:  336:                   bool run_script) /**< run script before checking the error message */
        -:  337:{
    #####:  338:  jerry_value_t result_val = jerry_parse ((const jerry_char_t *) script_p, strlen (script_p), options_p);
        -:  339:
    #####:  340:  if (run_script)
        -:  341:  {
    #####:  342:    TEST_ASSERT (!jerry_value_is_exception (result_val));
    #####:  343:    jerry_value_t script_val = result_val;
        -:  344:
    #####:  345:    result_val = jerry_run (script_val);
    #####:  346:    jerry_value_free (script_val);
        -:  347:  }
        -:  348:
    #####:  349:  TEST_ASSERT (jerry_value_is_exception (result_val));
    #####:  350:  result_val = jerry_exception_value (result_val, true);
        -:  351:
    #####:  352:  jerry_value_t err_str_val = jerry_value_to_string (result_val);
    #####:  353:  jerry_size_t err_str_size = jerry_string_size (err_str_val, JERRY_ENCODING_CESU8);
        -:  354:  jerry_char_t err_str_buf[256];
        -:  355:
    #####:  356:  TEST_ASSERT (err_str_size <= sizeof (err_str_buf));
    #####:  357:  TEST_ASSERT (err_str_size == strlen (error_message_p));
        -:  358:
    #####:  359:  TEST_ASSERT (jerry_string_to_buffer (err_str_val, JERRY_ENCODING_CESU8, err_str_buf, err_str_size) == err_str_size);
        -:  360:
    #####:  361:  jerry_value_free (err_str_val);
    #####:  362:  jerry_value_free (result_val);
    #####:  363:  TEST_ASSERT (memcmp ((char *) err_str_buf, error_message_p, err_str_size) == 0);
    #####:  364:} /* test_syntax_error */
        -:  365:
        -:  366:int
    #####:  367:main (void)
    #####:  368:{
    #####:  369:  TEST_INIT ();
        -:  370:
        -:  371:  bool is_ok;
        -:  372:  jerry_size_t sz, cesu8_sz;
        -:  373:  jerry_length_t cesu8_length;
        -:  374:  jerry_value_t val_t, val_foo, val_bar, val_A, val_A_prototype, val_a, val_a_foo, val_value_field, val_p, val_np;
        -:  375:  jerry_value_t val_call_external;
        -:  376:  jerry_value_t global_obj_val, obj_val;
        -:  377:  jerry_value_t external_func_val, external_construct_val;
        -:  378:  jerry_value_t throw_test_handler_val;
        -:  379:  jerry_value_t parsed_code_val, proto_val, prim_val;
        -:  380:  jerry_value_t res, args[2];
        -:  381:  double number_val;
        -:  382:  char buffer[32];
        -:  383:
    #####:  384:  jerry_init (JERRY_INIT_EMPTY);
        -:  385:
    #####:  386:  parsed_code_val = jerry_parse (test_source, sizeof (test_source) - 1, NULL);
    #####:  387:  TEST_ASSERT (!jerry_value_is_exception (parsed_code_val));
        -:  388:
    #####:  389:  res = jerry_run (parsed_code_val);
    #####:  390:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  391:  jerry_value_free (res);
    #####:  392:  jerry_value_free (parsed_code_val);
        -:  393:
    #####:  394:  global_obj_val = jerry_current_realm ();
        -:  395:
        -:  396:  /* Get global.boo (non-existing field) */
    #####:  397:  val_t = get_property (global_obj_val, "boo");
    #####:  398:  TEST_ASSERT (!jerry_value_is_exception (val_t));
    #####:  399:  TEST_ASSERT (jerry_value_is_undefined (val_t));
        -:  400:
        -:  401:  /* Get global.t */
    #####:  402:  val_t = get_property (global_obj_val, "t");
    #####:  403:  TEST_ASSERT (!jerry_value_is_exception (val_t));
    #####:  404:  TEST_ASSERT (jerry_value_is_number (val_t) && jerry_value_as_number (val_t) == 1.0);
    #####:  405:  jerry_value_free (val_t);
        -:  406:
        -:  407:  /* Get global.foo */
    #####:  408:  val_foo = get_property (global_obj_val, "foo");
    #####:  409:  TEST_ASSERT (!jerry_value_is_exception (val_foo));
    #####:  410:  TEST_ASSERT (jerry_value_is_object (val_foo));
        -:  411:
        -:  412:  /* Call foo (4, 2) */
    #####:  413:  args[0] = jerry_number (4);
    #####:  414:  args[1] = jerry_number (2);
    #####:  415:  res = jerry_call (val_foo, jerry_undefined (), args, 2);
    #####:  416:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  417:  TEST_ASSERT (jerry_value_is_number (res) && jerry_value_as_number (res) == 1.0);
    #####:  418:  jerry_value_free (res);
        -:  419:
        -:  420:  /* Get global.bar */
    #####:  421:  val_bar = get_property (global_obj_val, "bar");
    #####:  422:  TEST_ASSERT (!jerry_value_is_exception (val_bar));
    #####:  423:  TEST_ASSERT (jerry_value_is_object (val_bar));
        -:  424:
        -:  425:  /* Call bar (4, 2) */
    #####:  426:  res = jerry_call (val_bar, jerry_undefined (), args, 2);
    #####:  427:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  428:  TEST_ASSERT (jerry_value_is_number (res) && jerry_value_as_number (res) == 5.0);
    #####:  429:  jerry_value_free (res);
    #####:  430:  jerry_value_free (val_bar);
        -:  431:
        -:  432:  /* Set global.t = "abcd" */
    #####:  433:  jerry_value_free (args[0]);
    #####:  434:  args[0] = jerry_string_sz ("abcd");
    #####:  435:  res = set_property (global_obj_val, "t", args[0]);
    #####:  436:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  437:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  438:  jerry_value_free (res);
        -:  439:
        -:  440:  /* Call foo (4, 2) */
    #####:  441:  res = jerry_call (val_foo, jerry_undefined (), args, 2);
    #####:  442:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  443:  TEST_ASSERT (jerry_value_is_string (res));
    #####:  444:  sz = jerry_string_size (res, JERRY_ENCODING_CESU8);
    #####:  445:  TEST_ASSERT (sz == 4);
    #####:  446:  sz = jerry_string_to_buffer (res, JERRY_ENCODING_CESU8, (jerry_char_t *) buffer, sz);
    #####:  447:  TEST_ASSERT (sz == 4);
    #####:  448:  jerry_value_free (res);
    #####:  449:  TEST_ASSERT (!strncmp (buffer, "abcd", (size_t) sz));
    #####:  450:  jerry_value_free (args[0]);
    #####:  451:  jerry_value_free (args[1]);
        -:  452:
        -:  453:  /* Get global.A */
    #####:  454:  val_A = get_property (global_obj_val, "A");
    #####:  455:  TEST_ASSERT (!jerry_value_is_exception (val_A));
    #####:  456:  TEST_ASSERT (jerry_value_is_object (val_A));
        -:  457:
        -:  458:  /* Get A.prototype */
    #####:  459:  is_ok = jerry_value_is_constructor (val_A);
    #####:  460:  TEST_ASSERT (is_ok);
    #####:  461:  val_A_prototype = get_property (val_A, "prototype");
    #####:  462:  TEST_ASSERT (!jerry_value_is_exception (val_A_prototype));
    #####:  463:  TEST_ASSERT (jerry_value_is_object (val_A_prototype));
    #####:  464:  jerry_value_free (val_A);
        -:  465:
        -:  466:  /* Set A.prototype.foo = global.foo */
    #####:  467:  res = set_property (val_A_prototype, "foo", val_foo);
    #####:  468:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  469:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  470:  jerry_value_free (res);
    #####:  471:  jerry_value_free (val_A_prototype);
    #####:  472:  jerry_value_free (val_foo);
        -:  473:
        -:  474:  /* Get global.a */
    #####:  475:  val_a = get_property (global_obj_val, "a");
    #####:  476:  TEST_ASSERT (!jerry_value_is_exception (val_a));
    #####:  477:  TEST_ASSERT (jerry_value_is_object (val_a));
        -:  478:
        -:  479:  /* Get a.t */
    #####:  480:  res = get_property (val_a, "t");
    #####:  481:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  482:  TEST_ASSERT (jerry_value_is_number (res) && jerry_value_as_number (res) == 12.0);
    #####:  483:  jerry_value_free (res);
        -:  484:
        -:  485:  /* foreach properties */
    #####:  486:  val_p = get_property (global_obj_val, "p");
    #####:  487:  is_ok = jerry_object_foreach (val_p, foreach, (void *) "user_data");
    #####:  488:  TEST_ASSERT (is_ok);
        -:  489:
        -:  490:  /* break foreach at third element */
    #####:  491:  int count = 0;
    #####:  492:  is_ok = jerry_object_foreach (val_p, foreach_subset, &count);
    #####:  493:  TEST_ASSERT (is_ok);
    #####:  494:  TEST_ASSERT (count == 3);
    #####:  495:  jerry_value_free (val_p);
        -:  496:
        -:  497:  /* foreach with throw test */
    #####:  498:  val_np = get_property (global_obj_val, "np");
    #####:  499:  is_ok = !jerry_object_foreach (val_np, foreach_exception, NULL);
    #####:  500:  TEST_ASSERT (is_ok);
    #####:  501:  jerry_value_free (val_np);
        -:  502:
        -:  503:  /* Get a.foo */
    #####:  504:  val_a_foo = get_property (val_a, "foo");
    #####:  505:  TEST_ASSERT (!jerry_value_is_exception (val_a_foo));
    #####:  506:  TEST_ASSERT (jerry_value_is_object (val_a_foo));
        -:  507:
        -:  508:  /* Call a.foo () */
    #####:  509:  res = jerry_call (val_a_foo, val_a, NULL, 0);
    #####:  510:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  511:  TEST_ASSERT (jerry_value_is_number (res) && jerry_value_as_number (res) == 12.0);
    #####:  512:  jerry_value_free (res);
    #####:  513:  jerry_value_free (val_a_foo);
        -:  514:
    #####:  515:  jerry_value_free (val_a);
        -:  516:
        -:  517:  /* Create native handler bound function object and set it to 'external' variable */
    #####:  518:  external_func_val = jerry_function_external (handler);
    #####:  519:  TEST_ASSERT (jerry_value_is_function (external_func_val) && jerry_value_is_constructor (external_func_val));
        -:  520:
    #####:  521:  res = set_property (global_obj_val, "external", external_func_val);
    #####:  522:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  523:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  524:  jerry_value_free (external_func_val);
        -:  525:
        -:  526:  /* Call 'call_external' function that should call external function created above */
    #####:  527:  val_call_external = get_property (global_obj_val, "call_external");
    #####:  528:  TEST_ASSERT (!jerry_value_is_exception (val_call_external));
    #####:  529:  TEST_ASSERT (jerry_value_is_object (val_call_external));
    #####:  530:  res = jerry_call (val_call_external, global_obj_val, NULL, 0);
    #####:  531:  jerry_value_free (val_call_external);
    #####:  532:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  533:  TEST_ASSERT (jerry_value_is_string (res));
    #####:  534:  sz = jerry_string_size (res, JERRY_ENCODING_CESU8);
    #####:  535:  TEST_ASSERT (sz == 19);
    #####:  536:  sz = jerry_string_to_buffer (res, JERRY_ENCODING_CESU8, (jerry_char_t *) buffer, sz);
    #####:  537:  TEST_ASSERT (sz == 19);
    #####:  538:  jerry_value_free (res);
    #####:  539:  TEST_ASSERT (!strncmp (buffer, "string from handler", (size_t) sz));
        -:  540:
        -:  541:  /* Create native handler bound function object and set it to 'external_construct' variable */
    #####:  542:  external_construct_val = jerry_function_external (handler_construct);
    #####:  543:  TEST_ASSERT (jerry_value_is_function (external_construct_val) && jerry_value_is_constructor (external_construct_val));
        -:  544:
    #####:  545:  res = set_property (global_obj_val, "external_construct", external_construct_val);
    #####:  546:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  547:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  548:  jerry_value_free (res);
        -:  549:
        -:  550:  /* Call external function created above, as constructor */
    #####:  551:  args[0] = jerry_boolean (true);
    #####:  552:  res = jerry_construct (external_construct_val, args, 1);
    #####:  553:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  554:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  555:  val_value_field = get_property (res, "value_field");
        -:  556:
        -:  557:  /* Get 'value_field' of constructed object */
    #####:  558:  TEST_ASSERT (!jerry_value_is_exception (val_value_field));
    #####:  559:  TEST_ASSERT (jerry_value_is_boolean (val_value_field) && jerry_value_is_true (val_value_field));
    #####:  560:  jerry_value_free (val_value_field);
    #####:  561:  jerry_value_free (external_construct_val);
        -:  562:
    #####:  563:  TEST_ASSERT (jerry_object_has_native_ptr (res, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind2)));
    #####:  564:  void *ptr = jerry_object_get_native_ptr (res, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind2));
    #####:  565:  TEST_ASSERT ((uintptr_t) ptr == (uintptr_t) 0x0012345678abcdefull);
        -:  566:
        -:  567:  /* Passing NULL for info_p is allowed. */
    #####:  568:  TEST_ASSERT (!jerry_object_has_native_ptr (res, NULL));
    #####:  569:  jerry_object_set_native_ptr (res, NULL, (void *) 0x0012345678abcdefull);
        -:  570:
    #####:  571:  TEST_ASSERT (jerry_object_has_native_ptr (res, NULL));
    #####:  572:  ptr = jerry_object_get_native_ptr (res, NULL);
    #####:  573:  TEST_ASSERT ((uintptr_t) ptr == (uintptr_t) 0x0012345678abcdefull);
        -:  574:
    #####:  575:  jerry_value_free (res);
        -:  576:
        -:  577:  /* Test: It is ok to set native pointer's free callback as NULL. */
    #####:  578:  jerry_value_t obj_freecb = jerry_object ();
    #####:  579:  jerry_object_set_native_ptr (obj_freecb, &JERRY_NATIVE_HANDLE_INFO_FOR_CTYPE (bind3), (void *) 0x1234);
        -:  580:
    #####:  581:  jerry_value_free (obj_freecb);
        -:  582:
        -:  583:  /* Test: Throwing exception from native handler. */
    #####:  584:  throw_test_handler_val = jerry_function_external (handler_throw_test);
    #####:  585:  TEST_ASSERT (jerry_value_is_function (throw_test_handler_val));
        -:  586:
    #####:  587:  res = set_property (global_obj_val, "throw_test", throw_test_handler_val);
    #####:  588:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  589:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  590:  jerry_value_free (res);
    #####:  591:  jerry_value_free (throw_test_handler_val);
        -:  592:
    #####:  593:  val_t = get_property (global_obj_val, "call_throw_test");
    #####:  594:  TEST_ASSERT (!jerry_value_is_exception (val_t));
    #####:  595:  TEST_ASSERT (jerry_value_is_object (val_t));
        -:  596:
    #####:  597:  res = jerry_call (val_t, global_obj_val, NULL, 0);
    #####:  598:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  599:  jerry_value_free (val_t);
    #####:  600:  jerry_value_free (res);
        -:  601:
        -:  602:  /* Test: Unhandled exception in called function */
    #####:  603:  val_t = get_property (global_obj_val, "throw_reference_error");
    #####:  604:  TEST_ASSERT (!jerry_value_is_exception (val_t));
    #####:  605:  TEST_ASSERT (jerry_value_is_object (val_t));
        -:  606:
    #####:  607:  res = jerry_call (val_t, global_obj_val, NULL, 0);
        -:  608:
    #####:  609:  TEST_ASSERT (jerry_value_is_exception (res));
    #####:  610:  jerry_value_free (val_t);
        -:  611:
        -:  612:  /* 'res' should contain exception object */
    #####:  613:  res = jerry_exception_value (res, true);
    #####:  614:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  615:  jerry_value_free (res);
        -:  616:
        -:  617:  /* Test: Call of non-function */
    #####:  618:  obj_val = jerry_object ();
    #####:  619:  res = jerry_call (obj_val, global_obj_val, NULL, 0);
    #####:  620:  TEST_ASSERT (jerry_value_is_exception (res));
        -:  621:
        -:  622:  /* 'res' should contain exception object */
    #####:  623:  res = jerry_exception_value (res, true);
    #####:  624:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  625:  jerry_value_free (res);
        -:  626:
    #####:  627:  jerry_value_free (obj_val);
        -:  628:
        -:  629:  /* Test: Unhandled exception in function called, as constructor */
    #####:  630:  val_t = get_property (global_obj_val, "throw_reference_error");
    #####:  631:  TEST_ASSERT (!jerry_value_is_exception (val_t));
    #####:  632:  TEST_ASSERT (jerry_value_is_object (val_t));
        -:  633:
    #####:  634:  res = jerry_construct (val_t, NULL, 0);
    #####:  635:  TEST_ASSERT (jerry_value_is_exception (res));
    #####:  636:  jerry_value_free (val_t);
        -:  637:
        -:  638:  /* 'res' should contain exception object */
    #####:  639:  res = jerry_exception_value (res, true);
    #####:  640:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  641:  jerry_value_free (res);
        -:  642:
        -:  643:  /* Test: Call of non-function as constructor */
    #####:  644:  obj_val = jerry_object ();
    #####:  645:  res = jerry_construct (obj_val, NULL, 0);
    #####:  646:  TEST_ASSERT (jerry_value_is_exception (res));
        -:  647:
        -:  648:  /* 'res' should contain exception object */
    #####:  649:  res = jerry_exception_value (res, true);
    #####:  650:  TEST_ASSERT (jerry_value_is_object (res));
    #####:  651:  jerry_value_free (res);
        -:  652:
    #####:  653:  jerry_value_free (obj_val);
        -:  654:
        -:  655:  /* Test: Array Object API */
    #####:  656:  jerry_value_t array_obj_val = jerry_array (10);
    #####:  657:  TEST_ASSERT (jerry_value_is_array (array_obj_val));
    #####:  658:  TEST_ASSERT (jerry_array_length (array_obj_val) == 10);
        -:  659:
    #####:  660:  jerry_value_t v_in = jerry_number (10.5);
    #####:  661:  res = jerry_object_set_index (array_obj_val, 5, v_in);
    #####:  662:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  663:  TEST_ASSERT (jerry_value_is_boolean (res) && jerry_value_is_true (res));
    #####:  664:  jerry_value_free (res);
    #####:  665:  jerry_value_t v_out = jerry_object_get_index (array_obj_val, 5);
        -:  666:
    #####:  667:  TEST_ASSERT (jerry_value_is_number (v_out) && jerry_value_as_number (v_out) == 10.5);
        -:  668:
    #####:  669:  jerry_object_delete_index (array_obj_val, 5);
    #####:  670:  jerry_value_t v_und = jerry_object_get_index (array_obj_val, 5);
        -:  671:
    #####:  672:  TEST_ASSERT (jerry_value_is_undefined (v_und));
        -:  673:
    #####:  674:  jerry_value_free (v_in);
    #####:  675:  jerry_value_free (v_out);
    #####:  676:  jerry_value_free (v_und);
    #####:  677:  jerry_value_free (array_obj_val);
        -:  678:
        -:  679:  /* Test: object keys */
    #####:  680:  res = jerry_object_keys (global_obj_val);
    #####:  681:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  682:  TEST_ASSERT (jerry_value_is_array (res));
    #####:  683:  TEST_ASSERT (jerry_array_length (res) == 15);
    #####:  684:  jerry_value_free (res);
        -:  685:
        -:  686:  /* Test: jerry_value_to_primitive */
    #####:  687:  obj_val = jerry_eval ((jerry_char_t *) "new String ('hello')", 20, JERRY_PARSE_NO_OPTS);
    #####:  688:  TEST_ASSERT (!jerry_value_is_exception (obj_val));
    #####:  689:  TEST_ASSERT (jerry_value_is_object (obj_val));
    #####:  690:  TEST_ASSERT (!jerry_value_is_string (obj_val));
    #####:  691:  prim_val = jerry_value_to_primitive (obj_val);
    #####:  692:  TEST_ASSERT (!jerry_value_is_exception (prim_val));
    #####:  693:  TEST_ASSERT (jerry_value_is_string (prim_val));
    #####:  694:  jerry_value_free (prim_val);
        -:  695:
        -:  696:  /* Test: jerry_object_proto */
    #####:  697:  proto_val = jerry_object_proto (jerry_undefined ());
    #####:  698:  TEST_ASSERT (jerry_value_is_exception (proto_val));
    #####:  699:  jerry_value_t error = jerry_exception_value (proto_val, true);
    #####:  700:  TEST_ASSERT (jerry_error_type (error) == JERRY_ERROR_TYPE);
    #####:  701:  jerry_value_free (error);
        -:  702:
    #####:  703:  proto_val = jerry_object_proto (obj_val);
    #####:  704:  TEST_ASSERT (!jerry_value_is_exception (proto_val));
    #####:  705:  TEST_ASSERT (jerry_value_is_object (proto_val));
    #####:  706:  jerry_value_free (proto_val);
    #####:  707:  jerry_value_free (obj_val);
        -:  708:
    #####:  709:  if (jerry_feature_enabled (JERRY_FEATURE_PROXY))
        -:  710:  {
    #####:  711:    jerry_value_t target = jerry_object ();
    #####:  712:    jerry_value_t handler = jerry_object ();
    #####:  713:    jerry_value_t proxy = jerry_proxy (target, handler);
    #####:  714:    jerry_value_t obj_proto = jerry_eval ((jerry_char_t *) "Object.prototype", 16, JERRY_PARSE_NO_OPTS);
        -:  715:
    #####:  716:    jerry_value_free (target);
    #####:  717:    jerry_value_free (handler);
    #####:  718:    proto_val = jerry_object_proto (proxy);
    #####:  719:    TEST_ASSERT (!jerry_value_is_exception (proto_val));
    #####:  720:    TEST_ASSERT (proto_val == obj_proto);
    #####:  721:    jerry_value_free (proto_val);
    #####:  722:    jerry_value_free (obj_proto);
    #####:  723:    jerry_value_free (proxy);
        -:  724:  }
        -:  725:
        -:  726:  /* Test: jerry_object_set_proto */
    #####:  727:  obj_val = jerry_object ();
    #####:  728:  res = jerry_object_set_proto (obj_val, jerry_null ());
    #####:  729:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  730:  TEST_ASSERT (jerry_value_is_boolean (res));
    #####:  731:  TEST_ASSERT (jerry_value_is_true (res));
        -:  732:
    #####:  733:  jerry_value_t new_proto = jerry_object ();
    #####:  734:  res = jerry_object_set_proto (obj_val, new_proto);
    #####:  735:  jerry_value_free (new_proto);
    #####:  736:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  737:  TEST_ASSERT (jerry_value_is_boolean (res));
    #####:  738:  TEST_ASSERT (jerry_value_is_true (res));
    #####:  739:  proto_val = jerry_object_proto (obj_val);
    #####:  740:  TEST_ASSERT (!jerry_value_is_exception (proto_val));
    #####:  741:  TEST_ASSERT (jerry_value_is_object (proto_val));
    #####:  742:  jerry_value_free (proto_val);
    #####:  743:  jerry_value_free (obj_val);
        -:  744:
    #####:  745:  if (jerry_feature_enabled (JERRY_FEATURE_PROXY))
        -:  746:  {
    #####:  747:    jerry_value_t target = jerry_object ();
    #####:  748:    jerry_value_t handler = jerry_object ();
    #####:  749:    jerry_value_t proxy = jerry_proxy (target, handler);
    #####:  750:    new_proto = jerry_eval ((jerry_char_t *) "Function.prototype", 18, JERRY_PARSE_NO_OPTS);
        -:  751:
    #####:  752:    res = jerry_object_set_proto (proxy, new_proto);
    #####:  753:    TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  754:    jerry_value_t target_proto = jerry_object_proto (target);
    #####:  755:    TEST_ASSERT (target_proto == new_proto);
        -:  756:
    #####:  757:    jerry_value_free (target);
    #####:  758:    jerry_value_free (handler);
    #####:  759:    jerry_value_free (proxy);
    #####:  760:    jerry_value_free (new_proto);
    #####:  761:    jerry_value_free (target_proto);
        -:  762:  }
        -:  763:
        -:  764:  /* Test: eval */
    #####:  765:  const jerry_char_t eval_code_src1[] = "(function () { return 123; })";
    #####:  766:  val_t = jerry_eval (eval_code_src1, sizeof (eval_code_src1) - 1, JERRY_PARSE_STRICT_MODE);
    #####:  767:  TEST_ASSERT (!jerry_value_is_exception (val_t));
    #####:  768:  TEST_ASSERT (jerry_value_is_object (val_t));
    #####:  769:  TEST_ASSERT (jerry_value_is_function (val_t));
        -:  770:
    #####:  771:  res = jerry_call (val_t, jerry_undefined (), NULL, 0);
    #####:  772:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####:  773:  TEST_ASSERT (jerry_value_is_number (res) && jerry_value_as_number (res) == 123.0);
    #####:  774:  jerry_value_free (res);
        -:  775:
    #####:  776:  jerry_value_free (val_t);
        -:  777:
        -:  778:  /* cleanup. */
    #####:  779:  jerry_value_free (global_obj_val);
        -:  780:
        -:  781:  /* Test: run gc. */
    #####:  782:  jerry_heap_gc (JERRY_GC_PRESSURE_LOW);
        -:  783:
        -:  784:  /* Test: spaces */
    #####:  785:  const jerry_char_t eval_code_src2[] = "\x0a \x0b \x0c \xc2\xa0 \xe2\x80\xa8 \xe2\x80\xa9 \xef\xbb\xbf 4321";
    #####:  786:  val_t = jerry_eval (eval_code_src2, sizeof (eval_code_src2) - 1, JERRY_PARSE_STRICT_MODE);
    #####:  787:  TEST_ASSERT (!jerry_value_is_exception (val_t));
    #####:  788:  TEST_ASSERT (jerry_value_is_number (val_t) && jerry_value_as_number (val_t) == 4321.0);
    #####:  789:  jerry_value_free (val_t);
        -:  790:
        -:  791:  /* Test: number */
    #####:  792:  val_t = jerry_number (6.25);
    #####:  793:  number_val = jerry_value_as_number (val_t);
    #####:  794:  TEST_ASSERT (number_val * 3 == 18.75);
    #####:  795:  jerry_value_free (val_t);
        -:  796:
    #####:  797:  val_t = jerry_infinity (true);
    #####:  798:  number_val = jerry_value_as_number (val_t);
    #####:  799:  TEST_ASSERT (number_val * 3 == number_val && number_val != 0.0);
    #####:  800:  jerry_value_free (val_t);
        -:  801:
    #####:  802:  val_t = jerry_nan ();
    #####:  803:  number_val = jerry_value_as_number (val_t);
    #####:  804:  TEST_ASSERT (number_val != number_val);
    #####:  805:  jerry_value_free (val_t);
        -:  806:
        -:  807:  /* Test: create function */
    #####:  808:  jerry_value_t script_source = jerry_string_sz ("  return 5 +  a+\nb+c");
        -:  809:
        -:  810:  jerry_parse_options_t parse_options;
    #####:  811:  parse_options.options = JERRY_PARSE_HAS_ARGUMENT_LIST;
    #####:  812:  parse_options.argument_list = jerry_string_sz ("a , b,c");
        -:  813:
    #####:  814:  jerry_value_t func_val = jerry_parse_value (script_source, &parse_options);
        -:  815:
    #####:  816:  TEST_ASSERT (!jerry_value_is_exception (func_val));
        -:  817:
    #####:  818:  jerry_value_free (parse_options.argument_list);
    #####:  819:  jerry_value_free (script_source);
        -:  820:
    #####:  821:  jerry_value_t func_args[3] = { jerry_number (4), jerry_number (6), jerry_number (-2) };
        -:  822:
    #####:  823:  val_t = jerry_call (func_val, func_args[0], func_args, 3);
    #####:  824:  number_val = jerry_value_as_number (val_t);
    #####:  825:  TEST_ASSERT (number_val == 13.0);
        -:  826:
    #####:  827:  jerry_value_free (val_t);
    #####:  828:  jerry_value_free (func_val);
        -:  829:
    #####:  830:  parse_options.options = JERRY_PARSE_HAS_ARGUMENT_LIST;
    #####:  831:  parse_options.argument_list = jerry_null ();
        -:  832:
    #####:  833:  func_val = jerry_parse ((const jerry_char_t *) "", 0, &parse_options);
    #####:  834:  jerry_value_free (parse_options.argument_list);
        -:  835:
    #####:  836:  TEST_ASSERT (jerry_value_is_exception (func_val) && jerry_error_type (func_val) == JERRY_ERROR_TYPE);
    #####:  837:  jerry_value_free (func_val);
        -:  838:
    #####:  839:  script_source = jerry_number (4.5);
    #####:  840:  func_val = jerry_parse_value (script_source, NULL);
    #####:  841:  jerry_value_free (script_source);
        -:  842:
    #####:  843:  TEST_ASSERT (jerry_value_is_exception (func_val) && jerry_error_type (func_val) == JERRY_ERROR_TYPE);
    #####:  844:  jerry_value_free (func_val);
        -:  845:
    #####:  846:  jerry_cleanup ();
        -:  847:
    #####:  848:  TEST_ASSERT (test_api_is_free_callback_was_called);
        -:  849:
        -:  850:  /* Test: jerry_exception_value */
        -:  851:  {
    #####:  852:    jerry_init (JERRY_INIT_EMPTY);
    #####:  853:    jerry_value_t num_val = jerry_number (123);
    #####:  854:    num_val = jerry_throw_value (num_val, true);
    #####:  855:    TEST_ASSERT (jerry_value_is_exception (num_val));
    #####:  856:    jerry_value_t num2_val = jerry_exception_value (num_val, false);
    #####:  857:    TEST_ASSERT (jerry_value_is_exception (num_val));
    #####:  858:    TEST_ASSERT (!jerry_value_is_exception (num2_val));
    #####:  859:    double num = jerry_value_as_number (num2_val);
    #####:  860:    TEST_ASSERT (num == 123);
    #####:  861:    num2_val = jerry_exception_value (num_val, true);
    #####:  862:    TEST_ASSERT (!jerry_value_is_exception (num2_val));
    #####:  863:    num = jerry_value_as_number (num2_val);
    #####:  864:    TEST_ASSERT (num == 123);
    #####:  865:    jerry_value_free (num2_val);
    #####:  866:    jerry_cleanup ();
        -:  867:  }
        -:  868:
        -:  869:  /* Test parsing/executing scripts with lexically scoped global variables multiple times. */
    #####:  870:  if (jerry_feature_enabled (JERRY_FEATURE_SYMBOL))
        -:  871:  {
    #####:  872:    jerry_init (JERRY_INIT_EMPTY);
    #####:  873:    const jerry_char_t scoped_src_p[] = "let a; this.b = 5";
    #####:  874:    jerry_value_t parse_result = jerry_parse (scoped_src_p, sizeof (scoped_src_p) - 1, NULL);
    #####:  875:    TEST_ASSERT (!jerry_value_is_exception (parse_result));
    #####:  876:    jerry_value_free (parse_result);
        -:  877:
    #####:  878:    parse_result = jerry_parse (scoped_src_p, sizeof (scoped_src_p) - 1, NULL);
    #####:  879:    TEST_ASSERT (!jerry_value_is_exception (parse_result));
        -:  880:
    #####:  881:    jerry_value_t run_result = jerry_run (parse_result);
    #####:  882:    TEST_ASSERT (!jerry_value_is_exception (run_result));
    #####:  883:    jerry_value_free (run_result);
        -:  884:
        -:  885:    /* Should be a syntax error due to redeclaration. */
    #####:  886:    run_result = jerry_run (parse_result);
    #####:  887:    TEST_ASSERT (jerry_value_is_exception (run_result));
    #####:  888:    jerry_value_free (run_result);
    #####:  889:    jerry_value_free (parse_result);
        -:  890:
        -:  891:    /* The variable should have no effect on parsing. */
    #####:  892:    parse_result = jerry_parse (scoped_src_p, sizeof (scoped_src_p) - 1, NULL);
    #####:  893:    TEST_ASSERT (!jerry_value_is_exception (parse_result));
    #####:  894:    jerry_value_free (parse_result);
        -:  895:
        -:  896:    /* The already existing global binding should not affect a new lexical binding */
    #####:  897:    const jerry_char_t scoped_src2_p[] = "let b = 6; this.b + b";
    #####:  898:    parse_result = jerry_parse (scoped_src2_p, sizeof (scoped_src2_p) - 1, NULL);
    #####:  899:    TEST_ASSERT (!jerry_value_is_exception (parse_result));
    #####:  900:    run_result = jerry_run (parse_result);
    #####:  901:    TEST_ASSERT (jerry_value_is_number (run_result));
    #####:  902:    TEST_ASSERT (jerry_value_as_number (run_result) == 11);
    #####:  903:    jerry_value_free (run_result);
    #####:  904:    jerry_value_free (parse_result);
        -:  905:
        -:  906:    /* Check restricted global property */
    #####:  907:    const jerry_char_t scoped_src3_p[] = "let undefined;";
    #####:  908:    parse_result = jerry_parse (scoped_src3_p, sizeof (scoped_src3_p) - 1, NULL);
    #####:  909:    TEST_ASSERT (!jerry_value_is_exception (parse_result));
    #####:  910:    run_result = jerry_run (parse_result);
    #####:  911:    TEST_ASSERT (jerry_value_is_exception (run_result));
    #####:  912:    TEST_ASSERT (jerry_error_type (run_result) == JERRY_ERROR_SYNTAX);
    #####:  913:    jerry_value_free (run_result);
    #####:  914:    jerry_value_free (parse_result);
        -:  915:
    #####:  916:    jerry_value_t global_obj = jerry_current_realm ();
    #####:  917:    jerry_value_t prop_name = jerry_string_sz ("foo");
        -:  918:
    #####:  919:    jerry_property_descriptor_t prop_desc = jerry_property_descriptor ();
    #####:  920:    prop_desc.flags |= JERRY_PROP_IS_VALUE_DEFINED;
    #####:  921:    prop_desc.value = jerry_number (5.2);
        -:  922:
    #####:  923:    jerry_value_t define_result = jerry_object_define_own_prop (global_obj, prop_name, &prop_desc);
    #####:  924:    TEST_ASSERT (jerry_value_is_boolean (define_result) && jerry_value_is_true (define_result));
    #####:  925:    jerry_value_free (define_result);
        -:  926:
    #####:  927:    jerry_property_descriptor_free (&prop_desc);
    #####:  928:    jerry_value_free (prop_name);
    #####:  929:    jerry_value_free (global_obj);
        -:  930:
    #####:  931:    const jerry_char_t scoped_src4_p[] = "let foo;";
    #####:  932:    parse_result = jerry_parse (scoped_src4_p, sizeof (scoped_src4_p) - 1, NULL);
    #####:  933:    TEST_ASSERT (!jerry_value_is_exception (parse_result));
    #####:  934:    run_result = jerry_run (parse_result);
    #####:  935:    TEST_ASSERT (jerry_value_is_exception (run_result));
    #####:  936:    TEST_ASSERT (jerry_error_type (run_result) == JERRY_ERROR_SYNTAX);
    #####:  937:    jerry_value_free (run_result);
    #####:  938:    jerry_value_free (parse_result);
        -:  939:
    #####:  940:    if (jerry_feature_enabled (JERRY_FEATURE_REALM))
        -:  941:    {
    #####:  942:      const jerry_char_t proxy_src_p[] = "new Proxy({}, { getOwnPropertyDescriptor() { throw 42.1 }})";
    #####:  943:      jerry_value_t proxy = jerry_eval (proxy_src_p, sizeof (proxy_src_p) - 1, JERRY_PARSE_NO_OPTS);
    #####:  944:      TEST_ASSERT (jerry_value_is_object (proxy));
    #####:  945:      jerry_value_t new_realm_value = jerry_realm ();
        -:  946:
    #####:  947:      jerry_value_t set_realm_this_result = jerry_realm_set_this (new_realm_value, proxy);
    #####:  948:      TEST_ASSERT (jerry_value_is_boolean (set_realm_this_result) && jerry_value_is_true (set_realm_this_result));
    #####:  949:      jerry_value_free (set_realm_this_result);
        -:  950:
    #####:  951:      jerry_value_t old_realm = jerry_set_realm (new_realm_value);
        -:  952:
    #####:  953:      const jerry_char_t scoped_src5_p[] = "let a;";
    #####:  954:      parse_result = jerry_parse (scoped_src5_p, sizeof (scoped_src5_p) - 1, NULL);
    #####:  955:      TEST_ASSERT (!jerry_value_is_exception (parse_result));
    #####:  956:      run_result = jerry_run (parse_result);
    #####:  957:      TEST_ASSERT (jerry_value_is_exception (run_result));
    #####:  958:      jerry_value_t error_value = jerry_exception_value (run_result, false);
    #####:  959:      TEST_ASSERT (jerry_value_is_number (error_value) && jerry_value_as_number (error_value) == 42.1);
    #####:  960:      jerry_value_free (error_value);
    #####:  961:      jerry_value_free (run_result);
    #####:  962:      jerry_value_free (parse_result);
        -:  963:
    #####:  964:      jerry_set_realm (old_realm);
        -:  965:
    #####:  966:      jerry_value_free (new_realm_value);
    #####:  967:      jerry_value_free (proxy);
        -:  968:
    #####:  969:      const jerry_char_t proxy_src2_p[] = "new Proxy(Object.defineProperty({}, 'b', {value: 5.2}), {})";
    #####:  970:      proxy = jerry_eval (proxy_src2_p, sizeof (proxy_src2_p) - 1, JERRY_PARSE_NO_OPTS);
    #####:  971:      TEST_ASSERT (jerry_value_is_object (proxy));
    #####:  972:      new_realm_value = jerry_realm ();
        -:  973:
    #####:  974:      set_realm_this_result = jerry_realm_set_this (new_realm_value, proxy);
    #####:  975:      TEST_ASSERT (jerry_value_is_boolean (set_realm_this_result) && jerry_value_is_true (set_realm_this_result));
    #####:  976:      jerry_value_free (set_realm_this_result);
        -:  977:
    #####:  978:      old_realm = jerry_set_realm (new_realm_value);
        -:  979:
    #####:  980:      const jerry_char_t scoped_src6_p[] = "let b;";
    #####:  981:      parse_result = jerry_parse (scoped_src6_p, sizeof (scoped_src6_p) - 1, NULL);
    #####:  982:      TEST_ASSERT (!jerry_value_is_exception (parse_result));
    #####:  983:      run_result = jerry_run (parse_result);
    #####:  984:      TEST_ASSERT (jerry_value_is_exception (run_result));
    #####:  985:      TEST_ASSERT (jerry_value_is_exception (run_result));
    #####:  986:      TEST_ASSERT (jerry_error_type (run_result) == JERRY_ERROR_SYNTAX);
    #####:  987:      jerry_value_free (run_result);
    #####:  988:      jerry_value_free (parse_result);
        -:  989:
    #####:  990:      jerry_set_realm (old_realm);
        -:  991:
    #####:  992:      jerry_value_free (new_realm_value);
    #####:  993:      jerry_value_free (proxy);
        -:  994:    }
        -:  995:
    #####:  996:    jerry_cleanup ();
        -:  997:  }
        -:  998:
        -:  999:  /* Test: parser error location */
    #####: 1000:  if (jerry_feature_enabled (JERRY_FEATURE_ERROR_MESSAGES))
        -: 1001:  {
    #####: 1002:    jerry_init (JERRY_INIT_SHOW_OPCODES);
        -: 1003:
    #####: 1004:    test_syntax_error ("b = 'hello';\nvar a = (;",
        -: 1005:                       NULL,
        -: 1006:                       "SyntaxError: Unexpected end of input [<anonymous>:2:10]",
        -: 1007:                       false);
        -: 1008:
    #####: 1009:    parse_options.options = JERRY_PARSE_HAS_SOURCE_NAME;
    #####: 1010:    parse_options.source_name = jerry_string_sz ("filename.js");
        -: 1011:
    #####: 1012:    test_syntax_error ("b = 'hello';\nvar a = (;",
        -: 1013:                       &parse_options,
        -: 1014:                       "SyntaxError: Unexpected end of input [filename.js:2:10]",
        -: 1015:                       false);
        -: 1016:
    #####: 1017:    test_syntax_error ("eval(\"var b;\\nfor (,); \");",
        -: 1018:                       &parse_options,
        -: 1019:                       "SyntaxError: Unexpected end of input [<eval>:2:6]",
        -: 1020:                       true);
        -: 1021:
    #####: 1022:    parse_options.options |= JERRY_PARSE_HAS_START;
    #####: 1023:    parse_options.start_line = 10;
    #####: 1024:    parse_options.start_column = 20;
        -: 1025:
    #####: 1026:    test_syntax_error ("for (var a in []",
        -: 1027:                       &parse_options,
        -: 1028:                       "SyntaxError: Expected ')' token [filename.js:10:36]",
        -: 1029:                       false);
        -: 1030:
    #####: 1031:    jerry_value_free (parse_options.source_name);
    #####: 1032:    jerry_cleanup ();
        -: 1033:  }
        -: 1034:
        -: 1035:  /* External Magic String */
    #####: 1036:  jerry_init (JERRY_INIT_SHOW_OPCODES);
        -: 1037:
    #####: 1038:  uint32_t num_magic_string_items = (uint32_t) (sizeof (magic_string_items) / sizeof (jerry_char_t *));
    #####: 1039:  jerry_register_magic_strings (magic_string_items, num_magic_string_items, magic_string_lengths);
        -: 1040:
    #####: 1041:  const jerry_char_t ms_code_src[] = "var global = {}; var console = [1]; var process = 1;";
    #####: 1042:  parsed_code_val = jerry_parse (ms_code_src, sizeof (ms_code_src) - 1, NULL);
    #####: 1043:  TEST_ASSERT (!jerry_value_is_exception (parsed_code_val));
        -: 1044:
    #####: 1045:  res = jerry_run (parsed_code_val);
    #####: 1046:  TEST_ASSERT (!jerry_value_is_exception (res));
    #####: 1047:  jerry_value_free (res);
    #####: 1048:  jerry_value_free (parsed_code_val);
        -: 1049:
        -: 1050:  /* call jerry_string_sz functions which will returns with the registered external magic strings */
    #####: 1051:  args[0] = jerry_string_sz ("console");
    #####: 1052:  args[1] = jerry_string_sz ("\xed\xa0\x80\xed\xb6\x8a"); /**< greek zero sign */
        -: 1053:
    #####: 1054:  cesu8_length = jerry_string_length (args[0]);
    #####: 1055:  cesu8_sz = jerry_string_size (args[0], JERRY_ENCODING_CESU8);
        -: 1056:
    #####: 1057:  JERRY_VLA (char, string_console, cesu8_sz);
    #####: 1058:  jerry_string_to_buffer (args[0], JERRY_ENCODING_CESU8, (jerry_char_t *) string_console, cesu8_sz);
        -: 1059:
    #####: 1060:  TEST_ASSERT (!strncmp (string_console, "console", cesu8_sz));
    #####: 1061:  TEST_ASSERT (cesu8_length == 7);
    #####: 1062:  TEST_ASSERT (cesu8_length == cesu8_sz);
        -: 1063:
    #####: 1064:  jerry_value_free (args[0]);
        -: 1065:
    #####: 1066:  const jerry_char_t test_magic_str_access_src[] = "'console'.charAt(6) == 'e'";
    #####: 1067:  res = jerry_eval (test_magic_str_access_src, sizeof (test_magic_str_access_src) - 1, JERRY_PARSE_NO_OPTS);
    #####: 1068:  TEST_ASSERT (jerry_value_is_boolean (res));
    #####: 1069:  TEST_ASSERT (jerry_value_is_true (res));
        -: 1070:
    #####: 1071:  jerry_value_free (res);
        -: 1072:
    #####: 1073:  cesu8_length = jerry_string_length (args[1]);
    #####: 1074:  cesu8_sz = jerry_string_size (args[1], JERRY_ENCODING_CESU8);
        -: 1075:
    #####: 1076:  JERRY_VLA (char, string_greek_zero_sign, cesu8_sz);
    #####: 1077:  jerry_string_to_buffer (args[1], JERRY_ENCODING_CESU8, (jerry_char_t *) string_greek_zero_sign, cesu8_sz);
        -: 1078:
    #####: 1079:  TEST_ASSERT (!strncmp (string_greek_zero_sign, "\xed\xa0\x80\xed\xb6\x8a", cesu8_sz));
    #####: 1080:  TEST_ASSERT (cesu8_length == 2);
    #####: 1081:  TEST_ASSERT (cesu8_sz == 6);
        -: 1082:
    #####: 1083:  jerry_value_free (args[1]);
        -: 1084:
    #####: 1085:  jerry_cleanup ();
        -: 1086:
        -: 1087:  return 0;
        -: 1088:} /* main */
