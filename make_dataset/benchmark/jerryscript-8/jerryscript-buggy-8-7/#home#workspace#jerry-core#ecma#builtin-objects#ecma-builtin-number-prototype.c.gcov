        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-number-prototype.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <math.h>
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-gc.h"
        -:   23:#include "ecma-globals.h"
        -:   24:#include "ecma-helpers-number.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-objects.h"
        -:   27:#include "ecma-string-object.h"
        -:   28:
        -:   29:#include "jrt-libc-includes.h"
        -:   30:#include "jrt.h"
        -:   31:#include "lit-char-helpers.h"
        -:   32:
        -:   33:#if JERRY_BUILTIN_NUMBER
        -:   34:
        -:   35:#define ECMA_BUILTINS_INTERNAL
        -:   36:#include "ecma-builtins-internal.h"
        -:   37:
        -:   38:/**
        -:   39: * This object has a custom dispatch function.
        -:   40: */
        -:   41:#define BUILTIN_CUSTOM_DISPATCH
        -:   42:
        -:   43:/**
        -:   44: * List of built-in routine identifiers.
        -:   45: */
        -:   46:enum
        -:   47:{
        -:   48:  ECMA_NUMBER_PROTOTYPE_ROUTINE_START = 0,
        -:   49:  ECMA_NUMBER_PROTOTYPE_VALUE_OF,
        -:   50:  ECMA_NUMBER_PROTOTYPE_TO_STRING,
        -:   51:  ECMA_NUMBER_PROTOTYPE_TO_LOCALE_STRING,
        -:   52:  ECMA_NUMBER_PROTOTYPE_TO_FIXED,
        -:   53:  ECMA_NUMBER_PROTOTYPE_TO_EXPONENTIAL,
        -:   54:  ECMA_NUMBER_PROTOTYPE_TO_PRECISION,
        -:   55:};
        -:   56:
        -:   57:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-number-prototype.inc.h"
        -:   58:#define BUILTIN_UNDERSCORED_ID  number_prototype
        -:   59:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   60:
        -:   61:/** \addtogroup ecma ECMA
        -:   62: * @{
        -:   63: *
        -:   64: * \addtogroup ecmabuiltins
        -:   65: * @{
        -:   66: *
        -:   67: * \addtogroup numberprototype ECMA Number.prototype object built-in
        -:   68: * @{
        -:   69: */
        -:   70:
        -:   71:/**
        -:   72: * Helper for rounding numbers
        -:   73: *
        -:   74: * @return rounded number
        -:   75: */
        -:   76:static inline lit_utf8_size_t JERRY_ATTR_ALWAYS_INLINE
        -:   77:ecma_builtin_number_prototype_helper_round (lit_utf8_byte_t *digits_p, /**< [in,out] number as a string in decimal
        -:   78:                                                                        *   form */
        -:   79:                                            lit_utf8_size_t num_digits, /**< length of the string representation */
        -:   80:                                            int32_t round_num, /**< number of digits to keep */
        -:   81:                                            int32_t *exponent_p, /**< [in, out] decimal exponent */
        -:   82:                                            bool zero) /**< true if digits_p represents zero */
        -:   83:{
    #####:   84:  if (round_num == 0 && *exponent_p == 0)
        -:   85:  {
    #####:   86:    if (digits_p[0] >= 5)
        -:   87:    {
    #####:   88:      digits_p[0] = '1';
        -:   89:    }
        -:   90:    else
        -:   91:    {
    #####:   92:      digits_p[0] = '0';
        -:   93:    }
        -:   94:
    #####:   95:    return 1;
        -:   96:  }
        -:   97:
    #####:   98:  if (round_num < 1)
        -:   99:  {
    #####:  100:    return 0;
        -:  101:  }
        -:  102:
    #####:  103:  if ((lit_utf8_size_t) round_num >= num_digits || zero)
        -:  104:  {
    #####:  105:    return num_digits;
        -:  106:  }
        -:  107:
    #####:  108:  if (digits_p[round_num] >= '5')
        -:  109:  {
    #####:  110:    digits_p[round_num] = '0';
        -:  111:
    #####:  112:    int i = 1;
        -:  113:
        -:  114:    /* Handle carry number. */
    #####:  115:    for (; i <= round_num; i++)
        -:  116:    {
    #####:  117:      if (++digits_p[round_num - i] <= '9')
        -:  118:      {
        -:  119:        break;
        -:  120:      }
    #####:  121:      digits_p[round_num - i] = '0';
        -:  122:    }
        -:  123:
        -:  124:    /* Prepend highest digit */
    #####:  125:    if (i > round_num)
        -:  126:    {
    #####:  127:      memmove (digits_p + 1, digits_p, num_digits);
    #####:  128:      digits_p[0] = '1';
    #####:  129:      *exponent_p += 1;
        -:  130:    }
        -:  131:  }
        -:  132:
    #####:  133:  return (lit_utf8_size_t) round_num;
        -:  134:} /* ecma_builtin_number_prototype_helper_round */
        -:  135:
        -:  136:/**
        -:  137: * Size of Number toString digit buffers.
        -:  138: */
        -:  139:#define NUMBER_TO_STRING_MAX_DIGIT_COUNT 64u
        -:  140:
        -:  141:/**
        -:  142: * The Number.prototype object's 'toString' and 'toLocaleString' routines
        -:  143: *
        -:  144: * See also:
        -:  145: *          ECMA-262 v5, 15.7.4.2
        -:  146: *          ECMA-262 v5, 15.7.4.7
        -:  147: *
        -:  148: * @return ecma value
        -:  149: *         Returned value must be freed with ecma_free_value.
        -:  150: */
        -:  151:static ecma_value_t
    #####:  152:ecma_builtin_number_prototype_object_to_string (ecma_number_t this_arg_number, /**< this argument number */
        -:  153:                                                const ecma_value_t *arguments_list_p, /**< arguments list */
        -:  154:                                                uint32_t arguments_list_len) /**< number of arguments */
        -:  155:{
        -:  156:  static const lit_utf8_byte_t digit_chars[36] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b',
        -:  157:                                                   'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        -:  158:                                                   'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };
        -:  159:
    #####:  160:  uint32_t radix = 10;
    #####:  161:  if (arguments_list_len > 0 && !ecma_is_value_undefined (arguments_list_p[0]))
        -:  162:  {
    #####:  163:    ecma_number_t arg_num;
        -:  164:
    #####:  165:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arguments_list_p[0], &arg_num)))
        -:  166:    {
    #####:  167:      return ECMA_VALUE_ERROR;
        -:  168:    }
        -:  169:
    #####:  170:    radix = ecma_number_to_uint32 (arg_num);
        -:  171:
    #####:  172:    if (radix < 2 || radix > 36)
        -:  173:    {
    #####:  174:      return ecma_raise_range_error (ECMA_ERR_RADIX_IS_OUT_OF_RANGE);
        -:  175:    }
        -:  176:  }
        -:  177:
    #####:  178:  if (ecma_number_is_nan (this_arg_number) || ecma_number_is_infinity (this_arg_number)
    #####:  179:      || ecma_number_is_zero (this_arg_number) || radix == 10)
        -:  180:  {
    #####:  181:    ecma_string_t *ret_str_p = ecma_new_ecma_string_from_number (this_arg_number);
    #####:  182:    return ecma_make_string_value (ret_str_p);
        -:  183:  }
        -:  184:
    #####:  185:  uint8_t integer_digits[NUMBER_TO_STRING_MAX_DIGIT_COUNT];
    #####:  186:  uint8_t fraction_digits[NUMBER_TO_STRING_MAX_DIGIT_COUNT];
    #####:  187:  uint32_t integer_zeros = 0;
    #####:  188:  uint32_t fraction_zeros = 0;
    #####:  189:  bool is_number_negative = false;
        -:  190:
    #####:  191:  if (ecma_number_is_negative (this_arg_number))
        -:  192:  {
    #####:  193:    this_arg_number = -this_arg_number;
    #####:  194:    is_number_negative = true;
        -:  195:  }
        -:  196:
    #####:  197:  ecma_number_t integer_part = floor (this_arg_number);
    #####:  198:  ecma_number_t fraction_part = this_arg_number - integer_part;
        -:  199:
    #####:  200:  uint8_t *integer_cursor_p = integer_digits + NUMBER_TO_STRING_MAX_DIGIT_COUNT;
    #####:  201:  uint8_t *fraction_cursor_p = fraction_digits;
        -:  202:
    #####:  203:  if (fraction_part > 0.0)
        -:  204:  {
        -:  205:    uint8_t digit;
    #####:  206:    ecma_number_t precision = (ecma_number_get_next (this_arg_number) - this_arg_number) * 0.5f;
    #####:  207:    precision = JERRY_MAX (precision, ECMA_NUMBER_MIN_VALUE);
        -:  208:
        -:  209:    do
        -:  210:    {
    #####:  211:      fraction_part *= radix;
    #####:  212:      precision *= radix;
        -:  213:
    #####:  214:      digit = (uint8_t) floor (fraction_part);
        -:  215:
    #####:  216:      if (digit == 0 && fraction_cursor_p == fraction_digits)
        -:  217:      {
    #####:  218:        fraction_zeros++;
    #####:  219:        continue;
        -:  220:      }
        -:  221:
    #####:  222:      JERRY_ASSERT (fraction_cursor_p < fraction_digits + NUMBER_TO_STRING_MAX_DIGIT_COUNT);
    #####:  223:      *fraction_cursor_p++ = digit;
    #####:  224:      fraction_part -= (ecma_number_t) digit;
    #####:  225:    } while (fraction_part >= precision);
        -:  226:
        -:  227:    /* Round to even */
    #####:  228:    if (fraction_part > 0.5 || (fraction_part == 0.5 && (digit & 1) != 0))
        -:  229:    {
        -:  230:      /* Add carry and remove overflowing trailing digits */
        -:  231:      while (true)
        -:  232:      {
    #####:  233:        (*(--fraction_cursor_p))++;
        -:  234:
    #####:  235:        if (*fraction_cursor_p < radix)
        -:  236:        {
        -:  237:          /* Re-adjust cursor to point after the last significant digit */
    #####:  238:          fraction_cursor_p++;
    #####:  239:          break;
        -:  240:        }
        -:  241:
    #####:  242:        if (fraction_cursor_p == fraction_digits)
        -:  243:        {
        -:  244:          /* Carry overflowed to integer part */
    #####:  245:          integer_part += 1;
    #####:  246:          break;
        -:  247:        }
        -:  248:      }
        -:  249:    }
        -:  250:
        -:  251:    /* Convert fraction digits to characters. */
    #####:  252:    for (uint8_t *digit_p = fraction_digits; digit_p < fraction_cursor_p; digit_p++)
        -:  253:    {
    #####:  254:      *digit_p = digit_chars[*digit_p];
        -:  255:    }
        -:  256:  }
        -:  257:
    #####:  258:  while (ecma_number_biased_exp (ecma_number_to_binary (integer_part / radix))
        -:  259:         > ECMA_NUMBER_EXPONENT_BIAS + ECMA_NUMBER_FRACTION_WIDTH)
        -:  260:  {
    #####:  261:    integer_zeros++;
    #####:  262:    integer_part /= radix;
        -:  263:  }
        -:  264:
    #####:  265:  uint64_t integer_u64 = (uint64_t) integer_part;
        -:  266:
        -:  267:  do
        -:  268:  {
    #####:  269:    uint64_t remainder = integer_u64 % radix;
    #####:  270:    *(--integer_cursor_p) = (uint8_t) digit_chars[remainder];
        -:  271:
    #####:  272:    integer_u64 /= radix;
    #####:  273:  } while (integer_u64 > 0);
        -:  274:
    #####:  275:  const uint32_t integer_digit_count =
    #####:  276:    (uint32_t) (integer_digits + NUMBER_TO_STRING_MAX_DIGIT_COUNT - integer_cursor_p);
    #####:  277:  JERRY_ASSERT (integer_digit_count > 0);
        -:  278:
    #####:  279:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  280:
    #####:  281:  if (is_number_negative)
        -:  282:  {
    #####:  283:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_MINUS);
        -:  284:  }
        -:  285:
    #####:  286:  ecma_stringbuilder_append_raw (&builder, integer_cursor_p, integer_digit_count);
        -:  287:
    #####:  288:  while (integer_zeros--)
        -:  289:  {
    #####:  290:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_0);
        -:  291:  }
        -:  292:
    #####:  293:  if (fraction_cursor_p != fraction_digits)
        -:  294:  {
    #####:  295:    ecma_stringbuilder_append_byte (&builder, LIT_CHAR_DOT);
        -:  296:
    #####:  297:    while (fraction_zeros--)
        -:  298:    {
    #####:  299:      ecma_stringbuilder_append_byte (&builder, LIT_CHAR_0);
        -:  300:    }
        -:  301:
    #####:  302:    const uint32_t fraction_digit_count = (uint32_t) (fraction_cursor_p - fraction_digits);
    #####:  303:    JERRY_ASSERT (fraction_digit_count > 0);
        -:  304:
    #####:  305:    ecma_stringbuilder_append_raw (&builder, fraction_digits, fraction_digit_count);
        -:  306:  }
        -:  307:
    #####:  308:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  309:} /* ecma_builtin_number_prototype_object_to_string */
        -:  310:
        -:  311:/**
        -:  312: * The Number.prototype object's 'valueOf' routine
        -:  313: *
        -:  314: * See also:
        -:  315: *          ECMA-262 v5, 15.7.4.4
        -:  316: *
        -:  317: * @return ecma value
        -:  318: *         Returned value must be freed with ecma_free_value.
        -:  319: */
        -:  320:static ecma_value_t
    #####:  321:ecma_builtin_number_prototype_object_value_of (ecma_value_t this_arg) /**< this argument */
        -:  322:{
    #####:  323:  if (ecma_is_value_number (this_arg))
        -:  324:  {
    #####:  325:    return this_arg;
        -:  326:  }
    #####:  327:  else if (ecma_is_value_object (this_arg))
        -:  328:  {
    #####:  329:    ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  330:
    #####:  331:    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_NUMBER))
        -:  332:    {
    #####:  333:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  334:
    #####:  335:      JERRY_ASSERT (ecma_is_value_number (ext_object_p->u.cls.u3.value));
        -:  336:
    #####:  337:      return ext_object_p->u.cls.u3.value;
        -:  338:    }
        -:  339:  }
        -:  340:
    #####:  341:  return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_NUMBER);
        -:  342:} /* ecma_builtin_number_prototype_object_value_of */
        -:  343:
        -:  344:/**
        -:  345: * Type of number routine
        -:  346: */
        -:  347:typedef enum
        -:  348:{
        -:  349:  NUMBER_ROUTINE_TO_FIXED, /**< Number.prototype.toFixed: ECMA-262 v11, 20.1.3.3 */
        -:  350:  NUMBER_ROUTINE_TO_EXPONENTIAL, /**< Number.prototype.toExponential: ECMA-262 v11, 20.1.3.2 */
        -:  351:  NUMBER_ROUTINE_TO_PRECISION, /**< Number.prototype.toPrecision: ECMA-262 v11, 20.1.3.5 */
        -:  352:  NUMBER_ROUTINE__COUNT, /**< count of the modes */
        -:  353:} number_routine_mode_t;
        -:  354:
        -:  355:/**
        -:  356: * Helper method to convert a number based on the given routine.
        -:  357: */
        -:  358:static ecma_value_t
    #####:  359:ecma_builtin_number_prototype_object_to_number_convert (ecma_number_t this_num, /**< this argument number */
        -:  360:                                                        ecma_value_t arg, /**< routine's argument */
        -:  361:                                                        number_routine_mode_t mode) /**< number routine mode */
        -:  362:{
    #####:  363:  if (ecma_is_value_undefined (arg) && mode == NUMBER_ROUTINE_TO_PRECISION)
        -:  364:  {
    #####:  365:    return ecma_builtin_number_prototype_object_to_string (this_num, NULL, 0);
        -:  366:  }
        -:  367:
    #####:  368:  ecma_number_t arg_num;
    #####:  369:  ecma_value_t to_integer = ecma_op_to_integer (arg, &arg_num);
        -:  370:
    #####:  371:  if (ECMA_IS_VALUE_ERROR (to_integer))
        -:  372:  {
    #####:  373:    return to_integer;
        -:  374:  }
        -:  375:
        -:  376:  /* Argument boundary check for toFixed method */
    #####:  377:  if (mode == NUMBER_ROUTINE_TO_FIXED && (arg_num <= -1 || arg_num >= 101))
        -:  378:  {
    #####:  379:    return ecma_raise_range_error (ECMA_ERR_FRACTION_DIGITS_OUT_OF_RANGE);
        -:  380:  }
        -:  381:
        -:  382:  /* Handle NaN separately */
    #####:  383:  if (ecma_number_is_nan (this_num))
        -:  384:  {
    #####:  385:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_NAN);
        -:  386:  }
        -:  387:
        -:  388:  /* Get the parameters of the number */
    #####:  389:  lit_utf8_byte_t digits[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
        -:  390:  lit_utf8_size_t num_of_digits;
    #####:  391:  int32_t exponent;
    #####:  392:  int32_t arg_int = ecma_number_to_int32 (arg_num);
    #####:  393:  bool is_zero = ecma_number_is_zero (this_num);
    #####:  394:  bool is_negative = ecma_number_is_negative (this_num);
        -:  395:
    #####:  396:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  397:
    #####:  398:  if (is_negative)
        -:  399:  {
    #####:  400:    if (!is_zero)
        -:  401:    {
    #####:  402:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_MINUS);
        -:  403:    }
        -:  404:
    #####:  405:    this_num *= -1;
        -:  406:  }
        -:  407:
        -:  408:  /* Handle zero separately */
    #####:  409:  if (is_zero)
        -:  410:  {
    #####:  411:    if (mode == NUMBER_ROUTINE_TO_PRECISION)
        -:  412:    {
    #####:  413:      arg_int--;
        -:  414:    }
        -:  415:
    #####:  416:    ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
        -:  417:
    #####:  418:    if (arg_int > 0)
        -:  419:    {
    #####:  420:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_DOT);
        -:  421:    }
        -:  422:
    #####:  423:    for (int32_t i = 0; i < arg_int; i++)
        -:  424:    {
    #####:  425:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
        -:  426:    }
        -:  427:
    #####:  428:    if (mode == NUMBER_ROUTINE_TO_EXPONENTIAL)
        -:  429:    {
    #####:  430:      ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "e+0", 3);
        -:  431:    }
        -:  432:
    #####:  433:    return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  434:  }
        -:  435:
        -:  436:  /* Handle infinity separately */
    #####:  437:  if (ecma_number_is_infinity (this_num))
        -:  438:  {
    #####:  439:    ecma_stringbuilder_append_magic (&builder, LIT_MAGIC_STRING_INFINITY_UL);
    #####:  440:    return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  441:  }
        -:  442:
        -:  443:  /* Argument boundary check for toExponential and toPrecision methods */
    #####:  444:  if (mode == NUMBER_ROUTINE_TO_EXPONENTIAL && (arg_num <= -1 || arg_num >= 101))
        -:  445:  {
    #####:  446:    ecma_stringbuilder_destroy (&builder);
    #####:  447:    return ecma_raise_range_error (ECMA_ERR_FRACTION_DIGITS_OUT_OF_RANGE);
        -:  448:  }
    #####:  449:  else if (mode == NUMBER_ROUTINE_TO_PRECISION && (arg_num < 1 || arg_num > 100))
        -:  450:  {
    #####:  451:    ecma_stringbuilder_destroy (&builder);
    #####:  452:    return ecma_raise_range_error (ECMA_ERR_PRECISION_DIGITS_MUST_BE_BETWEEN_IN_RANGE);
        -:  453:  }
        -:  454:
    #####:  455:  num_of_digits = ecma_number_to_decimal (this_num, digits, &exponent);
        -:  456:
        -:  457:  /* Handle undefined argument */
    #####:  458:  if (ecma_is_value_undefined (arg) && mode == NUMBER_ROUTINE_TO_EXPONENTIAL)
        -:  459:  {
    #####:  460:    arg_int = (int32_t) num_of_digits - 1;
        -:  461:  }
        -:  462:
    #####:  463:  if (mode == NUMBER_ROUTINE_TO_FIXED && exponent > 21)
        -:  464:  {
    #####:  465:    ecma_stringbuilder_destroy (&builder);
        -:  466:
    #####:  467:    if (is_negative)
        -:  468:    {
    #####:  469:      this_num *= -1;
        -:  470:    }
        -:  471:
    #####:  472:    return ecma_builtin_number_prototype_object_to_string (this_num, NULL, 0);
        -:  473:  }
        -:  474:
    #####:  475:  int32_t digits_to_keep = arg_int;
        -:  476:
    #####:  477:  if (mode == NUMBER_ROUTINE_TO_FIXED)
        -:  478:  {
    #####:  479:    digits_to_keep += exponent;
        -:  480:  }
    #####:  481:  else if (mode == NUMBER_ROUTINE_TO_EXPONENTIAL)
        -:  482:  {
    #####:  483:    digits_to_keep += 1;
        -:  484:  }
        -:  485:
    #####:  486:  num_of_digits = ecma_builtin_number_prototype_helper_round (digits, num_of_digits, digits_to_keep, &exponent, false);
        -:  487:
        -:  488:  /* toExponent routine and toPrecision cases where the exponent > precision or exponent < -5 */
    #####:  489:  if (mode == NUMBER_ROUTINE_TO_EXPONENTIAL
    #####:  490:      || (mode == NUMBER_ROUTINE_TO_PRECISION && (exponent < -5 || exponent > arg_int)))
        -:  491:  {
        -:  492:    /* Append first digit */
    #####:  493:    ecma_stringbuilder_append_byte (&builder, *digits);
        -:  494:
    #####:  495:    if (mode == NUMBER_ROUTINE_TO_PRECISION)
        -:  496:    {
    #####:  497:      arg_int--;
        -:  498:    }
        -:  499:
    #####:  500:    if (arg_int > 0)
        -:  501:    {
    #####:  502:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_DOT);
        -:  503:    }
        -:  504:
        -:  505:    /* Append significant fraction digits */
    #####:  506:    ecma_stringbuilder_append_raw (&builder, digits + 1, num_of_digits - 1);
        -:  507:
        -:  508:    /* Append leading zeros */
    #####:  509:    for (int32_t i = (int32_t) (num_of_digits); i < arg_int + 1; i++)
        -:  510:    {
    #####:  511:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
        -:  512:    }
        -:  513:
    #####:  514:    ecma_stringbuilder_append_char (&builder, LIT_CHAR_LOWERCASE_E);
        -:  515:
    #####:  516:    if (exponent <= 0)
        -:  517:    {
    #####:  518:      exponent = (-exponent) + 1;
    #####:  519:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_MINUS);
        -:  520:    }
        -:  521:    else
        -:  522:    {
    #####:  523:      exponent -= 1;
    #####:  524:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_PLUS);
        -:  525:    }
        -:  526:
        -:  527:    /* Append exponent part */
    #####:  528:    lit_utf8_size_t exp_size = ecma_uint32_to_utf8_string ((uint32_t) exponent, digits, 3);
    #####:  529:    ecma_stringbuilder_append_raw (&builder, digits, exp_size);
        -:  530:
    #####:  531:    return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  532:  }
        -:  533:
        -:  534:  /* toFixed routine and toPrecision cases where the exponent <= precision and exponent >= -5 */
        -:  535:  lit_utf8_size_t result_digits;
        -:  536:
    #####:  537:  if (mode == NUMBER_ROUTINE_TO_FIXED)
        -:  538:  {
    #####:  539:    result_digits = ((exponent > 0) ? (lit_utf8_size_t) (exponent + arg_int) : (lit_utf8_size_t) (arg_int + 1));
        -:  540:  }
        -:  541:  else
        -:  542:  {
    #####:  543:    result_digits = ((exponent <= 0) ? (lit_utf8_size_t) (1 - exponent + arg_int) : (lit_utf8_size_t) arg_int);
        -:  544:  }
        -:  545:
        -:  546:  /* Number of digits we copied from digits array */
    #####:  547:  lit_utf8_size_t copied_digits = 0;
        -:  548:
    #####:  549:  if (exponent == 0 && digits_to_keep == 0)
        -:  550:  {
    #####:  551:    ecma_stringbuilder_append_char (&builder, *digits);
    #####:  552:    return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  553:  }
        -:  554:
    #####:  555:  if (exponent <= 0)
        -:  556:  {
    #####:  557:    ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
    #####:  558:    result_digits--;
        -:  559:
    #####:  560:    if (result_digits > 0)
        -:  561:    {
    #####:  562:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_DOT);
        -:  563:
        -:  564:      /* Append leading zeros to the fraction part */
    #####:  565:      for (int32_t i = 0; i < -exponent && result_digits > 0; i++)
        -:  566:      {
    #####:  567:        ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
    #####:  568:        result_digits--;
        -:  569:      }
        -:  570:    }
        -:  571:  }
        -:  572:  else
        -:  573:  {
        -:  574:    /* Append significant digits of integer part */
    #####:  575:    copied_digits = JERRY_MIN (JERRY_MIN (num_of_digits, result_digits), (lit_utf8_size_t) exponent);
    #####:  576:    ecma_stringbuilder_append_raw (&builder, digits, copied_digits);
        -:  577:
    #####:  578:    result_digits -= copied_digits;
    #####:  579:    num_of_digits -= copied_digits;
    #####:  580:    exponent -= (int32_t) copied_digits;
        -:  581:
        -:  582:    /* Append zeros before decimal point */
    #####:  583:    while (exponent > 0 && result_digits > 0)
        -:  584:    {
    #####:  585:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
    #####:  586:      result_digits--;
    #####:  587:      exponent--;
        -:  588:    }
        -:  589:
    #####:  590:    if (result_digits > 0)
        -:  591:    {
    #####:  592:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_DOT);
        -:  593:    }
        -:  594:  }
        -:  595:
    #####:  596:  if (result_digits > 0)
        -:  597:  {
        -:  598:    /* Append significant digits to the fraction part */
    #####:  599:    lit_utf8_size_t to_copy = JERRY_MIN (num_of_digits, result_digits);
    #####:  600:    ecma_stringbuilder_append_raw (&builder, digits + copied_digits, to_copy);
    #####:  601:    result_digits -= to_copy;
        -:  602:
        -:  603:    /* Append leading zeros */
    #####:  604:    while (result_digits > 0)
        -:  605:    {
    #####:  606:      ecma_stringbuilder_append_char (&builder, LIT_CHAR_0);
    #####:  607:      result_digits--;
        -:  608:    }
        -:  609:  }
        -:  610:
    #####:  611:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  612:} /* ecma_builtin_number_prototype_object_to_number_convert */
        -:  613:
        -:  614:/**
        -:  615: * Dispatcher of the built-in's routines
        -:  616: *
        -:  617: * @return ecma value
        -:  618: *         Returned value must be freed with ecma_free_value.
        -:  619: */
        -:  620:ecma_value_t
    #####:  621:ecma_builtin_number_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  622:                                                ecma_value_t this_arg, /**< 'this' argument value */
        -:  623:                                                const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  624:                                                                                        *   passed to routine */
        -:  625:                                                uint32_t arguments_number) /**< length of arguments' list */
        -:  626:{
    #####:  627:  ecma_value_t this_value = ecma_builtin_number_prototype_object_value_of (this_arg);
        -:  628:
    #####:  629:  if (ECMA_IS_VALUE_ERROR (this_value))
        -:  630:  {
    #####:  631:    return this_value;
        -:  632:  }
        -:  633:
    #####:  634:  if (builtin_routine_id == ECMA_NUMBER_PROTOTYPE_VALUE_OF)
        -:  635:  {
    #####:  636:    return ecma_copy_value (this_value);
        -:  637:  }
        -:  638:
    #####:  639:  ecma_number_t this_arg_number = ecma_get_number_from_value (this_value);
        -:  640:
    #####:  641:  switch (builtin_routine_id)
        -:  642:  {
    #####:  643:    case ECMA_NUMBER_PROTOTYPE_TO_STRING:
        -:  644:    {
    #####:  645:      return ecma_builtin_number_prototype_object_to_string (this_arg_number, arguments_list_p, arguments_number);
        -:  646:    }
    #####:  647:    case ECMA_NUMBER_PROTOTYPE_TO_LOCALE_STRING:
        -:  648:    {
    #####:  649:      return ecma_builtin_number_prototype_object_to_string (this_arg_number, NULL, 0);
        -:  650:    }
    #####:  651:    case ECMA_NUMBER_PROTOTYPE_TO_FIXED:
        -:  652:    case ECMA_NUMBER_PROTOTYPE_TO_EXPONENTIAL:
        -:  653:    case ECMA_NUMBER_PROTOTYPE_TO_PRECISION:
        -:  654:    {
    #####:  655:      const int option = NUMBER_ROUTINE_TO_FIXED + (builtin_routine_id - ECMA_NUMBER_PROTOTYPE_TO_FIXED);
    #####:  656:      return ecma_builtin_number_prototype_object_to_number_convert (this_arg_number,
        -:  657:                                                                     arguments_list_p[0],
        -:  658:                                                                     (number_routine_mode_t) option);
        -:  659:    }
    #####:  660:    default:
        -:  661:    {
    #####:  662:      JERRY_UNREACHABLE ();
        -:  663:    }
        -:  664:  }
        -:  665:} /* ecma_builtin_number_prototype_dispatch_routine */
        -:  666:
        -:  667:/**
        -:  668: * @}
        -:  669: * @}
        -:  670: * @}
        -:  671: */
        -:  672:
        -:  673:#endif /* JERRY_BUILTIN_NUMBER */
