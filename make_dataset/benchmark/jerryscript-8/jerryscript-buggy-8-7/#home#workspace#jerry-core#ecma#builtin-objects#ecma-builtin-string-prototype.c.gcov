        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-string-prototype.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtin-regexp.inc.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-function-object.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-helpers.h"
        -:   27:#include "ecma-iterator-object.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-string-object.h"
        -:   30:
        -:   31:#include "jcontext.h"
        -:   32:#include "jrt-libc-includes.h"
        -:   33:#include "jrt.h"
        -:   34:#include "lit-char-helpers.h"
        -:   35:#include "lit-strings.h"
        -:   36:
        -:   37:#if JERRY_BUILTIN_REGEXP
        -:   38:#include "ecma-regexp-object.h"
        -:   39:#endif /* JERRY_BUILTIN_REGEXP */
        -:   40:
        -:   41:#if JERRY_BUILTIN_STRING
        -:   42:
        -:   43:#define ECMA_BUILTINS_INTERNAL
        -:   44:#include "ecma-builtins-internal.h"
        -:   45:
        -:   46:/**
        -:   47: * This object has a custom dispatch function.
        -:   48: */
        -:   49:#define BUILTIN_CUSTOM_DISPATCH
        -:   50:
        -:   51:/**
        -:   52: * List of built-in routine identifiers.
        -:   53: */
        -:   54:enum
        -:   55:{
        -:   56:  ECMA_STRING_PROTOTYPE_ROUTINE_START = 0,
        -:   57:  /* Note: These 4 routines MUST be in this order */
        -:   58:  ECMA_STRING_PROTOTYPE_TO_STRING,
        -:   59:  ECMA_STRING_PROTOTYPE_VALUE_OF,
        -:   60:  ECMA_STRING_PROTOTYPE_CHAR_AT,
        -:   61:  ECMA_STRING_PROTOTYPE_CHAR_CODE_AT,
        -:   62:
        -:   63:  ECMA_STRING_PROTOTYPE_CONCAT,
        -:   64:  ECMA_STRING_PROTOTYPE_SLICE,
        -:   65:  ECMA_STRING_PROTOTYPE_AT,
        -:   66:
        -:   67:  ECMA_STRING_PROTOTYPE_LOCALE_COMPARE,
        -:   68:
        -:   69:  ECMA_STRING_PROTOTYPE_MATCH,
        -:   70:  ECMA_STRING_PROTOTYPE_REPLACE,
        -:   71:  ECMA_STRING_PROTOTYPE_SEARCH,
        -:   72:
        -:   73:  ECMA_STRING_PROTOTYPE_SPLIT,
        -:   74:  ECMA_STRING_PROTOTYPE_SUBSTRING,
        -:   75:  ECMA_STRING_PROTOTYPE_TO_LOWER_CASE,
        -:   76:  ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE,
        -:   77:  ECMA_STRING_PROTOTYPE_TO_UPPER_CASE,
        -:   78:  ECMA_STRING_PROTOTYPE_TO_LOCAL_UPPER_CASE,
        -:   79:  ECMA_STRING_PROTOTYPE_TRIM,
        -:   80:
        -:   81:  ECMA_STRING_PROTOTYPE_SUBSTR,
        -:   82:
        -:   83:  ECMA_STRING_PROTOTYPE_REPEAT,
        -:   84:  ECMA_STRING_PROTOTYPE_CODE_POINT_AT,
        -:   85:  ECMA_STRING_PROTOTYPE_PAD_START,
        -:   86:  ECMA_STRING_PROTOTYPE_PAD_END,
        -:   87:  /* Note: These 5 routines MUST be in this order */
        -:   88:  ECMA_STRING_PROTOTYPE_LAST_INDEX_OF,
        -:   89:  ECMA_STRING_PROTOTYPE_INDEX_OF,
        -:   90:  ECMA_STRING_PROTOTYPE_STARTS_WITH,
        -:   91:  ECMA_STRING_PROTOTYPE_INCLUDES,
        -:   92:  ECMA_STRING_PROTOTYPE_ENDS_WITH,
        -:   93:
        -:   94:  ECMA_STRING_PROTOTYPE_ITERATOR,
        -:   95:  ECMA_STRING_PROTOTYPE_REPLACE_ALL,
        -:   96:  ECMA_STRING_PROTOTYPE_MATCH_ALL,
        -:   97:};
        -:   98:
        -:   99:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-string-prototype.inc.h"
        -:  100:#define BUILTIN_UNDERSCORED_ID  string_prototype
        -:  101:#include "ecma-builtin-internal-routines-template.inc.h"
        -:  102:
        -:  103:/** \addtogroup ecma ECMA
        -:  104: * @{
        -:  105: *
        -:  106: * \addtogroup ecmabuiltins
        -:  107: * @{
        -:  108: *
        -:  109: * \addtogroup stringprototype ECMA String.prototype object built-in
        -:  110: * @{
        -:  111: */
        -:  112:
        -:  113:/**
        -:  114: * The String.prototype object's 'toString' and 'valueOf' routines
        -:  115: *
        -:  116: * See also:
        -:  117: *          ECMA-262 v5, 15.5.4.2
        -:  118: *          ECMA-262 v5, 15.5.4.3
        -:  119: *
        -:  120: * @return ecma value
        -:  121: *         Returned value must be freed with ecma_free_value.
        -:  122: */
        -:  123:static ecma_value_t
    #####:  124:ecma_builtin_string_prototype_object_to_string (ecma_value_t this_arg) /**< this argument */
        -:  125:{
    #####:  126:  if (ecma_is_value_string (this_arg))
        -:  127:  {
    #####:  128:    return ecma_copy_value (this_arg);
        -:  129:  }
        -:  130:
    #####:  131:  if (ecma_is_value_object (this_arg))
        -:  132:  {
    #####:  133:    ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  134:
    #####:  135:    if (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_STRING))
        -:  136:    {
    #####:  137:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  138:
    #####:  139:      JERRY_ASSERT (ecma_is_value_string (ext_object_p->u.cls.u3.value));
        -:  140:
    #####:  141:      return ecma_copy_value (ext_object_p->u.cls.u3.value);
        -:  142:    }
        -:  143:  }
        -:  144:
    #####:  145:  return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_STRING_OBJECT);
        -:  146:} /* ecma_builtin_string_prototype_object_to_string */
        -:  147:
        -:  148:/**
        -:  149: * Helper function for the String.prototype object's 'charAt' and charCodeAt' routine
        -:  150: *
        -:  151: * @return ecma value
        -:  152: *         Returned value must be freed with ecma_free_value.
        -:  153: */
        -:  154:static ecma_value_t
    #####:  155:ecma_builtin_string_prototype_char_at_helper (ecma_value_t this_arg, /**< this argument */
        -:  156:                                              ecma_value_t arg, /**< routine's argument */
        -:  157:                                              bool charcode_mode) /**< routine mode */
        -:  158:{
        -:  159:  /* 3 */
    #####:  160:  ecma_number_t index_num;
    #####:  161:  ecma_value_t to_num_result = ecma_op_to_integer (arg, &index_num);
        -:  162:
    #####:  163:  if (JERRY_UNLIKELY (!ecma_is_value_empty (to_num_result)))
        -:  164:  {
    #####:  165:    return to_num_result;
        -:  166:  }
        -:  167:
        -:  168:  /* 2 */
    #####:  169:  ecma_string_t *original_string_p = ecma_op_to_string (this_arg);
    #####:  170:  if (JERRY_UNLIKELY (original_string_p == NULL))
        -:  171:  {
    #####:  172:    return ECMA_VALUE_ERROR;
        -:  173:  }
        -:  174:
        -:  175:  /* 4 */
    #####:  176:  const lit_utf8_size_t len = ecma_string_get_length (original_string_p);
        -:  177:
        -:  178:  /* 5 */
        -:  179:  // When index_num is NaN, then the first two comparisons are false
    #####:  180:  if (index_num < 0 || index_num >= len || (ecma_number_is_nan (index_num) && len == 0))
        -:  181:  {
    #####:  182:    ecma_deref_ecma_string (original_string_p);
    #####:  183:    return (charcode_mode ? ecma_make_nan_value () : ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY));
        -:  184:  }
        -:  185:
        -:  186:  /* 6 */
        -:  187:  /*
        -:  188:   * String length is currently uint32_t, but index_num may be bigger,
        -:  189:   * ToInteger performs floor, while ToUInt32 performs modulo 2^32,
        -:  190:   * hence after the check 0 <= index_num < len we assume to_uint32 can be used.
        -:  191:   * We assume to_uint32 (NaN) is 0.
        -:  192:   */
    #####:  193:  JERRY_ASSERT (ecma_number_is_nan (index_num) || ecma_number_to_uint32 (index_num) == ecma_number_trunc (index_num));
        -:  194:
    #####:  195:  ecma_char_t new_ecma_char = ecma_string_get_char_at_pos (original_string_p, ecma_number_to_uint32 (index_num));
    #####:  196:  ecma_deref_ecma_string (original_string_p);
        -:  197:
    #####:  198:  return (charcode_mode ? ecma_make_uint32_value (new_ecma_char)
    #####:  199:                        : ecma_make_string_value (ecma_new_ecma_string_from_code_unit (new_ecma_char)));
        -:  200:} /* ecma_builtin_string_prototype_char_at_helper */
        -:  201:
        -:  202:/**
        -:  203: * The String.prototype object's 'concat' routine
        -:  204: *
        -:  205: * See also:
        -:  206: *          ECMA-262 v5, 15.5.4.6
        -:  207: *
        -:  208: * @return ecma value
        -:  209: *         Returned value must be freed with ecma_free_value.
        -:  210: */
        -:  211:static ecma_value_t
    #####:  212:ecma_builtin_string_prototype_object_concat (ecma_string_t *this_string_p, /**< this argument */
        -:  213:                                             const ecma_value_t *argument_list_p, /**< arguments list */
        -:  214:                                             uint32_t arguments_number) /**< number of arguments */
        -:  215:{
    #####:  216:  ecma_stringbuilder_t builder = ecma_stringbuilder_create_from (this_string_p);
        -:  217:
        -:  218:  /* 5 */
    #####:  219:  for (uint32_t arg_index = 0; arg_index < arguments_number; ++arg_index)
        -:  220:  {
        -:  221:    /* 5a, b */
    #####:  222:    ecma_string_t *get_arg_string_p = ecma_op_to_string (argument_list_p[arg_index]);
        -:  223:
    #####:  224:    if (JERRY_UNLIKELY (get_arg_string_p == NULL))
        -:  225:    {
    #####:  226:      ecma_stringbuilder_destroy (&builder);
    #####:  227:      return ECMA_VALUE_ERROR;
        -:  228:    }
        -:  229:
    #####:  230:    ecma_stringbuilder_append (&builder, get_arg_string_p);
        -:  231:
    #####:  232:    ecma_deref_ecma_string (get_arg_string_p);
        -:  233:  }
        -:  234:
        -:  235:  /* 6 */
    #####:  236:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  237:} /* ecma_builtin_string_prototype_object_concat */
        -:  238:
        -:  239:/**
        -:  240: * The String.prototype object's 'localeCompare' routine
        -:  241: *
        -:  242: * See also:
        -:  243: *          ECMA-262 v5, 15.5.4.9
        -:  244: *
        -:  245: * @return ecma value
        -:  246: *         Returned value must be freed with ecma_free_value.
        -:  247: */
        -:  248:static ecma_value_t
    #####:  249:ecma_builtin_string_prototype_object_locale_compare (ecma_string_t *this_string_p, /**< this argument */
        -:  250:                                                     ecma_value_t arg) /**< routine's argument */
        -:  251:{
        -:  252:  /* 3. */
    #####:  253:  ecma_string_t *arg_string_p = ecma_op_to_string (arg);
        -:  254:
    #####:  255:  if (JERRY_UNLIKELY (arg_string_p == NULL))
        -:  256:  {
    #####:  257:    return ECMA_VALUE_ERROR;
        -:  258:  }
        -:  259:
    #####:  260:  ecma_number_t result = ECMA_NUMBER_ZERO;
        -:  261:
    #####:  262:  if (ecma_compare_ecma_strings_relational (this_string_p, arg_string_p))
        -:  263:  {
    #####:  264:    result = ECMA_NUMBER_MINUS_ONE;
        -:  265:  }
    #####:  266:  else if (!ecma_compare_ecma_strings (this_string_p, arg_string_p))
        -:  267:  {
    #####:  268:    result = ECMA_NUMBER_ONE;
        -:  269:  }
        -:  270:  else
        -:  271:  {
    #####:  272:    result = ECMA_NUMBER_ZERO;
        -:  273:  }
        -:  274:
    #####:  275:  ecma_deref_ecma_string (arg_string_p);
        -:  276:
    #####:  277:  return ecma_make_number_value (result);
        -:  278:} /* ecma_builtin_string_prototype_object_locale_compare */
        -:  279:
        -:  280:#if JERRY_BUILTIN_REGEXP
        -:  281:/**
        -:  282: * The String.prototype object's 'match' routine
        -:  283: *
        -:  284: * See also:
        -:  285: *          ECMA-262 v5, 15.5.4.10
        -:  286: *
        -:  287: * @return ecma value
        -:  288: *         Returned value must be freed with ecma_free_value.
        -:  289: */
        -:  290:static ecma_value_t
    #####:  291:ecma_builtin_string_prototype_object_match (ecma_value_t this_argument, /**< this argument */
        -:  292:                                            ecma_value_t regexp_arg) /**< routine's argument */
        -:  293:{
        -:  294:#if JERRY_ESNEXT
        -:  295:  /* 3. */
    #####:  296:  if (!(ecma_is_value_undefined (regexp_arg) || ecma_is_value_null (regexp_arg)))
        -:  297:  {
        -:  298:    /* 3.a */
    #####:  299:    ecma_value_t matcher = ecma_op_get_method_by_symbol_id (regexp_arg, LIT_GLOBAL_SYMBOL_MATCH);
        -:  300:
        -:  301:    /* 3.b */
    #####:  302:    if (ECMA_IS_VALUE_ERROR (matcher))
        -:  303:    {
    #####:  304:      return matcher;
        -:  305:    }
        -:  306:
        -:  307:    /* 3.c */
    #####:  308:    if (!ecma_is_value_undefined (matcher))
        -:  309:    {
        -:  310:      /* 3.c.i */
    #####:  311:      ecma_object_t *matcher_method = ecma_get_object_from_value (matcher);
    #####:  312:      ecma_value_t result = ecma_op_function_call (matcher_method, regexp_arg, &this_argument, 1);
    #####:  313:      ecma_deref_object (matcher_method);
    #####:  314:      return result;
        -:  315:    }
        -:  316:  }
        -:  317:
        -:  318:  /* 4. */
    #####:  319:  ecma_string_t *this_str_p = ecma_op_to_string (this_argument);
        -:  320:
        -:  321:  /* 5. */
    #####:  322:  if (JERRY_UNLIKELY (this_str_p == NULL))
        -:  323:  {
    #####:  324:    return ECMA_VALUE_ERROR;
        -:  325:  }
        -:  326:
        -:  327:  /* 6. */
    #####:  328:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  329:
    #####:  330:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  331:  {
    #####:  332:    ecma_deref_ecma_string (this_str_p);
    #####:  333:    return ECMA_VALUE_ERROR;
        -:  334:  }
        -:  335:
    #####:  336:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (regexp_obj_p, regexp_arg, ECMA_VALUE_UNDEFINED);
        -:  337:
        -:  338:  /* 7. */
    #####:  339:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  340:  {
    #####:  341:    ecma_deref_object (regexp_obj_p);
    #####:  342:    ecma_deref_ecma_string (this_str_p);
    #####:  343:    return new_regexp;
        -:  344:  }
    #####:  345:  ecma_value_t this_str_value = ecma_make_string_value (this_str_p);
        -:  346:
        -:  347:  /* 8. */
    #####:  348:  ecma_value_t ret_value = ecma_op_invoke_by_symbol_id (new_regexp, LIT_GLOBAL_SYMBOL_MATCH, &this_str_value, 1);
        -:  349:
    #####:  350:  ecma_deref_ecma_string (this_str_p);
    #####:  351:  ecma_free_value (new_regexp);
        -:  352:
    #####:  353:  return ret_value;
        -:  354:
        -:  355:#else /* !JERRY_ESNEXT */
    #####:  356:  if (ecma_object_is_regexp_object (regexp_arg))
        -:  357:  {
    #####:  358:    return ecma_regexp_match_helper (regexp_arg, this_argument);
        -:  359:  }
        -:  360:
    #####:  361:  ecma_object_t *regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  362:
    #####:  363:  if (JERRY_UNLIKELY (regexp_obj_p == NULL))
        -:  364:  {
        -:  365:    return ECMA_VALUE_ERROR;
        -:  366:  }
        -:  367:
    #####:  368:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (regexp_obj_p, regexp_arg, ECMA_VALUE_UNDEFINED);
        -:  369:
    #####:  370:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  371:  {
    #####:  372:    ecma_deref_object (regexp_obj_p);
    #####:  373:    return new_regexp;
        -:  374:  }
        -:  375:
    #####:  376:  ecma_value_t result = ecma_regexp_match_helper (new_regexp, this_argument);
        -:  377:
    #####:  378:  ecma_free_value (new_regexp);
        -:  379:
    #####:  380:  return result;
        -:  381:#endif /* JERRY_ESNEXT */
        -:  382:} /* ecma_builtin_string_prototype_object_match */
        -:  383:
        -:  384:#if JERRY_ESNEXT
        -:  385:/**
        -:  386: * The String.prototype object's 'matchAll' routine
        -:  387: *
        -:  388: * See also:
        -:  389: *          ECMA-262 v11, 21.1.3.12
        -:  390: *
        -:  391: * @return ecma value
        -:  392: *         Returned value must be freed with ecma_free_value.
        -:  393: */
        -:  394:static ecma_value_t
    #####:  395:ecma_builtin_string_prototype_object_match_all (ecma_value_t this_argument, /**< this argument */
        -:  396:                                                ecma_value_t regexp_arg) /**< routine's argument */
        -:  397:{
        -:  398:  /* 2. */
    #####:  399:  if (!ecma_is_value_null (regexp_arg) && !ecma_is_value_undefined (regexp_arg))
        -:  400:  {
        -:  401:    /* 2.a */
    #####:  402:    ecma_value_t is_regexp = ecma_op_is_regexp (regexp_arg);
        -:  403:
    #####:  404:    if (ECMA_IS_VALUE_ERROR (is_regexp))
        -:  405:    {
    #####:  406:      return is_regexp;
        -:  407:    }
        -:  408:
        -:  409:    /* 2.b */
    #####:  410:    if (ecma_is_value_true (is_regexp))
        -:  411:    {
        -:  412:      /* 2.b.i */
    #####:  413:      ecma_object_t *regexp_obj_p = ecma_get_object_from_value (regexp_arg);
    #####:  414:      ecma_value_t get_flags = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_FLAGS);
        -:  415:
    #####:  416:      if (ECMA_IS_VALUE_ERROR (get_flags))
        -:  417:      {
    #####:  418:        return get_flags;
        -:  419:      }
        -:  420:
        -:  421:      /* 2.b.ii */
    #####:  422:      if (!ecma_op_require_object_coercible (get_flags))
        -:  423:      {
    #####:  424:        ecma_free_value (get_flags);
    #####:  425:        return ECMA_VALUE_ERROR;
        -:  426:      }
        -:  427:
        -:  428:      /* 2.b.iii */
    #####:  429:      ecma_string_t *flags = ecma_op_to_string (get_flags);
        -:  430:
    #####:  431:      ecma_free_value (get_flags);
        -:  432:
    #####:  433:      if (JERRY_UNLIKELY (flags == NULL))
        -:  434:      {
    #####:  435:        return ECMA_VALUE_ERROR;
        -:  436:      }
        -:  437:
    #####:  438:      uint16_t parsed_flag;
    #####:  439:      ecma_value_t flag_parse = ecma_regexp_parse_flags (flags, &parsed_flag);
        -:  440:
    #####:  441:      ecma_deref_ecma_string (flags);
        -:  442:
    #####:  443:      if (ECMA_IS_VALUE_ERROR (flag_parse))
        -:  444:      {
    #####:  445:        return flag_parse;
        -:  446:      }
        -:  447:
    #####:  448:      if (!(parsed_flag & RE_FLAG_GLOBAL))
        -:  449:      {
    #####:  450:        return ecma_raise_type_error (ECMA_ERR_REGEXP_ARGUMENT_SHOULD_HAVE_GLOBAL_FLAG);
        -:  451:      }
        -:  452:    }
        -:  453:
        -:  454:    /* 2.c */
    #####:  455:    ecma_value_t matcher = ecma_op_get_method_by_symbol_id (regexp_arg, LIT_GLOBAL_SYMBOL_MATCH_ALL);
        -:  456:
    #####:  457:    if (ECMA_IS_VALUE_ERROR (matcher))
        -:  458:    {
    #####:  459:      return matcher;
        -:  460:    }
        -:  461:
        -:  462:    /* 2.d */
    #####:  463:    if (!ecma_is_value_undefined (matcher))
        -:  464:    {
        -:  465:      /* 2.d.i */
    #####:  466:      ecma_object_t *matcher_method = ecma_get_object_from_value (matcher);
    #####:  467:      ecma_value_t result = ecma_op_function_call (matcher_method, regexp_arg, &this_argument, 1);
    #####:  468:      ecma_deref_object (matcher_method);
    #####:  469:      return result;
        -:  470:    }
        -:  471:  }
        -:  472:
        -:  473:  /* 3. */
    #####:  474:  ecma_string_t *str_p = ecma_op_to_string (this_argument);
        -:  475:
    #####:  476:  if (JERRY_UNLIKELY (str_p == NULL))
        -:  477:  {
    #####:  478:    return ECMA_VALUE_ERROR;
        -:  479:  }
        -:  480:
        -:  481:  /* 4. */
    #####:  482:  ecma_object_t *new_regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  483:
    #####:  484:  if (JERRY_UNLIKELY (new_regexp_obj_p == NULL))
        -:  485:  {
    #####:  486:    ecma_deref_ecma_string (str_p);
    #####:  487:    return ECMA_VALUE_ERROR;
        -:  488:  }
        -:  489:
    #####:  490:  ecma_value_t new_regexp = ecma_op_create_regexp_from_pattern (new_regexp_obj_p, regexp_arg, ECMA_VALUE_UNDEFINED);
        -:  491:
    #####:  492:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  493:  {
    #####:  494:    ecma_deref_ecma_string (str_p);
    #####:  495:    ecma_deref_object (new_regexp_obj_p);
    #####:  496:    return new_regexp;
        -:  497:  }
        -:  498:
        -:  499:  /* 5. */
    #####:  500:  ecma_value_t string_arg = ecma_make_string_value (str_p);
    #####:  501:  ecma_value_t ret_value = ecma_op_invoke_by_symbol_id (new_regexp, LIT_GLOBAL_SYMBOL_MATCH_ALL, &string_arg, 1);
        -:  502:
    #####:  503:  ecma_deref_ecma_string (str_p);
    #####:  504:  ecma_free_value (new_regexp);
        -:  505:
    #####:  506:  return ret_value;
        -:  507:} /* ecma_builtin_string_prototype_object_match_all */
        -:  508:#endif /* JERRY_ESNEXT */
        -:  509:
        -:  510:/**
        -:  511: * The String.prototype object's 'replace' and 'replaceAll' routine
        -:  512: *
        -:  513: * See also:
        -:  514: *          ECMA-262 v5, 15.5.4.11 (replace ES5)
        -:  515: *          ECMA-262 v6, 21.1.3.14 (replace ES6)
        -:  516: *          ECMA-262 v12, 21.1.3.18 (replaceAll)
        -:  517: *
        -:  518: * @return ecma value
        -:  519: *         Returned value must be freed with ecma_free_value.
        -:  520: */
        -:  521:static ecma_value_t
    #####:  522:ecma_builtin_string_prototype_object_replace_helper (ecma_value_t this_value, /**< this argument */
        -:  523:                                                     ecma_value_t search_value, /**< routine's first argument */
        -:  524:                                                     ecma_value_t replace_value, /**< routine's second argument */
        -:  525:                                                     bool replace_all)
        -:  526:{
        -:  527:#if JERRY_ESNEXT
    #####:  528:  if (!(ecma_is_value_undefined (search_value) || ecma_is_value_null (search_value)))
        -:  529:  {
    #####:  530:    if (replace_all)
        -:  531:    {
    #####:  532:      ecma_value_t is_regexp = ecma_op_is_regexp (search_value);
        -:  533:
    #####:  534:      if (ECMA_IS_VALUE_ERROR (is_regexp))
        -:  535:      {
    #####:  536:        return is_regexp;
        -:  537:      }
        -:  538:
    #####:  539:      if (ecma_is_value_true (is_regexp))
        -:  540:      {
    #####:  541:        ecma_object_t *regexp_obj_p = ecma_get_object_from_value (search_value);
    #####:  542:        ecma_value_t get_flags = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_FLAGS);
        -:  543:
    #####:  544:        if (ECMA_IS_VALUE_ERROR (get_flags))
        -:  545:        {
    #####:  546:          return get_flags;
        -:  547:        }
        -:  548:
    #####:  549:        if (!ecma_op_require_object_coercible (get_flags))
        -:  550:        {
    #####:  551:          ecma_free_value (get_flags);
    #####:  552:          return ECMA_VALUE_ERROR;
        -:  553:        }
        -:  554:
    #####:  555:        ecma_string_t *flags = ecma_op_to_string (get_flags);
        -:  556:
    #####:  557:        ecma_free_value (get_flags);
        -:  558:
    #####:  559:        if (JERRY_UNLIKELY (flags == NULL))
        -:  560:        {
    #####:  561:          return ECMA_VALUE_ERROR;
        -:  562:        }
        -:  563:
    #####:  564:        bool have_global_flag = lit_find_char_in_string (flags, LIT_CHAR_LOWERCASE_G);
        -:  565:
    #####:  566:        ecma_deref_ecma_string (flags);
        -:  567:
    #####:  568:        if (!have_global_flag)
        -:  569:        {
    #####:  570:          return ecma_raise_type_error (ECMA_ERR_REGEXP_ARGUMENT_SHOULD_HAVE_GLOBAL_FLAG);
        -:  571:        }
        -:  572:      }
        -:  573:    }
        -:  574:
    #####:  575:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (search_value));
    #####:  576:    ecma_value_t replace_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_REPLACE);
    #####:  577:    ecma_deref_object (obj_p);
        -:  578:
    #####:  579:    if (ECMA_IS_VALUE_ERROR (replace_symbol))
        -:  580:    {
    #####:  581:      return replace_symbol;
        -:  582:    }
        -:  583:
    #####:  584:    if (!ecma_is_value_undefined (replace_symbol) && !ecma_is_value_null (replace_symbol))
        -:  585:    {
    #####:  586:      ecma_value_t arguments[] = { this_value, replace_value };
    #####:  587:      ecma_value_t replace_result = ecma_op_function_validated_call (replace_symbol, search_value, arguments, 2);
    #####:  588:      ecma_free_value (replace_symbol);
        -:  589:
    #####:  590:      return replace_result;
        -:  591:    }
        -:  592:  }
        -:  593:#else /* !JERRY_ESNEXT */
    #####:  594:  if (ecma_object_is_regexp_object (search_value))
        -:  595:  {
    #####:  596:    return ecma_regexp_replace_helper (search_value, this_value, replace_value);
        -:  597:  }
        -:  598:#endif /* JERRY_ESNEXT */
        -:  599:
    #####:  600:  ecma_string_t *input_str_p = ecma_op_to_string (this_value);
        -:  601:
    #####:  602:  if (input_str_p == NULL)
        -:  603:  {
    #####:  604:    return ECMA_VALUE_ERROR;
        -:  605:  }
        -:  606:
    #####:  607:  ecma_value_t result = ECMA_VALUE_ERROR;
        -:  608:
    #####:  609:  ecma_string_t *search_str_p = ecma_op_to_string (search_value);
    #####:  610:  if (search_str_p == NULL)
        -:  611:  {
    #####:  612:    ecma_deref_ecma_string (input_str_p);
    #####:  613:    return result;
        -:  614:  }
        -:  615:
    #####:  616:  ecma_replace_context_t replace_ctx;
    #####:  617:  replace_ctx.capture_count = 0;
    #####:  618:  replace_ctx.u.captures_p = NULL;
        -:  619:
    #####:  620:  replace_ctx.replace_str_p = NULL;
    #####:  621:  if (!ecma_op_is_callable (replace_value))
        -:  622:  {
    #####:  623:    replace_ctx.replace_str_p = ecma_op_to_string (replace_value);
    #####:  624:    if (replace_ctx.replace_str_p == NULL)
        -:  625:    {
    #####:  626:      goto cleanup_search;
        -:  627:    }
        -:  628:  }
        -:  629:
    #####:  630:  uint8_t input_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  631:  replace_ctx.string_p = ecma_string_get_chars (input_str_p, &(replace_ctx.string_size), NULL, NULL, &input_flags);
        -:  632:
    #####:  633:  lit_utf8_size_t search_size;
    #####:  634:  lit_utf8_size_t search_length;
    #####:  635:  uint8_t search_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  636:  const lit_utf8_byte_t *search_buf_p =
        -:  637:    ecma_string_get_chars (search_str_p, &search_size, &search_length, NULL, &search_flags);
        -:  638:
    #####:  639:  ecma_string_t *result_string_p = NULL;
        -:  640:
    #####:  641:  if (replace_ctx.string_size >= search_size)
        -:  642:  {
    #####:  643:    replace_ctx.builder = ecma_stringbuilder_create ();
    #####:  644:    replace_ctx.matched_size = search_size;
    #####:  645:    const lit_utf8_byte_t *const input_end_p = replace_ctx.string_p + replace_ctx.string_size;
    #####:  646:    const lit_utf8_byte_t *const loop_end_p = input_end_p - search_size;
    #####:  647:    const lit_utf8_byte_t *last_match_end_p = replace_ctx.string_p;
    #####:  648:    const lit_utf8_byte_t *curr_p = replace_ctx.string_p;
        -:  649:
    #####:  650:    lit_utf8_size_t pos = 0;
    #####:  651:    while (curr_p <= loop_end_p)
        -:  652:    {
    #####:  653:      if (!memcmp (curr_p, search_buf_p, search_size))
        -:  654:      {
    #####:  655:        const lit_utf8_size_t prefix_size = (lit_utf8_size_t) (curr_p - last_match_end_p);
    #####:  656:        ecma_stringbuilder_append_raw (&replace_ctx.builder, last_match_end_p, prefix_size);
        -:  657:
    #####:  658:        last_match_end_p = curr_p + search_size;
        -:  659:
    #####:  660:        if (replace_ctx.replace_str_p == NULL)
        -:  661:        {
    #####:  662:          ecma_object_t *function_p = ecma_get_object_from_value (replace_value);
        -:  663:
    #####:  664:          ecma_value_t args[] = { ecma_make_string_value (search_str_p),
    #####:  665:                                  ecma_make_uint32_value (pos),
    #####:  666:                                  ecma_make_string_value (input_str_p) };
        -:  667:
    #####:  668:          result = ecma_op_function_call (function_p, ECMA_VALUE_UNDEFINED, args, 3);
        -:  669:
    #####:  670:          if (ECMA_IS_VALUE_ERROR (result))
        -:  671:          {
    #####:  672:            ecma_stringbuilder_destroy (&replace_ctx.builder);
    #####:  673:            goto cleanup_replace;
        -:  674:          }
        -:  675:
    #####:  676:          ecma_string_t *const result_str_p = ecma_op_to_string (result);
    #####:  677:          ecma_free_value (result);
        -:  678:
    #####:  679:          if (result_str_p == NULL)
        -:  680:          {
    #####:  681:            ecma_stringbuilder_destroy (&replace_ctx.builder);
    #####:  682:            result = ECMA_VALUE_ERROR;
    #####:  683:            goto cleanup_replace;
        -:  684:          }
        -:  685:
    #####:  686:          ecma_stringbuilder_append (&replace_ctx.builder, result_str_p);
    #####:  687:          ecma_deref_ecma_string (result_str_p);
        -:  688:        }
        -:  689:        else
        -:  690:        {
    #####:  691:          replace_ctx.matched_p = curr_p;
    #####:  692:          replace_ctx.match_byte_pos = (lit_utf8_size_t) (curr_p - replace_ctx.string_p);
        -:  693:
    #####:  694:          ecma_builtin_replace_substitute (&replace_ctx);
        -:  695:        }
        -:  696:
    #####:  697:        if (!replace_all || last_match_end_p == input_end_p)
        -:  698:        {
        -:  699:          break;
        -:  700:        }
        -:  701:
    #####:  702:        if (search_size != 0)
        -:  703:        {
    #####:  704:          curr_p = last_match_end_p;
    #####:  705:          pos += search_length;
    #####:  706:          continue;
        -:  707:        }
        -:  708:      }
        -:  709:
    #####:  710:      pos++;
    #####:  711:      lit_utf8_incr (&curr_p);
        -:  712:    }
        -:  713:
    #####:  714:    ecma_stringbuilder_append_raw (&replace_ctx.builder,
        -:  715:                                   last_match_end_p,
    #####:  716:                                   (lit_utf8_size_t) (input_end_p - last_match_end_p));
    #####:  717:    result_string_p = ecma_stringbuilder_finalize (&replace_ctx.builder);
        -:  718:  }
        -:  719:
    #####:  720:  if (result_string_p == NULL)
        -:  721:  {
    #####:  722:    ecma_ref_ecma_string (input_str_p);
    #####:  723:    result_string_p = input_str_p;
        -:  724:  }
        -:  725:
    #####:  726:  result = ecma_make_string_value (result_string_p);
        -:  727:
    #####:  728:cleanup_replace:
    #####:  729:  if (input_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -:  730:  {
    #####:  731:    jmem_heap_free_block ((void *) replace_ctx.string_p, replace_ctx.string_size);
        -:  732:  }
        -:  733:
    #####:  734:  if (search_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -:  735:  {
    #####:  736:    jmem_heap_free_block ((void *) search_buf_p, search_size);
        -:  737:  }
        -:  738:
    #####:  739:  if (replace_ctx.replace_str_p != NULL)
        -:  740:  {
    #####:  741:    ecma_deref_ecma_string (replace_ctx.replace_str_p);
        -:  742:  }
        -:  743:
    #####:  744:cleanup_search:
    #####:  745:  ecma_deref_ecma_string (search_str_p);
    #####:  746:  ecma_deref_ecma_string (input_str_p);
        -:  747:
    #####:  748:  return result;
        -:  749:} /* ecma_builtin_string_prototype_object_replace_helper */
        -:  750:
        -:  751:/**
        -:  752: * The String.prototype object's 'search' routine
        -:  753: *
        -:  754: * See also:
        -:  755: *          ECMA-262 v5, 15.5.4.12
        -:  756: *          ECMA-262 v6, 21.1.3.15
        -:  757: *
        -:  758: * @return ecma value
        -:  759: *         Returned value must be freed with ecma_free_value.
        -:  760: */
        -:  761:static ecma_value_t
    #####:  762:ecma_builtin_string_prototype_object_search (ecma_value_t this_value, /**< this argument */
        -:  763:                                             ecma_value_t regexp_value) /**< routine's argument */
        -:  764:{
        -:  765:#if JERRY_ESNEXT
    #####:  766:  if (!(ecma_is_value_undefined (regexp_value) || ecma_is_value_null (regexp_value)))
        -:  767:  {
    #####:  768:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (regexp_value));
    #####:  769:    ecma_value_t search_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_SEARCH);
    #####:  770:    ecma_deref_object (obj_p);
        -:  771:
    #####:  772:    if (ECMA_IS_VALUE_ERROR (search_symbol))
        -:  773:    {
    #####:  774:      return search_symbol;
        -:  775:    }
        -:  776:
    #####:  777:    if (!ecma_is_value_undefined (search_symbol) && !ecma_is_value_null (search_symbol))
        -:  778:    {
    #####:  779:      ecma_value_t search_result = ecma_op_function_validated_call (search_symbol, regexp_value, &this_value, 1);
    #####:  780:      ecma_free_value (search_symbol);
    #####:  781:      return search_result;
        -:  782:    }
        -:  783:  }
        -:  784:#else /* !JERRY_ESNEXT */
    #####:  785:  if (ecma_object_is_regexp_object (regexp_value))
        -:  786:  {
    #####:  787:    return ecma_regexp_search_helper (regexp_value, this_value);
        -:  788:  }
        -:  789:#endif /* JERRY_ESNEXT */
        -:  790:
    #####:  791:  ecma_value_t result = ECMA_VALUE_ERROR;
        -:  792:
    #####:  793:  ecma_string_t *string_p = ecma_op_to_string (this_value);
    #####:  794:  if (string_p == NULL)
        -:  795:  {
    #####:  796:    return result;
        -:  797:  }
        -:  798:
    #####:  799:  ecma_string_t *pattern_p = ecma_regexp_read_pattern_str_helper (regexp_value);
    #####:  800:  if (pattern_p == NULL)
        -:  801:  {
    #####:  802:    goto cleanup_string;
        -:  803:  }
        -:  804:
    #####:  805:  ecma_object_t *new_regexp_obj_p = ecma_op_regexp_alloc (NULL);
        -:  806:
    #####:  807:  if (JERRY_UNLIKELY (new_regexp_obj_p == NULL))
        -:  808:  {
    #####:  809:    ecma_deref_ecma_string (string_p);
    #####:  810:    ecma_deref_ecma_string (pattern_p);
    #####:  811:    return ECMA_VALUE_ERROR;
        -:  812:  }
        -:  813:
    #####:  814:  ecma_value_t new_regexp =
    #####:  815:    ecma_op_create_regexp_from_pattern (new_regexp_obj_p, ecma_make_string_value (pattern_p), ECMA_VALUE_UNDEFINED);
        -:  816:
    #####:  817:  ecma_deref_ecma_string (pattern_p);
        -:  818:
    #####:  819:  if (ECMA_IS_VALUE_ERROR (new_regexp))
        -:  820:  {
    #####:  821:    ecma_deref_object (new_regexp_obj_p);
    #####:  822:    goto cleanup_string;
        -:  823:  }
        -:  824:
        -:  825:#if !JERRY_ESNEXT
    #####:  826:  result = ecma_regexp_search_helper (new_regexp, ecma_make_string_value (string_p));
    #####:  827:  ecma_deref_object (ecma_get_object_from_value (new_regexp));
        -:  828:#else /* JERRY_ESNEXT */
    #####:  829:  ecma_object_t *regexp_obj_p = ecma_get_object_from_value (new_regexp);
    #####:  830:  ecma_value_t this_str_value = ecma_make_string_value (string_p);
    #####:  831:  result = ecma_op_invoke_by_symbol_id (new_regexp, LIT_GLOBAL_SYMBOL_SEARCH, &this_str_value, 1);
    #####:  832:  ecma_deref_object (regexp_obj_p);
        -:  833:#endif /* !JERRY_ESNEXT */
        -:  834:
    #####:  835:cleanup_string:
    #####:  836:  ecma_deref_ecma_string (string_p);
    #####:  837:  return result;
        -:  838:} /* ecma_builtin_string_prototype_object_search */
        -:  839:
        -:  840:#endif /* JERRY_BUILTIN_REGEXP */
        -:  841:
        -:  842:/**
        -:  843: * The String.prototype object's 'slice' routine
        -:  844: *
        -:  845: * See also:
        -:  846: *          ECMA-262 v5, 15.5.4.13
        -:  847: *
        -:  848: * @return ecma value
        -:  849: *         Returned value must be freed with ecma_free_value.
        -:  850: */
        -:  851:static ecma_value_t
    #####:  852:ecma_builtin_string_prototype_object_slice (ecma_string_t *get_string_val, /**< this argument */
        -:  853:                                            ecma_value_t arg1, /**< routine's first argument */
        -:  854:                                            ecma_value_t arg2) /**< routine's second argument */
        -:  855:{
    #####:  856:  const lit_utf8_size_t len = ecma_string_get_length (get_string_val);
        -:  857:
        -:  858:  /* 4. 6. */
    #####:  859:  lit_utf8_size_t start = 0, end = len;
        -:  860:
    #####:  861:  if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (arg1, len, &start)))
        -:  862:  {
    #####:  863:    return ECMA_VALUE_ERROR;
        -:  864:  }
        -:  865:
        -:  866:  /* 5. 7. */
    #####:  867:  if (ecma_is_value_undefined (arg2))
        -:  868:  {
    #####:  869:    end = len;
        -:  870:  }
        -:  871:  else
        -:  872:  {
    #####:  873:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (arg2, len, &end)))
        -:  874:    {
    #####:  875:      return ECMA_VALUE_ERROR;
        -:  876:    }
        -:  877:  }
        -:  878:
    #####:  879:  JERRY_ASSERT (start <= len && end <= len);
        -:  880:
        -:  881:  /* 8-9. */
    #####:  882:  ecma_string_t *new_str_p = ecma_string_substr (get_string_val, start, end);
        -:  883:
    #####:  884:  return ecma_make_string_value (new_str_p);
        -:  885:} /* ecma_builtin_string_prototype_object_slice */
        -:  886:
        -:  887:/**
        -:  888: * The String.prototype object's 'at' routine
        -:  889: *
        -:  890: * See also:
        -:  891: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal
        -:  892: *          from: https://tc39.es/proposal-relative-indexing-method
        -:  893: *
        -:  894: * @return ecma value
        -:  895: *         Returned value must be freed with ecma_free_value.
        -:  896: */
        -:  897:static ecma_value_t
    #####:  898:ecma_builtin_string_prototype_object_at (ecma_string_t *string_val, /**< this argument */
        -:  899:                                         const ecma_value_t index) /**< index argument */
        -:  900:{
    #####:  901:  ecma_length_t len = (ecma_length_t) ecma_string_get_length (string_val);
    #####:  902:  ecma_length_t res_index;
    #####:  903:  ecma_value_t return_value = ecma_builtin_helper_calculate_index (index, len, &res_index);
        -:  904:
    #####:  905:  if (return_value != ECMA_VALUE_EMPTY)
        -:  906:  {
    #####:  907:    return return_value;
        -:  908:  }
        -:  909:
    #####:  910:  ecma_char_t character = ecma_string_get_char_at_pos (string_val, (lit_utf8_size_t) res_index);
        -:  911:
    #####:  912:  return ecma_make_string_value (ecma_new_ecma_string_from_code_unit (character));
        -:  913:} /* ecma_builtin_string_prototype_object_at */
        -:  914:
        -:  915:/**
        -:  916: * The String.prototype object's 'split' routine
        -:  917: *
        -:  918: * See also:
        -:  919: *          ECMA-262 v5, 15.5.4.14
        -:  920: *
        -:  921: * @return ecma value
        -:  922: *         Returned value must be freed with ecma_free_value.
        -:  923: */
        -:  924:static ecma_value_t
    #####:  925:ecma_builtin_string_prototype_object_split (ecma_value_t this_value, /**< this argument */
        -:  926:                                            ecma_value_t separator_value, /**< separator */
        -:  927:                                            ecma_value_t limit_value) /**< limit */
        -:  928:{
        -:  929:#if JERRY_ESNEXT
    #####:  930:  if (!(ecma_is_value_undefined (separator_value) || ecma_is_value_null (separator_value)))
        -:  931:  {
    #####:  932:    ecma_object_t *obj_p = ecma_get_object_from_value (ecma_op_to_object (separator_value));
    #####:  933:    ecma_value_t split_symbol = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_SPLIT);
    #####:  934:    ecma_deref_object (obj_p);
        -:  935:
    #####:  936:    if (ECMA_IS_VALUE_ERROR (split_symbol))
        -:  937:    {
    #####:  938:      return split_symbol;
        -:  939:    }
        -:  940:
    #####:  941:    if (!ecma_is_value_undefined (split_symbol) && !ecma_is_value_null (split_symbol))
        -:  942:    {
    #####:  943:      ecma_value_t arguments[] = { this_value, limit_value };
    #####:  944:      ecma_value_t split_result = ecma_op_function_validated_call (split_symbol, separator_value, arguments, 2);
    #####:  945:      ecma_free_value (split_symbol);
        -:  946:
    #####:  947:      return split_result;
        -:  948:    }
        -:  949:  }
        -:  950:#else /* !JERRY_ESNEXT */
    #####:  951:  if (ecma_object_is_regexp_object (separator_value))
        -:  952:  {
    #####:  953:    return ecma_regexp_split_helper (separator_value, this_value, limit_value);
        -:  954:  }
        -:  955:#endif /* JERRY_ESNEXT */
        -:  956:
    #####:  957:  ecma_value_t result = ECMA_VALUE_ERROR;
        -:  958:
        -:  959:  /* 4. */
    #####:  960:  ecma_string_t *string_p = ecma_op_to_string (this_value);
    #####:  961:  if (string_p == NULL)
        -:  962:  {
    #####:  963:    return result;
        -:  964:  }
        -:  965:
        -:  966:  /* 8. */
    #####:  967:  uint32_t limit = UINT32_MAX - 1;
        -:  968:
    #####:  969:  if (!ecma_is_value_undefined (limit_value))
        -:  970:  {
        -:  971:    /* ECMA-262 v11, 21.1.3.20 6 */
    #####:  972:    ecma_number_t num;
    #####:  973:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (limit_value, &num)))
        -:  974:    {
    #####:  975:      goto cleanup_string;
        -:  976:    }
    #####:  977:    limit = ecma_number_to_uint32 (num);
        -:  978:  }
        -:  979:
        -:  980:  /* 12. */
    #####:  981:  ecma_string_t *separator_p = ecma_op_to_string (separator_value);
    #####:  982:  if (separator_p == NULL)
        -:  983:  {
    #####:  984:    goto cleanup_string;
        -:  985:  }
        -:  986:
        -:  987:  /* 6. */
    #####:  988:  ecma_object_t *array_p = ecma_op_new_array_object (0);
    #####:  989:  result = ecma_make_object_value (array_p);
        -:  990:
        -:  991:  /* 14. */
    #####:  992:  if (limit == 0)
        -:  993:  {
    #####:  994:    goto cleanup_separator;
        -:  995:  }
        -:  996:
        -:  997:  /* 6. */
    #####:  998:  lit_utf8_size_t array_length = 0;
        -:  999:
        -: 1000:  /* 15. */
    #####: 1001:  if (ecma_is_value_undefined (separator_value))
        -: 1002:  {
    #####: 1003:    ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 1004:                                                                     array_length,
        -: 1005:                                                                     ecma_make_string_value (string_p),
        -: 1006:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1007:    JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####: 1008:    goto cleanup_separator;
        -: 1009:  }
        -: 1010:
        -: 1011:  /* 16. */
    #####: 1012:  if (ecma_string_is_empty (string_p))
        -: 1013:  {
    #####: 1014:    if (!ecma_string_is_empty (separator_p))
        -: 1015:    {
    #####: 1016:      ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 1017:                                                                       array_length,
        -: 1018:                                                                       ecma_make_string_value (string_p),
        -: 1019:                                                                       ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1020:      JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
        -: 1021:    }
        -: 1022:
    #####: 1023:    goto cleanup_separator;
        -: 1024:  }
        -: 1025:
    #####: 1026:  lit_utf8_size_t string_size;
    #####: 1027:  uint8_t string_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 1028:  const lit_utf8_byte_t *string_buffer_p = ecma_string_get_chars (string_p, &string_size, NULL, NULL, &string_flags);
    #####: 1029:  lit_utf8_size_t separator_size;
    #####: 1030:  uint8_t separator_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####: 1031:  const lit_utf8_byte_t *separator_buffer_p =
        -: 1032:    ecma_string_get_chars (separator_p, &separator_size, NULL, NULL, &separator_flags);
        -: 1033:
    #####: 1034:  const lit_utf8_byte_t *const string_end_p = string_buffer_p + string_size;
    #####: 1035:  const lit_utf8_byte_t *const compare_end_p = JERRY_MIN (string_end_p - separator_size + 1, string_end_p);
    #####: 1036:  const lit_utf8_byte_t *current_p = string_buffer_p;
    #####: 1037:  const lit_utf8_byte_t *last_str_begin_p = string_buffer_p;
        -: 1038:
    #####: 1039:  while (current_p < compare_end_p)
        -: 1040:  {
    #####: 1041:    if (!memcmp (current_p, separator_buffer_p, separator_size) && (last_str_begin_p != current_p + separator_size))
        -: 1042:    {
    #####: 1043:      ecma_string_t *substr_p =
    #####: 1044:        ecma_new_ecma_string_from_utf8 (last_str_begin_p, (lit_utf8_size_t) (current_p - last_str_begin_p));
    #####: 1045:      ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
    #####: 1046:                                                                       array_length++,
        -: 1047:                                                                       ecma_make_string_value (substr_p),
        -: 1048:                                                                       ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1049:      JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####: 1050:      ecma_deref_ecma_string (substr_p);
        -: 1051:
    #####: 1052:      if (array_length >= limit)
        -: 1053:      {
    #####: 1054:        goto cleanup_buffers;
        -: 1055:      }
        -: 1056:
    #####: 1057:      current_p += separator_size;
    #####: 1058:      last_str_begin_p = current_p;
    #####: 1059:      continue;
        -: 1060:    }
        -: 1061:
    #####: 1062:    lit_utf8_incr (&current_p);
        -: 1063:  }
        -: 1064:
    #####: 1065:  ecma_string_t *end_substr_p =
    #####: 1066:    ecma_new_ecma_string_from_utf8 (last_str_begin_p, (lit_utf8_size_t) (string_end_p - last_str_begin_p));
    #####: 1067:  ecma_value_t put_result = ecma_builtin_helper_def_prop_by_index (array_p,
        -: 1068:                                                                   array_length,
        -: 1069:                                                                   ecma_make_string_value (end_substr_p),
        -: 1070:                                                                   ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####: 1071:  JERRY_ASSERT (put_result == ECMA_VALUE_TRUE);
    #####: 1072:  ecma_deref_ecma_string (end_substr_p);
        -: 1073:
    #####: 1074:cleanup_buffers:
    #####: 1075:  if (string_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1076:  {
    #####: 1077:    jmem_heap_free_block ((void *) string_buffer_p, string_size);
        -: 1078:  }
        -: 1079:
    #####: 1080:  if (separator_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1081:  {
    #####: 1082:    jmem_heap_free_block ((void *) separator_buffer_p, separator_size);
        -: 1083:  }
        -: 1084:
    #####: 1085:cleanup_separator:
    #####: 1086:  ecma_deref_ecma_string (separator_p);
    #####: 1087:cleanup_string:
    #####: 1088:  ecma_deref_ecma_string (string_p);
    #####: 1089:  return result;
        -: 1090:} /* ecma_builtin_string_prototype_object_split */
        -: 1091:
        -: 1092:/**
        -: 1093: * The String.prototype object's 'substring' routine
        -: 1094: *
        -: 1095: * See also:
        -: 1096: *          ECMA-262 v5, 15.5.4.15
        -: 1097: *
        -: 1098: * @return ecma value
        -: 1099: *         Returned value must be freed with ecma_free_value.
        -: 1100: */
        -: 1101:static ecma_value_t
    #####: 1102:ecma_builtin_string_prototype_object_substring (ecma_string_t *original_string_p, /**< this argument */
        -: 1103:                                                ecma_value_t arg1, /**< routine's first argument */
        -: 1104:                                                ecma_value_t arg2) /**< routine's second argument */
        -: 1105:{
        -: 1106:  /* 3 */
    #####: 1107:  const lit_utf8_size_t len = ecma_string_get_length (original_string_p);
    #####: 1108:  lit_utf8_size_t start = 0, end = len;
        -: 1109:
        -: 1110:  /* 4 */
    #####: 1111:  ecma_number_t start_num;
        -: 1112:
    #####: 1113:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg1, &start_num)))
        -: 1114:  {
    #####: 1115:    return ECMA_VALUE_ERROR;
        -: 1116:  }
        -: 1117:
        -: 1118:  /* 6 */
    #####: 1119:  start = (uint32_t) JERRY_MIN (JERRY_MAX (start_num, 0), len);
        -: 1120:
        -: 1121:  /* 5 */
    #####: 1122:  if (ecma_is_value_undefined (arg2))
        -: 1123:  {
    #####: 1124:    end = len;
        -: 1125:  }
        -: 1126:  else
        -: 1127:  {
        -: 1128:    /* 5 part 2 */
    #####: 1129:    ecma_number_t end_num;
        -: 1130:
    #####: 1131:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg2, &end_num)))
        -: 1132:    {
    #####: 1133:      return ECMA_VALUE_ERROR;
        -: 1134:    }
        -: 1135:    /* 7 */
    #####: 1136:    end = (uint32_t) JERRY_MIN (JERRY_MAX (end_num, 0), len);
        -: 1137:  }
        -: 1138:
    #####: 1139:  JERRY_ASSERT (start <= len && end <= len);
        -: 1140:
        -: 1141:  /* 8 */
    #####: 1142:  uint32_t from = start < end ? start : end;
        -: 1143:
        -: 1144:  /* 9 */
    #####: 1145:  uint32_t to = start > end ? start : end;
        -: 1146:
        -: 1147:  /* 10 */
    #####: 1148:  ecma_string_t *new_str_p = ecma_string_substr (original_string_p, from, to);
    #####: 1149:  return ecma_make_string_value (new_str_p);
        -: 1150:} /* ecma_builtin_string_prototype_object_substring */
        -: 1151:
        -: 1152:/**
        -: 1153: * The common implementation of the String.prototype object's
        -: 1154: * 'toLowerCase', 'toLocaleLowerCase', 'toUpperCase', 'toLocalUpperCase' routines
        -: 1155: *
        -: 1156: * See also:
        -: 1157: *          ECMA-262 v5, 15.5.4.16
        -: 1158: *          ECMA-262 v5, 15.5.4.17
        -: 1159: *          ECMA-262 v5, 15.5.4.18
        -: 1160: *          ECMA-262 v5, 15.5.4.19
        -: 1161: *
        -: 1162: * Helper function to convert a string to upper or lower case.
        -: 1163: *
        -: 1164: * @return ecma value
        -: 1165: *         Returned value must be freed with ecma_free_value.
        -: 1166: */
        -: 1167:static ecma_value_t
    #####: 1168:ecma_builtin_string_prototype_object_conversion_helper (ecma_string_t *input_string_p, /**< this argument */
        -: 1169:                                                        bool lower_case) /**< convert to lower (true)
        -: 1170:                                                                          *   or upper (false) case */
        -: 1171:{
    #####: 1172:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -: 1173:
    #####: 1174:  ECMA_STRING_TO_UTF8_STRING (input_string_p, input_start_p, input_start_size);
        -: 1175:
    #####: 1176:  const lit_utf8_byte_t *input_curr_p = input_start_p;
    #####: 1177:  const lit_utf8_byte_t *input_str_end_p = input_start_p + input_start_size;
        -: 1178:
    #####: 1179:  while (input_curr_p < input_str_end_p)
        -: 1180:  {
    #####: 1181:    lit_code_point_t cp = lit_cesu8_read_next (&input_curr_p);
        -: 1182:
        -: 1183:#if JERRY_ESNEXT
    #####: 1184:    if (lit_is_code_point_utf16_high_surrogate (cp) && input_curr_p < input_str_end_p)
        -: 1185:    {
    #####: 1186:      const ecma_char_t next_ch = lit_cesu8_peek_next (input_curr_p);
    #####: 1187:      if (lit_is_code_point_utf16_low_surrogate (next_ch))
        -: 1188:      {
    #####: 1189:        cp = lit_convert_surrogate_pair_to_code_point ((ecma_char_t) cp, next_ch);
    #####: 1190:        input_curr_p += LIT_UTF8_MAX_BYTES_IN_CODE_UNIT;
        -: 1191:      }
        -: 1192:    }
        -: 1193:#endif /* JERRY_ESNEXT */
        -: 1194:
    #####: 1195:    if (lower_case)
        -: 1196:    {
    #####: 1197:      lit_char_to_lower_case (cp, &builder);
        -: 1198:    }
        -: 1199:    else
        -: 1200:    {
    #####: 1201:      lit_char_to_upper_case (cp, &builder);
        -: 1202:    }
        -: 1203:  }
        -: 1204:
    #####: 1205:  ECMA_FINALIZE_UTF8_STRING (input_start_p, input_start_size);
        -: 1206:
    #####: 1207:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -: 1208:} /* ecma_builtin_string_prototype_object_conversion_helper */
        -: 1209:
        -: 1210:/**
        -: 1211: * The String.prototype object's 'trim' routine
        -: 1212: *
        -: 1213: * See also:
        -: 1214: *          ECMA-262 v5, 15.5.4.20
        -: 1215: *
        -: 1216: * @return ecma value
        -: 1217: *         Returned value must be freed with ecma_free_value.
        -: 1218: */
        -: 1219:static ecma_value_t
    #####: 1220:ecma_builtin_string_prototype_object_trim (ecma_string_t *original_string_p) /**< this argument */
        -: 1221:{
    #####: 1222:  ecma_string_t *trimmed_string_p = ecma_string_trim (original_string_p);
        -: 1223:
    #####: 1224:  return ecma_make_string_value (trimmed_string_p);
        -: 1225:} /* ecma_builtin_string_prototype_object_trim */
        -: 1226:
        -: 1227:#if JERRY_ESNEXT
        -: 1228:
        -: 1229:/**
        -: 1230: * The String.prototype object's 'repeat' routine
        -: 1231: *
        -: 1232: * See also:
        -: 1233: *          ECMA-262 v6, 21.1.3.13
        -: 1234: *
        -: 1235: * @return ecma value
        -: 1236: *         Returned value must be freed with ecma_free_value.
        -: 1237: */
        -: 1238:static ecma_value_t
    #####: 1239:ecma_builtin_string_prototype_object_repeat (ecma_string_t *original_string_p, /**< this argument */
        -: 1240:                                             ecma_value_t repeat) /**< times to repeat */
        -: 1241:{
        -: 1242:  ecma_string_t *ret_string_p;
        -: 1243:
        -: 1244:  /* 4 */
    #####: 1245:  ecma_number_t count_number;
    #####: 1246:  ecma_value_t count_value = ecma_op_to_integer (repeat, &count_number);
        -: 1247:
        -: 1248:  /* 5 */
    #####: 1249:  if (ECMA_IS_VALUE_ERROR (count_value))
        -: 1250:  {
    #####: 1251:    return count_value;
        -: 1252:  }
        -: 1253:
    #####: 1254:  int32_t repeat_count = ecma_number_to_int32 (count_number);
        -: 1255:
    #####: 1256:  bool isNan = ecma_number_is_nan (count_number);
        -: 1257:
        -: 1258:  /* 6, 7 */
    #####: 1259:  if (count_number < 0 || (!isNan && ecma_number_is_infinity (count_number)))
        -: 1260:  {
    #####: 1261:    return ecma_raise_range_error (ECMA_ERR_INVALID_COUNT_VALUE);
        -: 1262:  }
        -: 1263:
    #####: 1264:  lit_utf8_size_t size = ecma_string_get_size (original_string_p);
        -: 1265:
    #####: 1266:  if (repeat_count == 0 || size == 0 || isNan)
        -: 1267:  {
    #####: 1268:    return ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1269:  }
        -: 1270:
    #####: 1271:  if ((uint32_t) repeat_count >= (ECMA_STRING_SIZE_LIMIT / size))
        -: 1272:  {
    #####: 1273:    return ecma_raise_range_error (ECMA_ERR_INVALID_STRING_);
        -: 1274:  }
        -: 1275:
    #####: 1276:  lit_utf8_size_t total_size = size * (lit_utf8_size_t) repeat_count;
        -: 1277:
    #####: 1278:  JMEM_DEFINE_LOCAL_ARRAY (str_buffer, total_size, lit_utf8_byte_t);
        -: 1279:
    #####: 1280:  ecma_string_to_cesu8_bytes (original_string_p, str_buffer, size);
    #####: 1281:  lit_utf8_byte_t *buffer_ptr = str_buffer + size;
        -: 1282:
    #####: 1283:  for (int32_t n = 1; n < repeat_count; n++)
        -: 1284:  {
    #####: 1285:    memcpy (buffer_ptr, str_buffer, size);
    #####: 1286:    buffer_ptr += size;
        -: 1287:  }
        -: 1288:
    #####: 1289:  ret_string_p = ecma_new_ecma_string_from_utf8 (str_buffer, (lit_utf8_size_t) (buffer_ptr - str_buffer));
    #####: 1290:  JMEM_FINALIZE_LOCAL_ARRAY (str_buffer);
        -: 1291:
    #####: 1292:  return ecma_make_string_value (ret_string_p);
        -: 1293:} /* ecma_builtin_string_prototype_object_repeat */
        -: 1294:
        -: 1295:/**
        -: 1296: * The String.prototype object's 'codePointAt' routine
        -: 1297: *
        -: 1298: * See also:
        -: 1299: *          ECMA-262 v6, 21.1.3.3
        -: 1300: *
        -: 1301: * @return lit_code_point_t
        -: 1302: */
        -: 1303:static ecma_value_t
    #####: 1304:ecma_builtin_string_prototype_object_code_point_at (ecma_string_t *this_string_p, /**< this argument */
        -: 1305:                                                    ecma_value_t pos) /**< given position */
        -: 1306:{
    #####: 1307:  ecma_number_t pos_num;
    #####: 1308:  ecma_value_t error = ecma_op_to_integer (pos, &pos_num);
        -: 1309:
    #####: 1310:  if (ECMA_IS_VALUE_ERROR (error))
        -: 1311:  {
    #####: 1312:    return error;
        -: 1313:  }
        -: 1314:
    #####: 1315:  lit_utf8_size_t length = ecma_string_get_length (this_string_p);
        -: 1316:
    #####: 1317:  if (pos_num < 0 || pos_num >= length)
        -: 1318:  {
    #####: 1319:    return ECMA_VALUE_UNDEFINED;
        -: 1320:  }
        -: 1321:
    #####: 1322:  uint32_t index = (uint32_t) pos_num;
        -: 1323:
    #####: 1324:  ecma_char_t first = ecma_string_get_char_at_pos (this_string_p, index);
        -: 1325:
    #####: 1326:  if (first < LIT_UTF16_HIGH_SURROGATE_MIN || first > LIT_UTF16_HIGH_SURROGATE_MAX || index + 1 == length)
        -: 1327:  {
    #####: 1328:    return ecma_make_uint32_value (first);
        -: 1329:  }
        -: 1330:
    #####: 1331:  ecma_char_t second = ecma_string_get_char_at_pos (this_string_p, index + 1);
        -: 1332:
    #####: 1333:  if (second < LIT_UTF16_LOW_SURROGATE_MARKER || second > LIT_UTF16_LOW_SURROGATE_MAX)
        -: 1334:  {
    #####: 1335:    return ecma_make_uint32_value (first);
        -: 1336:  }
        -: 1337:
    #####: 1338:  return ecma_make_uint32_value (lit_convert_surrogate_pair_to_code_point (first, second));
        -: 1339:} /* ecma_builtin_string_prototype_object_code_point_at */
        -: 1340:
        -: 1341:#endif /* JERRY_ESNEXT */
        -: 1342:
        -: 1343:#if JERRY_BUILTIN_ANNEXB
        -: 1344:
        -: 1345:/**
        -: 1346: * The String.prototype object's 'substr' routine
        -: 1347: *
        -: 1348: * See also:
        -: 1349: *          ECMA-262 v5, B.2.3
        -: 1350: *
        -: 1351: * @return ecma value
        -: 1352: *         Returned value must be freed with ecma_free_value.
        -: 1353: */
        -: 1354:static ecma_value_t
    #####: 1355:ecma_builtin_string_prototype_object_substr (ecma_string_t *this_string_p, /**< this argument */
        -: 1356:                                             ecma_value_t start, /**< routine's first argument */
        -: 1357:                                             ecma_value_t length) /**< routine's second argument */
        -: 1358:{
        -: 1359:  /* 2. */
    #####: 1360:  ecma_number_t start_num;
        -: 1361:
    #####: 1362:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (start, &start_num)))
        -: 1363:  {
    #####: 1364:    return ECMA_VALUE_ERROR;
        -: 1365:  }
        -: 1366:
        -: 1367:  /* 3. */
    #####: 1368:  ecma_number_t length_num = ecma_number_make_infinity (false);
        -: 1369:
    #####: 1370:  if (!ecma_is_value_undefined (length))
        -: 1371:  {
    #####: 1372:    ecma_number_t len;
        -: 1373:
    #####: 1374:    if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (length, &len)))
        -: 1375:    {
    #####: 1376:      return ECMA_VALUE_ERROR;
        -: 1377:    }
        -: 1378:
    #####: 1379:    length_num = ecma_number_is_nan (len) ? 0 : len;
        -: 1380:  }
        -: 1381:
        -: 1382:  /* 4. */
    #####: 1383:  lit_utf8_size_t this_len = ecma_string_get_length (this_string_p);
        -: 1384:
        -: 1385:  /* 5. */
    #####: 1386:  uint32_t from = (uint32_t) ((start_num < 0) ? JERRY_MAX (this_len + start_num, 0) : start_num);
        -: 1387:
    #####: 1388:  if (from > this_len)
        -: 1389:  {
    #####: 1390:    from = this_len;
        -: 1391:  }
        -: 1392:
        -: 1393:  /* 6. */
    #####: 1394:  ecma_number_t to_num = JERRY_MIN (JERRY_MAX (length_num, 0), this_len - from);
        -: 1395:
        -: 1396:  /* 7. */
    #####: 1397:  uint32_t to = from + (uint32_t) to_num;
        -: 1398:
        -: 1399:  /* 8. */
    #####: 1400:  ecma_string_t *new_str_p = ecma_string_substr (this_string_p, from, to);
    #####: 1401:  return ecma_make_string_value (new_str_p);
        -: 1402:} /* ecma_builtin_string_prototype_object_substr */
        -: 1403:
        -: 1404:#endif /* JERRY_BUILTIN_ANNEXB */
        -: 1405:
        -: 1406:#if JERRY_ESNEXT
        -: 1407:
        -: 1408:/**
        -: 1409: * The String.prototype object's @@iterator routine
        -: 1410: *
        -: 1411: * See also:
        -: 1412: *          ECMA-262 v6, 21.1.3.27
        -: 1413: *
        -: 1414: * @return ecma value
        -: 1415: *         Returned value must be freed with ecma_free_value.
        -: 1416: */
        -: 1417:static ecma_value_t
    #####: 1418:ecma_builtin_string_prototype_object_iterator (ecma_value_t to_string) /**< this argument */
        -: 1419:{
    #####: 1420:  return ecma_op_create_iterator_object (ecma_copy_value (to_string),
        -: 1421:                                         ecma_builtin_get (ECMA_BUILTIN_ID_STRING_ITERATOR_PROTOTYPE),
        -: 1422:                                         ECMA_OBJECT_CLASS_STRING_ITERATOR,
        -: 1423:                                         ECMA_ITERATOR_VALUES);
        -: 1424:} /* ecma_builtin_string_prototype_object_iterator */
        -: 1425:
        -: 1426:#endif /* JERRY_ESNEXT */
        -: 1427:
        -: 1428:/**
        -: 1429: * Dispatcher of the built-in's routines
        -: 1430: *
        -: 1431: * @return ecma value
        -: 1432: *         Returned value must be freed with ecma_free_value.
        -: 1433: */
        -: 1434:ecma_value_t
    #####: 1435:ecma_builtin_string_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine
        -: 1436:                                                                             *   identifier */
        -: 1437:                                                ecma_value_t this_arg, /**< 'this' argument value */
        -: 1438:                                                const ecma_value_t arguments_list_p[], /**< list of arguments
        -: 1439:                                                                                        *   passed to routine */
        -: 1440:                                                uint32_t arguments_number) /**< length of arguments' list */
        -: 1441:{
    #####: 1442:  if (builtin_routine_id <= ECMA_STRING_PROTOTYPE_VALUE_OF)
        -: 1443:  {
    #####: 1444:    return ecma_builtin_string_prototype_object_to_string (this_arg);
        -: 1445:  }
        -: 1446:
    #####: 1447:  if (!ecma_op_require_object_coercible (this_arg))
        -: 1448:  {
    #####: 1449:    return ECMA_VALUE_ERROR;
        -: 1450:  }
        -: 1451:
    #####: 1452:  ecma_value_t arg1 = arguments_list_p[0];
    #####: 1453:  ecma_value_t arg2 = arguments_list_p[1];
        -: 1454:
        -: 1455:#if JERRY_BUILTIN_REGEXP
    #####: 1456:  if (builtin_routine_id == ECMA_STRING_PROTOTYPE_MATCH)
        -: 1457:  {
    #####: 1458:    return ecma_builtin_string_prototype_object_match (this_arg, arg1);
        -: 1459:  }
        -: 1460:
        -: 1461:#if JERRY_ESNEXT
    #####: 1462:  if (builtin_routine_id == ECMA_STRING_PROTOTYPE_MATCH_ALL)
        -: 1463:  {
    #####: 1464:    return ecma_builtin_string_prototype_object_match_all (this_arg, arg1);
        -: 1465:  }
        -: 1466:#endif /* JERRY_ESNEXT */
        -: 1467:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1468:
    #####: 1469:  if (builtin_routine_id <= ECMA_STRING_PROTOTYPE_CHAR_CODE_AT)
        -: 1470:  {
    #####: 1471:    return ecma_builtin_string_prototype_char_at_helper (this_arg,
        -: 1472:                                                         arg1,
        -: 1473:                                                         builtin_routine_id == ECMA_STRING_PROTOTYPE_CHAR_CODE_AT);
        -: 1474:  }
        -: 1475:
        -: 1476:#if JERRY_BUILTIN_REGEXP
    #####: 1477:  if (builtin_routine_id == ECMA_STRING_PROTOTYPE_REPLACE)
        -: 1478:  {
    #####: 1479:    return ecma_builtin_string_prototype_object_replace_helper (this_arg, arg1, arg2, false);
        -: 1480:  }
        -: 1481:#if JERRY_ESNEXT
    #####: 1482:  else if (builtin_routine_id == ECMA_STRING_PROTOTYPE_REPLACE_ALL)
        -: 1483:  {
    #####: 1484:    return ecma_builtin_string_prototype_object_replace_helper (this_arg, arg1, arg2, true);
        -: 1485:  }
        -: 1486:#endif /* JERRY_ESNEXT  */
        -: 1487:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1488:
    #####: 1489:  ecma_string_t *string_p = ecma_op_to_string (this_arg);
        -: 1490:
    #####: 1491:  if (JERRY_UNLIKELY (string_p == NULL))
        -: 1492:  {
    #####: 1493:    return ECMA_VALUE_ERROR;
        -: 1494:  }
        -: 1495:
    #####: 1496:  ecma_value_t to_string_val = ecma_make_string_value (string_p);
    #####: 1497:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -: 1498:
    #####: 1499:  switch (builtin_routine_id)
        -: 1500:  {
    #####: 1501:    case ECMA_STRING_PROTOTYPE_CONCAT:
        -: 1502:    {
    #####: 1503:      ret_value = ecma_builtin_string_prototype_object_concat (string_p, arguments_list_p, arguments_number);
    #####: 1504:      break;
        -: 1505:    }
    #####: 1506:    case ECMA_STRING_PROTOTYPE_SLICE:
        -: 1507:    {
    #####: 1508:      ret_value = ecma_builtin_string_prototype_object_slice (string_p, arg1, arg2);
    #####: 1509:      break;
        -: 1510:    }
    #####: 1511:    case ECMA_STRING_PROTOTYPE_AT:
        -: 1512:    {
    #####: 1513:      ret_value = ecma_builtin_string_prototype_object_at (string_p, arg1);
    #####: 1514:      break;
        -: 1515:    }
    #####: 1516:    case ECMA_STRING_PROTOTYPE_LAST_INDEX_OF:
        -: 1517:    case ECMA_STRING_PROTOTYPE_INDEX_OF:
        -: 1518:#if JERRY_ESNEXT
        -: 1519:    case ECMA_STRING_PROTOTYPE_STARTS_WITH:
        -: 1520:    case ECMA_STRING_PROTOTYPE_INCLUDES:
        -: 1521:    case ECMA_STRING_PROTOTYPE_ENDS_WITH:
        -: 1522:#endif /* JERRY_ESNEXT */
        -: 1523:    {
        -: 1524:      ecma_string_index_of_mode_t mode;
    #####: 1525:      mode = (ecma_string_index_of_mode_t) (builtin_routine_id - ECMA_STRING_PROTOTYPE_LAST_INDEX_OF);
    #####: 1526:      ret_value = ecma_builtin_helper_string_prototype_object_index_of (string_p, arg1, arg2, mode);
    #####: 1527:      break;
        -: 1528:    }
    #####: 1529:    case ECMA_STRING_PROTOTYPE_LOCALE_COMPARE:
        -: 1530:    {
    #####: 1531:      ret_value = ecma_builtin_string_prototype_object_locale_compare (string_p, arg1);
    #####: 1532:      break;
        -: 1533:    }
        -: 1534:#if JERRY_BUILTIN_REGEXP
    #####: 1535:    case ECMA_STRING_PROTOTYPE_SEARCH:
        -: 1536:    {
    #####: 1537:      ret_value = ecma_builtin_string_prototype_object_search (to_string_val, arg1);
    #####: 1538:      break;
        -: 1539:    }
        -: 1540:#endif /* JERRY_BUILTIN_REGEXP */
    #####: 1541:    case ECMA_STRING_PROTOTYPE_SPLIT:
        -: 1542:    {
    #####: 1543:      ret_value = ecma_builtin_string_prototype_object_split (to_string_val, arg1, arg2);
    #####: 1544:      break;
        -: 1545:    }
    #####: 1546:    case ECMA_STRING_PROTOTYPE_SUBSTRING:
        -: 1547:    {
    #####: 1548:      ret_value = ecma_builtin_string_prototype_object_substring (string_p, arg1, arg2);
    #####: 1549:      break;
        -: 1550:    }
    #####: 1551:    case ECMA_STRING_PROTOTYPE_TO_LOWER_CASE:
        -: 1552:    case ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE:
        -: 1553:    case ECMA_STRING_PROTOTYPE_TO_UPPER_CASE:
        -: 1554:    case ECMA_STRING_PROTOTYPE_TO_LOCAL_UPPER_CASE:
        -: 1555:    {
    #####: 1556:      bool is_lower_case = builtin_routine_id <= ECMA_STRING_PROTOTYPE_TO_LOCAL_LOWER_CASE;
    #####: 1557:      ret_value = ecma_builtin_string_prototype_object_conversion_helper (string_p, is_lower_case);
    #####: 1558:      break;
        -: 1559:    }
    #####: 1560:    case ECMA_STRING_PROTOTYPE_TRIM:
        -: 1561:    {
    #####: 1562:      ret_value = ecma_builtin_string_prototype_object_trim (string_p);
    #####: 1563:      break;
        -: 1564:    }
        -: 1565:#if JERRY_BUILTIN_ANNEXB
    #####: 1566:    case ECMA_STRING_PROTOTYPE_SUBSTR:
        -: 1567:    {
    #####: 1568:      ret_value = ecma_builtin_string_prototype_object_substr (string_p, arg1, arg2);
    #####: 1569:      break;
        -: 1570:    }
        -: 1571:#endif /* JERRY_BUILTIN_ANNEXB */
        -: 1572:#if JERRY_ESNEXT
    #####: 1573:    case ECMA_STRING_PROTOTYPE_REPEAT:
        -: 1574:    {
    #####: 1575:      ret_value = ecma_builtin_string_prototype_object_repeat (string_p, arg1);
    #####: 1576:      break;
        -: 1577:    }
    #####: 1578:    case ECMA_STRING_PROTOTYPE_CODE_POINT_AT:
        -: 1579:    {
    #####: 1580:      ret_value = ecma_builtin_string_prototype_object_code_point_at (string_p, arg1);
    #####: 1581:      break;
        -: 1582:    }
    #####: 1583:    case ECMA_STRING_PROTOTYPE_ITERATOR:
        -: 1584:    {
    #####: 1585:      ret_value = ecma_builtin_string_prototype_object_iterator (to_string_val);
    #####: 1586:      break;
        -: 1587:    }
    #####: 1588:    case ECMA_STRING_PROTOTYPE_PAD_END:
        -: 1589:    case ECMA_STRING_PROTOTYPE_PAD_START:
        -: 1590:    {
    #####: 1591:      ret_value = ecma_string_pad (to_string_val, arg1, arg2, builtin_routine_id == ECMA_STRING_PROTOTYPE_PAD_START);
    #####: 1592:      break;
        -: 1593:    }
        -: 1594:#endif /* JERRY_ESNEXT */
    #####: 1595:    default:
        -: 1596:    {
    #####: 1597:      JERRY_UNREACHABLE ();
        -: 1598:    }
        -: 1599:  }
        -: 1600:
    #####: 1601:  ecma_deref_ecma_string (string_p);
        -: 1602:
    #####: 1603:  return ret_value;
        -: 1604:} /* ecma_builtin_string_prototype_dispatch_routine */
        -: 1605:
        -: 1606:/**
        -: 1607: * @}
        -: 1608: * @}
        -: 1609: * @}
        -: 1610: */
        -: 1611:
        -: 1612:#endif /* JERRY_BUILTIN_STRING */
