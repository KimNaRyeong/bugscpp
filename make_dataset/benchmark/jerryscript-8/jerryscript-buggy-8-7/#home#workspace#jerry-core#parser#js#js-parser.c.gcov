        -:    0:Source:/home/workspace/jerry-core/parser/js/js-parser.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-exceptions.h"
        -:   17:#include "ecma-extended-info.h"
        -:   18:#include "ecma-helpers.h"
        -:   19:#include "ecma-literal-storage.h"
        -:   20:#include "ecma-module.h"
        -:   21:
        -:   22:#include "debugger.h"
        -:   23:#include "jcontext.h"
        -:   24:#include "js-parser-internal.h"
        -:   25:#include "lit-char-helpers.h"
        -:   26:
        -:   27:#if JERRY_PARSER
        -:   28:
        -:   29:JERRY_STATIC_ASSERT ((int) ECMA_PARSE_STRICT_MODE == (int) PARSER_IS_STRICT,
        -:   30:                     ecma_parse_strict_mode_must_be_equal_to_parser_is_strict);
        -:   31:
        -:   32:#if JERRY_ESNEXT
        -:   33:JERRY_STATIC_ASSERT (PARSER_SAVE_STATUS_FLAGS (PARSER_ALLOW_SUPER) == 0x1, incorrect_saving_of_ecma_parse_allow_super);
        -:   34:JERRY_STATIC_ASSERT (PARSER_RESTORE_STATUS_FLAGS (ECMA_PARSE_ALLOW_SUPER) == PARSER_ALLOW_SUPER,
        -:   35:                     incorrect_restoring_of_ecma_parse_allow_super);
        -:   36:
        -:   37:JERRY_STATIC_ASSERT (PARSER_RESTORE_STATUS_FLAGS (ECMA_PARSE_FUNCTION_CONTEXT) == 0,
        -:   38:                     ecma_parse_function_context_must_not_be_transformed);
        -:   39:#endif /* JERRY_ESNEXT */
        -:   40:
        -:   41:/** \addtogroup parser Parser
        -:   42: * @{
        -:   43: *
        -:   44: * \addtogroup jsparser JavaScript
        -:   45: * @{
        -:   46: *
        -:   47: * \addtogroup jsparser_parser Parser
        -:   48: * @{
        -:   49: */
        -:   50:
        -:   51:/**
        -:   52: * Compute real literal indicies.
        -:   53: *
        -:   54: * @return length of the prefix opcodes
        -:   55: */
        -:   56:static void
        5:   57:parser_compute_indicies (parser_context_t *context_p, /**< context */
        -:   58:                         uint16_t *ident_end, /**< end of the identifier group */
        -:   59:                         uint16_t *const_literal_end) /**< end of the const literal group */
        -:   60:{
        5:   61:  parser_list_iterator_t literal_iterator;
        -:   62:  lexer_literal_t *literal_p;
        -:   63:
        5:   64:  uint16_t ident_count = 0;
        5:   65:  uint16_t const_literal_count = 0;
        -:   66:
        -:   67:  uint16_t ident_index;
        -:   68:  uint16_t const_literal_index;
        -:   69:  uint16_t literal_index;
        -:   70:
        -:   71:  /* First phase: count the number of items in each group. */
        5:   72:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
       37:   73:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:   74:  {
       27:   75:    switch (literal_p->type)
        -:   76:    {
       11:   77:      case LEXER_IDENT_LITERAL:
        -:   78:      {
       11:   79:        if (literal_p->status_flags & LEXER_FLAG_USED)
        -:   80:        {
        9:   81:          ident_count++;
        9:   82:          break;
        -:   83:        }
        2:   84:        else if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:   85:        {
    #####:   86:          jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);
        -:   87:          /* This literal should not be freed even if an error is encountered later. */
    #####:   88:          literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;
        -:   89:        }
        2:   90:        continue;
        -:   91:      }
       12:   92:      case LEXER_STRING_LITERAL:
        -:   93:      {
       12:   94:        const_literal_count++;
       12:   95:        break;
        -:   96:      }
    #####:   97:      case LEXER_NUMBER_LITERAL:
        -:   98:      {
    #####:   99:        const_literal_count++;
    #####:  100:        continue;
        -:  101:      }
        4:  102:      case LEXER_FUNCTION_LITERAL:
        -:  103:      case LEXER_REGEXP_LITERAL:
        -:  104:      {
        4:  105:        continue;
        -:  106:      }
    #####:  107:      default:
        -:  108:      {
    #####:  109:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);
    #####:  110:        continue;
        -:  111:      }
        -:  112:    }
        -:  113:
       21:  114:    const uint8_t *char_p = literal_p->u.char_p;
       21:  115:    uint32_t status_flags = context_p->status_flags;
        -:  116:
       21:  117:    if ((literal_p->status_flags & LEXER_FLAG_SOURCE_PTR) && literal_p->prop.length < 0xfff)
        -:  118:    {
       21:  119:      size_t bytes_to_end = (size_t) (context_p->source_end_p - char_p);
        -:  120:
       21:  121:      if (bytes_to_end < 0xfffff)
        -:  122:      {
       21:  123:        literal_p->u.source_data = ((uint32_t) bytes_to_end) | (((uint32_t) literal_p->prop.length) << 20);
       21:  124:        literal_p->status_flags |= LEXER_FLAG_LATE_INIT;
       21:  125:        status_flags |= PARSER_HAS_LATE_LIT_INIT;
       21:  126:        context_p->status_flags = status_flags;
       21:  127:        char_p = NULL;
        -:  128:      }
        -:  129:    }
        -:  130:
       21:  131:    if (char_p != NULL)
        -:  132:    {
    #####:  133:      literal_p->u.value = ecma_find_or_create_literal_string (char_p,
    #####:  134:                                                               literal_p->prop.length,
    #####:  135:                                                               (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);
        -:  136:
    #####:  137:      if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:  138:      {
    #####:  139:        jmem_heap_free_block ((void *) char_p, literal_p->prop.length);
        -:  140:        /* This literal should not be freed even if an error is encountered later. */
    #####:  141:        literal_p->status_flags |= LEXER_FLAG_SOURCE_PTR;
        -:  142:      }
        -:  143:    }
        -:  144:  }
        -:  145:
        5:  146:  ident_index = context_p->register_count;
        5:  147:  const_literal_index = (uint16_t) (ident_index + ident_count);
        5:  148:  literal_index = (uint16_t) (const_literal_index + const_literal_count);
        -:  149:
        -:  150:  /* Second phase: Assign an index to each literal. */
        5:  151:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        -:  152:
       37:  153:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:  154:  {
       27:  155:    switch (literal_p->type)
        -:  156:    {
       11:  157:      case LEXER_IDENT_LITERAL:
        -:  158:      {
       11:  159:        if (literal_p->status_flags & LEXER_FLAG_USED)
        -:  160:        {
        9:  161:          literal_p->prop.index = ident_index;
        9:  162:          ident_index++;
        -:  163:        }
       11:  164:        break;
        -:  165:      }
       12:  166:      case LEXER_STRING_LITERAL:
        -:  167:      case LEXER_NUMBER_LITERAL:
        -:  168:      {
       12:  169:        JERRY_ASSERT ((literal_p->status_flags & ~(LEXER_FLAG_SOURCE_PTR | LEXER_FLAG_LATE_INIT)) == 0);
       12:  170:        literal_p->prop.index = const_literal_index;
       12:  171:        const_literal_index++;
       12:  172:        break;
        -:  173:      }
        4:  174:      case LEXER_FUNCTION_LITERAL:
        -:  175:      case LEXER_REGEXP_LITERAL:
        -:  176:      {
        4:  177:        JERRY_ASSERT (literal_p->status_flags == 0);
        -:  178:
        4:  179:        literal_p->prop.index = literal_index;
        4:  180:        literal_index++;
        4:  181:        break;
        -:  182:      }
    #####:  183:      default:
        -:  184:      {
    #####:  185:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL
        -:  186:                      && literal_p->status_flags == LEXER_FLAG_FUNCTION_ARGUMENT);
    #####:  187:        break;
        -:  188:      }
        -:  189:    }
        -:  190:  }
        -:  191:
        5:  192:  JERRY_ASSERT (ident_index == context_p->register_count + ident_count);
        5:  193:  JERRY_ASSERT (const_literal_index == ident_index + const_literal_count);
        5:  194:  JERRY_ASSERT (literal_index <= context_p->register_count + context_p->literal_count);
        -:  195:
        5:  196:  context_p->literal_count = literal_index;
        -:  197:
        5:  198:  *ident_end = ident_index;
        5:  199:  *const_literal_end = const_literal_index;
        5:  200:} /* parser_compute_indicies */
        -:  201:
        -:  202:/**
        -:  203: * Initialize literal pool.
        -:  204: */
        -:  205:static void
        5:  206:parser_init_literal_pool (parser_context_t *context_p, /**< context */
        -:  207:                          ecma_value_t *literal_pool_p) /**< start of literal pool */
        -:  208:{
        5:  209:  parser_list_iterator_t literal_iterator;
        -:  210:  lexer_literal_t *literal_p;
        -:  211:
        5:  212:  parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
        -:  213:
       37:  214:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -:  215:  {
       27:  216:    switch (literal_p->type)
        -:  217:    {
       11:  218:      case LEXER_IDENT_LITERAL:
        -:  219:      {
       11:  220:        if (!(literal_p->status_flags & LEXER_FLAG_USED))
        -:  221:        {
        2:  222:          break;
        -:  223:        }
        -:  224:        /* FALLTHRU */
        -:  225:      }
        -:  226:      case LEXER_STRING_LITERAL:
        -:  227:      {
       21:  228:        ecma_value_t lit_value = literal_p->u.value;
        -:  229:
       21:  230:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
       21:  231:        literal_pool_p[literal_p->prop.index] = lit_value;
       21:  232:        break;
        -:  233:      }
    #####:  234:      case LEXER_NUMBER_LITERAL:
        -:  235:      {
    #####:  236:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        -:  237:
    #####:  238:        literal_pool_p[literal_p->prop.index] = literal_p->u.value;
    #####:  239:        break;
        -:  240:      }
        4:  241:      case LEXER_FUNCTION_LITERAL:
        -:  242:      case LEXER_REGEXP_LITERAL:
        -:  243:      {
        4:  244:        JERRY_ASSERT (literal_p->prop.index >= context_p->register_count);
        -:  245:
        4:  246:        ECMA_SET_INTERNAL_VALUE_POINTER (literal_pool_p[literal_p->prop.index], literal_p->u.bytecode_p);
        4:  247:        break;
        -:  248:      }
    #####:  249:      default:
        -:  250:      {
    #####:  251:        JERRY_ASSERT (literal_p->type == LEXER_UNUSED_LITERAL);
    #####:  252:        break;
        -:  253:      }
        -:  254:    }
    #####:  255:  }
        5:  256:} /* parser_init_literal_pool */
        -:  257:
        -:  258:/*
        -:  259: * During byte code post processing certain bytes are not
        -:  260: * copied into the final byte code buffer. For example, if
        -:  261: * one byte is enough for encoding a literal index, the
        -:  262: * second byte is not copied. However, when a byte is skipped,
        -:  263: * the offsets of those branches which crosses (jumps over)
        -:  264: * that byte code should also be decreased by one. Instead
        -:  265: * of finding these jumps every time when a byte is skipped,
        -:  266: * all branch offset updates are computed in one step.
        -:  267: *
        -:  268: * Branch offset mapping example:
        -:  269: *
        -:  270: * Let's assume that each parser_mem_page of the byte_code
        -:  271: * buffer is 8 bytes long and only 4 bytes are kept for a
        -:  272: * given page:
        -:  273: *
        -:  274: * +---+---+---+---+---+---+---+---+
        -:  275: * | X | 1 | 2 | 3 | X | 4 | X | X |
        -:  276: * +---+---+---+---+---+---+---+---+
        -:  277: *
        -:  278: * X marks those bytes which are removed. The resulting
        -:  279: * offset mapping is the following:
        -:  280: *
        -:  281: * +---+---+---+---+---+---+---+---+
        -:  282: * | 0 | 1 | 2 | 3 | 3 | 4 | 4 | 4 |
        -:  283: * +---+---+---+---+---+---+---+---+
        -:  284: *
        -:  285: * Each X is simply replaced by the index of the previous
        -:  286: * index starting from zero. This shows the number of
        -:  287: * copied bytes before a given byte including the byte
        -:  288: * itself. The last byte always shows the number of bytes
        -:  289: * copied from this page.
        -:  290: *
        -:  291: * This mapping allows recomputing all branch targets,
        -:  292: * since mapping[to] - mapping[from] is the new argument
        -:  293: * for forward branches. As for backward branches, the
        -:  294: * equation is reversed to mapping[from] - mapping[to].
        -:  295: *
        -:  296: * The mapping is relative to one page, so distance
        -:  297: * computation affecting multiple pages requires a loop.
        -:  298: * We should also note that only argument bytes can
        -:  299: * be skipped, so removed bytes cannot be targeted by
        -:  300: * branches. Valid branches always target instruction
        -:  301: * starts only.
        -:  302: */
        -:  303:
        -:  304:/**
        -:  305: * Recompute the argument of a forward branch.
        -:  306: *
        -:  307: * @return the new distance
        -:  308: */
        -:  309:static size_t
    #####:  310:parser_update_forward_branch (parser_mem_page_t *page_p, /**< current page */
        -:  311:                              size_t full_distance, /**< full distance */
        -:  312:                              uint8_t bytes_copied_before_jump) /**< bytes copied before jump */
        -:  313:{
    #####:  314:  size_t new_distance = 0;
        -:  315:
    #####:  316:  while (full_distance > PARSER_CBC_STREAM_PAGE_SIZE)
        -:  317:  {
    #####:  318:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  319:    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  320:    page_p = page_p->next_p;
        -:  321:  }
        -:  322:
    #####:  323:  new_distance += page_p->bytes[full_distance - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  324:  return new_distance - bytes_copied_before_jump;
        -:  325:} /* parser_update_forward_branch */
        -:  326:
        -:  327:/**
        -:  328: * Recompute the argument of a backward branch.
        -:  329: *
        -:  330: * @return the new distance
        -:  331: */
        -:  332:static size_t
    #####:  333:parser_update_backward_branch (parser_mem_page_t *page_p, /**< current page */
        -:  334:                               size_t full_distance, /**< full distance */
        -:  335:                               uint8_t bytes_copied_before_jump) /**< bytes copied before jump */
        -:  336:{
    #####:  337:  size_t new_distance = bytes_copied_before_jump;
        -:  338:
    #####:  339:  while (full_distance >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  340:  {
    #####:  341:    JERRY_ASSERT (page_p != NULL);
    #####:  342:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  343:    full_distance -= PARSER_CBC_STREAM_PAGE_SIZE;
    #####:  344:    page_p = page_p->next_p;
        -:  345:  }
        -:  346:
    #####:  347:  if (full_distance > 0)
        -:  348:  {
    #####:  349:    size_t offset = PARSER_CBC_STREAM_PAGE_SIZE - full_distance;
        -:  350:
    #####:  351:    JERRY_ASSERT (page_p != NULL);
        -:  352:
    #####:  353:    new_distance += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
    #####:  354:    new_distance -= page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        -:  355:  }
        -:  356:
    #####:  357:  return new_distance;
        -:  358:} /* parser_update_backward_branch */
        -:  359:
        -:  360:/**
        -:  361: * Update targets of all branches in one step.
        -:  362: */
        -:  363:static void
        5:  364:parse_update_branches (parser_context_t *context_p, /**< context */
        -:  365:                       uint8_t *byte_code_p) /**< byte code */
        -:  366:{
        5:  367:  parser_mem_page_t *page_p = context_p->byte_code.first_p;
        5:  368:  parser_mem_page_t *prev_page_p = NULL;
        5:  369:  parser_mem_page_t *last_page_p = context_p->byte_code.last_p;
        5:  370:  size_t last_position = context_p->byte_code.last_position;
        5:  371:  size_t offset = 0;
        5:  372:  size_t bytes_copied = 0;
        -:  373:
        5:  374:  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  375:  {
    #####:  376:    last_page_p = NULL;
    #####:  377:    last_position = 0;
        -:  378:  }
        -:  379:
      149:  380:  while (page_p != last_page_p || offset < last_position)
        -:  381:  {
        -:  382:    /* Branch instructions are marked to improve search speed. */
      139:  383:    if (page_p->bytes[offset] & CBC_HIGHEST_BIT_MASK)
        -:  384:    {
    #####:  385:      uint8_t *bytes_p = byte_code_p + bytes_copied;
        -:  386:      uint8_t flags;
    #####:  387:      uint8_t bytes_copied_before_jump = 0;
        -:  388:      size_t branch_argument_length;
        -:  389:      size_t target_distance;
        -:  390:      size_t length;
        -:  391:
    #####:  392:      if (offset > 0)
        -:  393:      {
    #####:  394:        bytes_copied_before_jump = page_p->bytes[offset - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        -:  395:      }
    #####:  396:      bytes_p += bytes_copied_before_jump;
        -:  397:
    #####:  398:      if (*bytes_p == CBC_EXT_OPCODE)
        -:  399:      {
    #####:  400:        bytes_p++;
    #####:  401:        flags = cbc_ext_flags[*bytes_p];
        -:  402:      }
        -:  403:      else
        -:  404:      {
    #####:  405:        flags = cbc_flags[*bytes_p];
        -:  406:      }
        -:  407:
    #####:  408:      JERRY_ASSERT (flags & CBC_HAS_BRANCH_ARG);
    #####:  409:      branch_argument_length = CBC_BRANCH_OFFSET_LENGTH (*bytes_p);
    #####:  410:      bytes_p++;
        -:  411:
        -:  412:      /* Decoding target. */
    #####:  413:      length = branch_argument_length;
    #####:  414:      target_distance = 0;
        -:  415:      do
        -:  416:      {
    #####:  417:        target_distance = (target_distance << 8) | *bytes_p;
    #####:  418:        bytes_p++;
    #####:  419:      } while (--length > 0);
        -:  420:
    #####:  421:      if (CBC_BRANCH_IS_FORWARD (flags))
        -:  422:      {
        -:  423:        /* Branch target was not set. */
    #####:  424:        JERRY_ASSERT (target_distance > 0);
        -:  425:
    #####:  426:        target_distance = parser_update_forward_branch (page_p, offset + target_distance, bytes_copied_before_jump);
        -:  427:      }
        -:  428:      else
        -:  429:      {
    #####:  430:        if (target_distance < offset)
        -:  431:        {
    #####:  432:          uint8_t bytes_copied_before_target = page_p->bytes[offset - target_distance - 1];
    #####:  433:          bytes_copied_before_target = bytes_copied_before_target & CBC_LOWER_SEVEN_BIT_MASK;
        -:  434:
    #####:  435:          target_distance = (size_t) (bytes_copied_before_jump - bytes_copied_before_target);
        -:  436:        }
    #####:  437:        else if (target_distance == offset)
        -:  438:        {
    #####:  439:          target_distance = bytes_copied_before_jump;
        -:  440:        }
        -:  441:        else
        -:  442:        {
    #####:  443:          target_distance =
    #####:  444:            parser_update_backward_branch (prev_page_p, target_distance - offset, bytes_copied_before_jump);
        -:  445:        }
        -:  446:      }
        -:  447:
        -:  448:      /* Encoding target again. */
        -:  449:      do
        -:  450:      {
    #####:  451:        bytes_p--;
    #####:  452:        *bytes_p = (uint8_t) (target_distance & 0xff);
    #####:  453:        target_distance >>= 8;
    #####:  454:      } while (--branch_argument_length > 0);
        -:  455:    }
        -:  456:
      139:  457:    offset++;
      139:  458:    if (offset >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  459:    {
        1:  460:      parser_mem_page_t *next_p = page_p->next_p;
        -:  461:
        -:  462:      /* We reverse the pages before the current page. */
        1:  463:      page_p->next_p = prev_page_p;
        1:  464:      prev_page_p = page_p;
        -:  465:
        1:  466:      bytes_copied += page_p->bytes[PARSER_CBC_STREAM_PAGE_SIZE - 1] & CBC_LOWER_SEVEN_BIT_MASK;
        1:  467:      page_p = next_p;
        1:  468:      offset = 0;
        -:  469:    }
        -:  470:  }
        -:  471:
        -:  472:  /* After this point the pages of the byte code stream are
        -:  473:   * not used anymore. However, they needs to be freed during
        -:  474:   * cleanup, so the first and last pointers of the stream
        -:  475:   * descriptor are reversed as well. */
        5:  476:  if (last_page_p != NULL)
        -:  477:  {
        5:  478:    JERRY_ASSERT (last_page_p == context_p->byte_code.last_p);
        5:  479:    last_page_p->next_p = prev_page_p;
        -:  480:  }
        -:  481:  else
        -:  482:  {
    #####:  483:    last_page_p = context_p->byte_code.last_p;
        -:  484:  }
        -:  485:
        5:  486:  context_p->byte_code.last_p = context_p->byte_code.first_p;
        5:  487:  context_p->byte_code.first_p = last_page_p;
        5:  488:} /* parse_update_branches */
        -:  489:
        -:  490:#if JERRY_DEBUGGER
        -:  491:
        -:  492:/**
        -:  493: * Send current breakpoint list.
        -:  494: */
        -:  495:static void
        -:  496:parser_send_breakpoints (parser_context_t *context_p, /**< context */
        -:  497:                         jerry_debugger_header_type_t type) /**< message type */
        -:  498:{
        -:  499:  JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -:  500:  JERRY_ASSERT (context_p->breakpoint_info_count > 0);
        -:  501:
        -:  502:  jerry_debugger_send_data (type,
        -:  503:                            context_p->breakpoint_info,
        -:  504:                            context_p->breakpoint_info_count * sizeof (parser_breakpoint_info_t));
        -:  505:
        -:  506:  context_p->breakpoint_info_count = 0;
        -:  507:} /* parser_send_breakpoints */
        -:  508:
        -:  509:/**
        -:  510: * Append a breakpoint info.
        -:  511: */
        -:  512:void
        -:  513:parser_append_breakpoint_info (parser_context_t *context_p, /**< context */
        -:  514:                               jerry_debugger_header_type_t type, /**< message type */
        -:  515:                               uint32_t value) /**< line or offset of the breakpoint */
        -:  516:{
        -:  517:  JERRY_ASSERT (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED);
        -:  518:
        -:  519:  context_p->status_flags |= PARSER_DEBUGGER_BREAKPOINT_APPENDED;
        -:  520:
        -:  521:  if (context_p->breakpoint_info_count >= JERRY_DEBUGGER_SEND_MAX (parser_breakpoint_info_t))
        -:  522:  {
        -:  523:    parser_send_breakpoints (context_p, type);
        -:  524:  }
        -:  525:
        -:  526:  context_p->breakpoint_info[context_p->breakpoint_info_count].value = value;
        -:  527:  context_p->breakpoint_info_count = (uint16_t) (context_p->breakpoint_info_count + 1);
        -:  528:} /* parser_append_breakpoint_info */
        -:  529:
        -:  530:#endif /* JERRY_DEBUGGER */
        -:  531:
        -:  532:/**
        -:  533: * Forward iterator: move to the next byte code
        -:  534: *
        -:  535: * @param page_p page
        -:  536: * @param offset offset
        -:  537: */
        -:  538:#define PARSER_NEXT_BYTE(page_p, offset)           \
        -:  539:  do                                               \
        -:  540:  {                                                \
        -:  541:    if (++(offset) >= PARSER_CBC_STREAM_PAGE_SIZE) \
        -:  542:    {                                              \
        -:  543:      offset = 0;                                  \
        -:  544:      page_p = page_p->next_p;                     \
        -:  545:    }                                              \
        -:  546:  } while (0)
        -:  547:
        -:  548:/**
        -:  549: * Forward iterator: move to the next byte code. Also updates the offset of the previous byte code.
        -:  550: *
        -:  551: * @param page_p page
        -:  552: * @param offset offset
        -:  553: * @param real_offset real offset
        -:  554: */
        -:  555:#define PARSER_NEXT_BYTE_UPDATE(page_p, offset, real_offset) \
        -:  556:  do                                                         \
        -:  557:  {                                                          \
        -:  558:    page_p->bytes[offset] = real_offset;                     \
        -:  559:    if (++(offset) >= PARSER_CBC_STREAM_PAGE_SIZE)           \
        -:  560:    {                                                        \
        -:  561:      offset = 0;                                            \
        -:  562:      real_offset = 0;                                       \
        -:  563:      page_p = page_p->next_p;                               \
        -:  564:    }                                                        \
        -:  565:  } while (0)
        -:  566:
        -:  567:/**
        -:  568: * Post processing main function.
        -:  569: *
        -:  570: * @return compiled code
        -:  571: */
        -:  572:static ecma_compiled_code_t *
        5:  573:parser_post_processing (parser_context_t *context_p) /**< context */
        -:  574:{
        -:  575:  uint16_t literal_one_byte_limit;
        5:  576:  uint16_t ident_end;
        5:  577:  uint16_t const_literal_end;
        -:  578:  parser_mem_page_t *page_p;
        -:  579:  parser_mem_page_t *last_page_p;
        -:  580:  size_t last_position;
        -:  581:  size_t offset;
        -:  582:  size_t length;
        -:  583:  size_t literal_length;
        -:  584:  size_t total_size;
        -:  585:  uint8_t real_offset;
        -:  586:  uint8_t *byte_code_p;
        -:  587:  bool needs_uint16_arguments;
        5:  588:  cbc_opcode_t last_opcode = CBC_EXT_OPCODE;
        -:  589:  ecma_compiled_code_t *compiled_code_p;
        -:  590:  ecma_value_t *literal_pool_p;
        -:  591:  uint8_t *dst_p;
        -:  592:
        -:  593:#if JERRY_ESNEXT
        5:  594:  if ((context_p->status_flags & (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))
        -:  595:      == (PARSER_IS_FUNCTION | PARSER_LEXICAL_BLOCK_NEEDED))
        -:  596:  {
    #####:  597:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  598:#ifndef JERRY_NDEBUG
    #####:  599:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -:  600:#endif /* !JERRY_NDEBUG */
        -:  601:
    #####:  602:    context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;
        -:  603:
    #####:  604:    parser_emit_cbc (context_p, CBC_CONTEXT_END);
        -:  605:
    #####:  606:    parser_branch_t branch;
    #####:  607:    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####:  608:    parser_set_branch_to_current_position (context_p, &branch);
        -:  609:
    #####:  610:    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));
        -:  611:  }
        -:  612:
        5:  613:  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -:  614:  {
    #####:  615:    PARSER_MINUS_EQUAL_U16 (context_p->stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -:  616:#ifndef JERRY_NDEBUG
    #####:  617:    PARSER_MINUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_TRY_CONTEXT_STACK_ALLOCATION);
        -:  618:#endif /* !JERRY_NDEBUG */
        -:  619:
    #####:  620:    if (context_p->stack_limit < PARSER_FINALLY_CONTEXT_STACK_ALLOCATION)
        -:  621:    {
    #####:  622:      context_p->stack_limit = PARSER_FINALLY_CONTEXT_STACK_ALLOCATION;
        -:  623:    }
        -:  624:
    #####:  625:    parser_branch_t branch;
        -:  626:
    #####:  627:    parser_stack_pop (context_p, &branch, sizeof (parser_branch_t));
    #####:  628:    parser_set_branch_to_current_position (context_p, &branch);
        -:  629:
    #####:  630:    JERRY_ASSERT (!(context_p->status_flags & PARSER_NO_END_LABEL));
        -:  631:  }
        -:  632:#endif /* JERRY_ESNEXT */
        -:  633:
        -:  634:#if JERRY_LINE_INFO
        5:  635:  JERRY_ASSERT (context_p->line_info_p != NULL);
        -:  636:#endif /* JERRY_LINE_INFO */
        -:  637:
        5:  638:  JERRY_ASSERT (context_p->stack_depth == 0);
        -:  639:#ifndef JERRY_NDEBUG
        5:  640:  JERRY_ASSERT (context_p->context_stack_depth == 0);
        -:  641:#endif /* !JERRY_NDEBUG */
        -:  642:
        5:  643:  if ((size_t) context_p->stack_limit + (size_t) context_p->register_count > PARSER_MAXIMUM_STACK_LIMIT)
        -:  644:  {
    #####:  645:    parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -:  646:  }
        -:  647:
        5:  648:  if (JERRY_UNLIKELY (context_p->script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -:  649:  {
        -:  650:    /* This is probably never happens in practice. */
    #####:  651:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -:  652:  }
        -:  653:
        5:  654:  context_p->script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
        -:  655:
        5:  656:  JERRY_ASSERT (context_p->literal_count <= PARSER_MAXIMUM_NUMBER_OF_LITERALS);
        -:  657:
        -:  658:#if JERRY_DEBUGGER
        -:  659:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -:  660:      && !(context_p->status_flags & PARSER_DEBUGGER_BREAKPOINT_APPENDED))
        -:  661:  {
        -:  662:    /* Always provide at least one breakpoint. */
        -:  663:    parser_emit_cbc (context_p, CBC_BREAKPOINT_DISABLED);
        -:  664:    parser_flush_cbc (context_p);
        -:  665:
        -:  666:    parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST, context_p->token.line);
        -:  667:
        -:  668:    context_p->last_breakpoint_line = context_p->token.line;
        -:  669:  }
        -:  670:
        -:  671:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -:  672:  {
        -:  673:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);
        -:  674:    JERRY_ASSERT (context_p->breakpoint_info_count == 0);
        -:  675:  }
        -:  676:#endif /* JERRY_DEBUGGER */
        -:  677:
        5:  678:  parser_compute_indicies (context_p, &ident_end, &const_literal_end);
        -:  679:
        5:  680:  if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)
        -:  681:  {
        5:  682:    literal_one_byte_limit = CBC_MAXIMUM_BYTE_VALUE - 1;
        -:  683:  }
        -:  684:  else
        -:  685:  {
    #####:  686:    literal_one_byte_limit = CBC_LOWER_SEVEN_BIT_MASK;
        -:  687:  }
        -:  688:
        5:  689:  last_page_p = context_p->byte_code.last_p;
        5:  690:  last_position = context_p->byte_code.last_position;
        -:  691:
        5:  692:  if (last_position >= PARSER_CBC_STREAM_PAGE_SIZE)
        -:  693:  {
    #####:  694:    last_page_p = NULL;
    #####:  695:    last_position = 0;
        -:  696:  }
        -:  697:
        5:  698:  page_p = context_p->byte_code.first_p;
        5:  699:  offset = 0;
        5:  700:  length = 0;
        -:  701:
       55:  702:  while (page_p != last_page_p || offset < last_position)
        -:  703:  {
        -:  704:    uint8_t *opcode_p;
        -:  705:    uint8_t flags;
        -:  706:    size_t branch_offset_length;
        -:  707:
       45:  708:    opcode_p = page_p->bytes + offset;
       45:  709:    last_opcode = (cbc_opcode_t) (*opcode_p);
       45:  710:    PARSER_NEXT_BYTE (page_p, offset);
       45:  711:    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (last_opcode);
       45:  712:    flags = cbc_flags[last_opcode];
       45:  713:    length++;
        -:  714:
       45:  715:    switch (last_opcode)
        -:  716:    {
        7:  717:      case CBC_EXT_OPCODE:
        -:  718:      {
        -:  719:        cbc_ext_opcode_t ext_opcode;
        -:  720:
        7:  721:        ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];
        7:  722:        branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);
        7:  723:        flags = cbc_ext_flags[ext_opcode];
        7:  724:        PARSER_NEXT_BYTE (page_p, offset);
        7:  725:        length++;
        7:  726:        break;
        -:  727:      }
    #####:  728:      case CBC_POST_DECR:
        -:  729:      {
    #####:  730:        *opcode_p = CBC_PRE_DECR;
    #####:  731:        break;
        -:  732:      }
    #####:  733:      case CBC_POST_INCR:
        -:  734:      {
    #####:  735:        *opcode_p = CBC_PRE_INCR;
    #####:  736:        break;
        -:  737:      }
    #####:  738:      case CBC_POST_DECR_IDENT:
        -:  739:      {
    #####:  740:        *opcode_p = CBC_PRE_DECR_IDENT;
    #####:  741:        break;
        -:  742:      }
    #####:  743:      case CBC_POST_INCR_IDENT:
        -:  744:      {
    #####:  745:        *opcode_p = CBC_PRE_INCR_IDENT;
    #####:  746:        break;
        -:  747:      }
       38:  748:      default:
        -:  749:      {
       38:  750:        break;
        -:  751:      }
        -:  752:    }
        -:  753:
      101:  754:    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  755:    {
       43:  756:      uint8_t *first_byte = page_p->bytes + offset;
       43:  757:      uint32_t literal_index = *first_byte;
        -:  758:
       43:  759:      PARSER_NEXT_BYTE (page_p, offset);
       43:  760:      length++;
        -:  761:
       43:  762:      literal_index |= ((uint32_t) page_p->bytes[offset]) << 8;
        -:  763:
       43:  764:      if (literal_index >= PARSER_REGISTER_START)
        -:  765:      {
        3:  766:        literal_index -= PARSER_REGISTER_START;
        -:  767:      }
        -:  768:      else
        -:  769:      {
       40:  770:        literal_index = (PARSER_GET_LITERAL (literal_index))->prop.index;
        -:  771:      }
        -:  772:
       43:  773:      if (literal_index <= literal_one_byte_limit)
        -:  774:      {
       43:  775:        *first_byte = (uint8_t) literal_index;
        -:  776:      }
        -:  777:      else
        -:  778:      {
    #####:  779:        if (context_p->literal_count <= CBC_MAXIMUM_SMALL_VALUE)
        -:  780:        {
    #####:  781:          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_SMALL_VALUE);
    #####:  782:          *first_byte = CBC_MAXIMUM_BYTE_VALUE;
    #####:  783:          page_p->bytes[offset] = (uint8_t) (literal_index - CBC_MAXIMUM_BYTE_VALUE);
    #####:  784:          length++;
        -:  785:        }
        -:  786:        else
        -:  787:        {
    #####:  788:          JERRY_ASSERT (literal_index <= CBC_MAXIMUM_FULL_VALUE);
    #####:  789:          *first_byte = (uint8_t) ((literal_index >> 8) | CBC_HIGHEST_BIT_MASK);
    #####:  790:          page_p->bytes[offset] = (uint8_t) (literal_index & 0xff);
    #####:  791:          length++;
        -:  792:        }
        -:  793:      }
       43:  794:      PARSER_NEXT_BYTE (page_p, offset);
        -:  795:
       43:  796:      if (flags & CBC_HAS_LITERAL_ARG2)
        -:  797:      {
       11:  798:        if (flags & CBC_HAS_LITERAL_ARG)
        -:  799:        {
       10:  800:          flags = CBC_HAS_LITERAL_ARG;
        -:  801:        }
        -:  802:        else
        -:  803:        {
        1:  804:          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;
        -:  805:        }
        -:  806:      }
        -:  807:      else
        -:  808:      {
       32:  809:        break;
        -:  810:      }
        -:  811:    }
        -:  812:
       45:  813:    if (flags & CBC_HAS_BYTE_ARG)
        -:  814:    {
        -:  815:      /* This argument will be copied without modification. */
        1:  816:      PARSER_NEXT_BYTE (page_p, offset);
        1:  817:      length++;
        -:  818:    }
        -:  819:
       45:  820:    if (flags & CBC_HAS_BRANCH_ARG)
        -:  821:    {
    #####:  822:      bool prefix_zero = true;
        -:  823:
        -:  824:      /* The leading zeroes are dropped from the stream.
        -:  825:       * Although dropping these zeroes for backward
        -:  826:       * branches are unnecessary, we use the same
        -:  827:       * code path for simplicity. */
    #####:  828:      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);
        -:  829:
    #####:  830:      while (--branch_offset_length > 0)
        -:  831:      {
    #####:  832:        uint8_t byte = page_p->bytes[offset];
    #####:  833:        if (byte > 0 || !prefix_zero)
        -:  834:        {
    #####:  835:          prefix_zero = false;
    #####:  836:          length++;
        -:  837:        }
        -:  838:        else
        -:  839:        {
    #####:  840:          JERRY_ASSERT (CBC_BRANCH_IS_FORWARD (flags));
        -:  841:        }
    #####:  842:        PARSER_NEXT_BYTE (page_p, offset);
        -:  843:      }
        -:  844:
    #####:  845:      if (last_opcode == (cbc_opcode_t) (CBC_JUMP_FORWARD + PARSER_MAX_BRANCH_LENGTH - 1) && prefix_zero
    #####:  846:          && page_p->bytes[offset] == PARSER_MAX_BRANCH_LENGTH + 1)
        -:  847:      {
        -:  848:        /* Uncoditional jumps which jump right after the instruction
        -:  849:         * are effectively NOPs. These jumps are removed from the
        -:  850:         * stream. The 1 byte long CBC_JUMP_FORWARD form marks these
        -:  851:         * instructions, since this form is constructed during post
        -:  852:         * processing and cannot be emitted directly. */
    #####:  853:        *opcode_p = CBC_JUMP_FORWARD;
    #####:  854:        length--;
        -:  855:      }
        -:  856:      else
        -:  857:      {
        -:  858:        /* Other last bytes are always copied. */
    #####:  859:        length++;
        -:  860:      }
        -:  861:
    #####:  862:      PARSER_NEXT_BYTE (page_p, offset);
        -:  863:    }
        -:  864:  }
        -:  865:
        5:  866:  if (!(context_p->status_flags & PARSER_NO_END_LABEL) || !(PARSER_OPCODE_IS_RETURN (last_opcode)))
        -:  867:  {
        5:  868:    context_p->status_flags &= (uint32_t) ~PARSER_NO_END_LABEL;
        -:  869:
        -:  870:#if JERRY_ESNEXT
        5:  871:    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -:  872:    {
    #####:  873:      length++;
        -:  874:    }
        -:  875:#endif /* JERRY_ESNEXT */
        -:  876:
        5:  877:    length++;
        -:  878:  }
        -:  879:
        5:  880:  needs_uint16_arguments = false;
        5:  881:  total_size = sizeof (cbc_uint8_arguments_t);
        -:  882:
        5:  883:  if (context_p->stack_limit > CBC_MAXIMUM_BYTE_VALUE || context_p->register_count > CBC_MAXIMUM_BYTE_VALUE
        5:  884:      || context_p->literal_count > CBC_MAXIMUM_BYTE_VALUE)
        -:  885:  {
    #####:  886:    needs_uint16_arguments = true;
    #####:  887:    total_size = sizeof (cbc_uint16_arguments_t);
        -:  888:  }
        -:  889:
        5:  890:  literal_length = (size_t) (context_p->literal_count - context_p->register_count) * sizeof (ecma_value_t);
        -:  891:
        5:  892:  total_size += literal_length + length;
        -:  893:
        5:  894:  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -:  895:  {
    #####:  896:    total_size += context_p->argument_count * sizeof (ecma_value_t);
        -:  897:  }
        -:  898:
        -:  899:#if JERRY_ESNEXT
        -:  900:  /* function.name */
        5:  901:  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))
        -:  902:  {
        5:  903:    total_size += sizeof (ecma_value_t);
        -:  904:  }
        -:  905:
        5:  906:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -:  907:  {
    #####:  908:    total_size += sizeof (ecma_value_t);
        -:  909:  }
        -:  910:#endif /* JERRY_ESNEXT */
        -:  911:
        -:  912:#if JERRY_LINE_INFO
        5:  913:  total_size += sizeof (ecma_value_t);
        -:  914:#endif /* JERRY_LINE_INFO */
        -:  915:
        -:  916:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        5:  917:  uint8_t extended_info = 0;
        -:  918:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  919:
        -:  920:#if JERRY_ESNEXT
        5:  921:  if (context_p->argument_length != UINT16_MAX)
        -:  922:  {
    #####:  923:    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH;
    #####:  924:    total_size += ecma_extended_info_get_encoded_length (context_p->argument_length);
        -:  925:  }
        -:  926:#endif /* JERRY_ESNEXT */
        -:  927:
        -:  928:#if JERRY_FUNCTION_TO_STRING
    #####:  929:  if (context_p->last_context_p != NULL)
        -:  930:  {
    #####:  931:    extended_info |= CBC_EXTENDED_CODE_FLAGS_HAS_SOURCE_CODE_RANGE;
        -:  932:
    #####:  933:    const uint8_t *start_p = context_p->source_start_p;
    #####:  934:    const uint8_t *function_start_p = context_p->last_context_p->function_start_p;
        -:  935:
    #####:  936:    if (function_start_p < start_p || function_start_p >= start_p + context_p->source_size)
        -:  937:    {
        -:  938:      JERRY_ASSERT (context_p->arguments_start_p != NULL && function_start_p >= context_p->arguments_start_p
        -:  939:                    && function_start_p < context_p->arguments_start_p + context_p->arguments_size);
        -:  940:
    #####:  941:      start_p = context_p->arguments_start_p;
    #####:  942:      extended_info |= CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS;
        -:  943:    }
        -:  944:
    #####:  945:    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (function_start_p - start_p));
    #####:  946:    total_size += ecma_extended_info_get_encoded_length ((uint32_t) (context_p->function_end_p - function_start_p));
        -:  947:  }
        -:  948:#endif /* JERRY_FUNCTION_TO_STRING */
        -:  949:
        -:  950:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        5:  951:  if (extended_info != 0)
        -:  952:  {
    #####:  953:    total_size += sizeof (uint8_t);
        -:  954:  }
        -:  955:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  956:
        5:  957:  total_size = JERRY_ALIGNUP (total_size, JMEM_ALIGNMENT);
        -:  958:
        5:  959:  compiled_code_p = (ecma_compiled_code_t *) parser_malloc (context_p, total_size);
        -:  960:
        -:  961:#if JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE
        -:  962:  // Avoid getting junk bytes
    #####:  963:  memset (compiled_code_p, 0, total_size);
        -:  964:#endif /* JERRY_SNAPSHOT_SAVE || JERRY_PARSER_DUMP_BYTE_CODE */
        -:  965:
        -:  966:#if JERRY_MEM_STATS
    #####:  967:  jmem_stats_allocate_byte_code_bytes (total_size);
        -:  968:#endif /* JERRY_MEM_STATS */
        -:  969:
        5:  970:  byte_code_p = (uint8_t *) compiled_code_p;
        5:  971:  compiled_code_p->size = (uint16_t) (total_size >> JMEM_ALIGNMENT_LOG);
        5:  972:  compiled_code_p->refs = 1;
        5:  973:  compiled_code_p->status_flags = 0;
        -:  974:
        -:  975:#if JERRY_ESNEXT
        5:  976:  if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -:  977:  {
    #####:  978:    JERRY_ASSERT (context_p->argument_count > 0);
    #####:  979:    context_p->argument_count--;
        -:  980:  }
        -:  981:#endif /* JERRY_ESNEXT */
        -:  982:
        5:  983:  if (needs_uint16_arguments)
        -:  984:  {
    #####:  985:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -:  986:
    #####:  987:    args_p->stack_limit = context_p->stack_limit;
    #####:  988:    args_p->script_value = context_p->script_value;
    #####:  989:    args_p->argument_end = context_p->argument_count;
    #####:  990:    args_p->register_end = context_p->register_count;
    #####:  991:    args_p->ident_end = ident_end;
    #####:  992:    args_p->const_literal_end = const_literal_end;
    #####:  993:    args_p->literal_end = context_p->literal_count;
        -:  994:
    #####:  995:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_UINT16_ARGUMENTS;
    #####:  996:    byte_code_p += sizeof (cbc_uint16_arguments_t);
        -:  997:  }
        -:  998:  else
        -:  999:  {
        5: 1000:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -: 1001:
        5: 1002:    args_p->stack_limit = (uint8_t) context_p->stack_limit;
        5: 1003:    args_p->argument_end = (uint8_t) context_p->argument_count;
        5: 1004:    args_p->script_value = context_p->script_value;
        5: 1005:    args_p->register_end = (uint8_t) context_p->register_count;
        5: 1006:    args_p->ident_end = (uint8_t) ident_end;
        5: 1007:    args_p->const_literal_end = (uint8_t) const_literal_end;
        5: 1008:    args_p->literal_end = (uint8_t) context_p->literal_count;
        -: 1009:
        5: 1010:    byte_code_p += sizeof (cbc_uint8_arguments_t);
        -: 1011:  }
        -: 1012:
        -: 1013:  uint16_t encoding_limit;
        -: 1014:  uint16_t encoding_delta;
        -: 1015:
        5: 1016:  if (context_p->literal_count > CBC_MAXIMUM_SMALL_VALUE)
        -: 1017:  {
    #####: 1018:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_FULL_LITERAL_ENCODING;
    #####: 1019:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
    #####: 1020:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -: 1021:  }
        -: 1022:  else
        -: 1023:  {
        5: 1024:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
        5: 1025:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -: 1026:  }
        -: 1027:
        5: 1028:  if (context_p->status_flags & PARSER_IS_STRICT)
        -: 1029:  {
        3: 1030:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_STRICT_MODE;
        -: 1031:  }
        -: 1032:
        5: 1033:  if ((context_p->status_flags & PARSER_ARGUMENTS_NEEDED) && PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -: 1034:  {
    #####: 1035:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED;
        -: 1036:  }
        -: 1037:
        5: 1038:  if (!(context_p->status_flags & PARSER_LEXICAL_ENV_NEEDED))
        -: 1039:  {
        3: 1040:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED;
        -: 1041:  }
        -: 1042:
        5: 1043:  uint16_t function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_NORMAL);
        -: 1044:
        5: 1045:  if (context_p->status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))
        -: 1046:  {
        1: 1047:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ACCESSOR);
        -: 1048:  }
        4: 1049:  else if (!(context_p->status_flags & PARSER_IS_FUNCTION))
        -: 1050:  {
        1: 1051:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_SCRIPT);
        -: 1052:  }
        -: 1053:#if JERRY_ESNEXT
        3: 1054:  else if (context_p->status_flags & PARSER_IS_ARROW_FUNCTION)
        -: 1055:  {
    #####: 1056:    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1057:    {
    #####: 1058:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_ARROW);
        -: 1059:    }
        -: 1060:    else
        -: 1061:    {
    #####: 1062:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ARROW);
        -: 1063:    }
        -: 1064:  }
        3: 1065:  else if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1066:  {
    #####: 1067:    if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1068:    {
    #####: 1069:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC_GENERATOR);
        -: 1070:    }
        -: 1071:    else
        -: 1072:    {
    #####: 1073:      function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_GENERATOR);
        -: 1074:    }
        -: 1075:  }
        3: 1076:  else if (context_p->status_flags & PARSER_IS_ASYNC_FUNCTION)
        -: 1077:  {
    #####: 1078:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_ASYNC);
        -: 1079:  }
        3: 1080:  else if (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR)
        -: 1081:  {
    #####: 1082:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_CONSTRUCTOR);
        -: 1083:  }
        3: 1084:  else if (context_p->status_flags & PARSER_IS_METHOD)
        -: 1085:  {
        1: 1086:    function_type = CBC_FUNCTION_TO_TYPE_BITS (CBC_FUNCTION_METHOD);
        -: 1087:  }
        -: 1088:
        5: 1089:  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
        -: 1090:  {
        1: 1091:    JERRY_ASSERT (!(context_p->status_flags & PARSER_IS_FUNCTION));
        1: 1092:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_LEXICAL_BLOCK_NEEDED;
        -: 1093:  }
        -: 1094:#endif /* JERRY_ESNEXT */
        -: 1095:
        5: 1096:  compiled_code_p->status_flags |= function_type;
        -: 1097:
        -: 1098:#if JERRY_LINE_INFO
        5: 1099:  compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_LINE_INFO;
        -: 1100:#endif /* JERRY_LINE_INFO */
        -: 1101:
        5: 1102:  literal_pool_p = ((ecma_value_t *) byte_code_p) - context_p->register_count;
        5: 1103:  byte_code_p += literal_length;
        5: 1104:  dst_p = byte_code_p;
        -: 1105:
        5: 1106:  parser_init_literal_pool (context_p, literal_pool_p);
        -: 1107:
        5: 1108:  page_p = context_p->byte_code.first_p;
        5: 1109:  offset = 0;
        5: 1110:  real_offset = 0;
        5: 1111:  uint8_t last_register_index =
        5: 1112:    (uint8_t) JERRY_MIN (context_p->register_count, (PARSER_MAXIMUM_NUMBER_OF_REGISTERS - 1));
        -: 1113:
       55: 1114:  while (page_p != last_page_p || offset < last_position)
        -: 1115:  {
        -: 1116:    uint8_t flags;
        -: 1117:    uint8_t *opcode_p;
        -: 1118:    uint8_t *branch_mark_p;
        -: 1119:    cbc_opcode_t opcode;
        -: 1120:    size_t branch_offset_length;
        -: 1121:
       45: 1122:    opcode_p = dst_p;
       45: 1123:    branch_mark_p = page_p->bytes + offset;
       45: 1124:    opcode = (cbc_opcode_t) (*branch_mark_p);
       45: 1125:    branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (opcode);
        -: 1126:
       45: 1127:    if (opcode == CBC_JUMP_FORWARD)
        -: 1128:    {
        -: 1129:      /* These opcodes are deleted from the stream. */
    #####: 1130:      size_t counter = PARSER_MAX_BRANCH_LENGTH + 1;
        -: 1131:
        -: 1132:      do
        -: 1133:      {
    #####: 1134:        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
    #####: 1135:      } while (--counter > 0);
        -: 1136:
    #####: 1137:      continue;
        -: 1138:    }
        -: 1139:
        -: 1140:    /* Storing the opcode */
       45: 1141:    *dst_p++ = (uint8_t) opcode;
       45: 1142:    real_offset++;
       45: 1143:    PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
       45: 1144:    flags = cbc_flags[opcode];
        -: 1145:
        -: 1146:#if JERRY_DEBUGGER
        -: 1147:    if (opcode == CBC_BREAKPOINT_DISABLED)
        -: 1148:    {
        -: 1149:      uint32_t bp_offset = (uint32_t) (((uint8_t *) dst_p) - ((uint8_t *) compiled_code_p) - 1);
        -: 1150:      parser_append_breakpoint_info (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST, bp_offset);
        -: 1151:    }
        -: 1152:#endif /* JERRY_DEBUGGER */
        -: 1153:
       45: 1154:    if (opcode == CBC_EXT_OPCODE)
        -: 1155:    {
        -: 1156:      cbc_ext_opcode_t ext_opcode;
        -: 1157:
        7: 1158:      ext_opcode = (cbc_ext_opcode_t) page_p->bytes[offset];
        7: 1159:      flags = cbc_ext_flags[ext_opcode];
        7: 1160:      branch_offset_length = CBC_BRANCH_OFFSET_LENGTH (ext_opcode);
        -: 1161:
        -: 1162:      /* Storing the extended opcode */
        7: 1163:      *dst_p++ = (uint8_t) ext_opcode;
        7: 1164:      opcode_p++;
        7: 1165:      real_offset++;
        7: 1166:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1167:    }
        -: 1168:
        -: 1169:    /* Only literal and call arguments can be combined. */
       45: 1170:    JERRY_ASSERT (!(flags & CBC_HAS_BRANCH_ARG) || !(flags & (CBC_HAS_BYTE_ARG | CBC_HAS_LITERAL_ARG)));
        -: 1171:
      101: 1172:    while (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -: 1173:    {
       43: 1174:      uint16_t first_byte = page_p->bytes[offset];
        -: 1175:
       43: 1176:      uint8_t *opcode_pos_p = dst_p - 1;
       43: 1177:      *dst_p++ = (uint8_t) first_byte;
       43: 1178:      real_offset++;
       43: 1179:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1180:
       43: 1181:      if (first_byte > literal_one_byte_limit)
        -: 1182:      {
    #####: 1183:        *dst_p++ = page_p->bytes[offset];
        -: 1184:
    #####: 1185:        if (first_byte >= encoding_limit)
        -: 1186:        {
    #####: 1187:          first_byte = (uint16_t) (((first_byte << 8) | dst_p[-1]) - encoding_delta);
        -: 1188:        }
    #####: 1189:        real_offset++;
        -: 1190:      }
       43: 1191:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1192:
       43: 1193:      if (flags & CBC_HAS_LITERAL_ARG2)
        -: 1194:      {
       11: 1195:        if (flags & CBC_HAS_LITERAL_ARG)
        -: 1196:        {
       10: 1197:          flags = CBC_HAS_LITERAL_ARG;
        -: 1198:        }
        -: 1199:        else
        -: 1200:        {
        1: 1201:          flags = CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2;
        -: 1202:        }
        -: 1203:      }
        -: 1204:      else
        -: 1205:      {
       32: 1206:        if (opcode == CBC_ASSIGN_SET_IDENT && JERRY_LIKELY (first_byte < last_register_index))
        -: 1207:        {
    #####: 1208:          *opcode_pos_p = CBC_MOV_IDENT;
        -: 1209:        }
        -: 1210:
       32: 1211:        break;
        -: 1212:      }
        -: 1213:    }
        -: 1214:
       45: 1215:    if (flags & CBC_HAS_BYTE_ARG)
        -: 1216:    {
        -: 1217:      /* This argument will be copied without modification. */
        1: 1218:      *dst_p++ = page_p->bytes[offset];
        1: 1219:      real_offset++;
        1: 1220:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        1: 1221:      continue;
        -: 1222:    }
        -: 1223:
       44: 1224:    if (flags & CBC_HAS_BRANCH_ARG)
        -: 1225:    {
    #####: 1226:      *branch_mark_p |= CBC_HIGHEST_BIT_MASK;
    #####: 1227:      bool prefix_zero = true;
        -: 1228:
        -: 1229:      /* The leading zeroes are dropped from the stream. */
    #####: 1230:      JERRY_ASSERT (branch_offset_length > 0 && branch_offset_length <= 3);
        -: 1231:
    #####: 1232:      while (--branch_offset_length > 0)
        -: 1233:      {
    #####: 1234:        uint8_t byte = page_p->bytes[offset];
    #####: 1235:        if (byte > 0 || !prefix_zero)
        -: 1236:        {
    #####: 1237:          prefix_zero = false;
    #####: 1238:          *dst_p++ = page_p->bytes[offset];
    #####: 1239:          real_offset++;
        -: 1240:        }
        -: 1241:        else
        -: 1242:        {
        -: 1243:          /* When a leading zero is dropped, the branch
        -: 1244:           * offset length must be decreased as well. */
    #####: 1245:          (*opcode_p)--;
        -: 1246:        }
    #####: 1247:        PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
        -: 1248:      }
        -: 1249:
    #####: 1250:      *dst_p++ = page_p->bytes[offset];
    #####: 1251:      real_offset++;
    #####: 1252:      PARSER_NEXT_BYTE_UPDATE (page_p, offset, real_offset);
    #####: 1253:      continue;
        -: 1254:    }
        -: 1255:  }
        -: 1256:
        -: 1257:#if JERRY_DEBUGGER
        -: 1258:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -: 1259:  {
        -: 1260:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_OFFSET_LIST);
        -: 1261:    JERRY_ASSERT (context_p->breakpoint_info_count == 0);
        -: 1262:  }
        -: 1263:#endif /* JERRY_DEBUGGER */
        -: 1264:
        5: 1265:  if (!(context_p->status_flags & PARSER_NO_END_LABEL))
        -: 1266:  {
        5: 1267:    *dst_p++ = CBC_RETURN_FUNCTION_END;
        -: 1268:
        -: 1269:#if JERRY_ESNEXT
        5: 1270:    if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -: 1271:    {
    #####: 1272:      dst_p[-1] = CBC_EXT_OPCODE;
    #####: 1273:      dst_p[0] = CBC_EXT_ASYNC_EXIT;
    #####: 1274:      dst_p++;
        -: 1275:    }
        -: 1276:#endif /* JERRY_ESNEXT */
        -: 1277:  }
        5: 1278:  JERRY_ASSERT (dst_p == byte_code_p + length);
        -: 1279:
        -: 1280:#if JERRY_LINE_INFO
        5: 1281:  uint8_t *line_info_p = parser_line_info_generate (context_p);
        -: 1282:#endif /* JERRY_LINE_INFO */
        -: 1283:
        5: 1284:  parse_update_branches (context_p, byte_code_p);
        -: 1285:
        5: 1286:  parser_cbc_stream_free (&context_p->byte_code);
        -: 1287:
        5: 1288:  if (context_p->status_flags & PARSER_HAS_LATE_LIT_INIT)
        -: 1289:  {
        5: 1290:    parser_list_iterator_t literal_iterator;
        -: 1291:    lexer_literal_t *literal_p;
        5: 1292:    uint16_t register_count = context_p->register_count;
        -: 1293:
        5: 1294:    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
       37: 1295:    while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)))
        -: 1296:    {
       27: 1297:      if ((literal_p->status_flags & LEXER_FLAG_LATE_INIT) && literal_p->prop.index >= register_count)
        -: 1298:      {
       21: 1299:        uint32_t source_data = literal_p->u.source_data;
       21: 1300:        const uint8_t *char_p = context_p->source_end_p - (source_data & 0xfffff);
       21: 1301:        ecma_value_t lit_value = ecma_find_or_create_literal_string (char_p,
        -: 1302:                                                                     source_data >> 20,
       21: 1303:                                                                     (literal_p->status_flags & LEXER_FLAG_ASCII) != 0);
       21: 1304:        literal_pool_p[literal_p->prop.index] = lit_value;
        -: 1305:      }
        -: 1306:    }
        -: 1307:  }
        -: 1308:
        5: 1309:  ecma_value_t *base_p = (ecma_value_t *) (((uint8_t *) compiled_code_p) + total_size);
        -: 1310:
        5: 1311:  if (PARSER_NEEDS_MAPPED_ARGUMENTS (context_p->status_flags))
        -: 1312:  {
    #####: 1313:    parser_list_iterator_t literal_iterator;
    #####: 1314:    uint16_t argument_count = 0;
    #####: 1315:    uint16_t register_count = context_p->register_count;
    #####: 1316:    base_p -= context_p->argument_count;
        -: 1317:
    #####: 1318:    parser_list_iterator_init (&context_p->literal_pool, &literal_iterator);
    #####: 1319:    while (argument_count < context_p->argument_count)
        -: 1320:    {
        -: 1321:      lexer_literal_t *literal_p;
    #####: 1322:      literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator);
        -: 1323:
    #####: 1324:      JERRY_ASSERT (literal_p != NULL);
        -: 1325:
    #####: 1326:      if (!(literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))
        -: 1327:      {
    #####: 1328:        continue;
        -: 1329:      }
        -: 1330:
        -: 1331:      /* All arguments must be moved to initialized registers. */
    #####: 1332:      if (literal_p->type == LEXER_UNUSED_LITERAL)
        -: 1333:      {
    #####: 1334:        base_p[argument_count] = ECMA_VALUE_EMPTY;
    #####: 1335:        argument_count++;
    #####: 1336:        continue;
        -: 1337:      }
        -: 1338:
    #####: 1339:      JERRY_ASSERT (literal_p->type == LEXER_IDENT_LITERAL);
        -: 1340:
    #####: 1341:      JERRY_ASSERT (literal_p->prop.index >= register_count);
        -: 1342:
    #####: 1343:      base_p[argument_count] = literal_pool_p[literal_p->prop.index];
    #####: 1344:      argument_count++;
        -: 1345:    }
        -: 1346:  }
        -: 1347:
        -: 1348:#if JERRY_ESNEXT
        5: 1349:  if (!(context_p->status_flags & PARSER_CLASS_CONSTRUCTOR))
        -: 1350:  {
        5: 1351:    *(--base_p) = ecma_make_magic_string_value (LIT_MAGIC_STRING__EMPTY);
        -: 1352:  }
        -: 1353:
        5: 1354:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 1355:  {
    #####: 1356:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_TAGGED_LITERALS;
    #####: 1357:    *(--base_p) = (ecma_value_t) context_p->tagged_template_literal_cp;
        -: 1358:  }
        -: 1359:#endif /* JERRY_ESNEXT */
        -: 1360:
        -: 1361:#if JERRY_LINE_INFO
        5: 1362:  ECMA_SET_INTERNAL_VALUE_POINTER (base_p[-1], line_info_p);
        -: 1363:#endif /* JERRY_LINE_INFO */
        -: 1364:
        -: 1365:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        5: 1366:  if (extended_info != 0)
        -: 1367:  {
        -: 1368:#if JERRY_LINE_INFO
    #####: 1369:    base_p--;
        -: 1370:#endif /* JERRY_LINE_INFO */
        -: 1371:
    #####: 1372:    uint8_t *extended_info_p = ((uint8_t *) base_p) - 1;
        -: 1373:
    #####: 1374:    compiled_code_p->status_flags |= CBC_CODE_FLAGS_HAS_EXTENDED_INFO;
    #####: 1375:    *extended_info_p = extended_info;
        -: 1376:
        -: 1377:#if JERRY_ESNEXT
    #####: 1378:    if (context_p->argument_length != UINT16_MAX)
        -: 1379:    {
    #####: 1380:      ecma_extended_info_encode_vlq (&extended_info_p, context_p->argument_length);
        -: 1381:    }
        -: 1382:#endif /* JERRY_ESNEXT */
        -: 1383:
        -: 1384:#if JERRY_FUNCTION_TO_STRING
    #####: 1385:    if (context_p->last_context_p != NULL)
        -: 1386:    {
    #####: 1387:      const uint8_t *start_p = context_p->source_start_p;
        -: 1388:
    #####: 1389:      if (extended_info & CBC_EXTENDED_CODE_FLAGS_SOURCE_CODE_IN_ARGUMENTS)
        -: 1390:      {
    #####: 1391:        start_p = context_p->arguments_start_p;
        -: 1392:      }
        -: 1393:
    #####: 1394:      const uint8_t *function_start_p = context_p->last_context_p->function_start_p;
        -: 1395:
    #####: 1396:      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (function_start_p - start_p));
    #####: 1397:      ecma_extended_info_encode_vlq (&extended_info_p, (uint32_t) (context_p->function_end_p - function_start_p));
        -: 1398:    }
        -: 1399:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1400:  }
        -: 1401:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -: 1402:
        -: 1403:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 1404:  if (context_p->is_show_opcodes)
        -: 1405:  {
        -: 1406:    util_print_cbc (compiled_code_p);
        -: 1407:    JERRY_DEBUG_MSG ("\nByte code size: %d bytes\n", (int) length);
        -: 1408:    context_p->total_byte_code_size += (uint32_t) length;
        -: 1409:  }
        -: 1410:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 1411:
        -: 1412:#if JERRY_DEBUGGER
        -: 1413:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 1414:  {
        -: 1415:    jerry_debugger_send_function_cp (JERRY_DEBUGGER_BYTE_CODE_CP, compiled_code_p);
        -: 1416:  }
        -: 1417:#endif /* JERRY_DEBUGGER */
        -: 1418:
        5: 1419:  return compiled_code_p;
        -: 1420:} /* parser_post_processing */
        -: 1421:
        -: 1422:#undef PARSER_NEXT_BYTE
        -: 1423:#undef PARSER_NEXT_BYTE_UPDATE
        -: 1424:
        -: 1425:#if JERRY_ESNEXT
        -: 1426:/**
        -: 1427: * Resolve private identifier in direct eval context
        -: 1428: */
        -: 1429:static bool
    #####: 1430:parser_resolve_private_identifier_eval (parser_context_t *context_p) /**< context */
        -: 1431:{
        -: 1432:  ecma_string_t *search_key_p;
    #####: 1433:  uint8_t *destination_p = (uint8_t *) parser_malloc (context_p, context_p->token.lit_location.length);
        -: 1434:
    #####: 1435:  lexer_convert_ident_to_cesu8 (destination_p,
        -: 1436:                                context_p->token.lit_location.char_p,
    #####: 1437:                                context_p->token.lit_location.length);
        -: 1438:
    #####: 1439:  search_key_p = ecma_new_ecma_string_from_utf8 (destination_p, context_p->token.lit_location.length);
        -: 1440:
    #####: 1441:  parser_free (destination_p, context_p->token.lit_location.length);
        -: 1442:
    #####: 1443:  ecma_object_t *lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -: 1444:
        -: 1445:  while (true)
        -: 1446:  {
    #####: 1447:    JERRY_ASSERT (lex_env_p != NULL);
        -: 1448:
    #####: 1449:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
    #####: 1450:        && (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) != 0
    #####: 1451:        && !ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))
        -: 1452:    {
    #####: 1453:      ecma_object_t *class_object_p = ((ecma_lexical_environment_class_t *) lex_env_p)->object_p;
        -: 1454:
    #####: 1455:      ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
    #####: 1456:      ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -: 1457:
    #####: 1458:      if (prop_p != NULL)
        -: 1459:      {
    #####: 1460:        ecma_value_t *collection_p =
    #####: 1461:          ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 1462:        ecma_value_t *current_p = collection_p + 1;
    #####: 1463:        ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1464:
    #####: 1465:        while (current_p < end_p)
        -: 1466:        {
    #####: 1467:          current_p++; /* skip kind */
    #####: 1468:          ecma_string_t *private_key_p = ecma_get_prop_name_from_value (*current_p++);
    #####: 1469:          current_p++; /* skip value */
        -: 1470:
    #####: 1471:          JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1472:
    #####: 1473:          ecma_string_t *private_key_desc_p =
    #####: 1474:            ecma_get_string_from_value (((ecma_extended_string_t *) private_key_p)->u.symbol_descriptor);
        -: 1475:
    #####: 1476:          if (ecma_compare_ecma_strings (private_key_desc_p, search_key_p))
        -: 1477:          {
    #####: 1478:            ecma_deref_ecma_string (search_key_p);
    #####: 1479:            lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####: 1480:            return true;
        -: 1481:          }
        -: 1482:        }
        -: 1483:      }
        -: 1484:    }
        -: 1485:
    #####: 1486:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -: 1487:    {
    #####: 1488:      break;
        -: 1489:    }
        -: 1490:
    #####: 1491:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1492:  }
        -: 1493:
    #####: 1494:  ecma_deref_ecma_string (search_key_p);
    #####: 1495:  return false;
        -: 1496:} /* parser_resolve_private_identifier_eval */
        -: 1497:
        -: 1498:/**
        -: 1499: * Resolve private identifier
        -: 1500: */
        -: 1501:void
        2: 1502:parser_resolve_private_identifier (parser_context_t *context_p) /**< context */
        -: 1503:{
        2: 1504:  if ((context_p->global_status_flags & ECMA_PARSE_DIRECT_EVAL) && parser_resolve_private_identifier_eval (context_p))
        -: 1505:  {
    #####: 1506:    return;
        -: 1507:  }
        -: 1508:
        2: 1509:  parser_private_context_t *context_iter_p = context_p->private_context_p;
        -: 1510:
        4: 1511:  while (context_iter_p)
        -: 1512:  {
        2: 1513:    if (context_iter_p == NULL || !(context_iter_p->opts & SCANNER_PRIVATE_FIELD_ACTIVE))
        -: 1514:    {
    #####: 1515:      parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1516:    }
        -: 1517:
        2: 1518:    if (!(context_iter_p->opts & SCANNER_SUCCESSFUL_CLASS_SCAN))
        -: 1519:    {
    #####: 1520:      lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
    #####: 1521:      return;
        -: 1522:    }
        -: 1523:
        2: 1524:    parser_private_context_t *private_context_p = context_iter_p;
        -: 1525:
        2: 1526:    if (private_context_p == NULL)
        -: 1527:    {
    #####: 1528:      parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1529:    }
        -: 1530:
        2: 1531:    scanner_class_private_member_t *ident_iter = private_context_p->members_p;
        -: 1532:
        4: 1533:    while (ident_iter)
        -: 1534:    {
        2: 1535:      if (lexer_compare_identifiers (context_p, &context_p->token.lit_location, &ident_iter->loc))
        -: 1536:      {
        2: 1537:        lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_STRING_LITERAL);
        2: 1538:        return;
        -: 1539:      }
        -: 1540:
    #####: 1541:      ident_iter = ident_iter->prev_p;
        -: 1542:    }
        -: 1543:
    #####: 1544:    context_iter_p = context_iter_p->prev_p;
        -: 1545:  }
        -: 1546:
    #####: 1547:  parser_raise_error (context_p, PARSER_ERR_UNDECLARED_PRIVATE_FIELD);
        -: 1548:} /* parser_resolve_private_identifier */
        -: 1549:
        -: 1550:/**
        -: 1551: * Save private field context
        -: 1552: */
        -: 1553:void
        1: 1554:parser_save_private_context (parser_context_t *context_p, /**< context */
        -: 1555:                             parser_private_context_t *private_ctx_p, /**< private context */
        -: 1556:                             scanner_class_info_t *class_info_p) /**< class scanner info */
        -: 1557:{
        1: 1558:  private_ctx_p->prev_p = context_p->private_context_p;
        1: 1559:  context_p->private_context_p = private_ctx_p;
        -: 1560:
        1: 1561:  context_p->private_context_p->members_p = class_info_p->members;
        1: 1562:  context_p->private_context_p->opts = class_info_p->info.u8_arg;
        1: 1563:  class_info_p->members = NULL;
        1: 1564:} /* parser_save_private_context */
        -: 1565:
        -: 1566:/**
        -: 1567: * Release contexts private fields
        -: 1568: */
        -: 1569:static void
    #####: 1570:parser_free_private_fields (parser_context_t *context_p) /**< context */
        -: 1571:{
    #####: 1572:  parser_private_context_t *iter = context_p->private_context_p;
        -: 1573:
    #####: 1574:  while (iter != NULL)
        -: 1575:  {
    #####: 1576:    parser_private_context_t *prev_p = iter->prev_p;
    #####: 1577:    scanner_release_private_fields (iter->members_p);
    #####: 1578:    iter = prev_p;
        -: 1579:  }
    #####: 1580:} /* parser_free_private_fields */
        -: 1581:
        -: 1582:/**
        -: 1583: * Restore contexts private fields
        -: 1584: */
        -: 1585:void
        1: 1586:parser_restore_private_context (parser_context_t *context_p, /**< context */
        -: 1587:                                parser_private_context_t *private_ctx_p) /**< private context */
        -: 1588:{
        1: 1589:  scanner_release_private_fields (context_p->private_context_p->members_p);
        1: 1590:  context_p->private_context_p = private_ctx_p->prev_p;
        1: 1591:} /* parser_restore_private_context */
        -: 1592:#endif /* JERRY_ESNEXT */
        -: 1593:
        -: 1594:/**
        -: 1595: * Free identifiers and literals.
        -: 1596: */
        -: 1597:static void
    #####: 1598:parser_free_literals (parser_list_t *literal_pool_p) /**< literals */
        -: 1599:{
    #####: 1600:  parser_list_iterator_t literal_iterator;
        -: 1601:  lexer_literal_t *literal_p;
        -: 1602:
    #####: 1603:  parser_list_iterator_init (literal_pool_p, &literal_iterator);
    #####: 1604:  while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL)
        -: 1605:  {
    #####: 1606:    util_free_literal (literal_p);
        -: 1607:  }
        -: 1608:
    #####: 1609:  parser_list_free (literal_pool_p);
    #####: 1610:} /* parser_free_literals */
        -: 1611:
        -: 1612:/**
        -: 1613: * Parse function arguments
        -: 1614: */
        -: 1615:static void
        4: 1616:parser_parse_function_arguments (parser_context_t *context_p, /**< context */
        -: 1617:                                 lexer_token_type_t end_type) /**< expected end type */
        -: 1618:{
        4: 1619:  JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 1620:
        -: 1621:#if JERRY_ESNEXT
        4: 1622:  JERRY_ASSERT (context_p->status_flags & PARSER_IS_FUNCTION);
        4: 1623:  JERRY_ASSERT (!(context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED));
        -: 1624:
        4: 1625:  bool has_duplicated_arg_names = false;
        -: 1626:
        4: 1627:  if (PARSER_IS_NORMAL_ASYNC_FUNCTION (context_p->status_flags))
        -: 1628:  {
    #####: 1629:    parser_branch_t branch;
    #####: 1630:    parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_TRY_CREATE_CONTEXT, &branch);
    #####: 1631:    parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 1632:
        -: 1633:#ifndef JERRY_NDEBUG
    #####: 1634:    context_p->context_stack_depth = PARSER_TRY_CONTEXT_STACK_ALLOCATION;
        -: 1635:#endif /* !JERRY_NDEBUG */
        -: 1636:  }
        -: 1637:#endif /* JERRY_ESNEXT */
        -: 1638:
        4: 1639:  if (context_p->token.type == end_type)
        -: 1640:  {
        -: 1641:#if JERRY_ESNEXT
        3: 1642:    context_p->status_flags &= (uint32_t) ~PARSER_DISALLOW_AWAIT_YIELD;
        -: 1643:
        3: 1644:    if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1645:    {
    #####: 1646:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);
    #####: 1647:      parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);
    #####: 1648:      parser_emit_cbc (context_p, CBC_POP);
    #####: 1649:      scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);
    #####: 1650:      return;
        -: 1651:    }
        -: 1652:#endif /* JERRY_ESNEXT */
        3: 1653:    scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
        3: 1654:    return;
        -: 1655:  }
        -: 1656:
        -: 1657:#if JERRY_ESNEXT
        1: 1658:  bool has_complex_argument = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_HAS_COMPLEX_ARGUMENT) != 0;
        -: 1659:#endif /* JERRY_ESNEXT */
        1: 1660:  bool is_strict = (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT) != 0;
        -: 1661:
        1: 1662:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_ARGS);
        1: 1663:  scanner_set_active (context_p);
        -: 1664:
        -: 1665:#if JERRY_ESNEXT
        1: 1666:  context_p->status_flags |= PARSER_FUNCTION_IS_PARSING_ARGS;
        -: 1667:#endif /* JERRY_ESNEXT */
        -: 1668:
        -: 1669:  while (true)
    #####: 1670:  {
        -: 1671:#if JERRY_ESNEXT
        1: 1672:    if (context_p->token.type == LEXER_THREE_DOTS)
        -: 1673:    {
    #####: 1674:      if (context_p->status_flags & PARSER_IS_PROPERTY_SETTER)
        -: 1675:      {
    #####: 1676:        parser_raise_error (context_p, PARSER_ERR_SETTER_REST_PARAMETER);
        -: 1677:      }
    #####: 1678:      lexer_next_token (context_p);
        -: 1679:
    #####: 1680:      if (has_duplicated_arg_names)
        -: 1681:      {
    #####: 1682:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1683:      }
        -: 1684:
    #####: 1685:      context_p->status_flags |= PARSER_FUNCTION_HAS_REST_PARAM | PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1686:    }
        -: 1687:
        1: 1688:    if (context_p->token.type == LEXER_LEFT_SQUARE || context_p->token.type == LEXER_LEFT_BRACE)
        -: 1689:    {
    #####: 1690:      if (has_duplicated_arg_names)
        -: 1691:      {
    #####: 1692:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1693:      }
        -: 1694:
    #####: 1695:      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1696:
    #####: 1697:      if (!(context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM))
        -: 1698:      {
    #####: 1699:        parser_emit_cbc_literal (context_p,
        -: 1700:                                 CBC_PUSH_LITERAL,
    #####: 1701:                                 (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));
        -: 1702:      }
        -: 1703:      else
        -: 1704:      {
    #####: 1705:        parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);
        -: 1706:      }
        -: 1707:
    #####: 1708:      uint32_t flags =
        -: 1709:        (PARSER_PATTERN_BINDING | PARSER_PATTERN_TARGET_ON_STACK | PARSER_PATTERN_LOCAL | PARSER_PATTERN_ARGUMENTS);
        -: 1710:
    #####: 1711:      if (context_p->next_scanner_info_p->source_p == context_p->source_p)
        -: 1712:      {
    #####: 1713:        if (context_p->next_scanner_info_p->type == SCANNER_TYPE_INITIALIZER)
        -: 1714:        {
    #####: 1715:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1716:          {
    #####: 1717:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1718:          }
        -: 1719:
    #####: 1720:          if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1721:          {
    #####: 1722:            parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);
        -: 1723:          }
        -: 1724:
    #####: 1725:          if (context_p->argument_length == UINT16_MAX)
        -: 1726:          {
    #####: 1727:            context_p->argument_length = context_p->argument_count;
        -: 1728:          }
        -: 1729:
    #####: 1730:          flags |= PARSER_PATTERN_TARGET_DEFAULT;
        -: 1731:        }
    #####: 1732:        else if (context_p->next_scanner_info_p->type == SCANNER_TYPE_LITERAL_FLAGS)
        -: 1733:        {
    #####: 1734:          if (context_p->next_scanner_info_p->u8_arg & SCANNER_LITERAL_OBJECT_HAS_REST)
        -: 1735:          {
    #####: 1736:            flags |= PARSER_PATTERN_HAS_REST_ELEMENT;
        -: 1737:          }
    #####: 1738:          scanner_release_next (context_p, sizeof (scanner_info_t));
        -: 1739:        }
        -: 1740:        else
        -: 1741:        {
    #####: 1742:          parser_raise_error (context_p, PARSER_ERR_INVALID_DESTRUCTURING_PATTERN);
        -: 1743:        }
        -: 1744:      }
        -: 1745:
    #####: 1746:      parser_parse_initializer (context_p, flags);
        -: 1747:
    #####: 1748:      context_p->argument_count++;
    #####: 1749:      if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1750:      {
    #####: 1751:        parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1752:      }
        -: 1753:
    #####: 1754:      if (context_p->token.type != LEXER_COMMA)
        -: 1755:      {
    #####: 1756:        if (context_p->token.type != end_type)
        -: 1757:        {
    #####: 1758:          parser_error_msg_t error =
    #####: 1759:            ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED : PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1760:
    #####: 1761:          parser_raise_error (context_p, error);
        -: 1762:        }
    #####: 1763:        break;
        -: 1764:      }
        -: 1765:
    #####: 1766:      lexer_next_token (context_p);
        -: 1767:
    #####: 1768:      if (context_p->token.type == end_type)
        -: 1769:      {
    #####: 1770:        break;
        -: 1771:      }
    #####: 1772:      continue;
        -: 1773:    }
        -: 1774:#endif /* JERRY_ESNEXT */
        -: 1775:
        1: 1776:    if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL)
        -: 1777:    {
    #####: 1778:      parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1779:    }
        -: 1780:
        1: 1781:    lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL);
        -: 1782:
        1: 1783:    if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS)
        -: 1784:    {
    #####: 1785:      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1786:    }
        -: 1787:
        1: 1788:    if (JERRY_UNLIKELY (context_p->lit_object.literal_p->status_flags & LEXER_FLAG_FUNCTION_ARGUMENT))
        -: 1789:    {
        -: 1790:#if JERRY_ESNEXT
    #####: 1791:      if ((context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT)
    #####: 1792:          || (context_p->status_flags & PARSER_IS_ARROW_FUNCTION))
        -: 1793:      {
    #####: 1794:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1795:      }
    #####: 1796:      has_duplicated_arg_names = true;
        -: 1797:#endif /* JERRY_ESNEXT */
        -: 1798:
    #####: 1799:      context_p->status_flags |= PARSER_HAS_NON_STRICT_ARG;
        -: 1800:    }
        -: 1801:    else
        -: 1802:    {
        1: 1803:      context_p->lit_object.literal_p->status_flags |= LEXER_FLAG_FUNCTION_ARGUMENT;
        -: 1804:    }
        -: 1805:
        1: 1806:    lexer_next_token (context_p);
        -: 1807:
        -: 1808:#if JERRY_ESNEXT
        1: 1809:    uint16_t literal_index = context_p->lit_object.index;
        -: 1810:
        1: 1811:    if (context_p->token.type == LEXER_ASSIGN)
        -: 1812:    {
    #####: 1813:      JERRY_ASSERT (has_complex_argument);
        -: 1814:
    #####: 1815:      if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1816:      {
    #####: 1817:        parser_raise_error (context_p, PARSER_ERR_REST_PARAMETER_DEFAULT_INITIALIZER);
        -: 1818:      }
        -: 1819:
    #####: 1820:      if (context_p->argument_length == UINT16_MAX)
        -: 1821:      {
    #####: 1822:        context_p->argument_length = context_p->argument_count;
        -: 1823:      }
        -: 1824:
    #####: 1825:      parser_branch_t skip_init;
        -: 1826:
    #####: 1827:      if (has_duplicated_arg_names)
        -: 1828:      {
    #####: 1829:        parser_raise_error (context_p, PARSER_ERR_DUPLICATED_ARGUMENT_NAMES);
        -: 1830:      }
        -: 1831:
    #####: 1832:      context_p->status_flags |= PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT;
        -: 1833:
        -: 1834:      /* LEXER_ASSIGN does not overwrite lit_object. */
    #####: 1835:      parser_emit_cbc_literal (context_p,
        -: 1836:                               CBC_PUSH_LITERAL,
    #####: 1837:                               (uint16_t) (PARSER_REGISTER_START + context_p->argument_count));
    #####: 1838:      parser_emit_cbc_ext_forward_branch (context_p, CBC_EXT_DEFAULT_INITIALIZER, &skip_init);
        -: 1839:
    #####: 1840:      lexer_next_token (context_p);
    #####: 1841:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 1842:
    #####: 1843:      parser_set_branch_to_current_position (context_p, &skip_init);
        -: 1844:
    #####: 1845:      uint16_t opcode = CBC_ASSIGN_LET_CONST;
        -: 1846:
    #####: 1847:      if (literal_index >= PARSER_REGISTER_START)
        -: 1848:      {
    #####: 1849:        opcode = CBC_MOV_IDENT;
        -: 1850:      }
    #####: 1851:      else if (!scanner_literal_is_created (context_p, literal_index))
        -: 1852:      {
    #####: 1853:        opcode = CBC_INIT_ARG_OR_CATCH;
        -: 1854:      }
        -: 1855:
    #####: 1856:      parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1857:    }
        1: 1858:    else if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1859:    {
    #####: 1860:      parser_emit_cbc_ext (context_p, CBC_EXT_PUSH_REST_OBJECT);
        -: 1861:
    #####: 1862:      uint16_t opcode = CBC_MOV_IDENT;
        -: 1863:
    #####: 1864:      if (literal_index < PARSER_REGISTER_START)
        -: 1865:      {
    #####: 1866:        opcode = CBC_INIT_ARG_OR_CATCH;
        -: 1867:
    #####: 1868:        if (scanner_literal_is_created (context_p, literal_index))
        -: 1869:        {
    #####: 1870:          opcode = CBC_ASSIGN_LET_CONST;
        -: 1871:        }
        -: 1872:      }
        -: 1873:
    #####: 1874:      parser_emit_cbc_literal (context_p, opcode, literal_index);
        -: 1875:    }
        1: 1876:    else if (has_complex_argument && literal_index < PARSER_REGISTER_START)
        -: 1877:    {
    #####: 1878:      uint16_t opcode = CBC_INIT_ARG_OR_FUNC;
        -: 1879:
    #####: 1880:      if (scanner_literal_is_created (context_p, literal_index))
        -: 1881:      {
    #####: 1882:        opcode = CBC_ASSIGN_LET_CONST_LITERAL;
        -: 1883:      }
        -: 1884:
    #####: 1885:      parser_emit_cbc_literal_value (context_p,
        -: 1886:                                     opcode,
    #####: 1887:                                     (uint16_t) (PARSER_REGISTER_START + context_p->argument_count),
        -: 1888:                                     literal_index);
        -: 1889:    }
        -: 1890:#endif /* JERRY_ESNEXT */
        -: 1891:
        1: 1892:    context_p->argument_count++;
        1: 1893:    if (context_p->argument_count >= PARSER_MAXIMUM_NUMBER_OF_REGISTERS)
        -: 1894:    {
    #####: 1895:      parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIMIT_REACHED);
        -: 1896:    }
        -: 1897:
        1: 1898:    if (context_p->token.type != LEXER_COMMA)
        -: 1899:    {
        1: 1900:      if (context_p->token.type != end_type)
        -: 1901:      {
    #####: 1902:        parser_error_msg_t error =
    #####: 1903:          ((end_type == LEXER_RIGHT_PAREN) ? PARSER_ERR_RIGHT_PAREN_EXPECTED : PARSER_ERR_IDENTIFIER_EXPECTED);
        -: 1904:
    #####: 1905:        parser_raise_error (context_p, error);
        -: 1906:      }
        1: 1907:      break;
        -: 1908:    }
        -: 1909:
        -: 1910:#if JERRY_ESNEXT
    #####: 1911:    if (context_p->status_flags & PARSER_FUNCTION_HAS_REST_PARAM)
        -: 1912:    {
    #####: 1913:      parser_raise_error (context_p, PARSER_ERR_FORMAL_PARAM_AFTER_REST_PARAMETER);
        -: 1914:    }
        -: 1915:#endif /* JERRY_ESNEXT */
        -: 1916:
    #####: 1917:    lexer_next_token (context_p);
        -: 1918:
        -: 1919:#if JERRY_ESNEXT
    #####: 1920:    if (context_p->token.type == end_type)
        -: 1921:    {
    #####: 1922:      break;
        -: 1923:    }
        -: 1924:#endif /* JERRY_ESNEXT */
        -: 1925:  }
        -: 1926:
        1: 1927:  scanner_revert_active (context_p);
        -: 1928:
        -: 1929:#if JERRY_ESNEXT
        1: 1930:  JERRY_ASSERT (has_complex_argument || !(context_p->status_flags & PARSER_FUNCTION_HAS_COMPLEX_ARGUMENT));
        -: 1931:
        1: 1932:  if (context_p->status_flags & PARSER_IS_GENERATOR_FUNCTION)
        -: 1933:  {
    #####: 1934:    parser_emit_cbc_ext (context_p, CBC_EXT_CREATE_GENERATOR);
    #####: 1935:    parser_emit_cbc (context_p, CBC_POP);
        -: 1936:  }
        -: 1937:
        1: 1938:  if (context_p->status_flags & PARSER_LEXICAL_BLOCK_NEEDED)
        -: 1939:  {
    #####: 1940:    if ((context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_LEXICAL_ENV_NEEDED)
    #####: 1941:        || scanner_is_context_needed (context_p, PARSER_CHECK_FUNCTION_CONTEXT))
    #####: 1942:    {
    #####: 1943:      context_p->status_flags |= PARSER_LEXICAL_ENV_NEEDED;
        -: 1944:
    #####: 1945:      parser_branch_t branch;
    #####: 1946:      parser_emit_cbc_forward_branch (context_p, CBC_BLOCK_CREATE_CONTEXT, &branch);
    #####: 1947:      parser_stack_push (context_p, &branch, sizeof (parser_branch_t));
        -: 1948:
        -: 1949:#ifndef JERRY_NDEBUG
    #####: 1950:      PARSER_PLUS_EQUAL_U16 (context_p->context_stack_depth, PARSER_BLOCK_CONTEXT_STACK_ALLOCATION);
        -: 1951:#endif /* !JERRY_NDEBUG */
        -: 1952:    }
        -: 1953:    else
        -: 1954:    {
    #####: 1955:      context_p->status_flags &= (uint32_t) ~PARSER_LEXICAL_BLOCK_NEEDED;
        -: 1956:    }
        -: 1957:  }
        -: 1958:
        1: 1959:  context_p->status_flags &= (uint32_t) ~(PARSER_DISALLOW_AWAIT_YIELD | PARSER_FUNCTION_IS_PARSING_ARGS);
        -: 1960:#endif /* JERRY_ESNEXT */
        -: 1961:
        1: 1962:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_IS_FUNCTION_BODY);
        -: 1963:
        1: 1964:  if (is_strict)
        -: 1965:  {
    #####: 1966:    context_p->status_flags |= PARSER_IS_STRICT;
        -: 1967:  }
        -: 1968:} /* parser_parse_function_arguments */
        -: 1969:
        -: 1970:#ifndef JERRY_NDEBUG
        -: 1971:JERRY_STATIC_ASSERT (PARSER_SCANNING_SUCCESSFUL == PARSER_HAS_LATE_LIT_INIT,
        -: 1972:                     parser_scanning_successful_should_share_the_bit_position_with_parser_has_late_lit_init);
        -: 1973:#endif /* !JERRY_NDEBUG */
        -: 1974:
        -: 1975:/**
        -: 1976: * Parser script size
        -: 1977: */
        -: 1978:static size_t
        1: 1979:parser_script_size (parser_context_t *context_p) /**< context */
        -: 1980:{
        1: 1981:  size_t script_size = sizeof (cbc_script_t);
        -: 1982:
        1: 1983:  if (context_p->user_value != ECMA_VALUE_EMPTY)
        -: 1984:  {
    #####: 1985:    script_size += sizeof (ecma_value_t);
        -: 1986:  }
        -: 1987:
        -: 1988:#if JERRY_FUNCTION_TO_STRING
    #####: 1989:  if (context_p->argument_list != ECMA_VALUE_EMPTY)
        -: 1990:  {
    #####: 1991:    script_size += sizeof (ecma_value_t);
        -: 1992:  }
        -: 1993:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 1994:
        -: 1995:#if JERRY_MODULE_SYSTEM
        1: 1996:  if (context_p->global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)
        -: 1997:  {
    #####: 1998:    script_size += sizeof (ecma_value_t);
        -: 1999:  }
        -: 2000:#endif /* JERRY_MODULE_SYSTEM */
        1: 2001:  return script_size;
        -: 2002:} /* parser_script_size */
        -: 2003:
        -: 2004:#if JERRY_SOURCE_NAME
        -: 2005:/**
        -: 2006: * Parser resource name
        -: 2007: */
        -: 2008:static ecma_value_t
        1: 2009:parser_source_name (parser_context_t *context_p) /**< context */
        -: 2010:{
        1: 2011:  if (context_p->options_p != NULL && (context_p->options_p->options & JERRY_PARSE_HAS_SOURCE_NAME))
        -: 2012:  {
        1: 2013:    JERRY_ASSERT (ecma_is_value_string (context_p->options_p->source_name));
        -: 2014:
        1: 2015:    ecma_ref_ecma_string (ecma_get_string_from_value (context_p->options_p->source_name));
        1: 2016:    return context_p->options_p->source_name;
        -: 2017:  }
        -: 2018:
    #####: 2019:  if (context_p->global_status_flags & ECMA_PARSE_EVAL)
        -: 2020:  {
    #####: 2021:    return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_EVAL);
        -: 2022:  }
        -: 2023:
    #####: 2024:  return ecma_make_magic_string_value (LIT_MAGIC_STRING_SOURCE_NAME_ANON);
        -: 2025:} /* parser_source_name */
        -: 2026:#endif /* JERRY_SOURCE_NAME */
        -: 2027:
        -: 2028:/**
        -: 2029: * Parse and compile EcmaScript source code
        -: 2030: *
        -: 2031: * Note: source must be a valid UTF-8 string
        -: 2032: *
        -: 2033: * @return compiled code
        -: 2034: */
        -: 2035:static ecma_compiled_code_t *
        1: 2036:parser_parse_source (void *source_p, /**< source code */
        -: 2037:                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */
        -: 2038:                     const jerry_parse_options_t *options_p) /**< additional configuration options */
        -: 2039:{
        1: 2040:  parser_context_t context;
        -: 2041:  ecma_compiled_code_t *compiled_code_p;
        -: 2042:
        1: 2043:  context.error = PARSER_ERR_NO_ERROR;
        1: 2044:  context.status_flags = parse_opts & PARSER_STRICT_MODE_MASK;
        1: 2045:  context.global_status_flags = parse_opts;
        -: 2046:
        -: 2047:#if JERRY_ESNEXT
        1: 2048:  context.status_flags |= PARSER_RESTORE_STATUS_FLAGS (parse_opts);
        1: 2049:  context.tagged_template_literal_cp = JMEM_CP_NULL;
        -: 2050:#endif /* JERRY_ESNEXT */
        -: 2051:
        1: 2052:  context.stack_depth = 0;
        1: 2053:  context.stack_limit = 0;
        1: 2054:  context.options_p = options_p;
        1: 2055:  context.script_p = NULL;
        1: 2056:  context.arguments_start_p = NULL;
        1: 2057:  context.arguments_size = 0;
        -: 2058:#if JERRY_MODULE_SYSTEM
        1: 2059:  if (context.global_status_flags & ECMA_PARSE_MODULE)
        -: 2060:  {
    #####: 2061:    context.status_flags |= PARSER_IS_STRICT;
        -: 2062:  }
        -: 2063:
        1: 2064:  context.module_names_p = NULL;
        -: 2065:#endif /* JERRY_MODULE_SYSTEM */
        -: 2066:
        1: 2067:  context.argument_list = ECMA_VALUE_EMPTY;
        -: 2068:
        1: 2069:  if (context.options_p != NULL && (context.options_p->options & JERRY_PARSE_HAS_ARGUMENT_LIST))
        -: 2070:  {
    #####: 2071:    context.argument_list = context.options_p->argument_list;
        -: 2072:  }
        1: 2073:  else if (context.global_status_flags & ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE)
        -: 2074:  {
    #####: 2075:    JERRY_ASSERT (context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE);
    #####: 2076:    context.argument_list = ((ecma_value_t *) source_p)[1];
        -: 2077:  }
        -: 2078:
        1: 2079:  if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2080:  {
    #####: 2081:    JERRY_ASSERT (ecma_is_value_string (context.argument_list));
        -: 2082:
    #####: 2083:    context.status_flags |= PARSER_IS_FUNCTION;
        -: 2084:#if JERRY_ESNEXT
    #####: 2085:    if (parse_opts & ECMA_PARSE_GENERATOR_FUNCTION)
        -: 2086:    {
    #####: 2087:      context.status_flags |= PARSER_IS_GENERATOR_FUNCTION;
        -: 2088:    }
    #####: 2089:    if (parse_opts & ECMA_PARSE_ASYNC_FUNCTION)
        -: 2090:    {
    #####: 2091:      context.status_flags |= PARSER_IS_ASYNC_FUNCTION;
        -: 2092:    }
        -: 2093:#endif /* JERRY_ESNEXT */
        -: 2094:
    #####: 2095:    ecma_string_t *string_p = ecma_get_string_from_value (context.argument_list);
    #####: 2096:    uint8_t flags = ECMA_STRING_FLAG_EMPTY;
        -: 2097:
    #####: 2098:    context.arguments_start_p = ecma_string_get_chars (string_p, &context.arguments_size, NULL, NULL, &flags);
        -: 2099:
    #####: 2100:    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2101:    {
    #####: 2102:      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_ARG_LIST;
        -: 2103:    }
        -: 2104:  }
        -: 2105:
        1: 2106:  if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))
        -: 2107:  {
        1: 2108:    context.source_start_p = ((parser_source_char_t *) source_p)->source_p;
        1: 2109:    context.source_size = (lit_utf8_size_t) ((parser_source_char_t *) source_p)->source_size;
        -: 2110:  }
        -: 2111:  else
        -: 2112:  {
    #####: 2113:    ecma_value_t source = ((ecma_value_t *) source_p)[0];
        -: 2114:
    #####: 2115:    JERRY_ASSERT (ecma_is_value_string (source));
        -: 2116:
    #####: 2117:    ecma_string_t *string_p = ecma_get_string_from_value (source);
    #####: 2118:    uint8_t flags = ECMA_STRING_FLAG_EMPTY;
        -: 2119:
    #####: 2120:    context.source_start_p = ecma_string_get_chars (string_p, &context.source_size, NULL, NULL, &flags);
        -: 2121:
    #####: 2122:    if (flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 2123:    {
    #####: 2124:      context.global_status_flags |= ECMA_PARSE_INTERNAL_FREE_SOURCE;
        -: 2125:    }
        -: 2126:  }
        -: 2127:
        -: 2128:#if JERRY_DEBUGGER
        -: 2129:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2130:  {
        -: 2131:    jerry_debugger_send_string (JERRY_DEBUGGER_SOURCE_CODE,
        -: 2132:                                JERRY_DEBUGGER_NO_SUBTYPE,
        -: 2133:                                context.source_start_p,
        -: 2134:                                context.source_size);
        -: 2135:  }
        -: 2136:#endif /* JERRY_DEBUGGER */
        -: 2137:
        1: 2138:  context.user_value = ECMA_VALUE_EMPTY;
        -: 2139:
        1: 2140:  if ((context.global_status_flags & ECMA_PARSE_EVAL) && JERRY_CONTEXT (vm_top_context_p) != NULL)
    #####: 2141:  {
    #####: 2142:    const ecma_compiled_code_t *bytecode_header_p = JERRY_CONTEXT (vm_top_context_p)->shared_p->bytecode_header_p;
        -: 2143:
        -: 2144:#if JERRY_SNAPSHOT_EXEC
    #####: 2145:    if (JERRY_LIKELY (!(bytecode_header_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION)))
        -: 2146:    {
        -: 2147:#endif /* JERRY_SNAPSHOT_EXEC */
    #####: 2148:      ecma_value_t parent_script_value = ((cbc_uint8_arguments_t *) bytecode_header_p)->script_value;
        -: 2149:      ;
    #####: 2150:      cbc_script_t *parent_script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, parent_script_value);
        -: 2151:
    #####: 2152:      if (parent_script_p->refs_and_type & CBC_SCRIPT_HAS_USER_VALUE)
        -: 2153:      {
    #####: 2154:        context.user_value = CBC_SCRIPT_GET_USER_VALUE (parent_script_p);
        -: 2155:      }
        -: 2156:#if JERRY_SNAPSHOT_EXEC
        -: 2157:    }
        -: 2158:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 2159:  }
        1: 2160:  else if (context.options_p != NULL && (context.options_p->options & JERRY_PARSE_HAS_USER_VALUE))
        -: 2161:  {
    #####: 2162:    context.user_value = context.options_p->user_value;
        -: 2163:  }
        -: 2164:
        1: 2165:  context.last_context_p = NULL;
        1: 2166:  context.last_statement.current_p = NULL;
        1: 2167:  context.token.flags = 0;
        1: 2168:  lexer_init_line_info (&context);
        -: 2169:
        1: 2170:  scanner_info_t scanner_info_end;
        1: 2171:  scanner_info_end.next_p = NULL;
        1: 2172:  scanner_info_end.source_p = NULL;
        1: 2173:  scanner_info_end.type = SCANNER_TYPE_END;
        1: 2174:  context.next_scanner_info_p = &scanner_info_end;
        1: 2175:  context.active_scanner_info_p = NULL;
        1: 2176:  context.skipped_scanner_info_p = NULL;
        1: 2177:  context.skipped_scanner_info_end_p = NULL;
        -: 2178:
        1: 2179:  context.last_cbc_opcode = PARSER_CBC_UNAVAILABLE;
        -: 2180:
        1: 2181:  context.argument_count = 0;
        -: 2182:#if JERRY_ESNEXT
        1: 2183:  context.argument_length = UINT16_MAX;
        -: 2184:#endif /* JERRY_ESNEXT */
        1: 2185:  context.register_count = 0;
        1: 2186:  context.literal_count = 0;
        -: 2187:
        1: 2188:  parser_cbc_stream_init (&context.byte_code);
        1: 2189:  context.byte_code_size = 0;
        1: 2190:  parser_list_init (&context.literal_pool,
        -: 2191:                    sizeof (lexer_literal_t),
        -: 2192:                    (uint32_t) ((128 - sizeof (void *)) / sizeof (lexer_literal_t)));
        1: 2193:  context.scope_stack_p = NULL;
        1: 2194:  context.scope_stack_size = 0;
        1: 2195:  context.scope_stack_top = 0;
        1: 2196:  context.scope_stack_reg_top = 0;
        -: 2197:#if JERRY_ESNEXT
        1: 2198:  context.scope_stack_global_end = 0;
        1: 2199:  context.tagged_template_literal_cp = JMEM_CP_NULL;
        1: 2200:  context.private_context_p = NULL;
        -: 2201:#endif /* JERRY_ESNEXT */
        -: 2202:
        -: 2203:#ifndef JERRY_NDEBUG
        1: 2204:  context.context_stack_depth = 0;
        -: 2205:#endif /* !JERRY_NDEBUG */
        -: 2206:
        -: 2207:#if JERRY_LINE_INFO
        1: 2208:  context.line_info_p = NULL;
        -: 2209:#endif /* JERRY_LINE_INFO */
        -: 2210:
        -: 2211:#if JERRY_FUNCTION_TO_STRING
    #####: 2212:  context.function_start_p = NULL;
    #####: 2213:  context.function_end_p = NULL;
        -: 2214:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2215:
        -: 2216:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2217:  context.is_show_opcodes = (JERRY_CONTEXT (jerry_init_flags) & JERRY_INIT_SHOW_OPCODES);
        -: 2218:  context.total_byte_code_size = 0;
        -: 2219:
        -: 2220:  if (context.is_show_opcodes)
        -: 2221:  {
        -: 2222:    JERRY_DEBUG_MSG ("\n--- %s parsing start ---\n\n", (context.arguments_start_p == NULL) ? "Script" : "Function");
        -: 2223:  }
        -: 2224:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2225:
        1: 2226:  scanner_scan_all (&context);
        -: 2227:
        1: 2228:  if (JERRY_UNLIKELY (context.error != PARSER_ERR_NO_ERROR))
        -: 2229:  {
    #####: 2230:    JERRY_ASSERT (context.error == PARSER_ERR_OUT_OF_MEMORY);
        -: 2231:
        -: 2232:    /* It is unlikely that memory can be allocated in an out-of-memory
        -: 2233:     * situation. However, a simple value can still be thrown. */
    #####: 2234:    jcontext_raise_exception (ECMA_VALUE_NULL);
    #####: 2235:    return NULL;
        -: 2236:  }
        -: 2237:
        1: 2238:  if (context.arguments_start_p == NULL)
        -: 2239:  {
        1: 2240:    context.source_p = context.source_start_p;
        1: 2241:    context.source_end_p = context.source_start_p + context.source_size;
        -: 2242:  }
        -: 2243:  else
        -: 2244:  {
    #####: 2245:    context.source_p = context.arguments_start_p;
    #####: 2246:    context.source_end_p = context.arguments_start_p + context.arguments_size;
        -: 2247:  }
        -: 2248:
        1: 2249:  context.u.allocated_buffer_p = NULL;
        1: 2250:  context.token.flags = 0;
        1: 2251:  lexer_init_line_info (&context);
        -: 2252:
        1: 2253:  parser_stack_init (&context);
        -: 2254:
        -: 2255:#if JERRY_DEBUGGER
        -: 2256:  context.breakpoint_info_count = 0;
        -: 2257:#endif /* JERRY_DEBUGGER */
        -: 2258:
        1: 2259:  JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_p);
        1: 2260:  JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2261:
        1: 2262:  if (context.next_scanner_info_p->u8_arg & SCANNER_FUNCTION_IS_STRICT)
        -: 2263:  {
    #####: 2264:    context.status_flags |= PARSER_IS_STRICT;
        -: 2265:  }
        -: 2266:
        1: 2267:  PARSER_TRY (context.try_buffer)
        -: 2268:  {
        1: 2269:    context.script_p = parser_malloc (&context, parser_script_size (&context));
        -: 2270:
        1: 2271:    CBC_SCRIPT_SET_TYPE (context.script_p, context.user_value, CBC_SCRIPT_REF_ONE);
        -: 2272:
        1: 2273:    if (context.global_status_flags & (ECMA_PARSE_EVAL | ECMA_PARSE_HAS_ARGUMENT_LIST_VALUE))
        -: 2274:    {
    #####: 2275:      context.script_p->refs_and_type |= CBC_SCRIPT_IS_EVAL_CODE;
        -: 2276:    }
        -: 2277:
        -: 2278:#if JERRY_BUILTIN_REALMS
        1: 2279:    context.script_p->realm_p = (ecma_object_t *) JERRY_CONTEXT (global_object_p);
        -: 2280:#endif /* JERRY_BUILTIN_REALMS */
        -: 2281:
        -: 2282:#if JERRY_SOURCE_NAME
        1: 2283:    context.script_p->source_name = parser_source_name (&context);
        -: 2284:#endif /* JERRY_SOURCE_NAME */
        -: 2285:
        1: 2286:    ECMA_SET_INTERNAL_VALUE_POINTER (context.script_value, context.script_p);
        -: 2287:
        -: 2288:    /* Pushing a dummy value ensures the stack is never empty.
        -: 2289:     * This simplifies the stack management routines. */
        1: 2290:    parser_stack_push_uint8 (&context, CBC_MAXIMUM_BYTE_VALUE);
        -: 2291:    /* The next token must always be present to make decisions
        -: 2292:     * in the parser. Therefore when a token is consumed, the
        -: 2293:     * lexer_next_token() must be immediately called. */
        1: 2294:    lexer_next_token (&context);
        -: 2295:
        1: 2296:    if (context.arguments_start_p != NULL)
        -: 2297:    {
    #####: 2298:      parser_parse_function_arguments (&context, LEXER_EOS);
        -: 2299:
    #####: 2300:      JERRY_ASSERT (context.next_scanner_info_p->type == SCANNER_TYPE_END_ARGUMENTS);
    #####: 2301:      scanner_release_next (&context, sizeof (scanner_info_t));
        -: 2302:
    #####: 2303:      context.source_p = context.source_start_p;
    #####: 2304:      context.source_end_p = context.source_start_p + context.source_size;
    #####: 2305:      lexer_init_line_info (&context);
        -: 2306:
    #####: 2307:      lexer_next_token (&context);
        -: 2308:    }
        -: 2309:#if JERRY_MODULE_SYSTEM
        1: 2310:    else if (parse_opts & ECMA_PARSE_MODULE)
        -: 2311:    {
    #####: 2312:      parser_branch_t branch;
    #####: 2313:      parser_emit_cbc_forward_branch (&context, CBC_JUMP_FORWARD, &branch);
        -: 2314:
    #####: 2315:      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_MODULE);
    #####: 2316:      parser_emit_cbc (&context, CBC_RETURN_FUNCTION_END);
        -: 2317:
    #####: 2318:      parser_set_branch_to_current_position (&context, &branch);
        -: 2319:    }
        -: 2320:#endif /* JERRY_MODULE_SYSTEM */
        -: 2321:    else
        -: 2322:    {
        1: 2323:      JERRY_ASSERT (context.next_scanner_info_p->source_p == context.source_start_p
        -: 2324:                    && context.next_scanner_info_p->type == SCANNER_TYPE_FUNCTION);
        -: 2325:
        -: 2326:#if JERRY_ESNEXT
        1: 2327:      if (scanner_is_context_needed (&context, PARSER_CHECK_GLOBAL_CONTEXT))
        -: 2328:      {
        1: 2329:        context.status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2330:      }
        -: 2331:
        1: 2332:      if (!(parse_opts & ECMA_PARSE_EVAL))
        -: 2333:      {
        1: 2334:        scanner_check_variables (&context);
        -: 2335:      }
        -: 2336:#endif /* JERRY_ESNEXT */
        -: 2337:
        1: 2338:      scanner_create_variables (&context, SCANNER_CREATE_VARS_IS_SCRIPT);
        -: 2339:    }
        -: 2340:
        1: 2341:    parser_parse_statements (&context);
        -: 2342:
        1: 2343:    JERRY_ASSERT (context.last_statement.current_p == NULL);
        -: 2344:
        1: 2345:    JERRY_ASSERT (context.last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        1: 2346:    JERRY_ASSERT (context.u.allocated_buffer_p == NULL);
        -: 2347:
        -: 2348:#ifndef JERRY_NDEBUG
        1: 2349:    JERRY_ASSERT (context.status_flags & PARSER_SCANNING_SUCCESSFUL);
        1: 2350:    JERRY_ASSERT (!(context.global_status_flags & ECMA_PARSE_INTERNAL_FOR_IN_OFF_CONTEXT_ERROR));
        1: 2351:    context.status_flags &= (uint32_t) ~PARSER_SCANNING_SUCCESSFUL;
        -: 2352:#endif /* !JERRY_NDEBUG */
        -: 2353:
        1: 2354:    JERRY_ASSERT (!(context.status_flags & PARSER_HAS_LATE_LIT_INIT));
        -: 2355:
        1: 2356:    compiled_code_p = parser_post_processing (&context);
        1: 2357:    parser_list_free (&context.literal_pool);
        -: 2358:
        -: 2359:    /* When parsing is successful, only the dummy value can be remained on the stack. */
        1: 2360:    JERRY_ASSERT (context.stack_top_uint8 == CBC_MAXIMUM_BYTE_VALUE && context.stack.last_position == 1
        -: 2361:                  && context.stack.first_p != NULL && context.stack.first_p->next_p == NULL
        -: 2362:                  && context.stack.last_p == NULL);
        -: 2363:
        1: 2364:    JERRY_ASSERT (context.arguments_start_p != NULL || !(context.status_flags & PARSER_ARGUMENTS_NEEDED));
        -: 2365:
        1: 2366:    context.script_p->refs_and_type -= CBC_SCRIPT_REF_ONE;
        -: 2367:
        1: 2368:    if (context.user_value != ECMA_VALUE_EMPTY)
        -: 2369:    {
    #####: 2370:      CBC_SCRIPT_GET_USER_VALUE (context.script_p) = ecma_copy_value_if_not_object (context.user_value);
        -: 2371:    }
        -: 2372:
        -: 2373:#if JERRY_MODULE_SYSTEM
        1: 2374:    if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_IMPORT_META)
        -: 2375:    {
    #####: 2376:      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;
    #####: 2377:      ecma_value_t module = ecma_make_object_value ((ecma_object_t *) JERRY_CONTEXT (module_current_p));
        -: 2378:
    #####: 2379:      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = module;
    #####: 2380:      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_IMPORT_META;
        -: 2381:    }
        -: 2382:#endif /* JERRY_MODULE_SYSTEM */
        -: 2383:
        -: 2384:#if JERRY_FUNCTION_TO_STRING
    #####: 2385:    if (!(context.global_status_flags & ECMA_PARSE_HAS_SOURCE_VALUE))
        -: 2386:    {
        -: 2387:      ecma_string_t *string_p;
        -: 2388:
    #####: 2389:      if (context.global_status_flags & ECMA_PARSE_INTERNAL_HAS_4_BYTE_MARKER)
        -: 2390:      {
    #####: 2391:        string_p = ecma_new_ecma_string_from_utf8_converted_to_cesu8 (context.source_start_p, context.source_size);
        -: 2392:      }
        -: 2393:      else
        -: 2394:      {
    #####: 2395:        string_p = ecma_new_ecma_string_from_utf8 (context.source_start_p, context.source_size);
        -: 2396:      }
        -: 2397:
    #####: 2398:      context.script_p->source_code = ecma_make_string_value (string_p);
        -: 2399:    }
        -: 2400:    else
        -: 2401:    {
    #####: 2402:      ecma_value_t source = ((ecma_value_t *) source_p)[0];
        -: 2403:
    #####: 2404:      ecma_ref_ecma_string (ecma_get_string_from_value (source));
    #####: 2405:      context.script_p->source_code = source;
        -: 2406:    }
        -: 2407:
    #####: 2408:    if (context.argument_list != ECMA_VALUE_EMPTY)
        -: 2409:    {
    #####: 2410:      int idx = (context.user_value != ECMA_VALUE_EMPTY) ? 1 : 0;
        -: 2411:
    #####: 2412:      CBC_SCRIPT_GET_OPTIONAL_VALUES (context.script_p)[idx] = context.argument_list;
        -: 2413:
    #####: 2414:      ecma_ref_ecma_string (ecma_get_string_from_value (context.argument_list));
    #####: 2415:      context.script_p->refs_and_type |= CBC_SCRIPT_HAS_FUNCTION_ARGUMENTS;
        -: 2416:    }
        -: 2417:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2418:
        -: 2419:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2420:    if (context.is_show_opcodes)
        -: 2421:    {
        -: 2422:      JERRY_DEBUG_MSG ("\n%s parsing successfully completed. Total byte code size: %d bytes\n",
        -: 2423:                       (context.arguments_start_p == NULL) ? "Script" : "Function",
        -: 2424:                       (int) context.total_byte_code_size);
        -: 2425:    }
        -: 2426:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2427:  }
        -: 2428:  PARSER_CATCH
        -: 2429:  {
    #####: 2430:    if (context.last_statement.current_p != NULL)
        -: 2431:    {
    #####: 2432:      parser_free_jumps (context.last_statement);
        -: 2433:    }
        -: 2434:
    #####: 2435:    parser_free_allocated_buffer (&context);
        -: 2436:
    #####: 2437:    scanner_cleanup (&context);
        -: 2438:
        -: 2439:#if JERRY_MODULE_SYSTEM
    #####: 2440:    if (context.module_names_p != NULL)
        -: 2441:    {
    #####: 2442:      ecma_module_release_module_names (context.module_names_p);
        -: 2443:    }
        -: 2444:#endif /* JERRY_MODULE_SYSTEM */
        -: 2445:
    #####: 2446:    compiled_code_p = NULL;
    #####: 2447:    parser_free_literals (&context.literal_pool);
    #####: 2448:    parser_cbc_stream_free (&context.byte_code);
        -: 2449:
        -: 2450:#if JERRY_SOURCE_NAME
    #####: 2451:    ecma_deref_ecma_string (ecma_get_string_from_value (context.script_p->source_name));
        -: 2452:#endif /* JERRY_SOURCE_NAME */
        -: 2453:
    #####: 2454:    if (context.script_p != NULL)
        -: 2455:    {
    #####: 2456:      JERRY_ASSERT (context.script_p->refs_and_type >= CBC_SCRIPT_REF_ONE);
    #####: 2457:      jmem_heap_free_block (context.script_p, parser_script_size (&context));
        -: 2458:    }
        -: 2459:  }
        -: 2460:  PARSER_TRY_END
        -: 2461:
        1: 2462:  if (context.scope_stack_p != NULL)
        -: 2463:  {
        1: 2464:    parser_free (context.scope_stack_p, context.scope_stack_size * sizeof (parser_scope_stack_t));
        -: 2465:  }
        -: 2466:
        -: 2467:#if JERRY_LINE_INFO
        1: 2468:  parser_line_info_free (context.line_info_p);
        -: 2469:#endif /* JERRY_LINE_INFO */
        -: 2470:
        -: 2471:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2472:  if (context.is_show_opcodes)
        -: 2473:  {
        -: 2474:    JERRY_DEBUG_MSG ("\n--- %s parsing end ---\n\n", (context.arguments_start_p == NULL) ? "Script" : "Function");
        -: 2475:  }
        -: 2476:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2477:
        1: 2478:  parser_stack_free (&context);
        -: 2479:
        1: 2480:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_SOURCE)
        -: 2481:  {
    #####: 2482:    jmem_heap_free_block ((void *) context.source_start_p, context.source_size);
        -: 2483:  }
        -: 2484:
        1: 2485:  if (context.global_status_flags & ECMA_PARSE_INTERNAL_FREE_ARG_LIST)
        -: 2486:  {
    #####: 2487:    jmem_heap_free_block ((void *) context.arguments_start_p, context.arguments_size);
        -: 2488:  }
        -: 2489:
        1: 2490:  if (compiled_code_p != NULL)
        -: 2491:  {
        1: 2492:    return compiled_code_p;
        -: 2493:  }
        -: 2494:
        -: 2495:#if JERRY_DEBUGGER
        -: 2496:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2497:  {
        -: 2498:    jerry_debugger_send_type (JERRY_DEBUGGER_PARSE_ERROR);
        -: 2499:  }
        -: 2500:#endif /* JERRY_DEBUGGER */
        -: 2501:
    #####: 2502:  if (context.error == PARSER_ERR_OUT_OF_MEMORY)
        -: 2503:  {
        -: 2504:    /* It is unlikely that memory can be allocated in an out-of-memory
        -: 2505:     * situation. However, a simple value can still be thrown. */
    #####: 2506:    jcontext_raise_exception (ECMA_VALUE_NULL);
    #####: 2507:    return NULL;
        -: 2508:  }
        -: 2509:#if (JERRY_STACK_LIMIT != 0)
    #####: 2510:  if (context.error == PARSER_ERR_STACK_OVERFLOW)
        -: 2511:  {
    #####: 2512:    ecma_raise_standard_error (JERRY_ERROR_RANGE, ECMA_ERR_MAXIMUM_CALL_STACK_SIZE_EXCEEDED);
    #####: 2513:    return NULL;
        -: 2514:  }
        -: 2515:#endif /* JERRY_STACK_LIMIT != 0 */
        -: 2516:
        -: 2517:#if JERRY_ERROR_MESSAGES
        -: 2518:  ecma_string_t *err_str_p;
        -: 2519:
    #####: 2520:  if (context.error == PARSER_ERR_INVALID_REGEXP)
        -: 2521:  {
    #####: 2522:    ecma_value_t error = jcontext_take_exception ();
    #####: 2523:    ecma_property_t *prop_p =
    #####: 2524:      ecma_find_named_property (ecma_get_object_from_value (error), ecma_get_magic_string (LIT_MAGIC_STRING_MESSAGE));
    #####: 2525:    ecma_free_value (error);
    #####: 2526:    JERRY_ASSERT (prop_p);
    #####: 2527:    err_str_p = ecma_get_string_from_value (ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 2528:    ecma_ref_ecma_string (err_str_p);
        -: 2529:  }
        -: 2530:  else
        -: 2531:  {
    #####: 2532:    err_str_p = ecma_new_ecma_external_string_from_cesu8 (parser_get_error_utf8 (context.error),
    #####: 2533:                                                          parser_get_error_size (context.error),
        -: 2534:                                                          NULL);
        -: 2535:  }
    #####: 2536:  ecma_value_t err_str_val = ecma_make_string_value (err_str_p);
    #####: 2537:  ecma_value_t line_str_val = ecma_make_uint32_value (context.token.line);
    #####: 2538:  ecma_value_t col_str_val = ecma_make_uint32_value (context.token.column);
    #####: 2539:  ecma_value_t source_name = parser_source_name (&context);
        -: 2540:
    #####: 2541:  ecma_raise_standard_error_with_format (JERRY_ERROR_SYNTAX,
        -: 2542:                                         "% [%:%:%]",
        -: 2543:                                         err_str_val,
        -: 2544:                                         source_name,
        -: 2545:                                         line_str_val,
        -: 2546:                                         col_str_val);
        -: 2547:
    #####: 2548:  ecma_free_value (source_name);
    #####: 2549:  ecma_free_value (col_str_val);
    #####: 2550:  ecma_free_value (line_str_val);
    #####: 2551:  ecma_deref_ecma_string (err_str_p);
        -: 2552:#else /* !JERRY_ERROR_MESSAGES */
        -: 2553:  if (context.error == PARSER_ERR_INVALID_REGEXP)
        -: 2554:  {
        -: 2555:    jcontext_release_exception ();
        -: 2556:  }
        -: 2557:
        -: 2558:  ecma_raise_syntax_error (ECMA_ERR_EMPTY);
        -: 2559:#endif /* JERRY_ERROR_MESSAGES */
        -: 2560:
    #####: 2561:  return NULL;
        -: 2562:} /* parser_parse_source */
        -: 2563:
        -: 2564:/**
        -: 2565: * Save parser context before function parsing.
        -: 2566: */
        -: 2567:static void
        4: 2568:parser_save_context (parser_context_t *context_p, /**< context */
        -: 2569:                     parser_saved_context_t *saved_context_p) /**< target for saving the context */
        -: 2570:{
        4: 2571:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 2572:
        -: 2573:#if JERRY_DEBUGGER
        -: 2574:  if ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) && context_p->breakpoint_info_count > 0)
        -: 2575:  {
        -: 2576:    parser_send_breakpoints (context_p, JERRY_DEBUGGER_BREAKPOINT_LIST);
        -: 2577:    context_p->breakpoint_info_count = 0;
        -: 2578:  }
        -: 2579:#endif /* JERRY_DEBUGGER */
        -: 2580:
        -: 2581:#if JERRY_ESNEXT
        4: 2582:  if (context_p->status_flags & PARSER_FUNCTION_IS_PARSING_ARGS)
        -: 2583:  {
    #####: 2584:    context_p->status_flags |= PARSER_LEXICAL_BLOCK_NEEDED;
        -: 2585:  }
        -: 2586:#endif /* JERRY_ESNEXT */
        -: 2587:
        -: 2588:  /* Save private part of the context. */
        -: 2589:
        4: 2590:  saved_context_p->status_flags = context_p->status_flags;
        4: 2591:  saved_context_p->stack_depth = context_p->stack_depth;
        4: 2592:  saved_context_p->stack_limit = context_p->stack_limit;
        4: 2593:  saved_context_p->prev_context_p = context_p->last_context_p;
        4: 2594:  saved_context_p->last_statement = context_p->last_statement;
        -: 2595:
        4: 2596:  saved_context_p->argument_count = context_p->argument_count;
        -: 2597:#if JERRY_ESNEXT
        4: 2598:  saved_context_p->argument_length = context_p->argument_length;
        -: 2599:#endif /* JERRY_ESNEXT */
        4: 2600:  saved_context_p->register_count = context_p->register_count;
        4: 2601:  saved_context_p->literal_count = context_p->literal_count;
        -: 2602:
        4: 2603:  saved_context_p->byte_code = context_p->byte_code;
        4: 2604:  saved_context_p->byte_code_size = context_p->byte_code_size;
        4: 2605:  saved_context_p->literal_pool_data = context_p->literal_pool.data;
        4: 2606:  saved_context_p->scope_stack_p = context_p->scope_stack_p;
        4: 2607:  saved_context_p->scope_stack_size = context_p->scope_stack_size;
        4: 2608:  saved_context_p->scope_stack_top = context_p->scope_stack_top;
        4: 2609:  saved_context_p->scope_stack_reg_top = context_p->scope_stack_reg_top;
        -: 2610:#if JERRY_ESNEXT
        4: 2611:  saved_context_p->scope_stack_global_end = context_p->scope_stack_global_end;
        4: 2612:  saved_context_p->tagged_template_literal_cp = context_p->tagged_template_literal_cp;
        -: 2613:#endif /* JERRY_ESNEXT */
        -: 2614:
        -: 2615:#ifndef JERRY_NDEBUG
        4: 2616:  saved_context_p->context_stack_depth = context_p->context_stack_depth;
        -: 2617:#endif /* !JERRY_NDEBUG */
        -: 2618:
        -: 2619:#if JERRY_LINE_INFO
        4: 2620:  saved_context_p->line_info_p = context_p->line_info_p;
        -: 2621:#endif /* JERRY_LINE_INFO */
        -: 2622:
        -: 2623:#if JERRY_FUNCTION_TO_STRING
    #####: 2624:  saved_context_p->function_start_p = context_p->function_start_p;
        -: 2625:#endif /* JERRY_FUNCTION_TO_STRING */
        -: 2626:
        -: 2627:  /* Reset private part of the context. */
        -: 2628:
        4: 2629:  context_p->status_flags &= PARSER_IS_STRICT;
        4: 2630:  context_p->stack_depth = 0;
        4: 2631:  context_p->stack_limit = 0;
        4: 2632:  context_p->last_context_p = saved_context_p;
        4: 2633:  context_p->last_statement.current_p = NULL;
        -: 2634:
        4: 2635:  context_p->argument_count = 0;
        -: 2636:#if JERRY_ESNEXT
        4: 2637:  context_p->argument_length = UINT16_MAX;
        -: 2638:#endif /* JERRY_ESNEXT */
        4: 2639:  context_p->register_count = 0;
        4: 2640:  context_p->literal_count = 0;
        -: 2641:
        4: 2642:  parser_cbc_stream_init (&context_p->byte_code);
        4: 2643:  context_p->byte_code_size = 0;
        4: 2644:  parser_list_reset (&context_p->literal_pool);
        4: 2645:  context_p->scope_stack_p = NULL;
        4: 2646:  context_p->scope_stack_size = 0;
        4: 2647:  context_p->scope_stack_top = 0;
        4: 2648:  context_p->scope_stack_reg_top = 0;
        -: 2649:#if JERRY_ESNEXT
        4: 2650:  context_p->scope_stack_global_end = 0;
        4: 2651:  context_p->tagged_template_literal_cp = JMEM_CP_NULL;
        -: 2652:#endif /* JERRY_ESNEXT */
        -: 2653:
        -: 2654:#ifndef JERRY_NDEBUG
        4: 2655:  context_p->context_stack_depth = 0;
        -: 2656:#endif /* !JERRY_NDEBUG */
        -: 2657:
        -: 2658:#if JERRY_LINE_INFO
        4: 2659:  context_p->line_info_p = NULL;
        -: 2660:#endif /* JERRY_LINE_INFO */
        4: 2661:} /* parser_save_context */
        -: 2662:
        -: 2663:/**
        -: 2664: * Restore parser context after function parsing.
        -: 2665: */
        -: 2666:static void
        4: 2667:parser_restore_context (parser_context_t *context_p, /**< context */
        -: 2668:                        parser_saved_context_t *saved_context_p) /**< target for saving the context */
        -: 2669:{
        4: 2670:  parser_list_free (&context_p->literal_pool);
        -: 2671:
        4: 2672:  if (context_p->scope_stack_p != NULL)
        -: 2673:  {
        2: 2674:    parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));
        -: 2675:  }
        -: 2676:
        -: 2677:#if JERRY_LINE_INFO
        4: 2678:  parser_line_info_free (context_p->line_info_p);
        -: 2679:#endif /* JERRY_LINE_INFO */
        -: 2680:
        -: 2681:  /* Restore private part of the context. */
        -: 2682:
        4: 2683:  JERRY_ASSERT (context_p->last_cbc_opcode == PARSER_CBC_UNAVAILABLE);
        -: 2684:
        4: 2685:  context_p->status_flags = saved_context_p->status_flags;
        4: 2686:  context_p->stack_depth = saved_context_p->stack_depth;
        4: 2687:  context_p->stack_limit = saved_context_p->stack_limit;
        4: 2688:  context_p->last_context_p = saved_context_p->prev_context_p;
        4: 2689:  context_p->last_statement = saved_context_p->last_statement;
        -: 2690:
        4: 2691:  context_p->argument_count = saved_context_p->argument_count;
        -: 2692:#if JERRY_ESNEXT
        4: 2693:  context_p->argument_length = saved_context_p->argument_length;
        -: 2694:#endif /* JERRY_ESNEXT */
        4: 2695:  context_p->register_count = saved_context_p->register_count;
        4: 2696:  context_p->literal_count = saved_context_p->literal_count;
        -: 2697:
        4: 2698:  context_p->byte_code = saved_context_p->byte_code;
        4: 2699:  context_p->byte_code_size = saved_context_p->byte_code_size;
        4: 2700:  context_p->literal_pool.data = saved_context_p->literal_pool_data;
        4: 2701:  context_p->scope_stack_p = saved_context_p->scope_stack_p;
        4: 2702:  context_p->scope_stack_size = saved_context_p->scope_stack_size;
        4: 2703:  context_p->scope_stack_top = saved_context_p->scope_stack_top;
        4: 2704:  context_p->scope_stack_reg_top = saved_context_p->scope_stack_reg_top;
        -: 2705:#if JERRY_ESNEXT
        4: 2706:  context_p->scope_stack_global_end = saved_context_p->scope_stack_global_end;
        4: 2707:  context_p->tagged_template_literal_cp = saved_context_p->tagged_template_literal_cp;
        -: 2708:#endif /* JERRY_ESNEXT */
        -: 2709:
        -: 2710:#ifndef JERRY_NDEBUG
        4: 2711:  context_p->context_stack_depth = saved_context_p->context_stack_depth;
        -: 2712:#endif /* !JERRY_NDEBUG */
        -: 2713:
        -: 2714:#if JERRY_LINE_INFO
        4: 2715:  context_p->line_info_p = saved_context_p->line_info_p;
        -: 2716:#endif /* JERRY_LINE_INFO */
        4: 2717:} /* parser_restore_context */
        -: 2718:
        -: 2719:/**
        -: 2720: * Parse function code
        -: 2721: *
        -: 2722: * @return compiled code
        -: 2723: */
        -: 2724:ecma_compiled_code_t *
        4: 2725:parser_parse_function (parser_context_t *context_p, /**< context */
        -: 2726:                       uint32_t status_flags) /**< extra status flags */
        -: 2727:{
        4: 2728:  parser_saved_context_t saved_context;
        -: 2729:  ecma_compiled_code_t *compiled_code_p;
        -: 2730:
        4: 2731:  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);
        4: 2732:  parser_save_context (context_p, &saved_context);
        4: 2733:  context_p->status_flags |= status_flags;
        -: 2734:#if JERRY_ESNEXT
        4: 2735:  context_p->status_flags |= PARSER_ALLOW_NEW_TARGET;
        -: 2736:#endif /* JERRY_ESNEXT */
        -: 2737:
        -: 2738:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2739:  if (context_p->is_show_opcodes)
        -: 2740:  {
        -: 2741:#if JERRY_ESNEXT
        -: 2742:    JERRY_DEBUG_MSG ("\n--- %s parsing start ---\n\n",
        -: 2743:                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? "Class constructor" : "Function");
        -: 2744:#else /* !JERRY_ESNEXT */
        -: 2745:    JERRY_DEBUG_MSG ("\n--- Function parsing start ---\n\n");
        -: 2746:#endif /* JERRY_ESNEXT */
        -: 2747:  }
        -: 2748:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2749:
        -: 2750:#if JERRY_DEBUGGER
        -: 2751:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2752:  {
        -: 2753:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2754:  }
        -: 2755:#endif /* JERRY_DEBUGGER */
        -: 2756:
        4: 2757:  lexer_next_token (context_p);
        -: 2758:
        4: 2759:  if (context_p->token.type != LEXER_LEFT_PAREN)
        -: 2760:  {
    #####: 2761:    parser_raise_error (context_p, PARSER_ERR_ARGUMENT_LIST_EXPECTED);
        -: 2762:  }
        -: 2763:
        4: 2764:  lexer_next_token (context_p);
        -: 2765:
        4: 2766:  parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);
        4: 2767:  lexer_next_token (context_p);
        -: 2768:
        4: 2769:  if ((context_p->status_flags & PARSER_IS_PROPERTY_GETTER) && context_p->argument_count != 0)
        -: 2770:  {
    #####: 2771:    parser_raise_error (context_p, PARSER_ERR_NO_ARGUMENTS_EXPECTED);
        -: 2772:  }
        -: 2773:
        4: 2774:  if ((context_p->status_flags & PARSER_IS_PROPERTY_SETTER) && context_p->argument_count != 1)
        -: 2775:  {
    #####: 2776:    parser_raise_error (context_p, PARSER_ERR_ONE_ARGUMENT_EXPECTED);
        -: 2777:  }
        -: 2778:
        -: 2779:#if JERRY_ESNEXT
        4: 2780:  if ((context_p->status_flags & (PARSER_CLASS_CONSTRUCTOR | PARSER_ALLOW_SUPER_CALL)) == PARSER_CLASS_CONSTRUCTOR)
        -: 2781:  {
    #####: 2782:    parser_emit_cbc_ext (context_p, CBC_EXT_RUN_FIELD_INIT);
    #####: 2783:    parser_flush_cbc (context_p);
        -: 2784:  }
        -: 2785:#endif /* JERRY_ESNEXT */
        -: 2786:
        -: 2787:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2788:  if (context_p->is_show_opcodes && (context_p->status_flags & PARSER_HAS_NON_STRICT_ARG))
        -: 2789:  {
        -: 2790:    JERRY_DEBUG_MSG ("  Note: legacy (non-strict) argument definition\n\n");
        -: 2791:  }
        -: 2792:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2793:
        4: 2794:  if (context_p->token.type != LEXER_LEFT_BRACE)
        -: 2795:  {
    #####: 2796:    parser_raise_error (context_p, PARSER_ERR_LEFT_BRACE_EXPECTED);
        -: 2797:  }
        -: 2798:
        4: 2799:  lexer_next_token (context_p);
        4: 2800:  parser_parse_statements (context_p);
        4: 2801:  compiled_code_p = parser_post_processing (context_p);
        -: 2802:
        -: 2803:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2804:  if (context_p->is_show_opcodes)
        -: 2805:  {
        -: 2806:#if JERRY_ESNEXT
        -: 2807:    JERRY_DEBUG_MSG ("\n--- %s parsing end ---\n\n",
        -: 2808:                     (context_p->status_flags & PARSER_CLASS_CONSTRUCTOR) ? "Class constructor" : "Function");
        -: 2809:#else /* !JERRY_ESNEXT */
        -: 2810:    JERRY_DEBUG_MSG ("\n--- Function parsing end ---\n\n");
        -: 2811:#endif /* JERRY_ESNEXT */
        -: 2812:  }
        -: 2813:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2814:
        4: 2815:  parser_restore_context (context_p, &saved_context);
        -: 2816:
        4: 2817:  return compiled_code_p;
        -: 2818:} /* parser_parse_function */
        -: 2819:
        -: 2820:#if JERRY_ESNEXT
        -: 2821:
        -: 2822:/**
        -: 2823: * Parse static class block code
        -: 2824: *
        -: 2825: * @return compiled code
        -: 2826: */
        -: 2827:ecma_compiled_code_t *
    #####: 2828:parser_parse_class_static_block (parser_context_t *context_p) /**< context */
        -: 2829:{
    #####: 2830:  parser_saved_context_t saved_context;
        -: 2831:  ecma_compiled_code_t *compiled_code_p;
        -: 2832:
    #####: 2833:  parser_save_context (context_p, &saved_context);
    #####: 2834:  context_p->status_flags |= (PARSER_IS_CLASS_STATIC_BLOCK | PARSER_FUNCTION_CLOSURE | PARSER_ALLOW_SUPER
        -: 2835:                              | PARSER_INSIDE_CLASS_FIELD | PARSER_ALLOW_NEW_TARGET | PARSER_DISALLOW_AWAIT_YIELD);
        -: 2836:
        -: 2837:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2838:  if (context_p->is_show_opcodes)
        -: 2839:  {
        -: 2840:    JERRY_DEBUG_MSG ("\n--- Static class block parsing start ---\n\n");
        -: 2841:  }
        -: 2842:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2843:
    #####: 2844:  scanner_create_variables (context_p, SCANNER_CREATE_VARS_NO_OPTS);
    #####: 2845:  lexer_next_token (context_p);
        -: 2846:
    #####: 2847:  parser_parse_statements (context_p);
    #####: 2848:  compiled_code_p = parser_post_processing (context_p);
        -: 2849:
        -: 2850:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2851:  if (context_p->is_show_opcodes)
        -: 2852:  {
        -: 2853:    JERRY_DEBUG_MSG ("\n--- Static class block parsing end ---\n\n");
        -: 2854:  }
        -: 2855:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2856:
    #####: 2857:  parser_restore_context (context_p, &saved_context);
        -: 2858:
    #####: 2859:  return compiled_code_p;
        -: 2860:} /* parser_parse_class_static_block */
        -: 2861:
        -: 2862:/**
        -: 2863: * Parse arrow function code
        -: 2864: *
        -: 2865: * @return compiled code
        -: 2866: */
        -: 2867:ecma_compiled_code_t *
    #####: 2868:parser_parse_arrow_function (parser_context_t *context_p, /**< context */
        -: 2869:                             uint32_t status_flags) /**< extra status flags */
        -: 2870:{
    #####: 2871:  parser_saved_context_t saved_context;
        -: 2872:  ecma_compiled_code_t *compiled_code_p;
        -: 2873:
    #####: 2874:  JERRY_ASSERT (status_flags & PARSER_IS_FUNCTION);
    #####: 2875:  JERRY_ASSERT (status_flags & PARSER_IS_ARROW_FUNCTION);
    #####: 2876:  parser_save_context (context_p, &saved_context);
    #####: 2877:  context_p->status_flags |= status_flags;
    #####: 2878:  context_p->status_flags |=
    #####: 2879:    saved_context.status_flags & (PARSER_ALLOW_NEW_TARGET | PARSER_ALLOW_SUPER | PARSER_ALLOW_SUPER_CALL);
        -: 2880:
        -: 2881:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2882:  if (context_p->is_show_opcodes)
        -: 2883:  {
        -: 2884:    JERRY_DEBUG_MSG ("\n--- Arrow function parsing start ---\n\n");
        -: 2885:  }
        -: 2886:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2887:
        -: 2888:#if JERRY_DEBUGGER
        -: 2889:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2890:  {
        -: 2891:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 2892:  }
        -: 2893:#endif /* JERRY_DEBUGGER */
        -: 2894:
        -: 2895:  /* The `await` keyword is disallowed in the IdentifierReference position */
    #####: 2896:  if (status_flags & PARSER_IS_CLASS_STATIC_BLOCK)
        -: 2897:  {
    #####: 2898:    context_p->status_flags |= PARSER_DISALLOW_AWAIT_YIELD;
        -: 2899:  }
        -: 2900:
    #####: 2901:  if (context_p->token.type == LEXER_LEFT_PAREN)
        -: 2902:  {
    #####: 2903:    lexer_next_token (context_p);
    #####: 2904:    parser_parse_function_arguments (context_p, LEXER_RIGHT_PAREN);
    #####: 2905:    lexer_next_token (context_p);
        -: 2906:  }
        -: 2907:  else
        -: 2908:  {
    #####: 2909:    parser_parse_function_arguments (context_p, LEXER_ARROW);
        -: 2910:  }
        -: 2911:
        -: 2912:  /* The `await` keyword is interpreted as an identifier within the body of arrow functions */
    #####: 2913:  if (status_flags & PARSER_IS_CLASS_STATIC_BLOCK)
        -: 2914:  {
    #####: 2915:    context_p->status_flags &= (uint32_t) ~(PARSER_DISALLOW_AWAIT_YIELD | PARSER_IS_CLASS_STATIC_BLOCK);
        -: 2916:  }
        -: 2917:
    #####: 2918:  JERRY_ASSERT (context_p->token.type == LEXER_ARROW);
        -: 2919:
    #####: 2920:  lexer_next_token (context_p);
        -: 2921:
    #####: 2922:  if (context_p->token.type == LEXER_LEFT_BRACE)
        -: 2923:  {
    #####: 2924:    lexer_next_token (context_p);
        -: 2925:
    #####: 2926:    context_p->status_flags |= PARSER_IS_CLOSURE;
    #####: 2927:    parser_parse_statements (context_p);
        -: 2928:
        -: 2929:    /* Unlike normal function, arrow functions consume their close brace. */
    #####: 2930:    JERRY_ASSERT (context_p->token.type == LEXER_RIGHT_BRACE);
    #####: 2931:    lexer_next_token (context_p);
        -: 2932:  }
        -: 2933:  else
        -: 2934:  {
    #####: 2935:    if (context_p->status_flags & PARSER_IS_STRICT && context_p->status_flags & PARSER_HAS_NON_STRICT_ARG)
        -: 2936:    {
    #####: 2937:      parser_raise_error (context_p, PARSER_ERR_NON_STRICT_ARG_DEFINITION);
        -: 2938:    }
        -: 2939:
        -: 2940:#if JERRY_LINE_INFO
    #####: 2941:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 2942:#endif /* JERRY_LINE_INFO */
        -: 2943:
    #####: 2944:    parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 2945:
    #####: 2946:    if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 2947:    {
    #####: 2948:      context_p->last_cbc_opcode = CBC_RETURN_WITH_LITERAL;
        -: 2949:    }
        -: 2950:    else
        -: 2951:    {
    #####: 2952:      parser_emit_cbc (context_p, CBC_RETURN);
        -: 2953:    }
    #####: 2954:    parser_flush_cbc (context_p);
        -: 2955:
    #####: 2956:    lexer_update_await_yield (context_p, saved_context.status_flags);
        -: 2957:  }
        -: 2958:
    #####: 2959:  compiled_code_p = parser_post_processing (context_p);
        -: 2960:
        -: 2961:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2962:  if (context_p->is_show_opcodes)
        -: 2963:  {
        -: 2964:    JERRY_DEBUG_MSG ("\n--- Arrow function parsing end ---\n\n");
        -: 2965:  }
        -: 2966:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2967:
    #####: 2968:  parser_restore_context (context_p, &saved_context);
        -: 2969:
    #####: 2970:  return compiled_code_p;
        -: 2971:} /* parser_parse_arrow_function */
        -: 2972:
        -: 2973:/**
        -: 2974: * Parse class fields
        -: 2975: *
        -: 2976: * @return compiled code
        -: 2977: */
        -: 2978:ecma_compiled_code_t *
    #####: 2979:parser_parse_class_fields (parser_context_t *context_p) /**< context */
        -: 2980:{
    #####: 2981:  parser_saved_context_t saved_context;
        -: 2982:  ecma_compiled_code_t *compiled_code_p;
        -: 2983:
    #####: 2984:  uint32_t extra_status_flags = context_p->status_flags & PARSER_INSIDE_WITH;
        -: 2985:
    #####: 2986:  parser_save_context (context_p, &saved_context);
    #####: 2987:  context_p->status_flags |= (PARSER_IS_FUNCTION | PARSER_ALLOW_SUPER | PARSER_INSIDE_CLASS_FIELD
        -: 2988:                              | PARSER_ALLOW_NEW_TARGET | extra_status_flags);
        -: 2989:
        -: 2990:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 2991:  if (context_p->is_show_opcodes)
        -: 2992:  {
        -: 2993:    JERRY_DEBUG_MSG ("\n--- Class fields parsing start ---\n\n");
        -: 2994:  }
        -: 2995:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 2996:
        -: 2997:#if JERRY_DEBUGGER
        -: 2998:  if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2999:  {
        -: 3000:    jerry_debugger_send_parse_function (context_p->token.line, context_p->token.column);
        -: 3001:  }
        -: 3002:#endif /* JERRY_DEBUGGER */
        -: 3003:
    #####: 3004:  const uint8_t *source_end_p = context_p->source_end_p;
    #####: 3005:  bool first_computed_class_field = true;
    #####: 3006:  scanner_location_t end_location;
    #####: 3007:  scanner_get_location (&end_location, context_p);
        -: 3008:
        -: 3009:  do
        -: 3010:  {
    #####: 3011:    uint8_t class_field_type = context_p->stack_top_uint8;
    #####: 3012:    parser_stack_pop_uint8 (context_p);
        -: 3013:
    #####: 3014:    scanner_range_t range = { 0 };
        -: 3015:
    #####: 3016:    if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 3017:    {
    #####: 3018:      parser_stack_pop (context_p, &range, sizeof (scanner_range_t));
        -: 3019:    }
    #####: 3020:    else if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 3021:    {
    #####: 3022:      parser_stack_pop (context_p, &range.start_location, sizeof (scanner_location_t));
        -: 3023:    }
        -: 3024:
    #####: 3025:    uint16_t literal_index = 0;
    #####: 3026:    bool is_private = false;
        -: 3027:
    #####: 3028:    if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 3029:    {
    #####: 3030:      scanner_set_location (context_p, &range.start_location);
        -: 3031:
    #####: 3032:      if (class_field_type & PARSER_CLASS_FIELD_STATIC_BLOCK)
        -: 3033:      {
    #####: 3034:        scanner_seek (context_p);
    #####: 3035:        JERRY_ASSERT (context_p->source_p[1] == LIT_CHAR_LEFT_BRACE);
    #####: 3036:        context_p->source_p += 2;
    #####: 3037:        context_p->source_end_p = source_end_p;
        -: 3038:
    #####: 3039:        uint16_t func_index = lexer_construct_class_static_block_function (context_p);
        -: 3040:
    #####: 3041:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_CLASS_CALL_STATIC_BLOCK, func_index);
    #####: 3042:        continue;
        -: 3043:      }
        -: 3044:
    #####: 3045:      uint32_t ident_opts = LEXER_OBJ_IDENT_ONLY_IDENTIFIERS;
    #####: 3046:      is_private = context_p->source_p[-1] == LIT_CHAR_HASHMARK;
        -: 3047:
    #####: 3048:      if (is_private)
        -: 3049:      {
    #####: 3050:        ident_opts |= LEXER_OBJ_IDENT_CLASS_PRIVATE;
        -: 3051:      }
        -: 3052:
    #####: 3053:      context_p->source_end_p = source_end_p;
    #####: 3054:      scanner_seek (context_p);
        -: 3055:
    #####: 3056:      lexer_expect_object_literal_id (context_p, ident_opts);
        -: 3057:
    #####: 3058:      literal_index = context_p->lit_object.index;
        -: 3059:
    #####: 3060:      if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 3061:      {
    #####: 3062:        lexer_next_token (context_p);
    #####: 3063:        JERRY_ASSERT (context_p->token.type == LEXER_ASSIGN);
        -: 3064:      }
        -: 3065:    }
    #####: 3066:    else if (first_computed_class_field)
        -: 3067:    {
    #####: 3068:      parser_emit_cbc (context_p, CBC_PUSH_NUMBER_0);
    #####: 3069:      first_computed_class_field = false;
        -: 3070:    }
        -: 3071:
    #####: 3072:    if (class_field_type & PARSER_CLASS_FIELD_INITIALIZED)
        -: 3073:    {
    #####: 3074:      if (!(class_field_type & PARSER_CLASS_FIELD_NORMAL))
        -: 3075:      {
    #####: 3076:        scanner_set_location (context_p, &range.start_location);
    #####: 3077:        scanner_seek (context_p);
        -: 3078:      }
        -: 3079:
    #####: 3080:      context_p->source_end_p = range.source_end_p;
    #####: 3081:      lexer_next_token (context_p);
        -: 3082:
        -: 3083:#if JERRY_LINE_INFO
    #####: 3084:      parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3085:#endif /* JERRY_LINE_INFO */
        -: 3086:
    #####: 3087:      parser_parse_expression (context_p, PARSE_EXPR_NO_COMMA);
        -: 3088:
    #####: 3089:      if (context_p->token.type != LEXER_EOS)
        -: 3090:      {
    #####: 3091:        parser_raise_error (context_p, PARSER_ERR_SEMICOLON_EXPECTED);
        -: 3092:      }
        -: 3093:    }
        -: 3094:    else
        -: 3095:    {
    #####: 3096:      parser_emit_cbc (context_p, CBC_PUSH_UNDEFINED);
        -: 3097:    }
        -: 3098:
    #####: 3099:    if (class_field_type & PARSER_CLASS_FIELD_NORMAL)
        -: 3100:    {
    #####: 3101:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
        -: 3102:
    #####: 3103:      if (function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3104:      {
    #####: 3105:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_SET_CLASS_NAME, literal_index);
        -: 3106:      }
    #####: 3107:      else if (function_literal_index < PARSER_NAMED_FUNCTION)
        -: 3108:      {
    #####: 3109:        uint32_t function_name_status_flags = is_private ? PARSER_PRIVATE_FUNCTION_NAME : 0;
    #####: 3110:        parser_set_function_name (context_p, function_literal_index, literal_index, function_name_status_flags);
        -: 3111:      }
        -: 3112:
    #####: 3113:      if (is_private)
        -: 3114:      {
    #####: 3115:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_PRIVATE_FIELD_ADD, literal_index);
        -: 3116:      }
        -: 3117:      else
        -: 3118:      {
    #####: 3119:        parser_emit_cbc_ext_literal (context_p, CBC_EXT_DEFINE_FIELD, literal_index);
        -: 3120:      }
        -: 3121:
        -: 3122:      /* Prepare stack slot for assignment property reference base. Needed by vm.c */
    #####: 3123:      if (context_p->stack_limit == context_p->stack_depth)
        -: 3124:      {
    #####: 3125:        context_p->stack_limit++;
    #####: 3126:        JERRY_ASSERT (context_p->stack_limit <= PARSER_MAXIMUM_STACK_LIMIT);
        -: 3127:      }
        -: 3128:    }
        -: 3129:    else
        -: 3130:    {
    #####: 3131:      uint16_t function_literal_index = parser_check_anonymous_function_declaration (context_p);
    #####: 3132:      uint16_t opcode = CBC_EXT_SET_NEXT_COMPUTED_FIELD;
        -: 3133:
    #####: 3134:      if (function_literal_index < PARSER_NAMED_FUNCTION || function_literal_index == PARSER_ANONYMOUS_CLASS)
        -: 3135:      {
    #####: 3136:        opcode = CBC_EXT_SET_NEXT_COMPUTED_FIELD_ANONYMOUS_FUNC;
        -: 3137:      }
        -: 3138:
    #####: 3139:      parser_flush_cbc (context_p);
        -: 3140:
        -: 3141:      /* The next opcode pushes two more temporary values onto the stack */
    #####: 3142:      if (context_p->stack_depth + 1 > context_p->stack_limit)
        -: 3143:      {
    #####: 3144:        context_p->stack_limit = (uint16_t) (context_p->stack_depth + 1);
    #####: 3145:        if (context_p->stack_limit > PARSER_MAXIMUM_STACK_LIMIT)
        -: 3146:        {
    #####: 3147:          parser_raise_error (context_p, PARSER_ERR_STACK_LIMIT_REACHED);
        -: 3148:        }
        -: 3149:      }
        -: 3150:
    #####: 3151:      parser_emit_cbc_ext (context_p, opcode);
        -: 3152:    }
    #####: 3153:  } while (!(context_p->stack_top_uint8 & PARSER_CLASS_FIELD_END));
        -: 3154:
    #####: 3155:  if (!first_computed_class_field)
        -: 3156:  {
    #####: 3157:    parser_emit_cbc (context_p, CBC_POP);
        -: 3158:  }
        -: 3159:
    #####: 3160:  parser_flush_cbc (context_p);
    #####: 3161:  context_p->source_end_p = source_end_p;
    #####: 3162:  scanner_set_location (context_p, &end_location);
        -: 3163:
        -: 3164:#if JERRY_LINE_INFO
    #####: 3165:  if (context_p->line_info_p == NULL)
        -: 3166:  {
    #####: 3167:    parser_line_info_append (context_p, context_p->token.line, context_p->token.column);
        -: 3168:  }
        -: 3169:#endif /* JERRY_LINE_INFO */
        -: 3170:
    #####: 3171:  compiled_code_p = parser_post_processing (context_p);
        -: 3172:
        -: 3173:#if JERRY_PARSER_DUMP_BYTE_CODE
        -: 3174:  if (context_p->is_show_opcodes)
        -: 3175:  {
        -: 3176:    JERRY_DEBUG_MSG ("\n--- Class fields parsing end ---\n\n");
        -: 3177:  }
        -: 3178:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -: 3179:
    #####: 3180:  parser_restore_context (context_p, &saved_context);
        -: 3181:
    #####: 3182:  return compiled_code_p;
        -: 3183:} /* parser_parse_class_fields */
        -: 3184:
        -: 3185:/**
        -: 3186: * Check whether the last emitted cbc opcode was an anonymous function declaration
        -: 3187: *
        -: 3188: * @return PARSER_NOT_FUNCTION_LITERAL - if the last opcode is not a function literal
        -: 3189: *         PARSER_NAMED_FUNCTION - if the last opcode is not a named function declataion
        -: 3190: *         PARSER_ANONYMOUS_CLASS - if the last opcode is an anonymous class declaration
        -: 3191: *         literal index of the anonymous function literal - otherwise
        -: 3192: */
        -: 3193:uint16_t
        4: 3194:parser_check_anonymous_function_declaration (parser_context_t *context_p) /**< context */
        -: 3195:{
        4: 3196:  if (context_p->last_cbc_opcode == PARSER_TO_EXT_OPCODE (CBC_EXT_FINALIZE_ANONYMOUS_CLASS))
        -: 3197:  {
    #####: 3198:    return PARSER_ANONYMOUS_CLASS;
        -: 3199:  }
        -: 3200:
        4: 3201:  if (context_p->last_cbc.literal_type != LEXER_FUNCTION_LITERAL)
        -: 3202:  {
        4: 3203:    return PARSER_NOT_FUNCTION_LITERAL;
        -: 3204:  }
        -: 3205:
    #####: 3206:  uint16_t literal_index = PARSER_NOT_FUNCTION_LITERAL;
        -: 3207:
    #####: 3208:  if (context_p->last_cbc_opcode == CBC_PUSH_LITERAL)
        -: 3209:  {
    #####: 3210:    literal_index = context_p->last_cbc.literal_index;
        -: 3211:  }
    #####: 3212:  else if (context_p->last_cbc_opcode == CBC_PUSH_TWO_LITERALS)
        -: 3213:  {
    #####: 3214:    literal_index = context_p->last_cbc.value;
        -: 3215:  }
    #####: 3216:  else if (context_p->last_cbc_opcode == CBC_PUSH_THREE_LITERALS)
        -: 3217:  {
    #####: 3218:    literal_index = context_p->last_cbc.third_literal_index;
        -: 3219:  }
        -: 3220:  else
        -: 3221:  {
    #####: 3222:    return PARSER_NOT_FUNCTION_LITERAL;
        -: 3223:  }
        -: 3224:
        -: 3225:  const ecma_compiled_code_t *bytecode_p;
    #####: 3226:  bytecode_p = (const ecma_compiled_code_t *) (PARSER_GET_LITERAL (literal_index)->u.bytecode_p);
    #####: 3227:  bool is_anon =
    #####: 3228:    ecma_is_value_magic_string (*ecma_compiled_code_resolve_function_name (bytecode_p), LIT_MAGIC_STRING__EMPTY);
        -: 3229:
    #####: 3230:  return (is_anon ? literal_index : PARSER_NAMED_FUNCTION);
        -: 3231:} /* parser_check_anonymous_function_declaration */
        -: 3232:
        -: 3233:/**
        -: 3234: * Set the function name of the function literal corresponds to the given function literal index
        -: 3235: * to the given character buffer of literal corresponds to the given name index.
        -: 3236: */
        -: 3237:void
        2: 3238:parser_set_function_name (parser_context_t *context_p, /**< context */
        -: 3239:                          uint16_t function_literal_index, /**< function literal index */
        -: 3240:                          uint16_t name_index, /**< function name literal index */
        -: 3241:                          uint32_t status_flags) /**< status flags */
        -: 3242:{
        -: 3243:  ecma_compiled_code_t *bytecode_p;
        2: 3244:  bytecode_p = (ecma_compiled_code_t *) (PARSER_GET_LITERAL (function_literal_index)->u.bytecode_p);
        -: 3245:
        2: 3246:  parser_compiled_code_set_function_name (context_p, bytecode_p, name_index, status_flags);
        2: 3247:} /* parser_set_function_name */
        -: 3248:
        -: 3249:/**
        -: 3250: * Prepend the given prefix into the current function name literal
        -: 3251: *
        -: 3252: * @return pointer to the newly allocated buffer
        -: 3253: */
        -: 3254:static uint8_t *
        1: 3255:parser_add_function_name_prefix (parser_context_t *context_p, /**< context */
        -: 3256:                                 const char *prefix_p, /**< prefix */
        -: 3257:                                 uint32_t prefix_size, /**< prefix's length */
        -: 3258:                                 uint32_t *name_length_p, /**< [out] function name's size */
        -: 3259:                                 lexer_literal_t *name_lit_p) /**< function name literal */
        -: 3260:{
        1: 3261:  *name_length_p += prefix_size;
        1: 3262:  uint8_t *name_buffer_p = (uint8_t *) parser_malloc (context_p, *name_length_p * sizeof (uint8_t));
        1: 3263:  memcpy (name_buffer_p, prefix_p, prefix_size);
        1: 3264:  memcpy (name_buffer_p + prefix_size, name_lit_p->u.char_p, name_lit_p->prop.length);
        -: 3265:
        1: 3266:  return name_buffer_p;
        -: 3267:} /* parser_add_function_name_prefix */
        -: 3268:
        -: 3269:/**
        -: 3270: * Set the function name of the given compiled code
        -: 3271: * to the given character buffer of literal corresponds to the given name index.
        -: 3272: */
        -: 3273:void
        3: 3274:parser_compiled_code_set_function_name (parser_context_t *context_p, /**< context */
        -: 3275:                                        ecma_compiled_code_t *bytecode_p, /**< function literal index */
        -: 3276:                                        uint16_t name_index, /**< function name literal index */
        -: 3277:                                        uint32_t status_flags) /**< status flags */
        -: 3278:{
        -: 3279:  ecma_value_t *func_name_start_p;
        3: 3280:  func_name_start_p = ecma_compiled_code_resolve_function_name ((const ecma_compiled_code_t *) bytecode_p);
        -: 3281:
        3: 3282:  if (JERRY_UNLIKELY (!ecma_is_value_magic_string (*func_name_start_p, LIT_MAGIC_STRING__EMPTY)))
        -: 3283:  {
    #####: 3284:    return;
        -: 3285:  }
        -: 3286:
        3: 3287:  parser_scope_stack_t *scope_stack_start_p = context_p->scope_stack_p;
        3: 3288:  parser_scope_stack_t *scope_stack_p = scope_stack_start_p + context_p->scope_stack_top;
        -: 3289:
       17: 3290:  while (scope_stack_p > scope_stack_start_p)
        -: 3291:  {
       11: 3292:    scope_stack_p--;
        -: 3293:
       11: 3294:    if (scope_stack_p->map_from != PARSER_SCOPE_STACK_FUNC && scanner_decode_map_to (scope_stack_p) == name_index)
        -: 3295:    {
    #####: 3296:      name_index = scope_stack_p->map_from;
    #####: 3297:      break;
        -: 3298:    }
        -: 3299:  }
        -: 3300:
        3: 3301:  lexer_literal_t *name_lit_p = (lexer_literal_t *) PARSER_GET_LITERAL (name_index);
        -: 3302:
        3: 3303:  if (name_lit_p->type != LEXER_IDENT_LITERAL && name_lit_p->type != LEXER_STRING_LITERAL)
        -: 3304:  {
    #####: 3305:    return;
        -: 3306:  }
        -: 3307:
        3: 3308:  uint8_t *name_buffer_p = (uint8_t *) name_lit_p->u.char_p;
        3: 3309:  uint32_t name_length = name_lit_p->prop.length;
        -: 3310:
        3: 3311:  if (status_flags & PARSER_PRIVATE_FUNCTION_NAME)
        -: 3312:  {
        1: 3313:    name_buffer_p = parser_add_function_name_prefix (context_p, "#", 1, &name_length, name_lit_p);
        -: 3314:  }
        2: 3315:  else if (status_flags & (PARSER_IS_PROPERTY_GETTER | PARSER_IS_PROPERTY_SETTER))
        -: 3316:  {
    #####: 3317:    name_buffer_p = parser_add_function_name_prefix (context_p,
    #####: 3318:                                                     (status_flags & PARSER_IS_PROPERTY_GETTER) ? "get " : "set ",
        -: 3319:                                                     4,
        -: 3320:                                                     &name_length,
        -: 3321:                                                     name_lit_p);
        -: 3322:  }
        -: 3323:
        3: 3324:  *func_name_start_p =
        3: 3325:    ecma_find_or_create_literal_string (name_buffer_p, name_length, (status_flags & LEXER_FLAG_ASCII) != 0);
        -: 3326:
        3: 3327:  if (name_buffer_p != name_lit_p->u.char_p)
        -: 3328:  {
        1: 3329:    parser_free (name_buffer_p, name_length);
        -: 3330:  }
        -: 3331:} /* parser_compiled_code_set_function_name */
        -: 3332:
        -: 3333:#endif /* JERRY_ESNEXT */
        -: 3334:
        -: 3335:/**
        -: 3336: * Raise a parse error.
        -: 3337: */
        -: 3338:void
    #####: 3339:parser_raise_error (parser_context_t *context_p, /**< context */
        -: 3340:                    parser_error_msg_t error) /**< error code */
        -: 3341:{
        -: 3342:  /* Must be compatible with the scanner because
        -: 3343:   * the lexer might throws errors during prescanning. */
    #####: 3344:  parser_saved_context_t *saved_context_p = context_p->last_context_p;
        -: 3345:
    #####: 3346:  while (saved_context_p != NULL)
        -: 3347:  {
    #####: 3348:    parser_cbc_stream_free (&saved_context_p->byte_code);
        -: 3349:
        -: 3350:    /* First the current literal pool is freed, and then it is replaced
        -: 3351:     * by the literal pool coming from the saved context. Since literals
        -: 3352:     * are not used anymore, this is a valid replacement. The last pool
        -: 3353:     * is freed by parser_parse_source. */
        -: 3354:
    #####: 3355:    parser_free_literals (&context_p->literal_pool);
    #####: 3356:    context_p->literal_pool.data = saved_context_p->literal_pool_data;
        -: 3357:
    #####: 3358:    if (context_p->scope_stack_p != NULL)
        -: 3359:    {
    #####: 3360:      parser_free (context_p->scope_stack_p, context_p->scope_stack_size * sizeof (parser_scope_stack_t));
        -: 3361:    }
    #####: 3362:    context_p->scope_stack_p = saved_context_p->scope_stack_p;
    #####: 3363:    context_p->scope_stack_size = saved_context_p->scope_stack_size;
        -: 3364:
    #####: 3365:    if (saved_context_p->last_statement.current_p != NULL)
        -: 3366:    {
    #####: 3367:      parser_free_jumps (saved_context_p->last_statement);
        -: 3368:    }
        -: 3369:
        -: 3370:#if JERRY_ESNEXT
    #####: 3371:    if (saved_context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 3372:    {
    #####: 3373:      ecma_collection_t *collection =
    #####: 3374:        ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, saved_context_p->tagged_template_literal_cp);
    #####: 3375:      ecma_collection_free_template_literal (collection);
        -: 3376:    }
        -: 3377:#endif /* JERRY_ESNEXT  */
        -: 3378:
        -: 3379:#if JERRY_LINE_INFO
    #####: 3380:    parser_line_info_free (saved_context_p->line_info_p);
        -: 3381:#endif /* JERRY_LINE_INFO */
        -: 3382:
    #####: 3383:    saved_context_p = saved_context_p->prev_context_p;
        -: 3384:  }
        -: 3385:
        -: 3386:#if JERRY_ESNEXT
    #####: 3387:  parser_free_private_fields (context_p);
        -: 3388:
    #####: 3389:  if (context_p->tagged_template_literal_cp != JMEM_CP_NULL)
        -: 3390:  {
    #####: 3391:    ecma_collection_t *collection =
    #####: 3392:      ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, context_p->tagged_template_literal_cp);
    #####: 3393:    ecma_collection_free_template_literal (collection);
        -: 3394:  }
        -: 3395:#endif /* JERRY_ESNEXT  */
        -: 3396:
    #####: 3397:  context_p->error = error;
    #####: 3398:  PARSER_THROW (context_p->try_buffer);
        -: 3399:  /* Should never been reached. */
        -: 3400:  JERRY_ASSERT (0);
        -: 3401:} /* parser_raise_error */
        -: 3402:
        -: 3403:#endif /* JERRY_PARSER */
        -: 3404:
        -: 3405:/**
        -: 3406: * Parse EcmaScript source code
        -: 3407: *
        -: 3408: * Note:
        -: 3409: *      if arg_list_p is not NULL, a function body is parsed
        -: 3410: *      returned value must be freed with ecma_free_value
        -: 3411: *
        -: 3412: * @return pointer to compiled byte code - if success
        -: 3413: *         NULL - otherwise
        -: 3414: */
        -: 3415:ecma_compiled_code_t *
        1: 3416:parser_parse_script (void *source_p, /**< source code */
        -: 3417:                     uint32_t parse_opts, /**< ecma_parse_opts_t option bits */
        -: 3418:                     const jerry_parse_options_t *options_p) /**< additional configuration options */
        -: 3419:{
        -: 3420:#if JERRY_PARSER
        1: 3421:  ecma_compiled_code_t *bytecode_p = parser_parse_source (source_p, parse_opts, options_p);
        -: 3422:
        1: 3423:  if (JERRY_UNLIKELY (bytecode_p == NULL))
        -: 3424:  {
        -: 3425:    /* Exception has already thrown. */
    #####: 3426:    return NULL;
        -: 3427:  }
        -: 3428:
        -: 3429:#if JERRY_DEBUGGER
        -: 3430:  if ((JERRY_CONTEXT (debugger_flags) & (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))
        -: 3431:      == (JERRY_DEBUGGER_CONNECTED | JERRY_DEBUGGER_PARSER_WAIT))
        -: 3432:  {
        -: 3433:    JERRY_DEBUGGER_SET_FLAGS (JERRY_DEBUGGER_PARSER_WAIT_MODE);
        -: 3434:    jerry_debugger_send_type (JERRY_DEBUGGER_WAITING_AFTER_PARSE);
        -: 3435:
        -: 3436:    while (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_PARSER_WAIT_MODE)
        -: 3437:    {
        -: 3438:      jerry_debugger_receive (NULL);
        -: 3439:
        -: 3440:      if (!(JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED))
        -: 3441:      {
        -: 3442:        break;
        -: 3443:      }
        -: 3444:
        -: 3445:      jerry_debugger_transport_sleep ();
        -: 3446:    }
        -: 3447:  }
        -: 3448:#endif /* JERRY_DEBUGGER */
        -: 3449:
        1: 3450:  return bytecode_p;
        -: 3451:#else /* !JERRY_PARSER */
        -: 3452:  JERRY_UNUSED (arg_list_p);
        -: 3453:  JERRY_UNUSED (arg_list_size);
        -: 3454:  JERRY_UNUSED (source_p);
        -: 3455:  JERRY_UNUSED (source_size);
        -: 3456:  JERRY_UNUSED (parse_opts);
        -: 3457:  JERRY_UNUSED (source_name);
        -: 3458:
        -: 3459:  ecma_raise_syntax_error (ECMA_ERR_PARSER_NOT_SUPPORTED);
        -: 3460:  return NULL;
        -: 3461:#endif /* JERRY_PARSER */
        -: 3462:} /* parser_parse_script */
        -: 3463:
        -: 3464:/**
        -: 3465: * @}
        -: 3466: * @}
        -: 3467: * @}
        -: 3468: */
