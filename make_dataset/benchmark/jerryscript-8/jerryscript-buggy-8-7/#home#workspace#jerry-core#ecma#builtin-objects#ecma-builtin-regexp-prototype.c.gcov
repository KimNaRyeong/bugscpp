        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-regexp-prototype.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtin-helpers.h"
        -:   19:#include "ecma-builtins.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-objects.h"
        -:   27:#include "ecma-regexp-object.h"
        -:   28:
        -:   29:#include "lit-char-helpers.h"
        -:   30:
        -:   31:#if JERRY_BUILTIN_REGEXP
        -:   32:#include "ecma-regexp-object.h"
        -:   33:
        -:   34:#include "re-compiler.h"
        -:   35:
        -:   36:#define ECMA_BUILTINS_INTERNAL
        -:   37:#include "ecma-builtins-internal.h"
        -:   38:
        -:   39:/**
        -:   40: * This object has a custom dispatch function.
        -:   41: */
        -:   42:#define BUILTIN_CUSTOM_DISPATCH
        -:   43:
        -:   44:/**
        -:   45: * List of built-in routine identifiers.
        -:   46: */
        -:   47:enum
        -:   48:{
        -:   49:  /** These routines must be in this order */
        -:   50:  ECMA_REGEXP_PROTOTYPE_ROUTINE_START = 0,
        -:   51:  ECMA_REGEXP_PROTOTYPE_ROUTINE_EXEC,
        -:   52:#if JERRY_BUILTIN_ANNEXB
        -:   53:  ECMA_REGEXP_PROTOTYPE_ROUTINE_COMPILE,
        -:   54:#endif /* JERRY_BUILTIN_ANNEXB */
        -:   55:
        -:   56:  ECMA_REGEXP_PROTOTYPE_ROUTINE_TEST,
        -:   57:  ECMA_REGEXP_PROTOTYPE_ROUTINE_TO_STRING,
        -:   58:#if JERRY_ESNEXT
        -:   59:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_SOURCE,
        -:   60:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_FLAGS,
        -:   61:
        -:   62:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_GLOBAL,
        -:   63:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_IGNORE_CASE,
        -:   64:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_MULTILINE,
        -:   65:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_STICKY,
        -:   66:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_UNICODE,
        -:   67:  ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_DOT_ALL,
        -:   68:
        -:   69:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_SEARCH,
        -:   70:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_MATCH,
        -:   71:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_REPLACE,
        -:   72:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_SPLIT,
        -:   73:  ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_MATCH_ALL,
        -:   74:#endif /* JERRY_ESNEXT */
        -:   75:};
        -:   76:
        -:   77:#define BUILTIN_INC_HEADER_NAME "ecma-builtin-regexp-prototype.inc.h"
        -:   78:#define BUILTIN_UNDERSCORED_ID  regexp_prototype
        -:   79:#include "ecma-builtin-internal-routines-template.inc.h"
        -:   80:
        -:   81:/** \addtogroup ecma ECMA
        -:   82: * @{
        -:   83: *
        -:   84: * \addtogroup ecmabuiltins
        -:   85: * @{
        -:   86: *
        -:   87: * \addtogroup regexpprototype ECMA RegExp.prototype object built-in
        -:   88: * @{
        -:   89: */
        -:   90:
        -:   91:#if JERRY_ESNEXT
        -:   92:/**
        -:   93: * Helper function to retrieve the flags associated with a RegExp object
        -:   94: *
        -:   95: * @return ECMA_VALUE_{TRUE,FALSE} depends on whether the given flag is present.
        -:   96: */
        -:   97:static ecma_value_t
    #####:   98:ecma_builtin_regexp_prototype_flags_helper (ecma_extended_object_t *re_obj_p, /**< this object */
        -:   99:                                            uint16_t builtin_routine_id) /**< id of the flag */
        -:  100:{
    #####:  101:  re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
        -:  102:
    #####:  103:  uint16_t flags = bc_p->header.status_flags;
        -:  104:
        -:  105:  static const uint8_t re_flags[] = {
        -:  106:    RE_FLAG_GLOBAL, RE_FLAG_IGNORE_CASE, RE_FLAG_MULTILINE, RE_FLAG_STICKY, RE_FLAG_UNICODE, RE_FLAG_DOTALL,
        -:  107:  };
        -:  108:
    #####:  109:  uint16_t offset = (uint16_t) (builtin_routine_id - ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_GLOBAL);
    #####:  110:  return ecma_make_boolean_value ((flags & re_flags[offset]) != 0);
        -:  111:} /* ecma_builtin_regexp_prototype_flags_helper */
        -:  112:
        -:  113:/**
        -:  114: * The RegExp.prototype object's 'flags' accessor property
        -:  115: *
        -:  116: * See also:
        -:  117: *          ECMA-262 v6, 21.2.5.3
        -:  118: *
        -:  119: * @return ECMA_VALUE_ERROR - if 'this' is not a RegExp object
        -:  120: *         string value     - otherwise
        -:  121: *
        -:  122: *         Returned value must be freed with ecma_free_value.
        -:  123: */
        -:  124:static ecma_value_t
    #####:  125:ecma_builtin_regexp_prototype_get_flags (ecma_object_t *object_p) /**< this object */
        -:  126:{
        -:  127:  static const lit_magic_string_id_t flag_lit_ids[] = { LIT_MAGIC_STRING_GLOBAL,    LIT_MAGIC_STRING_IGNORECASE_UL,
        -:  128:                                                        LIT_MAGIC_STRING_MULTILINE, LIT_MAGIC_STRING_DOTALL,
        -:  129:                                                        LIT_MAGIC_STRING_UNICODE,   LIT_MAGIC_STRING_STICKY };
        -:  130:
        -:  131:  static const lit_utf8_byte_t flag_chars[] = { LIT_CHAR_LOWERCASE_G, LIT_CHAR_LOWERCASE_I, LIT_CHAR_LOWERCASE_M,
        -:  132:                                                LIT_CHAR_LOWERCASE_S, LIT_CHAR_LOWERCASE_U, LIT_CHAR_LOWERCASE_Y };
        -:  133:
    #####:  134:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
    #####:  135:  for (uint32_t i = 0; i < sizeof (flag_lit_ids) / sizeof (lit_magic_string_id_t); i++)
        -:  136:  {
    #####:  137:    ecma_value_t result = ecma_op_object_get_by_magic_id (object_p, flag_lit_ids[i]);
    #####:  138:    if (ECMA_IS_VALUE_ERROR (result))
        -:  139:    {
    #####:  140:      ecma_stringbuilder_destroy (&builder);
    #####:  141:      return result;
        -:  142:    }
        -:  143:
    #####:  144:    if (ecma_op_to_boolean (result))
        -:  145:    {
    #####:  146:      ecma_stringbuilder_append_byte (&builder, flag_chars[i]);
        -:  147:    }
        -:  148:
    #####:  149:    ecma_free_value (result);
        -:  150:  }
        -:  151:
    #####:  152:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  153:} /* ecma_builtin_regexp_prototype_get_flags */
        -:  154:
        -:  155:/**
        -:  156: * The EscapeRegExpPattern method.
        -:  157: *
        -:  158: * See also:
        -:  159: *          ECMA-262 v6, 21.2.3.2.4
        -:  160: *
        -:  161: * @return ecma_value_t
        -:  162: */
        -:  163:static ecma_value_t
    #####:  164:ecma_op_escape_regexp_pattern (ecma_string_t *pattern_str_p) /**< RegExp pattern */
        -:  165:{
    #####:  166:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  167:
    #####:  168:  ECMA_STRING_TO_UTF8_STRING (pattern_str_p, pattern_start_p, pattern_start_size);
        -:  169:
    #####:  170:  const lit_utf8_byte_t *pattern_str_curr_p = pattern_start_p;
    #####:  171:  const lit_utf8_byte_t *pattern_str_end_p = pattern_start_p + pattern_start_size;
        -:  172:
    #####:  173:  while (pattern_str_curr_p < pattern_str_end_p)
        -:  174:  {
    #####:  175:    ecma_char_t c = lit_cesu8_read_next (&pattern_str_curr_p);
        -:  176:
    #####:  177:    switch (c)
        -:  178:    {
    #####:  179:      case LIT_CHAR_SLASH:
        -:  180:      {
    #####:  181:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\/", 2);
    #####:  182:        break;
        -:  183:      }
    #####:  184:      case LIT_CHAR_LF:
        -:  185:      {
    #####:  186:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\n", 2);
    #####:  187:        break;
        -:  188:      }
    #####:  189:      case LIT_CHAR_CR:
        -:  190:      {
    #####:  191:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\r", 2);
    #####:  192:        break;
        -:  193:      }
    #####:  194:      case LIT_CHAR_LS:
        -:  195:      {
    #####:  196:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\u2028", 6);
    #####:  197:        break;
        -:  198:      }
    #####:  199:      case LIT_CHAR_PS:
        -:  200:      {
    #####:  201:        ecma_stringbuilder_append_raw (&builder, (const lit_utf8_byte_t *) "\\u2029", 6);
    #####:  202:        break;
        -:  203:      }
    #####:  204:      case LIT_CHAR_BACKSLASH:
        -:  205:      {
    #####:  206:        JERRY_ASSERT (pattern_str_curr_p < pattern_str_end_p);
    #####:  207:        ecma_stringbuilder_append_char (&builder, LIT_CHAR_BACKSLASH);
    #####:  208:        ecma_stringbuilder_append_char (&builder, lit_cesu8_read_next (&pattern_str_curr_p));
    #####:  209:        break;
        -:  210:      }
    #####:  211:      default:
        -:  212:      {
    #####:  213:        ecma_stringbuilder_append_char (&builder, c);
    #####:  214:        break;
        -:  215:      }
        -:  216:    }
        -:  217:  }
        -:  218:
    #####:  219:  ECMA_FINALIZE_UTF8_STRING (pattern_start_p, pattern_start_size);
        -:  220:
    #####:  221:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  222:} /* ecma_op_escape_regexp_pattern */
        -:  223:
        -:  224:/**
        -:  225: * The RegExp.prototype object's 'source' accessor property
        -:  226: *
        -:  227: * See also:
        -:  228: *          ECMA-262 v6, 21.2.5.10
        -:  229: *
        -:  230: * @return ECMA_VALUE_ERROR - if 'this' is not a RegExp object
        -:  231: *         string value     - otherwise
        -:  232: *
        -:  233: *         Returned value must be freed with ecma_free_value.
        -:  234: */
        -:  235:static ecma_value_t
    #####:  236:ecma_builtin_regexp_prototype_get_source (ecma_extended_object_t *re_obj_p) /**< this argument */
        -:  237:{
    #####:  238:  re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
        -:  239:
    #####:  240:  return ecma_op_escape_regexp_pattern (ecma_get_string_from_value (bc_p->source));
        -:  241:} /* ecma_builtin_regexp_prototype_get_source */
        -:  242:#endif /* JERRY_ESNEXT */
        -:  243:
        -:  244:#if JERRY_BUILTIN_ANNEXB
        -:  245:/**
        -:  246: * The RegExp.prototype object's 'compile' routine
        -:  247: *
        -:  248: * See also:
        -:  249: *          ECMA-262 v11, B.2.5.1
        -:  250: *
        -:  251: * @return undefined        - if compiled successfully
        -:  252: *         error ecma value - otherwise
        -:  253: *
        -:  254: *         Returned value must be freed with ecma_free_value.
        -:  255: */
        -:  256:static ecma_value_t
    #####:  257:ecma_builtin_regexp_prototype_compile (ecma_value_t this_arg, /**< this */
        -:  258:                                       ecma_value_t pattern_arg, /**< pattern or RegExp object */
        -:  259:                                       ecma_value_t flags_arg) /**< flags */
        -:  260:{
        -:  261:#if !JERRY_ESNEXT
    #####:  262:  if (ecma_get_object_from_value (this_arg) == ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE))
        -:  263:  {
    #####:  264:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_IS_NOT_AN_REGEXP);
        -:  265:  }
        -:  266:#endif /* !JERRY_ESNEXT */
        -:  267:
    #####:  268:  ecma_object_t *this_obj_p = ecma_get_object_from_value (this_arg);
    #####:  269:  ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) this_obj_p;
    #####:  270:  re_compiled_code_t *old_bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
        -:  271:
        -:  272:  ecma_value_t ret_value;
        -:  273:
    #####:  274:  if (ecma_object_is_regexp_object (pattern_arg))
        -:  275:  {
    #####:  276:    if (!ecma_is_value_undefined (flags_arg))
        -:  277:    {
    #####:  278:      return ecma_raise_type_error (ECMA_ERR_INVALID_ARGUMENT);
        -:  279:    }
        -:  280:
    #####:  281:    ecma_extended_object_t *pattern_obj_p = (ecma_extended_object_t *) ecma_get_object_from_value (pattern_arg);
    #####:  282:    re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, pattern_obj_p->u.cls.u3.value);
        -:  283:
    #####:  284:    ret_value = ecma_op_create_regexp_from_bytecode (this_obj_p, bc_p);
        -:  285:  }
        -:  286:  else
        -:  287:  {
    #####:  288:    ret_value = ecma_op_create_regexp_from_pattern (this_obj_p, pattern_arg, flags_arg);
        -:  289:  }
        -:  290:
    #####:  291:  if (!ECMA_IS_VALUE_ERROR (ret_value))
        -:  292:  {
    #####:  293:    ecma_value_t status = ecma_builtin_helper_def_prop (this_obj_p,
        -:  294:                                                        ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL),
        -:  295:                                                        ecma_make_uint32_value (0),
        -:  296:                                                        ECMA_PROPERTY_FLAG_WRITABLE | JERRY_PROP_SHOULD_THROW);
        -:  297:
    #####:  298:    ecma_bytecode_deref ((ecma_compiled_code_t *) old_bc_p);
        -:  299:
    #####:  300:    if (ECMA_IS_VALUE_ERROR (status))
        -:  301:    {
    #####:  302:      return status;
        -:  303:    }
        -:  304:
    #####:  305:    ecma_ref_object (this_obj_p);
        -:  306:  }
        -:  307:
    #####:  308:  return ret_value;
        -:  309:} /* ecma_builtin_regexp_prototype_compile */
        -:  310:
        -:  311:#endif /* JERRY_BUILTIN_ANNEXB */
        -:  312:
        -:  313:/**
        -:  314: * The RegExp.prototype object's 'exec' routine
        -:  315: *
        -:  316: * See also:
        -:  317: *          ECMA-262 v5, 15.10.6.2
        -:  318: *
        -:  319: * @return array object containing the results - if the matched
        -:  320: *         null                                - otherwise
        -:  321: *
        -:  322: *         May raise error, so returned value must be freed with ecma_free_value.
        -:  323: */
        -:  324:static ecma_value_t
    #####:  325:ecma_builtin_regexp_prototype_exec (ecma_value_t this_arg, /**< this argument */
        -:  326:                                    ecma_value_t arg) /**< routine's argument */
        -:  327:{
    #####:  328:  ecma_value_t obj_this = ecma_op_to_object (this_arg);
    #####:  329:  if (ECMA_IS_VALUE_ERROR (obj_this))
        -:  330:  {
    #####:  331:    return obj_this;
        -:  332:  }
        -:  333:
    #####:  334:  ecma_string_t *input_str_p = ecma_op_to_string (arg);
    #####:  335:  if (JERRY_UNLIKELY (input_str_p == NULL))
        -:  336:  {
    #####:  337:    ecma_free_value (obj_this);
    #####:  338:    return ECMA_VALUE_ERROR;
        -:  339:  }
        -:  340:
    #####:  341:  ecma_value_t ret_value = ecma_regexp_exec_helper (ecma_get_object_from_value (obj_this), input_str_p);
        -:  342:
    #####:  343:  ecma_free_value (obj_this);
    #####:  344:  ecma_deref_ecma_string (input_str_p);
        -:  345:
    #####:  346:  return ret_value;
        -:  347:} /* ecma_builtin_regexp_prototype_exec */
        -:  348:
        -:  349:/**
        -:  350: * The RegExp.prototype object's 'test' routine
        -:  351: *
        -:  352: * See also:
        -:  353: *          ECMA-262 v5, 15.10.6.3
        -:  354: *          ECMA-262 v6, 21.2.5.13
        -:  355: *
        -:  356: * @return true  - if match is not null
        -:  357: *         false - otherwise
        -:  358: *
        -:  359: *         May raise error, so returned value must be freed with ecma_free_value.
        -:  360: */
        -:  361:static ecma_value_t
    #####:  362:ecma_builtin_regexp_prototype_test (ecma_value_t this_arg, /**< this argument */
        -:  363:                                    ecma_value_t arg) /**< routine's argument */
        -:  364:{
        -:  365:#if JERRY_ESNEXT
    #####:  366:  ecma_string_t *arg_str_p = ecma_op_to_string (arg);
        -:  367:
    #####:  368:  if (JERRY_UNLIKELY (arg_str_p == NULL))
        -:  369:  {
    #####:  370:    return ECMA_VALUE_ERROR;
        -:  371:  }
        -:  372:
    #####:  373:  ecma_value_t result = ecma_op_regexp_exec (this_arg, arg_str_p);
        -:  374:
    #####:  375:  ecma_deref_ecma_string (arg_str_p);
        -:  376:
    #####:  377:  if (ECMA_IS_VALUE_ERROR (result))
        -:  378:  {
    #####:  379:    return result;
        -:  380:  }
        -:  381:#else /* !JERRY_ESNEXT */
    #####:  382:  ecma_value_t result = ecma_builtin_regexp_prototype_exec (this_arg, arg);
        -:  383:
    #####:  384:  if (ECMA_IS_VALUE_ERROR (result))
        -:  385:  {
        -:  386:    return result;
        -:  387:  }
        -:  388:#endif /* JERRY_ESNEXT */
        -:  389:
    #####:  390:  ecma_value_t ret_value = ecma_make_boolean_value (!ecma_is_value_null (result));
    #####:  391:  ecma_free_value (result);
        -:  392:
    #####:  393:  return ret_value;
        -:  394:} /* ecma_builtin_regexp_prototype_test */
        -:  395:
        -:  396:/**
        -:  397: * The RegExp.prototype object's 'toString' routine
        -:  398: *
        -:  399: * See also:
        -:  400: *          ECMA-262 v5, 15.10.6.4
        -:  401: *
        -:  402: * @return ecma value
        -:  403: *         Returned value must be freed with ecma_free_value.
        -:  404: */
        -:  405:static ecma_value_t
    #####:  406:ecma_builtin_regexp_prototype_to_string (ecma_object_t *object_p) /**< this object */
        -:  407:{
        -:  408:#if JERRY_ESNEXT
    #####:  409:  ecma_value_t result = ecma_op_object_get_by_magic_id (object_p, LIT_MAGIC_STRING_SOURCE);
    #####:  410:  if (ECMA_IS_VALUE_ERROR (result))
        -:  411:  {
    #####:  412:    return result;
        -:  413:  }
        -:  414:
    #####:  415:  ecma_string_t *source_p = ecma_op_to_string (result);
    #####:  416:  ecma_free_value (result);
        -:  417:
    #####:  418:  if (source_p == NULL)
        -:  419:  {
    #####:  420:    return ECMA_VALUE_ERROR;
        -:  421:  }
        -:  422:
    #####:  423:  result = ecma_op_object_get_by_magic_id (object_p, LIT_MAGIC_STRING_FLAGS);
    #####:  424:  if (ECMA_IS_VALUE_ERROR (result))
        -:  425:  {
    #####:  426:    ecma_deref_ecma_string (source_p);
    #####:  427:    return result;
        -:  428:  }
        -:  429:
    #####:  430:  ecma_string_t *flags_p = ecma_op_to_string (result);
    #####:  431:  ecma_free_value (result);
        -:  432:
    #####:  433:  if (flags_p == NULL)
        -:  434:  {
    #####:  435:    ecma_deref_ecma_string (source_p);
    #####:  436:    return ECMA_VALUE_ERROR;
        -:  437:  }
        -:  438:
    #####:  439:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
    #####:  440:  ecma_stringbuilder_append_byte (&builder, LIT_CHAR_SLASH);
    #####:  441:  ecma_stringbuilder_append (&builder, source_p);
    #####:  442:  ecma_stringbuilder_append_byte (&builder, LIT_CHAR_SLASH);
    #####:  443:  ecma_stringbuilder_append (&builder, flags_p);
        -:  444:
    #####:  445:  ecma_deref_ecma_string (source_p);
    #####:  446:  ecma_deref_ecma_string (flags_p);
        -:  447:
    #####:  448:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  449:#else /* !JERRY_ESNEXT */
    #####:  450:  ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) object_p;
        -:  451:
    #####:  452:  re_compiled_code_t *bc_p = ECMA_GET_INTERNAL_VALUE_POINTER (re_compiled_code_t, re_obj_p->u.cls.u3.value);
        -:  453:
    #####:  454:  ecma_string_t *source_p = ecma_get_string_from_value (bc_p->source);
    #####:  455:  uint16_t flags = bc_p->header.status_flags;
        -:  456:
    #####:  457:  ecma_stringbuilder_t result = ecma_stringbuilder_create ();
    #####:  458:  ecma_stringbuilder_append_byte (&result, LIT_CHAR_SLASH);
    #####:  459:  ecma_stringbuilder_append (&result, source_p);
    #####:  460:  ecma_stringbuilder_append_byte (&result, LIT_CHAR_SLASH);
        -:  461:
    #####:  462:  if (flags & RE_FLAG_GLOBAL)
        -:  463:  {
    #####:  464:    ecma_stringbuilder_append_byte (&result, LIT_CHAR_LOWERCASE_G);
        -:  465:  }
        -:  466:
    #####:  467:  if (flags & RE_FLAG_IGNORE_CASE)
        -:  468:  {
    #####:  469:    ecma_stringbuilder_append_byte (&result, LIT_CHAR_LOWERCASE_I);
        -:  470:  }
        -:  471:
    #####:  472:  if (flags & RE_FLAG_MULTILINE)
        -:  473:  {
    #####:  474:    ecma_stringbuilder_append_byte (&result, LIT_CHAR_LOWERCASE_M);
        -:  475:  }
        -:  476:
    #####:  477:  return ecma_make_string_value (ecma_stringbuilder_finalize (&result));
        -:  478:#endif /* JERRY_ESNEXT */
        -:  479:} /* ecma_builtin_regexp_prototype_to_string */
        -:  480:
        -:  481:#if JERRY_ESNEXT
        -:  482:/**
        -:  483: * Helper function to determine if method is the builtin exec method
        -:  484: *
        -:  485: * @return true, if function is the builtin exec method
        -:  486: *         false, otherwise
        -:  487: */
        -:  488:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####:  489:ecma_builtin_is_regexp_exec (ecma_extended_object_t *obj_p)
        -:  490:{
    #####:  491:  return (ecma_get_object_type (&obj_p->object) == ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION
    #####:  492:          && obj_p->u.built_in.routine_id == ECMA_REGEXP_PROTOTYPE_ROUTINE_EXEC);
        -:  493:} /* ecma_builtin_is_regexp_exec */
        -:  494:#endif /* JERRY_ESNEXT */
        -:  495:
        -:  496:#if JERRY_ESNEXT
        -:  497:/**
        -:  498: * The RegExp.prototype object's 'matchAll' routine
        -:  499: *
        -:  500: * See also:
        -:  501: *          ECMA-262 v11, 21.2.5.8
        -:  502: *
        -:  503: * @return ecma_value_t
        -:  504: */
        -:  505:static ecma_value_t
    #####:  506:ecma_builtin_regexp_prototype_match_all (ecma_object_t *regexp_obj_p, /**< this argument */
        -:  507:                                         ecma_value_t string_arg) /**< source string */
        -:  508:{
        -:  509:  /* 3. */
    #####:  510:  ecma_string_t *str_p = ecma_op_to_string (string_arg);
        -:  511:
    #####:  512:  if (JERRY_UNLIKELY (str_p == NULL))
        -:  513:  {
    #####:  514:    return ECMA_VALUE_ERROR;
        -:  515:  }
        -:  516:
        -:  517:  /* 4. */
    #####:  518:  ecma_value_t constructor = ecma_op_species_constructor (regexp_obj_p, ECMA_BUILTIN_ID_REGEXP);
        -:  519:
    #####:  520:  if (ECMA_IS_VALUE_ERROR (constructor))
        -:  521:  {
    #####:  522:    ecma_deref_ecma_string (str_p);
    #####:  523:    return constructor;
        -:  524:  }
        -:  525:
        -:  526:  /* 5. */
    #####:  527:  ecma_value_t get_flag = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_FLAGS);
        -:  528:
    #####:  529:  if (ECMA_IS_VALUE_ERROR (get_flag))
        -:  530:  {
    #####:  531:    ecma_deref_ecma_string (str_p);
    #####:  532:    ecma_free_value (constructor);
    #####:  533:    return get_flag;
        -:  534:  }
        -:  535:
    #####:  536:  ecma_string_t *flags = ecma_op_to_string (get_flag);
        -:  537:
    #####:  538:  ecma_free_value (get_flag);
        -:  539:
    #####:  540:  if (JERRY_UNLIKELY (flags == NULL))
        -:  541:  {
    #####:  542:    ecma_deref_ecma_string (str_p);
    #####:  543:    ecma_free_value (constructor);
    #####:  544:    return ECMA_VALUE_ERROR;
        -:  545:  }
        -:  546:
        -:  547:  /* 6. */
    #####:  548:  ecma_object_t *constructor_obj_p = ecma_get_object_from_value (constructor);
    #####:  549:  ecma_value_t flags_value = ecma_make_string_value (flags);
    #####:  550:  ecma_value_t match_args[] = { ecma_make_object_value (regexp_obj_p), flags_value };
    #####:  551:  ecma_value_t matcher = ecma_op_function_construct (constructor_obj_p, constructor_obj_p, match_args, 2);
        -:  552:
    #####:  553:  ecma_deref_object (constructor_obj_p);
        -:  554:
    #####:  555:  if (ECMA_IS_VALUE_ERROR (matcher))
        -:  556:  {
    #####:  557:    ecma_deref_ecma_string (str_p);
    #####:  558:    ecma_deref_ecma_string (flags);
    #####:  559:    return matcher;
        -:  560:  }
        -:  561:
        -:  562:  /* 7. */
    #####:  563:  ecma_value_t get_last_index = ecma_op_object_get_by_magic_id (regexp_obj_p, LIT_MAGIC_STRING_LASTINDEX_UL);
        -:  564:
    #####:  565:  if (ECMA_IS_VALUE_ERROR (get_last_index))
        -:  566:  {
    #####:  567:    ecma_deref_ecma_string (str_p);
    #####:  568:    ecma_deref_ecma_string (flags);
    #####:  569:    ecma_free_value (matcher);
    #####:  570:    return get_last_index;
        -:  571:  }
        -:  572:
    #####:  573:  ecma_length_t last_index;
    #####:  574:  ecma_value_t to_len = ecma_op_to_length (get_last_index, &last_index);
        -:  575:
    #####:  576:  ecma_free_value (get_last_index);
        -:  577:
    #####:  578:  if (ECMA_IS_VALUE_ERROR (to_len))
        -:  579:  {
    #####:  580:    ecma_deref_ecma_string (str_p);
    #####:  581:    ecma_deref_ecma_string (flags);
    #####:  582:    ecma_free_value (matcher);
    #####:  583:    return to_len;
        -:  584:  }
        -:  585:
        -:  586:  /* 8. */
    #####:  587:  ecma_object_t *matcher_obj_p = ecma_get_object_from_value (matcher);
    #####:  588:  ecma_value_t last_index_value = ecma_make_length_value (last_index);
    #####:  589:  ecma_value_t set =
    #####:  590:    ecma_op_object_put (matcher_obj_p, ecma_get_magic_string (LIT_MAGIC_STRING_LASTINDEX_UL), last_index_value, true);
        -:  591:
    #####:  592:  ecma_free_value (last_index_value);
        -:  593:
    #####:  594:  if (ECMA_IS_VALUE_ERROR (set))
        -:  595:  {
    #####:  596:    ecma_deref_ecma_string (str_p);
    #####:  597:    ecma_deref_ecma_string (flags);
    #####:  598:    ecma_deref_object (matcher_obj_p);
        -:  599:  }
        -:  600:
    #####:  601:  uint16_t parsed_flag;
    #####:  602:  ecma_value_t flag_parse = ecma_regexp_parse_flags (flags, &parsed_flag);
        -:  603:
    #####:  604:  ecma_deref_ecma_string (flags);
        -:  605:
    #####:  606:  if (ECMA_IS_VALUE_ERROR (flag_parse))
        -:  607:  {
    #####:  608:    ecma_deref_ecma_string (str_p);
    #####:  609:    ecma_deref_object (matcher_obj_p);
    #####:  610:    return flag_parse;
        -:  611:  }
        -:  612:
        -:  613:  /* 13. */
        -:  614:  ecma_object_t *result_obj;
    #####:  615:  ecma_object_t *proto_p = ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_STRING_ITERATOR_PROTOTYPE);
    #####:  616:  result_obj = ecma_create_object (proto_p, sizeof (ecma_regexp_string_iterator_t), ECMA_OBJECT_TYPE_CLASS);
        -:  617:
    #####:  618:  ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) result_obj;
    #####:  619:  ext_obj_p->u.cls.type = ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR;
    #####:  620:  ext_obj_p->u.cls.u1.regexp_string_iterator_flags = (uint8_t) (parsed_flag & (RE_FLAG_GLOBAL | RE_FLAG_UNICODE));
        -:  621:
    #####:  622:  ecma_regexp_string_iterator_t *regexp_string_iterator_obj = (ecma_regexp_string_iterator_t *) result_obj;
        -:  623:
    #####:  624:  regexp_string_iterator_obj->iterating_regexp = matcher;
    #####:  625:  regexp_string_iterator_obj->iterated_string = ecma_make_string_value (str_p);
        -:  626:
    #####:  627:  ecma_deref_object (matcher_obj_p);
        -:  628:
    #####:  629:  return ecma_make_object_value (result_obj);
        -:  630:} /* ecma_builtin_regexp_prototype_match_all */
        -:  631:#endif /* JERRY_ESNEXT */
        -:  632:
        -:  633:/**
        -:  634: * Dispatcher of the Regexp built-in's routines
        -:  635: *
        -:  636: * @return ecma value
        -:  637: *         Returned value must be freed with ecma_free_value.
        -:  638: */
        -:  639:ecma_value_t
    #####:  640:ecma_builtin_regexp_prototype_dispatch_routine (uint8_t builtin_routine_id, /**< built-in wide routine identifier */
        -:  641:                                                ecma_value_t this_arg, /**< 'this' argument value */
        -:  642:                                                const ecma_value_t arguments_list_p[], /**< list of arguments
        -:  643:                                                                                        *   passed to routine */
        -:  644:                                                uint32_t arguments_number) /**< length of arguments' list */
        -:  645:{
        -:  646:  JERRY_UNUSED (arguments_number);
        -:  647:
        -:  648:#if !JERRY_ESNEXT
    #####:  649:  bool require_regexp = builtin_routine_id <= ECMA_REGEXP_PROTOTYPE_ROUTINE_TO_STRING;
        -:  650:#else /* JERRY_ESNEXT */
    #####:  651:  bool require_regexp = builtin_routine_id < ECMA_REGEXP_PROTOTYPE_ROUTINE_TEST;
        -:  652:#endif /* JERRY_ESNEXT */
        -:  653:
    #####:  654:  ecma_object_t *obj_p = NULL;
        -:  655:
        -:  656:  /* 1. && 2. */
    #####:  657:  if (ecma_is_value_object (this_arg))
        -:  658:  {
    #####:  659:    obj_p = ecma_get_object_from_value (this_arg);
        -:  660:
    #####:  661:    if (require_regexp && !ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_REGEXP))
        -:  662:    {
    #####:  663:      obj_p = NULL;
        -:  664:    }
        -:  665:  }
        -:  666:
    #####:  667:  if (obj_p == NULL)
        -:  668:  {
    #####:  669:    return ecma_raise_type_error (ECMA_ERR_ARGUMENT_THIS_NOT_OBJECT);
        -:  670:  }
        -:  671:
    #####:  672:  switch (builtin_routine_id)
        -:  673:  {
        -:  674:#if JERRY_BUILTIN_ANNEXB
    #####:  675:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_COMPILE:
        -:  676:    {
    #####:  677:      return ecma_builtin_regexp_prototype_compile (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -:  678:    }
        -:  679:#endif /* JERRY_BUILTIN_ANNEXB */
    #####:  680:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_TEST:
        -:  681:    {
    #####:  682:      return ecma_builtin_regexp_prototype_test (this_arg, arguments_list_p[0]);
        -:  683:    }
    #####:  684:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_EXEC:
        -:  685:    {
    #####:  686:      return ecma_builtin_regexp_prototype_exec (this_arg, arguments_list_p[0]);
        -:  687:    }
    #####:  688:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_TO_STRING:
        -:  689:    {
    #####:  690:      return ecma_builtin_regexp_prototype_to_string (obj_p);
        -:  691:    }
        -:  692:#if JERRY_ESNEXT
    #####:  693:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_SEARCH:
        -:  694:    {
    #####:  695:      return ecma_regexp_search_helper (this_arg, arguments_list_p[0]);
        -:  696:    }
    #####:  697:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_MATCH:
        -:  698:    {
    #####:  699:      return ecma_regexp_match_helper (this_arg, arguments_list_p[0]);
        -:  700:    }
    #####:  701:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_MATCH_ALL:
        -:  702:    {
    #####:  703:      return ecma_builtin_regexp_prototype_match_all (obj_p, arguments_list_p[0]);
        -:  704:    }
    #####:  705:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_REPLACE:
        -:  706:    {
    #####:  707:      return ecma_regexp_replace_helper (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -:  708:    }
    #####:  709:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_SYMBOL_SPLIT:
        -:  710:    {
    #####:  711:      return ecma_regexp_split_helper (this_arg, arguments_list_p[0], arguments_list_p[1]);
        -:  712:    }
    #####:  713:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_FLAGS:
        -:  714:    {
    #####:  715:      return ecma_builtin_regexp_prototype_get_flags (obj_p);
        -:  716:    }
    #####:  717:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_SOURCE:
        -:  718:    {
    #####:  719:      if (!ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_REGEXP))
        -:  720:      {
    #####:  721:        if (obj_p == ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE))
        -:  722:        {
    #####:  723:          return ecma_make_magic_string_value (LIT_MAGIC_STRING_EMPTY_NON_CAPTURE_GROUP);
        -:  724:        }
        -:  725:
    #####:  726:        return ecma_raise_type_error (ECMA_ERR_ARGUMENT_IS_NOT_AN_REGEXP);
        -:  727:      }
        -:  728:
    #####:  729:      ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) obj_p;
    #####:  730:      return ecma_builtin_regexp_prototype_get_source (re_obj_p);
        -:  731:    }
    #####:  732:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_GLOBAL:
        -:  733:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_IGNORE_CASE:
        -:  734:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_MULTILINE:
        -:  735:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_STICKY:
        -:  736:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_UNICODE:
        -:  737:    case ECMA_REGEXP_PROTOTYPE_ROUTINE_GET_DOT_ALL:
        -:  738:    {
    #####:  739:      if (!ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_REGEXP))
        -:  740:      {
    #####:  741:        if (obj_p == ecma_builtin_get (ECMA_BUILTIN_ID_REGEXP_PROTOTYPE))
        -:  742:        {
    #####:  743:          return ECMA_VALUE_UNDEFINED;
        -:  744:        }
        -:  745:
    #####:  746:        return ecma_raise_type_error (ECMA_ERR_ARGUMENT_IS_NOT_AN_REGEXP);
        -:  747:      }
        -:  748:
    #####:  749:      ecma_extended_object_t *re_obj_p = (ecma_extended_object_t *) obj_p;
    #####:  750:      return ecma_builtin_regexp_prototype_flags_helper (re_obj_p, builtin_routine_id);
        -:  751:    }
        -:  752:#endif /* JERRY_ESNEXT */
    #####:  753:    default:
        -:  754:    {
    #####:  755:      JERRY_UNREACHABLE ();
        -:  756:    }
        -:  757:  }
        -:  758:} /* ecma_builtin_regexp_prototype_dispatch_routine */
        -:  759:/**
        -:  760: * @}
        -:  761: * @}
        -:  762: * @}
        -:  763: */
        -:  764:
        -:  765:#endif /* JERRY_BUILTIN_REGEXP */
