        -:    0:Source:/home/workspace/jerry-core/vm/opcodes.c
        -:    0:Programs:299
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "opcodes.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-array-object.h"
        -:   20:#include "ecma-builtin-helpers.h"
        -:   21:#include "ecma-builtins.h"
        -:   22:#include "ecma-conversion.h"
        -:   23:#include "ecma-exceptions.h"
        -:   24:#include "ecma-function-object.h"
        -:   25:#include "ecma-gc.h"
        -:   26:#include "ecma-globals.h"
        -:   27:#include "ecma-helpers.h"
        -:   28:#include "ecma-iterator-object.h"
        -:   29:#include "ecma-lex-env.h"
        -:   30:#include "ecma-objects.h"
        -:   31:#include "ecma-promise-object.h"
        -:   32:#include "ecma-proxy-object.h"
        -:   33:
        -:   34:#include "jcontext.h"
        -:   35:#include "vm-defines.h"
        -:   36:#include "vm-stack.h"
        -:   37:
        -:   38:/** \addtogroup vm Virtual machine
        -:   39: * @{
        -:   40: *
        -:   41: * \addtogroup vm_opcodes Opcodes
        -:   42: * @{
        -:   43: */
        -:   44:
        -:   45:/**
        -:   46: * 'typeof' opcode handler.
        -:   47: *
        -:   48: * See also: ECMA-262 v5, 11.4.3
        -:   49: *
        -:   50: * @return ecma value
        -:   51: *         Returned value must be freed with ecma_free_value
        -:   52: */
        -:   53:ecma_value_t
    #####:   54:opfunc_typeof (ecma_value_t left_value) /**< left value */
        -:   55:{
    #####:   56:  return ecma_make_magic_string_value (ecma_get_typeof_lit_id (left_value));
        -:   57:} /* opfunc_typeof */
        -:   58:
        -:   59:/**
        -:   60: * Update data property for object literals.
        -:   61: */
        -:   62:void
        1:   63:opfunc_set_data_property (ecma_object_t *object_p, /**< object */
        -:   64:                          ecma_string_t *prop_name_p, /**< data property name */
        -:   65:                          ecma_value_t value) /**< new value */
        -:   66:{
        1:   67:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -:   68:
        1:   69:  ecma_property_t *property_p = ecma_find_named_property (object_p, prop_name_p);
        -:   70:  ecma_property_value_t *prop_value_p;
        -:   71:
        1:   72:  if (property_p == NULL)
        -:   73:  {
        1:   74:    prop_value_p =
        -:   75:      ecma_create_named_data_property (object_p, prop_name_p, ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE, NULL);
        -:   76:  }
        -:   77:  else
        -:   78:  {
    #####:   79:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:   80:
    #####:   81:    prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:   82:
    #####:   83:    if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:   84:    {
        -:   85:#if JERRY_CPOINTER_32_BIT
        -:   86:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
    #####:   87:      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,
        -:   88:                                                        ECMA_PROPERTY_VALUE_PTR (property_p)->getter_setter_pair_cp);
    #####:   89:      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));
        -:   90:#endif /* JERRY_CPOINTER_32_BIT */
        -:   91:
    #####:   92:      *property_p |= ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE;
    #####:   93:      prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####:   94:      return;
        -:   95:    }
        -:   96:  }
        -:   97:
        1:   98:  ecma_named_data_property_assign_value (object_p, prop_value_p, value);
        -:   99:} /* opfunc_set_data_property */
        -:  100:
        -:  101:/**
        -:  102: * Update getter or setter for object literals.
        -:  103: */
        -:  104:void
    #####:  105:opfunc_set_accessor (bool is_getter, /**< is getter accessor */
        -:  106:                     ecma_value_t object, /**< object value */
        -:  107:                     ecma_string_t *accessor_name_p, /**< accessor name */
        -:  108:                     ecma_value_t accessor) /**< accessor value */
        -:  109:{
    #####:  110:  ecma_object_t *object_p = ecma_get_object_from_value (object);
        -:  111:
    #####:  112:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -:  113:
    #####:  114:  ecma_property_t *property_p = ecma_find_named_property (object_p, accessor_name_p);
    #####:  115:  ecma_object_t *accessor_p = ecma_get_object_from_value (accessor);
        -:  116:
    #####:  117:  ecma_object_t *getter_func_p = NULL;
    #####:  118:  ecma_object_t *setter_func_p = NULL;
        -:  119:
    #####:  120:  if (is_getter)
        -:  121:  {
    #####:  122:    getter_func_p = accessor_p;
        -:  123:  }
        -:  124:  else
        -:  125:  {
    #####:  126:    setter_func_p = accessor_p;
        -:  127:  }
        -:  128:
    #####:  129:  if (property_p == NULL)
        -:  130:  {
    #####:  131:    ecma_create_named_accessor_property (object_p,
        -:  132:                                         accessor_name_p,
        -:  133:                                         getter_func_p,
        -:  134:                                         setter_func_p,
        -:  135:                                         ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE,
        -:  136:                                         NULL);
        -:  137:  }
        -:  138:  else
        -:  139:  {
    #####:  140:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  141:
    #####:  142:    ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  143:
    #####:  144:    if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  145:    {
        -:  146:#if JERRY_CPOINTER_32_BIT
        -:  147:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
    #####:  148:      getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));
        -:  149:#endif /* JERRY_CPOINTER_32_BIT */
        -:  150:
    #####:  151:      ecma_free_value_if_not_object (prop_value_p->value);
    #####:  152:      *property_p = (uint8_t) (*property_p & ~(ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE));
        -:  153:
        -:  154:#if JERRY_CPOINTER_32_BIT
    #####:  155:      ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, getter_func_p);
    #####:  156:      ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, setter_func_p);
    #####:  157:      ECMA_SET_NON_NULL_POINTER (prop_value_p->getter_setter_pair_cp, getter_setter_pair_p);
        -:  158:#else /* !JERRY_CPOINTER_32_BIT */
    #####:  159:      ECMA_SET_POINTER (prop_value_p->getter_setter_pair.getter_cp, getter_func_p);
    #####:  160:      ECMA_SET_POINTER (prop_value_p->getter_setter_pair.setter_cp, setter_func_p);
        -:  161:#endif /* JERRY_CPOINTER_32_BIT */
    #####:  162:      return;
        -:  163:    }
        -:  164:
    #####:  165:    if (is_getter)
        -:  166:    {
    #####:  167:      ecma_set_named_accessor_property_getter (object_p, prop_value_p, accessor_p);
        -:  168:    }
        -:  169:    else
        -:  170:    {
    #####:  171:      ecma_set_named_accessor_property_setter (object_p, prop_value_p, accessor_p);
        -:  172:    }
        -:  173:  }
        -:  174:} /* opfunc_set_accessor */
        -:  175:
        -:  176:/**
        -:  177: * Deletes an object property.
        -:  178: *
        -:  179: * @return ecma value
        -:  180: *         Returned value must be freed with ecma_free_value
        -:  181: */
        -:  182:ecma_value_t
    #####:  183:vm_op_delete_prop (ecma_value_t object, /**< base object */
        -:  184:                   ecma_value_t property, /**< property name */
        -:  185:                   bool is_strict) /**< strict mode */
        -:  186:{
        -:  187:#if !JERRY_ESNEXT
    #####:  188:  if (ecma_is_value_undefined (object))
        -:  189:  {
        -:  190:    return ECMA_VALUE_TRUE;
        -:  191:  }
        -:  192:#endif /* !JERRY_ESNEXT */
        -:  193:
    #####:  194:  if (!ecma_op_require_object_coercible (object))
        -:  195:  {
    #####:  196:    return ECMA_VALUE_ERROR;
        -:  197:  }
        -:  198:
    #####:  199:  ecma_string_t *name_string_p = ecma_op_to_property_key (property);
        -:  200:
    #####:  201:  if (JERRY_UNLIKELY (name_string_p == NULL))
        -:  202:  {
    #####:  203:    return ECMA_VALUE_ERROR;
        -:  204:  }
        -:  205:
    #####:  206:  ecma_value_t obj_value = ecma_op_to_object (object);
        -:  207:  /* The ecma_op_require_object_coercible call already checked the op_to_object error cases. */
    #####:  208:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (obj_value));
    #####:  209:  JERRY_ASSERT (ecma_is_value_object (obj_value));
    #####:  210:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
    #####:  211:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
        -:  212:
    #####:  213:  ecma_value_t delete_op_ret = ecma_op_object_delete (obj_p, name_string_p, is_strict);
    #####:  214:  JERRY_ASSERT (ecma_is_value_boolean (delete_op_ret) || ECMA_IS_VALUE_ERROR (delete_op_ret));
    #####:  215:  ecma_deref_object (obj_p);
    #####:  216:  ecma_deref_ecma_string (name_string_p);
        -:  217:
        -:  218:#if JERRY_ESNEXT
    #####:  219:  if (is_strict && ecma_is_value_false (delete_op_ret))
        -:  220:  {
    #####:  221:    return ecma_raise_type_error (ECMA_ERR_OPERATOR_DELETE_RETURNED_FALSE_IN_STRICT_MODE);
        -:  222:  }
        -:  223:#endif /* JERRY_ESNEXT */
        -:  224:
    #####:  225:  return delete_op_ret;
        -:  226:} /* vm_op_delete_prop */
        -:  227:
        -:  228:/**
        -:  229: * Deletes a variable.
        -:  230: *
        -:  231: * @return ecma value
        -:  232: *         Returned value must be freed with ecma_free_value
        -:  233: */
        -:  234:ecma_value_t
    #####:  235:vm_op_delete_var (ecma_value_t name_literal, /**< name literal */
        -:  236:                  ecma_object_t *lex_env_p) /**< lexical environment */
        -:  237:{
    #####:  238:  ecma_value_t completion_value = ECMA_VALUE_EMPTY;
        -:  239:
    #####:  240:  ecma_string_t *var_name_str_p = ecma_get_string_from_value (name_literal);
        -:  241:
    #####:  242:  ecma_object_t *ref_base_lex_env_p = ecma_op_resolve_reference_base (lex_env_p, var_name_str_p);
        -:  243:
        -:  244:#if JERRY_BUILTIN_PROXY
    #####:  245:  if (JERRY_UNLIKELY (ref_base_lex_env_p == ECMA_OBJECT_POINTER_ERROR))
        -:  246:  {
    #####:  247:    return ECMA_VALUE_ERROR;
        -:  248:  }
        -:  249:#endif /* JERRY_BUILTIN_PROXY */
        -:  250:
    #####:  251:  if (ref_base_lex_env_p == NULL)
        -:  252:  {
    #####:  253:    completion_value = ECMA_VALUE_TRUE;
        -:  254:  }
        -:  255:  else
        -:  256:  {
    #####:  257:    JERRY_ASSERT (ecma_is_lexical_environment (ref_base_lex_env_p));
        -:  258:
    #####:  259:    completion_value = ecma_op_delete_binding (ref_base_lex_env_p, var_name_str_p);
        -:  260:  }
        -:  261:
    #####:  262:  return completion_value;
        -:  263:} /* vm_op_delete_var */
        -:  264:
        -:  265:/**
        -:  266: * 'for-in' opcode handler
        -:  267: *
        -:  268: *  Note: from ES2015 (ES6) the for-in can trigger error when
        -:  269: *        the property names are not available (ex.: via Proxy ownKeys).
        -:  270: *        In these cases an error must be returned.
        -:  271: *
        -:  272: *        This error is returned as the `result_obj_p` and the
        -:  273: *        function's return value is NULL.
        -:  274: *
        -:  275: * See also:
        -:  276: *          ECMA-262 v5, 12.6.4
        -:  277: *
        -:  278: * @return - chain list of property names
        -:  279: *         - In case of error: NULL is returned and the `result_obj_p`
        -:  280: *           must be checked.
        -:  281: */
        -:  282:ecma_collection_t *
    #####:  283:opfunc_for_in (ecma_value_t iterable_value, /**< ideally an iterable value */
        -:  284:               ecma_value_t *result_obj_p) /**< expression object */
        -:  285:{
        -:  286:  /* 3. */
    #####:  287:  if (ecma_is_value_undefined (iterable_value) || ecma_is_value_null (iterable_value))
        -:  288:  {
    #####:  289:    return NULL;
        -:  290:  }
        -:  291:
        -:  292:  /* 4. */
    #####:  293:  ecma_value_t obj_expr_value = ecma_op_to_object (iterable_value);
        -:  294:  /* ecma_op_to_object will only raise error on null/undefined values but those are handled above. */
    #####:  295:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (obj_expr_value));
    #####:  296:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_expr_value);
    #####:  297:  ecma_collection_t *prop_names_p = ecma_op_object_enumerate (obj_p);
        -:  298:
        -:  299:#if JERRY_ESNEXT
    #####:  300:  if (JERRY_UNLIKELY (prop_names_p == NULL))
        -:  301:  {
    #####:  302:    ecma_deref_object (obj_p);
    #####:  303:    *result_obj_p = ECMA_VALUE_ERROR;
    #####:  304:    return NULL;
        -:  305:  }
        -:  306:#endif /* JERRY_ESNEXT */
        -:  307:
    #####:  308:  if (prop_names_p->item_count != 0)
        -:  309:  {
    #####:  310:    *result_obj_p = ecma_make_object_value (obj_p);
    #####:  311:    return prop_names_p;
        -:  312:  }
        -:  313:
    #####:  314:  ecma_deref_object (obj_p);
    #####:  315:  ecma_collection_destroy (prop_names_p);
        -:  316:
    #####:  317:  return NULL;
        -:  318:} /* opfunc_for_in */
        -:  319:
        -:  320:#if JERRY_ESNEXT
        -:  321:
        -:  322:/**
        -:  323: * 'VM_OC_APPEND_ARRAY' opcode handler specialized for spread objects
        -:  324: *
        -:  325: * @return ECMA_VALUE_ERROR - if the operation failed
        -:  326: *         ECMA_VALUE_EMPTY, otherwise
        -:  327: */
        -:  328:static ecma_value_t JERRY_ATTR_NOINLINE
    #####:  329:opfunc_append_to_spread_array (ecma_value_t *stack_top_p, /**< current stack top */
        -:  330:                               uint16_t values_length) /**< number of elements to set */
        -:  331:{
    #####:  332:  JERRY_ASSERT (!(values_length & OPFUNC_HAS_SPREAD_ELEMENT));
        -:  333:
    #####:  334:  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####:  335:  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  336:
    #####:  337:  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####:  338:  uint32_t old_length = ext_array_obj_p->u.array.length;
        -:  339:
    #####:  340:  for (uint32_t i = 0, idx = old_length; i < values_length; i++, idx++)
        -:  341:  {
    #####:  342:    if (ecma_is_value_array_hole (stack_top_p[i]))
        -:  343:    {
    #####:  344:      continue;
        -:  345:    }
        -:  346:
    #####:  347:    if (stack_top_p[i] == ECMA_VALUE_SPREAD_ELEMENT)
        -:  348:    {
    #####:  349:      i++;
    #####:  350:      ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  351:      ecma_value_t spread_value = stack_top_p[i];
        -:  352:
    #####:  353:      ecma_value_t next_method;
    #####:  354:      ecma_value_t iterator = ecma_op_get_iterator (spread_value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  355:
    #####:  356:      if (!ECMA_IS_VALUE_ERROR (iterator))
        -:  357:      {
        -:  358:        while (true)
    #####:  359:        {
    #####:  360:          ecma_value_t next_value = ecma_op_iterator_step (iterator, next_method);
        -:  361:
    #####:  362:          if (ECMA_IS_VALUE_ERROR (next_value))
        -:  363:          {
    #####:  364:            break;
        -:  365:          }
        -:  366:
    #####:  367:          if (ecma_is_value_false (next_value))
        -:  368:          {
    #####:  369:            idx--;
    #####:  370:            ret_value = ECMA_VALUE_EMPTY;
    #####:  371:            break;
        -:  372:          }
        -:  373:
    #####:  374:          ecma_value_t value = ecma_op_iterator_value (next_value);
        -:  375:
    #####:  376:          ecma_free_value (next_value);
        -:  377:
    #####:  378:          if (ECMA_IS_VALUE_ERROR (value))
        -:  379:          {
    #####:  380:            break;
        -:  381:          }
        -:  382:
        -:  383:          ecma_value_t put_comp;
    #####:  384:          put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
    #####:  385:                                                            idx++,
        -:  386:                                                            value,
        -:  387:                                                            ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -:  388:
    #####:  389:          JERRY_ASSERT (ecma_is_value_true (put_comp));
    #####:  390:          ecma_free_value (value);
        -:  391:        }
        -:  392:      }
        -:  393:
    #####:  394:      ecma_free_value (iterator);
    #####:  395:      ecma_free_value (next_method);
    #####:  396:      ecma_free_value (spread_value);
        -:  397:
    #####:  398:      if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  399:      {
    #####:  400:        for (uint32_t k = i + 1; k < values_length; k++)
        -:  401:        {
    #####:  402:          ecma_free_value (stack_top_p[k]);
        -:  403:        }
        -:  404:
    #####:  405:        return ret_value;
        -:  406:      }
        -:  407:    }
        -:  408:    else
        -:  409:    {
    #####:  410:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
        -:  411:                                                                     idx,
    #####:  412:                                                                     stack_top_p[i],
        -:  413:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  414:      JERRY_ASSERT (ecma_is_value_true (put_comp));
    #####:  415:      ecma_free_value (stack_top_p[i]);
        -:  416:    }
        -:  417:  }
        -:  418:
    #####:  419:  return ECMA_VALUE_EMPTY;
        -:  420:} /* opfunc_append_to_spread_array */
        -:  421:
        -:  422:/**
        -:  423: * Spread function call/construct arguments into an ecma-collection
        -:  424: *
        -:  425: * @return NULL - if the operation failed
        -:  426: *         pointer to the ecma-collection with the spreaded arguments, otherwise
        -:  427: */
        -:  428:JERRY_ATTR_NOINLINE ecma_collection_t *
    #####:  429:opfunc_spread_arguments (ecma_value_t *stack_top_p, /**< pointer to the current stack top */
        -:  430:                         uint8_t arguments_list_len) /**< number of arguments */
        -:  431:{
    #####:  432:  ecma_collection_t *buff_p = ecma_new_collection ();
        -:  433:
    #####:  434:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  435:  {
    #####:  436:    ecma_value_t arg = *stack_top_p++;
        -:  437:
    #####:  438:    if (arg != ECMA_VALUE_SPREAD_ELEMENT)
        -:  439:    {
    #####:  440:      ecma_collection_push_back (buff_p, arg);
    #####:  441:      continue;
        -:  442:    }
        -:  443:
    #####:  444:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  445:    ecma_value_t spread_value = *stack_top_p++;
    #####:  446:    i++;
        -:  447:
    #####:  448:    ecma_value_t next_method;
    #####:  449:    ecma_value_t iterator = ecma_op_get_iterator (spread_value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  450:
    #####:  451:    if (!ECMA_IS_VALUE_ERROR (iterator))
        -:  452:    {
        -:  453:      while (true)
    #####:  454:      {
    #####:  455:        ecma_value_t next_value = ecma_op_iterator_step (iterator, next_method);
        -:  456:
    #####:  457:        if (ECMA_IS_VALUE_ERROR (next_value))
        -:  458:        {
    #####:  459:          break;
        -:  460:        }
        -:  461:
    #####:  462:        if (ecma_is_value_false (next_value))
        -:  463:        {
    #####:  464:          ret_value = ECMA_VALUE_EMPTY;
    #####:  465:          break;
        -:  466:        }
        -:  467:
    #####:  468:        ecma_value_t value = ecma_op_iterator_value (next_value);
        -:  469:
    #####:  470:        ecma_free_value (next_value);
        -:  471:
    #####:  472:        if (ECMA_IS_VALUE_ERROR (value))
        -:  473:        {
    #####:  474:          break;
        -:  475:        }
        -:  476:
    #####:  477:        ecma_collection_push_back (buff_p, value);
        -:  478:      }
        -:  479:    }
        -:  480:
    #####:  481:    ecma_free_value (iterator);
    #####:  482:    ecma_free_value (next_method);
    #####:  483:    ecma_free_value (spread_value);
        -:  484:
    #####:  485:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  486:    {
    #####:  487:      for (uint32_t k = i + 1; k < arguments_list_len; k++)
        -:  488:      {
    #####:  489:        ecma_free_value (*stack_top_p++);
        -:  490:      }
        -:  491:
    #####:  492:      ecma_collection_free (buff_p);
    #####:  493:      buff_p = NULL;
    #####:  494:      break;
        -:  495:    }
        -:  496:  }
        -:  497:
    #####:  498:  return buff_p;
        -:  499:} /* opfunc_spread_arguments */
        -:  500:
        -:  501:#endif /* JERRY_ESNEXT */
        -:  502:
        -:  503:/**
        -:  504: * 'VM_OC_APPEND_ARRAY' opcode handler, for setting array object properties
        -:  505: *
        -:  506: * @return ECMA_VALUE_ERROR - if the operation failed
        -:  507: *         ECMA_VALUE_EMPTY, otherwise
        -:  508: */
        -:  509:ecma_value_t JERRY_ATTR_NOINLINE
    #####:  510:opfunc_append_array (ecma_value_t *stack_top_p, /**< current stack top */
        -:  511:                     uint16_t values_length) /**< number of elements to set
        -:  512:                                              *   with potential OPFUNC_HAS_SPREAD_ELEMENT flag */
        -:  513:{
        -:  514:#if JERRY_ESNEXT
    #####:  515:  if (values_length >= OPFUNC_HAS_SPREAD_ELEMENT)
        -:  516:  {
    #####:  517:    return opfunc_append_to_spread_array (stack_top_p, (uint16_t) (values_length & ~OPFUNC_HAS_SPREAD_ELEMENT));
        -:  518:  }
        -:  519:#endif /* JERRY_ESNEXT */
        -:  520:
    #####:  521:  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####:  522:  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  523:
    #####:  524:  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####:  525:  uint32_t old_length = ext_array_obj_p->u.array.length;
        -:  526:
    #####:  527:  if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_array_obj_p)))
        -:  528:  {
    #####:  529:    uint32_t filled_holes = 0;
    #####:  530:    ecma_value_t *values_p = ecma_fast_array_extend (array_obj_p, old_length + values_length);
        -:  531:
    #####:  532:    for (uint32_t i = 0; i < values_length; i++)
        -:  533:    {
    #####:  534:      values_p[old_length + i] = stack_top_p[i];
        -:  535:
    #####:  536:      if (!ecma_is_value_array_hole (stack_top_p[i]))
        -:  537:      {
    #####:  538:        filled_holes++;
        -:  539:
    #####:  540:        ecma_deref_if_object (stack_top_p[i]);
        -:  541:      }
        -:  542:    }
        -:  543:
    #####:  544:    ext_array_obj_p->u.array.length_prop_and_hole_count -= filled_holes * ECMA_FAST_ARRAY_HOLE_ONE;
        -:  545:
    #####:  546:    if (JERRY_UNLIKELY ((values_length - filled_holes) > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT))
        -:  547:    {
    #####:  548:      ecma_fast_array_convert_to_normal (array_obj_p);
        -:  549:    }
        -:  550:  }
        -:  551:  else
        -:  552:  {
    #####:  553:    for (uint32_t i = 0; i < values_length; i++)
        -:  554:    {
    #####:  555:      if (!ecma_is_value_array_hole (stack_top_p[i]))
        -:  556:      {
    #####:  557:        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (old_length + i);
        -:  558:
        -:  559:        ecma_property_value_t *prop_value_p;
        -:  560:
    #####:  561:        prop_value_p = ecma_create_named_data_property (array_obj_p,
        -:  562:                                                        index_str_p,
        -:  563:                                                        ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  564:                                                        NULL);
        -:  565:
    #####:  566:        ecma_deref_ecma_string (index_str_p);
    #####:  567:        prop_value_p->value = stack_top_p[i];
    #####:  568:        ecma_deref_if_object (stack_top_p[i]);
        -:  569:      }
        -:  570:    }
    #####:  571:    ext_array_obj_p->u.array.length = old_length + values_length;
        -:  572:  }
        -:  573:
    #####:  574:  return ECMA_VALUE_EMPTY;
        -:  575:} /* opfunc_append_array */
        -:  576:
        -:  577:#if JERRY_ESNEXT
        -:  578:
        -:  579:/**
        -:  580: * Create an executable object using the current frame context
        -:  581: *
        -:  582: * @return executable object
        -:  583: */
        -:  584:vm_executable_object_t *
    #####:  585:opfunc_create_executable_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  586:                                 vm_create_executable_object_type_t type) /**< executable object type */
        -:  587:{
    #####:  588:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -:  589:  size_t size, register_end;
        -:  590:
    #####:  591:  ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_header_p);
        -:  592:
    #####:  593:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  594:  {
    #####:  595:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  596:    register_end = (size_t) args_p->register_end;
    #####:  597:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -:  598:  }
        -:  599:  else
        -:  600:  {
    #####:  601:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  602:    register_end = (size_t) args_p->register_end;
    #####:  603:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -:  604:  }
        -:  605:
    #####:  606:  size_t total_size = JERRY_ALIGNUP (sizeof (vm_executable_object_t) + size, sizeof (uintptr_t));
        -:  607:
    #####:  608:  ecma_object_t *proto_p = NULL;
        -:  609:  /* Async function objects are not accessible, so their class_id is not relevant. */
    #####:  610:  uint8_t class_type = ECMA_OBJECT_CLASS_GENERATOR;
        -:  611:
    #####:  612:  if (type == VM_CREATE_EXECUTABLE_OBJECT_GENERATOR)
        -:  613:  {
    #####:  614:    ecma_builtin_id_t default_proto_id = ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE;
        -:  615:
    #####:  616:    if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR)
        -:  617:    {
    #####:  618:      default_proto_id = ECMA_BUILTIN_ID_ASYNC_GENERATOR_PROTOTYPE;
    #####:  619:      class_type = ECMA_OBJECT_CLASS_ASYNC_GENERATOR;
        -:  620:    }
        -:  621:
    #####:  622:    JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####:  623:    proto_p = ecma_op_get_prototype_from_constructor (frame_ctx_p->shared_p->function_object_p, default_proto_id);
        -:  624:  }
        -:  625:
    #####:  626:  ecma_object_t *object_p = ecma_create_object (proto_p, total_size, ECMA_OBJECT_TYPE_CLASS);
        -:  627:
    #####:  628:  vm_executable_object_t *executable_object_p = (vm_executable_object_t *) object_p;
        -:  629:
    #####:  630:  if (type == VM_CREATE_EXECUTABLE_OBJECT_GENERATOR)
        -:  631:  {
    #####:  632:    ecma_deref_object (proto_p);
        -:  633:  }
        -:  634:
    #####:  635:  executable_object_p->extended_object.u.cls.type = class_type;
    #####:  636:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags = 0;
    #####:  637:  ECMA_SET_INTERNAL_VALUE_ANY_POINTER (executable_object_p->extended_object.u.cls.u3.head, NULL);
    #####:  638:  executable_object_p->iterator = ECMA_VALUE_UNDEFINED;
        -:  639:
    #####:  640:  JERRY_ASSERT (!(frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL));
        -:  641:
        -:  642:  /* Copy shared data and frame context. */
    #####:  643:  vm_frame_ctx_shared_t *new_shared_p = &(executable_object_p->shared);
    #####:  644:  *new_shared_p = *(frame_ctx_p->shared_p);
    #####:  645:  new_shared_p->status_flags &= (uint32_t) ~VM_FRAME_CTX_SHARED_HAS_ARG_LIST;
    #####:  646:  new_shared_p->status_flags |= VM_FRAME_CTX_SHARED_EXECUTABLE;
        -:  647:
    #####:  648:  vm_frame_ctx_t *new_frame_ctx_p = &(executable_object_p->frame_ctx);
    #####:  649:  *new_frame_ctx_p = *frame_ctx_p;
    #####:  650:  new_frame_ctx_p->shared_p = new_shared_p;
        -:  651:
        -:  652:  /* The old register values are discarded. */
    #####:  653:  ecma_value_t *new_registers_p = VM_GET_REGISTERS (new_frame_ctx_p);
    #####:  654:  memcpy (new_registers_p, VM_GET_REGISTERS (frame_ctx_p), size);
        -:  655:
    #####:  656:  size_t stack_top = (size_t) (frame_ctx_p->stack_top_p - VM_GET_REGISTERS (frame_ctx_p));
    #####:  657:  ecma_value_t *new_stack_top_p = new_registers_p + stack_top;
        -:  658:
    #####:  659:  new_frame_ctx_p->stack_top_p = new_stack_top_p;
        -:  660:
        -:  661:  /* Initial state is "not running", so all object references are released. */
        -:  662:
    #####:  663:  if (frame_ctx_p->context_depth > 0)
        -:  664:  {
    #####:  665:    JERRY_ASSERT (type != VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -:  666:
    #####:  667:    ecma_value_t *register_end_p = new_registers_p + register_end;
        -:  668:
    #####:  669:    JERRY_ASSERT (register_end_p <= new_stack_top_p);
        -:  670:
    #####:  671:    while (new_registers_p < register_end_p)
        -:  672:    {
    #####:  673:      ecma_deref_if_object (*new_registers_p++);
        -:  674:    }
        -:  675:
    #####:  676:    vm_ref_lex_env_chain (frame_ctx_p->lex_env_p, frame_ctx_p->context_depth, new_registers_p, false);
        -:  677:
    #####:  678:    new_registers_p += frame_ctx_p->context_depth;
        -:  679:
    #####:  680:    JERRY_ASSERT (new_registers_p <= new_stack_top_p);
        -:  681:  }
        -:  682:
    #####:  683:  while (new_registers_p < new_stack_top_p)
        -:  684:  {
    #####:  685:    ecma_deref_if_object (*new_registers_p++);
        -:  686:  }
        -:  687:
    #####:  688:  JERRY_ASSERT (*VM_GET_EXECUTABLE_ITERATOR (new_frame_ctx_p) == ECMA_VALUE_UNDEFINED);
        -:  689:
    #####:  690:  new_frame_ctx_p->this_binding = ecma_copy_value_if_not_object (new_frame_ctx_p->this_binding);
        -:  691:
    #####:  692:  JERRY_CONTEXT (vm_top_context_p) = new_frame_ctx_p->prev_context_p;
        -:  693:
    #####:  694:  return executable_object_p;
        -:  695:} /* opfunc_create_executable_object */
        -:  696:
        -:  697:/**
        -:  698: * Byte code which resumes an executable object with throw
        -:  699: */
        -:  700:const uint8_t opfunc_resume_executable_object_with_throw[1] = { CBC_THROW };
        -:  701:
        -:  702:/**
        -:  703: * Byte code which resumes an executable object with return
        -:  704: */
        -:  705:const uint8_t opfunc_resume_executable_object_with_return[2] = { CBC_EXT_OPCODE, CBC_EXT_RETURN };
        -:  706:
        -:  707:/**
        -:  708: * Resume the execution of an inactive executable object
        -:  709: *
        -:  710: * @return value provided by the execution
        -:  711: */
        -:  712:ecma_value_t
    #####:  713:opfunc_resume_executable_object (vm_executable_object_t *executable_object_p, /**< executable object */
        -:  714:                                 ecma_value_t value) /**< value pushed onto the stack (takes the reference) */
        -:  715:{
    #####:  716:  const ecma_compiled_code_t *bytecode_header_p = executable_object_p->shared.bytecode_header_p;
    #####:  717:  ecma_value_t *register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
        -:  718:  ecma_value_t *register_end_p;
        -:  719:
    #####:  720:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  721:  {
    #####:  722:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  723:    register_end_p = register_p + args_p->register_end;
        -:  724:  }
        -:  725:  else
        -:  726:  {
    #####:  727:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  728:    register_end_p = register_p + args_p->register_end;
        -:  729:  }
        -:  730:
    #####:  731:  ecma_value_t *stack_top_p = executable_object_p->frame_ctx.stack_top_p;
        -:  732:
    #####:  733:  if (value != ECMA_VALUE_EMPTY)
        -:  734:  {
    #####:  735:    *stack_top_p = value;
    #####:  736:    executable_object_p->frame_ctx.stack_top_p = stack_top_p + 1;
        -:  737:  }
        -:  738:
    #####:  739:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  740:  {
    #####:  741:    while (register_p < register_end_p)
        -:  742:    {
    #####:  743:      ecma_ref_if_object (*register_p++);
        -:  744:    }
        -:  745:
    #####:  746:    vm_ref_lex_env_chain (executable_object_p->frame_ctx.lex_env_p,
    #####:  747:                          executable_object_p->frame_ctx.context_depth,
        -:  748:                          register_p,
        -:  749:                          true);
        -:  750:
    #####:  751:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  752:  }
        -:  753:
    #####:  754:  while (register_p < stack_top_p)
        -:  755:  {
    #####:  756:    ecma_ref_if_object (*register_p++);
        -:  757:  }
        -:  758:
    #####:  759:  ecma_ref_if_object (executable_object_p->iterator);
        -:  760:
    #####:  761:  JERRY_ASSERT (ECMA_EXECUTABLE_OBJECT_IS_SUSPENDED (executable_object_p));
        -:  762:
    #####:  763:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_RUNNING;
        -:  764:
    #####:  765:  executable_object_p->frame_ctx.prev_context_p = JERRY_CONTEXT (vm_top_context_p);
    #####:  766:  JERRY_CONTEXT (vm_top_context_p) = &executable_object_p->frame_ctx;
        -:  767:
        -:  768:  /* inside the generators the "new.target" is always "undefined" as it can't be invoked with "new" */
    #####:  769:  ecma_object_t *old_new_target = JERRY_CONTEXT (current_new_target_p);
    #####:  770:  JERRY_CONTEXT (current_new_target_p) = NULL;
        -:  771:
        -:  772:#if JERRY_BUILTIN_REALMS
    #####:  773:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
    #####:  774:  JERRY_CONTEXT (global_object_p) = ecma_op_function_get_realm (bytecode_header_p);
        -:  775:#endif /* JERRY_BUILTIN_REALMS */
        -:  776:
    #####:  777:  ecma_value_t result = vm_execute (&executable_object_p->frame_ctx);
        -:  778:
        -:  779:#if JERRY_BUILTIN_REALMS
    #####:  780:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  781:#endif /* JERRY_BUILTIN_REALMS */
        -:  782:
    #####:  783:  JERRY_CONTEXT (current_new_target_p) = old_new_target;
    #####:  784:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags &= (uint8_t) ~ECMA_EXECUTABLE_OBJECT_RUNNING;
        -:  785:
    #####:  786:  if (executable_object_p->frame_ctx.call_operation != VM_EXEC_RETURN)
        -:  787:  {
    #####:  788:    JERRY_ASSERT (executable_object_p->frame_ctx.call_operation == VM_NO_EXEC_OP);
        -:  789:
        -:  790:    /* All resources are released. */
    #####:  791:    executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_COMPLETED;
    #####:  792:    return result;
        -:  793:  }
        -:  794:
    #####:  795:  JERRY_CONTEXT (vm_top_context_p) = executable_object_p->frame_ctx.prev_context_p;
        -:  796:
    #####:  797:  register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
    #####:  798:  stack_top_p = executable_object_p->frame_ctx.stack_top_p;
        -:  799:
    #####:  800:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  801:  {
    #####:  802:    while (register_p < register_end_p)
        -:  803:    {
    #####:  804:      ecma_deref_if_object (*register_p++);
        -:  805:    }
        -:  806:
    #####:  807:    vm_ref_lex_env_chain (executable_object_p->frame_ctx.lex_env_p,
    #####:  808:                          executable_object_p->frame_ctx.context_depth,
        -:  809:                          register_p,
        -:  810:                          false);
        -:  811:
    #####:  812:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  813:  }
        -:  814:
    #####:  815:  while (register_p < stack_top_p)
        -:  816:  {
    #####:  817:    ecma_deref_if_object (*register_p++);
        -:  818:  }
        -:  819:
    #####:  820:  ecma_deref_if_object (executable_object_p->iterator);
        -:  821:
    #####:  822:  return result;
        -:  823:} /* opfunc_resume_executable_object */
        -:  824:
        -:  825:/**
        -:  826: * Fulfill the next promise of the async generator with the value
        -:  827: */
        -:  828:void
    #####:  829:opfunc_async_generator_yield (ecma_extended_object_t *async_generator_object_p, /**< async generator object */
        -:  830:                              ecma_value_t value) /**< value (takes the reference) */
        -:  831:{
        -:  832:  ecma_async_generator_task_t *task_p;
    #####:  833:  task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, async_generator_object_p->u.cls.u3.head);
        -:  834:
    #####:  835:  ecma_value_t iter_result = ecma_create_iter_result_object (value, ECMA_VALUE_FALSE);
    #####:  836:  ecma_fulfill_promise (task_p->promise, iter_result);
        -:  837:
    #####:  838:  ecma_free_value (iter_result);
    #####:  839:  ecma_free_value (value);
        -:  840:
    #####:  841:  ecma_value_t next = task_p->next;
    #####:  842:  async_generator_object_p->u.cls.u3.head = next;
        -:  843:
    #####:  844:  JERRY_ASSERT (task_p->operation_value == ECMA_VALUE_UNDEFINED);
    #####:  845:  jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -:  846:
    #####:  847:  if (!ECMA_IS_INTERNAL_VALUE_NULL (next))
        -:  848:  {
    #####:  849:    ecma_value_t executable_object = ecma_make_object_value ((ecma_object_t *) async_generator_object_p);
    #####:  850:    ecma_enqueue_promise_async_generator_job (executable_object);
        -:  851:  }
    #####:  852:} /* opfunc_async_generator_yield */
        -:  853:
        -:  854:/**
        -:  855: * Creates a new executable object and awaits for the value
        -:  856: *
        -:  857: * Note:
        -:  858: *   extra_flags can be used to set additional extra_info flags
        -:  859: *
        -:  860: * @return a new Promise object on success, error otherwise
        -:  861: */
        -:  862:ecma_value_t
    #####:  863:opfunc_async_create_and_await (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  864:                               ecma_value_t value, /**< awaited value (takes reference) */
        -:  865:                               uint16_t extra_flags) /**< extra flags */
        -:  866:{
    #####:  867:  JERRY_ASSERT (
        -:  868:    CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC
        -:  869:    || (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_ARROW));
        -:  870:
    #####:  871:  ecma_object_t *promise_p = ecma_builtin_get (ECMA_BUILTIN_ID_PROMISE);
    #####:  872:  ecma_value_t result = ecma_promise_reject_or_resolve (ecma_make_object_value (promise_p), value, true);
    #####:  873:  ecma_free_value (value);
        -:  874:
    #####:  875:  if (ECMA_IS_VALUE_ERROR (result))
        -:  876:  {
    #####:  877:    return result;
        -:  878:  }
        -:  879:
        -:  880:  vm_executable_object_t *executable_object_p;
    #####:  881:  executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_ASYNC);
        -:  882:
    #####:  883:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= extra_flags;
        -:  884:
    #####:  885:  ecma_promise_async_then (result, ecma_make_object_value ((ecma_object_t *) executable_object_p));
    #####:  886:  ecma_deref_object ((ecma_object_t *) executable_object_p);
    #####:  887:  ecma_free_value (result);
        -:  888:
    #####:  889:  result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, promise_p);
        -:  890:
    #####:  891:  JERRY_ASSERT (ecma_is_value_object (result));
    #####:  892:  executable_object_p->iterator = result;
        -:  893:
    #####:  894:  return result;
        -:  895:} /* opfunc_async_create_and_await */
        -:  896:
        -:  897:/**
        -:  898: * PrivateMethodOrAccessorAdd abstact operation.
        -:  899: *
        -:  900: * See also: ECMAScript v12, 7.3.29.
        -:  901: *
        -:  902: * @return ECMA_VALUE_ERROR - initialization fails
        -:  903: *         ECMA_VALUE_UNDEFINED - otherwise
        -:  904: */
        -:  905:static ecma_value_t
        2:  906:opfunc_private_method_or_accessor_add (ecma_object_t *class_object_p, /**< the function itself */
        -:  907:                                       ecma_object_t *this_obj_p, /**< this object */
        -:  908:                                       uint32_t static_flag)
        -:  909:{
        2:  910:  ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
        2:  911:  ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -:  912:
        2:  913:  if (prop_p == NULL)
        -:  914:  {
    #####:  915:    return ECMA_VALUE_UNDEFINED;
        -:  916:  }
        -:  917:
        2:  918:  ecma_value_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
        2:  919:  ecma_value_t *current_p = collection_p + 1;
        2:  920:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -:  921:
        6:  922:  while (current_p < end_p)
        -:  923:  {
        2:  924:    uint32_t prop_desc = *current_p++;
        2:  925:    ecma_private_property_kind_t kind = ECMA_PRIVATE_PROPERTY_KIND (prop_desc);
        -:  926:
        2:  927:    if ((prop_desc & ECMA_PRIVATE_PROPERTY_STATIC_FLAG) != static_flag || kind == ECMA_PRIVATE_FIELD)
        -:  928:    {
        1:  929:      current_p += 2;
        1:  930:      continue;
        -:  931:    }
        -:  932:
        1:  933:    ecma_string_t *prop_name_p = ecma_get_symbol_from_value (*current_p++);
        1:  934:    ecma_value_t method = *current_p++;
        -:  935:
        1:  936:    JERRY_ASSERT (prop_name_p->u.hash & ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD);
        -:  937:
        1:  938:    prop_p = ecma_find_named_property (this_obj_p, prop_name_p);
        1:  939:    ecma_object_t *method_p = ecma_get_object_from_value (method);
        -:  940:
        1:  941:    if (kind == ECMA_PRIVATE_METHOD)
        -:  942:    {
    #####:  943:      if (prop_p != NULL)
        -:  944:      {
    #####:  945:        return ecma_raise_type_error (ECMA_ERR_CANNOT_DECLARE_SAME_PRIVATE_FIELD_TWICE);
        -:  946:      }
        -:  947:
    #####:  948:      ecma_property_value_t *prop_value_p =
        -:  949:        ecma_create_named_data_property (this_obj_p, prop_name_p, ECMA_PROPERTY_FIXED, NULL);
    #####:  950:      prop_value_p->value = method;
    #####:  951:      continue;
        -:  952:    }
        -:  953:
        1:  954:    if (prop_p == NULL)
        -:  955:    {
        1:  956:      ecma_object_t *getter_p = (kind == ECMA_PRIVATE_GETTER) ? method_p : NULL;
        1:  957:      ecma_object_t *setter_p = (kind == ECMA_PRIVATE_SETTER) ? method_p : NULL;
        1:  958:      ecma_create_named_accessor_property (this_obj_p, prop_name_p, getter_p, setter_p, ECMA_PROPERTY_FIXED, NULL);
        1:  959:      continue;
        -:  960:    }
        -:  961:
    #####:  962:    ecma_property_value_t *accessor_objs_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####:  963:    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);
        -:  964:
    #####:  965:    if (kind == ECMA_PRIVATE_GETTER)
        -:  966:    {
    #####:  967:      ECMA_SET_POINTER (get_set_pair_p->getter_cp, method_p);
        -:  968:    }
        -:  969:    else
        -:  970:    {
    #####:  971:      JERRY_ASSERT (kind == ECMA_PRIVATE_SETTER);
    #####:  972:      ECMA_SET_POINTER (get_set_pair_p->setter_cp, method_p);
        -:  973:    }
        -:  974:  }
        -:  975:
        2:  976:  return ECMA_VALUE_UNDEFINED;
        -:  977:} /* opfunc_private_method_or_accessor_add */
        -:  978:
        -:  979:/**
        -:  980: * DefineField abstract operation.
        -:  981: *
        -:  982: * See also: ECMAScript v12, 7.3.32.
        -:  983: *
        -:  984: * @return ECMA_VALUE_ERROR - operation fails
        -:  985: *         ECMA_VALUE_{TRUE/FALSE} - otherwise
        -:  986: */
        -:  987:ecma_value_t
    #####:  988:opfunc_define_field (ecma_value_t base, ecma_value_t property, ecma_value_t value)
        -:  989:{
    #####:  990:  ecma_string_t *property_key_p = ecma_op_to_property_key (property);
        -:  991:
    #####:  992:  JERRY_ASSERT (property_key_p != NULL);
    #####:  993:  ecma_object_t *obj_p = ecma_get_object_from_value (base);
    #####:  994:  ecma_property_descriptor_t desc = ecma_make_empty_property_descriptor ();
    #####:  995:  desc.value = value;
    #####:  996:  desc.flags = (JERRY_PROP_IS_WRITABLE | JERRY_PROP_IS_WRITABLE_DEFINED | JERRY_PROP_IS_ENUMERABLE
        -:  997:                | JERRY_PROP_IS_ENUMERABLE_DEFINED | JERRY_PROP_IS_CONFIGURABLE | JERRY_PROP_IS_CONFIGURABLE_DEFINED
        -:  998:                | JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_SHOULD_THROW);
        -:  999:
    #####: 1000:  ecma_value_t result = ecma_op_object_define_own_property (obj_p, property_key_p, &desc);
    #####: 1001:  ecma_deref_ecma_string (property_key_p);
        -: 1002:
    #####: 1003:  return result;
        -: 1004:} /* opfunc_define_field */
        -: 1005:
        -: 1006:/**
        -: 1007: * Initialize class fields.
        -: 1008: *
        -: 1009: * @return ECMA_VALUE_ERROR - initialization fails
        -: 1010: *         ECMA_VALUE_UNDEFINED - otherwise
        -: 1011: */
        -: 1012:ecma_value_t
        1: 1013:opfunc_init_class_fields (ecma_object_t *class_object_p, /**< the function itself */
        -: 1014:                          ecma_value_t this_val) /**< this_arg of the function */
        -: 1015:{
        1: 1016:  JERRY_ASSERT (ecma_is_value_object (this_val));
        1: 1017:  ecma_object_t *this_obj_p = ecma_get_object_from_value (this_val);
        -: 1018:
        1: 1019:  ecma_value_t result = opfunc_private_method_or_accessor_add (class_object_p, this_obj_p, 0);
        -: 1020:
        1: 1021:  if (ECMA_IS_VALUE_ERROR (result))
        -: 1022:  {
    #####: 1023:    return result;
        -: 1024:  }
        -: 1025:
        1: 1026:  ecma_string_t *name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
        1: 1027:  ecma_property_t *property_p = ecma_find_named_property (class_object_p, name_p);
        -: 1028:
        1: 1029:  if (property_p == NULL)
        -: 1030:  {
        1: 1031:    return ECMA_VALUE_UNDEFINED;
        -: 1032:  }
        -: 1033:
    #####: 1034:  vm_frame_ctx_shared_class_fields_t shared_class_fields;
    #####: 1035:  shared_class_fields.header.status_flags = VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS;
    #####: 1036:  shared_class_fields.computed_class_fields_p = NULL;
        -: 1037:
    #####: 1038:  name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 1039:  ecma_property_t *class_field_property_p = ecma_find_named_property (class_object_p, name_p);
        -: 1040:
    #####: 1041:  if (class_field_property_p != NULL)
        -: 1042:  {
    #####: 1043:    ecma_value_t value = ECMA_PROPERTY_VALUE_PTR (class_field_property_p)->value;
    #####: 1044:    shared_class_fields.computed_class_fields_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
        -: 1045:  }
        -: 1046:
    #####: 1047:  ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1048:  JERRY_ASSERT (ecma_op_is_callable (property_value_p->value));
        -: 1049:
        -: 1050:  ecma_extended_object_t *ext_function_p;
    #####: 1051:  ext_function_p = (ecma_extended_object_t *) ecma_get_object_from_value (property_value_p->value);
    #####: 1052:  shared_class_fields.header.bytecode_header_p = ecma_op_function_get_compiled_code (ext_function_p);
    #####: 1053:  shared_class_fields.header.function_object_p = &ext_function_p->object;
        -: 1054:
    #####: 1055:  ecma_object_t *scope_p =
    #####: 1056:    ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_function_p->u.function.scope_cp);
        -: 1057:
    #####: 1058:  result = vm_run (&shared_class_fields.header, this_val, scope_p);
        -: 1059:
    #####: 1060:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result) || result == ECMA_VALUE_UNDEFINED);
    #####: 1061:  return result;
        -: 1062:} /* opfunc_init_class_fields */
        -: 1063:
        -: 1064:/**
        -: 1065: * Initialize static class fields.
        -: 1066: *
        -: 1067: * @return ECMA_VALUE_ERROR - initialization fails
        -: 1068: *         ECMA_VALUE_UNDEFINED - otherwise
        -: 1069: */
        -: 1070:ecma_value_t
    #####: 1071:opfunc_init_static_class_fields (ecma_value_t function_object, /**< the function itself */
        -: 1072:                                 ecma_value_t this_val) /**< this_arg of the function */
        -: 1073:{
    #####: 1074:  JERRY_ASSERT (ecma_op_is_callable (function_object));
    #####: 1075:  JERRY_ASSERT (ecma_is_value_object (this_val));
        -: 1076:
    #####: 1077:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 1078:  ecma_object_t *function_object_p = ecma_get_object_from_value (function_object);
    #####: 1079:  ecma_property_t *class_field_property_p = ecma_find_named_property (function_object_p, name_p);
        -: 1080:
    #####: 1081:  vm_frame_ctx_shared_class_fields_t shared_class_fields;
    #####: 1082:  shared_class_fields.header.function_object_p = function_object_p;
    #####: 1083:  shared_class_fields.header.status_flags = VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS;
    #####: 1084:  shared_class_fields.computed_class_fields_p = NULL;
        -: 1085:
    #####: 1086:  if (class_field_property_p != NULL)
        -: 1087:  {
    #####: 1088:    ecma_value_t value = ECMA_PROPERTY_VALUE_PTR (class_field_property_p)->value;
    #####: 1089:    shared_class_fields.computed_class_fields_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
        -: 1090:  }
        -: 1091:
    #####: 1092:  ecma_extended_object_t *ext_function_p = (ecma_extended_object_t *) function_object_p;
    #####: 1093:  shared_class_fields.header.bytecode_header_p = ecma_op_function_get_compiled_code (ext_function_p);
        -: 1094:
    #####: 1095:  ecma_object_t *scope_p =
    #####: 1096:    ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, ext_function_p->u.function.scope_cp);
        -: 1097:
    #####: 1098:  ecma_value_t result = vm_run (&shared_class_fields.header, this_val, scope_p);
        -: 1099:
    #####: 1100:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result) || result == ECMA_VALUE_UNDEFINED);
    #####: 1101:  return result;
        -: 1102:} /* opfunc_init_static_class_fields */
        -: 1103:
        -: 1104:/**
        -: 1105: * Add the name of a computed field to a name list
        -: 1106: *
        -: 1107: * @return ECMA_VALUE_ERROR - name is not a valid property name
        -: 1108: *         ECMA_VALUE_UNDEFINED - otherwise
        -: 1109: */
        -: 1110:ecma_value_t
    #####: 1111:opfunc_add_computed_field (ecma_value_t class_object, /**< class object */
        -: 1112:                           ecma_value_t name) /**< name of the property */
        -: 1113:{
    #####: 1114:  ecma_string_t *prop_name_p = ecma_op_to_property_key (name);
        -: 1115:
    #####: 1116:  if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1117:  {
    #####: 1118:    return ECMA_VALUE_ERROR;
        -: 1119:  }
        -: 1120:
    #####: 1121:  if (ecma_prop_name_is_symbol (prop_name_p))
        -: 1122:  {
    #####: 1123:    name = ecma_make_symbol_value (prop_name_p);
        -: 1124:  }
        -: 1125:  else
        -: 1126:  {
    #####: 1127:    name = ecma_make_string_value (prop_name_p);
        -: 1128:  }
        -: 1129:
    #####: 1130:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 1131:  ecma_object_t *class_object_p = ecma_get_object_from_value (class_object);
        -: 1132:
    #####: 1133:  ecma_property_t *property_p = ecma_find_named_property (class_object_p, name_p);
        -: 1134:  ecma_value_t *compact_collection_p;
        -: 1135:  ecma_property_value_t *property_value_p;
        -: 1136:
    #####: 1137:  if (property_p == NULL)
        -: 1138:  {
    #####: 1139:    ECMA_CREATE_INTERNAL_PROPERTY (class_object_p, name_p, property_p, property_value_p);
    #####: 1140:    compact_collection_p = ecma_new_compact_collection ();
        -: 1141:  }
        -: 1142:  else
        -: 1143:  {
    #####: 1144:    property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1145:    compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, property_value_p->value);
        -: 1146:  }
        -: 1147:
    #####: 1148:  compact_collection_p = ecma_compact_collection_push_back (compact_collection_p, name);
    #####: 1149:  ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
    #####: 1150:  return ECMA_VALUE_UNDEFINED;
        -: 1151:} /* opfunc_add_computed_field */
        -: 1152:
        -: 1153:/**
        -: 1154: * Create implicit class constructor
        -: 1155: *
        -: 1156: * See also: ECMAScript v6, 14.5.14
        -: 1157: *
        -: 1158: * @return - new external function ecma-object
        -: 1159: */
        -: 1160:ecma_value_t
        1: 1161:opfunc_create_implicit_class_constructor (uint8_t opcode, /**< current cbc opcode */
        -: 1162:                                          const ecma_compiled_code_t *bytecode_p) /**< current byte code */
        -: 1163:{
        -: 1164:  /* 8. */
        1: 1165:  ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
        1: 1166:  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 1167:
        1: 1168:  if (JERRY_UNLIKELY (script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -: 1169:  {
    #####: 1170:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -: 1171:  }
        -: 1172:
        1: 1173:  ecma_object_t *function_object_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE),
        -: 1174:                                                         sizeof (ecma_extended_object_t),
        -: 1175:                                                         ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION);
        -: 1176:
        1: 1177:  ecma_extended_object_t *constructor_object_p = (ecma_extended_object_t *) function_object_p;
        -: 1178:
        1: 1179:  script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
        1: 1180:  constructor_object_p->u.constructor_function.script_value = script_value;
        1: 1181:  constructor_object_p->u.constructor_function.flags = 0;
        -: 1182:
        -: 1183:  /* 10.a.i */
        1: 1184:  if (opcode == CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR_HERITAGE)
        -: 1185:  {
    #####: 1186:    constructor_object_p->u.constructor_function.flags |= ECMA_CONSTRUCTOR_FUNCTION_HAS_HERITAGE;
        -: 1187:  }
        -: 1188:
        -: 1189:  ecma_property_value_t *prop_value_p;
        1: 1190:  prop_value_p = ecma_create_named_data_property (function_object_p,
        -: 1191:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -: 1192:                                                  ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 1193:                                                  NULL);
        1: 1194:  prop_value_p->value = ecma_make_uint32_value (0);
        -: 1195:
        1: 1196:  return ecma_make_object_value (function_object_p);
        -: 1197:} /* opfunc_create_implicit_class_constructor */
        -: 1198:
        -: 1199:/**
        -: 1200: * Set the [[HomeObject]] attribute of the given functon object
        -: 1201: */
        -: 1202:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1203:opfunc_set_home_object (ecma_object_t *func_p, /**< function object */
        -: 1204:                        ecma_object_t *parent_env_p) /**< parent environment */
        -: 1205:{
        2: 1206:  JERRY_ASSERT (ecma_is_lexical_environment (parent_env_p));
        -: 1207:
        2: 1208:  if (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1209:  {
        2: 1210:    ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
        2: 1211:    ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp,
        -: 1212:                                   parent_env_p,
        -: 1213:                                   JMEM_CP_GET_POINTER_TAG_BITS (ext_func_p->u.function.scope_cp));
        -: 1214:  }
    #####: 1215:} /* opfunc_set_home_object */
        -: 1216:
        -: 1217:/**
        -: 1218: * Make private key from descriptor
        -: 1219: */
        -: 1220:ecma_string_t *
        1: 1221:opfunc_make_private_key (ecma_value_t descriptor) /**< descriptor */
        -: 1222:{
        1: 1223:  ecma_string_t *private_key_p = ecma_new_symbol_from_descriptor_string (descriptor);
        1: 1224:  private_key_p->u.hash |= ECMA_SYMBOL_FLAG_PRIVATE_KEY;
        -: 1225:
        1: 1226:  return (ecma_string_t *) private_key_p;
        -: 1227:} /* opfunc_make_private_key */
        -: 1228:
        -: 1229:/**
        -: 1230: * Find a private property in the private elements internal property given the key
        -: 1231: */
        -: 1232:static ecma_property_t *
    #####: 1233:opfunc_find_private_key (ecma_object_t *class_object_p, /**< class environment */
        -: 1234:                         ecma_object_t *obj_p, /**< object */
        -: 1235:                         ecma_string_t *search_key_p, /**< key */
        -: 1236:                         ecma_string_t **out_private_key_p) /**< [out] private key */
        -: 1237:{
    #####: 1238:  if (ecma_op_object_is_fast_array (obj_p))
        -: 1239:  {
    #####: 1240:    return NULL;
        -: 1241:  }
        -: 1242:
    #####: 1243:  ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
    #####: 1244:  ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -: 1245:
    #####: 1246:  if (prop_p == NULL)
        -: 1247:  {
    #####: 1248:    return NULL;
        -: 1249:  }
        -: 1250:
    #####: 1251:  ecma_value_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
    #####: 1252:  ecma_value_t *current_p = collection_p + 1;
    #####: 1253:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1254:
    #####: 1255:  while (current_p < end_p)
        -: 1256:  {
    #####: 1257:    current_p++; /* skip kind */
    #####: 1258:    ecma_string_t *private_key_p = ecma_get_prop_name_from_value (*current_p++);
    #####: 1259:    current_p++; /* skip value */
        -: 1260:
    #####: 1261:    JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1262:
    #####: 1263:    ecma_string_t *private_key_desc_p =
    #####: 1264:      ecma_get_string_from_value (((ecma_extended_string_t *) private_key_p)->u.symbol_descriptor);
        -: 1265:
    #####: 1266:    if (ecma_compare_ecma_strings (private_key_desc_p, search_key_p))
        -: 1267:    {
    #####: 1268:      prop_p = ecma_find_named_property (obj_p, private_key_p);
        -: 1269:
    #####: 1270:      if (out_private_key_p)
        -: 1271:      {
    #####: 1272:        *out_private_key_p = private_key_p;
        -: 1273:      }
        -: 1274:
    #####: 1275:      return prop_p;
        -: 1276:    }
        -: 1277:  }
        -: 1278:
    #####: 1279:  return NULL;
        -: 1280:} /* opfunc_find_private_key */
        -: 1281:
        -: 1282:/**
        -: 1283: * PrivateElementFind abstact operation
        -: 1284: *
        -: 1285: * See also: ECMAScript v12, 7.3.27
        -: 1286: *
        -: 1287: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1288: *           ECMA_VALUE_EMPTY - otherwise
        -: 1289: */
        -: 1290:static ecma_property_t *
    #####: 1291:opfunc_find_private_element (ecma_object_t *obj_p, /**< object */
        -: 1292:                             ecma_string_t *key_p, /**< key */
        -: 1293:                             ecma_string_t **private_key_p, /**< [out] private key */
        -: 1294:                             bool allow_heritage)
        -: 1295:{
    #####: 1296:  JERRY_ASSERT (private_key_p != NULL);
    #####: 1297:  JERRY_ASSERT (*private_key_p == NULL);
    #####: 1298:  ecma_object_t *lex_env_p = JERRY_CONTEXT (vm_top_context_p)->lex_env_p;
        -: 1299:
        -: 1300:  while (true)
        -: 1301:  {
    #####: 1302:    JERRY_ASSERT (lex_env_p != NULL);
        -: 1303:
    #####: 1304:    if (ecma_get_lex_env_type (lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
    #####: 1305:        && (lex_env_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA) != 0
    #####: 1306:        && !ECMA_LEX_ENV_CLASS_IS_MODULE (lex_env_p))
        -: 1307:    {
    #####: 1308:      ecma_object_t *class_object_p = ((ecma_lexical_environment_class_t *) lex_env_p)->object_p;
        -: 1309:
    #####: 1310:      ecma_property_t *prop_p = opfunc_find_private_key (class_object_p, obj_p, key_p, private_key_p);
        -: 1311:
    #####: 1312:      if (prop_p || *private_key_p != NULL)
        -: 1313:      {
        -: 1314:        /* Found non shadowed property */
    #####: 1315:        return prop_p;
        -: 1316:      }
        -: 1317:
    #####: 1318:      if (!allow_heritage)
        -: 1319:      {
    #####: 1320:        return NULL;
        -: 1321:      }
        -: 1322:    }
        -: 1323:
    #####: 1324:    if (lex_env_p->u2.outer_reference_cp == JMEM_CP_NULL)
        -: 1325:    {
    #####: 1326:      break;
        -: 1327:    }
        -: 1328:
    #####: 1329:    lex_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, lex_env_p->u2.outer_reference_cp);
        -: 1330:  }
        -: 1331:
    #####: 1332:  return NULL;
        -: 1333:} /* opfunc_find_private_element */
        -: 1334:
        -: 1335:/**
        -: 1336: * In expression runtime evaluation in case of private identifiers
        -: 1337: *
        -: 1338: * See also: ECMAScript v12, 13.10.1
        -: 1339: *
        -: 1340: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1341: *           ECMA_VALUE_TRUE - if the property was found in the base object
        -: 1342: *           ECMA_VALUE_FALSE - otherwise
        -: 1343: */
        -: 1344:ecma_value_t
    #####: 1345:opfunc_private_in (ecma_value_t base, ecma_value_t property)
        -: 1346:{
    #####: 1347:  if (!ecma_is_value_object (base))
        -: 1348:  {
    #####: 1349:    return ecma_raise_type_error (ECMA_ERR_RIGHT_VALUE_OF_IN_MUST_BE_AN_OBJECT);
        -: 1350:  }
        -: 1351:
    #####: 1352:  ecma_object_t *obj_p = ecma_get_object_from_value (base);
    #####: 1353:  ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (property);
    #####: 1354:  ecma_string_t *private_key_p = NULL;
        -: 1355:
    #####: 1356:  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, false);
        -: 1357:
    #####: 1358:  return ecma_make_boolean_value (prop_p != NULL);
        -: 1359:} /* opfunc_private_in */
        -: 1360:
        -: 1361:/**
        -: 1362: * PrivateFieldAdd abstact operation
        -: 1363: *
        -: 1364: * See also: ECMAScript v12, 7.3.28
        -: 1365: *
        -: 1366: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1367: *           ECMA_VALUE_EMPTY - otherwise
        -: 1368: */
        -: 1369:ecma_value_t
    #####: 1370:opfunc_private_field_add (ecma_value_t base, /**< base object */
        -: 1371:                          ecma_value_t property, /**< property name */
        -: 1372:                          ecma_value_t value) /**< ecma value */
        -: 1373:{
    #####: 1374:  ecma_object_t *obj_p = ecma_get_object_from_value (base);
    #####: 1375:  ecma_string_t *prop_name_p = ecma_get_string_from_value (property);
    #####: 1376:  ecma_string_t *private_key_p = NULL;
        -: 1377:
    #####: 1378:  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, false);
        -: 1379:
    #####: 1380:  if (prop_p != NULL)
        -: 1381:  {
    #####: 1382:    return ecma_raise_type_error (ECMA_ERR_CANNOT_DECLARE_SAME_PRIVATE_FIELD_TWICE);
        -: 1383:  }
        -: 1384:
    #####: 1385:  ecma_property_value_t *value_p =
    #####: 1386:    ecma_create_named_data_property (obj_p, private_key_p, ECMA_PROPERTY_FLAG_WRITABLE, NULL);
        -: 1387:
    #####: 1388:  value_p->value = ecma_copy_value_if_not_object (value);
        -: 1389:
    #####: 1390:  return ECMA_VALUE_EMPTY;
        -: 1391:} /* opfunc_private_field_add */
        -: 1392:
        -: 1393:/**
        -: 1394: * PrivateSet abstact operation
        -: 1395: *
        -: 1396: * See also: ECMAScript v12, 7.3.31
        -: 1397: *
        -: 1398: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1399: *           ECMA_VALUE_EMPTY - otherwise
        -: 1400: */
        -: 1401:ecma_value_t
        1: 1402:opfunc_private_set (ecma_value_t base, /**< this object */
        -: 1403:                    ecma_value_t property, /**< property name */
        -: 1404:                    ecma_value_t value) /**< ecma value */
        -: 1405:{
        1: 1406:  ecma_object_t *obj_p = ecma_get_object_from_value (base);
        -: 1407:
        -: 1408:
        1: 1409:  ecma_string_t *prop_name_p = ecma_get_string_from_value (property);
        1: 1410:  ecma_string_t *private_key_p = NULL;
        -: 1411:
    #####: 1412:  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, true);
        -: 1413:
        -: 1414:
    #####: 1415:  if (prop_p == NULL)
        -: 1416:  {
    #####: 1417:    return ecma_raise_type_error (ECMA_ERR_CANNOT_WRITE_PRIVATE_MEMBER_TO_AN_OBJECT_WHOSE_CLASS_DID_NOT_DECLARE_IT);
        -: 1418:  }
    #####: 1419:  if (*prop_p & ECMA_PROPERTY_FLAG_DATA)
        -: 1420:  {
    #####: 1421:    JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1422:
    #####: 1423:    if (private_key_p->u.hash & ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD)
        -: 1424:    {
    #####: 1425:      return ecma_raise_type_error (ECMA_ERR_PRIVATE_METHOD_IS_NOT_WRITABLE);
        -: 1426:    }
    #####: 1427:    ecma_value_assign_value (&ECMA_PROPERTY_VALUE_PTR (prop_p)->value, value);
    #####: 1428:    return ecma_copy_value (value);
        -: 1429:  }
    #####: 1430:  ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (prop_p));
        -: 1431:
        -: 1432:
    #####: 1433:  if (get_set_pair_p->setter_cp == JMEM_CP_NULL)
        -: 1434:  {
    #####: 1435:    return ecma_raise_type_error (ECMA_ERR_PRIVATE_FIELD_WAS_DEFINED_WITHOUT_A_SETTER);
        -: 1436:  }
        -: 1437:
    #####: 1438:  ecma_object_t *setter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp);
        -: 1439:
    #####: 1440:  return ecma_op_function_call (setter_p, base, &value, 1);
        -: 1441:} /* opfunc_private_set */
        -: 1442:
        -: 1443:/**
        -: 1444: * PrivateGet abstact operation
        -: 1445: *
        -: 1446: * See also: ECMAScript v12, 7.3.30
        -: 1447: *
        -: 1448: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1449: *           private property value - otherwise
        -: 1450: */
        -: 1451:ecma_value_t
    #####: 1452:opfunc_private_get (ecma_value_t base, /**< this object */
        -: 1453:                    ecma_value_t property) /**< property name */
        -: 1454:{
    #####: 1455:  ecma_value_t base_obj = ecma_op_to_object (base);
        -: 1456:
    #####: 1457:  if (ECMA_IS_VALUE_ERROR (base_obj))
        -: 1458:  {
    #####: 1459:    return base_obj;
        -: 1460:  }
        -: 1461:
    #####: 1462:  ecma_object_t *obj_p = ecma_get_object_from_value (base_obj);
    #####: 1463:  ecma_string_t *prop_name_p = ecma_get_string_from_value (property);
    #####: 1464:  ecma_string_t *private_key_p = NULL;
        -: 1465:
    #####: 1466:  ecma_property_t *prop_p = opfunc_find_private_element (obj_p, prop_name_p, &private_key_p, true);
        -: 1467:
        -: 1468:  ecma_value_t result;
        -: 1469:
    #####: 1470:  if (prop_p == NULL)
        -: 1471:  {
    #####: 1472:    result = ecma_raise_type_error (ECMA_ERR_CANNOT_READ_PRIVATE_MEMBER_TO_AN_OBJECT_WHOSE_CLASS_DID_NOT_DECLARE_IT);
        -: 1473:  }
    #####: 1474:  else if (*prop_p & ECMA_PROPERTY_FLAG_DATA)
        -: 1475:  {
    #####: 1476:    result = ecma_copy_value (ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
        -: 1477:  }
        -: 1478:  else
        -: 1479:  {
    #####: 1480:    ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (ECMA_PROPERTY_VALUE_PTR (prop_p));
        -: 1481:
    #####: 1482:    if (get_set_pair_p->getter_cp == JMEM_CP_NULL)
        -: 1483:    {
    #####: 1484:      result = ecma_raise_type_error (ECMA_ERR_PRIVATE_FIELD_WAS_DEFINED_WITHOUT_A_GETTER);
        -: 1485:    }
        -: 1486:    else
        -: 1487:    {
    #####: 1488:      ecma_object_t *getter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp);
    #####: 1489:      result = ecma_op_function_call (getter_p, base, NULL, 0);
        -: 1490:    }
        -: 1491:  }
        -: 1492:
    #####: 1493:  ecma_deref_object (obj_p);
        -: 1494:
    #####: 1495:  return result;
        -: 1496:} /* opfunc_private_get */
        -: 1497:
        -: 1498:/**
        -: 1499: * Find the private property in the object who's private key descriptor matches the given key
        -: 1500: */
        -: 1501:static ecma_string_t *
        1: 1502:opfunc_create_private_key (ecma_value_t *collection_p, /**< TODO */
        -: 1503:                           ecma_value_t search_key, /**< key */
        -: 1504:                           ecma_private_property_kind_t search_kind)
        -: 1505:{
        1: 1506:  if (search_kind < ECMA_PRIVATE_GETTER)
        -: 1507:  {
    #####: 1508:    return opfunc_make_private_key (search_key);
        -: 1509:  }
        -: 1510:
        1: 1511:  ecma_string_t *search_key_p = ecma_get_string_from_value (search_key);
        -: 1512:
        1: 1513:  ecma_value_t *current_p = collection_p + 1;
        1: 1514:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1515:
        1: 1516:  while (current_p < end_p)
        -: 1517:  {
    #####: 1518:    ecma_private_property_kind_t kind = ECMA_PRIVATE_PROPERTY_KIND (*current_p++);
    #####: 1519:    ecma_string_t *private_key_p = ecma_get_prop_name_from_value (*current_p++);
    #####: 1520:    current_p++; /* skip value */
        -: 1521:
    #####: 1522:    if (kind < ECMA_PRIVATE_GETTER)
        -: 1523:    {
    #####: 1524:      continue;
        -: 1525:    }
        -: 1526:
    #####: 1527:    JERRY_ASSERT (ecma_prop_name_is_symbol (private_key_p));
        -: 1528:
    #####: 1529:    ecma_string_t *private_key_desc_p =
    #####: 1530:      ecma_get_string_from_value (((ecma_extended_string_t *) private_key_p)->u.symbol_descriptor);
        -: 1531:
    #####: 1532:    if (ecma_compare_ecma_strings (private_key_desc_p, search_key_p))
        -: 1533:    {
    #####: 1534:      ecma_deref_ecma_string (search_key_p);
    #####: 1535:      ecma_ref_ecma_string (private_key_p);
    #####: 1536:      return private_key_p;
        -: 1537:    }
        -: 1538:  }
        -: 1539:
        1: 1540:  return opfunc_make_private_key (search_key);
        -: 1541:} /* opfunc_create_private_key */
        -: 1542:
        -: 1543:/**
        -: 1544: * Collect private members for PrivateMethodOrAccessorAdd and PrivateFieldAdd abstract operations
        -: 1545: */
        -: 1546:void
        1: 1547:opfunc_collect_private_properties (ecma_value_t constructor, ecma_value_t prop_name, ecma_value_t value, uint8_t opcode)
        -: 1548:{
        1: 1549:  ecma_private_property_kind_t kind = ECMA_PRIVATE_FIELD;
        1: 1550:  bool is_static = false;
        -: 1551:
        1: 1552:  if (opcode >= CBC_EXT_COLLECT_PRIVATE_STATIC_FIELD)
        -: 1553:  {
    #####: 1554:    opcode = (uint8_t) (opcode - PARSER_STATIC_PRIVATE_TO_PRIVATE_OFFSET);
    #####: 1555:    is_static = true;
        -: 1556:  }
        -: 1557:
        1: 1558:  if (opcode == CBC_EXT_COLLECT_PRIVATE_METHOD)
        -: 1559:  {
    #####: 1560:    prop_name ^= value;
    #####: 1561:    value ^= prop_name;
    #####: 1562:    prop_name ^= value;
    #####: 1563:    kind = ECMA_PRIVATE_METHOD;
        -: 1564:  }
        1: 1565:  else if (opcode == CBC_EXT_COLLECT_PRIVATE_GETTER)
        -: 1566:  {
    #####: 1567:    kind = ECMA_PRIVATE_GETTER;
        -: 1568:  }
        1: 1569:  else if (opcode == CBC_EXT_COLLECT_PRIVATE_SETTER)
        -: 1570:  {
        1: 1571:    kind = ECMA_PRIVATE_SETTER;
        -: 1572:  }
        -: 1573:
        1: 1574:  JERRY_ASSERT (ecma_is_value_object (constructor));
        1: 1575:  JERRY_ASSERT (ecma_is_value_string (prop_name));
        1: 1576:  JERRY_ASSERT (ecma_is_value_object (value) || ecma_is_value_undefined (value));
        -: 1577:
        1: 1578:  ecma_object_t *constructor_p = ecma_get_object_from_value (constructor);
        1: 1579:  ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
        1: 1580:  ecma_property_t *prop_p = ecma_find_named_property (constructor_p, internal_string_p);
        -: 1581:  ecma_value_t *collection_p;
        -: 1582:  ecma_property_value_t *prop_value_p;
        -: 1583:
        1: 1584:  if (prop_p == NULL)
        -: 1585:  {
        1: 1586:    collection_p = ecma_new_compact_collection ();
        1: 1587:    ECMA_CREATE_INTERNAL_PROPERTY (constructor_p, internal_string_p, prop_p, prop_value_p);
        1: 1588:    ECMA_SET_INTERNAL_VALUE_POINTER (prop_value_p->value, collection_p);
        -: 1589:  }
        -: 1590:  else
        -: 1591:  {
    #####: 1592:    prop_value_p = ECMA_PROPERTY_VALUE_PTR (prop_p);
    #####: 1593:    collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, prop_value_p->value);
        -: 1594:  }
        -: 1595:
        1: 1596:  ecma_string_t *key_p = opfunc_create_private_key (collection_p, prop_name, kind);
        -: 1597:
        1: 1598:  if (kind != ECMA_PRIVATE_FIELD)
        -: 1599:  {
        1: 1600:    key_p->u.hash |= ECMA_SYMBOL_FLAG_PRIVATE_INSTANCE_METHOD;
        -: 1601:  }
        -: 1602:
        1: 1603:  if (is_static)
        -: 1604:  {
    #####: 1605:    kind |= ECMA_PRIVATE_PROPERTY_STATIC_FLAG;
        -: 1606:  }
        -: 1607:
        1: 1608:  collection_p = ecma_compact_collection_push_back (collection_p, (ecma_value_t) kind);
        1: 1609:  collection_p = ecma_compact_collection_push_back (collection_p, ecma_make_symbol_value (key_p));
        1: 1610:  collection_p = ecma_compact_collection_push_back (collection_p, value);
        -: 1611:
        -: 1612:#ifndef JERRY_NDEBUG
        1: 1613:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        1: 1614:  ecma_value_t *current_p = collection_p + 1;
        -: 1615:
        1: 1616:  JERRY_ASSERT ((end_p - current_p) % ECMA_PRIVATE_ELEMENT_LIST_SIZE == 0);
        -: 1617:#endif /* !defined (JERRY_NDEBUG) */
        -: 1618:
        1: 1619:  ECMA_SET_INTERNAL_VALUE_POINTER (prop_value_p->value, collection_p);
        -: 1620:
        1: 1621:  ecma_free_value (value);
        1: 1622:} /* opfunc_collect_private_properties */
        -: 1623:
        -: 1624:/**
        -: 1625: * ClassDefinitionEvaluation environment initialization part
        -: 1626: *
        -: 1627: * See also: ECMAScript v6, 14.5.14
        -: 1628: *
        -: 1629: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1630: *           ECMA_VALUE_EMPTY - otherwise
        -: 1631: */
        -: 1632:void
        1: 1633:opfunc_push_class_environment (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1634:                               ecma_value_t **vm_stack_top, /**< VM stack top */
        -: 1635:                               ecma_value_t class_name) /**< class name */
        -: 1636:{
        1: 1637:  JERRY_ASSERT (ecma_is_value_string (class_name));
        1: 1638:  ecma_object_t *class_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1639:
        -: 1640:  /* 4.a */
        -: 1641:  ecma_property_value_t *property_value_p;
        1: 1642:  property_value_p = ecma_create_named_data_property (class_env_p,
        -: 1643:                                                      ecma_get_string_from_value (class_name),
        -: 1644:                                                      ECMA_PROPERTY_FLAG_ENUMERABLE,
        -: 1645:                                                      NULL);
        -: 1646:
        1: 1647:  property_value_p->value = ECMA_VALUE_UNINITIALIZED;
        1: 1648:  frame_ctx_p->lex_env_p = class_env_p;
        -: 1649:
        1: 1650:  *(*vm_stack_top)++ = ECMA_VALUE_RELEASE_LEX_ENV;
        1: 1651:} /* opfunc_push_class_environment */
        -: 1652:
        -: 1653:/**
        -: 1654: * ClassDefinitionEvaluation object initialization part
        -: 1655: *
        -: 1656: * See also: ECMAScript v6, 14.5.14
        -: 1657: *
        -: 1658: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1659: *           ECMA_VALUE_EMPTY - otherwise
        -: 1660: */
        -: 1661:ecma_value_t
        1: 1662:opfunc_init_class (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1663:                   ecma_value_t *stack_top_p) /**< stack top */
        -: 1664:{
        -: 1665:  /* 5.b, 6.e.ii */
        1: 1666:  ecma_object_t *ctor_parent_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);
        1: 1667:  ecma_object_t *proto_parent_p = NULL;
        1: 1668:  bool free_proto_parent = false;
        -: 1669:
        1: 1670:  ecma_value_t super_class = stack_top_p[-2];
        1: 1671:  ecma_object_t *ctor_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 1672:
        1: 1673:  bool heritage_present = !ecma_is_value_array_hole (super_class);
        -: 1674:
        -: 1675:  /* 5. ClassHeritage opt is not present */
        1: 1676:  if (!heritage_present)
        -: 1677:  {
        -: 1678:    /* 5.a */
        1: 1679:    proto_parent_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
        -: 1680:  }
    #####: 1681:  else if (!ecma_is_value_null (super_class))
        -: 1682:  {
        -: 1683:    /* 6.f, 6.g.i */
    #####: 1684:    if (!ecma_is_constructor (super_class))
        -: 1685:    {
    #####: 1686:      return ecma_raise_type_error (ECMA_ERR_CLASS_EXTENDS_NOT_CONSTRUCTOR);
        -: 1687:    }
        -: 1688:
    #####: 1689:    ecma_object_t *parent_p = ecma_get_object_from_value (super_class);
        -: 1690:
        -: 1691:    /* 6.g.ii */
    #####: 1692:    ecma_value_t proto_parent = ecma_op_object_get_by_magic_id (parent_p, LIT_MAGIC_STRING_PROTOTYPE);
        -: 1693:
        -: 1694:    /* 6.g.iii */
    #####: 1695:    if (ECMA_IS_VALUE_ERROR (proto_parent))
        -: 1696:    {
    #####: 1697:      return proto_parent;
        -: 1698:    }
        -: 1699:
        -: 1700:    /* 6.g.iv */
    #####: 1701:    if (ecma_is_value_object (proto_parent))
        -: 1702:    {
    #####: 1703:      proto_parent_p = ecma_get_object_from_value (proto_parent);
    #####: 1704:      free_proto_parent = true;
        -: 1705:    }
    #####: 1706:    else if (ecma_is_value_null (proto_parent))
        -: 1707:    {
    #####: 1708:      proto_parent_p = NULL;
        -: 1709:    }
        -: 1710:    else
        -: 1711:    {
    #####: 1712:      ecma_free_value (proto_parent);
    #####: 1713:      return ecma_raise_type_error (ECMA_ERR_PROPERTY_PROTOTYPE_IS_NOT_AN_OBJECT);
        -: 1714:    }
        -: 1715:
        -: 1716:    /* 6.g.v */
    #####: 1717:    ctor_parent_p = parent_p;
        -: 1718:  }
        -: 1719:
        -: 1720:  /* 7. */
        1: 1721:  ecma_object_t *proto_p = ecma_create_object (proto_parent_p, 0, ECMA_OBJECT_TYPE_GENERAL);
        1: 1722:  ecma_value_t proto = ecma_make_object_value (proto_p);
        -: 1723:
        1: 1724:  ECMA_SET_POINTER (ctor_p->u2.prototype_cp, ctor_parent_p);
        -: 1725:
        1: 1726:  if (free_proto_parent)
        -: 1727:  {
    #####: 1728:    ecma_deref_object (proto_parent_p);
        -: 1729:  }
        1: 1730:  ecma_free_value (super_class);
        -: 1731:
        -: 1732:  /* 16. */
        -: 1733:  ecma_property_value_t *property_value_p;
        1: 1734:  property_value_p = ecma_create_named_data_property (ctor_p,
        -: 1735:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_PROTOTYPE),
        -: 1736:                                                      ECMA_PROPERTY_FIXED,
        -: 1737:                                                      NULL);
        1: 1738:  property_value_p->value = proto;
        -: 1739:
        -: 1740:  /* 18. */
        1: 1741:  property_value_p = ecma_create_named_data_property (proto_p,
        -: 1742:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_CONSTRUCTOR),
        -: 1743:                                                      ECMA_PROPERTY_CONFIGURABLE_WRITABLE,
        -: 1744:                                                      NULL);
        1: 1745:  property_value_p->value = ecma_make_object_value (ctor_p);
        -: 1746:
        1: 1747:  if (ecma_get_object_type (ctor_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1748:  {
    #####: 1749:    opfunc_bind_class_environment (frame_ctx_p->lex_env_p, proto_p, ctor_p, ctor_p);
        -: 1750:
        -: 1751:    /* 15. set Fs [[ConstructorKind]] internal slot to "derived". */
    #####: 1752:    if (heritage_present)
        -: 1753:    {
    #####: 1754:      ECMA_SET_THIRD_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) ctor_p)->u.function.scope_cp);
        -: 1755:    }
        -: 1756:  }
        -: 1757:
        1: 1758:  stack_top_p[-2] = stack_top_p[-1];
        1: 1759:  stack_top_p[-1] = proto;
        -: 1760:
        1: 1761:  return ECMA_VALUE_EMPTY;
        -: 1762:} /* opfunc_init_class */
        -: 1763:
        -: 1764:/**
        -: 1765: * Creates a new class lexical environment and binds the bound object and the class's object
        -: 1766: *
        -: 1767: * @return newly created class lexical environment - if func_obj_p is not present
        -: 1768: *         NULL - otherwise, also the environment is set as the func_obj_p's scope
        -: 1769: */
        -: 1770:ecma_object_t *
        2: 1771:opfunc_bind_class_environment (ecma_object_t *lex_env_p, /**< lexical environment */
        -: 1772:                               ecma_object_t *home_object_p, /**< bound object */
        -: 1773:                               ecma_object_t *ctor_p, /**< constructor object */
        -: 1774:                               ecma_object_t *func_obj_p) /**< function object */
        -: 1775:{
        2: 1776:  ecma_object_t *proto_env_p = ecma_create_lex_env_class (lex_env_p, sizeof (ecma_lexical_environment_class_t));
        2: 1777:  ECMA_SET_NON_NULL_POINTER (proto_env_p->u1.bound_object_cp, home_object_p);
        2: 1778:  ((ecma_lexical_environment_class_t *) proto_env_p)->object_p = ctor_p;
        2: 1779:  ((ecma_lexical_environment_class_t *) proto_env_p)->type = ECMA_LEX_ENV_CLASS_TYPE_CLASS_ENV;
        -: 1780:
        2: 1781:  if (func_obj_p)
        -: 1782:  {
    #####: 1783:    JERRY_ASSERT (ecma_get_object_type (func_obj_p) == ECMA_OBJECT_TYPE_FUNCTION);
    #####: 1784:    ECMA_SET_NON_NULL_POINTER_TAG (((ecma_extended_object_t *) func_obj_p)->u.function.scope_cp, proto_env_p, 0);
    #####: 1785:    ecma_deref_object (proto_env_p);
    #####: 1786:    return NULL;
        -: 1787:  }
        -: 1788:
        2: 1789:  return proto_env_p;
        -: 1790:} /* opfunc_bind_class_environment */
        -: 1791:
        -: 1792:/**
        -: 1793: * Set [[Enumerable]] and [[HomeObject]] attributes for all class method
        -: 1794: */
        -: 1795:static void
        2: 1796:opfunc_set_class_attributes (ecma_object_t *obj_p, /**< object */
        -: 1797:                             ecma_object_t *parent_env_p) /**< parent environment */
        -: 1798:{
        2: 1799:  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -: 1800:
        -: 1801:#if JERRY_PROPERTY_HASHMAP
        2: 1802:  if (prop_iter_cp != JMEM_CP_NULL)
        -: 1803:  {
        2: 1804:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        2: 1805:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 1806:    {
    #####: 1807:      prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1808:    }
        -: 1809:  }
        -: 1810:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 1811:
        7: 1812:  while (prop_iter_cp != JMEM_CP_NULL)
        -: 1813:  {
        3: 1814:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        3: 1815:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 1816:
        3: 1817:    ecma_property_pair_t *property_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 1818:
        9: 1819:    for (uint32_t index = 0; index < ECMA_PROPERTY_PAIR_ITEM_COUNT; index++)
        -: 1820:    {
        6: 1821:      uint8_t property = property_pair_p->header.types[index];
        -: 1822:
        6: 1823:      if (!ECMA_PROPERTY_IS_RAW (property))
        -: 1824:      {
        1: 1825:        JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_DELETED
        -: 1826:                      || (ECMA_PROPERTY_IS_INTERNAL (property)
        -: 1827:                          && LIT_INTERNAL_MAGIC_STRING_IGNORED (property_pair_p->names_cp[index])));
        1: 1828:        continue;
        -: 1829:      }
        -: 1830:
        5: 1831:      if (property & ECMA_PROPERTY_FLAG_DATA)
        -: 1832:      {
        5: 1833:        if (ecma_is_value_object (property_pair_p->values[index].value) && ecma_is_property_enumerable (property))
        -: 1834:        {
        1: 1835:          property_pair_p->header.types[index] = (uint8_t) (property & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
        1: 1836:          opfunc_set_home_object (ecma_get_object_from_value (property_pair_p->values[index].value), parent_env_p);
        -: 1837:        }
        5: 1838:        continue;
        -: 1839:      }
        -: 1840:
    #####: 1841:      property_pair_p->header.types[index] = (uint8_t) (property & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
    #####: 1842:      ecma_property_value_t *accessor_objs_p = property_pair_p->values + index;
        -: 1843:
    #####: 1844:      ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);
        -: 1845:
    #####: 1846:      if (get_set_pair_p->getter_cp != JMEM_CP_NULL)
        -: 1847:      {
    #####: 1848:        opfunc_set_home_object (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp), parent_env_p);
        -: 1849:      }
        -: 1850:
    #####: 1851:      if (get_set_pair_p->setter_cp != JMEM_CP_NULL)
        -: 1852:      {
    #####: 1853:        opfunc_set_home_object (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp), parent_env_p);
        -: 1854:      }
        -: 1855:    }
        -: 1856:
        3: 1857:    prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1858:  }
        2: 1859:} /* opfunc_set_class_attributes */
        -: 1860:
        -: 1861:/**
        -: 1862: * Set [[HomeObject]] attributes for all class private elements
        -: 1863: */
        -: 1864:static void
        1: 1865:opfunc_set_private_instance_method_attributes (ecma_object_t *class_object_p, /**< class constructor  */
        -: 1866:                                               ecma_object_t *parent_env_p) /**< parent environment */
        -: 1867:{
        1: 1868:  ecma_string_t *internal_string_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_PRIVATE_ELEMENTS);
        1: 1869:  ecma_property_t *prop_p = ecma_find_named_property (class_object_p, internal_string_p);
        -: 1870:
        1: 1871:  if (prop_p == NULL)
        -: 1872:  {
    #####: 1873:    return;
        -: 1874:  }
        -: 1875:
        1: 1876:  ecma_value_t *collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, ECMA_PROPERTY_VALUE_PTR (prop_p)->value);
        1: 1877:  ecma_value_t *current_p = collection_p + 1;
        1: 1878:  ecma_value_t *end_p = ecma_compact_collection_end (collection_p);
        -: 1879:
        3: 1880:  while (current_p < end_p)
        -: 1881:  {
        1: 1882:    current_p += 2; /* skip kind, name */
        1: 1883:    ecma_value_t value = *current_p++;
        -: 1884:
        1: 1885:    if (!ecma_is_value_undefined (value))
        -: 1886:    {
        1: 1887:      opfunc_set_home_object (ecma_get_object_from_value (value), parent_env_p);
        -: 1888:    }
        -: 1889:  }
        -: 1890:} /* opfunc_set_private_instance_method_attributes */
        -: 1891:
        -: 1892:/**
        -: 1893: * Pop the current lexical environment referenced by the frame context
        -: 1894: */
        -: 1895:void
        1: 1896:opfunc_pop_lexical_environment (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 1897:{
        1: 1898:  ecma_object_t *outer_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, frame_ctx_p->lex_env_p->u2.outer_reference_cp);
        1: 1899:  ecma_deref_object (frame_ctx_p->lex_env_p);
        1: 1900:  frame_ctx_p->lex_env_p = outer_env_p;
        1: 1901:} /* opfunc_pop_lexical_environment */
        -: 1902:
        -: 1903:/**
        -: 1904: * ClassDefinitionEvaluation finalization part
        -: 1905: *
        -: 1906: * See also: ECMAScript v6, 14.5.14
        -: 1907: */
        -: 1908:void
        1: 1909:opfunc_finalize_class (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1910:                       ecma_value_t **vm_stack_top_p, /**< current vm stack top */
        -: 1911:                       ecma_value_t class_name) /**< class name */
        -: 1912:{
        1: 1913:  JERRY_ASSERT (ecma_is_value_undefined (class_name) || ecma_is_value_string (class_name));
        1: 1914:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1915:
        1: 1916:  ecma_object_t *ctor_p = ecma_get_object_from_value (stack_top_p[-2]);
        1: 1917:  ecma_object_t *proto_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 1918:
        1: 1919:  ecma_object_t *class_env_p = frame_ctx_p->lex_env_p;
        -: 1920:
        -: 1921:  /* 23.a */
        1: 1922:  if (!ecma_is_value_undefined (class_name))
        -: 1923:  {
        1: 1924:    ecma_op_initialize_binding (class_env_p, ecma_get_string_from_value (class_name), stack_top_p[-2]);
        -: 1925:  }
        -: 1926:
        1: 1927:  ecma_object_t *ctor_env_p = opfunc_bind_class_environment (class_env_p, ctor_p, ctor_p, NULL);
        1: 1928:  ecma_object_t *proto_env_p = opfunc_bind_class_environment (class_env_p, proto_p, ctor_p, NULL);
        -: 1929:
        1: 1930:  opfunc_set_class_attributes (ctor_p, ctor_env_p);
        1: 1931:  opfunc_set_class_attributes (proto_p, proto_env_p);
        1: 1932:  opfunc_set_private_instance_method_attributes (ctor_p, proto_env_p);
        -: 1933:
        1: 1934:  ecma_deref_object (proto_env_p);
        1: 1935:  ecma_deref_object (ctor_env_p);
        1: 1936:  ecma_deref_object (proto_p);
        -: 1937:
        1: 1938:  JERRY_ASSERT ((ecma_is_value_undefined (class_name) ? stack_top_p[-3] == ECMA_VALUE_UNDEFINED
        -: 1939:                                                      : stack_top_p[-3] == ECMA_VALUE_RELEASE_LEX_ENV));
        -: 1940:
        -: 1941:  /* only the current class remains on the stack */
        1: 1942:  if (stack_top_p[-3] == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 1943:  {
        1: 1944:    opfunc_pop_lexical_environment (frame_ctx_p);
        -: 1945:  }
        -: 1946:
        1: 1947:  ecma_value_t result = opfunc_private_method_or_accessor_add (ctor_p, ctor_p, ECMA_PRIVATE_PROPERTY_STATIC_FLAG);
        1: 1948:  JERRY_ASSERT (ecma_is_value_undefined (result));
        -: 1949:
        1: 1950:  stack_top_p[-3] = stack_top_p[-2];
        1: 1951:  *vm_stack_top_p -= 2;
        1: 1952:} /* opfunc_finalize_class */
        -: 1953:
        -: 1954:/**
        -: 1955: * MakeSuperPropertyReference operation
        -: 1956: *
        -: 1957: * See also: ECMAScript v6, 12.3.5.3
        -: 1958: *
        -: 1959: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1960: *         ECMA_VALUE_EMPTY - otherwise
        -: 1961: */
        -: 1962:ecma_value_t
    #####: 1963:opfunc_form_super_reference (ecma_value_t **vm_stack_top_p, /**< current vm stack top */
        -: 1964:                             vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1965:                             ecma_value_t prop_name, /**< property name to resolve */
        -: 1966:                             uint8_t opcode) /**< current cbc opcode */
        -: 1967:{
    #####: 1968:  ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -: 1969:
    #####: 1970:  if (environment_record_p && !ecma_op_this_binding_is_initialized (environment_record_p))
        -: 1971:  {
    #####: 1972:    return ecma_raise_reference_error (ECMA_ERR_CALL_SUPER_CONSTRUCTOR_DERIVED_CLASS_BEFORE_THIS);
        -: 1973:  }
        -: 1974:
    #####: 1975:  ecma_value_t parent = ecma_op_resolve_super_base (frame_ctx_p->lex_env_p);
        -: 1976:
    #####: 1977:  if (ECMA_IS_VALUE_ERROR (parent))
        -: 1978:  {
    #####: 1979:    return ecma_raise_type_error (ECMA_ERR_INVOKE_NULLABLE_SUPER_METHOD);
        -: 1980:  }
        -: 1981:
    #####: 1982:  if (!ecma_op_require_object_coercible (parent))
        -: 1983:  {
    #####: 1984:    return ECMA_VALUE_ERROR;
        -: 1985:  }
        -: 1986:
    #####: 1987:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1988:
    #####: 1989:  if (opcode >= CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE)
        -: 1990:  {
    #####: 1991:    JERRY_ASSERT (opcode == CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE
        -: 1992:                  || opcode == CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);
    #####: 1993:    *stack_top_p++ = parent;
    #####: 1994:    *stack_top_p++ = ecma_copy_value (prop_name);
    #####: 1995:    *vm_stack_top_p = stack_top_p;
        -: 1996:
    #####: 1997:    return ECMA_VALUE_EMPTY;
        -: 1998:  }
        -: 1999:
    #####: 2000:  ecma_object_t *parent_p = ecma_get_object_from_value (parent);
    #####: 2001:  ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name);
        -: 2002:
    #####: 2003:  if (prop_name_p == NULL)
        -: 2004:  {
    #####: 2005:    ecma_deref_object (parent_p);
    #####: 2006:    return ECMA_VALUE_ERROR;
        -: 2007:  }
        -: 2008:
    #####: 2009:  ecma_value_t result = ecma_op_object_get_with_receiver (parent_p, prop_name_p, frame_ctx_p->this_binding);
    #####: 2010:  ecma_deref_ecma_string (prop_name_p);
    #####: 2011:  ecma_deref_object (parent_p);
        -: 2012:
    #####: 2013:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2014:  {
    #####: 2015:    return result;
        -: 2016:  }
        -: 2017:
    #####: 2018:  if (opcode == CBC_EXT_SUPER_PROP_LITERAL_REFERENCE || opcode == CBC_EXT_SUPER_PROP_REFERENCE)
        -: 2019:  {
    #####: 2020:    *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 2021:    *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 2022:  }
        -: 2023:
    #####: 2024:  *stack_top_p++ = result;
    #####: 2025:  *vm_stack_top_p = stack_top_p;
        -: 2026:
    #####: 2027:  return ECMA_VALUE_EMPTY;
        -: 2028:} /* opfunc_form_super_reference */
        -: 2029:
        -: 2030:/**
        -: 2031: * Assignment operation for SuperRefence base
        -: 2032: *
        -: 2033: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2034: *         ECMA_VALUE_EMPTY - otherwise
        -: 2035: */
        -: 2036:ecma_value_t
    #####: 2037:opfunc_assign_super_reference (ecma_value_t **vm_stack_top_p, /**< vm stack top */
        -: 2038:                               vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 2039:                               uint32_t opcode_data) /**< opcode data to store the result */
        -: 2040:{
    #####: 2041:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 2042:
    #####: 2043:  ecma_value_t base_obj = ecma_op_to_object (stack_top_p[-3]);
        -: 2044:
    #####: 2045:  if (ECMA_IS_VALUE_ERROR (base_obj))
        -: 2046:  {
    #####: 2047:    return base_obj;
        -: 2048:  }
        -: 2049:
    #####: 2050:  ecma_object_t *base_obj_p = ecma_get_object_from_value (base_obj);
    #####: 2051:  ecma_string_t *prop_name_p = ecma_op_to_property_key (stack_top_p[-2]);
        -: 2052:
    #####: 2053:  if (prop_name_p == NULL)
        -: 2054:  {
    #####: 2055:    ecma_deref_object (base_obj_p);
    #####: 2056:    return ECMA_VALUE_ERROR;
        -: 2057:  }
        -: 2058:
    #####: 2059:  bool is_strict = (frame_ctx_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0;
        -: 2060:
    #####: 2061:  ecma_value_t result =
    #####: 2062:    ecma_op_object_put_with_receiver (base_obj_p, prop_name_p, stack_top_p[-1], frame_ctx_p->this_binding, is_strict);
        -: 2063:
    #####: 2064:  ecma_deref_ecma_string (prop_name_p);
    #####: 2065:  ecma_deref_object (base_obj_p);
        -: 2066:
    #####: 2067:  if (ECMA_IS_VALUE_ERROR (result))
        -: 2068:  {
    #####: 2069:    return result;
        -: 2070:  }
        -: 2071:
    #####: 2072:  for (int32_t i = 1; i <= 3; i++)
        -: 2073:  {
    #####: 2074:    ecma_free_value (stack_top_p[-i]);
        -: 2075:  }
        -: 2076:
    #####: 2077:  stack_top_p -= 3;
        -: 2078:
    #####: 2079:  if (opcode_data & VM_OC_PUT_STACK)
        -: 2080:  {
    #####: 2081:    *stack_top_p++ = result;
        -: 2082:  }
    #####: 2083:  else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 2084:  {
    #####: 2085:    ecma_fast_free_value (VM_GET_REGISTER (frame_ctx_p, 0));
    #####: 2086:    VM_GET_REGISTERS (frame_ctx_p)[0] = result;
        -: 2087:  }
        -: 2088:
    #####: 2089:  *vm_stack_top_p = stack_top_p;
        -: 2090:
    #####: 2091:  return result;
        -: 2092:} /* opfunc_assign_super_reference */
        -: 2093:
        -: 2094:/**
        -: 2095: * Copy data properties of an object
        -: 2096: *
        -: 2097: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2098: *         ECMA_VALUE_EMPTY - otherwise
        -: 2099: */
        -: 2100:ecma_value_t
    #####: 2101:opfunc_copy_data_properties (ecma_value_t target_object, /**< target object */
        -: 2102:                             ecma_value_t source_object, /**< source object */
        -: 2103:                             ecma_value_t filter_array) /**< filter array */
        -: 2104:{
    #####: 2105:  bool source_to_object = false;
        -: 2106:
    #####: 2107:  if (!ecma_is_value_object (source_object))
        -: 2108:  {
    #####: 2109:    source_object = ecma_op_to_object (source_object);
        -: 2110:
    #####: 2111:    if (ECMA_IS_VALUE_ERROR (source_object))
        -: 2112:    {
    #####: 2113:      return source_object;
        -: 2114:    }
        -: 2115:
    #####: 2116:    source_to_object = true;
        -: 2117:  }
        -: 2118:
    #####: 2119:  ecma_object_t *source_object_p = ecma_get_object_from_value (source_object);
    #####: 2120:  ecma_collection_t *names_p = ecma_op_object_own_property_keys (source_object_p, JERRY_PROPERTY_FILTER_ALL);
        -: 2121:
        -: 2122:#if JERRY_BUILTIN_PROXY
    #####: 2123:  if (names_p == NULL)
        -: 2124:  {
    #####: 2125:    JERRY_ASSERT (!source_to_object);
    #####: 2126:    return ECMA_VALUE_ERROR;
        -: 2127:  }
        -: 2128:#endif /* JERRY_BUILTIN_PROXY */
        -: 2129:
    #####: 2130:  ecma_object_t *target_object_p = ecma_get_object_from_value (target_object);
    #####: 2131:  ecma_value_t *buffer_p = names_p->buffer_p;
    #####: 2132:  ecma_value_t *buffer_end_p = buffer_p + names_p->item_count;
    #####: 2133:  ecma_value_t *filter_start_p = NULL;
    #####: 2134:  ecma_value_t *filter_end_p = NULL;
    #####: 2135:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -: 2136:
    #####: 2137:  if (filter_array != ECMA_VALUE_UNDEFINED)
        -: 2138:  {
    #####: 2139:    ecma_object_t *filter_array_p = ecma_get_object_from_value (filter_array);
        -: 2140:
    #####: 2141:    JERRY_ASSERT (ecma_get_object_type (filter_array_p) == ECMA_OBJECT_TYPE_ARRAY);
    #####: 2142:    JERRY_ASSERT (ecma_op_object_is_fast_array (filter_array_p));
        -: 2143:
    #####: 2144:    if (filter_array_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 2145:    {
    #####: 2146:      filter_start_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, filter_array_p->u1.property_list_cp);
    #####: 2147:      filter_end_p = filter_start_p + ((ecma_extended_object_t *) filter_array_p)->u.array.length;
        -: 2148:    }
        -: 2149:  }
        -: 2150:
    #####: 2151:  while (buffer_p < buffer_end_p)
        -: 2152:  {
    #####: 2153:    ecma_string_t *property_name_p = ecma_get_prop_name_from_value (*buffer_p++);
        -: 2154:
    #####: 2155:    if (filter_start_p != NULL)
        -: 2156:    {
    #####: 2157:      ecma_value_t *filter_p = filter_start_p;
        -: 2158:
        -: 2159:      do
        -: 2160:      {
    #####: 2161:        if (ecma_compare_ecma_strings (property_name_p, ecma_get_prop_name_from_value (*filter_p)))
        -: 2162:        {
    #####: 2163:          break;
        -: 2164:        }
    #####: 2165:      } while (++filter_p < filter_end_p);
        -: 2166:
    #####: 2167:      if (filter_p != filter_end_p)
        -: 2168:      {
    #####: 2169:        continue;
        -: 2170:      }
        -: 2171:    }
        -: 2172:
    #####: 2173:    ecma_property_descriptor_t descriptor;
    #####: 2174:    result = ecma_op_object_get_own_property_descriptor (source_object_p, property_name_p, &descriptor);
        -: 2175:
    #####: 2176:    if (ECMA_IS_VALUE_ERROR (result))
        -: 2177:    {
    #####: 2178:      break;
        -: 2179:    }
        -: 2180:
    #####: 2181:    if (result == ECMA_VALUE_FALSE)
        -: 2182:    {
    #####: 2183:      continue;
        -: 2184:    }
        -: 2185:
    #####: 2186:    if (!(descriptor.flags & JERRY_PROP_IS_ENUMERABLE))
        -: 2187:    {
    #####: 2188:      ecma_free_property_descriptor (&descriptor);
    #####: 2189:      continue;
        -: 2190:    }
        -: 2191:
    #####: 2192:    if ((descriptor.flags & JERRY_PROP_IS_VALUE_DEFINED) && !ECMA_OBJECT_IS_PROXY (source_object_p))
        -: 2193:    {
    #####: 2194:      result = descriptor.value;
        -: 2195:    }
        -: 2196:    else
        -: 2197:    {
    #####: 2198:      ecma_free_property_descriptor (&descriptor);
        -: 2199:
    #####: 2200:      result = ecma_op_object_get (source_object_p, property_name_p);
        -: 2201:
    #####: 2202:      if (ECMA_IS_VALUE_ERROR (result))
        -: 2203:      {
    #####: 2204:        break;
        -: 2205:      }
        -: 2206:    }
        -: 2207:
    #####: 2208:    opfunc_set_data_property (target_object_p, property_name_p, result);
    #####: 2209:    ecma_free_value (result);
        -: 2210:
    #####: 2211:    result = ECMA_VALUE_EMPTY;
        -: 2212:  }
        -: 2213:
    #####: 2214:  if (JERRY_UNLIKELY (source_to_object))
        -: 2215:  {
    #####: 2216:    ecma_deref_object (source_object_p);
        -: 2217:  }
        -: 2218:
    #####: 2219:  ecma_collection_free (names_p);
    #####: 2220:  return result;
        -: 2221:} /* opfunc_copy_data_properties */
        -: 2222:
        -: 2223:/**
        -: 2224: * Check whether the current lexical scope has restricted binding declaration with the given name
        -: 2225: *
        -: 2226: * Steps are include ES11: 8.1.1.4.14 HasRestrictedGlobalProperty abstract operation
        -: 2227: *
        -: 2228: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 2229: *         ECMA_VALUE_TRUE - if it has restricted property binding
        -: 2230: *         ECMA_VALUE_FALSE - otherwise
        -: 2231: */
        -: 2232:ecma_value_t
        3: 2233:opfunc_lexical_scope_has_restricted_binding (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 2234:                                             ecma_string_t *name_p) /**< binding name */
        -: 2235:{
        3: 2236:  JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 2237:
        -: 2238:#if JERRY_BUILTIN_REALMS
        3: 2239:  JERRY_ASSERT (frame_ctx_p->this_binding == JERRY_CONTEXT (global_object_p)->this_binding);
        -: 2240:#else /* !JERRY_BUILTIN_REALMS */
        -: 2241:  JERRY_ASSERT (frame_ctx_p->this_binding == ecma_builtin_get_global ());
        -: 2242:#endif /* JERRY_BUILTIN_REALMS */
        -: 2243:
        3: 2244:  ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
        3: 2245:  ecma_property_t *binding_p = ecma_find_named_property (lex_env_p, name_p);
        -: 2246:
        3: 2247:  if (binding_p != NULL)
        -: 2248:  {
    #####: 2249:    return ECMA_VALUE_TRUE;
        -: 2250:  }
        -: 2251:
        -: 2252:#if JERRY_BUILTIN_REALMS
        3: 2253:  ecma_object_t *const global_scope_p = ecma_get_global_scope ((ecma_object_t *) JERRY_CONTEXT (global_object_p));
        -: 2254:#else /* !JERRY_BUILTIN_REALMS */
        -: 2255:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -: 2256:#endif /* JERRY_BUILTIN_REALMS */
        -: 2257:
        3: 2258:  if (global_scope_p != lex_env_p)
        -: 2259:  {
    #####: 2260:    return ECMA_VALUE_FALSE;
        -: 2261:  }
        -: 2262:
        3: 2263:  ecma_object_t *global_obj_p = ecma_get_object_from_value (frame_ctx_p->this_binding);
        -: 2264:
        -: 2265:#if JERRY_BUILTIN_PROXY
        3: 2266:  if (ECMA_OBJECT_IS_PROXY (global_obj_p))
        -: 2267:  {
    #####: 2268:    ecma_property_descriptor_t prop_desc;
    #####: 2269:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (global_obj_p, name_p, &prop_desc);
        -: 2270:
    #####: 2271:    if (ecma_is_value_true (status))
        -: 2272:    {
    #####: 2273:      status = ecma_make_boolean_value ((prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE) == 0);
    #####: 2274:      ecma_free_property_descriptor (&prop_desc);
        -: 2275:    }
        -: 2276:
    #####: 2277:    return status;
        -: 2278:  }
        -: 2279:#endif /* JERRY_BUILTIN_PROXY */
        -: 2280:
        3: 2281:  ecma_property_t property = ecma_op_object_get_own_property (global_obj_p, name_p, NULL, ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 2282:
        3: 2283:  JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_NOT_FOUND || ECMA_PROPERTY_IS_FOUND (property));
        -: 2284:
        3: 2285:  return ecma_make_boolean_value (property != ECMA_PROPERTY_TYPE_NOT_FOUND
        3: 2286:                                  && !ecma_is_property_configurable (property));
        -: 2287:} /* opfunc_lexical_scope_has_restricted_binding */
        -: 2288:
        -: 2289:#endif /* JERRY_ESNEXT */
        -: 2290:
        -: 2291:/**
        -: 2292: * @}
        -: 2293: * @}
        -: 2294: */
