        -:    0:Source:/home/workspace/src/tree.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/tree.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/tree.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * tree.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *      Lu-chuan Kung and Kang-pen Chen.
        -:    6: *      All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004-2006, 2008, 2010-2014
        -:    9: *      libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: * @file tree.c
        -:   17: * @brief API for accessing the phrase tree.
        -:   18: */
        -:   19:#include <assert.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:
        -:   24:#include "chewing-private.h"
        -:   25:#include "chewing-utf8-util.h"
        -:   26:#include "userphrase-private.h"
        -:   27:#include "global.h"
        -:   28:#include "global-private.h"
        -:   29:#include "dict-private.h"
        -:   30:#include "memory-private.h"
        -:   31:#include "tree-private.h"
        -:   32:#include "private.h"
        -:   33:#include "plat_mmap.h"
        -:   34:#include "chewingutil.h"
        -:   35:
        -:   36:#define INTERVAL_SIZE ( ( MAX_PHONE_SEQ_LEN + 1 ) * MAX_PHONE_SEQ_LEN / 2 )
        -:   37:
        -:   38:typedef struct PhraseIntervalType {
        -:   39:    int from, to, source;
        -:   40:    Phrase *p_phr;
        -:   41:} PhraseIntervalType;
        -:   42:
        -:   43:typedef struct RecordNode {
        -:   44:    int *arrIndex;              /* the index array of the things in "interval" */
        -:   45:    int nInter, score;
        -:   46:    struct RecordNode *next;
        -:   47:    int nMatchCnnct;            /* match how many Cnnct. */
        -:   48:} RecordNode;
        -:   49:
        -:   50:typedef struct TreeDataType {
        -:   51:    int leftmost[MAX_PHONE_SEQ_LEN + 1];
        -:   52:    char graph[MAX_PHONE_SEQ_LEN + 1][MAX_PHONE_SEQ_LEN + 1];
        -:   53:    PhraseIntervalType interval[MAX_INTERVAL];
        -:   54:    int nInterval;
        -:   55:    RecordNode *phList;
        -:   56:    int nPhListLen;
        -:   57:} TreeDataType;
        -:   58:
      258:   59:static int IsContain(IntervalType in1, IntervalType in2)
        -:   60:{
      258:   61:    return (in1.from <= in2.from && in1.to >= in2.to);
        -:   62:}
        -:   63:
       84:   64:int IsIntersect(IntervalType in1, IntervalType in2)
        -:   65:{
       84:   66:    return (max(in1.from, in2.from) < min(in1.to, in2.to));
        -:   67:}
        -:   68:
    14240:   69:static int PhraseIntervalContain(PhraseIntervalType in1, PhraseIntervalType in2)
        -:   70:{
    14240:   71:    return (in1.from <= in2.from && in1.to >= in2.to);
        -:   72:}
        -:   73:
       26:   74:static int PhraseIntervalIntersect(PhraseIntervalType in1, PhraseIntervalType in2)
        -:   75:{
       26:   76:    return (max(in1.from, in2.from) < min(in1.to, in2.to));
        -:   77:}
        -:   78:
       55:   79:void TerminateTree(ChewingData *pgdata)
        -:   80:{
       55:   81:    pgdata->static_data.tree = NULL;
       55:   82:    plat_mmap_close(&pgdata->static_data.tree_mmap);
       55:   83:}
        -:   84:
        -:   85:
       55:   86:int InitTree(ChewingData *pgdata, const char *prefix)
        -:   87:{
        -:   88:    char filename[PATH_MAX];
        -:   89:    size_t len;
        -:   90:    size_t offset;
        -:   91:
       55:   92:    len = snprintf(filename, sizeof(filename), "%s" PLAT_SEPARATOR "%s", prefix, PHONE_TREE_FILE);
       55:   93:    if (len + 1 > sizeof(filename))
    #####:   94:        return -1;
        -:   95:
       55:   96:    plat_mmap_set_invalid(&pgdata->static_data.tree_mmap);
       55:   97:    pgdata->static_data.tree_size = plat_mmap_create(&pgdata->static_data.tree_mmap, filename, FLAG_ATTRIBUTE_READ);
       55:   98:    if (pgdata->static_data.tree_size <= 0)
    #####:   99:        return -1;
        -:  100:
       55:  101:    offset = 0;
       55:  102:    pgdata->static_data.tree =
       55:  103:        (const TreeType *) plat_mmap_set_view(&pgdata->static_data.tree_mmap, &offset, &pgdata->static_data.tree_size);
       55:  104:    if (!pgdata->static_data.tree)
    #####:  105:        return -1;
        -:  106:
       55:  107:    return 0;
        -:  108:}
        -:  109:
     7591:  110:static int CheckBreakpoint(int from, int to, int bArrBrkpt[])
        -:  111:{
        -:  112:    int i;
        -:  113:
    18683:  114:    for (i = from + 1; i < to; i++)
    11189:  115:        if (bArrBrkpt[i])
       97:  116:            return 0;
     7494:  117:    return 1;
        -:  118:}
        -:  119:
      144:  120:static int CheckUserChoose(ChewingData *pgdata,
        -:  121:                           uint16_t *new_phoneSeq, int from, int to,
        -:  122:                           Phrase **pp_phr,
        -:  123:                           char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],
        -:  124:                           IntervalType selectInterval[], int nSelect)
        -:  125:{
        -:  126:    IntervalType inte, c;
        -:  127:    int chno, len;
        -:  128:    int user_alloc;
        -:  129:    UserPhraseData *pUserPhraseData;
      144:  130:    Phrase *p_phr = ALC(Phrase, 1);
        -:  131:
     144*:  132:    assert(p_phr);
      144:  133:    inte.from = from;
      144:  134:    inte.to = to;
      144:  135:    *pp_phr = NULL;
        -:  136:
        -:  137:    /* pass 1
        -:  138:     * if these exist one selected interval which is not contained by inte
        -:  139:     * but has intersection with inte, then inte is an unacceptable interval
        -:  140:     */
      172:  141:    for (chno = 0; chno < nSelect; chno++) {
       28:  142:        c = selectInterval[chno];
       28:  143:        if (IsIntersect(inte, c) && !IsContain(inte, c)) {
    #####:  144:            free(p_phr);
    #####:  145:            return 0;
        -:  146:        }
        -:  147:    }
        -:  148:
        -:  149:    /* pass 2
        -:  150:     * if there exist one phrase satisfied all selectStr then return 1, else return 0.
        -:  151:     * also store the phrase with highest freq
        -:  152:     */
      144:  153:    pUserPhraseData = UserGetPhraseFirst(pgdata, new_phoneSeq);
      144:  154:    if (pUserPhraseData == NULL)
    #####:  155:      goto end;
      144:  156:    p_phr->freq = -1;
        -:  157:    do {
      295:  158:        for (chno = 0; chno < nSelect; chno++) {
       75:  159:            c = selectInterval[chno];
        -:  160:
       75:  161:            if (IsContain(inte, c)) {
        -:  162:                /*
        -:  163:                 * find a phrase of ph_id where the text contains
        -:  164:                 * 'selectStr[chno]' test if not ok then return 0,
        -:  165:                 * if ok then continue to test. */
       69:  166:                len = c.to - c.from;
       69:  167:                if (memcmp(ueStrSeek(pUserPhraseData->wordSeq, c.from - from),
       69:  168:                           selectStr[chno], ueStrNBytes(selectStr[chno], len)))
       47:  169:                    break;
        -:  170:            }
        -:  171:
        -:  172:        }
      267:  173:        if (chno == nSelect) {
        -:  174:            /* save phrase data to "pp_phr" */
      220:  175:            if (pUserPhraseData->userfreq > p_phr->freq) {
      158:  176:                if ((user_alloc = (to - from)) > 0) {
      158:  177:                    ueStrNCpy(p_phr->phrase, pUserPhraseData->wordSeq, user_alloc, 1);
        -:  178:                }
      158:  179:                p_phr->freq = pUserPhraseData->userfreq;
      158:  180:                *pp_phr = p_phr;
        -:  181:            }
        -:  182:        }
      267:  183:    } while ((pUserPhraseData = UserGetPhraseNext(pgdata, new_phoneSeq)) != NULL);
      144:  184:    UserGetPhraseEnd(pgdata, new_phoneSeq);
        -:  185:
      144:  186:    if (p_phr->freq != -1)
      144:  187:        return 1;
    #####:  188:  end:
    #####:  189:    free(p_phr);
    #####:  190:    return 0;
        -:  191:}
        -:  192:
        -:  193:/*
        -:  194: * phrase is said to satisfy a choose interval if
        -:  195: * their intersections are the same */
     3967:  196:static int CheckChoose(ChewingData *pgdata,
        -:  197:                       const TreeType *phrase_parent, int from, int to, Phrase **pp_phr,
        -:  198:                       char selectStr[][MAX_PHONE_SEQ_LEN * MAX_UTF8_SIZE + 1],
        -:  199:                       IntervalType selectInterval[], int nSelect)
        -:  200:{
        -:  201:    IntervalType inte, c;
        -:  202:    int chno, len;
     3967:  203:    Phrase *phrase = ALC(Phrase, 1);
        -:  204:
    3967*:  205:    assert(phrase);
     3967:  206:    inte.from = from;
     3967:  207:    inte.to = to;
     3967:  208:    *pp_phr = NULL;
        -:  209:
        -:  210:    /* if there exist one phrase satisfied all selectStr then return 1, else return 0. */
     3967:  211:    GetPhraseFirst(pgdata, phrase, phrase_parent);
        -:  212:    do {
     4104:  213:        for (chno = 0; chno < nSelect; chno++) {
      161:  214:            c = selectInterval[chno];
        -:  215:
      161:  216:            if (IsContain(inte, c)) {
        -:  217:                /* find a phrase under phrase_parent where the text contains
        -:  218:                 * 'selectStr[chno]' test if not ok then return 0, if ok
        -:  219:                 * then continue to test
        -:  220:                 */
      121:  221:                len = c.to - c.from;
      121:  222:                if (memcmp(ueStrSeek(phrase->phrase, c.from - from),
      121:  223:                           selectStr[chno], ueStrNBytes(selectStr[chno], len)))
       99:  224:                    break;
       40:  225:            } else if (IsIntersect(inte, selectInterval[chno])) {
       20:  226:                free(phrase);
       20:  227:                return 0;
        -:  228:            }
        -:  229:        }
     4042:  230:        if (chno == nSelect) {
     3943:  231:            *pp_phr = phrase;
     3943:  232:            return 1;
        -:  233:        }
       99:  234:    } while (GetVocabNext(pgdata, phrase));
        4:  235:    free(phrase);
        4:  236:    return 0;
        -:  237:}
        -:  238:
   104626:  239:static int CompTreeType(const void *a, const void *b)
        -:  240:{
   104626:  241:    return GetUint16(((TreeType *) a)->key) - GetUint16(((TreeType *) b)->key);
        -:  242:}
        -:  243:
        -:  244:/** @brief search for the phrases have the same pronunciation.*/
        -:  245:/* if phoneSeq[begin] ~ phoneSeq[end] is a phrase, then add an interval
        -:  246: * from (begin) to (end+1)
        -:  247: */
     7811:  248:const TreeType *TreeFindPhrase(ChewingData *pgdata, int begin, int end, const uint16_t *phoneSeq)
        -:  249:{
        -:  250:    TreeType target;
     7811:  251:    const TreeType *tree_p = pgdata->static_data.tree;
        -:  252:    uint32_t range[2];
        -:  253:    int i;
        -:  254:
    20080:  255:    for (i = begin; i <= end; i++) {
    15289:  256:        PutUint16(phoneSeq[i], target.key);
    15289:  257:        range[0] = GetUint24(tree_p->child.begin);
    15289:  258:        range[1] = GetUint24(tree_p->child.end);
   15289*:  259:        assert(range[1] >= range[0]);
    15289:  260:        tree_p = (const TreeType *) bsearch(&target, pgdata->static_data.tree + range[0],
    15289:  261:                                            range[1] - range[0], sizeof(TreeType), CompTreeType);
        -:  262:
        -:  263:        /* if not found any word then fail. */
    15289:  264:        if (!tree_p)
     3020:  265:            return NULL;
        -:  266:    }
        -:  267:
        -:  268:    /* If its child has no key value of 0, then it is only a "half" phrase. */
     4791:  269:    if (GetUint16(pgdata->static_data.tree[GetUint24(tree_p->child.begin)].key) != 0)
      507:  270:        return NULL;
     4284:  271:    return tree_p;
        -:  272:}
        -:  273:
        -:  274:/**
        -:  275: * @brief get child range of a given parent node.
        -:  276: */
     4244:  277:void TreeChildRange(ChewingData *pgdata, const TreeType *parent)
        -:  278:{
     4244:  279:    pgdata->static_data.tree_cur_pos = pgdata->static_data.tree + GetUint24(parent->child.begin);
     4244:  280:    pgdata->static_data.tree_end_pos = pgdata->static_data.tree + GetUint24(parent->child.end);
     4244:  281:}
        -:  282:
     3943:  283:static void AddInterval(TreeDataType *ptd, int begin, int end, Phrase *p_phrase, int dict_or_user)
        -:  284:{
     3943:  285:    ptd->interval[ptd->nInterval].from = begin;
     3943:  286:    ptd->interval[ptd->nInterval].to = end + 1;
     3943:  287:    ptd->interval[ptd->nInterval].p_phr = p_phrase;
     3943:  288:    ptd->interval[ptd->nInterval].source = dict_or_user;
     3943:  289:    ptd->nInterval++;
     3943:  290:}
        -:  291:
        -:  292:/* Item which inserts to interval array */
        -:  293:typedef enum {
        -:  294:    USED_PHRASE_NONE,           /**< none of items used */
        -:  295:    USED_PHRASE_USER,           /**< User phrase */
        -:  296:    USED_PHRASE_DICT            /**< Dict phrase */
        -:  297:} UsedPhraseMode;
        -:  298:
     7494:  299:static void internal_release_Phrase(UsedPhraseMode mode, Phrase *pUser, Phrase *pDict)
        -:  300:{
        -:  301:    /* we must free unused phrase entry to avoid memory leak. */
     7494:  302:    switch (mode) {
       74:  303:    case USED_PHRASE_USER:
       74:  304:        if (pDict != NULL)
       74:  305:            free(pDict);
       74:  306:        break;
     3869:  307:    case USED_PHRASE_DICT:
     3869:  308:        if (pUser != NULL)
       70:  309:            free(pUser);
     3869:  310:        break;
     3551:  311:    default:                   /* In fact, it is always 0 */
     3551:  312:        if (pDict != NULL)
    #####:  313:            free(pDict);
     3551:  314:        if (pUser != NULL)
    #####:  315:            free(pUser);
     3551:  316:        break;
        -:  317:    }
     7494:  318:}
        -:  319:
     1326:  320:static void FindInterval(ChewingData *pgdata, TreeDataType *ptd)
        -:  321:{
        -:  322:    int end, begin;
        -:  323:    const TreeType *phrase_parent;
        -:  324:    Phrase *p_phrase, *puserphrase, *pdictphrase;
        -:  325:    UsedPhraseMode i_used_phrase;
        -:  326:    uint16_t new_phoneSeq[MAX_PHONE_SEQ_LEN];
        -:  327:    UserPhraseData *userphrase;
        -:  328:
     4118:  329:    for (begin = 0; begin < pgdata->nPhoneSeq; begin++) {
    10286:  330:        for (end = begin; end < min(pgdata->nPhoneSeq, begin + MAX_PHRASE_LEN); end++) {
     7591:  331:            if (!CheckBreakpoint(begin, end + 1, pgdata->bArrBrkpt))
       97:  332:                break;
        -:  333:
        -:  334:            /* set new_phoneSeq */
     7494:  335:            memcpy(new_phoneSeq, &pgdata->phoneSeq[begin], sizeof(uint16_t) * (end - begin + 1));
     7494:  336:            new_phoneSeq[end - begin + 1] = 0;
     7494:  337:            puserphrase = pdictphrase = NULL;
     7494:  338:            i_used_phrase = USED_PHRASE_NONE;
        -:  339:
     7494:  340:            userphrase = UserGetPhraseFirst(pgdata, new_phoneSeq);
     7494:  341:            UserGetPhraseEnd(pgdata, new_phoneSeq);
        -:  342:
     7638:  343:            if (userphrase && CheckUserChoose(pgdata, new_phoneSeq, begin, end + 1,
      144:  344:                                              &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {
      144:  345:                puserphrase = p_phrase;
        -:  346:            }
        -:  347:
        -:  348:            /* check dict phrase */
     7494:  349:            phrase_parent = TreeFindPhrase(pgdata, begin, end, pgdata->phoneSeq);
    11461:  350:            if (phrase_parent &&
     3967:  351:                CheckChoose(pgdata,
        -:  352:                            phrase_parent, begin, end + 1,
     3967:  353:                            &p_phrase, pgdata->selectStr, pgdata->selectInterval, pgdata->nSelect)) {
     3943:  354:                pdictphrase = p_phrase;
        -:  355:            }
        -:  356:
        -:  357:            /* add only one interval, which has the largest freqency
        -:  358:             * but when the phrase is the same, the user phrase overrides
        -:  359:             * static dict
        -:  360:             */
     7494:  361:            if (puserphrase != NULL && pdictphrase == NULL) {
    #####:  362:                i_used_phrase = USED_PHRASE_USER;
     7494:  363:            } else if (puserphrase == NULL && pdictphrase != NULL) {
     3799:  364:                i_used_phrase = USED_PHRASE_DICT;
     3695:  365:            } else if (puserphrase != NULL && pdictphrase != NULL) {
        -:  366:                /* the same phrase, userphrase overrides */
      144:  367:                if (!strcmp(puserphrase->phrase, pdictphrase->phrase)) {
       60:  368:                    i_used_phrase = USED_PHRASE_USER;
        -:  369:                } else {
       84:  370:                    if (puserphrase->freq > pdictphrase->freq) {
       14:  371:                        i_used_phrase = USED_PHRASE_USER;
        -:  372:                    } else {
       70:  373:                        i_used_phrase = USED_PHRASE_DICT;
        -:  374:                    }
        -:  375:                }
        -:  376:            }
     7494:  377:            switch (i_used_phrase) {
       74:  378:            case USED_PHRASE_USER:
       74:  379:                AddInterval(ptd, begin, end, puserphrase, IS_USER_PHRASE);
       74:  380:                break;
     3869:  381:            case USED_PHRASE_DICT:
     3869:  382:                AddInterval(ptd, begin, end, pdictphrase, IS_DICT_PHRASE);
     3869:  383:                break;
     3551:  384:            case USED_PHRASE_NONE:
        -:  385:            default:
     3551:  386:                break;
        -:  387:            }
     7494:  388:            internal_release_Phrase(i_used_phrase, puserphrase, pdictphrase);
        -:  389:        }
        -:  390:    }
     1326:  391:}
        -:  392:
     1326:  393:static void SetInfo(int len, TreeDataType *ptd)
        -:  394:{
        -:  395:    int i, a;
        -:  396:
     5444:  397:    for (i = 0; i <= len; i++)
     4118:  398:        ptd->leftmost[i] = i;
     5269:  399:    for (i = 0; i < ptd->nInterval; i++) {
     3943:  400:        ptd->graph[ptd->interval[i].from][ptd->interval[i].to] = 1;
     3943:  401:        ptd->graph[ptd->interval[i].to][ptd->interval[i].from] = 1;
        -:  402:    }
        -:  403:
        -:  404:    /* set leftmost */
     5444:  405:    for (a = 0; a <= len; a++) {
    23498:  406:        for (i = 0; i <= len; i++) {
    19380:  407:            if (!(ptd->graph[a][i]))
    11494:  408:                continue;
     7886:  409:            if (ptd->leftmost[i] < ptd->leftmost[a])
     2784:  410:                ptd->leftmost[a] = ptd->leftmost[i];
        -:  411:        }
        -:  412:    }
     1326:  413:}
        -:  414:
        -:  415:/*
        -:  416: * First we compare the 'nMatchCnnct'.
        -:  417: * If the values are the same, we will compare the 'score'
        -:  418: */
        2:  419:static int CompRecord(const RecordNode **pa, const RecordNode **pb)
        -:  420:{
        2:  421:    int diff = (*pb)->nMatchCnnct - (*pa)->nMatchCnnct;
        -:  422:
        2:  423:    if (diff)
    #####:  424:        return diff;
        2:  425:    return ((*pb)->score - (*pa)->score);
        -:  426:}
        -:  427:
        -:  428:/*
        -:  429: * Remove the interval containing in another interval.
        -:  430: *
        -:  431: * Example:
        -:  432: * 國民大會 has three interval: 國民, 大會, 國民大會. This function removes
        -:  433: * 國名, 大會 because 國民大會 contains 國民 and 大會.
        -:  434: */
     1326:  435:static void Discard1(TreeDataType *ptd)
        -:  436:{
        -:  437:    int a, b;
        -:  438:    char failflag[INTERVAL_SIZE];
        -:  439:    int nInterval2;
        -:  440:
     1326:  441:    memset(failflag, 0, sizeof(failflag));
     5269:  442:    for (a = 0; a < ptd->nInterval; a++) {
     3943:  443:        if (failflag[a])
     1223:  444:            continue;
    15631:  445:        for (b = 0; b < ptd->nInterval; b++) {
    14064:  446:            if (a == b || failflag[b])
     5770:  447:                continue;
        -:  448:
        -:  449:            /* interval b is in interval a */
     8294:  450:            if (PhraseIntervalContain(ptd->interval[a], ptd->interval[b]))
     2198:  451:                continue;
        -:  452:
        -:  453:            /* interval b is in front of interval a */
     6096:  454:            if (ptd->interval[b].to <= ptd->interval[a].from)
     2436:  455:                continue;
        -:  456:
        -:  457:            /* interval b is in back of interval a */
     3660:  458:            if (ptd->interval[a].to <= ptd->interval[b].from)
     2507:  459:                continue;
        -:  460:
     1153:  461:            break;
        -:  462:        }
        -:  463:        /* if any other interval b is inside or leftside or rightside the
        -:  464:         * interval a */
     2720:  465:        if (b >= ptd->nInterval) {
        -:  466:            /* then kill all the intervals inside the interval a */
        -:  467:            int i;
        -:  468:
    10284:  469:            for (i = 0; i < ptd->nInterval; i++) {
     8717:  470:                if (!failflag[i] && i != a && PhraseIntervalContain(ptd->interval[a], ptd->interval[i])) {
     2034:  471:                    failflag[i] = 1;
        -:  472:                }
        -:  473:            }
        -:  474:        }
        -:  475:    }
        -:  476:    /* discard all the intervals whose failflag[a] = 1 */
     1326:  477:    nInterval2 = 0;
     5269:  478:    for (a = 0; a < ptd->nInterval; a++) {
     3943:  479:        if (!failflag[a]) {
     1909:  480:            ptd->interval[nInterval2++] = ptd->interval[a];
        -:  481:        } else {
     2034:  482:            if (ptd->interval[a].p_phr != NULL) {
     2034:  483:                free(ptd->interval[a].p_phr);
        -:  484:            }
        -:  485:        }
        -:  486:    }
     1326:  487:    ptd->nInterval = nInterval2;
     1326:  488:}
        -:  489:
        -:  490:/*
        -:  491: * Remove the interval that cannot connect to head or tail by other intervals.
        -:  492: *
        -:  493: * Example:
        -:  494: * The input string length is 5
        -:  495: * The available intervals are [1,1], [1,2], [2,3], [2,4], [5,5], [3,5].
        -:  496: *
        -:  497: * The possible connection from head to tail are [1,2][3,5], and
        -:  498: * [1,1][2,4][5,5]. Since [2,3] cannot connect to head or tail, it is removed
        -:  499: * by this function.
        -:  500: */
     1326:  501:static void Discard2(TreeDataType *ptd)
        -:  502:{
        -:  503:    int i, j;
        -:  504:    char overwrite[MAX_PHONE_SEQ_LEN];
        -:  505:    char failflag[INTERVAL_SIZE];
        -:  506:    int nInterval2;
        -:  507:
     1326:  508:    memset(failflag, 0, sizeof(failflag));
     3235:  509:    for (i = 0; i < ptd->nInterval; i++) {
     1909:  510:        if (ptd->leftmost[ptd->interval[i].from] == 0)
     1909:  511:            continue;
        -:  512:        /* test if interval i is overwrited by other intervals */
    #####:  513:        memset(overwrite, 0, sizeof(overwrite));
    #####:  514:        for (j = 0; j < ptd->nInterval; j++) {
    #####:  515:            if (j == i)
    #####:  516:                continue;
    #####:  517:            memset(&overwrite[ptd->interval[j].from], 1, ptd->interval[j].to - ptd->interval[j].from);
        -:  518:        }
    #####:  519:        if (memchr(&overwrite[ptd->interval[i].from], 1, ptd->interval[i].to - ptd->interval[i].from))
    #####:  520:            failflag[i] = 1;
        -:  521:    }
        -:  522:    /* discard all the intervals whose failflag[a] = 1 */
     1326:  523:    nInterval2 = 0;
     3235:  524:    for (i = 0; i < ptd->nInterval; i++)
     1909:  525:        if (!failflag[i])
     1909:  526:            ptd->interval[nInterval2++] = ptd->interval[i];
     1326:  527:    ptd->nInterval = nInterval2;
     1326:  528:}
        -:  529:
     1721:  530:static void FillPreeditBuf(ChewingData *pgdata, char *phrase, int from, int to)
        -:  531:{
        -:  532:    int i;
     1721:  533:    int start = 0;
        -:  534:
    1721*:  535:    assert(pgdata);
    1721*:  536:    assert(phrase);
    1721*:  537:    assert(from < to);
        -:  538:
     1721:  539:    start = toPreeditBufIndex(pgdata, from);
        -:  540:
     1721:  541:    LOG_VERBOSE("Fill preeditBuf start %d, from = %d, to = %d", start, from, to);
        -:  542:
     4543:  543:    for (i = start; i < start - from + to; ++i) {
     2822:  544:        ueStrNCpy(pgdata->preeditBuf[i].char_, ueStrSeek(phrase, i - start), 1, STRNCPY_CLOSE);
        -:  545:    }
     1721:  546:}
        -:  547:
        -:  548:/* kpchen said, record is the index array of interval */
     1326:  549:static void OutputRecordStr(ChewingData *pgdata, const TreeDataType *ptd)
        -:  550:{
        -:  551:    PhraseIntervalType inter;
        -:  552:    int i;
        -:  553:
     3025:  554:    for (i = 0; i < ptd->phList->nInter; i++) {
     1699:  555:        inter = ptd->interval[ptd->phList->arrIndex[i]];
     1699:  556:        FillPreeditBuf(pgdata, inter.p_phr->phrase, inter.from, inter.to);
        -:  557:    }
        -:  558:
     1348:  559:    for (i = 0; i < pgdata->nSelect; i++) {
       22:  560:        FillPreeditBuf(pgdata, pgdata->selectStr[i], pgdata->selectInterval[i].from, pgdata->selectInterval[i].to);
        -:  561:    }
     1326:  562:}
        -:  563:
     3794:  564:static int rule_largest_sum(const int *record, int nRecord, const TreeDataType *ptd)
        -:  565:{
     3794:  566:    int i, score = 0;
        -:  567:    PhraseIntervalType inter;
        -:  568:
    11098:  569:    for (i = 0; i < nRecord; i++) {
     7304:  570:        inter = ptd->interval[record[i]];
    7304*:  571:        assert(inter.p_phr);
     7304:  572:        score += inter.to - inter.from;
        -:  573:    }
     3794:  574:    return score;
        -:  575:}
        -:  576:
     1897:  577:static int rule_largest_avgwordlen(const int *record, int nRecord, const TreeDataType *ptd)
        -:  578:{
        -:  579:    /* constant factor 6=1*2*3, to keep value as integer */
     1897:  580:    return 6 * rule_largest_sum(record, nRecord, ptd) / nRecord;
        -:  581:}
        -:  582:
     1897:  583:static int rule_smallest_lenvariance(const int *record, int nRecord, const TreeDataType *ptd)
        -:  584:{
     1897:  585:    int i, j, score = 0;
        -:  586:    PhraseIntervalType inter1, inter2;
        -:  587:
        -:  588:    /* kcwu: heuristic? why variance no square function? */
     5549:  589:    for (i = 0; i < nRecord; i++) {
     6719:  590:        for (j = i + 1; j < nRecord; j++) {
     3067:  591:            inter1 = ptd->interval[record[i]];
     3067:  592:            inter2 = ptd->interval[record[j]];
    3067*:  593:            assert(inter1.p_phr && inter2.p_phr);
     3067:  594:            score += abs((inter1.to - inter1.from) - (inter2.to - inter2.from));
        -:  595:        }
        -:  596:    }
     1897:  597:    return -score;
        -:  598:}
        -:  599:
     1897:  600:static int rule_largest_freqsum(const int *record, int nRecord, const TreeDataType *ptd)
        -:  601:{
     1897:  602:    int i, score = 0;
        -:  603:    PhraseIntervalType inter;
        -:  604:
     5549:  605:    for (i = 0; i < nRecord; i++) {
     3652:  606:        inter = ptd->interval[record[i]];
    3652*:  607:        assert(inter.p_phr);
        -:  608:
        -:  609:        /* We adjust the 'freq' of One-word Phrase */
     3652:  610:        score += (inter.to - inter.from == 1) ? (inter.p_phr->freq / 512) : inter.p_phr->freq;
        -:  611:    }
     1897:  612:    return score;
        -:  613:}
        -:  614:
     1897:  615:static int LoadPhraseAndCountScore(const int *record, int nRecord, const TreeDataType *ptd)
        -:  616:{
     1897:  617:    int total_score = 0;
        -:  618:
        -:  619:    /* NOTE: the balance factor is tuneable */
     1897:  620:    if (nRecord) {
     1897:  621:        total_score += 1000 * rule_largest_sum(record, nRecord, ptd);
     1897:  622:        total_score += 1000 * rule_largest_avgwordlen(record, nRecord, ptd);
     1897:  623:        total_score += 100 * rule_smallest_lenvariance(record, nRecord, ptd);
     1897:  624:        total_score += rule_largest_freqsum(record, nRecord, ptd);
        -:  625:    }
     1897:  626:    return total_score;
        -:  627:}
        -:  628:
       36:  629:static int IsRecContain(const int *intA, int nA, const int *intB, int nB, const TreeDataType *ptd)
        -:  630:{
        -:  631:    int big, sml;
        -:  632:
       84:  633:    for (big = 0, sml = 0; sml < nB; sml++) {
      154:  634:        while ((big < nA) && ptd->interval[intA[big]].from < ptd->interval[intB[sml]].to) {
      126:  635:            if (PhraseIntervalContain(ptd->interval[intA[big]], ptd->interval[intB[sml]]))
       48:  636:                break;
       78:  637:            big++;
        -:  638:        }
       76:  639:        if ((big >= nA) || ptd->interval[intA[big]].from >= ptd->interval[intB[sml]].to)
       28:  640:            return 0;
        -:  641:    }
        8:  642:    return 1;
        -:  643:}
        -:  644:
        2:  645:static void SortListByScore(TreeDataType *ptd)
        -:  646:{
        -:  647:    int i, listLen;
        -:  648:    RecordNode *p, **arr;
        -:  649:
        6:  650:    for (listLen = 0, p = ptd->phList; p; listLen++, p = p->next);
        2:  651:    ptd->nPhListLen = listLen;
        -:  652:
        2:  653:    arr = ALC(RecordNode *, listLen);
        -:  654:
       2*:  655:    assert(arr);
        -:  656:
        6:  657:    for (i = 0, p = ptd->phList; i < listLen; p = p->next, i++) {
        4:  658:        arr[i] = p;
        4:  659:        p->score = LoadPhraseAndCountScore(p->arrIndex, p->nInter, ptd);
        -:  660:    }
        -:  661:
        2:  662:    qsort(arr, listLen, sizeof(RecordNode *), (CompFuncType) CompRecord);
        -:  663:
        2:  664:    ptd->phList = arr[0];
        4:  665:    for (i = 1; i < listLen; i++) {
        2:  666:        arr[i - 1]->next = arr[i];
        -:  667:    }
        2:  668:    arr[listLen - 1]->next = NULL;
        -:  669:
        2:  670:    free(arr);
        2:  671:}
        -:  672:
        -:  673:/* when record==NULL then output the "link list" */
       12:  674:static void SaveRecord(const int *record, int nInter, TreeDataType *ptd)
        -:  675:{
        -:  676:    RecordNode *now, *p, *pre;
        -:  677:
       12:  678:    pre = NULL;
       30:  679:    for (p = ptd->phList; p;) {
        -:  680:        /* if  'p' contains 'record', then discard 'record'. */
       18:  681:        if (IsRecContain(p->arrIndex, p->nInter, record, nInter, ptd))
    #####:  682:            return;
        -:  683:
        -:  684:        /* if 'record' contains 'p', then discard 'p'
        -:  685:         * -- We must deal with the linked list. */
       18:  686:        if (IsRecContain(record, nInter, p->arrIndex, p->nInter, ptd)) {
        8:  687:            RecordNode *tp = p;
        -:  688:
        8:  689:            if (pre)
        4:  690:                pre->next = p->next;
        -:  691:            else
        4:  692:                ptd->phList = ptd->phList->next;
        8:  693:            p = p->next;
        8:  694:            free(tp->arrIndex);
        8:  695:            free(tp);
        -:  696:        } else
       10:  697:            pre = p, p = p->next;
        -:  698:    }
       12:  699:    now = ALC(RecordNode, 1);
        -:  700:
      12*:  701:    assert(now);
       12:  702:    now->next = ptd->phList;
       12:  703:    now->arrIndex = ALC(int, nInter);
        -:  704:
      12*:  705:    assert(now->arrIndex);
       12:  706:    now->nInter = nInter;
       12:  707:    memcpy(now->arrIndex, record, nInter * sizeof(int));
       12:  708:    ptd->phList = now;
        -:  709:}
        -:  710:
       28:  711:static void RecursiveSave(int depth, int to, int *record, TreeDataType *ptd)
        -:  712:{
        -:  713:    int first, i;
        -:  714:
        -:  715:    /* to find first interval */
       60:  716:    for (first = record[depth - 1] + 1; ptd->interval[first].from < to && first < ptd->nInterval; first++);
        -:  717:
       28:  718:    if (first == ptd->nInterval) {
       12:  719:        SaveRecord(record + 1, depth - 1, ptd);
       12:  720:        return;
        -:  721:    }
       16:  722:    record[depth] = first;
       16:  723:    RecursiveSave(depth + 1, ptd->interval[first].to, record, ptd);
        -:  724:    /* for each interval which intersects first */
       26:  725:    for (i = first + 1; PhraseIntervalIntersect(ptd->interval[first], ptd->interval[i]) && i < ptd->nInterval; i++) {
       10:  726:        record[depth] = i;
       10:  727:        RecursiveSave(depth + 1, ptd->interval[i].to, record, ptd);
        -:  728:    }
        -:  729:}
        -:  730:
        2:  731:static void SaveList(TreeDataType *ptd)
        -:  732:{
        2:  733:    int record[MAX_PHONE_SEQ_LEN + 1] = { -1 };
        -:  734:
        2:  735:    RecursiveSave(1, 0, record, ptd);
        2:  736:}
        -:  737:
     1326:  738:static void InitPhrasing(TreeDataType *ptd)
        -:  739:{
     1326:  740:    memset(ptd, 0, sizeof(TreeDataType));
     1326:  741:}
        -:  742:
     1326:  743:static void SaveDispInterval(PhrasingOutput *ppo, TreeDataType *ptd)
        -:  744:{
        -:  745:    int i;
        -:  746:
     3025:  747:    for (i = 0; i < ptd->phList->nInter; i++) {
     1699:  748:        ppo->dispInterval[i].from = ptd->interval[ptd->phList->arrIndex[i]].from;
     1699:  749:        ppo->dispInterval[i].to = ptd->interval[ptd->phList->arrIndex[i]].to;
        -:  750:    }
     1326:  751:    ppo->nDispInterval = ptd->phList->nInter;
     1326:  752:}
        -:  753:
     1326:  754:static void CleanUpMem(TreeDataType *ptd)
        -:  755:{
        -:  756:    int i;
        -:  757:    RecordNode *pNode;
        -:  758:
     3235:  759:    for (i = 0; i < ptd->nInterval; i++) {
     1909:  760:        if (ptd->interval[i].p_phr) {
     1909:  761:            free(ptd->interval[i].p_phr);
     1909:  762:            ptd->interval[i].p_phr = NULL;
        -:  763:        }
        -:  764:    }
     2654:  765:    while (ptd->phList != NULL) {
     1328:  766:        pNode = ptd->phList;
     1328:  767:        ptd->phList = pNode->next;
     1328:  768:        free(pNode->arrIndex);
     1328:  769:        free(pNode);
        -:  770:    }
     1326:  771:}
        -:  772:
        2:  773:static void CountMatchCnnct(TreeDataType *ptd, const int *bUserArrCnnct, int nPhoneSeq)
        -:  774:{
        -:  775:    RecordNode *p;
        -:  776:    int i, k, sum;
        -:  777:
        6:  778:    for (p = ptd->phList; p; p = p->next) {
        -:  779:        /* for each record, count its 'nMatchCnnct' */
       16:  780:        for (sum = 0, i = 1; i < nPhoneSeq; i++) {
       12:  781:            if (!bUserArrCnnct[i])
       12:  782:                continue;
        -:  783:            /* check if matching 'cnnct' */
    #####:  784:            for (k = 0; k < p->nInter; k++) {
    #####:  785:                if (ptd->interval[p->arrIndex[k]].from < i && ptd->interval[p->arrIndex[k]].to > i) {
    #####:  786:                    sum++;
    #####:  787:                    break;
        -:  788:                }
        -:  789:            }
        -:  790:        }
        4:  791:        p->nMatchCnnct = sum;
        -:  792:    }
        2:  793:}
        -:  794:
     1326:  795:static void ShowList(ChewingData *pgdata, const TreeDataType *ptd)
        -:  796:{
        -:  797:    const RecordNode *p;
        -:  798:    int i;
        -:  799:
     1326:  800:    DEBUG_OUT("After SaveList :\n");
     2654:  801:    for (p = ptd->phList; p; p = p->next) {
     1328:  802:        DEBUG_OUT("  interval : ");
     3031:  803:        for (i = 0; i < p->nInter; i++) {
     1703:  804:            DEBUG_OUT("[%d %d] ", ptd->interval[p->arrIndex[i]].from, ptd->interval[p->arrIndex[i]].to);
        -:  805:        }
     1328:  806:        DEBUG_OUT("\n" "      score : %d , nMatchCnnct : %d\n", p->score, p->nMatchCnnct);
        -:  807:    }
     1326:  808:    DEBUG_OUT("\n");
     1326:  809:}
        -:  810:
        2:  811:static RecordNode *NextCut(TreeDataType *tdt, PhrasingOutput *ppo)
        -:  812:{
        -:  813:    /* pop nNumCut-th candidate to first */
        -:  814:    int i;
        -:  815:    RecordNode *former;
        -:  816:    RecordNode *want;
        -:  817:
        2:  818:    if (ppo->nNumCut >= tdt->nPhListLen)
        1:  819:        ppo->nNumCut = 0;
        2:  820:    if (ppo->nNumCut == 0)
        1:  821:        return tdt->phList;
        -:  822:
        -:  823:    /* find the former of our candidate */
        1:  824:    former = tdt->phList;
       1*:  825:    for (i = 0; i < ppo->nNumCut - 1; i++) {
    #####:  826:        former = former->next;
    #####:  827:        assert(former);
        -:  828:    }
        -:  829:
        -:  830:    /* take the candidate out of the listed list */
        1:  831:    want = former->next;
       1*:  832:    assert(want);
        1:  833:    former->next = former->next->next;
        -:  834:
        -:  835:    /* prepend to front of list */
        1:  836:    want->next = tdt->phList;
        1:  837:    tdt->phList = want;
        -:  838:
        1:  839:    return tdt->phList;
        -:  840:}
        -:  841:
     1249:  842:static int SortByIncreaseEnd(const void *x, const void *y)
        -:  843:{
     1249:  844:    const PhraseIntervalType *interval_x = (const PhraseIntervalType *) x;
     1249:  845:    const PhraseIntervalType *interval_y = (const PhraseIntervalType *) y;
        -:  846:
     1249:  847:    if (interval_x->to < interval_y->to)
     1115:  848:        return -1;
        -:  849:
      134:  850:    if (interval_x->to > interval_y->to)
        2:  851:        return 1;
        -:  852:
      132:  853:    return 0;
        -:  854:}
        -:  855:
      979:  856:static RecordNode *DuplicateRecordAndInsertInterval(const RecordNode *record, TreeDataType *pdt, const int interval_id)
        -:  857:{
      979:  858:    RecordNode *ret = NULL;
        -:  859:
     979*:  860:    assert(record);
     979*:  861:    assert(pdt);
        -:  862:
      979:  863:    ret = ALC(RecordNode, 1);
        -:  864:
      979:  865:    if (!ret)
    #####:  866:        return NULL;
        -:  867:
      979:  868:    ret->arrIndex = ALC(int, record->nInter + 1);
      979:  869:    if (!ret->arrIndex) {
    #####:  870:        free(ret);
    #####:  871:        return NULL;
        -:  872:    }
      979:  873:    ret->nInter = record->nInter + 1;
      979:  874:    memcpy(ret->arrIndex, record->arrIndex, sizeof(record->arrIndex[0]) * record->nInter);
        -:  875:
      979:  876:    ret->arrIndex[ret->nInter - 1] = interval_id;
        -:  877:
      979:  878:    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);
        -:  879:
      979:  880:    return ret;
        -:  881:}
        -:  882:
      914:  883:static RecordNode *CreateSingleIntervalRecord(TreeDataType *pdt, const int interval_id)
        -:  884:{
      914:  885:    RecordNode *ret = NULL;
        -:  886:
     914*:  887:    assert(pdt);
        -:  888:
      914:  889:    ret = ALC(RecordNode, 1);
        -:  890:
      914:  891:    if (!ret)
    #####:  892:        return NULL;
        -:  893:
      914:  894:    ret->arrIndex = ALC(int, 1);
      914:  895:    if (!ret->arrIndex) {
    #####:  896:        free(ret);
    #####:  897:        return NULL;
        -:  898:    }
        -:  899:
      914:  900:    ret->nInter = 1;
      914:  901:    ret->arrIndex[0] = interval_id;
        -:  902:
      914:  903:    ret->score = LoadPhraseAndCountScore(ret->arrIndex, ret->nInter, pdt);
        -:  904:
      914:  905:    return ret;
        -:  906:}
        -:  907:
      414:  908:static RecordNode *CreateNullIntervalRecord()
        -:  909:{
      414:  910:    RecordNode *ret = NULL;
      414:  911:    ret = ALC(RecordNode, 1);
        -:  912:
      414:  913:    if (!ret)
    #####:  914:        return NULL;
        -:  915:
      414:  916:    ret->arrIndex = ALC(int, 1);
      414:  917:    if (!ret->arrIndex) {
    #####:  918:        free(ret);
    #####:  919:        return NULL;
        -:  920:    }
        -:  921:
      414:  922:    ret->nInter = 0;
      414:  923:    ret->score = 0;
        -:  924:
      414:  925:    return ret;
        -:  926:}
        -:  927:
     3767:  928:static void FreeRecord(RecordNode *node)
        -:  929:{
     3767:  930:    if (node) {
      983:  931:        free(node->arrIndex);
      983:  932:        free(node);
        -:  933:    }
     3767:  934:}
        -:  935:
     1324:  936:static void DoDpPhrasing(ChewingData *pgdata, TreeDataType *pdt)
        -:  937:{
     1324:  938:    RecordNode *highest_score[MAX_PHONE_SEQ_LEN] = { 0 };
        -:  939:    RecordNode *tmp;
        -:  940:    int prev_end;
        -:  941:    int end;
        -:  942:    int interval_id;
        -:  943:
    1324*:  944:    assert(pgdata);
    1324*:  945:    assert(pdt);
        -:  946:
        -:  947:    /*
        -:  948:     * Assume P(x,y) is the highest score phrasing result from x to y. The
        -:  949:     * following is formula for P(x,y):
        -:  950:     *
        -:  951:     * P(x,y) = MAX( P(x,y-1)+P(y-1,y), P(x,y-2)+P(y-2,y), ... )
        -:  952:     *
        -:  953:     * While P(x,y-1) is stored in highest_score array, and P(y-1,y) is
        -:  954:     * interval end at y. In this formula, x is always 0.
        -:  955:     *
        -:  956:     * The format of highest_score array is described as following:
        -:  957:     *
        -:  958:     * highest_score[0] = P(0,0)
        -:  959:     * highest_score[1] = P(0,1)
        -:  960:     * ...
        -:  961:     * highest_score[y-1] = P(0,y-1)
        -:  962:     */
        -:  963:
        -:  964:    /* The interval shall be sorted by the increase order of end. */
     1324:  965:    qsort(pdt->interval, pdt->nInterval, sizeof(pdt->interval[0]), SortByIncreaseEnd);
        -:  966:
     3217:  967:    for (interval_id = 0; interval_id < pdt->nInterval; ++interval_id) {
        -:  968:        /*
        -:  969:         * XXX: pdt->interval.to is excluding, while end is
        -:  970:         * including, so we need to minus one here.
        -:  971:         */
     1893:  972:        end = pdt->interval[interval_id].to - 1;
        -:  973:
     1893:  974:        prev_end = pdt->interval[interval_id].from - 1;
        -:  975:
     1893:  976:        if (prev_end >= 0)
      979:  977:            tmp = DuplicateRecordAndInsertInterval(highest_score[prev_end], pdt, interval_id);
        -:  978:        else
      914:  979:            tmp = CreateSingleIntervalRecord(pdt, interval_id);
        -:  980:
        -:  981:        /* FIXME: shall exit immediately? */
     1893:  982:        if (!tmp)
    #####:  983:            continue;
        -:  984:
     1893:  985:        if (highest_score[end] == NULL || highest_score[end]->score < tmp->score) {
     1825:  986:            FreeRecord(highest_score[end]);
     1825:  987:            highest_score[end] = tmp;
        -:  988:        } else
       68:  989:            FreeRecord(tmp);
        -:  990:    }
        -:  991:
     1324:  992:    if (pgdata->nPhoneSeq - 1 < 0 || highest_score[pgdata->nPhoneSeq - 1] == NULL) {
      414:  993:        pdt->phList = CreateNullIntervalRecord();
        -:  994:    } else {
      910:  995:        pdt->phList = highest_score[pgdata->nPhoneSeq - 1];
        -:  996:    }
     1324:  997:    pdt->nPhListLen = 1;
        -:  998:
     3198:  999:    for (end = 0; end < pgdata->nPhoneSeq - 1; ++end)
     1874: 1000:        FreeRecord(highest_score[end]);
     1324: 1001:}
        -: 1002:
     1326: 1003:int Phrasing(ChewingData *pgdata, int all_phrasing)
        -: 1004:{
        -: 1005:    TreeDataType treeData;
        -: 1006:
     1326: 1007:    InitPhrasing(&treeData);
        -: 1008:
     1326: 1009:    FindInterval(pgdata, &treeData);
     1326: 1010:    SetInfo(pgdata->nPhoneSeq, &treeData);
     1326: 1011:    Discard1(&treeData);
     1326: 1012:    Discard2(&treeData);
     1326: 1013:    if (all_phrasing) {
        2: 1014:        SaveList(&treeData);
        2: 1015:        CountMatchCnnct(&treeData, pgdata->bUserArrCnnct, pgdata->nPhoneSeq);
        2: 1016:        SortListByScore(&treeData);
        2: 1017:        NextCut(&treeData, &pgdata->phrOut);
        -: 1018:    } else {
     1324: 1019:        DoDpPhrasing(pgdata, &treeData);
        -: 1020:    }
        -: 1021:
     1326: 1022:    ShowList(pgdata, &treeData);
        -: 1023:
        -: 1024:    /* set phrasing output */
     1326: 1025:    OutputRecordStr(pgdata, &treeData);
     1326: 1026:    SaveDispInterval(&pgdata->phrOut, &treeData);
        -: 1027:
        -: 1028:    /* free "phrase" */
     1326: 1029:    CleanUpMem(&treeData);
     1326: 1030:    return 0;
        -: 1031:}
