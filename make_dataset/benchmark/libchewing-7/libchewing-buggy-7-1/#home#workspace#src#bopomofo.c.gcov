        -:    0:Source:/home/workspace/src/bopomofo.c
        -:    0:Graph:/home/workspace/build/CMakeFiles/chewing.dir/src/bopomofo.gcno
        -:    0:Data:/home/workspace/build/CMakeFiles/chewing.dir/src/bopomofo.gcda
        -:    0:Runs:1
        -:    1:/**
        -:    2: * bopomofo.c
        -:    3: *
        -:    4: * Copyright (c) 1999, 2000, 2001
        -:    5: *      Lu-chuan Kung and Kang-pen Chen.
        -:    6: *      All rights reserved.
        -:    7: *
        -:    8: * Copyright (c) 2004-2006, 2008-2010, 2012-2014
        -:    9: *      libchewing Core Team. See ChangeLog for details.
        -:   10: *
        -:   11: * See the file "COPYING" for information on usage and redistribution
        -:   12: * of this file.
        -:   13: */
        -:   14:
        -:   15:/**
        -:   16: * @file bopomofo.c
        -:   17: *
        -:   18: * control keyboard mapping
        -:   19: * include the definition of BopomofoData structure
        -:   20: */
        -:   21:
        -:   22:#include <ctype.h>
        -:   23:#include <string.h>
        -:   24:
        -:   25:#include "bopomofo-private.h"
        -:   26:#include "chewingutil.h"
        -:   27:#include "dict-private.h"
        -:   28:#include "key2pho-private.h"
        -:   29:#include "pinyin-private.h"
        -:   30:#include "private.h"
        -:   31:
        -:   32:/*
        -:   33: * process a key input
        -:   34: * return value:
        -:   35: *      BOPOMOFO_ABSORB
        -:   36: *      BOPOMOFO_COMMIT
        -:   37: *      BOPOMOFO_KEY_ERROR
        -:   38: *      BOPOMOFO_ERROR
        -:   39: */
       36:   40:static int IsHsuPhoEndKey(const int pho_inx[], int key)
        -:   41:{
       36:   42:    switch (key) {
       17:   43:    case 's':
        -:   44:    case 'd':
        -:   45:    case 'f':
        -:   46:    case 'j':
        -:   47:    case ' ':
       17:   48:        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);
       19:   49:    default:
       19:   50:        return 0;
        -:   51:    }
        -:   52:}
        -:   53:
        -:   54:/* copy the idea from HSU keyboard */
       36:   55:static int IsET26PhoEndKey(const int pho_inx[], int key)
        -:   56:{
       36:   57:    switch (key) {
       16:   58:    case 'd':
        -:   59:    case 'f':
        -:   60:    case 'j':
        -:   61:    case 'k':
        -:   62:    case ' ':
       16:   63:        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);
       20:   64:    default:
       20:   65:        return 0;
        -:   66:    }
        -:   67:}
        -:   68:
        -:   69:/* copy the idea from HSU keyboard */
       56:   70:static int IsDACHENCP26PhoEndKey(const int pho_inx[], int key)
        -:   71:{
       56:   72:    switch (key) {
        8:   73:    case 'e':
        -:   74:    case 'r':
        -:   75:    case 'd':
        -:   76:    case 'y':
        -:   77:    case ' ':
        8:   78:        return (pho_inx[0] || pho_inx[1] || pho_inx[2]);
       48:   79:    default:
       48:   80:        return 0;
        -:   81:    }
        -:   82:}
        -:   83:
      288:   84:static int IsDefPhoEndKey(int key, int kbtype)
        -:   85:{
      288:   86:    if (PhoneInxFromKey(key, 3, kbtype, 1))
       94:   87:        return 1;
        -:   88:
      194:   89:    if (key == ' ')
       11:   90:        return 1;
      183:   91:    return 0;
        -:   92:}
        -:   93:
      183:   94:static int EndKeyProcess(ChewingData *pgdata, int key, int searchTimes)
        -:   95:{
      183:   96:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
        -:   97:    uint16_t u16Pho, u16PhoAlt;
        -:   98:    Phrase tempword;
        -:   99:    int pho_inx;
        -:  100:
      183:  101:    if (pBopomofo->pho_inx[0] == 0 && pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0 && pBopomofo->pho_inx[3] == 0) {
        -:  102:        /*
        -:  103:         * Special handle for space key (Indeed very special one).
        -:  104:         * Un-break the situation that OnKeySpace() is not called,
        -:  105:         * hence the Candidate window doesn't show up, because
        -:  106:         * BOPOMOFO_NO_WORD is returned.
        -:  107:         */
    #####:  108:        return (key == ' ') ? BOPOMOFO_KEY_ERROR : BOPOMOFO_NO_WORD;
        -:  109:    }
        -:  110:
      183:  111:    pho_inx = PhoneInxFromKey(key, 3, pBopomofo->kbtype, searchTimes);
      183:  112:    if (pBopomofo->pho_inx[3] == 0) {
      182:  113:        pBopomofo->pho_inx[3] = pho_inx;
      182:  114:        pBopomofo->pho_inx_alt[3] = pho_inx;
        1:  115:    } else if (key != ' ') {
    #####:  116:        pBopomofo->pho_inx[3] = pho_inx;
    #####:  117:        pBopomofo->pho_inx_alt[3] = pho_inx;
    #####:  118:        return BOPOMOFO_NO_WORD;
        -:  119:    }
        -:  120:
      183:  121:    u16Pho = UintFromPhoneInx(pBopomofo->pho_inx);
      183:  122:    if (GetCharFirst(pgdata, &tempword, u16Pho) == 0) {
    #####:  123:        BopomofoRemoveAll(pBopomofo);
    #####:  124:        return BOPOMOFO_NO_WORD;
        -:  125:    }
        -:  126:
      183:  127:    pBopomofo->phone = u16Pho;
        -:  128:
      183:  129:    if (pBopomofo->pho_inx_alt[0] == 0 && pBopomofo->pho_inx_alt[1] == 0 && pBopomofo->pho_inx_alt[2] == 0) {
        -:  130:        /* no alternative phone, copy from default as alt */
      138:  131:        pBopomofo->phoneAlt = u16Pho;
        -:  132:    } else {
       45:  133:        u16PhoAlt = UintFromPhoneInx(pBopomofo->pho_inx_alt);
       45:  134:        pBopomofo->phoneAlt = u16PhoAlt;
        -:  135:    }
        -:  136:
      183:  137:    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));
      183:  138:    memset(pBopomofo->pho_inx_alt, 0, sizeof(pBopomofo->pho_inx_alt));
      183:  139:    return BOPOMOFO_COMMIT;
        -:  140:}
        -:  141:
      288:  142:static int DefPhoInput(ChewingData *pgdata, int key)
        -:  143:{
      288:  144:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
      288:  145:    int type = 0, inx = 0;
        -:  146:    int i;
        -:  147:
      288:  148:    if (IsDefPhoEndKey(key, pBopomofo->kbtype)) {
      133:  149:        for (i = 0; i < BOPOMOFO_SIZE; ++i)
      131:  150:            if (pBopomofo->pho_inx[i] != 0)
      103:  151:                break;
      105:  152:        if (i < BOPOMOFO_SIZE)
      103:  153:            return EndKeyProcess(pgdata, key, 1);
        -:  154:    } else {
      183:  155:        pBopomofo->pho_inx[3] = 0;
        -:  156:    }
        -:  157:
        -:  158:    /* decide if the key is a phone */
      361:  159:    for (type = 0; type <= 3; type++) {
      357:  160:        inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, 1);
      357:  161:        if (inx)
      181:  162:            break;
        -:  163:    }
        -:  164:
        -:  165:    /* the key is NOT a phone */
      185:  166:    if (type > 3) {
        4:  167:        return BOPOMOFO_KEY_ERROR;
        -:  168:    }
        -:  169:
        -:  170:    /* fill the key into the phone buffer */
      181:  171:    pBopomofo->pho_inx[type] = inx;
      181:  172:    return BOPOMOFO_ABSORB;
        -:  173:}
        -:  174:
       36:  175:static int HsuPhoInput(ChewingData *pgdata, int key)
        -:  176:{
       36:  177:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
       36:  178:    int type = 0, searchTimes = 0, inx = 0;
        -:  179:
        -:  180:    /* Dvorak Hsu key has already converted to Hsu */
       36:  181:    if (IsHsuPhoEndKey(pBopomofo->pho_inx, key)) {
       14:  182:        if (pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0) {
        -:  183:            /* convert "ㄐㄑㄒ" to "ㄓㄔㄕ" */
        7:  184:            if (12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {
        1:  185:                pBopomofo->pho_inx[0] += 3;
        -:  186:            }
        -:  187:            /* convert "ㄏ" to "ㄛ" */
        6:  188:            else if (pBopomofo->pho_inx[0] == 11) {
        1:  189:                pBopomofo->pho_inx[0] = 0;
        1:  190:                pBopomofo->pho_inx[2] = 2;
        -:  191:            }
        -:  192:            /* convert "ㄍ" to "ㄜ" */
        5:  193:            else if (pBopomofo->pho_inx[0] == 9) {
        1:  194:                pBopomofo->pho_inx[0] = 0;
        1:  195:                pBopomofo->pho_inx[2] = 3;
        -:  196:            }
        -:  197:            /* convert "ㄇ" to "ㄢ" */
        4:  198:            else if (pBopomofo->pho_inx[0] == 3) {
        1:  199:                pBopomofo->pho_inx[0] = 0;
        1:  200:                pBopomofo->pho_inx[2] = 9;
        -:  201:            }
        -:  202:            /* convert "ㄋ" to "ㄣ" */
        3:  203:            else if (pBopomofo->pho_inx[0] == 7) {
        1:  204:                pBopomofo->pho_inx[0] = 0;
        1:  205:                pBopomofo->pho_inx[2] = 10;
        -:  206:            }
        -:  207:            /* convert "ㄎ" to "ㄤ" */
        2:  208:            else if (pBopomofo->pho_inx[0] == 10) {
        1:  209:                pBopomofo->pho_inx[0] = 0;
        1:  210:                pBopomofo->pho_inx[2] = 11;
        -:  211:            }
        -:  212:            /* convert "ㄌ" to "ㄦ" */
        1:  213:            else if (pBopomofo->pho_inx[0] == 8) {
        1:  214:                pBopomofo->pho_inx[0] = 0;
        1:  215:                pBopomofo->pho_inx[2] = 13;
        -:  216:            }
        -:  217:        }
        -:  218:
        -:  219:        /* fuzzy ㄍㄧ to ㄐㄧ and ㄍㄩ to ㄐㄩ */
      14*:  220:        if ((pBopomofo->pho_inx[0] == 9) && ((pBopomofo->pho_inx[1] == 1) || (pBopomofo->pho_inx[1] == 3))) {
    #####:  221:            pBopomofo->pho_inx[0] = 12;
        -:  222:        }
        -:  223:
       14:  224:        searchTimes = (key == 'j') ? 3 : 2;
        -:  225:
       14:  226:        return EndKeyProcess(pgdata, key, searchTimes);
        -:  227:    } else {
        -:  228:        /* decide if the key is a phone */
       37:  229:        for (type = 0, searchTimes = 1; type < 3; type++) {
       37:  230:            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);
       37:  231:            if (!inx)
        9:  232:                continue;       /* if inx == 0, next type */
       28:  233:            else if (type == 0) {
        -:  234:                /**
        -:  235:                 * Hsu maps multiple bopomofo into one single key.
        -:  236:                 * Therefore, if a consonant or a medial already exists
        -:  237:                 * in buffer, and the user presses a key with consonant
        -:  238:                 * and rhyme, libchewing should consider that the user
        -:  239:                 * wants to input the rhyme.
        -:  240:                 */
       19:  241:                if ((inx == 3 || (7 <= inx && inx <= 11) || inx == 20)
       14:  242:                    && (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1])) {
        -:  243:                    /* if inx !=0 */
        6:  244:                    searchTimes = 2;    /* possible infinite loop here */
        -:  245:                } else
        -:  246:                    break;
        9:  247:            } else if (type == 1 && inx == 1) { /* handle i and e */
        2:  248:                if (pBopomofo->pho_inx[1]) {
    #####:  249:                    searchTimes = 2;
        -:  250:                } else
        2:  251:                    break;
        -:  252:            } else
        -:  253:                break;
        -:  254:        }
        -:  255:
        -:  256:        /* fuzzy ㄍㄧ to ㄐㄧ and ㄍㄩ to ㄐㄩ */
      22*:  257:        if ((pBopomofo->pho_inx[0] == 9) && ((pBopomofo->pho_inx[1] == 1) || (pBopomofo->pho_inx[1] == 3))) {
    #####:  258:            pBopomofo->pho_inx[0] = 12;
        -:  259:        }
        -:  260:
        -:  261:        /* ㄐㄑㄒ must be followed by ㄧㄩ, if not, convert them to ㄓㄔㄕ */
      22*:  262:        if (type == 1 && inx == 2 && 12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {
        -:  263:            /* followed by ㄨ */
    #####:  264:            pBopomofo->pho_inx[0] += 3;
        -:  265:        }
        -:  266:
       22:  267:        if (type == 2 && pBopomofo->pho_inx[1] == 0 && 12 <= pBopomofo->pho_inx[0] && pBopomofo->pho_inx[0] <= 14) {
        -:  268:            /* followed by other phones */
        1:  269:            pBopomofo->pho_inx[0] += 3;
        -:  270:        }
        -:  271:
       22:  272:        if (type == 3) {        /* the key is NOT a phone */
    #####:  273:            if (isalpha(key))
    #####:  274:                return BOPOMOFO_NO_WORD;
    #####:  275:            return BOPOMOFO_KEY_ERROR;
        -:  276:        }
        -:  277:        /* fill the key into the phone buffer */
       22:  278:        pBopomofo->pho_inx[type] = inx;
       22:  279:        return BOPOMOFO_ABSORB;
        -:  280:    }
        -:  281:}
        -:  282:
        -:  283:/* copy the idea from hsu */
       36:  284:static int ET26PhoInput(ChewingData *pgdata, int key)
        -:  285:{
       36:  286:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
       36:  287:    int type = 0, searchTimes = 0, inx = 0;
        -:  288:
       36:  289:    if (IsET26PhoEndKey(pBopomofo->pho_inx, key)) {
       14:  290:        if (pBopomofo->pho_inx[1] == 0 && pBopomofo->pho_inx[2] == 0) {
        -:  291:            /* convert "ㄐㄒ" to "ㄓㄕ" */
        7:  292:            if (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14) {
        1:  293:                pBopomofo->pho_inx[0] += 3;
        -:  294:            }
        -:  295:            /* convert "ㄆ" to "ㄡ" */
        6:  296:            else if (pBopomofo->pho_inx[0] == 2) {
        1:  297:                pBopomofo->pho_inx[0] = 0;
        1:  298:                pBopomofo->pho_inx[2] = 8;
        -:  299:            }
        -:  300:            /* convert "ㄇ" to "ㄢ" */
        5:  301:            else if (pBopomofo->pho_inx[0] == 3) {
        1:  302:                pBopomofo->pho_inx[0] = 0;
        1:  303:                pBopomofo->pho_inx[2] = 9;
        -:  304:            }
        -:  305:            /* convert "ㄋ" to "ㄣ" */
        4:  306:            else if (pBopomofo->pho_inx[0] == 7) {
        1:  307:                pBopomofo->pho_inx[0] = 0;
        1:  308:                pBopomofo->pho_inx[2] = 10;
        -:  309:            }
        -:  310:            /* convert "ㄊ" to "ㄤ" */
        3:  311:            else if (pBopomofo->pho_inx[0] == 6) {
        1:  312:                pBopomofo->pho_inx[0] = 0;
        1:  313:                pBopomofo->pho_inx[2] = 11;
        -:  314:            }
        -:  315:            /* convert "ㄌ" to "ㄥ" */
        2:  316:            else if (pBopomofo->pho_inx[0] == 8) {
        1:  317:                pBopomofo->pho_inx[0] = 0;
        1:  318:                pBopomofo->pho_inx[2] = 12;
        -:  319:            }
        -:  320:            /* convert "ㄏ" to "ㄦ" */
        1:  321:            else if (pBopomofo->pho_inx[0] == 11) {
        1:  322:                pBopomofo->pho_inx[0] = 0;
        1:  323:                pBopomofo->pho_inx[2] = 13;
        -:  324:            }
        -:  325:        }
       14:  326:        searchTimes = 2;
       14:  327:        return EndKeyProcess(pgdata, key, searchTimes);
        -:  328:    } else {
        -:  329:        /* decide if the key is a phone */
       37:  330:        for (type = 0, searchTimes = 1; type < 3; type++) {
       37:  331:            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);
       37:  332:            if (!inx)
       10:  333:                continue;       /* if inx == 0, next type */
       27:  334:            else if (type == 0) {
        -:  335:                 /**
        -:  336:                  * Same as Hsu: If a consonant or a medial already exists
        -:  337:                  * in buffer, and the user presses a key with consonant
        -:  338:                  * and rhyme, libchewing should consider that the user
        -:  339:                  * wants to input the rhyme.
        -:  340:                  */
       18:  341:                if ((inx == 2 || inx == 3 || inx == 11 || inx == 19 || inx == 20 ||
       16:  342:                    (6 <= inx && inx <= 8)) && (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1])) {
        -:  343:                    /* if inx !=0 */
        5:  344:                    searchTimes = 2;    /* possible infinite loop here */
        -:  345:                } else
        -:  346:                    break;
        -:  347:            } else
        9:  348:                break;
        -:  349:        }
        -:  350:        /* convert "ㄐㄒ" to "ㄓㄕ" */
       22:  351:        if (type == 1) {
        3:  352:            if (inx == 2) {
        1:  353:                if (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14) {
    #####:  354:                    pBopomofo->pho_inx[0] += 3;
        -:  355:                }
        -:  356:            } else {
        -:  357:                /* convert "ㄍ" to "ㄑ" */
        2:  358:                if (pBopomofo->pho_inx[0] == 9) {
    #####:  359:                    pBopomofo->pho_inx[0] = 13;
        -:  360:                }
        -:  361:            }
        -:  362:        }
        -:  363:
       22:  364:        if (type == 2 && pBopomofo->pho_inx[1] == 0 && (pBopomofo->pho_inx[0] == 12 || pBopomofo->pho_inx[0] == 14)) {
        1:  365:            pBopomofo->pho_inx[0] += 3;
        -:  366:        }
        -:  367:
       22:  368:        if (type == 3) {        /* the key is NOT a phone */
    #####:  369:            if (isalpha(key))
    #####:  370:                return BOPOMOFO_NO_WORD;
    #####:  371:            return BOPOMOFO_KEY_ERROR;
        -:  372:        }
        -:  373:        /* fill the key into the phone buffer */
       22:  374:        pBopomofo->pho_inx[type] = inx;
       22:  375:        return BOPOMOFO_ABSORB;
        -:  376:    }
        -:  377:}
        -:  378:
       24:  379:static int SwitchingBetween(int *pho_idx, int a, int b)
        -:  380:{
       24:  381:    if (*pho_idx == a) {
        8:  382:        *pho_idx = b;
        8:  383:        return 1;
       16:  384:    } else if (*pho_idx == b) {
    #####:  385:        *pho_idx = a;
    #####:  386:        return 1;
        -:  387:    }
       16:  388:    return 0;
        -:  389:}
        -:  390:
       56:  391:static int DACHENCP26PhoInput(ChewingData *pgdata, int key)
        -:  392:{
       56:  393:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
       56:  394:    int type = 0, searchTimes = 0, inx = 0;
        -:  395:
       56:  396:    if (IsDACHENCP26PhoEndKey(pBopomofo->pho_inx, key)) {
        7:  397:        searchTimes = 2;
        7:  398:        return EndKeyProcess(pgdata, key, searchTimes);
        -:  399:    } else {
        -:  400:        /* decide if the key is a phone */
       94:  401:        for (type = 0, searchTimes = 1; type < 3; type++) {
       94:  402:            inx = PhoneInxFromKey(key, type, pBopomofo->kbtype, searchTimes);
       94:  403:            if (!inx)
       45:  404:                continue;       /* if inx == 0, next type */
       49:  405:            else if (type == 0) {
       19:  406:                break;
        -:  407:                if (pBopomofo->pho_inx[0] || pBopomofo->pho_inx[1]) {
        -:  408:                    /* if inx !=0 */
        -:  409:                    searchTimes = 2;    /* possible infinite loop here */
        -:  410:                } else
        -:  411:                    break;
        -:  412:            } else
       30:  413:                break;
        -:  414:        }
        -:  415:        /* switching between "ㄅ" and "ㄆ" */
       49:  416:        if (key == 'q') {
        3:  417:            if (SwitchingBetween(&pBopomofo->pho_inx[0], 1, 2)) {
        1:  418:                return BOPOMOFO_ABSORB;
        -:  419:            }
        -:  420:        }
        -:  421:        /* switching between "ㄉ" and "ㄊ" */
       46:  422:        else if (key == 'w') {
        4:  423:            if (SwitchingBetween(&pBopomofo->pho_inx[0], 5, 6)) {
        1:  424:                return BOPOMOFO_ABSORB;
        -:  425:            }
        -:  426:        }
        -:  427:        /* switching between "ㄓ" and "ㄔ" */
       42:  428:        else if (key == 't') {
        3:  429:            if (SwitchingBetween(&pBopomofo->pho_inx[0], 15, 16)) {
        1:  430:                return BOPOMOFO_ABSORB;
        -:  431:            }
        -:  432:        }
        -:  433:        /* converting "ㄖ" to "ㄝ" */
       39:  434:        else if (key == 'b') {
        2:  435:            if (pBopomofo->pho_inx[0] != 0 || pBopomofo->pho_inx[1] != 0) {
        1:  436:                pBopomofo->pho_inx[2] = 4;
        1:  437:                return BOPOMOFO_ABSORB;
        -:  438:            }
        -:  439:        }
        -:  440:        /* converting "ㄙ" to "ㄥ" */
       37:  441:        else if (key == 'n') {
        2:  442:            if (pBopomofo->pho_inx[0] != 0 || pBopomofo->pho_inx[1] != 0) {
        1:  443:                pBopomofo->pho_inx[2] = 12;
        1:  444:                return BOPOMOFO_ABSORB;
        -:  445:            }
        -:  446:        }
        -:  447:        /* switching between "ㄧ", "ㄚ", and "ㄧㄚ" */
       35:  448:        else if (key == 'u') {
        8:  449:            if (pBopomofo->pho_inx[1] == 1 && pBopomofo->pho_inx[2] != 1) {
        1:  450:                pBopomofo->pho_inx[1] = 0;
        1:  451:                pBopomofo->pho_inx[2] = 1;
        1:  452:                return BOPOMOFO_ABSORB;
        7:  453:            } else if (pBopomofo->pho_inx[1] != 1 && pBopomofo->pho_inx[2] == 1) {
        1:  454:                pBopomofo->pho_inx[1] = 1;
        1:  455:                return BOPOMOFO_ABSORB;
        6:  456:            } else if (pBopomofo->pho_inx[1] == 1 && pBopomofo->pho_inx[2] == 1) {
        1:  457:                pBopomofo->pho_inx[1] = 0;
        1:  458:                pBopomofo->pho_inx[2] = 0;
        1:  459:                return BOPOMOFO_ABSORB;
        5:  460:            } else if (pBopomofo->pho_inx[1] != 0) {
        1:  461:                pBopomofo->pho_inx[2] = 1;
        1:  462:                return BOPOMOFO_ABSORB;
        -:  463:            }
        -:  464:        }
        -:  465:        /* switching between "ㄩ" and "ㄡ" */
       27:  466:        else if (key == 'm') {
        4:  467:            if (pBopomofo->pho_inx[1] == 3 && pBopomofo->pho_inx[2] != 8) {
        1:  468:                pBopomofo->pho_inx[1] = 0;
        1:  469:                pBopomofo->pho_inx[2] = 8;
        1:  470:                return BOPOMOFO_ABSORB;
        3:  471:            } else if (pBopomofo->pho_inx[1] != 3 && pBopomofo->pho_inx[2] == 8) {
        1:  472:                pBopomofo->pho_inx[1] = 3;
        1:  473:                pBopomofo->pho_inx[2] = 0;
        1:  474:                return BOPOMOFO_ABSORB;
        2:  475:            } else if (pBopomofo->pho_inx[1] != 0) {
        1:  476:                pBopomofo->pho_inx[2] = 8;
        1:  477:                return BOPOMOFO_ABSORB;
        -:  478:            }
        -:  479:        }
        -:  480:        /* switching between "ㄛ" and "ㄞ" */
       23:  481:        else if (key == 'i') {
        2:  482:            if (SwitchingBetween(&pBopomofo->pho_inx[2], 2, 5)) {
        1:  483:                return BOPOMOFO_ABSORB;
        -:  484:            }
        -:  485:        }
        -:  486:        /* switching between "ㄟ" and "ㄢ" */
       21:  487:        else if (key == 'o') {
        2:  488:            if (SwitchingBetween(&pBopomofo->pho_inx[2], 6, 9)) {
        1:  489:                return BOPOMOFO_ABSORB;
        -:  490:            }
        -:  491:        }
        -:  492:        /* switching between "ㄠ" and "ㄤ" */
       19:  493:        else if (key == 'l') {
        4:  494:            if (SwitchingBetween(&pBopomofo->pho_inx[2], 7, 11)) {
        2:  495:                return BOPOMOFO_ABSORB;
        -:  496:            }
        -:  497:        }
        -:  498:        /* switching between "ㄣ" and "ㄦ" */
       15:  499:        else if (key == 'p') {
        6:  500:            if (SwitchingBetween(&pBopomofo->pho_inx[2], 10, 13)) {
        1:  501:                return BOPOMOFO_ABSORB;
        -:  502:            }
        -:  503:        }
       32:  504:        if (type == 3) {        /* the key is NOT a phone */
    #####:  505:            if (isalpha(key))
    #####:  506:                return BOPOMOFO_NO_WORD;
    #####:  507:            return BOPOMOFO_KEY_ERROR;
        -:  508:        }
        -:  509:        /* fill the key into the phone buffer */
       32:  510:        pBopomofo->pho_inx[type] = inx;
       32:  511:        return BOPOMOFO_ABSORB;
        -:  512:    }
        -:  513:}
        -:  514:
      186:  515:static int IsPinYinEndKey(int key)
        -:  516:{
      186:  517:    if ((key == ' ') || (key == '1') || (key == '2') || (key == '3') || (key == '4') || (key == '5')) {
       45:  518:        return 1;
        -:  519:    }
      141:  520:    return 0;
        -:  521:}
        -:  522:
       45:  523:static int IsSymbolKey(int key)
        -:  524:{
       45:  525:    if ((key < 97) || (key > 122)) {
    #####:  526:        return 1;
        -:  527:    }
        -:  528:
       45:  529:    return 0;
        -:  530:}
        -:  531:
      186:  532:static int PinYinInput(ChewingData *pgdata, int key)
        -:  533:{
      186:  534:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
      186:  535:    int err = 0;
        -:  536:    unsigned int i;
        -:  537:    char bopomofoKeySeq[5], bopomofoKeySeqAlt[5], buf[2];
        -:  538:    size_t len;
        -:  539:
      186:  540:    DEBUG_CHECKPOINT();
        -:  541:
      186:  542:    if (pBopomofo->pinYinData.keySeq[0] == 0 && IsSymbolKey(key)) {
    #####:  543:        return BOPOMOFO_KEY_ERROR;
        -:  544:    }
        -:  545:
      186:  546:    if (IsPinYinEndKey(key)) {
       45:  547:        err = PinyinToBopomofo(pgdata, pBopomofo->pinYinData.keySeq, bopomofoKeySeq, bopomofoKeySeqAlt);
       45:  548:        if (err) {
    #####:  549:            pBopomofo->pinYinData.keySeq[0] = '\0';
    #####:  550:            return BOPOMOFO_ABSORB;
        -:  551:        }
        -:  552:
       45:  553:        DEBUG_OUT("bopomofoKeySeq: %s\n", bopomofoKeySeq);
       45:  554:        DEBUG_OUT("bopomofoKeySeqAlt: %s\n", bopomofoKeySeqAlt);
        -:  555:
       45:  556:        len = strlen(bopomofoKeySeq);
      138:  557:        for (i = 0; i < len; i++) {
       93:  558:            int type = 0, inx = 0;
        -:  559:
      189:  560:            for (type = 0; type <= 3; type++) {
      189:  561:                inx = PhoneInxFromKey(bopomofoKeySeq[i], type, pBopomofo->kbtype, 1);
      189:  562:                if (inx)
       93:  563:                    break;
        -:  564:            }
        -:  565:
        -:  566:            /* the key is NOT a phone */
       93:  567:            if (type > 3) {
    #####:  568:                return BOPOMOFO_KEY_ERROR;
        -:  569:            }
        -:  570:
       93:  571:            pBopomofo->pho_inx[type] = inx;
        -:  572:
        -:  573:        }
        -:  574:
       45:  575:        len = strlen(bopomofoKeySeqAlt);
      140:  576:        for (i = 0; i < len; i++) {
       95:  577:            int type = 0, inx = 0;
        -:  578:
      193:  579:            for (type = 0; type <= 3; type++) {
      193:  580:                inx = PhoneInxFromKey(bopomofoKeySeqAlt[i], type, pBopomofo->kbtype, 1);
      193:  581:                if (inx)
       95:  582:                    break;
        -:  583:            }
        -:  584:
        -:  585:            /* the key is NOT a phone */
       95:  586:            if (type > 3) {
    #####:  587:                return BOPOMOFO_KEY_ERROR;
        -:  588:            }
        -:  589:
       95:  590:            pBopomofo->pho_inx_alt[type] = inx;
        -:  591:
        -:  592:        }
        -:  593:
       45:  594:        switch (key) {
    #####:  595:        case '1':
    #####:  596:            key = ' ';
    #####:  597:            break;
        6:  598:        case '2':
        6:  599:            key = '6';
        6:  600:            break;
        3:  601:        case '5':
        3:  602:            key = '7';
        -:  603:        }
       45:  604:        pBopomofo->pinYinData.keySeq[0] = '\0';
       45:  605:        return EndKeyProcess(pgdata, key, 1);
        -:  606:    }
      141:  607:    buf[0] = key;
      141:  608:    buf[1] = '\0';
      141:  609:    strcat(pBopomofo->pinYinData.keySeq, buf);
        -:  610:
      141:  611:    DEBUG_OUT("PinYin Seq: %s\n", pBopomofo->pinYinData.keySeq);
        -:  612:
      141:  613:    return BOPOMOFO_ABSORB;
        -:  614:}
        -:  615:
        -:  616:/* key: ascii code of input, including space */
      620:  617:int BopomofoPhoInput(ChewingData *pgdata, int key)
        -:  618:{
      620:  619:    BopomofoData *pBopomofo = &(pgdata->bopomofoData);
        -:  620:
        -:  621:    /* open symbol table */
      620:  622:    if (key == '`') {
       18:  623:        pgdata->bSelect = 1;
       18:  624:        pgdata->choiceInfo.oldChiSymbolCursor = pgdata->chiSymbolCursor;
       18:  625:        HaninSymbolInput(pgdata);
       18:  626:        return BOPOMOFO_OPEN_SYMBOL_TABLE;
        -:  627:    }
      602:  628:    switch (pBopomofo->kbtype) {
       36:  629:    case KB_HSU:
        -:  630:    case KB_DVORAK_HSU:
       36:  631:        return HsuPhoInput(pgdata, key);
        -:  632:        break;
       36:  633:    case KB_ET26:
       36:  634:        return ET26PhoInput(pgdata, key);
        -:  635:        break;
       56:  636:    case KB_DACHEN_CP26:
       56:  637:        return DACHENCP26PhoInput(pgdata, key);
        -:  638:        break;
      186:  639:    case KB_HANYU_PINYIN:
        -:  640:    case KB_THL_PINYIN:
        -:  641:    case KB_MPS2_PINYIN:
      186:  642:        return PinYinInput(pgdata, key);
        -:  643:        break;
      288:  644:    default:
      288:  645:        return DefPhoInput(pgdata, key);
        -:  646:    }
        -:  647:    return BOPOMOFO_ERROR;
        -:  648:}
        -:  649:
        -:  650:/* remove the latest key */
        1:  651:int BopomofoRemoveLast(BopomofoData *pBopomofo)
        -:  652:{
        -:  653:    int i;
        -:  654:
        1:  655:    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {
    #####:  656:        i = strlen(pBopomofo->pinYinData.keySeq);
    #####:  657:        pBopomofo->pinYinData.keySeq[i - 1] = '\0';
        -:  658:    } else {
        2:  659:        for (i = 3; i >= 0; i--) {
        2:  660:            if (pBopomofo->pho_inx[i]) {
        1:  661:                pBopomofo->pho_inx[i] = 0;
        1:  662:                return 0;
        -:  663:            }
        -:  664:        }
        -:  665:    }
    #####:  666:    return 0;
        -:  667:}
        -:  668:
        -:  669:/* remove all the key entered */
       18:  670:int BopomofoRemoveAll(BopomofoData *pBopomofo)
        -:  671:{
       18:  672:    memset(pBopomofo->pho_inx, 0, sizeof(pBopomofo->pho_inx));
       18:  673:    memset(pBopomofo->pinYinData.keySeq, 0, sizeof(pBopomofo->pinYinData.keySeq));
       18:  674:    return 0;
        -:  675:}
        -:  676:
       80:  677:int BopomofoIsEntering(BopomofoData *pBopomofo)
        -:  678:{
        -:  679:    int i;
        -:  680:
       80:  681:    if (pBopomofo->kbtype >= KB_HANYU_PINYIN) {
    #####:  682:        if (pBopomofo->pinYinData.keySeq[0])
    #####:  683:            return 1;
        -:  684:    } else {
      344:  685:        for (i = 0; i < BOPOMOFO_SIZE; i++)
      280:  686:            if (pBopomofo->pho_inx[i])
       16:  687:                return 1;
        -:  688:    }
       64:  689:    return 0;
        -:  690:}
