        -:    0:Source:tif_next.c
        -:    1:/* $Id$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1988-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:#include "tiffiop.h"
        -:   28:#ifdef NEXT_SUPPORT
        -:   29:/*
        -:   30: * TIFF Library.
        -:   31: *
        -:   32: * NeXT 2-bit Grey Scale Compression Algorithm Support
        -:   33: */
        -:   34:
        -:   35:#define SETPIXEL(op, v) {			\
        -:   36:	switch (npixels++ & 3) {		\
        -:   37:	case 0:	op[0]  = (unsigned char) ((v) << 6); break;	\
        -:   38:	case 1:	op[0] |= (v) << 4; break;	\
        -:   39:	case 2:	op[0] |= (v) << 2; break;	\
        -:   40:	case 3:	*op++ |= (v);	   op_offset++; break;	\
        -:   41:	}					\
        -:   42:}
        -:   43:
        -:   44:#define LITERALROW	0x00
        -:   45:#define LITERALSPAN	0x40
        -:   46:#define WHITE   	((1<<2)-1)
        -:   47:
        -:   48:static int
    #####:   49:NeXTDecode(TIFF* tif, uint8* buf, tmsize_t occ, uint16 s)
        -:   50:{
        -:   51:	static const char module[] = "NeXTDecode";
        -:   52:	unsigned char *bp, *op;
        -:   53:	tmsize_t cc;
        -:   54:	uint8* row;
        -:   55:	tmsize_t scanline, n;
        -:   56:
        -:   57:	(void) s;
        -:   58:	/*
        -:   59:	 * Each scanline is assumed to start off as all
        -:   60:	 * white (we assume a PhotometricInterpretation
        -:   61:	 * of ``min-is-black'').
        -:   62:	 */
    #####:   63:	for (op = (unsigned char*) buf, cc = occ; cc-- > 0;)
    #####:   64:		*op++ = 0xff;
        -:   65:
    #####:   66:	bp = (unsigned char *)tif->tif_rawcp;
    #####:   67:	cc = tif->tif_rawcc;
    #####:   68:	scanline = tif->tif_scanlinesize;
    #####:   69:	if (occ % scanline)
        -:   70:	{
    #####:   71:		TIFFErrorExt(tif->tif_clientdata, module, "Fractional scanlines cannot be read");
    #####:   72:		return (0);
        -:   73:	}
    #####:   74:	for (row = buf; cc > 0 && occ > 0; occ -= scanline, row += scanline) {
    #####:   75:		n = *bp++;
    #####:   76:		cc--;
    #####:   77:		switch (n) {
    #####:   78:		case LITERALROW:
        -:   79:			/*
        -:   80:			 * The entire scanline is given as literal values.
        -:   81:			 */
    #####:   82:			if (cc < scanline)
    #####:   83:				goto bad;
    #####:   84:			_TIFFmemcpy(row, bp, scanline);
    #####:   85:			bp += scanline;
    #####:   86:			cc -= scanline;
    #####:   87:			break;
    #####:   88:		case LITERALSPAN: {
        -:   89:			tmsize_t off;
        -:   90:			/*
        -:   91:			 * The scanline has a literal span that begins at some
        -:   92:			 * offset.
        -:   93:			 */
    #####:   94:			if( cc < 4 )
    #####:   95:				goto bad;
    #####:   96:			off = (bp[0] * 256) + bp[1];
    #####:   97:			n = (bp[2] * 256) + bp[3];
    #####:   98:			if (cc < 4+n || off+n > scanline)
    #####:   99:				goto bad;
    #####:  100:			_TIFFmemcpy(row+off, bp+4, n);
    #####:  101:			bp += 4+n;
    #####:  102:			cc -= 4+n;
    #####:  103:			break;
        -:  104:		}
    #####:  105:		default: {
    #####:  106:			uint32 npixels = 0, grey;
    #####:  107:			tmsize_t op_offset = 0;
    #####:  108:			uint32 imagewidth = tif->tif_dir.td_imagewidth;
    #####:  109:            if( isTiled(tif) )
    #####:  110:                imagewidth = tif->tif_dir.td_tilewidth;
        -:  111:
        -:  112:			/*
        -:  113:			 * The scanline is composed of a sequence of constant
        -:  114:			 * color ``runs''.  We shift into ``run mode'' and
        -:  115:			 * interpret bytes as codes of the form
        -:  116:			 * <color><npixels> until we've filled the scanline.
        -:  117:			 */
    #####:  118:			op = row;
        -:  119:			for (;;) {
    #####:  120:				grey = (uint32)((n>>6) & 0x3);
    #####:  121:				n &= 0x3f;
        -:  122:				/*
        -:  123:				 * Ensure the run does not exceed the scanline
        -:  124:				 * bounds, potentially resulting in a security
        -:  125:				 * issue.
        -:  126:				 */
    #####:  127:				while (n-- > 0 && npixels < imagewidth && op_offset < scanline)
    #####:  128:					SETPIXEL(op, grey);
    #####:  129:				if (npixels >= imagewidth)
    #####:  130:					break;
    #####:  131:                if (op_offset >= scanline ) {
    #####:  132:                    TIFFErrorExt(tif->tif_clientdata, module, "Invalid data for scanline %ld",
    #####:  133:                        (long) tif->tif_row);
    #####:  134:                    return (0);
        -:  135:                }
    #####:  136:				if (cc == 0)
    #####:  137:					goto bad;
    #####:  138:				n = *bp++;
    #####:  139:				cc--;
        -:  140:			}
    #####:  141:			break;
        -:  142:		}
        -:  143:		}
        -:  144:	}
    #####:  145:	tif->tif_rawcp = (uint8*) bp;
    #####:  146:	tif->tif_rawcc = cc;
    #####:  147:	return (1);
    #####:  148:bad:
    #####:  149:	TIFFErrorExt(tif->tif_clientdata, module, "Not enough data for scanline %ld",
    #####:  150:	    (long) tif->tif_row);
    #####:  151:	return (0);
        -:  152:}
        -:  153:
        -:  154:static int
    #####:  155:NeXTPreDecode(TIFF* tif, uint16 s)
        -:  156:{
        -:  157:	static const char module[] = "NeXTPreDecode";
    #####:  158:	TIFFDirectory *td = &tif->tif_dir;
        -:  159:	(void)s;
        -:  160:
    #####:  161:	if( td->td_bitspersample != 2 )
        -:  162:	{
    #####:  163:		TIFFErrorExt(tif->tif_clientdata, module, "Unsupported BitsPerSample = %d",
    #####:  164:					 td->td_bitspersample);
    #####:  165:		return (0);
        -:  166:	}
    #####:  167:	return (1);
        -:  168:}
        -:  169:	
        -:  170:int
    #####:  171:TIFFInitNeXT(TIFF* tif, int scheme)
        -:  172:{
        -:  173:	(void) scheme;
    #####:  174:	tif->tif_predecode = NeXTPreDecode;  
    #####:  175:	tif->tif_decoderow = NeXTDecode;  
    #####:  176:	tif->tif_decodestrip = NeXTDecode;  
    #####:  177:	tif->tif_decodetile = NeXTDecode;
    #####:  178:	return (1);
        -:  179:}
        -:  180:#endif /* NEXT_SUPPORT */
        -:  181:
        -:  182:/* vim: set ts=8 sts=8 sw=8 noet: */
        -:  183:/*
        -:  184: * Local Variables:
        -:  185: * mode: c
        -:  186: * c-basic-offset: 8
        -:  187: * fill-column: 78
        -:  188: * End:
        -:  189: */
