        -:    0:Source:tif_dumpmode.c
        -:    1:/* $Header$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1988-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:/*
        -:   28: * TIFF Library.
        -:   29: *
        -:   30: * "Null" Compression Algorithm Support.
        -:   31: */
        -:   32:#include "tiffiop.h"
        -:   33:
        -:   34:static int
    #####:   35:DumpFixupTags(TIFF* tif)
        -:   36:{
        -:   37:	(void) tif;
    #####:   38:	return (1);
        -:   39:}
        -:   40:
        -:   41:/*
        -:   42: * Encode a hunk of pixels.
        -:   43: */
        -:   44:static int
    #####:   45:DumpModeEncode(TIFF* tif, uint8* pp, tmsize_t cc, uint16 s)
        -:   46:{
        -:   47:	(void) s;
    #####:   48:	while (cc > 0) {
        -:   49:		tmsize_t n;
        -:   50:
    #####:   51:		n = cc;
    #####:   52:		if (tif->tif_rawcc + n > tif->tif_rawdatasize)
    #####:   53:			n = tif->tif_rawdatasize - tif->tif_rawcc;
        -:   54:
    #####:   55:		assert( n > 0 );
        -:   56:
        -:   57:		/*
        -:   58:		 * Avoid copy if client has setup raw
        -:   59:		 * data buffer to avoid extra copy.
        -:   60:		 */
    #####:   61:		if (tif->tif_rawcp != pp)
    #####:   62:			_TIFFmemcpy(tif->tif_rawcp, pp, n);
    #####:   63:		tif->tif_rawcp += n;
    #####:   64:		tif->tif_rawcc += n;
    #####:   65:		pp += n;
    #####:   66:		cc -= n;
    #####:   67:		if (tif->tif_rawcc >= tif->tif_rawdatasize &&
    #####:   68:		    !TIFFFlushData1(tif))
    #####:   69:			return (0);
        -:   70:	}
    #####:   71:	return (1);
        -:   72:}
        -:   73:
        -:   74:/*
        -:   75: * Decode a hunk of pixels.
        -:   76: */
        -:   77:static int
    #####:   78:DumpModeDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
        -:   79:{
        -:   80:	static const char module[] = "DumpModeDecode";
        -:   81:	(void) s;
    #####:   82:	if (tif->tif_rawcc < cc) {
        -:   83:#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))
        -:   84:		TIFFErrorExt(tif->tif_clientdata, module,
        -:   85:"Not enough data for scanline %lu, expected a request for at most %I64d bytes, got a request for %I64d bytes",
        -:   86:		             (unsigned long) tif->tif_row,
        -:   87:		             (signed __int64) tif->tif_rawcc,
        -:   88:		             (signed __int64) cc);
        -:   89:#else
    #####:   90:		TIFFErrorExt(tif->tif_clientdata, module,
        -:   91:"Not enough data for scanline %lu, expected a request for at most %lld bytes, got a request for %lld bytes",
    #####:   92:		             (unsigned long) tif->tif_row,
    #####:   93:		             (signed long long) tif->tif_rawcc,
        -:   94:		             (signed long long) cc);
        -:   95:#endif
    #####:   96:		return (0);
        -:   97:	}
        -:   98:	/*
        -:   99:	 * Avoid copy if client has setup raw
        -:  100:	 * data buffer to avoid extra copy.
        -:  101:	 */
    #####:  102:	if (tif->tif_rawcp != buf)
    #####:  103:		_TIFFmemcpy(buf, tif->tif_rawcp, cc);
    #####:  104:	tif->tif_rawcp += cc;
    #####:  105:	tif->tif_rawcc -= cc;  
    #####:  106:	return (1);
        -:  107:}
        -:  108:
        -:  109:/*
        -:  110: * Seek forwards nrows in the current strip.
        -:  111: */
        -:  112:static int
    #####:  113:DumpModeSeek(TIFF* tif, uint32 nrows)
        -:  114:{
    #####:  115:	tif->tif_rawcp += nrows * tif->tif_scanlinesize;
    #####:  116:	tif->tif_rawcc -= nrows * tif->tif_scanlinesize;
    #####:  117:	return (1);
        -:  118:}
        -:  119:
        -:  120:/*
        -:  121: * Initialize dump mode.
        -:  122: */
        -:  123:int
        5:  124:TIFFInitDumpMode(TIFF* tif, int scheme)
        -:  125:{
        -:  126:	(void) scheme;
        5:  127:	tif->tif_fixuptags = DumpFixupTags;  
        5:  128:	tif->tif_decoderow = DumpModeDecode;
        5:  129:	tif->tif_decodestrip = DumpModeDecode;
        5:  130:	tif->tif_decodetile = DumpModeDecode;
        5:  131:	tif->tif_encoderow = DumpModeEncode;
        5:  132:	tif->tif_encodestrip = DumpModeEncode;
        5:  133:	tif->tif_encodetile = DumpModeEncode; 
        5:  134:	tif->tif_seek = DumpModeSeek;
        5:  135:	return (1);
        -:  136:}
        -:  137:/*
        -:  138: * Local Variables:
        -:  139: * mode: c
        -:  140: * c-basic-offset: 8
        -:  141: * fill-column: 78
        -:  142: * End:
        -:  143: */
