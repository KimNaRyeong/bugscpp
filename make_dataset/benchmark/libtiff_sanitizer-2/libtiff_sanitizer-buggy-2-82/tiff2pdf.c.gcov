        -:    0:Source:tiff2pdf.c
        -:    1:/* $Id$
        -:    2: *
        -:    3: * tiff2pdf - converts a TIFF image to a PDF document
        -:    4: *
        -:    5: * Copyright (c) 2003 Ross Finlayson
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the name of
        -:   11: * Ross Finlayson may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Ross Finlayson.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL ROSS FINLAYSON BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:#include "tif_config.h"
        -:   28:
        -:   29:#include <stdio.h>
        -:   30:#include <stdlib.h>
        -:   31:#include <string.h>
        -:   32:#include <ctype.h>
        -:   33:#include <time.h>
        -:   34:#include <errno.h>
        -:   35:#include <limits.h>
        -:   36:
        -:   37:#if HAVE_UNISTD_H
        -:   38:# include <unistd.h>
        -:   39:#endif
        -:   40:
        -:   41:#ifdef HAVE_FCNTL_H
        -:   42:# include <fcntl.h>
        -:   43:#endif
        -:   44:
        -:   45:#ifdef HAVE_IO_H
        -:   46:# include <io.h>
        -:   47:#endif
        -:   48:
        -:   49:#ifdef NEED_LIBPORT
        -:   50:# include "libport.h"
        -:   51:#endif
        -:   52:
        -:   53:#include "tiffiop.h"
        -:   54:#include "tiffio.h"
        -:   55:
        -:   56:#ifndef HAVE_GETOPT
        -:   57:extern int getopt(int, char**, char*);
        -:   58:#endif
        -:   59:
        -:   60:#ifndef EXIT_SUCCESS
        -:   61:# define EXIT_SUCCESS	0
        -:   62:#endif
        -:   63:#ifndef EXIT_FAILURE
        -:   64:# define EXIT_FAILURE	1
        -:   65:#endif
        -:   66:
        -:   67:#define TIFF2PDF_MODULE "tiff2pdf"
        -:   68:
        -:   69:#define PS_UNIT_SIZE	72.0F
        -:   70:
        -:   71:/* This type is of PDF color spaces. */
        -:   72:typedef enum {
        -:   73:	T2P_CS_BILEVEL = 0x01,	/* Bilevel, black and white */
        -:   74:	T2P_CS_GRAY = 0x02,	/* Single channel */
        -:   75:	T2P_CS_RGB = 0x04,	/* Three channel tristimulus RGB */
        -:   76:	T2P_CS_CMYK = 0x08,	/* Four channel CMYK print inkset */
        -:   77:	T2P_CS_LAB = 0x10,	/* Three channel L*a*b* color space */
        -:   78:	T2P_CS_PALETTE = 0x1000,/* One of the above with a color map */
        -:   79:	T2P_CS_CALGRAY = 0x20,	/* Calibrated single channel */
        -:   80:	T2P_CS_CALRGB = 0x40,	/* Calibrated three channel tristimulus RGB */
        -:   81:	T2P_CS_ICCBASED = 0x80	/* ICC profile color specification */
        -:   82:} t2p_cs_t;
        -:   83:
        -:   84:/* This type is of PDF compression types.  */
        -:   85:typedef enum{
        -:   86:	T2P_COMPRESS_NONE=0x00
        -:   87:#ifdef CCITT_SUPPORT
        -:   88:	, T2P_COMPRESS_G4=0x01
        -:   89:#endif
        -:   90:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
        -:   91:	, T2P_COMPRESS_JPEG=0x02
        -:   92:#endif
        -:   93:#ifdef ZIP_SUPPORT
        -:   94:	, T2P_COMPRESS_ZIP=0x04
        -:   95:#endif
        -:   96:} t2p_compress_t;
        -:   97:
        -:   98:/* This type is whether TIFF image data can be used in PDF without transcoding. */
        -:   99:typedef enum{
        -:  100:	T2P_TRANSCODE_RAW=0x01, /* The raw data from the input can be used without recompressing */
        -:  101:	T2P_TRANSCODE_ENCODE=0x02 /* The data from the input is perhaps unencoded and reencoded */
        -:  102:} t2p_transcode_t;
        -:  103:
        -:  104:/* This type is of information about the data samples of the input image. */
        -:  105:typedef enum{
        -:  106:	T2P_SAMPLE_NOTHING=0x0000, /* The unencoded samples are normal for the output colorspace */
        -:  107:	T2P_SAMPLE_ABGR_TO_RGB=0x0001, /* The unencoded samples are the result of ReadRGBAImage */
        -:  108:	T2P_SAMPLE_RGBA_TO_RGB=0x0002, /* The unencoded samples are contiguous RGBA */
        -:  109:	T2P_SAMPLE_RGBAA_TO_RGB=0x0004, /* The unencoded samples are RGBA with premultiplied alpha */
        -:  110:	T2P_SAMPLE_YCBCR_TO_RGB=0x0008, 
        -:  111:	T2P_SAMPLE_YCBCR_TO_LAB=0x0010, 
        -:  112:	T2P_SAMPLE_REALIZE_PALETTE=0x0020, /* The unencoded samples are indexes into the color map */
        -:  113:	T2P_SAMPLE_SIGNED_TO_UNSIGNED=0x0040, /* The unencoded samples are signed instead of unsignd */
        -:  114:	T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED=0x0040, /* The L*a*b* samples have a* and b* signed */
        -:  115:	T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG=0x0100 /* The unencoded samples are separate instead of contiguous */
        -:  116:} t2p_sample_t;
        -:  117:
        -:  118:/* This type is of error status of the T2P struct. */
        -:  119:typedef enum{
        -:  120:	T2P_ERR_OK = 0, /* This is the value of t2p->t2p_error when there is no error */
        -:  121:	T2P_ERR_ERROR = 1 /* This is the value of t2p->t2p_error when there was an error */
        -:  122:} t2p_err_t;
        -:  123:
        -:  124:/* This struct defines a logical page of a TIFF. */
        -:  125:typedef struct {
        -:  126:	tdir_t page_directory;
        -:  127:	uint32 page_number;
        -:  128:	ttile_t page_tilecount;
        -:  129:	uint32 page_extra;
        -:  130:} T2P_PAGE;
        -:  131:
        -:  132:/* This struct defines a PDF rectangle's coordinates. */
        -:  133:typedef struct {
        -:  134:	float x1;
        -:  135:	float y1;
        -:  136:	float x2;
        -:  137:	float y2;
        -:  138:	float mat[9];
        -:  139:} T2P_BOX;
        -:  140:
        -:  141:/* This struct defines a tile of a PDF.  */
        -:  142:typedef struct {
        -:  143:	T2P_BOX tile_box;
        -:  144:} T2P_TILE;
        -:  145:
        -:  146:/* This struct defines information about the tiles on a PDF page. */
        -:  147:typedef struct {
        -:  148:	ttile_t tiles_tilecount;
        -:  149:	uint32 tiles_tilewidth;
        -:  150:	uint32 tiles_tilelength;
        -:  151:	uint32 tiles_tilecountx;
        -:  152:	uint32 tiles_tilecounty;
        -:  153:	uint32 tiles_edgetilewidth;
        -:  154:	uint32 tiles_edgetilelength;
        -:  155:	T2P_TILE* tiles_tiles;
        -:  156:} T2P_TILES;
        -:  157:
        -:  158:/* This struct is the context of a function to generate PDF from a TIFF. */
        -:  159:typedef struct {
        -:  160:	t2p_err_t t2p_error;
        -:  161:	T2P_PAGE* tiff_pages;
        -:  162:	T2P_TILES* tiff_tiles;
        -:  163:	tdir_t tiff_pagecount;
        -:  164:	uint16 tiff_compression;
        -:  165:	uint16 tiff_photometric;
        -:  166:	uint16 tiff_fillorder;
        -:  167:	uint16 tiff_bitspersample;
        -:  168:	uint16 tiff_samplesperpixel;
        -:  169:	uint16 tiff_planar;
        -:  170:	uint32 tiff_width;
        -:  171:	uint32 tiff_length;
        -:  172:	float tiff_xres;
        -:  173:	float tiff_yres;
        -:  174:	uint16 tiff_orientation;
        -:  175:	toff_t tiff_dataoffset;
        -:  176:	tsize_t tiff_datasize;
        -:  177:	uint16 tiff_resunit;
        -:  178:	uint16 pdf_centimeters;
        -:  179:	uint16 pdf_overrideres;
        -:  180:	uint16 pdf_overridepagesize;
        -:  181:	float pdf_defaultxres;
        -:  182:	float pdf_defaultyres;
        -:  183:	float pdf_xres;
        -:  184:	float pdf_yres;
        -:  185:	float pdf_defaultpagewidth;
        -:  186:	float pdf_defaultpagelength;
        -:  187:	float pdf_pagewidth;
        -:  188:	float pdf_pagelength;
        -:  189:	float pdf_imagewidth;
        -:  190:	float pdf_imagelength;
        -:  191:	int pdf_image_fillpage; /* 0 (default: no scaling, 1:scale imagesize to pagesize */
        -:  192:	T2P_BOX pdf_mediabox;
        -:  193:	T2P_BOX pdf_imagebox;
        -:  194:	uint16 pdf_majorversion;
        -:  195:	uint16 pdf_minorversion;
        -:  196:	uint32 pdf_catalog;
        -:  197:	uint32 pdf_pages;
        -:  198:	uint32 pdf_info;
        -:  199:	uint32 pdf_palettecs;
        -:  200:	uint16 pdf_fitwindow;
        -:  201:	uint32 pdf_startxref;
        -:  202:#define TIFF2PDF_FILEID_SIZE 33
        -:  203:	char pdf_fileid[TIFF2PDF_FILEID_SIZE];
        -:  204:#define TIFF2PDF_DATETIME_SIZE 17
        -:  205:	char pdf_datetime[TIFF2PDF_DATETIME_SIZE];
        -:  206:#define TIFF2PDF_CREATOR_SIZE 512
        -:  207:	char pdf_creator[TIFF2PDF_CREATOR_SIZE];
        -:  208:#define TIFF2PDF_AUTHOR_SIZE 512
        -:  209:	char pdf_author[TIFF2PDF_AUTHOR_SIZE];
        -:  210:#define TIFF2PDF_TITLE_SIZE 512
        -:  211:	char pdf_title[TIFF2PDF_TITLE_SIZE];
        -:  212:#define TIFF2PDF_SUBJECT_SIZE 512
        -:  213:	char pdf_subject[TIFF2PDF_SUBJECT_SIZE];
        -:  214:#define TIFF2PDF_KEYWORDS_SIZE 512
        -:  215:	char pdf_keywords[TIFF2PDF_KEYWORDS_SIZE];
        -:  216:	t2p_cs_t pdf_colorspace;
        -:  217:	uint16 pdf_colorspace_invert;
        -:  218:	uint16 pdf_switchdecode;
        -:  219:	uint16 pdf_palettesize;
        -:  220:	unsigned char* pdf_palette;
        -:  221:	int pdf_labrange[4];
        -:  222:	t2p_compress_t pdf_defaultcompression;
        -:  223:	uint16 pdf_defaultcompressionquality;
        -:  224:	t2p_compress_t pdf_compression;
        -:  225:	uint16 pdf_compressionquality;
        -:  226:	uint16 pdf_nopassthrough;
        -:  227:	t2p_transcode_t pdf_transcode;
        -:  228:	t2p_sample_t pdf_sample;
        -:  229:	uint32* pdf_xrefoffsets;
        -:  230:	uint32 pdf_xrefcount;
        -:  231:	tdir_t pdf_page;
        -:  232:#ifdef OJPEG_SUPPORT
        -:  233:	tdata_t pdf_ojpegdata;
        -:  234:	uint32 pdf_ojpegdatalength;
        -:  235:	uint32 pdf_ojpegiflength;
        -:  236:#endif
        -:  237:	float tiff_whitechromaticities[2];
        -:  238:	float tiff_primarychromaticities[6];
        -:  239:	float tiff_referenceblackwhite[2];
        -:  240:	float* tiff_transferfunction[3];
        -:  241:	int pdf_image_interpolate;	/* 0 (default) : do not interpolate,
        -:  242:					   1 : interpolate */
        -:  243:	uint16 tiff_transferfunctioncount;
        -:  244:	uint32 pdf_icccs;
        -:  245:	uint32 tiff_iccprofilelength;
        -:  246:	tdata_t tiff_iccprofile;
        -:  247:
        -:  248:	/* fields for custom read/write procedures */
        -:  249:	FILE *outputfile;
        -:  250:	int outputdisable;
        -:  251:	tsize_t outputwritten;
        -:  252:} T2P;
        -:  253:
        -:  254:/* These functions are called by main. */
        -:  255:
        -:  256:void tiff2pdf_usage(void);
        -:  257:int tiff2pdf_match_paper_size(float*, float*, char*);
        -:  258:
        -:  259:/* These functions are used to generate a PDF from a TIFF. */ 
        -:  260:
        -:  261:#ifdef __cplusplus
        -:  262:extern "C" {
        -:  263:#endif
        -:  264:
        -:  265:T2P* t2p_init(void);
        -:  266:void t2p_validate(T2P*);
        -:  267:tsize_t t2p_write_pdf(T2P*, TIFF*, TIFF*);
        -:  268:void t2p_free(T2P*);
        -:  269:
        -:  270:#ifdef __cplusplus
        -:  271:}
        -:  272:#endif
        -:  273:
        -:  274:void t2p_read_tiff_init(T2P*, TIFF*);
        -:  275:int t2p_cmp_t2p_page(const void*, const void*);
        -:  276:void t2p_read_tiff_data(T2P*, TIFF*);
        -:  277:void t2p_read_tiff_size(T2P*, TIFF*);
        -:  278:void t2p_read_tiff_size_tile(T2P*, TIFF*, ttile_t);
        -:  279:int t2p_tile_is_right_edge(T2P_TILES, ttile_t);
        -:  280:int t2p_tile_is_bottom_edge(T2P_TILES, ttile_t);
        -:  281:int t2p_tile_is_edge(T2P_TILES, ttile_t);
        -:  282:int t2p_tile_is_corner_edge(T2P_TILES, ttile_t);
        -:  283:tsize_t t2p_readwrite_pdf_image(T2P*, TIFF*, TIFF*);
        -:  284:tsize_t t2p_readwrite_pdf_image_tile(T2P*, TIFF*, TIFF*, ttile_t);
        -:  285:#ifdef OJPEG_SUPPORT
        -:  286:int t2p_process_ojpeg_tables(T2P*, TIFF*);
        -:  287:#endif
        -:  288:#ifdef JPEG_SUPPORT
        -:  289:int t2p_process_jpeg_strip(unsigned char*, tsize_t*, unsigned char*, tsize_t, tsize_t*, tstrip_t, uint32);
        -:  290:#endif
        -:  291:void t2p_tile_collapse_left(tdata_t, tsize_t, uint32, uint32, uint32);
        -:  292:void t2p_write_advance_directory(T2P*, TIFF*);
        -:  293:tsize_t t2p_sample_planar_separate_to_contig(T2P*, unsigned char*, unsigned char*, tsize_t);
        -:  294:tsize_t t2p_sample_realize_palette(T2P*, unsigned char*);
        -:  295:tsize_t t2p_sample_abgr_to_rgb(tdata_t, uint32);
        -:  296:tsize_t t2p_sample_rgba_to_rgb(tdata_t, uint32);
        -:  297:tsize_t t2p_sample_rgbaa_to_rgb(tdata_t, uint32);
        -:  298:tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t, uint32);
        -:  299:tsize_t t2p_write_pdf_header(T2P*, TIFF*);
        -:  300:tsize_t t2p_write_pdf_obj_start(uint32, TIFF*);
        -:  301:tsize_t t2p_write_pdf_obj_end(TIFF*);
        -:  302:tsize_t t2p_write_pdf_name(unsigned char*, TIFF*);
        -:  303:tsize_t t2p_write_pdf_string(char*, TIFF*);
        -:  304:tsize_t t2p_write_pdf_stream(tdata_t, tsize_t, TIFF*);
        -:  305:tsize_t t2p_write_pdf_stream_start(TIFF*);
        -:  306:tsize_t t2p_write_pdf_stream_end(TIFF*);
        -:  307:tsize_t t2p_write_pdf_stream_dict(tsize_t, uint32, TIFF*);
        -:  308:tsize_t t2p_write_pdf_stream_dict_start(TIFF*);
        -:  309:tsize_t t2p_write_pdf_stream_dict_end(TIFF*);
        -:  310:tsize_t t2p_write_pdf_stream_length(tsize_t, TIFF*);
        -:  311:tsize_t t2p_write_pdf_catalog(T2P*, TIFF*);
        -:  312:tsize_t t2p_write_pdf_info(T2P*, TIFF*, TIFF*);
        -:  313:void t2p_pdf_currenttime(T2P*);
        -:  314:void t2p_pdf_tifftime(T2P*, TIFF*);
        -:  315:tsize_t t2p_write_pdf_pages(T2P*, TIFF*);
        -:  316:tsize_t t2p_write_pdf_page(uint32, T2P*, TIFF*);
        -:  317:void t2p_compose_pdf_page(T2P*);
        -:  318:void t2p_compose_pdf_page_orient(T2P_BOX*, uint16);
        -:  319:void t2p_compose_pdf_page_orient_flip(T2P_BOX*, uint16);
        -:  320:tsize_t t2p_write_pdf_page_content(T2P*, TIFF*);
        -:  321:tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t, T2P*, TIFF*);
        -:  322:tsize_t t2p_write_pdf_xobject_cs(T2P*, TIFF*);
        -:  323:tsize_t t2p_write_pdf_transfer(T2P*, TIFF*);
        -:  324:tsize_t t2p_write_pdf_transfer_dict(T2P*, TIFF*, uint16);
        -:  325:tsize_t t2p_write_pdf_transfer_stream(T2P*, TIFF*, uint16);
        -:  326:tsize_t t2p_write_pdf_xobject_calcs(T2P*, TIFF*);
        -:  327:tsize_t t2p_write_pdf_xobject_icccs(T2P*, TIFF*);
        -:  328:tsize_t t2p_write_pdf_xobject_icccs_dict(T2P*, TIFF*);
        -:  329:tsize_t t2p_write_pdf_xobject_icccs_stream(T2P*, TIFF*);
        -:  330:tsize_t t2p_write_pdf_xobject_cs_stream(T2P*, TIFF*);
        -:  331:tsize_t t2p_write_pdf_xobject_decode(T2P*, TIFF*);
        -:  332:tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t, T2P*, TIFF*);
        -:  333:tsize_t t2p_write_pdf_xreftable(T2P*, TIFF*);
        -:  334:tsize_t t2p_write_pdf_trailer(T2P*, TIFF*);
        -:  335:
        -:  336:#define check_snprintf_ret(t2p, rv, buf) do { \
        -:  337:	if ((rv) < 0) rv = 0; \
        -:  338:	else if((rv) >= (int)sizeof(buf)) (rv) = sizeof(buf) - 1; \
        -:  339:	else break; \
        -:  340:	if ((t2p) != NULL) (t2p)->t2p_error = T2P_ERR_ERROR; \
        -:  341:} while(0)
        -:  342:
        -:  343:static void
    #####:  344:t2p_disable(TIFF *tif)
        -:  345:{
    #####:  346:	T2P *t2p = (T2P*) TIFFClientdata(tif);
    #####:  347:	t2p->outputdisable = 1;
    #####:  348:}
        -:  349:
        -:  350:static void
    #####:  351:t2p_enable(TIFF *tif)
        -:  352:{
    #####:  353:	T2P *t2p = (T2P*) TIFFClientdata(tif);
    #####:  354:	t2p->outputdisable = 0;
    #####:  355:}
        -:  356:
        -:  357:/*
        -:  358: * Procs for TIFFClientOpen
        -:  359: */
        -:  360:
        -:  361:#ifdef OJPEG_SUPPORT
        -:  362:static tmsize_t 
    #####:  363:t2pReadFile(TIFF *tif, tdata_t data, tmsize_t size)
        -:  364:{
    #####:  365:	thandle_t client = TIFFClientdata(tif);
    #####:  366:	TIFFReadWriteProc proc = TIFFGetReadProc(tif);
    #####:  367:	if (proc)
    #####:  368:		return proc(client, data, size);
    #####:  369:	return -1;
        -:  370:}
        -:  371:#endif /* OJPEG_SUPPORT */
        -:  372:
        -:  373:static tmsize_t 
      180:  374:t2pWriteFile(TIFF *tif, tdata_t data, tmsize_t size)
        -:  375:{
      180:  376:	thandle_t client = TIFFClientdata(tif);
      180:  377:	TIFFReadWriteProc proc = TIFFGetWriteProc(tif);
      180:  378:	if (proc)
      180:  379:		return proc(client, data, size);
    #####:  380:	return -1;
        -:  381:}
        -:  382:
        -:  383:static uint64
        1:  384:t2pSeekFile(TIFF *tif, toff_t offset, int whence)
        -:  385:{
        1:  386:	thandle_t client = TIFFClientdata(tif);
        1:  387:	TIFFSeekProc proc = TIFFGetSeekProc(tif);
        1:  388:	if (proc)
        1:  389:		return proc(client, offset, whence);
    #####:  390:	return -1;
        -:  391:}
        -:  392:
        -:  393:static tmsize_t 
    #####:  394:t2p_readproc(thandle_t handle, tdata_t data, tmsize_t size) 
        -:  395:{
        -:  396:	(void) handle, (void) data, (void) size;
    #####:  397:	return -1;
        -:  398:}
        -:  399:
        -:  400:static tmsize_t 
      181:  401:t2p_writeproc(thandle_t handle, tdata_t data, tmsize_t size) 
        -:  402:{
      181:  403:	T2P *t2p = (T2P*) handle;
      181:  404:	if (t2p->outputdisable <= 0 && t2p->outputfile) {
     180*:  405:		tsize_t written = fwrite(data, 1, size, t2p->outputfile);
      180:  406:		t2p->outputwritten += written;
      180:  407:		return written;
        -:  408:	}
        1:  409:	return size; 
        -:  410:}
        -:  411:
        -:  412:static uint64 
        2:  413:t2p_seekproc(thandle_t handle, uint64 offset, int whence) 
        -:  414:{ 
        2:  415:	T2P *t2p = (T2P*) handle;
        2:  416:	if (t2p->outputdisable <= 0 && t2p->outputfile)
        1:  417:		return _TIFF_fseek_f(t2p->outputfile, (_TIFF_off_t) offset, whence);
        1:  418:	return offset;
        -:  419:}
        -:  420:
        -:  421:static int 
    #####:  422:t2p_closeproc(thandle_t handle)
        -:  423:{ 
    #####:  424:	T2P *t2p = (T2P*) handle;
    #####:  425:	return fclose(t2p->outputfile);
        -:  426:}
        -:  427:
        -:  428:static uint64 
    #####:  429:t2p_sizeproc(thandle_t handle) 
        -:  430:{
        -:  431:	(void) handle;
    #####:  432:	return -1;
        -:  433:}
        -:  434:
        -:  435:static int 
    #####:  436:t2p_mapproc(thandle_t handle, void **data, toff_t *offset) 
        -:  437:{ 
        -:  438:	(void) handle, (void) data, (void) offset;
    #####:  439:	return -1; 
        -:  440:}
        -:  441:
        -:  442:static void 
    #####:  443:t2p_unmapproc(thandle_t handle, void *data, toff_t offset)
        -:  444:{ 
        -:  445:	(void) handle, (void) data, (void) offset;
    #####:  446:}
        -:  447:
        -:  448:#if defined(OJPEG_SUPPORT) || defined(JPEG_SUPPORT)
        -:  449:static uint64
    #####:  450:checkAdd64(uint64 summand1, uint64 summand2, T2P* t2p)
        -:  451:{
    #####:  452:	uint64 bytes = summand1 + summand2;
        -:  453:
    #####:  454:	if (bytes < summand1) {
    #####:  455:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####:  456:		t2p->t2p_error = T2P_ERR_ERROR;
    #####:  457:		bytes = 0;
        -:  458:	}
        -:  459:
    #####:  460:	return bytes;
        -:  461:}
        -:  462:#endif /* defined(OJPEG_SUPPORT) || defined(JPEG_SUPPORT) */
        -:  463:
        -:  464:static uint64
    #####:  465:checkMultiply64(uint64 first, uint64 second, T2P* t2p)
        -:  466:{
    #####:  467:	uint64 bytes = first * second;
        -:  468:
    #####:  469:	if (second && bytes / second != first) {
    #####:  470:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####:  471:		t2p->t2p_error = T2P_ERR_ERROR;
    #####:  472:		bytes = 0;
        -:  473:	}
        -:  474:
    #####:  475:	return bytes;
        -:  476:}
        -:  477:
        -:  478:/*
        -:  479:
        -:  480:  This is the main function.
        -:  481:
        -:  482:  The program converts one TIFF file to one PDF file, including multiple page 
        -:  483:  TIFF files, tiled TIFF files, black and white. grayscale, and color TIFF 
        -:  484:  files that contain data of TIFF photometric interpretations of bilevel, 
        -:  485:  grayscale, RGB, YCbCr, CMYK separation, and ICC L*a*b* as supported by 
        -:  486:  libtiff and PDF.
        -:  487:
        -:  488:  If you have multiple TIFF files to convert into one PDF file then use tiffcp 
        -:  489:  or other program to concatenate the files into a multiple page TIFF file.  
        -:  490:  If the input TIFF file is of huge dimensions (greater than 10000 pixels height
        -:  491:  or width) convert the input image to a tiled TIFF if it is not already.
        -:  492:
        -:  493:  The standard output is standard output.  Set the output file name with the 
        -:  494:  "-o output.pdf" option.
        -:  495:
        -:  496:  All black and white files are compressed into a single strip CCITT G4 Fax 
        -:  497:  compressed PDF, unless tiled, where tiled black and white images are 
        -:  498:  compressed into tiled CCITT G4 Fax compressed PDF, libtiff CCITT support 
        -:  499:  is assumed.
        -:  500:
        -:  501:  Color and grayscale data can be compressed using either JPEG compression, 
        -:  502:  ITU-T T.81, or Zip/Deflate LZ77 compression, per PNG 1.2 and RFC 1951.  Set 
        -:  503:  the compression type using the -j or -z options.  JPEG compression support 
        -:  504:  requires that libtiff be configured with JPEG support, and Zip/Deflate 
        -:  505:  compression support requires that libtiff is configured with Zip support, 
        -:  506:  in tiffconf.h.  Use only one or the other of -j and -z.  The -q option 
        -:  507:  sets the image compression quality, that is 1-100 with libjpeg JPEG 
        -:  508:  compression and one of 1, 10, 11, 12, 13, 14, or 15 for PNG group compression 
        -:  509:  predictor methods, add 100, 200, ..., 900 to set zlib compression quality 1-9.
        -:  510:  PNG Group differencing predictor methods are not currently implemented.
        -:  511:
        -:  512:  If the input TIFF contains single strip CCITT G4 Fax compressed information, 
        -:  513:  then that is written to the PDF file without transcoding, unless the options 
        -:  514:  of no compression and no passthrough are set, -d and -n.
        -:  515:
        -:  516:  If the input TIFF contains JPEG or single strip Zip/Deflate compressed 
        -:  517:  information, and they are configured, then that is written to the PDF file 
        -:  518:  without transcoding, unless the options of no compression and no passthrough 
        -:  519:  are set.
        -:  520:
        -:  521:  The default page size upon which the TIFF image is placed is determined by 
        -:  522:  the resolution and extent of the image data.  Default values for the TIFF 
        -:  523:  image resolution can be set using the -x and -y options.  The page size can 
        -:  524:  be set using the -p option for paper size, or -w and -l for paper width and 
        -:  525:  length, then each page of the TIFF image is centered on its page.  The 
        -:  526:  distance unit for default resolution and page width and length can be set 
        -:  527:  by the -u option, the default unit is inch.
        -:  528:
        -:  529:  Various items of the output document information can be set with the -e, -c, 
        -:  530:  -a, -t, -s, and -k tags.  Setting the argument of the option to "" for these 
        -:  531:  tags causes the relevant document information field to be not written.  Some 
        -:  532:  of the document information values otherwise get their information from the 
        -:  533:  input TIFF image, the software, author, document name, and image description.
        -:  534:
        -:  535:  The output PDF file conforms to the PDF 1.1 specification or PDF 1.2 if using 
        -:  536:  Zip/Deflate compression.  
        -:  537:  
        -:  538:  The Portable Document Format (PDF) specification is copyrighted by Adobe 
        -:  539:  Systems, Incorporated.  Todos derechos reservados.
        -:  540:
        -:  541:  Here is a listing of the usage example and the options to the tiff2pdf 
        -:  542:  program that is part of the libtiff distribution.  Options followed by 
        -:  543:  a colon have a required argument.
        -:  544:  
        -:  545:    usage:  tiff2pdf [options] input.tif
        -:  546:
        -:  547:    options:
        -:  548:    -o: output to file name
        -:  549:
        -:  550:    -j: compress with JPEG (requires libjpeg configured with libtiff)
        -:  551:    -z: compress with Zip/Deflate (requires zlib configured with libtiff)
        -:  552:    -q: compression quality
        -:  553:    -n: no compressed data passthrough
        -:  554:    -d: do not compress (decompress)
        -:  555:    -i: invert colors
        -:  556:    -u: set distance unit, 'i' for inch, 'm' for centimeter
        -:  557:    -x: set x resolution default
        -:  558:    -y: set y resolution default
        -:  559:    -w: width in units
        -:  560:    -l: length in units
        -:  561:    -r: 'd' for resolution default, 'o' for resolution override
        -:  562:    -p: paper size, eg "letter", "legal", "a4"
        -:  563:    -F: make the tiff fill the PDF page
        -:  564:    -f: set pdf "fit window" user preference
        -:  565:    -b:	set PDF "Interpolate" user preference
        -:  566:    -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS
        -:  567:    -c: creator, overrides image software default
        -:  568:    -a: author, overrides image artist default
        -:  569:    -t: title, overrides image document name default
        -:  570:    -s: subject, overrides image image description default
        -:  571:    -k: keywords
        -:  572:
        -:  573:    -h: usage
        -:  574:
        -:  575:    examples:
        -:  576:
        -:  577:        tiff2pdf -o output.pdf input.tiff
        -:  578:
        -:  579:    The above example would generate the file output.pdf from input.tiff.
        -:  580:
        -:  581:        tiff2pdf input.tiff
        -:  582:
        -:  583:    The above example would generate PDF output from input.tiff and write it
        -:  584:    to standard output.
        -:  585:
        -:  586:        tiff2pdf -j -p letter -o output.pdf input.tiff
        -:  587:
        -:  588:    The above example would generate the file output.pdf from input.tiff,
        -:  589:    putting the image pages on a letter sized page, compressing the output
        -:  590:    with JPEG.
        -:  591:
        -:  592:	Please report bugs through:
        -:  593:
        -:  594:	http://bugzilla.remotesensing.org/buglist.cgi?product=libtiff
        -:  595:
        -:  596:    See also libtiff.3t, tiffcp.
        -:  597:  */
        -:  598:
        -:  599:#ifdef DPP_ENABLE_GCOV
        -:  600:#include <signal.h>
        -:  601:static struct sigaction dpp_gcov_sigaction;
        -:  602:static struct sigaction dpp_orig_sigaction;
    #####:  603:void dpp_sighandler(int signum) {
    #####:  604:	__gcov_flush();
    #####:  605:	sigaction(sigaction, &dpp_orig_sigaction, NULL);
    #####:  606:	raise(signum);
    #####:  607:	exit(1);
        -:  608:}
        -:  609:#endif
        1:  610:void __asan_on_error(void) {
        -:  611:#ifdef DPP_ENABLE_GCOV
        1:  612:    __gcov_flush();
        -:  613:#endif
    #####:  614:}
        -:  615:int
        1:  616:main(int argc, char* argv[])
        -:  617:{
        -:  618:#ifdef DPP_ENABLE_GCOV
        -:  619:	  {
        1:  620:		  dpp_gcov_sigaction.sa_handler = dpp_sighandler;
        1:  621:		  sigemptyset(&dpp_gcov_sigaction.sa_mask);
        1:  622:		  dpp_gcov_sigaction.sa_flags = 0;
        1:  623:		  sigaction(SIGSEGV, &dpp_gcov_sigaction, &dpp_orig_sigaction);
        1:  624:		  sigaction(SIGFPE, &dpp_gcov_sigaction, &dpp_orig_sigaction);
        1:  625:		  sigaction(SIGABRT, &dpp_gcov_sigaction, &dpp_orig_sigaction);
        -:  626:	  }
        -:  627:#endif
        -:  628:#if !HAVE_DECL_OPTARG
        -:  629:	extern char *optarg;
        -:  630:	extern int optind;
        -:  631:#endif
        1:  632:	const char *outfilename = NULL;
        1:  633:	T2P *t2p = NULL;
        1:  634:	TIFF *input = NULL, *output = NULL;
        1:  635:	int c, ret = EXIT_SUCCESS;
        -:  636:
        1:  637:	t2p = t2p_init();
        -:  638:
        1:  639:	if (t2p == NULL){
    #####:  640:		TIFFError(TIFF2PDF_MODULE, "Can't initialize context");
    #####:  641:		goto fail;
        -:  642:	}
        -:  643:
        2:  644:	while (argv &&
       1*:  645:	       (c = getopt(argc, argv,
        -:  646:			   "o:q:u:x:y:w:l:r:p:e:c:a:t:s:k:jzndifbhF")) != -1){
    #####:  647:		switch (c) {
    #####:  648:			case 'o':
    #####:  649:				outfilename = optarg;
    #####:  650:				break;
        -:  651:#ifdef JPEG_SUPPORT
    #####:  652:			case 'j':  
    #####:  653:				t2p->pdf_defaultcompression=T2P_COMPRESS_JPEG;
    #####:  654:				break;
        -:  655:#endif
        -:  656:#ifndef JPEG_SUPPORT
        -:  657:			case 'j':  
        -:  658:				TIFFWarning(
        -:  659:					TIFF2PDF_MODULE, 
        -:  660:					"JPEG support in libtiff required for JPEG compression, ignoring option");
        -:  661:				break;
        -:  662:#endif
        -:  663:#ifdef ZIP_SUPPORT
        -:  664:			case 'z':  
        -:  665:				t2p->pdf_defaultcompression=T2P_COMPRESS_ZIP;
        -:  666:				break;
        -:  667:#endif
        -:  668:#ifndef ZIP_SUPPORT
    #####:  669:			case 'z':  
    #####:  670:				TIFFWarning(
        -:  671:					TIFF2PDF_MODULE, 
        -:  672:					"Zip support in libtiff required for Zip compression, ignoring option");
    #####:  673:				break;
        -:  674:#endif
    #####:  675:			case 'q': 
    #####:  676:				t2p->pdf_defaultcompressionquality=atoi(optarg);
    #####:  677:				break;
    #####:  678:			case 'n': 
    #####:  679:				t2p->pdf_nopassthrough=1;
    #####:  680:				break;
    #####:  681:			case 'd': 
    #####:  682:				t2p->pdf_defaultcompression=T2P_COMPRESS_NONE;
    #####:  683:				break;
    #####:  684:			case 'u': 
    #####:  685:				if(optarg[0]=='m'){
    #####:  686:					t2p->pdf_centimeters=1;
        -:  687:				}
    #####:  688:				break;
    #####:  689:			case 'x': 
    #####:  690:				t2p->pdf_defaultxres = 
    #####:  691:					(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  692:				break;
    #####:  693:			case 'y': 
    #####:  694:				t2p->pdf_defaultyres = 
    #####:  695:					(float)atof(optarg) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  696:				break;
    #####:  697:			case 'w': 
    #####:  698:				t2p->pdf_overridepagesize=1;
    #####:  699:				t2p->pdf_defaultpagewidth = 
    #####:  700:					((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  701:				break;
    #####:  702:			case 'l': 
    #####:  703:				t2p->pdf_overridepagesize=1;
    #####:  704:				t2p->pdf_defaultpagelength = 
    #####:  705:					((float)atof(optarg) * PS_UNIT_SIZE) / (t2p->pdf_centimeters?2.54F:1.0F);
    #####:  706:				break;
    #####:  707:			case 'r': 
    #####:  708:				if(optarg[0]=='o'){
    #####:  709:					t2p->pdf_overrideres=1;
        -:  710:				}
    #####:  711:				break;
    #####:  712:			case 'p': 
    #####:  713:				if(tiff2pdf_match_paper_size(
        -:  714:					&(t2p->pdf_defaultpagewidth), 
        -:  715:					&(t2p->pdf_defaultpagelength), 
        -:  716:					optarg)){
    #####:  717:					t2p->pdf_overridepagesize=1;
        -:  718:				} else {
    #####:  719:					TIFFWarning(TIFF2PDF_MODULE, 
        -:  720:					"Unknown paper size %s, ignoring option",
        -:  721:						optarg);
        -:  722:				}
    #####:  723:				break;
    #####:  724:			case 'i':
    #####:  725:				t2p->pdf_colorspace_invert=1;
    #####:  726:				break;
    #####:  727:			case 'F':
    #####:  728:				t2p->pdf_image_fillpage = 1;
    #####:  729:				break;
    #####:  730:			case 'f': 
    #####:  731:				t2p->pdf_fitwindow=1;
    #####:  732:				break;
    #####:  733:			case 'e':
    #####:  734:				if (strlen(optarg) == 0) {
    #####:  735:					t2p->pdf_datetime[0] = '\0';
        -:  736:				} else {
    #####:  737:					t2p->pdf_datetime[0] = 'D';
    #####:  738:					t2p->pdf_datetime[1] = ':';
    #####:  739:					strncpy(t2p->pdf_datetime + 2, optarg,
        -:  740:						sizeof(t2p->pdf_datetime) - 3);
    #####:  741:					t2p->pdf_datetime[sizeof(t2p->pdf_datetime) - 1] = '\0';
        -:  742:				}
    #####:  743:				break;
    #####:  744:			case 'c': 
    #####:  745:				strncpy(t2p->pdf_creator, optarg, sizeof(t2p->pdf_creator) - 1);
    #####:  746:				t2p->pdf_creator[sizeof(t2p->pdf_creator) - 1] = '\0';
    #####:  747:				break;
    #####:  748:			case 'a': 
    #####:  749:				strncpy(t2p->pdf_author, optarg, sizeof(t2p->pdf_author) - 1);
    #####:  750:				t2p->pdf_author[sizeof(t2p->pdf_author) - 1] = '\0';
    #####:  751:				break;
    #####:  752:			case 't': 
    #####:  753:				strncpy(t2p->pdf_title, optarg, sizeof(t2p->pdf_title) - 1);
    #####:  754:				t2p->pdf_title[sizeof(t2p->pdf_title) - 1] = '\0';
    #####:  755:				break;
    #####:  756:			case 's': 
    #####:  757:				strncpy(t2p->pdf_subject, optarg, sizeof(t2p->pdf_subject) - 1);
    #####:  758:				t2p->pdf_subject[sizeof(t2p->pdf_subject) - 1] = '\0';
    #####:  759:				break;
    #####:  760:			case 'k': 
    #####:  761:				strncpy(t2p->pdf_keywords, optarg, sizeof(t2p->pdf_keywords) - 1);
    #####:  762:				t2p->pdf_keywords[sizeof(t2p->pdf_keywords) - 1] = '\0';
    #####:  763:				break;
    #####:  764:			case 'b':
    #####:  765:				t2p->pdf_image_interpolate = 1;
    #####:  766:				break;
    #####:  767:			case 'h': 
        -:  768:			case '?': 
    #####:  769:				tiff2pdf_usage();
    #####:  770:				goto success;
        -:  771:				break;
        -:  772:		}
        1:  773:	}
        -:  774:
        -:  775:	/*
        -:  776:	 * Input
        -:  777:	 */
        1:  778:	if(argc > optind) {
        1:  779:		input = TIFFOpen(argv[optind++], "r");
        1:  780:		if (input==NULL) {
    #####:  781:			TIFFError(TIFF2PDF_MODULE, 
        -:  782:				  "Can't open input file %s for reading", 
    #####:  783:				  argv[optind-1]);
    #####:  784:			goto fail;
        -:  785:		}
        -:  786:	} else {
    #####:  787:		TIFFError(TIFF2PDF_MODULE, "No input file specified"); 
    #####:  788:		tiff2pdf_usage();
    #####:  789:		goto fail;
        -:  790:	}
        -:  791:
        1:  792:	if(argc > optind) {
    #####:  793:		TIFFError(TIFF2PDF_MODULE, 
        -:  794:			  "No support for multiple input files"); 
    #####:  795:		tiff2pdf_usage();
    #####:  796:		goto fail;
        -:  797:	}
        -:  798:
        -:  799:	/*
        -:  800:	 * Output
        -:  801:	 */
        1:  802:	t2p->outputdisable = 1;
        1:  803:	if (outfilename) {
    #####:  804:		t2p->outputfile = fopen(outfilename, "wb");
    #####:  805:		if (t2p->outputfile == NULL) {
    #####:  806:			TIFFError(TIFF2PDF_MODULE,
        -:  807:				  "Can't open output file %s for writing",
        -:  808:				  outfilename);
    #####:  809:			goto fail;
        -:  810:		}
        -:  811:	} else {
        1:  812:		outfilename = "-";
        1:  813:		t2p->outputfile = stdout;
        -:  814:	}
        -:  815:
        1:  816:	output = TIFFClientOpen(outfilename, "w", (thandle_t) t2p,
        -:  817:				t2p_readproc, t2p_writeproc, t2p_seekproc, 
        -:  818:				t2p_closeproc, t2p_sizeproc, 
        -:  819:				t2p_mapproc, t2p_unmapproc);
        1:  820:	t2p->outputdisable = 0;
        1:  821:	if (output == NULL) {
    #####:  822:		TIFFError(TIFF2PDF_MODULE,
        -:  823:			  "Can't initialize output descriptor");
    #####:  824:		goto fail;
        -:  825:	}
        -:  826:	
        -:  827:	/*
        -:  828:	 * Validate
        -:  829:	 */
        1:  830:	t2p_validate(t2p);
        1:  831:	t2pSeekFile(output, (toff_t) 0, SEEK_SET);
        -:  832:
        -:  833:	/*
        -:  834:	 * Write
        -:  835:	 */
        1:  836:	t2p_write_pdf(t2p, input, output);
    #####:  837:	if (t2p->t2p_error != 0) {
    #####:  838:		TIFFError(TIFF2PDF_MODULE,
        -:  839:			  "An error occurred creating output PDF file");
    #####:  840:		goto fail;
        -:  841:	}
        -:  842:
    #####:  843:	goto success;
    #####:  844:fail:
    #####:  845:	ret = EXIT_FAILURE;
    #####:  846:success:
    #####:  847:	if(input != NULL)
    #####:  848:		TIFFClose(input);
    #####:  849:	if (output != NULL)
    #####:  850:		TIFFClose(output);
    #####:  851:	if (t2p != NULL)
    #####:  852:		t2p_free(t2p);
    #####:  853:	return ret;
        -:  854:  
        -:  855:}
        -:  856:
    #####:  857:void tiff2pdf_usage(){
    #####:  858:	char* lines[]={
        -:  859:	"usage:  tiff2pdf [options] input.tiff",
        -:  860:	"options:",
        -:  861:	" -o: output to file name",
        -:  862:#ifdef JPEG_SUPPORT
        -:  863:	" -j: compress with JPEG", 
        -:  864:#endif
        -:  865:#ifdef ZIP_SUPPORT
        -:  866:	" -z: compress with Zip/Deflate",
        -:  867:#endif
        -:  868:	" -q: compression quality",
        -:  869:	" -n: no compressed data passthrough",
        -:  870:	" -d: do not compress (decompress)",
        -:  871:	" -i: invert colors",
        -:  872:	" -u: set distance unit, 'i' for inch, 'm' for centimeter",
        -:  873:	" -x: set x resolution default in dots per unit",
        -:  874:	" -y: set y resolution default in dots per unit",
        -:  875:	" -w: width in units",
        -:  876:	" -l: length in units",
        -:  877:	" -r: 'd' for resolution default, 'o' for resolution override",
        -:  878:	" -p: paper size, eg \"letter\", \"legal\", \"A4\"",
        -:  879:  " -F: make the tiff fill the PDF page",
        -:  880:	" -f: set PDF \"Fit Window\" user preference",
        -:  881:	" -e: date, overrides image or current date/time default, YYYYMMDDHHMMSS",
        -:  882:	" -c: sets document creator, overrides image software default",
        -:  883:	" -a: sets document author, overrides image artist default",
        -:  884:	" -t: sets document title, overrides image document name default",
        -:  885:	" -s: sets document subject, overrides image image description default",
        -:  886:	" -k: sets document keywords",
        -:  887:	" -b: set PDF \"Interpolate\" user preference",
        -:  888:	" -h: usage",
        -:  889:	NULL
        -:  890:	};
    #####:  891:	int i=0;
        -:  892:
    #####:  893:	fprintf(stderr, "%s\n\n", TIFFGetVersion());
    #####:  894:	for (i=0;lines[i]!=NULL;i++){
    #####:  895:		fprintf(stderr, "%s\n", lines[i]);
        -:  896:	}
        -:  897:
    #####:  898:	return;
        -:  899:}
        -:  900:
    #####:  901:int tiff2pdf_match_paper_size(float* width, float* length, char* papersize){
        -:  902:
        -:  903:	size_t i, len;
    #####:  904:	const char* sizes[]={
        -:  905:		"LETTER", "A4", "LEGAL",
        -:  906:		"EXECUTIVE", "LETTER", "LEGAL", "LEDGER", "TABLOID", 
        -:  907:		"A", "B", "C", "D", "E", "F", "G", "H", "J", "K", 
        -:  908:		"A10", "A9", "A8", "A7", "A6", "A5", "A4", "A3", "A2", "A1", "A0", 
        -:  909:		"2A0", "4A0", "2A", "4A", 
        -:  910:		"B10", "B9", "B8", "B7", "B6", "B5", "B4", "B3", "B2", "B1", "B0", 
        -:  911:		"JISB10", "JISB9", "JISB8", "JISB7", "JISB6", "JISB5", "JISB4", 
        -:  912:		"JISB3", "JISB2", "JISB1", "JISB0", 
        -:  913:		"C10", "C9", "C8", "C7", "C6", "C5", "C4", "C3", "C2", "C1", "C0", 
        -:  914:		"RA2", "RA1", "RA0", "SRA4", "SRA3", "SRA2", "SRA1", "SRA0", 
        -:  915:		"A3EXTRA", "A4EXTRA", 
        -:  916:		"STATEMENT", "FOLIO", "QUARTO", 
        -:  917:		NULL
        -:  918:	} ;
    #####:  919:	const int widths[]={
        -:  920:		612, 595, 612,
        -:  921:		522, 612,612,792,792,
        -:  922:		612,792,1224,1584,2448,2016,792,2016,2448,2880,
        -:  923:		74,105,147,210,298,420,595,842,1191,1684,2384,3370,4768,3370,4768,
        -:  924:		88,125,176,249,354,499,709,1001,1417,2004,2835,
        -:  925:		91,128,181,258,363,516,729,1032,1460,2064,2920,
        -:  926:		79,113,162,230,323,459,649,918,1298,1298,2599,
        -:  927:		1219,1729,2438,638,907,1276,1814,2551,
        -:  928:		914,667,
        -:  929:		396, 612, 609, 
        -:  930:		0
        -:  931:	};
    #####:  932:	const int lengths[]={
        -:  933:		792,842,1008,
        -:  934:		756,792,1008,1224,1224,
        -:  935:		792,1224,1584,2448,3168,2880,6480,10296,12672,10296,
        -:  936:		105,147,210,298,420,595,842,1191,1684,2384,3370,4768,6741,4768,6741,
        -:  937:		125,176,249,354,499,709,1001,1417,2004,2835,4008,
        -:  938:		128,181,258,363,516,729,1032,1460,2064,2920,4127,
        -:  939:		113,162,230,323,459,649,918,1298,1837,1837,3677,
        -:  940:		1729,2438,3458,907,1276,1814,2551,3628,
        -:  941:		1262,914,
        -:  942:		612, 936, 780, 
        -:  943:		0
        -:  944:	};
        -:  945:
    #####:  946:	len=strlen(papersize);
    #####:  947:	for(i=0;i<len;i++){
    #####:  948:		papersize[i]=toupper((int) papersize[i]);
        -:  949:	}
    #####:  950:	for(i=0;sizes[i]!=NULL; i++){
    #####:  951:		if (strcmp( (const char*)papersize, sizes[i])==0){
    #####:  952:			*width=(float)widths[i];
    #####:  953:			*length=(float)lengths[i];
    #####:  954:			return(1);
        -:  955:		}
        -:  956:	}
        -:  957:
    #####:  958:	return(0);
        -:  959:}
        -:  960:
        -:  961:/*
        -:  962: * This function allocates and initializes a T2P context struct pointer.
        -:  963: */
        -:  964:
        1:  965:T2P* t2p_init()
        -:  966:{
        1:  967:	T2P* t2p = (T2P*) _TIFFmalloc(sizeof(T2P));
        1:  968:	if(t2p==NULL){
    #####:  969:		TIFFError(
        -:  970:			TIFF2PDF_MODULE, 
        -:  971:			"Can't allocate %lu bytes of memory for t2p_init", 
        -:  972:			(unsigned long) sizeof(T2P));
    #####:  973:		return( (T2P*) NULL );
        -:  974:	}
        1:  975:	_TIFFmemset(t2p, 0x00, sizeof(T2P));
        1:  976:	t2p->pdf_majorversion=1;
        1:  977:	t2p->pdf_minorversion=1;
        1:  978:	t2p->pdf_defaultxres=300.0;
        1:  979:	t2p->pdf_defaultyres=300.0;
        1:  980:	t2p->pdf_defaultpagewidth=612.0;
        1:  981:	t2p->pdf_defaultpagelength=792.0;
        1:  982:	t2p->pdf_xrefcount=3; /* Catalog, Info, Pages */
        -:  983:	
        1:  984:	return(t2p);
        -:  985:}
        -:  986:
        -:  987:/*
        -:  988: * This function frees a T2P context struct pointer and any allocated data fields of it.
        -:  989: */
        -:  990:
    #####:  991:void t2p_free(T2P* t2p)
        -:  992:{
    #####:  993:	int i = 0;
        -:  994:
    #####:  995:	if (t2p != NULL) {
    #####:  996:		if(t2p->pdf_xrefoffsets != NULL){
    #####:  997:			_TIFFfree( (tdata_t) t2p->pdf_xrefoffsets);
        -:  998:		}
    #####:  999:		if(t2p->tiff_pages != NULL){
    #####: 1000:			_TIFFfree( (tdata_t) t2p->tiff_pages);
        -: 1001:		}
    #####: 1002:		for(i=0;i<t2p->tiff_pagecount;i++){
    #####: 1003:			if(t2p->tiff_tiles[i].tiles_tiles != NULL){
    #####: 1004:				_TIFFfree( (tdata_t) t2p->tiff_tiles[i].tiles_tiles);
        -: 1005:			}
        -: 1006:		}
    #####: 1007:		if(t2p->tiff_tiles != NULL){
    #####: 1008:			_TIFFfree( (tdata_t) t2p->tiff_tiles);
        -: 1009:		}
    #####: 1010:		if(t2p->pdf_palette != NULL){
    #####: 1011:			_TIFFfree( (tdata_t) t2p->pdf_palette);
        -: 1012:		}
        -: 1013:#ifdef OJPEG_SUPPORT
    #####: 1014:		if(t2p->pdf_ojpegdata != NULL){
    #####: 1015:			_TIFFfree( (tdata_t) t2p->pdf_ojpegdata);
        -: 1016:		}
        -: 1017:#endif
    #####: 1018:		_TIFFfree( (tdata_t) t2p );
        -: 1019:	}
        -: 1020:
    #####: 1021:	return;
        -: 1022:}
        -: 1023:
        -: 1024:/*
        -: 1025:	This function validates the values of a T2P context struct pointer
        -: 1026:        before calling t2p_write_pdf with it.
        -: 1027:*/
        -: 1028:
        1: 1029:void t2p_validate(T2P* t2p){
        -: 1030:
        -: 1031:#ifdef JPEG_SUPPORT
        1: 1032:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1033:		if(t2p->pdf_defaultcompressionquality>100 ||
    #####: 1034:			t2p->pdf_defaultcompressionquality<1){
    #####: 1035:			t2p->pdf_defaultcompressionquality=0;
        -: 1036:		}
        -: 1037:	}
        -: 1038:#endif
        -: 1039:#ifdef ZIP_SUPPORT
        -: 1040:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_ZIP){
        -: 1041: 		uint16 m=t2p->pdf_defaultcompressionquality%100;
        -: 1042: 		if(t2p->pdf_defaultcompressionquality/100 > 9 ||
        -: 1043: 			(m>1 && m<10) || m>15){
        -: 1044: 			t2p->pdf_defaultcompressionquality=0;
        -: 1045:		}
        -: 1046:		if(t2p->pdf_defaultcompressionquality%100 !=0){
        -: 1047: 			t2p->pdf_defaultcompressionquality/=100;
        -: 1048: 			t2p->pdf_defaultcompressionquality*=100;
        -: 1049:			TIFFError(
        -: 1050:				TIFF2PDF_MODULE, 
        -: 1051:				"PNG Group predictor differencing not implemented, assuming compression quality %u", 
        -: 1052:				t2p->pdf_defaultcompressionquality);
        -: 1053:		}
        -: 1054:		t2p->pdf_defaultcompressionquality%=100;
        -: 1055:		if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}
        -: 1056:	}
        -: 1057:#endif
        -: 1058:	(void)0;
        -: 1059:
        1: 1060:	return;
        -: 1061:}
        -: 1062:
        -: 1063:
        -: 1064:/*
        -: 1065:	This function scans the input TIFF file for pages.  It attempts
        -: 1066:        to determine which IFD's of the TIFF file contain image document
        -: 1067:        pages.  For each, it gathers some information that has to do
        -: 1068:        with the output of the PDF document as a whole.  
        -: 1069:*/
        -: 1070:
        1: 1071:void t2p_read_tiff_init(T2P* t2p, TIFF* input){
        -: 1072:
        1: 1073:	tdir_t directorycount=0;
        1: 1074:	tdir_t i=0;
        1: 1075:	uint16 pagen=0;
        1: 1076:	uint16 paged=0;
        1: 1077:	uint16 xuint16=0;
        -: 1078:
        1: 1079:	directorycount=TIFFNumberOfDirectories(input);
       1*: 1080:	t2p->tiff_pages = (T2P_PAGE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_PAGE)));
        1: 1081:	if(t2p->tiff_pages==NULL){
    #####: 1082:		TIFFError(
        -: 1083:			TIFF2PDF_MODULE, 
        -: 1084:			"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for tiff_pages array, %s", 
    #####: 1085:			(TIFF_SIZE_T) directorycount * sizeof(T2P_PAGE), 
        -: 1086:			TIFFFileName(input));
    #####: 1087:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1088:		return;
        -: 1089:	}
        1: 1090:	_TIFFmemset( t2p->tiff_pages, 0x00, directorycount * sizeof(T2P_PAGE));
       1*: 1091:	t2p->tiff_tiles = (T2P_TILES*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,directorycount,sizeof(T2P_TILES)));
        1: 1092:	if(t2p->tiff_tiles==NULL){
    #####: 1093:		TIFFError(
        -: 1094:			TIFF2PDF_MODULE, 
        -: 1095:			"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for tiff_tiles array, %s", 
    #####: 1096:			(TIFF_SIZE_T) directorycount * sizeof(T2P_TILES), 
        -: 1097:			TIFFFileName(input));
    #####: 1098:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1099:		return;
        -: 1100:	}
        1: 1101:	_TIFFmemset( t2p->tiff_tiles, 0x00, directorycount * sizeof(T2P_TILES));
        2: 1102:	for(i=0;i<directorycount;i++){
        1: 1103:		uint32 subfiletype = 0;
        -: 1104:		
        1: 1105:		if(!TIFFSetDirectory(input, i)){
    #####: 1106:			TIFFError(
        -: 1107:				TIFF2PDF_MODULE, 
        -: 1108:				"Can't set directory %u of input file %s", 
        -: 1109:				i,
        -: 1110:				TIFFFileName(input));
    #####: 1111:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1112:			return;
        -: 1113:		}
        1: 1114:		if(TIFFGetField(input, TIFFTAG_PAGENUMBER, &pagen, &paged)){
    #####: 1115:			if((pagen>paged) && (paged != 0)){
    #####: 1116:				t2p->tiff_pages[t2p->tiff_pagecount].page_number = 
        -: 1117:					paged;
        -: 1118:			} else {
    #####: 1119:				t2p->tiff_pages[t2p->tiff_pagecount].page_number = 
        -: 1120:					pagen;
        -: 1121:			}
    #####: 1122:			goto ispage2;
        -: 1123:		}
        1: 1124:		if(TIFFGetField(input, TIFFTAG_SUBFILETYPE, &subfiletype)){
    #####: 1125:			if ( ((subfiletype & FILETYPE_PAGE) != 0)
    #####: 1126:                             || (subfiletype == 0)){
    #####: 1127:				goto ispage;
        -: 1128:			} else {
    #####: 1129:				goto isnotpage;
        -: 1130:			}
        -: 1131:		}
        1: 1132:		if(TIFFGetField(input, TIFFTAG_OSUBFILETYPE, &subfiletype)){
    #####: 1133:			if ((subfiletype == OFILETYPE_IMAGE) 
    #####: 1134:				|| (subfiletype == OFILETYPE_PAGE)
    #####: 1135:				|| (subfiletype == 0) ){
    #####: 1136:				goto ispage;
        -: 1137:			} else {
    #####: 1138:				goto isnotpage;
        -: 1139:			}
        -: 1140:		}
        1: 1141:		ispage:
        1: 1142:		t2p->tiff_pages[t2p->tiff_pagecount].page_number=t2p->tiff_pagecount;
        1: 1143:		ispage2:
        1: 1144:		t2p->tiff_pages[t2p->tiff_pagecount].page_directory=i;
        1: 1145:		if(TIFFIsTiled(input)){
        2: 1146:			t2p->tiff_pages[t2p->tiff_pagecount].page_tilecount = 
        1: 1147:				TIFFNumberOfTiles(input);
        -: 1148:		}
        1: 1149:		t2p->tiff_pagecount++;
        1: 1150:		isnotpage:
        -: 1151:		(void)0;
        -: 1152:	}
        -: 1153:	
       1*: 1154:	qsort((void*) t2p->tiff_pages, t2p->tiff_pagecount,
        -: 1155:              sizeof(T2P_PAGE), t2p_cmp_t2p_page);
        -: 1156:
        2: 1157:	for(i=0;i<t2p->tiff_pagecount;i++){
        1: 1158:		t2p->pdf_xrefcount += 5;
        1: 1159:		TIFFSetDirectory(input, t2p->tiff_pages[i].page_directory );
        1: 1160:		if((TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &xuint16)
        1: 1161:                    && (xuint16==PHOTOMETRIC_PALETTE))
        1: 1162:		   || TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)) {
    #####: 1163:			t2p->tiff_pages[i].page_extra++;
    #####: 1164:			t2p->pdf_xrefcount++;
        -: 1165:		}
        -: 1166:#ifdef ZIP_SUPPORT
        -: 1167:		if (TIFFGetField(input, TIFFTAG_COMPRESSION, &xuint16)) {
        -: 1168:                        if( (xuint16== COMPRESSION_DEFLATE ||
        -: 1169:                             xuint16== COMPRESSION_ADOBE_DEFLATE) && 
        -: 1170:                            ((t2p->tiff_pages[i].page_tilecount != 0) 
        -: 1171:                             || TIFFNumberOfStrips(input)==1) &&
        -: 1172:                            (t2p->pdf_nopassthrough==0)	){
        -: 1173:                                if(t2p->pdf_minorversion<2){t2p->pdf_minorversion=2;}
        -: 1174:                        }
        -: 1175:                }
        -: 1176:#endif
        1: 1177:		if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,
        -: 1178:                                 &(t2p->tiff_transferfunction[0]),
        -: 1179:                                 &(t2p->tiff_transferfunction[1]),
        -: 1180:                                 &(t2p->tiff_transferfunction[2]))) {
    #####: 1181:			if((t2p->tiff_transferfunction[1] != (float*) NULL) &&
    #####: 1182:                           (t2p->tiff_transferfunction[2] != (float*) NULL) &&
    #####: 1183:                           (t2p->tiff_transferfunction[1] !=
    #####: 1184:                            t2p->tiff_transferfunction[0])) {
    #####: 1185:				t2p->tiff_transferfunctioncount = 3;
    #####: 1186:				t2p->tiff_pages[i].page_extra += 4;
    #####: 1187:				t2p->pdf_xrefcount += 4;
        -: 1188:			} else {
    #####: 1189:				t2p->tiff_transferfunctioncount = 1;
    #####: 1190:				t2p->tiff_pages[i].page_extra += 2;
    #####: 1191:				t2p->pdf_xrefcount += 2;
        -: 1192:			}
    #####: 1193:			if(t2p->pdf_minorversion < 2)
    #####: 1194:				t2p->pdf_minorversion = 2;
        -: 1195:                } else {
        1: 1196:			t2p->tiff_transferfunctioncount=0;
        -: 1197:		}
        1: 1198:		if( TIFFGetField(
        -: 1199:			input, 
        -: 1200:			TIFFTAG_ICCPROFILE, 
        -: 1201:			&(t2p->tiff_iccprofilelength), 
        -: 1202:			&(t2p->tiff_iccprofile)) != 0){
    #####: 1203:			t2p->tiff_pages[i].page_extra++;
    #####: 1204:			t2p->pdf_xrefcount++;
    #####: 1205:			if(t2p->pdf_minorversion<3){t2p->pdf_minorversion=3;}
        -: 1206:		}
        1: 1207:		t2p->tiff_tiles[i].tiles_tilecount=
        2: 1208:			t2p->tiff_pages[i].page_tilecount;
        1: 1209:		if( (TIFFGetField(input, TIFFTAG_PLANARCONFIG, &xuint16) != 0)
        1: 1210:			&& (xuint16 == PLANARCONFIG_SEPARATE ) ){
    #####: 1211:				if( !TIFFGetField(input, TIFFTAG_SAMPLESPERPIXEL, &xuint16) )
        -: 1212:				{
    #####: 1213:					TIFFError(
        -: 1214:                        TIFF2PDF_MODULE, 
        -: 1215:                        "Missing SamplesPerPixel, %s", 
        -: 1216:                        TIFFFileName(input));
    #####: 1217:                    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1218:                    return;
        -: 1219:				}
    #####: 1220:                if( (t2p->tiff_tiles[i].tiles_tilecount % xuint16) != 0 )
        -: 1221:                {
    #####: 1222:                    TIFFError(
        -: 1223:                        TIFF2PDF_MODULE, 
        -: 1224:                        "Invalid tile count, %s", 
        -: 1225:                        TIFFFileName(input));
    #####: 1226:                    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1227:                    return;
        -: 1228:                }
    #####: 1229:				t2p->tiff_tiles[i].tiles_tilecount/= xuint16;
        -: 1230:		}
        1: 1231:		if( t2p->tiff_tiles[i].tiles_tilecount > 0){
        2: 1232:			t2p->pdf_xrefcount += 
        1: 1233:				(t2p->tiff_tiles[i].tiles_tilecount -1)*2;
        1: 1234:			TIFFGetField(input, 
        -: 1235:				TIFFTAG_TILEWIDTH, 
        1: 1236:				&( t2p->tiff_tiles[i].tiles_tilewidth) );
        1: 1237:			TIFFGetField(input, 
        -: 1238:				TIFFTAG_TILELENGTH, 
        1: 1239:				&( t2p->tiff_tiles[i].tiles_tilelength) );
        2: 1240:			t2p->tiff_tiles[i].tiles_tiles = 
       2*: 1241:			(T2P_TILE*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->tiff_tiles[i].tiles_tilecount,
        -: 1242:                                                                 sizeof(T2P_TILE)) );
        1: 1243:			if( t2p->tiff_tiles[i].tiles_tiles == NULL){
    #####: 1244:				TIFFError(
        -: 1245:					TIFF2PDF_MODULE, 
        -: 1246:					"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory for t2p_read_tiff_init, %s", 
    #####: 1247:					(TIFF_SIZE_T) t2p->tiff_tiles[i].tiles_tilecount * sizeof(T2P_TILE), 
        -: 1248:					TIFFFileName(input));
    #####: 1249:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1250:				return;
        -: 1251:			}
        -: 1252:		}
        -: 1253:	}
        -: 1254:
        1: 1255:	return;
        -: 1256:}
        -: 1257:
        -: 1258:/*
        -: 1259: * This function is used by qsort to sort a T2P_PAGE* array of page structures
        -: 1260: * by page number. If the page numbers are the same, we fall back to comparing
        -: 1261: * directory numbers to preserve the order of the input file.
        -: 1262: */
        -: 1263:
    #####: 1264:int t2p_cmp_t2p_page(const void* e1, const void* e2){
        -: 1265:
        -: 1266:	int d;
    #####: 1267:	d = (int32)(((T2P_PAGE*)e1)->page_number) - (int32)(((T2P_PAGE*)e2)->page_number);
    #####: 1268:	if(d == 0){
    #####: 1269:		d = (int32)(((T2P_PAGE*)e1)->page_directory) - (int32)(((T2P_PAGE*)e2)->page_directory);
        -: 1270:	}
    #####: 1271:	return d;
        -: 1272:}
        -: 1273:
        -: 1274:/*
        -: 1275:	This function sets the input directory to the directory of a given
        -: 1276:	page and determines information about the image.  It checks
        -: 1277:	the image characteristics to determine if it is possible to convert
        -: 1278:	the image data into a page of PDF output, setting values of the T2P
        -: 1279:	struct for this page.  It determines what color space is used in
        -: 1280:	the output PDF to represent the image.
        -: 1281:	
        -: 1282:	It determines if the image can be converted as raw data without
        -: 1283:	requiring transcoding of the image data.
        -: 1284:*/
        -: 1285:
        1: 1286:void t2p_read_tiff_data(T2P* t2p, TIFF* input){
        -: 1287:
        1: 1288:	int i=0;
        1: 1289:	uint16* r;
        1: 1290:	uint16* g;
        1: 1291:	uint16* b;
        1: 1292:	uint16* a;
        1: 1293:	uint16 xuint16;
        1: 1294:	uint16* xuint16p;
        1: 1295:	float* xfloatp;
        -: 1296:
        1: 1297:	t2p->pdf_transcode = T2P_TRANSCODE_ENCODE;
        1: 1298:	t2p->pdf_sample = T2P_SAMPLE_NOTHING;
        1: 1299:        t2p->pdf_switchdecode = t2p->pdf_colorspace_invert;
        -: 1300:        
        -: 1301:	
        1: 1302:	TIFFSetDirectory(input, t2p->tiff_pages[t2p->pdf_page].page_directory);
        -: 1303:
        1: 1304:	TIFFGetField(input, TIFFTAG_IMAGEWIDTH, &(t2p->tiff_width));
        1: 1305:	if(t2p->tiff_width == 0){
    #####: 1306:		TIFFError(
        -: 1307:			TIFF2PDF_MODULE, 
        -: 1308:			"No support for %s with zero width", 
        -: 1309:			TIFFFileName(input)	);
    #####: 1310:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1311:		return;
        -: 1312:	}
        -: 1313:
        1: 1314:	TIFFGetField(input, TIFFTAG_IMAGELENGTH, &(t2p->tiff_length));
        1: 1315:	if(t2p->tiff_length == 0){
    #####: 1316:		TIFFError(
        -: 1317:			TIFF2PDF_MODULE, 
        -: 1318:			"No support for %s with zero length", 
        -: 1319:			TIFFFileName(input)	);
    #####: 1320:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1321:		return;
        -: 1322:	}
        -: 1323:
        1: 1324:        if(TIFFGetField(input, TIFFTAG_COMPRESSION, &(t2p->tiff_compression)) == 0){
    #####: 1325:                TIFFError(
        -: 1326:                        TIFF2PDF_MODULE, 
        -: 1327:                        "No support for %s with no compression tag", 
        -: 1328:                        TIFFFileName(input)     );
    #####: 1329:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1330:                return;
        -: 1331:
        -: 1332:        }
        1: 1333:        if( TIFFIsCODECConfigured(t2p->tiff_compression) == 0){
    #####: 1334:		TIFFError(
        -: 1335:			TIFF2PDF_MODULE, 
        -: 1336:			"No support for %s with compression type %u:  not configured", 
        -: 1337:			TIFFFileName(input), 
    #####: 1338:			t2p->tiff_compression	
        -: 1339:			);
    #####: 1340:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1341:		return;
        -: 1342:	
        -: 1343:	}
        -: 1344:
        1: 1345:	TIFFGetFieldDefaulted(input, TIFFTAG_BITSPERSAMPLE, &(t2p->tiff_bitspersample));
        1: 1346:	switch(t2p->tiff_bitspersample){
        1: 1347:		case 1:
        -: 1348:		case 2:
        -: 1349:		case 4:
        -: 1350:		case 8:
        1: 1351:			break;
    #####: 1352:		case 0:
    #####: 1353:			TIFFWarning(
        -: 1354:				TIFF2PDF_MODULE, 
        -: 1355:				"Image %s has 0 bits per sample, assuming 1",
        -: 1356:				TIFFFileName(input));
    #####: 1357:			t2p->tiff_bitspersample=1;
    #####: 1358:			break;
    #####: 1359:		default:
    #####: 1360:			TIFFError(
        -: 1361:				TIFF2PDF_MODULE, 
        -: 1362:				"No support for %s with %u bits per sample",
        -: 1363:				TIFFFileName(input),
    #####: 1364:				t2p->tiff_bitspersample);
    #####: 1365:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1366:			return;
        -: 1367:	}
        -: 1368:
        1: 1369:	TIFFGetFieldDefaulted(input, TIFFTAG_SAMPLESPERPIXEL, &(t2p->tiff_samplesperpixel));
        1: 1370:	if(t2p->tiff_samplesperpixel>4){
    #####: 1371:		TIFFError(
        -: 1372:			TIFF2PDF_MODULE, 
        -: 1373:			"No support for %s with %u samples per pixel",
        -: 1374:			TIFFFileName(input),
    #####: 1375:			t2p->tiff_samplesperpixel);
    #####: 1376:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1377:		return;
        -: 1378:	}
        1: 1379:	if(t2p->tiff_samplesperpixel==0){
    #####: 1380:		TIFFWarning(
        -: 1381:			TIFF2PDF_MODULE, 
        -: 1382:			"Image %s has 0 samples per pixel, assuming 1",
        -: 1383:			TIFFFileName(input));
    #####: 1384:		t2p->tiff_samplesperpixel=1;
        -: 1385:	}
        -: 1386:	
        1: 1387:	if(TIFFGetField(input, TIFFTAG_SAMPLEFORMAT, &xuint16) != 0 ){
    #####: 1388:		switch(xuint16){
    #####: 1389:			case 0:
        -: 1390:			case 1:
        -: 1391:			case 4:
    #####: 1392:				break;
    #####: 1393:			default:
    #####: 1394:				TIFFError(
        -: 1395:					TIFF2PDF_MODULE, 
        -: 1396:					"No support for %s with sample format %u",
        -: 1397:					TIFFFileName(input),
        -: 1398:					xuint16);
    #####: 1399:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1400:				return;
        -: 1401:				break;
        -: 1402:		}
        1: 1403:	}
        -: 1404:	
        1: 1405:	TIFFGetFieldDefaulted(input, TIFFTAG_FILLORDER, &(t2p->tiff_fillorder));
        -: 1406:	
        1: 1407:        if(TIFFGetField(input, TIFFTAG_PHOTOMETRIC, &(t2p->tiff_photometric)) == 0){
    #####: 1408:                TIFFError(
        -: 1409:                        TIFF2PDF_MODULE, 
        -: 1410:                        "No support for %s with no photometric interpretation tag", 
        -: 1411:                        TIFFFileName(input)     );
    #####: 1412:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1413:                return;
        -: 1414:
        -: 1415:        }
        -: 1416:        
        1: 1417:	switch(t2p->tiff_photometric){
    #####: 1418:		case PHOTOMETRIC_MINISWHITE:
        -: 1419:		case PHOTOMETRIC_MINISBLACK: 
    #####: 1420:			if (t2p->tiff_bitspersample==1){
    #####: 1421:				t2p->pdf_colorspace=T2P_CS_BILEVEL;
    #####: 1422:				if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){
    #####: 1423:					t2p->pdf_switchdecode ^= 1;
        -: 1424:				}
        -: 1425:			} else {
    #####: 1426:				t2p->pdf_colorspace=T2P_CS_GRAY;
    #####: 1427:				if(t2p->tiff_photometric==PHOTOMETRIC_MINISWHITE){
    #####: 1428:					t2p->pdf_switchdecode ^= 1;
        -: 1429:				} 
        -: 1430:			}
    #####: 1431:			break;
    #####: 1432:		case PHOTOMETRIC_RGB: 
    #####: 1433:			t2p->pdf_colorspace=T2P_CS_RGB;
    #####: 1434:			if(t2p->tiff_samplesperpixel == 3){
    #####: 1435:				break;
        -: 1436:			}
    #####: 1437:			if(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){
    #####: 1438:				if(xuint16==1)
    #####: 1439:					goto photometric_palette;
        -: 1440:			}
    #####: 1441:			if(t2p->tiff_samplesperpixel > 3) {
    #####: 1442:				if(t2p->tiff_samplesperpixel == 4) {
    #####: 1443:					t2p->pdf_colorspace = T2P_CS_RGB;
    #####: 1444:					if(TIFFGetField(input,
        -: 1445:							TIFFTAG_EXTRASAMPLES,
        -: 1446:							&xuint16, &xuint16p)
    #####: 1447:					   && xuint16 == 1) {
    #####: 1448:						if(xuint16p[0] == EXTRASAMPLE_ASSOCALPHA){
    #####: 1449:							if( t2p->tiff_bitspersample != 8 )
        -: 1450:							{
    #####: 1451:							    TIFFError(
        -: 1452:								    TIFF2PDF_MODULE, 
        -: 1453:								    "No support for BitsPerSample=%d for RGBA",
    #####: 1454:								    t2p->tiff_bitspersample);
    #####: 1455:							    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1456:							    return;
        -: 1457:							}
    #####: 1458:							t2p->pdf_sample=T2P_SAMPLE_RGBAA_TO_RGB;
    #####: 1459:							break;
        -: 1460:						}
    #####: 1461:						if(xuint16p[0] == EXTRASAMPLE_UNASSALPHA){
    #####: 1462:							if( t2p->tiff_bitspersample != 8 )
        -: 1463:							{
    #####: 1464:							    TIFFError(
        -: 1465:								    TIFF2PDF_MODULE, 
        -: 1466:								    "No support for BitsPerSample=%d for RGBA",
    #####: 1467:								    t2p->tiff_bitspersample);
    #####: 1468:							    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1469:							    return;
        -: 1470:							}
    #####: 1471:							t2p->pdf_sample=T2P_SAMPLE_RGBA_TO_RGB;
    #####: 1472:							break;
        -: 1473:						}
    #####: 1474:						TIFFWarning(
        -: 1475:							TIFF2PDF_MODULE, 
        -: 1476:							"RGB image %s has 4 samples per pixel, assuming RGBA",
        -: 1477:							TIFFFileName(input));
    #####: 1478:							break;
        -: 1479:					}
    #####: 1480:					t2p->pdf_colorspace=T2P_CS_CMYK;
    #####: 1481:					t2p->pdf_switchdecode ^= 1;
    #####: 1482:					TIFFWarning(
        -: 1483:						TIFF2PDF_MODULE, 
        -: 1484:						"RGB image %s has 4 samples per pixel, assuming inverse CMYK",
        -: 1485:					TIFFFileName(input));
    #####: 1486:					break;
        -: 1487:				} else {
    #####: 1488:					TIFFError(
        -: 1489:						TIFF2PDF_MODULE, 
        -: 1490:						"No support for RGB image %s with %u samples per pixel", 
        -: 1491:						TIFFFileName(input), 
    #####: 1492:						t2p->tiff_samplesperpixel);
    #####: 1493:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1494:					break;
        -: 1495:				}
        -: 1496:			} else {
    #####: 1497:				TIFFError(
        -: 1498:					TIFF2PDF_MODULE, 
        -: 1499:					"No support for RGB image %s with %u samples per pixel", 
        -: 1500:					TIFFFileName(input), 
    #####: 1501:					t2p->tiff_samplesperpixel);
    #####: 1502:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1503:				break;
        -: 1504:			}
        -: 1505:		case PHOTOMETRIC_PALETTE: 
    #####: 1506:			photometric_palette:
    #####: 1507:			if(t2p->tiff_samplesperpixel!=1){
    #####: 1508:				TIFFError(
        -: 1509:					TIFF2PDF_MODULE, 
        -: 1510:					"No support for palettized image %s with not one sample per pixel", 
        -: 1511:					TIFFFileName(input));
    #####: 1512:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1513:				return;
        -: 1514:			}
    #####: 1515:			t2p->pdf_colorspace=T2P_CS_RGB | T2P_CS_PALETTE;
    #####: 1516:			t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;
    #####: 1517:			if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b)){
    #####: 1518:				TIFFError(
        -: 1519:					TIFF2PDF_MODULE, 
        -: 1520:					"Palettized image %s has no color map", 
        -: 1521:					TIFFFileName(input));
    #####: 1522:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1523:				return;
        -: 1524:			} 
    #####: 1525:			if(t2p->pdf_palette != NULL){
    #####: 1526:				_TIFFfree(t2p->pdf_palette);
    #####: 1527:				t2p->pdf_palette=NULL;
        -: 1528:			}
    #####: 1529:			t2p->pdf_palette = (unsigned char*)
    #####: 1530:				_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,3));
    #####: 1531:			if(t2p->pdf_palette==NULL){
    #####: 1532:				TIFFError(
        -: 1533:					TIFF2PDF_MODULE, 
        -: 1534:					"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s", 
    #####: 1535:					t2p->pdf_palettesize, 
        -: 1536:					TIFFFileName(input));
    #####: 1537:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1538:				return;
        -: 1539:			}
    #####: 1540:			for(i=0;i<t2p->pdf_palettesize;i++){
    #####: 1541:				t2p->pdf_palette[(i*3)]  = (unsigned char) (r[i]>>8);
    #####: 1542:				t2p->pdf_palette[(i*3)+1]= (unsigned char) (g[i]>>8);
    #####: 1543:				t2p->pdf_palette[(i*3)+2]= (unsigned char) (b[i]>>8);
        -: 1544:			}
    #####: 1545:			t2p->pdf_palettesize *= 3;
    #####: 1546:			break;
    #####: 1547:		case PHOTOMETRIC_SEPARATED:
    #####: 1548:			if(TIFFGetField(input, TIFFTAG_INDEXED, &xuint16)){
    #####: 1549:				if(xuint16==1){
    #####: 1550:						goto photometric_palette_cmyk;
        -: 1551:				}
        -: 1552:			}
    #####: 1553:			if( TIFFGetField(input, TIFFTAG_INKSET, &xuint16) ){
    #####: 1554:				if(xuint16 != INKSET_CMYK){
    #####: 1555:					TIFFError(
        -: 1556:						TIFF2PDF_MODULE, 
        -: 1557:						"No support for %s because its inkset is not CMYK",
        -: 1558:						TIFFFileName(input) );
    #####: 1559:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1560:					return;
        -: 1561:				}
        -: 1562:			}
    #####: 1563:			if(t2p->tiff_samplesperpixel==4){
    #####: 1564:				t2p->pdf_colorspace=T2P_CS_CMYK;
        -: 1565:			} else {
    #####: 1566:				TIFFError(
        -: 1567:					TIFF2PDF_MODULE, 
        -: 1568:					"No support for %s because it has %u samples per pixel",
        -: 1569:					TIFFFileName(input), 
    #####: 1570:					t2p->tiff_samplesperpixel);
    #####: 1571:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1572:				return;
        -: 1573:			}
    #####: 1574:			break;
    #####: 1575:			photometric_palette_cmyk:
    #####: 1576:			if(t2p->tiff_samplesperpixel!=1){
    #####: 1577:				TIFFError(
        -: 1578:					TIFF2PDF_MODULE, 
        -: 1579:					"No support for palettized CMYK image %s with not one sample per pixel", 
        -: 1580:					TIFFFileName(input));
    #####: 1581:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1582:				return;
        -: 1583:			}
    #####: 1584:			t2p->pdf_colorspace=T2P_CS_CMYK | T2P_CS_PALETTE;
    #####: 1585:			t2p->pdf_palettesize=0x0001<<t2p->tiff_bitspersample;
    #####: 1586:			if(!TIFFGetField(input, TIFFTAG_COLORMAP, &r, &g, &b, &a)){
    #####: 1587:				TIFFError(
        -: 1588:					TIFF2PDF_MODULE, 
        -: 1589:					"Palettized image %s has no color map", 
        -: 1590:					TIFFFileName(input));
    #####: 1591:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1592:				return;
        -: 1593:			} 
    #####: 1594:			if(t2p->pdf_palette != NULL){
    #####: 1595:				_TIFFfree(t2p->pdf_palette);
    #####: 1596:				t2p->pdf_palette=NULL;
        -: 1597:			}
    #####: 1598:			t2p->pdf_palette = (unsigned char*) 
    #####: 1599:				_TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_palettesize,4));
    #####: 1600:			if(t2p->pdf_palette==NULL){
    #####: 1601:				TIFFError(
        -: 1602:					TIFF2PDF_MODULE, 
        -: 1603:					"Can't allocate %u bytes of memory for t2p_read_tiff_image, %s", 
    #####: 1604:					t2p->pdf_palettesize, 
        -: 1605:					TIFFFileName(input));
    #####: 1606:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1607:				return;
        -: 1608:			}
    #####: 1609:			for(i=0;i<t2p->pdf_palettesize;i++){
    #####: 1610:				t2p->pdf_palette[(i*4)]  = (unsigned char) (r[i]>>8);
    #####: 1611:				t2p->pdf_palette[(i*4)+1]= (unsigned char) (g[i]>>8);
    #####: 1612:				t2p->pdf_palette[(i*4)+2]= (unsigned char) (b[i]>>8);
    #####: 1613:				t2p->pdf_palette[(i*4)+3]= (unsigned char) (a[i]>>8);
        -: 1614:			}
    #####: 1615:			t2p->pdf_palettesize *= 4;
    #####: 1616:			break;
    #####: 1617:		case PHOTOMETRIC_YCBCR:
    #####: 1618:			t2p->pdf_colorspace=T2P_CS_RGB;
    #####: 1619:			if(t2p->tiff_samplesperpixel==1){
    #####: 1620:				t2p->pdf_colorspace=T2P_CS_GRAY;
    #####: 1621:				t2p->tiff_photometric=PHOTOMETRIC_MINISBLACK;
    #####: 1622:				break;
        -: 1623:			}
    #####: 1624:			t2p->pdf_sample=T2P_SAMPLE_YCBCR_TO_RGB;
        -: 1625:#ifdef JPEG_SUPPORT
    #####: 1626:			if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1627:				t2p->pdf_sample=T2P_SAMPLE_NOTHING;
        -: 1628:			}
        -: 1629:#endif
    #####: 1630:			break;
    #####: 1631:		case PHOTOMETRIC_CIELAB:
    #####: 1632:            if( t2p->tiff_samplesperpixel != 3){
    #####: 1633:                TIFFError(
        -: 1634:                    TIFF2PDF_MODULE, 
        -: 1635:                    "Unsupported samplesperpixel = %d for CIELAB", 
    #####: 1636:                    t2p->tiff_samplesperpixel);
    #####: 1637:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1638:                return;
        -: 1639:            }
    #####: 1640:            if( t2p->tiff_bitspersample != 8){
    #####: 1641:                TIFFError(
        -: 1642:                    TIFF2PDF_MODULE, 
        -: 1643:                    "Invalid bitspersample = %d for CIELAB", 
    #####: 1644:                    t2p->tiff_bitspersample);
    #####: 1645:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1646:                return;
        -: 1647:            }
    #####: 1648:			t2p->pdf_labrange[0]= -127;
    #####: 1649:			t2p->pdf_labrange[1]= 127;
    #####: 1650:			t2p->pdf_labrange[2]= -127;
    #####: 1651:			t2p->pdf_labrange[3]= 127;
    #####: 1652:			t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;
    #####: 1653:			t2p->pdf_colorspace=T2P_CS_LAB;
    #####: 1654:			break;
        1: 1655:		case PHOTOMETRIC_ICCLAB:
        1: 1656:			t2p->pdf_labrange[0]= 0;
        1: 1657:			t2p->pdf_labrange[1]= 255;
        1: 1658:			t2p->pdf_labrange[2]= 0;
        1: 1659:			t2p->pdf_labrange[3]= 255;
        1: 1660:			t2p->pdf_colorspace=T2P_CS_LAB;
        1: 1661:			break;
    #####: 1662:		case PHOTOMETRIC_ITULAB:
    #####: 1663:            if( t2p->tiff_samplesperpixel != 3){
    #####: 1664:                TIFFError(
        -: 1665:                    TIFF2PDF_MODULE, 
        -: 1666:                    "Unsupported samplesperpixel = %d for ITULAB", 
    #####: 1667:                    t2p->tiff_samplesperpixel);
    #####: 1668:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1669:                return;
        -: 1670:            }
    #####: 1671:            if( t2p->tiff_bitspersample != 8){
    #####: 1672:                TIFFError(
        -: 1673:                    TIFF2PDF_MODULE, 
        -: 1674:                    "Invalid bitspersample = %d for ITULAB", 
    #####: 1675:                    t2p->tiff_bitspersample);
    #####: 1676:                t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1677:                return;
        -: 1678:            }
    #####: 1679:			t2p->pdf_labrange[0]=-85;
    #####: 1680:			t2p->pdf_labrange[1]=85;
    #####: 1681:			t2p->pdf_labrange[2]=-75;
    #####: 1682:			t2p->pdf_labrange[3]=124;
    #####: 1683:			t2p->pdf_sample=T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED;
    #####: 1684:			t2p->pdf_colorspace=T2P_CS_LAB;
    #####: 1685:			break;
    #####: 1686:		case PHOTOMETRIC_LOGL:
        -: 1687:		case PHOTOMETRIC_LOGLUV:
    #####: 1688:			TIFFError(
        -: 1689:				TIFF2PDF_MODULE, 
        -: 1690:				"No support for %s with photometric interpretation LogL/LogLuv", 
        -: 1691:				TIFFFileName(input));
    #####: 1692:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1693:			return;
    #####: 1694:		default:
    #####: 1695:			TIFFError(
        -: 1696:				TIFF2PDF_MODULE, 
        -: 1697:				"No support for %s with photometric interpretation %u", 
        -: 1698:				TIFFFileName(input),
    #####: 1699:				t2p->tiff_photometric);
    #####: 1700:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1701:			return;
        -: 1702:	}
        -: 1703:
        1: 1704:	if(TIFFGetField(input, TIFFTAG_PLANARCONFIG, &(t2p->tiff_planar))){
        1: 1705:		switch(t2p->tiff_planar){
    #####: 1706:			case 0:
    #####: 1707:				TIFFWarning(
        -: 1708:					TIFF2PDF_MODULE, 
        -: 1709:					"Image %s has planar configuration 0, assuming 1", 
        -: 1710:					TIFFFileName(input));
    #####: 1711:				t2p->tiff_planar=PLANARCONFIG_CONTIG;
        1: 1712:			case PLANARCONFIG_CONTIG:
        1: 1713:				break;
    #####: 1714:			case PLANARCONFIG_SEPARATE:
    #####: 1715:				t2p->pdf_sample=T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG;
    #####: 1716:				if(t2p->tiff_bitspersample!=8){
    #####: 1717:					TIFFError(
        -: 1718:						TIFF2PDF_MODULE, 
        -: 1719:						"No support for %s with separated planar configuration and %u bits per sample", 
        -: 1720:						TIFFFileName(input),
    #####: 1721:						t2p->tiff_bitspersample);
    #####: 1722:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1723:					return;
        -: 1724:				}
    #####: 1725:				break;
    #####: 1726:			default:
    #####: 1727:				TIFFError(
        -: 1728:					TIFF2PDF_MODULE, 
        -: 1729:					"No support for %s with planar configuration %u", 
        -: 1730:					TIFFFileName(input),
    #####: 1731:					t2p->tiff_planar);
    #####: 1732:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1733:				return;
        -: 1734:		}
    #####: 1735:	}
        -: 1736:
        1: 1737:        TIFFGetFieldDefaulted(input, TIFFTAG_ORIENTATION,
        -: 1738:                              &(t2p->tiff_orientation));
        1: 1739:        if(t2p->tiff_orientation>8){
    #####: 1740:                TIFFWarning(TIFF2PDF_MODULE,
        -: 1741:                            "Image %s has orientation %u, assuming 0",
    #####: 1742:                            TIFFFileName(input), t2p->tiff_orientation);
    #####: 1743:                t2p->tiff_orientation=0;
        -: 1744:        }
        -: 1745:
        1: 1746:        if(TIFFGetField(input, TIFFTAG_XRESOLUTION, &(t2p->tiff_xres) ) == 0){
        1: 1747:                t2p->tiff_xres=0.0;
        -: 1748:        }
        1: 1749:        if(TIFFGetField(input, TIFFTAG_YRESOLUTION, &(t2p->tiff_yres) ) == 0){
        1: 1750:                t2p->tiff_yres=0.0;
        -: 1751:        }
        1: 1752:	TIFFGetFieldDefaulted(input, TIFFTAG_RESOLUTIONUNIT,
        -: 1753:			      &(t2p->tiff_resunit));
        1: 1754:	if(t2p->tiff_resunit == RESUNIT_CENTIMETER) {
    #####: 1755:		t2p->tiff_xres *= 2.54F;
    #####: 1756:		t2p->tiff_yres *= 2.54F;
        1: 1757:	} else if (t2p->tiff_resunit != RESUNIT_INCH
    #####: 1758:		   && t2p->pdf_centimeters != 0) {
    #####: 1759:		t2p->tiff_xres *= 2.54F;
    #####: 1760:		t2p->tiff_yres *= 2.54F;
        -: 1761:	}
        -: 1762:
        1: 1763:	t2p_compose_pdf_page(t2p);
        1: 1764:        if( t2p->t2p_error == T2P_ERR_ERROR )
    #####: 1765:	    return;
        -: 1766:
        1: 1767:	t2p->pdf_transcode = T2P_TRANSCODE_ENCODE;
        1: 1768:	if(t2p->pdf_nopassthrough==0){
        -: 1769:#ifdef CCITT_SUPPORT
        1: 1770:		if(t2p->tiff_compression==COMPRESSION_CCITTFAX4  
        -: 1771:			){
    #####: 1772:			if(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){
    #####: 1773:				t2p->pdf_transcode = T2P_TRANSCODE_RAW;
    #####: 1774:				t2p->pdf_compression=T2P_COMPRESS_G4;
        -: 1775:			}
        -: 1776:		}
        -: 1777:#endif
        -: 1778:#ifdef ZIP_SUPPORT
        -: 1779:		if(t2p->tiff_compression== COMPRESSION_ADOBE_DEFLATE 
        -: 1780:			|| t2p->tiff_compression==COMPRESSION_DEFLATE){
        -: 1781:			if(TIFFIsTiled(input) || (TIFFNumberOfStrips(input)==1) ){
        -: 1782:				t2p->pdf_transcode = T2P_TRANSCODE_RAW;
        -: 1783:				t2p->pdf_compression=T2P_COMPRESS_ZIP;
        -: 1784:			}
        -: 1785:		}
        -: 1786:#endif
        -: 1787:#ifdef OJPEG_SUPPORT
        1: 1788:		if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 1789:			t2p->pdf_transcode = T2P_TRANSCODE_RAW;
    #####: 1790:			t2p->pdf_compression=T2P_COMPRESS_JPEG;
    #####: 1791:			t2p_process_ojpeg_tables(t2p, input);
        -: 1792:		}
        -: 1793:#endif
        -: 1794:#ifdef JPEG_SUPPORT
        1: 1795:		if(t2p->tiff_compression==COMPRESSION_JPEG){
        1: 1796:			t2p->pdf_transcode = T2P_TRANSCODE_RAW;
        1: 1797:			t2p->pdf_compression=T2P_COMPRESS_JPEG;
        -: 1798:		}
        -: 1799:#endif
        -: 1800:		(void)0;
        -: 1801:	}
        -: 1802:
        1: 1803:	if(t2p->pdf_transcode!=T2P_TRANSCODE_RAW){
    #####: 1804:		t2p->pdf_compression = t2p->pdf_defaultcompression;
        -: 1805:	}
        -: 1806:
        -: 1807:#ifdef JPEG_SUPPORT
        1: 1808:	if(t2p->pdf_defaultcompression==T2P_COMPRESS_JPEG){
    #####: 1809:		if(t2p->pdf_colorspace & T2P_CS_PALETTE){
    #####: 1810:			t2p->pdf_sample|=T2P_SAMPLE_REALIZE_PALETTE;
    #####: 1811:			t2p->pdf_colorspace ^= T2P_CS_PALETTE;
    #####: 1812:			t2p->tiff_pages[t2p->pdf_page].page_extra--;
        -: 1813:		}
        -: 1814:	}
        1: 1815:	if(t2p->tiff_compression==COMPRESSION_JPEG){
        1: 1816:		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 1817:			TIFFError(
        -: 1818:				TIFF2PDF_MODULE, 
        -: 1819:				"No support for %s with JPEG compression and separated planar configuration", 
        -: 1820:				TIFFFileName(input));
    #####: 1821:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 1822:			return;
        -: 1823:		}
        -: 1824:	}
        -: 1825:#endif
        -: 1826:#ifdef OJPEG_SUPPORT
        1: 1827:	if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 1828:		if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 1829:			TIFFError(
        -: 1830:				TIFF2PDF_MODULE, 
        -: 1831:				"No support for %s with OJPEG compression and separated planar configuration", 
        -: 1832:				TIFFFileName(input));
    #####: 1833:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 1834:			return;
        -: 1835:		}
        -: 1836:	}
        -: 1837:#endif
        -: 1838:
        1: 1839:	if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){
    #####: 1840:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
    #####: 1841:			t2p->tiff_samplesperpixel=4;
    #####: 1842:			t2p->tiff_photometric=PHOTOMETRIC_SEPARATED;
        -: 1843:		} else {
    #####: 1844:			t2p->tiff_samplesperpixel=3;
    #####: 1845:			t2p->tiff_photometric=PHOTOMETRIC_RGB;
        -: 1846:		}
        -: 1847:	}
        -: 1848:
        1: 1849:	if (TIFFGetField(input, TIFFTAG_TRANSFERFUNCTION,
        -: 1850:			 &(t2p->tiff_transferfunction[0]),
        -: 1851:			 &(t2p->tiff_transferfunction[1]),
        -: 1852:			 &(t2p->tiff_transferfunction[2]))) {
    #####: 1853:		if((t2p->tiff_transferfunction[1] != (float*) NULL) &&
    #####: 1854:                   (t2p->tiff_transferfunction[2] != (float*) NULL) &&
    #####: 1855:                   (t2p->tiff_transferfunction[1] !=
    #####: 1856:                    t2p->tiff_transferfunction[0])) {
    #####: 1857:			t2p->tiff_transferfunctioncount=3;
        -: 1858:		} else {
    #####: 1859:			t2p->tiff_transferfunctioncount=1;
        -: 1860:		}
        -: 1861:	} else {
        1: 1862:		t2p->tiff_transferfunctioncount=0;
        -: 1863:	}
        1: 1864:	if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp)!=0){
    #####: 1865:		t2p->tiff_whitechromaticities[0]=xfloatp[0];
    #####: 1866:		t2p->tiff_whitechromaticities[1]=xfloatp[1];
    #####: 1867:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
    #####: 1868:			t2p->pdf_colorspace |= T2P_CS_CALGRAY;
        -: 1869:		}
    #####: 1870:		if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 1871:			t2p->pdf_colorspace |= T2P_CS_CALRGB;
        -: 1872:		}
        -: 1873:	}
        1: 1874:	if(TIFFGetField(input, TIFFTAG_PRIMARYCHROMATICITIES, &xfloatp)!=0){
    #####: 1875:		t2p->tiff_primarychromaticities[0]=xfloatp[0];
    #####: 1876:		t2p->tiff_primarychromaticities[1]=xfloatp[1];
    #####: 1877:		t2p->tiff_primarychromaticities[2]=xfloatp[2];
    #####: 1878:		t2p->tiff_primarychromaticities[3]=xfloatp[3];
    #####: 1879:		t2p->tiff_primarychromaticities[4]=xfloatp[4];
    #####: 1880:		t2p->tiff_primarychromaticities[5]=xfloatp[5];
    #####: 1881:		if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 1882:			t2p->pdf_colorspace |= T2P_CS_CALRGB;
        -: 1883:		}
        -: 1884:	}
        1: 1885:	if(t2p->pdf_colorspace & T2P_CS_LAB){
        1: 1886:		if(TIFFGetField(input, TIFFTAG_WHITEPOINT, &xfloatp) != 0){
    #####: 1887:			t2p->tiff_whitechromaticities[0]=xfloatp[0];
    #####: 1888:			t2p->tiff_whitechromaticities[1]=xfloatp[1];
        -: 1889:		} else {
        1: 1890:			t2p->tiff_whitechromaticities[0]=0.3457F; /* 0.3127F; */
        1: 1891:			t2p->tiff_whitechromaticities[1]=0.3585F; /* 0.3290F; */
        -: 1892:		}
        -: 1893:	}
        1: 1894:	if(TIFFGetField(input, 
        -: 1895:		TIFFTAG_ICCPROFILE, 
        -: 1896:		&(t2p->tiff_iccprofilelength), 
        -: 1897:		&(t2p->tiff_iccprofile))!=0){
    #####: 1898:		t2p->pdf_colorspace |= T2P_CS_ICCBASED;
        -: 1899:	} else {
        1: 1900:		t2p->tiff_iccprofilelength=0;
        1: 1901:		t2p->tiff_iccprofile=NULL;
        -: 1902:	}
        -: 1903:	
        -: 1904:#ifdef CCITT_SUPPORT
       1*: 1905:	if( t2p->tiff_bitspersample==1 &&
    #####: 1906:		t2p->tiff_samplesperpixel==1){
    #####: 1907:		t2p->pdf_compression = T2P_COMPRESS_G4;
        -: 1908:	}
        -: 1909:#endif
        -: 1910:
        -: 1911:
        1: 1912:	return;
        -: 1913:}
        -: 1914:
        -: 1915:/*
        -: 1916:	This function returns the necessary size of a data buffer to contain the raw or 
        -: 1917:	uncompressed image data from the input TIFF for a page.
        -: 1918:*/
        -: 1919:
    #####: 1920:void t2p_read_tiff_size(T2P* t2p, TIFF* input){
        -: 1921:
    #####: 1922:	uint64* sbc=NULL;
        -: 1923:#if defined(JPEG_SUPPORT) || defined (OJPEG_SUPPORT)
    #####: 1924:	unsigned char* jpt=NULL;
    #####: 1925:	tstrip_t i=0;
    #####: 1926:	tstrip_t stripcount=0;
        -: 1927:#endif
    #####: 1928:        uint64 k = 0;
        -: 1929:
    #####: 1930:	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
        -: 1931:#ifdef CCITT_SUPPORT
    #####: 1932:		if(t2p->pdf_compression == T2P_COMPRESS_G4 ){
    #####: 1933:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
        -: 1934:            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
        -: 1935:                TIFFError(TIFF2PDF_MODULE, "Integer overflow");
        -: 1936:                t2p->t2p_error = T2P_ERR_ERROR;
        -: 1937:            }
    #####: 1938:			t2p->tiff_datasize=(tmsize_t)sbc[0];
    #####: 1939:			return;
        -: 1940:		}
        -: 1941:#endif
        -: 1942:#ifdef ZIP_SUPPORT
        -: 1943:		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
        -: 1944:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
        -: 1945:            if (sbc[0] != (uint64)(tmsize_t)sbc[0]) {
        -: 1946:                TIFFError(TIFF2PDF_MODULE, "Integer overflow");
        -: 1947:                t2p->t2p_error = T2P_ERR_ERROR;
        -: 1948:            }
        -: 1949:			t2p->tiff_datasize=(tmsize_t)sbc[0];
        -: 1950:			return;
        -: 1951:		}
        -: 1952:#endif
        -: 1953:#ifdef OJPEG_SUPPORT
    #####: 1954:		if(t2p->tiff_compression == COMPRESSION_OJPEG){
    #####: 1955:			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
    #####: 1956:				TIFFError(TIFF2PDF_MODULE, 
        -: 1957:					"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS",
        -: 1958:					TIFFFileName(input));
    #####: 1959:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1960:				return;
        -: 1961:			}
    #####: 1962:			stripcount=TIFFNumberOfStrips(input);
    #####: 1963:			for(i=0;i<stripcount;i++){
    #####: 1964:				k = checkAdd64(k, sbc[i], t2p);
        -: 1965:			}
    #####: 1966:			if(TIFFGetField(input, TIFFTAG_JPEGIFOFFSET, &(t2p->tiff_dataoffset))){
    #####: 1967:				if(t2p->tiff_dataoffset != 0){
    #####: 1968:					if(TIFFGetField(input, TIFFTAG_JPEGIFBYTECOUNT, &(t2p->tiff_datasize))!=0){
    #####: 1969:						if((uint64)t2p->tiff_datasize < k) {
    #####: 1970:							TIFFWarning(TIFF2PDF_MODULE, 
        -: 1971:								"Input file %s has short JPEG interchange file byte count", 
        -: 1972:								TIFFFileName(input));
    #####: 1973:							t2p->pdf_ojpegiflength=t2p->tiff_datasize;
    #####: 1974:							k = checkAdd64(k, t2p->tiff_datasize, t2p);
    #####: 1975:							k = checkAdd64(k, 6, t2p);
    #####: 1976:							k = checkAdd64(k, stripcount, t2p);
    #####: 1977:							k = checkAdd64(k, stripcount, t2p);
    #####: 1978:							t2p->tiff_datasize = (tsize_t) k;
    #####: 1979:							if ((uint64) t2p->tiff_datasize != k) {
    #####: 1980:								TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 1981:								t2p->t2p_error = T2P_ERR_ERROR;
        -: 1982:							}
    #####: 1983:							return;
        -: 1984:						}
    #####: 1985:						return;
        -: 1986:					}else {
    #####: 1987:						TIFFError(TIFF2PDF_MODULE, 
        -: 1988:							"Input file %s missing field: TIFFTAG_JPEGIFBYTECOUNT",
        -: 1989:							TIFFFileName(input));
    #####: 1990:							t2p->t2p_error = T2P_ERR_ERROR;
    #####: 1991:							return;
        -: 1992:					}
        -: 1993:				}
        -: 1994:			}
    #####: 1995:			k = checkAdd64(k, stripcount, t2p);
    #####: 1996:			k = checkAdd64(k, stripcount, t2p);
    #####: 1997:			k = checkAdd64(k, 2048, t2p);
    #####: 1998:			t2p->tiff_datasize = (tsize_t) k;
    #####: 1999:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 2000:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2001:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2002:			}
    #####: 2003:			return;
        -: 2004:		}
        -: 2005:#endif
        -: 2006:#ifdef JPEG_SUPPORT
    #####: 2007:		if(t2p->tiff_compression == COMPRESSION_JPEG) {
    #####: 2008:			uint32 count = 0;
    #####: 2009:			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0 ){
    #####: 2010:				if(count > 4){
    #####: 2011:					k += count;
    #####: 2012:					k -= 2; /* don't use EOI of header */
        -: 2013:				}
        -: 2014:			} else {
    #####: 2015:				k = 2; /* SOI for first strip */
        -: 2016:			}
    #####: 2017:			stripcount=TIFFNumberOfStrips(input);
    #####: 2018:			if(!TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc)){
    #####: 2019:				TIFFError(TIFF2PDF_MODULE, 
        -: 2020:					"Input file %s missing field: TIFFTAG_STRIPBYTECOUNTS",
        -: 2021:					TIFFFileName(input));
    #####: 2022:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2023:				return;
        -: 2024:			}
    #####: 2025:			for(i=0;i<stripcount;i++){
    #####: 2026:				k = checkAdd64(k, sbc[i], t2p);
    #####: 2027:				k -=2; /* don't use EOI of strip */
    #####: 2028:				k +=2; /* add space for restart marker */
        -: 2029:			}
    #####: 2030:			k = checkAdd64(k, 2, t2p); /* use EOI of last strip */
    #####: 2031:			k = checkAdd64(k, 6, t2p); /* for DRI marker of first strip */
    #####: 2032:			t2p->tiff_datasize = (tsize_t) k;
    #####: 2033:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 2034:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2035:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2036:			}
    #####: 2037:			return;
        -: 2038:		}
        -: 2039:#endif
        -: 2040:		(void) 0;
        -: 2041:	}
    #####: 2042:	k = checkMultiply64(TIFFScanlineSize(input), t2p->tiff_length, t2p);
    #####: 2043:	if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 2044:		k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
        -: 2045:	}
    #####: 2046:	if (k == 0) {
        -: 2047:		/* Assume we had overflow inside TIFFScanlineSize */
    #####: 2048:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2049:	}
        -: 2050:
    #####: 2051:	t2p->tiff_datasize = (tsize_t) k;
    #####: 2052:	if ((uint64) t2p->tiff_datasize != k) {
    #####: 2053:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2054:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2055:	}
        -: 2056:
    #####: 2057:	return;
        -: 2058:}
        -: 2059:
        -: 2060:/*
        -: 2061:	This function returns the necessary size of a data buffer to contain the raw or 
        -: 2062:	uncompressed image data from the input TIFF for a tile of a page.
        -: 2063:*/
        -: 2064:
        1: 2065:void t2p_read_tiff_size_tile(T2P* t2p, TIFF* input, ttile_t tile){
        -: 2066:
        1: 2067:	uint64* tbc = NULL;
        1: 2068:	uint16 edge=0;
        -: 2069:#ifdef JPEG_SUPPORT
        1: 2070:	unsigned char* jpt;
        -: 2071:#endif
        -: 2072:        uint64 k;
        -: 2073:
        1: 2074:	edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
        1: 2075:	edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
        -: 2076:	
        1: 2077:	if(t2p->pdf_transcode==T2P_TRANSCODE_RAW){
        1: 2078:		if(edge
        -: 2079:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
        1: 2080:		&& !(t2p->pdf_compression==T2P_COMPRESS_JPEG)
        -: 2081:#endif
        -: 2082:		){
    #####: 2083:			t2p->tiff_datasize=TIFFTileSize(input);
    #####: 2084:			if (t2p->tiff_datasize == 0) {
        -: 2085:				/* Assume we had overflow inside TIFFTileSize */
    #####: 2086:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2087:			}
    #####: 2088:			return;
        -: 2089:		} else {
        1: 2090:			TIFFGetField(input, TIFFTAG_TILEBYTECOUNTS, &tbc);
        1: 2091:			k=tbc[tile];
        -: 2092:#ifdef OJPEG_SUPPORT
        1: 2093:			if(t2p->tiff_compression==COMPRESSION_OJPEG){
    #####: 2094:			  	k = checkAdd64(k, 2048, t2p);
        -: 2095:			}
        -: 2096:#endif
        -: 2097:#ifdef JPEG_SUPPORT
        1: 2098:			if(t2p->tiff_compression==COMPRESSION_JPEG) {
        1: 2099:				uint32 count = 0;
        1: 2100:				if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt)!=0){
        1: 2101:					if(count > 4){
    #####: 2102:						k = checkAdd64(k, count, t2p);
    #####: 2103:						k -= 2; /* don't use EOI of header or SOI of tile */
        -: 2104:					}
        -: 2105:				}
        -: 2106:			}
        -: 2107:#endif
        1: 2108:			t2p->tiff_datasize = (tsize_t) k;
        1: 2109:			if ((uint64) t2p->tiff_datasize != k) {
    #####: 2110:				TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2111:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2112:			}
        1: 2113:			return;
        -: 2114:		}
        -: 2115:	}
    #####: 2116:	k = TIFFTileSize(input);
    #####: 2117:	if(t2p->tiff_planar==PLANARCONFIG_SEPARATE){
    #####: 2118:		k = checkMultiply64(k, t2p->tiff_samplesperpixel, t2p);
        -: 2119:	}
    #####: 2120:	if (k == 0) {
        -: 2121:		/* Assume we had overflow inside TIFFTileSize */
    #####: 2122:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2123:	}
        -: 2124:
    #####: 2125:	t2p->tiff_datasize = (tsize_t) k;
    #####: 2126:	if ((uint64) t2p->tiff_datasize != k) {
    #####: 2127:		TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 2128:		t2p->t2p_error = T2P_ERR_ERROR;
        -: 2129:	}
        -: 2130:
    #####: 2131:	return;
        -: 2132:}
        -: 2133:
        -: 2134:/*
        -: 2135: * This functions returns a non-zero value when the tile is on the right edge
        -: 2136: * and does not have full imaged tile width.
        -: 2137: */
        -: 2138:
        3: 2139:int t2p_tile_is_right_edge(T2P_TILES tiles, ttile_t tile){
        -: 2140:
       3*: 2141:	if( ((tile+1) % tiles.tiles_tilecountx == 0) 
        3: 2142:		&& (tiles.tiles_edgetilewidth != 0) ){
    #####: 2143:		return(1);
        -: 2144:	} else {
        3: 2145:		return(0);
        -: 2146:	}
        -: 2147:}
        -: 2148:
        -: 2149:/*
        -: 2150: * This functions returns a non-zero value when the tile is on the bottom edge
        -: 2151: * and does not have full imaged tile length.
        -: 2152: */
        -: 2153:
        3: 2154:int t2p_tile_is_bottom_edge(T2P_TILES tiles, ttile_t tile){
        -: 2155:
        3: 2156:	if( ((tile+1) > (tiles.tiles_tilecount-tiles.tiles_tilecountx) )
        3: 2157:		&& (tiles.tiles_edgetilelength != 0) ){
        3: 2158:		return(1);
        -: 2159:	} else {
    #####: 2160:		return(0);
        -: 2161:	}
        -: 2162:}
        -: 2163:
        -: 2164:/*
        -: 2165: * This function returns a non-zero value when the tile is a right edge tile
        -: 2166: * or a bottom edge tile.
        -: 2167: */
        -: 2168:
    #####: 2169:int t2p_tile_is_edge(T2P_TILES tiles, ttile_t tile){
        -: 2170:
    #####: 2171:	return(t2p_tile_is_right_edge(tiles, tile) | t2p_tile_is_bottom_edge(tiles, tile) );
        -: 2172:}
        -: 2173:
        -: 2174:/*
        -: 2175:	This function returns a non-zero value when the tile is a right edge tile and a bottom 
        -: 2176:	edge tile.
        -: 2177:*/
        -: 2178:
    #####: 2179:int t2p_tile_is_corner_edge(T2P_TILES tiles, ttile_t tile){
        -: 2180:
    #####: 2181:	return(t2p_tile_is_right_edge(tiles, tile) & t2p_tile_is_bottom_edge(tiles, tile) );
        -: 2182:}
        -: 2183:
        -: 2184:
        -: 2185:/*
        -: 2186:	This function reads the raster image data from the input TIFF for an image and writes 
        -: 2187:	the data to the output PDF XObject image dictionary stream.  It returns the amount written 
        -: 2188:	or zero on error.
        -: 2189:*/
        -: 2190:
    #####: 2191:tsize_t t2p_readwrite_pdf_image(T2P* t2p, TIFF* input, TIFF* output){
        -: 2192:
    #####: 2193:	tsize_t written=0;
    #####: 2194:	unsigned char* buffer=NULL;
    #####: 2195:	unsigned char* samplebuffer=NULL;
    #####: 2196:	tsize_t bufferoffset=0;
    #####: 2197:	tsize_t samplebufferoffset=0;
    #####: 2198:	tsize_t read=0;
    #####: 2199:	tstrip_t i=0;
    #####: 2200:	tstrip_t j=0;
    #####: 2201:	tstrip_t stripcount=0;
    #####: 2202:	tsize_t stripsize=0;
    #####: 2203:	tsize_t sepstripcount=0;
    #####: 2204:	tsize_t sepstripsize=0;
        -: 2205:#ifdef OJPEG_SUPPORT
    #####: 2206:	toff_t inputoffset=0;
    #####: 2207:	uint16 h_samp=1;
    #####: 2208:	uint16 v_samp=1;
    #####: 2209:	uint16 ri=1;
    #####: 2210:	uint32 rows=0;
        -: 2211:#endif /* ifdef OJPEG_SUPPORT */
        -: 2212:#ifdef JPEG_SUPPORT
    #####: 2213:	unsigned char* jpt;
    #####: 2214:	float* xfloatp;
    #####: 2215:	uint64* sbc;
        -: 2216:	unsigned char* stripbuffer;
    #####: 2217:	tsize_t striplength=0;
    #####: 2218:	uint32 max_striplength=0;
        -: 2219:#endif /* ifdef JPEG_SUPPORT */
        -: 2220:
        -: 2221:	/* Fail if prior error (in particular, can't trust tiff_datasize) */
    #####: 2222:	if (t2p->t2p_error != T2P_ERR_OK)
    #####: 2223:		return(0);
        -: 2224:
    #####: 2225:	if(t2p->pdf_transcode == T2P_TRANSCODE_RAW){
        -: 2226:#ifdef CCITT_SUPPORT
    #####: 2227:		if(t2p->pdf_compression == T2P_COMPRESS_G4){
        -: 2228:			buffer = (unsigned char*)
    #####: 2229:				_TIFFmalloc(t2p->tiff_datasize);
    #####: 2230:			if (buffer == NULL) {
    #####: 2231:				TIFFError(TIFF2PDF_MODULE, 
        -: 2232:                                          "Can't allocate %lu bytes of memory for "
        -: 2233:                                          "t2p_readwrite_pdf_image, %s", 
    #####: 2234:					(unsigned long) t2p->tiff_datasize, 
        -: 2235:					TIFFFileName(input));
    #####: 2236:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2237:				return(0);
        -: 2238:			}
    #####: 2239:			TIFFReadRawStrip(input, 0, (tdata_t) buffer,
        -: 2240:					 t2p->tiff_datasize);
    #####: 2241:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
        -: 2242:					/*
        -: 2243:					 * make sure is lsb-to-msb
        -: 2244:					 * bit-endianness fill order
        -: 2245:					 */
    #####: 2246:					TIFFReverseBits(buffer,
        -: 2247:							t2p->tiff_datasize);
        -: 2248:			}
    #####: 2249:			t2pWriteFile(output, (tdata_t) buffer,
        -: 2250:				      t2p->tiff_datasize);
    #####: 2251:			_TIFFfree(buffer);
    #####: 2252:			return(t2p->tiff_datasize);
        -: 2253:		}
        -: 2254:#endif /* ifdef CCITT_SUPPORT */
        -: 2255:#ifdef ZIP_SUPPORT
        -: 2256:		if (t2p->pdf_compression == T2P_COMPRESS_ZIP) {
        -: 2257:			buffer = (unsigned char*)
        -: 2258:				_TIFFmalloc(t2p->tiff_datasize);
        -: 2259:			if(buffer == NULL){
        -: 2260:				TIFFError(TIFF2PDF_MODULE, 
        -: 2261:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
        -: 2262:					(unsigned long) t2p->tiff_datasize, 
        -: 2263:					TIFFFileName(input));
        -: 2264:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2265:				return(0);
        -: 2266:			}
        -: 2267:                        memset(buffer, 0, t2p->tiff_datasize);
        -: 2268:			TIFFReadRawStrip(input, 0, (tdata_t) buffer,
        -: 2269:					 t2p->tiff_datasize);
        -: 2270:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB) {
        -: 2271:					TIFFReverseBits(buffer,
        -: 2272:							t2p->tiff_datasize);
        -: 2273:			}
        -: 2274:			t2pWriteFile(output, (tdata_t) buffer,
        -: 2275:				      t2p->tiff_datasize);
        -: 2276:			_TIFFfree(buffer);
        -: 2277:			return(t2p->tiff_datasize);
        -: 2278:		}
        -: 2279:#endif /* ifdef ZIP_SUPPORT */
        -: 2280:#ifdef OJPEG_SUPPORT
    #####: 2281:		if(t2p->tiff_compression == COMPRESSION_OJPEG) {
        -: 2282:
    #####: 2283:			if(t2p->tiff_dataoffset != 0) {
        -: 2284:				buffer = (unsigned char*)
    #####: 2285:					_TIFFmalloc(t2p->tiff_datasize);
    #####: 2286:				if(buffer == NULL) {
    #####: 2287:					TIFFError(TIFF2PDF_MODULE, 
        -: 2288:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2289:						(unsigned long) t2p->tiff_datasize, 
        -: 2290:						TIFFFileName(input));
    #####: 2291:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2292:					return(0);
        -: 2293:				}
    #####: 2294:                                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2295:				if(t2p->pdf_ojpegiflength==0){
    #####: 2296:					inputoffset=t2pSeekFile(input, 0,
        -: 2297:								 SEEK_CUR);
    #####: 2298:					t2pSeekFile(input,
        -: 2299:						     t2p->tiff_dataoffset,
        -: 2300:						     SEEK_SET);
    #####: 2301:					t2pReadFile(input, (tdata_t) buffer,
        -: 2302:						     t2p->tiff_datasize);
    #####: 2303:					t2pSeekFile(input, inputoffset,
        -: 2304:						     SEEK_SET);
    #####: 2305:					t2pWriteFile(output, (tdata_t) buffer,
        -: 2306:						      t2p->tiff_datasize);
    #####: 2307:					_TIFFfree(buffer);
    #####: 2308:					return(t2p->tiff_datasize);
        -: 2309:				} else {
    #####: 2310:					inputoffset=t2pSeekFile(input, 0,
        -: 2311:								 SEEK_CUR);
    #####: 2312:					t2pSeekFile(input,
        -: 2313:						     t2p->tiff_dataoffset,
        -: 2314:						     SEEK_SET);
    #####: 2315:					bufferoffset = t2pReadFile(input,
        -: 2316:						(tdata_t) buffer,
    #####: 2317:						t2p->pdf_ojpegiflength);
    #####: 2318:					t2p->pdf_ojpegiflength = 0;
    #####: 2319:					t2pSeekFile(input, inputoffset,
        -: 2320:						     SEEK_SET);
    #####: 2321:					TIFFGetField(input,
        -: 2322:						     TIFFTAG_YCBCRSUBSAMPLING,
        -: 2323:						     &h_samp, &v_samp);
    #####: 2324:					buffer[bufferoffset++]= 0xff;
    #####: 2325:					buffer[bufferoffset++]= 0xdd;
    #####: 2326:					buffer[bufferoffset++]= 0x00;
    #####: 2327:					buffer[bufferoffset++]= 0x04;
    #####: 2328:					h_samp*=8;
    #####: 2329:					v_samp*=8;
    #####: 2330:					ri=(t2p->tiff_width+h_samp-1) / h_samp;
    #####: 2331:					TIFFGetField(input,
        -: 2332:						     TIFFTAG_ROWSPERSTRIP,
        -: 2333:						     &rows);
    #####: 2334:					ri*=(rows+v_samp-1)/v_samp;
    #####: 2335:					buffer[bufferoffset++]= (ri>>8) & 0xff;
    #####: 2336:					buffer[bufferoffset++]= ri & 0xff;
    #####: 2337:					stripcount=TIFFNumberOfStrips(input);
    #####: 2338:					for(i=0;i<stripcount;i++){
    #####: 2339:						if(i != 0 ){ 
    #####: 2340:							buffer[bufferoffset++]=0xff;
    #####: 2341:							buffer[bufferoffset++]=(0xd0 | ((i-1)%8));
        -: 2342:						}
    #####: 2343:						bufferoffset+=TIFFReadRawStrip(input, 
        -: 2344:							i, 
    #####: 2345:							(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2346:							-1);
        -: 2347:					}
    #####: 2348:					t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2349:					_TIFFfree(buffer);
    #####: 2350:					return(bufferoffset);
        -: 2351:				}
        -: 2352:			} else {
    #####: 2353:				if(! t2p->pdf_ojpegdata){
    #####: 2354:					TIFFError(TIFF2PDF_MODULE, 
        -: 2355:				"No support for OJPEG image %s with bad tables", 
        -: 2356:						TIFFFileName(input));
    #####: 2357:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2358:					return(0);
        -: 2359:				}
        -: 2360:				buffer = (unsigned char*)
    #####: 2361:					_TIFFmalloc(t2p->tiff_datasize);
    #####: 2362:				if(buffer==NULL){
    #####: 2363:					TIFFError(TIFF2PDF_MODULE, 
        -: 2364:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2365:						(unsigned long) t2p->tiff_datasize, 
        -: 2366:						TIFFFileName(input));
    #####: 2367:					t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2368:					return(0);
        -: 2369:				}
    #####: 2370:                                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2371:				_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);
    #####: 2372:				bufferoffset=t2p->pdf_ojpegdatalength;
    #####: 2373:				stripcount=TIFFNumberOfStrips(input);
    #####: 2374:				for(i=0;i<stripcount;i++){
    #####: 2375:					if(i != 0){
    #####: 2376:						buffer[bufferoffset++]=0xff;
    #####: 2377:						buffer[bufferoffset++]=(0xd0 | ((i-1)%8));
        -: 2378:					}
    #####: 2379:					bufferoffset+=TIFFReadRawStrip(input, 
        -: 2380:						i, 
    #####: 2381:						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2382:						-1);
        -: 2383:				}
    #####: 2384:				if( ! ( (buffer[bufferoffset-1]==0xd9) && (buffer[bufferoffset-2]==0xff) ) ){
    #####: 2385:						buffer[bufferoffset++]=0xff;
    #####: 2386:						buffer[bufferoffset++]=0xd9;
        -: 2387:				}
    #####: 2388:				t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2389:				_TIFFfree(buffer);
    #####: 2390:				return(bufferoffset);
        -: 2391:#if 0
        -: 2392:                                /*
        -: 2393:                                  This hunk of code removed code is clearly
        -: 2394:                                  mis-placed and we are not sure where it
        -: 2395:                                  should be (if anywhere)
        -: 2396:                                */
        -: 2397:				TIFFError(TIFF2PDF_MODULE, 
        -: 2398:	"No support for OJPEG image %s with no JPEG File Interchange offset", 
        -: 2399:					TIFFFileName(input));
        -: 2400:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2401:				return(0);
        -: 2402:#endif
        -: 2403:			}
        -: 2404:		}
        -: 2405:#endif /* ifdef OJPEG_SUPPORT */
        -: 2406:#ifdef JPEG_SUPPORT
    #####: 2407:		if(t2p->tiff_compression == COMPRESSION_JPEG) {
    #####: 2408:			uint32 count = 0;
        -: 2409:			buffer = (unsigned char*)
    #####: 2410:				_TIFFmalloc(t2p->tiff_datasize);
    #####: 2411:			if(buffer==NULL){
    #####: 2412:				TIFFError(TIFF2PDF_MODULE, 
        -: 2413:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2414:					(unsigned long) t2p->tiff_datasize, 
        -: 2415:					TIFFFileName(input));
    #####: 2416:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2417:				return(0);
        -: 2418:			}
    #####: 2419:                        memset(buffer, 0, t2p->tiff_datasize);
    #####: 2420:			if (TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
    #####: 2421:				if(count > 4) {
    #####: 2422:					_TIFFmemcpy(buffer, jpt, count);
    #####: 2423:					bufferoffset += count - 2;
        -: 2424:				}
        -: 2425:			}
    #####: 2426:			stripcount=TIFFNumberOfStrips(input);
    #####: 2427:			TIFFGetField(input, TIFFTAG_STRIPBYTECOUNTS, &sbc);
    #####: 2428:			for(i=0;i<stripcount;i++){
    #####: 2429:				if(sbc[i]>max_striplength) max_striplength=sbc[i];
        -: 2430:			}
        -: 2431:			stripbuffer = (unsigned char*)
    #####: 2432:				_TIFFmalloc(max_striplength);
    #####: 2433:			if(stripbuffer==NULL){
    #####: 2434:				TIFFError(TIFF2PDF_MODULE, 
        -: 2435:	"Can't allocate %u bytes of memory for t2p_readwrite_pdf_image, %s", 
        -: 2436:					max_striplength, 
        -: 2437:					TIFFFileName(input));
    #####: 2438:				_TIFFfree(buffer);
    #####: 2439:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2440:				return(0);
        -: 2441:			}
    #####: 2442:			for(i=0;i<stripcount;i++){
    #####: 2443:				striplength=TIFFReadRawStrip(input, i, (tdata_t) stripbuffer, -1);
    #####: 2444:				if(!t2p_process_jpeg_strip(
        -: 2445:					stripbuffer, 
        -: 2446:					&striplength, 
        -: 2447:					buffer,
        -: 2448:                    t2p->tiff_datasize,
        -: 2449:					&bufferoffset, 
        -: 2450:					i, 
        -: 2451:					t2p->tiff_length)){
    #####: 2452:						TIFFError(TIFF2PDF_MODULE, 
        -: 2453:				"Can't process JPEG data in input file %s", 
        -: 2454:							TIFFFileName(input));
    #####: 2455:						_TIFFfree(samplebuffer);
    #####: 2456:						_TIFFfree(buffer);
    #####: 2457:						t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2458:						return(0);
        -: 2459:				}
        -: 2460:			}
    #####: 2461:			buffer[bufferoffset++]=0xff; 
    #####: 2462:			buffer[bufferoffset++]=0xd9;
    #####: 2463:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2464:			_TIFFfree(stripbuffer);
    #####: 2465:			_TIFFfree(buffer);
    #####: 2466:			return(bufferoffset);
        -: 2467:		}
        -: 2468:#endif /* ifdef JPEG_SUPPORT */
        -: 2469:		(void)0;
        -: 2470:	}
        -: 2471:
    #####: 2472:	if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
    #####: 2473:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2474:		if(buffer==NULL){
    #####: 2475:			TIFFError(TIFF2PDF_MODULE, 
        -: 2476:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2477:				(unsigned long) t2p->tiff_datasize, 
        -: 2478:				TIFFFileName(input));
    #####: 2479:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2480:			return(0);
        -: 2481:		}
    #####: 2482:                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2483:		stripsize=TIFFStripSize(input);
    #####: 2484:		stripcount=TIFFNumberOfStrips(input);
    #####: 2485:		for(i=0;i<stripcount;i++){
        -: 2486:			read = 
    #####: 2487:				TIFFReadEncodedStrip(input, 
        -: 2488:				i, 
    #####: 2489:				(tdata_t) &buffer[bufferoffset], 
    #####: 2490:				TIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));
    #####: 2491:			if(read==-1){
    #####: 2492:				TIFFError(TIFF2PDF_MODULE, 
        -: 2493:					"Error on decoding strip %u of %s", 
        -: 2494:					i, 
        -: 2495:					TIFFFileName(input));
    #####: 2496:				_TIFFfree(buffer);
    #####: 2497:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2498:				return(0);
        -: 2499:			}
    #####: 2500:			bufferoffset+=read;
        -: 2501:		}
        -: 2502:	} else {
    #####: 2503:		if(t2p->pdf_sample & T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
        -: 2504:		
    #####: 2505:			sepstripsize=TIFFStripSize(input);
    #####: 2506:			sepstripcount=TIFFNumberOfStrips(input);
        -: 2507:		
    #####: 2508:			stripsize=sepstripsize*t2p->tiff_samplesperpixel;
    #####: 2509:			stripcount=sepstripcount/t2p->tiff_samplesperpixel;
        -: 2510:			
    #####: 2511:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2512:			if(buffer==NULL){
    #####: 2513:				TIFFError(TIFF2PDF_MODULE, 
        -: 2514:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2515:					(unsigned long) t2p->tiff_datasize, 
        -: 2516:					TIFFFileName(input));
    #####: 2517:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2518:				return(0);
        -: 2519:			}
    #####: 2520:                        memset(buffer, 0, t2p->tiff_datasize);
    #####: 2521:			samplebuffer = (unsigned char*) _TIFFmalloc(stripsize);
    #####: 2522:			if(samplebuffer==NULL){
    #####: 2523:				TIFFError(TIFF2PDF_MODULE, 
        -: 2524:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2525:					(unsigned long) t2p->tiff_datasize, 
        -: 2526:					TIFFFileName(input));
    #####: 2527:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2528:                                _TIFFfree(buffer);
    #####: 2529:				return(0);
        -: 2530:			}
    #####: 2531:			for(i=0;i<stripcount;i++){
    #####: 2532:				samplebufferoffset=0;
    #####: 2533:				for(j=0;j<t2p->tiff_samplesperpixel;j++){
        -: 2534:					read = 
    #####: 2535:						TIFFReadEncodedStrip(input, 
    #####: 2536:							i + j*stripcount, 
    #####: 2537:							(tdata_t) &(samplebuffer[samplebufferoffset]), 
    #####: 2538:							TIFFmin(sepstripsize, stripsize - samplebufferoffset));
    #####: 2539:					if(read==-1){
    #####: 2540:						TIFFError(TIFF2PDF_MODULE, 
        -: 2541:					"Error on decoding strip %u of %s", 
    #####: 2542:							i + j*stripcount, 
        -: 2543:							TIFFFileName(input));
    #####: 2544:							_TIFFfree(buffer);
    #####: 2545:						t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2546:						return(0);
        -: 2547:					}
    #####: 2548:					samplebufferoffset+=read;
        -: 2549:				}
    #####: 2550:				t2p_sample_planar_separate_to_contig(
        -: 2551:					t2p,
        -: 2552:					&(buffer[bufferoffset]),
        -: 2553:					samplebuffer, 
        -: 2554:					samplebufferoffset); 
    #####: 2555:				bufferoffset+=samplebufferoffset;
        -: 2556:			}
    #####: 2557:			_TIFFfree(samplebuffer);
    #####: 2558:			goto dataready;
        -: 2559:		}
        -: 2560:
    #####: 2561:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2562:		if(buffer==NULL){
    #####: 2563:			TIFFError(TIFF2PDF_MODULE, 
        -: 2564:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2565:				(unsigned long) t2p->tiff_datasize, 
        -: 2566:				TIFFFileName(input));
    #####: 2567:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2568:			return(0);
        -: 2569:		}
    #####: 2570:                memset(buffer, 0, t2p->tiff_datasize);
    #####: 2571:		stripsize=TIFFStripSize(input);
    #####: 2572:		stripcount=TIFFNumberOfStrips(input);
    #####: 2573:		for(i=0;i<stripcount;i++){
        -: 2574:			read = 
    #####: 2575:				TIFFReadEncodedStrip(input, 
        -: 2576:				i, 
    #####: 2577:				(tdata_t) &buffer[bufferoffset], 
    #####: 2578:				TIFFmin(stripsize, t2p->tiff_datasize - bufferoffset));
    #####: 2579:			if(read==-1){
    #####: 2580:				TIFFError(TIFF2PDF_MODULE, 
        -: 2581:					"Error on decoding strip %u of %s", 
        -: 2582:					i, 
        -: 2583:					TIFFFileName(input));
    #####: 2584:				_TIFFfree(samplebuffer);
    #####: 2585:				_TIFFfree(buffer);
    #####: 2586:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2587:				return(0);
        -: 2588:			}
    #####: 2589:			bufferoffset+=read;
        -: 2590:		}
        -: 2591:
    #####: 2592:		if(t2p->pdf_sample & T2P_SAMPLE_REALIZE_PALETTE){
        -: 2593:			// FIXME: overflow?
    #####: 2594:			samplebuffer=(unsigned char*)_TIFFrealloc( 
        -: 2595:				(tdata_t) buffer, 
    #####: 2596:				t2p->tiff_datasize * t2p->tiff_samplesperpixel);
    #####: 2597:			if(samplebuffer==NULL){
    #####: 2598:				TIFFError(TIFF2PDF_MODULE, 
        -: 2599:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2600:					(unsigned long) t2p->tiff_datasize, 
        -: 2601:					TIFFFileName(input));
    #####: 2602:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2603:				_TIFFfree(buffer);
    #####: 2604:				return(0);
        -: 2605:			} else {
    #####: 2606:				buffer=samplebuffer;
    #####: 2607:				t2p->tiff_datasize *= t2p->tiff_samplesperpixel;
        -: 2608:			}
    #####: 2609:			t2p_sample_realize_palette(t2p, buffer);
        -: 2610:		}
        -: 2611:
    #####: 2612:		if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
    #####: 2613:			t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
        -: 2614:				(tdata_t)buffer, 
    #####: 2615:				t2p->tiff_width*t2p->tiff_length);
        -: 2616:		}
        -: 2617:
    #####: 2618:		if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
    #####: 2619:			t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
        -: 2620:				(tdata_t)buffer, 
    #####: 2621:				t2p->tiff_width*t2p->tiff_length);
        -: 2622:		}
        -: 2623:
    #####: 2624:		if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
    #####: 2625:			samplebuffer=(unsigned char*)_TIFFrealloc(
        -: 2626:				(tdata_t)buffer, 
    #####: 2627:				t2p->tiff_width*t2p->tiff_length*4);
    #####: 2628:			if(samplebuffer==NULL){
    #####: 2629:				TIFFError(TIFF2PDF_MODULE, 
        -: 2630:	"Can't allocate %lu bytes of memory for t2p_readwrite_pdf_image, %s", 
    #####: 2631:					(unsigned long) t2p->tiff_datasize, 
        -: 2632:					TIFFFileName(input));
    #####: 2633:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2634:				_TIFFfree(buffer);
    #####: 2635:				return(0);
        -: 2636:			} else {
    #####: 2637:				buffer=samplebuffer;
        -: 2638:			}
    #####: 2639:			if(!TIFFReadRGBAImageOriented(
        -: 2640:				input, 
        -: 2641:				t2p->tiff_width, 
        -: 2642:				t2p->tiff_length, 
        -: 2643:				(uint32*)buffer, 
        -: 2644:				ORIENTATION_TOPLEFT,
        -: 2645:				0)){
    #####: 2646:				TIFFError(TIFF2PDF_MODULE, 
        -: 2647:	"Can't use TIFFReadRGBAImageOriented to extract RGB image from %s", 
        -: 2648:					TIFFFileName(input));
    #####: 2649:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2650:				return(0);
        -: 2651:			}
    #####: 2652:			t2p->tiff_datasize=t2p_sample_abgr_to_rgb(
        -: 2653:				(tdata_t) buffer, 
    #####: 2654:				t2p->tiff_width*t2p->tiff_length);
        -: 2655:
        -: 2656:		}
        -: 2657:
    #####: 2658:		if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
    #####: 2659:			t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
        -: 2660:				(tdata_t)buffer, 
    #####: 2661:				t2p->tiff_width*t2p->tiff_length);
        -: 2662:		}
        -: 2663:	}
        -: 2664:
    #####: 2665:dataready:
        -: 2666:
    #####: 2667:	t2p_disable(output);
    #####: 2668:	TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
    #####: 2669:	TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
    #####: 2670:	TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
    #####: 2671:	TIFFSetField(output, TIFFTAG_IMAGEWIDTH, t2p->tiff_width);
    #####: 2672:	TIFFSetField(output, TIFFTAG_IMAGELENGTH, t2p->tiff_length);
    #####: 2673:	TIFFSetField(output, TIFFTAG_ROWSPERSTRIP, t2p->tiff_length);
    #####: 2674:	TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    #####: 2675:	TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
        -: 2676:
    #####: 2677:	switch(t2p->pdf_compression){
    #####: 2678:	case T2P_COMPRESS_NONE:
    #####: 2679:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
    #####: 2680:		break;
        -: 2681:#ifdef CCITT_SUPPORT
    #####: 2682:	case T2P_COMPRESS_G4:
    #####: 2683:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
    #####: 2684:		break;
        -: 2685:#endif /* ifdef CCITT_SUPPORT */
        -: 2686:#ifdef JPEG_SUPPORT
    #####: 2687:	case T2P_COMPRESS_JPEG:
    #####: 2688:		if(t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {
    #####: 2689:			uint16 hor = 0, ver = 0;
    #####: 2690:			if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver) !=0 ) {
    #####: 2691:				if(hor != 0 && ver != 0){
    #####: 2692:					TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);
        -: 2693:				}
        -: 2694:			}
    #####: 2695:			if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){
    #####: 2696:				TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);
        -: 2697:			}
        -: 2698:		}
    #####: 2699:		if(TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG)==0){
    #####: 2700:			TIFFError(TIFF2PDF_MODULE, 
        -: 2701:		"Unable to use JPEG compression for input %s and output %s", 
        -: 2702:				TIFFFileName(input),
        -: 2703:				TIFFFileName(output));
    #####: 2704:			_TIFFfree(buffer);
    #####: 2705:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2706:			return(0);
        -: 2707:		}
    #####: 2708:		TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0);
        -: 2709:
    #####: 2710:		if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){
    #####: 2711:			TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    #####: 2712:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){
    #####: 2713:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
        -: 2714:			} else {
    #####: 2715:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);
        -: 2716:			}
        -: 2717:		}
    #####: 2718:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
        -: 2719:			(void)0;
        -: 2720:		}
    #####: 2721:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
        -: 2722:			(void)0;
        -: 2723:		}
    #####: 2724:		if(t2p->pdf_defaultcompressionquality != 0){
    #####: 2725:			TIFFSetField(output, 
        -: 2726:				TIFFTAG_JPEGQUALITY, 
    #####: 2727:				t2p->pdf_defaultcompressionquality);
        -: 2728:		}
        -: 2729:	
    #####: 2730:		break;
        -: 2731:#endif /* ifdef JPEG_SUPPORT */
        -: 2732:#ifdef ZIP_SUPPORT
        -: 2733:	case T2P_COMPRESS_ZIP:
        -: 2734:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
        -: 2735:		if(t2p->pdf_defaultcompressionquality%100 != 0){
        -: 2736:			TIFFSetField(output, 
        -: 2737:				TIFFTAG_PREDICTOR, 
        -: 2738:				t2p->pdf_defaultcompressionquality % 100);
        -: 2739:		}
        -: 2740:		if(t2p->pdf_defaultcompressionquality/100 != 0){
        -: 2741:			TIFFSetField(output, 
        -: 2742:				TIFFTAG_ZIPQUALITY, 
        -: 2743:				(t2p->pdf_defaultcompressionquality / 100));
        -: 2744:		}
        -: 2745:		break;
        -: 2746:#endif /* ifdef ZIP_SUPPORT */
    #####: 2747:	default:
    #####: 2748:		break;
        -: 2749:	}
        -: 2750:
    #####: 2751:	t2p_enable(output);
    #####: 2752:	t2p->outputwritten = 0;
        -: 2753:#ifdef JPEG_SUPPORT
    #####: 2754:	if(t2p->pdf_compression == T2P_COMPRESS_JPEG
    #####: 2755:	   && t2p->tiff_photometric == PHOTOMETRIC_YCBCR){
    #####: 2756:		bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,
        -: 2757:						     buffer,
        -: 2758:						     stripsize * stripcount); 
        -: 2759:	} else
        -: 2760:#endif /* ifdef JPEG_SUPPORT */
        -: 2761:        {
    #####: 2762:		bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t)0,
        -: 2763:						     buffer,
        -: 2764:						     t2p->tiff_datasize); 
        -: 2765:	}
    #####: 2766:	if (buffer != NULL) {
    #####: 2767:		_TIFFfree(buffer);
    #####: 2768:		buffer=NULL;
        -: 2769:	}
        -: 2770:
    #####: 2771:	if (bufferoffset == (tsize_t)-1) {
    #####: 2772:		TIFFError(TIFF2PDF_MODULE, 
        -: 2773:			  "Error writing encoded strip to output PDF %s", 
        -: 2774:			  TIFFFileName(output));
    #####: 2775:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2776:		return(0);
        -: 2777:	}
        -: 2778:	
    #####: 2779:	written = t2p->outputwritten;
    #####: 2780:	return(written);
        -: 2781:}
        -: 2782:
        -: 2783:/*
        -: 2784: * This function reads the raster image data from the input TIFF for an image
        -: 2785: * tile and writes the data to the output PDF XObject image dictionary stream
        -: 2786: * for the tile.  It returns the amount written or zero on error.
        -: 2787: */
        -: 2788:
        1: 2789:tsize_t t2p_readwrite_pdf_image_tile(T2P* t2p, TIFF* input, TIFF* output, ttile_t tile){
        -: 2790:
        1: 2791:	uint16 edge=0;
        1: 2792:	tsize_t written=0;
        1: 2793:	unsigned char* buffer=NULL;
        1: 2794:	tsize_t bufferoffset=0;
        1: 2795:	unsigned char* samplebuffer=NULL;
        1: 2796:	tsize_t samplebufferoffset=0;
        1: 2797:	tsize_t read=0;
        1: 2798:	uint16 i=0;
        1: 2799:	ttile_t tilecount=0;
        -: 2800:	/* tsize_t tilesize=0; */
        1: 2801:	ttile_t septilecount=0;
        1: 2802:	tsize_t septilesize=0;
        -: 2803:#ifdef JPEG_SUPPORT
        1: 2804:	unsigned char* jpt;
        1: 2805:	float* xfloatp;
        1: 2806:	uint32 xuint32=0;
        -: 2807:#endif
        -: 2808:
        -: 2809:	/* Fail if prior error (in particular, can't trust tiff_datasize) */
        1: 2810:	if (t2p->t2p_error != T2P_ERR_OK)
    #####: 2811:		return(0);
        -: 2812:
        1: 2813:	edge |= t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
        1: 2814:	edge |= t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile);
        -: 2815:
        1: 2816:	if( (t2p->pdf_transcode == T2P_TRANSCODE_RAW) && ((edge == 0)
        -: 2817:#if defined(JPEG_SUPPORT) || defined(OJPEG_SUPPORT)
        1: 2818:		|| (t2p->pdf_compression == T2P_COMPRESS_JPEG)
        -: 2819:#endif
        -: 2820:	)
        -: 2821:	){
        -: 2822:#ifdef CCITT_SUPPORT
        1: 2823:		if(t2p->pdf_compression == T2P_COMPRESS_G4){
    #####: 2824:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2825:			if(buffer==NULL){
    #####: 2826:				TIFFError(TIFF2PDF_MODULE, 
        -: 2827:					"Can't allocate %lu bytes of memory "
        -: 2828:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2829:					(unsigned long) t2p->tiff_datasize, 
        -: 2830:					TIFFFileName(input));
    #####: 2831:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2832:				return(0);
        -: 2833:			}
    #####: 2834:			TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
    #####: 2835:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
    #####: 2836:					TIFFReverseBits(buffer, t2p->tiff_datasize);
        -: 2837:			}
    #####: 2838:			t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
    #####: 2839:			_TIFFfree(buffer);
    #####: 2840:			return(t2p->tiff_datasize);
        -: 2841:		}
        -: 2842:#endif
        -: 2843:#ifdef ZIP_SUPPORT
        -: 2844:		if(t2p->pdf_compression == T2P_COMPRESS_ZIP){
        -: 2845:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
        -: 2846:			if(buffer==NULL){
        -: 2847:				TIFFError(TIFF2PDF_MODULE, 
        -: 2848:					"Can't allocate %lu bytes of memory "
        -: 2849:                                        "for t2p_readwrite_pdf_image_tile, %s", 
        -: 2850:					(unsigned long) t2p->tiff_datasize, 
        -: 2851:					TIFFFileName(input));
        -: 2852:				t2p->t2p_error = T2P_ERR_ERROR;
        -: 2853:				return(0);
        -: 2854:			}
        -: 2855:			TIFFReadRawTile(input, tile, (tdata_t) buffer, t2p->tiff_datasize);
        -: 2856:			if (t2p->tiff_fillorder==FILLORDER_LSB2MSB){
        -: 2857:					TIFFReverseBits(buffer, t2p->tiff_datasize);
        -: 2858:			}
        -: 2859:			t2pWriteFile(output, (tdata_t) buffer, t2p->tiff_datasize);
        -: 2860:			_TIFFfree(buffer);
        -: 2861:			return(t2p->tiff_datasize);
        -: 2862:		}
        -: 2863:#endif
        -: 2864:#ifdef OJPEG_SUPPORT
        1: 2865:		if(t2p->tiff_compression == COMPRESSION_OJPEG){
    #####: 2866:			if(! t2p->pdf_ojpegdata){
    #####: 2867:				TIFFError(TIFF2PDF_MODULE, 
        -: 2868:					"No support for OJPEG image %s with "
        -: 2869:                                        "bad tables", 
        -: 2870:					TIFFFileName(input));
    #####: 2871:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2872:				return(0);
        -: 2873:			}
    #####: 2874:			buffer=(unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2875:			if(buffer==NULL){
    #####: 2876:				TIFFError(TIFF2PDF_MODULE, 
        -: 2877:					"Can't allocate %lu bytes of memory "
        -: 2878:                                        "for t2p_readwrite_pdf_image, %s", 
    #####: 2879:					(unsigned long) t2p->tiff_datasize, 
        -: 2880:					TIFFFileName(input));
    #####: 2881:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2882:				return(0);
        -: 2883:			}
    #####: 2884:			_TIFFmemcpy(buffer, t2p->pdf_ojpegdata, t2p->pdf_ojpegdatalength);
    #####: 2885:			if(edge!=0){
    #####: 2886:				if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
    #####: 2887:					buffer[7]=
    #####: 2888:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength >> 8) & 0xff;
    #####: 2889:					buffer[8]=
    #####: 2890:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength ) & 0xff;
        -: 2891:				}
    #####: 2892:				if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile)){
    #####: 2893:					buffer[9]=
    #####: 2894:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth >> 8) & 0xff;
    #####: 2895:					buffer[10]=
    #####: 2896:						(t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth ) & 0xff;
        -: 2897:				}
        -: 2898:			}
    #####: 2899:			bufferoffset=t2p->pdf_ojpegdatalength;
    #####: 2900:			bufferoffset+=TIFFReadRawTile(input, 
        -: 2901:					tile, 
    #####: 2902:					(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2903:					-1);
    #####: 2904:			((unsigned char*)buffer)[bufferoffset++]=0xff;
    #####: 2905:			((unsigned char*)buffer)[bufferoffset++]=0xd9;
    #####: 2906:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2907:			_TIFFfree(buffer);
    #####: 2908:			return(bufferoffset);
        -: 2909:		}
        -: 2910:#endif
        -: 2911:#ifdef JPEG_SUPPORT
        1: 2912:		if(t2p->tiff_compression == COMPRESSION_JPEG){
        -: 2913:			unsigned char table_end[2];
        1: 2914:			uint32 count = 0;
        1: 2915:			buffer= (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
        1: 2916:			if(buffer==NULL){
    #####: 2917:				TIFFError(TIFF2PDF_MODULE, 
        -: 2918:					"Can't allocate " TIFF_SIZE_FORMAT " bytes of memory "
        -: 2919:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 2920:                                          (TIFF_SIZE_T) t2p->tiff_datasize, 
        -: 2921:					TIFFFileName(input));
    #####: 2922:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2923:				return(0);
        -: 2924:			}
        1: 2925:			if(TIFFGetField(input, TIFFTAG_JPEGTABLES, &count, &jpt) != 0) {
        1: 2926:				if (count >= 4) {
        -: 2927:                                        int retTIFFReadRawTile;
        -: 2928:                    /* Ignore EOI marker of JpegTables */
        1: 2929:					_TIFFmemcpy(buffer, jpt, count - 2);
    #####: 2930:					bufferoffset += count - 2;
        -: 2931:                    /* Store last 2 bytes of the JpegTables */
    #####: 2932:					table_end[0] = buffer[bufferoffset-2];
    #####: 2933:					table_end[1] = buffer[bufferoffset-1];
    #####: 2934:					xuint32 = bufferoffset;
    #####: 2935:                                        bufferoffset -= 2;
    #####: 2936:                                        retTIFFReadRawTile= TIFFReadRawTile(
        -: 2937:						input, 
        -: 2938:						tile, 
    #####: 2939:						(tdata_t) &(((unsigned char*)buffer)[bufferoffset]), 
        -: 2940:						-1);
    #####: 2941:                                        if( retTIFFReadRawTile < 0 )
        -: 2942:                                        {
    #####: 2943:                                            _TIFFfree(buffer);
    #####: 2944:                                            t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2945:                                            return(0);
        -: 2946:                                        }
    #####: 2947:					bufferoffset += retTIFFReadRawTile;
        -: 2948:                    /* Overwrite SOI marker of image scan with previously */
        -: 2949:                    /* saved end of JpegTables */
    #####: 2950:					buffer[xuint32-2]=table_end[0];
    #####: 2951:					buffer[xuint32-1]=table_end[1];
        -: 2952:				}
        -: 2953:			}
    #####: 2954:			t2pWriteFile(output, (tdata_t) buffer, bufferoffset);
    #####: 2955:			_TIFFfree(buffer);
    #####: 2956:			return(bufferoffset);
        -: 2957:		}
        -: 2958:#endif
        -: 2959:		(void)0;
        -: 2960:	}
        -: 2961:
    #####: 2962:	if(t2p->pdf_sample==T2P_SAMPLE_NOTHING){
    #####: 2963:		buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2964:		if(buffer==NULL){
    #####: 2965:			TIFFError(TIFF2PDF_MODULE, 
        -: 2966:				"Can't allocate %lu bytes of memory for "
        -: 2967:                                "t2p_readwrite_pdf_image_tile, %s", 
    #####: 2968:				(unsigned long) t2p->tiff_datasize, 
        -: 2969:				TIFFFileName(input));
    #####: 2970:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 2971:			return(0);
        -: 2972:		}
        -: 2973:
    #####: 2974:		read = TIFFReadEncodedTile(
        -: 2975:			input, 
        -: 2976:			tile, 
    #####: 2977:			(tdata_t) &buffer[bufferoffset], 
        -: 2978:			t2p->tiff_datasize);
    #####: 2979:		if(read==-1){
    #####: 2980:			TIFFError(TIFF2PDF_MODULE, 
        -: 2981:				"Error on decoding tile %u of %s", 
        -: 2982:				tile, 
        -: 2983:				TIFFFileName(input));
    #####: 2984:			_TIFFfree(buffer);
    #####: 2985:			t2p->t2p_error=T2P_ERR_ERROR;
    #####: 2986:			return(0);
        -: 2987:		}
        -: 2988:
        -: 2989:	} else {
        -: 2990:
    #####: 2991:		if(t2p->pdf_sample == T2P_SAMPLE_PLANAR_SEPARATE_TO_CONTIG){
    #####: 2992:			septilesize=TIFFTileSize(input);
    #####: 2993:			septilecount=TIFFNumberOfTiles(input);
        -: 2994:			/* tilesize=septilesize*t2p->tiff_samplesperpixel; */
    #####: 2995:			tilecount=septilecount/t2p->tiff_samplesperpixel;
    #####: 2996:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 2997:			if(buffer==NULL){
    #####: 2998:				TIFFError(TIFF2PDF_MODULE, 
        -: 2999:					"Can't allocate %lu bytes of memory "
        -: 3000:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 3001:					(unsigned long) t2p->tiff_datasize, 
        -: 3002:					TIFFFileName(input));
    #####: 3003:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3004:				return(0);
        -: 3005:			}
    #####: 3006:			samplebuffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 3007:			if(samplebuffer==NULL){
    #####: 3008:				TIFFError(TIFF2PDF_MODULE, 
        -: 3009:					"Can't allocate %lu bytes of memory "
        -: 3010:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 3011:					(unsigned long) t2p->tiff_datasize, 
        -: 3012:					TIFFFileName(input));
    #####: 3013:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3014:				return(0);
        -: 3015:			}
    #####: 3016:			samplebufferoffset=0;
    #####: 3017:			for(i=0;i<t2p->tiff_samplesperpixel;i++){
        -: 3018:				read = 
    #####: 3019:					TIFFReadEncodedTile(input, 
    #####: 3020:						tile + i*tilecount, 
    #####: 3021:						(tdata_t) &(samplebuffer[samplebufferoffset]), 
        -: 3022:						septilesize);
    #####: 3023:				if(read==-1){
    #####: 3024:					TIFFError(TIFF2PDF_MODULE, 
        -: 3025:						"Error on decoding tile %u of %s", 
    #####: 3026:						tile + i*tilecount, 
        -: 3027:						TIFFFileName(input));
    #####: 3028:						_TIFFfree(samplebuffer);
    #####: 3029:						_TIFFfree(buffer);
    #####: 3030:					t2p->t2p_error=T2P_ERR_ERROR;
    #####: 3031:					return(0);
        -: 3032:				}
    #####: 3033:				samplebufferoffset+=read;
        -: 3034:			}
    #####: 3035:			t2p_sample_planar_separate_to_contig(
        -: 3036:				t2p,
        -: 3037:				&(buffer[bufferoffset]),
        -: 3038:				samplebuffer, 
        -: 3039:				samplebufferoffset); 
    #####: 3040:			bufferoffset+=samplebufferoffset;
    #####: 3041:			_TIFFfree(samplebuffer);
        -: 3042:		}
        -: 3043:
    #####: 3044:		if(buffer==NULL){
    #####: 3045:			buffer = (unsigned char*) _TIFFmalloc(t2p->tiff_datasize);
    #####: 3046:			if(buffer==NULL){
    #####: 3047:				TIFFError(TIFF2PDF_MODULE, 
        -: 3048:					"Can't allocate %lu bytes of memory "
        -: 3049:                                        "for t2p_readwrite_pdf_image_tile, %s", 
    #####: 3050:					(unsigned long) t2p->tiff_datasize, 
        -: 3051:					TIFFFileName(input));
    #####: 3052:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3053:				return(0);
        -: 3054:			}
    #####: 3055:			read = TIFFReadEncodedTile(
        -: 3056:				input, 
        -: 3057:				tile, 
    #####: 3058:				(tdata_t) &buffer[bufferoffset], 
        -: 3059:				t2p->tiff_datasize);
    #####: 3060:			if(read==-1){
    #####: 3061:				TIFFError(TIFF2PDF_MODULE, 
        -: 3062:					"Error on decoding tile %u of %s", 
        -: 3063:					tile, 
        -: 3064:					TIFFFileName(input));
    #####: 3065:				_TIFFfree(buffer);
    #####: 3066:				t2p->t2p_error=T2P_ERR_ERROR;
    #####: 3067:				return(0);
        -: 3068:			}
        -: 3069:		}
        -: 3070:
    #####: 3071:		if(t2p->pdf_sample & T2P_SAMPLE_RGBA_TO_RGB){
    #####: 3072:			t2p->tiff_datasize=t2p_sample_rgba_to_rgb(
        -: 3073:				(tdata_t)buffer, 
    #####: 3074:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3075:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3076:		}
        -: 3077:
    #####: 3078:		if(t2p->pdf_sample & T2P_SAMPLE_RGBAA_TO_RGB){
    #####: 3079:			t2p->tiff_datasize=t2p_sample_rgbaa_to_rgb(
        -: 3080:				(tdata_t)buffer, 
    #####: 3081:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3082:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3083:		}
        -: 3084:
    #####: 3085:		if(t2p->pdf_sample & T2P_SAMPLE_YCBCR_TO_RGB){
    #####: 3086:			TIFFError(TIFF2PDF_MODULE, 
        -: 3087:				"No support for YCbCr to RGB in tile for %s", 
        -: 3088:				TIFFFileName(input));
    #####: 3089:			_TIFFfree(buffer);
    #####: 3090:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3091:			return(0);
        -: 3092:		}
        -: 3093:
    #####: 3094:		if(t2p->pdf_sample & T2P_SAMPLE_LAB_SIGNED_TO_UNSIGNED){
    #####: 3095:			t2p->tiff_datasize=t2p_sample_lab_signed_to_unsigned(
        -: 3096:				(tdata_t)buffer, 
    #####: 3097:				t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth
    #####: 3098:				*t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3099:		}
        -: 3100:	}
        -: 3101:
    #####: 3102:	if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) != 0){
    #####: 3103:		t2p_tile_collapse_left(
        -: 3104:			buffer, 
        -: 3105:			TIFFTileRowSize(input),
    #####: 3106:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth,
    #####: 3107:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth, 
    #####: 3108:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3109:	}
        -: 3110:
        -: 3111:
    #####: 3112:	t2p_disable(output);
    #####: 3113:	TIFFSetField(output, TIFFTAG_PHOTOMETRIC, t2p->tiff_photometric);
    #####: 3114:	TIFFSetField(output, TIFFTAG_BITSPERSAMPLE, t2p->tiff_bitspersample);
    #####: 3115:	TIFFSetField(output, TIFFTAG_SAMPLESPERPIXEL, t2p->tiff_samplesperpixel);
    #####: 3116:	if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
    #####: 3117:		TIFFSetField(
        -: 3118:			output, 
        -: 3119:			TIFFTAG_IMAGEWIDTH, 
    #####: 3120:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
        -: 3121:	} else {
    #####: 3122:		TIFFSetField(
        -: 3123:			output, 
        -: 3124:			TIFFTAG_IMAGEWIDTH, 
    #####: 3125:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
        -: 3126:	}
    #####: 3127:	if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile) == 0){
    #####: 3128:		TIFFSetField(
        -: 3129:			output, 
        -: 3130:			TIFFTAG_IMAGELENGTH, 
    #####: 3131:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
    #####: 3132:		TIFFSetField(
        -: 3133:			output, 
        -: 3134:			TIFFTAG_ROWSPERSTRIP, 
    #####: 3135:			t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 3136:	} else {
    #####: 3137:		TIFFSetField(
        -: 3138:			output, 
        -: 3139:			TIFFTAG_IMAGELENGTH, 
    #####: 3140:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
    #####: 3141:		TIFFSetField(
        -: 3142:			output, 
        -: 3143:			TIFFTAG_ROWSPERSTRIP, 
    #####: 3144:			t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
        -: 3145:	}
    #####: 3146:	TIFFSetField(output, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
    #####: 3147:	TIFFSetField(output, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
        -: 3148:
    #####: 3149:	switch(t2p->pdf_compression){
    #####: 3150:	case T2P_COMPRESS_NONE:
    #####: 3151:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_NONE);
    #####: 3152:		break;
        -: 3153:#ifdef CCITT_SUPPORT
    #####: 3154:	case T2P_COMPRESS_G4:
    #####: 3155:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_CCITTFAX4);
    #####: 3156:		break;
        -: 3157:#endif
        -: 3158:#ifdef JPEG_SUPPORT
    #####: 3159:	case T2P_COMPRESS_JPEG:
    #####: 3160:		if (t2p->tiff_photometric==PHOTOMETRIC_YCBCR) {
    #####: 3161:			uint16 hor = 0, ver = 0;
    #####: 3162:			if (TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &hor, &ver)!=0) {
    #####: 3163:				if (hor != 0 && ver != 0) {
    #####: 3164:					TIFFSetField(output, TIFFTAG_YCBCRSUBSAMPLING, hor, ver);
        -: 3165:				}
        -: 3166:			}
    #####: 3167:			if(TIFFGetField(input, TIFFTAG_REFERENCEBLACKWHITE, &xfloatp)!=0){
    #####: 3168:				TIFFSetField(output, TIFFTAG_REFERENCEBLACKWHITE, xfloatp);
        -: 3169:			}
        -: 3170:		}
    #####: 3171:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);
    #####: 3172:		TIFFSetField(output, TIFFTAG_JPEGTABLESMODE, 0); /* JPEGTABLESMODE_NONE */
    #####: 3173:		if(t2p->pdf_colorspace & (T2P_CS_RGB | T2P_CS_LAB)){
    #####: 3174:			TIFFSetField(output, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
    #####: 3175:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR){
    #####: 3176:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
        -: 3177:			} else {
    #####: 3178:				TIFFSetField(output, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RAW);
        -: 3179:			}
        -: 3180:		}
    #####: 3181:		if(t2p->pdf_colorspace & T2P_CS_GRAY){
        -: 3182:			(void)0;
        -: 3183:		}
    #####: 3184:		if(t2p->pdf_colorspace & T2P_CS_CMYK){
        -: 3185:			(void)0;
        -: 3186:		}
    #####: 3187:		if(t2p->pdf_defaultcompressionquality != 0){
    #####: 3188:			TIFFSetField(output, 
        -: 3189:				TIFFTAG_JPEGQUALITY, 
    #####: 3190:				t2p->pdf_defaultcompressionquality);
        -: 3191:		}
    #####: 3192:		break;
        -: 3193:#endif
        -: 3194:#ifdef ZIP_SUPPORT
        -: 3195:	case T2P_COMPRESS_ZIP:
        -: 3196:		TIFFSetField(output, TIFFTAG_COMPRESSION, COMPRESSION_DEFLATE);
        -: 3197:		if(t2p->pdf_defaultcompressionquality%100 != 0){
        -: 3198:			TIFFSetField(output, 
        -: 3199:				TIFFTAG_PREDICTOR, 
        -: 3200:				t2p->pdf_defaultcompressionquality % 100);
        -: 3201:		}
        -: 3202:		if(t2p->pdf_defaultcompressionquality/100 != 0){
        -: 3203:			TIFFSetField(output, 
        -: 3204:				TIFFTAG_ZIPQUALITY, 
        -: 3205:				(t2p->pdf_defaultcompressionquality / 100));
        -: 3206:		}
        -: 3207:		break;
        -: 3208:#endif
    #####: 3209:	default:
    #####: 3210:		break;
        -: 3211:	}
        -: 3212:
    #####: 3213:	t2p_enable(output);
    #####: 3214:	t2p->outputwritten = 0;
    #####: 3215:	bufferoffset = TIFFWriteEncodedStrip(output, (tstrip_t) 0, buffer,
        -: 3216:					     TIFFStripSize(output)); 
    #####: 3217:	if (buffer != NULL) {
    #####: 3218:		_TIFFfree(buffer);
    #####: 3219:		buffer = NULL;
        -: 3220:	}
    #####: 3221:	if (bufferoffset == -1) {
    #####: 3222:		TIFFError(TIFF2PDF_MODULE, 
        -: 3223:			  "Error writing encoded tile to output PDF %s", 
        -: 3224:			  TIFFFileName(output));
    #####: 3225:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3226:		return(0);
        -: 3227:	}
        -: 3228:	
    #####: 3229:	written = t2p->outputwritten;
        -: 3230:	
    #####: 3231:	return(written);
        -: 3232:}
        -: 3233:
        -: 3234:#ifdef OJPEG_SUPPORT
    #####: 3235:int t2p_process_ojpeg_tables(T2P* t2p, TIFF* input){
    #####: 3236:	uint16 proc=0;
    #####: 3237:	void* q;
    #####: 3238:	uint32 q_length=0;
    #####: 3239:	void* dc;
    #####: 3240:	uint32 dc_length=0;
    #####: 3241:	void* ac;
    #####: 3242:	uint32 ac_length=0;
    #####: 3243:	uint16* lp;
    #####: 3244:	uint16* pt;
    #####: 3245:	uint16 h_samp=1;
    #####: 3246:	uint16 v_samp=1;
        -: 3247:	unsigned char* ojpegdata;
        -: 3248:	uint16 table_count;
        -: 3249:	uint32 offset_table;
        -: 3250:	uint32 offset_ms_l;
        -: 3251:	uint32 code_count;
    #####: 3252:	uint32 i=0;
    #####: 3253:	uint32 dest=0;
    #####: 3254:	uint16 ri=0;
    #####: 3255:	uint32 rows=0;
        -: 3256:	
    #####: 3257:	if(!TIFFGetField(input, TIFFTAG_JPEGPROC, &proc)){
    #####: 3258:		TIFFError(TIFF2PDF_MODULE, 
        -: 3259:			"Missing JPEGProc field in OJPEG image %s", 
        -: 3260:			TIFFFileName(input));
    #####: 3261:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3262:		return(0);
        -: 3263:	}
    #####: 3264:	if(proc!=JPEGPROC_BASELINE && proc!=JPEGPROC_LOSSLESS){
    #####: 3265:		TIFFError(TIFF2PDF_MODULE, 
        -: 3266:			"Bad JPEGProc field in OJPEG image %s", 
        -: 3267:			TIFFFileName(input));
    #####: 3268:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3269:		return(0);
        -: 3270:	}
    #####: 3271:	if(!TIFFGetField(input, TIFFTAG_JPEGQTABLES, &q_length, &q)){
    #####: 3272:		TIFFError(TIFF2PDF_MODULE, 
        -: 3273:			"Missing JPEGQTables field in OJPEG image %s", 
        -: 3274:			TIFFFileName(input));
    #####: 3275:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3276:		return(0);
        -: 3277:	}
    #####: 3278:	if(q_length < (64U * t2p->tiff_samplesperpixel)){
    #####: 3279:		TIFFError(TIFF2PDF_MODULE, 
        -: 3280:			"Bad JPEGQTables field in OJPEG image %s", 
        -: 3281:			TIFFFileName(input));
    #####: 3282:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3283:		return(0);
        -: 3284:	} 
    #####: 3285:	if(!TIFFGetField(input, TIFFTAG_JPEGDCTABLES, &dc_length, &dc)){
    #####: 3286:		TIFFError(TIFF2PDF_MODULE, 
        -: 3287:			"Missing JPEGDCTables field in OJPEG image %s", 
        -: 3288:			TIFFFileName(input));
    #####: 3289:			t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3290:		return(0);
        -: 3291:	}
    #####: 3292:	if(proc==JPEGPROC_BASELINE){
    #####: 3293:		if(!TIFFGetField(input, TIFFTAG_JPEGACTABLES, &ac_length, &ac)){
    #####: 3294:			TIFFError(TIFF2PDF_MODULE, 
        -: 3295:				"Missing JPEGACTables field in OJPEG image %s", 
        -: 3296:				TIFFFileName(input));
    #####: 3297:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3298:			return(0);
        -: 3299:		}
        -: 3300:	} else {
    #####: 3301:		if(!TIFFGetField(input, TIFFTAG_JPEGLOSSLESSPREDICTORS, &lp)){
    #####: 3302:			TIFFError(TIFF2PDF_MODULE, 
        -: 3303:				"Missing JPEGLosslessPredictors field in OJPEG image %s", 
        -: 3304:				TIFFFileName(input));
    #####: 3305:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3306:				return(0);
        -: 3307:		}
    #####: 3308:		if(!TIFFGetField(input, TIFFTAG_JPEGPOINTTRANSFORM, &pt)){
    #####: 3309:			TIFFError(TIFF2PDF_MODULE, 
        -: 3310:				"Missing JPEGPointTransform field in OJPEG image %s", 
        -: 3311:				TIFFFileName(input));
    #####: 3312:				t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3313:			return(0);
        -: 3314:		}
        -: 3315:	}
    #####: 3316:	if(!TIFFGetField(input, TIFFTAG_YCBCRSUBSAMPLING, &h_samp, &v_samp)){
    #####: 3317:		h_samp=1;
    #####: 3318:		v_samp=1;
        -: 3319:	}
    #####: 3320:	if(t2p->pdf_ojpegdata != NULL){
    #####: 3321:		_TIFFfree(t2p->pdf_ojpegdata);
    #####: 3322:		t2p->pdf_ojpegdata=NULL;
        -: 3323:	} 
    #####: 3324:	t2p->pdf_ojpegdata = _TIFFmalloc(2048);
    #####: 3325:	if(t2p->pdf_ojpegdata == NULL){
    #####: 3326:		TIFFError(TIFF2PDF_MODULE, 
        -: 3327:			"Can't allocate %u bytes of memory for t2p_process_ojpeg_tables, %s", 
        -: 3328:			2048, 
        -: 3329:			TIFFFileName(input));
    #####: 3330:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3331:		return(0);
        -: 3332:	}
    #####: 3333:	_TIFFmemset(t2p->pdf_ojpegdata, 0x00, 2048);
    #####: 3334:	t2p->pdf_ojpegdatalength = 0;
    #####: 3335:	table_count=t2p->tiff_samplesperpixel;
    #####: 3336:	if(proc==JPEGPROC_BASELINE){
    #####: 3337:		if(table_count>2) table_count=2;
        -: 3338:	}
    #####: 3339:	ojpegdata=(unsigned char*)t2p->pdf_ojpegdata;
    #####: 3340:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3341:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xd8;
    #####: 3342:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3343:	if(proc==JPEGPROC_BASELINE){
    #####: 3344:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc0;
        -: 3345:	} else {
    #####: 3346:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc3;
        -: 3347:	}
    #####: 3348:	ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3349:	ojpegdata[t2p->pdf_ojpegdatalength++]=(8 + 3*t2p->tiff_samplesperpixel);
    #####: 3350:	ojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_bitspersample & 0xff);
    #####: 3351:	if(TIFFIsTiled(input)){
    #####: 3352:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3353:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength >> 8) & 0xff;
    #####: 3354:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3355:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength ) & 0xff;
    #####: 3356:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3357:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth >> 8) & 0xff;
    #####: 3358:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3359:			(t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth ) & 0xff;
        -: 3360:	} else {
    #####: 3361:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3362:			(t2p->tiff_length >> 8) & 0xff;
    #####: 3363:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3364:			(t2p->tiff_length ) & 0xff;
    #####: 3365:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3366:			(t2p->tiff_width >> 8) & 0xff;
    #####: 3367:		ojpegdata[t2p->pdf_ojpegdatalength++]=
    #####: 3368:			(t2p->tiff_width ) & 0xff;
        -: 3369:	}
    #####: 3370:	ojpegdata[t2p->pdf_ojpegdatalength++]=(t2p->tiff_samplesperpixel & 0xff);
    #####: 3371:	for(i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 3372:		ojpegdata[t2p->pdf_ojpegdatalength++]=i;
    #####: 3373:		if(i==0){
    #####: 3374:			ojpegdata[t2p->pdf_ojpegdatalength] |= h_samp<<4 & 0xf0;;
    #####: 3375:			ojpegdata[t2p->pdf_ojpegdatalength++] |= v_samp & 0x0f;
        -: 3376:		} else {
    #####: 3377:				ojpegdata[t2p->pdf_ojpegdatalength++]= 0x11;
        -: 3378:		}
    #####: 3379:		ojpegdata[t2p->pdf_ojpegdatalength++]=i;
        -: 3380:	}
    #####: 3381:	for(dest=0;dest<t2p->tiff_samplesperpixel;dest++){
    #####: 3382:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3383:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xdb;
    #####: 3384:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3385:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x43;
    #####: 3386:		ojpegdata[t2p->pdf_ojpegdatalength++]=dest;
    #####: 3387:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength++]), 
    #####: 3388:			&(((unsigned char*)q)[64*dest]), 64);
    #####: 3389:		t2p->pdf_ojpegdatalength+=64;
        -: 3390:	}
    #####: 3391:	offset_table=0;
    #####: 3392:	for(dest=0;dest<table_count;dest++){
    #####: 3393:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3394:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;
    #####: 3395:		offset_ms_l=t2p->pdf_ojpegdatalength;
    #####: 3396:		t2p->pdf_ojpegdatalength+=2;
    #####: 3397:		ojpegdata[t2p->pdf_ojpegdatalength++]=dest & 0x0f;
    #####: 3398:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3399:			&(((unsigned char*)dc)[offset_table]), 16);
    #####: 3400:		code_count=0;
    #####: 3401:		offset_table+=16;
    #####: 3402:		for(i=0;i<16;i++){
    #####: 3403:			code_count+=ojpegdata[t2p->pdf_ojpegdatalength++];
        -: 3404:		}
    #####: 3405:		ojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;
    #####: 3406:		ojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;
    #####: 3407:		_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3408:			&(((unsigned char*)dc)[offset_table]), code_count);
    #####: 3409:		offset_table+=code_count;
    #####: 3410:		t2p->pdf_ojpegdatalength+=code_count;
        -: 3411:	}
    #####: 3412:	if(proc==JPEGPROC_BASELINE){
    #####: 3413:	offset_table=0;
    #####: 3414:		for(dest=0;dest<table_count;dest++){
    #####: 3415:			ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3416:			ojpegdata[t2p->pdf_ojpegdatalength++]=0xc4;
    #####: 3417:			offset_ms_l=t2p->pdf_ojpegdatalength;
    #####: 3418:			t2p->pdf_ojpegdatalength+=2;
    #####: 3419:			ojpegdata[t2p->pdf_ojpegdatalength] |= 0x10;
    #####: 3420:			ojpegdata[t2p->pdf_ojpegdatalength++] |=dest & 0x0f;
    #####: 3421:			_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3422:				&(((unsigned char*)ac)[offset_table]), 16);
    #####: 3423:			code_count=0;
    #####: 3424:			offset_table+=16;
    #####: 3425:			for(i=0;i<16;i++){
    #####: 3426:				code_count+=ojpegdata[t2p->pdf_ojpegdatalength++];
        -: 3427:			}	
    #####: 3428:			ojpegdata[offset_ms_l]=((19+code_count)>>8) & 0xff;
    #####: 3429:			ojpegdata[offset_ms_l+1]=(19+code_count) & 0xff;
    #####: 3430:			_TIFFmemcpy( &(ojpegdata[t2p->pdf_ojpegdatalength]), 
    #####: 3431:				&(((unsigned char*)ac)[offset_table]), code_count);
    #####: 3432:			offset_table+=code_count;
    #####: 3433:			t2p->pdf_ojpegdatalength+=code_count;
        -: 3434:		}
        -: 3435:	}
    #####: 3436:	if(TIFFNumberOfStrips(input)>1){
    #####: 3437:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3438:		ojpegdata[t2p->pdf_ojpegdatalength++]=0xdd;
    #####: 3439:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3440:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x04;
    #####: 3441:		h_samp*=8;
    #####: 3442:		v_samp*=8;
    #####: 3443:		ri=(t2p->tiff_width+h_samp-1) / h_samp;
    #####: 3444:		TIFFGetField(input, TIFFTAG_ROWSPERSTRIP, &rows);
    #####: 3445:		ri*=(rows+v_samp-1)/v_samp;
    #####: 3446:		ojpegdata[t2p->pdf_ojpegdatalength++]= (ri>>8) & 0xff;
    #####: 3447:		ojpegdata[t2p->pdf_ojpegdatalength++]= ri & 0xff;
        -: 3448:	}
    #####: 3449:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xff;
    #####: 3450:	ojpegdata[t2p->pdf_ojpegdatalength++]=0xda;
    #####: 3451:	ojpegdata[t2p->pdf_ojpegdatalength++]=0x00;
    #####: 3452:	ojpegdata[t2p->pdf_ojpegdatalength++]=(6 + 2*t2p->tiff_samplesperpixel);
    #####: 3453:	ojpegdata[t2p->pdf_ojpegdatalength++]=t2p->tiff_samplesperpixel & 0xff;
    #####: 3454:	for(i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 3455:		ojpegdata[t2p->pdf_ojpegdatalength++]= i & 0xff;
    #####: 3456:		if(proc==JPEGPROC_BASELINE){
    #####: 3457:			ojpegdata[t2p->pdf_ojpegdatalength] |= 
    #####: 3458:				( ( (i>(table_count-1U)) ? (table_count-1U) : i) << 4U) & 0xf0;
    #####: 3459:			ojpegdata[t2p->pdf_ojpegdatalength++] |= 
    #####: 3460:				( (i>(table_count-1U)) ? (table_count-1U) : i) & 0x0f;
        -: 3461:		} else {
    #####: 3462:			ojpegdata[t2p->pdf_ojpegdatalength++] =  (i << 4) & 0xf0;
        -: 3463:		}
        -: 3464:	}
    #####: 3465:	if(proc==JPEGPROC_BASELINE){
    #####: 3466:		t2p->pdf_ojpegdatalength++;
    #####: 3467:		ojpegdata[t2p->pdf_ojpegdatalength++]=0x3f;
    #####: 3468:		t2p->pdf_ojpegdatalength++;
        -: 3469:	} else {
    #####: 3470:		ojpegdata[t2p->pdf_ojpegdatalength++]= (lp[0] & 0xff);
    #####: 3471:		t2p->pdf_ojpegdatalength++;
    #####: 3472:		ojpegdata[t2p->pdf_ojpegdatalength++]= (pt[0] & 0x0f);
        -: 3473:	}
        -: 3474:
    #####: 3475:	return(1);
        -: 3476:}
        -: 3477:#endif
        -: 3478:
        -: 3479:#ifdef JPEG_SUPPORT
    #####: 3480:int t2p_process_jpeg_strip(
        -: 3481:	unsigned char* strip, 
        -: 3482:	tsize_t* striplength, 
        -: 3483:	unsigned char* buffer, 
        -: 3484:    tsize_t buffersize,
        -: 3485:	tsize_t* bufferoffset, 
        -: 3486:	tstrip_t no, 
        -: 3487:	uint32 height){
        -: 3488:
    #####: 3489:	tsize_t i=0;
        -: 3490:
    #####: 3491:	while (i < *striplength) {
        -: 3492:		tsize_t datalen;
        -: 3493:		uint16 ri;
        -: 3494:		uint16 v_samp;
        -: 3495:		uint16 h_samp;
        -: 3496:		int j;
        -: 3497:		int ncomp;
        -: 3498:
        -: 3499:		/* marker header: one or more FFs */
    #####: 3500:		if (strip[i] != 0xff)
    #####: 3501:			return(0);
    #####: 3502:		i++;
    #####: 3503:		while (i < *striplength && strip[i] == 0xff)
    #####: 3504:			i++;
    #####: 3505:		if (i >= *striplength)
    #####: 3506:			return(0);
        -: 3507:		/* SOI is the only pre-SOS marker without a length word */
    #####: 3508:		if (strip[i] == 0xd8)
    #####: 3509:			datalen = 0;
        -: 3510:		else {
    #####: 3511:			if ((*striplength - i) <= 2)
    #####: 3512:				return(0);
    #####: 3513:			datalen = (strip[i+1] << 8) | strip[i+2];
    #####: 3514:			if (datalen < 2 || datalen >= (*striplength - i))
    #####: 3515:				return(0);
        -: 3516:		}
    #####: 3517:		switch( strip[i] ){
    #####: 3518:			case 0xd8:	/* SOI - start of image */
    #####: 3519:                if( *bufferoffset + 2 > buffersize )
    #####: 3520:                    return(0);
    #####: 3521:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), 2);
    #####: 3522:				*bufferoffset+=2;
    #####: 3523:				break;
    #####: 3524:			case 0xc0:	/* SOF0 */
        -: 3525:			case 0xc1:	/* SOF1 */
        -: 3526:			case 0xc3:	/* SOF3 */
        -: 3527:			case 0xc9:	/* SOF9 */
        -: 3528:			case 0xca:	/* SOF10 */
    #####: 3529:				if(no==0){
    #####: 3530:                    if( *bufferoffset + datalen + 2 + 6 > buffersize )
    #####: 3531:                        return(0);
    #####: 3532:					_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3533:                    if( *bufferoffset + 9 >= buffersize )
    #####: 3534:                        return(0);
    #####: 3535:					ncomp = buffer[*bufferoffset+9];
    #####: 3536:					if (ncomp < 1 || ncomp > 4)
    #####: 3537:						return(0);
    #####: 3538:					v_samp=1;
    #####: 3539:					h_samp=1;
    #####: 3540:                    if( *bufferoffset + 11 + 3*(ncomp-1) >= buffersize )
    #####: 3541:                        return(0);
    #####: 3542:					for(j=0;j<ncomp;j++){
    #####: 3543:						uint16 samp = buffer[*bufferoffset+11+(3*j)];
    #####: 3544:						if( (samp>>4) > h_samp) 
    #####: 3545:							h_samp = (samp>>4);
    #####: 3546:						if( (samp & 0x0f) > v_samp) 
    #####: 3547:							v_samp = (samp & 0x0f);
        -: 3548:					}
    #####: 3549:					v_samp*=8;
    #####: 3550:					h_samp*=8;
    #####: 3551:					ri=((( ((uint16)(buffer[*bufferoffset+5])<<8) | 
    #####: 3552:					(uint16)(buffer[*bufferoffset+6]) )+v_samp-1)/ 
        -: 3553:					v_samp);
    #####: 3554:					ri*=((( ((uint16)(buffer[*bufferoffset+7])<<8) | 
    #####: 3555:					(uint16)(buffer[*bufferoffset+8]) )+h_samp-1)/ 
        -: 3556:					h_samp);
    #####: 3557:					buffer[*bufferoffset+5]=
    #####: 3558:                                          (unsigned char) ((height>>8) & 0xff);
    #####: 3559:					buffer[*bufferoffset+6]=
    #####: 3560:                                            (unsigned char) (height & 0xff);
    #####: 3561:					*bufferoffset+=datalen+2;
        -: 3562:					/* insert a DRI marker */
    #####: 3563:					buffer[(*bufferoffset)++]=0xff;
    #####: 3564:					buffer[(*bufferoffset)++]=0xdd;
    #####: 3565:					buffer[(*bufferoffset)++]=0x00;
    #####: 3566:					buffer[(*bufferoffset)++]=0x04;
    #####: 3567:					buffer[(*bufferoffset)++]=(ri >> 8) & 0xff;
    #####: 3568:					buffer[(*bufferoffset)++]= ri & 0xff;
        -: 3569:				}
    #####: 3570:				break;
    #####: 3571:			case 0xc4: /* DHT */
        -: 3572:			case 0xdb: /* DQT */
    #####: 3573:                if( *bufferoffset + datalen + 2 > buffersize )
    #####: 3574:                    return(0);
    #####: 3575:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3576:				*bufferoffset+=datalen+2;
    #####: 3577:				break;
    #####: 3578:			case 0xda: /* SOS */
    #####: 3579:				if(no==0){
    #####: 3580:                    if( *bufferoffset + datalen + 2 > buffersize )
    #####: 3581:                        return(0);
    #####: 3582:					_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i-1]), datalen+2);
    #####: 3583:					*bufferoffset+=datalen+2;
        -: 3584:				} else {
    #####: 3585:                    if( *bufferoffset + 2 > buffersize )
    #####: 3586:                        return(0);
    #####: 3587:					buffer[(*bufferoffset)++]=0xff;
    #####: 3588:					buffer[(*bufferoffset)++]=
    #####: 3589:                                            (unsigned char)(0xd0 | ((no-1)%8));
        -: 3590:				}
    #####: 3591:				i += datalen + 1;
        -: 3592:				/* copy remainder of strip */
    #####: 3593:                if( *bufferoffset + *striplength - i > buffersize )
    #####: 3594:                    return(0);
    #####: 3595:				_TIFFmemcpy(&(buffer[*bufferoffset]), &(strip[i]), *striplength - i);
    #####: 3596:				*bufferoffset+= *striplength - i;
    #####: 3597:				return(1);
    #####: 3598:			default:
        -: 3599:				/* ignore any other marker */
    #####: 3600:				break;
        -: 3601:		}
    #####: 3602:		i += datalen + 1;
        -: 3603:	}
        -: 3604:
        -: 3605:	/* failed to find SOS marker */
    #####: 3606:	return(0);
        -: 3607:}
        -: 3608:#endif
        -: 3609:
        -: 3610:/*
        -: 3611:	This functions converts a tilewidth x tilelength buffer of samples into an edgetilewidth x 
        -: 3612:	tilelength buffer of samples.
        -: 3613:*/
    #####: 3614:void t2p_tile_collapse_left(
        -: 3615:	tdata_t buffer, 
        -: 3616:	tsize_t scanwidth, 
        -: 3617:	uint32 tilewidth, 
        -: 3618:	uint32 edgetilewidth, 
        -: 3619:	uint32 tilelength){
        -: 3620:	
        -: 3621:	uint32 i;
    #####: 3622:	tsize_t edgescanwidth=0;
        -: 3623:	
    #####: 3624:	edgescanwidth = (scanwidth * edgetilewidth + (tilewidth - 1))/ tilewidth;
    #####: 3625:	for(i=0;i<tilelength;i++){
        -: 3626:                /* We use memmove() since there can be overlaps in src and dst buffers for the first items */
    #####: 3627:		memmove( 
    #####: 3628:			&(((char*)buffer)[edgescanwidth*i]), 
    #####: 3629:			&(((char*)buffer)[scanwidth*i]), 
        -: 3630:			edgescanwidth);
        -: 3631:	}
        -: 3632:	
    #####: 3633:	return;
        -: 3634:}
        -: 3635:
        -: 3636:
        -: 3637:/*
        -: 3638: * This function calls TIFFWriteDirectory on the output after blanking its
        -: 3639: * output by replacing the read, write, and seek procedures with empty
        -: 3640: * implementations, then it replaces the original implementations.
        -: 3641: */
        -: 3642:
        -: 3643:void
    #####: 3644:t2p_write_advance_directory(T2P* t2p, TIFF* output)
        -: 3645:{
    #####: 3646:	t2p_disable(output);
    #####: 3647:	if(!TIFFWriteDirectory(output)){
    #####: 3648:		TIFFError(TIFF2PDF_MODULE, 
        -: 3649:			"Error writing virtual directory to output PDF %s", 
        -: 3650:			TIFFFileName(output));
    #####: 3651:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3652:		return;
        -: 3653:	}
    #####: 3654:	t2p_enable(output);
    #####: 3655:	return;
        -: 3656:}
        -: 3657:
    #####: 3658:tsize_t t2p_sample_planar_separate_to_contig(
        -: 3659:											T2P* t2p, 
        -: 3660:											unsigned char* buffer, 
        -: 3661:											unsigned char* samplebuffer, 
        -: 3662:											tsize_t samplebuffersize){
        -: 3663:
    #####: 3664:	tsize_t stride=0;
    #####: 3665:	tsize_t i=0;
    #####: 3666:	tsize_t j=0;
        -: 3667:	
    #####: 3668:	stride=samplebuffersize/t2p->tiff_samplesperpixel;
    #####: 3669:	for(i=0;i<stride;i++){
    #####: 3670:		for(j=0;j<t2p->tiff_samplesperpixel;j++){
    #####: 3671:			buffer[i*t2p->tiff_samplesperpixel + j] = samplebuffer[i + j*stride];
        -: 3672:		}
        -: 3673:	}
        -: 3674:
    #####: 3675:	return(samplebuffersize);
        -: 3676:}
        -: 3677:
    #####: 3678:tsize_t t2p_sample_realize_palette(T2P* t2p, unsigned char* buffer){
        -: 3679:
    #####: 3680:	uint32 sample_count=0;
    #####: 3681:	uint16 component_count=0;
    #####: 3682:	uint32 palette_offset=0;
    #####: 3683:	uint32 sample_offset=0;
    #####: 3684:	uint32 i=0;
    #####: 3685:	uint32 j=0;
    #####: 3686:	sample_count=t2p->tiff_width*t2p->tiff_length;
    #####: 3687:	component_count=t2p->tiff_samplesperpixel;
    #####: 3688:        if( sample_count * component_count > t2p->tiff_datasize )
        -: 3689:        {
    #####: 3690:            TIFFError(TIFF2PDF_MODULE,  "Error: sample_count * component_count > t2p->tiff_datasize");
    #####: 3691:            t2p->t2p_error = T2P_ERR_ERROR;
    #####: 3692:            return 1;
        -: 3693:        }
        -: 3694:	
    #####: 3695:	for(i=sample_count;i>0;i--){
    #####: 3696:		palette_offset=buffer[i-1] * component_count;
    #####: 3697:		sample_offset= (i-1) * component_count;
    #####: 3698:		for(j=0;j<component_count;j++){
    #####: 3699:			buffer[sample_offset+j]=t2p->pdf_palette[palette_offset+j];
        -: 3700:		}
        -: 3701:	}
        -: 3702:
    #####: 3703:	return(0);
        -: 3704:}
        -: 3705:
        -: 3706:/*
        -: 3707:	This functions converts in place a buffer of ABGR interleaved data
        -: 3708:	into RGB interleaved data, discarding A.
        -: 3709:*/
        -: 3710:
    #####: 3711:tsize_t t2p_sample_abgr_to_rgb(tdata_t data, uint32 samplecount)
        -: 3712:{
    #####: 3713:	uint32 i=0;
    #####: 3714:	uint32 sample=0;
        -: 3715:	
    #####: 3716:	for(i=0;i<samplecount;i++){
    #####: 3717:		sample=((uint32*)data)[i];
    #####: 3718:		((char*)data)[i*3]= (char) (sample & 0xff);
    #####: 3719:		((char*)data)[i*3+1]= (char) ((sample>>8) & 0xff);
    #####: 3720:		((char*)data)[i*3+2]= (char) ((sample>>16) & 0xff);
        -: 3721:	}
        -: 3722:
    #####: 3723:	return(i*3);
        -: 3724:}
        -: 3725:
        -: 3726:/*
        -: 3727: * This functions converts in place a buffer of RGBA interleaved data
        -: 3728: * into RGB interleaved data, discarding A.
        -: 3729: */
        -: 3730:
        -: 3731:tsize_t
    #####: 3732:t2p_sample_rgbaa_to_rgb(tdata_t data, uint32 samplecount)
        -: 3733:{
        -: 3734:	uint32 i;
        -: 3735:	
        -: 3736:    /* For the 3 first samples, there is overlapping between souce and
        -: 3737:       destination, so use memmove().
        -: 3738:       See http://bugzilla.maptools.org/show_bug.cgi?id=2577 */
    #####: 3739:    for(i = 0; i < 3 && i < samplecount; i++)
    #####: 3740:        memmove((uint8*)data + i * 3, (uint8*)data + i * 4, 3);
    #####: 3741:	for(; i < samplecount; i++)
    #####: 3742:		memcpy((uint8*)data + i * 3, (uint8*)data + i * 4, 3);
        -: 3743:
    #####: 3744:	return(i * 3);
        -: 3745:}
        -: 3746:
        -: 3747:/*
        -: 3748: * This functions converts in place a buffer of RGBA interleaved data
        -: 3749: * into RGB interleaved data, adding 255-A to each component sample.
        -: 3750: */
        -: 3751:
        -: 3752:tsize_t
    #####: 3753:t2p_sample_rgba_to_rgb(tdata_t data, uint32 samplecount)
        -: 3754:{
    #####: 3755:	uint32 i = 0;
    #####: 3756:	uint32 sample = 0;
    #####: 3757:	uint8 alpha = 0;
        -: 3758:
    #####: 3759:	for (i = 0; i < samplecount; i++) {
    #####: 3760:		sample=((uint32*)data)[i];
    #####: 3761:		alpha=(uint8)((255 - ((sample >> 24) & 0xff)));
    #####: 3762:		((uint8 *)data)[i * 3] = (uint8) ((sample >> 16) & 0xff) + alpha;
    #####: 3763:		((uint8 *)data)[i * 3 + 1] = (uint8) ((sample >> 8) & 0xff) + alpha;
    #####: 3764:		((uint8 *)data)[i * 3 + 2] = (uint8) (sample & 0xff) + alpha;
        -: 3765:	}
        -: 3766:
    #####: 3767:	return (i * 3);
        -: 3768:}
        -: 3769:
        -: 3770:/*
        -: 3771:	This function converts the a and b samples of Lab data from signed
        -: 3772:	to unsigned.
        -: 3773:*/
        -: 3774:
    #####: 3775:tsize_t t2p_sample_lab_signed_to_unsigned(tdata_t buffer, uint32 samplecount){
        -: 3776:
    #####: 3777:	uint32 i=0;
        -: 3778:
    #####: 3779:	for(i=0;i<samplecount;i++){
    #####: 3780:		if( (((unsigned char*)buffer)[(i*3)+1] & 0x80) !=0){
    #####: 3781:			((unsigned char*)buffer)[(i*3)+1] =
    #####: 3782:				(unsigned char)(0x80 + ((char*)buffer)[(i*3)+1]);
        -: 3783:		} else {
    #####: 3784:			((unsigned char*)buffer)[(i*3)+1] |= 0x80;
        -: 3785:		}
    #####: 3786:		if( (((unsigned char*)buffer)[(i*3)+2] & 0x80) !=0){
    #####: 3787:			((unsigned char*)buffer)[(i*3)+2] =
    #####: 3788:				(unsigned char)(0x80 + ((char*)buffer)[(i*3)+2]);
        -: 3789:		} else {
    #####: 3790:			((unsigned char*)buffer)[(i*3)+2] |= 0x80;
        -: 3791:		}
        -: 3792:	}
        -: 3793:
    #####: 3794:	return(samplecount*3);
        -: 3795:}
        -: 3796:
        -: 3797:/* 
        -: 3798:	This function writes the PDF header to output.
        -: 3799:*/
        -: 3800:
        1: 3801:tsize_t t2p_write_pdf_header(T2P* t2p, TIFF* output){
        -: 3802:
        1: 3803:	tsize_t written=0;
        1: 3804:	char buffer[16];
        1: 3805:	int buflen=0;
        -: 3806:	
    #####: 3807:	buflen = snprintf(buffer, sizeof(buffer), "%%PDF-%u.%u ",
        1: 3808:			  t2p->pdf_majorversion&0xff,
        1: 3809:			  t2p->pdf_minorversion&0xff);
       1*: 3810:	check_snprintf_ret(t2p, buflen, buffer);
        1: 3811:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 3812:	written += t2pWriteFile(output, (tdata_t)"\n%\342\343\317\323\n", 7);
        -: 3813:
        1: 3814:	return(written);
        -: 3815:}
        -: 3816:
        -: 3817:/*
        -: 3818:	This function writes the beginning of a PDF object to output.
        -: 3819:*/
        -: 3820:
        7: 3821:tsize_t t2p_write_pdf_obj_start(uint32 number, TIFF* output){
        -: 3822:
        7: 3823:	tsize_t written=0;
        7: 3824:	char buffer[32];
        7: 3825:	int buflen=0;
        -: 3826:
       7*: 3827:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)number);
       7*: 3828:	check_snprintf_ret((T2P*)NULL, buflen, buffer);
        7: 3829:	written += t2pWriteFile(output, (tdata_t) buffer, buflen );
        7: 3830:	written += t2pWriteFile(output, (tdata_t) " 0 obj\n", 7);
        -: 3831:
        7: 3832:	return(written);
        -: 3833:}
        -: 3834:
        -: 3835:/*
        -: 3836:	This function writes the end of a PDF object to output.
        -: 3837:*/
        -: 3838:
        6: 3839:tsize_t t2p_write_pdf_obj_end(TIFF* output){
        -: 3840:
        6: 3841:	tsize_t written=0;
        -: 3842:
        6: 3843:	written += t2pWriteFile(output, (tdata_t) "endobj\n", 7);
        -: 3844:
        6: 3845:	return(written);
        -: 3846:}
        -: 3847:
        -: 3848:/*
        -: 3849:	This function writes a PDF name object to output.
        -: 3850:*/
        -: 3851:
    #####: 3852:tsize_t t2p_write_pdf_name(unsigned char* name, TIFF* output){
        -: 3853:
    #####: 3854:	tsize_t written=0;
    #####: 3855:	uint32 i=0;
    #####: 3856:	char buffer[64];
    #####: 3857:	uint16 nextchar=0;
    #####: 3858:	size_t namelen=0;
        -: 3859:	
    #####: 3860:	namelen = strlen((char *)name);
    #####: 3861:	if (namelen>126) {
    #####: 3862:		namelen=126;
        -: 3863:	}
    #####: 3864:	written += t2pWriteFile(output, (tdata_t) "/", 1);
    #####: 3865:	for (i=0;i<namelen;i++){
    #####: 3866:		if ( ((unsigned char)name[i]) < 0x21){
    #####: 3867:			snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3868:			buffer[sizeof(buffer) - 1] = '\0';
    #####: 3869:			written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3870:			nextchar=1;
        -: 3871:		}
    #####: 3872:		if ( ((unsigned char)name[i]) > 0x7E){
    #####: 3873:			snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3874:			buffer[sizeof(buffer) - 1] = '\0';
    #####: 3875:			written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3876:			nextchar=1;
        -: 3877:		}
    #####: 3878:		if (nextchar==0){
    #####: 3879:			switch (name[i]){
    #####: 3880:				case 0x23:
    #####: 3881:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3882:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3883:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3884:					break;
    #####: 3885:				case 0x25:
    #####: 3886:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3887:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3888:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3889:					break;
    #####: 3890:				case 0x28:
    #####: 3891:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3892:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3893:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3894:					break;
    #####: 3895:				case 0x29:
    #####: 3896:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3897:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3898:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3899:					break;
    #####: 3900:				case 0x2F:
    #####: 3901:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3902:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3903:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3904:					break;
    #####: 3905:				case 0x3C:
    #####: 3906:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3907:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3908:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3909:					break;
    #####: 3910:				case 0x3E:
    #####: 3911:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3912:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3913:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3914:					break;
    #####: 3915:				case 0x5B:
    #####: 3916:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3917:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3918:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3919:					break;
    #####: 3920:				case 0x5D:
    #####: 3921:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]);
    #####: 3922:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3923:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3924:					break;
    #####: 3925:				case 0x7B:
    #####: 3926:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3927:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3928:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3929:					break;
    #####: 3930:				case 0x7D:
    #####: 3931:					snprintf(buffer, sizeof(buffer), "#%.2X", name[i]); 
    #####: 3932:					buffer[sizeof(buffer) - 1] = '\0';
    #####: 3933:					written += t2pWriteFile(output, (tdata_t) buffer, 3);
    #####: 3934:					break;
    #####: 3935:				default:
    #####: 3936:					written += t2pWriteFile(output, (tdata_t) &name[i], 1);
        -: 3937:			}
    #####: 3938:		}
    #####: 3939:		nextchar=0;
        -: 3940:	}
    #####: 3941:	written += t2pWriteFile(output, (tdata_t) " ", 1);
        -: 3942:
    #####: 3943:	return(written);
        -: 3944:}
        -: 3945:
        -: 3946:/*
        -: 3947: * This function writes a PDF string object to output.
        -: 3948: */
        -: 3949:	
        4: 3950:tsize_t t2p_write_pdf_string(char* pdfstr, TIFF* output)
        -: 3951:{
        4: 3952:	tsize_t written = 0;
        4: 3953:	uint32 i = 0;
        4: 3954:	char buffer[64];
        4: 3955:	size_t len = 0;
        -: 3956:	
       4*: 3957:	len = strlen(pdfstr);
        4: 3958:	written += t2pWriteFile(output, (tdata_t) "(", 1);
       72: 3959:	for (i=0; i<len; i++) {
       68: 3960:		if((pdfstr[i]&0x80) || (pdfstr[i]==127) || (pdfstr[i]<32)){
        1: 3961:			snprintf(buffer, sizeof(buffer), "\\%.3o", ((unsigned char)pdfstr[i]));
        1: 3962:			written += t2pWriteFile(output, (tdata_t)buffer, 4);
        -: 3963:		} else {
       67: 3964:			switch (pdfstr[i]){
    #####: 3965:				case 0x08:
    #####: 3966:					written += t2pWriteFile(output, (tdata_t) "\\b", 2);
    #####: 3967:					break;
    #####: 3968:				case 0x09:
    #####: 3969:					written += t2pWriteFile(output, (tdata_t) "\\t", 2);
    #####: 3970:					break;
    #####: 3971:				case 0x0A:
    #####: 3972:					written += t2pWriteFile(output, (tdata_t) "\\n", 2);
    #####: 3973:					break;
    #####: 3974:				case 0x0C:
    #####: 3975:					written += t2pWriteFile(output, (tdata_t) "\\f", 2);
    #####: 3976:					break;
    #####: 3977:				case 0x0D:
    #####: 3978:					written += t2pWriteFile(output, (tdata_t) "\\r", 2);
    #####: 3979:					break;
    #####: 3980:				case 0x28:
    #####: 3981:					written += t2pWriteFile(output, (tdata_t) "\\(", 2);
    #####: 3982:					break;
    #####: 3983:				case 0x29:
    #####: 3984:					written += t2pWriteFile(output, (tdata_t) "\\)", 2);
    #####: 3985:					break;
    #####: 3986:				case 0x5C:
    #####: 3987:					written += t2pWriteFile(output, (tdata_t) "\\\\", 2);
    #####: 3988:					break;
       67: 3989:				default:
       67: 3990:					written += t2pWriteFile(output, (tdata_t) &pdfstr[i], 1);
        -: 3991:			}
        -: 3992:		}
        -: 3993:	}
        4: 3994:	written += t2pWriteFile(output, (tdata_t) ") ", 1);
        -: 3995:
        4: 3996:	return(written);
        -: 3997:}
        -: 3998:
        -: 3999:
        -: 4000:/*
        -: 4001:	This function writes a buffer of data to output.
        -: 4002:*/
        -: 4003:
        1: 4004:tsize_t t2p_write_pdf_stream(tdata_t buffer, tsize_t len, TIFF* output){
        -: 4005:
        1: 4006:	tsize_t written=0;
        -: 4007:
        1: 4008:	written += t2pWriteFile(output, (tdata_t) buffer, len);
        -: 4009:
        1: 4010:	return(written);
        -: 4011:}
        -: 4012:
        -: 4013:/*
        -: 4014:	This functions writes the beginning of a PDF stream to output.
        -: 4015:*/
        -: 4016:
        2: 4017:tsize_t t2p_write_pdf_stream_start(TIFF* output){
        -: 4018:
        2: 4019:	tsize_t written=0;
        -: 4020:
        2: 4021:	written += t2pWriteFile(output, (tdata_t) "stream\n", 7);
        -: 4022:
        2: 4023:	return(written);
        -: 4024:}
        -: 4025:
        -: 4026:/*
        -: 4027:	This function writes the end of a PDF stream to output. 
        -: 4028:*/
        -: 4029:
        1: 4030:tsize_t t2p_write_pdf_stream_end(TIFF* output){
        -: 4031:
        1: 4032:	tsize_t written=0;
        -: 4033:
        1: 4034:	written += t2pWriteFile(output, (tdata_t) "\nendstream\n", 11);
        -: 4035:
        1: 4036:	return(written);
        -: 4037:}
        -: 4038:
        -: 4039:/*
        -: 4040:	This function writes a stream dictionary for a PDF stream to output.
        -: 4041:*/
        -: 4042:
        2: 4043:tsize_t t2p_write_pdf_stream_dict(tsize_t len, uint32 number, TIFF* output){
        -: 4044:	
        2: 4045:	tsize_t written=0;
        2: 4046:	char buffer[32];
        2: 4047:	int buflen=0;
        -: 4048:	
        2: 4049:	written += t2pWriteFile(output, (tdata_t) "/Length ", 8);
        2: 4050:	if(len!=0){
    #####: 4051:		written += t2p_write_pdf_stream_length(len, output);
        -: 4052:	} else {
       2*: 4053:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)number);
       2*: 4054:		check_snprintf_ret((T2P*)NULL, buflen, buffer);
        2: 4055:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        2: 4056:		written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
        -: 4057:	}
        -: 4058:	
        2: 4059:	return(written);
        -: 4060:}
        -: 4061:
        -: 4062:/*
        -: 4063:	This functions writes the beginning of a PDF stream dictionary to output.
        -: 4064:*/
        -: 4065:
        2: 4066:tsize_t t2p_write_pdf_stream_dict_start(TIFF* output){
        -: 4067:
        2: 4068:	tsize_t written=0;
        -: 4069:
        2: 4070:	written += t2pWriteFile(output, (tdata_t) "<< \n", 4);
        -: 4071:
        2: 4072:	return(written);
        -: 4073:}
        -: 4074:
        -: 4075:/*
        -: 4076:	This function writes the end of a PDF stream dictionary to output. 
        -: 4077:*/
        -: 4078:
        2: 4079:tsize_t t2p_write_pdf_stream_dict_end(TIFF* output){
        -: 4080:
        2: 4081:	tsize_t written=0;
        -: 4082:
        2: 4083:	written += t2pWriteFile(output, (tdata_t) " >>\n", 4);
        -: 4084:
        2: 4085:	return(written);
        -: 4086:}
        -: 4087:
        -: 4088:/*
        -: 4089:	This function writes a number to output.
        -: 4090:*/
        -: 4091:
        1: 4092:tsize_t t2p_write_pdf_stream_length(tsize_t len, TIFF* output){
        -: 4093:
        1: 4094:	tsize_t written=0;
        1: 4095:	char buffer[32];
        1: 4096:	int buflen=0;
        -: 4097:
       1*: 4098:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)len);
       1*: 4099:	check_snprintf_ret((T2P*)NULL, buflen, buffer);
        1: 4100:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4101:	written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4102:
        1: 4103:	return(written);
        -: 4104:}
        -: 4105:
        -: 4106:/*
        -: 4107: * This function writes the PDF Catalog structure to output.
        -: 4108: */
        -: 4109:
        1: 4110:tsize_t t2p_write_pdf_catalog(T2P* t2p, TIFF* output)
        -: 4111:{
        1: 4112:	tsize_t written = 0;
        1: 4113:	char buffer[32];
        1: 4114:	int buflen = 0;
        -: 4115:
        1: 4116:	written += t2pWriteFile(output, 
        -: 4117:		(tdata_t)"<< \n/Type /Catalog \n/Pages ", 
        -: 4118:		27);
       1*: 4119:	buflen = snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_pages);
       1*: 4120:	check_snprintf_ret(t2p, buflen, buffer);
       1*: 4121:	written += t2pWriteFile(output, (tdata_t) buffer,
        1: 4122:				TIFFmin((size_t)buflen, sizeof(buffer) - 1));
        1: 4123:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
        1: 4124:	if(t2p->pdf_fitwindow){
    #####: 4125:		written += t2pWriteFile(output, 
        -: 4126:			(tdata_t) "/ViewerPreferences <</FitWindow true>>\n", 
        -: 4127:			39);
        -: 4128:	}
        1: 4129:	written += t2pWriteFile(output, (tdata_t)">>\n", 3);
        -: 4130:
        1: 4131:	return(written);
        -: 4132:}
        -: 4133:
        -: 4134:/*
        -: 4135:	This function writes the PDF Info structure to output.
        -: 4136:*/
        -: 4137:
        1: 4138:tsize_t t2p_write_pdf_info(T2P* t2p, TIFF* input, TIFF* output)
        -: 4139:{
        1: 4140:	tsize_t written = 0;
        1: 4141:	char* info;
        1: 4142:	char buffer[512];
        -: 4143:
        1: 4144:	if(t2p->pdf_datetime[0] == '\0')
        1: 4145:		t2p_pdf_tifftime(t2p, input);
        1: 4146:	if (strlen(t2p->pdf_datetime) > 0) {
        1: 4147:		written += t2pWriteFile(output, (tdata_t) "<< \n/CreationDate ", 18);
        1: 4148:		written += t2p_write_pdf_string(t2p->pdf_datetime, output);
        1: 4149:		written += t2pWriteFile(output, (tdata_t) "\n/ModDate ", 10);
        1: 4150:		written += t2p_write_pdf_string(t2p->pdf_datetime, output);
        -: 4151:	}
        1: 4152:	written += t2pWriteFile(output, (tdata_t) "\n/Producer ", 11);
        1: 4153:	snprintf(buffer, sizeof(buffer), "libtiff / tiff2pdf - %d", TIFFLIB_VERSION);
        1: 4154:	written += t2p_write_pdf_string(buffer, output);
        1: 4155:	written += t2pWriteFile(output, (tdata_t) "\n", 1);
        1: 4156:	if (t2p->pdf_creator[0] != '\0') {
    #####: 4157:		written += t2pWriteFile(output, (tdata_t) "/Creator ", 9);
    #####: 4158:		written += t2p_write_pdf_string(t2p->pdf_creator, output);
    #####: 4159:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4160:	} else {
       1*: 4161:		if (TIFFGetField(input, TIFFTAG_SOFTWARE, &info) != 0 && info) {
    #####: 4162:			if(strlen(info) >= sizeof(t2p->pdf_creator))
    #####: 4163:				info[sizeof(t2p->pdf_creator) - 1] = '\0';
    #####: 4164:			written += t2pWriteFile(output, (tdata_t) "/Creator ", 9);
    #####: 4165:			written += t2p_write_pdf_string(info, output);
    #####: 4166:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4167:		}
        -: 4168:	}
        1: 4169:	if (t2p->pdf_author[0] != '\0') {
    #####: 4170:		written += t2pWriteFile(output, (tdata_t) "/Author ", 8);
    #####: 4171:		written += t2p_write_pdf_string(t2p->pdf_author, output);
    #####: 4172:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4173:	} else {
        1: 4174:		if ((TIFFGetField(input, TIFFTAG_ARTIST, &info) != 0
        1: 4175:		     || TIFFGetField(input, TIFFTAG_COPYRIGHT, &info) != 0)
    #####: 4176:		    && info) {
    #####: 4177:			if (strlen(info) >= sizeof(t2p->pdf_author))
    #####: 4178:				info[sizeof(t2p->pdf_author) - 1] = '\0';
    #####: 4179:			written += t2pWriteFile(output, (tdata_t) "/Author ", 8);
    #####: 4180:			written += t2p_write_pdf_string(info, output);
    #####: 4181:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4182:		}
        -: 4183:	}
        1: 4184:	if (t2p->pdf_title[0] != '\0') {
    #####: 4185:		written += t2pWriteFile(output, (tdata_t) "/Title ", 7);
    #####: 4186:		written += t2p_write_pdf_string(t2p->pdf_title, output);
    #####: 4187:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4188:	} else {
        1: 4189:		if (TIFFGetField(input, TIFFTAG_DOCUMENTNAME, &info) != 0){
       1*: 4190:			if(strlen(info) > 511) {
    #####: 4191:				info[512] = '\0';
        -: 4192:			}
        1: 4193:			written += t2pWriteFile(output, (tdata_t) "/Title ", 7);
        1: 4194:			written += t2p_write_pdf_string(info, output);
        1: 4195:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4196:		}
        -: 4197:	}
        1: 4198:	if (t2p->pdf_subject[0] != '\0') {
    #####: 4199:		written += t2pWriteFile(output, (tdata_t) "/Subject ", 9);
    #####: 4200:		written += t2p_write_pdf_string(t2p->pdf_subject, output);
    #####: 4201:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4202:	} else {
       1*: 4203:		if (TIFFGetField(input, TIFFTAG_IMAGEDESCRIPTION, &info) != 0 && info) {
    #####: 4204:			if (strlen(info) >= sizeof(t2p->pdf_subject))
    #####: 4205:				info[sizeof(t2p->pdf_subject) - 1] = '\0';
    #####: 4206:			written += t2pWriteFile(output, (tdata_t) "/Subject ", 9);
    #####: 4207:			written += t2p_write_pdf_string(info, output);
    #####: 4208:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4209:		}
        -: 4210:	}
        1: 4211:	if (t2p->pdf_keywords[0] != '\0') {
    #####: 4212:		written += t2pWriteFile(output, (tdata_t) "/Keywords ", 10);
    #####: 4213:		written += t2p_write_pdf_string(t2p->pdf_keywords, output);
    #####: 4214:		written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4215:	}
        1: 4216:	written += t2pWriteFile(output, (tdata_t) ">> \n", 4);
        -: 4217:
        1: 4218:	return(written);
        -: 4219:}
        -: 4220:
        -: 4221:/*
        -: 4222: * This function fills a string of a T2P struct with the current time as a PDF
        -: 4223: * date string, it is called by t2p_pdf_tifftime.
        -: 4224: */
        -: 4225:
        1: 4226:void t2p_pdf_currenttime(T2P* t2p)
        -: 4227:{
        -: 4228:	struct tm* currenttime;
        1: 4229:	time_t timenow;
        -: 4230:
        1: 4231:	if (time(&timenow) == (time_t) -1) {
    #####: 4232:		TIFFError(TIFF2PDF_MODULE,
    #####: 4233:			  "Can't get the current time: %s", strerror(errno));
    #####: 4234:		timenow = (time_t) 0;
        -: 4235:	}
        -: 4236:
        1: 4237:	currenttime = localtime(&timenow);
        1: 4238:	snprintf(t2p->pdf_datetime, sizeof(t2p->pdf_datetime),
        -: 4239:		 "D:%.4d%.2d%.2d%.2d%.2d%.2d",
        1: 4240:		 (currenttime->tm_year + 1900) % 65536,
        1: 4241:		 (currenttime->tm_mon + 1) % 256,
        1: 4242:		 (currenttime->tm_mday) % 256,
        1: 4243:		 (currenttime->tm_hour) % 256,
        1: 4244:		 (currenttime->tm_min) % 256,
        1: 4245:		 (currenttime->tm_sec) % 256);
        -: 4246:
        1: 4247:	return;
        -: 4248:}
        -: 4249:
        -: 4250:/*
        -: 4251: * This function fills a string of a T2P struct with the date and time of a
        -: 4252: * TIFF file if it exists or the current time as a PDF date string.
        -: 4253: */
        -: 4254:
        1: 4255:void t2p_pdf_tifftime(T2P* t2p, TIFF* input)
        -: 4256:{
        1: 4257:	char* datetime;
        -: 4258:
        1: 4259:	if (TIFFGetField(input, TIFFTAG_DATETIME, &datetime) != 0
    #####: 4260:	    && (strlen(datetime) >= 19) ){
    #####: 4261:		t2p->pdf_datetime[0]='D';
    #####: 4262:		t2p->pdf_datetime[1]=':';
    #####: 4263:		t2p->pdf_datetime[2]=datetime[0];
    #####: 4264:		t2p->pdf_datetime[3]=datetime[1];
    #####: 4265:		t2p->pdf_datetime[4]=datetime[2];
    #####: 4266:		t2p->pdf_datetime[5]=datetime[3];
    #####: 4267:		t2p->pdf_datetime[6]=datetime[5];
    #####: 4268:		t2p->pdf_datetime[7]=datetime[6];
    #####: 4269:		t2p->pdf_datetime[8]=datetime[8];
    #####: 4270:		t2p->pdf_datetime[9]=datetime[9];
    #####: 4271:		t2p->pdf_datetime[10]=datetime[11];
    #####: 4272:		t2p->pdf_datetime[11]=datetime[12];
    #####: 4273:		t2p->pdf_datetime[12]=datetime[14];
    #####: 4274:		t2p->pdf_datetime[13]=datetime[15];
    #####: 4275:		t2p->pdf_datetime[14]=datetime[17];
    #####: 4276:		t2p->pdf_datetime[15]=datetime[18];
    #####: 4277:		t2p->pdf_datetime[16] = '\0';
        -: 4278:	} else {
        1: 4279:		t2p_pdf_currenttime(t2p);
        -: 4280:	}
        -: 4281:
        1: 4282:	return;
        -: 4283:}
        -: 4284:
        -: 4285:/*
        -: 4286: * This function writes a PDF Pages Tree structure to output.
        -: 4287: */
        -: 4288:
        1: 4289:tsize_t t2p_write_pdf_pages(T2P* t2p, TIFF* output)
        -: 4290:{
        1: 4291:	tsize_t written=0;
        1: 4292:	tdir_t i=0;
        1: 4293:	char buffer[32];
        1: 4294:	int buflen=0;
        -: 4295:
        1: 4296:	int page=0;
        1: 4297:	written += t2pWriteFile(output,
        -: 4298:		(tdata_t) "<< \n/Type /Pages \n/Kids [ ", 26);
        1: 4299:	page = t2p->pdf_pages+1;
        2: 4300:	for (i=0;i<t2p->tiff_pagecount;i++){
       1*: 4301:		buflen=snprintf(buffer, sizeof(buffer), "%d", page);
       1*: 4302:		check_snprintf_ret(t2p, buflen, buffer);
        1: 4303:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4304:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
        1: 4305:		if ( ((i+1)%8)==0 ) {
    #####: 4306:			written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4307:		}
        1: 4308:		page +=3;
        1: 4309:		page += t2p->tiff_pages[i].page_extra;
        1: 4310:		if(t2p->tiff_pages[i].page_tilecount>0){
        1: 4311:			page += (2 * t2p->tiff_pages[i].page_tilecount);
        -: 4312:		} else {
    #####: 4313:			page +=2;
        -: 4314:		}
        -: 4315:	}
        1: 4316:	written += t2pWriteFile(output, (tdata_t) "] \n/Count ", 10);
       1*: 4317:	buflen=snprintf(buffer, sizeof(buffer), "%d", t2p->tiff_pagecount);
       1*: 4318:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4319:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4320:	written += t2pWriteFile(output, (tdata_t) " \n>> \n", 6);
        -: 4321:
        1: 4322:	return(written);
        -: 4323:}
        -: 4324:
        -: 4325:/*
        -: 4326:	This function writes a PDF Page structure to output.
        -: 4327:*/
        -: 4328:
        1: 4329:tsize_t t2p_write_pdf_page(uint32 object, T2P* t2p, TIFF* output){
        -: 4330:
        1: 4331:	unsigned int i=0;
        1: 4332:	tsize_t written=0;
        1: 4333:	char buffer[256];
        1: 4334:	int buflen=0;
        -: 4335:
        1: 4336:	written += t2pWriteFile(output, (tdata_t) "<<\n/Type /Page \n/Parent ", 24);
       1*: 4337:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_pages);
       1*: 4338:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4339:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4340:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
        1: 4341:	written += t2pWriteFile(output, (tdata_t) "/MediaBox [", 11); 
       1*: 4342:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.x1);
       1*: 4343:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4344:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4345:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
       1*: 4346:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.y1);
       1*: 4347:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4348:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4349:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
       1*: 4350:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.x2);
       1*: 4351:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4352:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4353:	written += t2pWriteFile(output, (tdata_t) " ", 1); 
       1*: 4354:	buflen=snprintf(buffer, sizeof(buffer), "%.4f",t2p->pdf_mediabox.y2);
       1*: 4355:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4356:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4357:	written += t2pWriteFile(output, (tdata_t) "] \n", 3); 
        1: 4358:	written += t2pWriteFile(output, (tdata_t) "/Contents ", 10);
       1*: 4359:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(object + 1));
       1*: 4360:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4361:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4362:	written += t2pWriteFile(output, (tdata_t) " 0 R \n", 6);
        1: 4363:	written += t2pWriteFile(output, (tdata_t) "/Resources << \n", 15);
        1: 4364:	if( t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount != 0 ){
        1: 4365:		written += t2pWriteFile(output, (tdata_t) "/XObject <<\n", 12);
        2: 4366:		for(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i++){
        1: 4367:			written += t2pWriteFile(output, (tdata_t) "/Im", 3);
       1*: 4368:			buflen = snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
       1*: 4369:			check_snprintf_ret(t2p, buflen, buffer);
        1: 4370:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4371:			written += t2pWriteFile(output, (tdata_t) "_", 1);
       1*: 4372:			buflen = snprintf(buffer, sizeof(buffer), "%u", i+1);
       1*: 4373:			check_snprintf_ret(t2p, buflen, buffer);
        1: 4374:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4375:			written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4376:			buflen = snprintf(buffer, sizeof(buffer), "%lu",
        1: 4377:				(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); 
       1*: 4378:			check_snprintf_ret(t2p, buflen, buffer);
        1: 4379:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4380:			written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
        1: 4381:			if(i%4==3){
    #####: 4382:				written += t2pWriteFile(output, (tdata_t) "\n", 1);
        -: 4383:			}
        -: 4384:		}
        1: 4385:		written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 4386:	} else {
    #####: 4387:			written += t2pWriteFile(output, (tdata_t) "/XObject <<\n", 12);
    #####: 4388:			written += t2pWriteFile(output, (tdata_t) "/Im", 3);
    #####: 4389:			buflen = snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
    #####: 4390:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4391:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4392:			written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4393:			buflen = snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4394:				(unsigned long)(object+3+(2*i)+t2p->tiff_pages[t2p->pdf_page].page_extra)); 
    #####: 4395:			check_snprintf_ret(t2p, buflen, buffer);
    #####: 4396:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4397:			written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4398:		written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 4399:	}
        1: 4400:	if(t2p->tiff_transferfunctioncount != 0) {
    #####: 4401:		written += t2pWriteFile(output, (tdata_t) "/ExtGState <<", 13);
    #####: 4402:		t2pWriteFile(output, (tdata_t) "/GS1 ", 5);
    #####: 4403:		buflen = snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4404:			(unsigned long)(object + 3)); 
    #####: 4405:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4406:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4407:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4408:		written += t2pWriteFile(output, (tdata_t) ">> \n", 4);
        -: 4409:	}
        1: 4410:	written += t2pWriteFile(output, (tdata_t) "/ProcSet [ ", 11);
        1: 4411:	if(t2p->pdf_colorspace & T2P_CS_BILEVEL 
        1: 4412:		|| t2p->pdf_colorspace & T2P_CS_GRAY
        -: 4413:		){
    #####: 4414:		written += t2pWriteFile(output, (tdata_t) "/ImageB ", 8);
        -: 4415:	} else {
        1: 4416:		written += t2pWriteFile(output, (tdata_t) "/ImageC ", 8);
        1: 4417:		if(t2p->pdf_colorspace & T2P_CS_PALETTE){
    #####: 4418:			written += t2pWriteFile(output, (tdata_t) "/ImageI ", 8);
        -: 4419:		}
        -: 4420:	}
        1: 4421:	written += t2pWriteFile(output, (tdata_t) "]\n>>\n>>\n", 8);
        -: 4422:
        1: 4423:	return(written);
        -: 4424:}
        -: 4425:
        -: 4426:/*
        -: 4427:	This function composes the page size and image and tile locations on a page.
        -: 4428:*/
        -: 4429:
        1: 4430:void t2p_compose_pdf_page(T2P* t2p){
        -: 4431:
        1: 4432:	uint32 i=0;
        1: 4433:	uint32 i2=0;
        1: 4434:	T2P_TILE* tiles=NULL;
        1: 4435:	T2P_BOX* boxp=NULL;
        1: 4436:	uint32 tilecountx=0;
        1: 4437:	uint32 tilecounty=0;
        1: 4438:	uint32 tilewidth=0;
        1: 4439:	uint32 tilelength=0;
        1: 4440:	int istiled=0;
        1: 4441:	float f=0;
        1: 4442:	float width_ratio=0;
        1: 4443:	float length_ratio=0;
        -: 4444:	
        1: 4445:	t2p->pdf_xres = t2p->tiff_xres;
        1: 4446:	t2p->pdf_yres = t2p->tiff_yres;
        1: 4447:	if(t2p->pdf_overrideres) {
    #####: 4448:		t2p->pdf_xres = t2p->pdf_defaultxres;
    #####: 4449:		t2p->pdf_yres = t2p->pdf_defaultyres;
        -: 4450:	}
        1: 4451:	if(t2p->pdf_xres == 0.0)
        1: 4452:		t2p->pdf_xres = t2p->pdf_defaultxres;
        1: 4453:	if(t2p->pdf_yres == 0.0)
        1: 4454:		t2p->pdf_yres = t2p->pdf_defaultyres;
        1: 4455:	if (t2p->pdf_image_fillpage) {
    #####: 4456:		width_ratio = t2p->pdf_defaultpagewidth/t2p->tiff_width;
    #####: 4457:		length_ratio = t2p->pdf_defaultpagelength/t2p->tiff_length;
    #####: 4458:		if (width_ratio < length_ratio ) {
    #####: 4459:			t2p->pdf_imagewidth = t2p->pdf_defaultpagewidth;
    #####: 4460:			t2p->pdf_imagelength = t2p->tiff_length * width_ratio;
        -: 4461:		} else {
    #####: 4462:			t2p->pdf_imagewidth = t2p->tiff_width * length_ratio;
    #####: 4463:			t2p->pdf_imagelength = t2p->pdf_defaultpagelength;
        -: 4464:		}
        1: 4465:	} else if (t2p->tiff_resunit != RESUNIT_CENTIMETER	/* RESUNIT_NONE and */
        1: 4466:		&& t2p->tiff_resunit != RESUNIT_INCH) {	/* other cases */
    #####: 4467:		t2p->pdf_imagewidth = ((float)(t2p->tiff_width))/t2p->pdf_xres;
    #####: 4468:		t2p->pdf_imagelength = ((float)(t2p->tiff_length))/t2p->pdf_yres;
        -: 4469:	} else {
        1: 4470:		t2p->pdf_imagewidth = 
        1: 4471:			((float)(t2p->tiff_width))*PS_UNIT_SIZE/t2p->pdf_xres;
        1: 4472:		t2p->pdf_imagelength = 
        1: 4473:			((float)(t2p->tiff_length))*PS_UNIT_SIZE/t2p->pdf_yres;
        -: 4474:	}
        1: 4475:	if(t2p->pdf_overridepagesize != 0) {
    #####: 4476:		t2p->pdf_pagewidth = t2p->pdf_defaultpagewidth;
    #####: 4477:		t2p->pdf_pagelength = t2p->pdf_defaultpagelength;
        -: 4478:	} else {
        1: 4479:		t2p->pdf_pagewidth = t2p->pdf_imagewidth;
        1: 4480:		t2p->pdf_pagelength = t2p->pdf_imagelength;
        -: 4481:	}
        1: 4482:	t2p->pdf_mediabox.x1=0.0;
        1: 4483:	t2p->pdf_mediabox.y1=0.0;
        1: 4484:	t2p->pdf_mediabox.x2=t2p->pdf_pagewidth;
        1: 4485:	t2p->pdf_mediabox.y2=t2p->pdf_pagelength;
        1: 4486:	t2p->pdf_imagebox.x1=0.0;
        1: 4487:	t2p->pdf_imagebox.y1=0.0;
        1: 4488:	t2p->pdf_imagebox.x2=t2p->pdf_imagewidth;
        1: 4489:	t2p->pdf_imagebox.y2=t2p->pdf_imagelength;
        1: 4490:	if(t2p->pdf_overridepagesize!=0){
    #####: 4491:		t2p->pdf_imagebox.x1+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);
    #####: 4492:		t2p->pdf_imagebox.y1+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);
    #####: 4493:		t2p->pdf_imagebox.x2+=((t2p->pdf_pagewidth-t2p->pdf_imagewidth)/2.0F);
    #####: 4494:		t2p->pdf_imagebox.y2+=((t2p->pdf_pagelength-t2p->pdf_imagelength)/2.0F);
        -: 4495:	}
        1: 4496:	if(t2p->tiff_orientation > 4){
    #####: 4497:		f=t2p->pdf_mediabox.x2;
    #####: 4498:		t2p->pdf_mediabox.x2=t2p->pdf_mediabox.y2;
    #####: 4499:		t2p->pdf_mediabox.y2=f;
        -: 4500:	}
        1: 4501:	istiled=((t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount==0) ? 0 : 1;
        1: 4502:	if(istiled==0){
    #####: 4503:		t2p_compose_pdf_page_orient(&(t2p->pdf_imagebox), t2p->tiff_orientation);
    #####: 4504:		return;
        -: 4505:	} else {
        1: 4506:		tilewidth=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilewidth;
        1: 4507:		tilelength=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilelength;
        1: 4508:		if( tilewidth > INT_MAX ||
        1: 4509:		    tilelength > INT_MAX ||
        1: 4510:		    t2p->tiff_width > INT_MAX - tilewidth ||
        1: 4511:		    t2p->tiff_length > INT_MAX - tilelength )
        -: 4512:		{
    #####: 4513:		    TIFFError(TIFF2PDF_MODULE, "Integer overflow");
    #####: 4514:		    t2p->t2p_error = T2P_ERR_ERROR;
    #####: 4515:		    return;
        -: 4516:		}
        1: 4517:		tilecountx=(t2p->tiff_width + 
       1*: 4518:			tilewidth -1)/ 
        -: 4519:			tilewidth;
        1: 4520:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecountx=tilecountx;
        1: 4521:		tilecounty=(t2p->tiff_length + 
       1*: 4522:			tilelength -1)/ 
        -: 4523:			tilelength;
        1: 4524:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecounty=tilecounty;
        2: 4525:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilewidth=
       2*: 4526:			t2p->tiff_width % tilewidth;
        2: 4527:		(t2p->tiff_tiles[t2p->pdf_page]).tiles_edgetilelength=
       2*: 4528:			t2p->tiff_length % tilelength;
        1: 4529:		tiles=(t2p->tiff_tiles[t2p->pdf_page]).tiles_tiles;
       1*: 4530:		for(i2=0;i2<tilecounty-1;i2++){
    #####: 4531:			for(i=0;i<tilecountx-1;i++){
    #####: 4532:				boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4533:				boxp->x1 = 
    #####: 4534:					t2p->pdf_imagebox.x1 
    #####: 4535:					+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4536:					/ (float)t2p->tiff_width);
    #####: 4537:				boxp->x2 = 
    #####: 4538:					t2p->pdf_imagebox.x1 
    #####: 4539:					+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)
    #####: 4540:					/ (float)t2p->tiff_width);
    #####: 4541:				boxp->y1 = 
    #####: 4542:					t2p->pdf_imagebox.y2 
    #####: 4543:					- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)
    #####: 4544:					/ (float)t2p->tiff_length);
    #####: 4545:				boxp->y2 = 
    #####: 4546:					t2p->pdf_imagebox.y2 
    #####: 4547:					- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4548:					/ (float)t2p->tiff_length);
        -: 4549:			}
    #####: 4550:			boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4551:			boxp->x1 = 
    #####: 4552:				t2p->pdf_imagebox.x1 
    #####: 4553:				+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4554:				/ (float)t2p->tiff_width);
    #####: 4555:			boxp->x2 = t2p->pdf_imagebox.x2;
    #####: 4556:			boxp->y1 = 
    #####: 4557:				t2p->pdf_imagebox.y2 
    #####: 4558:				- ((float)(t2p->pdf_imagelength * (i2+1) * tilelength)
    #####: 4559:				/ (float)t2p->tiff_length);
    #####: 4560:			boxp->y2 = 
    #####: 4561:				t2p->pdf_imagebox.y2 
    #####: 4562:				- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4563:				/ (float)t2p->tiff_length);
        -: 4564:		}
       1*: 4565:		for(i=0;i<tilecountx-1;i++){
    #####: 4566:			boxp=&(tiles[i2*tilecountx+i].tile_box);
    #####: 4567:			boxp->x1 = 
    #####: 4568:				t2p->pdf_imagebox.x1 
    #####: 4569:				+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
    #####: 4570:				/ (float)t2p->tiff_width);
    #####: 4571:			boxp->x2 = 
    #####: 4572:				t2p->pdf_imagebox.x1 
    #####: 4573:				+ ((float)(t2p->pdf_imagewidth * (i+1) * tilewidth)
    #####: 4574:				/ (float)t2p->tiff_width);
    #####: 4575:			boxp->y1 = t2p->pdf_imagebox.y1;
    #####: 4576:			boxp->y2 = 
    #####: 4577:				t2p->pdf_imagebox.y2 
    #####: 4578:				- ((float)(t2p->pdf_imagelength * i2 * tilelength)
    #####: 4579:				/ (float)t2p->tiff_length);
        -: 4580:		}
        1: 4581:		boxp=&(tiles[i2*tilecountx+i].tile_box);
        2: 4582:		boxp->x1 = 
        1: 4583:			t2p->pdf_imagebox.x1 
        1: 4584:			+ ((float)(t2p->pdf_imagewidth * i * tilewidth)
        1: 4585:			/ (float)t2p->tiff_width);
        1: 4586:		boxp->x2 = t2p->pdf_imagebox.x2;
        1: 4587:		boxp->y1 = t2p->pdf_imagebox.y1;
        1: 4588:		boxp->y2 = 
        1: 4589:			t2p->pdf_imagebox.y2 
        1: 4590:			- ((float)(t2p->pdf_imagelength * i2 * tilelength)
        1: 4591:			/ (float)t2p->tiff_length);
        -: 4592:	}
        1: 4593:	if(t2p->tiff_orientation==0 || t2p->tiff_orientation==1){
        2: 4594:		for(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){
        1: 4595:			t2p_compose_pdf_page_orient( &(tiles[i].tile_box) , 0);
        -: 4596:		}
        1: 4597:		return;
        -: 4598:	}
    #####: 4599:	for(i=0;i<(t2p->tiff_tiles[t2p->pdf_page]).tiles_tilecount;i++){
    #####: 4600:		boxp=&(tiles[i].tile_box);
    #####: 4601:		boxp->x1 -= t2p->pdf_imagebox.x1;
    #####: 4602:		boxp->x2 -= t2p->pdf_imagebox.x1;
    #####: 4603:		boxp->y1 -= t2p->pdf_imagebox.y1;
    #####: 4604:		boxp->y2 -= t2p->pdf_imagebox.y1;
    #####: 4605:		if(t2p->tiff_orientation==2 || t2p->tiff_orientation==3){
    #####: 4606:			boxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;
    #####: 4607:			boxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;
        -: 4608:		}
    #####: 4609:		if(t2p->tiff_orientation==3 || t2p->tiff_orientation==4){
    #####: 4610:			boxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;
    #####: 4611:			boxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;
        -: 4612:		}
    #####: 4613:		if(t2p->tiff_orientation==8 || t2p->tiff_orientation==5){
    #####: 4614:			boxp->y1 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y1;
    #####: 4615:			boxp->y2 = t2p->pdf_imagebox.y2 - t2p->pdf_imagebox.y1 - boxp->y2;
        -: 4616:		}
    #####: 4617:		if(t2p->tiff_orientation==5 || t2p->tiff_orientation==6){
    #####: 4618:			boxp->x1 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x1;
    #####: 4619:			boxp->x2 = t2p->pdf_imagebox.x2 - t2p->pdf_imagebox.x1 - boxp->x2;
        -: 4620:		}
    #####: 4621:		if(t2p->tiff_orientation > 4){
    #####: 4622:			f=boxp->x1;
    #####: 4623:			boxp->x1 = boxp->y1;
    #####: 4624:			boxp->y1 = f;
    #####: 4625:			f=boxp->x2;
    #####: 4626:			boxp->x2 = boxp->y2;
    #####: 4627:			boxp->y2 = f; 
    #####: 4628:			t2p_compose_pdf_page_orient_flip(boxp, t2p->tiff_orientation);
        -: 4629:		} else {
    #####: 4630:			t2p_compose_pdf_page_orient(boxp, t2p->tiff_orientation);
        -: 4631:		}
        -: 4632:		
        -: 4633:	}
        -: 4634:
    #####: 4635:	return;
        -: 4636:}
        -: 4637:
        1: 4638:void t2p_compose_pdf_page_orient(T2P_BOX* boxp, uint16 orientation){
        -: 4639:
        -: 4640:	float m1[9];
        1: 4641:	float f=0.0;
        -: 4642:	
        1: 4643:	if( boxp->x1 > boxp->x2){
    #####: 4644:		f=boxp->x1;
    #####: 4645:		boxp->x1=boxp->x2;
    #####: 4646:		boxp->x2 = f;
        -: 4647:	}
        1: 4648:	if( boxp->y1 > boxp->y2){
    #####: 4649:		f=boxp->y1;
    #####: 4650:		boxp->y1=boxp->y2;
    #####: 4651:		boxp->y2 = f;
        -: 4652:	}
        1: 4653:	boxp->mat[0]=m1[0]=boxp->x2-boxp->x1;
        1: 4654:	boxp->mat[1]=m1[1]=0.0;
        1: 4655:	boxp->mat[2]=m1[2]=0.0;
        1: 4656:	boxp->mat[3]=m1[3]=0.0;
        1: 4657:	boxp->mat[4]=m1[4]=boxp->y2-boxp->y1;
        1: 4658:	boxp->mat[5]=m1[5]=0.0;
        1: 4659:	boxp->mat[6]=m1[6]=boxp->x1;
        1: 4660:	boxp->mat[7]=m1[7]=boxp->y1;
        1: 4661:	boxp->mat[8]=m1[8]=1.0;
        1: 4662:	switch(orientation){
        1: 4663:		case 0:
        -: 4664:		case 1:
        1: 4665:			break;
    #####: 4666:		case 2:
    #####: 4667:			boxp->mat[0]=0.0F-m1[0];
    #####: 4668:			boxp->mat[6]+=m1[0];
    #####: 4669:			break;
    #####: 4670:		case 3:
    #####: 4671:			boxp->mat[0]=0.0F-m1[0];
    #####: 4672:			boxp->mat[4]=0.0F-m1[4];
    #####: 4673:			boxp->mat[6]+=m1[0];
    #####: 4674:			boxp->mat[7]+=m1[4];
    #####: 4675:			break;
    #####: 4676:		case 4:
    #####: 4677:			boxp->mat[4]=0.0F-m1[4];
    #####: 4678:			boxp->mat[7]+=m1[4];
    #####: 4679:			break;
    #####: 4680:		case 5:
    #####: 4681:			boxp->mat[0]=0.0F;
    #####: 4682:			boxp->mat[1]=0.0F-m1[0];
    #####: 4683:			boxp->mat[3]=0.0F-m1[4];
    #####: 4684:			boxp->mat[4]=0.0F;
    #####: 4685:			boxp->mat[6]+=m1[4];
    #####: 4686:			boxp->mat[7]+=m1[0];
    #####: 4687:			break;
    #####: 4688:		case 6:
    #####: 4689:			boxp->mat[0]=0.0F;
    #####: 4690:			boxp->mat[1]=0.0F-m1[0];
    #####: 4691:			boxp->mat[3]=m1[4];
    #####: 4692:			boxp->mat[4]=0.0F;
    #####: 4693:			boxp->mat[7]+=m1[0];
    #####: 4694:			break;
    #####: 4695:		case 7:
    #####: 4696:			boxp->mat[0]=0.0F;
    #####: 4697:			boxp->mat[1]=m1[0];
    #####: 4698:			boxp->mat[3]=m1[4];
    #####: 4699:			boxp->mat[4]=0.0F;
    #####: 4700:			break;
    #####: 4701:		case 8:
    #####: 4702:			boxp->mat[0]=0.0F;
    #####: 4703:			boxp->mat[1]=m1[0];
    #####: 4704:			boxp->mat[3]=0.0F-m1[4];
    #####: 4705:			boxp->mat[4]=0.0F;
    #####: 4706:			boxp->mat[6]+=m1[4];
    #####: 4707:			break;
        -: 4708:	}
        -: 4709:
        1: 4710:	return;
        -: 4711:}
        -: 4712:
    #####: 4713:void t2p_compose_pdf_page_orient_flip(T2P_BOX* boxp, uint16 orientation){
        -: 4714:
        -: 4715:	float m1[9];
    #####: 4716:	float f=0.0;
        -: 4717:	
    #####: 4718:	if( boxp->x1 > boxp->x2){
    #####: 4719:		f=boxp->x1;
    #####: 4720:		boxp->x1=boxp->x2;
    #####: 4721:		boxp->x2 = f;
        -: 4722:	}
    #####: 4723:	if( boxp->y1 > boxp->y2){
    #####: 4724:		f=boxp->y1;
    #####: 4725:		boxp->y1=boxp->y2;
    #####: 4726:		boxp->y2 = f;
        -: 4727:	}
    #####: 4728:	boxp->mat[0]=m1[0]=boxp->x2-boxp->x1;
    #####: 4729:	boxp->mat[1]=m1[1]=0.0F;
    #####: 4730:	boxp->mat[2]=m1[2]=0.0F;
    #####: 4731:	boxp->mat[3]=m1[3]=0.0F;
    #####: 4732:	boxp->mat[4]=m1[4]=boxp->y2-boxp->y1;
    #####: 4733:	boxp->mat[5]=m1[5]=0.0F;
    #####: 4734:	boxp->mat[6]=m1[6]=boxp->x1;
    #####: 4735:	boxp->mat[7]=m1[7]=boxp->y1;
    #####: 4736:	boxp->mat[8]=m1[8]=1.0F;
    #####: 4737:	switch(orientation){
    #####: 4738:		case 5:
    #####: 4739:			boxp->mat[0]=0.0F;
    #####: 4740:			boxp->mat[1]=0.0F-m1[4];
    #####: 4741:			boxp->mat[3]=0.0F-m1[0];
    #####: 4742:			boxp->mat[4]=0.0F;
    #####: 4743:			boxp->mat[6]+=m1[0];
    #####: 4744:			boxp->mat[7]+=m1[4];
    #####: 4745:			break;
    #####: 4746:		case 6:
    #####: 4747:			boxp->mat[0]=0.0F;
    #####: 4748:			boxp->mat[1]=0.0F-m1[4];
    #####: 4749:			boxp->mat[3]=m1[0];
    #####: 4750:			boxp->mat[4]=0.0F;
    #####: 4751:			boxp->mat[7]+=m1[4];
    #####: 4752:			break;
    #####: 4753:		case 7:
    #####: 4754:			boxp->mat[0]=0.0F;
    #####: 4755:			boxp->mat[1]=m1[4];
    #####: 4756:			boxp->mat[3]=m1[0];
    #####: 4757:			boxp->mat[4]=0.0F;
    #####: 4758:			break;
    #####: 4759:		case 8:
    #####: 4760:			boxp->mat[0]=0.0F;
    #####: 4761:			boxp->mat[1]=m1[4];
    #####: 4762:			boxp->mat[3]=0.0F-m1[0];
    #####: 4763:			boxp->mat[4]=0.0F;
    #####: 4764:			boxp->mat[6]+=m1[0];
    #####: 4765:			break;
        -: 4766:	}
        -: 4767:
    #####: 4768:	return;
        -: 4769:}
        -: 4770:
        -: 4771:/*
        -: 4772:	This function writes a PDF Contents stream to output.
        -: 4773:*/
        -: 4774:
        1: 4775:tsize_t t2p_write_pdf_page_content_stream(T2P* t2p, TIFF* output){
        -: 4776:
        1: 4777:	tsize_t written=0;
        1: 4778:	ttile_t i=0;
        1: 4779:	char buffer[512];
        1: 4780:	int buflen=0;
        -: 4781:	T2P_BOX box;
        -: 4782:	
        1: 4783:	if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount>0){ 
        2: 4784:		for(i=0;i<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount; i++){
        1: 4785:			box=t2p->tiff_tiles[t2p->pdf_page].tiles_tiles[i].tile_box;
       1*: 4786:			buflen=snprintf(buffer, sizeof(buffer), 
        -: 4787:				"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d_%ld Do Q\n", 
        1: 4788:				t2p->tiff_transferfunctioncount?"/GS1 gs ":"",
        1: 4789:				box.mat[0],
        1: 4790:				box.mat[1],
        1: 4791:				box.mat[3],
        1: 4792:				box.mat[4],
        1: 4793:				box.mat[6],
        1: 4794:				box.mat[7],
        1: 4795:				t2p->pdf_page + 1, 
        1: 4796:				(long)(i + 1));
       1*: 4797:			check_snprintf_ret(t2p, buflen, buffer);
        1: 4798:			written += t2p_write_pdf_stream(buffer, buflen, output);
        -: 4799:		}
        -: 4800:	} else {
    #####: 4801:		box=t2p->pdf_imagebox;
    #####: 4802:		buflen=snprintf(buffer, sizeof(buffer), 
        -: 4803:			"q %s %.4f %.4f %.4f %.4f %.4f %.4f cm /Im%d Do Q\n", 
    #####: 4804:			t2p->tiff_transferfunctioncount?"/GS1 gs ":"",
    #####: 4805:			box.mat[0],
    #####: 4806:			box.mat[1],
    #####: 4807:			box.mat[3],
    #####: 4808:			box.mat[4],
    #####: 4809:			box.mat[6],
    #####: 4810:			box.mat[7],
    #####: 4811:			t2p->pdf_page+1);
    #####: 4812:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4813:		written += t2p_write_pdf_stream(buffer, buflen, output);
        -: 4814:	}
        -: 4815:
        1: 4816:	return(written);
        -: 4817:}
        -: 4818:
        -: 4819:/*
        -: 4820:	This function writes a PDF Image XObject stream dictionary to output. 
        -: 4821:*/
        -: 4822:
        1: 4823:tsize_t t2p_write_pdf_xobject_stream_dict(ttile_t tile, 
        -: 4824:												T2P* t2p, 
        -: 4825:												TIFF* output){
        -: 4826:
        1: 4827:	tsize_t written=0;
        1: 4828:	char buffer[32];
        1: 4829:	int buflen=0;
        -: 4830:
        1: 4831:	written += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output); 
        1: 4832:	written += t2pWriteFile(output, 
        -: 4833:		(tdata_t) "/Type /XObject \n/Subtype /Image \n/Name /Im", 
        -: 4834:		42);
       1*: 4835:	buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_page+1);
       1*: 4836:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4837:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4838:	if(tile != 0){
        1: 4839:		written += t2pWriteFile(output, (tdata_t) "_", 1);
       1*: 4840:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)tile);
       1*: 4841:		check_snprintf_ret(t2p, buflen, buffer);
        1: 4842:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 4843:	}
        1: 4844:	written += t2pWriteFile(output, (tdata_t) "\n/Width ", 8);
        1: 4845:	if(tile==0){
    #####: 4846:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->tiff_width);
        -: 4847:	} else {
        1: 4848:		if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){
    #####: 4849:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4850:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
        -: 4851:		} else {
       1*: 4852:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
        1: 4853:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
        -: 4854:		}
        -: 4855:	}
       1*: 4856:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4857:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4858:	written += t2pWriteFile(output, (tdata_t) "\n/Height ", 9);
        1: 4859:	if(tile==0){
    #####: 4860:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->tiff_length);
        -: 4861:	} else {
        1: 4862:		if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)!=0){
       1*: 4863:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
        1: 4864:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
        -: 4865:		} else {
    #####: 4866:			buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4867:				(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
        -: 4868:		}
        -: 4869:	}
       1*: 4870:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4871:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4872:	written += t2pWriteFile(output, (tdata_t) "\n/BitsPerComponent ", 19);
       1*: 4873:	buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_bitspersample);
       1*: 4874:	check_snprintf_ret(t2p, buflen, buffer);
        1: 4875:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4876:	written += t2pWriteFile(output, (tdata_t) "\n/ColorSpace ", 13);
        1: 4877:	written += t2p_write_pdf_xobject_cs(t2p, output);
        1: 4878:	if (t2p->pdf_image_interpolate)
    #####: 4879:		written += t2pWriteFile(output,
        -: 4880:					 (tdata_t) "\n/Interpolate true", 18);
        1: 4881:	if( (t2p->pdf_switchdecode != 0)
        -: 4882:#ifdef CCITT_SUPPORT
    #####: 4883:		&& ! (t2p->pdf_colorspace & T2P_CS_BILEVEL 
    #####: 4884:		&& t2p->pdf_compression == T2P_COMPRESS_G4)
        -: 4885:#endif
        -: 4886:		){
    #####: 4887:		written += t2p_write_pdf_xobject_decode(t2p, output);
        -: 4888:	}
        1: 4889:	written += t2p_write_pdf_xobject_stream_filter(tile, t2p, output);
        -: 4890:	
        1: 4891:	return(written);
        -: 4892:}
        -: 4893:
        -: 4894:/*
        -: 4895: * 	This function writes a PDF Image XObject Colorspace name to output.
        -: 4896: */
        -: 4897:
        -: 4898:
        1: 4899:tsize_t t2p_write_pdf_xobject_cs(T2P* t2p, TIFF* output){
        -: 4900:
        1: 4901:	tsize_t written=0;
        1: 4902:	char buffer[128];
        1: 4903:	int buflen=0;
        -: 4904:
        1: 4905:	float X_W=1.0;
        1: 4906:	float Y_W=1.0;
        1: 4907:	float Z_W=1.0;
        -: 4908:	
        1: 4909:	if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){
    #####: 4910:		written += t2p_write_pdf_xobject_icccs(t2p, output);
    #####: 4911:		return(written);
        -: 4912:	}
        1: 4913:	if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){
    #####: 4914:		written += t2pWriteFile(output, (tdata_t) "[ /Indexed ", 11);
    #####: 4915:		t2p->pdf_colorspace ^= T2P_CS_PALETTE;
    #####: 4916:		written += t2p_write_pdf_xobject_cs(t2p, output);
    #####: 4917:		t2p->pdf_colorspace |= T2P_CS_PALETTE;
    #####: 4918:		buflen=snprintf(buffer, sizeof(buffer), "%u", (0x0001 << t2p->tiff_bitspersample)-1 );
    #####: 4919:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4920:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4921:		written += t2pWriteFile(output, (tdata_t) " ", 1);
    #####: 4922:		buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_palettecs ); 
    #####: 4923:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4924:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4925:		written += t2pWriteFile(output, (tdata_t) " 0 R ]\n", 7);
    #####: 4926:		return(written);
        -: 4927:	}
        1: 4928:	if(t2p->pdf_colorspace & T2P_CS_BILEVEL){
    #####: 4929:			written += t2pWriteFile(output, (tdata_t) "/DeviceGray \n", 13);
        -: 4930:	}
        1: 4931:	if(t2p->pdf_colorspace & T2P_CS_GRAY){
    #####: 4932:			if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 4933:				written += t2p_write_pdf_xobject_calcs(t2p, output);
        -: 4934:			} else {
    #####: 4935:				written += t2pWriteFile(output, (tdata_t) "/DeviceGray \n", 13);
        -: 4936:			}
        -: 4937:	}
        1: 4938:	if(t2p->pdf_colorspace & T2P_CS_RGB){
    #####: 4939:			if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 4940:				written += t2p_write_pdf_xobject_calcs(t2p, output);
        -: 4941:			} else {
    #####: 4942:				written += t2pWriteFile(output, (tdata_t) "/DeviceRGB \n", 12);
        -: 4943:			}
        -: 4944:	}
        1: 4945:	if(t2p->pdf_colorspace & T2P_CS_CMYK){
    #####: 4946:			written += t2pWriteFile(output, (tdata_t) "/DeviceCMYK \n", 13);
        -: 4947:	}
        1: 4948:	if(t2p->pdf_colorspace & T2P_CS_LAB){
        1: 4949:			written += t2pWriteFile(output, (tdata_t) "[/Lab << \n", 10);
        1: 4950:			written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
        1: 4951:			X_W = t2p->tiff_whitechromaticities[0];
        1: 4952:			Y_W = t2p->tiff_whitechromaticities[1];
        1: 4953:			Z_W = 1.0F - (X_W + Y_W);
        1: 4954:			X_W /= Y_W;
        1: 4955:			Z_W /= Y_W;
        1: 4956:			Y_W = 1.0F;
       1*: 4957:			buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
       1*: 4958:			check_snprintf_ret(t2p, buflen, buffer);
        1: 4959:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4960:			written += t2pWriteFile(output, (tdata_t) "/Range ", 7);
       1*: 4961:			buflen=snprintf(buffer, sizeof(buffer), "[%d %d %d %d] \n", 
        -: 4962:				t2p->pdf_labrange[0], 
        -: 4963:				t2p->pdf_labrange[1], 
        -: 4964:				t2p->pdf_labrange[2], 
        -: 4965:				t2p->pdf_labrange[3]);
       1*: 4966:			check_snprintf_ret(t2p, buflen, buffer);
        1: 4967:			written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        1: 4968:			written += t2pWriteFile(output, (tdata_t) ">>] \n", 5);
        -: 4969:			
        -: 4970:	}
        -: 4971:	
        1: 4972:	return(written);
        -: 4973:}
        -: 4974:
    #####: 4975:tsize_t t2p_write_pdf_transfer(T2P* t2p, TIFF* output){
        -: 4976:
    #####: 4977:	tsize_t written=0;
    #####: 4978:	char buffer[32];
    #####: 4979:	int buflen=0;
        -: 4980:
    #####: 4981:	written += t2pWriteFile(output, (tdata_t) "<< /Type /ExtGState \n/TR ", 25);
    #####: 4982:	if(t2p->tiff_transferfunctioncount == 1){
    #####: 4983:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4984:			       (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 4985:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4986:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4987:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
        -: 4988:	} else {
    #####: 4989:		written += t2pWriteFile(output, (tdata_t) "[ ", 2);
    #####: 4990:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4991:			       (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 4992:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4993:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4994:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 4995:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 4996:			       (unsigned long)(t2p->pdf_xrefcount + 2));
    #####: 4997:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 4998:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 4999:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 5000:		buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5001:			       (unsigned long)(t2p->pdf_xrefcount + 3));
    #####: 5002:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5003:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5004:		written += t2pWriteFile(output, (tdata_t) " 0 R ", 5);
    #####: 5005:		written += t2pWriteFile(output, (tdata_t) "/Identity ] ", 12);
        -: 5006:	}
        -: 5007:
    #####: 5008:	written += t2pWriteFile(output, (tdata_t) " >> \n", 5);
        -: 5009:
    #####: 5010:	return(written);
        -: 5011:}
        -: 5012:
    #####: 5013:tsize_t t2p_write_pdf_transfer_dict(T2P* t2p, TIFF* output, uint16 i){
        -: 5014:
    #####: 5015:	tsize_t written=0;
    #####: 5016:	char buffer[32];
    #####: 5017:	int buflen=0;
        -: 5018:	(void)i; /* XXX */
        -: 5019:
    #####: 5020:	written += t2pWriteFile(output, (tdata_t) "/FunctionType 0 \n", 17);
    #####: 5021:	written += t2pWriteFile(output, (tdata_t) "/Domain [0.0 1.0] \n", 19);
    #####: 5022:	written += t2pWriteFile(output, (tdata_t) "/Range [0.0 1.0] \n", 18);
    #####: 5023:	buflen=snprintf(buffer, sizeof(buffer), "/Size [%u] \n", (1<<t2p->tiff_bitspersample));
    #####: 5024:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5025:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5026:	written += t2pWriteFile(output, (tdata_t) "/BitsPerSample 16 \n", 19);
    #####: 5027:	written += t2p_write_pdf_stream_dict(((tsize_t)1)<<(t2p->tiff_bitspersample+1), 0, output);
        -: 5028:
    #####: 5029:	return(written);
        -: 5030:}
        -: 5031:
    #####: 5032:tsize_t t2p_write_pdf_transfer_stream(T2P* t2p, TIFF* output, uint16 i){
        -: 5033:
    #####: 5034:	tsize_t written=0;
        -: 5035:
    #####: 5036:	written += t2p_write_pdf_stream(
    #####: 5037:		t2p->tiff_transferfunction[i], 
    #####: 5038:		(((tsize_t)1)<<(t2p->tiff_bitspersample+1)), 
        -: 5039:		output);
        -: 5040:
    #####: 5041:	return(written);
        -: 5042:}
        -: 5043:
        -: 5044:/*
        -: 5045:	This function writes a PDF Image XObject Colorspace array to output.
        -: 5046:*/
        -: 5047:
    #####: 5048:tsize_t t2p_write_pdf_xobject_calcs(T2P* t2p, TIFF* output){
        -: 5049:
    #####: 5050:	tsize_t written=0;
    #####: 5051:	char buffer[256];
    #####: 5052:	int buflen=0;
        -: 5053:	
    #####: 5054:	float X_W=0.0;
    #####: 5055:	float Y_W=0.0;
    #####: 5056:	float Z_W=0.0;
    #####: 5057:	float X_R=0.0;
    #####: 5058:	float Y_R=0.0;
    #####: 5059:	float Z_R=0.0;
    #####: 5060:	float X_G=0.0;
    #####: 5061:	float Y_G=0.0;
    #####: 5062:	float Z_G=0.0;
    #####: 5063:	float X_B=0.0;
    #####: 5064:	float Y_B=0.0;
    #####: 5065:	float Z_B=0.0;
    #####: 5066:	float x_w=0.0;
    #####: 5067:	float y_w=0.0;
    #####: 5068:	float z_w=0.0;
    #####: 5069:	float x_r=0.0;
    #####: 5070:	float y_r=0.0;
    #####: 5071:	float x_g=0.0;
    #####: 5072:	float y_g=0.0;
    #####: 5073:	float x_b=0.0;
    #####: 5074:	float y_b=0.0;
    #####: 5075:	float R=1.0;
    #####: 5076:	float G=1.0;
    #####: 5077:	float B=1.0;
        -: 5078:	
    #####: 5079:	written += t2pWriteFile(output, (tdata_t) "[", 1);
    #####: 5080:	if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 5081:		written += t2pWriteFile(output, (tdata_t) "/CalGray ", 9);
    #####: 5082:		X_W = t2p->tiff_whitechromaticities[0];
    #####: 5083:		Y_W = t2p->tiff_whitechromaticities[1];
    #####: 5084:		Z_W = 1.0F - (X_W + Y_W);
    #####: 5085:		X_W /= Y_W;
    #####: 5086:		Z_W /= Y_W;
    #####: 5087:		Y_W = 1.0F;
        -: 5088:	}
    #####: 5089:	if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 5090:		written += t2pWriteFile(output, (tdata_t) "/CalRGB ", 8);
    #####: 5091:		x_w = t2p->tiff_whitechromaticities[0];
    #####: 5092:		y_w = t2p->tiff_whitechromaticities[1];
    #####: 5093:		x_r = t2p->tiff_primarychromaticities[0];
    #####: 5094:		y_r = t2p->tiff_primarychromaticities[1];
    #####: 5095:		x_g = t2p->tiff_primarychromaticities[2];
    #####: 5096:		y_g = t2p->tiff_primarychromaticities[3];
    #####: 5097:		x_b = t2p->tiff_primarychromaticities[4];
    #####: 5098:		y_b = t2p->tiff_primarychromaticities[5];
    #####: 5099:		z_w = y_w * ((x_g - x_b)*y_r - (x_r-x_b)*y_g + (x_r-x_g)*y_b);
    #####: 5100:		Y_R = (y_r/R) * ((x_g-x_b)*y_w - (x_w-x_b)*y_g + (x_w-x_g)*y_b) / z_w;
    #####: 5101:		X_R = Y_R * x_r / y_r;
    #####: 5102:		Z_R = Y_R * (((1-x_r)/y_r)-1);
    #####: 5103:		Y_G = ((0.0F-(y_g))/G) * ((x_r-x_b)*y_w - (x_w-x_b)*y_r + (x_w-x_r)*y_b) / z_w;
    #####: 5104:		X_G = Y_G * x_g / y_g;
    #####: 5105:		Z_G = Y_G * (((1-x_g)/y_g)-1);
    #####: 5106:		Y_B = (y_b/B) * ((x_r-x_g)*y_w - (x_w-x_g)*y_r + (x_w-x_r)*y_g) / z_w;
    #####: 5107:		X_B = Y_B * x_b / y_b;
    #####: 5108:		Z_B = Y_B * (((1-x_b)/y_b)-1);
    #####: 5109:		X_W = (X_R * R) + (X_G * G) + (X_B * B);
    #####: 5110:		Y_W = (Y_R * R) + (Y_G * G) + (Y_B * B);
    #####: 5111:		Z_W = (Z_R * R) + (Z_G * G) + (Z_B * B);
    #####: 5112:		X_W /= Y_W;
    #####: 5113:		Z_W /= Y_W;
    #####: 5114:		Y_W = 1.0;
        -: 5115:	}
    #####: 5116:	written += t2pWriteFile(output, (tdata_t) "<< \n", 4);
    #####: 5117:	if(t2p->pdf_colorspace & T2P_CS_CALGRAY){
    #####: 5118:		written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
    #####: 5119:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
    #####: 5120:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5121:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5122:		written += t2pWriteFile(output, (tdata_t) "/Gamma 2.2 \n", 12);
        -: 5123:	}
    #####: 5124:	if(t2p->pdf_colorspace & T2P_CS_CALRGB){
    #####: 5125:		written += t2pWriteFile(output, (tdata_t) "/WhitePoint ", 12);
    #####: 5126:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f] \n", X_W, Y_W, Z_W);
    #####: 5127:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5128:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5129:		written += t2pWriteFile(output, (tdata_t) "/Matrix ", 8);
    #####: 5130:		buflen=snprintf(buffer, sizeof(buffer), "[%.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f %.4f] \n", 
        -: 5131:			X_R, Y_R, Z_R, 
        -: 5132:			X_G, Y_G, Z_G, 
        -: 5133:			X_B, Y_B, Z_B); 
    #####: 5134:		check_snprintf_ret(t2p, buflen, buffer);
    #####: 5135:		written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5136:		written += t2pWriteFile(output, (tdata_t) "/Gamma [2.2 2.2 2.2] \n", 22);
        -: 5137:	}
    #####: 5138:	written += t2pWriteFile(output, (tdata_t) ">>] \n", 5);
        -: 5139:
    #####: 5140:	return(written);
        -: 5141:}
        -: 5142:
        -: 5143:/*
        -: 5144:	This function writes a PDF Image XObject Colorspace array to output.
        -: 5145:*/
        -: 5146:
    #####: 5147:tsize_t t2p_write_pdf_xobject_icccs(T2P* t2p, TIFF* output){
        -: 5148:
    #####: 5149:	tsize_t written=0;
    #####: 5150:	char buffer[32];
    #####: 5151:	int buflen=0;
        -: 5152:	
    #####: 5153:	written += t2pWriteFile(output, (tdata_t) "[/ICCBased ", 11);
    #####: 5154:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_icccs);
    #####: 5155:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5156:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5157:	written += t2pWriteFile(output, (tdata_t) " 0 R] \n", 7);
        -: 5158:
    #####: 5159:	return(written);
        -: 5160:}
        -: 5161:
    #####: 5162:tsize_t t2p_write_pdf_xobject_icccs_dict(T2P* t2p, TIFF* output){
        -: 5163:
    #####: 5164:	tsize_t written=0;
    #####: 5165:	char buffer[32];
    #####: 5166:	int buflen=0;
        -: 5167:	
    #####: 5168:	written += t2pWriteFile(output, (tdata_t) "/N ", 3);
    #####: 5169:	buflen=snprintf(buffer, sizeof(buffer), "%u \n", t2p->tiff_samplesperpixel);
    #####: 5170:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5171:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5172:	written += t2pWriteFile(output, (tdata_t) "/Alternate ", 11);
    #####: 5173:	t2p->pdf_colorspace ^= T2P_CS_ICCBASED;
    #####: 5174:	written += t2p_write_pdf_xobject_cs(t2p, output);
    #####: 5175:	t2p->pdf_colorspace |= T2P_CS_ICCBASED;
    #####: 5176:	written += t2p_write_pdf_stream_dict(t2p->tiff_iccprofilelength, 0, output);
        -: 5177:	
    #####: 5178:	return(written);
        -: 5179:}
        -: 5180:
    #####: 5181:tsize_t t2p_write_pdf_xobject_icccs_stream(T2P* t2p, TIFF* output){
        -: 5182:
    #####: 5183:	tsize_t written=0;
        -: 5184:
    #####: 5185:	written += t2p_write_pdf_stream(
    #####: 5186:				(tdata_t) t2p->tiff_iccprofile, 
    #####: 5187:				(tsize_t) t2p->tiff_iccprofilelength, 
        -: 5188:				output);
        -: 5189:	
    #####: 5190:	return(written);
        -: 5191:}
        -: 5192:
        -: 5193:/*
        -: 5194:	This function writes a palette stream for an indexed color space to output.
        -: 5195:*/
        -: 5196:
    #####: 5197:tsize_t t2p_write_pdf_xobject_palettecs_stream(T2P* t2p, TIFF* output){
        -: 5198:
    #####: 5199:	tsize_t written=0;
        -: 5200:
    #####: 5201:	written += t2p_write_pdf_stream(
    #####: 5202:				(tdata_t) t2p->pdf_palette, 
    #####: 5203:				(tsize_t) t2p->pdf_palettesize, 
        -: 5204:				output);
        -: 5205:	
    #####: 5206:	return(written);
        -: 5207:}
        -: 5208:
        -: 5209:/*
        -: 5210:	This function writes a PDF Image XObject Decode array to output.
        -: 5211:*/
        -: 5212:
    #####: 5213:tsize_t t2p_write_pdf_xobject_decode(T2P* t2p, TIFF* output){
        -: 5214:
    #####: 5215:	tsize_t written=0;
    #####: 5216:	int i=0;
        -: 5217:
    #####: 5218:	written += t2pWriteFile(output, (tdata_t) "/Decode [ ", 10);
    #####: 5219:	for (i=0;i<t2p->tiff_samplesperpixel;i++){
    #####: 5220:		written += t2pWriteFile(output, (tdata_t) "1 0 ", 4);
        -: 5221:	}
    #####: 5222:	written += t2pWriteFile(output, (tdata_t) "]\n", 2);
        -: 5223:
    #####: 5224:	return(written);
        -: 5225:}
        -: 5226:
        -: 5227:/*
        -: 5228:	This function writes a PDF Image XObject stream filter name and parameters to 
        -: 5229:	output.
        -: 5230:*/
        -: 5231:
        1: 5232:tsize_t t2p_write_pdf_xobject_stream_filter(ttile_t tile, T2P* t2p, TIFF* output){
        -: 5233:
        1: 5234:	tsize_t written=0;
        1: 5235:	char buffer[32];
        1: 5236:	int buflen=0;
        -: 5237:
        1: 5238:	if(t2p->pdf_compression==T2P_COMPRESS_NONE){
    #####: 5239:		return(written);
        -: 5240:	}
        1: 5241:	written += t2pWriteFile(output, (tdata_t) "/Filter ", 8);
        1: 5242:	switch(t2p->pdf_compression){
        -: 5243:#ifdef CCITT_SUPPORT
    #####: 5244:		case T2P_COMPRESS_G4:
    #####: 5245:			written += t2pWriteFile(output, (tdata_t) "/CCITTFaxDecode ", 16);
    #####: 5246:			written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
    #####: 5247:			written += t2pWriteFile(output, (tdata_t) "<< /K -1 ", 9);
    #####: 5248:			if(tile==0){
    #####: 5249:				written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5250:				buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5251:					       (unsigned long)t2p->tiff_width);
    #####: 5252:				check_snprintf_ret(t2p, buflen, buffer);
    #####: 5253:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5254:				written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5255:				buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5256:					       (unsigned long)t2p->tiff_length);
    #####: 5257:				check_snprintf_ret(t2p, buflen, buffer);
    #####: 5258:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5259:			} else {
    #####: 5260:				if(t2p_tile_is_right_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){
    #####: 5261:					written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5262:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5263:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilewidth);
    #####: 5264:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5265:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5266:				} else {
    #####: 5267:					written += t2pWriteFile(output, (tdata_t) "/Columns ", 9);
    #####: 5268:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5269:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilewidth);
    #####: 5270:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5271:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5272:				}
    #####: 5273:				if(t2p_tile_is_bottom_edge(t2p->tiff_tiles[t2p->pdf_page], tile-1)==0){
    #####: 5274:					written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5275:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5276:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_tilelength);
    #####: 5277:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5278:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5279:				} else {
    #####: 5280:					written += t2pWriteFile(output, (tdata_t) " /Rows ", 7);
    #####: 5281:					buflen=snprintf(buffer, sizeof(buffer), "%lu",
    #####: 5282:						(unsigned long)t2p->tiff_tiles[t2p->pdf_page].tiles_edgetilelength);
    #####: 5283:					check_snprintf_ret(t2p, buflen, buffer);
    #####: 5284:					written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5285:				}
        -: 5286:			}
    #####: 5287:			if(t2p->pdf_switchdecode == 0){
    #####: 5288:				written += t2pWriteFile(output, (tdata_t) " /BlackIs1 true ", 16);
        -: 5289:			}
    #####: 5290:			written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
    #####: 5291:			break;
        -: 5292:#endif
        -: 5293:#ifdef JPEG_SUPPORT
        1: 5294:		case T2P_COMPRESS_JPEG:
        1: 5295:			written += t2pWriteFile(output, (tdata_t) "/DCTDecode ", 11);
        -: 5296:
        1: 5297:			if(t2p->tiff_photometric != PHOTOMETRIC_YCBCR) {
        1: 5298:				written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
        1: 5299:				written += t2pWriteFile(output, (tdata_t) "<< /ColorTransform 1 >>\n", 24);
        -: 5300:			}
        1: 5301:			break;
        -: 5302:#endif
        -: 5303:#ifdef ZIP_SUPPORT
        -: 5304:		case T2P_COMPRESS_ZIP:
        -: 5305:			written += t2pWriteFile(output, (tdata_t) "/FlateDecode ", 13);
        -: 5306:			if(t2p->pdf_compressionquality%100){
        -: 5307:				written += t2pWriteFile(output, (tdata_t) "/DecodeParms ", 13);
        -: 5308:				written += t2pWriteFile(output, (tdata_t) "<< /Predictor ", 14);
        -: 5309:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->pdf_compressionquality%100);
        -: 5310:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5311:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5312:				written += t2pWriteFile(output, (tdata_t) " /Columns ", 10);
        -: 5313:				buflen = snprintf(buffer, sizeof(buffer), "%lu",
        -: 5314:						 (unsigned long)t2p->tiff_width);
        -: 5315:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5316:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5317:				written += t2pWriteFile(output, (tdata_t) " /Colors ", 9);
        -: 5318:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_samplesperpixel);
        -: 5319:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5320:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5321:				written += t2pWriteFile(output, (tdata_t) " /BitsPerComponent ", 19);
        -: 5322:				buflen=snprintf(buffer, sizeof(buffer), "%u", t2p->tiff_bitspersample);
        -: 5323:				check_snprintf_ret(t2p, buflen, buffer);
        -: 5324:				written += t2pWriteFile(output, (tdata_t) buffer, buflen);
        -: 5325:				written += t2pWriteFile(output, (tdata_t) ">>\n", 3);
        -: 5326:			}
        -: 5327:			break;
        -: 5328:#endif
    #####: 5329:		default:
    #####: 5330:			break;
        -: 5331:	}
        -: 5332:
        1: 5333:	return(written);
        -: 5334:}
        -: 5335:
        -: 5336:/*
        -: 5337:	This function writes a PDF xref table to output.
        -: 5338:*/
        -: 5339:
    #####: 5340:tsize_t t2p_write_pdf_xreftable(T2P* t2p, TIFF* output){
        -: 5341:
    #####: 5342:	tsize_t written=0;
    #####: 5343:	char buffer[64];
    #####: 5344:	int buflen=0;
    #####: 5345:	uint32 i=0;
        -: 5346:
    #####: 5347:	written += t2pWriteFile(output, (tdata_t) "xref\n0 ", 7);
    #####: 5348:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(t2p->pdf_xrefcount + 1));
    #####: 5349:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5350:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5351:	written += t2pWriteFile(output, (tdata_t) " \n0000000000 65535 f \n", 22);
    #####: 5352:	for (i=0;i<t2p->pdf_xrefcount;i++){
    #####: 5353:		snprintf(buffer, sizeof(buffer), "%.10lu 00000 n \n",
    #####: 5354:			(unsigned long)t2p->pdf_xrefoffsets[i]);
    #####: 5355:		written += t2pWriteFile(output, (tdata_t) buffer, 20);
        -: 5356:	}
        -: 5357:
    #####: 5358:	return(written);
        -: 5359:}
        -: 5360:
        -: 5361:/*
        -: 5362: * This function writes a PDF trailer to output.
        -: 5363: */
        -: 5364:
    #####: 5365:tsize_t t2p_write_pdf_trailer(T2P* t2p, TIFF* output)
        -: 5366:{
        -: 5367:
    #####: 5368:	tsize_t written = 0;
    #####: 5369:	char buffer[32];
    #####: 5370:	int buflen = 0;
    #####: 5371:	size_t i = 0;
        -: 5372:
    #####: 5373:	for (i = 0; i < sizeof(t2p->pdf_fileid) - 8; i += 8)
    #####: 5374:		snprintf(t2p->pdf_fileid + i, 9, "%.8X", rand());
        -: 5375:
    #####: 5376:	written += t2pWriteFile(output, (tdata_t) "trailer\n<<\n/Size ", 17);
    #####: 5377:	buflen = snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)(t2p->pdf_xrefcount+1));
    #####: 5378:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5379:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5380:	written += t2pWriteFile(output, (tdata_t) "\n/Root ", 7);
    #####: 5381:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_catalog);
    #####: 5382:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5383:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5384:	written += t2pWriteFile(output, (tdata_t) " 0 R \n/Info ", 12);
    #####: 5385:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_info);
    #####: 5386:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5387:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5388:	written += t2pWriteFile(output, (tdata_t) " 0 R \n/ID[<", 11);
    #####: 5389:	written += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,
        -: 5390:				sizeof(t2p->pdf_fileid) - 1);
    #####: 5391:	written += t2pWriteFile(output, (tdata_t) "><", 2);
    #####: 5392:	written += t2pWriteFile(output, (tdata_t) t2p->pdf_fileid,
        -: 5393:				sizeof(t2p->pdf_fileid) - 1);
    #####: 5394:	written += t2pWriteFile(output, (tdata_t) ">]\n>>\nstartxref\n", 16);
    #####: 5395:	buflen=snprintf(buffer, sizeof(buffer), "%lu", (unsigned long)t2p->pdf_startxref);
    #####: 5396:	check_snprintf_ret(t2p, buflen, buffer);
    #####: 5397:	written += t2pWriteFile(output, (tdata_t) buffer, buflen);
    #####: 5398:	written += t2pWriteFile(output, (tdata_t) "\n%%EOF\n", 7);
        -: 5399:
    #####: 5400:	return(written);
        -: 5401:}
        -: 5402: 
        -: 5403:/*
        -: 5404:
        -: 5405:  This function writes a PDF to a file given a pointer to a TIFF.
        -: 5406:
        -: 5407:  The idea with using a TIFF* as output for a PDF file is that the file 
        -: 5408:  can be created with TIFFClientOpen for memory-mapped use within the TIFF 
        -: 5409:  library, and TIFFWriteEncodedStrip can be used to write compressed data to 
        -: 5410:  the output.  The output is not actually a TIFF file, it is a PDF file.  
        -: 5411:
        -: 5412:  This function uses only t2pWriteFile and TIFFWriteEncodedStrip to write to 
        -: 5413:  the output TIFF file.  When libtiff would otherwise be writing data to the 
        -: 5414:  output file, the write procedure of the TIFF structure is replaced with an 
        -: 5415:  empty implementation.
        -: 5416:
        -: 5417:  The first argument to the function is an initialized and validated T2P 
        -: 5418:  context struct pointer.
        -: 5419:
        -: 5420:  The second argument to the function is the TIFF* that is the input that has 
        -: 5421:  been opened for reading and no other functions have been called upon it.
        -: 5422:
        -: 5423:  The third argument to the function is the TIFF* that is the output that has 
        -: 5424:  been opened for writing.  It has to be opened so that it hasn't written any 
        -: 5425:  data to the output.  If the output is seekable then it's OK to seek to the 
        -: 5426:  beginning of the file.  The function only writes to the output PDF and does 
        -: 5427:  not seek.  See the example usage in the main() function.
        -: 5428:
        -: 5429:	TIFF* output = TIFFOpen("output.pdf", "w");
        -: 5430:	assert(output != NULL);
        -: 5431:
        -: 5432:	if(output->tif_seekproc != NULL){
        -: 5433:		t2pSeekFile(output, (toff_t) 0, SEEK_SET);
        -: 5434:	}
        -: 5435:
        -: 5436:  This function returns the file size of the output PDF file.  On error it 
        -: 5437:  returns zero and the t2p->t2p_error variable is set to T2P_ERR_ERROR.
        -: 5438:
        -: 5439:  After this function completes, call t2p_free on t2p, TIFFClose on input, 
        -: 5440:  and TIFFClose on output.
        -: 5441:*/
        -: 5442:
        1: 5443:tsize_t t2p_write_pdf(T2P* t2p, TIFF* input, TIFF* output){
        -: 5444:
        1: 5445:	tsize_t written=0;
        1: 5446:	ttile_t i2=0;
        1: 5447:	tsize_t streamlen=0;
        1: 5448:	uint16 i=0;
        -: 5449:
        1: 5450:	t2p_read_tiff_init(t2p, input);
       1*: 5451:	if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
       1*: 5452:	t2p->pdf_xrefoffsets= (uint32*) _TIFFmalloc(TIFFSafeMultiply(tmsize_t,t2p->pdf_xrefcount,sizeof(uint32)) );
        1: 5453:	if(t2p->pdf_xrefoffsets==NULL){
    #####: 5454:		TIFFError(
        -: 5455:			TIFF2PDF_MODULE, 
        -: 5456:			"Can't allocate %u bytes of memory for t2p_write_pdf", 
    #####: 5457:			(unsigned int) (t2p->pdf_xrefcount * sizeof(uint32)) );
    #####: 5458:		t2p->t2p_error = T2P_ERR_ERROR;
    #####: 5459:		return(written);
        -: 5460:	}
        1: 5461:	t2p->pdf_xrefcount=0;
        1: 5462:	t2p->pdf_catalog=1;
        1: 5463:	t2p->pdf_info=2;
        1: 5464:	t2p->pdf_pages=3;
        1: 5465:	written += t2p_write_pdf_header(t2p, output);
        1: 5466:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
        1: 5467:	t2p->pdf_catalog=t2p->pdf_xrefcount;
        1: 5468:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
        1: 5469:	written += t2p_write_pdf_catalog(t2p, output);
        1: 5470:	written += t2p_write_pdf_obj_end(output);
        1: 5471:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
        1: 5472:	t2p->pdf_info=t2p->pdf_xrefcount;
        1: 5473:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
        1: 5474:	written += t2p_write_pdf_info(t2p, input, output);
        1: 5475:	written += t2p_write_pdf_obj_end(output);
        1: 5476:	t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
        1: 5477:	t2p->pdf_pages=t2p->pdf_xrefcount;
        1: 5478:	written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
        1: 5479:	written += t2p_write_pdf_pages(t2p, output);
        1: 5480:	written += t2p_write_pdf_obj_end(output);
       1*: 5481:	for(t2p->pdf_page=0;t2p->pdf_page<t2p->tiff_pagecount;t2p->pdf_page++){
        1: 5482:		t2p_read_tiff_data(t2p, input);
       1*: 5483:		if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
        1: 5484:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
        1: 5485:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
        1: 5486:		written += t2p_write_pdf_page(t2p->pdf_xrefcount, t2p, output);
        1: 5487:		written += t2p_write_pdf_obj_end(output);
        1: 5488:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
        1: 5489:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
        1: 5490:		written += t2p_write_pdf_stream_dict_start(output);
        1: 5491:		written += t2p_write_pdf_stream_dict(0, t2p->pdf_xrefcount+1, output);
        1: 5492:		written += t2p_write_pdf_stream_dict_end(output);
        1: 5493:		written += t2p_write_pdf_stream_start(output);
        1: 5494:		streamlen=written;
        1: 5495:		written += t2p_write_pdf_page_content_stream(t2p, output);
        1: 5496:		streamlen=written-streamlen;
        1: 5497:		written += t2p_write_pdf_stream_end(output);
        1: 5498:		written += t2p_write_pdf_obj_end(output);
        1: 5499:		t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
        1: 5500:		written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
        1: 5501:		written += t2p_write_pdf_stream_length(streamlen, output);
        1: 5502:		written += t2p_write_pdf_obj_end(output);
        1: 5503:		if(t2p->tiff_transferfunctioncount != 0){
    #####: 5504:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5505:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5506:			written += t2p_write_pdf_transfer(t2p, output);
    #####: 5507:			written += t2p_write_pdf_obj_end(output);
    #####: 5508:			for(i=0; i < t2p->tiff_transferfunctioncount; i++){
    #####: 5509:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5510:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5511:				written += t2p_write_pdf_stream_dict_start(output);
    #####: 5512:				written += t2p_write_pdf_transfer_dict(t2p, output, i);
    #####: 5513:				written += t2p_write_pdf_stream_dict_end(output);
    #####: 5514:				written += t2p_write_pdf_stream_start(output);
        -: 5515:				/* streamlen=written; */ /* value not used */
    #####: 5516:				written += t2p_write_pdf_transfer_stream(t2p, output, i);
        -: 5517:				/* streamlen=written-streamlen; */ /* value not used */
    #####: 5518:				written += t2p_write_pdf_stream_end(output);
    #####: 5519:				written += t2p_write_pdf_obj_end(output);
        -: 5520:			}
        -: 5521:		}
        1: 5522:		if( (t2p->pdf_colorspace & T2P_CS_PALETTE) != 0){
    #####: 5523:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5524:			t2p->pdf_palettecs=t2p->pdf_xrefcount;
    #####: 5525:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5526:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5527:			written += t2p_write_pdf_stream_dict(t2p->pdf_palettesize, 0, output);
    #####: 5528:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5529:			written += t2p_write_pdf_stream_start(output);
        -: 5530:			/* streamlen=written; */ /* value not used */
    #####: 5531:			written += t2p_write_pdf_xobject_palettecs_stream(t2p, output);
        -: 5532:			/* streamlen=written-streamlen; */ /* value not used */
    #####: 5533:			written += t2p_write_pdf_stream_end(output);
    #####: 5534:			written += t2p_write_pdf_obj_end(output);
        -: 5535:		}
        1: 5536:		if( (t2p->pdf_colorspace & T2P_CS_ICCBASED) != 0){
    #####: 5537:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5538:			t2p->pdf_icccs=t2p->pdf_xrefcount;
    #####: 5539:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5540:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5541:			written += t2p_write_pdf_xobject_icccs_dict(t2p, output);
    #####: 5542:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5543:			written += t2p_write_pdf_stream_start(output);
        -: 5544:			/* streamlen=written; */ /* value not used */
    #####: 5545:			written += t2p_write_pdf_xobject_icccs_stream(t2p, output);
        -: 5546:			/* streamlen=written-streamlen; */ /* value not used */
    #####: 5547:			written += t2p_write_pdf_stream_end(output);
    #####: 5548:			written += t2p_write_pdf_obj_end(output);
        -: 5549:		}
        1: 5550:		if(t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount !=0){
       1*: 5551:			for(i2=0;i2<t2p->tiff_tiles[t2p->pdf_page].tiles_tilecount;i2++){
        1: 5552:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
        1: 5553:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
        1: 5554:				written += t2p_write_pdf_stream_dict_start(output);
        1: 5555:				written += t2p_write_pdf_xobject_stream_dict(
        -: 5556:					i2+1, 
        -: 5557:					t2p, 
        -: 5558:					output);
        1: 5559:				written += t2p_write_pdf_stream_dict_end(output);
        1: 5560:				written += t2p_write_pdf_stream_start(output);
        1: 5561:				streamlen=written;
        1: 5562:				t2p_read_tiff_size_tile(t2p, input, i2);
       1*: 5563:				written += t2p_readwrite_pdf_image_tile(t2p, input, output, i2);
    #####: 5564:				t2p_write_advance_directory(t2p, output);
    #####: 5565:				if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5566:				streamlen=written-streamlen;
    #####: 5567:				written += t2p_write_pdf_stream_end(output);
    #####: 5568:				written += t2p_write_pdf_obj_end(output);
    #####: 5569:				t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5570:				written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5571:				written += t2p_write_pdf_stream_length(streamlen, output);
    #####: 5572:				written += t2p_write_pdf_obj_end(output);
        -: 5573:			}
        -: 5574:		} else {
    #####: 5575:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5576:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5577:			written += t2p_write_pdf_stream_dict_start(output);
    #####: 5578:			written += t2p_write_pdf_xobject_stream_dict(
        -: 5579:				0, 
        -: 5580:				t2p, 
        -: 5581:				output);
    #####: 5582:			written += t2p_write_pdf_stream_dict_end(output);
    #####: 5583:			written += t2p_write_pdf_stream_start(output);
    #####: 5584:			streamlen=written;
    #####: 5585:			t2p_read_tiff_size(t2p, input);
    #####: 5586:			written += t2p_readwrite_pdf_image(t2p, input, output);
    #####: 5587:			t2p_write_advance_directory(t2p, output);
    #####: 5588:			if(t2p->t2p_error!=T2P_ERR_OK){return(0);}
    #####: 5589:			streamlen=written-streamlen;
    #####: 5590:			written += t2p_write_pdf_stream_end(output);
    #####: 5591:			written += t2p_write_pdf_obj_end(output);
    #####: 5592:			t2p->pdf_xrefoffsets[t2p->pdf_xrefcount++]=written;
    #####: 5593:			written += t2p_write_pdf_obj_start(t2p->pdf_xrefcount, output);
    #####: 5594:			written += t2p_write_pdf_stream_length(streamlen, output);
    #####: 5595:			written += t2p_write_pdf_obj_end(output);
        -: 5596:		}
        -: 5597:	}
    #####: 5598:	t2p->pdf_startxref = written;
    #####: 5599:	written += t2p_write_pdf_xreftable(t2p, output);
    #####: 5600:	written += t2p_write_pdf_trailer(t2p, output);
    #####: 5601:	t2p_disable(output);
        -: 5602:
    #####: 5603:	return(written);
        -: 5604:}
        -: 5605:
        -: 5606:/* vim: set ts=8 sts=8 sw=8 noet: */
        -: 5607:/*
        -: 5608: * Local Variables:
        -: 5609: * mode: c
        -: 5610: * c-basic-offset: 8
        -: 5611: * fill-column: 78
        -: 5612: * End:
        -: 5613: */
