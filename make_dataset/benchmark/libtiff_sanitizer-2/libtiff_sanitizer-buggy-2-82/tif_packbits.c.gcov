        -:    0:Source:tif_packbits.c
        -:    1:/* $Id$ */
        -:    2:
        -:    3:/*
        -:    4: * Copyright (c) 1988-1997 Sam Leffler
        -:    5: * Copyright (c) 1991-1997 Silicon Graphics, Inc.
        -:    6: *
        -:    7: * Permission to use, copy, modify, distribute, and sell this software and 
        -:    8: * its documentation for any purpose is hereby granted without fee, provided
        -:    9: * that (i) the above copyright notices and this permission notice appear in
        -:   10: * all copies of the software and related documentation, and (ii) the names of
        -:   11: * Sam Leffler and Silicon Graphics may not be used in any advertising or
        -:   12: * publicity relating to the software without the specific, prior written
        -:   13: * permission of Sam Leffler and Silicon Graphics.
        -:   14: * 
        -:   15: * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
        -:   16: * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
        -:   17: * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
        -:   18: * 
        -:   19: * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
        -:   20: * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
        -:   21: * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
        -:   22: * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
        -:   23: * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
        -:   24: * OF THIS SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:#include "tiffiop.h"
        -:   28:#ifdef PACKBITS_SUPPORT
        -:   29:/*
        -:   30: * TIFF Library.
        -:   31: *
        -:   32: * PackBits Compression Algorithm Support
        -:   33: */
        -:   34:#include <stdio.h>
        -:   35:
        -:   36:static int
    #####:   37:PackBitsPreEncode(TIFF* tif, uint16 s)
        -:   38:{
        -:   39:	(void) s;
        -:   40:
    #####:   41:        tif->tif_data = (uint8*)_TIFFmalloc(sizeof(tmsize_t));
    #####:   42:	if (tif->tif_data == NULL)
    #####:   43:		return (0);
        -:   44:	/*
        -:   45:	 * Calculate the scanline/tile-width size in bytes.
        -:   46:	 */
    #####:   47:	if (isTiled(tif))
    #####:   48:		*(tmsize_t*)tif->tif_data = TIFFTileRowSize(tif);
        -:   49:	else
    #####:   50:		*(tmsize_t*)tif->tif_data = TIFFScanlineSize(tif);
    #####:   51:	return (1);
        -:   52:}
        -:   53:
        -:   54:static int
    #####:   55:PackBitsPostEncode(TIFF* tif)
        -:   56:{
    #####:   57:        if (tif->tif_data)
    #####:   58:            _TIFFfree(tif->tif_data);
    #####:   59:	return (1);
        -:   60:}
        -:   61:
        -:   62:/*
        -:   63: * Encode a run of pixels.
        -:   64: */
        -:   65:static int
    #####:   66:PackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s)
        -:   67:{
    #####:   68:	unsigned char* bp = (unsigned char*) buf;
        -:   69:	uint8* op;
        -:   70:	uint8* ep;
        -:   71:	uint8* lastliteral;
        -:   72:	long n, slop;
        -:   73:	int b;
        -:   74:	enum { BASE, LITERAL, RUN, LITERAL_RUN } state;
        -:   75:
        -:   76:	(void) s;
    #####:   77:	op = tif->tif_rawcp;
    #####:   78:	ep = tif->tif_rawdata + tif->tif_rawdatasize;
    #####:   79:	state = BASE;
    #####:   80:	lastliteral = 0;
    #####:   81:	while (cc > 0) {
        -:   82:		/*
        -:   83:		 * Find the longest string of identical bytes.
        -:   84:		 */
    #####:   85:		b = *bp++;
    #####:   86:		cc--;
    #####:   87:		n = 1;
    #####:   88:		for (; cc > 0 && b == *bp; cc--, bp++)
    #####:   89:			n++;
    #####:   90:	again:
    #####:   91:		if (op + 2 >= ep) {		/* insure space for new data */
        -:   92:			/*
        -:   93:			 * Be careful about writing the last
        -:   94:			 * literal.  Must write up to that point
        -:   95:			 * and then copy the remainder to the
        -:   96:			 * front of the buffer.
        -:   97:			 */
    #####:   98:			if (state == LITERAL || state == LITERAL_RUN) {
    #####:   99:				slop = (long)(op - lastliteral);
    #####:  100:				tif->tif_rawcc += (tmsize_t)(lastliteral - tif->tif_rawcp);
    #####:  101:				if (!TIFFFlushData1(tif))
    #####:  102:					return (-1);
    #####:  103:				op = tif->tif_rawcp;
    #####:  104:				while (slop-- > 0)
    #####:  105:					*op++ = *lastliteral++;
    #####:  106:				lastliteral = tif->tif_rawcp;
        -:  107:			} else {
    #####:  108:				tif->tif_rawcc += (tmsize_t)(op - tif->tif_rawcp);
    #####:  109:				if (!TIFFFlushData1(tif))
    #####:  110:					return (-1);
    #####:  111:				op = tif->tif_rawcp;
        -:  112:			}
        -:  113:		}
    #####:  114:		switch (state) {
    #####:  115:		case BASE:		/* initial state, set run/literal */
    #####:  116:			if (n > 1) {
    #####:  117:				state = RUN;
    #####:  118:				if (n > 128) {
    #####:  119:					*op++ = (uint8) -127;
    #####:  120:					*op++ = (uint8) b;
    #####:  121:					n -= 128;
    #####:  122:					goto again;
        -:  123:				}
    #####:  124:				*op++ = (uint8)(-(n-1));
    #####:  125:				*op++ = (uint8) b;
        -:  126:			} else {
    #####:  127:				lastliteral = op;
    #####:  128:				*op++ = 0;
    #####:  129:				*op++ = (uint8) b;
    #####:  130:				state = LITERAL;
        -:  131:			}
    #####:  132:			break;
    #####:  133:		case LITERAL:		/* last object was literal string */
    #####:  134:			if (n > 1) {
    #####:  135:				state = LITERAL_RUN;
    #####:  136:				if (n > 128) {
    #####:  137:					*op++ = (uint8) -127;
    #####:  138:					*op++ = (uint8) b;
    #####:  139:					n -= 128;
    #####:  140:					goto again;
        -:  141:				}
    #####:  142:				*op++ = (uint8)(-(n-1));	/* encode run */
    #####:  143:				*op++ = (uint8) b;
        -:  144:			} else {			/* extend literal */
    #####:  145:				if (++(*lastliteral) == 127)
    #####:  146:					state = BASE;
    #####:  147:				*op++ = (uint8) b;
        -:  148:			}
    #####:  149:			break;
    #####:  150:		case RUN:		/* last object was run */
    #####:  151:			if (n > 1) {
    #####:  152:				if (n > 128) {
    #####:  153:					*op++ = (uint8) -127;
    #####:  154:					*op++ = (uint8) b;
    #####:  155:					n -= 128;
    #####:  156:					goto again;
        -:  157:				}
    #####:  158:				*op++ = (uint8)(-(n-1));
    #####:  159:				*op++ = (uint8) b;
        -:  160:			} else {
    #####:  161:				lastliteral = op;
    #####:  162:				*op++ = 0;
    #####:  163:				*op++ = (uint8) b;
    #####:  164:				state = LITERAL;
        -:  165:			}
    #####:  166:			break;
    #####:  167:		case LITERAL_RUN:	/* literal followed by a run */
        -:  168:			/*
        -:  169:			 * Check to see if previous run should
        -:  170:			 * be converted to a literal, in which
        -:  171:			 * case we convert literal-run-literal
        -:  172:			 * to a single literal.
        -:  173:			 */
    #####:  174:			if (n == 1 && op[-2] == (uint8) -1 &&
    #####:  175:			    *lastliteral < 126) {
    #####:  176:				state = (((*lastliteral) += 2) == 127 ?
    #####:  177:				    BASE : LITERAL);
    #####:  178:				op[-2] = op[-1];	/* replicate */
        -:  179:			} else
    #####:  180:				state = RUN;
    #####:  181:			goto again;
        -:  182:		}
    #####:  183:	}
    #####:  184:	tif->tif_rawcc += (tmsize_t)(op - tif->tif_rawcp);
    #####:  185:	tif->tif_rawcp = op;
    #####:  186:	return (1);
        -:  187:}
        -:  188:
        -:  189:/*
        -:  190: * Encode a rectangular chunk of pixels.  We break it up
        -:  191: * into row-sized pieces to insure that encoded runs do
        -:  192: * not span rows.  Otherwise, there can be problems with
        -:  193: * the decoder if data is read, for example, by scanlines
        -:  194: * when it was encoded by strips.
        -:  195: */
        -:  196:static int
    #####:  197:PackBitsEncodeChunk(TIFF* tif, uint8* bp, tmsize_t cc, uint16 s)
        -:  198:{
    #####:  199:	tmsize_t rowsize = *(tmsize_t*)tif->tif_data;
        -:  200:
    #####:  201:	while (cc > 0) {
    #####:  202:		tmsize_t chunk = rowsize;
        -:  203:		
    #####:  204:		if( cc < chunk )
    #####:  205:		    chunk = cc;
        -:  206:
    #####:  207:		if (PackBitsEncode(tif, bp, chunk, s) < 0)
    #####:  208:		    return (-1);
    #####:  209:		bp += chunk;
    #####:  210:		cc -= chunk;
        -:  211:	}
    #####:  212:	return (1);
        -:  213:}
        -:  214:
        -:  215:static int
    #####:  216:PackBitsDecode(TIFF* tif, uint8* op, tmsize_t occ, uint16 s)
        -:  217:{
        -:  218:	static const char module[] = "PackBitsDecode";
        -:  219:	char *bp;
        -:  220:	tmsize_t cc;
        -:  221:	long n;
        -:  222:	int b;
        -:  223:
        -:  224:	(void) s;
    #####:  225:	bp = (char*) tif->tif_rawcp;
    #####:  226:	cc = tif->tif_rawcc;
    #####:  227:	while (cc > 0 && occ > 0) {
    #####:  228:		n = (long) *bp++;
    #####:  229:		cc--;
        -:  230:		/*
        -:  231:		 * Watch out for compilers that
        -:  232:		 * don't sign extend chars...
        -:  233:		 */
    #####:  234:		if (n >= 128)
    #####:  235:			n -= 256;
    #####:  236:		if (n < 0) {		/* replicate next byte -n+1 times */
    #####:  237:			if (n == -128)	/* nop */
    #####:  238:				continue;
    #####:  239:			n = -n + 1;
    #####:  240:			if( occ < (tmsize_t)n )
        -:  241:			{
    #####:  242:				TIFFWarningExt(tif->tif_clientdata, module,
        -:  243:				    "Discarding %lu bytes to avoid buffer overrun",
    #####:  244:				    (unsigned long) ((tmsize_t)n - occ));
    #####:  245:				n = (long)occ;
        -:  246:			}
    #####:  247:			occ -= n;
    #####:  248:			b = *bp++;
    #####:  249:			cc--;
    #####:  250:			while (n-- > 0)
    #####:  251:				*op++ = (uint8) b;
        -:  252:		} else {		/* copy next n+1 bytes literally */
    #####:  253:			if (occ < (tmsize_t)(n + 1))
        -:  254:			{
    #####:  255:				TIFFWarningExt(tif->tif_clientdata, module,
        -:  256:				    "Discarding %lu bytes to avoid buffer overrun",
    #####:  257:				    (unsigned long) ((tmsize_t)n - occ + 1));
    #####:  258:				n = (long)occ - 1;
        -:  259:			}
    #####:  260:			if (cc < (tmsize_t) (n+1)) 
        -:  261:			{
    #####:  262:				TIFFWarningExt(tif->tif_clientdata, module,
        -:  263:					       "Terminating PackBitsDecode due to lack of data.");
    #####:  264:				break;
        -:  265:			}
    #####:  266:			_TIFFmemcpy(op, bp, ++n);
    #####:  267:			op += n; occ -= n;
    #####:  268:			bp += n; cc -= n;
        -:  269:		}
        -:  270:	}
    #####:  271:	tif->tif_rawcp = (uint8*) bp;
    #####:  272:	tif->tif_rawcc = cc;
    #####:  273:	if (occ > 0) {
    #####:  274:		TIFFErrorExt(tif->tif_clientdata, module,
        -:  275:		    "Not enough data for scanline %lu",
    #####:  276:		    (unsigned long) tif->tif_row);
    #####:  277:		return (0);
        -:  278:	}
    #####:  279:	return (1);
        -:  280:}
        -:  281:
        -:  282:int
    #####:  283:TIFFInitPackBits(TIFF* tif, int scheme)
        -:  284:{
        -:  285:	(void) scheme;
    #####:  286:	tif->tif_decoderow = PackBitsDecode;
    #####:  287:	tif->tif_decodestrip = PackBitsDecode;
    #####:  288:	tif->tif_decodetile = PackBitsDecode;
    #####:  289:	tif->tif_preencode = PackBitsPreEncode;
    #####:  290:	tif->tif_postencode = PackBitsPostEncode;
    #####:  291:	tif->tif_encoderow = PackBitsEncode;
    #####:  292:	tif->tif_encodestrip = PackBitsEncodeChunk;
    #####:  293:	tif->tif_encodetile = PackBitsEncodeChunk;
    #####:  294:	return (1);
        -:  295:}
        -:  296:#endif /* PACKBITS_SUPPORT */
        -:  297:
        -:  298:/* vim: set ts=8 sts=8 sw=8 noet: */
        -:  299:/*
        -:  300: * Local Variables:
        -:  301: * mode: c
        -:  302: * c-basic-offset: 8
        -:  303: * fill-column: 78
        -:  304: * End:
        -:  305: */
