        -:    0:Source:/home/workspace/jerry-core/parser/js/common.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "common.h"
        -:   17:#include "ecma-helpers.h"
        -:   18:#include "ecma-extended-info.h"
        -:   19:#include "ecma-big-uint.h"
        -:   20:#include "ecma-bigint.h"
        -:   21:#include "js-parser-internal.h"
        -:   22:#include "lit-char-helpers.h"
        -:   23:
        -:   24:/** \addtogroup parser Parser
        -:   25: * @{
        -:   26: *
        -:   27: * \addtogroup jsparser JavaScript
        -:   28: * @{
        -:   29: *
        -:   30: * \addtogroup jsparser_utils Utility
        -:   31: * @{
        -:   32: */
        -:   33:
        -:   34:#if JERRY_PARSER
        -:   35:
        -:   36:/**
        -:   37: * Free literal.
        -:   38: */
        -:   39:void
    #####:   40:util_free_literal (lexer_literal_t *literal_p) /**< literal */
        -:   41:{
    #####:   42:  if (literal_p->type == LEXER_IDENT_LITERAL
    #####:   43:      || literal_p->type == LEXER_STRING_LITERAL)
        -:   44:  {
    #####:   45:    if (!(literal_p->status_flags & LEXER_FLAG_SOURCE_PTR))
        -:   46:    {
    #####:   47:      jmem_heap_free_block ((void *) literal_p->u.char_p, literal_p->prop.length);
        -:   48:    }
        -:   49:  }
    #####:   50:  else if ((literal_p->type == LEXER_FUNCTION_LITERAL)
    #####:   51:           || (literal_p->type == LEXER_REGEXP_LITERAL))
        -:   52:  {
    #####:   53:    ecma_bytecode_deref (literal_p->u.bytecode_p);
        -:   54:  }
    #####:   55:} /* util_free_literal */
        -:   56:
        -:   57:#endif /* JERRY_PARSER */
        -:   58:
        -:   59:#if JERRY_PARSER_DUMP_BYTE_CODE
        -:   60:
        -:   61:/**
        -:   62: * Debug utility to print a character sequence.
        -:   63: */
        -:   64:static void
        -:   65:util_print_chars (const uint8_t *char_p, /**< character pointer */
        -:   66:                  size_t size) /**< size */
        -:   67:{
        -:   68:  while (size > 0)
        -:   69:  {
        -:   70:    JERRY_DEBUG_MSG ("%c", *char_p++);
        -:   71:    size--;
        -:   72:  }
        -:   73:} /* util_print_chars */
        -:   74:
        -:   75:/**
        -:   76: * Debug utility to print a number.
        -:   77: */
        -:   78:static void
        -:   79:util_print_number (ecma_number_t num_p) /**< number to print */
        -:   80:{
        -:   81:  lit_utf8_byte_t str_buf[ECMA_MAX_CHARS_IN_STRINGIFIED_NUMBER];
        -:   82:  lit_utf8_size_t str_size = ecma_number_to_utf8_string (num_p, str_buf, sizeof (str_buf));
        -:   83:  str_buf[str_size] = 0;
        -:   84:  JERRY_DEBUG_MSG ("%s", str_buf);
        -:   85:} /* util_print_number */
        -:   86:
        -:   87:#if JERRY_BUILTIN_BIGINT
        -:   88:
        -:   89:/**
        -:   90: * Debug utility to print a bigint.
        -:   91: */
        -:   92:static void
        -:   93:util_print_bigint (ecma_value_t bigint) /**< bigint to print */
        -:   94:{
        -:   95:  if (bigint == ECMA_BIGINT_ZERO)
        -:   96:  {
        -:   97:    JERRY_DEBUG_MSG ("0");
        -:   98:    return;
        -:   99:  }
        -:  100:
        -:  101:  ecma_extended_primitive_t *bigint_p = ecma_get_extended_primitive_from_value (bigint);
        -:  102:  uint32_t char_start_p, char_size_p;
        -:  103:  lit_utf8_byte_t *string_buffer_p = ecma_big_uint_to_string (bigint_p, 10, &char_start_p, &char_size_p);
        -:  104:
        -:  105:  if (JERRY_UNLIKELY (string_buffer_p == NULL))
        -:  106:  {
        -:  107:    JERRY_DEBUG_MSG ("<out-of-memory>");
        -:  108:    return;
        -:  109:  }
        -:  110:
        -:  111:  JERRY_ASSERT (char_start_p > 0);
        -:  112:
        -:  113:  if (bigint_p->u.bigint_sign_and_size & ECMA_BIGINT_SIGN)
        -:  114:  {
        -:  115:    string_buffer_p[--char_start_p] = LIT_CHAR_MINUS;
        -:  116:  }
        -:  117:
        -:  118:  util_print_chars (string_buffer_p + char_start_p, char_size_p - char_start_p);
        -:  119:  jmem_heap_free_block (string_buffer_p, char_size_p);
        -:  120:} /* util_print_bigint */
        -:  121:
        -:  122:#endif /* JERRY_BUILTIN_BIGINT */
        -:  123:
        -:  124:/**
        -:  125: * Print literal
        -:  126: */
        -:  127:void
        -:  128:util_print_literal (lexer_literal_t *literal_p) /**< literal */
        -:  129:{
        -:  130:  switch (literal_p->type)
        -:  131:  {
        -:  132:    case LEXER_IDENT_LITERAL:
        -:  133:    {
        -:  134:      JERRY_DEBUG_MSG ("ident(");
        -:  135:      util_print_chars (literal_p->u.char_p, literal_p->prop.length);
        -:  136:      break;
        -:  137:    }
        -:  138:    case LEXER_FUNCTION_LITERAL:
        -:  139:    {
        -:  140:      JERRY_DEBUG_MSG ("function");
        -:  141:      return;
        -:  142:    }
        -:  143:    case LEXER_STRING_LITERAL:
        -:  144:    {
        -:  145:      JERRY_DEBUG_MSG ("string(");
        -:  146:      util_print_chars (literal_p->u.char_p, literal_p->prop.length);
        -:  147:      break;
        -:  148:    }
        -:  149:    case LEXER_NUMBER_LITERAL:
        -:  150:    {
        -:  151:#if JERRY_BUILTIN_BIGINT
        -:  152:      if (ecma_is_value_bigint (literal_p->u.value))
        -:  153:      {
        -:  154:        JERRY_DEBUG_MSG ("bigint(");
        -:  155:        util_print_bigint (literal_p->u.value);
        -:  156:        break;
        -:  157:      }
        -:  158:#endif /* JERRY_BUILTIN_BIGINT */
        -:  159:      JERRY_DEBUG_MSG ("number(");
        -:  160:      util_print_number (ecma_get_number_from_value (literal_p->u.value));
        -:  161:      break;
        -:  162:    }
        -:  163:    case LEXER_REGEXP_LITERAL:
        -:  164:    {
        -:  165:      JERRY_DEBUG_MSG ("regexp");
        -:  166:      return;
        -:  167:    }
        -:  168:    default:
        -:  169:    {
        -:  170:      JERRY_DEBUG_MSG ("unknown");
        -:  171:      return;
        -:  172:    }
        -:  173:  }
        -:  174:
        -:  175:  JERRY_DEBUG_MSG (")");
        -:  176:} /* util_print_literal */
        -:  177:
        -:  178:/**
        -:  179: * Print literal.
        -:  180: */
        -:  181:static void
        -:  182:util_print_literal_value (ecma_compiled_code_t *compiled_code_p, /**< compiled code */
        -:  183:                          uint16_t literal_index) /**< literal index */
        -:  184:{
        -:  185:  uint16_t argument_end;
        -:  186:  uint16_t register_end;
        -:  187:  uint16_t ident_end;
        -:  188:  uint16_t const_literal_end;
        -:  189:  ecma_value_t *literal_start_p;
        -:  190:
        -:  191:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  192:  {
        -:  193:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
        -:  194:    argument_end = args_p->argument_end;
        -:  195:    register_end = args_p->register_end;
        -:  196:    ident_end = args_p->ident_end;
        -:  197:    const_literal_end = args_p->const_literal_end;
        -:  198:    literal_start_p = (ecma_value_t *) (args_p + 1);
        -:  199:  }
        -:  200:  else
        -:  201:  {
        -:  202:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
        -:  203:    argument_end = args_p->argument_end;
        -:  204:    register_end = args_p->register_end;
        -:  205:    ident_end = args_p->ident_end;
        -:  206:    const_literal_end = args_p->const_literal_end;
        -:  207:    literal_start_p = (ecma_value_t *) (args_p + 1);
        -:  208:  }
        -:  209:
        -:  210:  if (literal_index < argument_end)
        -:  211:  {
        -:  212:    JERRY_DEBUG_MSG (" arg:%d", literal_index);
        -:  213:    return;
        -:  214:  }
        -:  215:
        -:  216:  if (literal_index < register_end)
        -:  217:  {
        -:  218:    JERRY_DEBUG_MSG (" reg:%d", literal_index);
        -:  219:    return;
        -:  220:  }
        -:  221:
        -:  222:  if (literal_index >= const_literal_end)
        -:  223:  {
        -:  224:    JERRY_DEBUG_MSG (" lit:%d", literal_index);
        -:  225:    return;
        -:  226:  }
        -:  227:
        -:  228:  if (literal_index < ident_end)
        -:  229:  {
        -:  230:    JERRY_DEBUG_MSG (" ident:%d->", literal_index);
        -:  231:  }
        -:  232:  else
        -:  233:  {
        -:  234:    JERRY_DEBUG_MSG (" const:%d->", literal_index);
        -:  235:  }
        -:  236:
        -:  237:  ecma_value_t value = literal_start_p[literal_index - register_end];
        -:  238:
        -:  239:  if (ecma_is_value_number (value))
        -:  240:  {
        -:  241:    JERRY_DEBUG_MSG ("number(");
        -:  242:    util_print_number (ecma_get_number_from_value (value));
        -:  243:  }
        -:  244:#if JERRY_BUILTIN_BIGINT
        -:  245:  else if (ecma_is_value_bigint (value))
        -:  246:  {
        -:  247:    JERRY_DEBUG_MSG ("bigint(");
        -:  248:    util_print_bigint (value);
        -:  249:  }
        -:  250:#endif /* JERRY_BUILTIN_BIGINT */
        -:  251:  else
        -:  252:  {
        -:  253:    ecma_string_t *literal_p = ecma_get_string_from_value (value);
        -:  254:
        -:  255:    JERRY_DEBUG_MSG ("string(");
        -:  256:
        -:  257:    ECMA_STRING_TO_UTF8_STRING (literal_p, chars_p, literal_size);
        -:  258:    util_print_chars (chars_p, literal_size);
        -:  259:    ECMA_FINALIZE_UTF8_STRING (chars_p, literal_size);
        -:  260:  }
        -:  261:
        -:  262:  JERRY_DEBUG_MSG (")");
        -:  263:} /* util_print_literal_value */
        -:  264:
        -:  265:#define PARSER_READ_IDENTIFIER_INDEX(name) \
        -:  266:  name = *byte_code_p++; \
        -:  267:  if (name >= encoding_limit) \
        -:  268:  { \
        -:  269:    name = (uint16_t) (((name << 8) | byte_code_p[0]) - encoding_delta); \
        -:  270:    byte_code_p++; \
        -:  271:  }
        -:  272:
        -:  273:/**
        -:  274: * Print byte code.
        -:  275: */
        -:  276:void
        -:  277:util_print_cbc (ecma_compiled_code_t *compiled_code_p) /**< compiled code */
        -:  278:{
        -:  279:  uint8_t flags;
        -:  280:  uint8_t *byte_code_start_p;
        -:  281:  uint8_t *byte_code_end_p;
        -:  282:  uint8_t *byte_code_p;
        -:  283:  uint16_t encoding_limit;
        -:  284:  uint16_t encoding_delta;
        -:  285:  uint16_t stack_limit;
        -:  286:  uint16_t argument_end;
        -:  287:  uint16_t register_end;
        -:  288:  uint16_t ident_end;
        -:  289:  uint16_t const_literal_end;
        -:  290:  uint16_t literal_end;
        -:  291:  size_t size = ((size_t) compiled_code_p->size) << JMEM_ALIGNMENT_LOG;
        -:  292:
        -:  293:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  294:  {
        -:  295:    cbc_uint16_arguments_t *args = (cbc_uint16_arguments_t *) compiled_code_p;
        -:  296:    stack_limit = args->stack_limit;
        -:  297:    argument_end = args->argument_end;
        -:  298:    register_end = args->register_end;
        -:  299:    ident_end = args->ident_end;
        -:  300:    const_literal_end = args->const_literal_end;
        -:  301:    literal_end = args->literal_end;
        -:  302:  }
        -:  303:  else
        -:  304:  {
        -:  305:    cbc_uint8_arguments_t *args = (cbc_uint8_arguments_t *) compiled_code_p;
        -:  306:    stack_limit = args->stack_limit;
        -:  307:    argument_end = args->argument_end;
        -:  308:    register_end = args->register_end;
        -:  309:    ident_end = args->ident_end;
        -:  310:    const_literal_end = args->const_literal_end;
        -:  311:    literal_end = args->literal_end;
        -:  312:  }
        -:  313:
        -:  314:  JERRY_DEBUG_MSG ("\nByte code dump:\n\n  Maximum stack depth: %d\n  Flags: [",
        -:  315:                   (int) (stack_limit + register_end));
        -:  316:
        -:  317:  if (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_FULL_LITERAL_ENCODING))
        -:  318:  {
        -:  319:    JERRY_DEBUG_MSG ("small_lit_enc");
        -:  320:    encoding_limit = CBC_SMALL_LITERAL_ENCODING_LIMIT;
        -:  321:    encoding_delta = CBC_SMALL_LITERAL_ENCODING_DELTA;
        -:  322:  }
        -:  323:  else
        -:  324:  {
        -:  325:    JERRY_DEBUG_MSG ("full_lit_enc");
        -:  326:    encoding_limit = CBC_FULL_LITERAL_ENCODING_LIMIT;
        -:  327:    encoding_delta = CBC_FULL_LITERAL_ENCODING_DELTA;
        -:  328:  }
        -:  329:
        -:  330:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  331:  {
        -:  332:    JERRY_DEBUG_MSG (",uint16_arguments");
        -:  333:  }
        -:  334:
        -:  335:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_STRICT_MODE)
        -:  336:  {
        -:  337:    JERRY_DEBUG_MSG (",strict_mode");
        -:  338:  }
        -:  339:
        -:  340:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)
        -:  341:  {
        -:  342:    JERRY_DEBUG_MSG (",mapped_arguments_needed");
        -:  343:    size -= argument_end * sizeof (ecma_value_t);
        -:  344:  }
        -:  345:
        -:  346:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_LEXICAL_ENV_NOT_NEEDED)
        -:  347:  {
        -:  348:    JERRY_DEBUG_MSG (",no_lexical_env");
        -:  349:  }
        -:  350:
        -:  351:#if JERRY_ESNEXT
        -:  352:  switch (CBC_FUNCTION_GET_TYPE (compiled_code_p->status_flags))
        -:  353:  {
        -:  354:    case CBC_FUNCTION_CONSTRUCTOR:
        -:  355:    {
        -:  356:      JERRY_DEBUG_MSG (",constructor");
        -:  357:      break;
        -:  358:    }
        -:  359:    case CBC_FUNCTION_GENERATOR:
        -:  360:    {
        -:  361:      JERRY_DEBUG_MSG (",generator");
        -:  362:      break;
        -:  363:    }
        -:  364:    case CBC_FUNCTION_ASYNC:
        -:  365:    {
        -:  366:      JERRY_DEBUG_MSG (",async");
        -:  367:      break;
        -:  368:    }
        -:  369:    case CBC_FUNCTION_ASYNC_GENERATOR:
        -:  370:    {
        -:  371:      JERRY_DEBUG_MSG (",async_generator");
        -:  372:      break;
        -:  373:    }
        -:  374:    case CBC_FUNCTION_ACCESSOR:
        -:  375:    {
        -:  376:      JERRY_DEBUG_MSG (",accessor");
        -:  377:      break;
        -:  378:    }
        -:  379:    case CBC_FUNCTION_ARROW:
        -:  380:    {
        -:  381:      JERRY_DEBUG_MSG (",arrow");
        -:  382:      break;
        -:  383:    }
        -:  384:    case CBC_FUNCTION_ASYNC_ARROW:
        -:  385:    {
        -:  386:      JERRY_DEBUG_MSG (",async_arrow");
        -:  387:      break;
        -:  388:    }
        -:  389:  }
        -:  390:#endif /* JERRY_ESNEXT */
        -:  391:
        -:  392:  JERRY_DEBUG_MSG ("]\n");
        -:  393:
        -:  394:  JERRY_DEBUG_MSG ("  Argument range end: %d\n", (int) argument_end);
        -:  395:  JERRY_DEBUG_MSG ("  Register range end: %d\n", (int) register_end);
        -:  396:  JERRY_DEBUG_MSG ("  Identifier range end: %d\n", (int) ident_end);
        -:  397:  JERRY_DEBUG_MSG ("  Const literal range end: %d\n", (int) const_literal_end);
        -:  398:  JERRY_DEBUG_MSG ("  Literal range end: %d\n\n", (int) literal_end);
        -:  399:
        -:  400:#if JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING
        -:  401:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_HAS_EXTENDED_INFO)
        -:  402:  {
        -:  403:    uint8_t *extended_info_p = ecma_compiled_code_resolve_extended_info (compiled_code_p);
        -:  404:    uint8_t *extended_info_start_p = extended_info_p + sizeof (uint8_t);
        -:  405:    uint8_t extended_info = *extended_info_p;
        -:  406:
        -:  407:    if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_ARGUMENT_LENGTH)
        -:  408:    {
        -:  409:      uint32_t argument_length = ecma_extended_info_decode_vlq (&extended_info_p);
        -:  410:      JERRY_DEBUG_MSG ("  [Extended] Argument length: %d\n", (int) argument_length);
        -:  411:    }
        -:  412:
        -:  413:    if (extended_info & CBC_EXTENDED_CODE_FLAGS_HAS_SOURCE_CODE_RANGE)
        -:  414:    {
        -:  415:      uint32_t range_start = ecma_extended_info_decode_vlq (&extended_info_p);
        -:  416:      uint32_t range_end = ecma_extended_info_decode_vlq (&extended_info_p) + range_start;
        -:  417:      JERRY_DEBUG_MSG ("  [Extended] Source code range: %d - %d\n", (int) range_start, (int) range_end);
        -:  418:    }
        -:  419:
        -:  420:    JERRY_DEBUG_MSG ("\n");
        -:  421:
        -:  422:    size -= (size_t) (extended_info_start_p - extended_info_p);
        -:  423:  }
        -:  424:#endif /* JERRY_ESNEXT || JERRY_FUNCTION_TO_STRING */
        -:  425:
        -:  426:  byte_code_start_p = (uint8_t *) compiled_code_p;
        -:  427:
        -:  428:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  429:  {
        -:  430:    byte_code_start_p += sizeof (cbc_uint16_arguments_t);
        -:  431:  }
        -:  432:  else
        -:  433:  {
        -:  434:    byte_code_start_p += sizeof (cbc_uint8_arguments_t);
        -:  435:  }
        -:  436:
        -:  437:  byte_code_start_p += (unsigned int) (literal_end - register_end) * sizeof (ecma_value_t);
        -:  438:
        -:  439:  if (CBC_FUNCTION_GET_TYPE (compiled_code_p->status_flags) != CBC_FUNCTION_CONSTRUCTOR)
        -:  440:  {
        -:  441:    size -= sizeof (ecma_value_t);
        -:  442:  }
        -:  443:
        -:  444:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_HAS_TAGGED_LITERALS)
        -:  445:  {
        -:  446:    size -= sizeof (ecma_value_t);
        -:  447:  }
        -:  448:
        -:  449:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_HAS_LINE_INFO)
        -:  450:  {
        -:  451:    size -= sizeof (ecma_value_t);
        -:  452:  }
        -:  453:
        -:  454:  byte_code_end_p = ((uint8_t *) compiled_code_p) + size;
        -:  455:  byte_code_p = byte_code_start_p;
        -:  456:
        -:  457:  while (byte_code_p < byte_code_end_p)
        -:  458:  {
        -:  459:    cbc_opcode_t opcode = (cbc_opcode_t) *byte_code_p;
        -:  460:    cbc_ext_opcode_t ext_opcode = CBC_EXT_NOP;
        -:  461:    size_t cbc_offset = (size_t) (byte_code_p - byte_code_start_p);
        -:  462:
        -:  463:    if (opcode != CBC_EXT_OPCODE)
        -:  464:    {
        -:  465:      flags = cbc_flags[opcode];
        -:  466:      JERRY_DEBUG_MSG (" %3d : %s", (int) cbc_offset, cbc_names[opcode]);
        -:  467:      byte_code_p++;
        -:  468:    }
        -:  469:    else
        -:  470:    {
        -:  471:      if (byte_code_p + 1 >= byte_code_end_p)
        -:  472:      {
        -:  473:        break;
        -:  474:      }
        -:  475:
        -:  476:      ext_opcode = (cbc_ext_opcode_t) byte_code_p[1];
        -:  477:
        -:  478:      if (ext_opcode == CBC_EXT_NOP)
        -:  479:      {
        -:  480:        break;
        -:  481:      }
        -:  482:
        -:  483:      flags = cbc_ext_flags[ext_opcode];
        -:  484:      JERRY_DEBUG_MSG (" %3d : %s", (int) cbc_offset, cbc_ext_names[ext_opcode]);
        -:  485:      byte_code_p += 2;
        -:  486:    }
        -:  487:
        -:  488:    if (flags & (CBC_HAS_LITERAL_ARG | CBC_HAS_LITERAL_ARG2))
        -:  489:    {
        -:  490:      uint16_t literal_index;
        -:  491:
        -:  492:      PARSER_READ_IDENTIFIER_INDEX (literal_index);
        -:  493:      util_print_literal_value (compiled_code_p, literal_index);
        -:  494:    }
        -:  495:
        -:  496:    if (flags & CBC_HAS_LITERAL_ARG2)
        -:  497:    {
        -:  498:      uint16_t literal_index;
        -:  499:
        -:  500:      PARSER_READ_IDENTIFIER_INDEX (literal_index);
        -:  501:      util_print_literal_value (compiled_code_p, literal_index);
        -:  502:
        -:  503:      if (!(flags & CBC_HAS_LITERAL_ARG))
        -:  504:      {
        -:  505:        PARSER_READ_IDENTIFIER_INDEX (literal_index);
        -:  506:        util_print_literal_value (compiled_code_p, literal_index);
        -:  507:      }
        -:  508:    }
        -:  509:
        -:  510:    if (flags & CBC_HAS_BYTE_ARG)
        -:  511:    {
        -:  512:      if (opcode == CBC_PUSH_NUMBER_POS_BYTE
        -:  513:          || opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_POS_BYTE)
        -:  514:      {
        -:  515:        JERRY_DEBUG_MSG (" number:%d", (int) *byte_code_p + 1);
        -:  516:      }
        -:  517:      else if (opcode == CBC_PUSH_NUMBER_NEG_BYTE
        -:  518:               || opcode == CBC_PUSH_LITERAL_PUSH_NUMBER_NEG_BYTE)
        -:  519:      {
        -:  520:        JERRY_DEBUG_MSG (" number:%d", -((int) *byte_code_p + 1));
        -:  521:      }
        -:  522:      else
        -:  523:      {
        -:  524:        JERRY_DEBUG_MSG (" byte_arg:%d", *byte_code_p);
        -:  525:      }
        -:  526:      byte_code_p++;
        -:  527:    }
        -:  528:
        -:  529:    if (flags & CBC_HAS_BRANCH_ARG)
        -:  530:    {
        -:  531:      size_t branch_offset_length = (opcode != CBC_EXT_OPCODE ? CBC_BRANCH_OFFSET_LENGTH (opcode)
        -:  532:                                                              : CBC_BRANCH_OFFSET_LENGTH (ext_opcode));
        -:  533:      size_t offset = 0;
        -:  534:
        -:  535:      do
        -:  536:      {
        -:  537:        offset = (offset << 8) | *byte_code_p++;
        -:  538:      }
        -:  539:      while (--branch_offset_length > 0);
        -:  540:
        -:  541:      JERRY_DEBUG_MSG (" offset:%d(->%d)",
        -:  542:                       (int) offset,
        -:  543:                       (int) (cbc_offset + (CBC_BRANCH_IS_FORWARD (flags) ? offset : -offset)));
        -:  544:    }
        -:  545:
        -:  546:    JERRY_DEBUG_MSG ("\n");
        -:  547:  }
        -:  548:} /* util_print_cbc */
        -:  549:
        -:  550:#undef PARSER_READ_IDENTIFIER_INDEX
        -:  551:
        -:  552:#endif /* JERRY_PARSER_DUMP_BYTE_CODE */
        -:  553:
        -:  554:/**
        -:  555: * @}
        -:  556: * @}
        -:  557: * @}
        -:  558: */
