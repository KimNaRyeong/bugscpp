        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-conversion.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:/**
        -:   17: * Implementation of ECMA-defined conversion routines
        -:   18: */
        -:   19:
        -:   20:#include <math.h>
        -:   21:
        -:   22:#include "ecma-alloc.h"
        -:   23:#include "ecma-bigint.h"
        -:   24:#include "ecma-bigint-object.h"
        -:   25:#include "ecma-boolean-object.h"
        -:   26:#include "ecma-conversion.h"
        -:   27:#include "ecma-exceptions.h"
        -:   28:#include "ecma-function-object.h"
        -:   29:#include "ecma-gc.h"
        -:   30:#include "ecma-globals.h"
        -:   31:#include "ecma-helpers.h"
        -:   32:#include "ecma-number-object.h"
        -:   33:#include "ecma-objects.h"
        -:   34:#include "ecma-objects-general.h"
        -:   35:#include "ecma-string-object.h"
        -:   36:#include "ecma-symbol-object.h"
        -:   37:#include "jrt-libc-includes.h"
        -:   38:
        -:   39:/** \addtogroup ecma ECMA
        -:   40: * @{
        -:   41: *
        -:   42: * \addtogroup ecmaconversion ECMA conversion routines
        -:   43: * @{
        -:   44: */
        -:   45:
        -:   46:/**
        -:   47: * RequireObjectCoercible operation.
        -:   48: *
        -:   49: * See also:
        -:   50: *          ECMA-262 v11, 7.2.1
        -:   51: *
        -:   52: * @return true - if the value can be coerced to object without any exceptions
        -:   53: *         false - otherwise
        -:   54: */
        -:   55:bool
    #####:   56:ecma_op_require_object_coercible (ecma_value_t value) /**< ecma value */
        -:   57:{
    #####:   58:  ecma_check_value_type_is_spec_defined (value);
        -:   59:
    #####:   60:  if (ecma_is_value_undefined (value) || ecma_is_value_null (value))
        -:   61:  {
    #####:   62:    ecma_raise_type_error (ECMA_ERR_MSG ("Argument cannot be converted to an object"));
    #####:   63:    return false;
        -:   64:  }
        -:   65:
    #####:   66:  return true;
        -:   67:} /* ecma_op_require_object_coercible */
        -:   68:
        -:   69:/**
        -:   70: * SameValue operation.
        -:   71: *
        -:   72: * See also:
        -:   73: *          ECMA-262 v5, 9.12
        -:   74: *
        -:   75: * @return true - if the value are same according to ECMA-defined SameValue algorithm,
        -:   76: *         false - otherwise
        -:   77: */
        -:   78:bool
    #####:   79:ecma_op_same_value (ecma_value_t x, /**< ecma value */
        -:   80:                    ecma_value_t y) /**< ecma value */
        -:   81:{
    #####:   82:  if (x == y)
        -:   83:  {
    #####:   84:    return true;
        -:   85:  }
        -:   86:
    #####:   87:  ecma_type_t type_of_x = ecma_get_value_type_field (x);
        -:   88:
    #####:   89:  if (type_of_x != ecma_get_value_type_field (y)
    #####:   90:      || type_of_x == ECMA_TYPE_DIRECT)
        -:   91:  {
    #####:   92:    return false;
        -:   93:  }
        -:   94:
    #####:   95:  if (ecma_is_value_number (x))
        -:   96:  {
    #####:   97:    ecma_number_t x_num = ecma_get_number_from_value (x);
    #####:   98:    ecma_number_t y_num = ecma_get_number_from_value (y);
        -:   99:
    #####:  100:    bool is_x_nan = ecma_number_is_nan (x_num);
    #####:  101:    bool is_y_nan = ecma_number_is_nan (y_num);
        -:  102:
    #####:  103:    if (is_x_nan || is_y_nan)
        -:  104:    {
    #####:  105:      return is_x_nan && is_y_nan;
        -:  106:    }
        -:  107:
    #####:  108:    if (ecma_number_is_zero (x_num)
    #####:  109:        && ecma_number_is_zero (y_num)
    #####:  110:        && ecma_number_is_negative (x_num) != ecma_number_is_negative (y_num))
        -:  111:    {
    #####:  112:      return false;
        -:  113:    }
        -:  114:
    #####:  115:    return (x_num == y_num);
        -:  116:  }
        -:  117:
    #####:  118:  if (ecma_is_value_string (x))
        -:  119:  {
    #####:  120:    ecma_string_t *x_str_p = ecma_get_string_from_value (x);
    #####:  121:    ecma_string_t *y_str_p = ecma_get_string_from_value (y);
        -:  122:
    #####:  123:    return ecma_compare_ecma_strings (x_str_p, y_str_p);
        -:  124:  }
        -:  125:
        -:  126:#if JERRY_BUILTIN_BIGINT
    #####:  127:  if (ecma_is_value_bigint (x))
        -:  128:  {
    #####:  129:    return (ecma_is_value_bigint (y) && ecma_bigint_compare_to_bigint (x, y) == 0);
        -:  130:  }
        -:  131:#endif /* JERRY_BUILTIN_BIGINT */
        -:  132:
    #####:  133:  JERRY_ASSERT (ecma_is_value_object (x) || ecma_is_value_symbol (x));
        -:  134:
    #####:  135:  return false;
        -:  136:} /* ecma_op_same_value */
        -:  137:
        -:  138:#if JERRY_BUILTIN_CONTAINER
        -:  139:/**
        -:  140: * SameValueZero operation.
        -:  141: *
        -:  142: * See also:
        -:  143: *          ECMA-262 v6, 7.2.10
        -:  144: *
        -:  145: * @return true - if the value are same according to ECMA-defined SameValueZero algorithm,
        -:  146: *         false - otherwise
        -:  147: */
        -:  148:bool
    #####:  149:ecma_op_same_value_zero (ecma_value_t x, /**< ecma value */
        -:  150:                         ecma_value_t y, /**< ecma value */
        -:  151:                         bool strict_equality) /**< strict equality */
        -:  152:{
    #####:  153:  if (ecma_is_value_number (x) && ecma_is_value_number (y))
        -:  154:  {
    #####:  155:    ecma_number_t x_num = ecma_get_number_from_value (x);
    #####:  156:    ecma_number_t y_num = ecma_get_number_from_value (y);
        -:  157:
    #####:  158:    bool is_x_nan = ecma_number_is_nan (x_num);
    #####:  159:    bool is_y_nan = ecma_number_is_nan (y_num);
        -:  160:
    #####:  161:    if (strict_equality
    #####:  162:        && is_x_nan
    #####:  163:        && is_y_nan)
        -:  164:    {
    #####:  165:      return false;
        -:  166:    }
        -:  167:
    #####:  168:    if (is_x_nan || is_y_nan)
        -:  169:    {
    #####:  170:      return (is_x_nan && is_y_nan);
        -:  171:    }
        -:  172:
    #####:  173:    if (ecma_number_is_zero (x_num)
    #####:  174:        && ecma_number_is_zero (y_num)
    #####:  175:        && ecma_number_is_negative (x_num) != ecma_number_is_negative (y_num))
        -:  176:    {
    #####:  177:      return true;
        -:  178:    }
        -:  179:
    #####:  180:    return (x_num == y_num);
        -:  181:  }
        -:  182:
    #####:  183:  return ecma_op_same_value (x, y);
        -:  184:} /* ecma_op_same_value_zero */
        -:  185:#endif /* JERRY_BUILTIN_CONTAINER */
        -:  186:
        -:  187:/**
        -:  188: * ToPrimitive operation.
        -:  189: *
        -:  190: * See also:
        -:  191: *          ECMA-262 v5, 9.1
        -:  192: *
        -:  193: * @return ecma value
        -:  194: *         Returned value must be freed with ecma_free_value
        -:  195: */
        -:  196:ecma_value_t
    #####:  197:ecma_op_to_primitive (ecma_value_t value, /**< ecma value */
        -:  198:                      ecma_preferred_type_hint_t preferred_type) /**< preferred type hint */
        -:  199:{
    #####:  200:  ecma_check_value_type_is_spec_defined (value);
        -:  201:
    #####:  202:  if (ecma_is_value_object (value))
        -:  203:  {
    #####:  204:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -:  205:
    #####:  206:    return ecma_op_object_default_value (obj_p, preferred_type);
        -:  207:  }
        -:  208:  else
        -:  209:  {
    #####:  210:    return ecma_copy_value (value);
        -:  211:  }
        -:  212:} /* ecma_op_to_primitive */
        -:  213:
        -:  214:/**
        -:  215: * ToBoolean operation. Cannot throw an exception.
        -:  216: *
        -:  217: * See also:
        -:  218: *          ECMA-262 v5, 9.2
        -:  219: *
        -:  220: * @return true - if the logical value is true
        -:  221: *         false - otherwise
        -:  222: */
        -:  223:bool
        4:  224:ecma_op_to_boolean (ecma_value_t value) /**< ecma value */
        -:  225:{
        4:  226:  ecma_check_value_type_is_spec_defined (value);
        -:  227:
        4:  228:  if (ecma_is_value_simple (value))
        -:  229:  {
        4:  230:    JERRY_ASSERT (ecma_is_value_boolean (value)
        -:  231:                  || ecma_is_value_undefined (value)
        -:  232:                  || ecma_is_value_null (value));
        -:  233:
        4:  234:    return ecma_is_value_true (value);
        -:  235:  }
        -:  236:
    #####:  237:  if (ecma_is_value_integer_number (value))
        -:  238:  {
    #####:  239:    return (value != ecma_make_integer_value (0));
        -:  240:  }
        -:  241:
    #####:  242:  if (ecma_is_value_float_number (value))
        -:  243:  {
    #####:  244:    ecma_number_t num = ecma_get_float_from_value (value);
        -:  245:
    #####:  246:    return (!ecma_number_is_nan (num) && !ecma_number_is_zero (num));
        -:  247:  }
        -:  248:
    #####:  249:  if (ecma_is_value_string (value))
        -:  250:  {
    #####:  251:    ecma_string_t *str_p = ecma_get_string_from_value (value);
        -:  252:
    #####:  253:    return !ecma_string_is_empty (str_p);
        -:  254:  }
        -:  255:
        -:  256:#if JERRY_BUILTIN_BIGINT
    #####:  257:  if (ecma_is_value_bigint (value))
        -:  258:  {
    #####:  259:    return value != ECMA_BIGINT_ZERO;
        -:  260:  }
        -:  261:#endif /* JERRY_BUILTIN_BIGINT */
        -:  262:
    #####:  263:  JERRY_ASSERT (ecma_is_value_object (value) || ecma_is_value_symbol (value));
        -:  264:
    #####:  265:  return true;
        -:  266:} /* ecma_op_to_boolean */
        -:  267:
        -:  268:/**
        -:  269: * ToNumber operation.
        -:  270: *
        -:  271: * See also:
        -:  272: *          ECMA-262 v5, 9.3
        -:  273: *
        -:  274: * @return ecma value
        -:  275: *         Returned value must be freed with ecma_free_value
        -:  276: */
        -:  277:extern inline ecma_value_t JERRY_ATTR_ALWAYS_INLINE
    #####:  278:ecma_op_to_number (ecma_value_t value, /**< ecma value */
        -:  279:                   ecma_number_t *number_p) /**< [out] ecma number */
        -:  280:{
        1:  281:  return ecma_op_to_numeric (value, number_p, ECMA_TO_NUMERIC_NO_OPTS);
        -:  282:} /* ecma_op_to_number */
        -:  283:
        -:  284:/**
        -:  285: * Helper to get the numeric value of an ecma value
        -:  286: *
        -:  287: * See also:
        -:  288: *          ECMA-262 v11, 7.1.3
        -:  289: *
        -:  290: * @return ECMA_VALUE_EMPTY if converted to number, BigInt if
        -:  291: *         converted to BigInt, and conversion error otherwise
        -:  292: *         Returned value must be freed with ecma_free_value
        -:  293: */
        -:  294:ecma_value_t
        1:  295:ecma_op_to_numeric (ecma_value_t value, /**< ecma value */
        -:  296:                    ecma_number_t *number_p, /**< [out] ecma number */
        -:  297:                    ecma_to_numeric_options_t options) /**< option bits */
        -:  298:{
        -:  299:  JERRY_UNUSED (options);
        -:  300:
        1:  301:  if (ecma_is_value_integer_number (value))
        -:  302:  {
        1:  303:    *number_p = (ecma_number_t) ecma_get_integer_from_value (value);
        1:  304:    return ECMA_VALUE_EMPTY;
        -:  305:  }
        -:  306:
    #####:  307:  if (ecma_is_value_float_number (value))
        -:  308:  {
    #####:  309:    *number_p = ecma_get_float_from_value (value);
    #####:  310:    return ECMA_VALUE_EMPTY;
        -:  311:  }
        -:  312:
    #####:  313:  if (ecma_is_value_string (value))
        -:  314:  {
    #####:  315:    ecma_string_t *str_p = ecma_get_string_from_value (value);
    #####:  316:    *number_p = ecma_string_to_number (str_p);
    #####:  317:    return ECMA_VALUE_EMPTY;
        -:  318:  }
        -:  319:
    #####:  320:  if (ecma_is_value_undefined (value))
        -:  321:  {
    #####:  322:    *number_p = ecma_number_make_nan ();
    #####:  323:    return ECMA_VALUE_EMPTY;
        -:  324:  }
        -:  325:
    #####:  326:  if (ecma_is_value_null (value))
        -:  327:  {
    #####:  328:    *number_p = 0;
    #####:  329:    return ECMA_VALUE_EMPTY;
        -:  330:  }
        -:  331:
    #####:  332:  if (ecma_is_value_true (value))
        -:  333:  {
    #####:  334:    *number_p = 1;
    #####:  335:    return ECMA_VALUE_EMPTY;
        -:  336:  }
        -:  337:
    #####:  338:  if (ecma_is_value_false (value))
        -:  339:  {
    #####:  340:    *number_p = 0;
    #####:  341:    return ECMA_VALUE_EMPTY;
        -:  342:  }
        -:  343:
        -:  344:#if JERRY_ESNEXT
    #####:  345:  if (ecma_is_value_symbol (value))
        -:  346:  {
    #####:  347:    return ecma_raise_type_error (ECMA_ERR_MSG ("Cannot convert a Symbol value to a number"));
        -:  348:  }
        -:  349:#endif /* JERRY_ESNEXT */
        -:  350:
        -:  351:#if JERRY_BUILTIN_BIGINT
    #####:  352:  if (ecma_is_value_bigint (value))
        -:  353:  {
    #####:  354:    if (options & ECMA_TO_NUMERIC_ALLOW_BIGINT)
        -:  355:    {
    #####:  356:      return ecma_copy_value (value);
        -:  357:    }
    #####:  358:    return ecma_raise_type_error (ECMA_ERR_MSG ("Cannot convert a BigInt value to a number"));
        -:  359:  }
        -:  360:#endif /* JERRY_BUILTIN_BIGINT */
        -:  361:
    #####:  362:  JERRY_ASSERT (ecma_is_value_object (value));
        -:  363:
    #####:  364:  ecma_object_t *object_p = ecma_get_object_from_value (value);
        -:  365:
    #####:  366:  ecma_value_t def_value = ecma_op_object_default_value (object_p, ECMA_PREFERRED_TYPE_NUMBER);
        -:  367:
    #####:  368:  if (ECMA_IS_VALUE_ERROR (def_value))
        -:  369:  {
    #####:  370:    return def_value;
        -:  371:  }
        -:  372:
    #####:  373:  ecma_value_t ret_value = ecma_op_to_numeric (def_value, number_p, options);
        -:  374:
    #####:  375:  ecma_fast_free_value (def_value);
        -:  376:
    #####:  377:  return ret_value;
        -:  378:} /* ecma_op_to_numeric */
        -:  379:
        -:  380:/**
        -:  381: * ToString operation.
        -:  382: *
        -:  383: * See also:
        -:  384: *          ECMA-262 v5, 9.8
        -:  385: *
        -:  386: * @return NULL - if the conversion fails
        -:  387: *         pointer to the string descriptor - otherwise
        -:  388: */
        -:  389:ecma_string_t *
        2:  390:ecma_op_to_string (ecma_value_t value) /**< ecma value */
        -:  391:{
        2:  392:  ecma_check_value_type_is_spec_defined (value);
        -:  393:
        2:  394:  if (ecma_is_value_string (value))
        -:  395:  {
        2:  396:    ecma_string_t *res_p = ecma_get_string_from_value (value);
        2:  397:    ecma_ref_ecma_string (res_p);
        2:  398:    return res_p;
        -:  399:  }
        -:  400:
    #####:  401:  if (ecma_is_value_integer_number (value))
        -:  402:  {
    #####:  403:    ecma_integer_value_t num = ecma_get_integer_from_value (value);
        -:  404:
    #####:  405:    if (num < 0)
        -:  406:    {
    #####:  407:      return ecma_new_ecma_string_from_number ((ecma_number_t) num);
        -:  408:    }
        -:  409:    else
        -:  410:    {
    #####:  411:      return ecma_new_ecma_string_from_uint32 ((uint32_t) num);
        -:  412:    }
        -:  413:  }
        -:  414:
    #####:  415:  if (ecma_is_value_float_number (value))
        -:  416:  {
    #####:  417:    ecma_number_t num = ecma_get_float_from_value (value);
    #####:  418:    return ecma_new_ecma_string_from_number (num);
        -:  419:  }
        -:  420:
    #####:  421:  if (ecma_is_value_undefined (value))
        -:  422:  {
    #####:  423:    return ecma_get_magic_string (LIT_MAGIC_STRING_UNDEFINED);
        -:  424:  }
        -:  425:
    #####:  426:  if (ecma_is_value_null (value))
        -:  427:  {
    #####:  428:    return ecma_get_magic_string (LIT_MAGIC_STRING_NULL);
        -:  429:  }
        -:  430:
    #####:  431:  if (ecma_is_value_true (value))
        -:  432:  {
    #####:  433:    return ecma_get_magic_string (LIT_MAGIC_STRING_TRUE);
        -:  434:  }
        -:  435:
    #####:  436:  if (ecma_is_value_false (value))
        -:  437:  {
    #####:  438:    return ecma_get_magic_string (LIT_MAGIC_STRING_FALSE);
        -:  439:  }
        -:  440:
        -:  441:#if JERRY_ESNEXT
    #####:  442:  if (ecma_is_value_symbol (value))
        -:  443:  {
    #####:  444:    ecma_raise_type_error (ECMA_ERR_MSG ("Cannot convert a Symbol value to a string"));
    #####:  445:    return NULL;
        -:  446:  }
        -:  447:#endif /* JERRY_ESNEXT */
        -:  448:
        -:  449:#if JERRY_BUILTIN_BIGINT
    #####:  450:  if (ecma_is_value_bigint (value))
        -:  451:  {
    #####:  452:    return ecma_bigint_to_string (value, 10);
        -:  453:  }
        -:  454:#endif /* JERRY_BUILTIN_BIGINT */
        -:  455:
    #####:  456:  JERRY_ASSERT (ecma_is_value_object (value));
        -:  457:
    #####:  458:  ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -:  459:
    #####:  460:  ecma_value_t def_value = ecma_op_object_default_value (obj_p, ECMA_PREFERRED_TYPE_STRING);
        -:  461:
    #####:  462:  if (ECMA_IS_VALUE_ERROR (def_value))
        -:  463:  {
    #####:  464:    return NULL;
        -:  465:  }
        -:  466:
    #####:  467:  ecma_string_t *ret_string_p = ecma_op_to_string (def_value);
        -:  468:
    #####:  469:  ecma_free_value (def_value);
        -:  470:
    #####:  471:  return ret_string_p;
        -:  472:} /* ecma_op_to_string */
        -:  473:
        -:  474:/**
        -:  475: * ToPropertyKey operation.
        -:  476: *
        -:  477: * See also:
        -:  478: *   ECMA 262 v6, 7.1.14
        -:  479: *   ECMA 262 v10, 7.1.14
        -:  480: *   ECMA 262 v11, 7.1.19
        -:  481: *
        -:  482: * @return NULL - if the conversion fails
        -:  483: *         ecma-string - otherwise
        -:  484: */
        -:  485:ecma_string_t *
        4:  486:ecma_op_to_property_key (ecma_value_t value) /**< ecma value */
        -:  487:{
        -:  488:  /* Fast path for strings and symbols */
        4:  489:  if (JERRY_LIKELY (ecma_is_value_prop_name (value)))
        -:  490:  {
        4:  491:    ecma_string_t *key_p = ecma_get_prop_name_from_value (value);
        4:  492:    ecma_ref_ecma_string (key_p);
        4:  493:    return key_p;
        -:  494:  }
        -:  495:
        -:  496:#if JERRY_ESNEXT
    #####:  497:  ecma_value_t key = ecma_op_to_primitive (value, ECMA_PREFERRED_TYPE_STRING);
        -:  498:
    #####:  499:  if (ECMA_IS_VALUE_ERROR (key))
        -:  500:  {
    #####:  501:    return NULL;
        -:  502:  }
        -:  503:
    #####:  504:  if (ecma_is_value_symbol (key))
        -:  505:  {
    #####:  506:    ecma_string_t *symbol_p = ecma_get_symbol_from_value (key);
    #####:  507:    return symbol_p;
        -:  508:  }
        -:  509:
    #####:  510:  ecma_string_t *result = ecma_op_to_string (key);
    #####:  511:  ecma_free_value (key);
        -:  512:
    #####:  513:  return result;
        -:  514:#else /* !JERRY_ESNEXT */
    #####:  515:  ecma_check_value_type_is_spec_defined (value);
        -:  516:
    #####:  517:  return ecma_op_to_string (value);
        -:  518:#endif /* JERRY_ESNEXT */
        -:  519:} /* ecma_op_to_property_key */
        -:  520:
        -:  521:/**
        -:  522: * ToObject operation.
        -:  523: *
        -:  524: * See also:
        -:  525: *          ECMA-262 v5, 9.9
        -:  526: *
        -:  527: * @return ecma value
        -:  528: *         Returned value must be freed with ecma_free_value
        -:  529: */
        -:  530:ecma_value_t
    #####:  531:ecma_op_to_object (ecma_value_t value) /**< ecma value */
        -:  532:{
    #####:  533:  ecma_check_value_type_is_spec_defined (value);
    #####:  534:  ecma_builtin_id_t proto_id = ECMA_BUILTIN_ID_OBJECT_PROTOTYPE;
        -:  535:  uint8_t class_type;
        -:  536:
    #####:  537:  if (ecma_is_value_number (value))
        -:  538:  {
        -:  539:#if JERRY_BUILTIN_NUMBER
    #####:  540:    proto_id =  ECMA_BUILTIN_ID_NUMBER_PROTOTYPE;
        -:  541:#endif /* JERRY_BUILTIN_NUMBER */
    #####:  542:    class_type = ECMA_OBJECT_CLASS_NUMBER;
        -:  543:  }
    #####:  544:  else if (ecma_is_value_string (value))
        -:  545:  {
        -:  546:#if JERRY_BUILTIN_STRING
    #####:  547:    proto_id = ECMA_BUILTIN_ID_STRING_PROTOTYPE;
        -:  548:#endif /* JERRY_BUILTIN_STRING */
    #####:  549:    class_type = ECMA_OBJECT_CLASS_STRING;
        -:  550:  }
    #####:  551:  else if (ecma_is_value_object (value))
        -:  552:  {
    #####:  553:    return ecma_copy_value (value);
        -:  554:  }
        -:  555:#if JERRY_ESNEXT
    #####:  556:  else if (ecma_is_value_symbol (value))
        -:  557:  {
    #####:  558:    proto_id = ECMA_BUILTIN_ID_SYMBOL_PROTOTYPE;
    #####:  559:    class_type = ECMA_OBJECT_CLASS_SYMBOL;
        -:  560:  }
        -:  561:#endif /* JERRY_ESNEXT */
        -:  562:#if JERRY_BUILTIN_BIGINT
    #####:  563:  else if (ecma_is_value_bigint (value))
        -:  564:  {
    #####:  565:    return ecma_op_create_bigint_object (value);
        -:  566:  }
        -:  567:#endif /* JERRY_BUILTIN_BIGINT */
        -:  568:  else
        -:  569:  {
    #####:  570:    if (ecma_is_value_undefined (value)
    #####:  571:        || ecma_is_value_null (value))
        -:  572:    {
    #####:  573:      return ecma_raise_type_error (ECMA_ERR_MSG ("Argument cannot be converted to an object"));
        -:  574:    }
        -:  575:    else
        -:  576:    {
    #####:  577:      JERRY_ASSERT (ecma_is_value_boolean (value));
        -:  578:#if JERRY_BUILTIN_BOOLEAN
    #####:  579:      proto_id = ECMA_BUILTIN_ID_BOOLEAN_PROTOTYPE;
        -:  580:#endif /* JERRY_BUILTIN_BOOLEAN */
    #####:  581:      class_type = ECMA_OBJECT_CLASS_BOOLEAN;
        -:  582:    }
        -:  583:  }
        -:  584:
    #####:  585:  ecma_object_t *object_p = ecma_create_object (ecma_builtin_get (proto_id),
        -:  586:                                                sizeof (ecma_extended_object_t),
        -:  587:                                                ECMA_OBJECT_TYPE_CLASS);
        -:  588:
    #####:  589:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  590:  ext_object_p->u.cls.type = class_type;
    #####:  591:  ext_object_p->u.cls.u3.value = ecma_copy_value_if_not_object (value);
        -:  592:
    #####:  593:  return ecma_make_object_value (object_p);
        -:  594:} /* ecma_op_to_object */
        -:  595:
        -:  596:/**
        -:  597: * FromPropertyDescriptor operation.
        -:  598: *
        -:  599: * See also:
        -:  600: *          ECMA-262 v5, 8.10.4
        -:  601: *
        -:  602: * @return constructed object
        -:  603: */
        -:  604:ecma_object_t *
    #####:  605:ecma_op_from_property_descriptor (const ecma_property_descriptor_t *src_prop_desc_p) /**< property descriptor */
        -:  606:{
        -:  607:  /* 2. */
    #####:  608:  ecma_object_t *obj_p = ecma_op_create_object_object_noarg ();
        -:  609:
        -:  610:  ecma_value_t completion;
    #####:  611:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -:  612:  {
    #####:  613:    prop_desc.flags = (JERRY_PROP_IS_VALUE_DEFINED
        -:  614:                       | JERRY_PROP_IS_WRITABLE_DEFINED
        -:  615:                       | JERRY_PROP_IS_WRITABLE
        -:  616:                       | JERRY_PROP_IS_ENUMERABLE_DEFINED
        -:  617:                       | JERRY_PROP_IS_ENUMERABLE
        -:  618:                       | JERRY_PROP_IS_CONFIGURABLE_DEFINED
        -:  619:                       | JERRY_PROP_IS_CONFIGURABLE);
        -:  620:  }
        -:  621:
        -:  622:  /* 3. */
    #####:  623:  if (src_prop_desc_p->flags & (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED))
        -:  624:  {
    #####:  625:    JERRY_ASSERT ((prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED))
        -:  626:                   == (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED));
        -:  627:
        -:  628:    /* a. */
    #####:  629:    prop_desc.value = src_prop_desc_p->value;
        -:  630:
    #####:  631:    completion = ecma_op_object_define_own_property (obj_p,
        -:  632:                                                     ecma_get_magic_string (LIT_MAGIC_STRING_VALUE),
        -:  633:                                                     &prop_desc);
    #####:  634:    JERRY_ASSERT (ecma_is_value_true (completion));
        -:  635:
        -:  636:    /* b. */
    #####:  637:    prop_desc.value = ecma_make_boolean_value (src_prop_desc_p->flags & JERRY_PROP_IS_WRITABLE);
        -:  638:
    #####:  639:    completion = ecma_op_object_define_own_property (obj_p,
        -:  640:                                                     ecma_get_magic_string (LIT_MAGIC_STRING_WRITABLE),
        -:  641:                                                     &prop_desc);
    #####:  642:    JERRY_ASSERT (ecma_is_value_true (completion));
        -:  643:  }
        -:  644:  else
        -:  645:  {
        -:  646:#if !JERRY_ESNEXT
        -:  647:    JERRY_ASSERT (src_prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED));
        -:  648:#else /* JERRY_ESNEXT */
    #####:  649:    if (src_prop_desc_p->flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED))
        -:  650:#endif /* JERRY_ESNEXT */
        -:  651:    {
        -:  652:      /* a. */
    #####:  653:      if (src_prop_desc_p->get_p == NULL)
        -:  654:      {
    #####:  655:        prop_desc.value = ECMA_VALUE_UNDEFINED;
        -:  656:      }
        -:  657:      else
        -:  658:      {
    #####:  659:        prop_desc.value = ecma_make_object_value (src_prop_desc_p->get_p);
        -:  660:      }
        -:  661:
    #####:  662:      completion = ecma_op_object_define_own_property (obj_p,
        -:  663:                                                       ecma_get_magic_string (LIT_MAGIC_STRING_GET),
        -:  664:                                                       &prop_desc);
    #####:  665:      JERRY_ASSERT (ecma_is_value_true (completion));
        -:  666:
        -:  667:      /* b. */
    #####:  668:      if (src_prop_desc_p->set_p == NULL)
        -:  669:      {
    #####:  670:        prop_desc.value = ECMA_VALUE_UNDEFINED;
        -:  671:      }
        -:  672:      else
        -:  673:      {
    #####:  674:        prop_desc.value = ecma_make_object_value (src_prop_desc_p->set_p);
        -:  675:      }
        -:  676:
    #####:  677:      completion = ecma_op_object_define_own_property (obj_p,
        -:  678:                                                       ecma_get_magic_string (LIT_MAGIC_STRING_SET),
        -:  679:                                                       &prop_desc);
    #####:  680:      JERRY_ASSERT (ecma_is_value_true (completion));
        -:  681:    }
        -:  682:  }
        -:  683:
    #####:  684:  prop_desc.value = ecma_make_boolean_value (src_prop_desc_p->flags & JERRY_PROP_IS_ENUMERABLE);
        -:  685:
    #####:  686:  completion = ecma_op_object_define_own_property (obj_p,
        -:  687:                                                   ecma_get_magic_string (LIT_MAGIC_STRING_ENUMERABLE),
        -:  688:                                                   &prop_desc);
    #####:  689:  JERRY_ASSERT (ecma_is_value_true (completion));
        -:  690:
    #####:  691:  prop_desc.value = ecma_make_boolean_value (src_prop_desc_p->flags & JERRY_PROP_IS_CONFIGURABLE);
        -:  692:
    #####:  693:  completion = ecma_op_object_define_own_property (obj_p,
        -:  694:                                                   ecma_get_magic_string (LIT_MAGIC_STRING_CONFIGURABLE),
        -:  695:                                                   &prop_desc);
    #####:  696:  JERRY_ASSERT (ecma_is_value_true (completion));
        -:  697:
    #####:  698:  return obj_p;
        -:  699:} /* ecma_op_from_property_descriptor */
        -:  700:
        -:  701:/**
        -:  702: * ToPropertyDescriptor operation.
        -:  703: *
        -:  704: * See also:
        -:  705: *          ECMA-262 v5, 8.10.5
        -:  706: *
        -:  707: * @return ECMA_VALUE_EMPTY if successful, ECMA_VALUE_ERROR otherwise
        -:  708: */
        -:  709:ecma_value_t
    #####:  710:ecma_op_to_property_descriptor (ecma_value_t obj_value, /**< object value */
        -:  711:                                ecma_property_descriptor_t *out_prop_desc_p) /**< [out] filled property descriptor
        -:  712:                                                                              *   if the operation is successful,
        -:  713:                                                                              *   unmodified otherwise */
        -:  714:{
        -:  715:  /* 1. */
    #####:  716:  if (!ecma_is_value_object (obj_value))
        -:  717:  {
    #####:  718:    return ecma_raise_type_error (ECMA_ERR_MSG ("Expected an object"));
        -:  719:  }
        -:  720:
    #####:  721:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
    #####:  722:  ecma_value_t ret_value = ECMA_VALUE_ERROR;
        -:  723:
        -:  724:  /* 3. */
    #####:  725:  ecma_value_t enumerable_prop_value = ecma_op_object_find (obj_p,
        -:  726:                                                            ecma_get_magic_string (LIT_MAGIC_STRING_ENUMERABLE));
        -:  727:
    #####:  728:  if (ECMA_IS_VALUE_ERROR (enumerable_prop_value))
        -:  729:  {
    #####:  730:    return enumerable_prop_value;
        -:  731:  }
        -:  732:
        -:  733:  /* 2. */
    #####:  734:  ecma_property_descriptor_t prop_desc = ecma_make_empty_property_descriptor ();
        -:  735:
    #####:  736:  if (ecma_is_value_found (enumerable_prop_value))
        -:  737:  {
    #####:  738:    uint32_t is_enumerable = (ecma_op_to_boolean (enumerable_prop_value) ? JERRY_PROP_IS_ENUMERABLE
    #####:  739:                                                                         : JERRY_PROP_NO_OPTS);
        -:  740:
    #####:  741:    prop_desc.flags |= (uint16_t) (JERRY_PROP_IS_ENUMERABLE_DEFINED | is_enumerable);
        -:  742:
    #####:  743:    ecma_free_value (enumerable_prop_value);
        -:  744:  }
        -:  745:
        -:  746:  /* 4. */
    #####:  747:  ecma_value_t configurable_prop_value = ecma_op_object_find (obj_p,
        -:  748:                                                              ecma_get_magic_string (LIT_MAGIC_STRING_CONFIGURABLE));
        -:  749:
    #####:  750:  if (ECMA_IS_VALUE_ERROR (configurable_prop_value))
        -:  751:  {
    #####:  752:    goto free_desc;
        -:  753:  }
        -:  754:
    #####:  755:  if (ecma_is_value_found (configurable_prop_value))
        -:  756:  {
    #####:  757:    uint32_t is_configurable = (ecma_op_to_boolean (configurable_prop_value) ? JERRY_PROP_IS_CONFIGURABLE
    #####:  758:                                                                             : JERRY_PROP_NO_OPTS);
        -:  759:
    #####:  760:    prop_desc.flags |= (uint16_t) (JERRY_PROP_IS_CONFIGURABLE_DEFINED | is_configurable);
        -:  761:
    #####:  762:    ecma_free_value (configurable_prop_value);
        -:  763:  }
        -:  764:
        -:  765:  /* 5. */
    #####:  766:  ecma_value_t value_prop_value = ecma_op_object_find (obj_p,
        -:  767:                                                       ecma_get_magic_string (LIT_MAGIC_STRING_VALUE));
        -:  768:
    #####:  769:  if (ECMA_IS_VALUE_ERROR (value_prop_value))
        -:  770:  {
    #####:  771:    goto free_desc;
        -:  772:  }
        -:  773:
    #####:  774:  if (ecma_is_value_found (value_prop_value))
        -:  775:  {
    #####:  776:    prop_desc.flags |= JERRY_PROP_IS_VALUE_DEFINED;
    #####:  777:    prop_desc.value = ecma_copy_value (value_prop_value);
    #####:  778:    ecma_free_value (value_prop_value);
        -:  779:  }
        -:  780:
        -:  781:  /* 6. */
    #####:  782:  ecma_value_t writable_prop_value = ecma_op_object_find (obj_p,
        -:  783:                                                          ecma_get_magic_string (LIT_MAGIC_STRING_WRITABLE));
        -:  784:
    #####:  785:  if (ECMA_IS_VALUE_ERROR (writable_prop_value))
        -:  786:  {
    #####:  787:    goto free_desc;
        -:  788:  }
        -:  789:
    #####:  790:  if (ecma_is_value_found (writable_prop_value))
        -:  791:  {
    #####:  792:    uint32_t is_writable = (ecma_op_to_boolean (writable_prop_value) ? JERRY_PROP_IS_WRITABLE
    #####:  793:                                                                     : JERRY_PROP_NO_OPTS);
        -:  794:
    #####:  795:    prop_desc.flags |= (uint16_t) (JERRY_PROP_IS_WRITABLE_DEFINED | is_writable);
        -:  796:
    #####:  797:    ecma_free_value (writable_prop_value);
        -:  798:  }
        -:  799:
        -:  800:  /* 7. */
    #####:  801:  ecma_value_t get_prop_value = ecma_op_object_find (obj_p,
        -:  802:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_GET));
        -:  803:
    #####:  804:  if (ECMA_IS_VALUE_ERROR (get_prop_value))
        -:  805:  {
    #####:  806:    goto free_desc;
        -:  807:  }
        -:  808:
    #####:  809:  if (ecma_is_value_found (get_prop_value))
        -:  810:  {
    #####:  811:    if (!ecma_op_is_callable (get_prop_value)
    #####:  812:        && !ecma_is_value_undefined (get_prop_value))
        -:  813:    {
    #####:  814:      ecma_free_value (get_prop_value);
    #####:  815:      ret_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));
    #####:  816:      goto free_desc;
        -:  817:    }
        -:  818:
    #####:  819:    prop_desc.flags |= JERRY_PROP_IS_GET_DEFINED;
        -:  820:
    #####:  821:    if (ecma_is_value_undefined (get_prop_value))
        -:  822:    {
    #####:  823:      prop_desc.get_p = NULL;
        -:  824:    }
        -:  825:    else
        -:  826:    {
    #####:  827:      JERRY_ASSERT (ecma_is_value_object (get_prop_value));
        -:  828:
    #####:  829:      ecma_object_t *get_p = ecma_get_object_from_value (get_prop_value);
    #####:  830:      ecma_ref_object (get_p);
        -:  831:
    #####:  832:      prop_desc.get_p = get_p;
        -:  833:    }
        -:  834:
    #####:  835:    ecma_free_value (get_prop_value);
        -:  836:  }
        -:  837:
        -:  838:  /* 8. */
    #####:  839:  ecma_value_t set_prop_value = ecma_op_object_find (obj_p,
        -:  840:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_SET));
        -:  841:
    #####:  842:  if (ECMA_IS_VALUE_ERROR (set_prop_value))
        -:  843:  {
    #####:  844:    goto free_desc;
        -:  845:  }
        -:  846:
    #####:  847:  if (ecma_is_value_found (set_prop_value))
        -:  848:  {
    #####:  849:    if (!ecma_op_is_callable (set_prop_value)
    #####:  850:        && !ecma_is_value_undefined (set_prop_value))
        -:  851:    {
    #####:  852:      ecma_free_value (set_prop_value);
    #####:  853:      ret_value = ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_expected_a_function));
    #####:  854:      goto free_desc;
        -:  855:    }
        -:  856:
    #####:  857:    prop_desc.flags |= JERRY_PROP_IS_SET_DEFINED;
        -:  858:
    #####:  859:    if (ecma_is_value_undefined (set_prop_value))
        -:  860:    {
    #####:  861:      prop_desc.set_p = NULL;
        -:  862:    }
        -:  863:    else
        -:  864:    {
    #####:  865:      JERRY_ASSERT (ecma_is_value_object (set_prop_value));
        -:  866:
    #####:  867:      ecma_object_t *set_p = ecma_get_object_from_value (set_prop_value);
    #####:  868:      ecma_ref_object (set_p);
        -:  869:
    #####:  870:      prop_desc.set_p = set_p;
        -:  871:    }
        -:  872:
    #####:  873:    ecma_free_value (set_prop_value);
        -:  874:  }
        -:  875:
        -:  876:  /* 9. */
    #####:  877:  if ((prop_desc.flags & (JERRY_PROP_IS_VALUE_DEFINED | JERRY_PROP_IS_WRITABLE_DEFINED))
    #####:  878:        && (prop_desc.flags & (JERRY_PROP_IS_GET_DEFINED | JERRY_PROP_IS_SET_DEFINED)))
        -:  879:  {
    #####:  880:    ret_value = ecma_raise_type_error (ECMA_ERR_MSG ("Accessors cannot be writable"));
        -:  881:  }
        -:  882:  else
        -:  883:  {
    #####:  884:    *out_prop_desc_p = prop_desc;
    #####:  885:    ret_value = ECMA_VALUE_EMPTY;
        -:  886:  }
        -:  887:
    #####:  888:free_desc:
    #####:  889:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  890:  {
    #####:  891:    ecma_free_property_descriptor (&prop_desc);
        -:  892:  }
        -:  893:
    #####:  894:  return ret_value;
        -:  895:} /* ecma_op_to_property_descriptor */
        -:  896:
        -:  897:/**
        -:  898: * IsInteger operation.
        -:  899: *
        -:  900: * See also:
        -:  901: *          ECMA-262 v5, 9.4
        -:  902: *          ECMA-262 v6, 7.1.4
        -:  903: *
        -:  904: * @return true - if the argument is integer
        -:  905: *              false - otherwise
        -:  906: */
        -:  907:bool
    #####:  908:ecma_op_is_integer (ecma_number_t num) /**< ecma number */
        -:  909:{
        -:  910:
    #####:  911:  if (ecma_number_is_nan (num) || ecma_number_is_infinity (num))
        -:  912:  {
    #####:  913:    return false;
        -:  914:  }
        -:  915:
    #####:  916:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (num));
    #####:  917:  ecma_number_t fabs_value = (ecma_number_t) fabs (num);
        -:  918:
    #####:  919:  return (floor_fabs == fabs_value);
        -:  920:} /* ecma_op_is_integer*/
        -:  921:/**
        -:  922: * ToInteger operation.
        -:  923: *
        -:  924: * See also:
        -:  925: *          ECMA-262 v5, 9.4
        -:  926: *          ECMA-262 v6, 7.1.4
        -:  927: *
        -:  928: * @return ECMA_VALUE_EMPTY if successful
        -:  929: *         conversion error otherwise
        -:  930: */
        -:  931:ecma_value_t
        1:  932:ecma_op_to_integer (ecma_value_t value, /**< ecma value */
        -:  933:                    ecma_number_t *number_p) /**< [out] ecma number */
        -:  934:{
        1:  935:  if (ECMA_IS_VALUE_ERROR (value))
        -:  936:  {
    #####:  937:    return value;
        -:  938:  }
        -:  939:
        -:  940:  /* 1 */
        1:  941:  ecma_value_t to_number = ecma_op_to_number (value, number_p);
        -:  942:
        -:  943:  /* 2 */
        1:  944:  if (ECMA_IS_VALUE_ERROR (to_number))
        -:  945:  {
    #####:  946:    return to_number;
        -:  947:  }
        -:  948:
        1:  949:  ecma_number_t number = *number_p;
        -:  950:
        -:  951:  /* 3 */
        1:  952:  if (ecma_number_is_nan (number))
        -:  953:  {
    #####:  954:    *number_p = ECMA_NUMBER_ZERO;
    #####:  955:    return ECMA_VALUE_EMPTY;
        -:  956:  }
        -:  957:
        -:  958:  /* 4 */
        1:  959:  if (ecma_number_is_zero (number) || ecma_number_is_infinity (number))
        -:  960:  {
    #####:  961:    return ECMA_VALUE_EMPTY;
        -:  962:  }
        -:  963:
        1:  964:  ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number));
        -:  965:  /* 5 */
        1:  966:  *number_p = ecma_number_is_negative (number) ? -floor_fabs : floor_fabs;
        1:  967:  return ECMA_VALUE_EMPTY;
        -:  968:} /* ecma_op_to_integer */
        -:  969:
        -:  970:/**
        -:  971: * ToLength operation.
        -:  972: *
        -:  973: * See also:
        -:  974: *          ECMA-262 v6, 7.1.15
        -:  975: *
        -:  976: * @return ECMA_VALUE_EMPTY if successful
        -:  977: *         conversion error otherwise
        -:  978: */
        -:  979:ecma_value_t
        1:  980:ecma_op_to_length (ecma_value_t value, /**< ecma value */
        -:  981:                   ecma_length_t *length) /**< [out] ecma number */
        -:  982:{
        -:  983:  /* 1 */
        1:  984:  if (ECMA_IS_VALUE_ERROR (value))
        -:  985:  {
    #####:  986:    return value;
        -:  987:  }
        -:  988:
        -:  989:#if JERRY_ESNEXT
        -:  990:  /* 2 */
        1:  991:  ecma_number_t num;
        1:  992:  ecma_value_t length_num = ecma_op_to_integer (value, &num);
        -:  993:
        -:  994:  /* 3 */
        1:  995:  if (ECMA_IS_VALUE_ERROR (length_num))
        -:  996:  {
    #####:  997:    return length_num;
        -:  998:  }
        -:  999:
        -: 1000:  /* 4 */
        1: 1001:  if (num <= 0.0f)
        -: 1002:  {
    #####: 1003:    *length = 0;
    #####: 1004:    return ECMA_VALUE_EMPTY;
        -: 1005:  }
        -: 1006:
        -: 1007:  /* 5 */
        1: 1008:  if (num >= ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1009:  {
    #####: 1010:    *length = (ecma_length_t) ECMA_NUMBER_MAX_SAFE_INTEGER;
    #####: 1011:    return ECMA_VALUE_EMPTY;
        -: 1012:  }
        -: 1013:
        -: 1014:  /* 6 */
        1: 1015:  *length = (ecma_length_t) num;
        1: 1016:  return ECMA_VALUE_EMPTY;
        -: 1017:#else /* !JERRY_ESNEXT */
        -: 1018:  /* In the case of ES5, ToLength(ES6) operation is the same as ToUint32(ES5) */
        -: 1019:  ecma_number_t num;
    #####: 1020:  ecma_value_t to_number = ecma_op_to_number (value, &num);
        -: 1021:
        -: 1022:  /* 2 */
    #####: 1023:  if (ECMA_IS_VALUE_ERROR (to_number))
        -: 1024:  {
        -: 1025:    return to_number;
        -: 1026:  }
        -: 1027:
    #####: 1028:  *length = ecma_number_to_uint32 (num);
    #####: 1029:  return ECMA_VALUE_EMPTY;
        -: 1030:#endif /* JERRY_ESNEXT */
        -: 1031:} /* ecma_op_to_length */
        -: 1032:
        -: 1033:#if JERRY_ESNEXT
        -: 1034:/**
        -: 1035: * ToIndex operation.
        -: 1036: *
        -: 1037: * See also:
        -: 1038: *          ECMA-262 v11, 7.1.22
        -: 1039: *
        -: 1040: * @return ECMA_VALUE_EMPTY if successful
        -: 1041: *         conversion error otherwise
        -: 1042: */
        -: 1043:ecma_value_t
    #####: 1044:ecma_op_to_index (ecma_value_t value, /**< ecma value */
        -: 1045:                  ecma_number_t *index) /**< [out] ecma number */
        -: 1046:{
        -: 1047:  /* 1. */
    #####: 1048:  if (ecma_is_value_undefined (value))
        -: 1049:  {
    #####: 1050:    *index = 0;
    #####: 1051:    return ECMA_VALUE_EMPTY;
        -: 1052:  }
        -: 1053:
        -: 1054:  /* 2.a */
    #####: 1055:  ecma_number_t integer_index;
    #####: 1056:  ecma_value_t index_value = ecma_op_to_integer (value, &integer_index);
        -: 1057:
    #####: 1058:  if (ECMA_IS_VALUE_ERROR (index_value))
        -: 1059:  {
    #####: 1060:    return index_value;
        -: 1061:  }
        -: 1062:
        -: 1063:  /* 2.b - 2.d */
    #####: 1064:  if (integer_index < 0.0f || integer_index > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -: 1065:  {
    #####: 1066:    return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid or out-of-range index"));
        -: 1067:  }
        -: 1068:
        -: 1069:  /* 3. */
    #####: 1070:  *index = integer_index;
    #####: 1071:  return ECMA_VALUE_EMPTY;
        -: 1072:} /* ecma_op_to_index */
        -: 1073:
        -: 1074:/**
        -: 1075: * CreateListFromArrayLike operation.
        -: 1076: * Different types are not handled yet.
        -: 1077: *
        -: 1078: * See also:
        -: 1079: *          ECMA-262 v6, 7.3.17
        -: 1080: *
        -: 1081: * @return ecma_collection_t if successful
        -: 1082: *         NULL otherwise
        -: 1083: */
        -: 1084:ecma_collection_t *
    #####: 1085:ecma_op_create_list_from_array_like (ecma_value_t arr,  /**< array value */
        -: 1086:                                     bool prop_names_only) /**< true - accept only property names
        -: 1087:                                                                false - otherwise */
        -: 1088:{
        -: 1089:  /* 1. */
    #####: 1090:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (arr));
        -: 1091:
        -: 1092:  /* 3. */
    #####: 1093:  if (!ecma_is_value_object (arr))
        -: 1094:  {
    #####: 1095:    ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_argument_is_not_an_object));
    #####: 1096:    return NULL;
        -: 1097:  }
    #####: 1098:  ecma_object_t *obj_p = ecma_get_object_from_value (arr);
        -: 1099:
        -: 1100:  /* 4. 5. */
    #####: 1101:  ecma_length_t len;
    #####: 1102:  if (ECMA_IS_VALUE_ERROR (ecma_op_object_get_length (obj_p, &len)))
        -: 1103:  {
    #####: 1104:    return NULL;
        -: 1105:  }
        -: 1106:
        -: 1107:  /* 6. */
    #####: 1108:  ecma_collection_t *list_ptr = ecma_new_collection ();
        -: 1109:
        -: 1110:  /* 7. 8. */
    #####: 1111:  for (ecma_length_t idx = 0; idx < len; idx++)
        -: 1112:  {
    #####: 1113:    ecma_value_t next = ecma_op_object_get_by_index (obj_p, idx);
    #####: 1114:    if (ECMA_IS_VALUE_ERROR (next))
        -: 1115:    {
    #####: 1116:      ecma_collection_free (list_ptr);
    #####: 1117:      return NULL;
        -: 1118:    }
        -: 1119:
    #####: 1120:    if (prop_names_only
    #####: 1121:        && !ecma_is_value_prop_name (next))
        -: 1122:    {
    #####: 1123:      ecma_free_value (next);
    #####: 1124:      ecma_collection_free (list_ptr);
    #####: 1125:      ecma_raise_type_error (ECMA_ERR_MSG ("Property name is neither Symbol nor string"));
    #####: 1126:      return NULL;
        -: 1127:    }
        -: 1128:
    #####: 1129:    ecma_collection_push_back (list_ptr, next);
        -: 1130:  }
        -: 1131:
        -: 1132:  /* 9. */
    #####: 1133:  return list_ptr;
        -: 1134:} /* ecma_op_create_list_from_array_like */
        -: 1135:#endif /* JERRY_ESNEXT */
        -: 1136:
        -: 1137:/**
        -: 1138: * @}
        -: 1139: * @}
        -: 1140: */
