        -:    0:Source:/home/workspace/jerry-core/ecma/builtin-objects/ecma-builtin-helpers.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-builtin-helpers.h"
        -:   17:
        -:   18:#include "ecma-alloc.h"
        -:   19:#include "ecma-array-object.h"
        -:   20:#include "ecma-builtins.h"
        -:   21:#include "ecma-conversion.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-exceptions.h"
        -:   24:#include "ecma-gc.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "jmem.h"
        -:   27:#include "ecma-objects.h"
        -:   28:#include "lit-magic-strings.h"
        -:   29:#include "lit-char-helpers.h"
        -:   30:
        -:   31:/** \addtogroup ecma ECMA
        -:   32: * @{
        -:   33: *
        -:   34: * \addtogroup ecmabuiltinhelpers ECMA builtin helper operations
        -:   35: * @{
        -:   36: */
        -:   37:
        -:   38:#if JERRY_ESNEXT
        -:   39:/**
        -:   40: * Helper function for Object.prototype.toString routine when
        -:   41: * the @@toStringTag property is present
        -:   42: *
        -:   43: * See also:
        -:   44: *          ECMA-262 v6, 19.1.3.6
        -:   45: *
        -:   46: * @return ecma value
        -:   47: *         Returned value must be freed with ecma_free_value.
        -:   48: */
        -:   49:static ecma_value_t
    #####:   50:ecma_builtin_helper_object_to_string_tag_helper (ecma_value_t tag_value) /**< string tag */
        -:   51:{
    #####:   52:  JERRY_ASSERT (ecma_is_value_string (tag_value));
        -:   53:
    #####:   54:  ecma_string_t *tag_str_p = ecma_get_string_from_value (tag_value);
        -:   55:  ecma_string_t *ret_string_p;
        -:   56:
        -:   57:  /* Building string "[object #@@toStringTag#]"
        -:   58:     The string size will be size("[object ") + size(#@@toStringTag#) + size ("]"). */
    #####:   59:  const lit_utf8_size_t buffer_size = 9 + ecma_string_get_size (tag_str_p);
    #####:   60:  JMEM_DEFINE_LOCAL_ARRAY (str_buffer, buffer_size, lit_utf8_byte_t);
        -:   61:
    #####:   62:  lit_utf8_byte_t *buffer_ptr = str_buffer;
        -:   63:
    #####:   64:  const lit_magic_string_id_t magic_string_ids[] =
        -:   65:  {
        -:   66:    LIT_MAGIC_STRING_LEFT_SQUARE_CHAR,
        -:   67:    LIT_MAGIC_STRING_OBJECT,
        -:   68:    LIT_MAGIC_STRING_SPACE_CHAR,
        -:   69:  };
        -:   70:
        -:   71:  /* Copy to buffer the "[object " string */
    #####:   72:  for (uint32_t i = 0; i < sizeof (magic_string_ids) / sizeof (lit_magic_string_id_t); ++i)
        -:   73:  {
    #####:   74:    buffer_ptr = lit_copy_magic_string_to_buffer (magic_string_ids[i], buffer_ptr,
    #####:   75:                                                  (lit_utf8_size_t) ((str_buffer + buffer_size) - buffer_ptr));
        -:   76:
    #####:   77:    JERRY_ASSERT (buffer_ptr <= str_buffer + buffer_size);
        -:   78:  }
        -:   79:
        -:   80:  /* Copy to buffer the #@@toStringTag# string */
    #####:   81:  buffer_ptr += ecma_string_copy_to_cesu8_buffer (tag_str_p, buffer_ptr,
    #####:   82:                                                  (lit_utf8_size_t) ((str_buffer + buffer_size) - buffer_ptr));
        -:   83:
    #####:   84:  JERRY_ASSERT (buffer_ptr <= str_buffer + buffer_size);
        -:   85:
        -:   86:  /* Copy to buffer the "]" string */
    #####:   87:  buffer_ptr = lit_copy_magic_string_to_buffer (LIT_MAGIC_STRING_RIGHT_SQUARE_CHAR, buffer_ptr,
    #####:   88:                                                (lit_utf8_size_t) ((str_buffer + buffer_size) - buffer_ptr));
        -:   89:
    #####:   90:  JERRY_ASSERT (buffer_ptr <= str_buffer + buffer_size);
        -:   91:
    #####:   92:  ret_string_p = ecma_new_ecma_string_from_utf8 (str_buffer, (lit_utf8_size_t) (buffer_ptr - str_buffer));
        -:   93:
    #####:   94:  JMEM_FINALIZE_LOCAL_ARRAY (str_buffer);
    #####:   95:  ecma_deref_ecma_string (tag_str_p);
        -:   96:
    #####:   97:  return ecma_make_string_value (ret_string_p);
        -:   98:} /* ecma_builtin_helper_object_to_string_tag_helper */
        -:   99:#endif /* JERRY_ESNEXT */
        -:  100:
        -:  101:/**
        -:  102: * Common implementation of the Object.prototype.toString routine
        -:  103: *
        -:  104: * See also:
        -:  105: *          ECMA-262 v5, 15.2.4.2
        -:  106: *
        -:  107: * Used by:
        -:  108: *         - The Object.prototype.toString routine.
        -:  109: *         - The Array.prototype.toString routine as fallback.
        -:  110: *
        -:  111: * @return ecma value
        -:  112: *         Returned value must be freed with ecma_free_value.
        -:  113: */
        -:  114:
        -:  115:ecma_value_t
    #####:  116:ecma_builtin_helper_object_to_string (const ecma_value_t this_arg) /**< this argument */
        -:  117:{
        -:  118:  lit_magic_string_id_t builtin_tag;
        -:  119:
    #####:  120:  if (ecma_is_value_undefined (this_arg))
        -:  121:  {
    #####:  122:    builtin_tag = LIT_MAGIC_STRING_UNDEFINED_UL;
        -:  123:  }
    #####:  124:  else if (ecma_is_value_null (this_arg))
        -:  125:  {
    #####:  126:    builtin_tag = LIT_MAGIC_STRING_NULL_UL;
        -:  127:  }
        -:  128:  else
        -:  129:  {
    #####:  130:    ecma_value_t obj_this = ecma_op_to_object (this_arg);
        -:  131:
    #####:  132:    if (ECMA_IS_VALUE_ERROR (obj_this))
        -:  133:    {
    #####:  134:      return obj_this;
        -:  135:    }
        -:  136:
    #####:  137:    JERRY_ASSERT (ecma_is_value_object (obj_this));
        -:  138:
    #####:  139:    ecma_object_t *obj_p = ecma_get_object_from_value (obj_this);
        -:  140:
    #####:  141:    builtin_tag = ecma_object_get_class_name (obj_p);
        -:  142:
        -:  143:#if JERRY_ESNEXT
    #####:  144:    ecma_value_t is_array = ecma_is_value_array (obj_this);
        -:  145:
    #####:  146:    if (ECMA_IS_VALUE_ERROR (is_array))
        -:  147:    {
    #####:  148:      ecma_deref_object (obj_p);
    #####:  149:      return is_array;
        -:  150:    }
        -:  151:
    #####:  152:    if (ecma_is_value_true (is_array))
        -:  153:    {
    #####:  154:      builtin_tag = LIT_MAGIC_STRING_ARRAY_UL;
        -:  155:    }
        -:  156:
    #####:  157:    ecma_value_t tag = ecma_op_object_get_by_symbol_id (obj_p, LIT_GLOBAL_SYMBOL_TO_STRING_TAG);
        -:  158:
    #####:  159:    if (ECMA_IS_VALUE_ERROR (tag))
        -:  160:    {
    #####:  161:      ecma_deref_object (obj_p);
    #####:  162:      return tag;
        -:  163:    }
        -:  164:
    #####:  165:    if (ecma_is_value_string (tag))
        -:  166:    {
    #####:  167:      ecma_deref_object (obj_p);
    #####:  168:      return ecma_builtin_helper_object_to_string_tag_helper (tag);
        -:  169:    }
    #####:  170:    else if (builtin_tag != LIT_MAGIC_STRING_ARGUMENTS_UL
    #####:  171:             && builtin_tag != LIT_MAGIC_STRING_FUNCTION_UL
    #####:  172:             && builtin_tag != LIT_MAGIC_STRING_ERROR_UL
    #####:  173:             && builtin_tag != LIT_MAGIC_STRING_BOOLEAN_UL
    #####:  174:             && builtin_tag != LIT_MAGIC_STRING_NUMBER_UL
    #####:  175:             && builtin_tag != LIT_MAGIC_STRING_STRING_UL
    #####:  176:             && builtin_tag != LIT_MAGIC_STRING_DATE_UL
    #####:  177:             && builtin_tag != LIT_MAGIC_STRING_REGEXP_UL
    #####:  178:             && builtin_tag != LIT_MAGIC_STRING_ARRAY_UL)
        -:  179:    {
    #####:  180:      builtin_tag = LIT_MAGIC_STRING_OBJECT_UL;
        -:  181:    }
        -:  182:
    #####:  183:    ecma_free_value (tag);
        -:  184:#endif /* JERRY_ESNEXT */
        -:  185:
    #####:  186:    ecma_deref_object (obj_p);
        -:  187:  }
        -:  188:
    #####:  189:  ecma_stringbuilder_t builder = ecma_stringbuilder_create ();
        -:  190:
    #####:  191:  ecma_stringbuilder_append_magic (&builder, LIT_MAGIC_STRING_OBJECT_TO_STRING_UL);
    #####:  192:  ecma_stringbuilder_append_magic (&builder, builtin_tag);
    #####:  193:  ecma_stringbuilder_append_byte (&builder, LIT_CHAR_RIGHT_SQUARE);
        -:  194:
    #####:  195:  return ecma_make_string_value (ecma_stringbuilder_finalize (&builder));
        -:  196:} /* ecma_builtin_helper_object_to_string */
        -:  197:
        -:  198:/**
        -:  199: * The Array.prototype's 'toLocaleString' single element operation routine
        -:  200: *
        -:  201: * See also:
        -:  202: *          ECMA-262 v5, 15.4.4.3 steps 6-8 and 10.b-d
        -:  203: *
        -:  204: * @return ecma value
        -:  205: *         Returned value must be freed with ecma_free_value.
        -:  206: */
        -:  207:ecma_string_t *
    #####:  208:ecma_builtin_helper_get_to_locale_string_at_index (ecma_object_t *obj_p, /**< this object */
        -:  209:                                                   ecma_length_t index) /**< array index */
        -:  210:{
    #####:  211:  ecma_value_t index_value = ecma_op_object_get_by_index (obj_p, index);
        -:  212:
    #####:  213:  if (ECMA_IS_VALUE_ERROR (index_value))
        -:  214:  {
    #####:  215:    return NULL;
        -:  216:  }
        -:  217:
    #####:  218:  if (ecma_is_value_undefined (index_value) || ecma_is_value_null (index_value))
        -:  219:  {
    #####:  220:    return ecma_get_magic_string (LIT_MAGIC_STRING__EMPTY);
        -:  221:  }
        -:  222:
    #####:  223:  ecma_value_t call_value = ecma_op_invoke_by_magic_id (index_value, LIT_MAGIC_STRING_TO_LOCALE_STRING_UL, NULL, 0);
        -:  224:
    #####:  225:  ecma_free_value (index_value);
        -:  226:
    #####:  227:  if (ECMA_IS_VALUE_ERROR (call_value))
        -:  228:  {
    #####:  229:    return NULL;
        -:  230:  }
        -:  231:
    #####:  232:  ecma_string_t *ret_string_p = ecma_op_to_string (call_value);
        -:  233:
    #####:  234:  ecma_free_value (call_value);
        -:  235:
    #####:  236:  return ret_string_p;
        -:  237:} /* ecma_builtin_helper_get_to_locale_string_at_index */
        -:  238:
        -:  239:/**
        -:  240: * Helper function to normalizing an array index
        -:  241: *
        -:  242: * See also:
        -:  243: *          ECMA-262 v5, 15.4.4.10 steps 5, 6, 7 part 2, 8
        -:  244: *          ECMA-262 v5, 15.4.4.12 steps 5, 6
        -:  245: *
        -:  246: *          ECMA-262 v6, 22.1.3.6 steps 5 - 7, 8 part 2, 9, 10
        -:  247: *          ECMA-262 v6, 22.1.3.3 steps 5 - 10, 11 part 2, 12, 13
        -:  248: *
        -:  249: * Used by:
        -:  250: *         - The Array.prototype.slice routine.
        -:  251: *         - The Array.prototype.splice routine.
        -:  252: *         - The Array.prototype.fill routine.
        -:  253: *         - The Array.prototype.copyWithin routine.
        -:  254: *
        -:  255: * @return ECMA_VALUE_EMPTY if successful
        -:  256: *         conversion error otherwise
        -:  257: */
        -:  258:ecma_value_t
    #####:  259:ecma_builtin_helper_array_index_normalize (ecma_value_t arg, /**< index */
        -:  260:                                           ecma_length_t length, /**< array's length */
        -:  261:                                           ecma_length_t *number_p) /**< [out] ecma_length_t */
        -:  262:{
        -:  263:#if JERRY_ESNEXT
    #####:  264:  ecma_number_t to_int;
        -:  265:
    #####:  266:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg, &to_int)))
        -:  267:  {
    #####:  268:    return ECMA_VALUE_ERROR;
        -:  269:  }
        -:  270:
    #####:  271:  *number_p = ((to_int < 0) ? (ecma_length_t) JERRY_MAX (((ecma_number_t) length + to_int), 0)
    #####:  272:                            : (ecma_length_t) JERRY_MIN (to_int, (ecma_number_t) length));
        -:  273:
    #####:  274:  return ECMA_VALUE_EMPTY;
        -:  275:#else /* !JERRY_ESNEXT */
    #####:  276:  return ecma_builtin_helper_uint32_index_normalize (arg, length, number_p);
        -:  277:#endif /* JERRY_ESNEXT */
        -:  278:} /* ecma_builtin_helper_array_index_normalize */
        -:  279:
        -:  280:/**
        -:  281: * Helper function to normalizing an uint32 index
        -:  282: *
        -:  283: * See also:
        -:  284: *          ECMA-262 v5, 15.5.4.13 steps 4 - 7
        -:  285: *          ECMA-262 v6, 22.2.3.5 steps 5 - 10, 11 part 2, 12, 13
        -:  286: *          ECMA-262 v6, 22.2.3.23 steps 5 - 10
        -:  287: *          ECMA-262 v6, 24.1.4.3 steps 6 - 8, 9 part 2, 10, 11
        -:  288: *          ECMA-262 v6, 22.2.3.26 steps 7 - 9, 10 part 2, 11, 12
        -:  289: *          ECMA-262 v6, 22.2.3.8 steps 5 - 7, 8 part 2, 9, 10
        -:  290: *
        -:  291: * Used by:
        -:  292: *         - The String.prototype.slice routine.
        -:  293: *         - The Array.prototype.copyWithin routine.
        -:  294: *         - The TypedArray.prototype.copyWithin routine.
        -:  295: *         - The TypedArray.prototype.slice routine.
        -:  296: *         - The ArrayBuffer.prototype.slice routine.
        -:  297: *         - The TypedArray.prototype.subarray routine.
        -:  298: *         - The TypedArray.prototype.fill routine.
        -:  299: *
        -:  300: * @return ECMA_VALUE_EMPTY if successful
        -:  301: *         conversion error otherwise
        -:  302: */
        -:  303:ecma_value_t
    #####:  304:ecma_builtin_helper_uint32_index_normalize (ecma_value_t arg, /**< index */
        -:  305:                                            uint32_t length, /**< array's length */
        -:  306:                                            uint32_t *number_p) /**< [out] uint32_t number */
        -:  307:{
    #####:  308:  ecma_number_t to_int;
        -:  309:
    #####:  310:  if (ECMA_IS_VALUE_ERROR (ecma_op_to_integer (arg, &to_int)))
        -:  311:  {
    #####:  312:    return ECMA_VALUE_ERROR;
        -:  313:  }
        -:  314:
    #####:  315:  *number_p = ((to_int < 0) ? (uint32_t) JERRY_MAX ((ecma_number_t) length + to_int, 0)
    #####:  316:                            : (uint32_t) JERRY_MIN (to_int, (ecma_number_t) length));
        -:  317:
    #####:  318:  return ECMA_VALUE_EMPTY;
        -:  319:} /* ecma_builtin_helper_uint32_index_normalize */
        -:  320:
        -:  321:/**
        -:  322: * Helper function for concatenating an ecma_value_t to an Array.
        -:  323: *
        -:  324: * See also:
        -:  325: *          ECMA-262 v5, 15.4.4.4 steps 5.b - 5.c
        -:  326: *
        -:  327: * Used by:
        -:  328: *         - The Array.prototype.concat routine.
        -:  329: *
        -:  330: * @return ecma value
        -:  331: *         Returned value must be freed with ecma_free_value.
        -:  332: */
        -:  333:ecma_value_t
    #####:  334:ecma_builtin_helper_array_concat_value (ecma_object_t *array_obj_p, /**< array */
        -:  335:                                        ecma_length_t *length_p, /**< [in,out] array's length */
        -:  336:                                        ecma_value_t value) /**< value to concat */
        -:  337:{
        -:  338:  /* 5.b */
        -:  339:#if JERRY_ESNEXT
    #####:  340:  ecma_value_t is_spreadable = ecma_op_is_concat_spreadable (value);
        -:  341:
    #####:  342:  if (ECMA_IS_VALUE_ERROR (is_spreadable))
        -:  343:  {
    #####:  344:    return is_spreadable;
        -:  345:  }
        -:  346:
    #####:  347:  bool spread_object = is_spreadable == ECMA_VALUE_TRUE;
        -:  348:  /* ES11: 22.1.3.1.5.c.iv.3.b */
    #####:  349:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE | JERRY_PROP_SHOULD_THROW;
        -:  350:#else /* !JERRY_ESNEXT */
        -:  351:  /* ES5.1: 15.4.4.4.5.b.iii.3.b */
    #####:  352:  const uint32_t prop_flags = ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE;
    #####:  353:  bool spread_object = ecma_is_value_true (ecma_is_value_array (value));
        -:  354:#endif /* JERRY_ESNEXT */
        -:  355:
    #####:  356:  if (spread_object)
        -:  357:  {
    #####:  358:    ecma_object_t *obj_p = ecma_get_object_from_value (value);
        -:  359:
        -:  360:#if JERRY_ESNEXT
    #####:  361:    ecma_length_t arg_len;
    #####:  362:    ecma_value_t error = ecma_op_object_get_length (obj_p, &arg_len);
        -:  363:
    #####:  364:    if (ECMA_IS_VALUE_ERROR (error))
        -:  365:    {
    #####:  366:      return error;
        -:  367:    }
        -:  368:
        -:  369:    /* 4 . */
    #####:  370:    if ((ecma_number_t) (*length_p + arg_len) > ECMA_NUMBER_MAX_SAFE_INTEGER)
        -:  371:    {
    #####:  372:      return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_invalid_array_length));
        -:  373:    }
        -:  374:#else /* !JERRY_ESNEXT */
        -:  375:    /* 5.b.ii */
    #####:  376:    uint32_t arg_len = ecma_array_get_length (obj_p);
        -:  377:#endif /* JERRY_ESNEXT */
        -:  378:    /* 5.b.iii */
    #####:  379:    for (ecma_length_t array_index = 0; array_index < arg_len; array_index++)
        -:  380:    {
        -:  381:      /* 5.b.iii.2 */
    #####:  382:      ecma_value_t get_value = ecma_op_object_find_by_index (obj_p, array_index);
        -:  383:
    #####:  384:      if (ECMA_IS_VALUE_ERROR (get_value))
        -:  385:      {
    #####:  386:        return get_value;
        -:  387:      }
        -:  388:
    #####:  389:      if (!ecma_is_value_found (get_value))
        -:  390:      {
    #####:  391:        continue;
        -:  392:      }
        -:  393:
        -:  394:      /* 5.b.iii.3.b */
        -:  395:      /* This will always be a simple value since 'is_throw' is false, so no need to free. */
    #####:  396:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
    #####:  397:                                                                     *length_p + array_index,
        -:  398:                                                                     get_value,
        -:  399:                                                                     prop_flags);
    #####:  400:      ecma_free_value (get_value);
        -:  401:#if JERRY_ESNEXT
    #####:  402:      if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  403:      {
    #####:  404:        return put_comp;
        -:  405:      }
        -:  406:#else /* !JERRY_ESNEXT */
        -:  407:      JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  408:#endif /* JERRY_ESNEXT */
        -:  409:    }
        -:  410:
    #####:  411:    *length_p += arg_len;
    #####:  412:    return ECMA_VALUE_EMPTY;
        -:  413:  }
        -:  414:
        -:  415:  /* 5.c.i */
        -:  416:  /* This will always be a simple value since 'is_throw' is false, so no need to free. */
    #####:  417:  ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
    #####:  418:                                                                 (*length_p)++,
        -:  419:                                                                 value,
        -:  420:                                                                 prop_flags);
        -:  421:
        -:  422:#if JERRY_ESNEXT
    #####:  423:  if (ECMA_IS_VALUE_ERROR (put_comp))
        -:  424:  {
    #####:  425:    return put_comp;
        -:  426:  }
        -:  427:#else /* !JERRY_ESNEXT */
        -:  428:  JERRY_ASSERT (ecma_is_value_true (put_comp));
        -:  429:#endif /* JERRY_ESNEXT */
        -:  430:
    #####:  431:  return ECMA_VALUE_EMPTY;
        -:  432:} /* ecma_builtin_helper_array_concat_value */
        -:  433:
        -:  434:/**
        -:  435: * Helper function to normalizing a string index
        -:  436: *
        -:  437: * This function clamps the given index to the [0, length] range.
        -:  438: * If the index is negative, 0 value is used.
        -:  439: * If the index is greater than the length of the string, the normalized index will be the length of the string.
        -:  440: * NaN is mapped to zero or length depending on the nan_to_zero parameter.
        -:  441: *
        -:  442: * See also:
        -:  443: *          ECMA-262 v5, 15.5.4.15
        -:  444: *
        -:  445: * Used by:
        -:  446: *         - The String.prototype.substring routine.
        -:  447: *         - The ecma_builtin_helper_string_prototype_object_index_of helper routine.
        -:  448: *
        -:  449: * @return lit_utf8_size_t - the normalized value of the index
        -:  450: */
        -:  451:lit_utf8_size_t
    #####:  452:ecma_builtin_helper_string_index_normalize (ecma_number_t index, /**< index */
        -:  453:                                            lit_utf8_size_t length, /**< string's length */
        -:  454:                                            bool nan_to_zero) /**< whether NaN is mapped to zero (t) or length (f) */
        -:  455:{
    #####:  456:  uint32_t norm_index = 0;
        -:  457:
    #####:  458:  if (ecma_number_is_nan (index))
        -:  459:  {
    #####:  460:    if (!nan_to_zero)
        -:  461:    {
    #####:  462:      norm_index = length;
        -:  463:    }
        -:  464:  }
    #####:  465:  else if (!ecma_number_is_negative (index))
        -:  466:  {
    #####:  467:    if (ecma_number_is_infinity (index))
        -:  468:    {
    #####:  469:      norm_index = length;
        -:  470:    }
        -:  471:    else
        -:  472:    {
    #####:  473:      norm_index = ecma_number_to_uint32 (index);
        -:  474:
    #####:  475:      if (norm_index > length)
        -:  476:      {
    #####:  477:        norm_index = length;
        -:  478:      }
        -:  479:    }
        -:  480:  }
        -:  481:
    #####:  482:  return norm_index;
        -:  483:} /* ecma_builtin_helper_string_index_normalize */
        -:  484:
        -:  485:/**
        -:  486: * Helper function for finding lastindex of a search string
        -:  487: *
        -:  488: * This function clamps the given index to the [0, length] range.
        -:  489: * If the index is negative, 0 value is used.
        -:  490: * If the index is greater than the length of the string, the normalized index will be the length of the string.
        -:  491: *
        -:  492: * See also:
        -:  493: *          ECMA-262 v6, 21.1.3.9
        -:  494: *
        -:  495: * Used by:
        -:  496: *         - The ecma_builtin_helper_string_prototype_object_index_of helper routine.
        -:  497: *         - The ecma_builtin_string_prototype_object_replace_match helper routine.
        -:  498: *
        -:  499: * @return uint32_t - whether there is a match for the search string
        -:  500: */
        -:  501:static uint32_t
    #####:  502:ecma_builtin_helper_string_find_last_index (ecma_string_t *original_str_p, /**< original string */
        -:  503:                                            ecma_string_t *search_str_p, /**< search string */
        -:  504:                                            uint32_t position) /**< start_position */
        -:  505:{
    #####:  506:  if (ecma_string_is_empty (search_str_p))
        -:  507:  {
    #####:  508:    return position;
        -:  509:  }
        -:  510:
    #####:  511:  uint32_t original_length = ecma_string_get_length (original_str_p);
        -:  512:
    #####:  513:  ECMA_STRING_TO_UTF8_STRING (search_str_p, search_str_utf8_p, search_str_size);
    #####:  514:  ECMA_STRING_TO_UTF8_STRING (original_str_p, original_str_utf8_p, original_str_size);
        -:  515:
    #####:  516:  uint32_t ret_value = UINT32_MAX;
        -:  517:
    #####:  518:  if (original_str_size >= search_str_size)
        -:  519:  {
    #####:  520:    const lit_utf8_byte_t *end_p = original_str_utf8_p + original_str_size;
    #####:  521:    const lit_utf8_byte_t *current_p = end_p;
        -:  522:
    #####:  523:    for (ecma_number_t i = original_length; i > position; i--)
        -:  524:    {
    #####:  525:      lit_utf8_decr (&current_p);
        -:  526:    }
        -:  527:
    #####:  528:    while (current_p + search_str_size > end_p)
        -:  529:    {
    #####:  530:      lit_utf8_decr (&current_p);
    #####:  531:      position--;
        -:  532:    }
        -:  533:
        -:  534:    while (true)
        -:  535:    {
    #####:  536:      if (memcmp (current_p, search_str_utf8_p, search_str_size) == 0)
        -:  537:      {
    #####:  538:        ret_value = position;
    #####:  539:        break;
        -:  540:      }
        -:  541:
    #####:  542:      if (position == 0)
        -:  543:      {
    #####:  544:        break;
        -:  545:      }
        -:  546:
    #####:  547:      lit_utf8_decr (&current_p);
    #####:  548:      position--;
        -:  549:    }
        -:  550:  }
    #####:  551:  ECMA_FINALIZE_UTF8_STRING (original_str_utf8_p, original_str_size);
    #####:  552:  ECMA_FINALIZE_UTF8_STRING (search_str_utf8_p, search_str_size);
        -:  553:
    #####:  554:  return ret_value;
        -:  555:} /* ecma_builtin_helper_string_find_last_index */
        -:  556:
        -:  557:/**
        -:  558: * Helper function for string indexOf, lastIndexOf, startsWith, includes, endsWith functions
        -:  559: *
        -:  560: * See also:
        -:  561: *          ECMA-262 v5, 15.5.4.7
        -:  562: *          ECMA-262 v5, 15.5.4.8
        -:  563: *          ECMA-262 v6, 21.1.3.6
        -:  564: *          ECMA-262 v6, 21.1.3.7
        -:  565: *          ECMA-262 v6, 21.1.3.18
        -:  566: *
        -:  567: * Used by:
        -:  568: *         - The String.prototype.indexOf routine.
        -:  569: *         - The String.prototype.lastIndexOf routine.
        -:  570: *         - The String.prototype.startsWith routine.
        -:  571: *         - The String.prototype.includes routine.
        -:  572: *         - The String.prototype.endsWith routine.
        -:  573: *
        -:  574: * @return ecma_value_t - Returns index (last index) or a
        -:  575: *                        boolean value
        -:  576: */
        -:  577:ecma_value_t
    #####:  578:ecma_builtin_helper_string_prototype_object_index_of (ecma_string_t *original_str_p, /**< this argument */
        -:  579:                                                      ecma_value_t arg1, /**< routine's first argument */
        -:  580:                                                      ecma_value_t arg2, /**< routine's second argument */
        -:  581:                                                      ecma_string_index_of_mode_t mode) /**< routine's mode */
        -:  582:{
        -:  583:  /* 5 (indexOf) -- 6 (lastIndexOf) */
    #####:  584:  const lit_utf8_size_t original_len = ecma_string_get_length (original_str_p);
        -:  585:
        -:  586:#if JERRY_ESNEXT
        -:  587:  /* 4, 6 (startsWith, includes, endsWith) */
    #####:  588:  if (mode >= ECMA_STRING_STARTS_WITH)
        -:  589:  {
    #####:  590:    ecma_value_t regexp = ecma_op_is_regexp (arg1);
        -:  591:
    #####:  592:    if (ECMA_IS_VALUE_ERROR (regexp))
        -:  593:    {
    #####:  594:      return regexp;
        -:  595:    }
        -:  596:
    #####:  597:    if (regexp == ECMA_VALUE_TRUE)
        -:  598:    {
    #####:  599:      JERRY_ASSERT (ECMA_STRING_LAST_INDEX_OF < mode && mode <= ECMA_STRING_ENDS_WITH);
    #####:  600:      return ecma_raise_type_error (ECMA_ERR_MSG ("Search string can't be of type: RegExp"));
        -:  601:    }
        -:  602:  }
        -:  603:#endif /* JERRY_ESNEXT */
        -:  604:
        -:  605:  /* 7, 8 */
    #####:  606:  ecma_string_t *search_str_p = ecma_op_to_string (arg1);
        -:  607:
    #####:  608:  if (JERRY_UNLIKELY (search_str_p == NULL))
        -:  609:  {
    #####:  610:    return ECMA_VALUE_ERROR;
        -:  611:  }
        -:  612:
        -:  613:  ecma_value_t ret_value;
        -:  614:
        -:  615:  /* 4 (indexOf, lastIndexOf), 9 (startsWith, includes), 10 (endsWith) */
    #####:  616:  ecma_number_t pos_num;
        -:  617:#if JERRY_ESNEXT
    #####:  618:  if (mode > ECMA_STRING_LAST_INDEX_OF)
        -:  619:  {
    #####:  620:    ret_value = ecma_op_to_integer (arg2, &pos_num);
        -:  621:  }
        -:  622:  else
        -:  623:  {
        -:  624:#endif /* JERRY_ESNEXT */
    #####:  625:    ret_value = ecma_op_to_number (arg2, &pos_num);
        -:  626:#if JERRY_ESNEXT
        -:  627:  }
        -:  628:#endif /* JERRY_ESNEXT */
        -:  629:
        -:  630:  /* 10 (startsWith, includes), 11 (endsWith) */
    #####:  631:  if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  632:  {
    #####:  633:    ecma_deref_ecma_string (search_str_p);
    #####:  634:    return ret_value;
        -:  635:  }
        -:  636:
    #####:  637:  bool use_first_index = mode != ECMA_STRING_LAST_INDEX_OF;
        -:  638:
        -:  639:  /* 4b, 6 (indexOf) - 4b, 5, 7 (lastIndexOf) */
    #####:  640:  lit_utf8_size_t start = ecma_builtin_helper_string_index_normalize (pos_num, original_len, use_first_index);
        -:  641:
    #####:  642:  ecma_number_t ret_num = ECMA_NUMBER_MINUS_ONE;
        -:  643:
    #####:  644:  ret_value = ECMA_VALUE_FALSE;
        -:  645:
    #####:  646:  switch (mode)
        -:  647:  {
        -:  648:#if JERRY_ESNEXT
    #####:  649:    case ECMA_STRING_STARTS_WITH:
        -:  650:    {
    #####:  651:      if (start > original_len)
        -:  652:      {
    #####:  653:        break;
        -:  654:      }
        -:  655:      /* 15, 16 (startsWith) */
    #####:  656:      uint32_t index = ecma_builtin_helper_string_find_index (original_str_p, search_str_p, start);
    #####:  657:      ret_value = ecma_make_boolean_value (index == start);
    #####:  658:      break;
        -:  659:    }
    #####:  660:    case ECMA_STRING_INCLUDES:
        -:  661:    {
    #####:  662:      if (ecma_builtin_helper_string_find_index (original_str_p, search_str_p, start) != UINT32_MAX)
        -:  663:      {
    #####:  664:        ret_value = ECMA_VALUE_TRUE;
        -:  665:      }
    #####:  666:      break;
        -:  667:    }
    #####:  668:    case ECMA_STRING_ENDS_WITH:
        -:  669:    {
    #####:  670:      if (start == 0)
        -:  671:      {
    #####:  672:        start = original_len;
        -:  673:      }
        -:  674:
    #####:  675:      lit_utf8_size_t search_str_len = ecma_string_get_length (search_str_p);
        -:  676:
    #####:  677:      if (search_str_len == 0)
        -:  678:      {
    #####:  679:        ret_value = ECMA_VALUE_TRUE;
    #####:  680:        break;
        -:  681:      }
        -:  682:
    #####:  683:      int32_t start_ends_with = (int32_t) (start - search_str_len);
        -:  684:
    #####:  685:      if (start_ends_with < 0)
        -:  686:      {
    #####:  687:        break;
        -:  688:      }
    #####:  689:      uint32_t index = ecma_builtin_helper_string_find_index (original_str_p,
        -:  690:                                                              search_str_p,
        -:  691:                                                              (uint32_t) start_ends_with);
    #####:  692:      ret_value = ecma_make_boolean_value (index  == (uint32_t) start_ends_with);
    #####:  693:      break;
        -:  694:    }
        -:  695:#endif /* JERRY_ESNEXT */
        -:  696:
    #####:  697:    case ECMA_STRING_INDEX_OF:
        -:  698:    {
        -:  699:      /* 8 (indexOf) -- 9 (lastIndexOf) */
    #####:  700:      ecma_value_t find_index = ecma_builtin_helper_string_find_index (original_str_p, search_str_p, start);
        -:  701:
    #####:  702:      if (find_index != UINT32_MAX)
        -:  703:      {
    #####:  704:        ret_num = ((ecma_number_t) find_index);
        -:  705:      }
    #####:  706:      ret_value = ecma_make_number_value (ret_num);
    #####:  707:      break;
        -:  708:    }
        -:  709:
    #####:  710:    case ECMA_STRING_LAST_INDEX_OF:
        -:  711:    {
    #####:  712:      uint32_t index = ecma_builtin_helper_string_find_last_index (original_str_p, search_str_p, start);
        -:  713:
    #####:  714:      if (index != UINT32_MAX)
        -:  715:      {
    #####:  716:        ret_num = ((ecma_number_t) index);
        -:  717:      }
    #####:  718:      ret_value = ecma_make_number_value (ret_num);
    #####:  719:      break;
        -:  720:    }
        -:  721:
    #####:  722:    default:
        -:  723:    {
    #####:  724:      JERRY_UNREACHABLE ();
        -:  725:    }
        -:  726:  }
        -:  727:
    #####:  728:  ecma_deref_ecma_string (search_str_p);
        -:  729:
    #####:  730:  return ret_value;
        -:  731:} /* ecma_builtin_helper_string_prototype_object_index_of */
        -:  732:
        -:  733:/**
        -:  734: * Helper function for finding index of a search string
        -:  735: *
        -:  736: * This function clamps the given index to the [0, length] range.
        -:  737: * If the index is negative, 0 value is used.
        -:  738: * If the index is greater than the length of the string, the normalized index will be the length of the string.
        -:  739: *
        -:  740: * See also:
        -:  741: *          ECMA-262 v6, 21.1.3.8
        -:  742: *
        -:  743: * Used by:
        -:  744: *         - The ecma_builtin_helper_string_prototype_object_index_of helper routine.
        -:  745: *         - The ecma_builtin_string_prototype_object_replace_match helper routine.
        -:  746: *
        -:  747: * @return uint32_t - whether there is a match for the search string
        -:  748: */
        -:  749:uint32_t
    #####:  750:ecma_builtin_helper_string_find_index (ecma_string_t *original_str_p, /**< index */
        -:  751:                                       ecma_string_t *search_str_p, /**< string's length */
        -:  752:                                       uint32_t start_pos) /**< start position */
        -:  753:{
    #####:  754:  uint32_t match_found = UINT32_MAX;
        -:  755:
    #####:  756:  if (ecma_string_is_empty (search_str_p))
        -:  757:  {
    #####:  758:    return start_pos;
        -:  759:  }
        -:  760:
    #####:  761:  ECMA_STRING_TO_UTF8_STRING (search_str_p, search_str_utf8_p, search_str_size);
    #####:  762:  ECMA_STRING_TO_UTF8_STRING (original_str_p, original_str_utf8_p, original_str_size);
        -:  763:
    #####:  764:  const lit_utf8_byte_t *str_current_p = original_str_utf8_p;
        -:  765:
    #####:  766:  for (ecma_number_t i = 0; i < start_pos; i++)
        -:  767:  {
    #####:  768:    lit_utf8_incr (&str_current_p);
        -:  769:  }
        -:  770:
    #####:  771:  const lit_utf8_byte_t *original_end_p = original_str_utf8_p + original_str_size;
        -:  772:
    #####:  773:  while (!((size_t) (original_end_p - str_current_p) < search_str_size))
        -:  774:  {
    #####:  775:    if (memcmp (str_current_p , search_str_utf8_p, search_str_size) == 0)
        -:  776:    {
    #####:  777:      match_found = start_pos;
    #####:  778:      break;
        -:  779:    }
        -:  780:
    #####:  781:    lit_utf8_incr (&str_current_p);
    #####:  782:    start_pos++;
        -:  783:  }
        -:  784:
    #####:  785:  ECMA_FINALIZE_UTF8_STRING (original_str_utf8_p, original_str_size);
    #####:  786:  ECMA_FINALIZE_UTF8_STRING (search_str_utf8_p, search_str_size);
        -:  787:
    #####:  788:  return match_found;
        -:  789:} /* ecma_builtin_helper_string_find_index */
        -:  790:
        -:  791:/**
        -:  792: * Helper function for using [[DefineOwnProperty]] specialized for indexed property names
        -:  793: *
        -:  794: * Note: this method falls back to the general ecma_builtin_helper_def_prop
        -:  795: *
        -:  796: * @return ecma value
        -:  797: *         Returned value must be freed with ecma_free_value.
        -:  798: */
        -:  799:ecma_value_t
        2:  800:ecma_builtin_helper_def_prop_by_index (ecma_object_t *obj_p, /**< object */
        -:  801:                                       ecma_length_t index, /**< property index */
        -:  802:                                       ecma_value_t value, /**< value */
        -:  803:                                       uint32_t opts) /**< any combination of ecma_property_flag_t bits */
        -:  804:{
        2:  805:  if (JERRY_LIKELY (index <= ECMA_DIRECT_STRING_MAX_IMM))
        -:  806:  {
        2:  807:    return ecma_builtin_helper_def_prop (obj_p,
        2:  808:                                         ECMA_CREATE_DIRECT_UINT32_STRING (index),
        -:  809:                                         value,
        -:  810:                                         opts);
        -:  811:  }
        -:  812:
    #####:  813:  ecma_string_t *index_str_p = ecma_new_ecma_string_from_length (index);
    #####:  814:  ecma_value_t ret_value = ecma_builtin_helper_def_prop (obj_p, index_str_p, value, opts);
    #####:  815:  ecma_deref_ecma_string (index_str_p);
        -:  816:
    #####:  817:  return ret_value;
        -:  818:} /* ecma_builtin_helper_def_prop_by_index */
        -:  819:
        -:  820:/**
        -:  821: * Helper function for at() functions.
        -:  822: *
        -:  823: * See also:
        -:  824: *          ECMA-262 Stage 3 Draft Relative Indexing Method proposal 3. 4. 5. 6.
        -:  825: *
        -:  826: * Used by:
        -:  827: *         - The Array.prototype.at routine.
        -:  828: *         - The String.prototype.at routine.
        -:  829: *         - The TypedArray.prototype.at routine.
        -:  830: *
        -:  831: * @return ECMA_VALUE_ERROR - on conversion error
        -:  832: *         ECMA_VALUE_UNDEFINED - if the requested index is not exist
        -:  833: *         ECMA_VALUE_EMPTY - otherwise
        -:  834: */
        -:  835:ecma_value_t
    #####:  836:ecma_builtin_helper_calculate_index (ecma_value_t index, /**< relative index argument */
        -:  837:                                     ecma_length_t length, /**< object's length */
        -:  838:                                     ecma_length_t *out_index) /**< calculated index */
        -:  839:{
    #####:  840:  JERRY_ASSERT (out_index != NULL);
        -:  841:
    #####:  842:  ecma_number_t relative_index;
    #####:  843:  ecma_value_t conversion_result = ecma_op_to_integer (index, &relative_index);
        -:  844:
        -:  845:   /* 4. */
    #####:  846:  if (ECMA_IS_VALUE_ERROR (conversion_result))
        -:  847:  {
    #####:  848:    return ECMA_VALUE_ERROR;
        -:  849:  }
        -:  850:
        -:  851:  /* 5. 6. */
        -:  852:  ecma_number_t k;
        -:  853:
    #####:  854:  if (relative_index >= 0)
        -:  855:  {
    #####:  856:    k = relative_index;
        -:  857:  }
        -:  858:  else
        -:  859:  {
    #####:  860:    k = ((ecma_number_t) length + relative_index);
        -:  861:  }
        -:  862:
        -:  863:  /* 7. */
    #####:  864:  if (k < 0 || k >= ((ecma_number_t) length))
        -:  865:  {
    #####:  866:    return ECMA_VALUE_UNDEFINED;
        -:  867:  }
        -:  868:
    #####:  869:  *out_index = (ecma_length_t) k;
        -:  870:
    #####:  871:  return ECMA_VALUE_EMPTY;
        -:  872:} /* ecma_builtin_helper_calculate_index */
        -:  873:
        -:  874:/**
        -:  875: * Helper function for using [[DefineOwnProperty]].
        -:  876: *
        -:  877: * See also:
        -:  878: *          ECMA-262 v5, 8.12.9
        -:  879: *          ECMA-262 v5, 15.4.5.1
        -:  880: *
        -:  881: * @return ecma value
        -:  882: *         Returned value must be freed with ecma_free_value.
        -:  883: */
        -:  884:ecma_value_t
        4:  885:ecma_builtin_helper_def_prop (ecma_object_t *obj_p, /**< object */
        -:  886:                              ecma_string_t *name_p, /**< name string */
        -:  887:                              ecma_value_t value, /**< value */
        -:  888:                              uint32_t opts) /**< any combination of ecma_property_descriptor_status_flags_t bits */
        -:  889:{
        4:  890:  ecma_property_descriptor_t prop_desc;
        -:  891:
        4:  892:  prop_desc.flags = (uint16_t) (ECMA_NAME_DATA_PROPERTY_DESCRIPTOR_BITS | opts);
        -:  893:
        4:  894:  prop_desc.value = value;
        -:  895:
        4:  896:  return ecma_op_object_define_own_property (obj_p,
        -:  897:                                             name_p,
        -:  898:                                             &prop_desc);
        -:  899:} /* ecma_builtin_helper_def_prop */
        -:  900:
        -:  901:/**
        -:  902: * GetSubstitution abstract operation
        -:  903: *
        -:  904: * See:
        -:  905: *     ECMA-262 v6.0 21.1.3.14.1
        -:  906: */
        -:  907:void
    #####:  908:ecma_builtin_replace_substitute (ecma_replace_context_t *ctx_p) /**< replace context */
        -:  909:{
    #####:  910:  JERRY_ASSERT (ctx_p->string_p != NULL);
    #####:  911:  JERRY_ASSERT (ctx_p->matched_p == NULL
        -:  912:                || (ctx_p->matched_p >= ctx_p->string_p
        -:  913:                    && ctx_p->matched_p <= ctx_p->string_p + ctx_p->string_size));
        -:  914:
    #####:  915:  lit_utf8_size_t replace_size;
    #####:  916:  uint8_t replace_flags = ECMA_STRING_FLAG_IS_ASCII;
    #####:  917:  const lit_utf8_byte_t *replace_buf_p = ecma_string_get_chars (ctx_p->replace_str_p,
        -:  918:                                                                &replace_size,
        -:  919:                                                                NULL,
        -:  920:                                                                NULL,
        -:  921:                                                                &replace_flags);
        -:  922:
    #####:  923:  const lit_utf8_byte_t *const replace_end_p = replace_buf_p + replace_size;
    #####:  924:  const lit_utf8_byte_t *curr_p = replace_buf_p;
    #####:  925:  const lit_utf8_byte_t *last_inserted_end_p = replace_buf_p;
        -:  926:
    #####:  927:  while (curr_p < replace_end_p)
        -:  928:  {
    #####:  929:    if (*curr_p++ == LIT_CHAR_DOLLAR_SIGN)
        -:  930:    {
    #####:  931:      ecma_stringbuilder_append_raw (&(ctx_p->builder),
        -:  932:                                     last_inserted_end_p,
    #####:  933:                                     (lit_utf8_size_t) (curr_p - last_inserted_end_p - 1));
    #####:  934:      if (curr_p >= replace_end_p)
        -:  935:      {
    #####:  936:        last_inserted_end_p = curr_p - 1;
    #####:  937:        break;
        -:  938:      }
        -:  939:
    #####:  940:      const lit_utf8_byte_t c = *curr_p++;
        -:  941:
    #####:  942:      switch (c)
        -:  943:      {
    #####:  944:        case LIT_CHAR_DOLLAR_SIGN:
        -:  945:        {
    #####:  946:          ecma_stringbuilder_append_byte (&(ctx_p->builder), LIT_CHAR_DOLLAR_SIGN);
    #####:  947:          break;
        -:  948:        }
    #####:  949:        case LIT_CHAR_AMPERSAND:
        -:  950:        {
        -:  951:#if JERRY_ESNEXT
    #####:  952:          if (JERRY_UNLIKELY (ctx_p->matched_p == NULL))
        -:  953:          {
    #####:  954:            JERRY_ASSERT (ctx_p->capture_count == 0);
    #####:  955:            JERRY_ASSERT (ctx_p->u.collection_p != NULL);
    #####:  956:            JERRY_ASSERT (ctx_p->u.collection_p->item_count > 0);
    #####:  957:            const ecma_value_t match_value = ctx_p->u.collection_p->buffer_p[0];
        -:  958:
    #####:  959:            JERRY_ASSERT (ecma_is_value_string (match_value));
    #####:  960:            ecma_stringbuilder_append (&(ctx_p->builder), ecma_get_string_from_value (match_value));
    #####:  961:            break;
        -:  962:          }
        -:  963:#endif /* JERRY_ESNEXT */
        -:  964:
    #####:  965:          JERRY_ASSERT (ctx_p->matched_p != NULL);
    #####:  966:          ecma_stringbuilder_append_raw (&(ctx_p->builder), ctx_p->matched_p, ctx_p->matched_size);
    #####:  967:          break;
        -:  968:        }
    #####:  969:        case LIT_CHAR_GRAVE_ACCENT:
        -:  970:        {
    #####:  971:          ecma_stringbuilder_append_raw (&(ctx_p->builder), ctx_p->string_p, ctx_p->match_byte_pos);
    #####:  972:          break;
        -:  973:        }
    #####:  974:        case LIT_CHAR_SINGLE_QUOTE:
        -:  975:        {
        -:  976:#if JERRY_ESNEXT
    #####:  977:          if (JERRY_UNLIKELY (ctx_p->matched_p == NULL))
        -:  978:          {
    #####:  979:            JERRY_ASSERT (ctx_p->capture_count == 0);
    #####:  980:            JERRY_ASSERT (ctx_p->u.collection_p != NULL);
    #####:  981:            JERRY_ASSERT (ctx_p->u.collection_p->item_count > 0);
    #####:  982:            const ecma_value_t match_value = ctx_p->u.collection_p->buffer_p[0];
        -:  983:
    #####:  984:            JERRY_ASSERT (ecma_is_value_string (match_value));
    #####:  985:            const ecma_string_t *const matched_p = ecma_get_string_from_value (match_value);
    #####:  986:            const lit_utf8_size_t match_size = ecma_string_get_size (matched_p);
    #####:  987:            const lit_utf8_byte_t *const begin_p = ctx_p->string_p + ctx_p->match_byte_pos + match_size;
        -:  988:
    #####:  989:            ecma_stringbuilder_append_raw (&(ctx_p->builder),
        -:  990:                                           begin_p,
    #####:  991:                                           (lit_utf8_size_t) (ctx_p->string_p + ctx_p->string_size - begin_p));
    #####:  992:            break;
        -:  993:          }
        -:  994:#endif /* JERRY_ESNEXT */
        -:  995:
    #####:  996:          JERRY_ASSERT (ctx_p->matched_p != NULL);
    #####:  997:          ecma_stringbuilder_append_raw (&(ctx_p->builder),
    #####:  998:                                         ctx_p->matched_p + ctx_p->matched_size,
    #####:  999:                                         ctx_p->string_size - ctx_p->match_byte_pos - ctx_p->matched_size);
    #####: 1000:          break;
        -: 1001:        }
    #####: 1002:        default:
        -: 1003:        {
    #####: 1004:          const lit_utf8_byte_t *const number_begin_p = curr_p - 1;
        -: 1005:
    #####: 1006:          if (lit_char_is_decimal_digit (c))
        -: 1007:          {
    #####: 1008:            uint32_t capture_count = ctx_p->capture_count;
        -: 1009:#if JERRY_ESNEXT
    #####: 1010:            if (capture_count == 0 && ctx_p->u.collection_p != NULL)
        -: 1011:            {
    #####: 1012:              capture_count = ctx_p->u.collection_p->item_count;
        -: 1013:            }
        -: 1014:#endif /* JERRY_ESNEXT */
        -: 1015:
    #####: 1016:            uint8_t idx = (uint8_t) (c - LIT_CHAR_0);
    #####: 1017:            if (curr_p < replace_end_p && lit_char_is_decimal_digit (*(curr_p)))
        -: 1018:            {
    #####: 1019:              uint8_t two_digit_index = (uint8_t) (idx * 10 + (uint8_t) (*(curr_p) - LIT_CHAR_0));
    #####: 1020:              if (two_digit_index < capture_count)
        -: 1021:              {
    #####: 1022:                idx = two_digit_index;
    #####: 1023:                curr_p++;
        -: 1024:              }
        -: 1025:            }
        -: 1026:
    #####: 1027:            if (idx > 0 && idx < capture_count)
        -: 1028:            {
    #####: 1029:              if (ctx_p->capture_count > 0)
        -: 1030:              {
        -: 1031:#if JERRY_BUILTIN_REGEXP
    #####: 1032:                JERRY_ASSERT (ctx_p->u.captures_p != NULL);
    #####: 1033:                const ecma_regexp_capture_t *const capture_p = ctx_p->u.captures_p + idx;
        -: 1034:
    #####: 1035:                if (ECMA_RE_IS_CAPTURE_DEFINED (capture_p))
        -: 1036:                {
    #####: 1037:                  ecma_stringbuilder_append_raw (&(ctx_p->builder),
        -: 1038:                                                 capture_p->begin_p,
    #####: 1039:                                                 (lit_utf8_size_t) (capture_p->end_p - capture_p->begin_p));
        -: 1040:                }
        -: 1041:
    #####: 1042:                break;
        -: 1043:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1044:              }
        -: 1045:#if JERRY_ESNEXT
    #####: 1046:              else if (ctx_p->u.collection_p != NULL)
        -: 1047:              {
    #####: 1048:                const ecma_value_t capture_value = ctx_p->u.collection_p->buffer_p[idx];
    #####: 1049:                if (!ecma_is_value_undefined (capture_value))
        -: 1050:                {
    #####: 1051:                  ecma_stringbuilder_append (&(ctx_p->builder), ecma_get_string_from_value (capture_value));
        -: 1052:                }
        -: 1053:
    #####: 1054:                break;
        -: 1055:              }
        -: 1056:#endif /* JERRY_ESNEXT */
        -: 1057:            }
        -: 1058:          }
        -: 1059:
    #####: 1060:          ecma_stringbuilder_append_byte (&(ctx_p->builder), LIT_CHAR_DOLLAR_SIGN);
    #####: 1061:          curr_p = number_begin_p;
    #####: 1062:          break;
        -: 1063:        }
        -: 1064:      }
        -: 1065:
    #####: 1066:      last_inserted_end_p = curr_p;
        -: 1067:    }
        -: 1068:  }
        -: 1069:
    #####: 1070:  ecma_stringbuilder_append_raw (&(ctx_p->builder),
        -: 1071:                                 last_inserted_end_p,
    #####: 1072:                                 (lit_utf8_size_t) (replace_end_p - last_inserted_end_p));
        -: 1073:
    #####: 1074:  if (replace_flags & ECMA_STRING_FLAG_MUST_BE_FREED)
        -: 1075:  {
    #####: 1076:    jmem_heap_free_block ((void *) replace_buf_p, replace_size);
        -: 1077:  }
    #####: 1078:} /* ecma_builtin_replace_substitute */
        -: 1079:
        -: 1080:/**
        -: 1081: * @}
        -: 1082: * @}
        -: 1083: */
