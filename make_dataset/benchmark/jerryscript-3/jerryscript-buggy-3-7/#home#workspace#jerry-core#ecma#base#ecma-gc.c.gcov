        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-gc.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:/**
        -:   17: * Garbage collector implementation
        -:   18: */
        -:   19:
        -:   20:#include "ecma-alloc.h"
        -:   21:#include "ecma-array-object.h"
        -:   22:#include "ecma-builtin-handlers.h"
        -:   23:#include "ecma-container-object.h"
        -:   24:#include "ecma-function-object.h"
        -:   25:#include "ecma-globals.h"
        -:   26:#include "ecma-gc.h"
        -:   27:#include "ecma-helpers.h"
        -:   28:#include "ecma-lcache.h"
        -:   29:#include "ecma-objects.h"
        -:   30:#include "ecma-property-hashmap.h"
        -:   31:#include "ecma-proxy-object.h"
        -:   32:#include "jcontext.h"
        -:   33:#include "jrt.h"
        -:   34:#include "jrt-libc-includes.h"
        -:   35:#include "jrt-bit-fields.h"
        -:   36:#include "re-compiler.h"
        -:   37:#include "vm-defines.h"
        -:   38:#include "vm-stack.h"
        -:   39:
        -:   40:#if JERRY_BUILTIN_TYPEDARRAY
        -:   41:#include "ecma-typedarray-object.h"
        -:   42:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:   43:#if JERRY_ESNEXT
        -:   44:#include "ecma-promise-object.h"
        -:   45:#endif /* JERRY_ESNEXT */
        -:   46:
        -:   47:/* TODO: Extract GC to a separate component */
        -:   48:
        -:   49:/** \addtogroup ecma ECMA
        -:   50: * @{
        -:   51: *
        -:   52: * \addtogroup ecmagc Garbage collector
        -:   53: * @{
        -:   54: */
        -:   55:
        -:   56:/*
        -:   57: * The garbage collector uses the reference counter
        -:   58: * of object: it increases the counter by one when
        -:   59: * the object is marked at the first time.
        -:   60: */
        -:   61:
        -:   62:/**
        -:   63: * Get visited flag of the object.
        -:   64: *
        -:   65: * @return true  - if visited
        -:   66: *         false - otherwise
        -:   67: */
        -:   68:static inline bool JERRY_ATTR_ALWAYS_INLINE
        -:   69:ecma_gc_is_object_visited (ecma_object_t *object_p) /**< object */
        -:   70:{
       75:   71:  JERRY_ASSERT (object_p != NULL);
        -:   72:
       75:   73:  return (object_p->type_flags_refs < ECMA_OBJECT_NON_VISITED);
        -:   74:} /* ecma_gc_is_object_visited */
        -:   75:
        -:   76:/**
        -:   77: * Mark objects as visited starting from specified object as root
        -:   78: */
        -:   79:static void ecma_gc_mark (ecma_object_t *object_p);
        -:   80:
        -:   81:/**
        -:   82: * Set visited flag of the object.
        -:   83: */
        -:   84:static void
    #####:   85:ecma_gc_set_object_visited (ecma_object_t *object_p) /**< object */
        -:   86:{
    #####:   87:  if (object_p->type_flags_refs >= ECMA_OBJECT_NON_VISITED)
        -:   88:  {
        -:   89:#if (JERRY_GC_MARK_LIMIT != 0)
    #####:   90:    if (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) != 0)
        -:   91:    {
    #####:   92:      JERRY_CONTEXT (ecma_gc_mark_recursion_limit)--;
        -:   93:      /* Set the reference count of gray object to 0 */
    #####:   94:      object_p->type_flags_refs &= (ecma_object_descriptor_t) (ECMA_OBJECT_REF_ONE - 1);
    #####:   95:      ecma_gc_mark (object_p);
    #####:   96:      JERRY_CONTEXT (ecma_gc_mark_recursion_limit)++;
        -:   97:    }
        -:   98:    else
        -:   99:    {
        -:  100:      /* Set the reference count of the non-marked gray object to 1 */
    #####:  101:      object_p->type_flags_refs &= (ecma_object_descriptor_t) ((ECMA_OBJECT_REF_ONE << 1) - 1);
    #####:  102:      JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);
        -:  103:    }
        -:  104:#else /* (JERRY_GC_MARK_LIMIT == 0) */
        -:  105:    /* Set the reference count of gray object to 0 */
        -:  106:    object_p->type_flags_refs &= (ecma_object_descriptor_t) (ECMA_OBJECT_REF_ONE - 1);
        -:  107:#endif /* (JERRY_GC_MARK_LIMIT != 0) */
        -:  108:  }
    #####:  109:} /* ecma_gc_set_object_visited */
        -:  110:
        -:  111:/**
        -:  112: * Initialize GC information for the object
        -:  113: */
        -:  114:extern inline void
       25:  115:ecma_init_gc_info (ecma_object_t *object_p) /**< object */
        -:  116:{
       25:  117:  JERRY_CONTEXT (ecma_gc_objects_number)++;
       25:  118:  JERRY_CONTEXT (ecma_gc_new_objects)++;
        -:  119:
       25:  120:  JERRY_ASSERT (object_p->type_flags_refs < ECMA_OBJECT_REF_ONE);
       25:  121:  object_p->type_flags_refs |= ECMA_OBJECT_REF_ONE;
        -:  122:
       25:  123:  object_p->gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
       25:  124:  ECMA_SET_NON_NULL_POINTER (JERRY_CONTEXT (ecma_gc_objects_cp), object_p);
       25:  125:} /* ecma_init_gc_info */
        -:  126:
        -:  127:/**
        -:  128: * Increase reference counter of an object
        -:  129: */
        -:  130:extern inline void JERRY_ATTR_ALWAYS_INLINE
        9:  131:ecma_ref_object_inline (ecma_object_t *object_p) /**< object */
        -:  132:{
       19:  133:  if (JERRY_LIKELY (object_p->type_flags_refs < ECMA_OBJECT_MAX_REF))
        -:  134:  {
       19:  135:    object_p->type_flags_refs = (ecma_object_descriptor_t) (object_p->type_flags_refs + ECMA_OBJECT_REF_ONE);
        -:  136:  }
        -:  137:  else
        -:  138:  {
    #####:  139:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -:  140:  }
        9:  141:} /* ecma_ref_object_inline */
        -:  142:
        -:  143:/**
        -:  144: * Increase reference counter of an object
        -:  145: */
        -:  146:void
       10:  147:ecma_ref_object (ecma_object_t *object_p) /**< object */
        -:  148:{
    #####:  149:  ecma_ref_object_inline (object_p);
       10:  150:} /* ecma_ref_object */
        -:  151:
        -:  152:/**
        -:  153: * Decrease reference counter of an object
        -:  154: */
        -:  155:extern inline void JERRY_ATTR_ALWAYS_INLINE
       44:  156:ecma_deref_object (ecma_object_t *object_p) /**< object */
        -:  157:{
       44:  158:  JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);
       44:  159:  object_p->type_flags_refs = (ecma_object_descriptor_t) (object_p->type_flags_refs - ECMA_OBJECT_REF_ONE);
       44:  160:} /* ecma_deref_object */
        -:  161:
        -:  162:/**
        -:  163: * Mark objects referenced by global object
        -:  164: */
        -:  165:static void
    #####:  166:ecma_gc_mark_global_object (ecma_global_object_t *global_object_p) /**< global object */
        -:  167:{
    #####:  168:  JERRY_ASSERT (global_object_p->extended_object.u.built_in.routine_id == 0);
        -:  169:
    #####:  170:  ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, global_object_p->global_env_cp));
        -:  171:
        -:  172:#if JERRY_BUILTIN_REALMS
    #####:  173:  ecma_gc_set_object_visited (ecma_get_object_from_value (global_object_p->this_binding));
        -:  174:#endif /* JERRY_BUILTIN_REALMS */
        -:  175:
        -:  176:#if JERRY_ESNEXT
    #####:  177:  if (global_object_p->global_scope_cp != global_object_p->global_env_cp)
        -:  178:  {
    #####:  179:    ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, global_object_p->global_scope_cp));
        -:  180:  }
        -:  181:#endif /* JERRY_ESNEXT */
        -:  182:
    #####:  183:  jmem_cpointer_t *builtin_objects_p = global_object_p->builtin_objects;
        -:  184:
    #####:  185:  for (int i = 0; i < ECMA_BUILTIN_OBJECTS_COUNT; i++)
        -:  186:  {
    #####:  187:    if (builtin_objects_p[i] != JMEM_CP_NULL)
        -:  188:    {
    #####:  189:      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, builtin_objects_p[i]));
        -:  190:    }
        -:  191:  }
    #####:  192:} /* ecma_gc_mark_global_object */
        -:  193:
        -:  194:/**
        -:  195: * Mark objects referenced by arguments object
        -:  196: */
        -:  197:static void
    #####:  198:ecma_gc_mark_arguments_object (ecma_extended_object_t *ext_object_p) /**< arguments object */
        -:  199:{
    #####:  200:  JERRY_ASSERT (ecma_get_object_type ((ecma_object_t *) ext_object_p) == ECMA_OBJECT_TYPE_CLASS);
        -:  201:
    #####:  202:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) ext_object_p;
    #####:  203:  ecma_gc_set_object_visited (ecma_get_object_from_value (arguments_p->callee));
        -:  204:
    #####:  205:  ecma_value_t *argv_p = (ecma_value_t *) (arguments_p + 1);
        -:  206:
    #####:  207:  if (ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -:  208:  {
    #####:  209:    ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;
    #####:  210:    argv_p = (ecma_value_t *) (mapped_arguments_p + 1);
        -:  211:
    #####:  212:    ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, mapped_arguments_p->lex_env));
        -:  213:  }
        -:  214:
    #####:  215:  uint32_t arguments_number = arguments_p->header.u.cls.u3.arguments_number;
        -:  216:
    #####:  217:  for (uint32_t i = 0; i < arguments_number; i++)
        -:  218:  {
    #####:  219:    if (ecma_is_value_object (argv_p[i]))
        -:  220:    {
    #####:  221:      ecma_gc_set_object_visited (ecma_get_object_from_value (argv_p[i]));
        -:  222:    }
        -:  223:  }
    #####:  224:} /* ecma_gc_mark_arguments_object */
        -:  225:
        -:  226:/**
        -:  227: * Mark referenced object from property
        -:  228: */
        -:  229:static void
    #####:  230:ecma_gc_mark_properties (ecma_object_t *object_p, /**< object */
        -:  231:                         bool mark_references) /**< mark references */
        -:  232:{
        -:  233:  JERRY_UNUSED (mark_references);
        -:  234:
        -:  235:#if !JERRY_MODULE_SYSTEM
        -:  236:  JERRY_ASSERT (!mark_references);
        -:  237:#endif /* !JERRY_MODULE_SYSTEM */
        -:  238:
    #####:  239:  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;
        -:  240:
        -:  241:#if JERRY_PROPERTY_HASHMAP
    #####:  242:  if (prop_iter_cp != JMEM_CP_NULL)
        -:  243:  {
    #####:  244:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####:  245:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -:  246:    {
    #####:  247:      prop_iter_cp = prop_iter_p->next_property_cp;
        -:  248:    }
        -:  249:  }
        -:  250:#endif /* JERRY_PROPERTY_HASHMAP */
        -:  251:
    #####:  252:  while (prop_iter_cp != JMEM_CP_NULL)
        -:  253:  {
    #####:  254:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####:  255:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -:  256:
    #####:  257:    ecma_property_pair_t *property_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -:  258:
    #####:  259:    for (uint32_t index = 0; index < ECMA_PROPERTY_PAIR_ITEM_COUNT; index++)
        -:  260:    {
    #####:  261:      uint8_t property = property_pair_p->header.types[index];
        -:  262:
    #####:  263:      if (JERRY_LIKELY (ECMA_PROPERTY_IS_RAW (property)))
        -:  264:      {
    #####:  265:        if (property & ECMA_PROPERTY_FLAG_DATA)
        -:  266:        {
    #####:  267:          ecma_value_t value = property_pair_p->values[index].value;
        -:  268:
    #####:  269:          if (ecma_is_value_object (value))
        -:  270:          {
    #####:  271:            ecma_gc_set_object_visited (ecma_get_object_from_value (value));
        -:  272:          }
    #####:  273:          continue;
        -:  274:        }
        -:  275:
        -:  276:#if JERRY_MODULE_SYSTEM
    #####:  277:        if (mark_references)
        -:  278:        {
    #####:  279:          continue;
        -:  280:        }
        -:  281:#endif /* JERRY_MODULE_SYSTEM */
        -:  282:
    #####:  283:        ecma_property_value_t *accessor_objs_p = property_pair_p->values + index;
        -:  284:
    #####:  285:        ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);
        -:  286:
    #####:  287:        if (get_set_pair_p->getter_cp != JMEM_CP_NULL)
        -:  288:        {
    #####:  289:          ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp));
        -:  290:        }
        -:  291:
    #####:  292:        if (get_set_pair_p->setter_cp != JMEM_CP_NULL)
        -:  293:        {
    #####:  294:          ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp));
        -:  295:        }
        -:  296:
    #####:  297:        continue;
        -:  298:      }
        -:  299:
    #####:  300:      if (!ECMA_PROPERTY_IS_INTERNAL (property))
        -:  301:      {
    #####:  302:        JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_DELETED
        -:  303:                      || property == ECMA_PROPERTY_TYPE_HASHMAP);
    #####:  304:        continue;
        -:  305:      }
        -:  306:
    #####:  307:      JERRY_ASSERT (property_pair_p->names_cp[index] >= LIT_INTERNAL_MAGIC_STRING_FIRST_DATA
        -:  308:                    && property_pair_p->names_cp[index] < LIT_MAGIC_STRING__COUNT);
        -:  309:
    #####:  310:      switch (property_pair_p->names_cp[index])
        -:  311:      {
        -:  312:#if JERRY_ESNEXT
    #####:  313:        case LIT_INTERNAL_MAGIC_STRING_ENVIRONMENT_RECORD:
        -:  314:        {
        -:  315:          ecma_environment_record_t *environment_record_p;
    #####:  316:          environment_record_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_environment_record_t,
        -:  317:                                                                  property_pair_p->values[index].value);
        -:  318:
    #####:  319:          if (environment_record_p->this_binding != ECMA_VALUE_UNINITIALIZED)
        -:  320:          {
    #####:  321:            JERRY_ASSERT (ecma_is_value_object (environment_record_p->this_binding));
    #####:  322:            ecma_gc_set_object_visited (ecma_get_object_from_value (environment_record_p->this_binding));
        -:  323:          }
        -:  324:
    #####:  325:          JERRY_ASSERT (ecma_is_value_object (environment_record_p->function_object));
    #####:  326:          ecma_gc_set_object_visited (ecma_get_object_from_value (environment_record_p->function_object));
    #####:  327:          break;
        -:  328:        }
        -:  329:#endif /* JERRY_ESNEXT */
        -:  330:#if JERRY_BUILTIN_CONTAINER
    #####:  331:        case LIT_INTERNAL_MAGIC_STRING_WEAK_REFS:
        -:  332:        {
    #####:  333:          ecma_value_t key_arg = ecma_make_object_value (object_p);
        -:  334:          ecma_collection_t *refs_p;
        -:  335:
    #####:  336:          refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, property_pair_p->values[index].value);
        -:  337:
    #####:  338:          for (uint32_t j = 0; j < refs_p->item_count; j++)
        -:  339:          {
    #####:  340:            const ecma_value_t reference_value = refs_p->buffer_p[j];
        -:  341:
    #####:  342:            if (ecma_is_value_empty (reference_value))
        -:  343:            {
    #####:  344:              continue;
        -:  345:            }
        -:  346:
    #####:  347:            ecma_object_t *reference_object_p = ecma_get_object_from_value (reference_value);
        -:  348:
    #####:  349:            JERRY_ASSERT (ecma_get_object_type (reference_object_p) == ECMA_OBJECT_TYPE_CLASS);
        -:  350:
    #####:  351:            ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) reference_object_p;
        -:  352:
    #####:  353:            if (map_object_p->u.cls.type != ECMA_OBJECT_CLASS_CONTAINER
    #####:  354:                || map_object_p->u.cls.u2.container_id != LIT_MAGIC_STRING_WEAKMAP_UL
    #####:  355:                || !ecma_gc_is_object_visited (reference_object_p))
        -:  356:            {
    #####:  357:              continue;
        -:  358:            }
        -:  359:
    #####:  360:            ecma_value_t value = ecma_op_container_find_weak_value (reference_object_p, key_arg);
        -:  361:
    #####:  362:            if (ecma_is_value_object (value))
        -:  363:            {
    #####:  364:              ecma_gc_set_object_visited (ecma_get_object_from_value (value));
        -:  365:            }
        -:  366:          }
    #####:  367:          break;
        -:  368:        }
        -:  369:#endif /* JERRY_BUILTIN_CONTAINER */
    #####:  370:        case LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES:
        -:  371:        {
    #####:  372:          jerry_value_t value = property_pair_p->values[index].value;
        -:  373:
    #####:  374:          if (value == JMEM_CP_NULL)
        -:  375:          {
    #####:  376:            JERRY_ASSERT (!(property & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL));
    #####:  377:            break;
        -:  378:          }
        -:  379:
        -:  380:          ecma_native_pointer_t *item_p;
    #####:  381:          item_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t, value);
        -:  382:
        -:  383:          do
        -:  384:          {
    #####:  385:            jerry_object_native_info_t *native_info_p = item_p->native_info_p;
        -:  386:
    #####:  387:            JERRY_ASSERT (native_info_p != NULL && native_info_p->number_of_references > 0);
        -:  388:
    #####:  389:            uint8_t *start_p = ((uint8_t *) item_p->native_p) + native_info_p->offset_of_references;
    #####:  390:            ecma_value_t *value_p = (ecma_value_t *) start_p;
    #####:  391:            ecma_value_t *end_p = value_p + native_info_p->number_of_references;
        -:  392:
        -:  393:            do
        -:  394:            {
    #####:  395:              if (ecma_is_value_object (*value_p))
        -:  396:              {
    #####:  397:                ecma_gc_set_object_visited (ecma_get_object_from_value (*value_p));
        -:  398:              }
        -:  399:            }
    #####:  400:            while (++value_p < end_p);
        -:  401:
    #####:  402:            if (property & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL)
        -:  403:            {
    #####:  404:              break;
        -:  405:            }
        -:  406:
    #####:  407:            item_p = &(((ecma_native_pointer_chain_t *) item_p)->next_p->data);
        -:  408:          }
    #####:  409:          while (item_p != NULL);
        -:  410:
    #####:  411:          break;
        -:  412:        }
        -:  413:      }
        -:  414:    }
        -:  415:
    #####:  416:    prop_iter_cp = prop_iter_p->next_property_cp;
        -:  417:  }
    #####:  418:} /* ecma_gc_mark_properties */
        -:  419:
        -:  420:/**
        -:  421: * Mark compiled code.
        -:  422: */
        -:  423:static void
    #####:  424:ecma_gc_mark_compiled_code (ecma_value_t script_value) /**< script value */
        -:  425:{
    #####:  426:  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -:  427:
    #####:  428:  if (script_p->refs_and_type & CBC_SCRIPT_USER_VALUE_IS_OBJECT)
        -:  429:  {
    #####:  430:    ecma_value_t user_value = CBC_SCRIPT_GET_USER_VALUE (script_p);
        -:  431:
    #####:  432:    JERRY_ASSERT (ecma_is_value_object (user_value));
    #####:  433:    ecma_gc_set_object_visited (ecma_get_object_from_value (user_value));
        -:  434:  }
        -:  435:
        -:  436:#if JERRY_MODULE_SYSTEM
    #####:  437:  if (script_p->refs_and_type & CBC_SCRIPT_HAS_IMPORT_META)
        -:  438:  {
    #####:  439:    ecma_value_t import_meta = CBC_SCRIPT_GET_IMPORT_META (script_p, script_p->refs_and_type);
        -:  440:
    #####:  441:    JERRY_ASSERT (ecma_is_value_object (import_meta));
    #####:  442:    ecma_gc_set_object_visited (ecma_get_object_from_value (import_meta));
        -:  443:  }
        -:  444:#endif /* JERRY_MODULE_SYSTEM */
        -:  445:
        -:  446:#if JERRY_BUILTIN_REALMS
    #####:  447:  ecma_gc_set_object_visited (script_p->realm_p);
        -:  448:#endif /* JERRY_BUILTIN_REALMS */
    #####:  449:} /* ecma_gc_mark_compiled_code */
        -:  450:
        -:  451:/**
        -:  452: * Mark objects referenced by bound function object.
        -:  453: */
        -:  454:static void JERRY_ATTR_NOINLINE
    #####:  455:ecma_gc_mark_bound_function_object (ecma_object_t *object_p) /**< bound function object */
        -:  456:{
    #####:  457:  JERRY_ASSERT (ecma_get_object_type (object_p) == ECMA_OBJECT_TYPE_BOUND_FUNCTION);
        -:  458:
    #####:  459:  ecma_bound_function_t *bound_func_p = (ecma_bound_function_t *) object_p;
        -:  460:
        -:  461:  ecma_object_t *target_func_p;
    #####:  462:  target_func_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -:  463:                                                              bound_func_p->header.u.bound_function.target_function);
        -:  464:
    #####:  465:  ecma_gc_set_object_visited (target_func_p);
        -:  466:
    #####:  467:  ecma_value_t args_len_or_this = bound_func_p->header.u.bound_function.args_len_or_this;
        -:  468:
    #####:  469:  if (!ecma_is_value_integer_number (args_len_or_this))
        -:  470:  {
    #####:  471:    if (ecma_is_value_object (args_len_or_this))
        -:  472:    {
    #####:  473:      ecma_gc_set_object_visited (ecma_get_object_from_value (args_len_or_this));
        -:  474:    }
        -:  475:
    #####:  476:    return;
        -:  477:  }
        -:  478:
    #####:  479:  ecma_integer_value_t args_length = ecma_get_integer_from_value (args_len_or_this);
    #####:  480:  ecma_value_t *args_p = (ecma_value_t *) (bound_func_p + 1);
        -:  481:
    #####:  482:  JERRY_ASSERT (args_length > 0);
        -:  483:
    #####:  484:  for (ecma_integer_value_t i = 0; i < args_length; i++)
        -:  485:  {
    #####:  486:    if (ecma_is_value_object (args_p[i]))
        -:  487:    {
    #####:  488:      ecma_gc_set_object_visited (ecma_get_object_from_value (args_p[i]));
        -:  489:    }
        -:  490:  }
        -:  491:} /* ecma_gc_mark_bound_function_object */
        -:  492:
        -:  493:#if JERRY_ESNEXT
        -:  494:/**
        -:  495: * Mark objects referenced by Promise built-in.
        -:  496: */
        -:  497:static void
    #####:  498:ecma_gc_mark_promise_object (ecma_extended_object_t *ext_object_p) /**< extended object */
        -:  499:{
        -:  500:  /* Mark promise result. */
    #####:  501:  ecma_value_t result = ext_object_p->u.cls.u3.value;
        -:  502:
    #####:  503:  if (ecma_is_value_object (result))
        -:  504:  {
    #####:  505:    ecma_gc_set_object_visited (ecma_get_object_from_value (result));
        -:  506:  }
        -:  507:
        -:  508:  /* Mark all reactions. */
    #####:  509:  ecma_promise_object_t *promise_object_p = (ecma_promise_object_t *) ext_object_p;
        -:  510:
    #####:  511:  ecma_collection_t *collection_p = promise_object_p->reactions;
        -:  512:
    #####:  513:  if (collection_p != NULL)
        -:  514:  {
    #####:  515:    ecma_value_t *buffer_p = collection_p->buffer_p;
    #####:  516:    ecma_value_t *buffer_end_p = buffer_p + collection_p->item_count;
        -:  517:
    #####:  518:    while (buffer_p < buffer_end_p)
        -:  519:    {
    #####:  520:      ecma_value_t value = *buffer_p++;
        -:  521:
    #####:  522:      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t, value));
        -:  523:
    #####:  524:      if (JMEM_CP_GET_FIRST_BIT_FROM_POINTER_TAG (value))
        -:  525:      {
    #####:  526:        ecma_gc_set_object_visited (ecma_get_object_from_value (*buffer_p++));
        -:  527:      }
        -:  528:
    #####:  529:      if (JMEM_CP_GET_SECOND_BIT_FROM_POINTER_TAG (value))
        -:  530:      {
    #####:  531:        ecma_gc_set_object_visited (ecma_get_object_from_value (*buffer_p++));
        -:  532:      }
        -:  533:    }
        -:  534:  }
    #####:  535:} /* ecma_gc_mark_promise_object */
        -:  536:
        -:  537:#endif /* JERRY_ESNEXT */
        -:  538:
        -:  539:#if JERRY_BUILTIN_CONTAINER
        -:  540:/**
        -:  541: * Mark objects referenced by Map built-in.
        -:  542: */
        -:  543:static void
    #####:  544:ecma_gc_mark_map_object (ecma_object_t *object_p) /**< object */
        -:  545:{
    #####:  546:  JERRY_ASSERT (object_p != NULL);
        -:  547:
    #####:  548:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
    #####:  549:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  550:                                                                    map_object_p->u.cls.u3.value);
    #####:  551:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
    #####:  552:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
        -:  553:
    #####:  554:  for (uint32_t i = 0; i < entry_count; i+= ECMA_CONTAINER_PAIR_SIZE)
        -:  555:  {
    #####:  556:    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);
        -:  557:
    #####:  558:    if (ecma_is_value_empty (entry_p->key))
        -:  559:    {
    #####:  560:      continue;
        -:  561:    }
        -:  562:
    #####:  563:    if (ecma_is_value_object (entry_p->key))
        -:  564:    {
    #####:  565:      ecma_gc_set_object_visited (ecma_get_object_from_value (entry_p->key));
        -:  566:    }
        -:  567:
    #####:  568:    if (ecma_is_value_object (entry_p->value))
        -:  569:    {
    #####:  570:      ecma_gc_set_object_visited (ecma_get_object_from_value (entry_p->value));
        -:  571:    }
        -:  572:  }
    #####:  573:} /* ecma_gc_mark_map_object */
        -:  574:
        -:  575:/**
        -:  576: * Mark objects referenced by WeakMap built-in.
        -:  577: */
        -:  578:static void
    #####:  579:ecma_gc_mark_weakmap_object (ecma_object_t *object_p) /**< object */
        -:  580:{
    #####:  581:  JERRY_ASSERT (object_p != NULL);
        -:  582:
    #####:  583:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
    #####:  584:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  585:                                                                    map_object_p->u.cls.u3.value);
    #####:  586:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
    #####:  587:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
        -:  588:
    #####:  589:  for (uint32_t i = 0; i < entry_count; i+= ECMA_CONTAINER_PAIR_SIZE)
        -:  590:  {
    #####:  591:    ecma_container_pair_t *entry_p = (ecma_container_pair_t *) (start_p + i);
        -:  592:
    #####:  593:    if (ecma_is_value_empty (entry_p->key))
        -:  594:    {
    #####:  595:      continue;
        -:  596:    }
        -:  597:
    #####:  598:    JERRY_ASSERT (ecma_is_value_object (entry_p->key));
        -:  599:
    #####:  600:    if (ecma_is_value_object (entry_p->value)
    #####:  601:        && ecma_gc_is_object_visited (ecma_get_object_from_value (entry_p->key)))
        -:  602:    {
    #####:  603:      ecma_gc_set_object_visited (ecma_get_object_from_value (entry_p->value));
        -:  604:    }
        -:  605:  }
    #####:  606:} /* ecma_gc_mark_weakmap_object */
        -:  607:
        -:  608:/**
        -:  609: * Mark objects referenced by Set built-in.
        -:  610: */
        -:  611:static void
    #####:  612:ecma_gc_mark_set_object (ecma_object_t *object_p) /**< object */
        -:  613:{
    #####:  614:  JERRY_ASSERT (object_p != NULL);
        -:  615:
    #####:  616:  ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
    #####:  617:  ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -:  618:                                                                    map_object_p->u.cls.u3.value);
    #####:  619:  ecma_value_t *start_p = ECMA_CONTAINER_START (container_p);
    #####:  620:  uint32_t entry_count = ECMA_CONTAINER_ENTRY_COUNT (container_p);
        -:  621:
    #####:  622:  for (uint32_t i = 0; i < entry_count; i+= ECMA_CONTAINER_VALUE_SIZE)
        -:  623:  {
    #####:  624:    ecma_value_t *entry_p = start_p + i;
        -:  625:
    #####:  626:    if (ecma_is_value_empty (*entry_p))
        -:  627:    {
    #####:  628:      continue;
        -:  629:    }
        -:  630:
    #####:  631:    if (ecma_is_value_object (*entry_p))
        -:  632:    {
    #####:  633:      ecma_gc_set_object_visited (ecma_get_object_from_value (*entry_p));
        -:  634:    }
        -:  635:  }
    #####:  636:} /* ecma_gc_mark_set_object */
        -:  637:#endif /* JERRY_BUILTIN_CONTAINER */
        -:  638:
        -:  639:#if JERRY_ESNEXT
        -:  640:/**
        -:  641: * Mark objects referenced by inactive generator functions, async functions, etc.
        -:  642: */
        -:  643:static void
    #####:  644:ecma_gc_mark_executable_object (ecma_object_t *object_p) /**< object */
        -:  645:{
    #####:  646:  vm_executable_object_t *executable_object_p = (vm_executable_object_t *) object_p;
        -:  647:
    #####:  648:  if (executable_object_p->extended_object.u.cls.u2.executable_obj_flags & ECMA_ASYNC_GENERATOR_CALLED)
        -:  649:  {
    #####:  650:    ecma_value_t task = executable_object_p->extended_object.u.cls.u3.head;
        -:  651:
    #####:  652:    while (!ECMA_IS_INTERNAL_VALUE_NULL (task))
        -:  653:    {
        -:  654:      ecma_async_generator_task_t *task_p;
    #####:  655:      task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, task);
        -:  656:
    #####:  657:      JERRY_ASSERT (ecma_is_value_object (task_p->promise));
    #####:  658:      ecma_gc_set_object_visited (ecma_get_object_from_value (task_p->promise));
        -:  659:
    #####:  660:      if (ecma_is_value_object (task_p->operation_value))
        -:  661:      {
    #####:  662:        ecma_gc_set_object_visited (ecma_get_object_from_value (task_p->operation_value));
        -:  663:      }
        -:  664:
    #####:  665:      task = task_p->next;
        -:  666:    }
        -:  667:  }
        -:  668:
    #####:  669:  ecma_gc_set_object_visited (executable_object_p->frame_ctx.lex_env_p);
    #####:  670:  ecma_gc_set_object_visited (executable_object_p->shared.function_object_p);
        -:  671:
    #####:  672:  if (!ECMA_EXECUTABLE_OBJECT_IS_SUSPENDED (executable_object_p))
        -:  673:  {
        -:  674:    /* All objects referenced by running executable objects are strong roots,
        -:  675:     * and a finished executable object cannot refer to other values. */
    #####:  676:    return;
        -:  677:  }
        -:  678:
    #####:  679:  if (ecma_is_value_object (executable_object_p->frame_ctx.this_binding))
        -:  680:  {
    #####:  681:    ecma_gc_set_object_visited (ecma_get_object_from_value (executable_object_p->frame_ctx.this_binding));
        -:  682:  }
        -:  683:
    #####:  684:  const ecma_compiled_code_t *bytecode_header_p = executable_object_p->shared.bytecode_header_p;
        -:  685:  size_t register_end;
        -:  686:
    #####:  687:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  688:  {
    #####:  689:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  690:    register_end = args_p->register_end;
        -:  691:  }
        -:  692:  else
        -:  693:  {
    #####:  694:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  695:    register_end = args_p->register_end;
        -:  696:  }
        -:  697:
    #####:  698:  ecma_value_t *register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
    #####:  699:  ecma_value_t *register_end_p = register_p + register_end;
        -:  700:
    #####:  701:  while (register_p < register_end_p)
        -:  702:  {
    #####:  703:    if (ecma_is_value_object (*register_p))
        -:  704:    {
    #####:  705:      ecma_gc_set_object_visited (ecma_get_object_from_value (*register_p));
        -:  706:    }
        -:  707:
    #####:  708:    register_p++;
        -:  709:  }
        -:  710:
    #####:  711:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  712:  {
    #####:  713:    ecma_value_t *context_end_p = register_p;
        -:  714:
    #####:  715:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  716:
    #####:  717:    ecma_value_t *context_top_p = register_p;
        -:  718:
        -:  719:    do
        -:  720:    {
    #####:  721:      if (VM_CONTEXT_IS_VARIABLE_LENGTH (VM_GET_CONTEXT_TYPE (context_top_p[-1])))
        -:  722:      {
    #####:  723:        ecma_value_t *last_item_p = context_top_p - VM_GET_CONTEXT_END (context_top_p[-1]);
    #####:  724:        JERRY_ASSERT (last_item_p >= context_end_p);
    #####:  725:        context_top_p--;
        -:  726:
        -:  727:        do
        -:  728:        {
    #####:  729:          ecma_gc_set_object_visited (ecma_get_object_from_value (*(--context_top_p)));
        -:  730:        }
    #####:  731:        while (context_top_p > last_item_p);
        -:  732:
    #####:  733:        continue;
        -:  734:      }
        -:  735:
    #####:  736:      uint32_t offsets = vm_get_context_value_offsets (context_top_p);
        -:  737:
    #####:  738:      while (VM_CONTEXT_HAS_NEXT_OFFSET (offsets))
        -:  739:      {
    #####:  740:        int32_t offset = VM_CONTEXT_GET_NEXT_OFFSET (offsets);
        -:  741:
    #####:  742:        if (ecma_is_value_object (context_top_p[offset]))
        -:  743:        {
    #####:  744:          ecma_gc_set_object_visited (ecma_get_object_from_value (context_top_p[offset]));
        -:  745:        }
        -:  746:
    #####:  747:        offsets >>= VM_CONTEXT_OFFSET_SHIFT;
        -:  748:      }
        -:  749:
    #####:  750:      JERRY_ASSERT (context_top_p >= context_end_p + offsets);
    #####:  751:      context_top_p -= offsets;
        -:  752:    }
    #####:  753:    while (context_top_p > context_end_p);
        -:  754:  }
        -:  755:
    #####:  756:  register_end_p = executable_object_p->frame_ctx.stack_top_p;
        -:  757:
    #####:  758:  while (register_p < register_end_p)
        -:  759:  {
    #####:  760:    if (ecma_is_value_object (*register_p))
        -:  761:    {
    #####:  762:      ecma_gc_set_object_visited (ecma_get_object_from_value (*register_p));
        -:  763:    }
        -:  764:
    #####:  765:    register_p++;
        -:  766:  }
        -:  767:
    #####:  768:  if (ecma_is_value_object (executable_object_p->frame_ctx.block_result))
        -:  769:  {
    #####:  770:    ecma_gc_set_object_visited (ecma_get_object_from_value (executable_object_p->frame_ctx.block_result));
        -:  771:  }
        -:  772:} /* ecma_gc_mark_executable_object */
        -:  773:
        -:  774:#endif /* JERRY_ESNEXT */
        -:  775:
        -:  776:#if JERRY_BUILTIN_PROXY
        -:  777:/**
        -:  778: * Mark the objects referenced by a proxy object
        -:  779: */
        -:  780:static void
    #####:  781:ecma_gc_mark_proxy_object (ecma_object_t *object_p) /**< proxy object */
        -:  782:{
    #####:  783:  JERRY_ASSERT (ECMA_OBJECT_IS_PROXY (object_p));
        -:  784:
    #####:  785:  ecma_proxy_object_t *proxy_p = (ecma_proxy_object_t *) object_p;
        -:  786:
    #####:  787:  if (!ecma_is_value_null (proxy_p->target))
        -:  788:  {
    #####:  789:    ecma_gc_set_object_visited (ecma_get_object_from_value (proxy_p->target));
        -:  790:  }
        -:  791:
    #####:  792:  if (!ecma_is_value_null (proxy_p->handler))
        -:  793:  {
    #####:  794:    ecma_gc_set_object_visited (ecma_get_object_from_value (proxy_p->handler));
        -:  795:  }
    #####:  796:} /* ecma_gc_mark_proxy_object */
        -:  797:#endif /* JERRY_BUILTIN_PROXY */
        -:  798:
        -:  799:/**
        -:  800: * Mark objects as visited starting from specified object as root
        -:  801: */
        -:  802:static void
    #####:  803:ecma_gc_mark (ecma_object_t *object_p) /**< object to mark from */
        -:  804:{
    #####:  805:  JERRY_ASSERT (object_p != NULL);
    #####:  806:  JERRY_ASSERT (ecma_gc_is_object_visited (object_p));
        -:  807:
    #####:  808:  if (ecma_is_lexical_environment (object_p))
        -:  809:  {
    #####:  810:    jmem_cpointer_t outer_lex_env_cp = object_p->u2.outer_reference_cp;
        -:  811:
    #####:  812:    if (outer_lex_env_cp != JMEM_CP_NULL)
        -:  813:    {
    #####:  814:      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, outer_lex_env_cp));
        -:  815:    }
        -:  816:
    #####:  817:    switch (ecma_get_lex_env_type (object_p))
        -:  818:    {
        -:  819:#if JERRY_ESNEXT
    #####:  820:      case ECMA_LEXICAL_ENVIRONMENT_CLASS:
        -:  821:      {
        -:  822:#if JERRY_MODULE_SYSTEM
    #####:  823:        if (object_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA)
        -:  824:        {
    #####:  825:          ecma_gc_mark_properties (object_p, true);
    #####:  826:          ecma_gc_set_object_visited (((ecma_lexical_environment_class_t *) object_p)->module_p);
    #####:  827:          return;
        -:  828:        }
        -:  829:#endif /* JERRY_MODULE_SYSTEM */
        -:  830:        /* FALLTHRU */
        -:  831:      }
        -:  832:#endif /* JERRY_ESNEXT */
    #####:  833:      case ECMA_LEXICAL_ENVIRONMENT_THIS_OBJECT_BOUND:
        -:  834:      {
    #####:  835:        ecma_object_t *binding_object_p = ecma_get_lex_env_binding_object (object_p);
    #####:  836:        ecma_gc_set_object_visited (binding_object_p);
    #####:  837:        return;
        -:  838:      }
    #####:  839:      default:
        -:  840:      {
    #####:  841:        break;
        -:  842:      }
        -:  843:    }
        -:  844:  }
        -:  845:  else
        -:  846:  {
        -:  847:    /**
        -:  848:     * Have the object's prototype here so the object could set it to JMEM_CP_NULL
        -:  849:     * if the prototype should be ignored (like in case of PROXY).
        -:  850:     */
    #####:  851:    jmem_cpointer_t proto_cp = object_p->u2.prototype_cp;
        -:  852:
    #####:  853:    switch (ecma_get_object_type (object_p))
        -:  854:    {
    #####:  855:      case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -:  856:      {
    #####:  857:        ecma_extended_object_t *extended_object_p = (ecma_extended_object_t *) object_p;
        -:  858:
    #####:  859:        if (extended_object_p->u.built_in.id == ECMA_BUILTIN_ID_GLOBAL)
        -:  860:        {
    #####:  861:          ecma_gc_mark_global_object ((ecma_global_object_t *) object_p);
        -:  862:        }
        -:  863:
        -:  864:#if JERRY_BUILTIN_REALMS
    #####:  865:        ecma_value_t realm_value = extended_object_p->u.built_in.realm_value;
    #####:  866:        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, realm_value));
        -:  867:#endif /* JERRY_BUILTIN_REALMS */
    #####:  868:        break;
        -:  869:      }
    #####:  870:      case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -:  871:      {
        -:  872:#if JERRY_BUILTIN_REALMS
    #####:  873:        ecma_value_t realm_value = ((ecma_extended_built_in_object_t *) object_p)->built_in.realm_value;
    #####:  874:        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, realm_value));
        -:  875:#endif /* JERRY_BUILTIN_REALMS */
        -:  876:        /* FALLTHRU */
        -:  877:      }
    #####:  878:      case ECMA_OBJECT_TYPE_CLASS:
        -:  879:      {
    #####:  880:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  881:
    #####:  882:        switch (ext_object_p->u.cls.type)
        -:  883:        {
    #####:  884:          case ECMA_OBJECT_CLASS_ARGUMENTS:
        -:  885:          {
    #####:  886:            ecma_gc_mark_arguments_object (ext_object_p);
    #####:  887:            break;
        -:  888:          }
        -:  889:#if JERRY_PARSER
    #####:  890:          case ECMA_OBJECT_CLASS_SCRIPT:
        -:  891:          {
        -:  892:            const ecma_compiled_code_t *compiled_code_p;
    #####:  893:            compiled_code_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -:  894:                                                               ext_object_p->u.cls.u3.value);
        -:  895:
    #####:  896:            JERRY_ASSERT (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));
    #####:  897:            ecma_gc_mark_compiled_code (((cbc_uint8_arguments_t *) compiled_code_p)->script_value);
    #####:  898:            break;
        -:  899:          }
        -:  900:#endif /* JERRY_PARSER */
        -:  901:#if JERRY_BUILTIN_TYPEDARRAY
    #####:  902:          case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -:  903:          {
    #####:  904:            ecma_gc_set_object_visited (ecma_typedarray_get_arraybuffer (object_p));
    #####:  905:            break;
        -:  906:          }
        -:  907:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -:  908:#if JERRY_MODULE_SYSTEM
    #####:  909:          case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:
        -:  910:          {
    #####:  911:            JERRY_ASSERT (proto_cp == JMEM_CP_NULL);
    #####:  912:            ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,
        -:  913:                                                                         ext_object_p->u.cls.u3.value));
    #####:  914:            ecma_gc_mark_properties (object_p, true);
    #####:  915:            return;
        -:  916:          }
        -:  917:#endif /* JERRY_MODULE_SYSTEM */
        -:  918:#if JERRY_MODULE_SYSTEM
    #####:  919:          case ECMA_OBJECT_CLASS_MODULE:
        -:  920:          {
    #####:  921:            ecma_module_t *module_p = ((ecma_module_t *) ext_object_p);
        -:  922:
    #####:  923:            if (module_p->scope_p != NULL)
        -:  924:            {
    #####:  925:              ecma_gc_set_object_visited (((ecma_module_t *) ext_object_p)->scope_p);
        -:  926:            }
        -:  927:
    #####:  928:            if (module_p->namespace_object_p != NULL)
        -:  929:            {
    #####:  930:              ecma_gc_set_object_visited (((ecma_module_t *) ext_object_p)->namespace_object_p);
        -:  931:            }
        -:  932:
    #####:  933:            if (!(module_p->header.u.cls.u2.module_flags & ECMA_MODULE_IS_NATIVE)
    #####:  934:                && module_p->u.compiled_code_p != NULL)
        -:  935:            {
    #####:  936:              const ecma_compiled_code_t *compiled_code_p = module_p->u.compiled_code_p;
        -:  937:
    #####:  938:              JERRY_ASSERT (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));
    #####:  939:              ecma_gc_mark_compiled_code (((cbc_uint8_arguments_t *) compiled_code_p)->script_value);
        -:  940:            }
        -:  941:
    #####:  942:            ecma_module_node_t *node_p = module_p->imports_p;
        -:  943:
    #####:  944:            while (node_p != NULL)
        -:  945:            {
    #####:  946:              if (ecma_is_value_object (node_p->u.path_or_module))
        -:  947:              {
    #####:  948:                ecma_gc_set_object_visited (ecma_get_object_from_value (node_p->u.path_or_module));
        -:  949:              }
        -:  950:
    #####:  951:              node_p = node_p->next_p;
        -:  952:            }
    #####:  953:            break;
        -:  954:          }
        -:  955:#endif /* JERRY_MODULE_SYSTEM */
        -:  956:#if JERRY_BUILTIN_DATAVIEW
    #####:  957:          case ECMA_OBJECT_CLASS_DATAVIEW:
        -:  958:          {
    #####:  959:            ecma_dataview_object_t *dataview_p = (ecma_dataview_object_t *) object_p;
    #####:  960:            ecma_gc_set_object_visited (dataview_p->buffer_p);
    #####:  961:            break;
        -:  962:          }
        -:  963:#endif /* JERRY_BUILTIN_DATAVIEW */
        -:  964:#if JERRY_BUILTIN_CONTAINER
    #####:  965:          case ECMA_OBJECT_CLASS_CONTAINER:
        -:  966:          {
    #####:  967:            if (ext_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_MAP_UL)
        -:  968:            {
    #####:  969:              ecma_gc_mark_map_object (object_p);
    #####:  970:              break;
        -:  971:            }
    #####:  972:            if (ext_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKMAP_UL)
        -:  973:            {
    #####:  974:              ecma_gc_mark_weakmap_object (object_p);
    #####:  975:              break;
        -:  976:            }
    #####:  977:            if (ext_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_SET_UL)
        -:  978:            {
    #####:  979:              ecma_gc_mark_set_object (object_p);
    #####:  980:              break;
        -:  981:            }
    #####:  982:            JERRY_ASSERT (ext_object_p->u.cls.u2.container_id == LIT_MAGIC_STRING_WEAKSET_UL);
    #####:  983:            break;
        -:  984:          }
        -:  985:#endif /* JERRY_BUILTIN_CONTAINER */
        -:  986:#if JERRY_ESNEXT
    #####:  987:          case ECMA_OBJECT_CLASS_GENERATOR:
        -:  988:          case ECMA_OBJECT_CLASS_ASYNC_GENERATOR:
        -:  989:          {
    #####:  990:            ecma_gc_mark_executable_object (object_p);
    #####:  991:            break;
        -:  992:          }
    #####:  993:          case ECMA_OBJECT_CLASS_PROMISE:
        -:  994:          {
    #####:  995:            ecma_gc_mark_promise_object (ext_object_p);
    #####:  996:            break;
        -:  997:          }
    #####:  998:          case ECMA_OBJECT_CLASS_PROMISE_CAPABILITY:
        -:  999:          {
    #####: 1000:            ecma_promise_capabality_t *capability_p = (ecma_promise_capabality_t *) object_p;
        -: 1001:
    #####: 1002:            if (ecma_is_value_object (capability_p->header.u.cls.u3.promise))
        -: 1003:            {
    #####: 1004:              ecma_gc_set_object_visited (ecma_get_object_from_value (capability_p->header.u.cls.u3.promise));
        -: 1005:            }
    #####: 1006:            if (ecma_is_value_object (capability_p->resolve))
        -: 1007:            {
    #####: 1008:              ecma_gc_set_object_visited (ecma_get_object_from_value (capability_p->resolve));
        -: 1009:            }
    #####: 1010:            if (ecma_is_value_object (capability_p->reject))
        -: 1011:            {
    #####: 1012:              ecma_gc_set_object_visited (ecma_get_object_from_value (capability_p->reject));
        -: 1013:            }
    #####: 1014:            break;
        -: 1015:          }
    #####: 1016:          case ECMA_OBJECT_CLASS_ARRAY_ITERATOR:
        -: 1017:          case ECMA_OBJECT_CLASS_SET_ITERATOR:
        -: 1018:          case ECMA_OBJECT_CLASS_MAP_ITERATOR:
        -: 1019:          {
    #####: 1020:            ecma_value_t iterated_value = ext_object_p->u.cls.u3.iterated_value;
    #####: 1021:            if (!ecma_is_value_empty (iterated_value))
        -: 1022:            {
    #####: 1023:              ecma_gc_set_object_visited (ecma_get_object_from_value (iterated_value));
        -: 1024:            }
    #####: 1025:            break;
        -: 1026:          }
        -: 1027:#if JERRY_BUILTIN_REGEXP
    #####: 1028:          case ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR:
        -: 1029:          {
    #####: 1030:            ecma_regexp_string_iterator_t *regexp_string_iterator_obj = (ecma_regexp_string_iterator_t *) object_p;
    #####: 1031:            ecma_value_t regexp = regexp_string_iterator_obj->iterating_regexp;
    #####: 1032:            ecma_gc_set_object_visited (ecma_get_object_from_value (regexp));
    #####: 1033:            break;
        -: 1034:          }
        -: 1035:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1036:#endif /* JERRY_ESNEXT */
    #####: 1037:          default:
        -: 1038:          {
        -: 1039:            /* The ECMA_OBJECT_CLASS__MAX type represents an uninitialized class. */
    #####: 1040:            JERRY_ASSERT (ext_object_p->u.cls.type <= ECMA_OBJECT_CLASS__MAX);
    #####: 1041:            break;
        -: 1042:          }
        -: 1043:        }
        -: 1044:
    #####: 1045:        break;
        -: 1046:      }
    #####: 1047:      case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1048:      {
        -: 1049:#if JERRY_BUILTIN_REALMS
    #####: 1050:        ecma_value_t realm_value = ((ecma_extended_built_in_object_t *) object_p)->built_in.realm_value;
    #####: 1051:        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, realm_value));
        -: 1052:#endif /* JERRY_BUILTIN_REALMS */
        -: 1053:        /* FALLTHRU */
        -: 1054:      }
    #####: 1055:      case ECMA_OBJECT_TYPE_ARRAY:
        -: 1056:      {
    #####: 1057:        ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1058:
        -: 1059:#if JERRY_ESNEXT
    #####: 1060:        if (JERRY_UNLIKELY (ext_object_p->u.array.length_prop_and_hole_count & ECMA_ARRAY_TEMPLATE_LITERAL))
        -: 1061:        {
        -: 1062:          /* Template objects are never marked. */
    #####: 1063:          JERRY_ASSERT (object_p->type_flags_refs >= ECMA_OBJECT_REF_ONE);
    #####: 1064:          return;
        -: 1065:        }
        -: 1066:#endif /* JERRY_ESNEXT */
        -: 1067:
    #####: 1068:        if (ecma_op_array_is_fast_array (ext_object_p))
        -: 1069:        {
    #####: 1070:          if (object_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 1071:          {
    #####: 1072:            ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -: 1073:
    #####: 1074:            for (uint32_t i = 0; i < ext_object_p->u.array.length; i++)
        -: 1075:            {
    #####: 1076:              if (ecma_is_value_object (values_p[i]))
        -: 1077:              {
    #####: 1078:                ecma_gc_set_object_visited (ecma_get_object_from_value (values_p[i]));
        -: 1079:              }
        -: 1080:            }
        -: 1081:          }
        -: 1082:
    #####: 1083:          if (proto_cp != JMEM_CP_NULL)
        -: 1084:          {
    #####: 1085:            ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp));
        -: 1086:          }
    #####: 1087:          return;
        -: 1088:        }
    #####: 1089:        break;
        -: 1090:      }
        -: 1091:#if JERRY_BUILTIN_PROXY
    #####: 1092:      case ECMA_OBJECT_TYPE_PROXY:
        -: 1093:      {
    #####: 1094:        ecma_gc_mark_proxy_object (object_p);
        -: 1095:        /* Prototype of proxy object is a bit set. */
    #####: 1096:        proto_cp = JMEM_CP_NULL;
    #####: 1097:        break;
        -: 1098:      }
        -: 1099:#endif /* JERRY_BUILTIN_PROXY */
    #####: 1100:      case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1101:      {
    #####: 1102:        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
    #####: 1103:        ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -: 1104:                                                                                ext_func_p->u.function.scope_cp));
        -: 1105:
    #####: 1106:        const ecma_compiled_code_t *compiled_code_p = ecma_op_function_get_compiled_code (ext_func_p);
        -: 1107:
        -: 1108:#if JERRY_ESNEXT
    #####: 1109:        if (CBC_FUNCTION_IS_ARROW (compiled_code_p->status_flags))
        -: 1110:        {
    #####: 1111:          ecma_arrow_function_t *arrow_func_p = (ecma_arrow_function_t *) object_p;
        -: 1112:
    #####: 1113:          if (ecma_is_value_object (arrow_func_p->this_binding))
        -: 1114:          {
    #####: 1115:            ecma_gc_set_object_visited (ecma_get_object_from_value (arrow_func_p->this_binding));
        -: 1116:          }
        -: 1117:
    #####: 1118:          if (ecma_is_value_object (arrow_func_p->new_target))
        -: 1119:          {
    #####: 1120:            ecma_gc_set_object_visited (ecma_get_object_from_value (arrow_func_p->new_target));
        -: 1121:          }
        -: 1122:        }
        -: 1123:#endif /* JERRY_ESNEXT */
        -: 1124:
        -: 1125:#if JERRY_SNAPSHOT_EXEC
    #####: 1126:        if (JERRY_UNLIKELY (compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION))
        -: 1127:        {
        -: 1128:          /* Static snapshot functions have a global realm */
        -: 1129:          break;
        -: 1130:        }
        -: 1131:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1132:
    #####: 1133:        JERRY_ASSERT (!(compiled_code_p->status_flags & CBC_CODE_FLAGS_STATIC_FUNCTION));
    #####: 1134:        ecma_gc_mark_compiled_code (((cbc_uint8_arguments_t *) compiled_code_p)->script_value);
    #####: 1135:        break;
        -: 1136:      }
    #####: 1137:      case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 1138:      {
    #####: 1139:        ecma_gc_mark_bound_function_object (object_p);
    #####: 1140:        break;
        -: 1141:      }
        -: 1142:#if JERRY_ESNEXT || JERRY_BUILTIN_REALMS
    #####: 1143:      case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1144:      {
    #####: 1145:        ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
        -: 1146:#endif /* JERRY_ESNEXT || JERRY_BUILTIN_REALMS */
        -: 1147:
        -: 1148:#if JERRY_BUILTIN_REALMS
    #####: 1149:        ecma_value_t realm_value = ext_func_p->u.built_in.realm_value;
    #####: 1150:        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t, realm_value));
        -: 1151:#endif /* JERRY_BUILTIN_REALMS */
        -: 1152:
        -: 1153:#if JERRY_ESNEXT
    #####: 1154:        if (ext_func_p->u.built_in.id == ECMA_BUILTIN_ID_HANDLER)
        -: 1155:        {
    #####: 1156:          switch (ext_func_p->u.built_in.routine_id)
        -: 1157:          {
    #####: 1158:            case ECMA_NATIVE_HANDLER_PROMISE_RESOLVE:
        -: 1159:            case ECMA_NATIVE_HANDLER_PROMISE_REJECT:
        -: 1160:            {
    #####: 1161:              ecma_promise_resolver_t *resolver_obj_p = (ecma_promise_resolver_t *) object_p;
    #####: 1162:              ecma_gc_set_object_visited (ecma_get_object_from_value (resolver_obj_p->promise));
    #####: 1163:              break;
        -: 1164:            }
    #####: 1165:            case ECMA_NATIVE_HANDLER_PROMISE_THEN_FINALLY:
        -: 1166:            case ECMA_NATIVE_HANDLER_PROMISE_CATCH_FINALLY:
        -: 1167:            {
    #####: 1168:              ecma_promise_finally_function_t *finally_obj_p = (ecma_promise_finally_function_t *) object_p;
    #####: 1169:              ecma_gc_set_object_visited (ecma_get_object_from_value (finally_obj_p->constructor));
    #####: 1170:              ecma_gc_set_object_visited (ecma_get_object_from_value (finally_obj_p->on_finally));
    #####: 1171:              break;
        -: 1172:            }
    #####: 1173:            case ECMA_NATIVE_HANDLER_PROMISE_CAPABILITY_EXECUTOR:
        -: 1174:            {
    #####: 1175:              ecma_promise_capability_executor_t *executor_p = (ecma_promise_capability_executor_t *) object_p;
    #####: 1176:              ecma_gc_set_object_visited (ecma_get_object_from_value (executor_p->capability));
    #####: 1177:              break;
        -: 1178:            }
    #####: 1179:            case ECMA_NATIVE_HANDLER_PROMISE_ALL_HELPER:
        -: 1180:            {
    #####: 1181:              ecma_promise_all_executor_t *executor_p = (ecma_promise_all_executor_t *) object_p;
    #####: 1182:              ecma_gc_set_object_visited (ecma_get_object_from_value (executor_p->capability));
    #####: 1183:              ecma_gc_set_object_visited (ecma_get_object_from_value (executor_p->values));
    #####: 1184:              ecma_gc_set_object_visited (ecma_get_object_from_value (executor_p->remaining_elements));
    #####: 1185:              break;
        -: 1186:            }
        -: 1187:#if JERRY_BUILTIN_PROXY
    #####: 1188:            case ECMA_NATIVE_HANDLER_PROXY_REVOKE:
        -: 1189:            {
    #####: 1190:              ecma_revocable_proxy_object_t *rev_proxy_p = (ecma_revocable_proxy_object_t *) object_p;
        -: 1191:
    #####: 1192:              if (!ecma_is_value_null (rev_proxy_p->proxy))
        -: 1193:              {
    #####: 1194:                ecma_gc_set_object_visited (ecma_get_object_from_value (rev_proxy_p->proxy));
        -: 1195:              }
        -: 1196:
    #####: 1197:              break;
        -: 1198:            }
        -: 1199:#endif /* JERRY_BUILTIN_PROXY */
    #####: 1200:            case ECMA_NATIVE_HANDLER_VALUE_THUNK:
        -: 1201:            case ECMA_NATIVE_HANDLER_VALUE_THROWER:
        -: 1202:            {
    #####: 1203:              ecma_promise_value_thunk_t *thunk_obj_p = (ecma_promise_value_thunk_t *) object_p;
        -: 1204:
    #####: 1205:              if (ecma_is_value_object (thunk_obj_p->value))
        -: 1206:              {
    #####: 1207:                ecma_gc_set_object_visited (ecma_get_object_from_value (thunk_obj_p->value));
        -: 1208:              }
    #####: 1209:              break;
        -: 1210:            }
    #####: 1211:            default:
        -: 1212:            {
    #####: 1213:              JERRY_UNREACHABLE ();
        -: 1214:            }
        -: 1215:          }
    #####: 1216:        }
        -: 1217:#endif /* JERRY_ESNEXT */
        -: 1218:
        -: 1219:#if JERRY_ESNEXT || JERRY_BUILTIN_REALMS
    #####: 1220:        break;
        -: 1221:      }
        -: 1222:#endif /* JERRY_ESNEXT || JERRY_BUILTIN_REALMS */
        -: 1223:#if JERRY_ESNEXT
    #####: 1224:      case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
        -: 1225:      {
    #####: 1226:        ecma_gc_mark_compiled_code (((ecma_extended_object_t *) object_p)->u.constructor_function.script_value);
    #####: 1227:        break;
        -: 1228:      }
        -: 1229:#endif /* JERRY_ESNEXT */
        -: 1230:#if JERRY_BUILTIN_REALMS
    #####: 1231:      case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 1232:      {
    #####: 1233:        ecma_native_function_t *native_function_p = (ecma_native_function_t *) object_p;
    #####: 1234:        ecma_gc_set_object_visited (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_object_t,
        -: 1235:                                                                     native_function_p->realm_value));
    #####: 1236:        break;
        -: 1237:      }
        -: 1238:#endif /* JERRY_BUILTIN_REALMS */
    #####: 1239:      default:
        -: 1240:      {
    #####: 1241:        break;
        -: 1242:      }
        -: 1243:    }
        -: 1244:
    #####: 1245:    if (proto_cp != JMEM_CP_NULL)
        -: 1246:    {
    #####: 1247:      ecma_gc_set_object_visited (ECMA_GET_NON_NULL_POINTER (ecma_object_t, proto_cp));
        -: 1248:    }
        -: 1249:  }
        -: 1250:
    #####: 1251:  ecma_gc_mark_properties (object_p, false);
        -: 1252:} /* ecma_gc_mark */
        -: 1253:
        -: 1254:/**
        -: 1255: * Free the native handle/pointer by calling its free callback.
        -: 1256: */
        -: 1257:static void
    #####: 1258:ecma_gc_free_native_pointer (ecma_property_t property, /**< property descriptor */
        -: 1259:                             ecma_value_t value) /**< property value */
        -: 1260:{
    #####: 1261:  if (JERRY_LIKELY (property & ECMA_PROPERTY_FLAG_SINGLE_EXTERNAL))
        -: 1262:  {
    #####: 1263:    JERRY_ASSERT (value != JMEM_CP_NULL);
        -: 1264:
        -: 1265:    ecma_native_pointer_t *native_pointer_p;
    #####: 1266:    native_pointer_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_t, value);
        -: 1267:
    #####: 1268:    if (native_pointer_p->native_info_p != NULL)
        -: 1269:    {
    #####: 1270:      jerry_object_native_free_callback_t free_cb = native_pointer_p->native_info_p->free_cb;
        -: 1271:
    #####: 1272:      if (free_cb != NULL)
        -: 1273:      {
    #####: 1274:        free_cb (native_pointer_p->native_p, native_pointer_p->native_info_p);
        -: 1275:      }
        -: 1276:    }
        -: 1277:
    #####: 1278:    jmem_heap_free_block (native_pointer_p, sizeof (ecma_native_pointer_t));
    #####: 1279:    return;
        -: 1280:  }
        -: 1281:
    #####: 1282:  if (value == JMEM_CP_NULL)
        -: 1283:  {
    #####: 1284:    return;
        -: 1285:  }
        -: 1286:
        -: 1287:  ecma_native_pointer_chain_t *item_p;
    #####: 1288:  item_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_native_pointer_chain_t, value);
        -: 1289:
        -: 1290:  do
        -: 1291:  {
    #####: 1292:    if (item_p->data.native_info_p != NULL)
        -: 1293:    {
    #####: 1294:      jerry_object_native_free_callback_t free_cb = item_p->data.native_info_p->free_cb;
        -: 1295:
    #####: 1296:      if (free_cb != NULL)
        -: 1297:      {
    #####: 1298:        free_cb (item_p->data.native_p, item_p->data.native_info_p);
        -: 1299:      }
        -: 1300:    }
        -: 1301:
    #####: 1302:    ecma_native_pointer_chain_t *next_p = item_p->next_p;
        -: 1303:
    #####: 1304:    jmem_heap_free_block (item_p, sizeof (ecma_native_pointer_chain_t));
        -: 1305:
    #####: 1306:    item_p = next_p;
        -: 1307:  }
    #####: 1308:  while (item_p != NULL);
        -: 1309:} /* ecma_gc_free_native_pointer */
        -: 1310:
        -: 1311:/**
        -: 1312: * Free specified arguments object.
        -: 1313: *
        -: 1314: * @return allocated object's size
        -: 1315: */
        -: 1316:static size_t
    #####: 1317:ecma_free_arguments_object (ecma_extended_object_t *ext_object_p) /**< arguments object */
        -: 1318:{
    #####: 1319:  JERRY_ASSERT (ecma_get_object_type ((ecma_object_t *) ext_object_p) == ECMA_OBJECT_TYPE_CLASS);
        -: 1320:
    #####: 1321:  size_t object_size = sizeof (ecma_unmapped_arguments_t);
        -: 1322:
    #####: 1323:  if (ext_object_p->u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_MAPPED)
        -: 1324:  {
    #####: 1325:    ecma_mapped_arguments_t *mapped_arguments_p = (ecma_mapped_arguments_t *) ext_object_p;
    #####: 1326:    object_size = sizeof (ecma_mapped_arguments_t);
        -: 1327:
        -: 1328:#if JERRY_SNAPSHOT_EXEC
    #####: 1329:    if (!(mapped_arguments_p->unmapped.header.u.cls.u1.arguments_flags & ECMA_ARGUMENTS_OBJECT_STATIC_BYTECODE))
        -: 1330:#endif /* JERRY_SNAPSHOT_EXEC */
        -: 1331:    {
    #####: 1332:      ecma_compiled_code_t *byte_code_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 1333:                                                                           mapped_arguments_p->u.byte_code);
        -: 1334:
    #####: 1335:      ecma_bytecode_deref (byte_code_p);
        -: 1336:    }
        -: 1337:  }
        -: 1338:
    #####: 1339:  ecma_value_t *argv_p = (ecma_value_t *) (((uint8_t *) ext_object_p) + object_size);
    #####: 1340:  ecma_unmapped_arguments_t *arguments_p = (ecma_unmapped_arguments_t *) ext_object_p;
    #####: 1341:  uint32_t arguments_number = arguments_p->header.u.cls.u3.arguments_number;
        -: 1342:
    #####: 1343:  for (uint32_t i = 0; i < arguments_number; i++)
        -: 1344:  {
    #####: 1345:    ecma_free_value_if_not_object (argv_p[i]);
        -: 1346:  }
        -: 1347:
    #####: 1348:  uint32_t saved_argument_count = JERRY_MAX (arguments_number,
        -: 1349:                                             arguments_p->header.u.cls.u2.formal_params_number);
        -: 1350:
    #####: 1351:  return object_size + (saved_argument_count * sizeof (ecma_value_t));
        -: 1352:} /* ecma_free_arguments_object */
        -: 1353:
        -: 1354:/**
        -: 1355: * Free specified fast access mode array object.
        -: 1356: */
        -: 1357:static void
        2: 1358:ecma_free_fast_access_array (ecma_object_t *object_p) /**< fast access mode array object to free */
        -: 1359:{
        2: 1360:  JERRY_ASSERT (ecma_op_object_is_fast_array (object_p));
        -: 1361:
        2: 1362:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        2: 1363:  const uint32_t aligned_length = ECMA_FAST_ARRAY_ALIGN_LENGTH (ext_object_p->u.array.length);
        -: 1364:
        2: 1365:  if (object_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 1366:  {
        2: 1367:    ecma_value_t *values_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, object_p->u1.property_list_cp);
        -: 1368:
       18: 1369:    for (uint32_t i = 0; i < aligned_length; i++)
        -: 1370:    {
       16: 1371:      ecma_free_value_if_not_object (values_p[i]);
        -: 1372:    }
        -: 1373:
        2: 1374:    jmem_heap_free_block (values_p, aligned_length * sizeof (ecma_value_t));
        -: 1375:  }
        -: 1376:
        2: 1377:  ecma_dealloc_extended_object (object_p, sizeof (ecma_extended_object_t));
        2: 1378:} /* ecma_free_fast_access_array */
        -: 1379:
        -: 1380:#if JERRY_ESNEXT
        -: 1381:
        -: 1382:/**
        -: 1383: * Free non-objects referenced by inactive generator functions, async functions, etc.
        -: 1384: *
        -: 1385: * @return total object size
        -: 1386: */
        -: 1387:static size_t
    #####: 1388:ecma_gc_free_executable_object (ecma_object_t *object_p) /**< object */
        -: 1389:{
    #####: 1390:  vm_executable_object_t *executable_object_p = (vm_executable_object_t *) object_p;
        -: 1391:
    #####: 1392:  const ecma_compiled_code_t *bytecode_header_p = executable_object_p->shared.bytecode_header_p;
        -: 1393:  size_t size, register_end;
        -: 1394:
    #####: 1395:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -: 1396:  {
    #####: 1397:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
        -: 1398:
    #####: 1399:    register_end = args_p->register_end;
    #####: 1400:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -: 1401:  }
        -: 1402:  else
        -: 1403:  {
    #####: 1404:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
        -: 1405:
    #####: 1406:    register_end = args_p->register_end;
    #####: 1407:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -: 1408:  }
        -: 1409:
    #####: 1410:  size = JERRY_ALIGNUP (sizeof (vm_executable_object_t) + size, sizeof (uintptr_t));
    #####: 1411:  ecma_bytecode_deref ((ecma_compiled_code_t *) bytecode_header_p);
        -: 1412:
    #####: 1413:  uint16_t executable_obj_flags = executable_object_p->extended_object.u.cls.u2.executable_obj_flags;
        -: 1414:
    #####: 1415:  JERRY_ASSERT (!(executable_obj_flags & ECMA_EXECUTABLE_OBJECT_RUNNING));
        -: 1416:
    #####: 1417:  if (executable_obj_flags & ECMA_ASYNC_GENERATOR_CALLED)
        -: 1418:  {
    #####: 1419:    ecma_value_t task = executable_object_p->extended_object.u.cls.u3.head;
        -: 1420:
    #####: 1421:    while (!ECMA_IS_INTERNAL_VALUE_NULL (task))
        -: 1422:    {
        -: 1423:      ecma_async_generator_task_t *task_p;
    #####: 1424:      task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t, task);
        -: 1425:
    #####: 1426:      JERRY_ASSERT (ecma_is_value_object (task_p->promise));
    #####: 1427:      ecma_free_value_if_not_object (task_p->operation_value);
        -: 1428:
    #####: 1429:      task = task_p->next;
    #####: 1430:      jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -: 1431:    }
        -: 1432:  }
        -: 1433:
    #####: 1434:  if (executable_obj_flags & ECMA_EXECUTABLE_OBJECT_COMPLETED)
        -: 1435:  {
    #####: 1436:    return size;
        -: 1437:  }
        -: 1438:
    #####: 1439:  ecma_free_value_if_not_object (executable_object_p->frame_ctx.this_binding);
        -: 1440:
    #####: 1441:  ecma_value_t *register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
    #####: 1442:  ecma_value_t *register_end_p = register_p + register_end;
        -: 1443:
    #####: 1444:  while (register_p < register_end_p)
        -: 1445:  {
    #####: 1446:    ecma_free_value_if_not_object (*register_p++);
        -: 1447:  }
        -: 1448:
    #####: 1449:  if (executable_object_p->frame_ctx.context_depth > 0)
        -: 1450:  {
    #####: 1451:    ecma_value_t *context_end_p = register_p;
        -: 1452:
    #####: 1453:    register_p += executable_object_p->frame_ctx.context_depth;
        -: 1454:
    #####: 1455:    ecma_value_t *context_top_p = register_p;
        -: 1456:
        -: 1457:    do
        -: 1458:    {
    #####: 1459:      context_top_p[-1] &= (uint32_t) ~VM_CONTEXT_HAS_LEX_ENV;
        -: 1460:
    #####: 1461:      if (VM_CONTEXT_IS_VARIABLE_LENGTH (VM_GET_CONTEXT_TYPE (context_top_p[-1])))
        -: 1462:      {
    #####: 1463:        ecma_value_t *last_item_p = context_top_p - VM_GET_CONTEXT_END (context_top_p[-1]);
    #####: 1464:        JERRY_ASSERT (last_item_p >= context_end_p);
    #####: 1465:        context_top_p--;
        -: 1466:
        -: 1467:        do
        -: 1468:        {
    #####: 1469:          ecma_free_value_if_not_object (*(--context_top_p));
        -: 1470:        }
    #####: 1471:        while (context_top_p > last_item_p);
        -: 1472:
    #####: 1473:        continue;
        -: 1474:      }
        -: 1475:
    #####: 1476:      uint32_t offsets = vm_get_context_value_offsets (context_top_p);
        -: 1477:
    #####: 1478:      while (VM_CONTEXT_HAS_NEXT_OFFSET (offsets))
        -: 1479:      {
    #####: 1480:        int32_t offset = VM_CONTEXT_GET_NEXT_OFFSET (offsets);
        -: 1481:
    #####: 1482:        if (ecma_is_value_object (context_top_p[offset]))
        -: 1483:        {
    #####: 1484:          context_top_p[offset] = ECMA_VALUE_UNDEFINED;
        -: 1485:        }
        -: 1486:
    #####: 1487:        offsets >>= VM_CONTEXT_OFFSET_SHIFT;
        -: 1488:      }
        -: 1489:
    #####: 1490:      context_top_p = vm_stack_context_abort (&executable_object_p->frame_ctx, context_top_p);
        -: 1491:    }
    #####: 1492:    while (context_top_p > context_end_p);
        -: 1493:  }
        -: 1494:
    #####: 1495:  register_end_p = executable_object_p->frame_ctx.stack_top_p;
        -: 1496:
    #####: 1497:  while (register_p < register_end_p)
        -: 1498:  {
    #####: 1499:    ecma_free_value_if_not_object (*register_p++);
        -: 1500:  }
        -: 1501:
    #####: 1502:  return size;
        -: 1503:} /* ecma_gc_free_executable_object */
        -: 1504:
        -: 1505:#endif /* JERRY_ESNEXT */
        -: 1506:
        -: 1507:JERRY_STATIC_ASSERT (!ECMA_PROPERTY_IS_RAW (ECMA_PROPERTY_TYPE_DELETED),
        -: 1508:                     ecma_property_type_deleted_must_not_be_raw_property);
        -: 1509:JERRY_STATIC_ASSERT ((ECMA_PROPERTY_TYPE_DELETED & ECMA_PROPERTY_FLAG_LCACHED) == 0,
        -: 1510:                     ecma_property_type_deleted_must_not_have_lcached_flag);
        -: 1511:JERRY_STATIC_ASSERT (ECMA_GC_FREE_SECOND_PROPERTY == 1,
        -: 1512:                     ecma_gc_free_second_must_be_one);
        -: 1513:
        -: 1514:/**
        -: 1515: * Free property of an object
        -: 1516: */
        -: 1517:void
       22: 1518:ecma_gc_free_property (ecma_object_t *object_p, /**< object */
        -: 1519:                       ecma_property_pair_t *prop_pair_p, /**< property pair */
        -: 1520:                       uint32_t options) /**< option bits including property index */
        -: 1521:{
        -: 1522:  /* Both cannot be deleted. */
       22: 1523:  JERRY_ASSERT (prop_pair_p->header.types[0] != ECMA_PROPERTY_TYPE_DELETED
        -: 1524:                || prop_pair_p->header.types[1] != ECMA_PROPERTY_TYPE_DELETED);
       22: 1525:  JERRY_ASSERT (prop_pair_p->header.types[0] != ECMA_PROPERTY_TYPE_HASHMAP);
        -: 1526:
       22: 1527:  uint32_t index = (options & ECMA_GC_FREE_SECOND_PROPERTY);
       22: 1528:  jmem_cpointer_t name_cp = prop_pair_p->names_cp[index];
       22: 1529:  ecma_property_t *property_p = prop_pair_p->header.types + index;
       22: 1530:  ecma_property_t property = *property_p;
        -: 1531:
        -: 1532:#if JERRY_LCACHE
       22: 1533:  if ((property & ECMA_PROPERTY_FLAG_LCACHED) != 0)
        -: 1534:  {
        6: 1535:    ecma_lcache_invalidate (object_p, name_cp, property_p);
        -: 1536:  }
        -: 1537:#endif /* JERRY_LCACHE */
        -: 1538:
       22: 1539:  if (ECMA_PROPERTY_IS_RAW (property))
        -: 1540:  {
       17: 1541:    if (ECMA_PROPERTY_GET_NAME_TYPE (property) == ECMA_DIRECT_STRING_PTR)
        -: 1542:    {
        8: 1543:      ecma_string_t *prop_name_p = ECMA_GET_NON_NULL_POINTER (ecma_string_t, name_cp);
        8: 1544:      ecma_deref_ecma_string (prop_name_p);
        -: 1545:    }
        -: 1546:
       17: 1547:    if (property & ECMA_PROPERTY_FLAG_DATA)
        -: 1548:    {
       15: 1549:      ecma_free_value_if_not_object (prop_pair_p->values[index].value);
       15: 1550:      return;
        -: 1551:    }
        -: 1552:
        2: 1553:    if (JERRY_UNLIKELY (options & ECMA_GC_FREE_REFERENCES))
        -: 1554:    {
    #####: 1555:      return;
        -: 1556:    }
        -: 1557:
        -: 1558:#if JERRY_CPOINTER_32_BIT
        -: 1559:    ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -: 1560:    getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,
        -: 1561:                                                      prop_pair_p->values[index].getter_setter_pair_cp);
        -: 1562:    jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));
        -: 1563:#endif /* JERRY_CPOINTER_32_BIT */
        2: 1564:    return;
        -: 1565:  }
        -: 1566:
        5: 1567:  if (property == ECMA_PROPERTY_TYPE_DELETED)
        -: 1568:  {
        5: 1569:    return;
        -: 1570:  }
        -: 1571:
    #####: 1572:  ecma_value_t value = prop_pair_p->values[index].value;
        -: 1573:
    #####: 1574:  switch (name_cp)
        -: 1575:  {
        -: 1576:#if JERRY_ESNEXT
    #####: 1577:    case LIT_INTERNAL_MAGIC_STRING_ENVIRONMENT_RECORD:
        -: 1578:    {
        -: 1579:      ecma_environment_record_t *environment_record_p;
    #####: 1580:      environment_record_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_environment_record_t, value);
    #####: 1581:      jmem_heap_free_block (environment_record_p, sizeof (ecma_environment_record_t));
    #####: 1582:      break;
        -: 1583:    }
    #####: 1584:    case LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED:
        -: 1585:    {
        -: 1586:      ecma_value_t *compact_collection_p;
    #####: 1587:      compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
    #####: 1588:      ecma_compact_collection_free (compact_collection_p);
    #####: 1589:      break;
        -: 1590:    }
        -: 1591:#endif /* JERRY_ESNEXT */
        -: 1592:#if JERRY_BUILTIN_WEAKREF || JERRY_BUILTIN_CONTAINER
    #####: 1593:    case LIT_INTERNAL_MAGIC_STRING_WEAK_REFS:
        -: 1594:    {
    #####: 1595:      ecma_collection_t *refs_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t, value);
    #####: 1596:      for (uint32_t j = 0; j < refs_p->item_count; j++)
        -: 1597:      {
    #####: 1598:        const ecma_value_t reference_value = refs_p->buffer_p[j];
        -: 1599:
    #####: 1600:        if (!ecma_is_value_empty (reference_value))
        -: 1601:        {
    #####: 1602:          ecma_object_t *obj_p = ecma_get_object_from_value (reference_value);
        -: 1603:
    #####: 1604:          if (ecma_object_class_is (obj_p, ECMA_OBJECT_CLASS_WEAKREF))
        -: 1605:          {
    #####: 1606:            ecma_extended_object_t *ext_obj_p = (ecma_extended_object_t *) obj_p;
    #####: 1607:            ext_obj_p->u.cls.u3.target = ECMA_VALUE_UNDEFINED;
    #####: 1608:            continue;
        -: 1609:          }
    #####: 1610:          ecma_op_container_remove_weak_entry (obj_p, ecma_make_object_value (object_p));
        -: 1611:        }
        -: 1612:      }
        -: 1613:
    #####: 1614:      ecma_collection_destroy (refs_p);
    #####: 1615:      break;
        -: 1616:    }
        -: 1617:#endif /* JERRY_BUILTIN_CONTAINER */
    #####: 1618:    default:
        -: 1619:    {
    #####: 1620:      JERRY_ASSERT (name_cp == LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER
        -: 1621:                    || name_cp == LIT_INTERNAL_MAGIC_STRING_NATIVE_POINTER_WITH_REFERENCES);
    #####: 1622:      ecma_gc_free_native_pointer (property, value);
    #####: 1623:      break;
        -: 1624:    }
        -: 1625:  }
        -: 1626:} /* ecma_gc_free_property */
        -: 1627:
        -: 1628:/**
        -: 1629: * Free properties of an object
        -: 1630: */
        -: 1631:void
       22: 1632:ecma_gc_free_properties (ecma_object_t *object_p, /**< object */
        -: 1633:                         uint32_t options) /**< option bits */
        -: 1634:{
       22: 1635:  jmem_cpointer_t prop_iter_cp = object_p->u1.property_list_cp;
        -: 1636:
        -: 1637:#if JERRY_PROPERTY_HASHMAP
       22: 1638:  if (prop_iter_cp != JMEM_CP_NULL)
        -: 1639:  {
        7: 1640:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t,
        -: 1641:                                                                     prop_iter_cp);
        7: 1642:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 1643:    {
    #####: 1644:      ecma_property_hashmap_free (object_p);
    #####: 1645:      prop_iter_cp = object_p->u1.property_list_cp;
        -: 1646:    }
        -: 1647:  }
        -: 1648:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 1649:
       55: 1650:  while (prop_iter_cp != JMEM_CP_NULL)
        -: 1651:  {
       11: 1652:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
       11: 1653:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 1654:
       11: 1655:    ecma_property_pair_t *prop_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 1656:
       33: 1657:    for (uint32_t i = 0; i < ECMA_PROPERTY_PAIR_ITEM_COUNT; i++)
        -: 1658:    {
       22: 1659:      ecma_gc_free_property (object_p, prop_pair_p, i | options);
        -: 1660:    }
        -: 1661:
       11: 1662:    prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1663:
       11: 1664:    ecma_dealloc_property_pair (prop_pair_p);
        -: 1665:  }
       22: 1666:} /* ecma_gc_free_properties */
        -: 1667:
        -: 1668:/**
        -: 1669: * Free specified object.
        -: 1670: */
        -: 1671:static void
       25: 1672:ecma_gc_free_object (ecma_object_t *object_p) /**< object to free */
        -: 1673:{
       50: 1674:  JERRY_ASSERT (object_p != NULL && !ecma_gc_is_object_visited (object_p));
        -: 1675:
       25: 1676:  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_objects_number) > 0);
       25: 1677:  JERRY_CONTEXT (ecma_gc_objects_number)--;
        -: 1678:
       25: 1679:  if (ecma_is_lexical_environment (object_p))
        -: 1680:  {
        -: 1681:#if JERRY_MODULE_SYSTEM
        2: 1682:    if (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_CLASS
    #####: 1683:        && (object_p->type_flags_refs & ECMA_OBJECT_FLAG_LEXICAL_ENV_HAS_DATA))
        -: 1684:    {
    #####: 1685:      ecma_gc_free_properties (object_p, ECMA_GC_FREE_REFERENCES);
    #####: 1686:      ecma_dealloc_extended_object (object_p, sizeof (ecma_lexical_environment_class_t));
    #####: 1687:      return;
        -: 1688:    }
        -: 1689:#endif /* JERRY_MODULE_SYSTEM */
        -: 1690:
        2: 1691:    if (ecma_get_lex_env_type (object_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 1692:    {
        1: 1693:      ecma_gc_free_properties (object_p, ECMA_GC_FREE_NO_OPTIONS);
        -: 1694:    }
        -: 1695:
        2: 1696:    ecma_dealloc_object (object_p);
        2: 1697:    return;
        -: 1698:  }
        -: 1699:
       23: 1700:  ecma_object_type_t object_type = ecma_get_object_type (object_p);
        -: 1701:
       23: 1702:  size_t ext_object_size = sizeof (ecma_extended_object_t);
        -: 1703:
       23: 1704:  switch (object_type)
        -: 1705:  {
        1: 1706:    case ECMA_OBJECT_TYPE_GENERAL:
        -: 1707:    {
        1: 1708:      ecma_gc_free_properties (object_p, ECMA_GC_FREE_NO_OPTIONS);
        1: 1709:      ecma_dealloc_object (object_p);
        1: 1710:      return;
        -: 1711:    }
        3: 1712:    case ECMA_OBJECT_TYPE_BUILT_IN_GENERAL:
        -: 1713:    {
        3: 1714:      if (((ecma_extended_object_t *) object_p)->u.built_in.id == ECMA_BUILTIN_ID_GLOBAL)
        -: 1715:      {
        1: 1716:        ext_object_size = sizeof (ecma_global_object_t);
        1: 1717:        break;
        -: 1718:      }
        -: 1719:
        2: 1720:      uint8_t bitset_size = ((ecma_extended_object_t *) object_p)->u.built_in.u.length_and_bitset_size;
        2: 1721:      ext_object_size += sizeof (uint64_t) * (bitset_size >> ECMA_BUILT_IN_BITSET_SHIFT);
        2: 1722:      break;
        -: 1723:    }
    #####: 1724:    case ECMA_OBJECT_TYPE_BUILT_IN_CLASS:
        -: 1725:    {
    #####: 1726:      ext_object_size = sizeof (ecma_extended_built_in_object_t);
    #####: 1727:      uint8_t bitset_size = ((ecma_extended_built_in_object_t *) object_p)->built_in.u.length_and_bitset_size;
    #####: 1728:      ext_object_size += sizeof (uint64_t) * (bitset_size >> ECMA_BUILT_IN_BITSET_SHIFT);
        -: 1729:      /* FALLTHRU */
        -: 1730:    }
        1: 1731:    case ECMA_OBJECT_TYPE_CLASS:
        -: 1732:    {
        1: 1733:      ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -: 1734:
        1: 1735:      switch (ext_object_p->u.cls.type)
        -: 1736:      {
    #####: 1737:        case ECMA_OBJECT_CLASS_STRING:
        -: 1738:        case ECMA_OBJECT_CLASS_NUMBER:
        -: 1739:#if JERRY_ESNEXT
        -: 1740:        case ECMA_OBJECT_CLASS_SYMBOL:
        -: 1741:#endif /* JERRY_ESNEXT */
        -: 1742:#if JERRY_BUILTIN_BIGINT
        -: 1743:        case ECMA_OBJECT_CLASS_BIGINT:
        -: 1744:#endif /* JERRY_BUILTIN_BIGINT */
        -: 1745:        {
    #####: 1746:          ecma_free_value (ext_object_p->u.cls.u3.value);
    #####: 1747:          break;
        -: 1748:        }
    #####: 1749:        case ECMA_OBJECT_CLASS_ARGUMENTS:
        -: 1750:        {
    #####: 1751:          ext_object_size = ecma_free_arguments_object (ext_object_p);
    #####: 1752:          break;
        -: 1753:        }
        -: 1754:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 1755:        case ECMA_OBJECT_CLASS_TYPEDARRAY:
        -: 1756:        {
    #####: 1757:          if (ext_object_p->u.cls.u2.typedarray_flags & ECMA_TYPEDARRAY_IS_EXTENDED)
        -: 1758:          {
    #####: 1759:            ext_object_size = sizeof (ecma_extended_typedarray_object_t);
        -: 1760:          }
    #####: 1761:          break;
        -: 1762:        }
        -: 1763:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1764:#if JERRY_MODULE_SYSTEM
    #####: 1765:        case ECMA_OBJECT_CLASS_MODULE_NAMESPACE:
        -: 1766:        {
    #####: 1767:          ecma_gc_free_properties (object_p, ECMA_GC_FREE_REFERENCES);
    #####: 1768:          ecma_dealloc_extended_object (object_p, sizeof (ecma_extended_object_t));
    #####: 1769:          return;
        -: 1770:        }
        -: 1771:#endif /* JERRY_MODULE_SYSTEM */
        -: 1772:#if JERRY_PARSER
        1: 1773:        case ECMA_OBJECT_CLASS_SCRIPT:
        -: 1774:        {
        -: 1775:          ecma_compiled_code_t *compiled_code_p;
        1: 1776:          compiled_code_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 1777:                                                             ext_object_p->u.cls.u3.value);
        -: 1778:
        1: 1779:          ecma_bytecode_deref (compiled_code_p);
        1: 1780:          break;
        -: 1781:        }
        -: 1782:#endif /* JERRY_PARSER */
        -: 1783:#if JERRY_BUILTIN_DATE
    #####: 1784:        case ECMA_OBJECT_CLASS_DATE:
        -: 1785:        {
        -: 1786:#if JERRY_ESNEXT
    #####: 1787:          ext_object_size = sizeof (ecma_date_object_t);
        -: 1788:#else /* !JERRY_ESNEXT */
    #####: 1789:          ecma_number_t *num_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_number_t, ext_object_p->u.cls.u3.date);
    #####: 1790:          ecma_dealloc_number (num_p);
        -: 1791:#endif /* JERRY_ESNEXT */
    #####: 1792:          break;
        -: 1793:        }
        -: 1794:#endif /* JERRY_BUILTIN_DATE */
        -: 1795:#if JERRY_BUILTIN_REGEXP
    #####: 1796:        case ECMA_OBJECT_CLASS_REGEXP:
        -: 1797:        {
    #####: 1798:          ecma_compiled_code_t *bytecode_p = ECMA_GET_INTERNAL_VALUE_ANY_POINTER (ecma_compiled_code_t,
        -: 1799:                                                                                  ext_object_p->u.cls.u3.value);
        -: 1800:
    #####: 1801:          ecma_bytecode_deref (bytecode_p);
        -: 1802:
    #####: 1803:          break;
        -: 1804:        }
        -: 1805:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1806:#if JERRY_ESNEXT
    #####: 1807:        case ECMA_OBJECT_CLASS_STRING_ITERATOR:
        -: 1808:        {
    #####: 1809:          ecma_value_t iterated_value = ext_object_p->u.cls.u3.iterated_value;
        -: 1810:
    #####: 1811:          if (!ecma_is_value_empty (iterated_value))
        -: 1812:          {
    #####: 1813:            ecma_deref_ecma_string (ecma_get_string_from_value (iterated_value));
        -: 1814:          }
        -: 1815:
    #####: 1816:          break;
        -: 1817:        }
        -: 1818:#if JERRY_BUILTIN_REGEXP
    #####: 1819:        case ECMA_OBJECT_CLASS_REGEXP_STRING_ITERATOR:
        -: 1820:        {
    #####: 1821:          ecma_regexp_string_iterator_t *regexp_string_iterator_obj = (ecma_regexp_string_iterator_t *) object_p;
    #####: 1822:          ecma_value_t iterated_string = regexp_string_iterator_obj->iterated_string;
        -: 1823:
    #####: 1824:          if (!ecma_is_value_empty (iterated_string))
        -: 1825:          {
    #####: 1826:            ecma_deref_ecma_string (ecma_get_string_from_value (iterated_string));
        -: 1827:          }
        -: 1828:
    #####: 1829:          ext_object_size = sizeof (ecma_regexp_string_iterator_t);
    #####: 1830:          break;
        -: 1831:        }
        -: 1832:#endif /* JERRY_BUILTIN_REGEXP */
        -: 1833:#endif /* JERRY_ESNEXT */
        -: 1834:#if JERRY_BUILTIN_TYPEDARRAY
    #####: 1835:        case ECMA_OBJECT_CLASS_ARRAY_BUFFER:
        -: 1836:#if JERRY_BUILTIN_SHAREDARRAYBUFFER
        -: 1837:        case ECMA_OBJECT_CLASS_SHARED_ARRAY_BUFFER:
        -: 1838:#endif /* JERRY_BUILTIN_SHAREDARRAYBUFFER */
        -: 1839:        {
    #####: 1840:          uint32_t arraybuffer_length = ext_object_p->u.cls.u3.length;
        -: 1841:
    #####: 1842:          if (ECMA_ARRAYBUFFER_HAS_EXTERNAL_MEMORY (ext_object_p))
        -: 1843:          {
    #####: 1844:            ext_object_size = sizeof (ecma_arraybuffer_external_info);
        -: 1845:
        -: 1846:            /* Call external free callback if any. */
    #####: 1847:            ecma_arraybuffer_external_info *array_p = (ecma_arraybuffer_external_info *) ext_object_p;
        -: 1848:
    #####: 1849:            if (array_p->free_cb != NULL)
        -: 1850:            {
    #####: 1851:              array_p->free_cb (array_p->buffer_p);
        -: 1852:            }
        -: 1853:          }
        -: 1854:          else
        -: 1855:          {
    #####: 1856:            ext_object_size += arraybuffer_length;
        -: 1857:          }
        -: 1858:
    #####: 1859:          break;
        -: 1860:        }
        -: 1861:#endif /* JERRY_BUILTIN_TYPEDARRAY */
        -: 1862:#if JERRY_BUILTIN_WEAKREF
    #####: 1863:        case ECMA_OBJECT_CLASS_WEAKREF:
        -: 1864:        {
    #####: 1865:          ecma_value_t target = ext_object_p->u.cls.u3.target;
        -: 1866:
    #####: 1867:          if (!ecma_is_value_undefined (target))
        -: 1868:          {
    #####: 1869:            ecma_op_object_unref_weak (ecma_get_object_from_value (target), ecma_make_object_value (object_p));
        -: 1870:          }
    #####: 1871:          break;
        -: 1872:        }
        -: 1873:#endif /* JERRY_BUILTIN_WEAKREF */
        -: 1874:#if JERRY_BUILTIN_CONTAINER
    #####: 1875:        case ECMA_OBJECT_CLASS_CONTAINER:
        -: 1876:        {
    #####: 1877:          ecma_extended_object_t *map_object_p = (ecma_extended_object_t *) object_p;
    #####: 1878:          ecma_collection_t *container_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_collection_t,
        -: 1879:                                                                            map_object_p->u.cls.u3.value);
    #####: 1880:          ecma_op_container_free_entries (object_p);
    #####: 1881:          ecma_collection_destroy (container_p);
    #####: 1882:          break;
        -: 1883:        }
        -: 1884:#endif /* JERRY_BUILTIN_CONTAINER */
        -: 1885:#if JERRY_BUILTIN_DATAVIEW
    #####: 1886:        case ECMA_OBJECT_CLASS_DATAVIEW:
        -: 1887:        {
    #####: 1888:          ext_object_size = sizeof (ecma_dataview_object_t);
    #####: 1889:          break;
        -: 1890:        }
        -: 1891:#endif /* JERRY_BUILTIN_DATAVIEW */
        -: 1892:#if JERRY_ESNEXT
    #####: 1893:        case ECMA_OBJECT_CLASS_GENERATOR:
        -: 1894:        case ECMA_OBJECT_CLASS_ASYNC_GENERATOR:
        -: 1895:        {
    #####: 1896:          ext_object_size = ecma_gc_free_executable_object (object_p);
    #####: 1897:          break;
        -: 1898:        }
    #####: 1899:        case ECMA_OBJECT_CLASS_PROMISE:
        -: 1900:        {
    #####: 1901:          ecma_free_value_if_not_object (ext_object_p->u.cls.u3.value);
        -: 1902:
        -: 1903:          /* Reactions only contains objects. */
    #####: 1904:          ecma_collection_destroy (((ecma_promise_object_t *) object_p)->reactions);
        -: 1905:
    #####: 1906:          ext_object_size = sizeof (ecma_promise_object_t);
    #####: 1907:          break;
        -: 1908:        }
    #####: 1909:        case ECMA_OBJECT_CLASS_PROMISE_CAPABILITY:
        -: 1910:        {
    #####: 1911:          ext_object_size = sizeof (ecma_promise_capabality_t);
    #####: 1912:          break;
        -: 1913:        }
        -: 1914:#endif /* JERRY_ESNEXT */
        -: 1915:#if JERRY_MODULE_SYSTEM
    #####: 1916:        case ECMA_OBJECT_CLASS_MODULE:
        -: 1917:        {
    #####: 1918:          ecma_module_release_module ((ecma_module_t *) ext_object_p);
    #####: 1919:          ext_object_size = sizeof (ecma_module_t);
    #####: 1920:          break;
        -: 1921:        }
        -: 1922:#endif /* JERRY_MODULE_SYSTEM */
    #####: 1923:        default:
        -: 1924:        {
        -: 1925:          /* The ECMA_OBJECT_CLASS__MAX type represents an uninitialized class. */
    #####: 1926:          JERRY_ASSERT (ext_object_p->u.cls.type <= ECMA_OBJECT_CLASS__MAX);
    #####: 1927:          break;
        -: 1928:        }
        -: 1929:      }
        -: 1930:
        1: 1931:      break;
        -: 1932:    }
        1: 1933:    case ECMA_OBJECT_TYPE_BUILT_IN_ARRAY:
        -: 1934:    {
        1: 1935:      ext_object_size = sizeof (ecma_extended_built_in_object_t);
        1: 1936:      uint8_t bitset_size = ((ecma_extended_built_in_object_t *) object_p)->built_in.u.length_and_bitset_size;
        1: 1937:      ext_object_size += sizeof (uint64_t) * (bitset_size >> ECMA_BUILT_IN_BITSET_SHIFT);
        -: 1938:      /* FALLTHRU */
        -: 1939:    }
        3: 1940:    case ECMA_OBJECT_TYPE_ARRAY:
        -: 1941:    {
        3: 1942:      if (ecma_op_array_is_fast_array ((ecma_extended_object_t *) object_p))
        -: 1943:      {
        2: 1944:        ecma_free_fast_access_array (object_p);
        2: 1945:        return;
        -: 1946:      }
        1: 1947:      break;
        -: 1948:    }
        -: 1949:#if JERRY_BUILTIN_PROXY
    #####: 1950:    case ECMA_OBJECT_TYPE_PROXY:
        -: 1951:    {
    #####: 1952:      ext_object_size = sizeof (ecma_proxy_object_t);
    #####: 1953:      break;
        -: 1954:    }
        -: 1955:#endif /* JERRY_BUILTIN_PROXY */
        5: 1956:    case ECMA_OBJECT_TYPE_FUNCTION:
        -: 1957:    {
        -: 1958:      /* Function with byte-code (not a built-in function). */
        5: 1959:      ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) object_p;
        -: 1960:
        -: 1961:#if JERRY_SNAPSHOT_EXEC
    #####: 1962:      if (ext_func_p->u.function.bytecode_cp != ECMA_NULL_POINTER)
        -: 1963:      {
        -: 1964:#endif /* JERRY_SNAPSHOT_EXEC */
        5: 1965:        ecma_compiled_code_t *byte_code_p = (ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -: 1966:                                                                              ext_func_p->u.function.bytecode_cp));
        -: 1967:
        -: 1968:#if JERRY_ESNEXT
        5: 1969:        if (CBC_FUNCTION_IS_ARROW (byte_code_p->status_flags))
        -: 1970:        {
        1: 1971:          ecma_free_value_if_not_object (((ecma_arrow_function_t *) object_p)->this_binding);
        1: 1972:          ecma_free_value_if_not_object (((ecma_arrow_function_t *) object_p)->new_target);
        1: 1973:          ext_object_size = sizeof (ecma_arrow_function_t);
        -: 1974:        }
        -: 1975:#endif /* JERRY_ESNEXT */
        -: 1976:
        5: 1977:        ecma_bytecode_deref (byte_code_p);
        -: 1978:#if JERRY_SNAPSHOT_EXEC
        -: 1979:      }
        -: 1980:      else
        -: 1981:      {
        -: 1982:        ext_object_size = sizeof (ecma_static_function_t);
        -: 1983:      }
        -: 1984:#endif /* JERRY_SNAPSHOT_EXEC */
        5: 1985:      break;
        -: 1986:    }
        5: 1987:    case ECMA_OBJECT_TYPE_BUILT_IN_FUNCTION:
        -: 1988:    {
        5: 1989:      ecma_extended_object_t *extended_func_p = (ecma_extended_object_t *) object_p;
        -: 1990:
        5: 1991:      if (!ecma_builtin_function_is_routine (object_p))
        -: 1992:      {
        3: 1993:        uint8_t bitset_size = extended_func_p->u.built_in.u.length_and_bitset_size;
        3: 1994:        ext_object_size += sizeof (uint64_t) * (bitset_size >> ECMA_BUILT_IN_BITSET_SHIFT);
        3: 1995:        break;
        -: 1996:      }
        -: 1997:
        -: 1998:#if JERRY_ESNEXT
        2: 1999:      if (extended_func_p->u.built_in.id != ECMA_BUILTIN_ID_HANDLER)
        -: 2000:      {
        2: 2001:        break;
        -: 2002:      }
        -: 2003:
    #####: 2004:      switch (extended_func_p->u.built_in.routine_id)
        -: 2005:      {
    #####: 2006:        case ECMA_NATIVE_HANDLER_PROMISE_RESOLVE:
        -: 2007:        case ECMA_NATIVE_HANDLER_PROMISE_REJECT:
        -: 2008:        {
    #####: 2009:          ext_object_size = sizeof (ecma_promise_resolver_t);
    #####: 2010:          break;
        -: 2011:        }
    #####: 2012:        case ECMA_NATIVE_HANDLER_PROMISE_THEN_FINALLY:
        -: 2013:        case ECMA_NATIVE_HANDLER_PROMISE_CATCH_FINALLY:
        -: 2014:        {
    #####: 2015:          ext_object_size = sizeof (ecma_promise_finally_function_t);
    #####: 2016:          break;
        -: 2017:        }
    #####: 2018:        case ECMA_NATIVE_HANDLER_PROMISE_CAPABILITY_EXECUTOR:
        -: 2019:        {
    #####: 2020:          ext_object_size = sizeof (ecma_promise_capability_executor_t);
    #####: 2021:          break;
        -: 2022:        }
    #####: 2023:        case ECMA_NATIVE_HANDLER_PROMISE_ALL_HELPER:
        -: 2024:        {
    #####: 2025:          ext_object_size = sizeof (ecma_promise_all_executor_t);
    #####: 2026:          break;
        -: 2027:        }
        -: 2028:#if JERRY_BUILTIN_PROXY
    #####: 2029:        case ECMA_NATIVE_HANDLER_PROXY_REVOKE:
        -: 2030:        {
    #####: 2031:          ext_object_size = sizeof (ecma_revocable_proxy_object_t);
    #####: 2032:          break;
        -: 2033:        }
        -: 2034:#endif /* JERRY_BUILTIN_PROXY */
    #####: 2035:        case ECMA_NATIVE_HANDLER_VALUE_THUNK:
        -: 2036:        case ECMA_NATIVE_HANDLER_VALUE_THROWER:
        -: 2037:        {
    #####: 2038:          ecma_free_value_if_not_object (((ecma_promise_value_thunk_t *) object_p)->value);
    #####: 2039:          ext_object_size = sizeof (ecma_promise_value_thunk_t);
    #####: 2040:          break;
        -: 2041:        }
    #####: 2042:        default:
        -: 2043:        {
    #####: 2044:          JERRY_UNREACHABLE ();
        -: 2045:        }
        -: 2046:      }
        -: 2047:#endif /* JERRY_ESNEXT */
    #####: 2048:      break;
        -: 2049:    }
    #####: 2050:    case ECMA_OBJECT_TYPE_BOUND_FUNCTION:
        -: 2051:    {
    #####: 2052:      ext_object_size = sizeof (ecma_bound_function_t);
    #####: 2053:      ecma_bound_function_t *bound_func_p = (ecma_bound_function_t *) object_p;
        -: 2054:
    #####: 2055:      ecma_value_t args_len_or_this = bound_func_p->header.u.bound_function.args_len_or_this;
        -: 2056:
        -: 2057:#if JERRY_ESNEXT
    #####: 2058:      ecma_free_value (bound_func_p->target_length);
        -: 2059:#endif /* JERRY_ESNEXT */
        -: 2060:
    #####: 2061:      if (!ecma_is_value_integer_number (args_len_or_this))
        -: 2062:      {
    #####: 2063:        ecma_free_value_if_not_object (args_len_or_this);
    #####: 2064:        break;
        -: 2065:      }
        -: 2066:
    #####: 2067:      ecma_integer_value_t args_length = ecma_get_integer_from_value (args_len_or_this);
    #####: 2068:      ecma_value_t *args_p = (ecma_value_t *) (bound_func_p + 1);
        -: 2069:
    #####: 2070:      for (ecma_integer_value_t i = 0; i < args_length; i++)
        -: 2071:      {
    #####: 2072:        ecma_free_value_if_not_object (args_p[i]);
        -: 2073:      }
        -: 2074:
    #####: 2075:      size_t args_size = ((size_t) args_length) * sizeof (ecma_value_t);
    #####: 2076:      ext_object_size += args_size;
    #####: 2077:      break;
        -: 2078:    }
        -: 2079:#if JERRY_ESNEXT
    #####: 2080:    case ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION:
        -: 2081:    {
    #####: 2082:      ecma_script_deref (((ecma_extended_object_t *) object_p)->u.constructor_function.script_value);
    #####: 2083:      break;
        -: 2084:    }
        -: 2085:#endif /* JERRY_ESNEXT */
        5: 2086:    case ECMA_OBJECT_TYPE_NATIVE_FUNCTION:
        -: 2087:    {
        5: 2088:      ext_object_size = sizeof (ecma_native_function_t);
        5: 2089:      break;
        -: 2090:    }
    #####: 2091:    default:
        -: 2092:    {
    #####: 2093:      JERRY_UNREACHABLE ();
        -: 2094:    }
        -: 2095:  }
        -: 2096:
       20: 2097:  ecma_gc_free_properties (object_p, ECMA_GC_FREE_NO_OPTIONS);
       20: 2098:  ecma_dealloc_extended_object (object_p, ext_object_size);
        -: 2099:} /* ecma_gc_free_object */
        -: 2100:
        -: 2101:/**
        -: 2102: * Run garbage collection, freeing objects that are no longer referenced.
        -: 2103: */
        -: 2104:void
        1: 2105:ecma_gc_run (void)
        -: 2106:{
        -: 2107:#if (JERRY_GC_MARK_LIMIT != 0)
        1: 2108:  JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) == JERRY_GC_MARK_LIMIT);
        -: 2109:#endif /* (JERRY_GC_MARK_LIMIT != 0) */
        -: 2110:
        1: 2111:  JERRY_CONTEXT (ecma_gc_new_objects) = 0;
        -: 2112:
        1: 2113:  ecma_object_t black_list_head;
        1: 2114:  black_list_head.gc_next_cp = JMEM_CP_NULL;
        1: 2115:  ecma_object_t *black_end_p = &black_list_head;
        -: 2116:
        1: 2117:  ecma_object_t white_gray_list_head;
        1: 2118:  white_gray_list_head.gc_next_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 2119:
        1: 2120:  ecma_object_t *obj_prev_p = &white_gray_list_head;
        1: 2121:  jmem_cpointer_t obj_iter_cp = obj_prev_p->gc_next_cp;
        -: 2122:  ecma_object_t *obj_iter_p;
        -: 2123:
        -: 2124:  /* Move root objects (i.e. they have global or stack references) to the black list. */
       27: 2125:  while (obj_iter_cp != JMEM_CP_NULL)
        -: 2126:  {
       25: 2127:    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);
       25: 2128:    const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;
        -: 2129:
       25: 2130:    JERRY_ASSERT (obj_prev_p == NULL
        -: 2131:                  || ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_prev_p->gc_next_cp) == obj_iter_p);
        -: 2132:
       25: 2133:    if (obj_iter_p->type_flags_refs >= ECMA_OBJECT_REF_ONE)
        -: 2134:    {
        -: 2135:      /* Moving the object to list of marked objects. */
    #####: 2136:      obj_prev_p->gc_next_cp = obj_next_cp;
        -: 2137:
    #####: 2138:      black_end_p->gc_next_cp = obj_iter_cp;
    #####: 2139:      black_end_p = obj_iter_p;
        -: 2140:    }
        -: 2141:    else
        -: 2142:    {
       25: 2143:      obj_iter_p->type_flags_refs |= ECMA_OBJECT_NON_VISITED;
       25: 2144:      obj_prev_p = obj_iter_p;
        -: 2145:    }
        -: 2146:
       25: 2147:    obj_iter_cp = obj_next_cp;
        -: 2148:  }
        -: 2149:
        1: 2150:  black_end_p->gc_next_cp = JMEM_CP_NULL;
        -: 2151:
        -: 2152:  /* Mark root objects. */
        1: 2153:  obj_iter_cp = black_list_head.gc_next_cp;
        2: 2154:  while (obj_iter_cp != JMEM_CP_NULL)
        -: 2155:  {
    #####: 2156:    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);
    #####: 2157:    ecma_gc_mark (obj_iter_p);
    #####: 2158:    obj_iter_cp = obj_iter_p->gc_next_cp;
        -: 2159:  }
        -: 2160:
        -: 2161:  /* Mark non-root objects. */
        -: 2162:  bool marked_anything_during_current_iteration;
        -: 2163:
        -: 2164:  do
        -: 2165:  {
        -: 2166:#if (JERRY_GC_MARK_LIMIT != 0)
        1: 2167:    JERRY_ASSERT (JERRY_CONTEXT (ecma_gc_mark_recursion_limit) == JERRY_GC_MARK_LIMIT);
        -: 2168:#endif /* (JERRY_GC_MARK_LIMIT != 0) */
        -: 2169:
        1: 2170:    marked_anything_during_current_iteration = false;
        -: 2171:
        1: 2172:    obj_prev_p = &white_gray_list_head;
        1: 2173:    obj_iter_cp = obj_prev_p->gc_next_cp;
        -: 2174:
       27: 2175:    while (obj_iter_cp != JMEM_CP_NULL)
        -: 2176:    {
       25: 2177:      obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);
       25: 2178:      const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;
        -: 2179:
       25: 2180:      JERRY_ASSERT (obj_prev_p == NULL
        -: 2181:                    || ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_prev_p->gc_next_cp) == obj_iter_p);
        -: 2182:
       25: 2183:      if (ecma_gc_is_object_visited (obj_iter_p))
        -: 2184:      {
        -: 2185:        /* Moving the object to list of marked objects */
    #####: 2186:        obj_prev_p->gc_next_cp = obj_next_cp;
        -: 2187:
    #####: 2188:        black_end_p->gc_next_cp = obj_iter_cp;
    #####: 2189:        black_end_p = obj_iter_p;
        -: 2190:
        -: 2191:#if (JERRY_GC_MARK_LIMIT != 0)
    #####: 2192:        if (obj_iter_p->type_flags_refs >= ECMA_OBJECT_REF_ONE)
        -: 2193:        {
        -: 2194:          /* Set the reference count of non-marked gray object to 0 */
    #####: 2195:          obj_iter_p->type_flags_refs &= (ecma_object_descriptor_t) (ECMA_OBJECT_REF_ONE - 1);
    #####: 2196:          ecma_gc_mark (obj_iter_p);
    #####: 2197:          marked_anything_during_current_iteration = true;
        -: 2198:        }
        -: 2199:#else /* (JERRY_GC_MARK_LIMIT == 0) */
        -: 2200:        marked_anything_during_current_iteration = true;
        -: 2201:#endif /* (JERRY_GC_MARK_LIMIT != 0) */
        -: 2202:      }
        -: 2203:      else
        -: 2204:      {
       25: 2205:        obj_prev_p = obj_iter_p;
        -: 2206:      }
        -: 2207:
       25: 2208:      obj_iter_cp = obj_next_cp;
        -: 2209:    }
        -: 2210:  }
        1: 2211:  while (marked_anything_during_current_iteration);
        -: 2212:
        1: 2213:  black_end_p->gc_next_cp = JMEM_CP_NULL;
        1: 2214:  JERRY_CONTEXT (ecma_gc_objects_cp) = black_list_head.gc_next_cp;
        -: 2215:
        -: 2216:  /* Sweep objects that are currently unmarked. */
        1: 2217:  obj_iter_cp = white_gray_list_head.gc_next_cp;
        -: 2218:
       27: 2219:  while (obj_iter_cp != JMEM_CP_NULL)
        -: 2220:  {
       25: 2221:    obj_iter_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);
       25: 2222:    const jmem_cpointer_t obj_next_cp = obj_iter_p->gc_next_cp;
        -: 2223:
       25: 2224:    JERRY_ASSERT (!ecma_gc_is_object_visited (obj_iter_p));
        -: 2225:
       25: 2226:    ecma_gc_free_object (obj_iter_p);
       25: 2227:    obj_iter_cp = obj_next_cp;
        -: 2228:  }
        -: 2229:
        -: 2230:#if JERRY_BUILTIN_REGEXP
        -: 2231:  /* Free RegExp bytecodes stored in cache */
        1: 2232:  re_cache_gc ();
        -: 2233:#endif /* JERRY_BUILTIN_REGEXP */
        1: 2234:} /* ecma_gc_run */
        -: 2235:
        -: 2236:/**
        -: 2237: * Try to free some memory (depending on memory pressure).
        -: 2238: *
        -: 2239: * When called with JMEM_PRESSURE_FULL, the engine will be terminated with ERR_OUT_OF_MEMORY.
        -: 2240: */
        -: 2241:void
    #####: 2242:ecma_free_unused_memory (jmem_pressure_t pressure) /**< current pressure */
        -: 2243:{
        -: 2244:#if JERRY_DEBUGGER
        -: 2245:  while ((JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED)
        -: 2246:         && JERRY_CONTEXT (debugger_byte_code_free_tail) != ECMA_NULL_POINTER)
        -: 2247:  {
        -: 2248:    /* Wait until all byte code is freed or the connection is aborted. */
        -: 2249:    jerry_debugger_receive (NULL);
        -: 2250:  }
        -: 2251:#endif /* JERRY_DEBUGGER */
        -: 2252:
    #####: 2253:  if (JERRY_LIKELY (pressure == JMEM_PRESSURE_LOW))
        -: 2254:  {
        -: 2255:#if JERRY_PROPERTY_HASHMAP
    #####: 2256:    if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) > ECMA_PROP_HASHMAP_ALLOC_ON)
        -: 2257:    {
    #####: 2258:      --JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);
        -: 2259:    }
    #####: 2260:    JERRY_CONTEXT (status_flags) &= (uint32_t) ~ECMA_STATUS_HIGH_PRESSURE_GC;
        -: 2261:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 2262:    /*
        -: 2263:     * If there is enough newly allocated objects since last GC, probably it is worthwhile to start GC now.
        -: 2264:     * Otherwise, probability to free sufficient space is considered to be low.
        -: 2265:     */
    #####: 2266:    size_t new_objects_fraction = CONFIG_ECMA_GC_NEW_OBJECTS_FRACTION;
        -: 2267:
    #####: 2268:    if (JERRY_CONTEXT (ecma_gc_new_objects) * new_objects_fraction > JERRY_CONTEXT (ecma_gc_objects_number))
        -: 2269:    {
    #####: 2270:      ecma_gc_run ();
        -: 2271:    }
        -: 2272:
    #####: 2273:    return;
        -: 2274:  }
    #####: 2275:  else if (pressure == JMEM_PRESSURE_HIGH)
        -: 2276:  {
        -: 2277:    /* Freeing as much memory as we currently can */
        -: 2278:#if JERRY_PROPERTY_HASHMAP
    #####: 2279:    if (JERRY_CONTEXT (status_flags) & ECMA_STATUS_HIGH_PRESSURE_GC)
        -: 2280:    {
    #####: 2281:      JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) = ECMA_PROP_HASHMAP_ALLOC_MAX;
        -: 2282:    }
    #####: 2283:    else if (JERRY_CONTEXT (ecma_prop_hashmap_alloc_state) < ECMA_PROP_HASHMAP_ALLOC_MAX)
        -: 2284:    {
    #####: 2285:      ++JERRY_CONTEXT (ecma_prop_hashmap_alloc_state);
    #####: 2286:      JERRY_CONTEXT (status_flags) |= ECMA_STATUS_HIGH_PRESSURE_GC;
        -: 2287:    }
        -: 2288:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 2289:
    #####: 2290:    ecma_gc_run ();
        -: 2291:
        -: 2292:#if JERRY_PROPERTY_HASHMAP
        -: 2293:    /* Free hashmaps of remaining objects. */
    #####: 2294:    jmem_cpointer_t obj_iter_cp = JERRY_CONTEXT (ecma_gc_objects_cp);
        -: 2295:
    #####: 2296:    while (obj_iter_cp != JMEM_CP_NULL)
        -: 2297:    {
    #####: 2298:      ecma_object_t *obj_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, obj_iter_cp);
        -: 2299:
    #####: 2300:      if (!ecma_is_lexical_environment (obj_iter_p)
    #####: 2301:          || ecma_get_lex_env_type (obj_iter_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE)
        -: 2302:      {
    #####: 2303:        if (!ecma_is_lexical_environment (obj_iter_p)
    #####: 2304:            && ecma_op_object_is_fast_array (obj_iter_p))
        -: 2305:        {
    #####: 2306:          obj_iter_cp = obj_iter_p->gc_next_cp;
    #####: 2307:          continue;
        -: 2308:        }
        -: 2309:
    #####: 2310:        jmem_cpointer_t prop_iter_cp = obj_iter_p->u1.property_list_cp;
        -: 2311:
    #####: 2312:        if (prop_iter_cp != JMEM_CP_NULL)
        -: 2313:        {
    #####: 2314:          ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
        -: 2315:
    #####: 2316:          if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 2317:          {
    #####: 2318:            ecma_property_hashmap_free (obj_iter_p);
        -: 2319:          }
        -: 2320:        }
        -: 2321:
        -: 2322:      }
        -: 2323:
    #####: 2324:      obj_iter_cp = obj_iter_p->gc_next_cp;
        -: 2325:    }
        -: 2326:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 2327:
    #####: 2328:    jmem_pools_collect_empty ();
    #####: 2329:    return;
        -: 2330:  }
    #####: 2331:  else if (JERRY_UNLIKELY (pressure == JMEM_PRESSURE_FULL))
        -: 2332:  {
    #####: 2333:    jerry_fatal (ERR_OUT_OF_MEMORY);
        -: 2334:  }
        -: 2335:  else
        -: 2336:  {
    #####: 2337:    JERRY_ASSERT (pressure == JMEM_PRESSURE_NONE);
    #####: 2338:    JERRY_UNREACHABLE ();
        -: 2339:  }
        -: 2340:} /* ecma_free_unused_memory */
        -: 2341:
        -: 2342:/**
        -: 2343: * @}
        -: 2344: * @}
        -: 2345: */
