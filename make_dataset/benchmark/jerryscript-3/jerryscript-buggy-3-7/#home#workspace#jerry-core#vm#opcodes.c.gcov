        -:    0:Source:/home/workspace/jerry-core/vm/opcodes.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-array-object.h"
        -:   18:#include "ecma-builtins.h"
        -:   19:#include "ecma-builtin-helpers.h"
        -:   20:#include "ecma-conversion.h"
        -:   21:#include "ecma-exceptions.h"
        -:   22:#include "ecma-function-object.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "ecma-iterator-object.h"
        -:   27:#include "ecma-lex-env.h"
        -:   28:#include "ecma-objects.h"
        -:   29:#include "ecma-promise-object.h"
        -:   30:#include "ecma-proxy-object.h"
        -:   31:#include "jcontext.h"
        -:   32:#include "opcodes.h"
        -:   33:#include "vm-defines.h"
        -:   34:#include "vm-stack.h"
        -:   35:
        -:   36:/** \addtogroup vm Virtual machine
        -:   37: * @{
        -:   38: *
        -:   39: * \addtogroup vm_opcodes Opcodes
        -:   40: * @{
        -:   41: */
        -:   42:
        -:   43:/**
        -:   44: * 'typeof' opcode handler.
        -:   45: *
        -:   46: * See also: ECMA-262 v5, 11.4.3
        -:   47: *
        -:   48: * @return ecma value
        -:   49: *         Returned value must be freed with ecma_free_value
        -:   50: */
        -:   51:ecma_value_t
    #####:   52:opfunc_typeof (ecma_value_t left_value) /**< left value */
        -:   53:{
    #####:   54:  return ecma_make_magic_string_value (ecma_get_typeof_lit_id (left_value));
        -:   55:} /* opfunc_typeof */
        -:   56:
        -:   57:/**
        -:   58: * Update data property for object literals.
        -:   59: */
        -:   60:void
        1:   61:opfunc_set_data_property (ecma_object_t *object_p, /**< object */
        -:   62:                          ecma_string_t *prop_name_p, /**< data property name */
        -:   63:                          ecma_value_t value) /**< new value */
        -:   64:{
        1:   65:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -:   66:
        1:   67:  ecma_property_t *property_p = ecma_find_named_property (object_p, prop_name_p);
        -:   68:  ecma_property_value_t *prop_value_p;
        -:   69:
        1:   70:  if (property_p == NULL)
        -:   71:  {
        1:   72:    prop_value_p = ecma_create_named_data_property (object_p,
        -:   73:                                                    prop_name_p,
        -:   74:                                                    ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:   75:                                                    NULL);
        -:   76:  }
        -:   77:  else
        -:   78:  {
    #####:   79:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:   80:
    #####:   81:    prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:   82:
    #####:   83:    if (!(*property_p & ECMA_PROPERTY_FLAG_DATA))
        -:   84:    {
        -:   85:#if JERRY_CPOINTER_32_BIT
        -:   86:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -:   87:      getter_setter_pair_p = ECMA_GET_NON_NULL_POINTER (ecma_getter_setter_pointers_t,
        -:   88:                                                        ECMA_PROPERTY_VALUE_PTR (property_p)->getter_setter_pair_cp);
        -:   89:      jmem_pools_free (getter_setter_pair_p, sizeof (ecma_getter_setter_pointers_t));
        -:   90:#endif /* JERRY_CPOINTER_32_BIT */
        -:   91:
    #####:   92:      *property_p |= ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE;
    #####:   93:      prop_value_p->value = ecma_copy_value_if_not_object (value);
    #####:   94:      return;
        -:   95:    }
        -:   96:  }
        -:   97:
        1:   98:  ecma_named_data_property_assign_value (object_p, prop_value_p, value);
        -:   99:} /* opfunc_set_data_property */
        -:  100:
        -:  101:/**
        -:  102: * Update getter or setter for object literals.
        -:  103: */
        -:  104:void
        3:  105:opfunc_set_accessor (bool is_getter, /**< is getter accessor */
        -:  106:                     ecma_value_t object, /**< object value */
        -:  107:                     ecma_string_t *accessor_name_p, /**< accessor name */
        -:  108:                     ecma_value_t accessor) /**< accessor value */
        -:  109:{
        3:  110:  ecma_object_t *object_p = ecma_get_object_from_value (object);
        -:  111:
        3:  112:  JERRY_ASSERT (!ecma_op_object_is_fast_array (object_p));
        -:  113:
        3:  114:  ecma_property_t *property_p = ecma_find_named_property (object_p, accessor_name_p);
        3:  115:  ecma_object_t *accessor_p = ecma_get_object_from_value (accessor);
        -:  116:
        3:  117:  ecma_object_t *getter_func_p = NULL;
        3:  118:  ecma_object_t *setter_func_p = NULL;
        -:  119:
        3:  120:  if (is_getter)
        -:  121:  {
        2:  122:    getter_func_p = accessor_p;
        -:  123:  }
        -:  124:  else
        -:  125:  {
        1:  126:    setter_func_p = accessor_p;
        -:  127:  }
        -:  128:
        3:  129:  if (property_p == NULL)
        -:  130:  {
        2:  131:    ecma_create_named_accessor_property (object_p,
        -:  132:                                         accessor_name_p,
        -:  133:                                         getter_func_p,
        -:  134:                                         setter_func_p,
        -:  135:                                         ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE,
        -:  136:                                         NULL);
        -:  137:  }
        -:  138:  else
        -:  139:  {
        1:  140:    JERRY_ASSERT (ECMA_PROPERTY_IS_RAW (*property_p));
        -:  141:
        1:  142:    ecma_property_value_t *prop_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
        -:  143:
        1:  144:    if (*property_p & ECMA_PROPERTY_FLAG_DATA)
        -:  145:    {
        -:  146:#if JERRY_CPOINTER_32_BIT
        -:  147:      ecma_getter_setter_pointers_t *getter_setter_pair_p;
        -:  148:      getter_setter_pair_p = jmem_pools_alloc (sizeof (ecma_getter_setter_pointers_t));
        -:  149:#endif /* JERRY_CPOINTER_32_BIT */
        -:  150:
    #####:  151:      ecma_free_value_if_not_object (prop_value_p->value);
    #####:  152:      *property_p = (uint8_t) (*property_p & ~(ECMA_PROPERTY_FLAG_DATA | ECMA_PROPERTY_FLAG_WRITABLE));
        -:  153:
        -:  154:#if JERRY_CPOINTER_32_BIT
        -:  155:      ECMA_SET_POINTER (getter_setter_pair_p->getter_cp, getter_func_p);
        -:  156:      ECMA_SET_POINTER (getter_setter_pair_p->setter_cp, setter_func_p);
        -:  157:      ECMA_SET_NON_NULL_POINTER (prop_value_p->getter_setter_pair_cp, getter_setter_pair_p);
        -:  158:#else /* !JERRY_CPOINTER_32_BIT */
    #####:  159:      ECMA_SET_POINTER (prop_value_p->getter_setter_pair.getter_cp, getter_func_p);
    #####:  160:      ECMA_SET_POINTER (prop_value_p->getter_setter_pair.setter_cp, setter_func_p);
        -:  161:#endif /* JERRY_CPOINTER_32_BIT */
    #####:  162:      return;
        -:  163:    }
        -:  164:
        1:  165:    if (is_getter)
        -:  166:    {
    #####:  167:      ecma_set_named_accessor_property_getter (object_p, prop_value_p, accessor_p);
        -:  168:    }
        -:  169:    else
        -:  170:    {
        1:  171:      ecma_set_named_accessor_property_setter (object_p, prop_value_p, accessor_p);
        -:  172:    }
        -:  173:  }
        -:  174:} /* opfunc_set_accessor */
        -:  175:
        -:  176:/**
        -:  177: * Deletes an object property.
        -:  178: *
        -:  179: * @return ecma value
        -:  180: *         Returned value must be freed with ecma_free_value
        -:  181: */
        -:  182:ecma_value_t
    #####:  183:vm_op_delete_prop (ecma_value_t object, /**< base object */
        -:  184:                   ecma_value_t property, /**< property name */
        -:  185:                   bool is_strict) /**< strict mode */
        -:  186:{
        -:  187:#if !JERRY_ESNEXT
    #####:  188:  if (ecma_is_value_undefined (object))
        -:  189:  {
        -:  190:    return ECMA_VALUE_TRUE;
        -:  191:  }
        -:  192:#endif /* !JERRY_ESNEXT */
        -:  193:
    #####:  194:  if (!ecma_op_require_object_coercible (object))
        -:  195:  {
    #####:  196:    return ECMA_VALUE_ERROR;
        -:  197:  }
        -:  198:
    #####:  199:  ecma_string_t *name_string_p = ecma_op_to_property_key (property);
        -:  200:
    #####:  201:  if (JERRY_UNLIKELY (name_string_p == NULL))
        -:  202:  {
    #####:  203:    return ECMA_VALUE_ERROR;
        -:  204:  }
        -:  205:
    #####:  206:  ecma_value_t obj_value = ecma_op_to_object (object);
        -:  207:  /* The ecma_op_require_object_coercible call already checked the op_to_object error cases. */
    #####:  208:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (obj_value));
    #####:  209:  JERRY_ASSERT (ecma_is_value_object (obj_value));
    #####:  210:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_value);
    #####:  211:  JERRY_ASSERT (!ecma_is_lexical_environment (obj_p));
        -:  212:
    #####:  213:  ecma_value_t delete_op_ret = ecma_op_object_delete (obj_p, name_string_p, is_strict);
    #####:  214:  JERRY_ASSERT (ecma_is_value_boolean (delete_op_ret) || ECMA_IS_VALUE_ERROR (delete_op_ret));
    #####:  215:  ecma_deref_object (obj_p);
    #####:  216:  ecma_deref_ecma_string (name_string_p);
        -:  217:
        -:  218:#if JERRY_ESNEXT
    #####:  219:  if (is_strict && ecma_is_value_false (delete_op_ret))
        -:  220:  {
    #####:  221:    return ecma_raise_type_error (ECMA_ERR_MSG ("Operator delete returned false in strict mode"));
        -:  222:  }
        -:  223:#endif /* JERRY_ESNEXT */
        -:  224:
    #####:  225:  return delete_op_ret;
        -:  226:} /* vm_op_delete_prop */
        -:  227:
        -:  228:/**
        -:  229: * Deletes a variable.
        -:  230: *
        -:  231: * @return ecma value
        -:  232: *         Returned value must be freed with ecma_free_value
        -:  233: */
        -:  234:ecma_value_t
    #####:  235:vm_op_delete_var (ecma_value_t name_literal, /**< name literal */
        -:  236:                  ecma_object_t *lex_env_p) /**< lexical environment */
        -:  237:{
    #####:  238:  ecma_value_t completion_value = ECMA_VALUE_EMPTY;
        -:  239:
    #####:  240:  ecma_string_t *var_name_str_p = ecma_get_string_from_value (name_literal);
        -:  241:
    #####:  242:  ecma_object_t *ref_base_lex_env_p = ecma_op_resolve_reference_base (lex_env_p, var_name_str_p);
        -:  243:
        -:  244:#if JERRY_BUILTIN_PROXY
    #####:  245:  if (JERRY_UNLIKELY (ref_base_lex_env_p == ECMA_OBJECT_POINTER_ERROR))
        -:  246:  {
    #####:  247:    return ECMA_VALUE_ERROR;
        -:  248:  }
        -:  249:#endif /* JERRY_BUILTIN_PROXY */
        -:  250:
    #####:  251:  if (ref_base_lex_env_p == NULL)
        -:  252:  {
    #####:  253:    completion_value = ECMA_VALUE_TRUE;
        -:  254:  }
        -:  255:  else
        -:  256:  {
    #####:  257:    JERRY_ASSERT (ecma_is_lexical_environment (ref_base_lex_env_p));
        -:  258:
    #####:  259:    completion_value = ecma_op_delete_binding (ref_base_lex_env_p, var_name_str_p);
        -:  260:  }
        -:  261:
    #####:  262:  return completion_value;
        -:  263:} /* vm_op_delete_var */
        -:  264:
        -:  265:/**
        -:  266: * 'for-in' opcode handler
        -:  267: *
        -:  268: *  Note: from ES2015 (ES6) the for-in can trigger error when
        -:  269: *        the property names are not available (ex.: via Proxy ownKeys).
        -:  270: *        In these cases an error must be returned.
        -:  271: *
        -:  272: *        This error is returned as the `result_obj_p` and the
        -:  273: *        function's return value is NULL.
        -:  274: *
        -:  275: * See also:
        -:  276: *          ECMA-262 v5, 12.6.4
        -:  277: *
        -:  278: * @return - chain list of property names
        -:  279: *         - In case of error: NULL is returned and the `result_obj_p`
        -:  280: *           must be checked.
        -:  281: */
        -:  282:ecma_collection_t *
    #####:  283:opfunc_for_in (ecma_value_t iterable_value, /**< ideally an iterable value */
        -:  284:               ecma_value_t *result_obj_p) /**< expression object */
        -:  285:{
        -:  286:  /* 3. */
    #####:  287:  if (ecma_is_value_undefined (iterable_value)
    #####:  288:      || ecma_is_value_null (iterable_value))
        -:  289:  {
    #####:  290:    return NULL;
        -:  291:  }
        -:  292:
        -:  293:  /* 4. */
    #####:  294:  ecma_value_t obj_expr_value = ecma_op_to_object (iterable_value);
        -:  295:  /* ecma_op_to_object will only raise error on null/undefined values but those are handled above. */
    #####:  296:  JERRY_ASSERT (!ECMA_IS_VALUE_ERROR (obj_expr_value));
    #####:  297:  ecma_object_t *obj_p = ecma_get_object_from_value (obj_expr_value);
    #####:  298:  ecma_collection_t *prop_names_p = ecma_op_object_enumerate (obj_p);
        -:  299:
        -:  300:#if JERRY_ESNEXT
    #####:  301:  if (JERRY_UNLIKELY (prop_names_p == NULL))
        -:  302:  {
    #####:  303:    ecma_deref_object (obj_p);
    #####:  304:    *result_obj_p = ECMA_VALUE_ERROR;
    #####:  305:    return NULL;
        -:  306:  }
        -:  307:#endif /* JERRY_ESNEXT */
        -:  308:
    #####:  309:  if (prop_names_p->item_count != 0)
        -:  310:  {
    #####:  311:    *result_obj_p = ecma_make_object_value (obj_p);
    #####:  312:    return prop_names_p;
        -:  313:  }
        -:  314:
    #####:  315:  ecma_deref_object (obj_p);
    #####:  316:  ecma_collection_destroy (prop_names_p);
        -:  317:
    #####:  318:  return NULL;
        -:  319:} /* opfunc_for_in */
        -:  320:
        -:  321:#if JERRY_ESNEXT
        -:  322:
        -:  323:/**
        -:  324: * 'VM_OC_APPEND_ARRAY' opcode handler specialized for spread objects
        -:  325: *
        -:  326: * @return ECMA_VALUE_ERROR - if the operation failed
        -:  327: *         ECMA_VALUE_EMPTY, otherwise
        -:  328: */
        -:  329:static ecma_value_t JERRY_ATTR_NOINLINE
    #####:  330:opfunc_append_to_spread_array (ecma_value_t *stack_top_p, /**< current stack top */
        -:  331:                               uint16_t values_length) /**< number of elements to set */
        -:  332:{
    #####:  333:  JERRY_ASSERT (!(values_length & OPFUNC_HAS_SPREAD_ELEMENT));
        -:  334:
    #####:  335:  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
    #####:  336:  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  337:
    #####:  338:  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
    #####:  339:  uint32_t old_length = ext_array_obj_p->u.array.length;
        -:  340:
    #####:  341:  for (uint32_t i = 0, idx = old_length; i < values_length; i++, idx++)
        -:  342:  {
    #####:  343:    if (ecma_is_value_array_hole (stack_top_p[i]))
        -:  344:    {
    #####:  345:      continue;
        -:  346:    }
        -:  347:
    #####:  348:    if (stack_top_p[i] == ECMA_VALUE_SPREAD_ELEMENT)
        -:  349:    {
    #####:  350:      i++;
    #####:  351:      ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  352:      ecma_value_t spread_value = stack_top_p[i];
        -:  353:
    #####:  354:      ecma_value_t next_method;
    #####:  355:      ecma_value_t iterator = ecma_op_get_iterator (spread_value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  356:
    #####:  357:      if (!ECMA_IS_VALUE_ERROR (iterator))
        -:  358:      {
        -:  359:        while (true)
    #####:  360:        {
    #####:  361:          ecma_value_t next_value = ecma_op_iterator_step (iterator, next_method);
        -:  362:
    #####:  363:          if (ECMA_IS_VALUE_ERROR (next_value))
        -:  364:          {
    #####:  365:            break;
        -:  366:          }
        -:  367:
    #####:  368:          if (ecma_is_value_false (next_value))
        -:  369:          {
    #####:  370:            idx--;
    #####:  371:            ret_value = ECMA_VALUE_EMPTY;
    #####:  372:            break;
        -:  373:          }
        -:  374:
    #####:  375:          ecma_value_t value = ecma_op_iterator_value (next_value);
        -:  376:
    #####:  377:          ecma_free_value (next_value);
        -:  378:
    #####:  379:          if (ECMA_IS_VALUE_ERROR (value))
        -:  380:          {
    #####:  381:            break;
        -:  382:          }
        -:  383:
        -:  384:          ecma_value_t put_comp;
    #####:  385:          put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
    #####:  386:                                                            idx++,
        -:  387:                                                            value,
        -:  388:                                                            ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
        -:  389:
    #####:  390:          JERRY_ASSERT (ecma_is_value_true (put_comp));
    #####:  391:          ecma_free_value (value);
        -:  392:        }
        -:  393:      }
        -:  394:
    #####:  395:      ecma_free_value (iterator);
    #####:  396:      ecma_free_value (next_method);
    #####:  397:      ecma_free_value (spread_value);
        -:  398:
    #####:  399:      if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  400:      {
    #####:  401:        for (uint32_t k = i + 1; k < values_length; k++)
        -:  402:        {
    #####:  403:          ecma_free_value (stack_top_p[k]);
        -:  404:        }
        -:  405:
    #####:  406:        return ret_value;
        -:  407:      }
        -:  408:    }
        -:  409:    else
        -:  410:    {
    #####:  411:      ecma_value_t put_comp = ecma_builtin_helper_def_prop_by_index (array_obj_p,
        -:  412:                                                                     idx,
    #####:  413:                                                                     stack_top_p[i],
        -:  414:                                                                     ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE);
    #####:  415:      JERRY_ASSERT (ecma_is_value_true (put_comp));
    #####:  416:      ecma_free_value (stack_top_p[i]);
        -:  417:    }
        -:  418:  }
        -:  419:
    #####:  420:  return ECMA_VALUE_EMPTY;
        -:  421:} /* opfunc_append_to_spread_array */
        -:  422:
        -:  423:/**
        -:  424: * Spread function call/construct arguments into an ecma-collection
        -:  425: *
        -:  426: * @return NULL - if the operation failed
        -:  427: *         pointer to the ecma-collection with the spreaded arguments, otherwise
        -:  428: */
        -:  429:JERRY_ATTR_NOINLINE ecma_collection_t *
    #####:  430:opfunc_spread_arguments (ecma_value_t *stack_top_p, /**< pointer to the current stack top */
        -:  431:                         uint8_t arguments_list_len) /**< number of arguments */
        -:  432:{
    #####:  433:  ecma_collection_t *buff_p = ecma_new_collection ();
        -:  434:
    #####:  435:  for (uint32_t i = 0; i < arguments_list_len; i++)
        -:  436:  {
    #####:  437:    ecma_value_t arg = *stack_top_p++;
        -:  438:
    #####:  439:    if (arg != ECMA_VALUE_SPREAD_ELEMENT)
        -:  440:    {
    #####:  441:      ecma_collection_push_back (buff_p, arg);
    #####:  442:      continue;
        -:  443:    }
        -:  444:
    #####:  445:    ecma_value_t ret_value = ECMA_VALUE_ERROR;
    #####:  446:    ecma_value_t spread_value = *stack_top_p++;
    #####:  447:    i++;
        -:  448:
    #####:  449:    ecma_value_t next_method;
    #####:  450:    ecma_value_t iterator = ecma_op_get_iterator (spread_value, ECMA_VALUE_SYNC_ITERATOR, &next_method);
        -:  451:
    #####:  452:    if (!ECMA_IS_VALUE_ERROR (iterator))
        -:  453:    {
        -:  454:      while (true)
    #####:  455:      {
    #####:  456:        ecma_value_t next_value = ecma_op_iterator_step (iterator, next_method);
        -:  457:
    #####:  458:        if (ECMA_IS_VALUE_ERROR (next_value))
        -:  459:        {
    #####:  460:          break;
        -:  461:        }
        -:  462:
    #####:  463:        if (ecma_is_value_false (next_value))
        -:  464:        {
    #####:  465:          ret_value = ECMA_VALUE_EMPTY;
    #####:  466:          break;
        -:  467:        }
        -:  468:
    #####:  469:        ecma_value_t value = ecma_op_iterator_value (next_value);
        -:  470:
    #####:  471:        ecma_free_value (next_value);
        -:  472:
    #####:  473:        if (ECMA_IS_VALUE_ERROR (value))
        -:  474:        {
    #####:  475:          break;
        -:  476:        }
        -:  477:
    #####:  478:        ecma_collection_push_back (buff_p, value);
        -:  479:      }
        -:  480:    }
        -:  481:
    #####:  482:    ecma_free_value (iterator);
    #####:  483:    ecma_free_value (next_method);
    #####:  484:    ecma_free_value (spread_value);
        -:  485:
    #####:  486:    if (ECMA_IS_VALUE_ERROR (ret_value))
        -:  487:    {
    #####:  488:      for (uint32_t k = i + 1; k < arguments_list_len; k++)
        -:  489:      {
    #####:  490:        ecma_free_value (*stack_top_p++);
        -:  491:      }
        -:  492:
    #####:  493:      ecma_collection_free (buff_p);
    #####:  494:      buff_p = NULL;
    #####:  495:      break;
        -:  496:    }
        -:  497:  }
        -:  498:
    #####:  499:  return buff_p;
        -:  500:} /* opfunc_spread_arguments */
        -:  501:
        -:  502:#endif /* JERRY_ESNEXT */
        -:  503:
        -:  504:/**
        -:  505: * 'VM_OC_APPEND_ARRAY' opcode handler, for setting array object properties
        -:  506: *
        -:  507: * @return ECMA_VALUE_ERROR - if the operation failed
        -:  508: *         ECMA_VALUE_EMPTY, otherwise
        -:  509: */
        -:  510:ecma_value_t JERRY_ATTR_NOINLINE
        1:  511:opfunc_append_array (ecma_value_t *stack_top_p, /**< current stack top */
        -:  512:                     uint16_t values_length) /**< number of elements to set
        -:  513:                                              *   with potential OPFUNC_HAS_SPREAD_ELEMENT flag */
        -:  514:{
        -:  515:#if JERRY_ESNEXT
        1:  516:  if (values_length >= OPFUNC_HAS_SPREAD_ELEMENT)
        -:  517:  {
    #####:  518:    return opfunc_append_to_spread_array (stack_top_p, (uint16_t) (values_length & ~OPFUNC_HAS_SPREAD_ELEMENT));
        -:  519:  }
        -:  520:#endif /* JERRY_ESNEXT */
        -:  521:
        1:  522:  ecma_object_t *array_obj_p = ecma_get_object_from_value (stack_top_p[-1]);
        1:  523:  JERRY_ASSERT (ecma_get_object_type (array_obj_p) == ECMA_OBJECT_TYPE_ARRAY);
        -:  524:
        1:  525:  ecma_extended_object_t *ext_array_obj_p = (ecma_extended_object_t *) array_obj_p;
        1:  526:  uint32_t old_length = ext_array_obj_p->u.array.length;
        -:  527:
        1:  528:  if (JERRY_LIKELY (ecma_op_array_is_fast_array (ext_array_obj_p)))
        -:  529:  {
        1:  530:    uint32_t filled_holes = 0;
        1:  531:    ecma_value_t *values_p = ecma_fast_array_extend (array_obj_p, old_length + values_length);
        -:  532:
        2:  533:    for (uint32_t i = 0; i < values_length; i++)
        -:  534:    {
        1:  535:      values_p[old_length + i] = stack_top_p[i];
        -:  536:
        1:  537:      if (!ecma_is_value_array_hole (stack_top_p[i]))
        -:  538:      {
        1:  539:        filled_holes++;
        -:  540:
        1:  541:        ecma_deref_if_object (stack_top_p[i]);
        -:  542:      }
        -:  543:    }
        -:  544:
        1:  545:    ext_array_obj_p->u.array.length_prop_and_hole_count -= filled_holes * ECMA_FAST_ARRAY_HOLE_ONE;
        -:  546:
        1:  547:    if (JERRY_UNLIKELY ((values_length - filled_holes) > ECMA_FAST_ARRAY_MAX_NEW_HOLES_COUNT))
        -:  548:    {
    #####:  549:      ecma_fast_array_convert_to_normal (array_obj_p);
        -:  550:    }
        -:  551:  }
        -:  552:  else
        -:  553:  {
    #####:  554:    for (uint32_t i = 0; i < values_length; i++)
        -:  555:    {
    #####:  556:      if (!ecma_is_value_array_hole (stack_top_p[i]))
        -:  557:      {
    #####:  558:        ecma_string_t *index_str_p = ecma_new_ecma_string_from_uint32 (old_length + i);
        -:  559:
        -:  560:        ecma_property_value_t *prop_value_p;
        -:  561:
    #####:  562:        prop_value_p = ecma_create_named_data_property (array_obj_p,
        -:  563:                                                        index_str_p,
        -:  564:                                                        ECMA_PROPERTY_CONFIGURABLE_ENUMERABLE_WRITABLE,
        -:  565:                                                        NULL);
        -:  566:
    #####:  567:        ecma_deref_ecma_string (index_str_p);
    #####:  568:        prop_value_p->value = stack_top_p[i];
    #####:  569:        ecma_deref_if_object (stack_top_p[i]);
        -:  570:      }
        -:  571:    }
    #####:  572:    ext_array_obj_p->u.array.length = old_length + values_length;
        -:  573:  }
        -:  574:
        1:  575:  return ECMA_VALUE_EMPTY;
        -:  576:} /* opfunc_append_array */
        -:  577:
        -:  578:#if JERRY_ESNEXT
        -:  579:
        -:  580:/**
        -:  581: * Create an executable object using the current frame context
        -:  582: *
        -:  583: * @return executable object
        -:  584: */
        -:  585:vm_executable_object_t *
    #####:  586:opfunc_create_executable_object (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  587:                                 vm_create_executable_object_type_t type) /**< executable object type */
        -:  588:{
    #####:  589:  const ecma_compiled_code_t *bytecode_header_p = frame_ctx_p->shared_p->bytecode_header_p;
        -:  590:  size_t size, register_end;
        -:  591:
    #####:  592:  ecma_bytecode_ref ((ecma_compiled_code_t *) bytecode_header_p);
        -:  593:
    #####:  594:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  595:  {
    #####:  596:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  597:    register_end = (size_t) args_p->register_end;
    #####:  598:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -:  599:  }
        -:  600:  else
        -:  601:  {
    #####:  602:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  603:    register_end = (size_t) args_p->register_end;
    #####:  604:    size = (register_end + (size_t) args_p->stack_limit) * sizeof (ecma_value_t);
        -:  605:  }
        -:  606:
    #####:  607:  size_t total_size = JERRY_ALIGNUP (sizeof (vm_executable_object_t) + size, sizeof (uintptr_t));
        -:  608:
    #####:  609:  ecma_object_t *proto_p = NULL;
        -:  610:  /* Async function objects are not accessible, so their class_id is not relevant. */
    #####:  611:  uint8_t class_type = ECMA_OBJECT_CLASS_GENERATOR;
        -:  612:
    #####:  613:  if (type == VM_CREATE_EXECUTABLE_OBJECT_GENERATOR)
        -:  614:  {
    #####:  615:    ecma_builtin_id_t default_proto_id = ECMA_BUILTIN_ID_GENERATOR_PROTOTYPE;
        -:  616:
    #####:  617:    if (CBC_FUNCTION_GET_TYPE (bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC_GENERATOR)
        -:  618:    {
    #####:  619:      default_proto_id = ECMA_BUILTIN_ID_ASYNC_GENERATOR_PROTOTYPE;
    #####:  620:      class_type = ECMA_OBJECT_CLASS_ASYNC_GENERATOR;
        -:  621:    }
        -:  622:
    #####:  623:    JERRY_ASSERT (frame_ctx_p->shared_p->status_flags & VM_FRAME_CTX_SHARED_NON_ARROW_FUNC);
    #####:  624:    proto_p = ecma_op_get_prototype_from_constructor (frame_ctx_p->shared_p->function_object_p,
        -:  625:                                                      default_proto_id);
        -:  626:  }
        -:  627:
    #####:  628:  ecma_object_t *object_p = ecma_create_object (proto_p,
        -:  629:                                                total_size,
        -:  630:                                                ECMA_OBJECT_TYPE_CLASS);
        -:  631:
    #####:  632:  vm_executable_object_t *executable_object_p = (vm_executable_object_t *) object_p;
        -:  633:
    #####:  634:  if (type == VM_CREATE_EXECUTABLE_OBJECT_GENERATOR)
        -:  635:  {
    #####:  636:    ecma_deref_object (proto_p);
        -:  637:  }
        -:  638:
    #####:  639:  executable_object_p->extended_object.u.cls.type = class_type;
    #####:  640:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags = 0;
    #####:  641:  ECMA_SET_INTERNAL_VALUE_ANY_POINTER (executable_object_p->extended_object.u.cls.u3.head, NULL);
        -:  642:
    #####:  643:  JERRY_ASSERT (!(frame_ctx_p->status_flags & VM_FRAME_CTX_DIRECT_EVAL));
        -:  644:
        -:  645:  /* Copy shared data and frame context. */
    #####:  646:  vm_frame_ctx_shared_t *new_shared_p = &(executable_object_p->shared);
    #####:  647:  *new_shared_p = *(frame_ctx_p->shared_p);
    #####:  648:  new_shared_p->status_flags &= (uint32_t) ~VM_FRAME_CTX_SHARED_HAS_ARG_LIST;
        -:  649:
    #####:  650:  vm_frame_ctx_t *new_frame_ctx_p = &(executable_object_p->frame_ctx);
    #####:  651:  *new_frame_ctx_p = *frame_ctx_p;
    #####:  652:  new_frame_ctx_p->shared_p = new_shared_p;
        -:  653:
        -:  654:  /* The old register values are discarded. */
    #####:  655:  ecma_value_t *new_registers_p = VM_GET_REGISTERS (new_frame_ctx_p);
    #####:  656:  memcpy (new_registers_p, VM_GET_REGISTERS (frame_ctx_p), size);
        -:  657:
    #####:  658:  size_t stack_top = (size_t) (frame_ctx_p->stack_top_p - VM_GET_REGISTERS (frame_ctx_p));
    #####:  659:  ecma_value_t *new_stack_top_p = new_registers_p + stack_top;
        -:  660:
    #####:  661:  new_frame_ctx_p->stack_top_p = new_stack_top_p;
        -:  662:
        -:  663:  /* Initial state is "not running", so all object references are released. */
        -:  664:
    #####:  665:  if (frame_ctx_p->context_depth > 0)
        -:  666:  {
    #####:  667:    JERRY_ASSERT (type != VM_CREATE_EXECUTABLE_OBJECT_GENERATOR);
        -:  668:
    #####:  669:    ecma_value_t *register_end_p = new_registers_p + register_end;
        -:  670:
    #####:  671:    JERRY_ASSERT (register_end_p <= new_stack_top_p);
        -:  672:
    #####:  673:    while (new_registers_p < register_end_p)
        -:  674:    {
    #####:  675:      ecma_deref_if_object (*new_registers_p++);
        -:  676:    }
        -:  677:
    #####:  678:    vm_ref_lex_env_chain (frame_ctx_p->lex_env_p,
    #####:  679:                          frame_ctx_p->context_depth,
        -:  680:                          new_registers_p,
        -:  681:                          false);
        -:  682:
    #####:  683:    new_registers_p += frame_ctx_p->context_depth;
        -:  684:
    #####:  685:    JERRY_ASSERT (new_registers_p <= new_stack_top_p);
        -:  686:  }
        -:  687:
    #####:  688:  while (new_registers_p < new_stack_top_p)
        -:  689:  {
    #####:  690:    ecma_deref_if_object (*new_registers_p++);
        -:  691:  }
        -:  692:
    #####:  693:  JERRY_ASSERT (new_frame_ctx_p->block_result == ECMA_VALUE_UNDEFINED);
        -:  694:
    #####:  695:  new_frame_ctx_p->this_binding = ecma_copy_value_if_not_object (new_frame_ctx_p->this_binding);
        -:  696:
    #####:  697:  JERRY_CONTEXT (vm_top_context_p) = new_frame_ctx_p->prev_context_p;
        -:  698:
    #####:  699:  return executable_object_p;
        -:  700:} /* opfunc_create_executable_object */
        -:  701:
        -:  702:/**
        -:  703: * Byte code which resumes an executable object with throw
        -:  704: */
        -:  705:const uint8_t opfunc_resume_executable_object_with_throw[1] =
        -:  706:{
        -:  707:  CBC_THROW
        -:  708:};
        -:  709:
        -:  710:/**
        -:  711: * Byte code which resumes an executable object with return
        -:  712: */
        -:  713:const uint8_t opfunc_resume_executable_object_with_return[2] =
        -:  714:{
        -:  715:  CBC_EXT_OPCODE, CBC_EXT_RETURN
        -:  716:};
        -:  717:
        -:  718:/**
        -:  719: * Resume the execution of an inactive executable object
        -:  720: *
        -:  721: * @return value provided by the execution
        -:  722: */
        -:  723:ecma_value_t
    #####:  724:opfunc_resume_executable_object (vm_executable_object_t *executable_object_p, /**< executable object */
        -:  725:                                 ecma_value_t value) /**< value pushed onto the stack (takes the reference) */
        -:  726:{
    #####:  727:  const ecma_compiled_code_t *bytecode_header_p = executable_object_p->shared.bytecode_header_p;
    #####:  728:  ecma_value_t *register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
        -:  729:  ecma_value_t *register_end_p;
        -:  730:
    #####:  731:  if (bytecode_header_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  732:  {
    #####:  733:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) bytecode_header_p;
    #####:  734:    register_end_p = register_p + args_p->register_end;
        -:  735:  }
        -:  736:  else
        -:  737:  {
    #####:  738:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) bytecode_header_p;
    #####:  739:    register_end_p = register_p + args_p->register_end;
        -:  740:  }
        -:  741:
    #####:  742:  ecma_value_t *stack_top_p = executable_object_p->frame_ctx.stack_top_p;
        -:  743:
    #####:  744:  if (value != ECMA_VALUE_EMPTY)
        -:  745:  {
    #####:  746:    *stack_top_p = value;
    #####:  747:    executable_object_p->frame_ctx.stack_top_p = stack_top_p + 1;
        -:  748:  }
        -:  749:
    #####:  750:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  751:  {
    #####:  752:    while (register_p < register_end_p)
        -:  753:    {
    #####:  754:      ecma_ref_if_object (*register_p++);
        -:  755:    }
        -:  756:
    #####:  757:    vm_ref_lex_env_chain (executable_object_p->frame_ctx.lex_env_p,
    #####:  758:                          executable_object_p->frame_ctx.context_depth,
        -:  759:                          register_p,
        -:  760:                          true);
        -:  761:
    #####:  762:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  763:  }
        -:  764:
    #####:  765:  while (register_p < stack_top_p)
        -:  766:  {
    #####:  767:    ecma_ref_if_object (*register_p++);
        -:  768:  }
        -:  769:
    #####:  770:  ecma_ref_if_object (executable_object_p->frame_ctx.block_result);
        -:  771:
    #####:  772:  JERRY_ASSERT (ECMA_EXECUTABLE_OBJECT_IS_SUSPENDED (executable_object_p));
        -:  773:
    #####:  774:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_RUNNING;
        -:  775:
    #####:  776:  executable_object_p->frame_ctx.prev_context_p = JERRY_CONTEXT (vm_top_context_p);
    #####:  777:  JERRY_CONTEXT (vm_top_context_p) = &executable_object_p->frame_ctx;
        -:  778:
        -:  779:  /* inside the generators the "new.target" is always "undefined" as it can't be invoked with "new" */
    #####:  780:  ecma_object_t *old_new_target = JERRY_CONTEXT (current_new_target_p);
    #####:  781:  JERRY_CONTEXT (current_new_target_p) = NULL;
        -:  782:
        -:  783:#if JERRY_BUILTIN_REALMS
    #####:  784:  ecma_global_object_t *saved_global_object_p = JERRY_CONTEXT (global_object_p);
    #####:  785:  JERRY_CONTEXT (global_object_p) = ecma_op_function_get_realm (bytecode_header_p);
        -:  786:#endif /* JERRY_BUILTIN_REALMS */
        -:  787:
    #####:  788:  ecma_value_t result = vm_execute (&executable_object_p->frame_ctx);
        -:  789:
        -:  790:#if JERRY_BUILTIN_REALMS
    #####:  791:  JERRY_CONTEXT (global_object_p) = saved_global_object_p;
        -:  792:#endif /* JERRY_BUILTIN_REALMS */
        -:  793:
    #####:  794:  JERRY_CONTEXT (current_new_target_p) = old_new_target;
    #####:  795:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags &= (uint8_t) ~ECMA_EXECUTABLE_OBJECT_RUNNING;
        -:  796:
    #####:  797:  if (executable_object_p->frame_ctx.call_operation != VM_EXEC_RETURN)
        -:  798:  {
    #####:  799:    JERRY_ASSERT (executable_object_p->frame_ctx.call_operation == VM_NO_EXEC_OP);
        -:  800:
        -:  801:    /* All resources are released. */
    #####:  802:    executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= ECMA_EXECUTABLE_OBJECT_COMPLETED;
    #####:  803:    return result;
        -:  804:  }
        -:  805:
    #####:  806:  JERRY_CONTEXT (vm_top_context_p) = executable_object_p->frame_ctx.prev_context_p;
        -:  807:
    #####:  808:  register_p = VM_GET_REGISTERS (&executable_object_p->frame_ctx);
    #####:  809:  stack_top_p = executable_object_p->frame_ctx.stack_top_p;
        -:  810:
    #####:  811:  if (executable_object_p->frame_ctx.context_depth > 0)
        -:  812:  {
    #####:  813:    while (register_p < register_end_p)
        -:  814:    {
    #####:  815:      ecma_deref_if_object (*register_p++);
        -:  816:    }
        -:  817:
    #####:  818:    vm_ref_lex_env_chain (executable_object_p->frame_ctx.lex_env_p,
    #####:  819:                          executable_object_p->frame_ctx.context_depth,
        -:  820:                          register_p,
        -:  821:                          false);
        -:  822:
    #####:  823:    register_p += executable_object_p->frame_ctx.context_depth;
        -:  824:  }
        -:  825:
    #####:  826:  while (register_p < stack_top_p)
        -:  827:  {
    #####:  828:    ecma_deref_if_object (*register_p++);
        -:  829:  }
        -:  830:
    #####:  831:  ecma_deref_if_object (executable_object_p->frame_ctx.block_result);
        -:  832:
    #####:  833:  return result;
        -:  834:} /* opfunc_resume_executable_object */
        -:  835:
        -:  836:/**
        -:  837: * Fulfill the next promise of the async generator with the value
        -:  838: */
        -:  839:void
    #####:  840:opfunc_async_generator_yield (ecma_extended_object_t *async_generator_object_p, /**< async generator object */
        -:  841:                              ecma_value_t value) /**< value (takes the reference) */
        -:  842:{
        -:  843:  ecma_async_generator_task_t *task_p;
    #####:  844:  task_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_async_generator_task_t,
        -:  845:                                            async_generator_object_p->u.cls.u3.head);
        -:  846:
    #####:  847:  ecma_value_t iter_result = ecma_create_iter_result_object (value, ECMA_VALUE_FALSE);
    #####:  848:  ecma_fulfill_promise (task_p->promise, iter_result);
        -:  849:
    #####:  850:  ecma_free_value (iter_result);
    #####:  851:  ecma_free_value (value);
        -:  852:
    #####:  853:  ecma_value_t next = task_p->next;
    #####:  854:  async_generator_object_p->u.cls.u3.head = next;
        -:  855:
    #####:  856:  JERRY_ASSERT (task_p->operation_value == ECMA_VALUE_UNDEFINED);
    #####:  857:  jmem_heap_free_block (task_p, sizeof (ecma_async_generator_task_t));
        -:  858:
    #####:  859:  if (!ECMA_IS_INTERNAL_VALUE_NULL (next))
        -:  860:  {
    #####:  861:    ecma_value_t executable_object = ecma_make_object_value ((ecma_object_t *) async_generator_object_p);
    #####:  862:    ecma_enqueue_promise_async_generator_job (executable_object);
        -:  863:  }
    #####:  864:} /* opfunc_async_generator_yield */
        -:  865:
        -:  866:/**
        -:  867: * Creates a new executable object and awaits for the value
        -:  868: *
        -:  869: * Note:
        -:  870: *   extra_flags can be used to set additional extra_info flags
        -:  871: *
        -:  872: * @return a new Promise object on success, error otherwise
        -:  873: */
        -:  874:ecma_value_t
    #####:  875:opfunc_async_create_and_await (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -:  876:                               ecma_value_t value, /**< awaited value (takes reference) */
        -:  877:                               uint16_t extra_flags) /**< extra flags */
        -:  878:{
    #####:  879:  JERRY_ASSERT (frame_ctx_p->block_result == ECMA_VALUE_UNDEFINED);
    #####:  880:  JERRY_ASSERT (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_ASYNC
        -:  881:                || (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags)
        -:  882:                    == CBC_FUNCTION_ASYNC_ARROW));
        -:  883:
    #####:  884:  ecma_object_t *promise_p = ecma_builtin_get (ECMA_BUILTIN_ID_PROMISE);
    #####:  885:  ecma_value_t result = ecma_promise_reject_or_resolve (ecma_make_object_value (promise_p), value, true);
    #####:  886:  ecma_free_value (value);
        -:  887:
    #####:  888:  if (ECMA_IS_VALUE_ERROR (result))
        -:  889:  {
    #####:  890:    return result;
        -:  891:  }
        -:  892:
        -:  893:  vm_executable_object_t *executable_object_p;
    #####:  894:  executable_object_p = opfunc_create_executable_object (frame_ctx_p, VM_CREATE_EXECUTABLE_OBJECT_ASYNC);
        -:  895:
    #####:  896:  executable_object_p->extended_object.u.cls.u2.executable_obj_flags |= extra_flags;
        -:  897:
    #####:  898:  ecma_promise_async_then (result, ecma_make_object_value ((ecma_object_t *) executable_object_p));
    #####:  899:  ecma_deref_object ((ecma_object_t *) executable_object_p);
    #####:  900:  ecma_free_value (result);
        -:  901:
    #####:  902:  result = ecma_op_create_promise_object (ECMA_VALUE_EMPTY, ECMA_VALUE_UNDEFINED, promise_p);
        -:  903:
    #####:  904:  JERRY_ASSERT (ecma_is_value_object (result));
    #####:  905:  executable_object_p->frame_ctx.block_result = result;
        -:  906:
    #####:  907:  return result;
        -:  908:} /* opfunc_async_create_and_await */
        -:  909:
        -:  910:/**
        -:  911: * Initialize class fields.
        -:  912: *
        -:  913: * @return ECMA_VALUE_ERROR - initialization fails
        -:  914: *         ECMA_VALUE_UNDEFINED - otherwise
        -:  915: */
        -:  916:ecma_value_t
    #####:  917:opfunc_init_class_fields (ecma_object_t *class_object_p, /**< the function itself */
        -:  918:                          ecma_value_t this_val) /**< this_arg of the function */
        -:  919:{
    #####:  920:  JERRY_ASSERT (ecma_is_value_object (this_val));
        -:  921:
    #####:  922:  ecma_string_t *name_p = ecma_get_magic_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_INIT);
    #####:  923:  ecma_property_t *property_p = ecma_find_named_property (class_object_p, name_p);
        -:  924:
    #####:  925:  if (property_p == NULL)
        -:  926:  {
    #####:  927:    return ECMA_VALUE_UNDEFINED;
        -:  928:  }
        -:  929:
    #####:  930:  vm_frame_ctx_shared_class_fields_t shared_class_fields;
    #####:  931:  shared_class_fields.header.status_flags = VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS;
    #####:  932:  shared_class_fields.computed_class_fields_p = NULL;
        -:  933:
    #####:  934:  name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####:  935:  ecma_property_t *class_field_property_p = ecma_find_named_property (class_object_p, name_p);
        -:  936:
    #####:  937:  if (class_field_property_p != NULL)
        -:  938:  {
    #####:  939:    ecma_value_t value = ECMA_PROPERTY_VALUE_PTR (class_field_property_p)->value;
    #####:  940:    shared_class_fields.computed_class_fields_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
        -:  941:  }
        -:  942:
    #####:  943:  ecma_property_value_t *property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####:  944:  JERRY_ASSERT (ecma_op_is_callable (property_value_p->value));
        -:  945:
        -:  946:  ecma_extended_object_t *ext_function_p;
    #####:  947:  ext_function_p = (ecma_extended_object_t *) ecma_get_object_from_value (property_value_p->value);
    #####:  948:  shared_class_fields.header.bytecode_header_p = ecma_op_function_get_compiled_code (ext_function_p);
    #####:  949:  shared_class_fields.header.function_object_p = &ext_function_p->object;
        -:  950:
    #####:  951:  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -:  952:                                                                       ext_function_p->u.function.scope_cp);
        -:  953:
    #####:  954:  ecma_value_t result = vm_run (&shared_class_fields.header, this_val, scope_p);
        -:  955:
    #####:  956:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result) || result == ECMA_VALUE_UNDEFINED);
    #####:  957:  return result;
        -:  958:} /* opfunc_init_class_fields */
        -:  959:
        -:  960:/**
        -:  961: * Initialize static class fields.
        -:  962: *
        -:  963: * @return ECMA_VALUE_ERROR - initialization fails
        -:  964: *         ECMA_VALUE_UNDEFINED - otherwise
        -:  965: */
        -:  966:ecma_value_t
    #####:  967:opfunc_init_static_class_fields (ecma_value_t function_object, /**< the function itself */
        -:  968:                                 ecma_value_t this_val) /**< this_arg of the function */
        -:  969:{
    #####:  970:  JERRY_ASSERT (ecma_op_is_callable (function_object));
    #####:  971:  JERRY_ASSERT (ecma_is_value_object (this_val));
        -:  972:
    #####:  973:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####:  974:  ecma_object_t *function_object_p = ecma_get_object_from_value (function_object);
    #####:  975:  ecma_property_t *class_field_property_p = ecma_find_named_property (function_object_p, name_p);
        -:  976:
    #####:  977:  vm_frame_ctx_shared_class_fields_t shared_class_fields;
    #####:  978:  shared_class_fields.header.function_object_p = function_object_p;
    #####:  979:  shared_class_fields.header.status_flags = VM_FRAME_CTX_SHARED_HAS_CLASS_FIELDS;
    #####:  980:  shared_class_fields.computed_class_fields_p = NULL;
        -:  981:
    #####:  982:  if (class_field_property_p != NULL)
        -:  983:  {
    #####:  984:    ecma_value_t value = ECMA_PROPERTY_VALUE_PTR (class_field_property_p)->value;
    #####:  985:    shared_class_fields.computed_class_fields_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, value);
        -:  986:  }
        -:  987:
    #####:  988:  ecma_extended_object_t *ext_function_p = (ecma_extended_object_t *) function_object_p;
    #####:  989:  shared_class_fields.header.bytecode_header_p = ecma_op_function_get_compiled_code (ext_function_p);
        -:  990:
    #####:  991:  ecma_object_t *scope_p = ECMA_GET_NON_NULL_POINTER_FROM_POINTER_TAG (ecma_object_t,
        -:  992:                                                                       ext_function_p->u.function.scope_cp);
        -:  993:
    #####:  994:  ecma_value_t result = vm_run (&shared_class_fields.header, this_val, scope_p);
        -:  995:
    #####:  996:  JERRY_ASSERT (ECMA_IS_VALUE_ERROR (result) || result == ECMA_VALUE_UNDEFINED);
    #####:  997:  return result;
        -:  998:} /* opfunc_init_static_class_fields */
        -:  999:
        -: 1000:/**
        -: 1001: * Add the name of a computed field to a name list
        -: 1002: *
        -: 1003: * @return ECMA_VALUE_ERROR - name is not a valid property name
        -: 1004: *         ECMA_VALUE_UNDEFINED - otherwise
        -: 1005: */
        -: 1006:ecma_value_t
    #####: 1007:opfunc_add_computed_field (ecma_value_t class_object, /**< class object */
        -: 1008:                           ecma_value_t name) /**< name of the property */
        -: 1009:{
    #####: 1010:  ecma_string_t *prop_name_p = ecma_op_to_property_key (name);
        -: 1011:
    #####: 1012:  if (JERRY_UNLIKELY (prop_name_p == NULL))
        -: 1013:  {
    #####: 1014:    return ECMA_VALUE_ERROR;
        -: 1015:  }
        -: 1016:
    #####: 1017:  if (ecma_prop_name_is_symbol (prop_name_p))
        -: 1018:  {
    #####: 1019:    name = ecma_make_symbol_value (prop_name_p);
        -: 1020:  }
        -: 1021:  else
        -: 1022:  {
    #####: 1023:    name = ecma_make_string_value (prop_name_p);
        -: 1024:  }
        -: 1025:
    #####: 1026:  ecma_string_t *name_p = ecma_get_internal_string (LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED);
    #####: 1027:  ecma_object_t *class_object_p = ecma_get_object_from_value (class_object);
        -: 1028:
    #####: 1029:  ecma_property_t *property_p = ecma_find_named_property (class_object_p, name_p);
        -: 1030:  ecma_value_t *compact_collection_p;
        -: 1031:  ecma_property_value_t *property_value_p;
        -: 1032:
    #####: 1033:  if (property_p == NULL)
        -: 1034:  {
    #####: 1035:    ECMA_CREATE_INTERNAL_PROPERTY (class_object_p, name_p, property_p, property_value_p);
    #####: 1036:    compact_collection_p = ecma_new_compact_collection ();
        -: 1037:  }
        -: 1038:  else
        -: 1039:  {
    #####: 1040:    property_value_p = ECMA_PROPERTY_VALUE_PTR (property_p);
    #####: 1041:    compact_collection_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_value_t, property_value_p->value);
        -: 1042:  }
        -: 1043:
    #####: 1044:  compact_collection_p = ecma_compact_collection_push_back (compact_collection_p, name);
    #####: 1045:  ECMA_SET_INTERNAL_VALUE_POINTER (property_value_p->value, compact_collection_p);
    #####: 1046:  return ECMA_VALUE_UNDEFINED;
        -: 1047:} /* opfunc_add_computed_field */
        -: 1048:
        -: 1049:/**
        -: 1050: * Create implicit class constructor
        -: 1051: *
        -: 1052: * See also: ECMAScript v6, 14.5.14
        -: 1053: *
        -: 1054: * @return - new external function ecma-object
        -: 1055: */
        -: 1056:ecma_value_t
    #####: 1057:opfunc_create_implicit_class_constructor (uint8_t opcode, /**< current cbc opcode */
        -: 1058:                                          const ecma_compiled_code_t *bytecode_p) /**< current byte code */
        -: 1059:{
        -: 1060:  /* 8. */
    #####: 1061:  ecma_value_t script_value = ((cbc_uint8_arguments_t *) bytecode_p)->script_value;
    #####: 1062:  cbc_script_t *script_p = ECMA_GET_INTERNAL_VALUE_POINTER (cbc_script_t, script_value);
        -: 1063:
    #####: 1064:  if (JERRY_UNLIKELY (script_p->refs_and_type >= CBC_SCRIPT_REF_MAX))
        -: 1065:  {
    #####: 1066:    jerry_fatal (ERR_REF_COUNT_LIMIT);
        -: 1067:  }
        -: 1068:
    #####: 1069:  ecma_object_t *function_object_p = ecma_create_object (ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE),
        -: 1070:                                                         sizeof (ecma_extended_object_t),
        -: 1071:                                                         ECMA_OBJECT_TYPE_CONSTRUCTOR_FUNCTION);
        -: 1072:
    #####: 1073:  ecma_extended_object_t *constructor_object_p = (ecma_extended_object_t *) function_object_p;
        -: 1074:
    #####: 1075:  script_p->refs_and_type += CBC_SCRIPT_REF_ONE;
    #####: 1076:  constructor_object_p->u.constructor_function.script_value = script_value;
    #####: 1077:  constructor_object_p->u.constructor_function.flags = 0;
        -: 1078:
        -: 1079:  /* 10.a.i */
    #####: 1080:  if (opcode == CBC_EXT_PUSH_IMPLICIT_CONSTRUCTOR_HERITAGE)
        -: 1081:  {
    #####: 1082:    constructor_object_p->u.constructor_function.flags |= ECMA_CONSTRUCTOR_FUNCTION_HAS_HERITAGE;
        -: 1083:  }
        -: 1084:
        -: 1085:  ecma_property_value_t *prop_value_p;
    #####: 1086:  prop_value_p = ecma_create_named_data_property (function_object_p,
        -: 1087:                                                  ecma_get_magic_string (LIT_MAGIC_STRING_LENGTH),
        -: 1088:                                                  ECMA_PROPERTY_FLAG_CONFIGURABLE,
        -: 1089:                                                  NULL);
    #####: 1090:  prop_value_p->value = ecma_make_uint32_value (0);
        -: 1091:
    #####: 1092:  return ecma_make_object_value (function_object_p);
        -: 1093:} /* opfunc_create_implicit_class_constructor */
        -: 1094:
        -: 1095:/**
        -: 1096: * Set the [[HomeObject]] attribute of the given functon object
        -: 1097: */
        -: 1098:extern inline void JERRY_ATTR_ALWAYS_INLINE
    #####: 1099:opfunc_set_home_object (ecma_object_t *func_p, /**< function object */
        -: 1100:                        ecma_object_t *parent_env_p) /**< parent environment */
        -: 1101:{
    #####: 1102:  JERRY_ASSERT (ecma_is_lexical_environment (parent_env_p));
        -: 1103:
    #####: 1104:  if (ecma_get_object_type (func_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1105:  {
    #####: 1106:    ecma_extended_object_t *ext_func_p = (ecma_extended_object_t *) func_p;
    #####: 1107:    ECMA_SET_NON_NULL_POINTER_TAG (ext_func_p->u.function.scope_cp,
        -: 1108:                                   parent_env_p,
        -: 1109:                                   JMEM_CP_GET_POINTER_TAG_BITS (ext_func_p->u.function.scope_cp));
        -: 1110:  }
    #####: 1111:} /* opfunc_set_home_object */
        -: 1112:
        -: 1113:/**
        -: 1114: * ClassDefinitionEvaluation environment initialization part
        -: 1115: *
        -: 1116: * See also: ECMAScript v6, 14.5.14
        -: 1117: *
        -: 1118: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1119: *           ECMA_VALUE_EMPTY - otherwise
        -: 1120: */
        -: 1121:void
    #####: 1122:opfunc_push_class_environment (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1123:                               ecma_value_t **vm_stack_top, /**< VM stack top */
        -: 1124:                               ecma_value_t class_name) /**< class name */
        -: 1125:{
    #####: 1126:  JERRY_ASSERT (ecma_is_value_string (class_name));
    #####: 1127:  ecma_object_t *class_env_p = ecma_create_decl_lex_env (frame_ctx_p->lex_env_p);
        -: 1128:
        -: 1129:  /* 4.a */
        -: 1130:  ecma_property_value_t *property_value_p;
    #####: 1131:  property_value_p = ecma_create_named_data_property (class_env_p,
        -: 1132:                                                      ecma_get_string_from_value (class_name),
        -: 1133:                                                      ECMA_PROPERTY_FLAG_ENUMERABLE,
        -: 1134:                                                      NULL);
        -: 1135:
    #####: 1136:  property_value_p->value = ECMA_VALUE_UNINITIALIZED;
    #####: 1137:  frame_ctx_p->lex_env_p = class_env_p;
        -: 1138:
    #####: 1139:  *(*vm_stack_top)++ = ECMA_VALUE_RELEASE_LEX_ENV;
    #####: 1140:} /* opfunc_push_class_environment */
        -: 1141:
        -: 1142:/**
        -: 1143: * ClassDefinitionEvaluation object initialization part
        -: 1144: *
        -: 1145: * See also: ECMAScript v6, 14.5.14
        -: 1146: *
        -: 1147: * @return - ECMA_VALUE_ERROR - if the operation fails
        -: 1148: *           ECMA_VALUE_EMPTY - otherwise
        -: 1149: */
        -: 1150:ecma_value_t
    #####: 1151:opfunc_init_class (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1152:                   ecma_value_t *stack_top_p) /**< stack top */
        -: 1153:{
        -: 1154:  /* 5.b, 6.e.ii */
    #####: 1155:  ecma_object_t *ctor_parent_p = ecma_builtin_get (ECMA_BUILTIN_ID_FUNCTION_PROTOTYPE);
    #####: 1156:  ecma_object_t *proto_parent_p = NULL;
    #####: 1157:  bool free_proto_parent = false;
        -: 1158:
    #####: 1159:  ecma_value_t super_class = stack_top_p[-2];
    #####: 1160:  ecma_object_t *ctor_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 1161:
    #####: 1162:  bool heritage_present = !ecma_is_value_array_hole (super_class);
        -: 1163:
        -: 1164:  /* 5. ClassHeritage opt is not present */
    #####: 1165:  if (!heritage_present)
        -: 1166:  {
        -: 1167:    /* 5.a */
    #####: 1168:    proto_parent_p = ecma_builtin_get (ECMA_BUILTIN_ID_OBJECT_PROTOTYPE);
        -: 1169:  }
    #####: 1170:  else if (!ecma_is_value_null (super_class))
        -: 1171:  {
        -: 1172:    /* 6.f, 6.g.i */
    #####: 1173:    if (!ecma_is_constructor (super_class))
        -: 1174:    {
    #####: 1175:      return ecma_raise_type_error ("Class extends value is not a constructor or null");
        -: 1176:    }
        -: 1177:
    #####: 1178:    ecma_object_t *parent_p = ecma_get_object_from_value (super_class);
        -: 1179:
        -: 1180:    /* 6.g.ii */
    #####: 1181:    ecma_value_t proto_parent = ecma_op_object_get_by_magic_id (parent_p, LIT_MAGIC_STRING_PROTOTYPE);
        -: 1182:
        -: 1183:    /* 6.g.iii */
    #####: 1184:    if (ECMA_IS_VALUE_ERROR (proto_parent))
        -: 1185:    {
    #####: 1186:      return proto_parent;
        -: 1187:    }
        -: 1188:
        -: 1189:    /* 6.g.iv */
    #####: 1190:    if (ecma_is_value_object (proto_parent))
        -: 1191:    {
    #####: 1192:      proto_parent_p = ecma_get_object_from_value (proto_parent);
    #####: 1193:      free_proto_parent = true;
        -: 1194:    }
    #####: 1195:    else if (ecma_is_value_null (proto_parent))
        -: 1196:    {
    #####: 1197:      proto_parent_p = NULL;
        -: 1198:    }
        -: 1199:    else
        -: 1200:    {
    #####: 1201:      ecma_free_value (proto_parent);
    #####: 1202:      return ecma_raise_type_error ("Property 'prototype' is not an object or null");
        -: 1203:    }
        -: 1204:
        -: 1205:    /* 6.g.v */
    #####: 1206:    ctor_parent_p = parent_p;
        -: 1207:  }
        -: 1208:
        -: 1209:  /* 7. */
    #####: 1210:  ecma_object_t *proto_p = ecma_create_object (proto_parent_p, 0, ECMA_OBJECT_TYPE_GENERAL);
    #####: 1211:  ecma_value_t proto = ecma_make_object_value (proto_p);
        -: 1212:
    #####: 1213:  ECMA_SET_POINTER (ctor_p->u2.prototype_cp, ctor_parent_p);
        -: 1214:
    #####: 1215:  if (free_proto_parent)
        -: 1216:  {
    #####: 1217:    ecma_deref_object (proto_parent_p);
        -: 1218:  }
    #####: 1219:  ecma_free_value (super_class);
        -: 1220:
        -: 1221:  /* 16. */
        -: 1222:  ecma_property_value_t *property_value_p;
    #####: 1223:  property_value_p = ecma_create_named_data_property (ctor_p,
        -: 1224:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_PROTOTYPE),
        -: 1225:                                                      ECMA_PROPERTY_FIXED,
        -: 1226:                                                      NULL);
    #####: 1227:  property_value_p->value = proto;
        -: 1228:
        -: 1229:  /* 18. */
    #####: 1230:  property_value_p = ecma_create_named_data_property (proto_p,
        -: 1231:                                                      ecma_get_magic_string (LIT_MAGIC_STRING_CONSTRUCTOR),
        -: 1232:                                                      ECMA_PROPERTY_CONFIGURABLE_WRITABLE,
        -: 1233:                                                      NULL);
    #####: 1234:  property_value_p->value = ecma_make_object_value (ctor_p);
        -: 1235:
    #####: 1236:  if (ecma_get_object_type (ctor_p) == ECMA_OBJECT_TYPE_FUNCTION)
        -: 1237:  {
    #####: 1238:    ecma_object_t *proto_env_p = ecma_create_lex_env_class (frame_ctx_p->lex_env_p, 0);
    #####: 1239:    ECMA_SET_NON_NULL_POINTER (proto_env_p->u1.bound_object_cp, proto_p);
        -: 1240:
    #####: 1241:    ECMA_SET_NON_NULL_POINTER_TAG (((ecma_extended_object_t *) ctor_p)->u.function.scope_cp, proto_env_p, 0);
        -: 1242:
        -: 1243:    /* 15. set F’s [[ConstructorKind]] internal slot to "derived". */
    #####: 1244:    if (heritage_present)
        -: 1245:    {
    #####: 1246:      ECMA_SET_THIRD_BIT_TO_POINTER_TAG (((ecma_extended_object_t *) ctor_p)->u.function.scope_cp);
        -: 1247:    }
        -: 1248:
    #####: 1249:    ecma_deref_object (proto_env_p);
        -: 1250:  }
        -: 1251:
    #####: 1252:  stack_top_p[-2] = stack_top_p[-1];
    #####: 1253:  stack_top_p[-1] = proto;
        -: 1254:
    #####: 1255:  return ECMA_VALUE_EMPTY;
        -: 1256:} /* opfunc_init_class */
        -: 1257:
        -: 1258:/**
        -: 1259: * Set [[Enumerable]] and [[HomeObject]] attributes for all class method
        -: 1260: */
        -: 1261:static void
    #####: 1262:opfunc_set_class_attributes (ecma_object_t *obj_p, /**< object */
        -: 1263:                             ecma_object_t *parent_env_p) /**< parent environment */
        -: 1264:{
    #####: 1265:  jmem_cpointer_t prop_iter_cp = obj_p->u1.property_list_cp;
        -: 1266:
        -: 1267:#if JERRY_PROPERTY_HASHMAP
    #####: 1268:  if (prop_iter_cp != JMEM_CP_NULL)
        -: 1269:  {
    #####: 1270:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####: 1271:    if (prop_iter_p->types[0] == ECMA_PROPERTY_TYPE_HASHMAP)
        -: 1272:    {
    #####: 1273:      prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1274:    }
        -: 1275:  }
        -: 1276:#endif /* JERRY_PROPERTY_HASHMAP */
        -: 1277:
    #####: 1278:  while (prop_iter_cp != JMEM_CP_NULL)
        -: 1279:  {
    #####: 1280:    ecma_property_header_t *prop_iter_p = ECMA_GET_NON_NULL_POINTER (ecma_property_header_t, prop_iter_cp);
    #####: 1281:    JERRY_ASSERT (ECMA_PROPERTY_IS_PROPERTY_PAIR (prop_iter_p));
        -: 1282:
    #####: 1283:    ecma_property_pair_t *property_pair_p = (ecma_property_pair_t *) prop_iter_p;
        -: 1284:
    #####: 1285:    for (uint32_t index = 0; index < ECMA_PROPERTY_PAIR_ITEM_COUNT; index++)
        -: 1286:    {
    #####: 1287:      uint8_t property = property_pair_p->header.types[index];
        -: 1288:
    #####: 1289:      if (!ECMA_PROPERTY_IS_RAW (property))
        -: 1290:      {
    #####: 1291:        JERRY_ASSERT (property == ECMA_PROPERTY_TYPE_DELETED
        -: 1292:                      || (ECMA_PROPERTY_IS_INTERNAL (property)
        -: 1293:                          && property_pair_p->names_cp[index] == LIT_INTERNAL_MAGIC_STRING_CLASS_FIELD_COMPUTED));
    #####: 1294:        continue;
        -: 1295:      }
        -: 1296:
    #####: 1297:      if (property & ECMA_PROPERTY_FLAG_DATA)
        -: 1298:      {
    #####: 1299:        if (ecma_is_value_object (property_pair_p->values[index].value)
    #####: 1300:            && ecma_is_property_enumerable (property))
        -: 1301:        {
    #####: 1302:          property_pair_p->header.types[index] = (uint8_t) (property & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
    #####: 1303:          opfunc_set_home_object (ecma_get_object_from_value (property_pair_p->values[index].value), parent_env_p);
        -: 1304:        }
    #####: 1305:        continue;
        -: 1306:      }
        -: 1307:
    #####: 1308:      property_pair_p->header.types[index] = (uint8_t) (property & ~ECMA_PROPERTY_FLAG_ENUMERABLE);
    #####: 1309:      ecma_property_value_t *accessor_objs_p = property_pair_p->values + index;
        -: 1310:
    #####: 1311:      ecma_getter_setter_pointers_t *get_set_pair_p = ecma_get_named_accessor_property (accessor_objs_p);
        -: 1312:
    #####: 1313:      if (get_set_pair_p->getter_cp != JMEM_CP_NULL)
        -: 1314:      {
    #####: 1315:        opfunc_set_home_object (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->getter_cp), parent_env_p);
        -: 1316:      }
        -: 1317:
    #####: 1318:      if (get_set_pair_p->setter_cp != JMEM_CP_NULL)
        -: 1319:      {
    #####: 1320:        opfunc_set_home_object (ECMA_GET_NON_NULL_POINTER (ecma_object_t, get_set_pair_p->setter_cp), parent_env_p);
        -: 1321:      }
        -: 1322:    }
        -: 1323:
    #####: 1324:    prop_iter_cp = prop_iter_p->next_property_cp;
        -: 1325:  }
    #####: 1326:} /* opfunc_set_class_attributes */
        -: 1327:
        -: 1328:/**
        -: 1329: * Pop the current lexical environment referenced by the frame context
        -: 1330: */
        -: 1331:void
    #####: 1332:opfunc_pop_lexical_environment (vm_frame_ctx_t *frame_ctx_p) /**< frame context */
        -: 1333:{
    #####: 1334:  ecma_object_t *outer_env_p = ECMA_GET_NON_NULL_POINTER (ecma_object_t, frame_ctx_p->lex_env_p->u2.outer_reference_cp);
    #####: 1335:  ecma_deref_object (frame_ctx_p->lex_env_p);
    #####: 1336:  frame_ctx_p->lex_env_p = outer_env_p;
    #####: 1337:} /* opfunc_pop_lexical_environment */
        -: 1338:
        -: 1339:/**
        -: 1340: * ClassDefinitionEvaluation finalization part
        -: 1341: *
        -: 1342: * See also: ECMAScript v6, 14.5.14
        -: 1343: */
        -: 1344:void
    #####: 1345:opfunc_finalize_class (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1346:                       ecma_value_t **vm_stack_top_p, /**< current vm stack top */
        -: 1347:                       ecma_value_t class_name) /**< class name */
        -: 1348:{
    #####: 1349:  JERRY_ASSERT (ecma_is_value_undefined (class_name) || ecma_is_value_string (class_name));
    #####: 1350:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1351:
    #####: 1352:  ecma_object_t *ctor_p = ecma_get_object_from_value (stack_top_p[-2]);
    #####: 1353:  ecma_object_t *proto_p = ecma_get_object_from_value (stack_top_p[-1]);
        -: 1354:
    #####: 1355:  ecma_object_t *class_env_p = frame_ctx_p->lex_env_p;
        -: 1356:
        -: 1357:  /* 23.a */
    #####: 1358:  if (!ecma_is_value_undefined (class_name))
        -: 1359:  {
    #####: 1360:    ecma_op_initialize_binding (class_env_p, ecma_get_string_from_value (class_name), stack_top_p[-2]);
        -: 1361:  }
        -: 1362:
    #####: 1363:  ecma_object_t *ctor_env_p = ecma_create_lex_env_class (class_env_p, 0);
    #####: 1364:  ECMA_SET_NON_NULL_POINTER (ctor_env_p->u1.bound_object_cp, ctor_p);
    #####: 1365:  ecma_object_t *proto_env_p = ecma_create_lex_env_class (class_env_p, 0);
    #####: 1366:  ECMA_SET_NON_NULL_POINTER (proto_env_p->u1.bound_object_cp, proto_p);
        -: 1367:
    #####: 1368:  opfunc_set_class_attributes (ctor_p, ctor_env_p);
    #####: 1369:  opfunc_set_class_attributes (proto_p, proto_env_p);
        -: 1370:
    #####: 1371:  ecma_deref_object (proto_env_p);
    #####: 1372:  ecma_deref_object (ctor_env_p);
    #####: 1373:  ecma_deref_object (proto_p);
        -: 1374:
    #####: 1375:  JERRY_ASSERT ((ecma_is_value_undefined (class_name) ? stack_top_p[-3] == ECMA_VALUE_UNDEFINED
        -: 1376:                                                      : stack_top_p[-3] == ECMA_VALUE_RELEASE_LEX_ENV));
        -: 1377:
        -: 1378:  /* only the current class remains on the stack */
    #####: 1379:  if (stack_top_p[-3] == ECMA_VALUE_RELEASE_LEX_ENV)
        -: 1380:  {
    #####: 1381:    opfunc_pop_lexical_environment (frame_ctx_p);
        -: 1382:  }
        -: 1383:
    #####: 1384:  stack_top_p[-3] = stack_top_p[-2];
    #####: 1385:  *vm_stack_top_p -= 2;
    #####: 1386:} /* opfunc_finalize_class */
        -: 1387:
        -: 1388:/**
        -: 1389: * MakeSuperPropertyReference operation
        -: 1390: *
        -: 1391: * See also: ECMAScript v6, 12.3.5.3
        -: 1392: *
        -: 1393: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1394: *         ECMA_VALUE_EMPTY - otherwise
        -: 1395: */
        -: 1396:ecma_value_t
    #####: 1397:opfunc_form_super_reference (ecma_value_t **vm_stack_top_p, /**< current vm stack top */
        -: 1398:                             vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1399:                             ecma_value_t prop_name, /**< property name to resolve */
        -: 1400:                             uint8_t opcode) /**< current cbc opcode */
        -: 1401:{
    #####: 1402:  if (CBC_FUNCTION_GET_TYPE (frame_ctx_p->shared_p->bytecode_header_p->status_flags) == CBC_FUNCTION_CONSTRUCTOR)
        -: 1403:  {
    #####: 1404:    ecma_environment_record_t *environment_record_p = ecma_op_get_environment_record (frame_ctx_p->lex_env_p);
        -: 1405:
    #####: 1406:    if (!ecma_op_this_binding_is_initialized (environment_record_p))
        -: 1407:    {
    #####: 1408:      return ecma_raise_reference_error (ECMA_ERR_MSG ("Must call super constructor in derived class before "
        -: 1409:                                                       "accessing 'this' or returning from it"));
        -: 1410:    }
        -: 1411:  }
        -: 1412:
    #####: 1413:  ecma_value_t parent = ecma_op_resolve_super_base (frame_ctx_p->lex_env_p);
        -: 1414:
    #####: 1415:  if (ECMA_IS_VALUE_ERROR (parent))
        -: 1416:  {
    #####: 1417:    return ecma_raise_type_error (ECMA_ERR_MSG ("Cannot invoke nullable super method"));
        -: 1418:  }
        -: 1419:
    #####: 1420:  if (!ecma_op_require_object_coercible (parent))
        -: 1421:  {
    #####: 1422:    return ECMA_VALUE_ERROR;
        -: 1423:  }
        -: 1424:
    #####: 1425:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1426:
    #####: 1427:  if (opcode >= CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE)
        -: 1428:  {
    #####: 1429:    JERRY_ASSERT (opcode == CBC_EXT_SUPER_PROP_ASSIGNMENT_REFERENCE
        -: 1430:                  || opcode == CBC_EXT_SUPER_PROP_LITERAL_ASSIGNMENT_REFERENCE);
    #####: 1431:    *stack_top_p++ = parent;
    #####: 1432:    *stack_top_p++ = ecma_copy_value (prop_name);
    #####: 1433:    *vm_stack_top_p = stack_top_p;
        -: 1434:
    #####: 1435:    return ECMA_VALUE_EMPTY;
        -: 1436:  }
        -: 1437:
    #####: 1438:  ecma_object_t *parent_p = ecma_get_object_from_value (parent);
    #####: 1439:  ecma_string_t *prop_name_p = ecma_op_to_property_key (prop_name);
        -: 1440:
    #####: 1441:  if (prop_name_p == NULL)
        -: 1442:  {
    #####: 1443:    ecma_deref_object (parent_p);
    #####: 1444:    return ECMA_VALUE_ERROR;
        -: 1445:  }
        -: 1446:
    #####: 1447:  ecma_value_t result = ecma_op_object_get_with_receiver (parent_p, prop_name_p, frame_ctx_p->this_binding);
    #####: 1448:  ecma_deref_ecma_string (prop_name_p);
    #####: 1449:  ecma_deref_object (parent_p);
        -: 1450:
    #####: 1451:  if (ECMA_IS_VALUE_ERROR (result))
        -: 1452:  {
    #####: 1453:    return result;
        -: 1454:  }
        -: 1455:
    #####: 1456:  if (opcode == CBC_EXT_SUPER_PROP_LITERAL_REFERENCE || opcode == CBC_EXT_SUPER_PROP_REFERENCE)
        -: 1457:  {
    #####: 1458:    *stack_top_p++ = ecma_copy_value (frame_ctx_p->this_binding);
    #####: 1459:    *stack_top_p++ = ECMA_VALUE_UNDEFINED;
        -: 1460:  }
        -: 1461:
    #####: 1462:  *stack_top_p++ = result;
    #####: 1463:  *vm_stack_top_p = stack_top_p;
        -: 1464:
    #####: 1465:  return ECMA_VALUE_EMPTY;
        -: 1466:} /* opfunc_form_super_reference */
        -: 1467:
        -: 1468:/**
        -: 1469: * Assignment operation for SuperRefence base
        -: 1470: *
        -: 1471: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1472: *         ECMA_VALUE_EMPTY - otherwise
        -: 1473: */
        -: 1474:ecma_value_t
    #####: 1475:opfunc_assign_super_reference (ecma_value_t **vm_stack_top_p, /**< vm stack top */
        -: 1476:                               vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1477:                               uint32_t opcode_data) /**< opcode data to store the result */
        -: 1478:{
    #####: 1479:  ecma_value_t *stack_top_p = *vm_stack_top_p;
        -: 1480:
    #####: 1481:  ecma_value_t base_obj = ecma_op_to_object (stack_top_p[-3]);
        -: 1482:
    #####: 1483:  if (ECMA_IS_VALUE_ERROR (base_obj))
        -: 1484:  {
    #####: 1485:    return base_obj;
        -: 1486:  }
        -: 1487:
    #####: 1488:  ecma_object_t *base_obj_p = ecma_get_object_from_value (base_obj);
    #####: 1489:  ecma_string_t *prop_name_p = ecma_op_to_property_key (stack_top_p[-2]);
        -: 1490:
    #####: 1491:  if (prop_name_p == NULL)
        -: 1492:  {
    #####: 1493:    ecma_deref_object (base_obj_p);
    #####: 1494:    return ECMA_VALUE_ERROR;
        -: 1495:  }
        -: 1496:
    #####: 1497:  bool is_strict = (frame_ctx_p->status_flags & VM_FRAME_CTX_IS_STRICT) != 0;
        -: 1498:
    #####: 1499:  ecma_value_t result = ecma_op_object_put_with_receiver (base_obj_p,
        -: 1500:                                                          prop_name_p,
    #####: 1501:                                                          stack_top_p[-1],
        -: 1502:                                                          frame_ctx_p->this_binding,
        -: 1503:                                                          is_strict);
        -: 1504:
    #####: 1505:  ecma_deref_ecma_string (prop_name_p);
    #####: 1506:  ecma_deref_object (base_obj_p);
        -: 1507:
    #####: 1508:  if (ECMA_IS_VALUE_ERROR (result))
        -: 1509:  {
    #####: 1510:    return result;
        -: 1511:  }
        -: 1512:
    #####: 1513:  for (int32_t i = 1; i <= 3; i++)
        -: 1514:  {
    #####: 1515:    ecma_free_value (stack_top_p[-i]);
        -: 1516:  }
        -: 1517:
    #####: 1518:  stack_top_p -= 3;
        -: 1519:
    #####: 1520:  if (opcode_data & VM_OC_PUT_STACK)
        -: 1521:  {
    #####: 1522:    *stack_top_p++ = result;
        -: 1523:  }
    #####: 1524:  else if (opcode_data & VM_OC_PUT_BLOCK)
        -: 1525:  {
    #####: 1526:    ecma_fast_free_value (frame_ctx_p->block_result);
    #####: 1527:    frame_ctx_p->block_result = result;
        -: 1528:  }
        -: 1529:
    #####: 1530:  *vm_stack_top_p = stack_top_p;
        -: 1531:
    #####: 1532:  return result;
        -: 1533:} /* opfunc_assign_super_reference */
        -: 1534:
        -: 1535:/**
        -: 1536: * Copy data properties of an object
        -: 1537: *
        -: 1538: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1539: *         ECMA_VALUE_EMPTY - otherwise
        -: 1540: */
        -: 1541:ecma_value_t
    #####: 1542:opfunc_copy_data_properties (ecma_value_t target_object, /**< target object */
        -: 1543:                             ecma_value_t source_object, /**< source object */
        -: 1544:                             ecma_value_t filter_array) /**< filter array */
        -: 1545:{
    #####: 1546:  bool source_to_object = false;
        -: 1547:
    #####: 1548:  if (!ecma_is_value_object (source_object))
        -: 1549:  {
    #####: 1550:    source_object = ecma_op_to_object (source_object);
        -: 1551:
    #####: 1552:    if (ECMA_IS_VALUE_ERROR (source_object))
        -: 1553:    {
    #####: 1554:      return source_object;
        -: 1555:    }
        -: 1556:
    #####: 1557:    source_to_object = true;
        -: 1558:  }
        -: 1559:
    #####: 1560:  ecma_object_t *source_object_p = ecma_get_object_from_value (source_object);
    #####: 1561:  ecma_collection_t *names_p = ecma_op_object_own_property_keys (source_object_p, JERRY_PROPERTY_FILTER_ALL);
        -: 1562:
        -: 1563:#if JERRY_BUILTIN_PROXY
    #####: 1564:  if (names_p == NULL)
        -: 1565:  {
    #####: 1566:    JERRY_ASSERT (!source_to_object);
    #####: 1567:    return ECMA_VALUE_ERROR;
        -: 1568:  }
        -: 1569:#endif /* JERRY_BUILTIN_PROXY */
        -: 1570:
    #####: 1571:  ecma_object_t *target_object_p = ecma_get_object_from_value (target_object);
    #####: 1572:  ecma_value_t *buffer_p = names_p->buffer_p;
    #####: 1573:  ecma_value_t *buffer_end_p = buffer_p + names_p->item_count;
    #####: 1574:  ecma_value_t *filter_start_p = NULL;
    #####: 1575:  ecma_value_t *filter_end_p = NULL;
    #####: 1576:  ecma_value_t result = ECMA_VALUE_EMPTY;
        -: 1577:
    #####: 1578:  if (filter_array != ECMA_VALUE_UNDEFINED)
        -: 1579:  {
    #####: 1580:    ecma_object_t *filter_array_p = ecma_get_object_from_value (filter_array);
        -: 1581:
    #####: 1582:    JERRY_ASSERT (ecma_get_object_type (filter_array_p) == ECMA_OBJECT_TYPE_ARRAY);
    #####: 1583:    JERRY_ASSERT (ecma_op_object_is_fast_array (filter_array_p));
        -: 1584:
    #####: 1585:    if (filter_array_p->u1.property_list_cp != JMEM_CP_NULL)
        -: 1586:    {
    #####: 1587:      filter_start_p = ECMA_GET_NON_NULL_POINTER (ecma_value_t, filter_array_p->u1.property_list_cp);
    #####: 1588:      filter_end_p = filter_start_p + ((ecma_extended_object_t *) filter_array_p)->u.array.length;
        -: 1589:    }
        -: 1590:  }
        -: 1591:
    #####: 1592:  while (buffer_p < buffer_end_p)
        -: 1593:  {
    #####: 1594:    ecma_string_t *property_name_p = ecma_get_prop_name_from_value (*buffer_p++);
        -: 1595:
    #####: 1596:    if (filter_start_p != NULL)
        -: 1597:    {
    #####: 1598:      ecma_value_t *filter_p = filter_start_p;
        -: 1599:
        -: 1600:      do
        -: 1601:      {
    #####: 1602:        if (ecma_compare_ecma_strings (property_name_p, ecma_get_prop_name_from_value (*filter_p)))
        -: 1603:        {
    #####: 1604:          break;
        -: 1605:        }
        -: 1606:      }
    #####: 1607:      while (++filter_p < filter_end_p);
        -: 1608:
    #####: 1609:      if (filter_p != filter_end_p)
        -: 1610:      {
    #####: 1611:        continue;
        -: 1612:      }
        -: 1613:    }
        -: 1614:
    #####: 1615:    ecma_property_descriptor_t descriptor;
    #####: 1616:    result = ecma_op_object_get_own_property_descriptor (source_object_p, property_name_p, &descriptor);
        -: 1617:
    #####: 1618:    if (ECMA_IS_VALUE_ERROR (result))
        -: 1619:    {
    #####: 1620:      break;
        -: 1621:    }
        -: 1622:
    #####: 1623:    if (result == ECMA_VALUE_FALSE)
        -: 1624:    {
    #####: 1625:      continue;
        -: 1626:    }
        -: 1627:
    #####: 1628:    if (!(descriptor.flags & JERRY_PROP_IS_ENUMERABLE))
        -: 1629:    {
    #####: 1630:      ecma_free_property_descriptor (&descriptor);
    #####: 1631:      continue;
        -: 1632:    }
        -: 1633:
    #####: 1634:    if ((descriptor.flags & JERRY_PROP_IS_VALUE_DEFINED) && !ECMA_OBJECT_IS_PROXY (source_object_p))
        -: 1635:    {
    #####: 1636:      result = descriptor.value;
        -: 1637:    }
        -: 1638:    else
        -: 1639:    {
    #####: 1640:      ecma_free_property_descriptor (&descriptor);
        -: 1641:
    #####: 1642:      result = ecma_op_object_get (source_object_p, property_name_p);
        -: 1643:
    #####: 1644:      if (ECMA_IS_VALUE_ERROR (result))
        -: 1645:      {
    #####: 1646:        break;
        -: 1647:      }
        -: 1648:    }
        -: 1649:
    #####: 1650:    opfunc_set_data_property (target_object_p, property_name_p, result);
    #####: 1651:    ecma_free_value (result);
        -: 1652:
    #####: 1653:    result = ECMA_VALUE_EMPTY;
        -: 1654:  }
        -: 1655:
    #####: 1656:  if (JERRY_UNLIKELY (source_to_object))
        -: 1657:  {
    #####: 1658:    ecma_deref_object (source_object_p);
        -: 1659:  }
        -: 1660:
    #####: 1661:  ecma_collection_free (names_p);
    #####: 1662:  return result;
        -: 1663:} /* opfunc_copy_data_properties */
        -: 1664:
        -: 1665:/**
        -: 1666: * Check whether the current lexical scope has restricted binding declaration with the given name
        -: 1667: *
        -: 1668: * Steps are include ES11: 8.1.1.4.14 HasRestrictedGlobalProperty abstract operation
        -: 1669: *
        -: 1670: * @return ECMA_VALUE_ERROR - if the operation fails
        -: 1671: *         ECMA_VALUE_TRUE - if it has restricted property binding
        -: 1672: *         ECMA_VALUE_FALSE - otherwise
        -: 1673: */
        -: 1674:ecma_value_t
    #####: 1675:opfunc_lexical_scope_has_restricted_binding (vm_frame_ctx_t *frame_ctx_p, /**< frame context */
        -: 1676:                                             ecma_string_t *name_p) /**< binding name */
        -: 1677:{
    #####: 1678:  JERRY_ASSERT (ecma_get_lex_env_type (frame_ctx_p->lex_env_p) == ECMA_LEXICAL_ENVIRONMENT_DECLARATIVE);
        -: 1679:
        -: 1680:#if JERRY_BUILTIN_REALMS
    #####: 1681:  JERRY_ASSERT (frame_ctx_p->this_binding == JERRY_CONTEXT (global_object_p)->this_binding);
        -: 1682:#else /* !JERRY_BUILTIN_REALMS */
        -: 1683:  JERRY_ASSERT (frame_ctx_p->this_binding == ecma_builtin_get_global ());
        -: 1684:#endif /* JERRY_BUILTIN_REALMS */
        -: 1685:
    #####: 1686:  ecma_object_t *lex_env_p = frame_ctx_p->lex_env_p;
    #####: 1687:  ecma_property_t *binding_p = ecma_find_named_property (lex_env_p, name_p);
        -: 1688:
    #####: 1689:  if (binding_p != NULL)
        -: 1690:  {
    #####: 1691:    return ECMA_VALUE_TRUE;
        -: 1692:  }
        -: 1693:
        -: 1694:#if JERRY_BUILTIN_REALMS
    #####: 1695:  ecma_object_t *const global_scope_p = ecma_get_global_scope ((ecma_object_t *) JERRY_CONTEXT (global_object_p));
        -: 1696:#else /* !JERRY_BUILTIN_REALMS */
        -: 1697:  ecma_object_t *const global_scope_p = ecma_get_global_scope (global_obj_p);
        -: 1698:#endif /* JERRY_BUILTIN_REALMS */
        -: 1699:
    #####: 1700:  if (global_scope_p != lex_env_p)
        -: 1701:  {
    #####: 1702:    return ECMA_VALUE_FALSE;
        -: 1703:  }
        -: 1704:
    #####: 1705:  ecma_object_t *global_obj_p = ecma_get_object_from_value (frame_ctx_p->this_binding);
        -: 1706:
        -: 1707:#if JERRY_BUILTIN_PROXY
    #####: 1708:  if (ECMA_OBJECT_IS_PROXY (global_obj_p))
        -: 1709:  {
    #####: 1710:    ecma_property_descriptor_t prop_desc;
    #####: 1711:    ecma_value_t status = ecma_proxy_object_get_own_property_descriptor (global_obj_p, name_p, &prop_desc);
        -: 1712:
    #####: 1713:    if (ecma_is_value_true (status))
        -: 1714:    {
    #####: 1715:      status = ecma_make_boolean_value ((prop_desc.flags & JERRY_PROP_IS_CONFIGURABLE) == 0);
    #####: 1716:      ecma_free_property_descriptor (&prop_desc);
        -: 1717:    }
        -: 1718:
    #####: 1719:    return status;
        -: 1720:  }
        -: 1721:#endif /* JERRY_BUILTIN_PROXY */
        -: 1722:
    #####: 1723:  ecma_property_t property = ecma_op_object_get_own_property (global_obj_p,
        -: 1724:                                                              name_p,
        -: 1725:                                                              NULL,
        -: 1726:                                                              ECMA_PROPERTY_GET_NO_OPTIONS);
        -: 1727:
    #####: 1728:  return ecma_make_boolean_value ((property != ECMA_PROPERTY_TYPE_NOT_FOUND
    #####: 1729:                                   && !ecma_is_property_configurable (property)));
        -: 1730:} /* opfunc_lexical_scope_has_restricted_binding */
        -: 1731:
        -: 1732:#endif /* JERRY_ESNEXT */
        -: 1733:
        -: 1734:/**
        -: 1735: * @}
        -: 1736: * @}
        -: 1737: */
