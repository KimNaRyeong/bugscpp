        -:    0:Source:/home/workspace/jerry-core/ecma/base/ecma-literal-storage.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-alloc.h"
        -:   17:#include "ecma-bigint.h"
        -:   18:#include "ecma-big-uint.h"
        -:   19:#include "ecma-literal-storage.h"
        -:   20:#include "ecma-helpers.h"
        -:   21:#include "jcontext.h"
        -:   22:
        -:   23:/** \addtogroup ecma ECMA
        -:   24: * @{
        -:   25: *
        -:   26: * \addtogroup ecmalitstorage Literal storage
        -:   27: * @{
        -:   28: */
        -:   29:
        -:   30:#if JERRY_ESNEXT
        -:   31:/**
        -:   32: * Free symbol list
        -:   33: */
        -:   34:static void
        1:   35:ecma_free_symbol_list (jmem_cpointer_t symbol_list_cp) /**< symbol list */
        -:   36:{
        2:   37:  while (symbol_list_cp != JMEM_CP_NULL)
        -:   38:  {
    #####:   39:    ecma_lit_storage_item_t *symbol_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t, symbol_list_cp);
        -:   40:
    #####:   41:    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:   42:    {
    #####:   43:      if (symbol_list_p->values[i] != JMEM_CP_NULL)
        -:   44:      {
    #####:   45:        ecma_string_t *string_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_string_t,
        -:   46:                                                                symbol_list_p->values[i]);
        -:   47:
    #####:   48:        JERRY_ASSERT (ECMA_STRING_IS_REF_EQUALS_TO_ONE (string_p));
    #####:   49:        ecma_deref_ecma_string (string_p);
        -:   50:      }
        -:   51:    }
        -:   52:
    #####:   53:    jmem_cpointer_t next_item_cp = symbol_list_p->next_cp;
    #####:   54:    jmem_pools_free (symbol_list_p, sizeof (ecma_lit_storage_item_t));
    #####:   55:    symbol_list_cp = next_item_cp;
        -:   56:  }
        1:   57:} /* ecma_free_symbol_list */
        -:   58:#endif /* JERRY_ESNEXT */
        -:   59:
        -:   60:/**
        -:   61: * Free string list
        -:   62: */
        -:   63:static void
        1:   64:ecma_free_string_list (jmem_cpointer_t string_list_cp) /**< string list */
        -:   65:{
        4:   66:  while (string_list_cp != JMEM_CP_NULL)
        -:   67:  {
        2:   68:    ecma_lit_storage_item_t *string_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t, string_list_cp);
        -:   69:
        8:   70:    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:   71:    {
        6:   72:      if (string_list_p->values[i] != JMEM_CP_NULL)
        -:   73:      {
        6:   74:        ecma_string_t *string_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_string_t,
        -:   75:                                                                string_list_p->values[i]);
        -:   76:
        6:   77:        JERRY_ASSERT (ECMA_STRING_IS_REF_EQUALS_TO_ONE (string_p));
        6:   78:        ecma_destroy_ecma_string (string_p);
        -:   79:      }
        -:   80:    }
        -:   81:
        2:   82:    jmem_cpointer_t next_item_cp = string_list_p->next_cp;
        2:   83:    jmem_pools_free (string_list_p, sizeof (ecma_lit_storage_item_t));
        2:   84:    string_list_cp = next_item_cp;
        -:   85:  }
        1:   86:} /* ecma_free_string_list */
        -:   87:
        -:   88:/**
        -:   89: * Free number list
        -:   90: */
        -:   91:static void
        1:   92:ecma_free_number_list (jmem_cpointer_t number_list_cp) /**< number list */
        -:   93:{
        2:   94:  while (number_list_cp != JMEM_CP_NULL)
        -:   95:  {
    #####:   96:    ecma_lit_storage_item_t *number_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t,
        -:   97:                                                                           number_list_cp);
        -:   98:
    #####:   99:    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:  100:    {
    #####:  101:      if (number_list_p->values[i] != JMEM_CP_NULL)
        -:  102:      {
    #####:  103:        ecma_dealloc_number (JMEM_CP_GET_NON_NULL_POINTER (ecma_number_t, number_list_p->values[i]));
        -:  104:      }
        -:  105:    }
        -:  106:
    #####:  107:    jmem_cpointer_t next_item_cp = number_list_p->next_cp;
    #####:  108:    jmem_pools_free (number_list_p, sizeof (ecma_lit_storage_item_t));
    #####:  109:    number_list_cp = next_item_cp;
        -:  110:  }
        1:  111:} /* ecma_free_number_list */
        -:  112:
        -:  113:#if JERRY_BUILTIN_BIGINT
        -:  114:
        -:  115:/**
        -:  116: * Free bigint list
        -:  117: */
        -:  118:static void
        1:  119:ecma_free_bigint_list (jmem_cpointer_t bigint_list_cp) /**< bigint list */
        -:  120:{
        2:  121:  while (bigint_list_cp != JMEM_CP_NULL)
        -:  122:  {
    #####:  123:    ecma_lit_storage_item_t *bigint_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t,
        -:  124:                                                                           bigint_list_cp);
        -:  125:
    #####:  126:    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:  127:    {
    #####:  128:      if (bigint_list_p->values[i] != JMEM_CP_NULL)
        -:  129:      {
    #####:  130:        ecma_extended_primitive_t *bigint_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_extended_primitive_t,
        -:  131:                                                                            bigint_list_p->values[i]);
    #####:  132:        JERRY_ASSERT (ECMA_EXTENDED_PRIMITIVE_IS_REF_EQUALS_TO_ONE (bigint_p));
    #####:  133:        ecma_deref_bigint (bigint_p);
        -:  134:      }
        -:  135:    }
        -:  136:
    #####:  137:    jmem_cpointer_t next_item_cp = bigint_list_p->next_cp;
    #####:  138:    jmem_pools_free (bigint_list_p, sizeof (ecma_lit_storage_item_t));
    #####:  139:    bigint_list_cp = next_item_cp;
        -:  140:  }
        1:  141:} /* ecma_free_bigint_list */
        -:  142:
        -:  143:#endif /* JERRY_BUILTIN_BIGINT */
        -:  144:
        -:  145:/**
        -:  146: * Finalize literal storage
        -:  147: */
        -:  148:void
        1:  149:ecma_finalize_lit_storage (void)
        -:  150:{
        -:  151:#if JERRY_ESNEXT
        1:  152:  ecma_free_symbol_list (JERRY_CONTEXT (symbol_list_first_cp));
        -:  153:#endif /* JERRY_ESNEXT */
        1:  154:  ecma_free_string_list (JERRY_CONTEXT (string_list_first_cp));
        1:  155:  ecma_free_number_list (JERRY_CONTEXT (number_list_first_cp));
        -:  156:#if JERRY_BUILTIN_BIGINT
        1:  157:  ecma_free_bigint_list (JERRY_CONTEXT (bigint_list_first_cp));
        -:  158:#endif /* JERRY_BUILTIN_BIGINT */
        1:  159:} /* ecma_finalize_lit_storage */
        -:  160:
        -:  161:/**
        -:  162: * Find or create a literal string.
        -:  163: *
        -:  164: * @return ecma_string_t compressed pointer
        -:  165: */
        -:  166:ecma_value_t
       20:  167:ecma_find_or_create_literal_string (const lit_utf8_byte_t *chars_p, /**< string to be searched */
        -:  168:                                    lit_utf8_size_t size, /**< size of the string */
        -:  169:                                    bool is_ascii) /**< encode of the string */
        -:  170:{
       20:  171:  ecma_string_t *string_p = (is_ascii ? ecma_new_ecma_string_from_ascii (chars_p, size)
       20:  172:                                      : ecma_new_ecma_string_from_utf8 (chars_p, size));
        -:  173:
       20:  174:  if (ECMA_IS_DIRECT_STRING (string_p))
        -:  175:  {
       12:  176:    return ecma_make_string_value (string_p);
        -:  177:  }
        -:  178:
        8:  179:  jmem_cpointer_t string_list_cp = JERRY_CONTEXT (string_list_first_cp);
        8:  180:  jmem_cpointer_t *empty_cpointer_p = NULL;
        -:  181:
       24:  182:  while (string_list_cp != JMEM_CP_NULL)
        -:  183:  {
       10:  184:    ecma_lit_storage_item_t *string_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t, string_list_cp);
        -:  185:
       36:  186:    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:  187:    {
       28:  188:      if (string_list_p->values[i] == JMEM_CP_NULL)
        -:  189:      {
        8:  190:        if (empty_cpointer_p == NULL)
        -:  191:        {
        5:  192:          empty_cpointer_p = string_list_p->values + i;
        -:  193:        }
        -:  194:      }
        -:  195:      else
        -:  196:      {
       20:  197:        ecma_string_t *value_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_string_t,
        -:  198:                                                               string_list_p->values[i]);
        -:  199:
       20:  200:        if (ecma_compare_ecma_strings (string_p, value_p))
        -:  201:        {
        -:  202:          /* Return with string if found in the list. */
        2:  203:          ecma_deref_ecma_string (string_p);
        2:  204:          return ecma_make_string_value (value_p);
        -:  205:        }
        -:  206:      }
        -:  207:    }
        -:  208:
        8:  209:    string_list_cp = string_list_p->next_cp;
        -:  210:  }
        -:  211:
        6:  212:  ECMA_SET_STRING_AS_STATIC (string_p);
        -:  213:  jmem_cpointer_t result;
        6:  214:  JMEM_CP_SET_NON_NULL_POINTER (result, string_p);
        -:  215:
        6:  216:  if (empty_cpointer_p != NULL)
        -:  217:  {
        4:  218:    *empty_cpointer_p = result;
        4:  219:    return ecma_make_string_value (string_p);
        -:  220:  }
        -:  221:
        -:  222:  ecma_lit_storage_item_t *new_item_p;
        2:  223:  new_item_p = (ecma_lit_storage_item_t *) jmem_pools_alloc (sizeof (ecma_lit_storage_item_t));
        -:  224:
        2:  225:  new_item_p->values[0] = result;
        6:  226:  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:  227:  {
        4:  228:    new_item_p->values[i] = JMEM_CP_NULL;
        -:  229:  }
        -:  230:
        2:  231:  new_item_p->next_cp = JERRY_CONTEXT (string_list_first_cp);
        2:  232:  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (string_list_first_cp), new_item_p);
        -:  233:
        2:  234:  return ecma_make_string_value (string_p);
        -:  235:} /* ecma_find_or_create_literal_string */
        -:  236:
        -:  237:/**
        -:  238: * Find or create a literal number.
        -:  239: *
        -:  240: * @return ecma value
        -:  241: */
        -:  242:ecma_value_t
        1:  243:ecma_find_or_create_literal_number (ecma_number_t number_arg) /**< number to be searched */
        -:  244:{
        1:  245:  ecma_value_t num = ecma_make_number_value (number_arg);
        -:  246:
        1:  247:  if (ecma_is_value_integer_number (num))
        -:  248:  {
        1:  249:    return num;
        -:  250:  }
        -:  251:
    #####:  252:  JERRY_ASSERT (ecma_is_value_float_number (num));
        -:  253:
    #####:  254:  jmem_cpointer_t number_list_cp = JERRY_CONTEXT (number_list_first_cp);
    #####:  255:  jmem_cpointer_t *empty_cpointer_p = NULL;
        -:  256:
    #####:  257:  while (number_list_cp != JMEM_CP_NULL)
        -:  258:  {
    #####:  259:    ecma_lit_storage_item_t *number_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t,
        -:  260:                                                                           number_list_cp);
        -:  261:
    #####:  262:    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:  263:    {
    #####:  264:      if (number_list_p->values[i] == JMEM_CP_NULL)
        -:  265:      {
    #####:  266:        if (empty_cpointer_p == NULL)
        -:  267:        {
    #####:  268:          empty_cpointer_p = number_list_p->values + i;
        -:  269:        }
        -:  270:      }
        -:  271:      else
        -:  272:      {
    #####:  273:        ecma_number_t *number_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_number_t,
        -:  274:                                                                number_list_p->values[i]);
        -:  275:
    #####:  276:        if (*number_p == number_arg)
        -:  277:        {
    #####:  278:          ecma_free_value (num);
    #####:  279:          return ecma_make_float_value (number_p);
        -:  280:        }
        -:  281:      }
        -:  282:    }
        -:  283:
    #####:  284:    number_list_cp = number_list_p->next_cp;
        -:  285:  }
        -:  286:
        -:  287:  jmem_cpointer_t result;
    #####:  288:  JMEM_CP_SET_NON_NULL_POINTER (result, ecma_get_pointer_from_float_value (num));
        -:  289:
    #####:  290:  if (empty_cpointer_p != NULL)
        -:  291:  {
    #####:  292:    *empty_cpointer_p = result;
    #####:  293:    return num;
        -:  294:  }
        -:  295:
        -:  296:  ecma_lit_storage_item_t *new_item_p;
    #####:  297:  new_item_p = (ecma_lit_storage_item_t *) jmem_pools_alloc (sizeof (ecma_lit_storage_item_t));
        -:  298:
    #####:  299:  new_item_p->values[0] = result;
    #####:  300:  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:  301:  {
    #####:  302:    new_item_p->values[i] = JMEM_CP_NULL;
        -:  303:  }
        -:  304:
    #####:  305:  new_item_p->next_cp = JERRY_CONTEXT (number_list_first_cp);
    #####:  306:  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (number_list_first_cp), new_item_p);
        -:  307:
    #####:  308:  return num;
        -:  309:} /* ecma_find_or_create_literal_number */
        -:  310:
        -:  311:#if JERRY_BUILTIN_BIGINT
        -:  312:
        -:  313:/**
        -:  314: * Find or create a literal BigInt.
        -:  315: *
        -:  316: * @return BigInt value
        -:  317: */
        -:  318:ecma_value_t
    #####:  319:ecma_find_or_create_literal_bigint (ecma_value_t bigint) /**< bigint to be searched */
        -:  320:{
    #####:  321:  JERRY_ASSERT (ecma_is_value_bigint (bigint));
        -:  322:
    #####:  323:  if (bigint == ECMA_BIGINT_ZERO)
        -:  324:  {
    #####:  325:    return bigint;
        -:  326:  }
        -:  327:
    #####:  328:  jmem_cpointer_t bigint_list_cp = JERRY_CONTEXT (bigint_list_first_cp);
    #####:  329:  jmem_cpointer_t *empty_cpointer_p = NULL;
        -:  330:
    #####:  331:  while (bigint_list_cp != JMEM_CP_NULL)
        -:  332:  {
    #####:  333:    ecma_lit_storage_item_t *bigint_list_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_lit_storage_item_t,
        -:  334:                                                                           bigint_list_cp);
        -:  335:
    #####:  336:    for (int i = 0; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:  337:    {
    #####:  338:      if (bigint_list_p->values[i] == JMEM_CP_NULL)
        -:  339:      {
    #####:  340:        if (empty_cpointer_p == NULL)
        -:  341:        {
    #####:  342:          empty_cpointer_p = bigint_list_p->values + i;
        -:  343:        }
        -:  344:      }
        -:  345:      else
        -:  346:      {
    #####:  347:        ecma_extended_primitive_t *other_bigint_p = JMEM_CP_GET_NON_NULL_POINTER (ecma_extended_primitive_t,
        -:  348:                                                                                  bigint_list_p->values[i]);
    #####:  349:        ecma_value_t other_bigint = ecma_make_extended_primitive_value (other_bigint_p, ECMA_TYPE_BIGINT);
        -:  350:
    #####:  351:        if (ecma_bigint_is_equal_to_bigint (bigint, other_bigint))
        -:  352:        {
    #####:  353:          ecma_free_value (bigint);
    #####:  354:          return other_bigint;
        -:  355:        }
        -:  356:      }
        -:  357:    }
        -:  358:
    #####:  359:    bigint_list_cp = bigint_list_p->next_cp;
        -:  360:  }
        -:  361:
        -:  362:  jmem_cpointer_t result;
    #####:  363:  JMEM_CP_SET_NON_NULL_POINTER (result, ecma_get_extended_primitive_from_value (bigint));
        -:  364:
    #####:  365:  if (empty_cpointer_p != NULL)
        -:  366:  {
    #####:  367:    *empty_cpointer_p = result;
    #####:  368:    return bigint;
        -:  369:  }
        -:  370:
        -:  371:  ecma_lit_storage_item_t *new_item_p;
    #####:  372:  new_item_p = (ecma_lit_storage_item_t *) jmem_pools_alloc (sizeof (ecma_lit_storage_item_t));
        -:  373:
    #####:  374:  new_item_p->values[0] = result;
    #####:  375:  for (int i = 1; i < ECMA_LIT_STORAGE_VALUE_COUNT; i++)
        -:  376:  {
    #####:  377:    new_item_p->values[i] = JMEM_CP_NULL;
        -:  378:  }
        -:  379:
    #####:  380:  new_item_p->next_cp = JERRY_CONTEXT (bigint_list_first_cp);
    #####:  381:  JMEM_CP_SET_NON_NULL_POINTER (JERRY_CONTEXT (bigint_list_first_cp), new_item_p);
        -:  382:
    #####:  383:  return bigint;
        -:  384:} /* ecma_find_or_create_literal_bigint */
        -:  385:
        -:  386:#endif /* JERRY_BUILTIN_BIGINT */
        -:  387:
        -:  388:/**
        -:  389: * Log2 of snapshot literal alignment.
        -:  390: */
        -:  391:#define JERRY_SNAPSHOT_LITERAL_ALIGNMENT_LOG 1
        -:  392:
        -:  393:/**
        -:  394: * Snapshot literal alignment.
        -:  395: */
        -:  396:#define JERRY_SNAPSHOT_LITERAL_ALIGNMENT (1u << JERRY_SNAPSHOT_LITERAL_ALIGNMENT_LOG)
        -:  397:
        -:  398:/**
        -:  399: * Literal offset shift.
        -:  400: */
        -:  401:#define JERRY_SNAPSHOT_LITERAL_SHIFT (ECMA_VALUE_SHIFT + 2)
        -:  402:
        -:  403:/**
        -:  404: * Literal value is number.
        -:  405: */
        -:  406:#define JERRY_SNAPSHOT_LITERAL_IS_NUMBER (1u << ECMA_VALUE_SHIFT)
        -:  407:
        -:  408:#if JERRY_BUILTIN_BIGINT
        -:  409:/**
        -:  410: * Literal value is BigInt.
        -:  411: */
        -:  412:#define JERRY_SNAPSHOT_LITERAL_IS_BIGINT (2u << ECMA_VALUE_SHIFT)
        -:  413:#endif /* JERRY_BUILTIN_BIGINT */
        -:  414:
        -:  415:#if JERRY_SNAPSHOT_SAVE
        -:  416:
        -:  417:/**
        -:  418: * Append the value at the end of the appropriate list if it is not present there.
        -:  419: */
    #####:  420:void ecma_save_literals_append_value (ecma_value_t value, /**< value to be appended */
        -:  421:                                      ecma_collection_t *lit_pool_p) /**< list of known values */
        -:  422:{
        -:  423:  /* Unlike direct numbers, direct strings are converted to character literals. */
    #####:  424:  if (!ecma_is_value_string (value)
        -:  425:#if JERRY_BUILTIN_BIGINT
    #####:  426:      && (!ecma_is_value_bigint (value) || value == ECMA_BIGINT_ZERO)
        -:  427:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  428:      && !ecma_is_value_float_number (value))
        -:  429:  {
        -:  430:    return;
        -:  431:  }
        -:  432:
    #####:  433:  ecma_value_t *buffer_p = lit_pool_p->buffer_p;
        -:  434:
    #####:  435:  for (uint32_t i = 0; i < lit_pool_p->item_count; i++)
        -:  436:  {
        -:  437:    /* Strings / numbers are direct strings or stored in the literal storage.
        -:  438:     * Therefore direct comparison is enough to find the same strings / numbers. */
    #####:  439:    if (buffer_p[i] == value)
        -:  440:    {
        -:  441:      return;
        -:  442:    }
        -:  443:  }
        -:  444:
    #####:  445:  ecma_collection_push_back (lit_pool_p, value);
        -:  446:} /* ecma_save_literals_append_value */
        -:  447:
        -:  448:/**
        -:  449: * Add names from a byte-code data to a list.
        -:  450: */
        -:  451:void
    #####:  452:ecma_save_literals_add_compiled_code (const ecma_compiled_code_t *compiled_code_p, /**< byte-code data */
        -:  453:                                      ecma_collection_t *lit_pool_p) /**< list of known values */
        -:  454:{
        -:  455:  ecma_value_t *literal_p;
        -:  456:  uint32_t argument_end;
        -:  457:  uint32_t register_end;
        -:  458:  uint32_t const_literal_end;
        -:  459:  uint32_t literal_end;
        -:  460:
        -:  461:  JERRY_ASSERT (CBC_IS_FUNCTION (compiled_code_p->status_flags));
        -:  462:
    #####:  463:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  464:  {
    #####:  465:    cbc_uint16_arguments_t *args_p = (cbc_uint16_arguments_t *) compiled_code_p;
    #####:  466:    uint8_t *byte_p = (uint8_t *) compiled_code_p;
        -:  467:
    #####:  468:    literal_p = (ecma_value_t *) (byte_p + sizeof (cbc_uint16_arguments_t));
    #####:  469:    register_end = args_p->register_end;
    #####:  470:    const_literal_end = args_p->const_literal_end - register_end;
    #####:  471:    literal_end = args_p->literal_end - register_end;
    #####:  472:    argument_end = args_p->argument_end;
        -:  473:  }
        -:  474:  else
        -:  475:  {
    #####:  476:    cbc_uint8_arguments_t *args_p = (cbc_uint8_arguments_t *) compiled_code_p;
    #####:  477:    uint8_t *byte_p = (uint8_t *) compiled_code_p;
        -:  478:
    #####:  479:    literal_p = (ecma_value_t *) (byte_p + sizeof (cbc_uint8_arguments_t));
    #####:  480:    register_end = args_p->register_end;
    #####:  481:    const_literal_end = args_p->const_literal_end - register_end;
    #####:  482:    literal_end = args_p->literal_end - register_end;
    #####:  483:    argument_end = args_p->argument_end;
        -:  484:  }
        -:  485:
    #####:  486:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)
        -:  487:  {
    #####:  488:    for (uint32_t i = 0; i < argument_end; i++)
        -:  489:    {
    #####:  490:      ecma_save_literals_append_value (literal_p[i], lit_pool_p);
        -:  491:    }
        -:  492:  }
        -:  493:
    #####:  494:  for (uint32_t i = 0; i < const_literal_end; i++)
        -:  495:  {
    #####:  496:    ecma_save_literals_append_value (literal_p[i], lit_pool_p);
        -:  497:  }
        -:  498:
    #####:  499:  for (uint32_t i = const_literal_end; i < literal_end; i++)
        -:  500:  {
    #####:  501:    ecma_compiled_code_t *bytecode_p = ECMA_GET_INTERNAL_VALUE_POINTER (ecma_compiled_code_t,
        -:  502:                                                                        literal_p[i]);
        -:  503:
    #####:  504:    if (CBC_IS_FUNCTION (bytecode_p->status_flags)
    #####:  505:        && bytecode_p != compiled_code_p)
        -:  506:    {
    #####:  507:      ecma_save_literals_add_compiled_code (bytecode_p, lit_pool_p);
        -:  508:    }
        -:  509:  }
        -:  510:
    #####:  511:  uint8_t *byte_p = ((uint8_t *) compiled_code_p) + (((size_t) compiled_code_p->size) << JMEM_ALIGNMENT_LOG);
    #####:  512:  literal_p = ecma_snapshot_resolve_serializable_values ((ecma_compiled_code_t *) compiled_code_p, byte_p);
        -:  513:
    #####:  514:  while (literal_p < (ecma_value_t *) byte_p)
        -:  515:  {
    #####:  516:    ecma_save_literals_append_value (*literal_p, lit_pool_p);
    #####:  517:    literal_p++;
        -:  518:  }
    #####:  519:} /* ecma_save_literals_add_compiled_code */
        -:  520:
        -:  521:/**
        -:  522: * Save literals to specified snapshot buffer.
        -:  523: *
        -:  524: * Note:
        -:  525: *      Frees 'lit_pool_p' regardless of success.
        -:  526: *
        -:  527: * @return true - if save was performed successfully (i.e. buffer size is sufficient),
        -:  528: *         false - otherwise
        -:  529: */
        -:  530:bool
    #####:  531:ecma_save_literals_for_snapshot (ecma_collection_t *lit_pool_p, /**< list of known values */
        -:  532:                                 uint32_t *buffer_p, /**< [out] output snapshot buffer */
        -:  533:                                 size_t buffer_size, /**< size of the buffer */
        -:  534:                                 size_t *in_out_buffer_offset_p, /**< [in,out] write position in the buffer */
        -:  535:                                 lit_mem_to_snapshot_id_map_entry_t **out_map_p, /**< [out] map from literal identifiers
        -:  536:                                                                                  *   to the literal offsets
        -:  537:                                                                                  *   in snapshot */
        -:  538:                                 uint32_t *out_map_len_p) /**< [out] number of literals */
        -:  539:{
    #####:  540:  if (lit_pool_p->item_count == 0)
        -:  541:  {
    #####:  542:    *out_map_p = NULL;
    #####:  543:    *out_map_len_p = 0;
        -:  544:  }
        -:  545:
    #####:  546:  uint32_t lit_table_size = 0;
    #####:  547:  size_t max_lit_table_size = buffer_size - *in_out_buffer_offset_p;
        -:  548:
    #####:  549:  if (max_lit_table_size > (UINT32_MAX >> JERRY_SNAPSHOT_LITERAL_SHIFT))
        -:  550:  {
    #####:  551:    max_lit_table_size = (UINT32_MAX >> JERRY_SNAPSHOT_LITERAL_SHIFT);
        -:  552:  }
        -:  553:
    #####:  554:  ecma_value_t *lit_buffer_p = lit_pool_p->buffer_p;
        -:  555:
        -:  556:  /* Compute the size of the literal pool. */
    #####:  557:  for (uint32_t i = 0; i < lit_pool_p->item_count; i++)
        -:  558:  {
    #####:  559:    if (ecma_is_value_float_number (lit_buffer_p[i]))
        -:  560:    {
    #####:  561:      lit_table_size += (uint32_t) sizeof (ecma_number_t);
        -:  562:    }
        -:  563:#if JERRY_BUILTIN_BIGINT
    #####:  564:    else if (ecma_is_value_bigint (lit_buffer_p[i]))
        -:  565:    {
    #####:  566:      ecma_extended_primitive_t *bigint_p = ecma_get_extended_primitive_from_value (lit_buffer_p[i]);
        -:  567:
    #####:  568:      lit_table_size += (uint32_t) JERRY_ALIGNUP (sizeof (uint32_t) + ECMA_BIGINT_GET_SIZE (bigint_p),
        -:  569:                                                  JERRY_SNAPSHOT_LITERAL_ALIGNMENT);
        -:  570:    }
        -:  571:#endif /* JERRY_BUILTIN_BIGINT */
        -:  572:    else
        -:  573:    {
    #####:  574:      ecma_string_t *string_p = ecma_get_string_from_value (lit_buffer_p[i]);
        -:  575:
    #####:  576:      lit_table_size += (uint32_t) JERRY_ALIGNUP (sizeof (uint16_t) + ecma_string_get_size (string_p),
        -:  577:                                                  JERRY_SNAPSHOT_LITERAL_ALIGNMENT);
        -:  578:    }
        -:  579:
        -:  580:    /* Check whether enough space is available and the maximum size is not reached. */
    #####:  581:    if (lit_table_size > max_lit_table_size)
        -:  582:    {
    #####:  583:      ecma_collection_destroy (lit_pool_p);
    #####:  584:      return false;
        -:  585:    }
        -:  586:  }
        -:  587:
        -:  588:  lit_mem_to_snapshot_id_map_entry_t *map_p;
    #####:  589:  uint32_t total_count = lit_pool_p->item_count;
        -:  590:
    #####:  591:  map_p = jmem_heap_alloc_block (total_count * sizeof (lit_mem_to_snapshot_id_map_entry_t));
        -:  592:
        -:  593:  /* Set return values (no error is possible from here). */
        -:  594:  JERRY_ASSERT ((*in_out_buffer_offset_p % sizeof (uint32_t)) == 0);
        -:  595:
    #####:  596:  uint8_t *destination_p = (uint8_t *) (buffer_p + (*in_out_buffer_offset_p / sizeof (uint32_t)));
    #####:  597:  uint32_t literal_offset = 0;
        -:  598:
    #####:  599:  *in_out_buffer_offset_p += lit_table_size;
    #####:  600:  *out_map_p = map_p;
    #####:  601:  *out_map_len_p = total_count;
        -:  602:
    #####:  603:  lit_buffer_p = lit_pool_p->buffer_p;
        -:  604:
        -:  605:  /* Generate literal pool data. */
    #####:  606:  for (uint32_t i = 0; i < lit_pool_p->item_count; i++)
        -:  607:  {
    #####:  608:    map_p->literal_id = lit_buffer_p[i];
    #####:  609:    map_p->literal_offset = (literal_offset << JERRY_SNAPSHOT_LITERAL_SHIFT) | ECMA_TYPE_SNAPSHOT_OFFSET;
        -:  610:
        -:  611:    lit_utf8_size_t length;
        -:  612:
    #####:  613:    if (ecma_is_value_float_number (lit_buffer_p[i]))
        -:  614:    {
    #####:  615:      map_p->literal_offset |= JERRY_SNAPSHOT_LITERAL_IS_NUMBER;
        -:  616:
    #####:  617:      ecma_number_t num = ecma_get_float_from_value (lit_buffer_p[i]);
    #####:  618:      memcpy (destination_p, &num, sizeof (ecma_number_t));
        -:  619:
    #####:  620:      length = JERRY_ALIGNUP (sizeof (ecma_number_t), JERRY_SNAPSHOT_LITERAL_ALIGNMENT);
        -:  621:    }
        -:  622:#if JERRY_BUILTIN_BIGINT
    #####:  623:    else if (ecma_is_value_bigint (lit_buffer_p[i]))
        -:  624:    {
    #####:  625:      map_p->literal_offset |= JERRY_SNAPSHOT_LITERAL_IS_BIGINT;
        -:  626:
    #####:  627:      ecma_extended_primitive_t *bigint_p = ecma_get_extended_primitive_from_value (lit_buffer_p[i]);
    #####:  628:      uint32_t size = ECMA_BIGINT_GET_SIZE (bigint_p);
        -:  629:
    #####:  630:      memcpy (destination_p, &bigint_p->u.bigint_sign_and_size, sizeof (uint32_t));
    #####:  631:      memcpy (destination_p + sizeof (uint32_t), ECMA_BIGINT_GET_DIGITS (bigint_p, 0), size);
        -:  632:
    #####:  633:      length = JERRY_ALIGNUP (sizeof (uint32_t) + size, JERRY_SNAPSHOT_LITERAL_ALIGNMENT);
        -:  634:    }
        -:  635:#endif /* JERRY_BUILTIN_BIGINT */
        -:  636:    else
        -:  637:    {
    #####:  638:      ecma_string_t *string_p = ecma_get_string_from_value (lit_buffer_p[i]);
    #####:  639:      length = ecma_string_get_size (string_p);
        -:  640:
    #####:  641:      *(uint16_t *) destination_p = (uint16_t) length;
        -:  642:
    #####:  643:      ecma_string_to_utf8_bytes (string_p, destination_p + sizeof (uint16_t), length);
        -:  644:
    #####:  645:      length = JERRY_ALIGNUP (sizeof (uint16_t) + length, JERRY_SNAPSHOT_LITERAL_ALIGNMENT);
        -:  646:    }
        -:  647:
        -:  648:    JERRY_ASSERT ((length % sizeof (uint16_t)) == 0);
    #####:  649:    destination_p += length;
    #####:  650:    literal_offset += length;
        -:  651:
    #####:  652:    map_p++;
        -:  653:  }
        -:  654:
    #####:  655:  ecma_collection_destroy (lit_pool_p);
    #####:  656:  return true;
        -:  657:} /* ecma_save_literals_for_snapshot */
        -:  658:
        -:  659:#endif /* JERRY_SNAPSHOT_SAVE */
        -:  660:
        -:  661:#if JERRY_SNAPSHOT_EXEC || JERRY_SNAPSHOT_SAVE
        -:  662:
        -:  663:/**
        -:  664: * Get the compressed pointer of a given literal.
        -:  665: *
        -:  666: * @return literal compressed pointer
        -:  667: */
        -:  668:ecma_value_t
    #####:  669:ecma_snapshot_get_literal (const uint8_t *literal_base_p, /**< literal start */
        -:  670:                           ecma_value_t literal_value) /**< string / number offset */
        -:  671:{
        -:  672:  JERRY_ASSERT ((literal_value & ECMA_VALUE_TYPE_MASK) == ECMA_TYPE_SNAPSHOT_OFFSET);
        -:  673:
    #####:  674:  const uint8_t *literal_p = literal_base_p + (literal_value >> JERRY_SNAPSHOT_LITERAL_SHIFT);
        -:  675:
    #####:  676:  if (literal_value & JERRY_SNAPSHOT_LITERAL_IS_NUMBER)
        -:  677:  {
        -:  678:    ecma_number_t num;
    #####:  679:    memcpy (&num, literal_p, sizeof (ecma_number_t));
    #####:  680:    return ecma_find_or_create_literal_number (num);
        -:  681:  }
        -:  682:
        -:  683:#if JERRY_BUILTIN_BIGINT
    #####:  684:  if (literal_value & JERRY_SNAPSHOT_LITERAL_IS_BIGINT)
        -:  685:  {
    #####:  686:    uint32_t bigint_sign_and_size = *(uint32_t *) literal_p;
    #####:  687:    uint32_t size = bigint_sign_and_size & ~(uint32_t) (sizeof (ecma_bigint_digit_t) - 1);
        -:  688:
    #####:  689:    ecma_extended_primitive_t *bigint_p = ecma_bigint_create (size);
        -:  690:
    #####:  691:    if (bigint_p == NULL)
        -:  692:    {
    #####:  693:      jerry_fatal (ERR_OUT_OF_MEMORY);
        -:  694:    }
        -:  695:
        -:  696:    /* Only the sign bit can differ. */
        -:  697:    JERRY_ASSERT (bigint_p->u.bigint_sign_and_size == (bigint_sign_and_size & ~(uint32_t) ECMA_BIGINT_SIGN));
        -:  698:
    #####:  699:    bigint_p->u.bigint_sign_and_size = bigint_sign_and_size;
    #####:  700:    memcpy (ECMA_BIGINT_GET_DIGITS (bigint_p, 0), literal_p + sizeof (uint32_t), size);
    #####:  701:    return ecma_find_or_create_literal_bigint (ecma_make_extended_primitive_value (bigint_p, ECMA_TYPE_BIGINT));
        -:  702:  }
        -:  703:#endif /* JERRY_BUILTIN_BIGINT */
        -:  704:
    #####:  705:  uint16_t length = *(const uint16_t *) literal_p;
        -:  706:
    #####:  707:  return ecma_find_or_create_literal_string (literal_p + sizeof (uint16_t), length, false);
        -:  708:} /* ecma_snapshot_get_literal */
        -:  709:
        -:  710:/**
        -:  711: * Compute the start of the serializable ecma-values of the bytecode
        -:  712: * Related values:
        -:  713: *  - function argument names, if CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED is present
        -:  714: *  - function name, if CBC_CODE_FLAGS_CLASS_CONSTRUCTOR is not present and ES.next profile is enabled
        -:  715: *
        -:  716: * @return pointer to the beginning of the serializable ecma-values
        -:  717: */
        -:  718:ecma_value_t *
    #####:  719:ecma_snapshot_resolve_serializable_values (const ecma_compiled_code_t *compiled_code_p, /**< compiled code */
        -:  720:                                           uint8_t *bytecode_end_p) /**< end of the bytecode */
        -:  721:{
    #####:  722:  ecma_value_t *base_p = (ecma_value_t *) bytecode_end_p;
        -:  723:
    #####:  724:  if (compiled_code_p->status_flags & CBC_CODE_FLAGS_MAPPED_ARGUMENTS_NEEDED)
        -:  725:  {
        -:  726:    uint32_t argument_end;
    #####:  727:    if (compiled_code_p->status_flags & CBC_CODE_FLAGS_UINT16_ARGUMENTS)
        -:  728:    {
    #####:  729:      argument_end = ((cbc_uint16_arguments_t *) compiled_code_p)->argument_end;
        -:  730:    }
        -:  731:    else
        -:  732:    {
    #####:  733:      argument_end = ((cbc_uint8_arguments_t *) compiled_code_p)->argument_end;
        -:  734:    }
        -:  735:
    #####:  736:    base_p -= argument_end;
        -:  737:  }
        -:  738:
        -:  739:#if JERRY_ESNEXT
        -:  740:  /* function name */
    #####:  741:  if (CBC_FUNCTION_GET_TYPE (compiled_code_p->status_flags) != CBC_FUNCTION_CONSTRUCTOR)
        -:  742:  {
    #####:  743:    base_p--;
        -:  744:  }
        -:  745:#endif /* JERRY_ESNEXT */
        -:  746:
    #####:  747:  return base_p;
        -:  748:} /* ecma_snapshot_resolve_serializable_values */
        -:  749:#endif /* JERRY_SNAPSHOT_EXEC || JERRY_SNAPSHOT_SAVE */
        -:  750:
        -:  751:/**
        -:  752: * @}
        -:  753: * @}
        -:  754: */
