        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-comparison.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-bigint.h"
        -:   17:#include "ecma-comparison.h"
        -:   18:#include "ecma-conversion.h"
        -:   19:#include "ecma-globals.h"
        -:   20:#include "ecma-objects.h"
        -:   21:#include "jrt.h"
        -:   22:
        -:   23:/** \addtogroup ecma ECMA
        -:   24: * @{
        -:   25: *
        -:   26: * \addtogroup ecmacomparison ECMA comparison
        -:   27: * @{
        -:   28: */
        -:   29:
        -:   30:/**
        -:   31: * ECMA abstract equality comparison routine.
        -:   32: *
        -:   33: * See also: ECMA-262 v5, 11.9.3
        -:   34: *
        -:   35: * Note:
        -:   36: *      This function might raise an exception, so the
        -:   37: *      returned value must be freed with ecma_free_value.
        -:   38: *
        -:   39: * @return true - if values are equal,
        -:   40: *         false - otherwise
        -:   41: *         error - in case of any problems
        -:   42: */
        -:   43:ecma_value_t
        2:   44:ecma_op_abstract_equality_compare (ecma_value_t x, /**< first operand */
        -:   45:                                   ecma_value_t y) /**< second operand */
        -:   46:{
        2:   47:  if (x == y)
        -:   48:  {
        1:   49:    return ECMA_VALUE_TRUE;
        -:   50:  }
        -:   51:
        1:   52:  if (ecma_are_values_integer_numbers (x, y))
        -:   53:  {
        -:   54:    /* Note: the (x == y) comparison captures the true case. */
        1:   55:    return ECMA_VALUE_FALSE;
        -:   56:  }
        -:   57:
    #####:   58:  if (ecma_is_value_number (x))
        -:   59:  {
    #####:   60:    if (ecma_is_value_number (y))
        -:   61:    {
        -:   62:      /* 1.c */
    #####:   63:      ecma_number_t x_num = ecma_get_number_from_value (x);
    #####:   64:      ecma_number_t y_num = ecma_get_number_from_value (y);
        -:   65:
    #####:   66:      bool is_x_equal_to_y = (x_num == y_num);
        -:   67:
        -:   68:#ifndef JERRY_NDEBUG
        -:   69:      bool is_x_equal_to_y_check;
        -:   70:
    #####:   71:      if (ecma_number_is_nan (x_num)
    #####:   72:          || ecma_number_is_nan (y_num))
        -:   73:      {
    #####:   74:        is_x_equal_to_y_check = false;
        -:   75:      }
    #####:   76:      else if (x_num == y_num
    #####:   77:               || (ecma_number_is_zero (x_num)
    #####:   78:                   && ecma_number_is_zero (y_num)))
        -:   79:      {
    #####:   80:        is_x_equal_to_y_check = true;
        -:   81:      }
        -:   82:      else
        -:   83:      {
    #####:   84:        is_x_equal_to_y_check = false;
        -:   85:      }
        -:   86:
    #####:   87:      JERRY_ASSERT (is_x_equal_to_y == is_x_equal_to_y_check);
        -:   88:#endif /* !JERRY_NDEBUG */
        -:   89:
    #####:   90:      return ecma_make_boolean_value (is_x_equal_to_y);
        -:   91:    }
        -:   92:
        -:   93:    /* Swap values. */
    #####:   94:    x ^= y;
    #####:   95:    y ^= x;
    #####:   96:    x ^= y;
        -:   97:  }
        -:   98:
    #####:   99:  if (ecma_is_value_string (x))
        -:  100:  {
    #####:  101:    if (ecma_is_value_string (y))
        -:  102:    {
        -:  103:      /* 1., d. */
    #####:  104:      ecma_string_t *x_str_p = ecma_get_string_from_value (x);
    #####:  105:      ecma_string_t *y_str_p = ecma_get_string_from_value (y);
        -:  106:
    #####:  107:      bool is_equal = ecma_compare_ecma_strings (x_str_p, y_str_p);
        -:  108:
    #####:  109:      return ecma_make_boolean_value (is_equal);
        -:  110:    }
        -:  111:
    #####:  112:    if (ecma_is_value_number (y))
        -:  113:    {
        -:  114:      /* 4. */
    #####:  115:      ecma_number_t num;
    #####:  116:      ecma_value_t x_num_value = ecma_op_to_number (x, &num);
        -:  117:
    #####:  118:      if (ECMA_IS_VALUE_ERROR (x_num_value))
        -:  119:      {
    #####:  120:        return x_num_value;
        -:  121:      }
    #####:  122:      ecma_value_t num_value = ecma_make_number_value (num);
    #####:  123:      ecma_value_t compare_result = ecma_op_abstract_equality_compare (num_value, y);
        -:  124:
    #####:  125:      ecma_free_value (num_value);
    #####:  126:      return compare_result;
        -:  127:    }
        -:  128:
        -:  129:    /* Swap values. */
    #####:  130:    x ^= y;
    #####:  131:    y ^= x;
    #####:  132:    x ^= y;
        -:  133:  }
        -:  134:
    #####:  135:  if (ecma_is_value_boolean (y))
        -:  136:  {
    #####:  137:    if (ecma_is_value_boolean (x))
        -:  138:    {
        -:  139:      /* 1., e. */
        -:  140:      /* Note: the (x == y) comparison captures the true case. */
    #####:  141:      return ECMA_VALUE_FALSE;
        -:  142:    }
        -:  143:
        -:  144:    /* 7. */
    #####:  145:    return ecma_op_abstract_equality_compare (x, ecma_make_integer_value (ecma_is_value_true (y) ? 1 : 0));
        -:  146:  }
        -:  147:
    #####:  148:  if (ecma_is_value_boolean (x))
        -:  149:  {
        -:  150:    /* 6. */
    #####:  151:    return ecma_op_abstract_equality_compare (ecma_make_integer_value (ecma_is_value_true (x) ? 1 : 0), y);
        -:  152:  }
        -:  153:
        -:  154:#if JERRY_BUILTIN_BIGINT
    #####:  155:  if (JERRY_UNLIKELY (ecma_is_value_bigint (x)))
        -:  156:  {
    #####:  157:    if (ecma_is_value_bigint (y))
        -:  158:    {
    #####:  159:      return ecma_make_boolean_value (ecma_bigint_is_equal_to_bigint (x, y));
        -:  160:    }
        -:  161:
    #####:  162:    if (ecma_is_value_string (y))
        -:  163:    {
    #####:  164:      ecma_value_t bigint = ecma_bigint_parse_string_value (y, ECMA_BIGINT_PARSE_DISALLOW_SYNTAX_ERROR);
        -:  165:
    #####:  166:      if (ECMA_IS_VALUE_ERROR (bigint)
    #####:  167:          || bigint == ECMA_VALUE_FALSE)
        -:  168:      {
    #####:  169:        return bigint;
        -:  170:      }
        -:  171:
    #####:  172:      JERRY_ASSERT (ecma_is_value_bigint (bigint));
        -:  173:
    #####:  174:      ecma_value_t result = ecma_make_boolean_value (ecma_bigint_is_equal_to_bigint (x, bigint));
        -:  175:
    #####:  176:      ecma_free_value (bigint);
    #####:  177:      return result;
        -:  178:    }
        -:  179:
    #####:  180:    if (ecma_is_value_number (y))
        -:  181:    {
    #####:  182:      return ecma_make_boolean_value (ecma_bigint_is_equal_to_number (x, ecma_get_number_from_value (y)));
        -:  183:    }
        -:  184:
        -:  185:    /* Swap values. */
    #####:  186:    x ^= y;
    #####:  187:    y ^= x;
    #####:  188:    x ^= y;
        -:  189:  }
        -:  190:#endif /* JERRY_BUILTIN_BIGINT */
        -:  191:
    #####:  192:  if (ecma_is_value_undefined (x)
    #####:  193:      || ecma_is_value_null (x))
        -:  194:  {
        -:  195:    /* 1. a., b. */
        -:  196:    /* 2., 3. */
    #####:  197:    bool is_equal = ecma_is_value_undefined (y) || ecma_is_value_null (y);
        -:  198:
    #####:  199:    return ecma_make_boolean_value (is_equal);
        -:  200:  }
        -:  201:
        -:  202:#if JERRY_ESNEXT
    #####:  203:  if (JERRY_UNLIKELY (ecma_is_value_symbol (x)))
        -:  204:  {
    #####:  205:    if (!ecma_is_value_object (y))
        -:  206:    {
    #####:  207:      return ECMA_VALUE_FALSE;
        -:  208:    }
        -:  209:
        -:  210:    /* Swap values. */
    #####:  211:    x ^= y;
    #####:  212:    y ^= x;
    #####:  213:    x ^= y;
        -:  214:  }
        -:  215:#endif /* JERRY_ESNEXT */
        -:  216:
    #####:  217:  JERRY_ASSERT (ecma_is_value_object (x));
        -:  218:
    #####:  219:  if (ecma_is_value_string (y)
        -:  220:#if JERRY_ESNEXT
    #####:  221:      || ecma_is_value_symbol (y)
        -:  222:#endif /* JERRY_ESNEXT */
        -:  223:#if JERRY_BUILTIN_BIGINT
    #####:  224:      || ecma_is_value_bigint (y)
        -:  225:#endif /* JERRY_BUILTIN_BIGINT */
    #####:  226:      || ecma_is_value_number (y))
        -:  227:  {
        -:  228:    /* 9. */
    #####:  229:    ecma_object_t *obj_p = ecma_get_object_from_value (x);
        -:  230:
    #####:  231:    ecma_value_t def_value = ecma_op_object_default_value (obj_p, ECMA_PREFERRED_TYPE_NO);
        -:  232:
    #####:  233:    if (ECMA_IS_VALUE_ERROR (def_value))
        -:  234:    {
    #####:  235:      return def_value;
        -:  236:    }
        -:  237:
    #####:  238:    ecma_value_t compare_result = ecma_op_abstract_equality_compare (def_value, y);
        -:  239:
    #####:  240:    ecma_free_value (def_value);
        -:  241:
    #####:  242:    return compare_result;
        -:  243:  }
        -:  244:
    #####:  245:  return ECMA_VALUE_FALSE;
        -:  246:} /* ecma_op_abstract_equality_compare */
        -:  247:
        -:  248:/**
        -:  249: * ECMA strict equality comparison routine.
        -:  250: *
        -:  251: * See also: ECMA-262 v5, 11.9.6
        -:  252: *
        -:  253: * @return true - if values are strict equal,
        -:  254: *         false - otherwise
        -:  255: */
        -:  256:bool
    #####:  257:ecma_op_strict_equality_compare (ecma_value_t x, /**< first operand */
        -:  258:                                 ecma_value_t y) /**< second operand */
        -:  259:{
    #####:  260:  if (ecma_is_value_direct (x)
    #####:  261:      || ecma_is_value_direct (y)
        -:  262:#if JERRY_ESNEXT
    #####:  263:      || ecma_is_value_symbol (x)
    #####:  264:      || ecma_is_value_symbol (y)
        -:  265:#endif /* JERRY_ESNEXT */
    #####:  266:      || ecma_is_value_object (x)
    #####:  267:      || ecma_is_value_object (y))
        -:  268:  {
    #####:  269:    JERRY_ASSERT (!ecma_is_value_direct (x)
        -:  270:                  || ecma_is_value_undefined (x)
        -:  271:                  || ecma_is_value_null (x)
        -:  272:                  || ecma_is_value_boolean (x)
        -:  273:                  || ecma_is_value_integer_number (x));
        -:  274:
    #####:  275:    JERRY_ASSERT (!ecma_is_value_direct (y)
        -:  276:                  || ecma_is_value_undefined (y)
        -:  277:                  || ecma_is_value_null (y)
        -:  278:                  || ecma_is_value_boolean (y)
        -:  279:                  || ecma_is_value_integer_number (y));
        -:  280:
    #####:  281:    if ((x != ecma_make_integer_value (0) || !ecma_is_value_float_number (y))
    #####:  282:        && (y != ecma_make_integer_value (0) || !ecma_is_value_float_number (x)))
        -:  283:    {
    #####:  284:      return (x == y);
        -:  285:    }
        -:  286:
        -:  287:    /* The +0 === -0 case handled below. */
        -:  288:  }
        -:  289:
    #####:  290:  JERRY_ASSERT (ecma_is_value_number (x) || ecma_is_value_string (x) ||
        -:  291:                ecma_is_value_bigint (x));
    #####:  292:  JERRY_ASSERT (ecma_is_value_number (y) || ecma_is_value_string (y) ||
        -:  293:                ecma_is_value_bigint (y));
        -:  294:
    #####:  295:  if (ecma_is_value_string (x))
        -:  296:  {
    #####:  297:    if (!ecma_is_value_string (y))
        -:  298:    {
    #####:  299:      return false;
        -:  300:    }
        -:  301:
    #####:  302:    ecma_string_t *x_str_p = ecma_get_string_from_value (x);
    #####:  303:    ecma_string_t *y_str_p = ecma_get_string_from_value (y);
        -:  304:
    #####:  305:    return ecma_compare_ecma_strings (x_str_p, y_str_p);
        -:  306:  }
        -:  307:
        -:  308:#if JERRY_BUILTIN_BIGINT
    #####:  309:  if (JERRY_UNLIKELY (ecma_is_value_bigint (x)))
        -:  310:  {
    #####:  311:    if (!ecma_is_value_bigint (y))
        -:  312:    {
    #####:  313:      return false;
        -:  314:    }
        -:  315:
    #####:  316:    return ecma_bigint_is_equal_to_bigint (x, y);
        -:  317:  }
        -:  318:#endif /* JERRY_BUILTIN_BIGINT */
        -:  319:
    #####:  320:  if (!ecma_is_value_number (y))
        -:  321:  {
    #####:  322:    return false;
        -:  323:  }
        -:  324:
    #####:  325:  ecma_number_t x_num = ecma_get_number_from_value (x);
    #####:  326:  ecma_number_t y_num = ecma_get_number_from_value (y);
        -:  327:
    #####:  328:  bool is_x_equal_to_y = (x_num == y_num);
        -:  329:
        -:  330:#ifndef JERRY_NDEBUG
        -:  331:  bool is_x_equal_to_y_check;
        -:  332:
    #####:  333:  if (ecma_number_is_nan (x_num)
    #####:  334:      || ecma_number_is_nan (y_num))
        -:  335:  {
    #####:  336:    is_x_equal_to_y_check = false;
        -:  337:  }
    #####:  338:  else if (x_num == y_num
    #####:  339:           || (ecma_number_is_zero (x_num)
    #####:  340:               && ecma_number_is_zero (y_num)))
        -:  341:  {
    #####:  342:    is_x_equal_to_y_check = true;
        -:  343:  }
        -:  344:  else
        -:  345:  {
    #####:  346:    is_x_equal_to_y_check = false;
        -:  347:  }
        -:  348:
    #####:  349:  JERRY_ASSERT (is_x_equal_to_y == is_x_equal_to_y_check);
        -:  350:#endif /* !JERRY_NDEBUG */
        -:  351:
    #####:  352:  return is_x_equal_to_y;
        -:  353:} /* ecma_op_strict_equality_compare */
        -:  354:
        -:  355:/**
        -:  356: * ECMA abstract relational comparison routine.
        -:  357: *
        -:  358: * See also: ECMA-262 v5, 11.8.5
        -:  359: *
        -:  360: * @return ecma value
        -:  361: *         Returned value must be freed with ecma_free_value
        -:  362: */
        -:  363:ecma_value_t
    #####:  364:ecma_op_abstract_relational_compare (ecma_value_t x, /**< first operand */
        -:  365:                                     ecma_value_t y, /**< second operand */
        -:  366:                                     bool left_first) /**< 'LeftFirst' flag */
        -:  367:{
    #####:  368:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  369:
        -:  370:  /* 1., 2. */
    #####:  371:  ecma_value_t prim_first_converted_value = ecma_op_to_primitive (x, ECMA_PREFERRED_TYPE_NUMBER);
    #####:  372:  if (ECMA_IS_VALUE_ERROR (prim_first_converted_value))
        -:  373:  {
    #####:  374:    return prim_first_converted_value;
        -:  375:  }
        -:  376:
    #####:  377:  ecma_value_t prim_second_converted_value = ecma_op_to_primitive (y, ECMA_PREFERRED_TYPE_NUMBER);
    #####:  378:  if (ECMA_IS_VALUE_ERROR (prim_second_converted_value))
        -:  379:  {
    #####:  380:    ecma_free_value (prim_first_converted_value);
    #####:  381:    return prim_second_converted_value;
        -:  382:  }
        -:  383:
    #####:  384:  ecma_value_t px = left_first ? prim_first_converted_value : prim_second_converted_value;
    #####:  385:  ecma_value_t py = left_first ? prim_second_converted_value : prim_first_converted_value;
        -:  386:
    #####:  387:  const bool is_px_string = ecma_is_value_string (px);
    #####:  388:  const bool is_py_string = ecma_is_value_string (py);
        -:  389:
    #####:  390:  if (!(is_px_string && is_py_string))
        -:  391:  {
        -:  392:#if JERRY_BUILTIN_BIGINT
    #####:  393:    if (JERRY_LIKELY (!ecma_is_value_bigint (px))
    #####:  394:        && JERRY_LIKELY (!ecma_is_value_bigint (py)))
    #####:  395:    {
        -:  396:#endif /* JERRY_BUILTIN_BIGINT */
        -:  397:      /* 3. */
        -:  398:
        -:  399:      /* a. */
        -:  400:
    #####:  401:      ecma_number_t nx;
    #####:  402:      ecma_number_t ny;
        -:  403:
    #####:  404:      if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (px, &nx))
    #####:  405:          || ECMA_IS_VALUE_ERROR (ecma_op_to_number (py, &ny)))
        -:  406:      {
    #####:  407:        ret_value = ECMA_VALUE_ERROR;
    #####:  408:        goto end;
        -:  409:      }
        -:  410:
        -:  411:      /* b. */
    #####:  412:      if (ecma_number_is_nan (nx)
    #####:  413:          || ecma_number_is_nan (ny))
        -:  414:      {
        -:  415:        /* c., d. */
    #####:  416:        ret_value = ECMA_VALUE_UNDEFINED;
        -:  417:      }
        -:  418:      else
        -:  419:      {
    #####:  420:        bool is_x_less_than_y = (nx < ny);
        -:  421:
        -:  422:#ifndef JERRY_NDEBUG
        -:  423:        bool is_x_less_than_y_check;
        -:  424:
    #####:  425:        if (nx == ny
    #####:  426:            || (ecma_number_is_zero (nx)
    #####:  427:                && ecma_number_is_zero (ny)))
        -:  428:        {
        -:  429:          /* e., f., g. */
    #####:  430:          is_x_less_than_y_check = false;
        -:  431:        }
    #####:  432:        else if (ecma_number_is_infinity (nx)
    #####:  433:                 && !ecma_number_is_negative (nx))
        -:  434:        {
        -:  435:          /* h. */
    #####:  436:          is_x_less_than_y_check = false;
        -:  437:        }
    #####:  438:        else if (ecma_number_is_infinity (ny)
    #####:  439:                 && !ecma_number_is_negative (ny))
        -:  440:        {
        -:  441:          /* i. */
    #####:  442:          is_x_less_than_y_check = true;
        -:  443:        }
    #####:  444:        else if (ecma_number_is_infinity (ny)
    #####:  445:                 && ecma_number_is_negative (ny))
        -:  446:        {
        -:  447:          /* j. */
    #####:  448:          is_x_less_than_y_check = false;
        -:  449:        }
    #####:  450:        else if (ecma_number_is_infinity (nx)
    #####:  451:                 && ecma_number_is_negative (nx))
        -:  452:        {
        -:  453:          /* k. */
    #####:  454:          is_x_less_than_y_check = true;
        -:  455:        }
        -:  456:        else
        -:  457:        {
        -:  458:          /* l. */
    #####:  459:          JERRY_ASSERT (!ecma_number_is_nan (nx)
        -:  460:                        && !ecma_number_is_infinity (nx));
    #####:  461:          JERRY_ASSERT (!ecma_number_is_nan (ny)
        -:  462:                        && !ecma_number_is_infinity (ny));
    #####:  463:          JERRY_ASSERT (!(ecma_number_is_zero (nx)
        -:  464:                        && ecma_number_is_zero (ny)));
        -:  465:
    #####:  466:          if (nx < ny)
        -:  467:          {
    #####:  468:            is_x_less_than_y_check = true;
        -:  469:          }
        -:  470:          else
        -:  471:          {
    #####:  472:            is_x_less_than_y_check = false;
        -:  473:          }
        -:  474:        }
        -:  475:
    #####:  476:        JERRY_ASSERT (is_x_less_than_y_check == is_x_less_than_y);
        -:  477:#endif /* !JERRY_NDEBUG */
        -:  478:
    #####:  479:        ret_value = ecma_make_boolean_value (is_x_less_than_y);
        -:  480:      }
        -:  481:#if JERRY_BUILTIN_BIGINT
        -:  482:    }
        -:  483:    else
        -:  484:    {
    #####:  485:      bool invert_result = false;
    #####:  486:      int compare_result = 0;
        -:  487:
    #####:  488:      if (!ecma_is_value_bigint (px))
        -:  489:      {
    #####:  490:        ecma_value_t tmp = px;
    #####:  491:        px = py;
    #####:  492:        py = tmp;
    #####:  493:        invert_result = true;
        -:  494:      }
        -:  495:
    #####:  496:      JERRY_ASSERT (ecma_is_value_bigint (px));
        -:  497:
    #####:  498:      if (ecma_is_value_bigint (py))
        -:  499:      {
    #####:  500:        compare_result = ecma_bigint_compare_to_bigint (px, py);
        -:  501:      }
    #####:  502:      else if (ecma_is_value_string (py))
        -:  503:      {
    #####:  504:        ret_value = ecma_bigint_parse_string_value (py, ECMA_BIGINT_PARSE_DISALLOW_SYNTAX_ERROR);
        -:  505:
    #####:  506:        if (!ECMA_IS_VALUE_ERROR (ret_value))
        -:  507:        {
    #####:  508:          if (ret_value == ECMA_VALUE_FALSE)
        -:  509:          {
    #####:  510:            ret_value = ECMA_VALUE_UNDEFINED;
        -:  511:          }
        -:  512:          else
        -:  513:          {
    #####:  514:            compare_result = ecma_bigint_compare_to_bigint (px, ret_value);
    #####:  515:            ecma_free_value (ret_value);
    #####:  516:            ret_value = ECMA_VALUE_EMPTY;
        -:  517:          }
        -:  518:        }
        -:  519:      }
        -:  520:      else
        -:  521:      {
    #####:  522:        ecma_number_t ny;
    #####:  523:        if (ECMA_IS_VALUE_ERROR (ecma_op_to_number (py, &ny)))
        -:  524:        {
    #####:  525:          ret_value = ECMA_VALUE_ERROR;
    #####:  526:          goto end;
        -:  527:        }
        -:  528:
    #####:  529:        if (ecma_number_is_nan (ny))
        -:  530:        {
    #####:  531:          ret_value = ECMA_VALUE_UNDEFINED;
        -:  532:        }
        -:  533:        else
        -:  534:        {
    #####:  535:          compare_result = ecma_bigint_compare_to_number (px, ny);
        -:  536:        }
        -:  537:      }
        -:  538:
    #####:  539:      if (ret_value == ECMA_VALUE_EMPTY)
        -:  540:      {
    #####:  541:        if (invert_result)
        -:  542:        {
    #####:  543:          compare_result = -compare_result;
        -:  544:        }
        -:  545:
    #####:  546:        ret_value = ecma_make_boolean_value (compare_result < 0);
        -:  547:      }
        -:  548:    }
        -:  549:#endif /* JERRY_BUILTIN_BIGINT */
        -:  550:  }
        -:  551:  else
        -:  552:  { /* 4. */
    #####:  553:    JERRY_ASSERT (is_px_string && is_py_string);
        -:  554:
    #####:  555:    ecma_string_t *str_x_p = ecma_get_string_from_value (px);
    #####:  556:    ecma_string_t *str_y_p = ecma_get_string_from_value (py);
        -:  557:
    #####:  558:    bool is_px_less = ecma_compare_ecma_strings_relational (str_x_p, str_y_p);
        -:  559:
    #####:  560:    ret_value = ecma_make_boolean_value (is_px_less);
        -:  561:  }
        -:  562:
    #####:  563:end:
    #####:  564:  ecma_free_value (prim_second_converted_value);
    #####:  565:  ecma_free_value (prim_first_converted_value);
        -:  566:
    #####:  567:  return ret_value;
        -:  568:} /* ecma_op_abstract_relational_compare */
        -:  569:
        -:  570:/**
        -:  571: * @}
        -:  572: * @}
        -:  573: */
