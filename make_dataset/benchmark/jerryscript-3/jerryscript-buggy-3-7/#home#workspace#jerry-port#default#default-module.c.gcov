        -:    0:Source:/home/workspace/jerry-port/default/default-module.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include <limits.h>
        -:   17:#include <stdarg.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:#include <sys/stat.h>
        -:   21:
        -:   22:#include "jerryscript-port.h"
        -:   23:#include "jerryscript-port-default.h"
        -:   24:
        -:   25:#ifndef S_ISDIR
        -:   26:#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
        -:   27:#endif
        -:   28:
        -:   29:/**
        -:   30: * Determines the size of the given file.
        -:   31: * @return size of the file
        -:   32: */
        -:   33:static size_t
        1:   34:jerry_port_get_file_size (FILE *file_p) /**< opened file */
        -:   35:{
        1:   36:  fseek (file_p, 0, SEEK_END);
        1:   37:  long size = ftell (file_p);
        1:   38:  fseek (file_p, 0, SEEK_SET);
        -:   39:
        1:   40:  return (size_t) size;
        -:   41:} /* jerry_port_get_file_size */
        -:   42:
        -:   43:/**
        -:   44: * Opens file with the given path and reads its source.
        -:   45: * @return the source of the file
        -:   46: */
        -:   47:uint8_t *
        1:   48:jerry_port_read_source (const char *file_name_p, /**< file name */
        -:   49:                        size_t *out_size_p) /**< [out] read bytes */
        -:   50:{
        1:   51:  struct stat stat_buffer;
        1:   52:  if (stat (file_name_p, &stat_buffer) == -1 || S_ISDIR (stat_buffer.st_mode))
        -:   53:  {
    #####:   54:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: Failed to open file: %s\n", file_name_p);
    #####:   55:    return NULL;
        -:   56:  }
        -:   57:
        1:   58:  FILE *file_p = fopen (file_name_p, "rb");
        -:   59:
        1:   60:  if (file_p == NULL)
        -:   61:  {
    #####:   62:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: Failed to open file: %s\n", file_name_p);
    #####:   63:    return NULL;
        -:   64:  }
        -:   65:
        1:   66:  size_t file_size = jerry_port_get_file_size (file_p);
        1:   67:  uint8_t *buffer_p = (uint8_t *) malloc (file_size);
        -:   68:
        1:   69:  if (buffer_p == NULL)
        -:   70:  {
    #####:   71:    fclose (file_p);
        -:   72:
    #####:   73:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: Failed to allocate memory for file: %s\n", file_name_p);
    #####:   74:    return NULL;
        -:   75:  }
        -:   76:
        1:   77:  size_t bytes_read = fread (buffer_p, 1u, file_size, file_p);
        -:   78:
        1:   79:  if (bytes_read != file_size)
        -:   80:  {
    #####:   81:    fclose (file_p);
    #####:   82:    free (buffer_p);
        -:   83:
    #####:   84:    jerry_port_log (JERRY_LOG_LEVEL_ERROR, "Error: Failed to read file: %s\n", file_name_p);
    #####:   85:    return NULL;
        -:   86:  }
        -:   87:
        1:   88:  fclose (file_p);
        1:   89:  *out_size_p = bytes_read;
        -:   90:
        1:   91:  return buffer_p;
        -:   92:} /* jerry_port_read_source */
        -:   93:
        -:   94:/**
        -:   95: * Release the previously opened file's content.
        -:   96: */
        -:   97:void
        1:   98:jerry_port_release_source (uint8_t *buffer_p) /**< buffer to free */
        -:   99:{
        1:  100:  free (buffer_p);
        1:  101:} /* jerry_port_release_source */
        -:  102:
        -:  103:/**
        -:  104: * Computes the end of the directory part of a path.
        -:  105: *
        -:  106: * @return end of the directory part of a path.
        -:  107: */
        -:  108:static size_t
    #####:  109:jerry_port_get_directory_end (const jerry_char_t *path_p) /**< path */
        -:  110:{
    #####:  111:  const jerry_char_t *end_p = path_p + strlen ((const char *) path_p);
        -:  112:
    #####:  113:  while (end_p > path_p)
        -:  114:  {
        -:  115:#if defined (_WIN32)
        -:  116:    if (end_p[-1] == '/' || end_p[-1] == '\\')
        -:  117:    {
        -:  118:      return (size_t) (end_p - path_p);
        -:  119:    }
        -:  120:#else /* !_WIN32 */
    #####:  121:    if (end_p[-1] == '/')
        -:  122:    {
    #####:  123:      return (size_t) (end_p - path_p);
        -:  124:    }
        -:  125:#endif /* _WIN32 */
        -:  126:
    #####:  127:    end_p--;
        -:  128:  }
        -:  129:
    #####:  130:  return 0;
        -:  131:} /* jerry_port_get_directory_end */
        -:  132:
        -:  133:/**
        -:  134: * Normalize a file path.
        -:  135: *
        -:  136: * @return a newly allocated buffer with the normalized path if the operation is successful,
        -:  137: *         NULL otherwise
        -:  138: */
        -:  139:static jerry_char_t *
    #####:  140:jerry_port_normalize_path (const jerry_char_t *in_path_p, /**< path to the referenced module */
        -:  141:                           size_t in_path_length, /**< length of the path */
        -:  142:                           const jerry_char_t *base_path_p, /**< base path */
        -:  143:                           size_t base_path_length) /**< length of the base path */
        -:  144:{
        -:  145:  char *path_p;
        -:  146:
    #####:  147:  if (base_path_length > 0)
        -:  148:  {
    #####:  149:    path_p = (char *) malloc (base_path_length + in_path_length + 1);
        -:  150:
    #####:  151:    if (path_p == NULL)
        -:  152:    {
    #####:  153:      return NULL;
        -:  154:    }
        -:  155:
    #####:  156:    memcpy (path_p, base_path_p, base_path_length);
    #####:  157:    memcpy (path_p + base_path_length, in_path_p, in_path_length);
    #####:  158:    path_p[base_path_length + in_path_length] = '\0';
        -:  159:  }
        -:  160:  else
        -:  161:  {
    #####:  162:    path_p = (char *) malloc (in_path_length + 1);
        -:  163:
    #####:  164:    if (path_p == NULL)
        -:  165:    {
    #####:  166:      return NULL;
        -:  167:    }
        -:  168:
    #####:  169:    memcpy (path_p, in_path_p, in_path_length);
    #####:  170:    path_p[in_path_length] = '\0';
        -:  171:  }
        -:  172:
        -:  173:#if defined (_WIN32)
        -:  174:  char full_path[_MAX_PATH];
        -:  175:
        -:  176:  if (_fullpath (full_path, path_p, _MAX_PATH) != NULL)
        -:  177:  {
        -:  178:    free (path_p);
        -:  179:
        -:  180:    size_t full_path_len = strlen (full_path);
        -:  181:
        -:  182:    path_p = (char *) malloc (full_path_len + 1);
        -:  183:
        -:  184:    if (path_p == NULL)
        -:  185:    {
        -:  186:      return NULL;
        -:  187:    }
        -:  188:
        -:  189:    memcpy (path_p, full_path, full_path_len + 1);
        -:  190:  }
        -:  191:#elif defined (__unix__) || defined (__APPLE__)
    #####:  192:  char *norm_p = realpath (path_p, NULL);
        -:  193:
    #####:  194:  if (norm_p != NULL)
        -:  195:  {
    #####:  196:    free (path_p);
    #####:  197:    path_p = norm_p;
        -:  198:  }
        -:  199:#endif /* _WIN32 */
        -:  200:
    #####:  201:  return (jerry_char_t *) path_p;
        -:  202:} /* jerry_port_normalize_path */
        -:  203:
        -:  204:/**
        -:  205: * A module descriptor.
        -:  206: */
        -:  207:typedef struct jerry_port_module_t
        -:  208:{
        -:  209:  struct jerry_port_module_t *next_p; /**< next_module */
        -:  210:  jerry_char_t *path_p; /**< path to the module */
        -:  211:  size_t base_path_length; /**< base path length for relative difference */
        -:  212:  jerry_value_t realm; /**< the realm of the module */
        -:  213:  jerry_value_t module; /**< the module itself */
        -:  214:} jerry_port_module_t;
        -:  215:
        -:  216:/**
        -:  217: * Native info descriptor for modules.
        -:  218: */
        -:  219:static const jerry_object_native_info_t jerry_port_module_native_info =
        -:  220:{
        -:  221:  .free_cb = NULL,
        -:  222:};
        -:  223:
        -:  224:/**
        -:  225: * Default module manager.
        -:  226: */
        -:  227:typedef struct
        -:  228:{
        -:  229:  jerry_port_module_t *module_head_p; /**< first module */
        -:  230:} jerry_port_module_manager_t;
        -:  231:
        -:  232:/**
        -:  233: * Release known modules.
        -:  234: */
        -:  235:static void
    #####:  236:jerry_port_module_free (jerry_port_module_manager_t *manager_p, /**< module manager */
        -:  237:                        const jerry_value_t realm) /**< if this argument is object, release only those modules,
        -:  238:                                                    *   which realm value is equal to this argument. */
        -:  239:{
    #####:  240:  jerry_port_module_t *module_p = manager_p->module_head_p;
        -:  241:
    #####:  242:  bool release_all = !jerry_value_is_object (realm);
        -:  243:
    #####:  244:  jerry_port_module_t *prev_p = NULL;
        -:  245:
    #####:  246:  while (module_p != NULL)
        -:  247:  {
    #####:  248:    jerry_port_module_t *next_p = module_p->next_p;
        -:  249:
    #####:  250:    if (release_all || module_p->realm == realm)
        -:  251:    {
    #####:  252:      free (module_p->path_p);
    #####:  253:      jerry_release_value (module_p->realm);
    #####:  254:      jerry_release_value (module_p->module);
        -:  255:
    #####:  256:      free (module_p);
        -:  257:
    #####:  258:      if (prev_p == NULL)
        -:  259:      {
    #####:  260:        manager_p->module_head_p = next_p;
        -:  261:      }
        -:  262:      else
        -:  263:      {
    #####:  264:        prev_p->next_p = next_p;
        -:  265:      }
        -:  266:    }
        -:  267:    else
        -:  268:    {
    #####:  269:      prev_p = module_p;
        -:  270:    }
        -:  271:
    #####:  272:    module_p = next_p;
        -:  273:  }
    #####:  274:} /* jerry_port_module_free */
        -:  275:
        -:  276:/**
        -:  277: * Initialize the default module manager.
        -:  278: */
        -:  279:static void
    #####:  280:jerry_port_module_manager_init (void *user_data_p)
        -:  281:{
    #####:  282:  ((jerry_port_module_manager_t *) user_data_p)->module_head_p = NULL;
    #####:  283:} /* jerry_port_module_manager_init */
        -:  284:
        -:  285:/**
        -:  286: * Deinitialize the default module manager.
        -:  287: */
        -:  288:static void
    #####:  289:jerry_port_module_manager_deinit (void *user_data_p) /**< context pointer to deinitialize */
        -:  290:{
    #####:  291:  jerry_value_t undef = jerry_create_undefined ();
    #####:  292:  jerry_port_module_free ((jerry_port_module_manager_t *) user_data_p, undef);
    #####:  293:  jerry_release_value (undef);
    #####:  294:} /* jerry_port_module_manager_deinit */
        -:  295:
        -:  296:/**
        -:  297: * Declare the context data manager for modules.
        -:  298: */
        -:  299:static const jerry_context_data_manager_t jerry_port_module_manager =
        -:  300:{
        -:  301:  .init_cb = jerry_port_module_manager_init,
        -:  302:  .deinit_cb = jerry_port_module_manager_deinit,
        -:  303:  .bytes_needed = sizeof (jerry_port_module_manager_t)
        -:  304:};
        -:  305:
        -:  306:/**
        -:  307: * Default module resolver.
        -:  308: *
        -:  309: * @return a module object if resolving is successful, an error otherwise
        -:  310: */
        -:  311:jerry_value_t
    #####:  312:jerry_port_module_resolve (const jerry_value_t specifier, /**< module specifier string */
        -:  313:                           const jerry_value_t referrer, /**< parent module */
        -:  314:                           void *user_p) /**< user data */
        -:  315:{
        -:  316:  (void) user_p;
        -:  317:
    #####:  318:  jerry_port_module_t *module_p;
    #####:  319:  const jerry_char_t *base_path_p = NULL;
    #####:  320:  size_t base_path_length = 0;
        -:  321:
    #####:  322:  if (jerry_get_object_native_pointer (referrer, (void **) &module_p, &jerry_port_module_native_info))
        -:  323:  {
    #####:  324:    base_path_p = module_p->path_p;
    #####:  325:    base_path_length = module_p->base_path_length;
        -:  326:  }
        -:  327:
    #####:  328:  jerry_size_t in_path_length = jerry_get_utf8_string_size (specifier);
    #####:  329:  jerry_char_t *in_path_p = (jerry_char_t *) malloc (in_path_length + 1);
    #####:  330:  jerry_string_to_utf8_char_buffer (specifier, in_path_p, in_path_length);
    #####:  331:  in_path_p[in_path_length] = '\0';
        -:  332:
    #####:  333:  jerry_char_t *path_p = jerry_port_normalize_path (in_path_p, in_path_length, base_path_p, base_path_length);
        -:  334:
    #####:  335:  if (path_p == NULL)
        -:  336:  {
    #####:  337:    return jerry_create_error (JERRY_ERROR_COMMON, (const jerry_char_t *) "Out of memory");
        -:  338:  }
        -:  339:
    #####:  340:  jerry_value_t realm = jerry_get_global_object ();
        -:  341:
        -:  342:  jerry_port_module_manager_t *manager_p;
    #####:  343:  manager_p = (jerry_port_module_manager_t *) jerry_get_context_data (&jerry_port_module_manager);
        -:  344:
    #####:  345:  module_p = manager_p->module_head_p;
        -:  346:
    #####:  347:  while (module_p != NULL)
        -:  348:  {
    #####:  349:    if (module_p->realm == realm
    #####:  350:        && strcmp ((const char *) module_p->path_p, (const char *) path_p) == 0)
        -:  351:    {
    #####:  352:      free (path_p);
    #####:  353:      free (in_path_p);
    #####:  354:      jerry_release_value (realm);
    #####:  355:      return jerry_acquire_value (module_p->module);
        -:  356:    }
        -:  357:
    #####:  358:    module_p = module_p->next_p;
        -:  359:  }
        -:  360:
    #####:  361:  size_t source_size;
    #####:  362:  uint8_t *source_p = jerry_port_read_source ((const char *) path_p, &source_size);
        -:  363:
    #####:  364:  if (source_p == NULL)
        -:  365:  {
    #####:  366:    free (path_p);
    #####:  367:    free (in_path_p);
    #####:  368:    jerry_release_value (realm);
        -:  369:    /* TODO: This is incorrect, but makes test262 module tests pass
        -:  370:     * (they should throw SyntaxError, but not because the module cannot be found). */
    #####:  371:    return jerry_create_error (JERRY_ERROR_SYNTAX, (const jerry_char_t *) "Module file not found");
        -:  372:  }
        -:  373:
    #####:  374:  jerry_parse_options_t parse_options;
    #####:  375:  parse_options.options = JERRY_PARSE_MODULE | JERRY_PARSE_HAS_RESOURCE;
    #####:  376:  parse_options.resource_name = jerry_create_string_sz ((const jerry_char_t *) in_path_p, in_path_length);
        -:  377:
    #####:  378:  jerry_value_t ret_value = jerry_parse (source_p,
        -:  379:                                         source_size,
        -:  380:                                         &parse_options);
    #####:  381:  jerry_release_value (parse_options.resource_name);
        -:  382:
    #####:  383:  jerry_port_release_source (source_p);
    #####:  384:  free (in_path_p);
        -:  385:
    #####:  386:  if (jerry_value_is_error (ret_value))
        -:  387:  {
    #####:  388:    free (path_p);
    #####:  389:    jerry_release_value (realm);
    #####:  390:    return ret_value;
        -:  391:  }
        -:  392:
    #####:  393:  module_p = (jerry_port_module_t *) malloc (sizeof (jerry_port_module_t));
        -:  394:
    #####:  395:  module_p->next_p = manager_p->module_head_p;
    #####:  396:  module_p->path_p = path_p;
    #####:  397:  module_p->base_path_length = jerry_port_get_directory_end (module_p->path_p);
    #####:  398:  module_p->realm = realm;
    #####:  399:  module_p->module = jerry_acquire_value (ret_value);
        -:  400:
    #####:  401:  jerry_set_object_native_pointer (ret_value, module_p, &jerry_port_module_native_info);
    #####:  402:  manager_p->module_head_p = module_p;
        -:  403:
    #####:  404:  return ret_value;
        -:  405:} /* jerry_port_module_resolve */
        -:  406:
        -:  407:/**
        -:  408: * Release known modules.
        -:  409: */
        -:  410:void
    #####:  411:jerry_port_module_release (const jerry_value_t realm) /**< if this argument is object, release only those modules,
        -:  412:                                                       *   which realm value is equal to this argument. */
        -:  413:{
    #####:  414:  jerry_port_module_free ((jerry_port_module_manager_t *) jerry_get_context_data (&jerry_port_module_manager),
        -:  415:                          realm);
    #####:  416:} /* jerry_port_module_release */
