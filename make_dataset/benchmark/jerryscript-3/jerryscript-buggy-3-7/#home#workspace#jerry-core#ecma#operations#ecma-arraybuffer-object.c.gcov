        -:    0:Source:/home/workspace/jerry-core/ecma/operations/ecma-arraybuffer-object.c
        -:    0:Programs:291
        -:    1:/* Copyright JS Foundation and other contributors, http://js.foundation
        -:    2: *
        -:    3: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    4: * you may not use this file except in compliance with the License.
        -:    5: * You may obtain a copy of the License at
        -:    6: *
        -:    7: *     http://www.apache.org/licenses/LICENSE-2.0
        -:    8: *
        -:    9: * Unless required by applicable law or agreed to in writing, software
        -:   10: * distributed under the License is distributed on an "AS IS" BASIS
        -:   11: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   12: * See the License for the specific language governing permissions and
        -:   13: * limitations under the License.
        -:   14: */
        -:   15:
        -:   16:#include "ecma-builtin-helpers.h"
        -:   17:#include "ecma-arraybuffer-object.h"
        -:   18:#include "ecma-shared-arraybuffer-object.h"
        -:   19:#include "ecma-typedarray-object.h"
        -:   20:#include "ecma-objects.h"
        -:   21:#include "ecma-builtins.h"
        -:   22:#include "ecma-exceptions.h"
        -:   23:#include "ecma-gc.h"
        -:   24:#include "ecma-globals.h"
        -:   25:#include "ecma-helpers.h"
        -:   26:#include "jmem.h"
        -:   27:#include "jcontext.h"
        -:   28:#include "ecma-function-object.h"
        -:   29:
        -:   30:#if JERRY_BUILTIN_TYPEDARRAY
        -:   31:
        -:   32:/** \addtogroup ecma ECMA
        -:   33: * @{
        -:   34: *
        -:   35: * \addtogroup ecmaarraybufferobject ECMA ArrayBuffer object related routines
        -:   36: * @{
        -:   37: */
        -:   38:
        -:   39:/**
        -:   40: * Helper function: create arraybuffer object based on the array length
        -:   41: *
        -:   42: * The struct of arraybuffer object:
        -:   43: *   ecma_object_t
        -:   44: *   extend_part
        -:   45: *   data buffer
        -:   46: *
        -:   47: * @return ecma_object_t *
        -:   48: */
        -:   49:ecma_object_t *
    #####:   50:ecma_arraybuffer_new_object (uint32_t length) /**< length of the arraybuffer */
        -:   51:{
    #####:   52:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE);
    #####:   53:  ecma_object_t *object_p = ecma_create_object (prototype_obj_p,
        -:   54:                                                sizeof (ecma_extended_object_t) + length,
        -:   55:                                                ECMA_OBJECT_TYPE_CLASS);
        -:   56:
    #####:   57:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:   58:  ext_object_p->u.cls.type = ECMA_OBJECT_CLASS_ARRAY_BUFFER;
    #####:   59:  ext_object_p->u.cls.u1.array_buffer_flags = ECMA_ARRAYBUFFER_INTERNAL_MEMORY;
    #####:   60:  ext_object_p->u.cls.u3.length = length;
        -:   61:
    #####:   62:  lit_utf8_byte_t *buf = (lit_utf8_byte_t *) (ext_object_p + 1);
    #####:   63:  memset (buf, 0, length);
        -:   64:
    #####:   65:  return object_p;
        -:   66:} /* ecma_arraybuffer_new_object */
        -:   67:
        -:   68:/**
        -:   69: * Helper function: create arraybuffer object with external buffer backing.
        -:   70: *
        -:   71: * The struct of external arraybuffer object:
        -:   72: *   ecma_object_t
        -:   73: *   extend_part
        -:   74: *   arraybuffer external info part
        -:   75: *
        -:   76: * @return ecma_object_t *, pointer to the created ArrayBuffer object
        -:   77: */
        -:   78:ecma_object_t *
    #####:   79:ecma_arraybuffer_new_object_external (uint32_t length, /**< length of the buffer_p to use */
        -:   80:                                      void *buffer_p, /**< pointer for ArrayBuffer's buffer backing */
        -:   81:                                      jerry_value_free_callback_t free_cb) /**< buffer free callback */
        -:   82:{
    #####:   83:  ecma_object_t *prototype_obj_p = ecma_builtin_get (ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE);
    #####:   84:  ecma_object_t *object_p = ecma_create_object (prototype_obj_p,
        -:   85:                                                sizeof (ecma_arraybuffer_external_info),
        -:   86:                                                ECMA_OBJECT_TYPE_CLASS);
        -:   87:
    #####:   88:  ecma_arraybuffer_external_info *array_object_p = (ecma_arraybuffer_external_info *) object_p;
    #####:   89:  array_object_p->extended_object.u.cls.type = ECMA_OBJECT_CLASS_ARRAY_BUFFER;
    #####:   90:  array_object_p->extended_object.u.cls.u1.array_buffer_flags = ECMA_ARRAYBUFFER_EXTERNAL_MEMORY;
    #####:   91:  array_object_p->extended_object.u.cls.u3.length = length;
        -:   92:
    #####:   93:  array_object_p->buffer_p = buffer_p;
    #####:   94:  array_object_p->free_cb = free_cb;
        -:   95:
    #####:   96:  return object_p;
        -:   97:} /* ecma_arraybuffer_new_object_external */
        -:   98:
        -:   99:/**
        -:  100: * ArrayBuffer object creation operation.
        -:  101: *
        -:  102: * See also: ES2015 24.1.1.1
        -:  103: *
        -:  104: * @return ecma value
        -:  105: *         Returned value must be freed with ecma_free_value
        -:  106: */
        -:  107:ecma_value_t
    #####:  108:ecma_op_create_arraybuffer_object (const ecma_value_t *arguments_list_p, /**< list of arguments that
        -:  109:                                                                          *   are passed to String constructor */
        -:  110:                                   uint32_t arguments_list_len) /**< length of the arguments' list */
        -:  111:{
    #####:  112:  JERRY_ASSERT (arguments_list_len == 0 || arguments_list_p != NULL);
        -:  113:
    #####:  114:  ecma_object_t *proto_p = ecma_op_get_prototype_from_constructor (JERRY_CONTEXT (current_new_target_p),
        -:  115:                                                                   ECMA_BUILTIN_ID_ARRAYBUFFER_PROTOTYPE);
        -:  116:
    #####:  117:  if (proto_p == NULL)
        -:  118:  {
    #####:  119:    return ECMA_VALUE_ERROR;
        -:  120:  }
        -:  121:
    #####:  122:  ecma_number_t length_num = 0;
        -:  123:
    #####:  124:  if (arguments_list_len > 0)
        -:  125:  {
        -:  126:
    #####:  127:    if (ecma_is_value_number (arguments_list_p[0]))
        -:  128:    {
    #####:  129:      length_num = ecma_get_number_from_value (arguments_list_p[0]);
        -:  130:    }
        -:  131:    else
        -:  132:    {
    #####:  133:      ecma_value_t to_number_value = ecma_op_to_number (arguments_list_p[0], &length_num);
        -:  134:
    #####:  135:      if (ECMA_IS_VALUE_ERROR (to_number_value))
        -:  136:      {
    #####:  137:        ecma_deref_object (proto_p);
    #####:  138:        return to_number_value;
        -:  139:      }
        -:  140:    }
        -:  141:
    #####:  142:    if (ecma_number_is_nan (length_num))
        -:  143:    {
    #####:  144:      length_num = 0;
        -:  145:    }
        -:  146:
    #####:  147:    const uint32_t maximum_size_in_byte = UINT32_MAX - sizeof (ecma_extended_object_t) - JMEM_ALIGNMENT + 1;
        -:  148:
    #####:  149:    if (length_num <= -1.0 || length_num > (ecma_number_t) maximum_size_in_byte + 0.5)
        -:  150:    {
    #####:  151:      ecma_deref_object (proto_p);
    #####:  152:      return ecma_raise_range_error (ECMA_ERR_MSG ("Invalid ArrayBuffer length"));
        -:  153:    }
        -:  154:  }
        -:  155:
    #####:  156:  uint32_t length_uint32 = ecma_number_to_uint32 (length_num);
        -:  157:
    #####:  158:  ecma_object_t *array_buffer = ecma_arraybuffer_new_object (length_uint32);
    #####:  159:  ECMA_SET_NON_NULL_POINTER (array_buffer->u2.prototype_cp, proto_p);
    #####:  160:  ecma_deref_object (proto_p);
        -:  161:
    #####:  162:  return ecma_make_object_value (array_buffer);
        -:  163:} /* ecma_op_create_arraybuffer_object */
        -:  164:
        -:  165:/**
        -:  166: * Helper function: check if the target is ArrayBuffer
        -:  167: *
        -:  168: *
        -:  169: * See also: ES2015 24.1.1.4
        -:  170: *
        -:  171: * @return true - if value is an ArrayBuffer object
        -:  172: *         false - otherwise
        -:  173: */
        -:  174:bool
    #####:  175:ecma_is_arraybuffer (ecma_value_t target) /**< the target value */
        -:  176:{
    #####:  177:  return (ecma_is_value_object (target)
    #####:  178:          && ecma_object_class_is (ecma_get_object_from_value (target), ECMA_OBJECT_CLASS_ARRAY_BUFFER));
        -:  179:} /* ecma_is_arraybuffer */
        -:  180:
        -:  181:/**
        -:  182: * Helper function: return the length of the buffer inside the arraybuffer object
        -:  183: *
        -:  184: * @return uint32_t, the length of the arraybuffer
        -:  185: */
        -:  186:uint32_t JERRY_ATTR_PURE
    #####:  187:ecma_arraybuffer_get_length (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  188:{
    #####:  189:  JERRY_ASSERT (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
        -:  190:                || ecma_object_is_shared_arraybuffer (object_p));
        -:  191:
    #####:  192:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  193:  return ecma_arraybuffer_is_detached (object_p) ? 0 : ext_object_p->u.cls.u3.length;
        -:  194:} /* ecma_arraybuffer_get_length */
        -:  195:
        -:  196:/**
        -:  197: * Helper function: return the pointer to the data buffer inside the arraybuffer object
        -:  198: *
        -:  199: * @return pointer to the data buffer
        -:  200: */
        -:  201:extern inline lit_utf8_byte_t * JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  202:ecma_arraybuffer_get_buffer (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  203:{
    #####:  204:  JERRY_ASSERT (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
        -:  205:                || ecma_object_is_shared_arraybuffer (object_p));
        -:  206:
    #####:  207:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
        -:  208:
    #####:  209:  if (ECMA_ARRAYBUFFER_HAS_EXTERNAL_MEMORY (ext_object_p))
        -:  210:  {
    #####:  211:    ecma_arraybuffer_external_info *array_p = (ecma_arraybuffer_external_info *) ext_object_p;
    #####:  212:    JERRY_ASSERT (!ecma_arraybuffer_is_detached (object_p) || array_p->buffer_p == NULL);
    #####:  213:    return (lit_utf8_byte_t *) array_p->buffer_p;
        -:  214:  }
    #####:  215:  else if (ext_object_p->u.cls.u1.array_buffer_flags & ECMA_ARRAYBUFFER_DETACHED)
        -:  216:  {
    #####:  217:    return NULL;
        -:  218:  }
        -:  219:
    #####:  220:  return (lit_utf8_byte_t *) (ext_object_p + 1);
        -:  221:} /* ecma_arraybuffer_get_buffer */
        -:  222:
        -:  223:/**
        -:  224: * Helper function: check if the target ArrayBuffer is detached
        -:  225: *
        -:  226: * @return true - if value is an detached ArrayBuffer object
        -:  227: *         false - otherwise
        -:  228: */
        -:  229:extern inline bool JERRY_ATTR_PURE JERRY_ATTR_ALWAYS_INLINE
    #####:  230:ecma_arraybuffer_is_detached (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  231:{
    #####:  232:  JERRY_ASSERT (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
        -:  233:                || ecma_object_is_shared_arraybuffer (object_p));
        -:  234:
    #####:  235:  return (((ecma_extended_object_t *) object_p)->u.cls.u1.array_buffer_flags & ECMA_ARRAYBUFFER_DETACHED) != 0;
        -:  236:} /* ecma_arraybuffer_is_detached */
        -:  237:
        -:  238:/**
        -:  239: * ArrayBuffer object detaching operation
        -:  240: *
        -:  241: * See also: ES2015 24.1.1.3
        -:  242: *
        -:  243: * @return true - if detach op succeeded
        -:  244: *         false - otherwise
        -:  245: */
        -:  246:extern inline bool JERRY_ATTR_ALWAYS_INLINE
    #####:  247:ecma_arraybuffer_detach (ecma_object_t *object_p) /**< pointer to the ArrayBuffer object */
        -:  248:{
    #####:  249:  JERRY_ASSERT (ecma_object_class_is (object_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER));
        -:  250:
    #####:  251:  if (ecma_arraybuffer_is_detached (object_p))
        -:  252:  {
    #####:  253:    return false;
        -:  254:  }
        -:  255:
    #####:  256:  ecma_extended_object_t *ext_object_p = (ecma_extended_object_t *) object_p;
    #####:  257:  ext_object_p->u.cls.u1.array_buffer_flags |= ECMA_ARRAYBUFFER_DETACHED;
        -:  258:
    #####:  259:  if (ECMA_ARRAYBUFFER_HAS_EXTERNAL_MEMORY (ext_object_p))
        -:  260:  {
    #####:  261:    ecma_arraybuffer_external_info *array_p = (ecma_arraybuffer_external_info *) ext_object_p;
        -:  262:
    #####:  263:    if (array_p->free_cb != NULL)
        -:  264:    {
    #####:  265:      array_p->free_cb (array_p->buffer_p);
    #####:  266:      array_p->free_cb = NULL;
        -:  267:    }
        -:  268:
    #####:  269:    ext_object_p->u.cls.u3.length = 0;
    #####:  270:    array_p->buffer_p = NULL;
        -:  271:  }
        -:  272:
    #####:  273:  return true;
        -:  274:} /* ecma_arraybuffer_detach */
        -:  275:
        -:  276:ecma_value_t
    #####:  277:ecma_builtin_arraybuffer_slice (ecma_value_t this_arg,
        -:  278:                                const ecma_value_t *argument_list_p,
        -:  279:                                uint32_t arguments_number)
        -:  280:{
    #####:  281:  ecma_object_t *object_p = ecma_get_object_from_value (this_arg);
        -:  282:
        -:  283:  /* 4. */
    #####:  284:  if (ecma_arraybuffer_is_detached (object_p))
        -:  285:  {
    #####:  286:    return ecma_raise_type_error (ECMA_ERR_MSG (ecma_error_arraybuffer_is_detached));
        -:  287:  }
        -:  288:
        -:  289:  /* 5. */
    #####:  290:  uint32_t len = ecma_arraybuffer_get_length (object_p);
        -:  291:
    #####:  292:  uint32_t start = 0;
    #####:  293:  uint32_t end = len;
        -:  294:
    #####:  295:  if (arguments_number > 0)
        -:  296:  {
        -:  297:    /* 6-7. */
    #####:  298:    if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (argument_list_p[0],
        -:  299:                                                                         len,
        -:  300:                                                                         &start)))
        -:  301:    {
    #####:  302:      return ECMA_VALUE_ERROR;
        -:  303:    }
        -:  304:
    #####:  305:    if (arguments_number > 1 && !ecma_is_value_undefined (argument_list_p[1]))
        -:  306:    {
        -:  307:      /* 8-9. */
    #####:  308:      if (ECMA_IS_VALUE_ERROR (ecma_builtin_helper_uint32_index_normalize (argument_list_p[1],
        -:  309:                                                                           len,
        -:  310:                                                                           &end)))
        -:  311:      {
    #####:  312:        return ECMA_VALUE_ERROR;
        -:  313:      }
        -:  314:    }
        -:  315:  }
        -:  316:
        -:  317:  /* 10. */
    #####:  318:  uint32_t new_len = (end >= start) ? (end - start) : 0;
        -:  319:
        -:  320:  /* 11. */
    #####:  321:  ecma_builtin_id_t buffer_builtin_id = ECMA_BUILTIN_ID_ARRAYBUFFER;
        -:  322:
    #####:  323:  if (ecma_is_shared_arraybuffer (this_arg))
        -:  324:  {
    #####:  325:    buffer_builtin_id = ECMA_BUILTIN_ID_SHARED_ARRAYBUFFER;
        -:  326:  }
        -:  327:
    #####:  328:  ecma_value_t ctor = ecma_op_species_constructor (object_p, buffer_builtin_id);
        -:  329:
    #####:  330:  if (ECMA_IS_VALUE_ERROR (ctor))
        -:  331:  {
    #####:  332:    return ctor;
        -:  333:  }
        -:  334:
        -:  335:  /* 12. */
    #####:  336:  ecma_object_t *ctor_obj_p = ecma_get_object_from_value (ctor);
    #####:  337:  ecma_value_t new_len_value = ecma_make_uint32_value (new_len);
        -:  338:
    #####:  339:  ecma_value_t new_arraybuffer = ecma_op_function_construct (ctor_obj_p, ctor_obj_p, &new_len_value, 1);
        -:  340:
    #####:  341:  ecma_deref_object (ctor_obj_p);
    #####:  342:  ecma_free_value (new_len_value);
        -:  343:
    #####:  344:  if (ECMA_IS_VALUE_ERROR (new_arraybuffer))
        -:  345:  {
    #####:  346:    return new_arraybuffer;
        -:  347:  }
        -:  348:
    #####:  349:  ecma_object_t *new_arraybuffer_p = ecma_get_object_from_value (new_arraybuffer);
    #####:  350:  ecma_value_t ret_value = ECMA_VALUE_EMPTY;
        -:  351:
        -:  352:  /* 13. */
    #####:  353:  if (!(ecma_object_class_is (new_arraybuffer_p, ECMA_OBJECT_CLASS_ARRAY_BUFFER)
    #####:  354:        || ecma_object_is_shared_arraybuffer (new_arraybuffer_p)))
        -:  355:  {
    #####:  356:    ret_value = ecma_raise_type_error (ECMA_ERR_MSG ("Return value is not an ArrayBuffer object"));
    #####:  357:    goto free_new_arraybuffer;
        -:  358:  }
        -:  359:
        -:  360:  /* 14-15. */
    #####:  361:  if (ecma_arraybuffer_is_detached (new_arraybuffer_p))
        -:  362:  {
    #####:  363:    ret_value = ecma_raise_type_error (ECMA_ERR_MSG ("Returned ArrayBuffer has been detached"));
    #####:  364:    goto free_new_arraybuffer;
        -:  365:  }
        -:  366:
        -:  367:  /* 16. */
    #####:  368:  if (new_arraybuffer == this_arg)
        -:  369:  {
    #####:  370:    ret_value = ecma_raise_type_error (ECMA_ERR_MSG ("ArrayBuffer subclass returned this from species constructor"));
    #####:  371:    goto free_new_arraybuffer;
        -:  372:  }
        -:  373:
        -:  374:  /* 17. */
    #####:  375:  if (ecma_arraybuffer_get_length (new_arraybuffer_p) < new_len)
        -:  376:  {
    #####:  377:    ret_value = ecma_raise_type_error (ECMA_ERR_MSG ("Derived ArrayBuffer constructor created a too small buffer"));
    #####:  378:    goto free_new_arraybuffer;
        -:  379:  }
        -:  380:
        -:  381:  /* 19. */
    #####:  382:  if (ecma_arraybuffer_is_detached (object_p))
        -:  383:  {
    #####:  384:    ret_value = ecma_raise_type_error (ECMA_ERR_MSG ("Original ArrayBuffer has been detached"));
    #####:  385:    goto free_new_arraybuffer;
        -:  386:  }
        -:  387:
        -:  388:  /* 20. */
    #####:  389:  lit_utf8_byte_t *old_buf = ecma_arraybuffer_get_buffer (object_p);
        -:  390:
        -:  391:  /* 21. */
    #####:  392:  lit_utf8_byte_t *new_buf = ecma_arraybuffer_get_buffer (new_arraybuffer_p);
        -:  393:
        -:  394:  /* 22. */
    #####:  395:  memcpy (new_buf, old_buf + start, new_len);
        -:  396:
    #####:  397:  free_new_arraybuffer:
    #####:  398:  if (ret_value != ECMA_VALUE_EMPTY)
        -:  399:  {
    #####:  400:    ecma_deref_object (new_arraybuffer_p);
        -:  401:  }
        -:  402:  else
        -:  403:  {
        -:  404:    /* 23. */
    #####:  405:    ret_value = ecma_make_object_value (new_arraybuffer_p);
        -:  406:  }
        -:  407:
    #####:  408:  return ret_value;
        -:  409:} /* ecma_builtin_arraybuffer_slice */
        -:  410:
        -:  411:/**
        -:  412: * @}
        -:  413: * @}
        -:  414: */
        -:  415:#endif /* JERRY_BUILTIN_TYPEDARRAY */
